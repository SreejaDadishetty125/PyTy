[
  {
    "project": "apache/airflow",
    "commit": "9844b910470feac9e524832a3affdc657c340bcd",
    "filename": "airflow/jobs/scheduler_job.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/apache-airflow/airflow/jobs/scheduler_job.py",
    "file_hunks_size": 22,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": true,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "airflow/jobs/scheduler_job.py:110:8 Incompatible variable type [9]: log is declared to have type `logging.Logger` but is used as type `None`.",
    "message": " log is declared to have type `logging.Logger` but is used as type `None`.",
    "rule_id": "Incompatible variable type [9]",
    "warning_line_no": 110,
    "warning_line": "        log: logging.Logger = None,",
    "min_patch": [
      {
        "hunk_fit_TFix": true,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "        do_pickle: bool = False,\n        log: logging.Logger = None,\n        processor_poll_interval: Optional[float] = None,\n",
        "source_code_len": 126,
        "target_code": "        do_pickle: bool = False,\n        log: Optional[logging.Logger] = None,\n        processor_poll_interval: Optional[float] = None,\n",
        "target_code_len": 136,
        "diff_format": "@@ -109,3 +108,3 @@\n         do_pickle: bool = False,\n-        log: logging.Logger = None,\n+        log: Optional[logging.Logger] = None,\n         processor_poll_interval: Optional[float] = None,\n",
        "source_code_with_indent": "        do_pickle: bool = False,\n        log: logging.Logger = None,\n        processor_poll_interval: Optional[float] = None,\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "        do_pickle: bool = False,\n        log: Optional[logging.Logger] = None,\n        processor_poll_interval: Optional[float] = None,\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "apache/airflow",
    "commit": "9844b910470feac9e524832a3affdc657c340bcd",
    "filename": "airflow/jobs/scheduler_job.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/apache-airflow/airflow/jobs/scheduler_job.py",
    "file_hunks_size": 22,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "airflow/jobs/scheduler_job.py:547:58 Incompatible parameter type [6]: Expected `Tuple[str, str, datetime.datetime]` for 1st positional only parameter to call `dict.__getitem__` but got `Tuple[str, str, str]`.",
    "message": " Expected `Tuple[str, str, datetime.datetime]` for 1st positional only parameter to call `dict.__getitem__` but got `Tuple[str, str, str]`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 547,
    "warning_line": "            try_number = ti_primary_key_to_try_number_map[ti.key.primary]",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "            raise ValueError(\"Processor agent is not started.\")\n        ti_primary_key_to_try_number_map: Dict[Tuple[str, str, datetime.datetime], int] = {}\n        event_buffer = self.executor.get_event_buffer()\n",
        "source_code_len": 213,
        "target_code": "            raise ValueError(\"Processor agent is not started.\")\n        ti_primary_key_to_try_number_map: Dict[Tuple[str, str, str], int] = {}\n        event_buffer = self.executor.get_event_buffer()\n",
        "target_code_len": 199,
        "diff_format": "@@ -508,3 +511,3 @@\n             raise ValueError(\"Processor agent is not started.\")\n-        ti_primary_key_to_try_number_map: Dict[Tuple[str, str, datetime.datetime], int] = {}\n+        ti_primary_key_to_try_number_map: Dict[Tuple[str, str, str], int] = {}\n         event_buffer = self.executor.get_event_buffer()\n",
        "source_code_with_indent": "            <IND>raise ValueError(\"Processor agent is not started.\")\n        <DED>ti_primary_key_to_try_number_map: Dict[Tuple[str, str, datetime.datetime], int] = {}\n        event_buffer = self.executor.get_event_buffer()\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "            <IND>raise ValueError(\"Processor agent is not started.\")\n        <DED>ti_primary_key_to_try_number_map: Dict[Tuple[str, str, str], int] = {}\n        event_buffer = self.executor.get_event_buffer()\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "apache/airflow",
    "commit": "9844b910470feac9e524832a3affdc657c340bcd",
    "filename": "airflow/jobs/scheduler_job.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/apache-airflow/airflow/jobs/scheduler_job.py",
    "file_hunks_size": 22,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": true,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "airflow/jobs/scheduler_job.py:746:64 Incompatible parameter type [6]: Expected `Variable[_typeshed.SupportsLessThanT (bound to _typeshed.SupportsLessThan)]` for 2nd positional only parameter to call `min` but got `Optional[float]`.",
    "message": " Expected `Variable[_typeshed.SupportsLessThanT (bound to _typeshed.SupportsLessThan)]` for 2nd positional only parameter to call `min` but got `Optional[float]`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 746,
    "warning_line": "                time.sleep(min(self._scheduler_idle_sleep_time, next_event))",
    "min_patch": [
      {
        "hunk_fit_TFix": true,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "                # usage when \"idle\"\n                time.sleep(min(self._scheduler_idle_sleep_time, next_event))\n\n",
        "source_code_len": 114,
        "target_code": "                # usage when \"idle\"\n                time.sleep(min(self._scheduler_idle_sleep_time, next_event if next_event else 0))\n\n",
        "target_code_len": 135,
        "diff_format": "@@ -745,3 +748,3 @@\n                 # usage when \"idle\"\n-                time.sleep(min(self._scheduler_idle_sleep_time, next_event))\n+                time.sleep(min(self._scheduler_idle_sleep_time, next_event if next_event else 0))\n \n",
        "source_code_with_indent": "                # usage when \"idle\"\n                <IND>time.sleep(min(self._scheduler_idle_sleep_time, next_event))\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "                # usage when \"idle\"\n                <IND>time.sleep(min(self._scheduler_idle_sleep_time, next_event if next_event else 0))\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "apache/airflow",
    "commit": "9844b910470feac9e524832a3affdc657c340bcd",
    "filename": "airflow/jobs/scheduler_job.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/apache-airflow/airflow/jobs/scheduler_job.py",
    "file_hunks_size": 22,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "airflow/jobs/scheduler_job.py:993:16 Incompatible return type [7]: Expected `int` but got implicit return value of `None`.",
    "message": " Expected `int` but got implicit return value of `None`.",
    "rule_id": "Incompatible return type [7]",
    "warning_line_no": 993,
    "warning_line": "                _update_state(dag, dag_run)",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "        session: Session,\n    ) -> int:\n        \"\"\"Find DagRuns in queued state and decide moving them to running state\"\"\"\n        dag_runs = self._get_next_dagruns_to_examine(State.QUEUED, session)\n\n",
        "source_code_len": 200,
        "target_code": "        session: Session,\n    ) -> None:\n        \"\"\"Find DagRuns in queued state and decide moving them to running state\"\"\"\n        dag_runs = self._get_next_dagruns_to_examine(DagRunState.QUEUED, session)\n\n",
        "target_code_len": 207,
        "diff_format": "@@ -953,5 +956,5 @@\n         session: Session,\n-    ) -> int:\n+    ) -> None:\n         \"\"\"Find DagRuns in queued state and decide moving them to running state\"\"\"\n-        dag_runs = self._get_next_dagruns_to_examine(State.QUEUED, session)\n+        dag_runs = self._get_next_dagruns_to_examine(DagRunState.QUEUED, session)\n \n",
        "source_code_with_indent": "        session: Session,\n    ) -> int:\n        <IND>\"\"\"Find DagRuns in queued state and decide moving them to running state\"\"\"\n        dag_runs = self._get_next_dagruns_to_examine(State.QUEUED, session)\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "        session: Session,\n    ) -> None:\n        <IND>\"\"\"Find DagRuns in queued state and decide moving them to running state\"\"\"\n        dag_runs = self._get_next_dagruns_to_examine(DagRunState.QUEUED, session)\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "apache/airflow",
    "commit": "9844b910470feac9e524832a3affdc657c340bcd",
    "filename": "airflow/jobs/scheduler_job.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/apache-airflow/airflow/jobs/scheduler_job.py",
    "file_hunks_size": 22,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "airflow/jobs/scheduler_job.py:1010:12 Incompatible return type [7]: Expected `Optional[DagCallbackRequest]` but got `int`.",
    "message": " Expected `Optional[DagCallbackRequest]` but got `int`.",
    "rule_id": "Incompatible return type [7]",
    "warning_line_no": 1010,
    "warning_line": "            return 0",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "        \"\"\"\n        dag = dag_run.dag = self.dagbag.get_dag(dag_run.dag_id, session=session)\n",
        "source_code_len": 93,
        "target_code": "        \"\"\"\n        callback: Optional[DagCallbackRequest] = None\n\n        dag = dag_run.dag = self.dagbag.get_dag(dag_run.dag_id, session=session)\n",
        "target_code_len": 148,
        "diff_format": "@@ -1005,2 +1008,4 @@\n         \"\"\"\n+        callback: Optional[DagCallbackRequest] = None\n+\n         dag = dag_run.dag = self.dagbag.get_dag(dag_run.dag_id, session=session)\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\n        dag = dag_run.dag = self.dagbag.get_dag(dag_run.dag_id, session=session)\n",
        "target_code_with_indent": "\n        callback: Optional[DagCallbackRequest] = None\n\n        dag = dag_run.dag = self.dagbag.get_dag(dag_run.dag_id, session=session)\n"
      },
      {
        "hunk_fit_TFix": true,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "            self.log.error(\"Couldn't find dag %s in DagBag/DB!\", dag_run.dag_id)\n            return 0\n        dag_model = DM.get_dagmodel(dag.dag_id, session)\n",
        "source_code_len": 159,
        "target_code": "            self.log.error(\"Couldn't find dag %s in DagBag/DB!\", dag_run.dag_id)\n            return callback\n        dag_model = DM.get_dagmodel(dag.dag_id, session)\n",
        "target_code_len": 166,
        "diff_format": "@@ -1009,3 +1014,3 @@\n             self.log.error(\"Couldn't find dag %s in DagBag/DB!\", dag_run.dag_id)\n-            return 0\n+            return callback\n         dag_model = DM.get_dagmodel(dag.dag_id, session)\n",
        "source_code_with_indent": "            <IND>self.log.error(\"Couldn't find dag %s in DagBag/DB!\", dag_run.dag_id)\n            return 0\n        <DED>dag_model = DM.get_dagmodel(dag.dag_id, session)\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "            <IND>self.log.error(\"Couldn't find dag %s in DagBag/DB!\", dag_run.dag_id)\n            return callback\n        <DED>dag_model = DM.get_dagmodel(dag.dag_id, session)\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "apache/airflow",
    "commit": "9844b910470feac9e524832a3affdc657c340bcd",
    "filename": "airflow/jobs/scheduler_job.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/apache-airflow/airflow/jobs/scheduler_job.py",
    "file_hunks_size": 22,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "airflow/jobs/scheduler_job.py:1046:12 Incompatible return type [7]: Expected `Optional[DagCallbackRequest]` but got `int`.",
    "message": " Expected `Optional[DagCallbackRequest]` but got `int`.",
    "rule_id": "Incompatible return type [7]",
    "warning_line_no": 1046,
    "warning_line": "            return 0",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "        \"\"\"\n        dag = dag_run.dag = self.dagbag.get_dag(dag_run.dag_id, session=session)\n",
        "source_code_len": 93,
        "target_code": "        \"\"\"\n        callback: Optional[DagCallbackRequest] = None\n\n        dag = dag_run.dag = self.dagbag.get_dag(dag_run.dag_id, session=session)\n",
        "target_code_len": 148,
        "diff_format": "@@ -1005,2 +1008,4 @@\n         \"\"\"\n+        callback: Optional[DagCallbackRequest] = None\n+\n         dag = dag_run.dag = self.dagbag.get_dag(dag_run.dag_id, session=session)\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\n        dag = dag_run.dag = self.dagbag.get_dag(dag_run.dag_id, session=session)\n",
        "target_code_with_indent": "\n        callback: Optional[DagCallbackRequest] = None\n\n        dag = dag_run.dag = self.dagbag.get_dag(dag_run.dag_id, session=session)\n"
      },
      {
        "hunk_fit_TFix": true,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "            self._send_dag_callbacks_to_processor(dag, callback_to_execute)\n\n            return 0\n\n",
        "source_code_len": 99,
        "target_code": "            self._send_dag_callbacks_to_processor(dag, callback_to_execute)\n            # Because we send the callback here, we need to return None\n            return callback\n\n",
        "target_code_len": 177,
        "diff_format": "@@ -1044,4 +1049,4 @@\n             self._send_dag_callbacks_to_processor(dag, callback_to_execute)\n-\n-            return 0\n+            # Because we send the callback here, we need to return None\n+            return callback\n \n",
        "source_code_with_indent": "            self._send_dag_callbacks_to_processor(dag, callback_to_execute)\n\n            return 0\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "            self._send_dag_callbacks_to_processor(dag, callback_to_execute)\n            # Because we send the callback here, we need to return None\n            return callback\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "apache/airflow",
    "commit": "9844b910470feac9e524832a3affdc657c340bcd",
    "filename": "airflow/jobs/scheduler_job.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/apache-airflow/airflow/jobs/scheduler_job.py",
    "file_hunks_size": 22,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "airflow/jobs/scheduler_job.py:1050:12 Incompatible return type [7]: Expected `Optional[DagCallbackRequest]` but got `int`.",
    "message": " Expected `Optional[DagCallbackRequest]` but got `int`.",
    "rule_id": "Incompatible return type [7]",
    "warning_line_no": 1050,
    "warning_line": "            return 0",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "        \"\"\"\n        dag = dag_run.dag = self.dagbag.get_dag(dag_run.dag_id, session=session)\n",
        "source_code_len": 93,
        "target_code": "        \"\"\"\n        callback: Optional[DagCallbackRequest] = None\n\n        dag = dag_run.dag = self.dagbag.get_dag(dag_run.dag_id, session=session)\n",
        "target_code_len": 148,
        "diff_format": "@@ -1005,2 +1008,4 @@\n         \"\"\"\n+        callback: Optional[DagCallbackRequest] = None\n+\n         dag = dag_run.dag = self.dagbag.get_dag(dag_run.dag_id, session=session)\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\n        dag = dag_run.dag = self.dagbag.get_dag(dag_run.dag_id, session=session)\n",
        "target_code_with_indent": "\n        callback: Optional[DagCallbackRequest] = None\n\n        dag = dag_run.dag = self.dagbag.get_dag(dag_run.dag_id, session=session)\n"
      },
      {
        "hunk_fit_TFix": true,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "            self.log.error(\"Execution date is in future: %s\", dag_run.execution_date)\n            return 0\n\n",
        "source_code_len": 108,
        "target_code": "            self.log.error(\"Execution date is in future: %s\", dag_run.execution_date)\n            return callback\n\n",
        "target_code_len": 115,
        "diff_format": "@@ -1049,3 +1054,3 @@\n             self.log.error(\"Execution date is in future: %s\", dag_run.execution_date)\n-            return 0\n+            return callback\n \n",
        "source_code_with_indent": "            <IND>self.log.error(\"Execution date is in future: %s\", dag_run.execution_date)\n            return 0\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "            <IND>self.log.error(\"Execution date is in future: %s\", dag_run.execution_date)\n            return callback\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  }
]