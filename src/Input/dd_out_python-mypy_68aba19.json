[
  {
    "project": "python/mypy",
    "commit": "68aba199c16634d0c4dc69984178a93231595fa8",
    "filename": "mypy/checker.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/python-mypy/mypy/checker.py",
    "file_hunks_size": 3,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "mypy/checker.py:1916:8 Incompatible return type [7]: Expected `Type` but got implicit return value of `None`.",
    "message": " Expected `Type` but got implicit return value of `None`.",
    "rule_id": "Incompatible return type [7]",
    "warning_line_no": 1916,
    "warning_line": "        self.check_subtype(actual_item_type, expected_item_type, e,",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "        subexpr_type = self.accept(e.expr, return_type)\n        if isinstance(subexpr_type, Instance):\n            if subexpr_type.type.fullname() == 'asyncio.futures.Future':\n                # if is a Future, in stmt don't need to do nothing\n                # because the type Future[Some] jus matters to the main loop\n                # that python executes, in statement we shouldn't get the Future,\n                # is just for async purposes.\n                self.function_stack[-1].is_coroutine = True  # Set the function as coroutine\n            elif is_subtype(subexpr_type, self.named_type('typing.Iterable')):\n                # If it's and Iterable-Like, let's check the types.\n                # Maybe just check if have __iter__? (like in analyze_iterable)\n                self.check_iterable_yield_from(e)\n            else:\n                self.msg.yield_from_invalid_operand_type(subexpr_type, e)\n        elif isinstance(subexpr_type, AnyType):\n            self.check_iterable_yield_from(e)\n        else:\n            self.msg.yield_from_invalid_operand_type(subexpr_type, e)\n\n        if (isinstance(subexpr_type, Instance) and\n                subexpr_type.type.fullname() == 'typing.Generator'):\n            return self.get_generator_return_type(subexpr_type)\n        else:\n            # non-Generators don't return anything from \"yield from\" expressions\n            return Void()\n\n    def check_iterable_yield_from(self, e: YieldFromExpr) -> Type:\n        \"\"\"\n            Check that return type is super type of Iterable (Maybe just check if have __iter__?)\n            and compare it with the type of the expression\n        \"\"\"\n        return_type = self.return_types[-1]\n        expected_item_type = self.get_generator_yield_type(return_type)\n        if e.expr is None:\n            actual_item_type = Void()  # type: Type\n        else:\n            actual_item_type = self.accept(e.expr, expected_item_type)\n            if hasattr(actual_item_type, 'args') and cast(Instance, actual_item_type).args:\n                actual_item_type = map_instance_to_supertype(\n                    cast(Instance, actual_item_type),\n                    self.lookup_typeinfo('typing.Iterable'))\n                actual_item_type = actual_item_type.args[0]   # Take the item inside the iterator\n\n",
        "source_code_len": 2291,
        "target_code": "        subexpr_type = self.accept(e.expr, return_type)\n\n        # check that the expr is an instance of Iterable and get the type of\n        # the iterator produced by __iter__\n        if (isinstance(subexpr_type, Instance) and\n                is_subtype(subexpr_type, self.named_type('typing.Iterable'))):\n            iter_method_type = self.expr_checker.analyze_external_member_access(\n                '__iter__',\n                subexpr_type,\n                AnyType())\n\n            generic_generator_type = self.named_generic_type('typing.Generator',\n                                                             [AnyType(), AnyType(), AnyType()])\n            iter_type, _ = self.expr_checker.check_call(iter_method_type, [], [],\n                                                        context=generic_generator_type)\n        elif isinstance(subexpr_type, AnyType):\n            iter_type = AnyType()\n        else:\n            self.msg.yield_from_invalid_operand_type(subexpr_type, e)\n            iter_type = AnyType()\n\n        # check that the iterator's item type matches the type yielded by the\n        # Generator function containing this yield from\n        expected_item_type = self.get_generator_yield_type(return_type)\n        actual_item_type = self.get_generator_yield_type(iter_type)\n\n",
        "target_code_len": 1298,
        "diff_format": "@@ -1873,43 +1866,26 @@\n         subexpr_type = self.accept(e.expr, return_type)\n-        if isinstance(subexpr_type, Instance):\n-            if subexpr_type.type.fullname() == 'asyncio.futures.Future':\n-                # if is a Future, in stmt don't need to do nothing\n-                # because the type Future[Some] jus matters to the main loop\n-                # that python executes, in statement we shouldn't get the Future,\n-                # is just for async purposes.\n-                self.function_stack[-1].is_coroutine = True  # Set the function as coroutine\n-            elif is_subtype(subexpr_type, self.named_type('typing.Iterable')):\n-                # If it's and Iterable-Like, let's check the types.\n-                # Maybe just check if have __iter__? (like in analyze_iterable)\n-                self.check_iterable_yield_from(e)\n-            else:\n-                self.msg.yield_from_invalid_operand_type(subexpr_type, e)\n+\n+        # check that the expr is an instance of Iterable and get the type of\n+        # the iterator produced by __iter__\n+        if (isinstance(subexpr_type, Instance) and\n+                is_subtype(subexpr_type, self.named_type('typing.Iterable'))):\n+            iter_method_type = self.expr_checker.analyze_external_member_access(\n+                '__iter__',\n+                subexpr_type,\n+                AnyType())\n+\n+            generic_generator_type = self.named_generic_type('typing.Generator',\n+                                                             [AnyType(), AnyType(), AnyType()])\n+            iter_type, _ = self.expr_checker.check_call(iter_method_type, [], [],\n+                                                        context=generic_generator_type)\n         elif isinstance(subexpr_type, AnyType):\n-            self.check_iterable_yield_from(e)\n+            iter_type = AnyType()\n         else:\n             self.msg.yield_from_invalid_operand_type(subexpr_type, e)\n-\n-        if (isinstance(subexpr_type, Instance) and\n-                subexpr_type.type.fullname() == 'typing.Generator'):\n-            return self.get_generator_return_type(subexpr_type)\n-        else:\n-            # non-Generators don't return anything from \"yield from\" expressions\n-            return Void()\n-\n-    def check_iterable_yield_from(self, e: YieldFromExpr) -> Type:\n-        \"\"\"\n-            Check that return type is super type of Iterable (Maybe just check if have __iter__?)\n-            and compare it with the type of the expression\n-        \"\"\"\n-        return_type = self.return_types[-1]\n+            iter_type = AnyType()\n+\n+        # check that the iterator's item type matches the type yielded by the\n+        # Generator function containing this yield from\n         expected_item_type = self.get_generator_yield_type(return_type)\n-        if e.expr is None:\n-            actual_item_type = Void()  # type: Type\n-        else:\n-            actual_item_type = self.accept(e.expr, expected_item_type)\n-            if hasattr(actual_item_type, 'args') and cast(Instance, actual_item_type).args:\n-                actual_item_type = map_instance_to_supertype(\n-                    cast(Instance, actual_item_type),\n-                    self.lookup_typeinfo('typing.Iterable'))\n-                actual_item_type = actual_item_type.args[0]   # Take the item inside the iterator\n+        actual_item_type = self.get_generator_yield_type(iter_type)\n \n",
        "source_code_with_indent": "        subexpr_type = self.accept(e.expr, return_type)\n        if isinstance(subexpr_type, Instance):\n            <IND>if subexpr_type.type.fullname() == 'asyncio.futures.Future':\n                # if is a Future, in stmt don't need to do nothing\n                # because the type Future[Some] jus matters to the main loop\n                # that python executes, in statement we shouldn't get the Future,\n                # is just for async purposes.\n                <IND>self.function_stack[-1].is_coroutine = True  # Set the function as coroutine\n            <DED>elif is_subtype(subexpr_type, self.named_type('typing.Iterable')):\n                # If it's and Iterable-Like, let's check the types.\n                # Maybe just check if have __iter__? (like in analyze_iterable)\n                <IND>self.check_iterable_yield_from(e)\n            <DED>else:\n                <IND>self.msg.yield_from_invalid_operand_type(subexpr_type, e)\n        <DED><DED>elif isinstance(subexpr_type, AnyType):\n            <IND>self.check_iterable_yield_from(e)\n        <DED>else:\n            <IND>self.msg.yield_from_invalid_operand_type(subexpr_type, e)\n\n        <DED>if (isinstance(subexpr_type, Instance) and\n                subexpr_type.type.fullname() == 'typing.Generator'):\n            <IND>return self.get_generator_return_type(subexpr_type)\n        <DED>else:\n            # non-Generators don't return anything from \"yield from\" expressions\n            <IND>return Void()\n\n    <DED><DED>def check_iterable_yield_from(self, e: YieldFromExpr) -> Type:\n        <IND>\"\"\"\n            Check that return type is super type of Iterable (Maybe just check if have __iter__?)\n            and compare it with the type of the expression\n        \"\"\"\n        return_type = self.return_types[-1]\n        expected_item_type = self.get_generator_yield_type(return_type)\n        if e.expr is None:\n            <IND>actual_item_type = Void()  # type: Type\n        <DED>else:\n            <IND>actual_item_type = self.accept(e.expr, expected_item_type)\n            if hasattr(actual_item_type, 'args') and cast(Instance, actual_item_type).args:\n                <IND>actual_item_type = map_instance_to_supertype(\n                    cast(Instance, actual_item_type),\n                    self.lookup_typeinfo('typing.Iterable'))\n                actual_item_type = actual_item_type.args[0]   # Take the item inside the iterator\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "        subexpr_type = self.accept(e.expr, return_type)\n\n        # check that the expr is an instance of Iterable and get the type of\n        # the iterator produced by __iter__\n        if (isinstance(subexpr_type, Instance) and\n                is_subtype(subexpr_type, self.named_type('typing.Iterable'))):\n            <IND>iter_method_type = self.expr_checker.analyze_external_member_access(\n                '__iter__',\n                subexpr_type,\n                AnyType())\n\n            generic_generator_type = self.named_generic_type('typing.Generator',\n                                                             [AnyType(), AnyType(), AnyType()])\n            iter_type, _ = self.expr_checker.check_call(iter_method_type, [], [],\n                                                        context=generic_generator_type)\n        <DED>elif isinstance(subexpr_type, AnyType):\n            <IND>iter_type = AnyType()\n        <DED>else:\n            <IND>self.msg.yield_from_invalid_operand_type(subexpr_type, e)\n            iter_type = AnyType()\n\n        # check that the iterator's item type matches the type yielded by the\n        # Generator function containing this yield from\n        <DED>expected_item_type = self.get_generator_yield_type(return_type)\n        actual_item_type = self.get_generator_yield_type(iter_type)\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "                           'actual type', 'expected type')\n\n",
        "source_code_len": 60,
        "target_code": "                           'actual type', 'expected type')\n\n        # determine the type of the entire yield from expression\n        if (isinstance(iter_type, Instance) and\n                iter_type.type.fullname() == 'typing.Generator'):\n            return self.get_generator_return_type(iter_type)\n        else:\n            # non-Generators don't return anything from \"yield from\" expressions\n            return Void()\n\n",
        "target_code_len": 422,
        "diff_format": "@@ -1918,2 +1894,10 @@\n                            'actual type', 'expected type')\n+\n+        # determine the type of the entire yield from expression\n+        if (isinstance(iter_type, Instance) and\n+                iter_type.type.fullname() == 'typing.Generator'):\n+            return self.get_generator_return_type(iter_type)\n+        else:\n+            # non-Generators don't return anything from \"yield from\" expressions\n+            return Void()\n \n",
        "source_code_with_indent": "                           'actual type', 'expected type')\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "                           'actual type', 'expected type')\n\n        # determine the type of the entire yield from expression\n        if (isinstance(iter_type, Instance) and\n                iter_type.type.fullname() == 'typing.Generator'):\n            <IND>return self.get_generator_return_type(iter_type)\n        <DED>else:\n            # non-Generators don't return anything from \"yield from\" expressions\n            <IND>return Void()\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  }
]