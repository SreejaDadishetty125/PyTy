[
  {
    "project": "hyperledger/indy-plenum",
    "commit": "7c33e84e4d9a13ffa73085eb98804e0b35d69e14",
    "filename": "setup.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/hyperledger-indy-plenum/setup.py",
    "file_hunks_size": 3,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "setup.py:48:11 Unbound name [10]: Name `__author__` is used but not defined in the current scope.",
    "message": " Name `__author__` is used but not defined in the current scope.",
    "rule_id": "Unbound name [10]",
    "warning_line_no": 48,
    "warning_line": "    author=__author__,"
  },
  {
    "project": "hyperledger/indy-plenum",
    "commit": "7c33e84e4d9a13ffa73085eb98804e0b35d69e14",
    "filename": "setup.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/hyperledger-indy-plenum/setup.py",
    "file_hunks_size": 3,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "setup.py:50:12 Unbound name [10]: Name `__license__` is used but not defined in the current scope.",
    "message": " Name `__license__` is used but not defined in the current scope.",
    "rule_id": "Unbound name [10]",
    "warning_line_no": 50,
    "warning_line": "    license=__license__,"
  },
  {
    "project": "hyperledger/indy-plenum",
    "commit": "7c33e84e4d9a13ffa73085eb98804e0b35d69e14",
    "filename": "plenum/common/transaction_store.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/hyperledger-indy-plenum/plenum/common/transaction_store.py",
    "file_hunks_size": 1,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "plenum/common/transaction_store.py:102:4 Inconsistent override [15]: `plenum.common.transaction_store.TransactionStore.get` overrides method defined in `Storage` inconsistently. Returned type `unknown` is not a subtype of the overridden return `typing.Coroutine[typing.Any, typing.Any, typing.Any]`.",
    "message": " `plenum.common.transaction_store.TransactionStore.get` overrides method defined in `Storage` inconsistently. Returned type `unknown` is not a subtype of the overridden return `typing.Coroutine[typing.Any, typing.Any, typing.Any]`.",
    "rule_id": "Inconsistent override [15]",
    "warning_line_no": 102,
    "warning_line": "    def get(self, identifier, reqId, **kwargs) -> Optional[Reply]:"
  },
  {
    "project": "hyperledger/indy-plenum",
    "commit": "7c33e84e4d9a13ffa73085eb98804e0b35d69e14",
    "filename": "plenum/common/types.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/hyperledger-indy-plenum/plenum/common/types.py",
    "file_hunks_size": 4,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "plenum/common/types.py:107:4 Incompatible return type [7]: Expected `NamedTuple` but got `typing.Type[TaggedTuple.cls]`.",
    "message": " Expected `NamedTuple` but got `typing.Type[TaggedTuple.cls]`.",
    "rule_id": "Incompatible return type [7]",
    "warning_line_no": 107,
    "warning_line": "    return cls",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    NODES = Field('nodes', Dict[str, HA])\n    POOL_LEDGER_STATUS = Field(\"poolLedgerStatus\", Any)\n    DOMAIN_LEDGER_STATUS = Field(\"domainLedgerStatus\", Any)\n    CONS_PROOF = Field(\"consProof\", Any)\n    POOL_CONS_PROOF = Field(\"poolConsProof\", Any)\n    DOMAIN_CONS_PROOF = Field(\"domainConsProof\", Any)\n    POOL_CATCHUP_REQ = Field(\"poolCatchupReq\", Any)\n    DOMAIN_CATCHUP_REQ = Field(\"domainCatchupReq\", Any)\n    POOL_CATCHUP_REP = Field(\"poolCatchupRep\", Any)\n    DOMAIN_CATCHUP_REP = Field(\"domainCatchupRep\", Any)\n\n\nclass TaggedTupleBase:\n    def melted(self):\n        \"\"\"\n        Return the tagged tuple in a dictionary form.\n        \"\"\"\n        if hasattr(self, \"__dict__\"):\n            m = self.__dict__\n        elif hasattr(self, \"_asdict\"):\n            m = self._asdict()\n        else:\n            raise RuntimeError(\"Cannot convert argument to a dictionary\")\n        m[OP_FIELD_NAME] = self.typename\n        m.move_to_end(OP_FIELD_NAME, False)\n        return m\n\n\n# noinspection PyProtectedMember\ndef TaggedTuple(typename, fields) -> NamedTuple:\n    cls = NamedTuple(typename, fields)\n    if OP_FIELD_NAME in cls._fields:\n        raise RuntimeError(\"field name '{}' is reserved in TaggedTuple\"\n                           .format(OP_FIELD_NAME))\n    cls.__bases__ += (TaggedTupleBase,)\n    cls.typename = typename\n    return cls\n\n",
        "source_code_len": 1339,
        "target_code": "    NODES = Field('nodes', Dict[str, HA])\n    CONS_PROOF = Field(\"consProof\", Any)\n    MSG_TYPE = Field(\"msg_type\", str)\n    PARAMS = Field(\"params\", dict)\n    PRIMARY = Field(\"primary\", dict)\n\n\n",
        "target_code_len": 195,
        "diff_format": "@@ -71,38 +61,7 @@\n     NODES = Field('nodes', Dict[str, HA])\n-    POOL_LEDGER_STATUS = Field(\"poolLedgerStatus\", Any)\n-    DOMAIN_LEDGER_STATUS = Field(\"domainLedgerStatus\", Any)\n     CONS_PROOF = Field(\"consProof\", Any)\n-    POOL_CONS_PROOF = Field(\"poolConsProof\", Any)\n-    DOMAIN_CONS_PROOF = Field(\"domainConsProof\", Any)\n-    POOL_CATCHUP_REQ = Field(\"poolCatchupReq\", Any)\n-    DOMAIN_CATCHUP_REQ = Field(\"domainCatchupReq\", Any)\n-    POOL_CATCHUP_REP = Field(\"poolCatchupRep\", Any)\n-    DOMAIN_CATCHUP_REP = Field(\"domainCatchupRep\", Any)\n+    MSG_TYPE = Field(\"msg_type\", str)\n+    PARAMS = Field(\"params\", dict)\n+    PRIMARY = Field(\"primary\", dict)\n \n-\n-class TaggedTupleBase:\n-    def melted(self):\n-        \"\"\"\n-        Return the tagged tuple in a dictionary form.\n-        \"\"\"\n-        if hasattr(self, \"__dict__\"):\n-            m = self.__dict__\n-        elif hasattr(self, \"_asdict\"):\n-            m = self._asdict()\n-        else:\n-            raise RuntimeError(\"Cannot convert argument to a dictionary\")\n-        m[OP_FIELD_NAME] = self.typename\n-        m.move_to_end(OP_FIELD_NAME, False)\n-        return m\n-\n-\n-# noinspection PyProtectedMember\n-def TaggedTuple(typename, fields) -> NamedTuple:\n-    cls = NamedTuple(typename, fields)\n-    if OP_FIELD_NAME in cls._fields:\n-        raise RuntimeError(\"field name '{}' is reserved in TaggedTuple\"\n-                           .format(OP_FIELD_NAME))\n-    cls.__bases__ += (TaggedTupleBase,)\n-    cls.typename = typename\n-    return cls\n \n",
        "source_code_with_indent": "    NODES = Field('nodes', Dict[str, HA])\n    POOL_LEDGER_STATUS = Field(\"poolLedgerStatus\", Any)\n    DOMAIN_LEDGER_STATUS = Field(\"domainLedgerStatus\", Any)\n    CONS_PROOF = Field(\"consProof\", Any)\n    POOL_CONS_PROOF = Field(\"poolConsProof\", Any)\n    DOMAIN_CONS_PROOF = Field(\"domainConsProof\", Any)\n    POOL_CATCHUP_REQ = Field(\"poolCatchupReq\", Any)\n    DOMAIN_CATCHUP_REQ = Field(\"domainCatchupReq\", Any)\n    POOL_CATCHUP_REP = Field(\"poolCatchupRep\", Any)\n    DOMAIN_CATCHUP_REP = Field(\"domainCatchupRep\", Any)\n\n\n<DED>class TaggedTupleBase:\n    <IND>def melted(self):\n        <IND>\"\"\"\n        Return the tagged tuple in a dictionary form.\n        \"\"\"\n        if hasattr(self, \"__dict__\"):\n            <IND>m = self.__dict__\n        <DED>elif hasattr(self, \"_asdict\"):\n            <IND>m = self._asdict()\n        <DED>else:\n            <IND>raise RuntimeError(\"Cannot convert argument to a dictionary\")\n        <DED>m[OP_FIELD_NAME] = self.typename\n        m.move_to_end(OP_FIELD_NAME, False)\n        return m\n\n\n# noinspection PyProtectedMember\n<DED><DED>def TaggedTuple(typename, fields) -> NamedTuple:\n    <IND>cls = NamedTuple(typename, fields)\n    if OP_FIELD_NAME in cls._fields:\n        <IND>raise RuntimeError(\"field name '{}' is reserved in TaggedTuple\"\n                           .format(OP_FIELD_NAME))\n    <DED>cls.__bases__ += (TaggedTupleBase,)\n    cls.typename = typename\n    return cls\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    NODES = Field('nodes', Dict[str, HA])\n    CONS_PROOF = Field(\"consProof\", Any)\n    MSG_TYPE = Field(\"msg_type\", str)\n    PARAMS = Field(\"params\", dict)\n    PRIMARY = Field(\"primary\", dict)\n\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": true,
        "has_suppression": false,
        "source_code": "\n\nclass ClientMessageValidator(MessageValidator):\n    schema = (\n        (f.IDENTIFIER.nm, IdentifierField()),\n        (f.REQ_ID.nm, NonNegativeNumberField()),\n        (OPERATION, ClientOperationField()),\n        (f.SIG.nm, SignatureField(optional=True)),\n        (f.DIGEST.nm, NonEmptyStringField(optional=True)),\n    )\n\n\nclass Nomination(MessageBase):\n    typename = NOMINATE\n\n    schema = (\n        (f.NAME.nm, NonEmptyStringField()),\n        (f.INST_ID.nm, NonNegativeNumberField()),\n        (f.VIEW_NO.nm, NonNegativeNumberField()),\n        (f.ORD_SEQ_NO.nm, NonNegativeNumberField()),\n    )\n# Nomination = TaggedTuple(NOMINATE, [\n#     f.NAME,\n#     f.INST_ID,\n#     f.VIEW_NO,\n#     f.ORD_SEQ_NO])\n\n\nBatch = TaggedTuple(BATCH, [\n    f.MSGS,\n    f.SIG])\n\n# Reelection messages that nodes send when they find the 2 or more nodes have\n# equal nominations for primary. `round` indicates the reelection round\n# number. So the first reelection would have round number 1, the one after\n# that would have round number 2. If a node receives a reelection message with\n# a round number that is not 1 greater than the reelections rounds it has\n# already seen then it rejects that message\n\n\nclass Reelection(MessageBase):\n    typename = REELECTION\n\n    schema = (\n        (f.INST_ID.nm, NonNegativeNumberField()),\n        (f.ROUND.nm, NonNegativeNumberField()),\n        (f.TIE_AMONG.nm, IterableField(TieAmongField())),\n        (f.VIEW_NO.nm, NonNegativeNumberField()),\n    )\n# Reelection = TaggedTuple(REELECTION, [\n#     f.INST_ID,\n#     f.ROUND,\n#     f.TIE_AMONG,\n#     f.VIEW_NO])\n\n# Declaration of a winner\n\nclass Primary(MessageBase):\n    typename = PRIMARY\n\n    schema = (\n        (f.NAME.nm, NonEmptyStringField()),\n        (f.INST_ID.nm, NonNegativeNumberField()),\n        (f.VIEW_NO.nm, NonNegativeNumberField()),\n        (f.ORD_SEQ_NO.nm, NonNegativeNumberField()),\n    )\n# Primary = TaggedTuple(PRIMARY, [\n#     f.NAME,\n#     f.INST_ID,\n#     f.VIEW_NO,\n#     f.ORD_SEQ_NO])\n\nBlacklistMsg = NamedTuple(BLACKLIST, [\n    f.SUSP_CODE,\n    f.NODE_NAME])\n\nRequestAck = TaggedTuple(REQACK, [\n    f.IDENTIFIER,\n    f.REQ_ID])\n\nRequestNack = TaggedTuple(REQNACK, [\n    f.IDENTIFIER,\n    f.REQ_ID,\n    f.REASON])\n\nReject = TaggedTuple(REJECT, [\n    f.IDENTIFIER,\n    f.REQ_ID,\n    f.REASON])\n\nPoolLedgerTxns = TaggedTuple(POOL_LEDGER_TXNS, [\n    f.TXN\n])\n\n\nclass Ordered(MessageBase):\n    typename = ORDERED\n    schema = (\n        (f.INST_ID.nm, NonNegativeNumberField()),\n        (f.VIEW_NO.nm, NonNegativeNumberField()),\n        (f.REQ_IDR.nm, IterableField(RequestIdentifierField())),\n        (f.PP_SEQ_NO.nm, NonNegativeNumberField()),\n        (f.PP_TIME.nm, TimestampField()),\n        (f.LEDGER_ID.nm, LedgerIdField()),\n        (f.STATE_ROOT.nm, HexField(length=64, nullable=True)),\n        (f.TXN_ROOT.nm, HexField(length=64, nullable=True)),\n    )\n# Ordered = NamedTuple(ORDERED, [\n#     f.INST_ID,\n#     f.VIEW_NO,\n#     f.REQ_IDR,\n#     f.PP_SEQ_NO,\n#     f.PP_TIME,\n#     f.LEDGER_ID,\n#     f.STATE_ROOT,\n#     f.TXN_ROOT,\n#     ])\n\n# <PROPAGATE, <REQUEST, o, s, c> \u03c3c, i>~\u03bci\n# s = client sequence number (comes from Aardvark paper)\n\nclass Propagate(MessageBase):\n    typename = PROPAGATE\n    schema = (\n        (f.REQUEST.nm, ClientMessageValidator()),\n        (f.SENDER_CLIENT.nm, NonEmptyStringField()),\n    )\n# Propagate = TaggedTuple(PROPAGATE, [\n#     f.REQUEST,\n#     f.SENDER_CLIENT])\n\n\nclass PrePrepare(MessageBase):\n    typename = PREPREPARE\n    schema = (\n        (f.INST_ID.nm, NonNegativeNumberField()),\n        (f.VIEW_NO.nm, NonNegativeNumberField()),\n        (f.PP_SEQ_NO.nm, NonNegativeNumberField()),\n        (f.PP_TIME.nm, TimestampField()),\n        (f.REQ_IDR.nm, IterableField(RequestIdentifierField())),\n        (f.DISCARDED.nm, NonNegativeNumberField()),\n        (f.DIGEST.nm, NonEmptyStringField()),\n        (f.LEDGER_ID.nm, LedgerIdField()),\n        (f.STATE_ROOT.nm, HexField(length=64, nullable=True)),\n        (f.TXN_ROOT.nm, HexField(length=64, nullable=True)),\n    )\n# PrePrepare = TaggedTuple(PREPREPARE, [\n#     f.INST_ID,\n#     f.VIEW_NO,\n#     f.PP_SEQ_NO,\n#     f.PP_TIME,\n#     f.REQ_IDR,\n#     f.DISCARDED,\n#     f.DIGEST,\n#     f.LEDGER_ID,\n#     f.STATE_ROOT,\n#     f.TXN_ROOT,\n#     ])\n\n\nclass Prepare(MessageBase):\n    typename = PREPARE\n    schema = (\n        (f.INST_ID.nm, NonNegativeNumberField()),\n        (f.VIEW_NO.nm, NonNegativeNumberField()),\n        (f.PP_SEQ_NO.nm, NonNegativeNumberField()),\n        (f.DIGEST.nm, NonEmptyStringField()),\n        (f.STATE_ROOT.nm, HexField(length=64, nullable=True)),\n        (f.TXN_ROOT.nm, HexField(length=64, nullable=True)),\n    )\n# Prepare = TaggedTuple(PREPARE, [\n#     f.INST_ID,\n#     f.VIEW_NO,\n#     f.PP_SEQ_NO,\n#     f.DIGEST,\n#     f.STATE_ROOT,\n#     f.TXN_ROOT,\n#     ])\n\n\nclass Commit(MessageBase):\n    typename = COMMIT\n    schema = (\n        (f.INST_ID.nm, NonNegativeNumberField()),\n        (f.VIEW_NO.nm, NonNegativeNumberField()),\n        (f.PP_SEQ_NO.nm, NonNegativeNumberField()),\n    )\n# Commit = TaggedTuple(COMMIT, [\n#     f.INST_ID,\n#     f.VIEW_NO,\n#     f.PP_SEQ_NO\n#     ])\n\n# class Checkpoint(MessageBase):\n#     typename = CHECKPOINT\n#     schema = (\n#         (f.INST_ID.nm, NonNegativeNumberField()),\n#         (f.VIEW_NO.nm, NonNegativeNumberField()),\n#         (f.SEQ_NO_START.nm, NonNegativeNumberField()),\n#         (f.SEQ_NO_END.nm, NonNegativeNumberField()),\n#         (f.DIGEST.nm, NonEmptyStringField()),\n#     )\nCheckpoint = TaggedTuple(CHECKPOINT, [\n    f.INST_ID,\n    f.VIEW_NO,\n    f.SEQ_NO_START,\n    f.SEQ_NO_END,\n    f.DIGEST])\n\n\nCheckpointState = NamedTuple(CHECKPOINT_STATE, [\n    f.SEQ_NO,   # Current ppSeqNo in the checkpoint\n    f.DIGESTS,  # Digest of all the requests in the checkpoint\n    f.DIGEST,   # Final digest of the checkpoint, after all requests in its\n    # range have been ordered\n    f.RECEIVED_DIGESTS,\n    f.IS_STABLE\n    ])\n\n\n# class ThreePCState(MessageBase):\n#     typename = THREE_PC_STATE\n#     schema = (\n#         (f.INST_ID.nm, NonNegativeNumberField()),\n#         (f.MSGS.nm, IterableField(ClientMessageValidator())),\n#     )\nThreePCState = TaggedTuple(THREE_PC_STATE, [\n    f.INST_ID,\n    f.MSGS])\n\nReply = TaggedTuple(REPLY, [f.RESULT])\n\n\nclass InstanceChange(MessageBase):\n    typename = INSTANCE_CHANGE\n    schema = (\n        (f.VIEW_NO.nm, NonNegativeNumberField()),\n        (f.REASON.nm, NonNegativeNumberField())\n    )\n# InstanceChange = TaggedTuple(INSTANCE_CHANGE, [\n#     f.VIEW_NO,\n#     f.REASON\n# ])\n\n\nclass LedgerStatus(MessageBase):\n    typename = LEDGER_STATUS\n    schema = (\n        (f.LEDGER_ID.nm, LedgerIdField()),\n        (f.TXN_SEQ_NO.nm, NonNegativeNumberField()),\n        (f.MERKLE_ROOT.nm, MerkleRootField()),\n    )\n# LedgerStatus = TaggedTuple(LEDGER_STATUS, [\n#     f.LEDGER_ID,\n#     f.TXN_SEQ_NO,\n#     f.MERKLE_ROOT])\n\n\nclass ConsistencyProof(MessageBase):\n    typename = CONSISTENCY_PROOF\n    schema = (\n        (f.LEDGER_ID.nm, LedgerIdField()),\n        (f.SEQ_NO_START.nm, NonNegativeNumberField()),\n        (f.SEQ_NO_END.nm, NonNegativeNumberField()),\n        (f.PP_SEQ_NO.nm, NonNegativeNumberField()),\n        (f.OLD_MERKLE_ROOT.nm, MerkleRootField()),\n        (f.NEW_MERKLE_ROOT.nm, MerkleRootField()),\n        (f.HASHES.nm, IterableField(NonEmptyStringField())),\n    )\n# ConsistencyProof = TaggedTuple(CONSISTENCY_PROOF, [\n#     f.LEDGER_ID,\n#     f.SEQ_NO_START,\n#     f.SEQ_NO_END,\n#     f.PP_SEQ_NO,\n#     f.OLD_MERKLE_ROOT,\n#     f.NEW_MERKLE_ROOT,\n#     f.HASHES\n# ])\n\n# TODO: Catchup is not a good name, replace it with `sync` or something which\n# is familiar\n\n# class CatchupReq(MessageBase):\n#     typename = CATCHUP_REQ\n#     schema = (\n#         (f.LEDGER_ID.nm, LedgerIdField()),\n#         (f.SEQ_NO_START.nm, NonNegativeNumberField()),\n#         (f.SEQ_NO_END.nm, NonNegativeNumberField()),\n#         (f.CATCHUP_TILL.nm, NonNegativeNumberField()),\n#     )\nCatchupReq = TaggedTuple(CATCHUP_REQ, [\n    f.LEDGER_ID,\n    f.SEQ_NO_START,\n    f.SEQ_NO_END,\n    f.CATCHUP_TILL\n])\n\n\n# class CatchupRep(MessageBase):\n#     typename = CATCHUP_REQ\n#     schema = (\n#         (f.LEDGER_ID.nm, LedgerIdField()),\n#         (f.TXNS.nm, IterableField(ClientMessageValidator())),\n#         (f.CONS_PROOF.nm, IterableField(HexField(length=64))),\n#     )\nCatchupRep = TaggedTuple(CATCHUP_REP, [\n    f.LEDGER_ID,\n    f.TXNS,\n    f.CONS_PROOF\n])\n\n# class ConsProofRequest(MessageBase):\n#     typename = CONS_PROOF_REQUEST\n#     schema = (\n#         (f.LEDGER_ID.nm, LedgerIdField()),\n#         (f.SEQ_NO_START.nm, NonNegativeNumberField()),\n#         (f.SEQ_NO_END.nm, NonNegativeNumberField()),\n#     )\nConsProofRequest = TaggedTuple(CONS_PROOF_REQUEST, [\n    f.LEDGER_ID,\n    f.SEQ_NO_START,\n    f.SEQ_NO_END\n])\n\n\nTaggedTuples = None  # type: Dict[str, class]\n\n\ndef loadRegistry():\n    global TaggedTuples\n    if not TaggedTuples:\n        this = sys.modules[__name__]\n        TaggedTuples = {getattr(this, x).__name__: getattr(this, x)\n                        for x in dir(this) if\n                        callable(getattr(getattr(this, x), \"melted\", None))\n                        and getattr(getattr(this, x), \"_fields\", None)}\n        # attach MessageBase, for pre-testing procedure\n        # TODO: add MessageBase classes another way\n        TaggedTuples.update(\n            {getattr(this, x).typename: getattr(this, x)\n             for x in dir(this)\n             if getattr(getattr(this, x), \"schema\", None) and issubclass(getattr(this, x), MessageBase)}\n        )\n\nloadRegistry()\n\nThreePhaseType = (PrePrepare, Prepare, Commit)\nThreePhaseMsg = TypeVar(\"3PhaseMsg\", *ThreePhaseType)\n\n\nElectionType = (Nomination, Primary, Reelection)\nElectionMsg = TypeVar(\"ElectionMsg\", *ElectionType)\n\nThreePhaseKey = NamedTuple(\"ThreePhaseKey\", [\n                        f.VIEW_NO,\n                        f.PP_SEQ_NO\n                    ])\n\n",
        "source_code_len": 9840,
        "target_code": "\n\n",
        "target_code_len": 2,
        "diff_format": "@@ -110,358 +69,2 @@\n \n-\n-class ClientMessageValidator(MessageValidator):\n-    schema = (\n-        (f.IDENTIFIER.nm, IdentifierField()),\n-        (f.REQ_ID.nm, NonNegativeNumberField()),\n-        (OPERATION, ClientOperationField()),\n-        (f.SIG.nm, SignatureField(optional=True)),\n-        (f.DIGEST.nm, NonEmptyStringField(optional=True)),\n-    )\n-\n-\n-class Nomination(MessageBase):\n-    typename = NOMINATE\n-\n-    schema = (\n-        (f.NAME.nm, NonEmptyStringField()),\n-        (f.INST_ID.nm, NonNegativeNumberField()),\n-        (f.VIEW_NO.nm, NonNegativeNumberField()),\n-        (f.ORD_SEQ_NO.nm, NonNegativeNumberField()),\n-    )\n-# Nomination = TaggedTuple(NOMINATE, [\n-#     f.NAME,\n-#     f.INST_ID,\n-#     f.VIEW_NO,\n-#     f.ORD_SEQ_NO])\n-\n-\n-Batch = TaggedTuple(BATCH, [\n-    f.MSGS,\n-    f.SIG])\n-\n-# Reelection messages that nodes send when they find the 2 or more nodes have\n-# equal nominations for primary. `round` indicates the reelection round\n-# number. So the first reelection would have round number 1, the one after\n-# that would have round number 2. If a node receives a reelection message with\n-# a round number that is not 1 greater than the reelections rounds it has\n-# already seen then it rejects that message\n-\n-\n-class Reelection(MessageBase):\n-    typename = REELECTION\n-\n-    schema = (\n-        (f.INST_ID.nm, NonNegativeNumberField()),\n-        (f.ROUND.nm, NonNegativeNumberField()),\n-        (f.TIE_AMONG.nm, IterableField(TieAmongField())),\n-        (f.VIEW_NO.nm, NonNegativeNumberField()),\n-    )\n-# Reelection = TaggedTuple(REELECTION, [\n-#     f.INST_ID,\n-#     f.ROUND,\n-#     f.TIE_AMONG,\n-#     f.VIEW_NO])\n-\n-# Declaration of a winner\n-\n-class Primary(MessageBase):\n-    typename = PRIMARY\n-\n-    schema = (\n-        (f.NAME.nm, NonEmptyStringField()),\n-        (f.INST_ID.nm, NonNegativeNumberField()),\n-        (f.VIEW_NO.nm, NonNegativeNumberField()),\n-        (f.ORD_SEQ_NO.nm, NonNegativeNumberField()),\n-    )\n-# Primary = TaggedTuple(PRIMARY, [\n-#     f.NAME,\n-#     f.INST_ID,\n-#     f.VIEW_NO,\n-#     f.ORD_SEQ_NO])\n-\n-BlacklistMsg = NamedTuple(BLACKLIST, [\n-    f.SUSP_CODE,\n-    f.NODE_NAME])\n-\n-RequestAck = TaggedTuple(REQACK, [\n-    f.IDENTIFIER,\n-    f.REQ_ID])\n-\n-RequestNack = TaggedTuple(REQNACK, [\n-    f.IDENTIFIER,\n-    f.REQ_ID,\n-    f.REASON])\n-\n-Reject = TaggedTuple(REJECT, [\n-    f.IDENTIFIER,\n-    f.REQ_ID,\n-    f.REASON])\n-\n-PoolLedgerTxns = TaggedTuple(POOL_LEDGER_TXNS, [\n-    f.TXN\n-])\n-\n-\n-class Ordered(MessageBase):\n-    typename = ORDERED\n-    schema = (\n-        (f.INST_ID.nm, NonNegativeNumberField()),\n-        (f.VIEW_NO.nm, NonNegativeNumberField()),\n-        (f.REQ_IDR.nm, IterableField(RequestIdentifierField())),\n-        (f.PP_SEQ_NO.nm, NonNegativeNumberField()),\n-        (f.PP_TIME.nm, TimestampField()),\n-        (f.LEDGER_ID.nm, LedgerIdField()),\n-        (f.STATE_ROOT.nm, HexField(length=64, nullable=True)),\n-        (f.TXN_ROOT.nm, HexField(length=64, nullable=True)),\n-    )\n-# Ordered = NamedTuple(ORDERED, [\n-#     f.INST_ID,\n-#     f.VIEW_NO,\n-#     f.REQ_IDR,\n-#     f.PP_SEQ_NO,\n-#     f.PP_TIME,\n-#     f.LEDGER_ID,\n-#     f.STATE_ROOT,\n-#     f.TXN_ROOT,\n-#     ])\n-\n-# <PROPAGATE, <REQUEST, o, s, c> \u03c3c, i>~\u03bci\n-# s = client sequence number (comes from Aardvark paper)\n-\n-class Propagate(MessageBase):\n-    typename = PROPAGATE\n-    schema = (\n-        (f.REQUEST.nm, ClientMessageValidator()),\n-        (f.SENDER_CLIENT.nm, NonEmptyStringField()),\n-    )\n-# Propagate = TaggedTuple(PROPAGATE, [\n-#     f.REQUEST,\n-#     f.SENDER_CLIENT])\n-\n-\n-class PrePrepare(MessageBase):\n-    typename = PREPREPARE\n-    schema = (\n-        (f.INST_ID.nm, NonNegativeNumberField()),\n-        (f.VIEW_NO.nm, NonNegativeNumberField()),\n-        (f.PP_SEQ_NO.nm, NonNegativeNumberField()),\n-        (f.PP_TIME.nm, TimestampField()),\n-        (f.REQ_IDR.nm, IterableField(RequestIdentifierField())),\n-        (f.DISCARDED.nm, NonNegativeNumberField()),\n-        (f.DIGEST.nm, NonEmptyStringField()),\n-        (f.LEDGER_ID.nm, LedgerIdField()),\n-        (f.STATE_ROOT.nm, HexField(length=64, nullable=True)),\n-        (f.TXN_ROOT.nm, HexField(length=64, nullable=True)),\n-    )\n-# PrePrepare = TaggedTuple(PREPREPARE, [\n-#     f.INST_ID,\n-#     f.VIEW_NO,\n-#     f.PP_SEQ_NO,\n-#     f.PP_TIME,\n-#     f.REQ_IDR,\n-#     f.DISCARDED,\n-#     f.DIGEST,\n-#     f.LEDGER_ID,\n-#     f.STATE_ROOT,\n-#     f.TXN_ROOT,\n-#     ])\n-\n-\n-class Prepare(MessageBase):\n-    typename = PREPARE\n-    schema = (\n-        (f.INST_ID.nm, NonNegativeNumberField()),\n-        (f.VIEW_NO.nm, NonNegativeNumberField()),\n-        (f.PP_SEQ_NO.nm, NonNegativeNumberField()),\n-        (f.DIGEST.nm, NonEmptyStringField()),\n-        (f.STATE_ROOT.nm, HexField(length=64, nullable=True)),\n-        (f.TXN_ROOT.nm, HexField(length=64, nullable=True)),\n-    )\n-# Prepare = TaggedTuple(PREPARE, [\n-#     f.INST_ID,\n-#     f.VIEW_NO,\n-#     f.PP_SEQ_NO,\n-#     f.DIGEST,\n-#     f.STATE_ROOT,\n-#     f.TXN_ROOT,\n-#     ])\n-\n-\n-class Commit(MessageBase):\n-    typename = COMMIT\n-    schema = (\n-        (f.INST_ID.nm, NonNegativeNumberField()),\n-        (f.VIEW_NO.nm, NonNegativeNumberField()),\n-        (f.PP_SEQ_NO.nm, NonNegativeNumberField()),\n-    )\n-# Commit = TaggedTuple(COMMIT, [\n-#     f.INST_ID,\n-#     f.VIEW_NO,\n-#     f.PP_SEQ_NO\n-#     ])\n-\n-# class Checkpoint(MessageBase):\n-#     typename = CHECKPOINT\n-#     schema = (\n-#         (f.INST_ID.nm, NonNegativeNumberField()),\n-#         (f.VIEW_NO.nm, NonNegativeNumberField()),\n-#         (f.SEQ_NO_START.nm, NonNegativeNumberField()),\n-#         (f.SEQ_NO_END.nm, NonNegativeNumberField()),\n-#         (f.DIGEST.nm, NonEmptyStringField()),\n-#     )\n-Checkpoint = TaggedTuple(CHECKPOINT, [\n-    f.INST_ID,\n-    f.VIEW_NO,\n-    f.SEQ_NO_START,\n-    f.SEQ_NO_END,\n-    f.DIGEST])\n-\n-\n-CheckpointState = NamedTuple(CHECKPOINT_STATE, [\n-    f.SEQ_NO,   # Current ppSeqNo in the checkpoint\n-    f.DIGESTS,  # Digest of all the requests in the checkpoint\n-    f.DIGEST,   # Final digest of the checkpoint, after all requests in its\n-    # range have been ordered\n-    f.RECEIVED_DIGESTS,\n-    f.IS_STABLE\n-    ])\n-\n-\n-# class ThreePCState(MessageBase):\n-#     typename = THREE_PC_STATE\n-#     schema = (\n-#         (f.INST_ID.nm, NonNegativeNumberField()),\n-#         (f.MSGS.nm, IterableField(ClientMessageValidator())),\n-#     )\n-ThreePCState = TaggedTuple(THREE_PC_STATE, [\n-    f.INST_ID,\n-    f.MSGS])\n-\n-Reply = TaggedTuple(REPLY, [f.RESULT])\n-\n-\n-class InstanceChange(MessageBase):\n-    typename = INSTANCE_CHANGE\n-    schema = (\n-        (f.VIEW_NO.nm, NonNegativeNumberField()),\n-        (f.REASON.nm, NonNegativeNumberField())\n-    )\n-# InstanceChange = TaggedTuple(INSTANCE_CHANGE, [\n-#     f.VIEW_NO,\n-#     f.REASON\n-# ])\n-\n-\n-class LedgerStatus(MessageBase):\n-    typename = LEDGER_STATUS\n-    schema = (\n-        (f.LEDGER_ID.nm, LedgerIdField()),\n-        (f.TXN_SEQ_NO.nm, NonNegativeNumberField()),\n-        (f.MERKLE_ROOT.nm, MerkleRootField()),\n-    )\n-# LedgerStatus = TaggedTuple(LEDGER_STATUS, [\n-#     f.LEDGER_ID,\n-#     f.TXN_SEQ_NO,\n-#     f.MERKLE_ROOT])\n-\n-\n-class ConsistencyProof(MessageBase):\n-    typename = CONSISTENCY_PROOF\n-    schema = (\n-        (f.LEDGER_ID.nm, LedgerIdField()),\n-        (f.SEQ_NO_START.nm, NonNegativeNumberField()),\n-        (f.SEQ_NO_END.nm, NonNegativeNumberField()),\n-        (f.PP_SEQ_NO.nm, NonNegativeNumberField()),\n-        (f.OLD_MERKLE_ROOT.nm, MerkleRootField()),\n-        (f.NEW_MERKLE_ROOT.nm, MerkleRootField()),\n-        (f.HASHES.nm, IterableField(NonEmptyStringField())),\n-    )\n-# ConsistencyProof = TaggedTuple(CONSISTENCY_PROOF, [\n-#     f.LEDGER_ID,\n-#     f.SEQ_NO_START,\n-#     f.SEQ_NO_END,\n-#     f.PP_SEQ_NO,\n-#     f.OLD_MERKLE_ROOT,\n-#     f.NEW_MERKLE_ROOT,\n-#     f.HASHES\n-# ])\n-\n-# TODO: Catchup is not a good name, replace it with `sync` or something which\n-# is familiar\n-\n-# class CatchupReq(MessageBase):\n-#     typename = CATCHUP_REQ\n-#     schema = (\n-#         (f.LEDGER_ID.nm, LedgerIdField()),\n-#         (f.SEQ_NO_START.nm, NonNegativeNumberField()),\n-#         (f.SEQ_NO_END.nm, NonNegativeNumberField()),\n-#         (f.CATCHUP_TILL.nm, NonNegativeNumberField()),\n-#     )\n-CatchupReq = TaggedTuple(CATCHUP_REQ, [\n-    f.LEDGER_ID,\n-    f.SEQ_NO_START,\n-    f.SEQ_NO_END,\n-    f.CATCHUP_TILL\n-])\n-\n-\n-# class CatchupRep(MessageBase):\n-#     typename = CATCHUP_REQ\n-#     schema = (\n-#         (f.LEDGER_ID.nm, LedgerIdField()),\n-#         (f.TXNS.nm, IterableField(ClientMessageValidator())),\n-#         (f.CONS_PROOF.nm, IterableField(HexField(length=64))),\n-#     )\n-CatchupRep = TaggedTuple(CATCHUP_REP, [\n-    f.LEDGER_ID,\n-    f.TXNS,\n-    f.CONS_PROOF\n-])\n-\n-# class ConsProofRequest(MessageBase):\n-#     typename = CONS_PROOF_REQUEST\n-#     schema = (\n-#         (f.LEDGER_ID.nm, LedgerIdField()),\n-#         (f.SEQ_NO_START.nm, NonNegativeNumberField()),\n-#         (f.SEQ_NO_END.nm, NonNegativeNumberField()),\n-#     )\n-ConsProofRequest = TaggedTuple(CONS_PROOF_REQUEST, [\n-    f.LEDGER_ID,\n-    f.SEQ_NO_START,\n-    f.SEQ_NO_END\n-])\n-\n-\n-TaggedTuples = None  # type: Dict[str, class]\n-\n-\n-def loadRegistry():\n-    global TaggedTuples\n-    if not TaggedTuples:\n-        this = sys.modules[__name__]\n-        TaggedTuples = {getattr(this, x).__name__: getattr(this, x)\n-                        for x in dir(this) if\n-                        callable(getattr(getattr(this, x), \"melted\", None))\n-                        and getattr(getattr(this, x), \"_fields\", None)}\n-        # attach MessageBase, for pre-testing procedure\n-        # TODO: add MessageBase classes another way\n-        TaggedTuples.update(\n-            {getattr(this, x).typename: getattr(this, x)\n-             for x in dir(this)\n-             if getattr(getattr(this, x), \"schema\", None) and issubclass(getattr(this, x), MessageBase)}\n-        )\n-\n-loadRegistry()\n-\n-ThreePhaseType = (PrePrepare, Prepare, Commit)\n-ThreePhaseMsg = TypeVar(\"3PhaseMsg\", *ThreePhaseType)\n-\n-\n-ElectionType = (Nomination, Primary, Reelection)\n-ElectionMsg = TypeVar(\"ElectionMsg\", *ElectionType)\n-\n-ThreePhaseKey = NamedTuple(\"ThreePhaseKey\", [\n-                        f.VIEW_NO,\n-                        f.PP_SEQ_NO\n-                    ])\n \n",
        "source_code_with_indent": "\n\nclass ClientMessageValidator(MessageValidator):\n    <IND>schema = (\n        (f.IDENTIFIER.nm, IdentifierField()),\n        (f.REQ_ID.nm, NonNegativeNumberField()),\n        (OPERATION, ClientOperationField()),\n        (f.SIG.nm, SignatureField(optional=True)),\n        (f.DIGEST.nm, NonEmptyStringField(optional=True)),\n    )\n\n\n<DED>class Nomination(MessageBase):\n    <IND>typename = NOMINATE\n\n    schema = (\n        (f.NAME.nm, NonEmptyStringField()),\n        (f.INST_ID.nm, NonNegativeNumberField()),\n        (f.VIEW_NO.nm, NonNegativeNumberField()),\n        (f.ORD_SEQ_NO.nm, NonNegativeNumberField()),\n    )\n# Nomination = TaggedTuple(NOMINATE, [\n#     f.NAME,\n#     f.INST_ID,\n#     f.VIEW_NO,\n#     f.ORD_SEQ_NO])\n\n\n<DED>Batch = TaggedTuple(BATCH, [\n    f.MSGS,\n    f.SIG])\n\n# Reelection messages that nodes send when they find the 2 or more nodes have\n# equal nominations for primary. `round` indicates the reelection round\n# number. So the first reelection would have round number 1, the one after\n# that would have round number 2. If a node receives a reelection message with\n# a round number that is not 1 greater than the reelections rounds it has\n# already seen then it rejects that message\n\n\nclass Reelection(MessageBase):\n    <IND>typename = REELECTION\n\n    schema = (\n        (f.INST_ID.nm, NonNegativeNumberField()),\n        (f.ROUND.nm, NonNegativeNumberField()),\n        (f.TIE_AMONG.nm, IterableField(TieAmongField())),\n        (f.VIEW_NO.nm, NonNegativeNumberField()),\n    )\n# Reelection = TaggedTuple(REELECTION, [\n#     f.INST_ID,\n#     f.ROUND,\n#     f.TIE_AMONG,\n#     f.VIEW_NO])\n\n# Declaration of a winner\n\n<DED>class Primary(MessageBase):\n    <IND>typename = PRIMARY\n\n    schema = (\n        (f.NAME.nm, NonEmptyStringField()),\n        (f.INST_ID.nm, NonNegativeNumberField()),\n        (f.VIEW_NO.nm, NonNegativeNumberField()),\n        (f.ORD_SEQ_NO.nm, NonNegativeNumberField()),\n    )\n# Primary = TaggedTuple(PRIMARY, [\n#     f.NAME,\n#     f.INST_ID,\n#     f.VIEW_NO,\n#     f.ORD_SEQ_NO])\n\n<DED>BlacklistMsg = NamedTuple(BLACKLIST, [\n    f.SUSP_CODE,\n    f.NODE_NAME])\n\nRequestAck = TaggedTuple(REQACK, [\n    f.IDENTIFIER,\n    f.REQ_ID])\n\nRequestNack = TaggedTuple(REQNACK, [\n    f.IDENTIFIER,\n    f.REQ_ID,\n    f.REASON])\n\nReject = TaggedTuple(REJECT, [\n    f.IDENTIFIER,\n    f.REQ_ID,\n    f.REASON])\n\nPoolLedgerTxns = TaggedTuple(POOL_LEDGER_TXNS, [\n    f.TXN\n])\n\n\nclass Ordered(MessageBase):\n    <IND>typename = ORDERED\n    schema = (\n        (f.INST_ID.nm, NonNegativeNumberField()),\n        (f.VIEW_NO.nm, NonNegativeNumberField()),\n        (f.REQ_IDR.nm, IterableField(RequestIdentifierField())),\n        (f.PP_SEQ_NO.nm, NonNegativeNumberField()),\n        (f.PP_TIME.nm, TimestampField()),\n        (f.LEDGER_ID.nm, LedgerIdField()),\n        (f.STATE_ROOT.nm, HexField(length=64, nullable=True)),\n        (f.TXN_ROOT.nm, HexField(length=64, nullable=True)),\n    )\n# Ordered = NamedTuple(ORDERED, [\n#     f.INST_ID,\n#     f.VIEW_NO,\n#     f.REQ_IDR,\n#     f.PP_SEQ_NO,\n#     f.PP_TIME,\n#     f.LEDGER_ID,\n#     f.STATE_ROOT,\n#     f.TXN_ROOT,\n#     ])\n\n# <PROPAGATE, <REQUEST, o, s, c> \u03c3c, i>~\u03bci\n# s = client sequence number (comes from Aardvark paper)\n\n<DED>class Propagate(MessageBase):\n    <IND>typename = PROPAGATE\n    schema = (\n        (f.REQUEST.nm, ClientMessageValidator()),\n        (f.SENDER_CLIENT.nm, NonEmptyStringField()),\n    )\n# Propagate = TaggedTuple(PROPAGATE, [\n#     f.REQUEST,\n#     f.SENDER_CLIENT])\n\n\n<DED>class PrePrepare(MessageBase):\n    <IND>typename = PREPREPARE\n    schema = (\n        (f.INST_ID.nm, NonNegativeNumberField()),\n        (f.VIEW_NO.nm, NonNegativeNumberField()),\n        (f.PP_SEQ_NO.nm, NonNegativeNumberField()),\n        (f.PP_TIME.nm, TimestampField()),\n        (f.REQ_IDR.nm, IterableField(RequestIdentifierField())),\n        (f.DISCARDED.nm, NonNegativeNumberField()),\n        (f.DIGEST.nm, NonEmptyStringField()),\n        (f.LEDGER_ID.nm, LedgerIdField()),\n        (f.STATE_ROOT.nm, HexField(length=64, nullable=True)),\n        (f.TXN_ROOT.nm, HexField(length=64, nullable=True)),\n    )\n# PrePrepare = TaggedTuple(PREPREPARE, [\n#     f.INST_ID,\n#     f.VIEW_NO,\n#     f.PP_SEQ_NO,\n#     f.PP_TIME,\n#     f.REQ_IDR,\n#     f.DISCARDED,\n#     f.DIGEST,\n#     f.LEDGER_ID,\n#     f.STATE_ROOT,\n#     f.TXN_ROOT,\n#     ])\n\n\n<DED>class Prepare(MessageBase):\n    <IND>typename = PREPARE\n    schema = (\n        (f.INST_ID.nm, NonNegativeNumberField()),\n        (f.VIEW_NO.nm, NonNegativeNumberField()),\n        (f.PP_SEQ_NO.nm, NonNegativeNumberField()),\n        (f.DIGEST.nm, NonEmptyStringField()),\n        (f.STATE_ROOT.nm, HexField(length=64, nullable=True)),\n        (f.TXN_ROOT.nm, HexField(length=64, nullable=True)),\n    )\n# Prepare = TaggedTuple(PREPARE, [\n#     f.INST_ID,\n#     f.VIEW_NO,\n#     f.PP_SEQ_NO,\n#     f.DIGEST,\n#     f.STATE_ROOT,\n#     f.TXN_ROOT,\n#     ])\n\n\n<DED>class Commit(MessageBase):\n    <IND>typename = COMMIT\n    schema = (\n        (f.INST_ID.nm, NonNegativeNumberField()),\n        (f.VIEW_NO.nm, NonNegativeNumberField()),\n        (f.PP_SEQ_NO.nm, NonNegativeNumberField()),\n    )\n# Commit = TaggedTuple(COMMIT, [\n#     f.INST_ID,\n#     f.VIEW_NO,\n#     f.PP_SEQ_NO\n#     ])\n\n# class Checkpoint(MessageBase):\n#     typename = CHECKPOINT\n#     schema = (\n#         (f.INST_ID.nm, NonNegativeNumberField()),\n#         (f.VIEW_NO.nm, NonNegativeNumberField()),\n#         (f.SEQ_NO_START.nm, NonNegativeNumberField()),\n#         (f.SEQ_NO_END.nm, NonNegativeNumberField()),\n#         (f.DIGEST.nm, NonEmptyStringField()),\n#     )\n<DED>Checkpoint = TaggedTuple(CHECKPOINT, [\n    f.INST_ID,\n    f.VIEW_NO,\n    f.SEQ_NO_START,\n    f.SEQ_NO_END,\n    f.DIGEST])\n\n\nCheckpointState = NamedTuple(CHECKPOINT_STATE, [\n    f.SEQ_NO,   # Current ppSeqNo in the checkpoint\n    f.DIGESTS,  # Digest of all the requests in the checkpoint\n    f.DIGEST,   # Final digest of the checkpoint, after all requests in its\n    # range have been ordered\n    f.RECEIVED_DIGESTS,\n    f.IS_STABLE\n    ])\n\n\n# class ThreePCState(MessageBase):\n#     typename = THREE_PC_STATE\n#     schema = (\n#         (f.INST_ID.nm, NonNegativeNumberField()),\n#         (f.MSGS.nm, IterableField(ClientMessageValidator())),\n#     )\nThreePCState = TaggedTuple(THREE_PC_STATE, [\n    f.INST_ID,\n    f.MSGS])\n\nReply = TaggedTuple(REPLY, [f.RESULT])\n\n\nclass InstanceChange(MessageBase):\n    <IND>typename = INSTANCE_CHANGE\n    schema = (\n        (f.VIEW_NO.nm, NonNegativeNumberField()),\n        (f.REASON.nm, NonNegativeNumberField())\n    )\n# InstanceChange = TaggedTuple(INSTANCE_CHANGE, [\n#     f.VIEW_NO,\n#     f.REASON\n# ])\n\n\n<DED>class LedgerStatus(MessageBase):\n    <IND>typename = LEDGER_STATUS\n    schema = (\n        (f.LEDGER_ID.nm, LedgerIdField()),\n        (f.TXN_SEQ_NO.nm, NonNegativeNumberField()),\n        (f.MERKLE_ROOT.nm, MerkleRootField()),\n    )\n# LedgerStatus = TaggedTuple(LEDGER_STATUS, [\n#     f.LEDGER_ID,\n#     f.TXN_SEQ_NO,\n#     f.MERKLE_ROOT])\n\n\n<DED>class ConsistencyProof(MessageBase):\n    <IND>typename = CONSISTENCY_PROOF\n    schema = (\n        (f.LEDGER_ID.nm, LedgerIdField()),\n        (f.SEQ_NO_START.nm, NonNegativeNumberField()),\n        (f.SEQ_NO_END.nm, NonNegativeNumberField()),\n        (f.PP_SEQ_NO.nm, NonNegativeNumberField()),\n        (f.OLD_MERKLE_ROOT.nm, MerkleRootField()),\n        (f.NEW_MERKLE_ROOT.nm, MerkleRootField()),\n        (f.HASHES.nm, IterableField(NonEmptyStringField())),\n    )\n# ConsistencyProof = TaggedTuple(CONSISTENCY_PROOF, [\n#     f.LEDGER_ID,\n#     f.SEQ_NO_START,\n#     f.SEQ_NO_END,\n#     f.PP_SEQ_NO,\n#     f.OLD_MERKLE_ROOT,\n#     f.NEW_MERKLE_ROOT,\n#     f.HASHES\n# ])\n\n# TODO: Catchup is not a good name, replace it with `sync` or something which\n# is familiar\n\n# class CatchupReq(MessageBase):\n#     typename = CATCHUP_REQ\n#     schema = (\n#         (f.LEDGER_ID.nm, LedgerIdField()),\n#         (f.SEQ_NO_START.nm, NonNegativeNumberField()),\n#         (f.SEQ_NO_END.nm, NonNegativeNumberField()),\n#         (f.CATCHUP_TILL.nm, NonNegativeNumberField()),\n#     )\n<DED>CatchupReq = TaggedTuple(CATCHUP_REQ, [\n    f.LEDGER_ID,\n    f.SEQ_NO_START,\n    f.SEQ_NO_END,\n    f.CATCHUP_TILL\n])\n\n\n# class CatchupRep(MessageBase):\n#     typename = CATCHUP_REQ\n#     schema = (\n#         (f.LEDGER_ID.nm, LedgerIdField()),\n#         (f.TXNS.nm, IterableField(ClientMessageValidator())),\n#         (f.CONS_PROOF.nm, IterableField(HexField(length=64))),\n#     )\nCatchupRep = TaggedTuple(CATCHUP_REP, [\n    f.LEDGER_ID,\n    f.TXNS,\n    f.CONS_PROOF\n])\n\n# class ConsProofRequest(MessageBase):\n#     typename = CONS_PROOF_REQUEST\n#     schema = (\n#         (f.LEDGER_ID.nm, LedgerIdField()),\n#         (f.SEQ_NO_START.nm, NonNegativeNumberField()),\n#         (f.SEQ_NO_END.nm, NonNegativeNumberField()),\n#     )\nConsProofRequest = TaggedTuple(CONS_PROOF_REQUEST, [\n    f.LEDGER_ID,\n    f.SEQ_NO_START,\n    f.SEQ_NO_END\n])\n\n\nTaggedTuples = None  # type: Dict[str, class]\n\n\ndef loadRegistry():\n    <IND>global TaggedTuples\n    if not TaggedTuples:\n        <IND>this = sys.modules[__name__]\n        TaggedTuples = {getattr(this, x).__name__: getattr(this, x)\n                        for x in dir(this) if\n                        callable(getattr(getattr(this, x), \"melted\", None))\n                        and getattr(getattr(this, x), \"_fields\", None)}\n        # attach MessageBase, for pre-testing procedure\n        # TODO: add MessageBase classes another way\n        TaggedTuples.update(\n            {getattr(this, x).typename: getattr(this, x)\n             for x in dir(this)\n             if getattr(getattr(this, x), \"schema\", None) and issubclass(getattr(this, x), MessageBase)}\n        )\n\n<DED><DED>loadRegistry()\n\nThreePhaseType = (PrePrepare, Prepare, Commit)\nThreePhaseMsg = TypeVar(\"3PhaseMsg\", *ThreePhaseType)\n\n\nElectionType = (Nomination, Primary, Reelection)\nElectionMsg = TypeVar(\"ElectionMsg\", *ElectionType)\n\nThreePhaseKey = NamedTuple(\"ThreePhaseKey\", [\n                        f.VIEW_NO,\n                        f.PP_SEQ_NO\n                    ])\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "hyperledger/indy-plenum",
    "commit": "7c33e84e4d9a13ffa73085eb98804e0b35d69e14",
    "filename": "plenum/common/util.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/hyperledger-indy-plenum/plenum/common/util.py",
    "file_hunks_size": 12,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "plenum/common/util.py:184:22 Incompatible variable type [9]: nodeCount is declared to have type `int` but is used as type `None`.",
    "message": " nodeCount is declared to have type `int` but is used as type `None`.",
    "rule_id": "Incompatible variable type [9]",
    "warning_line_no": 184,
    "warning_line": "def get_strong_quorum(nodeCount: int = None, f: int = None) -> int:",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    if nodeCount >= 4:\n        return floor((nodeCount - 1) / 3)\n    else:\n        return 0\n\n\ndef get_strong_quorum(nodeCount: int = None, f: int = None) -> int:\n    r\"\"\"\n    Return the minimum number of nodes where the number of correct nodes is\n    greater than the number of faulty nodes.\n    Calculated as :math:`2*f + 1`\n\n    :param nodeCount: the number of nodes in the system\n    :param f: the max. number of failures\n    \"\"\"\n    if nodeCount is not None:\n        f = getMaxFailures(nodeCount)\n    if f is not None:\n        return 2 * f + 1\n\n\ndef get_weak_quorum(nodeCount: int = None, f: int = None) -> int:\n    if nodeCount is not None:\n        f = getMaxFailures(nodeCount)\n    if f is not None:\n        return f + 1\n\n",
        "source_code_len": 728,
        "target_code": "    if nodeCount >= 4:\n        return int(floor((nodeCount - 1) / 3))\n    else:\n        return 0\n\n",
        "target_code_len": 98,
        "diff_format": "@@ -178,27 +180,5 @@\n     if nodeCount >= 4:\n-        return floor((nodeCount - 1) / 3)\n+        return int(floor((nodeCount - 1) / 3))\n     else:\n         return 0\n-\n-\n-def get_strong_quorum(nodeCount: int = None, f: int = None) -> int:\n-    r\"\"\"\n-    Return the minimum number of nodes where the number of correct nodes is\n-    greater than the number of faulty nodes.\n-    Calculated as :math:`2*f + 1`\n-\n-    :param nodeCount: the number of nodes in the system\n-    :param f: the max. number of failures\n-    \"\"\"\n-    if nodeCount is not None:\n-        f = getMaxFailures(nodeCount)\n-    if f is not None:\n-        return 2 * f + 1\n-\n-\n-def get_weak_quorum(nodeCount: int = None, f: int = None) -> int:\n-    if nodeCount is not None:\n-        f = getMaxFailures(nodeCount)\n-    if f is not None:\n-        return f + 1\n \n",
        "source_code_with_indent": "    if nodeCount >= 4:\n        <IND>return floor((nodeCount - 1) / 3)\n    <DED>else:\n        <IND>return 0\n\n\n<DED><DED>def get_strong_quorum(nodeCount: int = None, f: int = None) -> int:\n    <IND>r\"\"\"\n    Return the minimum number of nodes where the number of correct nodes is\n    greater than the number of faulty nodes.\n    Calculated as :math:`2*f + 1`\n\n    :param nodeCount: the number of nodes in the system\n    :param f: the max. number of failures\n    \"\"\"\n    if nodeCount is not None:\n        <IND>f = getMaxFailures(nodeCount)\n    <DED>if f is not None:\n        <IND>return 2 * f + 1\n\n\n<DED><DED>def get_weak_quorum(nodeCount: int = None, f: int = None) -> int:\n    <IND>if nodeCount is not None:\n        <IND>f = getMaxFailures(nodeCount)\n    <DED>if f is not None:\n        <IND>return f + 1\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    if nodeCount >= 4:\n        <IND>return int(floor((nodeCount - 1) / 3))\n    <DED>else:\n        <IND>return 0\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "hyperledger/indy-plenum",
    "commit": "7c33e84e4d9a13ffa73085eb98804e0b35d69e14",
    "filename": "plenum/common/util.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/hyperledger-indy-plenum/plenum/common/util.py",
    "file_hunks_size": 12,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "plenum/common/util.py:184:45 Incompatible variable type [9]: f is declared to have type `int` but is used as type `None`.",
    "message": " f is declared to have type `int` but is used as type `None`.",
    "rule_id": "Incompatible variable type [9]",
    "warning_line_no": 184,
    "warning_line": "def get_strong_quorum(nodeCount: int = None, f: int = None) -> int:",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    if nodeCount >= 4:\n        return floor((nodeCount - 1) / 3)\n    else:\n        return 0\n\n\ndef get_strong_quorum(nodeCount: int = None, f: int = None) -> int:\n    r\"\"\"\n    Return the minimum number of nodes where the number of correct nodes is\n    greater than the number of faulty nodes.\n    Calculated as :math:`2*f + 1`\n\n    :param nodeCount: the number of nodes in the system\n    :param f: the max. number of failures\n    \"\"\"\n    if nodeCount is not None:\n        f = getMaxFailures(nodeCount)\n    if f is not None:\n        return 2 * f + 1\n\n\ndef get_weak_quorum(nodeCount: int = None, f: int = None) -> int:\n    if nodeCount is not None:\n        f = getMaxFailures(nodeCount)\n    if f is not None:\n        return f + 1\n\n",
        "source_code_len": 728,
        "target_code": "    if nodeCount >= 4:\n        return int(floor((nodeCount - 1) / 3))\n    else:\n        return 0\n\n",
        "target_code_len": 98,
        "diff_format": "@@ -178,27 +180,5 @@\n     if nodeCount >= 4:\n-        return floor((nodeCount - 1) / 3)\n+        return int(floor((nodeCount - 1) / 3))\n     else:\n         return 0\n-\n-\n-def get_strong_quorum(nodeCount: int = None, f: int = None) -> int:\n-    r\"\"\"\n-    Return the minimum number of nodes where the number of correct nodes is\n-    greater than the number of faulty nodes.\n-    Calculated as :math:`2*f + 1`\n-\n-    :param nodeCount: the number of nodes in the system\n-    :param f: the max. number of failures\n-    \"\"\"\n-    if nodeCount is not None:\n-        f = getMaxFailures(nodeCount)\n-    if f is not None:\n-        return 2 * f + 1\n-\n-\n-def get_weak_quorum(nodeCount: int = None, f: int = None) -> int:\n-    if nodeCount is not None:\n-        f = getMaxFailures(nodeCount)\n-    if f is not None:\n-        return f + 1\n \n",
        "source_code_with_indent": "    if nodeCount >= 4:\n        <IND>return floor((nodeCount - 1) / 3)\n    <DED>else:\n        <IND>return 0\n\n\n<DED><DED>def get_strong_quorum(nodeCount: int = None, f: int = None) -> int:\n    <IND>r\"\"\"\n    Return the minimum number of nodes where the number of correct nodes is\n    greater than the number of faulty nodes.\n    Calculated as :math:`2*f + 1`\n\n    :param nodeCount: the number of nodes in the system\n    :param f: the max. number of failures\n    \"\"\"\n    if nodeCount is not None:\n        <IND>f = getMaxFailures(nodeCount)\n    <DED>if f is not None:\n        <IND>return 2 * f + 1\n\n\n<DED><DED>def get_weak_quorum(nodeCount: int = None, f: int = None) -> int:\n    <IND>if nodeCount is not None:\n        <IND>f = getMaxFailures(nodeCount)\n    <DED>if f is not None:\n        <IND>return f + 1\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    if nodeCount >= 4:\n        <IND>return int(floor((nodeCount - 1) / 3))\n    <DED>else:\n        <IND>return 0\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "hyperledger/indy-plenum",
    "commit": "7c33e84e4d9a13ffa73085eb98804e0b35d69e14",
    "filename": "plenum/common/util.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/hyperledger-indy-plenum/plenum/common/util.py",
    "file_hunks_size": 12,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "plenum/common/util.py:196:8 Incompatible return type [7]: Expected `int` but got implicit return value of `None`.",
    "message": " Expected `int` but got implicit return value of `None`.",
    "rule_id": "Incompatible return type [7]",
    "warning_line_no": 196,
    "warning_line": "        return 2 * f + 1",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    if nodeCount >= 4:\n        return floor((nodeCount - 1) / 3)\n    else:\n        return 0\n\n\ndef get_strong_quorum(nodeCount: int = None, f: int = None) -> int:\n    r\"\"\"\n    Return the minimum number of nodes where the number of correct nodes is\n    greater than the number of faulty nodes.\n    Calculated as :math:`2*f + 1`\n\n    :param nodeCount: the number of nodes in the system\n    :param f: the max. number of failures\n    \"\"\"\n    if nodeCount is not None:\n        f = getMaxFailures(nodeCount)\n    if f is not None:\n        return 2 * f + 1\n\n\ndef get_weak_quorum(nodeCount: int = None, f: int = None) -> int:\n    if nodeCount is not None:\n        f = getMaxFailures(nodeCount)\n    if f is not None:\n        return f + 1\n\n",
        "source_code_len": 728,
        "target_code": "    if nodeCount >= 4:\n        return int(floor((nodeCount - 1) / 3))\n    else:\n        return 0\n\n",
        "target_code_len": 98,
        "diff_format": "@@ -178,27 +180,5 @@\n     if nodeCount >= 4:\n-        return floor((nodeCount - 1) / 3)\n+        return int(floor((nodeCount - 1) / 3))\n     else:\n         return 0\n-\n-\n-def get_strong_quorum(nodeCount: int = None, f: int = None) -> int:\n-    r\"\"\"\n-    Return the minimum number of nodes where the number of correct nodes is\n-    greater than the number of faulty nodes.\n-    Calculated as :math:`2*f + 1`\n-\n-    :param nodeCount: the number of nodes in the system\n-    :param f: the max. number of failures\n-    \"\"\"\n-    if nodeCount is not None:\n-        f = getMaxFailures(nodeCount)\n-    if f is not None:\n-        return 2 * f + 1\n-\n-\n-def get_weak_quorum(nodeCount: int = None, f: int = None) -> int:\n-    if nodeCount is not None:\n-        f = getMaxFailures(nodeCount)\n-    if f is not None:\n-        return f + 1\n \n",
        "source_code_with_indent": "    if nodeCount >= 4:\n        <IND>return floor((nodeCount - 1) / 3)\n    <DED>else:\n        <IND>return 0\n\n\n<DED><DED>def get_strong_quorum(nodeCount: int = None, f: int = None) -> int:\n    <IND>r\"\"\"\n    Return the minimum number of nodes where the number of correct nodes is\n    greater than the number of faulty nodes.\n    Calculated as :math:`2*f + 1`\n\n    :param nodeCount: the number of nodes in the system\n    :param f: the max. number of failures\n    \"\"\"\n    if nodeCount is not None:\n        <IND>f = getMaxFailures(nodeCount)\n    <DED>if f is not None:\n        <IND>return 2 * f + 1\n\n\n<DED><DED>def get_weak_quorum(nodeCount: int = None, f: int = None) -> int:\n    <IND>if nodeCount is not None:\n        <IND>f = getMaxFailures(nodeCount)\n    <DED>if f is not None:\n        <IND>return f + 1\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    if nodeCount >= 4:\n        <IND>return int(floor((nodeCount - 1) / 3))\n    <DED>else:\n        <IND>return 0\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "hyperledger/indy-plenum",
    "commit": "7c33e84e4d9a13ffa73085eb98804e0b35d69e14",
    "filename": "plenum/common/util.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/hyperledger-indy-plenum/plenum/common/util.py",
    "file_hunks_size": 12,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "plenum/common/util.py:199:20 Incompatible variable type [9]: nodeCount is declared to have type `int` but is used as type `None`.",
    "message": " nodeCount is declared to have type `int` but is used as type `None`.",
    "rule_id": "Incompatible variable type [9]",
    "warning_line_no": 199,
    "warning_line": "def get_weak_quorum(nodeCount: int = None, f: int = None) -> int:",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    if nodeCount >= 4:\n        return floor((nodeCount - 1) / 3)\n    else:\n        return 0\n\n\ndef get_strong_quorum(nodeCount: int = None, f: int = None) -> int:\n    r\"\"\"\n    Return the minimum number of nodes where the number of correct nodes is\n    greater than the number of faulty nodes.\n    Calculated as :math:`2*f + 1`\n\n    :param nodeCount: the number of nodes in the system\n    :param f: the max. number of failures\n    \"\"\"\n    if nodeCount is not None:\n        f = getMaxFailures(nodeCount)\n    if f is not None:\n        return 2 * f + 1\n\n\ndef get_weak_quorum(nodeCount: int = None, f: int = None) -> int:\n    if nodeCount is not None:\n        f = getMaxFailures(nodeCount)\n    if f is not None:\n        return f + 1\n\n",
        "source_code_len": 728,
        "target_code": "    if nodeCount >= 4:\n        return int(floor((nodeCount - 1) / 3))\n    else:\n        return 0\n\n",
        "target_code_len": 98,
        "diff_format": "@@ -178,27 +180,5 @@\n     if nodeCount >= 4:\n-        return floor((nodeCount - 1) / 3)\n+        return int(floor((nodeCount - 1) / 3))\n     else:\n         return 0\n-\n-\n-def get_strong_quorum(nodeCount: int = None, f: int = None) -> int:\n-    r\"\"\"\n-    Return the minimum number of nodes where the number of correct nodes is\n-    greater than the number of faulty nodes.\n-    Calculated as :math:`2*f + 1`\n-\n-    :param nodeCount: the number of nodes in the system\n-    :param f: the max. number of failures\n-    \"\"\"\n-    if nodeCount is not None:\n-        f = getMaxFailures(nodeCount)\n-    if f is not None:\n-        return 2 * f + 1\n-\n-\n-def get_weak_quorum(nodeCount: int = None, f: int = None) -> int:\n-    if nodeCount is not None:\n-        f = getMaxFailures(nodeCount)\n-    if f is not None:\n-        return f + 1\n \n",
        "source_code_with_indent": "    if nodeCount >= 4:\n        <IND>return floor((nodeCount - 1) / 3)\n    <DED>else:\n        <IND>return 0\n\n\n<DED><DED>def get_strong_quorum(nodeCount: int = None, f: int = None) -> int:\n    <IND>r\"\"\"\n    Return the minimum number of nodes where the number of correct nodes is\n    greater than the number of faulty nodes.\n    Calculated as :math:`2*f + 1`\n\n    :param nodeCount: the number of nodes in the system\n    :param f: the max. number of failures\n    \"\"\"\n    if nodeCount is not None:\n        <IND>f = getMaxFailures(nodeCount)\n    <DED>if f is not None:\n        <IND>return 2 * f + 1\n\n\n<DED><DED>def get_weak_quorum(nodeCount: int = None, f: int = None) -> int:\n    <IND>if nodeCount is not None:\n        <IND>f = getMaxFailures(nodeCount)\n    <DED>if f is not None:\n        <IND>return f + 1\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    if nodeCount >= 4:\n        <IND>return int(floor((nodeCount - 1) / 3))\n    <DED>else:\n        <IND>return 0\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "hyperledger/indy-plenum",
    "commit": "7c33e84e4d9a13ffa73085eb98804e0b35d69e14",
    "filename": "plenum/common/util.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/hyperledger-indy-plenum/plenum/common/util.py",
    "file_hunks_size": 12,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "plenum/common/util.py:199:43 Incompatible variable type [9]: f is declared to have type `int` but is used as type `None`.",
    "message": " f is declared to have type `int` but is used as type `None`.",
    "rule_id": "Incompatible variable type [9]",
    "warning_line_no": 199,
    "warning_line": "def get_weak_quorum(nodeCount: int = None, f: int = None) -> int:",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    if nodeCount >= 4:\n        return floor((nodeCount - 1) / 3)\n    else:\n        return 0\n\n\ndef get_strong_quorum(nodeCount: int = None, f: int = None) -> int:\n    r\"\"\"\n    Return the minimum number of nodes where the number of correct nodes is\n    greater than the number of faulty nodes.\n    Calculated as :math:`2*f + 1`\n\n    :param nodeCount: the number of nodes in the system\n    :param f: the max. number of failures\n    \"\"\"\n    if nodeCount is not None:\n        f = getMaxFailures(nodeCount)\n    if f is not None:\n        return 2 * f + 1\n\n\ndef get_weak_quorum(nodeCount: int = None, f: int = None) -> int:\n    if nodeCount is not None:\n        f = getMaxFailures(nodeCount)\n    if f is not None:\n        return f + 1\n\n",
        "source_code_len": 728,
        "target_code": "    if nodeCount >= 4:\n        return int(floor((nodeCount - 1) / 3))\n    else:\n        return 0\n\n",
        "target_code_len": 98,
        "diff_format": "@@ -178,27 +180,5 @@\n     if nodeCount >= 4:\n-        return floor((nodeCount - 1) / 3)\n+        return int(floor((nodeCount - 1) / 3))\n     else:\n         return 0\n-\n-\n-def get_strong_quorum(nodeCount: int = None, f: int = None) -> int:\n-    r\"\"\"\n-    Return the minimum number of nodes where the number of correct nodes is\n-    greater than the number of faulty nodes.\n-    Calculated as :math:`2*f + 1`\n-\n-    :param nodeCount: the number of nodes in the system\n-    :param f: the max. number of failures\n-    \"\"\"\n-    if nodeCount is not None:\n-        f = getMaxFailures(nodeCount)\n-    if f is not None:\n-        return 2 * f + 1\n-\n-\n-def get_weak_quorum(nodeCount: int = None, f: int = None) -> int:\n-    if nodeCount is not None:\n-        f = getMaxFailures(nodeCount)\n-    if f is not None:\n-        return f + 1\n \n",
        "source_code_with_indent": "    if nodeCount >= 4:\n        <IND>return floor((nodeCount - 1) / 3)\n    <DED>else:\n        <IND>return 0\n\n\n<DED><DED>def get_strong_quorum(nodeCount: int = None, f: int = None) -> int:\n    <IND>r\"\"\"\n    Return the minimum number of nodes where the number of correct nodes is\n    greater than the number of faulty nodes.\n    Calculated as :math:`2*f + 1`\n\n    :param nodeCount: the number of nodes in the system\n    :param f: the max. number of failures\n    \"\"\"\n    if nodeCount is not None:\n        <IND>f = getMaxFailures(nodeCount)\n    <DED>if f is not None:\n        <IND>return 2 * f + 1\n\n\n<DED><DED>def get_weak_quorum(nodeCount: int = None, f: int = None) -> int:\n    <IND>if nodeCount is not None:\n        <IND>f = getMaxFailures(nodeCount)\n    <DED>if f is not None:\n        <IND>return f + 1\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    if nodeCount >= 4:\n        <IND>return int(floor((nodeCount - 1) / 3))\n    <DED>else:\n        <IND>return 0\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "hyperledger/indy-plenum",
    "commit": "7c33e84e4d9a13ffa73085eb98804e0b35d69e14",
    "filename": "plenum/common/util.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/hyperledger-indy-plenum/plenum/common/util.py",
    "file_hunks_size": 12,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "plenum/common/util.py:203:8 Incompatible return type [7]: Expected `int` but got implicit return value of `None`.",
    "message": " Expected `int` but got implicit return value of `None`.",
    "rule_id": "Incompatible return type [7]",
    "warning_line_no": 203,
    "warning_line": "        return f + 1",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    if nodeCount >= 4:\n        return floor((nodeCount - 1) / 3)\n    else:\n        return 0\n\n\ndef get_strong_quorum(nodeCount: int = None, f: int = None) -> int:\n    r\"\"\"\n    Return the minimum number of nodes where the number of correct nodes is\n    greater than the number of faulty nodes.\n    Calculated as :math:`2*f + 1`\n\n    :param nodeCount: the number of nodes in the system\n    :param f: the max. number of failures\n    \"\"\"\n    if nodeCount is not None:\n        f = getMaxFailures(nodeCount)\n    if f is not None:\n        return 2 * f + 1\n\n\ndef get_weak_quorum(nodeCount: int = None, f: int = None) -> int:\n    if nodeCount is not None:\n        f = getMaxFailures(nodeCount)\n    if f is not None:\n        return f + 1\n\n",
        "source_code_len": 728,
        "target_code": "    if nodeCount >= 4:\n        return int(floor((nodeCount - 1) / 3))\n    else:\n        return 0\n\n",
        "target_code_len": 98,
        "diff_format": "@@ -178,27 +180,5 @@\n     if nodeCount >= 4:\n-        return floor((nodeCount - 1) / 3)\n+        return int(floor((nodeCount - 1) / 3))\n     else:\n         return 0\n-\n-\n-def get_strong_quorum(nodeCount: int = None, f: int = None) -> int:\n-    r\"\"\"\n-    Return the minimum number of nodes where the number of correct nodes is\n-    greater than the number of faulty nodes.\n-    Calculated as :math:`2*f + 1`\n-\n-    :param nodeCount: the number of nodes in the system\n-    :param f: the max. number of failures\n-    \"\"\"\n-    if nodeCount is not None:\n-        f = getMaxFailures(nodeCount)\n-    if f is not None:\n-        return 2 * f + 1\n-\n-\n-def get_weak_quorum(nodeCount: int = None, f: int = None) -> int:\n-    if nodeCount is not None:\n-        f = getMaxFailures(nodeCount)\n-    if f is not None:\n-        return f + 1\n \n",
        "source_code_with_indent": "    if nodeCount >= 4:\n        <IND>return floor((nodeCount - 1) / 3)\n    <DED>else:\n        <IND>return 0\n\n\n<DED><DED>def get_strong_quorum(nodeCount: int = None, f: int = None) -> int:\n    <IND>r\"\"\"\n    Return the minimum number of nodes where the number of correct nodes is\n    greater than the number of faulty nodes.\n    Calculated as :math:`2*f + 1`\n\n    :param nodeCount: the number of nodes in the system\n    :param f: the max. number of failures\n    \"\"\"\n    if nodeCount is not None:\n        <IND>f = getMaxFailures(nodeCount)\n    <DED>if f is not None:\n        <IND>return 2 * f + 1\n\n\n<DED><DED>def get_weak_quorum(nodeCount: int = None, f: int = None) -> int:\n    <IND>if nodeCount is not None:\n        <IND>f = getMaxFailures(nodeCount)\n    <DED>if f is not None:\n        <IND>return f + 1\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    if nodeCount >= 4:\n        <IND>return int(floor((nodeCount - 1) / 3))\n    <DED>else:\n        <IND>return 0\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "hyperledger/indy-plenum",
    "commit": "7c33e84e4d9a13ffa73085eb98804e0b35d69e14",
    "filename": "plenum/server/monitor.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/hyperledger-indy-plenum/plenum/server/monitor.py",
    "file_hunks_size": 3,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": true,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "plenum/server/monitor.py:379:8 Incompatible return type [7]: Expected `float` but got `Optional[float]`.",
    "message": " Expected `float` but got `Optional[float]`.",
    "rule_id": "Incompatible return type [7]",
    "warning_line_no": 379,
    "warning_line": "        return reqs / tm if tm else None",
    "min_patch": [
      {
        "hunk_fit_TFix": true,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "        reqs, tm = self.numOrderedRequests[instId]\n        return reqs / tm if tm else None\n\n",
        "source_code_len": 93,
        "target_code": "        reqs, tm = self.numOrderedRequests[instId]\n        return reqs / tm if tm else 0\n\n",
        "target_code_len": 90,
        "diff_format": "@@ -378,3 +378,3 @@\n         reqs, tm = self.numOrderedRequests[instId]\n-        return reqs / tm if tm else None\n+        return reqs / tm if tm else 0\n \n",
        "source_code_with_indent": "        <DED>reqs, tm = self.numOrderedRequests[instId]\n        return reqs / tm if tm else None\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "        <DED>reqs, tm = self.numOrderedRequests[instId]\n        return reqs / tm if tm else 0\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "hyperledger/indy-plenum",
    "commit": "7c33e84e4d9a13ffa73085eb98804e0b35d69e14",
    "filename": "plenum/server/node.py",
    "min_patch_found": false,
    "full_warning_msg": "plenum/server/node.py:242:8 Incompatible attribute type [8]: Attribute `elector` declared in class `Node` has type `PrimaryDecider` but is used as type `None`.",
    "exception": "Cannot have more than 64 hunks in a file",
    "dd_fail": true
  },
  {
    "project": "hyperledger/indy-plenum",
    "commit": "7c33e84e4d9a13ffa73085eb98804e0b35d69e14",
    "filename": "plenum/server/node.py",
    "min_patch_found": false,
    "full_warning_msg": "plenum/server/node.py:1937:43 Incompatible parameter type [6]: Expected `int` for 2nd positional only parameter to call `dict.__setitem__` but got `Tuple[typing.Any, typing.Any]`.",
    "exception": "Cannot have more than 64 hunks in a file",
    "dd_fail": true
  },
  {
    "project": "hyperledger/indy-plenum",
    "commit": "7c33e84e4d9a13ffa73085eb98804e0b35d69e14",
    "filename": "plenum/server/propagator.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/hyperledger-indy-plenum/plenum/server/propagator.py",
    "file_hunks_size": 11,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "plenum/server/propagator.py:88:63 Invalid type [31]: Expression `(bool, str)` is not a valid type.",
    "message": " Expression `(bool, str)` is not a valid type.",
    "rule_id": "Invalid type [31]",
    "warning_line_no": 88,
    "warning_line": "    def canForward(self, req: Request, requiredVotes: int) -> (bool, str):"
  },
  {
    "project": "hyperledger/indy-plenum",
    "commit": "7c33e84e4d9a13ffa73085eb98804e0b35d69e14",
    "filename": "plenum/server/propagator.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/hyperledger-indy-plenum/plenum/server/propagator.py",
    "file_hunks_size": 11,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "plenum/server/propagator.py:163:47 Invalid type [31]: Expression `(bool, str)` is not a valid type.",
    "message": " Expression `(bool, str)` is not a valid type.",
    "rule_id": "Invalid type [31]",
    "warning_line_no": 163,
    "warning_line": "    def canForward(self, request: Request) -> (bool, str):"
  },
  {
    "project": "hyperledger/indy-plenum",
    "commit": "7c33e84e4d9a13ffa73085eb98804e0b35d69e14",
    "filename": "plenum/test/malicious_behaviors_node.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/hyperledger-indy-plenum/plenum/test/malicious_behaviors_node.py",
    "file_hunks_size": 7,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "plenum/test/malicious_behaviors_node.py:104:8 Incompatible attribute type [8]: Attribute `sendPrePrepare` declared in class `plenum.server.replica.Replica` has type `BoundMethod[typing.Callable(plenum.server.replica.Replica.sendPrePrepare)[[Named(self, plenum.server.replica.Replica), Named(ppReq, PrePrepare)], typing.Any], TestReplica]` but is used as type `types.MethodType`.",
    "message": " Attribute `sendPrePrepare` declared in class `plenum.server.replica.Replica` has type `BoundMethod[typing.Callable(plenum.server.replica.Replica.sendPrePrepare)[[Named(self, plenum.server.replica.Replica), Named(ppReq, PrePrepare)], typing.Any], TestReplica]` but is used as type `types.MethodType`.",
    "rule_id": "Incompatible attribute type [8]",
    "warning_line_no": 104,
    "warning_line": "        replica.sendPrePrepare = evilMethod"
  },
  {
    "project": "hyperledger/indy-plenum",
    "commit": "7c33e84e4d9a13ffa73085eb98804e0b35d69e14",
    "filename": "plenum/test/malicious_behaviors_node.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/hyperledger-indy-plenum/plenum/test/malicious_behaviors_node.py",
    "file_hunks_size": 7,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "plenum/test/malicious_behaviors_node.py:106:8 Incompatible attribute type [8]: Attribute `doPrepare` declared in class `plenum.server.replica.Replica` has type `BoundMethod[typing.Callable(plenum.server.replica.Replica.doPrepare)[[Named(self, plenum.server.replica.Replica), Named(pp, PrePrepare)], typing.Any], TestReplica]` but is used as type `types.MethodType`.",
    "message": " Attribute `doPrepare` declared in class `plenum.server.replica.Replica` has type `BoundMethod[typing.Callable(plenum.server.replica.Replica.doPrepare)[[Named(self, plenum.server.replica.Replica), Named(pp, PrePrepare)], typing.Any], TestReplica]` but is used as type `types.MethodType`.",
    "rule_id": "Incompatible attribute type [8]",
    "warning_line_no": 106,
    "warning_line": "        replica.doPrepare = evilMethod"
  },
  {
    "project": "hyperledger/indy-plenum",
    "commit": "7c33e84e4d9a13ffa73085eb98804e0b35d69e14",
    "filename": "plenum/test/malicious_behaviors_node.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/hyperledger-indy-plenum/plenum/test/malicious_behaviors_node.py",
    "file_hunks_size": 7,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "plenum/test/malicious_behaviors_node.py:108:8 Incompatible attribute type [8]: Attribute `doCommit` declared in class `plenum.server.replica.Replica` has type `BoundMethod[typing.Callable(plenum.server.replica.Replica.doCommit)[[Named(self, plenum.server.replica.Replica), Named(p, Prepare)], typing.Any], TestReplica]` but is used as type `types.MethodType`.",
    "message": " Attribute `doCommit` declared in class `plenum.server.replica.Replica` has type `BoundMethod[typing.Callable(plenum.server.replica.Replica.doCommit)[[Named(self, plenum.server.replica.Replica), Named(p, Prepare)], typing.Any], TestReplica]` but is used as type `types.MethodType`.",
    "rule_id": "Incompatible attribute type [8]",
    "warning_line_no": 108,
    "warning_line": "        replica.doCommit = evilMethod"
  },
  {
    "project": "hyperledger/indy-plenum",
    "commit": "7c33e84e4d9a13ffa73085eb98804e0b35d69e14",
    "filename": "plenum/test/malicious_behaviors_node.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/hyperledger-indy-plenum/plenum/test/malicious_behaviors_node.py",
    "file_hunks_size": 7,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "plenum/test/malicious_behaviors_node.py:132:33 Incompatible parameter type [6]: Expected `typing.NamedTuple` for 1st positional only parameter to call `updateNamedTuple` but got `PrePrepare`.",
    "message": " Expected `typing.NamedTuple` for 1st positional only parameter to call `updateNamedTuple` but got `PrePrepare`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 132,
    "warning_line": "        ppReq = updateNamedTuple(ppReq, digest=ppReq.digest+'random')"
  },
  {
    "project": "hyperledger/indy-plenum",
    "commit": "7c33e84e4d9a13ffa73085eb98804e0b35d69e14",
    "filename": "plenum/test/test_node.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/hyperledger-indy-plenum/plenum/test/test_node.py",
    "file_hunks_size": 19,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "plenum/test/test_node.py:393:8 Incompatible return type [7]: Expected `TestNode` but got `typing.Optional[TestNode]`.",
    "message": " Expected `TestNode` but got `typing.Optional[TestNode]`.",
    "rule_id": "Incompatible return type [7]",
    "warning_line_no": 393,
    "warning_line": "        return self.nodes.get(key)"
  },
  {
    "project": "hyperledger/indy-plenum",
    "commit": "7c33e84e4d9a13ffa73085eb98804e0b35d69e14",
    "filename": "plenum/test/test_node.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/hyperledger-indy-plenum/plenum/test/test_node.py",
    "file_hunks_size": 19,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": true,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "plenum/test/test_node.py:431:8 Incompatible return type [7]: Expected `typing.Tuple[typing.Any, ...]` but got `List[typing.Any]`.",
    "message": " Expected `typing.Tuple[typing.Any, ...]` but got `List[typing.Any]`.",
    "rule_id": "Incompatible return type [7]",
    "warning_line_no": 431,
    "warning_line": "        return getAllMsgReceivedForNode(self.getNode(node), method)",
    "min_patch": [
      {
        "hunk_fit_TFix": true,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n    def getAllMsgReceived(self, node: NodeRef, method: str = None) -> Tuple:\n        return getAllMsgReceivedForNode(self.getNode(node), method)\n",
        "source_code_len": 146,
        "target_code": "\n    def getAllMsgReceived(self, node: NodeRef, method: str = None) -> List:\n        return getAllMsgReceivedForNode(self.getNode(node), method)\n",
        "target_code_len": 145,
        "diff_format": "@@ -429,3 +491,3 @@\n \n-    def getAllMsgReceived(self, node: NodeRef, method: str = None) -> Tuple:\n+    def getAllMsgReceived(self, node: NodeRef, method: str = None) -> List:\n         return getAllMsgReceivedForNode(self.getNode(node), method)\n",
        "source_code_with_indent": "\n    <DED>def getAllMsgReceived(self, node: NodeRef, method: str = None) -> Tuple:\n        <IND>return getAllMsgReceivedForNode(self.getNode(node), method)\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n    <DED>def getAllMsgReceived(self, node: NodeRef, method: str = None) -> List:\n        <IND>return getAllMsgReceivedForNode(self.getNode(node), method)\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "hyperledger/indy-plenum",
    "commit": "7c33e84e4d9a13ffa73085eb98804e0b35d69e14",
    "filename": "plenum/test/test_node.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/hyperledger-indy-plenum/plenum/test/test_node.py",
    "file_hunks_size": 19,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "plenum/test/test_node.py:614:35 Incompatible parameter type [6]: Expected `float` for 4th parameter `timeout` to call `checkIfSameReplicaIPrimary` but got `typing.Optional[float]`.",
    "message": " Expected `float` for 4th parameter `timeout` to call `checkIfSameReplicaIPrimary` but got `typing.Optional[float]`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 614,
    "warning_line": "                                   timeout=newTimeout)"
  },
  {
    "project": "hyperledger/indy-plenum",
    "commit": "7c33e84e4d9a13ffa73085eb98804e0b35d69e14",
    "filename": "plenum/test/view_change/test_elections_after_view_change.py",
    "min_patch_found": false,
    "full_warning_msg": "plenum/test/view_change/test_elections_after_view_change.py:40:39 Incompatible parameter type [6]: Expected `typing.Sequence[plenum.test.test_node.TestNode]` for 2nd positional only parameter to call `checkProtocolInstanceSetup` but got `TestNodeSet`.",
    "exception": "[Errno 2] No such file or directory: '/home/chowyi/TypeAnnotation_Study/GitHub/hyperledger-indy-plenum/plenum/test/view_change/test_elections_after_view_change.py'",
    "dd_fail": true
  }
]