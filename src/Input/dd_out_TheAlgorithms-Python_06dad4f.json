[
  {
    "project": "TheAlgorithms/Python",
    "commit": "06dad4f9d8624d9b9a4be56fef47a657f6ce6b82",
    "filename": "blockchain/chinese_remainder_theorem.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/TheAlgorithms-Python/blockchain/chinese_remainder_theorem.py",
    "file_hunks_size": 2,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "blockchain/chinese_remainder_theorem.py:15:40 Invalid type [31]: Expression `(int, int)` is not a valid type.",
    "message": " Expression `(int, int)` is not a valid type.",
    "rule_id": "Invalid type [31]",
    "warning_line_no": 15,
    "warning_line": "def extended_euclid(a: int, b: int) -> (int, int):",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "# Chinese Remainder Theorem:\n# GCD ( Greatest Common Divisor ) or HCF ( Highest Common Factor )\n\n# If GCD(a,b) = 1, then for any remainder ra modulo a and any remainder rb modulo b\n# there exists integer n, such that n = ra (mod a) and n = ra(mod b).  If n1 and n2 are\n# two such integers, then n1=n2(mod ab)\n\n# Algorithm :\n\n# 1. Use extended euclid algorithm to find x,y such that a*x + b*y = 1\n# 2. Take n = ra*by + rb*ax\n\n",
        "source_code_len": 425,
        "target_code": "\"\"\"\nChinese Remainder Theorem:\nGCD ( Greatest Common Divisor ) or HCF ( Highest Common Factor )\n\nIf GCD(a,b) = 1, then for any remainder ra modulo a and any remainder rb modulo b\nthere exists integer n, such that n = ra (mod a) and n = ra(mod b).  If n1 and n2 are\ntwo such integers, then n1=n2(mod ab)\n\nAlgorithm :\n\n1. Use extended euclid algorithm to find x,y such that a*x + b*y = 1\n2. Take n = ra*by + rb*ax\n\"\"\"\nfrom typing import Tuple\n\n",
        "target_code_len": 442,
        "diff_format": "@@ -1,12 +1,15 @@\n-# Chinese Remainder Theorem:\n-# GCD ( Greatest Common Divisor ) or HCF ( Highest Common Factor )\n+\"\"\"\n+Chinese Remainder Theorem:\n+GCD ( Greatest Common Divisor ) or HCF ( Highest Common Factor )\n \n-# If GCD(a,b) = 1, then for any remainder ra modulo a and any remainder rb modulo b\n-# there exists integer n, such that n = ra (mod a) and n = ra(mod b).  If n1 and n2 are\n-# two such integers, then n1=n2(mod ab)\n+If GCD(a,b) = 1, then for any remainder ra modulo a and any remainder rb modulo b\n+there exists integer n, such that n = ra (mod a) and n = ra(mod b).  If n1 and n2 are\n+two such integers, then n1=n2(mod ab)\n \n-# Algorithm :\n+Algorithm :\n \n-# 1. Use extended euclid algorithm to find x,y such that a*x + b*y = 1\n-# 2. Take n = ra*by + rb*ax\n+1. Use extended euclid algorithm to find x,y such that a*x + b*y = 1\n+2. Take n = ra*by + rb*ax\n+\"\"\"\n+from typing import Tuple\n \n",
        "source_code_with_indent": "# Chinese Remainder Theorem:\n# GCD ( Greatest Common Divisor ) or HCF ( Highest Common Factor )\n\n# If GCD(a,b) = 1, then for any remainder ra modulo a and any remainder rb modulo b\n# there exists integer n, such that n = ra (mod a) and n = ra(mod b).  If n1 and n2 are\n# two such integers, then n1=n2(mod ab)\n\n# Algorithm :\n\n# 1. Use extended euclid algorithm to find x,y such that a*x + b*y = 1\n# 2. Take n = ra*by + rb*ax\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\"\"\"\nChinese Remainder Theorem:\nGCD ( Greatest Common Divisor ) or HCF ( Highest Common Factor )\n\nIf GCD(a,b) = 1, then for any remainder ra modulo a and any remainder rb modulo b\nthere exists integer n, such that n = ra (mod a) and n = ra(mod b).  If n1 and n2 are\ntwo such integers, then n1=n2(mod ab)\n\nAlgorithm :\n\n1. Use extended euclid algorithm to find x,y such that a*x + b*y = 1\n2. Take n = ra*by + rb*ax\n\"\"\"\nfrom typing import Tuple\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": true,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "# Extended Euclid\ndef extended_euclid(a: int, b: int) -> (int, int):\n    \"\"\"\n",
        "source_code_len": 77,
        "target_code": "# Extended Euclid\ndef extended_euclid(a: int, b: int) -> Tuple[int, int]:\n    \"\"\"\n",
        "target_code_len": 82,
        "diff_format": "@@ -14,3 +17,3 @@\n # Extended Euclid\n-def extended_euclid(a: int, b: int) -> (int, int):\n+def extended_euclid(a: int, b: int) -> Tuple[int, int]:\n     \"\"\"\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "# Extended Euclid\ndef extended_euclid(a: int, b: int) -> (int, int):\n    <IND>",
        "target_code_with_indent": "# Extended Euclid\ndef extended_euclid(a: int, b: int) -> Tuple[int, int]:\n    <IND>"
      }
    ]
  },
  {
    "project": "TheAlgorithms/Python",
    "commit": "06dad4f9d8624d9b9a4be56fef47a657f6ce6b82",
    "filename": "blockchain/diophantine_equation.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/TheAlgorithms-Python/blockchain/diophantine_equation.py",
    "file_hunks_size": 4,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "blockchain/diophantine_equation.py:8:44 Invalid type [31]: Expression `(int, int)` is not a valid type.",
    "message": " Expression `(int, int)` is not a valid type.",
    "rule_id": "Invalid type [31]",
    "warning_line_no": 8,
    "warning_line": "def diophantine(a: int, b: int, c: int) -> (int, int):",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "# Diophantine Equation : Given integers a,b,c ( at least one of a and b != 0), the\n# diophantine equation a*x + b*y = c has a solution (where x and y are integers)\n# iff gcd(a,b) divides c.\n\n# GCD ( Greatest Common Divisor ) or HCF ( Highest Common Factor )\n\n\ndef diophantine(a: int, b: int, c: int) -> (int, int):\n    \"\"\"\n    >>> diophantine(10,6,14)\n",
        "source_code_len": 352,
        "target_code": "from typing import Tuple\n\n\ndef diophantine(a: int, b: int, c: int) -> Tuple[float, float]:\n    \"\"\"\n    Diophantine Equation : Given integers a,b,c ( at least one of a and b != 0), the\n    diophantine equation a*x + b*y = c has a solution (where x and y are integers)\n    iff gcd(a,b) divides c.\n\n    GCD ( Greatest Common Divisor ) or HCF ( Highest Common Factor )\n\n    >>> diophantine(10,6,14)\n",
        "target_code_len": 395,
        "diff_format": "@@ -1,10 +1,12 @@\n-# Diophantine Equation : Given integers a,b,c ( at least one of a and b != 0), the\n-# diophantine equation a*x + b*y = c has a solution (where x and y are integers)\n-# iff gcd(a,b) divides c.\n-\n-# GCD ( Greatest Common Divisor ) or HCF ( Highest Common Factor )\n+from typing import Tuple\n \n \n-def diophantine(a: int, b: int, c: int) -> (int, int):\n+def diophantine(a: int, b: int, c: int) -> Tuple[float, float]:\n     \"\"\"\n+    Diophantine Equation : Given integers a,b,c ( at least one of a and b != 0), the\n+    diophantine equation a*x + b*y = c has a solution (where x and y are integers)\n+    iff gcd(a,b) divides c.\n+\n+    GCD ( Greatest Common Divisor ) or HCF ( Highest Common Factor )\n+\n     >>> diophantine(10,6,14)\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "# Diophantine Equation : Given integers a,b,c ( at least one of a and b != 0), the\n# diophantine equation a*x + b*y = c has a solution (where x and y are integers)\n# iff gcd(a,b) divides c.\n\n# GCD ( Greatest Common Divisor ) or HCF ( Highest Common Factor )\n\n\ndef diophantine(a: int, b: int, c: int) -> (int, int):\n    <IND>",
        "target_code_with_indent": "from typing import Tuple\n\n\ndef diophantine(a: int, b: int, c: int) -> Tuple[float, float]:\n    <IND>"
      }
    ]
  },
  {
    "project": "TheAlgorithms/Python",
    "commit": "06dad4f9d8624d9b9a4be56fef47a657f6ce6b82",
    "filename": "blockchain/diophantine_equation.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/TheAlgorithms-Python/blockchain/diophantine_equation.py",
    "file_hunks_size": 4,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "blockchain/diophantine_equation.py:101:37 Invalid type [31]: Expression `(int, int, int)` is not a valid type.",
    "message": " Expression `(int, int, int)` is not a valid type.",
    "rule_id": "Invalid type [31]",
    "warning_line_no": 101,
    "warning_line": "def extended_gcd(a: int, b: int) -> (int, int, int):",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "# Diophantine Equation : Given integers a,b,c ( at least one of a and b != 0), the\n# diophantine equation a*x + b*y = c has a solution (where x and y are integers)\n# iff gcd(a,b) divides c.\n\n# GCD ( Greatest Common Divisor ) or HCF ( Highest Common Factor )\n\n\ndef diophantine(a: int, b: int, c: int) -> (int, int):\n    \"\"\"\n    >>> diophantine(10,6,14)\n",
        "source_code_len": 352,
        "target_code": "from typing import Tuple\n\n\ndef diophantine(a: int, b: int, c: int) -> Tuple[float, float]:\n    \"\"\"\n    Diophantine Equation : Given integers a,b,c ( at least one of a and b != 0), the\n    diophantine equation a*x + b*y = c has a solution (where x and y are integers)\n    iff gcd(a,b) divides c.\n\n    GCD ( Greatest Common Divisor ) or HCF ( Highest Common Factor )\n\n    >>> diophantine(10,6,14)\n",
        "target_code_len": 395,
        "diff_format": "@@ -1,10 +1,12 @@\n-# Diophantine Equation : Given integers a,b,c ( at least one of a and b != 0), the\n-# diophantine equation a*x + b*y = c has a solution (where x and y are integers)\n-# iff gcd(a,b) divides c.\n-\n-# GCD ( Greatest Common Divisor ) or HCF ( Highest Common Factor )\n+from typing import Tuple\n \n \n-def diophantine(a: int, b: int, c: int) -> (int, int):\n+def diophantine(a: int, b: int, c: int) -> Tuple[float, float]:\n     \"\"\"\n+    Diophantine Equation : Given integers a,b,c ( at least one of a and b != 0), the\n+    diophantine equation a*x + b*y = c has a solution (where x and y are integers)\n+    iff gcd(a,b) divides c.\n+\n+    GCD ( Greatest Common Divisor ) or HCF ( Highest Common Factor )\n+\n     >>> diophantine(10,6,14)\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "# Diophantine Equation : Given integers a,b,c ( at least one of a and b != 0), the\n# diophantine equation a*x + b*y = c has a solution (where x and y are integers)\n# iff gcd(a,b) divides c.\n\n# GCD ( Greatest Common Divisor ) or HCF ( Highest Common Factor )\n\n\ndef diophantine(a: int, b: int, c: int) -> (int, int):\n    <IND>",
        "target_code_with_indent": "from typing import Tuple\n\n\ndef diophantine(a: int, b: int, c: int) -> Tuple[float, float]:\n    <IND>"
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n# Extended Euclid's Algorithm : If d divides a and b and d = a*x + b*y for integers\n# x and y, then d = gcd(a,b)\n\n\ndef extended_gcd(a: int, b: int) -> (int, int, int):\n    \"\"\"\n    >>> extended_gcd(10, 6)\n",
        "source_code_len": 205,
        "target_code": "\ndef extended_gcd(a: int, b: int) -> Tuple[int, int, int]:\n    \"\"\"\n    Extended Euclid's Algorithm : If d divides a and b and d = a*x + b*y for integers\n    x and y, then d = gcd(a,b)\n\n    >>> extended_gcd(10, 6)\n",
        "target_code_len": 213,
        "diff_format": "@@ -96,8 +97,7 @@\n \n-# Extended Euclid's Algorithm : If d divides a and b and d = a*x + b*y for integers\n-# x and y, then d = gcd(a,b)\n+def extended_gcd(a: int, b: int) -> Tuple[int, int, int]:\n+    \"\"\"\n+    Extended Euclid's Algorithm : If d divides a and b and d = a*x + b*y for integers\n+    x and y, then d = gcd(a,b)\n \n-\n-def extended_gcd(a: int, b: int) -> (int, int, int):\n-    \"\"\"\n     >>> extended_gcd(10, 6)\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\n# Extended Euclid's Algorithm : If d divides a and b and d = a*x + b*y for integers\n# x and y, then d = gcd(a,b)\n\n\n<DED>def extended_gcd(a: int, b: int) -> (int, int, int):\n    <IND>",
        "target_code_with_indent": "\n<DED>def extended_gcd(a: int, b: int) -> Tuple[int, int, int]:\n    <IND>"
      }
    ]
  },
  {
    "project": "TheAlgorithms/Python",
    "commit": "06dad4f9d8624d9b9a4be56fef47a657f6ce6b82",
    "filename": "blockchain/modular_division.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/TheAlgorithms-Python/blockchain/modular_division.py",
    "file_hunks_size": 7,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "blockchain/modular_division.py:75:37 Invalid type [31]: Expression `(int, int, int)` is not a valid type.",
    "message": " Expression `(int, int, int)` is not a valid type.",
    "rule_id": "Invalid type [31]",
    "warning_line_no": 75,
    "warning_line": "def extended_gcd(a: int, b: int) -> (int, int, int):",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "# Modular Division :\n# An efficient algorithm for dividing b by a modulo n.\n\n# GCD ( Greatest Common Divisor ) or HCF ( Highest Common Factor )\n\n# Given three integers a, b, and n, such that gcd(a,n)=1 and n>1, the algorithm should\n# return an integer x such that 0\u2264x\u2264n\u22121, and  b/a=x(modn) (that is, b=ax(modn)).\n\n# Theorem:\n# a has a multiplicative inverse modulo n iff gcd(a,n) = 1\n\n\n# This find x = b*a^(-1) mod n\n# Uses ExtendedEuclid to find the inverse of a\n\n",
        "source_code_len": 465,
        "target_code": "from typing import Tuple\n\n",
        "target_code_len": 26,
        "diff_format": "@@ -1,15 +1,2 @@\n-# Modular Division :\n-# An efficient algorithm for dividing b by a modulo n.\n-\n-# GCD ( Greatest Common Divisor ) or HCF ( Highest Common Factor )\n-\n-# Given three integers a, b, and n, such that gcd(a,n)=1 and n>1, the algorithm should\n-# return an integer x such that 0\u2264x\u2264n\u22121, and  b/a=x(modn) (that is, b=ax(modn)).\n-\n-# Theorem:\n-# a has a multiplicative inverse modulo n iff gcd(a,n) = 1\n-\n-\n-# This find x = b*a^(-1) mod n\n-# Uses ExtendedEuclid to find the inverse of a\n+from typing import Tuple\n \n",
        "source_code_with_indent": "# Modular Division :\n# An efficient algorithm for dividing b by a modulo n.\n\n# GCD ( Greatest Common Divisor ) or HCF ( Highest Common Factor )\n\n# Given three integers a, b, and n, such that gcd(a,n)=1 and n>1, the algorithm should\n# return an integer x such that 0\u2264x\u2264n\u22121, and  b/a=x(modn) (that is, b=ax(modn)).\n\n# Theorem:\n# a has a multiplicative inverse modulo n iff gcd(a,n) = 1\n\n\n# This find x = b*a^(-1) mod n\n# Uses ExtendedEuclid to find the inverse of a\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "from typing import Tuple\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n# Extended Euclid's Algorithm : If d divides a and b and d = a*x + b*y for integers x\n# and y, then d = gcd(a,b)\n\n\ndef extended_gcd(a: int, b: int) -> (int, int, int):\n    \"\"\"\n     >>> extended_gcd(10, 6)\n     (2, -1, 2)\n\n     >>> extended_gcd(7, 5)\n     (1, -2, 3)\n\n",
        "source_code_len": 268,
        "target_code": "\ndef extended_gcd(a: int, b: int) -> Tuple[int, int, int]:\n    \"\"\"\n    Extended Euclid's Algorithm : If d divides a and b and d = a*x + b*y for integers x\n    and y, then d = gcd(a,b)\n    >>> extended_gcd(10, 6)\n    (2, -1, 2)\n\n    >>> extended_gcd(7, 5)\n    (1, -2, 3)\n\n",
        "target_code_len": 271,
        "diff_format": "@@ -70,13 +75,11 @@\n \n-# Extended Euclid's Algorithm : If d divides a and b and d = a*x + b*y for integers x\n-# and y, then d = gcd(a,b)\n+def extended_gcd(a: int, b: int) -> Tuple[int, int, int]:\n+    \"\"\"\n+    Extended Euclid's Algorithm : If d divides a and b and d = a*x + b*y for integers x\n+    and y, then d = gcd(a,b)\n+    >>> extended_gcd(10, 6)\n+    (2, -1, 2)\n \n-\n-def extended_gcd(a: int, b: int) -> (int, int, int):\n-    \"\"\"\n-     >>> extended_gcd(10, 6)\n-     (2, -1, 2)\n-\n-     >>> extended_gcd(7, 5)\n-     (1, -2, 3)\n+    >>> extended_gcd(7, 5)\n+    (1, -2, 3)\n \n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\n# Extended Euclid's Algorithm : If d divides a and b and d = a*x + b*y for integers x\n# and y, then d = gcd(a,b)\n\n\n<DED>def extended_gcd(a: int, b: int) -> (int, int, int):\n    <IND>",
        "target_code_with_indent": "\n<DED>def extended_gcd(a: int, b: int) -> Tuple[int, int, int]:\n    <IND>"
      }
    ]
  },
  {
    "project": "TheAlgorithms/Python",
    "commit": "06dad4f9d8624d9b9a4be56fef47a657f6ce6b82",
    "filename": "blockchain/modular_division.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/TheAlgorithms-Python/blockchain/modular_division.py",
    "file_hunks_size": 7,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "blockchain/modular_division.py:102:40 Invalid type [31]: Expression `(int, int)` is not a valid type.",
    "message": " Expression `(int, int)` is not a valid type.",
    "rule_id": "Invalid type [31]",
    "warning_line_no": 102,
    "warning_line": "def extended_euclid(a: int, b: int) -> (int, int):",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "# Modular Division :\n# An efficient algorithm for dividing b by a modulo n.\n\n# GCD ( Greatest Common Divisor ) or HCF ( Highest Common Factor )\n\n# Given three integers a, b, and n, such that gcd(a,n)=1 and n>1, the algorithm should\n# return an integer x such that 0\u2264x\u2264n\u22121, and  b/a=x(modn) (that is, b=ax(modn)).\n\n# Theorem:\n# a has a multiplicative inverse modulo n iff gcd(a,n) = 1\n\n\n# This find x = b*a^(-1) mod n\n# Uses ExtendedEuclid to find the inverse of a\n\n",
        "source_code_len": 465,
        "target_code": "from typing import Tuple\n\n",
        "target_code_len": 26,
        "diff_format": "@@ -1,15 +1,2 @@\n-# Modular Division :\n-# An efficient algorithm for dividing b by a modulo n.\n-\n-# GCD ( Greatest Common Divisor ) or HCF ( Highest Common Factor )\n-\n-# Given three integers a, b, and n, such that gcd(a,n)=1 and n>1, the algorithm should\n-# return an integer x such that 0\u2264x\u2264n\u22121, and  b/a=x(modn) (that is, b=ax(modn)).\n-\n-# Theorem:\n-# a has a multiplicative inverse modulo n iff gcd(a,n) = 1\n-\n-\n-# This find x = b*a^(-1) mod n\n-# Uses ExtendedEuclid to find the inverse of a\n+from typing import Tuple\n \n",
        "source_code_with_indent": "# Modular Division :\n# An efficient algorithm for dividing b by a modulo n.\n\n# GCD ( Greatest Common Divisor ) or HCF ( Highest Common Factor )\n\n# Given three integers a, b, and n, such that gcd(a,n)=1 and n>1, the algorithm should\n# return an integer x such that 0\u2264x\u2264n\u22121, and  b/a=x(modn) (that is, b=ax(modn)).\n\n# Theorem:\n# a has a multiplicative inverse modulo n iff gcd(a,n) = 1\n\n\n# This find x = b*a^(-1) mod n\n# Uses ExtendedEuclid to find the inverse of a\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "from typing import Tuple\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": true,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n# Extended Euclid\ndef extended_euclid(a: int, b: int) -> (int, int):\n    \"\"\"\n    >>> extended_euclid(10, 6)\n",
        "source_code_len": 109,
        "target_code": "\ndef extended_euclid(a: int, b: int) -> Tuple[int, int]:\n    \"\"\"\n    Extended Euclid\n    >>> extended_euclid(10, 6)\n",
        "target_code_len": 116,
        "diff_format": "@@ -100,5 +103,5 @@\n \n-# Extended Euclid\n-def extended_euclid(a: int, b: int) -> (int, int):\n+def extended_euclid(a: int, b: int) -> Tuple[int, int]:\n     \"\"\"\n+    Extended Euclid\n     >>> extended_euclid(10, 6)\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\n# Extended Euclid\n<DED>def extended_euclid(a: int, b: int) -> (int, int):\n    <IND>",
        "target_code_with_indent": "\n<DED>def extended_euclid(a: int, b: int) -> Tuple[int, int]:\n    <IND>"
      }
    ]
  }
]