[
  {
    "project": "winedarksea/AutoTS",
    "commit": "2819f7919ec38e6aa35e5c1100449d4bbb174a2a",
    "filename": "autots/tools/shaping.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/winedarksea-AutoTS/autots/tools/shaping.py",
    "file_hunks_size": 4,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "autots/tools/shaping.py:241:30 Incompatible variable type [9]: context_length is declared to have type `int` but is used as type `None`.",
    "message": " context_length is declared to have type `int` but is used as type `None`.",
    "rule_id": "Incompatible variable type [9]",
    "warning_line_no": 241,
    "warning_line": "                              context_length: int = None,",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    \n    if forecast_length > int(len(df.index) * (min_allowed_train_percent)):\n        raise ValueError(\"forecast_length is too large, not enough training data, alter min_allowed_train_percent to override, or reduce validation number, if applicable\")\n    \n    train = df.head(len(df.index) - forecast_length)\n    test = df.tail(forecast_length)\n    \n    if (verbose > 0) and ((train.isnull().sum(axis=0)/train.shape[1]).max() > 0.9):\n        print(\"One or more series is 90% or more NaN in this test split\")\n    return train, test\n\n\ndef multiple_train_test_split(df, forecast_length: int = 10,\n                              context_length: int = None,\n                              train_na_tolerance: float = 0.95,\n                              test_na_tolerance: float = 0.75):\n    \"\"\"Uses the last periods of forecast_length as the test set\n    \n    Args:\n        context_length (int):, the length (number of periods) of the train dataset\n        \n        forecast_length (int):, the length of the test dataset\n        \n        train_na_tolerance (float): percent na allowed in train\n        test_na_tolerance (float): percent na allowed in test (1.0 would allow a series of entirely NaN)\n    \n    Returns:\n        train, test    (both pd DataFrames)\n    \"\"\"\n    assert forecast_length > 0, \"forecast_length must be greater than 0\"\n    \n    if context_length is None:\n        context_length = 2 * forecast_length\n    \n    if forecast_length > int(len(df.index) * (min_allowed_train_percent)):\n        raise ValueError(\"forecast_length is too large, not enough training data, alter min_allowed_train_percent to override\")\n    \n    else:\n        train = df.head(len(df.index) - forecast_length)\n        test = df.tail(forecast_length)\n        return train, test\n",
        "source_code_len": 1764,
        "target_code": "    \n    if (forecast_length * min_allowed_train_percent) > int((df.shape[0]) - forecast_length):\n        raise ValueError(\"forecast_length is too large, not enough training data, alter min_allowed_train_percent to override, or reduce validation number, if applicable\")\n\n    train = df.head((df.shape[0]) - forecast_length)\n    test = df.tail(forecast_length)\n\n    if (verbose > 0) and ((train.isnull().sum(axis=0)/train.shape[0]).max() > 0.9):\n        print(\"One or more series is 90% or more NaN in this train split\")\n    if (verbose >= 0) and ((test.isnull().sum(axis=0)/test.shape[0]).max() > 0.9):\n        print(\"One or more series is 90% or more NaN in this test split\")\n    return train, test\n",
        "target_code_len": 700,
        "diff_format": "@@ -228,41 +215,12 @@\n     \n-    if forecast_length > int(len(df.index) * (min_allowed_train_percent)):\n+    if (forecast_length * min_allowed_train_percent) > int((df.shape[0]) - forecast_length):\n         raise ValueError(\"forecast_length is too large, not enough training data, alter min_allowed_train_percent to override, or reduce validation number, if applicable\")\n-    \n-    train = df.head(len(df.index) - forecast_length)\n+\n+    train = df.head((df.shape[0]) - forecast_length)\n     test = df.tail(forecast_length)\n-    \n-    if (verbose > 0) and ((train.isnull().sum(axis=0)/train.shape[1]).max() > 0.9):\n+\n+    if (verbose > 0) and ((train.isnull().sum(axis=0)/train.shape[0]).max() > 0.9):\n+        print(\"One or more series is 90% or more NaN in this train split\")\n+    if (verbose >= 0) and ((test.isnull().sum(axis=0)/test.shape[0]).max() > 0.9):\n         print(\"One or more series is 90% or more NaN in this test split\")\n     return train, test\n-\n-\n-def multiple_train_test_split(df, forecast_length: int = 10,\n-                              context_length: int = None,\n-                              train_na_tolerance: float = 0.95,\n-                              test_na_tolerance: float = 0.75):\n-    \"\"\"Uses the last periods of forecast_length as the test set\n-    \n-    Args:\n-        context_length (int):, the length (number of periods) of the train dataset\n-        \n-        forecast_length (int):, the length of the test dataset\n-        \n-        train_na_tolerance (float): percent na allowed in train\n-        test_na_tolerance (float): percent na allowed in test (1.0 would allow a series of entirely NaN)\n-    \n-    Returns:\n-        train, test    (both pd DataFrames)\n-    \"\"\"\n-    assert forecast_length > 0, \"forecast_length must be greater than 0\"\n-    \n-    if context_length is None:\n-        context_length = 2 * forecast_length\n-    \n-    if forecast_length > int(len(df.index) * (min_allowed_train_percent)):\n-        raise ValueError(\"forecast_length is too large, not enough training data, alter min_allowed_train_percent to override\")\n-    \n-    else:\n-        train = df.head(len(df.index) - forecast_length)\n-        test = df.tail(forecast_length)\n-        return train, test\n",
        "source_code_with_indent": "    \n    if forecast_length > int(len(df.index) * (min_allowed_train_percent)):\n        <IND>raise ValueError(\"forecast_length is too large, not enough training data, alter min_allowed_train_percent to override, or reduce validation number, if applicable\")\n    \n    <DED>train = df.head(len(df.index) - forecast_length)\n    test = df.tail(forecast_length)\n    \n    if (verbose > 0) and ((train.isnull().sum(axis=0)/train.shape[1]).max() > 0.9):\n        <IND>print(\"One or more series is 90% or more NaN in this test split\")\n    <DED>return train, test\n\n\n<DED>def multiple_train_test_split(df, forecast_length: int = 10,\n                              context_length: int = None,\n                              train_na_tolerance: float = 0.95,\n                              test_na_tolerance: float = 0.75):\n    <IND>\"\"\"Uses the last periods of forecast_length as the test set\n    \n    Args:\n        context_length (int):, the length (number of periods) of the train dataset\n        \n        forecast_length (int):, the length of the test dataset\n        \n        train_na_tolerance (float): percent na allowed in train\n        test_na_tolerance (float): percent na allowed in test (1.0 would allow a series of entirely NaN)\n    \n    Returns:\n        train, test    (both pd DataFrames)\n    \"\"\"\n    assert forecast_length > 0, \"forecast_length must be greater than 0\"\n    \n    if context_length is None:\n        <IND>context_length = 2 * forecast_length\n    \n    <DED>if forecast_length > int(len(df.index) * (min_allowed_train_percent)):\n        <IND>raise ValueError(\"forecast_length is too large, not enough training data, alter min_allowed_train_percent to override\")\n    \n    <DED>else:\n        <IND>train = df.head(len(df.index) - forecast_length)\n        test = df.tail(forecast_length)\n        return train, test\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    \n    if (forecast_length * min_allowed_train_percent) > int((df.shape[0]) - forecast_length):\n        <IND>raise ValueError(\"forecast_length is too large, not enough training data, alter min_allowed_train_percent to override, or reduce validation number, if applicable\")\n\n    <DED>train = df.head((df.shape[0]) - forecast_length)\n    test = df.tail(forecast_length)\n\n    if (verbose > 0) and ((train.isnull().sum(axis=0)/train.shape[0]).max() > 0.9):\n        <IND>print(\"One or more series is 90% or more NaN in this train split\")\n    <DED>if (verbose >= 0) and ((test.isnull().sum(axis=0)/test.shape[0]).max() > 0.9):\n        <IND>print(\"One or more series is 90% or more NaN in this test split\")\n    <DED>return train, test\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "winedarksea/AutoTS",
    "commit": "2819f7919ec38e6aa35e5c1100449d4bbb174a2a",
    "filename": "autots/tools/shaping.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/winedarksea-AutoTS/autots/tools/shaping.py",
    "file_hunks_size": 4,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "autots/tools/shaping.py:262:46 Unbound name [10]: Name `min_allowed_train_percent` is used but not defined in the current scope.",
    "message": " Name `min_allowed_train_percent` is used but not defined in the current scope.",
    "rule_id": "Unbound name [10]",
    "warning_line_no": 262,
    "warning_line": "    if forecast_length > int(len(df.index) * (min_allowed_train_percent)):",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    \n    if forecast_length > int(len(df.index) * (min_allowed_train_percent)):\n        raise ValueError(\"forecast_length is too large, not enough training data, alter min_allowed_train_percent to override, or reduce validation number, if applicable\")\n    \n    train = df.head(len(df.index) - forecast_length)\n    test = df.tail(forecast_length)\n    \n    if (verbose > 0) and ((train.isnull().sum(axis=0)/train.shape[1]).max() > 0.9):\n        print(\"One or more series is 90% or more NaN in this test split\")\n    return train, test\n\n\ndef multiple_train_test_split(df, forecast_length: int = 10,\n                              context_length: int = None,\n                              train_na_tolerance: float = 0.95,\n                              test_na_tolerance: float = 0.75):\n    \"\"\"Uses the last periods of forecast_length as the test set\n    \n    Args:\n        context_length (int):, the length (number of periods) of the train dataset\n        \n        forecast_length (int):, the length of the test dataset\n        \n        train_na_tolerance (float): percent na allowed in train\n        test_na_tolerance (float): percent na allowed in test (1.0 would allow a series of entirely NaN)\n    \n    Returns:\n        train, test    (both pd DataFrames)\n    \"\"\"\n    assert forecast_length > 0, \"forecast_length must be greater than 0\"\n    \n    if context_length is None:\n        context_length = 2 * forecast_length\n    \n    if forecast_length > int(len(df.index) * (min_allowed_train_percent)):\n        raise ValueError(\"forecast_length is too large, not enough training data, alter min_allowed_train_percent to override\")\n    \n    else:\n        train = df.head(len(df.index) - forecast_length)\n        test = df.tail(forecast_length)\n        return train, test\n",
        "source_code_len": 1764,
        "target_code": "    \n    if (forecast_length * min_allowed_train_percent) > int((df.shape[0]) - forecast_length):\n        raise ValueError(\"forecast_length is too large, not enough training data, alter min_allowed_train_percent to override, or reduce validation number, if applicable\")\n\n    train = df.head((df.shape[0]) - forecast_length)\n    test = df.tail(forecast_length)\n\n    if (verbose > 0) and ((train.isnull().sum(axis=0)/train.shape[0]).max() > 0.9):\n        print(\"One or more series is 90% or more NaN in this train split\")\n    if (verbose >= 0) and ((test.isnull().sum(axis=0)/test.shape[0]).max() > 0.9):\n        print(\"One or more series is 90% or more NaN in this test split\")\n    return train, test\n",
        "target_code_len": 700,
        "diff_format": "@@ -228,41 +215,12 @@\n     \n-    if forecast_length > int(len(df.index) * (min_allowed_train_percent)):\n+    if (forecast_length * min_allowed_train_percent) > int((df.shape[0]) - forecast_length):\n         raise ValueError(\"forecast_length is too large, not enough training data, alter min_allowed_train_percent to override, or reduce validation number, if applicable\")\n-    \n-    train = df.head(len(df.index) - forecast_length)\n+\n+    train = df.head((df.shape[0]) - forecast_length)\n     test = df.tail(forecast_length)\n-    \n-    if (verbose > 0) and ((train.isnull().sum(axis=0)/train.shape[1]).max() > 0.9):\n+\n+    if (verbose > 0) and ((train.isnull().sum(axis=0)/train.shape[0]).max() > 0.9):\n+        print(\"One or more series is 90% or more NaN in this train split\")\n+    if (verbose >= 0) and ((test.isnull().sum(axis=0)/test.shape[0]).max() > 0.9):\n         print(\"One or more series is 90% or more NaN in this test split\")\n     return train, test\n-\n-\n-def multiple_train_test_split(df, forecast_length: int = 10,\n-                              context_length: int = None,\n-                              train_na_tolerance: float = 0.95,\n-                              test_na_tolerance: float = 0.75):\n-    \"\"\"Uses the last periods of forecast_length as the test set\n-    \n-    Args:\n-        context_length (int):, the length (number of periods) of the train dataset\n-        \n-        forecast_length (int):, the length of the test dataset\n-        \n-        train_na_tolerance (float): percent na allowed in train\n-        test_na_tolerance (float): percent na allowed in test (1.0 would allow a series of entirely NaN)\n-    \n-    Returns:\n-        train, test    (both pd DataFrames)\n-    \"\"\"\n-    assert forecast_length > 0, \"forecast_length must be greater than 0\"\n-    \n-    if context_length is None:\n-        context_length = 2 * forecast_length\n-    \n-    if forecast_length > int(len(df.index) * (min_allowed_train_percent)):\n-        raise ValueError(\"forecast_length is too large, not enough training data, alter min_allowed_train_percent to override\")\n-    \n-    else:\n-        train = df.head(len(df.index) - forecast_length)\n-        test = df.tail(forecast_length)\n-        return train, test\n",
        "source_code_with_indent": "    \n    if forecast_length > int(len(df.index) * (min_allowed_train_percent)):\n        <IND>raise ValueError(\"forecast_length is too large, not enough training data, alter min_allowed_train_percent to override, or reduce validation number, if applicable\")\n    \n    <DED>train = df.head(len(df.index) - forecast_length)\n    test = df.tail(forecast_length)\n    \n    if (verbose > 0) and ((train.isnull().sum(axis=0)/train.shape[1]).max() > 0.9):\n        <IND>print(\"One or more series is 90% or more NaN in this test split\")\n    <DED>return train, test\n\n\n<DED>def multiple_train_test_split(df, forecast_length: int = 10,\n                              context_length: int = None,\n                              train_na_tolerance: float = 0.95,\n                              test_na_tolerance: float = 0.75):\n    <IND>\"\"\"Uses the last periods of forecast_length as the test set\n    \n    Args:\n        context_length (int):, the length (number of periods) of the train dataset\n        \n        forecast_length (int):, the length of the test dataset\n        \n        train_na_tolerance (float): percent na allowed in train\n        test_na_tolerance (float): percent na allowed in test (1.0 would allow a series of entirely NaN)\n    \n    Returns:\n        train, test    (both pd DataFrames)\n    \"\"\"\n    assert forecast_length > 0, \"forecast_length must be greater than 0\"\n    \n    if context_length is None:\n        <IND>context_length = 2 * forecast_length\n    \n    <DED>if forecast_length > int(len(df.index) * (min_allowed_train_percent)):\n        <IND>raise ValueError(\"forecast_length is too large, not enough training data, alter min_allowed_train_percent to override\")\n    \n    <DED>else:\n        <IND>train = df.head(len(df.index) - forecast_length)\n        test = df.tail(forecast_length)\n        return train, test\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    \n    if (forecast_length * min_allowed_train_percent) > int((df.shape[0]) - forecast_length):\n        <IND>raise ValueError(\"forecast_length is too large, not enough training data, alter min_allowed_train_percent to override, or reduce validation number, if applicable\")\n\n    <DED>train = df.head((df.shape[0]) - forecast_length)\n    test = df.tail(forecast_length)\n\n    if (verbose > 0) and ((train.isnull().sum(axis=0)/train.shape[0]).max() > 0.9):\n        <IND>print(\"One or more series is 90% or more NaN in this train split\")\n    <DED>if (verbose >= 0) and ((test.isnull().sum(axis=0)/test.shape[0]).max() > 0.9):\n        <IND>print(\"One or more series is 90% or more NaN in this test split\")\n    <DED>return train, test\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  }
]