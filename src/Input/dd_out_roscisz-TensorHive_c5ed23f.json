[
  {
    "project": "roscisz/TensorHive",
    "commit": "c5ed23f82597837b0e216b50225fb7d7cd79c15c",
    "filename": "tensorhive/core/violation_handlers/EmailSendingBehaviour.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/roscisz-TensorHive/tensorhive/core/violation_handlers/EmailSendingBehaviour.py",
    "file_hunks_size": 7,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "tensorhive/core/violation_handlers/EmailSendingBehaviour.py:71:8 Incompatible variable type [9]: email is declared to have type `str` but is used as type `Message`.",
    "message": " email is declared to have type `str` but is used as type `Message`.",
    "rule_id": "Incompatible variable type [9]",
    "warning_line_no": 71,
    "warning_line": "        email = Message(author=MAILBOT.SMTP_LOGIN, to=email, subject=MAILBOT.INTRUDER_SUBJECT, body=email_body)",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "class EmailSendingBehaviour:\n    '''TODO'''\n\n    def __init__(self) -> None:\n        '''TODO'''\n        self.mailer = Mailer(server=MAILBOT.SMTP_SERVER, port=MAILBOT.SMTP_PORT)\n        self.test_smtp_configuration()\n        self.interval = datetime.timedelta(minutes=MAILBOT.INTERVAL)\n        self.timers = {}\n\n    def time_to_resend(self, timer: LastEmailTime, to_admin: Optional[bool] = False) -> bool:\n        '''TODO'''\n        if to_admin:\n",
        "source_code_len": 445,
        "target_code": "class EmailSendingBehaviour:\n    '''\n    When violation is triggered by ProtectionHandler it tries to contact\n    intruder and/or admin via email.\n\n    They get individual email message based on different HTML templates.\n    It will send messages periodically (every `self.interval` time)\n\n    There is `self.timers` memory which stores who and when was recentyl emailed.\n    If intruder does not have email assigned (or no account at all),\n    only admin will be notified (MAILBOT.NOTIFY_ADMIN and MAILBOT.ADMIN_EMAIL must be configured)\n\n    If SMTP configuration (server or credentials) are incorrect,\n    it will be logged each time `trigger_action` is called.\n    '''\n\n    def __init__(self) -> None:\n        self.mailer = Mailer(server=MAILBOT.SMTP_SERVER, port=MAILBOT.SMTP_PORT)\n        self._test_smtp_configuration()\n        self.interval = datetime.timedelta(minutes=MAILBOT.INTERVAL)\n        self.timers = {}  # type: Dict[str, LastEmailTime]\n\n    @override\n    def trigger_action(self, violation_data: Dict[str, Any]) -> None:\n        '''Contains business logic for intruder and admin email notifications.\n        It relies on early returns if any error occures.\n\n        :param violation_data: data received from ProtectionService\n        '''\n        # Expect certain keys beforehand\n        assert {'INTRUDER_USERNAME', 'RESERVATION_OWNER_USERNAME',\n                'RESERVATION_OWNER_EMAIL', 'RESERVATION_END', 'UUID', 'HOSTNAME'\n                }.issubset(violation_data), 'Invalid keys in violation_data'\n\n        if not self._test_smtp_configuration():\n            return\n\n        try:\n            # Fetch intruder email address and extend violation data\n            intruder_email = User.find_by_username(violation_data['INTRUDER_USERNAME']).email\n        except NoResultFound as e:\n            intruder_email = None\n            log.warning(e)\n        finally:\n            violation_data['INTRUDER_EMAIL'] = intruder_email\n\n        if not intruder_email:\n            # Intruder has no account or email assigned, try notify admin then\n            timer = self._get_timer(violation_data['INTRUDER_USERNAME'])\n            if MAILBOT.NOTIFY_ADMIN and self._time_to_resend(timer, to_admin=True):\n                self._email_admin(violation_data, timer)\n            return\n\n        # Intruder has account and email address, try email him and admin then\n        timer = self._get_timer(intruder_email)\n        if MAILBOT.NOTIFY_INTRUDER and self._time_to_resend(timer):\n            self._email_intruder(intruder_email, violation_data, timer)\n        if MAILBOT.NOTIFY_ADMIN and self._time_to_resend(timer, to_admin=True):\n            self._email_admin(violation_data, timer)\n\n    def _time_to_resend(self, timer: LastEmailTime, to_admin: Optional[bool] = False) -> bool:\n        '''Returns whether last email was sent min X time ago.'''\n        if to_admin:\n",
        "target_code_len": 2871,
        "diff_format": "@@ -24,13 +26,63 @@\n class EmailSendingBehaviour:\n-    '''TODO'''\n+    '''\n+    When violation is triggered by ProtectionHandler it tries to contact\n+    intruder and/or admin via email.\n+\n+    They get individual email message based on different HTML templates.\n+    It will send messages periodically (every `self.interval` time)\n+\n+    There is `self.timers` memory which stores who and when was recentyl emailed.\n+    If intruder does not have email assigned (or no account at all),\n+    only admin will be notified (MAILBOT.NOTIFY_ADMIN and MAILBOT.ADMIN_EMAIL must be configured)\n+\n+    If SMTP configuration (server or credentials) are incorrect,\n+    it will be logged each time `trigger_action` is called.\n+    '''\n \n     def __init__(self) -> None:\n-        '''TODO'''\n         self.mailer = Mailer(server=MAILBOT.SMTP_SERVER, port=MAILBOT.SMTP_PORT)\n-        self.test_smtp_configuration()\n+        self._test_smtp_configuration()\n         self.interval = datetime.timedelta(minutes=MAILBOT.INTERVAL)\n-        self.timers = {}\n+        self.timers = {}  # type: Dict[str, LastEmailTime]\n \n-    def time_to_resend(self, timer: LastEmailTime, to_admin: Optional[bool] = False) -> bool:\n-        '''TODO'''\n+    @override\n+    def trigger_action(self, violation_data: Dict[str, Any]) -> None:\n+        '''Contains business logic for intruder and admin email notifications.\n+        It relies on early returns if any error occures.\n+\n+        :param violation_data: data received from ProtectionService\n+        '''\n+        # Expect certain keys beforehand\n+        assert {'INTRUDER_USERNAME', 'RESERVATION_OWNER_USERNAME',\n+                'RESERVATION_OWNER_EMAIL', 'RESERVATION_END', 'UUID', 'HOSTNAME'\n+                }.issubset(violation_data), 'Invalid keys in violation_data'\n+\n+        if not self._test_smtp_configuration():\n+            return\n+\n+        try:\n+            # Fetch intruder email address and extend violation data\n+            intruder_email = User.find_by_username(violation_data['INTRUDER_USERNAME']).email\n+        except NoResultFound as e:\n+            intruder_email = None\n+            log.warning(e)\n+        finally:\n+            violation_data['INTRUDER_EMAIL'] = intruder_email\n+\n+        if not intruder_email:\n+            # Intruder has no account or email assigned, try notify admin then\n+            timer = self._get_timer(violation_data['INTRUDER_USERNAME'])\n+            if MAILBOT.NOTIFY_ADMIN and self._time_to_resend(timer, to_admin=True):\n+                self._email_admin(violation_data, timer)\n+            return\n+\n+        # Intruder has account and email address, try email him and admin then\n+        timer = self._get_timer(intruder_email)\n+        if MAILBOT.NOTIFY_INTRUDER and self._time_to_resend(timer):\n+            self._email_intruder(intruder_email, violation_data, timer)\n+        if MAILBOT.NOTIFY_ADMIN and self._time_to_resend(timer, to_admin=True):\n+            self._email_admin(violation_data, timer)\n+\n+    def _time_to_resend(self, timer: LastEmailTime, to_admin: Optional[bool] = False) -> bool:\n+        '''Returns whether last email was sent min X time ago.'''\n         if to_admin:\n",
        "source_code_with_indent": "<DED><DED>class EmailSendingBehaviour:\n    <IND>'''TODO'''\n\n    def __init__(self) -> None:\n        <IND>'''TODO'''\n        self.mailer = Mailer(server=MAILBOT.SMTP_SERVER, port=MAILBOT.SMTP_PORT)\n        self.test_smtp_configuration()\n        self.interval = datetime.timedelta(minutes=MAILBOT.INTERVAL)\n        self.timers = {}\n\n    <DED>def time_to_resend(self, timer: LastEmailTime, to_admin: Optional[bool] = False) -> bool:\n        <IND>'''TODO'''\n        if to_admin:\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "<DED><DED>class EmailSendingBehaviour:\n    <IND>'''\n    When violation is triggered by ProtectionHandler it tries to contact\n    intruder and/or admin via email.\n\n    They get individual email message based on different HTML templates.\n    It will send messages periodically (every `self.interval` time)\n\n    There is `self.timers` memory which stores who and when was recentyl emailed.\n    If intruder does not have email assigned (or no account at all),\n    only admin will be notified (MAILBOT.NOTIFY_ADMIN and MAILBOT.ADMIN_EMAIL must be configured)\n\n    If SMTP configuration (server or credentials) are incorrect,\n    it will be logged each time `trigger_action` is called.\n    '''\n\n    def __init__(self) -> None:\n        <IND>self.mailer = Mailer(server=MAILBOT.SMTP_SERVER, port=MAILBOT.SMTP_PORT)\n        self._test_smtp_configuration()\n        self.interval = datetime.timedelta(minutes=MAILBOT.INTERVAL)\n        self.timers = {}  # type: Dict[str, LastEmailTime]\n\n    <DED>@override\n    def trigger_action(self, violation_data: Dict[str, Any]) -> None:\n        <IND>'''Contains business logic for intruder and admin email notifications.\n        It relies on early returns if any error occures.\n\n        :param violation_data: data received from ProtectionService\n        '''\n        # Expect certain keys beforehand\n        assert {'INTRUDER_USERNAME', 'RESERVATION_OWNER_USERNAME',\n                'RESERVATION_OWNER_EMAIL', 'RESERVATION_END', 'UUID', 'HOSTNAME'\n                }.issubset(violation_data), 'Invalid keys in violation_data'\n\n        if not self._test_smtp_configuration():\n            <IND>return\n\n        <DED>try:\n            # Fetch intruder email address and extend violation data\n            <IND>intruder_email = User.find_by_username(violation_data['INTRUDER_USERNAME']).email\n        <DED>except NoResultFound as e:\n            <IND>intruder_email = None\n            log.warning(e)\n        <DED>finally:\n            <IND>violation_data['INTRUDER_EMAIL'] = intruder_email\n\n        <DED>if not intruder_email:\n            # Intruder has no account or email assigned, try notify admin then\n            <IND>timer = self._get_timer(violation_data['INTRUDER_USERNAME'])\n            if MAILBOT.NOTIFY_ADMIN and self._time_to_resend(timer, to_admin=True):\n                <IND>self._email_admin(violation_data, timer)\n            <DED>return\n\n        # Intruder has account and email address, try email him and admin then\n        <DED>timer = self._get_timer(intruder_email)\n        if MAILBOT.NOTIFY_INTRUDER and self._time_to_resend(timer):\n            <IND>self._email_intruder(intruder_email, violation_data, timer)\n        <DED>if MAILBOT.NOTIFY_ADMIN and self._time_to_resend(timer, to_admin=True):\n            <IND>self._email_admin(violation_data, timer)\n\n    <DED><DED>def _time_to_resend(self, timer: LastEmailTime, to_admin: Optional[bool] = False) -> bool:\n        <IND>'''Returns whether last email was sent min X time ago.'''\n        if to_admin:\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n    def get_timer(self, keyname: str) -> Dict[str, datetime.datetime]:\n        '''TODO'''\n        try:\n",
        "source_code_len": 104,
        "target_code": "\n    def _get_timer(self, keyname: str) -> LastEmailTime:\n        '''Safe dict fetching. It will create missing key with default value.'''\n        try:\n",
        "target_code_len": 152,
        "diff_format": "@@ -41,4 +93,4 @@\n \n-    def get_timer(self, keyname: str) -> Dict[str, datetime.datetime]:\n-        '''TODO'''\n+    def _get_timer(self, keyname: str) -> LastEmailTime:\n+        '''Safe dict fetching. It will create missing key with default value.'''\n         try:\n",
        "source_code_with_indent": "\n    <DED>def get_timer(self, keyname: str) -> Dict[str, datetime.datetime]:\n        <IND>'''TODO'''\n        try:\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n    <DED>def _get_timer(self, keyname: str) -> LastEmailTime:\n        <IND>'''Safe dict fetching. It will create missing key with default value.'''\n        try:\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n    def test_smtp_configuration(self) -> bool:\n        try:\n",
        "source_code_len": 61,
        "target_code": "\n    def _test_smtp_configuration(self) -> bool:\n        '''Does very basic checks whether config variables are not None (which is the default).\n        Then, it tries to establish an SMTP connection.\n        It logs error reason and appropriate hint.\n        '''\n        try:\n",
        "target_code_len": 277,
        "diff_format": "@@ -51,3 +103,7 @@\n \n-    def test_smtp_configuration(self) -> bool:\n+    def _test_smtp_configuration(self) -> bool:\n+        '''Does very basic checks whether config variables are not None (which is the default).\n+        Then, it tries to establish an SMTP connection.\n+        It logs error reason and appropriate hint.\n+        '''\n         try:\n",
        "source_code_with_indent": "\n    <DED><DED>def test_smtp_configuration(self) -> bool:\n        <IND>try:\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n    <DED><DED>def _test_smtp_configuration(self) -> bool:\n        <IND>'''Does very basic checks whether config variables are not None (which is the default).\n        Then, it tries to establish an SMTP connection.\n        It logs error reason and appropriate hint.\n        '''\n        try:\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": true,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n    def email_intruder(self, email: str, violation_data: Dict, timer: LastEmailTime) -> None:\n        email_body = MessageBodyTemplater(template=MAILBOT.INTRUDER_BODY_TEMPLATE).fill_in(data=violation_data)\n        email = Message(author=MAILBOT.SMTP_LOGIN, to=email, subject=MAILBOT.INTRUDER_SUBJECT, body=email_body)\n        self.mailer.send(email)\n",
        "source_code_len": 351,
        "target_code": "\n    def _email_intruder(self, email_address: str, violation_data: Dict, timer: LastEmailTime) -> None:\n        '''Prepare message, send and update timer.'''\n        email_body = MessageBodyTemplater(template=MAILBOT.INTRUDER_BODY_TEMPLATE).fill_in(data=violation_data)\n        email = Message(author=MAILBOT.SMTP_LOGIN, to=email_address, subject=MAILBOT.INTRUDER_SUBJECT, body=email_body)\n        self.mailer.send(email)\n",
        "target_code_len": 422,
        "diff_format": "@@ -68,5 +124,6 @@\n \n-    def email_intruder(self, email: str, violation_data: Dict, timer: LastEmailTime) -> None:\n+    def _email_intruder(self, email_address: str, violation_data: Dict, timer: LastEmailTime) -> None:\n+        '''Prepare message, send and update timer.'''\n         email_body = MessageBodyTemplater(template=MAILBOT.INTRUDER_BODY_TEMPLATE).fill_in(data=violation_data)\n-        email = Message(author=MAILBOT.SMTP_LOGIN, to=email, subject=MAILBOT.INTRUDER_SUBJECT, body=email_body)\n+        email = Message(author=MAILBOT.SMTP_LOGIN, to=email_address, subject=MAILBOT.INTRUDER_SUBJECT, body=email_body)\n         self.mailer.send(email)\n",
        "source_code_with_indent": "\n    <DED><DED>def email_intruder(self, email: str, violation_data: Dict, timer: LastEmailTime) -> None:\n        <IND>email_body = MessageBodyTemplater(template=MAILBOT.INTRUDER_BODY_TEMPLATE).fill_in(data=violation_data)\n        email = Message(author=MAILBOT.SMTP_LOGIN, to=email, subject=MAILBOT.INTRUDER_SUBJECT, body=email_body)\n        self.mailer.send(email)\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n    <DED><DED>def _email_intruder(self, email_address: str, violation_data: Dict, timer: LastEmailTime) -> None:\n        <IND>'''Prepare message, send and update timer.'''\n        email_body = MessageBodyTemplater(template=MAILBOT.INTRUDER_BODY_TEMPLATE).fill_in(data=violation_data)\n        email = Message(author=MAILBOT.SMTP_LOGIN, to=email_address, subject=MAILBOT.INTRUDER_SUBJECT, body=email_body)\n        self.mailer.send(email)\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n    def email_admin(self, violation_data: Dict, timer: LastEmailTime) -> None:\n        email_body = MessageBodyTemplater(template=MAILBOT.ADMIN_BODY_TEMPLATE).fill_in(data=violation_data)\n",
        "source_code_len": 189,
        "target_code": "\n    def _email_admin(self, violation_data: Dict, timer: LastEmailTime) -> None:\n        '''Prepare message, send and update timer.'''\n        email_body = MessageBodyTemplater(template=MAILBOT.ADMIN_BODY_TEMPLATE).fill_in(data=violation_data)\n",
        "target_code_len": 244,
        "diff_format": "@@ -75,3 +132,4 @@\n \n-    def email_admin(self, violation_data: Dict, timer: LastEmailTime) -> None:\n+    def _email_admin(self, violation_data: Dict, timer: LastEmailTime) -> None:\n+        '''Prepare message, send and update timer.'''\n         email_body = MessageBodyTemplater(template=MAILBOT.ADMIN_BODY_TEMPLATE).fill_in(data=violation_data)\n",
        "source_code_with_indent": "\n    <DED>def email_admin(self, violation_data: Dict, timer: LastEmailTime) -> None:\n        <IND>email_body = MessageBodyTemplater(template=MAILBOT.ADMIN_BODY_TEMPLATE).fill_in(data=violation_data)\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n    <DED>def _email_admin(self, violation_data: Dict, timer: LastEmailTime) -> None:\n        <IND>'''Prepare message, send and update timer.'''\n        email_body = MessageBodyTemplater(template=MAILBOT.ADMIN_BODY_TEMPLATE).fill_in(data=violation_data)\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": true,
        "has_suppression": false,
        "source_code": "        log.info('Email to admin has been sent: {}'.format(email))\n\n    @override\n    def trigger_action(self, violation_data: Dict[str, Any]) -> None:\n        '''TODO'''\n        # Expect proper keys beforehand\n        assert {\n            'INTRUDER_USERNAME',\n            'RESERVATION_OWNER_USERNAME',\n            'RESERVATION_OWNER_EMAIL',\n            'RESERVATION_END',\n            'UUID',\n            'HOSTNAME'}.issubset(violation_data), 'Invalid keys in violation_data'\n\n        if not self.test_smtp_configuration():\n            return\n\n        try:\n            # Fetch email address and extend violation data\n            intruder_email = User.find_by_username(violation_data['INTRUDER_USERNAME']).email\n        except NoResultFound as e:\n            intruder_email = None\n            log.warning(e)\n        finally:\n            violation_data['INTRUDER_EMAIL'] = intruder_email\n\n        if not intruder_email:\n            # At least try notify admin\n            timer = self.get_timer(violation_data['INTRUDER_USERNAME'])\n            if MAILBOT.NOTIFY_ADMIN and self.time_to_resend(timer, to_admin=True):\n                self.email_admin(violation_data, timer)\n            return\n\n        # Try email both\n        timer = self.get_timer(intruder_email)\n        if MAILBOT.NOTIFY_INTRUDER and self.time_to_resend(timer):\n            self.email_intruder(intruder_email, violation_data, timer)\n        if MAILBOT.NOTIFY_ADMIN and self.time_to_resend(timer, to_admin=True):\n            self.email_admin(violation_data, timer)\n",
        "source_code_len": 1530,
        "target_code": "        log.info('Email to admin has been sent: {}'.format(email))\n",
        "target_code_len": 67,
        "diff_format": "@@ -82,39 +140,1 @@\n         log.info('Email to admin has been sent: {}'.format(email))\n-\n-    @override\n-    def trigger_action(self, violation_data: Dict[str, Any]) -> None:\n-        '''TODO'''\n-        # Expect proper keys beforehand\n-        assert {\n-            'INTRUDER_USERNAME',\n-            'RESERVATION_OWNER_USERNAME',\n-            'RESERVATION_OWNER_EMAIL',\n-            'RESERVATION_END',\n-            'UUID',\n-            'HOSTNAME'}.issubset(violation_data), 'Invalid keys in violation_data'\n-\n-        if not self.test_smtp_configuration():\n-            return\n-\n-        try:\n-            # Fetch email address and extend violation data\n-            intruder_email = User.find_by_username(violation_data['INTRUDER_USERNAME']).email\n-        except NoResultFound as e:\n-            intruder_email = None\n-            log.warning(e)\n-        finally:\n-            violation_data['INTRUDER_EMAIL'] = intruder_email\n-\n-        if not intruder_email:\n-            # At least try notify admin\n-            timer = self.get_timer(violation_data['INTRUDER_USERNAME'])\n-            if MAILBOT.NOTIFY_ADMIN and self.time_to_resend(timer, to_admin=True):\n-                self.email_admin(violation_data, timer)\n-            return\n-\n-        # Try email both\n-        timer = self.get_timer(intruder_email)\n-        if MAILBOT.NOTIFY_INTRUDER and self.time_to_resend(timer):\n-            self.email_intruder(intruder_email, violation_data, timer)\n-        if MAILBOT.NOTIFY_ADMIN and self.time_to_resend(timer, to_admin=True):\n-            self.email_admin(violation_data, timer)\n",
        "source_code_with_indent": "        log.info('Email to admin has been sent: {}'.format(email))\n\n    <DED>@override\n    def trigger_action(self, violation_data: Dict[str, Any]) -> None:\n        <IND>'''TODO'''\n        # Expect proper keys beforehand\n        assert {\n            'INTRUDER_USERNAME',\n            'RESERVATION_OWNER_USERNAME',\n            'RESERVATION_OWNER_EMAIL',\n            'RESERVATION_END',\n            'UUID',\n            'HOSTNAME'}.issubset(violation_data), 'Invalid keys in violation_data'\n\n        if not self.test_smtp_configuration():\n            <IND>return\n\n        <DED>try:\n            # Fetch email address and extend violation data\n            <IND>intruder_email = User.find_by_username(violation_data['INTRUDER_USERNAME']).email\n        <DED>except NoResultFound as e:\n            <IND>intruder_email = None\n            log.warning(e)\n        <DED>finally:\n            <IND>violation_data['INTRUDER_EMAIL'] = intruder_email\n\n        <DED>if not intruder_email:\n            # At least try notify admin\n            <IND>timer = self.get_timer(violation_data['INTRUDER_USERNAME'])\n            if MAILBOT.NOTIFY_ADMIN and self.time_to_resend(timer, to_admin=True):\n                <IND>self.email_admin(violation_data, timer)\n            <DED>return\n\n        # Try email both\n        <DED>timer = self.get_timer(intruder_email)\n        if MAILBOT.NOTIFY_INTRUDER and self.time_to_resend(timer):\n            <IND>self.email_intruder(intruder_email, violation_data, timer)\n        <DED>if MAILBOT.NOTIFY_ADMIN and self.time_to_resend(timer, to_admin=True):\n            <IND>self.email_admin(violation_data, timer)\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "        log.info('Email to admin has been sent: {}'.format(email))\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "roscisz/TensorHive",
    "commit": "c5ed23f82597837b0e216b50225fb7d7cd79c15c",
    "filename": "tensorhive/core/violation_handlers/EmailSendingBehaviour.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/roscisz-TensorHive/tensorhive/core/violation_handlers/EmailSendingBehaviour.py",
    "file_hunks_size": 7,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "tensorhive/core/violation_handlers/EmailSendingBehaviour.py:72:25 Incompatible parameter type [6]: Expected `Message` for 1st positional only parameter to call `Mailer.send` but got `str`.",
    "message": " Expected `Message` for 1st positional only parameter to call `Mailer.send` but got `str`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 72,
    "warning_line": "        self.mailer.send(email)",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "class EmailSendingBehaviour:\n    '''TODO'''\n\n    def __init__(self) -> None:\n        '''TODO'''\n        self.mailer = Mailer(server=MAILBOT.SMTP_SERVER, port=MAILBOT.SMTP_PORT)\n        self.test_smtp_configuration()\n        self.interval = datetime.timedelta(minutes=MAILBOT.INTERVAL)\n        self.timers = {}\n\n    def time_to_resend(self, timer: LastEmailTime, to_admin: Optional[bool] = False) -> bool:\n        '''TODO'''\n        if to_admin:\n",
        "source_code_len": 445,
        "target_code": "class EmailSendingBehaviour:\n    '''\n    When violation is triggered by ProtectionHandler it tries to contact\n    intruder and/or admin via email.\n\n    They get individual email message based on different HTML templates.\n    It will send messages periodically (every `self.interval` time)\n\n    There is `self.timers` memory which stores who and when was recentyl emailed.\n    If intruder does not have email assigned (or no account at all),\n    only admin will be notified (MAILBOT.NOTIFY_ADMIN and MAILBOT.ADMIN_EMAIL must be configured)\n\n    If SMTP configuration (server or credentials) are incorrect,\n    it will be logged each time `trigger_action` is called.\n    '''\n\n    def __init__(self) -> None:\n        self.mailer = Mailer(server=MAILBOT.SMTP_SERVER, port=MAILBOT.SMTP_PORT)\n        self._test_smtp_configuration()\n        self.interval = datetime.timedelta(minutes=MAILBOT.INTERVAL)\n        self.timers = {}  # type: Dict[str, LastEmailTime]\n\n    @override\n    def trigger_action(self, violation_data: Dict[str, Any]) -> None:\n        '''Contains business logic for intruder and admin email notifications.\n        It relies on early returns if any error occures.\n\n        :param violation_data: data received from ProtectionService\n        '''\n        # Expect certain keys beforehand\n        assert {'INTRUDER_USERNAME', 'RESERVATION_OWNER_USERNAME',\n                'RESERVATION_OWNER_EMAIL', 'RESERVATION_END', 'UUID', 'HOSTNAME'\n                }.issubset(violation_data), 'Invalid keys in violation_data'\n\n        if not self._test_smtp_configuration():\n            return\n\n        try:\n            # Fetch intruder email address and extend violation data\n            intruder_email = User.find_by_username(violation_data['INTRUDER_USERNAME']).email\n        except NoResultFound as e:\n            intruder_email = None\n            log.warning(e)\n        finally:\n            violation_data['INTRUDER_EMAIL'] = intruder_email\n\n        if not intruder_email:\n            # Intruder has no account or email assigned, try notify admin then\n            timer = self._get_timer(violation_data['INTRUDER_USERNAME'])\n            if MAILBOT.NOTIFY_ADMIN and self._time_to_resend(timer, to_admin=True):\n                self._email_admin(violation_data, timer)\n            return\n\n        # Intruder has account and email address, try email him and admin then\n        timer = self._get_timer(intruder_email)\n        if MAILBOT.NOTIFY_INTRUDER and self._time_to_resend(timer):\n            self._email_intruder(intruder_email, violation_data, timer)\n        if MAILBOT.NOTIFY_ADMIN and self._time_to_resend(timer, to_admin=True):\n            self._email_admin(violation_data, timer)\n\n    def _time_to_resend(self, timer: LastEmailTime, to_admin: Optional[bool] = False) -> bool:\n        '''Returns whether last email was sent min X time ago.'''\n        if to_admin:\n",
        "target_code_len": 2871,
        "diff_format": "@@ -24,13 +26,63 @@\n class EmailSendingBehaviour:\n-    '''TODO'''\n+    '''\n+    When violation is triggered by ProtectionHandler it tries to contact\n+    intruder and/or admin via email.\n+\n+    They get individual email message based on different HTML templates.\n+    It will send messages periodically (every `self.interval` time)\n+\n+    There is `self.timers` memory which stores who and when was recentyl emailed.\n+    If intruder does not have email assigned (or no account at all),\n+    only admin will be notified (MAILBOT.NOTIFY_ADMIN and MAILBOT.ADMIN_EMAIL must be configured)\n+\n+    If SMTP configuration (server or credentials) are incorrect,\n+    it will be logged each time `trigger_action` is called.\n+    '''\n \n     def __init__(self) -> None:\n-        '''TODO'''\n         self.mailer = Mailer(server=MAILBOT.SMTP_SERVER, port=MAILBOT.SMTP_PORT)\n-        self.test_smtp_configuration()\n+        self._test_smtp_configuration()\n         self.interval = datetime.timedelta(minutes=MAILBOT.INTERVAL)\n-        self.timers = {}\n+        self.timers = {}  # type: Dict[str, LastEmailTime]\n \n-    def time_to_resend(self, timer: LastEmailTime, to_admin: Optional[bool] = False) -> bool:\n-        '''TODO'''\n+    @override\n+    def trigger_action(self, violation_data: Dict[str, Any]) -> None:\n+        '''Contains business logic for intruder and admin email notifications.\n+        It relies on early returns if any error occures.\n+\n+        :param violation_data: data received from ProtectionService\n+        '''\n+        # Expect certain keys beforehand\n+        assert {'INTRUDER_USERNAME', 'RESERVATION_OWNER_USERNAME',\n+                'RESERVATION_OWNER_EMAIL', 'RESERVATION_END', 'UUID', 'HOSTNAME'\n+                }.issubset(violation_data), 'Invalid keys in violation_data'\n+\n+        if not self._test_smtp_configuration():\n+            return\n+\n+        try:\n+            # Fetch intruder email address and extend violation data\n+            intruder_email = User.find_by_username(violation_data['INTRUDER_USERNAME']).email\n+        except NoResultFound as e:\n+            intruder_email = None\n+            log.warning(e)\n+        finally:\n+            violation_data['INTRUDER_EMAIL'] = intruder_email\n+\n+        if not intruder_email:\n+            # Intruder has no account or email assigned, try notify admin then\n+            timer = self._get_timer(violation_data['INTRUDER_USERNAME'])\n+            if MAILBOT.NOTIFY_ADMIN and self._time_to_resend(timer, to_admin=True):\n+                self._email_admin(violation_data, timer)\n+            return\n+\n+        # Intruder has account and email address, try email him and admin then\n+        timer = self._get_timer(intruder_email)\n+        if MAILBOT.NOTIFY_INTRUDER and self._time_to_resend(timer):\n+            self._email_intruder(intruder_email, violation_data, timer)\n+        if MAILBOT.NOTIFY_ADMIN and self._time_to_resend(timer, to_admin=True):\n+            self._email_admin(violation_data, timer)\n+\n+    def _time_to_resend(self, timer: LastEmailTime, to_admin: Optional[bool] = False) -> bool:\n+        '''Returns whether last email was sent min X time ago.'''\n         if to_admin:\n",
        "source_code_with_indent": "<DED><DED>class EmailSendingBehaviour:\n    <IND>'''TODO'''\n\n    def __init__(self) -> None:\n        <IND>'''TODO'''\n        self.mailer = Mailer(server=MAILBOT.SMTP_SERVER, port=MAILBOT.SMTP_PORT)\n        self.test_smtp_configuration()\n        self.interval = datetime.timedelta(minutes=MAILBOT.INTERVAL)\n        self.timers = {}\n\n    <DED>def time_to_resend(self, timer: LastEmailTime, to_admin: Optional[bool] = False) -> bool:\n        <IND>'''TODO'''\n        if to_admin:\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "<DED><DED>class EmailSendingBehaviour:\n    <IND>'''\n    When violation is triggered by ProtectionHandler it tries to contact\n    intruder and/or admin via email.\n\n    They get individual email message based on different HTML templates.\n    It will send messages periodically (every `self.interval` time)\n\n    There is `self.timers` memory which stores who and when was recentyl emailed.\n    If intruder does not have email assigned (or no account at all),\n    only admin will be notified (MAILBOT.NOTIFY_ADMIN and MAILBOT.ADMIN_EMAIL must be configured)\n\n    If SMTP configuration (server or credentials) are incorrect,\n    it will be logged each time `trigger_action` is called.\n    '''\n\n    def __init__(self) -> None:\n        <IND>self.mailer = Mailer(server=MAILBOT.SMTP_SERVER, port=MAILBOT.SMTP_PORT)\n        self._test_smtp_configuration()\n        self.interval = datetime.timedelta(minutes=MAILBOT.INTERVAL)\n        self.timers = {}  # type: Dict[str, LastEmailTime]\n\n    <DED>@override\n    def trigger_action(self, violation_data: Dict[str, Any]) -> None:\n        <IND>'''Contains business logic for intruder and admin email notifications.\n        It relies on early returns if any error occures.\n\n        :param violation_data: data received from ProtectionService\n        '''\n        # Expect certain keys beforehand\n        assert {'INTRUDER_USERNAME', 'RESERVATION_OWNER_USERNAME',\n                'RESERVATION_OWNER_EMAIL', 'RESERVATION_END', 'UUID', 'HOSTNAME'\n                }.issubset(violation_data), 'Invalid keys in violation_data'\n\n        if not self._test_smtp_configuration():\n            <IND>return\n\n        <DED>try:\n            # Fetch intruder email address and extend violation data\n            <IND>intruder_email = User.find_by_username(violation_data['INTRUDER_USERNAME']).email\n        <DED>except NoResultFound as e:\n            <IND>intruder_email = None\n            log.warning(e)\n        <DED>finally:\n            <IND>violation_data['INTRUDER_EMAIL'] = intruder_email\n\n        <DED>if not intruder_email:\n            # Intruder has no account or email assigned, try notify admin then\n            <IND>timer = self._get_timer(violation_data['INTRUDER_USERNAME'])\n            if MAILBOT.NOTIFY_ADMIN and self._time_to_resend(timer, to_admin=True):\n                <IND>self._email_admin(violation_data, timer)\n            <DED>return\n\n        # Intruder has account and email address, try email him and admin then\n        <DED>timer = self._get_timer(intruder_email)\n        if MAILBOT.NOTIFY_INTRUDER and self._time_to_resend(timer):\n            <IND>self._email_intruder(intruder_email, violation_data, timer)\n        <DED>if MAILBOT.NOTIFY_ADMIN and self._time_to_resend(timer, to_admin=True):\n            <IND>self._email_admin(violation_data, timer)\n\n    <DED><DED>def _time_to_resend(self, timer: LastEmailTime, to_admin: Optional[bool] = False) -> bool:\n        <IND>'''Returns whether last email was sent min X time ago.'''\n        if to_admin:\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n    def get_timer(self, keyname: str) -> Dict[str, datetime.datetime]:\n        '''TODO'''\n        try:\n",
        "source_code_len": 104,
        "target_code": "\n    def _get_timer(self, keyname: str) -> LastEmailTime:\n        '''Safe dict fetching. It will create missing key with default value.'''\n        try:\n",
        "target_code_len": 152,
        "diff_format": "@@ -41,4 +93,4 @@\n \n-    def get_timer(self, keyname: str) -> Dict[str, datetime.datetime]:\n-        '''TODO'''\n+    def _get_timer(self, keyname: str) -> LastEmailTime:\n+        '''Safe dict fetching. It will create missing key with default value.'''\n         try:\n",
        "source_code_with_indent": "\n    <DED>def get_timer(self, keyname: str) -> Dict[str, datetime.datetime]:\n        <IND>'''TODO'''\n        try:\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n    <DED>def _get_timer(self, keyname: str) -> LastEmailTime:\n        <IND>'''Safe dict fetching. It will create missing key with default value.'''\n        try:\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n    def test_smtp_configuration(self) -> bool:\n        try:\n",
        "source_code_len": 61,
        "target_code": "\n    def _test_smtp_configuration(self) -> bool:\n        '''Does very basic checks whether config variables are not None (which is the default).\n        Then, it tries to establish an SMTP connection.\n        It logs error reason and appropriate hint.\n        '''\n        try:\n",
        "target_code_len": 277,
        "diff_format": "@@ -51,3 +103,7 @@\n \n-    def test_smtp_configuration(self) -> bool:\n+    def _test_smtp_configuration(self) -> bool:\n+        '''Does very basic checks whether config variables are not None (which is the default).\n+        Then, it tries to establish an SMTP connection.\n+        It logs error reason and appropriate hint.\n+        '''\n         try:\n",
        "source_code_with_indent": "\n    <DED><DED>def test_smtp_configuration(self) -> bool:\n        <IND>try:\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n    <DED><DED>def _test_smtp_configuration(self) -> bool:\n        <IND>'''Does very basic checks whether config variables are not None (which is the default).\n        Then, it tries to establish an SMTP connection.\n        It logs error reason and appropriate hint.\n        '''\n        try:\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": true,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n    def email_intruder(self, email: str, violation_data: Dict, timer: LastEmailTime) -> None:\n        email_body = MessageBodyTemplater(template=MAILBOT.INTRUDER_BODY_TEMPLATE).fill_in(data=violation_data)\n        email = Message(author=MAILBOT.SMTP_LOGIN, to=email, subject=MAILBOT.INTRUDER_SUBJECT, body=email_body)\n        self.mailer.send(email)\n",
        "source_code_len": 351,
        "target_code": "\n    def _email_intruder(self, email_address: str, violation_data: Dict, timer: LastEmailTime) -> None:\n        '''Prepare message, send and update timer.'''\n        email_body = MessageBodyTemplater(template=MAILBOT.INTRUDER_BODY_TEMPLATE).fill_in(data=violation_data)\n        email = Message(author=MAILBOT.SMTP_LOGIN, to=email_address, subject=MAILBOT.INTRUDER_SUBJECT, body=email_body)\n        self.mailer.send(email)\n",
        "target_code_len": 422,
        "diff_format": "@@ -68,5 +124,6 @@\n \n-    def email_intruder(self, email: str, violation_data: Dict, timer: LastEmailTime) -> None:\n+    def _email_intruder(self, email_address: str, violation_data: Dict, timer: LastEmailTime) -> None:\n+        '''Prepare message, send and update timer.'''\n         email_body = MessageBodyTemplater(template=MAILBOT.INTRUDER_BODY_TEMPLATE).fill_in(data=violation_data)\n-        email = Message(author=MAILBOT.SMTP_LOGIN, to=email, subject=MAILBOT.INTRUDER_SUBJECT, body=email_body)\n+        email = Message(author=MAILBOT.SMTP_LOGIN, to=email_address, subject=MAILBOT.INTRUDER_SUBJECT, body=email_body)\n         self.mailer.send(email)\n",
        "source_code_with_indent": "\n    <DED><DED>def email_intruder(self, email: str, violation_data: Dict, timer: LastEmailTime) -> None:\n        <IND>email_body = MessageBodyTemplater(template=MAILBOT.INTRUDER_BODY_TEMPLATE).fill_in(data=violation_data)\n        email = Message(author=MAILBOT.SMTP_LOGIN, to=email, subject=MAILBOT.INTRUDER_SUBJECT, body=email_body)\n        self.mailer.send(email)\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n    <DED><DED>def _email_intruder(self, email_address: str, violation_data: Dict, timer: LastEmailTime) -> None:\n        <IND>'''Prepare message, send and update timer.'''\n        email_body = MessageBodyTemplater(template=MAILBOT.INTRUDER_BODY_TEMPLATE).fill_in(data=violation_data)\n        email = Message(author=MAILBOT.SMTP_LOGIN, to=email_address, subject=MAILBOT.INTRUDER_SUBJECT, body=email_body)\n        self.mailer.send(email)\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n    def email_admin(self, violation_data: Dict, timer: LastEmailTime) -> None:\n        email_body = MessageBodyTemplater(template=MAILBOT.ADMIN_BODY_TEMPLATE).fill_in(data=violation_data)\n",
        "source_code_len": 189,
        "target_code": "\n    def _email_admin(self, violation_data: Dict, timer: LastEmailTime) -> None:\n        '''Prepare message, send and update timer.'''\n        email_body = MessageBodyTemplater(template=MAILBOT.ADMIN_BODY_TEMPLATE).fill_in(data=violation_data)\n",
        "target_code_len": 244,
        "diff_format": "@@ -75,3 +132,4 @@\n \n-    def email_admin(self, violation_data: Dict, timer: LastEmailTime) -> None:\n+    def _email_admin(self, violation_data: Dict, timer: LastEmailTime) -> None:\n+        '''Prepare message, send and update timer.'''\n         email_body = MessageBodyTemplater(template=MAILBOT.ADMIN_BODY_TEMPLATE).fill_in(data=violation_data)\n",
        "source_code_with_indent": "\n    <DED>def email_admin(self, violation_data: Dict, timer: LastEmailTime) -> None:\n        <IND>email_body = MessageBodyTemplater(template=MAILBOT.ADMIN_BODY_TEMPLATE).fill_in(data=violation_data)\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n    <DED>def _email_admin(self, violation_data: Dict, timer: LastEmailTime) -> None:\n        <IND>'''Prepare message, send and update timer.'''\n        email_body = MessageBodyTemplater(template=MAILBOT.ADMIN_BODY_TEMPLATE).fill_in(data=violation_data)\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": true,
        "has_suppression": false,
        "source_code": "        log.info('Email to admin has been sent: {}'.format(email))\n\n    @override\n    def trigger_action(self, violation_data: Dict[str, Any]) -> None:\n        '''TODO'''\n        # Expect proper keys beforehand\n        assert {\n            'INTRUDER_USERNAME',\n            'RESERVATION_OWNER_USERNAME',\n            'RESERVATION_OWNER_EMAIL',\n            'RESERVATION_END',\n            'UUID',\n            'HOSTNAME'}.issubset(violation_data), 'Invalid keys in violation_data'\n\n        if not self.test_smtp_configuration():\n            return\n\n        try:\n            # Fetch email address and extend violation data\n            intruder_email = User.find_by_username(violation_data['INTRUDER_USERNAME']).email\n        except NoResultFound as e:\n            intruder_email = None\n            log.warning(e)\n        finally:\n            violation_data['INTRUDER_EMAIL'] = intruder_email\n\n        if not intruder_email:\n            # At least try notify admin\n            timer = self.get_timer(violation_data['INTRUDER_USERNAME'])\n            if MAILBOT.NOTIFY_ADMIN and self.time_to_resend(timer, to_admin=True):\n                self.email_admin(violation_data, timer)\n            return\n\n        # Try email both\n        timer = self.get_timer(intruder_email)\n        if MAILBOT.NOTIFY_INTRUDER and self.time_to_resend(timer):\n            self.email_intruder(intruder_email, violation_data, timer)\n        if MAILBOT.NOTIFY_ADMIN and self.time_to_resend(timer, to_admin=True):\n            self.email_admin(violation_data, timer)\n",
        "source_code_len": 1530,
        "target_code": "        log.info('Email to admin has been sent: {}'.format(email))\n",
        "target_code_len": 67,
        "diff_format": "@@ -82,39 +140,1 @@\n         log.info('Email to admin has been sent: {}'.format(email))\n-\n-    @override\n-    def trigger_action(self, violation_data: Dict[str, Any]) -> None:\n-        '''TODO'''\n-        # Expect proper keys beforehand\n-        assert {\n-            'INTRUDER_USERNAME',\n-            'RESERVATION_OWNER_USERNAME',\n-            'RESERVATION_OWNER_EMAIL',\n-            'RESERVATION_END',\n-            'UUID',\n-            'HOSTNAME'}.issubset(violation_data), 'Invalid keys in violation_data'\n-\n-        if not self.test_smtp_configuration():\n-            return\n-\n-        try:\n-            # Fetch email address and extend violation data\n-            intruder_email = User.find_by_username(violation_data['INTRUDER_USERNAME']).email\n-        except NoResultFound as e:\n-            intruder_email = None\n-            log.warning(e)\n-        finally:\n-            violation_data['INTRUDER_EMAIL'] = intruder_email\n-\n-        if not intruder_email:\n-            # At least try notify admin\n-            timer = self.get_timer(violation_data['INTRUDER_USERNAME'])\n-            if MAILBOT.NOTIFY_ADMIN and self.time_to_resend(timer, to_admin=True):\n-                self.email_admin(violation_data, timer)\n-            return\n-\n-        # Try email both\n-        timer = self.get_timer(intruder_email)\n-        if MAILBOT.NOTIFY_INTRUDER and self.time_to_resend(timer):\n-            self.email_intruder(intruder_email, violation_data, timer)\n-        if MAILBOT.NOTIFY_ADMIN and self.time_to_resend(timer, to_admin=True):\n-            self.email_admin(violation_data, timer)\n",
        "source_code_with_indent": "        log.info('Email to admin has been sent: {}'.format(email))\n\n    <DED>@override\n    def trigger_action(self, violation_data: Dict[str, Any]) -> None:\n        <IND>'''TODO'''\n        # Expect proper keys beforehand\n        assert {\n            'INTRUDER_USERNAME',\n            'RESERVATION_OWNER_USERNAME',\n            'RESERVATION_OWNER_EMAIL',\n            'RESERVATION_END',\n            'UUID',\n            'HOSTNAME'}.issubset(violation_data), 'Invalid keys in violation_data'\n\n        if not self.test_smtp_configuration():\n            <IND>return\n\n        <DED>try:\n            # Fetch email address and extend violation data\n            <IND>intruder_email = User.find_by_username(violation_data['INTRUDER_USERNAME']).email\n        <DED>except NoResultFound as e:\n            <IND>intruder_email = None\n            log.warning(e)\n        <DED>finally:\n            <IND>violation_data['INTRUDER_EMAIL'] = intruder_email\n\n        <DED>if not intruder_email:\n            # At least try notify admin\n            <IND>timer = self.get_timer(violation_data['INTRUDER_USERNAME'])\n            if MAILBOT.NOTIFY_ADMIN and self.time_to_resend(timer, to_admin=True):\n                <IND>self.email_admin(violation_data, timer)\n            <DED>return\n\n        # Try email both\n        <DED>timer = self.get_timer(intruder_email)\n        if MAILBOT.NOTIFY_INTRUDER and self.time_to_resend(timer):\n            <IND>self.email_intruder(intruder_email, violation_data, timer)\n        <DED>if MAILBOT.NOTIFY_ADMIN and self.time_to_resend(timer, to_admin=True):\n            <IND>self.email_admin(violation_data, timer)\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "        log.info('Email to admin has been sent: {}'.format(email))\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "roscisz/TensorHive",
    "commit": "c5ed23f82597837b0e216b50225fb7d7cd79c15c",
    "filename": "tensorhive/core/violation_handlers/EmailSendingBehaviour.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/roscisz-TensorHive/tensorhive/core/violation_handlers/EmailSendingBehaviour.py",
    "file_hunks_size": 7,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": true,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "tensorhive/core/violation_handlers/EmailSendingBehaviour.py:111:60 Incompatible parameter type [6]: Expected `LastEmailTime` for 1st positional only parameter to call `EmailSendingBehaviour.time_to_resend` but got `Dict[str, datetime.datetime]`.",
    "message": " Expected `LastEmailTime` for 1st positional only parameter to call `EmailSendingBehaviour.time_to_resend` but got `Dict[str, datetime.datetime]`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 111,
    "warning_line": "            if MAILBOT.NOTIFY_ADMIN and self.time_to_resend(timer, to_admin=True):",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": true,
        "has_suppression": false,
        "source_code": "        log.info('Email to admin has been sent: {}'.format(email))\n\n    @override\n    def trigger_action(self, violation_data: Dict[str, Any]) -> None:\n        '''TODO'''\n        # Expect proper keys beforehand\n        assert {\n            'INTRUDER_USERNAME',\n            'RESERVATION_OWNER_USERNAME',\n            'RESERVATION_OWNER_EMAIL',\n            'RESERVATION_END',\n            'UUID',\n            'HOSTNAME'}.issubset(violation_data), 'Invalid keys in violation_data'\n\n        if not self.test_smtp_configuration():\n            return\n\n        try:\n            # Fetch email address and extend violation data\n            intruder_email = User.find_by_username(violation_data['INTRUDER_USERNAME']).email\n        except NoResultFound as e:\n            intruder_email = None\n            log.warning(e)\n        finally:\n            violation_data['INTRUDER_EMAIL'] = intruder_email\n\n        if not intruder_email:\n            # At least try notify admin\n            timer = self.get_timer(violation_data['INTRUDER_USERNAME'])\n            if MAILBOT.NOTIFY_ADMIN and self.time_to_resend(timer, to_admin=True):\n                self.email_admin(violation_data, timer)\n            return\n\n        # Try email both\n        timer = self.get_timer(intruder_email)\n        if MAILBOT.NOTIFY_INTRUDER and self.time_to_resend(timer):\n            self.email_intruder(intruder_email, violation_data, timer)\n        if MAILBOT.NOTIFY_ADMIN and self.time_to_resend(timer, to_admin=True):\n            self.email_admin(violation_data, timer)\n",
        "source_code_len": 1530,
        "target_code": "        log.info('Email to admin has been sent: {}'.format(email))\n",
        "target_code_len": 67,
        "diff_format": "@@ -82,39 +140,1 @@\n         log.info('Email to admin has been sent: {}'.format(email))\n-\n-    @override\n-    def trigger_action(self, violation_data: Dict[str, Any]) -> None:\n-        '''TODO'''\n-        # Expect proper keys beforehand\n-        assert {\n-            'INTRUDER_USERNAME',\n-            'RESERVATION_OWNER_USERNAME',\n-            'RESERVATION_OWNER_EMAIL',\n-            'RESERVATION_END',\n-            'UUID',\n-            'HOSTNAME'}.issubset(violation_data), 'Invalid keys in violation_data'\n-\n-        if not self.test_smtp_configuration():\n-            return\n-\n-        try:\n-            # Fetch email address and extend violation data\n-            intruder_email = User.find_by_username(violation_data['INTRUDER_USERNAME']).email\n-        except NoResultFound as e:\n-            intruder_email = None\n-            log.warning(e)\n-        finally:\n-            violation_data['INTRUDER_EMAIL'] = intruder_email\n-\n-        if not intruder_email:\n-            # At least try notify admin\n-            timer = self.get_timer(violation_data['INTRUDER_USERNAME'])\n-            if MAILBOT.NOTIFY_ADMIN and self.time_to_resend(timer, to_admin=True):\n-                self.email_admin(violation_data, timer)\n-            return\n-\n-        # Try email both\n-        timer = self.get_timer(intruder_email)\n-        if MAILBOT.NOTIFY_INTRUDER and self.time_to_resend(timer):\n-            self.email_intruder(intruder_email, violation_data, timer)\n-        if MAILBOT.NOTIFY_ADMIN and self.time_to_resend(timer, to_admin=True):\n-            self.email_admin(violation_data, timer)\n",
        "source_code_with_indent": "        log.info('Email to admin has been sent: {}'.format(email))\n\n    <DED>@override\n    def trigger_action(self, violation_data: Dict[str, Any]) -> None:\n        <IND>'''TODO'''\n        # Expect proper keys beforehand\n        assert {\n            'INTRUDER_USERNAME',\n            'RESERVATION_OWNER_USERNAME',\n            'RESERVATION_OWNER_EMAIL',\n            'RESERVATION_END',\n            'UUID',\n            'HOSTNAME'}.issubset(violation_data), 'Invalid keys in violation_data'\n\n        if not self.test_smtp_configuration():\n            <IND>return\n\n        <DED>try:\n            # Fetch email address and extend violation data\n            <IND>intruder_email = User.find_by_username(violation_data['INTRUDER_USERNAME']).email\n        <DED>except NoResultFound as e:\n            <IND>intruder_email = None\n            log.warning(e)\n        <DED>finally:\n            <IND>violation_data['INTRUDER_EMAIL'] = intruder_email\n\n        <DED>if not intruder_email:\n            # At least try notify admin\n            <IND>timer = self.get_timer(violation_data['INTRUDER_USERNAME'])\n            if MAILBOT.NOTIFY_ADMIN and self.time_to_resend(timer, to_admin=True):\n                <IND>self.email_admin(violation_data, timer)\n            <DED>return\n\n        # Try email both\n        <DED>timer = self.get_timer(intruder_email)\n        if MAILBOT.NOTIFY_INTRUDER and self.time_to_resend(timer):\n            <IND>self.email_intruder(intruder_email, violation_data, timer)\n        <DED>if MAILBOT.NOTIFY_ADMIN and self.time_to_resend(timer, to_admin=True):\n            <IND>self.email_admin(violation_data, timer)\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "        log.info('Email to admin has been sent: {}'.format(email))\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "roscisz/TensorHive",
    "commit": "c5ed23f82597837b0e216b50225fb7d7cd79c15c",
    "filename": "tensorhive/core/violation_handlers/EmailSendingBehaviour.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/roscisz-TensorHive/tensorhive/core/violation_handlers/EmailSendingBehaviour.py",
    "file_hunks_size": 7,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": true,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "tensorhive/core/violation_handlers/EmailSendingBehaviour.py:112:49 Incompatible parameter type [6]: Expected `LastEmailTime` for 2nd positional only parameter to call `EmailSendingBehaviour.email_admin` but got `Dict[str, datetime.datetime]`.",
    "message": " Expected `LastEmailTime` for 2nd positional only parameter to call `EmailSendingBehaviour.email_admin` but got `Dict[str, datetime.datetime]`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 112,
    "warning_line": "                self.email_admin(violation_data, timer)",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": true,
        "has_suppression": false,
        "source_code": "        log.info('Email to admin has been sent: {}'.format(email))\n\n    @override\n    def trigger_action(self, violation_data: Dict[str, Any]) -> None:\n        '''TODO'''\n        # Expect proper keys beforehand\n        assert {\n            'INTRUDER_USERNAME',\n            'RESERVATION_OWNER_USERNAME',\n            'RESERVATION_OWNER_EMAIL',\n            'RESERVATION_END',\n            'UUID',\n            'HOSTNAME'}.issubset(violation_data), 'Invalid keys in violation_data'\n\n        if not self.test_smtp_configuration():\n            return\n\n        try:\n            # Fetch email address and extend violation data\n            intruder_email = User.find_by_username(violation_data['INTRUDER_USERNAME']).email\n        except NoResultFound as e:\n            intruder_email = None\n            log.warning(e)\n        finally:\n            violation_data['INTRUDER_EMAIL'] = intruder_email\n\n        if not intruder_email:\n            # At least try notify admin\n            timer = self.get_timer(violation_data['INTRUDER_USERNAME'])\n            if MAILBOT.NOTIFY_ADMIN and self.time_to_resend(timer, to_admin=True):\n                self.email_admin(violation_data, timer)\n            return\n\n        # Try email both\n        timer = self.get_timer(intruder_email)\n        if MAILBOT.NOTIFY_INTRUDER and self.time_to_resend(timer):\n            self.email_intruder(intruder_email, violation_data, timer)\n        if MAILBOT.NOTIFY_ADMIN and self.time_to_resend(timer, to_admin=True):\n            self.email_admin(violation_data, timer)\n",
        "source_code_len": 1530,
        "target_code": "        log.info('Email to admin has been sent: {}'.format(email))\n",
        "target_code_len": 67,
        "diff_format": "@@ -82,39 +140,1 @@\n         log.info('Email to admin has been sent: {}'.format(email))\n-\n-    @override\n-    def trigger_action(self, violation_data: Dict[str, Any]) -> None:\n-        '''TODO'''\n-        # Expect proper keys beforehand\n-        assert {\n-            'INTRUDER_USERNAME',\n-            'RESERVATION_OWNER_USERNAME',\n-            'RESERVATION_OWNER_EMAIL',\n-            'RESERVATION_END',\n-            'UUID',\n-            'HOSTNAME'}.issubset(violation_data), 'Invalid keys in violation_data'\n-\n-        if not self.test_smtp_configuration():\n-            return\n-\n-        try:\n-            # Fetch email address and extend violation data\n-            intruder_email = User.find_by_username(violation_data['INTRUDER_USERNAME']).email\n-        except NoResultFound as e:\n-            intruder_email = None\n-            log.warning(e)\n-        finally:\n-            violation_data['INTRUDER_EMAIL'] = intruder_email\n-\n-        if not intruder_email:\n-            # At least try notify admin\n-            timer = self.get_timer(violation_data['INTRUDER_USERNAME'])\n-            if MAILBOT.NOTIFY_ADMIN and self.time_to_resend(timer, to_admin=True):\n-                self.email_admin(violation_data, timer)\n-            return\n-\n-        # Try email both\n-        timer = self.get_timer(intruder_email)\n-        if MAILBOT.NOTIFY_INTRUDER and self.time_to_resend(timer):\n-            self.email_intruder(intruder_email, violation_data, timer)\n-        if MAILBOT.NOTIFY_ADMIN and self.time_to_resend(timer, to_admin=True):\n-            self.email_admin(violation_data, timer)\n",
        "source_code_with_indent": "        log.info('Email to admin has been sent: {}'.format(email))\n\n    <DED>@override\n    def trigger_action(self, violation_data: Dict[str, Any]) -> None:\n        <IND>'''TODO'''\n        # Expect proper keys beforehand\n        assert {\n            'INTRUDER_USERNAME',\n            'RESERVATION_OWNER_USERNAME',\n            'RESERVATION_OWNER_EMAIL',\n            'RESERVATION_END',\n            'UUID',\n            'HOSTNAME'}.issubset(violation_data), 'Invalid keys in violation_data'\n\n        if not self.test_smtp_configuration():\n            <IND>return\n\n        <DED>try:\n            # Fetch email address and extend violation data\n            <IND>intruder_email = User.find_by_username(violation_data['INTRUDER_USERNAME']).email\n        <DED>except NoResultFound as e:\n            <IND>intruder_email = None\n            log.warning(e)\n        <DED>finally:\n            <IND>violation_data['INTRUDER_EMAIL'] = intruder_email\n\n        <DED>if not intruder_email:\n            # At least try notify admin\n            <IND>timer = self.get_timer(violation_data['INTRUDER_USERNAME'])\n            if MAILBOT.NOTIFY_ADMIN and self.time_to_resend(timer, to_admin=True):\n                <IND>self.email_admin(violation_data, timer)\n            <DED>return\n\n        # Try email both\n        <DED>timer = self.get_timer(intruder_email)\n        if MAILBOT.NOTIFY_INTRUDER and self.time_to_resend(timer):\n            <IND>self.email_intruder(intruder_email, violation_data, timer)\n        <DED>if MAILBOT.NOTIFY_ADMIN and self.time_to_resend(timer, to_admin=True):\n            <IND>self.email_admin(violation_data, timer)\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "        log.info('Email to admin has been sent: {}'.format(email))\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "roscisz/TensorHive",
    "commit": "c5ed23f82597837b0e216b50225fb7d7cd79c15c",
    "filename": "tensorhive/core/violation_handlers/EmailSendingBehaviour.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/roscisz-TensorHive/tensorhive/core/violation_handlers/EmailSendingBehaviour.py",
    "file_hunks_size": 7,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": true,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "tensorhive/core/violation_handlers/EmailSendingBehaviour.py:117:59 Incompatible parameter type [6]: Expected `LastEmailTime` for 1st positional only parameter to call `EmailSendingBehaviour.time_to_resend` but got `Dict[str, datetime.datetime]`.",
    "message": " Expected `LastEmailTime` for 1st positional only parameter to call `EmailSendingBehaviour.time_to_resend` but got `Dict[str, datetime.datetime]`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 117,
    "warning_line": "        if MAILBOT.NOTIFY_INTRUDER and self.time_to_resend(timer):",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": true,
        "has_suppression": false,
        "source_code": "        log.info('Email to admin has been sent: {}'.format(email))\n\n    @override\n    def trigger_action(self, violation_data: Dict[str, Any]) -> None:\n        '''TODO'''\n        # Expect proper keys beforehand\n        assert {\n            'INTRUDER_USERNAME',\n            'RESERVATION_OWNER_USERNAME',\n            'RESERVATION_OWNER_EMAIL',\n            'RESERVATION_END',\n            'UUID',\n            'HOSTNAME'}.issubset(violation_data), 'Invalid keys in violation_data'\n\n        if not self.test_smtp_configuration():\n            return\n\n        try:\n            # Fetch email address and extend violation data\n            intruder_email = User.find_by_username(violation_data['INTRUDER_USERNAME']).email\n        except NoResultFound as e:\n            intruder_email = None\n            log.warning(e)\n        finally:\n            violation_data['INTRUDER_EMAIL'] = intruder_email\n\n        if not intruder_email:\n            # At least try notify admin\n            timer = self.get_timer(violation_data['INTRUDER_USERNAME'])\n            if MAILBOT.NOTIFY_ADMIN and self.time_to_resend(timer, to_admin=True):\n                self.email_admin(violation_data, timer)\n            return\n\n        # Try email both\n        timer = self.get_timer(intruder_email)\n        if MAILBOT.NOTIFY_INTRUDER and self.time_to_resend(timer):\n            self.email_intruder(intruder_email, violation_data, timer)\n        if MAILBOT.NOTIFY_ADMIN and self.time_to_resend(timer, to_admin=True):\n            self.email_admin(violation_data, timer)\n",
        "source_code_len": 1530,
        "target_code": "        log.info('Email to admin has been sent: {}'.format(email))\n",
        "target_code_len": 67,
        "diff_format": "@@ -82,39 +140,1 @@\n         log.info('Email to admin has been sent: {}'.format(email))\n-\n-    @override\n-    def trigger_action(self, violation_data: Dict[str, Any]) -> None:\n-        '''TODO'''\n-        # Expect proper keys beforehand\n-        assert {\n-            'INTRUDER_USERNAME',\n-            'RESERVATION_OWNER_USERNAME',\n-            'RESERVATION_OWNER_EMAIL',\n-            'RESERVATION_END',\n-            'UUID',\n-            'HOSTNAME'}.issubset(violation_data), 'Invalid keys in violation_data'\n-\n-        if not self.test_smtp_configuration():\n-            return\n-\n-        try:\n-            # Fetch email address and extend violation data\n-            intruder_email = User.find_by_username(violation_data['INTRUDER_USERNAME']).email\n-        except NoResultFound as e:\n-            intruder_email = None\n-            log.warning(e)\n-        finally:\n-            violation_data['INTRUDER_EMAIL'] = intruder_email\n-\n-        if not intruder_email:\n-            # At least try notify admin\n-            timer = self.get_timer(violation_data['INTRUDER_USERNAME'])\n-            if MAILBOT.NOTIFY_ADMIN and self.time_to_resend(timer, to_admin=True):\n-                self.email_admin(violation_data, timer)\n-            return\n-\n-        # Try email both\n-        timer = self.get_timer(intruder_email)\n-        if MAILBOT.NOTIFY_INTRUDER and self.time_to_resend(timer):\n-            self.email_intruder(intruder_email, violation_data, timer)\n-        if MAILBOT.NOTIFY_ADMIN and self.time_to_resend(timer, to_admin=True):\n-            self.email_admin(violation_data, timer)\n",
        "source_code_with_indent": "        log.info('Email to admin has been sent: {}'.format(email))\n\n    <DED>@override\n    def trigger_action(self, violation_data: Dict[str, Any]) -> None:\n        <IND>'''TODO'''\n        # Expect proper keys beforehand\n        assert {\n            'INTRUDER_USERNAME',\n            'RESERVATION_OWNER_USERNAME',\n            'RESERVATION_OWNER_EMAIL',\n            'RESERVATION_END',\n            'UUID',\n            'HOSTNAME'}.issubset(violation_data), 'Invalid keys in violation_data'\n\n        if not self.test_smtp_configuration():\n            <IND>return\n\n        <DED>try:\n            # Fetch email address and extend violation data\n            <IND>intruder_email = User.find_by_username(violation_data['INTRUDER_USERNAME']).email\n        <DED>except NoResultFound as e:\n            <IND>intruder_email = None\n            log.warning(e)\n        <DED>finally:\n            <IND>violation_data['INTRUDER_EMAIL'] = intruder_email\n\n        <DED>if not intruder_email:\n            # At least try notify admin\n            <IND>timer = self.get_timer(violation_data['INTRUDER_USERNAME'])\n            if MAILBOT.NOTIFY_ADMIN and self.time_to_resend(timer, to_admin=True):\n                <IND>self.email_admin(violation_data, timer)\n            <DED>return\n\n        # Try email both\n        <DED>timer = self.get_timer(intruder_email)\n        if MAILBOT.NOTIFY_INTRUDER and self.time_to_resend(timer):\n            <IND>self.email_intruder(intruder_email, violation_data, timer)\n        <DED>if MAILBOT.NOTIFY_ADMIN and self.time_to_resend(timer, to_admin=True):\n            <IND>self.email_admin(violation_data, timer)\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "        log.info('Email to admin has been sent: {}'.format(email))\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "roscisz/TensorHive",
    "commit": "c5ed23f82597837b0e216b50225fb7d7cd79c15c",
    "filename": "tensorhive/core/violation_handlers/EmailSendingBehaviour.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/roscisz-TensorHive/tensorhive/core/violation_handlers/EmailSendingBehaviour.py",
    "file_hunks_size": 7,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": true,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "tensorhive/core/violation_handlers/EmailSendingBehaviour.py:118:64 Incompatible parameter type [6]: Expected `LastEmailTime` for 3rd positional only parameter to call `EmailSendingBehaviour.email_intruder` but got `Dict[str, datetime.datetime]`.",
    "message": " Expected `LastEmailTime` for 3rd positional only parameter to call `EmailSendingBehaviour.email_intruder` but got `Dict[str, datetime.datetime]`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 118,
    "warning_line": "            self.email_intruder(intruder_email, violation_data, timer)",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": true,
        "has_suppression": false,
        "source_code": "        log.info('Email to admin has been sent: {}'.format(email))\n\n    @override\n    def trigger_action(self, violation_data: Dict[str, Any]) -> None:\n        '''TODO'''\n        # Expect proper keys beforehand\n        assert {\n            'INTRUDER_USERNAME',\n            'RESERVATION_OWNER_USERNAME',\n            'RESERVATION_OWNER_EMAIL',\n            'RESERVATION_END',\n            'UUID',\n            'HOSTNAME'}.issubset(violation_data), 'Invalid keys in violation_data'\n\n        if not self.test_smtp_configuration():\n            return\n\n        try:\n            # Fetch email address and extend violation data\n            intruder_email = User.find_by_username(violation_data['INTRUDER_USERNAME']).email\n        except NoResultFound as e:\n            intruder_email = None\n            log.warning(e)\n        finally:\n            violation_data['INTRUDER_EMAIL'] = intruder_email\n\n        if not intruder_email:\n            # At least try notify admin\n            timer = self.get_timer(violation_data['INTRUDER_USERNAME'])\n            if MAILBOT.NOTIFY_ADMIN and self.time_to_resend(timer, to_admin=True):\n                self.email_admin(violation_data, timer)\n            return\n\n        # Try email both\n        timer = self.get_timer(intruder_email)\n        if MAILBOT.NOTIFY_INTRUDER and self.time_to_resend(timer):\n            self.email_intruder(intruder_email, violation_data, timer)\n        if MAILBOT.NOTIFY_ADMIN and self.time_to_resend(timer, to_admin=True):\n            self.email_admin(violation_data, timer)\n",
        "source_code_len": 1530,
        "target_code": "        log.info('Email to admin has been sent: {}'.format(email))\n",
        "target_code_len": 67,
        "diff_format": "@@ -82,39 +140,1 @@\n         log.info('Email to admin has been sent: {}'.format(email))\n-\n-    @override\n-    def trigger_action(self, violation_data: Dict[str, Any]) -> None:\n-        '''TODO'''\n-        # Expect proper keys beforehand\n-        assert {\n-            'INTRUDER_USERNAME',\n-            'RESERVATION_OWNER_USERNAME',\n-            'RESERVATION_OWNER_EMAIL',\n-            'RESERVATION_END',\n-            'UUID',\n-            'HOSTNAME'}.issubset(violation_data), 'Invalid keys in violation_data'\n-\n-        if not self.test_smtp_configuration():\n-            return\n-\n-        try:\n-            # Fetch email address and extend violation data\n-            intruder_email = User.find_by_username(violation_data['INTRUDER_USERNAME']).email\n-        except NoResultFound as e:\n-            intruder_email = None\n-            log.warning(e)\n-        finally:\n-            violation_data['INTRUDER_EMAIL'] = intruder_email\n-\n-        if not intruder_email:\n-            # At least try notify admin\n-            timer = self.get_timer(violation_data['INTRUDER_USERNAME'])\n-            if MAILBOT.NOTIFY_ADMIN and self.time_to_resend(timer, to_admin=True):\n-                self.email_admin(violation_data, timer)\n-            return\n-\n-        # Try email both\n-        timer = self.get_timer(intruder_email)\n-        if MAILBOT.NOTIFY_INTRUDER and self.time_to_resend(timer):\n-            self.email_intruder(intruder_email, violation_data, timer)\n-        if MAILBOT.NOTIFY_ADMIN and self.time_to_resend(timer, to_admin=True):\n-            self.email_admin(violation_data, timer)\n",
        "source_code_with_indent": "        log.info('Email to admin has been sent: {}'.format(email))\n\n    <DED>@override\n    def trigger_action(self, violation_data: Dict[str, Any]) -> None:\n        <IND>'''TODO'''\n        # Expect proper keys beforehand\n        assert {\n            'INTRUDER_USERNAME',\n            'RESERVATION_OWNER_USERNAME',\n            'RESERVATION_OWNER_EMAIL',\n            'RESERVATION_END',\n            'UUID',\n            'HOSTNAME'}.issubset(violation_data), 'Invalid keys in violation_data'\n\n        if not self.test_smtp_configuration():\n            <IND>return\n\n        <DED>try:\n            # Fetch email address and extend violation data\n            <IND>intruder_email = User.find_by_username(violation_data['INTRUDER_USERNAME']).email\n        <DED>except NoResultFound as e:\n            <IND>intruder_email = None\n            log.warning(e)\n        <DED>finally:\n            <IND>violation_data['INTRUDER_EMAIL'] = intruder_email\n\n        <DED>if not intruder_email:\n            # At least try notify admin\n            <IND>timer = self.get_timer(violation_data['INTRUDER_USERNAME'])\n            if MAILBOT.NOTIFY_ADMIN and self.time_to_resend(timer, to_admin=True):\n                <IND>self.email_admin(violation_data, timer)\n            <DED>return\n\n        # Try email both\n        <DED>timer = self.get_timer(intruder_email)\n        if MAILBOT.NOTIFY_INTRUDER and self.time_to_resend(timer):\n            <IND>self.email_intruder(intruder_email, violation_data, timer)\n        <DED>if MAILBOT.NOTIFY_ADMIN and self.time_to_resend(timer, to_admin=True):\n            <IND>self.email_admin(violation_data, timer)\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "        log.info('Email to admin has been sent: {}'.format(email))\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "roscisz/TensorHive",
    "commit": "c5ed23f82597837b0e216b50225fb7d7cd79c15c",
    "filename": "tensorhive/core/violation_handlers/EmailSendingBehaviour.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/roscisz-TensorHive/tensorhive/core/violation_handlers/EmailSendingBehaviour.py",
    "file_hunks_size": 7,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": true,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "tensorhive/core/violation_handlers/EmailSendingBehaviour.py:119:56 Incompatible parameter type [6]: Expected `LastEmailTime` for 1st positional only parameter to call `EmailSendingBehaviour.time_to_resend` but got `Dict[str, datetime.datetime]`.",
    "message": " Expected `LastEmailTime` for 1st positional only parameter to call `EmailSendingBehaviour.time_to_resend` but got `Dict[str, datetime.datetime]`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 119,
    "warning_line": "        if MAILBOT.NOTIFY_ADMIN and self.time_to_resend(timer, to_admin=True):",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": true,
        "has_suppression": false,
        "source_code": "        log.info('Email to admin has been sent: {}'.format(email))\n\n    @override\n    def trigger_action(self, violation_data: Dict[str, Any]) -> None:\n        '''TODO'''\n        # Expect proper keys beforehand\n        assert {\n            'INTRUDER_USERNAME',\n            'RESERVATION_OWNER_USERNAME',\n            'RESERVATION_OWNER_EMAIL',\n            'RESERVATION_END',\n            'UUID',\n            'HOSTNAME'}.issubset(violation_data), 'Invalid keys in violation_data'\n\n        if not self.test_smtp_configuration():\n            return\n\n        try:\n            # Fetch email address and extend violation data\n            intruder_email = User.find_by_username(violation_data['INTRUDER_USERNAME']).email\n        except NoResultFound as e:\n            intruder_email = None\n            log.warning(e)\n        finally:\n            violation_data['INTRUDER_EMAIL'] = intruder_email\n\n        if not intruder_email:\n            # At least try notify admin\n            timer = self.get_timer(violation_data['INTRUDER_USERNAME'])\n            if MAILBOT.NOTIFY_ADMIN and self.time_to_resend(timer, to_admin=True):\n                self.email_admin(violation_data, timer)\n            return\n\n        # Try email both\n        timer = self.get_timer(intruder_email)\n        if MAILBOT.NOTIFY_INTRUDER and self.time_to_resend(timer):\n            self.email_intruder(intruder_email, violation_data, timer)\n        if MAILBOT.NOTIFY_ADMIN and self.time_to_resend(timer, to_admin=True):\n            self.email_admin(violation_data, timer)\n",
        "source_code_len": 1530,
        "target_code": "        log.info('Email to admin has been sent: {}'.format(email))\n",
        "target_code_len": 67,
        "diff_format": "@@ -82,39 +140,1 @@\n         log.info('Email to admin has been sent: {}'.format(email))\n-\n-    @override\n-    def trigger_action(self, violation_data: Dict[str, Any]) -> None:\n-        '''TODO'''\n-        # Expect proper keys beforehand\n-        assert {\n-            'INTRUDER_USERNAME',\n-            'RESERVATION_OWNER_USERNAME',\n-            'RESERVATION_OWNER_EMAIL',\n-            'RESERVATION_END',\n-            'UUID',\n-            'HOSTNAME'}.issubset(violation_data), 'Invalid keys in violation_data'\n-\n-        if not self.test_smtp_configuration():\n-            return\n-\n-        try:\n-            # Fetch email address and extend violation data\n-            intruder_email = User.find_by_username(violation_data['INTRUDER_USERNAME']).email\n-        except NoResultFound as e:\n-            intruder_email = None\n-            log.warning(e)\n-        finally:\n-            violation_data['INTRUDER_EMAIL'] = intruder_email\n-\n-        if not intruder_email:\n-            # At least try notify admin\n-            timer = self.get_timer(violation_data['INTRUDER_USERNAME'])\n-            if MAILBOT.NOTIFY_ADMIN and self.time_to_resend(timer, to_admin=True):\n-                self.email_admin(violation_data, timer)\n-            return\n-\n-        # Try email both\n-        timer = self.get_timer(intruder_email)\n-        if MAILBOT.NOTIFY_INTRUDER and self.time_to_resend(timer):\n-            self.email_intruder(intruder_email, violation_data, timer)\n-        if MAILBOT.NOTIFY_ADMIN and self.time_to_resend(timer, to_admin=True):\n-            self.email_admin(violation_data, timer)\n",
        "source_code_with_indent": "        log.info('Email to admin has been sent: {}'.format(email))\n\n    <DED>@override\n    def trigger_action(self, violation_data: Dict[str, Any]) -> None:\n        <IND>'''TODO'''\n        # Expect proper keys beforehand\n        assert {\n            'INTRUDER_USERNAME',\n            'RESERVATION_OWNER_USERNAME',\n            'RESERVATION_OWNER_EMAIL',\n            'RESERVATION_END',\n            'UUID',\n            'HOSTNAME'}.issubset(violation_data), 'Invalid keys in violation_data'\n\n        if not self.test_smtp_configuration():\n            <IND>return\n\n        <DED>try:\n            # Fetch email address and extend violation data\n            <IND>intruder_email = User.find_by_username(violation_data['INTRUDER_USERNAME']).email\n        <DED>except NoResultFound as e:\n            <IND>intruder_email = None\n            log.warning(e)\n        <DED>finally:\n            <IND>violation_data['INTRUDER_EMAIL'] = intruder_email\n\n        <DED>if not intruder_email:\n            # At least try notify admin\n            <IND>timer = self.get_timer(violation_data['INTRUDER_USERNAME'])\n            if MAILBOT.NOTIFY_ADMIN and self.time_to_resend(timer, to_admin=True):\n                <IND>self.email_admin(violation_data, timer)\n            <DED>return\n\n        # Try email both\n        <DED>timer = self.get_timer(intruder_email)\n        if MAILBOT.NOTIFY_INTRUDER and self.time_to_resend(timer):\n            <IND>self.email_intruder(intruder_email, violation_data, timer)\n        <DED>if MAILBOT.NOTIFY_ADMIN and self.time_to_resend(timer, to_admin=True):\n            <IND>self.email_admin(violation_data, timer)\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "        log.info('Email to admin has been sent: {}'.format(email))\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "roscisz/TensorHive",
    "commit": "c5ed23f82597837b0e216b50225fb7d7cd79c15c",
    "filename": "tensorhive/core/violation_handlers/EmailSendingBehaviour.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/roscisz-TensorHive/tensorhive/core/violation_handlers/EmailSendingBehaviour.py",
    "file_hunks_size": 7,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": true,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "tensorhive/core/violation_handlers/EmailSendingBehaviour.py:120:45 Incompatible parameter type [6]: Expected `LastEmailTime` for 2nd positional only parameter to call `EmailSendingBehaviour.email_admin` but got `Dict[str, datetime.datetime]`.",
    "message": " Expected `LastEmailTime` for 2nd positional only parameter to call `EmailSendingBehaviour.email_admin` but got `Dict[str, datetime.datetime]`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 120,
    "warning_line": "            self.email_admin(violation_data, timer)",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": true,
        "has_suppression": false,
        "source_code": "        log.info('Email to admin has been sent: {}'.format(email))\n\n    @override\n    def trigger_action(self, violation_data: Dict[str, Any]) -> None:\n        '''TODO'''\n        # Expect proper keys beforehand\n        assert {\n            'INTRUDER_USERNAME',\n            'RESERVATION_OWNER_USERNAME',\n            'RESERVATION_OWNER_EMAIL',\n            'RESERVATION_END',\n            'UUID',\n            'HOSTNAME'}.issubset(violation_data), 'Invalid keys in violation_data'\n\n        if not self.test_smtp_configuration():\n            return\n\n        try:\n            # Fetch email address and extend violation data\n            intruder_email = User.find_by_username(violation_data['INTRUDER_USERNAME']).email\n        except NoResultFound as e:\n            intruder_email = None\n            log.warning(e)\n        finally:\n            violation_data['INTRUDER_EMAIL'] = intruder_email\n\n        if not intruder_email:\n            # At least try notify admin\n            timer = self.get_timer(violation_data['INTRUDER_USERNAME'])\n            if MAILBOT.NOTIFY_ADMIN and self.time_to_resend(timer, to_admin=True):\n                self.email_admin(violation_data, timer)\n            return\n\n        # Try email both\n        timer = self.get_timer(intruder_email)\n        if MAILBOT.NOTIFY_INTRUDER and self.time_to_resend(timer):\n            self.email_intruder(intruder_email, violation_data, timer)\n        if MAILBOT.NOTIFY_ADMIN and self.time_to_resend(timer, to_admin=True):\n            self.email_admin(violation_data, timer)\n",
        "source_code_len": 1530,
        "target_code": "        log.info('Email to admin has been sent: {}'.format(email))\n",
        "target_code_len": 67,
        "diff_format": "@@ -82,39 +140,1 @@\n         log.info('Email to admin has been sent: {}'.format(email))\n-\n-    @override\n-    def trigger_action(self, violation_data: Dict[str, Any]) -> None:\n-        '''TODO'''\n-        # Expect proper keys beforehand\n-        assert {\n-            'INTRUDER_USERNAME',\n-            'RESERVATION_OWNER_USERNAME',\n-            'RESERVATION_OWNER_EMAIL',\n-            'RESERVATION_END',\n-            'UUID',\n-            'HOSTNAME'}.issubset(violation_data), 'Invalid keys in violation_data'\n-\n-        if not self.test_smtp_configuration():\n-            return\n-\n-        try:\n-            # Fetch email address and extend violation data\n-            intruder_email = User.find_by_username(violation_data['INTRUDER_USERNAME']).email\n-        except NoResultFound as e:\n-            intruder_email = None\n-            log.warning(e)\n-        finally:\n-            violation_data['INTRUDER_EMAIL'] = intruder_email\n-\n-        if not intruder_email:\n-            # At least try notify admin\n-            timer = self.get_timer(violation_data['INTRUDER_USERNAME'])\n-            if MAILBOT.NOTIFY_ADMIN and self.time_to_resend(timer, to_admin=True):\n-                self.email_admin(violation_data, timer)\n-            return\n-\n-        # Try email both\n-        timer = self.get_timer(intruder_email)\n-        if MAILBOT.NOTIFY_INTRUDER and self.time_to_resend(timer):\n-            self.email_intruder(intruder_email, violation_data, timer)\n-        if MAILBOT.NOTIFY_ADMIN and self.time_to_resend(timer, to_admin=True):\n-            self.email_admin(violation_data, timer)\n",
        "source_code_with_indent": "        log.info('Email to admin has been sent: {}'.format(email))\n\n    <DED>@override\n    def trigger_action(self, violation_data: Dict[str, Any]) -> None:\n        <IND>'''TODO'''\n        # Expect proper keys beforehand\n        assert {\n            'INTRUDER_USERNAME',\n            'RESERVATION_OWNER_USERNAME',\n            'RESERVATION_OWNER_EMAIL',\n            'RESERVATION_END',\n            'UUID',\n            'HOSTNAME'}.issubset(violation_data), 'Invalid keys in violation_data'\n\n        if not self.test_smtp_configuration():\n            <IND>return\n\n        <DED>try:\n            # Fetch email address and extend violation data\n            <IND>intruder_email = User.find_by_username(violation_data['INTRUDER_USERNAME']).email\n        <DED>except NoResultFound as e:\n            <IND>intruder_email = None\n            log.warning(e)\n        <DED>finally:\n            <IND>violation_data['INTRUDER_EMAIL'] = intruder_email\n\n        <DED>if not intruder_email:\n            # At least try notify admin\n            <IND>timer = self.get_timer(violation_data['INTRUDER_USERNAME'])\n            if MAILBOT.NOTIFY_ADMIN and self.time_to_resend(timer, to_admin=True):\n                <IND>self.email_admin(violation_data, timer)\n            <DED>return\n\n        # Try email both\n        <DED>timer = self.get_timer(intruder_email)\n        if MAILBOT.NOTIFY_INTRUDER and self.time_to_resend(timer):\n            <IND>self.email_intruder(intruder_email, violation_data, timer)\n        <DED>if MAILBOT.NOTIFY_ADMIN and self.time_to_resend(timer, to_admin=True):\n            <IND>self.email_admin(violation_data, timer)\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "        log.info('Email to admin has been sent: {}'.format(email))\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  }
]