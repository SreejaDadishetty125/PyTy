[
  {
    "project": "kenfar/DataGristle",
    "commit": "c85be697bb673eb3181cab4ba1ca84ea198db2bb",
    "filename": "datagristle/common.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/kenfar-DataGristle/datagristle/common.py",
    "file_hunks_size": 3,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "datagristle/common.py:218:12 Incompatible return type [7]: Expected `Dict[str, typing.Any]` but got `List[str]`.",
    "message": " Expected `Dict[str, typing.Any]` but got `List[str]`.",
    "rule_id": "Incompatible return type [7]",
    "warning_line_no": 218,
    "warning_line": "            return col_names",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "def get_best_col_names(config: Dict[str, Any],\n                       dialect: csv.Dialect) -> Dict[str, Any]:\n\n",
        "source_code_len": 112,
        "target_code": "def get_best_col_names(config: Dict[str, Any],\n                       dialect) -> Optional[List[str]]:\n\n",
        "target_code_len": 104,
        "diff_format": "@@ -203,3 +205,3 @@\n def get_best_col_names(config: Dict[str, Any],\n-                       dialect: csv.Dialect) -> Dict[str, Any]:\n+                       dialect) -> Optional[List[str]]:\n \n",
        "source_code_with_indent": "<DED>def get_best_col_names(config: Dict[str, Any],\n                       dialect: csv.Dialect) -> Dict[str, Any]:\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "<DED>def get_best_col_names(config: Dict[str, Any],\n                       dialect) -> Optional[List[str]]:\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "kenfar/DataGristle",
    "commit": "c85be697bb673eb3181cab4ba1ca84ea198db2bb",
    "filename": "datagristle/common.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/kenfar-DataGristle/datagristle/common.py",
    "file_hunks_size": 3,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "datagristle/common.py:220:8 Incompatible return type [7]: Expected `Dict[str, typing.Any]` but got `None`.",
    "message": " Expected `Dict[str, typing.Any]` but got `None`.",
    "rule_id": "Incompatible return type [7]",
    "warning_line_no": 220,
    "warning_line": "        return None",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "def get_best_col_names(config: Dict[str, Any],\n                       dialect: csv.Dialect) -> Dict[str, Any]:\n\n",
        "source_code_len": 112,
        "target_code": "def get_best_col_names(config: Dict[str, Any],\n                       dialect) -> Optional[List[str]]:\n\n",
        "target_code_len": 104,
        "diff_format": "@@ -203,3 +205,3 @@\n def get_best_col_names(config: Dict[str, Any],\n-                       dialect: csv.Dialect) -> Dict[str, Any]:\n+                       dialect) -> Optional[List[str]]:\n \n",
        "source_code_with_indent": "<DED>def get_best_col_names(config: Dict[str, Any],\n                       dialect: csv.Dialect) -> Dict[str, Any]:\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "<DED>def get_best_col_names(config: Dict[str, Any],\n                       dialect) -> Optional[List[str]]:\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "kenfar/DataGristle",
    "commit": "c85be697bb673eb3181cab4ba1ca84ea198db2bb",
    "filename": "datagristle/common.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/kenfar-DataGristle/datagristle/common.py",
    "file_hunks_size": 3,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "datagristle/common.py:220:8 Incompatible return type [7]: Expected `Dict[str, typing.Any]` but got implicit return value of `None`.",
    "message": " Expected `Dict[str, typing.Any]` but got implicit return value of `None`.",
    "rule_id": "Incompatible return type [7]",
    "warning_line_no": 220,
    "warning_line": "        return None",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "def get_best_col_names(config: Dict[str, Any],\n                       dialect: csv.Dialect) -> Dict[str, Any]:\n\n",
        "source_code_len": 112,
        "target_code": "def get_best_col_names(config: Dict[str, Any],\n                       dialect) -> Optional[List[str]]:\n\n",
        "target_code_len": 104,
        "diff_format": "@@ -203,3 +205,3 @@\n def get_best_col_names(config: Dict[str, Any],\n-                       dialect: csv.Dialect) -> Dict[str, Any]:\n+                       dialect) -> Optional[List[str]]:\n \n",
        "source_code_with_indent": "<DED>def get_best_col_names(config: Dict[str, Any],\n                       dialect: csv.Dialect) -> Dict[str, Any]:\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "<DED>def get_best_col_names(config: Dict[str, Any],\n                       dialect) -> Optional[List[str]]:\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "kenfar/DataGristle",
    "commit": "c85be697bb673eb3181cab4ba1ca84ea198db2bb",
    "filename": "datagristle/csvhelper.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/kenfar-DataGristle/datagristle/csvhelper.py",
    "file_hunks_size": 18,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "datagristle/csvhelper.py:27:8 Incompatible return type [7]: Expected `int` but got `None`.",
    "message": " Expected `int` but got `None`.",
    "rule_id": "Incompatible return type [7]",
    "warning_line_no": 27,
    "warning_line": "        return None",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "from pprint import pprint as pp\nfrom typing import Optional, List, Dict\nimport _csv\n",
        "source_code_len": 84,
        "target_code": "from pprint import pprint as pp\nfrom typing import Optional, List, Dict, Any, Union, Type\nimport _csv\n",
        "target_code_len": 102,
        "diff_format": "@@ -11,3 +11,3 @@\n from pprint import pprint as pp\n-from typing import Optional, List, Dict\n+from typing import Optional, List, Dict, Any, Union, Type\n import _csv\n",
        "source_code_with_indent": "from pprint import pprint as pp\nfrom typing import Optional, List, Dict\nimport _csv\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "from pprint import pprint as pp\nfrom typing import Optional, List, Dict, Any, Union, Type\nimport _csv\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\ndef get_quote_number(quote_name: str) -> int:\n    \"\"\" used to help applications look up quote names typically provided by users.\n",
        "source_code_len": 130,
        "target_code": "\ndef get_quote_number(quote_name: Optional[str]) -> Optional[int]:\n    \"\"\" used to help applications look up quote names typically provided by users.\n",
        "target_code_len": 150,
        "diff_format": "@@ -18,3 +18,3 @@\n \n-def get_quote_number(quote_name: str) -> int:\n+def get_quote_number(quote_name: Optional[str]) -> Optional[int]:\n     \"\"\" used to help applications look up quote names typically provided by users.\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\ndef get_quote_number(quote_name: str) -> int:\n    <IND>",
        "target_code_with_indent": "\ndef get_quote_number(quote_name: Optional[str]) -> Optional[int]:\n    <IND>"
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "class Dialect(csv.Dialect):\n    def __init__(self,\n                 delimiter: str,\n                 has_header: bool,\n                 quoting: int,\n                 quotechar: str = None,\n                 doublequote: Optional[str] = None,\n                 escapechar: Optional[str] = None,\n",
        "source_code_len": 293,
        "target_code": "class Dialect(csv.Dialect):\n    \"\"\" A simple Dialect class\n\n    This dialect class includes has_header and minimal defaulting that make it work\n    better for this application - where we want to pass around csv info, not define\n    reusable dialects.\n    \"\"\"\n    def __init__(self,\n                 delimiter: Optional[str],\n                 has_header: Optional[bool],\n                 quoting: Optional[int],\n                 quotechar: Optional[str] = None,\n                 doublequote: Optional[bool] = None,\n                 escapechar: Optional[str] = None,\n",
        "target_code_len": 565,
        "diff_format": "@@ -48,8 +52,14 @@\n class Dialect(csv.Dialect):\n+    \"\"\" A simple Dialect class\n+\n+    This dialect class includes has_header and minimal defaulting that make it work\n+    better for this application - where we want to pass around csv info, not define\n+    reusable dialects.\n+    \"\"\"\n     def __init__(self,\n-                 delimiter: str,\n-                 has_header: bool,\n-                 quoting: int,\n-                 quotechar: str = None,\n-                 doublequote: Optional[str] = None,\n+                 delimiter: Optional[str],\n+                 has_header: Optional[bool],\n+                 quoting: Optional[int],\n+                 quotechar: Optional[str] = None,\n+                 doublequote: Optional[bool] = None,\n                  escapechar: Optional[str] = None,\n",
        "source_code_with_indent": "<DED><DED>class Dialect(csv.Dialect):\n    <IND>def __init__(self,\n                 delimiter: str,\n                 has_header: bool,\n                 quoting: int,\n                 quotechar: str = None,\n                 doublequote: Optional[str] = None,\n                 escapechar: Optional[str] = None,\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "<DED><DED>class Dialect(csv.Dialect):\n    <IND>\"\"\" A simple Dialect class\n\n    This dialect class includes has_header and minimal defaulting that make it work\n    better for this application - where we want to pass around csv info, not define\n    reusable dialects.\n    \"\"\"\n    def __init__(self,\n                 delimiter: Optional[str],\n                 has_header: Optional[bool],\n                 quoting: Optional[int],\n                 quotechar: Optional[str] = None,\n                 doublequote: Optional[bool] = None,\n                 escapechar: Optional[str] = None,\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    if quoting is not None:\n        dialect.quoting = quoting\n    if quotechar is not None:\n",
        "source_code_len": 92,
        "target_code": "    if quoting is not None:\n        dialect.quoting = get_quote_number(quoting)\n    if quotechar is not None:\n",
        "target_code_len": 110,
        "diff_format": "@@ -169,3 +189,3 @@\n     if quoting is not None:\n-        dialect.quoting = quoting\n+        dialect.quoting = get_quote_number(quoting)\n     if quotechar is not None:\n",
        "source_code_with_indent": "    <DED>if quoting is not None:\n        <IND>dialect.quoting = quoting\n    <DED>if quotechar is not None:\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    <DED>if quoting is not None:\n        <IND>dialect.quoting = get_quote_number(quoting)\n    <DED>if quotechar is not None:\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    if dialect.quoting is None:\n        dialect.quoting = quoting\n    if dialect.quotechar is None:\n",
        "source_code_len": 100,
        "target_code": "    if dialect.quoting is None:\n        dialect.quoting = get_quote_number(quoting)\n    if dialect.quotechar is None:\n",
        "target_code_len": 118,
        "diff_format": "@@ -213,3 +233,3 @@\n     if dialect.quoting is None:\n-        dialect.quoting = quoting\n+        dialect.quoting = get_quote_number(quoting)\n     if dialect.quotechar is None:\n",
        "source_code_with_indent": "    <DED>if dialect.quoting is None:\n        <IND>dialect.quoting = quoting\n    <DED>if dialect.quotechar is None:\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    <DED>if dialect.quoting is None:\n        <IND>dialect.quoting = get_quote_number(quoting)\n    <DED>if dialect.quotechar is None:\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    #total_field_cnt  = collections.defaultdict(int)\n    total_field_cnt: Dict[int, int] = {}\n\n",
        "source_code_len": 95,
        "target_code": "    #total_field_cnt  = collections.defaultdict(int)\n    total_field_cnt: Dict[Any, Union[int, float]] = {}\n\n",
        "target_code_len": 109,
        "diff_format": "@@ -302,3 +323,3 @@\n     #total_field_cnt  = collections.defaultdict(int)\n-    total_field_cnt: Dict[int, int] = {}\n+    total_field_cnt: Dict[Any, Union[int, float]] = {}\n \n",
        "source_code_with_indent": "    #total_field_cnt  = collections.defaultdict(int)\n    total_field_cnt: Dict[int, int] = {}\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    #total_field_cnt  = collections.defaultdict(int)\n    total_field_cnt: Dict[Any, Union[int, float]] = {}\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    #quoted_field_cnt = collections.defaultdict(int)\n    quoted_field_cnt: Dict[int, int] = {}\n\n",
        "source_code_len": 96,
        "target_code": "    #quoted_field_cnt = collections.defaultdict(int)\n    quoted_field_cnt: Dict[Any, Union[int, float]] = {}\n\n",
        "target_code_len": 110,
        "diff_format": "@@ -308,3 +329,3 @@\n     #quoted_field_cnt = collections.defaultdict(int)\n-    quoted_field_cnt: Dict[int, int] = {}\n+    quoted_field_cnt: Dict[Any, Union[int, float]] = {}\n \n",
        "source_code_with_indent": "    #quoted_field_cnt = collections.defaultdict(int)\n    quoted_field_cnt: Dict[int, int] = {}\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    #quoted_field_cnt = collections.defaultdict(int)\n    quoted_field_cnt: Dict[Any, Union[int, float]] = {}\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "kenfar/DataGristle",
    "commit": "c85be697bb673eb3181cab4ba1ca84ea198db2bb",
    "filename": "datagristle/csvhelper.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/kenfar-DataGristle/datagristle/csvhelper.py",
    "file_hunks_size": 18,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "datagristle/csvhelper.py:38:8 Incompatible return type [7]: Expected `str` but got `None`.",
    "message": " Expected `str` but got `None`.",
    "rule_id": "Incompatible return type [7]",
    "warning_line_no": 38,
    "warning_line": "        return None",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\ndef get_quote_name(quote_number: int) -> str:\n    \"\"\" used to help applications look up quote names based on the number\n",
        "source_code_len": 121,
        "target_code": "\ndef get_quote_name(quote_number: int) -> Optional[str]:\n    \"\"\" used to help applications look up quote names based on the number\n",
        "target_code_len": 131,
        "diff_format": "@@ -32,3 +34,3 @@\n \n-def get_quote_name(quote_number: int) -> str:\n+def get_quote_name(quote_number: int) -> Optional[str]:\n     \"\"\" used to help applications look up quote names based on the number\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\n<DED><DED>def get_quote_name(quote_number: int) -> str:\n    <IND>",
        "target_code_with_indent": "\n<DED><DED>def get_quote_name(quote_number: int) -> Optional[str]:\n    <IND>"
      }
    ]
  },
  {
    "project": "kenfar/DataGristle",
    "commit": "c85be697bb673eb3181cab4ba1ca84ea198db2bb",
    "filename": "datagristle/csvhelper.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/kenfar-DataGristle/datagristle/csvhelper.py",
    "file_hunks_size": 18,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "datagristle/csvhelper.py:44:8 Incompatible return type [7]: Expected `str` but got implicit return value of `None`.",
    "message": " Expected `str` but got implicit return value of `None`.",
    "rule_id": "Incompatible return type [7]",
    "warning_line_no": 44,
    "warning_line": "        raise ValueError('invalid quote_number: {}'.format(quote_number))",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\ndef get_quote_name(quote_number: int) -> str:\n    \"\"\" used to help applications look up quote names based on the number\n",
        "source_code_len": 121,
        "target_code": "\ndef get_quote_name(quote_number: int) -> Optional[str]:\n    \"\"\" used to help applications look up quote names based on the number\n",
        "target_code_len": 131,
        "diff_format": "@@ -32,3 +34,3 @@\n \n-def get_quote_name(quote_number: int) -> str:\n+def get_quote_name(quote_number: int) -> Optional[str]:\n     \"\"\" used to help applications look up quote names based on the number\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\n<DED><DED>def get_quote_name(quote_number: int) -> str:\n    <IND>",
        "target_code_with_indent": "\n<DED><DED>def get_quote_name(quote_number: int) -> Optional[str]:\n    <IND>"
      }
    ]
  },
  {
    "project": "kenfar/DataGristle",
    "commit": "c85be697bb673eb3181cab4ba1ca84ea198db2bb",
    "filename": "datagristle/csvhelper.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/kenfar-DataGristle/datagristle/csvhelper.py",
    "file_hunks_size": 18,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "datagristle/csvhelper.py:53:17 Incompatible variable type [9]: quotechar is declared to have type `str` but is used as type `None`.",
    "message": " quotechar is declared to have type `str` but is used as type `None`.",
    "rule_id": "Incompatible variable type [9]",
    "warning_line_no": 53,
    "warning_line": "                 quotechar: str = None,",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "from pprint import pprint as pp\nfrom typing import Optional, List, Dict\nimport _csv\n",
        "source_code_len": 84,
        "target_code": "from pprint import pprint as pp\nfrom typing import Optional, List, Dict, Any, Union, Type\nimport _csv\n",
        "target_code_len": 102,
        "diff_format": "@@ -11,3 +11,3 @@\n from pprint import pprint as pp\n-from typing import Optional, List, Dict\n+from typing import Optional, List, Dict, Any, Union, Type\n import _csv\n",
        "source_code_with_indent": "from pprint import pprint as pp\nfrom typing import Optional, List, Dict\nimport _csv\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "from pprint import pprint as pp\nfrom typing import Optional, List, Dict, Any, Union, Type\nimport _csv\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "class Dialect(csv.Dialect):\n    def __init__(self,\n                 delimiter: str,\n                 has_header: bool,\n                 quoting: int,\n                 quotechar: str = None,\n                 doublequote: Optional[str] = None,\n                 escapechar: Optional[str] = None,\n",
        "source_code_len": 293,
        "target_code": "class Dialect(csv.Dialect):\n    \"\"\" A simple Dialect class\n\n    This dialect class includes has_header and minimal defaulting that make it work\n    better for this application - where we want to pass around csv info, not define\n    reusable dialects.\n    \"\"\"\n    def __init__(self,\n                 delimiter: Optional[str],\n                 has_header: Optional[bool],\n                 quoting: Optional[int],\n                 quotechar: Optional[str] = None,\n                 doublequote: Optional[bool] = None,\n                 escapechar: Optional[str] = None,\n",
        "target_code_len": 565,
        "diff_format": "@@ -48,8 +52,14 @@\n class Dialect(csv.Dialect):\n+    \"\"\" A simple Dialect class\n+\n+    This dialect class includes has_header and minimal defaulting that make it work\n+    better for this application - where we want to pass around csv info, not define\n+    reusable dialects.\n+    \"\"\"\n     def __init__(self,\n-                 delimiter: str,\n-                 has_header: bool,\n-                 quoting: int,\n-                 quotechar: str = None,\n-                 doublequote: Optional[str] = None,\n+                 delimiter: Optional[str],\n+                 has_header: Optional[bool],\n+                 quoting: Optional[int],\n+                 quotechar: Optional[str] = None,\n+                 doublequote: Optional[bool] = None,\n                  escapechar: Optional[str] = None,\n",
        "source_code_with_indent": "<DED><DED>class Dialect(csv.Dialect):\n    <IND>def __init__(self,\n                 delimiter: str,\n                 has_header: bool,\n                 quoting: int,\n                 quotechar: str = None,\n                 doublequote: Optional[str] = None,\n                 escapechar: Optional[str] = None,\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "<DED><DED>class Dialect(csv.Dialect):\n    <IND>\"\"\" A simple Dialect class\n\n    This dialect class includes has_header and minimal defaulting that make it work\n    better for this application - where we want to pass around csv info, not define\n    reusable dialects.\n    \"\"\"\n    def __init__(self,\n                 delimiter: Optional[str],\n                 has_header: Optional[bool],\n                 quoting: Optional[int],\n                 quotechar: Optional[str] = None,\n                 doublequote: Optional[bool] = None,\n                 escapechar: Optional[str] = None,\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    if quoting is not None:\n        dialect.quoting = quoting\n    if quotechar is not None:\n",
        "source_code_len": 92,
        "target_code": "    if quoting is not None:\n        dialect.quoting = get_quote_number(quoting)\n    if quotechar is not None:\n",
        "target_code_len": 110,
        "diff_format": "@@ -169,3 +189,3 @@\n     if quoting is not None:\n-        dialect.quoting = quoting\n+        dialect.quoting = get_quote_number(quoting)\n     if quotechar is not None:\n",
        "source_code_with_indent": "    <DED>if quoting is not None:\n        <IND>dialect.quoting = quoting\n    <DED>if quotechar is not None:\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    <DED>if quoting is not None:\n        <IND>dialect.quoting = get_quote_number(quoting)\n    <DED>if quotechar is not None:\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    if dialect.quoting is None:\n        dialect.quoting = quoting\n    if dialect.quotechar is None:\n",
        "source_code_len": 100,
        "target_code": "    if dialect.quoting is None:\n        dialect.quoting = get_quote_number(quoting)\n    if dialect.quotechar is None:\n",
        "target_code_len": 118,
        "diff_format": "@@ -213,3 +233,3 @@\n     if dialect.quoting is None:\n-        dialect.quoting = quoting\n+        dialect.quoting = get_quote_number(quoting)\n     if dialect.quotechar is None:\n",
        "source_code_with_indent": "    <DED>if dialect.quoting is None:\n        <IND>dialect.quoting = quoting\n    <DED>if dialect.quotechar is None:\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    <DED>if dialect.quoting is None:\n        <IND>dialect.quoting = get_quote_number(quoting)\n    <DED>if dialect.quotechar is None:\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    #total_field_cnt  = collections.defaultdict(int)\n    total_field_cnt: Dict[int, int] = {}\n\n",
        "source_code_len": 95,
        "target_code": "    #total_field_cnt  = collections.defaultdict(int)\n    total_field_cnt: Dict[Any, Union[int, float]] = {}\n\n",
        "target_code_len": 109,
        "diff_format": "@@ -302,3 +323,3 @@\n     #total_field_cnt  = collections.defaultdict(int)\n-    total_field_cnt: Dict[int, int] = {}\n+    total_field_cnt: Dict[Any, Union[int, float]] = {}\n \n",
        "source_code_with_indent": "    #total_field_cnt  = collections.defaultdict(int)\n    total_field_cnt: Dict[int, int] = {}\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    #total_field_cnt  = collections.defaultdict(int)\n    total_field_cnt: Dict[Any, Union[int, float]] = {}\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    #quoted_field_cnt = collections.defaultdict(int)\n    quoted_field_cnt: Dict[int, int] = {}\n\n",
        "source_code_len": 96,
        "target_code": "    #quoted_field_cnt = collections.defaultdict(int)\n    quoted_field_cnt: Dict[Any, Union[int, float]] = {}\n\n",
        "target_code_len": 110,
        "diff_format": "@@ -308,3 +329,3 @@\n     #quoted_field_cnt = collections.defaultdict(int)\n-    quoted_field_cnt: Dict[int, int] = {}\n+    quoted_field_cnt: Dict[Any, Union[int, float]] = {}\n \n",
        "source_code_with_indent": "    #quoted_field_cnt = collections.defaultdict(int)\n    quoted_field_cnt: Dict[int, int] = {}\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    #quoted_field_cnt = collections.defaultdict(int)\n    quoted_field_cnt: Dict[Any, Union[int, float]] = {}\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "kenfar/DataGristle",
    "commit": "c85be697bb673eb3181cab4ba1ca84ea198db2bb",
    "filename": "datagristle/csvhelper.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/kenfar-DataGristle/datagristle/csvhelper.py",
    "file_hunks_size": 18,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "datagristle/csvhelper.py:101:32 Incompatible parameter type [6]: Expected `str` for 1st parameter `delimiter` to call `Dialect.__init__` but got `Optional[str]`.",
    "message": " Expected `str` for 1st parameter `delimiter` to call `Dialect.__init__` but got `Optional[str]`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 101,
    "warning_line": "        final_dialect = Dialect(delimiter=delimiter,",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "from pprint import pprint as pp\nfrom typing import Optional, List, Dict\nimport _csv\n",
        "source_code_len": 84,
        "target_code": "from pprint import pprint as pp\nfrom typing import Optional, List, Dict, Any, Union, Type\nimport _csv\n",
        "target_code_len": 102,
        "diff_format": "@@ -11,3 +11,3 @@\n from pprint import pprint as pp\n-from typing import Optional, List, Dict\n+from typing import Optional, List, Dict, Any, Union, Type\n import _csv\n",
        "source_code_with_indent": "from pprint import pprint as pp\nfrom typing import Optional, List, Dict\nimport _csv\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "from pprint import pprint as pp\nfrom typing import Optional, List, Dict, Any, Union, Type\nimport _csv\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "class Dialect(csv.Dialect):\n    def __init__(self,\n                 delimiter: str,\n                 has_header: bool,\n                 quoting: int,\n                 quotechar: str = None,\n                 doublequote: Optional[str] = None,\n                 escapechar: Optional[str] = None,\n",
        "source_code_len": 293,
        "target_code": "class Dialect(csv.Dialect):\n    \"\"\" A simple Dialect class\n\n    This dialect class includes has_header and minimal defaulting that make it work\n    better for this application - where we want to pass around csv info, not define\n    reusable dialects.\n    \"\"\"\n    def __init__(self,\n                 delimiter: Optional[str],\n                 has_header: Optional[bool],\n                 quoting: Optional[int],\n                 quotechar: Optional[str] = None,\n                 doublequote: Optional[bool] = None,\n                 escapechar: Optional[str] = None,\n",
        "target_code_len": 565,
        "diff_format": "@@ -48,8 +52,14 @@\n class Dialect(csv.Dialect):\n+    \"\"\" A simple Dialect class\n+\n+    This dialect class includes has_header and minimal defaulting that make it work\n+    better for this application - where we want to pass around csv info, not define\n+    reusable dialects.\n+    \"\"\"\n     def __init__(self,\n-                 delimiter: str,\n-                 has_header: bool,\n-                 quoting: int,\n-                 quotechar: str = None,\n-                 doublequote: Optional[str] = None,\n+                 delimiter: Optional[str],\n+                 has_header: Optional[bool],\n+                 quoting: Optional[int],\n+                 quotechar: Optional[str] = None,\n+                 doublequote: Optional[bool] = None,\n                  escapechar: Optional[str] = None,\n",
        "source_code_with_indent": "<DED><DED>class Dialect(csv.Dialect):\n    <IND>def __init__(self,\n                 delimiter: str,\n                 has_header: bool,\n                 quoting: int,\n                 quotechar: str = None,\n                 doublequote: Optional[str] = None,\n                 escapechar: Optional[str] = None,\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "<DED><DED>class Dialect(csv.Dialect):\n    <IND>\"\"\" A simple Dialect class\n\n    This dialect class includes has_header and minimal defaulting that make it work\n    better for this application - where we want to pass around csv info, not define\n    reusable dialects.\n    \"\"\"\n    def __init__(self,\n                 delimiter: Optional[str],\n                 has_header: Optional[bool],\n                 quoting: Optional[int],\n                 quotechar: Optional[str] = None,\n                 doublequote: Optional[bool] = None,\n                 escapechar: Optional[str] = None,\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    if quoting is not None:\n        dialect.quoting = quoting\n    if quotechar is not None:\n",
        "source_code_len": 92,
        "target_code": "    if quoting is not None:\n        dialect.quoting = get_quote_number(quoting)\n    if quotechar is not None:\n",
        "target_code_len": 110,
        "diff_format": "@@ -169,3 +189,3 @@\n     if quoting is not None:\n-        dialect.quoting = quoting\n+        dialect.quoting = get_quote_number(quoting)\n     if quotechar is not None:\n",
        "source_code_with_indent": "    <DED>if quoting is not None:\n        <IND>dialect.quoting = quoting\n    <DED>if quotechar is not None:\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    <DED>if quoting is not None:\n        <IND>dialect.quoting = get_quote_number(quoting)\n    <DED>if quotechar is not None:\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    if dialect.quoting is None:\n        dialect.quoting = quoting\n    if dialect.quotechar is None:\n",
        "source_code_len": 100,
        "target_code": "    if dialect.quoting is None:\n        dialect.quoting = get_quote_number(quoting)\n    if dialect.quotechar is None:\n",
        "target_code_len": 118,
        "diff_format": "@@ -213,3 +233,3 @@\n     if dialect.quoting is None:\n-        dialect.quoting = quoting\n+        dialect.quoting = get_quote_number(quoting)\n     if dialect.quotechar is None:\n",
        "source_code_with_indent": "    <DED>if dialect.quoting is None:\n        <IND>dialect.quoting = quoting\n    <DED>if dialect.quotechar is None:\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    <DED>if dialect.quoting is None:\n        <IND>dialect.quoting = get_quote_number(quoting)\n    <DED>if dialect.quotechar is None:\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    #total_field_cnt  = collections.defaultdict(int)\n    total_field_cnt: Dict[int, int] = {}\n\n",
        "source_code_len": 95,
        "target_code": "    #total_field_cnt  = collections.defaultdict(int)\n    total_field_cnt: Dict[Any, Union[int, float]] = {}\n\n",
        "target_code_len": 109,
        "diff_format": "@@ -302,3 +323,3 @@\n     #total_field_cnt  = collections.defaultdict(int)\n-    total_field_cnt: Dict[int, int] = {}\n+    total_field_cnt: Dict[Any, Union[int, float]] = {}\n \n",
        "source_code_with_indent": "    #total_field_cnt  = collections.defaultdict(int)\n    total_field_cnt: Dict[int, int] = {}\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    #total_field_cnt  = collections.defaultdict(int)\n    total_field_cnt: Dict[Any, Union[int, float]] = {}\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    #quoted_field_cnt = collections.defaultdict(int)\n    quoted_field_cnt: Dict[int, int] = {}\n\n",
        "source_code_len": 96,
        "target_code": "    #quoted_field_cnt = collections.defaultdict(int)\n    quoted_field_cnt: Dict[Any, Union[int, float]] = {}\n\n",
        "target_code_len": 110,
        "diff_format": "@@ -308,3 +329,3 @@\n     #quoted_field_cnt = collections.defaultdict(int)\n-    quoted_field_cnt: Dict[int, int] = {}\n+    quoted_field_cnt: Dict[Any, Union[int, float]] = {}\n \n",
        "source_code_with_indent": "    #quoted_field_cnt = collections.defaultdict(int)\n    quoted_field_cnt: Dict[int, int] = {}\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    #quoted_field_cnt = collections.defaultdict(int)\n    quoted_field_cnt: Dict[Any, Union[int, float]] = {}\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "kenfar/DataGristle",
    "commit": "c85be697bb673eb3181cab4ba1ca84ea198db2bb",
    "filename": "datagristle/csvhelper.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/kenfar-DataGristle/datagristle/csvhelper.py",
    "file_hunks_size": 18,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "datagristle/csvhelper.py:102:57 Incompatible parameter type [6]: Expected `str` for 1st positional only parameter to call `get_quote_number` but got `Optional[str]`.",
    "message": " Expected `str` for 1st positional only parameter to call `get_quote_number` but got `Optional[str]`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 102,
    "warning_line": "                                quoting=get_quote_number(quoting),",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "from pprint import pprint as pp\nfrom typing import Optional, List, Dict\nimport _csv\n",
        "source_code_len": 84,
        "target_code": "from pprint import pprint as pp\nfrom typing import Optional, List, Dict, Any, Union, Type\nimport _csv\n",
        "target_code_len": 102,
        "diff_format": "@@ -11,3 +11,3 @@\n from pprint import pprint as pp\n-from typing import Optional, List, Dict\n+from typing import Optional, List, Dict, Any, Union, Type\n import _csv\n",
        "source_code_with_indent": "from pprint import pprint as pp\nfrom typing import Optional, List, Dict\nimport _csv\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "from pprint import pprint as pp\nfrom typing import Optional, List, Dict, Any, Union, Type\nimport _csv\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\ndef get_quote_number(quote_name: str) -> int:\n    \"\"\" used to help applications look up quote names typically provided by users.\n",
        "source_code_len": 130,
        "target_code": "\ndef get_quote_number(quote_name: Optional[str]) -> Optional[int]:\n    \"\"\" used to help applications look up quote names typically provided by users.\n",
        "target_code_len": 150,
        "diff_format": "@@ -18,3 +18,3 @@\n \n-def get_quote_number(quote_name: str) -> int:\n+def get_quote_number(quote_name: Optional[str]) -> Optional[int]:\n     \"\"\" used to help applications look up quote names typically provided by users.\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\ndef get_quote_number(quote_name: str) -> int:\n    <IND>",
        "target_code_with_indent": "\ndef get_quote_number(quote_name: Optional[str]) -> Optional[int]:\n    <IND>"
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "class Dialect(csv.Dialect):\n    def __init__(self,\n                 delimiter: str,\n                 has_header: bool,\n                 quoting: int,\n                 quotechar: str = None,\n                 doublequote: Optional[str] = None,\n                 escapechar: Optional[str] = None,\n",
        "source_code_len": 293,
        "target_code": "class Dialect(csv.Dialect):\n    \"\"\" A simple Dialect class\n\n    This dialect class includes has_header and minimal defaulting that make it work\n    better for this application - where we want to pass around csv info, not define\n    reusable dialects.\n    \"\"\"\n    def __init__(self,\n                 delimiter: Optional[str],\n                 has_header: Optional[bool],\n                 quoting: Optional[int],\n                 quotechar: Optional[str] = None,\n                 doublequote: Optional[bool] = None,\n                 escapechar: Optional[str] = None,\n",
        "target_code_len": 565,
        "diff_format": "@@ -48,8 +52,14 @@\n class Dialect(csv.Dialect):\n+    \"\"\" A simple Dialect class\n+\n+    This dialect class includes has_header and minimal defaulting that make it work\n+    better for this application - where we want to pass around csv info, not define\n+    reusable dialects.\n+    \"\"\"\n     def __init__(self,\n-                 delimiter: str,\n-                 has_header: bool,\n-                 quoting: int,\n-                 quotechar: str = None,\n-                 doublequote: Optional[str] = None,\n+                 delimiter: Optional[str],\n+                 has_header: Optional[bool],\n+                 quoting: Optional[int],\n+                 quotechar: Optional[str] = None,\n+                 doublequote: Optional[bool] = None,\n                  escapechar: Optional[str] = None,\n",
        "source_code_with_indent": "<DED><DED>class Dialect(csv.Dialect):\n    <IND>def __init__(self,\n                 delimiter: str,\n                 has_header: bool,\n                 quoting: int,\n                 quotechar: str = None,\n                 doublequote: Optional[str] = None,\n                 escapechar: Optional[str] = None,\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "<DED><DED>class Dialect(csv.Dialect):\n    <IND>\"\"\" A simple Dialect class\n\n    This dialect class includes has_header and minimal defaulting that make it work\n    better for this application - where we want to pass around csv info, not define\n    reusable dialects.\n    \"\"\"\n    def __init__(self,\n                 delimiter: Optional[str],\n                 has_header: Optional[bool],\n                 quoting: Optional[int],\n                 quotechar: Optional[str] = None,\n                 doublequote: Optional[bool] = None,\n                 escapechar: Optional[str] = None,\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    if quoting is not None:\n        dialect.quoting = quoting\n    if quotechar is not None:\n",
        "source_code_len": 92,
        "target_code": "    if quoting is not None:\n        dialect.quoting = get_quote_number(quoting)\n    if quotechar is not None:\n",
        "target_code_len": 110,
        "diff_format": "@@ -169,3 +189,3 @@\n     if quoting is not None:\n-        dialect.quoting = quoting\n+        dialect.quoting = get_quote_number(quoting)\n     if quotechar is not None:\n",
        "source_code_with_indent": "    <DED>if quoting is not None:\n        <IND>dialect.quoting = quoting\n    <DED>if quotechar is not None:\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    <DED>if quoting is not None:\n        <IND>dialect.quoting = get_quote_number(quoting)\n    <DED>if quotechar is not None:\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    if dialect.quoting is None:\n        dialect.quoting = quoting\n    if dialect.quotechar is None:\n",
        "source_code_len": 100,
        "target_code": "    if dialect.quoting is None:\n        dialect.quoting = get_quote_number(quoting)\n    if dialect.quotechar is None:\n",
        "target_code_len": 118,
        "diff_format": "@@ -213,3 +233,3 @@\n     if dialect.quoting is None:\n-        dialect.quoting = quoting\n+        dialect.quoting = get_quote_number(quoting)\n     if dialect.quotechar is None:\n",
        "source_code_with_indent": "    <DED>if dialect.quoting is None:\n        <IND>dialect.quoting = quoting\n    <DED>if dialect.quotechar is None:\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    <DED>if dialect.quoting is None:\n        <IND>dialect.quoting = get_quote_number(quoting)\n    <DED>if dialect.quotechar is None:\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    #total_field_cnt  = collections.defaultdict(int)\n    total_field_cnt: Dict[int, int] = {}\n\n",
        "source_code_len": 95,
        "target_code": "    #total_field_cnt  = collections.defaultdict(int)\n    total_field_cnt: Dict[Any, Union[int, float]] = {}\n\n",
        "target_code_len": 109,
        "diff_format": "@@ -302,3 +323,3 @@\n     #total_field_cnt  = collections.defaultdict(int)\n-    total_field_cnt: Dict[int, int] = {}\n+    total_field_cnt: Dict[Any, Union[int, float]] = {}\n \n",
        "source_code_with_indent": "    #total_field_cnt  = collections.defaultdict(int)\n    total_field_cnt: Dict[int, int] = {}\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    #total_field_cnt  = collections.defaultdict(int)\n    total_field_cnt: Dict[Any, Union[int, float]] = {}\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    #quoted_field_cnt = collections.defaultdict(int)\n    quoted_field_cnt: Dict[int, int] = {}\n\n",
        "source_code_len": 96,
        "target_code": "    #quoted_field_cnt = collections.defaultdict(int)\n    quoted_field_cnt: Dict[Any, Union[int, float]] = {}\n\n",
        "target_code_len": 110,
        "diff_format": "@@ -308,3 +329,3 @@\n     #quoted_field_cnt = collections.defaultdict(int)\n-    quoted_field_cnt: Dict[int, int] = {}\n+    quoted_field_cnt: Dict[Any, Union[int, float]] = {}\n \n",
        "source_code_with_indent": "    #quoted_field_cnt = collections.defaultdict(int)\n    quoted_field_cnt: Dict[int, int] = {}\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    #quoted_field_cnt = collections.defaultdict(int)\n    quoted_field_cnt: Dict[Any, Union[int, float]] = {}\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "kenfar/DataGristle",
    "commit": "c85be697bb673eb3181cab4ba1ca84ea198db2bb",
    "filename": "datagristle/csvhelper.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/kenfar-DataGristle/datagristle/csvhelper.py",
    "file_hunks_size": 18,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "datagristle/csvhelper.py:103:32 Incompatible parameter type [6]: Expected `str` for 3rd parameter `quotechar` to call `Dialect.__init__` but got `Optional[str]`.",
    "message": " Expected `str` for 3rd parameter `quotechar` to call `Dialect.__init__` but got `Optional[str]`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 103,
    "warning_line": "                                quotechar=quotechar,",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "from pprint import pprint as pp\nfrom typing import Optional, List, Dict\nimport _csv\n",
        "source_code_len": 84,
        "target_code": "from pprint import pprint as pp\nfrom typing import Optional, List, Dict, Any, Union, Type\nimport _csv\n",
        "target_code_len": 102,
        "diff_format": "@@ -11,3 +11,3 @@\n from pprint import pprint as pp\n-from typing import Optional, List, Dict\n+from typing import Optional, List, Dict, Any, Union, Type\n import _csv\n",
        "source_code_with_indent": "from pprint import pprint as pp\nfrom typing import Optional, List, Dict\nimport _csv\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "from pprint import pprint as pp\nfrom typing import Optional, List, Dict, Any, Union, Type\nimport _csv\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "class Dialect(csv.Dialect):\n    def __init__(self,\n                 delimiter: str,\n                 has_header: bool,\n                 quoting: int,\n                 quotechar: str = None,\n                 doublequote: Optional[str] = None,\n                 escapechar: Optional[str] = None,\n",
        "source_code_len": 293,
        "target_code": "class Dialect(csv.Dialect):\n    \"\"\" A simple Dialect class\n\n    This dialect class includes has_header and minimal defaulting that make it work\n    better for this application - where we want to pass around csv info, not define\n    reusable dialects.\n    \"\"\"\n    def __init__(self,\n                 delimiter: Optional[str],\n                 has_header: Optional[bool],\n                 quoting: Optional[int],\n                 quotechar: Optional[str] = None,\n                 doublequote: Optional[bool] = None,\n                 escapechar: Optional[str] = None,\n",
        "target_code_len": 565,
        "diff_format": "@@ -48,8 +52,14 @@\n class Dialect(csv.Dialect):\n+    \"\"\" A simple Dialect class\n+\n+    This dialect class includes has_header and minimal defaulting that make it work\n+    better for this application - where we want to pass around csv info, not define\n+    reusable dialects.\n+    \"\"\"\n     def __init__(self,\n-                 delimiter: str,\n-                 has_header: bool,\n-                 quoting: int,\n-                 quotechar: str = None,\n-                 doublequote: Optional[str] = None,\n+                 delimiter: Optional[str],\n+                 has_header: Optional[bool],\n+                 quoting: Optional[int],\n+                 quotechar: Optional[str] = None,\n+                 doublequote: Optional[bool] = None,\n                  escapechar: Optional[str] = None,\n",
        "source_code_with_indent": "<DED><DED>class Dialect(csv.Dialect):\n    <IND>def __init__(self,\n                 delimiter: str,\n                 has_header: bool,\n                 quoting: int,\n                 quotechar: str = None,\n                 doublequote: Optional[str] = None,\n                 escapechar: Optional[str] = None,\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "<DED><DED>class Dialect(csv.Dialect):\n    <IND>\"\"\" A simple Dialect class\n\n    This dialect class includes has_header and minimal defaulting that make it work\n    better for this application - where we want to pass around csv info, not define\n    reusable dialects.\n    \"\"\"\n    def __init__(self,\n                 delimiter: Optional[str],\n                 has_header: Optional[bool],\n                 quoting: Optional[int],\n                 quotechar: Optional[str] = None,\n                 doublequote: Optional[bool] = None,\n                 escapechar: Optional[str] = None,\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    if quoting is not None:\n        dialect.quoting = quoting\n    if quotechar is not None:\n",
        "source_code_len": 92,
        "target_code": "    if quoting is not None:\n        dialect.quoting = get_quote_number(quoting)\n    if quotechar is not None:\n",
        "target_code_len": 110,
        "diff_format": "@@ -169,3 +189,3 @@\n     if quoting is not None:\n-        dialect.quoting = quoting\n+        dialect.quoting = get_quote_number(quoting)\n     if quotechar is not None:\n",
        "source_code_with_indent": "    <DED>if quoting is not None:\n        <IND>dialect.quoting = quoting\n    <DED>if quotechar is not None:\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    <DED>if quoting is not None:\n        <IND>dialect.quoting = get_quote_number(quoting)\n    <DED>if quotechar is not None:\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    if dialect.quoting is None:\n        dialect.quoting = quoting\n    if dialect.quotechar is None:\n",
        "source_code_len": 100,
        "target_code": "    if dialect.quoting is None:\n        dialect.quoting = get_quote_number(quoting)\n    if dialect.quotechar is None:\n",
        "target_code_len": 118,
        "diff_format": "@@ -213,3 +233,3 @@\n     if dialect.quoting is None:\n-        dialect.quoting = quoting\n+        dialect.quoting = get_quote_number(quoting)\n     if dialect.quotechar is None:\n",
        "source_code_with_indent": "    <DED>if dialect.quoting is None:\n        <IND>dialect.quoting = quoting\n    <DED>if dialect.quotechar is None:\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    <DED>if dialect.quoting is None:\n        <IND>dialect.quoting = get_quote_number(quoting)\n    <DED>if dialect.quotechar is None:\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    #total_field_cnt  = collections.defaultdict(int)\n    total_field_cnt: Dict[int, int] = {}\n\n",
        "source_code_len": 95,
        "target_code": "    #total_field_cnt  = collections.defaultdict(int)\n    total_field_cnt: Dict[Any, Union[int, float]] = {}\n\n",
        "target_code_len": 109,
        "diff_format": "@@ -302,3 +323,3 @@\n     #total_field_cnt  = collections.defaultdict(int)\n-    total_field_cnt: Dict[int, int] = {}\n+    total_field_cnt: Dict[Any, Union[int, float]] = {}\n \n",
        "source_code_with_indent": "    #total_field_cnt  = collections.defaultdict(int)\n    total_field_cnt: Dict[int, int] = {}\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    #total_field_cnt  = collections.defaultdict(int)\n    total_field_cnt: Dict[Any, Union[int, float]] = {}\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    #quoted_field_cnt = collections.defaultdict(int)\n    quoted_field_cnt: Dict[int, int] = {}\n\n",
        "source_code_len": 96,
        "target_code": "    #quoted_field_cnt = collections.defaultdict(int)\n    quoted_field_cnt: Dict[Any, Union[int, float]] = {}\n\n",
        "target_code_len": 110,
        "diff_format": "@@ -308,3 +329,3 @@\n     #quoted_field_cnt = collections.defaultdict(int)\n-    quoted_field_cnt: Dict[int, int] = {}\n+    quoted_field_cnt: Dict[Any, Union[int, float]] = {}\n \n",
        "source_code_with_indent": "    #quoted_field_cnt = collections.defaultdict(int)\n    quoted_field_cnt: Dict[int, int] = {}\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    #quoted_field_cnt = collections.defaultdict(int)\n    quoted_field_cnt: Dict[Any, Union[int, float]] = {}\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "kenfar/DataGristle",
    "commit": "c85be697bb673eb3181cab4ba1ca84ea198db2bb",
    "filename": "datagristle/csvhelper.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/kenfar-DataGristle/datagristle/csvhelper.py",
    "file_hunks_size": 18,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "datagristle/csvhelper.py:104:32 Incompatible parameter type [6]: Expected `bool` for 4th parameter `has_header` to call `Dialect.__init__` but got `Optional[bool]`.",
    "message": " Expected `bool` for 4th parameter `has_header` to call `Dialect.__init__` but got `Optional[bool]`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 104,
    "warning_line": "                                has_header=has_header,",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "from pprint import pprint as pp\nfrom typing import Optional, List, Dict\nimport _csv\n",
        "source_code_len": 84,
        "target_code": "from pprint import pprint as pp\nfrom typing import Optional, List, Dict, Any, Union, Type\nimport _csv\n",
        "target_code_len": 102,
        "diff_format": "@@ -11,3 +11,3 @@\n from pprint import pprint as pp\n-from typing import Optional, List, Dict\n+from typing import Optional, List, Dict, Any, Union, Type\n import _csv\n",
        "source_code_with_indent": "from pprint import pprint as pp\nfrom typing import Optional, List, Dict\nimport _csv\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "from pprint import pprint as pp\nfrom typing import Optional, List, Dict, Any, Union, Type\nimport _csv\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "class Dialect(csv.Dialect):\n    def __init__(self,\n                 delimiter: str,\n                 has_header: bool,\n                 quoting: int,\n                 quotechar: str = None,\n                 doublequote: Optional[str] = None,\n                 escapechar: Optional[str] = None,\n",
        "source_code_len": 293,
        "target_code": "class Dialect(csv.Dialect):\n    \"\"\" A simple Dialect class\n\n    This dialect class includes has_header and minimal defaulting that make it work\n    better for this application - where we want to pass around csv info, not define\n    reusable dialects.\n    \"\"\"\n    def __init__(self,\n                 delimiter: Optional[str],\n                 has_header: Optional[bool],\n                 quoting: Optional[int],\n                 quotechar: Optional[str] = None,\n                 doublequote: Optional[bool] = None,\n                 escapechar: Optional[str] = None,\n",
        "target_code_len": 565,
        "diff_format": "@@ -48,8 +52,14 @@\n class Dialect(csv.Dialect):\n+    \"\"\" A simple Dialect class\n+\n+    This dialect class includes has_header and minimal defaulting that make it work\n+    better for this application - where we want to pass around csv info, not define\n+    reusable dialects.\n+    \"\"\"\n     def __init__(self,\n-                 delimiter: str,\n-                 has_header: bool,\n-                 quoting: int,\n-                 quotechar: str = None,\n-                 doublequote: Optional[str] = None,\n+                 delimiter: Optional[str],\n+                 has_header: Optional[bool],\n+                 quoting: Optional[int],\n+                 quotechar: Optional[str] = None,\n+                 doublequote: Optional[bool] = None,\n                  escapechar: Optional[str] = None,\n",
        "source_code_with_indent": "<DED><DED>class Dialect(csv.Dialect):\n    <IND>def __init__(self,\n                 delimiter: str,\n                 has_header: bool,\n                 quoting: int,\n                 quotechar: str = None,\n                 doublequote: Optional[str] = None,\n                 escapechar: Optional[str] = None,\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "<DED><DED>class Dialect(csv.Dialect):\n    <IND>\"\"\" A simple Dialect class\n\n    This dialect class includes has_header and minimal defaulting that make it work\n    better for this application - where we want to pass around csv info, not define\n    reusable dialects.\n    \"\"\"\n    def __init__(self,\n                 delimiter: Optional[str],\n                 has_header: Optional[bool],\n                 quoting: Optional[int],\n                 quotechar: Optional[str] = None,\n                 doublequote: Optional[bool] = None,\n                 escapechar: Optional[str] = None,\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    if quoting is not None:\n        dialect.quoting = quoting\n    if quotechar is not None:\n",
        "source_code_len": 92,
        "target_code": "    if quoting is not None:\n        dialect.quoting = get_quote_number(quoting)\n    if quotechar is not None:\n",
        "target_code_len": 110,
        "diff_format": "@@ -169,3 +189,3 @@\n     if quoting is not None:\n-        dialect.quoting = quoting\n+        dialect.quoting = get_quote_number(quoting)\n     if quotechar is not None:\n",
        "source_code_with_indent": "    <DED>if quoting is not None:\n        <IND>dialect.quoting = quoting\n    <DED>if quotechar is not None:\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    <DED>if quoting is not None:\n        <IND>dialect.quoting = get_quote_number(quoting)\n    <DED>if quotechar is not None:\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    if dialect.quoting is None:\n        dialect.quoting = quoting\n    if dialect.quotechar is None:\n",
        "source_code_len": 100,
        "target_code": "    if dialect.quoting is None:\n        dialect.quoting = get_quote_number(quoting)\n    if dialect.quotechar is None:\n",
        "target_code_len": 118,
        "diff_format": "@@ -213,3 +233,3 @@\n     if dialect.quoting is None:\n-        dialect.quoting = quoting\n+        dialect.quoting = get_quote_number(quoting)\n     if dialect.quotechar is None:\n",
        "source_code_with_indent": "    <DED>if dialect.quoting is None:\n        <IND>dialect.quoting = quoting\n    <DED>if dialect.quotechar is None:\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    <DED>if dialect.quoting is None:\n        <IND>dialect.quoting = get_quote_number(quoting)\n    <DED>if dialect.quotechar is None:\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    #total_field_cnt  = collections.defaultdict(int)\n    total_field_cnt: Dict[int, int] = {}\n\n",
        "source_code_len": 95,
        "target_code": "    #total_field_cnt  = collections.defaultdict(int)\n    total_field_cnt: Dict[Any, Union[int, float]] = {}\n\n",
        "target_code_len": 109,
        "diff_format": "@@ -302,3 +323,3 @@\n     #total_field_cnt  = collections.defaultdict(int)\n-    total_field_cnt: Dict[int, int] = {}\n+    total_field_cnt: Dict[Any, Union[int, float]] = {}\n \n",
        "source_code_with_indent": "    #total_field_cnt  = collections.defaultdict(int)\n    total_field_cnt: Dict[int, int] = {}\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    #total_field_cnt  = collections.defaultdict(int)\n    total_field_cnt: Dict[Any, Union[int, float]] = {}\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    #quoted_field_cnt = collections.defaultdict(int)\n    quoted_field_cnt: Dict[int, int] = {}\n\n",
        "source_code_len": 96,
        "target_code": "    #quoted_field_cnt = collections.defaultdict(int)\n    quoted_field_cnt: Dict[Any, Union[int, float]] = {}\n\n",
        "target_code_len": 110,
        "diff_format": "@@ -308,3 +329,3 @@\n     #quoted_field_cnt = collections.defaultdict(int)\n-    quoted_field_cnt: Dict[int, int] = {}\n+    quoted_field_cnt: Dict[Any, Union[int, float]] = {}\n \n",
        "source_code_with_indent": "    #quoted_field_cnt = collections.defaultdict(int)\n    quoted_field_cnt: Dict[int, int] = {}\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    #quoted_field_cnt = collections.defaultdict(int)\n    quoted_field_cnt: Dict[Any, Union[int, float]] = {}\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "kenfar/DataGristle",
    "commit": "c85be697bb673eb3181cab4ba1ca84ea198db2bb",
    "filename": "datagristle/csvhelper.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/kenfar-DataGristle/datagristle/csvhelper.py",
    "file_hunks_size": 18,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "datagristle/csvhelper.py:105:32 Incompatible parameter type [6]: Expected `Optional[str]` for 5th parameter `doublequote` to call `Dialect.__init__` but got `Optional[bool]`.",
    "message": " Expected `Optional[str]` for 5th parameter `doublequote` to call `Dialect.__init__` but got `Optional[bool]`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 105,
    "warning_line": "                                doublequote=doublequote,",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "from pprint import pprint as pp\nfrom typing import Optional, List, Dict\nimport _csv\n",
        "source_code_len": 84,
        "target_code": "from pprint import pprint as pp\nfrom typing import Optional, List, Dict, Any, Union, Type\nimport _csv\n",
        "target_code_len": 102,
        "diff_format": "@@ -11,3 +11,3 @@\n from pprint import pprint as pp\n-from typing import Optional, List, Dict\n+from typing import Optional, List, Dict, Any, Union, Type\n import _csv\n",
        "source_code_with_indent": "from pprint import pprint as pp\nfrom typing import Optional, List, Dict\nimport _csv\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "from pprint import pprint as pp\nfrom typing import Optional, List, Dict, Any, Union, Type\nimport _csv\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "class Dialect(csv.Dialect):\n    def __init__(self,\n                 delimiter: str,\n                 has_header: bool,\n                 quoting: int,\n                 quotechar: str = None,\n                 doublequote: Optional[str] = None,\n                 escapechar: Optional[str] = None,\n",
        "source_code_len": 293,
        "target_code": "class Dialect(csv.Dialect):\n    \"\"\" A simple Dialect class\n\n    This dialect class includes has_header and minimal defaulting that make it work\n    better for this application - where we want to pass around csv info, not define\n    reusable dialects.\n    \"\"\"\n    def __init__(self,\n                 delimiter: Optional[str],\n                 has_header: Optional[bool],\n                 quoting: Optional[int],\n                 quotechar: Optional[str] = None,\n                 doublequote: Optional[bool] = None,\n                 escapechar: Optional[str] = None,\n",
        "target_code_len": 565,
        "diff_format": "@@ -48,8 +52,14 @@\n class Dialect(csv.Dialect):\n+    \"\"\" A simple Dialect class\n+\n+    This dialect class includes has_header and minimal defaulting that make it work\n+    better for this application - where we want to pass around csv info, not define\n+    reusable dialects.\n+    \"\"\"\n     def __init__(self,\n-                 delimiter: str,\n-                 has_header: bool,\n-                 quoting: int,\n-                 quotechar: str = None,\n-                 doublequote: Optional[str] = None,\n+                 delimiter: Optional[str],\n+                 has_header: Optional[bool],\n+                 quoting: Optional[int],\n+                 quotechar: Optional[str] = None,\n+                 doublequote: Optional[bool] = None,\n                  escapechar: Optional[str] = None,\n",
        "source_code_with_indent": "<DED><DED>class Dialect(csv.Dialect):\n    <IND>def __init__(self,\n                 delimiter: str,\n                 has_header: bool,\n                 quoting: int,\n                 quotechar: str = None,\n                 doublequote: Optional[str] = None,\n                 escapechar: Optional[str] = None,\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "<DED><DED>class Dialect(csv.Dialect):\n    <IND>\"\"\" A simple Dialect class\n\n    This dialect class includes has_header and minimal defaulting that make it work\n    better for this application - where we want to pass around csv info, not define\n    reusable dialects.\n    \"\"\"\n    def __init__(self,\n                 delimiter: Optional[str],\n                 has_header: Optional[bool],\n                 quoting: Optional[int],\n                 quotechar: Optional[str] = None,\n                 doublequote: Optional[bool] = None,\n                 escapechar: Optional[str] = None,\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    if quoting is not None:\n        dialect.quoting = quoting\n    if quotechar is not None:\n",
        "source_code_len": 92,
        "target_code": "    if quoting is not None:\n        dialect.quoting = get_quote_number(quoting)\n    if quotechar is not None:\n",
        "target_code_len": 110,
        "diff_format": "@@ -169,3 +189,3 @@\n     if quoting is not None:\n-        dialect.quoting = quoting\n+        dialect.quoting = get_quote_number(quoting)\n     if quotechar is not None:\n",
        "source_code_with_indent": "    <DED>if quoting is not None:\n        <IND>dialect.quoting = quoting\n    <DED>if quotechar is not None:\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    <DED>if quoting is not None:\n        <IND>dialect.quoting = get_quote_number(quoting)\n    <DED>if quotechar is not None:\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    if dialect.quoting is None:\n        dialect.quoting = quoting\n    if dialect.quotechar is None:\n",
        "source_code_len": 100,
        "target_code": "    if dialect.quoting is None:\n        dialect.quoting = get_quote_number(quoting)\n    if dialect.quotechar is None:\n",
        "target_code_len": 118,
        "diff_format": "@@ -213,3 +233,3 @@\n     if dialect.quoting is None:\n-        dialect.quoting = quoting\n+        dialect.quoting = get_quote_number(quoting)\n     if dialect.quotechar is None:\n",
        "source_code_with_indent": "    <DED>if dialect.quoting is None:\n        <IND>dialect.quoting = quoting\n    <DED>if dialect.quotechar is None:\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    <DED>if dialect.quoting is None:\n        <IND>dialect.quoting = get_quote_number(quoting)\n    <DED>if dialect.quotechar is None:\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    #total_field_cnt  = collections.defaultdict(int)\n    total_field_cnt: Dict[int, int] = {}\n\n",
        "source_code_len": 95,
        "target_code": "    #total_field_cnt  = collections.defaultdict(int)\n    total_field_cnt: Dict[Any, Union[int, float]] = {}\n\n",
        "target_code_len": 109,
        "diff_format": "@@ -302,3 +323,3 @@\n     #total_field_cnt  = collections.defaultdict(int)\n-    total_field_cnt: Dict[int, int] = {}\n+    total_field_cnt: Dict[Any, Union[int, float]] = {}\n \n",
        "source_code_with_indent": "    #total_field_cnt  = collections.defaultdict(int)\n    total_field_cnt: Dict[int, int] = {}\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    #total_field_cnt  = collections.defaultdict(int)\n    total_field_cnt: Dict[Any, Union[int, float]] = {}\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    #quoted_field_cnt = collections.defaultdict(int)\n    quoted_field_cnt: Dict[int, int] = {}\n\n",
        "source_code_len": 96,
        "target_code": "    #quoted_field_cnt = collections.defaultdict(int)\n    quoted_field_cnt: Dict[Any, Union[int, float]] = {}\n\n",
        "target_code_len": 110,
        "diff_format": "@@ -308,3 +329,3 @@\n     #quoted_field_cnt = collections.defaultdict(int)\n-    quoted_field_cnt: Dict[int, int] = {}\n+    quoted_field_cnt: Dict[Any, Union[int, float]] = {}\n \n",
        "source_code_with_indent": "    #quoted_field_cnt = collections.defaultdict(int)\n    quoted_field_cnt: Dict[int, int] = {}\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    #quoted_field_cnt = collections.defaultdict(int)\n    quoted_field_cnt: Dict[Any, Union[int, float]] = {}\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "kenfar/DataGristle",
    "commit": "c85be697bb673eb3181cab4ba1ca84ea198db2bb",
    "filename": "datagristle/csvhelper.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/kenfar-DataGristle/datagristle/csvhelper.py",
    "file_hunks_size": 18,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": true,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "datagristle/csvhelper.py:170:8 Incompatible attribute type [8]: Attribute `quoting` declared in class `Dialect` has type `int` but is used as type `str`.",
    "message": " Attribute `quoting` declared in class `Dialect` has type `int` but is used as type `str`.",
    "rule_id": "Incompatible attribute type [8]",
    "warning_line_no": 170,
    "warning_line": "        dialect.quoting = quoting",
    "min_patch": [
      {
        "hunk_fit_TFix": true,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    if quoting is not None:\n        dialect.quoting = quoting\n    if quotechar is not None:\n",
        "source_code_len": 92,
        "target_code": "    if quoting is not None:\n        dialect.quoting = get_quote_number(quoting)\n    if quotechar is not None:\n",
        "target_code_len": 110,
        "diff_format": "@@ -169,3 +189,3 @@\n     if quoting is not None:\n-        dialect.quoting = quoting\n+        dialect.quoting = get_quote_number(quoting)\n     if quotechar is not None:\n",
        "source_code_with_indent": "    <DED>if quoting is not None:\n        <IND>dialect.quoting = quoting\n    <DED>if quotechar is not None:\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    <DED>if quoting is not None:\n        <IND>dialect.quoting = get_quote_number(quoting)\n    <DED>if quotechar is not None:\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "kenfar/DataGristle",
    "commit": "c85be697bb673eb3181cab4ba1ca84ea198db2bb",
    "filename": "datagristle/csvhelper.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/kenfar-DataGristle/datagristle/csvhelper.py",
    "file_hunks_size": 18,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "datagristle/csvhelper.py:174:8 Incompatible attribute type [8]: Attribute `quotechar` declared in class `Dialect` has type `str` but is used as type `None`.",
    "message": " Attribute `quotechar` declared in class `Dialect` has type `str` but is used as type `None`.",
    "rule_id": "Incompatible attribute type [8]",
    "warning_line_no": 174,
    "warning_line": "        dialect.quotechar = None",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "from pprint import pprint as pp\nfrom typing import Optional, List, Dict\nimport _csv\n",
        "source_code_len": 84,
        "target_code": "from pprint import pprint as pp\nfrom typing import Optional, List, Dict, Any, Union, Type\nimport _csv\n",
        "target_code_len": 102,
        "diff_format": "@@ -11,3 +11,3 @@\n from pprint import pprint as pp\n-from typing import Optional, List, Dict\n+from typing import Optional, List, Dict, Any, Union, Type\n import _csv\n",
        "source_code_with_indent": "from pprint import pprint as pp\nfrom typing import Optional, List, Dict\nimport _csv\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "from pprint import pprint as pp\nfrom typing import Optional, List, Dict, Any, Union, Type\nimport _csv\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "class Dialect(csv.Dialect):\n    def __init__(self,\n                 delimiter: str,\n                 has_header: bool,\n                 quoting: int,\n                 quotechar: str = None,\n                 doublequote: Optional[str] = None,\n                 escapechar: Optional[str] = None,\n",
        "source_code_len": 293,
        "target_code": "class Dialect(csv.Dialect):\n    \"\"\" A simple Dialect class\n\n    This dialect class includes has_header and minimal defaulting that make it work\n    better for this application - where we want to pass around csv info, not define\n    reusable dialects.\n    \"\"\"\n    def __init__(self,\n                 delimiter: Optional[str],\n                 has_header: Optional[bool],\n                 quoting: Optional[int],\n                 quotechar: Optional[str] = None,\n                 doublequote: Optional[bool] = None,\n                 escapechar: Optional[str] = None,\n",
        "target_code_len": 565,
        "diff_format": "@@ -48,8 +52,14 @@\n class Dialect(csv.Dialect):\n+    \"\"\" A simple Dialect class\n+\n+    This dialect class includes has_header and minimal defaulting that make it work\n+    better for this application - where we want to pass around csv info, not define\n+    reusable dialects.\n+    \"\"\"\n     def __init__(self,\n-                 delimiter: str,\n-                 has_header: bool,\n-                 quoting: int,\n-                 quotechar: str = None,\n-                 doublequote: Optional[str] = None,\n+                 delimiter: Optional[str],\n+                 has_header: Optional[bool],\n+                 quoting: Optional[int],\n+                 quotechar: Optional[str] = None,\n+                 doublequote: Optional[bool] = None,\n                  escapechar: Optional[str] = None,\n",
        "source_code_with_indent": "<DED><DED>class Dialect(csv.Dialect):\n    <IND>def __init__(self,\n                 delimiter: str,\n                 has_header: bool,\n                 quoting: int,\n                 quotechar: str = None,\n                 doublequote: Optional[str] = None,\n                 escapechar: Optional[str] = None,\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "<DED><DED>class Dialect(csv.Dialect):\n    <IND>\"\"\" A simple Dialect class\n\n    This dialect class includes has_header and minimal defaulting that make it work\n    better for this application - where we want to pass around csv info, not define\n    reusable dialects.\n    \"\"\"\n    def __init__(self,\n                 delimiter: Optional[str],\n                 has_header: Optional[bool],\n                 quoting: Optional[int],\n                 quotechar: Optional[str] = None,\n                 doublequote: Optional[bool] = None,\n                 escapechar: Optional[str] = None,\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    if quoting is not None:\n        dialect.quoting = quoting\n    if quotechar is not None:\n",
        "source_code_len": 92,
        "target_code": "    if quoting is not None:\n        dialect.quoting = get_quote_number(quoting)\n    if quotechar is not None:\n",
        "target_code_len": 110,
        "diff_format": "@@ -169,3 +189,3 @@\n     if quoting is not None:\n-        dialect.quoting = quoting\n+        dialect.quoting = get_quote_number(quoting)\n     if quotechar is not None:\n",
        "source_code_with_indent": "    <DED>if quoting is not None:\n        <IND>dialect.quoting = quoting\n    <DED>if quotechar is not None:\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    <DED>if quoting is not None:\n        <IND>dialect.quoting = get_quote_number(quoting)\n    <DED>if quotechar is not None:\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    if dialect.quoting is None:\n        dialect.quoting = quoting\n    if dialect.quotechar is None:\n",
        "source_code_len": 100,
        "target_code": "    if dialect.quoting is None:\n        dialect.quoting = get_quote_number(quoting)\n    if dialect.quotechar is None:\n",
        "target_code_len": 118,
        "diff_format": "@@ -213,3 +233,3 @@\n     if dialect.quoting is None:\n-        dialect.quoting = quoting\n+        dialect.quoting = get_quote_number(quoting)\n     if dialect.quotechar is None:\n",
        "source_code_with_indent": "    <DED>if dialect.quoting is None:\n        <IND>dialect.quoting = quoting\n    <DED>if dialect.quotechar is None:\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    <DED>if dialect.quoting is None:\n        <IND>dialect.quoting = get_quote_number(quoting)\n    <DED>if dialect.quotechar is None:\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    #total_field_cnt  = collections.defaultdict(int)\n    total_field_cnt: Dict[int, int] = {}\n\n",
        "source_code_len": 95,
        "target_code": "    #total_field_cnt  = collections.defaultdict(int)\n    total_field_cnt: Dict[Any, Union[int, float]] = {}\n\n",
        "target_code_len": 109,
        "diff_format": "@@ -302,3 +323,3 @@\n     #total_field_cnt  = collections.defaultdict(int)\n-    total_field_cnt: Dict[int, int] = {}\n+    total_field_cnt: Dict[Any, Union[int, float]] = {}\n \n",
        "source_code_with_indent": "    #total_field_cnt  = collections.defaultdict(int)\n    total_field_cnt: Dict[int, int] = {}\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    #total_field_cnt  = collections.defaultdict(int)\n    total_field_cnt: Dict[Any, Union[int, float]] = {}\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    #quoted_field_cnt = collections.defaultdict(int)\n    quoted_field_cnt: Dict[int, int] = {}\n\n",
        "source_code_len": 96,
        "target_code": "    #quoted_field_cnt = collections.defaultdict(int)\n    quoted_field_cnt: Dict[Any, Union[int, float]] = {}\n\n",
        "target_code_len": 110,
        "diff_format": "@@ -308,3 +329,3 @@\n     #quoted_field_cnt = collections.defaultdict(int)\n-    quoted_field_cnt: Dict[int, int] = {}\n+    quoted_field_cnt: Dict[Any, Union[int, float]] = {}\n \n",
        "source_code_with_indent": "    #quoted_field_cnt = collections.defaultdict(int)\n    quoted_field_cnt: Dict[int, int] = {}\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    #quoted_field_cnt = collections.defaultdict(int)\n    quoted_field_cnt: Dict[Any, Union[int, float]] = {}\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "kenfar/DataGristle",
    "commit": "c85be697bb673eb3181cab4ba1ca84ea198db2bb",
    "filename": "datagristle/csvhelper.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/kenfar-DataGristle/datagristle/csvhelper.py",
    "file_hunks_size": 18,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "datagristle/csvhelper.py:178:8 Incompatible attribute type [8]: Attribute `doublequote` declared in class `Dialect` has type `Optional[str]` but is used as type `bool`.",
    "message": " Attribute `doublequote` declared in class `Dialect` has type `Optional[str]` but is used as type `bool`.",
    "rule_id": "Incompatible attribute type [8]",
    "warning_line_no": 178,
    "warning_line": "        dialect.doublequote = True",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "from pprint import pprint as pp\nfrom typing import Optional, List, Dict\nimport _csv\n",
        "source_code_len": 84,
        "target_code": "from pprint import pprint as pp\nfrom typing import Optional, List, Dict, Any, Union, Type\nimport _csv\n",
        "target_code_len": 102,
        "diff_format": "@@ -11,3 +11,3 @@\n from pprint import pprint as pp\n-from typing import Optional, List, Dict\n+from typing import Optional, List, Dict, Any, Union, Type\n import _csv\n",
        "source_code_with_indent": "from pprint import pprint as pp\nfrom typing import Optional, List, Dict\nimport _csv\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "from pprint import pprint as pp\nfrom typing import Optional, List, Dict, Any, Union, Type\nimport _csv\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "class Dialect(csv.Dialect):\n    def __init__(self,\n                 delimiter: str,\n                 has_header: bool,\n                 quoting: int,\n                 quotechar: str = None,\n                 doublequote: Optional[str] = None,\n                 escapechar: Optional[str] = None,\n",
        "source_code_len": 293,
        "target_code": "class Dialect(csv.Dialect):\n    \"\"\" A simple Dialect class\n\n    This dialect class includes has_header and minimal defaulting that make it work\n    better for this application - where we want to pass around csv info, not define\n    reusable dialects.\n    \"\"\"\n    def __init__(self,\n                 delimiter: Optional[str],\n                 has_header: Optional[bool],\n                 quoting: Optional[int],\n                 quotechar: Optional[str] = None,\n                 doublequote: Optional[bool] = None,\n                 escapechar: Optional[str] = None,\n",
        "target_code_len": 565,
        "diff_format": "@@ -48,8 +52,14 @@\n class Dialect(csv.Dialect):\n+    \"\"\" A simple Dialect class\n+\n+    This dialect class includes has_header and minimal defaulting that make it work\n+    better for this application - where we want to pass around csv info, not define\n+    reusable dialects.\n+    \"\"\"\n     def __init__(self,\n-                 delimiter: str,\n-                 has_header: bool,\n-                 quoting: int,\n-                 quotechar: str = None,\n-                 doublequote: Optional[str] = None,\n+                 delimiter: Optional[str],\n+                 has_header: Optional[bool],\n+                 quoting: Optional[int],\n+                 quotechar: Optional[str] = None,\n+                 doublequote: Optional[bool] = None,\n                  escapechar: Optional[str] = None,\n",
        "source_code_with_indent": "<DED><DED>class Dialect(csv.Dialect):\n    <IND>def __init__(self,\n                 delimiter: str,\n                 has_header: bool,\n                 quoting: int,\n                 quotechar: str = None,\n                 doublequote: Optional[str] = None,\n                 escapechar: Optional[str] = None,\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "<DED><DED>class Dialect(csv.Dialect):\n    <IND>\"\"\" A simple Dialect class\n\n    This dialect class includes has_header and minimal defaulting that make it work\n    better for this application - where we want to pass around csv info, not define\n    reusable dialects.\n    \"\"\"\n    def __init__(self,\n                 delimiter: Optional[str],\n                 has_header: Optional[bool],\n                 quoting: Optional[int],\n                 quotechar: Optional[str] = None,\n                 doublequote: Optional[bool] = None,\n                 escapechar: Optional[str] = None,\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    if quoting is not None:\n        dialect.quoting = quoting\n    if quotechar is not None:\n",
        "source_code_len": 92,
        "target_code": "    if quoting is not None:\n        dialect.quoting = get_quote_number(quoting)\n    if quotechar is not None:\n",
        "target_code_len": 110,
        "diff_format": "@@ -169,3 +189,3 @@\n     if quoting is not None:\n-        dialect.quoting = quoting\n+        dialect.quoting = get_quote_number(quoting)\n     if quotechar is not None:\n",
        "source_code_with_indent": "    <DED>if quoting is not None:\n        <IND>dialect.quoting = quoting\n    <DED>if quotechar is not None:\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    <DED>if quoting is not None:\n        <IND>dialect.quoting = get_quote_number(quoting)\n    <DED>if quotechar is not None:\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    if dialect.quoting is None:\n        dialect.quoting = quoting\n    if dialect.quotechar is None:\n",
        "source_code_len": 100,
        "target_code": "    if dialect.quoting is None:\n        dialect.quoting = get_quote_number(quoting)\n    if dialect.quotechar is None:\n",
        "target_code_len": 118,
        "diff_format": "@@ -213,3 +233,3 @@\n     if dialect.quoting is None:\n-        dialect.quoting = quoting\n+        dialect.quoting = get_quote_number(quoting)\n     if dialect.quotechar is None:\n",
        "source_code_with_indent": "    <DED>if dialect.quoting is None:\n        <IND>dialect.quoting = quoting\n    <DED>if dialect.quotechar is None:\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    <DED>if dialect.quoting is None:\n        <IND>dialect.quoting = get_quote_number(quoting)\n    <DED>if dialect.quotechar is None:\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    #total_field_cnt  = collections.defaultdict(int)\n    total_field_cnt: Dict[int, int] = {}\n\n",
        "source_code_len": 95,
        "target_code": "    #total_field_cnt  = collections.defaultdict(int)\n    total_field_cnt: Dict[Any, Union[int, float]] = {}\n\n",
        "target_code_len": 109,
        "diff_format": "@@ -302,3 +323,3 @@\n     #total_field_cnt  = collections.defaultdict(int)\n-    total_field_cnt: Dict[int, int] = {}\n+    total_field_cnt: Dict[Any, Union[int, float]] = {}\n \n",
        "source_code_with_indent": "    #total_field_cnt  = collections.defaultdict(int)\n    total_field_cnt: Dict[int, int] = {}\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    #total_field_cnt  = collections.defaultdict(int)\n    total_field_cnt: Dict[Any, Union[int, float]] = {}\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    #quoted_field_cnt = collections.defaultdict(int)\n    quoted_field_cnt: Dict[int, int] = {}\n\n",
        "source_code_len": 96,
        "target_code": "    #quoted_field_cnt = collections.defaultdict(int)\n    quoted_field_cnt: Dict[Any, Union[int, float]] = {}\n\n",
        "target_code_len": 110,
        "diff_format": "@@ -308,3 +329,3 @@\n     #quoted_field_cnt = collections.defaultdict(int)\n-    quoted_field_cnt: Dict[int, int] = {}\n+    quoted_field_cnt: Dict[Any, Union[int, float]] = {}\n \n",
        "source_code_with_indent": "    #quoted_field_cnt = collections.defaultdict(int)\n    quoted_field_cnt: Dict[int, int] = {}\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    #quoted_field_cnt = collections.defaultdict(int)\n    quoted_field_cnt: Dict[Any, Union[int, float]] = {}\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "kenfar/DataGristle",
    "commit": "c85be697bb673eb3181cab4ba1ca84ea198db2bb",
    "filename": "datagristle/csvhelper.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/kenfar-DataGristle/datagristle/csvhelper.py",
    "file_hunks_size": 18,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "datagristle/csvhelper.py:181:8 Incompatible attribute type [8]: Attribute `doublequote` declared in class `Dialect` has type `Optional[str]` but is used as type `bool`.",
    "message": " Attribute `doublequote` declared in class `Dialect` has type `Optional[str]` but is used as type `bool`.",
    "rule_id": "Incompatible attribute type [8]",
    "warning_line_no": 181,
    "warning_line": "        dialect.doublequote = False",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "from pprint import pprint as pp\nfrom typing import Optional, List, Dict\nimport _csv\n",
        "source_code_len": 84,
        "target_code": "from pprint import pprint as pp\nfrom typing import Optional, List, Dict, Any, Union, Type\nimport _csv\n",
        "target_code_len": 102,
        "diff_format": "@@ -11,3 +11,3 @@\n from pprint import pprint as pp\n-from typing import Optional, List, Dict\n+from typing import Optional, List, Dict, Any, Union, Type\n import _csv\n",
        "source_code_with_indent": "from pprint import pprint as pp\nfrom typing import Optional, List, Dict\nimport _csv\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "from pprint import pprint as pp\nfrom typing import Optional, List, Dict, Any, Union, Type\nimport _csv\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "class Dialect(csv.Dialect):\n    def __init__(self,\n                 delimiter: str,\n                 has_header: bool,\n                 quoting: int,\n                 quotechar: str = None,\n                 doublequote: Optional[str] = None,\n                 escapechar: Optional[str] = None,\n",
        "source_code_len": 293,
        "target_code": "class Dialect(csv.Dialect):\n    \"\"\" A simple Dialect class\n\n    This dialect class includes has_header and minimal defaulting that make it work\n    better for this application - where we want to pass around csv info, not define\n    reusable dialects.\n    \"\"\"\n    def __init__(self,\n                 delimiter: Optional[str],\n                 has_header: Optional[bool],\n                 quoting: Optional[int],\n                 quotechar: Optional[str] = None,\n                 doublequote: Optional[bool] = None,\n                 escapechar: Optional[str] = None,\n",
        "target_code_len": 565,
        "diff_format": "@@ -48,8 +52,14 @@\n class Dialect(csv.Dialect):\n+    \"\"\" A simple Dialect class\n+\n+    This dialect class includes has_header and minimal defaulting that make it work\n+    better for this application - where we want to pass around csv info, not define\n+    reusable dialects.\n+    \"\"\"\n     def __init__(self,\n-                 delimiter: str,\n-                 has_header: bool,\n-                 quoting: int,\n-                 quotechar: str = None,\n-                 doublequote: Optional[str] = None,\n+                 delimiter: Optional[str],\n+                 has_header: Optional[bool],\n+                 quoting: Optional[int],\n+                 quotechar: Optional[str] = None,\n+                 doublequote: Optional[bool] = None,\n                  escapechar: Optional[str] = None,\n",
        "source_code_with_indent": "<DED><DED>class Dialect(csv.Dialect):\n    <IND>def __init__(self,\n                 delimiter: str,\n                 has_header: bool,\n                 quoting: int,\n                 quotechar: str = None,\n                 doublequote: Optional[str] = None,\n                 escapechar: Optional[str] = None,\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "<DED><DED>class Dialect(csv.Dialect):\n    <IND>\"\"\" A simple Dialect class\n\n    This dialect class includes has_header and minimal defaulting that make it work\n    better for this application - where we want to pass around csv info, not define\n    reusable dialects.\n    \"\"\"\n    def __init__(self,\n                 delimiter: Optional[str],\n                 has_header: Optional[bool],\n                 quoting: Optional[int],\n                 quotechar: Optional[str] = None,\n                 doublequote: Optional[bool] = None,\n                 escapechar: Optional[str] = None,\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    if quoting is not None:\n        dialect.quoting = quoting\n    if quotechar is not None:\n",
        "source_code_len": 92,
        "target_code": "    if quoting is not None:\n        dialect.quoting = get_quote_number(quoting)\n    if quotechar is not None:\n",
        "target_code_len": 110,
        "diff_format": "@@ -169,3 +189,3 @@\n     if quoting is not None:\n-        dialect.quoting = quoting\n+        dialect.quoting = get_quote_number(quoting)\n     if quotechar is not None:\n",
        "source_code_with_indent": "    <DED>if quoting is not None:\n        <IND>dialect.quoting = quoting\n    <DED>if quotechar is not None:\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    <DED>if quoting is not None:\n        <IND>dialect.quoting = get_quote_number(quoting)\n    <DED>if quotechar is not None:\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    if dialect.quoting is None:\n        dialect.quoting = quoting\n    if dialect.quotechar is None:\n",
        "source_code_len": 100,
        "target_code": "    if dialect.quoting is None:\n        dialect.quoting = get_quote_number(quoting)\n    if dialect.quotechar is None:\n",
        "target_code_len": 118,
        "diff_format": "@@ -213,3 +233,3 @@\n     if dialect.quoting is None:\n-        dialect.quoting = quoting\n+        dialect.quoting = get_quote_number(quoting)\n     if dialect.quotechar is None:\n",
        "source_code_with_indent": "    <DED>if dialect.quoting is None:\n        <IND>dialect.quoting = quoting\n    <DED>if dialect.quotechar is None:\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    <DED>if dialect.quoting is None:\n        <IND>dialect.quoting = get_quote_number(quoting)\n    <DED>if dialect.quotechar is None:\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    #total_field_cnt  = collections.defaultdict(int)\n    total_field_cnt: Dict[int, int] = {}\n\n",
        "source_code_len": 95,
        "target_code": "    #total_field_cnt  = collections.defaultdict(int)\n    total_field_cnt: Dict[Any, Union[int, float]] = {}\n\n",
        "target_code_len": 109,
        "diff_format": "@@ -302,3 +323,3 @@\n     #total_field_cnt  = collections.defaultdict(int)\n-    total_field_cnt: Dict[int, int] = {}\n+    total_field_cnt: Dict[Any, Union[int, float]] = {}\n \n",
        "source_code_with_indent": "    #total_field_cnt  = collections.defaultdict(int)\n    total_field_cnt: Dict[int, int] = {}\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    #total_field_cnt  = collections.defaultdict(int)\n    total_field_cnt: Dict[Any, Union[int, float]] = {}\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    #quoted_field_cnt = collections.defaultdict(int)\n    quoted_field_cnt: Dict[int, int] = {}\n\n",
        "source_code_len": 96,
        "target_code": "    #quoted_field_cnt = collections.defaultdict(int)\n    quoted_field_cnt: Dict[Any, Union[int, float]] = {}\n\n",
        "target_code_len": 110,
        "diff_format": "@@ -308,3 +329,3 @@\n     #quoted_field_cnt = collections.defaultdict(int)\n-    quoted_field_cnt: Dict[int, int] = {}\n+    quoted_field_cnt: Dict[Any, Union[int, float]] = {}\n \n",
        "source_code_with_indent": "    #quoted_field_cnt = collections.defaultdict(int)\n    quoted_field_cnt: Dict[int, int] = {}\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    #quoted_field_cnt = collections.defaultdict(int)\n    quoted_field_cnt: Dict[Any, Union[int, float]] = {}\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "kenfar/DataGristle",
    "commit": "c85be697bb673eb3181cab4ba1ca84ea198db2bb",
    "filename": "datagristle/csvhelper.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/kenfar-DataGristle/datagristle/csvhelper.py",
    "file_hunks_size": 18,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "datagristle/csvhelper.py:185:8 Incompatible attribute type [8]: Attribute `doublequote` declared in class `Dialect` has type `Optional[str]` but is used as type `bool`.",
    "message": " Attribute `doublequote` declared in class `Dialect` has type `Optional[str]` but is used as type `bool`.",
    "rule_id": "Incompatible attribute type [8]",
    "warning_line_no": 185,
    "warning_line": "        dialect.doublequote = False",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "from pprint import pprint as pp\nfrom typing import Optional, List, Dict\nimport _csv\n",
        "source_code_len": 84,
        "target_code": "from pprint import pprint as pp\nfrom typing import Optional, List, Dict, Any, Union, Type\nimport _csv\n",
        "target_code_len": 102,
        "diff_format": "@@ -11,3 +11,3 @@\n from pprint import pprint as pp\n-from typing import Optional, List, Dict\n+from typing import Optional, List, Dict, Any, Union, Type\n import _csv\n",
        "source_code_with_indent": "from pprint import pprint as pp\nfrom typing import Optional, List, Dict\nimport _csv\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "from pprint import pprint as pp\nfrom typing import Optional, List, Dict, Any, Union, Type\nimport _csv\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "class Dialect(csv.Dialect):\n    def __init__(self,\n                 delimiter: str,\n                 has_header: bool,\n                 quoting: int,\n                 quotechar: str = None,\n                 doublequote: Optional[str] = None,\n                 escapechar: Optional[str] = None,\n",
        "source_code_len": 293,
        "target_code": "class Dialect(csv.Dialect):\n    \"\"\" A simple Dialect class\n\n    This dialect class includes has_header and minimal defaulting that make it work\n    better for this application - where we want to pass around csv info, not define\n    reusable dialects.\n    \"\"\"\n    def __init__(self,\n                 delimiter: Optional[str],\n                 has_header: Optional[bool],\n                 quoting: Optional[int],\n                 quotechar: Optional[str] = None,\n                 doublequote: Optional[bool] = None,\n                 escapechar: Optional[str] = None,\n",
        "target_code_len": 565,
        "diff_format": "@@ -48,8 +52,14 @@\n class Dialect(csv.Dialect):\n+    \"\"\" A simple Dialect class\n+\n+    This dialect class includes has_header and minimal defaulting that make it work\n+    better for this application - where we want to pass around csv info, not define\n+    reusable dialects.\n+    \"\"\"\n     def __init__(self,\n-                 delimiter: str,\n-                 has_header: bool,\n-                 quoting: int,\n-                 quotechar: str = None,\n-                 doublequote: Optional[str] = None,\n+                 delimiter: Optional[str],\n+                 has_header: Optional[bool],\n+                 quoting: Optional[int],\n+                 quotechar: Optional[str] = None,\n+                 doublequote: Optional[bool] = None,\n                  escapechar: Optional[str] = None,\n",
        "source_code_with_indent": "<DED><DED>class Dialect(csv.Dialect):\n    <IND>def __init__(self,\n                 delimiter: str,\n                 has_header: bool,\n                 quoting: int,\n                 quotechar: str = None,\n                 doublequote: Optional[str] = None,\n                 escapechar: Optional[str] = None,\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "<DED><DED>class Dialect(csv.Dialect):\n    <IND>\"\"\" A simple Dialect class\n\n    This dialect class includes has_header and minimal defaulting that make it work\n    better for this application - where we want to pass around csv info, not define\n    reusable dialects.\n    \"\"\"\n    def __init__(self,\n                 delimiter: Optional[str],\n                 has_header: Optional[bool],\n                 quoting: Optional[int],\n                 quotechar: Optional[str] = None,\n                 doublequote: Optional[bool] = None,\n                 escapechar: Optional[str] = None,\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    if quoting is not None:\n        dialect.quoting = quoting\n    if quotechar is not None:\n",
        "source_code_len": 92,
        "target_code": "    if quoting is not None:\n        dialect.quoting = get_quote_number(quoting)\n    if quotechar is not None:\n",
        "target_code_len": 110,
        "diff_format": "@@ -169,3 +189,3 @@\n     if quoting is not None:\n-        dialect.quoting = quoting\n+        dialect.quoting = get_quote_number(quoting)\n     if quotechar is not None:\n",
        "source_code_with_indent": "    <DED>if quoting is not None:\n        <IND>dialect.quoting = quoting\n    <DED>if quotechar is not None:\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    <DED>if quoting is not None:\n        <IND>dialect.quoting = get_quote_number(quoting)\n    <DED>if quotechar is not None:\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    if dialect.quoting is None:\n        dialect.quoting = quoting\n    if dialect.quotechar is None:\n",
        "source_code_len": 100,
        "target_code": "    if dialect.quoting is None:\n        dialect.quoting = get_quote_number(quoting)\n    if dialect.quotechar is None:\n",
        "target_code_len": 118,
        "diff_format": "@@ -213,3 +233,3 @@\n     if dialect.quoting is None:\n-        dialect.quoting = quoting\n+        dialect.quoting = get_quote_number(quoting)\n     if dialect.quotechar is None:\n",
        "source_code_with_indent": "    <DED>if dialect.quoting is None:\n        <IND>dialect.quoting = quoting\n    <DED>if dialect.quotechar is None:\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    <DED>if dialect.quoting is None:\n        <IND>dialect.quoting = get_quote_number(quoting)\n    <DED>if dialect.quotechar is None:\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    #total_field_cnt  = collections.defaultdict(int)\n    total_field_cnt: Dict[int, int] = {}\n\n",
        "source_code_len": 95,
        "target_code": "    #total_field_cnt  = collections.defaultdict(int)\n    total_field_cnt: Dict[Any, Union[int, float]] = {}\n\n",
        "target_code_len": 109,
        "diff_format": "@@ -302,3 +323,3 @@\n     #total_field_cnt  = collections.defaultdict(int)\n-    total_field_cnt: Dict[int, int] = {}\n+    total_field_cnt: Dict[Any, Union[int, float]] = {}\n \n",
        "source_code_with_indent": "    #total_field_cnt  = collections.defaultdict(int)\n    total_field_cnt: Dict[int, int] = {}\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    #total_field_cnt  = collections.defaultdict(int)\n    total_field_cnt: Dict[Any, Union[int, float]] = {}\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    #quoted_field_cnt = collections.defaultdict(int)\n    quoted_field_cnt: Dict[int, int] = {}\n\n",
        "source_code_len": 96,
        "target_code": "    #quoted_field_cnt = collections.defaultdict(int)\n    quoted_field_cnt: Dict[Any, Union[int, float]] = {}\n\n",
        "target_code_len": 110,
        "diff_format": "@@ -308,3 +329,3 @@\n     #quoted_field_cnt = collections.defaultdict(int)\n-    quoted_field_cnt: Dict[int, int] = {}\n+    quoted_field_cnt: Dict[Any, Union[int, float]] = {}\n \n",
        "source_code_with_indent": "    #quoted_field_cnt = collections.defaultdict(int)\n    quoted_field_cnt: Dict[int, int] = {}\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    #quoted_field_cnt = collections.defaultdict(int)\n    quoted_field_cnt: Dict[Any, Union[int, float]] = {}\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "kenfar/DataGristle",
    "commit": "c85be697bb673eb3181cab4ba1ca84ea198db2bb",
    "filename": "datagristle/csvhelper.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/kenfar-DataGristle/datagristle/csvhelper.py",
    "file_hunks_size": 18,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "datagristle/csvhelper.py:190:8 Incompatible attribute type [8]: Attribute `doublequote` declared in class `Dialect` has type `Optional[str]` but is used as type `bool`.",
    "message": " Attribute `doublequote` declared in class `Dialect` has type `Optional[str]` but is used as type `bool`.",
    "rule_id": "Incompatible attribute type [8]",
    "warning_line_no": 190,
    "warning_line": "        dialect.doublequote = True",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "from pprint import pprint as pp\nfrom typing import Optional, List, Dict\nimport _csv\n",
        "source_code_len": 84,
        "target_code": "from pprint import pprint as pp\nfrom typing import Optional, List, Dict, Any, Union, Type\nimport _csv\n",
        "target_code_len": 102,
        "diff_format": "@@ -11,3 +11,3 @@\n from pprint import pprint as pp\n-from typing import Optional, List, Dict\n+from typing import Optional, List, Dict, Any, Union, Type\n import _csv\n",
        "source_code_with_indent": "from pprint import pprint as pp\nfrom typing import Optional, List, Dict\nimport _csv\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "from pprint import pprint as pp\nfrom typing import Optional, List, Dict, Any, Union, Type\nimport _csv\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "class Dialect(csv.Dialect):\n    def __init__(self,\n                 delimiter: str,\n                 has_header: bool,\n                 quoting: int,\n                 quotechar: str = None,\n                 doublequote: Optional[str] = None,\n                 escapechar: Optional[str] = None,\n",
        "source_code_len": 293,
        "target_code": "class Dialect(csv.Dialect):\n    \"\"\" A simple Dialect class\n\n    This dialect class includes has_header and minimal defaulting that make it work\n    better for this application - where we want to pass around csv info, not define\n    reusable dialects.\n    \"\"\"\n    def __init__(self,\n                 delimiter: Optional[str],\n                 has_header: Optional[bool],\n                 quoting: Optional[int],\n                 quotechar: Optional[str] = None,\n                 doublequote: Optional[bool] = None,\n                 escapechar: Optional[str] = None,\n",
        "target_code_len": 565,
        "diff_format": "@@ -48,8 +52,14 @@\n class Dialect(csv.Dialect):\n+    \"\"\" A simple Dialect class\n+\n+    This dialect class includes has_header and minimal defaulting that make it work\n+    better for this application - where we want to pass around csv info, not define\n+    reusable dialects.\n+    \"\"\"\n     def __init__(self,\n-                 delimiter: str,\n-                 has_header: bool,\n-                 quoting: int,\n-                 quotechar: str = None,\n-                 doublequote: Optional[str] = None,\n+                 delimiter: Optional[str],\n+                 has_header: Optional[bool],\n+                 quoting: Optional[int],\n+                 quotechar: Optional[str] = None,\n+                 doublequote: Optional[bool] = None,\n                  escapechar: Optional[str] = None,\n",
        "source_code_with_indent": "<DED><DED>class Dialect(csv.Dialect):\n    <IND>def __init__(self,\n                 delimiter: str,\n                 has_header: bool,\n                 quoting: int,\n                 quotechar: str = None,\n                 doublequote: Optional[str] = None,\n                 escapechar: Optional[str] = None,\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "<DED><DED>class Dialect(csv.Dialect):\n    <IND>\"\"\" A simple Dialect class\n\n    This dialect class includes has_header and minimal defaulting that make it work\n    better for this application - where we want to pass around csv info, not define\n    reusable dialects.\n    \"\"\"\n    def __init__(self,\n                 delimiter: Optional[str],\n                 has_header: Optional[bool],\n                 quoting: Optional[int],\n                 quotechar: Optional[str] = None,\n                 doublequote: Optional[bool] = None,\n                 escapechar: Optional[str] = None,\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    if quoting is not None:\n        dialect.quoting = quoting\n    if quotechar is not None:\n",
        "source_code_len": 92,
        "target_code": "    if quoting is not None:\n        dialect.quoting = get_quote_number(quoting)\n    if quotechar is not None:\n",
        "target_code_len": 110,
        "diff_format": "@@ -169,3 +189,3 @@\n     if quoting is not None:\n-        dialect.quoting = quoting\n+        dialect.quoting = get_quote_number(quoting)\n     if quotechar is not None:\n",
        "source_code_with_indent": "    <DED>if quoting is not None:\n        <IND>dialect.quoting = quoting\n    <DED>if quotechar is not None:\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    <DED>if quoting is not None:\n        <IND>dialect.quoting = get_quote_number(quoting)\n    <DED>if quotechar is not None:\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    if dialect.quoting is None:\n        dialect.quoting = quoting\n    if dialect.quotechar is None:\n",
        "source_code_len": 100,
        "target_code": "    if dialect.quoting is None:\n        dialect.quoting = get_quote_number(quoting)\n    if dialect.quotechar is None:\n",
        "target_code_len": 118,
        "diff_format": "@@ -213,3 +233,3 @@\n     if dialect.quoting is None:\n-        dialect.quoting = quoting\n+        dialect.quoting = get_quote_number(quoting)\n     if dialect.quotechar is None:\n",
        "source_code_with_indent": "    <DED>if dialect.quoting is None:\n        <IND>dialect.quoting = quoting\n    <DED>if dialect.quotechar is None:\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    <DED>if dialect.quoting is None:\n        <IND>dialect.quoting = get_quote_number(quoting)\n    <DED>if dialect.quotechar is None:\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    #total_field_cnt  = collections.defaultdict(int)\n    total_field_cnt: Dict[int, int] = {}\n\n",
        "source_code_len": 95,
        "target_code": "    #total_field_cnt  = collections.defaultdict(int)\n    total_field_cnt: Dict[Any, Union[int, float]] = {}\n\n",
        "target_code_len": 109,
        "diff_format": "@@ -302,3 +323,3 @@\n     #total_field_cnt  = collections.defaultdict(int)\n-    total_field_cnt: Dict[int, int] = {}\n+    total_field_cnt: Dict[Any, Union[int, float]] = {}\n \n",
        "source_code_with_indent": "    #total_field_cnt  = collections.defaultdict(int)\n    total_field_cnt: Dict[int, int] = {}\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    #total_field_cnt  = collections.defaultdict(int)\n    total_field_cnt: Dict[Any, Union[int, float]] = {}\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    #quoted_field_cnt = collections.defaultdict(int)\n    quoted_field_cnt: Dict[int, int] = {}\n\n",
        "source_code_len": 96,
        "target_code": "    #quoted_field_cnt = collections.defaultdict(int)\n    quoted_field_cnt: Dict[Any, Union[int, float]] = {}\n\n",
        "target_code_len": 110,
        "diff_format": "@@ -308,3 +329,3 @@\n     #quoted_field_cnt = collections.defaultdict(int)\n-    quoted_field_cnt: Dict[int, int] = {}\n+    quoted_field_cnt: Dict[Any, Union[int, float]] = {}\n \n",
        "source_code_with_indent": "    #quoted_field_cnt = collections.defaultdict(int)\n    quoted_field_cnt: Dict[int, int] = {}\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    #quoted_field_cnt = collections.defaultdict(int)\n    quoted_field_cnt: Dict[Any, Union[int, float]] = {}\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "kenfar/DataGristle",
    "commit": "c85be697bb673eb3181cab4ba1ca84ea198db2bb",
    "filename": "datagristle/csvhelper.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/kenfar-DataGristle/datagristle/csvhelper.py",
    "file_hunks_size": 18,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "datagristle/csvhelper.py:212:8 Incompatible attribute type [8]: Attribute `delimiter` declared in class `Dialect` has type `str` but is used as type `Optional[str]`.",
    "message": " Attribute `delimiter` declared in class `Dialect` has type `str` but is used as type `Optional[str]`.",
    "rule_id": "Incompatible attribute type [8]",
    "warning_line_no": 212,
    "warning_line": "        dialect.delimiter = delimiter",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "from pprint import pprint as pp\nfrom typing import Optional, List, Dict\nimport _csv\n",
        "source_code_len": 84,
        "target_code": "from pprint import pprint as pp\nfrom typing import Optional, List, Dict, Any, Union, Type\nimport _csv\n",
        "target_code_len": 102,
        "diff_format": "@@ -11,3 +11,3 @@\n from pprint import pprint as pp\n-from typing import Optional, List, Dict\n+from typing import Optional, List, Dict, Any, Union, Type\n import _csv\n",
        "source_code_with_indent": "from pprint import pprint as pp\nfrom typing import Optional, List, Dict\nimport _csv\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "from pprint import pprint as pp\nfrom typing import Optional, List, Dict, Any, Union, Type\nimport _csv\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "class Dialect(csv.Dialect):\n    def __init__(self,\n                 delimiter: str,\n                 has_header: bool,\n                 quoting: int,\n                 quotechar: str = None,\n                 doublequote: Optional[str] = None,\n                 escapechar: Optional[str] = None,\n",
        "source_code_len": 293,
        "target_code": "class Dialect(csv.Dialect):\n    \"\"\" A simple Dialect class\n\n    This dialect class includes has_header and minimal defaulting that make it work\n    better for this application - where we want to pass around csv info, not define\n    reusable dialects.\n    \"\"\"\n    def __init__(self,\n                 delimiter: Optional[str],\n                 has_header: Optional[bool],\n                 quoting: Optional[int],\n                 quotechar: Optional[str] = None,\n                 doublequote: Optional[bool] = None,\n                 escapechar: Optional[str] = None,\n",
        "target_code_len": 565,
        "diff_format": "@@ -48,8 +52,14 @@\n class Dialect(csv.Dialect):\n+    \"\"\" A simple Dialect class\n+\n+    This dialect class includes has_header and minimal defaulting that make it work\n+    better for this application - where we want to pass around csv info, not define\n+    reusable dialects.\n+    \"\"\"\n     def __init__(self,\n-                 delimiter: str,\n-                 has_header: bool,\n-                 quoting: int,\n-                 quotechar: str = None,\n-                 doublequote: Optional[str] = None,\n+                 delimiter: Optional[str],\n+                 has_header: Optional[bool],\n+                 quoting: Optional[int],\n+                 quotechar: Optional[str] = None,\n+                 doublequote: Optional[bool] = None,\n                  escapechar: Optional[str] = None,\n",
        "source_code_with_indent": "<DED><DED>class Dialect(csv.Dialect):\n    <IND>def __init__(self,\n                 delimiter: str,\n                 has_header: bool,\n                 quoting: int,\n                 quotechar: str = None,\n                 doublequote: Optional[str] = None,\n                 escapechar: Optional[str] = None,\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "<DED><DED>class Dialect(csv.Dialect):\n    <IND>\"\"\" A simple Dialect class\n\n    This dialect class includes has_header and minimal defaulting that make it work\n    better for this application - where we want to pass around csv info, not define\n    reusable dialects.\n    \"\"\"\n    def __init__(self,\n                 delimiter: Optional[str],\n                 has_header: Optional[bool],\n                 quoting: Optional[int],\n                 quotechar: Optional[str] = None,\n                 doublequote: Optional[bool] = None,\n                 escapechar: Optional[str] = None,\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    if quoting is not None:\n        dialect.quoting = quoting\n    if quotechar is not None:\n",
        "source_code_len": 92,
        "target_code": "    if quoting is not None:\n        dialect.quoting = get_quote_number(quoting)\n    if quotechar is not None:\n",
        "target_code_len": 110,
        "diff_format": "@@ -169,3 +189,3 @@\n     if quoting is not None:\n-        dialect.quoting = quoting\n+        dialect.quoting = get_quote_number(quoting)\n     if quotechar is not None:\n",
        "source_code_with_indent": "    <DED>if quoting is not None:\n        <IND>dialect.quoting = quoting\n    <DED>if quotechar is not None:\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    <DED>if quoting is not None:\n        <IND>dialect.quoting = get_quote_number(quoting)\n    <DED>if quotechar is not None:\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    if dialect.quoting is None:\n        dialect.quoting = quoting\n    if dialect.quotechar is None:\n",
        "source_code_len": 100,
        "target_code": "    if dialect.quoting is None:\n        dialect.quoting = get_quote_number(quoting)\n    if dialect.quotechar is None:\n",
        "target_code_len": 118,
        "diff_format": "@@ -213,3 +233,3 @@\n     if dialect.quoting is None:\n-        dialect.quoting = quoting\n+        dialect.quoting = get_quote_number(quoting)\n     if dialect.quotechar is None:\n",
        "source_code_with_indent": "    <DED>if dialect.quoting is None:\n        <IND>dialect.quoting = quoting\n    <DED>if dialect.quotechar is None:\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    <DED>if dialect.quoting is None:\n        <IND>dialect.quoting = get_quote_number(quoting)\n    <DED>if dialect.quotechar is None:\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    #total_field_cnt  = collections.defaultdict(int)\n    total_field_cnt: Dict[int, int] = {}\n\n",
        "source_code_len": 95,
        "target_code": "    #total_field_cnt  = collections.defaultdict(int)\n    total_field_cnt: Dict[Any, Union[int, float]] = {}\n\n",
        "target_code_len": 109,
        "diff_format": "@@ -302,3 +323,3 @@\n     #total_field_cnt  = collections.defaultdict(int)\n-    total_field_cnt: Dict[int, int] = {}\n+    total_field_cnt: Dict[Any, Union[int, float]] = {}\n \n",
        "source_code_with_indent": "    #total_field_cnt  = collections.defaultdict(int)\n    total_field_cnt: Dict[int, int] = {}\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    #total_field_cnt  = collections.defaultdict(int)\n    total_field_cnt: Dict[Any, Union[int, float]] = {}\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    #quoted_field_cnt = collections.defaultdict(int)\n    quoted_field_cnt: Dict[int, int] = {}\n\n",
        "source_code_len": 96,
        "target_code": "    #quoted_field_cnt = collections.defaultdict(int)\n    quoted_field_cnt: Dict[Any, Union[int, float]] = {}\n\n",
        "target_code_len": 110,
        "diff_format": "@@ -308,3 +329,3 @@\n     #quoted_field_cnt = collections.defaultdict(int)\n-    quoted_field_cnt: Dict[int, int] = {}\n+    quoted_field_cnt: Dict[Any, Union[int, float]] = {}\n \n",
        "source_code_with_indent": "    #quoted_field_cnt = collections.defaultdict(int)\n    quoted_field_cnt: Dict[int, int] = {}\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    #quoted_field_cnt = collections.defaultdict(int)\n    quoted_field_cnt: Dict[Any, Union[int, float]] = {}\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "kenfar/DataGristle",
    "commit": "c85be697bb673eb3181cab4ba1ca84ea198db2bb",
    "filename": "datagristle/csvhelper.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/kenfar-DataGristle/datagristle/csvhelper.py",
    "file_hunks_size": 18,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "datagristle/csvhelper.py:214:8 Incompatible attribute type [8]: Attribute `quoting` declared in class `Dialect` has type `int` but is used as type `Optional[str]`.",
    "message": " Attribute `quoting` declared in class `Dialect` has type `int` but is used as type `Optional[str]`.",
    "rule_id": "Incompatible attribute type [8]",
    "warning_line_no": 214,
    "warning_line": "        dialect.quoting = quoting",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "from pprint import pprint as pp\nfrom typing import Optional, List, Dict\nimport _csv\n",
        "source_code_len": 84,
        "target_code": "from pprint import pprint as pp\nfrom typing import Optional, List, Dict, Any, Union, Type\nimport _csv\n",
        "target_code_len": 102,
        "diff_format": "@@ -11,3 +11,3 @@\n from pprint import pprint as pp\n-from typing import Optional, List, Dict\n+from typing import Optional, List, Dict, Any, Union, Type\n import _csv\n",
        "source_code_with_indent": "from pprint import pprint as pp\nfrom typing import Optional, List, Dict\nimport _csv\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "from pprint import pprint as pp\nfrom typing import Optional, List, Dict, Any, Union, Type\nimport _csv\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\ndef get_quote_number(quote_name: str) -> int:\n    \"\"\" used to help applications look up quote names typically provided by users.\n",
        "source_code_len": 130,
        "target_code": "\ndef get_quote_number(quote_name: Optional[str]) -> Optional[int]:\n    \"\"\" used to help applications look up quote names typically provided by users.\n",
        "target_code_len": 150,
        "diff_format": "@@ -18,3 +18,3 @@\n \n-def get_quote_number(quote_name: str) -> int:\n+def get_quote_number(quote_name: Optional[str]) -> Optional[int]:\n     \"\"\" used to help applications look up quote names typically provided by users.\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\ndef get_quote_number(quote_name: str) -> int:\n    <IND>",
        "target_code_with_indent": "\ndef get_quote_number(quote_name: Optional[str]) -> Optional[int]:\n    <IND>"
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "class Dialect(csv.Dialect):\n    def __init__(self,\n                 delimiter: str,\n                 has_header: bool,\n                 quoting: int,\n                 quotechar: str = None,\n                 doublequote: Optional[str] = None,\n                 escapechar: Optional[str] = None,\n",
        "source_code_len": 293,
        "target_code": "class Dialect(csv.Dialect):\n    \"\"\" A simple Dialect class\n\n    This dialect class includes has_header and minimal defaulting that make it work\n    better for this application - where we want to pass around csv info, not define\n    reusable dialects.\n    \"\"\"\n    def __init__(self,\n                 delimiter: Optional[str],\n                 has_header: Optional[bool],\n                 quoting: Optional[int],\n                 quotechar: Optional[str] = None,\n                 doublequote: Optional[bool] = None,\n                 escapechar: Optional[str] = None,\n",
        "target_code_len": 565,
        "diff_format": "@@ -48,8 +52,14 @@\n class Dialect(csv.Dialect):\n+    \"\"\" A simple Dialect class\n+\n+    This dialect class includes has_header and minimal defaulting that make it work\n+    better for this application - where we want to pass around csv info, not define\n+    reusable dialects.\n+    \"\"\"\n     def __init__(self,\n-                 delimiter: str,\n-                 has_header: bool,\n-                 quoting: int,\n-                 quotechar: str = None,\n-                 doublequote: Optional[str] = None,\n+                 delimiter: Optional[str],\n+                 has_header: Optional[bool],\n+                 quoting: Optional[int],\n+                 quotechar: Optional[str] = None,\n+                 doublequote: Optional[bool] = None,\n                  escapechar: Optional[str] = None,\n",
        "source_code_with_indent": "<DED><DED>class Dialect(csv.Dialect):\n    <IND>def __init__(self,\n                 delimiter: str,\n                 has_header: bool,\n                 quoting: int,\n                 quotechar: str = None,\n                 doublequote: Optional[str] = None,\n                 escapechar: Optional[str] = None,\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "<DED><DED>class Dialect(csv.Dialect):\n    <IND>\"\"\" A simple Dialect class\n\n    This dialect class includes has_header and minimal defaulting that make it work\n    better for this application - where we want to pass around csv info, not define\n    reusable dialects.\n    \"\"\"\n    def __init__(self,\n                 delimiter: Optional[str],\n                 has_header: Optional[bool],\n                 quoting: Optional[int],\n                 quotechar: Optional[str] = None,\n                 doublequote: Optional[bool] = None,\n                 escapechar: Optional[str] = None,\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    if quoting is not None:\n        dialect.quoting = quoting\n    if quotechar is not None:\n",
        "source_code_len": 92,
        "target_code": "    if quoting is not None:\n        dialect.quoting = get_quote_number(quoting)\n    if quotechar is not None:\n",
        "target_code_len": 110,
        "diff_format": "@@ -169,3 +189,3 @@\n     if quoting is not None:\n-        dialect.quoting = quoting\n+        dialect.quoting = get_quote_number(quoting)\n     if quotechar is not None:\n",
        "source_code_with_indent": "    <DED>if quoting is not None:\n        <IND>dialect.quoting = quoting\n    <DED>if quotechar is not None:\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    <DED>if quoting is not None:\n        <IND>dialect.quoting = get_quote_number(quoting)\n    <DED>if quotechar is not None:\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": true,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    if dialect.quoting is None:\n        dialect.quoting = quoting\n    if dialect.quotechar is None:\n",
        "source_code_len": 100,
        "target_code": "    if dialect.quoting is None:\n        dialect.quoting = get_quote_number(quoting)\n    if dialect.quotechar is None:\n",
        "target_code_len": 118,
        "diff_format": "@@ -213,3 +233,3 @@\n     if dialect.quoting is None:\n-        dialect.quoting = quoting\n+        dialect.quoting = get_quote_number(quoting)\n     if dialect.quotechar is None:\n",
        "source_code_with_indent": "    <DED>if dialect.quoting is None:\n        <IND>dialect.quoting = quoting\n    <DED>if dialect.quotechar is None:\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    <DED>if dialect.quoting is None:\n        <IND>dialect.quoting = get_quote_number(quoting)\n    <DED>if dialect.quotechar is None:\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    #total_field_cnt  = collections.defaultdict(int)\n    total_field_cnt: Dict[int, int] = {}\n\n",
        "source_code_len": 95,
        "target_code": "    #total_field_cnt  = collections.defaultdict(int)\n    total_field_cnt: Dict[Any, Union[int, float]] = {}\n\n",
        "target_code_len": 109,
        "diff_format": "@@ -302,3 +323,3 @@\n     #total_field_cnt  = collections.defaultdict(int)\n-    total_field_cnt: Dict[int, int] = {}\n+    total_field_cnt: Dict[Any, Union[int, float]] = {}\n \n",
        "source_code_with_indent": "    #total_field_cnt  = collections.defaultdict(int)\n    total_field_cnt: Dict[int, int] = {}\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    #total_field_cnt  = collections.defaultdict(int)\n    total_field_cnt: Dict[Any, Union[int, float]] = {}\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    #quoted_field_cnt = collections.defaultdict(int)\n    quoted_field_cnt: Dict[int, int] = {}\n\n",
        "source_code_len": 96,
        "target_code": "    #quoted_field_cnt = collections.defaultdict(int)\n    quoted_field_cnt: Dict[Any, Union[int, float]] = {}\n\n",
        "target_code_len": 110,
        "diff_format": "@@ -308,3 +329,3 @@\n     #quoted_field_cnt = collections.defaultdict(int)\n-    quoted_field_cnt: Dict[int, int] = {}\n+    quoted_field_cnt: Dict[Any, Union[int, float]] = {}\n \n",
        "source_code_with_indent": "    #quoted_field_cnt = collections.defaultdict(int)\n    quoted_field_cnt: Dict[int, int] = {}\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    #quoted_field_cnt = collections.defaultdict(int)\n    quoted_field_cnt: Dict[Any, Union[int, float]] = {}\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "kenfar/DataGristle",
    "commit": "c85be697bb673eb3181cab4ba1ca84ea198db2bb",
    "filename": "datagristle/csvhelper.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/kenfar-DataGristle/datagristle/csvhelper.py",
    "file_hunks_size": 18,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "datagristle/csvhelper.py:216:8 Incompatible attribute type [8]: Attribute `quotechar` declared in class `Dialect` has type `str` but is used as type `Optional[str]`.",
    "message": " Attribute `quotechar` declared in class `Dialect` has type `str` but is used as type `Optional[str]`.",
    "rule_id": "Incompatible attribute type [8]",
    "warning_line_no": 216,
    "warning_line": "        dialect.quotechar = quotechar",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "from pprint import pprint as pp\nfrom typing import Optional, List, Dict\nimport _csv\n",
        "source_code_len": 84,
        "target_code": "from pprint import pprint as pp\nfrom typing import Optional, List, Dict, Any, Union, Type\nimport _csv\n",
        "target_code_len": 102,
        "diff_format": "@@ -11,3 +11,3 @@\n from pprint import pprint as pp\n-from typing import Optional, List, Dict\n+from typing import Optional, List, Dict, Any, Union, Type\n import _csv\n",
        "source_code_with_indent": "from pprint import pprint as pp\nfrom typing import Optional, List, Dict\nimport _csv\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "from pprint import pprint as pp\nfrom typing import Optional, List, Dict, Any, Union, Type\nimport _csv\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "class Dialect(csv.Dialect):\n    def __init__(self,\n                 delimiter: str,\n                 has_header: bool,\n                 quoting: int,\n                 quotechar: str = None,\n                 doublequote: Optional[str] = None,\n                 escapechar: Optional[str] = None,\n",
        "source_code_len": 293,
        "target_code": "class Dialect(csv.Dialect):\n    \"\"\" A simple Dialect class\n\n    This dialect class includes has_header and minimal defaulting that make it work\n    better for this application - where we want to pass around csv info, not define\n    reusable dialects.\n    \"\"\"\n    def __init__(self,\n                 delimiter: Optional[str],\n                 has_header: Optional[bool],\n                 quoting: Optional[int],\n                 quotechar: Optional[str] = None,\n                 doublequote: Optional[bool] = None,\n                 escapechar: Optional[str] = None,\n",
        "target_code_len": 565,
        "diff_format": "@@ -48,8 +52,14 @@\n class Dialect(csv.Dialect):\n+    \"\"\" A simple Dialect class\n+\n+    This dialect class includes has_header and minimal defaulting that make it work\n+    better for this application - where we want to pass around csv info, not define\n+    reusable dialects.\n+    \"\"\"\n     def __init__(self,\n-                 delimiter: str,\n-                 has_header: bool,\n-                 quoting: int,\n-                 quotechar: str = None,\n-                 doublequote: Optional[str] = None,\n+                 delimiter: Optional[str],\n+                 has_header: Optional[bool],\n+                 quoting: Optional[int],\n+                 quotechar: Optional[str] = None,\n+                 doublequote: Optional[bool] = None,\n                  escapechar: Optional[str] = None,\n",
        "source_code_with_indent": "<DED><DED>class Dialect(csv.Dialect):\n    <IND>def __init__(self,\n                 delimiter: str,\n                 has_header: bool,\n                 quoting: int,\n                 quotechar: str = None,\n                 doublequote: Optional[str] = None,\n                 escapechar: Optional[str] = None,\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "<DED><DED>class Dialect(csv.Dialect):\n    <IND>\"\"\" A simple Dialect class\n\n    This dialect class includes has_header and minimal defaulting that make it work\n    better for this application - where we want to pass around csv info, not define\n    reusable dialects.\n    \"\"\"\n    def __init__(self,\n                 delimiter: Optional[str],\n                 has_header: Optional[bool],\n                 quoting: Optional[int],\n                 quotechar: Optional[str] = None,\n                 doublequote: Optional[bool] = None,\n                 escapechar: Optional[str] = None,\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    if quoting is not None:\n        dialect.quoting = quoting\n    if quotechar is not None:\n",
        "source_code_len": 92,
        "target_code": "    if quoting is not None:\n        dialect.quoting = get_quote_number(quoting)\n    if quotechar is not None:\n",
        "target_code_len": 110,
        "diff_format": "@@ -169,3 +189,3 @@\n     if quoting is not None:\n-        dialect.quoting = quoting\n+        dialect.quoting = get_quote_number(quoting)\n     if quotechar is not None:\n",
        "source_code_with_indent": "    <DED>if quoting is not None:\n        <IND>dialect.quoting = quoting\n    <DED>if quotechar is not None:\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    <DED>if quoting is not None:\n        <IND>dialect.quoting = get_quote_number(quoting)\n    <DED>if quotechar is not None:\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    if dialect.quoting is None:\n        dialect.quoting = quoting\n    if dialect.quotechar is None:\n",
        "source_code_len": 100,
        "target_code": "    if dialect.quoting is None:\n        dialect.quoting = get_quote_number(quoting)\n    if dialect.quotechar is None:\n",
        "target_code_len": 118,
        "diff_format": "@@ -213,3 +233,3 @@\n     if dialect.quoting is None:\n-        dialect.quoting = quoting\n+        dialect.quoting = get_quote_number(quoting)\n     if dialect.quotechar is None:\n",
        "source_code_with_indent": "    <DED>if dialect.quoting is None:\n        <IND>dialect.quoting = quoting\n    <DED>if dialect.quotechar is None:\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    <DED>if dialect.quoting is None:\n        <IND>dialect.quoting = get_quote_number(quoting)\n    <DED>if dialect.quotechar is None:\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    #total_field_cnt  = collections.defaultdict(int)\n    total_field_cnt: Dict[int, int] = {}\n\n",
        "source_code_len": 95,
        "target_code": "    #total_field_cnt  = collections.defaultdict(int)\n    total_field_cnt: Dict[Any, Union[int, float]] = {}\n\n",
        "target_code_len": 109,
        "diff_format": "@@ -302,3 +323,3 @@\n     #total_field_cnt  = collections.defaultdict(int)\n-    total_field_cnt: Dict[int, int] = {}\n+    total_field_cnt: Dict[Any, Union[int, float]] = {}\n \n",
        "source_code_with_indent": "    #total_field_cnt  = collections.defaultdict(int)\n    total_field_cnt: Dict[int, int] = {}\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    #total_field_cnt  = collections.defaultdict(int)\n    total_field_cnt: Dict[Any, Union[int, float]] = {}\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    #quoted_field_cnt = collections.defaultdict(int)\n    quoted_field_cnt: Dict[int, int] = {}\n\n",
        "source_code_len": 96,
        "target_code": "    #quoted_field_cnt = collections.defaultdict(int)\n    quoted_field_cnt: Dict[Any, Union[int, float]] = {}\n\n",
        "target_code_len": 110,
        "diff_format": "@@ -308,3 +329,3 @@\n     #quoted_field_cnt = collections.defaultdict(int)\n-    quoted_field_cnt: Dict[int, int] = {}\n+    quoted_field_cnt: Dict[Any, Union[int, float]] = {}\n \n",
        "source_code_with_indent": "    #quoted_field_cnt = collections.defaultdict(int)\n    quoted_field_cnt: Dict[int, int] = {}\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    #quoted_field_cnt = collections.defaultdict(int)\n    quoted_field_cnt: Dict[Any, Union[int, float]] = {}\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "kenfar/DataGristle",
    "commit": "c85be697bb673eb3181cab4ba1ca84ea198db2bb",
    "filename": "datagristle/csvhelper.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/kenfar-DataGristle/datagristle/csvhelper.py",
    "file_hunks_size": 18,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "datagristle/csvhelper.py:218:8 Incompatible attribute type [8]: Attribute `has_header` declared in class `Dialect` has type `bool` but is used as type `Optional[bool]`.",
    "message": " Attribute `has_header` declared in class `Dialect` has type `bool` but is used as type `Optional[bool]`.",
    "rule_id": "Incompatible attribute type [8]",
    "warning_line_no": 218,
    "warning_line": "        dialect.has_header = has_header",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "from pprint import pprint as pp\nfrom typing import Optional, List, Dict\nimport _csv\n",
        "source_code_len": 84,
        "target_code": "from pprint import pprint as pp\nfrom typing import Optional, List, Dict, Any, Union, Type\nimport _csv\n",
        "target_code_len": 102,
        "diff_format": "@@ -11,3 +11,3 @@\n from pprint import pprint as pp\n-from typing import Optional, List, Dict\n+from typing import Optional, List, Dict, Any, Union, Type\n import _csv\n",
        "source_code_with_indent": "from pprint import pprint as pp\nfrom typing import Optional, List, Dict\nimport _csv\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "from pprint import pprint as pp\nfrom typing import Optional, List, Dict, Any, Union, Type\nimport _csv\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "class Dialect(csv.Dialect):\n    def __init__(self,\n                 delimiter: str,\n                 has_header: bool,\n                 quoting: int,\n                 quotechar: str = None,\n                 doublequote: Optional[str] = None,\n                 escapechar: Optional[str] = None,\n",
        "source_code_len": 293,
        "target_code": "class Dialect(csv.Dialect):\n    \"\"\" A simple Dialect class\n\n    This dialect class includes has_header and minimal defaulting that make it work\n    better for this application - where we want to pass around csv info, not define\n    reusable dialects.\n    \"\"\"\n    def __init__(self,\n                 delimiter: Optional[str],\n                 has_header: Optional[bool],\n                 quoting: Optional[int],\n                 quotechar: Optional[str] = None,\n                 doublequote: Optional[bool] = None,\n                 escapechar: Optional[str] = None,\n",
        "target_code_len": 565,
        "diff_format": "@@ -48,8 +52,14 @@\n class Dialect(csv.Dialect):\n+    \"\"\" A simple Dialect class\n+\n+    This dialect class includes has_header and minimal defaulting that make it work\n+    better for this application - where we want to pass around csv info, not define\n+    reusable dialects.\n+    \"\"\"\n     def __init__(self,\n-                 delimiter: str,\n-                 has_header: bool,\n-                 quoting: int,\n-                 quotechar: str = None,\n-                 doublequote: Optional[str] = None,\n+                 delimiter: Optional[str],\n+                 has_header: Optional[bool],\n+                 quoting: Optional[int],\n+                 quotechar: Optional[str] = None,\n+                 doublequote: Optional[bool] = None,\n                  escapechar: Optional[str] = None,\n",
        "source_code_with_indent": "<DED><DED>class Dialect(csv.Dialect):\n    <IND>def __init__(self,\n                 delimiter: str,\n                 has_header: bool,\n                 quoting: int,\n                 quotechar: str = None,\n                 doublequote: Optional[str] = None,\n                 escapechar: Optional[str] = None,\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "<DED><DED>class Dialect(csv.Dialect):\n    <IND>\"\"\" A simple Dialect class\n\n    This dialect class includes has_header and minimal defaulting that make it work\n    better for this application - where we want to pass around csv info, not define\n    reusable dialects.\n    \"\"\"\n    def __init__(self,\n                 delimiter: Optional[str],\n                 has_header: Optional[bool],\n                 quoting: Optional[int],\n                 quotechar: Optional[str] = None,\n                 doublequote: Optional[bool] = None,\n                 escapechar: Optional[str] = None,\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    if quoting is not None:\n        dialect.quoting = quoting\n    if quotechar is not None:\n",
        "source_code_len": 92,
        "target_code": "    if quoting is not None:\n        dialect.quoting = get_quote_number(quoting)\n    if quotechar is not None:\n",
        "target_code_len": 110,
        "diff_format": "@@ -169,3 +189,3 @@\n     if quoting is not None:\n-        dialect.quoting = quoting\n+        dialect.quoting = get_quote_number(quoting)\n     if quotechar is not None:\n",
        "source_code_with_indent": "    <DED>if quoting is not None:\n        <IND>dialect.quoting = quoting\n    <DED>if quotechar is not None:\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    <DED>if quoting is not None:\n        <IND>dialect.quoting = get_quote_number(quoting)\n    <DED>if quotechar is not None:\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    if dialect.quoting is None:\n        dialect.quoting = quoting\n    if dialect.quotechar is None:\n",
        "source_code_len": 100,
        "target_code": "    if dialect.quoting is None:\n        dialect.quoting = get_quote_number(quoting)\n    if dialect.quotechar is None:\n",
        "target_code_len": 118,
        "diff_format": "@@ -213,3 +233,3 @@\n     if dialect.quoting is None:\n-        dialect.quoting = quoting\n+        dialect.quoting = get_quote_number(quoting)\n     if dialect.quotechar is None:\n",
        "source_code_with_indent": "    <DED>if dialect.quoting is None:\n        <IND>dialect.quoting = quoting\n    <DED>if dialect.quotechar is None:\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    <DED>if dialect.quoting is None:\n        <IND>dialect.quoting = get_quote_number(quoting)\n    <DED>if dialect.quotechar is None:\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    #total_field_cnt  = collections.defaultdict(int)\n    total_field_cnt: Dict[int, int] = {}\n\n",
        "source_code_len": 95,
        "target_code": "    #total_field_cnt  = collections.defaultdict(int)\n    total_field_cnt: Dict[Any, Union[int, float]] = {}\n\n",
        "target_code_len": 109,
        "diff_format": "@@ -302,3 +323,3 @@\n     #total_field_cnt  = collections.defaultdict(int)\n-    total_field_cnt: Dict[int, int] = {}\n+    total_field_cnt: Dict[Any, Union[int, float]] = {}\n \n",
        "source_code_with_indent": "    #total_field_cnt  = collections.defaultdict(int)\n    total_field_cnt: Dict[int, int] = {}\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    #total_field_cnt  = collections.defaultdict(int)\n    total_field_cnt: Dict[Any, Union[int, float]] = {}\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    #quoted_field_cnt = collections.defaultdict(int)\n    quoted_field_cnt: Dict[int, int] = {}\n\n",
        "source_code_len": 96,
        "target_code": "    #quoted_field_cnt = collections.defaultdict(int)\n    quoted_field_cnt: Dict[Any, Union[int, float]] = {}\n\n",
        "target_code_len": 110,
        "diff_format": "@@ -308,3 +329,3 @@\n     #quoted_field_cnt = collections.defaultdict(int)\n-    quoted_field_cnt: Dict[int, int] = {}\n+    quoted_field_cnt: Dict[Any, Union[int, float]] = {}\n \n",
        "source_code_with_indent": "    #quoted_field_cnt = collections.defaultdict(int)\n    quoted_field_cnt: Dict[int, int] = {}\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    #quoted_field_cnt = collections.defaultdict(int)\n    quoted_field_cnt: Dict[Any, Union[int, float]] = {}\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "kenfar/DataGristle",
    "commit": "c85be697bb673eb3181cab4ba1ca84ea198db2bb",
    "filename": "datagristle/csvhelper.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/kenfar-DataGristle/datagristle/csvhelper.py",
    "file_hunks_size": 18,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "datagristle/csvhelper.py:224:8 Incompatible attribute type [8]: Attribute `doublequote` declared in class `Dialect` has type `Optional[str]` but is used as type `Optional[bool]`.",
    "message": " Attribute `doublequote` declared in class `Dialect` has type `Optional[str]` but is used as type `Optional[bool]`.",
    "rule_id": "Incompatible attribute type [8]",
    "warning_line_no": 224,
    "warning_line": "        dialect.doublequote = doublequote",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "from pprint import pprint as pp\nfrom typing import Optional, List, Dict\nimport _csv\n",
        "source_code_len": 84,
        "target_code": "from pprint import pprint as pp\nfrom typing import Optional, List, Dict, Any, Union, Type\nimport _csv\n",
        "target_code_len": 102,
        "diff_format": "@@ -11,3 +11,3 @@\n from pprint import pprint as pp\n-from typing import Optional, List, Dict\n+from typing import Optional, List, Dict, Any, Union, Type\n import _csv\n",
        "source_code_with_indent": "from pprint import pprint as pp\nfrom typing import Optional, List, Dict\nimport _csv\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "from pprint import pprint as pp\nfrom typing import Optional, List, Dict, Any, Union, Type\nimport _csv\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "class Dialect(csv.Dialect):\n    def __init__(self,\n                 delimiter: str,\n                 has_header: bool,\n                 quoting: int,\n                 quotechar: str = None,\n                 doublequote: Optional[str] = None,\n                 escapechar: Optional[str] = None,\n",
        "source_code_len": 293,
        "target_code": "class Dialect(csv.Dialect):\n    \"\"\" A simple Dialect class\n\n    This dialect class includes has_header and minimal defaulting that make it work\n    better for this application - where we want to pass around csv info, not define\n    reusable dialects.\n    \"\"\"\n    def __init__(self,\n                 delimiter: Optional[str],\n                 has_header: Optional[bool],\n                 quoting: Optional[int],\n                 quotechar: Optional[str] = None,\n                 doublequote: Optional[bool] = None,\n                 escapechar: Optional[str] = None,\n",
        "target_code_len": 565,
        "diff_format": "@@ -48,8 +52,14 @@\n class Dialect(csv.Dialect):\n+    \"\"\" A simple Dialect class\n+\n+    This dialect class includes has_header and minimal defaulting that make it work\n+    better for this application - where we want to pass around csv info, not define\n+    reusable dialects.\n+    \"\"\"\n     def __init__(self,\n-                 delimiter: str,\n-                 has_header: bool,\n-                 quoting: int,\n-                 quotechar: str = None,\n-                 doublequote: Optional[str] = None,\n+                 delimiter: Optional[str],\n+                 has_header: Optional[bool],\n+                 quoting: Optional[int],\n+                 quotechar: Optional[str] = None,\n+                 doublequote: Optional[bool] = None,\n                  escapechar: Optional[str] = None,\n",
        "source_code_with_indent": "<DED><DED>class Dialect(csv.Dialect):\n    <IND>def __init__(self,\n                 delimiter: str,\n                 has_header: bool,\n                 quoting: int,\n                 quotechar: str = None,\n                 doublequote: Optional[str] = None,\n                 escapechar: Optional[str] = None,\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "<DED><DED>class Dialect(csv.Dialect):\n    <IND>\"\"\" A simple Dialect class\n\n    This dialect class includes has_header and minimal defaulting that make it work\n    better for this application - where we want to pass around csv info, not define\n    reusable dialects.\n    \"\"\"\n    def __init__(self,\n                 delimiter: Optional[str],\n                 has_header: Optional[bool],\n                 quoting: Optional[int],\n                 quotechar: Optional[str] = None,\n                 doublequote: Optional[bool] = None,\n                 escapechar: Optional[str] = None,\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    if quoting is not None:\n        dialect.quoting = quoting\n    if quotechar is not None:\n",
        "source_code_len": 92,
        "target_code": "    if quoting is not None:\n        dialect.quoting = get_quote_number(quoting)\n    if quotechar is not None:\n",
        "target_code_len": 110,
        "diff_format": "@@ -169,3 +189,3 @@\n     if quoting is not None:\n-        dialect.quoting = quoting\n+        dialect.quoting = get_quote_number(quoting)\n     if quotechar is not None:\n",
        "source_code_with_indent": "    <DED>if quoting is not None:\n        <IND>dialect.quoting = quoting\n    <DED>if quotechar is not None:\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    <DED>if quoting is not None:\n        <IND>dialect.quoting = get_quote_number(quoting)\n    <DED>if quotechar is not None:\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    if dialect.quoting is None:\n        dialect.quoting = quoting\n    if dialect.quotechar is None:\n",
        "source_code_len": 100,
        "target_code": "    if dialect.quoting is None:\n        dialect.quoting = get_quote_number(quoting)\n    if dialect.quotechar is None:\n",
        "target_code_len": 118,
        "diff_format": "@@ -213,3 +233,3 @@\n     if dialect.quoting is None:\n-        dialect.quoting = quoting\n+        dialect.quoting = get_quote_number(quoting)\n     if dialect.quotechar is None:\n",
        "source_code_with_indent": "    <DED>if dialect.quoting is None:\n        <IND>dialect.quoting = quoting\n    <DED>if dialect.quotechar is None:\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    <DED>if dialect.quoting is None:\n        <IND>dialect.quoting = get_quote_number(quoting)\n    <DED>if dialect.quotechar is None:\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    #total_field_cnt  = collections.defaultdict(int)\n    total_field_cnt: Dict[int, int] = {}\n\n",
        "source_code_len": 95,
        "target_code": "    #total_field_cnt  = collections.defaultdict(int)\n    total_field_cnt: Dict[Any, Union[int, float]] = {}\n\n",
        "target_code_len": 109,
        "diff_format": "@@ -302,3 +323,3 @@\n     #total_field_cnt  = collections.defaultdict(int)\n-    total_field_cnt: Dict[int, int] = {}\n+    total_field_cnt: Dict[Any, Union[int, float]] = {}\n \n",
        "source_code_with_indent": "    #total_field_cnt  = collections.defaultdict(int)\n    total_field_cnt: Dict[int, int] = {}\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    #total_field_cnt  = collections.defaultdict(int)\n    total_field_cnt: Dict[Any, Union[int, float]] = {}\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    #quoted_field_cnt = collections.defaultdict(int)\n    quoted_field_cnt: Dict[int, int] = {}\n\n",
        "source_code_len": 96,
        "target_code": "    #quoted_field_cnt = collections.defaultdict(int)\n    quoted_field_cnt: Dict[Any, Union[int, float]] = {}\n\n",
        "target_code_len": 110,
        "diff_format": "@@ -308,3 +329,3 @@\n     #quoted_field_cnt = collections.defaultdict(int)\n-    quoted_field_cnt: Dict[int, int] = {}\n+    quoted_field_cnt: Dict[Any, Union[int, float]] = {}\n \n",
        "source_code_with_indent": "    #quoted_field_cnt = collections.defaultdict(int)\n    quoted_field_cnt: Dict[int, int] = {}\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    #quoted_field_cnt = collections.defaultdict(int)\n    quoted_field_cnt: Dict[Any, Union[int, float]] = {}\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "kenfar/DataGristle",
    "commit": "c85be697bb673eb3181cab4ba1ca84ea198db2bb",
    "filename": "datagristle/csvhelper.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/kenfar-DataGristle/datagristle/csvhelper.py",
    "file_hunks_size": 18,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "datagristle/csvhelper.py:346:61 Incompatible parameter type [6]: Expected `Dict[typing.Any, typing.Union[float, int]]` for 1st positional only parameter to call `comm.get_common_key` but got `Dict[int, int]`.",
    "message": " Expected `Dict[typing.Any, typing.Union[float, int]]` for 1st positional only parameter to call `comm.get_common_key` but got `Dict[int, int]`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 346,
    "warning_line": "    common_field_cnt, common_field_pct = comm.get_common_key(total_field_cnt)",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "from pprint import pprint as pp\nfrom typing import Optional, List, Dict\nimport _csv\n",
        "source_code_len": 84,
        "target_code": "from pprint import pprint as pp\nfrom typing import Optional, List, Dict, Any, Union, Type\nimport _csv\n",
        "target_code_len": 102,
        "diff_format": "@@ -11,3 +11,3 @@\n from pprint import pprint as pp\n-from typing import Optional, List, Dict\n+from typing import Optional, List, Dict, Any, Union, Type\n import _csv\n",
        "source_code_with_indent": "from pprint import pprint as pp\nfrom typing import Optional, List, Dict\nimport _csv\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "from pprint import pprint as pp\nfrom typing import Optional, List, Dict, Any, Union, Type\nimport _csv\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    #total_field_cnt  = collections.defaultdict(int)\n    total_field_cnt: Dict[int, int] = {}\n\n",
        "source_code_len": 95,
        "target_code": "    #total_field_cnt  = collections.defaultdict(int)\n    total_field_cnt: Dict[Any, Union[int, float]] = {}\n\n",
        "target_code_len": 109,
        "diff_format": "@@ -302,3 +323,3 @@\n     #total_field_cnt  = collections.defaultdict(int)\n-    total_field_cnt: Dict[int, int] = {}\n+    total_field_cnt: Dict[Any, Union[int, float]] = {}\n \n",
        "source_code_with_indent": "    #total_field_cnt  = collections.defaultdict(int)\n    total_field_cnt: Dict[int, int] = {}\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    #total_field_cnt  = collections.defaultdict(int)\n    total_field_cnt: Dict[Any, Union[int, float]] = {}\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    #quoted_field_cnt = collections.defaultdict(int)\n    quoted_field_cnt: Dict[int, int] = {}\n\n",
        "source_code_len": 96,
        "target_code": "    #quoted_field_cnt = collections.defaultdict(int)\n    quoted_field_cnt: Dict[Any, Union[int, float]] = {}\n\n",
        "target_code_len": 110,
        "diff_format": "@@ -308,3 +329,3 @@\n     #quoted_field_cnt = collections.defaultdict(int)\n-    quoted_field_cnt: Dict[int, int] = {}\n+    quoted_field_cnt: Dict[Any, Union[int, float]] = {}\n \n",
        "source_code_with_indent": "    #quoted_field_cnt = collections.defaultdict(int)\n    quoted_field_cnt: Dict[int, int] = {}\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    #quoted_field_cnt = collections.defaultdict(int)\n    quoted_field_cnt: Dict[Any, Union[int, float]] = {}\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "kenfar/DataGristle",
    "commit": "c85be697bb673eb3181cab4ba1ca84ea198db2bb",
    "filename": "datagristle/csvhelper.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/kenfar-DataGristle/datagristle/csvhelper.py",
    "file_hunks_size": 18,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "datagristle/csvhelper.py:347:75 Incompatible parameter type [6]: Expected `Dict[typing.Any, typing.Union[float, int]]` for 1st positional only parameter to call `comm.get_common_key` but got `Dict[int, int]`.",
    "message": " Expected `Dict[typing.Any, typing.Union[float, int]]` for 1st positional only parameter to call `comm.get_common_key` but got `Dict[int, int]`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 347,
    "warning_line": "    common_quoted_field_cnt, common_quoted_field_pct = comm.get_common_key(quoted_field_cnt)",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "from pprint import pprint as pp\nfrom typing import Optional, List, Dict\nimport _csv\n",
        "source_code_len": 84,
        "target_code": "from pprint import pprint as pp\nfrom typing import Optional, List, Dict, Any, Union, Type\nimport _csv\n",
        "target_code_len": 102,
        "diff_format": "@@ -11,3 +11,3 @@\n from pprint import pprint as pp\n-from typing import Optional, List, Dict\n+from typing import Optional, List, Dict, Any, Union, Type\n import _csv\n",
        "source_code_with_indent": "from pprint import pprint as pp\nfrom typing import Optional, List, Dict\nimport _csv\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "from pprint import pprint as pp\nfrom typing import Optional, List, Dict, Any, Union, Type\nimport _csv\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    #total_field_cnt  = collections.defaultdict(int)\n    total_field_cnt: Dict[int, int] = {}\n\n",
        "source_code_len": 95,
        "target_code": "    #total_field_cnt  = collections.defaultdict(int)\n    total_field_cnt: Dict[Any, Union[int, float]] = {}\n\n",
        "target_code_len": 109,
        "diff_format": "@@ -302,3 +323,3 @@\n     #total_field_cnt  = collections.defaultdict(int)\n-    total_field_cnt: Dict[int, int] = {}\n+    total_field_cnt: Dict[Any, Union[int, float]] = {}\n \n",
        "source_code_with_indent": "    #total_field_cnt  = collections.defaultdict(int)\n    total_field_cnt: Dict[int, int] = {}\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    #total_field_cnt  = collections.defaultdict(int)\n    total_field_cnt: Dict[Any, Union[int, float]] = {}\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    #quoted_field_cnt = collections.defaultdict(int)\n    quoted_field_cnt: Dict[int, int] = {}\n\n",
        "source_code_len": 96,
        "target_code": "    #quoted_field_cnt = collections.defaultdict(int)\n    quoted_field_cnt: Dict[Any, Union[int, float]] = {}\n\n",
        "target_code_len": 110,
        "diff_format": "@@ -308,3 +329,3 @@\n     #quoted_field_cnt = collections.defaultdict(int)\n-    quoted_field_cnt: Dict[int, int] = {}\n+    quoted_field_cnt: Dict[Any, Union[int, float]] = {}\n \n",
        "source_code_with_indent": "    #quoted_field_cnt = collections.defaultdict(int)\n    quoted_field_cnt: Dict[int, int] = {}\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    #quoted_field_cnt = collections.defaultdict(int)\n    quoted_field_cnt: Dict[Any, Union[int, float]] = {}\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "kenfar/DataGristle",
    "commit": "c85be697bb673eb3181cab4ba1ca84ea198db2bb",
    "filename": "datagristle/field_type.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/kenfar-DataGristle/datagristle/field_type.py",
    "file_hunks_size": 3,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": true,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "datagristle/field_type.py:333:27 Invalid type [31]: Expression `[float, str]` is not a valid type.",
    "message": " Expression `[float, str]` is not a valid type.",
    "rule_id": "Invalid type [31]",
    "warning_line_no": 333,
    "warning_line": "def is_timestamp(time_val: [float, str]) -> Tuple[bool, Optional[str], Optional[str]]:",
    "min_patch": [
      {
        "hunk_fit_TFix": true,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\ndef is_timestamp(time_val: [float, str]) -> Tuple[bool, Optional[str], Optional[str]]:\n    \"\"\" Determine if arg is a timestamp and if so what format\n",
        "source_code_len": 150,
        "target_code": "\ndef is_timestamp(time_val: Union[float, str]) -> Tuple[bool, Optional[str], Optional[str]]:\n    \"\"\" Determine if arg is a timestamp and if so what format\n",
        "target_code_len": 155,
        "diff_format": "@@ -332,3 +334,3 @@\n \n-def is_timestamp(time_val: [float, str]) -> Tuple[bool, Optional[str], Optional[str]]:\n+def is_timestamp(time_val: Union[float, str]) -> Tuple[bool, Optional[str], Optional[str]]:\n     \"\"\" Determine if arg is a timestamp and if so what format\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\n<DED><DED>def is_timestamp(time_val: [float, str]) -> Tuple[bool, Optional[str], Optional[str]]:\n    <IND>",
        "target_code_with_indent": "\n<DED><DED>def is_timestamp(time_val: Union[float, str]) -> Tuple[bool, Optional[str], Optional[str]]:\n    <IND>"
      }
    ]
  }
]