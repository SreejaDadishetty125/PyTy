[
  {
    "project": "kensho-technologies/graphql-compiler",
    "commit": "44c63aa9bfae8655d9214445066eaa13a203b4dd",
    "filename": "graphql_compiler/schema_transformation/rename_schema.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/kensho-technologies-graphql-compiler/graphql_compiler/schema_transformation/rename_schema.py",
    "file_hunks_size": 14,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "graphql_compiler/schema_transformation/rename_schema.py:1057:36 Incompatible parameter type [6]: Expected `str` for 1st positional only parameter to call `Mapping.get` but got `Optional[str]`.",
    "message": " Expected `str` for 1st positional only parameter to call `Mapping.get` but got `Optional[str]`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 1057,
    "warning_line": "        if self.field_renamings.get(self.current_type, {}).get(field_name, {field_name}) == set():",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n    _validate_renamings(schema_ast, type_renamings, field_renamings, query_type)\n\n",
        "source_code_len": 83,
        "target_code": "\n    _ensure_no_unsupported_suppressions(schema_ast, type_renamings)\n\n",
        "target_code_len": 70,
        "diff_format": "@@ -237,3 +237,3 @@\n \n-    _validate_renamings(schema_ast, type_renamings, field_renamings, query_type)\n+    _ensure_no_unsupported_suppressions(schema_ast, type_renamings)\n \n",
        "source_code_with_indent": "\n    _validate_renamings(schema_ast, type_renamings, field_renamings, query_type)\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n    _ensure_no_unsupported_suppressions(schema_ast, type_renamings)\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": true,
        "has_suppression": false,
        "source_code": "    )\n\n\ndef _validate_renamings(\n    schema_ast: DocumentNode,\n    type_renamings: Mapping[str, Optional[str]],\n    field_renamings: Mapping[str, Mapping[str, Set[str]]],\n    query_type: str,\n) -> None:\n    \"\"\"Validate the type_renamings argument before attempting to rename the schema.\n\n    Check for fields with suppressed types or unions whose members were all suppressed. Also,\n    confirm type_renamings contains no enums, interfaces, or interface implementation suppressions\n    because that hasn't been implemented yet.\n\n    The input AST will not be modified.\n\n    Args:\n        schema_ast: represents a valid schema that does not contain extensions, input object\n                    definitions, mutations, or subscriptions, whose fields of the query type share\n                    the same name as the types they query. Not modified by this function\n        type_renamings: maps original type name to renamed name or None (for type suppression). A\n                        type named \"Foo\" will be unchanged iff type_renamings does not map \"Foo\" to\n                        anything, i.e. \"Foo\" not in type_renamings\n        field_renamings: maps type names to the field renamings for that type. The renamings map\n                         field names belonging to the type to a set of field names for the\n                         renamed schema\n        query_type: name of the query type, e.g. 'RootSchemaQuery'\n\n    Raises:\n        - CascadingSuppressionError if a type/field suppression would require further suppressions\n        - NotImplementedError if type_renamings attempts to suppress an enum, an interface, or a\n          type implementing an interface\n    \"\"\"\n    _ensure_no_cascading_type_suppressions(schema_ast, type_renamings, field_renamings, query_type)\n    _ensure_no_unsupported_suppressions(schema_ast, type_renamings)\n\n\ndef _ensure_no_cascading_type_suppressions(\n    schema_ast: DocumentNode,\n    type_renamings: Mapping[str, Optional[str]],\n    field_renamings: Mapping[str, Mapping[str, Set[str]]],\n    query_type: str,\n) -> None:\n    \"\"\"Check for situations that would require further suppressions to produce a valid schema.\"\"\"\n    visitor = CascadingSuppressionCheckVisitor(type_renamings, field_renamings, query_type)\n    visit(schema_ast, visitor)\n    if visitor.fields_to_suppress or visitor.union_types_to_suppress or visitor.types_to_suppress:\n        error_message_components = [\n            \"Renamings would require further suppressions to produce a valid renamed schema.\"\n        ]\n        if visitor.fields_to_suppress:\n            for object_type in visitor.fields_to_suppress:\n                error_message_components.append(f\"Object type {object_type} contains: \")\n                error_message_components.extend(\n                    (\n                        f\"field {field} of suppressed type \"\n                        f\"{visitor.fields_to_suppress[object_type][field]}, \"\n                        for field in visitor.fields_to_suppress[object_type]\n                    )\n                )\n            error_message_components.append(\n                \"A schema containing a field that is of a nonexistent type is invalid. To fix \"\n                \"this, suppress the previously-mentioned fields using the field_renamings argument \"\n                \"of rename_schema.\"\n            )\n        if visitor.union_types_to_suppress:\n            for union_type in visitor.union_types_to_suppress:\n                error_message_components.append(\n                    f\"Union type {union_type} has no non-suppressed members: \"\n                )\n                error_message_components.extend(\n                    (union_member.name.value for union_member in union_type.types)\n                )\n            error_message_components.append(\n                \"A schema containing a union with no members is invalid. To fix this, suppress the \"\n                \"previously-mentioned unions using the type_renamings argument of rename_schema.\"\n            )\n        if visitor.types_to_suppress:\n            error_message_components.append(\n                f\"The following types have no non-suppressed fields, which is invalid: \"\n                f\"{sorted(visitor.types_to_suppress)}. To fix this, suppress the \"\n                f\"previously-mentioned types using the type_renamings argument of rename_schema.\"\n            )\n        error_message_components.append(\n            \"Note that adding suppressions may lead to other types, fields, etc. requiring \"\n            \"suppression so you may need to iterate on this before getting a legal schema.\"\n        )\n        raise CascadingSuppressionError(\"\\n\".join(error_message_components))\n\n",
        "source_code_len": 4671,
        "target_code": "    )\n\n",
        "target_code_len": 7,
        "diff_format": "@@ -251,90 +251,2 @@\n     )\n-\n-\n-def _validate_renamings(\n-    schema_ast: DocumentNode,\n-    type_renamings: Mapping[str, Optional[str]],\n-    field_renamings: Mapping[str, Mapping[str, Set[str]]],\n-    query_type: str,\n-) -> None:\n-    \"\"\"Validate the type_renamings argument before attempting to rename the schema.\n-\n-    Check for fields with suppressed types or unions whose members were all suppressed. Also,\n-    confirm type_renamings contains no enums, interfaces, or interface implementation suppressions\n-    because that hasn't been implemented yet.\n-\n-    The input AST will not be modified.\n-\n-    Args:\n-        schema_ast: represents a valid schema that does not contain extensions, input object\n-                    definitions, mutations, or subscriptions, whose fields of the query type share\n-                    the same name as the types they query. Not modified by this function\n-        type_renamings: maps original type name to renamed name or None (for type suppression). A\n-                        type named \"Foo\" will be unchanged iff type_renamings does not map \"Foo\" to\n-                        anything, i.e. \"Foo\" not in type_renamings\n-        field_renamings: maps type names to the field renamings for that type. The renamings map\n-                         field names belonging to the type to a set of field names for the\n-                         renamed schema\n-        query_type: name of the query type, e.g. 'RootSchemaQuery'\n-\n-    Raises:\n-        - CascadingSuppressionError if a type/field suppression would require further suppressions\n-        - NotImplementedError if type_renamings attempts to suppress an enum, an interface, or a\n-          type implementing an interface\n-    \"\"\"\n-    _ensure_no_cascading_type_suppressions(schema_ast, type_renamings, field_renamings, query_type)\n-    _ensure_no_unsupported_suppressions(schema_ast, type_renamings)\n-\n-\n-def _ensure_no_cascading_type_suppressions(\n-    schema_ast: DocumentNode,\n-    type_renamings: Mapping[str, Optional[str]],\n-    field_renamings: Mapping[str, Mapping[str, Set[str]]],\n-    query_type: str,\n-) -> None:\n-    \"\"\"Check for situations that would require further suppressions to produce a valid schema.\"\"\"\n-    visitor = CascadingSuppressionCheckVisitor(type_renamings, field_renamings, query_type)\n-    visit(schema_ast, visitor)\n-    if visitor.fields_to_suppress or visitor.union_types_to_suppress or visitor.types_to_suppress:\n-        error_message_components = [\n-            \"Renamings would require further suppressions to produce a valid renamed schema.\"\n-        ]\n-        if visitor.fields_to_suppress:\n-            for object_type in visitor.fields_to_suppress:\n-                error_message_components.append(f\"Object type {object_type} contains: \")\n-                error_message_components.extend(\n-                    (\n-                        f\"field {field} of suppressed type \"\n-                        f\"{visitor.fields_to_suppress[object_type][field]}, \"\n-                        for field in visitor.fields_to_suppress[object_type]\n-                    )\n-                )\n-            error_message_components.append(\n-                \"A schema containing a field that is of a nonexistent type is invalid. To fix \"\n-                \"this, suppress the previously-mentioned fields using the field_renamings argument \"\n-                \"of rename_schema.\"\n-            )\n-        if visitor.union_types_to_suppress:\n-            for union_type in visitor.union_types_to_suppress:\n-                error_message_components.append(\n-                    f\"Union type {union_type} has no non-suppressed members: \"\n-                )\n-                error_message_components.extend(\n-                    (union_member.name.value for union_member in union_type.types)\n-                )\n-            error_message_components.append(\n-                \"A schema containing a union with no members is invalid. To fix this, suppress the \"\n-                \"previously-mentioned unions using the type_renamings argument of rename_schema.\"\n-            )\n-        if visitor.types_to_suppress:\n-            error_message_components.append(\n-                f\"The following types have no non-suppressed fields, which is invalid: \"\n-                f\"{sorted(visitor.types_to_suppress)}. To fix this, suppress the \"\n-                f\"previously-mentioned types using the type_renamings argument of rename_schema.\"\n-            )\n-        error_message_components.append(\n-            \"Note that adding suppressions may lead to other types, fields, etc. requiring \"\n-            \"suppression so you may need to iterate on this before getting a legal schema.\"\n-        )\n-        raise CascadingSuppressionError(\"\\n\".join(error_message_components))\n \n",
        "source_code_with_indent": "    )\n\n\n<DED>def _validate_renamings(\n    schema_ast: DocumentNode,\n    type_renamings: Mapping[str, Optional[str]],\n    field_renamings: Mapping[str, Mapping[str, Set[str]]],\n    query_type: str,\n) -> None:\n    <IND>\"\"\"Validate the type_renamings argument before attempting to rename the schema.\n\n    Check for fields with suppressed types or unions whose members were all suppressed. Also,\n    confirm type_renamings contains no enums, interfaces, or interface implementation suppressions\n    because that hasn't been implemented yet.\n\n    The input AST will not be modified.\n\n    Args:\n        schema_ast: represents a valid schema that does not contain extensions, input object\n                    definitions, mutations, or subscriptions, whose fields of the query type share\n                    the same name as the types they query. Not modified by this function\n        type_renamings: maps original type name to renamed name or None (for type suppression). A\n                        type named \"Foo\" will be unchanged iff type_renamings does not map \"Foo\" to\n                        anything, i.e. \"Foo\" not in type_renamings\n        field_renamings: maps type names to the field renamings for that type. The renamings map\n                         field names belonging to the type to a set of field names for the\n                         renamed schema\n        query_type: name of the query type, e.g. 'RootSchemaQuery'\n\n    Raises:\n        - CascadingSuppressionError if a type/field suppression would require further suppressions\n        - NotImplementedError if type_renamings attempts to suppress an enum, an interface, or a\n          type implementing an interface\n    \"\"\"\n    _ensure_no_cascading_type_suppressions(schema_ast, type_renamings, field_renamings, query_type)\n    _ensure_no_unsupported_suppressions(schema_ast, type_renamings)\n\n\n<DED>def _ensure_no_cascading_type_suppressions(\n    schema_ast: DocumentNode,\n    type_renamings: Mapping[str, Optional[str]],\n    field_renamings: Mapping[str, Mapping[str, Set[str]]],\n    query_type: str,\n) -> None:\n    <IND>\"\"\"Check for situations that would require further suppressions to produce a valid schema.\"\"\"\n    visitor = CascadingSuppressionCheckVisitor(type_renamings, field_renamings, query_type)\n    visit(schema_ast, visitor)\n    if visitor.fields_to_suppress or visitor.union_types_to_suppress or visitor.types_to_suppress:\n        <IND>error_message_components = [\n            \"Renamings would require further suppressions to produce a valid renamed schema.\"\n        ]\n        if visitor.fields_to_suppress:\n            <IND>for object_type in visitor.fields_to_suppress:\n                <IND>error_message_components.append(f\"Object type {object_type} contains: \")\n                error_message_components.extend(\n                    (\n                        f\"field {field} of suppressed type \"\n                        f\"{visitor.fields_to_suppress[object_type][field]}, \"\n                        for field in visitor.fields_to_suppress[object_type]\n                    )\n                )\n            <DED>error_message_components.append(\n                \"A schema containing a field that is of a nonexistent type is invalid. To fix \"\n                \"this, suppress the previously-mentioned fields using the field_renamings argument \"\n                \"of rename_schema.\"\n            )\n        <DED>if visitor.union_types_to_suppress:\n            <IND>for union_type in visitor.union_types_to_suppress:\n                <IND>error_message_components.append(\n                    f\"Union type {union_type} has no non-suppressed members: \"\n                )\n                error_message_components.extend(\n                    (union_member.name.value for union_member in union_type.types)\n                )\n            <DED>error_message_components.append(\n                \"A schema containing a union with no members is invalid. To fix this, suppress the \"\n                \"previously-mentioned unions using the type_renamings argument of rename_schema.\"\n            )\n        <DED>if visitor.types_to_suppress:\n            <IND>error_message_components.append(\n                f\"The following types have no non-suppressed fields, which is invalid: \"\n                f\"{sorted(visitor.types_to_suppress)}. To fix this, suppress the \"\n                f\"previously-mentioned types using the type_renamings argument of rename_schema.\"\n            )\n        <DED>error_message_components.append(\n            \"Note that adding suppressions may lead to other types, fields, etc. requiring \"\n            \"suppression so you may need to iterate on this before getting a legal schema.\"\n        )\n        raise CascadingSuppressionError(\"\\n\".join(error_message_components))\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    )\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    renamed_schema_ast = visit(schema_ast, visitor)\n    if visitor.invalid_type_names or visitor.invalid_field_names:\n        explanation = (\n            \"Applying the renaming would involve names that are not valid, non-reserved \"\n",
        "source_code_len": 232,
        "target_code": "    renamed_schema_ast = visit(schema_ast, visitor)\n    if (\n        visitor.object_types_to_suppress\n        or visitor.union_types_to_suppress\n        or visitor.fields_to_suppress\n    ):\n        error_message_components = [\n            \"Renamings would require further suppressions to produce a valid renamed schema.\"\n        ]\n        if visitor.object_types_to_suppress:\n            error_message_components.append(\n                f\"The following object types have no non-suppressed fields, which is invalid: \"\n                f\"{sorted(visitor.object_types_to_suppress)}. To fix this, suppress the \"\n                f\"previously-mentioned types using the type_renamings argument of rename_schema.\"\n            )\n        if visitor.union_types_to_suppress:\n            error_message_components.append(\n                f\"The following union types have no non-suppressed types, which is invalid: \"\n                f\"{sorted(visitor.union_types_to_suppress)}. To fix this, suppress the \"\n                \"previously-mentioned unions using the type_renamings argument of rename_schema.\"\n            )\n        if visitor.fields_to_suppress:\n            for object_type in visitor.fields_to_suppress:\n                error_message_components.append(f\"Object type {object_type} contains: \")\n                error_message_components.extend(\n                    (\n                        f\"field {field} of suppressed type \"\n                        f\"{visitor.fields_to_suppress[object_type][field]}, \"\n                        for field in visitor.fields_to_suppress[object_type]\n                    )\n                )\n            error_message_components.append(\n                \"A schema containing a field that is of a nonexistent type is invalid. To fix \"\n                \"this, suppress the previously-mentioned fields using the field_renamings argument \"\n                \"of rename_schema.\"\n            )\n        error_message_components.append(\n            \"Note that adding suppressions may lead to other types, fields, etc. requiring \"\n            \"suppression so you may need to iterate on this before getting a legal schema.\"\n        )\n        raise CascadingSuppressionError(\"\\n\".join(error_message_components))\n    if visitor.invalid_type_names or visitor.invalid_field_names:\n        error_message_components = [\n            \"Applying the renaming would involve names that are not valid, non-reserved \"\n",
        "target_code_len": 2415,
        "diff_format": "@@ -417,4 +329,44 @@\n     renamed_schema_ast = visit(schema_ast, visitor)\n+    if (\n+        visitor.object_types_to_suppress\n+        or visitor.union_types_to_suppress\n+        or visitor.fields_to_suppress\n+    ):\n+        error_message_components = [\n+            \"Renamings would require further suppressions to produce a valid renamed schema.\"\n+        ]\n+        if visitor.object_types_to_suppress:\n+            error_message_components.append(\n+                f\"The following object types have no non-suppressed fields, which is invalid: \"\n+                f\"{sorted(visitor.object_types_to_suppress)}. To fix this, suppress the \"\n+                f\"previously-mentioned types using the type_renamings argument of rename_schema.\"\n+            )\n+        if visitor.union_types_to_suppress:\n+            error_message_components.append(\n+                f\"The following union types have no non-suppressed types, which is invalid: \"\n+                f\"{sorted(visitor.union_types_to_suppress)}. To fix this, suppress the \"\n+                \"previously-mentioned unions using the type_renamings argument of rename_schema.\"\n+            )\n+        if visitor.fields_to_suppress:\n+            for object_type in visitor.fields_to_suppress:\n+                error_message_components.append(f\"Object type {object_type} contains: \")\n+                error_message_components.extend(\n+                    (\n+                        f\"field {field} of suppressed type \"\n+                        f\"{visitor.fields_to_suppress[object_type][field]}, \"\n+                        for field in visitor.fields_to_suppress[object_type]\n+                    )\n+                )\n+            error_message_components.append(\n+                \"A schema containing a field that is of a nonexistent type is invalid. To fix \"\n+                \"this, suppress the previously-mentioned fields using the field_renamings argument \"\n+                \"of rename_schema.\"\n+            )\n+        error_message_components.append(\n+            \"Note that adding suppressions may lead to other types, fields, etc. requiring \"\n+            \"suppression so you may need to iterate on this before getting a legal schema.\"\n+        )\n+        raise CascadingSuppressionError(\"\\n\".join(error_message_components))\n     if visitor.invalid_type_names or visitor.invalid_field_names:\n-        explanation = (\n+        error_message_components = [\n             \"Applying the renaming would involve names that are not valid, non-reserved \"\n",
        "source_code_with_indent": "    renamed_schema_ast = visit(schema_ast, visitor)\n    if visitor.invalid_type_names or visitor.invalid_field_names:\n        <IND>explanation = (\n            \"Applying the renaming would involve names that are not valid, non-reserved \"\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    renamed_schema_ast = visit(schema_ast, visitor)\n    if (\n        visitor.object_types_to_suppress\n        or visitor.union_types_to_suppress\n        or visitor.fields_to_suppress\n    ):\n        <IND>error_message_components = [\n            \"Renamings would require further suppressions to produce a valid renamed schema.\"\n        ]\n        if visitor.object_types_to_suppress:\n            <IND>error_message_components.append(\n                f\"The following object types have no non-suppressed fields, which is invalid: \"\n                f\"{sorted(visitor.object_types_to_suppress)}. To fix this, suppress the \"\n                f\"previously-mentioned types using the type_renamings argument of rename_schema.\"\n            )\n        <DED>if visitor.union_types_to_suppress:\n            <IND>error_message_components.append(\n                f\"The following union types have no non-suppressed types, which is invalid: \"\n                f\"{sorted(visitor.union_types_to_suppress)}. To fix this, suppress the \"\n                \"previously-mentioned unions using the type_renamings argument of rename_schema.\"\n            )\n        <DED>if visitor.fields_to_suppress:\n            <IND>for object_type in visitor.fields_to_suppress:\n                <IND>error_message_components.append(f\"Object type {object_type} contains: \")\n                error_message_components.extend(\n                    (\n                        f\"field {field} of suppressed type \"\n                        f\"{visitor.fields_to_suppress[object_type][field]}, \"\n                        for field in visitor.fields_to_suppress[object_type]\n                    )\n                )\n            <DED>error_message_components.append(\n                \"A schema containing a field that is of a nonexistent type is invalid. To fix \"\n                \"this, suppress the previously-mentioned fields using the field_renamings argument \"\n                \"of rename_schema.\"\n            )\n        <DED>error_message_components.append(\n            \"Note that adding suppressions may lead to other types, fields, etc. requiring \"\n            \"suppression so you may need to iterate on this before getting a legal schema.\"\n        )\n        raise CascadingSuppressionError(\"\\n\".join(error_message_components))\n    <DED>if visitor.invalid_type_names or visitor.invalid_field_names:\n        <IND>error_message_components = [\n            \"Applying the renaming would involve names that are not valid, non-reserved \"\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "            \"start with double underscores.\"\n        )\n        invalid_type_names_message = None\n        if visitor.invalid_type_names:\n            sorted_invalid_type_names = sorted(visitor.invalid_type_names.items())\n            invalid_type_names_message = (\n                f\"The following is a list of tuples that describes what needs to be fixed for type \"\n",
        "source_code_len": 363,
        "target_code": "            \"start with double underscores.\"\n        ]\n        if visitor.invalid_type_names:\n            sorted_invalid_type_names = sorted(visitor.invalid_type_names.items())\n            error_message_components.append(\n                f\"The following is a list of tuples that describes what needs to be fixed for type \"\n",
        "target_code_len": 323,
        "diff_format": "@@ -423,7 +375,6 @@\n             \"start with double underscores.\"\n-        )\n-        invalid_type_names_message = None\n+        ]\n         if visitor.invalid_type_names:\n             sorted_invalid_type_names = sorted(visitor.invalid_type_names.items())\n-            invalid_type_names_message = (\n+            error_message_components.append(\n                 f\"The following is a list of tuples that describes what needs to be fixed for type \"\n",
        "source_code_with_indent": "            \"start with double underscores.\"\n        )\n        invalid_type_names_message = None\n        if visitor.invalid_type_names:\n            <IND>sorted_invalid_type_names = sorted(visitor.invalid_type_names.items())\n            invalid_type_names_message = (\n                f\"The following is a list of tuples that describes what needs to be fixed for type \"\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "            \"start with double underscores.\"\n        ]\n        if visitor.invalid_type_names:\n            <IND>sorted_invalid_type_names = sorted(visitor.invalid_type_names.items())\n            error_message_components.append(\n                f\"The following is a list of tuples that describes what needs to be fixed for type \"\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": true,
        "has_suppression": false,
        "source_code": "            )\n        error_message_components = [\n            explanation,\n            invalid_type_names_message,\n            invalid_field_names_message,\n        ]\n        raise InvalidNameError(\"\\n\".join([i for i in error_message_components if i is not None]))\n",
        "source_code_len": 265,
        "target_code": "            )\n        raise InvalidNameError(\"\\n\".join([i for i in error_message_components if i is not None]))\n",
        "target_code_len": 112,
        "diff_format": "@@ -446,7 +396,2 @@\n             )\n-        error_message_components = [\n-            explanation,\n-            invalid_type_names_message,\n-            invalid_field_names_message,\n-        ]\n         raise InvalidNameError(\"\\n\".join([i for i in error_message_components if i is not None]))\n",
        "source_code_with_indent": "            )\n        <DED>error_message_components = [\n            explanation,\n            invalid_type_names_message,\n            invalid_field_names_message,\n        ]\n        raise InvalidNameError(\"\\n\".join([i for i in error_message_components if i is not None]))\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "            )\n        <DED>raise InvalidNameError(\"\\n\".join([i for i in error_message_components if i is not None]))\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "        self.types_involving_interfaces_with_field_renamings = set()\n\n",
        "source_code_len": 70,
        "target_code": "        self.types_involving_interfaces_with_field_renamings = set()\n        self.object_types_to_suppress = set()\n        self.union_types_to_suppress = set()\n        self.fields_to_suppress = {}\n\n",
        "target_code_len": 198,
        "diff_format": "@@ -722,2 +682,5 @@\n         self.types_involving_interfaces_with_field_renamings = set()\n+        self.object_types_to_suppress = set()\n+        self.union_types_to_suppress = set()\n+        self.fields_to_suppress = {}\n \n",
        "source_code_with_indent": "        self.types_involving_interfaces_with_field_renamings = set()\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "        self.types_involving_interfaces_with_field_renamings = set()\n        self.object_types_to_suppress = set()\n        self.union_types_to_suppress = set()\n        self.fields_to_suppress = {}\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": true,
        "has_suppression": false,
        "source_code": "\nclass CascadingSuppressionCheckVisitor(Visitor):\n    \"\"\"Traverse the schema to check for cascading suppression issues.\n\n    The fields_to_suppress attribute records non-suppressed fields that depend on suppressed types.\n    The union_types_to_suppress attribute records unions that had all its members suppressed.\n    The types_to_suppress attribute records types for which all fields were suppressed.\n\n    After calling visit() on the schema using this visitor, if any of these attributes are non-empty\n    then there are further suppressions required to produce a legal schema so the code should then\n    raise a CascadingSuppressionError.\n\n    \"\"\"\n\n    # For a type named T, and its field named F whose type has name V, this dict would be\n    # {\"T\": {\"F\": \"V\"}}\n    fields_to_suppress: Dict[str, Dict[str, str]]\n    union_types_to_suppress: List[UnionTypeDefinitionNode]\n    types_to_suppress: Set[str]\n\n    def __init__(\n        self,\n        type_renamings: Mapping[str, Optional[str]],\n        field_renamings: Mapping[str, Mapping[str, Set[str]]],\n        query_type: str,\n    ) -> None:\n        \"\"\"Create a visitor to check that suppression does not cause an illegal state.\n\n        Args:\n            type_renamings: maps original type name to renamed name or None (for type suppression).\n                            A type named \"Foo\" will be unchanged iff type_renamings does not map\n                            \"Foo\" to anything, i.e. \"Foo\" not in type_renamings\n            field_renamings: maps type names to the field renamings for that type. The renamings map\n                             field names belonging to the type to a set of field names for the\n                             renamed schema\n            query_type: name of the query type (e.g. RootSchemaQuery)\n        \"\"\"\n        self.type_renamings = type_renamings\n        self.field_renamings = field_renamings\n        self.query_type = query_type\n        self.current_type: Optional[str] = None\n        self.fields_to_suppress = {}\n        self.union_types_to_suppress = []\n        self.types_to_suppress = set()\n\n    def enter_object_type_definition(\n        self,\n        node: ObjectTypeDefinitionNode,\n        key: Any,\n        parent: Any,\n        path: List[Any],\n        ancestors: List[Any],\n    ) -> None:\n        \"\"\"Record the current type that the visitor is traversing.\"\"\"\n        self.current_type = node.name.value\n        if self.current_type not in self.field_renamings:\n            # No field renamings for current type, so it's impossible for all its fields to have\n            # been suppressed.\n            return\n        current_type_field_renamings = self.field_renamings[self.current_type]\n        for field in node.fields:\n            field_name = field.name.value\n            if (\n                field_name not in current_type_field_renamings\n                or current_type_field_renamings[field_name]\n            ):\n                # Do nothing if there's at least one field for the current type that hasn't been\n                # suppressed, either because field renamings didn't contain an entry for field_name\n                # or if it didn't suppress the field\n                return\n        self.types_to_suppress.add(self.current_type)\n\n    def leave_object_type_definition(\n        self,\n        node: ObjectTypeDefinitionNode,\n        key: Any,\n        parent: Any,\n        path: List[Any],\n        ancestors: List[Any],\n    ) -> None:\n        \"\"\"Finish traversing the current type node.\"\"\"\n        self.current_type = None\n\n    def enter_field_definition(\n        self,\n        node: FieldDefinitionNode,\n        key: Any,\n        parent: Any,\n        path: List[Any],\n        ancestors: List[Any],\n    ) -> None:\n        \"\"\"Check that no type Bar contains a field of type Foo, where Foo is suppressed.\"\"\"\n        if self.current_type == self.query_type:\n            return IDLE\n        # At a field of a type that is not the query type\n        field_name = node.name.value\n        field_type = get_ast_with_non_null_and_list_stripped(node.type).name.value\n        if self.type_renamings.get(field_type, field_type):\n            return IDLE\n        # Reaching this point means this field is of a type to be suppressed.\n        if self.current_type is None:\n            raise AssertionError(\n                \"Entered a field not in any ObjectTypeDefinition scope because \"\n                \"self.current_type is None\"\n            )\n        if self.current_type == field_type:\n            # Then node corresponds to a field belonging to type T that is also of type T.\n            # Therefore, we don't need to explicitly suppress the field as well and this should not\n            # raise errors.\n            return IDLE\n        if self.field_renamings.get(self.current_type, {}).get(field_name, {field_name}) == set():\n            # Field was also suppressed so this should not raise errors.\n            return IDLE\n        if self.current_type not in self.fields_to_suppress:\n            self.fields_to_suppress[self.current_type] = {}\n        self.fields_to_suppress[self.current_type][field_name] = field_type\n        return IDLE\n\n    def enter_union_type_definition(\n        self,\n        node: UnionTypeDefinitionNode,\n        key: Any,\n        parent: Any,\n        path: List[Any],\n        ancestors: List[Any],\n    ) -> None:\n        \"\"\"Check that each union still has at least one non-suppressed member.\"\"\"\n        union_name = node.name.value\n        # Check if all the union members are suppressed.\n        for union_member in node.types:\n            union_member_type = get_ast_with_non_null_and_list_stripped(union_member).name.value\n            if self.type_renamings.get(union_member_type, union_member_type):\n                # Then at least one member of the union is not suppressed, so there is no cascading\n                # suppression error concern.\n                return IDLE\n        if self.type_renamings.get(union_name, union_name) is None:\n            # If the union is also suppressed, then nothing needs to happen here\n            return IDLE\n        self.union_types_to_suppress.append(node)\n\n        return IDLE\n\n\nclass SuppressionNotImplementedVisitor(Visitor):\n",
        "source_code_len": 6207,
        "target_code": "\nclass SuppressionNotImplementedVisitor(Visitor):\n",
        "target_code_len": 50,
        "diff_format": "@@ -947,144 +979,2 @@\n \n-class CascadingSuppressionCheckVisitor(Visitor):\n-    \"\"\"Traverse the schema to check for cascading suppression issues.\n-\n-    The fields_to_suppress attribute records non-suppressed fields that depend on suppressed types.\n-    The union_types_to_suppress attribute records unions that had all its members suppressed.\n-    The types_to_suppress attribute records types for which all fields were suppressed.\n-\n-    After calling visit() on the schema using this visitor, if any of these attributes are non-empty\n-    then there are further suppressions required to produce a legal schema so the code should then\n-    raise a CascadingSuppressionError.\n-\n-    \"\"\"\n-\n-    # For a type named T, and its field named F whose type has name V, this dict would be\n-    # {\"T\": {\"F\": \"V\"}}\n-    fields_to_suppress: Dict[str, Dict[str, str]]\n-    union_types_to_suppress: List[UnionTypeDefinitionNode]\n-    types_to_suppress: Set[str]\n-\n-    def __init__(\n-        self,\n-        type_renamings: Mapping[str, Optional[str]],\n-        field_renamings: Mapping[str, Mapping[str, Set[str]]],\n-        query_type: str,\n-    ) -> None:\n-        \"\"\"Create a visitor to check that suppression does not cause an illegal state.\n-\n-        Args:\n-            type_renamings: maps original type name to renamed name or None (for type suppression).\n-                            A type named \"Foo\" will be unchanged iff type_renamings does not map\n-                            \"Foo\" to anything, i.e. \"Foo\" not in type_renamings\n-            field_renamings: maps type names to the field renamings for that type. The renamings map\n-                             field names belonging to the type to a set of field names for the\n-                             renamed schema\n-            query_type: name of the query type (e.g. RootSchemaQuery)\n-        \"\"\"\n-        self.type_renamings = type_renamings\n-        self.field_renamings = field_renamings\n-        self.query_type = query_type\n-        self.current_type: Optional[str] = None\n-        self.fields_to_suppress = {}\n-        self.union_types_to_suppress = []\n-        self.types_to_suppress = set()\n-\n-    def enter_object_type_definition(\n-        self,\n-        node: ObjectTypeDefinitionNode,\n-        key: Any,\n-        parent: Any,\n-        path: List[Any],\n-        ancestors: List[Any],\n-    ) -> None:\n-        \"\"\"Record the current type that the visitor is traversing.\"\"\"\n-        self.current_type = node.name.value\n-        if self.current_type not in self.field_renamings:\n-            # No field renamings for current type, so it's impossible for all its fields to have\n-            # been suppressed.\n-            return\n-        current_type_field_renamings = self.field_renamings[self.current_type]\n-        for field in node.fields:\n-            field_name = field.name.value\n-            if (\n-                field_name not in current_type_field_renamings\n-                or current_type_field_renamings[field_name]\n-            ):\n-                # Do nothing if there's at least one field for the current type that hasn't been\n-                # suppressed, either because field renamings didn't contain an entry for field_name\n-                # or if it didn't suppress the field\n-                return\n-        self.types_to_suppress.add(self.current_type)\n-\n-    def leave_object_type_definition(\n-        self,\n-        node: ObjectTypeDefinitionNode,\n-        key: Any,\n-        parent: Any,\n-        path: List[Any],\n-        ancestors: List[Any],\n-    ) -> None:\n-        \"\"\"Finish traversing the current type node.\"\"\"\n-        self.current_type = None\n-\n-    def enter_field_definition(\n-        self,\n-        node: FieldDefinitionNode,\n-        key: Any,\n-        parent: Any,\n-        path: List[Any],\n-        ancestors: List[Any],\n-    ) -> None:\n-        \"\"\"Check that no type Bar contains a field of type Foo, where Foo is suppressed.\"\"\"\n-        if self.current_type == self.query_type:\n-            return IDLE\n-        # At a field of a type that is not the query type\n-        field_name = node.name.value\n-        field_type = get_ast_with_non_null_and_list_stripped(node.type).name.value\n-        if self.type_renamings.get(field_type, field_type):\n-            return IDLE\n-        # Reaching this point means this field is of a type to be suppressed.\n-        if self.current_type is None:\n-            raise AssertionError(\n-                \"Entered a field not in any ObjectTypeDefinition scope because \"\n-                \"self.current_type is None\"\n-            )\n-        if self.current_type == field_type:\n-            # Then node corresponds to a field belonging to type T that is also of type T.\n-            # Therefore, we don't need to explicitly suppress the field as well and this should not\n-            # raise errors.\n-            return IDLE\n-        if self.field_renamings.get(self.current_type, {}).get(field_name, {field_name}) == set():\n-            # Field was also suppressed so this should not raise errors.\n-            return IDLE\n-        if self.current_type not in self.fields_to_suppress:\n-            self.fields_to_suppress[self.current_type] = {}\n-        self.fields_to_suppress[self.current_type][field_name] = field_type\n-        return IDLE\n-\n-    def enter_union_type_definition(\n-        self,\n-        node: UnionTypeDefinitionNode,\n-        key: Any,\n-        parent: Any,\n-        path: List[Any],\n-        ancestors: List[Any],\n-    ) -> None:\n-        \"\"\"Check that each union still has at least one non-suppressed member.\"\"\"\n-        union_name = node.name.value\n-        # Check if all the union members are suppressed.\n-        for union_member in node.types:\n-            union_member_type = get_ast_with_non_null_and_list_stripped(union_member).name.value\n-            if self.type_renamings.get(union_member_type, union_member_type):\n-                # Then at least one member of the union is not suppressed, so there is no cascading\n-                # suppression error concern.\n-                return IDLE\n-        if self.type_renamings.get(union_name, union_name) is None:\n-            # If the union is also suppressed, then nothing needs to happen here\n-            return IDLE\n-        self.union_types_to_suppress.append(node)\n-\n-        return IDLE\n-\n-\n class SuppressionNotImplementedVisitor(Visitor):\n",
        "source_code_with_indent": "\n<DED><DED>class CascadingSuppressionCheckVisitor(Visitor):\n    <IND>\"\"\"Traverse the schema to check for cascading suppression issues.\n\n    The fields_to_suppress attribute records non-suppressed fields that depend on suppressed types.\n    The union_types_to_suppress attribute records unions that had all its members suppressed.\n    The types_to_suppress attribute records types for which all fields were suppressed.\n\n    After calling visit() on the schema using this visitor, if any of these attributes are non-empty\n    then there are further suppressions required to produce a legal schema so the code should then\n    raise a CascadingSuppressionError.\n\n    \"\"\"\n\n    # For a type named T, and its field named F whose type has name V, this dict would be\n    # {\"T\": {\"F\": \"V\"}}\n    fields_to_suppress: Dict[str, Dict[str, str]]\n    union_types_to_suppress: List[UnionTypeDefinitionNode]\n    types_to_suppress: Set[str]\n\n    def __init__(\n        self,\n        type_renamings: Mapping[str, Optional[str]],\n        field_renamings: Mapping[str, Mapping[str, Set[str]]],\n        query_type: str,\n    ) -> None:\n        <IND>\"\"\"Create a visitor to check that suppression does not cause an illegal state.\n\n        Args:\n            type_renamings: maps original type name to renamed name or None (for type suppression).\n                            A type named \"Foo\" will be unchanged iff type_renamings does not map\n                            \"Foo\" to anything, i.e. \"Foo\" not in type_renamings\n            field_renamings: maps type names to the field renamings for that type. The renamings map\n                             field names belonging to the type to a set of field names for the\n                             renamed schema\n            query_type: name of the query type (e.g. RootSchemaQuery)\n        \"\"\"\n        self.type_renamings = type_renamings\n        self.field_renamings = field_renamings\n        self.query_type = query_type\n        self.current_type: Optional[str] = None\n        self.fields_to_suppress = {}\n        self.union_types_to_suppress = []\n        self.types_to_suppress = set()\n\n    <DED>def enter_object_type_definition(\n        self,\n        node: ObjectTypeDefinitionNode,\n        key: Any,\n        parent: Any,\n        path: List[Any],\n        ancestors: List[Any],\n    ) -> None:\n        <IND>\"\"\"Record the current type that the visitor is traversing.\"\"\"\n        self.current_type = node.name.value\n        if self.current_type not in self.field_renamings:\n            # No field renamings for current type, so it's impossible for all its fields to have\n            # been suppressed.\n            <IND>return\n        <DED>current_type_field_renamings = self.field_renamings[self.current_type]\n        for field in node.fields:\n            <IND>field_name = field.name.value\n            if (\n                field_name not in current_type_field_renamings\n                or current_type_field_renamings[field_name]\n            ):\n                # Do nothing if there's at least one field for the current type that hasn't been\n                # suppressed, either because field renamings didn't contain an entry for field_name\n                # or if it didn't suppress the field\n                <IND>return\n        <DED><DED>self.types_to_suppress.add(self.current_type)\n\n    <DED>def leave_object_type_definition(\n        self,\n        node: ObjectTypeDefinitionNode,\n        key: Any,\n        parent: Any,\n        path: List[Any],\n        ancestors: List[Any],\n    ) -> None:\n        <IND>\"\"\"Finish traversing the current type node.\"\"\"\n        self.current_type = None\n\n    <DED>def enter_field_definition(\n        self,\n        node: FieldDefinitionNode,\n        key: Any,\n        parent: Any,\n        path: List[Any],\n        ancestors: List[Any],\n    ) -> None:\n        <IND>\"\"\"Check that no type Bar contains a field of type Foo, where Foo is suppressed.\"\"\"\n        if self.current_type == self.query_type:\n            <IND>return IDLE\n        # At a field of a type that is not the query type\n        <DED>field_name = node.name.value\n        field_type = get_ast_with_non_null_and_list_stripped(node.type).name.value\n        if self.type_renamings.get(field_type, field_type):\n            <IND>return IDLE\n        # Reaching this point means this field is of a type to be suppressed.\n        <DED>if self.current_type is None:\n            <IND>raise AssertionError(\n                \"Entered a field not in any ObjectTypeDefinition scope because \"\n                \"self.current_type is None\"\n            )\n        <DED>if self.current_type == field_type:\n            # Then node corresponds to a field belonging to type T that is also of type T.\n            # Therefore, we don't need to explicitly suppress the field as well and this should not\n            # raise errors.\n            <IND>return IDLE\n        <DED>if self.field_renamings.get(self.current_type, {}).get(field_name, {field_name}) == set():\n            # Field was also suppressed so this should not raise errors.\n            <IND>return IDLE\n        <DED>if self.current_type not in self.fields_to_suppress:\n            <IND>self.fields_to_suppress[self.current_type] = {}\n        <DED>self.fields_to_suppress[self.current_type][field_name] = field_type\n        return IDLE\n\n    <DED>def enter_union_type_definition(\n        self,\n        node: UnionTypeDefinitionNode,\n        key: Any,\n        parent: Any,\n        path: List[Any],\n        ancestors: List[Any],\n    ) -> None:\n        <IND>\"\"\"Check that each union still has at least one non-suppressed member.\"\"\"\n        union_name = node.name.value\n        # Check if all the union members are suppressed.\n        for union_member in node.types:\n            <IND>union_member_type = get_ast_with_non_null_and_list_stripped(union_member).name.value\n            if self.type_renamings.get(union_member_type, union_member_type):\n                # Then at least one member of the union is not suppressed, so there is no cascading\n                # suppression error concern.\n                <IND>return IDLE\n        <DED><DED>if self.type_renamings.get(union_name, union_name) is None:\n            # If the union is also suppressed, then nothing needs to happen here\n            <IND>return IDLE\n        <DED>self.union_types_to_suppress.append(node)\n\n        return IDLE\n\n\n<DED><DED>class SuppressionNotImplementedVisitor(Visitor):\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n<DED><DED>class SuppressionNotImplementedVisitor(Visitor):\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "kensho-technologies/graphql-compiler",
    "commit": "44c63aa9bfae8655d9214445066eaa13a203b4dd",
    "filename": "graphql_compiler/schema_transformation/rename_schema.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/kensho-technologies-graphql-compiler/graphql_compiler/schema_transformation/rename_schema.py",
    "file_hunks_size": 14,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "graphql_compiler/schema_transformation/rename_schema.py:1061:36 Incompatible parameter type [6]: Expected `str` for 1st positional only parameter to call `dict.__setitem__` but got `Optional[str]`.",
    "message": " Expected `str` for 1st positional only parameter to call `dict.__setitem__` but got `Optional[str]`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 1061,
    "warning_line": "            self.fields_to_suppress[self.current_type] = {}",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n    _validate_renamings(schema_ast, type_renamings, field_renamings, query_type)\n\n",
        "source_code_len": 83,
        "target_code": "\n    _ensure_no_unsupported_suppressions(schema_ast, type_renamings)\n\n",
        "target_code_len": 70,
        "diff_format": "@@ -237,3 +237,3 @@\n \n-    _validate_renamings(schema_ast, type_renamings, field_renamings, query_type)\n+    _ensure_no_unsupported_suppressions(schema_ast, type_renamings)\n \n",
        "source_code_with_indent": "\n    _validate_renamings(schema_ast, type_renamings, field_renamings, query_type)\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n    _ensure_no_unsupported_suppressions(schema_ast, type_renamings)\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": true,
        "has_suppression": false,
        "source_code": "    )\n\n\ndef _validate_renamings(\n    schema_ast: DocumentNode,\n    type_renamings: Mapping[str, Optional[str]],\n    field_renamings: Mapping[str, Mapping[str, Set[str]]],\n    query_type: str,\n) -> None:\n    \"\"\"Validate the type_renamings argument before attempting to rename the schema.\n\n    Check for fields with suppressed types or unions whose members were all suppressed. Also,\n    confirm type_renamings contains no enums, interfaces, or interface implementation suppressions\n    because that hasn't been implemented yet.\n\n    The input AST will not be modified.\n\n    Args:\n        schema_ast: represents a valid schema that does not contain extensions, input object\n                    definitions, mutations, or subscriptions, whose fields of the query type share\n                    the same name as the types they query. Not modified by this function\n        type_renamings: maps original type name to renamed name or None (for type suppression). A\n                        type named \"Foo\" will be unchanged iff type_renamings does not map \"Foo\" to\n                        anything, i.e. \"Foo\" not in type_renamings\n        field_renamings: maps type names to the field renamings for that type. The renamings map\n                         field names belonging to the type to a set of field names for the\n                         renamed schema\n        query_type: name of the query type, e.g. 'RootSchemaQuery'\n\n    Raises:\n        - CascadingSuppressionError if a type/field suppression would require further suppressions\n        - NotImplementedError if type_renamings attempts to suppress an enum, an interface, or a\n          type implementing an interface\n    \"\"\"\n    _ensure_no_cascading_type_suppressions(schema_ast, type_renamings, field_renamings, query_type)\n    _ensure_no_unsupported_suppressions(schema_ast, type_renamings)\n\n\ndef _ensure_no_cascading_type_suppressions(\n    schema_ast: DocumentNode,\n    type_renamings: Mapping[str, Optional[str]],\n    field_renamings: Mapping[str, Mapping[str, Set[str]]],\n    query_type: str,\n) -> None:\n    \"\"\"Check for situations that would require further suppressions to produce a valid schema.\"\"\"\n    visitor = CascadingSuppressionCheckVisitor(type_renamings, field_renamings, query_type)\n    visit(schema_ast, visitor)\n    if visitor.fields_to_suppress or visitor.union_types_to_suppress or visitor.types_to_suppress:\n        error_message_components = [\n            \"Renamings would require further suppressions to produce a valid renamed schema.\"\n        ]\n        if visitor.fields_to_suppress:\n            for object_type in visitor.fields_to_suppress:\n                error_message_components.append(f\"Object type {object_type} contains: \")\n                error_message_components.extend(\n                    (\n                        f\"field {field} of suppressed type \"\n                        f\"{visitor.fields_to_suppress[object_type][field]}, \"\n                        for field in visitor.fields_to_suppress[object_type]\n                    )\n                )\n            error_message_components.append(\n                \"A schema containing a field that is of a nonexistent type is invalid. To fix \"\n                \"this, suppress the previously-mentioned fields using the field_renamings argument \"\n                \"of rename_schema.\"\n            )\n        if visitor.union_types_to_suppress:\n            for union_type in visitor.union_types_to_suppress:\n                error_message_components.append(\n                    f\"Union type {union_type} has no non-suppressed members: \"\n                )\n                error_message_components.extend(\n                    (union_member.name.value for union_member in union_type.types)\n                )\n            error_message_components.append(\n                \"A schema containing a union with no members is invalid. To fix this, suppress the \"\n                \"previously-mentioned unions using the type_renamings argument of rename_schema.\"\n            )\n        if visitor.types_to_suppress:\n            error_message_components.append(\n                f\"The following types have no non-suppressed fields, which is invalid: \"\n                f\"{sorted(visitor.types_to_suppress)}. To fix this, suppress the \"\n                f\"previously-mentioned types using the type_renamings argument of rename_schema.\"\n            )\n        error_message_components.append(\n            \"Note that adding suppressions may lead to other types, fields, etc. requiring \"\n            \"suppression so you may need to iterate on this before getting a legal schema.\"\n        )\n        raise CascadingSuppressionError(\"\\n\".join(error_message_components))\n\n",
        "source_code_len": 4671,
        "target_code": "    )\n\n",
        "target_code_len": 7,
        "diff_format": "@@ -251,90 +251,2 @@\n     )\n-\n-\n-def _validate_renamings(\n-    schema_ast: DocumentNode,\n-    type_renamings: Mapping[str, Optional[str]],\n-    field_renamings: Mapping[str, Mapping[str, Set[str]]],\n-    query_type: str,\n-) -> None:\n-    \"\"\"Validate the type_renamings argument before attempting to rename the schema.\n-\n-    Check for fields with suppressed types or unions whose members were all suppressed. Also,\n-    confirm type_renamings contains no enums, interfaces, or interface implementation suppressions\n-    because that hasn't been implemented yet.\n-\n-    The input AST will not be modified.\n-\n-    Args:\n-        schema_ast: represents a valid schema that does not contain extensions, input object\n-                    definitions, mutations, or subscriptions, whose fields of the query type share\n-                    the same name as the types they query. Not modified by this function\n-        type_renamings: maps original type name to renamed name or None (for type suppression). A\n-                        type named \"Foo\" will be unchanged iff type_renamings does not map \"Foo\" to\n-                        anything, i.e. \"Foo\" not in type_renamings\n-        field_renamings: maps type names to the field renamings for that type. The renamings map\n-                         field names belonging to the type to a set of field names for the\n-                         renamed schema\n-        query_type: name of the query type, e.g. 'RootSchemaQuery'\n-\n-    Raises:\n-        - CascadingSuppressionError if a type/field suppression would require further suppressions\n-        - NotImplementedError if type_renamings attempts to suppress an enum, an interface, or a\n-          type implementing an interface\n-    \"\"\"\n-    _ensure_no_cascading_type_suppressions(schema_ast, type_renamings, field_renamings, query_type)\n-    _ensure_no_unsupported_suppressions(schema_ast, type_renamings)\n-\n-\n-def _ensure_no_cascading_type_suppressions(\n-    schema_ast: DocumentNode,\n-    type_renamings: Mapping[str, Optional[str]],\n-    field_renamings: Mapping[str, Mapping[str, Set[str]]],\n-    query_type: str,\n-) -> None:\n-    \"\"\"Check for situations that would require further suppressions to produce a valid schema.\"\"\"\n-    visitor = CascadingSuppressionCheckVisitor(type_renamings, field_renamings, query_type)\n-    visit(schema_ast, visitor)\n-    if visitor.fields_to_suppress or visitor.union_types_to_suppress or visitor.types_to_suppress:\n-        error_message_components = [\n-            \"Renamings would require further suppressions to produce a valid renamed schema.\"\n-        ]\n-        if visitor.fields_to_suppress:\n-            for object_type in visitor.fields_to_suppress:\n-                error_message_components.append(f\"Object type {object_type} contains: \")\n-                error_message_components.extend(\n-                    (\n-                        f\"field {field} of suppressed type \"\n-                        f\"{visitor.fields_to_suppress[object_type][field]}, \"\n-                        for field in visitor.fields_to_suppress[object_type]\n-                    )\n-                )\n-            error_message_components.append(\n-                \"A schema containing a field that is of a nonexistent type is invalid. To fix \"\n-                \"this, suppress the previously-mentioned fields using the field_renamings argument \"\n-                \"of rename_schema.\"\n-            )\n-        if visitor.union_types_to_suppress:\n-            for union_type in visitor.union_types_to_suppress:\n-                error_message_components.append(\n-                    f\"Union type {union_type} has no non-suppressed members: \"\n-                )\n-                error_message_components.extend(\n-                    (union_member.name.value for union_member in union_type.types)\n-                )\n-            error_message_components.append(\n-                \"A schema containing a union with no members is invalid. To fix this, suppress the \"\n-                \"previously-mentioned unions using the type_renamings argument of rename_schema.\"\n-            )\n-        if visitor.types_to_suppress:\n-            error_message_components.append(\n-                f\"The following types have no non-suppressed fields, which is invalid: \"\n-                f\"{sorted(visitor.types_to_suppress)}. To fix this, suppress the \"\n-                f\"previously-mentioned types using the type_renamings argument of rename_schema.\"\n-            )\n-        error_message_components.append(\n-            \"Note that adding suppressions may lead to other types, fields, etc. requiring \"\n-            \"suppression so you may need to iterate on this before getting a legal schema.\"\n-        )\n-        raise CascadingSuppressionError(\"\\n\".join(error_message_components))\n \n",
        "source_code_with_indent": "    )\n\n\n<DED>def _validate_renamings(\n    schema_ast: DocumentNode,\n    type_renamings: Mapping[str, Optional[str]],\n    field_renamings: Mapping[str, Mapping[str, Set[str]]],\n    query_type: str,\n) -> None:\n    <IND>\"\"\"Validate the type_renamings argument before attempting to rename the schema.\n\n    Check for fields with suppressed types or unions whose members were all suppressed. Also,\n    confirm type_renamings contains no enums, interfaces, or interface implementation suppressions\n    because that hasn't been implemented yet.\n\n    The input AST will not be modified.\n\n    Args:\n        schema_ast: represents a valid schema that does not contain extensions, input object\n                    definitions, mutations, or subscriptions, whose fields of the query type share\n                    the same name as the types they query. Not modified by this function\n        type_renamings: maps original type name to renamed name or None (for type suppression). A\n                        type named \"Foo\" will be unchanged iff type_renamings does not map \"Foo\" to\n                        anything, i.e. \"Foo\" not in type_renamings\n        field_renamings: maps type names to the field renamings for that type. The renamings map\n                         field names belonging to the type to a set of field names for the\n                         renamed schema\n        query_type: name of the query type, e.g. 'RootSchemaQuery'\n\n    Raises:\n        - CascadingSuppressionError if a type/field suppression would require further suppressions\n        - NotImplementedError if type_renamings attempts to suppress an enum, an interface, or a\n          type implementing an interface\n    \"\"\"\n    _ensure_no_cascading_type_suppressions(schema_ast, type_renamings, field_renamings, query_type)\n    _ensure_no_unsupported_suppressions(schema_ast, type_renamings)\n\n\n<DED>def _ensure_no_cascading_type_suppressions(\n    schema_ast: DocumentNode,\n    type_renamings: Mapping[str, Optional[str]],\n    field_renamings: Mapping[str, Mapping[str, Set[str]]],\n    query_type: str,\n) -> None:\n    <IND>\"\"\"Check for situations that would require further suppressions to produce a valid schema.\"\"\"\n    visitor = CascadingSuppressionCheckVisitor(type_renamings, field_renamings, query_type)\n    visit(schema_ast, visitor)\n    if visitor.fields_to_suppress or visitor.union_types_to_suppress or visitor.types_to_suppress:\n        <IND>error_message_components = [\n            \"Renamings would require further suppressions to produce a valid renamed schema.\"\n        ]\n        if visitor.fields_to_suppress:\n            <IND>for object_type in visitor.fields_to_suppress:\n                <IND>error_message_components.append(f\"Object type {object_type} contains: \")\n                error_message_components.extend(\n                    (\n                        f\"field {field} of suppressed type \"\n                        f\"{visitor.fields_to_suppress[object_type][field]}, \"\n                        for field in visitor.fields_to_suppress[object_type]\n                    )\n                )\n            <DED>error_message_components.append(\n                \"A schema containing a field that is of a nonexistent type is invalid. To fix \"\n                \"this, suppress the previously-mentioned fields using the field_renamings argument \"\n                \"of rename_schema.\"\n            )\n        <DED>if visitor.union_types_to_suppress:\n            <IND>for union_type in visitor.union_types_to_suppress:\n                <IND>error_message_components.append(\n                    f\"Union type {union_type} has no non-suppressed members: \"\n                )\n                error_message_components.extend(\n                    (union_member.name.value for union_member in union_type.types)\n                )\n            <DED>error_message_components.append(\n                \"A schema containing a union with no members is invalid. To fix this, suppress the \"\n                \"previously-mentioned unions using the type_renamings argument of rename_schema.\"\n            )\n        <DED>if visitor.types_to_suppress:\n            <IND>error_message_components.append(\n                f\"The following types have no non-suppressed fields, which is invalid: \"\n                f\"{sorted(visitor.types_to_suppress)}. To fix this, suppress the \"\n                f\"previously-mentioned types using the type_renamings argument of rename_schema.\"\n            )\n        <DED>error_message_components.append(\n            \"Note that adding suppressions may lead to other types, fields, etc. requiring \"\n            \"suppression so you may need to iterate on this before getting a legal schema.\"\n        )\n        raise CascadingSuppressionError(\"\\n\".join(error_message_components))\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    )\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    renamed_schema_ast = visit(schema_ast, visitor)\n    if visitor.invalid_type_names or visitor.invalid_field_names:\n        explanation = (\n            \"Applying the renaming would involve names that are not valid, non-reserved \"\n",
        "source_code_len": 232,
        "target_code": "    renamed_schema_ast = visit(schema_ast, visitor)\n    if (\n        visitor.object_types_to_suppress\n        or visitor.union_types_to_suppress\n        or visitor.fields_to_suppress\n    ):\n        error_message_components = [\n            \"Renamings would require further suppressions to produce a valid renamed schema.\"\n        ]\n        if visitor.object_types_to_suppress:\n            error_message_components.append(\n                f\"The following object types have no non-suppressed fields, which is invalid: \"\n                f\"{sorted(visitor.object_types_to_suppress)}. To fix this, suppress the \"\n                f\"previously-mentioned types using the type_renamings argument of rename_schema.\"\n            )\n        if visitor.union_types_to_suppress:\n            error_message_components.append(\n                f\"The following union types have no non-suppressed types, which is invalid: \"\n                f\"{sorted(visitor.union_types_to_suppress)}. To fix this, suppress the \"\n                \"previously-mentioned unions using the type_renamings argument of rename_schema.\"\n            )\n        if visitor.fields_to_suppress:\n            for object_type in visitor.fields_to_suppress:\n                error_message_components.append(f\"Object type {object_type} contains: \")\n                error_message_components.extend(\n                    (\n                        f\"field {field} of suppressed type \"\n                        f\"{visitor.fields_to_suppress[object_type][field]}, \"\n                        for field in visitor.fields_to_suppress[object_type]\n                    )\n                )\n            error_message_components.append(\n                \"A schema containing a field that is of a nonexistent type is invalid. To fix \"\n                \"this, suppress the previously-mentioned fields using the field_renamings argument \"\n                \"of rename_schema.\"\n            )\n        error_message_components.append(\n            \"Note that adding suppressions may lead to other types, fields, etc. requiring \"\n            \"suppression so you may need to iterate on this before getting a legal schema.\"\n        )\n        raise CascadingSuppressionError(\"\\n\".join(error_message_components))\n    if visitor.invalid_type_names or visitor.invalid_field_names:\n        error_message_components = [\n            \"Applying the renaming would involve names that are not valid, non-reserved \"\n",
        "target_code_len": 2415,
        "diff_format": "@@ -417,4 +329,44 @@\n     renamed_schema_ast = visit(schema_ast, visitor)\n+    if (\n+        visitor.object_types_to_suppress\n+        or visitor.union_types_to_suppress\n+        or visitor.fields_to_suppress\n+    ):\n+        error_message_components = [\n+            \"Renamings would require further suppressions to produce a valid renamed schema.\"\n+        ]\n+        if visitor.object_types_to_suppress:\n+            error_message_components.append(\n+                f\"The following object types have no non-suppressed fields, which is invalid: \"\n+                f\"{sorted(visitor.object_types_to_suppress)}. To fix this, suppress the \"\n+                f\"previously-mentioned types using the type_renamings argument of rename_schema.\"\n+            )\n+        if visitor.union_types_to_suppress:\n+            error_message_components.append(\n+                f\"The following union types have no non-suppressed types, which is invalid: \"\n+                f\"{sorted(visitor.union_types_to_suppress)}. To fix this, suppress the \"\n+                \"previously-mentioned unions using the type_renamings argument of rename_schema.\"\n+            )\n+        if visitor.fields_to_suppress:\n+            for object_type in visitor.fields_to_suppress:\n+                error_message_components.append(f\"Object type {object_type} contains: \")\n+                error_message_components.extend(\n+                    (\n+                        f\"field {field} of suppressed type \"\n+                        f\"{visitor.fields_to_suppress[object_type][field]}, \"\n+                        for field in visitor.fields_to_suppress[object_type]\n+                    )\n+                )\n+            error_message_components.append(\n+                \"A schema containing a field that is of a nonexistent type is invalid. To fix \"\n+                \"this, suppress the previously-mentioned fields using the field_renamings argument \"\n+                \"of rename_schema.\"\n+            )\n+        error_message_components.append(\n+            \"Note that adding suppressions may lead to other types, fields, etc. requiring \"\n+            \"suppression so you may need to iterate on this before getting a legal schema.\"\n+        )\n+        raise CascadingSuppressionError(\"\\n\".join(error_message_components))\n     if visitor.invalid_type_names or visitor.invalid_field_names:\n-        explanation = (\n+        error_message_components = [\n             \"Applying the renaming would involve names that are not valid, non-reserved \"\n",
        "source_code_with_indent": "    renamed_schema_ast = visit(schema_ast, visitor)\n    if visitor.invalid_type_names or visitor.invalid_field_names:\n        <IND>explanation = (\n            \"Applying the renaming would involve names that are not valid, non-reserved \"\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    renamed_schema_ast = visit(schema_ast, visitor)\n    if (\n        visitor.object_types_to_suppress\n        or visitor.union_types_to_suppress\n        or visitor.fields_to_suppress\n    ):\n        <IND>error_message_components = [\n            \"Renamings would require further suppressions to produce a valid renamed schema.\"\n        ]\n        if visitor.object_types_to_suppress:\n            <IND>error_message_components.append(\n                f\"The following object types have no non-suppressed fields, which is invalid: \"\n                f\"{sorted(visitor.object_types_to_suppress)}. To fix this, suppress the \"\n                f\"previously-mentioned types using the type_renamings argument of rename_schema.\"\n            )\n        <DED>if visitor.union_types_to_suppress:\n            <IND>error_message_components.append(\n                f\"The following union types have no non-suppressed types, which is invalid: \"\n                f\"{sorted(visitor.union_types_to_suppress)}. To fix this, suppress the \"\n                \"previously-mentioned unions using the type_renamings argument of rename_schema.\"\n            )\n        <DED>if visitor.fields_to_suppress:\n            <IND>for object_type in visitor.fields_to_suppress:\n                <IND>error_message_components.append(f\"Object type {object_type} contains: \")\n                error_message_components.extend(\n                    (\n                        f\"field {field} of suppressed type \"\n                        f\"{visitor.fields_to_suppress[object_type][field]}, \"\n                        for field in visitor.fields_to_suppress[object_type]\n                    )\n                )\n            <DED>error_message_components.append(\n                \"A schema containing a field that is of a nonexistent type is invalid. To fix \"\n                \"this, suppress the previously-mentioned fields using the field_renamings argument \"\n                \"of rename_schema.\"\n            )\n        <DED>error_message_components.append(\n            \"Note that adding suppressions may lead to other types, fields, etc. requiring \"\n            \"suppression so you may need to iterate on this before getting a legal schema.\"\n        )\n        raise CascadingSuppressionError(\"\\n\".join(error_message_components))\n    <DED>if visitor.invalid_type_names or visitor.invalid_field_names:\n        <IND>error_message_components = [\n            \"Applying the renaming would involve names that are not valid, non-reserved \"\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "            \"start with double underscores.\"\n        )\n        invalid_type_names_message = None\n        if visitor.invalid_type_names:\n            sorted_invalid_type_names = sorted(visitor.invalid_type_names.items())\n            invalid_type_names_message = (\n                f\"The following is a list of tuples that describes what needs to be fixed for type \"\n",
        "source_code_len": 363,
        "target_code": "            \"start with double underscores.\"\n        ]\n        if visitor.invalid_type_names:\n            sorted_invalid_type_names = sorted(visitor.invalid_type_names.items())\n            error_message_components.append(\n                f\"The following is a list of tuples that describes what needs to be fixed for type \"\n",
        "target_code_len": 323,
        "diff_format": "@@ -423,7 +375,6 @@\n             \"start with double underscores.\"\n-        )\n-        invalid_type_names_message = None\n+        ]\n         if visitor.invalid_type_names:\n             sorted_invalid_type_names = sorted(visitor.invalid_type_names.items())\n-            invalid_type_names_message = (\n+            error_message_components.append(\n                 f\"The following is a list of tuples that describes what needs to be fixed for type \"\n",
        "source_code_with_indent": "            \"start with double underscores.\"\n        )\n        invalid_type_names_message = None\n        if visitor.invalid_type_names:\n            <IND>sorted_invalid_type_names = sorted(visitor.invalid_type_names.items())\n            invalid_type_names_message = (\n                f\"The following is a list of tuples that describes what needs to be fixed for type \"\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "            \"start with double underscores.\"\n        ]\n        if visitor.invalid_type_names:\n            <IND>sorted_invalid_type_names = sorted(visitor.invalid_type_names.items())\n            error_message_components.append(\n                f\"The following is a list of tuples that describes what needs to be fixed for type \"\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": true,
        "has_suppression": false,
        "source_code": "            )\n        error_message_components = [\n            explanation,\n            invalid_type_names_message,\n            invalid_field_names_message,\n        ]\n        raise InvalidNameError(\"\\n\".join([i for i in error_message_components if i is not None]))\n",
        "source_code_len": 265,
        "target_code": "            )\n        raise InvalidNameError(\"\\n\".join([i for i in error_message_components if i is not None]))\n",
        "target_code_len": 112,
        "diff_format": "@@ -446,7 +396,2 @@\n             )\n-        error_message_components = [\n-            explanation,\n-            invalid_type_names_message,\n-            invalid_field_names_message,\n-        ]\n         raise InvalidNameError(\"\\n\".join([i for i in error_message_components if i is not None]))\n",
        "source_code_with_indent": "            )\n        <DED>error_message_components = [\n            explanation,\n            invalid_type_names_message,\n            invalid_field_names_message,\n        ]\n        raise InvalidNameError(\"\\n\".join([i for i in error_message_components if i is not None]))\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "            )\n        <DED>raise InvalidNameError(\"\\n\".join([i for i in error_message_components if i is not None]))\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "        self.types_involving_interfaces_with_field_renamings = set()\n\n",
        "source_code_len": 70,
        "target_code": "        self.types_involving_interfaces_with_field_renamings = set()\n        self.object_types_to_suppress = set()\n        self.union_types_to_suppress = set()\n        self.fields_to_suppress = {}\n\n",
        "target_code_len": 198,
        "diff_format": "@@ -722,2 +682,5 @@\n         self.types_involving_interfaces_with_field_renamings = set()\n+        self.object_types_to_suppress = set()\n+        self.union_types_to_suppress = set()\n+        self.fields_to_suppress = {}\n \n",
        "source_code_with_indent": "        self.types_involving_interfaces_with_field_renamings = set()\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "        self.types_involving_interfaces_with_field_renamings = set()\n        self.object_types_to_suppress = set()\n        self.union_types_to_suppress = set()\n        self.fields_to_suppress = {}\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": true,
        "has_suppression": false,
        "source_code": "\nclass CascadingSuppressionCheckVisitor(Visitor):\n    \"\"\"Traverse the schema to check for cascading suppression issues.\n\n    The fields_to_suppress attribute records non-suppressed fields that depend on suppressed types.\n    The union_types_to_suppress attribute records unions that had all its members suppressed.\n    The types_to_suppress attribute records types for which all fields were suppressed.\n\n    After calling visit() on the schema using this visitor, if any of these attributes are non-empty\n    then there are further suppressions required to produce a legal schema so the code should then\n    raise a CascadingSuppressionError.\n\n    \"\"\"\n\n    # For a type named T, and its field named F whose type has name V, this dict would be\n    # {\"T\": {\"F\": \"V\"}}\n    fields_to_suppress: Dict[str, Dict[str, str]]\n    union_types_to_suppress: List[UnionTypeDefinitionNode]\n    types_to_suppress: Set[str]\n\n    def __init__(\n        self,\n        type_renamings: Mapping[str, Optional[str]],\n        field_renamings: Mapping[str, Mapping[str, Set[str]]],\n        query_type: str,\n    ) -> None:\n        \"\"\"Create a visitor to check that suppression does not cause an illegal state.\n\n        Args:\n            type_renamings: maps original type name to renamed name or None (for type suppression).\n                            A type named \"Foo\" will be unchanged iff type_renamings does not map\n                            \"Foo\" to anything, i.e. \"Foo\" not in type_renamings\n            field_renamings: maps type names to the field renamings for that type. The renamings map\n                             field names belonging to the type to a set of field names for the\n                             renamed schema\n            query_type: name of the query type (e.g. RootSchemaQuery)\n        \"\"\"\n        self.type_renamings = type_renamings\n        self.field_renamings = field_renamings\n        self.query_type = query_type\n        self.current_type: Optional[str] = None\n        self.fields_to_suppress = {}\n        self.union_types_to_suppress = []\n        self.types_to_suppress = set()\n\n    def enter_object_type_definition(\n        self,\n        node: ObjectTypeDefinitionNode,\n        key: Any,\n        parent: Any,\n        path: List[Any],\n        ancestors: List[Any],\n    ) -> None:\n        \"\"\"Record the current type that the visitor is traversing.\"\"\"\n        self.current_type = node.name.value\n        if self.current_type not in self.field_renamings:\n            # No field renamings for current type, so it's impossible for all its fields to have\n            # been suppressed.\n            return\n        current_type_field_renamings = self.field_renamings[self.current_type]\n        for field in node.fields:\n            field_name = field.name.value\n            if (\n                field_name not in current_type_field_renamings\n                or current_type_field_renamings[field_name]\n            ):\n                # Do nothing if there's at least one field for the current type that hasn't been\n                # suppressed, either because field renamings didn't contain an entry for field_name\n                # or if it didn't suppress the field\n                return\n        self.types_to_suppress.add(self.current_type)\n\n    def leave_object_type_definition(\n        self,\n        node: ObjectTypeDefinitionNode,\n        key: Any,\n        parent: Any,\n        path: List[Any],\n        ancestors: List[Any],\n    ) -> None:\n        \"\"\"Finish traversing the current type node.\"\"\"\n        self.current_type = None\n\n    def enter_field_definition(\n        self,\n        node: FieldDefinitionNode,\n        key: Any,\n        parent: Any,\n        path: List[Any],\n        ancestors: List[Any],\n    ) -> None:\n        \"\"\"Check that no type Bar contains a field of type Foo, where Foo is suppressed.\"\"\"\n        if self.current_type == self.query_type:\n            return IDLE\n        # At a field of a type that is not the query type\n        field_name = node.name.value\n        field_type = get_ast_with_non_null_and_list_stripped(node.type).name.value\n        if self.type_renamings.get(field_type, field_type):\n            return IDLE\n        # Reaching this point means this field is of a type to be suppressed.\n        if self.current_type is None:\n            raise AssertionError(\n                \"Entered a field not in any ObjectTypeDefinition scope because \"\n                \"self.current_type is None\"\n            )\n        if self.current_type == field_type:\n            # Then node corresponds to a field belonging to type T that is also of type T.\n            # Therefore, we don't need to explicitly suppress the field as well and this should not\n            # raise errors.\n            return IDLE\n        if self.field_renamings.get(self.current_type, {}).get(field_name, {field_name}) == set():\n            # Field was also suppressed so this should not raise errors.\n            return IDLE\n        if self.current_type not in self.fields_to_suppress:\n            self.fields_to_suppress[self.current_type] = {}\n        self.fields_to_suppress[self.current_type][field_name] = field_type\n        return IDLE\n\n    def enter_union_type_definition(\n        self,\n        node: UnionTypeDefinitionNode,\n        key: Any,\n        parent: Any,\n        path: List[Any],\n        ancestors: List[Any],\n    ) -> None:\n        \"\"\"Check that each union still has at least one non-suppressed member.\"\"\"\n        union_name = node.name.value\n        # Check if all the union members are suppressed.\n        for union_member in node.types:\n            union_member_type = get_ast_with_non_null_and_list_stripped(union_member).name.value\n            if self.type_renamings.get(union_member_type, union_member_type):\n                # Then at least one member of the union is not suppressed, so there is no cascading\n                # suppression error concern.\n                return IDLE\n        if self.type_renamings.get(union_name, union_name) is None:\n            # If the union is also suppressed, then nothing needs to happen here\n            return IDLE\n        self.union_types_to_suppress.append(node)\n\n        return IDLE\n\n\nclass SuppressionNotImplementedVisitor(Visitor):\n",
        "source_code_len": 6207,
        "target_code": "\nclass SuppressionNotImplementedVisitor(Visitor):\n",
        "target_code_len": 50,
        "diff_format": "@@ -947,144 +979,2 @@\n \n-class CascadingSuppressionCheckVisitor(Visitor):\n-    \"\"\"Traverse the schema to check for cascading suppression issues.\n-\n-    The fields_to_suppress attribute records non-suppressed fields that depend on suppressed types.\n-    The union_types_to_suppress attribute records unions that had all its members suppressed.\n-    The types_to_suppress attribute records types for which all fields were suppressed.\n-\n-    After calling visit() on the schema using this visitor, if any of these attributes are non-empty\n-    then there are further suppressions required to produce a legal schema so the code should then\n-    raise a CascadingSuppressionError.\n-\n-    \"\"\"\n-\n-    # For a type named T, and its field named F whose type has name V, this dict would be\n-    # {\"T\": {\"F\": \"V\"}}\n-    fields_to_suppress: Dict[str, Dict[str, str]]\n-    union_types_to_suppress: List[UnionTypeDefinitionNode]\n-    types_to_suppress: Set[str]\n-\n-    def __init__(\n-        self,\n-        type_renamings: Mapping[str, Optional[str]],\n-        field_renamings: Mapping[str, Mapping[str, Set[str]]],\n-        query_type: str,\n-    ) -> None:\n-        \"\"\"Create a visitor to check that suppression does not cause an illegal state.\n-\n-        Args:\n-            type_renamings: maps original type name to renamed name or None (for type suppression).\n-                            A type named \"Foo\" will be unchanged iff type_renamings does not map\n-                            \"Foo\" to anything, i.e. \"Foo\" not in type_renamings\n-            field_renamings: maps type names to the field renamings for that type. The renamings map\n-                             field names belonging to the type to a set of field names for the\n-                             renamed schema\n-            query_type: name of the query type (e.g. RootSchemaQuery)\n-        \"\"\"\n-        self.type_renamings = type_renamings\n-        self.field_renamings = field_renamings\n-        self.query_type = query_type\n-        self.current_type: Optional[str] = None\n-        self.fields_to_suppress = {}\n-        self.union_types_to_suppress = []\n-        self.types_to_suppress = set()\n-\n-    def enter_object_type_definition(\n-        self,\n-        node: ObjectTypeDefinitionNode,\n-        key: Any,\n-        parent: Any,\n-        path: List[Any],\n-        ancestors: List[Any],\n-    ) -> None:\n-        \"\"\"Record the current type that the visitor is traversing.\"\"\"\n-        self.current_type = node.name.value\n-        if self.current_type not in self.field_renamings:\n-            # No field renamings for current type, so it's impossible for all its fields to have\n-            # been suppressed.\n-            return\n-        current_type_field_renamings = self.field_renamings[self.current_type]\n-        for field in node.fields:\n-            field_name = field.name.value\n-            if (\n-                field_name not in current_type_field_renamings\n-                or current_type_field_renamings[field_name]\n-            ):\n-                # Do nothing if there's at least one field for the current type that hasn't been\n-                # suppressed, either because field renamings didn't contain an entry for field_name\n-                # or if it didn't suppress the field\n-                return\n-        self.types_to_suppress.add(self.current_type)\n-\n-    def leave_object_type_definition(\n-        self,\n-        node: ObjectTypeDefinitionNode,\n-        key: Any,\n-        parent: Any,\n-        path: List[Any],\n-        ancestors: List[Any],\n-    ) -> None:\n-        \"\"\"Finish traversing the current type node.\"\"\"\n-        self.current_type = None\n-\n-    def enter_field_definition(\n-        self,\n-        node: FieldDefinitionNode,\n-        key: Any,\n-        parent: Any,\n-        path: List[Any],\n-        ancestors: List[Any],\n-    ) -> None:\n-        \"\"\"Check that no type Bar contains a field of type Foo, where Foo is suppressed.\"\"\"\n-        if self.current_type == self.query_type:\n-            return IDLE\n-        # At a field of a type that is not the query type\n-        field_name = node.name.value\n-        field_type = get_ast_with_non_null_and_list_stripped(node.type).name.value\n-        if self.type_renamings.get(field_type, field_type):\n-            return IDLE\n-        # Reaching this point means this field is of a type to be suppressed.\n-        if self.current_type is None:\n-            raise AssertionError(\n-                \"Entered a field not in any ObjectTypeDefinition scope because \"\n-                \"self.current_type is None\"\n-            )\n-        if self.current_type == field_type:\n-            # Then node corresponds to a field belonging to type T that is also of type T.\n-            # Therefore, we don't need to explicitly suppress the field as well and this should not\n-            # raise errors.\n-            return IDLE\n-        if self.field_renamings.get(self.current_type, {}).get(field_name, {field_name}) == set():\n-            # Field was also suppressed so this should not raise errors.\n-            return IDLE\n-        if self.current_type not in self.fields_to_suppress:\n-            self.fields_to_suppress[self.current_type] = {}\n-        self.fields_to_suppress[self.current_type][field_name] = field_type\n-        return IDLE\n-\n-    def enter_union_type_definition(\n-        self,\n-        node: UnionTypeDefinitionNode,\n-        key: Any,\n-        parent: Any,\n-        path: List[Any],\n-        ancestors: List[Any],\n-    ) -> None:\n-        \"\"\"Check that each union still has at least one non-suppressed member.\"\"\"\n-        union_name = node.name.value\n-        # Check if all the union members are suppressed.\n-        for union_member in node.types:\n-            union_member_type = get_ast_with_non_null_and_list_stripped(union_member).name.value\n-            if self.type_renamings.get(union_member_type, union_member_type):\n-                # Then at least one member of the union is not suppressed, so there is no cascading\n-                # suppression error concern.\n-                return IDLE\n-        if self.type_renamings.get(union_name, union_name) is None:\n-            # If the union is also suppressed, then nothing needs to happen here\n-            return IDLE\n-        self.union_types_to_suppress.append(node)\n-\n-        return IDLE\n-\n-\n class SuppressionNotImplementedVisitor(Visitor):\n",
        "source_code_with_indent": "\n<DED><DED>class CascadingSuppressionCheckVisitor(Visitor):\n    <IND>\"\"\"Traverse the schema to check for cascading suppression issues.\n\n    The fields_to_suppress attribute records non-suppressed fields that depend on suppressed types.\n    The union_types_to_suppress attribute records unions that had all its members suppressed.\n    The types_to_suppress attribute records types for which all fields were suppressed.\n\n    After calling visit() on the schema using this visitor, if any of these attributes are non-empty\n    then there are further suppressions required to produce a legal schema so the code should then\n    raise a CascadingSuppressionError.\n\n    \"\"\"\n\n    # For a type named T, and its field named F whose type has name V, this dict would be\n    # {\"T\": {\"F\": \"V\"}}\n    fields_to_suppress: Dict[str, Dict[str, str]]\n    union_types_to_suppress: List[UnionTypeDefinitionNode]\n    types_to_suppress: Set[str]\n\n    def __init__(\n        self,\n        type_renamings: Mapping[str, Optional[str]],\n        field_renamings: Mapping[str, Mapping[str, Set[str]]],\n        query_type: str,\n    ) -> None:\n        <IND>\"\"\"Create a visitor to check that suppression does not cause an illegal state.\n\n        Args:\n            type_renamings: maps original type name to renamed name or None (for type suppression).\n                            A type named \"Foo\" will be unchanged iff type_renamings does not map\n                            \"Foo\" to anything, i.e. \"Foo\" not in type_renamings\n            field_renamings: maps type names to the field renamings for that type. The renamings map\n                             field names belonging to the type to a set of field names for the\n                             renamed schema\n            query_type: name of the query type (e.g. RootSchemaQuery)\n        \"\"\"\n        self.type_renamings = type_renamings\n        self.field_renamings = field_renamings\n        self.query_type = query_type\n        self.current_type: Optional[str] = None\n        self.fields_to_suppress = {}\n        self.union_types_to_suppress = []\n        self.types_to_suppress = set()\n\n    <DED>def enter_object_type_definition(\n        self,\n        node: ObjectTypeDefinitionNode,\n        key: Any,\n        parent: Any,\n        path: List[Any],\n        ancestors: List[Any],\n    ) -> None:\n        <IND>\"\"\"Record the current type that the visitor is traversing.\"\"\"\n        self.current_type = node.name.value\n        if self.current_type not in self.field_renamings:\n            # No field renamings for current type, so it's impossible for all its fields to have\n            # been suppressed.\n            <IND>return\n        <DED>current_type_field_renamings = self.field_renamings[self.current_type]\n        for field in node.fields:\n            <IND>field_name = field.name.value\n            if (\n                field_name not in current_type_field_renamings\n                or current_type_field_renamings[field_name]\n            ):\n                # Do nothing if there's at least one field for the current type that hasn't been\n                # suppressed, either because field renamings didn't contain an entry for field_name\n                # or if it didn't suppress the field\n                <IND>return\n        <DED><DED>self.types_to_suppress.add(self.current_type)\n\n    <DED>def leave_object_type_definition(\n        self,\n        node: ObjectTypeDefinitionNode,\n        key: Any,\n        parent: Any,\n        path: List[Any],\n        ancestors: List[Any],\n    ) -> None:\n        <IND>\"\"\"Finish traversing the current type node.\"\"\"\n        self.current_type = None\n\n    <DED>def enter_field_definition(\n        self,\n        node: FieldDefinitionNode,\n        key: Any,\n        parent: Any,\n        path: List[Any],\n        ancestors: List[Any],\n    ) -> None:\n        <IND>\"\"\"Check that no type Bar contains a field of type Foo, where Foo is suppressed.\"\"\"\n        if self.current_type == self.query_type:\n            <IND>return IDLE\n        # At a field of a type that is not the query type\n        <DED>field_name = node.name.value\n        field_type = get_ast_with_non_null_and_list_stripped(node.type).name.value\n        if self.type_renamings.get(field_type, field_type):\n            <IND>return IDLE\n        # Reaching this point means this field is of a type to be suppressed.\n        <DED>if self.current_type is None:\n            <IND>raise AssertionError(\n                \"Entered a field not in any ObjectTypeDefinition scope because \"\n                \"self.current_type is None\"\n            )\n        <DED>if self.current_type == field_type:\n            # Then node corresponds to a field belonging to type T that is also of type T.\n            # Therefore, we don't need to explicitly suppress the field as well and this should not\n            # raise errors.\n            <IND>return IDLE\n        <DED>if self.field_renamings.get(self.current_type, {}).get(field_name, {field_name}) == set():\n            # Field was also suppressed so this should not raise errors.\n            <IND>return IDLE\n        <DED>if self.current_type not in self.fields_to_suppress:\n            <IND>self.fields_to_suppress[self.current_type] = {}\n        <DED>self.fields_to_suppress[self.current_type][field_name] = field_type\n        return IDLE\n\n    <DED>def enter_union_type_definition(\n        self,\n        node: UnionTypeDefinitionNode,\n        key: Any,\n        parent: Any,\n        path: List[Any],\n        ancestors: List[Any],\n    ) -> None:\n        <IND>\"\"\"Check that each union still has at least one non-suppressed member.\"\"\"\n        union_name = node.name.value\n        # Check if all the union members are suppressed.\n        for union_member in node.types:\n            <IND>union_member_type = get_ast_with_non_null_and_list_stripped(union_member).name.value\n            if self.type_renamings.get(union_member_type, union_member_type):\n                # Then at least one member of the union is not suppressed, so there is no cascading\n                # suppression error concern.\n                <IND>return IDLE\n        <DED><DED>if self.type_renamings.get(union_name, union_name) is None:\n            # If the union is also suppressed, then nothing needs to happen here\n            <IND>return IDLE\n        <DED>self.union_types_to_suppress.append(node)\n\n        return IDLE\n\n\n<DED><DED>class SuppressionNotImplementedVisitor(Visitor):\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n<DED><DED>class SuppressionNotImplementedVisitor(Visitor):\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "kensho-technologies/graphql-compiler",
    "commit": "44c63aa9bfae8655d9214445066eaa13a203b4dd",
    "filename": "graphql_compiler/schema_transformation/rename_schema.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/kensho-technologies-graphql-compiler/graphql_compiler/schema_transformation/rename_schema.py",
    "file_hunks_size": 14,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "graphql_compiler/schema_transformation/rename_schema.py:1062:32 Incompatible parameter type [6]: Expected `str` for 1st positional only parameter to call `dict.__getitem__` but got `Optional[str]`.",
    "message": " Expected `str` for 1st positional only parameter to call `dict.__getitem__` but got `Optional[str]`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 1062,
    "warning_line": "        self.fields_to_suppress[self.current_type][field_name] = field_type",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n    _validate_renamings(schema_ast, type_renamings, field_renamings, query_type)\n\n",
        "source_code_len": 83,
        "target_code": "\n    _ensure_no_unsupported_suppressions(schema_ast, type_renamings)\n\n",
        "target_code_len": 70,
        "diff_format": "@@ -237,3 +237,3 @@\n \n-    _validate_renamings(schema_ast, type_renamings, field_renamings, query_type)\n+    _ensure_no_unsupported_suppressions(schema_ast, type_renamings)\n \n",
        "source_code_with_indent": "\n    _validate_renamings(schema_ast, type_renamings, field_renamings, query_type)\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n    _ensure_no_unsupported_suppressions(schema_ast, type_renamings)\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": true,
        "has_suppression": false,
        "source_code": "    )\n\n\ndef _validate_renamings(\n    schema_ast: DocumentNode,\n    type_renamings: Mapping[str, Optional[str]],\n    field_renamings: Mapping[str, Mapping[str, Set[str]]],\n    query_type: str,\n) -> None:\n    \"\"\"Validate the type_renamings argument before attempting to rename the schema.\n\n    Check for fields with suppressed types or unions whose members were all suppressed. Also,\n    confirm type_renamings contains no enums, interfaces, or interface implementation suppressions\n    because that hasn't been implemented yet.\n\n    The input AST will not be modified.\n\n    Args:\n        schema_ast: represents a valid schema that does not contain extensions, input object\n                    definitions, mutations, or subscriptions, whose fields of the query type share\n                    the same name as the types they query. Not modified by this function\n        type_renamings: maps original type name to renamed name or None (for type suppression). A\n                        type named \"Foo\" will be unchanged iff type_renamings does not map \"Foo\" to\n                        anything, i.e. \"Foo\" not in type_renamings\n        field_renamings: maps type names to the field renamings for that type. The renamings map\n                         field names belonging to the type to a set of field names for the\n                         renamed schema\n        query_type: name of the query type, e.g. 'RootSchemaQuery'\n\n    Raises:\n        - CascadingSuppressionError if a type/field suppression would require further suppressions\n        - NotImplementedError if type_renamings attempts to suppress an enum, an interface, or a\n          type implementing an interface\n    \"\"\"\n    _ensure_no_cascading_type_suppressions(schema_ast, type_renamings, field_renamings, query_type)\n    _ensure_no_unsupported_suppressions(schema_ast, type_renamings)\n\n\ndef _ensure_no_cascading_type_suppressions(\n    schema_ast: DocumentNode,\n    type_renamings: Mapping[str, Optional[str]],\n    field_renamings: Mapping[str, Mapping[str, Set[str]]],\n    query_type: str,\n) -> None:\n    \"\"\"Check for situations that would require further suppressions to produce a valid schema.\"\"\"\n    visitor = CascadingSuppressionCheckVisitor(type_renamings, field_renamings, query_type)\n    visit(schema_ast, visitor)\n    if visitor.fields_to_suppress or visitor.union_types_to_suppress or visitor.types_to_suppress:\n        error_message_components = [\n            \"Renamings would require further suppressions to produce a valid renamed schema.\"\n        ]\n        if visitor.fields_to_suppress:\n            for object_type in visitor.fields_to_suppress:\n                error_message_components.append(f\"Object type {object_type} contains: \")\n                error_message_components.extend(\n                    (\n                        f\"field {field} of suppressed type \"\n                        f\"{visitor.fields_to_suppress[object_type][field]}, \"\n                        for field in visitor.fields_to_suppress[object_type]\n                    )\n                )\n            error_message_components.append(\n                \"A schema containing a field that is of a nonexistent type is invalid. To fix \"\n                \"this, suppress the previously-mentioned fields using the field_renamings argument \"\n                \"of rename_schema.\"\n            )\n        if visitor.union_types_to_suppress:\n            for union_type in visitor.union_types_to_suppress:\n                error_message_components.append(\n                    f\"Union type {union_type} has no non-suppressed members: \"\n                )\n                error_message_components.extend(\n                    (union_member.name.value for union_member in union_type.types)\n                )\n            error_message_components.append(\n                \"A schema containing a union with no members is invalid. To fix this, suppress the \"\n                \"previously-mentioned unions using the type_renamings argument of rename_schema.\"\n            )\n        if visitor.types_to_suppress:\n            error_message_components.append(\n                f\"The following types have no non-suppressed fields, which is invalid: \"\n                f\"{sorted(visitor.types_to_suppress)}. To fix this, suppress the \"\n                f\"previously-mentioned types using the type_renamings argument of rename_schema.\"\n            )\n        error_message_components.append(\n            \"Note that adding suppressions may lead to other types, fields, etc. requiring \"\n            \"suppression so you may need to iterate on this before getting a legal schema.\"\n        )\n        raise CascadingSuppressionError(\"\\n\".join(error_message_components))\n\n",
        "source_code_len": 4671,
        "target_code": "    )\n\n",
        "target_code_len": 7,
        "diff_format": "@@ -251,90 +251,2 @@\n     )\n-\n-\n-def _validate_renamings(\n-    schema_ast: DocumentNode,\n-    type_renamings: Mapping[str, Optional[str]],\n-    field_renamings: Mapping[str, Mapping[str, Set[str]]],\n-    query_type: str,\n-) -> None:\n-    \"\"\"Validate the type_renamings argument before attempting to rename the schema.\n-\n-    Check for fields with suppressed types or unions whose members were all suppressed. Also,\n-    confirm type_renamings contains no enums, interfaces, or interface implementation suppressions\n-    because that hasn't been implemented yet.\n-\n-    The input AST will not be modified.\n-\n-    Args:\n-        schema_ast: represents a valid schema that does not contain extensions, input object\n-                    definitions, mutations, or subscriptions, whose fields of the query type share\n-                    the same name as the types they query. Not modified by this function\n-        type_renamings: maps original type name to renamed name or None (for type suppression). A\n-                        type named \"Foo\" will be unchanged iff type_renamings does not map \"Foo\" to\n-                        anything, i.e. \"Foo\" not in type_renamings\n-        field_renamings: maps type names to the field renamings for that type. The renamings map\n-                         field names belonging to the type to a set of field names for the\n-                         renamed schema\n-        query_type: name of the query type, e.g. 'RootSchemaQuery'\n-\n-    Raises:\n-        - CascadingSuppressionError if a type/field suppression would require further suppressions\n-        - NotImplementedError if type_renamings attempts to suppress an enum, an interface, or a\n-          type implementing an interface\n-    \"\"\"\n-    _ensure_no_cascading_type_suppressions(schema_ast, type_renamings, field_renamings, query_type)\n-    _ensure_no_unsupported_suppressions(schema_ast, type_renamings)\n-\n-\n-def _ensure_no_cascading_type_suppressions(\n-    schema_ast: DocumentNode,\n-    type_renamings: Mapping[str, Optional[str]],\n-    field_renamings: Mapping[str, Mapping[str, Set[str]]],\n-    query_type: str,\n-) -> None:\n-    \"\"\"Check for situations that would require further suppressions to produce a valid schema.\"\"\"\n-    visitor = CascadingSuppressionCheckVisitor(type_renamings, field_renamings, query_type)\n-    visit(schema_ast, visitor)\n-    if visitor.fields_to_suppress or visitor.union_types_to_suppress or visitor.types_to_suppress:\n-        error_message_components = [\n-            \"Renamings would require further suppressions to produce a valid renamed schema.\"\n-        ]\n-        if visitor.fields_to_suppress:\n-            for object_type in visitor.fields_to_suppress:\n-                error_message_components.append(f\"Object type {object_type} contains: \")\n-                error_message_components.extend(\n-                    (\n-                        f\"field {field} of suppressed type \"\n-                        f\"{visitor.fields_to_suppress[object_type][field]}, \"\n-                        for field in visitor.fields_to_suppress[object_type]\n-                    )\n-                )\n-            error_message_components.append(\n-                \"A schema containing a field that is of a nonexistent type is invalid. To fix \"\n-                \"this, suppress the previously-mentioned fields using the field_renamings argument \"\n-                \"of rename_schema.\"\n-            )\n-        if visitor.union_types_to_suppress:\n-            for union_type in visitor.union_types_to_suppress:\n-                error_message_components.append(\n-                    f\"Union type {union_type} has no non-suppressed members: \"\n-                )\n-                error_message_components.extend(\n-                    (union_member.name.value for union_member in union_type.types)\n-                )\n-            error_message_components.append(\n-                \"A schema containing a union with no members is invalid. To fix this, suppress the \"\n-                \"previously-mentioned unions using the type_renamings argument of rename_schema.\"\n-            )\n-        if visitor.types_to_suppress:\n-            error_message_components.append(\n-                f\"The following types have no non-suppressed fields, which is invalid: \"\n-                f\"{sorted(visitor.types_to_suppress)}. To fix this, suppress the \"\n-                f\"previously-mentioned types using the type_renamings argument of rename_schema.\"\n-            )\n-        error_message_components.append(\n-            \"Note that adding suppressions may lead to other types, fields, etc. requiring \"\n-            \"suppression so you may need to iterate on this before getting a legal schema.\"\n-        )\n-        raise CascadingSuppressionError(\"\\n\".join(error_message_components))\n \n",
        "source_code_with_indent": "    )\n\n\n<DED>def _validate_renamings(\n    schema_ast: DocumentNode,\n    type_renamings: Mapping[str, Optional[str]],\n    field_renamings: Mapping[str, Mapping[str, Set[str]]],\n    query_type: str,\n) -> None:\n    <IND>\"\"\"Validate the type_renamings argument before attempting to rename the schema.\n\n    Check for fields with suppressed types or unions whose members were all suppressed. Also,\n    confirm type_renamings contains no enums, interfaces, or interface implementation suppressions\n    because that hasn't been implemented yet.\n\n    The input AST will not be modified.\n\n    Args:\n        schema_ast: represents a valid schema that does not contain extensions, input object\n                    definitions, mutations, or subscriptions, whose fields of the query type share\n                    the same name as the types they query. Not modified by this function\n        type_renamings: maps original type name to renamed name or None (for type suppression). A\n                        type named \"Foo\" will be unchanged iff type_renamings does not map \"Foo\" to\n                        anything, i.e. \"Foo\" not in type_renamings\n        field_renamings: maps type names to the field renamings for that type. The renamings map\n                         field names belonging to the type to a set of field names for the\n                         renamed schema\n        query_type: name of the query type, e.g. 'RootSchemaQuery'\n\n    Raises:\n        - CascadingSuppressionError if a type/field suppression would require further suppressions\n        - NotImplementedError if type_renamings attempts to suppress an enum, an interface, or a\n          type implementing an interface\n    \"\"\"\n    _ensure_no_cascading_type_suppressions(schema_ast, type_renamings, field_renamings, query_type)\n    _ensure_no_unsupported_suppressions(schema_ast, type_renamings)\n\n\n<DED>def _ensure_no_cascading_type_suppressions(\n    schema_ast: DocumentNode,\n    type_renamings: Mapping[str, Optional[str]],\n    field_renamings: Mapping[str, Mapping[str, Set[str]]],\n    query_type: str,\n) -> None:\n    <IND>\"\"\"Check for situations that would require further suppressions to produce a valid schema.\"\"\"\n    visitor = CascadingSuppressionCheckVisitor(type_renamings, field_renamings, query_type)\n    visit(schema_ast, visitor)\n    if visitor.fields_to_suppress or visitor.union_types_to_suppress or visitor.types_to_suppress:\n        <IND>error_message_components = [\n            \"Renamings would require further suppressions to produce a valid renamed schema.\"\n        ]\n        if visitor.fields_to_suppress:\n            <IND>for object_type in visitor.fields_to_suppress:\n                <IND>error_message_components.append(f\"Object type {object_type} contains: \")\n                error_message_components.extend(\n                    (\n                        f\"field {field} of suppressed type \"\n                        f\"{visitor.fields_to_suppress[object_type][field]}, \"\n                        for field in visitor.fields_to_suppress[object_type]\n                    )\n                )\n            <DED>error_message_components.append(\n                \"A schema containing a field that is of a nonexistent type is invalid. To fix \"\n                \"this, suppress the previously-mentioned fields using the field_renamings argument \"\n                \"of rename_schema.\"\n            )\n        <DED>if visitor.union_types_to_suppress:\n            <IND>for union_type in visitor.union_types_to_suppress:\n                <IND>error_message_components.append(\n                    f\"Union type {union_type} has no non-suppressed members: \"\n                )\n                error_message_components.extend(\n                    (union_member.name.value for union_member in union_type.types)\n                )\n            <DED>error_message_components.append(\n                \"A schema containing a union with no members is invalid. To fix this, suppress the \"\n                \"previously-mentioned unions using the type_renamings argument of rename_schema.\"\n            )\n        <DED>if visitor.types_to_suppress:\n            <IND>error_message_components.append(\n                f\"The following types have no non-suppressed fields, which is invalid: \"\n                f\"{sorted(visitor.types_to_suppress)}. To fix this, suppress the \"\n                f\"previously-mentioned types using the type_renamings argument of rename_schema.\"\n            )\n        <DED>error_message_components.append(\n            \"Note that adding suppressions may lead to other types, fields, etc. requiring \"\n            \"suppression so you may need to iterate on this before getting a legal schema.\"\n        )\n        raise CascadingSuppressionError(\"\\n\".join(error_message_components))\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    )\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    renamed_schema_ast = visit(schema_ast, visitor)\n    if visitor.invalid_type_names or visitor.invalid_field_names:\n        explanation = (\n            \"Applying the renaming would involve names that are not valid, non-reserved \"\n",
        "source_code_len": 232,
        "target_code": "    renamed_schema_ast = visit(schema_ast, visitor)\n    if (\n        visitor.object_types_to_suppress\n        or visitor.union_types_to_suppress\n        or visitor.fields_to_suppress\n    ):\n        error_message_components = [\n            \"Renamings would require further suppressions to produce a valid renamed schema.\"\n        ]\n        if visitor.object_types_to_suppress:\n            error_message_components.append(\n                f\"The following object types have no non-suppressed fields, which is invalid: \"\n                f\"{sorted(visitor.object_types_to_suppress)}. To fix this, suppress the \"\n                f\"previously-mentioned types using the type_renamings argument of rename_schema.\"\n            )\n        if visitor.union_types_to_suppress:\n            error_message_components.append(\n                f\"The following union types have no non-suppressed types, which is invalid: \"\n                f\"{sorted(visitor.union_types_to_suppress)}. To fix this, suppress the \"\n                \"previously-mentioned unions using the type_renamings argument of rename_schema.\"\n            )\n        if visitor.fields_to_suppress:\n            for object_type in visitor.fields_to_suppress:\n                error_message_components.append(f\"Object type {object_type} contains: \")\n                error_message_components.extend(\n                    (\n                        f\"field {field} of suppressed type \"\n                        f\"{visitor.fields_to_suppress[object_type][field]}, \"\n                        for field in visitor.fields_to_suppress[object_type]\n                    )\n                )\n            error_message_components.append(\n                \"A schema containing a field that is of a nonexistent type is invalid. To fix \"\n                \"this, suppress the previously-mentioned fields using the field_renamings argument \"\n                \"of rename_schema.\"\n            )\n        error_message_components.append(\n            \"Note that adding suppressions may lead to other types, fields, etc. requiring \"\n            \"suppression so you may need to iterate on this before getting a legal schema.\"\n        )\n        raise CascadingSuppressionError(\"\\n\".join(error_message_components))\n    if visitor.invalid_type_names or visitor.invalid_field_names:\n        error_message_components = [\n            \"Applying the renaming would involve names that are not valid, non-reserved \"\n",
        "target_code_len": 2415,
        "diff_format": "@@ -417,4 +329,44 @@\n     renamed_schema_ast = visit(schema_ast, visitor)\n+    if (\n+        visitor.object_types_to_suppress\n+        or visitor.union_types_to_suppress\n+        or visitor.fields_to_suppress\n+    ):\n+        error_message_components = [\n+            \"Renamings would require further suppressions to produce a valid renamed schema.\"\n+        ]\n+        if visitor.object_types_to_suppress:\n+            error_message_components.append(\n+                f\"The following object types have no non-suppressed fields, which is invalid: \"\n+                f\"{sorted(visitor.object_types_to_suppress)}. To fix this, suppress the \"\n+                f\"previously-mentioned types using the type_renamings argument of rename_schema.\"\n+            )\n+        if visitor.union_types_to_suppress:\n+            error_message_components.append(\n+                f\"The following union types have no non-suppressed types, which is invalid: \"\n+                f\"{sorted(visitor.union_types_to_suppress)}. To fix this, suppress the \"\n+                \"previously-mentioned unions using the type_renamings argument of rename_schema.\"\n+            )\n+        if visitor.fields_to_suppress:\n+            for object_type in visitor.fields_to_suppress:\n+                error_message_components.append(f\"Object type {object_type} contains: \")\n+                error_message_components.extend(\n+                    (\n+                        f\"field {field} of suppressed type \"\n+                        f\"{visitor.fields_to_suppress[object_type][field]}, \"\n+                        for field in visitor.fields_to_suppress[object_type]\n+                    )\n+                )\n+            error_message_components.append(\n+                \"A schema containing a field that is of a nonexistent type is invalid. To fix \"\n+                \"this, suppress the previously-mentioned fields using the field_renamings argument \"\n+                \"of rename_schema.\"\n+            )\n+        error_message_components.append(\n+            \"Note that adding suppressions may lead to other types, fields, etc. requiring \"\n+            \"suppression so you may need to iterate on this before getting a legal schema.\"\n+        )\n+        raise CascadingSuppressionError(\"\\n\".join(error_message_components))\n     if visitor.invalid_type_names or visitor.invalid_field_names:\n-        explanation = (\n+        error_message_components = [\n             \"Applying the renaming would involve names that are not valid, non-reserved \"\n",
        "source_code_with_indent": "    renamed_schema_ast = visit(schema_ast, visitor)\n    if visitor.invalid_type_names or visitor.invalid_field_names:\n        <IND>explanation = (\n            \"Applying the renaming would involve names that are not valid, non-reserved \"\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    renamed_schema_ast = visit(schema_ast, visitor)\n    if (\n        visitor.object_types_to_suppress\n        or visitor.union_types_to_suppress\n        or visitor.fields_to_suppress\n    ):\n        <IND>error_message_components = [\n            \"Renamings would require further suppressions to produce a valid renamed schema.\"\n        ]\n        if visitor.object_types_to_suppress:\n            <IND>error_message_components.append(\n                f\"The following object types have no non-suppressed fields, which is invalid: \"\n                f\"{sorted(visitor.object_types_to_suppress)}. To fix this, suppress the \"\n                f\"previously-mentioned types using the type_renamings argument of rename_schema.\"\n            )\n        <DED>if visitor.union_types_to_suppress:\n            <IND>error_message_components.append(\n                f\"The following union types have no non-suppressed types, which is invalid: \"\n                f\"{sorted(visitor.union_types_to_suppress)}. To fix this, suppress the \"\n                \"previously-mentioned unions using the type_renamings argument of rename_schema.\"\n            )\n        <DED>if visitor.fields_to_suppress:\n            <IND>for object_type in visitor.fields_to_suppress:\n                <IND>error_message_components.append(f\"Object type {object_type} contains: \")\n                error_message_components.extend(\n                    (\n                        f\"field {field} of suppressed type \"\n                        f\"{visitor.fields_to_suppress[object_type][field]}, \"\n                        for field in visitor.fields_to_suppress[object_type]\n                    )\n                )\n            <DED>error_message_components.append(\n                \"A schema containing a field that is of a nonexistent type is invalid. To fix \"\n                \"this, suppress the previously-mentioned fields using the field_renamings argument \"\n                \"of rename_schema.\"\n            )\n        <DED>error_message_components.append(\n            \"Note that adding suppressions may lead to other types, fields, etc. requiring \"\n            \"suppression so you may need to iterate on this before getting a legal schema.\"\n        )\n        raise CascadingSuppressionError(\"\\n\".join(error_message_components))\n    <DED>if visitor.invalid_type_names or visitor.invalid_field_names:\n        <IND>error_message_components = [\n            \"Applying the renaming would involve names that are not valid, non-reserved \"\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "            \"start with double underscores.\"\n        )\n        invalid_type_names_message = None\n        if visitor.invalid_type_names:\n            sorted_invalid_type_names = sorted(visitor.invalid_type_names.items())\n            invalid_type_names_message = (\n                f\"The following is a list of tuples that describes what needs to be fixed for type \"\n",
        "source_code_len": 363,
        "target_code": "            \"start with double underscores.\"\n        ]\n        if visitor.invalid_type_names:\n            sorted_invalid_type_names = sorted(visitor.invalid_type_names.items())\n            error_message_components.append(\n                f\"The following is a list of tuples that describes what needs to be fixed for type \"\n",
        "target_code_len": 323,
        "diff_format": "@@ -423,7 +375,6 @@\n             \"start with double underscores.\"\n-        )\n-        invalid_type_names_message = None\n+        ]\n         if visitor.invalid_type_names:\n             sorted_invalid_type_names = sorted(visitor.invalid_type_names.items())\n-            invalid_type_names_message = (\n+            error_message_components.append(\n                 f\"The following is a list of tuples that describes what needs to be fixed for type \"\n",
        "source_code_with_indent": "            \"start with double underscores.\"\n        )\n        invalid_type_names_message = None\n        if visitor.invalid_type_names:\n            <IND>sorted_invalid_type_names = sorted(visitor.invalid_type_names.items())\n            invalid_type_names_message = (\n                f\"The following is a list of tuples that describes what needs to be fixed for type \"\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "            \"start with double underscores.\"\n        ]\n        if visitor.invalid_type_names:\n            <IND>sorted_invalid_type_names = sorted(visitor.invalid_type_names.items())\n            error_message_components.append(\n                f\"The following is a list of tuples that describes what needs to be fixed for type \"\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": true,
        "has_suppression": false,
        "source_code": "            )\n        error_message_components = [\n            explanation,\n            invalid_type_names_message,\n            invalid_field_names_message,\n        ]\n        raise InvalidNameError(\"\\n\".join([i for i in error_message_components if i is not None]))\n",
        "source_code_len": 265,
        "target_code": "            )\n        raise InvalidNameError(\"\\n\".join([i for i in error_message_components if i is not None]))\n",
        "target_code_len": 112,
        "diff_format": "@@ -446,7 +396,2 @@\n             )\n-        error_message_components = [\n-            explanation,\n-            invalid_type_names_message,\n-            invalid_field_names_message,\n-        ]\n         raise InvalidNameError(\"\\n\".join([i for i in error_message_components if i is not None]))\n",
        "source_code_with_indent": "            )\n        <DED>error_message_components = [\n            explanation,\n            invalid_type_names_message,\n            invalid_field_names_message,\n        ]\n        raise InvalidNameError(\"\\n\".join([i for i in error_message_components if i is not None]))\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "            )\n        <DED>raise InvalidNameError(\"\\n\".join([i for i in error_message_components if i is not None]))\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "        self.types_involving_interfaces_with_field_renamings = set()\n\n",
        "source_code_len": 70,
        "target_code": "        self.types_involving_interfaces_with_field_renamings = set()\n        self.object_types_to_suppress = set()\n        self.union_types_to_suppress = set()\n        self.fields_to_suppress = {}\n\n",
        "target_code_len": 198,
        "diff_format": "@@ -722,2 +682,5 @@\n         self.types_involving_interfaces_with_field_renamings = set()\n+        self.object_types_to_suppress = set()\n+        self.union_types_to_suppress = set()\n+        self.fields_to_suppress = {}\n \n",
        "source_code_with_indent": "        self.types_involving_interfaces_with_field_renamings = set()\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "        self.types_involving_interfaces_with_field_renamings = set()\n        self.object_types_to_suppress = set()\n        self.union_types_to_suppress = set()\n        self.fields_to_suppress = {}\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": true,
        "has_suppression": false,
        "source_code": "\nclass CascadingSuppressionCheckVisitor(Visitor):\n    \"\"\"Traverse the schema to check for cascading suppression issues.\n\n    The fields_to_suppress attribute records non-suppressed fields that depend on suppressed types.\n    The union_types_to_suppress attribute records unions that had all its members suppressed.\n    The types_to_suppress attribute records types for which all fields were suppressed.\n\n    After calling visit() on the schema using this visitor, if any of these attributes are non-empty\n    then there are further suppressions required to produce a legal schema so the code should then\n    raise a CascadingSuppressionError.\n\n    \"\"\"\n\n    # For a type named T, and its field named F whose type has name V, this dict would be\n    # {\"T\": {\"F\": \"V\"}}\n    fields_to_suppress: Dict[str, Dict[str, str]]\n    union_types_to_suppress: List[UnionTypeDefinitionNode]\n    types_to_suppress: Set[str]\n\n    def __init__(\n        self,\n        type_renamings: Mapping[str, Optional[str]],\n        field_renamings: Mapping[str, Mapping[str, Set[str]]],\n        query_type: str,\n    ) -> None:\n        \"\"\"Create a visitor to check that suppression does not cause an illegal state.\n\n        Args:\n            type_renamings: maps original type name to renamed name or None (for type suppression).\n                            A type named \"Foo\" will be unchanged iff type_renamings does not map\n                            \"Foo\" to anything, i.e. \"Foo\" not in type_renamings\n            field_renamings: maps type names to the field renamings for that type. The renamings map\n                             field names belonging to the type to a set of field names for the\n                             renamed schema\n            query_type: name of the query type (e.g. RootSchemaQuery)\n        \"\"\"\n        self.type_renamings = type_renamings\n        self.field_renamings = field_renamings\n        self.query_type = query_type\n        self.current_type: Optional[str] = None\n        self.fields_to_suppress = {}\n        self.union_types_to_suppress = []\n        self.types_to_suppress = set()\n\n    def enter_object_type_definition(\n        self,\n        node: ObjectTypeDefinitionNode,\n        key: Any,\n        parent: Any,\n        path: List[Any],\n        ancestors: List[Any],\n    ) -> None:\n        \"\"\"Record the current type that the visitor is traversing.\"\"\"\n        self.current_type = node.name.value\n        if self.current_type not in self.field_renamings:\n            # No field renamings for current type, so it's impossible for all its fields to have\n            # been suppressed.\n            return\n        current_type_field_renamings = self.field_renamings[self.current_type]\n        for field in node.fields:\n            field_name = field.name.value\n            if (\n                field_name not in current_type_field_renamings\n                or current_type_field_renamings[field_name]\n            ):\n                # Do nothing if there's at least one field for the current type that hasn't been\n                # suppressed, either because field renamings didn't contain an entry for field_name\n                # or if it didn't suppress the field\n                return\n        self.types_to_suppress.add(self.current_type)\n\n    def leave_object_type_definition(\n        self,\n        node: ObjectTypeDefinitionNode,\n        key: Any,\n        parent: Any,\n        path: List[Any],\n        ancestors: List[Any],\n    ) -> None:\n        \"\"\"Finish traversing the current type node.\"\"\"\n        self.current_type = None\n\n    def enter_field_definition(\n        self,\n        node: FieldDefinitionNode,\n        key: Any,\n        parent: Any,\n        path: List[Any],\n        ancestors: List[Any],\n    ) -> None:\n        \"\"\"Check that no type Bar contains a field of type Foo, where Foo is suppressed.\"\"\"\n        if self.current_type == self.query_type:\n            return IDLE\n        # At a field of a type that is not the query type\n        field_name = node.name.value\n        field_type = get_ast_with_non_null_and_list_stripped(node.type).name.value\n        if self.type_renamings.get(field_type, field_type):\n            return IDLE\n        # Reaching this point means this field is of a type to be suppressed.\n        if self.current_type is None:\n            raise AssertionError(\n                \"Entered a field not in any ObjectTypeDefinition scope because \"\n                \"self.current_type is None\"\n            )\n        if self.current_type == field_type:\n            # Then node corresponds to a field belonging to type T that is also of type T.\n            # Therefore, we don't need to explicitly suppress the field as well and this should not\n            # raise errors.\n            return IDLE\n        if self.field_renamings.get(self.current_type, {}).get(field_name, {field_name}) == set():\n            # Field was also suppressed so this should not raise errors.\n            return IDLE\n        if self.current_type not in self.fields_to_suppress:\n            self.fields_to_suppress[self.current_type] = {}\n        self.fields_to_suppress[self.current_type][field_name] = field_type\n        return IDLE\n\n    def enter_union_type_definition(\n        self,\n        node: UnionTypeDefinitionNode,\n        key: Any,\n        parent: Any,\n        path: List[Any],\n        ancestors: List[Any],\n    ) -> None:\n        \"\"\"Check that each union still has at least one non-suppressed member.\"\"\"\n        union_name = node.name.value\n        # Check if all the union members are suppressed.\n        for union_member in node.types:\n            union_member_type = get_ast_with_non_null_and_list_stripped(union_member).name.value\n            if self.type_renamings.get(union_member_type, union_member_type):\n                # Then at least one member of the union is not suppressed, so there is no cascading\n                # suppression error concern.\n                return IDLE\n        if self.type_renamings.get(union_name, union_name) is None:\n            # If the union is also suppressed, then nothing needs to happen here\n            return IDLE\n        self.union_types_to_suppress.append(node)\n\n        return IDLE\n\n\nclass SuppressionNotImplementedVisitor(Visitor):\n",
        "source_code_len": 6207,
        "target_code": "\nclass SuppressionNotImplementedVisitor(Visitor):\n",
        "target_code_len": 50,
        "diff_format": "@@ -947,144 +979,2 @@\n \n-class CascadingSuppressionCheckVisitor(Visitor):\n-    \"\"\"Traverse the schema to check for cascading suppression issues.\n-\n-    The fields_to_suppress attribute records non-suppressed fields that depend on suppressed types.\n-    The union_types_to_suppress attribute records unions that had all its members suppressed.\n-    The types_to_suppress attribute records types for which all fields were suppressed.\n-\n-    After calling visit() on the schema using this visitor, if any of these attributes are non-empty\n-    then there are further suppressions required to produce a legal schema so the code should then\n-    raise a CascadingSuppressionError.\n-\n-    \"\"\"\n-\n-    # For a type named T, and its field named F whose type has name V, this dict would be\n-    # {\"T\": {\"F\": \"V\"}}\n-    fields_to_suppress: Dict[str, Dict[str, str]]\n-    union_types_to_suppress: List[UnionTypeDefinitionNode]\n-    types_to_suppress: Set[str]\n-\n-    def __init__(\n-        self,\n-        type_renamings: Mapping[str, Optional[str]],\n-        field_renamings: Mapping[str, Mapping[str, Set[str]]],\n-        query_type: str,\n-    ) -> None:\n-        \"\"\"Create a visitor to check that suppression does not cause an illegal state.\n-\n-        Args:\n-            type_renamings: maps original type name to renamed name or None (for type suppression).\n-                            A type named \"Foo\" will be unchanged iff type_renamings does not map\n-                            \"Foo\" to anything, i.e. \"Foo\" not in type_renamings\n-            field_renamings: maps type names to the field renamings for that type. The renamings map\n-                             field names belonging to the type to a set of field names for the\n-                             renamed schema\n-            query_type: name of the query type (e.g. RootSchemaQuery)\n-        \"\"\"\n-        self.type_renamings = type_renamings\n-        self.field_renamings = field_renamings\n-        self.query_type = query_type\n-        self.current_type: Optional[str] = None\n-        self.fields_to_suppress = {}\n-        self.union_types_to_suppress = []\n-        self.types_to_suppress = set()\n-\n-    def enter_object_type_definition(\n-        self,\n-        node: ObjectTypeDefinitionNode,\n-        key: Any,\n-        parent: Any,\n-        path: List[Any],\n-        ancestors: List[Any],\n-    ) -> None:\n-        \"\"\"Record the current type that the visitor is traversing.\"\"\"\n-        self.current_type = node.name.value\n-        if self.current_type not in self.field_renamings:\n-            # No field renamings for current type, so it's impossible for all its fields to have\n-            # been suppressed.\n-            return\n-        current_type_field_renamings = self.field_renamings[self.current_type]\n-        for field in node.fields:\n-            field_name = field.name.value\n-            if (\n-                field_name not in current_type_field_renamings\n-                or current_type_field_renamings[field_name]\n-            ):\n-                # Do nothing if there's at least one field for the current type that hasn't been\n-                # suppressed, either because field renamings didn't contain an entry for field_name\n-                # or if it didn't suppress the field\n-                return\n-        self.types_to_suppress.add(self.current_type)\n-\n-    def leave_object_type_definition(\n-        self,\n-        node: ObjectTypeDefinitionNode,\n-        key: Any,\n-        parent: Any,\n-        path: List[Any],\n-        ancestors: List[Any],\n-    ) -> None:\n-        \"\"\"Finish traversing the current type node.\"\"\"\n-        self.current_type = None\n-\n-    def enter_field_definition(\n-        self,\n-        node: FieldDefinitionNode,\n-        key: Any,\n-        parent: Any,\n-        path: List[Any],\n-        ancestors: List[Any],\n-    ) -> None:\n-        \"\"\"Check that no type Bar contains a field of type Foo, where Foo is suppressed.\"\"\"\n-        if self.current_type == self.query_type:\n-            return IDLE\n-        # At a field of a type that is not the query type\n-        field_name = node.name.value\n-        field_type = get_ast_with_non_null_and_list_stripped(node.type).name.value\n-        if self.type_renamings.get(field_type, field_type):\n-            return IDLE\n-        # Reaching this point means this field is of a type to be suppressed.\n-        if self.current_type is None:\n-            raise AssertionError(\n-                \"Entered a field not in any ObjectTypeDefinition scope because \"\n-                \"self.current_type is None\"\n-            )\n-        if self.current_type == field_type:\n-            # Then node corresponds to a field belonging to type T that is also of type T.\n-            # Therefore, we don't need to explicitly suppress the field as well and this should not\n-            # raise errors.\n-            return IDLE\n-        if self.field_renamings.get(self.current_type, {}).get(field_name, {field_name}) == set():\n-            # Field was also suppressed so this should not raise errors.\n-            return IDLE\n-        if self.current_type not in self.fields_to_suppress:\n-            self.fields_to_suppress[self.current_type] = {}\n-        self.fields_to_suppress[self.current_type][field_name] = field_type\n-        return IDLE\n-\n-    def enter_union_type_definition(\n-        self,\n-        node: UnionTypeDefinitionNode,\n-        key: Any,\n-        parent: Any,\n-        path: List[Any],\n-        ancestors: List[Any],\n-    ) -> None:\n-        \"\"\"Check that each union still has at least one non-suppressed member.\"\"\"\n-        union_name = node.name.value\n-        # Check if all the union members are suppressed.\n-        for union_member in node.types:\n-            union_member_type = get_ast_with_non_null_and_list_stripped(union_member).name.value\n-            if self.type_renamings.get(union_member_type, union_member_type):\n-                # Then at least one member of the union is not suppressed, so there is no cascading\n-                # suppression error concern.\n-                return IDLE\n-        if self.type_renamings.get(union_name, union_name) is None:\n-            # If the union is also suppressed, then nothing needs to happen here\n-            return IDLE\n-        self.union_types_to_suppress.append(node)\n-\n-        return IDLE\n-\n-\n class SuppressionNotImplementedVisitor(Visitor):\n",
        "source_code_with_indent": "\n<DED><DED>class CascadingSuppressionCheckVisitor(Visitor):\n    <IND>\"\"\"Traverse the schema to check for cascading suppression issues.\n\n    The fields_to_suppress attribute records non-suppressed fields that depend on suppressed types.\n    The union_types_to_suppress attribute records unions that had all its members suppressed.\n    The types_to_suppress attribute records types for which all fields were suppressed.\n\n    After calling visit() on the schema using this visitor, if any of these attributes are non-empty\n    then there are further suppressions required to produce a legal schema so the code should then\n    raise a CascadingSuppressionError.\n\n    \"\"\"\n\n    # For a type named T, and its field named F whose type has name V, this dict would be\n    # {\"T\": {\"F\": \"V\"}}\n    fields_to_suppress: Dict[str, Dict[str, str]]\n    union_types_to_suppress: List[UnionTypeDefinitionNode]\n    types_to_suppress: Set[str]\n\n    def __init__(\n        self,\n        type_renamings: Mapping[str, Optional[str]],\n        field_renamings: Mapping[str, Mapping[str, Set[str]]],\n        query_type: str,\n    ) -> None:\n        <IND>\"\"\"Create a visitor to check that suppression does not cause an illegal state.\n\n        Args:\n            type_renamings: maps original type name to renamed name or None (for type suppression).\n                            A type named \"Foo\" will be unchanged iff type_renamings does not map\n                            \"Foo\" to anything, i.e. \"Foo\" not in type_renamings\n            field_renamings: maps type names to the field renamings for that type. The renamings map\n                             field names belonging to the type to a set of field names for the\n                             renamed schema\n            query_type: name of the query type (e.g. RootSchemaQuery)\n        \"\"\"\n        self.type_renamings = type_renamings\n        self.field_renamings = field_renamings\n        self.query_type = query_type\n        self.current_type: Optional[str] = None\n        self.fields_to_suppress = {}\n        self.union_types_to_suppress = []\n        self.types_to_suppress = set()\n\n    <DED>def enter_object_type_definition(\n        self,\n        node: ObjectTypeDefinitionNode,\n        key: Any,\n        parent: Any,\n        path: List[Any],\n        ancestors: List[Any],\n    ) -> None:\n        <IND>\"\"\"Record the current type that the visitor is traversing.\"\"\"\n        self.current_type = node.name.value\n        if self.current_type not in self.field_renamings:\n            # No field renamings for current type, so it's impossible for all its fields to have\n            # been suppressed.\n            <IND>return\n        <DED>current_type_field_renamings = self.field_renamings[self.current_type]\n        for field in node.fields:\n            <IND>field_name = field.name.value\n            if (\n                field_name not in current_type_field_renamings\n                or current_type_field_renamings[field_name]\n            ):\n                # Do nothing if there's at least one field for the current type that hasn't been\n                # suppressed, either because field renamings didn't contain an entry for field_name\n                # or if it didn't suppress the field\n                <IND>return\n        <DED><DED>self.types_to_suppress.add(self.current_type)\n\n    <DED>def leave_object_type_definition(\n        self,\n        node: ObjectTypeDefinitionNode,\n        key: Any,\n        parent: Any,\n        path: List[Any],\n        ancestors: List[Any],\n    ) -> None:\n        <IND>\"\"\"Finish traversing the current type node.\"\"\"\n        self.current_type = None\n\n    <DED>def enter_field_definition(\n        self,\n        node: FieldDefinitionNode,\n        key: Any,\n        parent: Any,\n        path: List[Any],\n        ancestors: List[Any],\n    ) -> None:\n        <IND>\"\"\"Check that no type Bar contains a field of type Foo, where Foo is suppressed.\"\"\"\n        if self.current_type == self.query_type:\n            <IND>return IDLE\n        # At a field of a type that is not the query type\n        <DED>field_name = node.name.value\n        field_type = get_ast_with_non_null_and_list_stripped(node.type).name.value\n        if self.type_renamings.get(field_type, field_type):\n            <IND>return IDLE\n        # Reaching this point means this field is of a type to be suppressed.\n        <DED>if self.current_type is None:\n            <IND>raise AssertionError(\n                \"Entered a field not in any ObjectTypeDefinition scope because \"\n                \"self.current_type is None\"\n            )\n        <DED>if self.current_type == field_type:\n            # Then node corresponds to a field belonging to type T that is also of type T.\n            # Therefore, we don't need to explicitly suppress the field as well and this should not\n            # raise errors.\n            <IND>return IDLE\n        <DED>if self.field_renamings.get(self.current_type, {}).get(field_name, {field_name}) == set():\n            # Field was also suppressed so this should not raise errors.\n            <IND>return IDLE\n        <DED>if self.current_type not in self.fields_to_suppress:\n            <IND>self.fields_to_suppress[self.current_type] = {}\n        <DED>self.fields_to_suppress[self.current_type][field_name] = field_type\n        return IDLE\n\n    <DED>def enter_union_type_definition(\n        self,\n        node: UnionTypeDefinitionNode,\n        key: Any,\n        parent: Any,\n        path: List[Any],\n        ancestors: List[Any],\n    ) -> None:\n        <IND>\"\"\"Check that each union still has at least one non-suppressed member.\"\"\"\n        union_name = node.name.value\n        # Check if all the union members are suppressed.\n        for union_member in node.types:\n            <IND>union_member_type = get_ast_with_non_null_and_list_stripped(union_member).name.value\n            if self.type_renamings.get(union_member_type, union_member_type):\n                # Then at least one member of the union is not suppressed, so there is no cascading\n                # suppression error concern.\n                <IND>return IDLE\n        <DED><DED>if self.type_renamings.get(union_name, union_name) is None:\n            # If the union is also suppressed, then nothing needs to happen here\n            <IND>return IDLE\n        <DED>self.union_types_to_suppress.append(node)\n\n        return IDLE\n\n\n<DED><DED>class SuppressionNotImplementedVisitor(Visitor):\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n<DED><DED>class SuppressionNotImplementedVisitor(Visitor):\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  }
]