[
  {
    "project": "samuelcolvin/pydantic",
    "commit": "4f4e22ef47ab04b289976bb4ba4904e3c701e72d",
    "filename": "tests/test_types.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/samuelcolvin-pydantic/tests/test_types.py",
    "file_hunks_size": 33,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "tests/test_types.py:444:4 Incompatible attribute type [8]: Attribute `a` declared in class `ListDictTupleModel` has type `typing.Dict[typing.Any, typing.Any]` but is used as type `None`.",
    "message": " Attribute `a` declared in class `ListDictTupleModel` has type `typing.Dict[typing.Any, typing.Any]` but is used as type `None`.",
    "rule_id": "Incompatible attribute type [8]",
    "warning_line_no": 444,
    "warning_line": "    a: dict = None",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\nclass ListDictTupleModel(BaseModel):\n    a: dict = None\n    b: list = None\n    c: OrderedDict = None\n    d: tuple = None\n\n\ndef test_dict():\n    assert ListDictTupleModel(a={1: 10, 2: 20}).a == {1: 10, 2: 20}\n    assert ListDictTupleModel(a=[(1, 2), (3, 4)]).a == {1: 2, 3: 4}\n\n    with pytest.raises(ValidationError) as exc_info:\n        ListDictTupleModel(a=[1, 2, 3])\n    assert exc_info.value.flatten_errors() == [\n",
        "source_code_len": 419,
        "target_code": "\ndef test_dict():\n    class Model(BaseModel):\n        v: dict\n\n    assert Model(v={1: 10, 2: 20}).v == {1: 10, 2: 20}\n    assert Model(v=[(1, 2), (3, 4)]).v == {1: 2, 3: 4}\n\n    with pytest.raises(ValidationError) as exc_info:\n        Model(v=[1, 2, 3])\n    assert exc_info.value.flatten_errors() == [\n        {\n            'loc': ('v',),\n            'msg': 'value is not a valid dict',\n            'type': 'type_error.dict',\n        },\n    ]\n\n\ndef test_list():\n    class Model(BaseModel):\n        v: list\n\n    assert Model(v=[1, 2, '3']).v == [1, 2, '3']\n    assert Model(v='xyz').v == ['x', 'y', 'z']\n    assert Model(v=(i**2 for i in range(5))).v == [0, 1, 4, 9, 16]\n\n    with pytest.raises(ValidationError) as exc_info:\n        Model(v=1)\n    assert exc_info.value.flatten_errors() == [\n        {\n            'loc': ('v',),\n            'msg': 'value is not a valid list',\n            'type': 'type_error.list',\n        },\n    ]\n\n\ndef test_ordered_dict():\n    class Model(BaseModel):\n        v: OrderedDict\n\n    assert Model(v=OrderedDict([(1, 10), (2, 20)])).v == OrderedDict([(1, 10), (2, 20)])\n    assert Model(v={1: 10, 2: 20}).v in (OrderedDict([(1, 10), (2, 20)]), OrderedDict([(2, 20), (1, 10)]))\n    assert Model(v=[(1, 2), (3, 4)]).v == OrderedDict([(1, 2), (3, 4)])\n\n    with pytest.raises(ValidationError) as exc_info:\n        Model(v=[1, 2, 3])\n    assert exc_info.value.flatten_errors() == [\n        {\n            'loc': ('v',),\n            'msg': 'value is not a valid dict',\n            'type': 'type_error.dict',\n        },\n    ]\n\n\ndef test_tuple():\n    class Model(BaseModel):\n        v: tuple\n\n    assert Model(v=(1, 2, '3')).v == (1, 2, '3')\n    assert Model(v='xyz').v == ('x', 'y', 'z')\n    assert Model(v=(i**2 for i in range(5))).v == (0, 1, 4, 9, 16)\n\n    with pytest.raises(ValidationError) as exc_info:\n        Model(v=1)\n    assert exc_info.value.flatten_errors() == [\n        {\n            'loc': ('v',),\n            'msg': 'value is not a valid tuple',\n            'type': 'type_error.tuple',\n        },\n    ]\n\n\ndef test_set():\n    class Model(BaseModel):\n        v: set\n\n    assert Model(v={1, 2, 2, '3'}).v == {1, 2, '3'}\n    assert Model(v='xyzxyz').v == {'x', 'y', 'z'}\n    assert Model(v={i**2 for i in range(5)}).v == {0, 1, 4, 9, 16}\n\n    with pytest.raises(ValidationError) as exc_info:\n        Model(v=1)\n    assert exc_info.value.flatten_errors() == [\n        {\n            'loc': ('v',),\n            'msg': 'value is not a valid set',\n            'type': 'type_error.set',\n        },\n    ]\n\n\ndef test_int_validation():\n    class Model(BaseModel):\n        a: PositiveInt = None\n        b: NegativeInt = None\n        c: conint(gt=4, lt=10) = None\n\n    m = Model(a=5, b=-5, c=5)\n    assert m == {'a': 5, 'b': -5, 'c': 5}\n\n    with pytest.raises(ValidationError) as exc_info:\n        Model(a=-5, b=5, c=-5)\n    assert exc_info.value.flatten_errors() == [\n",
        "target_code_len": 2894,
        "diff_format": "@@ -442,15 +412,107 @@\n \n-class ListDictTupleModel(BaseModel):\n-    a: dict = None\n-    b: list = None\n-    c: OrderedDict = None\n-    d: tuple = None\n-\n-\n def test_dict():\n-    assert ListDictTupleModel(a={1: 10, 2: 20}).a == {1: 10, 2: 20}\n-    assert ListDictTupleModel(a=[(1, 2), (3, 4)]).a == {1: 2, 3: 4}\n-\n-    with pytest.raises(ValidationError) as exc_info:\n-        ListDictTupleModel(a=[1, 2, 3])\n+    class Model(BaseModel):\n+        v: dict\n+\n+    assert Model(v={1: 10, 2: 20}).v == {1: 10, 2: 20}\n+    assert Model(v=[(1, 2), (3, 4)]).v == {1: 2, 3: 4}\n+\n+    with pytest.raises(ValidationError) as exc_info:\n+        Model(v=[1, 2, 3])\n+    assert exc_info.value.flatten_errors() == [\n+        {\n+            'loc': ('v',),\n+            'msg': 'value is not a valid dict',\n+            'type': 'type_error.dict',\n+        },\n+    ]\n+\n+\n+def test_list():\n+    class Model(BaseModel):\n+        v: list\n+\n+    assert Model(v=[1, 2, '3']).v == [1, 2, '3']\n+    assert Model(v='xyz').v == ['x', 'y', 'z']\n+    assert Model(v=(i**2 for i in range(5))).v == [0, 1, 4, 9, 16]\n+\n+    with pytest.raises(ValidationError) as exc_info:\n+        Model(v=1)\n+    assert exc_info.value.flatten_errors() == [\n+        {\n+            'loc': ('v',),\n+            'msg': 'value is not a valid list',\n+            'type': 'type_error.list',\n+        },\n+    ]\n+\n+\n+def test_ordered_dict():\n+    class Model(BaseModel):\n+        v: OrderedDict\n+\n+    assert Model(v=OrderedDict([(1, 10), (2, 20)])).v == OrderedDict([(1, 10), (2, 20)])\n+    assert Model(v={1: 10, 2: 20}).v in (OrderedDict([(1, 10), (2, 20)]), OrderedDict([(2, 20), (1, 10)]))\n+    assert Model(v=[(1, 2), (3, 4)]).v == OrderedDict([(1, 2), (3, 4)])\n+\n+    with pytest.raises(ValidationError) as exc_info:\n+        Model(v=[1, 2, 3])\n+    assert exc_info.value.flatten_errors() == [\n+        {\n+            'loc': ('v',),\n+            'msg': 'value is not a valid dict',\n+            'type': 'type_error.dict',\n+        },\n+    ]\n+\n+\n+def test_tuple():\n+    class Model(BaseModel):\n+        v: tuple\n+\n+    assert Model(v=(1, 2, '3')).v == (1, 2, '3')\n+    assert Model(v='xyz').v == ('x', 'y', 'z')\n+    assert Model(v=(i**2 for i in range(5))).v == (0, 1, 4, 9, 16)\n+\n+    with pytest.raises(ValidationError) as exc_info:\n+        Model(v=1)\n+    assert exc_info.value.flatten_errors() == [\n+        {\n+            'loc': ('v',),\n+            'msg': 'value is not a valid tuple',\n+            'type': 'type_error.tuple',\n+        },\n+    ]\n+\n+\n+def test_set():\n+    class Model(BaseModel):\n+        v: set\n+\n+    assert Model(v={1, 2, 2, '3'}).v == {1, 2, '3'}\n+    assert Model(v='xyzxyz').v == {'x', 'y', 'z'}\n+    assert Model(v={i**2 for i in range(5)}).v == {0, 1, 4, 9, 16}\n+\n+    with pytest.raises(ValidationError) as exc_info:\n+        Model(v=1)\n+    assert exc_info.value.flatten_errors() == [\n+        {\n+            'loc': ('v',),\n+            'msg': 'value is not a valid set',\n+            'type': 'type_error.set',\n+        },\n+    ]\n+\n+\n+def test_int_validation():\n+    class Model(BaseModel):\n+        a: PositiveInt = None\n+        b: NegativeInt = None\n+        c: conint(gt=4, lt=10) = None\n+\n+    m = Model(a=5, b=-5, c=5)\n+    assert m == {'a': 5, 'b': -5, 'c': 5}\n+\n+    with pytest.raises(ValidationError) as exc_info:\n+        Model(a=-5, b=5, c=-5)\n     assert exc_info.value.flatten_errors() == [\n",
        "source_code_with_indent": "\n<DED><DED><DED>class ListDictTupleModel(BaseModel):\n    <IND>a: dict = None\n    b: list = None\n    c: OrderedDict = None\n    d: tuple = None\n\n\n<DED>def test_dict():\n    <IND>assert ListDictTupleModel(a={1: 10, 2: 20}).a == {1: 10, 2: 20}\n    assert ListDictTupleModel(a=[(1, 2), (3, 4)]).a == {1: 2, 3: 4}\n\n    with pytest.raises(ValidationError) as exc_info:\n        <IND>ListDictTupleModel(a=[1, 2, 3])\n    <DED>assert exc_info.value.flatten_errors() == [\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n<DED><DED><DED>def test_dict():\n    <IND>class Model(BaseModel):\n        <IND>v: dict\n\n    <DED>assert Model(v={1: 10, 2: 20}).v == {1: 10, 2: 20}\n    assert Model(v=[(1, 2), (3, 4)]).v == {1: 2, 3: 4}\n\n    with pytest.raises(ValidationError) as exc_info:\n        <IND>Model(v=[1, 2, 3])\n    <DED>assert exc_info.value.flatten_errors() == [\n        {\n            'loc': ('v',),\n            'msg': 'value is not a valid dict',\n            'type': 'type_error.dict',\n        },\n    ]\n\n\n<DED>def test_list():\n    <IND>class Model(BaseModel):\n        <IND>v: list\n\n    <DED>assert Model(v=[1, 2, '3']).v == [1, 2, '3']\n    assert Model(v='xyz').v == ['x', 'y', 'z']\n    assert Model(v=(i**2 for i in range(5))).v == [0, 1, 4, 9, 16]\n\n    with pytest.raises(ValidationError) as exc_info:\n        <IND>Model(v=1)\n    <DED>assert exc_info.value.flatten_errors() == [\n        {\n            'loc': ('v',),\n            'msg': 'value is not a valid list',\n            'type': 'type_error.list',\n        },\n    ]\n\n\n<DED>def test_ordered_dict():\n    <IND>class Model(BaseModel):\n        <IND>v: OrderedDict\n\n    <DED>assert Model(v=OrderedDict([(1, 10), (2, 20)])).v == OrderedDict([(1, 10), (2, 20)])\n    assert Model(v={1: 10, 2: 20}).v in (OrderedDict([(1, 10), (2, 20)]), OrderedDict([(2, 20), (1, 10)]))\n    assert Model(v=[(1, 2), (3, 4)]).v == OrderedDict([(1, 2), (3, 4)])\n\n    with pytest.raises(ValidationError) as exc_info:\n        <IND>Model(v=[1, 2, 3])\n    <DED>assert exc_info.value.flatten_errors() == [\n        {\n            'loc': ('v',),\n            'msg': 'value is not a valid dict',\n            'type': 'type_error.dict',\n        },\n    ]\n\n\n<DED>def test_tuple():\n    <IND>class Model(BaseModel):\n        <IND>v: tuple\n\n    <DED>assert Model(v=(1, 2, '3')).v == (1, 2, '3')\n    assert Model(v='xyz').v == ('x', 'y', 'z')\n    assert Model(v=(i**2 for i in range(5))).v == (0, 1, 4, 9, 16)\n\n    with pytest.raises(ValidationError) as exc_info:\n        <IND>Model(v=1)\n    <DED>assert exc_info.value.flatten_errors() == [\n        {\n            'loc': ('v',),\n            'msg': 'value is not a valid tuple',\n            'type': 'type_error.tuple',\n        },\n    ]\n\n\n<DED>def test_set():\n    <IND>class Model(BaseModel):\n        <IND>v: set\n\n    <DED>assert Model(v={1, 2, 2, '3'}).v == {1, 2, '3'}\n    assert Model(v='xyzxyz').v == {'x', 'y', 'z'}\n    assert Model(v={i**2 for i in range(5)}).v == {0, 1, 4, 9, 16}\n\n    with pytest.raises(ValidationError) as exc_info:\n        <IND>Model(v=1)\n    <DED>assert exc_info.value.flatten_errors() == [\n        {\n            'loc': ('v',),\n            'msg': 'value is not a valid set',\n            'type': 'type_error.set',\n        },\n    ]\n\n\n<DED>def test_int_validation():\n    <IND>class Model(BaseModel):\n        <IND>a: PositiveInt = None\n        b: NegativeInt = None\n        c: conint(gt=4, lt=10) = None\n\n    <DED>m = Model(a=5, b=-5, c=5)\n    assert m == {'a': 5, 'b': -5, 'c': 5}\n\n    with pytest.raises(ValidationError) as exc_info:\n        <IND>Model(a=-5, b=5, c=-5)\n    <DED>assert exc_info.value.flatten_errors() == [\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "samuelcolvin/pydantic",
    "commit": "4f4e22ef47ab04b289976bb4ba4904e3c701e72d",
    "filename": "tests/test_types.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/samuelcolvin-pydantic/tests/test_types.py",
    "file_hunks_size": 33,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "tests/test_types.py:445:4 Incompatible attribute type [8]: Attribute `b` declared in class `ListDictTupleModel` has type `typing.List[typing.Any]` but is used as type `None`.",
    "message": " Attribute `b` declared in class `ListDictTupleModel` has type `typing.List[typing.Any]` but is used as type `None`.",
    "rule_id": "Incompatible attribute type [8]",
    "warning_line_no": 445,
    "warning_line": "    b: list = None",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\nclass ListDictTupleModel(BaseModel):\n    a: dict = None\n    b: list = None\n    c: OrderedDict = None\n    d: tuple = None\n\n\ndef test_dict():\n    assert ListDictTupleModel(a={1: 10, 2: 20}).a == {1: 10, 2: 20}\n    assert ListDictTupleModel(a=[(1, 2), (3, 4)]).a == {1: 2, 3: 4}\n\n    with pytest.raises(ValidationError) as exc_info:\n        ListDictTupleModel(a=[1, 2, 3])\n    assert exc_info.value.flatten_errors() == [\n",
        "source_code_len": 419,
        "target_code": "\ndef test_dict():\n    class Model(BaseModel):\n        v: dict\n\n    assert Model(v={1: 10, 2: 20}).v == {1: 10, 2: 20}\n    assert Model(v=[(1, 2), (3, 4)]).v == {1: 2, 3: 4}\n\n    with pytest.raises(ValidationError) as exc_info:\n        Model(v=[1, 2, 3])\n    assert exc_info.value.flatten_errors() == [\n        {\n            'loc': ('v',),\n            'msg': 'value is not a valid dict',\n            'type': 'type_error.dict',\n        },\n    ]\n\n\ndef test_list():\n    class Model(BaseModel):\n        v: list\n\n    assert Model(v=[1, 2, '3']).v == [1, 2, '3']\n    assert Model(v='xyz').v == ['x', 'y', 'z']\n    assert Model(v=(i**2 for i in range(5))).v == [0, 1, 4, 9, 16]\n\n    with pytest.raises(ValidationError) as exc_info:\n        Model(v=1)\n    assert exc_info.value.flatten_errors() == [\n        {\n            'loc': ('v',),\n            'msg': 'value is not a valid list',\n            'type': 'type_error.list',\n        },\n    ]\n\n\ndef test_ordered_dict():\n    class Model(BaseModel):\n        v: OrderedDict\n\n    assert Model(v=OrderedDict([(1, 10), (2, 20)])).v == OrderedDict([(1, 10), (2, 20)])\n    assert Model(v={1: 10, 2: 20}).v in (OrderedDict([(1, 10), (2, 20)]), OrderedDict([(2, 20), (1, 10)]))\n    assert Model(v=[(1, 2), (3, 4)]).v == OrderedDict([(1, 2), (3, 4)])\n\n    with pytest.raises(ValidationError) as exc_info:\n        Model(v=[1, 2, 3])\n    assert exc_info.value.flatten_errors() == [\n        {\n            'loc': ('v',),\n            'msg': 'value is not a valid dict',\n            'type': 'type_error.dict',\n        },\n    ]\n\n\ndef test_tuple():\n    class Model(BaseModel):\n        v: tuple\n\n    assert Model(v=(1, 2, '3')).v == (1, 2, '3')\n    assert Model(v='xyz').v == ('x', 'y', 'z')\n    assert Model(v=(i**2 for i in range(5))).v == (0, 1, 4, 9, 16)\n\n    with pytest.raises(ValidationError) as exc_info:\n        Model(v=1)\n    assert exc_info.value.flatten_errors() == [\n        {\n            'loc': ('v',),\n            'msg': 'value is not a valid tuple',\n            'type': 'type_error.tuple',\n        },\n    ]\n\n\ndef test_set():\n    class Model(BaseModel):\n        v: set\n\n    assert Model(v={1, 2, 2, '3'}).v == {1, 2, '3'}\n    assert Model(v='xyzxyz').v == {'x', 'y', 'z'}\n    assert Model(v={i**2 for i in range(5)}).v == {0, 1, 4, 9, 16}\n\n    with pytest.raises(ValidationError) as exc_info:\n        Model(v=1)\n    assert exc_info.value.flatten_errors() == [\n        {\n            'loc': ('v',),\n            'msg': 'value is not a valid set',\n            'type': 'type_error.set',\n        },\n    ]\n\n\ndef test_int_validation():\n    class Model(BaseModel):\n        a: PositiveInt = None\n        b: NegativeInt = None\n        c: conint(gt=4, lt=10) = None\n\n    m = Model(a=5, b=-5, c=5)\n    assert m == {'a': 5, 'b': -5, 'c': 5}\n\n    with pytest.raises(ValidationError) as exc_info:\n        Model(a=-5, b=5, c=-5)\n    assert exc_info.value.flatten_errors() == [\n",
        "target_code_len": 2894,
        "diff_format": "@@ -442,15 +412,107 @@\n \n-class ListDictTupleModel(BaseModel):\n-    a: dict = None\n-    b: list = None\n-    c: OrderedDict = None\n-    d: tuple = None\n-\n-\n def test_dict():\n-    assert ListDictTupleModel(a={1: 10, 2: 20}).a == {1: 10, 2: 20}\n-    assert ListDictTupleModel(a=[(1, 2), (3, 4)]).a == {1: 2, 3: 4}\n-\n-    with pytest.raises(ValidationError) as exc_info:\n-        ListDictTupleModel(a=[1, 2, 3])\n+    class Model(BaseModel):\n+        v: dict\n+\n+    assert Model(v={1: 10, 2: 20}).v == {1: 10, 2: 20}\n+    assert Model(v=[(1, 2), (3, 4)]).v == {1: 2, 3: 4}\n+\n+    with pytest.raises(ValidationError) as exc_info:\n+        Model(v=[1, 2, 3])\n+    assert exc_info.value.flatten_errors() == [\n+        {\n+            'loc': ('v',),\n+            'msg': 'value is not a valid dict',\n+            'type': 'type_error.dict',\n+        },\n+    ]\n+\n+\n+def test_list():\n+    class Model(BaseModel):\n+        v: list\n+\n+    assert Model(v=[1, 2, '3']).v == [1, 2, '3']\n+    assert Model(v='xyz').v == ['x', 'y', 'z']\n+    assert Model(v=(i**2 for i in range(5))).v == [0, 1, 4, 9, 16]\n+\n+    with pytest.raises(ValidationError) as exc_info:\n+        Model(v=1)\n+    assert exc_info.value.flatten_errors() == [\n+        {\n+            'loc': ('v',),\n+            'msg': 'value is not a valid list',\n+            'type': 'type_error.list',\n+        },\n+    ]\n+\n+\n+def test_ordered_dict():\n+    class Model(BaseModel):\n+        v: OrderedDict\n+\n+    assert Model(v=OrderedDict([(1, 10), (2, 20)])).v == OrderedDict([(1, 10), (2, 20)])\n+    assert Model(v={1: 10, 2: 20}).v in (OrderedDict([(1, 10), (2, 20)]), OrderedDict([(2, 20), (1, 10)]))\n+    assert Model(v=[(1, 2), (3, 4)]).v == OrderedDict([(1, 2), (3, 4)])\n+\n+    with pytest.raises(ValidationError) as exc_info:\n+        Model(v=[1, 2, 3])\n+    assert exc_info.value.flatten_errors() == [\n+        {\n+            'loc': ('v',),\n+            'msg': 'value is not a valid dict',\n+            'type': 'type_error.dict',\n+        },\n+    ]\n+\n+\n+def test_tuple():\n+    class Model(BaseModel):\n+        v: tuple\n+\n+    assert Model(v=(1, 2, '3')).v == (1, 2, '3')\n+    assert Model(v='xyz').v == ('x', 'y', 'z')\n+    assert Model(v=(i**2 for i in range(5))).v == (0, 1, 4, 9, 16)\n+\n+    with pytest.raises(ValidationError) as exc_info:\n+        Model(v=1)\n+    assert exc_info.value.flatten_errors() == [\n+        {\n+            'loc': ('v',),\n+            'msg': 'value is not a valid tuple',\n+            'type': 'type_error.tuple',\n+        },\n+    ]\n+\n+\n+def test_set():\n+    class Model(BaseModel):\n+        v: set\n+\n+    assert Model(v={1, 2, 2, '3'}).v == {1, 2, '3'}\n+    assert Model(v='xyzxyz').v == {'x', 'y', 'z'}\n+    assert Model(v={i**2 for i in range(5)}).v == {0, 1, 4, 9, 16}\n+\n+    with pytest.raises(ValidationError) as exc_info:\n+        Model(v=1)\n+    assert exc_info.value.flatten_errors() == [\n+        {\n+            'loc': ('v',),\n+            'msg': 'value is not a valid set',\n+            'type': 'type_error.set',\n+        },\n+    ]\n+\n+\n+def test_int_validation():\n+    class Model(BaseModel):\n+        a: PositiveInt = None\n+        b: NegativeInt = None\n+        c: conint(gt=4, lt=10) = None\n+\n+    m = Model(a=5, b=-5, c=5)\n+    assert m == {'a': 5, 'b': -5, 'c': 5}\n+\n+    with pytest.raises(ValidationError) as exc_info:\n+        Model(a=-5, b=5, c=-5)\n     assert exc_info.value.flatten_errors() == [\n",
        "source_code_with_indent": "\n<DED><DED><DED>class ListDictTupleModel(BaseModel):\n    <IND>a: dict = None\n    b: list = None\n    c: OrderedDict = None\n    d: tuple = None\n\n\n<DED>def test_dict():\n    <IND>assert ListDictTupleModel(a={1: 10, 2: 20}).a == {1: 10, 2: 20}\n    assert ListDictTupleModel(a=[(1, 2), (3, 4)]).a == {1: 2, 3: 4}\n\n    with pytest.raises(ValidationError) as exc_info:\n        <IND>ListDictTupleModel(a=[1, 2, 3])\n    <DED>assert exc_info.value.flatten_errors() == [\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n<DED><DED><DED>def test_dict():\n    <IND>class Model(BaseModel):\n        <IND>v: dict\n\n    <DED>assert Model(v={1: 10, 2: 20}).v == {1: 10, 2: 20}\n    assert Model(v=[(1, 2), (3, 4)]).v == {1: 2, 3: 4}\n\n    with pytest.raises(ValidationError) as exc_info:\n        <IND>Model(v=[1, 2, 3])\n    <DED>assert exc_info.value.flatten_errors() == [\n        {\n            'loc': ('v',),\n            'msg': 'value is not a valid dict',\n            'type': 'type_error.dict',\n        },\n    ]\n\n\n<DED>def test_list():\n    <IND>class Model(BaseModel):\n        <IND>v: list\n\n    <DED>assert Model(v=[1, 2, '3']).v == [1, 2, '3']\n    assert Model(v='xyz').v == ['x', 'y', 'z']\n    assert Model(v=(i**2 for i in range(5))).v == [0, 1, 4, 9, 16]\n\n    with pytest.raises(ValidationError) as exc_info:\n        <IND>Model(v=1)\n    <DED>assert exc_info.value.flatten_errors() == [\n        {\n            'loc': ('v',),\n            'msg': 'value is not a valid list',\n            'type': 'type_error.list',\n        },\n    ]\n\n\n<DED>def test_ordered_dict():\n    <IND>class Model(BaseModel):\n        <IND>v: OrderedDict\n\n    <DED>assert Model(v=OrderedDict([(1, 10), (2, 20)])).v == OrderedDict([(1, 10), (2, 20)])\n    assert Model(v={1: 10, 2: 20}).v in (OrderedDict([(1, 10), (2, 20)]), OrderedDict([(2, 20), (1, 10)]))\n    assert Model(v=[(1, 2), (3, 4)]).v == OrderedDict([(1, 2), (3, 4)])\n\n    with pytest.raises(ValidationError) as exc_info:\n        <IND>Model(v=[1, 2, 3])\n    <DED>assert exc_info.value.flatten_errors() == [\n        {\n            'loc': ('v',),\n            'msg': 'value is not a valid dict',\n            'type': 'type_error.dict',\n        },\n    ]\n\n\n<DED>def test_tuple():\n    <IND>class Model(BaseModel):\n        <IND>v: tuple\n\n    <DED>assert Model(v=(1, 2, '3')).v == (1, 2, '3')\n    assert Model(v='xyz').v == ('x', 'y', 'z')\n    assert Model(v=(i**2 for i in range(5))).v == (0, 1, 4, 9, 16)\n\n    with pytest.raises(ValidationError) as exc_info:\n        <IND>Model(v=1)\n    <DED>assert exc_info.value.flatten_errors() == [\n        {\n            'loc': ('v',),\n            'msg': 'value is not a valid tuple',\n            'type': 'type_error.tuple',\n        },\n    ]\n\n\n<DED>def test_set():\n    <IND>class Model(BaseModel):\n        <IND>v: set\n\n    <DED>assert Model(v={1, 2, 2, '3'}).v == {1, 2, '3'}\n    assert Model(v='xyzxyz').v == {'x', 'y', 'z'}\n    assert Model(v={i**2 for i in range(5)}).v == {0, 1, 4, 9, 16}\n\n    with pytest.raises(ValidationError) as exc_info:\n        <IND>Model(v=1)\n    <DED>assert exc_info.value.flatten_errors() == [\n        {\n            'loc': ('v',),\n            'msg': 'value is not a valid set',\n            'type': 'type_error.set',\n        },\n    ]\n\n\n<DED>def test_int_validation():\n    <IND>class Model(BaseModel):\n        <IND>a: PositiveInt = None\n        b: NegativeInt = None\n        c: conint(gt=4, lt=10) = None\n\n    <DED>m = Model(a=5, b=-5, c=5)\n    assert m == {'a': 5, 'b': -5, 'c': 5}\n\n    with pytest.raises(ValidationError) as exc_info:\n        <IND>Model(a=-5, b=5, c=-5)\n    <DED>assert exc_info.value.flatten_errors() == [\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "samuelcolvin/pydantic",
    "commit": "4f4e22ef47ab04b289976bb4ba4904e3c701e72d",
    "filename": "tests/test_types.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/samuelcolvin-pydantic/tests/test_types.py",
    "file_hunks_size": 33,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "tests/test_types.py:446:4 Incompatible attribute type [8]: Attribute `c` declared in class `ListDictTupleModel` has type `OrderedDict[typing.Any, typing.Any]` but is used as type `None`.",
    "message": " Attribute `c` declared in class `ListDictTupleModel` has type `OrderedDict[typing.Any, typing.Any]` but is used as type `None`.",
    "rule_id": "Incompatible attribute type [8]",
    "warning_line_no": 446,
    "warning_line": "    c: OrderedDict = None",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\nclass ListDictTupleModel(BaseModel):\n    a: dict = None\n    b: list = None\n    c: OrderedDict = None\n    d: tuple = None\n\n\ndef test_dict():\n    assert ListDictTupleModel(a={1: 10, 2: 20}).a == {1: 10, 2: 20}\n    assert ListDictTupleModel(a=[(1, 2), (3, 4)]).a == {1: 2, 3: 4}\n\n    with pytest.raises(ValidationError) as exc_info:\n        ListDictTupleModel(a=[1, 2, 3])\n    assert exc_info.value.flatten_errors() == [\n",
        "source_code_len": 419,
        "target_code": "\ndef test_dict():\n    class Model(BaseModel):\n        v: dict\n\n    assert Model(v={1: 10, 2: 20}).v == {1: 10, 2: 20}\n    assert Model(v=[(1, 2), (3, 4)]).v == {1: 2, 3: 4}\n\n    with pytest.raises(ValidationError) as exc_info:\n        Model(v=[1, 2, 3])\n    assert exc_info.value.flatten_errors() == [\n        {\n            'loc': ('v',),\n            'msg': 'value is not a valid dict',\n            'type': 'type_error.dict',\n        },\n    ]\n\n\ndef test_list():\n    class Model(BaseModel):\n        v: list\n\n    assert Model(v=[1, 2, '3']).v == [1, 2, '3']\n    assert Model(v='xyz').v == ['x', 'y', 'z']\n    assert Model(v=(i**2 for i in range(5))).v == [0, 1, 4, 9, 16]\n\n    with pytest.raises(ValidationError) as exc_info:\n        Model(v=1)\n    assert exc_info.value.flatten_errors() == [\n        {\n            'loc': ('v',),\n            'msg': 'value is not a valid list',\n            'type': 'type_error.list',\n        },\n    ]\n\n\ndef test_ordered_dict():\n    class Model(BaseModel):\n        v: OrderedDict\n\n    assert Model(v=OrderedDict([(1, 10), (2, 20)])).v == OrderedDict([(1, 10), (2, 20)])\n    assert Model(v={1: 10, 2: 20}).v in (OrderedDict([(1, 10), (2, 20)]), OrderedDict([(2, 20), (1, 10)]))\n    assert Model(v=[(1, 2), (3, 4)]).v == OrderedDict([(1, 2), (3, 4)])\n\n    with pytest.raises(ValidationError) as exc_info:\n        Model(v=[1, 2, 3])\n    assert exc_info.value.flatten_errors() == [\n        {\n            'loc': ('v',),\n            'msg': 'value is not a valid dict',\n            'type': 'type_error.dict',\n        },\n    ]\n\n\ndef test_tuple():\n    class Model(BaseModel):\n        v: tuple\n\n    assert Model(v=(1, 2, '3')).v == (1, 2, '3')\n    assert Model(v='xyz').v == ('x', 'y', 'z')\n    assert Model(v=(i**2 for i in range(5))).v == (0, 1, 4, 9, 16)\n\n    with pytest.raises(ValidationError) as exc_info:\n        Model(v=1)\n    assert exc_info.value.flatten_errors() == [\n        {\n            'loc': ('v',),\n            'msg': 'value is not a valid tuple',\n            'type': 'type_error.tuple',\n        },\n    ]\n\n\ndef test_set():\n    class Model(BaseModel):\n        v: set\n\n    assert Model(v={1, 2, 2, '3'}).v == {1, 2, '3'}\n    assert Model(v='xyzxyz').v == {'x', 'y', 'z'}\n    assert Model(v={i**2 for i in range(5)}).v == {0, 1, 4, 9, 16}\n\n    with pytest.raises(ValidationError) as exc_info:\n        Model(v=1)\n    assert exc_info.value.flatten_errors() == [\n        {\n            'loc': ('v',),\n            'msg': 'value is not a valid set',\n            'type': 'type_error.set',\n        },\n    ]\n\n\ndef test_int_validation():\n    class Model(BaseModel):\n        a: PositiveInt = None\n        b: NegativeInt = None\n        c: conint(gt=4, lt=10) = None\n\n    m = Model(a=5, b=-5, c=5)\n    assert m == {'a': 5, 'b': -5, 'c': 5}\n\n    with pytest.raises(ValidationError) as exc_info:\n        Model(a=-5, b=5, c=-5)\n    assert exc_info.value.flatten_errors() == [\n",
        "target_code_len": 2894,
        "diff_format": "@@ -442,15 +412,107 @@\n \n-class ListDictTupleModel(BaseModel):\n-    a: dict = None\n-    b: list = None\n-    c: OrderedDict = None\n-    d: tuple = None\n-\n-\n def test_dict():\n-    assert ListDictTupleModel(a={1: 10, 2: 20}).a == {1: 10, 2: 20}\n-    assert ListDictTupleModel(a=[(1, 2), (3, 4)]).a == {1: 2, 3: 4}\n-\n-    with pytest.raises(ValidationError) as exc_info:\n-        ListDictTupleModel(a=[1, 2, 3])\n+    class Model(BaseModel):\n+        v: dict\n+\n+    assert Model(v={1: 10, 2: 20}).v == {1: 10, 2: 20}\n+    assert Model(v=[(1, 2), (3, 4)]).v == {1: 2, 3: 4}\n+\n+    with pytest.raises(ValidationError) as exc_info:\n+        Model(v=[1, 2, 3])\n+    assert exc_info.value.flatten_errors() == [\n+        {\n+            'loc': ('v',),\n+            'msg': 'value is not a valid dict',\n+            'type': 'type_error.dict',\n+        },\n+    ]\n+\n+\n+def test_list():\n+    class Model(BaseModel):\n+        v: list\n+\n+    assert Model(v=[1, 2, '3']).v == [1, 2, '3']\n+    assert Model(v='xyz').v == ['x', 'y', 'z']\n+    assert Model(v=(i**2 for i in range(5))).v == [0, 1, 4, 9, 16]\n+\n+    with pytest.raises(ValidationError) as exc_info:\n+        Model(v=1)\n+    assert exc_info.value.flatten_errors() == [\n+        {\n+            'loc': ('v',),\n+            'msg': 'value is not a valid list',\n+            'type': 'type_error.list',\n+        },\n+    ]\n+\n+\n+def test_ordered_dict():\n+    class Model(BaseModel):\n+        v: OrderedDict\n+\n+    assert Model(v=OrderedDict([(1, 10), (2, 20)])).v == OrderedDict([(1, 10), (2, 20)])\n+    assert Model(v={1: 10, 2: 20}).v in (OrderedDict([(1, 10), (2, 20)]), OrderedDict([(2, 20), (1, 10)]))\n+    assert Model(v=[(1, 2), (3, 4)]).v == OrderedDict([(1, 2), (3, 4)])\n+\n+    with pytest.raises(ValidationError) as exc_info:\n+        Model(v=[1, 2, 3])\n+    assert exc_info.value.flatten_errors() == [\n+        {\n+            'loc': ('v',),\n+            'msg': 'value is not a valid dict',\n+            'type': 'type_error.dict',\n+        },\n+    ]\n+\n+\n+def test_tuple():\n+    class Model(BaseModel):\n+        v: tuple\n+\n+    assert Model(v=(1, 2, '3')).v == (1, 2, '3')\n+    assert Model(v='xyz').v == ('x', 'y', 'z')\n+    assert Model(v=(i**2 for i in range(5))).v == (0, 1, 4, 9, 16)\n+\n+    with pytest.raises(ValidationError) as exc_info:\n+        Model(v=1)\n+    assert exc_info.value.flatten_errors() == [\n+        {\n+            'loc': ('v',),\n+            'msg': 'value is not a valid tuple',\n+            'type': 'type_error.tuple',\n+        },\n+    ]\n+\n+\n+def test_set():\n+    class Model(BaseModel):\n+        v: set\n+\n+    assert Model(v={1, 2, 2, '3'}).v == {1, 2, '3'}\n+    assert Model(v='xyzxyz').v == {'x', 'y', 'z'}\n+    assert Model(v={i**2 for i in range(5)}).v == {0, 1, 4, 9, 16}\n+\n+    with pytest.raises(ValidationError) as exc_info:\n+        Model(v=1)\n+    assert exc_info.value.flatten_errors() == [\n+        {\n+            'loc': ('v',),\n+            'msg': 'value is not a valid set',\n+            'type': 'type_error.set',\n+        },\n+    ]\n+\n+\n+def test_int_validation():\n+    class Model(BaseModel):\n+        a: PositiveInt = None\n+        b: NegativeInt = None\n+        c: conint(gt=4, lt=10) = None\n+\n+    m = Model(a=5, b=-5, c=5)\n+    assert m == {'a': 5, 'b': -5, 'c': 5}\n+\n+    with pytest.raises(ValidationError) as exc_info:\n+        Model(a=-5, b=5, c=-5)\n     assert exc_info.value.flatten_errors() == [\n",
        "source_code_with_indent": "\n<DED><DED><DED>class ListDictTupleModel(BaseModel):\n    <IND>a: dict = None\n    b: list = None\n    c: OrderedDict = None\n    d: tuple = None\n\n\n<DED>def test_dict():\n    <IND>assert ListDictTupleModel(a={1: 10, 2: 20}).a == {1: 10, 2: 20}\n    assert ListDictTupleModel(a=[(1, 2), (3, 4)]).a == {1: 2, 3: 4}\n\n    with pytest.raises(ValidationError) as exc_info:\n        <IND>ListDictTupleModel(a=[1, 2, 3])\n    <DED>assert exc_info.value.flatten_errors() == [\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n<DED><DED><DED>def test_dict():\n    <IND>class Model(BaseModel):\n        <IND>v: dict\n\n    <DED>assert Model(v={1: 10, 2: 20}).v == {1: 10, 2: 20}\n    assert Model(v=[(1, 2), (3, 4)]).v == {1: 2, 3: 4}\n\n    with pytest.raises(ValidationError) as exc_info:\n        <IND>Model(v=[1, 2, 3])\n    <DED>assert exc_info.value.flatten_errors() == [\n        {\n            'loc': ('v',),\n            'msg': 'value is not a valid dict',\n            'type': 'type_error.dict',\n        },\n    ]\n\n\n<DED>def test_list():\n    <IND>class Model(BaseModel):\n        <IND>v: list\n\n    <DED>assert Model(v=[1, 2, '3']).v == [1, 2, '3']\n    assert Model(v='xyz').v == ['x', 'y', 'z']\n    assert Model(v=(i**2 for i in range(5))).v == [0, 1, 4, 9, 16]\n\n    with pytest.raises(ValidationError) as exc_info:\n        <IND>Model(v=1)\n    <DED>assert exc_info.value.flatten_errors() == [\n        {\n            'loc': ('v',),\n            'msg': 'value is not a valid list',\n            'type': 'type_error.list',\n        },\n    ]\n\n\n<DED>def test_ordered_dict():\n    <IND>class Model(BaseModel):\n        <IND>v: OrderedDict\n\n    <DED>assert Model(v=OrderedDict([(1, 10), (2, 20)])).v == OrderedDict([(1, 10), (2, 20)])\n    assert Model(v={1: 10, 2: 20}).v in (OrderedDict([(1, 10), (2, 20)]), OrderedDict([(2, 20), (1, 10)]))\n    assert Model(v=[(1, 2), (3, 4)]).v == OrderedDict([(1, 2), (3, 4)])\n\n    with pytest.raises(ValidationError) as exc_info:\n        <IND>Model(v=[1, 2, 3])\n    <DED>assert exc_info.value.flatten_errors() == [\n        {\n            'loc': ('v',),\n            'msg': 'value is not a valid dict',\n            'type': 'type_error.dict',\n        },\n    ]\n\n\n<DED>def test_tuple():\n    <IND>class Model(BaseModel):\n        <IND>v: tuple\n\n    <DED>assert Model(v=(1, 2, '3')).v == (1, 2, '3')\n    assert Model(v='xyz').v == ('x', 'y', 'z')\n    assert Model(v=(i**2 for i in range(5))).v == (0, 1, 4, 9, 16)\n\n    with pytest.raises(ValidationError) as exc_info:\n        <IND>Model(v=1)\n    <DED>assert exc_info.value.flatten_errors() == [\n        {\n            'loc': ('v',),\n            'msg': 'value is not a valid tuple',\n            'type': 'type_error.tuple',\n        },\n    ]\n\n\n<DED>def test_set():\n    <IND>class Model(BaseModel):\n        <IND>v: set\n\n    <DED>assert Model(v={1, 2, 2, '3'}).v == {1, 2, '3'}\n    assert Model(v='xyzxyz').v == {'x', 'y', 'z'}\n    assert Model(v={i**2 for i in range(5)}).v == {0, 1, 4, 9, 16}\n\n    with pytest.raises(ValidationError) as exc_info:\n        <IND>Model(v=1)\n    <DED>assert exc_info.value.flatten_errors() == [\n        {\n            'loc': ('v',),\n            'msg': 'value is not a valid set',\n            'type': 'type_error.set',\n        },\n    ]\n\n\n<DED>def test_int_validation():\n    <IND>class Model(BaseModel):\n        <IND>a: PositiveInt = None\n        b: NegativeInt = None\n        c: conint(gt=4, lt=10) = None\n\n    <DED>m = Model(a=5, b=-5, c=5)\n    assert m == {'a': 5, 'b': -5, 'c': 5}\n\n    with pytest.raises(ValidationError) as exc_info:\n        <IND>Model(a=-5, b=5, c=-5)\n    <DED>assert exc_info.value.flatten_errors() == [\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "samuelcolvin/pydantic",
    "commit": "4f4e22ef47ab04b289976bb4ba4904e3c701e72d",
    "filename": "tests/test_types.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/samuelcolvin-pydantic/tests/test_types.py",
    "file_hunks_size": 33,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "tests/test_types.py:447:4 Incompatible attribute type [8]: Attribute `d` declared in class `ListDictTupleModel` has type `typing.Tuple[typing.Any, ...]` but is used as type `None`.",
    "message": " Attribute `d` declared in class `ListDictTupleModel` has type `typing.Tuple[typing.Any, ...]` but is used as type `None`.",
    "rule_id": "Incompatible attribute type [8]",
    "warning_line_no": 447,
    "warning_line": "    d: tuple = None",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\nclass ListDictTupleModel(BaseModel):\n    a: dict = None\n    b: list = None\n    c: OrderedDict = None\n    d: tuple = None\n\n\ndef test_dict():\n    assert ListDictTupleModel(a={1: 10, 2: 20}).a == {1: 10, 2: 20}\n    assert ListDictTupleModel(a=[(1, 2), (3, 4)]).a == {1: 2, 3: 4}\n\n    with pytest.raises(ValidationError) as exc_info:\n        ListDictTupleModel(a=[1, 2, 3])\n    assert exc_info.value.flatten_errors() == [\n",
        "source_code_len": 419,
        "target_code": "\ndef test_dict():\n    class Model(BaseModel):\n        v: dict\n\n    assert Model(v={1: 10, 2: 20}).v == {1: 10, 2: 20}\n    assert Model(v=[(1, 2), (3, 4)]).v == {1: 2, 3: 4}\n\n    with pytest.raises(ValidationError) as exc_info:\n        Model(v=[1, 2, 3])\n    assert exc_info.value.flatten_errors() == [\n        {\n            'loc': ('v',),\n            'msg': 'value is not a valid dict',\n            'type': 'type_error.dict',\n        },\n    ]\n\n\ndef test_list():\n    class Model(BaseModel):\n        v: list\n\n    assert Model(v=[1, 2, '3']).v == [1, 2, '3']\n    assert Model(v='xyz').v == ['x', 'y', 'z']\n    assert Model(v=(i**2 for i in range(5))).v == [0, 1, 4, 9, 16]\n\n    with pytest.raises(ValidationError) as exc_info:\n        Model(v=1)\n    assert exc_info.value.flatten_errors() == [\n        {\n            'loc': ('v',),\n            'msg': 'value is not a valid list',\n            'type': 'type_error.list',\n        },\n    ]\n\n\ndef test_ordered_dict():\n    class Model(BaseModel):\n        v: OrderedDict\n\n    assert Model(v=OrderedDict([(1, 10), (2, 20)])).v == OrderedDict([(1, 10), (2, 20)])\n    assert Model(v={1: 10, 2: 20}).v in (OrderedDict([(1, 10), (2, 20)]), OrderedDict([(2, 20), (1, 10)]))\n    assert Model(v=[(1, 2), (3, 4)]).v == OrderedDict([(1, 2), (3, 4)])\n\n    with pytest.raises(ValidationError) as exc_info:\n        Model(v=[1, 2, 3])\n    assert exc_info.value.flatten_errors() == [\n        {\n            'loc': ('v',),\n            'msg': 'value is not a valid dict',\n            'type': 'type_error.dict',\n        },\n    ]\n\n\ndef test_tuple():\n    class Model(BaseModel):\n        v: tuple\n\n    assert Model(v=(1, 2, '3')).v == (1, 2, '3')\n    assert Model(v='xyz').v == ('x', 'y', 'z')\n    assert Model(v=(i**2 for i in range(5))).v == (0, 1, 4, 9, 16)\n\n    with pytest.raises(ValidationError) as exc_info:\n        Model(v=1)\n    assert exc_info.value.flatten_errors() == [\n        {\n            'loc': ('v',),\n            'msg': 'value is not a valid tuple',\n            'type': 'type_error.tuple',\n        },\n    ]\n\n\ndef test_set():\n    class Model(BaseModel):\n        v: set\n\n    assert Model(v={1, 2, 2, '3'}).v == {1, 2, '3'}\n    assert Model(v='xyzxyz').v == {'x', 'y', 'z'}\n    assert Model(v={i**2 for i in range(5)}).v == {0, 1, 4, 9, 16}\n\n    with pytest.raises(ValidationError) as exc_info:\n        Model(v=1)\n    assert exc_info.value.flatten_errors() == [\n        {\n            'loc': ('v',),\n            'msg': 'value is not a valid set',\n            'type': 'type_error.set',\n        },\n    ]\n\n\ndef test_int_validation():\n    class Model(BaseModel):\n        a: PositiveInt = None\n        b: NegativeInt = None\n        c: conint(gt=4, lt=10) = None\n\n    m = Model(a=5, b=-5, c=5)\n    assert m == {'a': 5, 'b': -5, 'c': 5}\n\n    with pytest.raises(ValidationError) as exc_info:\n        Model(a=-5, b=5, c=-5)\n    assert exc_info.value.flatten_errors() == [\n",
        "target_code_len": 2894,
        "diff_format": "@@ -442,15 +412,107 @@\n \n-class ListDictTupleModel(BaseModel):\n-    a: dict = None\n-    b: list = None\n-    c: OrderedDict = None\n-    d: tuple = None\n-\n-\n def test_dict():\n-    assert ListDictTupleModel(a={1: 10, 2: 20}).a == {1: 10, 2: 20}\n-    assert ListDictTupleModel(a=[(1, 2), (3, 4)]).a == {1: 2, 3: 4}\n-\n-    with pytest.raises(ValidationError) as exc_info:\n-        ListDictTupleModel(a=[1, 2, 3])\n+    class Model(BaseModel):\n+        v: dict\n+\n+    assert Model(v={1: 10, 2: 20}).v == {1: 10, 2: 20}\n+    assert Model(v=[(1, 2), (3, 4)]).v == {1: 2, 3: 4}\n+\n+    with pytest.raises(ValidationError) as exc_info:\n+        Model(v=[1, 2, 3])\n+    assert exc_info.value.flatten_errors() == [\n+        {\n+            'loc': ('v',),\n+            'msg': 'value is not a valid dict',\n+            'type': 'type_error.dict',\n+        },\n+    ]\n+\n+\n+def test_list():\n+    class Model(BaseModel):\n+        v: list\n+\n+    assert Model(v=[1, 2, '3']).v == [1, 2, '3']\n+    assert Model(v='xyz').v == ['x', 'y', 'z']\n+    assert Model(v=(i**2 for i in range(5))).v == [0, 1, 4, 9, 16]\n+\n+    with pytest.raises(ValidationError) as exc_info:\n+        Model(v=1)\n+    assert exc_info.value.flatten_errors() == [\n+        {\n+            'loc': ('v',),\n+            'msg': 'value is not a valid list',\n+            'type': 'type_error.list',\n+        },\n+    ]\n+\n+\n+def test_ordered_dict():\n+    class Model(BaseModel):\n+        v: OrderedDict\n+\n+    assert Model(v=OrderedDict([(1, 10), (2, 20)])).v == OrderedDict([(1, 10), (2, 20)])\n+    assert Model(v={1: 10, 2: 20}).v in (OrderedDict([(1, 10), (2, 20)]), OrderedDict([(2, 20), (1, 10)]))\n+    assert Model(v=[(1, 2), (3, 4)]).v == OrderedDict([(1, 2), (3, 4)])\n+\n+    with pytest.raises(ValidationError) as exc_info:\n+        Model(v=[1, 2, 3])\n+    assert exc_info.value.flatten_errors() == [\n+        {\n+            'loc': ('v',),\n+            'msg': 'value is not a valid dict',\n+            'type': 'type_error.dict',\n+        },\n+    ]\n+\n+\n+def test_tuple():\n+    class Model(BaseModel):\n+        v: tuple\n+\n+    assert Model(v=(1, 2, '3')).v == (1, 2, '3')\n+    assert Model(v='xyz').v == ('x', 'y', 'z')\n+    assert Model(v=(i**2 for i in range(5))).v == (0, 1, 4, 9, 16)\n+\n+    with pytest.raises(ValidationError) as exc_info:\n+        Model(v=1)\n+    assert exc_info.value.flatten_errors() == [\n+        {\n+            'loc': ('v',),\n+            'msg': 'value is not a valid tuple',\n+            'type': 'type_error.tuple',\n+        },\n+    ]\n+\n+\n+def test_set():\n+    class Model(BaseModel):\n+        v: set\n+\n+    assert Model(v={1, 2, 2, '3'}).v == {1, 2, '3'}\n+    assert Model(v='xyzxyz').v == {'x', 'y', 'z'}\n+    assert Model(v={i**2 for i in range(5)}).v == {0, 1, 4, 9, 16}\n+\n+    with pytest.raises(ValidationError) as exc_info:\n+        Model(v=1)\n+    assert exc_info.value.flatten_errors() == [\n+        {\n+            'loc': ('v',),\n+            'msg': 'value is not a valid set',\n+            'type': 'type_error.set',\n+        },\n+    ]\n+\n+\n+def test_int_validation():\n+    class Model(BaseModel):\n+        a: PositiveInt = None\n+        b: NegativeInt = None\n+        c: conint(gt=4, lt=10) = None\n+\n+    m = Model(a=5, b=-5, c=5)\n+    assert m == {'a': 5, 'b': -5, 'c': 5}\n+\n+    with pytest.raises(ValidationError) as exc_info:\n+        Model(a=-5, b=5, c=-5)\n     assert exc_info.value.flatten_errors() == [\n",
        "source_code_with_indent": "\n<DED><DED><DED>class ListDictTupleModel(BaseModel):\n    <IND>a: dict = None\n    b: list = None\n    c: OrderedDict = None\n    d: tuple = None\n\n\n<DED>def test_dict():\n    <IND>assert ListDictTupleModel(a={1: 10, 2: 20}).a == {1: 10, 2: 20}\n    assert ListDictTupleModel(a=[(1, 2), (3, 4)]).a == {1: 2, 3: 4}\n\n    with pytest.raises(ValidationError) as exc_info:\n        <IND>ListDictTupleModel(a=[1, 2, 3])\n    <DED>assert exc_info.value.flatten_errors() == [\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n<DED><DED><DED>def test_dict():\n    <IND>class Model(BaseModel):\n        <IND>v: dict\n\n    <DED>assert Model(v={1: 10, 2: 20}).v == {1: 10, 2: 20}\n    assert Model(v=[(1, 2), (3, 4)]).v == {1: 2, 3: 4}\n\n    with pytest.raises(ValidationError) as exc_info:\n        <IND>Model(v=[1, 2, 3])\n    <DED>assert exc_info.value.flatten_errors() == [\n        {\n            'loc': ('v',),\n            'msg': 'value is not a valid dict',\n            'type': 'type_error.dict',\n        },\n    ]\n\n\n<DED>def test_list():\n    <IND>class Model(BaseModel):\n        <IND>v: list\n\n    <DED>assert Model(v=[1, 2, '3']).v == [1, 2, '3']\n    assert Model(v='xyz').v == ['x', 'y', 'z']\n    assert Model(v=(i**2 for i in range(5))).v == [0, 1, 4, 9, 16]\n\n    with pytest.raises(ValidationError) as exc_info:\n        <IND>Model(v=1)\n    <DED>assert exc_info.value.flatten_errors() == [\n        {\n            'loc': ('v',),\n            'msg': 'value is not a valid list',\n            'type': 'type_error.list',\n        },\n    ]\n\n\n<DED>def test_ordered_dict():\n    <IND>class Model(BaseModel):\n        <IND>v: OrderedDict\n\n    <DED>assert Model(v=OrderedDict([(1, 10), (2, 20)])).v == OrderedDict([(1, 10), (2, 20)])\n    assert Model(v={1: 10, 2: 20}).v in (OrderedDict([(1, 10), (2, 20)]), OrderedDict([(2, 20), (1, 10)]))\n    assert Model(v=[(1, 2), (3, 4)]).v == OrderedDict([(1, 2), (3, 4)])\n\n    with pytest.raises(ValidationError) as exc_info:\n        <IND>Model(v=[1, 2, 3])\n    <DED>assert exc_info.value.flatten_errors() == [\n        {\n            'loc': ('v',),\n            'msg': 'value is not a valid dict',\n            'type': 'type_error.dict',\n        },\n    ]\n\n\n<DED>def test_tuple():\n    <IND>class Model(BaseModel):\n        <IND>v: tuple\n\n    <DED>assert Model(v=(1, 2, '3')).v == (1, 2, '3')\n    assert Model(v='xyz').v == ('x', 'y', 'z')\n    assert Model(v=(i**2 for i in range(5))).v == (0, 1, 4, 9, 16)\n\n    with pytest.raises(ValidationError) as exc_info:\n        <IND>Model(v=1)\n    <DED>assert exc_info.value.flatten_errors() == [\n        {\n            'loc': ('v',),\n            'msg': 'value is not a valid tuple',\n            'type': 'type_error.tuple',\n        },\n    ]\n\n\n<DED>def test_set():\n    <IND>class Model(BaseModel):\n        <IND>v: set\n\n    <DED>assert Model(v={1, 2, 2, '3'}).v == {1, 2, '3'}\n    assert Model(v='xyzxyz').v == {'x', 'y', 'z'}\n    assert Model(v={i**2 for i in range(5)}).v == {0, 1, 4, 9, 16}\n\n    with pytest.raises(ValidationError) as exc_info:\n        <IND>Model(v=1)\n    <DED>assert exc_info.value.flatten_errors() == [\n        {\n            'loc': ('v',),\n            'msg': 'value is not a valid set',\n            'type': 'type_error.set',\n        },\n    ]\n\n\n<DED>def test_int_validation():\n    <IND>class Model(BaseModel):\n        <IND>a: PositiveInt = None\n        b: NegativeInt = None\n        c: conint(gt=4, lt=10) = None\n\n    <DED>m = Model(a=5, b=-5, c=5)\n    assert m == {'a': 5, 'b': -5, 'c': 5}\n\n    with pytest.raises(ValidationError) as exc_info:\n        <IND>Model(a=-5, b=5, c=-5)\n    <DED>assert exc_info.value.flatten_errors() == [\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "samuelcolvin/pydantic",
    "commit": "4f4e22ef47ab04b289976bb4ba4904e3c701e72d",
    "filename": "tests/test_types.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/samuelcolvin-pydantic/tests/test_types.py",
    "file_hunks_size": 33,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "tests/test_types.py:519:4 Incompatible attribute type [8]: Attribute `a` declared in class `IntModel` has type `pydantic.types.PositiveInt` but is used as type `None`.",
    "message": " Attribute `a` declared in class `IntModel` has type `pydantic.types.PositiveInt` but is used as type `None`.",
    "rule_id": "Incompatible attribute type [8]",
    "warning_line_no": 519,
    "warning_line": "    a: PositiveInt = None",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "            'loc': ('a',),\n            'msg': 'value is not a valid dict, got list',\n            'type': 'type_error',\n        },\n    ]\n\n\ndef test_list():\n    m = ListDictTupleModel(b=[1, 2, '3'])\n    assert m.a is None\n    assert m.b == [1, 2, '3']\n    assert ListDictTupleModel(b='xyz').b == ['x', 'y', 'z']\n    assert ListDictTupleModel(b=(i**2 for i in range(5))).b == [0, 1, 4, 9, 16]\n\n    with pytest.raises(ValidationError) as exc_info:\n        ListDictTupleModel(b=1)\n    assert exc_info.value.flatten_errors() == [\n        {\n            'loc': ('b',),\n            'msg': '\\'int\\' object is not iterable',\n            'type': 'type_error',\n        },\n    ]\n\n\ndef test_ordered_dict():\n    assert ListDictTupleModel(c=OrderedDict([(1, 10), (2, 20)])).c == OrderedDict([(1, 10), (2, 20)])\n    assert ListDictTupleModel(c={1: 10, 2: 20}).c in (OrderedDict([(1, 10), (2, 20)]), OrderedDict([(2, 20), (1, 10)]))\n    assert ListDictTupleModel(c=[(1, 2), (3, 4)]).c == OrderedDict([(1, 2), (3, 4)])\n\n    with pytest.raises(ValidationError) as exc_info:\n        ListDictTupleModel(c=[1, 2, 3])\n    assert exc_info.value.flatten_errors() == [\n        {\n            'loc': ('c',),\n            'msg': '\\'int\\' object is not iterable',\n            'type': 'type_error',\n        },\n    ]\n\n\ndef test_tuple():\n    m = ListDictTupleModel(d=(1, 2, '3'))\n    assert m.a is None\n    assert m.d == (1, 2, '3')\n    assert m.dict() == {'a': None, 'b': None, 'c': None, 'd': (1, 2, '3')}\n    assert ListDictTupleModel(d='xyz').d == ('x', 'y', 'z')\n    assert ListDictTupleModel(d=(i**2 for i in range(5))).d == (0, 1, 4, 9, 16)\n\n    with pytest.raises(ValidationError) as exc_info:\n        ListDictTupleModel(d=1)\n    assert exc_info.value.flatten_errors() == [\n        {\n            'loc': ('d',),\n            'msg': '\\'int\\' object is not iterable',\n            'type': 'type_error',\n        },\n    ]\n\n\nclass IntModel(BaseModel):\n    a: PositiveInt = None\n    b: NegativeInt = None\n    c: conint(gt=4, lt=10) = None\n\n\ndef test_int_validation():\n    m = IntModel(a=5, b=-5, c=5)\n    assert m == {'a': 5, 'b': -5, 'c': 5}\n\n    with pytest.raises(ValidationError) as exc_info:\n        IntModel(a=-5, b=5, c=-5)\n    assert exc_info.value.flatten_errors() == [\n",
        "source_code_len": 2242,
        "target_code": "            'loc': ('a',),\n            'msg': 'ensure this value is greater than 0',\n            'type': 'value_error.number.min_size',\n            'ctx': {\n                'limit_value': 0,\n            },\n        },\n        {\n            'loc': ('b',),\n            'msg': 'ensure this value is less than 0',\n            'type': 'value_error.number.max_size',\n            'ctx': {\n                'limit_value': 0,\n            },\n        },\n        {\n            'loc': ('c',),\n            'msg': 'ensure this value is greater than 4',\n            'type': 'value_error.number.min_size',\n            'ctx': {\n                'limit_value': 4,\n            },\n        },\n    ]\n\n\ndef test_float_validation():\n    class Model(BaseModel):\n        a: PositiveFloat = None\n        b: NegativeFloat = None\n        c: confloat(gt=4, lt=12.2) = None\n\n    m = Model(a=5.1, b=-5.2, c=5.3)\n    assert m == {'a': 5.1, 'b': -5.2, 'c': 5.3}\n\n    with pytest.raises(ValidationError) as exc_info:\n        Model(a=-5.1, b=5.2, c=-5.3)\n    assert exc_info.value.flatten_errors() == [\n",
        "target_code_len": 1063,
        "diff_format": "@@ -458,73 +520,38 @@\n             'loc': ('a',),\n-            'msg': 'value is not a valid dict, got list',\n-            'type': 'type_error',\n-        },\n-    ]\n-\n-\n-def test_list():\n-    m = ListDictTupleModel(b=[1, 2, '3'])\n-    assert m.a is None\n-    assert m.b == [1, 2, '3']\n-    assert ListDictTupleModel(b='xyz').b == ['x', 'y', 'z']\n-    assert ListDictTupleModel(b=(i**2 for i in range(5))).b == [0, 1, 4, 9, 16]\n-\n-    with pytest.raises(ValidationError) as exc_info:\n-        ListDictTupleModel(b=1)\n-    assert exc_info.value.flatten_errors() == [\n+            'msg': 'ensure this value is greater than 0',\n+            'type': 'value_error.number.min_size',\n+            'ctx': {\n+                'limit_value': 0,\n+            },\n+        },\n         {\n             'loc': ('b',),\n-            'msg': '\\'int\\' object is not iterable',\n-            'type': 'type_error',\n-        },\n-    ]\n-\n-\n-def test_ordered_dict():\n-    assert ListDictTupleModel(c=OrderedDict([(1, 10), (2, 20)])).c == OrderedDict([(1, 10), (2, 20)])\n-    assert ListDictTupleModel(c={1: 10, 2: 20}).c in (OrderedDict([(1, 10), (2, 20)]), OrderedDict([(2, 20), (1, 10)]))\n-    assert ListDictTupleModel(c=[(1, 2), (3, 4)]).c == OrderedDict([(1, 2), (3, 4)])\n-\n-    with pytest.raises(ValidationError) as exc_info:\n-        ListDictTupleModel(c=[1, 2, 3])\n-    assert exc_info.value.flatten_errors() == [\n+            'msg': 'ensure this value is less than 0',\n+            'type': 'value_error.number.max_size',\n+            'ctx': {\n+                'limit_value': 0,\n+            },\n+        },\n         {\n             'loc': ('c',),\n-            'msg': '\\'int\\' object is not iterable',\n-            'type': 'type_error',\n-        },\n-    ]\n-\n-\n-def test_tuple():\n-    m = ListDictTupleModel(d=(1, 2, '3'))\n-    assert m.a is None\n-    assert m.d == (1, 2, '3')\n-    assert m.dict() == {'a': None, 'b': None, 'c': None, 'd': (1, 2, '3')}\n-    assert ListDictTupleModel(d='xyz').d == ('x', 'y', 'z')\n-    assert ListDictTupleModel(d=(i**2 for i in range(5))).d == (0, 1, 4, 9, 16)\n-\n-    with pytest.raises(ValidationError) as exc_info:\n-        ListDictTupleModel(d=1)\n-    assert exc_info.value.flatten_errors() == [\n-        {\n-            'loc': ('d',),\n-            'msg': '\\'int\\' object is not iterable',\n-            'type': 'type_error',\n-        },\n-    ]\n-\n-\n-class IntModel(BaseModel):\n-    a: PositiveInt = None\n-    b: NegativeInt = None\n-    c: conint(gt=4, lt=10) = None\n-\n-\n-def test_int_validation():\n-    m = IntModel(a=5, b=-5, c=5)\n-    assert m == {'a': 5, 'b': -5, 'c': 5}\n-\n-    with pytest.raises(ValidationError) as exc_info:\n-        IntModel(a=-5, b=5, c=-5)\n+            'msg': 'ensure this value is greater than 4',\n+            'type': 'value_error.number.min_size',\n+            'ctx': {\n+                'limit_value': 4,\n+            },\n+        },\n+    ]\n+\n+\n+def test_float_validation():\n+    class Model(BaseModel):\n+        a: PositiveFloat = None\n+        b: NegativeFloat = None\n+        c: confloat(gt=4, lt=12.2) = None\n+\n+    m = Model(a=5.1, b=-5.2, c=5.3)\n+    assert m == {'a': 5.1, 'b': -5.2, 'c': 5.3}\n+\n+    with pytest.raises(ValidationError) as exc_info:\n+        Model(a=-5.1, b=5.2, c=-5.3)\n     assert exc_info.value.flatten_errors() == [\n",
        "source_code_with_indent": "            'loc': ('a',),\n            'msg': 'value is not a valid dict, got list',\n            'type': 'type_error',\n        },\n    ]\n\n\n<DED>def test_list():\n    <IND>m = ListDictTupleModel(b=[1, 2, '3'])\n    assert m.a is None\n    assert m.b == [1, 2, '3']\n    assert ListDictTupleModel(b='xyz').b == ['x', 'y', 'z']\n    assert ListDictTupleModel(b=(i**2 for i in range(5))).b == [0, 1, 4, 9, 16]\n\n    with pytest.raises(ValidationError) as exc_info:\n        <IND>ListDictTupleModel(b=1)\n    <DED>assert exc_info.value.flatten_errors() == [\n        {\n            'loc': ('b',),\n            'msg': '\\'int\\' object is not iterable',\n            'type': 'type_error',\n        },\n    ]\n\n\n<DED>def test_ordered_dict():\n    <IND>assert ListDictTupleModel(c=OrderedDict([(1, 10), (2, 20)])).c == OrderedDict([(1, 10), (2, 20)])\n    assert ListDictTupleModel(c={1: 10, 2: 20}).c in (OrderedDict([(1, 10), (2, 20)]), OrderedDict([(2, 20), (1, 10)]))\n    assert ListDictTupleModel(c=[(1, 2), (3, 4)]).c == OrderedDict([(1, 2), (3, 4)])\n\n    with pytest.raises(ValidationError) as exc_info:\n        <IND>ListDictTupleModel(c=[1, 2, 3])\n    <DED>assert exc_info.value.flatten_errors() == [\n        {\n            'loc': ('c',),\n            'msg': '\\'int\\' object is not iterable',\n            'type': 'type_error',\n        },\n    ]\n\n\n<DED>def test_tuple():\n    <IND>m = ListDictTupleModel(d=(1, 2, '3'))\n    assert m.a is None\n    assert m.d == (1, 2, '3')\n    assert m.dict() == {'a': None, 'b': None, 'c': None, 'd': (1, 2, '3')}\n    assert ListDictTupleModel(d='xyz').d == ('x', 'y', 'z')\n    assert ListDictTupleModel(d=(i**2 for i in range(5))).d == (0, 1, 4, 9, 16)\n\n    with pytest.raises(ValidationError) as exc_info:\n        <IND>ListDictTupleModel(d=1)\n    <DED>assert exc_info.value.flatten_errors() == [\n        {\n            'loc': ('d',),\n            'msg': '\\'int\\' object is not iterable',\n            'type': 'type_error',\n        },\n    ]\n\n\n<DED>class IntModel(BaseModel):\n    <IND>a: PositiveInt = None\n    b: NegativeInt = None\n    c: conint(gt=4, lt=10) = None\n\n\n<DED>def test_int_validation():\n    <IND>m = IntModel(a=5, b=-5, c=5)\n    assert m == {'a': 5, 'b': -5, 'c': 5}\n\n    with pytest.raises(ValidationError) as exc_info:\n        <IND>IntModel(a=-5, b=5, c=-5)\n    <DED>assert exc_info.value.flatten_errors() == [\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "            'loc': ('a',),\n            'msg': 'ensure this value is greater than 0',\n            'type': 'value_error.number.min_size',\n            'ctx': {\n                'limit_value': 0,\n            },\n        },\n        {\n            'loc': ('b',),\n            'msg': 'ensure this value is less than 0',\n            'type': 'value_error.number.max_size',\n            'ctx': {\n                'limit_value': 0,\n            },\n        },\n        {\n            'loc': ('c',),\n            'msg': 'ensure this value is greater than 4',\n            'type': 'value_error.number.min_size',\n            'ctx': {\n                'limit_value': 4,\n            },\n        },\n    ]\n\n\n<DED>def test_float_validation():\n    <IND>class Model(BaseModel):\n        <IND>a: PositiveFloat = None\n        b: NegativeFloat = None\n        c: confloat(gt=4, lt=12.2) = None\n\n    <DED>m = Model(a=5.1, b=-5.2, c=5.3)\n    assert m == {'a': 5.1, 'b': -5.2, 'c': 5.3}\n\n    with pytest.raises(ValidationError) as exc_info:\n        <IND>Model(a=-5.1, b=5.2, c=-5.3)\n    <DED>assert exc_info.value.flatten_errors() == [\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "samuelcolvin/pydantic",
    "commit": "4f4e22ef47ab04b289976bb4ba4904e3c701e72d",
    "filename": "tests/test_types.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/samuelcolvin-pydantic/tests/test_types.py",
    "file_hunks_size": 33,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "tests/test_types.py:520:4 Incompatible attribute type [8]: Attribute `b` declared in class `IntModel` has type `pydantic.types.NegativeInt` but is used as type `None`.",
    "message": " Attribute `b` declared in class `IntModel` has type `pydantic.types.NegativeInt` but is used as type `None`.",
    "rule_id": "Incompatible attribute type [8]",
    "warning_line_no": 520,
    "warning_line": "    b: NegativeInt = None",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "            'loc': ('a',),\n            'msg': 'value is not a valid dict, got list',\n            'type': 'type_error',\n        },\n    ]\n\n\ndef test_list():\n    m = ListDictTupleModel(b=[1, 2, '3'])\n    assert m.a is None\n    assert m.b == [1, 2, '3']\n    assert ListDictTupleModel(b='xyz').b == ['x', 'y', 'z']\n    assert ListDictTupleModel(b=(i**2 for i in range(5))).b == [0, 1, 4, 9, 16]\n\n    with pytest.raises(ValidationError) as exc_info:\n        ListDictTupleModel(b=1)\n    assert exc_info.value.flatten_errors() == [\n        {\n            'loc': ('b',),\n            'msg': '\\'int\\' object is not iterable',\n            'type': 'type_error',\n        },\n    ]\n\n\ndef test_ordered_dict():\n    assert ListDictTupleModel(c=OrderedDict([(1, 10), (2, 20)])).c == OrderedDict([(1, 10), (2, 20)])\n    assert ListDictTupleModel(c={1: 10, 2: 20}).c in (OrderedDict([(1, 10), (2, 20)]), OrderedDict([(2, 20), (1, 10)]))\n    assert ListDictTupleModel(c=[(1, 2), (3, 4)]).c == OrderedDict([(1, 2), (3, 4)])\n\n    with pytest.raises(ValidationError) as exc_info:\n        ListDictTupleModel(c=[1, 2, 3])\n    assert exc_info.value.flatten_errors() == [\n        {\n            'loc': ('c',),\n            'msg': '\\'int\\' object is not iterable',\n            'type': 'type_error',\n        },\n    ]\n\n\ndef test_tuple():\n    m = ListDictTupleModel(d=(1, 2, '3'))\n    assert m.a is None\n    assert m.d == (1, 2, '3')\n    assert m.dict() == {'a': None, 'b': None, 'c': None, 'd': (1, 2, '3')}\n    assert ListDictTupleModel(d='xyz').d == ('x', 'y', 'z')\n    assert ListDictTupleModel(d=(i**2 for i in range(5))).d == (0, 1, 4, 9, 16)\n\n    with pytest.raises(ValidationError) as exc_info:\n        ListDictTupleModel(d=1)\n    assert exc_info.value.flatten_errors() == [\n        {\n            'loc': ('d',),\n            'msg': '\\'int\\' object is not iterable',\n            'type': 'type_error',\n        },\n    ]\n\n\nclass IntModel(BaseModel):\n    a: PositiveInt = None\n    b: NegativeInt = None\n    c: conint(gt=4, lt=10) = None\n\n\ndef test_int_validation():\n    m = IntModel(a=5, b=-5, c=5)\n    assert m == {'a': 5, 'b': -5, 'c': 5}\n\n    with pytest.raises(ValidationError) as exc_info:\n        IntModel(a=-5, b=5, c=-5)\n    assert exc_info.value.flatten_errors() == [\n",
        "source_code_len": 2242,
        "target_code": "            'loc': ('a',),\n            'msg': 'ensure this value is greater than 0',\n            'type': 'value_error.number.min_size',\n            'ctx': {\n                'limit_value': 0,\n            },\n        },\n        {\n            'loc': ('b',),\n            'msg': 'ensure this value is less than 0',\n            'type': 'value_error.number.max_size',\n            'ctx': {\n                'limit_value': 0,\n            },\n        },\n        {\n            'loc': ('c',),\n            'msg': 'ensure this value is greater than 4',\n            'type': 'value_error.number.min_size',\n            'ctx': {\n                'limit_value': 4,\n            },\n        },\n    ]\n\n\ndef test_float_validation():\n    class Model(BaseModel):\n        a: PositiveFloat = None\n        b: NegativeFloat = None\n        c: confloat(gt=4, lt=12.2) = None\n\n    m = Model(a=5.1, b=-5.2, c=5.3)\n    assert m == {'a': 5.1, 'b': -5.2, 'c': 5.3}\n\n    with pytest.raises(ValidationError) as exc_info:\n        Model(a=-5.1, b=5.2, c=-5.3)\n    assert exc_info.value.flatten_errors() == [\n",
        "target_code_len": 1063,
        "diff_format": "@@ -458,73 +520,38 @@\n             'loc': ('a',),\n-            'msg': 'value is not a valid dict, got list',\n-            'type': 'type_error',\n-        },\n-    ]\n-\n-\n-def test_list():\n-    m = ListDictTupleModel(b=[1, 2, '3'])\n-    assert m.a is None\n-    assert m.b == [1, 2, '3']\n-    assert ListDictTupleModel(b='xyz').b == ['x', 'y', 'z']\n-    assert ListDictTupleModel(b=(i**2 for i in range(5))).b == [0, 1, 4, 9, 16]\n-\n-    with pytest.raises(ValidationError) as exc_info:\n-        ListDictTupleModel(b=1)\n-    assert exc_info.value.flatten_errors() == [\n+            'msg': 'ensure this value is greater than 0',\n+            'type': 'value_error.number.min_size',\n+            'ctx': {\n+                'limit_value': 0,\n+            },\n+        },\n         {\n             'loc': ('b',),\n-            'msg': '\\'int\\' object is not iterable',\n-            'type': 'type_error',\n-        },\n-    ]\n-\n-\n-def test_ordered_dict():\n-    assert ListDictTupleModel(c=OrderedDict([(1, 10), (2, 20)])).c == OrderedDict([(1, 10), (2, 20)])\n-    assert ListDictTupleModel(c={1: 10, 2: 20}).c in (OrderedDict([(1, 10), (2, 20)]), OrderedDict([(2, 20), (1, 10)]))\n-    assert ListDictTupleModel(c=[(1, 2), (3, 4)]).c == OrderedDict([(1, 2), (3, 4)])\n-\n-    with pytest.raises(ValidationError) as exc_info:\n-        ListDictTupleModel(c=[1, 2, 3])\n-    assert exc_info.value.flatten_errors() == [\n+            'msg': 'ensure this value is less than 0',\n+            'type': 'value_error.number.max_size',\n+            'ctx': {\n+                'limit_value': 0,\n+            },\n+        },\n         {\n             'loc': ('c',),\n-            'msg': '\\'int\\' object is not iterable',\n-            'type': 'type_error',\n-        },\n-    ]\n-\n-\n-def test_tuple():\n-    m = ListDictTupleModel(d=(1, 2, '3'))\n-    assert m.a is None\n-    assert m.d == (1, 2, '3')\n-    assert m.dict() == {'a': None, 'b': None, 'c': None, 'd': (1, 2, '3')}\n-    assert ListDictTupleModel(d='xyz').d == ('x', 'y', 'z')\n-    assert ListDictTupleModel(d=(i**2 for i in range(5))).d == (0, 1, 4, 9, 16)\n-\n-    with pytest.raises(ValidationError) as exc_info:\n-        ListDictTupleModel(d=1)\n-    assert exc_info.value.flatten_errors() == [\n-        {\n-            'loc': ('d',),\n-            'msg': '\\'int\\' object is not iterable',\n-            'type': 'type_error',\n-        },\n-    ]\n-\n-\n-class IntModel(BaseModel):\n-    a: PositiveInt = None\n-    b: NegativeInt = None\n-    c: conint(gt=4, lt=10) = None\n-\n-\n-def test_int_validation():\n-    m = IntModel(a=5, b=-5, c=5)\n-    assert m == {'a': 5, 'b': -5, 'c': 5}\n-\n-    with pytest.raises(ValidationError) as exc_info:\n-        IntModel(a=-5, b=5, c=-5)\n+            'msg': 'ensure this value is greater than 4',\n+            'type': 'value_error.number.min_size',\n+            'ctx': {\n+                'limit_value': 4,\n+            },\n+        },\n+    ]\n+\n+\n+def test_float_validation():\n+    class Model(BaseModel):\n+        a: PositiveFloat = None\n+        b: NegativeFloat = None\n+        c: confloat(gt=4, lt=12.2) = None\n+\n+    m = Model(a=5.1, b=-5.2, c=5.3)\n+    assert m == {'a': 5.1, 'b': -5.2, 'c': 5.3}\n+\n+    with pytest.raises(ValidationError) as exc_info:\n+        Model(a=-5.1, b=5.2, c=-5.3)\n     assert exc_info.value.flatten_errors() == [\n",
        "source_code_with_indent": "            'loc': ('a',),\n            'msg': 'value is not a valid dict, got list',\n            'type': 'type_error',\n        },\n    ]\n\n\n<DED>def test_list():\n    <IND>m = ListDictTupleModel(b=[1, 2, '3'])\n    assert m.a is None\n    assert m.b == [1, 2, '3']\n    assert ListDictTupleModel(b='xyz').b == ['x', 'y', 'z']\n    assert ListDictTupleModel(b=(i**2 for i in range(5))).b == [0, 1, 4, 9, 16]\n\n    with pytest.raises(ValidationError) as exc_info:\n        <IND>ListDictTupleModel(b=1)\n    <DED>assert exc_info.value.flatten_errors() == [\n        {\n            'loc': ('b',),\n            'msg': '\\'int\\' object is not iterable',\n            'type': 'type_error',\n        },\n    ]\n\n\n<DED>def test_ordered_dict():\n    <IND>assert ListDictTupleModel(c=OrderedDict([(1, 10), (2, 20)])).c == OrderedDict([(1, 10), (2, 20)])\n    assert ListDictTupleModel(c={1: 10, 2: 20}).c in (OrderedDict([(1, 10), (2, 20)]), OrderedDict([(2, 20), (1, 10)]))\n    assert ListDictTupleModel(c=[(1, 2), (3, 4)]).c == OrderedDict([(1, 2), (3, 4)])\n\n    with pytest.raises(ValidationError) as exc_info:\n        <IND>ListDictTupleModel(c=[1, 2, 3])\n    <DED>assert exc_info.value.flatten_errors() == [\n        {\n            'loc': ('c',),\n            'msg': '\\'int\\' object is not iterable',\n            'type': 'type_error',\n        },\n    ]\n\n\n<DED>def test_tuple():\n    <IND>m = ListDictTupleModel(d=(1, 2, '3'))\n    assert m.a is None\n    assert m.d == (1, 2, '3')\n    assert m.dict() == {'a': None, 'b': None, 'c': None, 'd': (1, 2, '3')}\n    assert ListDictTupleModel(d='xyz').d == ('x', 'y', 'z')\n    assert ListDictTupleModel(d=(i**2 for i in range(5))).d == (0, 1, 4, 9, 16)\n\n    with pytest.raises(ValidationError) as exc_info:\n        <IND>ListDictTupleModel(d=1)\n    <DED>assert exc_info.value.flatten_errors() == [\n        {\n            'loc': ('d',),\n            'msg': '\\'int\\' object is not iterable',\n            'type': 'type_error',\n        },\n    ]\n\n\n<DED>class IntModel(BaseModel):\n    <IND>a: PositiveInt = None\n    b: NegativeInt = None\n    c: conint(gt=4, lt=10) = None\n\n\n<DED>def test_int_validation():\n    <IND>m = IntModel(a=5, b=-5, c=5)\n    assert m == {'a': 5, 'b': -5, 'c': 5}\n\n    with pytest.raises(ValidationError) as exc_info:\n        <IND>IntModel(a=-5, b=5, c=-5)\n    <DED>assert exc_info.value.flatten_errors() == [\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "            'loc': ('a',),\n            'msg': 'ensure this value is greater than 0',\n            'type': 'value_error.number.min_size',\n            'ctx': {\n                'limit_value': 0,\n            },\n        },\n        {\n            'loc': ('b',),\n            'msg': 'ensure this value is less than 0',\n            'type': 'value_error.number.max_size',\n            'ctx': {\n                'limit_value': 0,\n            },\n        },\n        {\n            'loc': ('c',),\n            'msg': 'ensure this value is greater than 4',\n            'type': 'value_error.number.min_size',\n            'ctx': {\n                'limit_value': 4,\n            },\n        },\n    ]\n\n\n<DED>def test_float_validation():\n    <IND>class Model(BaseModel):\n        <IND>a: PositiveFloat = None\n        b: NegativeFloat = None\n        c: confloat(gt=4, lt=12.2) = None\n\n    <DED>m = Model(a=5.1, b=-5.2, c=5.3)\n    assert m == {'a': 5.1, 'b': -5.2, 'c': 5.3}\n\n    with pytest.raises(ValidationError) as exc_info:\n        <IND>Model(a=-5.1, b=5.2, c=-5.3)\n    <DED>assert exc_info.value.flatten_errors() == [\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "samuelcolvin/pydantic",
    "commit": "4f4e22ef47ab04b289976bb4ba4904e3c701e72d",
    "filename": "tests/test_types.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/samuelcolvin-pydantic/tests/test_types.py",
    "file_hunks_size": 33,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "tests/test_types.py:521:7 Invalid type [31]: Expression `pydantic.conint($parameter$gt = 4, $parameter$lt = 10)` is not a valid type.",
    "message": " Expression `pydantic.conint($parameter$gt = 4, $parameter$lt = 10)` is not a valid type.",
    "rule_id": "Invalid type [31]",
    "warning_line_no": 521,
    "warning_line": "    c: conint(gt=4, lt=10) = None",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "            'loc': ('a',),\n            'msg': 'value is not a valid dict, got list',\n            'type': 'type_error',\n        },\n    ]\n\n\ndef test_list():\n    m = ListDictTupleModel(b=[1, 2, '3'])\n    assert m.a is None\n    assert m.b == [1, 2, '3']\n    assert ListDictTupleModel(b='xyz').b == ['x', 'y', 'z']\n    assert ListDictTupleModel(b=(i**2 for i in range(5))).b == [0, 1, 4, 9, 16]\n\n    with pytest.raises(ValidationError) as exc_info:\n        ListDictTupleModel(b=1)\n    assert exc_info.value.flatten_errors() == [\n        {\n            'loc': ('b',),\n            'msg': '\\'int\\' object is not iterable',\n            'type': 'type_error',\n        },\n    ]\n\n\ndef test_ordered_dict():\n    assert ListDictTupleModel(c=OrderedDict([(1, 10), (2, 20)])).c == OrderedDict([(1, 10), (2, 20)])\n    assert ListDictTupleModel(c={1: 10, 2: 20}).c in (OrderedDict([(1, 10), (2, 20)]), OrderedDict([(2, 20), (1, 10)]))\n    assert ListDictTupleModel(c=[(1, 2), (3, 4)]).c == OrderedDict([(1, 2), (3, 4)])\n\n    with pytest.raises(ValidationError) as exc_info:\n        ListDictTupleModel(c=[1, 2, 3])\n    assert exc_info.value.flatten_errors() == [\n        {\n            'loc': ('c',),\n            'msg': '\\'int\\' object is not iterable',\n            'type': 'type_error',\n        },\n    ]\n\n\ndef test_tuple():\n    m = ListDictTupleModel(d=(1, 2, '3'))\n    assert m.a is None\n    assert m.d == (1, 2, '3')\n    assert m.dict() == {'a': None, 'b': None, 'c': None, 'd': (1, 2, '3')}\n    assert ListDictTupleModel(d='xyz').d == ('x', 'y', 'z')\n    assert ListDictTupleModel(d=(i**2 for i in range(5))).d == (0, 1, 4, 9, 16)\n\n    with pytest.raises(ValidationError) as exc_info:\n        ListDictTupleModel(d=1)\n    assert exc_info.value.flatten_errors() == [\n        {\n            'loc': ('d',),\n            'msg': '\\'int\\' object is not iterable',\n            'type': 'type_error',\n        },\n    ]\n\n\nclass IntModel(BaseModel):\n    a: PositiveInt = None\n    b: NegativeInt = None\n    c: conint(gt=4, lt=10) = None\n\n\ndef test_int_validation():\n    m = IntModel(a=5, b=-5, c=5)\n    assert m == {'a': 5, 'b': -5, 'c': 5}\n\n    with pytest.raises(ValidationError) as exc_info:\n        IntModel(a=-5, b=5, c=-5)\n    assert exc_info.value.flatten_errors() == [\n",
        "source_code_len": 2242,
        "target_code": "            'loc': ('a',),\n            'msg': 'ensure this value is greater than 0',\n            'type': 'value_error.number.min_size',\n            'ctx': {\n                'limit_value': 0,\n            },\n        },\n        {\n            'loc': ('b',),\n            'msg': 'ensure this value is less than 0',\n            'type': 'value_error.number.max_size',\n            'ctx': {\n                'limit_value': 0,\n            },\n        },\n        {\n            'loc': ('c',),\n            'msg': 'ensure this value is greater than 4',\n            'type': 'value_error.number.min_size',\n            'ctx': {\n                'limit_value': 4,\n            },\n        },\n    ]\n\n\ndef test_float_validation():\n    class Model(BaseModel):\n        a: PositiveFloat = None\n        b: NegativeFloat = None\n        c: confloat(gt=4, lt=12.2) = None\n\n    m = Model(a=5.1, b=-5.2, c=5.3)\n    assert m == {'a': 5.1, 'b': -5.2, 'c': 5.3}\n\n    with pytest.raises(ValidationError) as exc_info:\n        Model(a=-5.1, b=5.2, c=-5.3)\n    assert exc_info.value.flatten_errors() == [\n",
        "target_code_len": 1063,
        "diff_format": "@@ -458,73 +520,38 @@\n             'loc': ('a',),\n-            'msg': 'value is not a valid dict, got list',\n-            'type': 'type_error',\n-        },\n-    ]\n-\n-\n-def test_list():\n-    m = ListDictTupleModel(b=[1, 2, '3'])\n-    assert m.a is None\n-    assert m.b == [1, 2, '3']\n-    assert ListDictTupleModel(b='xyz').b == ['x', 'y', 'z']\n-    assert ListDictTupleModel(b=(i**2 for i in range(5))).b == [0, 1, 4, 9, 16]\n-\n-    with pytest.raises(ValidationError) as exc_info:\n-        ListDictTupleModel(b=1)\n-    assert exc_info.value.flatten_errors() == [\n+            'msg': 'ensure this value is greater than 0',\n+            'type': 'value_error.number.min_size',\n+            'ctx': {\n+                'limit_value': 0,\n+            },\n+        },\n         {\n             'loc': ('b',),\n-            'msg': '\\'int\\' object is not iterable',\n-            'type': 'type_error',\n-        },\n-    ]\n-\n-\n-def test_ordered_dict():\n-    assert ListDictTupleModel(c=OrderedDict([(1, 10), (2, 20)])).c == OrderedDict([(1, 10), (2, 20)])\n-    assert ListDictTupleModel(c={1: 10, 2: 20}).c in (OrderedDict([(1, 10), (2, 20)]), OrderedDict([(2, 20), (1, 10)]))\n-    assert ListDictTupleModel(c=[(1, 2), (3, 4)]).c == OrderedDict([(1, 2), (3, 4)])\n-\n-    with pytest.raises(ValidationError) as exc_info:\n-        ListDictTupleModel(c=[1, 2, 3])\n-    assert exc_info.value.flatten_errors() == [\n+            'msg': 'ensure this value is less than 0',\n+            'type': 'value_error.number.max_size',\n+            'ctx': {\n+                'limit_value': 0,\n+            },\n+        },\n         {\n             'loc': ('c',),\n-            'msg': '\\'int\\' object is not iterable',\n-            'type': 'type_error',\n-        },\n-    ]\n-\n-\n-def test_tuple():\n-    m = ListDictTupleModel(d=(1, 2, '3'))\n-    assert m.a is None\n-    assert m.d == (1, 2, '3')\n-    assert m.dict() == {'a': None, 'b': None, 'c': None, 'd': (1, 2, '3')}\n-    assert ListDictTupleModel(d='xyz').d == ('x', 'y', 'z')\n-    assert ListDictTupleModel(d=(i**2 for i in range(5))).d == (0, 1, 4, 9, 16)\n-\n-    with pytest.raises(ValidationError) as exc_info:\n-        ListDictTupleModel(d=1)\n-    assert exc_info.value.flatten_errors() == [\n-        {\n-            'loc': ('d',),\n-            'msg': '\\'int\\' object is not iterable',\n-            'type': 'type_error',\n-        },\n-    ]\n-\n-\n-class IntModel(BaseModel):\n-    a: PositiveInt = None\n-    b: NegativeInt = None\n-    c: conint(gt=4, lt=10) = None\n-\n-\n-def test_int_validation():\n-    m = IntModel(a=5, b=-5, c=5)\n-    assert m == {'a': 5, 'b': -5, 'c': 5}\n-\n-    with pytest.raises(ValidationError) as exc_info:\n-        IntModel(a=-5, b=5, c=-5)\n+            'msg': 'ensure this value is greater than 4',\n+            'type': 'value_error.number.min_size',\n+            'ctx': {\n+                'limit_value': 4,\n+            },\n+        },\n+    ]\n+\n+\n+def test_float_validation():\n+    class Model(BaseModel):\n+        a: PositiveFloat = None\n+        b: NegativeFloat = None\n+        c: confloat(gt=4, lt=12.2) = None\n+\n+    m = Model(a=5.1, b=-5.2, c=5.3)\n+    assert m == {'a': 5.1, 'b': -5.2, 'c': 5.3}\n+\n+    with pytest.raises(ValidationError) as exc_info:\n+        Model(a=-5.1, b=5.2, c=-5.3)\n     assert exc_info.value.flatten_errors() == [\n",
        "source_code_with_indent": "            'loc': ('a',),\n            'msg': 'value is not a valid dict, got list',\n            'type': 'type_error',\n        },\n    ]\n\n\n<DED>def test_list():\n    <IND>m = ListDictTupleModel(b=[1, 2, '3'])\n    assert m.a is None\n    assert m.b == [1, 2, '3']\n    assert ListDictTupleModel(b='xyz').b == ['x', 'y', 'z']\n    assert ListDictTupleModel(b=(i**2 for i in range(5))).b == [0, 1, 4, 9, 16]\n\n    with pytest.raises(ValidationError) as exc_info:\n        <IND>ListDictTupleModel(b=1)\n    <DED>assert exc_info.value.flatten_errors() == [\n        {\n            'loc': ('b',),\n            'msg': '\\'int\\' object is not iterable',\n            'type': 'type_error',\n        },\n    ]\n\n\n<DED>def test_ordered_dict():\n    <IND>assert ListDictTupleModel(c=OrderedDict([(1, 10), (2, 20)])).c == OrderedDict([(1, 10), (2, 20)])\n    assert ListDictTupleModel(c={1: 10, 2: 20}).c in (OrderedDict([(1, 10), (2, 20)]), OrderedDict([(2, 20), (1, 10)]))\n    assert ListDictTupleModel(c=[(1, 2), (3, 4)]).c == OrderedDict([(1, 2), (3, 4)])\n\n    with pytest.raises(ValidationError) as exc_info:\n        <IND>ListDictTupleModel(c=[1, 2, 3])\n    <DED>assert exc_info.value.flatten_errors() == [\n        {\n            'loc': ('c',),\n            'msg': '\\'int\\' object is not iterable',\n            'type': 'type_error',\n        },\n    ]\n\n\n<DED>def test_tuple():\n    <IND>m = ListDictTupleModel(d=(1, 2, '3'))\n    assert m.a is None\n    assert m.d == (1, 2, '3')\n    assert m.dict() == {'a': None, 'b': None, 'c': None, 'd': (1, 2, '3')}\n    assert ListDictTupleModel(d='xyz').d == ('x', 'y', 'z')\n    assert ListDictTupleModel(d=(i**2 for i in range(5))).d == (0, 1, 4, 9, 16)\n\n    with pytest.raises(ValidationError) as exc_info:\n        <IND>ListDictTupleModel(d=1)\n    <DED>assert exc_info.value.flatten_errors() == [\n        {\n            'loc': ('d',),\n            'msg': '\\'int\\' object is not iterable',\n            'type': 'type_error',\n        },\n    ]\n\n\n<DED>class IntModel(BaseModel):\n    <IND>a: PositiveInt = None\n    b: NegativeInt = None\n    c: conint(gt=4, lt=10) = None\n\n\n<DED>def test_int_validation():\n    <IND>m = IntModel(a=5, b=-5, c=5)\n    assert m == {'a': 5, 'b': -5, 'c': 5}\n\n    with pytest.raises(ValidationError) as exc_info:\n        <IND>IntModel(a=-5, b=5, c=-5)\n    <DED>assert exc_info.value.flatten_errors() == [\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "            'loc': ('a',),\n            'msg': 'ensure this value is greater than 0',\n            'type': 'value_error.number.min_size',\n            'ctx': {\n                'limit_value': 0,\n            },\n        },\n        {\n            'loc': ('b',),\n            'msg': 'ensure this value is less than 0',\n            'type': 'value_error.number.max_size',\n            'ctx': {\n                'limit_value': 0,\n            },\n        },\n        {\n            'loc': ('c',),\n            'msg': 'ensure this value is greater than 4',\n            'type': 'value_error.number.min_size',\n            'ctx': {\n                'limit_value': 4,\n            },\n        },\n    ]\n\n\n<DED>def test_float_validation():\n    <IND>class Model(BaseModel):\n        <IND>a: PositiveFloat = None\n        b: NegativeFloat = None\n        c: confloat(gt=4, lt=12.2) = None\n\n    <DED>m = Model(a=5.1, b=-5.2, c=5.3)\n    assert m == {'a': 5.1, 'b': -5.2, 'c': 5.3}\n\n    with pytest.raises(ValidationError) as exc_info:\n        <IND>Model(a=-5.1, b=5.2, c=-5.3)\n    <DED>assert exc_info.value.flatten_errors() == [\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "samuelcolvin/pydantic",
    "commit": "4f4e22ef47ab04b289976bb4ba4904e3c701e72d",
    "filename": "tests/test_types.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/samuelcolvin-pydantic/tests/test_types.py",
    "file_hunks_size": 33,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "tests/test_types.py:550:4 Incompatible attribute type [8]: Attribute `a` declared in class `FloatModel` has type `pydantic.types.PositiveFloat` but is used as type `None`.",
    "message": " Attribute `a` declared in class `FloatModel` has type `pydantic.types.PositiveFloat` but is used as type `None`.",
    "rule_id": "Incompatible attribute type [8]",
    "warning_line_no": 550,
    "warning_line": "    a: PositiveFloat = None",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "            'loc': ('c',),\n            'msg': 'size less than minimum allowed: 4',\n            'type': 'value_error',\n        },\n    ]\n\n\nclass FloatModel(BaseModel):\n    a: PositiveFloat = None\n    b: NegativeFloat = None\n    c: confloat(gt=4, lt=12.2) = None\n\n\ndef test_float_validation():\n    m = FloatModel(a=5.1, b=-5.2, c=5.3)\n    assert m == {'a': 5.1, 'b': -5.2, 'c': 5.3}\n\n    with pytest.raises(ValidationError) as exc_info:\n        FloatModel(a=-5.1, b=5.2, c=-5.3)\n    assert exc_info.value.flatten_errors() == [\n        {\n            'loc': ('a',),\n            'msg': 'size less than minimum allowed: 0',\n            'type': 'value_error',\n        },\n        {\n            'loc': ('b',),\n            'msg': 'size greater than maximum allowed: 0',\n            'type': 'value_error',\n        },\n        {\n            'loc': ('c',),\n            'msg': 'size less than minimum allowed: 4',\n            'type': 'value_error',\n        },\n    ]\n\n\ndef test_set():\n    class SetModel(BaseModel):\n        v: set = ...\n\n    m = SetModel(v=[1, 2, 3])\n    assert m.v == {1, 2, 3}\n    assert m.dict() == {'v': {1, 2, 3}}\n    assert SetModel(v={'a', 'b', 'c'}).v == {'a', 'b', 'c'}\n\n",
        "source_code_len": 1180,
        "target_code": "            'loc': ('c',),\n            'msg': 'ensure this value is greater than 4',\n            'type': 'value_error.number.min_size',\n            'ctx': {\n                'limit_value': 4,\n            },\n        },\n    ]\n\n",
        "target_code_len": 224,
        "diff_format": "@@ -542,47 +575,9 @@\n             'loc': ('c',),\n-            'msg': 'size less than minimum allowed: 4',\n-            'type': 'value_error',\n-        },\n-    ]\n-\n-\n-class FloatModel(BaseModel):\n-    a: PositiveFloat = None\n-    b: NegativeFloat = None\n-    c: confloat(gt=4, lt=12.2) = None\n-\n-\n-def test_float_validation():\n-    m = FloatModel(a=5.1, b=-5.2, c=5.3)\n-    assert m == {'a': 5.1, 'b': -5.2, 'c': 5.3}\n-\n-    with pytest.raises(ValidationError) as exc_info:\n-        FloatModel(a=-5.1, b=5.2, c=-5.3)\n-    assert exc_info.value.flatten_errors() == [\n-        {\n-            'loc': ('a',),\n-            'msg': 'size less than minimum allowed: 0',\n-            'type': 'value_error',\n-        },\n-        {\n-            'loc': ('b',),\n-            'msg': 'size greater than maximum allowed: 0',\n-            'type': 'value_error',\n-        },\n-        {\n-            'loc': ('c',),\n-            'msg': 'size less than minimum allowed: 4',\n-            'type': 'value_error',\n-        },\n-    ]\n-\n-\n-def test_set():\n-    class SetModel(BaseModel):\n-        v: set = ...\n-\n-    m = SetModel(v=[1, 2, 3])\n-    assert m.v == {1, 2, 3}\n-    assert m.dict() == {'v': {1, 2, 3}}\n-    assert SetModel(v={'a', 'b', 'c'}).v == {'a', 'b', 'c'}\n+            'msg': 'ensure this value is greater than 4',\n+            'type': 'value_error.number.min_size',\n+            'ctx': {\n+                'limit_value': 4,\n+            },\n+        },\n+    ]\n \n",
        "source_code_with_indent": "            'loc': ('c',),\n            'msg': 'size less than minimum allowed: 4',\n            'type': 'value_error',\n        },\n    ]\n\n\n<DED>class FloatModel(BaseModel):\n    <IND>a: PositiveFloat = None\n    b: NegativeFloat = None\n    c: confloat(gt=4, lt=12.2) = None\n\n\n<DED>def test_float_validation():\n    <IND>m = FloatModel(a=5.1, b=-5.2, c=5.3)\n    assert m == {'a': 5.1, 'b': -5.2, 'c': 5.3}\n\n    with pytest.raises(ValidationError) as exc_info:\n        <IND>FloatModel(a=-5.1, b=5.2, c=-5.3)\n    <DED>assert exc_info.value.flatten_errors() == [\n        {\n            'loc': ('a',),\n            'msg': 'size less than minimum allowed: 0',\n            'type': 'value_error',\n        },\n        {\n            'loc': ('b',),\n            'msg': 'size greater than maximum allowed: 0',\n            'type': 'value_error',\n        },\n        {\n            'loc': ('c',),\n            'msg': 'size less than minimum allowed: 4',\n            'type': 'value_error',\n        },\n    ]\n\n\n<DED>def test_set():\n    <IND>class SetModel(BaseModel):\n        <IND>v: set = ...\n\n    <DED>m = SetModel(v=[1, 2, 3])\n    assert m.v == {1, 2, 3}\n    assert m.dict() == {'v': {1, 2, 3}}\n    assert SetModel(v={'a', 'b', 'c'}).v == {'a', 'b', 'c'}\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "            'loc': ('c',),\n            'msg': 'ensure this value is greater than 4',\n            'type': 'value_error.number.min_size',\n            'ctx': {\n                'limit_value': 4,\n            },\n        },\n    ]\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "samuelcolvin/pydantic",
    "commit": "4f4e22ef47ab04b289976bb4ba4904e3c701e72d",
    "filename": "tests/test_types.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/samuelcolvin-pydantic/tests/test_types.py",
    "file_hunks_size": 33,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "tests/test_types.py:551:4 Incompatible attribute type [8]: Attribute `b` declared in class `FloatModel` has type `pydantic.types.NegativeFloat` but is used as type `None`.",
    "message": " Attribute `b` declared in class `FloatModel` has type `pydantic.types.NegativeFloat` but is used as type `None`.",
    "rule_id": "Incompatible attribute type [8]",
    "warning_line_no": 551,
    "warning_line": "    b: NegativeFloat = None",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "            'loc': ('c',),\n            'msg': 'size less than minimum allowed: 4',\n            'type': 'value_error',\n        },\n    ]\n\n\nclass FloatModel(BaseModel):\n    a: PositiveFloat = None\n    b: NegativeFloat = None\n    c: confloat(gt=4, lt=12.2) = None\n\n\ndef test_float_validation():\n    m = FloatModel(a=5.1, b=-5.2, c=5.3)\n    assert m == {'a': 5.1, 'b': -5.2, 'c': 5.3}\n\n    with pytest.raises(ValidationError) as exc_info:\n        FloatModel(a=-5.1, b=5.2, c=-5.3)\n    assert exc_info.value.flatten_errors() == [\n        {\n            'loc': ('a',),\n            'msg': 'size less than minimum allowed: 0',\n            'type': 'value_error',\n        },\n        {\n            'loc': ('b',),\n            'msg': 'size greater than maximum allowed: 0',\n            'type': 'value_error',\n        },\n        {\n            'loc': ('c',),\n            'msg': 'size less than minimum allowed: 4',\n            'type': 'value_error',\n        },\n    ]\n\n\ndef test_set():\n    class SetModel(BaseModel):\n        v: set = ...\n\n    m = SetModel(v=[1, 2, 3])\n    assert m.v == {1, 2, 3}\n    assert m.dict() == {'v': {1, 2, 3}}\n    assert SetModel(v={'a', 'b', 'c'}).v == {'a', 'b', 'c'}\n\n",
        "source_code_len": 1180,
        "target_code": "            'loc': ('c',),\n            'msg': 'ensure this value is greater than 4',\n            'type': 'value_error.number.min_size',\n            'ctx': {\n                'limit_value': 4,\n            },\n        },\n    ]\n\n",
        "target_code_len": 224,
        "diff_format": "@@ -542,47 +575,9 @@\n             'loc': ('c',),\n-            'msg': 'size less than minimum allowed: 4',\n-            'type': 'value_error',\n-        },\n-    ]\n-\n-\n-class FloatModel(BaseModel):\n-    a: PositiveFloat = None\n-    b: NegativeFloat = None\n-    c: confloat(gt=4, lt=12.2) = None\n-\n-\n-def test_float_validation():\n-    m = FloatModel(a=5.1, b=-5.2, c=5.3)\n-    assert m == {'a': 5.1, 'b': -5.2, 'c': 5.3}\n-\n-    with pytest.raises(ValidationError) as exc_info:\n-        FloatModel(a=-5.1, b=5.2, c=-5.3)\n-    assert exc_info.value.flatten_errors() == [\n-        {\n-            'loc': ('a',),\n-            'msg': 'size less than minimum allowed: 0',\n-            'type': 'value_error',\n-        },\n-        {\n-            'loc': ('b',),\n-            'msg': 'size greater than maximum allowed: 0',\n-            'type': 'value_error',\n-        },\n-        {\n-            'loc': ('c',),\n-            'msg': 'size less than minimum allowed: 4',\n-            'type': 'value_error',\n-        },\n-    ]\n-\n-\n-def test_set():\n-    class SetModel(BaseModel):\n-        v: set = ...\n-\n-    m = SetModel(v=[1, 2, 3])\n-    assert m.v == {1, 2, 3}\n-    assert m.dict() == {'v': {1, 2, 3}}\n-    assert SetModel(v={'a', 'b', 'c'}).v == {'a', 'b', 'c'}\n+            'msg': 'ensure this value is greater than 4',\n+            'type': 'value_error.number.min_size',\n+            'ctx': {\n+                'limit_value': 4,\n+            },\n+        },\n+    ]\n \n",
        "source_code_with_indent": "            'loc': ('c',),\n            'msg': 'size less than minimum allowed: 4',\n            'type': 'value_error',\n        },\n    ]\n\n\n<DED>class FloatModel(BaseModel):\n    <IND>a: PositiveFloat = None\n    b: NegativeFloat = None\n    c: confloat(gt=4, lt=12.2) = None\n\n\n<DED>def test_float_validation():\n    <IND>m = FloatModel(a=5.1, b=-5.2, c=5.3)\n    assert m == {'a': 5.1, 'b': -5.2, 'c': 5.3}\n\n    with pytest.raises(ValidationError) as exc_info:\n        <IND>FloatModel(a=-5.1, b=5.2, c=-5.3)\n    <DED>assert exc_info.value.flatten_errors() == [\n        {\n            'loc': ('a',),\n            'msg': 'size less than minimum allowed: 0',\n            'type': 'value_error',\n        },\n        {\n            'loc': ('b',),\n            'msg': 'size greater than maximum allowed: 0',\n            'type': 'value_error',\n        },\n        {\n            'loc': ('c',),\n            'msg': 'size less than minimum allowed: 4',\n            'type': 'value_error',\n        },\n    ]\n\n\n<DED>def test_set():\n    <IND>class SetModel(BaseModel):\n        <IND>v: set = ...\n\n    <DED>m = SetModel(v=[1, 2, 3])\n    assert m.v == {1, 2, 3}\n    assert m.dict() == {'v': {1, 2, 3}}\n    assert SetModel(v={'a', 'b', 'c'}).v == {'a', 'b', 'c'}\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "            'loc': ('c',),\n            'msg': 'ensure this value is greater than 4',\n            'type': 'value_error.number.min_size',\n            'ctx': {\n                'limit_value': 4,\n            },\n        },\n    ]\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "samuelcolvin/pydantic",
    "commit": "4f4e22ef47ab04b289976bb4ba4904e3c701e72d",
    "filename": "tests/test_types.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/samuelcolvin-pydantic/tests/test_types.py",
    "file_hunks_size": 33,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "tests/test_types.py:552:7 Invalid type [31]: Expression `pydantic.confloat($parameter$gt = 4, $parameter$lt = 12.200000)` is not a valid type.",
    "message": " Expression `pydantic.confloat($parameter$gt = 4, $parameter$lt = 12.200000)` is not a valid type.",
    "rule_id": "Invalid type [31]",
    "warning_line_no": 552,
    "warning_line": "    c: confloat(gt=4, lt=12.2) = None",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "            'loc': ('c',),\n            'msg': 'size less than minimum allowed: 4',\n            'type': 'value_error',\n        },\n    ]\n\n\nclass FloatModel(BaseModel):\n    a: PositiveFloat = None\n    b: NegativeFloat = None\n    c: confloat(gt=4, lt=12.2) = None\n\n\ndef test_float_validation():\n    m = FloatModel(a=5.1, b=-5.2, c=5.3)\n    assert m == {'a': 5.1, 'b': -5.2, 'c': 5.3}\n\n    with pytest.raises(ValidationError) as exc_info:\n        FloatModel(a=-5.1, b=5.2, c=-5.3)\n    assert exc_info.value.flatten_errors() == [\n        {\n            'loc': ('a',),\n            'msg': 'size less than minimum allowed: 0',\n            'type': 'value_error',\n        },\n        {\n            'loc': ('b',),\n            'msg': 'size greater than maximum allowed: 0',\n            'type': 'value_error',\n        },\n        {\n            'loc': ('c',),\n            'msg': 'size less than minimum allowed: 4',\n            'type': 'value_error',\n        },\n    ]\n\n\ndef test_set():\n    class SetModel(BaseModel):\n        v: set = ...\n\n    m = SetModel(v=[1, 2, 3])\n    assert m.v == {1, 2, 3}\n    assert m.dict() == {'v': {1, 2, 3}}\n    assert SetModel(v={'a', 'b', 'c'}).v == {'a', 'b', 'c'}\n\n",
        "source_code_len": 1180,
        "target_code": "            'loc': ('c',),\n            'msg': 'ensure this value is greater than 4',\n            'type': 'value_error.number.min_size',\n            'ctx': {\n                'limit_value': 4,\n            },\n        },\n    ]\n\n",
        "target_code_len": 224,
        "diff_format": "@@ -542,47 +575,9 @@\n             'loc': ('c',),\n-            'msg': 'size less than minimum allowed: 4',\n-            'type': 'value_error',\n-        },\n-    ]\n-\n-\n-class FloatModel(BaseModel):\n-    a: PositiveFloat = None\n-    b: NegativeFloat = None\n-    c: confloat(gt=4, lt=12.2) = None\n-\n-\n-def test_float_validation():\n-    m = FloatModel(a=5.1, b=-5.2, c=5.3)\n-    assert m == {'a': 5.1, 'b': -5.2, 'c': 5.3}\n-\n-    with pytest.raises(ValidationError) as exc_info:\n-        FloatModel(a=-5.1, b=5.2, c=-5.3)\n-    assert exc_info.value.flatten_errors() == [\n-        {\n-            'loc': ('a',),\n-            'msg': 'size less than minimum allowed: 0',\n-            'type': 'value_error',\n-        },\n-        {\n-            'loc': ('b',),\n-            'msg': 'size greater than maximum allowed: 0',\n-            'type': 'value_error',\n-        },\n-        {\n-            'loc': ('c',),\n-            'msg': 'size less than minimum allowed: 4',\n-            'type': 'value_error',\n-        },\n-    ]\n-\n-\n-def test_set():\n-    class SetModel(BaseModel):\n-        v: set = ...\n-\n-    m = SetModel(v=[1, 2, 3])\n-    assert m.v == {1, 2, 3}\n-    assert m.dict() == {'v': {1, 2, 3}}\n-    assert SetModel(v={'a', 'b', 'c'}).v == {'a', 'b', 'c'}\n+            'msg': 'ensure this value is greater than 4',\n+            'type': 'value_error.number.min_size',\n+            'ctx': {\n+                'limit_value': 4,\n+            },\n+        },\n+    ]\n \n",
        "source_code_with_indent": "            'loc': ('c',),\n            'msg': 'size less than minimum allowed: 4',\n            'type': 'value_error',\n        },\n    ]\n\n\n<DED>class FloatModel(BaseModel):\n    <IND>a: PositiveFloat = None\n    b: NegativeFloat = None\n    c: confloat(gt=4, lt=12.2) = None\n\n\n<DED>def test_float_validation():\n    <IND>m = FloatModel(a=5.1, b=-5.2, c=5.3)\n    assert m == {'a': 5.1, 'b': -5.2, 'c': 5.3}\n\n    with pytest.raises(ValidationError) as exc_info:\n        <IND>FloatModel(a=-5.1, b=5.2, c=-5.3)\n    <DED>assert exc_info.value.flatten_errors() == [\n        {\n            'loc': ('a',),\n            'msg': 'size less than minimum allowed: 0',\n            'type': 'value_error',\n        },\n        {\n            'loc': ('b',),\n            'msg': 'size greater than maximum allowed: 0',\n            'type': 'value_error',\n        },\n        {\n            'loc': ('c',),\n            'msg': 'size less than minimum allowed: 4',\n            'type': 'value_error',\n        },\n    ]\n\n\n<DED>def test_set():\n    <IND>class SetModel(BaseModel):\n        <IND>v: set = ...\n\n    <DED>m = SetModel(v=[1, 2, 3])\n    assert m.v == {1, 2, 3}\n    assert m.dict() == {'v': {1, 2, 3}}\n    assert SetModel(v={'a', 'b', 'c'}).v == {'a', 'b', 'c'}\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "            'loc': ('c',),\n            'msg': 'ensure this value is greater than 4',\n            'type': 'value_error.number.min_size',\n            'ctx': {\n                'limit_value': 4,\n            },\n        },\n    ]\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  }
]