[
  {
    "project": "pypiserver/pypiserver",
    "commit": "cf424c982d8c66b8ee38984b4c61b8340ddece28",
    "filename": "pypiserver/core.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/pypiserver-pypiserver/pypiserver/core.py",
    "file_hunks_size": 7,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "pypiserver/core.py:266:4 Incompatible variable type [9]: listdir is declared to have type `typing.Callable(listdir)[[Named(root, str)], t.Iterable[PkgFile]]` but is used as type `typing.Callable(_listdir)[[Named(root, str)], t.Iterable[PkgFile]]`.",
    "message": " listdir is declared to have type `typing.Callable(listdir)[[Named(root, str)], t.Iterable[PkgFile]]` but is used as type `typing.Callable(_listdir)[[Named(root, str)], t.Iterable[PkgFile]]`.",
    "rule_id": "Incompatible variable type [9]",
    "warning_line_no": 266,
    "warning_line": "    listdir = _listdir",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "        self.replaces = replaces\n\n    def __repr__(self):\n        return \"{}({})\".format(\n",
        "source_code_len": 90,
        "target_code": "        self.replaces = replaces\n        self.digest = None\n        self.digester = None\n\n    def __repr__(self) -> str:\n        return \"{}({})\".format(\n",
        "target_code_len": 153,
        "diff_format": "@@ -149,4 +62,6 @@\n         self.replaces = replaces\n+        self.digest = None\n+        self.digester = None\n \n-    def __repr__(self):\n+    def __repr__(self) -> str:\n         return \"{}({})\".format(\n",
        "source_code_with_indent": "        self.replaces = replaces\n\n    <DED>def __repr__(self):\n        <IND>return \"{}({})\".format(\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "        self.replaces = replaces\n        self.digest = None\n        self.digester = None\n\n    <DED>def __repr__(self) -> str:\n        <IND>return \"{}({})\".format(\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": true,
        "source_code": "\n    def fname_and_hash(self, hash_algo):\n        if not hasattr(self, \"_fname_and_hash\"):\n            if hash_algo:\n                self._fname_and_hash = (\n                    f\"{self.relfn_unix}#{hash_algo}=\"\n                    f\"{digest_file(self.fn, hash_algo)}\"\n                )\n            else:\n                self._fname_and_hash = self.relfn_unix\n        return self._fname_and_hash\n\n\ndef _listdir(root: str) -> t.Iterable[PkgFile]:\n    root = os.path.abspath(root)\n    for dirpath, dirnames, filenames in os.walk(root):\n        dirnames[:] = [x for x in dirnames if is_allowed_path(x)]\n        for x in filenames:\n            fn = os.path.join(root, dirpath, x)\n            if not is_allowed_path(x) or not os.path.isfile(fn):\n                continue\n            res = guess_pkgname_and_version(x)\n            if not res:\n                # #Seems the current file isn't a proper package\n                continue\n            pkgname, version = res\n            if pkgname:\n                yield PkgFile(\n                    pkgname=pkgname,\n                    version=version,\n                    fn=fn,\n                    root=root,\n                    relfn=fn[len(root) + 1 :],\n                )\n\n\ndef find_packages(pkgs, prefix=\"\"):\n    prefix = normalize_pkgname(prefix)\n    for x in pkgs:\n        if prefix and x.pkgname_norm != prefix:\n            continue\n        yield x\n\n\ndef get_prefixes(pkgs):\n    normalized_pkgnames = set()\n    for x in pkgs:\n        if x.pkgname:\n            normalized_pkgnames.add(x.pkgname_norm)\n    return normalized_pkgnames\n\n\ndef exists(root, filename):\n    assert \"/\" not in filename\n    dest_fn = os.path.join(root, filename)\n    return os.path.exists(dest_fn)\n\n\ndef store(root, filename, save_method):\n    assert \"/\" not in filename\n    dest_fn = os.path.join(root, filename)\n    save_method(dest_fn, overwrite=True)  # Overwite check earlier.\n\n\ndef get_bad_url_redirect_path(request, prefix):\n    \"\"\"Get the path for a bad root url.\"\"\"\n    p = request.custom_fullpath\n    if p.endswith(\"/\"):\n        p = p[:-1]\n    p = p.rsplit(\"/\", 1)[0]\n    prefix = quote(prefix)\n    p += \"/simple/{}/\".format(prefix)\n    return p\n\n\ndef _digest_file(fpath, hash_algo):\n    \"\"\"\n    Reads and digests a file according to specified hashing-algorith.\n\n    :param str sha256: any algo contained in :mod:`hashlib`\n    :return: <hash_algo>=<hex_digest>\n\n    From http://stackoverflow.com/a/21565932/548792\n    \"\"\"\n    blocksize = 2 ** 16\n    digester = hashlib.new(hash_algo)\n    with open(fpath, \"rb\") as f:\n        for block in iter(lambda: f.read(blocksize), b\"\"):\n            digester.update(block)\n    return digester.hexdigest()\n\n\ntry:\n    from .cache import cache_manager\n\n    def listdir(root: str) -> t.Iterable[PkgFile]:\n        # root must be absolute path\n        return cache_manager.listdir(root, _listdir)\n\n    def digest_file(fpath, hash_algo):\n        # fpath must be absolute path\n        return cache_manager.digest_file(fpath, hash_algo, _digest_file)\n\n\nexcept ImportError:\n    listdir = _listdir\n    digest_file = _digest_file\n",
        "source_code_len": 3084,
        "target_code": "\n    @property\n    def fname_and_hash(self) -> str:\n        if self.digest is None and self.digester is not None:\n            self.digest = self.digester(self)\n        hashpart = f\"#{self.digest}\" if self.digest else \"\"\n        return self.relfn_unix + hashpart  # type: ignore\n",
        "target_code_len": 278,
        "diff_format": "@@ -161,107 +76,7 @@\n \n-    def fname_and_hash(self, hash_algo):\n-        if not hasattr(self, \"_fname_and_hash\"):\n-            if hash_algo:\n-                self._fname_and_hash = (\n-                    f\"{self.relfn_unix}#{hash_algo}=\"\n-                    f\"{digest_file(self.fn, hash_algo)}\"\n-                )\n-            else:\n-                self._fname_and_hash = self.relfn_unix\n-        return self._fname_and_hash\n-\n-\n-def _listdir(root: str) -> t.Iterable[PkgFile]:\n-    root = os.path.abspath(root)\n-    for dirpath, dirnames, filenames in os.walk(root):\n-        dirnames[:] = [x for x in dirnames if is_allowed_path(x)]\n-        for x in filenames:\n-            fn = os.path.join(root, dirpath, x)\n-            if not is_allowed_path(x) or not os.path.isfile(fn):\n-                continue\n-            res = guess_pkgname_and_version(x)\n-            if not res:\n-                # #Seems the current file isn't a proper package\n-                continue\n-            pkgname, version = res\n-            if pkgname:\n-                yield PkgFile(\n-                    pkgname=pkgname,\n-                    version=version,\n-                    fn=fn,\n-                    root=root,\n-                    relfn=fn[len(root) + 1 :],\n-                )\n-\n-\n-def find_packages(pkgs, prefix=\"\"):\n-    prefix = normalize_pkgname(prefix)\n-    for x in pkgs:\n-        if prefix and x.pkgname_norm != prefix:\n-            continue\n-        yield x\n-\n-\n-def get_prefixes(pkgs):\n-    normalized_pkgnames = set()\n-    for x in pkgs:\n-        if x.pkgname:\n-            normalized_pkgnames.add(x.pkgname_norm)\n-    return normalized_pkgnames\n-\n-\n-def exists(root, filename):\n-    assert \"/\" not in filename\n-    dest_fn = os.path.join(root, filename)\n-    return os.path.exists(dest_fn)\n-\n-\n-def store(root, filename, save_method):\n-    assert \"/\" not in filename\n-    dest_fn = os.path.join(root, filename)\n-    save_method(dest_fn, overwrite=True)  # Overwite check earlier.\n-\n-\n-def get_bad_url_redirect_path(request, prefix):\n-    \"\"\"Get the path for a bad root url.\"\"\"\n-    p = request.custom_fullpath\n-    if p.endswith(\"/\"):\n-        p = p[:-1]\n-    p = p.rsplit(\"/\", 1)[0]\n-    prefix = quote(prefix)\n-    p += \"/simple/{}/\".format(prefix)\n-    return p\n-\n-\n-def _digest_file(fpath, hash_algo):\n-    \"\"\"\n-    Reads and digests a file according to specified hashing-algorith.\n-\n-    :param str sha256: any algo contained in :mod:`hashlib`\n-    :return: <hash_algo>=<hex_digest>\n-\n-    From http://stackoverflow.com/a/21565932/548792\n-    \"\"\"\n-    blocksize = 2 ** 16\n-    digester = hashlib.new(hash_algo)\n-    with open(fpath, \"rb\") as f:\n-        for block in iter(lambda: f.read(blocksize), b\"\"):\n-            digester.update(block)\n-    return digester.hexdigest()\n-\n-\n-try:\n-    from .cache import cache_manager\n-\n-    def listdir(root: str) -> t.Iterable[PkgFile]:\n-        # root must be absolute path\n-        return cache_manager.listdir(root, _listdir)\n-\n-    def digest_file(fpath, hash_algo):\n-        # fpath must be absolute path\n-        return cache_manager.digest_file(fpath, hash_algo, _digest_file)\n-\n-\n-except ImportError:\n-    listdir = _listdir\n-    digest_file = _digest_file\n+    @property\n+    def fname_and_hash(self) -> str:\n+        if self.digest is None and self.digester is not None:\n+            self.digest = self.digester(self)\n+        hashpart = f\"#{self.digest}\" if self.digest else \"\"\n+        return self.relfn_unix + hashpart  # type: ignore\n",
        "source_code_with_indent": "\n    <DED>def fname_and_hash(self, hash_algo):\n        <IND>if not hasattr(self, \"_fname_and_hash\"):\n            <IND>if hash_algo:\n                <IND>self._fname_and_hash = (\n                    f\"{self.relfn_unix}#{hash_algo}=\"\n                    f\"{digest_file(self.fn, hash_algo)}\"\n                )\n            <DED>else:\n                <IND>self._fname_and_hash = self.relfn_unix\n        <DED><DED>return self._fname_and_hash\n\n\n<DED><DED>def _listdir(root: str) -> t.Iterable[PkgFile]:\n    <IND>root = os.path.abspath(root)\n    for dirpath, dirnames, filenames in os.walk(root):\n        <IND>dirnames[:] = [x for x in dirnames if is_allowed_path(x)]\n        for x in filenames:\n            <IND>fn = os.path.join(root, dirpath, x)\n            if not is_allowed_path(x) or not os.path.isfile(fn):\n                <IND>continue\n            <DED>res = guess_pkgname_and_version(x)\n            if not res:\n                # #Seems the current file isn't a proper package\n                <IND>continue\n            <DED>pkgname, version = res\n            if pkgname:\n                <IND>yield PkgFile(\n                    pkgname=pkgname,\n                    version=version,\n                    fn=fn,\n                    root=root,\n                    relfn=fn[len(root) + 1 :],\n                )\n\n\n<DED><DED><DED><DED>def find_packages(pkgs, prefix=\"\"):\n    <IND>prefix = normalize_pkgname(prefix)\n    for x in pkgs:\n        <IND>if prefix and x.pkgname_norm != prefix:\n            <IND>continue\n        <DED>yield x\n\n\n<DED><DED>def get_prefixes(pkgs):\n    <IND>normalized_pkgnames = set()\n    for x in pkgs:\n        <IND>if x.pkgname:\n            <IND>normalized_pkgnames.add(x.pkgname_norm)\n    <DED><DED>return normalized_pkgnames\n\n\n<DED>def exists(root, filename):\n    <IND>assert \"/\" not in filename\n    dest_fn = os.path.join(root, filename)\n    return os.path.exists(dest_fn)\n\n\n<DED>def store(root, filename, save_method):\n    <IND>assert \"/\" not in filename\n    dest_fn = os.path.join(root, filename)\n    save_method(dest_fn, overwrite=True)  # Overwite check earlier.\n\n\n<DED>def get_bad_url_redirect_path(request, prefix):\n    <IND>\"\"\"Get the path for a bad root url.\"\"\"\n    p = request.custom_fullpath\n    if p.endswith(\"/\"):\n        <IND>p = p[:-1]\n    <DED>p = p.rsplit(\"/\", 1)[0]\n    prefix = quote(prefix)\n    p += \"/simple/{}/\".format(prefix)\n    return p\n\n\n<DED>def _digest_file(fpath, hash_algo):\n    <IND>\"\"\"\n    Reads and digests a file according to specified hashing-algorith.\n\n    :param str sha256: any algo contained in :mod:`hashlib`\n    :return: <hash_algo>=<hex_digest>\n\n    From http://stackoverflow.com/a/21565932/548792\n    \"\"\"\n    blocksize = 2 ** 16\n    digester = hashlib.new(hash_algo)\n    with open(fpath, \"rb\") as f:\n        <IND>for block in iter(lambda: f.read(blocksize), b\"\"):\n            <IND>digester.update(block)\n    <DED><DED>return digester.hexdigest()\n\n\n<DED>try:\n    <IND>from .cache import cache_manager\n\n    def listdir(root: str) -> t.Iterable[PkgFile]:\n        # root must be absolute path\n        <IND>return cache_manager.listdir(root, _listdir)\n\n    <DED>def digest_file(fpath, hash_algo):\n        # fpath must be absolute path\n        <IND>return cache_manager.digest_file(fpath, hash_algo, _digest_file)\n\n\n<DED><DED>except ImportError:\n    <IND>listdir = _listdir\n    digest_file = _digest_file\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n    <DED>@property\n    def fname_and_hash(self) -> str:\n        <IND>if self.digest is None and self.digester is not None:\n            <IND>self.digest = self.digester(self)\n        <DED>hashpart = f\"#{self.digest}\" if self.digest else \"\"\n        return self.relfn_unix + hashpart  # type: ignore\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  }
]