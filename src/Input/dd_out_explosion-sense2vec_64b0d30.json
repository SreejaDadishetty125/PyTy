[
  {
    "project": "explosion/sense2vec",
    "commit": "64b0d30d4ed06ccab69ecd2d6beb6e6c936c1802",
    "filename": "sense2vec/sense2vec.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/explosion-sense2vec/sense2vec/sense2vec.py",
    "file_hunks_size": 8,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "sense2vec/sense2vec.py:186:28 Incompatible parameter type [6]: Expected `typing.Sized` for 1st positional only parameter to call `len` but got `Iterable[Union[int, str]]`.",
    "message": " Expected `typing.Sized` for 1st positional only parameter to call `len` but got `Iterable[Union[int, str]]`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 186,
    "warning_line": "        n_similar = n + len(keys)",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "from typing import Callable, Tuple, List, Union, Iterable, Dict\nfrom collections import OrderedDict\nfrom pathlib import Path\n",
        "source_code_len": 125,
        "target_code": "from typing import Callable, Tuple, List, Union, Sequence, Dict\nfrom pathlib import Path\n",
        "target_code_len": 89,
        "diff_format": "@@ -1,3 +1,2 @@\n-from typing import Callable, Tuple, List, Union, Iterable, Dict\n-from collections import OrderedDict\n+from typing import Callable, Tuple, List, Union, Sequence, Dict\n from pathlib import Path\n",
        "source_code_with_indent": "from typing import Callable, Tuple, List, Union, Iterable, Dict\nfrom collections import OrderedDict\nfrom pathlib import Path\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "from typing import Callable, Tuple, List, Union, Sequence, Dict\nfrom pathlib import Path\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "        self,\n        keys_a: Union[Iterable[Union[str, int]], str, int],\n        keys_b: Union[Iterable[Union[str, int]], str, int],\n    ) -> float:\n",
        "source_code_len": 150,
        "target_code": "        self,\n        keys_a: Union[Sequence[Union[str, int]], str, int],\n        keys_b: Union[Sequence[Union[str, int]], str, int],\n    ) -> float:\n",
        "target_code_len": 150,
        "diff_format": "@@ -144,4 +143,4 @@\n         self,\n-        keys_a: Union[Iterable[Union[str, int]], str, int],\n-        keys_b: Union[Iterable[Union[str, int]], str, int],\n+        keys_a: Union[Sequence[Union[str, int]], str, int],\n+        keys_b: Union[Sequence[Union[str, int]], str, int],\n     ) -> float:\n",
        "source_code_with_indent": "        self,\n        keys_a: Union[Iterable[Union[str, int]], str, int],\n        keys_b: Union[Iterable[Union[str, int]], str, int],\n    ) -> float:\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "        self,\n        keys_a: Union[Sequence[Union[str, int]], str, int],\n        keys_b: Union[Sequence[Union[str, int]], str, int],\n    ) -> float:\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "        self,\n        keys: Union[Iterable[Union[str, int]], str, int],\n        n: int = 10,\n",
        "source_code_len": 93,
        "target_code": "        self,\n        keys: Union[Sequence[Union[str, int]], str, int],\n        n: int = 10,\n",
        "target_code_len": 93,
        "diff_format": "@@ -170,3 +169,3 @@\n         self,\n-        keys: Union[Iterable[Union[str, int]], str, int],\n+        keys: Union[Sequence[Union[str, int]], str, int],\n         n: int = 10,\n",
        "source_code_with_indent": "        self,\n        keys: Union[Iterable[Union[str, int]], str, int],\n        n: int = 10,\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "        self,\n        keys: Union[Sequence[Union[str, int]], str, int],\n        n: int = 10,\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "        )\n        result = OrderedDict(zip(result_keys.flatten(), scores.flatten()))\n        result = [(self.strings[key], score) for key, score in result.items() if key]\n        result = [(key, score) for key, score in result if key not in keys]\n",
        "source_code_len": 247,
        "target_code": "        )\n        result = list(zip(result_keys.flatten(), scores.flatten()))\n        result = [(self.strings[key], score) for key, score in result if key]\n        result = [(key, score) for key, score in result if key not in keys]\n",
        "target_code_len": 232,
        "diff_format": "@@ -199,4 +198,4 @@\n         )\n-        result = OrderedDict(zip(result_keys.flatten(), scores.flatten()))\n-        result = [(self.strings[key], score) for key, score in result.items() if key]\n+        result = list(zip(result_keys.flatten(), scores.flatten()))\n+        result = [(self.strings[key], score) for key, score in result if key]\n         result = [(key, score) for key, score in result if key not in keys]\n",
        "source_code_with_indent": "        )\n        result = OrderedDict(zip(result_keys.flatten(), scores.flatten()))\n        result = [(self.strings[key], score) for key, score in result.items() if key]\n        result = [(key, score) for key, score in result if key not in keys]\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "        )\n        result = list(zip(result_keys.flatten(), scores.flatten()))\n        result = [(self.strings[key], score) for key, score in result if key]\n        result = [(key, score) for key, score in result if key not in keys]\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n    def to_bytes(self, exclude: Iterable[str] = tuple()) -> bytes:\n        \"\"\"Serialize a Sense2Vec object to a bytestring.\n",
        "source_code_len": 125,
        "target_code": "\n    def to_bytes(self, exclude: Sequence[str] = tuple()) -> bytes:\n        \"\"\"Serialize a Sense2Vec object to a bytestring.\n",
        "target_code_len": 125,
        "diff_format": "@@ -245,3 +244,3 @@\n \n-    def to_bytes(self, exclude: Iterable[str] = tuple()) -> bytes:\n+    def to_bytes(self, exclude: Sequence[str] = tuple()) -> bytes:\n         \"\"\"Serialize a Sense2Vec object to a bytestring.\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\n    <DED>def to_bytes(self, exclude: Iterable[str] = tuple()) -> bytes:\n        <IND>",
        "target_code_with_indent": "\n    <DED>def to_bytes(self, exclude: Sequence[str] = tuple()) -> bytes:\n        <IND>"
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n    def from_bytes(self, bytes_data: bytes, exclude: Iterable[str] = tuple()):\n        \"\"\"Load a Sense2Vec object from a bytestring.\n",
        "source_code_len": 134,
        "target_code": "\n    def from_bytes(self, bytes_data: bytes, exclude: Sequence[str] = tuple()):\n        \"\"\"Load a Sense2Vec object from a bytestring.\n",
        "target_code_len": 134,
        "diff_format": "@@ -258,3 +257,3 @@\n \n-    def from_bytes(self, bytes_data: bytes, exclude: Iterable[str] = tuple()):\n+    def from_bytes(self, bytes_data: bytes, exclude: Sequence[str] = tuple()):\n         \"\"\"Load a Sense2Vec object from a bytestring.\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\n    <DED>def from_bytes(self, bytes_data: bytes, exclude: Iterable[str] = tuple()):\n        <IND>",
        "target_code_with_indent": "\n    <DED>def from_bytes(self, bytes_data: bytes, exclude: Sequence[str] = tuple()):\n        <IND>"
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n    def to_disk(self, path: Union[Path, str], exclude: Iterable[str] = tuple()):\n        \"\"\"Serialize a Sense2Vec object to a directory.\n",
        "source_code_len": 138,
        "target_code": "\n    def to_disk(self, path: Union[Path, str], exclude: Sequence[str] = tuple()):\n        \"\"\"Serialize a Sense2Vec object to a directory.\n",
        "target_code_len": 138,
        "diff_format": "@@ -273,3 +272,3 @@\n \n-    def to_disk(self, path: Union[Path, str], exclude: Iterable[str] = tuple()):\n+    def to_disk(self, path: Union[Path, str], exclude: Sequence[str] = tuple()):\n         \"\"\"Serialize a Sense2Vec object to a directory.\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\n    <DED>def to_disk(self, path: Union[Path, str], exclude: Iterable[str] = tuple()):\n        <IND>",
        "target_code_with_indent": "\n    <DED>def to_disk(self, path: Union[Path, str], exclude: Sequence[str] = tuple()):\n        <IND>"
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n    def from_disk(self, path: Union[Path, str], exclude: Iterable[str] = tuple()):\n        \"\"\"Load a Sense2Vec object from a directory.\n",
        "source_code_len": 137,
        "target_code": "\n    def from_disk(self, path: Union[Path, str], exclude: Sequence[str] = tuple()):\n        \"\"\"Load a Sense2Vec object from a directory.\n",
        "target_code_len": 137,
        "diff_format": "@@ -286,3 +285,3 @@\n \n-    def from_disk(self, path: Union[Path, str], exclude: Iterable[str] = tuple()):\n+    def from_disk(self, path: Union[Path, str], exclude: Sequence[str] = tuple()):\n         \"\"\"Load a Sense2Vec object from a directory.\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\n    <DED><DED>def from_disk(self, path: Union[Path, str], exclude: Iterable[str] = tuple()):\n        <IND>",
        "target_code_with_indent": "\n    <DED><DED>def from_disk(self, path: Union[Path, str], exclude: Sequence[str] = tuple()):\n        <IND>"
      }
    ]
  },
  {
    "project": "explosion/sense2vec",
    "commit": "64b0d30d4ed06ccab69ecd2d6beb6e6c936c1802",
    "filename": "sense2vec/sense2vec.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/explosion-sense2vec/sense2vec/sense2vec.py",
    "file_hunks_size": 8,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "sense2vec/sense2vec.py:193:64 Incompatible parameter type [6]: Expected `typing.Sized` for 1st positional only parameter to call `len` but got `Iterable[Union[int, str]]`.",
    "message": " Expected `typing.Sized` for 1st positional only parameter to call `len` but got `Iterable[Union[int, str]]`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 193,
    "warning_line": "                f\"entries in the table while excluding the {len(keys)} keys\"",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "from typing import Callable, Tuple, List, Union, Iterable, Dict\nfrom collections import OrderedDict\nfrom pathlib import Path\n",
        "source_code_len": 125,
        "target_code": "from typing import Callable, Tuple, List, Union, Sequence, Dict\nfrom pathlib import Path\n",
        "target_code_len": 89,
        "diff_format": "@@ -1,3 +1,2 @@\n-from typing import Callable, Tuple, List, Union, Iterable, Dict\n-from collections import OrderedDict\n+from typing import Callable, Tuple, List, Union, Sequence, Dict\n from pathlib import Path\n",
        "source_code_with_indent": "from typing import Callable, Tuple, List, Union, Iterable, Dict\nfrom collections import OrderedDict\nfrom pathlib import Path\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "from typing import Callable, Tuple, List, Union, Sequence, Dict\nfrom pathlib import Path\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "        self,\n        keys_a: Union[Iterable[Union[str, int]], str, int],\n        keys_b: Union[Iterable[Union[str, int]], str, int],\n    ) -> float:\n",
        "source_code_len": 150,
        "target_code": "        self,\n        keys_a: Union[Sequence[Union[str, int]], str, int],\n        keys_b: Union[Sequence[Union[str, int]], str, int],\n    ) -> float:\n",
        "target_code_len": 150,
        "diff_format": "@@ -144,4 +143,4 @@\n         self,\n-        keys_a: Union[Iterable[Union[str, int]], str, int],\n-        keys_b: Union[Iterable[Union[str, int]], str, int],\n+        keys_a: Union[Sequence[Union[str, int]], str, int],\n+        keys_b: Union[Sequence[Union[str, int]], str, int],\n     ) -> float:\n",
        "source_code_with_indent": "        self,\n        keys_a: Union[Iterable[Union[str, int]], str, int],\n        keys_b: Union[Iterable[Union[str, int]], str, int],\n    ) -> float:\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "        self,\n        keys_a: Union[Sequence[Union[str, int]], str, int],\n        keys_b: Union[Sequence[Union[str, int]], str, int],\n    ) -> float:\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "        self,\n        keys: Union[Iterable[Union[str, int]], str, int],\n        n: int = 10,\n",
        "source_code_len": 93,
        "target_code": "        self,\n        keys: Union[Sequence[Union[str, int]], str, int],\n        n: int = 10,\n",
        "target_code_len": 93,
        "diff_format": "@@ -170,3 +169,3 @@\n         self,\n-        keys: Union[Iterable[Union[str, int]], str, int],\n+        keys: Union[Sequence[Union[str, int]], str, int],\n         n: int = 10,\n",
        "source_code_with_indent": "        self,\n        keys: Union[Iterable[Union[str, int]], str, int],\n        n: int = 10,\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "        self,\n        keys: Union[Sequence[Union[str, int]], str, int],\n        n: int = 10,\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "        )\n        result = OrderedDict(zip(result_keys.flatten(), scores.flatten()))\n        result = [(self.strings[key], score) for key, score in result.items() if key]\n        result = [(key, score) for key, score in result if key not in keys]\n",
        "source_code_len": 247,
        "target_code": "        )\n        result = list(zip(result_keys.flatten(), scores.flatten()))\n        result = [(self.strings[key], score) for key, score in result if key]\n        result = [(key, score) for key, score in result if key not in keys]\n",
        "target_code_len": 232,
        "diff_format": "@@ -199,4 +198,4 @@\n         )\n-        result = OrderedDict(zip(result_keys.flatten(), scores.flatten()))\n-        result = [(self.strings[key], score) for key, score in result.items() if key]\n+        result = list(zip(result_keys.flatten(), scores.flatten()))\n+        result = [(self.strings[key], score) for key, score in result if key]\n         result = [(key, score) for key, score in result if key not in keys]\n",
        "source_code_with_indent": "        )\n        result = OrderedDict(zip(result_keys.flatten(), scores.flatten()))\n        result = [(self.strings[key], score) for key, score in result.items() if key]\n        result = [(key, score) for key, score in result if key not in keys]\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "        )\n        result = list(zip(result_keys.flatten(), scores.flatten()))\n        result = [(self.strings[key], score) for key, score in result if key]\n        result = [(key, score) for key, score in result if key not in keys]\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n    def to_bytes(self, exclude: Iterable[str] = tuple()) -> bytes:\n        \"\"\"Serialize a Sense2Vec object to a bytestring.\n",
        "source_code_len": 125,
        "target_code": "\n    def to_bytes(self, exclude: Sequence[str] = tuple()) -> bytes:\n        \"\"\"Serialize a Sense2Vec object to a bytestring.\n",
        "target_code_len": 125,
        "diff_format": "@@ -245,3 +244,3 @@\n \n-    def to_bytes(self, exclude: Iterable[str] = tuple()) -> bytes:\n+    def to_bytes(self, exclude: Sequence[str] = tuple()) -> bytes:\n         \"\"\"Serialize a Sense2Vec object to a bytestring.\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\n    <DED>def to_bytes(self, exclude: Iterable[str] = tuple()) -> bytes:\n        <IND>",
        "target_code_with_indent": "\n    <DED>def to_bytes(self, exclude: Sequence[str] = tuple()) -> bytes:\n        <IND>"
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n    def from_bytes(self, bytes_data: bytes, exclude: Iterable[str] = tuple()):\n        \"\"\"Load a Sense2Vec object from a bytestring.\n",
        "source_code_len": 134,
        "target_code": "\n    def from_bytes(self, bytes_data: bytes, exclude: Sequence[str] = tuple()):\n        \"\"\"Load a Sense2Vec object from a bytestring.\n",
        "target_code_len": 134,
        "diff_format": "@@ -258,3 +257,3 @@\n \n-    def from_bytes(self, bytes_data: bytes, exclude: Iterable[str] = tuple()):\n+    def from_bytes(self, bytes_data: bytes, exclude: Sequence[str] = tuple()):\n         \"\"\"Load a Sense2Vec object from a bytestring.\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\n    <DED>def from_bytes(self, bytes_data: bytes, exclude: Iterable[str] = tuple()):\n        <IND>",
        "target_code_with_indent": "\n    <DED>def from_bytes(self, bytes_data: bytes, exclude: Sequence[str] = tuple()):\n        <IND>"
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n    def to_disk(self, path: Union[Path, str], exclude: Iterable[str] = tuple()):\n        \"\"\"Serialize a Sense2Vec object to a directory.\n",
        "source_code_len": 138,
        "target_code": "\n    def to_disk(self, path: Union[Path, str], exclude: Sequence[str] = tuple()):\n        \"\"\"Serialize a Sense2Vec object to a directory.\n",
        "target_code_len": 138,
        "diff_format": "@@ -273,3 +272,3 @@\n \n-    def to_disk(self, path: Union[Path, str], exclude: Iterable[str] = tuple()):\n+    def to_disk(self, path: Union[Path, str], exclude: Sequence[str] = tuple()):\n         \"\"\"Serialize a Sense2Vec object to a directory.\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\n    <DED>def to_disk(self, path: Union[Path, str], exclude: Iterable[str] = tuple()):\n        <IND>",
        "target_code_with_indent": "\n    <DED>def to_disk(self, path: Union[Path, str], exclude: Sequence[str] = tuple()):\n        <IND>"
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n    def from_disk(self, path: Union[Path, str], exclude: Iterable[str] = tuple()):\n        \"\"\"Load a Sense2Vec object from a directory.\n",
        "source_code_len": 137,
        "target_code": "\n    def from_disk(self, path: Union[Path, str], exclude: Sequence[str] = tuple()):\n        \"\"\"Load a Sense2Vec object from a directory.\n",
        "target_code_len": 137,
        "diff_format": "@@ -286,3 +285,3 @@\n \n-    def from_disk(self, path: Union[Path, str], exclude: Iterable[str] = tuple()):\n+    def from_disk(self, path: Union[Path, str], exclude: Sequence[str] = tuple()):\n         \"\"\"Load a Sense2Vec object from a directory.\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\n    <DED><DED>def from_disk(self, path: Union[Path, str], exclude: Iterable[str] = tuple()):\n        <IND>",
        "target_code_with_indent": "\n    <DED><DED>def from_disk(self, path: Union[Path, str], exclude: Sequence[str] = tuple()):\n        <IND>"
      }
    ]
  }
]