[
  {
    "project": "Trusted-AI/adversarial-robustness-toolbox",
    "commit": "e7c5d65a6e28af8ca36fb568551ae72ee7cc2d37",
    "filename": "art/attacks/extraction/copycat_cnn.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/Trusted-AI-adversarial-robustness-toolbox/art/attacks/extraction/copycat_cnn.py",
    "file_hunks_size": 5,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "art/attacks/extraction/copycat_cnn.py:125:8 Incompatible return type [7]: Expected `Classifier` but got `ClassifierMixin`.",
    "message": " Expected `Classifier` but got `ClassifierMixin`.",
    "rule_id": "Incompatible return type [7]",
    "warning_line_no": 125,
    "warning_line": "        return thieved_classifier",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "        thieved_classifier = kwargs[\"thieved_classifier\"]\n        if thieved_classifier is None or not isinstance(\n            thieved_classifier, ClassifierMixin\n        ):\n            raise ValueError(\"A thieved classifier is needed.\")\n",
        "source_code_len": 238,
        "target_code": "        thieved_classifier = kwargs[\"thieved_classifier\"]\n        if thieved_classifier is None or not isinstance(thieved_classifier, Classifier):\n            raise ValueError(\"A thieved classifier is needed.\")\n",
        "target_code_len": 211,
        "diff_format": "@@ -105,5 +103,3 @@\n         thieved_classifier = kwargs[\"thieved_classifier\"]\n-        if thieved_classifier is None or not isinstance(\n-            thieved_classifier, ClassifierMixin\n-        ):\n+        if thieved_classifier is None or not isinstance(thieved_classifier, Classifier):\n             raise ValueError(\"A thieved classifier is needed.\")\n",
        "source_code_with_indent": "        <DED>thieved_classifier = kwargs[\"thieved_classifier\"]\n        if thieved_classifier is None or not isinstance(\n            thieved_classifier, ClassifierMixin\n        ):\n            <IND>raise ValueError(\"A thieved classifier is needed.\")\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "        <DED>thieved_classifier = kwargs[\"thieved_classifier\"]\n        if thieved_classifier is None or not isinstance(thieved_classifier, Classifier):\n            <IND>raise ValueError(\"A thieved classifier is needed.\")\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "Trusted-AI/adversarial-robustness-toolbox",
    "commit": "e7c5d65a6e28af8ca36fb568551ae72ee7cc2d37",
    "filename": "art/attacks/extraction/functionally_equivalent_extraction.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/Trusted-AI-adversarial-robustness-toolbox/art/attacks/extraction/functionally_equivalent_extraction.py",
    "file_hunks_size": 26,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": true,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "art/attacks/extraction/functionally_equivalent_extraction.py:198:19 Unsupported operand [58]: `*` is not supported for operand types `Optional[int]` and `Optional[int]`.",
    "message": " `*` is not supported for operand types `Optional[int]` and `Optional[int]`.",
    "rule_id": "Unsupported operand [58]",
    "warning_line_no": 198,
    "warning_line": "        h_square = self.num_neurons * self.num_neurons",
    "min_patch": [
      {
        "hunk_fit_TFix": true,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "        logger.info(\"Searching for critical points.\")\n        h_square = self.num_neurons * self.num_neurons\n",
        "source_code_len": 109,
        "target_code": "        logger.info(\"Searching for critical points.\")\n\n        if self.num_neurons is None:\n            raise ValueError(\"The value of `num_neurons` is required for critical point search.\")\n        h_square = self.num_neurons * self.num_neurons\n",
        "target_code_len": 245,
        "diff_format": "@@ -197,2 +184,5 @@\n         logger.info(\"Searching for critical points.\")\n+\n+        if self.num_neurons is None:\n+            raise ValueError(\"The value of `num_neurons` is required for critical point search.\")\n         h_square = self.num_neurons * self.num_neurons\n",
        "source_code_with_indent": "        logger.info(\"Searching for critical points.\")\n        h_square = self.num_neurons * self.num_neurons\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "        logger.info(\"Searching for critical points.\")\n\n        if self.num_neurons is None:\n            <IND>raise ValueError(\"The value of `num_neurons` is required for critical point search.\")\n        <DED>h_square = self.num_neurons * self.num_neurons\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "Trusted-AI/adversarial-robustness-toolbox",
    "commit": "e7c5d65a6e28af8ca36fb568551ae72ee7cc2d37",
    "filename": "art/attacks/extraction/functionally_equivalent_extraction.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/Trusted-AI-adversarial-robustness-toolbox/art/attacks/extraction/functionally_equivalent_extraction.py",
    "file_hunks_size": 26,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": true,
    "full_warning_msg": "art/attacks/extraction/functionally_equivalent_extraction.py:535:8 Incompatible parameter type [6]: Expected `Classifier` for 1st parameter `classifier` to call `FunctionallyEquivalentExtraction.__init__` but got `KerasClassifier`.",
    "message": " Expected `Classifier` for 1st parameter `classifier` to call `FunctionallyEquivalentExtraction.__init__` but got `KerasClassifier`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 535,
    "warning_line": "        classifier=target_classifier, num_neurons=number_neurons",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": true,
        "source_code": "\n    target_classifier = KerasClassifier(\n        model=model, use_logits=True, clip_values=(0, 1)\n    )\n\n    fee = FunctionallyEquivalentExtraction(\n        classifier=target_classifier, num_neurons=number_neurons\n    )\n",
        "source_code_len": 221,
        "target_code": "\n    target_classifier = KerasClassifier(model=model, use_logits=True, clip_values=(0, 1))\n\n    fee = FunctionallyEquivalentExtraction(\n        classifier=target_classifier, num_neurons=number_neurons  # type: ignore\n    )\n",
        "target_code_len": 223,
        "diff_format": "@@ -529,8 +467,6 @@\n \n-    target_classifier = KerasClassifier(\n-        model=model, use_logits=True, clip_values=(0, 1)\n-    )\n+    target_classifier = KerasClassifier(model=model, use_logits=True, clip_values=(0, 1))\n \n     fee = FunctionallyEquivalentExtraction(\n-        classifier=target_classifier, num_neurons=number_neurons\n+        classifier=target_classifier, num_neurons=number_neurons  # type: ignore\n     )\n",
        "source_code_with_indent": "\n    target_classifier = KerasClassifier(\n        model=model, use_logits=True, clip_values=(0, 1)\n    )\n\n    fee = FunctionallyEquivalentExtraction(\n        classifier=target_classifier, num_neurons=number_neurons\n    )\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n    target_classifier = KerasClassifier(model=model, use_logits=True, clip_values=(0, 1))\n\n    fee = FunctionallyEquivalentExtraction(\n        classifier=target_classifier, num_neurons=number_neurons  # type: ignore\n    )\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "Trusted-AI/adversarial-robustness-toolbox",
    "commit": "e7c5d65a6e28af8ca36fb568551ae72ee7cc2d37",
    "filename": "art/attacks/extraction/knockoff_nets.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/Trusted-AI-adversarial-robustness-toolbox/art/attacks/extraction/knockoff_nets.py",
    "file_hunks_size": 15,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "art/attacks/extraction/knockoff_nets.py:131:60 Incompatible parameter type [6]: Expected `Classifier` for 2nd positional only parameter to call `KnockoffNets._random_extraction` but got `ClassifierMixin`.",
    "message": " Expected `Classifier` for 2nd positional only parameter to call `KnockoffNets._random_extraction` but got `ClassifierMixin`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 131,
    "warning_line": "            thieved_classifier = self._random_extraction(x, thieved_classifier)",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "        thieved_classifier = kwargs.get(\"thieved_classifier\")\n        if thieved_classifier is None or not isinstance(\n            thieved_classifier, ClassifierMixin\n        ):\n            raise ValueError(\"A thieved classifier is needed.\")\n",
        "source_code_len": 242,
        "target_code": "        thieved_classifier = kwargs.get(\"thieved_classifier\")\n        if thieved_classifier is None or not isinstance(thieved_classifier, Classifier):\n            raise ValueError(\"A thieved classifier is needed.\")\n",
        "target_code_len": 215,
        "diff_format": "@@ -123,5 +117,3 @@\n         thieved_classifier = kwargs.get(\"thieved_classifier\")\n-        if thieved_classifier is None or not isinstance(\n-            thieved_classifier, ClassifierMixin\n-        ):\n+        if thieved_classifier is None or not isinstance(thieved_classifier, Classifier):\n             raise ValueError(\"A thieved classifier is needed.\")\n",
        "source_code_with_indent": "        <DED>thieved_classifier = kwargs.get(\"thieved_classifier\")\n        if thieved_classifier is None or not isinstance(\n            thieved_classifier, ClassifierMixin\n        ):\n            <IND>raise ValueError(\"A thieved classifier is needed.\")\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "        <DED>thieved_classifier = kwargs.get(\"thieved_classifier\")\n        if thieved_classifier is None or not isinstance(thieved_classifier, Classifier):\n            <IND>raise ValueError(\"A thieved classifier is needed.\")\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "Trusted-AI/adversarial-robustness-toolbox",
    "commit": "e7c5d65a6e28af8ca36fb568551ae72ee7cc2d37",
    "filename": "art/attacks/extraction/knockoff_nets.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/Trusted-AI-adversarial-robustness-toolbox/art/attacks/extraction/knockoff_nets.py",
    "file_hunks_size": 15,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "art/attacks/extraction/knockoff_nets.py:133:65 Incompatible parameter type [6]: Expected `Classifier` for 3rd positional only parameter to call `KnockoffNets._adaptive_extraction` but got `ClassifierMixin`.",
    "message": " Expected `Classifier` for 3rd positional only parameter to call `KnockoffNets._adaptive_extraction` but got `ClassifierMixin`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 133,
    "warning_line": "            thieved_classifier = self._adaptive_extraction(x, y, thieved_classifier)",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "        thieved_classifier = kwargs.get(\"thieved_classifier\")\n        if thieved_classifier is None or not isinstance(\n            thieved_classifier, ClassifierMixin\n        ):\n            raise ValueError(\"A thieved classifier is needed.\")\n",
        "source_code_len": 242,
        "target_code": "        thieved_classifier = kwargs.get(\"thieved_classifier\")\n        if thieved_classifier is None or not isinstance(thieved_classifier, Classifier):\n            raise ValueError(\"A thieved classifier is needed.\")\n",
        "target_code_len": 215,
        "diff_format": "@@ -123,5 +117,3 @@\n         thieved_classifier = kwargs.get(\"thieved_classifier\")\n-        if thieved_classifier is None or not isinstance(\n-            thieved_classifier, ClassifierMixin\n-        ):\n+        if thieved_classifier is None or not isinstance(thieved_classifier, Classifier):\n             raise ValueError(\"A thieved classifier is needed.\")\n",
        "source_code_with_indent": "        <DED>thieved_classifier = kwargs.get(\"thieved_classifier\")\n        if thieved_classifier is None or not isinstance(\n            thieved_classifier, ClassifierMixin\n        ):\n            <IND>raise ValueError(\"A thieved classifier is needed.\")\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "        <DED>thieved_classifier = kwargs.get(\"thieved_classifier\")\n        if thieved_classifier is None or not isinstance(thieved_classifier, Classifier):\n            <IND>raise ValueError(\"A thieved classifier is needed.\")\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "Trusted-AI/adversarial-robustness-toolbox",
    "commit": "e7c5d65a6e28af8ca36fb568551ae72ee7cc2d37",
    "filename": "art/attacks/poisoning/poisoning_attack_svm.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/Trusted-AI-adversarial-robustness-toolbox/art/attacks/poisoning/poisoning_attack_svm.py",
    "file_hunks_size": 10,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": true,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "art/attacks/poisoning/poisoning_attack_svm.py:146:11 Unsupported operand [58]: `<=` is not supported for operand types `Optional[float]` and `int`.",
    "message": " `<=` is not supported for operand types `Optional[float]` and `int`.",
    "rule_id": "Unsupported operand [58]",
    "warning_line_no": 146,
    "warning_line": "        if self.step <= 0:",
    "min_patch": [
      {
        "hunk_fit_TFix": true,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    def _check_params(self) -> None:\n        if self.step <= 0:\n            raise ValueError(\"Step size must be strictly positive.\")\n        if self.eps <= 0:\n            raise ValueError(\"Value of eps must be strictly positive.\")\n",
        "source_code_len": 231,
        "target_code": "    def _check_params(self) -> None:\n        if self.step is not None and self.step <= 0:\n            raise ValueError(\"Step size must be strictly positive.\")\n        if self.eps is not None and self.eps <= 0:\n            raise ValueError(\"Value of eps must be strictly positive.\")\n",
        "target_code_len": 282,
        "diff_format": "@@ -145,5 +138,5 @@\n     def _check_params(self) -> None:\n-        if self.step <= 0:\n+        if self.step is not None and self.step <= 0:\n             raise ValueError(\"Step size must be strictly positive.\")\n-        if self.eps <= 0:\n+        if self.eps is not None and self.eps <= 0:\n             raise ValueError(\"Value of eps must be strictly positive.\")\n",
        "source_code_with_indent": "    <DED>def _check_params(self) -> None:\n        <IND>if self.step <= 0:\n            <IND>raise ValueError(\"Step size must be strictly positive.\")\n        <DED>if self.eps <= 0:\n            <IND>raise ValueError(\"Value of eps must be strictly positive.\")\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    <DED>def _check_params(self) -> None:\n        <IND>if self.step is not None and self.step <= 0:\n            <IND>raise ValueError(\"Step size must be strictly positive.\")\n        <DED>if self.eps is not None and self.eps <= 0:\n            <IND>raise ValueError(\"Value of eps must be strictly positive.\")\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "Trusted-AI/adversarial-robustness-toolbox",
    "commit": "e7c5d65a6e28af8ca36fb568551ae72ee7cc2d37",
    "filename": "art/attacks/poisoning/poisoning_attack_svm.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/Trusted-AI-adversarial-robustness-toolbox/art/attacks/poisoning/poisoning_attack_svm.py",
    "file_hunks_size": 10,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": true,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "art/attacks/poisoning/poisoning_attack_svm.py:148:11 Unsupported operand [58]: `<=` is not supported for operand types `Optional[float]` and `int`.",
    "message": " `<=` is not supported for operand types `Optional[float]` and `int`.",
    "rule_id": "Unsupported operand [58]",
    "warning_line_no": 148,
    "warning_line": "        if self.eps <= 0:",
    "min_patch": [
      {
        "hunk_fit_TFix": true,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    def _check_params(self) -> None:\n        if self.step <= 0:\n            raise ValueError(\"Step size must be strictly positive.\")\n        if self.eps <= 0:\n            raise ValueError(\"Value of eps must be strictly positive.\")\n",
        "source_code_len": 231,
        "target_code": "    def _check_params(self) -> None:\n        if self.step is not None and self.step <= 0:\n            raise ValueError(\"Step size must be strictly positive.\")\n        if self.eps is not None and self.eps <= 0:\n            raise ValueError(\"Value of eps must be strictly positive.\")\n",
        "target_code_len": 282,
        "diff_format": "@@ -145,5 +138,5 @@\n     def _check_params(self) -> None:\n-        if self.step <= 0:\n+        if self.step is not None and self.step <= 0:\n             raise ValueError(\"Step size must be strictly positive.\")\n-        if self.eps <= 0:\n+        if self.eps is not None and self.eps <= 0:\n             raise ValueError(\"Value of eps must be strictly positive.\")\n",
        "source_code_with_indent": "    <DED>def _check_params(self) -> None:\n        <IND>if self.step <= 0:\n            <IND>raise ValueError(\"Step size must be strictly positive.\")\n        <DED>if self.eps <= 0:\n            <IND>raise ValueError(\"Value of eps must be strictly positive.\")\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    <DED>def _check_params(self) -> None:\n        <IND>if self.step is not None and self.step <= 0:\n            <IND>raise ValueError(\"Step size must be strictly positive.\")\n        <DED>if self.eps is not None and self.eps <= 0:\n            <IND>raise ValueError(\"Value of eps must be strictly positive.\")\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  }
]