[
  {
    "project": "python/mypy",
    "commit": "b778c875cc6e92ad82666531740dab28274cf3e4",
    "filename": "mypy/checkmember.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/python-mypy/mypy/checkmember.py",
    "file_hunks_size": 6,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "mypy/checkmember.py:792:35 Incompatible parameter type [6]: Expected `List[int]` for 2nd parameter `arg_kinds` to call `CallableType.__init__` but got `List[typing_extensions.Final[int]]`.",
    "message": " Expected `List[int]` for 2nd parameter `arg_kinds` to call `CallableType.__init__` but got `List[typing_extensions.Final[int]]`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 792,
    "warning_line": "                                   arg_kinds=[ARG_STAR, ARG_STAR2],",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    # in the MRO, preferring __init__ if there is a tie.\n    init_method = info.get_method('__init__')\n    new_method = info.get_method('__new__')\n    if not init_method:\n        # Must be an invalid class definition.\n",
        "source_code_len": 218,
        "target_code": "    # in the MRO, preferring __init__ if there is a tie.\n    init_method = info.get('__init__')\n    new_method = info.get('__new__')\n    if not init_method or not is_valid_constructor(init_method.node):\n        # Must be an invalid class definition.\n",
        "target_code_len": 250,
        "diff_format": "@@ -766,5 +766,5 @@\n     # in the MRO, preferring __init__ if there is a tie.\n-    init_method = info.get_method('__init__')\n-    new_method = info.get_method('__new__')\n-    if not init_method:\n+    init_method = info.get('__init__')\n+    new_method = info.get('__new__')\n+    if not init_method or not is_valid_constructor(init_method.node):\n         # Must be an invalid class definition.\n",
        "source_code_with_indent": "    # in the MRO, preferring __init__ if there is a tie.\n    init_method = info.get_method('__init__')\n    new_method = info.get_method('__new__')\n    if not init_method:\n        # Must be an invalid class definition.\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    # in the MRO, preferring __init__ if there is a tie.\n    init_method = info.get('__init__')\n    new_method = info.get('__new__')\n    if not init_method or not is_valid_constructor(init_method.node):\n        # Must be an invalid class definition.\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    new_method = new_method or init_method\n\n    init_index = info.mro.index(init_method.info)\n    new_index = info.mro.index(new_method.info)\n\n",
        "source_code_len": 143,
        "target_code": "    new_method = new_method or init_method\n    if not is_valid_constructor(new_method.node):\n        # Must be an invalid class definition.\n        return AnyType(TypeOfAny.from_error)\n\n    # The two is_valid_constructor() checks ensure this.\n    assert isinstance(new_method.node, (FuncBase, Decorator))\n    assert isinstance(init_method.node, (FuncBase, Decorator))\n\n    init_index = info.mro.index(init_method.node.info)\n    new_index = info.mro.index(new_method.node.info)\n\n",
        "target_code_len": 478,
        "diff_format": "@@ -774,5 +774,12 @@\n     new_method = new_method or init_method\n-\n-    init_index = info.mro.index(init_method.info)\n-    new_index = info.mro.index(new_method.info)\n+    if not is_valid_constructor(new_method.node):\n+        # Must be an invalid class definition.\n+        return AnyType(TypeOfAny.from_error)\n+\n+    # The two is_valid_constructor() checks ensure this.\n+    assert isinstance(new_method.node, (FuncBase, Decorator))\n+    assert isinstance(init_method.node, (FuncBase, Decorator))\n+\n+    init_index = info.mro.index(init_method.node.info)\n+    new_index = info.mro.index(new_method.node.info)\n \n",
        "source_code_with_indent": "    <DED>new_method = new_method or init_method\n\n    init_index = info.mro.index(init_method.info)\n    new_index = info.mro.index(new_method.info)\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    <DED>new_method = new_method or init_method\n    if not is_valid_constructor(new_method.node):\n        # Must be an invalid class definition.\n        <IND>return AnyType(TypeOfAny.from_error)\n\n    # The two is_valid_constructor() checks ensure this.\n    <DED>assert isinstance(new_method.node, (FuncBase, Decorator))\n    assert isinstance(init_method.node, (FuncBase, Decorator))\n\n    init_index = info.mro.index(init_method.node.info)\n    new_index = info.mro.index(new_method.node.info)\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "        # typeshed (#5647).\n        method = init_method\n    # Construct callable type based on signature of __init__. Adjust\n    # return type and insert type arguments.\n    return type_object_type_from_function(method, info, fallback)\n\n\ndef type_object_type_from_function(init_or_new: FuncBase,\n                                   info: TypeInfo,\n                                   fallback: Instance) -> FunctionLike:\n    signature = bind_self(function_type(init_or_new, fallback))\n\n    # The __init__ method might come from a generic superclass\n",
        "source_code_len": 548,
        "target_code": "        # typeshed (#5647).\n        method = init_method.node\n    # Construct callable type based on signature of __init__. Adjust\n    # return type and insert type arguments.\n    if isinstance(method, FuncBase):\n        t = function_type(method, fallback)\n    else:\n        assert isinstance(method.type, FunctionLike)  # is_valid_constructor() ensures this\n        t = method.type\n    return type_object_type_from_function(t, info, method.info, fallback)\n\n\ndef is_valid_constructor(n: Optional[SymbolNode]) -> bool:\n    \"\"\"Does this node represents a valid constructor method?\n\n    This includes normal functions, overloaded functions, and decorators\n    that return a callable type.\n    \"\"\"\n    if isinstance(n, FuncBase):\n        return True\n    if isinstance(n, Decorator):\n        return isinstance(n.type, FunctionLike)\n    return False\n\n\ndef type_object_type_from_function(signature: FunctionLike,\n                                   info: TypeInfo,\n                                   def_info: TypeInfo,\n                                   fallback: Instance) -> FunctionLike:\n    # The __init__ method might come from a generic superclass\n",
        "target_code_len": 1147,
        "diff_format": "@@ -800,13 +807,30 @@\n         # typeshed (#5647).\n-        method = init_method\n+        method = init_method.node\n     # Construct callable type based on signature of __init__. Adjust\n     # return type and insert type arguments.\n-    return type_object_type_from_function(method, info, fallback)\n-\n-\n-def type_object_type_from_function(init_or_new: FuncBase,\n+    if isinstance(method, FuncBase):\n+        t = function_type(method, fallback)\n+    else:\n+        assert isinstance(method.type, FunctionLike)  # is_valid_constructor() ensures this\n+        t = method.type\n+    return type_object_type_from_function(t, info, method.info, fallback)\n+\n+\n+def is_valid_constructor(n: Optional[SymbolNode]) -> bool:\n+    \"\"\"Does this node represents a valid constructor method?\n+\n+    This includes normal functions, overloaded functions, and decorators\n+    that return a callable type.\n+    \"\"\"\n+    if isinstance(n, FuncBase):\n+        return True\n+    if isinstance(n, Decorator):\n+        return isinstance(n.type, FunctionLike)\n+    return False\n+\n+\n+def type_object_type_from_function(signature: FunctionLike,\n                                    info: TypeInfo,\n+                                   def_info: TypeInfo,\n                                    fallback: Instance) -> FunctionLike:\n-    signature = bind_self(function_type(init_or_new, fallback))\n-\n     # The __init__ method might come from a generic superclass\n",
        "source_code_with_indent": "        # typeshed (#5647).\n        <DED><DED>method = init_method\n    # Construct callable type based on signature of __init__. Adjust\n    # return type and insert type arguments.\n    <DED>return type_object_type_from_function(method, info, fallback)\n\n\n<DED>def type_object_type_from_function(init_or_new: FuncBase,\n                                   info: TypeInfo,\n                                   fallback: Instance) -> FunctionLike:\n    <IND>signature = bind_self(function_type(init_or_new, fallback))\n\n    # The __init__ method might come from a generic superclass\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "        # typeshed (#5647).\n        <DED><DED>method = init_method.node\n    # Construct callable type based on signature of __init__. Adjust\n    # return type and insert type arguments.\n    <DED>if isinstance(method, FuncBase):\n        <IND>t = function_type(method, fallback)\n    <DED>else:\n        <IND>assert isinstance(method.type, FunctionLike)  # is_valid_constructor() ensures this\n        t = method.type\n    <DED>return type_object_type_from_function(t, info, method.info, fallback)\n\n\n<DED>def is_valid_constructor(n: Optional[SymbolNode]) -> bool:\n    <IND>\"\"\"Does this node represents a valid constructor method?\n\n    This includes normal functions, overloaded functions, and decorators\n    that return a callable type.\n    \"\"\"\n    if isinstance(n, FuncBase):\n        <IND>return True\n    <DED>if isinstance(n, Decorator):\n        <IND>return isinstance(n.type, FunctionLike)\n    <DED>return False\n\n\n<DED>def type_object_type_from_function(signature: FunctionLike,\n                                   info: TypeInfo,\n                                   def_info: TypeInfo,\n                                   fallback: Instance) -> FunctionLike:\n    # The __init__ method might come from a generic superclass\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    # We need to first map B's __init__ to the type (List[T]) -> None.\n    signature = cast(FunctionLike,\n                     map_type_from_supertype(signature, info, init_or_new.info))\n    special_sig = None  # type: Optional[str]\n    if init_or_new.info.fullname() == 'builtins.dict':\n        # Special signature!\n",
        "source_code_len": 317,
        "target_code": "    # We need to first map B's __init__ to the type (List[T]) -> None.\n    signature = bind_self(signature)\n    signature = cast(FunctionLike,\n                     map_type_from_supertype(signature, info, def_info))\n    special_sig = None  # type: Optional[str]\n    if def_info.fullname() == 'builtins.dict':\n        # Special signature!\n",
        "target_code_len": 338,
        "diff_format": "@@ -820,6 +844,7 @@\n     # We need to first map B's __init__ to the type (List[T]) -> None.\n+    signature = bind_self(signature)\n     signature = cast(FunctionLike,\n-                     map_type_from_supertype(signature, info, init_or_new.info))\n+                     map_type_from_supertype(signature, info, def_info))\n     special_sig = None  # type: Optional[str]\n-    if init_or_new.info.fullname() == 'builtins.dict':\n+    if def_info.fullname() == 'builtins.dict':\n         # Special signature!\n",
        "source_code_with_indent": "    # We need to first map B's __init__ to the type (List[T]) -> None.\n    signature = cast(FunctionLike,\n                     map_type_from_supertype(signature, info, init_or_new.info))\n    special_sig = None  # type: Optional[str]\n    if init_or_new.info.fullname() == 'builtins.dict':\n        # Special signature!\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    # We need to first map B's __init__ to the type (List[T]) -> None.\n    <IND>signature = bind_self(signature)\n    signature = cast(FunctionLike,\n                     map_type_from_supertype(signature, info, def_info))\n    special_sig = None  # type: Optional[str]\n    if def_info.fullname() == 'builtins.dict':\n        # Special signature!\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "python/mypy",
    "commit": "b778c875cc6e92ad82666531740dab28274cf3e4",
    "filename": "mypy/checkmember.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/python-mypy/mypy/checkmember.py",
    "file_hunks_size": 6,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "mypy/checkmember.py:847:8 Incompatible parameter type [6]: Expected `mypy_extensions.FlexibleAlias[Type, typing.Any]` for 1st parameter `ret_type` to call `CallableType.copy_modified` but got `typing.Union[Instance, TupleType]`.",
    "message": " Expected `mypy_extensions.FlexibleAlias[Type, typing.Any]` for 1st parameter `ret_type` to call `CallableType.copy_modified` but got `typing.Union[Instance, TupleType]`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 847,
    "warning_line": "        ret_type=fill_typevars(info), fallback=type_type, name=None, variables=variables,"
  }
]