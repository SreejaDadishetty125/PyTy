[
  {
    "project": "spinalcordtoolbox/spinalcordtoolbox",
    "commit": "b6afaaa58a66bdd22d4877d779288fd44d481303",
    "filename": "scripts/sct_invert_image.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/spinalcordtoolbox-spinalcordtoolbox/scripts/sct_invert_image.py",
    "file_hunks_size": 5,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "scripts/sct_invert_image.py:36:4 Incompatible variable type [9]: param is declared to have type `typing.Type[param]` but is used as type `param`.",
    "message": " param is declared to have type `typing.Type[param]` but is used as type `param`.",
    "rule_id": "Incompatible variable type [9]",
    "warning_line_no": 36,
    "warning_line": "    param = param()",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n# DEFAULT PARAMETERS\n\n\nclass param:\n    # The constructor\n    def __init__(self):\n        self.debug = 0\n\n#=======================================================================================================================\n# Start program\n#=======================================================================================================================\nif __name__ == \"__main__\":\n    sct.start_stream_logger()\n    # initialize parameters\n    param = param()\n    # call main function\n\n    # Initialize the parser\n    parser = Parser(__file__)\n    parser.usage.set_description('Utility function for labels.')\n    parser.add_option(name=\"-i\",\n",
        "source_code_len": 652,
        "target_code": "\n\ndef get_parser():\n    # Initialize the parser\n    parser = Parser(__file__)\n    parser.usage.set_description('This function inverts the image intensity using the maximum intensity in the image and 0.')\n    parser.add_option(name=\"-i\",\n",
        "target_code_len": 237,
        "diff_format": "@@ -21,22 +19,7 @@\n \n-# DEFAULT PARAMETERS\n \n-\n-class param:\n-    # The constructor\n-    def __init__(self):\n-        self.debug = 0\n-\n-#=======================================================================================================================\n-# Start program\n-#=======================================================================================================================\n-if __name__ == \"__main__\":\n-    sct.start_stream_logger()\n-    # initialize parameters\n-    param = param()\n-    # call main function\n-\n+def get_parser():\n     # Initialize the parser\n     parser = Parser(__file__)\n-    parser.usage.set_description('Utility function for labels.')\n+    parser.usage.set_description('This function inverts the image intensity using the maximum intensity in the image and 0.')\n     parser.add_option(name=\"-i\",\n",
        "source_code_with_indent": "\n# DEFAULT PARAMETERS\n\n\nclass param:\n    # The constructor\n    <IND>def __init__(self):\n        <IND>self.debug = 0\n\n#=======================================================================================================================\n# Start program\n#=======================================================================================================================\n<DED><DED>if __name__ == \"__main__\":\n    <IND>sct.start_stream_logger()\n    # initialize parameters\n    param = param()\n    # call main function\n\n    # Initialize the parser\n    parser = Parser(__file__)\n    parser.usage.set_description('Utility function for labels.')\n    parser.add_option(name=\"-i\",\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n\ndef get_parser():\n    # Initialize the parser\n    <IND>parser = Parser(__file__)\n    parser.usage.set_description('This function inverts the image intensity using the maximum intensity in the image and 0.')\n    parser.add_option(name=\"-i\",\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "spinalcordtoolbox/spinalcordtoolbox",
    "commit": "b6afaaa58a66bdd22d4877d779288fd44d481303",
    "filename": "testing/test_sct_segment_graymatter.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/spinalcordtoolbox-spinalcordtoolbox/testing/test_sct_segment_graymatter.py",
    "file_hunks_size": 2,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "testing/test_sct_segment_graymatter.py:159:9 Unbound name [10]: Name `path_sct` is used but not defined in the current scope.",
    "message": " Name `path_sct` is used but not defined in the current scope.",
    "rule_id": "Unbound name [10]",
    "warning_line_no": 159,
    "warning_line": "    test(path_sct+'/data')",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    result_dice_gm, result_dice_wm, result_hausdorff, result_median_dist = float('nan'), float('nan'), float('nan'), float('nan')\n    if status == 0 and \"-ref\" in dict_param_with_path.keys()    :\n        target_name = sct.extract_fname(dict_param_with_path[\"-i\"])[1]\n\n        dice_fname = path_output+'dice_coefficient_'+target_name+'.txt'\n        hausdorff_fname = path_output+'hausdorff_dist_'+target_name+'.txt'\n\n        # Extracting dice results:\n        dice = open(dice_fname, 'r')\n        dice_lines = dice.readlines()\n        dice.close()\n        gm_start = dice_lines.index('Dice coefficient on the Gray Matter segmentation:\\n')\n        wm_start = dice_lines.index('Dice coefficient on the White Matter segmentation:\\n')\n\n        # extracting dice on GM\n        gm_dice_lines = dice_lines[gm_start:wm_start-1]\n        gm_dice_lines = gm_dice_lines[gm_dice_lines.index('2D Dice coefficient by slice:\\n')+1:-1]\n\n        null_slices = []\n        gm_dice = []\n        for line in gm_dice_lines:\n            n_slice, dc = line.split(' ')\n            # remove \\n from dice result\n            dc = dc[:-1]\n            dc = dc[:-4] if '[0m' in dc else dc\n\n            if dc == '0' or dc == 'nan':\n                null_slices.append(n_slice)\n            else:\n                try:\n                    gm_dice.append(float(dc))\n                except ValueError:\n                    gm_dice.append(float(dc[:-4]))\n        result_dice_gm = mean(gm_dice)\n\n        # extracting dice on WM\n        wm_dice_lines = dice_lines[wm_start:]\n        wm_dice_lines = wm_dice_lines[wm_dice_lines.index('2D Dice coefficient by slice:\\n')+1:]\n        wm_dice = []\n        for line in wm_dice_lines:\n            n_slice, dc = line.split(' ')\n            # remove \\n from dice result\n            if line is not wm_dice_lines[-1]:\n                dc = dc[:-1]\n            if n_slice not in null_slices:\n                try:\n                    wm_dice.append(float(dc))\n                except ValueError:\n                    wm_dice.append(float(dc[:-4]))\n        result_dice_wm = mean(wm_dice)\n\n        # Extracting hausdorff distance results\n        hd = open(hausdorff_fname, 'r')\n        hd_lines = hd.readlines()\n        hd.close()\n\n        # remove title of columns and last empty/non important lines\n        hd_lines = hd_lines[1:-4]\n\n        hausdorff = []\n        max_med = []\n        for line in hd_lines:\n            slice_id, res = line.split(':')\n            slice, n_slice = slice_id.split(' ')\n            if n_slice not in null_slices:\n                hd, med1, med2 = res[:-1].split(' - ')\n                hd, med1, med2 = float(hd), float(med1), float(med2)\n                hausdorff.append(hd)\n                max_med.append(max(med1, med2))\n\n        result_hausdorff = mean(hausdorff)\n        result_median_dist = mean(max_med)\n\n        # Integrity check\n        hd_threshold = 3 # in mm\n        wm_dice_threshold = 0.8\n        if result_hausdorff > hd_threshold or result_dice_wm < wm_dice_threshold:\n            status = 99\n            output += '\\nResulting segmentation is too different from manual segmentation:\\n' \\\n                      'WM dice: '+str(result_dice_wm)+'\\n' \\\n                      'Hausdorff distance: '+str(result_hausdorff)+'\\n'\n\n    # transform results into Pandas structure\n    results = DataFrame(data={'status': status, 'output': output, 'dice_gm': result_dice_gm, 'dice_wm': result_dice_wm, 'hausdorff': result_hausdorff, 'med_dist': result_median_dist, 'duration_[s]': duration}, index=[path_data])\n\n    return status, output, results\n\n\nif __name__ == \"__main__\":\n    # call main function\n    test(path_sct+'/data')\n",
        "source_code_len": 3650,
        "target_code": "    result_dice_gm, result_dice_wm, result_hausdorff, result_median_dist = float('nan'), float('nan'), float('nan'), float('nan')\n\n    target_name = sct.extract_fname(param_test.file_input)[1]\n\n    dice_fname = param_test.path_output + 'dice_coefficient_' + target_name + '.txt'\n    hausdorff_fname = param_test.path_output + 'hausdorff_dist_' + target_name + '.txt'\n\n    # Extracting dice results:\n    dice = open(dice_fname, 'r')\n    dice_lines = dice.readlines()\n    dice.close()\n    gm_start = dice_lines.index('Dice coefficient on the Gray Matter segmentation:\\n')\n    wm_start = dice_lines.index('Dice coefficient on the White Matter segmentation:\\n')\n\n    # extracting dice on GM\n    gm_dice_lines = dice_lines[gm_start:wm_start - 1]\n    gm_dice_lines = gm_dice_lines[gm_dice_lines.index('2D Dice coefficient by slice:\\n') + 1:-1]\n\n    null_slices = []\n    gm_dice = []\n    for line in gm_dice_lines:\n        n_slice, dc = line.split(' ')\n        # remove \\n from dice result\n        dc = dc[:-1]\n        dc = dc[:-4] if '[0m' in dc else dc\n\n        if dc == '0' or dc == 'nan':\n            null_slices.append(n_slice)\n        else:\n            try:\n                gm_dice.append(float(dc))\n            except ValueError:\n                gm_dice.append(float(dc[:-4]))\n    result_dice_gm = mean(gm_dice)\n\n    # extracting dice on WM\n    wm_dice_lines = dice_lines[wm_start:]\n    wm_dice_lines = wm_dice_lines[wm_dice_lines.index('2D Dice coefficient by slice:\\n') + 1:]\n    wm_dice = []\n    for line in wm_dice_lines:\n        n_slice, dc = line.split(' ')\n        # remove \\n from dice result\n        if line is not wm_dice_lines[-1]:\n            dc = dc[:-1]\n        if n_slice not in null_slices:\n            try:\n                wm_dice.append(float(dc))\n            except ValueError:\n                wm_dice.append(float(dc[:-4]))\n    result_dice_wm = mean(wm_dice)\n\n    # Extracting hausdorff distance results\n    hd = open(hausdorff_fname, 'r')\n    hd_lines = hd.readlines()\n    hd.close()\n\n    # remove title of columns and last empty/non important lines\n    hd_lines = hd_lines[1:-4]\n\n    hausdorff = []\n    max_med = []\n    for line in hd_lines:\n        slice_id, res = line.split(':')\n        slice, n_slice = slice_id.split(' ')\n        if n_slice not in null_slices:\n            hd, med1, med2 = res[:-1].split(' - ')\n            hd, med1, med2 = float(hd), float(med1), float(med2)\n            hausdorff.append(hd)\n            max_med.append(max(med1, med2))\n\n    result_hausdorff = mean(hausdorff)\n    result_median_dist = mean(max_med)\n\n    # Integrity check\n    if result_hausdorff > param_test.hd_threshold or result_dice_wm < param_test.wm_dice_threshold:\n        param_test.status = 99\n        param_test.output += '\\nResulting segmentation is too different from manual segmentation:\\n' \\\n                             'WM dice: ' + str(result_dice_wm) + '\\n' \\\n                             'Hausdorff distance: ' + str(result_hausdorff) + '\\n'\n\n    # transform results into Pandas structure\n    results = DataFrame(data={'status': param_test.status, 'output': param_test.output, 'dice_gm': result_dice_gm, 'dice_wm': result_dice_wm,\n                              'hausdorff': result_hausdorff, 'med_dist': result_median_dist, 'duration_[s]': param_test.duration},\n                        index=[param_test.path_data])\n\n    return param_test\n",
        "target_code_len": 3369,
        "diff_format": "@@ -69,91 +52,86 @@\n     result_dice_gm, result_dice_wm, result_hausdorff, result_median_dist = float('nan'), float('nan'), float('nan'), float('nan')\n-    if status == 0 and \"-ref\" in dict_param_with_path.keys()    :\n-        target_name = sct.extract_fname(dict_param_with_path[\"-i\"])[1]\n \n-        dice_fname = path_output+'dice_coefficient_'+target_name+'.txt'\n-        hausdorff_fname = path_output+'hausdorff_dist_'+target_name+'.txt'\n+    target_name = sct.extract_fname(param_test.file_input)[1]\n \n-        # Extracting dice results:\n-        dice = open(dice_fname, 'r')\n-        dice_lines = dice.readlines()\n-        dice.close()\n-        gm_start = dice_lines.index('Dice coefficient on the Gray Matter segmentation:\\n')\n-        wm_start = dice_lines.index('Dice coefficient on the White Matter segmentation:\\n')\n+    dice_fname = param_test.path_output + 'dice_coefficient_' + target_name + '.txt'\n+    hausdorff_fname = param_test.path_output + 'hausdorff_dist_' + target_name + '.txt'\n \n-        # extracting dice on GM\n-        gm_dice_lines = dice_lines[gm_start:wm_start-1]\n-        gm_dice_lines = gm_dice_lines[gm_dice_lines.index('2D Dice coefficient by slice:\\n')+1:-1]\n+    # Extracting dice results:\n+    dice = open(dice_fname, 'r')\n+    dice_lines = dice.readlines()\n+    dice.close()\n+    gm_start = dice_lines.index('Dice coefficient on the Gray Matter segmentation:\\n')\n+    wm_start = dice_lines.index('Dice coefficient on the White Matter segmentation:\\n')\n \n-        null_slices = []\n-        gm_dice = []\n-        for line in gm_dice_lines:\n-            n_slice, dc = line.split(' ')\n-            # remove \\n from dice result\n+    # extracting dice on GM\n+    gm_dice_lines = dice_lines[gm_start:wm_start - 1]\n+    gm_dice_lines = gm_dice_lines[gm_dice_lines.index('2D Dice coefficient by slice:\\n') + 1:-1]\n+\n+    null_slices = []\n+    gm_dice = []\n+    for line in gm_dice_lines:\n+        n_slice, dc = line.split(' ')\n+        # remove \\n from dice result\n+        dc = dc[:-1]\n+        dc = dc[:-4] if '[0m' in dc else dc\n+\n+        if dc == '0' or dc == 'nan':\n+            null_slices.append(n_slice)\n+        else:\n+            try:\n+                gm_dice.append(float(dc))\n+            except ValueError:\n+                gm_dice.append(float(dc[:-4]))\n+    result_dice_gm = mean(gm_dice)\n+\n+    # extracting dice on WM\n+    wm_dice_lines = dice_lines[wm_start:]\n+    wm_dice_lines = wm_dice_lines[wm_dice_lines.index('2D Dice coefficient by slice:\\n') + 1:]\n+    wm_dice = []\n+    for line in wm_dice_lines:\n+        n_slice, dc = line.split(' ')\n+        # remove \\n from dice result\n+        if line is not wm_dice_lines[-1]:\n             dc = dc[:-1]\n-            dc = dc[:-4] if '[0m' in dc else dc\n+        if n_slice not in null_slices:\n+            try:\n+                wm_dice.append(float(dc))\n+            except ValueError:\n+                wm_dice.append(float(dc[:-4]))\n+    result_dice_wm = mean(wm_dice)\n \n-            if dc == '0' or dc == 'nan':\n-                null_slices.append(n_slice)\n-            else:\n-                try:\n-                    gm_dice.append(float(dc))\n-                except ValueError:\n-                    gm_dice.append(float(dc[:-4]))\n-        result_dice_gm = mean(gm_dice)\n+    # Extracting hausdorff distance results\n+    hd = open(hausdorff_fname, 'r')\n+    hd_lines = hd.readlines()\n+    hd.close()\n \n-        # extracting dice on WM\n-        wm_dice_lines = dice_lines[wm_start:]\n-        wm_dice_lines = wm_dice_lines[wm_dice_lines.index('2D Dice coefficient by slice:\\n')+1:]\n-        wm_dice = []\n-        for line in wm_dice_lines:\n-            n_slice, dc = line.split(' ')\n-            # remove \\n from dice result\n-            if line is not wm_dice_lines[-1]:\n-                dc = dc[:-1]\n-            if n_slice not in null_slices:\n-                try:\n-                    wm_dice.append(float(dc))\n-                except ValueError:\n-                    wm_dice.append(float(dc[:-4]))\n-        result_dice_wm = mean(wm_dice)\n+    # remove title of columns and last empty/non important lines\n+    hd_lines = hd_lines[1:-4]\n \n-        # Extracting hausdorff distance results\n-        hd = open(hausdorff_fname, 'r')\n-        hd_lines = hd.readlines()\n-        hd.close()\n+    hausdorff = []\n+    max_med = []\n+    for line in hd_lines:\n+        slice_id, res = line.split(':')\n+        slice, n_slice = slice_id.split(' ')\n+        if n_slice not in null_slices:\n+            hd, med1, med2 = res[:-1].split(' - ')\n+            hd, med1, med2 = float(hd), float(med1), float(med2)\n+            hausdorff.append(hd)\n+            max_med.append(max(med1, med2))\n \n-        # remove title of columns and last empty/non important lines\n-        hd_lines = hd_lines[1:-4]\n+    result_hausdorff = mean(hausdorff)\n+    result_median_dist = mean(max_med)\n \n-        hausdorff = []\n-        max_med = []\n-        for line in hd_lines:\n-            slice_id, res = line.split(':')\n-            slice, n_slice = slice_id.split(' ')\n-            if n_slice not in null_slices:\n-                hd, med1, med2 = res[:-1].split(' - ')\n-                hd, med1, med2 = float(hd), float(med1), float(med2)\n-                hausdorff.append(hd)\n-                max_med.append(max(med1, med2))\n-\n-        result_hausdorff = mean(hausdorff)\n-        result_median_dist = mean(max_med)\n-\n-        # Integrity check\n-        hd_threshold = 3 # in mm\n-        wm_dice_threshold = 0.8\n-        if result_hausdorff > hd_threshold or result_dice_wm < wm_dice_threshold:\n-            status = 99\n-            output += '\\nResulting segmentation is too different from manual segmentation:\\n' \\\n-                      'WM dice: '+str(result_dice_wm)+'\\n' \\\n-                      'Hausdorff distance: '+str(result_hausdorff)+'\\n'\n+    # Integrity check\n+    if result_hausdorff > param_test.hd_threshold or result_dice_wm < param_test.wm_dice_threshold:\n+        param_test.status = 99\n+        param_test.output += '\\nResulting segmentation is too different from manual segmentation:\\n' \\\n+                             'WM dice: ' + str(result_dice_wm) + '\\n' \\\n+                             'Hausdorff distance: ' + str(result_hausdorff) + '\\n'\n \n     # transform results into Pandas structure\n-    results = DataFrame(data={'status': status, 'output': output, 'dice_gm': result_dice_gm, 'dice_wm': result_dice_wm, 'hausdorff': result_hausdorff, 'med_dist': result_median_dist, 'duration_[s]': duration}, index=[path_data])\n+    results = DataFrame(data={'status': param_test.status, 'output': param_test.output, 'dice_gm': result_dice_gm, 'dice_wm': result_dice_wm,\n+                              'hausdorff': result_hausdorff, 'med_dist': result_median_dist, 'duration_[s]': param_test.duration},\n+                        index=[param_test.path_data])\n \n-    return status, output, results\n-\n-\n-if __name__ == \"__main__\":\n-    # call main function\n-    test(path_sct+'/data')\n+    return param_test\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "    result_dice_gm, result_dice_wm, result_hausdorff, result_median_dist = float('nan'), float('nan'), float('nan'), float('nan')\n    if status == 0 and \"-ref\" in dict_param_with_path.keys()    :\n        <IND>target_name = sct.extract_fname(dict_param_with_path[\"-i\"])[1]\n\n        dice_fname = path_output+'dice_coefficient_'+target_name+'.txt'\n        hausdorff_fname = path_output+'hausdorff_dist_'+target_name+'.txt'\n\n        # Extracting dice results:\n        dice = open(dice_fname, 'r')\n        dice_lines = dice.readlines()\n        dice.close()\n        gm_start = dice_lines.index('Dice coefficient on the Gray Matter segmentation:\\n')\n        wm_start = dice_lines.index('Dice coefficient on the White Matter segmentation:\\n')\n\n        # extracting dice on GM\n        gm_dice_lines = dice_lines[gm_start:wm_start-1]\n        gm_dice_lines = gm_dice_lines[gm_dice_lines.index('2D Dice coefficient by slice:\\n')+1:-1]\n\n        null_slices = []\n        gm_dice = []\n        for line in gm_dice_lines:\n            <IND>n_slice, dc = line.split(' ')\n            # remove \\n from dice result\n            dc = dc[:-1]\n            dc = dc[:-4] if '[0m' in dc else dc\n\n            if dc == '0' or dc == 'nan':\n                <IND>null_slices.append(n_slice)\n            <DED>else:\n                <IND>try:\n                    <IND>gm_dice.append(float(dc))\n                <DED>except ValueError:\n                    <IND>gm_dice.append(float(dc[:-4]))\n        <DED><DED><DED>result_dice_gm = mean(gm_dice)\n\n        # extracting dice on WM\n        wm_dice_lines = dice_lines[wm_start:]\n        wm_dice_lines = wm_dice_lines[wm_dice_lines.index('2D Dice coefficient by slice:\\n')+1:]\n        wm_dice = []\n        for line in wm_dice_lines:\n            <IND>n_slice, dc = line.split(' ')\n            # remove \\n from dice result\n            if line is not wm_dice_lines[-1]:\n                <IND>dc = dc[:-1]\n            <DED>if n_slice not in null_slices:\n                <IND>try:\n                    <IND>wm_dice.append(float(dc))\n                <DED>except ValueError:\n                    <IND>wm_dice.append(float(dc[:-4]))\n        <DED><DED><DED>result_dice_wm = mean(wm_dice)\n\n        # Extracting hausdorff distance results\n        hd = open(hausdorff_fname, 'r')\n        hd_lines = hd.readlines()\n        hd.close()\n\n        # remove title of columns and last empty/non important lines\n        hd_lines = hd_lines[1:-4]\n\n        hausdorff = []\n        max_med = []\n        for line in hd_lines:\n            <IND>slice_id, res = line.split(':')\n            slice, n_slice = slice_id.split(' ')\n            if n_slice not in null_slices:\n                <IND>hd, med1, med2 = res[:-1].split(' - ')\n                hd, med1, med2 = float(hd), float(med1), float(med2)\n                hausdorff.append(hd)\n                max_med.append(max(med1, med2))\n\n        <DED><DED>result_hausdorff = mean(hausdorff)\n        result_median_dist = mean(max_med)\n\n        # Integrity check\n        hd_threshold = 3 # in mm\n        wm_dice_threshold = 0.8\n        if result_hausdorff > hd_threshold or result_dice_wm < wm_dice_threshold:\n            <IND>status = 99\n            output += '\\nResulting segmentation is too different from manual segmentation:\\n'                      'WM dice: '+str(result_dice_wm)+'\\n'                      'Hausdorff distance: '+str(result_hausdorff)+'\\n'\n\n    # transform results into Pandas structure\n    <DED><DED>results = DataFrame(data={'status': status, 'output': output, 'dice_gm': result_dice_gm, 'dice_wm': result_dice_wm, 'hausdorff': result_hausdorff, 'med_dist': result_median_dist, 'duration_[s]': duration}, index=[path_data])\n\n    return status, output, results\n\n\n<DED>if __name__ == \"__main__\":\n    # call main function\n    <IND>test(path_sct+'/data')\n",
        "target_code_with_indent": "    result_dice_gm, result_dice_wm, result_hausdorff, result_median_dist = float('nan'), float('nan'), float('nan'), float('nan')\n\n    target_name = sct.extract_fname(param_test.file_input)[1]\n\n    dice_fname = param_test.path_output + 'dice_coefficient_' + target_name + '.txt'\n    hausdorff_fname = param_test.path_output + 'hausdorff_dist_' + target_name + '.txt'\n\n    # Extracting dice results:\n    dice = open(dice_fname, 'r')\n    dice_lines = dice.readlines()\n    dice.close()\n    gm_start = dice_lines.index('Dice coefficient on the Gray Matter segmentation:\\n')\n    wm_start = dice_lines.index('Dice coefficient on the White Matter segmentation:\\n')\n\n    # extracting dice on GM\n    gm_dice_lines = dice_lines[gm_start:wm_start - 1]\n    gm_dice_lines = gm_dice_lines[gm_dice_lines.index('2D Dice coefficient by slice:\\n') + 1:-1]\n\n    null_slices = []\n    gm_dice = []\n    for line in gm_dice_lines:\n        <IND>n_slice, dc = line.split(' ')\n        # remove \\n from dice result\n        dc = dc[:-1]\n        dc = dc[:-4] if '[0m' in dc else dc\n\n        if dc == '0' or dc == 'nan':\n            <IND>null_slices.append(n_slice)\n        <DED>else:\n            <IND>try:\n                <IND>gm_dice.append(float(dc))\n            <DED>except ValueError:\n                <IND>gm_dice.append(float(dc[:-4]))\n    <DED><DED><DED>result_dice_gm = mean(gm_dice)\n\n    # extracting dice on WM\n    wm_dice_lines = dice_lines[wm_start:]\n    wm_dice_lines = wm_dice_lines[wm_dice_lines.index('2D Dice coefficient by slice:\\n') + 1:]\n    wm_dice = []\n    for line in wm_dice_lines:\n        <IND>n_slice, dc = line.split(' ')\n        # remove \\n from dice result\n        if line is not wm_dice_lines[-1]:\n            <IND>dc = dc[:-1]\n        <DED>if n_slice not in null_slices:\n            <IND>try:\n                <IND>wm_dice.append(float(dc))\n            <DED>except ValueError:\n                <IND>wm_dice.append(float(dc[:-4]))\n    <DED><DED><DED>result_dice_wm = mean(wm_dice)\n\n    # Extracting hausdorff distance results\n    hd = open(hausdorff_fname, 'r')\n    hd_lines = hd.readlines()\n    hd.close()\n\n    # remove title of columns and last empty/non important lines\n    hd_lines = hd_lines[1:-4]\n\n    hausdorff = []\n    max_med = []\n    for line in hd_lines:\n        <IND>slice_id, res = line.split(':')\n        slice, n_slice = slice_id.split(' ')\n        if n_slice not in null_slices:\n            <IND>hd, med1, med2 = res[:-1].split(' - ')\n            hd, med1, med2 = float(hd), float(med1), float(med2)\n            hausdorff.append(hd)\n            max_med.append(max(med1, med2))\n\n    <DED><DED>result_hausdorff = mean(hausdorff)\n    result_median_dist = mean(max_med)\n\n    # Integrity check\n    if result_hausdorff > param_test.hd_threshold or result_dice_wm < param_test.wm_dice_threshold:\n        <IND>param_test.status = 99\n        param_test.output += '\\nResulting segmentation is too different from manual segmentation:\\n'                             'WM dice: ' + str(result_dice_wm) + '\\n'                             'Hausdorff distance: ' + str(result_hausdorff) + '\\n'\n\n    # transform results into Pandas structure\n    <DED>results = DataFrame(data={'status': param_test.status, 'output': param_test.output, 'dice_gm': result_dice_gm, 'dice_wm': result_dice_wm,\n                              'hausdorff': result_hausdorff, 'med_dist': result_median_dist, 'duration_[s]': param_test.duration},\n                        index=[param_test.path_data])\n\n    return param_test\n"
      }
    ]
  }
]