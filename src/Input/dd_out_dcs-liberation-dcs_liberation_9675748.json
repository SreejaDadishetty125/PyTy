[
  {
    "project": "dcs-liberation/dcs_liberation",
    "commit": "967574820fbc06b523f60139ad6c00614c1056a3",
    "filename": "game/operation/operation.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/dcs-liberation-dcs_liberation/game/operation/operation.py",
    "file_hunks_size": 2,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "game/operation/operation.py:318:38 Incompatible parameter type [6]: Expected `Operation` for 1st positional only parameter to call `game.plugins.luaplugin.LuaPlugin.inject_scripts` but got `typing.Type[Operation]`.",
    "message": " Expected `Operation` for 1st positional only parameter to call `game.plugins.luaplugin.LuaPlugin.inject_scripts` but got `typing.Type[Operation]`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 318,
    "warning_line": "                plugin.inject_scripts(cls)"
  },
  {
    "project": "dcs-liberation/dcs_liberation",
    "commit": "967574820fbc06b523f60139ad6c00614c1056a3",
    "filename": "game/operation/operation.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/dcs-liberation-dcs_liberation/game/operation/operation.py",
    "file_hunks_size": 2,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "game/operation/operation.py:319:44 Incompatible parameter type [6]: Expected `Operation` for 1st positional only parameter to call `game.plugins.luaplugin.LuaPlugin.inject_configuration` but got `typing.Type[Operation]`.",
    "message": " Expected `Operation` for 1st positional only parameter to call `game.plugins.luaplugin.LuaPlugin.inject_configuration` but got `typing.Type[Operation]`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 319,
    "warning_line": "                plugin.inject_configuration(cls)"
  },
  {
    "project": "dcs-liberation/dcs_liberation",
    "commit": "967574820fbc06b523f60139ad6c00614c1056a3",
    "filename": "game/theater/conflicttheater.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/dcs-liberation-dcs_liberation/game/theater/conflicttheater.py",
    "file_hunks_size": 3,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "game/theater/conflicttheater.py:498:12 Incompatible return type [7]: Expected `Tuple[ControlPoint]` but got `typing.Tuple[ControlPoint, ...]`.",
    "message": " Expected `Tuple[ControlPoint]` but got `typing.Tuple[ControlPoint, ...]`.",
    "rule_id": "Incompatible return type [7]",
    "warning_line_no": 498,
    "warning_line": "            return tuple(closest_opposing_cps)",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "from pathlib import Path\nfrom typing import Any, Dict, Iterator, List, Optional, Tuple, Union\n\n",
        "source_code_len": 95,
        "target_code": "from pathlib import Path\nfrom typing import Any, Dict, Iterator, List, Optional, Tuple, Union, cast\n\n",
        "target_code_len": 101,
        "diff_format": "@@ -9,3 +9,3 @@\n from pathlib import Path\n-from typing import Any, Dict, Iterator, List, Optional, Tuple, Union\n+from typing import Any, Dict, Iterator, List, Optional, Tuple, Union, cast\n \n",
        "source_code_with_indent": "from pathlib import Path\nfrom typing import Any, Dict, Iterator, List, Optional, Tuple, Union\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "from pathlib import Path\nfrom typing import Any, Dict, Iterator, List, Optional, Tuple, Union, cast\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    \n    def closest_opposing_control_points(self) -> Tuple[ControlPoint]:\n        \"\"\"\n",
        "source_code_len": 87,
        "target_code": "    \n    def closest_opposing_control_points(self) -> Tuple[ControlPoint, ControlPoint]:\n        \"\"\"\n",
        "target_code_len": 101,
        "diff_format": "@@ -473,3 +473,3 @@\n     \n-    def closest_opposing_control_points(self) -> Tuple[ControlPoint]:\n+    def closest_opposing_control_points(self) -> Tuple[ControlPoint, ControlPoint]:\n         \"\"\"\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "    \n    <DED>def closest_opposing_control_points(self) -> Tuple[ControlPoint]:\n        <IND>",
        "target_code_with_indent": "    \n    <DED>def closest_opposing_control_points(self) -> Tuple[ControlPoint, ControlPoint]:\n        <IND>"
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": true,
        "source_code": "                        distances[cp.id] = dist\n            closest_cp = min(distances, key=distances.get)\n            all_cp_min_distances[(control_point.id, closest_cp)] = distances[closest_cp]\n        closest_opposing_cps = [\n            self.find_control_point_by_id(i)\n            for i \n            in min(all_cp_min_distances, key=all_cp_min_distances.get)\n          ]  # type: List[ControlPoint]\n        if closest_opposing_cps[0].captured:\n            return tuple(closest_opposing_cps)\n        else:\n            return tuple(reversed(closest_opposing_cps))\n\n",
        "source_code_len": 568,
        "target_code": "                        distances[cp.id] = dist\n            closest_cp_id = min(distances, key=distances.get)  # type: ignore\n\n            all_cp_min_distances[(control_point.id, closest_cp_id)] = distances[closest_cp_id]\n        closest_opposing_cps = [\n            self.find_control_point_by_id(i)\n            for i\n            in min(all_cp_min_distances, key=all_cp_min_distances.get)  # type: ignore\n          ]  # type: List[ControlPoint]\n        assert len(closest_opposing_cps) == 2\n        if closest_opposing_cps[0].captured:\n            return cast(Tuple[ControlPoint, ControlPoint], tuple(closest_opposing_cps))\n        else:\n            return cast(Tuple[ControlPoint, ControlPoint], tuple(reversed(closest_opposing_cps)))\n\n",
        "target_code_len": 737,
        "diff_format": "@@ -489,13 +489,15 @@\n                         distances[cp.id] = dist\n-            closest_cp = min(distances, key=distances.get)\n-            all_cp_min_distances[(control_point.id, closest_cp)] = distances[closest_cp]\n+            closest_cp_id = min(distances, key=distances.get)  # type: ignore\n+\n+            all_cp_min_distances[(control_point.id, closest_cp_id)] = distances[closest_cp_id]\n         closest_opposing_cps = [\n             self.find_control_point_by_id(i)\n-            for i \n-            in min(all_cp_min_distances, key=all_cp_min_distances.get)\n+            for i\n+            in min(all_cp_min_distances, key=all_cp_min_distances.get)  # type: ignore\n           ]  # type: List[ControlPoint]\n+        assert len(closest_opposing_cps) == 2\n         if closest_opposing_cps[0].captured:\n-            return tuple(closest_opposing_cps)\n+            return cast(Tuple[ControlPoint, ControlPoint], tuple(closest_opposing_cps))\n         else:\n-            return tuple(reversed(closest_opposing_cps))\n+            return cast(Tuple[ControlPoint, ControlPoint], tuple(reversed(closest_opposing_cps)))\n \n",
        "source_code_with_indent": "                        <IND>distances[cp.id] = dist\n            <DED><DED><DED>closest_cp = min(distances, key=distances.get)\n            all_cp_min_distances[(control_point.id, closest_cp)] = distances[closest_cp]\n        <DED>closest_opposing_cps = [\n            self.find_control_point_by_id(i)\n            for i \n            in min(all_cp_min_distances, key=all_cp_min_distances.get)\n          ]  # type: List[ControlPoint]\n        if closest_opposing_cps[0].captured:\n            <IND>return tuple(closest_opposing_cps)\n        <DED>else:\n            <IND>return tuple(reversed(closest_opposing_cps))\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "                        <IND>distances[cp.id] = dist\n            <DED><DED><DED>closest_cp_id = min(distances, key=distances.get)  # type: ignore\n\n            all_cp_min_distances[(control_point.id, closest_cp_id)] = distances[closest_cp_id]\n        <DED>closest_opposing_cps = [\n            self.find_control_point_by_id(i)\n            for i\n            in min(all_cp_min_distances, key=all_cp_min_distances.get)  # type: ignore\n          ]  # type: List[ControlPoint]\n        assert len(closest_opposing_cps) == 2\n        if closest_opposing_cps[0].captured:\n            <IND>return cast(Tuple[ControlPoint, ControlPoint], tuple(closest_opposing_cps))\n        <DED>else:\n            <IND>return cast(Tuple[ControlPoint, ControlPoint], tuple(reversed(closest_opposing_cps)))\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "dcs-liberation/dcs_liberation",
    "commit": "967574820fbc06b523f60139ad6c00614c1056a3",
    "filename": "game/theater/conflicttheater.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/dcs-liberation-dcs_liberation/game/theater/conflicttheater.py",
    "file_hunks_size": 3,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "game/theater/conflicttheater.py:500:12 Incompatible return type [7]: Expected `Tuple[ControlPoint]` but got `typing.Tuple[ControlPoint, ...]`.",
    "message": " Expected `Tuple[ControlPoint]` but got `typing.Tuple[ControlPoint, ...]`.",
    "rule_id": "Incompatible return type [7]",
    "warning_line_no": 500,
    "warning_line": "            return tuple(reversed(closest_opposing_cps))",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "from pathlib import Path\nfrom typing import Any, Dict, Iterator, List, Optional, Tuple, Union\n\n",
        "source_code_len": 95,
        "target_code": "from pathlib import Path\nfrom typing import Any, Dict, Iterator, List, Optional, Tuple, Union, cast\n\n",
        "target_code_len": 101,
        "diff_format": "@@ -9,3 +9,3 @@\n from pathlib import Path\n-from typing import Any, Dict, Iterator, List, Optional, Tuple, Union\n+from typing import Any, Dict, Iterator, List, Optional, Tuple, Union, cast\n \n",
        "source_code_with_indent": "from pathlib import Path\nfrom typing import Any, Dict, Iterator, List, Optional, Tuple, Union\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "from pathlib import Path\nfrom typing import Any, Dict, Iterator, List, Optional, Tuple, Union, cast\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    \n    def closest_opposing_control_points(self) -> Tuple[ControlPoint]:\n        \"\"\"\n",
        "source_code_len": 87,
        "target_code": "    \n    def closest_opposing_control_points(self) -> Tuple[ControlPoint, ControlPoint]:\n        \"\"\"\n",
        "target_code_len": 101,
        "diff_format": "@@ -473,3 +473,3 @@\n     \n-    def closest_opposing_control_points(self) -> Tuple[ControlPoint]:\n+    def closest_opposing_control_points(self) -> Tuple[ControlPoint, ControlPoint]:\n         \"\"\"\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "    \n    <DED>def closest_opposing_control_points(self) -> Tuple[ControlPoint]:\n        <IND>",
        "target_code_with_indent": "    \n    <DED>def closest_opposing_control_points(self) -> Tuple[ControlPoint, ControlPoint]:\n        <IND>"
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": true,
        "source_code": "                        distances[cp.id] = dist\n            closest_cp = min(distances, key=distances.get)\n            all_cp_min_distances[(control_point.id, closest_cp)] = distances[closest_cp]\n        closest_opposing_cps = [\n            self.find_control_point_by_id(i)\n            for i \n            in min(all_cp_min_distances, key=all_cp_min_distances.get)\n          ]  # type: List[ControlPoint]\n        if closest_opposing_cps[0].captured:\n            return tuple(closest_opposing_cps)\n        else:\n            return tuple(reversed(closest_opposing_cps))\n\n",
        "source_code_len": 568,
        "target_code": "                        distances[cp.id] = dist\n            closest_cp_id = min(distances, key=distances.get)  # type: ignore\n\n            all_cp_min_distances[(control_point.id, closest_cp_id)] = distances[closest_cp_id]\n        closest_opposing_cps = [\n            self.find_control_point_by_id(i)\n            for i\n            in min(all_cp_min_distances, key=all_cp_min_distances.get)  # type: ignore\n          ]  # type: List[ControlPoint]\n        assert len(closest_opposing_cps) == 2\n        if closest_opposing_cps[0].captured:\n            return cast(Tuple[ControlPoint, ControlPoint], tuple(closest_opposing_cps))\n        else:\n            return cast(Tuple[ControlPoint, ControlPoint], tuple(reversed(closest_opposing_cps)))\n\n",
        "target_code_len": 737,
        "diff_format": "@@ -489,13 +489,15 @@\n                         distances[cp.id] = dist\n-            closest_cp = min(distances, key=distances.get)\n-            all_cp_min_distances[(control_point.id, closest_cp)] = distances[closest_cp]\n+            closest_cp_id = min(distances, key=distances.get)  # type: ignore\n+\n+            all_cp_min_distances[(control_point.id, closest_cp_id)] = distances[closest_cp_id]\n         closest_opposing_cps = [\n             self.find_control_point_by_id(i)\n-            for i \n-            in min(all_cp_min_distances, key=all_cp_min_distances.get)\n+            for i\n+            in min(all_cp_min_distances, key=all_cp_min_distances.get)  # type: ignore\n           ]  # type: List[ControlPoint]\n+        assert len(closest_opposing_cps) == 2\n         if closest_opposing_cps[0].captured:\n-            return tuple(closest_opposing_cps)\n+            return cast(Tuple[ControlPoint, ControlPoint], tuple(closest_opposing_cps))\n         else:\n-            return tuple(reversed(closest_opposing_cps))\n+            return cast(Tuple[ControlPoint, ControlPoint], tuple(reversed(closest_opposing_cps)))\n \n",
        "source_code_with_indent": "                        <IND>distances[cp.id] = dist\n            <DED><DED><DED>closest_cp = min(distances, key=distances.get)\n            all_cp_min_distances[(control_point.id, closest_cp)] = distances[closest_cp]\n        <DED>closest_opposing_cps = [\n            self.find_control_point_by_id(i)\n            for i \n            in min(all_cp_min_distances, key=all_cp_min_distances.get)\n          ]  # type: List[ControlPoint]\n        if closest_opposing_cps[0].captured:\n            <IND>return tuple(closest_opposing_cps)\n        <DED>else:\n            <IND>return tuple(reversed(closest_opposing_cps))\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "                        <IND>distances[cp.id] = dist\n            <DED><DED><DED>closest_cp_id = min(distances, key=distances.get)  # type: ignore\n\n            all_cp_min_distances[(control_point.id, closest_cp_id)] = distances[closest_cp_id]\n        <DED>closest_opposing_cps = [\n            self.find_control_point_by_id(i)\n            for i\n            in min(all_cp_min_distances, key=all_cp_min_distances.get)  # type: ignore\n          ]  # type: List[ControlPoint]\n        assert len(closest_opposing_cps) == 2\n        if closest_opposing_cps[0].captured:\n            <IND>return cast(Tuple[ControlPoint, ControlPoint], tuple(closest_opposing_cps))\n        <DED>else:\n            <IND>return cast(Tuple[ControlPoint, ControlPoint], tuple(reversed(closest_opposing_cps)))\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  }
]