[
  {
    "project": "tensortrade-org/tensortrade",
    "commit": "6612114dbf2b024b8dbf43497c01acc435f75a05",
    "filename": "tensortrade/actions/managed_risk_orders.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/tensortrade-org-tensortrade/tensortrade/actions/managed_risk_orders.py",
    "file_hunks_size": 6,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "tensortrade/actions/managed_risk_orders.py:36:17 Incompatible variable type [9]: ttl_in_seconds is declared to have type `int` but is used as type `None`.",
    "message": " ttl_in_seconds is declared to have type `int` but is used as type `None`.",
    "rule_id": "Incompatible variable type [9]",
    "warning_line_no": 36,
    "warning_line": "                 ttl_in_seconds: int = None,"
  },
  {
    "project": "tensortrade-org/tensortrade",
    "commit": "6612114dbf2b024b8dbf43497c01acc435f75a05",
    "filename": "tensortrade/actions/managed_risk_orders.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/tensortrade-org-tensortrade/tensortrade/actions/managed_risk_orders.py",
    "file_hunks_size": 6,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "tensortrade/actions/managed_risk_orders.py:37:17 Incompatible variable type [9]: ttl_in_steps is declared to have type `int` but is used as type `None`.",
    "message": " ttl_in_steps is declared to have type `int` but is used as type `None`.",
    "rule_id": "Incompatible variable type [9]",
    "warning_line_no": 37,
    "warning_line": "                 ttl_in_steps: int = None,"
  },
  {
    "project": "tensortrade-org/tensortrade",
    "commit": "6612114dbf2b024b8dbf43497c01acc435f75a05",
    "filename": "tensortrade/actions/managed_risk_orders.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/tensortrade-org-tensortrade/tensortrade/actions/managed_risk_orders.py",
    "file_hunks_size": 6,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "tensortrade/actions/managed_risk_orders.py:139:12 Incompatible return type [7]: Expected `tensortrade.orders.order.Order` but got implicit return value of `None`.",
    "message": " Expected `tensortrade.orders.order.Order` but got implicit return value of `None`.",
    "rule_id": "Incompatible return type [7]",
    "warning_line_no": 139,
    "warning_line": "            order.attach(self._order_listener)",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n    def reset(self):\n",
        "source_code_len": 22,
        "target_code": "\n        return order\n\n    def reset(self):\n",
        "target_code_len": 44,
        "diff_format": "@@ -140,2 +136,4 @@\n \n+        return order\n+\n     def reset(self):\n",
        "source_code_with_indent": "\n    <DED><DED>def reset(self):\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n        <DED>return order\n\n    <DED>def reset(self):\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "tensortrade-org/tensortrade",
    "commit": "6612114dbf2b024b8dbf43497c01acc435f75a05",
    "filename": "tensortrade/instruments/quantity.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/tensortrade-org-tensortrade/tensortrade/instruments/quantity.py",
    "file_hunks_size": 4,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": true,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "tensortrade/instruments/quantity.py:408:38 Unsupported operand [58]: `*` is not supported for operand types `float` and `Union[Quantity, float]`.",
    "message": " `*` is not supported for operand types `float` and `Union[Quantity, float]`.",
    "rule_id": "Unsupported operand [58]",
    "warning_line_no": 408,
    "warning_line": "            price = Price(self.rate * other, self.pair)",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": true,
        "has_suppression": false,
        "source_code": "    def __mul__(self, other: Union['Quantity', float, int]) -> 'Quantity':\n        if isinstance(other, Price):\n            if other.pair.quote != self.instrument:\n                raise IncompatiblePriceQuantityOperation(other.pair.quote, self.instrument)\n            return Quantity(other.pair.base, other.rate * self.size, self.path_id)\n        return Quantity._math_operation(self, other, operator.mul)\n",
        "source_code_len": 406,
        "target_code": "    def __mul__(self, other: Union['Quantity', float, int]) -> 'Quantity':\n        return Quantity._math_operation(self, other, operator.mul)\n",
        "target_code_len": 142,
        "diff_format": "@@ -140,6 +139,2 @@\n     def __mul__(self, other: Union['Quantity', float, int]) -> 'Quantity':\n-        if isinstance(other, Price):\n-            if other.pair.quote != self.instrument:\n-                raise IncompatiblePriceQuantityOperation(other.pair.quote, self.instrument)\n-            return Quantity(other.pair.base, other.rate * self.size, self.path_id)\n         return Quantity._math_operation(self, other, operator.mul)\n",
        "source_code_with_indent": "    <DED>def __mul__(self, other: Union['Quantity', float, int]) -> 'Quantity':\n        <IND>if isinstance(other, Price):\n            <IND>if other.pair.quote != self.instrument:\n                <IND>raise IncompatiblePriceQuantityOperation(other.pair.quote, self.instrument)\n            <DED>return Quantity(other.pair.base, other.rate * self.size, self.path_id)\n        <DED>return Quantity._math_operation(self, other, operator.mul)\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    <DED>def __mul__(self, other: Union['Quantity', float, int]) -> 'Quantity':\n        <IND>return Quantity._math_operation(self, other, operator.mul)\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": true,
        "has_suppression": false,
        "source_code": "        return Quantity.__mul__(self, other)\n\n    def __truediv__(self, other: Union['Quantity', 'Instrument', float, int]) -> Union['Quantity', 'Price']:\n        if isinstance(other, Price):\n            if other.pair.base != self.instrument:\n                raise IncompatiblePriceQuantityOperation(other.pair.quote, self.instrument)\n            return Quantity(other.pair.quote, self.size / other.rate, self.path_id)\n        elif other.__class__.__name__ == \"Instrument\":\n            return Price(self.size, self.instrument / other)\n\n        elif isinstance(other, Quantity):\n            if self.instrument != other.instrument:\n                return Price(self.size / other.size, self.instrument / other.instrument)\n\n        return Quantity._math_operation(self, other, operator.truediv)\n\n",
        "source_code_len": 792,
        "target_code": "        return Quantity.__mul__(self, other)\n\n",
        "target_code_len": 46,
        "diff_format": "@@ -148,16 +143,2 @@\n         return Quantity.__mul__(self, other)\n-\n-    def __truediv__(self, other: Union['Quantity', 'Instrument', float, int]) -> Union['Quantity', 'Price']:\n-        if isinstance(other, Price):\n-            if other.pair.base != self.instrument:\n-                raise IncompatiblePriceQuantityOperation(other.pair.quote, self.instrument)\n-            return Quantity(other.pair.quote, self.size / other.rate, self.path_id)\n-        elif other.__class__.__name__ == \"Instrument\":\n-            return Price(self.size, self.instrument / other)\n-\n-        elif isinstance(other, Quantity):\n-            if self.instrument != other.instrument:\n-                return Price(self.size / other.size, self.instrument / other.instrument)\n-\n-        return Quantity._math_operation(self, other, operator.truediv)\n \n",
        "source_code_with_indent": "        <IND>return Quantity.__mul__(self, other)\n\n    <DED>def __truediv__(self, other: Union['Quantity', 'Instrument', float, int]) -> Union['Quantity', 'Price']:\n        <IND>if isinstance(other, Price):\n            <IND>if other.pair.base != self.instrument:\n                <IND>raise IncompatiblePriceQuantityOperation(other.pair.quote, self.instrument)\n            <DED>return Quantity(other.pair.quote, self.size / other.rate, self.path_id)\n        <DED>elif other.__class__.__name__ == \"Instrument\":\n            <IND>return Price(self.size, self.instrument / other)\n\n        <DED>elif isinstance(other, Quantity):\n            <IND>if self.instrument != other.instrument:\n                <IND>return Price(self.size / other.size, self.instrument / other.instrument)\n\n        <DED><DED>return Quantity._math_operation(self, other, operator.truediv)\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "        <IND>return Quantity.__mul__(self, other)\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": true,
        "has_suppression": false,
        "source_code": "        return str(self)\n\n\nclass Price:\n\n    def __init__(self, rate, pair: 'TradingPair'):\n        self._pair = pair\n\n        if rate < 0:\n            raise InvalidNegativeQuantity(rate)\n        self.rate = rate\n\n    @property\n    def rate(self) -> float:\n        \"\"\"\n        Gets the rate of purchasing 1 unit of the quote instrument in terms of the base\n        instrument.\n\n        Returns:\n            rate : float\n                The rate of exchanging the trading pair in terms of the\n                base instrument.\n        \"\"\"\n        return self._rate\n\n    @rate.setter\n    def rate(self, rate: float):\n        self._rate = rate\n\n    @property\n    def pair(self) -> 'TradingPair':\n        \"\"\"\n        Gets the trading pair associated with rate being stated.\n\n        Returns:\n             pair: TradingPair\n                The trading pair associated with the rate.\n        \"\"\"\n        return self._pair\n\n    def __add__(self, other: Union['Price', float, int]):\n        \"\"\"Adds two PriceType objects together.\n\n        Arguments:\n            other: Union[Price, float, int]\n                The object that is the right argument of the\n                operation.\n\n        Raises:\n            IncompatibleTradingPairException:\n                If (other : Price) and the pairs do not equal each other.\n        \"\"\"\n        price = None\n\n        if isinstance(other, Price):\n            rate = self.rate + other.rate\n            pair = self.pair or other.pair\n\n            if self.pair != other.pair:\n                raise IncompatibleTradingPairOperation(self.pair, other.pair)\n\n            price = Price(rate, pair)\n\n        elif isinstance(other, float) or isinstance(other, int):\n            price = Price(self.rate + other, self.pair)\n\n        elif not isinstance(other, Number):\n            raise InvalidNonNumericQuantity(other)\n\n        return price\n\n    def __radd__(self, other: Union['Price', float, int]):\n        \"\"\"Adds two PriceType objects together.\n\n        Arguments:\n            other: Union[Price, float, int]\n                The object that is the left argument of the\n                operation.\n\n        Raises:\n            IncompatibleTradingPairException:\n                If (other : Price) and the pairs do not equal each other.\n        \"\"\"\n        price = None\n\n        if isinstance(other, Price):\n            rate = other.rate + self.rate\n            pair = self.pair or other.pair\n\n            if self.pair != other.pair:\n                raise IncompatibleTradingPairOperation(self.pair, other.pair)\n\n            price = Price(rate, pair)\n\n        elif isinstance(other, float) or isinstance(other, int):\n            price = Price(other + self.rate, self.pair)\n\n        elif not isinstance(other, Number):\n            raise InvalidNonNumericQuantity(other)\n\n        return price\n\n    def __iadd__(self, other: Union['Price', float, int]):\n        \"\"\"Iteratively add to a Price object.\n\n        Arguments:\n            other: Union[Price, float, int]\n                The object that is the left argument of the\n                operation.\n\n        Raises:\n            IncompatibleTradingPairException:\n                If (other : Price) and the pairs do not equal each other.\n            InvalidNonNumericQuantity:\n                If not (other : Union[Price, Number]).\n        \"\"\"\n\n        if isinstance(other, Price):\n            if self.pair != other.pair:\n                raise IncompatibleTradingPairOperation(self.pair, other.pair)\n\n            self.rate += other.rate\n\n        elif isinstance(other, float) or isinstance(other, int):\n            self.rate += other\n\n        elif not isinstance(other, Number):\n            raise InvalidNonNumericQuantity(other)\n\n        return self\n\n    def __sub__(self, other: Union['Price', float, int]):\n        \"\"\"Subtracts two PriceType objects together.\n\n        Arguments:\n            other: Union[Price, float, int]\n                The object that is the right argument of the\n                operation.\n\n        Raises:\n            IncompatibleTradingPairException:\n                If (other : Price) and the pairs do not equal each other.\n            InvalidNonNumericQuantity:\n                If not (other : Union[Price, Number]).\n        \"\"\"\n        price = None\n\n        if isinstance(other, Price):\n            rate = self.rate - other.rate\n            pair = self.pair or other.pair\n\n            if self.pair != other.pair:\n                raise IncompatibleTradingPairOperation(self.pair, other.pair)\n\n            price = Price(rate, pair)\n\n        elif isinstance(other, float) or isinstance(other, int):\n            price = Price(self.rate - other, self.pair)\n\n        elif not isinstance(other, Number):\n            raise InvalidNonNumericQuantity(other)\n\n        return price\n\n    def __rsub__(self, other: Union['Price', float, int]):\n        \"\"\"Subtracts two PriceType objects together.\n\n        Arguments:\n            other: Union[Price, float, int]\n                The object that is the left argument of the\n                operation.\n\n        Raises:\n            IncompatibleTradingPairException:\n                If (other : Price) and the pairs do not equal each other.\n            InvalidNonNumericQuantity:\n                If not (other : Union[Price, Number]).\n        \"\"\"\n        price = None\n\n        if isinstance(other, Price):\n            rate = other.rate - self.rate\n            pair = self.pair or other.pair\n\n            if self.pair != other.pair:\n                raise IncompatibleTradingPairOperation(self.pair, other.pair)\n\n            price = Price(rate, pair)\n\n        elif isinstance(other, float) or isinstance(other, int):\n            price = Price(other - self.rate, self.pair)\n\n        elif not isinstance(other, Number):\n            raise InvalidNonNumericQuantity(other)\n\n        return price\n\n    def __mul__(self, other: Union['Price', 'Quantity', float, int]):\n        \"\"\"Multiplies two PriceType objects together.\n\n        Arguments:\n            other: Union[Price, float, int]\n                The object that is the right argument of the\n                operation.\n\n        Raises:\n            IncompatibleTradingPairException:\n                If (other : Price) and the pairs do not equal each other.\n            InvalidNonNumericQuantity:\n                If not (other : Union[Price, Number]).\n        \"\"\"\n        price = None\n\n        if isinstance(other, Price):\n            rate = self.rate * other.rate\n            pair = self.pair or other.pair\n\n            if self.pair != other.pair:\n                raise IncompatibleTradingPairOperation(self.pair, other.pair)\n\n            price = Price(rate, pair)\n\n        elif isinstance(other, float) or isinstance(other, int):\n            price = Price(self.rate * other, self.pair)\n\n        elif isinstance(other, Quantity):\n\n            if other.instrument != self.pair.quote:\n                raise IncompatiblePriceQuantityOperation(self.pair.quote, other.instrument)\n\n            return Quantity(self.pair.base, self.rate * other.size, other.path_id)\n\n        elif not isinstance(other, Number):\n            raise InvalidNonNumericQuantity(other)\n\n        return price\n\n    def __rmul__(self, other: Union['Price', 'Quantity', float, int]):\n        \"\"\"Multiplies two PriceType objects together.\n\n        Arguments:\n            other: Union[Price, float, int]\n                The object that is the left argument of the\n                addition operation.\n\n        Raises:\n            IncompatibleTradingPairException:\n                If (other : Price) and the pairs do not equal each other.\n            InvalidNonNumericQuantity:\n                If not (other : Union[Price, Number]).\n        \"\"\"\n        return self.__mul__(other)\n\n    def __truediv__(self, other: Union['Price', float, int]):\n        \"\"\"Divides two PriceType objects together.\n\n        Arguments:\n            other: Union[Price, float, int]\n                The object that is the left argument of the\n                addition operation.\n\n        Raises:\n            IncompatibleTradingPairException:\n                If (other : Price) and the pairs do not equal each other.\n            InvalidNonNumericQuantity:\n                If not (other : Union[Price, Number]).\n        \"\"\"\n        price = None\n\n        if isinstance(other, Price):\n\n            if self.pair.base == other.pair.base and self.pair.quote != other.pair.quote:\n                return Price(self.rate / other.rate, other.pair.quote / self.pair.quote)\n\n            elif self.pair.base != other.pair.base and self.pair.quote == other.pair.quote:\n                return Price(self.rate / other.rate, self.pair.base / other.pair.base)\n\n            elif self.pair.base != other.pair.base and self.pair.quote != other.pair.quote:\n                raise IncompatibleTradingPairOperation(self.pair, other.pair)\n\n            return self.rate / other.rate\n\n        elif isinstance(other, float) or isinstance(other, int):\n            price = Price(self.rate / other, self.pair)\n\n        elif isinstance(other, Quantity):\n            raise IncompatiblePriceQuantityOperation(self, other)\n\n        elif not isinstance(other, Number):\n            raise InvalidNonNumericQuantity(other)\n\n        return price\n\n    def __rtruediv__(self, other: Union['Price', float, int]):\n        \"\"\"Divides two PriceType objects together.\n\n        Arguments:\n            other: Union[Price, float, int]\n                The object that is the left argument of the\n                addition operation.\n\n        Raises:\n            IncompatibleTradingPairException:\n                If (other : Price) and the pairs do not equal each other.\n            InvalidNonNumericQuantity:\n                If not (other : Union[Price, Number]).\n        \"\"\"\n        price = None\n\n        if isinstance(other, float) or isinstance(other, int):\n            price = Price(other / self.rate, self.pair.quote / self.pair.base)\n\n        elif isinstance(other, Quantity):\n            raise IncompatiblePriceQuantityOperation(self, other)\n\n        elif not isinstance(other, Number):\n            raise InvalidNonNumericQuantity(other)\n\n        return price\n\n    def __str__(self):\n        s = \"{0:.\" + str(self.pair.base.precision) + \"f}\" + \" {1}\"\n        s = s.format(self.rate, self.pair)\n        return s\n\n    def __repr__(self):\n        return str(self)\n",
        "source_code_len": 10327,
        "target_code": "        return str(self)\n",
        "target_code_len": 25,
        "diff_format": "@@ -185,327 +166,1 @@\n         return str(self)\n-\n-\n-class Price:\n-\n-    def __init__(self, rate, pair: 'TradingPair'):\n-        self._pair = pair\n-\n-        if rate < 0:\n-            raise InvalidNegativeQuantity(rate)\n-        self.rate = rate\n-\n-    @property\n-    def rate(self) -> float:\n-        \"\"\"\n-        Gets the rate of purchasing 1 unit of the quote instrument in terms of the base\n-        instrument.\n-\n-        Returns:\n-            rate : float\n-                The rate of exchanging the trading pair in terms of the\n-                base instrument.\n-        \"\"\"\n-        return self._rate\n-\n-    @rate.setter\n-    def rate(self, rate: float):\n-        self._rate = rate\n-\n-    @property\n-    def pair(self) -> 'TradingPair':\n-        \"\"\"\n-        Gets the trading pair associated with rate being stated.\n-\n-        Returns:\n-             pair: TradingPair\n-                The trading pair associated with the rate.\n-        \"\"\"\n-        return self._pair\n-\n-    def __add__(self, other: Union['Price', float, int]):\n-        \"\"\"Adds two PriceType objects together.\n-\n-        Arguments:\n-            other: Union[Price, float, int]\n-                The object that is the right argument of the\n-                operation.\n-\n-        Raises:\n-            IncompatibleTradingPairException:\n-                If (other : Price) and the pairs do not equal each other.\n-        \"\"\"\n-        price = None\n-\n-        if isinstance(other, Price):\n-            rate = self.rate + other.rate\n-            pair = self.pair or other.pair\n-\n-            if self.pair != other.pair:\n-                raise IncompatibleTradingPairOperation(self.pair, other.pair)\n-\n-            price = Price(rate, pair)\n-\n-        elif isinstance(other, float) or isinstance(other, int):\n-            price = Price(self.rate + other, self.pair)\n-\n-        elif not isinstance(other, Number):\n-            raise InvalidNonNumericQuantity(other)\n-\n-        return price\n-\n-    def __radd__(self, other: Union['Price', float, int]):\n-        \"\"\"Adds two PriceType objects together.\n-\n-        Arguments:\n-            other: Union[Price, float, int]\n-                The object that is the left argument of the\n-                operation.\n-\n-        Raises:\n-            IncompatibleTradingPairException:\n-                If (other : Price) and the pairs do not equal each other.\n-        \"\"\"\n-        price = None\n-\n-        if isinstance(other, Price):\n-            rate = other.rate + self.rate\n-            pair = self.pair or other.pair\n-\n-            if self.pair != other.pair:\n-                raise IncompatibleTradingPairOperation(self.pair, other.pair)\n-\n-            price = Price(rate, pair)\n-\n-        elif isinstance(other, float) or isinstance(other, int):\n-            price = Price(other + self.rate, self.pair)\n-\n-        elif not isinstance(other, Number):\n-            raise InvalidNonNumericQuantity(other)\n-\n-        return price\n-\n-    def __iadd__(self, other: Union['Price', float, int]):\n-        \"\"\"Iteratively add to a Price object.\n-\n-        Arguments:\n-            other: Union[Price, float, int]\n-                The object that is the left argument of the\n-                operation.\n-\n-        Raises:\n-            IncompatibleTradingPairException:\n-                If (other : Price) and the pairs do not equal each other.\n-            InvalidNonNumericQuantity:\n-                If not (other : Union[Price, Number]).\n-        \"\"\"\n-\n-        if isinstance(other, Price):\n-            if self.pair != other.pair:\n-                raise IncompatibleTradingPairOperation(self.pair, other.pair)\n-\n-            self.rate += other.rate\n-\n-        elif isinstance(other, float) or isinstance(other, int):\n-            self.rate += other\n-\n-        elif not isinstance(other, Number):\n-            raise InvalidNonNumericQuantity(other)\n-\n-        return self\n-\n-    def __sub__(self, other: Union['Price', float, int]):\n-        \"\"\"Subtracts two PriceType objects together.\n-\n-        Arguments:\n-            other: Union[Price, float, int]\n-                The object that is the right argument of the\n-                operation.\n-\n-        Raises:\n-            IncompatibleTradingPairException:\n-                If (other : Price) and the pairs do not equal each other.\n-            InvalidNonNumericQuantity:\n-                If not (other : Union[Price, Number]).\n-        \"\"\"\n-        price = None\n-\n-        if isinstance(other, Price):\n-            rate = self.rate - other.rate\n-            pair = self.pair or other.pair\n-\n-            if self.pair != other.pair:\n-                raise IncompatibleTradingPairOperation(self.pair, other.pair)\n-\n-            price = Price(rate, pair)\n-\n-        elif isinstance(other, float) or isinstance(other, int):\n-            price = Price(self.rate - other, self.pair)\n-\n-        elif not isinstance(other, Number):\n-            raise InvalidNonNumericQuantity(other)\n-\n-        return price\n-\n-    def __rsub__(self, other: Union['Price', float, int]):\n-        \"\"\"Subtracts two PriceType objects together.\n-\n-        Arguments:\n-            other: Union[Price, float, int]\n-                The object that is the left argument of the\n-                operation.\n-\n-        Raises:\n-            IncompatibleTradingPairException:\n-                If (other : Price) and the pairs do not equal each other.\n-            InvalidNonNumericQuantity:\n-                If not (other : Union[Price, Number]).\n-        \"\"\"\n-        price = None\n-\n-        if isinstance(other, Price):\n-            rate = other.rate - self.rate\n-            pair = self.pair or other.pair\n-\n-            if self.pair != other.pair:\n-                raise IncompatibleTradingPairOperation(self.pair, other.pair)\n-\n-            price = Price(rate, pair)\n-\n-        elif isinstance(other, float) or isinstance(other, int):\n-            price = Price(other - self.rate, self.pair)\n-\n-        elif not isinstance(other, Number):\n-            raise InvalidNonNumericQuantity(other)\n-\n-        return price\n-\n-    def __mul__(self, other: Union['Price', 'Quantity', float, int]):\n-        \"\"\"Multiplies two PriceType objects together.\n-\n-        Arguments:\n-            other: Union[Price, float, int]\n-                The object that is the right argument of the\n-                operation.\n-\n-        Raises:\n-            IncompatibleTradingPairException:\n-                If (other : Price) and the pairs do not equal each other.\n-            InvalidNonNumericQuantity:\n-                If not (other : Union[Price, Number]).\n-        \"\"\"\n-        price = None\n-\n-        if isinstance(other, Price):\n-            rate = self.rate * other.rate\n-            pair = self.pair or other.pair\n-\n-            if self.pair != other.pair:\n-                raise IncompatibleTradingPairOperation(self.pair, other.pair)\n-\n-            price = Price(rate, pair)\n-\n-        elif isinstance(other, float) or isinstance(other, int):\n-            price = Price(self.rate * other, self.pair)\n-\n-        elif isinstance(other, Quantity):\n-\n-            if other.instrument != self.pair.quote:\n-                raise IncompatiblePriceQuantityOperation(self.pair.quote, other.instrument)\n-\n-            return Quantity(self.pair.base, self.rate * other.size, other.path_id)\n-\n-        elif not isinstance(other, Number):\n-            raise InvalidNonNumericQuantity(other)\n-\n-        return price\n-\n-    def __rmul__(self, other: Union['Price', 'Quantity', float, int]):\n-        \"\"\"Multiplies two PriceType objects together.\n-\n-        Arguments:\n-            other: Union[Price, float, int]\n-                The object that is the left argument of the\n-                addition operation.\n-\n-        Raises:\n-            IncompatibleTradingPairException:\n-                If (other : Price) and the pairs do not equal each other.\n-            InvalidNonNumericQuantity:\n-                If not (other : Union[Price, Number]).\n-        \"\"\"\n-        return self.__mul__(other)\n-\n-    def __truediv__(self, other: Union['Price', float, int]):\n-        \"\"\"Divides two PriceType objects together.\n-\n-        Arguments:\n-            other: Union[Price, float, int]\n-                The object that is the left argument of the\n-                addition operation.\n-\n-        Raises:\n-            IncompatibleTradingPairException:\n-                If (other : Price) and the pairs do not equal each other.\n-            InvalidNonNumericQuantity:\n-                If not (other : Union[Price, Number]).\n-        \"\"\"\n-        price = None\n-\n-        if isinstance(other, Price):\n-\n-            if self.pair.base == other.pair.base and self.pair.quote != other.pair.quote:\n-                return Price(self.rate / other.rate, other.pair.quote / self.pair.quote)\n-\n-            elif self.pair.base != other.pair.base and self.pair.quote == other.pair.quote:\n-                return Price(self.rate / other.rate, self.pair.base / other.pair.base)\n-\n-            elif self.pair.base != other.pair.base and self.pair.quote != other.pair.quote:\n-                raise IncompatibleTradingPairOperation(self.pair, other.pair)\n-\n-            return self.rate / other.rate\n-\n-        elif isinstance(other, float) or isinstance(other, int):\n-            price = Price(self.rate / other, self.pair)\n-\n-        elif isinstance(other, Quantity):\n-            raise IncompatiblePriceQuantityOperation(self, other)\n-\n-        elif not isinstance(other, Number):\n-            raise InvalidNonNumericQuantity(other)\n-\n-        return price\n-\n-    def __rtruediv__(self, other: Union['Price', float, int]):\n-        \"\"\"Divides two PriceType objects together.\n-\n-        Arguments:\n-            other: Union[Price, float, int]\n-                The object that is the left argument of the\n-                addition operation.\n-\n-        Raises:\n-            IncompatibleTradingPairException:\n-                If (other : Price) and the pairs do not equal each other.\n-            InvalidNonNumericQuantity:\n-                If not (other : Union[Price, Number]).\n-        \"\"\"\n-        price = None\n-\n-        if isinstance(other, float) or isinstance(other, int):\n-            price = Price(other / self.rate, self.pair.quote / self.pair.base)\n-\n-        elif isinstance(other, Quantity):\n-            raise IncompatiblePriceQuantityOperation(self, other)\n-\n-        elif not isinstance(other, Number):\n-            raise InvalidNonNumericQuantity(other)\n-\n-        return price\n-\n-    def __str__(self):\n-        s = \"{0:.\" + str(self.pair.base.precision) + \"f}\" + \" {1}\"\n-        s = s.format(self.rate, self.pair)\n-        return s\n-\n-    def __repr__(self):\n-        return str(self)\n",
        "source_code_with_indent": "        <IND>return str(self)\n\n\n<DED><DED>class Price:\n\n    <IND>def __init__(self, rate, pair: 'TradingPair'):\n        <IND>self._pair = pair\n\n        if rate < 0:\n            <IND>raise InvalidNegativeQuantity(rate)\n        <DED>self.rate = rate\n\n    <DED>@property\n    def rate(self) -> float:\n        <IND>\"\"\"\n        Gets the rate of purchasing 1 unit of the quote instrument in terms of the base\n        instrument.\n\n        Returns:\n            rate : float\n                The rate of exchanging the trading pair in terms of the\n                base instrument.\n        \"\"\"\n        return self._rate\n\n    <DED>@rate.setter\n    def rate(self, rate: float):\n        <IND>self._rate = rate\n\n    <DED>@property\n    def pair(self) -> 'TradingPair':\n        <IND>\"\"\"\n        Gets the trading pair associated with rate being stated.\n\n        Returns:\n             pair: TradingPair\n                The trading pair associated with the rate.\n        \"\"\"\n        return self._pair\n\n    <DED>def __add__(self, other: Union['Price', float, int]):\n        <IND>\"\"\"Adds two PriceType objects together.\n\n        Arguments:\n            other: Union[Price, float, int]\n                The object that is the right argument of the\n                operation.\n\n        Raises:\n            IncompatibleTradingPairException:\n                If (other : Price) and the pairs do not equal each other.\n        \"\"\"\n        price = None\n\n        if isinstance(other, Price):\n            <IND>rate = self.rate + other.rate\n            pair = self.pair or other.pair\n\n            if self.pair != other.pair:\n                <IND>raise IncompatibleTradingPairOperation(self.pair, other.pair)\n\n            <DED>price = Price(rate, pair)\n\n        <DED>elif isinstance(other, float) or isinstance(other, int):\n            <IND>price = Price(self.rate + other, self.pair)\n\n        <DED>elif not isinstance(other, Number):\n            <IND>raise InvalidNonNumericQuantity(other)\n\n        <DED>return price\n\n    <DED>def __radd__(self, other: Union['Price', float, int]):\n        <IND>\"\"\"Adds two PriceType objects together.\n\n        Arguments:\n            other: Union[Price, float, int]\n                The object that is the left argument of the\n                operation.\n\n        Raises:\n            IncompatibleTradingPairException:\n                If (other : Price) and the pairs do not equal each other.\n        \"\"\"\n        price = None\n\n        if isinstance(other, Price):\n            <IND>rate = other.rate + self.rate\n            pair = self.pair or other.pair\n\n            if self.pair != other.pair:\n                <IND>raise IncompatibleTradingPairOperation(self.pair, other.pair)\n\n            <DED>price = Price(rate, pair)\n\n        <DED>elif isinstance(other, float) or isinstance(other, int):\n            <IND>price = Price(other + self.rate, self.pair)\n\n        <DED>elif not isinstance(other, Number):\n            <IND>raise InvalidNonNumericQuantity(other)\n\n        <DED>return price\n\n    <DED>def __iadd__(self, other: Union['Price', float, int]):\n        <IND>\"\"\"Iteratively add to a Price object.\n\n        Arguments:\n            other: Union[Price, float, int]\n                The object that is the left argument of the\n                operation.\n\n        Raises:\n            IncompatibleTradingPairException:\n                If (other : Price) and the pairs do not equal each other.\n            InvalidNonNumericQuantity:\n                If not (other : Union[Price, Number]).\n        \"\"\"\n\n        if isinstance(other, Price):\n            <IND>if self.pair != other.pair:\n                <IND>raise IncompatibleTradingPairOperation(self.pair, other.pair)\n\n            <DED>self.rate += other.rate\n\n        <DED>elif isinstance(other, float) or isinstance(other, int):\n            <IND>self.rate += other\n\n        <DED>elif not isinstance(other, Number):\n            <IND>raise InvalidNonNumericQuantity(other)\n\n        <DED>return self\n\n    <DED>def __sub__(self, other: Union['Price', float, int]):\n        <IND>\"\"\"Subtracts two PriceType objects together.\n\n        Arguments:\n            other: Union[Price, float, int]\n                The object that is the right argument of the\n                operation.\n\n        Raises:\n            IncompatibleTradingPairException:\n                If (other : Price) and the pairs do not equal each other.\n            InvalidNonNumericQuantity:\n                If not (other : Union[Price, Number]).\n        \"\"\"\n        price = None\n\n        if isinstance(other, Price):\n            <IND>rate = self.rate - other.rate\n            pair = self.pair or other.pair\n\n            if self.pair != other.pair:\n                <IND>raise IncompatibleTradingPairOperation(self.pair, other.pair)\n\n            <DED>price = Price(rate, pair)\n\n        <DED>elif isinstance(other, float) or isinstance(other, int):\n            <IND>price = Price(self.rate - other, self.pair)\n\n        <DED>elif not isinstance(other, Number):\n            <IND>raise InvalidNonNumericQuantity(other)\n\n        <DED>return price\n\n    <DED>def __rsub__(self, other: Union['Price', float, int]):\n        <IND>\"\"\"Subtracts two PriceType objects together.\n\n        Arguments:\n            other: Union[Price, float, int]\n                The object that is the left argument of the\n                operation.\n\n        Raises:\n            IncompatibleTradingPairException:\n                If (other : Price) and the pairs do not equal each other.\n            InvalidNonNumericQuantity:\n                If not (other : Union[Price, Number]).\n        \"\"\"\n        price = None\n\n        if isinstance(other, Price):\n            <IND>rate = other.rate - self.rate\n            pair = self.pair or other.pair\n\n            if self.pair != other.pair:\n                <IND>raise IncompatibleTradingPairOperation(self.pair, other.pair)\n\n            <DED>price = Price(rate, pair)\n\n        <DED>elif isinstance(other, float) or isinstance(other, int):\n            <IND>price = Price(other - self.rate, self.pair)\n\n        <DED>elif not isinstance(other, Number):\n            <IND>raise InvalidNonNumericQuantity(other)\n\n        <DED>return price\n\n    <DED>def __mul__(self, other: Union['Price', 'Quantity', float, int]):\n        <IND>\"\"\"Multiplies two PriceType objects together.\n\n        Arguments:\n            other: Union[Price, float, int]\n                The object that is the right argument of the\n                operation.\n\n        Raises:\n            IncompatibleTradingPairException:\n                If (other : Price) and the pairs do not equal each other.\n            InvalidNonNumericQuantity:\n                If not (other : Union[Price, Number]).\n        \"\"\"\n        price = None\n\n        if isinstance(other, Price):\n            <IND>rate = self.rate * other.rate\n            pair = self.pair or other.pair\n\n            if self.pair != other.pair:\n                <IND>raise IncompatibleTradingPairOperation(self.pair, other.pair)\n\n            <DED>price = Price(rate, pair)\n\n        <DED>elif isinstance(other, float) or isinstance(other, int):\n            <IND>price = Price(self.rate * other, self.pair)\n\n        <DED>elif isinstance(other, Quantity):\n\n            <IND>if other.instrument != self.pair.quote:\n                <IND>raise IncompatiblePriceQuantityOperation(self.pair.quote, other.instrument)\n\n            <DED>return Quantity(self.pair.base, self.rate * other.size, other.path_id)\n\n        <DED>elif not isinstance(other, Number):\n            <IND>raise InvalidNonNumericQuantity(other)\n\n        <DED>return price\n\n    <DED>def __rmul__(self, other: Union['Price', 'Quantity', float, int]):\n        <IND>\"\"\"Multiplies two PriceType objects together.\n\n        Arguments:\n            other: Union[Price, float, int]\n                The object that is the left argument of the\n                addition operation.\n\n        Raises:\n            IncompatibleTradingPairException:\n                If (other : Price) and the pairs do not equal each other.\n            InvalidNonNumericQuantity:\n                If not (other : Union[Price, Number]).\n        \"\"\"\n        return self.__mul__(other)\n\n    <DED>def __truediv__(self, other: Union['Price', float, int]):\n        <IND>\"\"\"Divides two PriceType objects together.\n\n        Arguments:\n            other: Union[Price, float, int]\n                The object that is the left argument of the\n                addition operation.\n\n        Raises:\n            IncompatibleTradingPairException:\n                If (other : Price) and the pairs do not equal each other.\n            InvalidNonNumericQuantity:\n                If not (other : Union[Price, Number]).\n        \"\"\"\n        price = None\n\n        if isinstance(other, Price):\n\n            <IND>if self.pair.base == other.pair.base and self.pair.quote != other.pair.quote:\n                <IND>return Price(self.rate / other.rate, other.pair.quote / self.pair.quote)\n\n            <DED>elif self.pair.base != other.pair.base and self.pair.quote == other.pair.quote:\n                <IND>return Price(self.rate / other.rate, self.pair.base / other.pair.base)\n\n            <DED>elif self.pair.base != other.pair.base and self.pair.quote != other.pair.quote:\n                <IND>raise IncompatibleTradingPairOperation(self.pair, other.pair)\n\n            <DED>return self.rate / other.rate\n\n        <DED>elif isinstance(other, float) or isinstance(other, int):\n            <IND>price = Price(self.rate / other, self.pair)\n\n        <DED>elif isinstance(other, Quantity):\n            <IND>raise IncompatiblePriceQuantityOperation(self, other)\n\n        <DED>elif not isinstance(other, Number):\n            <IND>raise InvalidNonNumericQuantity(other)\n\n        <DED>return price\n\n    <DED>def __rtruediv__(self, other: Union['Price', float, int]):\n        <IND>\"\"\"Divides two PriceType objects together.\n\n        Arguments:\n            other: Union[Price, float, int]\n                The object that is the left argument of the\n                addition operation.\n\n        Raises:\n            IncompatibleTradingPairException:\n                If (other : Price) and the pairs do not equal each other.\n            InvalidNonNumericQuantity:\n                If not (other : Union[Price, Number]).\n        \"\"\"\n        price = None\n\n        if isinstance(other, float) or isinstance(other, int):\n            <IND>price = Price(other / self.rate, self.pair.quote / self.pair.base)\n\n        <DED>elif isinstance(other, Quantity):\n            <IND>raise IncompatiblePriceQuantityOperation(self, other)\n\n        <DED>elif not isinstance(other, Number):\n            <IND>raise InvalidNonNumericQuantity(other)\n\n        <DED>return price\n\n    <DED>def __str__(self):\n        <IND>s = \"{0:.\" + str(self.pair.base.precision) + \"f}\" + \" {1}\"\n        s = s.format(self.rate, self.pair)\n        return s\n\n    <DED>def __repr__(self):\n        <IND>return str(self)\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "        <IND>return str(self)\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "tensortrade-org/tensortrade",
    "commit": "6612114dbf2b024b8dbf43497c01acc435f75a05",
    "filename": "tensortrade/orders/create.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/tensortrade-org-tensortrade/tensortrade/orders/create.py",
    "file_hunks_size": 8,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "tensortrade/orders/create.py:32:18 Incompatible parameter type [6]: Expected `tensortrade.instruments.quantity.Price` for 5th parameter `price` to call `tensortrade.orders.order.Order.__init__` but got `float`.",
    "message": " Expected `tensortrade.instruments.quantity.Price` for 5th parameter `price` to call `tensortrade.orders.order.Order.__init__` but got `float`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 32,
    "warning_line": "                  price=price,"
  },
  {
    "project": "tensortrade-org/tensortrade",
    "commit": "6612114dbf2b024b8dbf43497c01acc435f75a05",
    "filename": "tensortrade/orders/create.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/tensortrade-org-tensortrade/tensortrade/orders/create.py",
    "file_hunks_size": 8,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "tensortrade/orders/create.py:46:16 Incompatible variable type [9]: ttl_in_seconds is declared to have type `int` but is used as type `None`.",
    "message": " ttl_in_seconds is declared to have type `int` but is used as type `None`.",
    "rule_id": "Incompatible variable type [9]",
    "warning_line_no": 46,
    "warning_line": "                ttl_in_seconds: int = None,"
  },
  {
    "project": "tensortrade-org/tensortrade",
    "commit": "6612114dbf2b024b8dbf43497c01acc435f75a05",
    "filename": "tensortrade/orders/create.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/tensortrade-org-tensortrade/tensortrade/orders/create.py",
    "file_hunks_size": 8,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "tensortrade/orders/create.py:47:16 Incompatible variable type [9]: ttl_in_steps is declared to have type `int` but is used as type `None`.",
    "message": " ttl_in_steps is declared to have type `int` but is used as type `None`.",
    "rule_id": "Incompatible variable type [9]",
    "warning_line_no": 47,
    "warning_line": "                ttl_in_steps: int = None):"
  },
  {
    "project": "tensortrade-org/tensortrade",
    "commit": "6612114dbf2b024b8dbf43497c01acc435f75a05",
    "filename": "tensortrade/orders/create.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/tensortrade-org-tensortrade/tensortrade/orders/create.py",
    "file_hunks_size": 8,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "tensortrade/orders/create.py:53:18 Incompatible parameter type [6]: Expected `tensortrade.instruments.quantity.Price` for 5th parameter `price` to call `tensortrade.orders.order.Order.__init__` but got `float`.",
    "message": " Expected `tensortrade.instruments.quantity.Price` for 5th parameter `price` to call `tensortrade.orders.order.Order.__init__` but got `float`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 53,
    "warning_line": "                  price=price,"
  },
  {
    "project": "tensortrade-org/tensortrade",
    "commit": "6612114dbf2b024b8dbf43497c01acc435f75a05",
    "filename": "tensortrade/orders/create.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/tensortrade-org-tensortrade/tensortrade/orders/create.py",
    "file_hunks_size": 8,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "tensortrade/orders/create.py:69:23 Incompatible variable type [9]: ttl_in_seconds is declared to have type `int` but is used as type `None`.",
    "message": " ttl_in_seconds is declared to have type `int` but is used as type `None`.",
    "rule_id": "Incompatible variable type [9]",
    "warning_line_no": 69,
    "warning_line": "                       ttl_in_seconds: int = None,"
  },
  {
    "project": "tensortrade-org/tensortrade",
    "commit": "6612114dbf2b024b8dbf43497c01acc435f75a05",
    "filename": "tensortrade/orders/create.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/tensortrade-org-tensortrade/tensortrade/orders/create.py",
    "file_hunks_size": 8,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "tensortrade/orders/create.py:70:23 Incompatible variable type [9]: ttl_in_steps is declared to have type `int` but is used as type `None`.",
    "message": " ttl_in_steps is declared to have type `int` but is used as type `None`.",
    "rule_id": "Incompatible variable type [9]",
    "warning_line_no": 70,
    "warning_line": "                       ttl_in_steps: int = None):"
  },
  {
    "project": "tensortrade-org/tensortrade",
    "commit": "6612114dbf2b024b8dbf43497c01acc435f75a05",
    "filename": "tensortrade/orders/create.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/tensortrade-org-tensortrade/tensortrade/orders/create.py",
    "file_hunks_size": 8,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "tensortrade/orders/create.py:76:18 Incompatible parameter type [6]: Expected `tensortrade.instruments.quantity.Price` for 5th parameter `price` to call `tensortrade.orders.order.Order.__init__` but got `float`.",
    "message": " Expected `tensortrade.instruments.quantity.Price` for 5th parameter `price` to call `tensortrade.orders.order.Order.__init__` but got `float`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 76,
    "warning_line": "                  price=price,"
  },
  {
    "project": "tensortrade-org/tensortrade",
    "commit": "6612114dbf2b024b8dbf43497c01acc435f75a05",
    "filename": "tensortrade/orders/create.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/tensortrade-org-tensortrade/tensortrade/orders/create.py",
    "file_hunks_size": 8,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "tensortrade/orders/create.py:96:23 Incompatible variable type [9]: ttl_in_seconds is declared to have type `int` but is used as type `None`.",
    "message": " ttl_in_seconds is declared to have type `int` but is used as type `None`.",
    "rule_id": "Incompatible variable type [9]",
    "warning_line_no": 96,
    "warning_line": "                       ttl_in_seconds: int = None,"
  },
  {
    "project": "tensortrade-org/tensortrade",
    "commit": "6612114dbf2b024b8dbf43497c01acc435f75a05",
    "filename": "tensortrade/orders/create.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/tensortrade-org-tensortrade/tensortrade/orders/create.py",
    "file_hunks_size": 8,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "tensortrade/orders/create.py:97:23 Incompatible variable type [9]: ttl_in_steps is declared to have type `int` but is used as type `None`.",
    "message": " ttl_in_steps is declared to have type `int` but is used as type `None`.",
    "rule_id": "Incompatible variable type [9]",
    "warning_line_no": 97,
    "warning_line": "                       ttl_in_steps: int = None):"
  },
  {
    "project": "tensortrade-org/tensortrade",
    "commit": "6612114dbf2b024b8dbf43497c01acc435f75a05",
    "filename": "tensortrade/orders/create.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/tensortrade-org-tensortrade/tensortrade/orders/create.py",
    "file_hunks_size": 8,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "tensortrade/orders/create.py:103:18 Incompatible parameter type [6]: Expected `tensortrade.instruments.quantity.Price` for 5th parameter `price` to call `tensortrade.orders.order.Order.__init__` but got `float`.",
    "message": " Expected `tensortrade.instruments.quantity.Price` for 5th parameter `price` to call `tensortrade.orders.order.Order.__init__` but got `float`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 103,
    "warning_line": "                  price=price,"
  },
  {
    "project": "tensortrade-org/tensortrade",
    "commit": "6612114dbf2b024b8dbf43497c01acc435f75a05",
    "filename": "tensortrade/slippage/random_slippage_model.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/tensortrade-org-tensortrade/tensortrade/exchanges/services/slippage/random_slippage_model.py",
    "file_hunks_size": 1,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "tensortrade/slippage/random_slippage_model.py:31:4 Inconsistent override [14]: `tensortrade.slippage.random_slippage_model.RandomUniformSlippageModel.adjust_trade` overrides method defined in `tensortrade.slippage.slippage_model.SlippageModel` inconsistently. Could not find parameter `Keywords(unknown)` in overriding signature.",
    "message": " `tensortrade.slippage.random_slippage_model.RandomUniformSlippageModel.adjust_trade` overrides method defined in `tensortrade.slippage.slippage_model.SlippageModel` inconsistently. Could not find parameter `Keywords(unknown)` in overriding signature.",
    "rule_id": "Inconsistent override [14]",
    "warning_line_no": 31,
    "warning_line": "    def adjust_trade(self, trade: Trade) -> Trade:"
  },
  {
    "project": "tensortrade-org/tensortrade",
    "commit": "6612114dbf2b024b8dbf43497c01acc435f75a05",
    "filename": "tensortrade/strategies/trading_strategy.py",
    "min_patch_found": false,
    "full_warning_msg": "tensortrade/strategies/trading_strategy.py:75:12 Incompatible variable type [9]: steps is declared to have type `int` but is used as type `None`.",
    "exception": "[Errno 2] No such file or directory: '/home/chowyi/TypeAnnotation_Study/GitHub/tensortrade-org-tensortrade/tensortrade/strategies/trading_strategy.py'",
    "dd_fail": true
  },
  {
    "project": "tensortrade-org/tensortrade",
    "commit": "6612114dbf2b024b8dbf43497c01acc435f75a05",
    "filename": "tensortrade/strategies/trading_strategy.py",
    "min_patch_found": false,
    "full_warning_msg": "tensortrade/strategies/trading_strategy.py:76:12 Incompatible variable type [9]: episodes is declared to have type `int` but is used as type `None`.",
    "exception": "[Errno 2] No such file or directory: '/home/chowyi/TypeAnnotation_Study/GitHub/tensortrade-org-tensortrade/tensortrade/strategies/trading_strategy.py'",
    "dd_fail": true
  },
  {
    "project": "tensortrade-org/tensortrade",
    "commit": "6612114dbf2b024b8dbf43497c01acc435f75a05",
    "filename": "tensortrade/strategies/trading_strategy.py",
    "min_patch_found": false,
    "full_warning_msg": "tensortrade/strategies/trading_strategy.py:77:12 Incompatible variable type [9]: render_mode is declared to have type `str` but is used as type `None`.",
    "exception": "[Errno 2] No such file or directory: '/home/chowyi/TypeAnnotation_Study/GitHub/tensortrade-org-tensortrade/tensortrade/strategies/trading_strategy.py'",
    "dd_fail": true
  },
  {
    "project": "tensortrade-org/tensortrade",
    "commit": "6612114dbf2b024b8dbf43497c01acc435f75a05",
    "filename": "tests/tensortrade/environments/test_bugs.py",
    "min_patch_found": false,
    "full_warning_msg": "tests/tensortrade/environments/test_bugs.py:82:8 Incompatible variable type [9]: specifications is declared to have type `List[typing.Tuple[typing.Any, ...]]` but is used as type `None`.",
    "exception": "[Errno 2] No such file or directory: '/home/chowyi/TypeAnnotation_Study/GitHub/tensortrade-org-tensortrade/tests/tensortrade/environments/test_bugs.py'",
    "dd_fail": true
  },
  {
    "project": "tensortrade-org/tensortrade",
    "commit": "6612114dbf2b024b8dbf43497c01acc435f75a05",
    "filename": "tests/tensortrade/environments/test_bugs.py",
    "min_patch_found": false,
    "full_warning_msg": "tests/tensortrade/environments/test_bugs.py:83:8 Incompatible variable type [9]: window_size is declared to have type `int` but is used as type `None`.",
    "exception": "[Errno 2] No such file or directory: '/home/chowyi/TypeAnnotation_Study/GitHub/tensortrade-org-tensortrade/tests/tensortrade/environments/test_bugs.py'",
    "dd_fail": true
  },
  {
    "project": "tensortrade-org/tensortrade",
    "commit": "6612114dbf2b024b8dbf43497c01acc435f75a05",
    "filename": "tests/tensortrade/exchanges/test_exchange.py",
    "min_patch_found": false,
    "full_warning_msg": "tests/tensortrade/exchanges/test_exchange.py:23:4 Inconsistent override [15]: `tests.tensortrade.exchanges.test_exchange.ConcreteExchange.quote_price` overrides method defined in `tensortrade.exchanges.exchange.Exchange` inconsistently. Returned type `float` is not a subtype of the overridden return `tensortrade.instruments.quantity.Price`.",
    "exception": "[Errno 2] No such file or directory: '/home/chowyi/TypeAnnotation_Study/GitHub/tensortrade-org-tensortrade/tests/tensortrade/exchanges/test_exchange.py'",
    "dd_fail": true
  },
  {
    "project": "tensortrade-org/tensortrade",
    "commit": "6612114dbf2b024b8dbf43497c01acc435f75a05",
    "filename": "tests/tensortrade/rewards/test_reward_scheme.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/tensortrade-org-tensortrade/tests/tensortrade/unit/rewards/test_reward_scheme.py",
    "file_hunks_size": 1,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "tests/tensortrade/rewards/test_reward_scheme.py:8:4 Inconsistent override [14]: `tests.tensortrade.rewards.test_reward_scheme.ConcreteRewardScheme.get_reward` overrides method defined in `tensortrade.rewards.reward_scheme.RewardScheme` inconsistently. Could not find parameter `portfolio` in overriding signature.",
    "message": " `tests.tensortrade.rewards.test_reward_scheme.ConcreteRewardScheme.get_reward` overrides method defined in `tensortrade.rewards.reward_scheme.RewardScheme` inconsistently. Could not find parameter `portfolio` in overriding signature.",
    "rule_id": "Inconsistent override [14]",
    "warning_line_no": 8,
    "warning_line": "    def get_reward(self, current_step: int, trade: Trade) -> float:"
  },
  {
    "project": "tensortrade-org/tensortrade",
    "commit": "6612114dbf2b024b8dbf43497c01acc435f75a05",
    "filename": "tests/tensortrade/strategies/test_trading_strategy.py",
    "min_patch_found": false,
    "full_warning_msg": "tests/tensortrade/strategies/test_trading_strategy.py:23:4 Inconsistent override [14]: `tests.tensortrade.strategies.test_trading_strategy.ConcreteTradingStrategy.run` overrides method defined in `tensortrade.strategies.trading_strategy.TradingStrategy` inconsistently. Could not find parameter `evaluation` in overriding signature.",
    "exception": "[Errno 2] No such file or directory: '/home/chowyi/TypeAnnotation_Study/GitHub/tensortrade-org-tensortrade/tests/tensortrade/strategies/test_trading_strategy.py'",
    "dd_fail": true
  },
  {
    "project": "tensortrade-org/tensortrade",
    "commit": "6612114dbf2b024b8dbf43497c01acc435f75a05",
    "filename": "tests/tensortrade/strategies/test_trading_strategy.py",
    "min_patch_found": false,
    "full_warning_msg": "tests/tensortrade/strategies/test_trading_strategy.py:23:4 Inconsistent override [14]: `tests.tensortrade.strategies.test_trading_strategy.ConcreteTradingStrategy.run` overrides method defined in `tensortrade.strategies.trading_strategy.TradingStrategy` inconsistently. Could not find parameter `render_mode` in overriding signature.",
    "exception": "[Errno 2] No such file or directory: '/home/chowyi/TypeAnnotation_Study/GitHub/tensortrade-org-tensortrade/tests/tensortrade/strategies/test_trading_strategy.py'",
    "dd_fail": true
  },
  {
    "project": "tensortrade-org/tensortrade",
    "commit": "6612114dbf2b024b8dbf43497c01acc435f75a05",
    "filename": "tests/tensortrade/strategies/test_trading_strategy.py",
    "min_patch_found": false,
    "full_warning_msg": "tests/tensortrade/strategies/test_trading_strategy.py:23:18 Incompatible variable type [9]: steps is declared to have type `int` but is used as type `None`.",
    "exception": "[Errno 2] No such file or directory: '/home/chowyi/TypeAnnotation_Study/GitHub/tensortrade-org-tensortrade/tests/tensortrade/strategies/test_trading_strategy.py'",
    "dd_fail": true
  },
  {
    "project": "tensortrade-org/tensortrade",
    "commit": "6612114dbf2b024b8dbf43497c01acc435f75a05",
    "filename": "tests/tensortrade/strategies/test_trading_strategy.py",
    "min_patch_found": false,
    "full_warning_msg": "tests/tensortrade/strategies/test_trading_strategy.py:23:37 Incompatible variable type [9]: episodes is declared to have type `int` but is used as type `None`.",
    "exception": "[Errno 2] No such file or directory: '/home/chowyi/TypeAnnotation_Study/GitHub/tensortrade-org-tensortrade/tests/tensortrade/strategies/test_trading_strategy.py'",
    "dd_fail": true
  }
]