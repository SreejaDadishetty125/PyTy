[
  {
    "project": "pantsbuild/pants",
    "commit": "99c2a50bf0b70732aa6c0aae9b74db0969ff4f6f",
    "filename": "src/python/pants/engine/build_files.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/pantsbuild-pants/src/python/pants/engine/build_files.py",
    "file_hunks_size": 12,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "src/python/pants/engine/build_files.py:38:16 Invalid type [31]: Expression `pants.util.objects.datatype(\"BuildDirs\", [\"dependencies\"])` is not a valid type.",
    "message": " Expression `pants.util.objects.datatype(\"BuildDirs\", [\"dependencies\"])` is not a valid type.",
    "rule_id": "Invalid type [31]",
    "warning_line_no": 38,
    "warning_line": "class BuildDirs(datatype('BuildDirs', ['dependencies'])):",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\nclass BuildDirs(datatype('BuildDirs', ['dependencies'])):\n  \"\"\"A list of Stat objects for directories containing build files.\"\"\"\n\n\nclass BuildFiles(datatype('BuildFiles', ['files_content'])):\n  \"\"\"The FileContents of BUILD files in some directory\"\"\"\n\n\nclass BuildFileGlobs(datatype('BuildFilesGlobs', ['path_globs'])):\n  \"\"\"A wrapper around PathGlobs that are known to match a build file pattern.\"\"\"\n\n\n@rule(BuildFiles,\n      [SelectProjection(FilesContent, PathGlobs, 'path_globs', BuildFileGlobs)])\ndef build_files(files_content):\n  return BuildFiles(files_content)\n\n\n@rule(BuildFileGlobs, [Select(AddressMapper), Select(Dir)])\ndef buildfile_path_globs_for_dir(address_mapper, directory):\n  patterns = tuple(join(directory.path, p) for p in address_mapper.build_patterns)\n  return BuildFileGlobs(PathGlobs.create('',\n                                         include=patterns,\n                                         exclude=address_mapper.build_ignore_patterns))\n\n\n@rule(AddressFamily, [Select(AddressMapper), Select(Dir), Select(BuildFiles)])\ndef parse_address_family(address_mapper, path, build_files):\n  \"\"\"Given the contents of the build files in one directory, return an AddressFamily.\n\n  The AddressFamily may be empty, but it will not be None.\n  \"\"\"\n  files_content = build_files.files_content.dependencies\n  if not files_content:\n    raise ResolveError('Directory \"{}\" does not contain build files.'.format(path))\n  address_maps = []\n  for filecontent_product in files_content:\n    address_maps.append(AddressMap.parse(filecontent_product.path,\n",
        "source_code_len": 1557,
        "target_code": "\n@rule(AddressFamily, [Select(AddressMapper), Select(Dir)])\ndef parse_address_family(address_mapper, directory):\n  \"\"\"Given an AddressMapper and a directory, return an AddressFamily.\n\n  The AddressFamily may be empty, but it will not be None.\n  \"\"\"\n  patterns = tuple(join(directory.path, p) for p in address_mapper.build_patterns)\n  path_globs = PathGlobs.create('',\n                                include=patterns,\n                                exclude=address_mapper.build_ignore_patterns)\n  files_content = yield Get(FilesContent, PathGlobs, path_globs)\n\n  if not files_content:\n    raise ResolveError('Directory \"{}\" does not contain build files.'.format(directory.path))\n  address_maps = []\n  for filecontent_product in files_content.dependencies:\n    address_maps.append(AddressMap.parse(filecontent_product.path,\n",
        "target_code_len": 824,
        "diff_format": "@@ -37,39 +37,18 @@\n \n-class BuildDirs(datatype('BuildDirs', ['dependencies'])):\n-  \"\"\"A list of Stat objects for directories containing build files.\"\"\"\n-\n-\n-class BuildFiles(datatype('BuildFiles', ['files_content'])):\n-  \"\"\"The FileContents of BUILD files in some directory\"\"\"\n-\n-\n-class BuildFileGlobs(datatype('BuildFilesGlobs', ['path_globs'])):\n-  \"\"\"A wrapper around PathGlobs that are known to match a build file pattern.\"\"\"\n-\n-\n-@rule(BuildFiles,\n-      [SelectProjection(FilesContent, PathGlobs, 'path_globs', BuildFileGlobs)])\n-def build_files(files_content):\n-  return BuildFiles(files_content)\n-\n-\n-@rule(BuildFileGlobs, [Select(AddressMapper), Select(Dir)])\n-def buildfile_path_globs_for_dir(address_mapper, directory):\n+@rule(AddressFamily, [Select(AddressMapper), Select(Dir)])\n+def parse_address_family(address_mapper, directory):\n+  \"\"\"Given an AddressMapper and a directory, return an AddressFamily.\n+\n+  The AddressFamily may be empty, but it will not be None.\n+  \"\"\"\n   patterns = tuple(join(directory.path, p) for p in address_mapper.build_patterns)\n-  return BuildFileGlobs(PathGlobs.create('',\n-                                         include=patterns,\n-                                         exclude=address_mapper.build_ignore_patterns))\n-\n-\n-@rule(AddressFamily, [Select(AddressMapper), Select(Dir), Select(BuildFiles)])\n-def parse_address_family(address_mapper, path, build_files):\n-  \"\"\"Given the contents of the build files in one directory, return an AddressFamily.\n-\n-  The AddressFamily may be empty, but it will not be None.\n-  \"\"\"\n-  files_content = build_files.files_content.dependencies\n+  path_globs = PathGlobs.create('',\n+                                include=patterns,\n+                                exclude=address_mapper.build_ignore_patterns)\n+  files_content = yield Get(FilesContent, PathGlobs, path_globs)\n+\n   if not files_content:\n-    raise ResolveError('Directory \"{}\" does not contain build files.'.format(path))\n+    raise ResolveError('Directory \"{}\" does not contain build files.'.format(directory.path))\n   address_maps = []\n-  for filecontent_product in files_content:\n+  for filecontent_product in files_content.dependencies:\n     address_maps.append(AddressMap.parse(filecontent_product.path,\n",
        "source_code_with_indent": "\n<DED>class BuildDirs(datatype('BuildDirs', ['dependencies'])):\n  <IND>\"\"\"A list of Stat objects for directories containing build files.\"\"\"\n\n\n<DED>class BuildFiles(datatype('BuildFiles', ['files_content'])):\n  <IND>\"\"\"The FileContents of BUILD files in some directory\"\"\"\n\n\n<DED>class BuildFileGlobs(datatype('BuildFilesGlobs', ['path_globs'])):\n  <IND>\"\"\"A wrapper around PathGlobs that are known to match a build file pattern.\"\"\"\n\n\n<DED>@rule(BuildFiles,\n      [SelectProjection(FilesContent, PathGlobs, 'path_globs', BuildFileGlobs)])\ndef build_files(files_content):\n  <IND>return BuildFiles(files_content)\n\n\n<DED>@rule(BuildFileGlobs, [Select(AddressMapper), Select(Dir)])\ndef buildfile_path_globs_for_dir(address_mapper, directory):\n  <IND>patterns = tuple(join(directory.path, p) for p in address_mapper.build_patterns)\n  return BuildFileGlobs(PathGlobs.create('',\n                                         include=patterns,\n                                         exclude=address_mapper.build_ignore_patterns))\n\n\n<DED>@rule(AddressFamily, [Select(AddressMapper), Select(Dir), Select(BuildFiles)])\ndef parse_address_family(address_mapper, path, build_files):\n  <IND>\"\"\"Given the contents of the build files in one directory, return an AddressFamily.\n\n  The AddressFamily may be empty, but it will not be None.\n  \"\"\"\n  files_content = build_files.files_content.dependencies\n  if not files_content:\n    <IND>raise ResolveError('Directory \"{}\" does not contain build files.'.format(path))\n  <DED>address_maps = []\n  for filecontent_product in files_content:\n    <IND>address_maps.append(AddressMap.parse(filecontent_product.path,\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n<DED>@rule(AddressFamily, [Select(AddressMapper), Select(Dir)])\ndef parse_address_family(address_mapper, directory):\n  <IND>\"\"\"Given an AddressMapper and a directory, return an AddressFamily.\n\n  The AddressFamily may be empty, but it will not be None.\n  \"\"\"\n  patterns = tuple(join(directory.path, p) for p in address_mapper.build_patterns)\n  path_globs = PathGlobs.create('',\n                                include=patterns,\n                                exclude=address_mapper.build_ignore_patterns)\n  files_content = yield Get(FilesContent, PathGlobs, path_globs)\n\n  if not files_content:\n    <IND>raise ResolveError('Directory \"{}\" does not contain build files.'.format(directory.path))\n  <DED>address_maps = []\n  for filecontent_product in files_content.dependencies:\n    <IND>address_maps.append(AddressMap.parse(filecontent_product.path,\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n@rule(BuildFileAddresses,\n      [Select(AddressMapper),\n       SelectDependencies(AddressFamily, BuildDirs, field_types=(Dir,)),\n       Select(Specs)])\ndef addresses_from_address_families(address_mapper, address_families, specs):\n  \"\"\"Given a list of AddressFamilies matching a list of Specs, return matching Addresses.\n\n",
        "source_code_len": 322,
        "target_code": "\n@rule(BuildFileAddresses, [Select(AddressMapper), Select(Specs)])\ndef addresses_from_address_families(address_mapper, specs):\n  \"\"\"Given an AddressMapper and list of Specs, return matching BuildFileAddresses.\n\n",
        "target_code_len": 211,
        "diff_format": "@@ -224,8 +202,5 @@\n \n-@rule(BuildFileAddresses,\n-      [Select(AddressMapper),\n-       SelectDependencies(AddressFamily, BuildDirs, field_types=(Dir,)),\n-       Select(Specs)])\n-def addresses_from_address_families(address_mapper, address_families, specs):\n-  \"\"\"Given a list of AddressFamilies matching a list of Specs, return matching Addresses.\n+@rule(BuildFileAddresses, [Select(AddressMapper), Select(Specs)])\n+def addresses_from_address_families(address_mapper, specs):\n+  \"\"\"Given an AddressMapper and list of Specs, return matching BuildFileAddresses.\n \n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\n<DED>@rule(BuildFileAddresses,\n      [Select(AddressMapper),\n       SelectDependencies(AddressFamily, BuildDirs, field_types=(Dir,)),\n       Select(Specs)])\ndef addresses_from_address_families(address_mapper, address_families, specs):\n  <IND>",
        "target_code_with_indent": "\n<DED>@rule(BuildFileAddresses, [Select(AddressMapper), Select(Specs)])\ndef addresses_from_address_families(address_mapper, specs):\n  <IND>"
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n  return BuildFileAddresses(addresses)\n\n\n@rule(BuildDirs, [Select(AddressMapper), Select(Snapshot)])\ndef filter_build_dirs(address_mapper, snapshot):\n  \"\"\"Given a Snapshot matching a build pattern, return parent directories as BuildDirs.\"\"\"\n  dirnames = set(dirname(f.stat.path) for f in snapshot.files)\n  return BuildDirs(tuple(Dir(d) for d in dirnames))\n\n\n@rule(PathGlobs, [Select(AddressMapper), Select(Specs)])\ndef spec_to_globs(address_mapper, specs):\n  \"\"\"Given a Spec object, return a PathGlobs object for the build files that it matches.\n  \"\"\"\n  patterns = set()\n",
        "source_code_len": 572,
        "target_code": "\n  yield BuildFileAddresses(addresses)\n\n\ndef _spec_to_globs(address_mapper, specs):\n  \"\"\"Given a Specs object, return a PathGlobs object for the build files that it matches.\"\"\"\n  patterns = set()\n",
        "target_code_len": 196,
        "diff_format": "@@ -296,16 +275,7 @@\n \n-  return BuildFileAddresses(addresses)\n-\n-\n-@rule(BuildDirs, [Select(AddressMapper), Select(Snapshot)])\n-def filter_build_dirs(address_mapper, snapshot):\n-  \"\"\"Given a Snapshot matching a build pattern, return parent directories as BuildDirs.\"\"\"\n-  dirnames = set(dirname(f.stat.path) for f in snapshot.files)\n-  return BuildDirs(tuple(Dir(d) for d in dirnames))\n-\n-\n-@rule(PathGlobs, [Select(AddressMapper), Select(Specs)])\n-def spec_to_globs(address_mapper, specs):\n-  \"\"\"Given a Spec object, return a PathGlobs object for the build files that it matches.\n-  \"\"\"\n+  yield BuildFileAddresses(addresses)\n+\n+\n+def _spec_to_globs(address_mapper, specs):\n+  \"\"\"Given a Specs object, return a PathGlobs object for the build files that it matches.\"\"\"\n   patterns = set()\n",
        "source_code_with_indent": "\n  <DED><DED>return BuildFileAddresses(addresses)\n\n\n<DED>@rule(BuildDirs, [Select(AddressMapper), Select(Snapshot)])\ndef filter_build_dirs(address_mapper, snapshot):\n  <IND>\"\"\"Given a Snapshot matching a build pattern, return parent directories as BuildDirs.\"\"\"\n  dirnames = set(dirname(f.stat.path) for f in snapshot.files)\n  return BuildDirs(tuple(Dir(d) for d in dirnames))\n\n\n<DED>@rule(PathGlobs, [Select(AddressMapper), Select(Specs)])\ndef spec_to_globs(address_mapper, specs):\n  <IND>\"\"\"Given a Spec object, return a PathGlobs object for the build files that it matches.\n  \"\"\"\n  patterns = set()\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n  <DED><DED>yield BuildFileAddresses(addresses)\n\n\n<DED>def _spec_to_globs(address_mapper, specs):\n  <IND>\"\"\"Given a Specs object, return a PathGlobs object for the build files that it matches.\"\"\"\n  patterns = set()\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": true,
        "has_suppression": false,
        "source_code": "\nBuildFilesCollection = Collection.of(BuildFiles)\n\n\ndef create_graph_rules(address_mapper, symbol_table):\n",
        "source_code_len": 106,
        "target_code": "\ndef create_graph_rules(address_mapper, symbol_table):\n",
        "target_code_len": 55,
        "diff_format": "@@ -342,5 +312,2 @@\n \n-BuildFilesCollection = Collection.of(BuildFiles)\n-\n-\n def create_graph_rules(address_mapper, symbol_table):\n",
        "source_code_with_indent": "\n<DED>BuildFilesCollection = Collection.of(BuildFiles)\n\n\ndef create_graph_rules(address_mapper, symbol_table):\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n<DED>def create_graph_rules(address_mapper, symbol_table):\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "pantsbuild/pants",
    "commit": "99c2a50bf0b70732aa6c0aae9b74db0969ff4f6f",
    "filename": "src/python/pants/engine/build_files.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/pantsbuild-pants/src/python/pants/engine/build_files.py",
    "file_hunks_size": 12,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "src/python/pants/engine/build_files.py:42:17 Invalid type [31]: Expression `pants.util.objects.datatype(\"BuildFiles\", [\"files_content\"])` is not a valid type.",
    "message": " Expression `pants.util.objects.datatype(\"BuildFiles\", [\"files_content\"])` is not a valid type.",
    "rule_id": "Invalid type [31]",
    "warning_line_no": 42,
    "warning_line": "class BuildFiles(datatype('BuildFiles', ['files_content'])):",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\nclass BuildDirs(datatype('BuildDirs', ['dependencies'])):\n  \"\"\"A list of Stat objects for directories containing build files.\"\"\"\n\n\nclass BuildFiles(datatype('BuildFiles', ['files_content'])):\n  \"\"\"The FileContents of BUILD files in some directory\"\"\"\n\n\nclass BuildFileGlobs(datatype('BuildFilesGlobs', ['path_globs'])):\n  \"\"\"A wrapper around PathGlobs that are known to match a build file pattern.\"\"\"\n\n\n@rule(BuildFiles,\n      [SelectProjection(FilesContent, PathGlobs, 'path_globs', BuildFileGlobs)])\ndef build_files(files_content):\n  return BuildFiles(files_content)\n\n\n@rule(BuildFileGlobs, [Select(AddressMapper), Select(Dir)])\ndef buildfile_path_globs_for_dir(address_mapper, directory):\n  patterns = tuple(join(directory.path, p) for p in address_mapper.build_patterns)\n  return BuildFileGlobs(PathGlobs.create('',\n                                         include=patterns,\n                                         exclude=address_mapper.build_ignore_patterns))\n\n\n@rule(AddressFamily, [Select(AddressMapper), Select(Dir), Select(BuildFiles)])\ndef parse_address_family(address_mapper, path, build_files):\n  \"\"\"Given the contents of the build files in one directory, return an AddressFamily.\n\n  The AddressFamily may be empty, but it will not be None.\n  \"\"\"\n  files_content = build_files.files_content.dependencies\n  if not files_content:\n    raise ResolveError('Directory \"{}\" does not contain build files.'.format(path))\n  address_maps = []\n  for filecontent_product in files_content:\n    address_maps.append(AddressMap.parse(filecontent_product.path,\n",
        "source_code_len": 1557,
        "target_code": "\n@rule(AddressFamily, [Select(AddressMapper), Select(Dir)])\ndef parse_address_family(address_mapper, directory):\n  \"\"\"Given an AddressMapper and a directory, return an AddressFamily.\n\n  The AddressFamily may be empty, but it will not be None.\n  \"\"\"\n  patterns = tuple(join(directory.path, p) for p in address_mapper.build_patterns)\n  path_globs = PathGlobs.create('',\n                                include=patterns,\n                                exclude=address_mapper.build_ignore_patterns)\n  files_content = yield Get(FilesContent, PathGlobs, path_globs)\n\n  if not files_content:\n    raise ResolveError('Directory \"{}\" does not contain build files.'.format(directory.path))\n  address_maps = []\n  for filecontent_product in files_content.dependencies:\n    address_maps.append(AddressMap.parse(filecontent_product.path,\n",
        "target_code_len": 824,
        "diff_format": "@@ -37,39 +37,18 @@\n \n-class BuildDirs(datatype('BuildDirs', ['dependencies'])):\n-  \"\"\"A list of Stat objects for directories containing build files.\"\"\"\n-\n-\n-class BuildFiles(datatype('BuildFiles', ['files_content'])):\n-  \"\"\"The FileContents of BUILD files in some directory\"\"\"\n-\n-\n-class BuildFileGlobs(datatype('BuildFilesGlobs', ['path_globs'])):\n-  \"\"\"A wrapper around PathGlobs that are known to match a build file pattern.\"\"\"\n-\n-\n-@rule(BuildFiles,\n-      [SelectProjection(FilesContent, PathGlobs, 'path_globs', BuildFileGlobs)])\n-def build_files(files_content):\n-  return BuildFiles(files_content)\n-\n-\n-@rule(BuildFileGlobs, [Select(AddressMapper), Select(Dir)])\n-def buildfile_path_globs_for_dir(address_mapper, directory):\n+@rule(AddressFamily, [Select(AddressMapper), Select(Dir)])\n+def parse_address_family(address_mapper, directory):\n+  \"\"\"Given an AddressMapper and a directory, return an AddressFamily.\n+\n+  The AddressFamily may be empty, but it will not be None.\n+  \"\"\"\n   patterns = tuple(join(directory.path, p) for p in address_mapper.build_patterns)\n-  return BuildFileGlobs(PathGlobs.create('',\n-                                         include=patterns,\n-                                         exclude=address_mapper.build_ignore_patterns))\n-\n-\n-@rule(AddressFamily, [Select(AddressMapper), Select(Dir), Select(BuildFiles)])\n-def parse_address_family(address_mapper, path, build_files):\n-  \"\"\"Given the contents of the build files in one directory, return an AddressFamily.\n-\n-  The AddressFamily may be empty, but it will not be None.\n-  \"\"\"\n-  files_content = build_files.files_content.dependencies\n+  path_globs = PathGlobs.create('',\n+                                include=patterns,\n+                                exclude=address_mapper.build_ignore_patterns)\n+  files_content = yield Get(FilesContent, PathGlobs, path_globs)\n+\n   if not files_content:\n-    raise ResolveError('Directory \"{}\" does not contain build files.'.format(path))\n+    raise ResolveError('Directory \"{}\" does not contain build files.'.format(directory.path))\n   address_maps = []\n-  for filecontent_product in files_content:\n+  for filecontent_product in files_content.dependencies:\n     address_maps.append(AddressMap.parse(filecontent_product.path,\n",
        "source_code_with_indent": "\n<DED>class BuildDirs(datatype('BuildDirs', ['dependencies'])):\n  <IND>\"\"\"A list of Stat objects for directories containing build files.\"\"\"\n\n\n<DED>class BuildFiles(datatype('BuildFiles', ['files_content'])):\n  <IND>\"\"\"The FileContents of BUILD files in some directory\"\"\"\n\n\n<DED>class BuildFileGlobs(datatype('BuildFilesGlobs', ['path_globs'])):\n  <IND>\"\"\"A wrapper around PathGlobs that are known to match a build file pattern.\"\"\"\n\n\n<DED>@rule(BuildFiles,\n      [SelectProjection(FilesContent, PathGlobs, 'path_globs', BuildFileGlobs)])\ndef build_files(files_content):\n  <IND>return BuildFiles(files_content)\n\n\n<DED>@rule(BuildFileGlobs, [Select(AddressMapper), Select(Dir)])\ndef buildfile_path_globs_for_dir(address_mapper, directory):\n  <IND>patterns = tuple(join(directory.path, p) for p in address_mapper.build_patterns)\n  return BuildFileGlobs(PathGlobs.create('',\n                                         include=patterns,\n                                         exclude=address_mapper.build_ignore_patterns))\n\n\n<DED>@rule(AddressFamily, [Select(AddressMapper), Select(Dir), Select(BuildFiles)])\ndef parse_address_family(address_mapper, path, build_files):\n  <IND>\"\"\"Given the contents of the build files in one directory, return an AddressFamily.\n\n  The AddressFamily may be empty, but it will not be None.\n  \"\"\"\n  files_content = build_files.files_content.dependencies\n  if not files_content:\n    <IND>raise ResolveError('Directory \"{}\" does not contain build files.'.format(path))\n  <DED>address_maps = []\n  for filecontent_product in files_content:\n    <IND>address_maps.append(AddressMap.parse(filecontent_product.path,\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n<DED>@rule(AddressFamily, [Select(AddressMapper), Select(Dir)])\ndef parse_address_family(address_mapper, directory):\n  <IND>\"\"\"Given an AddressMapper and a directory, return an AddressFamily.\n\n  The AddressFamily may be empty, but it will not be None.\n  \"\"\"\n  patterns = tuple(join(directory.path, p) for p in address_mapper.build_patterns)\n  path_globs = PathGlobs.create('',\n                                include=patterns,\n                                exclude=address_mapper.build_ignore_patterns)\n  files_content = yield Get(FilesContent, PathGlobs, path_globs)\n\n  if not files_content:\n    <IND>raise ResolveError('Directory \"{}\" does not contain build files.'.format(directory.path))\n  <DED>address_maps = []\n  for filecontent_product in files_content.dependencies:\n    <IND>address_maps.append(AddressMap.parse(filecontent_product.path,\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n@rule(BuildFileAddresses,\n      [Select(AddressMapper),\n       SelectDependencies(AddressFamily, BuildDirs, field_types=(Dir,)),\n       Select(Specs)])\ndef addresses_from_address_families(address_mapper, address_families, specs):\n  \"\"\"Given a list of AddressFamilies matching a list of Specs, return matching Addresses.\n\n",
        "source_code_len": 322,
        "target_code": "\n@rule(BuildFileAddresses, [Select(AddressMapper), Select(Specs)])\ndef addresses_from_address_families(address_mapper, specs):\n  \"\"\"Given an AddressMapper and list of Specs, return matching BuildFileAddresses.\n\n",
        "target_code_len": 211,
        "diff_format": "@@ -224,8 +202,5 @@\n \n-@rule(BuildFileAddresses,\n-      [Select(AddressMapper),\n-       SelectDependencies(AddressFamily, BuildDirs, field_types=(Dir,)),\n-       Select(Specs)])\n-def addresses_from_address_families(address_mapper, address_families, specs):\n-  \"\"\"Given a list of AddressFamilies matching a list of Specs, return matching Addresses.\n+@rule(BuildFileAddresses, [Select(AddressMapper), Select(Specs)])\n+def addresses_from_address_families(address_mapper, specs):\n+  \"\"\"Given an AddressMapper and list of Specs, return matching BuildFileAddresses.\n \n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\n<DED>@rule(BuildFileAddresses,\n      [Select(AddressMapper),\n       SelectDependencies(AddressFamily, BuildDirs, field_types=(Dir,)),\n       Select(Specs)])\ndef addresses_from_address_families(address_mapper, address_families, specs):\n  <IND>",
        "target_code_with_indent": "\n<DED>@rule(BuildFileAddresses, [Select(AddressMapper), Select(Specs)])\ndef addresses_from_address_families(address_mapper, specs):\n  <IND>"
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n  return BuildFileAddresses(addresses)\n\n\n@rule(BuildDirs, [Select(AddressMapper), Select(Snapshot)])\ndef filter_build_dirs(address_mapper, snapshot):\n  \"\"\"Given a Snapshot matching a build pattern, return parent directories as BuildDirs.\"\"\"\n  dirnames = set(dirname(f.stat.path) for f in snapshot.files)\n  return BuildDirs(tuple(Dir(d) for d in dirnames))\n\n\n@rule(PathGlobs, [Select(AddressMapper), Select(Specs)])\ndef spec_to_globs(address_mapper, specs):\n  \"\"\"Given a Spec object, return a PathGlobs object for the build files that it matches.\n  \"\"\"\n  patterns = set()\n",
        "source_code_len": 572,
        "target_code": "\n  yield BuildFileAddresses(addresses)\n\n\ndef _spec_to_globs(address_mapper, specs):\n  \"\"\"Given a Specs object, return a PathGlobs object for the build files that it matches.\"\"\"\n  patterns = set()\n",
        "target_code_len": 196,
        "diff_format": "@@ -296,16 +275,7 @@\n \n-  return BuildFileAddresses(addresses)\n-\n-\n-@rule(BuildDirs, [Select(AddressMapper), Select(Snapshot)])\n-def filter_build_dirs(address_mapper, snapshot):\n-  \"\"\"Given a Snapshot matching a build pattern, return parent directories as BuildDirs.\"\"\"\n-  dirnames = set(dirname(f.stat.path) for f in snapshot.files)\n-  return BuildDirs(tuple(Dir(d) for d in dirnames))\n-\n-\n-@rule(PathGlobs, [Select(AddressMapper), Select(Specs)])\n-def spec_to_globs(address_mapper, specs):\n-  \"\"\"Given a Spec object, return a PathGlobs object for the build files that it matches.\n-  \"\"\"\n+  yield BuildFileAddresses(addresses)\n+\n+\n+def _spec_to_globs(address_mapper, specs):\n+  \"\"\"Given a Specs object, return a PathGlobs object for the build files that it matches.\"\"\"\n   patterns = set()\n",
        "source_code_with_indent": "\n  <DED><DED>return BuildFileAddresses(addresses)\n\n\n<DED>@rule(BuildDirs, [Select(AddressMapper), Select(Snapshot)])\ndef filter_build_dirs(address_mapper, snapshot):\n  <IND>\"\"\"Given a Snapshot matching a build pattern, return parent directories as BuildDirs.\"\"\"\n  dirnames = set(dirname(f.stat.path) for f in snapshot.files)\n  return BuildDirs(tuple(Dir(d) for d in dirnames))\n\n\n<DED>@rule(PathGlobs, [Select(AddressMapper), Select(Specs)])\ndef spec_to_globs(address_mapper, specs):\n  <IND>\"\"\"Given a Spec object, return a PathGlobs object for the build files that it matches.\n  \"\"\"\n  patterns = set()\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n  <DED><DED>yield BuildFileAddresses(addresses)\n\n\n<DED>def _spec_to_globs(address_mapper, specs):\n  <IND>\"\"\"Given a Specs object, return a PathGlobs object for the build files that it matches.\"\"\"\n  patterns = set()\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": true,
        "has_suppression": false,
        "source_code": "\nBuildFilesCollection = Collection.of(BuildFiles)\n\n\ndef create_graph_rules(address_mapper, symbol_table):\n",
        "source_code_len": 106,
        "target_code": "\ndef create_graph_rules(address_mapper, symbol_table):\n",
        "target_code_len": 55,
        "diff_format": "@@ -342,5 +312,2 @@\n \n-BuildFilesCollection = Collection.of(BuildFiles)\n-\n-\n def create_graph_rules(address_mapper, symbol_table):\n",
        "source_code_with_indent": "\n<DED>BuildFilesCollection = Collection.of(BuildFiles)\n\n\ndef create_graph_rules(address_mapper, symbol_table):\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n<DED>def create_graph_rules(address_mapper, symbol_table):\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "pantsbuild/pants",
    "commit": "99c2a50bf0b70732aa6c0aae9b74db0969ff4f6f",
    "filename": "src/python/pants/engine/build_files.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/pantsbuild-pants/src/python/pants/engine/build_files.py",
    "file_hunks_size": 12,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "src/python/pants/engine/build_files.py:46:21 Invalid type [31]: Expression `pants.util.objects.datatype(\"BuildFilesGlobs\", [\"path_globs\"])` is not a valid type.",
    "message": " Expression `pants.util.objects.datatype(\"BuildFilesGlobs\", [\"path_globs\"])` is not a valid type.",
    "rule_id": "Invalid type [31]",
    "warning_line_no": 46,
    "warning_line": "class BuildFileGlobs(datatype('BuildFilesGlobs', ['path_globs'])):",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\nclass BuildDirs(datatype('BuildDirs', ['dependencies'])):\n  \"\"\"A list of Stat objects for directories containing build files.\"\"\"\n\n\nclass BuildFiles(datatype('BuildFiles', ['files_content'])):\n  \"\"\"The FileContents of BUILD files in some directory\"\"\"\n\n\nclass BuildFileGlobs(datatype('BuildFilesGlobs', ['path_globs'])):\n  \"\"\"A wrapper around PathGlobs that are known to match a build file pattern.\"\"\"\n\n\n@rule(BuildFiles,\n      [SelectProjection(FilesContent, PathGlobs, 'path_globs', BuildFileGlobs)])\ndef build_files(files_content):\n  return BuildFiles(files_content)\n\n\n@rule(BuildFileGlobs, [Select(AddressMapper), Select(Dir)])\ndef buildfile_path_globs_for_dir(address_mapper, directory):\n  patterns = tuple(join(directory.path, p) for p in address_mapper.build_patterns)\n  return BuildFileGlobs(PathGlobs.create('',\n                                         include=patterns,\n                                         exclude=address_mapper.build_ignore_patterns))\n\n\n@rule(AddressFamily, [Select(AddressMapper), Select(Dir), Select(BuildFiles)])\ndef parse_address_family(address_mapper, path, build_files):\n  \"\"\"Given the contents of the build files in one directory, return an AddressFamily.\n\n  The AddressFamily may be empty, but it will not be None.\n  \"\"\"\n  files_content = build_files.files_content.dependencies\n  if not files_content:\n    raise ResolveError('Directory \"{}\" does not contain build files.'.format(path))\n  address_maps = []\n  for filecontent_product in files_content:\n    address_maps.append(AddressMap.parse(filecontent_product.path,\n",
        "source_code_len": 1557,
        "target_code": "\n@rule(AddressFamily, [Select(AddressMapper), Select(Dir)])\ndef parse_address_family(address_mapper, directory):\n  \"\"\"Given an AddressMapper and a directory, return an AddressFamily.\n\n  The AddressFamily may be empty, but it will not be None.\n  \"\"\"\n  patterns = tuple(join(directory.path, p) for p in address_mapper.build_patterns)\n  path_globs = PathGlobs.create('',\n                                include=patterns,\n                                exclude=address_mapper.build_ignore_patterns)\n  files_content = yield Get(FilesContent, PathGlobs, path_globs)\n\n  if not files_content:\n    raise ResolveError('Directory \"{}\" does not contain build files.'.format(directory.path))\n  address_maps = []\n  for filecontent_product in files_content.dependencies:\n    address_maps.append(AddressMap.parse(filecontent_product.path,\n",
        "target_code_len": 824,
        "diff_format": "@@ -37,39 +37,18 @@\n \n-class BuildDirs(datatype('BuildDirs', ['dependencies'])):\n-  \"\"\"A list of Stat objects for directories containing build files.\"\"\"\n-\n-\n-class BuildFiles(datatype('BuildFiles', ['files_content'])):\n-  \"\"\"The FileContents of BUILD files in some directory\"\"\"\n-\n-\n-class BuildFileGlobs(datatype('BuildFilesGlobs', ['path_globs'])):\n-  \"\"\"A wrapper around PathGlobs that are known to match a build file pattern.\"\"\"\n-\n-\n-@rule(BuildFiles,\n-      [SelectProjection(FilesContent, PathGlobs, 'path_globs', BuildFileGlobs)])\n-def build_files(files_content):\n-  return BuildFiles(files_content)\n-\n-\n-@rule(BuildFileGlobs, [Select(AddressMapper), Select(Dir)])\n-def buildfile_path_globs_for_dir(address_mapper, directory):\n+@rule(AddressFamily, [Select(AddressMapper), Select(Dir)])\n+def parse_address_family(address_mapper, directory):\n+  \"\"\"Given an AddressMapper and a directory, return an AddressFamily.\n+\n+  The AddressFamily may be empty, but it will not be None.\n+  \"\"\"\n   patterns = tuple(join(directory.path, p) for p in address_mapper.build_patterns)\n-  return BuildFileGlobs(PathGlobs.create('',\n-                                         include=patterns,\n-                                         exclude=address_mapper.build_ignore_patterns))\n-\n-\n-@rule(AddressFamily, [Select(AddressMapper), Select(Dir), Select(BuildFiles)])\n-def parse_address_family(address_mapper, path, build_files):\n-  \"\"\"Given the contents of the build files in one directory, return an AddressFamily.\n-\n-  The AddressFamily may be empty, but it will not be None.\n-  \"\"\"\n-  files_content = build_files.files_content.dependencies\n+  path_globs = PathGlobs.create('',\n+                                include=patterns,\n+                                exclude=address_mapper.build_ignore_patterns)\n+  files_content = yield Get(FilesContent, PathGlobs, path_globs)\n+\n   if not files_content:\n-    raise ResolveError('Directory \"{}\" does not contain build files.'.format(path))\n+    raise ResolveError('Directory \"{}\" does not contain build files.'.format(directory.path))\n   address_maps = []\n-  for filecontent_product in files_content:\n+  for filecontent_product in files_content.dependencies:\n     address_maps.append(AddressMap.parse(filecontent_product.path,\n",
        "source_code_with_indent": "\n<DED>class BuildDirs(datatype('BuildDirs', ['dependencies'])):\n  <IND>\"\"\"A list of Stat objects for directories containing build files.\"\"\"\n\n\n<DED>class BuildFiles(datatype('BuildFiles', ['files_content'])):\n  <IND>\"\"\"The FileContents of BUILD files in some directory\"\"\"\n\n\n<DED>class BuildFileGlobs(datatype('BuildFilesGlobs', ['path_globs'])):\n  <IND>\"\"\"A wrapper around PathGlobs that are known to match a build file pattern.\"\"\"\n\n\n<DED>@rule(BuildFiles,\n      [SelectProjection(FilesContent, PathGlobs, 'path_globs', BuildFileGlobs)])\ndef build_files(files_content):\n  <IND>return BuildFiles(files_content)\n\n\n<DED>@rule(BuildFileGlobs, [Select(AddressMapper), Select(Dir)])\ndef buildfile_path_globs_for_dir(address_mapper, directory):\n  <IND>patterns = tuple(join(directory.path, p) for p in address_mapper.build_patterns)\n  return BuildFileGlobs(PathGlobs.create('',\n                                         include=patterns,\n                                         exclude=address_mapper.build_ignore_patterns))\n\n\n<DED>@rule(AddressFamily, [Select(AddressMapper), Select(Dir), Select(BuildFiles)])\ndef parse_address_family(address_mapper, path, build_files):\n  <IND>\"\"\"Given the contents of the build files in one directory, return an AddressFamily.\n\n  The AddressFamily may be empty, but it will not be None.\n  \"\"\"\n  files_content = build_files.files_content.dependencies\n  if not files_content:\n    <IND>raise ResolveError('Directory \"{}\" does not contain build files.'.format(path))\n  <DED>address_maps = []\n  for filecontent_product in files_content:\n    <IND>address_maps.append(AddressMap.parse(filecontent_product.path,\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n<DED>@rule(AddressFamily, [Select(AddressMapper), Select(Dir)])\ndef parse_address_family(address_mapper, directory):\n  <IND>\"\"\"Given an AddressMapper and a directory, return an AddressFamily.\n\n  The AddressFamily may be empty, but it will not be None.\n  \"\"\"\n  patterns = tuple(join(directory.path, p) for p in address_mapper.build_patterns)\n  path_globs = PathGlobs.create('',\n                                include=patterns,\n                                exclude=address_mapper.build_ignore_patterns)\n  files_content = yield Get(FilesContent, PathGlobs, path_globs)\n\n  if not files_content:\n    <IND>raise ResolveError('Directory \"{}\" does not contain build files.'.format(directory.path))\n  <DED>address_maps = []\n  for filecontent_product in files_content.dependencies:\n    <IND>address_maps.append(AddressMap.parse(filecontent_product.path,\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n@rule(BuildFileAddresses,\n      [Select(AddressMapper),\n       SelectDependencies(AddressFamily, BuildDirs, field_types=(Dir,)),\n       Select(Specs)])\ndef addresses_from_address_families(address_mapper, address_families, specs):\n  \"\"\"Given a list of AddressFamilies matching a list of Specs, return matching Addresses.\n\n",
        "source_code_len": 322,
        "target_code": "\n@rule(BuildFileAddresses, [Select(AddressMapper), Select(Specs)])\ndef addresses_from_address_families(address_mapper, specs):\n  \"\"\"Given an AddressMapper and list of Specs, return matching BuildFileAddresses.\n\n",
        "target_code_len": 211,
        "diff_format": "@@ -224,8 +202,5 @@\n \n-@rule(BuildFileAddresses,\n-      [Select(AddressMapper),\n-       SelectDependencies(AddressFamily, BuildDirs, field_types=(Dir,)),\n-       Select(Specs)])\n-def addresses_from_address_families(address_mapper, address_families, specs):\n-  \"\"\"Given a list of AddressFamilies matching a list of Specs, return matching Addresses.\n+@rule(BuildFileAddresses, [Select(AddressMapper), Select(Specs)])\n+def addresses_from_address_families(address_mapper, specs):\n+  \"\"\"Given an AddressMapper and list of Specs, return matching BuildFileAddresses.\n \n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\n<DED>@rule(BuildFileAddresses,\n      [Select(AddressMapper),\n       SelectDependencies(AddressFamily, BuildDirs, field_types=(Dir,)),\n       Select(Specs)])\ndef addresses_from_address_families(address_mapper, address_families, specs):\n  <IND>",
        "target_code_with_indent": "\n<DED>@rule(BuildFileAddresses, [Select(AddressMapper), Select(Specs)])\ndef addresses_from_address_families(address_mapper, specs):\n  <IND>"
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n  return BuildFileAddresses(addresses)\n\n\n@rule(BuildDirs, [Select(AddressMapper), Select(Snapshot)])\ndef filter_build_dirs(address_mapper, snapshot):\n  \"\"\"Given a Snapshot matching a build pattern, return parent directories as BuildDirs.\"\"\"\n  dirnames = set(dirname(f.stat.path) for f in snapshot.files)\n  return BuildDirs(tuple(Dir(d) for d in dirnames))\n\n\n@rule(PathGlobs, [Select(AddressMapper), Select(Specs)])\ndef spec_to_globs(address_mapper, specs):\n  \"\"\"Given a Spec object, return a PathGlobs object for the build files that it matches.\n  \"\"\"\n  patterns = set()\n",
        "source_code_len": 572,
        "target_code": "\n  yield BuildFileAddresses(addresses)\n\n\ndef _spec_to_globs(address_mapper, specs):\n  \"\"\"Given a Specs object, return a PathGlobs object for the build files that it matches.\"\"\"\n  patterns = set()\n",
        "target_code_len": 196,
        "diff_format": "@@ -296,16 +275,7 @@\n \n-  return BuildFileAddresses(addresses)\n-\n-\n-@rule(BuildDirs, [Select(AddressMapper), Select(Snapshot)])\n-def filter_build_dirs(address_mapper, snapshot):\n-  \"\"\"Given a Snapshot matching a build pattern, return parent directories as BuildDirs.\"\"\"\n-  dirnames = set(dirname(f.stat.path) for f in snapshot.files)\n-  return BuildDirs(tuple(Dir(d) for d in dirnames))\n-\n-\n-@rule(PathGlobs, [Select(AddressMapper), Select(Specs)])\n-def spec_to_globs(address_mapper, specs):\n-  \"\"\"Given a Spec object, return a PathGlobs object for the build files that it matches.\n-  \"\"\"\n+  yield BuildFileAddresses(addresses)\n+\n+\n+def _spec_to_globs(address_mapper, specs):\n+  \"\"\"Given a Specs object, return a PathGlobs object for the build files that it matches.\"\"\"\n   patterns = set()\n",
        "source_code_with_indent": "\n  <DED><DED>return BuildFileAddresses(addresses)\n\n\n<DED>@rule(BuildDirs, [Select(AddressMapper), Select(Snapshot)])\ndef filter_build_dirs(address_mapper, snapshot):\n  <IND>\"\"\"Given a Snapshot matching a build pattern, return parent directories as BuildDirs.\"\"\"\n  dirnames = set(dirname(f.stat.path) for f in snapshot.files)\n  return BuildDirs(tuple(Dir(d) for d in dirnames))\n\n\n<DED>@rule(PathGlobs, [Select(AddressMapper), Select(Specs)])\ndef spec_to_globs(address_mapper, specs):\n  <IND>\"\"\"Given a Spec object, return a PathGlobs object for the build files that it matches.\n  \"\"\"\n  patterns = set()\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n  <DED><DED>yield BuildFileAddresses(addresses)\n\n\n<DED>def _spec_to_globs(address_mapper, specs):\n  <IND>\"\"\"Given a Specs object, return a PathGlobs object for the build files that it matches.\"\"\"\n  patterns = set()\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": true,
        "has_suppression": false,
        "source_code": "\nBuildFilesCollection = Collection.of(BuildFiles)\n\n\ndef create_graph_rules(address_mapper, symbol_table):\n",
        "source_code_len": 106,
        "target_code": "\ndef create_graph_rules(address_mapper, symbol_table):\n",
        "target_code_len": 55,
        "diff_format": "@@ -342,5 +312,2 @@\n \n-BuildFilesCollection = Collection.of(BuildFiles)\n-\n-\n def create_graph_rules(address_mapper, symbol_table):\n",
        "source_code_with_indent": "\n<DED>BuildFilesCollection = Collection.of(BuildFiles)\n\n\ndef create_graph_rules(address_mapper, symbol_table):\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n<DED>def create_graph_rules(address_mapper, symbol_table):\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "pantsbuild/pants",
    "commit": "99c2a50bf0b70732aa6c0aae9b74db0969ff4f6f",
    "filename": "tests/python/pants_test/engine/examples/planners.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/pantsbuild-pants/tests/python/pants_test/engine/examples/planners.py",
    "file_hunks_size": 18,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "tests/python/pants_test/engine/examples/planners.py:95:26 Invalid type [31]: Expression `pants.util.objects.datatype(\"ImportedJVMPackages\", [\"dependencies\"])` is not a valid type.",
    "message": " Expression `pants.util.objects.datatype(\"ImportedJVMPackages\", [\"dependencies\"])` is not a valid type.",
    "rule_id": "Invalid type [31]",
    "warning_line_no": 95,
    "warning_line": "class ImportedJVMPackages(datatype('ImportedJVMPackages', ['dependencies'])):"
  }
]