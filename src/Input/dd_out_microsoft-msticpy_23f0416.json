[
  {
    "project": "microsoft/msticpy",
    "commit": "23f0416e8f2b8df83b745e077255859a9bb1b601",
    "filename": "msticpy/nbtools/query_schema.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/microsoft-msticpy/msticpy/nbtools/query_schema.py",
    "file_hunks_size": 4,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": true,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "msticpy/nbtools/query_schema.py:295:24 Incompatible parameter type [6]: Expected `DataEnvironment` for 1st parameter `environment` to call `DataSchema.__init__` but got `str`.",
    "message": " Expected `DataEnvironment` for 1st parameter `environment` to call `DataSchema.__init__` but got `str`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 295,
    "warning_line": "    schema = DataSchema(environment='LogAnalytics',",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": true,
        "has_suppression": false,
        "source_code": "        return list(families)\n\n\nif __name__ == '__main__':\n    # mini test code\n    # pylint: disable=locally-disabled, C0103\n    schema = DataSchema(environment='LogAnalytics',\n                        data_family='WindowsSecurity', data_source='process_create')\n    assert len(schema.data_environments) >= 2\n    assert len(schema.data_families) >= 2\n    assert len(schema.data_source_types) >= 3\n    assert 'table' in schema\n    assert 'query_project' in schema\n    schemas = DataSchema.default_schemas(\n        environment='LogAnalytics', data_family='WindowsSecurity')\n    assert schemas is not None\n    assert len(schemas) >= 3\n    # pylint: enable=locally-disabled, C0103\n",
        "source_code_len": 677,
        "target_code": "        return list(families)\n",
        "target_code_len": 30,
        "diff_format": "@@ -289,18 +292,1 @@\n         return list(families)\n-\n-\n-if __name__ == '__main__':\n-    # mini test code\n-    # pylint: disable=locally-disabled, C0103\n-    schema = DataSchema(environment='LogAnalytics',\n-                        data_family='WindowsSecurity', data_source='process_create')\n-    assert len(schema.data_environments) >= 2\n-    assert len(schema.data_families) >= 2\n-    assert len(schema.data_source_types) >= 3\n-    assert 'table' in schema\n-    assert 'query_project' in schema\n-    schemas = DataSchema.default_schemas(\n-        environment='LogAnalytics', data_family='WindowsSecurity')\n-    assert schemas is not None\n-    assert len(schemas) >= 3\n-    # pylint: enable=locally-disabled, C0103\n",
        "source_code_with_indent": "        <DED><DED>return list(families)\n\n\n<DED><DED>if __name__ == '__main__':\n    # mini test code\n    # pylint: disable=locally-disabled, C0103\n    <IND>schema = DataSchema(environment='LogAnalytics',\n                        data_family='WindowsSecurity', data_source='process_create')\n    assert len(schema.data_environments) >= 2\n    assert len(schema.data_families) >= 2\n    assert len(schema.data_source_types) >= 3\n    assert 'table' in schema\n    assert 'query_project' in schema\n    schemas = DataSchema.default_schemas(\n        environment='LogAnalytics', data_family='WindowsSecurity')\n    assert schemas is not None\n    assert len(schemas) >= 3\n    # pylint: enable=locally-disabled, C0103\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "        <DED><DED>return list(families)\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "microsoft/msticpy",
    "commit": "23f0416e8f2b8df83b745e077255859a9bb1b601",
    "filename": "msticpy/nbtools/query_schema.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/microsoft-msticpy/msticpy/nbtools/query_schema.py",
    "file_hunks_size": 4,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": true,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "msticpy/nbtools/query_schema.py:296:24 Incompatible parameter type [6]: Expected `DataFamily` for 2nd parameter `data_family` to call `DataSchema.__init__` but got `str`.",
    "message": " Expected `DataFamily` for 2nd parameter `data_family` to call `DataSchema.__init__` but got `str`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 296,
    "warning_line": "                        data_family='WindowsSecurity', data_source='process_create')",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": true,
        "has_suppression": false,
        "source_code": "        return list(families)\n\n\nif __name__ == '__main__':\n    # mini test code\n    # pylint: disable=locally-disabled, C0103\n    schema = DataSchema(environment='LogAnalytics',\n                        data_family='WindowsSecurity', data_source='process_create')\n    assert len(schema.data_environments) >= 2\n    assert len(schema.data_families) >= 2\n    assert len(schema.data_source_types) >= 3\n    assert 'table' in schema\n    assert 'query_project' in schema\n    schemas = DataSchema.default_schemas(\n        environment='LogAnalytics', data_family='WindowsSecurity')\n    assert schemas is not None\n    assert len(schemas) >= 3\n    # pylint: enable=locally-disabled, C0103\n",
        "source_code_len": 677,
        "target_code": "        return list(families)\n",
        "target_code_len": 30,
        "diff_format": "@@ -289,18 +292,1 @@\n         return list(families)\n-\n-\n-if __name__ == '__main__':\n-    # mini test code\n-    # pylint: disable=locally-disabled, C0103\n-    schema = DataSchema(environment='LogAnalytics',\n-                        data_family='WindowsSecurity', data_source='process_create')\n-    assert len(schema.data_environments) >= 2\n-    assert len(schema.data_families) >= 2\n-    assert len(schema.data_source_types) >= 3\n-    assert 'table' in schema\n-    assert 'query_project' in schema\n-    schemas = DataSchema.default_schemas(\n-        environment='LogAnalytics', data_family='WindowsSecurity')\n-    assert schemas is not None\n-    assert len(schemas) >= 3\n-    # pylint: enable=locally-disabled, C0103\n",
        "source_code_with_indent": "        <DED><DED>return list(families)\n\n\n<DED><DED>if __name__ == '__main__':\n    # mini test code\n    # pylint: disable=locally-disabled, C0103\n    <IND>schema = DataSchema(environment='LogAnalytics',\n                        data_family='WindowsSecurity', data_source='process_create')\n    assert len(schema.data_environments) >= 2\n    assert len(schema.data_families) >= 2\n    assert len(schema.data_source_types) >= 3\n    assert 'table' in schema\n    assert 'query_project' in schema\n    schemas = DataSchema.default_schemas(\n        environment='LogAnalytics', data_family='WindowsSecurity')\n    assert schemas is not None\n    assert len(schemas) >= 3\n    # pylint: enable=locally-disabled, C0103\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "        <DED><DED>return list(families)\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "microsoft/msticpy",
    "commit": "23f0416e8f2b8df83b745e077255859a9bb1b601",
    "filename": "msticpy/nbtools/utility.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/microsoft-msticpy/msticpy/nbtools/utility.py",
    "file_hunks_size": 9,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "msticpy/nbtools/utility.py:120:4 Incompatible return type [7]: Expected `str` but got `None`.",
    "message": " Expected `str` but got `None`.",
    "rule_id": "Incompatible return type [7]",
    "warning_line_no": 120,
    "warning_line": "    return None",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "import sys\nfrom IPython.core.display import display, HTML\n",
        "source_code_len": 58,
        "target_code": "import sys\nimport warnings\nfrom typing import Callable, Optional, Any\n\nfrom IPython.core.display import display, HTML\n",
        "target_code_len": 118,
        "diff_format": "@@ -8,2 +8,5 @@\n import sys\n+import warnings\n+from typing import Callable, Optional, Any\n+\n from IPython.core.display import display, HTML\n",
        "source_code_with_indent": "import sys\nfrom IPython.core.display import display, HTML\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "import sys\nimport warnings\nfrom typing import Callable, Optional, Any\n\nfrom IPython.core.display import display, HTML\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "@export\ndef get_nb_query_param(nb_url_search: str, param: str) -> str:\n    \"\"\"\n",
        "source_code_len": 79,
        "target_code": "@export\ndef get_nb_query_param(nb_url_search: str, param: str) -> Optional[str]:\n    \"\"\"\n",
        "target_code_len": 89,
        "diff_format": "@@ -103,3 +108,3 @@\n @export\n-def get_nb_query_param(nb_url_search: str, param: str) -> str:\n+def get_nb_query_param(nb_url_search: str, param: str) -> Optional[str]:\n     \"\"\"\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "<DED>@export\ndef get_nb_query_param(nb_url_search: str, param: str) -> str:\n    <IND>",
        "target_code_with_indent": "<DED>@export\ndef get_nb_query_param(nb_url_search: str, param: str) -> Optional[str]:\n    <IND>"
      }
    ]
  },
  {
    "project": "microsoft/msticpy",
    "commit": "23f0416e8f2b8df83b745e077255859a9bb1b601",
    "filename": "msticpy/nbtools/wsconfig.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/microsoft-msticpy/msticpy/nbtools/wsconfig.py",
    "file_hunks_size": 5,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "msticpy/nbtools/wsconfig.py:55:8 Incompatible return type [7]: Expected `typing.Dict[typing.Any, typing.Any]` but got implicit return value of `None`.",
    "message": " Expected `typing.Dict[typing.Any, typing.Any]` but got implicit return value of `None`.",
    "rule_id": "Incompatible return type [7]",
    "warning_line_no": 55,
    "warning_line": "        with open(file_path) as json_file:",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "                return json_config\n",
        "source_code_len": 35,
        "target_code": "                return json_config\n        return {}\n",
        "target_code_len": 53,
        "diff_format": "@@ -58,1 +60,2 @@\n                 return json_config\n+        return {}\n",
        "source_code_with_indent": "                return json_config\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "                return json_config\n        <DED><DED>return {}\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "microsoft/msticpy",
    "commit": "23f0416e8f2b8df83b745e077255859a9bb1b601",
    "filename": "msticpy/sectools/base64unpack.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/microsoft-msticpy/msticpy/sectools/base64unpack.py",
    "file_hunks_size": 14,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "msticpy/sectools/base64unpack.py:203:8 Incompatible return type [7]: Expected `Tuple[str, BinaryRecord]` but got `Tuple[str, None]`.",
    "message": " Expected `Tuple[str, BinaryRecord]` but got `Tuple[str, None]`.",
    "rule_id": "Incompatible return type [7]",
    "warning_line_no": 203,
    "warning_line": "        return b64encoded_string, None",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "import tarfile\nfrom typing import Tuple, Any, Set, Mapping\nimport zipfile\n",
        "source_code_len": 74,
        "target_code": "import tarfile\nfrom typing import Tuple, Any, Set, Mapping, Optional, List, Dict\nimport zipfile\n",
        "target_code_len": 96,
        "diff_format": "@@ -33,3 +33,3 @@\n import tarfile\n-from typing import Tuple, Any, Set, Mapping\n+from typing import Tuple, Any, Set, Mapping, Optional, List, Dict\n import zipfile\n",
        "source_code_with_indent": "import tarfile\nfrom typing import Tuple, Any, Set, Mapping\nimport zipfile\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "import tarfile\nfrom typing import Tuple, Any, Set, Mapping, Optional, List, Dict\nimport zipfile\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "                                  current_depth: int = 1,\n                                  current_index: int = 1) -> Tuple[str, BinaryRecord]:\n    \"\"\"Decode string and return displayable content plus list of decoded artifacts.\"\"\"\n",
        "source_code_len": 232,
        "target_code": "                                  current_depth: int = 1,\n                                  current_index: int = 1) -> Tuple[str,\n                                                                   Optional[List[BinaryRecord]]]:\n    \"\"\"Decode string and return displayable content plus list of decoded artifacts.\"\"\"\n",
        "target_code_len": 315,
        "diff_format": "@@ -195,3 +198,4 @@\n                                   current_depth: int = 1,\n-                                  current_index: int = 1) -> Tuple[str, BinaryRecord]:\n+                                  current_index: int = 1) -> Tuple[str,\n+                                                                   Optional[List[BinaryRecord]]]:\n     \"\"\"Decode string and return displayable content plus list of decoded artifacts.\"\"\"\n",
        "source_code_with_indent": "                                  current_depth: int = 1,\n                                  current_index: int = 1) -> Tuple[str, BinaryRecord]:\n    <IND>\"\"\"Decode string and return displayable content plus list of decoded artifacts.\"\"\"\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "                                  current_depth: int = 1,\n                                  current_index: int = 1) -> Tuple[str,\n                                                                   Optional[List[BinaryRecord]]]:\n    <IND>\"\"\"Decode string and return displayable content plus list of decoded artifacts.\"\"\"\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "@export\ndef get_items_from_gzip(binary: bytes) -> Tuple[str, bytes]:\n    \"\"\"\n",
        "source_code_len": 77,
        "target_code": "@export\ndef get_items_from_gzip(binary: bytes) -> Tuple[str, Mapping[str, bytes]]:\n    \"\"\"\n",
        "target_code_len": 91,
        "diff_format": "@@ -530,3 +535,3 @@\n @export\n-def get_items_from_gzip(binary: bytes) -> Tuple[str, bytes]:\n+def get_items_from_gzip(binary: bytes) -> Tuple[str, Mapping[str, bytes]]:\n     \"\"\"\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "<DED><DED>@export\ndef get_items_from_gzip(binary: bytes) -> Tuple[str, bytes]:\n    <IND>",
        "target_code_with_indent": "<DED>@export\ndef get_items_from_gzip(binary: bytes) -> Tuple[str, Mapping[str, bytes]]:\n    <IND>"
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "        tar_file = tar.extractfile(item)\n        archive_file = tar_file.read()\n        archive_dict[item] = archive_file\n    return 'tar', archive_dict\n",
        "source_code_len": 153,
        "target_code": "        tar_file = tar.extractfile(item)\n        if tar_file:\n            archive_dict[item] = tar_file.read()\n        else:\n            archive_dict[item] = None\n    return 'tar', archive_dict\n",
        "target_code_len": 194,
        "diff_format": "@@ -597,4 +603,6 @@\n         tar_file = tar.extractfile(item)\n-        archive_file = tar_file.read()\n-        archive_dict[item] = archive_file\n+        if tar_file:\n+            archive_dict[item] = tar_file.read()\n+        else:\n+            archive_dict[item] = None\n     return 'tar', archive_dict\n",
        "source_code_with_indent": "        <IND>tar_file = tar.extractfile(item)\n        archive_file = tar_file.read()\n        archive_dict[item] = archive_file\n    <DED>return 'tar', archive_dict\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "        <IND>tar_file = tar.extractfile(item)\n        if tar_file:\n            <IND>archive_dict[item] = tar_file.read()\n        <DED>else:\n            <IND>archive_dict[item] = None\n    <DED><DED>return 'tar', archive_dict\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "microsoft/msticpy",
    "commit": "23f0416e8f2b8df83b745e077255859a9bb1b601",
    "filename": "msticpy/sectools/base64unpack.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/microsoft-msticpy/msticpy/sectools/base64unpack.py",
    "file_hunks_size": 14,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "msticpy/sectools/base64unpack.py:218:12 Incompatible return type [7]: Expected `Tuple[str, BinaryRecord]` but got `Tuple[str, typing.List[typing.Any]]`.",
    "message": " Expected `Tuple[str, BinaryRecord]` but got `Tuple[str, typing.List[typing.Any]]`.",
    "rule_id": "Incompatible return type [7]",
    "warning_line_no": 218,
    "warning_line": "            return display_string, [out_record]",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "import tarfile\nfrom typing import Tuple, Any, Set, Mapping\nimport zipfile\n",
        "source_code_len": 74,
        "target_code": "import tarfile\nfrom typing import Tuple, Any, Set, Mapping, Optional, List, Dict\nimport zipfile\n",
        "target_code_len": 96,
        "diff_format": "@@ -33,3 +33,3 @@\n import tarfile\n-from typing import Tuple, Any, Set, Mapping\n+from typing import Tuple, Any, Set, Mapping, Optional, List, Dict\n import zipfile\n",
        "source_code_with_indent": "import tarfile\nfrom typing import Tuple, Any, Set, Mapping\nimport zipfile\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "import tarfile\nfrom typing import Tuple, Any, Set, Mapping, Optional, List, Dict\nimport zipfile\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "                                  current_depth: int = 1,\n                                  current_index: int = 1) -> Tuple[str, BinaryRecord]:\n    \"\"\"Decode string and return displayable content plus list of decoded artifacts.\"\"\"\n",
        "source_code_len": 232,
        "target_code": "                                  current_depth: int = 1,\n                                  current_index: int = 1) -> Tuple[str,\n                                                                   Optional[List[BinaryRecord]]]:\n    \"\"\"Decode string and return displayable content plus list of decoded artifacts.\"\"\"\n",
        "target_code_len": 315,
        "diff_format": "@@ -195,3 +198,4 @@\n                                   current_depth: int = 1,\n-                                  current_index: int = 1) -> Tuple[str, BinaryRecord]:\n+                                  current_index: int = 1) -> Tuple[str,\n+                                                                   Optional[List[BinaryRecord]]]:\n     \"\"\"Decode string and return displayable content plus list of decoded artifacts.\"\"\"\n",
        "source_code_with_indent": "                                  current_depth: int = 1,\n                                  current_index: int = 1) -> Tuple[str, BinaryRecord]:\n    <IND>\"\"\"Decode string and return displayable content plus list of decoded artifacts.\"\"\"\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "                                  current_depth: int = 1,\n                                  current_index: int = 1) -> Tuple[str,\n                                                                   Optional[List[BinaryRecord]]]:\n    <IND>\"\"\"Decode string and return displayable content plus list of decoded artifacts.\"\"\"\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "@export\ndef get_items_from_gzip(binary: bytes) -> Tuple[str, bytes]:\n    \"\"\"\n",
        "source_code_len": 77,
        "target_code": "@export\ndef get_items_from_gzip(binary: bytes) -> Tuple[str, Mapping[str, bytes]]:\n    \"\"\"\n",
        "target_code_len": 91,
        "diff_format": "@@ -530,3 +535,3 @@\n @export\n-def get_items_from_gzip(binary: bytes) -> Tuple[str, bytes]:\n+def get_items_from_gzip(binary: bytes) -> Tuple[str, Mapping[str, bytes]]:\n     \"\"\"\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "<DED><DED>@export\ndef get_items_from_gzip(binary: bytes) -> Tuple[str, bytes]:\n    <IND>",
        "target_code_with_indent": "<DED>@export\ndef get_items_from_gzip(binary: bytes) -> Tuple[str, Mapping[str, bytes]]:\n    <IND>"
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "        tar_file = tar.extractfile(item)\n        archive_file = tar_file.read()\n        archive_dict[item] = archive_file\n    return 'tar', archive_dict\n",
        "source_code_len": 153,
        "target_code": "        tar_file = tar.extractfile(item)\n        if tar_file:\n            archive_dict[item] = tar_file.read()\n        else:\n            archive_dict[item] = None\n    return 'tar', archive_dict\n",
        "target_code_len": 194,
        "diff_format": "@@ -597,4 +603,6 @@\n         tar_file = tar.extractfile(item)\n-        archive_file = tar_file.read()\n-        archive_dict[item] = archive_file\n+        if tar_file:\n+            archive_dict[item] = tar_file.read()\n+        else:\n+            archive_dict[item] = None\n     return 'tar', archive_dict\n",
        "source_code_with_indent": "        <IND>tar_file = tar.extractfile(item)\n        archive_file = tar_file.read()\n        archive_dict[item] = archive_file\n    <DED>return 'tar', archive_dict\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "        <IND>tar_file = tar.extractfile(item)\n        if tar_file:\n            <IND>archive_dict[item] = tar_file.read()\n        <DED>else:\n            <IND>archive_dict[item] = None\n    <DED><DED>return 'tar', archive_dict\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "microsoft/msticpy",
    "commit": "23f0416e8f2b8df83b745e077255859a9bb1b601",
    "filename": "msticpy/sectools/base64unpack.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/microsoft-msticpy/msticpy/sectools/base64unpack.py",
    "file_hunks_size": 14,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "msticpy/sectools/base64unpack.py:226:12 Incompatible return type [7]: Expected `Tuple[str, BinaryRecord]` but got `Tuple[str, typing.List[typing.Any]]`.",
    "message": " Expected `Tuple[str, BinaryRecord]` but got `Tuple[str, typing.List[typing.Any]]`.",
    "rule_id": "Incompatible return type [7]",
    "warning_line_no": 226,
    "warning_line": "            return display_string, [out_record]",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "import tarfile\nfrom typing import Tuple, Any, Set, Mapping\nimport zipfile\n",
        "source_code_len": 74,
        "target_code": "import tarfile\nfrom typing import Tuple, Any, Set, Mapping, Optional, List, Dict\nimport zipfile\n",
        "target_code_len": 96,
        "diff_format": "@@ -33,3 +33,3 @@\n import tarfile\n-from typing import Tuple, Any, Set, Mapping\n+from typing import Tuple, Any, Set, Mapping, Optional, List, Dict\n import zipfile\n",
        "source_code_with_indent": "import tarfile\nfrom typing import Tuple, Any, Set, Mapping\nimport zipfile\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "import tarfile\nfrom typing import Tuple, Any, Set, Mapping, Optional, List, Dict\nimport zipfile\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "                                  current_depth: int = 1,\n                                  current_index: int = 1) -> Tuple[str, BinaryRecord]:\n    \"\"\"Decode string and return displayable content plus list of decoded artifacts.\"\"\"\n",
        "source_code_len": 232,
        "target_code": "                                  current_depth: int = 1,\n                                  current_index: int = 1) -> Tuple[str,\n                                                                   Optional[List[BinaryRecord]]]:\n    \"\"\"Decode string and return displayable content plus list of decoded artifacts.\"\"\"\n",
        "target_code_len": 315,
        "diff_format": "@@ -195,3 +198,4 @@\n                                   current_depth: int = 1,\n-                                  current_index: int = 1) -> Tuple[str, BinaryRecord]:\n+                                  current_index: int = 1) -> Tuple[str,\n+                                                                   Optional[List[BinaryRecord]]]:\n     \"\"\"Decode string and return displayable content plus list of decoded artifacts.\"\"\"\n",
        "source_code_with_indent": "                                  current_depth: int = 1,\n                                  current_index: int = 1) -> Tuple[str, BinaryRecord]:\n    <IND>\"\"\"Decode string and return displayable content plus list of decoded artifacts.\"\"\"\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "                                  current_depth: int = 1,\n                                  current_index: int = 1) -> Tuple[str,\n                                                                   Optional[List[BinaryRecord]]]:\n    <IND>\"\"\"Decode string and return displayable content plus list of decoded artifacts.\"\"\"\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "@export\ndef get_items_from_gzip(binary: bytes) -> Tuple[str, bytes]:\n    \"\"\"\n",
        "source_code_len": 77,
        "target_code": "@export\ndef get_items_from_gzip(binary: bytes) -> Tuple[str, Mapping[str, bytes]]:\n    \"\"\"\n",
        "target_code_len": 91,
        "diff_format": "@@ -530,3 +535,3 @@\n @export\n-def get_items_from_gzip(binary: bytes) -> Tuple[str, bytes]:\n+def get_items_from_gzip(binary: bytes) -> Tuple[str, Mapping[str, bytes]]:\n     \"\"\"\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "<DED><DED>@export\ndef get_items_from_gzip(binary: bytes) -> Tuple[str, bytes]:\n    <IND>",
        "target_code_with_indent": "<DED>@export\ndef get_items_from_gzip(binary: bytes) -> Tuple[str, Mapping[str, bytes]]:\n    <IND>"
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "        tar_file = tar.extractfile(item)\n        archive_file = tar_file.read()\n        archive_dict[item] = archive_file\n    return 'tar', archive_dict\n",
        "source_code_len": 153,
        "target_code": "        tar_file = tar.extractfile(item)\n        if tar_file:\n            archive_dict[item] = tar_file.read()\n        else:\n            archive_dict[item] = None\n    return 'tar', archive_dict\n",
        "target_code_len": 194,
        "diff_format": "@@ -597,4 +603,6 @@\n         tar_file = tar.extractfile(item)\n-        archive_file = tar_file.read()\n-        archive_dict[item] = archive_file\n+        if tar_file:\n+            archive_dict[item] = tar_file.read()\n+        else:\n+            archive_dict[item] = None\n     return 'tar', archive_dict\n",
        "source_code_with_indent": "        <IND>tar_file = tar.extractfile(item)\n        archive_file = tar_file.read()\n        archive_dict[item] = archive_file\n    <DED>return 'tar', archive_dict\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "        <IND>tar_file = tar.extractfile(item)\n        if tar_file:\n            <IND>archive_dict[item] = tar_file.read()\n        <DED>else:\n            <IND>archive_dict[item] = None\n    <DED><DED>return 'tar', archive_dict\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "microsoft/msticpy",
    "commit": "23f0416e8f2b8df83b745e077255859a9bb1b601",
    "filename": "msticpy/sectools/base64unpack.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/microsoft-msticpy/msticpy/sectools/base64unpack.py",
    "file_hunks_size": 14,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "msticpy/sectools/base64unpack.py:547:4 Incompatible return type [7]: Expected `Tuple[str, bytes]` but got `Tuple[str, typing.Dict[str, bytes]]`.",
    "message": " Expected `Tuple[str, bytes]` but got `Tuple[str, typing.Dict[str, bytes]]`.",
    "rule_id": "Incompatible return type [7]",
    "warning_line_no": 547,
    "warning_line": "    return 'gz', {'gzip_file': archive_file}",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "@export\ndef get_items_from_gzip(binary: bytes) -> Tuple[str, bytes]:\n    \"\"\"\n",
        "source_code_len": 77,
        "target_code": "@export\ndef get_items_from_gzip(binary: bytes) -> Tuple[str, Mapping[str, bytes]]:\n    \"\"\"\n",
        "target_code_len": 91,
        "diff_format": "@@ -530,3 +535,3 @@\n @export\n-def get_items_from_gzip(binary: bytes) -> Tuple[str, bytes]:\n+def get_items_from_gzip(binary: bytes) -> Tuple[str, Mapping[str, bytes]]:\n     \"\"\"\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "<DED><DED>@export\ndef get_items_from_gzip(binary: bytes) -> Tuple[str, bytes]:\n    <IND>",
        "target_code_with_indent": "<DED>@export\ndef get_items_from_gzip(binary: bytes) -> Tuple[str, Mapping[str, bytes]]:\n    <IND>"
      }
    ]
  },
  {
    "project": "microsoft/msticpy",
    "commit": "23f0416e8f2b8df83b745e077255859a9bb1b601",
    "filename": "msticpy/sectools/geoip.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/microsoft-msticpy/msticpy/sectools/geoip.py",
    "file_hunks_size": 12,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "msticpy/sectools/geoip.py:180:43 Incompatible parameter type [6]: Expected `typing.Dict[typing.Any, typing.Any]` for 1st positional only parameter to call `IPStackLookup._create_ip_entity` but got `str`.",
    "message": " Expected `typing.Dict[typing.Any, typing.Any]` for 1st positional only parameter to call `IPStackLookup._create_ip_entity` but got `str`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 180,
    "warning_line": "                    self._create_ip_entity(ip_loc, ip_entity))",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "from datetime import datetime, timedelta\nfrom typing import Tuple, List, Mapping\nfrom IPython import get_ipython\n",
        "source_code_len": 113,
        "target_code": "from datetime import datetime, timedelta\nfrom typing import Tuple, List, Dict\nfrom IPython import get_ipython\n",
        "target_code_len": 110,
        "diff_format": "@@ -14,3 +14,3 @@\n from datetime import datetime, timedelta\n-from typing import Tuple, List, Mapping\n+from typing import Tuple, List, Dict\n from IPython import get_ipython\n",
        "source_code_with_indent": "from datetime import datetime, timedelta\nfrom typing import Tuple, List, Mapping\nfrom IPython import get_ipython\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "from datetime import datetime, timedelta\nfrom typing import Tuple, List, Dict\nfrom IPython import get_ipython\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "                  ip_addr_list: Iterable = None,\n                  ip_entity: IpAddress = None) -> Tuple[List[Mapping[str, str]], List[IpAddress]]:\n        \"\"\"\n",
        "source_code_len": 160,
        "target_code": "                  ip_addr_list: Iterable = None,\n                  ip_entity: IpAddress = None) -> Tuple[List[Tuple[Dict[str, str], int]],\n                                                        List[IpAddress]]:\n        \"\"\"\n",
        "target_code_len": 225,
        "diff_format": "@@ -49,3 +49,4 @@\n                   ip_addr_list: Iterable = None,\n-                  ip_entity: IpAddress = None) -> Tuple[List[Mapping[str, str]], List[IpAddress]]:\n+                  ip_entity: IpAddress = None) -> Tuple[List[Tuple[Dict[str, str], int]],\n+                                                        List[IpAddress]]:\n         \"\"\"\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "                  ip_addr_list: Iterable = None,\n                  ip_entity: IpAddress = None) -> Tuple[List[Mapping[str, str]], List[IpAddress]]:\n        <IND>",
        "target_code_with_indent": "                  ip_addr_list: Iterable = None,\n                  ip_entity: IpAddress = None) -> Tuple[List[Tuple[Dict[str, str], int]],\n                                                        List[IpAddress]]:\n        <IND>"
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "                  ip_addr_list: Iterable = None,\n                  ip_entity: IpAddress = None) -> Tuple[List[Mapping[str, str]], List[IpAddress]]:\n        \"\"\"\n",
        "source_code_len": 160,
        "target_code": "                  ip_addr_list: Iterable = None,\n                  ip_entity: IpAddress = None) -> Tuple[List[Tuple[Dict[str, str], int]],\n                                                        List[IpAddress]]:\n        \"\"\"\n",
        "target_code_len": 225,
        "diff_format": "@@ -136,3 +137,4 @@\n                   ip_addr_list: Iterable = None,\n-                  ip_entity: IpAddress = None) -> Tuple[List[Mapping[str, str]], List[IpAddress]]:\n+                  ip_entity: IpAddress = None) -> Tuple[List[Tuple[Dict[str, str], int]],\n+                                                        List[IpAddress]]:\n         \"\"\"\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "                  ip_addr_list: Iterable = None,\n                  ip_entity: IpAddress = None) -> Tuple[List[Mapping[str, str]], List[IpAddress]]:\n        <IND>",
        "target_code_with_indent": "                  ip_addr_list: Iterable = None,\n                  ip_entity: IpAddress = None) -> Tuple[List[Tuple[Dict[str, str], int]],\n                                                        List[IpAddress]]:\n        <IND>"
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n    def _submit_request(self, ip_list: List[str]) -> List[Tuple[str, int]]:\n        \"\"\"\n",
        "source_code_len": 89,
        "target_code": "\n    def _submit_request(self, ip_list: List[str]) -> List[Tuple[Dict[str, str], int]]:\n        \"\"\"\n",
        "target_code_len": 100,
        "diff_format": "@@ -200,3 +202,3 @@\n \n-    def _submit_request(self, ip_list: List[str]) -> List[Tuple[str, int]]:\n+    def _submit_request(self, ip_list: List[str]) -> List[Tuple[Dict[str, str], int]]:\n         \"\"\"\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\n    <DED>def _submit_request(self, ip_list: List[str]) -> List[Tuple[str, int]]:\n        <IND>",
        "target_code_with_indent": "\n    <DED>def _submit_request(self, ip_list: List[str]) -> List[Tuple[Dict[str, str], int]]:\n        <IND>"
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "                        except JSONDecodeError:\n                            ip_loc_results.append(None, response.status_code)\n                    else:\n                        print('Unknown response from IPStack request.')\n                        ip_loc_results.append(None, -1)\n            return ip_loc_results\n        else:\n            submit_url = self._IPSTACK_API.format(iplist=','.join(ip_list),\n                                                  access_key=self._api_key)\n            response = requests.get(submit_url)\n\n            if response.status_code == 200:\n                results = response.json()\n                # {\"success\":false,\"error\":{\"code\":303,\"type\":\"batch_not_supported_on_plan\",\n                # \"info\":\"Bulk requests are not supported on your plan.\n                # Please upgrade your subscription.\"}}\n\n                if 'success' in results and not results[\"success\"]:\n                    raise PermissionError('Service unable to complete request. Error: {}'\n                                          .format(results['error']))\n                return [(item, response.status_code) for item in results]\n            else:\n                if response:\n                    try:\n                        return [(response.json(), response.status_code)]\n                    except JSONDecodeError:\n                        pass\n                return [(None, response.status_code)]\n\n",
        "source_code_len": 1410,
        "target_code": "                        except JSONDecodeError:\n                            ip_loc_results.append((None, response.status_code))\n                    else:\n                        print('Unknown response from IPStack request.')\n                        ip_loc_results.append((None, -1))\n            return ip_loc_results\n        \n        submit_url = self._IPSTACK_API.format(iplist=','.join(ip_list),\n                                                access_key=self._api_key)\n        response = requests.get(submit_url)\n\n        if response.status_code == 200:\n            results = response.json()\n            # {\"success\":false,\"error\":{\"code\":303,\"type\":\"batch_not_supported_on_plan\",\n            # \"info\":\"Bulk requests are not supported on your plan.\n            # Please upgrade your subscription.\"}}\n\n            if 'success' in results and not results[\"success\"]:\n                raise PermissionError('Service unable to complete request. Error: {}'\n                                        .format(results['error']))\n            return [(item, response.status_code) for item in results]\n        \n        if response:\n            try:\n                return [(response.json(), response.status_code)]\n            except JSONDecodeError:\n                pass\n        return [({}, response.status_code)]\n\n",
        "target_code_len": 1306,
        "diff_format": "@@ -231,29 +233,29 @@\n                         except JSONDecodeError:\n-                            ip_loc_results.append(None, response.status_code)\n+                            ip_loc_results.append((None, response.status_code))\n                     else:\n                         print('Unknown response from IPStack request.')\n-                        ip_loc_results.append(None, -1)\n+                        ip_loc_results.append((None, -1))\n             return ip_loc_results\n-        else:\n-            submit_url = self._IPSTACK_API.format(iplist=','.join(ip_list),\n-                                                  access_key=self._api_key)\n-            response = requests.get(submit_url)\n-\n-            if response.status_code == 200:\n-                results = response.json()\n-                # {\"success\":false,\"error\":{\"code\":303,\"type\":\"batch_not_supported_on_plan\",\n-                # \"info\":\"Bulk requests are not supported on your plan.\n-                # Please upgrade your subscription.\"}}\n-\n-                if 'success' in results and not results[\"success\"]:\n-                    raise PermissionError('Service unable to complete request. Error: {}'\n-                                          .format(results['error']))\n-                return [(item, response.status_code) for item in results]\n-            else:\n-                if response:\n-                    try:\n-                        return [(response.json(), response.status_code)]\n-                    except JSONDecodeError:\n-                        pass\n-                return [(None, response.status_code)]\n+        \n+        submit_url = self._IPSTACK_API.format(iplist=','.join(ip_list),\n+                                                access_key=self._api_key)\n+        response = requests.get(submit_url)\n+\n+        if response.status_code == 200:\n+            results = response.json()\n+            # {\"success\":false,\"error\":{\"code\":303,\"type\":\"batch_not_supported_on_plan\",\n+            # \"info\":\"Bulk requests are not supported on your plan.\n+            # Please upgrade your subscription.\"}}\n+\n+            if 'success' in results and not results[\"success\"]:\n+                raise PermissionError('Service unable to complete request. Error: {}'\n+                                        .format(results['error']))\n+            return [(item, response.status_code) for item in results]\n+        \n+        if response:\n+            try:\n+                return [(response.json(), response.status_code)]\n+            except JSONDecodeError:\n+                pass\n+        return [({}, response.status_code)]\n \n",
        "source_code_with_indent": "                        <DED>except JSONDecodeError:\n                            <IND>ip_loc_results.append(None, response.status_code)\n                    <DED><DED>else:\n                        <IND>print('Unknown response from IPStack request.')\n                        ip_loc_results.append(None, -1)\n            <DED><DED><DED>return ip_loc_results\n        <DED>else:\n            <IND>submit_url = self._IPSTACK_API.format(iplist=','.join(ip_list),\n                                                  access_key=self._api_key)\n            response = requests.get(submit_url)\n\n            if response.status_code == 200:\n                <IND>results = response.json()\n                # {\"success\":false,\"error\":{\"code\":303,\"type\":\"batch_not_supported_on_plan\",\n                # \"info\":\"Bulk requests are not supported on your plan.\n                # Please upgrade your subscription.\"}}\n\n                if 'success' in results and not results[\"success\"]:\n                    <IND>raise PermissionError('Service unable to complete request. Error: {}'\n                                          .format(results['error']))\n                <DED>return [(item, response.status_code) for item in results]\n            <DED>else:\n                <IND>if response:\n                    <IND>try:\n                        <IND>return [(response.json(), response.status_code)]\n                    <DED>except JSONDecodeError:\n                        <IND>pass\n                <DED><DED>return [(None, response.status_code)]\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "                        <DED>except JSONDecodeError:\n                            <IND>ip_loc_results.append((None, response.status_code))\n                    <DED><DED>else:\n                        <IND>print('Unknown response from IPStack request.')\n                        ip_loc_results.append((None, -1))\n            <DED><DED><DED>return ip_loc_results\n        \n        <DED>submit_url = self._IPSTACK_API.format(iplist=','.join(ip_list),\n                                                access_key=self._api_key)\n        response = requests.get(submit_url)\n\n        if response.status_code == 200:\n            <IND>results = response.json()\n            # {\"success\":false,\"error\":{\"code\":303,\"type\":\"batch_not_supported_on_plan\",\n            # \"info\":\"Bulk requests are not supported on your plan.\n            # Please upgrade your subscription.\"}}\n\n            if 'success' in results and not results[\"success\"]:\n                <IND>raise PermissionError('Service unable to complete request. Error: {}'\n                                        .format(results['error']))\n            <DED>return [(item, response.status_code) for item in results]\n        \n        <DED>if response:\n            <IND>try:\n                <IND>return [(response.json(), response.status_code)]\n            <DED>except JSONDecodeError:\n                <IND>pass\n        <DED><DED>return [({}, response.status_code)]\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "                  ip_addr_list: Iterable = None,\n                  ip_entity: IpAddress = None) -> Tuple[List[Mapping[str, str]], List[IpAddress]]:\n        \"\"\"\n",
        "source_code_len": 160,
        "target_code": "                  ip_addr_list: Iterable = None,\n                  ip_entity: IpAddress = None) -> Tuple[List[Tuple[Dict[str, str], int]],\n                                                        List[IpAddress]]:\n        \"\"\"\n",
        "target_code_len": 225,
        "diff_format": "@@ -293,3 +297,4 @@\n                   ip_addr_list: Iterable = None,\n-                  ip_entity: IpAddress = None) -> Tuple[List[Mapping[str, str]], List[IpAddress]]:\n+                  ip_entity: IpAddress = None) -> Tuple[List[Tuple[Dict[str, str], int]],\n+                                                        List[IpAddress]]:\n         \"\"\"\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "                  ip_addr_list: Iterable = None,\n                  ip_entity: IpAddress = None) -> Tuple[List[Mapping[str, str]], List[IpAddress]]:\n        <IND>",
        "target_code_with_indent": "                  ip_addr_list: Iterable = None,\n                  ip_entity: IpAddress = None) -> Tuple[List[Tuple[Dict[str, str], int]],\n                                                        List[IpAddress]]:\n        <IND>"
      }
    ]
  },
  {
    "project": "microsoft/msticpy",
    "commit": "23f0416e8f2b8df83b745e077255859a9bb1b601",
    "filename": "msticpy/sectools/geoip.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/microsoft-msticpy/msticpy/sectools/geoip.py",
    "file_hunks_size": 12,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "msticpy/sectools/geoip.py:182:8 Incompatible return type [7]: Expected `Tuple[List[Mapping[str, str]], List[IpAddress]]` but got `Tuple[List[Tuple[str, int]], List[typing.Any]]`.",
    "message": " Expected `Tuple[List[Mapping[str, str]], List[IpAddress]]` but got `Tuple[List[Tuple[str, int]], List[typing.Any]]`.",
    "rule_id": "Incompatible return type [7]",
    "warning_line_no": 182,
    "warning_line": "        return results, output_entities",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "from datetime import datetime, timedelta\nfrom typing import Tuple, List, Mapping\nfrom IPython import get_ipython\n",
        "source_code_len": 113,
        "target_code": "from datetime import datetime, timedelta\nfrom typing import Tuple, List, Dict\nfrom IPython import get_ipython\n",
        "target_code_len": 110,
        "diff_format": "@@ -14,3 +14,3 @@\n from datetime import datetime, timedelta\n-from typing import Tuple, List, Mapping\n+from typing import Tuple, List, Dict\n from IPython import get_ipython\n",
        "source_code_with_indent": "from datetime import datetime, timedelta\nfrom typing import Tuple, List, Mapping\nfrom IPython import get_ipython\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "from datetime import datetime, timedelta\nfrom typing import Tuple, List, Dict\nfrom IPython import get_ipython\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "                  ip_addr_list: Iterable = None,\n                  ip_entity: IpAddress = None) -> Tuple[List[Mapping[str, str]], List[IpAddress]]:\n        \"\"\"\n",
        "source_code_len": 160,
        "target_code": "                  ip_addr_list: Iterable = None,\n                  ip_entity: IpAddress = None) -> Tuple[List[Tuple[Dict[str, str], int]],\n                                                        List[IpAddress]]:\n        \"\"\"\n",
        "target_code_len": 225,
        "diff_format": "@@ -49,3 +49,4 @@\n                   ip_addr_list: Iterable = None,\n-                  ip_entity: IpAddress = None) -> Tuple[List[Mapping[str, str]], List[IpAddress]]:\n+                  ip_entity: IpAddress = None) -> Tuple[List[Tuple[Dict[str, str], int]],\n+                                                        List[IpAddress]]:\n         \"\"\"\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "                  ip_addr_list: Iterable = None,\n                  ip_entity: IpAddress = None) -> Tuple[List[Mapping[str, str]], List[IpAddress]]:\n        <IND>",
        "target_code_with_indent": "                  ip_addr_list: Iterable = None,\n                  ip_entity: IpAddress = None) -> Tuple[List[Tuple[Dict[str, str], int]],\n                                                        List[IpAddress]]:\n        <IND>"
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "                  ip_addr_list: Iterable = None,\n                  ip_entity: IpAddress = None) -> Tuple[List[Mapping[str, str]], List[IpAddress]]:\n        \"\"\"\n",
        "source_code_len": 160,
        "target_code": "                  ip_addr_list: Iterable = None,\n                  ip_entity: IpAddress = None) -> Tuple[List[Tuple[Dict[str, str], int]],\n                                                        List[IpAddress]]:\n        \"\"\"\n",
        "target_code_len": 225,
        "diff_format": "@@ -136,3 +137,4 @@\n                   ip_addr_list: Iterable = None,\n-                  ip_entity: IpAddress = None) -> Tuple[List[Mapping[str, str]], List[IpAddress]]:\n+                  ip_entity: IpAddress = None) -> Tuple[List[Tuple[Dict[str, str], int]],\n+                                                        List[IpAddress]]:\n         \"\"\"\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "                  ip_addr_list: Iterable = None,\n                  ip_entity: IpAddress = None) -> Tuple[List[Mapping[str, str]], List[IpAddress]]:\n        <IND>",
        "target_code_with_indent": "                  ip_addr_list: Iterable = None,\n                  ip_entity: IpAddress = None) -> Tuple[List[Tuple[Dict[str, str], int]],\n                                                        List[IpAddress]]:\n        <IND>"
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n    def _submit_request(self, ip_list: List[str]) -> List[Tuple[str, int]]:\n        \"\"\"\n",
        "source_code_len": 89,
        "target_code": "\n    def _submit_request(self, ip_list: List[str]) -> List[Tuple[Dict[str, str], int]]:\n        \"\"\"\n",
        "target_code_len": 100,
        "diff_format": "@@ -200,3 +202,3 @@\n \n-    def _submit_request(self, ip_list: List[str]) -> List[Tuple[str, int]]:\n+    def _submit_request(self, ip_list: List[str]) -> List[Tuple[Dict[str, str], int]]:\n         \"\"\"\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\n    <DED>def _submit_request(self, ip_list: List[str]) -> List[Tuple[str, int]]:\n        <IND>",
        "target_code_with_indent": "\n    <DED>def _submit_request(self, ip_list: List[str]) -> List[Tuple[Dict[str, str], int]]:\n        <IND>"
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "                        except JSONDecodeError:\n                            ip_loc_results.append(None, response.status_code)\n                    else:\n                        print('Unknown response from IPStack request.')\n                        ip_loc_results.append(None, -1)\n            return ip_loc_results\n        else:\n            submit_url = self._IPSTACK_API.format(iplist=','.join(ip_list),\n                                                  access_key=self._api_key)\n            response = requests.get(submit_url)\n\n            if response.status_code == 200:\n                results = response.json()\n                # {\"success\":false,\"error\":{\"code\":303,\"type\":\"batch_not_supported_on_plan\",\n                # \"info\":\"Bulk requests are not supported on your plan.\n                # Please upgrade your subscription.\"}}\n\n                if 'success' in results and not results[\"success\"]:\n                    raise PermissionError('Service unable to complete request. Error: {}'\n                                          .format(results['error']))\n                return [(item, response.status_code) for item in results]\n            else:\n                if response:\n                    try:\n                        return [(response.json(), response.status_code)]\n                    except JSONDecodeError:\n                        pass\n                return [(None, response.status_code)]\n\n",
        "source_code_len": 1410,
        "target_code": "                        except JSONDecodeError:\n                            ip_loc_results.append((None, response.status_code))\n                    else:\n                        print('Unknown response from IPStack request.')\n                        ip_loc_results.append((None, -1))\n            return ip_loc_results\n        \n        submit_url = self._IPSTACK_API.format(iplist=','.join(ip_list),\n                                                access_key=self._api_key)\n        response = requests.get(submit_url)\n\n        if response.status_code == 200:\n            results = response.json()\n            # {\"success\":false,\"error\":{\"code\":303,\"type\":\"batch_not_supported_on_plan\",\n            # \"info\":\"Bulk requests are not supported on your plan.\n            # Please upgrade your subscription.\"}}\n\n            if 'success' in results and not results[\"success\"]:\n                raise PermissionError('Service unable to complete request. Error: {}'\n                                        .format(results['error']))\n            return [(item, response.status_code) for item in results]\n        \n        if response:\n            try:\n                return [(response.json(), response.status_code)]\n            except JSONDecodeError:\n                pass\n        return [({}, response.status_code)]\n\n",
        "target_code_len": 1306,
        "diff_format": "@@ -231,29 +233,29 @@\n                         except JSONDecodeError:\n-                            ip_loc_results.append(None, response.status_code)\n+                            ip_loc_results.append((None, response.status_code))\n                     else:\n                         print('Unknown response from IPStack request.')\n-                        ip_loc_results.append(None, -1)\n+                        ip_loc_results.append((None, -1))\n             return ip_loc_results\n-        else:\n-            submit_url = self._IPSTACK_API.format(iplist=','.join(ip_list),\n-                                                  access_key=self._api_key)\n-            response = requests.get(submit_url)\n-\n-            if response.status_code == 200:\n-                results = response.json()\n-                # {\"success\":false,\"error\":{\"code\":303,\"type\":\"batch_not_supported_on_plan\",\n-                # \"info\":\"Bulk requests are not supported on your plan.\n-                # Please upgrade your subscription.\"}}\n-\n-                if 'success' in results and not results[\"success\"]:\n-                    raise PermissionError('Service unable to complete request. Error: {}'\n-                                          .format(results['error']))\n-                return [(item, response.status_code) for item in results]\n-            else:\n-                if response:\n-                    try:\n-                        return [(response.json(), response.status_code)]\n-                    except JSONDecodeError:\n-                        pass\n-                return [(None, response.status_code)]\n+        \n+        submit_url = self._IPSTACK_API.format(iplist=','.join(ip_list),\n+                                                access_key=self._api_key)\n+        response = requests.get(submit_url)\n+\n+        if response.status_code == 200:\n+            results = response.json()\n+            # {\"success\":false,\"error\":{\"code\":303,\"type\":\"batch_not_supported_on_plan\",\n+            # \"info\":\"Bulk requests are not supported on your plan.\n+            # Please upgrade your subscription.\"}}\n+\n+            if 'success' in results and not results[\"success\"]:\n+                raise PermissionError('Service unable to complete request. Error: {}'\n+                                        .format(results['error']))\n+            return [(item, response.status_code) for item in results]\n+        \n+        if response:\n+            try:\n+                return [(response.json(), response.status_code)]\n+            except JSONDecodeError:\n+                pass\n+        return [({}, response.status_code)]\n \n",
        "source_code_with_indent": "                        <DED>except JSONDecodeError:\n                            <IND>ip_loc_results.append(None, response.status_code)\n                    <DED><DED>else:\n                        <IND>print('Unknown response from IPStack request.')\n                        ip_loc_results.append(None, -1)\n            <DED><DED><DED>return ip_loc_results\n        <DED>else:\n            <IND>submit_url = self._IPSTACK_API.format(iplist=','.join(ip_list),\n                                                  access_key=self._api_key)\n            response = requests.get(submit_url)\n\n            if response.status_code == 200:\n                <IND>results = response.json()\n                # {\"success\":false,\"error\":{\"code\":303,\"type\":\"batch_not_supported_on_plan\",\n                # \"info\":\"Bulk requests are not supported on your plan.\n                # Please upgrade your subscription.\"}}\n\n                if 'success' in results and not results[\"success\"]:\n                    <IND>raise PermissionError('Service unable to complete request. Error: {}'\n                                          .format(results['error']))\n                <DED>return [(item, response.status_code) for item in results]\n            <DED>else:\n                <IND>if response:\n                    <IND>try:\n                        <IND>return [(response.json(), response.status_code)]\n                    <DED>except JSONDecodeError:\n                        <IND>pass\n                <DED><DED>return [(None, response.status_code)]\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "                        <DED>except JSONDecodeError:\n                            <IND>ip_loc_results.append((None, response.status_code))\n                    <DED><DED>else:\n                        <IND>print('Unknown response from IPStack request.')\n                        ip_loc_results.append((None, -1))\n            <DED><DED><DED>return ip_loc_results\n        \n        <DED>submit_url = self._IPSTACK_API.format(iplist=','.join(ip_list),\n                                                access_key=self._api_key)\n        response = requests.get(submit_url)\n\n        if response.status_code == 200:\n            <IND>results = response.json()\n            # {\"success\":false,\"error\":{\"code\":303,\"type\":\"batch_not_supported_on_plan\",\n            # \"info\":\"Bulk requests are not supported on your plan.\n            # Please upgrade your subscription.\"}}\n\n            if 'success' in results and not results[\"success\"]:\n                <IND>raise PermissionError('Service unable to complete request. Error: {}'\n                                        .format(results['error']))\n            <DED>return [(item, response.status_code) for item in results]\n        \n        <DED>if response:\n            <IND>try:\n                <IND>return [(response.json(), response.status_code)]\n            <DED>except JSONDecodeError:\n                <IND>pass\n        <DED><DED>return [({}, response.status_code)]\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "                  ip_addr_list: Iterable = None,\n                  ip_entity: IpAddress = None) -> Tuple[List[Mapping[str, str]], List[IpAddress]]:\n        \"\"\"\n",
        "source_code_len": 160,
        "target_code": "                  ip_addr_list: Iterable = None,\n                  ip_entity: IpAddress = None) -> Tuple[List[Tuple[Dict[str, str], int]],\n                                                        List[IpAddress]]:\n        \"\"\"\n",
        "target_code_len": 225,
        "diff_format": "@@ -293,3 +297,4 @@\n                   ip_addr_list: Iterable = None,\n-                  ip_entity: IpAddress = None) -> Tuple[List[Mapping[str, str]], List[IpAddress]]:\n+                  ip_entity: IpAddress = None) -> Tuple[List[Tuple[Dict[str, str], int]],\n+                                                        List[IpAddress]]:\n         \"\"\"\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "                  ip_addr_list: Iterable = None,\n                  ip_entity: IpAddress = None) -> Tuple[List[Mapping[str, str]], List[IpAddress]]:\n        <IND>",
        "target_code_with_indent": "                  ip_addr_list: Iterable = None,\n                  ip_entity: IpAddress = None) -> Tuple[List[Tuple[Dict[str, str], int]],\n                                                        List[IpAddress]]:\n        <IND>"
      }
    ]
  },
  {
    "project": "microsoft/msticpy",
    "commit": "23f0416e8f2b8df83b745e077255859a9bb1b601",
    "filename": "msticpy/sectools/geoip.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/microsoft-msticpy/msticpy/sectools/geoip.py",
    "file_hunks_size": 12,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "msticpy/sectools/geoip.py:258:16 Incompatible return type [7]: Expected `List[Tuple[str, int]]` but got `List[Tuple[None, int]]`.",
    "message": " Expected `List[Tuple[str, int]]` but got `List[Tuple[None, int]]`.",
    "rule_id": "Incompatible return type [7]",
    "warning_line_no": 258,
    "warning_line": "                return [(None, response.status_code)]",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "from datetime import datetime, timedelta\nfrom typing import Tuple, List, Mapping\nfrom IPython import get_ipython\n",
        "source_code_len": 113,
        "target_code": "from datetime import datetime, timedelta\nfrom typing import Tuple, List, Dict\nfrom IPython import get_ipython\n",
        "target_code_len": 110,
        "diff_format": "@@ -14,3 +14,3 @@\n from datetime import datetime, timedelta\n-from typing import Tuple, List, Mapping\n+from typing import Tuple, List, Dict\n from IPython import get_ipython\n",
        "source_code_with_indent": "from datetime import datetime, timedelta\nfrom typing import Tuple, List, Mapping\nfrom IPython import get_ipython\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "from datetime import datetime, timedelta\nfrom typing import Tuple, List, Dict\nfrom IPython import get_ipython\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "                  ip_addr_list: Iterable = None,\n                  ip_entity: IpAddress = None) -> Tuple[List[Mapping[str, str]], List[IpAddress]]:\n        \"\"\"\n",
        "source_code_len": 160,
        "target_code": "                  ip_addr_list: Iterable = None,\n                  ip_entity: IpAddress = None) -> Tuple[List[Tuple[Dict[str, str], int]],\n                                                        List[IpAddress]]:\n        \"\"\"\n",
        "target_code_len": 225,
        "diff_format": "@@ -49,3 +49,4 @@\n                   ip_addr_list: Iterable = None,\n-                  ip_entity: IpAddress = None) -> Tuple[List[Mapping[str, str]], List[IpAddress]]:\n+                  ip_entity: IpAddress = None) -> Tuple[List[Tuple[Dict[str, str], int]],\n+                                                        List[IpAddress]]:\n         \"\"\"\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "                  ip_addr_list: Iterable = None,\n                  ip_entity: IpAddress = None) -> Tuple[List[Mapping[str, str]], List[IpAddress]]:\n        <IND>",
        "target_code_with_indent": "                  ip_addr_list: Iterable = None,\n                  ip_entity: IpAddress = None) -> Tuple[List[Tuple[Dict[str, str], int]],\n                                                        List[IpAddress]]:\n        <IND>"
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "                  ip_addr_list: Iterable = None,\n                  ip_entity: IpAddress = None) -> Tuple[List[Mapping[str, str]], List[IpAddress]]:\n        \"\"\"\n",
        "source_code_len": 160,
        "target_code": "                  ip_addr_list: Iterable = None,\n                  ip_entity: IpAddress = None) -> Tuple[List[Tuple[Dict[str, str], int]],\n                                                        List[IpAddress]]:\n        \"\"\"\n",
        "target_code_len": 225,
        "diff_format": "@@ -136,3 +137,4 @@\n                   ip_addr_list: Iterable = None,\n-                  ip_entity: IpAddress = None) -> Tuple[List[Mapping[str, str]], List[IpAddress]]:\n+                  ip_entity: IpAddress = None) -> Tuple[List[Tuple[Dict[str, str], int]],\n+                                                        List[IpAddress]]:\n         \"\"\"\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "                  ip_addr_list: Iterable = None,\n                  ip_entity: IpAddress = None) -> Tuple[List[Mapping[str, str]], List[IpAddress]]:\n        <IND>",
        "target_code_with_indent": "                  ip_addr_list: Iterable = None,\n                  ip_entity: IpAddress = None) -> Tuple[List[Tuple[Dict[str, str], int]],\n                                                        List[IpAddress]]:\n        <IND>"
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n    def _submit_request(self, ip_list: List[str]) -> List[Tuple[str, int]]:\n        \"\"\"\n",
        "source_code_len": 89,
        "target_code": "\n    def _submit_request(self, ip_list: List[str]) -> List[Tuple[Dict[str, str], int]]:\n        \"\"\"\n",
        "target_code_len": 100,
        "diff_format": "@@ -200,3 +202,3 @@\n \n-    def _submit_request(self, ip_list: List[str]) -> List[Tuple[str, int]]:\n+    def _submit_request(self, ip_list: List[str]) -> List[Tuple[Dict[str, str], int]]:\n         \"\"\"\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\n    <DED>def _submit_request(self, ip_list: List[str]) -> List[Tuple[str, int]]:\n        <IND>",
        "target_code_with_indent": "\n    <DED>def _submit_request(self, ip_list: List[str]) -> List[Tuple[Dict[str, str], int]]:\n        <IND>"
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "                        except JSONDecodeError:\n                            ip_loc_results.append(None, response.status_code)\n                    else:\n                        print('Unknown response from IPStack request.')\n                        ip_loc_results.append(None, -1)\n            return ip_loc_results\n        else:\n            submit_url = self._IPSTACK_API.format(iplist=','.join(ip_list),\n                                                  access_key=self._api_key)\n            response = requests.get(submit_url)\n\n            if response.status_code == 200:\n                results = response.json()\n                # {\"success\":false,\"error\":{\"code\":303,\"type\":\"batch_not_supported_on_plan\",\n                # \"info\":\"Bulk requests are not supported on your plan.\n                # Please upgrade your subscription.\"}}\n\n                if 'success' in results and not results[\"success\"]:\n                    raise PermissionError('Service unable to complete request. Error: {}'\n                                          .format(results['error']))\n                return [(item, response.status_code) for item in results]\n            else:\n                if response:\n                    try:\n                        return [(response.json(), response.status_code)]\n                    except JSONDecodeError:\n                        pass\n                return [(None, response.status_code)]\n\n",
        "source_code_len": 1410,
        "target_code": "                        except JSONDecodeError:\n                            ip_loc_results.append((None, response.status_code))\n                    else:\n                        print('Unknown response from IPStack request.')\n                        ip_loc_results.append((None, -1))\n            return ip_loc_results\n        \n        submit_url = self._IPSTACK_API.format(iplist=','.join(ip_list),\n                                                access_key=self._api_key)\n        response = requests.get(submit_url)\n\n        if response.status_code == 200:\n            results = response.json()\n            # {\"success\":false,\"error\":{\"code\":303,\"type\":\"batch_not_supported_on_plan\",\n            # \"info\":\"Bulk requests are not supported on your plan.\n            # Please upgrade your subscription.\"}}\n\n            if 'success' in results and not results[\"success\"]:\n                raise PermissionError('Service unable to complete request. Error: {}'\n                                        .format(results['error']))\n            return [(item, response.status_code) for item in results]\n        \n        if response:\n            try:\n                return [(response.json(), response.status_code)]\n            except JSONDecodeError:\n                pass\n        return [({}, response.status_code)]\n\n",
        "target_code_len": 1306,
        "diff_format": "@@ -231,29 +233,29 @@\n                         except JSONDecodeError:\n-                            ip_loc_results.append(None, response.status_code)\n+                            ip_loc_results.append((None, response.status_code))\n                     else:\n                         print('Unknown response from IPStack request.')\n-                        ip_loc_results.append(None, -1)\n+                        ip_loc_results.append((None, -1))\n             return ip_loc_results\n-        else:\n-            submit_url = self._IPSTACK_API.format(iplist=','.join(ip_list),\n-                                                  access_key=self._api_key)\n-            response = requests.get(submit_url)\n-\n-            if response.status_code == 200:\n-                results = response.json()\n-                # {\"success\":false,\"error\":{\"code\":303,\"type\":\"batch_not_supported_on_plan\",\n-                # \"info\":\"Bulk requests are not supported on your plan.\n-                # Please upgrade your subscription.\"}}\n-\n-                if 'success' in results and not results[\"success\"]:\n-                    raise PermissionError('Service unable to complete request. Error: {}'\n-                                          .format(results['error']))\n-                return [(item, response.status_code) for item in results]\n-            else:\n-                if response:\n-                    try:\n-                        return [(response.json(), response.status_code)]\n-                    except JSONDecodeError:\n-                        pass\n-                return [(None, response.status_code)]\n+        \n+        submit_url = self._IPSTACK_API.format(iplist=','.join(ip_list),\n+                                                access_key=self._api_key)\n+        response = requests.get(submit_url)\n+\n+        if response.status_code == 200:\n+            results = response.json()\n+            # {\"success\":false,\"error\":{\"code\":303,\"type\":\"batch_not_supported_on_plan\",\n+            # \"info\":\"Bulk requests are not supported on your plan.\n+            # Please upgrade your subscription.\"}}\n+\n+            if 'success' in results and not results[\"success\"]:\n+                raise PermissionError('Service unable to complete request. Error: {}'\n+                                        .format(results['error']))\n+            return [(item, response.status_code) for item in results]\n+        \n+        if response:\n+            try:\n+                return [(response.json(), response.status_code)]\n+            except JSONDecodeError:\n+                pass\n+        return [({}, response.status_code)]\n \n",
        "source_code_with_indent": "                        <DED>except JSONDecodeError:\n                            <IND>ip_loc_results.append(None, response.status_code)\n                    <DED><DED>else:\n                        <IND>print('Unknown response from IPStack request.')\n                        ip_loc_results.append(None, -1)\n            <DED><DED><DED>return ip_loc_results\n        <DED>else:\n            <IND>submit_url = self._IPSTACK_API.format(iplist=','.join(ip_list),\n                                                  access_key=self._api_key)\n            response = requests.get(submit_url)\n\n            if response.status_code == 200:\n                <IND>results = response.json()\n                # {\"success\":false,\"error\":{\"code\":303,\"type\":\"batch_not_supported_on_plan\",\n                # \"info\":\"Bulk requests are not supported on your plan.\n                # Please upgrade your subscription.\"}}\n\n                if 'success' in results and not results[\"success\"]:\n                    <IND>raise PermissionError('Service unable to complete request. Error: {}'\n                                          .format(results['error']))\n                <DED>return [(item, response.status_code) for item in results]\n            <DED>else:\n                <IND>if response:\n                    <IND>try:\n                        <IND>return [(response.json(), response.status_code)]\n                    <DED>except JSONDecodeError:\n                        <IND>pass\n                <DED><DED>return [(None, response.status_code)]\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "                        <DED>except JSONDecodeError:\n                            <IND>ip_loc_results.append((None, response.status_code))\n                    <DED><DED>else:\n                        <IND>print('Unknown response from IPStack request.')\n                        ip_loc_results.append((None, -1))\n            <DED><DED><DED>return ip_loc_results\n        \n        <DED>submit_url = self._IPSTACK_API.format(iplist=','.join(ip_list),\n                                                access_key=self._api_key)\n        response = requests.get(submit_url)\n\n        if response.status_code == 200:\n            <IND>results = response.json()\n            # {\"success\":false,\"error\":{\"code\":303,\"type\":\"batch_not_supported_on_plan\",\n            # \"info\":\"Bulk requests are not supported on your plan.\n            # Please upgrade your subscription.\"}}\n\n            if 'success' in results and not results[\"success\"]:\n                <IND>raise PermissionError('Service unable to complete request. Error: {}'\n                                        .format(results['error']))\n            <DED>return [(item, response.status_code) for item in results]\n        \n        <DED>if response:\n            <IND>try:\n                <IND>return [(response.json(), response.status_code)]\n            <DED>except JSONDecodeError:\n                <IND>pass\n        <DED><DED>return [({}, response.status_code)]\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "                  ip_addr_list: Iterable = None,\n                  ip_entity: IpAddress = None) -> Tuple[List[Mapping[str, str]], List[IpAddress]]:\n        \"\"\"\n",
        "source_code_len": 160,
        "target_code": "                  ip_addr_list: Iterable = None,\n                  ip_entity: IpAddress = None) -> Tuple[List[Tuple[Dict[str, str], int]],\n                                                        List[IpAddress]]:\n        \"\"\"\n",
        "target_code_len": 225,
        "diff_format": "@@ -293,3 +297,4 @@\n                   ip_addr_list: Iterable = None,\n-                  ip_entity: IpAddress = None) -> Tuple[List[Mapping[str, str]], List[IpAddress]]:\n+                  ip_entity: IpAddress = None) -> Tuple[List[Tuple[Dict[str, str], int]],\n+                                                        List[IpAddress]]:\n         \"\"\"\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "                  ip_addr_list: Iterable = None,\n                  ip_entity: IpAddress = None) -> Tuple[List[Mapping[str, str]], List[IpAddress]]:\n        <IND>",
        "target_code_with_indent": "                  ip_addr_list: Iterable = None,\n                  ip_entity: IpAddress = None) -> Tuple[List[Tuple[Dict[str, str], int]],\n                                                        List[IpAddress]]:\n        <IND>"
      }
    ]
  },
  {
    "project": "microsoft/msticpy",
    "commit": "23f0416e8f2b8df83b745e077255859a9bb1b601",
    "filename": "msticpy/sectools/vtlookup.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/microsoft-msticpy/msticpy/sectools/vtlookup.py",
    "file_hunks_size": 64,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": true,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "msticpy/sectools/vtlookup.py:203:12 Incompatible variable type [9]: src_index_col is declared to have type `str` but is used as type `None`.",
    "message": " src_index_col is declared to have type `str` but is used as type `None`.",
    "rule_id": "Incompatible variable type [9]",
    "warning_line_no": 203,
    "warning_line": "            src_index_col = None",
    "min_patch": [
      {
        "hunk_fit_TFix": true,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n        if src_index_col not in data:\n            src_index_col = None\n\n",
        "source_code_len": 73,
        "target_code": "\n        src_idx_col = src_index_col if src_index_col in data else None\n\n",
        "target_code_len": 73,
        "diff_format": "@@ -201,4 +238,3 @@\n \n-        if src_index_col not in data:\n-            src_index_col = None\n+        src_idx_col = src_index_col if src_index_col in data else None\n \n",
        "source_code_with_indent": "\n        <DED><DED>if src_index_col not in data:\n            <IND>src_index_col = None\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n        <DED><DED>src_idx_col = src_index_col if src_index_col in data else None\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "microsoft/msticpy",
    "commit": "23f0416e8f2b8df83b745e077255859a9bb1b601",
    "filename": "msticpy/sectools/vtlookup.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/microsoft-msticpy/msticpy/sectools/vtlookup.py",
    "file_hunks_size": 64,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "msticpy/sectools/vtlookup.py:212:51 Incompatible parameter type [6]: Expected `str` for 2nd positional only parameter to call `VTLookup._print_status` but got `int`.",
    "message": " Expected `str` for 2nd positional only parameter to call `VTLookup._print_status` but got `int`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 212,
    "warning_line": "            .format(len(self.results), len(data)), 2)",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    @classmethod\n    def _get_supported_vt_ioc_types(cls) -> list({str}):\n        \"\"\"Return the subset of IoC types supported by VT.\"\"\"\n        return [t for t in cls._SUPPORTED_INPUT_TYPES if cls._VT_TYPE_MAP[t] is not None]\n\n    def _print_status(self, message: str, verbosity_level: str):\n        \"\"\"\n",
        "source_code_len": 304,
        "target_code": "    @classmethod\n    def _get_supported_vt_ioc_types(cls) -> List[str]:\n        \"\"\"Return the subset of IoC types supported by VT.\"\"\"\n        return [\n            t for t in cls._SUPPORTED_INPUT_TYPES if cls._VT_TYPE_MAP[t] is not None\n        ]\n\n    def _print_status(self, message: str, verbosity_level: int):\n        \"\"\"\n",
        "target_code_len": 324,
        "diff_format": "@@ -814,7 +970,9 @@\n     @classmethod\n-    def _get_supported_vt_ioc_types(cls) -> list({str}):\n+    def _get_supported_vt_ioc_types(cls) -> List[str]:\n         \"\"\"Return the subset of IoC types supported by VT.\"\"\"\n-        return [t for t in cls._SUPPORTED_INPUT_TYPES if cls._VT_TYPE_MAP[t] is not None]\n-\n-    def _print_status(self, message: str, verbosity_level: str):\n+        return [\n+            t for t in cls._SUPPORTED_INPUT_TYPES if cls._VT_TYPE_MAP[t] is not None\n+        ]\n+\n+    def _print_status(self, message: str, verbosity_level: int):\n         \"\"\"\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "    <DED>@classmethod\n    def _get_supported_vt_ioc_types(cls) -> list({str}):\n        <IND>\"\"\"Return the subset of IoC types supported by VT.\"\"\"\n        return [t for t in cls._SUPPORTED_INPUT_TYPES if cls._VT_TYPE_MAP[t] is not None]\n\n    <DED>def _print_status(self, message: str, verbosity_level: str):\n        <IND>",
        "target_code_with_indent": "    <DED>@classmethod\n    def _get_supported_vt_ioc_types(cls) -> List[str]:\n        <IND>\"\"\"Return the subset of IoC types supported by VT.\"\"\"\n        return [\n            t for t in cls._SUPPORTED_INPUT_TYPES if cls._VT_TYPE_MAP[t] is not None\n        ]\n\n    <DED>def _print_status(self, message: str, verbosity_level: int):\n        <IND>"
      }
    ]
  },
  {
    "project": "microsoft/msticpy",
    "commit": "23f0416e8f2b8df83b745e077255859a9bb1b601",
    "filename": "msticpy/sectools/vtlookup.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/microsoft-msticpy/msticpy/sectools/vtlookup.py",
    "file_hunks_size": 64,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "msticpy/sectools/vtlookup.py:337:56 Incompatible parameter type [6]: Expected `str` for 2nd positional only parameter to call `VTLookup._print_status` but got `int`.",
    "message": " Expected `str` for 2nd positional only parameter to call `VTLookup._print_status` but got `int`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 337,
    "warning_line": "                    .format(obs_submit, ioc_type, idx), 2)",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    @classmethod\n    def _get_supported_vt_ioc_types(cls) -> list({str}):\n        \"\"\"Return the subset of IoC types supported by VT.\"\"\"\n        return [t for t in cls._SUPPORTED_INPUT_TYPES if cls._VT_TYPE_MAP[t] is not None]\n\n    def _print_status(self, message: str, verbosity_level: str):\n        \"\"\"\n",
        "source_code_len": 304,
        "target_code": "    @classmethod\n    def _get_supported_vt_ioc_types(cls) -> List[str]:\n        \"\"\"Return the subset of IoC types supported by VT.\"\"\"\n        return [\n            t for t in cls._SUPPORTED_INPUT_TYPES if cls._VT_TYPE_MAP[t] is not None\n        ]\n\n    def _print_status(self, message: str, verbosity_level: int):\n        \"\"\"\n",
        "target_code_len": 324,
        "diff_format": "@@ -814,7 +970,9 @@\n     @classmethod\n-    def _get_supported_vt_ioc_types(cls) -> list({str}):\n+    def _get_supported_vt_ioc_types(cls) -> List[str]:\n         \"\"\"Return the subset of IoC types supported by VT.\"\"\"\n-        return [t for t in cls._SUPPORTED_INPUT_TYPES if cls._VT_TYPE_MAP[t] is not None]\n-\n-    def _print_status(self, message: str, verbosity_level: str):\n+        return [\n+            t for t in cls._SUPPORTED_INPUT_TYPES if cls._VT_TYPE_MAP[t] is not None\n+        ]\n+\n+    def _print_status(self, message: str, verbosity_level: int):\n         \"\"\"\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "    <DED>@classmethod\n    def _get_supported_vt_ioc_types(cls) -> list({str}):\n        <IND>\"\"\"Return the subset of IoC types supported by VT.\"\"\"\n        return [t for t in cls._SUPPORTED_INPUT_TYPES if cls._VT_TYPE_MAP[t] is not None]\n\n    <DED>def _print_status(self, message: str, verbosity_level: str):\n        <IND>",
        "target_code_with_indent": "    <DED>@classmethod\n    def _get_supported_vt_ioc_types(cls) -> List[str]:\n        <IND>\"\"\"Return the subset of IoC types supported by VT.\"\"\"\n        return [\n            t for t in cls._SUPPORTED_INPUT_TYPES if cls._VT_TYPE_MAP[t] is not None\n        ]\n\n    <DED>def _print_status(self, message: str, verbosity_level: int):\n        <IND>"
      }
    ]
  },
  {
    "project": "microsoft/msticpy",
    "commit": "23f0416e8f2b8df83b745e077255859a9bb1b601",
    "filename": "msticpy/sectools/vtlookup.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/microsoft-msticpy/msticpy/sectools/vtlookup.py",
    "file_hunks_size": 64,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "msticpy/sectools/vtlookup.py:353:67 Incompatible parameter type [6]: Expected `str` for 2nd positional only parameter to call `VTLookup._print_status` but got `int`.",
    "message": " Expected `str` for 2nd positional only parameter to call `VTLookup._print_status` but got `int`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 353,
    "warning_line": "                                    source_row_index[failed_obs]), 1)",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    @classmethod\n    def _get_supported_vt_ioc_types(cls) -> list({str}):\n        \"\"\"Return the subset of IoC types supported by VT.\"\"\"\n        return [t for t in cls._SUPPORTED_INPUT_TYPES if cls._VT_TYPE_MAP[t] is not None]\n\n    def _print_status(self, message: str, verbosity_level: str):\n        \"\"\"\n",
        "source_code_len": 304,
        "target_code": "    @classmethod\n    def _get_supported_vt_ioc_types(cls) -> List[str]:\n        \"\"\"Return the subset of IoC types supported by VT.\"\"\"\n        return [\n            t for t in cls._SUPPORTED_INPUT_TYPES if cls._VT_TYPE_MAP[t] is not None\n        ]\n\n    def _print_status(self, message: str, verbosity_level: int):\n        \"\"\"\n",
        "target_code_len": 324,
        "diff_format": "@@ -814,7 +970,9 @@\n     @classmethod\n-    def _get_supported_vt_ioc_types(cls) -> list({str}):\n+    def _get_supported_vt_ioc_types(cls) -> List[str]:\n         \"\"\"Return the subset of IoC types supported by VT.\"\"\"\n-        return [t for t in cls._SUPPORTED_INPUT_TYPES if cls._VT_TYPE_MAP[t] is not None]\n-\n-    def _print_status(self, message: str, verbosity_level: str):\n+        return [\n+            t for t in cls._SUPPORTED_INPUT_TYPES if cls._VT_TYPE_MAP[t] is not None\n+        ]\n+\n+    def _print_status(self, message: str, verbosity_level: int):\n         \"\"\"\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "    <DED>@classmethod\n    def _get_supported_vt_ioc_types(cls) -> list({str}):\n        <IND>\"\"\"Return the subset of IoC types supported by VT.\"\"\"\n        return [t for t in cls._SUPPORTED_INPUT_TYPES if cls._VT_TYPE_MAP[t] is not None]\n\n    <DED>def _print_status(self, message: str, verbosity_level: str):\n        <IND>",
        "target_code_with_indent": "    <DED>@classmethod\n    def _get_supported_vt_ioc_types(cls) -> List[str]:\n        <IND>\"\"\"Return the subset of IoC types supported by VT.\"\"\"\n        return [\n            t for t in cls._SUPPORTED_INPUT_TYPES if cls._VT_TYPE_MAP[t] is not None\n        ]\n\n    <DED>def _print_status(self, message: str, verbosity_level: int):\n        <IND>"
      }
    ]
  },
  {
    "project": "microsoft/msticpy",
    "commit": "23f0416e8f2b8df83b745e077255859a9bb1b601",
    "filename": "msticpy/sectools/vtlookup.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/microsoft-msticpy/msticpy/sectools/vtlookup.py",
    "file_hunks_size": 64,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "msticpy/sectools/vtlookup.py:393:74 Incompatible parameter type [6]: Expected `str` for 2nd positional only parameter to call `VTLookup._print_status` but got `int`.",
    "message": " Expected `str` for 2nd positional only parameter to call `VTLookup._print_status` but got `int`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 393,
    "warning_line": "                               .format(observable, ioc_type, source_idx), 1)",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    @classmethod\n    def _get_supported_vt_ioc_types(cls) -> list({str}):\n        \"\"\"Return the subset of IoC types supported by VT.\"\"\"\n        return [t for t in cls._SUPPORTED_INPUT_TYPES if cls._VT_TYPE_MAP[t] is not None]\n\n    def _print_status(self, message: str, verbosity_level: str):\n        \"\"\"\n",
        "source_code_len": 304,
        "target_code": "    @classmethod\n    def _get_supported_vt_ioc_types(cls) -> List[str]:\n        \"\"\"Return the subset of IoC types supported by VT.\"\"\"\n        return [\n            t for t in cls._SUPPORTED_INPUT_TYPES if cls._VT_TYPE_MAP[t] is not None\n        ]\n\n    def _print_status(self, message: str, verbosity_level: int):\n        \"\"\"\n",
        "target_code_len": 324,
        "diff_format": "@@ -814,7 +970,9 @@\n     @classmethod\n-    def _get_supported_vt_ioc_types(cls) -> list({str}):\n+    def _get_supported_vt_ioc_types(cls) -> List[str]:\n         \"\"\"Return the subset of IoC types supported by VT.\"\"\"\n-        return [t for t in cls._SUPPORTED_INPUT_TYPES if cls._VT_TYPE_MAP[t] is not None]\n-\n-    def _print_status(self, message: str, verbosity_level: str):\n+        return [\n+            t for t in cls._SUPPORTED_INPUT_TYPES if cls._VT_TYPE_MAP[t] is not None\n+        ]\n+\n+    def _print_status(self, message: str, verbosity_level: int):\n         \"\"\"\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "    <DED>@classmethod\n    def _get_supported_vt_ioc_types(cls) -> list({str}):\n        <IND>\"\"\"Return the subset of IoC types supported by VT.\"\"\"\n        return [t for t in cls._SUPPORTED_INPUT_TYPES if cls._VT_TYPE_MAP[t] is not None]\n\n    <DED>def _print_status(self, message: str, verbosity_level: str):\n        <IND>",
        "target_code_with_indent": "    <DED>@classmethod\n    def _get_supported_vt_ioc_types(cls) -> List[str]:\n        <IND>\"\"\"Return the subset of IoC types supported by VT.\"\"\"\n        return [\n            t for t in cls._SUPPORTED_INPUT_TYPES if cls._VT_TYPE_MAP[t] is not None\n        ]\n\n    <DED>def _print_status(self, message: str, verbosity_level: int):\n        <IND>"
      }
    ]
  },
  {
    "project": "microsoft/msticpy",
    "commit": "23f0416e8f2b8df83b745e077255859a9bb1b601",
    "filename": "msticpy/sectools/vtlookup.py",
    "min_patch_found": false,
    "full_warning_msg": "msticpy/sectools/vtlookup.py:439:49 Invalid type [31]: Expression `dict({ str:any })` is not a valid type.",
    "exception": "too many values to unpack (expected 2)",
    "dd_fail": true
  },
  {
    "project": "microsoft/msticpy",
    "commit": "23f0416e8f2b8df83b745e077255859a9bb1b601",
    "filename": "msticpy/sectools/vtlookup.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/microsoft-msticpy/msticpy/sectools/vtlookup.py",
    "file_hunks_size": 64,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "msticpy/sectools/vtlookup.py:522:74 Incompatible parameter type [6]: Expected `str` for 2nd positional only parameter to call `VTLookup._print_status` but got `int`.",
    "message": " Expected `str` for 2nd positional only parameter to call `VTLookup._print_status` but got `int`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 522,
    "warning_line": "            self._print_status(status + ' (Source index {})'.format(idx), 1)",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    @classmethod\n    def _get_supported_vt_ioc_types(cls) -> list({str}):\n        \"\"\"Return the subset of IoC types supported by VT.\"\"\"\n        return [t for t in cls._SUPPORTED_INPUT_TYPES if cls._VT_TYPE_MAP[t] is not None]\n\n    def _print_status(self, message: str, verbosity_level: str):\n        \"\"\"\n",
        "source_code_len": 304,
        "target_code": "    @classmethod\n    def _get_supported_vt_ioc_types(cls) -> List[str]:\n        \"\"\"Return the subset of IoC types supported by VT.\"\"\"\n        return [\n            t for t in cls._SUPPORTED_INPUT_TYPES if cls._VT_TYPE_MAP[t] is not None\n        ]\n\n    def _print_status(self, message: str, verbosity_level: int):\n        \"\"\"\n",
        "target_code_len": 324,
        "diff_format": "@@ -814,7 +970,9 @@\n     @classmethod\n-    def _get_supported_vt_ioc_types(cls) -> list({str}):\n+    def _get_supported_vt_ioc_types(cls) -> List[str]:\n         \"\"\"Return the subset of IoC types supported by VT.\"\"\"\n-        return [t for t in cls._SUPPORTED_INPUT_TYPES if cls._VT_TYPE_MAP[t] is not None]\n-\n-    def _print_status(self, message: str, verbosity_level: str):\n+        return [\n+            t for t in cls._SUPPORTED_INPUT_TYPES if cls._VT_TYPE_MAP[t] is not None\n+        ]\n+\n+    def _print_status(self, message: str, verbosity_level: int):\n         \"\"\"\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "    <DED>@classmethod\n    def _get_supported_vt_ioc_types(cls) -> list({str}):\n        <IND>\"\"\"Return the subset of IoC types supported by VT.\"\"\"\n        return [t for t in cls._SUPPORTED_INPUT_TYPES if cls._VT_TYPE_MAP[t] is not None]\n\n    <DED>def _print_status(self, message: str, verbosity_level: str):\n        <IND>",
        "target_code_with_indent": "    <DED>@classmethod\n    def _get_supported_vt_ioc_types(cls) -> List[str]:\n        <IND>\"\"\"Return the subset of IoC types supported by VT.\"\"\"\n        return [\n            t for t in cls._SUPPORTED_INPUT_TYPES if cls._VT_TYPE_MAP[t] is not None\n        ]\n\n    <DED>def _print_status(self, message: str, verbosity_level: int):\n        <IND>"
      }
    ]
  },
  {
    "project": "microsoft/msticpy",
    "commit": "23f0416e8f2b8df83b745e077255859a9bb1b601",
    "filename": "msticpy/sectools/vtlookup.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/microsoft-msticpy/msticpy/sectools/vtlookup.py",
    "file_hunks_size": 64,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "msticpy/sectools/vtlookup.py:534:74 Incompatible parameter type [6]: Expected `str` for 2nd positional only parameter to call `VTLookup._print_status` but got `int`.",
    "message": " Expected `str` for 2nd positional only parameter to call `VTLookup._print_status` but got `int`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 534,
    "warning_line": "                .format(observable, ioc_type, pp_observable.status, idx), 2)",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    @classmethod\n    def _get_supported_vt_ioc_types(cls) -> list({str}):\n        \"\"\"Return the subset of IoC types supported by VT.\"\"\"\n        return [t for t in cls._SUPPORTED_INPUT_TYPES if cls._VT_TYPE_MAP[t] is not None]\n\n    def _print_status(self, message: str, verbosity_level: str):\n        \"\"\"\n",
        "source_code_len": 304,
        "target_code": "    @classmethod\n    def _get_supported_vt_ioc_types(cls) -> List[str]:\n        \"\"\"Return the subset of IoC types supported by VT.\"\"\"\n        return [\n            t for t in cls._SUPPORTED_INPUT_TYPES if cls._VT_TYPE_MAP[t] is not None\n        ]\n\n    def _print_status(self, message: str, verbosity_level: int):\n        \"\"\"\n",
        "target_code_len": 324,
        "diff_format": "@@ -814,7 +970,9 @@\n     @classmethod\n-    def _get_supported_vt_ioc_types(cls) -> list({str}):\n+    def _get_supported_vt_ioc_types(cls) -> List[str]:\n         \"\"\"Return the subset of IoC types supported by VT.\"\"\"\n-        return [t for t in cls._SUPPORTED_INPUT_TYPES if cls._VT_TYPE_MAP[t] is not None]\n-\n-    def _print_status(self, message: str, verbosity_level: str):\n+        return [\n+            t for t in cls._SUPPORTED_INPUT_TYPES if cls._VT_TYPE_MAP[t] is not None\n+        ]\n+\n+    def _print_status(self, message: str, verbosity_level: int):\n         \"\"\"\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "    <DED>@classmethod\n    def _get_supported_vt_ioc_types(cls) -> list({str}):\n        <IND>\"\"\"Return the subset of IoC types supported by VT.\"\"\"\n        return [t for t in cls._SUPPORTED_INPUT_TYPES if cls._VT_TYPE_MAP[t] is not None]\n\n    <DED>def _print_status(self, message: str, verbosity_level: str):\n        <IND>",
        "target_code_with_indent": "    <DED>@classmethod\n    def _get_supported_vt_ioc_types(cls) -> List[str]:\n        <IND>\"\"\"Return the subset of IoC types supported by VT.\"\"\"\n        return [\n            t for t in cls._SUPPORTED_INPUT_TYPES if cls._VT_TYPE_MAP[t] is not None\n        ]\n\n    <DED>def _print_status(self, message: str, verbosity_level: int):\n        <IND>"
      }
    ]
  },
  {
    "project": "microsoft/msticpy",
    "commit": "23f0416e8f2b8df83b745e077255859a9bb1b601",
    "filename": "msticpy/sectools/vtlookup.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/microsoft-msticpy/msticpy/sectools/vtlookup.py",
    "file_hunks_size": 64,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "msticpy/sectools/vtlookup.py:545:71 Incompatible parameter type [6]: Expected `str` for 2nd positional only parameter to call `VTLookup._print_status` but got `int`.",
    "message": " Expected `str` for 2nd positional only parameter to call `VTLookup._print_status` but got `int`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 545,
    "warning_line": "                .format(observable, ioc_type, dup_result.status, idx), 2)",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    @classmethod\n    def _get_supported_vt_ioc_types(cls) -> list({str}):\n        \"\"\"Return the subset of IoC types supported by VT.\"\"\"\n        return [t for t in cls._SUPPORTED_INPUT_TYPES if cls._VT_TYPE_MAP[t] is not None]\n\n    def _print_status(self, message: str, verbosity_level: str):\n        \"\"\"\n",
        "source_code_len": 304,
        "target_code": "    @classmethod\n    def _get_supported_vt_ioc_types(cls) -> List[str]:\n        \"\"\"Return the subset of IoC types supported by VT.\"\"\"\n        return [\n            t for t in cls._SUPPORTED_INPUT_TYPES if cls._VT_TYPE_MAP[t] is not None\n        ]\n\n    def _print_status(self, message: str, verbosity_level: int):\n        \"\"\"\n",
        "target_code_len": 324,
        "diff_format": "@@ -814,7 +970,9 @@\n     @classmethod\n-    def _get_supported_vt_ioc_types(cls) -> list({str}):\n+    def _get_supported_vt_ioc_types(cls) -> List[str]:\n         \"\"\"Return the subset of IoC types supported by VT.\"\"\"\n-        return [t for t in cls._SUPPORTED_INPUT_TYPES if cls._VT_TYPE_MAP[t] is not None]\n-\n-    def _print_status(self, message: str, verbosity_level: str):\n+        return [\n+            t for t in cls._SUPPORTED_INPUT_TYPES if cls._VT_TYPE_MAP[t] is not None\n+        ]\n+\n+    def _print_status(self, message: str, verbosity_level: int):\n         \"\"\"\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "    <DED>@classmethod\n    def _get_supported_vt_ioc_types(cls) -> list({str}):\n        <IND>\"\"\"Return the subset of IoC types supported by VT.\"\"\"\n        return [t for t in cls._SUPPORTED_INPUT_TYPES if cls._VT_TYPE_MAP[t] is not None]\n\n    <DED>def _print_status(self, message: str, verbosity_level: str):\n        <IND>",
        "target_code_with_indent": "    <DED>@classmethod\n    def _get_supported_vt_ioc_types(cls) -> List[str]:\n        <IND>\"\"\"Return the subset of IoC types supported by VT.\"\"\"\n        return [\n            t for t in cls._SUPPORTED_INPUT_TYPES if cls._VT_TYPE_MAP[t] is not None\n        ]\n\n    <DED>def _print_status(self, message: str, verbosity_level: int):\n        <IND>"
      }
    ]
  },
  {
    "project": "microsoft/msticpy",
    "commit": "23f0416e8f2b8df83b745e077255859a9bb1b601",
    "filename": "msticpy/sectools/vtlookup.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/microsoft-msticpy/msticpy/sectools/vtlookup.py",
    "file_hunks_size": 64,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "msticpy/sectools/vtlookup.py:734:12 Incompatible return type [7]: Expected `str` but got `typing.Tuple[None, str]`.",
    "message": " Expected `str` but got `typing.Tuple[None, str]`.",
    "rule_id": "Incompatible return type [7]",
    "warning_line_no": 734,
    "warning_line": "            return None, 'Could not parse as valid URL'",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "import re\nfrom typing import List, Mapping, Any\nfrom collections import namedtuple, Counter\n",
        "source_code_len": 92,
        "target_code": "import re\nfrom typing import List, Mapping, Any, Dict, Optional, Tuple\nfrom collections import namedtuple, Counter\n",
        "target_code_len": 115,
        "diff_format": "@@ -11,3 +11,3 @@\n import re\n-from typing import List, Mapping, Any\n+from typing import List, Mapping, Any, Dict, Optional, Tuple\n from collections import namedtuple, Counter\n",
        "source_code_with_indent": "import re\nfrom typing import List, Mapping, Any\nfrom collections import namedtuple, Counter\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "import re\nfrom typing import List, Mapping, Any, Dict, Optional, Tuple\nfrom collections import namedtuple, Counter\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n        if '.' not in host:\n            return PreProcessResult(None, 'Host is unqualified domain name')\n\n        if scheme.lower() in ['file']:\n            return PreProcessResult(None, f'{scheme} URL scheme is not supported')\n\n        return PreProcessResult(clean_url, 'ok')\n\n    @classmethod\n    def _clean_url(cls, url: str) -> str:\n        \"\"\"\n",
        "source_code_len": 351,
        "target_code": "\n        if \".\" not in host:\n            return PreProcessResult(None, \"Host is unqualified domain name\")\n\n        if scheme.lower() in [\"file\"]:\n            return PreProcessResult(None, f\"{scheme} URL scheme is not supported\")\n\n        return PreProcessResult(clean_url, \"ok\")\n\n    @classmethod\n    def _clean_url(cls, url: str) -> Optional[str]:\n        \"\"\"\n",
        "target_code_len": 361,
        "diff_format": "@@ -700,12 +845,12 @@\n \n-        if '.' not in host:\n-            return PreProcessResult(None, 'Host is unqualified domain name')\n-\n-        if scheme.lower() in ['file']:\n-            return PreProcessResult(None, f'{scheme} URL scheme is not supported')\n-\n-        return PreProcessResult(clean_url, 'ok')\n+        if \".\" not in host:\n+            return PreProcessResult(None, \"Host is unqualified domain name\")\n+\n+        if scheme.lower() in [\"file\"]:\n+            return PreProcessResult(None, f\"{scheme} URL scheme is not supported\")\n+\n+        return PreProcessResult(clean_url, \"ok\")\n \n     @classmethod\n-    def _clean_url(cls, url: str) -> str:\n+    def _clean_url(cls, url: str) -> Optional[str]:\n         \"\"\"\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\n        <DED>if '.' not in host:\n            <IND>return PreProcessResult(None, 'Host is unqualified domain name')\n\n        <DED>if scheme.lower() in ['file']:\n            <IND>return PreProcessResult(None, f'{scheme} URL scheme is not supported')\n\n        <DED>return PreProcessResult(clean_url, 'ok')\n\n    <DED>@classmethod\n    def _clean_url(cls, url: str) -> str:\n        <IND>",
        "target_code_with_indent": "\n        <DED>if \".\" not in host:\n            <IND>return PreProcessResult(None, \"Host is unqualified domain name\")\n\n        <DED>if scheme.lower() in [\"file\"]:\n            <IND>return PreProcessResult(None, f\"{scheme} URL scheme is not supported\")\n\n        <DED>return PreProcessResult(clean_url, \"ok\")\n\n    <DED>@classmethod\n    def _clean_url(cls, url: str) -> Optional[str]:\n        <IND>"
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n            :param cls: the class\n            :param url: the URL to check\n        \"\"\"\n        # slightly stricter than normal URL regex to exclude '() from host string\n        http_strict_regex = r'''\n            (?P<protocol>(https?|ftp|telnet|ldap|file)://)\n",
        "source_code_len": 262,
        "target_code": "\n        Parameters\n        ----------\n        url : str\n            the URL to check\n\n        Returns\n        -------\n        Optional[str]\n            Cleaned URL or None if the input was not a valid URL\n\n        \"\"\"\n        # slightly stricter than normal URL regex to exclude '() from host string\n        http_strict_regex = r\"\"\"\n            (?P<protocol>(https?|ftp|telnet|ldap|file)://)\n",
        "target_code_len": 393,
        "diff_format": "@@ -713,7 +858,15 @@\n \n-            :param cls: the class\n-            :param url: the URL to check\n+        Parameters\n+        ----------\n+        url : str\n+            the URL to check\n+\n+        Returns\n+        -------\n+        Optional[str]\n+            Cleaned URL or None if the input was not a valid URL\n+\n         \"\"\"\n         # slightly stricter than normal URL regex to exclude '() from host string\n-        http_strict_regex = r'''\n+        http_strict_regex = r\"\"\"\n             (?P<protocol>(https?|ftp|telnet|ldap|file)://)\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\n        # slightly stricter than normal URL regex to exclude '() from host string\n        http_strict_regex =",
        "target_code_with_indent": "\n        # slightly stricter than normal URL regex to exclude '() from host string\n        http_strict_regex ="
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "            (\\?(?P<query>([a-z0-9-._~!$&'()*+,;=:/?@]|%[0-9A-F]{2})*))?\n            (\\#(?P<fragment>([a-z0-9-._~!$&'()*+,;=:/?@]|%[0-9A-F]{2})*))?\\b'''\n        if cls._http_strict_rgxc is None:\n            cls._http_strict_rgxc = re.compile(\n                http_strict_regex, re.I | re.X | re.M)\n\n",
        "source_code_len": 298,
        "target_code": "            (\\?(?P<query>([a-z0-9-._~!$&'()*+,;=:/?@]|%[0-9A-F]{2})*))?\n            (\\#(?P<fragment>([a-z0-9-._~!$&'()*+,;=:/?@]|%[0-9A-F]{2})*))?\\b\"\"\"\n        if cls._http_strict_rgxc is None:\n            cls._http_strict_rgxc = re.compile(http_strict_regex, re.I | re.X | re.M)\n\n",
        "target_code_len": 281,
        "diff_format": "@@ -724,6 +877,5 @@\n             (\\?(?P<query>([a-z0-9-._~!$&'()*+,;=:/?@]|%[0-9A-F]{2})*))?\n-            (\\#(?P<fragment>([a-z0-9-._~!$&'()*+,;=:/?@]|%[0-9A-F]{2})*))?\\b'''\n+            (\\#(?P<fragment>([a-z0-9-._~!$&'()*+,;=:/?@]|%[0-9A-F]{2})*))?\\b\"\"\"\n         if cls._http_strict_rgxc is None:\n-            cls._http_strict_rgxc = re.compile(\n-                http_strict_regex, re.I | re.X | re.M)\n+            cls._http_strict_rgxc = re.compile(http_strict_regex, re.I | re.X | re.M)\n \n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\n        if cls._http_strict_rgxc is None:\n            <IND>cls._http_strict_rgxc = re.compile(\n                http_strict_regex, re.I | re.X | re.M)\n\n",
        "target_code_with_indent": "\n        if cls._http_strict_rgxc is None:\n            <IND>cls._http_strict_rgxc = re.compile(http_strict_regex, re.I | re.X | re.M)\n\n"
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "        match_url = cls._http_strict_rgxc.search(url)\n        if (match_url.groupdict()['protocol'] is None or\n                match_url.groupdict()['host'] is None):\n            return None, 'Could not parse as valid URL'\n\n        # build the URL dropping the query string and fragments\n        clean_url = match_url.groupdict()['protocol']\n        if match_url.groupdict()['userinfo']:\n            clean_url += match_url.groupdict()['userinfo']\n        clean_url += match_url.groupdict()['host']\n        if match_url.groupdict()['port']:\n            clean_url += ':' + match_url.groupdict()['port']\n        if match_url.groupdict()['path']:\n            clean_url += '/' + match_url.groupdict()['path']\n\n",
        "source_code_len": 705,
        "target_code": "        match_url = cls._http_strict_rgxc.search(url)\n        if (match_url.groupdict()[\"protocol\"] is None\n                or match_url.groupdict()[\"host\"] is None):\n            return None\n\n        # build the URL dropping the query string and fragments\n        clean_url = match_url.groupdict()[\"protocol\"]\n        if match_url.groupdict()[\"userinfo\"]:\n            clean_url += match_url.groupdict()[\"userinfo\"]\n        clean_url += match_url.groupdict()[\"host\"]\n        if match_url.groupdict()[\"port\"]:\n            clean_url += \":\" + match_url.groupdict()[\"port\"]\n        if match_url.groupdict()[\"path\"]:\n            clean_url += \"/\" + match_url.groupdict()[\"path\"]\n\n",
        "target_code_len": 673,
        "diff_format": "@@ -731,15 +883,15 @@\n         match_url = cls._http_strict_rgxc.search(url)\n-        if (match_url.groupdict()['protocol'] is None or\n-                match_url.groupdict()['host'] is None):\n-            return None, 'Could not parse as valid URL'\n+        if (match_url.groupdict()[\"protocol\"] is None\n+                or match_url.groupdict()[\"host\"] is None):\n+            return None\n \n         # build the URL dropping the query string and fragments\n-        clean_url = match_url.groupdict()['protocol']\n-        if match_url.groupdict()['userinfo']:\n-            clean_url += match_url.groupdict()['userinfo']\n-        clean_url += match_url.groupdict()['host']\n-        if match_url.groupdict()['port']:\n-            clean_url += ':' + match_url.groupdict()['port']\n-        if match_url.groupdict()['path']:\n-            clean_url += '/' + match_url.groupdict()['path']\n+        clean_url = match_url.groupdict()[\"protocol\"]\n+        if match_url.groupdict()[\"userinfo\"]:\n+            clean_url += match_url.groupdict()[\"userinfo\"]\n+        clean_url += match_url.groupdict()[\"host\"]\n+        if match_url.groupdict()[\"port\"]:\n+            clean_url += \":\" + match_url.groupdict()[\"port\"]\n+        if match_url.groupdict()[\"path\"]:\n+            clean_url += \"/\" + match_url.groupdict()[\"path\"]\n \n",
        "source_code_with_indent": "        <DED>match_url = cls._http_strict_rgxc.search(url)\n        if (match_url.groupdict()['protocol'] is None or\n                match_url.groupdict()['host'] is None):\n            <IND>return None, 'Could not parse as valid URL'\n\n        # build the URL dropping the query string and fragments\n        <DED>clean_url = match_url.groupdict()['protocol']\n        if match_url.groupdict()['userinfo']:\n            <IND>clean_url += match_url.groupdict()['userinfo']\n        <DED>clean_url += match_url.groupdict()['host']\n        if match_url.groupdict()['port']:\n            <IND>clean_url += ':' + match_url.groupdict()['port']\n        <DED>if match_url.groupdict()['path']:\n            <IND>clean_url += '/' + match_url.groupdict()['path']\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "        <DED>match_url = cls._http_strict_rgxc.search(url)\n        if (match_url.groupdict()[\"protocol\"] is None\n                or match_url.groupdict()[\"host\"] is None):\n            <IND>return None\n\n        # build the URL dropping the query string and fragments\n        <DED>clean_url = match_url.groupdict()[\"protocol\"]\n        if match_url.groupdict()[\"userinfo\"]:\n            <IND>clean_url += match_url.groupdict()[\"userinfo\"]\n        <DED>clean_url += match_url.groupdict()[\"host\"]\n        if match_url.groupdict()[\"port\"]:\n            <IND>clean_url += \":\" + match_url.groupdict()[\"port\"]\n        <DED>if match_url.groupdict()[\"path\"]:\n            <IND>clean_url += \"/\" + match_url.groupdict()[\"path\"]\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "microsoft/msticpy",
    "commit": "23f0416e8f2b8df83b745e077255859a9bb1b601",
    "filename": "msticpy/sectools/vtlookup.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/microsoft-msticpy/msticpy/sectools/vtlookup.py",
    "file_hunks_size": 64,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "msticpy/sectools/vtlookup.py:815:44 Invalid type [31]: Expression `list(set(str))` is not a valid type.",
    "message": " Expression `list(set(str))` is not a valid type.",
    "rule_id": "Invalid type [31]",
    "warning_line_no": 815,
    "warning_line": "    def _get_supported_vt_ioc_types(cls) -> list({str}):",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    @classmethod\n    def _get_supported_vt_ioc_types(cls) -> list({str}):\n        \"\"\"Return the subset of IoC types supported by VT.\"\"\"\n        return [t for t in cls._SUPPORTED_INPUT_TYPES if cls._VT_TYPE_MAP[t] is not None]\n\n    def _print_status(self, message: str, verbosity_level: str):\n        \"\"\"\n",
        "source_code_len": 304,
        "target_code": "    @classmethod\n    def _get_supported_vt_ioc_types(cls) -> List[str]:\n        \"\"\"Return the subset of IoC types supported by VT.\"\"\"\n        return [\n            t for t in cls._SUPPORTED_INPUT_TYPES if cls._VT_TYPE_MAP[t] is not None\n        ]\n\n    def _print_status(self, message: str, verbosity_level: int):\n        \"\"\"\n",
        "target_code_len": 324,
        "diff_format": "@@ -814,7 +970,9 @@\n     @classmethod\n-    def _get_supported_vt_ioc_types(cls) -> list({str}):\n+    def _get_supported_vt_ioc_types(cls) -> List[str]:\n         \"\"\"Return the subset of IoC types supported by VT.\"\"\"\n-        return [t for t in cls._SUPPORTED_INPUT_TYPES if cls._VT_TYPE_MAP[t] is not None]\n-\n-    def _print_status(self, message: str, verbosity_level: str):\n+        return [\n+            t for t in cls._SUPPORTED_INPUT_TYPES if cls._VT_TYPE_MAP[t] is not None\n+        ]\n+\n+    def _print_status(self, message: str, verbosity_level: int):\n         \"\"\"\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "    <DED>@classmethod\n    def _get_supported_vt_ioc_types(cls) -> list({str}):\n        <IND>\"\"\"Return the subset of IoC types supported by VT.\"\"\"\n        return [t for t in cls._SUPPORTED_INPUT_TYPES if cls._VT_TYPE_MAP[t] is not None]\n\n    <DED>def _print_status(self, message: str, verbosity_level: str):\n        <IND>",
        "target_code_with_indent": "    <DED>@classmethod\n    def _get_supported_vt_ioc_types(cls) -> List[str]:\n        <IND>\"\"\"Return the subset of IoC types supported by VT.\"\"\"\n        return [\n            t for t in cls._SUPPORTED_INPUT_TYPES if cls._VT_TYPE_MAP[t] is not None\n        ]\n\n    <DED>def _print_status(self, message: str, verbosity_level: int):\n        <IND>"
      }
    ]
  },
  {
    "project": "microsoft/msticpy",
    "commit": "23f0416e8f2b8df83b745e077255859a9bb1b601",
    "filename": "msticpy/sectools/vtlookup.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/microsoft-msticpy/msticpy/sectools/vtlookup.py",
    "file_hunks_size": 64,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "msticpy/sectools/vtlookup.py:826:11 Unsupported operand [58]: `<=` is not supported for operand types `str` and `int`.",
    "message": " `<=` is not supported for operand types `str` and `int`.",
    "rule_id": "Unsupported operand [58]",
    "warning_line_no": 826,
    "warning_line": "        if verbosity_level <= self._verbosity:",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    @classmethod\n    def _get_supported_vt_ioc_types(cls) -> list({str}):\n        \"\"\"Return the subset of IoC types supported by VT.\"\"\"\n        return [t for t in cls._SUPPORTED_INPUT_TYPES if cls._VT_TYPE_MAP[t] is not None]\n\n    def _print_status(self, message: str, verbosity_level: str):\n        \"\"\"\n",
        "source_code_len": 304,
        "target_code": "    @classmethod\n    def _get_supported_vt_ioc_types(cls) -> List[str]:\n        \"\"\"Return the subset of IoC types supported by VT.\"\"\"\n        return [\n            t for t in cls._SUPPORTED_INPUT_TYPES if cls._VT_TYPE_MAP[t] is not None\n        ]\n\n    def _print_status(self, message: str, verbosity_level: int):\n        \"\"\"\n",
        "target_code_len": 324,
        "diff_format": "@@ -814,7 +970,9 @@\n     @classmethod\n-    def _get_supported_vt_ioc_types(cls) -> list({str}):\n+    def _get_supported_vt_ioc_types(cls) -> List[str]:\n         \"\"\"Return the subset of IoC types supported by VT.\"\"\"\n-        return [t for t in cls._SUPPORTED_INPUT_TYPES if cls._VT_TYPE_MAP[t] is not None]\n-\n-    def _print_status(self, message: str, verbosity_level: str):\n+        return [\n+            t for t in cls._SUPPORTED_INPUT_TYPES if cls._VT_TYPE_MAP[t] is not None\n+        ]\n+\n+    def _print_status(self, message: str, verbosity_level: int):\n         \"\"\"\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "    <DED>@classmethod\n    def _get_supported_vt_ioc_types(cls) -> list({str}):\n        <IND>\"\"\"Return the subset of IoC types supported by VT.\"\"\"\n        return [t for t in cls._SUPPORTED_INPUT_TYPES if cls._VT_TYPE_MAP[t] is not None]\n\n    <DED>def _print_status(self, message: str, verbosity_level: str):\n        <IND>",
        "target_code_with_indent": "    <DED>@classmethod\n    def _get_supported_vt_ioc_types(cls) -> List[str]:\n        <IND>\"\"\"Return the subset of IoC types supported by VT.\"\"\"\n        return [\n            t for t in cls._SUPPORTED_INPUT_TYPES if cls._VT_TYPE_MAP[t] is not None\n        ]\n\n    <DED>def _print_status(self, message: str, verbosity_level: int):\n        <IND>"
      }
    ]
  }
]