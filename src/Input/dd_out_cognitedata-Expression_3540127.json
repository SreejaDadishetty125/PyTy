[
  {
    "project": "cognitedata/Expression",
    "commit": "35401272e295a746a67211a51563d654e1bf944c",
    "filename": "expression/collections/map.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/cognitedata-Expression/expression/collections/map.py",
    "file_hunks_size": 9,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": true,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "expression/collections/map.py:197:60 Incompatible parameter type [6]: Expected `typing.Callable[[Variable[seq.TSource]], Variable[seq.TResult]]` for 1st positional only parameter to call `seq.map` but got `typing.Callable(expression.core.misc.fst)[[Named(value, Tuple[Variable[expression.core.misc.A], Variable[expression.core.misc.B]])], Variable[expression.core.misc.A]]`.",
    "message": " Expected `typing.Callable[[Variable[seq.TSource]], Variable[seq.TResult]]` for 1st positional only parameter to call `seq.map` but got `typing.Callable(expression.core.misc.fst)[[Named(value, Tuple[Variable[expression.core.misc.A], Variable[expression.core.misc.B]])], Variable[expression.core.misc.A]]`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 197,
    "warning_line": "        return set(pipe(maptree.to_seq(self._tree), seq.map(fst)))",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": true,
        "has_suppression": false,
        "source_code": "\n    def keys(self) -> Set[Key]:\n        return set(pipe(maptree.to_seq(self._tree), seq.map(fst)))\n\n    def value(self) -> Set[Value]:\n        return set(pipe(maptree.to_seq(self._tree), seq.map(snd)))\n\n    def items(self) -> Set[Tuple[Key, Value]]:\n",
        "source_code_len": 251,
        "target_code": "\n    def items(self) -> Set[Tuple[Key, Value]]:\n",
        "target_code_len": 48,
        "diff_format": "@@ -195,8 +182,2 @@\n \n-    def keys(self) -> Set[Key]:\n-        return set(pipe(maptree.to_seq(self._tree), seq.map(fst)))\n-\n-    def value(self) -> Set[Value]:\n-        return set(pipe(maptree.to_seq(self._tree), seq.map(snd)))\n-\n     def items(self) -> Set[Tuple[Key, Value]]:\n",
        "source_code_with_indent": "\n    <DED>def keys(self) -> Set[Key]:\n        <IND>return set(pipe(maptree.to_seq(self._tree), seq.map(fst)))\n\n    <DED>def value(self) -> Set[Value]:\n        <IND>return set(pipe(maptree.to_seq(self._tree), seq.map(snd)))\n\n    <DED>def items(self) -> Set[Tuple[Key, Value]]:\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n    <DED>def items(self) -> Set[Tuple[Key, Value]]:\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "cognitedata/Expression",
    "commit": "35401272e295a746a67211a51563d654e1bf944c",
    "filename": "expression/collections/map.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/cognitedata-Expression/expression/collections/map.py",
    "file_hunks_size": 9,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": true,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "expression/collections/map.py:200:60 Incompatible parameter type [6]: Expected `typing.Callable[[Variable[seq.TSource]], Variable[seq.TResult]]` for 1st positional only parameter to call `seq.map` but got `typing.Callable(expression.core.misc.snd)[[Named(value, Tuple[Variable[expression.core.misc.A], Variable[expression.core.misc.B]])], Variable[expression.core.misc.B]]`.",
    "message": " Expected `typing.Callable[[Variable[seq.TSource]], Variable[seq.TResult]]` for 1st positional only parameter to call `seq.map` but got `typing.Callable(expression.core.misc.snd)[[Named(value, Tuple[Variable[expression.core.misc.A], Variable[expression.core.misc.B]])], Variable[expression.core.misc.B]]`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 200,
    "warning_line": "        return set(pipe(maptree.to_seq(self._tree), seq.map(snd)))",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": true,
        "has_suppression": false,
        "source_code": "\n    def keys(self) -> Set[Key]:\n        return set(pipe(maptree.to_seq(self._tree), seq.map(fst)))\n\n    def value(self) -> Set[Value]:\n        return set(pipe(maptree.to_seq(self._tree), seq.map(snd)))\n\n    def items(self) -> Set[Tuple[Key, Value]]:\n",
        "source_code_len": 251,
        "target_code": "\n    def items(self) -> Set[Tuple[Key, Value]]:\n",
        "target_code_len": 48,
        "diff_format": "@@ -195,8 +182,2 @@\n \n-    def keys(self) -> Set[Key]:\n-        return set(pipe(maptree.to_seq(self._tree), seq.map(fst)))\n-\n-    def value(self) -> Set[Value]:\n-        return set(pipe(maptree.to_seq(self._tree), seq.map(snd)))\n-\n     def items(self) -> Set[Tuple[Key, Value]]:\n",
        "source_code_with_indent": "\n    <DED>def keys(self) -> Set[Key]:\n        <IND>return set(pipe(maptree.to_seq(self._tree), seq.map(fst)))\n\n    <DED>def value(self) -> Set[Value]:\n        <IND>return set(pipe(maptree.to_seq(self._tree), seq.map(snd)))\n\n    <DED>def items(self) -> Set[Tuple[Key, Value]]:\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n    <DED>def items(self) -> Set[Tuple[Key, Value]]:\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "cognitedata/Expression",
    "commit": "35401272e295a746a67211a51563d654e1bf944c",
    "filename": "expression/collections/map.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/cognitedata-Expression/expression/collections/map.py",
    "file_hunks_size": 9,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "expression/collections/map.py:387:21 Incompatible parameter type [6]: Expected `Variable[Value]` for 1st positional only parameter to call `Map.__getitem__` but got `Variable[Key]`.",
    "message": " Expected `Variable[Value]` for 1st positional only parameter to call `Map.__getitem__` but got `Variable[Key]`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 387,
    "warning_line": "        return table[key]",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "        res = 0\n        for x, y in self:\n            res = combine_hash(res, hash(x))\n",
        "source_code_len": 87,
        "target_code": "        res = 0\n        for x, y in maptree.mk_iterator(self._tree):\n            res = combine_hash(res, hash(x))\n",
        "target_code_len": 114,
        "diff_format": "@@ -264,3 +249,3 @@\n         res = 0\n-        for x, y in self:\n+        for x, y in maptree.mk_iterator(self._tree):\n             res = combine_hash(res, hash(x))\n",
        "source_code_with_indent": "        <DED>res = 0\n        for x, y in self:\n            <IND>res = combine_hash(res, hash(x))\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "        <DED>res = 0\n        for x, y in maptree.mk_iterator(self._tree):\n            <IND>res = combine_hash(res, hash(x))\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n    def __getitem__(self, key: Value) -> Value:\n        return maptree.find(key, self._tree)\n\n    def __iter__(self) -> Iterator[Tuple[Key, Value]]:\n        return maptree.mk_iterator(self._tree)\n\n",
        "source_code_len": 198,
        "target_code": "\n    def __getitem__(self, key: Key) -> Value:\n        return maptree.find(key, self._tree)\n\n    def __iter__(self) -> Iterator[Key]:\n        xs = maptree.mk_iterator(self._tree)\n        return (k for (k, _) in xs)\n\n",
        "target_code_len": 216,
        "diff_format": "@@ -269,7 +254,8 @@\n \n-    def __getitem__(self, key: Value) -> Value:\n+    def __getitem__(self, key: Key) -> Value:\n         return maptree.find(key, self._tree)\n \n-    def __iter__(self) -> Iterator[Tuple[Key, Value]]:\n-        return maptree.mk_iterator(self._tree)\n+    def __iter__(self) -> Iterator[Key]:\n+        xs = maptree.mk_iterator(self._tree)\n+        return (k for (k, _) in xs)\n \n",
        "source_code_with_indent": "\n    <DED>def __getitem__(self, key: Value) -> Value:\n        <IND>return maptree.find(key, self._tree)\n\n    <DED>def __iter__(self) -> Iterator[Tuple[Key, Value]]:\n        <IND>return maptree.mk_iterator(self._tree)\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n    <DED>def __getitem__(self, key: Key) -> Value:\n        <IND>return maptree.find(key, self._tree)\n\n    <DED>def __iter__(self) -> Iterator[Key]:\n        <IND>xs = maptree.mk_iterator(self._tree)\n        return (k for (k, _) in xs)\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "cognitedata/Expression",
    "commit": "35401272e295a746a67211a51563d654e1bf944c",
    "filename": "expression/collections/map.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/cognitedata-Expression/expression/collections/map.py",
    "file_hunks_size": 9,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "expression/collections/map.py:439:12 Incompatible return type [7]: Expected `expression.core.option.Option[Variable[Result]]` but got `Variable[Result]`.",
    "message": " Expected `expression.core.option.Option[Variable[Result]]` but got `Variable[Result]`.",
    "rule_id": "Incompatible return type [7]",
    "warning_line_no": 439,
    "warning_line": "            return res"
  },
  {
    "project": "cognitedata/Expression",
    "commit": "35401272e295a746a67211a51563d654e1bf944c",
    "filename": "expression/collections/map.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/cognitedata-Expression/expression/collections/map.py",
    "file_hunks_size": 9,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "expression/collections/map.py:441:12 Incompatible return type [7]: Expected `expression.core.option.Option[Variable[Result]]` but got implicit return value of `None`.",
    "message": " Expected `expression.core.option.Option[Variable[Result]]` but got implicit return value of `None`.",
    "rule_id": "Incompatible return type [7]",
    "warning_line_no": 441,
    "warning_line": "            raise KeyError()"
  },
  {
    "project": "cognitedata/Expression",
    "commit": "35401272e295a746a67211a51563d654e1bf944c",
    "filename": "expression/collections/map.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/cognitedata-Expression/expression/collections/map.py",
    "file_hunks_size": 9,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "expression/collections/map.py:496:4 Incompatible return type [7]: Expected `Variable[Result]` but got `typing.Callable[[Named(state, Variable[Result])], Variable[Result]]`.",
    "message": " Expected `Variable[Result]` but got `typing.Callable[[Named(state, Variable[Result])], Variable[Result]]`.",
    "rule_id": "Incompatible return type [7]",
    "warning_line_no": 496,
    "warning_line": "    return _fold_back",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\ndef fold_back(folder: Callable[[Tuple[Key, Value], Result], Result], table: Map[Key, Value]) -> Result:\n    def _fold_back(state: Result) -> Result:\n",
        "source_code_len": 150,
        "target_code": "\ndef fold_back(\n    folder: Callable[[Tuple[Key, Value], Result], Result], table: Map[Key, Value]\n) -> Callable[[Result], Result]:\n    def _fold_back(state: Result) -> Result:\n",
        "target_code_len": 176,
        "diff_format": "@@ -491,3 +477,5 @@\n \n-def fold_back(folder: Callable[[Tuple[Key, Value], Result], Result], table: Map[Key, Value]) -> Result:\n+def fold_back(\n+    folder: Callable[[Tuple[Key, Value], Result], Result], table: Map[Key, Value]\n+) -> Callable[[Result], Result]:\n     def _fold_back(state: Result) -> Result:\n",
        "source_code_with_indent": "\n<DED>def fold_back(folder: Callable[[Tuple[Key, Value], Result], Result], table: Map[Key, Value]) -> Result:\n    <IND>def _fold_back(state: Result) -> Result:\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n<DED>def fold_back(\n    folder: Callable[[Tuple[Key, Value], Result], Result], table: Map[Key, Value]\n) -> Callable[[Result], Result]:\n    <IND>def _fold_back(state: Result) -> Result:\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "cognitedata/Expression",
    "commit": "35401272e295a746a67211a51563d654e1bf944c",
    "filename": "expression/core/typing.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/cognitedata-Expression/expression/core/typing.py",
    "file_hunks_size": 7,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "expression/core/typing.py:42:28 Incompatible parameter type [6]: Expected `typing.Union[typing.Type[typing.Any], typing.Tuple[typing.Type[typing.Any], ...]]` for 2nd positional only parameter to call `isinstance` but got `Variable[Base]`.",
    "message": " Expected `typing.Union[typing.Type[typing.Any], typing.Tuple[typing.Type[typing.Any], ...]]` for 2nd positional only parameter to call `isinstance` but got `Variable[Base]`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 42,
    "warning_line": "    assert isinstance(expr, type), f\"The type of expression {expr} is not a supertype of {type}\"",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "from abc import abstractmethod\nfrom typing import Any, Optional, TypeVar, cast, get_origin\n\nfrom typing_extensions import Protocol\n\n",
        "source_code_len": 132,
        "target_code": "from typing import Optional, Type, TypeVar, cast, get_origin\n\n",
        "target_code_len": 62,
        "diff_format": "@@ -1,5 +1,2 @@\n-from abc import abstractmethod\n-from typing import Any, Optional, TypeVar, cast, get_origin\n-\n-from typing_extensions import Protocol\n+from typing import Optional, Type, TypeVar, cast, get_origin\n \n",
        "source_code_with_indent": "from abc import abstractmethod\nfrom typing import Any, Optional, TypeVar, cast, get_origin\n\nfrom typing_extensions import Protocol\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "from typing import Optional, Type, TypeVar, cast, get_origin\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\nclass Comparable(Protocol):\n    @abstractmethod\n    def __eq__(self, other: Any) -> bool:\n        pass\n\n    @abstractmethod\n    def __lt__(self: C, other: C) -> bool:\n        pass\n\n    def __gt__(self: C, other: C) -> bool:\n        return (not self < other) and self != other\n\n    def __le__(self: C, other: C) -> bool:\n        return self < other or self == other\n\n    def __ge__(self: C, other: C) -> bool:\n        return not self < other\n\n\ndef downcast(type: Base, expr: Derived) -> Base:\n    \"\"\"Downcast expression `Derived` to `Base`\n",
        "source_code_len": 540,
        "target_code": "\ndef downcast(type: Type[Derived], expr: Base) -> Derived:\n    \"\"\"Downcast expression `Derived` to `Base`\n",
        "target_code_len": 106,
        "diff_format": "@@ -14,22 +10,3 @@\n \n-class Comparable(Protocol):\n-    @abstractmethod\n-    def __eq__(self, other: Any) -> bool:\n-        pass\n-\n-    @abstractmethod\n-    def __lt__(self: C, other: C) -> bool:\n-        pass\n-\n-    def __gt__(self: C, other: C) -> bool:\n-        return (not self < other) and self != other\n-\n-    def __le__(self: C, other: C) -> bool:\n-        return self < other or self == other\n-\n-    def __ge__(self: C, other: C) -> bool:\n-        return not self < other\n-\n-\n-def downcast(type: Base, expr: Derived) -> Base:\n+def downcast(type: Type[Derived], expr: Base) -> Derived:\n     \"\"\"Downcast expression `Derived` to `Base`\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\nclass Comparable(Protocol):\n    <IND>@abstractmethod\n    def __eq__(self, other: Any) -> bool:\n        <IND>pass\n\n    <DED>@abstractmethod\n    def __lt__(self: C, other: C) -> bool:\n        <IND>pass\n\n    <DED>def __gt__(self: C, other: C) -> bool:\n        <IND>return (not self < other) and self != other\n\n    <DED>def __le__(self: C, other: C) -> bool:\n        <IND>return self < other or self == other\n\n    <DED>def __ge__(self: C, other: C) -> bool:\n        <IND>return not self < other\n\n\n<DED><DED>def downcast(type: Base, expr: Derived) -> Base:\n    <IND>",
        "target_code_with_indent": "\ndef downcast(type: Type[Derived], expr: Base) -> Derived:\n    <IND>"
      },
      {
        "hunk_fit_TFix": true,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    assert isinstance(expr, type), f\"The type of expression {expr} is not a supertype of {type}\"\n    return expr\n\n\ndef upcast(type: Derived, expr: Base) -> Derived:\n    \"\"\"Upcast expression `Base` to `Derived`.\n\n",
        "source_code_len": 212,
        "target_code": "    assert isinstance(expr, type), f\"The type of expression {expr} is not a supertype of {type}\"\n    return cast(type, expr)\n\n\ndef upcast(type: Type[Base], expr: Derived) -> Base:\n    \"\"\"Upcast expression `Derived` to `Base`.\n\n",
        "target_code_len": 227,
        "diff_format": "@@ -42,7 +19,7 @@\n     assert isinstance(expr, type), f\"The type of expression {expr} is not a supertype of {type}\"\n-    return expr\n+    return cast(type, expr)\n \n \n-def upcast(type: Derived, expr: Base) -> Derived:\n-    \"\"\"Upcast expression `Base` to `Derived`.\n+def upcast(type: Type[Base], expr: Derived) -> Base:\n+    \"\"\"Upcast expression `Derived` to `Base`.\n \n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "    assert isinstance(expr, type), f\"The type of expression {expr} is not a supertype of {type}\"\n    return expr\n\n\n<DED>def upcast(type: Derived, expr: Base) -> Derived:\n    <IND>",
        "target_code_with_indent": "    assert isinstance(expr, type), f\"The type of expression {expr} is not a supertype of {type}\"\n    return cast(type, expr)\n\n\n<DED>def upcast(type: Type[Base], expr: Derived) -> Base:\n    <IND>"
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    \"\"\"\n    origin: Optional[Derived] = get_origin(type_) or type_\n    if origin is not None and isinstance(expr, origin):\n",
        "source_code_len": 123,
        "target_code": "    \"\"\"\n    origin: Optional[Type[Derived]] = get_origin(type_) or type_\n    if origin is not None and isinstance(expr, origin):\n",
        "target_code_len": 129,
        "diff_format": "@@ -67,3 +44,3 @@\n     \"\"\"\n-    origin: Optional[Derived] = get_origin(type_) or type_\n+    origin: Optional[Type[Derived]] = get_origin(type_) or type_\n     if origin is not None and isinstance(expr, origin):\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\n    origin: Optional[Derived] = get_origin(type_) or type_\n    if origin is not None and isinstance(expr, origin):\n",
        "target_code_with_indent": "\n    origin: Optional[Type[Derived]] = get_origin(type_) or type_\n    if origin is not None and isinstance(expr, origin):\n"
      }
    ]
  },
  {
    "project": "cognitedata/Expression",
    "commit": "35401272e295a746a67211a51563d654e1bf944c",
    "filename": "expression/core/typing.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/cognitedata-Expression/expression/core/typing.py",
    "file_hunks_size": 7,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "expression/core/typing.py:54:28 Incompatible parameter type [6]: Expected `typing.Union[typing.Type[typing.Any], typing.Tuple[typing.Type[typing.Any], ...]]` for 2nd positional only parameter to call `isinstance` but got `Variable[Derived]`.",
    "message": " Expected `typing.Union[typing.Type[typing.Any], typing.Tuple[typing.Type[typing.Any], ...]]` for 2nd positional only parameter to call `isinstance` but got `Variable[Derived]`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 54,
    "warning_line": "    assert isinstance(expr, type), f\"The expression {expr} is not derived from type {type}\"",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "from abc import abstractmethod\nfrom typing import Any, Optional, TypeVar, cast, get_origin\n\nfrom typing_extensions import Protocol\n\n",
        "source_code_len": 132,
        "target_code": "from typing import Optional, Type, TypeVar, cast, get_origin\n\n",
        "target_code_len": 62,
        "diff_format": "@@ -1,5 +1,2 @@\n-from abc import abstractmethod\n-from typing import Any, Optional, TypeVar, cast, get_origin\n-\n-from typing_extensions import Protocol\n+from typing import Optional, Type, TypeVar, cast, get_origin\n \n",
        "source_code_with_indent": "from abc import abstractmethod\nfrom typing import Any, Optional, TypeVar, cast, get_origin\n\nfrom typing_extensions import Protocol\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "from typing import Optional, Type, TypeVar, cast, get_origin\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\nclass Comparable(Protocol):\n    @abstractmethod\n    def __eq__(self, other: Any) -> bool:\n        pass\n\n    @abstractmethod\n    def __lt__(self: C, other: C) -> bool:\n        pass\n\n    def __gt__(self: C, other: C) -> bool:\n        return (not self < other) and self != other\n\n    def __le__(self: C, other: C) -> bool:\n        return self < other or self == other\n\n    def __ge__(self: C, other: C) -> bool:\n        return not self < other\n\n\ndef downcast(type: Base, expr: Derived) -> Base:\n    \"\"\"Downcast expression `Derived` to `Base`\n",
        "source_code_len": 540,
        "target_code": "\ndef downcast(type: Type[Derived], expr: Base) -> Derived:\n    \"\"\"Downcast expression `Derived` to `Base`\n",
        "target_code_len": 106,
        "diff_format": "@@ -14,22 +10,3 @@\n \n-class Comparable(Protocol):\n-    @abstractmethod\n-    def __eq__(self, other: Any) -> bool:\n-        pass\n-\n-    @abstractmethod\n-    def __lt__(self: C, other: C) -> bool:\n-        pass\n-\n-    def __gt__(self: C, other: C) -> bool:\n-        return (not self < other) and self != other\n-\n-    def __le__(self: C, other: C) -> bool:\n-        return self < other or self == other\n-\n-    def __ge__(self: C, other: C) -> bool:\n-        return not self < other\n-\n-\n-def downcast(type: Base, expr: Derived) -> Base:\n+def downcast(type: Type[Derived], expr: Base) -> Derived:\n     \"\"\"Downcast expression `Derived` to `Base`\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\nclass Comparable(Protocol):\n    <IND>@abstractmethod\n    def __eq__(self, other: Any) -> bool:\n        <IND>pass\n\n    <DED>@abstractmethod\n    def __lt__(self: C, other: C) -> bool:\n        <IND>pass\n\n    <DED>def __gt__(self: C, other: C) -> bool:\n        <IND>return (not self < other) and self != other\n\n    <DED>def __le__(self: C, other: C) -> bool:\n        <IND>return self < other or self == other\n\n    <DED>def __ge__(self: C, other: C) -> bool:\n        <IND>return not self < other\n\n\n<DED><DED>def downcast(type: Base, expr: Derived) -> Base:\n    <IND>",
        "target_code_with_indent": "\ndef downcast(type: Type[Derived], expr: Base) -> Derived:\n    <IND>"
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    assert isinstance(expr, type), f\"The type of expression {expr} is not a supertype of {type}\"\n    return expr\n\n\ndef upcast(type: Derived, expr: Base) -> Derived:\n    \"\"\"Upcast expression `Base` to `Derived`.\n\n",
        "source_code_len": 212,
        "target_code": "    assert isinstance(expr, type), f\"The type of expression {expr} is not a supertype of {type}\"\n    return cast(type, expr)\n\n\ndef upcast(type: Type[Base], expr: Derived) -> Base:\n    \"\"\"Upcast expression `Derived` to `Base`.\n\n",
        "target_code_len": 227,
        "diff_format": "@@ -42,7 +19,7 @@\n     assert isinstance(expr, type), f\"The type of expression {expr} is not a supertype of {type}\"\n-    return expr\n+    return cast(type, expr)\n \n \n-def upcast(type: Derived, expr: Base) -> Derived:\n-    \"\"\"Upcast expression `Base` to `Derived`.\n+def upcast(type: Type[Base], expr: Derived) -> Base:\n+    \"\"\"Upcast expression `Derived` to `Base`.\n \n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "    assert isinstance(expr, type), f\"The type of expression {expr} is not a supertype of {type}\"\n    return expr\n\n\n<DED>def upcast(type: Derived, expr: Base) -> Derived:\n    <IND>",
        "target_code_with_indent": "    assert isinstance(expr, type), f\"The type of expression {expr} is not a supertype of {type}\"\n    return cast(type, expr)\n\n\n<DED>def upcast(type: Type[Base], expr: Derived) -> Base:\n    <IND>"
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    \"\"\"\n    origin: Optional[Derived] = get_origin(type_) or type_\n    if origin is not None and isinstance(expr, origin):\n",
        "source_code_len": 123,
        "target_code": "    \"\"\"\n    origin: Optional[Type[Derived]] = get_origin(type_) or type_\n    if origin is not None and isinstance(expr, origin):\n",
        "target_code_len": 129,
        "diff_format": "@@ -67,3 +44,3 @@\n     \"\"\"\n-    origin: Optional[Derived] = get_origin(type_) or type_\n+    origin: Optional[Type[Derived]] = get_origin(type_) or type_\n     if origin is not None and isinstance(expr, origin):\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\n    origin: Optional[Derived] = get_origin(type_) or type_\n    if origin is not None and isinstance(expr, origin):\n",
        "target_code_with_indent": "\n    origin: Optional[Type[Derived]] = get_origin(type_) or type_\n    if origin is not None and isinstance(expr, origin):\n"
      }
    ]
  },
  {
    "project": "cognitedata/Expression",
    "commit": "35401272e295a746a67211a51563d654e1bf944c",
    "filename": "expression/core/typing.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/cognitedata-Expression/expression/core/typing.py",
    "file_hunks_size": 7,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "expression/core/typing.py:69:47 Incompatible parameter type [6]: Expected `typing.Union[typing.Type[typing.Any], typing.Tuple[typing.Type[typing.Any], ...]]` for 2nd positional only parameter to call `isinstance` but got `Variable[Derived]`.",
    "message": " Expected `typing.Union[typing.Type[typing.Any], typing.Tuple[typing.Type[typing.Any], ...]]` for 2nd positional only parameter to call `isinstance` but got `Variable[Derived]`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 69,
    "warning_line": "    if origin is not None and isinstance(expr, origin):",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "from abc import abstractmethod\nfrom typing import Any, Optional, TypeVar, cast, get_origin\n\nfrom typing_extensions import Protocol\n\n",
        "source_code_len": 132,
        "target_code": "from typing import Optional, Type, TypeVar, cast, get_origin\n\n",
        "target_code_len": 62,
        "diff_format": "@@ -1,5 +1,2 @@\n-from abc import abstractmethod\n-from typing import Any, Optional, TypeVar, cast, get_origin\n-\n-from typing_extensions import Protocol\n+from typing import Optional, Type, TypeVar, cast, get_origin\n \n",
        "source_code_with_indent": "from abc import abstractmethod\nfrom typing import Any, Optional, TypeVar, cast, get_origin\n\nfrom typing_extensions import Protocol\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "from typing import Optional, Type, TypeVar, cast, get_origin\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\nclass Comparable(Protocol):\n    @abstractmethod\n    def __eq__(self, other: Any) -> bool:\n        pass\n\n    @abstractmethod\n    def __lt__(self: C, other: C) -> bool:\n        pass\n\n    def __gt__(self: C, other: C) -> bool:\n        return (not self < other) and self != other\n\n    def __le__(self: C, other: C) -> bool:\n        return self < other or self == other\n\n    def __ge__(self: C, other: C) -> bool:\n        return not self < other\n\n\ndef downcast(type: Base, expr: Derived) -> Base:\n    \"\"\"Downcast expression `Derived` to `Base`\n",
        "source_code_len": 540,
        "target_code": "\ndef downcast(type: Type[Derived], expr: Base) -> Derived:\n    \"\"\"Downcast expression `Derived` to `Base`\n",
        "target_code_len": 106,
        "diff_format": "@@ -14,22 +10,3 @@\n \n-class Comparable(Protocol):\n-    @abstractmethod\n-    def __eq__(self, other: Any) -> bool:\n-        pass\n-\n-    @abstractmethod\n-    def __lt__(self: C, other: C) -> bool:\n-        pass\n-\n-    def __gt__(self: C, other: C) -> bool:\n-        return (not self < other) and self != other\n-\n-    def __le__(self: C, other: C) -> bool:\n-        return self < other or self == other\n-\n-    def __ge__(self: C, other: C) -> bool:\n-        return not self < other\n-\n-\n-def downcast(type: Base, expr: Derived) -> Base:\n+def downcast(type: Type[Derived], expr: Base) -> Derived:\n     \"\"\"Downcast expression `Derived` to `Base`\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\nclass Comparable(Protocol):\n    <IND>@abstractmethod\n    def __eq__(self, other: Any) -> bool:\n        <IND>pass\n\n    <DED>@abstractmethod\n    def __lt__(self: C, other: C) -> bool:\n        <IND>pass\n\n    <DED>def __gt__(self: C, other: C) -> bool:\n        <IND>return (not self < other) and self != other\n\n    <DED>def __le__(self: C, other: C) -> bool:\n        <IND>return self < other or self == other\n\n    <DED>def __ge__(self: C, other: C) -> bool:\n        <IND>return not self < other\n\n\n<DED><DED>def downcast(type: Base, expr: Derived) -> Base:\n    <IND>",
        "target_code_with_indent": "\ndef downcast(type: Type[Derived], expr: Base) -> Derived:\n    <IND>"
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    assert isinstance(expr, type), f\"The type of expression {expr} is not a supertype of {type}\"\n    return expr\n\n\ndef upcast(type: Derived, expr: Base) -> Derived:\n    \"\"\"Upcast expression `Base` to `Derived`.\n\n",
        "source_code_len": 212,
        "target_code": "    assert isinstance(expr, type), f\"The type of expression {expr} is not a supertype of {type}\"\n    return cast(type, expr)\n\n\ndef upcast(type: Type[Base], expr: Derived) -> Base:\n    \"\"\"Upcast expression `Derived` to `Base`.\n\n",
        "target_code_len": 227,
        "diff_format": "@@ -42,7 +19,7 @@\n     assert isinstance(expr, type), f\"The type of expression {expr} is not a supertype of {type}\"\n-    return expr\n+    return cast(type, expr)\n \n \n-def upcast(type: Derived, expr: Base) -> Derived:\n-    \"\"\"Upcast expression `Base` to `Derived`.\n+def upcast(type: Type[Base], expr: Derived) -> Base:\n+    \"\"\"Upcast expression `Derived` to `Base`.\n \n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "    assert isinstance(expr, type), f\"The type of expression {expr} is not a supertype of {type}\"\n    return expr\n\n\n<DED>def upcast(type: Derived, expr: Base) -> Derived:\n    <IND>",
        "target_code_with_indent": "    assert isinstance(expr, type), f\"The type of expression {expr} is not a supertype of {type}\"\n    return cast(type, expr)\n\n\n<DED>def upcast(type: Type[Base], expr: Derived) -> Base:\n    <IND>"
      },
      {
        "hunk_fit_TFix": true,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    \"\"\"\n    origin: Optional[Derived] = get_origin(type_) or type_\n    if origin is not None and isinstance(expr, origin):\n",
        "source_code_len": 123,
        "target_code": "    \"\"\"\n    origin: Optional[Type[Derived]] = get_origin(type_) or type_\n    if origin is not None and isinstance(expr, origin):\n",
        "target_code_len": 129,
        "diff_format": "@@ -67,3 +44,3 @@\n     \"\"\"\n-    origin: Optional[Derived] = get_origin(type_) or type_\n+    origin: Optional[Type[Derived]] = get_origin(type_) or type_\n     if origin is not None and isinstance(expr, origin):\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\n    origin: Optional[Derived] = get_origin(type_) or type_\n    if origin is not None and isinstance(expr, origin):\n",
        "target_code_with_indent": "\n    origin: Optional[Type[Derived]] = get_origin(type_) or type_\n    if origin is not None and isinstance(expr, origin):\n"
      }
    ]
  },
  {
    "project": "cognitedata/Expression",
    "commit": "35401272e295a746a67211a51563d654e1bf944c",
    "filename": "expression/core/typing.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/cognitedata-Expression/expression/core/typing.py",
    "file_hunks_size": 7,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "expression/core/typing.py:70:23 Invalid type [31]: Expression `type($parameter$type_)` is not a valid type.",
    "message": " Expression `type($parameter$type_)` is not a valid type.",
    "rule_id": "Invalid type [31]",
    "warning_line_no": 70,
    "warning_line": "        derived = cast(type(type_), expr)",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "from abc import abstractmethod\nfrom typing import Any, Optional, TypeVar, cast, get_origin\n\nfrom typing_extensions import Protocol\n\n",
        "source_code_len": 132,
        "target_code": "from typing import Optional, Type, TypeVar, cast, get_origin\n\n",
        "target_code_len": 62,
        "diff_format": "@@ -1,5 +1,2 @@\n-from abc import abstractmethod\n-from typing import Any, Optional, TypeVar, cast, get_origin\n-\n-from typing_extensions import Protocol\n+from typing import Optional, Type, TypeVar, cast, get_origin\n \n",
        "source_code_with_indent": "from abc import abstractmethod\nfrom typing import Any, Optional, TypeVar, cast, get_origin\n\nfrom typing_extensions import Protocol\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "from typing import Optional, Type, TypeVar, cast, get_origin\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\nclass Comparable(Protocol):\n    @abstractmethod\n    def __eq__(self, other: Any) -> bool:\n        pass\n\n    @abstractmethod\n    def __lt__(self: C, other: C) -> bool:\n        pass\n\n    def __gt__(self: C, other: C) -> bool:\n        return (not self < other) and self != other\n\n    def __le__(self: C, other: C) -> bool:\n        return self < other or self == other\n\n    def __ge__(self: C, other: C) -> bool:\n        return not self < other\n\n\ndef downcast(type: Base, expr: Derived) -> Base:\n    \"\"\"Downcast expression `Derived` to `Base`\n",
        "source_code_len": 540,
        "target_code": "\ndef downcast(type: Type[Derived], expr: Base) -> Derived:\n    \"\"\"Downcast expression `Derived` to `Base`\n",
        "target_code_len": 106,
        "diff_format": "@@ -14,22 +10,3 @@\n \n-class Comparable(Protocol):\n-    @abstractmethod\n-    def __eq__(self, other: Any) -> bool:\n-        pass\n-\n-    @abstractmethod\n-    def __lt__(self: C, other: C) -> bool:\n-        pass\n-\n-    def __gt__(self: C, other: C) -> bool:\n-        return (not self < other) and self != other\n-\n-    def __le__(self: C, other: C) -> bool:\n-        return self < other or self == other\n-\n-    def __ge__(self: C, other: C) -> bool:\n-        return not self < other\n-\n-\n-def downcast(type: Base, expr: Derived) -> Base:\n+def downcast(type: Type[Derived], expr: Base) -> Derived:\n     \"\"\"Downcast expression `Derived` to `Base`\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\nclass Comparable(Protocol):\n    <IND>@abstractmethod\n    def __eq__(self, other: Any) -> bool:\n        <IND>pass\n\n    <DED>@abstractmethod\n    def __lt__(self: C, other: C) -> bool:\n        <IND>pass\n\n    <DED>def __gt__(self: C, other: C) -> bool:\n        <IND>return (not self < other) and self != other\n\n    <DED>def __le__(self: C, other: C) -> bool:\n        <IND>return self < other or self == other\n\n    <DED>def __ge__(self: C, other: C) -> bool:\n        <IND>return not self < other\n\n\n<DED><DED>def downcast(type: Base, expr: Derived) -> Base:\n    <IND>",
        "target_code_with_indent": "\ndef downcast(type: Type[Derived], expr: Base) -> Derived:\n    <IND>"
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    assert isinstance(expr, type), f\"The type of expression {expr} is not a supertype of {type}\"\n    return expr\n\n\ndef upcast(type: Derived, expr: Base) -> Derived:\n    \"\"\"Upcast expression `Base` to `Derived`.\n\n",
        "source_code_len": 212,
        "target_code": "    assert isinstance(expr, type), f\"The type of expression {expr} is not a supertype of {type}\"\n    return cast(type, expr)\n\n\ndef upcast(type: Type[Base], expr: Derived) -> Base:\n    \"\"\"Upcast expression `Derived` to `Base`.\n\n",
        "target_code_len": 227,
        "diff_format": "@@ -42,7 +19,7 @@\n     assert isinstance(expr, type), f\"The type of expression {expr} is not a supertype of {type}\"\n-    return expr\n+    return cast(type, expr)\n \n \n-def upcast(type: Derived, expr: Base) -> Derived:\n-    \"\"\"Upcast expression `Base` to `Derived`.\n+def upcast(type: Type[Base], expr: Derived) -> Base:\n+    \"\"\"Upcast expression `Derived` to `Base`.\n \n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "    assert isinstance(expr, type), f\"The type of expression {expr} is not a supertype of {type}\"\n    return expr\n\n\n<DED>def upcast(type: Derived, expr: Base) -> Derived:\n    <IND>",
        "target_code_with_indent": "    assert isinstance(expr, type), f\"The type of expression {expr} is not a supertype of {type}\"\n    return cast(type, expr)\n\n\n<DED>def upcast(type: Type[Base], expr: Derived) -> Base:\n    <IND>"
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    \"\"\"\n    origin: Optional[Derived] = get_origin(type_) or type_\n    if origin is not None and isinstance(expr, origin):\n",
        "source_code_len": 123,
        "target_code": "    \"\"\"\n    origin: Optional[Type[Derived]] = get_origin(type_) or type_\n    if origin is not None and isinstance(expr, origin):\n",
        "target_code_len": 129,
        "diff_format": "@@ -67,3 +44,3 @@\n     \"\"\"\n-    origin: Optional[Derived] = get_origin(type_) or type_\n+    origin: Optional[Type[Derived]] = get_origin(type_) or type_\n     if origin is not None and isinstance(expr, origin):\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\n    origin: Optional[Derived] = get_origin(type_) or type_\n    if origin is not None and isinstance(expr, origin):\n",
        "target_code_with_indent": "\n    origin: Optional[Type[Derived]] = get_origin(type_) or type_\n    if origin is not None and isinstance(expr, origin):\n"
      }
    ]
  }
]