[
  {
    "project": "golemfactory/clay",
    "commit": "d291323078d2bf6f8745a297c1a6fb54f9dd02f5",
    "filename": "apps/blender/blender_reference_generator.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/golemfactory-clay/apps/blender/blender_reference_generator.py",
    "file_hunks_size": 18,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "apps/blender/blender_reference_generator.py:53:8 Incompatible attribute type [8]: Attribute `crop_size` declared in class `BlenderReferenceGenerator` has type `Tuple[float, float]` but is used as type `Tuple[]`.",
    "message": " Attribute `crop_size` declared in class `BlenderReferenceGenerator` has type `Tuple[float, float]` but is used as type `Tuple[]`.",
    "rule_id": "Incompatible attribute type [8]",
    "warning_line_no": 53,
    "warning_line": "        self.crop_size: Tuple[float, float] = ()",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "# pylint: disable=R0902\nclass CropContext:\n    def __init__(self, crops_data: Dict[str, Any], computer,\n",
        "source_code_len": 104,
        "target_code": "# pylint: disable=R0902\nclass VerificationContext:\n    def __init__(self, crops_data: Dict[str, Any], computer,\n",
        "target_code_len": 112,
        "diff_format": "@@ -20,3 +20,3 @@\n # pylint: disable=R0902\n-class CropContext:\n+class VerificationContext:\n     def __init__(self, crops_data: Dict[str, Any], computer,\n",
        "source_code_with_indent": "# pylint: disable=R0902\nclass CropContext:\n    <IND>def __init__(self, crops_data: Dict[str, Any], computer,\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "# pylint: disable=R0902\nclass VerificationContext:\n    <IND>def __init__(self, crops_data: Dict[str, Any], computer,\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "        self.crops_path = crops_data['paths']\n        self.crop_values = crops_data['position'][0]\n        self.crop_pixels = crops_data['position'][1]\n        self.computer = computer\n",
        "source_code_len": 185,
        "target_code": "        self.crops_path = crops_data['paths']\n        self.crops_floating_point_coordinates = crops_data['position'][0]\n        self.crops_pixel_coordinates = crops_data['position'][1]\n        self.computer = computer\n",
        "target_code_len": 218,
        "diff_format": "@@ -25,4 +25,4 @@\n         self.crops_path = crops_data['paths']\n-        self.crop_values = crops_data['position'][0]\n-        self.crop_pixels = crops_data['position'][1]\n+        self.crops_floating_point_coordinates = crops_data['position'][0]\n+        self.crops_pixel_coordinates = crops_data['position'][1]\n         self.computer = computer\n",
        "source_code_with_indent": "        <IND>self.crops_path = crops_data['paths']\n        self.crop_values = crops_data['position'][0]\n        self.crop_pixels = crops_data['position'][1]\n        self.computer = computer\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "        <IND>self.crops_path = crops_data['paths']\n        self.crops_floating_point_coordinates = crops_data['position'][0]\n        self.crops_pixel_coordinates = crops_data['position'][1]\n        self.computer = computer\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "        self.success = callbacks['success']\n        self.errback = callbacks['errback']\n        self.crop_size = crops_data['position'][2]\n\n    def get_crop_path(self, crop_number):\n        return os.path.join(self.crops_path, str(crop_number))\n",
        "source_code_len": 245,
        "target_code": "        self.success = callbacks['success']\n        self.error_callback = callbacks['errback']\n        self.crop_size = crops_data['position'][2]\n\n    def get_crop_path(self, crop_number: int) -> str:\n        return os.path.join(self.crops_path, str(crop_number))\n",
        "target_code_len": 264,
        "diff_format": "@@ -31,6 +31,6 @@\n         self.success = callbacks['success']\n-        self.errback = callbacks['errback']\n+        self.error_callback = callbacks['errback']\n         self.crop_size = crops_data['position'][2]\n \n-    def get_crop_path(self, crop_number):\n+    def get_crop_path(self, crop_number: int) -> str:\n         return os.path.join(self.crops_path, str(crop_number))\n",
        "source_code_with_indent": "        self.success = callbacks['success']\n        self.errback = callbacks['errback']\n        self.crop_size = crops_data['position'][2]\n\n    <DED>def get_crop_path(self, crop_number):\n        <IND>return os.path.join(self.crops_path, str(crop_number))\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "        self.success = callbacks['success']\n        self.error_callback = callbacks['errback']\n        self.crop_size = crops_data['position'][2]\n\n    <DED>def get_crop_path(self, crop_number: int) -> str:\n        <IND>return os.path.join(self.crops_path, str(crop_number))\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\nCropRenderedSuccessCallback = Callable[[List[str], float, CropContext, int],\n                                       None]\nCropRenderedFailureCallback = Callable[[Exception], None]\n\n",
        "source_code_len": 182,
        "target_code": "\nCropRenderedSuccessCallbackType = Callable[[List[str],\n                                            float,\n                                            VerificationContext,\n                                            int],\n                                           None]\nCropRenderedFailureCallbackType = Callable[[Exception], None]\n\n",
        "target_code_len": 334,
        "diff_format": "@@ -38,5 +38,8 @@\n \n-CropRenderedSuccessCallback = Callable[[List[str], float, CropContext, int],\n-                                       None]\n-CropRenderedFailureCallback = Callable[[Exception], None]\n+CropRenderedSuccessCallbackType = Callable[[List[str],\n+                                            float,\n+                                            VerificationContext,\n+                                            int],\n+                                           None]\n+CropRenderedFailureCallbackType = Callable[[Exception], None]\n \n",
        "source_code_with_indent": "\n<DED><DED>CropRenderedSuccessCallback = Callable[[List[str], float, CropContext, int],\n                                       None]\nCropRenderedFailureCallback = Callable[[Exception], None]\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n<DED><DED>CropRenderedSuccessCallbackType = Callable[[List[str],\n                                            float,\n                                            VerificationContext,\n                                            int],\n                                           None]\nCropRenderedFailureCallbackType = Callable[[Exception], None]\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "class BlenderReferenceGenerator:\n    MIN_CROP_RES = 8\n    CROP_STEP = 0.01\n    CROPS_NO_FIRST = 3\n    CROPS_NO_SECOND = 6\n\n",
        "source_code_len": 123,
        "target_code": "class BlenderReferenceGenerator:\n    MIN_CROP_SIZE = 8\n    CROP_RELATIVE_SIZE = 0.01\n    DEFAULT_CROPS_NUMBER_FIRST_VERIFICATION_STEP = 3\n    DEFAULT_CROPS_NUMBER_SECOND_VERIFICATION_STEP = 6\n\n",
        "target_code_len": 193,
        "diff_format": "@@ -44,6 +47,6 @@\n class BlenderReferenceGenerator:\n-    MIN_CROP_RES = 8\n-    CROP_STEP = 0.01\n-    CROPS_NO_FIRST = 3\n-    CROPS_NO_SECOND = 6\n+    MIN_CROP_SIZE = 8\n+    CROP_RELATIVE_SIZE = 0.01\n+    DEFAULT_CROPS_NUMBER_FIRST_VERIFICATION_STEP = 3\n+    DEFAULT_CROPS_NUMBER_SECOND_VERIFICATION_STEP = 6\n \n",
        "source_code_with_indent": "class BlenderReferenceGenerator:\n    <IND>MIN_CROP_RES = 8\n    CROP_STEP = 0.01\n    CROPS_NO_FIRST = 3\n    CROPS_NO_SECOND = 6\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "class BlenderReferenceGenerator:\n    <IND>MIN_CROP_SIZE = 8\n    CROP_RELATIVE_SIZE = 0.01\n    DEFAULT_CROPS_NUMBER_FIRST_VERIFICATION_STEP = 3\n    DEFAULT_CROPS_NUMBER_SECOND_VERIFICATION_STEP = 6\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": true,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "        self.crop_counter: int = 0\n        self.crop_size: Tuple[float, float] = ()\n        self.split_values: List[Tuple[float, float, float, float]] = []\n        self.split_pixels: List[Tuple[int, int]] = []\n        self.rendered_crops_results: Dict[int, List[Any]] = {}\n",
        "source_code_len": 273,
        "target_code": "        self.crop_counter: int = 0\n        self.crop_size_in_pixels: Tuple[int, int] = (0, 0)\n        self.crops_blender_borders: List[Tuple[float, float, float, float]] = []\n        self.crops_pixel_coordinates: List[Tuple[int, int]] = []\n        self.rendered_crops_results: Dict[int, List[Any]] = {}\n",
        "target_code_len": 303,
        "diff_format": "@@ -52,5 +55,5 @@\n         self.crop_counter: int = 0\n-        self.crop_size: Tuple[float, float] = ()\n-        self.split_values: List[Tuple[float, float, float, float]] = []\n-        self.split_pixels: List[Tuple[int, int]] = []\n+        self.crop_size_in_pixels: Tuple[int, int] = (0, 0)\n+        self.crops_blender_borders: List[Tuple[float, float, float, float]] = []\n+        self.crops_pixel_coordinates: List[Tuple[int, int]] = []\n         self.rendered_crops_results: Dict[int, List[Any]] = {}\n",
        "source_code_with_indent": "        self.crop_counter: int = 0\n        self.crop_size: Tuple[float, float] = ()\n        self.split_values: List[Tuple[float, float, float, float]] = []\n        self.split_pixels: List[Tuple[int, int]] = []\n        self.rendered_crops_results: Dict[int, List[Any]] = {}\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "        self.crop_counter: int = 0\n        self.crop_size_in_pixels: Tuple[int, int] = (0, 0)\n        self.crops_blender_borders: List[Tuple[float, float, float, float]] = []\n        self.crops_pixel_coordinates: List[Tuple[int, int]] = []\n        self.rendered_crops_results: Dict[int, List[Any]] = {}\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    # pylint: disable=R0914\n    def generate_split_data(self, resolution: Tuple[int, int],\n                            image_border: List[float],\n                            splits_num: int,\n                            crop_size: Optional[Tuple[int, int]] = None):\n        \"\"\"\n        This function will generate split data for performing random crops.\n        Crops will be rendered from blend files using calculated values (\n        floats that indicate position in original blender file ).\n\n",
        "source_code_len": 494,
        "target_code": "    # pylint: disable=R0914\n    def generate_crops_data(self,\n                            resolution: Tuple[int, int],\n                            subtask_border: List[float],\n                            crops_number: int,\n                            crop_size_as_fraction:\n                            Optional[Tuple[float, float]]=None):\n        \"\"\"\n        This function will generate split data for performing random crops.\n        Crops will be rendered from blend files using calculated values\n        (floats that indicate position in original blender file).\n\n",
        "target_code_len": 566,
        "diff_format": "@@ -65,10 +68,12 @@\n     # pylint: disable=R0914\n-    def generate_split_data(self, resolution: Tuple[int, int],\n-                            image_border: List[float],\n-                            splits_num: int,\n-                            crop_size: Optional[Tuple[int, int]] = None):\n+    def generate_crops_data(self,\n+                            resolution: Tuple[int, int],\n+                            subtask_border: List[float],\n+                            crops_number: int,\n+                            crop_size_as_fraction:\n+                            Optional[Tuple[float, float]]=None):\n         \"\"\"\n         This function will generate split data for performing random crops.\n-        Crops will be rendered from blend files using calculated values (\n-        floats that indicate position in original blender file ).\n+        Crops will be rendered from blend files using calculated values\n+        (floats that indicate position in original blender file).\n \n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "    # pylint: disable=R0914\n    <DED>def generate_split_data(self, resolution: Tuple[int, int],\n                            image_border: List[float],\n                            splits_num: int,\n                            crop_size: Optional[Tuple[int, int]] = None):\n        <IND>",
        "target_code_with_indent": "    # pylint: disable=R0914\n    <DED>def generate_crops_data(self,\n                            resolution: Tuple[int, int],\n                            subtask_border: List[float],\n                            crops_number: int,\n                            crop_size_as_fraction:\n                            Optional[Tuple[float, float]]=None):\n        <IND>"
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "        \"\"\"\n        logger.info(\"Values left=%r, right=%r, top=%r, bottom=%r\",\n                    image_border[0], image_border[1], image_border[3],\n                    image_border[2])\n\n        #  This is how Blender is calculating pixel check\n        #  BlenderSync::get_buffer_params in blender_camers.cpp file\n        #  BoundBox2D border = cam->border.clamp();\n        #  params.full_x = (int)(border.left * (float)width);\n        #\n        #  NOTE BLENDER IS USING FLOATS Vgit stALUES\n        #  that means single precision 4 bytes floats, python is not\n        #  it is using double precision values. Here numpy is used to emulate\n        #  that loss of precision when assigning double to float.\n        left_p = math.floor(numpy.float32(image_border[0]) *\n                            numpy.float32(resolution[0]))\n        right_p = math.floor(numpy.float32(image_border[1]) *\n                             numpy.float32(resolution[0]))\n        bottom_p = math.floor(numpy.float32(image_border[2]) *\n                              numpy.float32(resolution[1]))\n        top_p = math.floor(numpy.float32(image_border[3]) *\n                           numpy.float32(resolution[1]))\n\n        logger.info(\"Pixels left=%r, right=%r, top=%r, bottom=%r\", left_p,\n                    right_p, top_p, bottom_p)\n\n        if crop_size is None:\n            crop_size = (self._find_split_size(resolution[0]),\n                         self._find_split_size(resolution[1]))\n        else:\n            crop_size = (int(crop_size[0] * resolution[0]),\n                         int(crop_size[1] * resolution[1]))\n\n        self.crop_size = (crop_size[0]/resolution[0],\n                          crop_size[1]/resolution[1])\n\n        # Randomisation cX and Y coordinate to render crop window\n        # Blender cropping window from top left. Cropped window pixels\n        # 0,0 are in top left\n        for _ in range(splits_num):\n            split_x = self._random_split(left_p, right_p, crop_size[0])\n            split_y = self._random_split(bottom_p, top_p, crop_size[1])\n\n            # Here another conversion from double to float\n            x_f = numpy.float32(numpy.float32(split_x[0])\n                                / numpy.float32(resolution[0]))\n            right_f = numpy.float32(numpy.float32(split_x[1]) /\n                                    numpy.float32(resolution[0]))\n            y_f = numpy.float32(numpy.float32(split_y[0])\n                                / numpy.float32(resolution[1]))\n            bottom_f = numpy.float32(numpy.float32(split_y[1])\n                                     / numpy.float32(resolution[1]))\n\n            # Recalculate pixel after converting to float\n            split_x[0] = math.floor(x_f * numpy.float32(resolution[0]))\n            split_y[1] = math.floor(bottom_f * numpy.float32(resolution[1]))\n\n            self.split_values.append((x_f, right_f, y_f, bottom_f))\n            self.split_pixels.append(self._pixel(split_x[0], split_y[1], top_p))\n        return self.split_values, self.split_pixels, self.crop_size\n\n    # pylint: disable-msg=too-many-arguments\n    def render_crops(self, resources: List[str],\n                     crop_rendered: CropRenderedSuccessCallback,\n                     crop_render_failure: CropRenderedFailureCallback,\n                     subtask_info: Dict[str, Any],\n                     num_crops: int = CROPS_NO_FIRST,\n                     crop_size: Optional[Tuple[int, int]] = None):\n        # pylint: disable=unused-argument\n        crops_path = os.path.join(subtask_info['tmp_dir'],\n                                  subtask_info['subtask_id'])\n\n        crops_info = self.generate_split_data((subtask_info['res_x'],\n                                               subtask_info['res_y']),\n",
        "source_code_len": 3755,
        "target_code": "        \"\"\"\n        subtask_pixel_coordinates = BlenderReferenceGenerator\\\n            .convert_blender_crop_border_to_pixel_coordinates(subtask_border,\n                                                              resolution)\n\n        if crop_size_as_fraction is None:\n            self.crop_size_in_pixels = BlenderReferenceGenerator\\\n                ._get_default_crop_size(resolution)\n            crop_size_as_fraction = (\n                self.crop_size_in_pixels[0] / resolution[0],\n                self.crop_size_in_pixels[1] / resolution[1])\n        else:\n            self.crop_size_in_pixels = (\n                int(crop_size_as_fraction[0] * resolution[0]),\n                int(crop_size_as_fraction[1] * resolution[1]))\n\n        for _ in range(crops_number):\n            self.generate_single_crop_data(subtask_pixel_coordinates,\n                                           resolution)\n\n        return self.crops_blender_borders, \\\n            self.crops_pixel_coordinates, \\\n            crop_size_as_fraction\n\n    def generate_single_crop_data(self,\n                                  subtask_pixel_coordinates: Dict[str, int],\n                                  resolution: Tuple[int, int]) -> None:\n\n        crop_horizontal_pixel_coordinates = BlenderReferenceGenerator \\\n            ._get_random_interval_within_boundaries(\n                subtask_pixel_coordinates[\"left\"],\n                subtask_pixel_coordinates[\"right\"],\n                self.crop_size_in_pixels[0])\n\n        crop_vertical_pixel_coordinates = BlenderReferenceGenerator \\\n            ._get_random_interval_within_boundaries(\n                subtask_pixel_coordinates[\"bottom\"],\n                subtask_pixel_coordinates[\"top\"],\n                self.crop_size_in_pixels[1])\n\n        blender_crop_border = BlenderReferenceGenerator \\\n            .convert_pixel_coordinates_to_blender_crop_border(\n                crop_horizontal_pixel_coordinates,\n                crop_vertical_pixel_coordinates,\n                resolution)\n\n        # Recalculate pixel after converting to float\n        crop_horizontal_pixel_coordinates = \\\n            math.floor(\n                blender_crop_border[\"left\"] * numpy.float32(resolution[0])), \\\n            crop_horizontal_pixel_coordinates[1]\n\n        crop_vertical_pixel_coordinates = crop_vertical_pixel_coordinates[0], \\\n            math.floor(blender_crop_border[\"bottom\"]\n                       * numpy.float32(resolution[1]))\n\n        self.crops_blender_borders.append((blender_crop_border[\"left\"],\n                                           blender_crop_border[\"right\"],\n                                           blender_crop_border[\"top\"],\n                                           blender_crop_border[\"bottom\"]))\n\n        pixel_coordinates = BlenderReferenceGenerator\\\n            .convert_bitmap_coordinates_to_traditional_y_direction(\n                crop_horizontal_pixel_coordinates[0],\n                crop_vertical_pixel_coordinates[1],\n                subtask_pixel_coordinates[\"top\"])\n\n        self.crops_pixel_coordinates.append(pixel_coordinates)\n\n    @staticmethod\n    def convert_blender_crop_border_to_pixel_coordinates(\n            subtask_border: List[float],\n            resolution: Tuple[int, int]) -> Dict[str, int]:\n\n        logger.debug(\"Values left=%r, right=%r, top=%r, bottom=%r\",\n                     subtask_border[0],\n                     subtask_border[1],\n                     subtask_border[3],\n                     subtask_border[2])\n        # This is how Blender is calculating pixel check\n        # BlenderSync::get_buffer_params in blender_camers.cpp file\n        # BoundBox2D border = cam->border.clamp();\n        # params.full_x = (int)(border.left * (float)width);\n\n        # NOTE blender uses floats (single precision) while python operates on\n        # doubles\n        # Here numpy is used to emulate this loss of precision when assigning\n        # double to float:\n        left = math.floor(\n            numpy.float32(subtask_border[0]) * numpy.float32(resolution[0]))\n\n        right = math.floor(\n            numpy.float32(subtask_border[1]) * numpy.float32(resolution[0]))\n\n        bottom = math.floor(\n            numpy.float32(subtask_border[2]) * numpy.float32(resolution[1]))\n\n        top = math.floor(\n            numpy.float32(subtask_border[3]) * numpy.float32(resolution[1]))\n\n        logger.debug(\"Pixels left=%r, right=%r, top=%r, bottom=%r\",\n                     left,\n                     right,\n                     top,\n                     bottom)\n        return {\"left\": left, \"right\": right, \"bottom\": bottom, \"top\": top}\n\n    @staticmethod\n    def convert_pixel_coordinates_to_blender_crop_border(\n            horizontal_pixel_coordinates: Tuple[int, int],\n            vertical_pixel_coordinates: Tuple[int, int],\n            resolution: Tuple[int, int]) -> Dict[str, float]:\n\n        left = numpy.float32(\n            numpy.float32(horizontal_pixel_coordinates[0])\n            / numpy.float32(resolution[0]))\n\n        right = numpy.float32(\n            numpy.float32(horizontal_pixel_coordinates[1])\n            / numpy.float32(resolution[0]))\n\n        top = numpy.float32(\n            numpy.float32(vertical_pixel_coordinates[0])\n            / numpy.float32(resolution[1]))\n\n        bottom = numpy.float32(\n            numpy.float32(vertical_pixel_coordinates[1])\n            / numpy.float32(resolution[1]))\n\n        return {\"left\": left, \"right\": right, \"bottom\": bottom, \"top\": top}\n\n    # pylint: disable-msg=too-many-arguments\n\n    def render_crops(self,\n                     resources: List[str],\n                     crop_rendered_callback: CropRenderedSuccessCallbackType,\n                     crop_render_fail_callback: CropRenderedFailureCallbackType,\n                     subtask_info: Dict[str, Any],\n                     num_crops: int\n                     =DEFAULT_CROPS_NUMBER_FIRST_VERIFICATION_STEP,\n                     crop_size: Optional[Tuple[int, int]] = None) \\\n            -> Tuple[int, int]:\n\n        crops_path = os.path.join(subtask_info['tmp_dir'],\n                                  subtask_info['subtask_id'])\n        crops_info = self.generate_crops_data((subtask_info['res_x'],\n                                               subtask_info['res_y']),\n",
        "target_code_len": 6264,
        "diff_format": "@@ -88,74 +93,147 @@\n         \"\"\"\n-        logger.info(\"Values left=%r, right=%r, top=%r, bottom=%r\",\n-                    image_border[0], image_border[1], image_border[3],\n-                    image_border[2])\n-\n-        #  This is how Blender is calculating pixel check\n-        #  BlenderSync::get_buffer_params in blender_camers.cpp file\n-        #  BoundBox2D border = cam->border.clamp();\n-        #  params.full_x = (int)(border.left * (float)width);\n-        #\n-        #  NOTE BLENDER IS USING FLOATS Vgit stALUES\n-        #  that means single precision 4 bytes floats, python is not\n-        #  it is using double precision values. Here numpy is used to emulate\n-        #  that loss of precision when assigning double to float.\n-        left_p = math.floor(numpy.float32(image_border[0]) *\n-                            numpy.float32(resolution[0]))\n-        right_p = math.floor(numpy.float32(image_border[1]) *\n-                             numpy.float32(resolution[0]))\n-        bottom_p = math.floor(numpy.float32(image_border[2]) *\n-                              numpy.float32(resolution[1]))\n-        top_p = math.floor(numpy.float32(image_border[3]) *\n-                           numpy.float32(resolution[1]))\n-\n-        logger.info(\"Pixels left=%r, right=%r, top=%r, bottom=%r\", left_p,\n-                    right_p, top_p, bottom_p)\n-\n-        if crop_size is None:\n-            crop_size = (self._find_split_size(resolution[0]),\n-                         self._find_split_size(resolution[1]))\n+        subtask_pixel_coordinates = BlenderReferenceGenerator\\\n+            .convert_blender_crop_border_to_pixel_coordinates(subtask_border,\n+                                                              resolution)\n+\n+        if crop_size_as_fraction is None:\n+            self.crop_size_in_pixels = BlenderReferenceGenerator\\\n+                ._get_default_crop_size(resolution)\n+            crop_size_as_fraction = (\n+                self.crop_size_in_pixels[0] / resolution[0],\n+                self.crop_size_in_pixels[1] / resolution[1])\n         else:\n-            crop_size = (int(crop_size[0] * resolution[0]),\n-                         int(crop_size[1] * resolution[1]))\n-\n-        self.crop_size = (crop_size[0]/resolution[0],\n-                          crop_size[1]/resolution[1])\n-\n-        # Randomisation cX and Y coordinate to render crop window\n-        # Blender cropping window from top left. Cropped window pixels\n-        # 0,0 are in top left\n-        for _ in range(splits_num):\n-            split_x = self._random_split(left_p, right_p, crop_size[0])\n-            split_y = self._random_split(bottom_p, top_p, crop_size[1])\n-\n-            # Here another conversion from double to float\n-            x_f = numpy.float32(numpy.float32(split_x[0])\n-                                / numpy.float32(resolution[0]))\n-            right_f = numpy.float32(numpy.float32(split_x[1]) /\n-                                    numpy.float32(resolution[0]))\n-            y_f = numpy.float32(numpy.float32(split_y[0])\n-                                / numpy.float32(resolution[1]))\n-            bottom_f = numpy.float32(numpy.float32(split_y[1])\n-                                     / numpy.float32(resolution[1]))\n-\n-            # Recalculate pixel after converting to float\n-            split_x[0] = math.floor(x_f * numpy.float32(resolution[0]))\n-            split_y[1] = math.floor(bottom_f * numpy.float32(resolution[1]))\n-\n-            self.split_values.append((x_f, right_f, y_f, bottom_f))\n-            self.split_pixels.append(self._pixel(split_x[0], split_y[1], top_p))\n-        return self.split_values, self.split_pixels, self.crop_size\n+            self.crop_size_in_pixels = (\n+                int(crop_size_as_fraction[0] * resolution[0]),\n+                int(crop_size_as_fraction[1] * resolution[1]))\n+\n+        for _ in range(crops_number):\n+            self.generate_single_crop_data(subtask_pixel_coordinates,\n+                                           resolution)\n+\n+        return self.crops_blender_borders, \\\n+            self.crops_pixel_coordinates, \\\n+            crop_size_as_fraction\n+\n+    def generate_single_crop_data(self,\n+                                  subtask_pixel_coordinates: Dict[str, int],\n+                                  resolution: Tuple[int, int]) -> None:\n+\n+        crop_horizontal_pixel_coordinates = BlenderReferenceGenerator \\\n+            ._get_random_interval_within_boundaries(\n+                subtask_pixel_coordinates[\"left\"],\n+                subtask_pixel_coordinates[\"right\"],\n+                self.crop_size_in_pixels[0])\n+\n+        crop_vertical_pixel_coordinates = BlenderReferenceGenerator \\\n+            ._get_random_interval_within_boundaries(\n+                subtask_pixel_coordinates[\"bottom\"],\n+                subtask_pixel_coordinates[\"top\"],\n+                self.crop_size_in_pixels[1])\n+\n+        blender_crop_border = BlenderReferenceGenerator \\\n+            .convert_pixel_coordinates_to_blender_crop_border(\n+                crop_horizontal_pixel_coordinates,\n+                crop_vertical_pixel_coordinates,\n+                resolution)\n+\n+        # Recalculate pixel after converting to float\n+        crop_horizontal_pixel_coordinates = \\\n+            math.floor(\n+                blender_crop_border[\"left\"] * numpy.float32(resolution[0])), \\\n+            crop_horizontal_pixel_coordinates[1]\n+\n+        crop_vertical_pixel_coordinates = crop_vertical_pixel_coordinates[0], \\\n+            math.floor(blender_crop_border[\"bottom\"]\n+                       * numpy.float32(resolution[1]))\n+\n+        self.crops_blender_borders.append((blender_crop_border[\"left\"],\n+                                           blender_crop_border[\"right\"],\n+                                           blender_crop_border[\"top\"],\n+                                           blender_crop_border[\"bottom\"]))\n+\n+        pixel_coordinates = BlenderReferenceGenerator\\\n+            .convert_bitmap_coordinates_to_traditional_y_direction(\n+                crop_horizontal_pixel_coordinates[0],\n+                crop_vertical_pixel_coordinates[1],\n+                subtask_pixel_coordinates[\"top\"])\n+\n+        self.crops_pixel_coordinates.append(pixel_coordinates)\n+\n+    @staticmethod\n+    def convert_blender_crop_border_to_pixel_coordinates(\n+            subtask_border: List[float],\n+            resolution: Tuple[int, int]) -> Dict[str, int]:\n+\n+        logger.debug(\"Values left=%r, right=%r, top=%r, bottom=%r\",\n+                     subtask_border[0],\n+                     subtask_border[1],\n+                     subtask_border[3],\n+                     subtask_border[2])\n+        # This is how Blender is calculating pixel check\n+        # BlenderSync::get_buffer_params in blender_camers.cpp file\n+        # BoundBox2D border = cam->border.clamp();\n+        # params.full_x = (int)(border.left * (float)width);\n+\n+        # NOTE blender uses floats (single precision) while python operates on\n+        # doubles\n+        # Here numpy is used to emulate this loss of precision when assigning\n+        # double to float:\n+        left = math.floor(\n+            numpy.float32(subtask_border[0]) * numpy.float32(resolution[0]))\n+\n+        right = math.floor(\n+            numpy.float32(subtask_border[1]) * numpy.float32(resolution[0]))\n+\n+        bottom = math.floor(\n+            numpy.float32(subtask_border[2]) * numpy.float32(resolution[1]))\n+\n+        top = math.floor(\n+            numpy.float32(subtask_border[3]) * numpy.float32(resolution[1]))\n+\n+        logger.debug(\"Pixels left=%r, right=%r, top=%r, bottom=%r\",\n+                     left,\n+                     right,\n+                     top,\n+                     bottom)\n+        return {\"left\": left, \"right\": right, \"bottom\": bottom, \"top\": top}\n+\n+    @staticmethod\n+    def convert_pixel_coordinates_to_blender_crop_border(\n+            horizontal_pixel_coordinates: Tuple[int, int],\n+            vertical_pixel_coordinates: Tuple[int, int],\n+            resolution: Tuple[int, int]) -> Dict[str, float]:\n+\n+        left = numpy.float32(\n+            numpy.float32(horizontal_pixel_coordinates[0])\n+            / numpy.float32(resolution[0]))\n+\n+        right = numpy.float32(\n+            numpy.float32(horizontal_pixel_coordinates[1])\n+            / numpy.float32(resolution[0]))\n+\n+        top = numpy.float32(\n+            numpy.float32(vertical_pixel_coordinates[0])\n+            / numpy.float32(resolution[1]))\n+\n+        bottom = numpy.float32(\n+            numpy.float32(vertical_pixel_coordinates[1])\n+            / numpy.float32(resolution[1]))\n+\n+        return {\"left\": left, \"right\": right, \"bottom\": bottom, \"top\": top}\n \n     # pylint: disable-msg=too-many-arguments\n-    def render_crops(self, resources: List[str],\n-                     crop_rendered: CropRenderedSuccessCallback,\n-                     crop_render_failure: CropRenderedFailureCallback,\n+\n+    def render_crops(self,\n+                     resources: List[str],\n+                     crop_rendered_callback: CropRenderedSuccessCallbackType,\n+                     crop_render_fail_callback: CropRenderedFailureCallbackType,\n                      subtask_info: Dict[str, Any],\n-                     num_crops: int = CROPS_NO_FIRST,\n-                     crop_size: Optional[Tuple[int, int]] = None):\n-        # pylint: disable=unused-argument\n+                     num_crops: int\n+                     =DEFAULT_CROPS_NUMBER_FIRST_VERIFICATION_STEP,\n+                     crop_size: Optional[Tuple[int, int]] = None) \\\n+            -> Tuple[int, int]:\n+\n         crops_path = os.path.join(subtask_info['tmp_dir'],\n                                   subtask_info['subtask_id'])\n-\n-        crops_info = self.generate_split_data((subtask_info['res_x'],\n+        crops_info = self.generate_crops_data((subtask_info['res_x'],\n                                                subtask_info['res_y']),\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\n        logger.info(\"Values left=%r, right=%r, top=%r, bottom=%r\",\n                    image_border[0], image_border[1], image_border[3],\n                    image_border[2])\n\n        #  This is how Blender is calculating pixel check\n        #  BlenderSync::get_buffer_params in blender_camers.cpp file\n        #  BoundBox2D border = cam->border.clamp();\n        #  params.full_x = (int)(border.left * (float)width);\n        #\n        #  NOTE BLENDER IS USING FLOATS Vgit stALUES\n        #  that means single precision 4 bytes floats, python is not\n        #  it is using double precision values. Here numpy is used to emulate\n        #  that loss of precision when assigning double to float.\n        left_p = math.floor(numpy.float32(image_border[0]) *\n                            numpy.float32(resolution[0]))\n        right_p = math.floor(numpy.float32(image_border[1]) *\n                             numpy.float32(resolution[0]))\n        bottom_p = math.floor(numpy.float32(image_border[2]) *\n                              numpy.float32(resolution[1]))\n        top_p = math.floor(numpy.float32(image_border[3]) *\n                           numpy.float32(resolution[1]))\n\n        logger.info(\"Pixels left=%r, right=%r, top=%r, bottom=%r\", left_p,\n                    right_p, top_p, bottom_p)\n\n        if crop_size is None:\n            <IND>crop_size = (self._find_split_size(resolution[0]),\n                         self._find_split_size(resolution[1]))\n        <DED>else:\n            <IND>crop_size = (int(crop_size[0] * resolution[0]),\n                         int(crop_size[1] * resolution[1]))\n\n        <DED>self.crop_size = (crop_size[0]/resolution[0],\n                          crop_size[1]/resolution[1])\n\n        # Randomisation cX and Y coordinate to render crop window\n        # Blender cropping window from top left. Cropped window pixels\n        # 0,0 are in top left\n        for _ in range(splits_num):\n            <IND>split_x = self._random_split(left_p, right_p, crop_size[0])\n            split_y = self._random_split(bottom_p, top_p, crop_size[1])\n\n            # Here another conversion from double to float\n            x_f = numpy.float32(numpy.float32(split_x[0])\n                                / numpy.float32(resolution[0]))\n            right_f = numpy.float32(numpy.float32(split_x[1]) /\n                                    numpy.float32(resolution[0]))\n            y_f = numpy.float32(numpy.float32(split_y[0])\n                                / numpy.float32(resolution[1]))\n            bottom_f = numpy.float32(numpy.float32(split_y[1])\n                                     / numpy.float32(resolution[1]))\n\n            # Recalculate pixel after converting to float\n            split_x[0] = math.floor(x_f * numpy.float32(resolution[0]))\n            split_y[1] = math.floor(bottom_f * numpy.float32(resolution[1]))\n\n            self.split_values.append((x_f, right_f, y_f, bottom_f))\n            self.split_pixels.append(self._pixel(split_x[0], split_y[1], top_p))\n        <DED>return self.split_values, self.split_pixels, self.crop_size\n\n    # pylint: disable-msg=too-many-arguments\n    <DED>def render_crops(self, resources: List[str],\n                     crop_rendered: CropRenderedSuccessCallback,\n                     crop_render_failure: CropRenderedFailureCallback,\n                     subtask_info: Dict[str, Any],\n                     num_crops: int = CROPS_NO_FIRST,\n                     crop_size: Optional[Tuple[int, int]] = None):\n        # pylint: disable=unused-argument\n        <IND>crops_path = os.path.join(subtask_info['tmp_dir'],\n                                  subtask_info['subtask_id'])\n\n        crops_info = self.generate_split_data((subtask_info['res_x'],\n                                               subtask_info['res_y']),\n",
        "target_code_with_indent": "\n        subtask_pixel_coordinates = BlenderReferenceGenerator            .convert_blender_crop_border_to_pixel_coordinates(subtask_border,\n                                                              resolution)\n\n        if crop_size_as_fraction is None:\n            <IND>self.crop_size_in_pixels = BlenderReferenceGenerator                ._get_default_crop_size(resolution)\n            crop_size_as_fraction = (\n                self.crop_size_in_pixels[0] / resolution[0],\n                self.crop_size_in_pixels[1] / resolution[1])\n        <DED>else:\n            <IND>self.crop_size_in_pixels = (\n                int(crop_size_as_fraction[0] * resolution[0]),\n                int(crop_size_as_fraction[1] * resolution[1]))\n\n        <DED>for _ in range(crops_number):\n            <IND>self.generate_single_crop_data(subtask_pixel_coordinates,\n                                           resolution)\n\n        <DED>return self.crops_blender_borders,            self.crops_pixel_coordinates,            crop_size_as_fraction\n\n    <DED>def generate_single_crop_data(self,\n                                  subtask_pixel_coordinates: Dict[str, int],\n                                  resolution: Tuple[int, int]) -> None:\n\n        <IND>crop_horizontal_pixel_coordinates = BlenderReferenceGenerator            ._get_random_interval_within_boundaries(\n                subtask_pixel_coordinates[\"left\"],\n                subtask_pixel_coordinates[\"right\"],\n                self.crop_size_in_pixels[0])\n\n        crop_vertical_pixel_coordinates = BlenderReferenceGenerator            ._get_random_interval_within_boundaries(\n                subtask_pixel_coordinates[\"bottom\"],\n                subtask_pixel_coordinates[\"top\"],\n                self.crop_size_in_pixels[1])\n\n        blender_crop_border = BlenderReferenceGenerator            .convert_pixel_coordinates_to_blender_crop_border(\n                crop_horizontal_pixel_coordinates,\n                crop_vertical_pixel_coordinates,\n                resolution)\n\n        # Recalculate pixel after converting to float\n        crop_horizontal_pixel_coordinates =            math.floor(\n                blender_crop_border[\"left\"] * numpy.float32(resolution[0])),            crop_horizontal_pixel_coordinates[1]\n\n        crop_vertical_pixel_coordinates = crop_vertical_pixel_coordinates[0],            math.floor(blender_crop_border[\"bottom\"]\n                       * numpy.float32(resolution[1]))\n\n        self.crops_blender_borders.append((blender_crop_border[\"left\"],\n                                           blender_crop_border[\"right\"],\n                                           blender_crop_border[\"top\"],\n                                           blender_crop_border[\"bottom\"]))\n\n        pixel_coordinates = BlenderReferenceGenerator            .convert_bitmap_coordinates_to_traditional_y_direction(\n                crop_horizontal_pixel_coordinates[0],\n                crop_vertical_pixel_coordinates[1],\n                subtask_pixel_coordinates[\"top\"])\n\n        self.crops_pixel_coordinates.append(pixel_coordinates)\n\n    <DED>@staticmethod\n    def convert_blender_crop_border_to_pixel_coordinates(\n            subtask_border: List[float],\n            resolution: Tuple[int, int]) -> Dict[str, int]:\n\n        <IND>logger.debug(\"Values left=%r, right=%r, top=%r, bottom=%r\",\n                     subtask_border[0],\n                     subtask_border[1],\n                     subtask_border[3],\n                     subtask_border[2])\n        # This is how Blender is calculating pixel check\n        # BlenderSync::get_buffer_params in blender_camers.cpp file\n        # BoundBox2D border = cam->border.clamp();\n        # params.full_x = (int)(border.left * (float)width);\n\n        # NOTE blender uses floats (single precision) while python operates on\n        # doubles\n        # Here numpy is used to emulate this loss of precision when assigning\n        # double to float:\n        left = math.floor(\n            numpy.float32(subtask_border[0]) * numpy.float32(resolution[0]))\n\n        right = math.floor(\n            numpy.float32(subtask_border[1]) * numpy.float32(resolution[0]))\n\n        bottom = math.floor(\n            numpy.float32(subtask_border[2]) * numpy.float32(resolution[1]))\n\n        top = math.floor(\n            numpy.float32(subtask_border[3]) * numpy.float32(resolution[1]))\n\n        logger.debug(\"Pixels left=%r, right=%r, top=%r, bottom=%r\",\n                     left,\n                     right,\n                     top,\n                     bottom)\n        return {\"left\": left, \"right\": right, \"bottom\": bottom, \"top\": top}\n\n    <DED>@staticmethod\n    def convert_pixel_coordinates_to_blender_crop_border(\n            horizontal_pixel_coordinates: Tuple[int, int],\n            vertical_pixel_coordinates: Tuple[int, int],\n            resolution: Tuple[int, int]) -> Dict[str, float]:\n\n        <IND>left = numpy.float32(\n            numpy.float32(horizontal_pixel_coordinates[0])\n            / numpy.float32(resolution[0]))\n\n        right = numpy.float32(\n            numpy.float32(horizontal_pixel_coordinates[1])\n            / numpy.float32(resolution[0]))\n\n        top = numpy.float32(\n            numpy.float32(vertical_pixel_coordinates[0])\n            / numpy.float32(resolution[1]))\n\n        bottom = numpy.float32(\n            numpy.float32(vertical_pixel_coordinates[1])\n            / numpy.float32(resolution[1]))\n\n        return {\"left\": left, \"right\": right, \"bottom\": bottom, \"top\": top}\n\n    # pylint: disable-msg=too-many-arguments\n\n    <DED>def render_crops(self,\n                     resources: List[str],\n                     crop_rendered_callback: CropRenderedSuccessCallbackType,\n                     crop_render_fail_callback: CropRenderedFailureCallbackType,\n                     subtask_info: Dict[str, Any],\n                     num_crops: int\n                     =DEFAULT_CROPS_NUMBER_FIRST_VERIFICATION_STEP,\n                     crop_size: Optional[Tuple[int, int]] = None)            -> Tuple[int, int]:\n\n        <IND>crops_path = os.path.join(subtask_info['tmp_dir'],\n                                  subtask_info['subtask_id'])\n        crops_info = self.generate_crops_data((subtask_info['res_x'],\n                                               subtask_info['res_y']),\n"
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n        verify_ctx = CropContext({'paths': crops_path, 'position': crops_info},\n                                 self.computer,\n                                 {'resources': resources,\n                                  'subtask_info': subtask_info},\n                                 {'success': crop_rendered,\n                                  'errback': crop_render_failure})\n        self._render_one_crop(verify_ctx, self.crop_rendered,\n                              crop_render_failure, self.crop_counter)\n        return self.crop_size\n\n",
        "source_code_len": 542,
        "target_code": "\n        verification_context = \\\n            VerificationContext({'paths': crops_path,\n                                 'position': crops_info},\n                                self.computer,\n                                {'resources': resources,\n                                 'subtask_info': subtask_info},\n                                {'success': crop_rendered_callback,\n                                 'errback': crop_render_fail_callback})\n\n        self._render_one_crop(verification_context,\n                              self.crop_rendered_callback,\n                              crop_render_fail_callback,\n                              self.crop_counter)\n\n        return self.crop_size_in_pixels\n\n",
        "target_code_len": 714,
        "diff_format": "@@ -165,11 +243,17 @@\n \n-        verify_ctx = CropContext({'paths': crops_path, 'position': crops_info},\n-                                 self.computer,\n-                                 {'resources': resources,\n-                                  'subtask_info': subtask_info},\n-                                 {'success': crop_rendered,\n-                                  'errback': crop_render_failure})\n-        self._render_one_crop(verify_ctx, self.crop_rendered,\n-                              crop_render_failure, self.crop_counter)\n-        return self.crop_size\n+        verification_context = \\\n+            VerificationContext({'paths': crops_path,\n+                                 'position': crops_info},\n+                                self.computer,\n+                                {'resources': resources,\n+                                 'subtask_info': subtask_info},\n+                                {'success': crop_rendered_callback,\n+                                 'errback': crop_render_fail_callback})\n+\n+        self._render_one_crop(verification_context,\n+                              self.crop_rendered_callback,\n+                              crop_render_fail_callback,\n+                              self.crop_counter)\n+\n+        return self.crop_size_in_pixels\n \n",
        "source_code_with_indent": "\n        verify_ctx = CropContext({'paths': crops_path, 'position': crops_info},\n                                 self.computer,\n                                 {'resources': resources,\n                                  'subtask_info': subtask_info},\n                                 {'success': crop_rendered,\n                                  'errback': crop_render_failure})\n        self._render_one_crop(verify_ctx, self.crop_rendered,\n                              crop_render_failure, self.crop_counter)\n        return self.crop_size\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent_exact_match": false,
        "target_code_with_indent": "\n        verification_context =            VerificationContext({'paths': crops_path,\n                                 'position': crops_info},\n                                self.computer,\n                                {'resources': resources,\n                                 'subtask_info': subtask_info},\n                                {'success': crop_rendered_callback,\n                                 'errback': crop_render_fail_callback})\n\n        self._render_one_crop(verification_context,\n                              self.crop_rendered_callback,\n                              crop_render_fail_callback,\n                              self.crop_counter)\n\n        return self.crop_size_in_pixels\n\n"
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    # pylint: disable=R0914\n    def _render_one_crop(self, verify_ctx: CropContext,\n                         crop_rendered: CropRenderedSuccessCallback,\n                         crop_render_failure: CropRenderedFailureCallback,\n                         crop_number: int):\n        minx, maxx, miny, maxy = verify_ctx.crop_values[\n            crop_number - self.crop_counter]\n\n        def generate_ctd(subtask_info, script_src):\n            ctd = deepcopy(subtask_info['ctd'])\n\n            ctd['extra_data']['outfilebasename'] = \\\n                \"ref_\" + subtask_info['outfilebasename']\n            ctd['extra_data']['script_src'] = script_src\n            ctd['deadline'] = timeout_to_deadline(\n                subtask_info['subtask_timeout'])\n            return ctd\n\n        script_src = generate_blender_crop_file(\n            resolution=(verify_ctx.subtask_info['res_x'],\n                        verify_ctx.subtask_info['res_y']),\n            borders_x=(minx, maxx),\n",
        "source_code_len": 969,
        "target_code": "    # pylint: disable=R0914\n    def _render_one_crop(self,\n                         verification_context: VerificationContext,\n                         crop_rendered: CropRenderedSuccessCallbackType,\n                         crop_render_failure: CropRenderedFailureCallbackType,\n                         crop_number: int) -> None:\n\n        minx, maxx, miny, maxy = verification_context \\\n            .crops_floating_point_coordinates[crop_number - self.crop_counter]\n\n        script_src = generate_blender_crop_file(\n            resolution=(verification_context.subtask_info['res_x'],\n                        verification_context.subtask_info['res_y']),\n            borders_x=(minx, maxx),\n",
        "target_code_len": 690,
        "diff_format": "@@ -180,22 +264,14 @@\n     # pylint: disable=R0914\n-    def _render_one_crop(self, verify_ctx: CropContext,\n-                         crop_rendered: CropRenderedSuccessCallback,\n-                         crop_render_failure: CropRenderedFailureCallback,\n-                         crop_number: int):\n-        minx, maxx, miny, maxy = verify_ctx.crop_values[\n-            crop_number - self.crop_counter]\n-\n-        def generate_ctd(subtask_info, script_src):\n-            ctd = deepcopy(subtask_info['ctd'])\n-\n-            ctd['extra_data']['outfilebasename'] = \\\n-                \"ref_\" + subtask_info['outfilebasename']\n-            ctd['extra_data']['script_src'] = script_src\n-            ctd['deadline'] = timeout_to_deadline(\n-                subtask_info['subtask_timeout'])\n-            return ctd\n+    def _render_one_crop(self,\n+                         verification_context: VerificationContext,\n+                         crop_rendered: CropRenderedSuccessCallbackType,\n+                         crop_render_failure: CropRenderedFailureCallbackType,\n+                         crop_number: int) -> None:\n+\n+        minx, maxx, miny, maxy = verification_context \\\n+            .crops_floating_point_coordinates[crop_number - self.crop_counter]\n \n         script_src = generate_blender_crop_file(\n-            resolution=(verify_ctx.subtask_info['res_x'],\n-                        verify_ctx.subtask_info['res_y']),\n+            resolution=(verification_context.subtask_info['res_x'],\n+                        verification_context.subtask_info['res_y']),\n             borders_x=(minx, maxx),\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "    # pylint: disable=R0914\n    <DED>def _render_one_crop(self, verify_ctx: CropContext,\n                         crop_rendered: CropRenderedSuccessCallback,\n                         crop_render_failure: CropRenderedFailureCallback,\n                         crop_number: int):\n        <IND>minx, maxx, miny, maxy = verify_ctx.crop_values[\n            crop_number - self.crop_counter]\n\n        def generate_ctd(subtask_info, script_src):\n            <IND>ctd = deepcopy(subtask_info['ctd'])\n\n            ctd['extra_data']['outfilebasename'] =                \"ref_\" + subtask_info['outfilebasename']\n            ctd['extra_data']['script_src'] = script_src\n            ctd['deadline'] = timeout_to_deadline(\n                subtask_info['subtask_timeout'])\n            return ctd\n\n        <DED>script_src = generate_blender_crop_file(\n            resolution=(verify_ctx.subtask_info['res_x'],\n                        verify_ctx.subtask_info['res_y']),\n            borders_x=(minx, maxx),\n",
        "target_code_with_indent": "    # pylint: disable=R0914\n    <DED>def _render_one_crop(self,\n                         verification_context: VerificationContext,\n                         crop_rendered: CropRenderedSuccessCallbackType,\n                         crop_render_failure: CropRenderedFailureCallbackType,\n                         crop_number: int) -> None:\n\n        <IND>minx, maxx, miny, maxy = verification_context            .crops_floating_point_coordinates[crop_number - self.crop_counter]\n\n        script_src = generate_blender_crop_file(\n            resolution=(verification_context.subtask_info['res_x'],\n                        verification_context.subtask_info['res_y']),\n            borders_x=(minx, maxx),\n"
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "            use_compositing=False,\n            samples=verify_ctx.subtask_info['samples']\n        )\n        ctd = generate_ctd(verify_ctx.subtask_info, script_src)\n        # FIXME issue #1955\n        verify_ctx.computer.start_computation(\n            root_path=verify_ctx.get_crop_path(crop_number),\n            success_callback=partial(crop_rendered,\n                                     verification_context=verify_ctx,\n                                     crop_number=crop_number),\n            error_callback=crop_render_failure,\n            compute_task_def=ctd,\n            resources=verify_ctx.resources,\n            additional_resources=[]\n        )\n\n",
        "source_code_len": 658,
        "target_code": "            use_compositing=False,\n            samples=verification_context.subtask_info['samples']\n        )\n        task_definition = BlenderReferenceGenerator\\\n            .generate_computational_task_definition(\n                verification_context.subtask_info,\n                script_src)\n\n        # FIXME issue #1955\n        verification_context.computer.start_computation(\n            root_path=verification_context.get_crop_path(crop_number),\n            success_callback=partial(crop_rendered,\n                                     verification_context=verification_context,\n                                     crop_number=crop_number),\n            error_callback=crop_render_failure,\n            compute_task_def=task_definition,\n            resources=verification_context.resources,\n            additional_resources=[]\n        )\n\n    @staticmethod\n    def generate_computational_task_definition(subtask_info: Dict[str, Any],\n                                               script_src: str) \\\n            -> Dict[str, Any]:\n\n        task_definition = deepcopy(subtask_info['ctd'])\n\n        task_definition['extra_data']['outfilebasename'] = \\\n            \"ref_\" + subtask_info['outfilebasename']\n\n        task_definition['extra_data']['script_src'] = script_src\n\n        task_definition['deadline'] = timeout_to_deadline(\n            subtask_info['subtask_timeout'])\n\n        return task_definition\n\n",
        "target_code_len": 1410,
        "diff_format": "@@ -203,16 +279,37 @@\n             use_compositing=False,\n-            samples=verify_ctx.subtask_info['samples']\n+            samples=verification_context.subtask_info['samples']\n         )\n-        ctd = generate_ctd(verify_ctx.subtask_info, script_src)\n+        task_definition = BlenderReferenceGenerator\\\n+            .generate_computational_task_definition(\n+                verification_context.subtask_info,\n+                script_src)\n+\n         # FIXME issue #1955\n-        verify_ctx.computer.start_computation(\n-            root_path=verify_ctx.get_crop_path(crop_number),\n+        verification_context.computer.start_computation(\n+            root_path=verification_context.get_crop_path(crop_number),\n             success_callback=partial(crop_rendered,\n-                                     verification_context=verify_ctx,\n+                                     verification_context=verification_context,\n                                      crop_number=crop_number),\n             error_callback=crop_render_failure,\n-            compute_task_def=ctd,\n-            resources=verify_ctx.resources,\n+            compute_task_def=task_definition,\n+            resources=verification_context.resources,\n             additional_resources=[]\n         )\n+\n+    @staticmethod\n+    def generate_computational_task_definition(subtask_info: Dict[str, Any],\n+                                               script_src: str) \\\n+            -> Dict[str, Any]:\n+\n+        task_definition = deepcopy(subtask_info['ctd'])\n+\n+        task_definition['extra_data']['outfilebasename'] = \\\n+            \"ref_\" + subtask_info['outfilebasename']\n+\n+        task_definition['extra_data']['script_src'] = script_src\n+\n+        task_definition['deadline'] = timeout_to_deadline(\n+            subtask_info['subtask_timeout'])\n+\n+        return task_definition\n \n",
        "source_code_with_indent": "            use_compositing=False,\n            samples=verify_ctx.subtask_info['samples']\n        )\n        ctd = generate_ctd(verify_ctx.subtask_info, script_src)\n        # FIXME issue #1955\n        verify_ctx.computer.start_computation(\n            root_path=verify_ctx.get_crop_path(crop_number),\n            success_callback=partial(crop_rendered,\n                                     verification_context=verify_ctx,\n                                     crop_number=crop_number),\n            error_callback=crop_render_failure,\n            compute_task_def=ctd,\n            resources=verify_ctx.resources,\n            additional_resources=[]\n        )\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent_exact_match": false,
        "target_code_with_indent": "            use_compositing=False,\n            samples=verification_context.subtask_info['samples']\n        )\n        task_definition = BlenderReferenceGenerator            .generate_computational_task_definition(\n                verification_context.subtask_info,\n                script_src)\n\n        # FIXME issue #1955\n        verification_context.computer.start_computation(\n            root_path=verification_context.get_crop_path(crop_number),\n            success_callback=partial(crop_rendered,\n                                     verification_context=verification_context,\n                                     crop_number=crop_number),\n            error_callback=crop_render_failure,\n            compute_task_def=task_definition,\n            resources=verification_context.resources,\n            additional_resources=[]\n        )\n\n    <DED>@staticmethod\n    def generate_computational_task_definition(subtask_info: Dict[str, Any],\n                                               script_src: str)            -> Dict[str, Any]:\n\n        <IND>task_definition = deepcopy(subtask_info['ctd'])\n\n        task_definition['extra_data']['outfilebasename'] =            \"ref_\" + subtask_info['outfilebasename']\n\n        task_definition['extra_data']['script_src'] = script_src\n\n        task_definition['deadline'] = timeout_to_deadline(\n            subtask_info['subtask_timeout'])\n\n        return task_definition\n\n"
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n    def crop_rendered(self, results: List[str], time_spend: float,\n                      verification_context: CropContext,\n                      crop_number: int) -> None:\n        self.rendered_crops_results[crop_number] \\\n            = [results, time_spend, verification_context]\n        crop_number += 1\n        if crop_number == \\\n                BlenderReferenceGenerator.CROPS_NO_FIRST or crop_number == \\\n                BlenderReferenceGenerator.CROPS_NO_SECOND:\n            self.crop_rendering_finished(\n                crop_number-BlenderReferenceGenerator.CROPS_NO_FIRST,\n                crop_number)\n            return\n\n        self._render_one_crop(verification_context, self.crop_rendered,\n                              verification_context.errback, crop_number)\n\n    @staticmethod\n    def _random_split(min_: int, max_: int, size_: int) -> List[int]:\n        # survive in edge cases\n        max_ -= 1\n        min_ += 1\n        difference = (max_ - size_)\n        if difference < 0:\n            raise Exception(\"Subtask is to small to reliable verifcation\")\n        split_min = random.randint(min_, difference)\n        split_max = split_min + size_\n        logger.info(\"split_min=%r, split_max=%r\", split_min, split_max)\n        return [split_min, split_max]\n\n    @staticmethod\n    def _pixel(crop_x_min: int, crop_y_max: int, top: int) -> Tuple[int, int]:\n        # In matrics calculation, y=0 is located on top. Where in blender in\n        # bottom. Take then given top and substract it from y_max\n        y = top - crop_y_max\n        x = crop_x_min\n        logger.info(\"X=%r, Y=%r\", x, y)\n",
        "source_code_len": 1607,
        "target_code": "\n    def crop_rendered_callback(self,\n                               results: List[str],\n                               time_spent: float,\n                               verification_context: VerificationContext,\n                               crop_number: int) -> None:\n        self.rendered_crops_results[crop_number] = [results,\n                                                    time_spent,\n                                                    verification_context]\n        crop_number += 1\n\n        crops_number_first_step = BlenderReferenceGenerator\\\n            .DEFAULT_CROPS_NUMBER_FIRST_VERIFICATION_STEP\n        crops_number_second_step = BlenderReferenceGenerator \\\n            .DEFAULT_CROPS_NUMBER_SECOND_VERIFICATION_STEP\n\n        if crop_number == crops_number_first_step \\\n                or crop_number == crops_number_second_step:\n            self.crop_rendering_finished(crop_number - crops_number_first_step,\n                                         crop_number)\n            return\n\n        self._render_one_crop(verification_context,\n                              self.crop_rendered_callback,\n                              verification_context.error_callback,\n                              crop_number)\n\n    @staticmethod\n    def _get_random_interval_within_boundaries(begin: int,\n                                               end: int,\n                                               interval_length: int) \\\n            -> Tuple[int, int]:\n\n        # survive in edge cases\n        end -= 1\n        begin += 1\n        max_possible_interval_end = (end - interval_length)\n        if max_possible_interval_end < 0:\n            raise Exception(\"Subtask is too small for reliable verification\")\n        interval_begin = random.randint(begin, max_possible_interval_end)\n        interval_end = interval_begin + interval_length\n\n        logger.info(\"interval_begin=%r, interval_end=%r\",\n                    interval_begin,\n                    interval_end)\n\n        return interval_begin, interval_end\n\n    @staticmethod\n    def convert_bitmap_coordinates_to_traditional_y_direction(x: int,\n                                                              crop_y_max: int,\n                                                              top: int) \\\n            -> Tuple[int, int]:\n        # In bitmap terms y=0 is located on top but blender uses classic\n        # vertical axis direction with y=0 at the bottom\n        y = top - crop_y_max\n        logger.info(\"X=%r, Y=%r\", x, y)\n",
        "target_code_len": 2489,
        "diff_format": "@@ -225,38 +322,57 @@\n \n-    def crop_rendered(self, results: List[str], time_spend: float,\n-                      verification_context: CropContext,\n-                      crop_number: int) -> None:\n-        self.rendered_crops_results[crop_number] \\\n-            = [results, time_spend, verification_context]\n+    def crop_rendered_callback(self,\n+                               results: List[str],\n+                               time_spent: float,\n+                               verification_context: VerificationContext,\n+                               crop_number: int) -> None:\n+        self.rendered_crops_results[crop_number] = [results,\n+                                                    time_spent,\n+                                                    verification_context]\n         crop_number += 1\n-        if crop_number == \\\n-                BlenderReferenceGenerator.CROPS_NO_FIRST or crop_number == \\\n-                BlenderReferenceGenerator.CROPS_NO_SECOND:\n-            self.crop_rendering_finished(\n-                crop_number-BlenderReferenceGenerator.CROPS_NO_FIRST,\n-                crop_number)\n+\n+        crops_number_first_step = BlenderReferenceGenerator\\\n+            .DEFAULT_CROPS_NUMBER_FIRST_VERIFICATION_STEP\n+        crops_number_second_step = BlenderReferenceGenerator \\\n+            .DEFAULT_CROPS_NUMBER_SECOND_VERIFICATION_STEP\n+\n+        if crop_number == crops_number_first_step \\\n+                or crop_number == crops_number_second_step:\n+            self.crop_rendering_finished(crop_number - crops_number_first_step,\n+                                         crop_number)\n             return\n \n-        self._render_one_crop(verification_context, self.crop_rendered,\n-                              verification_context.errback, crop_number)\n-\n-    @staticmethod\n-    def _random_split(min_: int, max_: int, size_: int) -> List[int]:\n+        self._render_one_crop(verification_context,\n+                              self.crop_rendered_callback,\n+                              verification_context.error_callback,\n+                              crop_number)\n+\n+    @staticmethod\n+    def _get_random_interval_within_boundaries(begin: int,\n+                                               end: int,\n+                                               interval_length: int) \\\n+            -> Tuple[int, int]:\n+\n         # survive in edge cases\n-        max_ -= 1\n-        min_ += 1\n-        difference = (max_ - size_)\n-        if difference < 0:\n-            raise Exception(\"Subtask is to small to reliable verifcation\")\n-        split_min = random.randint(min_, difference)\n-        split_max = split_min + size_\n-        logger.info(\"split_min=%r, split_max=%r\", split_min, split_max)\n-        return [split_min, split_max]\n-\n-    @staticmethod\n-    def _pixel(crop_x_min: int, crop_y_max: int, top: int) -> Tuple[int, int]:\n-        # In matrics calculation, y=0 is located on top. Where in blender in\n-        # bottom. Take then given top and substract it from y_max\n+        end -= 1\n+        begin += 1\n+        max_possible_interval_end = (end - interval_length)\n+        if max_possible_interval_end < 0:\n+            raise Exception(\"Subtask is too small for reliable verification\")\n+        interval_begin = random.randint(begin, max_possible_interval_end)\n+        interval_end = interval_begin + interval_length\n+\n+        logger.info(\"interval_begin=%r, interval_end=%r\",\n+                    interval_begin,\n+                    interval_end)\n+\n+        return interval_begin, interval_end\n+\n+    @staticmethod\n+    def convert_bitmap_coordinates_to_traditional_y_direction(x: int,\n+                                                              crop_y_max: int,\n+                                                              top: int) \\\n+            -> Tuple[int, int]:\n+        # In bitmap terms y=0 is located on top but blender uses classic\n+        # vertical axis direction with y=0 at the bottom\n         y = top - crop_y_max\n-        x = crop_x_min\n         logger.info(\"X=%r, Y=%r\", x, y)\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\n    <DED><DED>def crop_rendered(self, results: List[str], time_spend: float,\n                      verification_context: CropContext,\n                      crop_number: int) -> None:\n        <IND>self.rendered_crops_results[crop_number]            = [results, time_spend, verification_context]\n        crop_number += 1\n        if crop_number ==                BlenderReferenceGenerator.CROPS_NO_FIRST or crop_number ==                BlenderReferenceGenerator.CROPS_NO_SECOND:\n            <IND>self.crop_rendering_finished(\n                crop_number-BlenderReferenceGenerator.CROPS_NO_FIRST,\n                crop_number)\n            return\n\n        <DED>self._render_one_crop(verification_context, self.crop_rendered,\n                              verification_context.errback, crop_number)\n\n    <DED>@staticmethod\n    def _random_split(min_: int, max_: int, size_: int) -> List[int]:\n        # survive in edge cases\n        <IND>max_ -= 1\n        min_ += 1\n        difference = (max_ - size_)\n        if difference < 0:\n            <IND>raise Exception(\"Subtask is to small to reliable verifcation\")\n        <DED>split_min = random.randint(min_, difference)\n        split_max = split_min + size_\n        logger.info(\"split_min=%r, split_max=%r\", split_min, split_max)\n        return [split_min, split_max]\n\n    <DED>@staticmethod\n    def _pixel(crop_x_min: int, crop_y_max: int, top: int) -> Tuple[int, int]:\n        # In matrics calculation, y=0 is located on top. Where in blender in\n        # bottom. Take then given top and substract it from y_max\n        <IND>y = top - crop_y_max\n        x = crop_x_min\n        logger.info(\"X=%r, Y=%r\", x, y)\n",
        "target_code_with_indent": "\n    <DED><DED>def crop_rendered_callback(self,\n                               results: List[str],\n                               time_spent: float,\n                               verification_context: VerificationContext,\n                               crop_number: int) -> None:\n        <IND>self.rendered_crops_results[crop_number] = [results,\n                                                    time_spent,\n                                                    verification_context]\n        crop_number += 1\n\n        crops_number_first_step = BlenderReferenceGenerator            .DEFAULT_CROPS_NUMBER_FIRST_VERIFICATION_STEP\n        crops_number_second_step = BlenderReferenceGenerator            .DEFAULT_CROPS_NUMBER_SECOND_VERIFICATION_STEP\n\n        if crop_number == crops_number_first_step                or crop_number == crops_number_second_step:\n            <IND>self.crop_rendering_finished(crop_number - crops_number_first_step,\n                                         crop_number)\n            return\n\n        <DED>self._render_one_crop(verification_context,\n                              self.crop_rendered_callback,\n                              verification_context.error_callback,\n                              crop_number)\n\n    <DED>@staticmethod\n    def _get_random_interval_within_boundaries(begin: int,\n                                               end: int,\n                                               interval_length: int)            -> Tuple[int, int]:\n\n        # survive in edge cases\n        <IND>end -= 1\n        begin += 1\n        max_possible_interval_end = (end - interval_length)\n        if max_possible_interval_end < 0:\n            <IND>raise Exception(\"Subtask is too small for reliable verification\")\n        <DED>interval_begin = random.randint(begin, max_possible_interval_end)\n        interval_end = interval_begin + interval_length\n\n        logger.info(\"interval_begin=%r, interval_end=%r\",\n                    interval_begin,\n                    interval_end)\n\n        return interval_begin, interval_end\n\n    <DED>@staticmethod\n    def convert_bitmap_coordinates_to_traditional_y_direction(x: int,\n                                                              crop_y_max: int,\n                                                              top: int)            -> Tuple[int, int]:\n        # In bitmap terms y=0 is located on top but blender uses classic\n        # vertical axis direction with y=0 at the bottom\n        <IND>y = top - crop_y_max\n        logger.info(\"X=%r, Y=%r\", x, y)\n"
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    @staticmethod\n    def _find_split_size(res: int) -> int:\n        #  Int rounding, this hasn't to be exact, since its only have to be\n        #  precise and constant\n        return int(\n            max(BlenderReferenceGenerator.MIN_CROP_RES,\n                BlenderReferenceGenerator.CROP_STEP * res))\n",
        "source_code_len": 305,
        "target_code": "    @staticmethod\n    def _get_default_crop_size(resolution: Tuple[int, int]) -> Tuple[int, int]:\n        x = BlenderReferenceGenerator._calculate_crop_side_length(resolution[0])\n        y = BlenderReferenceGenerator._calculate_crop_side_length(resolution[1])\n        return x, y\n\n    @staticmethod\n    def _calculate_crop_side_length(subtask_side_length: int) -> int:\n        # Int rounding, this doesn't have to be exact\n        # as long as it works consistently\n        calculated_length = int(\n            BlenderReferenceGenerator.CROP_RELATIVE_SIZE * subtask_side_length)\n\n        return max(BlenderReferenceGenerator.MIN_CROP_SIZE, calculated_length)\n",
        "target_code_len": 659,
        "diff_format": "@@ -265,7 +381,14 @@\n     @staticmethod\n-    def _find_split_size(res: int) -> int:\n-        #  Int rounding, this hasn't to be exact, since its only have to be\n-        #  precise and constant\n-        return int(\n-            max(BlenderReferenceGenerator.MIN_CROP_RES,\n-                BlenderReferenceGenerator.CROP_STEP * res))\n+    def _get_default_crop_size(resolution: Tuple[int, int]) -> Tuple[int, int]:\n+        x = BlenderReferenceGenerator._calculate_crop_side_length(resolution[0])\n+        y = BlenderReferenceGenerator._calculate_crop_side_length(resolution[1])\n+        return x, y\n+\n+    @staticmethod\n+    def _calculate_crop_side_length(subtask_side_length: int) -> int:\n+        # Int rounding, this doesn't have to be exact\n+        # as long as it works consistently\n+        calculated_length = int(\n+            BlenderReferenceGenerator.CROP_RELATIVE_SIZE * subtask_side_length)\n+\n+        return max(BlenderReferenceGenerator.MIN_CROP_SIZE, calculated_length)\n",
        "source_code_with_indent": "    <DED>@staticmethod\n    def _find_split_size(res: int) -> int:\n        #  Int rounding, this hasn't to be exact, since its only have to be\n        #  precise and constant\n        <IND>return int(\n            max(BlenderReferenceGenerator.MIN_CROP_RES,\n                BlenderReferenceGenerator.CROP_STEP * res))\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    <DED>@staticmethod\n    def _get_default_crop_size(resolution: Tuple[int, int]) -> Tuple[int, int]:\n        <IND>x = BlenderReferenceGenerator._calculate_crop_side_length(resolution[0])\n        y = BlenderReferenceGenerator._calculate_crop_side_length(resolution[1])\n        return x, y\n\n    <DED>@staticmethod\n    def _calculate_crop_side_length(subtask_side_length: int) -> int:\n        # Int rounding, this doesn't have to be exact\n        # as long as it works consistently\n        <IND>calculated_length = int(\n            BlenderReferenceGenerator.CROP_RELATIVE_SIZE * subtask_side_length)\n\n        return max(BlenderReferenceGenerator.MIN_CROP_SIZE, calculated_length)\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  }
]