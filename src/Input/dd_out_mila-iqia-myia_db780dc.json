[
  {
    "project": "mila-iqia/myia",
    "commit": "db780dcb80048f18d02437ab8b86a042e010e66c",
    "filename": "myia/monomorphize.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/mila-iqia-myia/myia/monomorphize.py",
    "file_hunks_size": 18,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "myia/monomorphize.py:82:34 Incompatible parameter type [6]: Expected `typing.Tuple[myia.abstract.data.AbstractValue]` for 2nd positional only parameter to call `myia.abstract.data.TypedPrimitive.__init__` but got `typing.Tuple[typing.Any, ...]`.",
    "message": " Expected `typing.Tuple[myia.abstract.data.AbstractValue]` for 2nd positional only parameter to call `myia.abstract.data.TypedPrimitive.__init__` but got `typing.Tuple[typing.Any, ...]`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 82,
    "warning_line": "    return TypedPrimitive(a.prim, tuple(self(ar, spc) for ar in a.args),",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    TypedPrimitive,\n    VirtualReference,\n",
        "source_code_len": 42,
        "target_code": "    TypedPrimitive,\n    VirtualFunction,\n    VirtualReference,\n",
        "target_code_len": 63,
        "diff_format": "@@ -27,2 +32,3 @@\n     TypedPrimitive,\n+    VirtualFunction,\n     VirtualReference,\n",
        "source_code_with_indent": "    TypedPrimitive,\n    VirtualReference,\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    TypedPrimitive,\n    VirtualFunction,\n    VirtualReference,\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n@abstract_clone.variant\ndef _fix_type(self, a: GraphFunction, spc):\n    ctx = spc.ctcache.get(a.tracking_id, None)\n    if ctx is None:\n        ctx = spc.ctcache.get(a.graph, None)\n    if ctx is None:\n        assert a.graph not in spc.results\n        return DummyFunction()\n    else:\n        return GraphFunction(spc.results[ctx], Context.empty(), None)\n\n\n@overload  # noqa: F811\ndef _fix_type(self, a: PrimitiveFunction, spc):\n    try:\n        return self(spc.analyze_function(None, a, None)[0], spc)\n    except Unspecializable:\n        return DummyFunction()\n\n\n@overload  # noqa: F811\ndef _fix_type(self, a: TypedPrimitive, spc):\n    return TypedPrimitive(a.prim, tuple(self(ar, spc) for ar in a.args),\n                          self(a.output, spc))\n\n",
        "source_code_len": 753,
        "target_code": "\ndef type_fixer(finder, monomorphizer=None):\n\n    fn = abstract_clone.copy()\n\n    @fn.register\n    def _fix_type(self, a: GraphFunction):\n        if a.graph.abstract is not None:\n            return self(a.graph.abstract.get_unique())\n        elif a.tracking_id in monomorphizer.ctcache:\n            ctx = monomorphizer.ctcache[a.tracking_id]\n            g = monomorphizer.results[ctx]\n            return VirtualFunction(\n                tuple(self(p.abstract) for p in g.parameters),\n                self(g.return_.abstract)\n            )\n        else:\n            return DummyFunction()\n\n    @fn.register  # noqa: F811\n    def _fix_type(self, a: PartialApplication):\n        vfn = self(a.fn)\n        if isinstance(vfn, VirtualFunction):\n            vfn = VirtualFunction(vfn.args[len(a.args):], vfn.output)\n        return vfn\n\n    @fn.register  # noqa: F811\n    def _fix_type(self, a: VirtualFunction):\n        return (yield VirtualFunction)(\n            tuple(self(arg) for arg in a.args),\n            self(a.output)\n        )\n\n    @fn.register  # noqa: F811\n    def _fix_type(self, a: JTransformedFunction):\n        def _jtag(x):\n            if isinstance(x, AbstractFunction):\n                v = x.get_sync()\n                rval = AbstractFunction(*[self(JTransformedFunction(poss))\n                                        for poss in v])\n            else:\n                rval = AbstractJTagged(self(x))\n            return rval\n\n        vfn = self(a.fn)\n        jargs = tuple(_jtag(arg) for arg in vfn.args)\n        jres = _jtag(vfn.output)\n        bprop = compute_bprop_type(vfn, vfn.args, vfn.output)\n        out = AbstractTuple([jres, bprop])\n        return VirtualFunction(jargs, out)\n\n    @fn.register  # noqa: F811\n    def _fix_type(self, a: AbstractFunction):\n        vfns = self(a.get_sync())\n        if len(vfns) == 1:\n            vfn, = vfns\n        else:\n            vfns = [v for v in vfns if not isinstance(v, DummyFunction)]\n            assert vfns and all(isinstance(v, VirtualFunction) for v in vfns)\n            vfn = VirtualFunction(\n                reduce(amerge, [v.args for v in vfns]),\n                reduce(amerge, [v.output for v in vfns]),\n            )\n        return (yield AbstractFunction)(vfn)\n\n    @fn.register  # noqa: F811\n    def _fix_type(self, a: PrimitiveFunction):\n        try:\n            return self(\n                finder.analyze_function(None, a, None)[0]\n            )\n        except Unspecializable:\n            return DummyFunction()\n\n    @fn.register  # noqa: F811\n    def _fix_type(self, a: MetaGraphFunction):\n        inf = finder.engine.get_inferrer_for(a)\n        argvals, outval = finder._find_unique_argvals(None, inf, None)\n        return VirtualFunction(tuple(argvals), outval)\n\n    @fn.register  # noqa: F811\n    def _fix_type(self, a: TypedPrimitive):\n        return VirtualFunction(tuple(self(ar) for ar in a.args),\n                               self(a.output))\n\n    return fn\n\n",
        "target_code_len": 2945,
        "diff_format": "@@ -59,26 +68,87 @@\n \n-@abstract_clone.variant\n-def _fix_type(self, a: GraphFunction, spc):\n-    ctx = spc.ctcache.get(a.tracking_id, None)\n-    if ctx is None:\n-        ctx = spc.ctcache.get(a.graph, None)\n-    if ctx is None:\n-        assert a.graph not in spc.results\n-        return DummyFunction()\n-    else:\n-        return GraphFunction(spc.results[ctx], Context.empty(), None)\n-\n-\n-@overload  # noqa: F811\n-def _fix_type(self, a: PrimitiveFunction, spc):\n-    try:\n-        return self(spc.analyze_function(None, a, None)[0], spc)\n-    except Unspecializable:\n-        return DummyFunction()\n-\n-\n-@overload  # noqa: F811\n-def _fix_type(self, a: TypedPrimitive, spc):\n-    return TypedPrimitive(a.prim, tuple(self(ar, spc) for ar in a.args),\n-                          self(a.output, spc))\n+def type_fixer(finder, monomorphizer=None):\n+\n+    fn = abstract_clone.copy()\n+\n+    @fn.register\n+    def _fix_type(self, a: GraphFunction):\n+        if a.graph.abstract is not None:\n+            return self(a.graph.abstract.get_unique())\n+        elif a.tracking_id in monomorphizer.ctcache:\n+            ctx = monomorphizer.ctcache[a.tracking_id]\n+            g = monomorphizer.results[ctx]\n+            return VirtualFunction(\n+                tuple(self(p.abstract) for p in g.parameters),\n+                self(g.return_.abstract)\n+            )\n+        else:\n+            return DummyFunction()\n+\n+    @fn.register  # noqa: F811\n+    def _fix_type(self, a: PartialApplication):\n+        vfn = self(a.fn)\n+        if isinstance(vfn, VirtualFunction):\n+            vfn = VirtualFunction(vfn.args[len(a.args):], vfn.output)\n+        return vfn\n+\n+    @fn.register  # noqa: F811\n+    def _fix_type(self, a: VirtualFunction):\n+        return (yield VirtualFunction)(\n+            tuple(self(arg) for arg in a.args),\n+            self(a.output)\n+        )\n+\n+    @fn.register  # noqa: F811\n+    def _fix_type(self, a: JTransformedFunction):\n+        def _jtag(x):\n+            if isinstance(x, AbstractFunction):\n+                v = x.get_sync()\n+                rval = AbstractFunction(*[self(JTransformedFunction(poss))\n+                                        for poss in v])\n+            else:\n+                rval = AbstractJTagged(self(x))\n+            return rval\n+\n+        vfn = self(a.fn)\n+        jargs = tuple(_jtag(arg) for arg in vfn.args)\n+        jres = _jtag(vfn.output)\n+        bprop = compute_bprop_type(vfn, vfn.args, vfn.output)\n+        out = AbstractTuple([jres, bprop])\n+        return VirtualFunction(jargs, out)\n+\n+    @fn.register  # noqa: F811\n+    def _fix_type(self, a: AbstractFunction):\n+        vfns = self(a.get_sync())\n+        if len(vfns) == 1:\n+            vfn, = vfns\n+        else:\n+            vfns = [v for v in vfns if not isinstance(v, DummyFunction)]\n+            assert vfns and all(isinstance(v, VirtualFunction) for v in vfns)\n+            vfn = VirtualFunction(\n+                reduce(amerge, [v.args for v in vfns]),\n+                reduce(amerge, [v.output for v in vfns]),\n+            )\n+        return (yield AbstractFunction)(vfn)\n+\n+    @fn.register  # noqa: F811\n+    def _fix_type(self, a: PrimitiveFunction):\n+        try:\n+            return self(\n+                finder.analyze_function(None, a, None)[0]\n+            )\n+        except Unspecializable:\n+            return DummyFunction()\n+\n+    @fn.register  # noqa: F811\n+    def _fix_type(self, a: MetaGraphFunction):\n+        inf = finder.engine.get_inferrer_for(a)\n+        argvals, outval = finder._find_unique_argvals(None, inf, None)\n+        return VirtualFunction(tuple(argvals), outval)\n+\n+    @fn.register  # noqa: F811\n+    def _fix_type(self, a: TypedPrimitive):\n+        return VirtualFunction(tuple(self(ar) for ar in a.args),\n+                               self(a.output))\n+\n+    return fn\n \n",
        "source_code_with_indent": "\n<DED><DED>@abstract_clone.variant\ndef _fix_type(self, a: GraphFunction, spc):\n    <IND>ctx = spc.ctcache.get(a.tracking_id, None)\n    if ctx is None:\n        <IND>ctx = spc.ctcache.get(a.graph, None)\n    <DED>if ctx is None:\n        <IND>assert a.graph not in spc.results\n        return DummyFunction()\n    <DED>else:\n        <IND>return GraphFunction(spc.results[ctx], Context.empty(), None)\n\n\n<DED><DED>@overload  # noqa: F811\ndef _fix_type(self, a: PrimitiveFunction, spc):\n    <IND>try:\n        <IND>return self(spc.analyze_function(None, a, None)[0], spc)\n    <DED>except Unspecializable:\n        <IND>return DummyFunction()\n\n\n<DED><DED>@overload  # noqa: F811\ndef _fix_type(self, a: TypedPrimitive, spc):\n    <IND>return TypedPrimitive(a.prim, tuple(self(ar, spc) for ar in a.args),\n                          self(a.output, spc))\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n<DED><DED>def type_fixer(finder, monomorphizer=None):\n\n    <IND>fn = abstract_clone.copy()\n\n    @fn.register\n    def _fix_type(self, a: GraphFunction):\n        <IND>if a.graph.abstract is not None:\n            <IND>return self(a.graph.abstract.get_unique())\n        <DED>elif a.tracking_id in monomorphizer.ctcache:\n            <IND>ctx = monomorphizer.ctcache[a.tracking_id]\n            g = monomorphizer.results[ctx]\n            return VirtualFunction(\n                tuple(self(p.abstract) for p in g.parameters),\n                self(g.return_.abstract)\n            )\n        <DED>else:\n            <IND>return DummyFunction()\n\n    <DED><DED>@fn.register  # noqa: F811\n    def _fix_type(self, a: PartialApplication):\n        <IND>vfn = self(a.fn)\n        if isinstance(vfn, VirtualFunction):\n            <IND>vfn = VirtualFunction(vfn.args[len(a.args):], vfn.output)\n        <DED>return vfn\n\n    <DED>@fn.register  # noqa: F811\n    def _fix_type(self, a: VirtualFunction):\n        <IND>return (yield VirtualFunction)(\n            tuple(self(arg) for arg in a.args),\n            self(a.output)\n        )\n\n    <DED>@fn.register  # noqa: F811\n    def _fix_type(self, a: JTransformedFunction):\n        <IND>def _jtag(x):\n            <IND>if isinstance(x, AbstractFunction):\n                <IND>v = x.get_sync()\n                rval = AbstractFunction(*[self(JTransformedFunction(poss))\n                                        for poss in v])\n            <DED>else:\n                <IND>rval = AbstractJTagged(self(x))\n            <DED>return rval\n\n        <DED>vfn = self(a.fn)\n        jargs = tuple(_jtag(arg) for arg in vfn.args)\n        jres = _jtag(vfn.output)\n        bprop = compute_bprop_type(vfn, vfn.args, vfn.output)\n        out = AbstractTuple([jres, bprop])\n        return VirtualFunction(jargs, out)\n\n    <DED>@fn.register  # noqa: F811\n    def _fix_type(self, a: AbstractFunction):\n        <IND>vfns = self(a.get_sync())\n        if len(vfns) == 1:\n            <IND>vfn, = vfns\n        <DED>else:\n            <IND>vfns = [v for v in vfns if not isinstance(v, DummyFunction)]\n            assert vfns and all(isinstance(v, VirtualFunction) for v in vfns)\n            vfn = VirtualFunction(\n                reduce(amerge, [v.args for v in vfns]),\n                reduce(amerge, [v.output for v in vfns]),\n            )\n        <DED>return (yield AbstractFunction)(vfn)\n\n    <DED>@fn.register  # noqa: F811\n    def _fix_type(self, a: PrimitiveFunction):\n        <IND>try:\n            <IND>return self(\n                finder.analyze_function(None, a, None)[0]\n            )\n        <DED>except Unspecializable:\n            <IND>return DummyFunction()\n\n    <DED><DED>@fn.register  # noqa: F811\n    def _fix_type(self, a: MetaGraphFunction):\n        <IND>inf = finder.engine.get_inferrer_for(a)\n        argvals, outval = finder._find_unique_argvals(None, inf, None)\n        return VirtualFunction(tuple(argvals), outval)\n\n    <DED>@fn.register  # noqa: F811\n    def _fix_type(self, a: TypedPrimitive):\n        <IND>return VirtualFunction(tuple(self(ar) for ar in a.args),\n                               self(a.output))\n\n    <DED>return fn\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  }
]