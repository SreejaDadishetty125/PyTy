[
  {
    "project": "cognitedata/Expression",
    "commit": "25d7c6f9437c3fbd3700809aa02f4f3f4a9236fb",
    "filename": "expression/collections/frozenlist.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/cognitedata-Expression/expression/collections/frozenlist.py",
    "file_hunks_size": 21,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "expression/collections/frozenlist.py:116:33 Unsupported operand [58]: `+` is not supported for operand types `FrozenList[Variable[TSource]]` and `FrozenList[Variable[TSource]]`.",
    "message": " `+` is not supported for operand types `FrozenList[Variable[TSource]]` and `FrozenList[Variable[TSource]]`.",
    "rule_id": "Unsupported operand [58]",
    "warning_line_no": 116,
    "warning_line": "        return FrozenList(self + other)",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "import functools\nfrom typing import Any, Callable, Iterable, List, Optional, Tuple, TypeVar, cast, get_origin, overload\n\n",
        "source_code_len": 121,
        "target_code": "import functools\nfrom typing import (\n    Any,\n    Callable,\n    Generic,\n    Iterable,\n    Iterator,\n    List,\n    Optional,\n    Protocol,\n    Tuple,\n    TypeVar,\n    cast,\n    get_origin,\n    overload,\n)\n\n",
        "target_code_len": 207,
        "diff_format": "@@ -22,3 +22,17 @@\n import functools\n-from typing import Any, Callable, Iterable, List, Optional, Tuple, TypeVar, cast, get_origin, overload\n+from typing import (\n+    Any,\n+    Callable,\n+    Generic,\n+    Iterable,\n+    Iterator,\n+    List,\n+    Optional,\n+    Protocol,\n+    Tuple,\n+    TypeVar,\n+    cast,\n+    get_origin,\n+    overload,\n+)\n \n",
        "source_code_with_indent": "import functools\nfrom typing import Any, Callable, Iterable, List, Optional, Tuple, TypeVar, cast, get_origin, overload\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "import functools\nfrom typing import (\n    Any,\n    Callable,\n    Generic,\n    Iterable,\n    Iterator,\n    List,\n    Optional,\n    Protocol,\n    Tuple,\n    TypeVar,\n    cast,\n    get_origin,\n    overload,\n)\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    \"\"\"\n\n",
        "source_code_len": 9,
        "target_code": "    \"\"\"\n\n    def __init__(self, value: Optional[Iterable[TSource]] = None) -> None:\n        # Use composition instead of inheritance since generic tuples\n        # are not suppored by mypy.\n        self.value: Tuple[TSource, ...] = tuple(value) if value else tuple()\n\n",
        "target_code_len": 268,
        "diff_format": "@@ -56,2 +70,7 @@\n     \"\"\"\n+\n+    def __init__(self, value: Optional[Iterable[TSource]] = None) -> None:\n+        # Use composition instead of inheritance since generic tuples\n+        # are not suppored by mypy.\n+        self.value: Tuple[TSource, ...] = tuple(value) if value else tuple()\n \n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\n\n",
        "target_code_with_indent": "\n\n    def __init__(self, value: Optional[Iterable[TSource]] = None) -> None:\n        # Use composition instead of inheritance since generic tuples\n        # are not suppored by mypy.\n        <IND>self.value: Tuple[TSource, ...] = tuple(value) if value else tuple()\n\n"
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    @staticmethod\n    def range(start: int, stop: int, step: Optional[int] = None) -> \"FrozenList[int]\":\n        ...\n",
        "source_code_len": 117,
        "target_code": "    @staticmethod\n    def range(start: int, stop: int) -> \"FrozenList[int]\":\n        ...\n\n    @overload\n    @staticmethod\n    def range(start: int, stop: int, step: int) -> \"FrozenList[int]\":\n        ...\n",
        "target_code_len": 204,
        "diff_format": "@@ -265,3 +284,8 @@\n     @staticmethod\n-    def range(start: int, stop: int, step: Optional[int] = None) -> \"FrozenList[int]\":\n+    def range(start: int, stop: int) -> \"FrozenList[int]\":\n+        ...\n+\n+    @overload\n+    @staticmethod\n+    def range(start: int, stop: int, step: int) -> \"FrozenList[int]\":\n         ...\n",
        "source_code_with_indent": "    @staticmethod\n    def range(start: int, stop: int, step: Optional[int] = None) -> \"FrozenList[int]\":\n        <IND>...\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    @staticmethod\n    def range(start: int, stop: int) -> \"FrozenList[int]\":\n        <IND>...\n\n    <DED>@overload\n    @staticmethod\n    def range(start: int, stop: int, step: int) -> \"FrozenList[int]\":\n        <IND>...\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "        \"\"\"\n        return of_seq(builtins.zip(self, other))\n\n",
        "source_code_len": 62,
        "target_code": "        \"\"\"\n        return of_seq(builtins.zip(self.value, other.value))\n\n    def __add__(self, other: \"FrozenList[TSource]\") -> \"FrozenList[TSource]\":\n        return FrozenList(self.value + other.value)\n\n    @overload\n    def __getitem__(self, key: slice) -> \"FrozenList[TSource]\":\n        ...\n\n    @overload\n    def __getitem__(self, key: int) -> TSource:\n        ...\n\n    def __getitem__(self, key: Any) -> Any:\n        return self.value[key]\n\n    def __iter__(self) -> Iterator[TSource]:\n        return iter(self.value)\n\n    def __eq__(self, other: Any) -> bool:\n        return self.value == other\n\n    def __len__(self) -> int:\n        return len(self.value)\n\n",
        "target_code_len": 665,
        "diff_format": "@@ -354,3 +382,26 @@\n         \"\"\"\n-        return of_seq(builtins.zip(self, other))\n+        return of_seq(builtins.zip(self.value, other.value))\n+\n+    def __add__(self, other: \"FrozenList[TSource]\") -> \"FrozenList[TSource]\":\n+        return FrozenList(self.value + other.value)\n+\n+    @overload\n+    def __getitem__(self, key: slice) -> \"FrozenList[TSource]\":\n+        ...\n+\n+    @overload\n+    def __getitem__(self, key: int) -> TSource:\n+        ...\n+\n+    def __getitem__(self, key: Any) -> Any:\n+        return self.value[key]\n+\n+    def __iter__(self) -> Iterator[TSource]:\n+        return iter(self.value)\n+\n+    def __eq__(self, other: Any) -> bool:\n+        return self.value == other\n+\n+    def __len__(self) -> int:\n+        return len(self.value)\n \n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\n        return of_seq(builtins.zip(self, other))\n\n",
        "target_code_with_indent": "\n        return of_seq(builtins.zip(self.value, other.value))\n\n    <DED>def __add__(self, other: \"FrozenList[TSource]\") -> \"FrozenList[TSource]\":\n        <IND>return FrozenList(self.value + other.value)\n\n    <DED>@overload\n    def __getitem__(self, key: slice) -> \"FrozenList[TSource]\":\n        <IND>...\n\n    <DED>@overload\n    def __getitem__(self, key: int) -> TSource:\n        <IND>...\n\n    <DED>def __getitem__(self, key: Any) -> Any:\n        <IND>return self.value[key]\n\n    <DED>def __iter__(self) -> Iterator[TSource]:\n        <IND>return iter(self.value)\n\n    <DED>def __eq__(self, other: Any) -> bool:\n        <IND>return self.value == other\n\n    <DED>def __len__(self) -> int:\n        <IND>return len(self.value)\n\n"
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "@overload\ndef range(start: int, stop: int, step: Optional[int] = None) -> FrozenList[int]:\n    ...\n",
        "source_code_len": 99,
        "target_code": "@overload\ndef range(start: int, stop: int) -> FrozenList[int]:\n    ...\n\n\n@overload\ndef range(start: int, stop: int, step: int) -> FrozenList[int]:\n    ...\n",
        "target_code_len": 155,
        "diff_format": "@@ -577,3 +642,8 @@\n @overload\n-def range(start: int, stop: int, step: Optional[int] = None) -> FrozenList[int]:\n+def range(start: int, stop: int) -> FrozenList[int]:\n+    ...\n+\n+\n+@overload\n+def range(start: int, stop: int, step: int) -> FrozenList[int]:\n     ...\n",
        "source_code_with_indent": "<DED>@overload\ndef range(start: int, stop: int, step: Optional[int] = None) -> FrozenList[int]:\n    <IND>...\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "<DED>@overload\ndef range(start: int, stop: int) -> FrozenList[int]:\n    <IND>...\n\n\n<DED>@overload\ndef range(start: int, stop: int, step: int) -> FrozenList[int]:\n    <IND>...\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "cognitedata/Expression",
    "commit": "25d7c6f9437c3fbd3700809aa02f4f3f4a9236fb",
    "filename": "expression/collections/frozenlist.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/cognitedata-Expression/expression/collections/frozenlist.py",
    "file_hunks_size": 21,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "expression/collections/frozenlist.py:146:39 Unsupported operand [58]: `+` is not supported for operand types `Tuple[Variable[TSource]]` and `FrozenList[Variable[TSource]]`.",
    "message": " `+` is not supported for operand types `Tuple[Variable[TSource]]` and `FrozenList[Variable[TSource]]`.",
    "rule_id": "Unsupported operand [58]",
    "warning_line_no": 146,
    "warning_line": "        return FrozenList((element,) + self)  # NOTE: Faster than (element, *self)",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    \"\"\"\n\n",
        "source_code_len": 9,
        "target_code": "    \"\"\"\n\n    def __init__(self, value: Optional[Iterable[TSource]] = None) -> None:\n        # Use composition instead of inheritance since generic tuples\n        # are not suppored by mypy.\n        self.value: Tuple[TSource, ...] = tuple(value) if value else tuple()\n\n",
        "target_code_len": 268,
        "diff_format": "@@ -56,2 +70,7 @@\n     \"\"\"\n+\n+    def __init__(self, value: Optional[Iterable[TSource]] = None) -> None:\n+        # Use composition instead of inheritance since generic tuples\n+        # are not suppored by mypy.\n+        self.value: Tuple[TSource, ...] = tuple(value) if value else tuple()\n \n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\n\n",
        "target_code_with_indent": "\n\n    def __init__(self, value: Optional[Iterable[TSource]] = None) -> None:\n        # Use composition instead of inheritance since generic tuples\n        # are not suppored by mypy.\n        <IND>self.value: Tuple[TSource, ...] = tuple(value) if value else tuple()\n\n"
      },
      {
        "hunk_fit_TFix": true,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n        return FrozenList((element,) + self)  # NOTE: Faster than (element, *self)\n\n",
        "source_code_len": 85,
        "target_code": "\n        return FrozenList((element,) + self.value)  # NOTE: Faster than (element, *self)\n\n",
        "target_code_len": 91,
        "diff_format": "@@ -145,3 +164,3 @@\n \n-        return FrozenList((element,) + self)  # NOTE: Faster than (element, *self)\n+        return FrozenList((element,) + self.value)  # NOTE: Faster than (element, *self)\n \n",
        "source_code_with_indent": "\n        return FrozenList((element,) + self)  # NOTE: Faster than (element, *self)\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n        return FrozenList((element,) + self.value)  # NOTE: Faster than (element, *self)\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    @staticmethod\n    def range(start: int, stop: int, step: Optional[int] = None) -> \"FrozenList[int]\":\n        ...\n",
        "source_code_len": 117,
        "target_code": "    @staticmethod\n    def range(start: int, stop: int) -> \"FrozenList[int]\":\n        ...\n\n    @overload\n    @staticmethod\n    def range(start: int, stop: int, step: int) -> \"FrozenList[int]\":\n        ...\n",
        "target_code_len": 204,
        "diff_format": "@@ -265,3 +284,8 @@\n     @staticmethod\n-    def range(start: int, stop: int, step: Optional[int] = None) -> \"FrozenList[int]\":\n+    def range(start: int, stop: int) -> \"FrozenList[int]\":\n+        ...\n+\n+    @overload\n+    @staticmethod\n+    def range(start: int, stop: int, step: int) -> \"FrozenList[int]\":\n         ...\n",
        "source_code_with_indent": "    @staticmethod\n    def range(start: int, stop: int, step: Optional[int] = None) -> \"FrozenList[int]\":\n        <IND>...\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    @staticmethod\n    def range(start: int, stop: int) -> \"FrozenList[int]\":\n        <IND>...\n\n    <DED>@overload\n    @staticmethod\n    def range(start: int, stop: int, step: int) -> \"FrozenList[int]\":\n        <IND>...\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "@overload\ndef range(start: int, stop: int, step: Optional[int] = None) -> FrozenList[int]:\n    ...\n",
        "source_code_len": 99,
        "target_code": "@overload\ndef range(start: int, stop: int) -> FrozenList[int]:\n    ...\n\n\n@overload\ndef range(start: int, stop: int, step: int) -> FrozenList[int]:\n    ...\n",
        "target_code_len": 155,
        "diff_format": "@@ -577,3 +642,8 @@\n @overload\n-def range(start: int, stop: int, step: Optional[int] = None) -> FrozenList[int]:\n+def range(start: int, stop: int) -> FrozenList[int]:\n+    ...\n+\n+\n+@overload\n+def range(start: int, stop: int, step: int) -> FrozenList[int]:\n     ...\n",
        "source_code_with_indent": "<DED>@overload\ndef range(start: int, stop: int, step: Optional[int] = None) -> FrozenList[int]:\n    <IND>...\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "<DED>@overload\ndef range(start: int, stop: int) -> FrozenList[int]:\n    <IND>...\n\n\n<DED>@overload\ndef range(start: int, stop: int, step: int) -> FrozenList[int]:\n    <IND>...\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "cognitedata/Expression",
    "commit": "25d7c6f9437c3fbd3700809aa02f4f3f4a9236fb",
    "filename": "expression/collections/seq.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/cognitedata-Expression/expression/collections/seq.py",
    "file_hunks_size": 8,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "expression/collections/seq.py:391:4 Incompatible return type [7]: Expected `Iterable[Variable[TSource]]` but got `init_infinite.Infinite`.",
    "message": " Expected `Iterable[Variable[TSource]]` but got `init_infinite.Infinite`.",
    "rule_id": "Incompatible return type [7]",
    "warning_line_no": 391,
    "warning_line": "    return Infinite(initializer)",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n    class Infinite(Iterable[int]):\n        \"\"\"An infinite iterable where each iterator starts counting at\n",
        "source_code_len": 107,
        "target_code": "\n    class Infinite(Iterable[TResult]):\n        \"\"\"An infinite iterable where each iterator starts counting at\n",
        "target_code_len": 111,
        "diff_format": "@@ -380,3 +385,3 @@\n \n-    class Infinite(Iterable[int]):\n+    class Infinite(Iterable[TResult]):\n         \"\"\"An infinite iterable where each iterator starts counting at\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\n    class Infinite(Iterable[int]):\n        <IND>",
        "target_code_with_indent": "\n    class Infinite(Iterable[TResult]):\n        <IND>"
      }
    ]
  },
  {
    "project": "cognitedata/Expression",
    "commit": "25d7c6f9437c3fbd3700809aa02f4f3f4a9236fb",
    "filename": "expression/core/typing.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/cognitedata-Expression/expression/core/typing.py",
    "file_hunks_size": 6,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": true,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "expression/core/typing.py:37:4 Incompatible variable type [9]: x is declared to have type `Type[typing.Any]` but is used as type `Variable[Base]`.",
    "message": " x is declared to have type `Type[typing.Any]` but is used as type `Variable[Base]`.",
    "rule_id": "Incompatible variable type [9]",
    "warning_line_no": 37,
    "warning_line": "    x: type = expr",
    "min_patch": [
      {
        "hunk_fit_TFix": true,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    \"\"\"\n    x: type = expr\n    return x\n\n",
        "source_code_len": 41,
        "target_code": "    \"\"\"\n    return expr\n\n",
        "target_code_len": 25,
        "diff_format": "@@ -36,4 +37,3 @@\n     \"\"\"\n-    x: type = expr\n-    return x\n+    return expr\n \n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\n    x: type = expr\n    return x\n\n",
        "target_code_with_indent": "\n    return expr\n\n"
      }
    ]
  },
  {
    "project": "cognitedata/Expression",
    "commit": "25d7c6f9437c3fbd3700809aa02f4f3f4a9236fb",
    "filename": "expression/core/typing.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/cognitedata-Expression/expression/core/typing.py",
    "file_hunks_size": 6,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": true,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "expression/core/typing.py:38:4 Incompatible return type [7]: Expected `Variable[Base]` but got `Type[typing.Any]`.",
    "message": " Expected `Variable[Base]` but got `Type[typing.Any]`.",
    "rule_id": "Incompatible return type [7]",
    "warning_line_no": 38,
    "warning_line": "    return x",
    "min_patch": [
      {
        "hunk_fit_TFix": true,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    \"\"\"\n    x: type = expr\n    return x\n\n",
        "source_code_len": 41,
        "target_code": "    \"\"\"\n    return expr\n\n",
        "target_code_len": 25,
        "diff_format": "@@ -36,4 +37,3 @@\n     \"\"\"\n-    x: type = expr\n-    return x\n+    return expr\n \n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\n    x: type = expr\n    return x\n\n",
        "target_code_with_indent": "\n    return expr\n\n"
      }
    ]
  },
  {
    "project": "cognitedata/Expression",
    "commit": "25d7c6f9437c3fbd3700809aa02f4f3f4a9236fb",
    "filename": "tests/test_frozenlist.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/cognitedata-Expression/tests/test_frozenlist.py",
    "file_hunks_size": 2,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "tests/test_frozenlist.py:114:14 Unsupported operand [58]: `+` is not supported for operand types `frozenlist.FrozenList[int]` and `frozenlist.FrozenList[int]`.",
    "message": " `+` is not supported for operand types `frozenlist.FrozenList[int]` and `frozenlist.FrozenList[int]`.",
    "rule_id": "Unsupported operand [58]",
    "warning_line_no": 114,
    "warning_line": "    fh = fx + fy"
  }
]