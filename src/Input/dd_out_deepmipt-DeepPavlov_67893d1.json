[
  {
    "project": "deepmipt/DeepPavlov",
    "commit": "67893d1d2bdb9ec4fd62be95a4d2fbb3113b30be",
    "filename": "deeppavlov/dataset_iterators/sqlite_iterator.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/deepmipt-DeepPavlov/deeppavlov/dataset_iterators/sqlite_iterator.py",
    "file_hunks_size": 4,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "deeppavlov/dataset_iterators/sqlite_iterator.py:56:67 Incompatible variable type [9]: batch_size is declared to have type `int` but is used as type `None`.",
    "message": " batch_size is declared to have type `int` but is used as type `None`.",
    "rule_id": "Incompatible variable type [9]",
    "warning_line_no": 56,
    "warning_line": "    def __init__(self, data_dir: str = '', data_url: str = DB_URL, batch_size: int = None,",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "import sqlite3\nfrom typing import List, Any, Dict, Optional\nfrom random import Random\n\n",
        "source_code_len": 87,
        "target_code": "import sqlite3\nfrom typing import List, Any, Dict, Optional, Union\nfrom random import Random\nfrom pathlib import Path\n\n",
        "target_code_len": 119,
        "diff_format": "@@ -15,4 +15,5 @@\n import sqlite3\n-from typing import List, Any, Dict, Optional\n+from typing import List, Any, Dict, Optional, Union\n from random import Random\n+from pathlib import Path\n \n",
        "source_code_with_indent": "import sqlite3\nfrom typing import List, Any, Dict, Optional\nfrom random import Random\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "import sqlite3\nfrom typing import List, Any, Dict, Optional, Union\nfrom random import Random\nfrom pathlib import Path\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n    def __init__(self, data_dir: str = '', data_url: str = DB_URL, batch_size: int = None,\n                 shuffle: bool = None, seed: int = None, **kwargs):\n\n        download_dir = expand_path(data_dir)\n        download_path = download_dir.joinpath(data_url.split(\"/\")[-1])\n        download(download_path, data_url, force_download=False)\n\n        self.connect = sqlite3.connect(str(download_path), check_same_thread=False)\n        self.db_name = self.get_db_name()\n        self.doc_ids = self.get_doc_ids()\n",
        "source_code_len": 510,
        "target_code": "\n    def __init__(self, load_path: Union[str, Path], batch_size: Optional[int] = None,\n                 shuffle: Optional[bool] = None, seed: Optional[int] = None, **kwargs) -> None:\n\n        load_path = str(expand_path(load_path))\n        logger.info(\"Connecting to database, path: {}\".format(load_path))\n        try:\n            self.connect = sqlite3.connect(load_path, check_same_thread=False)\n        except sqlite3.OperationalError as e:\n            e.args = e.args + (\"Check that DB path exists and is a valid DB file\",)\n            raise e\n        try:\n            self.db_name = self.get_db_name()\n        except TypeError as e:\n            e.args = e.args + (\n                'Check that DB path was created correctly and is not empty. '\n                'Check that a correct dataset_format is passed to the ODQAReader config',)\n            raise e\n        self.doc_ids = self.get_doc_ids()\n",
        "target_code_len": 901,
        "diff_format": "@@ -55,11 +52,19 @@\n \n-    def __init__(self, data_dir: str = '', data_url: str = DB_URL, batch_size: int = None,\n-                 shuffle: bool = None, seed: int = None, **kwargs):\n+    def __init__(self, load_path: Union[str, Path], batch_size: Optional[int] = None,\n+                 shuffle: Optional[bool] = None, seed: Optional[int] = None, **kwargs) -> None:\n \n-        download_dir = expand_path(data_dir)\n-        download_path = download_dir.joinpath(data_url.split(\"/\")[-1])\n-        download(download_path, data_url, force_download=False)\n-\n-        self.connect = sqlite3.connect(str(download_path), check_same_thread=False)\n-        self.db_name = self.get_db_name()\n+        load_path = str(expand_path(load_path))\n+        logger.info(\"Connecting to database, path: {}\".format(load_path))\n+        try:\n+            self.connect = sqlite3.connect(load_path, check_same_thread=False)\n+        except sqlite3.OperationalError as e:\n+            e.args = e.args + (\"Check that DB path exists and is a valid DB file\",)\n+            raise e\n+        try:\n+            self.db_name = self.get_db_name()\n+        except TypeError as e:\n+            e.args = e.args + (\n+                'Check that DB path was created correctly and is not empty. '\n+                'Check that a correct dataset_format is passed to the ODQAReader config',)\n+            raise e\n         self.doc_ids = self.get_doc_ids()\n",
        "source_code_with_indent": "\n    def __init__(self, data_dir: str = '', data_url: str = DB_URL, batch_size: int = None,\n                 shuffle: bool = None, seed: int = None, **kwargs):\n\n        <IND>download_dir = expand_path(data_dir)\n        download_path = download_dir.joinpath(data_url.split(\"/\")[-1])\n        download(download_path, data_url, force_download=False)\n\n        self.connect = sqlite3.connect(str(download_path), check_same_thread=False)\n        self.db_name = self.get_db_name()\n        self.doc_ids = self.get_doc_ids()\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n    def __init__(self, load_path: Union[str, Path], batch_size: Optional[int] = None,\n                 shuffle: Optional[bool] = None, seed: Optional[int] = None, **kwargs) -> None:\n\n        <IND>load_path = str(expand_path(load_path))\n        logger.info(\"Connecting to database, path: {}\".format(load_path))\n        try:\n            <IND>self.connect = sqlite3.connect(load_path, check_same_thread=False)\n        <DED>except sqlite3.OperationalError as e:\n            <IND>e.args = e.args + (\"Check that DB path exists and is a valid DB file\",)\n            raise e\n        <DED>try:\n            <IND>self.db_name = self.get_db_name()\n        <DED>except TypeError as e:\n            <IND>e.args = e.args + (\n                'Check that DB path was created correctly and is not empty. '\n                'Check that a correct dataset_format is passed to the ODQAReader config',)\n            raise e\n        <DED>self.doc_ids = self.get_doc_ids()\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "deepmipt/DeepPavlov",
    "commit": "67893d1d2bdb9ec4fd62be95a4d2fbb3113b30be",
    "filename": "deeppavlov/dataset_iterators/sqlite_iterator.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/deepmipt-DeepPavlov/deeppavlov/dataset_iterators/sqlite_iterator.py",
    "file_hunks_size": 4,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "deeppavlov/dataset_iterators/sqlite_iterator.py:57:17 Incompatible variable type [9]: shuffle is declared to have type `bool` but is used as type `None`.",
    "message": " shuffle is declared to have type `bool` but is used as type `None`.",
    "rule_id": "Incompatible variable type [9]",
    "warning_line_no": 57,
    "warning_line": "                 shuffle: bool = None, seed: int = None, **kwargs):",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "import sqlite3\nfrom typing import List, Any, Dict, Optional\nfrom random import Random\n\n",
        "source_code_len": 87,
        "target_code": "import sqlite3\nfrom typing import List, Any, Dict, Optional, Union\nfrom random import Random\nfrom pathlib import Path\n\n",
        "target_code_len": 119,
        "diff_format": "@@ -15,4 +15,5 @@\n import sqlite3\n-from typing import List, Any, Dict, Optional\n+from typing import List, Any, Dict, Optional, Union\n from random import Random\n+from pathlib import Path\n \n",
        "source_code_with_indent": "import sqlite3\nfrom typing import List, Any, Dict, Optional\nfrom random import Random\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "import sqlite3\nfrom typing import List, Any, Dict, Optional, Union\nfrom random import Random\nfrom pathlib import Path\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n    def __init__(self, data_dir: str = '', data_url: str = DB_URL, batch_size: int = None,\n                 shuffle: bool = None, seed: int = None, **kwargs):\n\n        download_dir = expand_path(data_dir)\n        download_path = download_dir.joinpath(data_url.split(\"/\")[-1])\n        download(download_path, data_url, force_download=False)\n\n        self.connect = sqlite3.connect(str(download_path), check_same_thread=False)\n        self.db_name = self.get_db_name()\n        self.doc_ids = self.get_doc_ids()\n",
        "source_code_len": 510,
        "target_code": "\n    def __init__(self, load_path: Union[str, Path], batch_size: Optional[int] = None,\n                 shuffle: Optional[bool] = None, seed: Optional[int] = None, **kwargs) -> None:\n\n        load_path = str(expand_path(load_path))\n        logger.info(\"Connecting to database, path: {}\".format(load_path))\n        try:\n            self.connect = sqlite3.connect(load_path, check_same_thread=False)\n        except sqlite3.OperationalError as e:\n            e.args = e.args + (\"Check that DB path exists and is a valid DB file\",)\n            raise e\n        try:\n            self.db_name = self.get_db_name()\n        except TypeError as e:\n            e.args = e.args + (\n                'Check that DB path was created correctly and is not empty. '\n                'Check that a correct dataset_format is passed to the ODQAReader config',)\n            raise e\n        self.doc_ids = self.get_doc_ids()\n",
        "target_code_len": 901,
        "diff_format": "@@ -55,11 +52,19 @@\n \n-    def __init__(self, data_dir: str = '', data_url: str = DB_URL, batch_size: int = None,\n-                 shuffle: bool = None, seed: int = None, **kwargs):\n+    def __init__(self, load_path: Union[str, Path], batch_size: Optional[int] = None,\n+                 shuffle: Optional[bool] = None, seed: Optional[int] = None, **kwargs) -> None:\n \n-        download_dir = expand_path(data_dir)\n-        download_path = download_dir.joinpath(data_url.split(\"/\")[-1])\n-        download(download_path, data_url, force_download=False)\n-\n-        self.connect = sqlite3.connect(str(download_path), check_same_thread=False)\n-        self.db_name = self.get_db_name()\n+        load_path = str(expand_path(load_path))\n+        logger.info(\"Connecting to database, path: {}\".format(load_path))\n+        try:\n+            self.connect = sqlite3.connect(load_path, check_same_thread=False)\n+        except sqlite3.OperationalError as e:\n+            e.args = e.args + (\"Check that DB path exists and is a valid DB file\",)\n+            raise e\n+        try:\n+            self.db_name = self.get_db_name()\n+        except TypeError as e:\n+            e.args = e.args + (\n+                'Check that DB path was created correctly and is not empty. '\n+                'Check that a correct dataset_format is passed to the ODQAReader config',)\n+            raise e\n         self.doc_ids = self.get_doc_ids()\n",
        "source_code_with_indent": "\n    def __init__(self, data_dir: str = '', data_url: str = DB_URL, batch_size: int = None,\n                 shuffle: bool = None, seed: int = None, **kwargs):\n\n        <IND>download_dir = expand_path(data_dir)\n        download_path = download_dir.joinpath(data_url.split(\"/\")[-1])\n        download(download_path, data_url, force_download=False)\n\n        self.connect = sqlite3.connect(str(download_path), check_same_thread=False)\n        self.db_name = self.get_db_name()\n        self.doc_ids = self.get_doc_ids()\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n    def __init__(self, load_path: Union[str, Path], batch_size: Optional[int] = None,\n                 shuffle: Optional[bool] = None, seed: Optional[int] = None, **kwargs) -> None:\n\n        <IND>load_path = str(expand_path(load_path))\n        logger.info(\"Connecting to database, path: {}\".format(load_path))\n        try:\n            <IND>self.connect = sqlite3.connect(load_path, check_same_thread=False)\n        <DED>except sqlite3.OperationalError as e:\n            <IND>e.args = e.args + (\"Check that DB path exists and is a valid DB file\",)\n            raise e\n        <DED>try:\n            <IND>self.db_name = self.get_db_name()\n        <DED>except TypeError as e:\n            <IND>e.args = e.args + (\n                'Check that DB path was created correctly and is not empty. '\n                'Check that a correct dataset_format is passed to the ODQAReader config',)\n            raise e\n        <DED>self.doc_ids = self.get_doc_ids()\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "deepmipt/DeepPavlov",
    "commit": "67893d1d2bdb9ec4fd62be95a4d2fbb3113b30be",
    "filename": "deeppavlov/dataset_iterators/sqlite_iterator.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/deepmipt-DeepPavlov/deeppavlov/dataset_iterators/sqlite_iterator.py",
    "file_hunks_size": 4,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "deeppavlov/dataset_iterators/sqlite_iterator.py:57:39 Incompatible variable type [9]: seed is declared to have type `int` but is used as type `None`.",
    "message": " seed is declared to have type `int` but is used as type `None`.",
    "rule_id": "Incompatible variable type [9]",
    "warning_line_no": 57,
    "warning_line": "                 shuffle: bool = None, seed: int = None, **kwargs):",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "import sqlite3\nfrom typing import List, Any, Dict, Optional\nfrom random import Random\n\n",
        "source_code_len": 87,
        "target_code": "import sqlite3\nfrom typing import List, Any, Dict, Optional, Union\nfrom random import Random\nfrom pathlib import Path\n\n",
        "target_code_len": 119,
        "diff_format": "@@ -15,4 +15,5 @@\n import sqlite3\n-from typing import List, Any, Dict, Optional\n+from typing import List, Any, Dict, Optional, Union\n from random import Random\n+from pathlib import Path\n \n",
        "source_code_with_indent": "import sqlite3\nfrom typing import List, Any, Dict, Optional\nfrom random import Random\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "import sqlite3\nfrom typing import List, Any, Dict, Optional, Union\nfrom random import Random\nfrom pathlib import Path\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n    def __init__(self, data_dir: str = '', data_url: str = DB_URL, batch_size: int = None,\n                 shuffle: bool = None, seed: int = None, **kwargs):\n\n        download_dir = expand_path(data_dir)\n        download_path = download_dir.joinpath(data_url.split(\"/\")[-1])\n        download(download_path, data_url, force_download=False)\n\n        self.connect = sqlite3.connect(str(download_path), check_same_thread=False)\n        self.db_name = self.get_db_name()\n        self.doc_ids = self.get_doc_ids()\n",
        "source_code_len": 510,
        "target_code": "\n    def __init__(self, load_path: Union[str, Path], batch_size: Optional[int] = None,\n                 shuffle: Optional[bool] = None, seed: Optional[int] = None, **kwargs) -> None:\n\n        load_path = str(expand_path(load_path))\n        logger.info(\"Connecting to database, path: {}\".format(load_path))\n        try:\n            self.connect = sqlite3.connect(load_path, check_same_thread=False)\n        except sqlite3.OperationalError as e:\n            e.args = e.args + (\"Check that DB path exists and is a valid DB file\",)\n            raise e\n        try:\n            self.db_name = self.get_db_name()\n        except TypeError as e:\n            e.args = e.args + (\n                'Check that DB path was created correctly and is not empty. '\n                'Check that a correct dataset_format is passed to the ODQAReader config',)\n            raise e\n        self.doc_ids = self.get_doc_ids()\n",
        "target_code_len": 901,
        "diff_format": "@@ -55,11 +52,19 @@\n \n-    def __init__(self, data_dir: str = '', data_url: str = DB_URL, batch_size: int = None,\n-                 shuffle: bool = None, seed: int = None, **kwargs):\n+    def __init__(self, load_path: Union[str, Path], batch_size: Optional[int] = None,\n+                 shuffle: Optional[bool] = None, seed: Optional[int] = None, **kwargs) -> None:\n \n-        download_dir = expand_path(data_dir)\n-        download_path = download_dir.joinpath(data_url.split(\"/\")[-1])\n-        download(download_path, data_url, force_download=False)\n-\n-        self.connect = sqlite3.connect(str(download_path), check_same_thread=False)\n-        self.db_name = self.get_db_name()\n+        load_path = str(expand_path(load_path))\n+        logger.info(\"Connecting to database, path: {}\".format(load_path))\n+        try:\n+            self.connect = sqlite3.connect(load_path, check_same_thread=False)\n+        except sqlite3.OperationalError as e:\n+            e.args = e.args + (\"Check that DB path exists and is a valid DB file\",)\n+            raise e\n+        try:\n+            self.db_name = self.get_db_name()\n+        except TypeError as e:\n+            e.args = e.args + (\n+                'Check that DB path was created correctly and is not empty. '\n+                'Check that a correct dataset_format is passed to the ODQAReader config',)\n+            raise e\n         self.doc_ids = self.get_doc_ids()\n",
        "source_code_with_indent": "\n    def __init__(self, data_dir: str = '', data_url: str = DB_URL, batch_size: int = None,\n                 shuffle: bool = None, seed: int = None, **kwargs):\n\n        <IND>download_dir = expand_path(data_dir)\n        download_path = download_dir.joinpath(data_url.split(\"/\")[-1])\n        download(download_path, data_url, force_download=False)\n\n        self.connect = sqlite3.connect(str(download_path), check_same_thread=False)\n        self.db_name = self.get_db_name()\n        self.doc_ids = self.get_doc_ids()\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n    def __init__(self, load_path: Union[str, Path], batch_size: Optional[int] = None,\n                 shuffle: Optional[bool] = None, seed: Optional[int] = None, **kwargs) -> None:\n\n        <IND>load_path = str(expand_path(load_path))\n        logger.info(\"Connecting to database, path: {}\".format(load_path))\n        try:\n            <IND>self.connect = sqlite3.connect(load_path, check_same_thread=False)\n        <DED>except sqlite3.OperationalError as e:\n            <IND>e.args = e.args + (\"Check that DB path exists and is a valid DB file\",)\n            raise e\n        <DED>try:\n            <IND>self.db_name = self.get_db_name()\n        <DED>except TypeError as e:\n            <IND>e.args = e.args + (\n                'Check that DB path was created correctly and is not empty. '\n                'Check that a correct dataset_format is passed to the ODQAReader config',)\n            raise e\n        <DED>self.doc_ids = self.get_doc_ids()\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  }
]