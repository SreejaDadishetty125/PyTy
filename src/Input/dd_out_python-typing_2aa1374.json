[
  {
    "project": "python/typing",
    "commit": "2aa13741538068a252733d4f339ab6c600d9de26",
    "filename": "python2/test_typing.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/python-typing/python2/test_typing.py",
    "file_hunks_size": 20,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": true,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "python2/test_typing.py:851:19 Invalid type [31]: Expression `typing.Tuple[\"42\"]` is not a valid type.",
    "message": " Expression `typing.Tuple[\"42\"]` is not a valid type.",
    "rule_id": "Invalid type [31]",
    "warning_line_no": 851,
    "warning_line": "        def foo(a: Tuple['42']):",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": true,
        "has_suppression": false,
        "source_code": "            Generic['/T']\n\n    def test_delayed_syntax_error(self):\n\n        def foo(a: 'Node[T'):\n            pass\n\n        with self.assertRaises(SyntaxError):\n            get_type_hints(foo)\n\n    def test_type_error(self):\n\n        def foo(a: Tuple['42']):\n            pass\n\n        with self.assertRaises(TypeError):\n            get_type_hints(foo)\n\n    def test_name_error(self):\n\n        def foo(a: 'Noode[T]'):\n            pass\n\n        with self.assertRaises(NameError):\n            get_type_hints(foo, locals())\n\n    def test_no_type_check(self):\n\n        @no_type_check\n        def foo(a: 'whatevers') -> {}:\n            pass\n\n        th = get_type_hints(foo)\n        self.assertEqual(th, {})\n\n    def test_no_type_check_class(self):\n\n        @no_type_check\n        class C:\n            def foo(a: 'whatevers') -> {}:\n                pass\n\n        cth = get_type_hints(C.foo)\n        self.assertEqual(cth, {})\n        ith = get_type_hints(C().foo)\n        self.assertEqual(ith, {})\n\n    def test_meta_no_type_check(self):\n\n        @no_type_check_decorator\n        def magic_decorator(deco):\n            return deco\n\n        self.assertEqual(magic_decorator.__name__, 'magic_decorator')\n\n        @magic_decorator\n        def foo(a: 'whatevers') -> {}:\n            pass\n\n        @magic_decorator\n        class C:\n            def foo(a: 'whatevers') -> {}:\n                pass\n\n        self.assertEqual(foo.__name__, 'foo')\n        th = get_type_hints(foo)\n        self.assertEqual(th, {})\n        cth = get_type_hints(C.foo)\n        self.assertEqual(cth, {})\n        ith = get_type_hints(C().foo)\n        self.assertEqual(ith, {})\n\n    def test_default_globals(self):\n        code = (\"class C:\\n\"\n                \"    def foo(self, a: 'C') -> 'D': pass\\n\"\n                \"class D:\\n\"\n                \"    def bar(self, b: 'D') -> C: pass\\n\"\n                )\n        ns = {}\n        exec(code, ns)\n        hints = get_type_hints(ns['C'].foo)\n        assert hints == {'a': ns['C'], 'return': ns['D']}\n\n",
        "source_code_len": 2011,
        "target_code": "            Generic['/T']\n\n",
        "target_code_len": 27,
        "diff_format": "@@ -839,83 +723,2 @@\n             Generic['/T']\n-\n-    def test_delayed_syntax_error(self):\n-\n-        def foo(a: 'Node[T'):\n-            pass\n-\n-        with self.assertRaises(SyntaxError):\n-            get_type_hints(foo)\n-\n-    def test_type_error(self):\n-\n-        def foo(a: Tuple['42']):\n-            pass\n-\n-        with self.assertRaises(TypeError):\n-            get_type_hints(foo)\n-\n-    def test_name_error(self):\n-\n-        def foo(a: 'Noode[T]'):\n-            pass\n-\n-        with self.assertRaises(NameError):\n-            get_type_hints(foo, locals())\n-\n-    def test_no_type_check(self):\n-\n-        @no_type_check\n-        def foo(a: 'whatevers') -> {}:\n-            pass\n-\n-        th = get_type_hints(foo)\n-        self.assertEqual(th, {})\n-\n-    def test_no_type_check_class(self):\n-\n-        @no_type_check\n-        class C:\n-            def foo(a: 'whatevers') -> {}:\n-                pass\n-\n-        cth = get_type_hints(C.foo)\n-        self.assertEqual(cth, {})\n-        ith = get_type_hints(C().foo)\n-        self.assertEqual(ith, {})\n-\n-    def test_meta_no_type_check(self):\n-\n-        @no_type_check_decorator\n-        def magic_decorator(deco):\n-            return deco\n-\n-        self.assertEqual(magic_decorator.__name__, 'magic_decorator')\n-\n-        @magic_decorator\n-        def foo(a: 'whatevers') -> {}:\n-            pass\n-\n-        @magic_decorator\n-        class C:\n-            def foo(a: 'whatevers') -> {}:\n-                pass\n-\n-        self.assertEqual(foo.__name__, 'foo')\n-        th = get_type_hints(foo)\n-        self.assertEqual(th, {})\n-        cth = get_type_hints(C.foo)\n-        self.assertEqual(cth, {})\n-        ith = get_type_hints(C().foo)\n-        self.assertEqual(ith, {})\n-\n-    def test_default_globals(self):\n-        code = (\"class C:\\n\"\n-                \"    def foo(self, a: 'C') -> 'D': pass\\n\"\n-                \"class D:\\n\"\n-                \"    def bar(self, b: 'D') -> C: pass\\n\"\n-                )\n-        ns = {}\n-        exec(code, ns)\n-        hints = get_type_hints(ns['C'].foo)\n-        assert hints == {'a': ns['C'], 'return': ns['D']}\n \n",
        "source_code_with_indent": "            <IND>Generic['/T']\n\n    <DED><DED>def test_delayed_syntax_error(self):\n\n        <IND>def foo(a: 'Node[T'):\n            <IND>pass\n\n        <DED>with self.assertRaises(SyntaxError):\n            <IND>get_type_hints(foo)\n\n    <DED><DED>def test_type_error(self):\n\n        <IND>def foo(a: Tuple['42']):\n            <IND>pass\n\n        <DED>with self.assertRaises(TypeError):\n            <IND>get_type_hints(foo)\n\n    <DED><DED>def test_name_error(self):\n\n        <IND>def foo(a: 'Noode[T]'):\n            <IND>pass\n\n        <DED>with self.assertRaises(NameError):\n            <IND>get_type_hints(foo, locals())\n\n    <DED><DED>def test_no_type_check(self):\n\n        <IND>@no_type_check\n        def foo(a: 'whatevers') -> {}:\n            <IND>pass\n\n        <DED>th = get_type_hints(foo)\n        self.assertEqual(th, {})\n\n    <DED>def test_no_type_check_class(self):\n\n        <IND>@no_type_check\n        class C:\n            <IND>def foo(a: 'whatevers') -> {}:\n                <IND>pass\n\n        <DED><DED>cth = get_type_hints(C.foo)\n        self.assertEqual(cth, {})\n        ith = get_type_hints(C().foo)\n        self.assertEqual(ith, {})\n\n    <DED>def test_meta_no_type_check(self):\n\n        <IND>@no_type_check_decorator\n        def magic_decorator(deco):\n            <IND>return deco\n\n        <DED>self.assertEqual(magic_decorator.__name__, 'magic_decorator')\n\n        @magic_decorator\n        def foo(a: 'whatevers') -> {}:\n            <IND>pass\n\n        <DED>@magic_decorator\n        class C:\n            <IND>def foo(a: 'whatevers') -> {}:\n                <IND>pass\n\n        <DED><DED>self.assertEqual(foo.__name__, 'foo')\n        th = get_type_hints(foo)\n        self.assertEqual(th, {})\n        cth = get_type_hints(C.foo)\n        self.assertEqual(cth, {})\n        ith = get_type_hints(C().foo)\n        self.assertEqual(ith, {})\n\n    <DED>def test_default_globals(self):\n        <IND>code = (\"class C:\\n\"\n                \"    def foo(self, a: 'C') -> 'D': pass\\n\"\n                \"class D:\\n\"\n                \"    def bar(self, b: 'D') -> C: pass\\n\"\n                )\n        ns = {}\n        exec(code, ns)\n        hints = get_type_hints(ns['C'].foo)\n        assert hints == {'a': ns['C'], 'return': ns['D']}\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "            <IND>Generic['/T']\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "python/typing",
    "commit": "2aa13741538068a252733d4f339ab6c600d9de26",
    "filename": "python2/test_typing.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/python-typing/python2/test_typing.py",
    "file_hunks_size": 20,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": true,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "python2/test_typing.py:868:35 Invalid type [31]: Expression `{  }` is not a valid type.",
    "message": " Expression `{  }` is not a valid type.",
    "rule_id": "Invalid type [31]",
    "warning_line_no": 868,
    "warning_line": "        def foo(a: 'whatevers') -> {}:",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": true,
        "has_suppression": false,
        "source_code": "            Generic['/T']\n\n    def test_delayed_syntax_error(self):\n\n        def foo(a: 'Node[T'):\n            pass\n\n        with self.assertRaises(SyntaxError):\n            get_type_hints(foo)\n\n    def test_type_error(self):\n\n        def foo(a: Tuple['42']):\n            pass\n\n        with self.assertRaises(TypeError):\n            get_type_hints(foo)\n\n    def test_name_error(self):\n\n        def foo(a: 'Noode[T]'):\n            pass\n\n        with self.assertRaises(NameError):\n            get_type_hints(foo, locals())\n\n    def test_no_type_check(self):\n\n        @no_type_check\n        def foo(a: 'whatevers') -> {}:\n            pass\n\n        th = get_type_hints(foo)\n        self.assertEqual(th, {})\n\n    def test_no_type_check_class(self):\n\n        @no_type_check\n        class C:\n            def foo(a: 'whatevers') -> {}:\n                pass\n\n        cth = get_type_hints(C.foo)\n        self.assertEqual(cth, {})\n        ith = get_type_hints(C().foo)\n        self.assertEqual(ith, {})\n\n    def test_meta_no_type_check(self):\n\n        @no_type_check_decorator\n        def magic_decorator(deco):\n            return deco\n\n        self.assertEqual(magic_decorator.__name__, 'magic_decorator')\n\n        @magic_decorator\n        def foo(a: 'whatevers') -> {}:\n            pass\n\n        @magic_decorator\n        class C:\n            def foo(a: 'whatevers') -> {}:\n                pass\n\n        self.assertEqual(foo.__name__, 'foo')\n        th = get_type_hints(foo)\n        self.assertEqual(th, {})\n        cth = get_type_hints(C.foo)\n        self.assertEqual(cth, {})\n        ith = get_type_hints(C().foo)\n        self.assertEqual(ith, {})\n\n    def test_default_globals(self):\n        code = (\"class C:\\n\"\n                \"    def foo(self, a: 'C') -> 'D': pass\\n\"\n                \"class D:\\n\"\n                \"    def bar(self, b: 'D') -> C: pass\\n\"\n                )\n        ns = {}\n        exec(code, ns)\n        hints = get_type_hints(ns['C'].foo)\n        assert hints == {'a': ns['C'], 'return': ns['D']}\n\n",
        "source_code_len": 2011,
        "target_code": "            Generic['/T']\n\n",
        "target_code_len": 27,
        "diff_format": "@@ -839,83 +723,2 @@\n             Generic['/T']\n-\n-    def test_delayed_syntax_error(self):\n-\n-        def foo(a: 'Node[T'):\n-            pass\n-\n-        with self.assertRaises(SyntaxError):\n-            get_type_hints(foo)\n-\n-    def test_type_error(self):\n-\n-        def foo(a: Tuple['42']):\n-            pass\n-\n-        with self.assertRaises(TypeError):\n-            get_type_hints(foo)\n-\n-    def test_name_error(self):\n-\n-        def foo(a: 'Noode[T]'):\n-            pass\n-\n-        with self.assertRaises(NameError):\n-            get_type_hints(foo, locals())\n-\n-    def test_no_type_check(self):\n-\n-        @no_type_check\n-        def foo(a: 'whatevers') -> {}:\n-            pass\n-\n-        th = get_type_hints(foo)\n-        self.assertEqual(th, {})\n-\n-    def test_no_type_check_class(self):\n-\n-        @no_type_check\n-        class C:\n-            def foo(a: 'whatevers') -> {}:\n-                pass\n-\n-        cth = get_type_hints(C.foo)\n-        self.assertEqual(cth, {})\n-        ith = get_type_hints(C().foo)\n-        self.assertEqual(ith, {})\n-\n-    def test_meta_no_type_check(self):\n-\n-        @no_type_check_decorator\n-        def magic_decorator(deco):\n-            return deco\n-\n-        self.assertEqual(magic_decorator.__name__, 'magic_decorator')\n-\n-        @magic_decorator\n-        def foo(a: 'whatevers') -> {}:\n-            pass\n-\n-        @magic_decorator\n-        class C:\n-            def foo(a: 'whatevers') -> {}:\n-                pass\n-\n-        self.assertEqual(foo.__name__, 'foo')\n-        th = get_type_hints(foo)\n-        self.assertEqual(th, {})\n-        cth = get_type_hints(C.foo)\n-        self.assertEqual(cth, {})\n-        ith = get_type_hints(C().foo)\n-        self.assertEqual(ith, {})\n-\n-    def test_default_globals(self):\n-        code = (\"class C:\\n\"\n-                \"    def foo(self, a: 'C') -> 'D': pass\\n\"\n-                \"class D:\\n\"\n-                \"    def bar(self, b: 'D') -> C: pass\\n\"\n-                )\n-        ns = {}\n-        exec(code, ns)\n-        hints = get_type_hints(ns['C'].foo)\n-        assert hints == {'a': ns['C'], 'return': ns['D']}\n \n",
        "source_code_with_indent": "            <IND>Generic['/T']\n\n    <DED><DED>def test_delayed_syntax_error(self):\n\n        <IND>def foo(a: 'Node[T'):\n            <IND>pass\n\n        <DED>with self.assertRaises(SyntaxError):\n            <IND>get_type_hints(foo)\n\n    <DED><DED>def test_type_error(self):\n\n        <IND>def foo(a: Tuple['42']):\n            <IND>pass\n\n        <DED>with self.assertRaises(TypeError):\n            <IND>get_type_hints(foo)\n\n    <DED><DED>def test_name_error(self):\n\n        <IND>def foo(a: 'Noode[T]'):\n            <IND>pass\n\n        <DED>with self.assertRaises(NameError):\n            <IND>get_type_hints(foo, locals())\n\n    <DED><DED>def test_no_type_check(self):\n\n        <IND>@no_type_check\n        def foo(a: 'whatevers') -> {}:\n            <IND>pass\n\n        <DED>th = get_type_hints(foo)\n        self.assertEqual(th, {})\n\n    <DED>def test_no_type_check_class(self):\n\n        <IND>@no_type_check\n        class C:\n            <IND>def foo(a: 'whatevers') -> {}:\n                <IND>pass\n\n        <DED><DED>cth = get_type_hints(C.foo)\n        self.assertEqual(cth, {})\n        ith = get_type_hints(C().foo)\n        self.assertEqual(ith, {})\n\n    <DED>def test_meta_no_type_check(self):\n\n        <IND>@no_type_check_decorator\n        def magic_decorator(deco):\n            <IND>return deco\n\n        <DED>self.assertEqual(magic_decorator.__name__, 'magic_decorator')\n\n        @magic_decorator\n        def foo(a: 'whatevers') -> {}:\n            <IND>pass\n\n        <DED>@magic_decorator\n        class C:\n            <IND>def foo(a: 'whatevers') -> {}:\n                <IND>pass\n\n        <DED><DED>self.assertEqual(foo.__name__, 'foo')\n        th = get_type_hints(foo)\n        self.assertEqual(th, {})\n        cth = get_type_hints(C.foo)\n        self.assertEqual(cth, {})\n        ith = get_type_hints(C().foo)\n        self.assertEqual(ith, {})\n\n    <DED>def test_default_globals(self):\n        <IND>code = (\"class C:\\n\"\n                \"    def foo(self, a: 'C') -> 'D': pass\\n\"\n                \"class D:\\n\"\n                \"    def bar(self, b: 'D') -> C: pass\\n\"\n                )\n        ns = {}\n        exec(code, ns)\n        hints = get_type_hints(ns['C'].foo)\n        assert hints == {'a': ns['C'], 'return': ns['D']}\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "            <IND>Generic['/T']\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "python/typing",
    "commit": "2aa13741538068a252733d4f339ab6c600d9de26",
    "filename": "python2/test_typing.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/python-typing/python2/test_typing.py",
    "file_hunks_size": 20,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": true,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "python2/test_typing.py:895:35 Invalid type [31]: Expression `{  }` is not a valid type.",
    "message": " Expression `{  }` is not a valid type.",
    "rule_id": "Invalid type [31]",
    "warning_line_no": 895,
    "warning_line": "        def foo(a: 'whatevers') -> {}:",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": true,
        "has_suppression": false,
        "source_code": "            Generic['/T']\n\n    def test_delayed_syntax_error(self):\n\n        def foo(a: 'Node[T'):\n            pass\n\n        with self.assertRaises(SyntaxError):\n            get_type_hints(foo)\n\n    def test_type_error(self):\n\n        def foo(a: Tuple['42']):\n            pass\n\n        with self.assertRaises(TypeError):\n            get_type_hints(foo)\n\n    def test_name_error(self):\n\n        def foo(a: 'Noode[T]'):\n            pass\n\n        with self.assertRaises(NameError):\n            get_type_hints(foo, locals())\n\n    def test_no_type_check(self):\n\n        @no_type_check\n        def foo(a: 'whatevers') -> {}:\n            pass\n\n        th = get_type_hints(foo)\n        self.assertEqual(th, {})\n\n    def test_no_type_check_class(self):\n\n        @no_type_check\n        class C:\n            def foo(a: 'whatevers') -> {}:\n                pass\n\n        cth = get_type_hints(C.foo)\n        self.assertEqual(cth, {})\n        ith = get_type_hints(C().foo)\n        self.assertEqual(ith, {})\n\n    def test_meta_no_type_check(self):\n\n        @no_type_check_decorator\n        def magic_decorator(deco):\n            return deco\n\n        self.assertEqual(magic_decorator.__name__, 'magic_decorator')\n\n        @magic_decorator\n        def foo(a: 'whatevers') -> {}:\n            pass\n\n        @magic_decorator\n        class C:\n            def foo(a: 'whatevers') -> {}:\n                pass\n\n        self.assertEqual(foo.__name__, 'foo')\n        th = get_type_hints(foo)\n        self.assertEqual(th, {})\n        cth = get_type_hints(C.foo)\n        self.assertEqual(cth, {})\n        ith = get_type_hints(C().foo)\n        self.assertEqual(ith, {})\n\n    def test_default_globals(self):\n        code = (\"class C:\\n\"\n                \"    def foo(self, a: 'C') -> 'D': pass\\n\"\n                \"class D:\\n\"\n                \"    def bar(self, b: 'D') -> C: pass\\n\"\n                )\n        ns = {}\n        exec(code, ns)\n        hints = get_type_hints(ns['C'].foo)\n        assert hints == {'a': ns['C'], 'return': ns['D']}\n\n",
        "source_code_len": 2011,
        "target_code": "            Generic['/T']\n\n",
        "target_code_len": 27,
        "diff_format": "@@ -839,83 +723,2 @@\n             Generic['/T']\n-\n-    def test_delayed_syntax_error(self):\n-\n-        def foo(a: 'Node[T'):\n-            pass\n-\n-        with self.assertRaises(SyntaxError):\n-            get_type_hints(foo)\n-\n-    def test_type_error(self):\n-\n-        def foo(a: Tuple['42']):\n-            pass\n-\n-        with self.assertRaises(TypeError):\n-            get_type_hints(foo)\n-\n-    def test_name_error(self):\n-\n-        def foo(a: 'Noode[T]'):\n-            pass\n-\n-        with self.assertRaises(NameError):\n-            get_type_hints(foo, locals())\n-\n-    def test_no_type_check(self):\n-\n-        @no_type_check\n-        def foo(a: 'whatevers') -> {}:\n-            pass\n-\n-        th = get_type_hints(foo)\n-        self.assertEqual(th, {})\n-\n-    def test_no_type_check_class(self):\n-\n-        @no_type_check\n-        class C:\n-            def foo(a: 'whatevers') -> {}:\n-                pass\n-\n-        cth = get_type_hints(C.foo)\n-        self.assertEqual(cth, {})\n-        ith = get_type_hints(C().foo)\n-        self.assertEqual(ith, {})\n-\n-    def test_meta_no_type_check(self):\n-\n-        @no_type_check_decorator\n-        def magic_decorator(deco):\n-            return deco\n-\n-        self.assertEqual(magic_decorator.__name__, 'magic_decorator')\n-\n-        @magic_decorator\n-        def foo(a: 'whatevers') -> {}:\n-            pass\n-\n-        @magic_decorator\n-        class C:\n-            def foo(a: 'whatevers') -> {}:\n-                pass\n-\n-        self.assertEqual(foo.__name__, 'foo')\n-        th = get_type_hints(foo)\n-        self.assertEqual(th, {})\n-        cth = get_type_hints(C.foo)\n-        self.assertEqual(cth, {})\n-        ith = get_type_hints(C().foo)\n-        self.assertEqual(ith, {})\n-\n-    def test_default_globals(self):\n-        code = (\"class C:\\n\"\n-                \"    def foo(self, a: 'C') -> 'D': pass\\n\"\n-                \"class D:\\n\"\n-                \"    def bar(self, b: 'D') -> C: pass\\n\"\n-                )\n-        ns = {}\n-        exec(code, ns)\n-        hints = get_type_hints(ns['C'].foo)\n-        assert hints == {'a': ns['C'], 'return': ns['D']}\n \n",
        "source_code_with_indent": "            <IND>Generic['/T']\n\n    <DED><DED>def test_delayed_syntax_error(self):\n\n        <IND>def foo(a: 'Node[T'):\n            <IND>pass\n\n        <DED>with self.assertRaises(SyntaxError):\n            <IND>get_type_hints(foo)\n\n    <DED><DED>def test_type_error(self):\n\n        <IND>def foo(a: Tuple['42']):\n            <IND>pass\n\n        <DED>with self.assertRaises(TypeError):\n            <IND>get_type_hints(foo)\n\n    <DED><DED>def test_name_error(self):\n\n        <IND>def foo(a: 'Noode[T]'):\n            <IND>pass\n\n        <DED>with self.assertRaises(NameError):\n            <IND>get_type_hints(foo, locals())\n\n    <DED><DED>def test_no_type_check(self):\n\n        <IND>@no_type_check\n        def foo(a: 'whatevers') -> {}:\n            <IND>pass\n\n        <DED>th = get_type_hints(foo)\n        self.assertEqual(th, {})\n\n    <DED>def test_no_type_check_class(self):\n\n        <IND>@no_type_check\n        class C:\n            <IND>def foo(a: 'whatevers') -> {}:\n                <IND>pass\n\n        <DED><DED>cth = get_type_hints(C.foo)\n        self.assertEqual(cth, {})\n        ith = get_type_hints(C().foo)\n        self.assertEqual(ith, {})\n\n    <DED>def test_meta_no_type_check(self):\n\n        <IND>@no_type_check_decorator\n        def magic_decorator(deco):\n            <IND>return deco\n\n        <DED>self.assertEqual(magic_decorator.__name__, 'magic_decorator')\n\n        @magic_decorator\n        def foo(a: 'whatevers') -> {}:\n            <IND>pass\n\n        <DED>@magic_decorator\n        class C:\n            <IND>def foo(a: 'whatevers') -> {}:\n                <IND>pass\n\n        <DED><DED>self.assertEqual(foo.__name__, 'foo')\n        th = get_type_hints(foo)\n        self.assertEqual(th, {})\n        cth = get_type_hints(C.foo)\n        self.assertEqual(cth, {})\n        ith = get_type_hints(C().foo)\n        self.assertEqual(ith, {})\n\n    <DED>def test_default_globals(self):\n        <IND>code = (\"class C:\\n\"\n                \"    def foo(self, a: 'C') -> 'D': pass\\n\"\n                \"class D:\\n\"\n                \"    def bar(self, b: 'D') -> C: pass\\n\"\n                )\n        ns = {}\n        exec(code, ns)\n        hints = get_type_hints(ns['C'].foo)\n        assert hints == {'a': ns['C'], 'return': ns['D']}\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "            <IND>Generic['/T']\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "python/typing",
    "commit": "2aa13741538068a252733d4f339ab6c600d9de26",
    "filename": "python2/typing.py",
    "min_patch_found": false,
    "full_warning_msg": "python2/typing.py:1557:23 Incompatible variable type [9]: size is declared to have type `int` but is used as type `None`.",
    "exception": "Cannot have more than 64 hunks in a file",
    "dd_fail": true
  }
]