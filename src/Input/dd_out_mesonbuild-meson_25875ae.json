[
  {
    "project": "mesonbuild/meson",
    "commit": "25875ae0d37b68635a61298a24917c313fb761e1",
    "filename": "mesonbuild/dependencies/factory.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/mesonbuild-meson/mesonbuild/dependencies/factory.py",
    "file_hunks_size": 6,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "mesonbuild/dependencies/factory.py:80:58 Incompatible parameter type [6]: Expected `T.Union[None, functools.partial[CMakeDependency], functools.partial[ExternalDependency], functools.partial[ExtraFrameworkDependency], functools.partial[PkgConfigDependency]]` for 2nd positional only parameter to call `dict.__setitem__` but got `functools.partial[ConfigToolDependency]`.",
    "message": " Expected `T.Union[None, functools.partial[CMakeDependency], functools.partial[ExternalDependency], functools.partial[ExtraFrameworkDependency], functools.partial[PkgConfigDependency]]` for 2nd positional only parameter to call `dict.__setitem__` but got `functools.partial[ConfigToolDependency]`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 80,
    "warning_line": "            self.classes[DependencyMethods.CONFIG_TOOL] = functools.partial(configtool_class, name)"
  },
  {
    "project": "mesonbuild/meson",
    "commit": "25875ae0d37b68635a61298a24917c313fb761e1",
    "filename": "mesonbuild/dependencies/factory.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/mesonbuild-meson/mesonbuild/dependencies/factory.py",
    "file_hunks_size": 6,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "mesonbuild/dependencies/factory.py:104:8 Incompatible return type [7]: Expected `T.List[Variable[DependencyType (bound to Dependency)]]` but got `T.List[functools.partial[typing.Any]]`.",
    "message": " Expected `T.List[Variable[DependencyType (bound to Dependency)]]` but got `T.List[functools.partial[typing.Any]]`.",
    "rule_id": "Incompatible return type [7]",
    "warning_line_no": 104,
    "warning_line": "        return [functools.partial(self.classes[m], env, nwargs) for m in methods",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    from ..environment import Environment\n    from .base import DependencyType\n    from .configtool import ConfigToolDependency\n    FactoryType = T.TypeVar('FactoryType', bound=T.Callable[..., T.List[T.Callable[[], 'Dependency']]])\n\n",
        "source_code_len": 233,
        "target_code": "    from ..environment import Environment\n    from .configtool import ConfigToolDependency\n\n    TV_DepGenerators = T.List[T.Callable[[], ExternalDependency]]\n    TV_WrappedFactoryFunc = T.Callable[\n        [\n            'Environment',\n            MachineChoice,\n            T.Dict[str, T.Any],\n            T.List[DependencyMethods]\n        ],\n        TV_DepGenerators\n    ]\n\n    TV_FactoryFunc = T.Callable[\n        [\n            'Environment',\n            MachineChoice,\n            T.Dict[str, T.Any]\n        ],\n        TV_DepGenerators\n    ]\n\n",
        "target_code_len": 546,
        "diff_format": "@@ -26,5 +26,23 @@\n     from ..environment import Environment\n-    from .base import DependencyType\n     from .configtool import ConfigToolDependency\n-    FactoryType = T.TypeVar('FactoryType', bound=T.Callable[..., T.List[T.Callable[[], 'Dependency']]])\n+\n+    TV_DepGenerators = T.List[T.Callable[[], ExternalDependency]]\n+    TV_WrappedFactoryFunc = T.Callable[\n+        [\n+            'Environment',\n+            MachineChoice,\n+            T.Dict[str, T.Any],\n+            T.List[DependencyMethods]\n+        ],\n+        TV_DepGenerators\n+    ]\n+\n+    TV_FactoryFunc = T.Callable[\n+        [\n+            'Environment',\n+            MachineChoice,\n+            T.Dict[str, T.Any]\n+        ],\n+        TV_DepGenerators\n+    ]\n \n",
        "source_code_with_indent": "    <IND>from ..environment import Environment\n    from .base import DependencyType\n    from .configtool import ConfigToolDependency\n    FactoryType = T.TypeVar('FactoryType', bound=T.Callable[..., T.List[T.Callable[[], 'Dependency']]])\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    <IND>from ..environment import Environment\n    from .configtool import ConfigToolDependency\n\n    TV_DepGenerators = T.List[T.Callable[[], ExternalDependency]]\n    TV_WrappedFactoryFunc = T.Callable[\n        [\n            'Environment',\n            MachineChoice,\n            T.Dict[str, T.Any],\n            T.List[DependencyMethods]\n        ],\n        TV_DepGenerators\n    ]\n\n    TV_FactoryFunc = T.Callable[\n        [\n            'Environment',\n            MachineChoice,\n            T.Dict[str, T.Any]\n        ],\n        TV_DepGenerators\n    ]\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    def __call__(self, env: 'Environment', for_machine: MachineChoice,\n                 kwargs: T.Dict[str, T.Any]) -> T.List['DependencyType']:\n        \"\"\"Return a list of Dependencies with the arguments already attached.\"\"\"\n",
        "source_code_len": 226,
        "target_code": "    def __call__(self, env: 'Environment', for_machine: MachineChoice,\n                 kwargs: T.Dict[str, T.Any]) -> 'TV_DepGenerators':\n        \"\"\"Return a list of Dependencies with the arguments already attached.\"\"\"\n",
        "target_code_len": 220,
        "diff_format": "@@ -97,3 +118,3 @@\n     def __call__(self, env: 'Environment', for_machine: MachineChoice,\n-                 kwargs: T.Dict[str, T.Any]) -> T.List['DependencyType']:\n+                 kwargs: T.Dict[str, T.Any]) -> 'TV_DepGenerators':\n         \"\"\"Return a list of Dependencies with the arguments already attached.\"\"\"\n",
        "source_code_with_indent": "    <DED>def __call__(self, env: 'Environment', for_machine: MachineChoice,\n                 kwargs: T.Dict[str, T.Any]) -> T.List['DependencyType']:\n        <IND>\"\"\"Return a list of Dependencies with the arguments already attached.\"\"\"\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    <DED>def __call__(self, env: 'Environment', for_machine: MachineChoice,\n                 kwargs: T.Dict[str, T.Any]) -> 'TV_DepGenerators':\n        <IND>\"\"\"Return a list of Dependencies with the arguments already attached.\"\"\"\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\ndef factory_methods(methods: T.Set[DependencyMethods]) -> T.Callable[['FactoryType'], 'FactoryType']:\n    \"\"\"Decorator for handling methods for dependency factory functions.\n",
        "source_code_len": 175,
        "target_code": "\ndef factory_methods(methods: T.Set[DependencyMethods]) -> T.Callable[['TV_WrappedFactoryFunc'], 'TV_FactoryFunc']:\n    \"\"\"Decorator for handling methods for dependency factory functions.\n",
        "target_code_len": 188,
        "diff_format": "@@ -107,3 +128,3 @@\n \n-def factory_methods(methods: T.Set[DependencyMethods]) -> T.Callable[['FactoryType'], 'FactoryType']:\n+def factory_methods(methods: T.Set[DependencyMethods]) -> T.Callable[['TV_WrappedFactoryFunc'], 'TV_FactoryFunc']:\n     \"\"\"Decorator for handling methods for dependency factory functions.\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\n<DED><DED>def factory_methods(methods: T.Set[DependencyMethods]) -> T.Callable[['FactoryType'], 'FactoryType']:\n    <IND>",
        "target_code_with_indent": "\n<DED><DED>def factory_methods(methods: T.Set[DependencyMethods]) -> T.Callable[['TV_WrappedFactoryFunc'], 'TV_FactoryFunc']:\n    <IND>"
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n    def inner(func: 'FactoryType') -> 'FactoryType':\n\n        @functools.wraps(func)\n        def wrapped(env: 'Environment', for_machine: MachineChoice, kwargs: T.Dict[str, T.Any]) -> T.List[T.Callable[[], 'Dependency']]:\n            return func(env, for_machine, kwargs, process_method_kw(methods, kwargs))\n\n        return T.cast('FactoryType', wrapped)\n\n",
        "source_code_len": 357,
        "target_code": "\n    def inner(func: 'TV_WrappedFactoryFunc') -> 'TV_FactoryFunc':\n\n        @functools.wraps(func)\n        def wrapped(env: 'Environment', for_machine: MachineChoice, kwargs: T.Dict[str, T.Any]) -> 'TV_DepGenerators':\n            return func(env, for_machine, kwargs, process_method_kw(methods, kwargs))\n\n        return wrapped\n\n",
        "target_code_len": 329,
        "diff_format": "@@ -116,9 +137,9 @@\n \n-    def inner(func: 'FactoryType') -> 'FactoryType':\n+    def inner(func: 'TV_WrappedFactoryFunc') -> 'TV_FactoryFunc':\n \n         @functools.wraps(func)\n-        def wrapped(env: 'Environment', for_machine: MachineChoice, kwargs: T.Dict[str, T.Any]) -> T.List[T.Callable[[], 'Dependency']]:\n+        def wrapped(env: 'Environment', for_machine: MachineChoice, kwargs: T.Dict[str, T.Any]) -> 'TV_DepGenerators':\n             return func(env, for_machine, kwargs, process_method_kw(methods, kwargs))\n \n-        return T.cast('FactoryType', wrapped)\n+        return wrapped\n \n",
        "source_code_with_indent": "\n    def inner(func: 'FactoryType') -> 'FactoryType':\n\n        <IND>@functools.wraps(func)\n        def wrapped(env: 'Environment', for_machine: MachineChoice, kwargs: T.Dict[str, T.Any]) -> T.List[T.Callable[[], 'Dependency']]:\n            <IND>return func(env, for_machine, kwargs, process_method_kw(methods, kwargs))\n\n        <DED>return T.cast('FactoryType', wrapped)\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n    def inner(func: 'TV_WrappedFactoryFunc') -> 'TV_FactoryFunc':\n\n        <IND>@functools.wraps(func)\n        def wrapped(env: 'Environment', for_machine: MachineChoice, kwargs: T.Dict[str, T.Any]) -> 'TV_DepGenerators':\n            <IND>return func(env, for_machine, kwargs, process_method_kw(methods, kwargs))\n\n        <DED>return wrapped\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  }
]