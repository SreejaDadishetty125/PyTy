[
  {
    "project": "libvips/pyvips",
    "commit": "13de380a2e0dd61e1a8bf416c57106434912edb8",
    "filename": "pyvips/compile.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/libvips-pyvips/pyvips/compile.py",
    "file_hunks_size": 2,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "pyvips/compile.py:60:18 Unbound name [10]: Name `glib_lib` is used but not defined in the current scope.",
    "message": " Name `glib_lib` is used but not defined in the current scope.",
    "rule_id": "Unbound name [10]",
    "warning_line_no": 60,
    "warning_line": "_log_handler_id = glib_lib.g_log_set_handler(_to_bytes('VIPS'), ",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\nffi = FFI()\n\n# we need to define this before we import the decls: they need to know which\n# bits of decl to make\ndef at_least_libvips(x, y):\n    \"\"\"Is this at least libvips x.y?\"\"\"\n\n    major = vips_lib.vips_version(0)\n    minor = vips_lib.vips_version(1)\n\n    return major > x or (major == x and minor >= y)\n\n",
        "source_code_len": 311,
        "target_code": "\nffibuilder = FFI()\n\nffibuilder.set_source(\"_libvips\",\n    r\"\"\" \n        #include <vips/vips.h>\n    \"\"\", \n    **pkgconfig.parse('vips'))\n\nfeatures = {\n    'version': True,\n    # at_least_libvips(8, 6):\n    'blend_mode': pkgconfig.installed('vips', '>= 8.6')\n}\n\n",
        "target_code_len": 261,
        "diff_format": "@@ -12,13 +12,15 @@\n \n-ffi = FFI()\n+ffibuilder = FFI()\n \n-# we need to define this before we import the decls: they need to know which\n-# bits of decl to make\n-def at_least_libvips(x, y):\n-    \"\"\"Is this at least libvips x.y?\"\"\"\n+ffibuilder.set_source(\"_libvips\",\n+    r\"\"\" \n+        #include <vips/vips.h>\n+    \"\"\", \n+    **pkgconfig.parse('vips'))\n \n-    major = vips_lib.vips_version(0)\n-    minor = vips_lib.vips_version(1)\n-\n-    return major > x or (major == x and minor >= y)\n+features = {\n+    'version': True,\n+    # at_least_libvips(8, 6):\n+    'blend_mode': pkgconfig.installed('vips', '>= 8.6')\n+}\n \n",
        "source_code_with_indent": "\nffi = FFI()\n\n# we need to define this before we import the decls: they need to know which\n# bits of decl to make\ndef at_least_libvips(x, y):\n    <IND>\"\"\"Is this at least libvips x.y?\"\"\"\n\n    major = vips_lib.vips_version(0)\n    minor = vips_lib.vips_version(1)\n\n    return major > x or (major == x and minor >= y)\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\nffibuilder = FFI()\n\nffibuilder.set_source(\"_libvips\",\n    r\"\"\" \n        #include <vips/vips.h>\n    \"\"\", \n    **pkgconfig.parse('vips'))\n\nfeatures = {\n    'version': True,\n    # at_least_libvips(8, 6):\n    'blend_mode': pkgconfig.installed('vips', '>= 8.6')\n}\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\nfrom .error import *\n\n# redirect all vips warnings to logging\n\nclass GLogLevelFlags(object):\n    # log flags \n    FLAG_RECURSION          = 1 << 0\n    FLAG_FATAL              = 1 << 1\n\n    # GLib log levels \n    LEVEL_ERROR             = 1 << 2       # always fatal \n    LEVEL_CRITICAL          = 1 << 3\n    LEVEL_WARNING           = 1 << 4\n    LEVEL_MESSAGE           = 1 << 5\n    LEVEL_INFO              = 1 << 6\n    LEVEL_DEBUG             = 1 << 7\n\n    LEVEL_TO_LOGGER = {\n        LEVEL_DEBUG : 10,\n        LEVEL_INFO : 20,\n        LEVEL_MESSAGE : 20,\n        LEVEL_WARNING : 30,\n        LEVEL_ERROR : 40,\n        LEVEL_CRITICAL : 50,\n    }\n\ndef _log_handler(domain, level, message, user_data):\n    logger.log(GLogLevelFlags.LEVEL_TO_LOGGER[level], \n               '{0}: {1}'.format(_to_string(ffi.string(domain)), \n                                 _to_string(ffi.string(message))))\n\n# keep a ref to the cb to stop it being GCd\n_log_handler_cb = ffi.callback('GLogFunc', _log_handler)\n_log_handler_id = glib_lib.g_log_set_handler(_to_bytes('VIPS'), \n                           GLogLevelFlags.LEVEL_DEBUG | \n                           GLogLevelFlags.LEVEL_INFO | \n                           GLogLevelFlags.LEVEL_MESSAGE | \n                           GLogLevelFlags.LEVEL_WARNING | \n                           GLogLevelFlags.LEVEL_CRITICAL | \n                           GLogLevelFlags.LEVEL_ERROR | \n                           GLogLevelFlags.FLAG_FATAL | \n                           GLogLevelFlags.FLAG_RECURSION,\n                           _log_handler_cb, ffi.NULL)\n\n# ffi doesn't like us looking up methods during shutdown: make a note of the\n# remove handler here\n_remove_handler = glib_lib.g_log_remove_handler\n\n# we must remove the handler on exit or libvips may try to run the callback\n# during shutdown\ndef _remove_log_handler():\n    global _log_handler_id\n    global _remove_handler\n\n    if _log_handler_id:\n        _remove_handler(_to_bytes('VIPS'), _log_handler_id)\n        _log_handler_id = None\n\natexit.register(_remove_log_handler)\n\nfrom .enums import *\nfrom .base import *\nfrom .gobject import *\nfrom .gvalue import *\nfrom .vobject import *\nfrom .vinterpolate import *\nfrom .voperation import *\nfrom .vimage import *\n\n__all__ = [\n    'Error', 'Image', 'Operation', 'GValue', 'Interpolate', 'GObject',\n    'VipsObject', 'type_find', 'type_name', 'version', '__version__',\n    'at_least_libvips',\n    'cache_set_max', 'cache_set_max_mem', 'cache_set_max_files'\n]\n",
        "source_code_len": 2479,
        "target_code": "\nffibuilder.cdef(decls.cdefs(features))\n\nffibuilder.compile(verbose=True)\n",
        "target_code_len": 74,
        "diff_format": "@@ -26,76 +28,4 @@\n \n-from .error import *\n+ffibuilder.cdef(decls.cdefs(features))\n \n-# redirect all vips warnings to logging\n-\n-class GLogLevelFlags(object):\n-    # log flags \n-    FLAG_RECURSION          = 1 << 0\n-    FLAG_FATAL              = 1 << 1\n-\n-    # GLib log levels \n-    LEVEL_ERROR             = 1 << 2       # always fatal \n-    LEVEL_CRITICAL          = 1 << 3\n-    LEVEL_WARNING           = 1 << 4\n-    LEVEL_MESSAGE           = 1 << 5\n-    LEVEL_INFO              = 1 << 6\n-    LEVEL_DEBUG             = 1 << 7\n-\n-    LEVEL_TO_LOGGER = {\n-        LEVEL_DEBUG : 10,\n-        LEVEL_INFO : 20,\n-        LEVEL_MESSAGE : 20,\n-        LEVEL_WARNING : 30,\n-        LEVEL_ERROR : 40,\n-        LEVEL_CRITICAL : 50,\n-    }\n-\n-def _log_handler(domain, level, message, user_data):\n-    logger.log(GLogLevelFlags.LEVEL_TO_LOGGER[level], \n-               '{0}: {1}'.format(_to_string(ffi.string(domain)), \n-                                 _to_string(ffi.string(message))))\n-\n-# keep a ref to the cb to stop it being GCd\n-_log_handler_cb = ffi.callback('GLogFunc', _log_handler)\n-_log_handler_id = glib_lib.g_log_set_handler(_to_bytes('VIPS'), \n-                           GLogLevelFlags.LEVEL_DEBUG | \n-                           GLogLevelFlags.LEVEL_INFO | \n-                           GLogLevelFlags.LEVEL_MESSAGE | \n-                           GLogLevelFlags.LEVEL_WARNING | \n-                           GLogLevelFlags.LEVEL_CRITICAL | \n-                           GLogLevelFlags.LEVEL_ERROR | \n-                           GLogLevelFlags.FLAG_FATAL | \n-                           GLogLevelFlags.FLAG_RECURSION,\n-                           _log_handler_cb, ffi.NULL)\n-\n-# ffi doesn't like us looking up methods during shutdown: make a note of the\n-# remove handler here\n-_remove_handler = glib_lib.g_log_remove_handler\n-\n-# we must remove the handler on exit or libvips may try to run the callback\n-# during shutdown\n-def _remove_log_handler():\n-    global _log_handler_id\n-    global _remove_handler\n-\n-    if _log_handler_id:\n-        _remove_handler(_to_bytes('VIPS'), _log_handler_id)\n-        _log_handler_id = None\n-\n-atexit.register(_remove_log_handler)\n-\n-from .enums import *\n-from .base import *\n-from .gobject import *\n-from .gvalue import *\n-from .vobject import *\n-from .vinterpolate import *\n-from .voperation import *\n-from .vimage import *\n-\n-__all__ = [\n-    'Error', 'Image', 'Operation', 'GValue', 'Interpolate', 'GObject',\n-    'VipsObject', 'type_find', 'type_name', 'version', '__version__',\n-    'at_least_libvips',\n-    'cache_set_max', 'cache_set_max_mem', 'cache_set_max_files'\n-]\n+ffibuilder.compile(verbose=True)\n",
        "source_code_with_indent": "\nfrom .error import *\n\n# redirect all vips warnings to logging\n\nclass GLogLevelFlags(object):\n    # log flags \n    <IND>FLAG_RECURSION          = 1 << 0\n    FLAG_FATAL              = 1 << 1\n\n    # GLib log levels \n    LEVEL_ERROR             = 1 << 2       # always fatal \n    LEVEL_CRITICAL          = 1 << 3\n    LEVEL_WARNING           = 1 << 4\n    LEVEL_MESSAGE           = 1 << 5\n    LEVEL_INFO              = 1 << 6\n    LEVEL_DEBUG             = 1 << 7\n\n    LEVEL_TO_LOGGER = {\n        LEVEL_DEBUG : 10,\n        LEVEL_INFO : 20,\n        LEVEL_MESSAGE : 20,\n        LEVEL_WARNING : 30,\n        LEVEL_ERROR : 40,\n        LEVEL_CRITICAL : 50,\n    }\n\n<DED>def _log_handler(domain, level, message, user_data):\n    <IND>logger.log(GLogLevelFlags.LEVEL_TO_LOGGER[level], \n               '{0}: {1}'.format(_to_string(ffi.string(domain)), \n                                 _to_string(ffi.string(message))))\n\n# keep a ref to the cb to stop it being GCd\n<DED>_log_handler_cb = ffi.callback('GLogFunc', _log_handler)\n_log_handler_id = glib_lib.g_log_set_handler(_to_bytes('VIPS'), \n                           GLogLevelFlags.LEVEL_DEBUG | \n                           GLogLevelFlags.LEVEL_INFO | \n                           GLogLevelFlags.LEVEL_MESSAGE | \n                           GLogLevelFlags.LEVEL_WARNING | \n                           GLogLevelFlags.LEVEL_CRITICAL | \n                           GLogLevelFlags.LEVEL_ERROR | \n                           GLogLevelFlags.FLAG_FATAL | \n                           GLogLevelFlags.FLAG_RECURSION,\n                           _log_handler_cb, ffi.NULL)\n\n# ffi doesn't like us looking up methods during shutdown: make a note of the\n# remove handler here\n_remove_handler = glib_lib.g_log_remove_handler\n\n# we must remove the handler on exit or libvips may try to run the callback\n# during shutdown\ndef _remove_log_handler():\n    <IND>global _log_handler_id\n    global _remove_handler\n\n    if _log_handler_id:\n        <IND>_remove_handler(_to_bytes('VIPS'), _log_handler_id)\n        _log_handler_id = None\n\n<DED><DED>atexit.register(_remove_log_handler)\n\nfrom .enums import *\nfrom .base import *\nfrom .gobject import *\nfrom .gvalue import *\nfrom .vobject import *\nfrom .vinterpolate import *\nfrom .voperation import *\nfrom .vimage import *\n\n__all__ = [\n    'Error', 'Image', 'Operation', 'GValue', 'Interpolate', 'GObject',\n    'VipsObject', 'type_find', 'type_name', 'version', '__version__',\n    'at_least_libvips',\n    'cache_set_max', 'cache_set_max_mem', 'cache_set_max_files'\n]\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\nffibuilder.cdef(decls.cdefs(features))\n\nffibuilder.compile(verbose=True)\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "libvips/pyvips",
    "commit": "13de380a2e0dd61e1a8bf416c57106434912edb8",
    "filename": "pyvips/compile.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/libvips-pyvips/pyvips/compile.py",
    "file_hunks_size": 2,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "pyvips/compile.py:85:0 Unbound name [10]: Name `atexit` is used but not defined in the current scope.",
    "message": " Name `atexit` is used but not defined in the current scope.",
    "rule_id": "Unbound name [10]",
    "warning_line_no": 85,
    "warning_line": "atexit.register(_remove_log_handler)",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\nffi = FFI()\n\n# we need to define this before we import the decls: they need to know which\n# bits of decl to make\ndef at_least_libvips(x, y):\n    \"\"\"Is this at least libvips x.y?\"\"\"\n\n    major = vips_lib.vips_version(0)\n    minor = vips_lib.vips_version(1)\n\n    return major > x or (major == x and minor >= y)\n\n",
        "source_code_len": 311,
        "target_code": "\nffibuilder = FFI()\n\nffibuilder.set_source(\"_libvips\",\n    r\"\"\" \n        #include <vips/vips.h>\n    \"\"\", \n    **pkgconfig.parse('vips'))\n\nfeatures = {\n    'version': True,\n    # at_least_libvips(8, 6):\n    'blend_mode': pkgconfig.installed('vips', '>= 8.6')\n}\n\n",
        "target_code_len": 261,
        "diff_format": "@@ -12,13 +12,15 @@\n \n-ffi = FFI()\n+ffibuilder = FFI()\n \n-# we need to define this before we import the decls: they need to know which\n-# bits of decl to make\n-def at_least_libvips(x, y):\n-    \"\"\"Is this at least libvips x.y?\"\"\"\n+ffibuilder.set_source(\"_libvips\",\n+    r\"\"\" \n+        #include <vips/vips.h>\n+    \"\"\", \n+    **pkgconfig.parse('vips'))\n \n-    major = vips_lib.vips_version(0)\n-    minor = vips_lib.vips_version(1)\n-\n-    return major > x or (major == x and minor >= y)\n+features = {\n+    'version': True,\n+    # at_least_libvips(8, 6):\n+    'blend_mode': pkgconfig.installed('vips', '>= 8.6')\n+}\n \n",
        "source_code_with_indent": "\nffi = FFI()\n\n# we need to define this before we import the decls: they need to know which\n# bits of decl to make\ndef at_least_libvips(x, y):\n    <IND>\"\"\"Is this at least libvips x.y?\"\"\"\n\n    major = vips_lib.vips_version(0)\n    minor = vips_lib.vips_version(1)\n\n    return major > x or (major == x and minor >= y)\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\nffibuilder = FFI()\n\nffibuilder.set_source(\"_libvips\",\n    r\"\"\" \n        #include <vips/vips.h>\n    \"\"\", \n    **pkgconfig.parse('vips'))\n\nfeatures = {\n    'version': True,\n    # at_least_libvips(8, 6):\n    'blend_mode': pkgconfig.installed('vips', '>= 8.6')\n}\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\nfrom .error import *\n\n# redirect all vips warnings to logging\n\nclass GLogLevelFlags(object):\n    # log flags \n    FLAG_RECURSION          = 1 << 0\n    FLAG_FATAL              = 1 << 1\n\n    # GLib log levels \n    LEVEL_ERROR             = 1 << 2       # always fatal \n    LEVEL_CRITICAL          = 1 << 3\n    LEVEL_WARNING           = 1 << 4\n    LEVEL_MESSAGE           = 1 << 5\n    LEVEL_INFO              = 1 << 6\n    LEVEL_DEBUG             = 1 << 7\n\n    LEVEL_TO_LOGGER = {\n        LEVEL_DEBUG : 10,\n        LEVEL_INFO : 20,\n        LEVEL_MESSAGE : 20,\n        LEVEL_WARNING : 30,\n        LEVEL_ERROR : 40,\n        LEVEL_CRITICAL : 50,\n    }\n\ndef _log_handler(domain, level, message, user_data):\n    logger.log(GLogLevelFlags.LEVEL_TO_LOGGER[level], \n               '{0}: {1}'.format(_to_string(ffi.string(domain)), \n                                 _to_string(ffi.string(message))))\n\n# keep a ref to the cb to stop it being GCd\n_log_handler_cb = ffi.callback('GLogFunc', _log_handler)\n_log_handler_id = glib_lib.g_log_set_handler(_to_bytes('VIPS'), \n                           GLogLevelFlags.LEVEL_DEBUG | \n                           GLogLevelFlags.LEVEL_INFO | \n                           GLogLevelFlags.LEVEL_MESSAGE | \n                           GLogLevelFlags.LEVEL_WARNING | \n                           GLogLevelFlags.LEVEL_CRITICAL | \n                           GLogLevelFlags.LEVEL_ERROR | \n                           GLogLevelFlags.FLAG_FATAL | \n                           GLogLevelFlags.FLAG_RECURSION,\n                           _log_handler_cb, ffi.NULL)\n\n# ffi doesn't like us looking up methods during shutdown: make a note of the\n# remove handler here\n_remove_handler = glib_lib.g_log_remove_handler\n\n# we must remove the handler on exit or libvips may try to run the callback\n# during shutdown\ndef _remove_log_handler():\n    global _log_handler_id\n    global _remove_handler\n\n    if _log_handler_id:\n        _remove_handler(_to_bytes('VIPS'), _log_handler_id)\n        _log_handler_id = None\n\natexit.register(_remove_log_handler)\n\nfrom .enums import *\nfrom .base import *\nfrom .gobject import *\nfrom .gvalue import *\nfrom .vobject import *\nfrom .vinterpolate import *\nfrom .voperation import *\nfrom .vimage import *\n\n__all__ = [\n    'Error', 'Image', 'Operation', 'GValue', 'Interpolate', 'GObject',\n    'VipsObject', 'type_find', 'type_name', 'version', '__version__',\n    'at_least_libvips',\n    'cache_set_max', 'cache_set_max_mem', 'cache_set_max_files'\n]\n",
        "source_code_len": 2479,
        "target_code": "\nffibuilder.cdef(decls.cdefs(features))\n\nffibuilder.compile(verbose=True)\n",
        "target_code_len": 74,
        "diff_format": "@@ -26,76 +28,4 @@\n \n-from .error import *\n+ffibuilder.cdef(decls.cdefs(features))\n \n-# redirect all vips warnings to logging\n-\n-class GLogLevelFlags(object):\n-    # log flags \n-    FLAG_RECURSION          = 1 << 0\n-    FLAG_FATAL              = 1 << 1\n-\n-    # GLib log levels \n-    LEVEL_ERROR             = 1 << 2       # always fatal \n-    LEVEL_CRITICAL          = 1 << 3\n-    LEVEL_WARNING           = 1 << 4\n-    LEVEL_MESSAGE           = 1 << 5\n-    LEVEL_INFO              = 1 << 6\n-    LEVEL_DEBUG             = 1 << 7\n-\n-    LEVEL_TO_LOGGER = {\n-        LEVEL_DEBUG : 10,\n-        LEVEL_INFO : 20,\n-        LEVEL_MESSAGE : 20,\n-        LEVEL_WARNING : 30,\n-        LEVEL_ERROR : 40,\n-        LEVEL_CRITICAL : 50,\n-    }\n-\n-def _log_handler(domain, level, message, user_data):\n-    logger.log(GLogLevelFlags.LEVEL_TO_LOGGER[level], \n-               '{0}: {1}'.format(_to_string(ffi.string(domain)), \n-                                 _to_string(ffi.string(message))))\n-\n-# keep a ref to the cb to stop it being GCd\n-_log_handler_cb = ffi.callback('GLogFunc', _log_handler)\n-_log_handler_id = glib_lib.g_log_set_handler(_to_bytes('VIPS'), \n-                           GLogLevelFlags.LEVEL_DEBUG | \n-                           GLogLevelFlags.LEVEL_INFO | \n-                           GLogLevelFlags.LEVEL_MESSAGE | \n-                           GLogLevelFlags.LEVEL_WARNING | \n-                           GLogLevelFlags.LEVEL_CRITICAL | \n-                           GLogLevelFlags.LEVEL_ERROR | \n-                           GLogLevelFlags.FLAG_FATAL | \n-                           GLogLevelFlags.FLAG_RECURSION,\n-                           _log_handler_cb, ffi.NULL)\n-\n-# ffi doesn't like us looking up methods during shutdown: make a note of the\n-# remove handler here\n-_remove_handler = glib_lib.g_log_remove_handler\n-\n-# we must remove the handler on exit or libvips may try to run the callback\n-# during shutdown\n-def _remove_log_handler():\n-    global _log_handler_id\n-    global _remove_handler\n-\n-    if _log_handler_id:\n-        _remove_handler(_to_bytes('VIPS'), _log_handler_id)\n-        _log_handler_id = None\n-\n-atexit.register(_remove_log_handler)\n-\n-from .enums import *\n-from .base import *\n-from .gobject import *\n-from .gvalue import *\n-from .vobject import *\n-from .vinterpolate import *\n-from .voperation import *\n-from .vimage import *\n-\n-__all__ = [\n-    'Error', 'Image', 'Operation', 'GValue', 'Interpolate', 'GObject',\n-    'VipsObject', 'type_find', 'type_name', 'version', '__version__',\n-    'at_least_libvips',\n-    'cache_set_max', 'cache_set_max_mem', 'cache_set_max_files'\n-]\n+ffibuilder.compile(verbose=True)\n",
        "source_code_with_indent": "\nfrom .error import *\n\n# redirect all vips warnings to logging\n\nclass GLogLevelFlags(object):\n    # log flags \n    <IND>FLAG_RECURSION          = 1 << 0\n    FLAG_FATAL              = 1 << 1\n\n    # GLib log levels \n    LEVEL_ERROR             = 1 << 2       # always fatal \n    LEVEL_CRITICAL          = 1 << 3\n    LEVEL_WARNING           = 1 << 4\n    LEVEL_MESSAGE           = 1 << 5\n    LEVEL_INFO              = 1 << 6\n    LEVEL_DEBUG             = 1 << 7\n\n    LEVEL_TO_LOGGER = {\n        LEVEL_DEBUG : 10,\n        LEVEL_INFO : 20,\n        LEVEL_MESSAGE : 20,\n        LEVEL_WARNING : 30,\n        LEVEL_ERROR : 40,\n        LEVEL_CRITICAL : 50,\n    }\n\n<DED>def _log_handler(domain, level, message, user_data):\n    <IND>logger.log(GLogLevelFlags.LEVEL_TO_LOGGER[level], \n               '{0}: {1}'.format(_to_string(ffi.string(domain)), \n                                 _to_string(ffi.string(message))))\n\n# keep a ref to the cb to stop it being GCd\n<DED>_log_handler_cb = ffi.callback('GLogFunc', _log_handler)\n_log_handler_id = glib_lib.g_log_set_handler(_to_bytes('VIPS'), \n                           GLogLevelFlags.LEVEL_DEBUG | \n                           GLogLevelFlags.LEVEL_INFO | \n                           GLogLevelFlags.LEVEL_MESSAGE | \n                           GLogLevelFlags.LEVEL_WARNING | \n                           GLogLevelFlags.LEVEL_CRITICAL | \n                           GLogLevelFlags.LEVEL_ERROR | \n                           GLogLevelFlags.FLAG_FATAL | \n                           GLogLevelFlags.FLAG_RECURSION,\n                           _log_handler_cb, ffi.NULL)\n\n# ffi doesn't like us looking up methods during shutdown: make a note of the\n# remove handler here\n_remove_handler = glib_lib.g_log_remove_handler\n\n# we must remove the handler on exit or libvips may try to run the callback\n# during shutdown\ndef _remove_log_handler():\n    <IND>global _log_handler_id\n    global _remove_handler\n\n    if _log_handler_id:\n        <IND>_remove_handler(_to_bytes('VIPS'), _log_handler_id)\n        _log_handler_id = None\n\n<DED><DED>atexit.register(_remove_log_handler)\n\nfrom .enums import *\nfrom .base import *\nfrom .gobject import *\nfrom .gvalue import *\nfrom .vobject import *\nfrom .vinterpolate import *\nfrom .voperation import *\nfrom .vimage import *\n\n__all__ = [\n    'Error', 'Image', 'Operation', 'GValue', 'Interpolate', 'GObject',\n    'VipsObject', 'type_find', 'type_name', 'version', '__version__',\n    'at_least_libvips',\n    'cache_set_max', 'cache_set_max_mem', 'cache_set_max_files'\n]\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\nffibuilder.cdef(decls.cdefs(features))\n\nffibuilder.compile(verbose=True)\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  }
]