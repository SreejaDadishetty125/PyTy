[
  {
    "project": "quantumlib/Cirq",
    "commit": "d20d6c0aeab1908230f3ec58a556e6e9f49c1419",
    "filename": "cirq/ops/common_gates.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/quantumlib-Cirq/cirq/ops/common_gates.py",
    "file_hunks_size": 2,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": true,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "cirq/ops/common_gates.py:459:17 Incompatible variable type [9]: Unable to unpack `None`, expected a tuple.",
    "message": " Unable to unpack `None`, expected a tuple.",
    "rule_id": "Incompatible variable type [9]",
    "warning_line_no": 459,
    "warning_line": "                 qid_shape: Tuple[int, ...] = None):",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": true,
        "has_suppression": false,
        "source_code": "\n@value.value_equality\nclass IdentityGate(raw_types.Gate):\n    \"\"\"A Gate that perform no operation on qubits.\n\n    The unitary matrix of this gate is a diagonal matrix with all 1s on the\n    diagonal and all 0s off the diagonal in any basis.\n\n    `cirq.I` is the single qubit identity gate.\n    \"\"\"\n\n    def __init__(self,\n                 num_qubits: Optional[int] = None,\n                 qid_shape: Tuple[int, ...] = None):\n        \"\"\"\n        Args:\n            num_qubits:\n            qid_shape: Specifies the dimension of each qid the measurement\n                applies to.  The default is 2 for every qubit.\n\n        Raises:\n            ValueError: If the length of qid_shape doesn't equal num_qubits.\n        \"\"\"\n        if qid_shape is None:\n            if num_qubits is None:\n                raise ValueError(\n                    'Specify either the num_qubits or qid_shape argument.')\n            qid_shape = (2,) * num_qubits\n        elif num_qubits is None:\n            num_qubits = len(qid_shape)\n        self._qid_shape = qid_shape\n        if len(self._qid_shape) != num_qubits:\n            raise ValueError('len(qid_shape) != num_qubits')\n\n    def _qid_shape_(self) -> Tuple[int, ...]:\n        return self._qid_shape\n\n    def on_each(self, *targets: Union[raw_types.Qid, Iterable[Any]]\n               ) -> List[raw_types.Operation]:\n        \"\"\"Returns a list of operations that applies the single qubit identity\n        to each of the targets.\n\n        Args:\n            *targets: The qubits to apply this gate to.\n\n        Returns:\n            Operations applying this gate to the target qubits.\n\n        Raises:\n            ValueError if targets are not instances of Qid or List[Qid] or\n            the gate from which this is applied is not a single qubit identity\n            gate.\n        \"\"\"\n        if len(self._qid_shape) != 1:\n            raise ValueError(\n                'IdentityGate only supports on_each when it is a one qubit '\n                'gate.')\n        operations: List[raw_types.Operation] = []\n        for target in targets:\n            if isinstance(target, Iterable) and not isinstance(target, str):\n                operations.extend(self.on_each(*target))\n            elif isinstance(target, raw_types.Qid):\n                operations.append(self.on(target))\n            else:\n                raise ValueError(\n                    'Gate was called with type different than Qid. Type: {}'.\n                    format(type(target)))\n        return operations\n\n    def _unitary_(self):\n        return np.identity(np.prod(self._qid_shape, dtype=int))\n\n    def _apply_unitary_(self, args: 'protocols.ApplyUnitaryArgs'\n                       ) -> Optional[np.ndarray]:\n        return args.target_tensor\n\n    def _pauli_expansion_(self) -> value.LinearDict[str]:\n        if not all(d == 2 for d in self._qid_shape):\n            return NotImplemented\n        return value.LinearDict({'I' * self.num_qubits(): 1.0})\n\n    def _trace_distance_bound_(self) -> float:\n        return 0.0\n\n    def __repr__(self):\n        if self._qid_shape == (2,):\n            return 'cirq.I'\n        other = ''\n        if not all(d == 2 for d in self._qid_shape):\n            other = ', {!r}'.format(self._qid_shape)\n        return 'cirq.IdentityGate({!r}{})'.format(self.num_qubits(), other)\n\n    def __str__(self):\n        if (self.num_qubits() == 1):\n            return 'I'\n\n        return 'I({})'.format(self.num_qubits())\n\n    def _circuit_diagram_info_(self, args: 'protocols.CircuitDiagramInfoArgs'\n                              ) -> 'protocols.CircuitDiagramInfo':\n        return protocols.CircuitDiagramInfo(\n            wire_symbols=('I',) * self.num_qubits(), connected=True)\n\n    def _qasm_(self, args: 'protocols.QasmArgs',\n               qubits: Tuple[raw_types.Qid, ...]) -> Optional[str]:\n        if not all(d == 2 for d in self._qid_shape):\n            return NotImplemented\n        args.validate_version('2.0')\n        return ''.join([args.format('id {0};\\n', qubit) for qubit in qubits])\n\n    def _value_equality_values_(self):\n        return self._qid_shape\n\n    def _json_dict_(self):\n        other = {}\n        if not all(d == 2 for d in self._qid_shape):\n            other['qid_shape'] = self._qid_shape\n        return {\n            'cirq_type': self.__class__.__name__,\n            'num_qubits': len(self._qid_shape),\n            **other,\n        }\n\n    @classmethod\n    def _from_json_dict_(cls, num_qubits, qid_shape=None, **kwargs):\n        return cls(num_qubits=num_qubits,\n                   qid_shape=None if qid_shape is None else tuple(qid_shape))\n\n\ndef identity(*qubits: raw_types.Qid) -> raw_types.Operation:\n    \"\"\"Returns a single IdentityGate applied to all the given qubits.\n\n    Args:\n        *qubits: The qubits that the identity gate will apply to.\n\n    Returns:\n        An identity operation on the given qubits.\n\n    Raises:\n        ValueError if the qubits are not instances of Qid.\n    \"\"\"\n    if not all(isinstance(qubit, raw_types.Qid) for qubit in qubits):\n        raise ValueError('identity() was called with type different than Qid.')\n\n    qid_shape = protocols.qid_shape(qubits)\n    return IdentityGate(len(qubits), qid_shape).on(*qubits)\n\n\nclass HPowGate(eigen_gate.EigenGate, gate_features.SingleQubitGate):\n",
        "source_code_len": 5276,
        "target_code": "\nclass HPowGate(eigen_gate.EigenGate, gate_features.SingleQubitGate):\n",
        "target_code_len": 70,
        "diff_format": "@@ -446,149 +446,2 @@\n \n-@value.value_equality\n-class IdentityGate(raw_types.Gate):\n-    \"\"\"A Gate that perform no operation on qubits.\n-\n-    The unitary matrix of this gate is a diagonal matrix with all 1s on the\n-    diagonal and all 0s off the diagonal in any basis.\n-\n-    `cirq.I` is the single qubit identity gate.\n-    \"\"\"\n-\n-    def __init__(self,\n-                 num_qubits: Optional[int] = None,\n-                 qid_shape: Tuple[int, ...] = None):\n-        \"\"\"\n-        Args:\n-            num_qubits:\n-            qid_shape: Specifies the dimension of each qid the measurement\n-                applies to.  The default is 2 for every qubit.\n-\n-        Raises:\n-            ValueError: If the length of qid_shape doesn't equal num_qubits.\n-        \"\"\"\n-        if qid_shape is None:\n-            if num_qubits is None:\n-                raise ValueError(\n-                    'Specify either the num_qubits or qid_shape argument.')\n-            qid_shape = (2,) * num_qubits\n-        elif num_qubits is None:\n-            num_qubits = len(qid_shape)\n-        self._qid_shape = qid_shape\n-        if len(self._qid_shape) != num_qubits:\n-            raise ValueError('len(qid_shape) != num_qubits')\n-\n-    def _qid_shape_(self) -> Tuple[int, ...]:\n-        return self._qid_shape\n-\n-    def on_each(self, *targets: Union[raw_types.Qid, Iterable[Any]]\n-               ) -> List[raw_types.Operation]:\n-        \"\"\"Returns a list of operations that applies the single qubit identity\n-        to each of the targets.\n-\n-        Args:\n-            *targets: The qubits to apply this gate to.\n-\n-        Returns:\n-            Operations applying this gate to the target qubits.\n-\n-        Raises:\n-            ValueError if targets are not instances of Qid or List[Qid] or\n-            the gate from which this is applied is not a single qubit identity\n-            gate.\n-        \"\"\"\n-        if len(self._qid_shape) != 1:\n-            raise ValueError(\n-                'IdentityGate only supports on_each when it is a one qubit '\n-                'gate.')\n-        operations: List[raw_types.Operation] = []\n-        for target in targets:\n-            if isinstance(target, Iterable) and not isinstance(target, str):\n-                operations.extend(self.on_each(*target))\n-            elif isinstance(target, raw_types.Qid):\n-                operations.append(self.on(target))\n-            else:\n-                raise ValueError(\n-                    'Gate was called with type different than Qid. Type: {}'.\n-                    format(type(target)))\n-        return operations\n-\n-    def _unitary_(self):\n-        return np.identity(np.prod(self._qid_shape, dtype=int))\n-\n-    def _apply_unitary_(self, args: 'protocols.ApplyUnitaryArgs'\n-                       ) -> Optional[np.ndarray]:\n-        return args.target_tensor\n-\n-    def _pauli_expansion_(self) -> value.LinearDict[str]:\n-        if not all(d == 2 for d in self._qid_shape):\n-            return NotImplemented\n-        return value.LinearDict({'I' * self.num_qubits(): 1.0})\n-\n-    def _trace_distance_bound_(self) -> float:\n-        return 0.0\n-\n-    def __repr__(self):\n-        if self._qid_shape == (2,):\n-            return 'cirq.I'\n-        other = ''\n-        if not all(d == 2 for d in self._qid_shape):\n-            other = ', {!r}'.format(self._qid_shape)\n-        return 'cirq.IdentityGate({!r}{})'.format(self.num_qubits(), other)\n-\n-    def __str__(self):\n-        if (self.num_qubits() == 1):\n-            return 'I'\n-\n-        return 'I({})'.format(self.num_qubits())\n-\n-    def _circuit_diagram_info_(self, args: 'protocols.CircuitDiagramInfoArgs'\n-                              ) -> 'protocols.CircuitDiagramInfo':\n-        return protocols.CircuitDiagramInfo(\n-            wire_symbols=('I',) * self.num_qubits(), connected=True)\n-\n-    def _qasm_(self, args: 'protocols.QasmArgs',\n-               qubits: Tuple[raw_types.Qid, ...]) -> Optional[str]:\n-        if not all(d == 2 for d in self._qid_shape):\n-            return NotImplemented\n-        args.validate_version('2.0')\n-        return ''.join([args.format('id {0};\\n', qubit) for qubit in qubits])\n-\n-    def _value_equality_values_(self):\n-        return self._qid_shape\n-\n-    def _json_dict_(self):\n-        other = {}\n-        if not all(d == 2 for d in self._qid_shape):\n-            other['qid_shape'] = self._qid_shape\n-        return {\n-            'cirq_type': self.__class__.__name__,\n-            'num_qubits': len(self._qid_shape),\n-            **other,\n-        }\n-\n-    @classmethod\n-    def _from_json_dict_(cls, num_qubits, qid_shape=None, **kwargs):\n-        return cls(num_qubits=num_qubits,\n-                   qid_shape=None if qid_shape is None else tuple(qid_shape))\n-\n-\n-def identity(*qubits: raw_types.Qid) -> raw_types.Operation:\n-    \"\"\"Returns a single IdentityGate applied to all the given qubits.\n-\n-    Args:\n-        *qubits: The qubits that the identity gate will apply to.\n-\n-    Returns:\n-        An identity operation on the given qubits.\n-\n-    Raises:\n-        ValueError if the qubits are not instances of Qid.\n-    \"\"\"\n-    if not all(isinstance(qubit, raw_types.Qid) for qubit in qubits):\n-        raise ValueError('identity() was called with type different than Qid.')\n-\n-    qid_shape = protocols.qid_shape(qubits)\n-    return IdentityGate(len(qubits), qid_shape).on(*qubits)\n-\n-\n class HPowGate(eigen_gate.EigenGate, gate_features.SingleQubitGate):\n",
        "source_code_with_indent": "\n<DED><DED>@value.value_equality\nclass IdentityGate(raw_types.Gate):\n    <IND>\"\"\"A Gate that perform no operation on qubits.\n\n    The unitary matrix of this gate is a diagonal matrix with all 1s on the\n    diagonal and all 0s off the diagonal in any basis.\n\n    `cirq.I` is the single qubit identity gate.\n    \"\"\"\n\n    def __init__(self,\n                 num_qubits: Optional[int] = None,\n                 qid_shape: Tuple[int, ...] = None):\n        <IND>\"\"\"\n        Args:\n            num_qubits:\n            qid_shape: Specifies the dimension of each qid the measurement\n                applies to.  The default is 2 for every qubit.\n\n        Raises:\n            ValueError: If the length of qid_shape doesn't equal num_qubits.\n        \"\"\"\n        if qid_shape is None:\n            <IND>if num_qubits is None:\n                <IND>raise ValueError(\n                    'Specify either the num_qubits or qid_shape argument.')\n            <DED>qid_shape = (2,) * num_qubits\n        <DED>elif num_qubits is None:\n            <IND>num_qubits = len(qid_shape)\n        <DED>self._qid_shape = qid_shape\n        if len(self._qid_shape) != num_qubits:\n            <IND>raise ValueError('len(qid_shape) != num_qubits')\n\n    <DED><DED>def _qid_shape_(self) -> Tuple[int, ...]:\n        <IND>return self._qid_shape\n\n    <DED>def on_each(self, *targets: Union[raw_types.Qid, Iterable[Any]]\n               ) -> List[raw_types.Operation]:\n        <IND>\"\"\"Returns a list of operations that applies the single qubit identity\n        to each of the targets.\n\n        Args:\n            *targets: The qubits to apply this gate to.\n\n        Returns:\n            Operations applying this gate to the target qubits.\n\n        Raises:\n            ValueError if targets are not instances of Qid or List[Qid] or\n            the gate from which this is applied is not a single qubit identity\n            gate.\n        \"\"\"\n        if len(self._qid_shape) != 1:\n            <IND>raise ValueError(\n                'IdentityGate only supports on_each when it is a one qubit '\n                'gate.')\n        <DED>operations: List[raw_types.Operation] = []\n        for target in targets:\n            <IND>if isinstance(target, Iterable) and not isinstance(target, str):\n                <IND>operations.extend(self.on_each(*target))\n            <DED>elif isinstance(target, raw_types.Qid):\n                <IND>operations.append(self.on(target))\n            <DED>else:\n                <IND>raise ValueError(\n                    'Gate was called with type different than Qid. Type: {}'.\n                    format(type(target)))\n        <DED><DED>return operations\n\n    <DED>def _unitary_(self):\n        <IND>return np.identity(np.prod(self._qid_shape, dtype=int))\n\n    <DED>def _apply_unitary_(self, args: 'protocols.ApplyUnitaryArgs'\n                       ) -> Optional[np.ndarray]:\n        <IND>return args.target_tensor\n\n    <DED>def _pauli_expansion_(self) -> value.LinearDict[str]:\n        <IND>if not all(d == 2 for d in self._qid_shape):\n            <IND>return NotImplemented\n        <DED>return value.LinearDict({'I' * self.num_qubits(): 1.0})\n\n    <DED>def _trace_distance_bound_(self) -> float:\n        <IND>return 0.0\n\n    <DED>def __repr__(self):\n        <IND>if self._qid_shape == (2,):\n            <IND>return 'cirq.I'\n        <DED>other = ''\n        if not all(d == 2 for d in self._qid_shape):\n            <IND>other = ', {!r}'.format(self._qid_shape)\n        <DED>return 'cirq.IdentityGate({!r}{})'.format(self.num_qubits(), other)\n\n    <DED>def __str__(self):\n        <IND>if (self.num_qubits() == 1):\n            <IND>return 'I'\n\n        <DED>return 'I({})'.format(self.num_qubits())\n\n    <DED>def _circuit_diagram_info_(self, args: 'protocols.CircuitDiagramInfoArgs'\n                              ) -> 'protocols.CircuitDiagramInfo':\n        <IND>return protocols.CircuitDiagramInfo(\n            wire_symbols=('I',) * self.num_qubits(), connected=True)\n\n    <DED>def _qasm_(self, args: 'protocols.QasmArgs',\n               qubits: Tuple[raw_types.Qid, ...]) -> Optional[str]:\n        <IND>if not all(d == 2 for d in self._qid_shape):\n            <IND>return NotImplemented\n        <DED>args.validate_version('2.0')\n        return ''.join([args.format('id {0};\\n', qubit) for qubit in qubits])\n\n    <DED>def _value_equality_values_(self):\n        <IND>return self._qid_shape\n\n    <DED>def _json_dict_(self):\n        <IND>other = {}\n        if not all(d == 2 for d in self._qid_shape):\n            <IND>other['qid_shape'] = self._qid_shape\n        <DED>return {\n            'cirq_type': self.__class__.__name__,\n            'num_qubits': len(self._qid_shape),\n            **other,\n        }\n\n    <DED>@classmethod\n    def _from_json_dict_(cls, num_qubits, qid_shape=None, **kwargs):\n        <IND>return cls(num_qubits=num_qubits,\n                   qid_shape=None if qid_shape is None else tuple(qid_shape))\n\n\n<DED><DED>def identity(*qubits: raw_types.Qid) -> raw_types.Operation:\n    <IND>\"\"\"Returns a single IdentityGate applied to all the given qubits.\n\n    Args:\n        *qubits: The qubits that the identity gate will apply to.\n\n    Returns:\n        An identity operation on the given qubits.\n\n    Raises:\n        ValueError if the qubits are not instances of Qid.\n    \"\"\"\n    if not all(isinstance(qubit, raw_types.Qid) for qubit in qubits):\n        <IND>raise ValueError('identity() was called with type different than Qid.')\n\n    <DED>qid_shape = protocols.qid_shape(qubits)\n    return IdentityGate(len(qubits), qid_shape).on(*qubits)\n\n\n<DED>class HPowGate(eigen_gate.EigenGate, gate_features.SingleQubitGate):\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n<DED><DED>class HPowGate(eigen_gate.EigenGate, gate_features.SingleQubitGate):\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": true,
        "has_suppression": false,
        "source_code": "\n# The one qubit identity gate.\n#\n# Matrix:\n#\n#     [[1, 0],\n#      [0, 1]]\nI = IdentityGate(num_qubits=1)\n\n\n# The Hadamard gate.\n",
        "source_code_len": 130,
        "target_code": "\n# The Hadamard gate.\n",
        "target_code_len": 22,
        "diff_format": "@@ -937,11 +790,2 @@\n \n-# The one qubit identity gate.\n-#\n-# Matrix:\n-#\n-#     [[1, 0],\n-#      [0, 1]]\n-I = IdentityGate(num_qubits=1)\n-\n-\n # The Hadamard gate.\n",
        "source_code_with_indent": "\n# The one qubit identity gate.\n#\n# Matrix:\n#\n#     [[1, 0],\n#      [0, 1]]\n<DED>I = IdentityGate(num_qubits=1)\n\n\n# The Hadamard gate.\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n# The Hadamard gate.\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  }
]