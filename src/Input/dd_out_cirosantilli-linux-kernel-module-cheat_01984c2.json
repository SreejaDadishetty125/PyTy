[
  {
    "project": "cirosantilli/linux-kernel-module-cheat",
    "commit": "01984c2201edf9411eca1e1a69953425083dd6f4",
    "filename": "thread_pool.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/cirosantilli-linux-kernel-module-cheat/thread_pool.py",
    "file_hunks_size": 18,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "thread_pool.py:251:8 Incompatible variable type [9]: thread_id_arg is declared to have type `str` but is used as type `None`.",
    "message": " thread_id_arg is declared to have type `str` but is used as type `None`.",
    "rule_id": "Incompatible variable type [9]",
    "warning_line_no": 251,
    "warning_line": "        thread_id_arg = None",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "import time\n\n",
        "source_code_len": 13,
        "target_code": "import time\nimport traceback\n\nclass ThreadPoolExitException(Exception):\n    '''\n    An object of this class may be raised by output_handler_function to\n    request early termination.\n\n    It is also raised by submit() if submit_raise_exit=True.\n    '''\n    pass\n\n",
        "target_code_len": 263,
        "diff_format": "@@ -8,2 +13,12 @@\n import time\n+import traceback\n+\n+class ThreadPoolExitException(Exception):\n+    '''\n+    An object of this class may be raised by output_handler_function to\n+    request early termination.\n+\n+    It is also raised by submit() if submit_raise_exit=True.\n+    '''\n+    pass\n \n",
        "source_code_with_indent": "import time\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "import time\nimport traceback\n\nclass ThreadPoolExitException(Exception):\n    <IND>'''\n    An object of this class may be raised by output_handler_function to\n    request early termination.\n\n    It is also raised by submit() if submit_raise_exit=True.\n    '''\n    pass\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "        thread_id_arg: Union[str,None] = None,\n    ):\n",
        "source_code_len": 54,
        "target_code": "        thread_id_arg: Union[str,None] = None,\n        submit_raise_exit: bool = False,\n        submit_skip_exit: bool = False,\n    ):\n",
        "target_code_len": 135,
        "diff_format": "@@ -44,2 +112,4 @@\n         thread_id_arg: Union[str,None] = None,\n+        submit_raise_exit: bool = False,\n+        submit_skip_exit: bool = False,\n     ):\n",
        "source_code_with_indent": "        thread_id_arg: Union[str,None] = None,\n    ):\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "        thread_id_arg: Union[str,None] = None,\n        submit_raise_exit: bool = False,\n        submit_skip_exit: bool = False,\n    ):\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "        self.thread_id_arg = thread_id_arg\n        self.nthreads = nthreads\n        self.error_output = None\n        self.error_output_lock = threading.Lock()\n        self.in_queue = queue.Queue(maxsize=nthreads)\n",
        "source_code_len": 213,
        "target_code": "        self.thread_id_arg = thread_id_arg\n        self.submit_raise_exit = submit_raise_exit\n        self.submit_skip_exit = submit_skip_exit\n        self.nthreads = nthreads\n        self.handle_output_result = None\n        self.handle_output_result_lock = threading.Lock()\n        self.in_queue = queue.Queue(maxsize=nthreads)\n",
        "target_code_len": 329,
        "diff_format": "@@ -77,5 +178,7 @@\n         self.thread_id_arg = thread_id_arg\n+        self.submit_raise_exit = submit_raise_exit\n+        self.submit_skip_exit = submit_skip_exit\n         self.nthreads = nthreads\n-        self.error_output = None\n-        self.error_output_lock = threading.Lock()\n+        self.handle_output_result = None\n+        self.handle_output_result_lock = threading.Lock()\n         self.in_queue = queue.Queue(maxsize=nthreads)\n",
        "source_code_with_indent": "        <DED>self.thread_id_arg = thread_id_arg\n        self.nthreads = nthreads\n        self.error_output = None\n        self.error_output_lock = threading.Lock()\n        self.in_queue = queue.Queue(maxsize=nthreads)\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "        <DED>self.thread_id_arg = thread_id_arg\n        self.submit_raise_exit = submit_raise_exit\n        self.submit_skip_exit = submit_skip_exit\n        self.nthreads = nthreads\n        self.handle_output_result = None\n        self.handle_output_result_lock = threading.Lock()\n        self.in_queue = queue.Queue(maxsize=nthreads)\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n    def __exit__(self, type, value, traceback):\n        self.join()\n\n    def get_error(self):\n        return self.error_output\n\n    def submit(self, work):\n        '''\n        Submit work. Block if there is already enough work scheduled (~nthreads).\n\n        :return: if an error occurred in some previously executed thread, the error.\n                 Otherwise, None. This allows the caller to stop submitting further\n                 work if desired.\n        '''\n        self.in_queue.put(work)\n        return self.error_output\n\n",
        "source_code_len": 533,
        "target_code": "\n    def __exit__(self, exception_type, exception_value, exception_traceback):\n        self.join()\n        return exception_type is ThreadPoolExitException\n\n    def _func_runner(self, thread_id):\n        while True:\n            work_function_input = self.in_queue.get(block=True)\n            if work_function_input is None:\n                break\n            if self.thread_id_arg is not None:\n                work_function_input[self.thread_id_arg] = thread_id\n            try:\n                work_function_exception = None\n                work_function_return = self.work_function(**work_function_input)\n            except Exception as e:\n                work_function_exception = e\n                work_function_return = None\n            handle_output_exception = None\n            try:\n                handle_output_return = self.handle_output(\n                    work_function_input,\n                    work_function_return,\n                    work_function_exception\n                )\n            except Exception as e:\n                handle_output_exception = e\n            handle_output_result = None\n            if handle_output_exception is not None:\n                handle_output_result = handle_output_exception\n            elif handle_output_return is not None:\n                handle_output_result = handle_output_return\n            if handle_output_result is not None and self.handle_output_result is None:\n                with self.handle_output_result_lock:\n                    self.handle_output_result = (\n                        work_function_input,\n                        work_function_return,\n                        handle_output_result\n                    )\n            self.in_queue.task_done()\n\n    @staticmethod\n    def exception_traceback_string(exception):\n        '''\n        Helper to get the traceback from an exception object.\n        This is usually what you want to print if an error happens in a thread:\n        https://stackoverflow.com/questions/3702675/how-to-print-the-full-traceback-without-halting-the-program/56199295#56199295\n        '''\n        return ''.join(traceback.format_exception(\n            None, exception, exception.__traceback__)\n        )\n\n    def get_handle_output_result(self):\n        '''\n        :return: if a handle_output call has raised previously, return a tuple:\n\n            ....\n            (work_function_input, work_function_return, exception_raised)\n            ....\n\n            corresponding to the first such raise.\n\n            Otherwise, if a handle_output returned non-None, a tuple:\n\n            (work_function_input, work_function_return, handle_output_return)\n\n            Otherwise, None.\n        '''\n        return self.handle_output_result\n\n",
        "target_code_len": 2729,
        "diff_format": "@@ -103,18 +204,70 @@\n \n-    def __exit__(self, type, value, traceback):\n+    def __exit__(self, exception_type, exception_value, exception_traceback):\n         self.join()\n-\n-    def get_error(self):\n-        return self.error_output\n-\n-    def submit(self, work):\n-        '''\n-        Submit work. Block if there is already enough work scheduled (~nthreads).\n-\n-        :return: if an error occurred in some previously executed thread, the error.\n-                 Otherwise, None. This allows the caller to stop submitting further\n-                 work if desired.\n-        '''\n-        self.in_queue.put(work)\n-        return self.error_output\n+        return exception_type is ThreadPoolExitException\n+\n+    def _func_runner(self, thread_id):\n+        while True:\n+            work_function_input = self.in_queue.get(block=True)\n+            if work_function_input is None:\n+                break\n+            if self.thread_id_arg is not None:\n+                work_function_input[self.thread_id_arg] = thread_id\n+            try:\n+                work_function_exception = None\n+                work_function_return = self.work_function(**work_function_input)\n+            except Exception as e:\n+                work_function_exception = e\n+                work_function_return = None\n+            handle_output_exception = None\n+            try:\n+                handle_output_return = self.handle_output(\n+                    work_function_input,\n+                    work_function_return,\n+                    work_function_exception\n+                )\n+            except Exception as e:\n+                handle_output_exception = e\n+            handle_output_result = None\n+            if handle_output_exception is not None:\n+                handle_output_result = handle_output_exception\n+            elif handle_output_return is not None:\n+                handle_output_result = handle_output_return\n+            if handle_output_result is not None and self.handle_output_result is None:\n+                with self.handle_output_result_lock:\n+                    self.handle_output_result = (\n+                        work_function_input,\n+                        work_function_return,\n+                        handle_output_result\n+                    )\n+            self.in_queue.task_done()\n+\n+    @staticmethod\n+    def exception_traceback_string(exception):\n+        '''\n+        Helper to get the traceback from an exception object.\n+        This is usually what you want to print if an error happens in a thread:\n+        https://stackoverflow.com/questions/3702675/how-to-print-the-full-traceback-without-halting-the-program/56199295#56199295\n+        '''\n+        return ''.join(traceback.format_exception(\n+            None, exception, exception.__traceback__)\n+        )\n+\n+    def get_handle_output_result(self):\n+        '''\n+        :return: if a handle_output call has raised previously, return a tuple:\n+\n+            ....\n+            (work_function_input, work_function_return, exception_raised)\n+            ....\n+\n+            corresponding to the first such raise.\n+\n+            Otherwise, if a handle_output returned non-None, a tuple:\n+\n+            (work_function_input, work_function_return, handle_output_return)\n+\n+            Otherwise, None.\n+        '''\n+        return self.handle_output_result\n \n",
        "source_code_with_indent": "\n    <DED>def __exit__(self, type, value, traceback):\n        <IND>self.join()\n\n    <DED>def get_error(self):\n        <IND>return self.error_output\n\n    <DED>def submit(self, work):\n        <IND>'''\n        Submit work. Block if there is already enough work scheduled (~nthreads).\n\n        :return: if an error occurred in some previously executed thread, the error.\n                 Otherwise, None. This allows the caller to stop submitting further\n                 work if desired.\n        '''\n        self.in_queue.put(work)\n        return self.error_output\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n    <DED>def __exit__(self, exception_type, exception_value, exception_traceback):\n        <IND>self.join()\n        return exception_type is ThreadPoolExitException\n\n    <DED>def _func_runner(self, thread_id):\n        <IND>while True:\n            <IND>work_function_input = self.in_queue.get(block=True)\n            if work_function_input is None:\n                <IND>break\n            <DED>if self.thread_id_arg is not None:\n                <IND>work_function_input[self.thread_id_arg] = thread_id\n            <DED>try:\n                <IND>work_function_exception = None\n                work_function_return = self.work_function(**work_function_input)\n            <DED>except Exception as e:\n                <IND>work_function_exception = e\n                work_function_return = None\n            <DED>handle_output_exception = None\n            try:\n                <IND>handle_output_return = self.handle_output(\n                    work_function_input,\n                    work_function_return,\n                    work_function_exception\n                )\n            <DED>except Exception as e:\n                <IND>handle_output_exception = e\n            <DED>handle_output_result = None\n            if handle_output_exception is not None:\n                <IND>handle_output_result = handle_output_exception\n            <DED>elif handle_output_return is not None:\n                <IND>handle_output_result = handle_output_return\n            <DED>if handle_output_result is not None and self.handle_output_result is None:\n                <IND>with self.handle_output_result_lock:\n                    <IND>self.handle_output_result = (\n                        work_function_input,\n                        work_function_return,\n                        handle_output_result\n                    )\n            <DED><DED>self.in_queue.task_done()\n\n    <DED><DED>@staticmethod\n    def exception_traceback_string(exception):\n        <IND>'''\n        Helper to get the traceback from an exception object.\n        This is usually what you want to print if an error happens in a thread:\n        https://stackoverflow.com/questions/3702675/how-to-print-the-full-traceback-without-halting-the-program/56199295#56199295\n        '''\n        return ''.join(traceback.format_exception(\n            None, exception, exception.__traceback__)\n        )\n\n    <DED>def get_handle_output_result(self):\n        <IND>'''\n        :return: if a handle_output call has raised previously, return a tuple:\n\n            ....\n            (work_function_input, work_function_return, exception_raised)\n            ....\n\n            corresponding to the first such raise.\n\n            Otherwise, if a handle_output returned non-None, a tuple:\n\n            (work_function_input, work_function_return, handle_output_return)\n\n            Otherwise, None.\n        '''\n        return self.handle_output_result\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "            thread.join()\n        return self.error_output\n\n    def _func_runner(self, thread_id):\n        while True:\n            work = self.in_queue.get(block=True)\n            if work is None:\n                break\n            if self.thread_id_arg is not None:\n                work[self.thread_id_arg] = thread_id\n            try:\n                exception = None\n                out = self.func(**work)\n            except Exception as e:\n                exception = e\n                out = None\n            try:\n                handle_output_return = self.handle_output(work, out, exception)\n            except Exception as e:\n                with self.error_output_lock:\n                    self.error_output = (work, out, e)\n            else:\n                if handle_output_return is not None:\n                    with self.error_output_lock:\n                        self.error_output = handle_output_return\n            finally:\n                self.in_queue.task_done()\n\nif __name__ == '__main__':\n    def func_maybe_raise(i):\n        '''\n",
        "source_code_len": 1050,
        "target_code": "            thread.join()\n        return self.get_handle_output_result()\n\n    def submit(\n        self,\n        work_function_input: Union[Dict,None] =None\n    ):\n        '''\n        Submit work. Block if there is already enough work scheduled (~nthreads).\n\n        :return: the same as get_handle_output_result\n        '''\n        handle_output_result = self.get_handle_output_result()\n        if handle_output_result is not None:\n            if self.submit_raise_exit:\n                raise ThreadPoolExitException()\n            if self.submit_skip_exit:\n                return handle_output_result\n        if work_function_input is None:\n            work_function_input = {}\n        self.in_queue.put(work_function_input)\n        return handle_output_result\n\nif __name__ == '__main__':\n    def get_work(min_, max_):\n        '''\n        Generate simple range work for work_function.\n        '''\n        for i in range(min_, max_):\n            yield {'i': i}\n\n    def work_function_maybe_raise(i):\n        '''\n",
        "target_code_len": 1011,
        "diff_format": "@@ -130,31 +283,33 @@\n             thread.join()\n-        return self.error_output\n-\n-    def _func_runner(self, thread_id):\n-        while True:\n-            work = self.in_queue.get(block=True)\n-            if work is None:\n-                break\n-            if self.thread_id_arg is not None:\n-                work[self.thread_id_arg] = thread_id\n-            try:\n-                exception = None\n-                out = self.func(**work)\n-            except Exception as e:\n-                exception = e\n-                out = None\n-            try:\n-                handle_output_return = self.handle_output(work, out, exception)\n-            except Exception as e:\n-                with self.error_output_lock:\n-                    self.error_output = (work, out, e)\n-            else:\n-                if handle_output_return is not None:\n-                    with self.error_output_lock:\n-                        self.error_output = handle_output_return\n-            finally:\n-                self.in_queue.task_done()\n+        return self.get_handle_output_result()\n+\n+    def submit(\n+        self,\n+        work_function_input: Union[Dict,None] =None\n+    ):\n+        '''\n+        Submit work. Block if there is already enough work scheduled (~nthreads).\n+\n+        :return: the same as get_handle_output_result\n+        '''\n+        handle_output_result = self.get_handle_output_result()\n+        if handle_output_result is not None:\n+            if self.submit_raise_exit:\n+                raise ThreadPoolExitException()\n+            if self.submit_skip_exit:\n+                return handle_output_result\n+        if work_function_input is None:\n+            work_function_input = {}\n+        self.in_queue.put(work_function_input)\n+        return handle_output_result\n \n if __name__ == '__main__':\n-    def func_maybe_raise(i):\n+    def get_work(min_, max_):\n+        '''\n+        Generate simple range work for work_function.\n+        '''\n+        for i in range(min_, max_):\n+            yield {'i': i}\n+\n+    def work_function_maybe_raise(i):\n         '''\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "            <IND>thread.join()\n        <DED>return self.error_output\n\n    <DED>def _func_runner(self, thread_id):\n        <IND>while True:\n            <IND>work = self.in_queue.get(block=True)\n            if work is None:\n                <IND>break\n            <DED>if self.thread_id_arg is not None:\n                <IND>work[self.thread_id_arg] = thread_id\n            <DED>try:\n                <IND>exception = None\n                out = self.func(**work)\n            <DED>except Exception as e:\n                <IND>exception = e\n                out = None\n            <DED>try:\n                <IND>handle_output_return = self.handle_output(work, out, exception)\n            <DED>except Exception as e:\n                <IND>with self.error_output_lock:\n                    <IND>self.error_output = (work, out, e)\n            <DED><DED>else:\n                <IND>if handle_output_return is not None:\n                    <IND>with self.error_output_lock:\n                        <IND>self.error_output = handle_output_return\n            <DED><DED><DED>finally:\n                <IND>self.in_queue.task_done()\n\n<DED><DED><DED><DED>if __name__ == '__main__':\n    <IND>def func_maybe_raise(i):\n        <IND>",
        "target_code_with_indent": "            <IND>thread.join()\n        <DED>return self.get_handle_output_result()\n\n    <DED>def submit(\n        self,\n        work_function_input: Union[Dict,None] =None\n    ):\n        <IND>'''\n        Submit work. Block if there is already enough work scheduled (~nthreads).\n\n        :return: the same as get_handle_output_result\n        '''\n        handle_output_result = self.get_handle_output_result()\n        if handle_output_result is not None:\n            <IND>if self.submit_raise_exit:\n                <IND>raise ThreadPoolExitException()\n            <DED>if self.submit_skip_exit:\n                <IND>return handle_output_result\n        <DED><DED>if work_function_input is None:\n            <IND>work_function_input = {}\n        <DED>self.in_queue.put(work_function_input)\n        return handle_output_result\n\n<DED><DED>if __name__ == '__main__':\n    <IND>def get_work(min_, max_):\n        <IND>'''\n        Generate simple range work for work_function.\n        '''\n        for i in range(min_, max_):\n            <IND>yield {'i': i}\n\n    <DED><DED>def work_function_maybe_raise(i):\n        <IND>"
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n    def func_get_thread(i, thread_id):\n        time.sleep((abs(i) % 4) / 10.0)\n        return thread_id\n\n    def get_work(min_, max_):\n        '''\n        Generate simple range work for my_func.\n        '''\n        for i in range(min_, max_):\n            yield {'i': i}\n\n",
        "source_code_len": 272,
        "target_code": "\n    def work_function_get_thread(i, thread_id):\n        time.sleep((abs(i) % 4) / 10.0)\n        return thread_id\n\n",
        "target_code_len": 115,
        "diff_format": "@@ -167,12 +322,5 @@\n \n-    def func_get_thread(i, thread_id):\n+    def work_function_get_thread(i, thread_id):\n         time.sleep((abs(i) % 4) / 10.0)\n         return thread_id\n-\n-    def get_work(min_, max_):\n-        '''\n-        Generate simple range work for my_func.\n-        '''\n-        for i in range(min_, max_):\n-            yield {'i': i}\n \n",
        "source_code_with_indent": "\n    <DED>def func_get_thread(i, thread_id):\n        <IND>time.sleep((abs(i) % 4) / 10.0)\n        return thread_id\n\n    <DED>def get_work(min_, max_):\n        <IND>'''\n        Generate simple range work for my_func.\n        '''\n        for i in range(min_, max_):\n            <IND>yield {'i': i}\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n    <DED>def work_function_get_thread(i, thread_id):\n        <IND>time.sleep((abs(i) % 4) / 10.0)\n        return thread_id\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "        print('{!r} {!r} {!r}'.format(input, output, exception))\n        if input['i'] == 10:\n            raise Exception\n\n",
        "source_code_len": 123,
        "target_code": "        print('{!r} {!r} {!r}'.format(input, output, exception))\n        if input['i'] == 0:\n            raise Exception\n\n    def handle_output_raise_exit_exception(input, output, exception):\n        '''\n        Return a ThreadPoolExitException() if input == -5.\n        Return the work_function exception if it raised.\n        '''\n        print('{!r} {!r} {!r}'.format(input, output, exception))\n        if exception:\n            return exception\n        if output == 10.0 / -5:\n            return ThreadPoolExitException()\n\n",
        "target_code_len": 526,
        "diff_format": "@@ -206,4 +354,15 @@\n         print('{!r} {!r} {!r}'.format(input, output, exception))\n-        if input['i'] == 10:\n+        if input['i'] == 0:\n             raise Exception\n+\n+    def handle_output_raise_exit_exception(input, output, exception):\n+        '''\n+        Return a ThreadPoolExitException() if input == -5.\n+        Return the work_function exception if it raised.\n+        '''\n+        print('{!r} {!r} {!r}'.format(input, output, exception))\n+        if exception:\n+            return exception\n+        if output == 10.0 / -5:\n+            return ThreadPoolExitException()\n \n",
        "source_code_with_indent": "        print('{!r} {!r} {!r}'.format(input, output, exception))\n        if input['i'] == 10:\n            <IND>raise Exception\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "        print('{!r} {!r} {!r}'.format(input, output, exception))\n        if input['i'] == 0:\n            <IND>raise Exception\n\n    <DED><DED>def handle_output_raise_exit_exception(input, output, exception):\n        <IND>'''\n        Return a ThreadPoolExitException() if input == -5.\n        Return the work_function exception if it raised.\n        '''\n        print('{!r} {!r} {!r}'.format(input, output, exception))\n        if exception:\n            <IND>return exception\n        <DED>if output == 10.0 / -5:\n            <IND>return ThreadPoolExitException()\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "        max_ = 100\n\n    if argv_len > 4:\n        c = sys.argv[4][0]\n    else:\n        c = '0'\n    if c == '1':\n        handle_output = handle_output_print_no_exit\n    elif c == '2':\n        handle_output = handle_output_queue\n    elif c == '3':\n        handle_output = handle_output_raise\n    else:\n        handle_output = handle_output_print\n\n    if argv_len > 5:\n        c = sys.argv[5][0]\n    else:\n        c = '0'\n    if c == '1':\n        my_func = func_get_thread\n        thread_id_arg = 'thread_id'\n    else:\n        my_func = func_maybe_raise\n        thread_id_arg = None\n",
        "source_code_len": 579,
        "target_code": "        max_ = 100\n    if argv_len > 4:\n        handle_output_funtion_string = sys.argv[4]\n    else:\n        handle_output_funtion_string = 'handle_output_print'\n    handle_output = eval(handle_output_funtion_string)\n    if argv_len > 5:\n        work_function = work_function_get_thread\n        thread_id_arg = sys.argv[5]\n    else:\n        work_function = work_function_maybe_raise\n        thread_id_arg = None\n",
        "target_code_len": 412,
        "diff_format": "@@ -227,25 +384,12 @@\n         max_ = 100\n-\n     if argv_len > 4:\n-        c = sys.argv[4][0]\n-    else:\n-        c = '0'\n-    if c == '1':\n-        handle_output = handle_output_print_no_exit\n-    elif c == '2':\n-        handle_output = handle_output_queue\n-    elif c == '3':\n-        handle_output = handle_output_raise\n-    else:\n-        handle_output = handle_output_print\n-\n+        handle_output_funtion_string = sys.argv[4]\n+    else:\n+        handle_output_funtion_string = 'handle_output_print'\n+    handle_output = eval(handle_output_funtion_string)\n     if argv_len > 5:\n-        c = sys.argv[5][0]\n-    else:\n-        c = '0'\n-    if c == '1':\n-        my_func = func_get_thread\n-        thread_id_arg = 'thread_id'\n-    else:\n-        my_func = func_maybe_raise\n+        work_function = work_function_get_thread\n+        thread_id_arg = sys.argv[5]\n+    else:\n+        work_function = work_function_maybe_raise\n         thread_id_arg = None\n",
        "source_code_with_indent": "        <IND>max_ = 100\n\n    <DED>if argv_len > 4:\n        <IND>c = sys.argv[4][0]\n    <DED>else:\n        <IND>c = '0'\n    <DED>if c == '1':\n        <IND>handle_output = handle_output_print_no_exit\n    <DED>elif c == '2':\n        <IND>handle_output = handle_output_queue\n    <DED>elif c == '3':\n        <IND>handle_output = handle_output_raise\n    <DED>else:\n        <IND>handle_output = handle_output_print\n\n    <DED>if argv_len > 5:\n        <IND>c = sys.argv[5][0]\n    <DED>else:\n        <IND>c = '0'\n    <DED>if c == '1':\n        <IND>my_func = func_get_thread\n        thread_id_arg = 'thread_id'\n    <DED>else:\n        <IND>my_func = func_maybe_raise\n        thread_id_arg = None\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "        <IND>max_ = 100\n    <DED>if argv_len > 4:\n        <IND>handle_output_funtion_string = sys.argv[4]\n    <DED>else:\n        <IND>handle_output_funtion_string = 'handle_output_print'\n    <DED>handle_output = eval(handle_output_funtion_string)\n    if argv_len > 5:\n        <IND>work_function = work_function_get_thread\n        thread_id_arg = sys.argv[5]\n    <DED>else:\n        <IND>work_function = work_function_maybe_raise\n        thread_id_arg = None\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    # Action.\n    thread_pool = ThreadPool(\n        my_func,\n        handle_output,\n        nthreads,\n        thread_id_arg,\n    )\n    for work in get_work(min_, max_):\n        error = thread_pool.submit(work)\n        if error is not None:\n            break\n    error = thread_pool.join()\n    if error is not None:\n        print('error: {!r}'.format(error))\n    if handle_output == handle_output_queue:\n",
        "source_code_len": 403,
        "target_code": "    # Action.\n    if handle_output is handle_output_raise_exit_exception:\n        # `with` version with implicit join and submit raise\n        # immediately when desired with ThreadPoolExitException.\n        #\n        # This is the more safe and convenient and DRY usage if\n        # you can use `with`, so prefer it generally.\n        with ThreadPool(\n            work_function,\n            handle_output,\n            nthreads,\n            thread_id_arg,\n            submit_raise_exit=True\n        ) as my_thread_pool:\n            for work in get_work(min_, max_):\n                my_thread_pool.submit(work)\n        handle_output_result = my_thread_pool.get_handle_output_result()\n    else:\n        # Explicit error checking in submit loop to exit immediately\n        # on error.\n        my_thread_pool = ThreadPool(\n            work_function,\n            handle_output,\n            nthreads,\n            thread_id_arg,\n        )\n        for work_function_input in get_work(min_, max_):\n            handle_output_result = my_thread_pool.submit(work_function_input)\n            if handle_output_result is not None:\n                break\n        handle_output_result = my_thread_pool.join()\n    if handle_output_result is not None:\n        work_function_input, work_function_return, exception = handle_output_result\n        if type(exception) is ThreadPoolExitException:\n            print('Early exit requested by handle_output with ThreadPoolExitException:')\n        else:\n            print('work_function or handle_output raised:')\n            print(ThreadPool.exception_traceback_string(exception), end='')\n        print('work_function_input: {!r}'.format(work_function_input))\n        print('work_function_return: {!r}'.format(work_function_return))\n    if handle_output == handle_output_queue:\n",
        "target_code_len": 1799,
        "diff_format": "@@ -253,15 +397,41 @@\n     # Action.\n-    thread_pool = ThreadPool(\n-        my_func,\n-        handle_output,\n-        nthreads,\n-        thread_id_arg,\n-    )\n-    for work in get_work(min_, max_):\n-        error = thread_pool.submit(work)\n-        if error is not None:\n-            break\n-    error = thread_pool.join()\n-    if error is not None:\n-        print('error: {!r}'.format(error))\n+    if handle_output is handle_output_raise_exit_exception:\n+        # `with` version with implicit join and submit raise\n+        # immediately when desired with ThreadPoolExitException.\n+        #\n+        # This is the more safe and convenient and DRY usage if\n+        # you can use `with`, so prefer it generally.\n+        with ThreadPool(\n+            work_function,\n+            handle_output,\n+            nthreads,\n+            thread_id_arg,\n+            submit_raise_exit=True\n+        ) as my_thread_pool:\n+            for work in get_work(min_, max_):\n+                my_thread_pool.submit(work)\n+        handle_output_result = my_thread_pool.get_handle_output_result()\n+    else:\n+        # Explicit error checking in submit loop to exit immediately\n+        # on error.\n+        my_thread_pool = ThreadPool(\n+            work_function,\n+            handle_output,\n+            nthreads,\n+            thread_id_arg,\n+        )\n+        for work_function_input in get_work(min_, max_):\n+            handle_output_result = my_thread_pool.submit(work_function_input)\n+            if handle_output_result is not None:\n+                break\n+        handle_output_result = my_thread_pool.join()\n+    if handle_output_result is not None:\n+        work_function_input, work_function_return, exception = handle_output_result\n+        if type(exception) is ThreadPoolExitException:\n+            print('Early exit requested by handle_output with ThreadPoolExitException:')\n+        else:\n+            print('work_function or handle_output raised:')\n+            print(ThreadPool.exception_traceback_string(exception), end='')\n+        print('work_function_input: {!r}'.format(work_function_input))\n+        print('work_function_return: {!r}'.format(work_function_return))\n     if handle_output == handle_output_queue:\n",
        "source_code_with_indent": "    # Action.\n    <DED>thread_pool = ThreadPool(\n        my_func,\n        handle_output,\n        nthreads,\n        thread_id_arg,\n    )\n    for work in get_work(min_, max_):\n        <IND>error = thread_pool.submit(work)\n        if error is not None:\n            <IND>break\n    <DED><DED>error = thread_pool.join()\n    if error is not None:\n        <IND>print('error: {!r}'.format(error))\n    <DED>if handle_output == handle_output_queue:\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    # Action.\n    <DED>if handle_output is handle_output_raise_exit_exception:\n        # `with` version with implicit join and submit raise\n        # immediately when desired with ThreadPoolExitException.\n        #\n        # This is the more safe and convenient and DRY usage if\n        # you can use `with`, so prefer it generally.\n        <IND>with ThreadPool(\n            work_function,\n            handle_output,\n            nthreads,\n            thread_id_arg,\n            submit_raise_exit=True\n        ) as my_thread_pool:\n            <IND>for work in get_work(min_, max_):\n                <IND>my_thread_pool.submit(work)\n        <DED><DED>handle_output_result = my_thread_pool.get_handle_output_result()\n    <DED>else:\n        # Explicit error checking in submit loop to exit immediately\n        # on error.\n        <IND>my_thread_pool = ThreadPool(\n            work_function,\n            handle_output,\n            nthreads,\n            thread_id_arg,\n        )\n        for work_function_input in get_work(min_, max_):\n            <IND>handle_output_result = my_thread_pool.submit(work_function_input)\n            if handle_output_result is not None:\n                <IND>break\n        <DED><DED>handle_output_result = my_thread_pool.join()\n    <DED>if handle_output_result is not None:\n        <IND>work_function_input, work_function_return, exception = handle_output_result\n        if type(exception) is ThreadPoolExitException:\n            <IND>print('Early exit requested by handle_output with ThreadPoolExitException:')\n        <DED>else:\n            <IND>print('work_function or handle_output raised:')\n            print(ThreadPool.exception_traceback_string(exception), end='')\n        <DED>print('work_function_input: {!r}'.format(work_function_input))\n        print('work_function_return: {!r}'.format(work_function_return))\n    <DED>if handle_output == handle_output_queue:\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  }
]