[
  {
    "project": "pantsbuild/pants",
    "commit": "f6fa5da0ccd5e5e90037b08dfe9d9af02cc68bad",
    "filename": "src/python/pants/engine/scheduler.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/pantsbuild-pants/src/python/pants/engine/scheduler.py",
    "file_hunks_size": 5,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": true,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "src/python/pants/engine/scheduler.py:402:25 Invalid type [31]: Expression `pants.util.objects.datatype(\"SnapshottedProcess\", [\"product_type\", \"binary_type\", \"input_selectors\", \"input_conversion\", \"output_conversion\"])` is not a valid type.",
    "message": " Expression `pants.util.objects.datatype(\"SnapshottedProcess\", [\"product_type\", \"binary_type\", \"input_selectors\", \"input_conversion\", \"output_conversion\"])` is not a valid type.",
    "rule_id": "Invalid type [31]",
    "warning_line_no": 402,
    "warning_line": "class SnapshottedProcess(datatype('SnapshottedProcess', ['product_type',",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": true,
        "has_suppression": false,
        "source_code": "  \"\"\"\n\n\nclass SnapshottedProcess(datatype('SnapshottedProcess', ['product_type',\n                                                         'binary_type',\n                                                         'input_selectors',\n                                                         'input_conversion',\n                                                         'output_conversion'])):\n  \"\"\"A task type for defining execution of snapshotted processes.\"\"\"\n\n  def as_node(self, subject, product_type, variants):\n    return ProcessExecutionNode(subject, variants, self)\n\n  @property\n  def output_product_type(self):\n    return self.product_type\n\n  @property\n  def input_selects(self):\n    return self.input_selectors\n\n\nclass TaskNodeFactory(datatype('Task', ['input_selects', 'task_func', 'product_type'])):\n  \"\"\"A set-friendly curried TaskNode constructor.\"\"\"\n\n  def as_node(self, subject, product_type, variants):\n    return TaskNode(subject, product_type, variants, self.task_func, self.input_selects)\n\n\nclass NodeBuilder(Closable):\n  \"\"\"Holds an index of tasks and intrinsics used to instantiate Nodes.\"\"\"\n\n  @classmethod\n  def create(cls, task_entries):\n    \"\"\"Creates a NodeBuilder with tasks indexed by their output type.\"\"\"\n    serializable_tasks = defaultdict(set)\n    for entry in task_entries:\n      if isinstance(entry, (tuple, list)) and len(entry) == 3:\n        output_type, input_selects, task = entry\n        serializable_tasks[output_type].add(\n          TaskNodeFactory(tuple(input_selects), task, output_type)\n        )\n      elif isinstance(entry, SnapshottedProcess):\n        serializable_tasks[entry.output_product_type].add(entry)\n      else:\n        raise Exception(\"Unexpected type for entry {}\".format(entry))\n\n    intrinsics = dict()\n    intrinsics.update(FilesystemNode.as_intrinsics())\n    intrinsics.update(SnapshotNode.as_intrinsics())\n    return cls(serializable_tasks, intrinsics)\n\n  @classmethod\n  def create_task_node(cls, subject, product_type, variants, task_func, clause):\n    return TaskNode(subject, product_type, variants, task_func, clause)\n\n  def __init__(self, tasks, intrinsics):\n    self._tasks = tasks\n    self._intrinsics = intrinsics\n\n  def gen_nodes(self, subject, product_type, variants):\n    # Intrinsics that provide the requested product for the current subject type.\n    intrinsic_node_factory = self._lookup_intrinsic(product_type, subject)\n    if intrinsic_node_factory:\n      yield intrinsic_node_factory(subject, product_type, variants)\n    else:\n      # Tasks that provide the requested product.\n      for node_factory in self._lookup_tasks(product_type):\n        yield node_factory(subject, product_type, variants)\n\n  def _lookup_tasks(self, product_type):\n    for entry in self._tasks[product_type]:\n      yield entry.as_node\n\n  def _lookup_intrinsic(self, product_type, subject):\n    return self._intrinsics.get((type(subject), product_type))\n\n",
        "source_code_len": 2905,
        "target_code": "  \"\"\"\n\n",
        "target_code_len": 7,
        "diff_format": "@@ -399,77 +398,2 @@\n   \"\"\"\n-\n-\n-class SnapshottedProcess(datatype('SnapshottedProcess', ['product_type',\n-                                                         'binary_type',\n-                                                         'input_selectors',\n-                                                         'input_conversion',\n-                                                         'output_conversion'])):\n-  \"\"\"A task type for defining execution of snapshotted processes.\"\"\"\n-\n-  def as_node(self, subject, product_type, variants):\n-    return ProcessExecutionNode(subject, variants, self)\n-\n-  @property\n-  def output_product_type(self):\n-    return self.product_type\n-\n-  @property\n-  def input_selects(self):\n-    return self.input_selectors\n-\n-\n-class TaskNodeFactory(datatype('Task', ['input_selects', 'task_func', 'product_type'])):\n-  \"\"\"A set-friendly curried TaskNode constructor.\"\"\"\n-\n-  def as_node(self, subject, product_type, variants):\n-    return TaskNode(subject, product_type, variants, self.task_func, self.input_selects)\n-\n-\n-class NodeBuilder(Closable):\n-  \"\"\"Holds an index of tasks and intrinsics used to instantiate Nodes.\"\"\"\n-\n-  @classmethod\n-  def create(cls, task_entries):\n-    \"\"\"Creates a NodeBuilder with tasks indexed by their output type.\"\"\"\n-    serializable_tasks = defaultdict(set)\n-    for entry in task_entries:\n-      if isinstance(entry, (tuple, list)) and len(entry) == 3:\n-        output_type, input_selects, task = entry\n-        serializable_tasks[output_type].add(\n-          TaskNodeFactory(tuple(input_selects), task, output_type)\n-        )\n-      elif isinstance(entry, SnapshottedProcess):\n-        serializable_tasks[entry.output_product_type].add(entry)\n-      else:\n-        raise Exception(\"Unexpected type for entry {}\".format(entry))\n-\n-    intrinsics = dict()\n-    intrinsics.update(FilesystemNode.as_intrinsics())\n-    intrinsics.update(SnapshotNode.as_intrinsics())\n-    return cls(serializable_tasks, intrinsics)\n-\n-  @classmethod\n-  def create_task_node(cls, subject, product_type, variants, task_func, clause):\n-    return TaskNode(subject, product_type, variants, task_func, clause)\n-\n-  def __init__(self, tasks, intrinsics):\n-    self._tasks = tasks\n-    self._intrinsics = intrinsics\n-\n-  def gen_nodes(self, subject, product_type, variants):\n-    # Intrinsics that provide the requested product for the current subject type.\n-    intrinsic_node_factory = self._lookup_intrinsic(product_type, subject)\n-    if intrinsic_node_factory:\n-      yield intrinsic_node_factory(subject, product_type, variants)\n-    else:\n-      # Tasks that provide the requested product.\n-      for node_factory in self._lookup_tasks(product_type):\n-        yield node_factory(subject, product_type, variants)\n-\n-  def _lookup_tasks(self, product_type):\n-    for entry in self._tasks[product_type]:\n-      yield entry.as_node\n-\n-  def _lookup_intrinsic(self, product_type, subject):\n-    return self._intrinsics.get((type(subject), product_type))\n \n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\n\n\n<DED>class SnapshottedProcess(datatype('SnapshottedProcess', ['product_type',\n                                                         'binary_type',\n                                                         'input_selectors',\n                                                         'input_conversion',\n                                                         'output_conversion'])):\n  <IND>\"\"\"A task type for defining execution of snapshotted processes.\"\"\"\n\n  def as_node(self, subject, product_type, variants):\n    <IND>return ProcessExecutionNode(subject, variants, self)\n\n  <DED>@property\n  def output_product_type(self):\n    <IND>return self.product_type\n\n  <DED>@property\n  def input_selects(self):\n    <IND>return self.input_selectors\n\n\n<DED><DED>class TaskNodeFactory(datatype('Task', ['input_selects', 'task_func', 'product_type'])):\n  <IND>\"\"\"A set-friendly curried TaskNode constructor.\"\"\"\n\n  def as_node(self, subject, product_type, variants):\n    <IND>return TaskNode(subject, product_type, variants, self.task_func, self.input_selects)\n\n\n<DED><DED>class NodeBuilder(Closable):\n  <IND>\"\"\"Holds an index of tasks and intrinsics used to instantiate Nodes.\"\"\"\n\n  @classmethod\n  def create(cls, task_entries):\n    <IND>\"\"\"Creates a NodeBuilder with tasks indexed by their output type.\"\"\"\n    serializable_tasks = defaultdict(set)\n    for entry in task_entries:\n      <IND>if isinstance(entry, (tuple, list)) and len(entry) == 3:\n        <IND>output_type, input_selects, task = entry\n        serializable_tasks[output_type].add(\n          TaskNodeFactory(tuple(input_selects), task, output_type)\n        )\n      <DED>elif isinstance(entry, SnapshottedProcess):\n        <IND>serializable_tasks[entry.output_product_type].add(entry)\n      <DED>else:\n        <IND>raise Exception(\"Unexpected type for entry {}\".format(entry))\n\n    <DED><DED>intrinsics = dict()\n    intrinsics.update(FilesystemNode.as_intrinsics())\n    intrinsics.update(SnapshotNode.as_intrinsics())\n    return cls(serializable_tasks, intrinsics)\n\n  <DED>@classmethod\n  def create_task_node(cls, subject, product_type, variants, task_func, clause):\n    <IND>return TaskNode(subject, product_type, variants, task_func, clause)\n\n  <DED>def __init__(self, tasks, intrinsics):\n    <IND>self._tasks = tasks\n    self._intrinsics = intrinsics\n\n  <DED>def gen_nodes(self, subject, product_type, variants):\n    # Intrinsics that provide the requested product for the current subject type.\n    <IND>intrinsic_node_factory = self._lookup_intrinsic(product_type, subject)\n    if intrinsic_node_factory:\n      <IND>yield intrinsic_node_factory(subject, product_type, variants)\n    <DED>else:\n      # Tasks that provide the requested product.\n      <IND>for node_factory in self._lookup_tasks(product_type):\n        <IND>yield node_factory(subject, product_type, variants)\n\n  <DED><DED><DED>def _lookup_tasks(self, product_type):\n    <IND>for entry in self._tasks[product_type]:\n      <IND>yield entry.as_node\n\n  <DED><DED>def _lookup_intrinsic(self, product_type, subject):\n    <IND>return self._intrinsics.get((type(subject), product_type))\n\n",
        "target_code_with_indent": "\n\n"
      }
    ]
  },
  {
    "project": "pantsbuild/pants",
    "commit": "f6fa5da0ccd5e5e90037b08dfe9d9af02cc68bad",
    "filename": "src/python/pants/engine/scheduler.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/pantsbuild-pants/src/python/pants/engine/scheduler.py",
    "file_hunks_size": 5,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": true,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "src/python/pants/engine/scheduler.py:421:22 Invalid type [31]: Expression `pants.util.objects.datatype(\"Task\", [\"input_selects\", \"task_func\", \"product_type\"])` is not a valid type.",
    "message": " Expression `pants.util.objects.datatype(\"Task\", [\"input_selects\", \"task_func\", \"product_type\"])` is not a valid type.",
    "rule_id": "Invalid type [31]",
    "warning_line_no": 421,
    "warning_line": "class TaskNodeFactory(datatype('Task', ['input_selects', 'task_func', 'product_type'])):",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": true,
        "has_suppression": false,
        "source_code": "  \"\"\"\n\n\nclass SnapshottedProcess(datatype('SnapshottedProcess', ['product_type',\n                                                         'binary_type',\n                                                         'input_selectors',\n                                                         'input_conversion',\n                                                         'output_conversion'])):\n  \"\"\"A task type for defining execution of snapshotted processes.\"\"\"\n\n  def as_node(self, subject, product_type, variants):\n    return ProcessExecutionNode(subject, variants, self)\n\n  @property\n  def output_product_type(self):\n    return self.product_type\n\n  @property\n  def input_selects(self):\n    return self.input_selectors\n\n\nclass TaskNodeFactory(datatype('Task', ['input_selects', 'task_func', 'product_type'])):\n  \"\"\"A set-friendly curried TaskNode constructor.\"\"\"\n\n  def as_node(self, subject, product_type, variants):\n    return TaskNode(subject, product_type, variants, self.task_func, self.input_selects)\n\n\nclass NodeBuilder(Closable):\n  \"\"\"Holds an index of tasks and intrinsics used to instantiate Nodes.\"\"\"\n\n  @classmethod\n  def create(cls, task_entries):\n    \"\"\"Creates a NodeBuilder with tasks indexed by their output type.\"\"\"\n    serializable_tasks = defaultdict(set)\n    for entry in task_entries:\n      if isinstance(entry, (tuple, list)) and len(entry) == 3:\n        output_type, input_selects, task = entry\n        serializable_tasks[output_type].add(\n          TaskNodeFactory(tuple(input_selects), task, output_type)\n        )\n      elif isinstance(entry, SnapshottedProcess):\n        serializable_tasks[entry.output_product_type].add(entry)\n      else:\n        raise Exception(\"Unexpected type for entry {}\".format(entry))\n\n    intrinsics = dict()\n    intrinsics.update(FilesystemNode.as_intrinsics())\n    intrinsics.update(SnapshotNode.as_intrinsics())\n    return cls(serializable_tasks, intrinsics)\n\n  @classmethod\n  def create_task_node(cls, subject, product_type, variants, task_func, clause):\n    return TaskNode(subject, product_type, variants, task_func, clause)\n\n  def __init__(self, tasks, intrinsics):\n    self._tasks = tasks\n    self._intrinsics = intrinsics\n\n  def gen_nodes(self, subject, product_type, variants):\n    # Intrinsics that provide the requested product for the current subject type.\n    intrinsic_node_factory = self._lookup_intrinsic(product_type, subject)\n    if intrinsic_node_factory:\n      yield intrinsic_node_factory(subject, product_type, variants)\n    else:\n      # Tasks that provide the requested product.\n      for node_factory in self._lookup_tasks(product_type):\n        yield node_factory(subject, product_type, variants)\n\n  def _lookup_tasks(self, product_type):\n    for entry in self._tasks[product_type]:\n      yield entry.as_node\n\n  def _lookup_intrinsic(self, product_type, subject):\n    return self._intrinsics.get((type(subject), product_type))\n\n",
        "source_code_len": 2905,
        "target_code": "  \"\"\"\n\n",
        "target_code_len": 7,
        "diff_format": "@@ -399,77 +398,2 @@\n   \"\"\"\n-\n-\n-class SnapshottedProcess(datatype('SnapshottedProcess', ['product_type',\n-                                                         'binary_type',\n-                                                         'input_selectors',\n-                                                         'input_conversion',\n-                                                         'output_conversion'])):\n-  \"\"\"A task type for defining execution of snapshotted processes.\"\"\"\n-\n-  def as_node(self, subject, product_type, variants):\n-    return ProcessExecutionNode(subject, variants, self)\n-\n-  @property\n-  def output_product_type(self):\n-    return self.product_type\n-\n-  @property\n-  def input_selects(self):\n-    return self.input_selectors\n-\n-\n-class TaskNodeFactory(datatype('Task', ['input_selects', 'task_func', 'product_type'])):\n-  \"\"\"A set-friendly curried TaskNode constructor.\"\"\"\n-\n-  def as_node(self, subject, product_type, variants):\n-    return TaskNode(subject, product_type, variants, self.task_func, self.input_selects)\n-\n-\n-class NodeBuilder(Closable):\n-  \"\"\"Holds an index of tasks and intrinsics used to instantiate Nodes.\"\"\"\n-\n-  @classmethod\n-  def create(cls, task_entries):\n-    \"\"\"Creates a NodeBuilder with tasks indexed by their output type.\"\"\"\n-    serializable_tasks = defaultdict(set)\n-    for entry in task_entries:\n-      if isinstance(entry, (tuple, list)) and len(entry) == 3:\n-        output_type, input_selects, task = entry\n-        serializable_tasks[output_type].add(\n-          TaskNodeFactory(tuple(input_selects), task, output_type)\n-        )\n-      elif isinstance(entry, SnapshottedProcess):\n-        serializable_tasks[entry.output_product_type].add(entry)\n-      else:\n-        raise Exception(\"Unexpected type for entry {}\".format(entry))\n-\n-    intrinsics = dict()\n-    intrinsics.update(FilesystemNode.as_intrinsics())\n-    intrinsics.update(SnapshotNode.as_intrinsics())\n-    return cls(serializable_tasks, intrinsics)\n-\n-  @classmethod\n-  def create_task_node(cls, subject, product_type, variants, task_func, clause):\n-    return TaskNode(subject, product_type, variants, task_func, clause)\n-\n-  def __init__(self, tasks, intrinsics):\n-    self._tasks = tasks\n-    self._intrinsics = intrinsics\n-\n-  def gen_nodes(self, subject, product_type, variants):\n-    # Intrinsics that provide the requested product for the current subject type.\n-    intrinsic_node_factory = self._lookup_intrinsic(product_type, subject)\n-    if intrinsic_node_factory:\n-      yield intrinsic_node_factory(subject, product_type, variants)\n-    else:\n-      # Tasks that provide the requested product.\n-      for node_factory in self._lookup_tasks(product_type):\n-        yield node_factory(subject, product_type, variants)\n-\n-  def _lookup_tasks(self, product_type):\n-    for entry in self._tasks[product_type]:\n-      yield entry.as_node\n-\n-  def _lookup_intrinsic(self, product_type, subject):\n-    return self._intrinsics.get((type(subject), product_type))\n \n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\n\n\n<DED>class SnapshottedProcess(datatype('SnapshottedProcess', ['product_type',\n                                                         'binary_type',\n                                                         'input_selectors',\n                                                         'input_conversion',\n                                                         'output_conversion'])):\n  <IND>\"\"\"A task type for defining execution of snapshotted processes.\"\"\"\n\n  def as_node(self, subject, product_type, variants):\n    <IND>return ProcessExecutionNode(subject, variants, self)\n\n  <DED>@property\n  def output_product_type(self):\n    <IND>return self.product_type\n\n  <DED>@property\n  def input_selects(self):\n    <IND>return self.input_selectors\n\n\n<DED><DED>class TaskNodeFactory(datatype('Task', ['input_selects', 'task_func', 'product_type'])):\n  <IND>\"\"\"A set-friendly curried TaskNode constructor.\"\"\"\n\n  def as_node(self, subject, product_type, variants):\n    <IND>return TaskNode(subject, product_type, variants, self.task_func, self.input_selects)\n\n\n<DED><DED>class NodeBuilder(Closable):\n  <IND>\"\"\"Holds an index of tasks and intrinsics used to instantiate Nodes.\"\"\"\n\n  @classmethod\n  def create(cls, task_entries):\n    <IND>\"\"\"Creates a NodeBuilder with tasks indexed by their output type.\"\"\"\n    serializable_tasks = defaultdict(set)\n    for entry in task_entries:\n      <IND>if isinstance(entry, (tuple, list)) and len(entry) == 3:\n        <IND>output_type, input_selects, task = entry\n        serializable_tasks[output_type].add(\n          TaskNodeFactory(tuple(input_selects), task, output_type)\n        )\n      <DED>elif isinstance(entry, SnapshottedProcess):\n        <IND>serializable_tasks[entry.output_product_type].add(entry)\n      <DED>else:\n        <IND>raise Exception(\"Unexpected type for entry {}\".format(entry))\n\n    <DED><DED>intrinsics = dict()\n    intrinsics.update(FilesystemNode.as_intrinsics())\n    intrinsics.update(SnapshotNode.as_intrinsics())\n    return cls(serializable_tasks, intrinsics)\n\n  <DED>@classmethod\n  def create_task_node(cls, subject, product_type, variants, task_func, clause):\n    <IND>return TaskNode(subject, product_type, variants, task_func, clause)\n\n  <DED>def __init__(self, tasks, intrinsics):\n    <IND>self._tasks = tasks\n    self._intrinsics = intrinsics\n\n  <DED>def gen_nodes(self, subject, product_type, variants):\n    # Intrinsics that provide the requested product for the current subject type.\n    <IND>intrinsic_node_factory = self._lookup_intrinsic(product_type, subject)\n    if intrinsic_node_factory:\n      <IND>yield intrinsic_node_factory(subject, product_type, variants)\n    <DED>else:\n      # Tasks that provide the requested product.\n      <IND>for node_factory in self._lookup_tasks(product_type):\n        <IND>yield node_factory(subject, product_type, variants)\n\n  <DED><DED><DED>def _lookup_tasks(self, product_type):\n    <IND>for entry in self._tasks[product_type]:\n      <IND>yield entry.as_node\n\n  <DED><DED>def _lookup_intrinsic(self, product_type, subject):\n    <IND>return self._intrinsics.get((type(subject), product_type))\n\n",
        "target_code_with_indent": "\n\n"
      }
    ]
  }
]