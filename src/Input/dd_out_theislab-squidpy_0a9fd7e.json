[
  {
    "project": "theislab/squidpy",
    "commit": "0a9fd7e4a3747db318e65a0a9fd3a31e87c06eed",
    "filename": "docs/source/utils.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/theislab-squidpy/docs/source/utils.py",
    "file_hunks_size": 7,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "docs/source/utils.py:77:4 Incompatible variable type [9]: path is declared to have type `str` but is used as type `Path`.",
    "message": " path is declared to have type `str` but is used as type `Path`.",
    "rule_id": "Incompatible variable type [9]",
    "warning_line_no": 77,
    "warning_line": "    path = Path(path)",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "@_cleanup\ndef _download_dir(url: str, *, path: str, depth: int) -> Tuple[bool, Optional[Union[Exception, str]]]:\n    if depth == 0:\n",
        "source_code_len": 132,
        "target_code": "@_cleanup\ndef _download_dir(url: str, *, path: Union[str, Path], depth: int) -> Tuple[bool, Optional[Union[Exception, str]]]:\n    if depth == 0:\n",
        "target_code_len": 145,
        "diff_format": "@@ -67,3 +66,3 @@\n @_cleanup\n-def _download_dir(url: str, *, path: str, depth: int) -> Tuple[bool, Optional[Union[Exception, str]]]:\n+def _download_dir(url: str, *, path: Union[str, Path], depth: int) -> Tuple[bool, Optional[Union[Exception, str]]]:\n     if depth == 0:\n",
        "source_code_with_indent": "<DED>@_cleanup\ndef _download_dir(url: str, *, path: str, depth: int) -> Tuple[bool, Optional[Union[Exception, str]]]:\n    <IND>if depth == 0:\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "<DED>@_cleanup\ndef _download_dir(url: str, *, path: Union[str, Path], depth: int) -> Tuple[bool, Optional[Union[Exception, str]]]:\n    <IND>if depth == 0:\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "theislab/squidpy",
    "commit": "0a9fd7e4a3747db318e65a0a9fd3a31e87c06eed",
    "filename": "docs/source/utils.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/theislab-squidpy/docs/source/utils.py",
    "file_hunks_size": 7,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "docs/source/utils.py:81:15 Unsupported operand [58]: `/` is not supported for operand types `str` and `typing.Any`.",
    "message": " `/` is not supported for operand types `str` and `typing.Any`.",
    "rule_id": "Unsupported operand [58]",
    "warning_line_no": 81,
    "warning_line": "        dest = path / item[\"name\"]",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "@_cleanup\ndef _download_dir(url: str, *, path: str, depth: int) -> Tuple[bool, Optional[Union[Exception, str]]]:\n    if depth == 0:\n",
        "source_code_len": 132,
        "target_code": "@_cleanup\ndef _download_dir(url: str, *, path: Union[str, Path], depth: int) -> Tuple[bool, Optional[Union[Exception, str]]]:\n    if depth == 0:\n",
        "target_code_len": 145,
        "diff_format": "@@ -67,3 +66,3 @@\n @_cleanup\n-def _download_dir(url: str, *, path: str, depth: int) -> Tuple[bool, Optional[Union[Exception, str]]]:\n+def _download_dir(url: str, *, path: Union[str, Path], depth: int) -> Tuple[bool, Optional[Union[Exception, str]]]:\n     if depth == 0:\n",
        "source_code_with_indent": "<DED>@_cleanup\ndef _download_dir(url: str, *, path: str, depth: int) -> Tuple[bool, Optional[Union[Exception, str]]]:\n    <IND>if depth == 0:\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "<DED>@_cleanup\ndef _download_dir(url: str, *, path: Union[str, Path], depth: int) -> Tuple[bool, Optional[Union[Exception, str]]]:\n    <IND>if depth == 0:\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "theislab/squidpy",
    "commit": "0a9fd7e4a3747db318e65a0a9fd3a31e87c06eed",
    "filename": "squidpy/gr/_ligrec.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/theislab-squidpy/squidpy/gr/_ligrec.py",
    "file_hunks_size": 42,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": true,
    "full_warning_msg": "squidpy/gr/_ligrec.py:372:12 Incompatible variable type [9]: clusters is declared to have type `Union[None, Sequence[Tuple[str, str]], Sequence[str]]` but is used as type `product[typing.Any]`.",
    "message": " clusters is declared to have type `Union[None, Sequence[Tuple[str, str]], Sequence[str]]` but is used as type `product[typing.Any]`.",
    "rule_id": "Incompatible variable type [9]",
    "warning_line_no": 372,
    "warning_line": "            clusters = product(clusters, repeat=2)",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": true,
        "source_code": "            )\n\n        if clusters is None:\n            clusters = sorted(map(str, self._adata.obs[cluster_key].cat.categories))\n\n        self._filtered_data[\"clusters\"] = self._adata.obs[cluster_key].astype(\"string\").astype(\"category\").values\n        cluster_cats = self._filtered_data[\"clusters\"].cat.categories\n\n        if all(map(lambda c: isinstance(c, str), clusters)):\n            clusters = product(clusters, repeat=2)\n        clusters = sorted(_check_tuple_needles(clusters, cluster_cats, msg=\"Invalid cluster `{0!r}`.\", reraise=True))\n\n        interactions = self.interactions[[SOURCE, TARGET]]\n\n        _clusters = list({c for cs in clusters for c in cs})\n        data = self._filtered_data.loc[np.isin(self._filtered_data[\"clusters\"], _clusters), :]\n        data[\"clusters\"].cat.remove_unused_categories(inplace=True)\n",
        "source_code_len": 830,
        "target_code": "            )\n        if TYPE_CHECKING:\n            assert isinstance(self.interactions, pd.DataFrame)\n            assert isinstance(self._filtered_data, pd.DataFrame)\n\n        interactions = self.interactions[[SOURCE, TARGET]]\n        self._filtered_data[\"clusters\"] = self._adata.obs[cluster_key].astype(\"string\").astype(\"category\").values\n\n        if clusters is None:\n            clusters = list(map(str, self._adata.obs[cluster_key].cat.categories))\n        if all(isinstance(c, str) for c in clusters):\n            clusters = list(product(clusters, repeat=2))  # type: ignore[no-redef,assignment]\n        clusters = sorted(\n            _check_tuple_needles(\n                clusters,  # type: ignore[arg-type]\n                self._filtered_data[\"clusters\"].cat.categories,\n                msg=\"Invalid cluster `{0!r}`.\",\n                reraise=True,\n            )\n        )\n        clusters_flat = list({c for cs in clusters for c in cs})\n\n        data = self._filtered_data.loc[np.isin(self._filtered_data[\"clusters\"], clusters_flat), :]\n        data[\"clusters\"].cat.remove_unused_categories(inplace=True)\n",
        "target_code_len": 1115,
        "diff_format": "@@ -363,17 +366,24 @@\n             )\n+        if TYPE_CHECKING:\n+            assert isinstance(self.interactions, pd.DataFrame)\n+            assert isinstance(self._filtered_data, pd.DataFrame)\n+\n+        interactions = self.interactions[[SOURCE, TARGET]]\n+        self._filtered_data[\"clusters\"] = self._adata.obs[cluster_key].astype(\"string\").astype(\"category\").values\n \n         if clusters is None:\n-            clusters = sorted(map(str, self._adata.obs[cluster_key].cat.categories))\n-\n-        self._filtered_data[\"clusters\"] = self._adata.obs[cluster_key].astype(\"string\").astype(\"category\").values\n-        cluster_cats = self._filtered_data[\"clusters\"].cat.categories\n-\n-        if all(map(lambda c: isinstance(c, str), clusters)):\n-            clusters = product(clusters, repeat=2)\n-        clusters = sorted(_check_tuple_needles(clusters, cluster_cats, msg=\"Invalid cluster `{0!r}`.\", reraise=True))\n-\n-        interactions = self.interactions[[SOURCE, TARGET]]\n-\n-        _clusters = list({c for cs in clusters for c in cs})\n-        data = self._filtered_data.loc[np.isin(self._filtered_data[\"clusters\"], _clusters), :]\n+            clusters = list(map(str, self._adata.obs[cluster_key].cat.categories))\n+        if all(isinstance(c, str) for c in clusters):\n+            clusters = list(product(clusters, repeat=2))  # type: ignore[no-redef,assignment]\n+        clusters = sorted(\n+            _check_tuple_needles(\n+                clusters,  # type: ignore[arg-type]\n+                self._filtered_data[\"clusters\"].cat.categories,\n+                msg=\"Invalid cluster `{0!r}`.\",\n+                reraise=True,\n+            )\n+        )\n+        clusters_flat = list({c for cs in clusters for c in cs})\n+\n+        data = self._filtered_data.loc[np.isin(self._filtered_data[\"clusters\"], clusters_flat), :]\n         data[\"clusters\"].cat.remove_unused_categories(inplace=True)\n",
        "source_code_with_indent": "            )\n\n        <DED>if clusters is None:\n            <IND>clusters = sorted(map(str, self._adata.obs[cluster_key].cat.categories))\n\n        <DED>self._filtered_data[\"clusters\"] = self._adata.obs[cluster_key].astype(\"string\").astype(\"category\").values\n        cluster_cats = self._filtered_data[\"clusters\"].cat.categories\n\n        if all(map(lambda c: isinstance(c, str), clusters)):\n            <IND>clusters = product(clusters, repeat=2)\n        <DED>clusters = sorted(_check_tuple_needles(clusters, cluster_cats, msg=\"Invalid cluster `{0!r}`.\", reraise=True))\n\n        interactions = self.interactions[[SOURCE, TARGET]]\n\n        _clusters = list({c for cs in clusters for c in cs})\n        data = self._filtered_data.loc[np.isin(self._filtered_data[\"clusters\"], _clusters), :]\n        data[\"clusters\"].cat.remove_unused_categories(inplace=True)\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "            )\n        <DED>if TYPE_CHECKING:\n            <IND>assert isinstance(self.interactions, pd.DataFrame)\n            assert isinstance(self._filtered_data, pd.DataFrame)\n\n        <DED>interactions = self.interactions[[SOURCE, TARGET]]\n        self._filtered_data[\"clusters\"] = self._adata.obs[cluster_key].astype(\"string\").astype(\"category\").values\n\n        if clusters is None:\n            <IND>clusters = list(map(str, self._adata.obs[cluster_key].cat.categories))\n        <DED>if all(isinstance(c, str) for c in clusters):\n            <IND>clusters = list(product(clusters, repeat=2))  # type: ignore[no-redef,assignment]\n        <DED>clusters = sorted(\n            _check_tuple_needles(\n                clusters,  # type: ignore[arg-type]\n                self._filtered_data[\"clusters\"].cat.categories,\n                msg=\"Invalid cluster `{0!r}`.\",\n                reraise=True,\n            )\n        )\n        clusters_flat = list({c for cs in clusters for c in cs})\n\n        data = self._filtered_data.loc[np.isin(self._filtered_data[\"clusters\"], clusters_flat), :]\n        data[\"clusters\"].cat.remove_unused_categories(inplace=True)\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "theislab/squidpy",
    "commit": "0a9fd7e4a3747db318e65a0a9fd3a31e87c06eed",
    "filename": "squidpy/gr/_ligrec.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/theislab-squidpy/squidpy/gr/_ligrec.py",
    "file_hunks_size": 42,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": true,
    "full_warning_msg": "squidpy/gr/_ligrec.py:373:47 Incompatible parameter type [6]: Expected `Sequence[Tuple[typing.Any, typing.Any]]` for 1st positional only parameter to call `_check_tuple_needles` but got `Union[Sequence[Tuple[str, str]], Sequence[str]]`.",
    "message": " Expected `Sequence[Tuple[typing.Any, typing.Any]]` for 1st positional only parameter to call `_check_tuple_needles` but got `Union[Sequence[Tuple[str, str]], Sequence[str]]`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 373,
    "warning_line": "        clusters = sorted(_check_tuple_needles(clusters, cluster_cats, msg=\"Invalid cluster `{0!r}`.\", reraise=True))",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": true,
        "source_code": "            )\n\n        if clusters is None:\n            clusters = sorted(map(str, self._adata.obs[cluster_key].cat.categories))\n\n        self._filtered_data[\"clusters\"] = self._adata.obs[cluster_key].astype(\"string\").astype(\"category\").values\n        cluster_cats = self._filtered_data[\"clusters\"].cat.categories\n\n        if all(map(lambda c: isinstance(c, str), clusters)):\n            clusters = product(clusters, repeat=2)\n        clusters = sorted(_check_tuple_needles(clusters, cluster_cats, msg=\"Invalid cluster `{0!r}`.\", reraise=True))\n\n        interactions = self.interactions[[SOURCE, TARGET]]\n\n        _clusters = list({c for cs in clusters for c in cs})\n        data = self._filtered_data.loc[np.isin(self._filtered_data[\"clusters\"], _clusters), :]\n        data[\"clusters\"].cat.remove_unused_categories(inplace=True)\n",
        "source_code_len": 830,
        "target_code": "            )\n        if TYPE_CHECKING:\n            assert isinstance(self.interactions, pd.DataFrame)\n            assert isinstance(self._filtered_data, pd.DataFrame)\n\n        interactions = self.interactions[[SOURCE, TARGET]]\n        self._filtered_data[\"clusters\"] = self._adata.obs[cluster_key].astype(\"string\").astype(\"category\").values\n\n        if clusters is None:\n            clusters = list(map(str, self._adata.obs[cluster_key].cat.categories))\n        if all(isinstance(c, str) for c in clusters):\n            clusters = list(product(clusters, repeat=2))  # type: ignore[no-redef,assignment]\n        clusters = sorted(\n            _check_tuple_needles(\n                clusters,  # type: ignore[arg-type]\n                self._filtered_data[\"clusters\"].cat.categories,\n                msg=\"Invalid cluster `{0!r}`.\",\n                reraise=True,\n            )\n        )\n        clusters_flat = list({c for cs in clusters for c in cs})\n\n        data = self._filtered_data.loc[np.isin(self._filtered_data[\"clusters\"], clusters_flat), :]\n        data[\"clusters\"].cat.remove_unused_categories(inplace=True)\n",
        "target_code_len": 1115,
        "diff_format": "@@ -363,17 +366,24 @@\n             )\n+        if TYPE_CHECKING:\n+            assert isinstance(self.interactions, pd.DataFrame)\n+            assert isinstance(self._filtered_data, pd.DataFrame)\n+\n+        interactions = self.interactions[[SOURCE, TARGET]]\n+        self._filtered_data[\"clusters\"] = self._adata.obs[cluster_key].astype(\"string\").astype(\"category\").values\n \n         if clusters is None:\n-            clusters = sorted(map(str, self._adata.obs[cluster_key].cat.categories))\n-\n-        self._filtered_data[\"clusters\"] = self._adata.obs[cluster_key].astype(\"string\").astype(\"category\").values\n-        cluster_cats = self._filtered_data[\"clusters\"].cat.categories\n-\n-        if all(map(lambda c: isinstance(c, str), clusters)):\n-            clusters = product(clusters, repeat=2)\n-        clusters = sorted(_check_tuple_needles(clusters, cluster_cats, msg=\"Invalid cluster `{0!r}`.\", reraise=True))\n-\n-        interactions = self.interactions[[SOURCE, TARGET]]\n-\n-        _clusters = list({c for cs in clusters for c in cs})\n-        data = self._filtered_data.loc[np.isin(self._filtered_data[\"clusters\"], _clusters), :]\n+            clusters = list(map(str, self._adata.obs[cluster_key].cat.categories))\n+        if all(isinstance(c, str) for c in clusters):\n+            clusters = list(product(clusters, repeat=2))  # type: ignore[no-redef,assignment]\n+        clusters = sorted(\n+            _check_tuple_needles(\n+                clusters,  # type: ignore[arg-type]\n+                self._filtered_data[\"clusters\"].cat.categories,\n+                msg=\"Invalid cluster `{0!r}`.\",\n+                reraise=True,\n+            )\n+        )\n+        clusters_flat = list({c for cs in clusters for c in cs})\n+\n+        data = self._filtered_data.loc[np.isin(self._filtered_data[\"clusters\"], clusters_flat), :]\n         data[\"clusters\"].cat.remove_unused_categories(inplace=True)\n",
        "source_code_with_indent": "            )\n\n        <DED>if clusters is None:\n            <IND>clusters = sorted(map(str, self._adata.obs[cluster_key].cat.categories))\n\n        <DED>self._filtered_data[\"clusters\"] = self._adata.obs[cluster_key].astype(\"string\").astype(\"category\").values\n        cluster_cats = self._filtered_data[\"clusters\"].cat.categories\n\n        if all(map(lambda c: isinstance(c, str), clusters)):\n            <IND>clusters = product(clusters, repeat=2)\n        <DED>clusters = sorted(_check_tuple_needles(clusters, cluster_cats, msg=\"Invalid cluster `{0!r}`.\", reraise=True))\n\n        interactions = self.interactions[[SOURCE, TARGET]]\n\n        _clusters = list({c for cs in clusters for c in cs})\n        data = self._filtered_data.loc[np.isin(self._filtered_data[\"clusters\"], _clusters), :]\n        data[\"clusters\"].cat.remove_unused_categories(inplace=True)\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "            )\n        <DED>if TYPE_CHECKING:\n            <IND>assert isinstance(self.interactions, pd.DataFrame)\n            assert isinstance(self._filtered_data, pd.DataFrame)\n\n        <DED>interactions = self.interactions[[SOURCE, TARGET]]\n        self._filtered_data[\"clusters\"] = self._adata.obs[cluster_key].astype(\"string\").astype(\"category\").values\n\n        if clusters is None:\n            <IND>clusters = list(map(str, self._adata.obs[cluster_key].cat.categories))\n        <DED>if all(isinstance(c, str) for c in clusters):\n            <IND>clusters = list(product(clusters, repeat=2))  # type: ignore[no-redef,assignment]\n        <DED>clusters = sorted(\n            _check_tuple_needles(\n                clusters,  # type: ignore[arg-type]\n                self._filtered_data[\"clusters\"].cat.categories,\n                msg=\"Invalid cluster `{0!r}`.\",\n                reraise=True,\n            )\n        )\n        clusters_flat = list({c for cs in clusters for c in cs})\n\n        data = self._filtered_data.loc[np.isin(self._filtered_data[\"clusters\"], clusters_flat), :]\n        data[\"clusters\"].cat.remove_unused_categories(inplace=True)\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "theislab/squidpy",
    "commit": "0a9fd7e4a3747db318e65a0a9fd3a31e87c06eed",
    "filename": "squidpy/gr/_ligrec.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/theislab-squidpy/squidpy/gr/_ligrec.py",
    "file_hunks_size": 42,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "squidpy/gr/_ligrec.py:704:8 Incompatible parameter type [6]: Expected `int` for 3rd parameter `n_jobs` to call `parallelize` but got `Optional[int]`.",
    "message": " Expected `int` for 3rd parameter `n_jobs` to call `parallelize` but got `Optional[int]`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 704,
    "warning_line": "        n_jobs=n_jobs,",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    seed: Optional[int] = None,\n    n_jobs: Optional[int] = None,\n    numba_parallel: Optional[bool] = None,\n    **kwargs,\n) -> TempResult:\n",
        "source_code_len": 140,
        "target_code": "    seed: Optional[int] = None,\n    n_jobs: int = 1,\n    numba_parallel: Optional[bool] = None,\n    **kwargs: Any,\n) -> TempResult:\n",
        "target_code_len": 132,
        "diff_format": "@@ -641,5 +665,5 @@\n     seed: Optional[int] = None,\n-    n_jobs: Optional[int] = None,\n+    n_jobs: int = 1,\n     numba_parallel: Optional[bool] = None,\n-    **kwargs,\n+    **kwargs: Any,\n ) -> TempResult:\n",
        "source_code_with_indent": "    seed: Optional[int] = None,\n    n_jobs: Optional[int] = None,\n    numba_parallel: Optional[bool] = None,\n    **kwargs,\n) -> TempResult:\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    seed: Optional[int] = None,\n    n_jobs: int = 1,\n    numba_parallel: Optional[bool] = None,\n    **kwargs: Any,\n) -> TempResult:\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "theislab/squidpy",
    "commit": "0a9fd7e4a3747db318e65a0a9fd3a31e87c06eed",
    "filename": "squidpy/im/crop.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/theislab-squidpy/squidpy/im/crop.py",
    "file_hunks_size": 2,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": true,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "squidpy/im/crop.py:80:4 Incompatible variable type [9]: channel_id is declared to have type `str` but is used as type `None`.",
    "message": " channel_id is declared to have type `str` but is used as type `None`.",
    "rule_id": "Incompatible variable type [9]",
    "warning_line_no": 80,
    "warning_line": "    channel_id: str = None,",
    "min_patch": [
      {
        "hunk_fit_TFix": true,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    y: int,\n    channel_id: str = None,\n    xs: int = 100,  # TODO: are these defaults reasonable or should no defaults be specified?\n",
        "source_code_len": 134,
        "target_code": "    y: int,\n    channel_id: Optional[str] = None,\n    xs: int = 100,  # TODO: are these defaults reasonable or should no defaults be specified?\n",
        "target_code_len": 144,
        "diff_format": "@@ -79,3 +79,3 @@\n     y: int,\n-    channel_id: str = None,\n+    channel_id: Optional[str] = None,\n     xs: int = 100,  # TODO: are these defaults reasonable or should no defaults be specified?\n",
        "source_code_with_indent": "    y: int,\n    channel_id: str = None,\n    xs: int = 100,  # TODO: are these defaults reasonable or should no defaults be specified?\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    y: int,\n    channel_id: Optional[str] = None,\n    xs: int = 100,  # TODO: are these defaults reasonable or should no defaults be specified?\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "theislab/squidpy",
    "commit": "0a9fd7e4a3747db318e65a0a9fd3a31e87c06eed",
    "filename": "squidpy/im/object.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/theislab-squidpy/squidpy/im/object.py",
    "file_hunks_size": 12,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "squidpy/im/object.py:51:12 Incompatible variable type [9]: chunks is declared to have type `Optional[int]` but is used as type `typing.Dict[str, int]`.",
    "message": " chunks is declared to have type `Optional[int]` but is used as type `typing.Dict[str, int]`.",
    "rule_id": "Incompatible variable type [9]",
    "warning_line_no": 51,
    "warning_line": "            chunks = {\"x\": chunks, \"y\": chunks}",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "        chunks: Optional[int] = None,\n        **kwargs,\n    ):\n        if chunks is not None:\n            chunks = {\"x\": chunks, \"y\": chunks}\n        self._chunks = chunks\n        self._lazy = lazy\n        self.data = xr.Dataset()\n        if img is not None:\n",
        "source_code_len": 259,
        "target_code": "        chunks: Optional[int] = None,\n        **kwargs: Any,\n    ):\n        self._chunks = None if chunks is None else {\"x\": chunks, \"y\": chunks}\n        self._lazy = lazy\n        self.data: xr.Dataset = xr.Dataset()\n        if img is not None:\n",
        "target_code_len": 245,
        "diff_format": "@@ -47,9 +45,7 @@\n         chunks: Optional[int] = None,\n-        **kwargs,\n+        **kwargs: Any,\n     ):\n-        if chunks is not None:\n-            chunks = {\"x\": chunks, \"y\": chunks}\n-        self._chunks = chunks\n+        self._chunks = None if chunks is None else {\"x\": chunks, \"y\": chunks}\n         self._lazy = lazy\n-        self.data = xr.Dataset()\n+        self.data: xr.Dataset = xr.Dataset()\n         if img is not None:\n",
        "source_code_with_indent": "        chunks: Optional[int] = None,\n        **kwargs,\n    ):\n        <IND>if chunks is not None:\n            <IND>chunks = {\"x\": chunks, \"y\": chunks}\n        <DED>self._chunks = chunks\n        self._lazy = lazy\n        self.data = xr.Dataset()\n        if img is not None:\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "        chunks: Optional[int] = None,\n        **kwargs: Any,\n    ):\n        <IND>self._chunks = None if chunks is None else {\"x\": chunks, \"y\": chunks}\n        self._lazy = lazy\n        self.data: xr.Dataset = xr.Dataset()\n        if img is not None:\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "theislab/squidpy",
    "commit": "0a9fd7e4a3747db318e65a0a9fd3a31e87c06eed",
    "filename": "tests/conftest.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/theislab-squidpy/tests/conftest.py",
    "file_hunks_size": 2,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": true,
    "full_warning_msg": "tests/conftest.py:88:4 Incompatible return type [7]: Expected `Tuple[Sequence[str], Sequence[str]]` but got `typing.Tuple[typing.Any, ...]`.",
    "message": " Expected `Tuple[Sequence[str], Sequence[str]]` but got `typing.Tuple[typing.Any, ...]`.",
    "rule_id": "Incompatible return type [7]",
    "warning_line_no": 88,
    "warning_line": "    return tuple(product(adata.raw.var_names[:5], adata.raw.var_names[:5]))",
    "min_patch": [
      {
        "hunk_fit_TFix": true,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": true,
        "source_code": "def interactions(adata: AnnData) -> Tuple[Sequence[str], Sequence[str]]:\n    return tuple(product(adata.raw.var_names[:5], adata.raw.var_names[:5]))\n\n",
        "source_code_len": 150,
        "target_code": "def interactions(adata: AnnData) -> Tuple[Sequence[str], Sequence[str]]:\n    return tuple(product(adata.raw.var_names[:5], adata.raw.var_names[:5]))  # type: ignore\n\n",
        "target_code_len": 166,
        "diff_format": "@@ -87,3 +86,3 @@\n def interactions(adata: AnnData) -> Tuple[Sequence[str], Sequence[str]]:\n-    return tuple(product(adata.raw.var_names[:5], adata.raw.var_names[:5]))\n+    return tuple(product(adata.raw.var_names[:5], adata.raw.var_names[:5]))  # type: ignore\n \n",
        "source_code_with_indent": "def interactions(adata: AnnData) -> Tuple[Sequence[str], Sequence[str]]:\n    <IND>return tuple(product(adata.raw.var_names[:5], adata.raw.var_names[:5]))\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "def interactions(adata: AnnData) -> Tuple[Sequence[str], Sequence[str]]:\n    <IND>return tuple(product(adata.raw.var_names[:5], adata.raw.var_names[:5]))  # type: ignore\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "theislab/squidpy",
    "commit": "0a9fd7e4a3747db318e65a0a9fd3a31e87c06eed",
    "filename": "tests/tests_graph/test_ligrec.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/theislab-squidpy/tests/tests_graph/test_ligrec.py",
    "file_hunks_size": 7,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": true,
    "full_warning_msg": "tests/tests_graph/test_ligrec.py:85:8 Incompatible variable type [9]: interactions is declared to have type `Tuple[Sequence[str], Sequence[str]]` but is used as type `typing.Tuple[typing.Union[str, str], ...]`.",
    "message": " interactions is declared to have type `Tuple[Sequence[str], Sequence[str]]` but is used as type `typing.Tuple[typing.Union[str, str], ...]`.",
    "rule_id": "Incompatible variable type [9]",
    "warning_line_no": 85,
    "warning_line": "        interactions += (\"foo\", \"bar\", \"bar\")",
    "min_patch": [
      {
        "hunk_fit_TFix": true,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": true,
        "source_code": "    def test_interactions_invalid_sequence(self, adata: AnnData, interactions: Interactions_t):\n        interactions += (\"foo\", \"bar\", \"bar\")\n        with pytest.raises(ValueError, match=r\"Not all interactions are of length `2`.\"):\n",
        "source_code_len": 232,
        "target_code": "    def test_interactions_invalid_sequence(self, adata: AnnData, interactions: Interactions_t):\n        interactions += (\"foo\", \"bar\", \"bar\")  # type: ignore\n        with pytest.raises(ValueError, match=r\"Not all interactions are of length `2`.\"):\n",
        "target_code_len": 248,
        "diff_format": "@@ -84,3 +83,3 @@\n     def test_interactions_invalid_sequence(self, adata: AnnData, interactions: Interactions_t):\n-        interactions += (\"foo\", \"bar\", \"bar\")\n+        interactions += (\"foo\", \"bar\", \"bar\")  # type: ignore\n         with pytest.raises(ValueError, match=r\"Not all interactions are of length `2`.\"):\n",
        "source_code_with_indent": "    <DED><DED>def test_interactions_invalid_sequence(self, adata: AnnData, interactions: Interactions_t):\n        <IND>interactions += (\"foo\", \"bar\", \"bar\")\n        with pytest.raises(ValueError, match=r\"Not all interactions are of length `2`.\"):\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    <DED><DED>def test_interactions_invalid_sequence(self, adata: AnnData, interactions: Interactions_t):\n        <IND>interactions += (\"foo\", \"bar\", \"bar\")  # type: ignore\n        with pytest.raises(ValueError, match=r\"Not all interactions are of length `2`.\"):\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "theislab/squidpy",
    "commit": "0a9fd7e4a3747db318e65a0a9fd3a31e87c06eed",
    "filename": "tests/tests_graph/test_ligrec.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/theislab-squidpy/tests/tests_graph/test_ligrec.py",
    "file_hunks_size": 7,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": true,
    "full_warning_msg": "tests/tests_graph/test_ligrec.py:393:8 Incompatible variable type [9]: interactions is declared to have type `Tuple[Sequence[str], Sequence[str]]` but is used as type `typing.Tuple[Tuple[str, str], ...]`.",
    "message": " interactions is declared to have type `Tuple[Sequence[str], Sequence[str]]` but is used as type `typing.Tuple[Tuple[str, str], ...]`.",
    "rule_id": "Incompatible variable type [9]",
    "warning_line_no": 393,
    "warning_line": "        interactions += (",
    "min_patch": [
      {
        "hunk_fit_TFix": true,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": true,
        "source_code": "        expected = {(r.upper(), l.upper()) for r, l in interactions}\n        interactions += (\n            (f\"{interactions[-1][0]}_{interactions[-1][1]}\", f\"{interactions[-2][0]}_{interactions[-2][1]}\"),\n        ) * 2\n        interactions += interactions[:3]\n        res = ligrec(\n",
        "source_code_len": 282,
        "target_code": "        expected = {(r.upper(), l.upper()) for r, l in interactions}\n        interactions += (  # type: ignore\n            (f\"{interactions[-1][0]}_{interactions[-1][1]}\", f\"{interactions[-2][0]}_{interactions[-2][1]}\"),\n        ) * 2\n        interactions += interactions[:3]  # type: ignore\n        res = ligrec(\n",
        "target_code_len": 314,
        "diff_format": "@@ -392,6 +395,6 @@\n         expected = {(r.upper(), l.upper()) for r, l in interactions}\n-        interactions += (\n+        interactions += (  # type: ignore\n             (f\"{interactions[-1][0]}_{interactions[-1][1]}\", f\"{interactions[-2][0]}_{interactions[-2][1]}\"),\n         ) * 2\n-        interactions += interactions[:3]\n+        interactions += interactions[:3]  # type: ignore\n         res = ligrec(\n",
        "source_code_with_indent": "        <IND>expected = {(r.upper(), l.upper()) for r, l in interactions}\n        interactions += (\n            (f\"{interactions[-1][0]}_{interactions[-1][1]}\", f\"{interactions[-2][0]}_{interactions[-2][1]}\"),\n        ) * 2\n        interactions += interactions[:3]\n        res = ligrec(\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "        <IND>expected = {(r.upper(), l.upper()) for r, l in interactions}\n        interactions += (  # type: ignore\n            (f\"{interactions[-1][0]}_{interactions[-1][1]}\", f\"{interactions[-2][0]}_{interactions[-2][1]}\"),\n        ) * 2\n        interactions += interactions[:3]  # type: ignore\n        res = ligrec(\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "theislab/squidpy",
    "commit": "0a9fd7e4a3747db318e65a0a9fd3a31e87c06eed",
    "filename": "tests/tests_graph/test_ligrec.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/theislab-squidpy/tests/tests_graph/test_ligrec.py",
    "file_hunks_size": 7,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": true,
    "full_warning_msg": "tests/tests_graph/test_ligrec.py:396:8 Incompatible variable type [9]: interactions is declared to have type `Tuple[Sequence[str], Sequence[str]]` but is used as type `typing.Tuple[Sequence[str], ...]`.",
    "message": " interactions is declared to have type `Tuple[Sequence[str], Sequence[str]]` but is used as type `typing.Tuple[Sequence[str], ...]`.",
    "rule_id": "Incompatible variable type [9]",
    "warning_line_no": 396,
    "warning_line": "        interactions += interactions[:3]",
    "min_patch": [
      {
        "hunk_fit_TFix": true,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": true,
        "source_code": "        expected = {(r.upper(), l.upper()) for r, l in interactions}\n        interactions += (\n            (f\"{interactions[-1][0]}_{interactions[-1][1]}\", f\"{interactions[-2][0]}_{interactions[-2][1]}\"),\n        ) * 2\n        interactions += interactions[:3]\n        res = ligrec(\n",
        "source_code_len": 282,
        "target_code": "        expected = {(r.upper(), l.upper()) for r, l in interactions}\n        interactions += (  # type: ignore\n            (f\"{interactions[-1][0]}_{interactions[-1][1]}\", f\"{interactions[-2][0]}_{interactions[-2][1]}\"),\n        ) * 2\n        interactions += interactions[:3]  # type: ignore\n        res = ligrec(\n",
        "target_code_len": 314,
        "diff_format": "@@ -392,6 +395,6 @@\n         expected = {(r.upper(), l.upper()) for r, l in interactions}\n-        interactions += (\n+        interactions += (  # type: ignore\n             (f\"{interactions[-1][0]}_{interactions[-1][1]}\", f\"{interactions[-2][0]}_{interactions[-2][1]}\"),\n         ) * 2\n-        interactions += interactions[:3]\n+        interactions += interactions[:3]  # type: ignore\n         res = ligrec(\n",
        "source_code_with_indent": "        <IND>expected = {(r.upper(), l.upper()) for r, l in interactions}\n        interactions += (\n            (f\"{interactions[-1][0]}_{interactions[-1][1]}\", f\"{interactions[-2][0]}_{interactions[-2][1]}\"),\n        ) * 2\n        interactions += interactions[:3]\n        res = ligrec(\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "        <IND>expected = {(r.upper(), l.upper()) for r, l in interactions}\n        interactions += (  # type: ignore\n            (f\"{interactions[-1][0]}_{interactions[-1][1]}\", f\"{interactions[-2][0]}_{interactions[-2][1]}\"),\n        ) * 2\n        interactions += interactions[:3]  # type: ignore\n        res = ligrec(\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  }
]