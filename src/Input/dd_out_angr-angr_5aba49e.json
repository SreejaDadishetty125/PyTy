[
  {
    "project": "angr/angr",
    "commit": "5aba49e92c98909aa99590bfc62a2643817bcf6a",
    "filename": "tests/test_memview.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/angr-angr/tests/test_memview.py",
    "file_hunks_size": 4,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "tests/test_memview.py:109:4 Unbound name [10]: Name `test_struct` is used but not defined in the current scope.",
    "message": " Name `test_struct` is used but not defined in the current scope.",
    "rule_id": "Unbound name [10]",
    "warning_line_no": 109,
    "warning_line": "    test_struct()",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n\n",
        "source_code_len": 2,
        "target_code": "\ndef test_struct_bitfield_simple():\n    \"\"\"\n    Tests if a struct with bitfields like\n    struct {\n        uint32_t a:8, b:1, c:23;\n    }\n    can be used with a memview\n    :return:\n    \"\"\"\n    state = SimState(arch='AMD64')\n    register_types(SimStruct(name=\"bitfield_struct\", pack=True, fields=OrderedDict([\n        (\"a\", SimTypeNumOffset(8, signed=False)),\n        (\"b\", SimTypeNumOffset(1, signed=False)),\n        (\"c\", SimTypeNumOffset(23, signed=False))\n    ])))\n\n    data = [\n        (b'\\x0e\\x02\\x00\\x00', (14, 0, 1)),\n        (b'\\x14T\\x00\\x00', (20, 0, 42)),\n        (b'\\x04\\n\\x01\\x00', (4, 0, 133)),\n        (b'\\x04j\\x01\\x00', (4, 0, 181)),\n        (b'\\x04\\xa2\\x01\\x00', (4, 0, 209)),\n        (b'\\x04\\xf4\\x01\\x00', (4, 0, 250)),\n        (b'\\x04\\\\\\x02\\x00', (4, 0, 302)),\n        (b'\\x04\\x98\\x02\\x00', (4, 0, 332)),\n        (b'\\x04\\xe0\\x02\\x00', (4, 0, 368)),\n        (b'\\x04\\x1e\\x03\\x00', (4, 0, 399)),\n    ]\n    state.memory.store(0x8000,\n                       b'\\x0e\\x02\\x00\\x00'\n                       b'\\x14T\\x00\\x00'\n                       b'\\x04\\n\\x01\\x00'\n                       b'\\x04j\\x01\\x00'\n                       b'\\x04\\xa2\\x01\\x00'\n                       b'\\x04\\xf4\\x01\\x00'\n                       b'\\x04\\\\\\x02\\x00'\n                       b'\\x04\\x98\\x02\\x00'\n                       b'\\x04\\xe0\\x02\\x00'\n                       b'\\x04\\x1e\\x03\\x00'\n                       )\n    view = state.mem[0x8000].struct.bitfield_struct.array(5)\n    for (idx, (b, result)) in enumerate(data):\n        v = view[idx]\n        s = v.concrete\n        nose.tools.assert_equal(s.a, result[0], msg=f\"Field a was {s.a}, expected {result[0]}, from bytes {b}\")\n        nose.tools.assert_equal(v.a.concrete, result[0], msg=f\"Field a was {v.a.concrete}, expected {result[0]}, from bytes {b}\")\n\n        nose.tools.assert_equal(s.b, result[1], msg=f\"Field b was {s.b}, expected {result[1]}, from bytes {b}\")\n        nose.tools.assert_equal(v.b.concrete, result[1], msg=f\"Field b was {s.b}, expected {result[1]}, from bytes {b}\")\n\n        nose.tools.assert_equal(s.c, result[2], msg=f\"Field c was {s.c}, expected {result[2]}, from bytes {b}\")\n        nose.tools.assert_equal(v.c.concrete, result[2], msg=f\"Field c was {v.c.concrete}, expected {result[2]}, from bytes {b}\")\n\ndef test_struct_bitfield_complex():\n    bitfield_struct2 = angr.types.parse_type(\"\"\"struct bitfield_struct2\n    {\n        uint64_t    target    : 36,    \n                    high8     :  8,   \n                    reserved  :  7,\n                    next      : 12,\n                    bind      :  1;\n    }\"\"\")\n\n    angr.types.register_types(bitfield_struct2)\n    state = SimState(arch='AMD64')\n    state.memory.store(0x1000, b'\\xb3\\xc7\\xe9|\\xad\\xd7\\xee$') # store some random data\n    struct = state.mem[0x1000].struct.bitfield_struct2.concrete\n    nose.tools.assert_equal(struct.target, 0xD7CE9C7B3)\n    nose.tools.assert_equal(struct.high8, 0x7A)\n    nose.tools.assert_equal(struct.next, 0x49D)\n    nose.tools.assert_equal(struct.bind, 0)\n    pass\n\n",
        "target_code_len": 3019,
        "diff_format": "@@ -102,2 +106,74 @@\n \n+def test_struct_bitfield_simple():\n+    \"\"\"\n+    Tests if a struct with bitfields like\n+    struct {\n+        uint32_t a:8, b:1, c:23;\n+    }\n+    can be used with a memview\n+    :return:\n+    \"\"\"\n+    state = SimState(arch='AMD64')\n+    register_types(SimStruct(name=\"bitfield_struct\", pack=True, fields=OrderedDict([\n+        (\"a\", SimTypeNumOffset(8, signed=False)),\n+        (\"b\", SimTypeNumOffset(1, signed=False)),\n+        (\"c\", SimTypeNumOffset(23, signed=False))\n+    ])))\n+\n+    data = [\n+        (b'\\x0e\\x02\\x00\\x00', (14, 0, 1)),\n+        (b'\\x14T\\x00\\x00', (20, 0, 42)),\n+        (b'\\x04\\n\\x01\\x00', (4, 0, 133)),\n+        (b'\\x04j\\x01\\x00', (4, 0, 181)),\n+        (b'\\x04\\xa2\\x01\\x00', (4, 0, 209)),\n+        (b'\\x04\\xf4\\x01\\x00', (4, 0, 250)),\n+        (b'\\x04\\\\\\x02\\x00', (4, 0, 302)),\n+        (b'\\x04\\x98\\x02\\x00', (4, 0, 332)),\n+        (b'\\x04\\xe0\\x02\\x00', (4, 0, 368)),\n+        (b'\\x04\\x1e\\x03\\x00', (4, 0, 399)),\n+    ]\n+    state.memory.store(0x8000,\n+                       b'\\x0e\\x02\\x00\\x00'\n+                       b'\\x14T\\x00\\x00'\n+                       b'\\x04\\n\\x01\\x00'\n+                       b'\\x04j\\x01\\x00'\n+                       b'\\x04\\xa2\\x01\\x00'\n+                       b'\\x04\\xf4\\x01\\x00'\n+                       b'\\x04\\\\\\x02\\x00'\n+                       b'\\x04\\x98\\x02\\x00'\n+                       b'\\x04\\xe0\\x02\\x00'\n+                       b'\\x04\\x1e\\x03\\x00'\n+                       )\n+    view = state.mem[0x8000].struct.bitfield_struct.array(5)\n+    for (idx, (b, result)) in enumerate(data):\n+        v = view[idx]\n+        s = v.concrete\n+        nose.tools.assert_equal(s.a, result[0], msg=f\"Field a was {s.a}, expected {result[0]}, from bytes {b}\")\n+        nose.tools.assert_equal(v.a.concrete, result[0], msg=f\"Field a was {v.a.concrete}, expected {result[0]}, from bytes {b}\")\n+\n+        nose.tools.assert_equal(s.b, result[1], msg=f\"Field b was {s.b}, expected {result[1]}, from bytes {b}\")\n+        nose.tools.assert_equal(v.b.concrete, result[1], msg=f\"Field b was {s.b}, expected {result[1]}, from bytes {b}\")\n+\n+        nose.tools.assert_equal(s.c, result[2], msg=f\"Field c was {s.c}, expected {result[2]}, from bytes {b}\")\n+        nose.tools.assert_equal(v.c.concrete, result[2], msg=f\"Field c was {v.c.concrete}, expected {result[2]}, from bytes {b}\")\n+\n+def test_struct_bitfield_complex():\n+    bitfield_struct2 = angr.types.parse_type(\"\"\"struct bitfield_struct2\n+    {\n+        uint64_t    target    : 36,    \n+                    high8     :  8,   \n+                    reserved  :  7,\n+                    next      : 12,\n+                    bind      :  1;\n+    }\"\"\")\n+\n+    angr.types.register_types(bitfield_struct2)\n+    state = SimState(arch='AMD64')\n+    state.memory.store(0x1000, b'\\xb3\\xc7\\xe9|\\xad\\xd7\\xee$') # store some random data\n+    struct = state.mem[0x1000].struct.bitfield_struct2.concrete\n+    nose.tools.assert_equal(struct.target, 0xD7CE9C7B3)\n+    nose.tools.assert_equal(struct.high8, 0x7A)\n+    nose.tools.assert_equal(struct.next, 0x49D)\n+    nose.tools.assert_equal(struct.bind, 0)\n+    pass\n \n",
        "source_code_with_indent": "\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n<DED>def test_struct_bitfield_simple():\n    <IND>\"\"\"\n    Tests if a struct with bitfields like\n    struct {\n        uint32_t a:8, b:1, c:23;\n    }\n    can be used with a memview\n    :return:\n    \"\"\"\n    state = SimState(arch='AMD64')\n    register_types(SimStruct(name=\"bitfield_struct\", pack=True, fields=OrderedDict([\n        (\"a\", SimTypeNumOffset(8, signed=False)),\n        (\"b\", SimTypeNumOffset(1, signed=False)),\n        (\"c\", SimTypeNumOffset(23, signed=False))\n    ])))\n\n    data = [\n        (b'\\x0e\\x02\\x00\\x00', (14, 0, 1)),\n        (b'\\x14T\\x00\\x00', (20, 0, 42)),\n        (b'\\x04\\n\\x01\\x00', (4, 0, 133)),\n        (b'\\x04j\\x01\\x00', (4, 0, 181)),\n        (b'\\x04\\xa2\\x01\\x00', (4, 0, 209)),\n        (b'\\x04\\xf4\\x01\\x00', (4, 0, 250)),\n        (b'\\x04\\\\\\x02\\x00', (4, 0, 302)),\n        (b'\\x04\\x98\\x02\\x00', (4, 0, 332)),\n        (b'\\x04\\xe0\\x02\\x00', (4, 0, 368)),\n        (b'\\x04\\x1e\\x03\\x00', (4, 0, 399)),\n    ]\n    state.memory.store(0x8000,\n                       b'\\x0e\\x02\\x00\\x00'\n                       b'\\x14T\\x00\\x00'\n                       b'\\x04\\n\\x01\\x00'\n                       b'\\x04j\\x01\\x00'\n                       b'\\x04\\xa2\\x01\\x00'\n                       b'\\x04\\xf4\\x01\\x00'\n                       b'\\x04\\\\\\x02\\x00'\n                       b'\\x04\\x98\\x02\\x00'\n                       b'\\x04\\xe0\\x02\\x00'\n                       b'\\x04\\x1e\\x03\\x00'\n                       )\n    view = state.mem[0x8000].struct.bitfield_struct.array(5)\n    for (idx, (b, result)) in enumerate(data):\n        <IND>v = view[idx]\n        s = v.concrete\n        nose.tools.assert_equal(s.a, result[0], msg=f\"Field a was {s.a}, expected {result[0]}, from bytes {b}\")\n        nose.tools.assert_equal(v.a.concrete, result[0], msg=f\"Field a was {v.a.concrete}, expected {result[0]}, from bytes {b}\")\n\n        nose.tools.assert_equal(s.b, result[1], msg=f\"Field b was {s.b}, expected {result[1]}, from bytes {b}\")\n        nose.tools.assert_equal(v.b.concrete, result[1], msg=f\"Field b was {s.b}, expected {result[1]}, from bytes {b}\")\n\n        nose.tools.assert_equal(s.c, result[2], msg=f\"Field c was {s.c}, expected {result[2]}, from bytes {b}\")\n        nose.tools.assert_equal(v.c.concrete, result[2], msg=f\"Field c was {v.c.concrete}, expected {result[2]}, from bytes {b}\")\n\n<DED><DED>def test_struct_bitfield_complex():\n    <IND>bitfield_struct2 = angr.types.parse_type(\"\"\"struct bitfield_struct2\n    {\n        uint64_t    target    : 36,    \n                    high8     :  8,   \n                    reserved  :  7,\n                    next      : 12,\n                    bind      :  1;\n    }\"\"\")\n\n    angr.types.register_types(bitfield_struct2)\n    state = SimState(arch='AMD64')\n    state.memory.store(0x1000, b'\\xb3\\xc7\\xe9|\\xad\\xd7\\xee$') # store some random data\n    struct = state.mem[0x1000].struct.bitfield_struct2.concrete\n    nose.tools.assert_equal(struct.target, 0xD7CE9C7B3)\n    nose.tools.assert_equal(struct.high8, 0x7A)\n    nose.tools.assert_equal(struct.next, 0x49D)\n    nose.tools.assert_equal(struct.bind, 0)\n    pass\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": true,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    test_pointer_concrete()\n    test_struct()\n",
        "source_code_len": 46,
        "target_code": "    test_pointer_concrete()\n    test_structs()\n    test_struct_bitfield_simple()\n    test_struct_bitfield_complex()\n",
        "target_code_len": 116,
        "diff_format": "@@ -108,2 +184,4 @@\n     test_pointer_concrete()\n-    test_struct()\n+    test_structs()\n+    test_struct_bitfield_simple()\n+    test_struct_bitfield_complex()\n",
        "source_code_with_indent": "    test_pointer_concrete()\n    test_struct()\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    test_pointer_concrete()\n    test_structs()\n    test_struct_bitfield_simple()\n    test_struct_bitfield_complex()\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  }
]