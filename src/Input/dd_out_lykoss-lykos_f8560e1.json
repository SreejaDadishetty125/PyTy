[
  {
    "project": "lykoss/lykos",
    "commit": "f8560e10e9e8cc4b4a3b8e750865c4079f7c9b37",
    "filename": "src/channels.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/lykoss-lykos/src/channels.py",
    "file_hunks_size": 2,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "src/channels.py:15:0 Incompatible variable type [9]: _channels is declared to have type `src.debug.dict.CheckedDict[]` but is used as type `src.debug.dict.CheckedDict`.",
    "message": " _channels is declared to have type `src.debug.dict.CheckedDict[]` but is used as type `src.debug.dict.CheckedDict`.",
    "rule_id": "Incompatible variable type [9]",
    "warning_line_no": 15,
    "warning_line": "_channels = CheckedDict(\"channels._channels\") # type: CheckedDict[str, Channel]"
  },
  {
    "project": "lykoss/lykos",
    "commit": "f8560e10e9e8cc4b4a3b8e750865c4079f7c9b37",
    "filename": "src/context.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/lykoss-lykos/src/context.py",
    "file_hunks_size": 6,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": true,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "src/context.py:321:8 Incompatible return type [7]: Expected `Tuple[str, str, str, str]` but got `typing.Tuple[typing.Any, ...]`.",
    "message": " Expected `Tuple[str, str, str, str]` but got `typing.Tuple[typing.Any, ...]`.",
    "rule_id": "Incompatible return type [7]",
    "warning_line_no": 321,
    "warning_line": "        return tuple(modes[:4])",
    "min_patch": [
      {
        "hunk_fit_TFix": true,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "            modes.append(\"\")\n        return tuple(modes[:4])\n\n",
        "source_code_len": 62,
        "target_code": "            modes.append(\"\")\n        rA, rB, rC, rD = modes[:4]\n        return (rA, rB, rC, rD)\n\n",
        "target_code_len": 97,
        "diff_format": "@@ -320,3 +323,4 @@\n             modes.append(\"\")\n-        return tuple(modes[:4])\n+        rA, rB, rC, rD = modes[:4]\n+        return (rA, rB, rC, rD)\n \n",
        "source_code_with_indent": "            <IND>modes.append(\"\")\n        <DED>return tuple(modes[:4])\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "            <IND>modes.append(\"\")\n        <DED>rA, rB, rC, rD = modes[:4]\n        return (rA, rB, rC, rD)\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "lykoss/lykos",
    "commit": "f8560e10e9e8cc4b4a3b8e750865c4079f7c9b37",
    "filename": "src/handler.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/lykoss-lykos/src/handler.py",
    "file_hunks_size": 6,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "src/handler.py:178:26 Incompatible parameter type [6]: Expected `int` for 2nd positional only parameter to call `list.__setitem__` but got `str`.",
    "message": " Expected `int` for 2nd positional only parameter to call `list.__setitem__` but got `str`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 178,
    "warning_line": "                info[0] = role_map[role1].replace(\" \", \"\")",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": true,
        "source_code": "import math\nfrom typing import Optional\n\nimport botconfig\nimport src.settings as var\n",
        "source_code_len": 85,
        "target_code": "import math\nfrom typing import List, Optional, Union\n\nimport botconfig  # type: ignore\nimport src.settings as var\n",
        "target_code_len": 114,
        "diff_format": "@@ -11,5 +13,5 @@\n import math\n-from typing import Optional\n-\n-import botconfig\n+from typing import List, Optional, Union\n+\n+import botconfig  # type: ignore\n import src.settings as var\n",
        "source_code_with_indent": "import math\nfrom typing import Optional\n\nimport botconfig\nimport src.settings as var\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "import math\nfrom typing import List, Optional, Union\n\nimport botconfig  # type: ignore\nimport src.settings as var\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "        common_roles = set(roles)\n        info = [0, 0]\n        role_map = messages.get_role_mapping()\n",
        "source_code_len": 103,
        "target_code": "        common_roles = set(roles)\n        info: List[Union[str, int]] = [0, 0]\n        role_map = messages.get_role_mapping()\n",
        "target_code_len": 126,
        "diff_format": "@@ -170,3 +172,3 @@\n         common_roles = set(roles)\n-        info = [0, 0]\n+        info: List[Union[str, int]] = [0, 0]\n         role_map = messages.get_role_mapping()\n",
        "source_code_with_indent": "        <IND>common_roles = set(roles)\n        info = [0, 0]\n        role_map = messages.get_role_mapping()\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "        <IND>common_roles = set(roles)\n        info: List[Union[str, int]] = [0, 0]\n        role_map = messages.get_role_mapping()\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "lykoss/lykos",
    "commit": "f8560e10e9e8cc4b4a3b8e750865c4079f7c9b37",
    "filename": "src/handler.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/lykoss-lykos/src/handler.py",
    "file_hunks_size": 6,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "src/handler.py:181:26 Incompatible parameter type [6]: Expected `int` for 2nd positional only parameter to call `list.__setitem__` but got `str`.",
    "message": " Expected `int` for 2nd positional only parameter to call `list.__setitem__` but got `str`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 181,
    "warning_line": "                info[1] = role_map[role2].replace(\" \", \"\")",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": true,
        "source_code": "import math\nfrom typing import Optional\n\nimport botconfig\nimport src.settings as var\n",
        "source_code_len": 85,
        "target_code": "import math\nfrom typing import List, Optional, Union\n\nimport botconfig  # type: ignore\nimport src.settings as var\n",
        "target_code_len": 114,
        "diff_format": "@@ -11,5 +13,5 @@\n import math\n-from typing import Optional\n-\n-import botconfig\n+from typing import List, Optional, Union\n+\n+import botconfig  # type: ignore\n import src.settings as var\n",
        "source_code_with_indent": "import math\nfrom typing import Optional\n\nimport botconfig\nimport src.settings as var\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "import math\nfrom typing import List, Optional, Union\n\nimport botconfig  # type: ignore\nimport src.settings as var\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "        common_roles = set(roles)\n        info = [0, 0]\n        role_map = messages.get_role_mapping()\n",
        "source_code_len": 103,
        "target_code": "        common_roles = set(roles)\n        info: List[Union[str, int]] = [0, 0]\n        role_map = messages.get_role_mapping()\n",
        "target_code_len": 126,
        "diff_format": "@@ -170,3 +172,3 @@\n         common_roles = set(roles)\n-        info = [0, 0]\n+        info: List[Union[str, int]] = [0, 0]\n         role_map = messages.get_role_mapping()\n",
        "source_code_with_indent": "        <IND>common_roles = set(roles)\n        info = [0, 0]\n        role_map = messages.get_role_mapping()\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "        <IND>common_roles = set(roles)\n        info: List[Union[str, int]] = [0, 0]\n        role_map = messages.get_role_mapping()\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "lykoss/lykos",
    "commit": "f8560e10e9e8cc4b4a3b8e750865c4079f7c9b37",
    "filename": "src/roles/alphawolf.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/lykoss-lykos/src/roles/alphawolf.py",
    "file_hunks_size": 3,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "src/roles/alphawolf.py:17:0 Incompatible variable type [9]: ALPHAS is declared to have type `UserSet[]` but is used as type `UserSet`.",
    "message": " ALPHAS is declared to have type `UserSet[]` but is used as type `UserSet`.",
    "rule_id": "Incompatible variable type [9]",
    "warning_line_no": 17,
    "warning_line": "ALPHAS = UserSet() # type: UserSet[users.User]",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\nregister_wolf(\"alpha wolf\")\n",
        "source_code_len": 29,
        "target_code": "\nif TYPE_CHECKING:\n    from src.users import User\n\nregister_wolf(\"alpha wolf\")\n",
        "target_code_len": 79,
        "diff_format": "@@ -13,2 +16,5 @@\n \n+if TYPE_CHECKING:\n+    from src.users import User\n+\n register_wolf(\"alpha wolf\")\n",
        "source_code_with_indent": "\nregister_wolf(\"alpha wolf\")\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\nif TYPE_CHECKING:\n    <IND>from src.users import User\n\n<DED>register_wolf(\"alpha wolf\")\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": true,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "ENABLED = False\nALPHAS = UserSet() # type: UserSet[users.User]\nBITTEN = UserDict() # type: UserDict[users.User, users.User]\n\n",
        "source_code_len": 125,
        "target_code": "ENABLED = False\nALPHAS = UserSet()\nBITTEN: UserDict[User, User] = UserDict()\n\n",
        "target_code_len": 78,
        "diff_format": "@@ -16,4 +22,4 @@\n ENABLED = False\n-ALPHAS = UserSet() # type: UserSet[users.User]\n-BITTEN = UserDict() # type: UserDict[users.User, users.User]\n+ALPHAS = UserSet()\n+BITTEN: UserDict[User, User] = UserDict()\n \n",
        "source_code_with_indent": "ENABLED = False\nALPHAS = UserSet() # type: UserSet[users.User]\nBITTEN = UserDict() # type: UserDict[users.User, users.User]\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "ENABLED = False\nALPHAS = UserSet()\nBITTEN: UserDict[User, User] = UserDict()\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "lykoss/lykos",
    "commit": "f8560e10e9e8cc4b4a3b8e750865c4079f7c9b37",
    "filename": "src/roles/alphawolf.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/lykoss-lykos/src/roles/alphawolf.py",
    "file_hunks_size": 3,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "src/roles/alphawolf.py:18:0 Incompatible variable type [9]: BITTEN is declared to have type `UserDict[]` but is used as type `UserDict`.",
    "message": " BITTEN is declared to have type `UserDict[]` but is used as type `UserDict`.",
    "rule_id": "Incompatible variable type [9]",
    "warning_line_no": 18,
    "warning_line": "BITTEN = UserDict() # type: UserDict[users.User, users.User]"
  },
  {
    "project": "lykoss/lykos",
    "commit": "f8560e10e9e8cc4b4a3b8e750865c4079f7c9b37",
    "filename": "src/roles/amnesiac.py",
    "min_patch_found": false,
    "full_warning_msg": "src/roles/amnesiac.py:16:0 Incompatible variable type [9]: ROLES is declared to have type `UserDict[]` but is used as type `UserDict`.",
    "exception": "PatchSet should only have 1 Patch, but it has 0",
    "dd_fail": true
  },
  {
    "project": "lykoss/lykos",
    "commit": "f8560e10e9e8cc4b4a3b8e750865c4079f7c9b37",
    "filename": "src/roles/angel.py",
    "min_patch_found": false,
    "full_warning_msg": "src/roles/angel.py:17:0 Incompatible variable type [9]: GUARDED is declared to have type `UserDict[]` but is used as type `UserDict`.",
    "exception": "PatchSet should only have 1 Patch, but it has 0",
    "dd_fail": true
  },
  {
    "project": "lykoss/lykos",
    "commit": "f8560e10e9e8cc4b4a3b8e750865c4079f7c9b37",
    "filename": "src/roles/angel.py",
    "min_patch_found": false,
    "full_warning_msg": "src/roles/angel.py:18:0 Incompatible variable type [9]: LASTGUARDED is declared to have type `UserDict[]` but is used as type `UserDict`.",
    "exception": "PatchSet should only have 1 Patch, but it has 0",
    "dd_fail": true
  },
  {
    "project": "lykoss/lykos",
    "commit": "f8560e10e9e8cc4b4a3b8e750865c4079f7c9b37",
    "filename": "src/roles/assassin.py",
    "min_patch_found": false,
    "full_warning_msg": "src/roles/assassin.py:16:0 Incompatible variable type [9]: TARGETED is declared to have type `UserDict[]` but is used as type `UserDict`.",
    "exception": "PatchSet should only have 1 Patch, but it has 0",
    "dd_fail": true
  },
  {
    "project": "lykoss/lykos",
    "commit": "f8560e10e9e8cc4b4a3b8e750865c4079f7c9b37",
    "filename": "src/roles/bodyguard.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/lykoss-lykos/src/roles/bodyguard.py",
    "file_hunks_size": 4,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "src/roles/bodyguard.py:17:0 Incompatible variable type [9]: GUARDED is declared to have type `UserDict[]` but is used as type `UserDict`.",
    "message": " GUARDED is declared to have type `UserDict[]` but is used as type `UserDict`.",
    "rule_id": "Incompatible variable type [9]",
    "warning_line_no": 17,
    "warning_line": "GUARDED = UserDict() # type: UserDict[users.User, users.User]"
  },
  {
    "project": "lykoss/lykos",
    "commit": "f8560e10e9e8cc4b4a3b8e750865c4079f7c9b37",
    "filename": "src/roles/clone.py",
    "min_patch_found": false,
    "full_warning_msg": "src/roles/clone.py:17:0 Incompatible variable type [9]: CLONED is declared to have type `UserDict[]` but is used as type `UserDict`.",
    "exception": "PatchSet should only have 1 Patch, but it has 0",
    "dd_fail": true
  },
  {
    "project": "lykoss/lykos",
    "commit": "f8560e10e9e8cc4b4a3b8e750865c4079f7c9b37",
    "filename": "src/roles/doctor.py",
    "min_patch_found": false,
    "full_warning_msg": "src/roles/doctor.py:16:0 Incompatible variable type [9]: DOCTORS is declared to have type `UserDict[]` but is used as type `UserDict`.",
    "exception": "PatchSet should only have 1 Patch, but it has 0",
    "dd_fail": true
  },
  {
    "project": "lykoss/lykos",
    "commit": "f8560e10e9e8cc4b4a3b8e750865c4079f7c9b37",
    "filename": "src/roles/doomsayer.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/lykoss-lykos/src/roles/doomsayer.py",
    "file_hunks_size": 3,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "src/roles/doomsayer.py:17:0 Incompatible variable type [9]: LASTSEEN is declared to have type `UserDict[]` but is used as type `UserDict`.",
    "message": " LASTSEEN is declared to have type `UserDict[]` but is used as type `UserDict`.",
    "rule_id": "Incompatible variable type [9]",
    "warning_line_no": 17,
    "warning_line": "LASTSEEN = UserDict() # type: UserDict[users.User, users.User]"
  },
  {
    "project": "lykoss/lykos",
    "commit": "f8560e10e9e8cc4b4a3b8e750865c4079f7c9b37",
    "filename": "src/roles/dullahan.py",
    "min_patch_found": false,
    "full_warning_msg": "src/roles/dullahan.py:15:0 Incompatible variable type [9]: KILLS is declared to have type `UserDict[]` but is used as type `UserDict`.",
    "exception": "PatchSet should only have 1 Patch, but it has 0",
    "dd_fail": true
  },
  {
    "project": "lykoss/lykos",
    "commit": "f8560e10e9e8cc4b4a3b8e750865c4079f7c9b37",
    "filename": "src/roles/dullahan.py",
    "min_patch_found": false,
    "full_warning_msg": "src/roles/dullahan.py:16:0 Incompatible variable type [9]: TARGETS is declared to have type `UserDict[]` but is used as type `UserDict`.",
    "exception": "PatchSet should only have 1 Patch, but it has 0",
    "dd_fail": true
  },
  {
    "project": "lykoss/lykos",
    "commit": "f8560e10e9e8cc4b4a3b8e750865c4079f7c9b37",
    "filename": "src/roles/hag.py",
    "min_patch_found": false,
    "full_warning_msg": "src/roles/hag.py:19:0 Incompatible variable type [9]: HEXED is declared to have type `UserDict[]` but is used as type `UserDict`.",
    "exception": "PatchSet should only have 1 Patch, but it has 0",
    "dd_fail": true
  },
  {
    "project": "lykoss/lykos",
    "commit": "f8560e10e9e8cc4b4a3b8e750865c4079f7c9b37",
    "filename": "src/roles/hag.py",
    "min_patch_found": false,
    "full_warning_msg": "src/roles/hag.py:20:0 Incompatible variable type [9]: LASTHEXED is declared to have type `UserDict[]` but is used as type `UserDict`.",
    "exception": "PatchSet should only have 1 Patch, but it has 0",
    "dd_fail": true
  },
  {
    "project": "lykoss/lykos",
    "commit": "f8560e10e9e8cc4b4a3b8e750865c4079f7c9b37",
    "filename": "src/roles/harlot.py",
    "min_patch_found": false,
    "full_warning_msg": "src/roles/harlot.py:17:0 Incompatible variable type [9]: VISITED is declared to have type `UserDict[]` but is used as type `UserDict`.",
    "exception": "PatchSet should only have 1 Patch, but it has 0",
    "dd_fail": true
  },
  {
    "project": "lykoss/lykos",
    "commit": "f8560e10e9e8cc4b4a3b8e750865c4079f7c9b37",
    "filename": "src/roles/helper/shamans.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/lykoss-lykos/src/roles/helper/shamans.py",
    "file_hunks_size": 1,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "src/roles/helper/shamans.py:61:0 Incompatible variable type [9]: DEATH is declared to have type `UserDict[]` but is used as type `UserDict`.",
    "message": " DEATH is declared to have type `UserDict[]` but is used as type `UserDict`.",
    "rule_id": "Incompatible variable type [9]",
    "warning_line_no": 61,
    "warning_line": "DEATH = UserDict() # type: UserDict[users.User, UserList]"
  },
  {
    "project": "lykoss/lykos",
    "commit": "f8560e10e9e8cc4b4a3b8e750865c4079f7c9b37",
    "filename": "src/roles/helper/wolves.py",
    "min_patch_found": false,
    "full_warning_msg": "src/roles/helper/wolves.py:17:0 Incompatible variable type [9]: KILLS is declared to have type `UserDict[]` but is used as type `UserDict`.",
    "exception": "PatchSet should only have 1 Patch, but it has 0",
    "dd_fail": true
  },
  {
    "project": "lykoss/lykos",
    "commit": "f8560e10e9e8cc4b4a3b8e750865c4079f7c9b37",
    "filename": "src/roles/hunter.py",
    "min_patch_found": false,
    "full_warning_msg": "src/roles/hunter.py:13:0 Incompatible variable type [9]: KILLS is declared to have type `UserDict[]` but is used as type `UserDict`.",
    "exception": "PatchSet should only have 1 Patch, but it has 0",
    "dd_fail": true
  },
  {
    "project": "lykoss/lykos",
    "commit": "f8560e10e9e8cc4b4a3b8e750865c4079f7c9b37",
    "filename": "src/roles/jester.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/lykoss-lykos/src/roles/jester.py",
    "file_hunks_size": 1,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": true,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "src/roles/jester.py:15:0 Incompatible variable type [9]: JESTERS is declared to have type `UserSet[]` but is used as type `UserSet`.",
    "message": " JESTERS is declared to have type `UserSet[]` but is used as type `UserSet`.",
    "rule_id": "Incompatible variable type [9]",
    "warning_line_no": 15,
    "warning_line": "JESTERS = UserSet() # type: UserSet[users.User]",
    "min_patch": [
      {
        "hunk_fit_TFix": true,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\nJESTERS = UserSet() # type: UserSet[users.User]\n\n",
        "source_code_len": 50,
        "target_code": "\nJESTERS = UserSet()\n\n",
        "target_code_len": 22,
        "diff_format": "@@ -14,3 +14,3 @@\n \n-JESTERS = UserSet() # type: UserSet[users.User]\n+JESTERS = UserSet()\n \n",
        "source_code_with_indent": "\nJESTERS = UserSet() # type: UserSet[users.User]\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\nJESTERS = UserSet()\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "lykoss/lykos",
    "commit": "f8560e10e9e8cc4b4a3b8e750865c4079f7c9b37",
    "filename": "src/roles/piper.py",
    "min_patch_found": false,
    "full_warning_msg": "src/roles/piper.py:15:0 Incompatible variable type [9]: TOBECHARMED is declared to have type `UserDict[]` but is used as type `UserDict`.",
    "exception": "PatchSet should only have 1 Patch, but it has 0",
    "dd_fail": true
  },
  {
    "project": "lykoss/lykos",
    "commit": "f8560e10e9e8cc4b4a3b8e750865c4079f7c9b37",
    "filename": "src/roles/sorcerer.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/lykoss-lykos/src/roles/sorcerer.py",
    "file_hunks_size": 1,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": true,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "src/roles/sorcerer.py:19:0 Incompatible variable type [9]: OBSERVED is declared to have type `UserSet[]` but is used as type `UserSet`.",
    "message": " OBSERVED is declared to have type `UserSet[]` but is used as type `UserSet`.",
    "rule_id": "Incompatible variable type [9]",
    "warning_line_no": 19,
    "warning_line": "OBSERVED = UserSet() # type: UserSet[users.User]",
    "min_patch": [
      {
        "hunk_fit_TFix": true,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\nOBSERVED = UserSet() # type: UserSet[users.User]\n\n",
        "source_code_len": 51,
        "target_code": "\nOBSERVED = UserSet()\n\n",
        "target_code_len": 23,
        "diff_format": "@@ -18,3 +18,3 @@\n \n-OBSERVED = UserSet() # type: UserSet[users.User]\n+OBSERVED = UserSet()\n \n",
        "source_code_with_indent": "\nOBSERVED = UserSet() # type: UserSet[users.User]\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\nOBSERVED = UserSet()\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "lykoss/lykos",
    "commit": "f8560e10e9e8cc4b4a3b8e750865c4079f7c9b37",
    "filename": "src/roles/succubus.py",
    "min_patch_found": false,
    "full_warning_msg": "src/roles/succubus.py:17:0 Incompatible variable type [9]: VISITED is declared to have type `UserDict[]` but is used as type `UserDict`.",
    "exception": "PatchSet should only have 1 Patch, but it has 0",
    "dd_fail": true
  },
  {
    "project": "lykoss/lykos",
    "commit": "f8560e10e9e8cc4b4a3b8e750865c4079f7c9b37",
    "filename": "src/roles/turncoat.py",
    "min_patch_found": false,
    "full_warning_msg": "src/roles/turncoat.py:15:0 Incompatible variable type [9]: TURNCOATS is declared to have type `UserDict[]` but is used as type `UserDict`.",
    "exception": "PatchSet should only have 1 Patch, but it has 0",
    "dd_fail": true
  },
  {
    "project": "lykoss/lykos",
    "commit": "f8560e10e9e8cc4b4a3b8e750865c4079f7c9b37",
    "filename": "src/roles/vengefulghost.py",
    "min_patch_found": false,
    "full_warning_msg": "src/roles/vengefulghost.py:14:0 Incompatible variable type [9]: KILLS is declared to have type `UserDict[]` but is used as type `UserDict`.",
    "exception": "PatchSet should only have 1 Patch, but it has 0",
    "dd_fail": true
  },
  {
    "project": "lykoss/lykos",
    "commit": "f8560e10e9e8cc4b4a3b8e750865c4079f7c9b37",
    "filename": "src/roles/vengefulghost.py",
    "min_patch_found": false,
    "full_warning_msg": "src/roles/vengefulghost.py:15:0 Incompatible variable type [9]: GHOSTS is declared to have type `UserDict[]` but is used as type `UserDict`.",
    "exception": "PatchSet should only have 1 Patch, but it has 0",
    "dd_fail": true
  },
  {
    "project": "lykoss/lykos",
    "commit": "f8560e10e9e8cc4b4a3b8e750865c4079f7c9b37",
    "filename": "src/roles/vengefulghost.py",
    "min_patch_found": false,
    "full_warning_msg": "src/roles/vengefulghost.py:18:0 Incompatible variable type [9]: drivenoff is declared to have type `UserDict[]` but is used as type `UserDict`.",
    "exception": "PatchSet should only have 1 Patch, but it has 0",
    "dd_fail": true
  },
  {
    "project": "lykoss/lykos",
    "commit": "f8560e10e9e8cc4b4a3b8e750865c4079f7c9b37",
    "filename": "src/roles/vigilante.py",
    "min_patch_found": false,
    "full_warning_msg": "src/roles/vigilante.py:14:0 Incompatible variable type [9]: KILLS is declared to have type `UserDict[]` but is used as type `UserDict`.",
    "exception": "PatchSet should only have 1 Patch, but it has 0",
    "dd_fail": true
  },
  {
    "project": "lykoss/lykos",
    "commit": "f8560e10e9e8cc4b4a3b8e750865c4079f7c9b37",
    "filename": "src/roles/warlock.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/lykoss-lykos/src/roles/warlock.py",
    "file_hunks_size": 3,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "src/roles/warlock.py:18:0 Incompatible variable type [9]: CURSED is declared to have type `UserDict[]` but is used as type `UserDict`.",
    "message": " CURSED is declared to have type `UserDict[]` but is used as type `UserDict`.",
    "rule_id": "Incompatible variable type [9]",
    "warning_line_no": 18,
    "warning_line": "CURSED = UserDict() # type: UserDict[users.User, users.User]"
  },
  {
    "project": "lykoss/lykos",
    "commit": "f8560e10e9e8cc4b4a3b8e750865c4079f7c9b37",
    "filename": "src/roles/warlock.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/lykoss-lykos/src/roles/warlock.py",
    "file_hunks_size": 3,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "src/roles/warlock.py:19:0 Incompatible variable type [9]: PASSED is declared to have type `UserSet[]` but is used as type `UserSet`.",
    "message": " PASSED is declared to have type `UserSet[]` but is used as type `UserSet`.",
    "rule_id": "Incompatible variable type [9]",
    "warning_line_no": 19,
    "warning_line": "PASSED = UserSet() # type: UserSet[users.Set]"
  },
  {
    "project": "lykoss/lykos",
    "commit": "f8560e10e9e8cc4b4a3b8e750865c4079f7c9b37",
    "filename": "src/roles/werecrow.py",
    "min_patch_found": false,
    "full_warning_msg": "src/roles/werecrow.py:16:0 Incompatible variable type [9]: OBSERVED is declared to have type `UserDict[]` but is used as type `UserDict`.",
    "exception": "PatchSet should only have 1 Patch, but it has 0",
    "dd_fail": true
  },
  {
    "project": "lykoss/lykos",
    "commit": "f8560e10e9e8cc4b4a3b8e750865c4079f7c9b37",
    "filename": "src/status/dying.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/lykoss-lykos/src/status/dying.py",
    "file_hunks_size": 1,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "src/status/dying.py:16:0 Incompatible variable type [9]: DYING is declared to have type `UserDict[]` but is used as type `UserDict`.",
    "message": " DYING is declared to have type `UserDict[]` but is used as type `UserDict`.",
    "rule_id": "Incompatible variable type [9]",
    "warning_line_no": 16,
    "warning_line": "DYING = UserDict() # type: UserDict[User, DyingEntry]"
  },
  {
    "project": "lykoss/lykos",
    "commit": "f8560e10e9e8cc4b4a3b8e750865c4079f7c9b37",
    "filename": "src/status/dying.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/lykoss-lykos/src/status/dying.py",
    "file_hunks_size": 1,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": true,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "src/status/dying.py:70:12 Incompatible return type [7]: Expected `bool` but got `None`.",
    "message": " Expected `bool` but got `None`.",
    "rule_id": "Incompatible return type [7]",
    "warning_line_no": 70,
    "warning_line": "            return",
    "min_patch": [
      {
        "hunk_fit_TFix": true,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "            #  either game ended, or a new game has started\n            return\n\n",
        "source_code_len": 80,
        "target_code": "            #  either game ended, or a new game has started\n            return True  # CHECK BEFORE PULLING: This used to say just \"return\" which appears to have been an actual bug. --GM\n\n",
        "target_code_len": 188,
        "diff_format": "@@ -69,3 +69,3 @@\n             #  either game ended, or a new game has started\n-            return\n+            return True  # CHECK BEFORE PULLING: This used to say just \"return\" which appears to have been an actual bug. --GM\n \n",
        "source_code_with_indent": "            #  either game ended, or a new game has started\n            <IND>return\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "            #  either game ended, or a new game has started\n            <IND>return True  # CHECK BEFORE PULLING: This used to say just \"return\" which appears to have been an actual bug. --GM\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "lykoss/lykos",
    "commit": "f8560e10e9e8cc4b4a3b8e750865c4079f7c9b37",
    "filename": "src/status/forcevote.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/lykoss-lykos/src/status/forcevote.py",
    "file_hunks_size": 10,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "src/status/forcevote.py:19:0 Incompatible variable type [9]: FORCED_COUNTS is declared to have type `UserDict[]` but is used as type `UserDict`.",
    "message": " FORCED_COUNTS is declared to have type `UserDict[]` but is used as type `UserDict`.",
    "rule_id": "Incompatible variable type [9]",
    "warning_line_no": 19,
    "warning_line": "FORCED_COUNTS = UserDict() # type: UserDict[users.User, int]"
  },
  {
    "project": "lykoss/lykos",
    "commit": "f8560e10e9e8cc4b4a3b8e750865c4079f7c9b37",
    "filename": "src/status/forcevote.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/lykoss-lykos/src/status/forcevote.py",
    "file_hunks_size": 10,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "src/status/forcevote.py:20:0 Incompatible variable type [9]: FORCED_TARGETS is declared to have type `UserDict[]` but is used as type `UserDict`.",
    "message": " FORCED_TARGETS is declared to have type `UserDict[]` but is used as type `UserDict`.",
    "rule_id": "Incompatible variable type [9]",
    "warning_line_no": 20,
    "warning_line": "FORCED_TARGETS = UserDict() # type: UserDict[users.User, UserSet]"
  },
  {
    "project": "lykoss/lykos",
    "commit": "f8560e10e9e8cc4b4a3b8e750865c4079f7c9b37",
    "filename": "src/status/forcevote.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/lykoss-lykos/src/status/forcevote.py",
    "file_hunks_size": 10,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "src/status/forcevote.py:33:27 Incompatible parameter type [6]: Expected `users.User` for 3rd positional only parameter to call `_add_count` but got `int`.",
    "message": " Expected `users.User` for 3rd positional only parameter to call `_add_count` but got `int`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 33,
    "warning_line": "    _add_count(var, votee, 1)",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "from src.events import Event\nfrom src import channels, users\n\n",
        "source_code_len": 62,
        "target_code": "from src.events import Event\nfrom src.users import User\nfrom src import channels\n\n",
        "target_code_len": 82,
        "diff_format": "@@ -7,3 +9,4 @@\n from src.events import Event\n-from src import channels, users\n+from src.users import User\n+from src import channels\n \n",
        "source_code_with_indent": "from src.events import Event\nfrom src import channels, users\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "from src.events import Event\nfrom src.users import User\nfrom src import channels\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\nFORCED_COUNTS = UserDict() # type: UserDict[users.User, int]\nFORCED_TARGETS = UserDict() # type: UserDict[users.User, UserSet]\n\ndef _add_count(var, votee : users.User, amount : users.User) -> None:\n    FORCED_COUNTS[votee] = FORCED_COUNTS.get(votee, 0) + amount\n",
        "source_code_len": 263,
        "target_code": "\nFORCED_COUNTS: UserDict[User, int] = UserDict()\nFORCED_TARGETS: UserDict[User, UserSet] = UserDict()\n\ndef _add_count(var, votee : User, amount : int) -> None:\n    FORCED_COUNTS[votee] = FORCED_COUNTS.get(votee, 0) + amount\n",
        "target_code_len": 224,
        "diff_format": "@@ -18,6 +21,6 @@\n \n-FORCED_COUNTS = UserDict() # type: UserDict[users.User, int]\n-FORCED_TARGETS = UserDict() # type: UserDict[users.User, UserSet]\n+FORCED_COUNTS: UserDict[User, int] = UserDict()\n+FORCED_TARGETS: UserDict[User, UserSet] = UserDict()\n \n-def _add_count(var, votee : users.User, amount : users.User) -> None:\n+def _add_count(var, votee : User, amount : int) -> None:\n     FORCED_COUNTS[votee] = FORCED_COUNTS.get(votee, 0) + amount\n",
        "source_code_with_indent": "\nFORCED_COUNTS = UserDict() # type: UserDict[users.User, int]\nFORCED_TARGETS = UserDict() # type: UserDict[users.User, UserSet]\n\ndef _add_count(var, votee : users.User, amount : users.User) -> None:\n    <IND>FORCED_COUNTS[votee] = FORCED_COUNTS.get(votee, 0) + amount\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\nFORCED_COUNTS: UserDict[User, int] = UserDict()\nFORCED_TARGETS: UserDict[User, UserSet] = UserDict()\n\ndef _add_count(var, votee : User, amount : int) -> None:\n    <IND>FORCED_COUNTS[votee] = FORCED_COUNTS.get(votee, 0) + amount\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\ndef add_force_vote(var, votee : users.User, targets : Iterable[users.User]) -> None:\n    \"\"\"Force votee to vote for the specified targets.\"\"\"\n",
        "source_code_len": 143,
        "target_code": "\ndef add_force_vote(var, votee : User, targets : Iterable[User]) -> None:\n    \"\"\"Force votee to vote for the specified targets.\"\"\"\n",
        "target_code_len": 131,
        "diff_format": "@@ -28,3 +31,3 @@\n \n-def add_force_vote(var, votee : users.User, targets : Iterable[users.User]) -> None:\n+def add_force_vote(var, votee : User, targets : Iterable[User]) -> None:\n     \"\"\"Force votee to vote for the specified targets.\"\"\"\n",
        "source_code_with_indent": "\n<DED><DED>def add_force_vote(var, votee : users.User, targets : Iterable[users.User]) -> None:\n    <IND>\"\"\"Force votee to vote for the specified targets.\"\"\"\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n<DED><DED>def add_force_vote(var, votee : User, targets : Iterable[User]) -> None:\n    <IND>\"\"\"Force votee to vote for the specified targets.\"\"\"\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\ndef add_force_abstain(var, votee : users.User) -> None:\n    \"\"\"Force votee to abstain.\"\"\"\n",
        "source_code_len": 91,
        "target_code": "\ndef add_force_abstain(var, votee : User) -> None:\n    \"\"\"Force votee to abstain.\"\"\"\n",
        "target_code_len": 85,
        "diff_format": "@@ -35,3 +38,3 @@\n \n-def add_force_abstain(var, votee : users.User) -> None:\n+def add_force_abstain(var, votee : User) -> None:\n     \"\"\"Force votee to abstain.\"\"\"\n",
        "source_code_with_indent": "\n<DED>def add_force_abstain(var, votee : users.User) -> None:\n    <IND>\"\"\"Force votee to abstain.\"\"\"\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n<DED>def add_force_abstain(var, votee : User) -> None:\n    <IND>\"\"\"Force votee to abstain.\"\"\"\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\ndef can_vote(var, votee : users.User, target : users.User) -> bool:\n    \"\"\"Check whether the votee can vote the target.\"\"\"\n",
        "source_code_len": 124,
        "target_code": "\ndef can_vote(var, votee : User, target : User) -> bool:\n    \"\"\"Check whether the votee can vote the target.\"\"\"\n",
        "target_code_len": 112,
        "diff_format": "@@ -41,3 +44,3 @@\n \n-def can_vote(var, votee : users.User, target : users.User) -> bool:\n+def can_vote(var, votee : User, target : User) -> bool:\n     \"\"\"Check whether the votee can vote the target.\"\"\"\n",
        "source_code_with_indent": "\n<DED>def can_vote(var, votee : users.User, target : users.User) -> bool:\n    <IND>\"\"\"Check whether the votee can vote the target.\"\"\"\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n<DED>def can_vote(var, votee : User, target : User) -> bool:\n    <IND>\"\"\"Check whether the votee can vote the target.\"\"\"\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\ndef can_abstain(var, votee : users.User) -> bool:\n    \"\"\"Check whether the votee can abstain.\"\"\"\n",
        "source_code_len": 98,
        "target_code": "\ndef can_abstain(var, votee : User) -> bool:\n    \"\"\"Check whether the votee can abstain.\"\"\"\n",
        "target_code_len": 92,
        "diff_format": "@@ -50,3 +53,3 @@\n \n-def can_abstain(var, votee : users.User) -> bool:\n+def can_abstain(var, votee : User) -> bool:\n     \"\"\"Check whether the votee can abstain.\"\"\"\n",
        "source_code_with_indent": "\n<DED>def can_abstain(var, votee : users.User) -> bool:\n    <IND>\"\"\"Check whether the votee can abstain.\"\"\"\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n<DED>def can_abstain(var, votee : User) -> bool:\n    <IND>\"\"\"Check whether the votee can abstain.\"\"\"\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\ndef get_forced_votes(var, target : users.User) -> Set[users.User]:\n    \"\"\"Retrieve the players who are being forced to vote target.\"\"\"\n",
        "source_code_len": 136,
        "target_code": "\ndef get_forced_votes(var, target : User) -> Set[User]:\n    \"\"\"Retrieve the players who are being forced to vote target.\"\"\"\n",
        "target_code_len": 124,
        "diff_format": "@@ -54,3 +57,3 @@\n \n-def get_forced_votes(var, target : users.User) -> Set[users.User]:\n+def get_forced_votes(var, target : User) -> Set[User]:\n     \"\"\"Retrieve the players who are being forced to vote target.\"\"\"\n",
        "source_code_with_indent": "\n<DED>def get_forced_votes(var, target : users.User) -> Set[users.User]:\n    <IND>\"\"\"Retrieve the players who are being forced to vote target.\"\"\"\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n<DED>def get_forced_votes(var, target : User) -> Set[User]:\n    <IND>\"\"\"Retrieve the players who are being forced to vote target.\"\"\"\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\ndef get_all_forced_votes(var) -> Set[users.User]:\n    \"\"\"Retrieve the players who are being forced to vote.\"\"\"\n",
        "source_code_len": 112,
        "target_code": "\ndef get_all_forced_votes(var) -> Set[User]:\n    \"\"\"Retrieve the players who are being forced to vote.\"\"\"\n",
        "target_code_len": 106,
        "diff_format": "@@ -58,3 +61,3 @@\n \n-def get_all_forced_votes(var) -> Set[users.User]:\n+def get_all_forced_votes(var) -> Set[User]:\n     \"\"\"Retrieve the players who are being forced to vote.\"\"\"\n",
        "source_code_with_indent": "\n<DED>def get_all_forced_votes(var) -> Set[users.User]:\n    <IND>\"\"\"Retrieve the players who are being forced to vote.\"\"\"\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n<DED>def get_all_forced_votes(var) -> Set[User]:\n    <IND>\"\"\"Retrieve the players who are being forced to vote.\"\"\"\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\ndef get_forced_abstains(var) -> Set[users.User]:\n    \"\"\"Retrieve the players who are being forced to abstain.\"\"\"\n",
        "source_code_len": 114,
        "target_code": "\ndef get_forced_abstains(var) -> Set[User]:\n    \"\"\"Retrieve the players who are being forced to abstain.\"\"\"\n",
        "target_code_len": 108,
        "diff_format": "@@ -62,3 +65,3 @@\n \n-def get_forced_abstains(var) -> Set[users.User]:\n+def get_forced_abstains(var) -> Set[User]:\n     \"\"\"Retrieve the players who are being forced to abstain.\"\"\"\n",
        "source_code_with_indent": "\n<DED>def get_forced_abstains(var) -> Set[users.User]:\n    <IND>\"\"\"Retrieve the players who are being forced to abstain.\"\"\"\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n<DED>def get_forced_abstains(var) -> Set[User]:\n    <IND>\"\"\"Retrieve the players who are being forced to abstain.\"\"\"\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "lykoss/lykos",
    "commit": "f8560e10e9e8cc4b4a3b8e750865c4079f7c9b37",
    "filename": "src/status/forcevote.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/lykoss-lykos/src/status/forcevote.py",
    "file_hunks_size": 10,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "src/status/forcevote.py:40:27 Incompatible parameter type [6]: Expected `users.User` for 3rd positional only parameter to call `_add_count` but got `int`.",
    "message": " Expected `users.User` for 3rd positional only parameter to call `_add_count` but got `int`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 40,
    "warning_line": "    _add_count(var, votee, -1)",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "from src.events import Event\nfrom src import channels, users\n\n",
        "source_code_len": 62,
        "target_code": "from src.events import Event\nfrom src.users import User\nfrom src import channels\n\n",
        "target_code_len": 82,
        "diff_format": "@@ -7,3 +9,4 @@\n from src.events import Event\n-from src import channels, users\n+from src.users import User\n+from src import channels\n \n",
        "source_code_with_indent": "from src.events import Event\nfrom src import channels, users\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "from src.events import Event\nfrom src.users import User\nfrom src import channels\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\nFORCED_COUNTS = UserDict() # type: UserDict[users.User, int]\nFORCED_TARGETS = UserDict() # type: UserDict[users.User, UserSet]\n\ndef _add_count(var, votee : users.User, amount : users.User) -> None:\n    FORCED_COUNTS[votee] = FORCED_COUNTS.get(votee, 0) + amount\n",
        "source_code_len": 263,
        "target_code": "\nFORCED_COUNTS: UserDict[User, int] = UserDict()\nFORCED_TARGETS: UserDict[User, UserSet] = UserDict()\n\ndef _add_count(var, votee : User, amount : int) -> None:\n    FORCED_COUNTS[votee] = FORCED_COUNTS.get(votee, 0) + amount\n",
        "target_code_len": 224,
        "diff_format": "@@ -18,6 +21,6 @@\n \n-FORCED_COUNTS = UserDict() # type: UserDict[users.User, int]\n-FORCED_TARGETS = UserDict() # type: UserDict[users.User, UserSet]\n+FORCED_COUNTS: UserDict[User, int] = UserDict()\n+FORCED_TARGETS: UserDict[User, UserSet] = UserDict()\n \n-def _add_count(var, votee : users.User, amount : users.User) -> None:\n+def _add_count(var, votee : User, amount : int) -> None:\n     FORCED_COUNTS[votee] = FORCED_COUNTS.get(votee, 0) + amount\n",
        "source_code_with_indent": "\nFORCED_COUNTS = UserDict() # type: UserDict[users.User, int]\nFORCED_TARGETS = UserDict() # type: UserDict[users.User, UserSet]\n\ndef _add_count(var, votee : users.User, amount : users.User) -> None:\n    <IND>FORCED_COUNTS[votee] = FORCED_COUNTS.get(votee, 0) + amount\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\nFORCED_COUNTS: UserDict[User, int] = UserDict()\nFORCED_TARGETS: UserDict[User, UserSet] = UserDict()\n\ndef _add_count(var, votee : User, amount : int) -> None:\n    <IND>FORCED_COUNTS[votee] = FORCED_COUNTS.get(votee, 0) + amount\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\ndef add_force_vote(var, votee : users.User, targets : Iterable[users.User]) -> None:\n    \"\"\"Force votee to vote for the specified targets.\"\"\"\n",
        "source_code_len": 143,
        "target_code": "\ndef add_force_vote(var, votee : User, targets : Iterable[User]) -> None:\n    \"\"\"Force votee to vote for the specified targets.\"\"\"\n",
        "target_code_len": 131,
        "diff_format": "@@ -28,3 +31,3 @@\n \n-def add_force_vote(var, votee : users.User, targets : Iterable[users.User]) -> None:\n+def add_force_vote(var, votee : User, targets : Iterable[User]) -> None:\n     \"\"\"Force votee to vote for the specified targets.\"\"\"\n",
        "source_code_with_indent": "\n<DED><DED>def add_force_vote(var, votee : users.User, targets : Iterable[users.User]) -> None:\n    <IND>\"\"\"Force votee to vote for the specified targets.\"\"\"\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n<DED><DED>def add_force_vote(var, votee : User, targets : Iterable[User]) -> None:\n    <IND>\"\"\"Force votee to vote for the specified targets.\"\"\"\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\ndef add_force_abstain(var, votee : users.User) -> None:\n    \"\"\"Force votee to abstain.\"\"\"\n",
        "source_code_len": 91,
        "target_code": "\ndef add_force_abstain(var, votee : User) -> None:\n    \"\"\"Force votee to abstain.\"\"\"\n",
        "target_code_len": 85,
        "diff_format": "@@ -35,3 +38,3 @@\n \n-def add_force_abstain(var, votee : users.User) -> None:\n+def add_force_abstain(var, votee : User) -> None:\n     \"\"\"Force votee to abstain.\"\"\"\n",
        "source_code_with_indent": "\n<DED>def add_force_abstain(var, votee : users.User) -> None:\n    <IND>\"\"\"Force votee to abstain.\"\"\"\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n<DED>def add_force_abstain(var, votee : User) -> None:\n    <IND>\"\"\"Force votee to abstain.\"\"\"\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\ndef can_vote(var, votee : users.User, target : users.User) -> bool:\n    \"\"\"Check whether the votee can vote the target.\"\"\"\n",
        "source_code_len": 124,
        "target_code": "\ndef can_vote(var, votee : User, target : User) -> bool:\n    \"\"\"Check whether the votee can vote the target.\"\"\"\n",
        "target_code_len": 112,
        "diff_format": "@@ -41,3 +44,3 @@\n \n-def can_vote(var, votee : users.User, target : users.User) -> bool:\n+def can_vote(var, votee : User, target : User) -> bool:\n     \"\"\"Check whether the votee can vote the target.\"\"\"\n",
        "source_code_with_indent": "\n<DED>def can_vote(var, votee : users.User, target : users.User) -> bool:\n    <IND>\"\"\"Check whether the votee can vote the target.\"\"\"\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n<DED>def can_vote(var, votee : User, target : User) -> bool:\n    <IND>\"\"\"Check whether the votee can vote the target.\"\"\"\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\ndef can_abstain(var, votee : users.User) -> bool:\n    \"\"\"Check whether the votee can abstain.\"\"\"\n",
        "source_code_len": 98,
        "target_code": "\ndef can_abstain(var, votee : User) -> bool:\n    \"\"\"Check whether the votee can abstain.\"\"\"\n",
        "target_code_len": 92,
        "diff_format": "@@ -50,3 +53,3 @@\n \n-def can_abstain(var, votee : users.User) -> bool:\n+def can_abstain(var, votee : User) -> bool:\n     \"\"\"Check whether the votee can abstain.\"\"\"\n",
        "source_code_with_indent": "\n<DED>def can_abstain(var, votee : users.User) -> bool:\n    <IND>\"\"\"Check whether the votee can abstain.\"\"\"\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n<DED>def can_abstain(var, votee : User) -> bool:\n    <IND>\"\"\"Check whether the votee can abstain.\"\"\"\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\ndef get_forced_votes(var, target : users.User) -> Set[users.User]:\n    \"\"\"Retrieve the players who are being forced to vote target.\"\"\"\n",
        "source_code_len": 136,
        "target_code": "\ndef get_forced_votes(var, target : User) -> Set[User]:\n    \"\"\"Retrieve the players who are being forced to vote target.\"\"\"\n",
        "target_code_len": 124,
        "diff_format": "@@ -54,3 +57,3 @@\n \n-def get_forced_votes(var, target : users.User) -> Set[users.User]:\n+def get_forced_votes(var, target : User) -> Set[User]:\n     \"\"\"Retrieve the players who are being forced to vote target.\"\"\"\n",
        "source_code_with_indent": "\n<DED>def get_forced_votes(var, target : users.User) -> Set[users.User]:\n    <IND>\"\"\"Retrieve the players who are being forced to vote target.\"\"\"\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n<DED>def get_forced_votes(var, target : User) -> Set[User]:\n    <IND>\"\"\"Retrieve the players who are being forced to vote target.\"\"\"\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\ndef get_all_forced_votes(var) -> Set[users.User]:\n    \"\"\"Retrieve the players who are being forced to vote.\"\"\"\n",
        "source_code_len": 112,
        "target_code": "\ndef get_all_forced_votes(var) -> Set[User]:\n    \"\"\"Retrieve the players who are being forced to vote.\"\"\"\n",
        "target_code_len": 106,
        "diff_format": "@@ -58,3 +61,3 @@\n \n-def get_all_forced_votes(var) -> Set[users.User]:\n+def get_all_forced_votes(var) -> Set[User]:\n     \"\"\"Retrieve the players who are being forced to vote.\"\"\"\n",
        "source_code_with_indent": "\n<DED>def get_all_forced_votes(var) -> Set[users.User]:\n    <IND>\"\"\"Retrieve the players who are being forced to vote.\"\"\"\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n<DED>def get_all_forced_votes(var) -> Set[User]:\n    <IND>\"\"\"Retrieve the players who are being forced to vote.\"\"\"\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\ndef get_forced_abstains(var) -> Set[users.User]:\n    \"\"\"Retrieve the players who are being forced to abstain.\"\"\"\n",
        "source_code_len": 114,
        "target_code": "\ndef get_forced_abstains(var) -> Set[User]:\n    \"\"\"Retrieve the players who are being forced to abstain.\"\"\"\n",
        "target_code_len": 108,
        "diff_format": "@@ -62,3 +65,3 @@\n \n-def get_forced_abstains(var) -> Set[users.User]:\n+def get_forced_abstains(var) -> Set[User]:\n     \"\"\"Retrieve the players who are being forced to abstain.\"\"\"\n",
        "source_code_with_indent": "\n<DED>def get_forced_abstains(var) -> Set[users.User]:\n    <IND>\"\"\"Retrieve the players who are being forced to abstain.\"\"\"\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n<DED>def get_forced_abstains(var) -> Set[User]:\n    <IND>\"\"\"Retrieve the players who are being forced to abstain.\"\"\"\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "lykoss/lykos",
    "commit": "f8560e10e9e8cc4b4a3b8e750865c4079f7c9b37",
    "filename": "src/status/voteweight.py",
    "min_patch_found": false,
    "full_warning_msg": "src/status/voteweight.py:9:0 Incompatible variable type [9]: WEIGHT is declared to have type `UserDict[]` but is used as type `UserDict`.",
    "exception": "PatchSet should only have 1 Patch, but it has 0",
    "dd_fail": true
  },
  {
    "project": "lykoss/lykos",
    "commit": "f8560e10e9e8cc4b4a3b8e750865c4079f7c9b37",
    "filename": "src/users.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/lykoss-lykos/src/users.py",
    "file_hunks_size": 6,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "src/users.py:20:0 Incompatible variable type [9]: _users is declared to have type `src.debug.set.CheckedSet[]` but is used as type `src.debug.set.CheckedSet`.",
    "message": " _users is declared to have type `src.debug.set.CheckedSet[]` but is used as type `src.debug.set.CheckedSet`.",
    "rule_id": "Incompatible variable type [9]",
    "warning_line_no": 20,
    "warning_line": "_users = CheckedSet(\"users._users\") # type: CheckedSet[User]"
  },
  {
    "project": "lykoss/lykos",
    "commit": "f8560e10e9e8cc4b4a3b8e750865c4079f7c9b37",
    "filename": "src/users.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/lykoss-lykos/src/users.py",
    "file_hunks_size": 6,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "src/users.py:21:0 Incompatible variable type [9]: _ghosts is declared to have type `src.debug.set.CheckedSet[]` but is used as type `src.debug.set.CheckedSet`.",
    "message": " _ghosts is declared to have type `src.debug.set.CheckedSet[]` but is used as type `src.debug.set.CheckedSet`.",
    "rule_id": "Incompatible variable type [9]",
    "warning_line_no": 21,
    "warning_line": "_ghosts = CheckedSet(\"users._ghosts\") # type: CheckedSet[User]"
  },
  {
    "project": "lykoss/lykos",
    "commit": "f8560e10e9e8cc4b4a3b8e750865c4079f7c9b37",
    "filename": "src/users.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/lykoss-lykos/src/users.py",
    "file_hunks_size": 6,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "src/users.py:22:0 Incompatible variable type [9]: _pending_account_updates is declared to have type `src.debug.dict.CheckedDict[]` but is used as type `src.debug.dict.CheckedDict`.",
    "message": " _pending_account_updates is declared to have type `src.debug.dict.CheckedDict[]` but is used as type `src.debug.dict.CheckedDict`.",
    "rule_id": "Incompatible variable type [9]",
    "warning_line_no": 22,
    "warning_line": "_pending_account_updates = CheckedDict(\"users._pending_account_updates\") # type: CheckedDict[User, CheckedDict[str, Callable]]"
  },
  {
    "project": "lykoss/lykos",
    "commit": "f8560e10e9e8cc4b4a3b8e750865c4079f7c9b37",
    "filename": "src/warnings.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/lykoss-lykos/src/warnings.py",
    "file_hunks_size": 6,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "src/warnings.py:215:8 Incompatible variable type [9]: base is declared to have type `Optional[str]` but is used as type `datetime`.",
    "message": " base is declared to have type `Optional[str]` but is used as type `datetime`.",
    "rule_id": "Incompatible variable type [9]",
    "warning_line_no": 215,
    "warning_line": "        base = datetime.utcnow()",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    if not base:\n        base = datetime.utcnow()\n    else:\n        base = datetime.strptime(base, \"%Y-%m-%d %H:%M:%S\")\n\n    if suffix == messages.raw(\"day_suffix\"):\n        expires = base + timedelta(days=amount)\n    elif suffix == messages.raw(\"hour_suffix\"):\n        expires = base + timedelta(hours=amount)\n    elif suffix == messages.raw(\"minute_suffix\"):\n        expires = base + timedelta(minutes=amount)\n    else:\n",
        "source_code_len": 422,
        "target_code": "    if not base:\n        base_dt = datetime.utcnow()\n    else:\n        base_dt = datetime.strptime(base, \"%Y-%m-%d %H:%M:%S\")\n\n    if suffix == messages.raw(\"day_suffix\"):\n        expires_dt = base_dt + timedelta(days=amount)\n    elif suffix == messages.raw(\"hour_suffix\"):\n        expires_dt = base_dt + timedelta(hours=amount)\n    elif suffix == messages.raw(\"minute_suffix\"):\n        expires_dt = base_dt + timedelta(minutes=amount)\n    else:\n",
        "target_code_len": 446,
        "diff_format": "@@ -214,12 +218,12 @@\n     if not base:\n-        base = datetime.utcnow()\n-    else:\n-        base = datetime.strptime(base, \"%Y-%m-%d %H:%M:%S\")\n+        base_dt = datetime.utcnow()\n+    else:\n+        base_dt = datetime.strptime(base, \"%Y-%m-%d %H:%M:%S\")\n \n     if suffix == messages.raw(\"day_suffix\"):\n-        expires = base + timedelta(days=amount)\n+        expires_dt = base_dt + timedelta(days=amount)\n     elif suffix == messages.raw(\"hour_suffix\"):\n-        expires = base + timedelta(hours=amount)\n+        expires_dt = base_dt + timedelta(hours=amount)\n     elif suffix == messages.raw(\"minute_suffix\"):\n-        expires = base + timedelta(minutes=amount)\n+        expires_dt = base_dt + timedelta(minutes=amount)\n     else:\n",
        "source_code_with_indent": "    <DED>if not base:\n        <IND>base = datetime.utcnow()\n    <DED>else:\n        <IND>base = datetime.strptime(base, \"%Y-%m-%d %H:%M:%S\")\n\n    <DED>if suffix == messages.raw(\"day_suffix\"):\n        <IND>expires = base + timedelta(days=amount)\n    <DED>elif suffix == messages.raw(\"hour_suffix\"):\n        <IND>expires = base + timedelta(hours=amount)\n    <DED>elif suffix == messages.raw(\"minute_suffix\"):\n        <IND>expires = base + timedelta(minutes=amount)\n    <DED>else:\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    <DED>if not base:\n        <IND>base_dt = datetime.utcnow()\n    <DED>else:\n        <IND>base_dt = datetime.strptime(base, \"%Y-%m-%d %H:%M:%S\")\n\n    <DED>if suffix == messages.raw(\"day_suffix\"):\n        <IND>expires_dt = base_dt + timedelta(days=amount)\n    <DED>elif suffix == messages.raw(\"hour_suffix\"):\n        <IND>expires_dt = base_dt + timedelta(hours=amount)\n    <DED>elif suffix == messages.raw(\"minute_suffix\"):\n        <IND>expires_dt = base_dt + timedelta(minutes=amount)\n    <DED>else:\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "lykoss/lykos",
    "commit": "f8560e10e9e8cc4b4a3b8e750865c4079f7c9b37",
    "filename": "src/warnings.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/lykoss-lykos/src/warnings.py",
    "file_hunks_size": 6,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "src/warnings.py:217:8 Incompatible variable type [9]: base is declared to have type `Optional[str]` but is used as type `datetime`.",
    "message": " base is declared to have type `Optional[str]` but is used as type `datetime`.",
    "rule_id": "Incompatible variable type [9]",
    "warning_line_no": 217,
    "warning_line": "        base = datetime.strptime(base, \"%Y-%m-%d %H:%M:%S\")",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    if not base:\n        base = datetime.utcnow()\n    else:\n        base = datetime.strptime(base, \"%Y-%m-%d %H:%M:%S\")\n\n    if suffix == messages.raw(\"day_suffix\"):\n        expires = base + timedelta(days=amount)\n    elif suffix == messages.raw(\"hour_suffix\"):\n        expires = base + timedelta(hours=amount)\n    elif suffix == messages.raw(\"minute_suffix\"):\n        expires = base + timedelta(minutes=amount)\n    else:\n",
        "source_code_len": 422,
        "target_code": "    if not base:\n        base_dt = datetime.utcnow()\n    else:\n        base_dt = datetime.strptime(base, \"%Y-%m-%d %H:%M:%S\")\n\n    if suffix == messages.raw(\"day_suffix\"):\n        expires_dt = base_dt + timedelta(days=amount)\n    elif suffix == messages.raw(\"hour_suffix\"):\n        expires_dt = base_dt + timedelta(hours=amount)\n    elif suffix == messages.raw(\"minute_suffix\"):\n        expires_dt = base_dt + timedelta(minutes=amount)\n    else:\n",
        "target_code_len": 446,
        "diff_format": "@@ -214,12 +218,12 @@\n     if not base:\n-        base = datetime.utcnow()\n-    else:\n-        base = datetime.strptime(base, \"%Y-%m-%d %H:%M:%S\")\n+        base_dt = datetime.utcnow()\n+    else:\n+        base_dt = datetime.strptime(base, \"%Y-%m-%d %H:%M:%S\")\n \n     if suffix == messages.raw(\"day_suffix\"):\n-        expires = base + timedelta(days=amount)\n+        expires_dt = base_dt + timedelta(days=amount)\n     elif suffix == messages.raw(\"hour_suffix\"):\n-        expires = base + timedelta(hours=amount)\n+        expires_dt = base_dt + timedelta(hours=amount)\n     elif suffix == messages.raw(\"minute_suffix\"):\n-        expires = base + timedelta(minutes=amount)\n+        expires_dt = base_dt + timedelta(minutes=amount)\n     else:\n",
        "source_code_with_indent": "    <DED>if not base:\n        <IND>base = datetime.utcnow()\n    <DED>else:\n        <IND>base = datetime.strptime(base, \"%Y-%m-%d %H:%M:%S\")\n\n    <DED>if suffix == messages.raw(\"day_suffix\"):\n        <IND>expires = base + timedelta(days=amount)\n    <DED>elif suffix == messages.raw(\"hour_suffix\"):\n        <IND>expires = base + timedelta(hours=amount)\n    <DED>elif suffix == messages.raw(\"minute_suffix\"):\n        <IND>expires = base + timedelta(minutes=amount)\n    <DED>else:\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    <DED>if not base:\n        <IND>base_dt = datetime.utcnow()\n    <DED>else:\n        <IND>base_dt = datetime.strptime(base, \"%Y-%m-%d %H:%M:%S\")\n\n    <DED>if suffix == messages.raw(\"day_suffix\"):\n        <IND>expires_dt = base_dt + timedelta(days=amount)\n    <DED>elif suffix == messages.raw(\"hour_suffix\"):\n        <IND>expires_dt = base_dt + timedelta(hours=amount)\n    <DED>elif suffix == messages.raw(\"minute_suffix\"):\n        <IND>expires_dt = base_dt + timedelta(minutes=amount)\n    <DED>else:\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "lykoss/lykos",
    "commit": "f8560e10e9e8cc4b4a3b8e750865c4079f7c9b37",
    "filename": "src/warnings.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/lykoss-lykos/src/warnings.py",
    "file_hunks_size": 6,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "src/warnings.py:220:8 Incompatible variable type [9]: expires is declared to have type `str` but is used as type `timedelta`.",
    "message": " expires is declared to have type `str` but is used as type `timedelta`.",
    "rule_id": "Incompatible variable type [9]",
    "warning_line_no": 220,
    "warning_line": "        expires = base + timedelta(days=amount)",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    if not base:\n        base = datetime.utcnow()\n    else:\n        base = datetime.strptime(base, \"%Y-%m-%d %H:%M:%S\")\n\n    if suffix == messages.raw(\"day_suffix\"):\n        expires = base + timedelta(days=amount)\n    elif suffix == messages.raw(\"hour_suffix\"):\n        expires = base + timedelta(hours=amount)\n    elif suffix == messages.raw(\"minute_suffix\"):\n        expires = base + timedelta(minutes=amount)\n    else:\n",
        "source_code_len": 422,
        "target_code": "    if not base:\n        base_dt = datetime.utcnow()\n    else:\n        base_dt = datetime.strptime(base, \"%Y-%m-%d %H:%M:%S\")\n\n    if suffix == messages.raw(\"day_suffix\"):\n        expires_dt = base_dt + timedelta(days=amount)\n    elif suffix == messages.raw(\"hour_suffix\"):\n        expires_dt = base_dt + timedelta(hours=amount)\n    elif suffix == messages.raw(\"minute_suffix\"):\n        expires_dt = base_dt + timedelta(minutes=amount)\n    else:\n",
        "target_code_len": 446,
        "diff_format": "@@ -214,12 +218,12 @@\n     if not base:\n-        base = datetime.utcnow()\n-    else:\n-        base = datetime.strptime(base, \"%Y-%m-%d %H:%M:%S\")\n+        base_dt = datetime.utcnow()\n+    else:\n+        base_dt = datetime.strptime(base, \"%Y-%m-%d %H:%M:%S\")\n \n     if suffix == messages.raw(\"day_suffix\"):\n-        expires = base + timedelta(days=amount)\n+        expires_dt = base_dt + timedelta(days=amount)\n     elif suffix == messages.raw(\"hour_suffix\"):\n-        expires = base + timedelta(hours=amount)\n+        expires_dt = base_dt + timedelta(hours=amount)\n     elif suffix == messages.raw(\"minute_suffix\"):\n-        expires = base + timedelta(minutes=amount)\n+        expires_dt = base_dt + timedelta(minutes=amount)\n     else:\n",
        "source_code_with_indent": "    <DED>if not base:\n        <IND>base = datetime.utcnow()\n    <DED>else:\n        <IND>base = datetime.strptime(base, \"%Y-%m-%d %H:%M:%S\")\n\n    <DED>if suffix == messages.raw(\"day_suffix\"):\n        <IND>expires = base + timedelta(days=amount)\n    <DED>elif suffix == messages.raw(\"hour_suffix\"):\n        <IND>expires = base + timedelta(hours=amount)\n    <DED>elif suffix == messages.raw(\"minute_suffix\"):\n        <IND>expires = base + timedelta(minutes=amount)\n    <DED>else:\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    <DED>if not base:\n        <IND>base_dt = datetime.utcnow()\n    <DED>else:\n        <IND>base_dt = datetime.strptime(base, \"%Y-%m-%d %H:%M:%S\")\n\n    <DED>if suffix == messages.raw(\"day_suffix\"):\n        <IND>expires_dt = base_dt + timedelta(days=amount)\n    <DED>elif suffix == messages.raw(\"hour_suffix\"):\n        <IND>expires_dt = base_dt + timedelta(hours=amount)\n    <DED>elif suffix == messages.raw(\"minute_suffix\"):\n        <IND>expires_dt = base_dt + timedelta(minutes=amount)\n    <DED>else:\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "lykoss/lykos",
    "commit": "f8560e10e9e8cc4b4a3b8e750865c4079f7c9b37",
    "filename": "src/warnings.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/lykoss-lykos/src/warnings.py",
    "file_hunks_size": 6,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "src/warnings.py:220:18 Unsupported operand [58]: `+` is not supported for operand types `Optional[str]` and `timedelta`.",
    "message": " `+` is not supported for operand types `Optional[str]` and `timedelta`.",
    "rule_id": "Unsupported operand [58]",
    "warning_line_no": 220,
    "warning_line": "        expires = base + timedelta(days=amount)",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    if not base:\n        base = datetime.utcnow()\n    else:\n        base = datetime.strptime(base, \"%Y-%m-%d %H:%M:%S\")\n\n    if suffix == messages.raw(\"day_suffix\"):\n        expires = base + timedelta(days=amount)\n    elif suffix == messages.raw(\"hour_suffix\"):\n        expires = base + timedelta(hours=amount)\n    elif suffix == messages.raw(\"minute_suffix\"):\n        expires = base + timedelta(minutes=amount)\n    else:\n",
        "source_code_len": 422,
        "target_code": "    if not base:\n        base_dt = datetime.utcnow()\n    else:\n        base_dt = datetime.strptime(base, \"%Y-%m-%d %H:%M:%S\")\n\n    if suffix == messages.raw(\"day_suffix\"):\n        expires_dt = base_dt + timedelta(days=amount)\n    elif suffix == messages.raw(\"hour_suffix\"):\n        expires_dt = base_dt + timedelta(hours=amount)\n    elif suffix == messages.raw(\"minute_suffix\"):\n        expires_dt = base_dt + timedelta(minutes=amount)\n    else:\n",
        "target_code_len": 446,
        "diff_format": "@@ -214,12 +218,12 @@\n     if not base:\n-        base = datetime.utcnow()\n-    else:\n-        base = datetime.strptime(base, \"%Y-%m-%d %H:%M:%S\")\n+        base_dt = datetime.utcnow()\n+    else:\n+        base_dt = datetime.strptime(base, \"%Y-%m-%d %H:%M:%S\")\n \n     if suffix == messages.raw(\"day_suffix\"):\n-        expires = base + timedelta(days=amount)\n+        expires_dt = base_dt + timedelta(days=amount)\n     elif suffix == messages.raw(\"hour_suffix\"):\n-        expires = base + timedelta(hours=amount)\n+        expires_dt = base_dt + timedelta(hours=amount)\n     elif suffix == messages.raw(\"minute_suffix\"):\n-        expires = base + timedelta(minutes=amount)\n+        expires_dt = base_dt + timedelta(minutes=amount)\n     else:\n",
        "source_code_with_indent": "    <DED>if not base:\n        <IND>base = datetime.utcnow()\n    <DED>else:\n        <IND>base = datetime.strptime(base, \"%Y-%m-%d %H:%M:%S\")\n\n    <DED>if suffix == messages.raw(\"day_suffix\"):\n        <IND>expires = base + timedelta(days=amount)\n    <DED>elif suffix == messages.raw(\"hour_suffix\"):\n        <IND>expires = base + timedelta(hours=amount)\n    <DED>elif suffix == messages.raw(\"minute_suffix\"):\n        <IND>expires = base + timedelta(minutes=amount)\n    <DED>else:\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    <DED>if not base:\n        <IND>base_dt = datetime.utcnow()\n    <DED>else:\n        <IND>base_dt = datetime.strptime(base, \"%Y-%m-%d %H:%M:%S\")\n\n    <DED>if suffix == messages.raw(\"day_suffix\"):\n        <IND>expires_dt = base_dt + timedelta(days=amount)\n    <DED>elif suffix == messages.raw(\"hour_suffix\"):\n        <IND>expires_dt = base_dt + timedelta(hours=amount)\n    <DED>elif suffix == messages.raw(\"minute_suffix\"):\n        <IND>expires_dt = base_dt + timedelta(minutes=amount)\n    <DED>else:\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "lykoss/lykos",
    "commit": "f8560e10e9e8cc4b4a3b8e750865c4079f7c9b37",
    "filename": "src/warnings.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/lykoss-lykos/src/warnings.py",
    "file_hunks_size": 6,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "src/warnings.py:222:8 Incompatible variable type [9]: expires is declared to have type `str` but is used as type `timedelta`.",
    "message": " expires is declared to have type `str` but is used as type `timedelta`.",
    "rule_id": "Incompatible variable type [9]",
    "warning_line_no": 222,
    "warning_line": "        expires = base + timedelta(hours=amount)",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    if not base:\n        base = datetime.utcnow()\n    else:\n        base = datetime.strptime(base, \"%Y-%m-%d %H:%M:%S\")\n\n    if suffix == messages.raw(\"day_suffix\"):\n        expires = base + timedelta(days=amount)\n    elif suffix == messages.raw(\"hour_suffix\"):\n        expires = base + timedelta(hours=amount)\n    elif suffix == messages.raw(\"minute_suffix\"):\n        expires = base + timedelta(minutes=amount)\n    else:\n",
        "source_code_len": 422,
        "target_code": "    if not base:\n        base_dt = datetime.utcnow()\n    else:\n        base_dt = datetime.strptime(base, \"%Y-%m-%d %H:%M:%S\")\n\n    if suffix == messages.raw(\"day_suffix\"):\n        expires_dt = base_dt + timedelta(days=amount)\n    elif suffix == messages.raw(\"hour_suffix\"):\n        expires_dt = base_dt + timedelta(hours=amount)\n    elif suffix == messages.raw(\"minute_suffix\"):\n        expires_dt = base_dt + timedelta(minutes=amount)\n    else:\n",
        "target_code_len": 446,
        "diff_format": "@@ -214,12 +218,12 @@\n     if not base:\n-        base = datetime.utcnow()\n-    else:\n-        base = datetime.strptime(base, \"%Y-%m-%d %H:%M:%S\")\n+        base_dt = datetime.utcnow()\n+    else:\n+        base_dt = datetime.strptime(base, \"%Y-%m-%d %H:%M:%S\")\n \n     if suffix == messages.raw(\"day_suffix\"):\n-        expires = base + timedelta(days=amount)\n+        expires_dt = base_dt + timedelta(days=amount)\n     elif suffix == messages.raw(\"hour_suffix\"):\n-        expires = base + timedelta(hours=amount)\n+        expires_dt = base_dt + timedelta(hours=amount)\n     elif suffix == messages.raw(\"minute_suffix\"):\n-        expires = base + timedelta(minutes=amount)\n+        expires_dt = base_dt + timedelta(minutes=amount)\n     else:\n",
        "source_code_with_indent": "    <DED>if not base:\n        <IND>base = datetime.utcnow()\n    <DED>else:\n        <IND>base = datetime.strptime(base, \"%Y-%m-%d %H:%M:%S\")\n\n    <DED>if suffix == messages.raw(\"day_suffix\"):\n        <IND>expires = base + timedelta(days=amount)\n    <DED>elif suffix == messages.raw(\"hour_suffix\"):\n        <IND>expires = base + timedelta(hours=amount)\n    <DED>elif suffix == messages.raw(\"minute_suffix\"):\n        <IND>expires = base + timedelta(minutes=amount)\n    <DED>else:\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    <DED>if not base:\n        <IND>base_dt = datetime.utcnow()\n    <DED>else:\n        <IND>base_dt = datetime.strptime(base, \"%Y-%m-%d %H:%M:%S\")\n\n    <DED>if suffix == messages.raw(\"day_suffix\"):\n        <IND>expires_dt = base_dt + timedelta(days=amount)\n    <DED>elif suffix == messages.raw(\"hour_suffix\"):\n        <IND>expires_dt = base_dt + timedelta(hours=amount)\n    <DED>elif suffix == messages.raw(\"minute_suffix\"):\n        <IND>expires_dt = base_dt + timedelta(minutes=amount)\n    <DED>else:\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "lykoss/lykos",
    "commit": "f8560e10e9e8cc4b4a3b8e750865c4079f7c9b37",
    "filename": "src/warnings.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/lykoss-lykos/src/warnings.py",
    "file_hunks_size": 6,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "src/warnings.py:222:18 Unsupported operand [58]: `+` is not supported for operand types `Optional[str]` and `timedelta`.",
    "message": " `+` is not supported for operand types `Optional[str]` and `timedelta`.",
    "rule_id": "Unsupported operand [58]",
    "warning_line_no": 222,
    "warning_line": "        expires = base + timedelta(hours=amount)",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    if not base:\n        base = datetime.utcnow()\n    else:\n        base = datetime.strptime(base, \"%Y-%m-%d %H:%M:%S\")\n\n    if suffix == messages.raw(\"day_suffix\"):\n        expires = base + timedelta(days=amount)\n    elif suffix == messages.raw(\"hour_suffix\"):\n        expires = base + timedelta(hours=amount)\n    elif suffix == messages.raw(\"minute_suffix\"):\n        expires = base + timedelta(minutes=amount)\n    else:\n",
        "source_code_len": 422,
        "target_code": "    if not base:\n        base_dt = datetime.utcnow()\n    else:\n        base_dt = datetime.strptime(base, \"%Y-%m-%d %H:%M:%S\")\n\n    if suffix == messages.raw(\"day_suffix\"):\n        expires_dt = base_dt + timedelta(days=amount)\n    elif suffix == messages.raw(\"hour_suffix\"):\n        expires_dt = base_dt + timedelta(hours=amount)\n    elif suffix == messages.raw(\"minute_suffix\"):\n        expires_dt = base_dt + timedelta(minutes=amount)\n    else:\n",
        "target_code_len": 446,
        "diff_format": "@@ -214,12 +218,12 @@\n     if not base:\n-        base = datetime.utcnow()\n-    else:\n-        base = datetime.strptime(base, \"%Y-%m-%d %H:%M:%S\")\n+        base_dt = datetime.utcnow()\n+    else:\n+        base_dt = datetime.strptime(base, \"%Y-%m-%d %H:%M:%S\")\n \n     if suffix == messages.raw(\"day_suffix\"):\n-        expires = base + timedelta(days=amount)\n+        expires_dt = base_dt + timedelta(days=amount)\n     elif suffix == messages.raw(\"hour_suffix\"):\n-        expires = base + timedelta(hours=amount)\n+        expires_dt = base_dt + timedelta(hours=amount)\n     elif suffix == messages.raw(\"minute_suffix\"):\n-        expires = base + timedelta(minutes=amount)\n+        expires_dt = base_dt + timedelta(minutes=amount)\n     else:\n",
        "source_code_with_indent": "    <DED>if not base:\n        <IND>base = datetime.utcnow()\n    <DED>else:\n        <IND>base = datetime.strptime(base, \"%Y-%m-%d %H:%M:%S\")\n\n    <DED>if suffix == messages.raw(\"day_suffix\"):\n        <IND>expires = base + timedelta(days=amount)\n    <DED>elif suffix == messages.raw(\"hour_suffix\"):\n        <IND>expires = base + timedelta(hours=amount)\n    <DED>elif suffix == messages.raw(\"minute_suffix\"):\n        <IND>expires = base + timedelta(minutes=amount)\n    <DED>else:\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    <DED>if not base:\n        <IND>base_dt = datetime.utcnow()\n    <DED>else:\n        <IND>base_dt = datetime.strptime(base, \"%Y-%m-%d %H:%M:%S\")\n\n    <DED>if suffix == messages.raw(\"day_suffix\"):\n        <IND>expires_dt = base_dt + timedelta(days=amount)\n    <DED>elif suffix == messages.raw(\"hour_suffix\"):\n        <IND>expires_dt = base_dt + timedelta(hours=amount)\n    <DED>elif suffix == messages.raw(\"minute_suffix\"):\n        <IND>expires_dt = base_dt + timedelta(minutes=amount)\n    <DED>else:\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "lykoss/lykos",
    "commit": "f8560e10e9e8cc4b4a3b8e750865c4079f7c9b37",
    "filename": "src/warnings.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/lykoss-lykos/src/warnings.py",
    "file_hunks_size": 6,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "src/warnings.py:224:8 Incompatible variable type [9]: expires is declared to have type `str` but is used as type `timedelta`.",
    "message": " expires is declared to have type `str` but is used as type `timedelta`.",
    "rule_id": "Incompatible variable type [9]",
    "warning_line_no": 224,
    "warning_line": "        expires = base + timedelta(minutes=amount)",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    if not base:\n        base = datetime.utcnow()\n    else:\n        base = datetime.strptime(base, \"%Y-%m-%d %H:%M:%S\")\n\n    if suffix == messages.raw(\"day_suffix\"):\n        expires = base + timedelta(days=amount)\n    elif suffix == messages.raw(\"hour_suffix\"):\n        expires = base + timedelta(hours=amount)\n    elif suffix == messages.raw(\"minute_suffix\"):\n        expires = base + timedelta(minutes=amount)\n    else:\n",
        "source_code_len": 422,
        "target_code": "    if not base:\n        base_dt = datetime.utcnow()\n    else:\n        base_dt = datetime.strptime(base, \"%Y-%m-%d %H:%M:%S\")\n\n    if suffix == messages.raw(\"day_suffix\"):\n        expires_dt = base_dt + timedelta(days=amount)\n    elif suffix == messages.raw(\"hour_suffix\"):\n        expires_dt = base_dt + timedelta(hours=amount)\n    elif suffix == messages.raw(\"minute_suffix\"):\n        expires_dt = base_dt + timedelta(minutes=amount)\n    else:\n",
        "target_code_len": 446,
        "diff_format": "@@ -214,12 +218,12 @@\n     if not base:\n-        base = datetime.utcnow()\n-    else:\n-        base = datetime.strptime(base, \"%Y-%m-%d %H:%M:%S\")\n+        base_dt = datetime.utcnow()\n+    else:\n+        base_dt = datetime.strptime(base, \"%Y-%m-%d %H:%M:%S\")\n \n     if suffix == messages.raw(\"day_suffix\"):\n-        expires = base + timedelta(days=amount)\n+        expires_dt = base_dt + timedelta(days=amount)\n     elif suffix == messages.raw(\"hour_suffix\"):\n-        expires = base + timedelta(hours=amount)\n+        expires_dt = base_dt + timedelta(hours=amount)\n     elif suffix == messages.raw(\"minute_suffix\"):\n-        expires = base + timedelta(minutes=amount)\n+        expires_dt = base_dt + timedelta(minutes=amount)\n     else:\n",
        "source_code_with_indent": "    <DED>if not base:\n        <IND>base = datetime.utcnow()\n    <DED>else:\n        <IND>base = datetime.strptime(base, \"%Y-%m-%d %H:%M:%S\")\n\n    <DED>if suffix == messages.raw(\"day_suffix\"):\n        <IND>expires = base + timedelta(days=amount)\n    <DED>elif suffix == messages.raw(\"hour_suffix\"):\n        <IND>expires = base + timedelta(hours=amount)\n    <DED>elif suffix == messages.raw(\"minute_suffix\"):\n        <IND>expires = base + timedelta(minutes=amount)\n    <DED>else:\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    <DED>if not base:\n        <IND>base_dt = datetime.utcnow()\n    <DED>else:\n        <IND>base_dt = datetime.strptime(base, \"%Y-%m-%d %H:%M:%S\")\n\n    <DED>if suffix == messages.raw(\"day_suffix\"):\n        <IND>expires_dt = base_dt + timedelta(days=amount)\n    <DED>elif suffix == messages.raw(\"hour_suffix\"):\n        <IND>expires_dt = base_dt + timedelta(hours=amount)\n    <DED>elif suffix == messages.raw(\"minute_suffix\"):\n        <IND>expires_dt = base_dt + timedelta(minutes=amount)\n    <DED>else:\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "lykoss/lykos",
    "commit": "f8560e10e9e8cc4b4a3b8e750865c4079f7c9b37",
    "filename": "src/warnings.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/lykoss-lykos/src/warnings.py",
    "file_hunks_size": 6,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "src/warnings.py:224:18 Unsupported operand [58]: `+` is not supported for operand types `Optional[str]` and `timedelta`.",
    "message": " `+` is not supported for operand types `Optional[str]` and `timedelta`.",
    "rule_id": "Unsupported operand [58]",
    "warning_line_no": 224,
    "warning_line": "        expires = base + timedelta(minutes=amount)",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    if not base:\n        base = datetime.utcnow()\n    else:\n        base = datetime.strptime(base, \"%Y-%m-%d %H:%M:%S\")\n\n    if suffix == messages.raw(\"day_suffix\"):\n        expires = base + timedelta(days=amount)\n    elif suffix == messages.raw(\"hour_suffix\"):\n        expires = base + timedelta(hours=amount)\n    elif suffix == messages.raw(\"minute_suffix\"):\n        expires = base + timedelta(minutes=amount)\n    else:\n",
        "source_code_len": 422,
        "target_code": "    if not base:\n        base_dt = datetime.utcnow()\n    else:\n        base_dt = datetime.strptime(base, \"%Y-%m-%d %H:%M:%S\")\n\n    if suffix == messages.raw(\"day_suffix\"):\n        expires_dt = base_dt + timedelta(days=amount)\n    elif suffix == messages.raw(\"hour_suffix\"):\n        expires_dt = base_dt + timedelta(hours=amount)\n    elif suffix == messages.raw(\"minute_suffix\"):\n        expires_dt = base_dt + timedelta(minutes=amount)\n    else:\n",
        "target_code_len": 446,
        "diff_format": "@@ -214,12 +218,12 @@\n     if not base:\n-        base = datetime.utcnow()\n-    else:\n-        base = datetime.strptime(base, \"%Y-%m-%d %H:%M:%S\")\n+        base_dt = datetime.utcnow()\n+    else:\n+        base_dt = datetime.strptime(base, \"%Y-%m-%d %H:%M:%S\")\n \n     if suffix == messages.raw(\"day_suffix\"):\n-        expires = base + timedelta(days=amount)\n+        expires_dt = base_dt + timedelta(days=amount)\n     elif suffix == messages.raw(\"hour_suffix\"):\n-        expires = base + timedelta(hours=amount)\n+        expires_dt = base_dt + timedelta(hours=amount)\n     elif suffix == messages.raw(\"minute_suffix\"):\n-        expires = base + timedelta(minutes=amount)\n+        expires_dt = base_dt + timedelta(minutes=amount)\n     else:\n",
        "source_code_with_indent": "    <DED>if not base:\n        <IND>base = datetime.utcnow()\n    <DED>else:\n        <IND>base = datetime.strptime(base, \"%Y-%m-%d %H:%M:%S\")\n\n    <DED>if suffix == messages.raw(\"day_suffix\"):\n        <IND>expires = base + timedelta(days=amount)\n    <DED>elif suffix == messages.raw(\"hour_suffix\"):\n        <IND>expires = base + timedelta(hours=amount)\n    <DED>elif suffix == messages.raw(\"minute_suffix\"):\n        <IND>expires = base + timedelta(minutes=amount)\n    <DED>else:\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    <DED>if not base:\n        <IND>base_dt = datetime.utcnow()\n    <DED>else:\n        <IND>base_dt = datetime.strptime(base, \"%Y-%m-%d %H:%M:%S\")\n\n    <DED>if suffix == messages.raw(\"day_suffix\"):\n        <IND>expires_dt = base_dt + timedelta(days=amount)\n    <DED>elif suffix == messages.raw(\"hour_suffix\"):\n        <IND>expires_dt = base_dt + timedelta(hours=amount)\n    <DED>elif suffix == messages.raw(\"minute_suffix\"):\n        <IND>expires_dt = base_dt + timedelta(minutes=amount)\n    <DED>else:\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "lykoss/lykos",
    "commit": "f8560e10e9e8cc4b4a3b8e750865c4079f7c9b37",
    "filename": "src/wolfgame.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/lykoss-lykos/src/wolfgame.py",
    "file_hunks_size": 7,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": true,
    "full_warning_msg": "src/wolfgame.py:87:0 Incompatible variable type [9]: src.settings.LAST_GOAT is declared to have type `UserDict[]` but is used as type `UserDict`.",
    "message": " src.settings.LAST_GOAT is declared to have type `UserDict[]` but is used as type `UserDict`.",
    "rule_id": "Incompatible variable type [9]",
    "warning_line_no": 87,
    "warning_line": "var.LAST_GOAT = UserDict() # type: UserDict[users.User, datetime]",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": true,
        "source_code": "\nvar.LAST_STATS = None\nvar.LAST_ADMINS = None\nvar.LAST_GSTATS = None\nvar.LAST_PSTATS = None\nvar.LAST_RSTATS = None\nvar.LAST_TIME = None\nvar.LAST_GOAT = UserDict() # type: UserDict[users.User, datetime]\n\nvar.ADMIN_PINGING = False\nvar.DCED_LOSERS = UserSet()\nvar.ADMIN_TO_PING = None\nvar.AFTER_FLASTGAME = None\nvar.PINGING_IFS = False\nvar.TIMERS = {}\nvar.PHASE = \"none\"\nvar.OLD_MODES = defaultdict(set)\n\nvar.ROLES = UserDict() # type: UserDict[str, UserSet]\nvar.ORIGINAL_ROLES = UserDict() # type: UserDict[str, UserSet]\nvar.MAIN_ROLES = UserDict() # type: UserDict[users.User, str]\nvar.ORIGINAL_MAIN_ROLES = UserDict() # type: UserDict[users.User, str]\nvar.FINAL_ROLES = UserDict() # type: UserDict[users.User, str]\nvar.ALL_PLAYERS = UserList()\nvar.FORCE_ROLES = DefaultUserDict(UserSet)\nvar.ORIGINAL_ACCS = UserDict() # type: UserDict[users.User, str]\n\nvar.IDLE_WARNED = UserSet()\nvar.IDLE_WARNED_PM = UserSet()\nvar.NIGHT_IDLED = UserSet()\nvar.NIGHT_IDLE_EXEMPT = UserSet()\n\nvar.DEAD = UserSet()\n\nvar.DEADCHAT_PLAYERS = UserSet()\n\nvar.SPECTATING_WOLFCHAT = UserSet()\nvar.SPECTATING_DEADCHAT = UserSet()\n\nvar.ORIGINAL_SETTINGS = {}\nvar.GAMEMODE_VOTES = UserDict()\n\nvar.LAST_SAID_TIME = UserDict()\n\nvar.GAME_START_TIME = datetime.now()  # for idle checker only\nvar.CAN_START_TIME = 0\nvar.STARTED_DAY_PLAYERS = 0\n\nvar.DISCONNECTED = UserDict() # type: UserDict[User, Tuple[datetime, str]]\n\nvar.RESTARTING = False\n\n",
        "source_code_len": 1411,
        "target_code": "\nvar.LAST_STATS = None  # type: ignore\nvar.LAST_ADMINS = None  # type: ignore\nvar.LAST_GSTATS = None  # type: ignore\nvar.LAST_PSTATS = None  # type: ignore\nvar.LAST_RSTATS = None  # type: ignore\nvar.LAST_TIME = None  # type: ignore\nvar.LAST_GOAT = UserDict() # type: ignore # actually UserDict[users.User, datetime]\n\nvar.ADMIN_PINGING = False  # type: ignore\nvar.DCED_LOSERS = UserSet()  # type: ignore\nvar.ADMIN_TO_PING = None  # type: ignore\nvar.AFTER_FLASTGAME = None  # type: ignore\nvar.PINGING_IFS = False  # type: ignore\nvar.TIMERS = {}  # type: ignore\nvar.PHASE = \"none\"  # type: ignore\nvar.OLD_MODES = defaultdict(set)  # type: ignore\n\nvar.ROLES = UserDict() # type: ignore # actually UserDict[str, UserSet]\nvar.ORIGINAL_ROLES = UserDict() # type: ignore # actually UserDict[str, UserSet]\nvar.MAIN_ROLES = UserDict() # type: ignore # actually UserDict[users.User, str]\nvar.ORIGINAL_MAIN_ROLES = UserDict() # type: ignore # actually UserDict[users.User, str]\nvar.FINAL_ROLES = UserDict() # type: ignore # actually UserDict[users.User, str]\nvar.ALL_PLAYERS = UserList() # type: ignore\nvar.FORCE_ROLES = DefaultUserDict(UserSet) # type: ignore\nvar.ORIGINAL_ACCS = UserDict() # type: ignore # actually UserDict[users.User, str]\n\nvar.IDLE_WARNED = UserSet() # type: ignore\nvar.IDLE_WARNED_PM = UserSet() # type: ignore\nvar.NIGHT_IDLED = UserSet() # type: ignore\nvar.NIGHT_IDLE_EXEMPT = UserSet() # type: ignore\n\nvar.DEAD = UserSet() # type: ignore\n\nvar.DEADCHAT_PLAYERS = UserSet() # type: ignore\n\nvar.SPECTATING_WOLFCHAT = UserSet() # type: ignore\nvar.SPECTATING_DEADCHAT = UserSet() # type: ignore\n\nvar.ORIGINAL_SETTINGS = {} # type: ignore\nvar.GAMEMODE_VOTES = UserDict() # type: ignore\n\nvar.LAST_SAID_TIME = UserDict() # type: ignore\n\nvar.GAME_START_TIME = datetime.now()  # type: ignore # for idle checker only\nvar.CAN_START_TIME = 0 # type: ignore\nvar.STARTED_DAY_PLAYERS = 0 # type: ignore\n\nvar.DISCONNECTED = UserDict() # type: ignore # actually UserDict[User, Tuple[datetime, str]]\n\nvar.RESTARTING = False # type: ignore\n\n",
        "target_code_len": 2034,
        "diff_format": "@@ -80,52 +85,52 @@\n \n-var.LAST_STATS = None\n-var.LAST_ADMINS = None\n-var.LAST_GSTATS = None\n-var.LAST_PSTATS = None\n-var.LAST_RSTATS = None\n-var.LAST_TIME = None\n-var.LAST_GOAT = UserDict() # type: UserDict[users.User, datetime]\n-\n-var.ADMIN_PINGING = False\n-var.DCED_LOSERS = UserSet()\n-var.ADMIN_TO_PING = None\n-var.AFTER_FLASTGAME = None\n-var.PINGING_IFS = False\n-var.TIMERS = {}\n-var.PHASE = \"none\"\n-var.OLD_MODES = defaultdict(set)\n-\n-var.ROLES = UserDict() # type: UserDict[str, UserSet]\n-var.ORIGINAL_ROLES = UserDict() # type: UserDict[str, UserSet]\n-var.MAIN_ROLES = UserDict() # type: UserDict[users.User, str]\n-var.ORIGINAL_MAIN_ROLES = UserDict() # type: UserDict[users.User, str]\n-var.FINAL_ROLES = UserDict() # type: UserDict[users.User, str]\n-var.ALL_PLAYERS = UserList()\n-var.FORCE_ROLES = DefaultUserDict(UserSet)\n-var.ORIGINAL_ACCS = UserDict() # type: UserDict[users.User, str]\n-\n-var.IDLE_WARNED = UserSet()\n-var.IDLE_WARNED_PM = UserSet()\n-var.NIGHT_IDLED = UserSet()\n-var.NIGHT_IDLE_EXEMPT = UserSet()\n-\n-var.DEAD = UserSet()\n-\n-var.DEADCHAT_PLAYERS = UserSet()\n-\n-var.SPECTATING_WOLFCHAT = UserSet()\n-var.SPECTATING_DEADCHAT = UserSet()\n-\n-var.ORIGINAL_SETTINGS = {}\n-var.GAMEMODE_VOTES = UserDict()\n-\n-var.LAST_SAID_TIME = UserDict()\n-\n-var.GAME_START_TIME = datetime.now()  # for idle checker only\n-var.CAN_START_TIME = 0\n-var.STARTED_DAY_PLAYERS = 0\n-\n-var.DISCONNECTED = UserDict() # type: UserDict[User, Tuple[datetime, str]]\n-\n-var.RESTARTING = False\n+var.LAST_STATS = None  # type: ignore\n+var.LAST_ADMINS = None  # type: ignore\n+var.LAST_GSTATS = None  # type: ignore\n+var.LAST_PSTATS = None  # type: ignore\n+var.LAST_RSTATS = None  # type: ignore\n+var.LAST_TIME = None  # type: ignore\n+var.LAST_GOAT = UserDict() # type: ignore # actually UserDict[users.User, datetime]\n+\n+var.ADMIN_PINGING = False  # type: ignore\n+var.DCED_LOSERS = UserSet()  # type: ignore\n+var.ADMIN_TO_PING = None  # type: ignore\n+var.AFTER_FLASTGAME = None  # type: ignore\n+var.PINGING_IFS = False  # type: ignore\n+var.TIMERS = {}  # type: ignore\n+var.PHASE = \"none\"  # type: ignore\n+var.OLD_MODES = defaultdict(set)  # type: ignore\n+\n+var.ROLES = UserDict() # type: ignore # actually UserDict[str, UserSet]\n+var.ORIGINAL_ROLES = UserDict() # type: ignore # actually UserDict[str, UserSet]\n+var.MAIN_ROLES = UserDict() # type: ignore # actually UserDict[users.User, str]\n+var.ORIGINAL_MAIN_ROLES = UserDict() # type: ignore # actually UserDict[users.User, str]\n+var.FINAL_ROLES = UserDict() # type: ignore # actually UserDict[users.User, str]\n+var.ALL_PLAYERS = UserList() # type: ignore\n+var.FORCE_ROLES = DefaultUserDict(UserSet) # type: ignore\n+var.ORIGINAL_ACCS = UserDict() # type: ignore # actually UserDict[users.User, str]\n+\n+var.IDLE_WARNED = UserSet() # type: ignore\n+var.IDLE_WARNED_PM = UserSet() # type: ignore\n+var.NIGHT_IDLED = UserSet() # type: ignore\n+var.NIGHT_IDLE_EXEMPT = UserSet() # type: ignore\n+\n+var.DEAD = UserSet() # type: ignore\n+\n+var.DEADCHAT_PLAYERS = UserSet() # type: ignore\n+\n+var.SPECTATING_WOLFCHAT = UserSet() # type: ignore\n+var.SPECTATING_DEADCHAT = UserSet() # type: ignore\n+\n+var.ORIGINAL_SETTINGS = {} # type: ignore\n+var.GAMEMODE_VOTES = UserDict() # type: ignore\n+\n+var.LAST_SAID_TIME = UserDict() # type: ignore\n+\n+var.GAME_START_TIME = datetime.now()  # type: ignore # for idle checker only\n+var.CAN_START_TIME = 0 # type: ignore\n+var.STARTED_DAY_PLAYERS = 0 # type: ignore\n+\n+var.DISCONNECTED = UserDict() # type: ignore # actually UserDict[User, Tuple[datetime, str]]\n+\n+var.RESTARTING = False # type: ignore\n \n",
        "source_code_with_indent": "\nvar.LAST_STATS = None\nvar.LAST_ADMINS = None\nvar.LAST_GSTATS = None\nvar.LAST_PSTATS = None\nvar.LAST_RSTATS = None\nvar.LAST_TIME = None\nvar.LAST_GOAT = UserDict() # type: UserDict[users.User, datetime]\n\nvar.ADMIN_PINGING = False\nvar.DCED_LOSERS = UserSet()\nvar.ADMIN_TO_PING = None\nvar.AFTER_FLASTGAME = None\nvar.PINGING_IFS = False\nvar.TIMERS = {}\nvar.PHASE = \"none\"\nvar.OLD_MODES = defaultdict(set)\n\nvar.ROLES = UserDict() # type: UserDict[str, UserSet]\nvar.ORIGINAL_ROLES = UserDict() # type: UserDict[str, UserSet]\nvar.MAIN_ROLES = UserDict() # type: UserDict[users.User, str]\nvar.ORIGINAL_MAIN_ROLES = UserDict() # type: UserDict[users.User, str]\nvar.FINAL_ROLES = UserDict() # type: UserDict[users.User, str]\nvar.ALL_PLAYERS = UserList()\nvar.FORCE_ROLES = DefaultUserDict(UserSet)\nvar.ORIGINAL_ACCS = UserDict() # type: UserDict[users.User, str]\n\nvar.IDLE_WARNED = UserSet()\nvar.IDLE_WARNED_PM = UserSet()\nvar.NIGHT_IDLED = UserSet()\nvar.NIGHT_IDLE_EXEMPT = UserSet()\n\nvar.DEAD = UserSet()\n\nvar.DEADCHAT_PLAYERS = UserSet()\n\nvar.SPECTATING_WOLFCHAT = UserSet()\nvar.SPECTATING_DEADCHAT = UserSet()\n\nvar.ORIGINAL_SETTINGS = {}\nvar.GAMEMODE_VOTES = UserDict()\n\nvar.LAST_SAID_TIME = UserDict()\n\nvar.GAME_START_TIME = datetime.now()  # for idle checker only\nvar.CAN_START_TIME = 0\nvar.STARTED_DAY_PLAYERS = 0\n\nvar.DISCONNECTED = UserDict() # type: UserDict[User, Tuple[datetime, str]]\n\nvar.RESTARTING = False\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\nvar.LAST_STATS = None  # type: ignore\nvar.LAST_ADMINS = None  # type: ignore\nvar.LAST_GSTATS = None  # type: ignore\nvar.LAST_PSTATS = None  # type: ignore\nvar.LAST_RSTATS = None  # type: ignore\nvar.LAST_TIME = None  # type: ignore\nvar.LAST_GOAT = UserDict() # type: ignore # actually UserDict[users.User, datetime]\n\nvar.ADMIN_PINGING = False  # type: ignore\nvar.DCED_LOSERS = UserSet()  # type: ignore\nvar.ADMIN_TO_PING = None  # type: ignore\nvar.AFTER_FLASTGAME = None  # type: ignore\nvar.PINGING_IFS = False  # type: ignore\nvar.TIMERS = {}  # type: ignore\nvar.PHASE = \"none\"  # type: ignore\nvar.OLD_MODES = defaultdict(set)  # type: ignore\n\nvar.ROLES = UserDict() # type: ignore # actually UserDict[str, UserSet]\nvar.ORIGINAL_ROLES = UserDict() # type: ignore # actually UserDict[str, UserSet]\nvar.MAIN_ROLES = UserDict() # type: ignore # actually UserDict[users.User, str]\nvar.ORIGINAL_MAIN_ROLES = UserDict() # type: ignore # actually UserDict[users.User, str]\nvar.FINAL_ROLES = UserDict() # type: ignore # actually UserDict[users.User, str]\nvar.ALL_PLAYERS = UserList() # type: ignore\nvar.FORCE_ROLES = DefaultUserDict(UserSet) # type: ignore\nvar.ORIGINAL_ACCS = UserDict() # type: ignore # actually UserDict[users.User, str]\n\nvar.IDLE_WARNED = UserSet() # type: ignore\nvar.IDLE_WARNED_PM = UserSet() # type: ignore\nvar.NIGHT_IDLED = UserSet() # type: ignore\nvar.NIGHT_IDLE_EXEMPT = UserSet() # type: ignore\n\nvar.DEAD = UserSet() # type: ignore\n\nvar.DEADCHAT_PLAYERS = UserSet() # type: ignore\n\nvar.SPECTATING_WOLFCHAT = UserSet() # type: ignore\nvar.SPECTATING_DEADCHAT = UserSet() # type: ignore\n\nvar.ORIGINAL_SETTINGS = {} # type: ignore\nvar.GAMEMODE_VOTES = UserDict() # type: ignore\n\nvar.LAST_SAID_TIME = UserDict() # type: ignore\n\nvar.GAME_START_TIME = datetime.now()  # type: ignore # for idle checker only\nvar.CAN_START_TIME = 0 # type: ignore\nvar.STARTED_DAY_PLAYERS = 0 # type: ignore\n\nvar.DISCONNECTED = UserDict() # type: ignore # actually UserDict[User, Tuple[datetime, str]]\n\nvar.RESTARTING = False # type: ignore\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "lykoss/lykos",
    "commit": "f8560e10e9e8cc4b4a3b8e750865c4079f7c9b37",
    "filename": "src/wolfgame.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/lykoss-lykos/src/wolfgame.py",
    "file_hunks_size": 7,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": true,
    "full_warning_msg": "src/wolfgame.py:98:0 Incompatible variable type [9]: src.settings.ROLES is declared to have type `UserDict[]` but is used as type `UserDict`.",
    "message": " src.settings.ROLES is declared to have type `UserDict[]` but is used as type `UserDict`.",
    "rule_id": "Incompatible variable type [9]",
    "warning_line_no": 98,
    "warning_line": "var.ROLES = UserDict() # type: UserDict[str, UserSet]",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": true,
        "source_code": "\nvar.LAST_STATS = None\nvar.LAST_ADMINS = None\nvar.LAST_GSTATS = None\nvar.LAST_PSTATS = None\nvar.LAST_RSTATS = None\nvar.LAST_TIME = None\nvar.LAST_GOAT = UserDict() # type: UserDict[users.User, datetime]\n\nvar.ADMIN_PINGING = False\nvar.DCED_LOSERS = UserSet()\nvar.ADMIN_TO_PING = None\nvar.AFTER_FLASTGAME = None\nvar.PINGING_IFS = False\nvar.TIMERS = {}\nvar.PHASE = \"none\"\nvar.OLD_MODES = defaultdict(set)\n\nvar.ROLES = UserDict() # type: UserDict[str, UserSet]\nvar.ORIGINAL_ROLES = UserDict() # type: UserDict[str, UserSet]\nvar.MAIN_ROLES = UserDict() # type: UserDict[users.User, str]\nvar.ORIGINAL_MAIN_ROLES = UserDict() # type: UserDict[users.User, str]\nvar.FINAL_ROLES = UserDict() # type: UserDict[users.User, str]\nvar.ALL_PLAYERS = UserList()\nvar.FORCE_ROLES = DefaultUserDict(UserSet)\nvar.ORIGINAL_ACCS = UserDict() # type: UserDict[users.User, str]\n\nvar.IDLE_WARNED = UserSet()\nvar.IDLE_WARNED_PM = UserSet()\nvar.NIGHT_IDLED = UserSet()\nvar.NIGHT_IDLE_EXEMPT = UserSet()\n\nvar.DEAD = UserSet()\n\nvar.DEADCHAT_PLAYERS = UserSet()\n\nvar.SPECTATING_WOLFCHAT = UserSet()\nvar.SPECTATING_DEADCHAT = UserSet()\n\nvar.ORIGINAL_SETTINGS = {}\nvar.GAMEMODE_VOTES = UserDict()\n\nvar.LAST_SAID_TIME = UserDict()\n\nvar.GAME_START_TIME = datetime.now()  # for idle checker only\nvar.CAN_START_TIME = 0\nvar.STARTED_DAY_PLAYERS = 0\n\nvar.DISCONNECTED = UserDict() # type: UserDict[User, Tuple[datetime, str]]\n\nvar.RESTARTING = False\n\n",
        "source_code_len": 1411,
        "target_code": "\nvar.LAST_STATS = None  # type: ignore\nvar.LAST_ADMINS = None  # type: ignore\nvar.LAST_GSTATS = None  # type: ignore\nvar.LAST_PSTATS = None  # type: ignore\nvar.LAST_RSTATS = None  # type: ignore\nvar.LAST_TIME = None  # type: ignore\nvar.LAST_GOAT = UserDict() # type: ignore # actually UserDict[users.User, datetime]\n\nvar.ADMIN_PINGING = False  # type: ignore\nvar.DCED_LOSERS = UserSet()  # type: ignore\nvar.ADMIN_TO_PING = None  # type: ignore\nvar.AFTER_FLASTGAME = None  # type: ignore\nvar.PINGING_IFS = False  # type: ignore\nvar.TIMERS = {}  # type: ignore\nvar.PHASE = \"none\"  # type: ignore\nvar.OLD_MODES = defaultdict(set)  # type: ignore\n\nvar.ROLES = UserDict() # type: ignore # actually UserDict[str, UserSet]\nvar.ORIGINAL_ROLES = UserDict() # type: ignore # actually UserDict[str, UserSet]\nvar.MAIN_ROLES = UserDict() # type: ignore # actually UserDict[users.User, str]\nvar.ORIGINAL_MAIN_ROLES = UserDict() # type: ignore # actually UserDict[users.User, str]\nvar.FINAL_ROLES = UserDict() # type: ignore # actually UserDict[users.User, str]\nvar.ALL_PLAYERS = UserList() # type: ignore\nvar.FORCE_ROLES = DefaultUserDict(UserSet) # type: ignore\nvar.ORIGINAL_ACCS = UserDict() # type: ignore # actually UserDict[users.User, str]\n\nvar.IDLE_WARNED = UserSet() # type: ignore\nvar.IDLE_WARNED_PM = UserSet() # type: ignore\nvar.NIGHT_IDLED = UserSet() # type: ignore\nvar.NIGHT_IDLE_EXEMPT = UserSet() # type: ignore\n\nvar.DEAD = UserSet() # type: ignore\n\nvar.DEADCHAT_PLAYERS = UserSet() # type: ignore\n\nvar.SPECTATING_WOLFCHAT = UserSet() # type: ignore\nvar.SPECTATING_DEADCHAT = UserSet() # type: ignore\n\nvar.ORIGINAL_SETTINGS = {} # type: ignore\nvar.GAMEMODE_VOTES = UserDict() # type: ignore\n\nvar.LAST_SAID_TIME = UserDict() # type: ignore\n\nvar.GAME_START_TIME = datetime.now()  # type: ignore # for idle checker only\nvar.CAN_START_TIME = 0 # type: ignore\nvar.STARTED_DAY_PLAYERS = 0 # type: ignore\n\nvar.DISCONNECTED = UserDict() # type: ignore # actually UserDict[User, Tuple[datetime, str]]\n\nvar.RESTARTING = False # type: ignore\n\n",
        "target_code_len": 2034,
        "diff_format": "@@ -80,52 +85,52 @@\n \n-var.LAST_STATS = None\n-var.LAST_ADMINS = None\n-var.LAST_GSTATS = None\n-var.LAST_PSTATS = None\n-var.LAST_RSTATS = None\n-var.LAST_TIME = None\n-var.LAST_GOAT = UserDict() # type: UserDict[users.User, datetime]\n-\n-var.ADMIN_PINGING = False\n-var.DCED_LOSERS = UserSet()\n-var.ADMIN_TO_PING = None\n-var.AFTER_FLASTGAME = None\n-var.PINGING_IFS = False\n-var.TIMERS = {}\n-var.PHASE = \"none\"\n-var.OLD_MODES = defaultdict(set)\n-\n-var.ROLES = UserDict() # type: UserDict[str, UserSet]\n-var.ORIGINAL_ROLES = UserDict() # type: UserDict[str, UserSet]\n-var.MAIN_ROLES = UserDict() # type: UserDict[users.User, str]\n-var.ORIGINAL_MAIN_ROLES = UserDict() # type: UserDict[users.User, str]\n-var.FINAL_ROLES = UserDict() # type: UserDict[users.User, str]\n-var.ALL_PLAYERS = UserList()\n-var.FORCE_ROLES = DefaultUserDict(UserSet)\n-var.ORIGINAL_ACCS = UserDict() # type: UserDict[users.User, str]\n-\n-var.IDLE_WARNED = UserSet()\n-var.IDLE_WARNED_PM = UserSet()\n-var.NIGHT_IDLED = UserSet()\n-var.NIGHT_IDLE_EXEMPT = UserSet()\n-\n-var.DEAD = UserSet()\n-\n-var.DEADCHAT_PLAYERS = UserSet()\n-\n-var.SPECTATING_WOLFCHAT = UserSet()\n-var.SPECTATING_DEADCHAT = UserSet()\n-\n-var.ORIGINAL_SETTINGS = {}\n-var.GAMEMODE_VOTES = UserDict()\n-\n-var.LAST_SAID_TIME = UserDict()\n-\n-var.GAME_START_TIME = datetime.now()  # for idle checker only\n-var.CAN_START_TIME = 0\n-var.STARTED_DAY_PLAYERS = 0\n-\n-var.DISCONNECTED = UserDict() # type: UserDict[User, Tuple[datetime, str]]\n-\n-var.RESTARTING = False\n+var.LAST_STATS = None  # type: ignore\n+var.LAST_ADMINS = None  # type: ignore\n+var.LAST_GSTATS = None  # type: ignore\n+var.LAST_PSTATS = None  # type: ignore\n+var.LAST_RSTATS = None  # type: ignore\n+var.LAST_TIME = None  # type: ignore\n+var.LAST_GOAT = UserDict() # type: ignore # actually UserDict[users.User, datetime]\n+\n+var.ADMIN_PINGING = False  # type: ignore\n+var.DCED_LOSERS = UserSet()  # type: ignore\n+var.ADMIN_TO_PING = None  # type: ignore\n+var.AFTER_FLASTGAME = None  # type: ignore\n+var.PINGING_IFS = False  # type: ignore\n+var.TIMERS = {}  # type: ignore\n+var.PHASE = \"none\"  # type: ignore\n+var.OLD_MODES = defaultdict(set)  # type: ignore\n+\n+var.ROLES = UserDict() # type: ignore # actually UserDict[str, UserSet]\n+var.ORIGINAL_ROLES = UserDict() # type: ignore # actually UserDict[str, UserSet]\n+var.MAIN_ROLES = UserDict() # type: ignore # actually UserDict[users.User, str]\n+var.ORIGINAL_MAIN_ROLES = UserDict() # type: ignore # actually UserDict[users.User, str]\n+var.FINAL_ROLES = UserDict() # type: ignore # actually UserDict[users.User, str]\n+var.ALL_PLAYERS = UserList() # type: ignore\n+var.FORCE_ROLES = DefaultUserDict(UserSet) # type: ignore\n+var.ORIGINAL_ACCS = UserDict() # type: ignore # actually UserDict[users.User, str]\n+\n+var.IDLE_WARNED = UserSet() # type: ignore\n+var.IDLE_WARNED_PM = UserSet() # type: ignore\n+var.NIGHT_IDLED = UserSet() # type: ignore\n+var.NIGHT_IDLE_EXEMPT = UserSet() # type: ignore\n+\n+var.DEAD = UserSet() # type: ignore\n+\n+var.DEADCHAT_PLAYERS = UserSet() # type: ignore\n+\n+var.SPECTATING_WOLFCHAT = UserSet() # type: ignore\n+var.SPECTATING_DEADCHAT = UserSet() # type: ignore\n+\n+var.ORIGINAL_SETTINGS = {} # type: ignore\n+var.GAMEMODE_VOTES = UserDict() # type: ignore\n+\n+var.LAST_SAID_TIME = UserDict() # type: ignore\n+\n+var.GAME_START_TIME = datetime.now()  # type: ignore # for idle checker only\n+var.CAN_START_TIME = 0 # type: ignore\n+var.STARTED_DAY_PLAYERS = 0 # type: ignore\n+\n+var.DISCONNECTED = UserDict() # type: ignore # actually UserDict[User, Tuple[datetime, str]]\n+\n+var.RESTARTING = False # type: ignore\n \n",
        "source_code_with_indent": "\nvar.LAST_STATS = None\nvar.LAST_ADMINS = None\nvar.LAST_GSTATS = None\nvar.LAST_PSTATS = None\nvar.LAST_RSTATS = None\nvar.LAST_TIME = None\nvar.LAST_GOAT = UserDict() # type: UserDict[users.User, datetime]\n\nvar.ADMIN_PINGING = False\nvar.DCED_LOSERS = UserSet()\nvar.ADMIN_TO_PING = None\nvar.AFTER_FLASTGAME = None\nvar.PINGING_IFS = False\nvar.TIMERS = {}\nvar.PHASE = \"none\"\nvar.OLD_MODES = defaultdict(set)\n\nvar.ROLES = UserDict() # type: UserDict[str, UserSet]\nvar.ORIGINAL_ROLES = UserDict() # type: UserDict[str, UserSet]\nvar.MAIN_ROLES = UserDict() # type: UserDict[users.User, str]\nvar.ORIGINAL_MAIN_ROLES = UserDict() # type: UserDict[users.User, str]\nvar.FINAL_ROLES = UserDict() # type: UserDict[users.User, str]\nvar.ALL_PLAYERS = UserList()\nvar.FORCE_ROLES = DefaultUserDict(UserSet)\nvar.ORIGINAL_ACCS = UserDict() # type: UserDict[users.User, str]\n\nvar.IDLE_WARNED = UserSet()\nvar.IDLE_WARNED_PM = UserSet()\nvar.NIGHT_IDLED = UserSet()\nvar.NIGHT_IDLE_EXEMPT = UserSet()\n\nvar.DEAD = UserSet()\n\nvar.DEADCHAT_PLAYERS = UserSet()\n\nvar.SPECTATING_WOLFCHAT = UserSet()\nvar.SPECTATING_DEADCHAT = UserSet()\n\nvar.ORIGINAL_SETTINGS = {}\nvar.GAMEMODE_VOTES = UserDict()\n\nvar.LAST_SAID_TIME = UserDict()\n\nvar.GAME_START_TIME = datetime.now()  # for idle checker only\nvar.CAN_START_TIME = 0\nvar.STARTED_DAY_PLAYERS = 0\n\nvar.DISCONNECTED = UserDict() # type: UserDict[User, Tuple[datetime, str]]\n\nvar.RESTARTING = False\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\nvar.LAST_STATS = None  # type: ignore\nvar.LAST_ADMINS = None  # type: ignore\nvar.LAST_GSTATS = None  # type: ignore\nvar.LAST_PSTATS = None  # type: ignore\nvar.LAST_RSTATS = None  # type: ignore\nvar.LAST_TIME = None  # type: ignore\nvar.LAST_GOAT = UserDict() # type: ignore # actually UserDict[users.User, datetime]\n\nvar.ADMIN_PINGING = False  # type: ignore\nvar.DCED_LOSERS = UserSet()  # type: ignore\nvar.ADMIN_TO_PING = None  # type: ignore\nvar.AFTER_FLASTGAME = None  # type: ignore\nvar.PINGING_IFS = False  # type: ignore\nvar.TIMERS = {}  # type: ignore\nvar.PHASE = \"none\"  # type: ignore\nvar.OLD_MODES = defaultdict(set)  # type: ignore\n\nvar.ROLES = UserDict() # type: ignore # actually UserDict[str, UserSet]\nvar.ORIGINAL_ROLES = UserDict() # type: ignore # actually UserDict[str, UserSet]\nvar.MAIN_ROLES = UserDict() # type: ignore # actually UserDict[users.User, str]\nvar.ORIGINAL_MAIN_ROLES = UserDict() # type: ignore # actually UserDict[users.User, str]\nvar.FINAL_ROLES = UserDict() # type: ignore # actually UserDict[users.User, str]\nvar.ALL_PLAYERS = UserList() # type: ignore\nvar.FORCE_ROLES = DefaultUserDict(UserSet) # type: ignore\nvar.ORIGINAL_ACCS = UserDict() # type: ignore # actually UserDict[users.User, str]\n\nvar.IDLE_WARNED = UserSet() # type: ignore\nvar.IDLE_WARNED_PM = UserSet() # type: ignore\nvar.NIGHT_IDLED = UserSet() # type: ignore\nvar.NIGHT_IDLE_EXEMPT = UserSet() # type: ignore\n\nvar.DEAD = UserSet() # type: ignore\n\nvar.DEADCHAT_PLAYERS = UserSet() # type: ignore\n\nvar.SPECTATING_WOLFCHAT = UserSet() # type: ignore\nvar.SPECTATING_DEADCHAT = UserSet() # type: ignore\n\nvar.ORIGINAL_SETTINGS = {} # type: ignore\nvar.GAMEMODE_VOTES = UserDict() # type: ignore\n\nvar.LAST_SAID_TIME = UserDict() # type: ignore\n\nvar.GAME_START_TIME = datetime.now()  # type: ignore # for idle checker only\nvar.CAN_START_TIME = 0 # type: ignore\nvar.STARTED_DAY_PLAYERS = 0 # type: ignore\n\nvar.DISCONNECTED = UserDict() # type: ignore # actually UserDict[User, Tuple[datetime, str]]\n\nvar.RESTARTING = False # type: ignore\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "lykoss/lykos",
    "commit": "f8560e10e9e8cc4b4a3b8e750865c4079f7c9b37",
    "filename": "src/wolfgame.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/lykoss-lykos/src/wolfgame.py",
    "file_hunks_size": 7,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": true,
    "full_warning_msg": "src/wolfgame.py:99:0 Incompatible variable type [9]: src.settings.ORIGINAL_ROLES is declared to have type `UserDict[]` but is used as type `UserDict`.",
    "message": " src.settings.ORIGINAL_ROLES is declared to have type `UserDict[]` but is used as type `UserDict`.",
    "rule_id": "Incompatible variable type [9]",
    "warning_line_no": 99,
    "warning_line": "var.ORIGINAL_ROLES = UserDict() # type: UserDict[str, UserSet]",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": true,
        "source_code": "\nvar.LAST_STATS = None\nvar.LAST_ADMINS = None\nvar.LAST_GSTATS = None\nvar.LAST_PSTATS = None\nvar.LAST_RSTATS = None\nvar.LAST_TIME = None\nvar.LAST_GOAT = UserDict() # type: UserDict[users.User, datetime]\n\nvar.ADMIN_PINGING = False\nvar.DCED_LOSERS = UserSet()\nvar.ADMIN_TO_PING = None\nvar.AFTER_FLASTGAME = None\nvar.PINGING_IFS = False\nvar.TIMERS = {}\nvar.PHASE = \"none\"\nvar.OLD_MODES = defaultdict(set)\n\nvar.ROLES = UserDict() # type: UserDict[str, UserSet]\nvar.ORIGINAL_ROLES = UserDict() # type: UserDict[str, UserSet]\nvar.MAIN_ROLES = UserDict() # type: UserDict[users.User, str]\nvar.ORIGINAL_MAIN_ROLES = UserDict() # type: UserDict[users.User, str]\nvar.FINAL_ROLES = UserDict() # type: UserDict[users.User, str]\nvar.ALL_PLAYERS = UserList()\nvar.FORCE_ROLES = DefaultUserDict(UserSet)\nvar.ORIGINAL_ACCS = UserDict() # type: UserDict[users.User, str]\n\nvar.IDLE_WARNED = UserSet()\nvar.IDLE_WARNED_PM = UserSet()\nvar.NIGHT_IDLED = UserSet()\nvar.NIGHT_IDLE_EXEMPT = UserSet()\n\nvar.DEAD = UserSet()\n\nvar.DEADCHAT_PLAYERS = UserSet()\n\nvar.SPECTATING_WOLFCHAT = UserSet()\nvar.SPECTATING_DEADCHAT = UserSet()\n\nvar.ORIGINAL_SETTINGS = {}\nvar.GAMEMODE_VOTES = UserDict()\n\nvar.LAST_SAID_TIME = UserDict()\n\nvar.GAME_START_TIME = datetime.now()  # for idle checker only\nvar.CAN_START_TIME = 0\nvar.STARTED_DAY_PLAYERS = 0\n\nvar.DISCONNECTED = UserDict() # type: UserDict[User, Tuple[datetime, str]]\n\nvar.RESTARTING = False\n\n",
        "source_code_len": 1411,
        "target_code": "\nvar.LAST_STATS = None  # type: ignore\nvar.LAST_ADMINS = None  # type: ignore\nvar.LAST_GSTATS = None  # type: ignore\nvar.LAST_PSTATS = None  # type: ignore\nvar.LAST_RSTATS = None  # type: ignore\nvar.LAST_TIME = None  # type: ignore\nvar.LAST_GOAT = UserDict() # type: ignore # actually UserDict[users.User, datetime]\n\nvar.ADMIN_PINGING = False  # type: ignore\nvar.DCED_LOSERS = UserSet()  # type: ignore\nvar.ADMIN_TO_PING = None  # type: ignore\nvar.AFTER_FLASTGAME = None  # type: ignore\nvar.PINGING_IFS = False  # type: ignore\nvar.TIMERS = {}  # type: ignore\nvar.PHASE = \"none\"  # type: ignore\nvar.OLD_MODES = defaultdict(set)  # type: ignore\n\nvar.ROLES = UserDict() # type: ignore # actually UserDict[str, UserSet]\nvar.ORIGINAL_ROLES = UserDict() # type: ignore # actually UserDict[str, UserSet]\nvar.MAIN_ROLES = UserDict() # type: ignore # actually UserDict[users.User, str]\nvar.ORIGINAL_MAIN_ROLES = UserDict() # type: ignore # actually UserDict[users.User, str]\nvar.FINAL_ROLES = UserDict() # type: ignore # actually UserDict[users.User, str]\nvar.ALL_PLAYERS = UserList() # type: ignore\nvar.FORCE_ROLES = DefaultUserDict(UserSet) # type: ignore\nvar.ORIGINAL_ACCS = UserDict() # type: ignore # actually UserDict[users.User, str]\n\nvar.IDLE_WARNED = UserSet() # type: ignore\nvar.IDLE_WARNED_PM = UserSet() # type: ignore\nvar.NIGHT_IDLED = UserSet() # type: ignore\nvar.NIGHT_IDLE_EXEMPT = UserSet() # type: ignore\n\nvar.DEAD = UserSet() # type: ignore\n\nvar.DEADCHAT_PLAYERS = UserSet() # type: ignore\n\nvar.SPECTATING_WOLFCHAT = UserSet() # type: ignore\nvar.SPECTATING_DEADCHAT = UserSet() # type: ignore\n\nvar.ORIGINAL_SETTINGS = {} # type: ignore\nvar.GAMEMODE_VOTES = UserDict() # type: ignore\n\nvar.LAST_SAID_TIME = UserDict() # type: ignore\n\nvar.GAME_START_TIME = datetime.now()  # type: ignore # for idle checker only\nvar.CAN_START_TIME = 0 # type: ignore\nvar.STARTED_DAY_PLAYERS = 0 # type: ignore\n\nvar.DISCONNECTED = UserDict() # type: ignore # actually UserDict[User, Tuple[datetime, str]]\n\nvar.RESTARTING = False # type: ignore\n\n",
        "target_code_len": 2034,
        "diff_format": "@@ -80,52 +85,52 @@\n \n-var.LAST_STATS = None\n-var.LAST_ADMINS = None\n-var.LAST_GSTATS = None\n-var.LAST_PSTATS = None\n-var.LAST_RSTATS = None\n-var.LAST_TIME = None\n-var.LAST_GOAT = UserDict() # type: UserDict[users.User, datetime]\n-\n-var.ADMIN_PINGING = False\n-var.DCED_LOSERS = UserSet()\n-var.ADMIN_TO_PING = None\n-var.AFTER_FLASTGAME = None\n-var.PINGING_IFS = False\n-var.TIMERS = {}\n-var.PHASE = \"none\"\n-var.OLD_MODES = defaultdict(set)\n-\n-var.ROLES = UserDict() # type: UserDict[str, UserSet]\n-var.ORIGINAL_ROLES = UserDict() # type: UserDict[str, UserSet]\n-var.MAIN_ROLES = UserDict() # type: UserDict[users.User, str]\n-var.ORIGINAL_MAIN_ROLES = UserDict() # type: UserDict[users.User, str]\n-var.FINAL_ROLES = UserDict() # type: UserDict[users.User, str]\n-var.ALL_PLAYERS = UserList()\n-var.FORCE_ROLES = DefaultUserDict(UserSet)\n-var.ORIGINAL_ACCS = UserDict() # type: UserDict[users.User, str]\n-\n-var.IDLE_WARNED = UserSet()\n-var.IDLE_WARNED_PM = UserSet()\n-var.NIGHT_IDLED = UserSet()\n-var.NIGHT_IDLE_EXEMPT = UserSet()\n-\n-var.DEAD = UserSet()\n-\n-var.DEADCHAT_PLAYERS = UserSet()\n-\n-var.SPECTATING_WOLFCHAT = UserSet()\n-var.SPECTATING_DEADCHAT = UserSet()\n-\n-var.ORIGINAL_SETTINGS = {}\n-var.GAMEMODE_VOTES = UserDict()\n-\n-var.LAST_SAID_TIME = UserDict()\n-\n-var.GAME_START_TIME = datetime.now()  # for idle checker only\n-var.CAN_START_TIME = 0\n-var.STARTED_DAY_PLAYERS = 0\n-\n-var.DISCONNECTED = UserDict() # type: UserDict[User, Tuple[datetime, str]]\n-\n-var.RESTARTING = False\n+var.LAST_STATS = None  # type: ignore\n+var.LAST_ADMINS = None  # type: ignore\n+var.LAST_GSTATS = None  # type: ignore\n+var.LAST_PSTATS = None  # type: ignore\n+var.LAST_RSTATS = None  # type: ignore\n+var.LAST_TIME = None  # type: ignore\n+var.LAST_GOAT = UserDict() # type: ignore # actually UserDict[users.User, datetime]\n+\n+var.ADMIN_PINGING = False  # type: ignore\n+var.DCED_LOSERS = UserSet()  # type: ignore\n+var.ADMIN_TO_PING = None  # type: ignore\n+var.AFTER_FLASTGAME = None  # type: ignore\n+var.PINGING_IFS = False  # type: ignore\n+var.TIMERS = {}  # type: ignore\n+var.PHASE = \"none\"  # type: ignore\n+var.OLD_MODES = defaultdict(set)  # type: ignore\n+\n+var.ROLES = UserDict() # type: ignore # actually UserDict[str, UserSet]\n+var.ORIGINAL_ROLES = UserDict() # type: ignore # actually UserDict[str, UserSet]\n+var.MAIN_ROLES = UserDict() # type: ignore # actually UserDict[users.User, str]\n+var.ORIGINAL_MAIN_ROLES = UserDict() # type: ignore # actually UserDict[users.User, str]\n+var.FINAL_ROLES = UserDict() # type: ignore # actually UserDict[users.User, str]\n+var.ALL_PLAYERS = UserList() # type: ignore\n+var.FORCE_ROLES = DefaultUserDict(UserSet) # type: ignore\n+var.ORIGINAL_ACCS = UserDict() # type: ignore # actually UserDict[users.User, str]\n+\n+var.IDLE_WARNED = UserSet() # type: ignore\n+var.IDLE_WARNED_PM = UserSet() # type: ignore\n+var.NIGHT_IDLED = UserSet() # type: ignore\n+var.NIGHT_IDLE_EXEMPT = UserSet() # type: ignore\n+\n+var.DEAD = UserSet() # type: ignore\n+\n+var.DEADCHAT_PLAYERS = UserSet() # type: ignore\n+\n+var.SPECTATING_WOLFCHAT = UserSet() # type: ignore\n+var.SPECTATING_DEADCHAT = UserSet() # type: ignore\n+\n+var.ORIGINAL_SETTINGS = {} # type: ignore\n+var.GAMEMODE_VOTES = UserDict() # type: ignore\n+\n+var.LAST_SAID_TIME = UserDict() # type: ignore\n+\n+var.GAME_START_TIME = datetime.now()  # type: ignore # for idle checker only\n+var.CAN_START_TIME = 0 # type: ignore\n+var.STARTED_DAY_PLAYERS = 0 # type: ignore\n+\n+var.DISCONNECTED = UserDict() # type: ignore # actually UserDict[User, Tuple[datetime, str]]\n+\n+var.RESTARTING = False # type: ignore\n \n",
        "source_code_with_indent": "\nvar.LAST_STATS = None\nvar.LAST_ADMINS = None\nvar.LAST_GSTATS = None\nvar.LAST_PSTATS = None\nvar.LAST_RSTATS = None\nvar.LAST_TIME = None\nvar.LAST_GOAT = UserDict() # type: UserDict[users.User, datetime]\n\nvar.ADMIN_PINGING = False\nvar.DCED_LOSERS = UserSet()\nvar.ADMIN_TO_PING = None\nvar.AFTER_FLASTGAME = None\nvar.PINGING_IFS = False\nvar.TIMERS = {}\nvar.PHASE = \"none\"\nvar.OLD_MODES = defaultdict(set)\n\nvar.ROLES = UserDict() # type: UserDict[str, UserSet]\nvar.ORIGINAL_ROLES = UserDict() # type: UserDict[str, UserSet]\nvar.MAIN_ROLES = UserDict() # type: UserDict[users.User, str]\nvar.ORIGINAL_MAIN_ROLES = UserDict() # type: UserDict[users.User, str]\nvar.FINAL_ROLES = UserDict() # type: UserDict[users.User, str]\nvar.ALL_PLAYERS = UserList()\nvar.FORCE_ROLES = DefaultUserDict(UserSet)\nvar.ORIGINAL_ACCS = UserDict() # type: UserDict[users.User, str]\n\nvar.IDLE_WARNED = UserSet()\nvar.IDLE_WARNED_PM = UserSet()\nvar.NIGHT_IDLED = UserSet()\nvar.NIGHT_IDLE_EXEMPT = UserSet()\n\nvar.DEAD = UserSet()\n\nvar.DEADCHAT_PLAYERS = UserSet()\n\nvar.SPECTATING_WOLFCHAT = UserSet()\nvar.SPECTATING_DEADCHAT = UserSet()\n\nvar.ORIGINAL_SETTINGS = {}\nvar.GAMEMODE_VOTES = UserDict()\n\nvar.LAST_SAID_TIME = UserDict()\n\nvar.GAME_START_TIME = datetime.now()  # for idle checker only\nvar.CAN_START_TIME = 0\nvar.STARTED_DAY_PLAYERS = 0\n\nvar.DISCONNECTED = UserDict() # type: UserDict[User, Tuple[datetime, str]]\n\nvar.RESTARTING = False\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\nvar.LAST_STATS = None  # type: ignore\nvar.LAST_ADMINS = None  # type: ignore\nvar.LAST_GSTATS = None  # type: ignore\nvar.LAST_PSTATS = None  # type: ignore\nvar.LAST_RSTATS = None  # type: ignore\nvar.LAST_TIME = None  # type: ignore\nvar.LAST_GOAT = UserDict() # type: ignore # actually UserDict[users.User, datetime]\n\nvar.ADMIN_PINGING = False  # type: ignore\nvar.DCED_LOSERS = UserSet()  # type: ignore\nvar.ADMIN_TO_PING = None  # type: ignore\nvar.AFTER_FLASTGAME = None  # type: ignore\nvar.PINGING_IFS = False  # type: ignore\nvar.TIMERS = {}  # type: ignore\nvar.PHASE = \"none\"  # type: ignore\nvar.OLD_MODES = defaultdict(set)  # type: ignore\n\nvar.ROLES = UserDict() # type: ignore # actually UserDict[str, UserSet]\nvar.ORIGINAL_ROLES = UserDict() # type: ignore # actually UserDict[str, UserSet]\nvar.MAIN_ROLES = UserDict() # type: ignore # actually UserDict[users.User, str]\nvar.ORIGINAL_MAIN_ROLES = UserDict() # type: ignore # actually UserDict[users.User, str]\nvar.FINAL_ROLES = UserDict() # type: ignore # actually UserDict[users.User, str]\nvar.ALL_PLAYERS = UserList() # type: ignore\nvar.FORCE_ROLES = DefaultUserDict(UserSet) # type: ignore\nvar.ORIGINAL_ACCS = UserDict() # type: ignore # actually UserDict[users.User, str]\n\nvar.IDLE_WARNED = UserSet() # type: ignore\nvar.IDLE_WARNED_PM = UserSet() # type: ignore\nvar.NIGHT_IDLED = UserSet() # type: ignore\nvar.NIGHT_IDLE_EXEMPT = UserSet() # type: ignore\n\nvar.DEAD = UserSet() # type: ignore\n\nvar.DEADCHAT_PLAYERS = UserSet() # type: ignore\n\nvar.SPECTATING_WOLFCHAT = UserSet() # type: ignore\nvar.SPECTATING_DEADCHAT = UserSet() # type: ignore\n\nvar.ORIGINAL_SETTINGS = {} # type: ignore\nvar.GAMEMODE_VOTES = UserDict() # type: ignore\n\nvar.LAST_SAID_TIME = UserDict() # type: ignore\n\nvar.GAME_START_TIME = datetime.now()  # type: ignore # for idle checker only\nvar.CAN_START_TIME = 0 # type: ignore\nvar.STARTED_DAY_PLAYERS = 0 # type: ignore\n\nvar.DISCONNECTED = UserDict() # type: ignore # actually UserDict[User, Tuple[datetime, str]]\n\nvar.RESTARTING = False # type: ignore\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "lykoss/lykos",
    "commit": "f8560e10e9e8cc4b4a3b8e750865c4079f7c9b37",
    "filename": "src/wolfgame.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/lykoss-lykos/src/wolfgame.py",
    "file_hunks_size": 7,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": true,
    "full_warning_msg": "src/wolfgame.py:100:0 Incompatible variable type [9]: src.settings.MAIN_ROLES is declared to have type `UserDict[]` but is used as type `UserDict`.",
    "message": " src.settings.MAIN_ROLES is declared to have type `UserDict[]` but is used as type `UserDict`.",
    "rule_id": "Incompatible variable type [9]",
    "warning_line_no": 100,
    "warning_line": "var.MAIN_ROLES = UserDict() # type: UserDict[users.User, str]",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": true,
        "source_code": "\nvar.LAST_STATS = None\nvar.LAST_ADMINS = None\nvar.LAST_GSTATS = None\nvar.LAST_PSTATS = None\nvar.LAST_RSTATS = None\nvar.LAST_TIME = None\nvar.LAST_GOAT = UserDict() # type: UserDict[users.User, datetime]\n\nvar.ADMIN_PINGING = False\nvar.DCED_LOSERS = UserSet()\nvar.ADMIN_TO_PING = None\nvar.AFTER_FLASTGAME = None\nvar.PINGING_IFS = False\nvar.TIMERS = {}\nvar.PHASE = \"none\"\nvar.OLD_MODES = defaultdict(set)\n\nvar.ROLES = UserDict() # type: UserDict[str, UserSet]\nvar.ORIGINAL_ROLES = UserDict() # type: UserDict[str, UserSet]\nvar.MAIN_ROLES = UserDict() # type: UserDict[users.User, str]\nvar.ORIGINAL_MAIN_ROLES = UserDict() # type: UserDict[users.User, str]\nvar.FINAL_ROLES = UserDict() # type: UserDict[users.User, str]\nvar.ALL_PLAYERS = UserList()\nvar.FORCE_ROLES = DefaultUserDict(UserSet)\nvar.ORIGINAL_ACCS = UserDict() # type: UserDict[users.User, str]\n\nvar.IDLE_WARNED = UserSet()\nvar.IDLE_WARNED_PM = UserSet()\nvar.NIGHT_IDLED = UserSet()\nvar.NIGHT_IDLE_EXEMPT = UserSet()\n\nvar.DEAD = UserSet()\n\nvar.DEADCHAT_PLAYERS = UserSet()\n\nvar.SPECTATING_WOLFCHAT = UserSet()\nvar.SPECTATING_DEADCHAT = UserSet()\n\nvar.ORIGINAL_SETTINGS = {}\nvar.GAMEMODE_VOTES = UserDict()\n\nvar.LAST_SAID_TIME = UserDict()\n\nvar.GAME_START_TIME = datetime.now()  # for idle checker only\nvar.CAN_START_TIME = 0\nvar.STARTED_DAY_PLAYERS = 0\n\nvar.DISCONNECTED = UserDict() # type: UserDict[User, Tuple[datetime, str]]\n\nvar.RESTARTING = False\n\n",
        "source_code_len": 1411,
        "target_code": "\nvar.LAST_STATS = None  # type: ignore\nvar.LAST_ADMINS = None  # type: ignore\nvar.LAST_GSTATS = None  # type: ignore\nvar.LAST_PSTATS = None  # type: ignore\nvar.LAST_RSTATS = None  # type: ignore\nvar.LAST_TIME = None  # type: ignore\nvar.LAST_GOAT = UserDict() # type: ignore # actually UserDict[users.User, datetime]\n\nvar.ADMIN_PINGING = False  # type: ignore\nvar.DCED_LOSERS = UserSet()  # type: ignore\nvar.ADMIN_TO_PING = None  # type: ignore\nvar.AFTER_FLASTGAME = None  # type: ignore\nvar.PINGING_IFS = False  # type: ignore\nvar.TIMERS = {}  # type: ignore\nvar.PHASE = \"none\"  # type: ignore\nvar.OLD_MODES = defaultdict(set)  # type: ignore\n\nvar.ROLES = UserDict() # type: ignore # actually UserDict[str, UserSet]\nvar.ORIGINAL_ROLES = UserDict() # type: ignore # actually UserDict[str, UserSet]\nvar.MAIN_ROLES = UserDict() # type: ignore # actually UserDict[users.User, str]\nvar.ORIGINAL_MAIN_ROLES = UserDict() # type: ignore # actually UserDict[users.User, str]\nvar.FINAL_ROLES = UserDict() # type: ignore # actually UserDict[users.User, str]\nvar.ALL_PLAYERS = UserList() # type: ignore\nvar.FORCE_ROLES = DefaultUserDict(UserSet) # type: ignore\nvar.ORIGINAL_ACCS = UserDict() # type: ignore # actually UserDict[users.User, str]\n\nvar.IDLE_WARNED = UserSet() # type: ignore\nvar.IDLE_WARNED_PM = UserSet() # type: ignore\nvar.NIGHT_IDLED = UserSet() # type: ignore\nvar.NIGHT_IDLE_EXEMPT = UserSet() # type: ignore\n\nvar.DEAD = UserSet() # type: ignore\n\nvar.DEADCHAT_PLAYERS = UserSet() # type: ignore\n\nvar.SPECTATING_WOLFCHAT = UserSet() # type: ignore\nvar.SPECTATING_DEADCHAT = UserSet() # type: ignore\n\nvar.ORIGINAL_SETTINGS = {} # type: ignore\nvar.GAMEMODE_VOTES = UserDict() # type: ignore\n\nvar.LAST_SAID_TIME = UserDict() # type: ignore\n\nvar.GAME_START_TIME = datetime.now()  # type: ignore # for idle checker only\nvar.CAN_START_TIME = 0 # type: ignore\nvar.STARTED_DAY_PLAYERS = 0 # type: ignore\n\nvar.DISCONNECTED = UserDict() # type: ignore # actually UserDict[User, Tuple[datetime, str]]\n\nvar.RESTARTING = False # type: ignore\n\n",
        "target_code_len": 2034,
        "diff_format": "@@ -80,52 +85,52 @@\n \n-var.LAST_STATS = None\n-var.LAST_ADMINS = None\n-var.LAST_GSTATS = None\n-var.LAST_PSTATS = None\n-var.LAST_RSTATS = None\n-var.LAST_TIME = None\n-var.LAST_GOAT = UserDict() # type: UserDict[users.User, datetime]\n-\n-var.ADMIN_PINGING = False\n-var.DCED_LOSERS = UserSet()\n-var.ADMIN_TO_PING = None\n-var.AFTER_FLASTGAME = None\n-var.PINGING_IFS = False\n-var.TIMERS = {}\n-var.PHASE = \"none\"\n-var.OLD_MODES = defaultdict(set)\n-\n-var.ROLES = UserDict() # type: UserDict[str, UserSet]\n-var.ORIGINAL_ROLES = UserDict() # type: UserDict[str, UserSet]\n-var.MAIN_ROLES = UserDict() # type: UserDict[users.User, str]\n-var.ORIGINAL_MAIN_ROLES = UserDict() # type: UserDict[users.User, str]\n-var.FINAL_ROLES = UserDict() # type: UserDict[users.User, str]\n-var.ALL_PLAYERS = UserList()\n-var.FORCE_ROLES = DefaultUserDict(UserSet)\n-var.ORIGINAL_ACCS = UserDict() # type: UserDict[users.User, str]\n-\n-var.IDLE_WARNED = UserSet()\n-var.IDLE_WARNED_PM = UserSet()\n-var.NIGHT_IDLED = UserSet()\n-var.NIGHT_IDLE_EXEMPT = UserSet()\n-\n-var.DEAD = UserSet()\n-\n-var.DEADCHAT_PLAYERS = UserSet()\n-\n-var.SPECTATING_WOLFCHAT = UserSet()\n-var.SPECTATING_DEADCHAT = UserSet()\n-\n-var.ORIGINAL_SETTINGS = {}\n-var.GAMEMODE_VOTES = UserDict()\n-\n-var.LAST_SAID_TIME = UserDict()\n-\n-var.GAME_START_TIME = datetime.now()  # for idle checker only\n-var.CAN_START_TIME = 0\n-var.STARTED_DAY_PLAYERS = 0\n-\n-var.DISCONNECTED = UserDict() # type: UserDict[User, Tuple[datetime, str]]\n-\n-var.RESTARTING = False\n+var.LAST_STATS = None  # type: ignore\n+var.LAST_ADMINS = None  # type: ignore\n+var.LAST_GSTATS = None  # type: ignore\n+var.LAST_PSTATS = None  # type: ignore\n+var.LAST_RSTATS = None  # type: ignore\n+var.LAST_TIME = None  # type: ignore\n+var.LAST_GOAT = UserDict() # type: ignore # actually UserDict[users.User, datetime]\n+\n+var.ADMIN_PINGING = False  # type: ignore\n+var.DCED_LOSERS = UserSet()  # type: ignore\n+var.ADMIN_TO_PING = None  # type: ignore\n+var.AFTER_FLASTGAME = None  # type: ignore\n+var.PINGING_IFS = False  # type: ignore\n+var.TIMERS = {}  # type: ignore\n+var.PHASE = \"none\"  # type: ignore\n+var.OLD_MODES = defaultdict(set)  # type: ignore\n+\n+var.ROLES = UserDict() # type: ignore # actually UserDict[str, UserSet]\n+var.ORIGINAL_ROLES = UserDict() # type: ignore # actually UserDict[str, UserSet]\n+var.MAIN_ROLES = UserDict() # type: ignore # actually UserDict[users.User, str]\n+var.ORIGINAL_MAIN_ROLES = UserDict() # type: ignore # actually UserDict[users.User, str]\n+var.FINAL_ROLES = UserDict() # type: ignore # actually UserDict[users.User, str]\n+var.ALL_PLAYERS = UserList() # type: ignore\n+var.FORCE_ROLES = DefaultUserDict(UserSet) # type: ignore\n+var.ORIGINAL_ACCS = UserDict() # type: ignore # actually UserDict[users.User, str]\n+\n+var.IDLE_WARNED = UserSet() # type: ignore\n+var.IDLE_WARNED_PM = UserSet() # type: ignore\n+var.NIGHT_IDLED = UserSet() # type: ignore\n+var.NIGHT_IDLE_EXEMPT = UserSet() # type: ignore\n+\n+var.DEAD = UserSet() # type: ignore\n+\n+var.DEADCHAT_PLAYERS = UserSet() # type: ignore\n+\n+var.SPECTATING_WOLFCHAT = UserSet() # type: ignore\n+var.SPECTATING_DEADCHAT = UserSet() # type: ignore\n+\n+var.ORIGINAL_SETTINGS = {} # type: ignore\n+var.GAMEMODE_VOTES = UserDict() # type: ignore\n+\n+var.LAST_SAID_TIME = UserDict() # type: ignore\n+\n+var.GAME_START_TIME = datetime.now()  # type: ignore # for idle checker only\n+var.CAN_START_TIME = 0 # type: ignore\n+var.STARTED_DAY_PLAYERS = 0 # type: ignore\n+\n+var.DISCONNECTED = UserDict() # type: ignore # actually UserDict[User, Tuple[datetime, str]]\n+\n+var.RESTARTING = False # type: ignore\n \n",
        "source_code_with_indent": "\nvar.LAST_STATS = None\nvar.LAST_ADMINS = None\nvar.LAST_GSTATS = None\nvar.LAST_PSTATS = None\nvar.LAST_RSTATS = None\nvar.LAST_TIME = None\nvar.LAST_GOAT = UserDict() # type: UserDict[users.User, datetime]\n\nvar.ADMIN_PINGING = False\nvar.DCED_LOSERS = UserSet()\nvar.ADMIN_TO_PING = None\nvar.AFTER_FLASTGAME = None\nvar.PINGING_IFS = False\nvar.TIMERS = {}\nvar.PHASE = \"none\"\nvar.OLD_MODES = defaultdict(set)\n\nvar.ROLES = UserDict() # type: UserDict[str, UserSet]\nvar.ORIGINAL_ROLES = UserDict() # type: UserDict[str, UserSet]\nvar.MAIN_ROLES = UserDict() # type: UserDict[users.User, str]\nvar.ORIGINAL_MAIN_ROLES = UserDict() # type: UserDict[users.User, str]\nvar.FINAL_ROLES = UserDict() # type: UserDict[users.User, str]\nvar.ALL_PLAYERS = UserList()\nvar.FORCE_ROLES = DefaultUserDict(UserSet)\nvar.ORIGINAL_ACCS = UserDict() # type: UserDict[users.User, str]\n\nvar.IDLE_WARNED = UserSet()\nvar.IDLE_WARNED_PM = UserSet()\nvar.NIGHT_IDLED = UserSet()\nvar.NIGHT_IDLE_EXEMPT = UserSet()\n\nvar.DEAD = UserSet()\n\nvar.DEADCHAT_PLAYERS = UserSet()\n\nvar.SPECTATING_WOLFCHAT = UserSet()\nvar.SPECTATING_DEADCHAT = UserSet()\n\nvar.ORIGINAL_SETTINGS = {}\nvar.GAMEMODE_VOTES = UserDict()\n\nvar.LAST_SAID_TIME = UserDict()\n\nvar.GAME_START_TIME = datetime.now()  # for idle checker only\nvar.CAN_START_TIME = 0\nvar.STARTED_DAY_PLAYERS = 0\n\nvar.DISCONNECTED = UserDict() # type: UserDict[User, Tuple[datetime, str]]\n\nvar.RESTARTING = False\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\nvar.LAST_STATS = None  # type: ignore\nvar.LAST_ADMINS = None  # type: ignore\nvar.LAST_GSTATS = None  # type: ignore\nvar.LAST_PSTATS = None  # type: ignore\nvar.LAST_RSTATS = None  # type: ignore\nvar.LAST_TIME = None  # type: ignore\nvar.LAST_GOAT = UserDict() # type: ignore # actually UserDict[users.User, datetime]\n\nvar.ADMIN_PINGING = False  # type: ignore\nvar.DCED_LOSERS = UserSet()  # type: ignore\nvar.ADMIN_TO_PING = None  # type: ignore\nvar.AFTER_FLASTGAME = None  # type: ignore\nvar.PINGING_IFS = False  # type: ignore\nvar.TIMERS = {}  # type: ignore\nvar.PHASE = \"none\"  # type: ignore\nvar.OLD_MODES = defaultdict(set)  # type: ignore\n\nvar.ROLES = UserDict() # type: ignore # actually UserDict[str, UserSet]\nvar.ORIGINAL_ROLES = UserDict() # type: ignore # actually UserDict[str, UserSet]\nvar.MAIN_ROLES = UserDict() # type: ignore # actually UserDict[users.User, str]\nvar.ORIGINAL_MAIN_ROLES = UserDict() # type: ignore # actually UserDict[users.User, str]\nvar.FINAL_ROLES = UserDict() # type: ignore # actually UserDict[users.User, str]\nvar.ALL_PLAYERS = UserList() # type: ignore\nvar.FORCE_ROLES = DefaultUserDict(UserSet) # type: ignore\nvar.ORIGINAL_ACCS = UserDict() # type: ignore # actually UserDict[users.User, str]\n\nvar.IDLE_WARNED = UserSet() # type: ignore\nvar.IDLE_WARNED_PM = UserSet() # type: ignore\nvar.NIGHT_IDLED = UserSet() # type: ignore\nvar.NIGHT_IDLE_EXEMPT = UserSet() # type: ignore\n\nvar.DEAD = UserSet() # type: ignore\n\nvar.DEADCHAT_PLAYERS = UserSet() # type: ignore\n\nvar.SPECTATING_WOLFCHAT = UserSet() # type: ignore\nvar.SPECTATING_DEADCHAT = UserSet() # type: ignore\n\nvar.ORIGINAL_SETTINGS = {} # type: ignore\nvar.GAMEMODE_VOTES = UserDict() # type: ignore\n\nvar.LAST_SAID_TIME = UserDict() # type: ignore\n\nvar.GAME_START_TIME = datetime.now()  # type: ignore # for idle checker only\nvar.CAN_START_TIME = 0 # type: ignore\nvar.STARTED_DAY_PLAYERS = 0 # type: ignore\n\nvar.DISCONNECTED = UserDict() # type: ignore # actually UserDict[User, Tuple[datetime, str]]\n\nvar.RESTARTING = False # type: ignore\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "lykoss/lykos",
    "commit": "f8560e10e9e8cc4b4a3b8e750865c4079f7c9b37",
    "filename": "src/wolfgame.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/lykoss-lykos/src/wolfgame.py",
    "file_hunks_size": 7,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": true,
    "full_warning_msg": "src/wolfgame.py:101:0 Incompatible variable type [9]: src.settings.ORIGINAL_MAIN_ROLES is declared to have type `UserDict[]` but is used as type `UserDict`.",
    "message": " src.settings.ORIGINAL_MAIN_ROLES is declared to have type `UserDict[]` but is used as type `UserDict`.",
    "rule_id": "Incompatible variable type [9]",
    "warning_line_no": 101,
    "warning_line": "var.ORIGINAL_MAIN_ROLES = UserDict() # type: UserDict[users.User, str]",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": true,
        "source_code": "\nvar.LAST_STATS = None\nvar.LAST_ADMINS = None\nvar.LAST_GSTATS = None\nvar.LAST_PSTATS = None\nvar.LAST_RSTATS = None\nvar.LAST_TIME = None\nvar.LAST_GOAT = UserDict() # type: UserDict[users.User, datetime]\n\nvar.ADMIN_PINGING = False\nvar.DCED_LOSERS = UserSet()\nvar.ADMIN_TO_PING = None\nvar.AFTER_FLASTGAME = None\nvar.PINGING_IFS = False\nvar.TIMERS = {}\nvar.PHASE = \"none\"\nvar.OLD_MODES = defaultdict(set)\n\nvar.ROLES = UserDict() # type: UserDict[str, UserSet]\nvar.ORIGINAL_ROLES = UserDict() # type: UserDict[str, UserSet]\nvar.MAIN_ROLES = UserDict() # type: UserDict[users.User, str]\nvar.ORIGINAL_MAIN_ROLES = UserDict() # type: UserDict[users.User, str]\nvar.FINAL_ROLES = UserDict() # type: UserDict[users.User, str]\nvar.ALL_PLAYERS = UserList()\nvar.FORCE_ROLES = DefaultUserDict(UserSet)\nvar.ORIGINAL_ACCS = UserDict() # type: UserDict[users.User, str]\n\nvar.IDLE_WARNED = UserSet()\nvar.IDLE_WARNED_PM = UserSet()\nvar.NIGHT_IDLED = UserSet()\nvar.NIGHT_IDLE_EXEMPT = UserSet()\n\nvar.DEAD = UserSet()\n\nvar.DEADCHAT_PLAYERS = UserSet()\n\nvar.SPECTATING_WOLFCHAT = UserSet()\nvar.SPECTATING_DEADCHAT = UserSet()\n\nvar.ORIGINAL_SETTINGS = {}\nvar.GAMEMODE_VOTES = UserDict()\n\nvar.LAST_SAID_TIME = UserDict()\n\nvar.GAME_START_TIME = datetime.now()  # for idle checker only\nvar.CAN_START_TIME = 0\nvar.STARTED_DAY_PLAYERS = 0\n\nvar.DISCONNECTED = UserDict() # type: UserDict[User, Tuple[datetime, str]]\n\nvar.RESTARTING = False\n\n",
        "source_code_len": 1411,
        "target_code": "\nvar.LAST_STATS = None  # type: ignore\nvar.LAST_ADMINS = None  # type: ignore\nvar.LAST_GSTATS = None  # type: ignore\nvar.LAST_PSTATS = None  # type: ignore\nvar.LAST_RSTATS = None  # type: ignore\nvar.LAST_TIME = None  # type: ignore\nvar.LAST_GOAT = UserDict() # type: ignore # actually UserDict[users.User, datetime]\n\nvar.ADMIN_PINGING = False  # type: ignore\nvar.DCED_LOSERS = UserSet()  # type: ignore\nvar.ADMIN_TO_PING = None  # type: ignore\nvar.AFTER_FLASTGAME = None  # type: ignore\nvar.PINGING_IFS = False  # type: ignore\nvar.TIMERS = {}  # type: ignore\nvar.PHASE = \"none\"  # type: ignore\nvar.OLD_MODES = defaultdict(set)  # type: ignore\n\nvar.ROLES = UserDict() # type: ignore # actually UserDict[str, UserSet]\nvar.ORIGINAL_ROLES = UserDict() # type: ignore # actually UserDict[str, UserSet]\nvar.MAIN_ROLES = UserDict() # type: ignore # actually UserDict[users.User, str]\nvar.ORIGINAL_MAIN_ROLES = UserDict() # type: ignore # actually UserDict[users.User, str]\nvar.FINAL_ROLES = UserDict() # type: ignore # actually UserDict[users.User, str]\nvar.ALL_PLAYERS = UserList() # type: ignore\nvar.FORCE_ROLES = DefaultUserDict(UserSet) # type: ignore\nvar.ORIGINAL_ACCS = UserDict() # type: ignore # actually UserDict[users.User, str]\n\nvar.IDLE_WARNED = UserSet() # type: ignore\nvar.IDLE_WARNED_PM = UserSet() # type: ignore\nvar.NIGHT_IDLED = UserSet() # type: ignore\nvar.NIGHT_IDLE_EXEMPT = UserSet() # type: ignore\n\nvar.DEAD = UserSet() # type: ignore\n\nvar.DEADCHAT_PLAYERS = UserSet() # type: ignore\n\nvar.SPECTATING_WOLFCHAT = UserSet() # type: ignore\nvar.SPECTATING_DEADCHAT = UserSet() # type: ignore\n\nvar.ORIGINAL_SETTINGS = {} # type: ignore\nvar.GAMEMODE_VOTES = UserDict() # type: ignore\n\nvar.LAST_SAID_TIME = UserDict() # type: ignore\n\nvar.GAME_START_TIME = datetime.now()  # type: ignore # for idle checker only\nvar.CAN_START_TIME = 0 # type: ignore\nvar.STARTED_DAY_PLAYERS = 0 # type: ignore\n\nvar.DISCONNECTED = UserDict() # type: ignore # actually UserDict[User, Tuple[datetime, str]]\n\nvar.RESTARTING = False # type: ignore\n\n",
        "target_code_len": 2034,
        "diff_format": "@@ -80,52 +85,52 @@\n \n-var.LAST_STATS = None\n-var.LAST_ADMINS = None\n-var.LAST_GSTATS = None\n-var.LAST_PSTATS = None\n-var.LAST_RSTATS = None\n-var.LAST_TIME = None\n-var.LAST_GOAT = UserDict() # type: UserDict[users.User, datetime]\n-\n-var.ADMIN_PINGING = False\n-var.DCED_LOSERS = UserSet()\n-var.ADMIN_TO_PING = None\n-var.AFTER_FLASTGAME = None\n-var.PINGING_IFS = False\n-var.TIMERS = {}\n-var.PHASE = \"none\"\n-var.OLD_MODES = defaultdict(set)\n-\n-var.ROLES = UserDict() # type: UserDict[str, UserSet]\n-var.ORIGINAL_ROLES = UserDict() # type: UserDict[str, UserSet]\n-var.MAIN_ROLES = UserDict() # type: UserDict[users.User, str]\n-var.ORIGINAL_MAIN_ROLES = UserDict() # type: UserDict[users.User, str]\n-var.FINAL_ROLES = UserDict() # type: UserDict[users.User, str]\n-var.ALL_PLAYERS = UserList()\n-var.FORCE_ROLES = DefaultUserDict(UserSet)\n-var.ORIGINAL_ACCS = UserDict() # type: UserDict[users.User, str]\n-\n-var.IDLE_WARNED = UserSet()\n-var.IDLE_WARNED_PM = UserSet()\n-var.NIGHT_IDLED = UserSet()\n-var.NIGHT_IDLE_EXEMPT = UserSet()\n-\n-var.DEAD = UserSet()\n-\n-var.DEADCHAT_PLAYERS = UserSet()\n-\n-var.SPECTATING_WOLFCHAT = UserSet()\n-var.SPECTATING_DEADCHAT = UserSet()\n-\n-var.ORIGINAL_SETTINGS = {}\n-var.GAMEMODE_VOTES = UserDict()\n-\n-var.LAST_SAID_TIME = UserDict()\n-\n-var.GAME_START_TIME = datetime.now()  # for idle checker only\n-var.CAN_START_TIME = 0\n-var.STARTED_DAY_PLAYERS = 0\n-\n-var.DISCONNECTED = UserDict() # type: UserDict[User, Tuple[datetime, str]]\n-\n-var.RESTARTING = False\n+var.LAST_STATS = None  # type: ignore\n+var.LAST_ADMINS = None  # type: ignore\n+var.LAST_GSTATS = None  # type: ignore\n+var.LAST_PSTATS = None  # type: ignore\n+var.LAST_RSTATS = None  # type: ignore\n+var.LAST_TIME = None  # type: ignore\n+var.LAST_GOAT = UserDict() # type: ignore # actually UserDict[users.User, datetime]\n+\n+var.ADMIN_PINGING = False  # type: ignore\n+var.DCED_LOSERS = UserSet()  # type: ignore\n+var.ADMIN_TO_PING = None  # type: ignore\n+var.AFTER_FLASTGAME = None  # type: ignore\n+var.PINGING_IFS = False  # type: ignore\n+var.TIMERS = {}  # type: ignore\n+var.PHASE = \"none\"  # type: ignore\n+var.OLD_MODES = defaultdict(set)  # type: ignore\n+\n+var.ROLES = UserDict() # type: ignore # actually UserDict[str, UserSet]\n+var.ORIGINAL_ROLES = UserDict() # type: ignore # actually UserDict[str, UserSet]\n+var.MAIN_ROLES = UserDict() # type: ignore # actually UserDict[users.User, str]\n+var.ORIGINAL_MAIN_ROLES = UserDict() # type: ignore # actually UserDict[users.User, str]\n+var.FINAL_ROLES = UserDict() # type: ignore # actually UserDict[users.User, str]\n+var.ALL_PLAYERS = UserList() # type: ignore\n+var.FORCE_ROLES = DefaultUserDict(UserSet) # type: ignore\n+var.ORIGINAL_ACCS = UserDict() # type: ignore # actually UserDict[users.User, str]\n+\n+var.IDLE_WARNED = UserSet() # type: ignore\n+var.IDLE_WARNED_PM = UserSet() # type: ignore\n+var.NIGHT_IDLED = UserSet() # type: ignore\n+var.NIGHT_IDLE_EXEMPT = UserSet() # type: ignore\n+\n+var.DEAD = UserSet() # type: ignore\n+\n+var.DEADCHAT_PLAYERS = UserSet() # type: ignore\n+\n+var.SPECTATING_WOLFCHAT = UserSet() # type: ignore\n+var.SPECTATING_DEADCHAT = UserSet() # type: ignore\n+\n+var.ORIGINAL_SETTINGS = {} # type: ignore\n+var.GAMEMODE_VOTES = UserDict() # type: ignore\n+\n+var.LAST_SAID_TIME = UserDict() # type: ignore\n+\n+var.GAME_START_TIME = datetime.now()  # type: ignore # for idle checker only\n+var.CAN_START_TIME = 0 # type: ignore\n+var.STARTED_DAY_PLAYERS = 0 # type: ignore\n+\n+var.DISCONNECTED = UserDict() # type: ignore # actually UserDict[User, Tuple[datetime, str]]\n+\n+var.RESTARTING = False # type: ignore\n \n",
        "source_code_with_indent": "\nvar.LAST_STATS = None\nvar.LAST_ADMINS = None\nvar.LAST_GSTATS = None\nvar.LAST_PSTATS = None\nvar.LAST_RSTATS = None\nvar.LAST_TIME = None\nvar.LAST_GOAT = UserDict() # type: UserDict[users.User, datetime]\n\nvar.ADMIN_PINGING = False\nvar.DCED_LOSERS = UserSet()\nvar.ADMIN_TO_PING = None\nvar.AFTER_FLASTGAME = None\nvar.PINGING_IFS = False\nvar.TIMERS = {}\nvar.PHASE = \"none\"\nvar.OLD_MODES = defaultdict(set)\n\nvar.ROLES = UserDict() # type: UserDict[str, UserSet]\nvar.ORIGINAL_ROLES = UserDict() # type: UserDict[str, UserSet]\nvar.MAIN_ROLES = UserDict() # type: UserDict[users.User, str]\nvar.ORIGINAL_MAIN_ROLES = UserDict() # type: UserDict[users.User, str]\nvar.FINAL_ROLES = UserDict() # type: UserDict[users.User, str]\nvar.ALL_PLAYERS = UserList()\nvar.FORCE_ROLES = DefaultUserDict(UserSet)\nvar.ORIGINAL_ACCS = UserDict() # type: UserDict[users.User, str]\n\nvar.IDLE_WARNED = UserSet()\nvar.IDLE_WARNED_PM = UserSet()\nvar.NIGHT_IDLED = UserSet()\nvar.NIGHT_IDLE_EXEMPT = UserSet()\n\nvar.DEAD = UserSet()\n\nvar.DEADCHAT_PLAYERS = UserSet()\n\nvar.SPECTATING_WOLFCHAT = UserSet()\nvar.SPECTATING_DEADCHAT = UserSet()\n\nvar.ORIGINAL_SETTINGS = {}\nvar.GAMEMODE_VOTES = UserDict()\n\nvar.LAST_SAID_TIME = UserDict()\n\nvar.GAME_START_TIME = datetime.now()  # for idle checker only\nvar.CAN_START_TIME = 0\nvar.STARTED_DAY_PLAYERS = 0\n\nvar.DISCONNECTED = UserDict() # type: UserDict[User, Tuple[datetime, str]]\n\nvar.RESTARTING = False\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\nvar.LAST_STATS = None  # type: ignore\nvar.LAST_ADMINS = None  # type: ignore\nvar.LAST_GSTATS = None  # type: ignore\nvar.LAST_PSTATS = None  # type: ignore\nvar.LAST_RSTATS = None  # type: ignore\nvar.LAST_TIME = None  # type: ignore\nvar.LAST_GOAT = UserDict() # type: ignore # actually UserDict[users.User, datetime]\n\nvar.ADMIN_PINGING = False  # type: ignore\nvar.DCED_LOSERS = UserSet()  # type: ignore\nvar.ADMIN_TO_PING = None  # type: ignore\nvar.AFTER_FLASTGAME = None  # type: ignore\nvar.PINGING_IFS = False  # type: ignore\nvar.TIMERS = {}  # type: ignore\nvar.PHASE = \"none\"  # type: ignore\nvar.OLD_MODES = defaultdict(set)  # type: ignore\n\nvar.ROLES = UserDict() # type: ignore # actually UserDict[str, UserSet]\nvar.ORIGINAL_ROLES = UserDict() # type: ignore # actually UserDict[str, UserSet]\nvar.MAIN_ROLES = UserDict() # type: ignore # actually UserDict[users.User, str]\nvar.ORIGINAL_MAIN_ROLES = UserDict() # type: ignore # actually UserDict[users.User, str]\nvar.FINAL_ROLES = UserDict() # type: ignore # actually UserDict[users.User, str]\nvar.ALL_PLAYERS = UserList() # type: ignore\nvar.FORCE_ROLES = DefaultUserDict(UserSet) # type: ignore\nvar.ORIGINAL_ACCS = UserDict() # type: ignore # actually UserDict[users.User, str]\n\nvar.IDLE_WARNED = UserSet() # type: ignore\nvar.IDLE_WARNED_PM = UserSet() # type: ignore\nvar.NIGHT_IDLED = UserSet() # type: ignore\nvar.NIGHT_IDLE_EXEMPT = UserSet() # type: ignore\n\nvar.DEAD = UserSet() # type: ignore\n\nvar.DEADCHAT_PLAYERS = UserSet() # type: ignore\n\nvar.SPECTATING_WOLFCHAT = UserSet() # type: ignore\nvar.SPECTATING_DEADCHAT = UserSet() # type: ignore\n\nvar.ORIGINAL_SETTINGS = {} # type: ignore\nvar.GAMEMODE_VOTES = UserDict() # type: ignore\n\nvar.LAST_SAID_TIME = UserDict() # type: ignore\n\nvar.GAME_START_TIME = datetime.now()  # type: ignore # for idle checker only\nvar.CAN_START_TIME = 0 # type: ignore\nvar.STARTED_DAY_PLAYERS = 0 # type: ignore\n\nvar.DISCONNECTED = UserDict() # type: ignore # actually UserDict[User, Tuple[datetime, str]]\n\nvar.RESTARTING = False # type: ignore\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "lykoss/lykos",
    "commit": "f8560e10e9e8cc4b4a3b8e750865c4079f7c9b37",
    "filename": "src/wolfgame.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/lykoss-lykos/src/wolfgame.py",
    "file_hunks_size": 7,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": true,
    "full_warning_msg": "src/wolfgame.py:102:0 Incompatible variable type [9]: src.settings.FINAL_ROLES is declared to have type `UserDict[]` but is used as type `UserDict`.",
    "message": " src.settings.FINAL_ROLES is declared to have type `UserDict[]` but is used as type `UserDict`.",
    "rule_id": "Incompatible variable type [9]",
    "warning_line_no": 102,
    "warning_line": "var.FINAL_ROLES = UserDict() # type: UserDict[users.User, str]",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": true,
        "source_code": "\nvar.LAST_STATS = None\nvar.LAST_ADMINS = None\nvar.LAST_GSTATS = None\nvar.LAST_PSTATS = None\nvar.LAST_RSTATS = None\nvar.LAST_TIME = None\nvar.LAST_GOAT = UserDict() # type: UserDict[users.User, datetime]\n\nvar.ADMIN_PINGING = False\nvar.DCED_LOSERS = UserSet()\nvar.ADMIN_TO_PING = None\nvar.AFTER_FLASTGAME = None\nvar.PINGING_IFS = False\nvar.TIMERS = {}\nvar.PHASE = \"none\"\nvar.OLD_MODES = defaultdict(set)\n\nvar.ROLES = UserDict() # type: UserDict[str, UserSet]\nvar.ORIGINAL_ROLES = UserDict() # type: UserDict[str, UserSet]\nvar.MAIN_ROLES = UserDict() # type: UserDict[users.User, str]\nvar.ORIGINAL_MAIN_ROLES = UserDict() # type: UserDict[users.User, str]\nvar.FINAL_ROLES = UserDict() # type: UserDict[users.User, str]\nvar.ALL_PLAYERS = UserList()\nvar.FORCE_ROLES = DefaultUserDict(UserSet)\nvar.ORIGINAL_ACCS = UserDict() # type: UserDict[users.User, str]\n\nvar.IDLE_WARNED = UserSet()\nvar.IDLE_WARNED_PM = UserSet()\nvar.NIGHT_IDLED = UserSet()\nvar.NIGHT_IDLE_EXEMPT = UserSet()\n\nvar.DEAD = UserSet()\n\nvar.DEADCHAT_PLAYERS = UserSet()\n\nvar.SPECTATING_WOLFCHAT = UserSet()\nvar.SPECTATING_DEADCHAT = UserSet()\n\nvar.ORIGINAL_SETTINGS = {}\nvar.GAMEMODE_VOTES = UserDict()\n\nvar.LAST_SAID_TIME = UserDict()\n\nvar.GAME_START_TIME = datetime.now()  # for idle checker only\nvar.CAN_START_TIME = 0\nvar.STARTED_DAY_PLAYERS = 0\n\nvar.DISCONNECTED = UserDict() # type: UserDict[User, Tuple[datetime, str]]\n\nvar.RESTARTING = False\n\n",
        "source_code_len": 1411,
        "target_code": "\nvar.LAST_STATS = None  # type: ignore\nvar.LAST_ADMINS = None  # type: ignore\nvar.LAST_GSTATS = None  # type: ignore\nvar.LAST_PSTATS = None  # type: ignore\nvar.LAST_RSTATS = None  # type: ignore\nvar.LAST_TIME = None  # type: ignore\nvar.LAST_GOAT = UserDict() # type: ignore # actually UserDict[users.User, datetime]\n\nvar.ADMIN_PINGING = False  # type: ignore\nvar.DCED_LOSERS = UserSet()  # type: ignore\nvar.ADMIN_TO_PING = None  # type: ignore\nvar.AFTER_FLASTGAME = None  # type: ignore\nvar.PINGING_IFS = False  # type: ignore\nvar.TIMERS = {}  # type: ignore\nvar.PHASE = \"none\"  # type: ignore\nvar.OLD_MODES = defaultdict(set)  # type: ignore\n\nvar.ROLES = UserDict() # type: ignore # actually UserDict[str, UserSet]\nvar.ORIGINAL_ROLES = UserDict() # type: ignore # actually UserDict[str, UserSet]\nvar.MAIN_ROLES = UserDict() # type: ignore # actually UserDict[users.User, str]\nvar.ORIGINAL_MAIN_ROLES = UserDict() # type: ignore # actually UserDict[users.User, str]\nvar.FINAL_ROLES = UserDict() # type: ignore # actually UserDict[users.User, str]\nvar.ALL_PLAYERS = UserList() # type: ignore\nvar.FORCE_ROLES = DefaultUserDict(UserSet) # type: ignore\nvar.ORIGINAL_ACCS = UserDict() # type: ignore # actually UserDict[users.User, str]\n\nvar.IDLE_WARNED = UserSet() # type: ignore\nvar.IDLE_WARNED_PM = UserSet() # type: ignore\nvar.NIGHT_IDLED = UserSet() # type: ignore\nvar.NIGHT_IDLE_EXEMPT = UserSet() # type: ignore\n\nvar.DEAD = UserSet() # type: ignore\n\nvar.DEADCHAT_PLAYERS = UserSet() # type: ignore\n\nvar.SPECTATING_WOLFCHAT = UserSet() # type: ignore\nvar.SPECTATING_DEADCHAT = UserSet() # type: ignore\n\nvar.ORIGINAL_SETTINGS = {} # type: ignore\nvar.GAMEMODE_VOTES = UserDict() # type: ignore\n\nvar.LAST_SAID_TIME = UserDict() # type: ignore\n\nvar.GAME_START_TIME = datetime.now()  # type: ignore # for idle checker only\nvar.CAN_START_TIME = 0 # type: ignore\nvar.STARTED_DAY_PLAYERS = 0 # type: ignore\n\nvar.DISCONNECTED = UserDict() # type: ignore # actually UserDict[User, Tuple[datetime, str]]\n\nvar.RESTARTING = False # type: ignore\n\n",
        "target_code_len": 2034,
        "diff_format": "@@ -80,52 +85,52 @@\n \n-var.LAST_STATS = None\n-var.LAST_ADMINS = None\n-var.LAST_GSTATS = None\n-var.LAST_PSTATS = None\n-var.LAST_RSTATS = None\n-var.LAST_TIME = None\n-var.LAST_GOAT = UserDict() # type: UserDict[users.User, datetime]\n-\n-var.ADMIN_PINGING = False\n-var.DCED_LOSERS = UserSet()\n-var.ADMIN_TO_PING = None\n-var.AFTER_FLASTGAME = None\n-var.PINGING_IFS = False\n-var.TIMERS = {}\n-var.PHASE = \"none\"\n-var.OLD_MODES = defaultdict(set)\n-\n-var.ROLES = UserDict() # type: UserDict[str, UserSet]\n-var.ORIGINAL_ROLES = UserDict() # type: UserDict[str, UserSet]\n-var.MAIN_ROLES = UserDict() # type: UserDict[users.User, str]\n-var.ORIGINAL_MAIN_ROLES = UserDict() # type: UserDict[users.User, str]\n-var.FINAL_ROLES = UserDict() # type: UserDict[users.User, str]\n-var.ALL_PLAYERS = UserList()\n-var.FORCE_ROLES = DefaultUserDict(UserSet)\n-var.ORIGINAL_ACCS = UserDict() # type: UserDict[users.User, str]\n-\n-var.IDLE_WARNED = UserSet()\n-var.IDLE_WARNED_PM = UserSet()\n-var.NIGHT_IDLED = UserSet()\n-var.NIGHT_IDLE_EXEMPT = UserSet()\n-\n-var.DEAD = UserSet()\n-\n-var.DEADCHAT_PLAYERS = UserSet()\n-\n-var.SPECTATING_WOLFCHAT = UserSet()\n-var.SPECTATING_DEADCHAT = UserSet()\n-\n-var.ORIGINAL_SETTINGS = {}\n-var.GAMEMODE_VOTES = UserDict()\n-\n-var.LAST_SAID_TIME = UserDict()\n-\n-var.GAME_START_TIME = datetime.now()  # for idle checker only\n-var.CAN_START_TIME = 0\n-var.STARTED_DAY_PLAYERS = 0\n-\n-var.DISCONNECTED = UserDict() # type: UserDict[User, Tuple[datetime, str]]\n-\n-var.RESTARTING = False\n+var.LAST_STATS = None  # type: ignore\n+var.LAST_ADMINS = None  # type: ignore\n+var.LAST_GSTATS = None  # type: ignore\n+var.LAST_PSTATS = None  # type: ignore\n+var.LAST_RSTATS = None  # type: ignore\n+var.LAST_TIME = None  # type: ignore\n+var.LAST_GOAT = UserDict() # type: ignore # actually UserDict[users.User, datetime]\n+\n+var.ADMIN_PINGING = False  # type: ignore\n+var.DCED_LOSERS = UserSet()  # type: ignore\n+var.ADMIN_TO_PING = None  # type: ignore\n+var.AFTER_FLASTGAME = None  # type: ignore\n+var.PINGING_IFS = False  # type: ignore\n+var.TIMERS = {}  # type: ignore\n+var.PHASE = \"none\"  # type: ignore\n+var.OLD_MODES = defaultdict(set)  # type: ignore\n+\n+var.ROLES = UserDict() # type: ignore # actually UserDict[str, UserSet]\n+var.ORIGINAL_ROLES = UserDict() # type: ignore # actually UserDict[str, UserSet]\n+var.MAIN_ROLES = UserDict() # type: ignore # actually UserDict[users.User, str]\n+var.ORIGINAL_MAIN_ROLES = UserDict() # type: ignore # actually UserDict[users.User, str]\n+var.FINAL_ROLES = UserDict() # type: ignore # actually UserDict[users.User, str]\n+var.ALL_PLAYERS = UserList() # type: ignore\n+var.FORCE_ROLES = DefaultUserDict(UserSet) # type: ignore\n+var.ORIGINAL_ACCS = UserDict() # type: ignore # actually UserDict[users.User, str]\n+\n+var.IDLE_WARNED = UserSet() # type: ignore\n+var.IDLE_WARNED_PM = UserSet() # type: ignore\n+var.NIGHT_IDLED = UserSet() # type: ignore\n+var.NIGHT_IDLE_EXEMPT = UserSet() # type: ignore\n+\n+var.DEAD = UserSet() # type: ignore\n+\n+var.DEADCHAT_PLAYERS = UserSet() # type: ignore\n+\n+var.SPECTATING_WOLFCHAT = UserSet() # type: ignore\n+var.SPECTATING_DEADCHAT = UserSet() # type: ignore\n+\n+var.ORIGINAL_SETTINGS = {} # type: ignore\n+var.GAMEMODE_VOTES = UserDict() # type: ignore\n+\n+var.LAST_SAID_TIME = UserDict() # type: ignore\n+\n+var.GAME_START_TIME = datetime.now()  # type: ignore # for idle checker only\n+var.CAN_START_TIME = 0 # type: ignore\n+var.STARTED_DAY_PLAYERS = 0 # type: ignore\n+\n+var.DISCONNECTED = UserDict() # type: ignore # actually UserDict[User, Tuple[datetime, str]]\n+\n+var.RESTARTING = False # type: ignore\n \n",
        "source_code_with_indent": "\nvar.LAST_STATS = None\nvar.LAST_ADMINS = None\nvar.LAST_GSTATS = None\nvar.LAST_PSTATS = None\nvar.LAST_RSTATS = None\nvar.LAST_TIME = None\nvar.LAST_GOAT = UserDict() # type: UserDict[users.User, datetime]\n\nvar.ADMIN_PINGING = False\nvar.DCED_LOSERS = UserSet()\nvar.ADMIN_TO_PING = None\nvar.AFTER_FLASTGAME = None\nvar.PINGING_IFS = False\nvar.TIMERS = {}\nvar.PHASE = \"none\"\nvar.OLD_MODES = defaultdict(set)\n\nvar.ROLES = UserDict() # type: UserDict[str, UserSet]\nvar.ORIGINAL_ROLES = UserDict() # type: UserDict[str, UserSet]\nvar.MAIN_ROLES = UserDict() # type: UserDict[users.User, str]\nvar.ORIGINAL_MAIN_ROLES = UserDict() # type: UserDict[users.User, str]\nvar.FINAL_ROLES = UserDict() # type: UserDict[users.User, str]\nvar.ALL_PLAYERS = UserList()\nvar.FORCE_ROLES = DefaultUserDict(UserSet)\nvar.ORIGINAL_ACCS = UserDict() # type: UserDict[users.User, str]\n\nvar.IDLE_WARNED = UserSet()\nvar.IDLE_WARNED_PM = UserSet()\nvar.NIGHT_IDLED = UserSet()\nvar.NIGHT_IDLE_EXEMPT = UserSet()\n\nvar.DEAD = UserSet()\n\nvar.DEADCHAT_PLAYERS = UserSet()\n\nvar.SPECTATING_WOLFCHAT = UserSet()\nvar.SPECTATING_DEADCHAT = UserSet()\n\nvar.ORIGINAL_SETTINGS = {}\nvar.GAMEMODE_VOTES = UserDict()\n\nvar.LAST_SAID_TIME = UserDict()\n\nvar.GAME_START_TIME = datetime.now()  # for idle checker only\nvar.CAN_START_TIME = 0\nvar.STARTED_DAY_PLAYERS = 0\n\nvar.DISCONNECTED = UserDict() # type: UserDict[User, Tuple[datetime, str]]\n\nvar.RESTARTING = False\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\nvar.LAST_STATS = None  # type: ignore\nvar.LAST_ADMINS = None  # type: ignore\nvar.LAST_GSTATS = None  # type: ignore\nvar.LAST_PSTATS = None  # type: ignore\nvar.LAST_RSTATS = None  # type: ignore\nvar.LAST_TIME = None  # type: ignore\nvar.LAST_GOAT = UserDict() # type: ignore # actually UserDict[users.User, datetime]\n\nvar.ADMIN_PINGING = False  # type: ignore\nvar.DCED_LOSERS = UserSet()  # type: ignore\nvar.ADMIN_TO_PING = None  # type: ignore\nvar.AFTER_FLASTGAME = None  # type: ignore\nvar.PINGING_IFS = False  # type: ignore\nvar.TIMERS = {}  # type: ignore\nvar.PHASE = \"none\"  # type: ignore\nvar.OLD_MODES = defaultdict(set)  # type: ignore\n\nvar.ROLES = UserDict() # type: ignore # actually UserDict[str, UserSet]\nvar.ORIGINAL_ROLES = UserDict() # type: ignore # actually UserDict[str, UserSet]\nvar.MAIN_ROLES = UserDict() # type: ignore # actually UserDict[users.User, str]\nvar.ORIGINAL_MAIN_ROLES = UserDict() # type: ignore # actually UserDict[users.User, str]\nvar.FINAL_ROLES = UserDict() # type: ignore # actually UserDict[users.User, str]\nvar.ALL_PLAYERS = UserList() # type: ignore\nvar.FORCE_ROLES = DefaultUserDict(UserSet) # type: ignore\nvar.ORIGINAL_ACCS = UserDict() # type: ignore # actually UserDict[users.User, str]\n\nvar.IDLE_WARNED = UserSet() # type: ignore\nvar.IDLE_WARNED_PM = UserSet() # type: ignore\nvar.NIGHT_IDLED = UserSet() # type: ignore\nvar.NIGHT_IDLE_EXEMPT = UserSet() # type: ignore\n\nvar.DEAD = UserSet() # type: ignore\n\nvar.DEADCHAT_PLAYERS = UserSet() # type: ignore\n\nvar.SPECTATING_WOLFCHAT = UserSet() # type: ignore\nvar.SPECTATING_DEADCHAT = UserSet() # type: ignore\n\nvar.ORIGINAL_SETTINGS = {} # type: ignore\nvar.GAMEMODE_VOTES = UserDict() # type: ignore\n\nvar.LAST_SAID_TIME = UserDict() # type: ignore\n\nvar.GAME_START_TIME = datetime.now()  # type: ignore # for idle checker only\nvar.CAN_START_TIME = 0 # type: ignore\nvar.STARTED_DAY_PLAYERS = 0 # type: ignore\n\nvar.DISCONNECTED = UserDict() # type: ignore # actually UserDict[User, Tuple[datetime, str]]\n\nvar.RESTARTING = False # type: ignore\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "lykoss/lykos",
    "commit": "f8560e10e9e8cc4b4a3b8e750865c4079f7c9b37",
    "filename": "src/wolfgame.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/lykoss-lykos/src/wolfgame.py",
    "file_hunks_size": 7,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": true,
    "full_warning_msg": "src/wolfgame.py:105:0 Incompatible variable type [9]: src.settings.ORIGINAL_ACCS is declared to have type `UserDict[]` but is used as type `UserDict`.",
    "message": " src.settings.ORIGINAL_ACCS is declared to have type `UserDict[]` but is used as type `UserDict`.",
    "rule_id": "Incompatible variable type [9]",
    "warning_line_no": 105,
    "warning_line": "var.ORIGINAL_ACCS = UserDict() # type: UserDict[users.User, str]",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": true,
        "source_code": "\nvar.LAST_STATS = None\nvar.LAST_ADMINS = None\nvar.LAST_GSTATS = None\nvar.LAST_PSTATS = None\nvar.LAST_RSTATS = None\nvar.LAST_TIME = None\nvar.LAST_GOAT = UserDict() # type: UserDict[users.User, datetime]\n\nvar.ADMIN_PINGING = False\nvar.DCED_LOSERS = UserSet()\nvar.ADMIN_TO_PING = None\nvar.AFTER_FLASTGAME = None\nvar.PINGING_IFS = False\nvar.TIMERS = {}\nvar.PHASE = \"none\"\nvar.OLD_MODES = defaultdict(set)\n\nvar.ROLES = UserDict() # type: UserDict[str, UserSet]\nvar.ORIGINAL_ROLES = UserDict() # type: UserDict[str, UserSet]\nvar.MAIN_ROLES = UserDict() # type: UserDict[users.User, str]\nvar.ORIGINAL_MAIN_ROLES = UserDict() # type: UserDict[users.User, str]\nvar.FINAL_ROLES = UserDict() # type: UserDict[users.User, str]\nvar.ALL_PLAYERS = UserList()\nvar.FORCE_ROLES = DefaultUserDict(UserSet)\nvar.ORIGINAL_ACCS = UserDict() # type: UserDict[users.User, str]\n\nvar.IDLE_WARNED = UserSet()\nvar.IDLE_WARNED_PM = UserSet()\nvar.NIGHT_IDLED = UserSet()\nvar.NIGHT_IDLE_EXEMPT = UserSet()\n\nvar.DEAD = UserSet()\n\nvar.DEADCHAT_PLAYERS = UserSet()\n\nvar.SPECTATING_WOLFCHAT = UserSet()\nvar.SPECTATING_DEADCHAT = UserSet()\n\nvar.ORIGINAL_SETTINGS = {}\nvar.GAMEMODE_VOTES = UserDict()\n\nvar.LAST_SAID_TIME = UserDict()\n\nvar.GAME_START_TIME = datetime.now()  # for idle checker only\nvar.CAN_START_TIME = 0\nvar.STARTED_DAY_PLAYERS = 0\n\nvar.DISCONNECTED = UserDict() # type: UserDict[User, Tuple[datetime, str]]\n\nvar.RESTARTING = False\n\n",
        "source_code_len": 1411,
        "target_code": "\nvar.LAST_STATS = None  # type: ignore\nvar.LAST_ADMINS = None  # type: ignore\nvar.LAST_GSTATS = None  # type: ignore\nvar.LAST_PSTATS = None  # type: ignore\nvar.LAST_RSTATS = None  # type: ignore\nvar.LAST_TIME = None  # type: ignore\nvar.LAST_GOAT = UserDict() # type: ignore # actually UserDict[users.User, datetime]\n\nvar.ADMIN_PINGING = False  # type: ignore\nvar.DCED_LOSERS = UserSet()  # type: ignore\nvar.ADMIN_TO_PING = None  # type: ignore\nvar.AFTER_FLASTGAME = None  # type: ignore\nvar.PINGING_IFS = False  # type: ignore\nvar.TIMERS = {}  # type: ignore\nvar.PHASE = \"none\"  # type: ignore\nvar.OLD_MODES = defaultdict(set)  # type: ignore\n\nvar.ROLES = UserDict() # type: ignore # actually UserDict[str, UserSet]\nvar.ORIGINAL_ROLES = UserDict() # type: ignore # actually UserDict[str, UserSet]\nvar.MAIN_ROLES = UserDict() # type: ignore # actually UserDict[users.User, str]\nvar.ORIGINAL_MAIN_ROLES = UserDict() # type: ignore # actually UserDict[users.User, str]\nvar.FINAL_ROLES = UserDict() # type: ignore # actually UserDict[users.User, str]\nvar.ALL_PLAYERS = UserList() # type: ignore\nvar.FORCE_ROLES = DefaultUserDict(UserSet) # type: ignore\nvar.ORIGINAL_ACCS = UserDict() # type: ignore # actually UserDict[users.User, str]\n\nvar.IDLE_WARNED = UserSet() # type: ignore\nvar.IDLE_WARNED_PM = UserSet() # type: ignore\nvar.NIGHT_IDLED = UserSet() # type: ignore\nvar.NIGHT_IDLE_EXEMPT = UserSet() # type: ignore\n\nvar.DEAD = UserSet() # type: ignore\n\nvar.DEADCHAT_PLAYERS = UserSet() # type: ignore\n\nvar.SPECTATING_WOLFCHAT = UserSet() # type: ignore\nvar.SPECTATING_DEADCHAT = UserSet() # type: ignore\n\nvar.ORIGINAL_SETTINGS = {} # type: ignore\nvar.GAMEMODE_VOTES = UserDict() # type: ignore\n\nvar.LAST_SAID_TIME = UserDict() # type: ignore\n\nvar.GAME_START_TIME = datetime.now()  # type: ignore # for idle checker only\nvar.CAN_START_TIME = 0 # type: ignore\nvar.STARTED_DAY_PLAYERS = 0 # type: ignore\n\nvar.DISCONNECTED = UserDict() # type: ignore # actually UserDict[User, Tuple[datetime, str]]\n\nvar.RESTARTING = False # type: ignore\n\n",
        "target_code_len": 2034,
        "diff_format": "@@ -80,52 +85,52 @@\n \n-var.LAST_STATS = None\n-var.LAST_ADMINS = None\n-var.LAST_GSTATS = None\n-var.LAST_PSTATS = None\n-var.LAST_RSTATS = None\n-var.LAST_TIME = None\n-var.LAST_GOAT = UserDict() # type: UserDict[users.User, datetime]\n-\n-var.ADMIN_PINGING = False\n-var.DCED_LOSERS = UserSet()\n-var.ADMIN_TO_PING = None\n-var.AFTER_FLASTGAME = None\n-var.PINGING_IFS = False\n-var.TIMERS = {}\n-var.PHASE = \"none\"\n-var.OLD_MODES = defaultdict(set)\n-\n-var.ROLES = UserDict() # type: UserDict[str, UserSet]\n-var.ORIGINAL_ROLES = UserDict() # type: UserDict[str, UserSet]\n-var.MAIN_ROLES = UserDict() # type: UserDict[users.User, str]\n-var.ORIGINAL_MAIN_ROLES = UserDict() # type: UserDict[users.User, str]\n-var.FINAL_ROLES = UserDict() # type: UserDict[users.User, str]\n-var.ALL_PLAYERS = UserList()\n-var.FORCE_ROLES = DefaultUserDict(UserSet)\n-var.ORIGINAL_ACCS = UserDict() # type: UserDict[users.User, str]\n-\n-var.IDLE_WARNED = UserSet()\n-var.IDLE_WARNED_PM = UserSet()\n-var.NIGHT_IDLED = UserSet()\n-var.NIGHT_IDLE_EXEMPT = UserSet()\n-\n-var.DEAD = UserSet()\n-\n-var.DEADCHAT_PLAYERS = UserSet()\n-\n-var.SPECTATING_WOLFCHAT = UserSet()\n-var.SPECTATING_DEADCHAT = UserSet()\n-\n-var.ORIGINAL_SETTINGS = {}\n-var.GAMEMODE_VOTES = UserDict()\n-\n-var.LAST_SAID_TIME = UserDict()\n-\n-var.GAME_START_TIME = datetime.now()  # for idle checker only\n-var.CAN_START_TIME = 0\n-var.STARTED_DAY_PLAYERS = 0\n-\n-var.DISCONNECTED = UserDict() # type: UserDict[User, Tuple[datetime, str]]\n-\n-var.RESTARTING = False\n+var.LAST_STATS = None  # type: ignore\n+var.LAST_ADMINS = None  # type: ignore\n+var.LAST_GSTATS = None  # type: ignore\n+var.LAST_PSTATS = None  # type: ignore\n+var.LAST_RSTATS = None  # type: ignore\n+var.LAST_TIME = None  # type: ignore\n+var.LAST_GOAT = UserDict() # type: ignore # actually UserDict[users.User, datetime]\n+\n+var.ADMIN_PINGING = False  # type: ignore\n+var.DCED_LOSERS = UserSet()  # type: ignore\n+var.ADMIN_TO_PING = None  # type: ignore\n+var.AFTER_FLASTGAME = None  # type: ignore\n+var.PINGING_IFS = False  # type: ignore\n+var.TIMERS = {}  # type: ignore\n+var.PHASE = \"none\"  # type: ignore\n+var.OLD_MODES = defaultdict(set)  # type: ignore\n+\n+var.ROLES = UserDict() # type: ignore # actually UserDict[str, UserSet]\n+var.ORIGINAL_ROLES = UserDict() # type: ignore # actually UserDict[str, UserSet]\n+var.MAIN_ROLES = UserDict() # type: ignore # actually UserDict[users.User, str]\n+var.ORIGINAL_MAIN_ROLES = UserDict() # type: ignore # actually UserDict[users.User, str]\n+var.FINAL_ROLES = UserDict() # type: ignore # actually UserDict[users.User, str]\n+var.ALL_PLAYERS = UserList() # type: ignore\n+var.FORCE_ROLES = DefaultUserDict(UserSet) # type: ignore\n+var.ORIGINAL_ACCS = UserDict() # type: ignore # actually UserDict[users.User, str]\n+\n+var.IDLE_WARNED = UserSet() # type: ignore\n+var.IDLE_WARNED_PM = UserSet() # type: ignore\n+var.NIGHT_IDLED = UserSet() # type: ignore\n+var.NIGHT_IDLE_EXEMPT = UserSet() # type: ignore\n+\n+var.DEAD = UserSet() # type: ignore\n+\n+var.DEADCHAT_PLAYERS = UserSet() # type: ignore\n+\n+var.SPECTATING_WOLFCHAT = UserSet() # type: ignore\n+var.SPECTATING_DEADCHAT = UserSet() # type: ignore\n+\n+var.ORIGINAL_SETTINGS = {} # type: ignore\n+var.GAMEMODE_VOTES = UserDict() # type: ignore\n+\n+var.LAST_SAID_TIME = UserDict() # type: ignore\n+\n+var.GAME_START_TIME = datetime.now()  # type: ignore # for idle checker only\n+var.CAN_START_TIME = 0 # type: ignore\n+var.STARTED_DAY_PLAYERS = 0 # type: ignore\n+\n+var.DISCONNECTED = UserDict() # type: ignore # actually UserDict[User, Tuple[datetime, str]]\n+\n+var.RESTARTING = False # type: ignore\n \n",
        "source_code_with_indent": "\nvar.LAST_STATS = None\nvar.LAST_ADMINS = None\nvar.LAST_GSTATS = None\nvar.LAST_PSTATS = None\nvar.LAST_RSTATS = None\nvar.LAST_TIME = None\nvar.LAST_GOAT = UserDict() # type: UserDict[users.User, datetime]\n\nvar.ADMIN_PINGING = False\nvar.DCED_LOSERS = UserSet()\nvar.ADMIN_TO_PING = None\nvar.AFTER_FLASTGAME = None\nvar.PINGING_IFS = False\nvar.TIMERS = {}\nvar.PHASE = \"none\"\nvar.OLD_MODES = defaultdict(set)\n\nvar.ROLES = UserDict() # type: UserDict[str, UserSet]\nvar.ORIGINAL_ROLES = UserDict() # type: UserDict[str, UserSet]\nvar.MAIN_ROLES = UserDict() # type: UserDict[users.User, str]\nvar.ORIGINAL_MAIN_ROLES = UserDict() # type: UserDict[users.User, str]\nvar.FINAL_ROLES = UserDict() # type: UserDict[users.User, str]\nvar.ALL_PLAYERS = UserList()\nvar.FORCE_ROLES = DefaultUserDict(UserSet)\nvar.ORIGINAL_ACCS = UserDict() # type: UserDict[users.User, str]\n\nvar.IDLE_WARNED = UserSet()\nvar.IDLE_WARNED_PM = UserSet()\nvar.NIGHT_IDLED = UserSet()\nvar.NIGHT_IDLE_EXEMPT = UserSet()\n\nvar.DEAD = UserSet()\n\nvar.DEADCHAT_PLAYERS = UserSet()\n\nvar.SPECTATING_WOLFCHAT = UserSet()\nvar.SPECTATING_DEADCHAT = UserSet()\n\nvar.ORIGINAL_SETTINGS = {}\nvar.GAMEMODE_VOTES = UserDict()\n\nvar.LAST_SAID_TIME = UserDict()\n\nvar.GAME_START_TIME = datetime.now()  # for idle checker only\nvar.CAN_START_TIME = 0\nvar.STARTED_DAY_PLAYERS = 0\n\nvar.DISCONNECTED = UserDict() # type: UserDict[User, Tuple[datetime, str]]\n\nvar.RESTARTING = False\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\nvar.LAST_STATS = None  # type: ignore\nvar.LAST_ADMINS = None  # type: ignore\nvar.LAST_GSTATS = None  # type: ignore\nvar.LAST_PSTATS = None  # type: ignore\nvar.LAST_RSTATS = None  # type: ignore\nvar.LAST_TIME = None  # type: ignore\nvar.LAST_GOAT = UserDict() # type: ignore # actually UserDict[users.User, datetime]\n\nvar.ADMIN_PINGING = False  # type: ignore\nvar.DCED_LOSERS = UserSet()  # type: ignore\nvar.ADMIN_TO_PING = None  # type: ignore\nvar.AFTER_FLASTGAME = None  # type: ignore\nvar.PINGING_IFS = False  # type: ignore\nvar.TIMERS = {}  # type: ignore\nvar.PHASE = \"none\"  # type: ignore\nvar.OLD_MODES = defaultdict(set)  # type: ignore\n\nvar.ROLES = UserDict() # type: ignore # actually UserDict[str, UserSet]\nvar.ORIGINAL_ROLES = UserDict() # type: ignore # actually UserDict[str, UserSet]\nvar.MAIN_ROLES = UserDict() # type: ignore # actually UserDict[users.User, str]\nvar.ORIGINAL_MAIN_ROLES = UserDict() # type: ignore # actually UserDict[users.User, str]\nvar.FINAL_ROLES = UserDict() # type: ignore # actually UserDict[users.User, str]\nvar.ALL_PLAYERS = UserList() # type: ignore\nvar.FORCE_ROLES = DefaultUserDict(UserSet) # type: ignore\nvar.ORIGINAL_ACCS = UserDict() # type: ignore # actually UserDict[users.User, str]\n\nvar.IDLE_WARNED = UserSet() # type: ignore\nvar.IDLE_WARNED_PM = UserSet() # type: ignore\nvar.NIGHT_IDLED = UserSet() # type: ignore\nvar.NIGHT_IDLE_EXEMPT = UserSet() # type: ignore\n\nvar.DEAD = UserSet() # type: ignore\n\nvar.DEADCHAT_PLAYERS = UserSet() # type: ignore\n\nvar.SPECTATING_WOLFCHAT = UserSet() # type: ignore\nvar.SPECTATING_DEADCHAT = UserSet() # type: ignore\n\nvar.ORIGINAL_SETTINGS = {} # type: ignore\nvar.GAMEMODE_VOTES = UserDict() # type: ignore\n\nvar.LAST_SAID_TIME = UserDict() # type: ignore\n\nvar.GAME_START_TIME = datetime.now()  # type: ignore # for idle checker only\nvar.CAN_START_TIME = 0 # type: ignore\nvar.STARTED_DAY_PLAYERS = 0 # type: ignore\n\nvar.DISCONNECTED = UserDict() # type: ignore # actually UserDict[User, Tuple[datetime, str]]\n\nvar.RESTARTING = False # type: ignore\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "lykoss/lykos",
    "commit": "f8560e10e9e8cc4b4a3b8e750865c4079f7c9b37",
    "filename": "src/wolfgame.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/lykoss-lykos/src/wolfgame.py",
    "file_hunks_size": 7,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": true,
    "full_warning_msg": "src/wolfgame.py:128:0 Incompatible variable type [9]: src.settings.DISCONNECTED is declared to have type `UserDict[]` but is used as type `UserDict`.",
    "message": " src.settings.DISCONNECTED is declared to have type `UserDict[]` but is used as type `UserDict`.",
    "rule_id": "Incompatible variable type [9]",
    "warning_line_no": 128,
    "warning_line": "var.DISCONNECTED = UserDict() # type: UserDict[User, Tuple[datetime, str]]",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": true,
        "source_code": "\nvar.LAST_STATS = None\nvar.LAST_ADMINS = None\nvar.LAST_GSTATS = None\nvar.LAST_PSTATS = None\nvar.LAST_RSTATS = None\nvar.LAST_TIME = None\nvar.LAST_GOAT = UserDict() # type: UserDict[users.User, datetime]\n\nvar.ADMIN_PINGING = False\nvar.DCED_LOSERS = UserSet()\nvar.ADMIN_TO_PING = None\nvar.AFTER_FLASTGAME = None\nvar.PINGING_IFS = False\nvar.TIMERS = {}\nvar.PHASE = \"none\"\nvar.OLD_MODES = defaultdict(set)\n\nvar.ROLES = UserDict() # type: UserDict[str, UserSet]\nvar.ORIGINAL_ROLES = UserDict() # type: UserDict[str, UserSet]\nvar.MAIN_ROLES = UserDict() # type: UserDict[users.User, str]\nvar.ORIGINAL_MAIN_ROLES = UserDict() # type: UserDict[users.User, str]\nvar.FINAL_ROLES = UserDict() # type: UserDict[users.User, str]\nvar.ALL_PLAYERS = UserList()\nvar.FORCE_ROLES = DefaultUserDict(UserSet)\nvar.ORIGINAL_ACCS = UserDict() # type: UserDict[users.User, str]\n\nvar.IDLE_WARNED = UserSet()\nvar.IDLE_WARNED_PM = UserSet()\nvar.NIGHT_IDLED = UserSet()\nvar.NIGHT_IDLE_EXEMPT = UserSet()\n\nvar.DEAD = UserSet()\n\nvar.DEADCHAT_PLAYERS = UserSet()\n\nvar.SPECTATING_WOLFCHAT = UserSet()\nvar.SPECTATING_DEADCHAT = UserSet()\n\nvar.ORIGINAL_SETTINGS = {}\nvar.GAMEMODE_VOTES = UserDict()\n\nvar.LAST_SAID_TIME = UserDict()\n\nvar.GAME_START_TIME = datetime.now()  # for idle checker only\nvar.CAN_START_TIME = 0\nvar.STARTED_DAY_PLAYERS = 0\n\nvar.DISCONNECTED = UserDict() # type: UserDict[User, Tuple[datetime, str]]\n\nvar.RESTARTING = False\n\n",
        "source_code_len": 1411,
        "target_code": "\nvar.LAST_STATS = None  # type: ignore\nvar.LAST_ADMINS = None  # type: ignore\nvar.LAST_GSTATS = None  # type: ignore\nvar.LAST_PSTATS = None  # type: ignore\nvar.LAST_RSTATS = None  # type: ignore\nvar.LAST_TIME = None  # type: ignore\nvar.LAST_GOAT = UserDict() # type: ignore # actually UserDict[users.User, datetime]\n\nvar.ADMIN_PINGING = False  # type: ignore\nvar.DCED_LOSERS = UserSet()  # type: ignore\nvar.ADMIN_TO_PING = None  # type: ignore\nvar.AFTER_FLASTGAME = None  # type: ignore\nvar.PINGING_IFS = False  # type: ignore\nvar.TIMERS = {}  # type: ignore\nvar.PHASE = \"none\"  # type: ignore\nvar.OLD_MODES = defaultdict(set)  # type: ignore\n\nvar.ROLES = UserDict() # type: ignore # actually UserDict[str, UserSet]\nvar.ORIGINAL_ROLES = UserDict() # type: ignore # actually UserDict[str, UserSet]\nvar.MAIN_ROLES = UserDict() # type: ignore # actually UserDict[users.User, str]\nvar.ORIGINAL_MAIN_ROLES = UserDict() # type: ignore # actually UserDict[users.User, str]\nvar.FINAL_ROLES = UserDict() # type: ignore # actually UserDict[users.User, str]\nvar.ALL_PLAYERS = UserList() # type: ignore\nvar.FORCE_ROLES = DefaultUserDict(UserSet) # type: ignore\nvar.ORIGINAL_ACCS = UserDict() # type: ignore # actually UserDict[users.User, str]\n\nvar.IDLE_WARNED = UserSet() # type: ignore\nvar.IDLE_WARNED_PM = UserSet() # type: ignore\nvar.NIGHT_IDLED = UserSet() # type: ignore\nvar.NIGHT_IDLE_EXEMPT = UserSet() # type: ignore\n\nvar.DEAD = UserSet() # type: ignore\n\nvar.DEADCHAT_PLAYERS = UserSet() # type: ignore\n\nvar.SPECTATING_WOLFCHAT = UserSet() # type: ignore\nvar.SPECTATING_DEADCHAT = UserSet() # type: ignore\n\nvar.ORIGINAL_SETTINGS = {} # type: ignore\nvar.GAMEMODE_VOTES = UserDict() # type: ignore\n\nvar.LAST_SAID_TIME = UserDict() # type: ignore\n\nvar.GAME_START_TIME = datetime.now()  # type: ignore # for idle checker only\nvar.CAN_START_TIME = 0 # type: ignore\nvar.STARTED_DAY_PLAYERS = 0 # type: ignore\n\nvar.DISCONNECTED = UserDict() # type: ignore # actually UserDict[User, Tuple[datetime, str]]\n\nvar.RESTARTING = False # type: ignore\n\n",
        "target_code_len": 2034,
        "diff_format": "@@ -80,52 +85,52 @@\n \n-var.LAST_STATS = None\n-var.LAST_ADMINS = None\n-var.LAST_GSTATS = None\n-var.LAST_PSTATS = None\n-var.LAST_RSTATS = None\n-var.LAST_TIME = None\n-var.LAST_GOAT = UserDict() # type: UserDict[users.User, datetime]\n-\n-var.ADMIN_PINGING = False\n-var.DCED_LOSERS = UserSet()\n-var.ADMIN_TO_PING = None\n-var.AFTER_FLASTGAME = None\n-var.PINGING_IFS = False\n-var.TIMERS = {}\n-var.PHASE = \"none\"\n-var.OLD_MODES = defaultdict(set)\n-\n-var.ROLES = UserDict() # type: UserDict[str, UserSet]\n-var.ORIGINAL_ROLES = UserDict() # type: UserDict[str, UserSet]\n-var.MAIN_ROLES = UserDict() # type: UserDict[users.User, str]\n-var.ORIGINAL_MAIN_ROLES = UserDict() # type: UserDict[users.User, str]\n-var.FINAL_ROLES = UserDict() # type: UserDict[users.User, str]\n-var.ALL_PLAYERS = UserList()\n-var.FORCE_ROLES = DefaultUserDict(UserSet)\n-var.ORIGINAL_ACCS = UserDict() # type: UserDict[users.User, str]\n-\n-var.IDLE_WARNED = UserSet()\n-var.IDLE_WARNED_PM = UserSet()\n-var.NIGHT_IDLED = UserSet()\n-var.NIGHT_IDLE_EXEMPT = UserSet()\n-\n-var.DEAD = UserSet()\n-\n-var.DEADCHAT_PLAYERS = UserSet()\n-\n-var.SPECTATING_WOLFCHAT = UserSet()\n-var.SPECTATING_DEADCHAT = UserSet()\n-\n-var.ORIGINAL_SETTINGS = {}\n-var.GAMEMODE_VOTES = UserDict()\n-\n-var.LAST_SAID_TIME = UserDict()\n-\n-var.GAME_START_TIME = datetime.now()  # for idle checker only\n-var.CAN_START_TIME = 0\n-var.STARTED_DAY_PLAYERS = 0\n-\n-var.DISCONNECTED = UserDict() # type: UserDict[User, Tuple[datetime, str]]\n-\n-var.RESTARTING = False\n+var.LAST_STATS = None  # type: ignore\n+var.LAST_ADMINS = None  # type: ignore\n+var.LAST_GSTATS = None  # type: ignore\n+var.LAST_PSTATS = None  # type: ignore\n+var.LAST_RSTATS = None  # type: ignore\n+var.LAST_TIME = None  # type: ignore\n+var.LAST_GOAT = UserDict() # type: ignore # actually UserDict[users.User, datetime]\n+\n+var.ADMIN_PINGING = False  # type: ignore\n+var.DCED_LOSERS = UserSet()  # type: ignore\n+var.ADMIN_TO_PING = None  # type: ignore\n+var.AFTER_FLASTGAME = None  # type: ignore\n+var.PINGING_IFS = False  # type: ignore\n+var.TIMERS = {}  # type: ignore\n+var.PHASE = \"none\"  # type: ignore\n+var.OLD_MODES = defaultdict(set)  # type: ignore\n+\n+var.ROLES = UserDict() # type: ignore # actually UserDict[str, UserSet]\n+var.ORIGINAL_ROLES = UserDict() # type: ignore # actually UserDict[str, UserSet]\n+var.MAIN_ROLES = UserDict() # type: ignore # actually UserDict[users.User, str]\n+var.ORIGINAL_MAIN_ROLES = UserDict() # type: ignore # actually UserDict[users.User, str]\n+var.FINAL_ROLES = UserDict() # type: ignore # actually UserDict[users.User, str]\n+var.ALL_PLAYERS = UserList() # type: ignore\n+var.FORCE_ROLES = DefaultUserDict(UserSet) # type: ignore\n+var.ORIGINAL_ACCS = UserDict() # type: ignore # actually UserDict[users.User, str]\n+\n+var.IDLE_WARNED = UserSet() # type: ignore\n+var.IDLE_WARNED_PM = UserSet() # type: ignore\n+var.NIGHT_IDLED = UserSet() # type: ignore\n+var.NIGHT_IDLE_EXEMPT = UserSet() # type: ignore\n+\n+var.DEAD = UserSet() # type: ignore\n+\n+var.DEADCHAT_PLAYERS = UserSet() # type: ignore\n+\n+var.SPECTATING_WOLFCHAT = UserSet() # type: ignore\n+var.SPECTATING_DEADCHAT = UserSet() # type: ignore\n+\n+var.ORIGINAL_SETTINGS = {} # type: ignore\n+var.GAMEMODE_VOTES = UserDict() # type: ignore\n+\n+var.LAST_SAID_TIME = UserDict() # type: ignore\n+\n+var.GAME_START_TIME = datetime.now()  # type: ignore # for idle checker only\n+var.CAN_START_TIME = 0 # type: ignore\n+var.STARTED_DAY_PLAYERS = 0 # type: ignore\n+\n+var.DISCONNECTED = UserDict() # type: ignore # actually UserDict[User, Tuple[datetime, str]]\n+\n+var.RESTARTING = False # type: ignore\n \n",
        "source_code_with_indent": "\nvar.LAST_STATS = None\nvar.LAST_ADMINS = None\nvar.LAST_GSTATS = None\nvar.LAST_PSTATS = None\nvar.LAST_RSTATS = None\nvar.LAST_TIME = None\nvar.LAST_GOAT = UserDict() # type: UserDict[users.User, datetime]\n\nvar.ADMIN_PINGING = False\nvar.DCED_LOSERS = UserSet()\nvar.ADMIN_TO_PING = None\nvar.AFTER_FLASTGAME = None\nvar.PINGING_IFS = False\nvar.TIMERS = {}\nvar.PHASE = \"none\"\nvar.OLD_MODES = defaultdict(set)\n\nvar.ROLES = UserDict() # type: UserDict[str, UserSet]\nvar.ORIGINAL_ROLES = UserDict() # type: UserDict[str, UserSet]\nvar.MAIN_ROLES = UserDict() # type: UserDict[users.User, str]\nvar.ORIGINAL_MAIN_ROLES = UserDict() # type: UserDict[users.User, str]\nvar.FINAL_ROLES = UserDict() # type: UserDict[users.User, str]\nvar.ALL_PLAYERS = UserList()\nvar.FORCE_ROLES = DefaultUserDict(UserSet)\nvar.ORIGINAL_ACCS = UserDict() # type: UserDict[users.User, str]\n\nvar.IDLE_WARNED = UserSet()\nvar.IDLE_WARNED_PM = UserSet()\nvar.NIGHT_IDLED = UserSet()\nvar.NIGHT_IDLE_EXEMPT = UserSet()\n\nvar.DEAD = UserSet()\n\nvar.DEADCHAT_PLAYERS = UserSet()\n\nvar.SPECTATING_WOLFCHAT = UserSet()\nvar.SPECTATING_DEADCHAT = UserSet()\n\nvar.ORIGINAL_SETTINGS = {}\nvar.GAMEMODE_VOTES = UserDict()\n\nvar.LAST_SAID_TIME = UserDict()\n\nvar.GAME_START_TIME = datetime.now()  # for idle checker only\nvar.CAN_START_TIME = 0\nvar.STARTED_DAY_PLAYERS = 0\n\nvar.DISCONNECTED = UserDict() # type: UserDict[User, Tuple[datetime, str]]\n\nvar.RESTARTING = False\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\nvar.LAST_STATS = None  # type: ignore\nvar.LAST_ADMINS = None  # type: ignore\nvar.LAST_GSTATS = None  # type: ignore\nvar.LAST_PSTATS = None  # type: ignore\nvar.LAST_RSTATS = None  # type: ignore\nvar.LAST_TIME = None  # type: ignore\nvar.LAST_GOAT = UserDict() # type: ignore # actually UserDict[users.User, datetime]\n\nvar.ADMIN_PINGING = False  # type: ignore\nvar.DCED_LOSERS = UserSet()  # type: ignore\nvar.ADMIN_TO_PING = None  # type: ignore\nvar.AFTER_FLASTGAME = None  # type: ignore\nvar.PINGING_IFS = False  # type: ignore\nvar.TIMERS = {}  # type: ignore\nvar.PHASE = \"none\"  # type: ignore\nvar.OLD_MODES = defaultdict(set)  # type: ignore\n\nvar.ROLES = UserDict() # type: ignore # actually UserDict[str, UserSet]\nvar.ORIGINAL_ROLES = UserDict() # type: ignore # actually UserDict[str, UserSet]\nvar.MAIN_ROLES = UserDict() # type: ignore # actually UserDict[users.User, str]\nvar.ORIGINAL_MAIN_ROLES = UserDict() # type: ignore # actually UserDict[users.User, str]\nvar.FINAL_ROLES = UserDict() # type: ignore # actually UserDict[users.User, str]\nvar.ALL_PLAYERS = UserList() # type: ignore\nvar.FORCE_ROLES = DefaultUserDict(UserSet) # type: ignore\nvar.ORIGINAL_ACCS = UserDict() # type: ignore # actually UserDict[users.User, str]\n\nvar.IDLE_WARNED = UserSet() # type: ignore\nvar.IDLE_WARNED_PM = UserSet() # type: ignore\nvar.NIGHT_IDLED = UserSet() # type: ignore\nvar.NIGHT_IDLE_EXEMPT = UserSet() # type: ignore\n\nvar.DEAD = UserSet() # type: ignore\n\nvar.DEADCHAT_PLAYERS = UserSet() # type: ignore\n\nvar.SPECTATING_WOLFCHAT = UserSet() # type: ignore\nvar.SPECTATING_DEADCHAT = UserSet() # type: ignore\n\nvar.ORIGINAL_SETTINGS = {} # type: ignore\nvar.GAMEMODE_VOTES = UserDict() # type: ignore\n\nvar.LAST_SAID_TIME = UserDict() # type: ignore\n\nvar.GAME_START_TIME = datetime.now()  # type: ignore # for idle checker only\nvar.CAN_START_TIME = 0 # type: ignore\nvar.STARTED_DAY_PLAYERS = 0 # type: ignore\n\nvar.DISCONNECTED = UserDict() # type: ignore # actually UserDict[User, Tuple[datetime, str]]\n\nvar.RESTARTING = False # type: ignore\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  }
]