[
  {
    "project": "PrefectHQ/prefect",
    "commit": "9eca1465b4572efaa8a2bddda85193ff7338745a",
    "filename": "src/prefect/backend/flow_run.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/PrefectHQ-prefect/src/prefect/backend/flow_run.py",
    "file_hunks_size": 6,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": true,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "src/prefect/backend/flow_run.py:394:4 Incompatible variable type [9]: message is declared to have type `str` but is used as type `None`.",
    "message": " message is declared to have type `str` but is used as type `None`.",
    "rule_id": "Incompatible variable type [9]",
    "warning_line_no": 394,
    "warning_line": "    message: str = None,",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": true,
        "has_suppression": false,
        "source_code": "\ndef execute_flow_run(\n    flow_run_id: str,\n    flow: \"Flow\" = None,\n    runner_cls: Type[\"prefect.engine.flow_runner.FlowRunner\"] = None,\n    **kwargs: Any,\n) -> \"FlowRunView\":\n    \"\"\" \"\n    The primary entry point for executing a flow run. The flow run will be run\n    in-process using the given `runner_cls` which defaults to the `CloudFlowRunner`.\n\n    EXPERIMENTAL: This interface is experimental and subject to change\n\n    Args:\n        - flow_run_id: The flow run id to execute; this run id must exist in the database\n        - flow: A Flow object can be passed to execute a flow without loading t from\n            Storage. If `None`, the flow's Storage metadata will be pulled from the\n            API and used to get a functional instance of the Flow and its tasks.\n        - runner_cls: An optional `FlowRunner` to override the default `CloudFlowRunner`\n        - **kwargs: Additional kwargs will be passed to the `FlowRunner.run` method\n\n    Returns:\n        A `FlowRunView` instance with information about the state of the flow run and its\n        task runs\n    \"\"\"\n    logger.debug(f\"Querying for flow run {flow_run_id!r}\")\n\n    # Get the `FlowRunner` class type\n    # TODO: Respect a config option for this class so it can be overridden by env var,\n    #       create a separate config argument for flow runs executed with the backend\n    runner_cls = runner_cls or prefect.engine.cloud.flow_runner.CloudFlowRunner\n\n    # Get data about the flow run from the backend\n    flow_run = FlowRunView.from_flow_run_id(flow_run_id=flow_run_id)\n    flow_metadata = flow_run.get_flow_metadata()\n\n    logger.info(f\"Constructing execution environment for flow run {flow_run_id!r}\")\n\n    # Populate global secrets\n    secrets = prefect.context.get(\"secrets\", {})\n    if flow_metadata.storage:\n        logger.info(\"Loading secrets...\")\n        for secret in flow_metadata.storage.secrets:\n            with fail_flow_run_on_exception(\n                flow_run_id=flow_run_id,\n                message=f\"Failed to load flow secret {secret!r}: {{exc}}\",\n            ):\n                secrets[secret] = prefect.tasks.secrets.PrefectSecret(name=secret).run()\n\n    # Load the flow from storage if not explicitly provided\n    if not flow:\n        logger.info(f\"Loading flow from {flow_metadata.storage}...\")\n        with prefect.context(secrets=secrets, loading_flow=True):\n            with fail_flow_run_on_exception(\n                flow_run_id=flow_run_id,\n                message=\"Failed to load flow from storage: {exc}\",\n            ):\n                flow = flow_metadata.storage.get_flow(flow_metadata.name)\n\n    # Update the run context to include secrets with merging\n    run_kwargs = copy.deepcopy(kwargs)\n    run_kwargs[\"context\"] = run_kwargs.get(\"context\", {})\n    run_kwargs[\"context\"][\"secrets\"] = {\n        # User provided secrets will override secrets we pulled from storage and the\n        # current context\n        **secrets,\n        **run_kwargs[\"context\"].get(\"secrets\", {}),\n    }\n    # Update some default run kwargs with flow settings\n    run_kwargs.setdefault(\"executor\", flow.executor)\n\n    # Execute the flow, this call will block until exit\n    logger.info(\n        f\"Beginning execution of flow run {flow_run.name!r} from {flow_metadata.name!r} \"\n        f\"with {runner_cls.__name__!r}\"\n    )\n    with prefect.context(flow_run_id=flow_run_id):\n        with fail_flow_run_on_exception(\n            flow_run_id=flow_run_id,\n            message=\"Failed to execute flow: {exc}\",\n        ):\n            if flow_metadata.run_config is not None:\n                runner_cls(flow=flow).run(**run_kwargs)\n\n            # Support for deprecated `flow.environment` use\n            else:\n                environment = flow.environment\n                environment.setup(flow)\n                environment.execute(flow)\n\n    # Get the final state\n    flow_run = flow_run.get_latest()\n    logger.info(f\"Run finished with final state {flow_run.state}\")\n    return flow_run\n\n\ndef check_for_compatible_agents(labels: Iterable[str], since_minutes: int = 1) -> str:\n",
        "source_code_len": 4067,
        "target_code": "\ndef check_for_compatible_agents(labels: Iterable[str], since_minutes: int = 1) -> str:\n",
        "target_code_len": 88,
        "diff_format": "@@ -181,97 +164,2 @@\n \n-def execute_flow_run(\n-    flow_run_id: str,\n-    flow: \"Flow\" = None,\n-    runner_cls: Type[\"prefect.engine.flow_runner.FlowRunner\"] = None,\n-    **kwargs: Any,\n-) -> \"FlowRunView\":\n-    \"\"\" \"\n-    The primary entry point for executing a flow run. The flow run will be run\n-    in-process using the given `runner_cls` which defaults to the `CloudFlowRunner`.\n-\n-    EXPERIMENTAL: This interface is experimental and subject to change\n-\n-    Args:\n-        - flow_run_id: The flow run id to execute; this run id must exist in the database\n-        - flow: A Flow object can be passed to execute a flow without loading t from\n-            Storage. If `None`, the flow's Storage metadata will be pulled from the\n-            API and used to get a functional instance of the Flow and its tasks.\n-        - runner_cls: An optional `FlowRunner` to override the default `CloudFlowRunner`\n-        - **kwargs: Additional kwargs will be passed to the `FlowRunner.run` method\n-\n-    Returns:\n-        A `FlowRunView` instance with information about the state of the flow run and its\n-        task runs\n-    \"\"\"\n-    logger.debug(f\"Querying for flow run {flow_run_id!r}\")\n-\n-    # Get the `FlowRunner` class type\n-    # TODO: Respect a config option for this class so it can be overridden by env var,\n-    #       create a separate config argument for flow runs executed with the backend\n-    runner_cls = runner_cls or prefect.engine.cloud.flow_runner.CloudFlowRunner\n-\n-    # Get data about the flow run from the backend\n-    flow_run = FlowRunView.from_flow_run_id(flow_run_id=flow_run_id)\n-    flow_metadata = flow_run.get_flow_metadata()\n-\n-    logger.info(f\"Constructing execution environment for flow run {flow_run_id!r}\")\n-\n-    # Populate global secrets\n-    secrets = prefect.context.get(\"secrets\", {})\n-    if flow_metadata.storage:\n-        logger.info(\"Loading secrets...\")\n-        for secret in flow_metadata.storage.secrets:\n-            with fail_flow_run_on_exception(\n-                flow_run_id=flow_run_id,\n-                message=f\"Failed to load flow secret {secret!r}: {{exc}}\",\n-            ):\n-                secrets[secret] = prefect.tasks.secrets.PrefectSecret(name=secret).run()\n-\n-    # Load the flow from storage if not explicitly provided\n-    if not flow:\n-        logger.info(f\"Loading flow from {flow_metadata.storage}...\")\n-        with prefect.context(secrets=secrets, loading_flow=True):\n-            with fail_flow_run_on_exception(\n-                flow_run_id=flow_run_id,\n-                message=\"Failed to load flow from storage: {exc}\",\n-            ):\n-                flow = flow_metadata.storage.get_flow(flow_metadata.name)\n-\n-    # Update the run context to include secrets with merging\n-    run_kwargs = copy.deepcopy(kwargs)\n-    run_kwargs[\"context\"] = run_kwargs.get(\"context\", {})\n-    run_kwargs[\"context\"][\"secrets\"] = {\n-        # User provided secrets will override secrets we pulled from storage and the\n-        # current context\n-        **secrets,\n-        **run_kwargs[\"context\"].get(\"secrets\", {}),\n-    }\n-    # Update some default run kwargs with flow settings\n-    run_kwargs.setdefault(\"executor\", flow.executor)\n-\n-    # Execute the flow, this call will block until exit\n-    logger.info(\n-        f\"Beginning execution of flow run {flow_run.name!r} from {flow_metadata.name!r} \"\n-        f\"with {runner_cls.__name__!r}\"\n-    )\n-    with prefect.context(flow_run_id=flow_run_id):\n-        with fail_flow_run_on_exception(\n-            flow_run_id=flow_run_id,\n-            message=\"Failed to execute flow: {exc}\",\n-        ):\n-            if flow_metadata.run_config is not None:\n-                runner_cls(flow=flow).run(**run_kwargs)\n-\n-            # Support for deprecated `flow.environment` use\n-            else:\n-                environment = flow.environment\n-                environment.setup(flow)\n-                environment.execute(flow)\n-\n-    # Get the final state\n-    flow_run = flow_run.get_latest()\n-    logger.info(f\"Run finished with final state {flow_run.state}\")\n-    return flow_run\n-\n-\n def check_for_compatible_agents(labels: Iterable[str], since_minutes: int = 1) -> str:\n",
        "source_code_with_indent": "\n<DED><DED>def execute_flow_run(\n    flow_run_id: str,\n    flow: \"Flow\" = None,\n    runner_cls: Type[\"prefect.engine.flow_runner.FlowRunner\"] = None,\n    **kwargs: Any,\n) -> \"FlowRunView\":\n    <IND>\"\"\" \"\n    The primary entry point for executing a flow run. The flow run will be run\n    in-process using the given `runner_cls` which defaults to the `CloudFlowRunner`.\n\n    EXPERIMENTAL: This interface is experimental and subject to change\n\n    Args:\n        - flow_run_id: The flow run id to execute; this run id must exist in the database\n        - flow: A Flow object can be passed to execute a flow without loading t from\n            Storage. If `None`, the flow's Storage metadata will be pulled from the\n            API and used to get a functional instance of the Flow and its tasks.\n        - runner_cls: An optional `FlowRunner` to override the default `CloudFlowRunner`\n        - **kwargs: Additional kwargs will be passed to the `FlowRunner.run` method\n\n    Returns:\n        A `FlowRunView` instance with information about the state of the flow run and its\n        task runs\n    \"\"\"\n    logger.debug(f\"Querying for flow run {flow_run_id!r}\")\n\n    # Get the `FlowRunner` class type\n    # TODO: Respect a config option for this class so it can be overridden by env var,\n    #       create a separate config argument for flow runs executed with the backend\n    runner_cls = runner_cls or prefect.engine.cloud.flow_runner.CloudFlowRunner\n\n    # Get data about the flow run from the backend\n    flow_run = FlowRunView.from_flow_run_id(flow_run_id=flow_run_id)\n    flow_metadata = flow_run.get_flow_metadata()\n\n    logger.info(f\"Constructing execution environment for flow run {flow_run_id!r}\")\n\n    # Populate global secrets\n    secrets = prefect.context.get(\"secrets\", {})\n    if flow_metadata.storage:\n        <IND>logger.info(\"Loading secrets...\")\n        for secret in flow_metadata.storage.secrets:\n            <IND>with fail_flow_run_on_exception(\n                flow_run_id=flow_run_id,\n                message=f\"Failed to load flow secret {secret!r}: {{exc}}\",\n            ):\n                <IND>secrets[secret] = prefect.tasks.secrets.PrefectSecret(name=secret).run()\n\n    # Load the flow from storage if not explicitly provided\n    <DED><DED><DED>if not flow:\n        <IND>logger.info(f\"Loading flow from {flow_metadata.storage}...\")\n        with prefect.context(secrets=secrets, loading_flow=True):\n            <IND>with fail_flow_run_on_exception(\n                flow_run_id=flow_run_id,\n                message=\"Failed to load flow from storage: {exc}\",\n            ):\n                <IND>flow = flow_metadata.storage.get_flow(flow_metadata.name)\n\n    # Update the run context to include secrets with merging\n    <DED><DED><DED>run_kwargs = copy.deepcopy(kwargs)\n    run_kwargs[\"context\"] = run_kwargs.get(\"context\", {})\n    run_kwargs[\"context\"][\"secrets\"] = {\n        # User provided secrets will override secrets we pulled from storage and the\n        # current context\n        **secrets,\n        **run_kwargs[\"context\"].get(\"secrets\", {}),\n    }\n    # Update some default run kwargs with flow settings\n    run_kwargs.setdefault(\"executor\", flow.executor)\n\n    # Execute the flow, this call will block until exit\n    logger.info(\n        f\"Beginning execution of flow run {flow_run.name!r} from {flow_metadata.name!r} \"\n        f\"with {runner_cls.__name__!r}\"\n    )\n    with prefect.context(flow_run_id=flow_run_id):\n        <IND>with fail_flow_run_on_exception(\n            flow_run_id=flow_run_id,\n            message=\"Failed to execute flow: {exc}\",\n        ):\n            <IND>if flow_metadata.run_config is not None:\n                <IND>runner_cls(flow=flow).run(**run_kwargs)\n\n            # Support for deprecated `flow.environment` use\n            <DED>else:\n                <IND>environment = flow.environment\n                environment.setup(flow)\n                environment.execute(flow)\n\n    # Get the final state\n    <DED><DED><DED>flow_run = flow_run.get_latest()\n    logger.info(f\"Run finished with final state {flow_run.state}\")\n    return flow_run\n\n\n<DED>def check_for_compatible_agents(labels: Iterable[str], since_minutes: int = 1) -> str:\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n<DED><DED>def check_for_compatible_agents(labels: Iterable[str], since_minutes: int = 1) -> str:\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": true,
        "has_suppression": false,
        "source_code": "    )\n\n\n@contextmanager\ndef fail_flow_run_on_exception(\n    flow_run_id: str,\n    message: str = None,\n) -> Any:\n    \"\"\"\n    A utility context manager to set the state of the given flow run to 'Failed' if\n    an exception occurs. A custom message can be provided for more details and will\n    be attached to the state and added to the run logs. KeyboardInterrupts will set\n    the flow run state to 'Cancelled' instead and will not use the message. All errors\n    will be re-raised.\n\n\n    Args:\n        - flow_run_id: The flow run id to update the state of\n        - message: The message to include in the state and logs. `{exc}` will be formatted\n            with the exception details.\n    \"\"\"\n    message = message or \"Flow run failed with {exc}\"\n    client = prefect.Client()\n\n    try:\n        yield\n    except Exception as exc:\n        if not FlowRunView.from_flow_run_id(flow_run_id).state.is_finished():\n            message = message.format(exc=exc.__repr__())\n            client.set_flow_run_state(\n                flow_run_id=flow_run_id, state=prefect.engine.state.Failed(message)\n            )\n            client.write_run_logs(\n                [\n                    dict(\n                        flow_run_id=flow_run_id,  # type: ignore\n                        name=\"prefect.backend.api.flow_run.execute_flow_run\",\n                        message=message,\n                        level=\"ERROR\",\n                    )\n                ]\n            )\n        logger.error(message, exc_info=True)\n        raise\n\n",
        "source_code_len": 1521,
        "target_code": "    )\n\n",
        "target_code_len": 7,
        "diff_format": "@@ -388,45 +274,2 @@\n     )\n-\n-\n-@contextmanager\n-def fail_flow_run_on_exception(\n-    flow_run_id: str,\n-    message: str = None,\n-) -> Any:\n-    \"\"\"\n-    A utility context manager to set the state of the given flow run to 'Failed' if\n-    an exception occurs. A custom message can be provided for more details and will\n-    be attached to the state and added to the run logs. KeyboardInterrupts will set\n-    the flow run state to 'Cancelled' instead and will not use the message. All errors\n-    will be re-raised.\n-\n-\n-    Args:\n-        - flow_run_id: The flow run id to update the state of\n-        - message: The message to include in the state and logs. `{exc}` will be formatted\n-            with the exception details.\n-    \"\"\"\n-    message = message or \"Flow run failed with {exc}\"\n-    client = prefect.Client()\n-\n-    try:\n-        yield\n-    except Exception as exc:\n-        if not FlowRunView.from_flow_run_id(flow_run_id).state.is_finished():\n-            message = message.format(exc=exc.__repr__())\n-            client.set_flow_run_state(\n-                flow_run_id=flow_run_id, state=prefect.engine.state.Failed(message)\n-            )\n-            client.write_run_logs(\n-                [\n-                    dict(\n-                        flow_run_id=flow_run_id,  # type: ignore\n-                        name=\"prefect.backend.api.flow_run.execute_flow_run\",\n-                        message=message,\n-                        level=\"ERROR\",\n-                    )\n-                ]\n-            )\n-        logger.error(message, exc_info=True)\n-        raise\n \n",
        "source_code_with_indent": "    )\n\n\n<DED>@contextmanager\ndef fail_flow_run_on_exception(\n    flow_run_id: str,\n    message: str = None,\n) -> Any:\n    <IND>\"\"\"\n    A utility context manager to set the state of the given flow run to 'Failed' if\n    an exception occurs. A custom message can be provided for more details and will\n    be attached to the state and added to the run logs. KeyboardInterrupts will set\n    the flow run state to 'Cancelled' instead and will not use the message. All errors\n    will be re-raised.\n\n\n    Args:\n        - flow_run_id: The flow run id to update the state of\n        - message: The message to include in the state and logs. `{exc}` will be formatted\n            with the exception details.\n    \"\"\"\n    message = message or \"Flow run failed with {exc}\"\n    client = prefect.Client()\n\n    try:\n        <IND>yield\n    <DED>except Exception as exc:\n        <IND>if not FlowRunView.from_flow_run_id(flow_run_id).state.is_finished():\n            <IND>message = message.format(exc=exc.__repr__())\n            client.set_flow_run_state(\n                flow_run_id=flow_run_id, state=prefect.engine.state.Failed(message)\n            )\n            client.write_run_logs(\n                [\n                    dict(\n                        flow_run_id=flow_run_id,  # type: ignore\n                        name=\"prefect.backend.api.flow_run.execute_flow_run\",\n                        message=message,\n                        level=\"ERROR\",\n                    )\n                ]\n            )\n        <DED>logger.error(message, exc_info=True)\n        raise\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    )\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  }
]