[
  {
    "project": "TheAlgorithms/Python",
    "commit": "bf6db32ec2fb04b6477722f0809c5efef0cad813",
    "filename": "data_structures/binary_tree/binary_tree_traversals.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/TheAlgorithms-Python/data_structures/binary_tree/binary_tree_traversals.py",
    "file_hunks_size": 8,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "data_structures/binary_tree/binary_tree_traversals.py:24:34 Incompatible parameter type [6]: Expected `Node` for 1st positional only parameter to call `preorder` but got `typing.Optional[Node]`.",
    "message": " Expected `Node` for 1st positional only parameter to call `preorder` but got `typing.Optional[Node]`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 24,
    "warning_line": "    return [root.data] + preorder(root.left) + preorder(root.right) if root else []",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\ndef preorder(root: Node):\n    \"\"\"\n",
        "source_code_len": 35,
        "target_code": "\ndef preorder(root: Node | None) -> list[int]:\n    \"\"\"\n",
        "target_code_len": 55,
        "diff_format": "@@ -17,3 +19,3 @@\n \n-def preorder(root: Node):\n+def preorder(root: Node | None) -> list[int]:\n     \"\"\"\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\n<DED>def preorder(root: Node):\n    <IND>",
        "target_code_with_indent": "\n<DED>def preorder(root: Node | None) -> list[int]:\n    <IND>"
      }
    ]
  },
  {
    "project": "TheAlgorithms/Python",
    "commit": "bf6db32ec2fb04b6477722f0809c5efef0cad813",
    "filename": "data_structures/binary_tree/binary_tree_traversals.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/TheAlgorithms-Python/data_structures/binary_tree/binary_tree_traversals.py",
    "file_hunks_size": 8,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "data_structures/binary_tree/binary_tree_traversals.py:24:56 Incompatible parameter type [6]: Expected `Node` for 1st positional only parameter to call `preorder` but got `typing.Optional[Node]`.",
    "message": " Expected `Node` for 1st positional only parameter to call `preorder` but got `typing.Optional[Node]`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 24,
    "warning_line": "    return [root.data] + preorder(root.left) + preorder(root.right) if root else []",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\ndef preorder(root: Node):\n    \"\"\"\n",
        "source_code_len": 35,
        "target_code": "\ndef preorder(root: Node | None) -> list[int]:\n    \"\"\"\n",
        "target_code_len": 55,
        "diff_format": "@@ -17,3 +19,3 @@\n \n-def preorder(root: Node):\n+def preorder(root: Node | None) -> list[int]:\n     \"\"\"\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\n<DED>def preorder(root: Node):\n    <IND>",
        "target_code_with_indent": "\n<DED>def preorder(root: Node | None) -> list[int]:\n    <IND>"
      }
    ]
  },
  {
    "project": "TheAlgorithms/Python",
    "commit": "bf6db32ec2fb04b6477722f0809c5efef0cad813",
    "filename": "data_structures/binary_tree/binary_tree_traversals.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/TheAlgorithms-Python/data_structures/binary_tree/binary_tree_traversals.py",
    "file_hunks_size": 8,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "data_structures/binary_tree/binary_tree_traversals.py:33:21 Incompatible parameter type [6]: Expected `Node` for 1st positional only parameter to call `postorder` but got `typing.Optional[Node]`.",
    "message": " Expected `Node` for 1st positional only parameter to call `postorder` but got `typing.Optional[Node]`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 33,
    "warning_line": "    return postorder(root.left) + postorder(root.right) + [root.data] if root else []",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\ndef postorder(root: Node):\n    \"\"\"\n",
        "source_code_len": 36,
        "target_code": "\ndef postorder(root: Node | None) -> list[int]:\n    \"\"\"\n",
        "target_code_len": 56,
        "diff_format": "@@ -26,3 +28,3 @@\n \n-def postorder(root: Node):\n+def postorder(root: Node | None) -> list[int]:\n     \"\"\"\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\n<DED>def postorder(root: Node):\n    <IND>",
        "target_code_with_indent": "\n<DED>def postorder(root: Node | None) -> list[int]:\n    <IND>"
      }
    ]
  },
  {
    "project": "TheAlgorithms/Python",
    "commit": "bf6db32ec2fb04b6477722f0809c5efef0cad813",
    "filename": "data_structures/binary_tree/binary_tree_traversals.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/TheAlgorithms-Python/data_structures/binary_tree/binary_tree_traversals.py",
    "file_hunks_size": 8,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "data_structures/binary_tree/binary_tree_traversals.py:33:44 Incompatible parameter type [6]: Expected `Node` for 1st positional only parameter to call `postorder` but got `typing.Optional[Node]`.",
    "message": " Expected `Node` for 1st positional only parameter to call `postorder` but got `typing.Optional[Node]`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 33,
    "warning_line": "    return postorder(root.left) + postorder(root.right) + [root.data] if root else []",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\ndef postorder(root: Node):\n    \"\"\"\n",
        "source_code_len": 36,
        "target_code": "\ndef postorder(root: Node | None) -> list[int]:\n    \"\"\"\n",
        "target_code_len": 56,
        "diff_format": "@@ -26,3 +28,3 @@\n \n-def postorder(root: Node):\n+def postorder(root: Node | None) -> list[int]:\n     \"\"\"\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\n<DED>def postorder(root: Node):\n    <IND>",
        "target_code_with_indent": "\n<DED>def postorder(root: Node | None) -> list[int]:\n    <IND>"
      }
    ]
  },
  {
    "project": "TheAlgorithms/Python",
    "commit": "bf6db32ec2fb04b6477722f0809c5efef0cad813",
    "filename": "data_structures/binary_tree/binary_tree_traversals.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/TheAlgorithms-Python/data_structures/binary_tree/binary_tree_traversals.py",
    "file_hunks_size": 8,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "data_structures/binary_tree/binary_tree_traversals.py:42:19 Incompatible parameter type [6]: Expected `Node` for 1st positional only parameter to call `inorder` but got `typing.Optional[Node]`.",
    "message": " Expected `Node` for 1st positional only parameter to call `inorder` but got `typing.Optional[Node]`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 42,
    "warning_line": "    return inorder(root.left) + [root.data] + inorder(root.right) if root else []",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\ndef inorder(root: Node):\n    \"\"\"\n",
        "source_code_len": 34,
        "target_code": "\ndef inorder(root: Node | None) -> list[int]:\n    \"\"\"\n",
        "target_code_len": 54,
        "diff_format": "@@ -35,3 +37,3 @@\n \n-def inorder(root: Node):\n+def inorder(root: Node | None) -> list[int]:\n     \"\"\"\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\n<DED>def inorder(root: Node):\n    <IND>",
        "target_code_with_indent": "\n<DED>def inorder(root: Node | None) -> list[int]:\n    <IND>"
      }
    ]
  },
  {
    "project": "TheAlgorithms/Python",
    "commit": "bf6db32ec2fb04b6477722f0809c5efef0cad813",
    "filename": "data_structures/binary_tree/binary_tree_traversals.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/TheAlgorithms-Python/data_structures/binary_tree/binary_tree_traversals.py",
    "file_hunks_size": 8,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "data_structures/binary_tree/binary_tree_traversals.py:42:54 Incompatible parameter type [6]: Expected `Node` for 1st positional only parameter to call `inorder` but got `typing.Optional[Node]`.",
    "message": " Expected `Node` for 1st positional only parameter to call `inorder` but got `typing.Optional[Node]`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 42,
    "warning_line": "    return inorder(root.left) + [root.data] + inorder(root.right) if root else []",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\ndef inorder(root: Node):\n    \"\"\"\n",
        "source_code_len": 34,
        "target_code": "\ndef inorder(root: Node | None) -> list[int]:\n    \"\"\"\n",
        "target_code_len": 54,
        "diff_format": "@@ -35,3 +37,3 @@\n \n-def inorder(root: Node):\n+def inorder(root: Node | None) -> list[int]:\n     \"\"\"\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\n<DED>def inorder(root: Node):\n    <IND>",
        "target_code_with_indent": "\n<DED>def inorder(root: Node | None) -> list[int]:\n    <IND>"
      }
    ]
  },
  {
    "project": "TheAlgorithms/Python",
    "commit": "bf6db32ec2fb04b6477722f0809c5efef0cad813",
    "filename": "data_structures/binary_tree/binary_tree_traversals.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/TheAlgorithms-Python/data_structures/binary_tree/binary_tree_traversals.py",
    "file_hunks_size": 8,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "data_structures/binary_tree/binary_tree_traversals.py:53:23 Incompatible parameter type [6]: Expected `Node` for 1st positional only parameter to call `height` but got `typing.Optional[Node]`.",
    "message": " Expected `Node` for 1st positional only parameter to call `height` but got `typing.Optional[Node]`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 53,
    "warning_line": "    return (max(height(root.left), height(root.right)) + 1) if root else 0",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\ndef height(root: Node):\n    \"\"\"\n",
        "source_code_len": 33,
        "target_code": "\ndef height(root: Node | None) -> int:\n    \"\"\"\n",
        "target_code_len": 47,
        "diff_format": "@@ -44,3 +46,3 @@\n \n-def height(root: Node):\n+def height(root: Node | None) -> int:\n     \"\"\"\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\n<DED>def height(root: Node):\n    <IND>",
        "target_code_with_indent": "\n<DED>def height(root: Node | None) -> int:\n    <IND>"
      }
    ]
  },
  {
    "project": "TheAlgorithms/Python",
    "commit": "bf6db32ec2fb04b6477722f0809c5efef0cad813",
    "filename": "data_structures/binary_tree/binary_tree_traversals.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/TheAlgorithms-Python/data_structures/binary_tree/binary_tree_traversals.py",
    "file_hunks_size": 8,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "data_structures/binary_tree/binary_tree_traversals.py:53:42 Incompatible parameter type [6]: Expected `Node` for 1st positional only parameter to call `height` but got `typing.Optional[Node]`.",
    "message": " Expected `Node` for 1st positional only parameter to call `height` but got `typing.Optional[Node]`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 53,
    "warning_line": "    return (max(height(root.left), height(root.right)) + 1) if root else 0",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\ndef height(root: Node):\n    \"\"\"\n",
        "source_code_len": 33,
        "target_code": "\ndef height(root: Node | None) -> int:\n    \"\"\"\n",
        "target_code_len": 47,
        "diff_format": "@@ -44,3 +46,3 @@\n \n-def height(root: Node):\n+def height(root: Node | None) -> int:\n     \"\"\"\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\n<DED>def height(root: Node):\n    <IND>",
        "target_code_with_indent": "\n<DED>def height(root: Node | None) -> int:\n    <IND>"
      }
    ]
  },
  {
    "project": "TheAlgorithms/Python",
    "commit": "bf6db32ec2fb04b6477722f0809c5efef0cad813",
    "filename": "data_structures/binary_tree/binary_tree_traversals.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/TheAlgorithms-Python/data_structures/binary_tree/binary_tree_traversals.py",
    "file_hunks_size": 8,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "data_structures/binary_tree/binary_tree_traversals.py:84:22 Incompatible parameter type [6]: Expected `Node` for 1st positional only parameter to call `level_order_2` but got `typing.Optional[Node]`.",
    "message": " Expected `Node` for 1st positional only parameter to call `level_order_2` but got `typing.Optional[Node]`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 84,
    "warning_line": "        level_order_2(root.left, level - 1)",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\nfrom dataclasses import dataclass\n\n",
        "source_code_len": 36,
        "target_code": "\nfrom collections import deque\nfrom dataclasses import dataclass\nfrom typing import Any, Sequence\n\n",
        "target_code_len": 99,
        "diff_format": "@@ -3,3 +3,5 @@\n \n+from collections import deque\n from dataclasses import dataclass\n+from typing import Any, Sequence\n \n",
        "source_code_with_indent": "\nfrom dataclasses import dataclass\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\nfrom collections import deque\nfrom dataclasses import dataclass\nfrom typing import Any, Sequence\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\ndef level_order_1(root: Node):\n    \"\"\"\n    Print whole binary tree in Level Order Traverse.\n    Level Order traverse: Visit nodes of the tree level-by-level.\n    \"\"\"\n    if not root:\n        return\n    temp = root\n    que = [temp]\n    while len(que) > 0:\n        print(que[0].data, end=\" \")\n        temp = que.pop(0)\n        if temp.left:\n            que.append(temp.left)\n        if temp.right:\n            que.append(temp.right)\n    return que\n\n\ndef level_order_2(root: Node, level: int):\n    \"\"\"\n    Level-wise traversal: Print all nodes present at the given level of the binary tree\n    \"\"\"\n    if not root:\n        return root\n    if level == 1:\n        print(root.data, end=\" \")\n    elif level > 1:\n        level_order_2(root.left, level - 1)\n        level_order_2(root.right, level - 1)\n\n\ndef print_left_to_right(root: Node, level: int):\n    \"\"\"\n    Print elements on particular level from left to right direction of the binary tree.\n    \"\"\"\n    if not root:\n        return\n    if level == 1:\n        print(root.data, end=\" \")\n    elif level > 1:\n        print_left_to_right(root.left, level - 1)\n        print_left_to_right(root.right, level - 1)\n\n\ndef print_right_to_left(root: Node, level: int):\n    \"\"\"\n    Print elements on particular level from right to left direction of the binary tree.\n    \"\"\"\n    if not root:\n        return\n    if level == 1:\n        print(root.data, end=\" \")\n    elif level > 1:\n        print_right_to_left(root.right, level - 1)\n        print_right_to_left(root.left, level - 1)\n\n\ndef zigzag(root: Node):\n    \"\"\"\n    ZigZag traverse: Print node left to right and right to left, alternatively.\n    \"\"\"\n    flag = 0\n    height_tree = height(root)\n    for h in range(1, height_tree + 1):\n        if flag == 0:\n            print_left_to_right(root, h)\n            flag = 1\n        else:\n            print_right_to_left(root, h)\n            flag = 0\n\n\ndef main():  # Main function for testing.\n    \"\"\"\n",
        "source_code_len": 1935,
        "target_code": "\ndef level_order(root: Node | None) -> Sequence[Node | None]:\n    \"\"\"\n    Returns a list of nodes value from a whole binary tree in Level Order Traverse.\n    Level Order traverse: Visit nodes of the tree level-by-level.\n    \"\"\"\n    output: list[Any] = []\n\n    if root is None:\n        return output\n\n    process_queue = deque([root])\n\n    while process_queue:\n        node = process_queue.popleft()\n        output.append(node.data)\n\n        if node.left:\n            process_queue.append(node.left)\n        if node.right:\n            process_queue.append(node.right)\n    return output\n\n\ndef get_nodes_from_left_to_right(\n    root: Node | None, level: int\n) -> Sequence[Node | None]:\n    \"\"\"\n    Returns a list of nodes value from a particular level:\n    Left to right direction of the binary tree.\n    \"\"\"\n    output: list[Any] = []\n\n    def populate_output(root: Node | None, level: int) -> None:\n        if not root:\n            return\n        if level == 1:\n\n            output.append(root.data)\n        elif level > 1:\n            populate_output(root.left, level - 1)\n            populate_output(root.right, level - 1)\n\n    populate_output(root, level)\n    return output\n\n\ndef get_nodes_from_right_to_left(\n    root: Node | None, level: int\n) -> Sequence[Node | None]:\n    \"\"\"\n    Returns a list of nodes value from a particular level:\n    Right to left direction of the binary tree.\n    \"\"\"\n    output: list[Any] = []\n\n    def populate_output(root: Node | None, level: int) -> None:\n        if root is None:\n            return\n        if level == 1:\n            output.append(root.data)\n        elif level > 1:\n            populate_output(root.right, level - 1)\n            populate_output(root.left, level - 1)\n\n    populate_output(root, level)\n    return output\n\n\ndef zigzag(root: Node | None) -> Sequence[Node | None] | list[Any]:\n    \"\"\"\n    ZigZag traverse:\n    Returns a list of nodes value from left to right and right to left, alternatively.\n    \"\"\"\n    if root is None:\n        return []\n\n    output: list[Sequence[Node | None]] = []\n\n    flag = 0\n    height_tree = height(root)\n\n    for h in range(1, height_tree + 1):\n        if not flag:\n            output.append(get_nodes_from_left_to_right(root, h))\n            flag = 1\n        else:\n            output.append(get_nodes_from_right_to_left(root, h))\n            flag = 0\n\n    return output\n\n\ndef main() -> None:  # Main function for testing.\n    \"\"\"\n",
        "target_code_len": 2421,
        "diff_format": "@@ -55,76 +57,95 @@\n \n-def level_order_1(root: Node):\n+def level_order(root: Node | None) -> Sequence[Node | None]:\n     \"\"\"\n-    Print whole binary tree in Level Order Traverse.\n+    Returns a list of nodes value from a whole binary tree in Level Order Traverse.\n     Level Order traverse: Visit nodes of the tree level-by-level.\n     \"\"\"\n-    if not root:\n-        return\n-    temp = root\n-    que = [temp]\n-    while len(que) > 0:\n-        print(que[0].data, end=\" \")\n-        temp = que.pop(0)\n-        if temp.left:\n-            que.append(temp.left)\n-        if temp.right:\n-            que.append(temp.right)\n-    return que\n+    output: list[Any] = []\n+\n+    if root is None:\n+        return output\n+\n+    process_queue = deque([root])\n+\n+    while process_queue:\n+        node = process_queue.popleft()\n+        output.append(node.data)\n+\n+        if node.left:\n+            process_queue.append(node.left)\n+        if node.right:\n+            process_queue.append(node.right)\n+    return output\n \n \n-def level_order_2(root: Node, level: int):\n+def get_nodes_from_left_to_right(\n+    root: Node | None, level: int\n+) -> Sequence[Node | None]:\n     \"\"\"\n-    Level-wise traversal: Print all nodes present at the given level of the binary tree\n+    Returns a list of nodes value from a particular level:\n+    Left to right direction of the binary tree.\n     \"\"\"\n-    if not root:\n-        return root\n-    if level == 1:\n-        print(root.data, end=\" \")\n-    elif level > 1:\n-        level_order_2(root.left, level - 1)\n-        level_order_2(root.right, level - 1)\n+    output: list[Any] = []\n+\n+    def populate_output(root: Node | None, level: int) -> None:\n+        if not root:\n+            return\n+        if level == 1:\n+\n+            output.append(root.data)\n+        elif level > 1:\n+            populate_output(root.left, level - 1)\n+            populate_output(root.right, level - 1)\n+\n+    populate_output(root, level)\n+    return output\n \n \n-def print_left_to_right(root: Node, level: int):\n+def get_nodes_from_right_to_left(\n+    root: Node | None, level: int\n+) -> Sequence[Node | None]:\n     \"\"\"\n-    Print elements on particular level from left to right direction of the binary tree.\n+    Returns a list of nodes value from a particular level:\n+    Right to left direction of the binary tree.\n     \"\"\"\n-    if not root:\n-        return\n-    if level == 1:\n-        print(root.data, end=\" \")\n-    elif level > 1:\n-        print_left_to_right(root.left, level - 1)\n-        print_left_to_right(root.right, level - 1)\n+    output: list[Any] = []\n+\n+    def populate_output(root: Node | None, level: int) -> None:\n+        if root is None:\n+            return\n+        if level == 1:\n+            output.append(root.data)\n+        elif level > 1:\n+            populate_output(root.right, level - 1)\n+            populate_output(root.left, level - 1)\n+\n+    populate_output(root, level)\n+    return output\n \n \n-def print_right_to_left(root: Node, level: int):\n+def zigzag(root: Node | None) -> Sequence[Node | None] | list[Any]:\n     \"\"\"\n-    Print elements on particular level from right to left direction of the binary tree.\n+    ZigZag traverse:\n+    Returns a list of nodes value from left to right and right to left, alternatively.\n     \"\"\"\n-    if not root:\n-        return\n-    if level == 1:\n-        print(root.data, end=\" \")\n-    elif level > 1:\n-        print_right_to_left(root.right, level - 1)\n-        print_right_to_left(root.left, level - 1)\n+    if root is None:\n+        return []\n+\n+    output: list[Sequence[Node | None]] = []\n+\n+    flag = 0\n+    height_tree = height(root)\n+\n+    for h in range(1, height_tree + 1):\n+        if not flag:\n+            output.append(get_nodes_from_left_to_right(root, h))\n+            flag = 1\n+        else:\n+            output.append(get_nodes_from_right_to_left(root, h))\n+            flag = 0\n+\n+    return output\n \n \n-def zigzag(root: Node):\n-    \"\"\"\n-    ZigZag traverse: Print node left to right and right to left, alternatively.\n-    \"\"\"\n-    flag = 0\n-    height_tree = height(root)\n-    for h in range(1, height_tree + 1):\n-        if flag == 0:\n-            print_left_to_right(root, h)\n-            flag = 1\n-        else:\n-            print_right_to_left(root, h)\n-            flag = 0\n-\n-\n-def main():  # Main function for testing.\n+def main() -> None:  # Main function for testing.\n     \"\"\"\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\n<DED>def level_order_1(root: Node):\n    <IND>\"\"\"\n    Print whole binary tree in Level Order Traverse.\n    Level Order traverse: Visit nodes of the tree level-by-level.\n    \"\"\"\n    if not root:\n        <IND>return\n    <DED>temp = root\n    que = [temp]\n    while len(que) > 0:\n        <IND>print(que[0].data, end=\" \")\n        temp = que.pop(0)\n        if temp.left:\n            <IND>que.append(temp.left)\n        <DED>if temp.right:\n            <IND>que.append(temp.right)\n    <DED><DED>return que\n\n\n<DED>def level_order_2(root: Node, level: int):\n    <IND>\"\"\"\n    Level-wise traversal: Print all nodes present at the given level of the binary tree\n    \"\"\"\n    if not root:\n        <IND>return root\n    <DED>if level == 1:\n        <IND>print(root.data, end=\" \")\n    <DED>elif level > 1:\n        <IND>level_order_2(root.left, level - 1)\n        level_order_2(root.right, level - 1)\n\n\n<DED><DED>def print_left_to_right(root: Node, level: int):\n    <IND>\"\"\"\n    Print elements on particular level from left to right direction of the binary tree.\n    \"\"\"\n    if not root:\n        <IND>return\n    <DED>if level == 1:\n        <IND>print(root.data, end=\" \")\n    <DED>elif level > 1:\n        <IND>print_left_to_right(root.left, level - 1)\n        print_left_to_right(root.right, level - 1)\n\n\n<DED><DED>def print_right_to_left(root: Node, level: int):\n    <IND>\"\"\"\n    Print elements on particular level from right to left direction of the binary tree.\n    \"\"\"\n    if not root:\n        <IND>return\n    <DED>if level == 1:\n        <IND>print(root.data, end=\" \")\n    <DED>elif level > 1:\n        <IND>print_right_to_left(root.right, level - 1)\n        print_right_to_left(root.left, level - 1)\n\n\n<DED><DED>def zigzag(root: Node):\n    <IND>\"\"\"\n    ZigZag traverse: Print node left to right and right to left, alternatively.\n    \"\"\"\n    flag = 0\n    height_tree = height(root)\n    for h in range(1, height_tree + 1):\n        <IND>if flag == 0:\n            <IND>print_left_to_right(root, h)\n            flag = 1\n        <DED>else:\n            <IND>print_right_to_left(root, h)\n            flag = 0\n\n\n<DED><DED><DED>def main():  # Main function for testing.\n    <IND>",
        "target_code_with_indent": "\n<DED>def level_order(root: Node | None) -> Sequence[Node | None]:\n    <IND>\"\"\"\n    Returns a list of nodes value from a whole binary tree in Level Order Traverse.\n    Level Order traverse: Visit nodes of the tree level-by-level.\n    \"\"\"\n    output: list[Any] = []\n\n    if root is None:\n        <IND>return output\n\n    <DED>process_queue = deque([root])\n\n    while process_queue:\n        <IND>node = process_queue.popleft()\n        output.append(node.data)\n\n        if node.left:\n            <IND>process_queue.append(node.left)\n        <DED>if node.right:\n            <IND>process_queue.append(node.right)\n    <DED><DED>return output\n\n\n<DED>def get_nodes_from_left_to_right(\n    root: Node | None, level: int\n) -> Sequence[Node | None]:\n    <IND>\"\"\"\n    Returns a list of nodes value from a particular level:\n    Left to right direction of the binary tree.\n    \"\"\"\n    output: list[Any] = []\n\n    def populate_output(root: Node | None, level: int) -> None:\n        <IND>if not root:\n            <IND>return\n        <DED>if level == 1:\n\n            <IND>output.append(root.data)\n        <DED>elif level > 1:\n            <IND>populate_output(root.left, level - 1)\n            populate_output(root.right, level - 1)\n\n    <DED><DED>populate_output(root, level)\n    return output\n\n\n<DED>def get_nodes_from_right_to_left(\n    root: Node | None, level: int\n) -> Sequence[Node | None]:\n    <IND>\"\"\"\n    Returns a list of nodes value from a particular level:\n    Right to left direction of the binary tree.\n    \"\"\"\n    output: list[Any] = []\n\n    def populate_output(root: Node | None, level: int) -> None:\n        <IND>if root is None:\n            <IND>return\n        <DED>if level == 1:\n            <IND>output.append(root.data)\n        <DED>elif level > 1:\n            <IND>populate_output(root.right, level - 1)\n            populate_output(root.left, level - 1)\n\n    <DED><DED>populate_output(root, level)\n    return output\n\n\n<DED>def zigzag(root: Node | None) -> Sequence[Node | None] | list[Any]:\n    <IND>\"\"\"\n    ZigZag traverse:\n    Returns a list of nodes value from left to right and right to left, alternatively.\n    \"\"\"\n    if root is None:\n        <IND>return []\n\n    <DED>output: list[Sequence[Node | None]] = []\n\n    flag = 0\n    height_tree = height(root)\n\n    for h in range(1, height_tree + 1):\n        <IND>if not flag:\n            <IND>output.append(get_nodes_from_left_to_right(root, h))\n            flag = 1\n        <DED>else:\n            <IND>output.append(get_nodes_from_right_to_left(root, h))\n            flag = 0\n\n    <DED><DED>return output\n\n\n<DED>def main() -> None:  # Main function for testing.\n    <IND>"
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    \"\"\"\n    print(f\"  In-order Traversal is {inorder(root)}\")\n    print(f\" Pre-order Traversal is {preorder(root)}\")\n    print(f\"Post-order Traversal is {postorder(root)}\")\n    print(f\"Height of Tree is {height(root)}\")\n    print(\"Complete Level Order Traversal is : \")\n    level_order_1(root)\n    print(\"\\nLevel-wise order Traversal is : \")\n    for h in range(1, height(root) + 1):\n        level_order_2(root, h)\n    print(\"\\nZigZag order Traversal is : \")\n    zigzag(root)\n    print()\n\n",
        "source_code_len": 488,
        "target_code": "    \"\"\"\n\n    print(f\"In-order Traversal: {inorder(root)}\")\n    print(f\"Pre-order Traversal: {preorder(root)}\")\n    print(f\"Post-order Traversal: {postorder(root)}\", \"\\n\")\n\n    print(f\"Height of Tree: {height(root)}\", \"\\n\")\n\n    print(\"Complete Level Order Traversal: \")\n    print(level_order(root), \"\\n\")\n\n    print(\"Level-wise order Traversal: \")\n\n    for level in range(1, height(root) + 1):\n        print(f\"Level {level}:\", get_nodes_from_left_to_right(root, level=level))\n\n    print(\"\\nZigZag order Traversal: \")\n    print(zigzag(root))\n\n",
        "target_code_len": 542,
        "diff_format": "@@ -136,14 +157,19 @@\n     \"\"\"\n-    print(f\"  In-order Traversal is {inorder(root)}\")\n-    print(f\" Pre-order Traversal is {preorder(root)}\")\n-    print(f\"Post-order Traversal is {postorder(root)}\")\n-    print(f\"Height of Tree is {height(root)}\")\n-    print(\"Complete Level Order Traversal is : \")\n-    level_order_1(root)\n-    print(\"\\nLevel-wise order Traversal is : \")\n-    for h in range(1, height(root) + 1):\n-        level_order_2(root, h)\n-    print(\"\\nZigZag order Traversal is : \")\n-    zigzag(root)\n-    print()\n+\n+    print(f\"In-order Traversal: {inorder(root)}\")\n+    print(f\"Pre-order Traversal: {preorder(root)}\")\n+    print(f\"Post-order Traversal: {postorder(root)}\", \"\\n\")\n+\n+    print(f\"Height of Tree: {height(root)}\", \"\\n\")\n+\n+    print(\"Complete Level Order Traversal: \")\n+    print(level_order(root), \"\\n\")\n+\n+    print(\"Level-wise order Traversal: \")\n+\n+    for level in range(1, height(root) + 1):\n+        print(f\"Level {level}:\", get_nodes_from_left_to_right(root, level=level))\n+\n+    print(\"\\nZigZag order Traversal: \")\n+    print(zigzag(root))\n \n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\n    print(f\"  In-order Traversal is {inorder(root)}\")\n    print(f\" Pre-order Traversal is {preorder(root)}\")\n    print(f\"Post-order Traversal is {postorder(root)}\")\n    print(f\"Height of Tree is {height(root)}\")\n    print(\"Complete Level Order Traversal is : \")\n    level_order_1(root)\n    print(\"\\nLevel-wise order Traversal is : \")\n    for h in range(1, height(root) + 1):\n        <IND>level_order_2(root, h)\n    <DED>print(\"\\nZigZag order Traversal is : \")\n    zigzag(root)\n    print()\n\n",
        "target_code_with_indent": "\n\n    print(f\"In-order Traversal: {inorder(root)}\")\n    print(f\"Pre-order Traversal: {preorder(root)}\")\n    print(f\"Post-order Traversal: {postorder(root)}\", \"\\n\")\n\n    print(f\"Height of Tree: {height(root)}\", \"\\n\")\n\n    print(\"Complete Level Order Traversal: \")\n    print(level_order(root), \"\\n\")\n\n    print(\"Level-wise order Traversal: \")\n\n    for level in range(1, height(root) + 1):\n        <IND>print(f\"Level {level}:\", get_nodes_from_left_to_right(root, level=level))\n\n    <DED>print(\"\\nZigZag order Traversal: \")\n    print(zigzag(root))\n\n"
      }
    ]
  },
  {
    "project": "TheAlgorithms/Python",
    "commit": "bf6db32ec2fb04b6477722f0809c5efef0cad813",
    "filename": "data_structures/binary_tree/binary_tree_traversals.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/TheAlgorithms-Python/data_structures/binary_tree/binary_tree_traversals.py",
    "file_hunks_size": 8,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "data_structures/binary_tree/binary_tree_traversals.py:85:22 Incompatible parameter type [6]: Expected `Node` for 1st positional only parameter to call `level_order_2` but got `typing.Optional[Node]`.",
    "message": " Expected `Node` for 1st positional only parameter to call `level_order_2` but got `typing.Optional[Node]`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 85,
    "warning_line": "        level_order_2(root.right, level - 1)",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\nfrom dataclasses import dataclass\n\n",
        "source_code_len": 36,
        "target_code": "\nfrom collections import deque\nfrom dataclasses import dataclass\nfrom typing import Any, Sequence\n\n",
        "target_code_len": 99,
        "diff_format": "@@ -3,3 +3,5 @@\n \n+from collections import deque\n from dataclasses import dataclass\n+from typing import Any, Sequence\n \n",
        "source_code_with_indent": "\nfrom dataclasses import dataclass\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\nfrom collections import deque\nfrom dataclasses import dataclass\nfrom typing import Any, Sequence\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\ndef level_order_1(root: Node):\n    \"\"\"\n    Print whole binary tree in Level Order Traverse.\n    Level Order traverse: Visit nodes of the tree level-by-level.\n    \"\"\"\n    if not root:\n        return\n    temp = root\n    que = [temp]\n    while len(que) > 0:\n        print(que[0].data, end=\" \")\n        temp = que.pop(0)\n        if temp.left:\n            que.append(temp.left)\n        if temp.right:\n            que.append(temp.right)\n    return que\n\n\ndef level_order_2(root: Node, level: int):\n    \"\"\"\n    Level-wise traversal: Print all nodes present at the given level of the binary tree\n    \"\"\"\n    if not root:\n        return root\n    if level == 1:\n        print(root.data, end=\" \")\n    elif level > 1:\n        level_order_2(root.left, level - 1)\n        level_order_2(root.right, level - 1)\n\n\ndef print_left_to_right(root: Node, level: int):\n    \"\"\"\n    Print elements on particular level from left to right direction of the binary tree.\n    \"\"\"\n    if not root:\n        return\n    if level == 1:\n        print(root.data, end=\" \")\n    elif level > 1:\n        print_left_to_right(root.left, level - 1)\n        print_left_to_right(root.right, level - 1)\n\n\ndef print_right_to_left(root: Node, level: int):\n    \"\"\"\n    Print elements on particular level from right to left direction of the binary tree.\n    \"\"\"\n    if not root:\n        return\n    if level == 1:\n        print(root.data, end=\" \")\n    elif level > 1:\n        print_right_to_left(root.right, level - 1)\n        print_right_to_left(root.left, level - 1)\n\n\ndef zigzag(root: Node):\n    \"\"\"\n    ZigZag traverse: Print node left to right and right to left, alternatively.\n    \"\"\"\n    flag = 0\n    height_tree = height(root)\n    for h in range(1, height_tree + 1):\n        if flag == 0:\n            print_left_to_right(root, h)\n            flag = 1\n        else:\n            print_right_to_left(root, h)\n            flag = 0\n\n\ndef main():  # Main function for testing.\n    \"\"\"\n",
        "source_code_len": 1935,
        "target_code": "\ndef level_order(root: Node | None) -> Sequence[Node | None]:\n    \"\"\"\n    Returns a list of nodes value from a whole binary tree in Level Order Traverse.\n    Level Order traverse: Visit nodes of the tree level-by-level.\n    \"\"\"\n    output: list[Any] = []\n\n    if root is None:\n        return output\n\n    process_queue = deque([root])\n\n    while process_queue:\n        node = process_queue.popleft()\n        output.append(node.data)\n\n        if node.left:\n            process_queue.append(node.left)\n        if node.right:\n            process_queue.append(node.right)\n    return output\n\n\ndef get_nodes_from_left_to_right(\n    root: Node | None, level: int\n) -> Sequence[Node | None]:\n    \"\"\"\n    Returns a list of nodes value from a particular level:\n    Left to right direction of the binary tree.\n    \"\"\"\n    output: list[Any] = []\n\n    def populate_output(root: Node | None, level: int) -> None:\n        if not root:\n            return\n        if level == 1:\n\n            output.append(root.data)\n        elif level > 1:\n            populate_output(root.left, level - 1)\n            populate_output(root.right, level - 1)\n\n    populate_output(root, level)\n    return output\n\n\ndef get_nodes_from_right_to_left(\n    root: Node | None, level: int\n) -> Sequence[Node | None]:\n    \"\"\"\n    Returns a list of nodes value from a particular level:\n    Right to left direction of the binary tree.\n    \"\"\"\n    output: list[Any] = []\n\n    def populate_output(root: Node | None, level: int) -> None:\n        if root is None:\n            return\n        if level == 1:\n            output.append(root.data)\n        elif level > 1:\n            populate_output(root.right, level - 1)\n            populate_output(root.left, level - 1)\n\n    populate_output(root, level)\n    return output\n\n\ndef zigzag(root: Node | None) -> Sequence[Node | None] | list[Any]:\n    \"\"\"\n    ZigZag traverse:\n    Returns a list of nodes value from left to right and right to left, alternatively.\n    \"\"\"\n    if root is None:\n        return []\n\n    output: list[Sequence[Node | None]] = []\n\n    flag = 0\n    height_tree = height(root)\n\n    for h in range(1, height_tree + 1):\n        if not flag:\n            output.append(get_nodes_from_left_to_right(root, h))\n            flag = 1\n        else:\n            output.append(get_nodes_from_right_to_left(root, h))\n            flag = 0\n\n    return output\n\n\ndef main() -> None:  # Main function for testing.\n    \"\"\"\n",
        "target_code_len": 2421,
        "diff_format": "@@ -55,76 +57,95 @@\n \n-def level_order_1(root: Node):\n+def level_order(root: Node | None) -> Sequence[Node | None]:\n     \"\"\"\n-    Print whole binary tree in Level Order Traverse.\n+    Returns a list of nodes value from a whole binary tree in Level Order Traverse.\n     Level Order traverse: Visit nodes of the tree level-by-level.\n     \"\"\"\n-    if not root:\n-        return\n-    temp = root\n-    que = [temp]\n-    while len(que) > 0:\n-        print(que[0].data, end=\" \")\n-        temp = que.pop(0)\n-        if temp.left:\n-            que.append(temp.left)\n-        if temp.right:\n-            que.append(temp.right)\n-    return que\n+    output: list[Any] = []\n+\n+    if root is None:\n+        return output\n+\n+    process_queue = deque([root])\n+\n+    while process_queue:\n+        node = process_queue.popleft()\n+        output.append(node.data)\n+\n+        if node.left:\n+            process_queue.append(node.left)\n+        if node.right:\n+            process_queue.append(node.right)\n+    return output\n \n \n-def level_order_2(root: Node, level: int):\n+def get_nodes_from_left_to_right(\n+    root: Node | None, level: int\n+) -> Sequence[Node | None]:\n     \"\"\"\n-    Level-wise traversal: Print all nodes present at the given level of the binary tree\n+    Returns a list of nodes value from a particular level:\n+    Left to right direction of the binary tree.\n     \"\"\"\n-    if not root:\n-        return root\n-    if level == 1:\n-        print(root.data, end=\" \")\n-    elif level > 1:\n-        level_order_2(root.left, level - 1)\n-        level_order_2(root.right, level - 1)\n+    output: list[Any] = []\n+\n+    def populate_output(root: Node | None, level: int) -> None:\n+        if not root:\n+            return\n+        if level == 1:\n+\n+            output.append(root.data)\n+        elif level > 1:\n+            populate_output(root.left, level - 1)\n+            populate_output(root.right, level - 1)\n+\n+    populate_output(root, level)\n+    return output\n \n \n-def print_left_to_right(root: Node, level: int):\n+def get_nodes_from_right_to_left(\n+    root: Node | None, level: int\n+) -> Sequence[Node | None]:\n     \"\"\"\n-    Print elements on particular level from left to right direction of the binary tree.\n+    Returns a list of nodes value from a particular level:\n+    Right to left direction of the binary tree.\n     \"\"\"\n-    if not root:\n-        return\n-    if level == 1:\n-        print(root.data, end=\" \")\n-    elif level > 1:\n-        print_left_to_right(root.left, level - 1)\n-        print_left_to_right(root.right, level - 1)\n+    output: list[Any] = []\n+\n+    def populate_output(root: Node | None, level: int) -> None:\n+        if root is None:\n+            return\n+        if level == 1:\n+            output.append(root.data)\n+        elif level > 1:\n+            populate_output(root.right, level - 1)\n+            populate_output(root.left, level - 1)\n+\n+    populate_output(root, level)\n+    return output\n \n \n-def print_right_to_left(root: Node, level: int):\n+def zigzag(root: Node | None) -> Sequence[Node | None] | list[Any]:\n     \"\"\"\n-    Print elements on particular level from right to left direction of the binary tree.\n+    ZigZag traverse:\n+    Returns a list of nodes value from left to right and right to left, alternatively.\n     \"\"\"\n-    if not root:\n-        return\n-    if level == 1:\n-        print(root.data, end=\" \")\n-    elif level > 1:\n-        print_right_to_left(root.right, level - 1)\n-        print_right_to_left(root.left, level - 1)\n+    if root is None:\n+        return []\n+\n+    output: list[Sequence[Node | None]] = []\n+\n+    flag = 0\n+    height_tree = height(root)\n+\n+    for h in range(1, height_tree + 1):\n+        if not flag:\n+            output.append(get_nodes_from_left_to_right(root, h))\n+            flag = 1\n+        else:\n+            output.append(get_nodes_from_right_to_left(root, h))\n+            flag = 0\n+\n+    return output\n \n \n-def zigzag(root: Node):\n-    \"\"\"\n-    ZigZag traverse: Print node left to right and right to left, alternatively.\n-    \"\"\"\n-    flag = 0\n-    height_tree = height(root)\n-    for h in range(1, height_tree + 1):\n-        if flag == 0:\n-            print_left_to_right(root, h)\n-            flag = 1\n-        else:\n-            print_right_to_left(root, h)\n-            flag = 0\n-\n-\n-def main():  # Main function for testing.\n+def main() -> None:  # Main function for testing.\n     \"\"\"\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\n<DED>def level_order_1(root: Node):\n    <IND>\"\"\"\n    Print whole binary tree in Level Order Traverse.\n    Level Order traverse: Visit nodes of the tree level-by-level.\n    \"\"\"\n    if not root:\n        <IND>return\n    <DED>temp = root\n    que = [temp]\n    while len(que) > 0:\n        <IND>print(que[0].data, end=\" \")\n        temp = que.pop(0)\n        if temp.left:\n            <IND>que.append(temp.left)\n        <DED>if temp.right:\n            <IND>que.append(temp.right)\n    <DED><DED>return que\n\n\n<DED>def level_order_2(root: Node, level: int):\n    <IND>\"\"\"\n    Level-wise traversal: Print all nodes present at the given level of the binary tree\n    \"\"\"\n    if not root:\n        <IND>return root\n    <DED>if level == 1:\n        <IND>print(root.data, end=\" \")\n    <DED>elif level > 1:\n        <IND>level_order_2(root.left, level - 1)\n        level_order_2(root.right, level - 1)\n\n\n<DED><DED>def print_left_to_right(root: Node, level: int):\n    <IND>\"\"\"\n    Print elements on particular level from left to right direction of the binary tree.\n    \"\"\"\n    if not root:\n        <IND>return\n    <DED>if level == 1:\n        <IND>print(root.data, end=\" \")\n    <DED>elif level > 1:\n        <IND>print_left_to_right(root.left, level - 1)\n        print_left_to_right(root.right, level - 1)\n\n\n<DED><DED>def print_right_to_left(root: Node, level: int):\n    <IND>\"\"\"\n    Print elements on particular level from right to left direction of the binary tree.\n    \"\"\"\n    if not root:\n        <IND>return\n    <DED>if level == 1:\n        <IND>print(root.data, end=\" \")\n    <DED>elif level > 1:\n        <IND>print_right_to_left(root.right, level - 1)\n        print_right_to_left(root.left, level - 1)\n\n\n<DED><DED>def zigzag(root: Node):\n    <IND>\"\"\"\n    ZigZag traverse: Print node left to right and right to left, alternatively.\n    \"\"\"\n    flag = 0\n    height_tree = height(root)\n    for h in range(1, height_tree + 1):\n        <IND>if flag == 0:\n            <IND>print_left_to_right(root, h)\n            flag = 1\n        <DED>else:\n            <IND>print_right_to_left(root, h)\n            flag = 0\n\n\n<DED><DED><DED>def main():  # Main function for testing.\n    <IND>",
        "target_code_with_indent": "\n<DED>def level_order(root: Node | None) -> Sequence[Node | None]:\n    <IND>\"\"\"\n    Returns a list of nodes value from a whole binary tree in Level Order Traverse.\n    Level Order traverse: Visit nodes of the tree level-by-level.\n    \"\"\"\n    output: list[Any] = []\n\n    if root is None:\n        <IND>return output\n\n    <DED>process_queue = deque([root])\n\n    while process_queue:\n        <IND>node = process_queue.popleft()\n        output.append(node.data)\n\n        if node.left:\n            <IND>process_queue.append(node.left)\n        <DED>if node.right:\n            <IND>process_queue.append(node.right)\n    <DED><DED>return output\n\n\n<DED>def get_nodes_from_left_to_right(\n    root: Node | None, level: int\n) -> Sequence[Node | None]:\n    <IND>\"\"\"\n    Returns a list of nodes value from a particular level:\n    Left to right direction of the binary tree.\n    \"\"\"\n    output: list[Any] = []\n\n    def populate_output(root: Node | None, level: int) -> None:\n        <IND>if not root:\n            <IND>return\n        <DED>if level == 1:\n\n            <IND>output.append(root.data)\n        <DED>elif level > 1:\n            <IND>populate_output(root.left, level - 1)\n            populate_output(root.right, level - 1)\n\n    <DED><DED>populate_output(root, level)\n    return output\n\n\n<DED>def get_nodes_from_right_to_left(\n    root: Node | None, level: int\n) -> Sequence[Node | None]:\n    <IND>\"\"\"\n    Returns a list of nodes value from a particular level:\n    Right to left direction of the binary tree.\n    \"\"\"\n    output: list[Any] = []\n\n    def populate_output(root: Node | None, level: int) -> None:\n        <IND>if root is None:\n            <IND>return\n        <DED>if level == 1:\n            <IND>output.append(root.data)\n        <DED>elif level > 1:\n            <IND>populate_output(root.right, level - 1)\n            populate_output(root.left, level - 1)\n\n    <DED><DED>populate_output(root, level)\n    return output\n\n\n<DED>def zigzag(root: Node | None) -> Sequence[Node | None] | list[Any]:\n    <IND>\"\"\"\n    ZigZag traverse:\n    Returns a list of nodes value from left to right and right to left, alternatively.\n    \"\"\"\n    if root is None:\n        <IND>return []\n\n    <DED>output: list[Sequence[Node | None]] = []\n\n    flag = 0\n    height_tree = height(root)\n\n    for h in range(1, height_tree + 1):\n        <IND>if not flag:\n            <IND>output.append(get_nodes_from_left_to_right(root, h))\n            flag = 1\n        <DED>else:\n            <IND>output.append(get_nodes_from_right_to_left(root, h))\n            flag = 0\n\n    <DED><DED>return output\n\n\n<DED>def main() -> None:  # Main function for testing.\n    <IND>"
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    \"\"\"\n    print(f\"  In-order Traversal is {inorder(root)}\")\n    print(f\" Pre-order Traversal is {preorder(root)}\")\n    print(f\"Post-order Traversal is {postorder(root)}\")\n    print(f\"Height of Tree is {height(root)}\")\n    print(\"Complete Level Order Traversal is : \")\n    level_order_1(root)\n    print(\"\\nLevel-wise order Traversal is : \")\n    for h in range(1, height(root) + 1):\n        level_order_2(root, h)\n    print(\"\\nZigZag order Traversal is : \")\n    zigzag(root)\n    print()\n\n",
        "source_code_len": 488,
        "target_code": "    \"\"\"\n\n    print(f\"In-order Traversal: {inorder(root)}\")\n    print(f\"Pre-order Traversal: {preorder(root)}\")\n    print(f\"Post-order Traversal: {postorder(root)}\", \"\\n\")\n\n    print(f\"Height of Tree: {height(root)}\", \"\\n\")\n\n    print(\"Complete Level Order Traversal: \")\n    print(level_order(root), \"\\n\")\n\n    print(\"Level-wise order Traversal: \")\n\n    for level in range(1, height(root) + 1):\n        print(f\"Level {level}:\", get_nodes_from_left_to_right(root, level=level))\n\n    print(\"\\nZigZag order Traversal: \")\n    print(zigzag(root))\n\n",
        "target_code_len": 542,
        "diff_format": "@@ -136,14 +157,19 @@\n     \"\"\"\n-    print(f\"  In-order Traversal is {inorder(root)}\")\n-    print(f\" Pre-order Traversal is {preorder(root)}\")\n-    print(f\"Post-order Traversal is {postorder(root)}\")\n-    print(f\"Height of Tree is {height(root)}\")\n-    print(\"Complete Level Order Traversal is : \")\n-    level_order_1(root)\n-    print(\"\\nLevel-wise order Traversal is : \")\n-    for h in range(1, height(root) + 1):\n-        level_order_2(root, h)\n-    print(\"\\nZigZag order Traversal is : \")\n-    zigzag(root)\n-    print()\n+\n+    print(f\"In-order Traversal: {inorder(root)}\")\n+    print(f\"Pre-order Traversal: {preorder(root)}\")\n+    print(f\"Post-order Traversal: {postorder(root)}\", \"\\n\")\n+\n+    print(f\"Height of Tree: {height(root)}\", \"\\n\")\n+\n+    print(\"Complete Level Order Traversal: \")\n+    print(level_order(root), \"\\n\")\n+\n+    print(\"Level-wise order Traversal: \")\n+\n+    for level in range(1, height(root) + 1):\n+        print(f\"Level {level}:\", get_nodes_from_left_to_right(root, level=level))\n+\n+    print(\"\\nZigZag order Traversal: \")\n+    print(zigzag(root))\n \n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\n    print(f\"  In-order Traversal is {inorder(root)}\")\n    print(f\" Pre-order Traversal is {preorder(root)}\")\n    print(f\"Post-order Traversal is {postorder(root)}\")\n    print(f\"Height of Tree is {height(root)}\")\n    print(\"Complete Level Order Traversal is : \")\n    level_order_1(root)\n    print(\"\\nLevel-wise order Traversal is : \")\n    for h in range(1, height(root) + 1):\n        <IND>level_order_2(root, h)\n    <DED>print(\"\\nZigZag order Traversal is : \")\n    zigzag(root)\n    print()\n\n",
        "target_code_with_indent": "\n\n    print(f\"In-order Traversal: {inorder(root)}\")\n    print(f\"Pre-order Traversal: {preorder(root)}\")\n    print(f\"Post-order Traversal: {postorder(root)}\", \"\\n\")\n\n    print(f\"Height of Tree: {height(root)}\", \"\\n\")\n\n    print(\"Complete Level Order Traversal: \")\n    print(level_order(root), \"\\n\")\n\n    print(\"Level-wise order Traversal: \")\n\n    for level in range(1, height(root) + 1):\n        <IND>print(f\"Level {level}:\", get_nodes_from_left_to_right(root, level=level))\n\n    <DED>print(\"\\nZigZag order Traversal: \")\n    print(zigzag(root))\n\n"
      }
    ]
  },
  {
    "project": "TheAlgorithms/Python",
    "commit": "bf6db32ec2fb04b6477722f0809c5efef0cad813",
    "filename": "data_structures/binary_tree/binary_tree_traversals.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/TheAlgorithms-Python/data_structures/binary_tree/binary_tree_traversals.py",
    "file_hunks_size": 8,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "data_structures/binary_tree/binary_tree_traversals.py:97:28 Incompatible parameter type [6]: Expected `Node` for 1st positional only parameter to call `print_left_to_right` but got `typing.Optional[Node]`.",
    "message": " Expected `Node` for 1st positional only parameter to call `print_left_to_right` but got `typing.Optional[Node]`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 97,
    "warning_line": "        print_left_to_right(root.left, level - 1)",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\nfrom dataclasses import dataclass\n\n",
        "source_code_len": 36,
        "target_code": "\nfrom collections import deque\nfrom dataclasses import dataclass\nfrom typing import Any, Sequence\n\n",
        "target_code_len": 99,
        "diff_format": "@@ -3,3 +3,5 @@\n \n+from collections import deque\n from dataclasses import dataclass\n+from typing import Any, Sequence\n \n",
        "source_code_with_indent": "\nfrom dataclasses import dataclass\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\nfrom collections import deque\nfrom dataclasses import dataclass\nfrom typing import Any, Sequence\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\ndef level_order_1(root: Node):\n    \"\"\"\n    Print whole binary tree in Level Order Traverse.\n    Level Order traverse: Visit nodes of the tree level-by-level.\n    \"\"\"\n    if not root:\n        return\n    temp = root\n    que = [temp]\n    while len(que) > 0:\n        print(que[0].data, end=\" \")\n        temp = que.pop(0)\n        if temp.left:\n            que.append(temp.left)\n        if temp.right:\n            que.append(temp.right)\n    return que\n\n\ndef level_order_2(root: Node, level: int):\n    \"\"\"\n    Level-wise traversal: Print all nodes present at the given level of the binary tree\n    \"\"\"\n    if not root:\n        return root\n    if level == 1:\n        print(root.data, end=\" \")\n    elif level > 1:\n        level_order_2(root.left, level - 1)\n        level_order_2(root.right, level - 1)\n\n\ndef print_left_to_right(root: Node, level: int):\n    \"\"\"\n    Print elements on particular level from left to right direction of the binary tree.\n    \"\"\"\n    if not root:\n        return\n    if level == 1:\n        print(root.data, end=\" \")\n    elif level > 1:\n        print_left_to_right(root.left, level - 1)\n        print_left_to_right(root.right, level - 1)\n\n\ndef print_right_to_left(root: Node, level: int):\n    \"\"\"\n    Print elements on particular level from right to left direction of the binary tree.\n    \"\"\"\n    if not root:\n        return\n    if level == 1:\n        print(root.data, end=\" \")\n    elif level > 1:\n        print_right_to_left(root.right, level - 1)\n        print_right_to_left(root.left, level - 1)\n\n\ndef zigzag(root: Node):\n    \"\"\"\n    ZigZag traverse: Print node left to right and right to left, alternatively.\n    \"\"\"\n    flag = 0\n    height_tree = height(root)\n    for h in range(1, height_tree + 1):\n        if flag == 0:\n            print_left_to_right(root, h)\n            flag = 1\n        else:\n            print_right_to_left(root, h)\n            flag = 0\n\n\ndef main():  # Main function for testing.\n    \"\"\"\n",
        "source_code_len": 1935,
        "target_code": "\ndef level_order(root: Node | None) -> Sequence[Node | None]:\n    \"\"\"\n    Returns a list of nodes value from a whole binary tree in Level Order Traverse.\n    Level Order traverse: Visit nodes of the tree level-by-level.\n    \"\"\"\n    output: list[Any] = []\n\n    if root is None:\n        return output\n\n    process_queue = deque([root])\n\n    while process_queue:\n        node = process_queue.popleft()\n        output.append(node.data)\n\n        if node.left:\n            process_queue.append(node.left)\n        if node.right:\n            process_queue.append(node.right)\n    return output\n\n\ndef get_nodes_from_left_to_right(\n    root: Node | None, level: int\n) -> Sequence[Node | None]:\n    \"\"\"\n    Returns a list of nodes value from a particular level:\n    Left to right direction of the binary tree.\n    \"\"\"\n    output: list[Any] = []\n\n    def populate_output(root: Node | None, level: int) -> None:\n        if not root:\n            return\n        if level == 1:\n\n            output.append(root.data)\n        elif level > 1:\n            populate_output(root.left, level - 1)\n            populate_output(root.right, level - 1)\n\n    populate_output(root, level)\n    return output\n\n\ndef get_nodes_from_right_to_left(\n    root: Node | None, level: int\n) -> Sequence[Node | None]:\n    \"\"\"\n    Returns a list of nodes value from a particular level:\n    Right to left direction of the binary tree.\n    \"\"\"\n    output: list[Any] = []\n\n    def populate_output(root: Node | None, level: int) -> None:\n        if root is None:\n            return\n        if level == 1:\n            output.append(root.data)\n        elif level > 1:\n            populate_output(root.right, level - 1)\n            populate_output(root.left, level - 1)\n\n    populate_output(root, level)\n    return output\n\n\ndef zigzag(root: Node | None) -> Sequence[Node | None] | list[Any]:\n    \"\"\"\n    ZigZag traverse:\n    Returns a list of nodes value from left to right and right to left, alternatively.\n    \"\"\"\n    if root is None:\n        return []\n\n    output: list[Sequence[Node | None]] = []\n\n    flag = 0\n    height_tree = height(root)\n\n    for h in range(1, height_tree + 1):\n        if not flag:\n            output.append(get_nodes_from_left_to_right(root, h))\n            flag = 1\n        else:\n            output.append(get_nodes_from_right_to_left(root, h))\n            flag = 0\n\n    return output\n\n\ndef main() -> None:  # Main function for testing.\n    \"\"\"\n",
        "target_code_len": 2421,
        "diff_format": "@@ -55,76 +57,95 @@\n \n-def level_order_1(root: Node):\n+def level_order(root: Node | None) -> Sequence[Node | None]:\n     \"\"\"\n-    Print whole binary tree in Level Order Traverse.\n+    Returns a list of nodes value from a whole binary tree in Level Order Traverse.\n     Level Order traverse: Visit nodes of the tree level-by-level.\n     \"\"\"\n-    if not root:\n-        return\n-    temp = root\n-    que = [temp]\n-    while len(que) > 0:\n-        print(que[0].data, end=\" \")\n-        temp = que.pop(0)\n-        if temp.left:\n-            que.append(temp.left)\n-        if temp.right:\n-            que.append(temp.right)\n-    return que\n+    output: list[Any] = []\n+\n+    if root is None:\n+        return output\n+\n+    process_queue = deque([root])\n+\n+    while process_queue:\n+        node = process_queue.popleft()\n+        output.append(node.data)\n+\n+        if node.left:\n+            process_queue.append(node.left)\n+        if node.right:\n+            process_queue.append(node.right)\n+    return output\n \n \n-def level_order_2(root: Node, level: int):\n+def get_nodes_from_left_to_right(\n+    root: Node | None, level: int\n+) -> Sequence[Node | None]:\n     \"\"\"\n-    Level-wise traversal: Print all nodes present at the given level of the binary tree\n+    Returns a list of nodes value from a particular level:\n+    Left to right direction of the binary tree.\n     \"\"\"\n-    if not root:\n-        return root\n-    if level == 1:\n-        print(root.data, end=\" \")\n-    elif level > 1:\n-        level_order_2(root.left, level - 1)\n-        level_order_2(root.right, level - 1)\n+    output: list[Any] = []\n+\n+    def populate_output(root: Node | None, level: int) -> None:\n+        if not root:\n+            return\n+        if level == 1:\n+\n+            output.append(root.data)\n+        elif level > 1:\n+            populate_output(root.left, level - 1)\n+            populate_output(root.right, level - 1)\n+\n+    populate_output(root, level)\n+    return output\n \n \n-def print_left_to_right(root: Node, level: int):\n+def get_nodes_from_right_to_left(\n+    root: Node | None, level: int\n+) -> Sequence[Node | None]:\n     \"\"\"\n-    Print elements on particular level from left to right direction of the binary tree.\n+    Returns a list of nodes value from a particular level:\n+    Right to left direction of the binary tree.\n     \"\"\"\n-    if not root:\n-        return\n-    if level == 1:\n-        print(root.data, end=\" \")\n-    elif level > 1:\n-        print_left_to_right(root.left, level - 1)\n-        print_left_to_right(root.right, level - 1)\n+    output: list[Any] = []\n+\n+    def populate_output(root: Node | None, level: int) -> None:\n+        if root is None:\n+            return\n+        if level == 1:\n+            output.append(root.data)\n+        elif level > 1:\n+            populate_output(root.right, level - 1)\n+            populate_output(root.left, level - 1)\n+\n+    populate_output(root, level)\n+    return output\n \n \n-def print_right_to_left(root: Node, level: int):\n+def zigzag(root: Node | None) -> Sequence[Node | None] | list[Any]:\n     \"\"\"\n-    Print elements on particular level from right to left direction of the binary tree.\n+    ZigZag traverse:\n+    Returns a list of nodes value from left to right and right to left, alternatively.\n     \"\"\"\n-    if not root:\n-        return\n-    if level == 1:\n-        print(root.data, end=\" \")\n-    elif level > 1:\n-        print_right_to_left(root.right, level - 1)\n-        print_right_to_left(root.left, level - 1)\n+    if root is None:\n+        return []\n+\n+    output: list[Sequence[Node | None]] = []\n+\n+    flag = 0\n+    height_tree = height(root)\n+\n+    for h in range(1, height_tree + 1):\n+        if not flag:\n+            output.append(get_nodes_from_left_to_right(root, h))\n+            flag = 1\n+        else:\n+            output.append(get_nodes_from_right_to_left(root, h))\n+            flag = 0\n+\n+    return output\n \n \n-def zigzag(root: Node):\n-    \"\"\"\n-    ZigZag traverse: Print node left to right and right to left, alternatively.\n-    \"\"\"\n-    flag = 0\n-    height_tree = height(root)\n-    for h in range(1, height_tree + 1):\n-        if flag == 0:\n-            print_left_to_right(root, h)\n-            flag = 1\n-        else:\n-            print_right_to_left(root, h)\n-            flag = 0\n-\n-\n-def main():  # Main function for testing.\n+def main() -> None:  # Main function for testing.\n     \"\"\"\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\n<DED>def level_order_1(root: Node):\n    <IND>\"\"\"\n    Print whole binary tree in Level Order Traverse.\n    Level Order traverse: Visit nodes of the tree level-by-level.\n    \"\"\"\n    if not root:\n        <IND>return\n    <DED>temp = root\n    que = [temp]\n    while len(que) > 0:\n        <IND>print(que[0].data, end=\" \")\n        temp = que.pop(0)\n        if temp.left:\n            <IND>que.append(temp.left)\n        <DED>if temp.right:\n            <IND>que.append(temp.right)\n    <DED><DED>return que\n\n\n<DED>def level_order_2(root: Node, level: int):\n    <IND>\"\"\"\n    Level-wise traversal: Print all nodes present at the given level of the binary tree\n    \"\"\"\n    if not root:\n        <IND>return root\n    <DED>if level == 1:\n        <IND>print(root.data, end=\" \")\n    <DED>elif level > 1:\n        <IND>level_order_2(root.left, level - 1)\n        level_order_2(root.right, level - 1)\n\n\n<DED><DED>def print_left_to_right(root: Node, level: int):\n    <IND>\"\"\"\n    Print elements on particular level from left to right direction of the binary tree.\n    \"\"\"\n    if not root:\n        <IND>return\n    <DED>if level == 1:\n        <IND>print(root.data, end=\" \")\n    <DED>elif level > 1:\n        <IND>print_left_to_right(root.left, level - 1)\n        print_left_to_right(root.right, level - 1)\n\n\n<DED><DED>def print_right_to_left(root: Node, level: int):\n    <IND>\"\"\"\n    Print elements on particular level from right to left direction of the binary tree.\n    \"\"\"\n    if not root:\n        <IND>return\n    <DED>if level == 1:\n        <IND>print(root.data, end=\" \")\n    <DED>elif level > 1:\n        <IND>print_right_to_left(root.right, level - 1)\n        print_right_to_left(root.left, level - 1)\n\n\n<DED><DED>def zigzag(root: Node):\n    <IND>\"\"\"\n    ZigZag traverse: Print node left to right and right to left, alternatively.\n    \"\"\"\n    flag = 0\n    height_tree = height(root)\n    for h in range(1, height_tree + 1):\n        <IND>if flag == 0:\n            <IND>print_left_to_right(root, h)\n            flag = 1\n        <DED>else:\n            <IND>print_right_to_left(root, h)\n            flag = 0\n\n\n<DED><DED><DED>def main():  # Main function for testing.\n    <IND>",
        "target_code_with_indent": "\n<DED>def level_order(root: Node | None) -> Sequence[Node | None]:\n    <IND>\"\"\"\n    Returns a list of nodes value from a whole binary tree in Level Order Traverse.\n    Level Order traverse: Visit nodes of the tree level-by-level.\n    \"\"\"\n    output: list[Any] = []\n\n    if root is None:\n        <IND>return output\n\n    <DED>process_queue = deque([root])\n\n    while process_queue:\n        <IND>node = process_queue.popleft()\n        output.append(node.data)\n\n        if node.left:\n            <IND>process_queue.append(node.left)\n        <DED>if node.right:\n            <IND>process_queue.append(node.right)\n    <DED><DED>return output\n\n\n<DED>def get_nodes_from_left_to_right(\n    root: Node | None, level: int\n) -> Sequence[Node | None]:\n    <IND>\"\"\"\n    Returns a list of nodes value from a particular level:\n    Left to right direction of the binary tree.\n    \"\"\"\n    output: list[Any] = []\n\n    def populate_output(root: Node | None, level: int) -> None:\n        <IND>if not root:\n            <IND>return\n        <DED>if level == 1:\n\n            <IND>output.append(root.data)\n        <DED>elif level > 1:\n            <IND>populate_output(root.left, level - 1)\n            populate_output(root.right, level - 1)\n\n    <DED><DED>populate_output(root, level)\n    return output\n\n\n<DED>def get_nodes_from_right_to_left(\n    root: Node | None, level: int\n) -> Sequence[Node | None]:\n    <IND>\"\"\"\n    Returns a list of nodes value from a particular level:\n    Right to left direction of the binary tree.\n    \"\"\"\n    output: list[Any] = []\n\n    def populate_output(root: Node | None, level: int) -> None:\n        <IND>if root is None:\n            <IND>return\n        <DED>if level == 1:\n            <IND>output.append(root.data)\n        <DED>elif level > 1:\n            <IND>populate_output(root.right, level - 1)\n            populate_output(root.left, level - 1)\n\n    <DED><DED>populate_output(root, level)\n    return output\n\n\n<DED>def zigzag(root: Node | None) -> Sequence[Node | None] | list[Any]:\n    <IND>\"\"\"\n    ZigZag traverse:\n    Returns a list of nodes value from left to right and right to left, alternatively.\n    \"\"\"\n    if root is None:\n        <IND>return []\n\n    <DED>output: list[Sequence[Node | None]] = []\n\n    flag = 0\n    height_tree = height(root)\n\n    for h in range(1, height_tree + 1):\n        <IND>if not flag:\n            <IND>output.append(get_nodes_from_left_to_right(root, h))\n            flag = 1\n        <DED>else:\n            <IND>output.append(get_nodes_from_right_to_left(root, h))\n            flag = 0\n\n    <DED><DED>return output\n\n\n<DED>def main() -> None:  # Main function for testing.\n    <IND>"
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    \"\"\"\n    print(f\"  In-order Traversal is {inorder(root)}\")\n    print(f\" Pre-order Traversal is {preorder(root)}\")\n    print(f\"Post-order Traversal is {postorder(root)}\")\n    print(f\"Height of Tree is {height(root)}\")\n    print(\"Complete Level Order Traversal is : \")\n    level_order_1(root)\n    print(\"\\nLevel-wise order Traversal is : \")\n    for h in range(1, height(root) + 1):\n        level_order_2(root, h)\n    print(\"\\nZigZag order Traversal is : \")\n    zigzag(root)\n    print()\n\n",
        "source_code_len": 488,
        "target_code": "    \"\"\"\n\n    print(f\"In-order Traversal: {inorder(root)}\")\n    print(f\"Pre-order Traversal: {preorder(root)}\")\n    print(f\"Post-order Traversal: {postorder(root)}\", \"\\n\")\n\n    print(f\"Height of Tree: {height(root)}\", \"\\n\")\n\n    print(\"Complete Level Order Traversal: \")\n    print(level_order(root), \"\\n\")\n\n    print(\"Level-wise order Traversal: \")\n\n    for level in range(1, height(root) + 1):\n        print(f\"Level {level}:\", get_nodes_from_left_to_right(root, level=level))\n\n    print(\"\\nZigZag order Traversal: \")\n    print(zigzag(root))\n\n",
        "target_code_len": 542,
        "diff_format": "@@ -136,14 +157,19 @@\n     \"\"\"\n-    print(f\"  In-order Traversal is {inorder(root)}\")\n-    print(f\" Pre-order Traversal is {preorder(root)}\")\n-    print(f\"Post-order Traversal is {postorder(root)}\")\n-    print(f\"Height of Tree is {height(root)}\")\n-    print(\"Complete Level Order Traversal is : \")\n-    level_order_1(root)\n-    print(\"\\nLevel-wise order Traversal is : \")\n-    for h in range(1, height(root) + 1):\n-        level_order_2(root, h)\n-    print(\"\\nZigZag order Traversal is : \")\n-    zigzag(root)\n-    print()\n+\n+    print(f\"In-order Traversal: {inorder(root)}\")\n+    print(f\"Pre-order Traversal: {preorder(root)}\")\n+    print(f\"Post-order Traversal: {postorder(root)}\", \"\\n\")\n+\n+    print(f\"Height of Tree: {height(root)}\", \"\\n\")\n+\n+    print(\"Complete Level Order Traversal: \")\n+    print(level_order(root), \"\\n\")\n+\n+    print(\"Level-wise order Traversal: \")\n+\n+    for level in range(1, height(root) + 1):\n+        print(f\"Level {level}:\", get_nodes_from_left_to_right(root, level=level))\n+\n+    print(\"\\nZigZag order Traversal: \")\n+    print(zigzag(root))\n \n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\n    print(f\"  In-order Traversal is {inorder(root)}\")\n    print(f\" Pre-order Traversal is {preorder(root)}\")\n    print(f\"Post-order Traversal is {postorder(root)}\")\n    print(f\"Height of Tree is {height(root)}\")\n    print(\"Complete Level Order Traversal is : \")\n    level_order_1(root)\n    print(\"\\nLevel-wise order Traversal is : \")\n    for h in range(1, height(root) + 1):\n        <IND>level_order_2(root, h)\n    <DED>print(\"\\nZigZag order Traversal is : \")\n    zigzag(root)\n    print()\n\n",
        "target_code_with_indent": "\n\n    print(f\"In-order Traversal: {inorder(root)}\")\n    print(f\"Pre-order Traversal: {preorder(root)}\")\n    print(f\"Post-order Traversal: {postorder(root)}\", \"\\n\")\n\n    print(f\"Height of Tree: {height(root)}\", \"\\n\")\n\n    print(\"Complete Level Order Traversal: \")\n    print(level_order(root), \"\\n\")\n\n    print(\"Level-wise order Traversal: \")\n\n    for level in range(1, height(root) + 1):\n        <IND>print(f\"Level {level}:\", get_nodes_from_left_to_right(root, level=level))\n\n    <DED>print(\"\\nZigZag order Traversal: \")\n    print(zigzag(root))\n\n"
      }
    ]
  },
  {
    "project": "TheAlgorithms/Python",
    "commit": "bf6db32ec2fb04b6477722f0809c5efef0cad813",
    "filename": "data_structures/binary_tree/binary_tree_traversals.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/TheAlgorithms-Python/data_structures/binary_tree/binary_tree_traversals.py",
    "file_hunks_size": 8,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "data_structures/binary_tree/binary_tree_traversals.py:98:28 Incompatible parameter type [6]: Expected `Node` for 1st positional only parameter to call `print_left_to_right` but got `typing.Optional[Node]`.",
    "message": " Expected `Node` for 1st positional only parameter to call `print_left_to_right` but got `typing.Optional[Node]`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 98,
    "warning_line": "        print_left_to_right(root.right, level - 1)",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\nfrom dataclasses import dataclass\n\n",
        "source_code_len": 36,
        "target_code": "\nfrom collections import deque\nfrom dataclasses import dataclass\nfrom typing import Any, Sequence\n\n",
        "target_code_len": 99,
        "diff_format": "@@ -3,3 +3,5 @@\n \n+from collections import deque\n from dataclasses import dataclass\n+from typing import Any, Sequence\n \n",
        "source_code_with_indent": "\nfrom dataclasses import dataclass\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\nfrom collections import deque\nfrom dataclasses import dataclass\nfrom typing import Any, Sequence\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\ndef level_order_1(root: Node):\n    \"\"\"\n    Print whole binary tree in Level Order Traverse.\n    Level Order traverse: Visit nodes of the tree level-by-level.\n    \"\"\"\n    if not root:\n        return\n    temp = root\n    que = [temp]\n    while len(que) > 0:\n        print(que[0].data, end=\" \")\n        temp = que.pop(0)\n        if temp.left:\n            que.append(temp.left)\n        if temp.right:\n            que.append(temp.right)\n    return que\n\n\ndef level_order_2(root: Node, level: int):\n    \"\"\"\n    Level-wise traversal: Print all nodes present at the given level of the binary tree\n    \"\"\"\n    if not root:\n        return root\n    if level == 1:\n        print(root.data, end=\" \")\n    elif level > 1:\n        level_order_2(root.left, level - 1)\n        level_order_2(root.right, level - 1)\n\n\ndef print_left_to_right(root: Node, level: int):\n    \"\"\"\n    Print elements on particular level from left to right direction of the binary tree.\n    \"\"\"\n    if not root:\n        return\n    if level == 1:\n        print(root.data, end=\" \")\n    elif level > 1:\n        print_left_to_right(root.left, level - 1)\n        print_left_to_right(root.right, level - 1)\n\n\ndef print_right_to_left(root: Node, level: int):\n    \"\"\"\n    Print elements on particular level from right to left direction of the binary tree.\n    \"\"\"\n    if not root:\n        return\n    if level == 1:\n        print(root.data, end=\" \")\n    elif level > 1:\n        print_right_to_left(root.right, level - 1)\n        print_right_to_left(root.left, level - 1)\n\n\ndef zigzag(root: Node):\n    \"\"\"\n    ZigZag traverse: Print node left to right and right to left, alternatively.\n    \"\"\"\n    flag = 0\n    height_tree = height(root)\n    for h in range(1, height_tree + 1):\n        if flag == 0:\n            print_left_to_right(root, h)\n            flag = 1\n        else:\n            print_right_to_left(root, h)\n            flag = 0\n\n\ndef main():  # Main function for testing.\n    \"\"\"\n",
        "source_code_len": 1935,
        "target_code": "\ndef level_order(root: Node | None) -> Sequence[Node | None]:\n    \"\"\"\n    Returns a list of nodes value from a whole binary tree in Level Order Traverse.\n    Level Order traverse: Visit nodes of the tree level-by-level.\n    \"\"\"\n    output: list[Any] = []\n\n    if root is None:\n        return output\n\n    process_queue = deque([root])\n\n    while process_queue:\n        node = process_queue.popleft()\n        output.append(node.data)\n\n        if node.left:\n            process_queue.append(node.left)\n        if node.right:\n            process_queue.append(node.right)\n    return output\n\n\ndef get_nodes_from_left_to_right(\n    root: Node | None, level: int\n) -> Sequence[Node | None]:\n    \"\"\"\n    Returns a list of nodes value from a particular level:\n    Left to right direction of the binary tree.\n    \"\"\"\n    output: list[Any] = []\n\n    def populate_output(root: Node | None, level: int) -> None:\n        if not root:\n            return\n        if level == 1:\n\n            output.append(root.data)\n        elif level > 1:\n            populate_output(root.left, level - 1)\n            populate_output(root.right, level - 1)\n\n    populate_output(root, level)\n    return output\n\n\ndef get_nodes_from_right_to_left(\n    root: Node | None, level: int\n) -> Sequence[Node | None]:\n    \"\"\"\n    Returns a list of nodes value from a particular level:\n    Right to left direction of the binary tree.\n    \"\"\"\n    output: list[Any] = []\n\n    def populate_output(root: Node | None, level: int) -> None:\n        if root is None:\n            return\n        if level == 1:\n            output.append(root.data)\n        elif level > 1:\n            populate_output(root.right, level - 1)\n            populate_output(root.left, level - 1)\n\n    populate_output(root, level)\n    return output\n\n\ndef zigzag(root: Node | None) -> Sequence[Node | None] | list[Any]:\n    \"\"\"\n    ZigZag traverse:\n    Returns a list of nodes value from left to right and right to left, alternatively.\n    \"\"\"\n    if root is None:\n        return []\n\n    output: list[Sequence[Node | None]] = []\n\n    flag = 0\n    height_tree = height(root)\n\n    for h in range(1, height_tree + 1):\n        if not flag:\n            output.append(get_nodes_from_left_to_right(root, h))\n            flag = 1\n        else:\n            output.append(get_nodes_from_right_to_left(root, h))\n            flag = 0\n\n    return output\n\n\ndef main() -> None:  # Main function for testing.\n    \"\"\"\n",
        "target_code_len": 2421,
        "diff_format": "@@ -55,76 +57,95 @@\n \n-def level_order_1(root: Node):\n+def level_order(root: Node | None) -> Sequence[Node | None]:\n     \"\"\"\n-    Print whole binary tree in Level Order Traverse.\n+    Returns a list of nodes value from a whole binary tree in Level Order Traverse.\n     Level Order traverse: Visit nodes of the tree level-by-level.\n     \"\"\"\n-    if not root:\n-        return\n-    temp = root\n-    que = [temp]\n-    while len(que) > 0:\n-        print(que[0].data, end=\" \")\n-        temp = que.pop(0)\n-        if temp.left:\n-            que.append(temp.left)\n-        if temp.right:\n-            que.append(temp.right)\n-    return que\n+    output: list[Any] = []\n+\n+    if root is None:\n+        return output\n+\n+    process_queue = deque([root])\n+\n+    while process_queue:\n+        node = process_queue.popleft()\n+        output.append(node.data)\n+\n+        if node.left:\n+            process_queue.append(node.left)\n+        if node.right:\n+            process_queue.append(node.right)\n+    return output\n \n \n-def level_order_2(root: Node, level: int):\n+def get_nodes_from_left_to_right(\n+    root: Node | None, level: int\n+) -> Sequence[Node | None]:\n     \"\"\"\n-    Level-wise traversal: Print all nodes present at the given level of the binary tree\n+    Returns a list of nodes value from a particular level:\n+    Left to right direction of the binary tree.\n     \"\"\"\n-    if not root:\n-        return root\n-    if level == 1:\n-        print(root.data, end=\" \")\n-    elif level > 1:\n-        level_order_2(root.left, level - 1)\n-        level_order_2(root.right, level - 1)\n+    output: list[Any] = []\n+\n+    def populate_output(root: Node | None, level: int) -> None:\n+        if not root:\n+            return\n+        if level == 1:\n+\n+            output.append(root.data)\n+        elif level > 1:\n+            populate_output(root.left, level - 1)\n+            populate_output(root.right, level - 1)\n+\n+    populate_output(root, level)\n+    return output\n \n \n-def print_left_to_right(root: Node, level: int):\n+def get_nodes_from_right_to_left(\n+    root: Node | None, level: int\n+) -> Sequence[Node | None]:\n     \"\"\"\n-    Print elements on particular level from left to right direction of the binary tree.\n+    Returns a list of nodes value from a particular level:\n+    Right to left direction of the binary tree.\n     \"\"\"\n-    if not root:\n-        return\n-    if level == 1:\n-        print(root.data, end=\" \")\n-    elif level > 1:\n-        print_left_to_right(root.left, level - 1)\n-        print_left_to_right(root.right, level - 1)\n+    output: list[Any] = []\n+\n+    def populate_output(root: Node | None, level: int) -> None:\n+        if root is None:\n+            return\n+        if level == 1:\n+            output.append(root.data)\n+        elif level > 1:\n+            populate_output(root.right, level - 1)\n+            populate_output(root.left, level - 1)\n+\n+    populate_output(root, level)\n+    return output\n \n \n-def print_right_to_left(root: Node, level: int):\n+def zigzag(root: Node | None) -> Sequence[Node | None] | list[Any]:\n     \"\"\"\n-    Print elements on particular level from right to left direction of the binary tree.\n+    ZigZag traverse:\n+    Returns a list of nodes value from left to right and right to left, alternatively.\n     \"\"\"\n-    if not root:\n-        return\n-    if level == 1:\n-        print(root.data, end=\" \")\n-    elif level > 1:\n-        print_right_to_left(root.right, level - 1)\n-        print_right_to_left(root.left, level - 1)\n+    if root is None:\n+        return []\n+\n+    output: list[Sequence[Node | None]] = []\n+\n+    flag = 0\n+    height_tree = height(root)\n+\n+    for h in range(1, height_tree + 1):\n+        if not flag:\n+            output.append(get_nodes_from_left_to_right(root, h))\n+            flag = 1\n+        else:\n+            output.append(get_nodes_from_right_to_left(root, h))\n+            flag = 0\n+\n+    return output\n \n \n-def zigzag(root: Node):\n-    \"\"\"\n-    ZigZag traverse: Print node left to right and right to left, alternatively.\n-    \"\"\"\n-    flag = 0\n-    height_tree = height(root)\n-    for h in range(1, height_tree + 1):\n-        if flag == 0:\n-            print_left_to_right(root, h)\n-            flag = 1\n-        else:\n-            print_right_to_left(root, h)\n-            flag = 0\n-\n-\n-def main():  # Main function for testing.\n+def main() -> None:  # Main function for testing.\n     \"\"\"\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\n<DED>def level_order_1(root: Node):\n    <IND>\"\"\"\n    Print whole binary tree in Level Order Traverse.\n    Level Order traverse: Visit nodes of the tree level-by-level.\n    \"\"\"\n    if not root:\n        <IND>return\n    <DED>temp = root\n    que = [temp]\n    while len(que) > 0:\n        <IND>print(que[0].data, end=\" \")\n        temp = que.pop(0)\n        if temp.left:\n            <IND>que.append(temp.left)\n        <DED>if temp.right:\n            <IND>que.append(temp.right)\n    <DED><DED>return que\n\n\n<DED>def level_order_2(root: Node, level: int):\n    <IND>\"\"\"\n    Level-wise traversal: Print all nodes present at the given level of the binary tree\n    \"\"\"\n    if not root:\n        <IND>return root\n    <DED>if level == 1:\n        <IND>print(root.data, end=\" \")\n    <DED>elif level > 1:\n        <IND>level_order_2(root.left, level - 1)\n        level_order_2(root.right, level - 1)\n\n\n<DED><DED>def print_left_to_right(root: Node, level: int):\n    <IND>\"\"\"\n    Print elements on particular level from left to right direction of the binary tree.\n    \"\"\"\n    if not root:\n        <IND>return\n    <DED>if level == 1:\n        <IND>print(root.data, end=\" \")\n    <DED>elif level > 1:\n        <IND>print_left_to_right(root.left, level - 1)\n        print_left_to_right(root.right, level - 1)\n\n\n<DED><DED>def print_right_to_left(root: Node, level: int):\n    <IND>\"\"\"\n    Print elements on particular level from right to left direction of the binary tree.\n    \"\"\"\n    if not root:\n        <IND>return\n    <DED>if level == 1:\n        <IND>print(root.data, end=\" \")\n    <DED>elif level > 1:\n        <IND>print_right_to_left(root.right, level - 1)\n        print_right_to_left(root.left, level - 1)\n\n\n<DED><DED>def zigzag(root: Node):\n    <IND>\"\"\"\n    ZigZag traverse: Print node left to right and right to left, alternatively.\n    \"\"\"\n    flag = 0\n    height_tree = height(root)\n    for h in range(1, height_tree + 1):\n        <IND>if flag == 0:\n            <IND>print_left_to_right(root, h)\n            flag = 1\n        <DED>else:\n            <IND>print_right_to_left(root, h)\n            flag = 0\n\n\n<DED><DED><DED>def main():  # Main function for testing.\n    <IND>",
        "target_code_with_indent": "\n<DED>def level_order(root: Node | None) -> Sequence[Node | None]:\n    <IND>\"\"\"\n    Returns a list of nodes value from a whole binary tree in Level Order Traverse.\n    Level Order traverse: Visit nodes of the tree level-by-level.\n    \"\"\"\n    output: list[Any] = []\n\n    if root is None:\n        <IND>return output\n\n    <DED>process_queue = deque([root])\n\n    while process_queue:\n        <IND>node = process_queue.popleft()\n        output.append(node.data)\n\n        if node.left:\n            <IND>process_queue.append(node.left)\n        <DED>if node.right:\n            <IND>process_queue.append(node.right)\n    <DED><DED>return output\n\n\n<DED>def get_nodes_from_left_to_right(\n    root: Node | None, level: int\n) -> Sequence[Node | None]:\n    <IND>\"\"\"\n    Returns a list of nodes value from a particular level:\n    Left to right direction of the binary tree.\n    \"\"\"\n    output: list[Any] = []\n\n    def populate_output(root: Node | None, level: int) -> None:\n        <IND>if not root:\n            <IND>return\n        <DED>if level == 1:\n\n            <IND>output.append(root.data)\n        <DED>elif level > 1:\n            <IND>populate_output(root.left, level - 1)\n            populate_output(root.right, level - 1)\n\n    <DED><DED>populate_output(root, level)\n    return output\n\n\n<DED>def get_nodes_from_right_to_left(\n    root: Node | None, level: int\n) -> Sequence[Node | None]:\n    <IND>\"\"\"\n    Returns a list of nodes value from a particular level:\n    Right to left direction of the binary tree.\n    \"\"\"\n    output: list[Any] = []\n\n    def populate_output(root: Node | None, level: int) -> None:\n        <IND>if root is None:\n            <IND>return\n        <DED>if level == 1:\n            <IND>output.append(root.data)\n        <DED>elif level > 1:\n            <IND>populate_output(root.right, level - 1)\n            populate_output(root.left, level - 1)\n\n    <DED><DED>populate_output(root, level)\n    return output\n\n\n<DED>def zigzag(root: Node | None) -> Sequence[Node | None] | list[Any]:\n    <IND>\"\"\"\n    ZigZag traverse:\n    Returns a list of nodes value from left to right and right to left, alternatively.\n    \"\"\"\n    if root is None:\n        <IND>return []\n\n    <DED>output: list[Sequence[Node | None]] = []\n\n    flag = 0\n    height_tree = height(root)\n\n    for h in range(1, height_tree + 1):\n        <IND>if not flag:\n            <IND>output.append(get_nodes_from_left_to_right(root, h))\n            flag = 1\n        <DED>else:\n            <IND>output.append(get_nodes_from_right_to_left(root, h))\n            flag = 0\n\n    <DED><DED>return output\n\n\n<DED>def main() -> None:  # Main function for testing.\n    <IND>"
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    \"\"\"\n    print(f\"  In-order Traversal is {inorder(root)}\")\n    print(f\" Pre-order Traversal is {preorder(root)}\")\n    print(f\"Post-order Traversal is {postorder(root)}\")\n    print(f\"Height of Tree is {height(root)}\")\n    print(\"Complete Level Order Traversal is : \")\n    level_order_1(root)\n    print(\"\\nLevel-wise order Traversal is : \")\n    for h in range(1, height(root) + 1):\n        level_order_2(root, h)\n    print(\"\\nZigZag order Traversal is : \")\n    zigzag(root)\n    print()\n\n",
        "source_code_len": 488,
        "target_code": "    \"\"\"\n\n    print(f\"In-order Traversal: {inorder(root)}\")\n    print(f\"Pre-order Traversal: {preorder(root)}\")\n    print(f\"Post-order Traversal: {postorder(root)}\", \"\\n\")\n\n    print(f\"Height of Tree: {height(root)}\", \"\\n\")\n\n    print(\"Complete Level Order Traversal: \")\n    print(level_order(root), \"\\n\")\n\n    print(\"Level-wise order Traversal: \")\n\n    for level in range(1, height(root) + 1):\n        print(f\"Level {level}:\", get_nodes_from_left_to_right(root, level=level))\n\n    print(\"\\nZigZag order Traversal: \")\n    print(zigzag(root))\n\n",
        "target_code_len": 542,
        "diff_format": "@@ -136,14 +157,19 @@\n     \"\"\"\n-    print(f\"  In-order Traversal is {inorder(root)}\")\n-    print(f\" Pre-order Traversal is {preorder(root)}\")\n-    print(f\"Post-order Traversal is {postorder(root)}\")\n-    print(f\"Height of Tree is {height(root)}\")\n-    print(\"Complete Level Order Traversal is : \")\n-    level_order_1(root)\n-    print(\"\\nLevel-wise order Traversal is : \")\n-    for h in range(1, height(root) + 1):\n-        level_order_2(root, h)\n-    print(\"\\nZigZag order Traversal is : \")\n-    zigzag(root)\n-    print()\n+\n+    print(f\"In-order Traversal: {inorder(root)}\")\n+    print(f\"Pre-order Traversal: {preorder(root)}\")\n+    print(f\"Post-order Traversal: {postorder(root)}\", \"\\n\")\n+\n+    print(f\"Height of Tree: {height(root)}\", \"\\n\")\n+\n+    print(\"Complete Level Order Traversal: \")\n+    print(level_order(root), \"\\n\")\n+\n+    print(\"Level-wise order Traversal: \")\n+\n+    for level in range(1, height(root) + 1):\n+        print(f\"Level {level}:\", get_nodes_from_left_to_right(root, level=level))\n+\n+    print(\"\\nZigZag order Traversal: \")\n+    print(zigzag(root))\n \n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\n    print(f\"  In-order Traversal is {inorder(root)}\")\n    print(f\" Pre-order Traversal is {preorder(root)}\")\n    print(f\"Post-order Traversal is {postorder(root)}\")\n    print(f\"Height of Tree is {height(root)}\")\n    print(\"Complete Level Order Traversal is : \")\n    level_order_1(root)\n    print(\"\\nLevel-wise order Traversal is : \")\n    for h in range(1, height(root) + 1):\n        <IND>level_order_2(root, h)\n    <DED>print(\"\\nZigZag order Traversal is : \")\n    zigzag(root)\n    print()\n\n",
        "target_code_with_indent": "\n\n    print(f\"In-order Traversal: {inorder(root)}\")\n    print(f\"Pre-order Traversal: {preorder(root)}\")\n    print(f\"Post-order Traversal: {postorder(root)}\", \"\\n\")\n\n    print(f\"Height of Tree: {height(root)}\", \"\\n\")\n\n    print(\"Complete Level Order Traversal: \")\n    print(level_order(root), \"\\n\")\n\n    print(\"Level-wise order Traversal: \")\n\n    for level in range(1, height(root) + 1):\n        <IND>print(f\"Level {level}:\", get_nodes_from_left_to_right(root, level=level))\n\n    <DED>print(\"\\nZigZag order Traversal: \")\n    print(zigzag(root))\n\n"
      }
    ]
  },
  {
    "project": "TheAlgorithms/Python",
    "commit": "bf6db32ec2fb04b6477722f0809c5efef0cad813",
    "filename": "data_structures/binary_tree/binary_tree_traversals.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/TheAlgorithms-Python/data_structures/binary_tree/binary_tree_traversals.py",
    "file_hunks_size": 8,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "data_structures/binary_tree/binary_tree_traversals.py:110:28 Incompatible parameter type [6]: Expected `Node` for 1st positional only parameter to call `print_right_to_left` but got `typing.Optional[Node]`.",
    "message": " Expected `Node` for 1st positional only parameter to call `print_right_to_left` but got `typing.Optional[Node]`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 110,
    "warning_line": "        print_right_to_left(root.right, level - 1)",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\nfrom dataclasses import dataclass\n\n",
        "source_code_len": 36,
        "target_code": "\nfrom collections import deque\nfrom dataclasses import dataclass\nfrom typing import Any, Sequence\n\n",
        "target_code_len": 99,
        "diff_format": "@@ -3,3 +3,5 @@\n \n+from collections import deque\n from dataclasses import dataclass\n+from typing import Any, Sequence\n \n",
        "source_code_with_indent": "\nfrom dataclasses import dataclass\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\nfrom collections import deque\nfrom dataclasses import dataclass\nfrom typing import Any, Sequence\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\ndef level_order_1(root: Node):\n    \"\"\"\n    Print whole binary tree in Level Order Traverse.\n    Level Order traverse: Visit nodes of the tree level-by-level.\n    \"\"\"\n    if not root:\n        return\n    temp = root\n    que = [temp]\n    while len(que) > 0:\n        print(que[0].data, end=\" \")\n        temp = que.pop(0)\n        if temp.left:\n            que.append(temp.left)\n        if temp.right:\n            que.append(temp.right)\n    return que\n\n\ndef level_order_2(root: Node, level: int):\n    \"\"\"\n    Level-wise traversal: Print all nodes present at the given level of the binary tree\n    \"\"\"\n    if not root:\n        return root\n    if level == 1:\n        print(root.data, end=\" \")\n    elif level > 1:\n        level_order_2(root.left, level - 1)\n        level_order_2(root.right, level - 1)\n\n\ndef print_left_to_right(root: Node, level: int):\n    \"\"\"\n    Print elements on particular level from left to right direction of the binary tree.\n    \"\"\"\n    if not root:\n        return\n    if level == 1:\n        print(root.data, end=\" \")\n    elif level > 1:\n        print_left_to_right(root.left, level - 1)\n        print_left_to_right(root.right, level - 1)\n\n\ndef print_right_to_left(root: Node, level: int):\n    \"\"\"\n    Print elements on particular level from right to left direction of the binary tree.\n    \"\"\"\n    if not root:\n        return\n    if level == 1:\n        print(root.data, end=\" \")\n    elif level > 1:\n        print_right_to_left(root.right, level - 1)\n        print_right_to_left(root.left, level - 1)\n\n\ndef zigzag(root: Node):\n    \"\"\"\n    ZigZag traverse: Print node left to right and right to left, alternatively.\n    \"\"\"\n    flag = 0\n    height_tree = height(root)\n    for h in range(1, height_tree + 1):\n        if flag == 0:\n            print_left_to_right(root, h)\n            flag = 1\n        else:\n            print_right_to_left(root, h)\n            flag = 0\n\n\ndef main():  # Main function for testing.\n    \"\"\"\n",
        "source_code_len": 1935,
        "target_code": "\ndef level_order(root: Node | None) -> Sequence[Node | None]:\n    \"\"\"\n    Returns a list of nodes value from a whole binary tree in Level Order Traverse.\n    Level Order traverse: Visit nodes of the tree level-by-level.\n    \"\"\"\n    output: list[Any] = []\n\n    if root is None:\n        return output\n\n    process_queue = deque([root])\n\n    while process_queue:\n        node = process_queue.popleft()\n        output.append(node.data)\n\n        if node.left:\n            process_queue.append(node.left)\n        if node.right:\n            process_queue.append(node.right)\n    return output\n\n\ndef get_nodes_from_left_to_right(\n    root: Node | None, level: int\n) -> Sequence[Node | None]:\n    \"\"\"\n    Returns a list of nodes value from a particular level:\n    Left to right direction of the binary tree.\n    \"\"\"\n    output: list[Any] = []\n\n    def populate_output(root: Node | None, level: int) -> None:\n        if not root:\n            return\n        if level == 1:\n\n            output.append(root.data)\n        elif level > 1:\n            populate_output(root.left, level - 1)\n            populate_output(root.right, level - 1)\n\n    populate_output(root, level)\n    return output\n\n\ndef get_nodes_from_right_to_left(\n    root: Node | None, level: int\n) -> Sequence[Node | None]:\n    \"\"\"\n    Returns a list of nodes value from a particular level:\n    Right to left direction of the binary tree.\n    \"\"\"\n    output: list[Any] = []\n\n    def populate_output(root: Node | None, level: int) -> None:\n        if root is None:\n            return\n        if level == 1:\n            output.append(root.data)\n        elif level > 1:\n            populate_output(root.right, level - 1)\n            populate_output(root.left, level - 1)\n\n    populate_output(root, level)\n    return output\n\n\ndef zigzag(root: Node | None) -> Sequence[Node | None] | list[Any]:\n    \"\"\"\n    ZigZag traverse:\n    Returns a list of nodes value from left to right and right to left, alternatively.\n    \"\"\"\n    if root is None:\n        return []\n\n    output: list[Sequence[Node | None]] = []\n\n    flag = 0\n    height_tree = height(root)\n\n    for h in range(1, height_tree + 1):\n        if not flag:\n            output.append(get_nodes_from_left_to_right(root, h))\n            flag = 1\n        else:\n            output.append(get_nodes_from_right_to_left(root, h))\n            flag = 0\n\n    return output\n\n\ndef main() -> None:  # Main function for testing.\n    \"\"\"\n",
        "target_code_len": 2421,
        "diff_format": "@@ -55,76 +57,95 @@\n \n-def level_order_1(root: Node):\n+def level_order(root: Node | None) -> Sequence[Node | None]:\n     \"\"\"\n-    Print whole binary tree in Level Order Traverse.\n+    Returns a list of nodes value from a whole binary tree in Level Order Traverse.\n     Level Order traverse: Visit nodes of the tree level-by-level.\n     \"\"\"\n-    if not root:\n-        return\n-    temp = root\n-    que = [temp]\n-    while len(que) > 0:\n-        print(que[0].data, end=\" \")\n-        temp = que.pop(0)\n-        if temp.left:\n-            que.append(temp.left)\n-        if temp.right:\n-            que.append(temp.right)\n-    return que\n+    output: list[Any] = []\n+\n+    if root is None:\n+        return output\n+\n+    process_queue = deque([root])\n+\n+    while process_queue:\n+        node = process_queue.popleft()\n+        output.append(node.data)\n+\n+        if node.left:\n+            process_queue.append(node.left)\n+        if node.right:\n+            process_queue.append(node.right)\n+    return output\n \n \n-def level_order_2(root: Node, level: int):\n+def get_nodes_from_left_to_right(\n+    root: Node | None, level: int\n+) -> Sequence[Node | None]:\n     \"\"\"\n-    Level-wise traversal: Print all nodes present at the given level of the binary tree\n+    Returns a list of nodes value from a particular level:\n+    Left to right direction of the binary tree.\n     \"\"\"\n-    if not root:\n-        return root\n-    if level == 1:\n-        print(root.data, end=\" \")\n-    elif level > 1:\n-        level_order_2(root.left, level - 1)\n-        level_order_2(root.right, level - 1)\n+    output: list[Any] = []\n+\n+    def populate_output(root: Node | None, level: int) -> None:\n+        if not root:\n+            return\n+        if level == 1:\n+\n+            output.append(root.data)\n+        elif level > 1:\n+            populate_output(root.left, level - 1)\n+            populate_output(root.right, level - 1)\n+\n+    populate_output(root, level)\n+    return output\n \n \n-def print_left_to_right(root: Node, level: int):\n+def get_nodes_from_right_to_left(\n+    root: Node | None, level: int\n+) -> Sequence[Node | None]:\n     \"\"\"\n-    Print elements on particular level from left to right direction of the binary tree.\n+    Returns a list of nodes value from a particular level:\n+    Right to left direction of the binary tree.\n     \"\"\"\n-    if not root:\n-        return\n-    if level == 1:\n-        print(root.data, end=\" \")\n-    elif level > 1:\n-        print_left_to_right(root.left, level - 1)\n-        print_left_to_right(root.right, level - 1)\n+    output: list[Any] = []\n+\n+    def populate_output(root: Node | None, level: int) -> None:\n+        if root is None:\n+            return\n+        if level == 1:\n+            output.append(root.data)\n+        elif level > 1:\n+            populate_output(root.right, level - 1)\n+            populate_output(root.left, level - 1)\n+\n+    populate_output(root, level)\n+    return output\n \n \n-def print_right_to_left(root: Node, level: int):\n+def zigzag(root: Node | None) -> Sequence[Node | None] | list[Any]:\n     \"\"\"\n-    Print elements on particular level from right to left direction of the binary tree.\n+    ZigZag traverse:\n+    Returns a list of nodes value from left to right and right to left, alternatively.\n     \"\"\"\n-    if not root:\n-        return\n-    if level == 1:\n-        print(root.data, end=\" \")\n-    elif level > 1:\n-        print_right_to_left(root.right, level - 1)\n-        print_right_to_left(root.left, level - 1)\n+    if root is None:\n+        return []\n+\n+    output: list[Sequence[Node | None]] = []\n+\n+    flag = 0\n+    height_tree = height(root)\n+\n+    for h in range(1, height_tree + 1):\n+        if not flag:\n+            output.append(get_nodes_from_left_to_right(root, h))\n+            flag = 1\n+        else:\n+            output.append(get_nodes_from_right_to_left(root, h))\n+            flag = 0\n+\n+    return output\n \n \n-def zigzag(root: Node):\n-    \"\"\"\n-    ZigZag traverse: Print node left to right and right to left, alternatively.\n-    \"\"\"\n-    flag = 0\n-    height_tree = height(root)\n-    for h in range(1, height_tree + 1):\n-        if flag == 0:\n-            print_left_to_right(root, h)\n-            flag = 1\n-        else:\n-            print_right_to_left(root, h)\n-            flag = 0\n-\n-\n-def main():  # Main function for testing.\n+def main() -> None:  # Main function for testing.\n     \"\"\"\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\n<DED>def level_order_1(root: Node):\n    <IND>\"\"\"\n    Print whole binary tree in Level Order Traverse.\n    Level Order traverse: Visit nodes of the tree level-by-level.\n    \"\"\"\n    if not root:\n        <IND>return\n    <DED>temp = root\n    que = [temp]\n    while len(que) > 0:\n        <IND>print(que[0].data, end=\" \")\n        temp = que.pop(0)\n        if temp.left:\n            <IND>que.append(temp.left)\n        <DED>if temp.right:\n            <IND>que.append(temp.right)\n    <DED><DED>return que\n\n\n<DED>def level_order_2(root: Node, level: int):\n    <IND>\"\"\"\n    Level-wise traversal: Print all nodes present at the given level of the binary tree\n    \"\"\"\n    if not root:\n        <IND>return root\n    <DED>if level == 1:\n        <IND>print(root.data, end=\" \")\n    <DED>elif level > 1:\n        <IND>level_order_2(root.left, level - 1)\n        level_order_2(root.right, level - 1)\n\n\n<DED><DED>def print_left_to_right(root: Node, level: int):\n    <IND>\"\"\"\n    Print elements on particular level from left to right direction of the binary tree.\n    \"\"\"\n    if not root:\n        <IND>return\n    <DED>if level == 1:\n        <IND>print(root.data, end=\" \")\n    <DED>elif level > 1:\n        <IND>print_left_to_right(root.left, level - 1)\n        print_left_to_right(root.right, level - 1)\n\n\n<DED><DED>def print_right_to_left(root: Node, level: int):\n    <IND>\"\"\"\n    Print elements on particular level from right to left direction of the binary tree.\n    \"\"\"\n    if not root:\n        <IND>return\n    <DED>if level == 1:\n        <IND>print(root.data, end=\" \")\n    <DED>elif level > 1:\n        <IND>print_right_to_left(root.right, level - 1)\n        print_right_to_left(root.left, level - 1)\n\n\n<DED><DED>def zigzag(root: Node):\n    <IND>\"\"\"\n    ZigZag traverse: Print node left to right and right to left, alternatively.\n    \"\"\"\n    flag = 0\n    height_tree = height(root)\n    for h in range(1, height_tree + 1):\n        <IND>if flag == 0:\n            <IND>print_left_to_right(root, h)\n            flag = 1\n        <DED>else:\n            <IND>print_right_to_left(root, h)\n            flag = 0\n\n\n<DED><DED><DED>def main():  # Main function for testing.\n    <IND>",
        "target_code_with_indent": "\n<DED>def level_order(root: Node | None) -> Sequence[Node | None]:\n    <IND>\"\"\"\n    Returns a list of nodes value from a whole binary tree in Level Order Traverse.\n    Level Order traverse: Visit nodes of the tree level-by-level.\n    \"\"\"\n    output: list[Any] = []\n\n    if root is None:\n        <IND>return output\n\n    <DED>process_queue = deque([root])\n\n    while process_queue:\n        <IND>node = process_queue.popleft()\n        output.append(node.data)\n\n        if node.left:\n            <IND>process_queue.append(node.left)\n        <DED>if node.right:\n            <IND>process_queue.append(node.right)\n    <DED><DED>return output\n\n\n<DED>def get_nodes_from_left_to_right(\n    root: Node | None, level: int\n) -> Sequence[Node | None]:\n    <IND>\"\"\"\n    Returns a list of nodes value from a particular level:\n    Left to right direction of the binary tree.\n    \"\"\"\n    output: list[Any] = []\n\n    def populate_output(root: Node | None, level: int) -> None:\n        <IND>if not root:\n            <IND>return\n        <DED>if level == 1:\n\n            <IND>output.append(root.data)\n        <DED>elif level > 1:\n            <IND>populate_output(root.left, level - 1)\n            populate_output(root.right, level - 1)\n\n    <DED><DED>populate_output(root, level)\n    return output\n\n\n<DED>def get_nodes_from_right_to_left(\n    root: Node | None, level: int\n) -> Sequence[Node | None]:\n    <IND>\"\"\"\n    Returns a list of nodes value from a particular level:\n    Right to left direction of the binary tree.\n    \"\"\"\n    output: list[Any] = []\n\n    def populate_output(root: Node | None, level: int) -> None:\n        <IND>if root is None:\n            <IND>return\n        <DED>if level == 1:\n            <IND>output.append(root.data)\n        <DED>elif level > 1:\n            <IND>populate_output(root.right, level - 1)\n            populate_output(root.left, level - 1)\n\n    <DED><DED>populate_output(root, level)\n    return output\n\n\n<DED>def zigzag(root: Node | None) -> Sequence[Node | None] | list[Any]:\n    <IND>\"\"\"\n    ZigZag traverse:\n    Returns a list of nodes value from left to right and right to left, alternatively.\n    \"\"\"\n    if root is None:\n        <IND>return []\n\n    <DED>output: list[Sequence[Node | None]] = []\n\n    flag = 0\n    height_tree = height(root)\n\n    for h in range(1, height_tree + 1):\n        <IND>if not flag:\n            <IND>output.append(get_nodes_from_left_to_right(root, h))\n            flag = 1\n        <DED>else:\n            <IND>output.append(get_nodes_from_right_to_left(root, h))\n            flag = 0\n\n    <DED><DED>return output\n\n\n<DED>def main() -> None:  # Main function for testing.\n    <IND>"
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    \"\"\"\n    print(f\"  In-order Traversal is {inorder(root)}\")\n    print(f\" Pre-order Traversal is {preorder(root)}\")\n    print(f\"Post-order Traversal is {postorder(root)}\")\n    print(f\"Height of Tree is {height(root)}\")\n    print(\"Complete Level Order Traversal is : \")\n    level_order_1(root)\n    print(\"\\nLevel-wise order Traversal is : \")\n    for h in range(1, height(root) + 1):\n        level_order_2(root, h)\n    print(\"\\nZigZag order Traversal is : \")\n    zigzag(root)\n    print()\n\n",
        "source_code_len": 488,
        "target_code": "    \"\"\"\n\n    print(f\"In-order Traversal: {inorder(root)}\")\n    print(f\"Pre-order Traversal: {preorder(root)}\")\n    print(f\"Post-order Traversal: {postorder(root)}\", \"\\n\")\n\n    print(f\"Height of Tree: {height(root)}\", \"\\n\")\n\n    print(\"Complete Level Order Traversal: \")\n    print(level_order(root), \"\\n\")\n\n    print(\"Level-wise order Traversal: \")\n\n    for level in range(1, height(root) + 1):\n        print(f\"Level {level}:\", get_nodes_from_left_to_right(root, level=level))\n\n    print(\"\\nZigZag order Traversal: \")\n    print(zigzag(root))\n\n",
        "target_code_len": 542,
        "diff_format": "@@ -136,14 +157,19 @@\n     \"\"\"\n-    print(f\"  In-order Traversal is {inorder(root)}\")\n-    print(f\" Pre-order Traversal is {preorder(root)}\")\n-    print(f\"Post-order Traversal is {postorder(root)}\")\n-    print(f\"Height of Tree is {height(root)}\")\n-    print(\"Complete Level Order Traversal is : \")\n-    level_order_1(root)\n-    print(\"\\nLevel-wise order Traversal is : \")\n-    for h in range(1, height(root) + 1):\n-        level_order_2(root, h)\n-    print(\"\\nZigZag order Traversal is : \")\n-    zigzag(root)\n-    print()\n+\n+    print(f\"In-order Traversal: {inorder(root)}\")\n+    print(f\"Pre-order Traversal: {preorder(root)}\")\n+    print(f\"Post-order Traversal: {postorder(root)}\", \"\\n\")\n+\n+    print(f\"Height of Tree: {height(root)}\", \"\\n\")\n+\n+    print(\"Complete Level Order Traversal: \")\n+    print(level_order(root), \"\\n\")\n+\n+    print(\"Level-wise order Traversal: \")\n+\n+    for level in range(1, height(root) + 1):\n+        print(f\"Level {level}:\", get_nodes_from_left_to_right(root, level=level))\n+\n+    print(\"\\nZigZag order Traversal: \")\n+    print(zigzag(root))\n \n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\n    print(f\"  In-order Traversal is {inorder(root)}\")\n    print(f\" Pre-order Traversal is {preorder(root)}\")\n    print(f\"Post-order Traversal is {postorder(root)}\")\n    print(f\"Height of Tree is {height(root)}\")\n    print(\"Complete Level Order Traversal is : \")\n    level_order_1(root)\n    print(\"\\nLevel-wise order Traversal is : \")\n    for h in range(1, height(root) + 1):\n        <IND>level_order_2(root, h)\n    <DED>print(\"\\nZigZag order Traversal is : \")\n    zigzag(root)\n    print()\n\n",
        "target_code_with_indent": "\n\n    print(f\"In-order Traversal: {inorder(root)}\")\n    print(f\"Pre-order Traversal: {preorder(root)}\")\n    print(f\"Post-order Traversal: {postorder(root)}\", \"\\n\")\n\n    print(f\"Height of Tree: {height(root)}\", \"\\n\")\n\n    print(\"Complete Level Order Traversal: \")\n    print(level_order(root), \"\\n\")\n\n    print(\"Level-wise order Traversal: \")\n\n    for level in range(1, height(root) + 1):\n        <IND>print(f\"Level {level}:\", get_nodes_from_left_to_right(root, level=level))\n\n    <DED>print(\"\\nZigZag order Traversal: \")\n    print(zigzag(root))\n\n"
      }
    ]
  },
  {
    "project": "TheAlgorithms/Python",
    "commit": "bf6db32ec2fb04b6477722f0809c5efef0cad813",
    "filename": "data_structures/binary_tree/binary_tree_traversals.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/TheAlgorithms-Python/data_structures/binary_tree/binary_tree_traversals.py",
    "file_hunks_size": 8,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "data_structures/binary_tree/binary_tree_traversals.py:111:28 Incompatible parameter type [6]: Expected `Node` for 1st positional only parameter to call `print_right_to_left` but got `typing.Optional[Node]`.",
    "message": " Expected `Node` for 1st positional only parameter to call `print_right_to_left` but got `typing.Optional[Node]`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 111,
    "warning_line": "        print_right_to_left(root.left, level - 1)",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\nfrom dataclasses import dataclass\n\n",
        "source_code_len": 36,
        "target_code": "\nfrom collections import deque\nfrom dataclasses import dataclass\nfrom typing import Any, Sequence\n\n",
        "target_code_len": 99,
        "diff_format": "@@ -3,3 +3,5 @@\n \n+from collections import deque\n from dataclasses import dataclass\n+from typing import Any, Sequence\n \n",
        "source_code_with_indent": "\nfrom dataclasses import dataclass\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\nfrom collections import deque\nfrom dataclasses import dataclass\nfrom typing import Any, Sequence\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\ndef level_order_1(root: Node):\n    \"\"\"\n    Print whole binary tree in Level Order Traverse.\n    Level Order traverse: Visit nodes of the tree level-by-level.\n    \"\"\"\n    if not root:\n        return\n    temp = root\n    que = [temp]\n    while len(que) > 0:\n        print(que[0].data, end=\" \")\n        temp = que.pop(0)\n        if temp.left:\n            que.append(temp.left)\n        if temp.right:\n            que.append(temp.right)\n    return que\n\n\ndef level_order_2(root: Node, level: int):\n    \"\"\"\n    Level-wise traversal: Print all nodes present at the given level of the binary tree\n    \"\"\"\n    if not root:\n        return root\n    if level == 1:\n        print(root.data, end=\" \")\n    elif level > 1:\n        level_order_2(root.left, level - 1)\n        level_order_2(root.right, level - 1)\n\n\ndef print_left_to_right(root: Node, level: int):\n    \"\"\"\n    Print elements on particular level from left to right direction of the binary tree.\n    \"\"\"\n    if not root:\n        return\n    if level == 1:\n        print(root.data, end=\" \")\n    elif level > 1:\n        print_left_to_right(root.left, level - 1)\n        print_left_to_right(root.right, level - 1)\n\n\ndef print_right_to_left(root: Node, level: int):\n    \"\"\"\n    Print elements on particular level from right to left direction of the binary tree.\n    \"\"\"\n    if not root:\n        return\n    if level == 1:\n        print(root.data, end=\" \")\n    elif level > 1:\n        print_right_to_left(root.right, level - 1)\n        print_right_to_left(root.left, level - 1)\n\n\ndef zigzag(root: Node):\n    \"\"\"\n    ZigZag traverse: Print node left to right and right to left, alternatively.\n    \"\"\"\n    flag = 0\n    height_tree = height(root)\n    for h in range(1, height_tree + 1):\n        if flag == 0:\n            print_left_to_right(root, h)\n            flag = 1\n        else:\n            print_right_to_left(root, h)\n            flag = 0\n\n\ndef main():  # Main function for testing.\n    \"\"\"\n",
        "source_code_len": 1935,
        "target_code": "\ndef level_order(root: Node | None) -> Sequence[Node | None]:\n    \"\"\"\n    Returns a list of nodes value from a whole binary tree in Level Order Traverse.\n    Level Order traverse: Visit nodes of the tree level-by-level.\n    \"\"\"\n    output: list[Any] = []\n\n    if root is None:\n        return output\n\n    process_queue = deque([root])\n\n    while process_queue:\n        node = process_queue.popleft()\n        output.append(node.data)\n\n        if node.left:\n            process_queue.append(node.left)\n        if node.right:\n            process_queue.append(node.right)\n    return output\n\n\ndef get_nodes_from_left_to_right(\n    root: Node | None, level: int\n) -> Sequence[Node | None]:\n    \"\"\"\n    Returns a list of nodes value from a particular level:\n    Left to right direction of the binary tree.\n    \"\"\"\n    output: list[Any] = []\n\n    def populate_output(root: Node | None, level: int) -> None:\n        if not root:\n            return\n        if level == 1:\n\n            output.append(root.data)\n        elif level > 1:\n            populate_output(root.left, level - 1)\n            populate_output(root.right, level - 1)\n\n    populate_output(root, level)\n    return output\n\n\ndef get_nodes_from_right_to_left(\n    root: Node | None, level: int\n) -> Sequence[Node | None]:\n    \"\"\"\n    Returns a list of nodes value from a particular level:\n    Right to left direction of the binary tree.\n    \"\"\"\n    output: list[Any] = []\n\n    def populate_output(root: Node | None, level: int) -> None:\n        if root is None:\n            return\n        if level == 1:\n            output.append(root.data)\n        elif level > 1:\n            populate_output(root.right, level - 1)\n            populate_output(root.left, level - 1)\n\n    populate_output(root, level)\n    return output\n\n\ndef zigzag(root: Node | None) -> Sequence[Node | None] | list[Any]:\n    \"\"\"\n    ZigZag traverse:\n    Returns a list of nodes value from left to right and right to left, alternatively.\n    \"\"\"\n    if root is None:\n        return []\n\n    output: list[Sequence[Node | None]] = []\n\n    flag = 0\n    height_tree = height(root)\n\n    for h in range(1, height_tree + 1):\n        if not flag:\n            output.append(get_nodes_from_left_to_right(root, h))\n            flag = 1\n        else:\n            output.append(get_nodes_from_right_to_left(root, h))\n            flag = 0\n\n    return output\n\n\ndef main() -> None:  # Main function for testing.\n    \"\"\"\n",
        "target_code_len": 2421,
        "diff_format": "@@ -55,76 +57,95 @@\n \n-def level_order_1(root: Node):\n+def level_order(root: Node | None) -> Sequence[Node | None]:\n     \"\"\"\n-    Print whole binary tree in Level Order Traverse.\n+    Returns a list of nodes value from a whole binary tree in Level Order Traverse.\n     Level Order traverse: Visit nodes of the tree level-by-level.\n     \"\"\"\n-    if not root:\n-        return\n-    temp = root\n-    que = [temp]\n-    while len(que) > 0:\n-        print(que[0].data, end=\" \")\n-        temp = que.pop(0)\n-        if temp.left:\n-            que.append(temp.left)\n-        if temp.right:\n-            que.append(temp.right)\n-    return que\n+    output: list[Any] = []\n+\n+    if root is None:\n+        return output\n+\n+    process_queue = deque([root])\n+\n+    while process_queue:\n+        node = process_queue.popleft()\n+        output.append(node.data)\n+\n+        if node.left:\n+            process_queue.append(node.left)\n+        if node.right:\n+            process_queue.append(node.right)\n+    return output\n \n \n-def level_order_2(root: Node, level: int):\n+def get_nodes_from_left_to_right(\n+    root: Node | None, level: int\n+) -> Sequence[Node | None]:\n     \"\"\"\n-    Level-wise traversal: Print all nodes present at the given level of the binary tree\n+    Returns a list of nodes value from a particular level:\n+    Left to right direction of the binary tree.\n     \"\"\"\n-    if not root:\n-        return root\n-    if level == 1:\n-        print(root.data, end=\" \")\n-    elif level > 1:\n-        level_order_2(root.left, level - 1)\n-        level_order_2(root.right, level - 1)\n+    output: list[Any] = []\n+\n+    def populate_output(root: Node | None, level: int) -> None:\n+        if not root:\n+            return\n+        if level == 1:\n+\n+            output.append(root.data)\n+        elif level > 1:\n+            populate_output(root.left, level - 1)\n+            populate_output(root.right, level - 1)\n+\n+    populate_output(root, level)\n+    return output\n \n \n-def print_left_to_right(root: Node, level: int):\n+def get_nodes_from_right_to_left(\n+    root: Node | None, level: int\n+) -> Sequence[Node | None]:\n     \"\"\"\n-    Print elements on particular level from left to right direction of the binary tree.\n+    Returns a list of nodes value from a particular level:\n+    Right to left direction of the binary tree.\n     \"\"\"\n-    if not root:\n-        return\n-    if level == 1:\n-        print(root.data, end=\" \")\n-    elif level > 1:\n-        print_left_to_right(root.left, level - 1)\n-        print_left_to_right(root.right, level - 1)\n+    output: list[Any] = []\n+\n+    def populate_output(root: Node | None, level: int) -> None:\n+        if root is None:\n+            return\n+        if level == 1:\n+            output.append(root.data)\n+        elif level > 1:\n+            populate_output(root.right, level - 1)\n+            populate_output(root.left, level - 1)\n+\n+    populate_output(root, level)\n+    return output\n \n \n-def print_right_to_left(root: Node, level: int):\n+def zigzag(root: Node | None) -> Sequence[Node | None] | list[Any]:\n     \"\"\"\n-    Print elements on particular level from right to left direction of the binary tree.\n+    ZigZag traverse:\n+    Returns a list of nodes value from left to right and right to left, alternatively.\n     \"\"\"\n-    if not root:\n-        return\n-    if level == 1:\n-        print(root.data, end=\" \")\n-    elif level > 1:\n-        print_right_to_left(root.right, level - 1)\n-        print_right_to_left(root.left, level - 1)\n+    if root is None:\n+        return []\n+\n+    output: list[Sequence[Node | None]] = []\n+\n+    flag = 0\n+    height_tree = height(root)\n+\n+    for h in range(1, height_tree + 1):\n+        if not flag:\n+            output.append(get_nodes_from_left_to_right(root, h))\n+            flag = 1\n+        else:\n+            output.append(get_nodes_from_right_to_left(root, h))\n+            flag = 0\n+\n+    return output\n \n \n-def zigzag(root: Node):\n-    \"\"\"\n-    ZigZag traverse: Print node left to right and right to left, alternatively.\n-    \"\"\"\n-    flag = 0\n-    height_tree = height(root)\n-    for h in range(1, height_tree + 1):\n-        if flag == 0:\n-            print_left_to_right(root, h)\n-            flag = 1\n-        else:\n-            print_right_to_left(root, h)\n-            flag = 0\n-\n-\n-def main():  # Main function for testing.\n+def main() -> None:  # Main function for testing.\n     \"\"\"\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\n<DED>def level_order_1(root: Node):\n    <IND>\"\"\"\n    Print whole binary tree in Level Order Traverse.\n    Level Order traverse: Visit nodes of the tree level-by-level.\n    \"\"\"\n    if not root:\n        <IND>return\n    <DED>temp = root\n    que = [temp]\n    while len(que) > 0:\n        <IND>print(que[0].data, end=\" \")\n        temp = que.pop(0)\n        if temp.left:\n            <IND>que.append(temp.left)\n        <DED>if temp.right:\n            <IND>que.append(temp.right)\n    <DED><DED>return que\n\n\n<DED>def level_order_2(root: Node, level: int):\n    <IND>\"\"\"\n    Level-wise traversal: Print all nodes present at the given level of the binary tree\n    \"\"\"\n    if not root:\n        <IND>return root\n    <DED>if level == 1:\n        <IND>print(root.data, end=\" \")\n    <DED>elif level > 1:\n        <IND>level_order_2(root.left, level - 1)\n        level_order_2(root.right, level - 1)\n\n\n<DED><DED>def print_left_to_right(root: Node, level: int):\n    <IND>\"\"\"\n    Print elements on particular level from left to right direction of the binary tree.\n    \"\"\"\n    if not root:\n        <IND>return\n    <DED>if level == 1:\n        <IND>print(root.data, end=\" \")\n    <DED>elif level > 1:\n        <IND>print_left_to_right(root.left, level - 1)\n        print_left_to_right(root.right, level - 1)\n\n\n<DED><DED>def print_right_to_left(root: Node, level: int):\n    <IND>\"\"\"\n    Print elements on particular level from right to left direction of the binary tree.\n    \"\"\"\n    if not root:\n        <IND>return\n    <DED>if level == 1:\n        <IND>print(root.data, end=\" \")\n    <DED>elif level > 1:\n        <IND>print_right_to_left(root.right, level - 1)\n        print_right_to_left(root.left, level - 1)\n\n\n<DED><DED>def zigzag(root: Node):\n    <IND>\"\"\"\n    ZigZag traverse: Print node left to right and right to left, alternatively.\n    \"\"\"\n    flag = 0\n    height_tree = height(root)\n    for h in range(1, height_tree + 1):\n        <IND>if flag == 0:\n            <IND>print_left_to_right(root, h)\n            flag = 1\n        <DED>else:\n            <IND>print_right_to_left(root, h)\n            flag = 0\n\n\n<DED><DED><DED>def main():  # Main function for testing.\n    <IND>",
        "target_code_with_indent": "\n<DED>def level_order(root: Node | None) -> Sequence[Node | None]:\n    <IND>\"\"\"\n    Returns a list of nodes value from a whole binary tree in Level Order Traverse.\n    Level Order traverse: Visit nodes of the tree level-by-level.\n    \"\"\"\n    output: list[Any] = []\n\n    if root is None:\n        <IND>return output\n\n    <DED>process_queue = deque([root])\n\n    while process_queue:\n        <IND>node = process_queue.popleft()\n        output.append(node.data)\n\n        if node.left:\n            <IND>process_queue.append(node.left)\n        <DED>if node.right:\n            <IND>process_queue.append(node.right)\n    <DED><DED>return output\n\n\n<DED>def get_nodes_from_left_to_right(\n    root: Node | None, level: int\n) -> Sequence[Node | None]:\n    <IND>\"\"\"\n    Returns a list of nodes value from a particular level:\n    Left to right direction of the binary tree.\n    \"\"\"\n    output: list[Any] = []\n\n    def populate_output(root: Node | None, level: int) -> None:\n        <IND>if not root:\n            <IND>return\n        <DED>if level == 1:\n\n            <IND>output.append(root.data)\n        <DED>elif level > 1:\n            <IND>populate_output(root.left, level - 1)\n            populate_output(root.right, level - 1)\n\n    <DED><DED>populate_output(root, level)\n    return output\n\n\n<DED>def get_nodes_from_right_to_left(\n    root: Node | None, level: int\n) -> Sequence[Node | None]:\n    <IND>\"\"\"\n    Returns a list of nodes value from a particular level:\n    Right to left direction of the binary tree.\n    \"\"\"\n    output: list[Any] = []\n\n    def populate_output(root: Node | None, level: int) -> None:\n        <IND>if root is None:\n            <IND>return\n        <DED>if level == 1:\n            <IND>output.append(root.data)\n        <DED>elif level > 1:\n            <IND>populate_output(root.right, level - 1)\n            populate_output(root.left, level - 1)\n\n    <DED><DED>populate_output(root, level)\n    return output\n\n\n<DED>def zigzag(root: Node | None) -> Sequence[Node | None] | list[Any]:\n    <IND>\"\"\"\n    ZigZag traverse:\n    Returns a list of nodes value from left to right and right to left, alternatively.\n    \"\"\"\n    if root is None:\n        <IND>return []\n\n    <DED>output: list[Sequence[Node | None]] = []\n\n    flag = 0\n    height_tree = height(root)\n\n    for h in range(1, height_tree + 1):\n        <IND>if not flag:\n            <IND>output.append(get_nodes_from_left_to_right(root, h))\n            flag = 1\n        <DED>else:\n            <IND>output.append(get_nodes_from_right_to_left(root, h))\n            flag = 0\n\n    <DED><DED>return output\n\n\n<DED>def main() -> None:  # Main function for testing.\n    <IND>"
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    \"\"\"\n    print(f\"  In-order Traversal is {inorder(root)}\")\n    print(f\" Pre-order Traversal is {preorder(root)}\")\n    print(f\"Post-order Traversal is {postorder(root)}\")\n    print(f\"Height of Tree is {height(root)}\")\n    print(\"Complete Level Order Traversal is : \")\n    level_order_1(root)\n    print(\"\\nLevel-wise order Traversal is : \")\n    for h in range(1, height(root) + 1):\n        level_order_2(root, h)\n    print(\"\\nZigZag order Traversal is : \")\n    zigzag(root)\n    print()\n\n",
        "source_code_len": 488,
        "target_code": "    \"\"\"\n\n    print(f\"In-order Traversal: {inorder(root)}\")\n    print(f\"Pre-order Traversal: {preorder(root)}\")\n    print(f\"Post-order Traversal: {postorder(root)}\", \"\\n\")\n\n    print(f\"Height of Tree: {height(root)}\", \"\\n\")\n\n    print(\"Complete Level Order Traversal: \")\n    print(level_order(root), \"\\n\")\n\n    print(\"Level-wise order Traversal: \")\n\n    for level in range(1, height(root) + 1):\n        print(f\"Level {level}:\", get_nodes_from_left_to_right(root, level=level))\n\n    print(\"\\nZigZag order Traversal: \")\n    print(zigzag(root))\n\n",
        "target_code_len": 542,
        "diff_format": "@@ -136,14 +157,19 @@\n     \"\"\"\n-    print(f\"  In-order Traversal is {inorder(root)}\")\n-    print(f\" Pre-order Traversal is {preorder(root)}\")\n-    print(f\"Post-order Traversal is {postorder(root)}\")\n-    print(f\"Height of Tree is {height(root)}\")\n-    print(\"Complete Level Order Traversal is : \")\n-    level_order_1(root)\n-    print(\"\\nLevel-wise order Traversal is : \")\n-    for h in range(1, height(root) + 1):\n-        level_order_2(root, h)\n-    print(\"\\nZigZag order Traversal is : \")\n-    zigzag(root)\n-    print()\n+\n+    print(f\"In-order Traversal: {inorder(root)}\")\n+    print(f\"Pre-order Traversal: {preorder(root)}\")\n+    print(f\"Post-order Traversal: {postorder(root)}\", \"\\n\")\n+\n+    print(f\"Height of Tree: {height(root)}\", \"\\n\")\n+\n+    print(\"Complete Level Order Traversal: \")\n+    print(level_order(root), \"\\n\")\n+\n+    print(\"Level-wise order Traversal: \")\n+\n+    for level in range(1, height(root) + 1):\n+        print(f\"Level {level}:\", get_nodes_from_left_to_right(root, level=level))\n+\n+    print(\"\\nZigZag order Traversal: \")\n+    print(zigzag(root))\n \n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\n    print(f\"  In-order Traversal is {inorder(root)}\")\n    print(f\" Pre-order Traversal is {preorder(root)}\")\n    print(f\"Post-order Traversal is {postorder(root)}\")\n    print(f\"Height of Tree is {height(root)}\")\n    print(\"Complete Level Order Traversal is : \")\n    level_order_1(root)\n    print(\"\\nLevel-wise order Traversal is : \")\n    for h in range(1, height(root) + 1):\n        <IND>level_order_2(root, h)\n    <DED>print(\"\\nZigZag order Traversal is : \")\n    zigzag(root)\n    print()\n\n",
        "target_code_with_indent": "\n\n    print(f\"In-order Traversal: {inorder(root)}\")\n    print(f\"Pre-order Traversal: {preorder(root)}\")\n    print(f\"Post-order Traversal: {postorder(root)}\", \"\\n\")\n\n    print(f\"Height of Tree: {height(root)}\", \"\\n\")\n\n    print(\"Complete Level Order Traversal: \")\n    print(level_order(root), \"\\n\")\n\n    print(\"Level-wise order Traversal: \")\n\n    for level in range(1, height(root) + 1):\n        <IND>print(f\"Level {level}:\", get_nodes_from_left_to_right(root, level=level))\n\n    <DED>print(\"\\nZigZag order Traversal: \")\n    print(zigzag(root))\n\n"
      }
    ]
  }
]