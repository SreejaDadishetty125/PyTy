[
  {
    "project": "google/TensorNetwork",
    "commit": "46be7df93bcaf7fc95cd09c9a3210db9e63098f1",
    "filename": "tensornetwork/block_sparse/charge.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/google-TensorNetwork/tensornetwork/block_sparse/charge.py",
    "file_hunks_size": 24,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "tensornetwork/block_sparse/charge.py:497:33 Incompatible parameter type [6]: Expected `typing.Iterable[Variable[_T1]]` for 1st positional only parameter to call `zip.__new__` but got `Optional[List[Type[BaseCharge]]]`.",
    "message": " Expected `typing.Iterable[Variable[_T1]]` for 1st positional only parameter to call `zip.__new__` but got `Optional[List[Type[BaseCharge]]]`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 497,
    "warning_line": "          a == b for a, b in zip(self.charge_types, target_charges.charge_types)",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "import numpy as np\nfrom tensornetwork.block_sparse.utils import intersect\nfrom typing import (List, Optional, Type, Any, Union, Callable)\n\n#TODO (mganahl): switch from column to row order for unique labels\n#TODO (mganahl): implement more efficient unique function\n#TODO (mganahl): clean up implementation of identity charges\n#TODO (mganahl): for rank-3 tensors with small bond dimensions, finding\n#                blocks brute force is much faster. Implement this.\n\n\n",
        "source_code_len": 467,
        "target_code": "import numpy as np\nfrom tensornetwork.block_sparse.utils import intersect, unique\nfrom typing import (List, Optional, Type, Any, Union, Callable)\n\n#TODO (mganahl): clean up implementation of identity charges\n\n",
        "target_code_len": 209,
        "diff_format": "@@ -15,11 +15,6 @@\n import numpy as np\n-from tensornetwork.block_sparse.utils import intersect\n+from tensornetwork.block_sparse.utils import intersect, unique\n from typing import (List, Optional, Type, Any, Union, Callable)\n \n-#TODO (mganahl): switch from column to row order for unique labels\n-#TODO (mganahl): implement more efficient unique function\n #TODO (mganahl): clean up implementation of identity charges\n-#TODO (mganahl): for rank-3 tensors with small bond dimensions, finding\n-#                blocks brute force is much faster. Implement this.\n-\n \n",
        "source_code_with_indent": "import numpy as np\nfrom tensornetwork.block_sparse.utils import intersect\nfrom typing import (List, Optional, Type, Any, Union, Callable)\n\n#TODO (mganahl): switch from column to row order for unique labels\n#TODO (mganahl): implement more efficient unique function\n#TODO (mganahl): clean up implementation of identity charges\n#TODO (mganahl): for rank-3 tensors with small bond dimensions, finding\n#                blocks brute force is much faster. Implement this.\n\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "import numpy as np\nfrom tensornetwork.block_sparse.utils import intersect, unique\nfrom typing import (List, Optional, Type, Any, Union, Callable)\n\n#TODO (mganahl): clean up implementation of identity charges\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "          .format(len(charge_types), charges.shape[1]))\n\n    if charges.shape[1] < 3:\n      label_dtype = np.int16\n    else:\n      label_dtype = np.int32\n    if charge_types is None:\n      charge_types = [type(self)] * charges.shape[1]\n    self.charge_types = charge_types\n    if charge_labels is None:\n      if charges.shape[0] > 0:\n        self.unique_charges, self.charge_labels = np.unique(\n            charges.astype(charge_dtype), return_inverse=True, axis=0)\n        self.charge_labels = self.charge_labels.astype(label_dtype)\n      else:\n        self.unique_charges = np.empty((0, charges.shape[1]),\n                                       dtype=charge_dtype)\n        self.charge_labels = np.empty(0, dtype=label_dtype)\n    else:\n      self.charge_labels = np.asarray(charge_labels, dtype=label_dtype)\n      self.unique_charges = charges.astype(charge_dtype)\n      \n  @staticmethod\n",
        "source_code_len": 889,
        "target_code": "          .format(len(charge_types), charges.shape[1]))\n    self.num_symmetries = charges.shape[1]\n    if charges.shape[1] < 3:\n      self.label_dtype = np.int16\n    else:\n      self.label_dtype = np.int32\n    if charge_types is None:\n      charge_types = [type(self)] * self.num_symmetries\n    self.charge_types = charge_types\n\n    if charge_labels is None:\n      self._unique_charges = None\n      self._charge_labels = None\n      self._charges = charges.astype(charge_dtype)\n\n\n    else:\n      self._charge_labels = np.asarray(charge_labels, dtype=self.label_dtype)\n      self._unique_charges = charges.astype(charge_dtype)\n      self._charges = None\n\n  @property\n  def unique_charges(self):\n    if self._unique_charges is None:\n      self._unique_charges, self._charge_labels = unique(\n          self.charges, return_inverse=True)\n      self._charges = None\n    return self._unique_charges\n\n  @property\n  def charge_labels(self):\n    if self._charge_labels is None:\n      self._unique_charges, self._charge_labels = unique(\n          self.charges, return_inverse=True)\n      self._charges = None\n    return self._charge_labels\n\n  @property\n  def charges(self):\n    if self._charges is not None:\n      return self._charges\n    return self._unique_charges[self._charge_labels, :]\n\n  @staticmethod\n",
        "target_code_len": 1297,
        "diff_format": "@@ -66,23 +59,44 @@\n           .format(len(charge_types), charges.shape[1]))\n-\n+    self.num_symmetries = charges.shape[1]\n     if charges.shape[1] < 3:\n-      label_dtype = np.int16\n+      self.label_dtype = np.int16\n     else:\n-      label_dtype = np.int32\n+      self.label_dtype = np.int32\n     if charge_types is None:\n-      charge_types = [type(self)] * charges.shape[1]\n+      charge_types = [type(self)] * self.num_symmetries\n     self.charge_types = charge_types\n+\n     if charge_labels is None:\n-      if charges.shape[0] > 0:\n-        self.unique_charges, self.charge_labels = np.unique(\n-            charges.astype(charge_dtype), return_inverse=True, axis=0)\n-        self.charge_labels = self.charge_labels.astype(label_dtype)\n-      else:\n-        self.unique_charges = np.empty((0, charges.shape[1]),\n-                                       dtype=charge_dtype)\n-        self.charge_labels = np.empty(0, dtype=label_dtype)\n+      self._unique_charges = None\n+      self._charge_labels = None\n+      self._charges = charges.astype(charge_dtype)\n+\n+\n     else:\n-      self.charge_labels = np.asarray(charge_labels, dtype=label_dtype)\n-      self.unique_charges = charges.astype(charge_dtype)\n-      \n+      self._charge_labels = np.asarray(charge_labels, dtype=self.label_dtype)\n+      self._unique_charges = charges.astype(charge_dtype)\n+      self._charges = None\n+\n+  @property\n+  def unique_charges(self):\n+    if self._unique_charges is None:\n+      self._unique_charges, self._charge_labels = unique(\n+          self.charges, return_inverse=True)\n+      self._charges = None\n+    return self._unique_charges\n+\n+  @property\n+  def charge_labels(self):\n+    if self._charge_labels is None:\n+      self._unique_charges, self._charge_labels = unique(\n+          self.charges, return_inverse=True)\n+      self._charges = None\n+    return self._charge_labels\n+\n+  @property\n+  def charges(self):\n+    if self._charges is not None:\n+      return self._charges\n+    return self._unique_charges[self._charge_labels, :]\n+\n   @staticmethod\n",
        "source_code_with_indent": "          .format(len(charge_types), charges.shape[1]))\n\n    <DED>if charges.shape[1] < 3:\n      <IND>label_dtype = np.int16\n    <DED>else:\n      <IND>label_dtype = np.int32\n    <DED>if charge_types is None:\n      <IND>charge_types = [type(self)] * charges.shape[1]\n    <DED>self.charge_types = charge_types\n    if charge_labels is None:\n      <IND>if charges.shape[0] > 0:\n        <IND>self.unique_charges, self.charge_labels = np.unique(\n            charges.astype(charge_dtype), return_inverse=True, axis=0)\n        self.charge_labels = self.charge_labels.astype(label_dtype)\n      <DED>else:\n        <IND>self.unique_charges = np.empty((0, charges.shape[1]),\n                                       dtype=charge_dtype)\n        self.charge_labels = np.empty(0, dtype=label_dtype)\n    <DED><DED>else:\n      <IND>self.charge_labels = np.asarray(charge_labels, dtype=label_dtype)\n      self.unique_charges = charges.astype(charge_dtype)\n      \n  <DED><DED>@staticmethod\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "          .format(len(charge_types), charges.shape[1]))\n    <DED>self.num_symmetries = charges.shape[1]\n    if charges.shape[1] < 3:\n      <IND>self.label_dtype = np.int16\n    <DED>else:\n      <IND>self.label_dtype = np.int32\n    <DED>if charge_types is None:\n      <IND>charge_types = [type(self)] * self.num_symmetries\n    <DED>self.charge_types = charge_types\n\n    if charge_labels is None:\n      <IND>self._unique_charges = None\n      self._charge_labels = None\n      self._charges = charges.astype(charge_dtype)\n\n\n    <DED>else:\n      <IND>self._charge_labels = np.asarray(charge_labels, dtype=self.label_dtype)\n      self._unique_charges = charges.astype(charge_dtype)\n      self._charges = None\n\n  <DED><DED>@property\n  def unique_charges(self):\n    <IND>if self._unique_charges is None:\n      <IND>self._unique_charges, self._charge_labels = unique(\n          self.charges, return_inverse=True)\n      self._charges = None\n    <DED>return self._unique_charges\n\n  <DED>@property\n  def charge_labels(self):\n    <IND>if self._charge_labels is None:\n      <IND>self._unique_charges, self._charge_labels = unique(\n          self.charges, return_inverse=True)\n      self._charges = None\n    <DED>return self._charge_labels\n\n  <DED>@property\n  def charges(self):\n    <IND>if self._charges is not None:\n      <IND>return self._charges\n    <DED>return self._unique_charges[self._charge_labels, :]\n\n  <DED>@staticmethod\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "  def dim(self):\n    return len(self.charge_labels)\n\n  @property\n  def num_symmetries(self) -> int:\n    \"\"\"\n    Return the number of different charges in `ChargeCollection`.\n    \"\"\"\n    return self.unique_charges.shape[1]\n\n",
        "source_code_len": 223,
        "target_code": "  def dim(self):\n    if self._charge_labels is not None:\n      return len(self._charge_labels)\n    return self._charges.shape[0]\n\n",
        "target_code_len": 130,
        "diff_format": "@@ -108,10 +122,5 @@\n   def dim(self):\n-    return len(self.charge_labels)\n-\n-  @property\n-  def num_symmetries(self) -> int:\n-    \"\"\"\n-    Return the number of different charges in `ChargeCollection`.\n-    \"\"\"\n-    return self.unique_charges.shape[1]\n+    if self._charge_labels is not None:\n+      return len(self._charge_labels)\n+    return self._charges.shape[0]\n \n",
        "source_code_with_indent": "  def dim(self):\n    <IND>return len(self.charge_labels)\n\n  <DED>@property\n  def num_symmetries(self) -> int:\n    <IND>\"\"\"\n    Return the number of different charges in `ChargeCollection`.\n    \"\"\"\n    return self.unique_charges.shape[1]\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "  def dim(self):\n    <IND>if self._charge_labels is not None:\n      <IND>return len(self._charge_labels)\n    <DED>return self._charges.shape[0]\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "  @property\n  def charges(self):\n    \"\"\"\n    Return the actual charges of `BaseCharge` as np.ndarray.\n    \"\"\"\n    return self.unique_charges[self.charge_labels, :]\n\n  @property\n  def dtype(self):\n    return self.unique_charges.dtype\n\n  @property\n  def label_dtype(self):\n    return self.charge_labels.dtype\n\n",
        "source_code_len": 308,
        "target_code": "  @property\n  def dtype(self):\n    if self._unique_charges is not None:\n      return self._unique_charges.dtype\n    return self._charges.dtype\n\n",
        "target_code_len": 144,
        "diff_format": "@@ -137,15 +153,6 @@\n   @property\n-  def charges(self):\n-    \"\"\"\n-    Return the actual charges of `BaseCharge` as np.ndarray.\n-    \"\"\"\n-    return self.unique_charges[self.charge_labels, :]\n-\n-  @property\n   def dtype(self):\n-    return self.unique_charges.dtype\n-\n-  @property\n-  def label_dtype(self):\n-    return self.charge_labels.dtype\n+    if self._unique_charges is not None:\n+      return self._unique_charges.dtype\n+    return self._charges.dtype\n \n",
        "source_code_with_indent": "  <DED>@property\n  def charges(self):\n    <IND>\"\"\"\n    Return the actual charges of `BaseCharge` as np.ndarray.\n    \"\"\"\n    return self.unique_charges[self.charge_labels, :]\n\n  <DED>@property\n  def dtype(self):\n    <IND>return self.unique_charges.dtype\n\n  <DED>@property\n  def label_dtype(self):\n    <IND>return self.charge_labels.dtype\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "  <DED>@property\n  def dtype(self):\n    <IND>if self._unique_charges is not None:\n      <IND>return self._unique_charges.dtype\n    <DED>return self._charges.dtype\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    obj = self.__new__(type(self))\n    labels = self.charge_labels[n]\n    unique_labels, new_labels = np.unique(labels, return_inverse=True)\n    if unique_labels.ndim == 0:\n      unique_labels = np.asarray(unique_labels)\n    unique_charges = self.unique_charges[unique_labels, :]\n    obj.__init__(unique_charges, new_labels, self.charge_types)\n    return obj\n\n  def isin(self, target_charges: Union[np.ndarray, \"BaseCharge\"]) -> np.ndarray:\n    \"\"\"\n    See also np.isin. \n    Returns an np.ndarray of `dtype=bool`, with `True` at all linear positions\n    where `self` is in `target_charges`, and `False` everywhere else.\n    Args:\n      target_charges: A `BaseCharge` object.\n    Returns:\n      np.ndarray: An array of boolean values.\n    \"\"\"\n    if isinstance(target_charges, type(self)):\n      if not np.all([\n          a == b for a, b in zip(self.charge_types, target_charges.charge_types)\n      ]):\n        raise TypeError(\n            \"isin only callable for equal charge types, found {} and {}\".format(\n                self.charge_types, target_charges.charge_types))\n\n      targets = target_charges.unique_charges\n    else:\n      if target_charges.ndim == 1:\n        if target_charges.shape[0] == 0:\n          raise ValueError(\"input to `isin` cannot be an empty np.ndarray\")\n        targets = np.unique(target_charges, axis=0)[:, None]\n      elif target_charges.ndim == 2:\n        if target_charges.shape[0] == 0:\n          raise ValueError(\"input to `isin` cannot be an empty np.ndarray\")\n\n        targets = np.unique(target_charges, axis=0)\n      else:\n        raise ValueError(\"targets.ndim has to be 1 or 2, found {}\".format(\n            target_charges.ndim))\n      if targets.shape[1] != self.num_symmetries:\n        raise ValueError(\n            \"target_charges.shape[0]={} is different from \"\n            \"self.num_symmetries = {}\"\n            .format(targets.shape[0], self.num_symmetries))\n\n    tmp = self.unique_charges[:, :, None] == targets.T[None, :, :]\n    #pylint: disable=no-member\n    inds = np.nonzero(\n        np.logical_or.reduce(np.logical_and.reduce(tmp, axis=1), axis=1))[0]\n\n    return np.isin(self.charge_labels, inds)\n\n",
        "source_code_len": 2153,
        "target_code": "    obj = self.__new__(type(self))\n    if self._unique_charges is not None:\n      labels = self.charge_labels[n]\n      unique_labels, new_labels = unique(labels, return_inverse=True)\n      unique_charges = self.unique_charges[unique_labels, :]\n      obj.__init__(unique_charges, new_labels, self.charge_types)\n      return obj\n    obj.__init__(\n        self._charges[n, :], charge_labels=None, charge_types=self.charge_types)\n    return obj\n\n",
        "target_code_len": 442,
        "diff_format": "@@ -476,54 +466,11 @@\n     obj = self.__new__(type(self))\n-    labels = self.charge_labels[n]\n-    unique_labels, new_labels = np.unique(labels, return_inverse=True)\n-    if unique_labels.ndim == 0:\n-      unique_labels = np.asarray(unique_labels)\n-    unique_charges = self.unique_charges[unique_labels, :]\n-    obj.__init__(unique_charges, new_labels, self.charge_types)\n+    if self._unique_charges is not None:\n+      labels = self.charge_labels[n]\n+      unique_labels, new_labels = unique(labels, return_inverse=True)\n+      unique_charges = self.unique_charges[unique_labels, :]\n+      obj.__init__(unique_charges, new_labels, self.charge_types)\n+      return obj\n+    obj.__init__(\n+        self._charges[n, :], charge_labels=None, charge_types=self.charge_types)\n     return obj\n-\n-  def isin(self, target_charges: Union[np.ndarray, \"BaseCharge\"]) -> np.ndarray:\n-    \"\"\"\n-    See also np.isin. \n-    Returns an np.ndarray of `dtype=bool`, with `True` at all linear positions\n-    where `self` is in `target_charges`, and `False` everywhere else.\n-    Args:\n-      target_charges: A `BaseCharge` object.\n-    Returns:\n-      np.ndarray: An array of boolean values.\n-    \"\"\"\n-    if isinstance(target_charges, type(self)):\n-      if not np.all([\n-          a == b for a, b in zip(self.charge_types, target_charges.charge_types)\n-      ]):\n-        raise TypeError(\n-            \"isin only callable for equal charge types, found {} and {}\".format(\n-                self.charge_types, target_charges.charge_types))\n-\n-      targets = target_charges.unique_charges\n-    else:\n-      if target_charges.ndim == 1:\n-        if target_charges.shape[0] == 0:\n-          raise ValueError(\"input to `isin` cannot be an empty np.ndarray\")\n-        targets = np.unique(target_charges, axis=0)[:, None]\n-      elif target_charges.ndim == 2:\n-        if target_charges.shape[0] == 0:\n-          raise ValueError(\"input to `isin` cannot be an empty np.ndarray\")\n-\n-        targets = np.unique(target_charges, axis=0)\n-      else:\n-        raise ValueError(\"targets.ndim has to be 1 or 2, found {}\".format(\n-            target_charges.ndim))\n-      if targets.shape[1] != self.num_symmetries:\n-        raise ValueError(\n-            \"target_charges.shape[0]={} is different from \"\n-            \"self.num_symmetries = {}\"\n-            .format(targets.shape[0], self.num_symmetries))\n-\n-    tmp = self.unique_charges[:, :, None] == targets.T[None, :, :]\n-    #pylint: disable=no-member\n-    inds = np.nonzero(\n-        np.logical_or.reduce(np.logical_and.reduce(tmp, axis=1), axis=1))[0]\n-\n-    return np.isin(self.charge_labels, inds)\n \n",
        "source_code_with_indent": "    obj = self.__new__(type(self))\n    labels = self.charge_labels[n]\n    unique_labels, new_labels = np.unique(labels, return_inverse=True)\n    if unique_labels.ndim == 0:\n      <IND>unique_labels = np.asarray(unique_labels)\n    <DED>unique_charges = self.unique_charges[unique_labels, :]\n    obj.__init__(unique_charges, new_labels, self.charge_types)\n    return obj\n\n  <DED>def isin(self, target_charges: Union[np.ndarray, \"BaseCharge\"]) -> np.ndarray:\n    <IND>\"\"\"\n    See also np.isin. \n    Returns an np.ndarray of `dtype=bool`, with `True` at all linear positions\n    where `self` is in `target_charges`, and `False` everywhere else.\n    Args:\n      target_charges: A `BaseCharge` object.\n    Returns:\n      np.ndarray: An array of boolean values.\n    \"\"\"\n    if isinstance(target_charges, type(self)):\n      <IND>if not np.all([\n          a == b for a, b in zip(self.charge_types, target_charges.charge_types)\n      ]):\n        <IND>raise TypeError(\n            \"isin only callable for equal charge types, found {} and {}\".format(\n                self.charge_types, target_charges.charge_types))\n\n      <DED>targets = target_charges.unique_charges\n    <DED>else:\n      <IND>if target_charges.ndim == 1:\n        <IND>if target_charges.shape[0] == 0:\n          <IND>raise ValueError(\"input to `isin` cannot be an empty np.ndarray\")\n        <DED>targets = np.unique(target_charges, axis=0)[:, None]\n      <DED>elif target_charges.ndim == 2:\n        <IND>if target_charges.shape[0] == 0:\n          <IND>raise ValueError(\"input to `isin` cannot be an empty np.ndarray\")\n\n        <DED>targets = np.unique(target_charges, axis=0)\n      <DED>else:\n        <IND>raise ValueError(\"targets.ndim has to be 1 or 2, found {}\".format(\n            target_charges.ndim))\n      <DED>if targets.shape[1] != self.num_symmetries:\n        <IND>raise ValueError(\n            \"target_charges.shape[0]={} is different from \"\n            \"self.num_symmetries = {}\"\n            .format(targets.shape[0], self.num_symmetries))\n\n    <DED><DED>tmp = self.unique_charges[:, :, None] == targets.T[None, :, :]\n    #pylint: disable=no-member\n    inds = np.nonzero(\n        np.logical_or.reduce(np.logical_and.reduce(tmp, axis=1), axis=1))[0]\n\n    return np.isin(self.charge_labels, inds)\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    obj = self.__new__(type(self))\n    if self._unique_charges is not None:\n      <IND>labels = self.charge_labels[n]\n      unique_labels, new_labels = unique(labels, return_inverse=True)\n      unique_charges = self.unique_charges[unique_labels, :]\n      obj.__init__(unique_charges, new_labels, self.charge_types)\n      return obj\n    <DED>obj.__init__(\n        self._charges[n, :], charge_labels=None, charge_types=self.charge_types)\n    return obj\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "google/TensorNetwork",
    "commit": "46be7df93bcaf7fc95cd09c9a3210db9e63098f1",
    "filename": "tensornetwork/block_sparse/charge.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/google-TensorNetwork/tensornetwork/block_sparse/charge.py",
    "file_hunks_size": 24,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "tensornetwork/block_sparse/charge.py:497:52 Incompatible parameter type [6]: Expected `typing.Iterable[Variable[_T2]]` for 2nd positional only parameter to call `zip.__new__` but got `Optional[List[Type[BaseCharge]]]`.",
    "message": " Expected `typing.Iterable[Variable[_T2]]` for 2nd positional only parameter to call `zip.__new__` but got `Optional[List[Type[BaseCharge]]]`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 497,
    "warning_line": "          a == b for a, b in zip(self.charge_types, target_charges.charge_types)",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "import numpy as np\nfrom tensornetwork.block_sparse.utils import intersect\nfrom typing import (List, Optional, Type, Any, Union, Callable)\n\n#TODO (mganahl): switch from column to row order for unique labels\n#TODO (mganahl): implement more efficient unique function\n#TODO (mganahl): clean up implementation of identity charges\n#TODO (mganahl): for rank-3 tensors with small bond dimensions, finding\n#                blocks brute force is much faster. Implement this.\n\n\n",
        "source_code_len": 467,
        "target_code": "import numpy as np\nfrom tensornetwork.block_sparse.utils import intersect, unique\nfrom typing import (List, Optional, Type, Any, Union, Callable)\n\n#TODO (mganahl): clean up implementation of identity charges\n\n",
        "target_code_len": 209,
        "diff_format": "@@ -15,11 +15,6 @@\n import numpy as np\n-from tensornetwork.block_sparse.utils import intersect\n+from tensornetwork.block_sparse.utils import intersect, unique\n from typing import (List, Optional, Type, Any, Union, Callable)\n \n-#TODO (mganahl): switch from column to row order for unique labels\n-#TODO (mganahl): implement more efficient unique function\n #TODO (mganahl): clean up implementation of identity charges\n-#TODO (mganahl): for rank-3 tensors with small bond dimensions, finding\n-#                blocks brute force is much faster. Implement this.\n-\n \n",
        "source_code_with_indent": "import numpy as np\nfrom tensornetwork.block_sparse.utils import intersect\nfrom typing import (List, Optional, Type, Any, Union, Callable)\n\n#TODO (mganahl): switch from column to row order for unique labels\n#TODO (mganahl): implement more efficient unique function\n#TODO (mganahl): clean up implementation of identity charges\n#TODO (mganahl): for rank-3 tensors with small bond dimensions, finding\n#                blocks brute force is much faster. Implement this.\n\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "import numpy as np\nfrom tensornetwork.block_sparse.utils import intersect, unique\nfrom typing import (List, Optional, Type, Any, Union, Callable)\n\n#TODO (mganahl): clean up implementation of identity charges\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "          .format(len(charge_types), charges.shape[1]))\n\n    if charges.shape[1] < 3:\n      label_dtype = np.int16\n    else:\n      label_dtype = np.int32\n    if charge_types is None:\n      charge_types = [type(self)] * charges.shape[1]\n    self.charge_types = charge_types\n    if charge_labels is None:\n      if charges.shape[0] > 0:\n        self.unique_charges, self.charge_labels = np.unique(\n            charges.astype(charge_dtype), return_inverse=True, axis=0)\n        self.charge_labels = self.charge_labels.astype(label_dtype)\n      else:\n        self.unique_charges = np.empty((0, charges.shape[1]),\n                                       dtype=charge_dtype)\n        self.charge_labels = np.empty(0, dtype=label_dtype)\n    else:\n      self.charge_labels = np.asarray(charge_labels, dtype=label_dtype)\n      self.unique_charges = charges.astype(charge_dtype)\n      \n  @staticmethod\n",
        "source_code_len": 889,
        "target_code": "          .format(len(charge_types), charges.shape[1]))\n    self.num_symmetries = charges.shape[1]\n    if charges.shape[1] < 3:\n      self.label_dtype = np.int16\n    else:\n      self.label_dtype = np.int32\n    if charge_types is None:\n      charge_types = [type(self)] * self.num_symmetries\n    self.charge_types = charge_types\n\n    if charge_labels is None:\n      self._unique_charges = None\n      self._charge_labels = None\n      self._charges = charges.astype(charge_dtype)\n\n\n    else:\n      self._charge_labels = np.asarray(charge_labels, dtype=self.label_dtype)\n      self._unique_charges = charges.astype(charge_dtype)\n      self._charges = None\n\n  @property\n  def unique_charges(self):\n    if self._unique_charges is None:\n      self._unique_charges, self._charge_labels = unique(\n          self.charges, return_inverse=True)\n      self._charges = None\n    return self._unique_charges\n\n  @property\n  def charge_labels(self):\n    if self._charge_labels is None:\n      self._unique_charges, self._charge_labels = unique(\n          self.charges, return_inverse=True)\n      self._charges = None\n    return self._charge_labels\n\n  @property\n  def charges(self):\n    if self._charges is not None:\n      return self._charges\n    return self._unique_charges[self._charge_labels, :]\n\n  @staticmethod\n",
        "target_code_len": 1297,
        "diff_format": "@@ -66,23 +59,44 @@\n           .format(len(charge_types), charges.shape[1]))\n-\n+    self.num_symmetries = charges.shape[1]\n     if charges.shape[1] < 3:\n-      label_dtype = np.int16\n+      self.label_dtype = np.int16\n     else:\n-      label_dtype = np.int32\n+      self.label_dtype = np.int32\n     if charge_types is None:\n-      charge_types = [type(self)] * charges.shape[1]\n+      charge_types = [type(self)] * self.num_symmetries\n     self.charge_types = charge_types\n+\n     if charge_labels is None:\n-      if charges.shape[0] > 0:\n-        self.unique_charges, self.charge_labels = np.unique(\n-            charges.astype(charge_dtype), return_inverse=True, axis=0)\n-        self.charge_labels = self.charge_labels.astype(label_dtype)\n-      else:\n-        self.unique_charges = np.empty((0, charges.shape[1]),\n-                                       dtype=charge_dtype)\n-        self.charge_labels = np.empty(0, dtype=label_dtype)\n+      self._unique_charges = None\n+      self._charge_labels = None\n+      self._charges = charges.astype(charge_dtype)\n+\n+\n     else:\n-      self.charge_labels = np.asarray(charge_labels, dtype=label_dtype)\n-      self.unique_charges = charges.astype(charge_dtype)\n-      \n+      self._charge_labels = np.asarray(charge_labels, dtype=self.label_dtype)\n+      self._unique_charges = charges.astype(charge_dtype)\n+      self._charges = None\n+\n+  @property\n+  def unique_charges(self):\n+    if self._unique_charges is None:\n+      self._unique_charges, self._charge_labels = unique(\n+          self.charges, return_inverse=True)\n+      self._charges = None\n+    return self._unique_charges\n+\n+  @property\n+  def charge_labels(self):\n+    if self._charge_labels is None:\n+      self._unique_charges, self._charge_labels = unique(\n+          self.charges, return_inverse=True)\n+      self._charges = None\n+    return self._charge_labels\n+\n+  @property\n+  def charges(self):\n+    if self._charges is not None:\n+      return self._charges\n+    return self._unique_charges[self._charge_labels, :]\n+\n   @staticmethod\n",
        "source_code_with_indent": "          .format(len(charge_types), charges.shape[1]))\n\n    <DED>if charges.shape[1] < 3:\n      <IND>label_dtype = np.int16\n    <DED>else:\n      <IND>label_dtype = np.int32\n    <DED>if charge_types is None:\n      <IND>charge_types = [type(self)] * charges.shape[1]\n    <DED>self.charge_types = charge_types\n    if charge_labels is None:\n      <IND>if charges.shape[0] > 0:\n        <IND>self.unique_charges, self.charge_labels = np.unique(\n            charges.astype(charge_dtype), return_inverse=True, axis=0)\n        self.charge_labels = self.charge_labels.astype(label_dtype)\n      <DED>else:\n        <IND>self.unique_charges = np.empty((0, charges.shape[1]),\n                                       dtype=charge_dtype)\n        self.charge_labels = np.empty(0, dtype=label_dtype)\n    <DED><DED>else:\n      <IND>self.charge_labels = np.asarray(charge_labels, dtype=label_dtype)\n      self.unique_charges = charges.astype(charge_dtype)\n      \n  <DED><DED>@staticmethod\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "          .format(len(charge_types), charges.shape[1]))\n    <DED>self.num_symmetries = charges.shape[1]\n    if charges.shape[1] < 3:\n      <IND>self.label_dtype = np.int16\n    <DED>else:\n      <IND>self.label_dtype = np.int32\n    <DED>if charge_types is None:\n      <IND>charge_types = [type(self)] * self.num_symmetries\n    <DED>self.charge_types = charge_types\n\n    if charge_labels is None:\n      <IND>self._unique_charges = None\n      self._charge_labels = None\n      self._charges = charges.astype(charge_dtype)\n\n\n    <DED>else:\n      <IND>self._charge_labels = np.asarray(charge_labels, dtype=self.label_dtype)\n      self._unique_charges = charges.astype(charge_dtype)\n      self._charges = None\n\n  <DED><DED>@property\n  def unique_charges(self):\n    <IND>if self._unique_charges is None:\n      <IND>self._unique_charges, self._charge_labels = unique(\n          self.charges, return_inverse=True)\n      self._charges = None\n    <DED>return self._unique_charges\n\n  <DED>@property\n  def charge_labels(self):\n    <IND>if self._charge_labels is None:\n      <IND>self._unique_charges, self._charge_labels = unique(\n          self.charges, return_inverse=True)\n      self._charges = None\n    <DED>return self._charge_labels\n\n  <DED>@property\n  def charges(self):\n    <IND>if self._charges is not None:\n      <IND>return self._charges\n    <DED>return self._unique_charges[self._charge_labels, :]\n\n  <DED>@staticmethod\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "  def dim(self):\n    return len(self.charge_labels)\n\n  @property\n  def num_symmetries(self) -> int:\n    \"\"\"\n    Return the number of different charges in `ChargeCollection`.\n    \"\"\"\n    return self.unique_charges.shape[1]\n\n",
        "source_code_len": 223,
        "target_code": "  def dim(self):\n    if self._charge_labels is not None:\n      return len(self._charge_labels)\n    return self._charges.shape[0]\n\n",
        "target_code_len": 130,
        "diff_format": "@@ -108,10 +122,5 @@\n   def dim(self):\n-    return len(self.charge_labels)\n-\n-  @property\n-  def num_symmetries(self) -> int:\n-    \"\"\"\n-    Return the number of different charges in `ChargeCollection`.\n-    \"\"\"\n-    return self.unique_charges.shape[1]\n+    if self._charge_labels is not None:\n+      return len(self._charge_labels)\n+    return self._charges.shape[0]\n \n",
        "source_code_with_indent": "  def dim(self):\n    <IND>return len(self.charge_labels)\n\n  <DED>@property\n  def num_symmetries(self) -> int:\n    <IND>\"\"\"\n    Return the number of different charges in `ChargeCollection`.\n    \"\"\"\n    return self.unique_charges.shape[1]\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "  def dim(self):\n    <IND>if self._charge_labels is not None:\n      <IND>return len(self._charge_labels)\n    <DED>return self._charges.shape[0]\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "  @property\n  def charges(self):\n    \"\"\"\n    Return the actual charges of `BaseCharge` as np.ndarray.\n    \"\"\"\n    return self.unique_charges[self.charge_labels, :]\n\n  @property\n  def dtype(self):\n    return self.unique_charges.dtype\n\n  @property\n  def label_dtype(self):\n    return self.charge_labels.dtype\n\n",
        "source_code_len": 308,
        "target_code": "  @property\n  def dtype(self):\n    if self._unique_charges is not None:\n      return self._unique_charges.dtype\n    return self._charges.dtype\n\n",
        "target_code_len": 144,
        "diff_format": "@@ -137,15 +153,6 @@\n   @property\n-  def charges(self):\n-    \"\"\"\n-    Return the actual charges of `BaseCharge` as np.ndarray.\n-    \"\"\"\n-    return self.unique_charges[self.charge_labels, :]\n-\n-  @property\n   def dtype(self):\n-    return self.unique_charges.dtype\n-\n-  @property\n-  def label_dtype(self):\n-    return self.charge_labels.dtype\n+    if self._unique_charges is not None:\n+      return self._unique_charges.dtype\n+    return self._charges.dtype\n \n",
        "source_code_with_indent": "  <DED>@property\n  def charges(self):\n    <IND>\"\"\"\n    Return the actual charges of `BaseCharge` as np.ndarray.\n    \"\"\"\n    return self.unique_charges[self.charge_labels, :]\n\n  <DED>@property\n  def dtype(self):\n    <IND>return self.unique_charges.dtype\n\n  <DED>@property\n  def label_dtype(self):\n    <IND>return self.charge_labels.dtype\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "  <DED>@property\n  def dtype(self):\n    <IND>if self._unique_charges is not None:\n      <IND>return self._unique_charges.dtype\n    <DED>return self._charges.dtype\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    obj = self.__new__(type(self))\n    labels = self.charge_labels[n]\n    unique_labels, new_labels = np.unique(labels, return_inverse=True)\n    if unique_labels.ndim == 0:\n      unique_labels = np.asarray(unique_labels)\n    unique_charges = self.unique_charges[unique_labels, :]\n    obj.__init__(unique_charges, new_labels, self.charge_types)\n    return obj\n\n  def isin(self, target_charges: Union[np.ndarray, \"BaseCharge\"]) -> np.ndarray:\n    \"\"\"\n    See also np.isin. \n    Returns an np.ndarray of `dtype=bool`, with `True` at all linear positions\n    where `self` is in `target_charges`, and `False` everywhere else.\n    Args:\n      target_charges: A `BaseCharge` object.\n    Returns:\n      np.ndarray: An array of boolean values.\n    \"\"\"\n    if isinstance(target_charges, type(self)):\n      if not np.all([\n          a == b for a, b in zip(self.charge_types, target_charges.charge_types)\n      ]):\n        raise TypeError(\n            \"isin only callable for equal charge types, found {} and {}\".format(\n                self.charge_types, target_charges.charge_types))\n\n      targets = target_charges.unique_charges\n    else:\n      if target_charges.ndim == 1:\n        if target_charges.shape[0] == 0:\n          raise ValueError(\"input to `isin` cannot be an empty np.ndarray\")\n        targets = np.unique(target_charges, axis=0)[:, None]\n      elif target_charges.ndim == 2:\n        if target_charges.shape[0] == 0:\n          raise ValueError(\"input to `isin` cannot be an empty np.ndarray\")\n\n        targets = np.unique(target_charges, axis=0)\n      else:\n        raise ValueError(\"targets.ndim has to be 1 or 2, found {}\".format(\n            target_charges.ndim))\n      if targets.shape[1] != self.num_symmetries:\n        raise ValueError(\n            \"target_charges.shape[0]={} is different from \"\n            \"self.num_symmetries = {}\"\n            .format(targets.shape[0], self.num_symmetries))\n\n    tmp = self.unique_charges[:, :, None] == targets.T[None, :, :]\n    #pylint: disable=no-member\n    inds = np.nonzero(\n        np.logical_or.reduce(np.logical_and.reduce(tmp, axis=1), axis=1))[0]\n\n    return np.isin(self.charge_labels, inds)\n\n",
        "source_code_len": 2153,
        "target_code": "    obj = self.__new__(type(self))\n    if self._unique_charges is not None:\n      labels = self.charge_labels[n]\n      unique_labels, new_labels = unique(labels, return_inverse=True)\n      unique_charges = self.unique_charges[unique_labels, :]\n      obj.__init__(unique_charges, new_labels, self.charge_types)\n      return obj\n    obj.__init__(\n        self._charges[n, :], charge_labels=None, charge_types=self.charge_types)\n    return obj\n\n",
        "target_code_len": 442,
        "diff_format": "@@ -476,54 +466,11 @@\n     obj = self.__new__(type(self))\n-    labels = self.charge_labels[n]\n-    unique_labels, new_labels = np.unique(labels, return_inverse=True)\n-    if unique_labels.ndim == 0:\n-      unique_labels = np.asarray(unique_labels)\n-    unique_charges = self.unique_charges[unique_labels, :]\n-    obj.__init__(unique_charges, new_labels, self.charge_types)\n+    if self._unique_charges is not None:\n+      labels = self.charge_labels[n]\n+      unique_labels, new_labels = unique(labels, return_inverse=True)\n+      unique_charges = self.unique_charges[unique_labels, :]\n+      obj.__init__(unique_charges, new_labels, self.charge_types)\n+      return obj\n+    obj.__init__(\n+        self._charges[n, :], charge_labels=None, charge_types=self.charge_types)\n     return obj\n-\n-  def isin(self, target_charges: Union[np.ndarray, \"BaseCharge\"]) -> np.ndarray:\n-    \"\"\"\n-    See also np.isin. \n-    Returns an np.ndarray of `dtype=bool`, with `True` at all linear positions\n-    where `self` is in `target_charges`, and `False` everywhere else.\n-    Args:\n-      target_charges: A `BaseCharge` object.\n-    Returns:\n-      np.ndarray: An array of boolean values.\n-    \"\"\"\n-    if isinstance(target_charges, type(self)):\n-      if not np.all([\n-          a == b for a, b in zip(self.charge_types, target_charges.charge_types)\n-      ]):\n-        raise TypeError(\n-            \"isin only callable for equal charge types, found {} and {}\".format(\n-                self.charge_types, target_charges.charge_types))\n-\n-      targets = target_charges.unique_charges\n-    else:\n-      if target_charges.ndim == 1:\n-        if target_charges.shape[0] == 0:\n-          raise ValueError(\"input to `isin` cannot be an empty np.ndarray\")\n-        targets = np.unique(target_charges, axis=0)[:, None]\n-      elif target_charges.ndim == 2:\n-        if target_charges.shape[0] == 0:\n-          raise ValueError(\"input to `isin` cannot be an empty np.ndarray\")\n-\n-        targets = np.unique(target_charges, axis=0)\n-      else:\n-        raise ValueError(\"targets.ndim has to be 1 or 2, found {}\".format(\n-            target_charges.ndim))\n-      if targets.shape[1] != self.num_symmetries:\n-        raise ValueError(\n-            \"target_charges.shape[0]={} is different from \"\n-            \"self.num_symmetries = {}\"\n-            .format(targets.shape[0], self.num_symmetries))\n-\n-    tmp = self.unique_charges[:, :, None] == targets.T[None, :, :]\n-    #pylint: disable=no-member\n-    inds = np.nonzero(\n-        np.logical_or.reduce(np.logical_and.reduce(tmp, axis=1), axis=1))[0]\n-\n-    return np.isin(self.charge_labels, inds)\n \n",
        "source_code_with_indent": "    obj = self.__new__(type(self))\n    labels = self.charge_labels[n]\n    unique_labels, new_labels = np.unique(labels, return_inverse=True)\n    if unique_labels.ndim == 0:\n      <IND>unique_labels = np.asarray(unique_labels)\n    <DED>unique_charges = self.unique_charges[unique_labels, :]\n    obj.__init__(unique_charges, new_labels, self.charge_types)\n    return obj\n\n  <DED>def isin(self, target_charges: Union[np.ndarray, \"BaseCharge\"]) -> np.ndarray:\n    <IND>\"\"\"\n    See also np.isin. \n    Returns an np.ndarray of `dtype=bool`, with `True` at all linear positions\n    where `self` is in `target_charges`, and `False` everywhere else.\n    Args:\n      target_charges: A `BaseCharge` object.\n    Returns:\n      np.ndarray: An array of boolean values.\n    \"\"\"\n    if isinstance(target_charges, type(self)):\n      <IND>if not np.all([\n          a == b for a, b in zip(self.charge_types, target_charges.charge_types)\n      ]):\n        <IND>raise TypeError(\n            \"isin only callable for equal charge types, found {} and {}\".format(\n                self.charge_types, target_charges.charge_types))\n\n      <DED>targets = target_charges.unique_charges\n    <DED>else:\n      <IND>if target_charges.ndim == 1:\n        <IND>if target_charges.shape[0] == 0:\n          <IND>raise ValueError(\"input to `isin` cannot be an empty np.ndarray\")\n        <DED>targets = np.unique(target_charges, axis=0)[:, None]\n      <DED>elif target_charges.ndim == 2:\n        <IND>if target_charges.shape[0] == 0:\n          <IND>raise ValueError(\"input to `isin` cannot be an empty np.ndarray\")\n\n        <DED>targets = np.unique(target_charges, axis=0)\n      <DED>else:\n        <IND>raise ValueError(\"targets.ndim has to be 1 or 2, found {}\".format(\n            target_charges.ndim))\n      <DED>if targets.shape[1] != self.num_symmetries:\n        <IND>raise ValueError(\n            \"target_charges.shape[0]={} is different from \"\n            \"self.num_symmetries = {}\"\n            .format(targets.shape[0], self.num_symmetries))\n\n    <DED><DED>tmp = self.unique_charges[:, :, None] == targets.T[None, :, :]\n    #pylint: disable=no-member\n    inds = np.nonzero(\n        np.logical_or.reduce(np.logical_and.reduce(tmp, axis=1), axis=1))[0]\n\n    return np.isin(self.charge_labels, inds)\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    obj = self.__new__(type(self))\n    if self._unique_charges is not None:\n      <IND>labels = self.charge_labels[n]\n      unique_labels, new_labels = unique(labels, return_inverse=True)\n      unique_charges = self.unique_charges[unique_labels, :]\n      obj.__init__(unique_charges, new_labels, self.charge_types)\n      return obj\n    <DED>obj.__init__(\n        self._charges[n, :], charge_labels=None, charge_types=self.charge_types)\n    return obj\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  }
]