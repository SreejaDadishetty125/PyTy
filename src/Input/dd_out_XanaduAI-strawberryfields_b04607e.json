[
  {
    "project": "XanaduAI/strawberryfields",
    "commit": "b04607eaef3c9e9258740447f48fbf999396fde9",
    "filename": "strawberryfields/result.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/XanaduAI-strawberryfields/strawberryfields/result.py",
    "file_hunks_size": 10,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "strawberryfields/result.py:71:40 Incompatible variable type [9]: ancilla_samples is declared to have type `Mapping[typing.Any, typing.Any]` but is used as type `None`.",
    "message": " ancilla_samples is declared to have type `Mapping[typing.Any, typing.Any]` but is used as type `None`.",
    "rule_id": "Incompatible variable type [9]",
    "warning_line_no": 71,
    "warning_line": "    def __init__(self, result: Mapping, ancilla_samples: Mapping = None) -> None:",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "import warnings\nfrom typing import Mapping, Optional\n\n",
        "source_code_len": 54,
        "target_code": "import warnings\nfrom typing import Mapping, Optional, List\n\n",
        "target_code_len": 60,
        "diff_format": "@@ -18,3 +18,3 @@\n import warnings\n-from typing import Mapping, Optional\n+from typing import Mapping, Optional, List\n \n",
        "source_code_with_indent": "import warnings\nfrom typing import Mapping, Optional\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "import warnings\nfrom typing import Mapping, Optional, List\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n    def __init__(self, result: Mapping, ancilla_samples: Mapping = None) -> None:\n        self._state = None\n        self._result = result\n        self._ancilla_samples = ancilla_samples\n\n",
        "source_code_len": 189,
        "target_code": "\n    def __init__(self, result: Mapping, **kwargs) -> None:\n        self._state = None\n        self._result = result\n\n        self._ancillae_samples = kwargs.get(\"ancillae_samples\", None)\n        self._samples_dict = kwargs.get(\"samples_dict\", None)\n\n",
        "target_code_len": 251,
        "diff_format": "@@ -70,6 +75,8 @@\n \n-    def __init__(self, result: Mapping, ancilla_samples: Mapping = None) -> None:\n+    def __init__(self, result: Mapping, **kwargs) -> None:\n         self._state = None\n         self._result = result\n-        self._ancilla_samples = ancilla_samples\n+\n+        self._ancillae_samples = kwargs.get(\"ancillae_samples\", None)\n+        self._samples_dict = kwargs.get(\"samples_dict\", None)\n \n",
        "source_code_with_indent": "\n    def __init__(self, result: Mapping, ancilla_samples: Mapping = None) -> None:\n        <IND>self._state = None\n        self._result = result\n        self._ancilla_samples = ancilla_samples\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n    def __init__(self, result: Mapping, **kwargs) -> None:\n        <IND>self._state = None\n        self._result = result\n\n        self._ancillae_samples = kwargs.get(\"ancillae_samples\", None)\n        self._samples_dict = kwargs.get(\"samples_dict\", None)\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n        Returns:\n            dict[int, list]: mode index associated with the list of measurement outcomes\n        \"\"\"\n        samples_dict = {key: val for key, val in self._result.items() if isinstance(key, int)}\n        return samples_dict\n\n    @property\n    def ancilla_samples(self) -> Optional[Mapping]:\n        \"\"\"All measurement samples from ancillary modes used for measurement-based\n",
        "source_code_len": 392,
        "target_code": "\n        .. note::\n\n            The samples dictionary may contain samples that are not present in\n            the samples array. In the samples array, each time a mode is measured\n            the prior measured sample on the same mode is replaced. The samples\n            dictionary, on the other hand, keeps _all_ measurements.\n\n        Returns:\n            Mapping[int, list]: mode index associated with the list of measurement outcomes\n        \"\"\"\n        return self._samples_dict\n\n    @property\n    def metadata(self) -> Mapping[str, np.ndarray]:\n        \"\"\"Metadata for the job results.\n\n        The metadata is considered to be everything contained in the raw results\n        except for the samples, which is stored under the \"output\" key.\n\n        Returns:\n            Mapping[str, ndarray]: dictionary containing job result metadata\n        \"\"\"\n        metadata = {key: val for key, val in self._result.items() if key != \"output\"}\n        return metadata\n\n    @property\n    def ancillae_samples(self) -> Optional[Mapping[int, List]]:\n        \"\"\"All measurement samples from ancillary modes used for measurement-based\n",
        "target_code_len": 1127,
        "diff_format": "@@ -105,10 +112,29 @@\n \n-        Returns:\n-            dict[int, list]: mode index associated with the list of measurement outcomes\n-        \"\"\"\n-        samples_dict = {key: val for key, val in self._result.items() if isinstance(key, int)}\n-        return samples_dict\n-\n-    @property\n-    def ancilla_samples(self) -> Optional[Mapping]:\n+        .. note::\n+\n+            The samples dictionary may contain samples that are not present in\n+            the samples array. In the samples array, each time a mode is measured\n+            the prior measured sample on the same mode is replaced. The samples\n+            dictionary, on the other hand, keeps _all_ measurements.\n+\n+        Returns:\n+            Mapping[int, list]: mode index associated with the list of measurement outcomes\n+        \"\"\"\n+        return self._samples_dict\n+\n+    @property\n+    def metadata(self) -> Mapping[str, np.ndarray]:\n+        \"\"\"Metadata for the job results.\n+\n+        The metadata is considered to be everything contained in the raw results\n+        except for the samples, which is stored under the \"output\" key.\n+\n+        Returns:\n+            Mapping[str, ndarray]: dictionary containing job result metadata\n+        \"\"\"\n+        metadata = {key: val for key, val in self._result.items() if key != \"output\"}\n+        return metadata\n+\n+    @property\n+    def ancillae_samples(self) -> Optional[Mapping[int, List]]:\n         \"\"\"All measurement samples from ancillary modes used for measurement-based\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\n        samples_dict = {key: val for key, val in self._result.items() if isinstance(key, int)}\n        return samples_dict\n\n    <DED>@property\n    def ancilla_samples(self) -> Optional[Mapping]:\n        <IND>",
        "target_code_with_indent": "\n        return self._samples_dict\n\n    <DED>@property\n    def metadata(self) -> Mapping[str, np.ndarray]:\n        <IND>\"\"\"Metadata for the job results.\n\n        The metadata is considered to be everything contained in the raw results\n        except for the samples, which is stored under the \"output\" key.\n\n        Returns:\n            Mapping[str, ndarray]: dictionary containing job result metadata\n        \"\"\"\n        metadata = {key: val for key, val in self._result.items() if key != \"output\"}\n        return metadata\n\n    <DED>@property\n    def ancillae_samples(self) -> Optional[Mapping[int, List]]:\n        <IND>"
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "        Returns:\n            dict[int, list]: mode index associated with the list of ancilla\n            measurement outcomes\n        \"\"\"\n        return self._ancilla_samples\n\n",
        "source_code_len": 176,
        "target_code": "        Returns:\n            Mapping[int, list]: mode index associated with the list of ancilla\n            measurement outcomes\n        \"\"\"\n        return self._ancillae_samples\n\n",
        "target_code_len": 180,
        "diff_format": "@@ -121,6 +147,6 @@\n         Returns:\n-            dict[int, list]: mode index associated with the list of ancilla\n+            Mapping[int, list]: mode index associated with the list of ancilla\n             measurement outcomes\n         \"\"\"\n-        return self._ancilla_samples\n+        return self._ancillae_samples\n \n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\n        return self._ancilla_samples\n\n",
        "target_code_with_indent": "\n        return self._ancillae_samples\n\n"
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n            if self.ancilla_samples is not None:\n                ancilla_modes = 0\n                for i in self.ancilla_samples.keys():\n                    ancilla_modes += len(self.ancilla_samples[i])\n                return (\n                    f\"<Result: shots={shots}, num_modes={modes}, num_ancillae={ancilla_modes}, \"\n                    f\"contains state={self._state is not None}>\"\n",
        "source_code_len": 391,
        "target_code": "\n            if self.ancillae_samples is not None:\n                ancillae_modes = 0\n                for i in self.ancillae_samples.keys():\n                    ancillae_modes += len(self.ancillae_samples[i])\n                return (\n                    f\"<Result: shots={shots}, num_modes={modes}, num_ancillae={ancillae_modes}, \"\n                    f\"contains state={self._state is not None}>\"\n",
        "target_code_len": 397,
        "diff_format": "@@ -154,8 +199,8 @@\n \n-            if self.ancilla_samples is not None:\n-                ancilla_modes = 0\n-                for i in self.ancilla_samples.keys():\n-                    ancilla_modes += len(self.ancilla_samples[i])\n+            if self.ancillae_samples is not None:\n+                ancillae_modes = 0\n+                for i in self.ancillae_samples.keys():\n+                    ancillae_modes += len(self.ancillae_samples[i])\n                 return (\n-                    f\"<Result: shots={shots}, num_modes={modes}, num_ancillae={ancilla_modes}, \"\n+                    f\"<Result: shots={shots}, num_modes={modes}, num_ancillae={ancillae_modes}, \"\n                     f\"contains state={self._state is not None}>\"\n",
        "source_code_with_indent": "\n            if self.ancilla_samples is not None:\n                <IND>ancilla_modes = 0\n                for i in self.ancilla_samples.keys():\n                    <IND>ancilla_modes += len(self.ancilla_samples[i])\n                <DED>return (\n                    f\"<Result: shots={shots}, num_modes={modes}, num_ancillae={ancilla_modes}, \"\n                    f\"contains state={self._state is not None}>\"\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n            if self.ancillae_samples is not None:\n                <IND>ancillae_modes = 0\n                for i in self.ancillae_samples.keys():\n                    <IND>ancillae_modes += len(self.ancillae_samples[i])\n                <DED>return (\n                    f\"<Result: shots={shots}, num_modes={modes}, num_ancillae={ancillae_modes}, \"\n                    f\"contains state={self._state is not None}>\"\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  }
]