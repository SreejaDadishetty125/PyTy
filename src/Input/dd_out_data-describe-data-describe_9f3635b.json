[
  {
    "project": "data-describe/data-describe",
    "commit": "9f3635b1cc00a3c03b17ea2f15f75248b5b3726a",
    "filename": "data_describe/core/clusters.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/data-describe-data-describe/data_describe/core/clustering.py",
    "file_hunks_size": 17,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": true,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "data_describe/core/clusters.py:84:8 Incompatible variable type [9]: clusters is declared to have type `List[int]` but is used as type `None`.",
    "message": " clusters is declared to have type `List[int]` but is used as type `None`.",
    "rule_id": "Incompatible variable type [9]",
    "warning_line_no": 84,
    "warning_line": "        clusters: List[int] = None,",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": true,
        "has_suppression": false,
        "source_code": "\nclass ClusterWidget(BaseWidget):\n    \"\"\"Interface for collecting additional information about the clustering.\"\"\"\n\n    def __init__(\n        self,\n        clusters: List[int] = None,\n        method: str = None,\n        estimator=None,\n        input_data=None,\n        scaled_data=None,\n        viz_data=None,\n        dim_method: str = None,\n        reductor=None,\n        xlabel: str = None,\n        ylabel: str = None,\n        **kwargs,\n    ):\n        \"\"\"Cluster Analysis.\n\n        Args:\n            clusters (List[int], optional): The predicted cluster labels\n            method (str): The clustering algorithm\n            estimator: The clustering estimator\n            input_data: The input data\n            scaled_data: The data after applying standardization\n            viz_data: The data used for the default visualization i.e. reduced to 2 dimensions\n            dim_method (str): The algorithm used for dimensionality reduction\n            reductor: The dimensionality reduction estimator\n            xlabel (str): The x-axis label for the cluster plot\n            ylabel (str): The y-axis label for the cluster plot\n        \"\"\"\n        super(ClusterWidget, self).__init__(**kwargs)\n        self.clusters = clusters\n        self.method = method\n        self.estimator = estimator\n        self.input_data = input_data\n        self.scaled_data = scaled_data\n        self.viz_data = viz_data\n        self.dim_method = dim_method\n        self.reductor = reductor\n        self.xlabel = xlabel\n        self.ylabel = ylabel\n\n    def __str__(self):\n        return \"data-describe Cluster Widget\"\n\n    def show(self, viz_backend=None, **kwargs):\n        \"\"\"Show the cluster plot.\"\"\"\n        backend = viz_backend or self.viz_backend\n\n        if self.viz_data is None:\n            raise ValueError(\"Could not find data to visualize.\")\n\n        return _get_viz_backend(backend).viz_cluster(\n            self.viz_data,\n            method=self.method,\n            xlabel=self.xlabel,\n            ylabel=self.ylabel,\n            **kwargs,\n        )\n\n\nclass KmeansClusterWidget(ClusterWidget):\n    \"\"\"Interface for collecting additional information about the k-Means clustering.\"\"\"\n\n    def __init__(\n        self,\n        n_clusters=None,\n        search=False,\n        cluster_range=None,\n        metric=None,\n        scores=None,\n        **kwargs,\n    ):\n        \"\"\"Mandatory parameters.\n\n        Args:\n            clusters (List[int], optional): The predicted cluster labels.\n            estimator (optional): The cluster estimator object.\n            n_clusters (int, optional): The number of clusters (k) used in the final clustering fit.\n            search (bool, optional): If True, a search was performed for optimal n_clusters.\n            cluster_range (Tuple[int, int], optional): The range of clusters searched as (min_cluster, max_cluster).\n            metric (str, optional): The metric used to evaluate the cluster search.\n            scores: The metric scores in cluster search.\n        \"\"\"\n        super(KmeansClusterWidget, self).__init__(**kwargs)\n        self.method = \"kmeans\"\n        self.n_clusters = n_clusters\n        self.search = search\n        self.cluster_range = cluster_range\n        self.metric = metric\n        self.scores = scores\n\n    def cluster_search_plot(self, viz_backend=None, **kwargs):\n        \"\"\"Shows the results of cluster search.\n\n        Cluster search attempts to find an optimal n_clusters by maximizing on some criterion.\n        This plot shows a line plot of each n_cluster that was attempted and its score.\n\n        Args:\n            viz_backend: The visualization backend.\n            **kwargs: Additional keyword arguments to pass to the visualization backend.\n\n        Returns:\n            The plot\n        \"\"\"\n        if not self.search:\n            raise ValueError(\n                \"Cluster search plot is not applicable when n_cluster is explicitly selected\"\n            )\n\n        return _get_viz_backend(viz_backend).viz_cluster_search_plot(\n            self.cluster_range, self.scores, self.metric, **kwargs\n        )\n\n\nclass HDBSCANClusterWidget(ClusterWidget):\n    \"\"\"Interface for collecting additional information about the HDBSCAN clustering.\"\"\"\n\n    def __init__(self, **kwargs):\n        \"\"\"Mandatory parameters.\n\n        Args:\n            clusters (List[int], optional): The predicted cluster labels.\n            estimator (optional): The HDBSCAN estimator object.\n        \"\"\"\n        super(HDBSCANClusterWidget, self).__init__(**kwargs)\n        self.method = \"hdbscan\"\n\n\ndef _pandas_compute_cluster(data, method: str, **kwargs):\n",
        "source_code_len": 4595,
        "target_code": "\ndef _pandas_compute_cluster(data, method: str, **kwargs):\n",
        "target_code_len": 59,
        "diff_format": "@@ -78,132 +222,2 @@\n \n-class ClusterWidget(BaseWidget):\n-    \"\"\"Interface for collecting additional information about the clustering.\"\"\"\n-\n-    def __init__(\n-        self,\n-        clusters: List[int] = None,\n-        method: str = None,\n-        estimator=None,\n-        input_data=None,\n-        scaled_data=None,\n-        viz_data=None,\n-        dim_method: str = None,\n-        reductor=None,\n-        xlabel: str = None,\n-        ylabel: str = None,\n-        **kwargs,\n-    ):\n-        \"\"\"Cluster Analysis.\n-\n-        Args:\n-            clusters (List[int], optional): The predicted cluster labels\n-            method (str): The clustering algorithm\n-            estimator: The clustering estimator\n-            input_data: The input data\n-            scaled_data: The data after applying standardization\n-            viz_data: The data used for the default visualization i.e. reduced to 2 dimensions\n-            dim_method (str): The algorithm used for dimensionality reduction\n-            reductor: The dimensionality reduction estimator\n-            xlabel (str): The x-axis label for the cluster plot\n-            ylabel (str): The y-axis label for the cluster plot\n-        \"\"\"\n-        super(ClusterWidget, self).__init__(**kwargs)\n-        self.clusters = clusters\n-        self.method = method\n-        self.estimator = estimator\n-        self.input_data = input_data\n-        self.scaled_data = scaled_data\n-        self.viz_data = viz_data\n-        self.dim_method = dim_method\n-        self.reductor = reductor\n-        self.xlabel = xlabel\n-        self.ylabel = ylabel\n-\n-    def __str__(self):\n-        return \"data-describe Cluster Widget\"\n-\n-    def show(self, viz_backend=None, **kwargs):\n-        \"\"\"Show the cluster plot.\"\"\"\n-        backend = viz_backend or self.viz_backend\n-\n-        if self.viz_data is None:\n-            raise ValueError(\"Could not find data to visualize.\")\n-\n-        return _get_viz_backend(backend).viz_cluster(\n-            self.viz_data,\n-            method=self.method,\n-            xlabel=self.xlabel,\n-            ylabel=self.ylabel,\n-            **kwargs,\n-        )\n-\n-\n-class KmeansClusterWidget(ClusterWidget):\n-    \"\"\"Interface for collecting additional information about the k-Means clustering.\"\"\"\n-\n-    def __init__(\n-        self,\n-        n_clusters=None,\n-        search=False,\n-        cluster_range=None,\n-        metric=None,\n-        scores=None,\n-        **kwargs,\n-    ):\n-        \"\"\"Mandatory parameters.\n-\n-        Args:\n-            clusters (List[int], optional): The predicted cluster labels.\n-            estimator (optional): The cluster estimator object.\n-            n_clusters (int, optional): The number of clusters (k) used in the final clustering fit.\n-            search (bool, optional): If True, a search was performed for optimal n_clusters.\n-            cluster_range (Tuple[int, int], optional): The range of clusters searched as (min_cluster, max_cluster).\n-            metric (str, optional): The metric used to evaluate the cluster search.\n-            scores: The metric scores in cluster search.\n-        \"\"\"\n-        super(KmeansClusterWidget, self).__init__(**kwargs)\n-        self.method = \"kmeans\"\n-        self.n_clusters = n_clusters\n-        self.search = search\n-        self.cluster_range = cluster_range\n-        self.metric = metric\n-        self.scores = scores\n-\n-    def cluster_search_plot(self, viz_backend=None, **kwargs):\n-        \"\"\"Shows the results of cluster search.\n-\n-        Cluster search attempts to find an optimal n_clusters by maximizing on some criterion.\n-        This plot shows a line plot of each n_cluster that was attempted and its score.\n-\n-        Args:\n-            viz_backend: The visualization backend.\n-            **kwargs: Additional keyword arguments to pass to the visualization backend.\n-\n-        Returns:\n-            The plot\n-        \"\"\"\n-        if not self.search:\n-            raise ValueError(\n-                \"Cluster search plot is not applicable when n_cluster is explicitly selected\"\n-            )\n-\n-        return _get_viz_backend(viz_backend).viz_cluster_search_plot(\n-            self.cluster_range, self.scores, self.metric, **kwargs\n-        )\n-\n-\n-class HDBSCANClusterWidget(ClusterWidget):\n-    \"\"\"Interface for collecting additional information about the HDBSCAN clustering.\"\"\"\n-\n-    def __init__(self, **kwargs):\n-        \"\"\"Mandatory parameters.\n-\n-        Args:\n-            clusters (List[int], optional): The predicted cluster labels.\n-            estimator (optional): The HDBSCAN estimator object.\n-        \"\"\"\n-        super(HDBSCANClusterWidget, self).__init__(**kwargs)\n-        self.method = \"hdbscan\"\n-\n-\n def _pandas_compute_cluster(data, method: str, **kwargs):\n",
        "source_code_with_indent": "\n<DED>class ClusterWidget(BaseWidget):\n    <IND>\"\"\"Interface for collecting additional information about the clustering.\"\"\"\n\n    def __init__(\n        self,\n        clusters: List[int] = None,\n        method: str = None,\n        estimator=None,\n        input_data=None,\n        scaled_data=None,\n        viz_data=None,\n        dim_method: str = None,\n        reductor=None,\n        xlabel: str = None,\n        ylabel: str = None,\n        **kwargs,\n    ):\n        <IND>\"\"\"Cluster Analysis.\n\n        Args:\n            clusters (List[int], optional): The predicted cluster labels\n            method (str): The clustering algorithm\n            estimator: The clustering estimator\n            input_data: The input data\n            scaled_data: The data after applying standardization\n            viz_data: The data used for the default visualization i.e. reduced to 2 dimensions\n            dim_method (str): The algorithm used for dimensionality reduction\n            reductor: The dimensionality reduction estimator\n            xlabel (str): The x-axis label for the cluster plot\n            ylabel (str): The y-axis label for the cluster plot\n        \"\"\"\n        super(ClusterWidget, self).__init__(**kwargs)\n        self.clusters = clusters\n        self.method = method\n        self.estimator = estimator\n        self.input_data = input_data\n        self.scaled_data = scaled_data\n        self.viz_data = viz_data\n        self.dim_method = dim_method\n        self.reductor = reductor\n        self.xlabel = xlabel\n        self.ylabel = ylabel\n\n    <DED>def __str__(self):\n        <IND>return \"data-describe Cluster Widget\"\n\n    <DED>def show(self, viz_backend=None, **kwargs):\n        <IND>\"\"\"Show the cluster plot.\"\"\"\n        backend = viz_backend or self.viz_backend\n\n        if self.viz_data is None:\n            <IND>raise ValueError(\"Could not find data to visualize.\")\n\n        <DED>return _get_viz_backend(backend).viz_cluster(\n            self.viz_data,\n            method=self.method,\n            xlabel=self.xlabel,\n            ylabel=self.ylabel,\n            **kwargs,\n        )\n\n\n<DED><DED>class KmeansClusterWidget(ClusterWidget):\n    <IND>\"\"\"Interface for collecting additional information about the k-Means clustering.\"\"\"\n\n    def __init__(\n        self,\n        n_clusters=None,\n        search=False,\n        cluster_range=None,\n        metric=None,\n        scores=None,\n        **kwargs,\n    ):\n        <IND>\"\"\"Mandatory parameters.\n\n        Args:\n            clusters (List[int], optional): The predicted cluster labels.\n            estimator (optional): The cluster estimator object.\n            n_clusters (int, optional): The number of clusters (k) used in the final clustering fit.\n            search (bool, optional): If True, a search was performed for optimal n_clusters.\n            cluster_range (Tuple[int, int], optional): The range of clusters searched as (min_cluster, max_cluster).\n            metric (str, optional): The metric used to evaluate the cluster search.\n            scores: The metric scores in cluster search.\n        \"\"\"\n        super(KmeansClusterWidget, self).__init__(**kwargs)\n        self.method = \"kmeans\"\n        self.n_clusters = n_clusters\n        self.search = search\n        self.cluster_range = cluster_range\n        self.metric = metric\n        self.scores = scores\n\n    <DED>def cluster_search_plot(self, viz_backend=None, **kwargs):\n        <IND>\"\"\"Shows the results of cluster search.\n\n        Cluster search attempts to find an optimal n_clusters by maximizing on some criterion.\n        This plot shows a line plot of each n_cluster that was attempted and its score.\n\n        Args:\n            viz_backend: The visualization backend.\n            **kwargs: Additional keyword arguments to pass to the visualization backend.\n\n        Returns:\n            The plot\n        \"\"\"\n        if not self.search:\n            <IND>raise ValueError(\n                \"Cluster search plot is not applicable when n_cluster is explicitly selected\"\n            )\n\n        <DED>return _get_viz_backend(viz_backend).viz_cluster_search_plot(\n            self.cluster_range, self.scores, self.metric, **kwargs\n        )\n\n\n<DED><DED>class HDBSCANClusterWidget(ClusterWidget):\n    <IND>\"\"\"Interface for collecting additional information about the HDBSCAN clustering.\"\"\"\n\n    def __init__(self, **kwargs):\n        <IND>\"\"\"Mandatory parameters.\n\n        Args:\n            clusters (List[int], optional): The predicted cluster labels.\n            estimator (optional): The HDBSCAN estimator object.\n        \"\"\"\n        super(HDBSCANClusterWidget, self).__init__(**kwargs)\n        self.method = \"hdbscan\"\n\n\n<DED><DED>def _pandas_compute_cluster(data, method: str, **kwargs):\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n<DED>def _pandas_compute_cluster(data, method: str, **kwargs):\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "data-describe/data-describe",
    "commit": "9f3635b1cc00a3c03b17ea2f15f75248b5b3726a",
    "filename": "data_describe/core/clusters.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/data-describe-data-describe/data_describe/core/clustering.py",
    "file_hunks_size": 17,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": true,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "data_describe/core/clusters.py:85:8 Incompatible variable type [9]: method is declared to have type `str` but is used as type `None`.",
    "message": " method is declared to have type `str` but is used as type `None`.",
    "rule_id": "Incompatible variable type [9]",
    "warning_line_no": 85,
    "warning_line": "        method: str = None,",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": true,
        "has_suppression": false,
        "source_code": "\nclass ClusterWidget(BaseWidget):\n    \"\"\"Interface for collecting additional information about the clustering.\"\"\"\n\n    def __init__(\n        self,\n        clusters: List[int] = None,\n        method: str = None,\n        estimator=None,\n        input_data=None,\n        scaled_data=None,\n        viz_data=None,\n        dim_method: str = None,\n        reductor=None,\n        xlabel: str = None,\n        ylabel: str = None,\n        **kwargs,\n    ):\n        \"\"\"Cluster Analysis.\n\n        Args:\n            clusters (List[int], optional): The predicted cluster labels\n            method (str): The clustering algorithm\n            estimator: The clustering estimator\n            input_data: The input data\n            scaled_data: The data after applying standardization\n            viz_data: The data used for the default visualization i.e. reduced to 2 dimensions\n            dim_method (str): The algorithm used for dimensionality reduction\n            reductor: The dimensionality reduction estimator\n            xlabel (str): The x-axis label for the cluster plot\n            ylabel (str): The y-axis label for the cluster plot\n        \"\"\"\n        super(ClusterWidget, self).__init__(**kwargs)\n        self.clusters = clusters\n        self.method = method\n        self.estimator = estimator\n        self.input_data = input_data\n        self.scaled_data = scaled_data\n        self.viz_data = viz_data\n        self.dim_method = dim_method\n        self.reductor = reductor\n        self.xlabel = xlabel\n        self.ylabel = ylabel\n\n    def __str__(self):\n        return \"data-describe Cluster Widget\"\n\n    def show(self, viz_backend=None, **kwargs):\n        \"\"\"Show the cluster plot.\"\"\"\n        backend = viz_backend or self.viz_backend\n\n        if self.viz_data is None:\n            raise ValueError(\"Could not find data to visualize.\")\n\n        return _get_viz_backend(backend).viz_cluster(\n            self.viz_data,\n            method=self.method,\n            xlabel=self.xlabel,\n            ylabel=self.ylabel,\n            **kwargs,\n        )\n\n\nclass KmeansClusterWidget(ClusterWidget):\n    \"\"\"Interface for collecting additional information about the k-Means clustering.\"\"\"\n\n    def __init__(\n        self,\n        n_clusters=None,\n        search=False,\n        cluster_range=None,\n        metric=None,\n        scores=None,\n        **kwargs,\n    ):\n        \"\"\"Mandatory parameters.\n\n        Args:\n            clusters (List[int], optional): The predicted cluster labels.\n            estimator (optional): The cluster estimator object.\n            n_clusters (int, optional): The number of clusters (k) used in the final clustering fit.\n            search (bool, optional): If True, a search was performed for optimal n_clusters.\n            cluster_range (Tuple[int, int], optional): The range of clusters searched as (min_cluster, max_cluster).\n            metric (str, optional): The metric used to evaluate the cluster search.\n            scores: The metric scores in cluster search.\n        \"\"\"\n        super(KmeansClusterWidget, self).__init__(**kwargs)\n        self.method = \"kmeans\"\n        self.n_clusters = n_clusters\n        self.search = search\n        self.cluster_range = cluster_range\n        self.metric = metric\n        self.scores = scores\n\n    def cluster_search_plot(self, viz_backend=None, **kwargs):\n        \"\"\"Shows the results of cluster search.\n\n        Cluster search attempts to find an optimal n_clusters by maximizing on some criterion.\n        This plot shows a line plot of each n_cluster that was attempted and its score.\n\n        Args:\n            viz_backend: The visualization backend.\n            **kwargs: Additional keyword arguments to pass to the visualization backend.\n\n        Returns:\n            The plot\n        \"\"\"\n        if not self.search:\n            raise ValueError(\n                \"Cluster search plot is not applicable when n_cluster is explicitly selected\"\n            )\n\n        return _get_viz_backend(viz_backend).viz_cluster_search_plot(\n            self.cluster_range, self.scores, self.metric, **kwargs\n        )\n\n\nclass HDBSCANClusterWidget(ClusterWidget):\n    \"\"\"Interface for collecting additional information about the HDBSCAN clustering.\"\"\"\n\n    def __init__(self, **kwargs):\n        \"\"\"Mandatory parameters.\n\n        Args:\n            clusters (List[int], optional): The predicted cluster labels.\n            estimator (optional): The HDBSCAN estimator object.\n        \"\"\"\n        super(HDBSCANClusterWidget, self).__init__(**kwargs)\n        self.method = \"hdbscan\"\n\n\ndef _pandas_compute_cluster(data, method: str, **kwargs):\n",
        "source_code_len": 4595,
        "target_code": "\ndef _pandas_compute_cluster(data, method: str, **kwargs):\n",
        "target_code_len": 59,
        "diff_format": "@@ -78,132 +222,2 @@\n \n-class ClusterWidget(BaseWidget):\n-    \"\"\"Interface for collecting additional information about the clustering.\"\"\"\n-\n-    def __init__(\n-        self,\n-        clusters: List[int] = None,\n-        method: str = None,\n-        estimator=None,\n-        input_data=None,\n-        scaled_data=None,\n-        viz_data=None,\n-        dim_method: str = None,\n-        reductor=None,\n-        xlabel: str = None,\n-        ylabel: str = None,\n-        **kwargs,\n-    ):\n-        \"\"\"Cluster Analysis.\n-\n-        Args:\n-            clusters (List[int], optional): The predicted cluster labels\n-            method (str): The clustering algorithm\n-            estimator: The clustering estimator\n-            input_data: The input data\n-            scaled_data: The data after applying standardization\n-            viz_data: The data used for the default visualization i.e. reduced to 2 dimensions\n-            dim_method (str): The algorithm used for dimensionality reduction\n-            reductor: The dimensionality reduction estimator\n-            xlabel (str): The x-axis label for the cluster plot\n-            ylabel (str): The y-axis label for the cluster plot\n-        \"\"\"\n-        super(ClusterWidget, self).__init__(**kwargs)\n-        self.clusters = clusters\n-        self.method = method\n-        self.estimator = estimator\n-        self.input_data = input_data\n-        self.scaled_data = scaled_data\n-        self.viz_data = viz_data\n-        self.dim_method = dim_method\n-        self.reductor = reductor\n-        self.xlabel = xlabel\n-        self.ylabel = ylabel\n-\n-    def __str__(self):\n-        return \"data-describe Cluster Widget\"\n-\n-    def show(self, viz_backend=None, **kwargs):\n-        \"\"\"Show the cluster plot.\"\"\"\n-        backend = viz_backend or self.viz_backend\n-\n-        if self.viz_data is None:\n-            raise ValueError(\"Could not find data to visualize.\")\n-\n-        return _get_viz_backend(backend).viz_cluster(\n-            self.viz_data,\n-            method=self.method,\n-            xlabel=self.xlabel,\n-            ylabel=self.ylabel,\n-            **kwargs,\n-        )\n-\n-\n-class KmeansClusterWidget(ClusterWidget):\n-    \"\"\"Interface for collecting additional information about the k-Means clustering.\"\"\"\n-\n-    def __init__(\n-        self,\n-        n_clusters=None,\n-        search=False,\n-        cluster_range=None,\n-        metric=None,\n-        scores=None,\n-        **kwargs,\n-    ):\n-        \"\"\"Mandatory parameters.\n-\n-        Args:\n-            clusters (List[int], optional): The predicted cluster labels.\n-            estimator (optional): The cluster estimator object.\n-            n_clusters (int, optional): The number of clusters (k) used in the final clustering fit.\n-            search (bool, optional): If True, a search was performed for optimal n_clusters.\n-            cluster_range (Tuple[int, int], optional): The range of clusters searched as (min_cluster, max_cluster).\n-            metric (str, optional): The metric used to evaluate the cluster search.\n-            scores: The metric scores in cluster search.\n-        \"\"\"\n-        super(KmeansClusterWidget, self).__init__(**kwargs)\n-        self.method = \"kmeans\"\n-        self.n_clusters = n_clusters\n-        self.search = search\n-        self.cluster_range = cluster_range\n-        self.metric = metric\n-        self.scores = scores\n-\n-    def cluster_search_plot(self, viz_backend=None, **kwargs):\n-        \"\"\"Shows the results of cluster search.\n-\n-        Cluster search attempts to find an optimal n_clusters by maximizing on some criterion.\n-        This plot shows a line plot of each n_cluster that was attempted and its score.\n-\n-        Args:\n-            viz_backend: The visualization backend.\n-            **kwargs: Additional keyword arguments to pass to the visualization backend.\n-\n-        Returns:\n-            The plot\n-        \"\"\"\n-        if not self.search:\n-            raise ValueError(\n-                \"Cluster search plot is not applicable when n_cluster is explicitly selected\"\n-            )\n-\n-        return _get_viz_backend(viz_backend).viz_cluster_search_plot(\n-            self.cluster_range, self.scores, self.metric, **kwargs\n-        )\n-\n-\n-class HDBSCANClusterWidget(ClusterWidget):\n-    \"\"\"Interface for collecting additional information about the HDBSCAN clustering.\"\"\"\n-\n-    def __init__(self, **kwargs):\n-        \"\"\"Mandatory parameters.\n-\n-        Args:\n-            clusters (List[int], optional): The predicted cluster labels.\n-            estimator (optional): The HDBSCAN estimator object.\n-        \"\"\"\n-        super(HDBSCANClusterWidget, self).__init__(**kwargs)\n-        self.method = \"hdbscan\"\n-\n-\n def _pandas_compute_cluster(data, method: str, **kwargs):\n",
        "source_code_with_indent": "\n<DED>class ClusterWidget(BaseWidget):\n    <IND>\"\"\"Interface for collecting additional information about the clustering.\"\"\"\n\n    def __init__(\n        self,\n        clusters: List[int] = None,\n        method: str = None,\n        estimator=None,\n        input_data=None,\n        scaled_data=None,\n        viz_data=None,\n        dim_method: str = None,\n        reductor=None,\n        xlabel: str = None,\n        ylabel: str = None,\n        **kwargs,\n    ):\n        <IND>\"\"\"Cluster Analysis.\n\n        Args:\n            clusters (List[int], optional): The predicted cluster labels\n            method (str): The clustering algorithm\n            estimator: The clustering estimator\n            input_data: The input data\n            scaled_data: The data after applying standardization\n            viz_data: The data used for the default visualization i.e. reduced to 2 dimensions\n            dim_method (str): The algorithm used for dimensionality reduction\n            reductor: The dimensionality reduction estimator\n            xlabel (str): The x-axis label for the cluster plot\n            ylabel (str): The y-axis label for the cluster plot\n        \"\"\"\n        super(ClusterWidget, self).__init__(**kwargs)\n        self.clusters = clusters\n        self.method = method\n        self.estimator = estimator\n        self.input_data = input_data\n        self.scaled_data = scaled_data\n        self.viz_data = viz_data\n        self.dim_method = dim_method\n        self.reductor = reductor\n        self.xlabel = xlabel\n        self.ylabel = ylabel\n\n    <DED>def __str__(self):\n        <IND>return \"data-describe Cluster Widget\"\n\n    <DED>def show(self, viz_backend=None, **kwargs):\n        <IND>\"\"\"Show the cluster plot.\"\"\"\n        backend = viz_backend or self.viz_backend\n\n        if self.viz_data is None:\n            <IND>raise ValueError(\"Could not find data to visualize.\")\n\n        <DED>return _get_viz_backend(backend).viz_cluster(\n            self.viz_data,\n            method=self.method,\n            xlabel=self.xlabel,\n            ylabel=self.ylabel,\n            **kwargs,\n        )\n\n\n<DED><DED>class KmeansClusterWidget(ClusterWidget):\n    <IND>\"\"\"Interface for collecting additional information about the k-Means clustering.\"\"\"\n\n    def __init__(\n        self,\n        n_clusters=None,\n        search=False,\n        cluster_range=None,\n        metric=None,\n        scores=None,\n        **kwargs,\n    ):\n        <IND>\"\"\"Mandatory parameters.\n\n        Args:\n            clusters (List[int], optional): The predicted cluster labels.\n            estimator (optional): The cluster estimator object.\n            n_clusters (int, optional): The number of clusters (k) used in the final clustering fit.\n            search (bool, optional): If True, a search was performed for optimal n_clusters.\n            cluster_range (Tuple[int, int], optional): The range of clusters searched as (min_cluster, max_cluster).\n            metric (str, optional): The metric used to evaluate the cluster search.\n            scores: The metric scores in cluster search.\n        \"\"\"\n        super(KmeansClusterWidget, self).__init__(**kwargs)\n        self.method = \"kmeans\"\n        self.n_clusters = n_clusters\n        self.search = search\n        self.cluster_range = cluster_range\n        self.metric = metric\n        self.scores = scores\n\n    <DED>def cluster_search_plot(self, viz_backend=None, **kwargs):\n        <IND>\"\"\"Shows the results of cluster search.\n\n        Cluster search attempts to find an optimal n_clusters by maximizing on some criterion.\n        This plot shows a line plot of each n_cluster that was attempted and its score.\n\n        Args:\n            viz_backend: The visualization backend.\n            **kwargs: Additional keyword arguments to pass to the visualization backend.\n\n        Returns:\n            The plot\n        \"\"\"\n        if not self.search:\n            <IND>raise ValueError(\n                \"Cluster search plot is not applicable when n_cluster is explicitly selected\"\n            )\n\n        <DED>return _get_viz_backend(viz_backend).viz_cluster_search_plot(\n            self.cluster_range, self.scores, self.metric, **kwargs\n        )\n\n\n<DED><DED>class HDBSCANClusterWidget(ClusterWidget):\n    <IND>\"\"\"Interface for collecting additional information about the HDBSCAN clustering.\"\"\"\n\n    def __init__(self, **kwargs):\n        <IND>\"\"\"Mandatory parameters.\n\n        Args:\n            clusters (List[int], optional): The predicted cluster labels.\n            estimator (optional): The HDBSCAN estimator object.\n        \"\"\"\n        super(HDBSCANClusterWidget, self).__init__(**kwargs)\n        self.method = \"hdbscan\"\n\n\n<DED><DED>def _pandas_compute_cluster(data, method: str, **kwargs):\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n<DED>def _pandas_compute_cluster(data, method: str, **kwargs):\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "data-describe/data-describe",
    "commit": "9f3635b1cc00a3c03b17ea2f15f75248b5b3726a",
    "filename": "data_describe/core/clusters.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/data-describe-data-describe/data_describe/core/clustering.py",
    "file_hunks_size": 17,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": true,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "data_describe/core/clusters.py:90:8 Incompatible variable type [9]: dim_method is declared to have type `str` but is used as type `None`.",
    "message": " dim_method is declared to have type `str` but is used as type `None`.",
    "rule_id": "Incompatible variable type [9]",
    "warning_line_no": 90,
    "warning_line": "        dim_method: str = None,",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": true,
        "has_suppression": false,
        "source_code": "\nclass ClusterWidget(BaseWidget):\n    \"\"\"Interface for collecting additional information about the clustering.\"\"\"\n\n    def __init__(\n        self,\n        clusters: List[int] = None,\n        method: str = None,\n        estimator=None,\n        input_data=None,\n        scaled_data=None,\n        viz_data=None,\n        dim_method: str = None,\n        reductor=None,\n        xlabel: str = None,\n        ylabel: str = None,\n        **kwargs,\n    ):\n        \"\"\"Cluster Analysis.\n\n        Args:\n            clusters (List[int], optional): The predicted cluster labels\n            method (str): The clustering algorithm\n            estimator: The clustering estimator\n            input_data: The input data\n            scaled_data: The data after applying standardization\n            viz_data: The data used for the default visualization i.e. reduced to 2 dimensions\n            dim_method (str): The algorithm used for dimensionality reduction\n            reductor: The dimensionality reduction estimator\n            xlabel (str): The x-axis label for the cluster plot\n            ylabel (str): The y-axis label for the cluster plot\n        \"\"\"\n        super(ClusterWidget, self).__init__(**kwargs)\n        self.clusters = clusters\n        self.method = method\n        self.estimator = estimator\n        self.input_data = input_data\n        self.scaled_data = scaled_data\n        self.viz_data = viz_data\n        self.dim_method = dim_method\n        self.reductor = reductor\n        self.xlabel = xlabel\n        self.ylabel = ylabel\n\n    def __str__(self):\n        return \"data-describe Cluster Widget\"\n\n    def show(self, viz_backend=None, **kwargs):\n        \"\"\"Show the cluster plot.\"\"\"\n        backend = viz_backend or self.viz_backend\n\n        if self.viz_data is None:\n            raise ValueError(\"Could not find data to visualize.\")\n\n        return _get_viz_backend(backend).viz_cluster(\n            self.viz_data,\n            method=self.method,\n            xlabel=self.xlabel,\n            ylabel=self.ylabel,\n            **kwargs,\n        )\n\n\nclass KmeansClusterWidget(ClusterWidget):\n    \"\"\"Interface for collecting additional information about the k-Means clustering.\"\"\"\n\n    def __init__(\n        self,\n        n_clusters=None,\n        search=False,\n        cluster_range=None,\n        metric=None,\n        scores=None,\n        **kwargs,\n    ):\n        \"\"\"Mandatory parameters.\n\n        Args:\n            clusters (List[int], optional): The predicted cluster labels.\n            estimator (optional): The cluster estimator object.\n            n_clusters (int, optional): The number of clusters (k) used in the final clustering fit.\n            search (bool, optional): If True, a search was performed for optimal n_clusters.\n            cluster_range (Tuple[int, int], optional): The range of clusters searched as (min_cluster, max_cluster).\n            metric (str, optional): The metric used to evaluate the cluster search.\n            scores: The metric scores in cluster search.\n        \"\"\"\n        super(KmeansClusterWidget, self).__init__(**kwargs)\n        self.method = \"kmeans\"\n        self.n_clusters = n_clusters\n        self.search = search\n        self.cluster_range = cluster_range\n        self.metric = metric\n        self.scores = scores\n\n    def cluster_search_plot(self, viz_backend=None, **kwargs):\n        \"\"\"Shows the results of cluster search.\n\n        Cluster search attempts to find an optimal n_clusters by maximizing on some criterion.\n        This plot shows a line plot of each n_cluster that was attempted and its score.\n\n        Args:\n            viz_backend: The visualization backend.\n            **kwargs: Additional keyword arguments to pass to the visualization backend.\n\n        Returns:\n            The plot\n        \"\"\"\n        if not self.search:\n            raise ValueError(\n                \"Cluster search plot is not applicable when n_cluster is explicitly selected\"\n            )\n\n        return _get_viz_backend(viz_backend).viz_cluster_search_plot(\n            self.cluster_range, self.scores, self.metric, **kwargs\n        )\n\n\nclass HDBSCANClusterWidget(ClusterWidget):\n    \"\"\"Interface for collecting additional information about the HDBSCAN clustering.\"\"\"\n\n    def __init__(self, **kwargs):\n        \"\"\"Mandatory parameters.\n\n        Args:\n            clusters (List[int], optional): The predicted cluster labels.\n            estimator (optional): The HDBSCAN estimator object.\n        \"\"\"\n        super(HDBSCANClusterWidget, self).__init__(**kwargs)\n        self.method = \"hdbscan\"\n\n\ndef _pandas_compute_cluster(data, method: str, **kwargs):\n",
        "source_code_len": 4595,
        "target_code": "\ndef _pandas_compute_cluster(data, method: str, **kwargs):\n",
        "target_code_len": 59,
        "diff_format": "@@ -78,132 +222,2 @@\n \n-class ClusterWidget(BaseWidget):\n-    \"\"\"Interface for collecting additional information about the clustering.\"\"\"\n-\n-    def __init__(\n-        self,\n-        clusters: List[int] = None,\n-        method: str = None,\n-        estimator=None,\n-        input_data=None,\n-        scaled_data=None,\n-        viz_data=None,\n-        dim_method: str = None,\n-        reductor=None,\n-        xlabel: str = None,\n-        ylabel: str = None,\n-        **kwargs,\n-    ):\n-        \"\"\"Cluster Analysis.\n-\n-        Args:\n-            clusters (List[int], optional): The predicted cluster labels\n-            method (str): The clustering algorithm\n-            estimator: The clustering estimator\n-            input_data: The input data\n-            scaled_data: The data after applying standardization\n-            viz_data: The data used for the default visualization i.e. reduced to 2 dimensions\n-            dim_method (str): The algorithm used for dimensionality reduction\n-            reductor: The dimensionality reduction estimator\n-            xlabel (str): The x-axis label for the cluster plot\n-            ylabel (str): The y-axis label for the cluster plot\n-        \"\"\"\n-        super(ClusterWidget, self).__init__(**kwargs)\n-        self.clusters = clusters\n-        self.method = method\n-        self.estimator = estimator\n-        self.input_data = input_data\n-        self.scaled_data = scaled_data\n-        self.viz_data = viz_data\n-        self.dim_method = dim_method\n-        self.reductor = reductor\n-        self.xlabel = xlabel\n-        self.ylabel = ylabel\n-\n-    def __str__(self):\n-        return \"data-describe Cluster Widget\"\n-\n-    def show(self, viz_backend=None, **kwargs):\n-        \"\"\"Show the cluster plot.\"\"\"\n-        backend = viz_backend or self.viz_backend\n-\n-        if self.viz_data is None:\n-            raise ValueError(\"Could not find data to visualize.\")\n-\n-        return _get_viz_backend(backend).viz_cluster(\n-            self.viz_data,\n-            method=self.method,\n-            xlabel=self.xlabel,\n-            ylabel=self.ylabel,\n-            **kwargs,\n-        )\n-\n-\n-class KmeansClusterWidget(ClusterWidget):\n-    \"\"\"Interface for collecting additional information about the k-Means clustering.\"\"\"\n-\n-    def __init__(\n-        self,\n-        n_clusters=None,\n-        search=False,\n-        cluster_range=None,\n-        metric=None,\n-        scores=None,\n-        **kwargs,\n-    ):\n-        \"\"\"Mandatory parameters.\n-\n-        Args:\n-            clusters (List[int], optional): The predicted cluster labels.\n-            estimator (optional): The cluster estimator object.\n-            n_clusters (int, optional): The number of clusters (k) used in the final clustering fit.\n-            search (bool, optional): If True, a search was performed for optimal n_clusters.\n-            cluster_range (Tuple[int, int], optional): The range of clusters searched as (min_cluster, max_cluster).\n-            metric (str, optional): The metric used to evaluate the cluster search.\n-            scores: The metric scores in cluster search.\n-        \"\"\"\n-        super(KmeansClusterWidget, self).__init__(**kwargs)\n-        self.method = \"kmeans\"\n-        self.n_clusters = n_clusters\n-        self.search = search\n-        self.cluster_range = cluster_range\n-        self.metric = metric\n-        self.scores = scores\n-\n-    def cluster_search_plot(self, viz_backend=None, **kwargs):\n-        \"\"\"Shows the results of cluster search.\n-\n-        Cluster search attempts to find an optimal n_clusters by maximizing on some criterion.\n-        This plot shows a line plot of each n_cluster that was attempted and its score.\n-\n-        Args:\n-            viz_backend: The visualization backend.\n-            **kwargs: Additional keyword arguments to pass to the visualization backend.\n-\n-        Returns:\n-            The plot\n-        \"\"\"\n-        if not self.search:\n-            raise ValueError(\n-                \"Cluster search plot is not applicable when n_cluster is explicitly selected\"\n-            )\n-\n-        return _get_viz_backend(viz_backend).viz_cluster_search_plot(\n-            self.cluster_range, self.scores, self.metric, **kwargs\n-        )\n-\n-\n-class HDBSCANClusterWidget(ClusterWidget):\n-    \"\"\"Interface for collecting additional information about the HDBSCAN clustering.\"\"\"\n-\n-    def __init__(self, **kwargs):\n-        \"\"\"Mandatory parameters.\n-\n-        Args:\n-            clusters (List[int], optional): The predicted cluster labels.\n-            estimator (optional): The HDBSCAN estimator object.\n-        \"\"\"\n-        super(HDBSCANClusterWidget, self).__init__(**kwargs)\n-        self.method = \"hdbscan\"\n-\n-\n def _pandas_compute_cluster(data, method: str, **kwargs):\n",
        "source_code_with_indent": "\n<DED>class ClusterWidget(BaseWidget):\n    <IND>\"\"\"Interface for collecting additional information about the clustering.\"\"\"\n\n    def __init__(\n        self,\n        clusters: List[int] = None,\n        method: str = None,\n        estimator=None,\n        input_data=None,\n        scaled_data=None,\n        viz_data=None,\n        dim_method: str = None,\n        reductor=None,\n        xlabel: str = None,\n        ylabel: str = None,\n        **kwargs,\n    ):\n        <IND>\"\"\"Cluster Analysis.\n\n        Args:\n            clusters (List[int], optional): The predicted cluster labels\n            method (str): The clustering algorithm\n            estimator: The clustering estimator\n            input_data: The input data\n            scaled_data: The data after applying standardization\n            viz_data: The data used for the default visualization i.e. reduced to 2 dimensions\n            dim_method (str): The algorithm used for dimensionality reduction\n            reductor: The dimensionality reduction estimator\n            xlabel (str): The x-axis label for the cluster plot\n            ylabel (str): The y-axis label for the cluster plot\n        \"\"\"\n        super(ClusterWidget, self).__init__(**kwargs)\n        self.clusters = clusters\n        self.method = method\n        self.estimator = estimator\n        self.input_data = input_data\n        self.scaled_data = scaled_data\n        self.viz_data = viz_data\n        self.dim_method = dim_method\n        self.reductor = reductor\n        self.xlabel = xlabel\n        self.ylabel = ylabel\n\n    <DED>def __str__(self):\n        <IND>return \"data-describe Cluster Widget\"\n\n    <DED>def show(self, viz_backend=None, **kwargs):\n        <IND>\"\"\"Show the cluster plot.\"\"\"\n        backend = viz_backend or self.viz_backend\n\n        if self.viz_data is None:\n            <IND>raise ValueError(\"Could not find data to visualize.\")\n\n        <DED>return _get_viz_backend(backend).viz_cluster(\n            self.viz_data,\n            method=self.method,\n            xlabel=self.xlabel,\n            ylabel=self.ylabel,\n            **kwargs,\n        )\n\n\n<DED><DED>class KmeansClusterWidget(ClusterWidget):\n    <IND>\"\"\"Interface for collecting additional information about the k-Means clustering.\"\"\"\n\n    def __init__(\n        self,\n        n_clusters=None,\n        search=False,\n        cluster_range=None,\n        metric=None,\n        scores=None,\n        **kwargs,\n    ):\n        <IND>\"\"\"Mandatory parameters.\n\n        Args:\n            clusters (List[int], optional): The predicted cluster labels.\n            estimator (optional): The cluster estimator object.\n            n_clusters (int, optional): The number of clusters (k) used in the final clustering fit.\n            search (bool, optional): If True, a search was performed for optimal n_clusters.\n            cluster_range (Tuple[int, int], optional): The range of clusters searched as (min_cluster, max_cluster).\n            metric (str, optional): The metric used to evaluate the cluster search.\n            scores: The metric scores in cluster search.\n        \"\"\"\n        super(KmeansClusterWidget, self).__init__(**kwargs)\n        self.method = \"kmeans\"\n        self.n_clusters = n_clusters\n        self.search = search\n        self.cluster_range = cluster_range\n        self.metric = metric\n        self.scores = scores\n\n    <DED>def cluster_search_plot(self, viz_backend=None, **kwargs):\n        <IND>\"\"\"Shows the results of cluster search.\n\n        Cluster search attempts to find an optimal n_clusters by maximizing on some criterion.\n        This plot shows a line plot of each n_cluster that was attempted and its score.\n\n        Args:\n            viz_backend: The visualization backend.\n            **kwargs: Additional keyword arguments to pass to the visualization backend.\n\n        Returns:\n            The plot\n        \"\"\"\n        if not self.search:\n            <IND>raise ValueError(\n                \"Cluster search plot is not applicable when n_cluster is explicitly selected\"\n            )\n\n        <DED>return _get_viz_backend(viz_backend).viz_cluster_search_plot(\n            self.cluster_range, self.scores, self.metric, **kwargs\n        )\n\n\n<DED><DED>class HDBSCANClusterWidget(ClusterWidget):\n    <IND>\"\"\"Interface for collecting additional information about the HDBSCAN clustering.\"\"\"\n\n    def __init__(self, **kwargs):\n        <IND>\"\"\"Mandatory parameters.\n\n        Args:\n            clusters (List[int], optional): The predicted cluster labels.\n            estimator (optional): The HDBSCAN estimator object.\n        \"\"\"\n        super(HDBSCANClusterWidget, self).__init__(**kwargs)\n        self.method = \"hdbscan\"\n\n\n<DED><DED>def _pandas_compute_cluster(data, method: str, **kwargs):\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n<DED>def _pandas_compute_cluster(data, method: str, **kwargs):\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "data-describe/data-describe",
    "commit": "9f3635b1cc00a3c03b17ea2f15f75248b5b3726a",
    "filename": "data_describe/core/clusters.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/data-describe-data-describe/data_describe/core/clustering.py",
    "file_hunks_size": 17,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": true,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "data_describe/core/clusters.py:92:8 Incompatible variable type [9]: xlabel is declared to have type `str` but is used as type `None`.",
    "message": " xlabel is declared to have type `str` but is used as type `None`.",
    "rule_id": "Incompatible variable type [9]",
    "warning_line_no": 92,
    "warning_line": "        xlabel: str = None,",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": true,
        "has_suppression": false,
        "source_code": "\nclass ClusterWidget(BaseWidget):\n    \"\"\"Interface for collecting additional information about the clustering.\"\"\"\n\n    def __init__(\n        self,\n        clusters: List[int] = None,\n        method: str = None,\n        estimator=None,\n        input_data=None,\n        scaled_data=None,\n        viz_data=None,\n        dim_method: str = None,\n        reductor=None,\n        xlabel: str = None,\n        ylabel: str = None,\n        **kwargs,\n    ):\n        \"\"\"Cluster Analysis.\n\n        Args:\n            clusters (List[int], optional): The predicted cluster labels\n            method (str): The clustering algorithm\n            estimator: The clustering estimator\n            input_data: The input data\n            scaled_data: The data after applying standardization\n            viz_data: The data used for the default visualization i.e. reduced to 2 dimensions\n            dim_method (str): The algorithm used for dimensionality reduction\n            reductor: The dimensionality reduction estimator\n            xlabel (str): The x-axis label for the cluster plot\n            ylabel (str): The y-axis label for the cluster plot\n        \"\"\"\n        super(ClusterWidget, self).__init__(**kwargs)\n        self.clusters = clusters\n        self.method = method\n        self.estimator = estimator\n        self.input_data = input_data\n        self.scaled_data = scaled_data\n        self.viz_data = viz_data\n        self.dim_method = dim_method\n        self.reductor = reductor\n        self.xlabel = xlabel\n        self.ylabel = ylabel\n\n    def __str__(self):\n        return \"data-describe Cluster Widget\"\n\n    def show(self, viz_backend=None, **kwargs):\n        \"\"\"Show the cluster plot.\"\"\"\n        backend = viz_backend or self.viz_backend\n\n        if self.viz_data is None:\n            raise ValueError(\"Could not find data to visualize.\")\n\n        return _get_viz_backend(backend).viz_cluster(\n            self.viz_data,\n            method=self.method,\n            xlabel=self.xlabel,\n            ylabel=self.ylabel,\n            **kwargs,\n        )\n\n\nclass KmeansClusterWidget(ClusterWidget):\n    \"\"\"Interface for collecting additional information about the k-Means clustering.\"\"\"\n\n    def __init__(\n        self,\n        n_clusters=None,\n        search=False,\n        cluster_range=None,\n        metric=None,\n        scores=None,\n        **kwargs,\n    ):\n        \"\"\"Mandatory parameters.\n\n        Args:\n            clusters (List[int], optional): The predicted cluster labels.\n            estimator (optional): The cluster estimator object.\n            n_clusters (int, optional): The number of clusters (k) used in the final clustering fit.\n            search (bool, optional): If True, a search was performed for optimal n_clusters.\n            cluster_range (Tuple[int, int], optional): The range of clusters searched as (min_cluster, max_cluster).\n            metric (str, optional): The metric used to evaluate the cluster search.\n            scores: The metric scores in cluster search.\n        \"\"\"\n        super(KmeansClusterWidget, self).__init__(**kwargs)\n        self.method = \"kmeans\"\n        self.n_clusters = n_clusters\n        self.search = search\n        self.cluster_range = cluster_range\n        self.metric = metric\n        self.scores = scores\n\n    def cluster_search_plot(self, viz_backend=None, **kwargs):\n        \"\"\"Shows the results of cluster search.\n\n        Cluster search attempts to find an optimal n_clusters by maximizing on some criterion.\n        This plot shows a line plot of each n_cluster that was attempted and its score.\n\n        Args:\n            viz_backend: The visualization backend.\n            **kwargs: Additional keyword arguments to pass to the visualization backend.\n\n        Returns:\n            The plot\n        \"\"\"\n        if not self.search:\n            raise ValueError(\n                \"Cluster search plot is not applicable when n_cluster is explicitly selected\"\n            )\n\n        return _get_viz_backend(viz_backend).viz_cluster_search_plot(\n            self.cluster_range, self.scores, self.metric, **kwargs\n        )\n\n\nclass HDBSCANClusterWidget(ClusterWidget):\n    \"\"\"Interface for collecting additional information about the HDBSCAN clustering.\"\"\"\n\n    def __init__(self, **kwargs):\n        \"\"\"Mandatory parameters.\n\n        Args:\n            clusters (List[int], optional): The predicted cluster labels.\n            estimator (optional): The HDBSCAN estimator object.\n        \"\"\"\n        super(HDBSCANClusterWidget, self).__init__(**kwargs)\n        self.method = \"hdbscan\"\n\n\ndef _pandas_compute_cluster(data, method: str, **kwargs):\n",
        "source_code_len": 4595,
        "target_code": "\ndef _pandas_compute_cluster(data, method: str, **kwargs):\n",
        "target_code_len": 59,
        "diff_format": "@@ -78,132 +222,2 @@\n \n-class ClusterWidget(BaseWidget):\n-    \"\"\"Interface for collecting additional information about the clustering.\"\"\"\n-\n-    def __init__(\n-        self,\n-        clusters: List[int] = None,\n-        method: str = None,\n-        estimator=None,\n-        input_data=None,\n-        scaled_data=None,\n-        viz_data=None,\n-        dim_method: str = None,\n-        reductor=None,\n-        xlabel: str = None,\n-        ylabel: str = None,\n-        **kwargs,\n-    ):\n-        \"\"\"Cluster Analysis.\n-\n-        Args:\n-            clusters (List[int], optional): The predicted cluster labels\n-            method (str): The clustering algorithm\n-            estimator: The clustering estimator\n-            input_data: The input data\n-            scaled_data: The data after applying standardization\n-            viz_data: The data used for the default visualization i.e. reduced to 2 dimensions\n-            dim_method (str): The algorithm used for dimensionality reduction\n-            reductor: The dimensionality reduction estimator\n-            xlabel (str): The x-axis label for the cluster plot\n-            ylabel (str): The y-axis label for the cluster plot\n-        \"\"\"\n-        super(ClusterWidget, self).__init__(**kwargs)\n-        self.clusters = clusters\n-        self.method = method\n-        self.estimator = estimator\n-        self.input_data = input_data\n-        self.scaled_data = scaled_data\n-        self.viz_data = viz_data\n-        self.dim_method = dim_method\n-        self.reductor = reductor\n-        self.xlabel = xlabel\n-        self.ylabel = ylabel\n-\n-    def __str__(self):\n-        return \"data-describe Cluster Widget\"\n-\n-    def show(self, viz_backend=None, **kwargs):\n-        \"\"\"Show the cluster plot.\"\"\"\n-        backend = viz_backend or self.viz_backend\n-\n-        if self.viz_data is None:\n-            raise ValueError(\"Could not find data to visualize.\")\n-\n-        return _get_viz_backend(backend).viz_cluster(\n-            self.viz_data,\n-            method=self.method,\n-            xlabel=self.xlabel,\n-            ylabel=self.ylabel,\n-            **kwargs,\n-        )\n-\n-\n-class KmeansClusterWidget(ClusterWidget):\n-    \"\"\"Interface for collecting additional information about the k-Means clustering.\"\"\"\n-\n-    def __init__(\n-        self,\n-        n_clusters=None,\n-        search=False,\n-        cluster_range=None,\n-        metric=None,\n-        scores=None,\n-        **kwargs,\n-    ):\n-        \"\"\"Mandatory parameters.\n-\n-        Args:\n-            clusters (List[int], optional): The predicted cluster labels.\n-            estimator (optional): The cluster estimator object.\n-            n_clusters (int, optional): The number of clusters (k) used in the final clustering fit.\n-            search (bool, optional): If True, a search was performed for optimal n_clusters.\n-            cluster_range (Tuple[int, int], optional): The range of clusters searched as (min_cluster, max_cluster).\n-            metric (str, optional): The metric used to evaluate the cluster search.\n-            scores: The metric scores in cluster search.\n-        \"\"\"\n-        super(KmeansClusterWidget, self).__init__(**kwargs)\n-        self.method = \"kmeans\"\n-        self.n_clusters = n_clusters\n-        self.search = search\n-        self.cluster_range = cluster_range\n-        self.metric = metric\n-        self.scores = scores\n-\n-    def cluster_search_plot(self, viz_backend=None, **kwargs):\n-        \"\"\"Shows the results of cluster search.\n-\n-        Cluster search attempts to find an optimal n_clusters by maximizing on some criterion.\n-        This plot shows a line plot of each n_cluster that was attempted and its score.\n-\n-        Args:\n-            viz_backend: The visualization backend.\n-            **kwargs: Additional keyword arguments to pass to the visualization backend.\n-\n-        Returns:\n-            The plot\n-        \"\"\"\n-        if not self.search:\n-            raise ValueError(\n-                \"Cluster search plot is not applicable when n_cluster is explicitly selected\"\n-            )\n-\n-        return _get_viz_backend(viz_backend).viz_cluster_search_plot(\n-            self.cluster_range, self.scores, self.metric, **kwargs\n-        )\n-\n-\n-class HDBSCANClusterWidget(ClusterWidget):\n-    \"\"\"Interface for collecting additional information about the HDBSCAN clustering.\"\"\"\n-\n-    def __init__(self, **kwargs):\n-        \"\"\"Mandatory parameters.\n-\n-        Args:\n-            clusters (List[int], optional): The predicted cluster labels.\n-            estimator (optional): The HDBSCAN estimator object.\n-        \"\"\"\n-        super(HDBSCANClusterWidget, self).__init__(**kwargs)\n-        self.method = \"hdbscan\"\n-\n-\n def _pandas_compute_cluster(data, method: str, **kwargs):\n",
        "source_code_with_indent": "\n<DED>class ClusterWidget(BaseWidget):\n    <IND>\"\"\"Interface for collecting additional information about the clustering.\"\"\"\n\n    def __init__(\n        self,\n        clusters: List[int] = None,\n        method: str = None,\n        estimator=None,\n        input_data=None,\n        scaled_data=None,\n        viz_data=None,\n        dim_method: str = None,\n        reductor=None,\n        xlabel: str = None,\n        ylabel: str = None,\n        **kwargs,\n    ):\n        <IND>\"\"\"Cluster Analysis.\n\n        Args:\n            clusters (List[int], optional): The predicted cluster labels\n            method (str): The clustering algorithm\n            estimator: The clustering estimator\n            input_data: The input data\n            scaled_data: The data after applying standardization\n            viz_data: The data used for the default visualization i.e. reduced to 2 dimensions\n            dim_method (str): The algorithm used for dimensionality reduction\n            reductor: The dimensionality reduction estimator\n            xlabel (str): The x-axis label for the cluster plot\n            ylabel (str): The y-axis label for the cluster plot\n        \"\"\"\n        super(ClusterWidget, self).__init__(**kwargs)\n        self.clusters = clusters\n        self.method = method\n        self.estimator = estimator\n        self.input_data = input_data\n        self.scaled_data = scaled_data\n        self.viz_data = viz_data\n        self.dim_method = dim_method\n        self.reductor = reductor\n        self.xlabel = xlabel\n        self.ylabel = ylabel\n\n    <DED>def __str__(self):\n        <IND>return \"data-describe Cluster Widget\"\n\n    <DED>def show(self, viz_backend=None, **kwargs):\n        <IND>\"\"\"Show the cluster plot.\"\"\"\n        backend = viz_backend or self.viz_backend\n\n        if self.viz_data is None:\n            <IND>raise ValueError(\"Could not find data to visualize.\")\n\n        <DED>return _get_viz_backend(backend).viz_cluster(\n            self.viz_data,\n            method=self.method,\n            xlabel=self.xlabel,\n            ylabel=self.ylabel,\n            **kwargs,\n        )\n\n\n<DED><DED>class KmeansClusterWidget(ClusterWidget):\n    <IND>\"\"\"Interface for collecting additional information about the k-Means clustering.\"\"\"\n\n    def __init__(\n        self,\n        n_clusters=None,\n        search=False,\n        cluster_range=None,\n        metric=None,\n        scores=None,\n        **kwargs,\n    ):\n        <IND>\"\"\"Mandatory parameters.\n\n        Args:\n            clusters (List[int], optional): The predicted cluster labels.\n            estimator (optional): The cluster estimator object.\n            n_clusters (int, optional): The number of clusters (k) used in the final clustering fit.\n            search (bool, optional): If True, a search was performed for optimal n_clusters.\n            cluster_range (Tuple[int, int], optional): The range of clusters searched as (min_cluster, max_cluster).\n            metric (str, optional): The metric used to evaluate the cluster search.\n            scores: The metric scores in cluster search.\n        \"\"\"\n        super(KmeansClusterWidget, self).__init__(**kwargs)\n        self.method = \"kmeans\"\n        self.n_clusters = n_clusters\n        self.search = search\n        self.cluster_range = cluster_range\n        self.metric = metric\n        self.scores = scores\n\n    <DED>def cluster_search_plot(self, viz_backend=None, **kwargs):\n        <IND>\"\"\"Shows the results of cluster search.\n\n        Cluster search attempts to find an optimal n_clusters by maximizing on some criterion.\n        This plot shows a line plot of each n_cluster that was attempted and its score.\n\n        Args:\n            viz_backend: The visualization backend.\n            **kwargs: Additional keyword arguments to pass to the visualization backend.\n\n        Returns:\n            The plot\n        \"\"\"\n        if not self.search:\n            <IND>raise ValueError(\n                \"Cluster search plot is not applicable when n_cluster is explicitly selected\"\n            )\n\n        <DED>return _get_viz_backend(viz_backend).viz_cluster_search_plot(\n            self.cluster_range, self.scores, self.metric, **kwargs\n        )\n\n\n<DED><DED>class HDBSCANClusterWidget(ClusterWidget):\n    <IND>\"\"\"Interface for collecting additional information about the HDBSCAN clustering.\"\"\"\n\n    def __init__(self, **kwargs):\n        <IND>\"\"\"Mandatory parameters.\n\n        Args:\n            clusters (List[int], optional): The predicted cluster labels.\n            estimator (optional): The HDBSCAN estimator object.\n        \"\"\"\n        super(HDBSCANClusterWidget, self).__init__(**kwargs)\n        self.method = \"hdbscan\"\n\n\n<DED><DED>def _pandas_compute_cluster(data, method: str, **kwargs):\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n<DED>def _pandas_compute_cluster(data, method: str, **kwargs):\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "data-describe/data-describe",
    "commit": "9f3635b1cc00a3c03b17ea2f15f75248b5b3726a",
    "filename": "data_describe/core/clusters.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/data-describe-data-describe/data_describe/core/clustering.py",
    "file_hunks_size": 17,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": true,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "data_describe/core/clusters.py:93:8 Incompatible variable type [9]: ylabel is declared to have type `str` but is used as type `None`.",
    "message": " ylabel is declared to have type `str` but is used as type `None`.",
    "rule_id": "Incompatible variable type [9]",
    "warning_line_no": 93,
    "warning_line": "        ylabel: str = None,",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": true,
        "has_suppression": false,
        "source_code": "\nclass ClusterWidget(BaseWidget):\n    \"\"\"Interface for collecting additional information about the clustering.\"\"\"\n\n    def __init__(\n        self,\n        clusters: List[int] = None,\n        method: str = None,\n        estimator=None,\n        input_data=None,\n        scaled_data=None,\n        viz_data=None,\n        dim_method: str = None,\n        reductor=None,\n        xlabel: str = None,\n        ylabel: str = None,\n        **kwargs,\n    ):\n        \"\"\"Cluster Analysis.\n\n        Args:\n            clusters (List[int], optional): The predicted cluster labels\n            method (str): The clustering algorithm\n            estimator: The clustering estimator\n            input_data: The input data\n            scaled_data: The data after applying standardization\n            viz_data: The data used for the default visualization i.e. reduced to 2 dimensions\n            dim_method (str): The algorithm used for dimensionality reduction\n            reductor: The dimensionality reduction estimator\n            xlabel (str): The x-axis label for the cluster plot\n            ylabel (str): The y-axis label for the cluster plot\n        \"\"\"\n        super(ClusterWidget, self).__init__(**kwargs)\n        self.clusters = clusters\n        self.method = method\n        self.estimator = estimator\n        self.input_data = input_data\n        self.scaled_data = scaled_data\n        self.viz_data = viz_data\n        self.dim_method = dim_method\n        self.reductor = reductor\n        self.xlabel = xlabel\n        self.ylabel = ylabel\n\n    def __str__(self):\n        return \"data-describe Cluster Widget\"\n\n    def show(self, viz_backend=None, **kwargs):\n        \"\"\"Show the cluster plot.\"\"\"\n        backend = viz_backend or self.viz_backend\n\n        if self.viz_data is None:\n            raise ValueError(\"Could not find data to visualize.\")\n\n        return _get_viz_backend(backend).viz_cluster(\n            self.viz_data,\n            method=self.method,\n            xlabel=self.xlabel,\n            ylabel=self.ylabel,\n            **kwargs,\n        )\n\n\nclass KmeansClusterWidget(ClusterWidget):\n    \"\"\"Interface for collecting additional information about the k-Means clustering.\"\"\"\n\n    def __init__(\n        self,\n        n_clusters=None,\n        search=False,\n        cluster_range=None,\n        metric=None,\n        scores=None,\n        **kwargs,\n    ):\n        \"\"\"Mandatory parameters.\n\n        Args:\n            clusters (List[int], optional): The predicted cluster labels.\n            estimator (optional): The cluster estimator object.\n            n_clusters (int, optional): The number of clusters (k) used in the final clustering fit.\n            search (bool, optional): If True, a search was performed for optimal n_clusters.\n            cluster_range (Tuple[int, int], optional): The range of clusters searched as (min_cluster, max_cluster).\n            metric (str, optional): The metric used to evaluate the cluster search.\n            scores: The metric scores in cluster search.\n        \"\"\"\n        super(KmeansClusterWidget, self).__init__(**kwargs)\n        self.method = \"kmeans\"\n        self.n_clusters = n_clusters\n        self.search = search\n        self.cluster_range = cluster_range\n        self.metric = metric\n        self.scores = scores\n\n    def cluster_search_plot(self, viz_backend=None, **kwargs):\n        \"\"\"Shows the results of cluster search.\n\n        Cluster search attempts to find an optimal n_clusters by maximizing on some criterion.\n        This plot shows a line plot of each n_cluster that was attempted and its score.\n\n        Args:\n            viz_backend: The visualization backend.\n            **kwargs: Additional keyword arguments to pass to the visualization backend.\n\n        Returns:\n            The plot\n        \"\"\"\n        if not self.search:\n            raise ValueError(\n                \"Cluster search plot is not applicable when n_cluster is explicitly selected\"\n            )\n\n        return _get_viz_backend(viz_backend).viz_cluster_search_plot(\n            self.cluster_range, self.scores, self.metric, **kwargs\n        )\n\n\nclass HDBSCANClusterWidget(ClusterWidget):\n    \"\"\"Interface for collecting additional information about the HDBSCAN clustering.\"\"\"\n\n    def __init__(self, **kwargs):\n        \"\"\"Mandatory parameters.\n\n        Args:\n            clusters (List[int], optional): The predicted cluster labels.\n            estimator (optional): The HDBSCAN estimator object.\n        \"\"\"\n        super(HDBSCANClusterWidget, self).__init__(**kwargs)\n        self.method = \"hdbscan\"\n\n\ndef _pandas_compute_cluster(data, method: str, **kwargs):\n",
        "source_code_len": 4595,
        "target_code": "\ndef _pandas_compute_cluster(data, method: str, **kwargs):\n",
        "target_code_len": 59,
        "diff_format": "@@ -78,132 +222,2 @@\n \n-class ClusterWidget(BaseWidget):\n-    \"\"\"Interface for collecting additional information about the clustering.\"\"\"\n-\n-    def __init__(\n-        self,\n-        clusters: List[int] = None,\n-        method: str = None,\n-        estimator=None,\n-        input_data=None,\n-        scaled_data=None,\n-        viz_data=None,\n-        dim_method: str = None,\n-        reductor=None,\n-        xlabel: str = None,\n-        ylabel: str = None,\n-        **kwargs,\n-    ):\n-        \"\"\"Cluster Analysis.\n-\n-        Args:\n-            clusters (List[int], optional): The predicted cluster labels\n-            method (str): The clustering algorithm\n-            estimator: The clustering estimator\n-            input_data: The input data\n-            scaled_data: The data after applying standardization\n-            viz_data: The data used for the default visualization i.e. reduced to 2 dimensions\n-            dim_method (str): The algorithm used for dimensionality reduction\n-            reductor: The dimensionality reduction estimator\n-            xlabel (str): The x-axis label for the cluster plot\n-            ylabel (str): The y-axis label for the cluster plot\n-        \"\"\"\n-        super(ClusterWidget, self).__init__(**kwargs)\n-        self.clusters = clusters\n-        self.method = method\n-        self.estimator = estimator\n-        self.input_data = input_data\n-        self.scaled_data = scaled_data\n-        self.viz_data = viz_data\n-        self.dim_method = dim_method\n-        self.reductor = reductor\n-        self.xlabel = xlabel\n-        self.ylabel = ylabel\n-\n-    def __str__(self):\n-        return \"data-describe Cluster Widget\"\n-\n-    def show(self, viz_backend=None, **kwargs):\n-        \"\"\"Show the cluster plot.\"\"\"\n-        backend = viz_backend or self.viz_backend\n-\n-        if self.viz_data is None:\n-            raise ValueError(\"Could not find data to visualize.\")\n-\n-        return _get_viz_backend(backend).viz_cluster(\n-            self.viz_data,\n-            method=self.method,\n-            xlabel=self.xlabel,\n-            ylabel=self.ylabel,\n-            **kwargs,\n-        )\n-\n-\n-class KmeansClusterWidget(ClusterWidget):\n-    \"\"\"Interface for collecting additional information about the k-Means clustering.\"\"\"\n-\n-    def __init__(\n-        self,\n-        n_clusters=None,\n-        search=False,\n-        cluster_range=None,\n-        metric=None,\n-        scores=None,\n-        **kwargs,\n-    ):\n-        \"\"\"Mandatory parameters.\n-\n-        Args:\n-            clusters (List[int], optional): The predicted cluster labels.\n-            estimator (optional): The cluster estimator object.\n-            n_clusters (int, optional): The number of clusters (k) used in the final clustering fit.\n-            search (bool, optional): If True, a search was performed for optimal n_clusters.\n-            cluster_range (Tuple[int, int], optional): The range of clusters searched as (min_cluster, max_cluster).\n-            metric (str, optional): The metric used to evaluate the cluster search.\n-            scores: The metric scores in cluster search.\n-        \"\"\"\n-        super(KmeansClusterWidget, self).__init__(**kwargs)\n-        self.method = \"kmeans\"\n-        self.n_clusters = n_clusters\n-        self.search = search\n-        self.cluster_range = cluster_range\n-        self.metric = metric\n-        self.scores = scores\n-\n-    def cluster_search_plot(self, viz_backend=None, **kwargs):\n-        \"\"\"Shows the results of cluster search.\n-\n-        Cluster search attempts to find an optimal n_clusters by maximizing on some criterion.\n-        This plot shows a line plot of each n_cluster that was attempted and its score.\n-\n-        Args:\n-            viz_backend: The visualization backend.\n-            **kwargs: Additional keyword arguments to pass to the visualization backend.\n-\n-        Returns:\n-            The plot\n-        \"\"\"\n-        if not self.search:\n-            raise ValueError(\n-                \"Cluster search plot is not applicable when n_cluster is explicitly selected\"\n-            )\n-\n-        return _get_viz_backend(viz_backend).viz_cluster_search_plot(\n-            self.cluster_range, self.scores, self.metric, **kwargs\n-        )\n-\n-\n-class HDBSCANClusterWidget(ClusterWidget):\n-    \"\"\"Interface for collecting additional information about the HDBSCAN clustering.\"\"\"\n-\n-    def __init__(self, **kwargs):\n-        \"\"\"Mandatory parameters.\n-\n-        Args:\n-            clusters (List[int], optional): The predicted cluster labels.\n-            estimator (optional): The HDBSCAN estimator object.\n-        \"\"\"\n-        super(HDBSCANClusterWidget, self).__init__(**kwargs)\n-        self.method = \"hdbscan\"\n-\n-\n def _pandas_compute_cluster(data, method: str, **kwargs):\n",
        "source_code_with_indent": "\n<DED>class ClusterWidget(BaseWidget):\n    <IND>\"\"\"Interface for collecting additional information about the clustering.\"\"\"\n\n    def __init__(\n        self,\n        clusters: List[int] = None,\n        method: str = None,\n        estimator=None,\n        input_data=None,\n        scaled_data=None,\n        viz_data=None,\n        dim_method: str = None,\n        reductor=None,\n        xlabel: str = None,\n        ylabel: str = None,\n        **kwargs,\n    ):\n        <IND>\"\"\"Cluster Analysis.\n\n        Args:\n            clusters (List[int], optional): The predicted cluster labels\n            method (str): The clustering algorithm\n            estimator: The clustering estimator\n            input_data: The input data\n            scaled_data: The data after applying standardization\n            viz_data: The data used for the default visualization i.e. reduced to 2 dimensions\n            dim_method (str): The algorithm used for dimensionality reduction\n            reductor: The dimensionality reduction estimator\n            xlabel (str): The x-axis label for the cluster plot\n            ylabel (str): The y-axis label for the cluster plot\n        \"\"\"\n        super(ClusterWidget, self).__init__(**kwargs)\n        self.clusters = clusters\n        self.method = method\n        self.estimator = estimator\n        self.input_data = input_data\n        self.scaled_data = scaled_data\n        self.viz_data = viz_data\n        self.dim_method = dim_method\n        self.reductor = reductor\n        self.xlabel = xlabel\n        self.ylabel = ylabel\n\n    <DED>def __str__(self):\n        <IND>return \"data-describe Cluster Widget\"\n\n    <DED>def show(self, viz_backend=None, **kwargs):\n        <IND>\"\"\"Show the cluster plot.\"\"\"\n        backend = viz_backend or self.viz_backend\n\n        if self.viz_data is None:\n            <IND>raise ValueError(\"Could not find data to visualize.\")\n\n        <DED>return _get_viz_backend(backend).viz_cluster(\n            self.viz_data,\n            method=self.method,\n            xlabel=self.xlabel,\n            ylabel=self.ylabel,\n            **kwargs,\n        )\n\n\n<DED><DED>class KmeansClusterWidget(ClusterWidget):\n    <IND>\"\"\"Interface for collecting additional information about the k-Means clustering.\"\"\"\n\n    def __init__(\n        self,\n        n_clusters=None,\n        search=False,\n        cluster_range=None,\n        metric=None,\n        scores=None,\n        **kwargs,\n    ):\n        <IND>\"\"\"Mandatory parameters.\n\n        Args:\n            clusters (List[int], optional): The predicted cluster labels.\n            estimator (optional): The cluster estimator object.\n            n_clusters (int, optional): The number of clusters (k) used in the final clustering fit.\n            search (bool, optional): If True, a search was performed for optimal n_clusters.\n            cluster_range (Tuple[int, int], optional): The range of clusters searched as (min_cluster, max_cluster).\n            metric (str, optional): The metric used to evaluate the cluster search.\n            scores: The metric scores in cluster search.\n        \"\"\"\n        super(KmeansClusterWidget, self).__init__(**kwargs)\n        self.method = \"kmeans\"\n        self.n_clusters = n_clusters\n        self.search = search\n        self.cluster_range = cluster_range\n        self.metric = metric\n        self.scores = scores\n\n    <DED>def cluster_search_plot(self, viz_backend=None, **kwargs):\n        <IND>\"\"\"Shows the results of cluster search.\n\n        Cluster search attempts to find an optimal n_clusters by maximizing on some criterion.\n        This plot shows a line plot of each n_cluster that was attempted and its score.\n\n        Args:\n            viz_backend: The visualization backend.\n            **kwargs: Additional keyword arguments to pass to the visualization backend.\n\n        Returns:\n            The plot\n        \"\"\"\n        if not self.search:\n            <IND>raise ValueError(\n                \"Cluster search plot is not applicable when n_cluster is explicitly selected\"\n            )\n\n        <DED>return _get_viz_backend(viz_backend).viz_cluster_search_plot(\n            self.cluster_range, self.scores, self.metric, **kwargs\n        )\n\n\n<DED><DED>class HDBSCANClusterWidget(ClusterWidget):\n    <IND>\"\"\"Interface for collecting additional information about the HDBSCAN clustering.\"\"\"\n\n    def __init__(self, **kwargs):\n        <IND>\"\"\"Mandatory parameters.\n\n        Args:\n            clusters (List[int], optional): The predicted cluster labels.\n            estimator (optional): The HDBSCAN estimator object.\n        \"\"\"\n        super(HDBSCANClusterWidget, self).__init__(**kwargs)\n        self.method = \"hdbscan\"\n\n\n<DED><DED>def _pandas_compute_cluster(data, method: str, **kwargs):\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n<DED>def _pandas_compute_cluster(data, method: str, **kwargs):\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "data-describe/data-describe",
    "commit": "9f3635b1cc00a3c03b17ea2f15f75248b5b3726a",
    "filename": "data_describe/core/clusters.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/data-describe-data-describe/data_describe/core/clustering.py",
    "file_hunks_size": 17,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "data_describe/core/clusters.py:245:4 Incompatible variable type [9]: Unable to unpack `None`, expected a tuple.",
    "message": " Unable to unpack `None`, expected a tuple.",
    "rule_id": "Incompatible variable type [9]",
    "warning_line_no": 245,
    "warning_line": "    cluster_range: Tuple[int, int] = None,"
  },
  {
    "project": "data-describe/data-describe",
    "commit": "9f3635b1cc00a3c03b17ea2f15f75248b5b3726a",
    "filename": "data_describe/core/clusters.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/data-describe-data-describe/data_describe/core/clustering.py",
    "file_hunks_size": 17,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "data_describe/core/clusters.py:280:4 Incompatible variable type [9]: Unable to unpack `None`, expected a tuple.",
    "message": " Unable to unpack `None`, expected a tuple.",
    "rule_id": "Incompatible variable type [9]",
    "warning_line_no": 280,
    "warning_line": "    cluster_range: Tuple[int, int] = None,"
  },
  {
    "project": "data-describe/data-describe",
    "commit": "9f3635b1cc00a3c03b17ea2f15f75248b5b3726a",
    "filename": "data_describe/core/clusters.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/data-describe-data-describe/data_describe/core/clustering.py",
    "file_hunks_size": 17,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "data_describe/core/clusters.py:382:23 Incompatible variable type [9]: xlabel is declared to have type `str` but is used as type `None`.",
    "message": " xlabel is declared to have type `str` but is used as type `None`.",
    "rule_id": "Incompatible variable type [9]",
    "warning_line_no": 382,
    "warning_line": "    data, method: str, xlabel: str = None, ylabel: str = None, **kwargs",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "def _plotly_viz_cluster(\n    data, method: str, xlabel: str = None, ylabel: str = None, **kwargs\n):\n",
        "source_code_len": 100,
        "target_code": "def _plotly_viz_cluster(\n    data,\n    method: str,\n    xlabel: Optional[str] = None,\n    ylabel: Optional[str] = None,\n    **kwargs,\n):\n",
        "target_code_len": 137,
        "diff_format": "@@ -381,3 +397,7 @@\n def _plotly_viz_cluster(\n-    data, method: str, xlabel: str = None, ylabel: str = None, **kwargs\n+    data,\n+    method: str,\n+    xlabel: Optional[str] = None,\n+    ylabel: Optional[str] = None,\n+    **kwargs,\n ):\n",
        "source_code_with_indent": "<DED>def _plotly_viz_cluster(\n    data, method: str, xlabel: str = None, ylabel: str = None, **kwargs\n):\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "<DED>def _plotly_viz_cluster(\n    data,\n    method: str,\n    xlabel: Optional[str] = None,\n    ylabel: Optional[str] = None,\n    **kwargs,\n):\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "data-describe/data-describe",
    "commit": "9f3635b1cc00a3c03b17ea2f15f75248b5b3726a",
    "filename": "data_describe/core/clusters.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/data-describe-data-describe/data_describe/core/clustering.py",
    "file_hunks_size": 17,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "data_describe/core/clusters.py:382:43 Incompatible variable type [9]: ylabel is declared to have type `str` but is used as type `None`.",
    "message": " ylabel is declared to have type `str` but is used as type `None`.",
    "rule_id": "Incompatible variable type [9]",
    "warning_line_no": 382,
    "warning_line": "    data, method: str, xlabel: str = None, ylabel: str = None, **kwargs",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "def _plotly_viz_cluster(\n    data, method: str, xlabel: str = None, ylabel: str = None, **kwargs\n):\n",
        "source_code_len": 100,
        "target_code": "def _plotly_viz_cluster(\n    data,\n    method: str,\n    xlabel: Optional[str] = None,\n    ylabel: Optional[str] = None,\n    **kwargs,\n):\n",
        "target_code_len": 137,
        "diff_format": "@@ -381,3 +397,7 @@\n def _plotly_viz_cluster(\n-    data, method: str, xlabel: str = None, ylabel: str = None, **kwargs\n+    data,\n+    method: str,\n+    xlabel: Optional[str] = None,\n+    ylabel: Optional[str] = None,\n+    **kwargs,\n ):\n",
        "source_code_with_indent": "<DED>def _plotly_viz_cluster(\n    data, method: str, xlabel: str = None, ylabel: str = None, **kwargs\n):\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "<DED>def _plotly_viz_cluster(\n    data,\n    method: str,\n    xlabel: Optional[str] = None,\n    ylabel: Optional[str] = None,\n    **kwargs,\n):\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "data-describe/data-describe",
    "commit": "9f3635b1cc00a3c03b17ea2f15f75248b5b3726a",
    "filename": "data_describe/core/clusters.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/data-describe-data-describe/data_describe/core/clustering.py",
    "file_hunks_size": 17,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "data_describe/core/clusters.py:444:23 Incompatible variable type [9]: xlabel is declared to have type `str` but is used as type `None`.",
    "message": " xlabel is declared to have type `str` but is used as type `None`.",
    "rule_id": "Incompatible variable type [9]",
    "warning_line_no": 444,
    "warning_line": "    data, method: str, xlabel: str = None, ylabel: str = None, **kwargs",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "def _seaborn_viz_cluster(\n    data, method: str, xlabel: str = None, ylabel: str = None, **kwargs\n):\n",
        "source_code_len": 101,
        "target_code": "def _seaborn_viz_cluster(\n    data,\n    method: str,\n    xlabel: Optional[str] = None,\n    ylabel: Optional[str] = None,\n    **kwargs,\n):\n",
        "target_code_len": 138,
        "diff_format": "@@ -443,3 +464,7 @@\n def _seaborn_viz_cluster(\n-    data, method: str, xlabel: str = None, ylabel: str = None, **kwargs\n+    data,\n+    method: str,\n+    xlabel: Optional[str] = None,\n+    ylabel: Optional[str] = None,\n+    **kwargs,\n ):\n",
        "source_code_with_indent": "<DED><DED>def _seaborn_viz_cluster(\n    data, method: str, xlabel: str = None, ylabel: str = None, **kwargs\n):\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "<DED><DED>def _seaborn_viz_cluster(\n    data,\n    method: str,\n    xlabel: Optional[str] = None,\n    ylabel: Optional[str] = None,\n    **kwargs,\n):\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "data-describe/data-describe",
    "commit": "9f3635b1cc00a3c03b17ea2f15f75248b5b3726a",
    "filename": "data_describe/core/clusters.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/data-describe-data-describe/data_describe/core/clustering.py",
    "file_hunks_size": 17,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "data_describe/core/clusters.py:444:43 Incompatible variable type [9]: ylabel is declared to have type `str` but is used as type `None`.",
    "message": " ylabel is declared to have type `str` but is used as type `None`.",
    "rule_id": "Incompatible variable type [9]",
    "warning_line_no": 444,
    "warning_line": "    data, method: str, xlabel: str = None, ylabel: str = None, **kwargs",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "def _seaborn_viz_cluster(\n    data, method: str, xlabel: str = None, ylabel: str = None, **kwargs\n):\n",
        "source_code_len": 101,
        "target_code": "def _seaborn_viz_cluster(\n    data,\n    method: str,\n    xlabel: Optional[str] = None,\n    ylabel: Optional[str] = None,\n    **kwargs,\n):\n",
        "target_code_len": 138,
        "diff_format": "@@ -443,3 +464,7 @@\n def _seaborn_viz_cluster(\n-    data, method: str, xlabel: str = None, ylabel: str = None, **kwargs\n+    data,\n+    method: str,\n+    xlabel: Optional[str] = None,\n+    ylabel: Optional[str] = None,\n+    **kwargs,\n ):\n",
        "source_code_with_indent": "<DED><DED>def _seaborn_viz_cluster(\n    data, method: str, xlabel: str = None, ylabel: str = None, **kwargs\n):\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "<DED><DED>def _seaborn_viz_cluster(\n    data,\n    method: str,\n    xlabel: Optional[str] = None,\n    ylabel: Optional[str] = None,\n    **kwargs,\n):\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "data-describe/data-describe",
    "commit": "9f3635b1cc00a3c03b17ea2f15f75248b5b3726a",
    "filename": "data_describe/core/distributions.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/data-describe-data-describe/data_describe/core/distributions.py",
    "file_hunks_size": 22,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "data_describe/core/distributions.py:84:14 Incompatible variable type [9]: x is declared to have type `str` but is used as type `None`.",
    "message": " x is declared to have type `str` but is used as type `None`.",
    "rule_id": "Incompatible variable type [9]",
    "warning_line_no": 84,
    "warning_line": "        self, x: str = None, contrast: str = None, viz_backend=None, **kwargs",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "from typing import Dict, Any\n\n",
        "source_code_len": 30,
        "target_code": "from typing import Dict, Any, Optional\n\n",
        "target_code_len": 40,
        "diff_format": "@@ -1,2 +1,2 @@\n-from typing import Dict, Any\n+from typing import Dict, Any, Optional\n \n",
        "source_code_with_indent": "from typing import Dict, Any\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "from typing import Dict, Any, Optional\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    def plot_distribution(\n        self, x: str = None, contrast: str = None, viz_backend=None, **kwargs\n    ):\n",
        "source_code_len": 112,
        "target_code": "    def plot_distribution(\n        self,\n        x: Optional[str] = None,\n        contrast: Optional[str] = None,\n        viz_backend: Optional[str] = None,\n        **kwargs,\n    ):\n",
        "target_code_len": 182,
        "diff_format": "@@ -83,3 +81,7 @@\n     def plot_distribution(\n-        self, x: str = None, contrast: str = None, viz_backend=None, **kwargs\n+        self,\n+        x: Optional[str] = None,\n+        contrast: Optional[str] = None,\n+        viz_backend: Optional[str] = None,\n+        **kwargs,\n     ):\n",
        "source_code_with_indent": "    <DED>def plot_distribution(\n        self, x: str = None, contrast: str = None, viz_backend=None, **kwargs\n    ):\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    <DED>def plot_distribution(\n        self,\n        x: Optional[str] = None,\n        contrast: Optional[str] = None,\n        viz_backend: Optional[str] = None,\n        **kwargs,\n    ):\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "data-describe/data-describe",
    "commit": "9f3635b1cc00a3c03b17ea2f15f75248b5b3726a",
    "filename": "data_describe/core/distributions.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/data-describe-data-describe/data_describe/core/distributions.py",
    "file_hunks_size": 22,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "data_describe/core/distributions.py:84:29 Incompatible variable type [9]: contrast is declared to have type `str` but is used as type `None`.",
    "message": " contrast is declared to have type `str` but is used as type `None`.",
    "rule_id": "Incompatible variable type [9]",
    "warning_line_no": 84,
    "warning_line": "        self, x: str = None, contrast: str = None, viz_backend=None, **kwargs",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "from typing import Dict, Any\n\n",
        "source_code_len": 30,
        "target_code": "from typing import Dict, Any, Optional\n\n",
        "target_code_len": 40,
        "diff_format": "@@ -1,2 +1,2 @@\n-from typing import Dict, Any\n+from typing import Dict, Any, Optional\n \n",
        "source_code_with_indent": "from typing import Dict, Any\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "from typing import Dict, Any, Optional\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    def plot_distribution(\n        self, x: str = None, contrast: str = None, viz_backend=None, **kwargs\n    ):\n",
        "source_code_len": 112,
        "target_code": "    def plot_distribution(\n        self,\n        x: Optional[str] = None,\n        contrast: Optional[str] = None,\n        viz_backend: Optional[str] = None,\n        **kwargs,\n    ):\n",
        "target_code_len": 182,
        "diff_format": "@@ -83,3 +81,7 @@\n     def plot_distribution(\n-        self, x: str = None, contrast: str = None, viz_backend=None, **kwargs\n+        self,\n+        x: Optional[str] = None,\n+        contrast: Optional[str] = None,\n+        viz_backend: Optional[str] = None,\n+        **kwargs,\n     ):\n",
        "source_code_with_indent": "    <DED>def plot_distribution(\n        self, x: str = None, contrast: str = None, viz_backend=None, **kwargs\n    ):\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    <DED>def plot_distribution(\n        self,\n        x: Optional[str] = None,\n        contrast: Optional[str] = None,\n        viz_backend: Optional[str] = None,\n        **kwargs,\n    ):\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "data-describe/data-describe",
    "commit": "9f3635b1cc00a3c03b17ea2f15f75248b5b3726a",
    "filename": "data_describe/core/distributions.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/data-describe-data-describe/data_describe/core/distributions.py",
    "file_hunks_size": 22,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "data_describe/core/distributions.py:137:44 Incompatible variable type [9]: contrast is declared to have type `str` but is used as type `None`.",
    "message": " contrast is declared to have type `str` but is used as type `None`.",
    "rule_id": "Incompatible variable type [9]",
    "warning_line_no": 137,
    "warning_line": "def _seaborn_viz_distribution(data, x: str, contrast: str = None, **kwargs):",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "from typing import Dict, Any\n\n",
        "source_code_len": 30,
        "target_code": "from typing import Dict, Any, Optional\n\n",
        "target_code_len": 40,
        "diff_format": "@@ -1,2 +1,2 @@\n-from typing import Dict, Any\n+from typing import Dict, Any, Optional\n \n",
        "source_code_with_indent": "from typing import Dict, Any\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "from typing import Dict, Any, Optional\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": true,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\ndef _seaborn_viz_distribution(data, x: str, contrast: str = None, **kwargs):\n    \"\"\"Plots the distribution.\n",
        "source_code_len": 109,
        "target_code": "\ndef _seaborn_viz_distribution(data, x: str, contrast: Optional[str] = None, **kwargs):\n    \"\"\"Plots the distribution.\n",
        "target_code_len": 119,
        "diff_format": "@@ -136,3 +172,3 @@\n \n-def _seaborn_viz_distribution(data, x: str, contrast: str = None, **kwargs):\n+def _seaborn_viz_distribution(data, x: str, contrast: Optional[str] = None, **kwargs):\n     \"\"\"Plots the distribution.\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\n<DED>def _seaborn_viz_distribution(data, x: str, contrast: str = None, **kwargs):\n    <IND>",
        "target_code_with_indent": "\n<DED>def _seaborn_viz_distribution(data, x: str, contrast: Optional[str] = None, **kwargs):\n    <IND>"
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    x: str,\n    contrast: str = None,\n    mode: str = \"combo\",\n    hist_kwargs: dict = None,\n    violin_kwargs: dict = None,\n    **kwargs,\n",
        "source_code_len": 139,
        "target_code": "    x: str,\n    contrast: Optional[str] = None,\n    mode: str = \"combo\",\n    hist_kwargs: Optional[dict] = None,\n    violin_kwargs: Optional[dict] = None,\n    **kwargs,\n",
        "target_code_len": 169,
        "diff_format": "@@ -157,6 +193,6 @@\n     x: str,\n-    contrast: str = None,\n+    contrast: Optional[str] = None,\n     mode: str = \"combo\",\n-    hist_kwargs: dict = None,\n-    violin_kwargs: dict = None,\n+    hist_kwargs: Optional[dict] = None,\n+    violin_kwargs: Optional[dict] = None,\n     **kwargs,\n",
        "source_code_with_indent": "    x: str,\n    contrast: str = None,\n    mode: str = \"combo\",\n    hist_kwargs: dict = None,\n    violin_kwargs: dict = None,\n    **kwargs,\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    x: str,\n    contrast: Optional[str] = None,\n    mode: str = \"combo\",\n    hist_kwargs: Optional[dict] = None,\n    violin_kwargs: Optional[dict] = None,\n    **kwargs,\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\ndef _seaborn_viz_categorical(\n    data,\n    x: str,\n    contrast: str = None,\n    bar_kwargs: dict = None,\n):\n    \"\"\"Plots a bar count plot for a categorical feature.\n",
        "source_code_len": 168,
        "target_code": "\ndef _seaborn_viz_categorical(data, x: str, contrast: Optional[str] = None, **kwargs):\n    \"\"\"Plots a bar count plot for a categorical feature.\n",
        "target_code_len": 144,
        "diff_format": "@@ -211,8 +254,3 @@\n \n-def _seaborn_viz_categorical(\n-    data,\n-    x: str,\n-    contrast: str = None,\n-    bar_kwargs: dict = None,\n-):\n+def _seaborn_viz_categorical(data, x: str, contrast: Optional[str] = None, **kwargs):\n     \"\"\"Plots a bar count plot for a categorical feature.\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\n<DED><DED>def _seaborn_viz_categorical(\n    data,\n    x: str,\n    contrast: str = None,\n    bar_kwargs: dict = None,\n):\n    <IND>",
        "target_code_with_indent": "\n<DED><DED>def _seaborn_viz_categorical(data, x: str, contrast: Optional[str] = None, **kwargs):\n    <IND>"
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\ndef _seaborn_viz_histogram(data, x: str, contrast: str = None, **kwargs):\n    \"\"\"Plot a single histogram.\n",
        "source_code_len": 107,
        "target_code": "\ndef _seaborn_viz_histogram(data, x: str, contrast: Optional[str] = None, **kwargs):\n    \"\"\"Plot a single histogram.\n",
        "target_code_len": 117,
        "diff_format": "@@ -238,3 +279,3 @@\n \n-def _seaborn_viz_histogram(data, x: str, contrast: str = None, **kwargs):\n+def _seaborn_viz_histogram(data, x: str, contrast: Optional[str] = None, **kwargs):\n     \"\"\"Plot a single histogram.\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\n<DED>def _seaborn_viz_histogram(data, x: str, contrast: str = None, **kwargs):\n    <IND>",
        "target_code_with_indent": "\n<DED>def _seaborn_viz_histogram(data, x: str, contrast: Optional[str] = None, **kwargs):\n    <IND>"
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\ndef _seaborn_viz_violin(data, x: str, contrast: str = None, **kwargs):\n    \"\"\"Plot a single violin plot.\n",
        "source_code_len": 106,
        "target_code": "\ndef _seaborn_viz_violin(data, x: str, contrast: Optional[str] = None, **kwargs):\n    \"\"\"Plot a single violin plot.\n",
        "target_code_len": 116,
        "diff_format": "@@ -264,3 +308,3 @@\n \n-def _seaborn_viz_violin(data, x: str, contrast: str = None, **kwargs):\n+def _seaborn_viz_violin(data, x: str, contrast: Optional[str] = None, **kwargs):\n     \"\"\"Plot a single violin plot.\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\n<DED>def _seaborn_viz_violin(data, x: str, contrast: str = None, **kwargs):\n    <IND>",
        "target_code_with_indent": "\n<DED>def _seaborn_viz_violin(data, x: str, contrast: Optional[str] = None, **kwargs):\n    <IND>"
      }
    ]
  },
  {
    "project": "data-describe/data-describe",
    "commit": "9f3635b1cc00a3c03b17ea2f15f75248b5b3726a",
    "filename": "data_describe/core/distributions.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/data-describe-data-describe/data_describe/core/distributions.py",
    "file_hunks_size": 22,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "data_describe/core/distributions.py:158:4 Incompatible variable type [9]: contrast is declared to have type `str` but is used as type `None`.",
    "message": " contrast is declared to have type `str` but is used as type `None`.",
    "rule_id": "Incompatible variable type [9]",
    "warning_line_no": 158,
    "warning_line": "    contrast: str = None,",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "from typing import Dict, Any\n\n",
        "source_code_len": 30,
        "target_code": "from typing import Dict, Any, Optional\n\n",
        "target_code_len": 40,
        "diff_format": "@@ -1,2 +1,2 @@\n-from typing import Dict, Any\n+from typing import Dict, Any, Optional\n \n",
        "source_code_with_indent": "from typing import Dict, Any\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "from typing import Dict, Any, Optional\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": true,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    x: str,\n    contrast: str = None,\n    mode: str = \"combo\",\n    hist_kwargs: dict = None,\n    violin_kwargs: dict = None,\n    **kwargs,\n",
        "source_code_len": 139,
        "target_code": "    x: str,\n    contrast: Optional[str] = None,\n    mode: str = \"combo\",\n    hist_kwargs: Optional[dict] = None,\n    violin_kwargs: Optional[dict] = None,\n    **kwargs,\n",
        "target_code_len": 169,
        "diff_format": "@@ -157,6 +193,6 @@\n     x: str,\n-    contrast: str = None,\n+    contrast: Optional[str] = None,\n     mode: str = \"combo\",\n-    hist_kwargs: dict = None,\n-    violin_kwargs: dict = None,\n+    hist_kwargs: Optional[dict] = None,\n+    violin_kwargs: Optional[dict] = None,\n     **kwargs,\n",
        "source_code_with_indent": "    x: str,\n    contrast: str = None,\n    mode: str = \"combo\",\n    hist_kwargs: dict = None,\n    violin_kwargs: dict = None,\n    **kwargs,\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    x: str,\n    contrast: Optional[str] = None,\n    mode: str = \"combo\",\n    hist_kwargs: Optional[dict] = None,\n    violin_kwargs: Optional[dict] = None,\n    **kwargs,\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\ndef _seaborn_viz_histogram(data, x: str, contrast: str = None, **kwargs):\n    \"\"\"Plot a single histogram.\n",
        "source_code_len": 107,
        "target_code": "\ndef _seaborn_viz_histogram(data, x: str, contrast: Optional[str] = None, **kwargs):\n    \"\"\"Plot a single histogram.\n",
        "target_code_len": 117,
        "diff_format": "@@ -238,3 +279,3 @@\n \n-def _seaborn_viz_histogram(data, x: str, contrast: str = None, **kwargs):\n+def _seaborn_viz_histogram(data, x: str, contrast: Optional[str] = None, **kwargs):\n     \"\"\"Plot a single histogram.\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\n<DED>def _seaborn_viz_histogram(data, x: str, contrast: str = None, **kwargs):\n    <IND>",
        "target_code_with_indent": "\n<DED>def _seaborn_viz_histogram(data, x: str, contrast: Optional[str] = None, **kwargs):\n    <IND>"
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\ndef _seaborn_viz_violin(data, x: str, contrast: str = None, **kwargs):\n    \"\"\"Plot a single violin plot.\n",
        "source_code_len": 106,
        "target_code": "\ndef _seaborn_viz_violin(data, x: str, contrast: Optional[str] = None, **kwargs):\n    \"\"\"Plot a single violin plot.\n",
        "target_code_len": 116,
        "diff_format": "@@ -264,3 +308,3 @@\n \n-def _seaborn_viz_violin(data, x: str, contrast: str = None, **kwargs):\n+def _seaborn_viz_violin(data, x: str, contrast: Optional[str] = None, **kwargs):\n     \"\"\"Plot a single violin plot.\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\n<DED>def _seaborn_viz_violin(data, x: str, contrast: str = None, **kwargs):\n    <IND>",
        "target_code_with_indent": "\n<DED>def _seaborn_viz_violin(data, x: str, contrast: Optional[str] = None, **kwargs):\n    <IND>"
      }
    ]
  },
  {
    "project": "data-describe/data-describe",
    "commit": "9f3635b1cc00a3c03b17ea2f15f75248b5b3726a",
    "filename": "data_describe/core/distributions.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/data-describe-data-describe/data_describe/core/distributions.py",
    "file_hunks_size": 22,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "data_describe/core/distributions.py:160:4 Incompatible variable type [9]: hist_kwargs is declared to have type `Dict[typing.Any, typing.Any]` but is used as type `None`.",
    "message": " hist_kwargs is declared to have type `Dict[typing.Any, typing.Any]` but is used as type `None`.",
    "rule_id": "Incompatible variable type [9]",
    "warning_line_no": 160,
    "warning_line": "    hist_kwargs: dict = None,",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "from typing import Dict, Any\n\n",
        "source_code_len": 30,
        "target_code": "from typing import Dict, Any, Optional\n\n",
        "target_code_len": 40,
        "diff_format": "@@ -1,2 +1,2 @@\n-from typing import Dict, Any\n+from typing import Dict, Any, Optional\n \n",
        "source_code_with_indent": "from typing import Dict, Any\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "from typing import Dict, Any, Optional\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": true,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    x: str,\n    contrast: str = None,\n    mode: str = \"combo\",\n    hist_kwargs: dict = None,\n    violin_kwargs: dict = None,\n    **kwargs,\n",
        "source_code_len": 139,
        "target_code": "    x: str,\n    contrast: Optional[str] = None,\n    mode: str = \"combo\",\n    hist_kwargs: Optional[dict] = None,\n    violin_kwargs: Optional[dict] = None,\n    **kwargs,\n",
        "target_code_len": 169,
        "diff_format": "@@ -157,6 +193,6 @@\n     x: str,\n-    contrast: str = None,\n+    contrast: Optional[str] = None,\n     mode: str = \"combo\",\n-    hist_kwargs: dict = None,\n-    violin_kwargs: dict = None,\n+    hist_kwargs: Optional[dict] = None,\n+    violin_kwargs: Optional[dict] = None,\n     **kwargs,\n",
        "source_code_with_indent": "    x: str,\n    contrast: str = None,\n    mode: str = \"combo\",\n    hist_kwargs: dict = None,\n    violin_kwargs: dict = None,\n    **kwargs,\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    x: str,\n    contrast: Optional[str] = None,\n    mode: str = \"combo\",\n    hist_kwargs: Optional[dict] = None,\n    violin_kwargs: Optional[dict] = None,\n    **kwargs,\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\ndef _seaborn_viz_histogram(data, x: str, contrast: str = None, **kwargs):\n    \"\"\"Plot a single histogram.\n",
        "source_code_len": 107,
        "target_code": "\ndef _seaborn_viz_histogram(data, x: str, contrast: Optional[str] = None, **kwargs):\n    \"\"\"Plot a single histogram.\n",
        "target_code_len": 117,
        "diff_format": "@@ -238,3 +279,3 @@\n \n-def _seaborn_viz_histogram(data, x: str, contrast: str = None, **kwargs):\n+def _seaborn_viz_histogram(data, x: str, contrast: Optional[str] = None, **kwargs):\n     \"\"\"Plot a single histogram.\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\n<DED>def _seaborn_viz_histogram(data, x: str, contrast: str = None, **kwargs):\n    <IND>",
        "target_code_with_indent": "\n<DED>def _seaborn_viz_histogram(data, x: str, contrast: Optional[str] = None, **kwargs):\n    <IND>"
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\ndef _seaborn_viz_violin(data, x: str, contrast: str = None, **kwargs):\n    \"\"\"Plot a single violin plot.\n",
        "source_code_len": 106,
        "target_code": "\ndef _seaborn_viz_violin(data, x: str, contrast: Optional[str] = None, **kwargs):\n    \"\"\"Plot a single violin plot.\n",
        "target_code_len": 116,
        "diff_format": "@@ -264,3 +308,3 @@\n \n-def _seaborn_viz_violin(data, x: str, contrast: str = None, **kwargs):\n+def _seaborn_viz_violin(data, x: str, contrast: Optional[str] = None, **kwargs):\n     \"\"\"Plot a single violin plot.\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\n<DED>def _seaborn_viz_violin(data, x: str, contrast: str = None, **kwargs):\n    <IND>",
        "target_code_with_indent": "\n<DED>def _seaborn_viz_violin(data, x: str, contrast: Optional[str] = None, **kwargs):\n    <IND>"
      }
    ]
  },
  {
    "project": "data-describe/data-describe",
    "commit": "9f3635b1cc00a3c03b17ea2f15f75248b5b3726a",
    "filename": "data_describe/core/distributions.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/data-describe-data-describe/data_describe/core/distributions.py",
    "file_hunks_size": 22,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "data_describe/core/distributions.py:161:4 Incompatible variable type [9]: violin_kwargs is declared to have type `Dict[typing.Any, typing.Any]` but is used as type `None`.",
    "message": " violin_kwargs is declared to have type `Dict[typing.Any, typing.Any]` but is used as type `None`.",
    "rule_id": "Incompatible variable type [9]",
    "warning_line_no": 161,
    "warning_line": "    violin_kwargs: dict = None,",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "from typing import Dict, Any\n\n",
        "source_code_len": 30,
        "target_code": "from typing import Dict, Any, Optional\n\n",
        "target_code_len": 40,
        "diff_format": "@@ -1,2 +1,2 @@\n-from typing import Dict, Any\n+from typing import Dict, Any, Optional\n \n",
        "source_code_with_indent": "from typing import Dict, Any\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "from typing import Dict, Any, Optional\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": true,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    x: str,\n    contrast: str = None,\n    mode: str = \"combo\",\n    hist_kwargs: dict = None,\n    violin_kwargs: dict = None,\n    **kwargs,\n",
        "source_code_len": 139,
        "target_code": "    x: str,\n    contrast: Optional[str] = None,\n    mode: str = \"combo\",\n    hist_kwargs: Optional[dict] = None,\n    violin_kwargs: Optional[dict] = None,\n    **kwargs,\n",
        "target_code_len": 169,
        "diff_format": "@@ -157,6 +193,6 @@\n     x: str,\n-    contrast: str = None,\n+    contrast: Optional[str] = None,\n     mode: str = \"combo\",\n-    hist_kwargs: dict = None,\n-    violin_kwargs: dict = None,\n+    hist_kwargs: Optional[dict] = None,\n+    violin_kwargs: Optional[dict] = None,\n     **kwargs,\n",
        "source_code_with_indent": "    x: str,\n    contrast: str = None,\n    mode: str = \"combo\",\n    hist_kwargs: dict = None,\n    violin_kwargs: dict = None,\n    **kwargs,\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    x: str,\n    contrast: Optional[str] = None,\n    mode: str = \"combo\",\n    hist_kwargs: Optional[dict] = None,\n    violin_kwargs: Optional[dict] = None,\n    **kwargs,\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\ndef _seaborn_viz_histogram(data, x: str, contrast: str = None, **kwargs):\n    \"\"\"Plot a single histogram.\n",
        "source_code_len": 107,
        "target_code": "\ndef _seaborn_viz_histogram(data, x: str, contrast: Optional[str] = None, **kwargs):\n    \"\"\"Plot a single histogram.\n",
        "target_code_len": 117,
        "diff_format": "@@ -238,3 +279,3 @@\n \n-def _seaborn_viz_histogram(data, x: str, contrast: str = None, **kwargs):\n+def _seaborn_viz_histogram(data, x: str, contrast: Optional[str] = None, **kwargs):\n     \"\"\"Plot a single histogram.\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\n<DED>def _seaborn_viz_histogram(data, x: str, contrast: str = None, **kwargs):\n    <IND>",
        "target_code_with_indent": "\n<DED>def _seaborn_viz_histogram(data, x: str, contrast: Optional[str] = None, **kwargs):\n    <IND>"
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\ndef _seaborn_viz_violin(data, x: str, contrast: str = None, **kwargs):\n    \"\"\"Plot a single violin plot.\n",
        "source_code_len": 106,
        "target_code": "\ndef _seaborn_viz_violin(data, x: str, contrast: Optional[str] = None, **kwargs):\n    \"\"\"Plot a single violin plot.\n",
        "target_code_len": 116,
        "diff_format": "@@ -264,3 +308,3 @@\n \n-def _seaborn_viz_violin(data, x: str, contrast: str = None, **kwargs):\n+def _seaborn_viz_violin(data, x: str, contrast: Optional[str] = None, **kwargs):\n     \"\"\"Plot a single violin plot.\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\n<DED>def _seaborn_viz_violin(data, x: str, contrast: str = None, **kwargs):\n    <IND>",
        "target_code_with_indent": "\n<DED>def _seaborn_viz_violin(data, x: str, contrast: Optional[str] = None, **kwargs):\n    <IND>"
      }
    ]
  },
  {
    "project": "data-describe/data-describe",
    "commit": "9f3635b1cc00a3c03b17ea2f15f75248b5b3726a",
    "filename": "data_describe/core/distributions.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/data-describe-data-describe/data_describe/core/distributions.py",
    "file_hunks_size": 22,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "data_describe/core/distributions.py:215:4 Incompatible variable type [9]: contrast is declared to have type `str` but is used as type `None`.",
    "message": " contrast is declared to have type `str` but is used as type `None`.",
    "rule_id": "Incompatible variable type [9]",
    "warning_line_no": 215,
    "warning_line": "    contrast: str = None,",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "from typing import Dict, Any\n\n",
        "source_code_len": 30,
        "target_code": "from typing import Dict, Any, Optional\n\n",
        "target_code_len": 40,
        "diff_format": "@@ -1,2 +1,2 @@\n-from typing import Dict, Any\n+from typing import Dict, Any, Optional\n \n",
        "source_code_with_indent": "from typing import Dict, Any\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "from typing import Dict, Any, Optional\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\ndef _seaborn_viz_categorical(\n    data,\n    x: str,\n    contrast: str = None,\n    bar_kwargs: dict = None,\n):\n    \"\"\"Plots a bar count plot for a categorical feature.\n",
        "source_code_len": 168,
        "target_code": "\ndef _seaborn_viz_categorical(data, x: str, contrast: Optional[str] = None, **kwargs):\n    \"\"\"Plots a bar count plot for a categorical feature.\n",
        "target_code_len": 144,
        "diff_format": "@@ -211,8 +254,3 @@\n \n-def _seaborn_viz_categorical(\n-    data,\n-    x: str,\n-    contrast: str = None,\n-    bar_kwargs: dict = None,\n-):\n+def _seaborn_viz_categorical(data, x: str, contrast: Optional[str] = None, **kwargs):\n     \"\"\"Plots a bar count plot for a categorical feature.\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\n<DED><DED>def _seaborn_viz_categorical(\n    data,\n    x: str,\n    contrast: str = None,\n    bar_kwargs: dict = None,\n):\n    <IND>",
        "target_code_with_indent": "\n<DED><DED>def _seaborn_viz_categorical(data, x: str, contrast: Optional[str] = None, **kwargs):\n    <IND>"
      }
    ]
  },
  {
    "project": "data-describe/data-describe",
    "commit": "9f3635b1cc00a3c03b17ea2f15f75248b5b3726a",
    "filename": "data_describe/core/distributions.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/data-describe-data-describe/data_describe/core/distributions.py",
    "file_hunks_size": 22,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "data_describe/core/distributions.py:216:4 Incompatible variable type [9]: bar_kwargs is declared to have type `Dict[typing.Any, typing.Any]` but is used as type `None`.",
    "message": " bar_kwargs is declared to have type `Dict[typing.Any, typing.Any]` but is used as type `None`.",
    "rule_id": "Incompatible variable type [9]",
    "warning_line_no": 216,
    "warning_line": "    bar_kwargs: dict = None,",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "from typing import Dict, Any\n\n",
        "source_code_len": 30,
        "target_code": "from typing import Dict, Any, Optional\n\n",
        "target_code_len": 40,
        "diff_format": "@@ -1,2 +1,2 @@\n-from typing import Dict, Any\n+from typing import Dict, Any, Optional\n \n",
        "source_code_with_indent": "from typing import Dict, Any\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "from typing import Dict, Any, Optional\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\ndef _seaborn_viz_categorical(\n    data,\n    x: str,\n    contrast: str = None,\n    bar_kwargs: dict = None,\n):\n    \"\"\"Plots a bar count plot for a categorical feature.\n",
        "source_code_len": 168,
        "target_code": "\ndef _seaborn_viz_categorical(data, x: str, contrast: Optional[str] = None, **kwargs):\n    \"\"\"Plots a bar count plot for a categorical feature.\n",
        "target_code_len": 144,
        "diff_format": "@@ -211,8 +254,3 @@\n \n-def _seaborn_viz_categorical(\n-    data,\n-    x: str,\n-    contrast: str = None,\n-    bar_kwargs: dict = None,\n-):\n+def _seaborn_viz_categorical(data, x: str, contrast: Optional[str] = None, **kwargs):\n     \"\"\"Plots a bar count plot for a categorical feature.\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\n<DED><DED>def _seaborn_viz_categorical(\n    data,\n    x: str,\n    contrast: str = None,\n    bar_kwargs: dict = None,\n):\n    <IND>",
        "target_code_with_indent": "\n<DED><DED>def _seaborn_viz_categorical(data, x: str, contrast: Optional[str] = None, **kwargs):\n    <IND>"
      }
    ]
  },
  {
    "project": "data-describe/data-describe",
    "commit": "9f3635b1cc00a3c03b17ea2f15f75248b5b3726a",
    "filename": "data_describe/core/distributions.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/data-describe-data-describe/data_describe/core/distributions.py",
    "file_hunks_size": 22,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "data_describe/core/distributions.py:239:41 Incompatible variable type [9]: contrast is declared to have type `str` but is used as type `None`.",
    "message": " contrast is declared to have type `str` but is used as type `None`.",
    "rule_id": "Incompatible variable type [9]",
    "warning_line_no": 239,
    "warning_line": "def _seaborn_viz_histogram(data, x: str, contrast: str = None, **kwargs):",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "from typing import Dict, Any\n\n",
        "source_code_len": 30,
        "target_code": "from typing import Dict, Any, Optional\n\n",
        "target_code_len": 40,
        "diff_format": "@@ -1,2 +1,2 @@\n-from typing import Dict, Any\n+from typing import Dict, Any, Optional\n \n",
        "source_code_with_indent": "from typing import Dict, Any\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "from typing import Dict, Any, Optional\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": true,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\ndef _seaborn_viz_histogram(data, x: str, contrast: str = None, **kwargs):\n    \"\"\"Plot a single histogram.\n",
        "source_code_len": 107,
        "target_code": "\ndef _seaborn_viz_histogram(data, x: str, contrast: Optional[str] = None, **kwargs):\n    \"\"\"Plot a single histogram.\n",
        "target_code_len": 117,
        "diff_format": "@@ -238,3 +279,3 @@\n \n-def _seaborn_viz_histogram(data, x: str, contrast: str = None, **kwargs):\n+def _seaborn_viz_histogram(data, x: str, contrast: Optional[str] = None, **kwargs):\n     \"\"\"Plot a single histogram.\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\n<DED>def _seaborn_viz_histogram(data, x: str, contrast: str = None, **kwargs):\n    <IND>",
        "target_code_with_indent": "\n<DED>def _seaborn_viz_histogram(data, x: str, contrast: Optional[str] = None, **kwargs):\n    <IND>"
      }
    ]
  },
  {
    "project": "data-describe/data-describe",
    "commit": "9f3635b1cc00a3c03b17ea2f15f75248b5b3726a",
    "filename": "data_describe/core/distributions.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/data-describe-data-describe/data_describe/core/distributions.py",
    "file_hunks_size": 22,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "data_describe/core/distributions.py:265:38 Incompatible variable type [9]: contrast is declared to have type `str` but is used as type `None`.",
    "message": " contrast is declared to have type `str` but is used as type `None`.",
    "rule_id": "Incompatible variable type [9]",
    "warning_line_no": 265,
    "warning_line": "def _seaborn_viz_violin(data, x: str, contrast: str = None, **kwargs):",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "from typing import Dict, Any\n\n",
        "source_code_len": 30,
        "target_code": "from typing import Dict, Any, Optional\n\n",
        "target_code_len": 40,
        "diff_format": "@@ -1,2 +1,2 @@\n-from typing import Dict, Any\n+from typing import Dict, Any, Optional\n \n",
        "source_code_with_indent": "from typing import Dict, Any\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "from typing import Dict, Any, Optional\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": true,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\ndef _seaborn_viz_violin(data, x: str, contrast: str = None, **kwargs):\n    \"\"\"Plot a single violin plot.\n",
        "source_code_len": 106,
        "target_code": "\ndef _seaborn_viz_violin(data, x: str, contrast: Optional[str] = None, **kwargs):\n    \"\"\"Plot a single violin plot.\n",
        "target_code_len": 116,
        "diff_format": "@@ -264,3 +308,3 @@\n \n-def _seaborn_viz_violin(data, x: str, contrast: str = None, **kwargs):\n+def _seaborn_viz_violin(data, x: str, contrast: Optional[str] = None, **kwargs):\n     \"\"\"Plot a single violin plot.\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\n<DED>def _seaborn_viz_violin(data, x: str, contrast: str = None, **kwargs):\n    <IND>",
        "target_code_with_indent": "\n<DED>def _seaborn_viz_violin(data, x: str, contrast: Optional[str] = None, **kwargs):\n    <IND>"
      }
    ]
  },
  {
    "project": "data-describe/data-describe",
    "commit": "9f3635b1cc00a3c03b17ea2f15f75248b5b3726a",
    "filename": "data_describe/core/distributions.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/data-describe-data-describe/data_describe/core/distributions.py",
    "file_hunks_size": 22,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "data_describe/core/distributions.py:290:35 Incompatible variable type [9]: contrast is declared to have type `str` but is used as type `None`.",
    "message": " contrast is declared to have type `str` but is used as type `None`.",
    "rule_id": "Incompatible variable type [9]",
    "warning_line_no": 290,
    "warning_line": "def _seaborn_viz_bar(data, x: str, contrast: str = None, **kwargs):",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "from typing import Dict, Any\n\n",
        "source_code_len": 30,
        "target_code": "from typing import Dict, Any, Optional\n\n",
        "target_code_len": 40,
        "diff_format": "@@ -1,2 +1,2 @@\n-from typing import Dict, Any\n+from typing import Dict, Any, Optional\n \n",
        "source_code_with_indent": "from typing import Dict, Any\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "from typing import Dict, Any, Optional\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": true,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\ndef _seaborn_viz_bar(data, x: str, contrast: str = None, **kwargs):\n    \"\"\"Plot a bar chart (count plot) for categorical features.\n",
        "source_code_len": 132,
        "target_code": "\ndef _seaborn_viz_bar(data, x: str, contrast: Optional[str] = None, **kwargs):\n    \"\"\"Plot a bar chart (count plot) for categorical features.\n",
        "target_code_len": 142,
        "diff_format": "@@ -289,3 +336,3 @@\n \n-def _seaborn_viz_bar(data, x: str, contrast: str = None, **kwargs):\n+def _seaborn_viz_bar(data, x: str, contrast: Optional[str] = None, **kwargs):\n     \"\"\"Plot a bar chart (count plot) for categorical features.\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\n<DED>def _seaborn_viz_bar(data, x: str, contrast: str = None, **kwargs):\n    <IND>",
        "target_code_with_indent": "\n<DED>def _seaborn_viz_bar(data, x: str, contrast: Optional[str] = None, **kwargs):\n    <IND>"
      }
    ]
  }
]