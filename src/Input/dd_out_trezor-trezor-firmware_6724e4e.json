[
  {
    "project": "trezor/trezor-firmware",
    "commit": "6724e4e40997c417378d22081b2a1b2fc7e61357",
    "filename": "mocks/generated/trezorcrypto.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/trezor-trezor-firmware/mocks/generated/trezorcrypto/__init__.py",
    "file_hunks_size": 10,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "mocks/generated/trezorcrypto.py:32:17 Incompatible variable type [9]: curve_name is declared to have type `str` but is used as type `None`.",
    "message": " curve_name is declared to have type `str` but is used as type `None`.",
    "rule_id": "Incompatible variable type [9]",
    "warning_line_no": 32,
    "warning_line": "                 curve_name: str = None) -> None:",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n    def update(self, data: bytes) -> bytes:\n        '''\n        Update AES context with data.\n        '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-bip32.h\nclass HDNode:\n    '''\n    BIP0032 HD node structure.\n    '''\n\n    def __init__(self,\n                 depth: int,\n                 fingerprint: int,\n                 child_num: int,\n                 chain_code: bytes,\n                 private_key: bytes = None,\n                 public_key: bytes = None,\n                 curve_name: str = None) -> None:\n        '''\n        '''\n\n    def derive(self, index: int, public: bool=False) -> None:\n        '''\n        Derive a BIP0032 child node in place.\n        '''\n\n    def derive_path(self, path: List[int]) -> None:\n        '''\n        Go through a list of indexes and iteratively derive a child node in place.\n        '''\n\n    def serialize_public(self, version: int) -> str:\n        '''\n        Serialize the public info from HD node to base58 string.\n        '''\n\n    def serialize_private(self, version: int) -> str:\n        '''\n        Serialize the private info HD node to base58 string.\n        '''\n\n    def clone(self) -> HDNode:\n        '''\n        Returns a copy of the HD node.\n        '''\n\n    def depth(self) -> int:\n        '''\n        Returns a depth of the HD node.\n        '''\n\n    def fingerprint(self) -> int:\n        '''\n        Returns a fingerprint of the HD node (hash of the parent public key).\n        '''\n\n    def child_num(self) -> int:\n        '''\n        Returns a child index of the HD node.\n        '''\n\n    def chain_code(self) -> bytes:\n        '''\n        Returns a chain code of the HD node.\n        '''\n\n    def private_key(self) -> bytes:\n        '''\n        Returns a private key of the HD node.\n        '''\n\n    def public_key(self) -> bytes:\n        '''\n        Returns a public key of the HD node.\n        '''\n\n    def address(self, version: int) -> str:\n        '''\n        Compute a base58-encoded address string from the HD node.\n        '''\n\n    def nem_address(self, network: int) -> str:\n        '''\n        Compute a NEM address string from the HD node.\n        '''\n\n    def nem_encrypt(self, transfer_public_key: bytes, iv: bytes, salt: bytes, payload: bytes) -> bytes:\n        '''\n        Encrypts payload using the transfer's public key\n        '''\n\n    def ethereum_pubkeyhash(self) -> bytes:\n        '''\n        Compute an Ethereum pubkeyhash (aka address) from the HD node.\n        '''\n\n    def deserialize(self, value: str, version_public: int, version_private: int) -> HDNode:\n        '''\n        Construct a BIP0032 HD node from a base58-serialized value.\n        '''\n\n    def from_seed(seed: bytes, curve_name: str) -> HDNode:\n        '''\n        Construct a BIP0032 HD node from a BIP0039 seed value.\n        '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\ndef find_word(prefix: str) -> Optional[str]:\n    '''\n    Return the first word from the wordlist starting with prefix.\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\ndef complete_word(prefix: str) -> int:\n    '''\n    Return possible 1-letter suffixes for given word prefix.\n    Result is a bitmask, with 'a' on the lowest bit, 'b' on the second lowest, etc.\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\ndef generate(strength: int) -> str:\n    '''\n    Generate a mnemonic of given strength (128, 160, 192, 224 and 256 bits).\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\ndef from_data(data: bytes) -> str:\n    '''\n    Generate a mnemonic from given data (of 16, 20, 24, 28 and 32 bytes).\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\ndef check(mnemonic: str) -> bool:\n    '''\n    Check whether given mnemonic is valid.\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\ndef seed(mnemonic: str, passphrase: str) -> bytes:\n    '''\n    Generate seed from mnemonic and passphrase.\n    '''\n\n",
        "source_code_len": 3868,
        "target_code": "\n    def encrypt(self, data: bytes) -> bytes:\n        '''\n        Encrypt data and update AES context.\n        '''\n\n    def decrypt(self, data: bytes) -> bytes:\n        '''\n        Decrypt data and update AES context.\n        '''\n\n",
        "target_code_len": 231,
        "diff_format": "@@ -13,145 +12,11 @@\n \n-    def update(self, data: bytes) -> bytes:\n-        '''\n-        Update AES context with data.\n-        '''\n-\n-# extmod/modtrezorcrypto/modtrezorcrypto-bip32.h\n-class HDNode:\n-    '''\n-    BIP0032 HD node structure.\n-    '''\n-\n-    def __init__(self,\n-                 depth: int,\n-                 fingerprint: int,\n-                 child_num: int,\n-                 chain_code: bytes,\n-                 private_key: bytes = None,\n-                 public_key: bytes = None,\n-                 curve_name: str = None) -> None:\n-        '''\n-        '''\n-\n-    def derive(self, index: int, public: bool=False) -> None:\n-        '''\n-        Derive a BIP0032 child node in place.\n-        '''\n-\n-    def derive_path(self, path: List[int]) -> None:\n-        '''\n-        Go through a list of indexes and iteratively derive a child node in place.\n-        '''\n-\n-    def serialize_public(self, version: int) -> str:\n-        '''\n-        Serialize the public info from HD node to base58 string.\n-        '''\n-\n-    def serialize_private(self, version: int) -> str:\n-        '''\n-        Serialize the private info HD node to base58 string.\n-        '''\n-\n-    def clone(self) -> HDNode:\n-        '''\n-        Returns a copy of the HD node.\n-        '''\n-\n-    def depth(self) -> int:\n-        '''\n-        Returns a depth of the HD node.\n-        '''\n-\n-    def fingerprint(self) -> int:\n-        '''\n-        Returns a fingerprint of the HD node (hash of the parent public key).\n-        '''\n-\n-    def child_num(self) -> int:\n-        '''\n-        Returns a child index of the HD node.\n-        '''\n-\n-    def chain_code(self) -> bytes:\n-        '''\n-        Returns a chain code of the HD node.\n-        '''\n-\n-    def private_key(self) -> bytes:\n-        '''\n-        Returns a private key of the HD node.\n-        '''\n-\n-    def public_key(self) -> bytes:\n-        '''\n-        Returns a public key of the HD node.\n-        '''\n-\n-    def address(self, version: int) -> str:\n-        '''\n-        Compute a base58-encoded address string from the HD node.\n-        '''\n-\n-    def nem_address(self, network: int) -> str:\n-        '''\n-        Compute a NEM address string from the HD node.\n-        '''\n-\n-    def nem_encrypt(self, transfer_public_key: bytes, iv: bytes, salt: bytes, payload: bytes) -> bytes:\n-        '''\n-        Encrypts payload using the transfer's public key\n-        '''\n-\n-    def ethereum_pubkeyhash(self) -> bytes:\n-        '''\n-        Compute an Ethereum pubkeyhash (aka address) from the HD node.\n-        '''\n-\n-    def deserialize(self, value: str, version_public: int, version_private: int) -> HDNode:\n-        '''\n-        Construct a BIP0032 HD node from a base58-serialized value.\n-        '''\n-\n-    def from_seed(seed: bytes, curve_name: str) -> HDNode:\n-        '''\n-        Construct a BIP0032 HD node from a BIP0039 seed value.\n-        '''\n-\n-# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\n-def find_word(prefix: str) -> Optional[str]:\n-    '''\n-    Return the first word from the wordlist starting with prefix.\n-    '''\n-\n-# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\n-def complete_word(prefix: str) -> int:\n-    '''\n-    Return possible 1-letter suffixes for given word prefix.\n-    Result is a bitmask, with 'a' on the lowest bit, 'b' on the second lowest, etc.\n-    '''\n-\n-# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\n-def generate(strength: int) -> str:\n-    '''\n-    Generate a mnemonic of given strength (128, 160, 192, 224 and 256 bits).\n-    '''\n-\n-# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\n-def from_data(data: bytes) -> str:\n-    '''\n-    Generate a mnemonic from given data (of 16, 20, 24, 28 and 32 bytes).\n-    '''\n-\n-# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\n-def check(mnemonic: str) -> bool:\n-    '''\n-    Check whether given mnemonic is valid.\n-    '''\n-\n-# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\n-def seed(mnemonic: str, passphrase: str) -> bytes:\n-    '''\n-    Generate seed from mnemonic and passphrase.\n-    '''\n+    def encrypt(self, data: bytes) -> bytes:\n+        '''\n+        Encrypt data and update AES context.\n+        '''\n+\n+    def decrypt(self, data: bytes) -> bytes:\n+        '''\n+        Decrypt data and update AES context.\n+        '''\n \n",
        "source_code_with_indent": "\n    <DED>def update(self, data: bytes) -> bytes:\n        <IND>'''\n        Update AES context with data.\n        '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-bip32.h\n<DED><DED>class HDNode:\n    <IND>'''\n    BIP0032 HD node structure.\n    '''\n\n    def __init__(self,\n                 depth: int,\n                 fingerprint: int,\n                 child_num: int,\n                 chain_code: bytes,\n                 private_key: bytes = None,\n                 public_key: bytes = None,\n                 curve_name: str = None) -> None:\n        <IND>'''\n        '''\n\n    <DED>def derive(self, index: int, public: bool=False) -> None:\n        <IND>'''\n        Derive a BIP0032 child node in place.\n        '''\n\n    <DED>def derive_path(self, path: List[int]) -> None:\n        <IND>'''\n        Go through a list of indexes and iteratively derive a child node in place.\n        '''\n\n    <DED>def serialize_public(self, version: int) -> str:\n        <IND>'''\n        Serialize the public info from HD node to base58 string.\n        '''\n\n    <DED>def serialize_private(self, version: int) -> str:\n        <IND>'''\n        Serialize the private info HD node to base58 string.\n        '''\n\n    <DED>def clone(self) -> HDNode:\n        <IND>'''\n        Returns a copy of the HD node.\n        '''\n\n    <DED>def depth(self) -> int:\n        <IND>'''\n        Returns a depth of the HD node.\n        '''\n\n    <DED>def fingerprint(self) -> int:\n        <IND>'''\n        Returns a fingerprint of the HD node (hash of the parent public key).\n        '''\n\n    <DED>def child_num(self) -> int:\n        <IND>'''\n        Returns a child index of the HD node.\n        '''\n\n    <DED>def chain_code(self) -> bytes:\n        <IND>'''\n        Returns a chain code of the HD node.\n        '''\n\n    <DED>def private_key(self) -> bytes:\n        <IND>'''\n        Returns a private key of the HD node.\n        '''\n\n    <DED>def public_key(self) -> bytes:\n        <IND>'''\n        Returns a public key of the HD node.\n        '''\n\n    <DED>def address(self, version: int) -> str:\n        <IND>'''\n        Compute a base58-encoded address string from the HD node.\n        '''\n\n    <DED>def nem_address(self, network: int) -> str:\n        <IND>'''\n        Compute a NEM address string from the HD node.\n        '''\n\n    <DED>def nem_encrypt(self, transfer_public_key: bytes, iv: bytes, salt: bytes, payload: bytes) -> bytes:\n        <IND>'''\n        Encrypts payload using the transfer's public key\n        '''\n\n    <DED>def ethereum_pubkeyhash(self) -> bytes:\n        <IND>'''\n        Compute an Ethereum pubkeyhash (aka address) from the HD node.\n        '''\n\n    <DED>def deserialize(self, value: str, version_public: int, version_private: int) -> HDNode:\n        <IND>'''\n        Construct a BIP0032 HD node from a base58-serialized value.\n        '''\n\n    <DED>def from_seed(seed: bytes, curve_name: str) -> HDNode:\n        <IND>'''\n        Construct a BIP0032 HD node from a BIP0039 seed value.\n        '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\n<DED><DED>def find_word(prefix: str) -> Optional[str]:\n    <IND>'''\n    Return the first word from the wordlist starting with prefix.\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\n<DED>def complete_word(prefix: str) -> int:\n    <IND>'''\n    Return possible 1-letter suffixes for given word prefix.\n    Result is a bitmask, with 'a' on the lowest bit, 'b' on the second lowest, etc.\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\n<DED>def generate(strength: int) -> str:\n    <IND>'''\n    Generate a mnemonic of given strength (128, 160, 192, 224 and 256 bits).\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\n<DED>def from_data(data: bytes) -> str:\n    <IND>'''\n    Generate a mnemonic from given data (of 16, 20, 24, 28 and 32 bytes).\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\n<DED>def check(mnemonic: str) -> bool:\n    <IND>'''\n    Check whether given mnemonic is valid.\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\n<DED>def seed(mnemonic: str, passphrase: str) -> bytes:\n    <IND>'''\n    Generate seed from mnemonic and passphrase.\n    '''\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n    <DED>def encrypt(self, data: bytes) -> bytes:\n        <IND>'''\n        Encrypt data and update AES context.\n        '''\n\n    <DED>def decrypt(self, data: bytes) -> bytes:\n        <IND>'''\n        Decrypt data and update AES context.\n        '''\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "trezor/trezor-firmware",
    "commit": "6724e4e40997c417378d22081b2a1b2fc7e61357",
    "filename": "mocks/generated/trezorcrypto.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/trezor-trezor-firmware/mocks/generated/trezorcrypto/__init__.py",
    "file_hunks_size": 10,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "mocks/generated/trezorcrypto.py:47:8 Incompatible return type [7]: Expected `str` but got implicit return value of `None`.",
    "message": " Expected `str` but got implicit return value of `None`.",
    "rule_id": "Incompatible return type [7]",
    "warning_line_no": 47,
    "warning_line": "        '''",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n    def update(self, data: bytes) -> bytes:\n        '''\n        Update AES context with data.\n        '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-bip32.h\nclass HDNode:\n    '''\n    BIP0032 HD node structure.\n    '''\n\n    def __init__(self,\n                 depth: int,\n                 fingerprint: int,\n                 child_num: int,\n                 chain_code: bytes,\n                 private_key: bytes = None,\n                 public_key: bytes = None,\n                 curve_name: str = None) -> None:\n        '''\n        '''\n\n    def derive(self, index: int, public: bool=False) -> None:\n        '''\n        Derive a BIP0032 child node in place.\n        '''\n\n    def derive_path(self, path: List[int]) -> None:\n        '''\n        Go through a list of indexes and iteratively derive a child node in place.\n        '''\n\n    def serialize_public(self, version: int) -> str:\n        '''\n        Serialize the public info from HD node to base58 string.\n        '''\n\n    def serialize_private(self, version: int) -> str:\n        '''\n        Serialize the private info HD node to base58 string.\n        '''\n\n    def clone(self) -> HDNode:\n        '''\n        Returns a copy of the HD node.\n        '''\n\n    def depth(self) -> int:\n        '''\n        Returns a depth of the HD node.\n        '''\n\n    def fingerprint(self) -> int:\n        '''\n        Returns a fingerprint of the HD node (hash of the parent public key).\n        '''\n\n    def child_num(self) -> int:\n        '''\n        Returns a child index of the HD node.\n        '''\n\n    def chain_code(self) -> bytes:\n        '''\n        Returns a chain code of the HD node.\n        '''\n\n    def private_key(self) -> bytes:\n        '''\n        Returns a private key of the HD node.\n        '''\n\n    def public_key(self) -> bytes:\n        '''\n        Returns a public key of the HD node.\n        '''\n\n    def address(self, version: int) -> str:\n        '''\n        Compute a base58-encoded address string from the HD node.\n        '''\n\n    def nem_address(self, network: int) -> str:\n        '''\n        Compute a NEM address string from the HD node.\n        '''\n\n    def nem_encrypt(self, transfer_public_key: bytes, iv: bytes, salt: bytes, payload: bytes) -> bytes:\n        '''\n        Encrypts payload using the transfer's public key\n        '''\n\n    def ethereum_pubkeyhash(self) -> bytes:\n        '''\n        Compute an Ethereum pubkeyhash (aka address) from the HD node.\n        '''\n\n    def deserialize(self, value: str, version_public: int, version_private: int) -> HDNode:\n        '''\n        Construct a BIP0032 HD node from a base58-serialized value.\n        '''\n\n    def from_seed(seed: bytes, curve_name: str) -> HDNode:\n        '''\n        Construct a BIP0032 HD node from a BIP0039 seed value.\n        '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\ndef find_word(prefix: str) -> Optional[str]:\n    '''\n    Return the first word from the wordlist starting with prefix.\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\ndef complete_word(prefix: str) -> int:\n    '''\n    Return possible 1-letter suffixes for given word prefix.\n    Result is a bitmask, with 'a' on the lowest bit, 'b' on the second lowest, etc.\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\ndef generate(strength: int) -> str:\n    '''\n    Generate a mnemonic of given strength (128, 160, 192, 224 and 256 bits).\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\ndef from_data(data: bytes) -> str:\n    '''\n    Generate a mnemonic from given data (of 16, 20, 24, 28 and 32 bytes).\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\ndef check(mnemonic: str) -> bool:\n    '''\n    Check whether given mnemonic is valid.\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\ndef seed(mnemonic: str, passphrase: str) -> bytes:\n    '''\n    Generate seed from mnemonic and passphrase.\n    '''\n\n",
        "source_code_len": 3868,
        "target_code": "\n    def encrypt(self, data: bytes) -> bytes:\n        '''\n        Encrypt data and update AES context.\n        '''\n\n    def decrypt(self, data: bytes) -> bytes:\n        '''\n        Decrypt data and update AES context.\n        '''\n\n",
        "target_code_len": 231,
        "diff_format": "@@ -13,145 +12,11 @@\n \n-    def update(self, data: bytes) -> bytes:\n-        '''\n-        Update AES context with data.\n-        '''\n-\n-# extmod/modtrezorcrypto/modtrezorcrypto-bip32.h\n-class HDNode:\n-    '''\n-    BIP0032 HD node structure.\n-    '''\n-\n-    def __init__(self,\n-                 depth: int,\n-                 fingerprint: int,\n-                 child_num: int,\n-                 chain_code: bytes,\n-                 private_key: bytes = None,\n-                 public_key: bytes = None,\n-                 curve_name: str = None) -> None:\n-        '''\n-        '''\n-\n-    def derive(self, index: int, public: bool=False) -> None:\n-        '''\n-        Derive a BIP0032 child node in place.\n-        '''\n-\n-    def derive_path(self, path: List[int]) -> None:\n-        '''\n-        Go through a list of indexes and iteratively derive a child node in place.\n-        '''\n-\n-    def serialize_public(self, version: int) -> str:\n-        '''\n-        Serialize the public info from HD node to base58 string.\n-        '''\n-\n-    def serialize_private(self, version: int) -> str:\n-        '''\n-        Serialize the private info HD node to base58 string.\n-        '''\n-\n-    def clone(self) -> HDNode:\n-        '''\n-        Returns a copy of the HD node.\n-        '''\n-\n-    def depth(self) -> int:\n-        '''\n-        Returns a depth of the HD node.\n-        '''\n-\n-    def fingerprint(self) -> int:\n-        '''\n-        Returns a fingerprint of the HD node (hash of the parent public key).\n-        '''\n-\n-    def child_num(self) -> int:\n-        '''\n-        Returns a child index of the HD node.\n-        '''\n-\n-    def chain_code(self) -> bytes:\n-        '''\n-        Returns a chain code of the HD node.\n-        '''\n-\n-    def private_key(self) -> bytes:\n-        '''\n-        Returns a private key of the HD node.\n-        '''\n-\n-    def public_key(self) -> bytes:\n-        '''\n-        Returns a public key of the HD node.\n-        '''\n-\n-    def address(self, version: int) -> str:\n-        '''\n-        Compute a base58-encoded address string from the HD node.\n-        '''\n-\n-    def nem_address(self, network: int) -> str:\n-        '''\n-        Compute a NEM address string from the HD node.\n-        '''\n-\n-    def nem_encrypt(self, transfer_public_key: bytes, iv: bytes, salt: bytes, payload: bytes) -> bytes:\n-        '''\n-        Encrypts payload using the transfer's public key\n-        '''\n-\n-    def ethereum_pubkeyhash(self) -> bytes:\n-        '''\n-        Compute an Ethereum pubkeyhash (aka address) from the HD node.\n-        '''\n-\n-    def deserialize(self, value: str, version_public: int, version_private: int) -> HDNode:\n-        '''\n-        Construct a BIP0032 HD node from a base58-serialized value.\n-        '''\n-\n-    def from_seed(seed: bytes, curve_name: str) -> HDNode:\n-        '''\n-        Construct a BIP0032 HD node from a BIP0039 seed value.\n-        '''\n-\n-# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\n-def find_word(prefix: str) -> Optional[str]:\n-    '''\n-    Return the first word from the wordlist starting with prefix.\n-    '''\n-\n-# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\n-def complete_word(prefix: str) -> int:\n-    '''\n-    Return possible 1-letter suffixes for given word prefix.\n-    Result is a bitmask, with 'a' on the lowest bit, 'b' on the second lowest, etc.\n-    '''\n-\n-# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\n-def generate(strength: int) -> str:\n-    '''\n-    Generate a mnemonic of given strength (128, 160, 192, 224 and 256 bits).\n-    '''\n-\n-# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\n-def from_data(data: bytes) -> str:\n-    '''\n-    Generate a mnemonic from given data (of 16, 20, 24, 28 and 32 bytes).\n-    '''\n-\n-# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\n-def check(mnemonic: str) -> bool:\n-    '''\n-    Check whether given mnemonic is valid.\n-    '''\n-\n-# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\n-def seed(mnemonic: str, passphrase: str) -> bytes:\n-    '''\n-    Generate seed from mnemonic and passphrase.\n-    '''\n+    def encrypt(self, data: bytes) -> bytes:\n+        '''\n+        Encrypt data and update AES context.\n+        '''\n+\n+    def decrypt(self, data: bytes) -> bytes:\n+        '''\n+        Decrypt data and update AES context.\n+        '''\n \n",
        "source_code_with_indent": "\n    <DED>def update(self, data: bytes) -> bytes:\n        <IND>'''\n        Update AES context with data.\n        '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-bip32.h\n<DED><DED>class HDNode:\n    <IND>'''\n    BIP0032 HD node structure.\n    '''\n\n    def __init__(self,\n                 depth: int,\n                 fingerprint: int,\n                 child_num: int,\n                 chain_code: bytes,\n                 private_key: bytes = None,\n                 public_key: bytes = None,\n                 curve_name: str = None) -> None:\n        <IND>'''\n        '''\n\n    <DED>def derive(self, index: int, public: bool=False) -> None:\n        <IND>'''\n        Derive a BIP0032 child node in place.\n        '''\n\n    <DED>def derive_path(self, path: List[int]) -> None:\n        <IND>'''\n        Go through a list of indexes and iteratively derive a child node in place.\n        '''\n\n    <DED>def serialize_public(self, version: int) -> str:\n        <IND>'''\n        Serialize the public info from HD node to base58 string.\n        '''\n\n    <DED>def serialize_private(self, version: int) -> str:\n        <IND>'''\n        Serialize the private info HD node to base58 string.\n        '''\n\n    <DED>def clone(self) -> HDNode:\n        <IND>'''\n        Returns a copy of the HD node.\n        '''\n\n    <DED>def depth(self) -> int:\n        <IND>'''\n        Returns a depth of the HD node.\n        '''\n\n    <DED>def fingerprint(self) -> int:\n        <IND>'''\n        Returns a fingerprint of the HD node (hash of the parent public key).\n        '''\n\n    <DED>def child_num(self) -> int:\n        <IND>'''\n        Returns a child index of the HD node.\n        '''\n\n    <DED>def chain_code(self) -> bytes:\n        <IND>'''\n        Returns a chain code of the HD node.\n        '''\n\n    <DED>def private_key(self) -> bytes:\n        <IND>'''\n        Returns a private key of the HD node.\n        '''\n\n    <DED>def public_key(self) -> bytes:\n        <IND>'''\n        Returns a public key of the HD node.\n        '''\n\n    <DED>def address(self, version: int) -> str:\n        <IND>'''\n        Compute a base58-encoded address string from the HD node.\n        '''\n\n    <DED>def nem_address(self, network: int) -> str:\n        <IND>'''\n        Compute a NEM address string from the HD node.\n        '''\n\n    <DED>def nem_encrypt(self, transfer_public_key: bytes, iv: bytes, salt: bytes, payload: bytes) -> bytes:\n        <IND>'''\n        Encrypts payload using the transfer's public key\n        '''\n\n    <DED>def ethereum_pubkeyhash(self) -> bytes:\n        <IND>'''\n        Compute an Ethereum pubkeyhash (aka address) from the HD node.\n        '''\n\n    <DED>def deserialize(self, value: str, version_public: int, version_private: int) -> HDNode:\n        <IND>'''\n        Construct a BIP0032 HD node from a base58-serialized value.\n        '''\n\n    <DED>def from_seed(seed: bytes, curve_name: str) -> HDNode:\n        <IND>'''\n        Construct a BIP0032 HD node from a BIP0039 seed value.\n        '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\n<DED><DED>def find_word(prefix: str) -> Optional[str]:\n    <IND>'''\n    Return the first word from the wordlist starting with prefix.\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\n<DED>def complete_word(prefix: str) -> int:\n    <IND>'''\n    Return possible 1-letter suffixes for given word prefix.\n    Result is a bitmask, with 'a' on the lowest bit, 'b' on the second lowest, etc.\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\n<DED>def generate(strength: int) -> str:\n    <IND>'''\n    Generate a mnemonic of given strength (128, 160, 192, 224 and 256 bits).\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\n<DED>def from_data(data: bytes) -> str:\n    <IND>'''\n    Generate a mnemonic from given data (of 16, 20, 24, 28 and 32 bytes).\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\n<DED>def check(mnemonic: str) -> bool:\n    <IND>'''\n    Check whether given mnemonic is valid.\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\n<DED>def seed(mnemonic: str, passphrase: str) -> bytes:\n    <IND>'''\n    Generate seed from mnemonic and passphrase.\n    '''\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n    <DED>def encrypt(self, data: bytes) -> bytes:\n        <IND>'''\n        Encrypt data and update AES context.\n        '''\n\n    <DED>def decrypt(self, data: bytes) -> bytes:\n        <IND>'''\n        Decrypt data and update AES context.\n        '''\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "trezor/trezor-firmware",
    "commit": "6724e4e40997c417378d22081b2a1b2fc7e61357",
    "filename": "mocks/generated/trezorcrypto.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/trezor-trezor-firmware/mocks/generated/trezorcrypto/__init__.py",
    "file_hunks_size": 10,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "mocks/generated/trezorcrypto.py:52:8 Incompatible return type [7]: Expected `str` but got implicit return value of `None`.",
    "message": " Expected `str` but got implicit return value of `None`.",
    "rule_id": "Incompatible return type [7]",
    "warning_line_no": 52,
    "warning_line": "        '''",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n    def update(self, data: bytes) -> bytes:\n        '''\n        Update AES context with data.\n        '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-bip32.h\nclass HDNode:\n    '''\n    BIP0032 HD node structure.\n    '''\n\n    def __init__(self,\n                 depth: int,\n                 fingerprint: int,\n                 child_num: int,\n                 chain_code: bytes,\n                 private_key: bytes = None,\n                 public_key: bytes = None,\n                 curve_name: str = None) -> None:\n        '''\n        '''\n\n    def derive(self, index: int, public: bool=False) -> None:\n        '''\n        Derive a BIP0032 child node in place.\n        '''\n\n    def derive_path(self, path: List[int]) -> None:\n        '''\n        Go through a list of indexes and iteratively derive a child node in place.\n        '''\n\n    def serialize_public(self, version: int) -> str:\n        '''\n        Serialize the public info from HD node to base58 string.\n        '''\n\n    def serialize_private(self, version: int) -> str:\n        '''\n        Serialize the private info HD node to base58 string.\n        '''\n\n    def clone(self) -> HDNode:\n        '''\n        Returns a copy of the HD node.\n        '''\n\n    def depth(self) -> int:\n        '''\n        Returns a depth of the HD node.\n        '''\n\n    def fingerprint(self) -> int:\n        '''\n        Returns a fingerprint of the HD node (hash of the parent public key).\n        '''\n\n    def child_num(self) -> int:\n        '''\n        Returns a child index of the HD node.\n        '''\n\n    def chain_code(self) -> bytes:\n        '''\n        Returns a chain code of the HD node.\n        '''\n\n    def private_key(self) -> bytes:\n        '''\n        Returns a private key of the HD node.\n        '''\n\n    def public_key(self) -> bytes:\n        '''\n        Returns a public key of the HD node.\n        '''\n\n    def address(self, version: int) -> str:\n        '''\n        Compute a base58-encoded address string from the HD node.\n        '''\n\n    def nem_address(self, network: int) -> str:\n        '''\n        Compute a NEM address string from the HD node.\n        '''\n\n    def nem_encrypt(self, transfer_public_key: bytes, iv: bytes, salt: bytes, payload: bytes) -> bytes:\n        '''\n        Encrypts payload using the transfer's public key\n        '''\n\n    def ethereum_pubkeyhash(self) -> bytes:\n        '''\n        Compute an Ethereum pubkeyhash (aka address) from the HD node.\n        '''\n\n    def deserialize(self, value: str, version_public: int, version_private: int) -> HDNode:\n        '''\n        Construct a BIP0032 HD node from a base58-serialized value.\n        '''\n\n    def from_seed(seed: bytes, curve_name: str) -> HDNode:\n        '''\n        Construct a BIP0032 HD node from a BIP0039 seed value.\n        '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\ndef find_word(prefix: str) -> Optional[str]:\n    '''\n    Return the first word from the wordlist starting with prefix.\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\ndef complete_word(prefix: str) -> int:\n    '''\n    Return possible 1-letter suffixes for given word prefix.\n    Result is a bitmask, with 'a' on the lowest bit, 'b' on the second lowest, etc.\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\ndef generate(strength: int) -> str:\n    '''\n    Generate a mnemonic of given strength (128, 160, 192, 224 and 256 bits).\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\ndef from_data(data: bytes) -> str:\n    '''\n    Generate a mnemonic from given data (of 16, 20, 24, 28 and 32 bytes).\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\ndef check(mnemonic: str) -> bool:\n    '''\n    Check whether given mnemonic is valid.\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\ndef seed(mnemonic: str, passphrase: str) -> bytes:\n    '''\n    Generate seed from mnemonic and passphrase.\n    '''\n\n",
        "source_code_len": 3868,
        "target_code": "\n    def encrypt(self, data: bytes) -> bytes:\n        '''\n        Encrypt data and update AES context.\n        '''\n\n    def decrypt(self, data: bytes) -> bytes:\n        '''\n        Decrypt data and update AES context.\n        '''\n\n",
        "target_code_len": 231,
        "diff_format": "@@ -13,145 +12,11 @@\n \n-    def update(self, data: bytes) -> bytes:\n-        '''\n-        Update AES context with data.\n-        '''\n-\n-# extmod/modtrezorcrypto/modtrezorcrypto-bip32.h\n-class HDNode:\n-    '''\n-    BIP0032 HD node structure.\n-    '''\n-\n-    def __init__(self,\n-                 depth: int,\n-                 fingerprint: int,\n-                 child_num: int,\n-                 chain_code: bytes,\n-                 private_key: bytes = None,\n-                 public_key: bytes = None,\n-                 curve_name: str = None) -> None:\n-        '''\n-        '''\n-\n-    def derive(self, index: int, public: bool=False) -> None:\n-        '''\n-        Derive a BIP0032 child node in place.\n-        '''\n-\n-    def derive_path(self, path: List[int]) -> None:\n-        '''\n-        Go through a list of indexes and iteratively derive a child node in place.\n-        '''\n-\n-    def serialize_public(self, version: int) -> str:\n-        '''\n-        Serialize the public info from HD node to base58 string.\n-        '''\n-\n-    def serialize_private(self, version: int) -> str:\n-        '''\n-        Serialize the private info HD node to base58 string.\n-        '''\n-\n-    def clone(self) -> HDNode:\n-        '''\n-        Returns a copy of the HD node.\n-        '''\n-\n-    def depth(self) -> int:\n-        '''\n-        Returns a depth of the HD node.\n-        '''\n-\n-    def fingerprint(self) -> int:\n-        '''\n-        Returns a fingerprint of the HD node (hash of the parent public key).\n-        '''\n-\n-    def child_num(self) -> int:\n-        '''\n-        Returns a child index of the HD node.\n-        '''\n-\n-    def chain_code(self) -> bytes:\n-        '''\n-        Returns a chain code of the HD node.\n-        '''\n-\n-    def private_key(self) -> bytes:\n-        '''\n-        Returns a private key of the HD node.\n-        '''\n-\n-    def public_key(self) -> bytes:\n-        '''\n-        Returns a public key of the HD node.\n-        '''\n-\n-    def address(self, version: int) -> str:\n-        '''\n-        Compute a base58-encoded address string from the HD node.\n-        '''\n-\n-    def nem_address(self, network: int) -> str:\n-        '''\n-        Compute a NEM address string from the HD node.\n-        '''\n-\n-    def nem_encrypt(self, transfer_public_key: bytes, iv: bytes, salt: bytes, payload: bytes) -> bytes:\n-        '''\n-        Encrypts payload using the transfer's public key\n-        '''\n-\n-    def ethereum_pubkeyhash(self) -> bytes:\n-        '''\n-        Compute an Ethereum pubkeyhash (aka address) from the HD node.\n-        '''\n-\n-    def deserialize(self, value: str, version_public: int, version_private: int) -> HDNode:\n-        '''\n-        Construct a BIP0032 HD node from a base58-serialized value.\n-        '''\n-\n-    def from_seed(seed: bytes, curve_name: str) -> HDNode:\n-        '''\n-        Construct a BIP0032 HD node from a BIP0039 seed value.\n-        '''\n-\n-# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\n-def find_word(prefix: str) -> Optional[str]:\n-    '''\n-    Return the first word from the wordlist starting with prefix.\n-    '''\n-\n-# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\n-def complete_word(prefix: str) -> int:\n-    '''\n-    Return possible 1-letter suffixes for given word prefix.\n-    Result is a bitmask, with 'a' on the lowest bit, 'b' on the second lowest, etc.\n-    '''\n-\n-# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\n-def generate(strength: int) -> str:\n-    '''\n-    Generate a mnemonic of given strength (128, 160, 192, 224 and 256 bits).\n-    '''\n-\n-# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\n-def from_data(data: bytes) -> str:\n-    '''\n-    Generate a mnemonic from given data (of 16, 20, 24, 28 and 32 bytes).\n-    '''\n-\n-# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\n-def check(mnemonic: str) -> bool:\n-    '''\n-    Check whether given mnemonic is valid.\n-    '''\n-\n-# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\n-def seed(mnemonic: str, passphrase: str) -> bytes:\n-    '''\n-    Generate seed from mnemonic and passphrase.\n-    '''\n+    def encrypt(self, data: bytes) -> bytes:\n+        '''\n+        Encrypt data and update AES context.\n+        '''\n+\n+    def decrypt(self, data: bytes) -> bytes:\n+        '''\n+        Decrypt data and update AES context.\n+        '''\n \n",
        "source_code_with_indent": "\n    <DED>def update(self, data: bytes) -> bytes:\n        <IND>'''\n        Update AES context with data.\n        '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-bip32.h\n<DED><DED>class HDNode:\n    <IND>'''\n    BIP0032 HD node structure.\n    '''\n\n    def __init__(self,\n                 depth: int,\n                 fingerprint: int,\n                 child_num: int,\n                 chain_code: bytes,\n                 private_key: bytes = None,\n                 public_key: bytes = None,\n                 curve_name: str = None) -> None:\n        <IND>'''\n        '''\n\n    <DED>def derive(self, index: int, public: bool=False) -> None:\n        <IND>'''\n        Derive a BIP0032 child node in place.\n        '''\n\n    <DED>def derive_path(self, path: List[int]) -> None:\n        <IND>'''\n        Go through a list of indexes and iteratively derive a child node in place.\n        '''\n\n    <DED>def serialize_public(self, version: int) -> str:\n        <IND>'''\n        Serialize the public info from HD node to base58 string.\n        '''\n\n    <DED>def serialize_private(self, version: int) -> str:\n        <IND>'''\n        Serialize the private info HD node to base58 string.\n        '''\n\n    <DED>def clone(self) -> HDNode:\n        <IND>'''\n        Returns a copy of the HD node.\n        '''\n\n    <DED>def depth(self) -> int:\n        <IND>'''\n        Returns a depth of the HD node.\n        '''\n\n    <DED>def fingerprint(self) -> int:\n        <IND>'''\n        Returns a fingerprint of the HD node (hash of the parent public key).\n        '''\n\n    <DED>def child_num(self) -> int:\n        <IND>'''\n        Returns a child index of the HD node.\n        '''\n\n    <DED>def chain_code(self) -> bytes:\n        <IND>'''\n        Returns a chain code of the HD node.\n        '''\n\n    <DED>def private_key(self) -> bytes:\n        <IND>'''\n        Returns a private key of the HD node.\n        '''\n\n    <DED>def public_key(self) -> bytes:\n        <IND>'''\n        Returns a public key of the HD node.\n        '''\n\n    <DED>def address(self, version: int) -> str:\n        <IND>'''\n        Compute a base58-encoded address string from the HD node.\n        '''\n\n    <DED>def nem_address(self, network: int) -> str:\n        <IND>'''\n        Compute a NEM address string from the HD node.\n        '''\n\n    <DED>def nem_encrypt(self, transfer_public_key: bytes, iv: bytes, salt: bytes, payload: bytes) -> bytes:\n        <IND>'''\n        Encrypts payload using the transfer's public key\n        '''\n\n    <DED>def ethereum_pubkeyhash(self) -> bytes:\n        <IND>'''\n        Compute an Ethereum pubkeyhash (aka address) from the HD node.\n        '''\n\n    <DED>def deserialize(self, value: str, version_public: int, version_private: int) -> HDNode:\n        <IND>'''\n        Construct a BIP0032 HD node from a base58-serialized value.\n        '''\n\n    <DED>def from_seed(seed: bytes, curve_name: str) -> HDNode:\n        <IND>'''\n        Construct a BIP0032 HD node from a BIP0039 seed value.\n        '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\n<DED><DED>def find_word(prefix: str) -> Optional[str]:\n    <IND>'''\n    Return the first word from the wordlist starting with prefix.\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\n<DED>def complete_word(prefix: str) -> int:\n    <IND>'''\n    Return possible 1-letter suffixes for given word prefix.\n    Result is a bitmask, with 'a' on the lowest bit, 'b' on the second lowest, etc.\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\n<DED>def generate(strength: int) -> str:\n    <IND>'''\n    Generate a mnemonic of given strength (128, 160, 192, 224 and 256 bits).\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\n<DED>def from_data(data: bytes) -> str:\n    <IND>'''\n    Generate a mnemonic from given data (of 16, 20, 24, 28 and 32 bytes).\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\n<DED>def check(mnemonic: str) -> bool:\n    <IND>'''\n    Check whether given mnemonic is valid.\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\n<DED>def seed(mnemonic: str, passphrase: str) -> bytes:\n    <IND>'''\n    Generate seed from mnemonic and passphrase.\n    '''\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n    <DED>def encrypt(self, data: bytes) -> bytes:\n        <IND>'''\n        Encrypt data and update AES context.\n        '''\n\n    <DED>def decrypt(self, data: bytes) -> bytes:\n        <IND>'''\n        Decrypt data and update AES context.\n        '''\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "trezor/trezor-firmware",
    "commit": "6724e4e40997c417378d22081b2a1b2fc7e61357",
    "filename": "mocks/generated/trezorcrypto.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/trezor-trezor-firmware/mocks/generated/trezorcrypto/__init__.py",
    "file_hunks_size": 10,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "mocks/generated/trezorcrypto.py:57:8 Incompatible return type [7]: Expected `HDNode` but got implicit return value of `None`.",
    "message": " Expected `HDNode` but got implicit return value of `None`.",
    "rule_id": "Incompatible return type [7]",
    "warning_line_no": 57,
    "warning_line": "        '''",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n    def update(self, data: bytes) -> bytes:\n        '''\n        Update AES context with data.\n        '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-bip32.h\nclass HDNode:\n    '''\n    BIP0032 HD node structure.\n    '''\n\n    def __init__(self,\n                 depth: int,\n                 fingerprint: int,\n                 child_num: int,\n                 chain_code: bytes,\n                 private_key: bytes = None,\n                 public_key: bytes = None,\n                 curve_name: str = None) -> None:\n        '''\n        '''\n\n    def derive(self, index: int, public: bool=False) -> None:\n        '''\n        Derive a BIP0032 child node in place.\n        '''\n\n    def derive_path(self, path: List[int]) -> None:\n        '''\n        Go through a list of indexes and iteratively derive a child node in place.\n        '''\n\n    def serialize_public(self, version: int) -> str:\n        '''\n        Serialize the public info from HD node to base58 string.\n        '''\n\n    def serialize_private(self, version: int) -> str:\n        '''\n        Serialize the private info HD node to base58 string.\n        '''\n\n    def clone(self) -> HDNode:\n        '''\n        Returns a copy of the HD node.\n        '''\n\n    def depth(self) -> int:\n        '''\n        Returns a depth of the HD node.\n        '''\n\n    def fingerprint(self) -> int:\n        '''\n        Returns a fingerprint of the HD node (hash of the parent public key).\n        '''\n\n    def child_num(self) -> int:\n        '''\n        Returns a child index of the HD node.\n        '''\n\n    def chain_code(self) -> bytes:\n        '''\n        Returns a chain code of the HD node.\n        '''\n\n    def private_key(self) -> bytes:\n        '''\n        Returns a private key of the HD node.\n        '''\n\n    def public_key(self) -> bytes:\n        '''\n        Returns a public key of the HD node.\n        '''\n\n    def address(self, version: int) -> str:\n        '''\n        Compute a base58-encoded address string from the HD node.\n        '''\n\n    def nem_address(self, network: int) -> str:\n        '''\n        Compute a NEM address string from the HD node.\n        '''\n\n    def nem_encrypt(self, transfer_public_key: bytes, iv: bytes, salt: bytes, payload: bytes) -> bytes:\n        '''\n        Encrypts payload using the transfer's public key\n        '''\n\n    def ethereum_pubkeyhash(self) -> bytes:\n        '''\n        Compute an Ethereum pubkeyhash (aka address) from the HD node.\n        '''\n\n    def deserialize(self, value: str, version_public: int, version_private: int) -> HDNode:\n        '''\n        Construct a BIP0032 HD node from a base58-serialized value.\n        '''\n\n    def from_seed(seed: bytes, curve_name: str) -> HDNode:\n        '''\n        Construct a BIP0032 HD node from a BIP0039 seed value.\n        '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\ndef find_word(prefix: str) -> Optional[str]:\n    '''\n    Return the first word from the wordlist starting with prefix.\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\ndef complete_word(prefix: str) -> int:\n    '''\n    Return possible 1-letter suffixes for given word prefix.\n    Result is a bitmask, with 'a' on the lowest bit, 'b' on the second lowest, etc.\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\ndef generate(strength: int) -> str:\n    '''\n    Generate a mnemonic of given strength (128, 160, 192, 224 and 256 bits).\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\ndef from_data(data: bytes) -> str:\n    '''\n    Generate a mnemonic from given data (of 16, 20, 24, 28 and 32 bytes).\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\ndef check(mnemonic: str) -> bool:\n    '''\n    Check whether given mnemonic is valid.\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\ndef seed(mnemonic: str, passphrase: str) -> bytes:\n    '''\n    Generate seed from mnemonic and passphrase.\n    '''\n\n",
        "source_code_len": 3868,
        "target_code": "\n    def encrypt(self, data: bytes) -> bytes:\n        '''\n        Encrypt data and update AES context.\n        '''\n\n    def decrypt(self, data: bytes) -> bytes:\n        '''\n        Decrypt data and update AES context.\n        '''\n\n",
        "target_code_len": 231,
        "diff_format": "@@ -13,145 +12,11 @@\n \n-    def update(self, data: bytes) -> bytes:\n-        '''\n-        Update AES context with data.\n-        '''\n-\n-# extmod/modtrezorcrypto/modtrezorcrypto-bip32.h\n-class HDNode:\n-    '''\n-    BIP0032 HD node structure.\n-    '''\n-\n-    def __init__(self,\n-                 depth: int,\n-                 fingerprint: int,\n-                 child_num: int,\n-                 chain_code: bytes,\n-                 private_key: bytes = None,\n-                 public_key: bytes = None,\n-                 curve_name: str = None) -> None:\n-        '''\n-        '''\n-\n-    def derive(self, index: int, public: bool=False) -> None:\n-        '''\n-        Derive a BIP0032 child node in place.\n-        '''\n-\n-    def derive_path(self, path: List[int]) -> None:\n-        '''\n-        Go through a list of indexes and iteratively derive a child node in place.\n-        '''\n-\n-    def serialize_public(self, version: int) -> str:\n-        '''\n-        Serialize the public info from HD node to base58 string.\n-        '''\n-\n-    def serialize_private(self, version: int) -> str:\n-        '''\n-        Serialize the private info HD node to base58 string.\n-        '''\n-\n-    def clone(self) -> HDNode:\n-        '''\n-        Returns a copy of the HD node.\n-        '''\n-\n-    def depth(self) -> int:\n-        '''\n-        Returns a depth of the HD node.\n-        '''\n-\n-    def fingerprint(self) -> int:\n-        '''\n-        Returns a fingerprint of the HD node (hash of the parent public key).\n-        '''\n-\n-    def child_num(self) -> int:\n-        '''\n-        Returns a child index of the HD node.\n-        '''\n-\n-    def chain_code(self) -> bytes:\n-        '''\n-        Returns a chain code of the HD node.\n-        '''\n-\n-    def private_key(self) -> bytes:\n-        '''\n-        Returns a private key of the HD node.\n-        '''\n-\n-    def public_key(self) -> bytes:\n-        '''\n-        Returns a public key of the HD node.\n-        '''\n-\n-    def address(self, version: int) -> str:\n-        '''\n-        Compute a base58-encoded address string from the HD node.\n-        '''\n-\n-    def nem_address(self, network: int) -> str:\n-        '''\n-        Compute a NEM address string from the HD node.\n-        '''\n-\n-    def nem_encrypt(self, transfer_public_key: bytes, iv: bytes, salt: bytes, payload: bytes) -> bytes:\n-        '''\n-        Encrypts payload using the transfer's public key\n-        '''\n-\n-    def ethereum_pubkeyhash(self) -> bytes:\n-        '''\n-        Compute an Ethereum pubkeyhash (aka address) from the HD node.\n-        '''\n-\n-    def deserialize(self, value: str, version_public: int, version_private: int) -> HDNode:\n-        '''\n-        Construct a BIP0032 HD node from a base58-serialized value.\n-        '''\n-\n-    def from_seed(seed: bytes, curve_name: str) -> HDNode:\n-        '''\n-        Construct a BIP0032 HD node from a BIP0039 seed value.\n-        '''\n-\n-# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\n-def find_word(prefix: str) -> Optional[str]:\n-    '''\n-    Return the first word from the wordlist starting with prefix.\n-    '''\n-\n-# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\n-def complete_word(prefix: str) -> int:\n-    '''\n-    Return possible 1-letter suffixes for given word prefix.\n-    Result is a bitmask, with 'a' on the lowest bit, 'b' on the second lowest, etc.\n-    '''\n-\n-# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\n-def generate(strength: int) -> str:\n-    '''\n-    Generate a mnemonic of given strength (128, 160, 192, 224 and 256 bits).\n-    '''\n-\n-# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\n-def from_data(data: bytes) -> str:\n-    '''\n-    Generate a mnemonic from given data (of 16, 20, 24, 28 and 32 bytes).\n-    '''\n-\n-# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\n-def check(mnemonic: str) -> bool:\n-    '''\n-    Check whether given mnemonic is valid.\n-    '''\n-\n-# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\n-def seed(mnemonic: str, passphrase: str) -> bytes:\n-    '''\n-    Generate seed from mnemonic and passphrase.\n-    '''\n+    def encrypt(self, data: bytes) -> bytes:\n+        '''\n+        Encrypt data and update AES context.\n+        '''\n+\n+    def decrypt(self, data: bytes) -> bytes:\n+        '''\n+        Decrypt data and update AES context.\n+        '''\n \n",
        "source_code_with_indent": "\n    <DED>def update(self, data: bytes) -> bytes:\n        <IND>'''\n        Update AES context with data.\n        '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-bip32.h\n<DED><DED>class HDNode:\n    <IND>'''\n    BIP0032 HD node structure.\n    '''\n\n    def __init__(self,\n                 depth: int,\n                 fingerprint: int,\n                 child_num: int,\n                 chain_code: bytes,\n                 private_key: bytes = None,\n                 public_key: bytes = None,\n                 curve_name: str = None) -> None:\n        <IND>'''\n        '''\n\n    <DED>def derive(self, index: int, public: bool=False) -> None:\n        <IND>'''\n        Derive a BIP0032 child node in place.\n        '''\n\n    <DED>def derive_path(self, path: List[int]) -> None:\n        <IND>'''\n        Go through a list of indexes and iteratively derive a child node in place.\n        '''\n\n    <DED>def serialize_public(self, version: int) -> str:\n        <IND>'''\n        Serialize the public info from HD node to base58 string.\n        '''\n\n    <DED>def serialize_private(self, version: int) -> str:\n        <IND>'''\n        Serialize the private info HD node to base58 string.\n        '''\n\n    <DED>def clone(self) -> HDNode:\n        <IND>'''\n        Returns a copy of the HD node.\n        '''\n\n    <DED>def depth(self) -> int:\n        <IND>'''\n        Returns a depth of the HD node.\n        '''\n\n    <DED>def fingerprint(self) -> int:\n        <IND>'''\n        Returns a fingerprint of the HD node (hash of the parent public key).\n        '''\n\n    <DED>def child_num(self) -> int:\n        <IND>'''\n        Returns a child index of the HD node.\n        '''\n\n    <DED>def chain_code(self) -> bytes:\n        <IND>'''\n        Returns a chain code of the HD node.\n        '''\n\n    <DED>def private_key(self) -> bytes:\n        <IND>'''\n        Returns a private key of the HD node.\n        '''\n\n    <DED>def public_key(self) -> bytes:\n        <IND>'''\n        Returns a public key of the HD node.\n        '''\n\n    <DED>def address(self, version: int) -> str:\n        <IND>'''\n        Compute a base58-encoded address string from the HD node.\n        '''\n\n    <DED>def nem_address(self, network: int) -> str:\n        <IND>'''\n        Compute a NEM address string from the HD node.\n        '''\n\n    <DED>def nem_encrypt(self, transfer_public_key: bytes, iv: bytes, salt: bytes, payload: bytes) -> bytes:\n        <IND>'''\n        Encrypts payload using the transfer's public key\n        '''\n\n    <DED>def ethereum_pubkeyhash(self) -> bytes:\n        <IND>'''\n        Compute an Ethereum pubkeyhash (aka address) from the HD node.\n        '''\n\n    <DED>def deserialize(self, value: str, version_public: int, version_private: int) -> HDNode:\n        <IND>'''\n        Construct a BIP0032 HD node from a base58-serialized value.\n        '''\n\n    <DED>def from_seed(seed: bytes, curve_name: str) -> HDNode:\n        <IND>'''\n        Construct a BIP0032 HD node from a BIP0039 seed value.\n        '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\n<DED><DED>def find_word(prefix: str) -> Optional[str]:\n    <IND>'''\n    Return the first word from the wordlist starting with prefix.\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\n<DED>def complete_word(prefix: str) -> int:\n    <IND>'''\n    Return possible 1-letter suffixes for given word prefix.\n    Result is a bitmask, with 'a' on the lowest bit, 'b' on the second lowest, etc.\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\n<DED>def generate(strength: int) -> str:\n    <IND>'''\n    Generate a mnemonic of given strength (128, 160, 192, 224 and 256 bits).\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\n<DED>def from_data(data: bytes) -> str:\n    <IND>'''\n    Generate a mnemonic from given data (of 16, 20, 24, 28 and 32 bytes).\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\n<DED>def check(mnemonic: str) -> bool:\n    <IND>'''\n    Check whether given mnemonic is valid.\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\n<DED>def seed(mnemonic: str, passphrase: str) -> bytes:\n    <IND>'''\n    Generate seed from mnemonic and passphrase.\n    '''\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n    <DED>def encrypt(self, data: bytes) -> bytes:\n        <IND>'''\n        Encrypt data and update AES context.\n        '''\n\n    <DED>def decrypt(self, data: bytes) -> bytes:\n        <IND>'''\n        Decrypt data and update AES context.\n        '''\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "trezor/trezor-firmware",
    "commit": "6724e4e40997c417378d22081b2a1b2fc7e61357",
    "filename": "mocks/generated/trezorcrypto.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/trezor-trezor-firmware/mocks/generated/trezorcrypto/__init__.py",
    "file_hunks_size": 10,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "mocks/generated/trezorcrypto.py:62:8 Incompatible return type [7]: Expected `int` but got implicit return value of `None`.",
    "message": " Expected `int` but got implicit return value of `None`.",
    "rule_id": "Incompatible return type [7]",
    "warning_line_no": 62,
    "warning_line": "        '''",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n    def update(self, data: bytes) -> bytes:\n        '''\n        Update AES context with data.\n        '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-bip32.h\nclass HDNode:\n    '''\n    BIP0032 HD node structure.\n    '''\n\n    def __init__(self,\n                 depth: int,\n                 fingerprint: int,\n                 child_num: int,\n                 chain_code: bytes,\n                 private_key: bytes = None,\n                 public_key: bytes = None,\n                 curve_name: str = None) -> None:\n        '''\n        '''\n\n    def derive(self, index: int, public: bool=False) -> None:\n        '''\n        Derive a BIP0032 child node in place.\n        '''\n\n    def derive_path(self, path: List[int]) -> None:\n        '''\n        Go through a list of indexes and iteratively derive a child node in place.\n        '''\n\n    def serialize_public(self, version: int) -> str:\n        '''\n        Serialize the public info from HD node to base58 string.\n        '''\n\n    def serialize_private(self, version: int) -> str:\n        '''\n        Serialize the private info HD node to base58 string.\n        '''\n\n    def clone(self) -> HDNode:\n        '''\n        Returns a copy of the HD node.\n        '''\n\n    def depth(self) -> int:\n        '''\n        Returns a depth of the HD node.\n        '''\n\n    def fingerprint(self) -> int:\n        '''\n        Returns a fingerprint of the HD node (hash of the parent public key).\n        '''\n\n    def child_num(self) -> int:\n        '''\n        Returns a child index of the HD node.\n        '''\n\n    def chain_code(self) -> bytes:\n        '''\n        Returns a chain code of the HD node.\n        '''\n\n    def private_key(self) -> bytes:\n        '''\n        Returns a private key of the HD node.\n        '''\n\n    def public_key(self) -> bytes:\n        '''\n        Returns a public key of the HD node.\n        '''\n\n    def address(self, version: int) -> str:\n        '''\n        Compute a base58-encoded address string from the HD node.\n        '''\n\n    def nem_address(self, network: int) -> str:\n        '''\n        Compute a NEM address string from the HD node.\n        '''\n\n    def nem_encrypt(self, transfer_public_key: bytes, iv: bytes, salt: bytes, payload: bytes) -> bytes:\n        '''\n        Encrypts payload using the transfer's public key\n        '''\n\n    def ethereum_pubkeyhash(self) -> bytes:\n        '''\n        Compute an Ethereum pubkeyhash (aka address) from the HD node.\n        '''\n\n    def deserialize(self, value: str, version_public: int, version_private: int) -> HDNode:\n        '''\n        Construct a BIP0032 HD node from a base58-serialized value.\n        '''\n\n    def from_seed(seed: bytes, curve_name: str) -> HDNode:\n        '''\n        Construct a BIP0032 HD node from a BIP0039 seed value.\n        '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\ndef find_word(prefix: str) -> Optional[str]:\n    '''\n    Return the first word from the wordlist starting with prefix.\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\ndef complete_word(prefix: str) -> int:\n    '''\n    Return possible 1-letter suffixes for given word prefix.\n    Result is a bitmask, with 'a' on the lowest bit, 'b' on the second lowest, etc.\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\ndef generate(strength: int) -> str:\n    '''\n    Generate a mnemonic of given strength (128, 160, 192, 224 and 256 bits).\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\ndef from_data(data: bytes) -> str:\n    '''\n    Generate a mnemonic from given data (of 16, 20, 24, 28 and 32 bytes).\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\ndef check(mnemonic: str) -> bool:\n    '''\n    Check whether given mnemonic is valid.\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\ndef seed(mnemonic: str, passphrase: str) -> bytes:\n    '''\n    Generate seed from mnemonic and passphrase.\n    '''\n\n",
        "source_code_len": 3868,
        "target_code": "\n    def encrypt(self, data: bytes) -> bytes:\n        '''\n        Encrypt data and update AES context.\n        '''\n\n    def decrypt(self, data: bytes) -> bytes:\n        '''\n        Decrypt data and update AES context.\n        '''\n\n",
        "target_code_len": 231,
        "diff_format": "@@ -13,145 +12,11 @@\n \n-    def update(self, data: bytes) -> bytes:\n-        '''\n-        Update AES context with data.\n-        '''\n-\n-# extmod/modtrezorcrypto/modtrezorcrypto-bip32.h\n-class HDNode:\n-    '''\n-    BIP0032 HD node structure.\n-    '''\n-\n-    def __init__(self,\n-                 depth: int,\n-                 fingerprint: int,\n-                 child_num: int,\n-                 chain_code: bytes,\n-                 private_key: bytes = None,\n-                 public_key: bytes = None,\n-                 curve_name: str = None) -> None:\n-        '''\n-        '''\n-\n-    def derive(self, index: int, public: bool=False) -> None:\n-        '''\n-        Derive a BIP0032 child node in place.\n-        '''\n-\n-    def derive_path(self, path: List[int]) -> None:\n-        '''\n-        Go through a list of indexes and iteratively derive a child node in place.\n-        '''\n-\n-    def serialize_public(self, version: int) -> str:\n-        '''\n-        Serialize the public info from HD node to base58 string.\n-        '''\n-\n-    def serialize_private(self, version: int) -> str:\n-        '''\n-        Serialize the private info HD node to base58 string.\n-        '''\n-\n-    def clone(self) -> HDNode:\n-        '''\n-        Returns a copy of the HD node.\n-        '''\n-\n-    def depth(self) -> int:\n-        '''\n-        Returns a depth of the HD node.\n-        '''\n-\n-    def fingerprint(self) -> int:\n-        '''\n-        Returns a fingerprint of the HD node (hash of the parent public key).\n-        '''\n-\n-    def child_num(self) -> int:\n-        '''\n-        Returns a child index of the HD node.\n-        '''\n-\n-    def chain_code(self) -> bytes:\n-        '''\n-        Returns a chain code of the HD node.\n-        '''\n-\n-    def private_key(self) -> bytes:\n-        '''\n-        Returns a private key of the HD node.\n-        '''\n-\n-    def public_key(self) -> bytes:\n-        '''\n-        Returns a public key of the HD node.\n-        '''\n-\n-    def address(self, version: int) -> str:\n-        '''\n-        Compute a base58-encoded address string from the HD node.\n-        '''\n-\n-    def nem_address(self, network: int) -> str:\n-        '''\n-        Compute a NEM address string from the HD node.\n-        '''\n-\n-    def nem_encrypt(self, transfer_public_key: bytes, iv: bytes, salt: bytes, payload: bytes) -> bytes:\n-        '''\n-        Encrypts payload using the transfer's public key\n-        '''\n-\n-    def ethereum_pubkeyhash(self) -> bytes:\n-        '''\n-        Compute an Ethereum pubkeyhash (aka address) from the HD node.\n-        '''\n-\n-    def deserialize(self, value: str, version_public: int, version_private: int) -> HDNode:\n-        '''\n-        Construct a BIP0032 HD node from a base58-serialized value.\n-        '''\n-\n-    def from_seed(seed: bytes, curve_name: str) -> HDNode:\n-        '''\n-        Construct a BIP0032 HD node from a BIP0039 seed value.\n-        '''\n-\n-# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\n-def find_word(prefix: str) -> Optional[str]:\n-    '''\n-    Return the first word from the wordlist starting with prefix.\n-    '''\n-\n-# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\n-def complete_word(prefix: str) -> int:\n-    '''\n-    Return possible 1-letter suffixes for given word prefix.\n-    Result is a bitmask, with 'a' on the lowest bit, 'b' on the second lowest, etc.\n-    '''\n-\n-# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\n-def generate(strength: int) -> str:\n-    '''\n-    Generate a mnemonic of given strength (128, 160, 192, 224 and 256 bits).\n-    '''\n-\n-# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\n-def from_data(data: bytes) -> str:\n-    '''\n-    Generate a mnemonic from given data (of 16, 20, 24, 28 and 32 bytes).\n-    '''\n-\n-# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\n-def check(mnemonic: str) -> bool:\n-    '''\n-    Check whether given mnemonic is valid.\n-    '''\n-\n-# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\n-def seed(mnemonic: str, passphrase: str) -> bytes:\n-    '''\n-    Generate seed from mnemonic and passphrase.\n-    '''\n+    def encrypt(self, data: bytes) -> bytes:\n+        '''\n+        Encrypt data and update AES context.\n+        '''\n+\n+    def decrypt(self, data: bytes) -> bytes:\n+        '''\n+        Decrypt data and update AES context.\n+        '''\n \n",
        "source_code_with_indent": "\n    <DED>def update(self, data: bytes) -> bytes:\n        <IND>'''\n        Update AES context with data.\n        '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-bip32.h\n<DED><DED>class HDNode:\n    <IND>'''\n    BIP0032 HD node structure.\n    '''\n\n    def __init__(self,\n                 depth: int,\n                 fingerprint: int,\n                 child_num: int,\n                 chain_code: bytes,\n                 private_key: bytes = None,\n                 public_key: bytes = None,\n                 curve_name: str = None) -> None:\n        <IND>'''\n        '''\n\n    <DED>def derive(self, index: int, public: bool=False) -> None:\n        <IND>'''\n        Derive a BIP0032 child node in place.\n        '''\n\n    <DED>def derive_path(self, path: List[int]) -> None:\n        <IND>'''\n        Go through a list of indexes and iteratively derive a child node in place.\n        '''\n\n    <DED>def serialize_public(self, version: int) -> str:\n        <IND>'''\n        Serialize the public info from HD node to base58 string.\n        '''\n\n    <DED>def serialize_private(self, version: int) -> str:\n        <IND>'''\n        Serialize the private info HD node to base58 string.\n        '''\n\n    <DED>def clone(self) -> HDNode:\n        <IND>'''\n        Returns a copy of the HD node.\n        '''\n\n    <DED>def depth(self) -> int:\n        <IND>'''\n        Returns a depth of the HD node.\n        '''\n\n    <DED>def fingerprint(self) -> int:\n        <IND>'''\n        Returns a fingerprint of the HD node (hash of the parent public key).\n        '''\n\n    <DED>def child_num(self) -> int:\n        <IND>'''\n        Returns a child index of the HD node.\n        '''\n\n    <DED>def chain_code(self) -> bytes:\n        <IND>'''\n        Returns a chain code of the HD node.\n        '''\n\n    <DED>def private_key(self) -> bytes:\n        <IND>'''\n        Returns a private key of the HD node.\n        '''\n\n    <DED>def public_key(self) -> bytes:\n        <IND>'''\n        Returns a public key of the HD node.\n        '''\n\n    <DED>def address(self, version: int) -> str:\n        <IND>'''\n        Compute a base58-encoded address string from the HD node.\n        '''\n\n    <DED>def nem_address(self, network: int) -> str:\n        <IND>'''\n        Compute a NEM address string from the HD node.\n        '''\n\n    <DED>def nem_encrypt(self, transfer_public_key: bytes, iv: bytes, salt: bytes, payload: bytes) -> bytes:\n        <IND>'''\n        Encrypts payload using the transfer's public key\n        '''\n\n    <DED>def ethereum_pubkeyhash(self) -> bytes:\n        <IND>'''\n        Compute an Ethereum pubkeyhash (aka address) from the HD node.\n        '''\n\n    <DED>def deserialize(self, value: str, version_public: int, version_private: int) -> HDNode:\n        <IND>'''\n        Construct a BIP0032 HD node from a base58-serialized value.\n        '''\n\n    <DED>def from_seed(seed: bytes, curve_name: str) -> HDNode:\n        <IND>'''\n        Construct a BIP0032 HD node from a BIP0039 seed value.\n        '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\n<DED><DED>def find_word(prefix: str) -> Optional[str]:\n    <IND>'''\n    Return the first word from the wordlist starting with prefix.\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\n<DED>def complete_word(prefix: str) -> int:\n    <IND>'''\n    Return possible 1-letter suffixes for given word prefix.\n    Result is a bitmask, with 'a' on the lowest bit, 'b' on the second lowest, etc.\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\n<DED>def generate(strength: int) -> str:\n    <IND>'''\n    Generate a mnemonic of given strength (128, 160, 192, 224 and 256 bits).\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\n<DED>def from_data(data: bytes) -> str:\n    <IND>'''\n    Generate a mnemonic from given data (of 16, 20, 24, 28 and 32 bytes).\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\n<DED>def check(mnemonic: str) -> bool:\n    <IND>'''\n    Check whether given mnemonic is valid.\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\n<DED>def seed(mnemonic: str, passphrase: str) -> bytes:\n    <IND>'''\n    Generate seed from mnemonic and passphrase.\n    '''\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n    <DED>def encrypt(self, data: bytes) -> bytes:\n        <IND>'''\n        Encrypt data and update AES context.\n        '''\n\n    <DED>def decrypt(self, data: bytes) -> bytes:\n        <IND>'''\n        Decrypt data and update AES context.\n        '''\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "trezor/trezor-firmware",
    "commit": "6724e4e40997c417378d22081b2a1b2fc7e61357",
    "filename": "mocks/generated/trezorcrypto.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/trezor-trezor-firmware/mocks/generated/trezorcrypto/__init__.py",
    "file_hunks_size": 10,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "mocks/generated/trezorcrypto.py:67:8 Incompatible return type [7]: Expected `int` but got implicit return value of `None`.",
    "message": " Expected `int` but got implicit return value of `None`.",
    "rule_id": "Incompatible return type [7]",
    "warning_line_no": 67,
    "warning_line": "        '''",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n    def update(self, data: bytes) -> bytes:\n        '''\n        Update AES context with data.\n        '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-bip32.h\nclass HDNode:\n    '''\n    BIP0032 HD node structure.\n    '''\n\n    def __init__(self,\n                 depth: int,\n                 fingerprint: int,\n                 child_num: int,\n                 chain_code: bytes,\n                 private_key: bytes = None,\n                 public_key: bytes = None,\n                 curve_name: str = None) -> None:\n        '''\n        '''\n\n    def derive(self, index: int, public: bool=False) -> None:\n        '''\n        Derive a BIP0032 child node in place.\n        '''\n\n    def derive_path(self, path: List[int]) -> None:\n        '''\n        Go through a list of indexes and iteratively derive a child node in place.\n        '''\n\n    def serialize_public(self, version: int) -> str:\n        '''\n        Serialize the public info from HD node to base58 string.\n        '''\n\n    def serialize_private(self, version: int) -> str:\n        '''\n        Serialize the private info HD node to base58 string.\n        '''\n\n    def clone(self) -> HDNode:\n        '''\n        Returns a copy of the HD node.\n        '''\n\n    def depth(self) -> int:\n        '''\n        Returns a depth of the HD node.\n        '''\n\n    def fingerprint(self) -> int:\n        '''\n        Returns a fingerprint of the HD node (hash of the parent public key).\n        '''\n\n    def child_num(self) -> int:\n        '''\n        Returns a child index of the HD node.\n        '''\n\n    def chain_code(self) -> bytes:\n        '''\n        Returns a chain code of the HD node.\n        '''\n\n    def private_key(self) -> bytes:\n        '''\n        Returns a private key of the HD node.\n        '''\n\n    def public_key(self) -> bytes:\n        '''\n        Returns a public key of the HD node.\n        '''\n\n    def address(self, version: int) -> str:\n        '''\n        Compute a base58-encoded address string from the HD node.\n        '''\n\n    def nem_address(self, network: int) -> str:\n        '''\n        Compute a NEM address string from the HD node.\n        '''\n\n    def nem_encrypt(self, transfer_public_key: bytes, iv: bytes, salt: bytes, payload: bytes) -> bytes:\n        '''\n        Encrypts payload using the transfer's public key\n        '''\n\n    def ethereum_pubkeyhash(self) -> bytes:\n        '''\n        Compute an Ethereum pubkeyhash (aka address) from the HD node.\n        '''\n\n    def deserialize(self, value: str, version_public: int, version_private: int) -> HDNode:\n        '''\n        Construct a BIP0032 HD node from a base58-serialized value.\n        '''\n\n    def from_seed(seed: bytes, curve_name: str) -> HDNode:\n        '''\n        Construct a BIP0032 HD node from a BIP0039 seed value.\n        '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\ndef find_word(prefix: str) -> Optional[str]:\n    '''\n    Return the first word from the wordlist starting with prefix.\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\ndef complete_word(prefix: str) -> int:\n    '''\n    Return possible 1-letter suffixes for given word prefix.\n    Result is a bitmask, with 'a' on the lowest bit, 'b' on the second lowest, etc.\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\ndef generate(strength: int) -> str:\n    '''\n    Generate a mnemonic of given strength (128, 160, 192, 224 and 256 bits).\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\ndef from_data(data: bytes) -> str:\n    '''\n    Generate a mnemonic from given data (of 16, 20, 24, 28 and 32 bytes).\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\ndef check(mnemonic: str) -> bool:\n    '''\n    Check whether given mnemonic is valid.\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\ndef seed(mnemonic: str, passphrase: str) -> bytes:\n    '''\n    Generate seed from mnemonic and passphrase.\n    '''\n\n",
        "source_code_len": 3868,
        "target_code": "\n    def encrypt(self, data: bytes) -> bytes:\n        '''\n        Encrypt data and update AES context.\n        '''\n\n    def decrypt(self, data: bytes) -> bytes:\n        '''\n        Decrypt data and update AES context.\n        '''\n\n",
        "target_code_len": 231,
        "diff_format": "@@ -13,145 +12,11 @@\n \n-    def update(self, data: bytes) -> bytes:\n-        '''\n-        Update AES context with data.\n-        '''\n-\n-# extmod/modtrezorcrypto/modtrezorcrypto-bip32.h\n-class HDNode:\n-    '''\n-    BIP0032 HD node structure.\n-    '''\n-\n-    def __init__(self,\n-                 depth: int,\n-                 fingerprint: int,\n-                 child_num: int,\n-                 chain_code: bytes,\n-                 private_key: bytes = None,\n-                 public_key: bytes = None,\n-                 curve_name: str = None) -> None:\n-        '''\n-        '''\n-\n-    def derive(self, index: int, public: bool=False) -> None:\n-        '''\n-        Derive a BIP0032 child node in place.\n-        '''\n-\n-    def derive_path(self, path: List[int]) -> None:\n-        '''\n-        Go through a list of indexes and iteratively derive a child node in place.\n-        '''\n-\n-    def serialize_public(self, version: int) -> str:\n-        '''\n-        Serialize the public info from HD node to base58 string.\n-        '''\n-\n-    def serialize_private(self, version: int) -> str:\n-        '''\n-        Serialize the private info HD node to base58 string.\n-        '''\n-\n-    def clone(self) -> HDNode:\n-        '''\n-        Returns a copy of the HD node.\n-        '''\n-\n-    def depth(self) -> int:\n-        '''\n-        Returns a depth of the HD node.\n-        '''\n-\n-    def fingerprint(self) -> int:\n-        '''\n-        Returns a fingerprint of the HD node (hash of the parent public key).\n-        '''\n-\n-    def child_num(self) -> int:\n-        '''\n-        Returns a child index of the HD node.\n-        '''\n-\n-    def chain_code(self) -> bytes:\n-        '''\n-        Returns a chain code of the HD node.\n-        '''\n-\n-    def private_key(self) -> bytes:\n-        '''\n-        Returns a private key of the HD node.\n-        '''\n-\n-    def public_key(self) -> bytes:\n-        '''\n-        Returns a public key of the HD node.\n-        '''\n-\n-    def address(self, version: int) -> str:\n-        '''\n-        Compute a base58-encoded address string from the HD node.\n-        '''\n-\n-    def nem_address(self, network: int) -> str:\n-        '''\n-        Compute a NEM address string from the HD node.\n-        '''\n-\n-    def nem_encrypt(self, transfer_public_key: bytes, iv: bytes, salt: bytes, payload: bytes) -> bytes:\n-        '''\n-        Encrypts payload using the transfer's public key\n-        '''\n-\n-    def ethereum_pubkeyhash(self) -> bytes:\n-        '''\n-        Compute an Ethereum pubkeyhash (aka address) from the HD node.\n-        '''\n-\n-    def deserialize(self, value: str, version_public: int, version_private: int) -> HDNode:\n-        '''\n-        Construct a BIP0032 HD node from a base58-serialized value.\n-        '''\n-\n-    def from_seed(seed: bytes, curve_name: str) -> HDNode:\n-        '''\n-        Construct a BIP0032 HD node from a BIP0039 seed value.\n-        '''\n-\n-# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\n-def find_word(prefix: str) -> Optional[str]:\n-    '''\n-    Return the first word from the wordlist starting with prefix.\n-    '''\n-\n-# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\n-def complete_word(prefix: str) -> int:\n-    '''\n-    Return possible 1-letter suffixes for given word prefix.\n-    Result is a bitmask, with 'a' on the lowest bit, 'b' on the second lowest, etc.\n-    '''\n-\n-# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\n-def generate(strength: int) -> str:\n-    '''\n-    Generate a mnemonic of given strength (128, 160, 192, 224 and 256 bits).\n-    '''\n-\n-# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\n-def from_data(data: bytes) -> str:\n-    '''\n-    Generate a mnemonic from given data (of 16, 20, 24, 28 and 32 bytes).\n-    '''\n-\n-# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\n-def check(mnemonic: str) -> bool:\n-    '''\n-    Check whether given mnemonic is valid.\n-    '''\n-\n-# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\n-def seed(mnemonic: str, passphrase: str) -> bytes:\n-    '''\n-    Generate seed from mnemonic and passphrase.\n-    '''\n+    def encrypt(self, data: bytes) -> bytes:\n+        '''\n+        Encrypt data and update AES context.\n+        '''\n+\n+    def decrypt(self, data: bytes) -> bytes:\n+        '''\n+        Decrypt data and update AES context.\n+        '''\n \n",
        "source_code_with_indent": "\n    <DED>def update(self, data: bytes) -> bytes:\n        <IND>'''\n        Update AES context with data.\n        '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-bip32.h\n<DED><DED>class HDNode:\n    <IND>'''\n    BIP0032 HD node structure.\n    '''\n\n    def __init__(self,\n                 depth: int,\n                 fingerprint: int,\n                 child_num: int,\n                 chain_code: bytes,\n                 private_key: bytes = None,\n                 public_key: bytes = None,\n                 curve_name: str = None) -> None:\n        <IND>'''\n        '''\n\n    <DED>def derive(self, index: int, public: bool=False) -> None:\n        <IND>'''\n        Derive a BIP0032 child node in place.\n        '''\n\n    <DED>def derive_path(self, path: List[int]) -> None:\n        <IND>'''\n        Go through a list of indexes and iteratively derive a child node in place.\n        '''\n\n    <DED>def serialize_public(self, version: int) -> str:\n        <IND>'''\n        Serialize the public info from HD node to base58 string.\n        '''\n\n    <DED>def serialize_private(self, version: int) -> str:\n        <IND>'''\n        Serialize the private info HD node to base58 string.\n        '''\n\n    <DED>def clone(self) -> HDNode:\n        <IND>'''\n        Returns a copy of the HD node.\n        '''\n\n    <DED>def depth(self) -> int:\n        <IND>'''\n        Returns a depth of the HD node.\n        '''\n\n    <DED>def fingerprint(self) -> int:\n        <IND>'''\n        Returns a fingerprint of the HD node (hash of the parent public key).\n        '''\n\n    <DED>def child_num(self) -> int:\n        <IND>'''\n        Returns a child index of the HD node.\n        '''\n\n    <DED>def chain_code(self) -> bytes:\n        <IND>'''\n        Returns a chain code of the HD node.\n        '''\n\n    <DED>def private_key(self) -> bytes:\n        <IND>'''\n        Returns a private key of the HD node.\n        '''\n\n    <DED>def public_key(self) -> bytes:\n        <IND>'''\n        Returns a public key of the HD node.\n        '''\n\n    <DED>def address(self, version: int) -> str:\n        <IND>'''\n        Compute a base58-encoded address string from the HD node.\n        '''\n\n    <DED>def nem_address(self, network: int) -> str:\n        <IND>'''\n        Compute a NEM address string from the HD node.\n        '''\n\n    <DED>def nem_encrypt(self, transfer_public_key: bytes, iv: bytes, salt: bytes, payload: bytes) -> bytes:\n        <IND>'''\n        Encrypts payload using the transfer's public key\n        '''\n\n    <DED>def ethereum_pubkeyhash(self) -> bytes:\n        <IND>'''\n        Compute an Ethereum pubkeyhash (aka address) from the HD node.\n        '''\n\n    <DED>def deserialize(self, value: str, version_public: int, version_private: int) -> HDNode:\n        <IND>'''\n        Construct a BIP0032 HD node from a base58-serialized value.\n        '''\n\n    <DED>def from_seed(seed: bytes, curve_name: str) -> HDNode:\n        <IND>'''\n        Construct a BIP0032 HD node from a BIP0039 seed value.\n        '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\n<DED><DED>def find_word(prefix: str) -> Optional[str]:\n    <IND>'''\n    Return the first word from the wordlist starting with prefix.\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\n<DED>def complete_word(prefix: str) -> int:\n    <IND>'''\n    Return possible 1-letter suffixes for given word prefix.\n    Result is a bitmask, with 'a' on the lowest bit, 'b' on the second lowest, etc.\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\n<DED>def generate(strength: int) -> str:\n    <IND>'''\n    Generate a mnemonic of given strength (128, 160, 192, 224 and 256 bits).\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\n<DED>def from_data(data: bytes) -> str:\n    <IND>'''\n    Generate a mnemonic from given data (of 16, 20, 24, 28 and 32 bytes).\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\n<DED>def check(mnemonic: str) -> bool:\n    <IND>'''\n    Check whether given mnemonic is valid.\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\n<DED>def seed(mnemonic: str, passphrase: str) -> bytes:\n    <IND>'''\n    Generate seed from mnemonic and passphrase.\n    '''\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n    <DED>def encrypt(self, data: bytes) -> bytes:\n        <IND>'''\n        Encrypt data and update AES context.\n        '''\n\n    <DED>def decrypt(self, data: bytes) -> bytes:\n        <IND>'''\n        Decrypt data and update AES context.\n        '''\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "trezor/trezor-firmware",
    "commit": "6724e4e40997c417378d22081b2a1b2fc7e61357",
    "filename": "mocks/generated/trezorcrypto.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/trezor-trezor-firmware/mocks/generated/trezorcrypto/__init__.py",
    "file_hunks_size": 10,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "mocks/generated/trezorcrypto.py:72:8 Incompatible return type [7]: Expected `int` but got implicit return value of `None`.",
    "message": " Expected `int` but got implicit return value of `None`.",
    "rule_id": "Incompatible return type [7]",
    "warning_line_no": 72,
    "warning_line": "        '''",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n    def update(self, data: bytes) -> bytes:\n        '''\n        Update AES context with data.\n        '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-bip32.h\nclass HDNode:\n    '''\n    BIP0032 HD node structure.\n    '''\n\n    def __init__(self,\n                 depth: int,\n                 fingerprint: int,\n                 child_num: int,\n                 chain_code: bytes,\n                 private_key: bytes = None,\n                 public_key: bytes = None,\n                 curve_name: str = None) -> None:\n        '''\n        '''\n\n    def derive(self, index: int, public: bool=False) -> None:\n        '''\n        Derive a BIP0032 child node in place.\n        '''\n\n    def derive_path(self, path: List[int]) -> None:\n        '''\n        Go through a list of indexes and iteratively derive a child node in place.\n        '''\n\n    def serialize_public(self, version: int) -> str:\n        '''\n        Serialize the public info from HD node to base58 string.\n        '''\n\n    def serialize_private(self, version: int) -> str:\n        '''\n        Serialize the private info HD node to base58 string.\n        '''\n\n    def clone(self) -> HDNode:\n        '''\n        Returns a copy of the HD node.\n        '''\n\n    def depth(self) -> int:\n        '''\n        Returns a depth of the HD node.\n        '''\n\n    def fingerprint(self) -> int:\n        '''\n        Returns a fingerprint of the HD node (hash of the parent public key).\n        '''\n\n    def child_num(self) -> int:\n        '''\n        Returns a child index of the HD node.\n        '''\n\n    def chain_code(self) -> bytes:\n        '''\n        Returns a chain code of the HD node.\n        '''\n\n    def private_key(self) -> bytes:\n        '''\n        Returns a private key of the HD node.\n        '''\n\n    def public_key(self) -> bytes:\n        '''\n        Returns a public key of the HD node.\n        '''\n\n    def address(self, version: int) -> str:\n        '''\n        Compute a base58-encoded address string from the HD node.\n        '''\n\n    def nem_address(self, network: int) -> str:\n        '''\n        Compute a NEM address string from the HD node.\n        '''\n\n    def nem_encrypt(self, transfer_public_key: bytes, iv: bytes, salt: bytes, payload: bytes) -> bytes:\n        '''\n        Encrypts payload using the transfer's public key\n        '''\n\n    def ethereum_pubkeyhash(self) -> bytes:\n        '''\n        Compute an Ethereum pubkeyhash (aka address) from the HD node.\n        '''\n\n    def deserialize(self, value: str, version_public: int, version_private: int) -> HDNode:\n        '''\n        Construct a BIP0032 HD node from a base58-serialized value.\n        '''\n\n    def from_seed(seed: bytes, curve_name: str) -> HDNode:\n        '''\n        Construct a BIP0032 HD node from a BIP0039 seed value.\n        '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\ndef find_word(prefix: str) -> Optional[str]:\n    '''\n    Return the first word from the wordlist starting with prefix.\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\ndef complete_word(prefix: str) -> int:\n    '''\n    Return possible 1-letter suffixes for given word prefix.\n    Result is a bitmask, with 'a' on the lowest bit, 'b' on the second lowest, etc.\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\ndef generate(strength: int) -> str:\n    '''\n    Generate a mnemonic of given strength (128, 160, 192, 224 and 256 bits).\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\ndef from_data(data: bytes) -> str:\n    '''\n    Generate a mnemonic from given data (of 16, 20, 24, 28 and 32 bytes).\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\ndef check(mnemonic: str) -> bool:\n    '''\n    Check whether given mnemonic is valid.\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\ndef seed(mnemonic: str, passphrase: str) -> bytes:\n    '''\n    Generate seed from mnemonic and passphrase.\n    '''\n\n",
        "source_code_len": 3868,
        "target_code": "\n    def encrypt(self, data: bytes) -> bytes:\n        '''\n        Encrypt data and update AES context.\n        '''\n\n    def decrypt(self, data: bytes) -> bytes:\n        '''\n        Decrypt data and update AES context.\n        '''\n\n",
        "target_code_len": 231,
        "diff_format": "@@ -13,145 +12,11 @@\n \n-    def update(self, data: bytes) -> bytes:\n-        '''\n-        Update AES context with data.\n-        '''\n-\n-# extmod/modtrezorcrypto/modtrezorcrypto-bip32.h\n-class HDNode:\n-    '''\n-    BIP0032 HD node structure.\n-    '''\n-\n-    def __init__(self,\n-                 depth: int,\n-                 fingerprint: int,\n-                 child_num: int,\n-                 chain_code: bytes,\n-                 private_key: bytes = None,\n-                 public_key: bytes = None,\n-                 curve_name: str = None) -> None:\n-        '''\n-        '''\n-\n-    def derive(self, index: int, public: bool=False) -> None:\n-        '''\n-        Derive a BIP0032 child node in place.\n-        '''\n-\n-    def derive_path(self, path: List[int]) -> None:\n-        '''\n-        Go through a list of indexes and iteratively derive a child node in place.\n-        '''\n-\n-    def serialize_public(self, version: int) -> str:\n-        '''\n-        Serialize the public info from HD node to base58 string.\n-        '''\n-\n-    def serialize_private(self, version: int) -> str:\n-        '''\n-        Serialize the private info HD node to base58 string.\n-        '''\n-\n-    def clone(self) -> HDNode:\n-        '''\n-        Returns a copy of the HD node.\n-        '''\n-\n-    def depth(self) -> int:\n-        '''\n-        Returns a depth of the HD node.\n-        '''\n-\n-    def fingerprint(self) -> int:\n-        '''\n-        Returns a fingerprint of the HD node (hash of the parent public key).\n-        '''\n-\n-    def child_num(self) -> int:\n-        '''\n-        Returns a child index of the HD node.\n-        '''\n-\n-    def chain_code(self) -> bytes:\n-        '''\n-        Returns a chain code of the HD node.\n-        '''\n-\n-    def private_key(self) -> bytes:\n-        '''\n-        Returns a private key of the HD node.\n-        '''\n-\n-    def public_key(self) -> bytes:\n-        '''\n-        Returns a public key of the HD node.\n-        '''\n-\n-    def address(self, version: int) -> str:\n-        '''\n-        Compute a base58-encoded address string from the HD node.\n-        '''\n-\n-    def nem_address(self, network: int) -> str:\n-        '''\n-        Compute a NEM address string from the HD node.\n-        '''\n-\n-    def nem_encrypt(self, transfer_public_key: bytes, iv: bytes, salt: bytes, payload: bytes) -> bytes:\n-        '''\n-        Encrypts payload using the transfer's public key\n-        '''\n-\n-    def ethereum_pubkeyhash(self) -> bytes:\n-        '''\n-        Compute an Ethereum pubkeyhash (aka address) from the HD node.\n-        '''\n-\n-    def deserialize(self, value: str, version_public: int, version_private: int) -> HDNode:\n-        '''\n-        Construct a BIP0032 HD node from a base58-serialized value.\n-        '''\n-\n-    def from_seed(seed: bytes, curve_name: str) -> HDNode:\n-        '''\n-        Construct a BIP0032 HD node from a BIP0039 seed value.\n-        '''\n-\n-# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\n-def find_word(prefix: str) -> Optional[str]:\n-    '''\n-    Return the first word from the wordlist starting with prefix.\n-    '''\n-\n-# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\n-def complete_word(prefix: str) -> int:\n-    '''\n-    Return possible 1-letter suffixes for given word prefix.\n-    Result is a bitmask, with 'a' on the lowest bit, 'b' on the second lowest, etc.\n-    '''\n-\n-# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\n-def generate(strength: int) -> str:\n-    '''\n-    Generate a mnemonic of given strength (128, 160, 192, 224 and 256 bits).\n-    '''\n-\n-# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\n-def from_data(data: bytes) -> str:\n-    '''\n-    Generate a mnemonic from given data (of 16, 20, 24, 28 and 32 bytes).\n-    '''\n-\n-# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\n-def check(mnemonic: str) -> bool:\n-    '''\n-    Check whether given mnemonic is valid.\n-    '''\n-\n-# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\n-def seed(mnemonic: str, passphrase: str) -> bytes:\n-    '''\n-    Generate seed from mnemonic and passphrase.\n-    '''\n+    def encrypt(self, data: bytes) -> bytes:\n+        '''\n+        Encrypt data and update AES context.\n+        '''\n+\n+    def decrypt(self, data: bytes) -> bytes:\n+        '''\n+        Decrypt data and update AES context.\n+        '''\n \n",
        "source_code_with_indent": "\n    <DED>def update(self, data: bytes) -> bytes:\n        <IND>'''\n        Update AES context with data.\n        '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-bip32.h\n<DED><DED>class HDNode:\n    <IND>'''\n    BIP0032 HD node structure.\n    '''\n\n    def __init__(self,\n                 depth: int,\n                 fingerprint: int,\n                 child_num: int,\n                 chain_code: bytes,\n                 private_key: bytes = None,\n                 public_key: bytes = None,\n                 curve_name: str = None) -> None:\n        <IND>'''\n        '''\n\n    <DED>def derive(self, index: int, public: bool=False) -> None:\n        <IND>'''\n        Derive a BIP0032 child node in place.\n        '''\n\n    <DED>def derive_path(self, path: List[int]) -> None:\n        <IND>'''\n        Go through a list of indexes and iteratively derive a child node in place.\n        '''\n\n    <DED>def serialize_public(self, version: int) -> str:\n        <IND>'''\n        Serialize the public info from HD node to base58 string.\n        '''\n\n    <DED>def serialize_private(self, version: int) -> str:\n        <IND>'''\n        Serialize the private info HD node to base58 string.\n        '''\n\n    <DED>def clone(self) -> HDNode:\n        <IND>'''\n        Returns a copy of the HD node.\n        '''\n\n    <DED>def depth(self) -> int:\n        <IND>'''\n        Returns a depth of the HD node.\n        '''\n\n    <DED>def fingerprint(self) -> int:\n        <IND>'''\n        Returns a fingerprint of the HD node (hash of the parent public key).\n        '''\n\n    <DED>def child_num(self) -> int:\n        <IND>'''\n        Returns a child index of the HD node.\n        '''\n\n    <DED>def chain_code(self) -> bytes:\n        <IND>'''\n        Returns a chain code of the HD node.\n        '''\n\n    <DED>def private_key(self) -> bytes:\n        <IND>'''\n        Returns a private key of the HD node.\n        '''\n\n    <DED>def public_key(self) -> bytes:\n        <IND>'''\n        Returns a public key of the HD node.\n        '''\n\n    <DED>def address(self, version: int) -> str:\n        <IND>'''\n        Compute a base58-encoded address string from the HD node.\n        '''\n\n    <DED>def nem_address(self, network: int) -> str:\n        <IND>'''\n        Compute a NEM address string from the HD node.\n        '''\n\n    <DED>def nem_encrypt(self, transfer_public_key: bytes, iv: bytes, salt: bytes, payload: bytes) -> bytes:\n        <IND>'''\n        Encrypts payload using the transfer's public key\n        '''\n\n    <DED>def ethereum_pubkeyhash(self) -> bytes:\n        <IND>'''\n        Compute an Ethereum pubkeyhash (aka address) from the HD node.\n        '''\n\n    <DED>def deserialize(self, value: str, version_public: int, version_private: int) -> HDNode:\n        <IND>'''\n        Construct a BIP0032 HD node from a base58-serialized value.\n        '''\n\n    <DED>def from_seed(seed: bytes, curve_name: str) -> HDNode:\n        <IND>'''\n        Construct a BIP0032 HD node from a BIP0039 seed value.\n        '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\n<DED><DED>def find_word(prefix: str) -> Optional[str]:\n    <IND>'''\n    Return the first word from the wordlist starting with prefix.\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\n<DED>def complete_word(prefix: str) -> int:\n    <IND>'''\n    Return possible 1-letter suffixes for given word prefix.\n    Result is a bitmask, with 'a' on the lowest bit, 'b' on the second lowest, etc.\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\n<DED>def generate(strength: int) -> str:\n    <IND>'''\n    Generate a mnemonic of given strength (128, 160, 192, 224 and 256 bits).\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\n<DED>def from_data(data: bytes) -> str:\n    <IND>'''\n    Generate a mnemonic from given data (of 16, 20, 24, 28 and 32 bytes).\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\n<DED>def check(mnemonic: str) -> bool:\n    <IND>'''\n    Check whether given mnemonic is valid.\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\n<DED>def seed(mnemonic: str, passphrase: str) -> bytes:\n    <IND>'''\n    Generate seed from mnemonic and passphrase.\n    '''\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n    <DED>def encrypt(self, data: bytes) -> bytes:\n        <IND>'''\n        Encrypt data and update AES context.\n        '''\n\n    <DED>def decrypt(self, data: bytes) -> bytes:\n        <IND>'''\n        Decrypt data and update AES context.\n        '''\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "trezor/trezor-firmware",
    "commit": "6724e4e40997c417378d22081b2a1b2fc7e61357",
    "filename": "mocks/generated/trezorcrypto.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/trezor-trezor-firmware/mocks/generated/trezorcrypto/__init__.py",
    "file_hunks_size": 10,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "mocks/generated/trezorcrypto.py:92:8 Incompatible return type [7]: Expected `str` but got implicit return value of `None`.",
    "message": " Expected `str` but got implicit return value of `None`.",
    "rule_id": "Incompatible return type [7]",
    "warning_line_no": 92,
    "warning_line": "        '''",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n    def update(self, data: bytes) -> bytes:\n        '''\n        Update AES context with data.\n        '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-bip32.h\nclass HDNode:\n    '''\n    BIP0032 HD node structure.\n    '''\n\n    def __init__(self,\n                 depth: int,\n                 fingerprint: int,\n                 child_num: int,\n                 chain_code: bytes,\n                 private_key: bytes = None,\n                 public_key: bytes = None,\n                 curve_name: str = None) -> None:\n        '''\n        '''\n\n    def derive(self, index: int, public: bool=False) -> None:\n        '''\n        Derive a BIP0032 child node in place.\n        '''\n\n    def derive_path(self, path: List[int]) -> None:\n        '''\n        Go through a list of indexes and iteratively derive a child node in place.\n        '''\n\n    def serialize_public(self, version: int) -> str:\n        '''\n        Serialize the public info from HD node to base58 string.\n        '''\n\n    def serialize_private(self, version: int) -> str:\n        '''\n        Serialize the private info HD node to base58 string.\n        '''\n\n    def clone(self) -> HDNode:\n        '''\n        Returns a copy of the HD node.\n        '''\n\n    def depth(self) -> int:\n        '''\n        Returns a depth of the HD node.\n        '''\n\n    def fingerprint(self) -> int:\n        '''\n        Returns a fingerprint of the HD node (hash of the parent public key).\n        '''\n\n    def child_num(self) -> int:\n        '''\n        Returns a child index of the HD node.\n        '''\n\n    def chain_code(self) -> bytes:\n        '''\n        Returns a chain code of the HD node.\n        '''\n\n    def private_key(self) -> bytes:\n        '''\n        Returns a private key of the HD node.\n        '''\n\n    def public_key(self) -> bytes:\n        '''\n        Returns a public key of the HD node.\n        '''\n\n    def address(self, version: int) -> str:\n        '''\n        Compute a base58-encoded address string from the HD node.\n        '''\n\n    def nem_address(self, network: int) -> str:\n        '''\n        Compute a NEM address string from the HD node.\n        '''\n\n    def nem_encrypt(self, transfer_public_key: bytes, iv: bytes, salt: bytes, payload: bytes) -> bytes:\n        '''\n        Encrypts payload using the transfer's public key\n        '''\n\n    def ethereum_pubkeyhash(self) -> bytes:\n        '''\n        Compute an Ethereum pubkeyhash (aka address) from the HD node.\n        '''\n\n    def deserialize(self, value: str, version_public: int, version_private: int) -> HDNode:\n        '''\n        Construct a BIP0032 HD node from a base58-serialized value.\n        '''\n\n    def from_seed(seed: bytes, curve_name: str) -> HDNode:\n        '''\n        Construct a BIP0032 HD node from a BIP0039 seed value.\n        '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\ndef find_word(prefix: str) -> Optional[str]:\n    '''\n    Return the first word from the wordlist starting with prefix.\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\ndef complete_word(prefix: str) -> int:\n    '''\n    Return possible 1-letter suffixes for given word prefix.\n    Result is a bitmask, with 'a' on the lowest bit, 'b' on the second lowest, etc.\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\ndef generate(strength: int) -> str:\n    '''\n    Generate a mnemonic of given strength (128, 160, 192, 224 and 256 bits).\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\ndef from_data(data: bytes) -> str:\n    '''\n    Generate a mnemonic from given data (of 16, 20, 24, 28 and 32 bytes).\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\ndef check(mnemonic: str) -> bool:\n    '''\n    Check whether given mnemonic is valid.\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\ndef seed(mnemonic: str, passphrase: str) -> bytes:\n    '''\n    Generate seed from mnemonic and passphrase.\n    '''\n\n",
        "source_code_len": 3868,
        "target_code": "\n    def encrypt(self, data: bytes) -> bytes:\n        '''\n        Encrypt data and update AES context.\n        '''\n\n    def decrypt(self, data: bytes) -> bytes:\n        '''\n        Decrypt data and update AES context.\n        '''\n\n",
        "target_code_len": 231,
        "diff_format": "@@ -13,145 +12,11 @@\n \n-    def update(self, data: bytes) -> bytes:\n-        '''\n-        Update AES context with data.\n-        '''\n-\n-# extmod/modtrezorcrypto/modtrezorcrypto-bip32.h\n-class HDNode:\n-    '''\n-    BIP0032 HD node structure.\n-    '''\n-\n-    def __init__(self,\n-                 depth: int,\n-                 fingerprint: int,\n-                 child_num: int,\n-                 chain_code: bytes,\n-                 private_key: bytes = None,\n-                 public_key: bytes = None,\n-                 curve_name: str = None) -> None:\n-        '''\n-        '''\n-\n-    def derive(self, index: int, public: bool=False) -> None:\n-        '''\n-        Derive a BIP0032 child node in place.\n-        '''\n-\n-    def derive_path(self, path: List[int]) -> None:\n-        '''\n-        Go through a list of indexes and iteratively derive a child node in place.\n-        '''\n-\n-    def serialize_public(self, version: int) -> str:\n-        '''\n-        Serialize the public info from HD node to base58 string.\n-        '''\n-\n-    def serialize_private(self, version: int) -> str:\n-        '''\n-        Serialize the private info HD node to base58 string.\n-        '''\n-\n-    def clone(self) -> HDNode:\n-        '''\n-        Returns a copy of the HD node.\n-        '''\n-\n-    def depth(self) -> int:\n-        '''\n-        Returns a depth of the HD node.\n-        '''\n-\n-    def fingerprint(self) -> int:\n-        '''\n-        Returns a fingerprint of the HD node (hash of the parent public key).\n-        '''\n-\n-    def child_num(self) -> int:\n-        '''\n-        Returns a child index of the HD node.\n-        '''\n-\n-    def chain_code(self) -> bytes:\n-        '''\n-        Returns a chain code of the HD node.\n-        '''\n-\n-    def private_key(self) -> bytes:\n-        '''\n-        Returns a private key of the HD node.\n-        '''\n-\n-    def public_key(self) -> bytes:\n-        '''\n-        Returns a public key of the HD node.\n-        '''\n-\n-    def address(self, version: int) -> str:\n-        '''\n-        Compute a base58-encoded address string from the HD node.\n-        '''\n-\n-    def nem_address(self, network: int) -> str:\n-        '''\n-        Compute a NEM address string from the HD node.\n-        '''\n-\n-    def nem_encrypt(self, transfer_public_key: bytes, iv: bytes, salt: bytes, payload: bytes) -> bytes:\n-        '''\n-        Encrypts payload using the transfer's public key\n-        '''\n-\n-    def ethereum_pubkeyhash(self) -> bytes:\n-        '''\n-        Compute an Ethereum pubkeyhash (aka address) from the HD node.\n-        '''\n-\n-    def deserialize(self, value: str, version_public: int, version_private: int) -> HDNode:\n-        '''\n-        Construct a BIP0032 HD node from a base58-serialized value.\n-        '''\n-\n-    def from_seed(seed: bytes, curve_name: str) -> HDNode:\n-        '''\n-        Construct a BIP0032 HD node from a BIP0039 seed value.\n-        '''\n-\n-# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\n-def find_word(prefix: str) -> Optional[str]:\n-    '''\n-    Return the first word from the wordlist starting with prefix.\n-    '''\n-\n-# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\n-def complete_word(prefix: str) -> int:\n-    '''\n-    Return possible 1-letter suffixes for given word prefix.\n-    Result is a bitmask, with 'a' on the lowest bit, 'b' on the second lowest, etc.\n-    '''\n-\n-# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\n-def generate(strength: int) -> str:\n-    '''\n-    Generate a mnemonic of given strength (128, 160, 192, 224 and 256 bits).\n-    '''\n-\n-# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\n-def from_data(data: bytes) -> str:\n-    '''\n-    Generate a mnemonic from given data (of 16, 20, 24, 28 and 32 bytes).\n-    '''\n-\n-# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\n-def check(mnemonic: str) -> bool:\n-    '''\n-    Check whether given mnemonic is valid.\n-    '''\n-\n-# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\n-def seed(mnemonic: str, passphrase: str) -> bytes:\n-    '''\n-    Generate seed from mnemonic and passphrase.\n-    '''\n+    def encrypt(self, data: bytes) -> bytes:\n+        '''\n+        Encrypt data and update AES context.\n+        '''\n+\n+    def decrypt(self, data: bytes) -> bytes:\n+        '''\n+        Decrypt data and update AES context.\n+        '''\n \n",
        "source_code_with_indent": "\n    <DED>def update(self, data: bytes) -> bytes:\n        <IND>'''\n        Update AES context with data.\n        '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-bip32.h\n<DED><DED>class HDNode:\n    <IND>'''\n    BIP0032 HD node structure.\n    '''\n\n    def __init__(self,\n                 depth: int,\n                 fingerprint: int,\n                 child_num: int,\n                 chain_code: bytes,\n                 private_key: bytes = None,\n                 public_key: bytes = None,\n                 curve_name: str = None) -> None:\n        <IND>'''\n        '''\n\n    <DED>def derive(self, index: int, public: bool=False) -> None:\n        <IND>'''\n        Derive a BIP0032 child node in place.\n        '''\n\n    <DED>def derive_path(self, path: List[int]) -> None:\n        <IND>'''\n        Go through a list of indexes and iteratively derive a child node in place.\n        '''\n\n    <DED>def serialize_public(self, version: int) -> str:\n        <IND>'''\n        Serialize the public info from HD node to base58 string.\n        '''\n\n    <DED>def serialize_private(self, version: int) -> str:\n        <IND>'''\n        Serialize the private info HD node to base58 string.\n        '''\n\n    <DED>def clone(self) -> HDNode:\n        <IND>'''\n        Returns a copy of the HD node.\n        '''\n\n    <DED>def depth(self) -> int:\n        <IND>'''\n        Returns a depth of the HD node.\n        '''\n\n    <DED>def fingerprint(self) -> int:\n        <IND>'''\n        Returns a fingerprint of the HD node (hash of the parent public key).\n        '''\n\n    <DED>def child_num(self) -> int:\n        <IND>'''\n        Returns a child index of the HD node.\n        '''\n\n    <DED>def chain_code(self) -> bytes:\n        <IND>'''\n        Returns a chain code of the HD node.\n        '''\n\n    <DED>def private_key(self) -> bytes:\n        <IND>'''\n        Returns a private key of the HD node.\n        '''\n\n    <DED>def public_key(self) -> bytes:\n        <IND>'''\n        Returns a public key of the HD node.\n        '''\n\n    <DED>def address(self, version: int) -> str:\n        <IND>'''\n        Compute a base58-encoded address string from the HD node.\n        '''\n\n    <DED>def nem_address(self, network: int) -> str:\n        <IND>'''\n        Compute a NEM address string from the HD node.\n        '''\n\n    <DED>def nem_encrypt(self, transfer_public_key: bytes, iv: bytes, salt: bytes, payload: bytes) -> bytes:\n        <IND>'''\n        Encrypts payload using the transfer's public key\n        '''\n\n    <DED>def ethereum_pubkeyhash(self) -> bytes:\n        <IND>'''\n        Compute an Ethereum pubkeyhash (aka address) from the HD node.\n        '''\n\n    <DED>def deserialize(self, value: str, version_public: int, version_private: int) -> HDNode:\n        <IND>'''\n        Construct a BIP0032 HD node from a base58-serialized value.\n        '''\n\n    <DED>def from_seed(seed: bytes, curve_name: str) -> HDNode:\n        <IND>'''\n        Construct a BIP0032 HD node from a BIP0039 seed value.\n        '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\n<DED><DED>def find_word(prefix: str) -> Optional[str]:\n    <IND>'''\n    Return the first word from the wordlist starting with prefix.\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\n<DED>def complete_word(prefix: str) -> int:\n    <IND>'''\n    Return possible 1-letter suffixes for given word prefix.\n    Result is a bitmask, with 'a' on the lowest bit, 'b' on the second lowest, etc.\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\n<DED>def generate(strength: int) -> str:\n    <IND>'''\n    Generate a mnemonic of given strength (128, 160, 192, 224 and 256 bits).\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\n<DED>def from_data(data: bytes) -> str:\n    <IND>'''\n    Generate a mnemonic from given data (of 16, 20, 24, 28 and 32 bytes).\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\n<DED>def check(mnemonic: str) -> bool:\n    <IND>'''\n    Check whether given mnemonic is valid.\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\n<DED>def seed(mnemonic: str, passphrase: str) -> bytes:\n    <IND>'''\n    Generate seed from mnemonic and passphrase.\n    '''\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n    <DED>def encrypt(self, data: bytes) -> bytes:\n        <IND>'''\n        Encrypt data and update AES context.\n        '''\n\n    <DED>def decrypt(self, data: bytes) -> bytes:\n        <IND>'''\n        Decrypt data and update AES context.\n        '''\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "trezor/trezor-firmware",
    "commit": "6724e4e40997c417378d22081b2a1b2fc7e61357",
    "filename": "mocks/generated/trezorcrypto.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/trezor-trezor-firmware/mocks/generated/trezorcrypto/__init__.py",
    "file_hunks_size": 10,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "mocks/generated/trezorcrypto.py:97:8 Incompatible return type [7]: Expected `str` but got implicit return value of `None`.",
    "message": " Expected `str` but got implicit return value of `None`.",
    "rule_id": "Incompatible return type [7]",
    "warning_line_no": 97,
    "warning_line": "        '''",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n    def update(self, data: bytes) -> bytes:\n        '''\n        Update AES context with data.\n        '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-bip32.h\nclass HDNode:\n    '''\n    BIP0032 HD node structure.\n    '''\n\n    def __init__(self,\n                 depth: int,\n                 fingerprint: int,\n                 child_num: int,\n                 chain_code: bytes,\n                 private_key: bytes = None,\n                 public_key: bytes = None,\n                 curve_name: str = None) -> None:\n        '''\n        '''\n\n    def derive(self, index: int, public: bool=False) -> None:\n        '''\n        Derive a BIP0032 child node in place.\n        '''\n\n    def derive_path(self, path: List[int]) -> None:\n        '''\n        Go through a list of indexes and iteratively derive a child node in place.\n        '''\n\n    def serialize_public(self, version: int) -> str:\n        '''\n        Serialize the public info from HD node to base58 string.\n        '''\n\n    def serialize_private(self, version: int) -> str:\n        '''\n        Serialize the private info HD node to base58 string.\n        '''\n\n    def clone(self) -> HDNode:\n        '''\n        Returns a copy of the HD node.\n        '''\n\n    def depth(self) -> int:\n        '''\n        Returns a depth of the HD node.\n        '''\n\n    def fingerprint(self) -> int:\n        '''\n        Returns a fingerprint of the HD node (hash of the parent public key).\n        '''\n\n    def child_num(self) -> int:\n        '''\n        Returns a child index of the HD node.\n        '''\n\n    def chain_code(self) -> bytes:\n        '''\n        Returns a chain code of the HD node.\n        '''\n\n    def private_key(self) -> bytes:\n        '''\n        Returns a private key of the HD node.\n        '''\n\n    def public_key(self) -> bytes:\n        '''\n        Returns a public key of the HD node.\n        '''\n\n    def address(self, version: int) -> str:\n        '''\n        Compute a base58-encoded address string from the HD node.\n        '''\n\n    def nem_address(self, network: int) -> str:\n        '''\n        Compute a NEM address string from the HD node.\n        '''\n\n    def nem_encrypt(self, transfer_public_key: bytes, iv: bytes, salt: bytes, payload: bytes) -> bytes:\n        '''\n        Encrypts payload using the transfer's public key\n        '''\n\n    def ethereum_pubkeyhash(self) -> bytes:\n        '''\n        Compute an Ethereum pubkeyhash (aka address) from the HD node.\n        '''\n\n    def deserialize(self, value: str, version_public: int, version_private: int) -> HDNode:\n        '''\n        Construct a BIP0032 HD node from a base58-serialized value.\n        '''\n\n    def from_seed(seed: bytes, curve_name: str) -> HDNode:\n        '''\n        Construct a BIP0032 HD node from a BIP0039 seed value.\n        '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\ndef find_word(prefix: str) -> Optional[str]:\n    '''\n    Return the first word from the wordlist starting with prefix.\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\ndef complete_word(prefix: str) -> int:\n    '''\n    Return possible 1-letter suffixes for given word prefix.\n    Result is a bitmask, with 'a' on the lowest bit, 'b' on the second lowest, etc.\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\ndef generate(strength: int) -> str:\n    '''\n    Generate a mnemonic of given strength (128, 160, 192, 224 and 256 bits).\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\ndef from_data(data: bytes) -> str:\n    '''\n    Generate a mnemonic from given data (of 16, 20, 24, 28 and 32 bytes).\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\ndef check(mnemonic: str) -> bool:\n    '''\n    Check whether given mnemonic is valid.\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\ndef seed(mnemonic: str, passphrase: str) -> bytes:\n    '''\n    Generate seed from mnemonic and passphrase.\n    '''\n\n",
        "source_code_len": 3868,
        "target_code": "\n    def encrypt(self, data: bytes) -> bytes:\n        '''\n        Encrypt data and update AES context.\n        '''\n\n    def decrypt(self, data: bytes) -> bytes:\n        '''\n        Decrypt data and update AES context.\n        '''\n\n",
        "target_code_len": 231,
        "diff_format": "@@ -13,145 +12,11 @@\n \n-    def update(self, data: bytes) -> bytes:\n-        '''\n-        Update AES context with data.\n-        '''\n-\n-# extmod/modtrezorcrypto/modtrezorcrypto-bip32.h\n-class HDNode:\n-    '''\n-    BIP0032 HD node structure.\n-    '''\n-\n-    def __init__(self,\n-                 depth: int,\n-                 fingerprint: int,\n-                 child_num: int,\n-                 chain_code: bytes,\n-                 private_key: bytes = None,\n-                 public_key: bytes = None,\n-                 curve_name: str = None) -> None:\n-        '''\n-        '''\n-\n-    def derive(self, index: int, public: bool=False) -> None:\n-        '''\n-        Derive a BIP0032 child node in place.\n-        '''\n-\n-    def derive_path(self, path: List[int]) -> None:\n-        '''\n-        Go through a list of indexes and iteratively derive a child node in place.\n-        '''\n-\n-    def serialize_public(self, version: int) -> str:\n-        '''\n-        Serialize the public info from HD node to base58 string.\n-        '''\n-\n-    def serialize_private(self, version: int) -> str:\n-        '''\n-        Serialize the private info HD node to base58 string.\n-        '''\n-\n-    def clone(self) -> HDNode:\n-        '''\n-        Returns a copy of the HD node.\n-        '''\n-\n-    def depth(self) -> int:\n-        '''\n-        Returns a depth of the HD node.\n-        '''\n-\n-    def fingerprint(self) -> int:\n-        '''\n-        Returns a fingerprint of the HD node (hash of the parent public key).\n-        '''\n-\n-    def child_num(self) -> int:\n-        '''\n-        Returns a child index of the HD node.\n-        '''\n-\n-    def chain_code(self) -> bytes:\n-        '''\n-        Returns a chain code of the HD node.\n-        '''\n-\n-    def private_key(self) -> bytes:\n-        '''\n-        Returns a private key of the HD node.\n-        '''\n-\n-    def public_key(self) -> bytes:\n-        '''\n-        Returns a public key of the HD node.\n-        '''\n-\n-    def address(self, version: int) -> str:\n-        '''\n-        Compute a base58-encoded address string from the HD node.\n-        '''\n-\n-    def nem_address(self, network: int) -> str:\n-        '''\n-        Compute a NEM address string from the HD node.\n-        '''\n-\n-    def nem_encrypt(self, transfer_public_key: bytes, iv: bytes, salt: bytes, payload: bytes) -> bytes:\n-        '''\n-        Encrypts payload using the transfer's public key\n-        '''\n-\n-    def ethereum_pubkeyhash(self) -> bytes:\n-        '''\n-        Compute an Ethereum pubkeyhash (aka address) from the HD node.\n-        '''\n-\n-    def deserialize(self, value: str, version_public: int, version_private: int) -> HDNode:\n-        '''\n-        Construct a BIP0032 HD node from a base58-serialized value.\n-        '''\n-\n-    def from_seed(seed: bytes, curve_name: str) -> HDNode:\n-        '''\n-        Construct a BIP0032 HD node from a BIP0039 seed value.\n-        '''\n-\n-# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\n-def find_word(prefix: str) -> Optional[str]:\n-    '''\n-    Return the first word from the wordlist starting with prefix.\n-    '''\n-\n-# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\n-def complete_word(prefix: str) -> int:\n-    '''\n-    Return possible 1-letter suffixes for given word prefix.\n-    Result is a bitmask, with 'a' on the lowest bit, 'b' on the second lowest, etc.\n-    '''\n-\n-# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\n-def generate(strength: int) -> str:\n-    '''\n-    Generate a mnemonic of given strength (128, 160, 192, 224 and 256 bits).\n-    '''\n-\n-# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\n-def from_data(data: bytes) -> str:\n-    '''\n-    Generate a mnemonic from given data (of 16, 20, 24, 28 and 32 bytes).\n-    '''\n-\n-# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\n-def check(mnemonic: str) -> bool:\n-    '''\n-    Check whether given mnemonic is valid.\n-    '''\n-\n-# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\n-def seed(mnemonic: str, passphrase: str) -> bytes:\n-    '''\n-    Generate seed from mnemonic and passphrase.\n-    '''\n+    def encrypt(self, data: bytes) -> bytes:\n+        '''\n+        Encrypt data and update AES context.\n+        '''\n+\n+    def decrypt(self, data: bytes) -> bytes:\n+        '''\n+        Decrypt data and update AES context.\n+        '''\n \n",
        "source_code_with_indent": "\n    <DED>def update(self, data: bytes) -> bytes:\n        <IND>'''\n        Update AES context with data.\n        '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-bip32.h\n<DED><DED>class HDNode:\n    <IND>'''\n    BIP0032 HD node structure.\n    '''\n\n    def __init__(self,\n                 depth: int,\n                 fingerprint: int,\n                 child_num: int,\n                 chain_code: bytes,\n                 private_key: bytes = None,\n                 public_key: bytes = None,\n                 curve_name: str = None) -> None:\n        <IND>'''\n        '''\n\n    <DED>def derive(self, index: int, public: bool=False) -> None:\n        <IND>'''\n        Derive a BIP0032 child node in place.\n        '''\n\n    <DED>def derive_path(self, path: List[int]) -> None:\n        <IND>'''\n        Go through a list of indexes and iteratively derive a child node in place.\n        '''\n\n    <DED>def serialize_public(self, version: int) -> str:\n        <IND>'''\n        Serialize the public info from HD node to base58 string.\n        '''\n\n    <DED>def serialize_private(self, version: int) -> str:\n        <IND>'''\n        Serialize the private info HD node to base58 string.\n        '''\n\n    <DED>def clone(self) -> HDNode:\n        <IND>'''\n        Returns a copy of the HD node.\n        '''\n\n    <DED>def depth(self) -> int:\n        <IND>'''\n        Returns a depth of the HD node.\n        '''\n\n    <DED>def fingerprint(self) -> int:\n        <IND>'''\n        Returns a fingerprint of the HD node (hash of the parent public key).\n        '''\n\n    <DED>def child_num(self) -> int:\n        <IND>'''\n        Returns a child index of the HD node.\n        '''\n\n    <DED>def chain_code(self) -> bytes:\n        <IND>'''\n        Returns a chain code of the HD node.\n        '''\n\n    <DED>def private_key(self) -> bytes:\n        <IND>'''\n        Returns a private key of the HD node.\n        '''\n\n    <DED>def public_key(self) -> bytes:\n        <IND>'''\n        Returns a public key of the HD node.\n        '''\n\n    <DED>def address(self, version: int) -> str:\n        <IND>'''\n        Compute a base58-encoded address string from the HD node.\n        '''\n\n    <DED>def nem_address(self, network: int) -> str:\n        <IND>'''\n        Compute a NEM address string from the HD node.\n        '''\n\n    <DED>def nem_encrypt(self, transfer_public_key: bytes, iv: bytes, salt: bytes, payload: bytes) -> bytes:\n        <IND>'''\n        Encrypts payload using the transfer's public key\n        '''\n\n    <DED>def ethereum_pubkeyhash(self) -> bytes:\n        <IND>'''\n        Compute an Ethereum pubkeyhash (aka address) from the HD node.\n        '''\n\n    <DED>def deserialize(self, value: str, version_public: int, version_private: int) -> HDNode:\n        <IND>'''\n        Construct a BIP0032 HD node from a base58-serialized value.\n        '''\n\n    <DED>def from_seed(seed: bytes, curve_name: str) -> HDNode:\n        <IND>'''\n        Construct a BIP0032 HD node from a BIP0039 seed value.\n        '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\n<DED><DED>def find_word(prefix: str) -> Optional[str]:\n    <IND>'''\n    Return the first word from the wordlist starting with prefix.\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\n<DED>def complete_word(prefix: str) -> int:\n    <IND>'''\n    Return possible 1-letter suffixes for given word prefix.\n    Result is a bitmask, with 'a' on the lowest bit, 'b' on the second lowest, etc.\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\n<DED>def generate(strength: int) -> str:\n    <IND>'''\n    Generate a mnemonic of given strength (128, 160, 192, 224 and 256 bits).\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\n<DED>def from_data(data: bytes) -> str:\n    <IND>'''\n    Generate a mnemonic from given data (of 16, 20, 24, 28 and 32 bytes).\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\n<DED>def check(mnemonic: str) -> bool:\n    <IND>'''\n    Check whether given mnemonic is valid.\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\n<DED>def seed(mnemonic: str, passphrase: str) -> bytes:\n    <IND>'''\n    Generate seed from mnemonic and passphrase.\n    '''\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n    <DED>def encrypt(self, data: bytes) -> bytes:\n        <IND>'''\n        Encrypt data and update AES context.\n        '''\n\n    <DED>def decrypt(self, data: bytes) -> bytes:\n        <IND>'''\n        Decrypt data and update AES context.\n        '''\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "trezor/trezor-firmware",
    "commit": "6724e4e40997c417378d22081b2a1b2fc7e61357",
    "filename": "mocks/generated/trezorcrypto.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/trezor-trezor-firmware/mocks/generated/trezorcrypto/__init__.py",
    "file_hunks_size": 10,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "mocks/generated/trezorcrypto.py:112:8 Incompatible return type [7]: Expected `HDNode` but got implicit return value of `None`.",
    "message": " Expected `HDNode` but got implicit return value of `None`.",
    "rule_id": "Incompatible return type [7]",
    "warning_line_no": 112,
    "warning_line": "        '''",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n    def update(self, data: bytes) -> bytes:\n        '''\n        Update AES context with data.\n        '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-bip32.h\nclass HDNode:\n    '''\n    BIP0032 HD node structure.\n    '''\n\n    def __init__(self,\n                 depth: int,\n                 fingerprint: int,\n                 child_num: int,\n                 chain_code: bytes,\n                 private_key: bytes = None,\n                 public_key: bytes = None,\n                 curve_name: str = None) -> None:\n        '''\n        '''\n\n    def derive(self, index: int, public: bool=False) -> None:\n        '''\n        Derive a BIP0032 child node in place.\n        '''\n\n    def derive_path(self, path: List[int]) -> None:\n        '''\n        Go through a list of indexes and iteratively derive a child node in place.\n        '''\n\n    def serialize_public(self, version: int) -> str:\n        '''\n        Serialize the public info from HD node to base58 string.\n        '''\n\n    def serialize_private(self, version: int) -> str:\n        '''\n        Serialize the private info HD node to base58 string.\n        '''\n\n    def clone(self) -> HDNode:\n        '''\n        Returns a copy of the HD node.\n        '''\n\n    def depth(self) -> int:\n        '''\n        Returns a depth of the HD node.\n        '''\n\n    def fingerprint(self) -> int:\n        '''\n        Returns a fingerprint of the HD node (hash of the parent public key).\n        '''\n\n    def child_num(self) -> int:\n        '''\n        Returns a child index of the HD node.\n        '''\n\n    def chain_code(self) -> bytes:\n        '''\n        Returns a chain code of the HD node.\n        '''\n\n    def private_key(self) -> bytes:\n        '''\n        Returns a private key of the HD node.\n        '''\n\n    def public_key(self) -> bytes:\n        '''\n        Returns a public key of the HD node.\n        '''\n\n    def address(self, version: int) -> str:\n        '''\n        Compute a base58-encoded address string from the HD node.\n        '''\n\n    def nem_address(self, network: int) -> str:\n        '''\n        Compute a NEM address string from the HD node.\n        '''\n\n    def nem_encrypt(self, transfer_public_key: bytes, iv: bytes, salt: bytes, payload: bytes) -> bytes:\n        '''\n        Encrypts payload using the transfer's public key\n        '''\n\n    def ethereum_pubkeyhash(self) -> bytes:\n        '''\n        Compute an Ethereum pubkeyhash (aka address) from the HD node.\n        '''\n\n    def deserialize(self, value: str, version_public: int, version_private: int) -> HDNode:\n        '''\n        Construct a BIP0032 HD node from a base58-serialized value.\n        '''\n\n    def from_seed(seed: bytes, curve_name: str) -> HDNode:\n        '''\n        Construct a BIP0032 HD node from a BIP0039 seed value.\n        '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\ndef find_word(prefix: str) -> Optional[str]:\n    '''\n    Return the first word from the wordlist starting with prefix.\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\ndef complete_word(prefix: str) -> int:\n    '''\n    Return possible 1-letter suffixes for given word prefix.\n    Result is a bitmask, with 'a' on the lowest bit, 'b' on the second lowest, etc.\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\ndef generate(strength: int) -> str:\n    '''\n    Generate a mnemonic of given strength (128, 160, 192, 224 and 256 bits).\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\ndef from_data(data: bytes) -> str:\n    '''\n    Generate a mnemonic from given data (of 16, 20, 24, 28 and 32 bytes).\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\ndef check(mnemonic: str) -> bool:\n    '''\n    Check whether given mnemonic is valid.\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\ndef seed(mnemonic: str, passphrase: str) -> bytes:\n    '''\n    Generate seed from mnemonic and passphrase.\n    '''\n\n",
        "source_code_len": 3868,
        "target_code": "\n    def encrypt(self, data: bytes) -> bytes:\n        '''\n        Encrypt data and update AES context.\n        '''\n\n    def decrypt(self, data: bytes) -> bytes:\n        '''\n        Decrypt data and update AES context.\n        '''\n\n",
        "target_code_len": 231,
        "diff_format": "@@ -13,145 +12,11 @@\n \n-    def update(self, data: bytes) -> bytes:\n-        '''\n-        Update AES context with data.\n-        '''\n-\n-# extmod/modtrezorcrypto/modtrezorcrypto-bip32.h\n-class HDNode:\n-    '''\n-    BIP0032 HD node structure.\n-    '''\n-\n-    def __init__(self,\n-                 depth: int,\n-                 fingerprint: int,\n-                 child_num: int,\n-                 chain_code: bytes,\n-                 private_key: bytes = None,\n-                 public_key: bytes = None,\n-                 curve_name: str = None) -> None:\n-        '''\n-        '''\n-\n-    def derive(self, index: int, public: bool=False) -> None:\n-        '''\n-        Derive a BIP0032 child node in place.\n-        '''\n-\n-    def derive_path(self, path: List[int]) -> None:\n-        '''\n-        Go through a list of indexes and iteratively derive a child node in place.\n-        '''\n-\n-    def serialize_public(self, version: int) -> str:\n-        '''\n-        Serialize the public info from HD node to base58 string.\n-        '''\n-\n-    def serialize_private(self, version: int) -> str:\n-        '''\n-        Serialize the private info HD node to base58 string.\n-        '''\n-\n-    def clone(self) -> HDNode:\n-        '''\n-        Returns a copy of the HD node.\n-        '''\n-\n-    def depth(self) -> int:\n-        '''\n-        Returns a depth of the HD node.\n-        '''\n-\n-    def fingerprint(self) -> int:\n-        '''\n-        Returns a fingerprint of the HD node (hash of the parent public key).\n-        '''\n-\n-    def child_num(self) -> int:\n-        '''\n-        Returns a child index of the HD node.\n-        '''\n-\n-    def chain_code(self) -> bytes:\n-        '''\n-        Returns a chain code of the HD node.\n-        '''\n-\n-    def private_key(self) -> bytes:\n-        '''\n-        Returns a private key of the HD node.\n-        '''\n-\n-    def public_key(self) -> bytes:\n-        '''\n-        Returns a public key of the HD node.\n-        '''\n-\n-    def address(self, version: int) -> str:\n-        '''\n-        Compute a base58-encoded address string from the HD node.\n-        '''\n-\n-    def nem_address(self, network: int) -> str:\n-        '''\n-        Compute a NEM address string from the HD node.\n-        '''\n-\n-    def nem_encrypt(self, transfer_public_key: bytes, iv: bytes, salt: bytes, payload: bytes) -> bytes:\n-        '''\n-        Encrypts payload using the transfer's public key\n-        '''\n-\n-    def ethereum_pubkeyhash(self) -> bytes:\n-        '''\n-        Compute an Ethereum pubkeyhash (aka address) from the HD node.\n-        '''\n-\n-    def deserialize(self, value: str, version_public: int, version_private: int) -> HDNode:\n-        '''\n-        Construct a BIP0032 HD node from a base58-serialized value.\n-        '''\n-\n-    def from_seed(seed: bytes, curve_name: str) -> HDNode:\n-        '''\n-        Construct a BIP0032 HD node from a BIP0039 seed value.\n-        '''\n-\n-# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\n-def find_word(prefix: str) -> Optional[str]:\n-    '''\n-    Return the first word from the wordlist starting with prefix.\n-    '''\n-\n-# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\n-def complete_word(prefix: str) -> int:\n-    '''\n-    Return possible 1-letter suffixes for given word prefix.\n-    Result is a bitmask, with 'a' on the lowest bit, 'b' on the second lowest, etc.\n-    '''\n-\n-# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\n-def generate(strength: int) -> str:\n-    '''\n-    Generate a mnemonic of given strength (128, 160, 192, 224 and 256 bits).\n-    '''\n-\n-# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\n-def from_data(data: bytes) -> str:\n-    '''\n-    Generate a mnemonic from given data (of 16, 20, 24, 28 and 32 bytes).\n-    '''\n-\n-# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\n-def check(mnemonic: str) -> bool:\n-    '''\n-    Check whether given mnemonic is valid.\n-    '''\n-\n-# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\n-def seed(mnemonic: str, passphrase: str) -> bytes:\n-    '''\n-    Generate seed from mnemonic and passphrase.\n-    '''\n+    def encrypt(self, data: bytes) -> bytes:\n+        '''\n+        Encrypt data and update AES context.\n+        '''\n+\n+    def decrypt(self, data: bytes) -> bytes:\n+        '''\n+        Decrypt data and update AES context.\n+        '''\n \n",
        "source_code_with_indent": "\n    <DED>def update(self, data: bytes) -> bytes:\n        <IND>'''\n        Update AES context with data.\n        '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-bip32.h\n<DED><DED>class HDNode:\n    <IND>'''\n    BIP0032 HD node structure.\n    '''\n\n    def __init__(self,\n                 depth: int,\n                 fingerprint: int,\n                 child_num: int,\n                 chain_code: bytes,\n                 private_key: bytes = None,\n                 public_key: bytes = None,\n                 curve_name: str = None) -> None:\n        <IND>'''\n        '''\n\n    <DED>def derive(self, index: int, public: bool=False) -> None:\n        <IND>'''\n        Derive a BIP0032 child node in place.\n        '''\n\n    <DED>def derive_path(self, path: List[int]) -> None:\n        <IND>'''\n        Go through a list of indexes and iteratively derive a child node in place.\n        '''\n\n    <DED>def serialize_public(self, version: int) -> str:\n        <IND>'''\n        Serialize the public info from HD node to base58 string.\n        '''\n\n    <DED>def serialize_private(self, version: int) -> str:\n        <IND>'''\n        Serialize the private info HD node to base58 string.\n        '''\n\n    <DED>def clone(self) -> HDNode:\n        <IND>'''\n        Returns a copy of the HD node.\n        '''\n\n    <DED>def depth(self) -> int:\n        <IND>'''\n        Returns a depth of the HD node.\n        '''\n\n    <DED>def fingerprint(self) -> int:\n        <IND>'''\n        Returns a fingerprint of the HD node (hash of the parent public key).\n        '''\n\n    <DED>def child_num(self) -> int:\n        <IND>'''\n        Returns a child index of the HD node.\n        '''\n\n    <DED>def chain_code(self) -> bytes:\n        <IND>'''\n        Returns a chain code of the HD node.\n        '''\n\n    <DED>def private_key(self) -> bytes:\n        <IND>'''\n        Returns a private key of the HD node.\n        '''\n\n    <DED>def public_key(self) -> bytes:\n        <IND>'''\n        Returns a public key of the HD node.\n        '''\n\n    <DED>def address(self, version: int) -> str:\n        <IND>'''\n        Compute a base58-encoded address string from the HD node.\n        '''\n\n    <DED>def nem_address(self, network: int) -> str:\n        <IND>'''\n        Compute a NEM address string from the HD node.\n        '''\n\n    <DED>def nem_encrypt(self, transfer_public_key: bytes, iv: bytes, salt: bytes, payload: bytes) -> bytes:\n        <IND>'''\n        Encrypts payload using the transfer's public key\n        '''\n\n    <DED>def ethereum_pubkeyhash(self) -> bytes:\n        <IND>'''\n        Compute an Ethereum pubkeyhash (aka address) from the HD node.\n        '''\n\n    <DED>def deserialize(self, value: str, version_public: int, version_private: int) -> HDNode:\n        <IND>'''\n        Construct a BIP0032 HD node from a base58-serialized value.\n        '''\n\n    <DED>def from_seed(seed: bytes, curve_name: str) -> HDNode:\n        <IND>'''\n        Construct a BIP0032 HD node from a BIP0039 seed value.\n        '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\n<DED><DED>def find_word(prefix: str) -> Optional[str]:\n    <IND>'''\n    Return the first word from the wordlist starting with prefix.\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\n<DED>def complete_word(prefix: str) -> int:\n    <IND>'''\n    Return possible 1-letter suffixes for given word prefix.\n    Result is a bitmask, with 'a' on the lowest bit, 'b' on the second lowest, etc.\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\n<DED>def generate(strength: int) -> str:\n    <IND>'''\n    Generate a mnemonic of given strength (128, 160, 192, 224 and 256 bits).\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\n<DED>def from_data(data: bytes) -> str:\n    <IND>'''\n    Generate a mnemonic from given data (of 16, 20, 24, 28 and 32 bytes).\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\n<DED>def check(mnemonic: str) -> bool:\n    <IND>'''\n    Check whether given mnemonic is valid.\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\n<DED>def seed(mnemonic: str, passphrase: str) -> bytes:\n    <IND>'''\n    Generate seed from mnemonic and passphrase.\n    '''\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n    <DED>def encrypt(self, data: bytes) -> bytes:\n        <IND>'''\n        Encrypt data and update AES context.\n        '''\n\n    <DED>def decrypt(self, data: bytes) -> bytes:\n        <IND>'''\n        Decrypt data and update AES context.\n        '''\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "trezor/trezor-firmware",
    "commit": "6724e4e40997c417378d22081b2a1b2fc7e61357",
    "filename": "mocks/generated/trezorcrypto.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/trezor-trezor-firmware/mocks/generated/trezorcrypto/__init__.py",
    "file_hunks_size": 10,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "mocks/generated/trezorcrypto.py:117:8 Incompatible return type [7]: Expected `HDNode` but got implicit return value of `None`.",
    "message": " Expected `HDNode` but got implicit return value of `None`.",
    "rule_id": "Incompatible return type [7]",
    "warning_line_no": 117,
    "warning_line": "        '''",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n    def update(self, data: bytes) -> bytes:\n        '''\n        Update AES context with data.\n        '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-bip32.h\nclass HDNode:\n    '''\n    BIP0032 HD node structure.\n    '''\n\n    def __init__(self,\n                 depth: int,\n                 fingerprint: int,\n                 child_num: int,\n                 chain_code: bytes,\n                 private_key: bytes = None,\n                 public_key: bytes = None,\n                 curve_name: str = None) -> None:\n        '''\n        '''\n\n    def derive(self, index: int, public: bool=False) -> None:\n        '''\n        Derive a BIP0032 child node in place.\n        '''\n\n    def derive_path(self, path: List[int]) -> None:\n        '''\n        Go through a list of indexes and iteratively derive a child node in place.\n        '''\n\n    def serialize_public(self, version: int) -> str:\n        '''\n        Serialize the public info from HD node to base58 string.\n        '''\n\n    def serialize_private(self, version: int) -> str:\n        '''\n        Serialize the private info HD node to base58 string.\n        '''\n\n    def clone(self) -> HDNode:\n        '''\n        Returns a copy of the HD node.\n        '''\n\n    def depth(self) -> int:\n        '''\n        Returns a depth of the HD node.\n        '''\n\n    def fingerprint(self) -> int:\n        '''\n        Returns a fingerprint of the HD node (hash of the parent public key).\n        '''\n\n    def child_num(self) -> int:\n        '''\n        Returns a child index of the HD node.\n        '''\n\n    def chain_code(self) -> bytes:\n        '''\n        Returns a chain code of the HD node.\n        '''\n\n    def private_key(self) -> bytes:\n        '''\n        Returns a private key of the HD node.\n        '''\n\n    def public_key(self) -> bytes:\n        '''\n        Returns a public key of the HD node.\n        '''\n\n    def address(self, version: int) -> str:\n        '''\n        Compute a base58-encoded address string from the HD node.\n        '''\n\n    def nem_address(self, network: int) -> str:\n        '''\n        Compute a NEM address string from the HD node.\n        '''\n\n    def nem_encrypt(self, transfer_public_key: bytes, iv: bytes, salt: bytes, payload: bytes) -> bytes:\n        '''\n        Encrypts payload using the transfer's public key\n        '''\n\n    def ethereum_pubkeyhash(self) -> bytes:\n        '''\n        Compute an Ethereum pubkeyhash (aka address) from the HD node.\n        '''\n\n    def deserialize(self, value: str, version_public: int, version_private: int) -> HDNode:\n        '''\n        Construct a BIP0032 HD node from a base58-serialized value.\n        '''\n\n    def from_seed(seed: bytes, curve_name: str) -> HDNode:\n        '''\n        Construct a BIP0032 HD node from a BIP0039 seed value.\n        '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\ndef find_word(prefix: str) -> Optional[str]:\n    '''\n    Return the first word from the wordlist starting with prefix.\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\ndef complete_word(prefix: str) -> int:\n    '''\n    Return possible 1-letter suffixes for given word prefix.\n    Result is a bitmask, with 'a' on the lowest bit, 'b' on the second lowest, etc.\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\ndef generate(strength: int) -> str:\n    '''\n    Generate a mnemonic of given strength (128, 160, 192, 224 and 256 bits).\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\ndef from_data(data: bytes) -> str:\n    '''\n    Generate a mnemonic from given data (of 16, 20, 24, 28 and 32 bytes).\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\ndef check(mnemonic: str) -> bool:\n    '''\n    Check whether given mnemonic is valid.\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\ndef seed(mnemonic: str, passphrase: str) -> bytes:\n    '''\n    Generate seed from mnemonic and passphrase.\n    '''\n\n",
        "source_code_len": 3868,
        "target_code": "\n    def encrypt(self, data: bytes) -> bytes:\n        '''\n        Encrypt data and update AES context.\n        '''\n\n    def decrypt(self, data: bytes) -> bytes:\n        '''\n        Decrypt data and update AES context.\n        '''\n\n",
        "target_code_len": 231,
        "diff_format": "@@ -13,145 +12,11 @@\n \n-    def update(self, data: bytes) -> bytes:\n-        '''\n-        Update AES context with data.\n-        '''\n-\n-# extmod/modtrezorcrypto/modtrezorcrypto-bip32.h\n-class HDNode:\n-    '''\n-    BIP0032 HD node structure.\n-    '''\n-\n-    def __init__(self,\n-                 depth: int,\n-                 fingerprint: int,\n-                 child_num: int,\n-                 chain_code: bytes,\n-                 private_key: bytes = None,\n-                 public_key: bytes = None,\n-                 curve_name: str = None) -> None:\n-        '''\n-        '''\n-\n-    def derive(self, index: int, public: bool=False) -> None:\n-        '''\n-        Derive a BIP0032 child node in place.\n-        '''\n-\n-    def derive_path(self, path: List[int]) -> None:\n-        '''\n-        Go through a list of indexes and iteratively derive a child node in place.\n-        '''\n-\n-    def serialize_public(self, version: int) -> str:\n-        '''\n-        Serialize the public info from HD node to base58 string.\n-        '''\n-\n-    def serialize_private(self, version: int) -> str:\n-        '''\n-        Serialize the private info HD node to base58 string.\n-        '''\n-\n-    def clone(self) -> HDNode:\n-        '''\n-        Returns a copy of the HD node.\n-        '''\n-\n-    def depth(self) -> int:\n-        '''\n-        Returns a depth of the HD node.\n-        '''\n-\n-    def fingerprint(self) -> int:\n-        '''\n-        Returns a fingerprint of the HD node (hash of the parent public key).\n-        '''\n-\n-    def child_num(self) -> int:\n-        '''\n-        Returns a child index of the HD node.\n-        '''\n-\n-    def chain_code(self) -> bytes:\n-        '''\n-        Returns a chain code of the HD node.\n-        '''\n-\n-    def private_key(self) -> bytes:\n-        '''\n-        Returns a private key of the HD node.\n-        '''\n-\n-    def public_key(self) -> bytes:\n-        '''\n-        Returns a public key of the HD node.\n-        '''\n-\n-    def address(self, version: int) -> str:\n-        '''\n-        Compute a base58-encoded address string from the HD node.\n-        '''\n-\n-    def nem_address(self, network: int) -> str:\n-        '''\n-        Compute a NEM address string from the HD node.\n-        '''\n-\n-    def nem_encrypt(self, transfer_public_key: bytes, iv: bytes, salt: bytes, payload: bytes) -> bytes:\n-        '''\n-        Encrypts payload using the transfer's public key\n-        '''\n-\n-    def ethereum_pubkeyhash(self) -> bytes:\n-        '''\n-        Compute an Ethereum pubkeyhash (aka address) from the HD node.\n-        '''\n-\n-    def deserialize(self, value: str, version_public: int, version_private: int) -> HDNode:\n-        '''\n-        Construct a BIP0032 HD node from a base58-serialized value.\n-        '''\n-\n-    def from_seed(seed: bytes, curve_name: str) -> HDNode:\n-        '''\n-        Construct a BIP0032 HD node from a BIP0039 seed value.\n-        '''\n-\n-# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\n-def find_word(prefix: str) -> Optional[str]:\n-    '''\n-    Return the first word from the wordlist starting with prefix.\n-    '''\n-\n-# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\n-def complete_word(prefix: str) -> int:\n-    '''\n-    Return possible 1-letter suffixes for given word prefix.\n-    Result is a bitmask, with 'a' on the lowest bit, 'b' on the second lowest, etc.\n-    '''\n-\n-# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\n-def generate(strength: int) -> str:\n-    '''\n-    Generate a mnemonic of given strength (128, 160, 192, 224 and 256 bits).\n-    '''\n-\n-# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\n-def from_data(data: bytes) -> str:\n-    '''\n-    Generate a mnemonic from given data (of 16, 20, 24, 28 and 32 bytes).\n-    '''\n-\n-# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\n-def check(mnemonic: str) -> bool:\n-    '''\n-    Check whether given mnemonic is valid.\n-    '''\n-\n-# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\n-def seed(mnemonic: str, passphrase: str) -> bytes:\n-    '''\n-    Generate seed from mnemonic and passphrase.\n-    '''\n+    def encrypt(self, data: bytes) -> bytes:\n+        '''\n+        Encrypt data and update AES context.\n+        '''\n+\n+    def decrypt(self, data: bytes) -> bytes:\n+        '''\n+        Decrypt data and update AES context.\n+        '''\n \n",
        "source_code_with_indent": "\n    <DED>def update(self, data: bytes) -> bytes:\n        <IND>'''\n        Update AES context with data.\n        '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-bip32.h\n<DED><DED>class HDNode:\n    <IND>'''\n    BIP0032 HD node structure.\n    '''\n\n    def __init__(self,\n                 depth: int,\n                 fingerprint: int,\n                 child_num: int,\n                 chain_code: bytes,\n                 private_key: bytes = None,\n                 public_key: bytes = None,\n                 curve_name: str = None) -> None:\n        <IND>'''\n        '''\n\n    <DED>def derive(self, index: int, public: bool=False) -> None:\n        <IND>'''\n        Derive a BIP0032 child node in place.\n        '''\n\n    <DED>def derive_path(self, path: List[int]) -> None:\n        <IND>'''\n        Go through a list of indexes and iteratively derive a child node in place.\n        '''\n\n    <DED>def serialize_public(self, version: int) -> str:\n        <IND>'''\n        Serialize the public info from HD node to base58 string.\n        '''\n\n    <DED>def serialize_private(self, version: int) -> str:\n        <IND>'''\n        Serialize the private info HD node to base58 string.\n        '''\n\n    <DED>def clone(self) -> HDNode:\n        <IND>'''\n        Returns a copy of the HD node.\n        '''\n\n    <DED>def depth(self) -> int:\n        <IND>'''\n        Returns a depth of the HD node.\n        '''\n\n    <DED>def fingerprint(self) -> int:\n        <IND>'''\n        Returns a fingerprint of the HD node (hash of the parent public key).\n        '''\n\n    <DED>def child_num(self) -> int:\n        <IND>'''\n        Returns a child index of the HD node.\n        '''\n\n    <DED>def chain_code(self) -> bytes:\n        <IND>'''\n        Returns a chain code of the HD node.\n        '''\n\n    <DED>def private_key(self) -> bytes:\n        <IND>'''\n        Returns a private key of the HD node.\n        '''\n\n    <DED>def public_key(self) -> bytes:\n        <IND>'''\n        Returns a public key of the HD node.\n        '''\n\n    <DED>def address(self, version: int) -> str:\n        <IND>'''\n        Compute a base58-encoded address string from the HD node.\n        '''\n\n    <DED>def nem_address(self, network: int) -> str:\n        <IND>'''\n        Compute a NEM address string from the HD node.\n        '''\n\n    <DED>def nem_encrypt(self, transfer_public_key: bytes, iv: bytes, salt: bytes, payload: bytes) -> bytes:\n        <IND>'''\n        Encrypts payload using the transfer's public key\n        '''\n\n    <DED>def ethereum_pubkeyhash(self) -> bytes:\n        <IND>'''\n        Compute an Ethereum pubkeyhash (aka address) from the HD node.\n        '''\n\n    <DED>def deserialize(self, value: str, version_public: int, version_private: int) -> HDNode:\n        <IND>'''\n        Construct a BIP0032 HD node from a base58-serialized value.\n        '''\n\n    <DED>def from_seed(seed: bytes, curve_name: str) -> HDNode:\n        <IND>'''\n        Construct a BIP0032 HD node from a BIP0039 seed value.\n        '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\n<DED><DED>def find_word(prefix: str) -> Optional[str]:\n    <IND>'''\n    Return the first word from the wordlist starting with prefix.\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\n<DED>def complete_word(prefix: str) -> int:\n    <IND>'''\n    Return possible 1-letter suffixes for given word prefix.\n    Result is a bitmask, with 'a' on the lowest bit, 'b' on the second lowest, etc.\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\n<DED>def generate(strength: int) -> str:\n    <IND>'''\n    Generate a mnemonic of given strength (128, 160, 192, 224 and 256 bits).\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\n<DED>def from_data(data: bytes) -> str:\n    <IND>'''\n    Generate a mnemonic from given data (of 16, 20, 24, 28 and 32 bytes).\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\n<DED>def check(mnemonic: str) -> bool:\n    <IND>'''\n    Check whether given mnemonic is valid.\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\n<DED>def seed(mnemonic: str, passphrase: str) -> bytes:\n    <IND>'''\n    Generate seed from mnemonic and passphrase.\n    '''\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n    <DED>def encrypt(self, data: bytes) -> bytes:\n        <IND>'''\n        Encrypt data and update AES context.\n        '''\n\n    <DED>def decrypt(self, data: bytes) -> bytes:\n        <IND>'''\n        Decrypt data and update AES context.\n        '''\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "trezor/trezor-firmware",
    "commit": "6724e4e40997c417378d22081b2a1b2fc7e61357",
    "filename": "mocks/generated/trezorcrypto.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/trezor-trezor-firmware/mocks/generated/trezorcrypto/__init__.py",
    "file_hunks_size": 10,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "mocks/generated/trezorcrypto.py:129:4 Incompatible return type [7]: Expected `int` but got implicit return value of `None`.",
    "message": " Expected `int` but got implicit return value of `None`.",
    "rule_id": "Incompatible return type [7]",
    "warning_line_no": 129,
    "warning_line": "    '''",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n    def update(self, data: bytes) -> bytes:\n        '''\n        Update AES context with data.\n        '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-bip32.h\nclass HDNode:\n    '''\n    BIP0032 HD node structure.\n    '''\n\n    def __init__(self,\n                 depth: int,\n                 fingerprint: int,\n                 child_num: int,\n                 chain_code: bytes,\n                 private_key: bytes = None,\n                 public_key: bytes = None,\n                 curve_name: str = None) -> None:\n        '''\n        '''\n\n    def derive(self, index: int, public: bool=False) -> None:\n        '''\n        Derive a BIP0032 child node in place.\n        '''\n\n    def derive_path(self, path: List[int]) -> None:\n        '''\n        Go through a list of indexes and iteratively derive a child node in place.\n        '''\n\n    def serialize_public(self, version: int) -> str:\n        '''\n        Serialize the public info from HD node to base58 string.\n        '''\n\n    def serialize_private(self, version: int) -> str:\n        '''\n        Serialize the private info HD node to base58 string.\n        '''\n\n    def clone(self) -> HDNode:\n        '''\n        Returns a copy of the HD node.\n        '''\n\n    def depth(self) -> int:\n        '''\n        Returns a depth of the HD node.\n        '''\n\n    def fingerprint(self) -> int:\n        '''\n        Returns a fingerprint of the HD node (hash of the parent public key).\n        '''\n\n    def child_num(self) -> int:\n        '''\n        Returns a child index of the HD node.\n        '''\n\n    def chain_code(self) -> bytes:\n        '''\n        Returns a chain code of the HD node.\n        '''\n\n    def private_key(self) -> bytes:\n        '''\n        Returns a private key of the HD node.\n        '''\n\n    def public_key(self) -> bytes:\n        '''\n        Returns a public key of the HD node.\n        '''\n\n    def address(self, version: int) -> str:\n        '''\n        Compute a base58-encoded address string from the HD node.\n        '''\n\n    def nem_address(self, network: int) -> str:\n        '''\n        Compute a NEM address string from the HD node.\n        '''\n\n    def nem_encrypt(self, transfer_public_key: bytes, iv: bytes, salt: bytes, payload: bytes) -> bytes:\n        '''\n        Encrypts payload using the transfer's public key\n        '''\n\n    def ethereum_pubkeyhash(self) -> bytes:\n        '''\n        Compute an Ethereum pubkeyhash (aka address) from the HD node.\n        '''\n\n    def deserialize(self, value: str, version_public: int, version_private: int) -> HDNode:\n        '''\n        Construct a BIP0032 HD node from a base58-serialized value.\n        '''\n\n    def from_seed(seed: bytes, curve_name: str) -> HDNode:\n        '''\n        Construct a BIP0032 HD node from a BIP0039 seed value.\n        '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\ndef find_word(prefix: str) -> Optional[str]:\n    '''\n    Return the first word from the wordlist starting with prefix.\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\ndef complete_word(prefix: str) -> int:\n    '''\n    Return possible 1-letter suffixes for given word prefix.\n    Result is a bitmask, with 'a' on the lowest bit, 'b' on the second lowest, etc.\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\ndef generate(strength: int) -> str:\n    '''\n    Generate a mnemonic of given strength (128, 160, 192, 224 and 256 bits).\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\ndef from_data(data: bytes) -> str:\n    '''\n    Generate a mnemonic from given data (of 16, 20, 24, 28 and 32 bytes).\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\ndef check(mnemonic: str) -> bool:\n    '''\n    Check whether given mnemonic is valid.\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\ndef seed(mnemonic: str, passphrase: str) -> bytes:\n    '''\n    Generate seed from mnemonic and passphrase.\n    '''\n\n",
        "source_code_len": 3868,
        "target_code": "\n    def encrypt(self, data: bytes) -> bytes:\n        '''\n        Encrypt data and update AES context.\n        '''\n\n    def decrypt(self, data: bytes) -> bytes:\n        '''\n        Decrypt data and update AES context.\n        '''\n\n",
        "target_code_len": 231,
        "diff_format": "@@ -13,145 +12,11 @@\n \n-    def update(self, data: bytes) -> bytes:\n-        '''\n-        Update AES context with data.\n-        '''\n-\n-# extmod/modtrezorcrypto/modtrezorcrypto-bip32.h\n-class HDNode:\n-    '''\n-    BIP0032 HD node structure.\n-    '''\n-\n-    def __init__(self,\n-                 depth: int,\n-                 fingerprint: int,\n-                 child_num: int,\n-                 chain_code: bytes,\n-                 private_key: bytes = None,\n-                 public_key: bytes = None,\n-                 curve_name: str = None) -> None:\n-        '''\n-        '''\n-\n-    def derive(self, index: int, public: bool=False) -> None:\n-        '''\n-        Derive a BIP0032 child node in place.\n-        '''\n-\n-    def derive_path(self, path: List[int]) -> None:\n-        '''\n-        Go through a list of indexes and iteratively derive a child node in place.\n-        '''\n-\n-    def serialize_public(self, version: int) -> str:\n-        '''\n-        Serialize the public info from HD node to base58 string.\n-        '''\n-\n-    def serialize_private(self, version: int) -> str:\n-        '''\n-        Serialize the private info HD node to base58 string.\n-        '''\n-\n-    def clone(self) -> HDNode:\n-        '''\n-        Returns a copy of the HD node.\n-        '''\n-\n-    def depth(self) -> int:\n-        '''\n-        Returns a depth of the HD node.\n-        '''\n-\n-    def fingerprint(self) -> int:\n-        '''\n-        Returns a fingerprint of the HD node (hash of the parent public key).\n-        '''\n-\n-    def child_num(self) -> int:\n-        '''\n-        Returns a child index of the HD node.\n-        '''\n-\n-    def chain_code(self) -> bytes:\n-        '''\n-        Returns a chain code of the HD node.\n-        '''\n-\n-    def private_key(self) -> bytes:\n-        '''\n-        Returns a private key of the HD node.\n-        '''\n-\n-    def public_key(self) -> bytes:\n-        '''\n-        Returns a public key of the HD node.\n-        '''\n-\n-    def address(self, version: int) -> str:\n-        '''\n-        Compute a base58-encoded address string from the HD node.\n-        '''\n-\n-    def nem_address(self, network: int) -> str:\n-        '''\n-        Compute a NEM address string from the HD node.\n-        '''\n-\n-    def nem_encrypt(self, transfer_public_key: bytes, iv: bytes, salt: bytes, payload: bytes) -> bytes:\n-        '''\n-        Encrypts payload using the transfer's public key\n-        '''\n-\n-    def ethereum_pubkeyhash(self) -> bytes:\n-        '''\n-        Compute an Ethereum pubkeyhash (aka address) from the HD node.\n-        '''\n-\n-    def deserialize(self, value: str, version_public: int, version_private: int) -> HDNode:\n-        '''\n-        Construct a BIP0032 HD node from a base58-serialized value.\n-        '''\n-\n-    def from_seed(seed: bytes, curve_name: str) -> HDNode:\n-        '''\n-        Construct a BIP0032 HD node from a BIP0039 seed value.\n-        '''\n-\n-# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\n-def find_word(prefix: str) -> Optional[str]:\n-    '''\n-    Return the first word from the wordlist starting with prefix.\n-    '''\n-\n-# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\n-def complete_word(prefix: str) -> int:\n-    '''\n-    Return possible 1-letter suffixes for given word prefix.\n-    Result is a bitmask, with 'a' on the lowest bit, 'b' on the second lowest, etc.\n-    '''\n-\n-# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\n-def generate(strength: int) -> str:\n-    '''\n-    Generate a mnemonic of given strength (128, 160, 192, 224 and 256 bits).\n-    '''\n-\n-# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\n-def from_data(data: bytes) -> str:\n-    '''\n-    Generate a mnemonic from given data (of 16, 20, 24, 28 and 32 bytes).\n-    '''\n-\n-# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\n-def check(mnemonic: str) -> bool:\n-    '''\n-    Check whether given mnemonic is valid.\n-    '''\n-\n-# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\n-def seed(mnemonic: str, passphrase: str) -> bytes:\n-    '''\n-    Generate seed from mnemonic and passphrase.\n-    '''\n+    def encrypt(self, data: bytes) -> bytes:\n+        '''\n+        Encrypt data and update AES context.\n+        '''\n+\n+    def decrypt(self, data: bytes) -> bytes:\n+        '''\n+        Decrypt data and update AES context.\n+        '''\n \n",
        "source_code_with_indent": "\n    <DED>def update(self, data: bytes) -> bytes:\n        <IND>'''\n        Update AES context with data.\n        '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-bip32.h\n<DED><DED>class HDNode:\n    <IND>'''\n    BIP0032 HD node structure.\n    '''\n\n    def __init__(self,\n                 depth: int,\n                 fingerprint: int,\n                 child_num: int,\n                 chain_code: bytes,\n                 private_key: bytes = None,\n                 public_key: bytes = None,\n                 curve_name: str = None) -> None:\n        <IND>'''\n        '''\n\n    <DED>def derive(self, index: int, public: bool=False) -> None:\n        <IND>'''\n        Derive a BIP0032 child node in place.\n        '''\n\n    <DED>def derive_path(self, path: List[int]) -> None:\n        <IND>'''\n        Go through a list of indexes and iteratively derive a child node in place.\n        '''\n\n    <DED>def serialize_public(self, version: int) -> str:\n        <IND>'''\n        Serialize the public info from HD node to base58 string.\n        '''\n\n    <DED>def serialize_private(self, version: int) -> str:\n        <IND>'''\n        Serialize the private info HD node to base58 string.\n        '''\n\n    <DED>def clone(self) -> HDNode:\n        <IND>'''\n        Returns a copy of the HD node.\n        '''\n\n    <DED>def depth(self) -> int:\n        <IND>'''\n        Returns a depth of the HD node.\n        '''\n\n    <DED>def fingerprint(self) -> int:\n        <IND>'''\n        Returns a fingerprint of the HD node (hash of the parent public key).\n        '''\n\n    <DED>def child_num(self) -> int:\n        <IND>'''\n        Returns a child index of the HD node.\n        '''\n\n    <DED>def chain_code(self) -> bytes:\n        <IND>'''\n        Returns a chain code of the HD node.\n        '''\n\n    <DED>def private_key(self) -> bytes:\n        <IND>'''\n        Returns a private key of the HD node.\n        '''\n\n    <DED>def public_key(self) -> bytes:\n        <IND>'''\n        Returns a public key of the HD node.\n        '''\n\n    <DED>def address(self, version: int) -> str:\n        <IND>'''\n        Compute a base58-encoded address string from the HD node.\n        '''\n\n    <DED>def nem_address(self, network: int) -> str:\n        <IND>'''\n        Compute a NEM address string from the HD node.\n        '''\n\n    <DED>def nem_encrypt(self, transfer_public_key: bytes, iv: bytes, salt: bytes, payload: bytes) -> bytes:\n        <IND>'''\n        Encrypts payload using the transfer's public key\n        '''\n\n    <DED>def ethereum_pubkeyhash(self) -> bytes:\n        <IND>'''\n        Compute an Ethereum pubkeyhash (aka address) from the HD node.\n        '''\n\n    <DED>def deserialize(self, value: str, version_public: int, version_private: int) -> HDNode:\n        <IND>'''\n        Construct a BIP0032 HD node from a base58-serialized value.\n        '''\n\n    <DED>def from_seed(seed: bytes, curve_name: str) -> HDNode:\n        <IND>'''\n        Construct a BIP0032 HD node from a BIP0039 seed value.\n        '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\n<DED><DED>def find_word(prefix: str) -> Optional[str]:\n    <IND>'''\n    Return the first word from the wordlist starting with prefix.\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\n<DED>def complete_word(prefix: str) -> int:\n    <IND>'''\n    Return possible 1-letter suffixes for given word prefix.\n    Result is a bitmask, with 'a' on the lowest bit, 'b' on the second lowest, etc.\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\n<DED>def generate(strength: int) -> str:\n    <IND>'''\n    Generate a mnemonic of given strength (128, 160, 192, 224 and 256 bits).\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\n<DED>def from_data(data: bytes) -> str:\n    <IND>'''\n    Generate a mnemonic from given data (of 16, 20, 24, 28 and 32 bytes).\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\n<DED>def check(mnemonic: str) -> bool:\n    <IND>'''\n    Check whether given mnemonic is valid.\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\n<DED>def seed(mnemonic: str, passphrase: str) -> bytes:\n    <IND>'''\n    Generate seed from mnemonic and passphrase.\n    '''\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n    <DED>def encrypt(self, data: bytes) -> bytes:\n        <IND>'''\n        Encrypt data and update AES context.\n        '''\n\n    <DED>def decrypt(self, data: bytes) -> bytes:\n        <IND>'''\n        Decrypt data and update AES context.\n        '''\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "trezor/trezor-firmware",
    "commit": "6724e4e40997c417378d22081b2a1b2fc7e61357",
    "filename": "mocks/generated/trezorcrypto.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/trezor-trezor-firmware/mocks/generated/trezorcrypto/__init__.py",
    "file_hunks_size": 10,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "mocks/generated/trezorcrypto.py:136:4 Incompatible return type [7]: Expected `str` but got implicit return value of `None`.",
    "message": " Expected `str` but got implicit return value of `None`.",
    "rule_id": "Incompatible return type [7]",
    "warning_line_no": 136,
    "warning_line": "    '''",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n    def update(self, data: bytes) -> bytes:\n        '''\n        Update AES context with data.\n        '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-bip32.h\nclass HDNode:\n    '''\n    BIP0032 HD node structure.\n    '''\n\n    def __init__(self,\n                 depth: int,\n                 fingerprint: int,\n                 child_num: int,\n                 chain_code: bytes,\n                 private_key: bytes = None,\n                 public_key: bytes = None,\n                 curve_name: str = None) -> None:\n        '''\n        '''\n\n    def derive(self, index: int, public: bool=False) -> None:\n        '''\n        Derive a BIP0032 child node in place.\n        '''\n\n    def derive_path(self, path: List[int]) -> None:\n        '''\n        Go through a list of indexes and iteratively derive a child node in place.\n        '''\n\n    def serialize_public(self, version: int) -> str:\n        '''\n        Serialize the public info from HD node to base58 string.\n        '''\n\n    def serialize_private(self, version: int) -> str:\n        '''\n        Serialize the private info HD node to base58 string.\n        '''\n\n    def clone(self) -> HDNode:\n        '''\n        Returns a copy of the HD node.\n        '''\n\n    def depth(self) -> int:\n        '''\n        Returns a depth of the HD node.\n        '''\n\n    def fingerprint(self) -> int:\n        '''\n        Returns a fingerprint of the HD node (hash of the parent public key).\n        '''\n\n    def child_num(self) -> int:\n        '''\n        Returns a child index of the HD node.\n        '''\n\n    def chain_code(self) -> bytes:\n        '''\n        Returns a chain code of the HD node.\n        '''\n\n    def private_key(self) -> bytes:\n        '''\n        Returns a private key of the HD node.\n        '''\n\n    def public_key(self) -> bytes:\n        '''\n        Returns a public key of the HD node.\n        '''\n\n    def address(self, version: int) -> str:\n        '''\n        Compute a base58-encoded address string from the HD node.\n        '''\n\n    def nem_address(self, network: int) -> str:\n        '''\n        Compute a NEM address string from the HD node.\n        '''\n\n    def nem_encrypt(self, transfer_public_key: bytes, iv: bytes, salt: bytes, payload: bytes) -> bytes:\n        '''\n        Encrypts payload using the transfer's public key\n        '''\n\n    def ethereum_pubkeyhash(self) -> bytes:\n        '''\n        Compute an Ethereum pubkeyhash (aka address) from the HD node.\n        '''\n\n    def deserialize(self, value: str, version_public: int, version_private: int) -> HDNode:\n        '''\n        Construct a BIP0032 HD node from a base58-serialized value.\n        '''\n\n    def from_seed(seed: bytes, curve_name: str) -> HDNode:\n        '''\n        Construct a BIP0032 HD node from a BIP0039 seed value.\n        '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\ndef find_word(prefix: str) -> Optional[str]:\n    '''\n    Return the first word from the wordlist starting with prefix.\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\ndef complete_word(prefix: str) -> int:\n    '''\n    Return possible 1-letter suffixes for given word prefix.\n    Result is a bitmask, with 'a' on the lowest bit, 'b' on the second lowest, etc.\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\ndef generate(strength: int) -> str:\n    '''\n    Generate a mnemonic of given strength (128, 160, 192, 224 and 256 bits).\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\ndef from_data(data: bytes) -> str:\n    '''\n    Generate a mnemonic from given data (of 16, 20, 24, 28 and 32 bytes).\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\ndef check(mnemonic: str) -> bool:\n    '''\n    Check whether given mnemonic is valid.\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\ndef seed(mnemonic: str, passphrase: str) -> bytes:\n    '''\n    Generate seed from mnemonic and passphrase.\n    '''\n\n",
        "source_code_len": 3868,
        "target_code": "\n    def encrypt(self, data: bytes) -> bytes:\n        '''\n        Encrypt data and update AES context.\n        '''\n\n    def decrypt(self, data: bytes) -> bytes:\n        '''\n        Decrypt data and update AES context.\n        '''\n\n",
        "target_code_len": 231,
        "diff_format": "@@ -13,145 +12,11 @@\n \n-    def update(self, data: bytes) -> bytes:\n-        '''\n-        Update AES context with data.\n-        '''\n-\n-# extmod/modtrezorcrypto/modtrezorcrypto-bip32.h\n-class HDNode:\n-    '''\n-    BIP0032 HD node structure.\n-    '''\n-\n-    def __init__(self,\n-                 depth: int,\n-                 fingerprint: int,\n-                 child_num: int,\n-                 chain_code: bytes,\n-                 private_key: bytes = None,\n-                 public_key: bytes = None,\n-                 curve_name: str = None) -> None:\n-        '''\n-        '''\n-\n-    def derive(self, index: int, public: bool=False) -> None:\n-        '''\n-        Derive a BIP0032 child node in place.\n-        '''\n-\n-    def derive_path(self, path: List[int]) -> None:\n-        '''\n-        Go through a list of indexes and iteratively derive a child node in place.\n-        '''\n-\n-    def serialize_public(self, version: int) -> str:\n-        '''\n-        Serialize the public info from HD node to base58 string.\n-        '''\n-\n-    def serialize_private(self, version: int) -> str:\n-        '''\n-        Serialize the private info HD node to base58 string.\n-        '''\n-\n-    def clone(self) -> HDNode:\n-        '''\n-        Returns a copy of the HD node.\n-        '''\n-\n-    def depth(self) -> int:\n-        '''\n-        Returns a depth of the HD node.\n-        '''\n-\n-    def fingerprint(self) -> int:\n-        '''\n-        Returns a fingerprint of the HD node (hash of the parent public key).\n-        '''\n-\n-    def child_num(self) -> int:\n-        '''\n-        Returns a child index of the HD node.\n-        '''\n-\n-    def chain_code(self) -> bytes:\n-        '''\n-        Returns a chain code of the HD node.\n-        '''\n-\n-    def private_key(self) -> bytes:\n-        '''\n-        Returns a private key of the HD node.\n-        '''\n-\n-    def public_key(self) -> bytes:\n-        '''\n-        Returns a public key of the HD node.\n-        '''\n-\n-    def address(self, version: int) -> str:\n-        '''\n-        Compute a base58-encoded address string from the HD node.\n-        '''\n-\n-    def nem_address(self, network: int) -> str:\n-        '''\n-        Compute a NEM address string from the HD node.\n-        '''\n-\n-    def nem_encrypt(self, transfer_public_key: bytes, iv: bytes, salt: bytes, payload: bytes) -> bytes:\n-        '''\n-        Encrypts payload using the transfer's public key\n-        '''\n-\n-    def ethereum_pubkeyhash(self) -> bytes:\n-        '''\n-        Compute an Ethereum pubkeyhash (aka address) from the HD node.\n-        '''\n-\n-    def deserialize(self, value: str, version_public: int, version_private: int) -> HDNode:\n-        '''\n-        Construct a BIP0032 HD node from a base58-serialized value.\n-        '''\n-\n-    def from_seed(seed: bytes, curve_name: str) -> HDNode:\n-        '''\n-        Construct a BIP0032 HD node from a BIP0039 seed value.\n-        '''\n-\n-# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\n-def find_word(prefix: str) -> Optional[str]:\n-    '''\n-    Return the first word from the wordlist starting with prefix.\n-    '''\n-\n-# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\n-def complete_word(prefix: str) -> int:\n-    '''\n-    Return possible 1-letter suffixes for given word prefix.\n-    Result is a bitmask, with 'a' on the lowest bit, 'b' on the second lowest, etc.\n-    '''\n-\n-# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\n-def generate(strength: int) -> str:\n-    '''\n-    Generate a mnemonic of given strength (128, 160, 192, 224 and 256 bits).\n-    '''\n-\n-# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\n-def from_data(data: bytes) -> str:\n-    '''\n-    Generate a mnemonic from given data (of 16, 20, 24, 28 and 32 bytes).\n-    '''\n-\n-# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\n-def check(mnemonic: str) -> bool:\n-    '''\n-    Check whether given mnemonic is valid.\n-    '''\n-\n-# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\n-def seed(mnemonic: str, passphrase: str) -> bytes:\n-    '''\n-    Generate seed from mnemonic and passphrase.\n-    '''\n+    def encrypt(self, data: bytes) -> bytes:\n+        '''\n+        Encrypt data and update AES context.\n+        '''\n+\n+    def decrypt(self, data: bytes) -> bytes:\n+        '''\n+        Decrypt data and update AES context.\n+        '''\n \n",
        "source_code_with_indent": "\n    <DED>def update(self, data: bytes) -> bytes:\n        <IND>'''\n        Update AES context with data.\n        '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-bip32.h\n<DED><DED>class HDNode:\n    <IND>'''\n    BIP0032 HD node structure.\n    '''\n\n    def __init__(self,\n                 depth: int,\n                 fingerprint: int,\n                 child_num: int,\n                 chain_code: bytes,\n                 private_key: bytes = None,\n                 public_key: bytes = None,\n                 curve_name: str = None) -> None:\n        <IND>'''\n        '''\n\n    <DED>def derive(self, index: int, public: bool=False) -> None:\n        <IND>'''\n        Derive a BIP0032 child node in place.\n        '''\n\n    <DED>def derive_path(self, path: List[int]) -> None:\n        <IND>'''\n        Go through a list of indexes and iteratively derive a child node in place.\n        '''\n\n    <DED>def serialize_public(self, version: int) -> str:\n        <IND>'''\n        Serialize the public info from HD node to base58 string.\n        '''\n\n    <DED>def serialize_private(self, version: int) -> str:\n        <IND>'''\n        Serialize the private info HD node to base58 string.\n        '''\n\n    <DED>def clone(self) -> HDNode:\n        <IND>'''\n        Returns a copy of the HD node.\n        '''\n\n    <DED>def depth(self) -> int:\n        <IND>'''\n        Returns a depth of the HD node.\n        '''\n\n    <DED>def fingerprint(self) -> int:\n        <IND>'''\n        Returns a fingerprint of the HD node (hash of the parent public key).\n        '''\n\n    <DED>def child_num(self) -> int:\n        <IND>'''\n        Returns a child index of the HD node.\n        '''\n\n    <DED>def chain_code(self) -> bytes:\n        <IND>'''\n        Returns a chain code of the HD node.\n        '''\n\n    <DED>def private_key(self) -> bytes:\n        <IND>'''\n        Returns a private key of the HD node.\n        '''\n\n    <DED>def public_key(self) -> bytes:\n        <IND>'''\n        Returns a public key of the HD node.\n        '''\n\n    <DED>def address(self, version: int) -> str:\n        <IND>'''\n        Compute a base58-encoded address string from the HD node.\n        '''\n\n    <DED>def nem_address(self, network: int) -> str:\n        <IND>'''\n        Compute a NEM address string from the HD node.\n        '''\n\n    <DED>def nem_encrypt(self, transfer_public_key: bytes, iv: bytes, salt: bytes, payload: bytes) -> bytes:\n        <IND>'''\n        Encrypts payload using the transfer's public key\n        '''\n\n    <DED>def ethereum_pubkeyhash(self) -> bytes:\n        <IND>'''\n        Compute an Ethereum pubkeyhash (aka address) from the HD node.\n        '''\n\n    <DED>def deserialize(self, value: str, version_public: int, version_private: int) -> HDNode:\n        <IND>'''\n        Construct a BIP0032 HD node from a base58-serialized value.\n        '''\n\n    <DED>def from_seed(seed: bytes, curve_name: str) -> HDNode:\n        <IND>'''\n        Construct a BIP0032 HD node from a BIP0039 seed value.\n        '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\n<DED><DED>def find_word(prefix: str) -> Optional[str]:\n    <IND>'''\n    Return the first word from the wordlist starting with prefix.\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\n<DED>def complete_word(prefix: str) -> int:\n    <IND>'''\n    Return possible 1-letter suffixes for given word prefix.\n    Result is a bitmask, with 'a' on the lowest bit, 'b' on the second lowest, etc.\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\n<DED>def generate(strength: int) -> str:\n    <IND>'''\n    Generate a mnemonic of given strength (128, 160, 192, 224 and 256 bits).\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\n<DED>def from_data(data: bytes) -> str:\n    <IND>'''\n    Generate a mnemonic from given data (of 16, 20, 24, 28 and 32 bytes).\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\n<DED>def check(mnemonic: str) -> bool:\n    <IND>'''\n    Check whether given mnemonic is valid.\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\n<DED>def seed(mnemonic: str, passphrase: str) -> bytes:\n    <IND>'''\n    Generate seed from mnemonic and passphrase.\n    '''\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n    <DED>def encrypt(self, data: bytes) -> bytes:\n        <IND>'''\n        Encrypt data and update AES context.\n        '''\n\n    <DED>def decrypt(self, data: bytes) -> bytes:\n        <IND>'''\n        Decrypt data and update AES context.\n        '''\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "trezor/trezor-firmware",
    "commit": "6724e4e40997c417378d22081b2a1b2fc7e61357",
    "filename": "mocks/generated/trezorcrypto.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/trezor-trezor-firmware/mocks/generated/trezorcrypto/__init__.py",
    "file_hunks_size": 10,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "mocks/generated/trezorcrypto.py:142:4 Incompatible return type [7]: Expected `str` but got implicit return value of `None`.",
    "message": " Expected `str` but got implicit return value of `None`.",
    "rule_id": "Incompatible return type [7]",
    "warning_line_no": 142,
    "warning_line": "    '''",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n    def update(self, data: bytes) -> bytes:\n        '''\n        Update AES context with data.\n        '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-bip32.h\nclass HDNode:\n    '''\n    BIP0032 HD node structure.\n    '''\n\n    def __init__(self,\n                 depth: int,\n                 fingerprint: int,\n                 child_num: int,\n                 chain_code: bytes,\n                 private_key: bytes = None,\n                 public_key: bytes = None,\n                 curve_name: str = None) -> None:\n        '''\n        '''\n\n    def derive(self, index: int, public: bool=False) -> None:\n        '''\n        Derive a BIP0032 child node in place.\n        '''\n\n    def derive_path(self, path: List[int]) -> None:\n        '''\n        Go through a list of indexes and iteratively derive a child node in place.\n        '''\n\n    def serialize_public(self, version: int) -> str:\n        '''\n        Serialize the public info from HD node to base58 string.\n        '''\n\n    def serialize_private(self, version: int) -> str:\n        '''\n        Serialize the private info HD node to base58 string.\n        '''\n\n    def clone(self) -> HDNode:\n        '''\n        Returns a copy of the HD node.\n        '''\n\n    def depth(self) -> int:\n        '''\n        Returns a depth of the HD node.\n        '''\n\n    def fingerprint(self) -> int:\n        '''\n        Returns a fingerprint of the HD node (hash of the parent public key).\n        '''\n\n    def child_num(self) -> int:\n        '''\n        Returns a child index of the HD node.\n        '''\n\n    def chain_code(self) -> bytes:\n        '''\n        Returns a chain code of the HD node.\n        '''\n\n    def private_key(self) -> bytes:\n        '''\n        Returns a private key of the HD node.\n        '''\n\n    def public_key(self) -> bytes:\n        '''\n        Returns a public key of the HD node.\n        '''\n\n    def address(self, version: int) -> str:\n        '''\n        Compute a base58-encoded address string from the HD node.\n        '''\n\n    def nem_address(self, network: int) -> str:\n        '''\n        Compute a NEM address string from the HD node.\n        '''\n\n    def nem_encrypt(self, transfer_public_key: bytes, iv: bytes, salt: bytes, payload: bytes) -> bytes:\n        '''\n        Encrypts payload using the transfer's public key\n        '''\n\n    def ethereum_pubkeyhash(self) -> bytes:\n        '''\n        Compute an Ethereum pubkeyhash (aka address) from the HD node.\n        '''\n\n    def deserialize(self, value: str, version_public: int, version_private: int) -> HDNode:\n        '''\n        Construct a BIP0032 HD node from a base58-serialized value.\n        '''\n\n    def from_seed(seed: bytes, curve_name: str) -> HDNode:\n        '''\n        Construct a BIP0032 HD node from a BIP0039 seed value.\n        '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\ndef find_word(prefix: str) -> Optional[str]:\n    '''\n    Return the first word from the wordlist starting with prefix.\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\ndef complete_word(prefix: str) -> int:\n    '''\n    Return possible 1-letter suffixes for given word prefix.\n    Result is a bitmask, with 'a' on the lowest bit, 'b' on the second lowest, etc.\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\ndef generate(strength: int) -> str:\n    '''\n    Generate a mnemonic of given strength (128, 160, 192, 224 and 256 bits).\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\ndef from_data(data: bytes) -> str:\n    '''\n    Generate a mnemonic from given data (of 16, 20, 24, 28 and 32 bytes).\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\ndef check(mnemonic: str) -> bool:\n    '''\n    Check whether given mnemonic is valid.\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\ndef seed(mnemonic: str, passphrase: str) -> bytes:\n    '''\n    Generate seed from mnemonic and passphrase.\n    '''\n\n",
        "source_code_len": 3868,
        "target_code": "\n    def encrypt(self, data: bytes) -> bytes:\n        '''\n        Encrypt data and update AES context.\n        '''\n\n    def decrypt(self, data: bytes) -> bytes:\n        '''\n        Decrypt data and update AES context.\n        '''\n\n",
        "target_code_len": 231,
        "diff_format": "@@ -13,145 +12,11 @@\n \n-    def update(self, data: bytes) -> bytes:\n-        '''\n-        Update AES context with data.\n-        '''\n-\n-# extmod/modtrezorcrypto/modtrezorcrypto-bip32.h\n-class HDNode:\n-    '''\n-    BIP0032 HD node structure.\n-    '''\n-\n-    def __init__(self,\n-                 depth: int,\n-                 fingerprint: int,\n-                 child_num: int,\n-                 chain_code: bytes,\n-                 private_key: bytes = None,\n-                 public_key: bytes = None,\n-                 curve_name: str = None) -> None:\n-        '''\n-        '''\n-\n-    def derive(self, index: int, public: bool=False) -> None:\n-        '''\n-        Derive a BIP0032 child node in place.\n-        '''\n-\n-    def derive_path(self, path: List[int]) -> None:\n-        '''\n-        Go through a list of indexes and iteratively derive a child node in place.\n-        '''\n-\n-    def serialize_public(self, version: int) -> str:\n-        '''\n-        Serialize the public info from HD node to base58 string.\n-        '''\n-\n-    def serialize_private(self, version: int) -> str:\n-        '''\n-        Serialize the private info HD node to base58 string.\n-        '''\n-\n-    def clone(self) -> HDNode:\n-        '''\n-        Returns a copy of the HD node.\n-        '''\n-\n-    def depth(self) -> int:\n-        '''\n-        Returns a depth of the HD node.\n-        '''\n-\n-    def fingerprint(self) -> int:\n-        '''\n-        Returns a fingerprint of the HD node (hash of the parent public key).\n-        '''\n-\n-    def child_num(self) -> int:\n-        '''\n-        Returns a child index of the HD node.\n-        '''\n-\n-    def chain_code(self) -> bytes:\n-        '''\n-        Returns a chain code of the HD node.\n-        '''\n-\n-    def private_key(self) -> bytes:\n-        '''\n-        Returns a private key of the HD node.\n-        '''\n-\n-    def public_key(self) -> bytes:\n-        '''\n-        Returns a public key of the HD node.\n-        '''\n-\n-    def address(self, version: int) -> str:\n-        '''\n-        Compute a base58-encoded address string from the HD node.\n-        '''\n-\n-    def nem_address(self, network: int) -> str:\n-        '''\n-        Compute a NEM address string from the HD node.\n-        '''\n-\n-    def nem_encrypt(self, transfer_public_key: bytes, iv: bytes, salt: bytes, payload: bytes) -> bytes:\n-        '''\n-        Encrypts payload using the transfer's public key\n-        '''\n-\n-    def ethereum_pubkeyhash(self) -> bytes:\n-        '''\n-        Compute an Ethereum pubkeyhash (aka address) from the HD node.\n-        '''\n-\n-    def deserialize(self, value: str, version_public: int, version_private: int) -> HDNode:\n-        '''\n-        Construct a BIP0032 HD node from a base58-serialized value.\n-        '''\n-\n-    def from_seed(seed: bytes, curve_name: str) -> HDNode:\n-        '''\n-        Construct a BIP0032 HD node from a BIP0039 seed value.\n-        '''\n-\n-# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\n-def find_word(prefix: str) -> Optional[str]:\n-    '''\n-    Return the first word from the wordlist starting with prefix.\n-    '''\n-\n-# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\n-def complete_word(prefix: str) -> int:\n-    '''\n-    Return possible 1-letter suffixes for given word prefix.\n-    Result is a bitmask, with 'a' on the lowest bit, 'b' on the second lowest, etc.\n-    '''\n-\n-# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\n-def generate(strength: int) -> str:\n-    '''\n-    Generate a mnemonic of given strength (128, 160, 192, 224 and 256 bits).\n-    '''\n-\n-# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\n-def from_data(data: bytes) -> str:\n-    '''\n-    Generate a mnemonic from given data (of 16, 20, 24, 28 and 32 bytes).\n-    '''\n-\n-# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\n-def check(mnemonic: str) -> bool:\n-    '''\n-    Check whether given mnemonic is valid.\n-    '''\n-\n-# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\n-def seed(mnemonic: str, passphrase: str) -> bytes:\n-    '''\n-    Generate seed from mnemonic and passphrase.\n-    '''\n+    def encrypt(self, data: bytes) -> bytes:\n+        '''\n+        Encrypt data and update AES context.\n+        '''\n+\n+    def decrypt(self, data: bytes) -> bytes:\n+        '''\n+        Decrypt data and update AES context.\n+        '''\n \n",
        "source_code_with_indent": "\n    <DED>def update(self, data: bytes) -> bytes:\n        <IND>'''\n        Update AES context with data.\n        '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-bip32.h\n<DED><DED>class HDNode:\n    <IND>'''\n    BIP0032 HD node structure.\n    '''\n\n    def __init__(self,\n                 depth: int,\n                 fingerprint: int,\n                 child_num: int,\n                 chain_code: bytes,\n                 private_key: bytes = None,\n                 public_key: bytes = None,\n                 curve_name: str = None) -> None:\n        <IND>'''\n        '''\n\n    <DED>def derive(self, index: int, public: bool=False) -> None:\n        <IND>'''\n        Derive a BIP0032 child node in place.\n        '''\n\n    <DED>def derive_path(self, path: List[int]) -> None:\n        <IND>'''\n        Go through a list of indexes and iteratively derive a child node in place.\n        '''\n\n    <DED>def serialize_public(self, version: int) -> str:\n        <IND>'''\n        Serialize the public info from HD node to base58 string.\n        '''\n\n    <DED>def serialize_private(self, version: int) -> str:\n        <IND>'''\n        Serialize the private info HD node to base58 string.\n        '''\n\n    <DED>def clone(self) -> HDNode:\n        <IND>'''\n        Returns a copy of the HD node.\n        '''\n\n    <DED>def depth(self) -> int:\n        <IND>'''\n        Returns a depth of the HD node.\n        '''\n\n    <DED>def fingerprint(self) -> int:\n        <IND>'''\n        Returns a fingerprint of the HD node (hash of the parent public key).\n        '''\n\n    <DED>def child_num(self) -> int:\n        <IND>'''\n        Returns a child index of the HD node.\n        '''\n\n    <DED>def chain_code(self) -> bytes:\n        <IND>'''\n        Returns a chain code of the HD node.\n        '''\n\n    <DED>def private_key(self) -> bytes:\n        <IND>'''\n        Returns a private key of the HD node.\n        '''\n\n    <DED>def public_key(self) -> bytes:\n        <IND>'''\n        Returns a public key of the HD node.\n        '''\n\n    <DED>def address(self, version: int) -> str:\n        <IND>'''\n        Compute a base58-encoded address string from the HD node.\n        '''\n\n    <DED>def nem_address(self, network: int) -> str:\n        <IND>'''\n        Compute a NEM address string from the HD node.\n        '''\n\n    <DED>def nem_encrypt(self, transfer_public_key: bytes, iv: bytes, salt: bytes, payload: bytes) -> bytes:\n        <IND>'''\n        Encrypts payload using the transfer's public key\n        '''\n\n    <DED>def ethereum_pubkeyhash(self) -> bytes:\n        <IND>'''\n        Compute an Ethereum pubkeyhash (aka address) from the HD node.\n        '''\n\n    <DED>def deserialize(self, value: str, version_public: int, version_private: int) -> HDNode:\n        <IND>'''\n        Construct a BIP0032 HD node from a base58-serialized value.\n        '''\n\n    <DED>def from_seed(seed: bytes, curve_name: str) -> HDNode:\n        <IND>'''\n        Construct a BIP0032 HD node from a BIP0039 seed value.\n        '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\n<DED><DED>def find_word(prefix: str) -> Optional[str]:\n    <IND>'''\n    Return the first word from the wordlist starting with prefix.\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\n<DED>def complete_word(prefix: str) -> int:\n    <IND>'''\n    Return possible 1-letter suffixes for given word prefix.\n    Result is a bitmask, with 'a' on the lowest bit, 'b' on the second lowest, etc.\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\n<DED>def generate(strength: int) -> str:\n    <IND>'''\n    Generate a mnemonic of given strength (128, 160, 192, 224 and 256 bits).\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\n<DED>def from_data(data: bytes) -> str:\n    <IND>'''\n    Generate a mnemonic from given data (of 16, 20, 24, 28 and 32 bytes).\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\n<DED>def check(mnemonic: str) -> bool:\n    <IND>'''\n    Check whether given mnemonic is valid.\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\n<DED>def seed(mnemonic: str, passphrase: str) -> bytes:\n    <IND>'''\n    Generate seed from mnemonic and passphrase.\n    '''\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n    <DED>def encrypt(self, data: bytes) -> bytes:\n        <IND>'''\n        Encrypt data and update AES context.\n        '''\n\n    <DED>def decrypt(self, data: bytes) -> bytes:\n        <IND>'''\n        Decrypt data and update AES context.\n        '''\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "trezor/trezor-firmware",
    "commit": "6724e4e40997c417378d22081b2a1b2fc7e61357",
    "filename": "mocks/generated/trezorcrypto.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/trezor-trezor-firmware/mocks/generated/trezorcrypto/__init__.py",
    "file_hunks_size": 10,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "mocks/generated/trezorcrypto.py:148:4 Incompatible return type [7]: Expected `bool` but got implicit return value of `None`.",
    "message": " Expected `bool` but got implicit return value of `None`.",
    "rule_id": "Incompatible return type [7]",
    "warning_line_no": 148,
    "warning_line": "    '''",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n    def update(self, data: bytes) -> bytes:\n        '''\n        Update AES context with data.\n        '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-bip32.h\nclass HDNode:\n    '''\n    BIP0032 HD node structure.\n    '''\n\n    def __init__(self,\n                 depth: int,\n                 fingerprint: int,\n                 child_num: int,\n                 chain_code: bytes,\n                 private_key: bytes = None,\n                 public_key: bytes = None,\n                 curve_name: str = None) -> None:\n        '''\n        '''\n\n    def derive(self, index: int, public: bool=False) -> None:\n        '''\n        Derive a BIP0032 child node in place.\n        '''\n\n    def derive_path(self, path: List[int]) -> None:\n        '''\n        Go through a list of indexes and iteratively derive a child node in place.\n        '''\n\n    def serialize_public(self, version: int) -> str:\n        '''\n        Serialize the public info from HD node to base58 string.\n        '''\n\n    def serialize_private(self, version: int) -> str:\n        '''\n        Serialize the private info HD node to base58 string.\n        '''\n\n    def clone(self) -> HDNode:\n        '''\n        Returns a copy of the HD node.\n        '''\n\n    def depth(self) -> int:\n        '''\n        Returns a depth of the HD node.\n        '''\n\n    def fingerprint(self) -> int:\n        '''\n        Returns a fingerprint of the HD node (hash of the parent public key).\n        '''\n\n    def child_num(self) -> int:\n        '''\n        Returns a child index of the HD node.\n        '''\n\n    def chain_code(self) -> bytes:\n        '''\n        Returns a chain code of the HD node.\n        '''\n\n    def private_key(self) -> bytes:\n        '''\n        Returns a private key of the HD node.\n        '''\n\n    def public_key(self) -> bytes:\n        '''\n        Returns a public key of the HD node.\n        '''\n\n    def address(self, version: int) -> str:\n        '''\n        Compute a base58-encoded address string from the HD node.\n        '''\n\n    def nem_address(self, network: int) -> str:\n        '''\n        Compute a NEM address string from the HD node.\n        '''\n\n    def nem_encrypt(self, transfer_public_key: bytes, iv: bytes, salt: bytes, payload: bytes) -> bytes:\n        '''\n        Encrypts payload using the transfer's public key\n        '''\n\n    def ethereum_pubkeyhash(self) -> bytes:\n        '''\n        Compute an Ethereum pubkeyhash (aka address) from the HD node.\n        '''\n\n    def deserialize(self, value: str, version_public: int, version_private: int) -> HDNode:\n        '''\n        Construct a BIP0032 HD node from a base58-serialized value.\n        '''\n\n    def from_seed(seed: bytes, curve_name: str) -> HDNode:\n        '''\n        Construct a BIP0032 HD node from a BIP0039 seed value.\n        '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\ndef find_word(prefix: str) -> Optional[str]:\n    '''\n    Return the first word from the wordlist starting with prefix.\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\ndef complete_word(prefix: str) -> int:\n    '''\n    Return possible 1-letter suffixes for given word prefix.\n    Result is a bitmask, with 'a' on the lowest bit, 'b' on the second lowest, etc.\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\ndef generate(strength: int) -> str:\n    '''\n    Generate a mnemonic of given strength (128, 160, 192, 224 and 256 bits).\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\ndef from_data(data: bytes) -> str:\n    '''\n    Generate a mnemonic from given data (of 16, 20, 24, 28 and 32 bytes).\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\ndef check(mnemonic: str) -> bool:\n    '''\n    Check whether given mnemonic is valid.\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\ndef seed(mnemonic: str, passphrase: str) -> bytes:\n    '''\n    Generate seed from mnemonic and passphrase.\n    '''\n\n",
        "source_code_len": 3868,
        "target_code": "\n    def encrypt(self, data: bytes) -> bytes:\n        '''\n        Encrypt data and update AES context.\n        '''\n\n    def decrypt(self, data: bytes) -> bytes:\n        '''\n        Decrypt data and update AES context.\n        '''\n\n",
        "target_code_len": 231,
        "diff_format": "@@ -13,145 +12,11 @@\n \n-    def update(self, data: bytes) -> bytes:\n-        '''\n-        Update AES context with data.\n-        '''\n-\n-# extmod/modtrezorcrypto/modtrezorcrypto-bip32.h\n-class HDNode:\n-    '''\n-    BIP0032 HD node structure.\n-    '''\n-\n-    def __init__(self,\n-                 depth: int,\n-                 fingerprint: int,\n-                 child_num: int,\n-                 chain_code: bytes,\n-                 private_key: bytes = None,\n-                 public_key: bytes = None,\n-                 curve_name: str = None) -> None:\n-        '''\n-        '''\n-\n-    def derive(self, index: int, public: bool=False) -> None:\n-        '''\n-        Derive a BIP0032 child node in place.\n-        '''\n-\n-    def derive_path(self, path: List[int]) -> None:\n-        '''\n-        Go through a list of indexes and iteratively derive a child node in place.\n-        '''\n-\n-    def serialize_public(self, version: int) -> str:\n-        '''\n-        Serialize the public info from HD node to base58 string.\n-        '''\n-\n-    def serialize_private(self, version: int) -> str:\n-        '''\n-        Serialize the private info HD node to base58 string.\n-        '''\n-\n-    def clone(self) -> HDNode:\n-        '''\n-        Returns a copy of the HD node.\n-        '''\n-\n-    def depth(self) -> int:\n-        '''\n-        Returns a depth of the HD node.\n-        '''\n-\n-    def fingerprint(self) -> int:\n-        '''\n-        Returns a fingerprint of the HD node (hash of the parent public key).\n-        '''\n-\n-    def child_num(self) -> int:\n-        '''\n-        Returns a child index of the HD node.\n-        '''\n-\n-    def chain_code(self) -> bytes:\n-        '''\n-        Returns a chain code of the HD node.\n-        '''\n-\n-    def private_key(self) -> bytes:\n-        '''\n-        Returns a private key of the HD node.\n-        '''\n-\n-    def public_key(self) -> bytes:\n-        '''\n-        Returns a public key of the HD node.\n-        '''\n-\n-    def address(self, version: int) -> str:\n-        '''\n-        Compute a base58-encoded address string from the HD node.\n-        '''\n-\n-    def nem_address(self, network: int) -> str:\n-        '''\n-        Compute a NEM address string from the HD node.\n-        '''\n-\n-    def nem_encrypt(self, transfer_public_key: bytes, iv: bytes, salt: bytes, payload: bytes) -> bytes:\n-        '''\n-        Encrypts payload using the transfer's public key\n-        '''\n-\n-    def ethereum_pubkeyhash(self) -> bytes:\n-        '''\n-        Compute an Ethereum pubkeyhash (aka address) from the HD node.\n-        '''\n-\n-    def deserialize(self, value: str, version_public: int, version_private: int) -> HDNode:\n-        '''\n-        Construct a BIP0032 HD node from a base58-serialized value.\n-        '''\n-\n-    def from_seed(seed: bytes, curve_name: str) -> HDNode:\n-        '''\n-        Construct a BIP0032 HD node from a BIP0039 seed value.\n-        '''\n-\n-# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\n-def find_word(prefix: str) -> Optional[str]:\n-    '''\n-    Return the first word from the wordlist starting with prefix.\n-    '''\n-\n-# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\n-def complete_word(prefix: str) -> int:\n-    '''\n-    Return possible 1-letter suffixes for given word prefix.\n-    Result is a bitmask, with 'a' on the lowest bit, 'b' on the second lowest, etc.\n-    '''\n-\n-# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\n-def generate(strength: int) -> str:\n-    '''\n-    Generate a mnemonic of given strength (128, 160, 192, 224 and 256 bits).\n-    '''\n-\n-# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\n-def from_data(data: bytes) -> str:\n-    '''\n-    Generate a mnemonic from given data (of 16, 20, 24, 28 and 32 bytes).\n-    '''\n-\n-# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\n-def check(mnemonic: str) -> bool:\n-    '''\n-    Check whether given mnemonic is valid.\n-    '''\n-\n-# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\n-def seed(mnemonic: str, passphrase: str) -> bytes:\n-    '''\n-    Generate seed from mnemonic and passphrase.\n-    '''\n+    def encrypt(self, data: bytes) -> bytes:\n+        '''\n+        Encrypt data and update AES context.\n+        '''\n+\n+    def decrypt(self, data: bytes) -> bytes:\n+        '''\n+        Decrypt data and update AES context.\n+        '''\n \n",
        "source_code_with_indent": "\n    <DED>def update(self, data: bytes) -> bytes:\n        <IND>'''\n        Update AES context with data.\n        '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-bip32.h\n<DED><DED>class HDNode:\n    <IND>'''\n    BIP0032 HD node structure.\n    '''\n\n    def __init__(self,\n                 depth: int,\n                 fingerprint: int,\n                 child_num: int,\n                 chain_code: bytes,\n                 private_key: bytes = None,\n                 public_key: bytes = None,\n                 curve_name: str = None) -> None:\n        <IND>'''\n        '''\n\n    <DED>def derive(self, index: int, public: bool=False) -> None:\n        <IND>'''\n        Derive a BIP0032 child node in place.\n        '''\n\n    <DED>def derive_path(self, path: List[int]) -> None:\n        <IND>'''\n        Go through a list of indexes and iteratively derive a child node in place.\n        '''\n\n    <DED>def serialize_public(self, version: int) -> str:\n        <IND>'''\n        Serialize the public info from HD node to base58 string.\n        '''\n\n    <DED>def serialize_private(self, version: int) -> str:\n        <IND>'''\n        Serialize the private info HD node to base58 string.\n        '''\n\n    <DED>def clone(self) -> HDNode:\n        <IND>'''\n        Returns a copy of the HD node.\n        '''\n\n    <DED>def depth(self) -> int:\n        <IND>'''\n        Returns a depth of the HD node.\n        '''\n\n    <DED>def fingerprint(self) -> int:\n        <IND>'''\n        Returns a fingerprint of the HD node (hash of the parent public key).\n        '''\n\n    <DED>def child_num(self) -> int:\n        <IND>'''\n        Returns a child index of the HD node.\n        '''\n\n    <DED>def chain_code(self) -> bytes:\n        <IND>'''\n        Returns a chain code of the HD node.\n        '''\n\n    <DED>def private_key(self) -> bytes:\n        <IND>'''\n        Returns a private key of the HD node.\n        '''\n\n    <DED>def public_key(self) -> bytes:\n        <IND>'''\n        Returns a public key of the HD node.\n        '''\n\n    <DED>def address(self, version: int) -> str:\n        <IND>'''\n        Compute a base58-encoded address string from the HD node.\n        '''\n\n    <DED>def nem_address(self, network: int) -> str:\n        <IND>'''\n        Compute a NEM address string from the HD node.\n        '''\n\n    <DED>def nem_encrypt(self, transfer_public_key: bytes, iv: bytes, salt: bytes, payload: bytes) -> bytes:\n        <IND>'''\n        Encrypts payload using the transfer's public key\n        '''\n\n    <DED>def ethereum_pubkeyhash(self) -> bytes:\n        <IND>'''\n        Compute an Ethereum pubkeyhash (aka address) from the HD node.\n        '''\n\n    <DED>def deserialize(self, value: str, version_public: int, version_private: int) -> HDNode:\n        <IND>'''\n        Construct a BIP0032 HD node from a base58-serialized value.\n        '''\n\n    <DED>def from_seed(seed: bytes, curve_name: str) -> HDNode:\n        <IND>'''\n        Construct a BIP0032 HD node from a BIP0039 seed value.\n        '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\n<DED><DED>def find_word(prefix: str) -> Optional[str]:\n    <IND>'''\n    Return the first word from the wordlist starting with prefix.\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\n<DED>def complete_word(prefix: str) -> int:\n    <IND>'''\n    Return possible 1-letter suffixes for given word prefix.\n    Result is a bitmask, with 'a' on the lowest bit, 'b' on the second lowest, etc.\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\n<DED>def generate(strength: int) -> str:\n    <IND>'''\n    Generate a mnemonic of given strength (128, 160, 192, 224 and 256 bits).\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\n<DED>def from_data(data: bytes) -> str:\n    <IND>'''\n    Generate a mnemonic from given data (of 16, 20, 24, 28 and 32 bytes).\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\n<DED>def check(mnemonic: str) -> bool:\n    <IND>'''\n    Check whether given mnemonic is valid.\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-bip39.h\n<DED>def seed(mnemonic: str, passphrase: str) -> bytes:\n    <IND>'''\n    Generate seed from mnemonic and passphrase.\n    '''\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n    <DED>def encrypt(self, data: bytes) -> bytes:\n        <IND>'''\n        Encrypt data and update AES context.\n        '''\n\n    <DED>def decrypt(self, data: bytes) -> bytes:\n        <IND>'''\n        Decrypt data and update AES context.\n        '''\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "trezor/trezor-firmware",
    "commit": "6724e4e40997c417378d22081b2a1b2fc7e61357",
    "filename": "mocks/generated/trezorcrypto.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/trezor-trezor-firmware/mocks/generated/trezorcrypto/__init__.py",
    "file_hunks_size": 10,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "mocks/generated/trezorcrypto.py:319:4 Incompatible return type [7]: Expected `bool` but got implicit return value of `None`.",
    "message": " Expected `bool` but got implicit return value of `None`.",
    "rule_id": "Incompatible return type [7]",
    "warning_line_no": 319,
    "warning_line": "    '''",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n# extmod/modtrezorcrypto/modtrezorcrypto-curve25519.h\ndef generate_secret() -> bytes:\n    '''\n    Generate secret key.\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-curve25519.h\ndef publickey(secret_key: bytes) -> bytes:\n    '''\n    Computes public key from secret key.\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-curve25519.h\ndef multiply(secret_key: bytes, public_key: bytes) -> bytes:\n    '''\n    Multiplies point defined by public_key with scalar defined by secret_key.\n    Useful for ECDH.\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-ed25519.h\ndef generate_secret() -> bytes:\n    '''\n    Generate secret key.\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-ed25519.h\ndef publickey(secret_key: bytes) -> bytes:\n    '''\n    Computes public key from secret key.\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-ed25519.h\ndef sign(secret_key: bytes, message: bytes, hasher: str='') -> bytes:\n    '''\n    Uses secret key to produce the signature of message.\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-ed25519.h\ndef verify(public_key: bytes, signature: bytes, message: bytes) -> bool:\n    '''\n    Uses public key to verify the signature of the message.\n    Returns True on success.\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-ed25519.h\ndef cosi_combine_publickeys(public_keys: List[bytes]) -> bytes:\n    '''\n    Combines a list of public keys used in COSI cosigning scheme.\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-ed25519.h\ndef cosi_combine_signatures(R: bytes, signatures: List[bytes]) -> bytes:\n    '''\n    Combines a list of signatures used in COSI cosigning scheme.\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-ed25519.h\ndef cosi_sign(secret_key: bytes, message: bytes, nonce: bytes, sigR: bytes, combined_pubkey: bytes) -> bytes:\n    '''\n    Produce signature of message using COSI cosigning scheme.\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-nem.h\ndef validate_address(address: str, network: int) -> bool:\n    '''\n    Validate a NEM address\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-nem.h\ndef compute_address(public_key: bytes, network: int) -> str:\n    '''\n    Compute a NEM address from a public key\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-nist256p1.h\ndef generate_secret() -> bytes:\n    '''\n    Generate secret key.\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-nist256p1.h\ndef publickey(secret_key: bytes, compressed: bool = True) -> bytes:\n    '''\n    Computes public key from secret key.\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-nist256p1.h\ndef sign(secret_key: bytes, digest: bytes, compressed: bool = True) -> bytes:\n    '''\n    Uses secret key to produce the signature of the digest.\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-nist256p1.h\ndef verify(public_key: bytes, signature: bytes, digest: bytes) -> bool:\n    '''\n    Uses public key to verify the signature of the digest.\n    Returns True on success.\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-nist256p1.h\ndef verify_recover(signature: bytes, digest: bytes) -> bytes:\n    '''\n    Uses signature of the digest to verify the digest and recover the public key.\n    Returns public key on success, None on failure.\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-nist256p1.h\ndef multiply(secret_key: bytes, public_key: bytes) -> bytes:\n    '''\n    Multiplies point defined by public_key with scalar defined by secret_key.\n    Useful for ECDH.\n    '''\n\n",
        "source_code_len": 3419,
        "target_code": "\n# extmod/modtrezorcrypto/modtrezorcrypto-groestl.h\nclass Groestl512:\n    '''\n    GROESTL512 context.\n    '''\n\n    def __init__(self, data: bytes = None) -> None:\n        '''\n        Creates a hash context object.\n        '''\n\n    def update(self, data: bytes) -> None:\n        '''\n        Update the hash context with hashed data.\n        '''\n\n    def digest(self) -> bytes:\n        '''\n        Returns the digest of hashed data.\n        '''\n\n",
        "target_code_len": 444,
        "diff_format": "@@ -254,114 +119,22 @@\n \n-# extmod/modtrezorcrypto/modtrezorcrypto-curve25519.h\n-def generate_secret() -> bytes:\n-    '''\n-    Generate secret key.\n-    '''\n-\n-# extmod/modtrezorcrypto/modtrezorcrypto-curve25519.h\n-def publickey(secret_key: bytes) -> bytes:\n-    '''\n-    Computes public key from secret key.\n-    '''\n-\n-# extmod/modtrezorcrypto/modtrezorcrypto-curve25519.h\n-def multiply(secret_key: bytes, public_key: bytes) -> bytes:\n-    '''\n-    Multiplies point defined by public_key with scalar defined by secret_key.\n-    Useful for ECDH.\n-    '''\n-\n-# extmod/modtrezorcrypto/modtrezorcrypto-ed25519.h\n-def generate_secret() -> bytes:\n-    '''\n-    Generate secret key.\n-    '''\n-\n-# extmod/modtrezorcrypto/modtrezorcrypto-ed25519.h\n-def publickey(secret_key: bytes) -> bytes:\n-    '''\n-    Computes public key from secret key.\n-    '''\n-\n-# extmod/modtrezorcrypto/modtrezorcrypto-ed25519.h\n-def sign(secret_key: bytes, message: bytes, hasher: str='') -> bytes:\n-    '''\n-    Uses secret key to produce the signature of message.\n-    '''\n-\n-# extmod/modtrezorcrypto/modtrezorcrypto-ed25519.h\n-def verify(public_key: bytes, signature: bytes, message: bytes) -> bool:\n-    '''\n-    Uses public key to verify the signature of the message.\n-    Returns True on success.\n-    '''\n-\n-# extmod/modtrezorcrypto/modtrezorcrypto-ed25519.h\n-def cosi_combine_publickeys(public_keys: List[bytes]) -> bytes:\n-    '''\n-    Combines a list of public keys used in COSI cosigning scheme.\n-    '''\n-\n-# extmod/modtrezorcrypto/modtrezorcrypto-ed25519.h\n-def cosi_combine_signatures(R: bytes, signatures: List[bytes]) -> bytes:\n-    '''\n-    Combines a list of signatures used in COSI cosigning scheme.\n-    '''\n-\n-# extmod/modtrezorcrypto/modtrezorcrypto-ed25519.h\n-def cosi_sign(secret_key: bytes, message: bytes, nonce: bytes, sigR: bytes, combined_pubkey: bytes) -> bytes:\n-    '''\n-    Produce signature of message using COSI cosigning scheme.\n-    '''\n-\n-# extmod/modtrezorcrypto/modtrezorcrypto-nem.h\n-def validate_address(address: str, network: int) -> bool:\n-    '''\n-    Validate a NEM address\n-    '''\n-\n-# extmod/modtrezorcrypto/modtrezorcrypto-nem.h\n-def compute_address(public_key: bytes, network: int) -> str:\n-    '''\n-    Compute a NEM address from a public key\n-    '''\n-\n-# extmod/modtrezorcrypto/modtrezorcrypto-nist256p1.h\n-def generate_secret() -> bytes:\n-    '''\n-    Generate secret key.\n-    '''\n-\n-# extmod/modtrezorcrypto/modtrezorcrypto-nist256p1.h\n-def publickey(secret_key: bytes, compressed: bool = True) -> bytes:\n-    '''\n-    Computes public key from secret key.\n-    '''\n-\n-# extmod/modtrezorcrypto/modtrezorcrypto-nist256p1.h\n-def sign(secret_key: bytes, digest: bytes, compressed: bool = True) -> bytes:\n-    '''\n-    Uses secret key to produce the signature of the digest.\n-    '''\n-\n-# extmod/modtrezorcrypto/modtrezorcrypto-nist256p1.h\n-def verify(public_key: bytes, signature: bytes, digest: bytes) -> bool:\n-    '''\n-    Uses public key to verify the signature of the digest.\n-    Returns True on success.\n-    '''\n-\n-# extmod/modtrezorcrypto/modtrezorcrypto-nist256p1.h\n-def verify_recover(signature: bytes, digest: bytes) -> bytes:\n-    '''\n-    Uses signature of the digest to verify the digest and recover the public key.\n-    Returns public key on success, None on failure.\n-    '''\n-\n-# extmod/modtrezorcrypto/modtrezorcrypto-nist256p1.h\n-def multiply(secret_key: bytes, public_key: bytes) -> bytes:\n-    '''\n-    Multiplies point defined by public_key with scalar defined by secret_key.\n-    Useful for ECDH.\n-    '''\n+# extmod/modtrezorcrypto/modtrezorcrypto-groestl.h\n+class Groestl512:\n+    '''\n+    GROESTL512 context.\n+    '''\n+\n+    def __init__(self, data: bytes = None) -> None:\n+        '''\n+        Creates a hash context object.\n+        '''\n+\n+    def update(self, data: bytes) -> None:\n+        '''\n+        Update the hash context with hashed data.\n+        '''\n+\n+    def digest(self) -> bytes:\n+        '''\n+        Returns the digest of hashed data.\n+        '''\n \n",
        "source_code_with_indent": "\n# extmod/modtrezorcrypto/modtrezorcrypto-curve25519.h\n<DED><DED>def generate_secret() -> bytes:\n    <IND>'''\n    Generate secret key.\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-curve25519.h\n<DED>def publickey(secret_key: bytes) -> bytes:\n    <IND>'''\n    Computes public key from secret key.\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-curve25519.h\n<DED>def multiply(secret_key: bytes, public_key: bytes) -> bytes:\n    <IND>'''\n    Multiplies point defined by public_key with scalar defined by secret_key.\n    Useful for ECDH.\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-ed25519.h\n<DED>def generate_secret() -> bytes:\n    <IND>'''\n    Generate secret key.\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-ed25519.h\n<DED>def publickey(secret_key: bytes) -> bytes:\n    <IND>'''\n    Computes public key from secret key.\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-ed25519.h\n<DED>def sign(secret_key: bytes, message: bytes, hasher: str='') -> bytes:\n    <IND>'''\n    Uses secret key to produce the signature of message.\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-ed25519.h\n<DED>def verify(public_key: bytes, signature: bytes, message: bytes) -> bool:\n    <IND>'''\n    Uses public key to verify the signature of the message.\n    Returns True on success.\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-ed25519.h\n<DED>def cosi_combine_publickeys(public_keys: List[bytes]) -> bytes:\n    <IND>'''\n    Combines a list of public keys used in COSI cosigning scheme.\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-ed25519.h\n<DED>def cosi_combine_signatures(R: bytes, signatures: List[bytes]) -> bytes:\n    <IND>'''\n    Combines a list of signatures used in COSI cosigning scheme.\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-ed25519.h\n<DED>def cosi_sign(secret_key: bytes, message: bytes, nonce: bytes, sigR: bytes, combined_pubkey: bytes) -> bytes:\n    <IND>'''\n    Produce signature of message using COSI cosigning scheme.\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-nem.h\n<DED>def validate_address(address: str, network: int) -> bool:\n    <IND>'''\n    Validate a NEM address\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-nem.h\n<DED>def compute_address(public_key: bytes, network: int) -> str:\n    <IND>'''\n    Compute a NEM address from a public key\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-nist256p1.h\n<DED>def generate_secret() -> bytes:\n    <IND>'''\n    Generate secret key.\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-nist256p1.h\n<DED>def publickey(secret_key: bytes, compressed: bool = True) -> bytes:\n    <IND>'''\n    Computes public key from secret key.\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-nist256p1.h\n<DED>def sign(secret_key: bytes, digest: bytes, compressed: bool = True) -> bytes:\n    <IND>'''\n    Uses secret key to produce the signature of the digest.\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-nist256p1.h\n<DED>def verify(public_key: bytes, signature: bytes, digest: bytes) -> bool:\n    <IND>'''\n    Uses public key to verify the signature of the digest.\n    Returns True on success.\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-nist256p1.h\n<DED>def verify_recover(signature: bytes, digest: bytes) -> bytes:\n    <IND>'''\n    Uses signature of the digest to verify the digest and recover the public key.\n    Returns public key on success, None on failure.\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-nist256p1.h\n<DED>def multiply(secret_key: bytes, public_key: bytes) -> bytes:\n    <IND>'''\n    Multiplies point defined by public_key with scalar defined by secret_key.\n    Useful for ECDH.\n    '''\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n# extmod/modtrezorcrypto/modtrezorcrypto-groestl.h\n<DED><DED>class Groestl512:\n    <IND>'''\n    GROESTL512 context.\n    '''\n\n    def __init__(self, data: bytes = None) -> None:\n        <IND>'''\n        Creates a hash context object.\n        '''\n\n    <DED>def update(self, data: bytes) -> None:\n        <IND>'''\n        Update the hash context with hashed data.\n        '''\n\n    <DED>def digest(self) -> bytes:\n        <IND>'''\n        Returns the digest of hashed data.\n        '''\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "trezor/trezor-firmware",
    "commit": "6724e4e40997c417378d22081b2a1b2fc7e61357",
    "filename": "mocks/generated/trezorcrypto.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/trezor-trezor-firmware/mocks/generated/trezorcrypto/__init__.py",
    "file_hunks_size": 10,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "mocks/generated/trezorcrypto.py:325:4 Incompatible return type [7]: Expected `str` but got implicit return value of `None`.",
    "message": " Expected `str` but got implicit return value of `None`.",
    "rule_id": "Incompatible return type [7]",
    "warning_line_no": 325,
    "warning_line": "    '''",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n# extmod/modtrezorcrypto/modtrezorcrypto-curve25519.h\ndef generate_secret() -> bytes:\n    '''\n    Generate secret key.\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-curve25519.h\ndef publickey(secret_key: bytes) -> bytes:\n    '''\n    Computes public key from secret key.\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-curve25519.h\ndef multiply(secret_key: bytes, public_key: bytes) -> bytes:\n    '''\n    Multiplies point defined by public_key with scalar defined by secret_key.\n    Useful for ECDH.\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-ed25519.h\ndef generate_secret() -> bytes:\n    '''\n    Generate secret key.\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-ed25519.h\ndef publickey(secret_key: bytes) -> bytes:\n    '''\n    Computes public key from secret key.\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-ed25519.h\ndef sign(secret_key: bytes, message: bytes, hasher: str='') -> bytes:\n    '''\n    Uses secret key to produce the signature of message.\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-ed25519.h\ndef verify(public_key: bytes, signature: bytes, message: bytes) -> bool:\n    '''\n    Uses public key to verify the signature of the message.\n    Returns True on success.\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-ed25519.h\ndef cosi_combine_publickeys(public_keys: List[bytes]) -> bytes:\n    '''\n    Combines a list of public keys used in COSI cosigning scheme.\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-ed25519.h\ndef cosi_combine_signatures(R: bytes, signatures: List[bytes]) -> bytes:\n    '''\n    Combines a list of signatures used in COSI cosigning scheme.\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-ed25519.h\ndef cosi_sign(secret_key: bytes, message: bytes, nonce: bytes, sigR: bytes, combined_pubkey: bytes) -> bytes:\n    '''\n    Produce signature of message using COSI cosigning scheme.\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-nem.h\ndef validate_address(address: str, network: int) -> bool:\n    '''\n    Validate a NEM address\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-nem.h\ndef compute_address(public_key: bytes, network: int) -> str:\n    '''\n    Compute a NEM address from a public key\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-nist256p1.h\ndef generate_secret() -> bytes:\n    '''\n    Generate secret key.\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-nist256p1.h\ndef publickey(secret_key: bytes, compressed: bool = True) -> bytes:\n    '''\n    Computes public key from secret key.\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-nist256p1.h\ndef sign(secret_key: bytes, digest: bytes, compressed: bool = True) -> bytes:\n    '''\n    Uses secret key to produce the signature of the digest.\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-nist256p1.h\ndef verify(public_key: bytes, signature: bytes, digest: bytes) -> bool:\n    '''\n    Uses public key to verify the signature of the digest.\n    Returns True on success.\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-nist256p1.h\ndef verify_recover(signature: bytes, digest: bytes) -> bytes:\n    '''\n    Uses signature of the digest to verify the digest and recover the public key.\n    Returns public key on success, None on failure.\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-nist256p1.h\ndef multiply(secret_key: bytes, public_key: bytes) -> bytes:\n    '''\n    Multiplies point defined by public_key with scalar defined by secret_key.\n    Useful for ECDH.\n    '''\n\n",
        "source_code_len": 3419,
        "target_code": "\n# extmod/modtrezorcrypto/modtrezorcrypto-groestl.h\nclass Groestl512:\n    '''\n    GROESTL512 context.\n    '''\n\n    def __init__(self, data: bytes = None) -> None:\n        '''\n        Creates a hash context object.\n        '''\n\n    def update(self, data: bytes) -> None:\n        '''\n        Update the hash context with hashed data.\n        '''\n\n    def digest(self) -> bytes:\n        '''\n        Returns the digest of hashed data.\n        '''\n\n",
        "target_code_len": 444,
        "diff_format": "@@ -254,114 +119,22 @@\n \n-# extmod/modtrezorcrypto/modtrezorcrypto-curve25519.h\n-def generate_secret() -> bytes:\n-    '''\n-    Generate secret key.\n-    '''\n-\n-# extmod/modtrezorcrypto/modtrezorcrypto-curve25519.h\n-def publickey(secret_key: bytes) -> bytes:\n-    '''\n-    Computes public key from secret key.\n-    '''\n-\n-# extmod/modtrezorcrypto/modtrezorcrypto-curve25519.h\n-def multiply(secret_key: bytes, public_key: bytes) -> bytes:\n-    '''\n-    Multiplies point defined by public_key with scalar defined by secret_key.\n-    Useful for ECDH.\n-    '''\n-\n-# extmod/modtrezorcrypto/modtrezorcrypto-ed25519.h\n-def generate_secret() -> bytes:\n-    '''\n-    Generate secret key.\n-    '''\n-\n-# extmod/modtrezorcrypto/modtrezorcrypto-ed25519.h\n-def publickey(secret_key: bytes) -> bytes:\n-    '''\n-    Computes public key from secret key.\n-    '''\n-\n-# extmod/modtrezorcrypto/modtrezorcrypto-ed25519.h\n-def sign(secret_key: bytes, message: bytes, hasher: str='') -> bytes:\n-    '''\n-    Uses secret key to produce the signature of message.\n-    '''\n-\n-# extmod/modtrezorcrypto/modtrezorcrypto-ed25519.h\n-def verify(public_key: bytes, signature: bytes, message: bytes) -> bool:\n-    '''\n-    Uses public key to verify the signature of the message.\n-    Returns True on success.\n-    '''\n-\n-# extmod/modtrezorcrypto/modtrezorcrypto-ed25519.h\n-def cosi_combine_publickeys(public_keys: List[bytes]) -> bytes:\n-    '''\n-    Combines a list of public keys used in COSI cosigning scheme.\n-    '''\n-\n-# extmod/modtrezorcrypto/modtrezorcrypto-ed25519.h\n-def cosi_combine_signatures(R: bytes, signatures: List[bytes]) -> bytes:\n-    '''\n-    Combines a list of signatures used in COSI cosigning scheme.\n-    '''\n-\n-# extmod/modtrezorcrypto/modtrezorcrypto-ed25519.h\n-def cosi_sign(secret_key: bytes, message: bytes, nonce: bytes, sigR: bytes, combined_pubkey: bytes) -> bytes:\n-    '''\n-    Produce signature of message using COSI cosigning scheme.\n-    '''\n-\n-# extmod/modtrezorcrypto/modtrezorcrypto-nem.h\n-def validate_address(address: str, network: int) -> bool:\n-    '''\n-    Validate a NEM address\n-    '''\n-\n-# extmod/modtrezorcrypto/modtrezorcrypto-nem.h\n-def compute_address(public_key: bytes, network: int) -> str:\n-    '''\n-    Compute a NEM address from a public key\n-    '''\n-\n-# extmod/modtrezorcrypto/modtrezorcrypto-nist256p1.h\n-def generate_secret() -> bytes:\n-    '''\n-    Generate secret key.\n-    '''\n-\n-# extmod/modtrezorcrypto/modtrezorcrypto-nist256p1.h\n-def publickey(secret_key: bytes, compressed: bool = True) -> bytes:\n-    '''\n-    Computes public key from secret key.\n-    '''\n-\n-# extmod/modtrezorcrypto/modtrezorcrypto-nist256p1.h\n-def sign(secret_key: bytes, digest: bytes, compressed: bool = True) -> bytes:\n-    '''\n-    Uses secret key to produce the signature of the digest.\n-    '''\n-\n-# extmod/modtrezorcrypto/modtrezorcrypto-nist256p1.h\n-def verify(public_key: bytes, signature: bytes, digest: bytes) -> bool:\n-    '''\n-    Uses public key to verify the signature of the digest.\n-    Returns True on success.\n-    '''\n-\n-# extmod/modtrezorcrypto/modtrezorcrypto-nist256p1.h\n-def verify_recover(signature: bytes, digest: bytes) -> bytes:\n-    '''\n-    Uses signature of the digest to verify the digest and recover the public key.\n-    Returns public key on success, None on failure.\n-    '''\n-\n-# extmod/modtrezorcrypto/modtrezorcrypto-nist256p1.h\n-def multiply(secret_key: bytes, public_key: bytes) -> bytes:\n-    '''\n-    Multiplies point defined by public_key with scalar defined by secret_key.\n-    Useful for ECDH.\n-    '''\n+# extmod/modtrezorcrypto/modtrezorcrypto-groestl.h\n+class Groestl512:\n+    '''\n+    GROESTL512 context.\n+    '''\n+\n+    def __init__(self, data: bytes = None) -> None:\n+        '''\n+        Creates a hash context object.\n+        '''\n+\n+    def update(self, data: bytes) -> None:\n+        '''\n+        Update the hash context with hashed data.\n+        '''\n+\n+    def digest(self) -> bytes:\n+        '''\n+        Returns the digest of hashed data.\n+        '''\n \n",
        "source_code_with_indent": "\n# extmod/modtrezorcrypto/modtrezorcrypto-curve25519.h\n<DED><DED>def generate_secret() -> bytes:\n    <IND>'''\n    Generate secret key.\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-curve25519.h\n<DED>def publickey(secret_key: bytes) -> bytes:\n    <IND>'''\n    Computes public key from secret key.\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-curve25519.h\n<DED>def multiply(secret_key: bytes, public_key: bytes) -> bytes:\n    <IND>'''\n    Multiplies point defined by public_key with scalar defined by secret_key.\n    Useful for ECDH.\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-ed25519.h\n<DED>def generate_secret() -> bytes:\n    <IND>'''\n    Generate secret key.\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-ed25519.h\n<DED>def publickey(secret_key: bytes) -> bytes:\n    <IND>'''\n    Computes public key from secret key.\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-ed25519.h\n<DED>def sign(secret_key: bytes, message: bytes, hasher: str='') -> bytes:\n    <IND>'''\n    Uses secret key to produce the signature of message.\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-ed25519.h\n<DED>def verify(public_key: bytes, signature: bytes, message: bytes) -> bool:\n    <IND>'''\n    Uses public key to verify the signature of the message.\n    Returns True on success.\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-ed25519.h\n<DED>def cosi_combine_publickeys(public_keys: List[bytes]) -> bytes:\n    <IND>'''\n    Combines a list of public keys used in COSI cosigning scheme.\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-ed25519.h\n<DED>def cosi_combine_signatures(R: bytes, signatures: List[bytes]) -> bytes:\n    <IND>'''\n    Combines a list of signatures used in COSI cosigning scheme.\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-ed25519.h\n<DED>def cosi_sign(secret_key: bytes, message: bytes, nonce: bytes, sigR: bytes, combined_pubkey: bytes) -> bytes:\n    <IND>'''\n    Produce signature of message using COSI cosigning scheme.\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-nem.h\n<DED>def validate_address(address: str, network: int) -> bool:\n    <IND>'''\n    Validate a NEM address\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-nem.h\n<DED>def compute_address(public_key: bytes, network: int) -> str:\n    <IND>'''\n    Compute a NEM address from a public key\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-nist256p1.h\n<DED>def generate_secret() -> bytes:\n    <IND>'''\n    Generate secret key.\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-nist256p1.h\n<DED>def publickey(secret_key: bytes, compressed: bool = True) -> bytes:\n    <IND>'''\n    Computes public key from secret key.\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-nist256p1.h\n<DED>def sign(secret_key: bytes, digest: bytes, compressed: bool = True) -> bytes:\n    <IND>'''\n    Uses secret key to produce the signature of the digest.\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-nist256p1.h\n<DED>def verify(public_key: bytes, signature: bytes, digest: bytes) -> bool:\n    <IND>'''\n    Uses public key to verify the signature of the digest.\n    Returns True on success.\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-nist256p1.h\n<DED>def verify_recover(signature: bytes, digest: bytes) -> bytes:\n    <IND>'''\n    Uses signature of the digest to verify the digest and recover the public key.\n    Returns public key on success, None on failure.\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-nist256p1.h\n<DED>def multiply(secret_key: bytes, public_key: bytes) -> bytes:\n    <IND>'''\n    Multiplies point defined by public_key with scalar defined by secret_key.\n    Useful for ECDH.\n    '''\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n# extmod/modtrezorcrypto/modtrezorcrypto-groestl.h\n<DED><DED>class Groestl512:\n    <IND>'''\n    GROESTL512 context.\n    '''\n\n    def __init__(self, data: bytes = None) -> None:\n        <IND>'''\n        Creates a hash context object.\n        '''\n\n    <DED>def update(self, data: bytes) -> None:\n        <IND>'''\n        Update the hash context with hashed data.\n        '''\n\n    <DED>def digest(self) -> bytes:\n        <IND>'''\n        Returns the digest of hashed data.\n        '''\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "trezor/trezor-firmware",
    "commit": "6724e4e40997c417378d22081b2a1b2fc7e61357",
    "filename": "mocks/generated/trezorcrypto.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/trezor-trezor-firmware/mocks/generated/trezorcrypto/__init__.py",
    "file_hunks_size": 10,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "mocks/generated/trezorcrypto.py:374:63 Incompatible variable type [9]: iterations is declared to have type `int` but is used as type `None`.",
    "message": " iterations is declared to have type `int` but is used as type `None`.",
    "rule_id": "Incompatible variable type [9]",
    "warning_line_no": 374,
    "warning_line": "    def __init__(self, prf: str, password: bytes, salt: bytes, iterations: int = None) -> None:"
  },
  {
    "project": "trezor/trezor-firmware",
    "commit": "6724e4e40997c417378d22081b2a1b2fc7e61357",
    "filename": "mocks/generated/trezorcrypto.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/trezor-trezor-firmware/mocks/generated/trezorcrypto/__init__.py",
    "file_hunks_size": 10,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "mocks/generated/trezorcrypto.py:391:4 Incompatible return type [7]: Expected `int` but got implicit return value of `None`.",
    "message": " Expected `int` but got implicit return value of `None`.",
    "rule_id": "Incompatible return type [7]",
    "warning_line_no": 391,
    "warning_line": "    '''"
  },
  {
    "project": "trezor/trezor-firmware",
    "commit": "6724e4e40997c417378d22081b2a1b2fc7e61357",
    "filename": "mocks/generated/trezorcrypto.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/trezor-trezor-firmware/mocks/generated/trezorcrypto/__init__.py",
    "file_hunks_size": 10,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": true,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "mocks/generated/trezorcrypto.py:464:4 Incompatible return type [7]: Expected `bool` but got implicit return value of `None`.",
    "message": " Expected `bool` but got implicit return value of `None`.",
    "rule_id": "Incompatible return type [7]",
    "warning_line_no": 464,
    "warning_line": "    '''",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": true,
        "has_suppression": false,
        "source_code": "\n# extmod/modtrezorcrypto/modtrezorcrypto-secp256k1.h\ndef generate_secret() -> bytes:\n    '''\n    Generate secret key.\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-secp256k1.h\ndef publickey(secret_key: bytes, compressed: bool = True) -> bytes:\n    '''\n    Computes public key from secret key.\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-secp256k1.h\ndef sign(secret_key: bytes, digest: bytes, compressed: bool = True) -> bytes:\n    '''\n    Uses secret key to produce the signature of the digest.\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-secp256k1.h\ndef verify(public_key: bytes, signature: bytes, digest: bytes) -> bool:\n    '''\n    Uses public key to verify the signature of the digest.\n    Returns True on success.\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-secp256k1.h\ndef verify_recover(signature: bytes, digest: bytes) -> bytes:\n    '''\n    Uses signature of the digest to verify the digest and recover the public key.\n    Returns public key on success, None on failure.\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-secp256k1.h\ndef multiply(secret_key: bytes, public_key: bytes) -> bytes:\n    '''\n    Multiplies point defined by public_key with scalar defined by secret_key.\n    Useful for ECDH.\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-sha1.h\n",
        "source_code_len": 1289,
        "target_code": "\n# extmod/modtrezorcrypto/modtrezorcrypto-sha1.h\n",
        "target_code_len": 49,
        "diff_format": "@@ -443,41 +198,2 @@\n \n-# extmod/modtrezorcrypto/modtrezorcrypto-secp256k1.h\n-def generate_secret() -> bytes:\n-    '''\n-    Generate secret key.\n-    '''\n-\n-# extmod/modtrezorcrypto/modtrezorcrypto-secp256k1.h\n-def publickey(secret_key: bytes, compressed: bool = True) -> bytes:\n-    '''\n-    Computes public key from secret key.\n-    '''\n-\n-# extmod/modtrezorcrypto/modtrezorcrypto-secp256k1.h\n-def sign(secret_key: bytes, digest: bytes, compressed: bool = True) -> bytes:\n-    '''\n-    Uses secret key to produce the signature of the digest.\n-    '''\n-\n-# extmod/modtrezorcrypto/modtrezorcrypto-secp256k1.h\n-def verify(public_key: bytes, signature: bytes, digest: bytes) -> bool:\n-    '''\n-    Uses public key to verify the signature of the digest.\n-    Returns True on success.\n-    '''\n-\n-# extmod/modtrezorcrypto/modtrezorcrypto-secp256k1.h\n-def verify_recover(signature: bytes, digest: bytes) -> bytes:\n-    '''\n-    Uses signature of the digest to verify the digest and recover the public key.\n-    Returns public key on success, None on failure.\n-    '''\n-\n-# extmod/modtrezorcrypto/modtrezorcrypto-secp256k1.h\n-def multiply(secret_key: bytes, public_key: bytes) -> bytes:\n-    '''\n-    Multiplies point defined by public_key with scalar defined by secret_key.\n-    Useful for ECDH.\n-    '''\n-\n # extmod/modtrezorcrypto/modtrezorcrypto-sha1.h\n",
        "source_code_with_indent": "\n# extmod/modtrezorcrypto/modtrezorcrypto-secp256k1.h\n<DED><DED>def generate_secret() -> bytes:\n    <IND>'''\n    Generate secret key.\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-secp256k1.h\n<DED>def publickey(secret_key: bytes, compressed: bool = True) -> bytes:\n    <IND>'''\n    Computes public key from secret key.\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-secp256k1.h\n<DED>def sign(secret_key: bytes, digest: bytes, compressed: bool = True) -> bytes:\n    <IND>'''\n    Uses secret key to produce the signature of the digest.\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-secp256k1.h\n<DED>def verify(public_key: bytes, signature: bytes, digest: bytes) -> bool:\n    <IND>'''\n    Uses public key to verify the signature of the digest.\n    Returns True on success.\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-secp256k1.h\n<DED>def verify_recover(signature: bytes, digest: bytes) -> bytes:\n    <IND>'''\n    Uses signature of the digest to verify the digest and recover the public key.\n    Returns public key on success, None on failure.\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-secp256k1.h\n<DED>def multiply(secret_key: bytes, public_key: bytes) -> bytes:\n    <IND>'''\n    Multiplies point defined by public_key with scalar defined by secret_key.\n    Useful for ECDH.\n    '''\n\n# extmod/modtrezorcrypto/modtrezorcrypto-sha1.h\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n# extmod/modtrezorcrypto/modtrezorcrypto-sha1.h\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "trezor/trezor-firmware",
    "commit": "6724e4e40997c417378d22081b2a1b2fc7e61357",
    "filename": "mocks/generated/trezorutils.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/trezor-trezor-firmware/mocks/generated/trezorutils.py",
    "file_hunks_size": 1,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": true,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "mocks/generated/trezorutils.py:35:25 Invalid type [31]: Expression `str.__truediv__(int).__truediv__(None)` is not a valid type.",
    "message": " Expression `str.__truediv__(int).__truediv__(None)` is not a valid type.",
    "rule_id": "Invalid type [31]",
    "warning_line_no": 35,
    "warning_line": "def symbol(name: str) -> str/int/None:",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": true,
        "has_suppression": false,
        "source_code": "    '''\n\n# extmod/modtrezorutils/modtrezorutils.c\ndef symbol(name: str) -> str/int/None:\n    '''\n    Retrieve internal symbol.\n    '''\n\n# extmod/modtrezorutils/modtrezorutils.c\ndef model() -> str:\n    '''\n    Return which hardware model we are running on.\n    '''\n",
        "source_code_len": 264,
        "target_code": "    '''\n",
        "target_code_len": 8,
        "diff_format": "@@ -32,13 +32,1 @@\n     '''\n-\n-# extmod/modtrezorutils/modtrezorutils.c\n-def symbol(name: str) -> str/int/None:\n-    '''\n-    Retrieve internal symbol.\n-    '''\n-\n-# extmod/modtrezorutils/modtrezorutils.c\n-def model() -> str:\n-    '''\n-    Return which hardware model we are running on.\n-    '''\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\n\n# extmod/modtrezorutils/modtrezorutils.c\n<DED>def symbol(name: str) -> str/int/None:\n    <IND>'''\n    Retrieve internal symbol.\n    '''\n\n# extmod/modtrezorutils/modtrezorutils.c\n<DED>def model() -> str:\n    <IND>'''\n    Return which hardware model we are running on.\n    '''\n",
        "target_code_with_indent": "\n"
      }
    ]
  },
  {
    "project": "trezor/trezor-firmware",
    "commit": "6724e4e40997c417378d22081b2a1b2fc7e61357",
    "filename": "mocks/generated/trezorutils.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/trezor-trezor-firmware/mocks/generated/trezorutils.py",
    "file_hunks_size": 1,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": true,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "mocks/generated/trezorutils.py:42:4 Incompatible return type [7]: Expected `str` but got implicit return value of `None`.",
    "message": " Expected `str` but got implicit return value of `None`.",
    "rule_id": "Incompatible return type [7]",
    "warning_line_no": 42,
    "warning_line": "    '''",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": true,
        "has_suppression": false,
        "source_code": "    '''\n\n# extmod/modtrezorutils/modtrezorutils.c\ndef symbol(name: str) -> str/int/None:\n    '''\n    Retrieve internal symbol.\n    '''\n\n# extmod/modtrezorutils/modtrezorutils.c\ndef model() -> str:\n    '''\n    Return which hardware model we are running on.\n    '''\n",
        "source_code_len": 264,
        "target_code": "    '''\n",
        "target_code_len": 8,
        "diff_format": "@@ -32,13 +32,1 @@\n     '''\n-\n-# extmod/modtrezorutils/modtrezorutils.c\n-def symbol(name: str) -> str/int/None:\n-    '''\n-    Retrieve internal symbol.\n-    '''\n-\n-# extmod/modtrezorutils/modtrezorutils.c\n-def model() -> str:\n-    '''\n-    Return which hardware model we are running on.\n-    '''\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\n\n# extmod/modtrezorutils/modtrezorutils.c\n<DED>def symbol(name: str) -> str/int/None:\n    <IND>'''\n    Retrieve internal symbol.\n    '''\n\n# extmod/modtrezorutils/modtrezorutils.c\n<DED>def model() -> str:\n    <IND>'''\n    Return which hardware model we are running on.\n    '''\n",
        "target_code_with_indent": "\n"
      }
    ]
  },
  {
    "project": "trezor/trezor-firmware",
    "commit": "6724e4e40997c417378d22081b2a1b2fc7e61357",
    "filename": "src/trezor/messages/MoneroExportedKeyImage.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/trezor-trezor-firmware/src/trezor/messages/MoneroExportedKeyImage.py",
    "file_hunks_size": 3,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "src/trezor/messages/MoneroExportedKeyImage.py:11:8 Incompatible variable type [9]: tag is declared to have type `bytes` but is used as type `None`.",
    "message": " tag is declared to have type `bytes` but is used as type `None`.",
    "rule_id": "Incompatible variable type [9]",
    "warning_line_no": 11,
    "warning_line": "        tag: bytes = None,"
  },
  {
    "project": "trezor/trezor-firmware",
    "commit": "6724e4e40997c417378d22081b2a1b2fc7e61357",
    "filename": "src/trezor/messages/MoneroRctKey.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/trezor-trezor-firmware/src/trezor/messages/MoneroRctKeyPublic.py",
    "file_hunks_size": 3,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "src/trezor/messages/MoneroRctKey.py:10:8 Incompatible variable type [9]: dest is declared to have type `bytes` but is used as type `None`.",
    "message": " dest is declared to have type `bytes` but is used as type `None`.",
    "rule_id": "Incompatible variable type [9]",
    "warning_line_no": 10,
    "warning_line": "        dest: bytes = None,"
  },
  {
    "project": "trezor/trezor-firmware",
    "commit": "6724e4e40997c417378d22081b2a1b2fc7e61357",
    "filename": "src/trezor/messages/MoneroRctKey.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/trezor-trezor-firmware/src/trezor/messages/MoneroRctKeyPublic.py",
    "file_hunks_size": 3,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "src/trezor/messages/MoneroRctKey.py:11:8 Incompatible variable type [9]: mask is declared to have type `bytes` but is used as type `None`.",
    "message": " mask is declared to have type `bytes` but is used as type `None`.",
    "rule_id": "Incompatible variable type [9]",
    "warning_line_no": 11,
    "warning_line": "        mask: bytes = None,"
  },
  {
    "project": "trezor/trezor-firmware",
    "commit": "6724e4e40997c417378d22081b2a1b2fc7e61357",
    "filename": "src/trezor/messages/MoneroTransactionAllInputsSetRequest.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/trezor-trezor-firmware/src/trezor/messages/MoneroTransactionAllInputsSetRequest.py",
    "file_hunks_size": 2,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": true,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "src/trezor/messages/MoneroTransactionAllInputsSetRequest.py:13:8 Incompatible variable type [9]: rsig_data is declared to have type `MoneroTransactionRsigData` but is used as type `None`.",
    "message": " rsig_data is declared to have type `MoneroTransactionRsigData` but is used as type `None`.",
    "rule_id": "Incompatible variable type [9]",
    "warning_line_no": 13,
    "warning_line": "        rsig_data: MoneroTransactionRsigData = None,",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": true,
        "has_suppression": false,
        "source_code": "    MESSAGE_WIRE_TYPE = 509\n\n    def __init__(\n        self,\n        rsig_data: MoneroTransactionRsigData = None,\n    ) -> None:\n        self.rsig_data = rsig_data\n\n    @classmethod\n    def get_fields(cls):\n        return {\n            1: ('rsig_data', MoneroTransactionRsigData, 0),\n        }\n",
        "source_code_len": 294,
        "target_code": "    MESSAGE_WIRE_TYPE = 509\n",
        "target_code_len": 28,
        "diff_format": "@@ -9,13 +7,1 @@\n     MESSAGE_WIRE_TYPE = 509\n-\n-    def __init__(\n-        self,\n-        rsig_data: MoneroTransactionRsigData = None,\n-    ) -> None:\n-        self.rsig_data = rsig_data\n-\n-    @classmethod\n-    def get_fields(cls):\n-        return {\n-            1: ('rsig_data', MoneroTransactionRsigData, 0),\n-        }\n",
        "source_code_with_indent": "    <IND>MESSAGE_WIRE_TYPE = 509\n\n    def __init__(\n        self,\n        rsig_data: MoneroTransactionRsigData = None,\n    ) -> None:\n        <IND>self.rsig_data = rsig_data\n\n    <DED>@classmethod\n    def get_fields(cls):\n        <IND>return {\n            1: ('rsig_data', MoneroTransactionRsigData, 0),\n        }\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    <IND>MESSAGE_WIRE_TYPE = 509\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "trezor/trezor-firmware",
    "commit": "6724e4e40997c417378d22081b2a1b2fc7e61357",
    "filename": "src/trezor/messages/MoneroTransactionData.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/trezor-trezor-firmware/src/trezor/messages/MoneroTransactionData.py",
    "file_hunks_size": 3,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "src/trezor/messages/MoneroTransactionData.py:29:8 Incompatible variable type [9]: is_multisig is declared to have type `bool` but is used as type `None`.",
    "message": " is_multisig is declared to have type `bool` but is used as type `None`.",
    "rule_id": "Incompatible variable type [9]",
    "warning_line_no": 29,
    "warning_line": "        is_multisig: bool = None,"
  },
  {
    "project": "trezor/trezor-firmware",
    "commit": "6724e4e40997c417378d22081b2a1b2fc7e61357",
    "filename": "src/trezor/messages/MoneroTransactionData.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/trezor-trezor-firmware/src/trezor/messages/MoneroTransactionData.py",
    "file_hunks_size": 3,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "src/trezor/messages/MoneroTransactionData.py:30:8 Incompatible variable type [9]: exp_tx_prefix_hash is declared to have type `bytes` but is used as type `None`.",
    "message": " exp_tx_prefix_hash is declared to have type `bytes` but is used as type `None`.",
    "rule_id": "Incompatible variable type [9]",
    "warning_line_no": 30,
    "warning_line": "        exp_tx_prefix_hash: bytes = None,"
  },
  {
    "project": "trezor/trezor-firmware",
    "commit": "6724e4e40997c417378d22081b2a1b2fc7e61357",
    "filename": "src/trezor/messages/MoneroTransactionData.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/trezor-trezor-firmware/src/trezor/messages/MoneroTransactionData.py",
    "file_hunks_size": 3,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "src/trezor/messages/MoneroTransactionData.py:31:8 Incompatible variable type [9]: use_tx_keys is declared to have type `List[bytes]` but is used as type `None`.",
    "message": " use_tx_keys is declared to have type `List[bytes]` but is used as type `None`.",
    "rule_id": "Incompatible variable type [9]",
    "warning_line_no": 31,
    "warning_line": "        use_tx_keys: List[bytes] = None,"
  },
  {
    "project": "trezor/trezor-firmware",
    "commit": "6724e4e40997c417378d22081b2a1b2fc7e61357",
    "filename": "src/trezor/messages/MoneroTransactionInitAck.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/trezor-trezor-firmware/src/trezor/messages/MoneroTransactionInitAck.py",
    "file_hunks_size": 2,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "src/trezor/messages/MoneroTransactionInitAck.py:19:8 Incompatible variable type [9]: version is declared to have type `int` but is used as type `None`.",
    "message": " version is declared to have type `int` but is used as type `None`.",
    "rule_id": "Incompatible variable type [9]",
    "warning_line_no": 19,
    "warning_line": "        version: int = None,"
  },
  {
    "project": "trezor/trezor-firmware",
    "commit": "6724e4e40997c417378d22081b2a1b2fc7e61357",
    "filename": "src/trezor/messages/MoneroTransactionInitAck.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/trezor-trezor-firmware/src/trezor/messages/MoneroTransactionInitAck.py",
    "file_hunks_size": 2,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "src/trezor/messages/MoneroTransactionInitAck.py:20:8 Incompatible variable type [9]: status is declared to have type `int` but is used as type `None`.",
    "message": " status is declared to have type `int` but is used as type `None`.",
    "rule_id": "Incompatible variable type [9]",
    "warning_line_no": 20,
    "warning_line": "        status: int = None,"
  },
  {
    "project": "trezor/trezor-firmware",
    "commit": "6724e4e40997c417378d22081b2a1b2fc7e61357",
    "filename": "src/trezor/messages/MoneroTransactionInitAck.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/trezor-trezor-firmware/src/trezor/messages/MoneroTransactionInitAck.py",
    "file_hunks_size": 2,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "src/trezor/messages/MoneroTransactionInitAck.py:21:8 Incompatible variable type [9]: in_memory is declared to have type `bool` but is used as type `None`.",
    "message": " in_memory is declared to have type `bool` but is used as type `None`.",
    "rule_id": "Incompatible variable type [9]",
    "warning_line_no": 21,
    "warning_line": "        in_memory: bool = None,"
  },
  {
    "project": "trezor/trezor-firmware",
    "commit": "6724e4e40997c417378d22081b2a1b2fc7e61357",
    "filename": "src/trezor/messages/MoneroTransactionInitAck.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/trezor-trezor-firmware/src/trezor/messages/MoneroTransactionInitAck.py",
    "file_hunks_size": 2,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "src/trezor/messages/MoneroTransactionInitAck.py:23:8 Incompatible variable type [9]: many_inputs is declared to have type `bool` but is used as type `None`.",
    "message": " many_inputs is declared to have type `bool` but is used as type `None`.",
    "rule_id": "Incompatible variable type [9]",
    "warning_line_no": 23,
    "warning_line": "        many_inputs: bool = None,"
  },
  {
    "project": "trezor/trezor-firmware",
    "commit": "6724e4e40997c417378d22081b2a1b2fc7e61357",
    "filename": "src/trezor/messages/MoneroTransactionInitAck.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/trezor-trezor-firmware/src/trezor/messages/MoneroTransactionInitAck.py",
    "file_hunks_size": 2,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "src/trezor/messages/MoneroTransactionInitAck.py:24:8 Incompatible variable type [9]: many_outputs is declared to have type `bool` but is used as type `None`.",
    "message": " many_outputs is declared to have type `bool` but is used as type `None`.",
    "rule_id": "Incompatible variable type [9]",
    "warning_line_no": 24,
    "warning_line": "        many_outputs: bool = None,"
  },
  {
    "project": "trezor/trezor-firmware",
    "commit": "6724e4e40997c417378d22081b2a1b2fc7e61357",
    "filename": "src/trezor/messages/MoneroTransactionMlsagDoneAck.py",
    "min_patch_found": false,
    "full_warning_msg": "src/trezor/messages/MoneroTransactionMlsagDoneAck.py:11:8 Incompatible variable type [9]: full_message_hash is declared to have type `bytes` but is used as type `None`.",
    "exception": "[Errno 2] No such file or directory: '/home/chowyi/TypeAnnotation_Study/GitHub/trezor-trezor-firmware/src/trezor/messages/MoneroTransactionMlsagDoneAck.py'",
    "dd_fail": true
  },
  {
    "project": "trezor/trezor-firmware",
    "commit": "6724e4e40997c417378d22081b2a1b2fc7e61357",
    "filename": "src/trezor/messages/MoneroTransactionRsigData.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/trezor-trezor-firmware/src/trezor/messages/MoneroTransactionRsigData.py",
    "file_hunks_size": 5,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "src/trezor/messages/MoneroTransactionRsigData.py:18:8 Incompatible variable type [9]: version is declared to have type `int` but is used as type `None`.",
    "message": " version is declared to have type `int` but is used as type `None`.",
    "rule_id": "Incompatible variable type [9]",
    "warning_line_no": 18,
    "warning_line": "        version: int = None,"
  },
  {
    "project": "trezor/trezor-firmware",
    "commit": "6724e4e40997c417378d22081b2a1b2fc7e61357",
    "filename": "src/trezor/messages/MoneroTransactionRsigData.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/trezor-trezor-firmware/src/trezor/messages/MoneroTransactionRsigData.py",
    "file_hunks_size": 5,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "src/trezor/messages/MoneroTransactionRsigData.py:22:8 Incompatible variable type [9]: step is declared to have type `int` but is used as type `None`.",
    "message": " step is declared to have type `int` but is used as type `None`.",
    "rule_id": "Incompatible variable type [9]",
    "warning_line_no": 22,
    "warning_line": "        step: int = None,"
  },
  {
    "project": "trezor/trezor-firmware",
    "commit": "6724e4e40997c417378d22081b2a1b2fc7e61357",
    "filename": "src/trezor/messages/MoneroTransactionRsigData.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/trezor-trezor-firmware/src/trezor/messages/MoneroTransactionRsigData.py",
    "file_hunks_size": 5,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "src/trezor/messages/MoneroTransactionRsigData.py:23:8 Incompatible variable type [9]: operation is declared to have type `int` but is used as type `None`.",
    "message": " operation is declared to have type `int` but is used as type `None`.",
    "rule_id": "Incompatible variable type [9]",
    "warning_line_no": 23,
    "warning_line": "        operation: int = None,"
  },
  {
    "project": "trezor/trezor-firmware",
    "commit": "6724e4e40997c417378d22081b2a1b2fc7e61357",
    "filename": "src/trezor/messages/MoneroTransactionRsigData.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/trezor-trezor-firmware/src/trezor/messages/MoneroTransactionRsigData.py",
    "file_hunks_size": 5,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "src/trezor/messages/MoneroTransactionRsigData.py:24:8 Incompatible variable type [9]: seed is declared to have type `bytes` but is used as type `None`.",
    "message": " seed is declared to have type `bytes` but is used as type `None`.",
    "rule_id": "Incompatible variable type [9]",
    "warning_line_no": 24,
    "warning_line": "        seed: bytes = None,"
  },
  {
    "project": "trezor/trezor-firmware",
    "commit": "6724e4e40997c417378d22081b2a1b2fc7e61357",
    "filename": "src/trezor/messages/MoneroTransactionRsigData.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/trezor-trezor-firmware/src/trezor/messages/MoneroTransactionRsigData.py",
    "file_hunks_size": 5,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "src/trezor/messages/MoneroTransactionRsigData.py:26:8 Incompatible variable type [9]: amount is declared to have type `bytes` but is used as type `None`.",
    "message": " amount is declared to have type `bytes` but is used as type `None`.",
    "rule_id": "Incompatible variable type [9]",
    "warning_line_no": 26,
    "warning_line": "        amount: bytes = None,"
  },
  {
    "project": "trezor/trezor-firmware",
    "commit": "6724e4e40997c417378d22081b2a1b2fc7e61357",
    "filename": "src/trezor/messages/MoneroTransactionRsigData.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/trezor-trezor-firmware/src/trezor/messages/MoneroTransactionRsigData.py",
    "file_hunks_size": 5,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "src/trezor/messages/MoneroTransactionRsigData.py:29:8 Incompatible variable type [9]: outputs is declared to have type `List[MoneroTransactionDestinationEntry]` but is used as type `None`.",
    "message": " outputs is declared to have type `List[MoneroTransactionDestinationEntry]` but is used as type `None`.",
    "rule_id": "Incompatible variable type [9]",
    "warning_line_no": 29,
    "warning_line": "        outputs: List[MoneroTransactionDestinationEntry] = None,"
  },
  {
    "project": "trezor/trezor-firmware",
    "commit": "6724e4e40997c417378d22081b2a1b2fc7e61357",
    "filename": "src/trezor/messages/MoneroTransactionSetInputRequest.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/trezor-trezor-firmware/src/trezor/messages/MoneroTransactionSetInputRequest.py",
    "file_hunks_size": 2,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "src/trezor/messages/MoneroTransactionSetInputRequest.py:13:8 Incompatible variable type [9]: version is declared to have type `int` but is used as type `None`.",
    "message": " version is declared to have type `int` but is used as type `None`.",
    "rule_id": "Incompatible variable type [9]",
    "warning_line_no": 13,
    "warning_line": "        version: int = None,"
  },
  {
    "project": "trezor/trezor-firmware",
    "commit": "6724e4e40997c417378d22081b2a1b2fc7e61357",
    "filename": "src/trezor/messages/MoneroTransactionSignInputAck.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/trezor-trezor-firmware/src/trezor/messages/MoneroTransactionSignInputAck.py",
    "file_hunks_size": 3,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "src/trezor/messages/MoneroTransactionSignInputAck.py:12:8 Incompatible variable type [9]: cout is declared to have type `bytes` but is used as type `None`.",
    "message": " cout is declared to have type `bytes` but is used as type `None`.",
    "rule_id": "Incompatible variable type [9]",
    "warning_line_no": 12,
    "warning_line": "        cout: bytes = None,"
  }
]