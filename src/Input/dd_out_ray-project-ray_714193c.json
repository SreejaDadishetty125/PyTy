[
  {
    "project": "ray-project/ray",
    "commit": "714193ce6fe1a6b6a6c6ae6c936e8effaff372e7",
    "filename": "python/ray/tune/utils/util.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/ray-project-ray/python/ray/tune/utils/util.py",
    "file_hunks_size": 3,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": true,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "python/ray/tune/utils/util.py:308:28 Incompatible parameter type [6]: Expected `Union[typing.Type[typing.Any], typing.Tuple[typing.Type[typing.Any], ...]]` for 2nd positional only parameter to call `isinstance` but got `Union[tuple[typing.Type[Union[dict, list]]], typing.Type[dict]]`.",
    "message": " Expected `Union[typing.Type[typing.Any], typing.Tuple[typing.Type[typing.Any], ...]]` for 2nd positional only parameter to call `isinstance` but got `Union[tuple[typing.Type[Union[dict, list]]], typing.Type[dict]]`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 308,
    "warning_line": "    while any(isinstance(v, while_check) for v in dt.values()):",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": true,
        "has_suppression": false,
        "source_code": "    return np.isnan(value) or np.isinf(value)\n\n\ndef merge_dicts(d1, d2):\n    \"\"\"\n    Args:\n        d1 (dict): Dict 1.\n        d2 (dict): Dict 2.\n\n    Returns:\n         dict: A new dict that is d1 and d2 deep merged.\n    \"\"\"\n    merged = copy.deepcopy(d1)\n    deep_update(merged, d2, True, [])\n    return merged\n\n\ndef deep_update(original,\n                new_dict,\n                new_keys_allowed=False,\n                allow_new_subkey_list=None,\n                override_all_if_type_changes=None):\n    \"\"\"Updates original dict with values from new_dict recursively.\n\n    If new key is introduced in new_dict, then if new_keys_allowed is not\n    True, an error will be thrown. Further, for sub-dicts, if the key is\n    in the allow_new_subkey_list, then new subkeys can be introduced.\n\n    Args:\n        original (dict): Dictionary with default values.\n        new_dict (dict): Dictionary with values to be updated\n        new_keys_allowed (bool): Whether new keys are allowed.\n        allow_new_subkey_list (Optional[List[str]]): List of keys that\n            correspond to dict values where new subkeys can be introduced.\n            This is only at the top level.\n        override_all_if_type_changes(Optional[List[str]]): List of top level\n            keys with value=dict, for which we always simply override the\n            entire value (dict), iff the \"type\" key in that value dict changes.\n    \"\"\"\n    allow_new_subkey_list = allow_new_subkey_list or []\n    override_all_if_type_changes = override_all_if_type_changes or []\n\n    for k, value in new_dict.items():\n        if k not in original and not new_keys_allowed:\n            raise Exception(\"Unknown config parameter `{}` \".format(k))\n\n        # Both orginal value and new one are dicts.\n        if isinstance(original.get(k), dict) and isinstance(value, dict):\n            # Check old type vs old one. If different, override entire value.\n            if k in override_all_if_type_changes and \\\n                \"type\" in value and \"type\" in original[k] and \\\n                    value[\"type\"] != original[k][\"type\"]:\n                original[k] = value\n            # Allowed key -> ok to add new subkeys.\n            elif k in allow_new_subkey_list:\n                deep_update(original[k], value, True)\n            # Non-allowed key.\n            else:\n                deep_update(original[k], value, new_keys_allowed)\n        # Original value not a dict OR new value not a dict:\n        # Override entire value.\n        else:\n            original[k] = value\n    return original\n\n\ndef flatten_dict(dt: Dict,\n                 delimiter: str = \"/\",\n                 prevent_delimiter: bool = False,\n                 flatten_list: bool = False):\n    \"\"\"Flatten dict.\n\n    Output and input are of the same dict type.\n    Input dict remains the same after the operation.\n    \"\"\"\n\n    def _raise_delimiter_exception():\n        raise ValueError(\n            f\"Found delimiter `{delimiter}` in key when trying to flatten \"\n            f\"array. Please avoid using the delimiter in your specification.\")\n\n    dt = copy.copy(dt)\n    if prevent_delimiter and any(delimiter in key for key in dt):\n        # Raise if delimiter is any of the keys\n        _raise_delimiter_exception()\n\n    while_check = (dict, list) if flatten_list else dict\n\n    while any(isinstance(v, while_check) for v in dt.values()):\n        remove = []\n        add = {}\n        for key, value in dt.items():\n            if isinstance(value, dict):\n                for subkey, v in value.items():\n                    if prevent_delimiter and delimiter in subkey:\n                        # Raise if delimiter is in any of the subkeys\n                        _raise_delimiter_exception()\n\n                    add[delimiter.join([key, str(subkey)])] = v\n                remove.append(key)\n            elif flatten_list and isinstance(value, list):\n                for i, v in enumerate(value):\n                    if prevent_delimiter and delimiter in subkey:\n                        # Raise if delimiter is in any of the subkeys\n                        _raise_delimiter_exception()\n\n                    add[delimiter.join([key, str(i)])] = v\n                remove.append(key)\n\n        dt.update(add)\n        for k in remove:\n            del dt[k]\n    return dt\n\n\ndef unflatten_dict(dt, delimiter=\"/\"):\n    \"\"\"Unflatten dict. Does not support unflattening lists.\"\"\"\n    dict_type = type(dt)\n    out = dict_type()\n    for key, val in dt.items():\n        path = key.split(delimiter)\n        item = out\n        for k in path[:-1]:\n            item = item.setdefault(k, dict_type())\n            if not isinstance(item, dict_type):\n                raise TypeError(\n                    f\"Cannot unflatten dict due the key '{key}' \"\n                    f\"having a parent key '{k}', which value is not \"\n                    f\"of type {dict_type} (got {type(item)}). \"\n                    \"Change the key names to resolve the conflict.\")\n        item[path[-1]] = val\n    return out\n\n\ndef unflatten_list_dict(dt, delimiter=\"/\"):\n    \"\"\"Unflatten nested dict and list.\n\n    This function now has some limitations:\n    (1) The keys of dt must be str.\n    (2) If unflattened dt (the result) contains list, the index order must be\n        ascending when accessing dt. Otherwise, this function will throw\n        AssertionError.\n    (3) The unflattened dt (the result) shouldn't contain dict with number\n        keys.\n\n    Be careful to use this function. If you want to improve this function,\n    please also improve the unit test. See #14487 for more details.\n\n    Args:\n        dt (dict): Flattened dictionary that is originally nested by multiple\n            list and dict.\n        delimiter (str): Delimiter of keys.\n\n    Example:\n        >>> dt = {\"aaa/0/bb\": 12, \"aaa/1/cc\": 56, \"aaa/1/dd\": 92}\n        >>> unflatten_list_dict(dt)\n        {'aaa': [{'bb': 12}, {'cc': 56, 'dd': 92}]}\n    \"\"\"\n    out_type = list if list(dt)[0].split(delimiter, 1)[0].isdigit() \\\n        else type(dt)\n    out = out_type()\n    for key, val in dt.items():\n        path = key.split(delimiter)\n\n        item = out\n        for i, k in enumerate(path[:-1]):\n            next_type = list if path[i + 1].isdigit() else dict\n            if isinstance(item, dict):\n                item = item.setdefault(k, next_type())\n            elif isinstance(item, list):\n                if int(k) >= len(item):\n                    item.append(next_type())\n                    assert int(k) == len(item) - 1\n                item = item[int(k)]\n\n        if isinstance(item, dict):\n            item[path[-1]] = val\n        elif isinstance(item, list):\n            item.append(val)\n            assert int(path[-1]) == len(item) - 1\n    return out\n\n\ndef unflattened_lookup(flat_key, lookup, delimiter=\"/\", **kwargs):\n    \"\"\"\n    Unflatten `flat_key` and iteratively look up in `lookup`. E.g.\n    `flat_key=\"a/0/b\"` will try to return `lookup[\"a\"][0][\"b\"]`.\n    \"\"\"\n    if flat_key in lookup:\n        return lookup[flat_key]\n    keys = deque(flat_key.split(delimiter))\n    base = lookup\n    while keys:\n        key = keys.popleft()\n        try:\n            if isinstance(base, Mapping):\n                base = base[key]\n            elif isinstance(base, Sequence):\n                base = base[int(key)]\n            else:\n                raise KeyError()\n        except KeyError as e:\n            if \"default\" in kwargs:\n                return kwargs[\"default\"]\n            raise e\n    return base\n\n",
        "source_code_len": 7467,
        "target_code": "    return np.isnan(value) or np.isinf(value)\n\n",
        "target_code_len": 47,
        "diff_format": "@@ -220,207 +222,2 @@\n     return np.isnan(value) or np.isinf(value)\n-\n-\n-def merge_dicts(d1, d2):\n-    \"\"\"\n-    Args:\n-        d1 (dict): Dict 1.\n-        d2 (dict): Dict 2.\n-\n-    Returns:\n-         dict: A new dict that is d1 and d2 deep merged.\n-    \"\"\"\n-    merged = copy.deepcopy(d1)\n-    deep_update(merged, d2, True, [])\n-    return merged\n-\n-\n-def deep_update(original,\n-                new_dict,\n-                new_keys_allowed=False,\n-                allow_new_subkey_list=None,\n-                override_all_if_type_changes=None):\n-    \"\"\"Updates original dict with values from new_dict recursively.\n-\n-    If new key is introduced in new_dict, then if new_keys_allowed is not\n-    True, an error will be thrown. Further, for sub-dicts, if the key is\n-    in the allow_new_subkey_list, then new subkeys can be introduced.\n-\n-    Args:\n-        original (dict): Dictionary with default values.\n-        new_dict (dict): Dictionary with values to be updated\n-        new_keys_allowed (bool): Whether new keys are allowed.\n-        allow_new_subkey_list (Optional[List[str]]): List of keys that\n-            correspond to dict values where new subkeys can be introduced.\n-            This is only at the top level.\n-        override_all_if_type_changes(Optional[List[str]]): List of top level\n-            keys with value=dict, for which we always simply override the\n-            entire value (dict), iff the \"type\" key in that value dict changes.\n-    \"\"\"\n-    allow_new_subkey_list = allow_new_subkey_list or []\n-    override_all_if_type_changes = override_all_if_type_changes or []\n-\n-    for k, value in new_dict.items():\n-        if k not in original and not new_keys_allowed:\n-            raise Exception(\"Unknown config parameter `{}` \".format(k))\n-\n-        # Both orginal value and new one are dicts.\n-        if isinstance(original.get(k), dict) and isinstance(value, dict):\n-            # Check old type vs old one. If different, override entire value.\n-            if k in override_all_if_type_changes and \\\n-                \"type\" in value and \"type\" in original[k] and \\\n-                    value[\"type\"] != original[k][\"type\"]:\n-                original[k] = value\n-            # Allowed key -> ok to add new subkeys.\n-            elif k in allow_new_subkey_list:\n-                deep_update(original[k], value, True)\n-            # Non-allowed key.\n-            else:\n-                deep_update(original[k], value, new_keys_allowed)\n-        # Original value not a dict OR new value not a dict:\n-        # Override entire value.\n-        else:\n-            original[k] = value\n-    return original\n-\n-\n-def flatten_dict(dt: Dict,\n-                 delimiter: str = \"/\",\n-                 prevent_delimiter: bool = False,\n-                 flatten_list: bool = False):\n-    \"\"\"Flatten dict.\n-\n-    Output and input are of the same dict type.\n-    Input dict remains the same after the operation.\n-    \"\"\"\n-\n-    def _raise_delimiter_exception():\n-        raise ValueError(\n-            f\"Found delimiter `{delimiter}` in key when trying to flatten \"\n-            f\"array. Please avoid using the delimiter in your specification.\")\n-\n-    dt = copy.copy(dt)\n-    if prevent_delimiter and any(delimiter in key for key in dt):\n-        # Raise if delimiter is any of the keys\n-        _raise_delimiter_exception()\n-\n-    while_check = (dict, list) if flatten_list else dict\n-\n-    while any(isinstance(v, while_check) for v in dt.values()):\n-        remove = []\n-        add = {}\n-        for key, value in dt.items():\n-            if isinstance(value, dict):\n-                for subkey, v in value.items():\n-                    if prevent_delimiter and delimiter in subkey:\n-                        # Raise if delimiter is in any of the subkeys\n-                        _raise_delimiter_exception()\n-\n-                    add[delimiter.join([key, str(subkey)])] = v\n-                remove.append(key)\n-            elif flatten_list and isinstance(value, list):\n-                for i, v in enumerate(value):\n-                    if prevent_delimiter and delimiter in subkey:\n-                        # Raise if delimiter is in any of the subkeys\n-                        _raise_delimiter_exception()\n-\n-                    add[delimiter.join([key, str(i)])] = v\n-                remove.append(key)\n-\n-        dt.update(add)\n-        for k in remove:\n-            del dt[k]\n-    return dt\n-\n-\n-def unflatten_dict(dt, delimiter=\"/\"):\n-    \"\"\"Unflatten dict. Does not support unflattening lists.\"\"\"\n-    dict_type = type(dt)\n-    out = dict_type()\n-    for key, val in dt.items():\n-        path = key.split(delimiter)\n-        item = out\n-        for k in path[:-1]:\n-            item = item.setdefault(k, dict_type())\n-            if not isinstance(item, dict_type):\n-                raise TypeError(\n-                    f\"Cannot unflatten dict due the key '{key}' \"\n-                    f\"having a parent key '{k}', which value is not \"\n-                    f\"of type {dict_type} (got {type(item)}). \"\n-                    \"Change the key names to resolve the conflict.\")\n-        item[path[-1]] = val\n-    return out\n-\n-\n-def unflatten_list_dict(dt, delimiter=\"/\"):\n-    \"\"\"Unflatten nested dict and list.\n-\n-    This function now has some limitations:\n-    (1) The keys of dt must be str.\n-    (2) If unflattened dt (the result) contains list, the index order must be\n-        ascending when accessing dt. Otherwise, this function will throw\n-        AssertionError.\n-    (3) The unflattened dt (the result) shouldn't contain dict with number\n-        keys.\n-\n-    Be careful to use this function. If you want to improve this function,\n-    please also improve the unit test. See #14487 for more details.\n-\n-    Args:\n-        dt (dict): Flattened dictionary that is originally nested by multiple\n-            list and dict.\n-        delimiter (str): Delimiter of keys.\n-\n-    Example:\n-        >>> dt = {\"aaa/0/bb\": 12, \"aaa/1/cc\": 56, \"aaa/1/dd\": 92}\n-        >>> unflatten_list_dict(dt)\n-        {'aaa': [{'bb': 12}, {'cc': 56, 'dd': 92}]}\n-    \"\"\"\n-    out_type = list if list(dt)[0].split(delimiter, 1)[0].isdigit() \\\n-        else type(dt)\n-    out = out_type()\n-    for key, val in dt.items():\n-        path = key.split(delimiter)\n-\n-        item = out\n-        for i, k in enumerate(path[:-1]):\n-            next_type = list if path[i + 1].isdigit() else dict\n-            if isinstance(item, dict):\n-                item = item.setdefault(k, next_type())\n-            elif isinstance(item, list):\n-                if int(k) >= len(item):\n-                    item.append(next_type())\n-                    assert int(k) == len(item) - 1\n-                item = item[int(k)]\n-\n-        if isinstance(item, dict):\n-            item[path[-1]] = val\n-        elif isinstance(item, list):\n-            item.append(val)\n-            assert int(path[-1]) == len(item) - 1\n-    return out\n-\n-\n-def unflattened_lookup(flat_key, lookup, delimiter=\"/\", **kwargs):\n-    \"\"\"\n-    Unflatten `flat_key` and iteratively look up in `lookup`. E.g.\n-    `flat_key=\"a/0/b\"` will try to return `lookup[\"a\"][0][\"b\"]`.\n-    \"\"\"\n-    if flat_key in lookup:\n-        return lookup[flat_key]\n-    keys = deque(flat_key.split(delimiter))\n-    base = lookup\n-    while keys:\n-        key = keys.popleft()\n-        try:\n-            if isinstance(base, Mapping):\n-                base = base[key]\n-            elif isinstance(base, Sequence):\n-                base = base[int(key)]\n-            else:\n-                raise KeyError()\n-        except KeyError as e:\n-            if \"default\" in kwargs:\n-                return kwargs[\"default\"]\n-            raise e\n-    return base\n \n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent": "    <IND>return np.isnan(value) or np.isinf(value)\n\n",
        "target_code_with_indent_exact_match": true,
        "source_code_with_indent": "    <IND>return np.isnan(value) or np.isinf(value)\n\n\n<DED>def merge_dicts(d1, d2):\n    <IND>\"\"\"\n    Args:\n        d1 (dict): Dict 1.\n        d2 (dict): Dict 2.\n\n    Returns:\n         dict: A new dict that is d1 and d2 deep merged.\n    \"\"\"\n    merged = copy.deepcopy(d1)\n    deep_update(merged, d2, True, [])\n    return merged\n\n\n<DED>def deep_update(original,\n                new_dict,\n                new_keys_allowed=False,\n                allow_new_subkey_list=None,\n                override_all_if_type_changes=None):\n    <IND>\"\"\"Updates original dict with values from new_dict recursively.\n\n    If new key is introduced in new_dict, then if new_keys_allowed is not\n    True, an error will be thrown. Further, for sub-dicts, if the key is\n    in the allow_new_subkey_list, then new subkeys can be introduced.\n\n    Args:\n        original (dict): Dictionary with default values.\n        new_dict (dict): Dictionary with values to be updated\n        new_keys_allowed (bool): Whether new keys are allowed.\n        allow_new_subkey_list (Optional[List[str]]): List of keys that\n            correspond to dict values where new subkeys can be introduced.\n            This is only at the top level.\n        override_all_if_type_changes(Optional[List[str]]): List of top level\n            keys with value=dict, for which we always simply override the\n            entire value (dict), iff the \"type\" key in that value dict changes.\n    \"\"\"\n    allow_new_subkey_list = allow_new_subkey_list or []\n    override_all_if_type_changes = override_all_if_type_changes or []\n\n    for k, value in new_dict.items():\n        <IND>if k not in original and not new_keys_allowed:\n            <IND>raise Exception(\"Unknown config parameter `{}` \".format(k))\n\n        # Both orginal value and new one are dicts.\n        <DED>if isinstance(original.get(k), dict) and isinstance(value, dict):\n            # Check old type vs old one. If different, override entire value.\n            <IND>if k in override_all_if_type_changes and                \"type\" in value and \"type\" in original[k] and                    value[\"type\"] != original[k][\"type\"]:\n                <IND>original[k] = value\n            # Allowed key -> ok to add new subkeys.\n            <DED>elif k in allow_new_subkey_list:\n                <IND>deep_update(original[k], value, True)\n            # Non-allowed key.\n            <DED>else:\n                <IND>deep_update(original[k], value, new_keys_allowed)\n        # Original value not a dict OR new value not a dict:\n        # Override entire value.\n        <DED><DED>else:\n            <IND>original[k] = value\n    <DED><DED>return original\n\n\n<DED>def flatten_dict(dt: Dict,\n                 delimiter: str = \"/\",\n                 prevent_delimiter: bool = False,\n                 flatten_list: bool = False):\n    <IND>\"\"\"Flatten dict.\n\n    Output and input are of the same dict type.\n    Input dict remains the same after the operation.\n    \"\"\"\n\n    def _raise_delimiter_exception():\n        <IND>raise ValueError(\n            f\"Found delimiter `{delimiter}` in key when trying to flatten \"\n            f\"array. Please avoid using the delimiter in your specification.\")\n\n    <DED>dt = copy.copy(dt)\n    if prevent_delimiter and any(delimiter in key for key in dt):\n        # Raise if delimiter is any of the keys\n        <IND>_raise_delimiter_exception()\n\n    <DED>while_check = (dict, list) if flatten_list else dict\n\n    while any(isinstance(v, while_check) for v in dt.values()):\n        <IND>remove = []\n        add = {}\n        for key, value in dt.items():\n            <IND>if isinstance(value, dict):\n                <IND>for subkey, v in value.items():\n                    <IND>if prevent_delimiter and delimiter in subkey:\n                        # Raise if delimiter is in any of the subkeys\n                        <IND>_raise_delimiter_exception()\n\n                    <DED>add[delimiter.join([key, str(subkey)])] = v\n                <DED>remove.append(key)\n            <DED>elif flatten_list and isinstance(value, list):\n                <IND>for i, v in enumerate(value):\n                    <IND>if prevent_delimiter and delimiter in subkey:\n                        # Raise if delimiter is in any of the subkeys\n                        <IND>_raise_delimiter_exception()\n\n                    <DED>add[delimiter.join([key, str(i)])] = v\n                <DED>remove.append(key)\n\n        <DED><DED>dt.update(add)\n        for k in remove:\n            <IND>del dt[k]\n    <DED><DED>return dt\n\n\n<DED>def unflatten_dict(dt, delimiter=\"/\"):\n    <IND>\"\"\"Unflatten dict. Does not support unflattening lists.\"\"\"\n    dict_type = type(dt)\n    out = dict_type()\n    for key, val in dt.items():\n        <IND>path = key.split(delimiter)\n        item = out\n        for k in path[:-1]:\n            <IND>item = item.setdefault(k, dict_type())\n            if not isinstance(item, dict_type):\n                <IND>raise TypeError(\n                    f\"Cannot unflatten dict due the key '{key}' \"\n                    f\"having a parent key '{k}', which value is not \"\n                    f\"of type {dict_type} (got {type(item)}). \"\n                    \"Change the key names to resolve the conflict.\")\n        <DED><DED>item[path[-1]] = val\n    <DED>return out\n\n\n<DED>def unflatten_list_dict(dt, delimiter=\"/\"):\n    <IND>\"\"\"Unflatten nested dict and list.\n\n    This function now has some limitations:\n    (1) The keys of dt must be str.\n    (2) If unflattened dt (the result) contains list, the index order must be\n        ascending when accessing dt. Otherwise, this function will throw\n        AssertionError.\n    (3) The unflattened dt (the result) shouldn't contain dict with number\n        keys.\n\n    Be careful to use this function. If you want to improve this function,\n    please also improve the unit test. See #14487 for more details.\n\n    Args:\n        dt (dict): Flattened dictionary that is originally nested by multiple\n            list and dict.\n        delimiter (str): Delimiter of keys.\n\n    Example:\n        >>> dt = {\"aaa/0/bb\": 12, \"aaa/1/cc\": 56, \"aaa/1/dd\": 92}\n        >>> unflatten_list_dict(dt)\n        {'aaa': [{'bb': 12}, {'cc': 56, 'dd': 92}]}\n    \"\"\"\n    out_type = list if list(dt)[0].split(delimiter, 1)[0].isdigit()        else type(dt)\n    out = out_type()\n    for key, val in dt.items():\n        <IND>path = key.split(delimiter)\n\n        item = out\n        for i, k in enumerate(path[:-1]):\n            <IND>next_type = list if path[i + 1].isdigit() else dict\n            if isinstance(item, dict):\n                <IND>item = item.setdefault(k, next_type())\n            <DED>elif isinstance(item, list):\n                <IND>if int(k) >= len(item):\n                    <IND>item.append(next_type())\n                    assert int(k) == len(item) - 1\n                <DED>item = item[int(k)]\n\n        <DED><DED>if isinstance(item, dict):\n            <IND>item[path[-1]] = val\n        <DED>elif isinstance(item, list):\n            <IND>item.append(val)\n            assert int(path[-1]) == len(item) - 1\n    <DED><DED>return out\n\n\n<DED>def unflattened_lookup(flat_key, lookup, delimiter=\"/\", **kwargs):\n    <IND>\"\"\"\n    Unflatten `flat_key` and iteratively look up in `lookup`. E.g.\n    `flat_key=\"a/0/b\"` will try to return `lookup[\"a\"][0][\"b\"]`.\n    \"\"\"\n    if flat_key in lookup:\n        <IND>return lookup[flat_key]\n    <DED>keys = deque(flat_key.split(delimiter))\n    base = lookup\n    while keys:\n        <IND>key = keys.popleft()\n        try:\n            <IND>if isinstance(base, Mapping):\n                <IND>base = base[key]\n            <DED>elif isinstance(base, Sequence):\n                <IND>base = base[int(key)]\n            <DED>else:\n                <IND>raise KeyError()\n        <DED><DED>except KeyError as e:\n            <IND>if \"default\" in kwargs:\n                <IND>return kwargs[\"default\"]\n            <DED>raise e\n    <DED><DED>return base\n\n"
      }
    ]
  }
]