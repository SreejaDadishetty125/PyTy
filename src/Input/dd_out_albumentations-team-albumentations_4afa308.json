[
  {
    "project": "albumentations-team/albumentations",
    "commit": "4afa308646dd9fa5e7cd37b8dcc38da416a6a5ad",
    "filename": "albumentations/augmentations/transforms.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/albumentations-team-albumentations/albumentations/augmentations/transforms.py",
    "file_hunks_size": 16,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": true,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "albumentations/augmentations/transforms.py:2833:8 Incompatible variable type [9]: unit_size_min is declared to have type `int` but is used as type `None`.",
    "message": " unit_size_min is declared to have type `int` but is used as type `None`.",
    "rule_id": "Incompatible variable type [9]",
    "warning_line_no": 2833,
    "warning_line": "        unit_size_min: int = None,",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": true,
        "has_suppression": false,
        "source_code": "        return [\"image\"]\n\n\nclass GridDropout(DualTransform):\n    \"\"\"GridDropout, drops out rectangular regions of an image and the corresponding mask in a grid fashion.\n\n    Args:\n        ratio (float): the ratio of the mask holes to the unit_size (same for horizontal and vertical directions).\n            Must be between 0 and 1. Default: 0.5.\n        unit_size_min (int): minimum size of the grid unit. Must be between 2 and the image shorter edge.\n            If 'None', holes_number_x and holes_number_y are used to setup the grid. Default: `None`.\n        unit_size_max (int): maximum size of the grid unit. Must be between 2 and the image shorter edge.\n            If 'None', holes_number_x and holes_number_y are used to setup the grid. Default: `None`.\n        holes_number_x (int): the number of grid units in x direction. Must be between 1 and image width//2.\n            If 'None', grid unit width is set as image_width//10. Default: `None`.\n        holes_number_y (int): the number of grid units in y direction. Must be between 1 and image height//2.\n            If `None`, grid unit height is set equal to the grid unit width or image height, whatever is smaller.\n        shift_x (int): offsets of the grid start in x direction from (0,0) coordinate.\n            Clipped between 0 and grid unit_width - hole_width. Default: 0.\n        shift_y (int): offsets of the grid start in y direction from (0,0) coordinate.\n            Clipped between 0 and grid unit height - hole_height. Default: 0.\n        random_offset (boolean): weather to offset the grid randomly between 0 and grid unit size - hole size\n            If 'True', entered shift_x, shift_y are ignored and set randomly. Default: `False`.\n        fill_value (int): value for the dropped pixels. Default = 0\n        mask_fill_value (int): value for the dropped pixels in mask.\n            If `None`, transformation is not applied to the mask. Default: `None`.\n\n    Targets:\n        image, mask\n\n    Image types:\n        uint8, float32\n\n    References:\n        https://arxiv.org/abs/2001.04086\n\n    \"\"\"\n\n    def __init__(\n        self,\n        ratio: float = 0.5,\n        unit_size_min: int = None,\n        unit_size_max: int = None,\n        holes_number_x: int = None,\n        holes_number_y: int = None,\n        shift_x: int = 0,\n        shift_y: int = 0,\n        random_offset: bool = False,\n        fill_value: int = 0,\n        mask_fill_value: int = None,\n        always_apply: bool = False,\n        p: float = 0.5,\n    ):\n        super(GridDropout, self).__init__(always_apply, p)\n        self.ratio = ratio\n        self.unit_size_min = unit_size_min\n        self.unit_size_max = unit_size_max\n        self.holes_number_x = holes_number_x\n        self.holes_number_y = holes_number_y\n        self.shift_x = shift_x\n        self.shift_y = shift_y\n        self.random_offset = random_offset\n        self.fill_value = fill_value\n        self.mask_fill_value = mask_fill_value\n        if not 0 < self.ratio <= 1:\n            raise ValueError(\"ratio must be between 0 and 1.\")\n\n    def apply(self, image, holes=(), **params):\n        return F.cutout(image, holes, self.fill_value)\n\n    def apply_to_mask(self, image, holes=(), **params):\n        if self.mask_fill_value is None:\n            return image\n\n        return F.cutout(image, holes, self.mask_fill_value)\n\n    def get_params_dependent_on_targets(self, params):\n        img = params[\"image\"]\n        height, width = img.shape[:2]\n        # set grid using unit size limits\n        if self.unit_size_min and self.unit_size_max:\n            if not 2 <= self.unit_size_min <= self.unit_size_max:\n                raise ValueError(\"Max unit size should be >= min size, both at least 2 pixels.\")\n            if self.unit_size_max > min(height, width):\n                raise ValueError(\"Grid size limits must be within the shortest image edge.\")\n            unit_width = random.randint(self.unit_size_min, self.unit_size_max + 1)\n            unit_height = unit_width\n        else:\n            # set grid using holes numbers\n            if self.holes_number_x is None:\n                unit_width = max(2, width // 10)\n            else:\n                if not 1 <= self.holes_number_x <= width // 2:\n                    raise ValueError(\"The hole_number_x must be between 1 and image width//2.\")\n                unit_width = width // self.holes_number_x\n            if self.holes_number_y is None:\n                unit_height = max(min(unit_width, height), 2)\n            else:\n                if not 1 <= self.holes_number_y <= height // 2:\n                    raise ValueError(\"The hole_number_y must be between 1 and image height//2.\")\n                unit_height = height // self.holes_number_y\n\n        hole_width = int(unit_width * self.ratio)\n        hole_height = int(unit_height * self.ratio)\n        # min 1 pixel and max unit length - 1\n        hole_width = min(max(hole_width, 1), unit_width - 1)\n        hole_height = min(max(hole_height, 1), unit_height - 1)\n        # set offset of the grid\n        if self.shift_x is None:\n            shift_x = 0\n        else:\n            shift_x = min(max(0, self.shift_x), unit_width - hole_width)\n        if self.shift_y is None:\n            shift_y = 0\n        else:\n            shift_y = min(max(0, self.shift_y), unit_height - hole_height)\n        if self.random_offset:\n            shift_x = random.randint(0, unit_width - hole_width)\n            shift_y = random.randint(0, unit_height - hole_height)\n        holes = []\n        for i in range(width // unit_width + 1):\n            for j in range(height // unit_height + 1):\n                x1 = min(shift_x + unit_width * i, width)\n                y1 = min(shift_y + unit_height * j, height)\n                x2 = min(x1 + hole_width, width)\n                y2 = min(y1 + hole_height, height)\n                holes.append((x1, y1, x2, y2))\n\n        return {\"holes\": holes}\n\n    @property\n    def targets_as_params(self):\n        return [\"image\"]\n\n    def get_transform_init_args_names(self):\n        return (\n            \"ratio\",\n            \"unit_size_min\",\n            \"unit_size_max\",\n            \"holes_number_x\",\n            \"holes_number_y\",\n            \"shift_x\",\n            \"shift_y\",\n            \"mask_fill_value\",\n            \"random_offset\",\n        )\n\n",
        "source_code_len": 6293,
        "target_code": "        return [\"image\"]\n\n",
        "target_code_len": 26,
        "diff_format": "@@ -2792,147 +2407,2 @@\n         return [\"image\"]\n-\n-\n-class GridDropout(DualTransform):\n-    \"\"\"GridDropout, drops out rectangular regions of an image and the corresponding mask in a grid fashion.\n-\n-    Args:\n-        ratio (float): the ratio of the mask holes to the unit_size (same for horizontal and vertical directions).\n-            Must be between 0 and 1. Default: 0.5.\n-        unit_size_min (int): minimum size of the grid unit. Must be between 2 and the image shorter edge.\n-            If 'None', holes_number_x and holes_number_y are used to setup the grid. Default: `None`.\n-        unit_size_max (int): maximum size of the grid unit. Must be between 2 and the image shorter edge.\n-            If 'None', holes_number_x and holes_number_y are used to setup the grid. Default: `None`.\n-        holes_number_x (int): the number of grid units in x direction. Must be between 1 and image width//2.\n-            If 'None', grid unit width is set as image_width//10. Default: `None`.\n-        holes_number_y (int): the number of grid units in y direction. Must be between 1 and image height//2.\n-            If `None`, grid unit height is set equal to the grid unit width or image height, whatever is smaller.\n-        shift_x (int): offsets of the grid start in x direction from (0,0) coordinate.\n-            Clipped between 0 and grid unit_width - hole_width. Default: 0.\n-        shift_y (int): offsets of the grid start in y direction from (0,0) coordinate.\n-            Clipped between 0 and grid unit height - hole_height. Default: 0.\n-        random_offset (boolean): weather to offset the grid randomly between 0 and grid unit size - hole size\n-            If 'True', entered shift_x, shift_y are ignored and set randomly. Default: `False`.\n-        fill_value (int): value for the dropped pixels. Default = 0\n-        mask_fill_value (int): value for the dropped pixels in mask.\n-            If `None`, transformation is not applied to the mask. Default: `None`.\n-\n-    Targets:\n-        image, mask\n-\n-    Image types:\n-        uint8, float32\n-\n-    References:\n-        https://arxiv.org/abs/2001.04086\n-\n-    \"\"\"\n-\n-    def __init__(\n-        self,\n-        ratio: float = 0.5,\n-        unit_size_min: int = None,\n-        unit_size_max: int = None,\n-        holes_number_x: int = None,\n-        holes_number_y: int = None,\n-        shift_x: int = 0,\n-        shift_y: int = 0,\n-        random_offset: bool = False,\n-        fill_value: int = 0,\n-        mask_fill_value: int = None,\n-        always_apply: bool = False,\n-        p: float = 0.5,\n-    ):\n-        super(GridDropout, self).__init__(always_apply, p)\n-        self.ratio = ratio\n-        self.unit_size_min = unit_size_min\n-        self.unit_size_max = unit_size_max\n-        self.holes_number_x = holes_number_x\n-        self.holes_number_y = holes_number_y\n-        self.shift_x = shift_x\n-        self.shift_y = shift_y\n-        self.random_offset = random_offset\n-        self.fill_value = fill_value\n-        self.mask_fill_value = mask_fill_value\n-        if not 0 < self.ratio <= 1:\n-            raise ValueError(\"ratio must be between 0 and 1.\")\n-\n-    def apply(self, image, holes=(), **params):\n-        return F.cutout(image, holes, self.fill_value)\n-\n-    def apply_to_mask(self, image, holes=(), **params):\n-        if self.mask_fill_value is None:\n-            return image\n-\n-        return F.cutout(image, holes, self.mask_fill_value)\n-\n-    def get_params_dependent_on_targets(self, params):\n-        img = params[\"image\"]\n-        height, width = img.shape[:2]\n-        # set grid using unit size limits\n-        if self.unit_size_min and self.unit_size_max:\n-            if not 2 <= self.unit_size_min <= self.unit_size_max:\n-                raise ValueError(\"Max unit size should be >= min size, both at least 2 pixels.\")\n-            if self.unit_size_max > min(height, width):\n-                raise ValueError(\"Grid size limits must be within the shortest image edge.\")\n-            unit_width = random.randint(self.unit_size_min, self.unit_size_max + 1)\n-            unit_height = unit_width\n-        else:\n-            # set grid using holes numbers\n-            if self.holes_number_x is None:\n-                unit_width = max(2, width // 10)\n-            else:\n-                if not 1 <= self.holes_number_x <= width // 2:\n-                    raise ValueError(\"The hole_number_x must be between 1 and image width//2.\")\n-                unit_width = width // self.holes_number_x\n-            if self.holes_number_y is None:\n-                unit_height = max(min(unit_width, height), 2)\n-            else:\n-                if not 1 <= self.holes_number_y <= height // 2:\n-                    raise ValueError(\"The hole_number_y must be between 1 and image height//2.\")\n-                unit_height = height // self.holes_number_y\n-\n-        hole_width = int(unit_width * self.ratio)\n-        hole_height = int(unit_height * self.ratio)\n-        # min 1 pixel and max unit length - 1\n-        hole_width = min(max(hole_width, 1), unit_width - 1)\n-        hole_height = min(max(hole_height, 1), unit_height - 1)\n-        # set offset of the grid\n-        if self.shift_x is None:\n-            shift_x = 0\n-        else:\n-            shift_x = min(max(0, self.shift_x), unit_width - hole_width)\n-        if self.shift_y is None:\n-            shift_y = 0\n-        else:\n-            shift_y = min(max(0, self.shift_y), unit_height - hole_height)\n-        if self.random_offset:\n-            shift_x = random.randint(0, unit_width - hole_width)\n-            shift_y = random.randint(0, unit_height - hole_height)\n-        holes = []\n-        for i in range(width // unit_width + 1):\n-            for j in range(height // unit_height + 1):\n-                x1 = min(shift_x + unit_width * i, width)\n-                y1 = min(shift_y + unit_height * j, height)\n-                x2 = min(x1 + hole_width, width)\n-                y2 = min(y1 + hole_height, height)\n-                holes.append((x1, y1, x2, y2))\n-\n-        return {\"holes\": holes}\n-\n-    @property\n-    def targets_as_params(self):\n-        return [\"image\"]\n-\n-    def get_transform_init_args_names(self):\n-        return (\n-            \"ratio\",\n-            \"unit_size_min\",\n-            \"unit_size_max\",\n-            \"holes_number_x\",\n-            \"holes_number_y\",\n-            \"shift_x\",\n-            \"shift_y\",\n-            \"mask_fill_value\",\n-            \"random_offset\",\n-        )\n \n",
        "source_code_with_indent": "        <IND>return [\"image\"]\n\n\n<DED><DED>class GridDropout(DualTransform):\n    <IND>\"\"\"GridDropout, drops out rectangular regions of an image and the corresponding mask in a grid fashion.\n\n    Args:\n        ratio (float): the ratio of the mask holes to the unit_size (same for horizontal and vertical directions).\n            Must be between 0 and 1. Default: 0.5.\n        unit_size_min (int): minimum size of the grid unit. Must be between 2 and the image shorter edge.\n            If 'None', holes_number_x and holes_number_y are used to setup the grid. Default: `None`.\n        unit_size_max (int): maximum size of the grid unit. Must be between 2 and the image shorter edge.\n            If 'None', holes_number_x and holes_number_y are used to setup the grid. Default: `None`.\n        holes_number_x (int): the number of grid units in x direction. Must be between 1 and image width//2.\n            If 'None', grid unit width is set as image_width//10. Default: `None`.\n        holes_number_y (int): the number of grid units in y direction. Must be between 1 and image height//2.\n            If `None`, grid unit height is set equal to the grid unit width or image height, whatever is smaller.\n        shift_x (int): offsets of the grid start in x direction from (0,0) coordinate.\n            Clipped between 0 and grid unit_width - hole_width. Default: 0.\n        shift_y (int): offsets of the grid start in y direction from (0,0) coordinate.\n            Clipped between 0 and grid unit height - hole_height. Default: 0.\n        random_offset (boolean): weather to offset the grid randomly between 0 and grid unit size - hole size\n            If 'True', entered shift_x, shift_y are ignored and set randomly. Default: `False`.\n        fill_value (int): value for the dropped pixels. Default = 0\n        mask_fill_value (int): value for the dropped pixels in mask.\n            If `None`, transformation is not applied to the mask. Default: `None`.\n\n    Targets:\n        image, mask\n\n    Image types:\n        uint8, float32\n\n    References:\n        https://arxiv.org/abs/2001.04086\n\n    \"\"\"\n\n    def __init__(\n        self,\n        ratio: float = 0.5,\n        unit_size_min: int = None,\n        unit_size_max: int = None,\n        holes_number_x: int = None,\n        holes_number_y: int = None,\n        shift_x: int = 0,\n        shift_y: int = 0,\n        random_offset: bool = False,\n        fill_value: int = 0,\n        mask_fill_value: int = None,\n        always_apply: bool = False,\n        p: float = 0.5,\n    ):\n        <IND>super(GridDropout, self).__init__(always_apply, p)\n        self.ratio = ratio\n        self.unit_size_min = unit_size_min\n        self.unit_size_max = unit_size_max\n        self.holes_number_x = holes_number_x\n        self.holes_number_y = holes_number_y\n        self.shift_x = shift_x\n        self.shift_y = shift_y\n        self.random_offset = random_offset\n        self.fill_value = fill_value\n        self.mask_fill_value = mask_fill_value\n        if not 0 < self.ratio <= 1:\n            <IND>raise ValueError(\"ratio must be between 0 and 1.\")\n\n    <DED><DED>def apply(self, image, holes=(), **params):\n        <IND>return F.cutout(image, holes, self.fill_value)\n\n    <DED>def apply_to_mask(self, image, holes=(), **params):\n        <IND>if self.mask_fill_value is None:\n            <IND>return image\n\n        <DED>return F.cutout(image, holes, self.mask_fill_value)\n\n    <DED>def get_params_dependent_on_targets(self, params):\n        <IND>img = params[\"image\"]\n        height, width = img.shape[:2]\n        # set grid using unit size limits\n        if self.unit_size_min and self.unit_size_max:\n            <IND>if not 2 <= self.unit_size_min <= self.unit_size_max:\n                <IND>raise ValueError(\"Max unit size should be >= min size, both at least 2 pixels.\")\n            <DED>if self.unit_size_max > min(height, width):\n                <IND>raise ValueError(\"Grid size limits must be within the shortest image edge.\")\n            <DED>unit_width = random.randint(self.unit_size_min, self.unit_size_max + 1)\n            unit_height = unit_width\n        <DED>else:\n            # set grid using holes numbers\n            <IND>if self.holes_number_x is None:\n                <IND>unit_width = max(2, width // 10)\n            <DED>else:\n                <IND>if not 1 <= self.holes_number_x <= width // 2:\n                    <IND>raise ValueError(\"The hole_number_x must be between 1 and image width//2.\")\n                <DED>unit_width = width // self.holes_number_x\n            <DED>if self.holes_number_y is None:\n                <IND>unit_height = max(min(unit_width, height), 2)\n            <DED>else:\n                <IND>if not 1 <= self.holes_number_y <= height // 2:\n                    <IND>raise ValueError(\"The hole_number_y must be between 1 and image height//2.\")\n                <DED>unit_height = height // self.holes_number_y\n\n        <DED><DED>hole_width = int(unit_width * self.ratio)\n        hole_height = int(unit_height * self.ratio)\n        # min 1 pixel and max unit length - 1\n        hole_width = min(max(hole_width, 1), unit_width - 1)\n        hole_height = min(max(hole_height, 1), unit_height - 1)\n        # set offset of the grid\n        if self.shift_x is None:\n            <IND>shift_x = 0\n        <DED>else:\n            <IND>shift_x = min(max(0, self.shift_x), unit_width - hole_width)\n        <DED>if self.shift_y is None:\n            <IND>shift_y = 0\n        <DED>else:\n            <IND>shift_y = min(max(0, self.shift_y), unit_height - hole_height)\n        <DED>if self.random_offset:\n            <IND>shift_x = random.randint(0, unit_width - hole_width)\n            shift_y = random.randint(0, unit_height - hole_height)\n        <DED>holes = []\n        for i in range(width // unit_width + 1):\n            <IND>for j in range(height // unit_height + 1):\n                <IND>x1 = min(shift_x + unit_width * i, width)\n                y1 = min(shift_y + unit_height * j, height)\n                x2 = min(x1 + hole_width, width)\n                y2 = min(y1 + hole_height, height)\n                holes.append((x1, y1, x2, y2))\n\n        <DED><DED>return {\"holes\": holes}\n\n    <DED>@property\n    def targets_as_params(self):\n        <IND>return [\"image\"]\n\n    <DED>def get_transform_init_args_names(self):\n        <IND>return (\n            \"ratio\",\n            \"unit_size_min\",\n            \"unit_size_max\",\n            \"holes_number_x\",\n            \"holes_number_y\",\n            \"shift_x\",\n            \"shift_y\",\n            \"mask_fill_value\",\n            \"random_offset\",\n        )\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "        <IND>return [\"image\"]\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "albumentations-team/albumentations",
    "commit": "4afa308646dd9fa5e7cd37b8dcc38da416a6a5ad",
    "filename": "albumentations/augmentations/transforms.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/albumentations-team-albumentations/albumentations/augmentations/transforms.py",
    "file_hunks_size": 16,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": true,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "albumentations/augmentations/transforms.py:2834:8 Incompatible variable type [9]: unit_size_max is declared to have type `int` but is used as type `None`.",
    "message": " unit_size_max is declared to have type `int` but is used as type `None`.",
    "rule_id": "Incompatible variable type [9]",
    "warning_line_no": 2834,
    "warning_line": "        unit_size_max: int = None,",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": true,
        "has_suppression": false,
        "source_code": "        return [\"image\"]\n\n\nclass GridDropout(DualTransform):\n    \"\"\"GridDropout, drops out rectangular regions of an image and the corresponding mask in a grid fashion.\n\n    Args:\n        ratio (float): the ratio of the mask holes to the unit_size (same for horizontal and vertical directions).\n            Must be between 0 and 1. Default: 0.5.\n        unit_size_min (int): minimum size of the grid unit. Must be between 2 and the image shorter edge.\n            If 'None', holes_number_x and holes_number_y are used to setup the grid. Default: `None`.\n        unit_size_max (int): maximum size of the grid unit. Must be between 2 and the image shorter edge.\n            If 'None', holes_number_x and holes_number_y are used to setup the grid. Default: `None`.\n        holes_number_x (int): the number of grid units in x direction. Must be between 1 and image width//2.\n            If 'None', grid unit width is set as image_width//10. Default: `None`.\n        holes_number_y (int): the number of grid units in y direction. Must be between 1 and image height//2.\n            If `None`, grid unit height is set equal to the grid unit width or image height, whatever is smaller.\n        shift_x (int): offsets of the grid start in x direction from (0,0) coordinate.\n            Clipped between 0 and grid unit_width - hole_width. Default: 0.\n        shift_y (int): offsets of the grid start in y direction from (0,0) coordinate.\n            Clipped between 0 and grid unit height - hole_height. Default: 0.\n        random_offset (boolean): weather to offset the grid randomly between 0 and grid unit size - hole size\n            If 'True', entered shift_x, shift_y are ignored and set randomly. Default: `False`.\n        fill_value (int): value for the dropped pixels. Default = 0\n        mask_fill_value (int): value for the dropped pixels in mask.\n            If `None`, transformation is not applied to the mask. Default: `None`.\n\n    Targets:\n        image, mask\n\n    Image types:\n        uint8, float32\n\n    References:\n        https://arxiv.org/abs/2001.04086\n\n    \"\"\"\n\n    def __init__(\n        self,\n        ratio: float = 0.5,\n        unit_size_min: int = None,\n        unit_size_max: int = None,\n        holes_number_x: int = None,\n        holes_number_y: int = None,\n        shift_x: int = 0,\n        shift_y: int = 0,\n        random_offset: bool = False,\n        fill_value: int = 0,\n        mask_fill_value: int = None,\n        always_apply: bool = False,\n        p: float = 0.5,\n    ):\n        super(GridDropout, self).__init__(always_apply, p)\n        self.ratio = ratio\n        self.unit_size_min = unit_size_min\n        self.unit_size_max = unit_size_max\n        self.holes_number_x = holes_number_x\n        self.holes_number_y = holes_number_y\n        self.shift_x = shift_x\n        self.shift_y = shift_y\n        self.random_offset = random_offset\n        self.fill_value = fill_value\n        self.mask_fill_value = mask_fill_value\n        if not 0 < self.ratio <= 1:\n            raise ValueError(\"ratio must be between 0 and 1.\")\n\n    def apply(self, image, holes=(), **params):\n        return F.cutout(image, holes, self.fill_value)\n\n    def apply_to_mask(self, image, holes=(), **params):\n        if self.mask_fill_value is None:\n            return image\n\n        return F.cutout(image, holes, self.mask_fill_value)\n\n    def get_params_dependent_on_targets(self, params):\n        img = params[\"image\"]\n        height, width = img.shape[:2]\n        # set grid using unit size limits\n        if self.unit_size_min and self.unit_size_max:\n            if not 2 <= self.unit_size_min <= self.unit_size_max:\n                raise ValueError(\"Max unit size should be >= min size, both at least 2 pixels.\")\n            if self.unit_size_max > min(height, width):\n                raise ValueError(\"Grid size limits must be within the shortest image edge.\")\n            unit_width = random.randint(self.unit_size_min, self.unit_size_max + 1)\n            unit_height = unit_width\n        else:\n            # set grid using holes numbers\n            if self.holes_number_x is None:\n                unit_width = max(2, width // 10)\n            else:\n                if not 1 <= self.holes_number_x <= width // 2:\n                    raise ValueError(\"The hole_number_x must be between 1 and image width//2.\")\n                unit_width = width // self.holes_number_x\n            if self.holes_number_y is None:\n                unit_height = max(min(unit_width, height), 2)\n            else:\n                if not 1 <= self.holes_number_y <= height // 2:\n                    raise ValueError(\"The hole_number_y must be between 1 and image height//2.\")\n                unit_height = height // self.holes_number_y\n\n        hole_width = int(unit_width * self.ratio)\n        hole_height = int(unit_height * self.ratio)\n        # min 1 pixel and max unit length - 1\n        hole_width = min(max(hole_width, 1), unit_width - 1)\n        hole_height = min(max(hole_height, 1), unit_height - 1)\n        # set offset of the grid\n        if self.shift_x is None:\n            shift_x = 0\n        else:\n            shift_x = min(max(0, self.shift_x), unit_width - hole_width)\n        if self.shift_y is None:\n            shift_y = 0\n        else:\n            shift_y = min(max(0, self.shift_y), unit_height - hole_height)\n        if self.random_offset:\n            shift_x = random.randint(0, unit_width - hole_width)\n            shift_y = random.randint(0, unit_height - hole_height)\n        holes = []\n        for i in range(width // unit_width + 1):\n            for j in range(height // unit_height + 1):\n                x1 = min(shift_x + unit_width * i, width)\n                y1 = min(shift_y + unit_height * j, height)\n                x2 = min(x1 + hole_width, width)\n                y2 = min(y1 + hole_height, height)\n                holes.append((x1, y1, x2, y2))\n\n        return {\"holes\": holes}\n\n    @property\n    def targets_as_params(self):\n        return [\"image\"]\n\n    def get_transform_init_args_names(self):\n        return (\n            \"ratio\",\n            \"unit_size_min\",\n            \"unit_size_max\",\n            \"holes_number_x\",\n            \"holes_number_y\",\n            \"shift_x\",\n            \"shift_y\",\n            \"mask_fill_value\",\n            \"random_offset\",\n        )\n\n",
        "source_code_len": 6293,
        "target_code": "        return [\"image\"]\n\n",
        "target_code_len": 26,
        "diff_format": "@@ -2792,147 +2407,2 @@\n         return [\"image\"]\n-\n-\n-class GridDropout(DualTransform):\n-    \"\"\"GridDropout, drops out rectangular regions of an image and the corresponding mask in a grid fashion.\n-\n-    Args:\n-        ratio (float): the ratio of the mask holes to the unit_size (same for horizontal and vertical directions).\n-            Must be between 0 and 1. Default: 0.5.\n-        unit_size_min (int): minimum size of the grid unit. Must be between 2 and the image shorter edge.\n-            If 'None', holes_number_x and holes_number_y are used to setup the grid. Default: `None`.\n-        unit_size_max (int): maximum size of the grid unit. Must be between 2 and the image shorter edge.\n-            If 'None', holes_number_x and holes_number_y are used to setup the grid. Default: `None`.\n-        holes_number_x (int): the number of grid units in x direction. Must be between 1 and image width//2.\n-            If 'None', grid unit width is set as image_width//10. Default: `None`.\n-        holes_number_y (int): the number of grid units in y direction. Must be between 1 and image height//2.\n-            If `None`, grid unit height is set equal to the grid unit width or image height, whatever is smaller.\n-        shift_x (int): offsets of the grid start in x direction from (0,0) coordinate.\n-            Clipped between 0 and grid unit_width - hole_width. Default: 0.\n-        shift_y (int): offsets of the grid start in y direction from (0,0) coordinate.\n-            Clipped between 0 and grid unit height - hole_height. Default: 0.\n-        random_offset (boolean): weather to offset the grid randomly between 0 and grid unit size - hole size\n-            If 'True', entered shift_x, shift_y are ignored and set randomly. Default: `False`.\n-        fill_value (int): value for the dropped pixels. Default = 0\n-        mask_fill_value (int): value for the dropped pixels in mask.\n-            If `None`, transformation is not applied to the mask. Default: `None`.\n-\n-    Targets:\n-        image, mask\n-\n-    Image types:\n-        uint8, float32\n-\n-    References:\n-        https://arxiv.org/abs/2001.04086\n-\n-    \"\"\"\n-\n-    def __init__(\n-        self,\n-        ratio: float = 0.5,\n-        unit_size_min: int = None,\n-        unit_size_max: int = None,\n-        holes_number_x: int = None,\n-        holes_number_y: int = None,\n-        shift_x: int = 0,\n-        shift_y: int = 0,\n-        random_offset: bool = False,\n-        fill_value: int = 0,\n-        mask_fill_value: int = None,\n-        always_apply: bool = False,\n-        p: float = 0.5,\n-    ):\n-        super(GridDropout, self).__init__(always_apply, p)\n-        self.ratio = ratio\n-        self.unit_size_min = unit_size_min\n-        self.unit_size_max = unit_size_max\n-        self.holes_number_x = holes_number_x\n-        self.holes_number_y = holes_number_y\n-        self.shift_x = shift_x\n-        self.shift_y = shift_y\n-        self.random_offset = random_offset\n-        self.fill_value = fill_value\n-        self.mask_fill_value = mask_fill_value\n-        if not 0 < self.ratio <= 1:\n-            raise ValueError(\"ratio must be between 0 and 1.\")\n-\n-    def apply(self, image, holes=(), **params):\n-        return F.cutout(image, holes, self.fill_value)\n-\n-    def apply_to_mask(self, image, holes=(), **params):\n-        if self.mask_fill_value is None:\n-            return image\n-\n-        return F.cutout(image, holes, self.mask_fill_value)\n-\n-    def get_params_dependent_on_targets(self, params):\n-        img = params[\"image\"]\n-        height, width = img.shape[:2]\n-        # set grid using unit size limits\n-        if self.unit_size_min and self.unit_size_max:\n-            if not 2 <= self.unit_size_min <= self.unit_size_max:\n-                raise ValueError(\"Max unit size should be >= min size, both at least 2 pixels.\")\n-            if self.unit_size_max > min(height, width):\n-                raise ValueError(\"Grid size limits must be within the shortest image edge.\")\n-            unit_width = random.randint(self.unit_size_min, self.unit_size_max + 1)\n-            unit_height = unit_width\n-        else:\n-            # set grid using holes numbers\n-            if self.holes_number_x is None:\n-                unit_width = max(2, width // 10)\n-            else:\n-                if not 1 <= self.holes_number_x <= width // 2:\n-                    raise ValueError(\"The hole_number_x must be between 1 and image width//2.\")\n-                unit_width = width // self.holes_number_x\n-            if self.holes_number_y is None:\n-                unit_height = max(min(unit_width, height), 2)\n-            else:\n-                if not 1 <= self.holes_number_y <= height // 2:\n-                    raise ValueError(\"The hole_number_y must be between 1 and image height//2.\")\n-                unit_height = height // self.holes_number_y\n-\n-        hole_width = int(unit_width * self.ratio)\n-        hole_height = int(unit_height * self.ratio)\n-        # min 1 pixel and max unit length - 1\n-        hole_width = min(max(hole_width, 1), unit_width - 1)\n-        hole_height = min(max(hole_height, 1), unit_height - 1)\n-        # set offset of the grid\n-        if self.shift_x is None:\n-            shift_x = 0\n-        else:\n-            shift_x = min(max(0, self.shift_x), unit_width - hole_width)\n-        if self.shift_y is None:\n-            shift_y = 0\n-        else:\n-            shift_y = min(max(0, self.shift_y), unit_height - hole_height)\n-        if self.random_offset:\n-            shift_x = random.randint(0, unit_width - hole_width)\n-            shift_y = random.randint(0, unit_height - hole_height)\n-        holes = []\n-        for i in range(width // unit_width + 1):\n-            for j in range(height // unit_height + 1):\n-                x1 = min(shift_x + unit_width * i, width)\n-                y1 = min(shift_y + unit_height * j, height)\n-                x2 = min(x1 + hole_width, width)\n-                y2 = min(y1 + hole_height, height)\n-                holes.append((x1, y1, x2, y2))\n-\n-        return {\"holes\": holes}\n-\n-    @property\n-    def targets_as_params(self):\n-        return [\"image\"]\n-\n-    def get_transform_init_args_names(self):\n-        return (\n-            \"ratio\",\n-            \"unit_size_min\",\n-            \"unit_size_max\",\n-            \"holes_number_x\",\n-            \"holes_number_y\",\n-            \"shift_x\",\n-            \"shift_y\",\n-            \"mask_fill_value\",\n-            \"random_offset\",\n-        )\n \n",
        "source_code_with_indent": "        <IND>return [\"image\"]\n\n\n<DED><DED>class GridDropout(DualTransform):\n    <IND>\"\"\"GridDropout, drops out rectangular regions of an image and the corresponding mask in a grid fashion.\n\n    Args:\n        ratio (float): the ratio of the mask holes to the unit_size (same for horizontal and vertical directions).\n            Must be between 0 and 1. Default: 0.5.\n        unit_size_min (int): minimum size of the grid unit. Must be between 2 and the image shorter edge.\n            If 'None', holes_number_x and holes_number_y are used to setup the grid. Default: `None`.\n        unit_size_max (int): maximum size of the grid unit. Must be between 2 and the image shorter edge.\n            If 'None', holes_number_x and holes_number_y are used to setup the grid. Default: `None`.\n        holes_number_x (int): the number of grid units in x direction. Must be between 1 and image width//2.\n            If 'None', grid unit width is set as image_width//10. Default: `None`.\n        holes_number_y (int): the number of grid units in y direction. Must be between 1 and image height//2.\n            If `None`, grid unit height is set equal to the grid unit width or image height, whatever is smaller.\n        shift_x (int): offsets of the grid start in x direction from (0,0) coordinate.\n            Clipped between 0 and grid unit_width - hole_width. Default: 0.\n        shift_y (int): offsets of the grid start in y direction from (0,0) coordinate.\n            Clipped between 0 and grid unit height - hole_height. Default: 0.\n        random_offset (boolean): weather to offset the grid randomly between 0 and grid unit size - hole size\n            If 'True', entered shift_x, shift_y are ignored and set randomly. Default: `False`.\n        fill_value (int): value for the dropped pixels. Default = 0\n        mask_fill_value (int): value for the dropped pixels in mask.\n            If `None`, transformation is not applied to the mask. Default: `None`.\n\n    Targets:\n        image, mask\n\n    Image types:\n        uint8, float32\n\n    References:\n        https://arxiv.org/abs/2001.04086\n\n    \"\"\"\n\n    def __init__(\n        self,\n        ratio: float = 0.5,\n        unit_size_min: int = None,\n        unit_size_max: int = None,\n        holes_number_x: int = None,\n        holes_number_y: int = None,\n        shift_x: int = 0,\n        shift_y: int = 0,\n        random_offset: bool = False,\n        fill_value: int = 0,\n        mask_fill_value: int = None,\n        always_apply: bool = False,\n        p: float = 0.5,\n    ):\n        <IND>super(GridDropout, self).__init__(always_apply, p)\n        self.ratio = ratio\n        self.unit_size_min = unit_size_min\n        self.unit_size_max = unit_size_max\n        self.holes_number_x = holes_number_x\n        self.holes_number_y = holes_number_y\n        self.shift_x = shift_x\n        self.shift_y = shift_y\n        self.random_offset = random_offset\n        self.fill_value = fill_value\n        self.mask_fill_value = mask_fill_value\n        if not 0 < self.ratio <= 1:\n            <IND>raise ValueError(\"ratio must be between 0 and 1.\")\n\n    <DED><DED>def apply(self, image, holes=(), **params):\n        <IND>return F.cutout(image, holes, self.fill_value)\n\n    <DED>def apply_to_mask(self, image, holes=(), **params):\n        <IND>if self.mask_fill_value is None:\n            <IND>return image\n\n        <DED>return F.cutout(image, holes, self.mask_fill_value)\n\n    <DED>def get_params_dependent_on_targets(self, params):\n        <IND>img = params[\"image\"]\n        height, width = img.shape[:2]\n        # set grid using unit size limits\n        if self.unit_size_min and self.unit_size_max:\n            <IND>if not 2 <= self.unit_size_min <= self.unit_size_max:\n                <IND>raise ValueError(\"Max unit size should be >= min size, both at least 2 pixels.\")\n            <DED>if self.unit_size_max > min(height, width):\n                <IND>raise ValueError(\"Grid size limits must be within the shortest image edge.\")\n            <DED>unit_width = random.randint(self.unit_size_min, self.unit_size_max + 1)\n            unit_height = unit_width\n        <DED>else:\n            # set grid using holes numbers\n            <IND>if self.holes_number_x is None:\n                <IND>unit_width = max(2, width // 10)\n            <DED>else:\n                <IND>if not 1 <= self.holes_number_x <= width // 2:\n                    <IND>raise ValueError(\"The hole_number_x must be between 1 and image width//2.\")\n                <DED>unit_width = width // self.holes_number_x\n            <DED>if self.holes_number_y is None:\n                <IND>unit_height = max(min(unit_width, height), 2)\n            <DED>else:\n                <IND>if not 1 <= self.holes_number_y <= height // 2:\n                    <IND>raise ValueError(\"The hole_number_y must be between 1 and image height//2.\")\n                <DED>unit_height = height // self.holes_number_y\n\n        <DED><DED>hole_width = int(unit_width * self.ratio)\n        hole_height = int(unit_height * self.ratio)\n        # min 1 pixel and max unit length - 1\n        hole_width = min(max(hole_width, 1), unit_width - 1)\n        hole_height = min(max(hole_height, 1), unit_height - 1)\n        # set offset of the grid\n        if self.shift_x is None:\n            <IND>shift_x = 0\n        <DED>else:\n            <IND>shift_x = min(max(0, self.shift_x), unit_width - hole_width)\n        <DED>if self.shift_y is None:\n            <IND>shift_y = 0\n        <DED>else:\n            <IND>shift_y = min(max(0, self.shift_y), unit_height - hole_height)\n        <DED>if self.random_offset:\n            <IND>shift_x = random.randint(0, unit_width - hole_width)\n            shift_y = random.randint(0, unit_height - hole_height)\n        <DED>holes = []\n        for i in range(width // unit_width + 1):\n            <IND>for j in range(height // unit_height + 1):\n                <IND>x1 = min(shift_x + unit_width * i, width)\n                y1 = min(shift_y + unit_height * j, height)\n                x2 = min(x1 + hole_width, width)\n                y2 = min(y1 + hole_height, height)\n                holes.append((x1, y1, x2, y2))\n\n        <DED><DED>return {\"holes\": holes}\n\n    <DED>@property\n    def targets_as_params(self):\n        <IND>return [\"image\"]\n\n    <DED>def get_transform_init_args_names(self):\n        <IND>return (\n            \"ratio\",\n            \"unit_size_min\",\n            \"unit_size_max\",\n            \"holes_number_x\",\n            \"holes_number_y\",\n            \"shift_x\",\n            \"shift_y\",\n            \"mask_fill_value\",\n            \"random_offset\",\n        )\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "        <IND>return [\"image\"]\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "albumentations-team/albumentations",
    "commit": "4afa308646dd9fa5e7cd37b8dcc38da416a6a5ad",
    "filename": "albumentations/augmentations/transforms.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/albumentations-team-albumentations/albumentations/augmentations/transforms.py",
    "file_hunks_size": 16,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": true,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "albumentations/augmentations/transforms.py:2835:8 Incompatible variable type [9]: holes_number_x is declared to have type `int` but is used as type `None`.",
    "message": " holes_number_x is declared to have type `int` but is used as type `None`.",
    "rule_id": "Incompatible variable type [9]",
    "warning_line_no": 2835,
    "warning_line": "        holes_number_x: int = None,",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": true,
        "has_suppression": false,
        "source_code": "        return [\"image\"]\n\n\nclass GridDropout(DualTransform):\n    \"\"\"GridDropout, drops out rectangular regions of an image and the corresponding mask in a grid fashion.\n\n    Args:\n        ratio (float): the ratio of the mask holes to the unit_size (same for horizontal and vertical directions).\n            Must be between 0 and 1. Default: 0.5.\n        unit_size_min (int): minimum size of the grid unit. Must be between 2 and the image shorter edge.\n            If 'None', holes_number_x and holes_number_y are used to setup the grid. Default: `None`.\n        unit_size_max (int): maximum size of the grid unit. Must be between 2 and the image shorter edge.\n            If 'None', holes_number_x and holes_number_y are used to setup the grid. Default: `None`.\n        holes_number_x (int): the number of grid units in x direction. Must be between 1 and image width//2.\n            If 'None', grid unit width is set as image_width//10. Default: `None`.\n        holes_number_y (int): the number of grid units in y direction. Must be between 1 and image height//2.\n            If `None`, grid unit height is set equal to the grid unit width or image height, whatever is smaller.\n        shift_x (int): offsets of the grid start in x direction from (0,0) coordinate.\n            Clipped between 0 and grid unit_width - hole_width. Default: 0.\n        shift_y (int): offsets of the grid start in y direction from (0,0) coordinate.\n            Clipped between 0 and grid unit height - hole_height. Default: 0.\n        random_offset (boolean): weather to offset the grid randomly between 0 and grid unit size - hole size\n            If 'True', entered shift_x, shift_y are ignored and set randomly. Default: `False`.\n        fill_value (int): value for the dropped pixels. Default = 0\n        mask_fill_value (int): value for the dropped pixels in mask.\n            If `None`, transformation is not applied to the mask. Default: `None`.\n\n    Targets:\n        image, mask\n\n    Image types:\n        uint8, float32\n\n    References:\n        https://arxiv.org/abs/2001.04086\n\n    \"\"\"\n\n    def __init__(\n        self,\n        ratio: float = 0.5,\n        unit_size_min: int = None,\n        unit_size_max: int = None,\n        holes_number_x: int = None,\n        holes_number_y: int = None,\n        shift_x: int = 0,\n        shift_y: int = 0,\n        random_offset: bool = False,\n        fill_value: int = 0,\n        mask_fill_value: int = None,\n        always_apply: bool = False,\n        p: float = 0.5,\n    ):\n        super(GridDropout, self).__init__(always_apply, p)\n        self.ratio = ratio\n        self.unit_size_min = unit_size_min\n        self.unit_size_max = unit_size_max\n        self.holes_number_x = holes_number_x\n        self.holes_number_y = holes_number_y\n        self.shift_x = shift_x\n        self.shift_y = shift_y\n        self.random_offset = random_offset\n        self.fill_value = fill_value\n        self.mask_fill_value = mask_fill_value\n        if not 0 < self.ratio <= 1:\n            raise ValueError(\"ratio must be between 0 and 1.\")\n\n    def apply(self, image, holes=(), **params):\n        return F.cutout(image, holes, self.fill_value)\n\n    def apply_to_mask(self, image, holes=(), **params):\n        if self.mask_fill_value is None:\n            return image\n\n        return F.cutout(image, holes, self.mask_fill_value)\n\n    def get_params_dependent_on_targets(self, params):\n        img = params[\"image\"]\n        height, width = img.shape[:2]\n        # set grid using unit size limits\n        if self.unit_size_min and self.unit_size_max:\n            if not 2 <= self.unit_size_min <= self.unit_size_max:\n                raise ValueError(\"Max unit size should be >= min size, both at least 2 pixels.\")\n            if self.unit_size_max > min(height, width):\n                raise ValueError(\"Grid size limits must be within the shortest image edge.\")\n            unit_width = random.randint(self.unit_size_min, self.unit_size_max + 1)\n            unit_height = unit_width\n        else:\n            # set grid using holes numbers\n            if self.holes_number_x is None:\n                unit_width = max(2, width // 10)\n            else:\n                if not 1 <= self.holes_number_x <= width // 2:\n                    raise ValueError(\"The hole_number_x must be between 1 and image width//2.\")\n                unit_width = width // self.holes_number_x\n            if self.holes_number_y is None:\n                unit_height = max(min(unit_width, height), 2)\n            else:\n                if not 1 <= self.holes_number_y <= height // 2:\n                    raise ValueError(\"The hole_number_y must be between 1 and image height//2.\")\n                unit_height = height // self.holes_number_y\n\n        hole_width = int(unit_width * self.ratio)\n        hole_height = int(unit_height * self.ratio)\n        # min 1 pixel and max unit length - 1\n        hole_width = min(max(hole_width, 1), unit_width - 1)\n        hole_height = min(max(hole_height, 1), unit_height - 1)\n        # set offset of the grid\n        if self.shift_x is None:\n            shift_x = 0\n        else:\n            shift_x = min(max(0, self.shift_x), unit_width - hole_width)\n        if self.shift_y is None:\n            shift_y = 0\n        else:\n            shift_y = min(max(0, self.shift_y), unit_height - hole_height)\n        if self.random_offset:\n            shift_x = random.randint(0, unit_width - hole_width)\n            shift_y = random.randint(0, unit_height - hole_height)\n        holes = []\n        for i in range(width // unit_width + 1):\n            for j in range(height // unit_height + 1):\n                x1 = min(shift_x + unit_width * i, width)\n                y1 = min(shift_y + unit_height * j, height)\n                x2 = min(x1 + hole_width, width)\n                y2 = min(y1 + hole_height, height)\n                holes.append((x1, y1, x2, y2))\n\n        return {\"holes\": holes}\n\n    @property\n    def targets_as_params(self):\n        return [\"image\"]\n\n    def get_transform_init_args_names(self):\n        return (\n            \"ratio\",\n            \"unit_size_min\",\n            \"unit_size_max\",\n            \"holes_number_x\",\n            \"holes_number_y\",\n            \"shift_x\",\n            \"shift_y\",\n            \"mask_fill_value\",\n            \"random_offset\",\n        )\n\n",
        "source_code_len": 6293,
        "target_code": "        return [\"image\"]\n\n",
        "target_code_len": 26,
        "diff_format": "@@ -2792,147 +2407,2 @@\n         return [\"image\"]\n-\n-\n-class GridDropout(DualTransform):\n-    \"\"\"GridDropout, drops out rectangular regions of an image and the corresponding mask in a grid fashion.\n-\n-    Args:\n-        ratio (float): the ratio of the mask holes to the unit_size (same for horizontal and vertical directions).\n-            Must be between 0 and 1. Default: 0.5.\n-        unit_size_min (int): minimum size of the grid unit. Must be between 2 and the image shorter edge.\n-            If 'None', holes_number_x and holes_number_y are used to setup the grid. Default: `None`.\n-        unit_size_max (int): maximum size of the grid unit. Must be between 2 and the image shorter edge.\n-            If 'None', holes_number_x and holes_number_y are used to setup the grid. Default: `None`.\n-        holes_number_x (int): the number of grid units in x direction. Must be between 1 and image width//2.\n-            If 'None', grid unit width is set as image_width//10. Default: `None`.\n-        holes_number_y (int): the number of grid units in y direction. Must be between 1 and image height//2.\n-            If `None`, grid unit height is set equal to the grid unit width or image height, whatever is smaller.\n-        shift_x (int): offsets of the grid start in x direction from (0,0) coordinate.\n-            Clipped between 0 and grid unit_width - hole_width. Default: 0.\n-        shift_y (int): offsets of the grid start in y direction from (0,0) coordinate.\n-            Clipped between 0 and grid unit height - hole_height. Default: 0.\n-        random_offset (boolean): weather to offset the grid randomly between 0 and grid unit size - hole size\n-            If 'True', entered shift_x, shift_y are ignored and set randomly. Default: `False`.\n-        fill_value (int): value for the dropped pixels. Default = 0\n-        mask_fill_value (int): value for the dropped pixels in mask.\n-            If `None`, transformation is not applied to the mask. Default: `None`.\n-\n-    Targets:\n-        image, mask\n-\n-    Image types:\n-        uint8, float32\n-\n-    References:\n-        https://arxiv.org/abs/2001.04086\n-\n-    \"\"\"\n-\n-    def __init__(\n-        self,\n-        ratio: float = 0.5,\n-        unit_size_min: int = None,\n-        unit_size_max: int = None,\n-        holes_number_x: int = None,\n-        holes_number_y: int = None,\n-        shift_x: int = 0,\n-        shift_y: int = 0,\n-        random_offset: bool = False,\n-        fill_value: int = 0,\n-        mask_fill_value: int = None,\n-        always_apply: bool = False,\n-        p: float = 0.5,\n-    ):\n-        super(GridDropout, self).__init__(always_apply, p)\n-        self.ratio = ratio\n-        self.unit_size_min = unit_size_min\n-        self.unit_size_max = unit_size_max\n-        self.holes_number_x = holes_number_x\n-        self.holes_number_y = holes_number_y\n-        self.shift_x = shift_x\n-        self.shift_y = shift_y\n-        self.random_offset = random_offset\n-        self.fill_value = fill_value\n-        self.mask_fill_value = mask_fill_value\n-        if not 0 < self.ratio <= 1:\n-            raise ValueError(\"ratio must be between 0 and 1.\")\n-\n-    def apply(self, image, holes=(), **params):\n-        return F.cutout(image, holes, self.fill_value)\n-\n-    def apply_to_mask(self, image, holes=(), **params):\n-        if self.mask_fill_value is None:\n-            return image\n-\n-        return F.cutout(image, holes, self.mask_fill_value)\n-\n-    def get_params_dependent_on_targets(self, params):\n-        img = params[\"image\"]\n-        height, width = img.shape[:2]\n-        # set grid using unit size limits\n-        if self.unit_size_min and self.unit_size_max:\n-            if not 2 <= self.unit_size_min <= self.unit_size_max:\n-                raise ValueError(\"Max unit size should be >= min size, both at least 2 pixels.\")\n-            if self.unit_size_max > min(height, width):\n-                raise ValueError(\"Grid size limits must be within the shortest image edge.\")\n-            unit_width = random.randint(self.unit_size_min, self.unit_size_max + 1)\n-            unit_height = unit_width\n-        else:\n-            # set grid using holes numbers\n-            if self.holes_number_x is None:\n-                unit_width = max(2, width // 10)\n-            else:\n-                if not 1 <= self.holes_number_x <= width // 2:\n-                    raise ValueError(\"The hole_number_x must be between 1 and image width//2.\")\n-                unit_width = width // self.holes_number_x\n-            if self.holes_number_y is None:\n-                unit_height = max(min(unit_width, height), 2)\n-            else:\n-                if not 1 <= self.holes_number_y <= height // 2:\n-                    raise ValueError(\"The hole_number_y must be between 1 and image height//2.\")\n-                unit_height = height // self.holes_number_y\n-\n-        hole_width = int(unit_width * self.ratio)\n-        hole_height = int(unit_height * self.ratio)\n-        # min 1 pixel and max unit length - 1\n-        hole_width = min(max(hole_width, 1), unit_width - 1)\n-        hole_height = min(max(hole_height, 1), unit_height - 1)\n-        # set offset of the grid\n-        if self.shift_x is None:\n-            shift_x = 0\n-        else:\n-            shift_x = min(max(0, self.shift_x), unit_width - hole_width)\n-        if self.shift_y is None:\n-            shift_y = 0\n-        else:\n-            shift_y = min(max(0, self.shift_y), unit_height - hole_height)\n-        if self.random_offset:\n-            shift_x = random.randint(0, unit_width - hole_width)\n-            shift_y = random.randint(0, unit_height - hole_height)\n-        holes = []\n-        for i in range(width // unit_width + 1):\n-            for j in range(height // unit_height + 1):\n-                x1 = min(shift_x + unit_width * i, width)\n-                y1 = min(shift_y + unit_height * j, height)\n-                x2 = min(x1 + hole_width, width)\n-                y2 = min(y1 + hole_height, height)\n-                holes.append((x1, y1, x2, y2))\n-\n-        return {\"holes\": holes}\n-\n-    @property\n-    def targets_as_params(self):\n-        return [\"image\"]\n-\n-    def get_transform_init_args_names(self):\n-        return (\n-            \"ratio\",\n-            \"unit_size_min\",\n-            \"unit_size_max\",\n-            \"holes_number_x\",\n-            \"holes_number_y\",\n-            \"shift_x\",\n-            \"shift_y\",\n-            \"mask_fill_value\",\n-            \"random_offset\",\n-        )\n \n",
        "source_code_with_indent": "        <IND>return [\"image\"]\n\n\n<DED><DED>class GridDropout(DualTransform):\n    <IND>\"\"\"GridDropout, drops out rectangular regions of an image and the corresponding mask in a grid fashion.\n\n    Args:\n        ratio (float): the ratio of the mask holes to the unit_size (same for horizontal and vertical directions).\n            Must be between 0 and 1. Default: 0.5.\n        unit_size_min (int): minimum size of the grid unit. Must be between 2 and the image shorter edge.\n            If 'None', holes_number_x and holes_number_y are used to setup the grid. Default: `None`.\n        unit_size_max (int): maximum size of the grid unit. Must be between 2 and the image shorter edge.\n            If 'None', holes_number_x and holes_number_y are used to setup the grid. Default: `None`.\n        holes_number_x (int): the number of grid units in x direction. Must be between 1 and image width//2.\n            If 'None', grid unit width is set as image_width//10. Default: `None`.\n        holes_number_y (int): the number of grid units in y direction. Must be between 1 and image height//2.\n            If `None`, grid unit height is set equal to the grid unit width or image height, whatever is smaller.\n        shift_x (int): offsets of the grid start in x direction from (0,0) coordinate.\n            Clipped between 0 and grid unit_width - hole_width. Default: 0.\n        shift_y (int): offsets of the grid start in y direction from (0,0) coordinate.\n            Clipped between 0 and grid unit height - hole_height. Default: 0.\n        random_offset (boolean): weather to offset the grid randomly between 0 and grid unit size - hole size\n            If 'True', entered shift_x, shift_y are ignored and set randomly. Default: `False`.\n        fill_value (int): value for the dropped pixels. Default = 0\n        mask_fill_value (int): value for the dropped pixels in mask.\n            If `None`, transformation is not applied to the mask. Default: `None`.\n\n    Targets:\n        image, mask\n\n    Image types:\n        uint8, float32\n\n    References:\n        https://arxiv.org/abs/2001.04086\n\n    \"\"\"\n\n    def __init__(\n        self,\n        ratio: float = 0.5,\n        unit_size_min: int = None,\n        unit_size_max: int = None,\n        holes_number_x: int = None,\n        holes_number_y: int = None,\n        shift_x: int = 0,\n        shift_y: int = 0,\n        random_offset: bool = False,\n        fill_value: int = 0,\n        mask_fill_value: int = None,\n        always_apply: bool = False,\n        p: float = 0.5,\n    ):\n        <IND>super(GridDropout, self).__init__(always_apply, p)\n        self.ratio = ratio\n        self.unit_size_min = unit_size_min\n        self.unit_size_max = unit_size_max\n        self.holes_number_x = holes_number_x\n        self.holes_number_y = holes_number_y\n        self.shift_x = shift_x\n        self.shift_y = shift_y\n        self.random_offset = random_offset\n        self.fill_value = fill_value\n        self.mask_fill_value = mask_fill_value\n        if not 0 < self.ratio <= 1:\n            <IND>raise ValueError(\"ratio must be between 0 and 1.\")\n\n    <DED><DED>def apply(self, image, holes=(), **params):\n        <IND>return F.cutout(image, holes, self.fill_value)\n\n    <DED>def apply_to_mask(self, image, holes=(), **params):\n        <IND>if self.mask_fill_value is None:\n            <IND>return image\n\n        <DED>return F.cutout(image, holes, self.mask_fill_value)\n\n    <DED>def get_params_dependent_on_targets(self, params):\n        <IND>img = params[\"image\"]\n        height, width = img.shape[:2]\n        # set grid using unit size limits\n        if self.unit_size_min and self.unit_size_max:\n            <IND>if not 2 <= self.unit_size_min <= self.unit_size_max:\n                <IND>raise ValueError(\"Max unit size should be >= min size, both at least 2 pixels.\")\n            <DED>if self.unit_size_max > min(height, width):\n                <IND>raise ValueError(\"Grid size limits must be within the shortest image edge.\")\n            <DED>unit_width = random.randint(self.unit_size_min, self.unit_size_max + 1)\n            unit_height = unit_width\n        <DED>else:\n            # set grid using holes numbers\n            <IND>if self.holes_number_x is None:\n                <IND>unit_width = max(2, width // 10)\n            <DED>else:\n                <IND>if not 1 <= self.holes_number_x <= width // 2:\n                    <IND>raise ValueError(\"The hole_number_x must be between 1 and image width//2.\")\n                <DED>unit_width = width // self.holes_number_x\n            <DED>if self.holes_number_y is None:\n                <IND>unit_height = max(min(unit_width, height), 2)\n            <DED>else:\n                <IND>if not 1 <= self.holes_number_y <= height // 2:\n                    <IND>raise ValueError(\"The hole_number_y must be between 1 and image height//2.\")\n                <DED>unit_height = height // self.holes_number_y\n\n        <DED><DED>hole_width = int(unit_width * self.ratio)\n        hole_height = int(unit_height * self.ratio)\n        # min 1 pixel and max unit length - 1\n        hole_width = min(max(hole_width, 1), unit_width - 1)\n        hole_height = min(max(hole_height, 1), unit_height - 1)\n        # set offset of the grid\n        if self.shift_x is None:\n            <IND>shift_x = 0\n        <DED>else:\n            <IND>shift_x = min(max(0, self.shift_x), unit_width - hole_width)\n        <DED>if self.shift_y is None:\n            <IND>shift_y = 0\n        <DED>else:\n            <IND>shift_y = min(max(0, self.shift_y), unit_height - hole_height)\n        <DED>if self.random_offset:\n            <IND>shift_x = random.randint(0, unit_width - hole_width)\n            shift_y = random.randint(0, unit_height - hole_height)\n        <DED>holes = []\n        for i in range(width // unit_width + 1):\n            <IND>for j in range(height // unit_height + 1):\n                <IND>x1 = min(shift_x + unit_width * i, width)\n                y1 = min(shift_y + unit_height * j, height)\n                x2 = min(x1 + hole_width, width)\n                y2 = min(y1 + hole_height, height)\n                holes.append((x1, y1, x2, y2))\n\n        <DED><DED>return {\"holes\": holes}\n\n    <DED>@property\n    def targets_as_params(self):\n        <IND>return [\"image\"]\n\n    <DED>def get_transform_init_args_names(self):\n        <IND>return (\n            \"ratio\",\n            \"unit_size_min\",\n            \"unit_size_max\",\n            \"holes_number_x\",\n            \"holes_number_y\",\n            \"shift_x\",\n            \"shift_y\",\n            \"mask_fill_value\",\n            \"random_offset\",\n        )\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "        <IND>return [\"image\"]\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "albumentations-team/albumentations",
    "commit": "4afa308646dd9fa5e7cd37b8dcc38da416a6a5ad",
    "filename": "albumentations/augmentations/transforms.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/albumentations-team-albumentations/albumentations/augmentations/transforms.py",
    "file_hunks_size": 16,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": true,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "albumentations/augmentations/transforms.py:2836:8 Incompatible variable type [9]: holes_number_y is declared to have type `int` but is used as type `None`.",
    "message": " holes_number_y is declared to have type `int` but is used as type `None`.",
    "rule_id": "Incompatible variable type [9]",
    "warning_line_no": 2836,
    "warning_line": "        holes_number_y: int = None,",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": true,
        "has_suppression": false,
        "source_code": "        return [\"image\"]\n\n\nclass GridDropout(DualTransform):\n    \"\"\"GridDropout, drops out rectangular regions of an image and the corresponding mask in a grid fashion.\n\n    Args:\n        ratio (float): the ratio of the mask holes to the unit_size (same for horizontal and vertical directions).\n            Must be between 0 and 1. Default: 0.5.\n        unit_size_min (int): minimum size of the grid unit. Must be between 2 and the image shorter edge.\n            If 'None', holes_number_x and holes_number_y are used to setup the grid. Default: `None`.\n        unit_size_max (int): maximum size of the grid unit. Must be between 2 and the image shorter edge.\n            If 'None', holes_number_x and holes_number_y are used to setup the grid. Default: `None`.\n        holes_number_x (int): the number of grid units in x direction. Must be between 1 and image width//2.\n            If 'None', grid unit width is set as image_width//10. Default: `None`.\n        holes_number_y (int): the number of grid units in y direction. Must be between 1 and image height//2.\n            If `None`, grid unit height is set equal to the grid unit width or image height, whatever is smaller.\n        shift_x (int): offsets of the grid start in x direction from (0,0) coordinate.\n            Clipped between 0 and grid unit_width - hole_width. Default: 0.\n        shift_y (int): offsets of the grid start in y direction from (0,0) coordinate.\n            Clipped between 0 and grid unit height - hole_height. Default: 0.\n        random_offset (boolean): weather to offset the grid randomly between 0 and grid unit size - hole size\n            If 'True', entered shift_x, shift_y are ignored and set randomly. Default: `False`.\n        fill_value (int): value for the dropped pixels. Default = 0\n        mask_fill_value (int): value for the dropped pixels in mask.\n            If `None`, transformation is not applied to the mask. Default: `None`.\n\n    Targets:\n        image, mask\n\n    Image types:\n        uint8, float32\n\n    References:\n        https://arxiv.org/abs/2001.04086\n\n    \"\"\"\n\n    def __init__(\n        self,\n        ratio: float = 0.5,\n        unit_size_min: int = None,\n        unit_size_max: int = None,\n        holes_number_x: int = None,\n        holes_number_y: int = None,\n        shift_x: int = 0,\n        shift_y: int = 0,\n        random_offset: bool = False,\n        fill_value: int = 0,\n        mask_fill_value: int = None,\n        always_apply: bool = False,\n        p: float = 0.5,\n    ):\n        super(GridDropout, self).__init__(always_apply, p)\n        self.ratio = ratio\n        self.unit_size_min = unit_size_min\n        self.unit_size_max = unit_size_max\n        self.holes_number_x = holes_number_x\n        self.holes_number_y = holes_number_y\n        self.shift_x = shift_x\n        self.shift_y = shift_y\n        self.random_offset = random_offset\n        self.fill_value = fill_value\n        self.mask_fill_value = mask_fill_value\n        if not 0 < self.ratio <= 1:\n            raise ValueError(\"ratio must be between 0 and 1.\")\n\n    def apply(self, image, holes=(), **params):\n        return F.cutout(image, holes, self.fill_value)\n\n    def apply_to_mask(self, image, holes=(), **params):\n        if self.mask_fill_value is None:\n            return image\n\n        return F.cutout(image, holes, self.mask_fill_value)\n\n    def get_params_dependent_on_targets(self, params):\n        img = params[\"image\"]\n        height, width = img.shape[:2]\n        # set grid using unit size limits\n        if self.unit_size_min and self.unit_size_max:\n            if not 2 <= self.unit_size_min <= self.unit_size_max:\n                raise ValueError(\"Max unit size should be >= min size, both at least 2 pixels.\")\n            if self.unit_size_max > min(height, width):\n                raise ValueError(\"Grid size limits must be within the shortest image edge.\")\n            unit_width = random.randint(self.unit_size_min, self.unit_size_max + 1)\n            unit_height = unit_width\n        else:\n            # set grid using holes numbers\n            if self.holes_number_x is None:\n                unit_width = max(2, width // 10)\n            else:\n                if not 1 <= self.holes_number_x <= width // 2:\n                    raise ValueError(\"The hole_number_x must be between 1 and image width//2.\")\n                unit_width = width // self.holes_number_x\n            if self.holes_number_y is None:\n                unit_height = max(min(unit_width, height), 2)\n            else:\n                if not 1 <= self.holes_number_y <= height // 2:\n                    raise ValueError(\"The hole_number_y must be between 1 and image height//2.\")\n                unit_height = height // self.holes_number_y\n\n        hole_width = int(unit_width * self.ratio)\n        hole_height = int(unit_height * self.ratio)\n        # min 1 pixel and max unit length - 1\n        hole_width = min(max(hole_width, 1), unit_width - 1)\n        hole_height = min(max(hole_height, 1), unit_height - 1)\n        # set offset of the grid\n        if self.shift_x is None:\n            shift_x = 0\n        else:\n            shift_x = min(max(0, self.shift_x), unit_width - hole_width)\n        if self.shift_y is None:\n            shift_y = 0\n        else:\n            shift_y = min(max(0, self.shift_y), unit_height - hole_height)\n        if self.random_offset:\n            shift_x = random.randint(0, unit_width - hole_width)\n            shift_y = random.randint(0, unit_height - hole_height)\n        holes = []\n        for i in range(width // unit_width + 1):\n            for j in range(height // unit_height + 1):\n                x1 = min(shift_x + unit_width * i, width)\n                y1 = min(shift_y + unit_height * j, height)\n                x2 = min(x1 + hole_width, width)\n                y2 = min(y1 + hole_height, height)\n                holes.append((x1, y1, x2, y2))\n\n        return {\"holes\": holes}\n\n    @property\n    def targets_as_params(self):\n        return [\"image\"]\n\n    def get_transform_init_args_names(self):\n        return (\n            \"ratio\",\n            \"unit_size_min\",\n            \"unit_size_max\",\n            \"holes_number_x\",\n            \"holes_number_y\",\n            \"shift_x\",\n            \"shift_y\",\n            \"mask_fill_value\",\n            \"random_offset\",\n        )\n\n",
        "source_code_len": 6293,
        "target_code": "        return [\"image\"]\n\n",
        "target_code_len": 26,
        "diff_format": "@@ -2792,147 +2407,2 @@\n         return [\"image\"]\n-\n-\n-class GridDropout(DualTransform):\n-    \"\"\"GridDropout, drops out rectangular regions of an image and the corresponding mask in a grid fashion.\n-\n-    Args:\n-        ratio (float): the ratio of the mask holes to the unit_size (same for horizontal and vertical directions).\n-            Must be between 0 and 1. Default: 0.5.\n-        unit_size_min (int): minimum size of the grid unit. Must be between 2 and the image shorter edge.\n-            If 'None', holes_number_x and holes_number_y are used to setup the grid. Default: `None`.\n-        unit_size_max (int): maximum size of the grid unit. Must be between 2 and the image shorter edge.\n-            If 'None', holes_number_x and holes_number_y are used to setup the grid. Default: `None`.\n-        holes_number_x (int): the number of grid units in x direction. Must be between 1 and image width//2.\n-            If 'None', grid unit width is set as image_width//10. Default: `None`.\n-        holes_number_y (int): the number of grid units in y direction. Must be between 1 and image height//2.\n-            If `None`, grid unit height is set equal to the grid unit width or image height, whatever is smaller.\n-        shift_x (int): offsets of the grid start in x direction from (0,0) coordinate.\n-            Clipped between 0 and grid unit_width - hole_width. Default: 0.\n-        shift_y (int): offsets of the grid start in y direction from (0,0) coordinate.\n-            Clipped between 0 and grid unit height - hole_height. Default: 0.\n-        random_offset (boolean): weather to offset the grid randomly between 0 and grid unit size - hole size\n-            If 'True', entered shift_x, shift_y are ignored and set randomly. Default: `False`.\n-        fill_value (int): value for the dropped pixels. Default = 0\n-        mask_fill_value (int): value for the dropped pixels in mask.\n-            If `None`, transformation is not applied to the mask. Default: `None`.\n-\n-    Targets:\n-        image, mask\n-\n-    Image types:\n-        uint8, float32\n-\n-    References:\n-        https://arxiv.org/abs/2001.04086\n-\n-    \"\"\"\n-\n-    def __init__(\n-        self,\n-        ratio: float = 0.5,\n-        unit_size_min: int = None,\n-        unit_size_max: int = None,\n-        holes_number_x: int = None,\n-        holes_number_y: int = None,\n-        shift_x: int = 0,\n-        shift_y: int = 0,\n-        random_offset: bool = False,\n-        fill_value: int = 0,\n-        mask_fill_value: int = None,\n-        always_apply: bool = False,\n-        p: float = 0.5,\n-    ):\n-        super(GridDropout, self).__init__(always_apply, p)\n-        self.ratio = ratio\n-        self.unit_size_min = unit_size_min\n-        self.unit_size_max = unit_size_max\n-        self.holes_number_x = holes_number_x\n-        self.holes_number_y = holes_number_y\n-        self.shift_x = shift_x\n-        self.shift_y = shift_y\n-        self.random_offset = random_offset\n-        self.fill_value = fill_value\n-        self.mask_fill_value = mask_fill_value\n-        if not 0 < self.ratio <= 1:\n-            raise ValueError(\"ratio must be between 0 and 1.\")\n-\n-    def apply(self, image, holes=(), **params):\n-        return F.cutout(image, holes, self.fill_value)\n-\n-    def apply_to_mask(self, image, holes=(), **params):\n-        if self.mask_fill_value is None:\n-            return image\n-\n-        return F.cutout(image, holes, self.mask_fill_value)\n-\n-    def get_params_dependent_on_targets(self, params):\n-        img = params[\"image\"]\n-        height, width = img.shape[:2]\n-        # set grid using unit size limits\n-        if self.unit_size_min and self.unit_size_max:\n-            if not 2 <= self.unit_size_min <= self.unit_size_max:\n-                raise ValueError(\"Max unit size should be >= min size, both at least 2 pixels.\")\n-            if self.unit_size_max > min(height, width):\n-                raise ValueError(\"Grid size limits must be within the shortest image edge.\")\n-            unit_width = random.randint(self.unit_size_min, self.unit_size_max + 1)\n-            unit_height = unit_width\n-        else:\n-            # set grid using holes numbers\n-            if self.holes_number_x is None:\n-                unit_width = max(2, width // 10)\n-            else:\n-                if not 1 <= self.holes_number_x <= width // 2:\n-                    raise ValueError(\"The hole_number_x must be between 1 and image width//2.\")\n-                unit_width = width // self.holes_number_x\n-            if self.holes_number_y is None:\n-                unit_height = max(min(unit_width, height), 2)\n-            else:\n-                if not 1 <= self.holes_number_y <= height // 2:\n-                    raise ValueError(\"The hole_number_y must be between 1 and image height//2.\")\n-                unit_height = height // self.holes_number_y\n-\n-        hole_width = int(unit_width * self.ratio)\n-        hole_height = int(unit_height * self.ratio)\n-        # min 1 pixel and max unit length - 1\n-        hole_width = min(max(hole_width, 1), unit_width - 1)\n-        hole_height = min(max(hole_height, 1), unit_height - 1)\n-        # set offset of the grid\n-        if self.shift_x is None:\n-            shift_x = 0\n-        else:\n-            shift_x = min(max(0, self.shift_x), unit_width - hole_width)\n-        if self.shift_y is None:\n-            shift_y = 0\n-        else:\n-            shift_y = min(max(0, self.shift_y), unit_height - hole_height)\n-        if self.random_offset:\n-            shift_x = random.randint(0, unit_width - hole_width)\n-            shift_y = random.randint(0, unit_height - hole_height)\n-        holes = []\n-        for i in range(width // unit_width + 1):\n-            for j in range(height // unit_height + 1):\n-                x1 = min(shift_x + unit_width * i, width)\n-                y1 = min(shift_y + unit_height * j, height)\n-                x2 = min(x1 + hole_width, width)\n-                y2 = min(y1 + hole_height, height)\n-                holes.append((x1, y1, x2, y2))\n-\n-        return {\"holes\": holes}\n-\n-    @property\n-    def targets_as_params(self):\n-        return [\"image\"]\n-\n-    def get_transform_init_args_names(self):\n-        return (\n-            \"ratio\",\n-            \"unit_size_min\",\n-            \"unit_size_max\",\n-            \"holes_number_x\",\n-            \"holes_number_y\",\n-            \"shift_x\",\n-            \"shift_y\",\n-            \"mask_fill_value\",\n-            \"random_offset\",\n-        )\n \n",
        "source_code_with_indent": "        <IND>return [\"image\"]\n\n\n<DED><DED>class GridDropout(DualTransform):\n    <IND>\"\"\"GridDropout, drops out rectangular regions of an image and the corresponding mask in a grid fashion.\n\n    Args:\n        ratio (float): the ratio of the mask holes to the unit_size (same for horizontal and vertical directions).\n            Must be between 0 and 1. Default: 0.5.\n        unit_size_min (int): minimum size of the grid unit. Must be between 2 and the image shorter edge.\n            If 'None', holes_number_x and holes_number_y are used to setup the grid. Default: `None`.\n        unit_size_max (int): maximum size of the grid unit. Must be between 2 and the image shorter edge.\n            If 'None', holes_number_x and holes_number_y are used to setup the grid. Default: `None`.\n        holes_number_x (int): the number of grid units in x direction. Must be between 1 and image width//2.\n            If 'None', grid unit width is set as image_width//10. Default: `None`.\n        holes_number_y (int): the number of grid units in y direction. Must be between 1 and image height//2.\n            If `None`, grid unit height is set equal to the grid unit width or image height, whatever is smaller.\n        shift_x (int): offsets of the grid start in x direction from (0,0) coordinate.\n            Clipped between 0 and grid unit_width - hole_width. Default: 0.\n        shift_y (int): offsets of the grid start in y direction from (0,0) coordinate.\n            Clipped between 0 and grid unit height - hole_height. Default: 0.\n        random_offset (boolean): weather to offset the grid randomly between 0 and grid unit size - hole size\n            If 'True', entered shift_x, shift_y are ignored and set randomly. Default: `False`.\n        fill_value (int): value for the dropped pixels. Default = 0\n        mask_fill_value (int): value for the dropped pixels in mask.\n            If `None`, transformation is not applied to the mask. Default: `None`.\n\n    Targets:\n        image, mask\n\n    Image types:\n        uint8, float32\n\n    References:\n        https://arxiv.org/abs/2001.04086\n\n    \"\"\"\n\n    def __init__(\n        self,\n        ratio: float = 0.5,\n        unit_size_min: int = None,\n        unit_size_max: int = None,\n        holes_number_x: int = None,\n        holes_number_y: int = None,\n        shift_x: int = 0,\n        shift_y: int = 0,\n        random_offset: bool = False,\n        fill_value: int = 0,\n        mask_fill_value: int = None,\n        always_apply: bool = False,\n        p: float = 0.5,\n    ):\n        <IND>super(GridDropout, self).__init__(always_apply, p)\n        self.ratio = ratio\n        self.unit_size_min = unit_size_min\n        self.unit_size_max = unit_size_max\n        self.holes_number_x = holes_number_x\n        self.holes_number_y = holes_number_y\n        self.shift_x = shift_x\n        self.shift_y = shift_y\n        self.random_offset = random_offset\n        self.fill_value = fill_value\n        self.mask_fill_value = mask_fill_value\n        if not 0 < self.ratio <= 1:\n            <IND>raise ValueError(\"ratio must be between 0 and 1.\")\n\n    <DED><DED>def apply(self, image, holes=(), **params):\n        <IND>return F.cutout(image, holes, self.fill_value)\n\n    <DED>def apply_to_mask(self, image, holes=(), **params):\n        <IND>if self.mask_fill_value is None:\n            <IND>return image\n\n        <DED>return F.cutout(image, holes, self.mask_fill_value)\n\n    <DED>def get_params_dependent_on_targets(self, params):\n        <IND>img = params[\"image\"]\n        height, width = img.shape[:2]\n        # set grid using unit size limits\n        if self.unit_size_min and self.unit_size_max:\n            <IND>if not 2 <= self.unit_size_min <= self.unit_size_max:\n                <IND>raise ValueError(\"Max unit size should be >= min size, both at least 2 pixels.\")\n            <DED>if self.unit_size_max > min(height, width):\n                <IND>raise ValueError(\"Grid size limits must be within the shortest image edge.\")\n            <DED>unit_width = random.randint(self.unit_size_min, self.unit_size_max + 1)\n            unit_height = unit_width\n        <DED>else:\n            # set grid using holes numbers\n            <IND>if self.holes_number_x is None:\n                <IND>unit_width = max(2, width // 10)\n            <DED>else:\n                <IND>if not 1 <= self.holes_number_x <= width // 2:\n                    <IND>raise ValueError(\"The hole_number_x must be between 1 and image width//2.\")\n                <DED>unit_width = width // self.holes_number_x\n            <DED>if self.holes_number_y is None:\n                <IND>unit_height = max(min(unit_width, height), 2)\n            <DED>else:\n                <IND>if not 1 <= self.holes_number_y <= height // 2:\n                    <IND>raise ValueError(\"The hole_number_y must be between 1 and image height//2.\")\n                <DED>unit_height = height // self.holes_number_y\n\n        <DED><DED>hole_width = int(unit_width * self.ratio)\n        hole_height = int(unit_height * self.ratio)\n        # min 1 pixel and max unit length - 1\n        hole_width = min(max(hole_width, 1), unit_width - 1)\n        hole_height = min(max(hole_height, 1), unit_height - 1)\n        # set offset of the grid\n        if self.shift_x is None:\n            <IND>shift_x = 0\n        <DED>else:\n            <IND>shift_x = min(max(0, self.shift_x), unit_width - hole_width)\n        <DED>if self.shift_y is None:\n            <IND>shift_y = 0\n        <DED>else:\n            <IND>shift_y = min(max(0, self.shift_y), unit_height - hole_height)\n        <DED>if self.random_offset:\n            <IND>shift_x = random.randint(0, unit_width - hole_width)\n            shift_y = random.randint(0, unit_height - hole_height)\n        <DED>holes = []\n        for i in range(width // unit_width + 1):\n            <IND>for j in range(height // unit_height + 1):\n                <IND>x1 = min(shift_x + unit_width * i, width)\n                y1 = min(shift_y + unit_height * j, height)\n                x2 = min(x1 + hole_width, width)\n                y2 = min(y1 + hole_height, height)\n                holes.append((x1, y1, x2, y2))\n\n        <DED><DED>return {\"holes\": holes}\n\n    <DED>@property\n    def targets_as_params(self):\n        <IND>return [\"image\"]\n\n    <DED>def get_transform_init_args_names(self):\n        <IND>return (\n            \"ratio\",\n            \"unit_size_min\",\n            \"unit_size_max\",\n            \"holes_number_x\",\n            \"holes_number_y\",\n            \"shift_x\",\n            \"shift_y\",\n            \"mask_fill_value\",\n            \"random_offset\",\n        )\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "        <IND>return [\"image\"]\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "albumentations-team/albumentations",
    "commit": "4afa308646dd9fa5e7cd37b8dcc38da416a6a5ad",
    "filename": "albumentations/augmentations/transforms.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/albumentations-team-albumentations/albumentations/augmentations/transforms.py",
    "file_hunks_size": 16,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": true,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "albumentations/augmentations/transforms.py:2841:8 Incompatible variable type [9]: mask_fill_value is declared to have type `int` but is used as type `None`.",
    "message": " mask_fill_value is declared to have type `int` but is used as type `None`.",
    "rule_id": "Incompatible variable type [9]",
    "warning_line_no": 2841,
    "warning_line": "        mask_fill_value: int = None,",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": true,
        "has_suppression": false,
        "source_code": "        return [\"image\"]\n\n\nclass GridDropout(DualTransform):\n    \"\"\"GridDropout, drops out rectangular regions of an image and the corresponding mask in a grid fashion.\n\n    Args:\n        ratio (float): the ratio of the mask holes to the unit_size (same for horizontal and vertical directions).\n            Must be between 0 and 1. Default: 0.5.\n        unit_size_min (int): minimum size of the grid unit. Must be between 2 and the image shorter edge.\n            If 'None', holes_number_x and holes_number_y are used to setup the grid. Default: `None`.\n        unit_size_max (int): maximum size of the grid unit. Must be between 2 and the image shorter edge.\n            If 'None', holes_number_x and holes_number_y are used to setup the grid. Default: `None`.\n        holes_number_x (int): the number of grid units in x direction. Must be between 1 and image width//2.\n            If 'None', grid unit width is set as image_width//10. Default: `None`.\n        holes_number_y (int): the number of grid units in y direction. Must be between 1 and image height//2.\n            If `None`, grid unit height is set equal to the grid unit width or image height, whatever is smaller.\n        shift_x (int): offsets of the grid start in x direction from (0,0) coordinate.\n            Clipped between 0 and grid unit_width - hole_width. Default: 0.\n        shift_y (int): offsets of the grid start in y direction from (0,0) coordinate.\n            Clipped between 0 and grid unit height - hole_height. Default: 0.\n        random_offset (boolean): weather to offset the grid randomly between 0 and grid unit size - hole size\n            If 'True', entered shift_x, shift_y are ignored and set randomly. Default: `False`.\n        fill_value (int): value for the dropped pixels. Default = 0\n        mask_fill_value (int): value for the dropped pixels in mask.\n            If `None`, transformation is not applied to the mask. Default: `None`.\n\n    Targets:\n        image, mask\n\n    Image types:\n        uint8, float32\n\n    References:\n        https://arxiv.org/abs/2001.04086\n\n    \"\"\"\n\n    def __init__(\n        self,\n        ratio: float = 0.5,\n        unit_size_min: int = None,\n        unit_size_max: int = None,\n        holes_number_x: int = None,\n        holes_number_y: int = None,\n        shift_x: int = 0,\n        shift_y: int = 0,\n        random_offset: bool = False,\n        fill_value: int = 0,\n        mask_fill_value: int = None,\n        always_apply: bool = False,\n        p: float = 0.5,\n    ):\n        super(GridDropout, self).__init__(always_apply, p)\n        self.ratio = ratio\n        self.unit_size_min = unit_size_min\n        self.unit_size_max = unit_size_max\n        self.holes_number_x = holes_number_x\n        self.holes_number_y = holes_number_y\n        self.shift_x = shift_x\n        self.shift_y = shift_y\n        self.random_offset = random_offset\n        self.fill_value = fill_value\n        self.mask_fill_value = mask_fill_value\n        if not 0 < self.ratio <= 1:\n            raise ValueError(\"ratio must be between 0 and 1.\")\n\n    def apply(self, image, holes=(), **params):\n        return F.cutout(image, holes, self.fill_value)\n\n    def apply_to_mask(self, image, holes=(), **params):\n        if self.mask_fill_value is None:\n            return image\n\n        return F.cutout(image, holes, self.mask_fill_value)\n\n    def get_params_dependent_on_targets(self, params):\n        img = params[\"image\"]\n        height, width = img.shape[:2]\n        # set grid using unit size limits\n        if self.unit_size_min and self.unit_size_max:\n            if not 2 <= self.unit_size_min <= self.unit_size_max:\n                raise ValueError(\"Max unit size should be >= min size, both at least 2 pixels.\")\n            if self.unit_size_max > min(height, width):\n                raise ValueError(\"Grid size limits must be within the shortest image edge.\")\n            unit_width = random.randint(self.unit_size_min, self.unit_size_max + 1)\n            unit_height = unit_width\n        else:\n            # set grid using holes numbers\n            if self.holes_number_x is None:\n                unit_width = max(2, width // 10)\n            else:\n                if not 1 <= self.holes_number_x <= width // 2:\n                    raise ValueError(\"The hole_number_x must be between 1 and image width//2.\")\n                unit_width = width // self.holes_number_x\n            if self.holes_number_y is None:\n                unit_height = max(min(unit_width, height), 2)\n            else:\n                if not 1 <= self.holes_number_y <= height // 2:\n                    raise ValueError(\"The hole_number_y must be between 1 and image height//2.\")\n                unit_height = height // self.holes_number_y\n\n        hole_width = int(unit_width * self.ratio)\n        hole_height = int(unit_height * self.ratio)\n        # min 1 pixel and max unit length - 1\n        hole_width = min(max(hole_width, 1), unit_width - 1)\n        hole_height = min(max(hole_height, 1), unit_height - 1)\n        # set offset of the grid\n        if self.shift_x is None:\n            shift_x = 0\n        else:\n            shift_x = min(max(0, self.shift_x), unit_width - hole_width)\n        if self.shift_y is None:\n            shift_y = 0\n        else:\n            shift_y = min(max(0, self.shift_y), unit_height - hole_height)\n        if self.random_offset:\n            shift_x = random.randint(0, unit_width - hole_width)\n            shift_y = random.randint(0, unit_height - hole_height)\n        holes = []\n        for i in range(width // unit_width + 1):\n            for j in range(height // unit_height + 1):\n                x1 = min(shift_x + unit_width * i, width)\n                y1 = min(shift_y + unit_height * j, height)\n                x2 = min(x1 + hole_width, width)\n                y2 = min(y1 + hole_height, height)\n                holes.append((x1, y1, x2, y2))\n\n        return {\"holes\": holes}\n\n    @property\n    def targets_as_params(self):\n        return [\"image\"]\n\n    def get_transform_init_args_names(self):\n        return (\n            \"ratio\",\n            \"unit_size_min\",\n            \"unit_size_max\",\n            \"holes_number_x\",\n            \"holes_number_y\",\n            \"shift_x\",\n            \"shift_y\",\n            \"mask_fill_value\",\n            \"random_offset\",\n        )\n\n",
        "source_code_len": 6293,
        "target_code": "        return [\"image\"]\n\n",
        "target_code_len": 26,
        "diff_format": "@@ -2792,147 +2407,2 @@\n         return [\"image\"]\n-\n-\n-class GridDropout(DualTransform):\n-    \"\"\"GridDropout, drops out rectangular regions of an image and the corresponding mask in a grid fashion.\n-\n-    Args:\n-        ratio (float): the ratio of the mask holes to the unit_size (same for horizontal and vertical directions).\n-            Must be between 0 and 1. Default: 0.5.\n-        unit_size_min (int): minimum size of the grid unit. Must be between 2 and the image shorter edge.\n-            If 'None', holes_number_x and holes_number_y are used to setup the grid. Default: `None`.\n-        unit_size_max (int): maximum size of the grid unit. Must be between 2 and the image shorter edge.\n-            If 'None', holes_number_x and holes_number_y are used to setup the grid. Default: `None`.\n-        holes_number_x (int): the number of grid units in x direction. Must be between 1 and image width//2.\n-            If 'None', grid unit width is set as image_width//10. Default: `None`.\n-        holes_number_y (int): the number of grid units in y direction. Must be between 1 and image height//2.\n-            If `None`, grid unit height is set equal to the grid unit width or image height, whatever is smaller.\n-        shift_x (int): offsets of the grid start in x direction from (0,0) coordinate.\n-            Clipped between 0 and grid unit_width - hole_width. Default: 0.\n-        shift_y (int): offsets of the grid start in y direction from (0,0) coordinate.\n-            Clipped between 0 and grid unit height - hole_height. Default: 0.\n-        random_offset (boolean): weather to offset the grid randomly between 0 and grid unit size - hole size\n-            If 'True', entered shift_x, shift_y are ignored and set randomly. Default: `False`.\n-        fill_value (int): value for the dropped pixels. Default = 0\n-        mask_fill_value (int): value for the dropped pixels in mask.\n-            If `None`, transformation is not applied to the mask. Default: `None`.\n-\n-    Targets:\n-        image, mask\n-\n-    Image types:\n-        uint8, float32\n-\n-    References:\n-        https://arxiv.org/abs/2001.04086\n-\n-    \"\"\"\n-\n-    def __init__(\n-        self,\n-        ratio: float = 0.5,\n-        unit_size_min: int = None,\n-        unit_size_max: int = None,\n-        holes_number_x: int = None,\n-        holes_number_y: int = None,\n-        shift_x: int = 0,\n-        shift_y: int = 0,\n-        random_offset: bool = False,\n-        fill_value: int = 0,\n-        mask_fill_value: int = None,\n-        always_apply: bool = False,\n-        p: float = 0.5,\n-    ):\n-        super(GridDropout, self).__init__(always_apply, p)\n-        self.ratio = ratio\n-        self.unit_size_min = unit_size_min\n-        self.unit_size_max = unit_size_max\n-        self.holes_number_x = holes_number_x\n-        self.holes_number_y = holes_number_y\n-        self.shift_x = shift_x\n-        self.shift_y = shift_y\n-        self.random_offset = random_offset\n-        self.fill_value = fill_value\n-        self.mask_fill_value = mask_fill_value\n-        if not 0 < self.ratio <= 1:\n-            raise ValueError(\"ratio must be between 0 and 1.\")\n-\n-    def apply(self, image, holes=(), **params):\n-        return F.cutout(image, holes, self.fill_value)\n-\n-    def apply_to_mask(self, image, holes=(), **params):\n-        if self.mask_fill_value is None:\n-            return image\n-\n-        return F.cutout(image, holes, self.mask_fill_value)\n-\n-    def get_params_dependent_on_targets(self, params):\n-        img = params[\"image\"]\n-        height, width = img.shape[:2]\n-        # set grid using unit size limits\n-        if self.unit_size_min and self.unit_size_max:\n-            if not 2 <= self.unit_size_min <= self.unit_size_max:\n-                raise ValueError(\"Max unit size should be >= min size, both at least 2 pixels.\")\n-            if self.unit_size_max > min(height, width):\n-                raise ValueError(\"Grid size limits must be within the shortest image edge.\")\n-            unit_width = random.randint(self.unit_size_min, self.unit_size_max + 1)\n-            unit_height = unit_width\n-        else:\n-            # set grid using holes numbers\n-            if self.holes_number_x is None:\n-                unit_width = max(2, width // 10)\n-            else:\n-                if not 1 <= self.holes_number_x <= width // 2:\n-                    raise ValueError(\"The hole_number_x must be between 1 and image width//2.\")\n-                unit_width = width // self.holes_number_x\n-            if self.holes_number_y is None:\n-                unit_height = max(min(unit_width, height), 2)\n-            else:\n-                if not 1 <= self.holes_number_y <= height // 2:\n-                    raise ValueError(\"The hole_number_y must be between 1 and image height//2.\")\n-                unit_height = height // self.holes_number_y\n-\n-        hole_width = int(unit_width * self.ratio)\n-        hole_height = int(unit_height * self.ratio)\n-        # min 1 pixel and max unit length - 1\n-        hole_width = min(max(hole_width, 1), unit_width - 1)\n-        hole_height = min(max(hole_height, 1), unit_height - 1)\n-        # set offset of the grid\n-        if self.shift_x is None:\n-            shift_x = 0\n-        else:\n-            shift_x = min(max(0, self.shift_x), unit_width - hole_width)\n-        if self.shift_y is None:\n-            shift_y = 0\n-        else:\n-            shift_y = min(max(0, self.shift_y), unit_height - hole_height)\n-        if self.random_offset:\n-            shift_x = random.randint(0, unit_width - hole_width)\n-            shift_y = random.randint(0, unit_height - hole_height)\n-        holes = []\n-        for i in range(width // unit_width + 1):\n-            for j in range(height // unit_height + 1):\n-                x1 = min(shift_x + unit_width * i, width)\n-                y1 = min(shift_y + unit_height * j, height)\n-                x2 = min(x1 + hole_width, width)\n-                y2 = min(y1 + hole_height, height)\n-                holes.append((x1, y1, x2, y2))\n-\n-        return {\"holes\": holes}\n-\n-    @property\n-    def targets_as_params(self):\n-        return [\"image\"]\n-\n-    def get_transform_init_args_names(self):\n-        return (\n-            \"ratio\",\n-            \"unit_size_min\",\n-            \"unit_size_max\",\n-            \"holes_number_x\",\n-            \"holes_number_y\",\n-            \"shift_x\",\n-            \"shift_y\",\n-            \"mask_fill_value\",\n-            \"random_offset\",\n-        )\n \n",
        "source_code_with_indent": "        <IND>return [\"image\"]\n\n\n<DED><DED>class GridDropout(DualTransform):\n    <IND>\"\"\"GridDropout, drops out rectangular regions of an image and the corresponding mask in a grid fashion.\n\n    Args:\n        ratio (float): the ratio of the mask holes to the unit_size (same for horizontal and vertical directions).\n            Must be between 0 and 1. Default: 0.5.\n        unit_size_min (int): minimum size of the grid unit. Must be between 2 and the image shorter edge.\n            If 'None', holes_number_x and holes_number_y are used to setup the grid. Default: `None`.\n        unit_size_max (int): maximum size of the grid unit. Must be between 2 and the image shorter edge.\n            If 'None', holes_number_x and holes_number_y are used to setup the grid. Default: `None`.\n        holes_number_x (int): the number of grid units in x direction. Must be between 1 and image width//2.\n            If 'None', grid unit width is set as image_width//10. Default: `None`.\n        holes_number_y (int): the number of grid units in y direction. Must be between 1 and image height//2.\n            If `None`, grid unit height is set equal to the grid unit width or image height, whatever is smaller.\n        shift_x (int): offsets of the grid start in x direction from (0,0) coordinate.\n            Clipped between 0 and grid unit_width - hole_width. Default: 0.\n        shift_y (int): offsets of the grid start in y direction from (0,0) coordinate.\n            Clipped between 0 and grid unit height - hole_height. Default: 0.\n        random_offset (boolean): weather to offset the grid randomly between 0 and grid unit size - hole size\n            If 'True', entered shift_x, shift_y are ignored and set randomly. Default: `False`.\n        fill_value (int): value for the dropped pixels. Default = 0\n        mask_fill_value (int): value for the dropped pixels in mask.\n            If `None`, transformation is not applied to the mask. Default: `None`.\n\n    Targets:\n        image, mask\n\n    Image types:\n        uint8, float32\n\n    References:\n        https://arxiv.org/abs/2001.04086\n\n    \"\"\"\n\n    def __init__(\n        self,\n        ratio: float = 0.5,\n        unit_size_min: int = None,\n        unit_size_max: int = None,\n        holes_number_x: int = None,\n        holes_number_y: int = None,\n        shift_x: int = 0,\n        shift_y: int = 0,\n        random_offset: bool = False,\n        fill_value: int = 0,\n        mask_fill_value: int = None,\n        always_apply: bool = False,\n        p: float = 0.5,\n    ):\n        <IND>super(GridDropout, self).__init__(always_apply, p)\n        self.ratio = ratio\n        self.unit_size_min = unit_size_min\n        self.unit_size_max = unit_size_max\n        self.holes_number_x = holes_number_x\n        self.holes_number_y = holes_number_y\n        self.shift_x = shift_x\n        self.shift_y = shift_y\n        self.random_offset = random_offset\n        self.fill_value = fill_value\n        self.mask_fill_value = mask_fill_value\n        if not 0 < self.ratio <= 1:\n            <IND>raise ValueError(\"ratio must be between 0 and 1.\")\n\n    <DED><DED>def apply(self, image, holes=(), **params):\n        <IND>return F.cutout(image, holes, self.fill_value)\n\n    <DED>def apply_to_mask(self, image, holes=(), **params):\n        <IND>if self.mask_fill_value is None:\n            <IND>return image\n\n        <DED>return F.cutout(image, holes, self.mask_fill_value)\n\n    <DED>def get_params_dependent_on_targets(self, params):\n        <IND>img = params[\"image\"]\n        height, width = img.shape[:2]\n        # set grid using unit size limits\n        if self.unit_size_min and self.unit_size_max:\n            <IND>if not 2 <= self.unit_size_min <= self.unit_size_max:\n                <IND>raise ValueError(\"Max unit size should be >= min size, both at least 2 pixels.\")\n            <DED>if self.unit_size_max > min(height, width):\n                <IND>raise ValueError(\"Grid size limits must be within the shortest image edge.\")\n            <DED>unit_width = random.randint(self.unit_size_min, self.unit_size_max + 1)\n            unit_height = unit_width\n        <DED>else:\n            # set grid using holes numbers\n            <IND>if self.holes_number_x is None:\n                <IND>unit_width = max(2, width // 10)\n            <DED>else:\n                <IND>if not 1 <= self.holes_number_x <= width // 2:\n                    <IND>raise ValueError(\"The hole_number_x must be between 1 and image width//2.\")\n                <DED>unit_width = width // self.holes_number_x\n            <DED>if self.holes_number_y is None:\n                <IND>unit_height = max(min(unit_width, height), 2)\n            <DED>else:\n                <IND>if not 1 <= self.holes_number_y <= height // 2:\n                    <IND>raise ValueError(\"The hole_number_y must be between 1 and image height//2.\")\n                <DED>unit_height = height // self.holes_number_y\n\n        <DED><DED>hole_width = int(unit_width * self.ratio)\n        hole_height = int(unit_height * self.ratio)\n        # min 1 pixel and max unit length - 1\n        hole_width = min(max(hole_width, 1), unit_width - 1)\n        hole_height = min(max(hole_height, 1), unit_height - 1)\n        # set offset of the grid\n        if self.shift_x is None:\n            <IND>shift_x = 0\n        <DED>else:\n            <IND>shift_x = min(max(0, self.shift_x), unit_width - hole_width)\n        <DED>if self.shift_y is None:\n            <IND>shift_y = 0\n        <DED>else:\n            <IND>shift_y = min(max(0, self.shift_y), unit_height - hole_height)\n        <DED>if self.random_offset:\n            <IND>shift_x = random.randint(0, unit_width - hole_width)\n            shift_y = random.randint(0, unit_height - hole_height)\n        <DED>holes = []\n        for i in range(width // unit_width + 1):\n            <IND>for j in range(height // unit_height + 1):\n                <IND>x1 = min(shift_x + unit_width * i, width)\n                y1 = min(shift_y + unit_height * j, height)\n                x2 = min(x1 + hole_width, width)\n                y2 = min(y1 + hole_height, height)\n                holes.append((x1, y1, x2, y2))\n\n        <DED><DED>return {\"holes\": holes}\n\n    <DED>@property\n    def targets_as_params(self):\n        <IND>return [\"image\"]\n\n    <DED>def get_transform_init_args_names(self):\n        <IND>return (\n            \"ratio\",\n            \"unit_size_min\",\n            \"unit_size_max\",\n            \"holes_number_x\",\n            \"holes_number_y\",\n            \"shift_x\",\n            \"shift_y\",\n            \"mask_fill_value\",\n            \"random_offset\",\n        )\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "        <IND>return [\"image\"]\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  }
]