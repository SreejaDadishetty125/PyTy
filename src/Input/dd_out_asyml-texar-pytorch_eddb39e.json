[
  {
    "project": "asyml/texar-pytorch",
    "commit": "eddb39e91420aa61675cae9bf6479d43432e18ef",
    "filename": "texar/torch/run/condition.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/asyml-texar-pytorch/texar/torch/run/condition.py",
    "file_hunks_size": 8,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": true,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "texar/torch/run/condition.py:284:50 Unsupported operand [58]: `-` is not supported for operand types `float` and `Optional[float]`.",
    "message": " `-` is not supported for operand types `float` and `Optional[float]`.",
    "rule_id": "Unsupported operand [58]",
    "warning_line_no": 284,
    "warning_line": "            self.accumulated_time += time_now() - self.start_time",
    "min_patch": [
      {
        "hunk_fit_TFix": true,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    def check_validation_begin(self, executor) -> bool:\n        if self.only_training:\n            self.accumulated_time += time_now() - self.start_time\n",
        "source_code_len": 153,
        "target_code": "    def check_validation_begin(self, executor) -> bool:\n        if self.only_training and self.start_time is not None:\n            self.accumulated_time += time_now() - self.start_time\n",
        "target_code_len": 185,
        "diff_format": "@@ -282,3 +282,3 @@\n     def check_validation_begin(self, executor) -> bool:\n-        if self.only_training:\n+        if self.only_training and self.start_time is not None:\n             self.accumulated_time += time_now() - self.start_time\n",
        "source_code_with_indent": "    <DED>def check_validation_begin(self, executor) -> bool:\n        <IND>if self.only_training:\n            <IND>self.accumulated_time += time_now() - self.start_time\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    <DED>def check_validation_begin(self, executor) -> bool:\n        <IND>if self.only_training and self.start_time is not None:\n            <IND>self.accumulated_time += time_now() - self.start_time\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "asyml/texar-pytorch",
    "commit": "eddb39e91420aa61675cae9bf6479d43432e18ef",
    "filename": "texar/torch/run/condition.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/asyml-texar-pytorch/texar/torch/run/condition.py",
    "file_hunks_size": 8,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": true,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "texar/torch/run/condition.py:297:50 Unsupported operand [58]: `-` is not supported for operand types `float` and `Optional[float]`.",
    "message": " `-` is not supported for operand types `float` and `Optional[float]`.",
    "rule_id": "Unsupported operand [58]",
    "warning_line_no": 297,
    "warning_line": "            self.accumulated_time += time_now() - self.start_time",
    "min_patch": [
      {
        "hunk_fit_TFix": true,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    def check_testing_begin(self, executor) -> bool:\n        if self.only_training:\n            self.accumulated_time += time_now() - self.start_time\n",
        "source_code_len": 150,
        "target_code": "    def check_testing_begin(self, executor) -> bool:\n        if self.only_training and self.start_time is not None:\n            self.accumulated_time += time_now() - self.start_time\n",
        "target_code_len": 182,
        "diff_format": "@@ -295,3 +295,3 @@\n     def check_testing_begin(self, executor) -> bool:\n-        if self.only_training:\n+        if self.only_training and self.start_time is not None:\n             self.accumulated_time += time_now() - self.start_time\n",
        "source_code_with_indent": "    <DED><DED>def check_testing_begin(self, executor) -> bool:\n        <IND>if self.only_training:\n            <IND>self.accumulated_time += time_now() - self.start_time\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    <DED><DED>def check_testing_begin(self, executor) -> bool:\n        <IND>if self.only_training and self.start_time is not None:\n            <IND>self.accumulated_time += time_now() - self.start_time\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "asyml/texar-pytorch",
    "commit": "eddb39e91420aa61675cae9bf6479d43432e18ef",
    "filename": "texar/torch/run/executor.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/asyml-texar-pytorch/texar/torch/run/executor.py",
    "file_hunks_size": 30,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "texar/torch/run/executor.py:144:17 Incompatible parameter type [6]: Expected `Union[os.PathLike[bytes], os.PathLike[str], bytes, int, str]` for 1st positional only parameter to call `open` but got `IO[str]`.",
    "message": " Expected `Union[os.PathLike[bytes], os.PathLike[str], bytes, int, str]` for 1st positional only parameter to call `open` but got `IO[str]`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 144,
    "warning_line": "            open(dest, \"w+\") if isinstance(dest, str) else dest",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "        self._log_conditions = utils.to_list(log_every)\n        self.log_format: str\n        self.log_destination: List[IO[str]]\n        self.print_configs_to_log = print_configs_to_log\n        self.eval_log_format: str\n\n        for attr, default in self._defaults.items():\n            value = locals()[attr]\n            if value is None:\n                value = default\n            setattr(self, attr, value)\n\n        # TODO: Close files somewhere? Maybe `atexit.register`?\n        self.log_destination = [\n            open(dest, \"w+\") if isinstance(dest, str) else dest\n            for dest in utils.to_list(self.log_destination)]\n\n        # Checkpoint management\n        self.checkpoint_dir = Path(checkpoint_dir)\n        self.max_to_keep = max_to_keep\n",
        "source_code_len": 756,
        "target_code": "        self._log_conditions = utils.to_list(log_every)\n        self.print_configs_to_log = print_configs_to_log\n\n        self.log_format: str = log_format or self._defaults[\"log_format\"]\n        self.eval_log_format: str = (\n                eval_log_format or self._defaults[\"eval_log_format\"])\n\n        # Checkpoint management\n        self.checkpoint_dir = (Path(checkpoint_dir)\n                               if checkpoint_dir is not None else None)\n        self.max_to_keep = max_to_keep\n",
        "target_code_len": 492,
        "diff_format": "@@ -130,20 +132,11 @@\n         self._log_conditions = utils.to_list(log_every)\n-        self.log_format: str\n-        self.log_destination: List[IO[str]]\n         self.print_configs_to_log = print_configs_to_log\n-        self.eval_log_format: str\n-\n-        for attr, default in self._defaults.items():\n-            value = locals()[attr]\n-            if value is None:\n-                value = default\n-            setattr(self, attr, value)\n-\n-        # TODO: Close files somewhere? Maybe `atexit.register`?\n-        self.log_destination = [\n-            open(dest, \"w+\") if isinstance(dest, str) else dest\n-            for dest in utils.to_list(self.log_destination)]\n+\n+        self.log_format: str = log_format or self._defaults[\"log_format\"]\n+        self.eval_log_format: str = (\n+                eval_log_format or self._defaults[\"eval_log_format\"])\n \n         # Checkpoint management\n-        self.checkpoint_dir = Path(checkpoint_dir)\n+        self.checkpoint_dir = (Path(checkpoint_dir)\n+                               if checkpoint_dir is not None else None)\n         self.max_to_keep = max_to_keep\n",
        "source_code_with_indent": "        self._log_conditions = utils.to_list(log_every)\n        self.log_format: str\n        self.log_destination: List[IO[str]]\n        self.print_configs_to_log = print_configs_to_log\n        self.eval_log_format: str\n\n        for attr, default in self._defaults.items():\n            <IND>value = locals()[attr]\n            if value is None:\n                <IND>value = default\n            <DED>setattr(self, attr, value)\n\n        # TODO: Close files somewhere? Maybe `atexit.register`?\n        <DED>self.log_destination = [\n            open(dest, \"w+\") if isinstance(dest, str) else dest\n            for dest in utils.to_list(self.log_destination)]\n\n        # Checkpoint management\n        self.checkpoint_dir = Path(checkpoint_dir)\n        self.max_to_keep = max_to_keep\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "        self._log_conditions = utils.to_list(log_every)\n        self.print_configs_to_log = print_configs_to_log\n\n        self.log_format: str = log_format or self._defaults[\"log_format\"]\n        self.eval_log_format: str = (\n                eval_log_format or self._defaults[\"eval_log_format\"])\n\n        # Checkpoint management\n        self.checkpoint_dir = (Path(checkpoint_dir)\n                               if checkpoint_dir is not None else None)\n        self.max_to_keep = max_to_keep\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": true,
        "source_code": "\n        if not self.checkpoint_dir.exists():\n            self.checkpoint_dir.mkdir(parents=True)\n        else:\n            self.write_log(\n",
        "source_code_len": 140,
        "target_code": "\n        directory_exists = False\n        if self.checkpoint_dir is not None:\n            if not self.checkpoint_dir.exists():\n                self.checkpoint_dir.mkdir(parents=True)\n            else:\n                directory_exists = False\n\n        # TODO: Close files somewhere? Maybe `atexit.register`?\n        # Create logging files after checkpoint directory is created.\n        self.log_destination: List[IO[str]] = [\n            open(dest, \"w+\") if isinstance(dest, str) else dest  # type: ignore\n            for dest in utils.to_list(  # type: ignore\n                log_destination or self._defaults[\"log_destination\"])]\n\n        if directory_exists:\n            self.write_log(\n",
        "target_code_len": 689,
        "diff_format": "@@ -152,5 +145,17 @@\n \n-        if not self.checkpoint_dir.exists():\n-            self.checkpoint_dir.mkdir(parents=True)\n-        else:\n+        directory_exists = False\n+        if self.checkpoint_dir is not None:\n+            if not self.checkpoint_dir.exists():\n+                self.checkpoint_dir.mkdir(parents=True)\n+            else:\n+                directory_exists = False\n+\n+        # TODO: Close files somewhere? Maybe `atexit.register`?\n+        # Create logging files after checkpoint directory is created.\n+        self.log_destination: List[IO[str]] = [\n+            open(dest, \"w+\") if isinstance(dest, str) else dest  # type: ignore\n+            for dest in utils.to_list(  # type: ignore\n+                log_destination or self._defaults[\"log_destination\"])]\n+\n+        if directory_exists:\n             self.write_log(\n",
        "source_code_with_indent": "\n        if not self.checkpoint_dir.exists():\n            <IND>self.checkpoint_dir.mkdir(parents=True)\n        <DED>else:\n            <IND>self.write_log(\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n        directory_exists = False\n        if self.checkpoint_dir is not None:\n            <IND>if not self.checkpoint_dir.exists():\n                <IND>self.checkpoint_dir.mkdir(parents=True)\n            <DED>else:\n                <IND>directory_exists = False\n\n        # TODO: Close files somewhere? Maybe `atexit.register`?\n        # Create logging files after checkpoint directory is created.\n        <DED><DED>self.log_destination: List[IO[str]] = [\n            open(dest, \"w+\") if isinstance(dest, str) else dest  # type: ignore\n            for dest in utils.to_list(  # type: ignore\n                log_destination or self._defaults[\"log_destination\"])]\n\n        if directory_exists:\n            <IND>self.write_log(\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "asyml/texar-pytorch",
    "commit": "eddb39e91420aa61675cae9bf6479d43432e18ef",
    "filename": "texar/torch/run/executor.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/asyml-texar-pytorch/texar/torch/run/executor.py",
    "file_hunks_size": 30,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "texar/torch/run/executor.py:148:35 Incompatible parameter type [6]: Expected `Union[os.PathLike[str], str]` for 1st positional only parameter to call `Path.__new__` but got `Optional[str]`.",
    "message": " Expected `Union[os.PathLike[str], str]` for 1st positional only parameter to call `Path.__new__` but got `Optional[str]`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 148,
    "warning_line": "        self.checkpoint_dir = Path(checkpoint_dir)",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "        self._log_conditions = utils.to_list(log_every)\n        self.log_format: str\n        self.log_destination: List[IO[str]]\n        self.print_configs_to_log = print_configs_to_log\n        self.eval_log_format: str\n\n        for attr, default in self._defaults.items():\n            value = locals()[attr]\n            if value is None:\n                value = default\n            setattr(self, attr, value)\n\n        # TODO: Close files somewhere? Maybe `atexit.register`?\n        self.log_destination = [\n            open(dest, \"w+\") if isinstance(dest, str) else dest\n            for dest in utils.to_list(self.log_destination)]\n\n        # Checkpoint management\n        self.checkpoint_dir = Path(checkpoint_dir)\n        self.max_to_keep = max_to_keep\n",
        "source_code_len": 756,
        "target_code": "        self._log_conditions = utils.to_list(log_every)\n        self.print_configs_to_log = print_configs_to_log\n\n        self.log_format: str = log_format or self._defaults[\"log_format\"]\n        self.eval_log_format: str = (\n                eval_log_format or self._defaults[\"eval_log_format\"])\n\n        # Checkpoint management\n        self.checkpoint_dir = (Path(checkpoint_dir)\n                               if checkpoint_dir is not None else None)\n        self.max_to_keep = max_to_keep\n",
        "target_code_len": 492,
        "diff_format": "@@ -130,20 +132,11 @@\n         self._log_conditions = utils.to_list(log_every)\n-        self.log_format: str\n-        self.log_destination: List[IO[str]]\n         self.print_configs_to_log = print_configs_to_log\n-        self.eval_log_format: str\n-\n-        for attr, default in self._defaults.items():\n-            value = locals()[attr]\n-            if value is None:\n-                value = default\n-            setattr(self, attr, value)\n-\n-        # TODO: Close files somewhere? Maybe `atexit.register`?\n-        self.log_destination = [\n-            open(dest, \"w+\") if isinstance(dest, str) else dest\n-            for dest in utils.to_list(self.log_destination)]\n+\n+        self.log_format: str = log_format or self._defaults[\"log_format\"]\n+        self.eval_log_format: str = (\n+                eval_log_format or self._defaults[\"eval_log_format\"])\n \n         # Checkpoint management\n-        self.checkpoint_dir = Path(checkpoint_dir)\n+        self.checkpoint_dir = (Path(checkpoint_dir)\n+                               if checkpoint_dir is not None else None)\n         self.max_to_keep = max_to_keep\n",
        "source_code_with_indent": "        self._log_conditions = utils.to_list(log_every)\n        self.log_format: str\n        self.log_destination: List[IO[str]]\n        self.print_configs_to_log = print_configs_to_log\n        self.eval_log_format: str\n\n        for attr, default in self._defaults.items():\n            <IND>value = locals()[attr]\n            if value is None:\n                <IND>value = default\n            <DED>setattr(self, attr, value)\n\n        # TODO: Close files somewhere? Maybe `atexit.register`?\n        <DED>self.log_destination = [\n            open(dest, \"w+\") if isinstance(dest, str) else dest\n            for dest in utils.to_list(self.log_destination)]\n\n        # Checkpoint management\n        self.checkpoint_dir = Path(checkpoint_dir)\n        self.max_to_keep = max_to_keep\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "        self._log_conditions = utils.to_list(log_every)\n        self.print_configs_to_log = print_configs_to_log\n\n        self.log_format: str = log_format or self._defaults[\"log_format\"]\n        self.eval_log_format: str = (\n                eval_log_format or self._defaults[\"eval_log_format\"])\n\n        # Checkpoint management\n        self.checkpoint_dir = (Path(checkpoint_dir)\n                               if checkpoint_dir is not None else None)\n        self.max_to_keep = max_to_keep\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": true,
        "source_code": "\n        if not self.checkpoint_dir.exists():\n            self.checkpoint_dir.mkdir(parents=True)\n        else:\n            self.write_log(\n",
        "source_code_len": 140,
        "target_code": "\n        directory_exists = False\n        if self.checkpoint_dir is not None:\n            if not self.checkpoint_dir.exists():\n                self.checkpoint_dir.mkdir(parents=True)\n            else:\n                directory_exists = False\n\n        # TODO: Close files somewhere? Maybe `atexit.register`?\n        # Create logging files after checkpoint directory is created.\n        self.log_destination: List[IO[str]] = [\n            open(dest, \"w+\") if isinstance(dest, str) else dest  # type: ignore\n            for dest in utils.to_list(  # type: ignore\n                log_destination or self._defaults[\"log_destination\"])]\n\n        if directory_exists:\n            self.write_log(\n",
        "target_code_len": 689,
        "diff_format": "@@ -152,5 +145,17 @@\n \n-        if not self.checkpoint_dir.exists():\n-            self.checkpoint_dir.mkdir(parents=True)\n-        else:\n+        directory_exists = False\n+        if self.checkpoint_dir is not None:\n+            if not self.checkpoint_dir.exists():\n+                self.checkpoint_dir.mkdir(parents=True)\n+            else:\n+                directory_exists = False\n+\n+        # TODO: Close files somewhere? Maybe `atexit.register`?\n+        # Create logging files after checkpoint directory is created.\n+        self.log_destination: List[IO[str]] = [\n+            open(dest, \"w+\") if isinstance(dest, str) else dest  # type: ignore\n+            for dest in utils.to_list(  # type: ignore\n+                log_destination or self._defaults[\"log_destination\"])]\n+\n+        if directory_exists:\n             self.write_log(\n",
        "source_code_with_indent": "\n        if not self.checkpoint_dir.exists():\n            <IND>self.checkpoint_dir.mkdir(parents=True)\n        <DED>else:\n            <IND>self.write_log(\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n        directory_exists = False\n        if self.checkpoint_dir is not None:\n            <IND>if not self.checkpoint_dir.exists():\n                <IND>self.checkpoint_dir.mkdir(parents=True)\n            <DED>else:\n                <IND>directory_exists = False\n\n        # TODO: Close files somewhere? Maybe `atexit.register`?\n        # Create logging files after checkpoint directory is created.\n        <DED><DED>self.log_destination: List[IO[str]] = [\n            open(dest, \"w+\") if isinstance(dest, str) else dest  # type: ignore\n            for dest in utils.to_list(  # type: ignore\n                log_destination or self._defaults[\"log_destination\"])]\n\n        if directory_exists:\n            <IND>self.write_log(\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "asyml/texar-pytorch",
    "commit": "eddb39e91420aa61675cae9bf6479d43432e18ef",
    "filename": "texar/torch/run/executor.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/asyml-texar-pytorch/texar/torch/run/executor.py",
    "file_hunks_size": 30,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": true,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "texar/torch/run/executor.py:301:30 Incompatible parameter type [6]: Expected `typing_extensions.Literal['epoch']` for 1st positional only parameter to call `TypedDictionary.__getitem__` but got `Union[typing_extensions.Literal['eval_metric'], typing_extensions.Literal['metric']]`.",
    "message": " Expected `typing_extensions.Literal['epoch']` for 1st positional only parameter to call `TypedDictionary.__getitem__` but got `Union[typing_extensions.Literal['eval_metric'], typing_extensions.Literal['metric']]`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 301,
    "warning_line": "        metrics = self.status[\"eval_metric\" if eval_mode else \"metric\"]",
    "min_patch": [
      {
        "hunk_fit_TFix": true,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "        # Set metric print formats for aggregated format variable.\n        metrics = self.status[\"eval_metric\" if eval_mode else \"metric\"]\n        if \"metric\" in format_vars and format_vars[\"metric\"] is not None:\n",
        "source_code_len": 213,
        "target_code": "        # Set metric print formats for aggregated format variable.\n        metrics = (self.status[\"eval_metric\"]\n                   if eval_mode else self.status[\"metric\"])\n        if \"metric\" in format_vars and format_vars[\"metric\"] is not None:\n",
        "target_code_len": 247,
        "diff_format": "@@ -300,3 +304,4 @@\n         # Set metric print formats for aggregated format variable.\n-        metrics = self.status[\"eval_metric\" if eval_mode else \"metric\"]\n+        metrics = (self.status[\"eval_metric\"]\n+                   if eval_mode else self.status[\"metric\"])\n         if \"metric\" in format_vars and format_vars[\"metric\"] is not None:\n",
        "source_code_with_indent": "        # Set metric print formats for aggregated format variable.\n        <DED>metrics = self.status[\"eval_metric\" if eval_mode else \"metric\"]\n        if \"metric\" in format_vars and format_vars[\"metric\"] is not None:\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "        # Set metric print formats for aggregated format variable.\n        <DED>metrics = (self.status[\"eval_metric\"]\n                   if eval_mode else self.status[\"metric\"])\n        if \"metric\" in format_vars and format_vars[\"metric\"] is not None:\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "asyml/texar-pytorch",
    "commit": "eddb39e91420aa61675cae9bf6479d43432e18ef",
    "filename": "texar/torch/run/executor.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/asyml-texar-pytorch/texar/torch/run/executor.py",
    "file_hunks_size": 30,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "texar/torch/run/executor.py:327:17 Unsupported operand [58]: `in` is not supported for right operand type `int`.",
    "message": " `in` is not supported for right operand type `int`.",
    "rule_id": "Unsupported operand [58]",
    "warning_line_no": 327,
    "warning_line": "            elif name in metrics:",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "        # Set metric print formats for aggregated format variable.\n        metrics = self.status[\"eval_metric\" if eval_mode else \"metric\"]\n        if \"metric\" in format_vars and format_vars[\"metric\"] is not None:\n",
        "source_code_len": 213,
        "target_code": "        # Set metric print formats for aggregated format variable.\n        metrics = (self.status[\"eval_metric\"]\n                   if eval_mode else self.status[\"metric\"])\n        if \"metric\" in format_vars and format_vars[\"metric\"] is not None:\n",
        "target_code_len": 247,
        "diff_format": "@@ -300,3 +304,4 @@\n         # Set metric print formats for aggregated format variable.\n-        metrics = self.status[\"eval_metric\" if eval_mode else \"metric\"]\n+        metrics = (self.status[\"eval_metric\"]\n+                   if eval_mode else self.status[\"metric\"])\n         if \"metric\" in format_vars and format_vars[\"metric\"] is not None:\n",
        "source_code_with_indent": "        # Set metric print formats for aggregated format variable.\n        <DED>metrics = self.status[\"eval_metric\" if eval_mode else \"metric\"]\n        if \"metric\" in format_vars and format_vars[\"metric\"] is not None:\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "        # Set metric print formats for aggregated format variable.\n        <DED>metrics = (self.status[\"eval_metric\"]\n                   if eval_mode else self.status[\"metric\"])\n        if \"metric\" in format_vars and format_vars[\"metric\"] is not None:\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "asyml/texar-pytorch",
    "commit": "eddb39e91420aa61675cae9bf6479d43432e18ef",
    "filename": "texar/torch/run/executor.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/asyml-texar-pytorch/texar/torch/run/executor.py",
    "file_hunks_size": 30,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "texar/torch/run/executor.py:530:8 Incompatible variable type [9]: path is declared to have type `Optional[str]` but is used as type `Path`.",
    "message": " path is declared to have type `Optional[str]` but is used as type `Path`.",
    "rule_id": "Incompatible variable type [9]",
    "warning_line_no": 530,
    "warning_line": "        path = self.checkpoint_dir if path is None else Path(path)",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "        self._log_conditions = utils.to_list(log_every)\n        self.log_format: str\n        self.log_destination: List[IO[str]]\n        self.print_configs_to_log = print_configs_to_log\n        self.eval_log_format: str\n\n        for attr, default in self._defaults.items():\n            value = locals()[attr]\n            if value is None:\n                value = default\n            setattr(self, attr, value)\n\n        # TODO: Close files somewhere? Maybe `atexit.register`?\n        self.log_destination = [\n            open(dest, \"w+\") if isinstance(dest, str) else dest\n            for dest in utils.to_list(self.log_destination)]\n\n        # Checkpoint management\n        self.checkpoint_dir = Path(checkpoint_dir)\n        self.max_to_keep = max_to_keep\n",
        "source_code_len": 756,
        "target_code": "        self._log_conditions = utils.to_list(log_every)\n        self.print_configs_to_log = print_configs_to_log\n\n        self.log_format: str = log_format or self._defaults[\"log_format\"]\n        self.eval_log_format: str = (\n                eval_log_format or self._defaults[\"eval_log_format\"])\n\n        # Checkpoint management\n        self.checkpoint_dir = (Path(checkpoint_dir)\n                               if checkpoint_dir is not None else None)\n        self.max_to_keep = max_to_keep\n",
        "target_code_len": 492,
        "diff_format": "@@ -130,20 +132,11 @@\n         self._log_conditions = utils.to_list(log_every)\n-        self.log_format: str\n-        self.log_destination: List[IO[str]]\n         self.print_configs_to_log = print_configs_to_log\n-        self.eval_log_format: str\n-\n-        for attr, default in self._defaults.items():\n-            value = locals()[attr]\n-            if value is None:\n-                value = default\n-            setattr(self, attr, value)\n-\n-        # TODO: Close files somewhere? Maybe `atexit.register`?\n-        self.log_destination = [\n-            open(dest, \"w+\") if isinstance(dest, str) else dest\n-            for dest in utils.to_list(self.log_destination)]\n+\n+        self.log_format: str = log_format or self._defaults[\"log_format\"]\n+        self.eval_log_format: str = (\n+                eval_log_format or self._defaults[\"eval_log_format\"])\n \n         # Checkpoint management\n-        self.checkpoint_dir = Path(checkpoint_dir)\n+        self.checkpoint_dir = (Path(checkpoint_dir)\n+                               if checkpoint_dir is not None else None)\n         self.max_to_keep = max_to_keep\n",
        "source_code_with_indent": "        self._log_conditions = utils.to_list(log_every)\n        self.log_format: str\n        self.log_destination: List[IO[str]]\n        self.print_configs_to_log = print_configs_to_log\n        self.eval_log_format: str\n\n        for attr, default in self._defaults.items():\n            <IND>value = locals()[attr]\n            if value is None:\n                <IND>value = default\n            <DED>setattr(self, attr, value)\n\n        # TODO: Close files somewhere? Maybe `atexit.register`?\n        <DED>self.log_destination = [\n            open(dest, \"w+\") if isinstance(dest, str) else dest\n            for dest in utils.to_list(self.log_destination)]\n\n        # Checkpoint management\n        self.checkpoint_dir = Path(checkpoint_dir)\n        self.max_to_keep = max_to_keep\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "        self._log_conditions = utils.to_list(log_every)\n        self.print_configs_to_log = print_configs_to_log\n\n        self.log_format: str = log_format or self._defaults[\"log_format\"]\n        self.eval_log_format: str = (\n                eval_log_format or self._defaults[\"eval_log_format\"])\n\n        # Checkpoint management\n        self.checkpoint_dir = (Path(checkpoint_dir)\n                               if checkpoint_dir is not None else None)\n        self.max_to_keep = max_to_keep\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": true,
        "source_code": "\n        if not self.checkpoint_dir.exists():\n            self.checkpoint_dir.mkdir(parents=True)\n        else:\n            self.write_log(\n",
        "source_code_len": 140,
        "target_code": "\n        directory_exists = False\n        if self.checkpoint_dir is not None:\n            if not self.checkpoint_dir.exists():\n                self.checkpoint_dir.mkdir(parents=True)\n            else:\n                directory_exists = False\n\n        # TODO: Close files somewhere? Maybe `atexit.register`?\n        # Create logging files after checkpoint directory is created.\n        self.log_destination: List[IO[str]] = [\n            open(dest, \"w+\") if isinstance(dest, str) else dest  # type: ignore\n            for dest in utils.to_list(  # type: ignore\n                log_destination or self._defaults[\"log_destination\"])]\n\n        if directory_exists:\n            self.write_log(\n",
        "target_code_len": 689,
        "diff_format": "@@ -152,5 +145,17 @@\n \n-        if not self.checkpoint_dir.exists():\n-            self.checkpoint_dir.mkdir(parents=True)\n-        else:\n+        directory_exists = False\n+        if self.checkpoint_dir is not None:\n+            if not self.checkpoint_dir.exists():\n+                self.checkpoint_dir.mkdir(parents=True)\n+            else:\n+                directory_exists = False\n+\n+        # TODO: Close files somewhere? Maybe `atexit.register`?\n+        # Create logging files after checkpoint directory is created.\n+        self.log_destination: List[IO[str]] = [\n+            open(dest, \"w+\") if isinstance(dest, str) else dest  # type: ignore\n+            for dest in utils.to_list(  # type: ignore\n+                log_destination or self._defaults[\"log_destination\"])]\n+\n+        if directory_exists:\n             self.write_log(\n",
        "source_code_with_indent": "\n        if not self.checkpoint_dir.exists():\n            <IND>self.checkpoint_dir.mkdir(parents=True)\n        <DED>else:\n            <IND>self.write_log(\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n        directory_exists = False\n        if self.checkpoint_dir is not None:\n            <IND>if not self.checkpoint_dir.exists():\n                <IND>self.checkpoint_dir.mkdir(parents=True)\n            <DED>else:\n                <IND>directory_exists = False\n\n        # TODO: Close files somewhere? Maybe `atexit.register`?\n        # Create logging files after checkpoint directory is created.\n        <DED><DED>self.log_destination: List[IO[str]] = [\n            open(dest, \"w+\") if isinstance(dest, str) else dest  # type: ignore\n            for dest in utils.to_list(  # type: ignore\n                log_destination or self._defaults[\"log_destination\"])]\n\n        if directory_exists:\n            <IND>self.write_log(\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "asyml/texar-pytorch",
    "commit": "eddb39e91420aa61675cae9bf6479d43432e18ef",
    "filename": "texar/torch/run/executor.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/asyml-texar-pytorch/texar/torch/run/executor.py",
    "file_hunks_size": 30,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "texar/torch/run/executor.py:541:16 Incompatible variable type [9]: path is declared to have type `Optional[str]` but is used as type `Path`.",
    "message": " path is declared to have type `Optional[str]` but is used as type `Path`.",
    "rule_id": "Incompatible variable type [9]",
    "warning_line_no": 541,
    "warning_line": "                path = self.checkpoint_dir / best_ckpt_name",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "        self._log_conditions = utils.to_list(log_every)\n        self.log_format: str\n        self.log_destination: List[IO[str]]\n        self.print_configs_to_log = print_configs_to_log\n        self.eval_log_format: str\n\n        for attr, default in self._defaults.items():\n            value = locals()[attr]\n            if value is None:\n                value = default\n            setattr(self, attr, value)\n\n        # TODO: Close files somewhere? Maybe `atexit.register`?\n        self.log_destination = [\n            open(dest, \"w+\") if isinstance(dest, str) else dest\n            for dest in utils.to_list(self.log_destination)]\n\n        # Checkpoint management\n        self.checkpoint_dir = Path(checkpoint_dir)\n        self.max_to_keep = max_to_keep\n",
        "source_code_len": 756,
        "target_code": "        self._log_conditions = utils.to_list(log_every)\n        self.print_configs_to_log = print_configs_to_log\n\n        self.log_format: str = log_format or self._defaults[\"log_format\"]\n        self.eval_log_format: str = (\n                eval_log_format or self._defaults[\"eval_log_format\"])\n\n        # Checkpoint management\n        self.checkpoint_dir = (Path(checkpoint_dir)\n                               if checkpoint_dir is not None else None)\n        self.max_to_keep = max_to_keep\n",
        "target_code_len": 492,
        "diff_format": "@@ -130,20 +132,11 @@\n         self._log_conditions = utils.to_list(log_every)\n-        self.log_format: str\n-        self.log_destination: List[IO[str]]\n         self.print_configs_to_log = print_configs_to_log\n-        self.eval_log_format: str\n-\n-        for attr, default in self._defaults.items():\n-            value = locals()[attr]\n-            if value is None:\n-                value = default\n-            setattr(self, attr, value)\n-\n-        # TODO: Close files somewhere? Maybe `atexit.register`?\n-        self.log_destination = [\n-            open(dest, \"w+\") if isinstance(dest, str) else dest\n-            for dest in utils.to_list(self.log_destination)]\n+\n+        self.log_format: str = log_format or self._defaults[\"log_format\"]\n+        self.eval_log_format: str = (\n+                eval_log_format or self._defaults[\"eval_log_format\"])\n \n         # Checkpoint management\n-        self.checkpoint_dir = Path(checkpoint_dir)\n+        self.checkpoint_dir = (Path(checkpoint_dir)\n+                               if checkpoint_dir is not None else None)\n         self.max_to_keep = max_to_keep\n",
        "source_code_with_indent": "        self._log_conditions = utils.to_list(log_every)\n        self.log_format: str\n        self.log_destination: List[IO[str]]\n        self.print_configs_to_log = print_configs_to_log\n        self.eval_log_format: str\n\n        for attr, default in self._defaults.items():\n            <IND>value = locals()[attr]\n            if value is None:\n                <IND>value = default\n            <DED>setattr(self, attr, value)\n\n        # TODO: Close files somewhere? Maybe `atexit.register`?\n        <DED>self.log_destination = [\n            open(dest, \"w+\") if isinstance(dest, str) else dest\n            for dest in utils.to_list(self.log_destination)]\n\n        # Checkpoint management\n        self.checkpoint_dir = Path(checkpoint_dir)\n        self.max_to_keep = max_to_keep\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "        self._log_conditions = utils.to_list(log_every)\n        self.print_configs_to_log = print_configs_to_log\n\n        self.log_format: str = log_format or self._defaults[\"log_format\"]\n        self.eval_log_format: str = (\n                eval_log_format or self._defaults[\"eval_log_format\"])\n\n        # Checkpoint management\n        self.checkpoint_dir = (Path(checkpoint_dir)\n                               if checkpoint_dir is not None else None)\n        self.max_to_keep = max_to_keep\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": true,
        "source_code": "\n        if not self.checkpoint_dir.exists():\n            self.checkpoint_dir.mkdir(parents=True)\n        else:\n            self.write_log(\n",
        "source_code_len": 140,
        "target_code": "\n        directory_exists = False\n        if self.checkpoint_dir is not None:\n            if not self.checkpoint_dir.exists():\n                self.checkpoint_dir.mkdir(parents=True)\n            else:\n                directory_exists = False\n\n        # TODO: Close files somewhere? Maybe `atexit.register`?\n        # Create logging files after checkpoint directory is created.\n        self.log_destination: List[IO[str]] = [\n            open(dest, \"w+\") if isinstance(dest, str) else dest  # type: ignore\n            for dest in utils.to_list(  # type: ignore\n                log_destination or self._defaults[\"log_destination\"])]\n\n        if directory_exists:\n            self.write_log(\n",
        "target_code_len": 689,
        "diff_format": "@@ -152,5 +145,17 @@\n \n-        if not self.checkpoint_dir.exists():\n-            self.checkpoint_dir.mkdir(parents=True)\n-        else:\n+        directory_exists = False\n+        if self.checkpoint_dir is not None:\n+            if not self.checkpoint_dir.exists():\n+                self.checkpoint_dir.mkdir(parents=True)\n+            else:\n+                directory_exists = False\n+\n+        # TODO: Close files somewhere? Maybe `atexit.register`?\n+        # Create logging files after checkpoint directory is created.\n+        self.log_destination: List[IO[str]] = [\n+            open(dest, \"w+\") if isinstance(dest, str) else dest  # type: ignore\n+            for dest in utils.to_list(  # type: ignore\n+                log_destination or self._defaults[\"log_destination\"])]\n+\n+        if directory_exists:\n             self.write_log(\n",
        "source_code_with_indent": "\n        if not self.checkpoint_dir.exists():\n            <IND>self.checkpoint_dir.mkdir(parents=True)\n        <DED>else:\n            <IND>self.write_log(\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n        directory_exists = False\n        if self.checkpoint_dir is not None:\n            <IND>if not self.checkpoint_dir.exists():\n                <IND>self.checkpoint_dir.mkdir(parents=True)\n            <DED>else:\n                <IND>directory_exists = False\n\n        # TODO: Close files somewhere? Maybe `atexit.register`?\n        # Create logging files after checkpoint directory is created.\n        <DED><DED>self.log_destination: List[IO[str]] = [\n            open(dest, \"w+\") if isinstance(dest, str) else dest  # type: ignore\n            for dest in utils.to_list(  # type: ignore\n                log_destination or self._defaults[\"log_destination\"])]\n\n        if directory_exists:\n            <IND>self.write_log(\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "asyml/texar-pytorch",
    "commit": "eddb39e91420aa61675cae9bf6479d43432e18ef",
    "filename": "texar/torch/run/metric/base_metric.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/asyml-texar-pytorch/texar/torch/run/metric/base_metric.py",
    "file_hunks_size": 3,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": true,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "texar/torch/run/metric/base_metric.py:37:8 Incompatible return type [7]: Expected `str` but got `Optional[str]`.",
    "message": " Expected `str` but got `Optional[str]`.",
    "rule_id": "Incompatible return type [7]",
    "warning_line_no": 37,
    "warning_line": "        return self._label_name",
    "min_patch": [
      {
        "hunk_fit_TFix": true,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    @property\n    def label_name(self) -> str:\n        return self._label_name\n",
        "source_code_len": 79,
        "target_code": "    @property\n    def label_name(self) -> Optional[str]:\n        return self._label_name\n",
        "target_code_len": 89,
        "diff_format": "@@ -35,3 +35,3 @@\n     @property\n-    def label_name(self) -> str:\n+    def label_name(self) -> Optional[str]:\n         return self._label_name\n",
        "source_code_with_indent": "    <DED>@property\n    def label_name(self) -> str:\n        <IND>return self._label_name\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    <DED>@property\n    def label_name(self) -> Optional[str]:\n        <IND>return self._label_name\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "asyml/texar-pytorch",
    "commit": "eddb39e91420aa61675cae9bf6479d43432e18ef",
    "filename": "texar/torch/run/metric/base_metric.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/asyml-texar-pytorch/texar/torch/run/metric/base_metric.py",
    "file_hunks_size": 3,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": true,
    "full_warning_msg": "texar/torch/run/metric/base_metric.py:52:25 Unsupported operand [58]: `>` is not supported for operand types `Variable[Value]` and `Variable[Value]`.",
    "message": " `>` is not supported for operand types `Variable[Value]` and `Variable[Value]`.",
    "rule_id": "Unsupported operand [58]",
    "warning_line_no": 52,
    "warning_line": "        result = True if cur > prev else False if cur < prev else None",
    "min_patch": [
      {
        "hunk_fit_TFix": true,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": true,
        "source_code": "    def better(self, cur: Value, prev: Value) -> Optional[bool]:\n        result = True if cur > prev else False if cur < prev else None\n        if not self.higher_is_better and result is not None:\n",
        "source_code_len": 197,
        "target_code": "    def better(self, cur: Value, prev: Value) -> Optional[bool]:\n        result = (True if cur > prev else  # type: ignore\n                  False if cur < prev else None)  # type: ignore\n        if not self.higher_is_better and result is not None:\n",
        "target_code_len": 249,
        "diff_format": "@@ -51,3 +51,4 @@\n     def better(self, cur: Value, prev: Value) -> Optional[bool]:\n-        result = True if cur > prev else False if cur < prev else None\n+        result = (True if cur > prev else  # type: ignore\n+                  False if cur < prev else None)  # type: ignore\n         if not self.higher_is_better and result is not None:\n",
        "source_code_with_indent": "    <DED>def better(self, cur: Value, prev: Value) -> Optional[bool]:\n        <IND>result = True if cur > prev else False if cur < prev else None\n        if not self.higher_is_better and result is not None:\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    <DED>def better(self, cur: Value, prev: Value) -> Optional[bool]:\n        <IND>result = (True if cur > prev else  # type: ignore\n                  False if cur < prev else None)  # type: ignore\n        if not self.higher_is_better and result is not None:\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "asyml/texar-pytorch",
    "commit": "eddb39e91420aa61675cae9bf6479d43432e18ef",
    "filename": "texar/torch/run/metric/base_metric.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/asyml-texar-pytorch/texar/torch/run/metric/base_metric.py",
    "file_hunks_size": 3,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": true,
    "full_warning_msg": "texar/torch/run/metric/base_metric.py:52:50 Unsupported operand [58]: `<` is not supported for operand types `Variable[Value]` and `Variable[Value]`.",
    "message": " `<` is not supported for operand types `Variable[Value]` and `Variable[Value]`.",
    "rule_id": "Unsupported operand [58]",
    "warning_line_no": 52,
    "warning_line": "        result = True if cur > prev else False if cur < prev else None",
    "min_patch": [
      {
        "hunk_fit_TFix": true,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": true,
        "source_code": "    def better(self, cur: Value, prev: Value) -> Optional[bool]:\n        result = True if cur > prev else False if cur < prev else None\n        if not self.higher_is_better and result is not None:\n",
        "source_code_len": 197,
        "target_code": "    def better(self, cur: Value, prev: Value) -> Optional[bool]:\n        result = (True if cur > prev else  # type: ignore\n                  False if cur < prev else None)  # type: ignore\n        if not self.higher_is_better and result is not None:\n",
        "target_code_len": 249,
        "diff_format": "@@ -51,3 +51,4 @@\n     def better(self, cur: Value, prev: Value) -> Optional[bool]:\n-        result = True if cur > prev else False if cur < prev else None\n+        result = (True if cur > prev else  # type: ignore\n+                  False if cur < prev else None)  # type: ignore\n         if not self.higher_is_better and result is not None:\n",
        "source_code_with_indent": "    <DED>def better(self, cur: Value, prev: Value) -> Optional[bool]:\n        <IND>result = True if cur > prev else False if cur < prev else None\n        if not self.higher_is_better and result is not None:\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    <DED>def better(self, cur: Value, prev: Value) -> Optional[bool]:\n        <IND>result = (True if cur > prev else  # type: ignore\n                  False if cur < prev else None)  # type: ignore\n        if not self.higher_is_better and result is not None:\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  }
]