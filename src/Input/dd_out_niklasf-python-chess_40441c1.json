[
  {
    "project": "niklasf/python-chess",
    "commit": "40441c1eb3093c25644fd2f25f5151a14636d432",
    "filename": "chess/engine.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/niklasf-python-chess/chess/engine.py",
    "file_hunks_size": 13,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "chess/engine.py:684:50 Incompatible parameter type [6]: Expected `int` for 2nd positional only parameter to call `BaseCommand._engine_terminated` but got `Optional[int]`.",
    "message": " Expected `int` for 2nd positional only parameter to call `BaseCommand._engine_terminated` but got `Optional[int]`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 684,
    "warning_line": "            self.command._engine_terminated(self, code)"
  },
  {
    "project": "niklasf/python-chess",
    "commit": "40441c1eb3093c25644fd2f25f5151a14636d432",
    "filename": "chess/engine.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/niklasf-python-chess/chess/engine.py",
    "file_hunks_size": 13,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "chess/engine.py:687:55 Incompatible parameter type [6]: Expected `int` for 2nd positional only parameter to call `BaseCommand._engine_terminated` but got `Optional[int]`.",
    "message": " Expected `int` for 2nd positional only parameter to call `BaseCommand._engine_terminated` but got `Optional[int]`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 687,
    "warning_line": "            self.next_command._engine_terminated(self, code)"
  },
  {
    "project": "niklasf/python-chess",
    "commit": "40441c1eb3093c25644fd2f25f5151a14636d432",
    "filename": "chess/engine.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/niklasf-python-chess/chess/engine.py",
    "file_hunks_size": 13,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "chess/engine.py:690:35 Incompatible parameter type [6]: Expected `int` for 1st positional only parameter to call `asyncio.futures.Future.set_result` but got `Optional[int]`.",
    "message": " Expected `int` for 1st positional only parameter to call `asyncio.futures.Future.set_result` but got `Optional[int]`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 690,
    "warning_line": "        self.returncode.set_result(code)"
  },
  {
    "project": "niklasf/python-chess",
    "commit": "40441c1eb3093c25644fd2f25f5151a14636d432",
    "filename": "chess/engine.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/niklasf-python-chess/chess/engine.py",
    "file_hunks_size": 13,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": true,
    "full_warning_msg": "chess/engine.py:703:31 Incompatible parameter type [6]: Expected `Iterable[typing_extensions.SupportsIndex]` for 1st positional only parameter to call `bytearray.extend` but got `Union[bytes, str]`.",
    "message": " Expected `Iterable[typing_extensions.SupportsIndex]` for 1st positional only parameter to call `bytearray.extend` but got `Union[bytes, str]`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 703,
    "warning_line": "        self.buffer[fd].extend(data)",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": true,
        "source_code": "    def pipe_data_received(self, fd: int, data: Union[bytes, str]) -> None:\n        self.buffer[fd].extend(data)\n        while b\"\\n\" in self.buffer[fd]:\n            line, self.buffer[fd] = self.buffer[fd].split(b\"\\n\", 1)\n            if line.endswith(b\"\\r\"):\n                line = line[:-1]\n            line = line.decode(\"utf-8\")\n            if fd == 1:\n",
        "source_code_len": 355,
        "target_code": "    def pipe_data_received(self, fd: int, data: Union[bytes, str]) -> None:\n        self.buffer[fd].extend(data)  # type: ignore\n        while b\"\\n\" in self.buffer[fd]:\n            line_bytes, self.buffer[fd] = self.buffer[fd].split(b\"\\n\", 1)\n            if line_bytes.endswith(b\"\\r\"):\n                line_bytes = line_bytes[:-1]\n            line = line_bytes.decode(\"utf-8\")\n            if fd == 1:\n",
        "target_code_len": 401,
        "diff_format": "@@ -702,8 +704,8 @@\n     def pipe_data_received(self, fd: int, data: Union[bytes, str]) -> None:\n-        self.buffer[fd].extend(data)\n+        self.buffer[fd].extend(data)  # type: ignore\n         while b\"\\n\" in self.buffer[fd]:\n-            line, self.buffer[fd] = self.buffer[fd].split(b\"\\n\", 1)\n-            if line.endswith(b\"\\r\"):\n-                line = line[:-1]\n-            line = line.decode(\"utf-8\")\n+            line_bytes, self.buffer[fd] = self.buffer[fd].split(b\"\\n\", 1)\n+            if line_bytes.endswith(b\"\\r\"):\n+                line_bytes = line_bytes[:-1]\n+            line = line_bytes.decode(\"utf-8\")\n             if fd == 1:\n",
        "source_code_with_indent": "    <DED>def pipe_data_received(self, fd: int, data: Union[bytes, str]) -> None:\n        <IND>self.buffer[fd].extend(data)\n        while b\"\\n\" in self.buffer[fd]:\n            <IND>line, self.buffer[fd] = self.buffer[fd].split(b\"\\n\", 1)\n            if line.endswith(b\"\\r\"):\n                <IND>line = line[:-1]\n            <DED>line = line.decode(\"utf-8\")\n            if fd == 1:\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    <DED>def pipe_data_received(self, fd: int, data: Union[bytes, str]) -> None:\n        <IND>self.buffer[fd].extend(data)  # type: ignore\n        while b\"\\n\" in self.buffer[fd]:\n            <IND>line_bytes, self.buffer[fd] = self.buffer[fd].split(b\"\\n\", 1)\n            if line_bytes.endswith(b\"\\r\"):\n                <IND>line_bytes = line_bytes[:-1]\n            <DED>line = line_bytes.decode(\"utf-8\")\n            if fd == 1:\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "niklasf/python-chess",
    "commit": "40441c1eb3093c25644fd2f25f5151a14636d432",
    "filename": "chess/engine.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/niklasf-python-chess/chess/engine.py",
    "file_hunks_size": 13,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "chess/engine.py:741:8 Incompatible variable type [9]: self.next_command is declared to have type `Optional[BaseCommand[EngineProtocol, typing.Any]]` but is used as type `BaseCommand[Variable[EngineProtocolT (bound to EngineProtocol)], Variable[T]]`.",
    "message": " self.next_command is declared to have type `Optional[BaseCommand[EngineProtocol, typing.Any]]` but is used as type `BaseCommand[Variable[EngineProtocolT (bound to EngineProtocol)], Variable[T]]`.",
    "rule_id": "Incompatible variable type [9]",
    "warning_line_no": 741,
    "warning_line": "        self.next_command = command",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n    def __init__(self) -> None:\n        self.loop = _get_running_loop()\n",
        "source_code_len": 73,
        "target_code": "\n    def __init__(self: EngineProtocolT) -> None:\n        self.loop = _get_running_loop()\n",
        "target_code_len": 90,
        "diff_format": "@@ -656,3 +656,3 @@\n \n-    def __init__(self) -> None:\n+    def __init__(self: EngineProtocolT) -> None:\n         self.loop = _get_running_loop()\n",
        "source_code_with_indent": "\n    def __init__(self) -> None:\n        <IND>self.loop = _get_running_loop()\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n    def __init__(self: EngineProtocolT) -> None:\n        <IND>self.loop = _get_running_loop()\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n        self.command: Optional[BaseCommand[EngineProtocol, Any]] = None\n        self.next_command: Optional[BaseCommand[EngineProtocol, Any]] = None\n\n",
        "source_code_len": 151,
        "target_code": "\n        self.command: Optional[BaseCommand[EngineProtocolT, Any]] = None\n        self.next_command: Optional[BaseCommand[EngineProtocolT, Any]] = None\n\n",
        "target_code_len": 153,
        "diff_format": "@@ -665,4 +665,4 @@\n \n-        self.command: Optional[BaseCommand[EngineProtocol, Any]] = None\n-        self.next_command: Optional[BaseCommand[EngineProtocol, Any]] = None\n+        self.command: Optional[BaseCommand[EngineProtocolT, Any]] = None\n+        self.next_command: Optional[BaseCommand[EngineProtocolT, Any]] = None\n \n",
        "source_code_with_indent": "\n        self.command: Optional[BaseCommand[EngineProtocol, Any]] = None\n        self.next_command: Optional[BaseCommand[EngineProtocol, Any]] = None\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n        self.command: Optional[BaseCommand[EngineProtocolT, Any]] = None\n        self.next_command: Optional[BaseCommand[EngineProtocolT, Any]] = None\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  }
]