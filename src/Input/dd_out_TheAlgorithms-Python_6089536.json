[
  {
    "project": "TheAlgorithms/Python",
    "commit": "60895366c0f50844af2737130ed98c2510e90060",
    "filename": "ciphers/diffie_hellman.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/TheAlgorithms-Python/ciphers/diffie_hellman.py",
    "file_hunks_size": 2,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "ciphers/diffie_hellman.py:248:11 Unsupported operand [58]: `<=` is not supported for operand types `int` and `str`.",
    "message": " `<=` is not supported for operand types `int` and `str`.",
    "rule_id": "Unsupported operand [58]",
    "warning_line_no": 248,
    "warning_line": "        if 2 <= remote_public_key_str and remote_public_key_str <= prime - 2:",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    @staticmethod\n    def is_valid_public_key_static(\n        local_private_key_str: str, remote_public_key_str: str, prime: int\n    ) -> bool:\n        # check if the other public key is valid based on NIST SP800-56\n",
        "source_code_len": 216,
        "target_code": "    @staticmethod\n    def is_valid_public_key_static(remote_public_key_str: int, prime: int) -> bool:\n        # check if the other public key is valid based on NIST SP800-56\n",
        "target_code_len": 174,
        "diff_format": "@@ -243,5 +243,3 @@\n     @staticmethod\n-    def is_valid_public_key_static(\n-        local_private_key_str: str, remote_public_key_str: str, prime: int\n-    ) -> bool:\n+    def is_valid_public_key_static(remote_public_key_str: int, prime: int) -> bool:\n         # check if the other public key is valid based on NIST SP800-56\n",
        "source_code_with_indent": "    <DED>@staticmethod\n    def is_valid_public_key_static(\n        local_private_key_str: str, remote_public_key_str: str, prime: int\n    ) -> bool:\n        # check if the other public key is valid based on NIST SP800-56\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    <DED>@staticmethod\n    def is_valid_public_key_static(remote_public_key_str: int, prime: int) -> bool:\n        # check if the other public key is valid based on NIST SP800-56\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "        prime = primes[group][\"prime\"]\n        if not DiffieHellman.is_valid_public_key_static(\n            local_private_key, remote_public_key, prime\n        ):\n            raise ValueError(\"Invalid public key\")\n",
        "source_code_len": 214,
        "target_code": "        prime = primes[group][\"prime\"]\n        if not DiffieHellman.is_valid_public_key_static(remote_public_key, prime):\n            raise ValueError(\"Invalid public key\")\n",
        "target_code_len": 173,
        "diff_format": "@@ -259,5 +257,3 @@\n         prime = primes[group][\"prime\"]\n-        if not DiffieHellman.is_valid_public_key_static(\n-            local_private_key, remote_public_key, prime\n-        ):\n+        if not DiffieHellman.is_valid_public_key_static(remote_public_key, prime):\n             raise ValueError(\"Invalid public key\")\n",
        "source_code_with_indent": "        prime = primes[group][\"prime\"]\n        if not DiffieHellman.is_valid_public_key_static(\n            local_private_key, remote_public_key, prime\n        ):\n            <IND>raise ValueError(\"Invalid public key\")\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "        prime = primes[group][\"prime\"]\n        if not DiffieHellman.is_valid_public_key_static(remote_public_key, prime):\n            <IND>raise ValueError(\"Invalid public key\")\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "TheAlgorithms/Python",
    "commit": "60895366c0f50844af2737130ed98c2510e90060",
    "filename": "ciphers/diffie_hellman.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/TheAlgorithms-Python/ciphers/diffie_hellman.py",
    "file_hunks_size": 2,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "ciphers/diffie_hellman.py:248:42 Unsupported operand [58]: `<=` is not supported for operand types `str` and `int`.",
    "message": " `<=` is not supported for operand types `str` and `int`.",
    "rule_id": "Unsupported operand [58]",
    "warning_line_no": 248,
    "warning_line": "        if 2 <= remote_public_key_str and remote_public_key_str <= prime - 2:",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    @staticmethod\n    def is_valid_public_key_static(\n        local_private_key_str: str, remote_public_key_str: str, prime: int\n    ) -> bool:\n        # check if the other public key is valid based on NIST SP800-56\n",
        "source_code_len": 216,
        "target_code": "    @staticmethod\n    def is_valid_public_key_static(remote_public_key_str: int, prime: int) -> bool:\n        # check if the other public key is valid based on NIST SP800-56\n",
        "target_code_len": 174,
        "diff_format": "@@ -243,5 +243,3 @@\n     @staticmethod\n-    def is_valid_public_key_static(\n-        local_private_key_str: str, remote_public_key_str: str, prime: int\n-    ) -> bool:\n+    def is_valid_public_key_static(remote_public_key_str: int, prime: int) -> bool:\n         # check if the other public key is valid based on NIST SP800-56\n",
        "source_code_with_indent": "    <DED>@staticmethod\n    def is_valid_public_key_static(\n        local_private_key_str: str, remote_public_key_str: str, prime: int\n    ) -> bool:\n        # check if the other public key is valid based on NIST SP800-56\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    <DED>@staticmethod\n    def is_valid_public_key_static(remote_public_key_str: int, prime: int) -> bool:\n        # check if the other public key is valid based on NIST SP800-56\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "        prime = primes[group][\"prime\"]\n        if not DiffieHellman.is_valid_public_key_static(\n            local_private_key, remote_public_key, prime\n        ):\n            raise ValueError(\"Invalid public key\")\n",
        "source_code_len": 214,
        "target_code": "        prime = primes[group][\"prime\"]\n        if not DiffieHellman.is_valid_public_key_static(remote_public_key, prime):\n            raise ValueError(\"Invalid public key\")\n",
        "target_code_len": 173,
        "diff_format": "@@ -259,5 +257,3 @@\n         prime = primes[group][\"prime\"]\n-        if not DiffieHellman.is_valid_public_key_static(\n-            local_private_key, remote_public_key, prime\n-        ):\n+        if not DiffieHellman.is_valid_public_key_static(remote_public_key, prime):\n             raise ValueError(\"Invalid public key\")\n",
        "source_code_with_indent": "        prime = primes[group][\"prime\"]\n        if not DiffieHellman.is_valid_public_key_static(\n            local_private_key, remote_public_key, prime\n        ):\n            <IND>raise ValueError(\"Invalid public key\")\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "        prime = primes[group][\"prime\"]\n        if not DiffieHellman.is_valid_public_key_static(remote_public_key, prime):\n            <IND>raise ValueError(\"Invalid public key\")\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "TheAlgorithms/Python",
    "commit": "60895366c0f50844af2737130ed98c2510e90060",
    "filename": "ciphers/diffie_hellman.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/TheAlgorithms-Python/ciphers/diffie_hellman.py",
    "file_hunks_size": 2,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "ciphers/diffie_hellman.py:249:19 Incompatible parameter type [6]: Expected `int` for 1st positional only parameter to call `pow` but got `str`.",
    "message": " Expected `int` for 1st positional only parameter to call `pow` but got `str`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 249,
    "warning_line": "            if pow(remote_public_key_str, (prime - 1) // 2, prime) == 1:",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    @staticmethod\n    def is_valid_public_key_static(\n        local_private_key_str: str, remote_public_key_str: str, prime: int\n    ) -> bool:\n        # check if the other public key is valid based on NIST SP800-56\n",
        "source_code_len": 216,
        "target_code": "    @staticmethod\n    def is_valid_public_key_static(remote_public_key_str: int, prime: int) -> bool:\n        # check if the other public key is valid based on NIST SP800-56\n",
        "target_code_len": 174,
        "diff_format": "@@ -243,5 +243,3 @@\n     @staticmethod\n-    def is_valid_public_key_static(\n-        local_private_key_str: str, remote_public_key_str: str, prime: int\n-    ) -> bool:\n+    def is_valid_public_key_static(remote_public_key_str: int, prime: int) -> bool:\n         # check if the other public key is valid based on NIST SP800-56\n",
        "source_code_with_indent": "    <DED>@staticmethod\n    def is_valid_public_key_static(\n        local_private_key_str: str, remote_public_key_str: str, prime: int\n    ) -> bool:\n        # check if the other public key is valid based on NIST SP800-56\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    <DED>@staticmethod\n    def is_valid_public_key_static(remote_public_key_str: int, prime: int) -> bool:\n        # check if the other public key is valid based on NIST SP800-56\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "        prime = primes[group][\"prime\"]\n        if not DiffieHellman.is_valid_public_key_static(\n            local_private_key, remote_public_key, prime\n        ):\n            raise ValueError(\"Invalid public key\")\n",
        "source_code_len": 214,
        "target_code": "        prime = primes[group][\"prime\"]\n        if not DiffieHellman.is_valid_public_key_static(remote_public_key, prime):\n            raise ValueError(\"Invalid public key\")\n",
        "target_code_len": 173,
        "diff_format": "@@ -259,5 +257,3 @@\n         prime = primes[group][\"prime\"]\n-        if not DiffieHellman.is_valid_public_key_static(\n-            local_private_key, remote_public_key, prime\n-        ):\n+        if not DiffieHellman.is_valid_public_key_static(remote_public_key, prime):\n             raise ValueError(\"Invalid public key\")\n",
        "source_code_with_indent": "        prime = primes[group][\"prime\"]\n        if not DiffieHellman.is_valid_public_key_static(\n            local_private_key, remote_public_key, prime\n        ):\n            <IND>raise ValueError(\"Invalid public key\")\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "        prime = primes[group][\"prime\"]\n        if not DiffieHellman.is_valid_public_key_static(remote_public_key, prime):\n            <IND>raise ValueError(\"Invalid public key\")\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "TheAlgorithms/Python",
    "commit": "60895366c0f50844af2737130ed98c2510e90060",
    "filename": "ciphers/diffie_hellman.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/TheAlgorithms-Python/ciphers/diffie_hellman.py",
    "file_hunks_size": 2,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "ciphers/diffie_hellman.py:261:12 Incompatible parameter type [6]: Expected `str` for 1st positional only parameter to call `DiffieHellman.is_valid_public_key_static` but got `int`.",
    "message": " Expected `str` for 1st positional only parameter to call `DiffieHellman.is_valid_public_key_static` but got `int`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 261,
    "warning_line": "            local_private_key, remote_public_key, prime",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    @staticmethod\n    def is_valid_public_key_static(\n        local_private_key_str: str, remote_public_key_str: str, prime: int\n    ) -> bool:\n        # check if the other public key is valid based on NIST SP800-56\n",
        "source_code_len": 216,
        "target_code": "    @staticmethod\n    def is_valid_public_key_static(remote_public_key_str: int, prime: int) -> bool:\n        # check if the other public key is valid based on NIST SP800-56\n",
        "target_code_len": 174,
        "diff_format": "@@ -243,5 +243,3 @@\n     @staticmethod\n-    def is_valid_public_key_static(\n-        local_private_key_str: str, remote_public_key_str: str, prime: int\n-    ) -> bool:\n+    def is_valid_public_key_static(remote_public_key_str: int, prime: int) -> bool:\n         # check if the other public key is valid based on NIST SP800-56\n",
        "source_code_with_indent": "    <DED>@staticmethod\n    def is_valid_public_key_static(\n        local_private_key_str: str, remote_public_key_str: str, prime: int\n    ) -> bool:\n        # check if the other public key is valid based on NIST SP800-56\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    <DED>@staticmethod\n    def is_valid_public_key_static(remote_public_key_str: int, prime: int) -> bool:\n        # check if the other public key is valid based on NIST SP800-56\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": true,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "        prime = primes[group][\"prime\"]\n        if not DiffieHellman.is_valid_public_key_static(\n            local_private_key, remote_public_key, prime\n        ):\n            raise ValueError(\"Invalid public key\")\n",
        "source_code_len": 214,
        "target_code": "        prime = primes[group][\"prime\"]\n        if not DiffieHellman.is_valid_public_key_static(remote_public_key, prime):\n            raise ValueError(\"Invalid public key\")\n",
        "target_code_len": 173,
        "diff_format": "@@ -259,5 +257,3 @@\n         prime = primes[group][\"prime\"]\n-        if not DiffieHellman.is_valid_public_key_static(\n-            local_private_key, remote_public_key, prime\n-        ):\n+        if not DiffieHellman.is_valid_public_key_static(remote_public_key, prime):\n             raise ValueError(\"Invalid public key\")\n",
        "source_code_with_indent": "        prime = primes[group][\"prime\"]\n        if not DiffieHellman.is_valid_public_key_static(\n            local_private_key, remote_public_key, prime\n        ):\n            <IND>raise ValueError(\"Invalid public key\")\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "        prime = primes[group][\"prime\"]\n        if not DiffieHellman.is_valid_public_key_static(remote_public_key, prime):\n            <IND>raise ValueError(\"Invalid public key\")\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "TheAlgorithms/Python",
    "commit": "60895366c0f50844af2737130ed98c2510e90060",
    "filename": "ciphers/diffie_hellman.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/TheAlgorithms-Python/ciphers/diffie_hellman.py",
    "file_hunks_size": 2,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "ciphers/diffie_hellman.py:261:31 Incompatible parameter type [6]: Expected `str` for 2nd positional only parameter to call `DiffieHellman.is_valid_public_key_static` but got `int`.",
    "message": " Expected `str` for 2nd positional only parameter to call `DiffieHellman.is_valid_public_key_static` but got `int`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 261,
    "warning_line": "            local_private_key, remote_public_key, prime",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    @staticmethod\n    def is_valid_public_key_static(\n        local_private_key_str: str, remote_public_key_str: str, prime: int\n    ) -> bool:\n        # check if the other public key is valid based on NIST SP800-56\n",
        "source_code_len": 216,
        "target_code": "    @staticmethod\n    def is_valid_public_key_static(remote_public_key_str: int, prime: int) -> bool:\n        # check if the other public key is valid based on NIST SP800-56\n",
        "target_code_len": 174,
        "diff_format": "@@ -243,5 +243,3 @@\n     @staticmethod\n-    def is_valid_public_key_static(\n-        local_private_key_str: str, remote_public_key_str: str, prime: int\n-    ) -> bool:\n+    def is_valid_public_key_static(remote_public_key_str: int, prime: int) -> bool:\n         # check if the other public key is valid based on NIST SP800-56\n",
        "source_code_with_indent": "    <DED>@staticmethod\n    def is_valid_public_key_static(\n        local_private_key_str: str, remote_public_key_str: str, prime: int\n    ) -> bool:\n        # check if the other public key is valid based on NIST SP800-56\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    <DED>@staticmethod\n    def is_valid_public_key_static(remote_public_key_str: int, prime: int) -> bool:\n        # check if the other public key is valid based on NIST SP800-56\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": true,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "        prime = primes[group][\"prime\"]\n        if not DiffieHellman.is_valid_public_key_static(\n            local_private_key, remote_public_key, prime\n        ):\n            raise ValueError(\"Invalid public key\")\n",
        "source_code_len": 214,
        "target_code": "        prime = primes[group][\"prime\"]\n        if not DiffieHellman.is_valid_public_key_static(remote_public_key, prime):\n            raise ValueError(\"Invalid public key\")\n",
        "target_code_len": 173,
        "diff_format": "@@ -259,5 +257,3 @@\n         prime = primes[group][\"prime\"]\n-        if not DiffieHellman.is_valid_public_key_static(\n-            local_private_key, remote_public_key, prime\n-        ):\n+        if not DiffieHellman.is_valid_public_key_static(remote_public_key, prime):\n             raise ValueError(\"Invalid public key\")\n",
        "source_code_with_indent": "        prime = primes[group][\"prime\"]\n        if not DiffieHellman.is_valid_public_key_static(\n            local_private_key, remote_public_key, prime\n        ):\n            <IND>raise ValueError(\"Invalid public key\")\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "        prime = primes[group][\"prime\"]\n        if not DiffieHellman.is_valid_public_key_static(remote_public_key, prime):\n            <IND>raise ValueError(\"Invalid public key\")\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "TheAlgorithms/Python",
    "commit": "60895366c0f50844af2737130ed98c2510e90060",
    "filename": "ciphers/onepad_cipher.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/TheAlgorithms-Python/ciphers/onepad_cipher.py",
    "file_hunks_size": 3,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": true,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "ciphers/onepad_cipher.py:5:37 Invalid type [31]: Expression `([str], [int])` is not a valid type.",
    "message": " Expression `([str], [int])` is not a valid type.",
    "rule_id": "Invalid type [31]",
    "warning_line_no": 5,
    "warning_line": "    def encrypt(self, text: str) -> ([str], [int]):",
    "min_patch": [
      {
        "hunk_fit_TFix": true,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "class Onepad:\n    def encrypt(self, text: str) -> ([str], [int]):\n        \"\"\"Function to encrypt text using pseudo-random numbers\"\"\"\n",
        "source_code_len": 133,
        "target_code": "class Onepad:\n    @staticmethod\n    def encrypt(text: str) -> tuple[list[int], list[int]]:\n        \"\"\"Function to encrypt text using pseudo-random numbers\"\"\"\n",
        "target_code_len": 158,
        "diff_format": "@@ -4,3 +4,4 @@\n class Onepad:\n-    def encrypt(self, text: str) -> ([str], [int]):\n+    @staticmethod\n+    def encrypt(text: str) -> tuple[list[int], list[int]]:\n         \"\"\"Function to encrypt text using pseudo-random numbers\"\"\"\n",
        "source_code_with_indent": "class Onepad:\n    <IND>def encrypt(self, text: str) -> ([str], [int]):\n        <IND>\"\"\"Function to encrypt text using pseudo-random numbers\"\"\"\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "class Onepad:\n    <IND>@staticmethod\n    def encrypt(text: str) -> tuple[list[int], list[int]]:\n        <IND>\"\"\"Function to encrypt text using pseudo-random numbers\"\"\"\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "TheAlgorithms/Python",
    "commit": "60895366c0f50844af2737130ed98c2510e90060",
    "filename": "ciphers/onepad_cipher.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/TheAlgorithms-Python/ciphers/onepad_cipher.py",
    "file_hunks_size": 3,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": true,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "ciphers/onepad_cipher.py:17:30 Invalid type [31]: Expression `[str]` is not a valid type.",
    "message": " Expression `[str]` is not a valid type.",
    "rule_id": "Invalid type [31]",
    "warning_line_no": 17,
    "warning_line": "    def decrypt(self, cipher: [str], key: [int]) -> str:",
    "min_patch": [
      {
        "hunk_fit_TFix": true,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n    def decrypt(self, cipher: [str], key: [int]) -> str:\n        \"\"\"Function to decrypt text using pseudo-random numbers.\"\"\"\n",
        "source_code_len": 126,
        "target_code": "\n    @staticmethod\n    def decrypt(cipher: list[int], key: list[int]) -> str:\n        \"\"\"Function to decrypt text using pseudo-random numbers.\"\"\"\n",
        "target_code_len": 146,
        "diff_format": "@@ -16,3 +17,4 @@\n \n-    def decrypt(self, cipher: [str], key: [int]) -> str:\n+    @staticmethod\n+    def decrypt(cipher: list[int], key: list[int]) -> str:\n         \"\"\"Function to decrypt text using pseudo-random numbers.\"\"\"\n",
        "source_code_with_indent": "\n    <DED>def decrypt(self, cipher: [str], key: [int]) -> str:\n        <IND>\"\"\"Function to decrypt text using pseudo-random numbers.\"\"\"\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n    <DED>@staticmethod\n    def decrypt(cipher: list[int], key: list[int]) -> str:\n        <IND>\"\"\"Function to decrypt text using pseudo-random numbers.\"\"\"\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "TheAlgorithms/Python",
    "commit": "60895366c0f50844af2737130ed98c2510e90060",
    "filename": "ciphers/onepad_cipher.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/TheAlgorithms-Python/ciphers/onepad_cipher.py",
    "file_hunks_size": 3,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": true,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "ciphers/onepad_cipher.py:17:42 Invalid type [31]: Expression `[int]` is not a valid type.",
    "message": " Expression `[int]` is not a valid type.",
    "rule_id": "Invalid type [31]",
    "warning_line_no": 17,
    "warning_line": "    def decrypt(self, cipher: [str], key: [int]) -> str:",
    "min_patch": [
      {
        "hunk_fit_TFix": true,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n    def decrypt(self, cipher: [str], key: [int]) -> str:\n        \"\"\"Function to decrypt text using pseudo-random numbers.\"\"\"\n",
        "source_code_len": 126,
        "target_code": "\n    @staticmethod\n    def decrypt(cipher: list[int], key: list[int]) -> str:\n        \"\"\"Function to decrypt text using pseudo-random numbers.\"\"\"\n",
        "target_code_len": 146,
        "diff_format": "@@ -16,3 +17,4 @@\n \n-    def decrypt(self, cipher: [str], key: [int]) -> str:\n+    @staticmethod\n+    def decrypt(cipher: list[int], key: list[int]) -> str:\n         \"\"\"Function to decrypt text using pseudo-random numbers.\"\"\"\n",
        "source_code_with_indent": "\n    <DED>def decrypt(self, cipher: [str], key: [int]) -> str:\n        <IND>\"\"\"Function to decrypt text using pseudo-random numbers.\"\"\"\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n    <DED>@staticmethod\n    def decrypt(cipher: list[int], key: list[int]) -> str:\n        <IND>\"\"\"Function to decrypt text using pseudo-random numbers.\"\"\"\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "TheAlgorithms/Python",
    "commit": "60895366c0f50844af2737130ed98c2510e90060",
    "filename": "ciphers/playfair_cipher.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/TheAlgorithms-Python/ciphers/playfair_cipher.py",
    "file_hunks_size": 2,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": true,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "ciphers/playfair_cipher.py:40:32 Invalid type [31]: Expression `[str]` is not a valid type.",
    "message": " Expression `[str]` is not a valid type.",
    "rule_id": "Invalid type [31]",
    "warning_line_no": 40,
    "warning_line": "def generate_table(key: str) -> [str]:",
    "min_patch": [
      {
        "hunk_fit_TFix": true,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\ndef generate_table(key: str) -> [str]:\n\n",
        "source_code_len": 41,
        "target_code": "\ndef generate_table(key: str) -> list[str]:\n\n",
        "target_code_len": 45,
        "diff_format": "@@ -39,3 +40,3 @@\n \n-def generate_table(key: str) -> [str]:\n+def generate_table(key: str) -> list[str]:\n \n",
        "source_code_with_indent": "\n<DED>def generate_table(key: str) -> [str]:\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n<DED>def generate_table(key: str) -> list[str]:\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "TheAlgorithms/Python",
    "commit": "60895366c0f50844af2737130ed98c2510e90060",
    "filename": "ciphers/rsa_cipher.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/TheAlgorithms-Python/ciphers/rsa_cipher.py",
    "file_hunks_size": 3,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "ciphers/rsa_cipher.py:43:76 Invalid type [31]: Expression `[int]` is not a valid type.",
    "message": " Expression `[int]` is not a valid type.",
    "rule_id": "Invalid type [31]",
    "warning_line_no": 43,
    "warning_line": "def getBlocksFromText(message: int, blockSize: int = DEFAULT_BLOCK_SIZE) -> [int]:",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    elif mode == \"decrypt\":\n        privKeyFilename = \"rsa_privkey.txt\"\n        print(\"Reading from %s and decrypting...\" % (filename))\n        decryptedText = readFromFileAndDecrypt(filename, privKeyFilename)\n        print(\"writing decryption to rsa_decryption.txt...\")\n        with open(\"rsa_decryption.txt\", \"w\") as dec:\n            dec.write(decryptedText)\n\n        print(\"\\nDecryption:\")\n        print(decryptedText)\n\n\ndef getBlocksFromText(message: int, blockSize: int = DEFAULT_BLOCK_SIZE) -> [int]:\n    messageBytes = message.encode(\"ascii\")\n\n    blockInts = []\n    for blockStart in range(0, len(messageBytes), blockSize):\n        blockInt = 0\n        for i in range(blockStart, min(blockStart + blockSize, len(messageBytes))):\n            blockInt += messageBytes[i] * (BYTE_SIZE ** (i % blockSize))\n        blockInts.append(blockInt)\n    return blockInts\n\n\ndef getTextFromBlocks(\n    blockInts: [int], messageLength: int, blockSize: int = DEFAULT_BLOCK_SIZE\n) -> str:\n    message = []\n    for blockInt in blockInts:\n        blockMessage = []\n        for i in range(blockSize - 1, -1, -1):\n            if len(message) + i < messageLength:\n                asciiNumber = blockInt // (BYTE_SIZE ** i)\n                blockInt = blockInt % (BYTE_SIZE ** i)\n                blockMessage.insert(0, chr(asciiNumber))\n        message.extend(blockMessage)\n    return \"\".join(message)\n\n\ndef encryptMessage(\n    message: str, key: (int, int), blockSize: int = DEFAULT_BLOCK_SIZE\n) -> [int]:\n    encryptedBlocks = []\n    n, e = key\n\n    for block in getBlocksFromText(message, blockSize):\n        encryptedBlocks.append(pow(block, e, n))\n    return encryptedBlocks\n\n\ndef decryptMessage(\n    encryptedBlocks: [int],\n    messageLength: int,\n    key: (int, int),\n    blockSize: int = DEFAULT_BLOCK_SIZE,\n) -> str:\n    decryptedBlocks = []\n    n, d = key\n    for block in encryptedBlocks:\n        decryptedBlocks.append(pow(block, d, n))\n    return getTextFromBlocks(decryptedBlocks, messageLength, blockSize)\n\n\ndef readKeyFile(keyFilename: str) -> (int, int, int):\n    with open(keyFilename) as fo:\n        content = fo.read()\n    keySize, n, EorD = content.split(\",\")\n    return (int(keySize), int(n), int(EorD))\n\n\ndef encryptAndWriteToFile(\n    messageFilename: str,\n    keyFilename: str,\n    message: str,\n    blockSize: int = DEFAULT_BLOCK_SIZE,\n) -> str:\n    keySize, n, e = readKeyFile(keyFilename)\n    if keySize < blockSize * 8:\n        sys.exit(\n            \"ERROR: Block size is %s bits and key size is %s bits. The RSA cipher \"\n            \"requires the block size to be equal to or greater than the key size. \"\n            \"Either decrease the block size or use different keys.\"\n            % (blockSize * 8, keySize)\n        )\n\n    encryptedBlocks = encryptMessage(message, (n, e), blockSize)\n\n    for i in range(len(encryptedBlocks)):\n        encryptedBlocks[i] = str(encryptedBlocks[i])\n    encryptedContent = \",\".join(encryptedBlocks)\n    encryptedContent = f\"{len(message)}_{blockSize}_{encryptedContent}\"\n    with open(messageFilename, \"w\") as fo:\n        fo.write(encryptedContent)\n    return encryptedContent\n\n\ndef readFromFileAndDecrypt(messageFilename: str, keyFilename: str) -> str:\n    keySize, n, d = readKeyFile(keyFilename)\n    with open(messageFilename) as fo:\n        content = fo.read()\n    messageLength, blockSize, encryptedMessage = content.split(\"_\")\n    messageLength = int(messageLength)\n    blockSize = int(blockSize)\n\n    if keySize < blockSize * 8:\n        sys.exit(\n            \"ERROR: Block size is %s bits and key size is %s bits. The RSA cipher \"\n            \"requires the block size to be equal to or greater than the key size. \"\n            \"Did you specify the correct key file and encrypted file?\"\n            % (blockSize * 8, keySize)\n        )\n\n    encryptedBlocks = []\n    for block in encryptedMessage.split(\",\"):\n        encryptedBlocks.append(int(block))\n\n    return decryptMessage(encryptedBlocks, messageLength, (n, d), blockSize)\n\n",
        "source_code_len": 3983,
        "target_code": "    elif mode == \"decrypt\":\n        privkey_filename = \"rsa_privkey.txt\"\n        print(\"Reading from %s and decrypting...\" % (filename))\n        decrypted_text = read_from_file_and_decrypt(filename, privkey_filename)\n        print(\"writing decryption to rsa_decryption.txt...\")\n        with open(\"rsa_decryption.txt\", \"w\") as dec:\n            dec.write(decrypted_text)\n\n        print(\"\\nDecryption:\")\n        print(decrypted_text)\n\n",
        "target_code_len": 432,
        "diff_format": "@@ -31,118 +138,11 @@\n     elif mode == \"decrypt\":\n-        privKeyFilename = \"rsa_privkey.txt\"\n+        privkey_filename = \"rsa_privkey.txt\"\n         print(\"Reading from %s and decrypting...\" % (filename))\n-        decryptedText = readFromFileAndDecrypt(filename, privKeyFilename)\n+        decrypted_text = read_from_file_and_decrypt(filename, privkey_filename)\n         print(\"writing decryption to rsa_decryption.txt...\")\n         with open(\"rsa_decryption.txt\", \"w\") as dec:\n-            dec.write(decryptedText)\n+            dec.write(decrypted_text)\n \n         print(\"\\nDecryption:\")\n-        print(decryptedText)\n-\n-\n-def getBlocksFromText(message: int, blockSize: int = DEFAULT_BLOCK_SIZE) -> [int]:\n-    messageBytes = message.encode(\"ascii\")\n-\n-    blockInts = []\n-    for blockStart in range(0, len(messageBytes), blockSize):\n-        blockInt = 0\n-        for i in range(blockStart, min(blockStart + blockSize, len(messageBytes))):\n-            blockInt += messageBytes[i] * (BYTE_SIZE ** (i % blockSize))\n-        blockInts.append(blockInt)\n-    return blockInts\n-\n-\n-def getTextFromBlocks(\n-    blockInts: [int], messageLength: int, blockSize: int = DEFAULT_BLOCK_SIZE\n-) -> str:\n-    message = []\n-    for blockInt in blockInts:\n-        blockMessage = []\n-        for i in range(blockSize - 1, -1, -1):\n-            if len(message) + i < messageLength:\n-                asciiNumber = blockInt // (BYTE_SIZE ** i)\n-                blockInt = blockInt % (BYTE_SIZE ** i)\n-                blockMessage.insert(0, chr(asciiNumber))\n-        message.extend(blockMessage)\n-    return \"\".join(message)\n-\n-\n-def encryptMessage(\n-    message: str, key: (int, int), blockSize: int = DEFAULT_BLOCK_SIZE\n-) -> [int]:\n-    encryptedBlocks = []\n-    n, e = key\n-\n-    for block in getBlocksFromText(message, blockSize):\n-        encryptedBlocks.append(pow(block, e, n))\n-    return encryptedBlocks\n-\n-\n-def decryptMessage(\n-    encryptedBlocks: [int],\n-    messageLength: int,\n-    key: (int, int),\n-    blockSize: int = DEFAULT_BLOCK_SIZE,\n-) -> str:\n-    decryptedBlocks = []\n-    n, d = key\n-    for block in encryptedBlocks:\n-        decryptedBlocks.append(pow(block, d, n))\n-    return getTextFromBlocks(decryptedBlocks, messageLength, blockSize)\n-\n-\n-def readKeyFile(keyFilename: str) -> (int, int, int):\n-    with open(keyFilename) as fo:\n-        content = fo.read()\n-    keySize, n, EorD = content.split(\",\")\n-    return (int(keySize), int(n), int(EorD))\n-\n-\n-def encryptAndWriteToFile(\n-    messageFilename: str,\n-    keyFilename: str,\n-    message: str,\n-    blockSize: int = DEFAULT_BLOCK_SIZE,\n-) -> str:\n-    keySize, n, e = readKeyFile(keyFilename)\n-    if keySize < blockSize * 8:\n-        sys.exit(\n-            \"ERROR: Block size is %s bits and key size is %s bits. The RSA cipher \"\n-            \"requires the block size to be equal to or greater than the key size. \"\n-            \"Either decrease the block size or use different keys.\"\n-            % (blockSize * 8, keySize)\n-        )\n-\n-    encryptedBlocks = encryptMessage(message, (n, e), blockSize)\n-\n-    for i in range(len(encryptedBlocks)):\n-        encryptedBlocks[i] = str(encryptedBlocks[i])\n-    encryptedContent = \",\".join(encryptedBlocks)\n-    encryptedContent = f\"{len(message)}_{blockSize}_{encryptedContent}\"\n-    with open(messageFilename, \"w\") as fo:\n-        fo.write(encryptedContent)\n-    return encryptedContent\n-\n-\n-def readFromFileAndDecrypt(messageFilename: str, keyFilename: str) -> str:\n-    keySize, n, d = readKeyFile(keyFilename)\n-    with open(messageFilename) as fo:\n-        content = fo.read()\n-    messageLength, blockSize, encryptedMessage = content.split(\"_\")\n-    messageLength = int(messageLength)\n-    blockSize = int(blockSize)\n-\n-    if keySize < blockSize * 8:\n-        sys.exit(\n-            \"ERROR: Block size is %s bits and key size is %s bits. The RSA cipher \"\n-            \"requires the block size to be equal to or greater than the key size. \"\n-            \"Did you specify the correct key file and encrypted file?\"\n-            % (blockSize * 8, keySize)\n-        )\n-\n-    encryptedBlocks = []\n-    for block in encryptedMessage.split(\",\"):\n-        encryptedBlocks.append(int(block))\n-\n-    return decryptMessage(encryptedBlocks, messageLength, (n, d), blockSize)\n+        print(decrypted_text)\n \n",
        "source_code_with_indent": "    <DED>elif mode == \"decrypt\":\n        <IND>privKeyFilename = \"rsa_privkey.txt\"\n        print(\"Reading from %s and decrypting...\" % (filename))\n        decryptedText = readFromFileAndDecrypt(filename, privKeyFilename)\n        print(\"writing decryption to rsa_decryption.txt...\")\n        with open(\"rsa_decryption.txt\", \"w\") as dec:\n            <IND>dec.write(decryptedText)\n\n        <DED>print(\"\\nDecryption:\")\n        print(decryptedText)\n\n\n<DED><DED>def getBlocksFromText(message: int, blockSize: int = DEFAULT_BLOCK_SIZE) -> [int]:\n    <IND>messageBytes = message.encode(\"ascii\")\n\n    blockInts = []\n    for blockStart in range(0, len(messageBytes), blockSize):\n        <IND>blockInt = 0\n        for i in range(blockStart, min(blockStart + blockSize, len(messageBytes))):\n            <IND>blockInt += messageBytes[i] * (BYTE_SIZE ** (i % blockSize))\n        <DED>blockInts.append(blockInt)\n    <DED>return blockInts\n\n\n<DED>def getTextFromBlocks(\n    blockInts: [int], messageLength: int, blockSize: int = DEFAULT_BLOCK_SIZE\n) -> str:\n    <IND>message = []\n    for blockInt in blockInts:\n        <IND>blockMessage = []\n        for i in range(blockSize - 1, -1, -1):\n            <IND>if len(message) + i < messageLength:\n                <IND>asciiNumber = blockInt // (BYTE_SIZE ** i)\n                blockInt = blockInt % (BYTE_SIZE ** i)\n                blockMessage.insert(0, chr(asciiNumber))\n        <DED><DED>message.extend(blockMessage)\n    <DED>return \"\".join(message)\n\n\n<DED>def encryptMessage(\n    message: str, key: (int, int), blockSize: int = DEFAULT_BLOCK_SIZE\n) -> [int]:\n    <IND>encryptedBlocks = []\n    n, e = key\n\n    for block in getBlocksFromText(message, blockSize):\n        <IND>encryptedBlocks.append(pow(block, e, n))\n    <DED>return encryptedBlocks\n\n\n<DED>def decryptMessage(\n    encryptedBlocks: [int],\n    messageLength: int,\n    key: (int, int),\n    blockSize: int = DEFAULT_BLOCK_SIZE,\n) -> str:\n    <IND>decryptedBlocks = []\n    n, d = key\n    for block in encryptedBlocks:\n        <IND>decryptedBlocks.append(pow(block, d, n))\n    <DED>return getTextFromBlocks(decryptedBlocks, messageLength, blockSize)\n\n\n<DED>def readKeyFile(keyFilename: str) -> (int, int, int):\n    <IND>with open(keyFilename) as fo:\n        <IND>content = fo.read()\n    <DED>keySize, n, EorD = content.split(\",\")\n    return (int(keySize), int(n), int(EorD))\n\n\n<DED>def encryptAndWriteToFile(\n    messageFilename: str,\n    keyFilename: str,\n    message: str,\n    blockSize: int = DEFAULT_BLOCK_SIZE,\n) -> str:\n    <IND>keySize, n, e = readKeyFile(keyFilename)\n    if keySize < blockSize * 8:\n        <IND>sys.exit(\n            \"ERROR: Block size is %s bits and key size is %s bits. The RSA cipher \"\n            \"requires the block size to be equal to or greater than the key size. \"\n            \"Either decrease the block size or use different keys.\"\n            % (blockSize * 8, keySize)\n        )\n\n    <DED>encryptedBlocks = encryptMessage(message, (n, e), blockSize)\n\n    for i in range(len(encryptedBlocks)):\n        <IND>encryptedBlocks[i] = str(encryptedBlocks[i])\n    <DED>encryptedContent = \",\".join(encryptedBlocks)\n    encryptedContent = f\"{len(message)}_{blockSize}_{encryptedContent}\"\n    with open(messageFilename, \"w\") as fo:\n        <IND>fo.write(encryptedContent)\n    <DED>return encryptedContent\n\n\n<DED>def readFromFileAndDecrypt(messageFilename: str, keyFilename: str) -> str:\n    <IND>keySize, n, d = readKeyFile(keyFilename)\n    with open(messageFilename) as fo:\n        <IND>content = fo.read()\n    <DED>messageLength, blockSize, encryptedMessage = content.split(\"_\")\n    messageLength = int(messageLength)\n    blockSize = int(blockSize)\n\n    if keySize < blockSize * 8:\n        <IND>sys.exit(\n            \"ERROR: Block size is %s bits and key size is %s bits. The RSA cipher \"\n            \"requires the block size to be equal to or greater than the key size. \"\n            \"Did you specify the correct key file and encrypted file?\"\n            % (blockSize * 8, keySize)\n        )\n\n    <DED>encryptedBlocks = []\n    for block in encryptedMessage.split(\",\"):\n        <IND>encryptedBlocks.append(int(block))\n\n    <DED>return decryptMessage(encryptedBlocks, messageLength, (n, d), blockSize)\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    <DED>elif mode == \"decrypt\":\n        <IND>privkey_filename = \"rsa_privkey.txt\"\n        print(\"Reading from %s and decrypting...\" % (filename))\n        decrypted_text = read_from_file_and_decrypt(filename, privkey_filename)\n        print(\"writing decryption to rsa_decryption.txt...\")\n        with open(\"rsa_decryption.txt\", \"w\") as dec:\n            <IND>dec.write(decrypted_text)\n\n        <DED>print(\"\\nDecryption:\")\n        print(decrypted_text)\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "TheAlgorithms/Python",
    "commit": "60895366c0f50844af2737130ed98c2510e90060",
    "filename": "ciphers/rsa_cipher.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/TheAlgorithms-Python/ciphers/rsa_cipher.py",
    "file_hunks_size": 3,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "ciphers/rsa_cipher.py:56:15 Invalid type [31]: Expression `[int]` is not a valid type.",
    "message": " Expression `[int]` is not a valid type.",
    "rule_id": "Invalid type [31]",
    "warning_line_no": 56,
    "warning_line": "    blockInts: [int], messageLength: int, blockSize: int = DEFAULT_BLOCK_SIZE",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    elif mode == \"decrypt\":\n        privKeyFilename = \"rsa_privkey.txt\"\n        print(\"Reading from %s and decrypting...\" % (filename))\n        decryptedText = readFromFileAndDecrypt(filename, privKeyFilename)\n        print(\"writing decryption to rsa_decryption.txt...\")\n        with open(\"rsa_decryption.txt\", \"w\") as dec:\n            dec.write(decryptedText)\n\n        print(\"\\nDecryption:\")\n        print(decryptedText)\n\n\ndef getBlocksFromText(message: int, blockSize: int = DEFAULT_BLOCK_SIZE) -> [int]:\n    messageBytes = message.encode(\"ascii\")\n\n    blockInts = []\n    for blockStart in range(0, len(messageBytes), blockSize):\n        blockInt = 0\n        for i in range(blockStart, min(blockStart + blockSize, len(messageBytes))):\n            blockInt += messageBytes[i] * (BYTE_SIZE ** (i % blockSize))\n        blockInts.append(blockInt)\n    return blockInts\n\n\ndef getTextFromBlocks(\n    blockInts: [int], messageLength: int, blockSize: int = DEFAULT_BLOCK_SIZE\n) -> str:\n    message = []\n    for blockInt in blockInts:\n        blockMessage = []\n        for i in range(blockSize - 1, -1, -1):\n            if len(message) + i < messageLength:\n                asciiNumber = blockInt // (BYTE_SIZE ** i)\n                blockInt = blockInt % (BYTE_SIZE ** i)\n                blockMessage.insert(0, chr(asciiNumber))\n        message.extend(blockMessage)\n    return \"\".join(message)\n\n\ndef encryptMessage(\n    message: str, key: (int, int), blockSize: int = DEFAULT_BLOCK_SIZE\n) -> [int]:\n    encryptedBlocks = []\n    n, e = key\n\n    for block in getBlocksFromText(message, blockSize):\n        encryptedBlocks.append(pow(block, e, n))\n    return encryptedBlocks\n\n\ndef decryptMessage(\n    encryptedBlocks: [int],\n    messageLength: int,\n    key: (int, int),\n    blockSize: int = DEFAULT_BLOCK_SIZE,\n) -> str:\n    decryptedBlocks = []\n    n, d = key\n    for block in encryptedBlocks:\n        decryptedBlocks.append(pow(block, d, n))\n    return getTextFromBlocks(decryptedBlocks, messageLength, blockSize)\n\n\ndef readKeyFile(keyFilename: str) -> (int, int, int):\n    with open(keyFilename) as fo:\n        content = fo.read()\n    keySize, n, EorD = content.split(\",\")\n    return (int(keySize), int(n), int(EorD))\n\n\ndef encryptAndWriteToFile(\n    messageFilename: str,\n    keyFilename: str,\n    message: str,\n    blockSize: int = DEFAULT_BLOCK_SIZE,\n) -> str:\n    keySize, n, e = readKeyFile(keyFilename)\n    if keySize < blockSize * 8:\n        sys.exit(\n            \"ERROR: Block size is %s bits and key size is %s bits. The RSA cipher \"\n            \"requires the block size to be equal to or greater than the key size. \"\n            \"Either decrease the block size or use different keys.\"\n            % (blockSize * 8, keySize)\n        )\n\n    encryptedBlocks = encryptMessage(message, (n, e), blockSize)\n\n    for i in range(len(encryptedBlocks)):\n        encryptedBlocks[i] = str(encryptedBlocks[i])\n    encryptedContent = \",\".join(encryptedBlocks)\n    encryptedContent = f\"{len(message)}_{blockSize}_{encryptedContent}\"\n    with open(messageFilename, \"w\") as fo:\n        fo.write(encryptedContent)\n    return encryptedContent\n\n\ndef readFromFileAndDecrypt(messageFilename: str, keyFilename: str) -> str:\n    keySize, n, d = readKeyFile(keyFilename)\n    with open(messageFilename) as fo:\n        content = fo.read()\n    messageLength, blockSize, encryptedMessage = content.split(\"_\")\n    messageLength = int(messageLength)\n    blockSize = int(blockSize)\n\n    if keySize < blockSize * 8:\n        sys.exit(\n            \"ERROR: Block size is %s bits and key size is %s bits. The RSA cipher \"\n            \"requires the block size to be equal to or greater than the key size. \"\n            \"Did you specify the correct key file and encrypted file?\"\n            % (blockSize * 8, keySize)\n        )\n\n    encryptedBlocks = []\n    for block in encryptedMessage.split(\",\"):\n        encryptedBlocks.append(int(block))\n\n    return decryptMessage(encryptedBlocks, messageLength, (n, d), blockSize)\n\n",
        "source_code_len": 3983,
        "target_code": "    elif mode == \"decrypt\":\n        privkey_filename = \"rsa_privkey.txt\"\n        print(\"Reading from %s and decrypting...\" % (filename))\n        decrypted_text = read_from_file_and_decrypt(filename, privkey_filename)\n        print(\"writing decryption to rsa_decryption.txt...\")\n        with open(\"rsa_decryption.txt\", \"w\") as dec:\n            dec.write(decrypted_text)\n\n        print(\"\\nDecryption:\")\n        print(decrypted_text)\n\n",
        "target_code_len": 432,
        "diff_format": "@@ -31,118 +138,11 @@\n     elif mode == \"decrypt\":\n-        privKeyFilename = \"rsa_privkey.txt\"\n+        privkey_filename = \"rsa_privkey.txt\"\n         print(\"Reading from %s and decrypting...\" % (filename))\n-        decryptedText = readFromFileAndDecrypt(filename, privKeyFilename)\n+        decrypted_text = read_from_file_and_decrypt(filename, privkey_filename)\n         print(\"writing decryption to rsa_decryption.txt...\")\n         with open(\"rsa_decryption.txt\", \"w\") as dec:\n-            dec.write(decryptedText)\n+            dec.write(decrypted_text)\n \n         print(\"\\nDecryption:\")\n-        print(decryptedText)\n-\n-\n-def getBlocksFromText(message: int, blockSize: int = DEFAULT_BLOCK_SIZE) -> [int]:\n-    messageBytes = message.encode(\"ascii\")\n-\n-    blockInts = []\n-    for blockStart in range(0, len(messageBytes), blockSize):\n-        blockInt = 0\n-        for i in range(blockStart, min(blockStart + blockSize, len(messageBytes))):\n-            blockInt += messageBytes[i] * (BYTE_SIZE ** (i % blockSize))\n-        blockInts.append(blockInt)\n-    return blockInts\n-\n-\n-def getTextFromBlocks(\n-    blockInts: [int], messageLength: int, blockSize: int = DEFAULT_BLOCK_SIZE\n-) -> str:\n-    message = []\n-    for blockInt in blockInts:\n-        blockMessage = []\n-        for i in range(blockSize - 1, -1, -1):\n-            if len(message) + i < messageLength:\n-                asciiNumber = blockInt // (BYTE_SIZE ** i)\n-                blockInt = blockInt % (BYTE_SIZE ** i)\n-                blockMessage.insert(0, chr(asciiNumber))\n-        message.extend(blockMessage)\n-    return \"\".join(message)\n-\n-\n-def encryptMessage(\n-    message: str, key: (int, int), blockSize: int = DEFAULT_BLOCK_SIZE\n-) -> [int]:\n-    encryptedBlocks = []\n-    n, e = key\n-\n-    for block in getBlocksFromText(message, blockSize):\n-        encryptedBlocks.append(pow(block, e, n))\n-    return encryptedBlocks\n-\n-\n-def decryptMessage(\n-    encryptedBlocks: [int],\n-    messageLength: int,\n-    key: (int, int),\n-    blockSize: int = DEFAULT_BLOCK_SIZE,\n-) -> str:\n-    decryptedBlocks = []\n-    n, d = key\n-    for block in encryptedBlocks:\n-        decryptedBlocks.append(pow(block, d, n))\n-    return getTextFromBlocks(decryptedBlocks, messageLength, blockSize)\n-\n-\n-def readKeyFile(keyFilename: str) -> (int, int, int):\n-    with open(keyFilename) as fo:\n-        content = fo.read()\n-    keySize, n, EorD = content.split(\",\")\n-    return (int(keySize), int(n), int(EorD))\n-\n-\n-def encryptAndWriteToFile(\n-    messageFilename: str,\n-    keyFilename: str,\n-    message: str,\n-    blockSize: int = DEFAULT_BLOCK_SIZE,\n-) -> str:\n-    keySize, n, e = readKeyFile(keyFilename)\n-    if keySize < blockSize * 8:\n-        sys.exit(\n-            \"ERROR: Block size is %s bits and key size is %s bits. The RSA cipher \"\n-            \"requires the block size to be equal to or greater than the key size. \"\n-            \"Either decrease the block size or use different keys.\"\n-            % (blockSize * 8, keySize)\n-        )\n-\n-    encryptedBlocks = encryptMessage(message, (n, e), blockSize)\n-\n-    for i in range(len(encryptedBlocks)):\n-        encryptedBlocks[i] = str(encryptedBlocks[i])\n-    encryptedContent = \",\".join(encryptedBlocks)\n-    encryptedContent = f\"{len(message)}_{blockSize}_{encryptedContent}\"\n-    with open(messageFilename, \"w\") as fo:\n-        fo.write(encryptedContent)\n-    return encryptedContent\n-\n-\n-def readFromFileAndDecrypt(messageFilename: str, keyFilename: str) -> str:\n-    keySize, n, d = readKeyFile(keyFilename)\n-    with open(messageFilename) as fo:\n-        content = fo.read()\n-    messageLength, blockSize, encryptedMessage = content.split(\"_\")\n-    messageLength = int(messageLength)\n-    blockSize = int(blockSize)\n-\n-    if keySize < blockSize * 8:\n-        sys.exit(\n-            \"ERROR: Block size is %s bits and key size is %s bits. The RSA cipher \"\n-            \"requires the block size to be equal to or greater than the key size. \"\n-            \"Did you specify the correct key file and encrypted file?\"\n-            % (blockSize * 8, keySize)\n-        )\n-\n-    encryptedBlocks = []\n-    for block in encryptedMessage.split(\",\"):\n-        encryptedBlocks.append(int(block))\n-\n-    return decryptMessage(encryptedBlocks, messageLength, (n, d), blockSize)\n+        print(decrypted_text)\n \n",
        "source_code_with_indent": "    <DED>elif mode == \"decrypt\":\n        <IND>privKeyFilename = \"rsa_privkey.txt\"\n        print(\"Reading from %s and decrypting...\" % (filename))\n        decryptedText = readFromFileAndDecrypt(filename, privKeyFilename)\n        print(\"writing decryption to rsa_decryption.txt...\")\n        with open(\"rsa_decryption.txt\", \"w\") as dec:\n            <IND>dec.write(decryptedText)\n\n        <DED>print(\"\\nDecryption:\")\n        print(decryptedText)\n\n\n<DED><DED>def getBlocksFromText(message: int, blockSize: int = DEFAULT_BLOCK_SIZE) -> [int]:\n    <IND>messageBytes = message.encode(\"ascii\")\n\n    blockInts = []\n    for blockStart in range(0, len(messageBytes), blockSize):\n        <IND>blockInt = 0\n        for i in range(blockStart, min(blockStart + blockSize, len(messageBytes))):\n            <IND>blockInt += messageBytes[i] * (BYTE_SIZE ** (i % blockSize))\n        <DED>blockInts.append(blockInt)\n    <DED>return blockInts\n\n\n<DED>def getTextFromBlocks(\n    blockInts: [int], messageLength: int, blockSize: int = DEFAULT_BLOCK_SIZE\n) -> str:\n    <IND>message = []\n    for blockInt in blockInts:\n        <IND>blockMessage = []\n        for i in range(blockSize - 1, -1, -1):\n            <IND>if len(message) + i < messageLength:\n                <IND>asciiNumber = blockInt // (BYTE_SIZE ** i)\n                blockInt = blockInt % (BYTE_SIZE ** i)\n                blockMessage.insert(0, chr(asciiNumber))\n        <DED><DED>message.extend(blockMessage)\n    <DED>return \"\".join(message)\n\n\n<DED>def encryptMessage(\n    message: str, key: (int, int), blockSize: int = DEFAULT_BLOCK_SIZE\n) -> [int]:\n    <IND>encryptedBlocks = []\n    n, e = key\n\n    for block in getBlocksFromText(message, blockSize):\n        <IND>encryptedBlocks.append(pow(block, e, n))\n    <DED>return encryptedBlocks\n\n\n<DED>def decryptMessage(\n    encryptedBlocks: [int],\n    messageLength: int,\n    key: (int, int),\n    blockSize: int = DEFAULT_BLOCK_SIZE,\n) -> str:\n    <IND>decryptedBlocks = []\n    n, d = key\n    for block in encryptedBlocks:\n        <IND>decryptedBlocks.append(pow(block, d, n))\n    <DED>return getTextFromBlocks(decryptedBlocks, messageLength, blockSize)\n\n\n<DED>def readKeyFile(keyFilename: str) -> (int, int, int):\n    <IND>with open(keyFilename) as fo:\n        <IND>content = fo.read()\n    <DED>keySize, n, EorD = content.split(\",\")\n    return (int(keySize), int(n), int(EorD))\n\n\n<DED>def encryptAndWriteToFile(\n    messageFilename: str,\n    keyFilename: str,\n    message: str,\n    blockSize: int = DEFAULT_BLOCK_SIZE,\n) -> str:\n    <IND>keySize, n, e = readKeyFile(keyFilename)\n    if keySize < blockSize * 8:\n        <IND>sys.exit(\n            \"ERROR: Block size is %s bits and key size is %s bits. The RSA cipher \"\n            \"requires the block size to be equal to or greater than the key size. \"\n            \"Either decrease the block size or use different keys.\"\n            % (blockSize * 8, keySize)\n        )\n\n    <DED>encryptedBlocks = encryptMessage(message, (n, e), blockSize)\n\n    for i in range(len(encryptedBlocks)):\n        <IND>encryptedBlocks[i] = str(encryptedBlocks[i])\n    <DED>encryptedContent = \",\".join(encryptedBlocks)\n    encryptedContent = f\"{len(message)}_{blockSize}_{encryptedContent}\"\n    with open(messageFilename, \"w\") as fo:\n        <IND>fo.write(encryptedContent)\n    <DED>return encryptedContent\n\n\n<DED>def readFromFileAndDecrypt(messageFilename: str, keyFilename: str) -> str:\n    <IND>keySize, n, d = readKeyFile(keyFilename)\n    with open(messageFilename) as fo:\n        <IND>content = fo.read()\n    <DED>messageLength, blockSize, encryptedMessage = content.split(\"_\")\n    messageLength = int(messageLength)\n    blockSize = int(blockSize)\n\n    if keySize < blockSize * 8:\n        <IND>sys.exit(\n            \"ERROR: Block size is %s bits and key size is %s bits. The RSA cipher \"\n            \"requires the block size to be equal to or greater than the key size. \"\n            \"Did you specify the correct key file and encrypted file?\"\n            % (blockSize * 8, keySize)\n        )\n\n    <DED>encryptedBlocks = []\n    for block in encryptedMessage.split(\",\"):\n        <IND>encryptedBlocks.append(int(block))\n\n    <DED>return decryptMessage(encryptedBlocks, messageLength, (n, d), blockSize)\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    <DED>elif mode == \"decrypt\":\n        <IND>privkey_filename = \"rsa_privkey.txt\"\n        print(\"Reading from %s and decrypting...\" % (filename))\n        decrypted_text = read_from_file_and_decrypt(filename, privkey_filename)\n        print(\"writing decryption to rsa_decryption.txt...\")\n        with open(\"rsa_decryption.txt\", \"w\") as dec:\n            <IND>dec.write(decrypted_text)\n\n        <DED>print(\"\\nDecryption:\")\n        print(decrypted_text)\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "TheAlgorithms/Python",
    "commit": "60895366c0f50844af2737130ed98c2510e90060",
    "filename": "ciphers/rsa_cipher.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/TheAlgorithms-Python/ciphers/rsa_cipher.py",
    "file_hunks_size": 3,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "ciphers/rsa_cipher.py:71:24 Invalid type [31]: Expression `(int, int)` is not a valid type.",
    "message": " Expression `(int, int)` is not a valid type.",
    "rule_id": "Invalid type [31]",
    "warning_line_no": 71,
    "warning_line": "    message: str, key: (int, int), blockSize: int = DEFAULT_BLOCK_SIZE",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    elif mode == \"decrypt\":\n        privKeyFilename = \"rsa_privkey.txt\"\n        print(\"Reading from %s and decrypting...\" % (filename))\n        decryptedText = readFromFileAndDecrypt(filename, privKeyFilename)\n        print(\"writing decryption to rsa_decryption.txt...\")\n        with open(\"rsa_decryption.txt\", \"w\") as dec:\n            dec.write(decryptedText)\n\n        print(\"\\nDecryption:\")\n        print(decryptedText)\n\n\ndef getBlocksFromText(message: int, blockSize: int = DEFAULT_BLOCK_SIZE) -> [int]:\n    messageBytes = message.encode(\"ascii\")\n\n    blockInts = []\n    for blockStart in range(0, len(messageBytes), blockSize):\n        blockInt = 0\n        for i in range(blockStart, min(blockStart + blockSize, len(messageBytes))):\n            blockInt += messageBytes[i] * (BYTE_SIZE ** (i % blockSize))\n        blockInts.append(blockInt)\n    return blockInts\n\n\ndef getTextFromBlocks(\n    blockInts: [int], messageLength: int, blockSize: int = DEFAULT_BLOCK_SIZE\n) -> str:\n    message = []\n    for blockInt in blockInts:\n        blockMessage = []\n        for i in range(blockSize - 1, -1, -1):\n            if len(message) + i < messageLength:\n                asciiNumber = blockInt // (BYTE_SIZE ** i)\n                blockInt = blockInt % (BYTE_SIZE ** i)\n                blockMessage.insert(0, chr(asciiNumber))\n        message.extend(blockMessage)\n    return \"\".join(message)\n\n\ndef encryptMessage(\n    message: str, key: (int, int), blockSize: int = DEFAULT_BLOCK_SIZE\n) -> [int]:\n    encryptedBlocks = []\n    n, e = key\n\n    for block in getBlocksFromText(message, blockSize):\n        encryptedBlocks.append(pow(block, e, n))\n    return encryptedBlocks\n\n\ndef decryptMessage(\n    encryptedBlocks: [int],\n    messageLength: int,\n    key: (int, int),\n    blockSize: int = DEFAULT_BLOCK_SIZE,\n) -> str:\n    decryptedBlocks = []\n    n, d = key\n    for block in encryptedBlocks:\n        decryptedBlocks.append(pow(block, d, n))\n    return getTextFromBlocks(decryptedBlocks, messageLength, blockSize)\n\n\ndef readKeyFile(keyFilename: str) -> (int, int, int):\n    with open(keyFilename) as fo:\n        content = fo.read()\n    keySize, n, EorD = content.split(\",\")\n    return (int(keySize), int(n), int(EorD))\n\n\ndef encryptAndWriteToFile(\n    messageFilename: str,\n    keyFilename: str,\n    message: str,\n    blockSize: int = DEFAULT_BLOCK_SIZE,\n) -> str:\n    keySize, n, e = readKeyFile(keyFilename)\n    if keySize < blockSize * 8:\n        sys.exit(\n            \"ERROR: Block size is %s bits and key size is %s bits. The RSA cipher \"\n            \"requires the block size to be equal to or greater than the key size. \"\n            \"Either decrease the block size or use different keys.\"\n            % (blockSize * 8, keySize)\n        )\n\n    encryptedBlocks = encryptMessage(message, (n, e), blockSize)\n\n    for i in range(len(encryptedBlocks)):\n        encryptedBlocks[i] = str(encryptedBlocks[i])\n    encryptedContent = \",\".join(encryptedBlocks)\n    encryptedContent = f\"{len(message)}_{blockSize}_{encryptedContent}\"\n    with open(messageFilename, \"w\") as fo:\n        fo.write(encryptedContent)\n    return encryptedContent\n\n\ndef readFromFileAndDecrypt(messageFilename: str, keyFilename: str) -> str:\n    keySize, n, d = readKeyFile(keyFilename)\n    with open(messageFilename) as fo:\n        content = fo.read()\n    messageLength, blockSize, encryptedMessage = content.split(\"_\")\n    messageLength = int(messageLength)\n    blockSize = int(blockSize)\n\n    if keySize < blockSize * 8:\n        sys.exit(\n            \"ERROR: Block size is %s bits and key size is %s bits. The RSA cipher \"\n            \"requires the block size to be equal to or greater than the key size. \"\n            \"Did you specify the correct key file and encrypted file?\"\n            % (blockSize * 8, keySize)\n        )\n\n    encryptedBlocks = []\n    for block in encryptedMessage.split(\",\"):\n        encryptedBlocks.append(int(block))\n\n    return decryptMessage(encryptedBlocks, messageLength, (n, d), blockSize)\n\n",
        "source_code_len": 3983,
        "target_code": "    elif mode == \"decrypt\":\n        privkey_filename = \"rsa_privkey.txt\"\n        print(\"Reading from %s and decrypting...\" % (filename))\n        decrypted_text = read_from_file_and_decrypt(filename, privkey_filename)\n        print(\"writing decryption to rsa_decryption.txt...\")\n        with open(\"rsa_decryption.txt\", \"w\") as dec:\n            dec.write(decrypted_text)\n\n        print(\"\\nDecryption:\")\n        print(decrypted_text)\n\n",
        "target_code_len": 432,
        "diff_format": "@@ -31,118 +138,11 @@\n     elif mode == \"decrypt\":\n-        privKeyFilename = \"rsa_privkey.txt\"\n+        privkey_filename = \"rsa_privkey.txt\"\n         print(\"Reading from %s and decrypting...\" % (filename))\n-        decryptedText = readFromFileAndDecrypt(filename, privKeyFilename)\n+        decrypted_text = read_from_file_and_decrypt(filename, privkey_filename)\n         print(\"writing decryption to rsa_decryption.txt...\")\n         with open(\"rsa_decryption.txt\", \"w\") as dec:\n-            dec.write(decryptedText)\n+            dec.write(decrypted_text)\n \n         print(\"\\nDecryption:\")\n-        print(decryptedText)\n-\n-\n-def getBlocksFromText(message: int, blockSize: int = DEFAULT_BLOCK_SIZE) -> [int]:\n-    messageBytes = message.encode(\"ascii\")\n-\n-    blockInts = []\n-    for blockStart in range(0, len(messageBytes), blockSize):\n-        blockInt = 0\n-        for i in range(blockStart, min(blockStart + blockSize, len(messageBytes))):\n-            blockInt += messageBytes[i] * (BYTE_SIZE ** (i % blockSize))\n-        blockInts.append(blockInt)\n-    return blockInts\n-\n-\n-def getTextFromBlocks(\n-    blockInts: [int], messageLength: int, blockSize: int = DEFAULT_BLOCK_SIZE\n-) -> str:\n-    message = []\n-    for blockInt in blockInts:\n-        blockMessage = []\n-        for i in range(blockSize - 1, -1, -1):\n-            if len(message) + i < messageLength:\n-                asciiNumber = blockInt // (BYTE_SIZE ** i)\n-                blockInt = blockInt % (BYTE_SIZE ** i)\n-                blockMessage.insert(0, chr(asciiNumber))\n-        message.extend(blockMessage)\n-    return \"\".join(message)\n-\n-\n-def encryptMessage(\n-    message: str, key: (int, int), blockSize: int = DEFAULT_BLOCK_SIZE\n-) -> [int]:\n-    encryptedBlocks = []\n-    n, e = key\n-\n-    for block in getBlocksFromText(message, blockSize):\n-        encryptedBlocks.append(pow(block, e, n))\n-    return encryptedBlocks\n-\n-\n-def decryptMessage(\n-    encryptedBlocks: [int],\n-    messageLength: int,\n-    key: (int, int),\n-    blockSize: int = DEFAULT_BLOCK_SIZE,\n-) -> str:\n-    decryptedBlocks = []\n-    n, d = key\n-    for block in encryptedBlocks:\n-        decryptedBlocks.append(pow(block, d, n))\n-    return getTextFromBlocks(decryptedBlocks, messageLength, blockSize)\n-\n-\n-def readKeyFile(keyFilename: str) -> (int, int, int):\n-    with open(keyFilename) as fo:\n-        content = fo.read()\n-    keySize, n, EorD = content.split(\",\")\n-    return (int(keySize), int(n), int(EorD))\n-\n-\n-def encryptAndWriteToFile(\n-    messageFilename: str,\n-    keyFilename: str,\n-    message: str,\n-    blockSize: int = DEFAULT_BLOCK_SIZE,\n-) -> str:\n-    keySize, n, e = readKeyFile(keyFilename)\n-    if keySize < blockSize * 8:\n-        sys.exit(\n-            \"ERROR: Block size is %s bits and key size is %s bits. The RSA cipher \"\n-            \"requires the block size to be equal to or greater than the key size. \"\n-            \"Either decrease the block size or use different keys.\"\n-            % (blockSize * 8, keySize)\n-        )\n-\n-    encryptedBlocks = encryptMessage(message, (n, e), blockSize)\n-\n-    for i in range(len(encryptedBlocks)):\n-        encryptedBlocks[i] = str(encryptedBlocks[i])\n-    encryptedContent = \",\".join(encryptedBlocks)\n-    encryptedContent = f\"{len(message)}_{blockSize}_{encryptedContent}\"\n-    with open(messageFilename, \"w\") as fo:\n-        fo.write(encryptedContent)\n-    return encryptedContent\n-\n-\n-def readFromFileAndDecrypt(messageFilename: str, keyFilename: str) -> str:\n-    keySize, n, d = readKeyFile(keyFilename)\n-    with open(messageFilename) as fo:\n-        content = fo.read()\n-    messageLength, blockSize, encryptedMessage = content.split(\"_\")\n-    messageLength = int(messageLength)\n-    blockSize = int(blockSize)\n-\n-    if keySize < blockSize * 8:\n-        sys.exit(\n-            \"ERROR: Block size is %s bits and key size is %s bits. The RSA cipher \"\n-            \"requires the block size to be equal to or greater than the key size. \"\n-            \"Did you specify the correct key file and encrypted file?\"\n-            % (blockSize * 8, keySize)\n-        )\n-\n-    encryptedBlocks = []\n-    for block in encryptedMessage.split(\",\"):\n-        encryptedBlocks.append(int(block))\n-\n-    return decryptMessage(encryptedBlocks, messageLength, (n, d), blockSize)\n+        print(decrypted_text)\n \n",
        "source_code_with_indent": "    <DED>elif mode == \"decrypt\":\n        <IND>privKeyFilename = \"rsa_privkey.txt\"\n        print(\"Reading from %s and decrypting...\" % (filename))\n        decryptedText = readFromFileAndDecrypt(filename, privKeyFilename)\n        print(\"writing decryption to rsa_decryption.txt...\")\n        with open(\"rsa_decryption.txt\", \"w\") as dec:\n            <IND>dec.write(decryptedText)\n\n        <DED>print(\"\\nDecryption:\")\n        print(decryptedText)\n\n\n<DED><DED>def getBlocksFromText(message: int, blockSize: int = DEFAULT_BLOCK_SIZE) -> [int]:\n    <IND>messageBytes = message.encode(\"ascii\")\n\n    blockInts = []\n    for blockStart in range(0, len(messageBytes), blockSize):\n        <IND>blockInt = 0\n        for i in range(blockStart, min(blockStart + blockSize, len(messageBytes))):\n            <IND>blockInt += messageBytes[i] * (BYTE_SIZE ** (i % blockSize))\n        <DED>blockInts.append(blockInt)\n    <DED>return blockInts\n\n\n<DED>def getTextFromBlocks(\n    blockInts: [int], messageLength: int, blockSize: int = DEFAULT_BLOCK_SIZE\n) -> str:\n    <IND>message = []\n    for blockInt in blockInts:\n        <IND>blockMessage = []\n        for i in range(blockSize - 1, -1, -1):\n            <IND>if len(message) + i < messageLength:\n                <IND>asciiNumber = blockInt // (BYTE_SIZE ** i)\n                blockInt = blockInt % (BYTE_SIZE ** i)\n                blockMessage.insert(0, chr(asciiNumber))\n        <DED><DED>message.extend(blockMessage)\n    <DED>return \"\".join(message)\n\n\n<DED>def encryptMessage(\n    message: str, key: (int, int), blockSize: int = DEFAULT_BLOCK_SIZE\n) -> [int]:\n    <IND>encryptedBlocks = []\n    n, e = key\n\n    for block in getBlocksFromText(message, blockSize):\n        <IND>encryptedBlocks.append(pow(block, e, n))\n    <DED>return encryptedBlocks\n\n\n<DED>def decryptMessage(\n    encryptedBlocks: [int],\n    messageLength: int,\n    key: (int, int),\n    blockSize: int = DEFAULT_BLOCK_SIZE,\n) -> str:\n    <IND>decryptedBlocks = []\n    n, d = key\n    for block in encryptedBlocks:\n        <IND>decryptedBlocks.append(pow(block, d, n))\n    <DED>return getTextFromBlocks(decryptedBlocks, messageLength, blockSize)\n\n\n<DED>def readKeyFile(keyFilename: str) -> (int, int, int):\n    <IND>with open(keyFilename) as fo:\n        <IND>content = fo.read()\n    <DED>keySize, n, EorD = content.split(\",\")\n    return (int(keySize), int(n), int(EorD))\n\n\n<DED>def encryptAndWriteToFile(\n    messageFilename: str,\n    keyFilename: str,\n    message: str,\n    blockSize: int = DEFAULT_BLOCK_SIZE,\n) -> str:\n    <IND>keySize, n, e = readKeyFile(keyFilename)\n    if keySize < blockSize * 8:\n        <IND>sys.exit(\n            \"ERROR: Block size is %s bits and key size is %s bits. The RSA cipher \"\n            \"requires the block size to be equal to or greater than the key size. \"\n            \"Either decrease the block size or use different keys.\"\n            % (blockSize * 8, keySize)\n        )\n\n    <DED>encryptedBlocks = encryptMessage(message, (n, e), blockSize)\n\n    for i in range(len(encryptedBlocks)):\n        <IND>encryptedBlocks[i] = str(encryptedBlocks[i])\n    <DED>encryptedContent = \",\".join(encryptedBlocks)\n    encryptedContent = f\"{len(message)}_{blockSize}_{encryptedContent}\"\n    with open(messageFilename, \"w\") as fo:\n        <IND>fo.write(encryptedContent)\n    <DED>return encryptedContent\n\n\n<DED>def readFromFileAndDecrypt(messageFilename: str, keyFilename: str) -> str:\n    <IND>keySize, n, d = readKeyFile(keyFilename)\n    with open(messageFilename) as fo:\n        <IND>content = fo.read()\n    <DED>messageLength, blockSize, encryptedMessage = content.split(\"_\")\n    messageLength = int(messageLength)\n    blockSize = int(blockSize)\n\n    if keySize < blockSize * 8:\n        <IND>sys.exit(\n            \"ERROR: Block size is %s bits and key size is %s bits. The RSA cipher \"\n            \"requires the block size to be equal to or greater than the key size. \"\n            \"Did you specify the correct key file and encrypted file?\"\n            % (blockSize * 8, keySize)\n        )\n\n    <DED>encryptedBlocks = []\n    for block in encryptedMessage.split(\",\"):\n        <IND>encryptedBlocks.append(int(block))\n\n    <DED>return decryptMessage(encryptedBlocks, messageLength, (n, d), blockSize)\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    <DED>elif mode == \"decrypt\":\n        <IND>privkey_filename = \"rsa_privkey.txt\"\n        print(\"Reading from %s and decrypting...\" % (filename))\n        decrypted_text = read_from_file_and_decrypt(filename, privkey_filename)\n        print(\"writing decryption to rsa_decryption.txt...\")\n        with open(\"rsa_decryption.txt\", \"w\") as dec:\n            <IND>dec.write(decrypted_text)\n\n        <DED>print(\"\\nDecryption:\")\n        print(decrypted_text)\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "TheAlgorithms/Python",
    "commit": "60895366c0f50844af2737130ed98c2510e90060",
    "filename": "ciphers/rsa_cipher.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/TheAlgorithms-Python/ciphers/rsa_cipher.py",
    "file_hunks_size": 3,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "ciphers/rsa_cipher.py:72:5 Invalid type [31]: Expression `[int]` is not a valid type.",
    "message": " Expression `[int]` is not a valid type.",
    "rule_id": "Invalid type [31]",
    "warning_line_no": 72,
    "warning_line": ") -> [int]:",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    elif mode == \"decrypt\":\n        privKeyFilename = \"rsa_privkey.txt\"\n        print(\"Reading from %s and decrypting...\" % (filename))\n        decryptedText = readFromFileAndDecrypt(filename, privKeyFilename)\n        print(\"writing decryption to rsa_decryption.txt...\")\n        with open(\"rsa_decryption.txt\", \"w\") as dec:\n            dec.write(decryptedText)\n\n        print(\"\\nDecryption:\")\n        print(decryptedText)\n\n\ndef getBlocksFromText(message: int, blockSize: int = DEFAULT_BLOCK_SIZE) -> [int]:\n    messageBytes = message.encode(\"ascii\")\n\n    blockInts = []\n    for blockStart in range(0, len(messageBytes), blockSize):\n        blockInt = 0\n        for i in range(blockStart, min(blockStart + blockSize, len(messageBytes))):\n            blockInt += messageBytes[i] * (BYTE_SIZE ** (i % blockSize))\n        blockInts.append(blockInt)\n    return blockInts\n\n\ndef getTextFromBlocks(\n    blockInts: [int], messageLength: int, blockSize: int = DEFAULT_BLOCK_SIZE\n) -> str:\n    message = []\n    for blockInt in blockInts:\n        blockMessage = []\n        for i in range(blockSize - 1, -1, -1):\n            if len(message) + i < messageLength:\n                asciiNumber = blockInt // (BYTE_SIZE ** i)\n                blockInt = blockInt % (BYTE_SIZE ** i)\n                blockMessage.insert(0, chr(asciiNumber))\n        message.extend(blockMessage)\n    return \"\".join(message)\n\n\ndef encryptMessage(\n    message: str, key: (int, int), blockSize: int = DEFAULT_BLOCK_SIZE\n) -> [int]:\n    encryptedBlocks = []\n    n, e = key\n\n    for block in getBlocksFromText(message, blockSize):\n        encryptedBlocks.append(pow(block, e, n))\n    return encryptedBlocks\n\n\ndef decryptMessage(\n    encryptedBlocks: [int],\n    messageLength: int,\n    key: (int, int),\n    blockSize: int = DEFAULT_BLOCK_SIZE,\n) -> str:\n    decryptedBlocks = []\n    n, d = key\n    for block in encryptedBlocks:\n        decryptedBlocks.append(pow(block, d, n))\n    return getTextFromBlocks(decryptedBlocks, messageLength, blockSize)\n\n\ndef readKeyFile(keyFilename: str) -> (int, int, int):\n    with open(keyFilename) as fo:\n        content = fo.read()\n    keySize, n, EorD = content.split(\",\")\n    return (int(keySize), int(n), int(EorD))\n\n\ndef encryptAndWriteToFile(\n    messageFilename: str,\n    keyFilename: str,\n    message: str,\n    blockSize: int = DEFAULT_BLOCK_SIZE,\n) -> str:\n    keySize, n, e = readKeyFile(keyFilename)\n    if keySize < blockSize * 8:\n        sys.exit(\n            \"ERROR: Block size is %s bits and key size is %s bits. The RSA cipher \"\n            \"requires the block size to be equal to or greater than the key size. \"\n            \"Either decrease the block size or use different keys.\"\n            % (blockSize * 8, keySize)\n        )\n\n    encryptedBlocks = encryptMessage(message, (n, e), blockSize)\n\n    for i in range(len(encryptedBlocks)):\n        encryptedBlocks[i] = str(encryptedBlocks[i])\n    encryptedContent = \",\".join(encryptedBlocks)\n    encryptedContent = f\"{len(message)}_{blockSize}_{encryptedContent}\"\n    with open(messageFilename, \"w\") as fo:\n        fo.write(encryptedContent)\n    return encryptedContent\n\n\ndef readFromFileAndDecrypt(messageFilename: str, keyFilename: str) -> str:\n    keySize, n, d = readKeyFile(keyFilename)\n    with open(messageFilename) as fo:\n        content = fo.read()\n    messageLength, blockSize, encryptedMessage = content.split(\"_\")\n    messageLength = int(messageLength)\n    blockSize = int(blockSize)\n\n    if keySize < blockSize * 8:\n        sys.exit(\n            \"ERROR: Block size is %s bits and key size is %s bits. The RSA cipher \"\n            \"requires the block size to be equal to or greater than the key size. \"\n            \"Did you specify the correct key file and encrypted file?\"\n            % (blockSize * 8, keySize)\n        )\n\n    encryptedBlocks = []\n    for block in encryptedMessage.split(\",\"):\n        encryptedBlocks.append(int(block))\n\n    return decryptMessage(encryptedBlocks, messageLength, (n, d), blockSize)\n\n",
        "source_code_len": 3983,
        "target_code": "    elif mode == \"decrypt\":\n        privkey_filename = \"rsa_privkey.txt\"\n        print(\"Reading from %s and decrypting...\" % (filename))\n        decrypted_text = read_from_file_and_decrypt(filename, privkey_filename)\n        print(\"writing decryption to rsa_decryption.txt...\")\n        with open(\"rsa_decryption.txt\", \"w\") as dec:\n            dec.write(decrypted_text)\n\n        print(\"\\nDecryption:\")\n        print(decrypted_text)\n\n",
        "target_code_len": 432,
        "diff_format": "@@ -31,118 +138,11 @@\n     elif mode == \"decrypt\":\n-        privKeyFilename = \"rsa_privkey.txt\"\n+        privkey_filename = \"rsa_privkey.txt\"\n         print(\"Reading from %s and decrypting...\" % (filename))\n-        decryptedText = readFromFileAndDecrypt(filename, privKeyFilename)\n+        decrypted_text = read_from_file_and_decrypt(filename, privkey_filename)\n         print(\"writing decryption to rsa_decryption.txt...\")\n         with open(\"rsa_decryption.txt\", \"w\") as dec:\n-            dec.write(decryptedText)\n+            dec.write(decrypted_text)\n \n         print(\"\\nDecryption:\")\n-        print(decryptedText)\n-\n-\n-def getBlocksFromText(message: int, blockSize: int = DEFAULT_BLOCK_SIZE) -> [int]:\n-    messageBytes = message.encode(\"ascii\")\n-\n-    blockInts = []\n-    for blockStart in range(0, len(messageBytes), blockSize):\n-        blockInt = 0\n-        for i in range(blockStart, min(blockStart + blockSize, len(messageBytes))):\n-            blockInt += messageBytes[i] * (BYTE_SIZE ** (i % blockSize))\n-        blockInts.append(blockInt)\n-    return blockInts\n-\n-\n-def getTextFromBlocks(\n-    blockInts: [int], messageLength: int, blockSize: int = DEFAULT_BLOCK_SIZE\n-) -> str:\n-    message = []\n-    for blockInt in blockInts:\n-        blockMessage = []\n-        for i in range(blockSize - 1, -1, -1):\n-            if len(message) + i < messageLength:\n-                asciiNumber = blockInt // (BYTE_SIZE ** i)\n-                blockInt = blockInt % (BYTE_SIZE ** i)\n-                blockMessage.insert(0, chr(asciiNumber))\n-        message.extend(blockMessage)\n-    return \"\".join(message)\n-\n-\n-def encryptMessage(\n-    message: str, key: (int, int), blockSize: int = DEFAULT_BLOCK_SIZE\n-) -> [int]:\n-    encryptedBlocks = []\n-    n, e = key\n-\n-    for block in getBlocksFromText(message, blockSize):\n-        encryptedBlocks.append(pow(block, e, n))\n-    return encryptedBlocks\n-\n-\n-def decryptMessage(\n-    encryptedBlocks: [int],\n-    messageLength: int,\n-    key: (int, int),\n-    blockSize: int = DEFAULT_BLOCK_SIZE,\n-) -> str:\n-    decryptedBlocks = []\n-    n, d = key\n-    for block in encryptedBlocks:\n-        decryptedBlocks.append(pow(block, d, n))\n-    return getTextFromBlocks(decryptedBlocks, messageLength, blockSize)\n-\n-\n-def readKeyFile(keyFilename: str) -> (int, int, int):\n-    with open(keyFilename) as fo:\n-        content = fo.read()\n-    keySize, n, EorD = content.split(\",\")\n-    return (int(keySize), int(n), int(EorD))\n-\n-\n-def encryptAndWriteToFile(\n-    messageFilename: str,\n-    keyFilename: str,\n-    message: str,\n-    blockSize: int = DEFAULT_BLOCK_SIZE,\n-) -> str:\n-    keySize, n, e = readKeyFile(keyFilename)\n-    if keySize < blockSize * 8:\n-        sys.exit(\n-            \"ERROR: Block size is %s bits and key size is %s bits. The RSA cipher \"\n-            \"requires the block size to be equal to or greater than the key size. \"\n-            \"Either decrease the block size or use different keys.\"\n-            % (blockSize * 8, keySize)\n-        )\n-\n-    encryptedBlocks = encryptMessage(message, (n, e), blockSize)\n-\n-    for i in range(len(encryptedBlocks)):\n-        encryptedBlocks[i] = str(encryptedBlocks[i])\n-    encryptedContent = \",\".join(encryptedBlocks)\n-    encryptedContent = f\"{len(message)}_{blockSize}_{encryptedContent}\"\n-    with open(messageFilename, \"w\") as fo:\n-        fo.write(encryptedContent)\n-    return encryptedContent\n-\n-\n-def readFromFileAndDecrypt(messageFilename: str, keyFilename: str) -> str:\n-    keySize, n, d = readKeyFile(keyFilename)\n-    with open(messageFilename) as fo:\n-        content = fo.read()\n-    messageLength, blockSize, encryptedMessage = content.split(\"_\")\n-    messageLength = int(messageLength)\n-    blockSize = int(blockSize)\n-\n-    if keySize < blockSize * 8:\n-        sys.exit(\n-            \"ERROR: Block size is %s bits and key size is %s bits. The RSA cipher \"\n-            \"requires the block size to be equal to or greater than the key size. \"\n-            \"Did you specify the correct key file and encrypted file?\"\n-            % (blockSize * 8, keySize)\n-        )\n-\n-    encryptedBlocks = []\n-    for block in encryptedMessage.split(\",\"):\n-        encryptedBlocks.append(int(block))\n-\n-    return decryptMessage(encryptedBlocks, messageLength, (n, d), blockSize)\n+        print(decrypted_text)\n \n",
        "source_code_with_indent": "    <DED>elif mode == \"decrypt\":\n        <IND>privKeyFilename = \"rsa_privkey.txt\"\n        print(\"Reading from %s and decrypting...\" % (filename))\n        decryptedText = readFromFileAndDecrypt(filename, privKeyFilename)\n        print(\"writing decryption to rsa_decryption.txt...\")\n        with open(\"rsa_decryption.txt\", \"w\") as dec:\n            <IND>dec.write(decryptedText)\n\n        <DED>print(\"\\nDecryption:\")\n        print(decryptedText)\n\n\n<DED><DED>def getBlocksFromText(message: int, blockSize: int = DEFAULT_BLOCK_SIZE) -> [int]:\n    <IND>messageBytes = message.encode(\"ascii\")\n\n    blockInts = []\n    for blockStart in range(0, len(messageBytes), blockSize):\n        <IND>blockInt = 0\n        for i in range(blockStart, min(blockStart + blockSize, len(messageBytes))):\n            <IND>blockInt += messageBytes[i] * (BYTE_SIZE ** (i % blockSize))\n        <DED>blockInts.append(blockInt)\n    <DED>return blockInts\n\n\n<DED>def getTextFromBlocks(\n    blockInts: [int], messageLength: int, blockSize: int = DEFAULT_BLOCK_SIZE\n) -> str:\n    <IND>message = []\n    for blockInt in blockInts:\n        <IND>blockMessage = []\n        for i in range(blockSize - 1, -1, -1):\n            <IND>if len(message) + i < messageLength:\n                <IND>asciiNumber = blockInt // (BYTE_SIZE ** i)\n                blockInt = blockInt % (BYTE_SIZE ** i)\n                blockMessage.insert(0, chr(asciiNumber))\n        <DED><DED>message.extend(blockMessage)\n    <DED>return \"\".join(message)\n\n\n<DED>def encryptMessage(\n    message: str, key: (int, int), blockSize: int = DEFAULT_BLOCK_SIZE\n) -> [int]:\n    <IND>encryptedBlocks = []\n    n, e = key\n\n    for block in getBlocksFromText(message, blockSize):\n        <IND>encryptedBlocks.append(pow(block, e, n))\n    <DED>return encryptedBlocks\n\n\n<DED>def decryptMessage(\n    encryptedBlocks: [int],\n    messageLength: int,\n    key: (int, int),\n    blockSize: int = DEFAULT_BLOCK_SIZE,\n) -> str:\n    <IND>decryptedBlocks = []\n    n, d = key\n    for block in encryptedBlocks:\n        <IND>decryptedBlocks.append(pow(block, d, n))\n    <DED>return getTextFromBlocks(decryptedBlocks, messageLength, blockSize)\n\n\n<DED>def readKeyFile(keyFilename: str) -> (int, int, int):\n    <IND>with open(keyFilename) as fo:\n        <IND>content = fo.read()\n    <DED>keySize, n, EorD = content.split(\",\")\n    return (int(keySize), int(n), int(EorD))\n\n\n<DED>def encryptAndWriteToFile(\n    messageFilename: str,\n    keyFilename: str,\n    message: str,\n    blockSize: int = DEFAULT_BLOCK_SIZE,\n) -> str:\n    <IND>keySize, n, e = readKeyFile(keyFilename)\n    if keySize < blockSize * 8:\n        <IND>sys.exit(\n            \"ERROR: Block size is %s bits and key size is %s bits. The RSA cipher \"\n            \"requires the block size to be equal to or greater than the key size. \"\n            \"Either decrease the block size or use different keys.\"\n            % (blockSize * 8, keySize)\n        )\n\n    <DED>encryptedBlocks = encryptMessage(message, (n, e), blockSize)\n\n    for i in range(len(encryptedBlocks)):\n        <IND>encryptedBlocks[i] = str(encryptedBlocks[i])\n    <DED>encryptedContent = \",\".join(encryptedBlocks)\n    encryptedContent = f\"{len(message)}_{blockSize}_{encryptedContent}\"\n    with open(messageFilename, \"w\") as fo:\n        <IND>fo.write(encryptedContent)\n    <DED>return encryptedContent\n\n\n<DED>def readFromFileAndDecrypt(messageFilename: str, keyFilename: str) -> str:\n    <IND>keySize, n, d = readKeyFile(keyFilename)\n    with open(messageFilename) as fo:\n        <IND>content = fo.read()\n    <DED>messageLength, blockSize, encryptedMessage = content.split(\"_\")\n    messageLength = int(messageLength)\n    blockSize = int(blockSize)\n\n    if keySize < blockSize * 8:\n        <IND>sys.exit(\n            \"ERROR: Block size is %s bits and key size is %s bits. The RSA cipher \"\n            \"requires the block size to be equal to or greater than the key size. \"\n            \"Did you specify the correct key file and encrypted file?\"\n            % (blockSize * 8, keySize)\n        )\n\n    <DED>encryptedBlocks = []\n    for block in encryptedMessage.split(\",\"):\n        <IND>encryptedBlocks.append(int(block))\n\n    <DED>return decryptMessage(encryptedBlocks, messageLength, (n, d), blockSize)\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    <DED>elif mode == \"decrypt\":\n        <IND>privkey_filename = \"rsa_privkey.txt\"\n        print(\"Reading from %s and decrypting...\" % (filename))\n        decrypted_text = read_from_file_and_decrypt(filename, privkey_filename)\n        print(\"writing decryption to rsa_decryption.txt...\")\n        with open(\"rsa_decryption.txt\", \"w\") as dec:\n            <IND>dec.write(decrypted_text)\n\n        <DED>print(\"\\nDecryption:\")\n        print(decrypted_text)\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "TheAlgorithms/Python",
    "commit": "60895366c0f50844af2737130ed98c2510e90060",
    "filename": "ciphers/rsa_cipher.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/TheAlgorithms-Python/ciphers/rsa_cipher.py",
    "file_hunks_size": 3,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "ciphers/rsa_cipher.py:76:35 Incompatible parameter type [6]: Expected `int` for 1st positional only parameter to call `getBlocksFromText` but got `str`.",
    "message": " Expected `int` for 1st positional only parameter to call `getBlocksFromText` but got `str`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 76,
    "warning_line": "    for block in getBlocksFromText(message, blockSize):",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    elif mode == \"decrypt\":\n        privKeyFilename = \"rsa_privkey.txt\"\n        print(\"Reading from %s and decrypting...\" % (filename))\n        decryptedText = readFromFileAndDecrypt(filename, privKeyFilename)\n        print(\"writing decryption to rsa_decryption.txt...\")\n        with open(\"rsa_decryption.txt\", \"w\") as dec:\n            dec.write(decryptedText)\n\n        print(\"\\nDecryption:\")\n        print(decryptedText)\n\n\ndef getBlocksFromText(message: int, blockSize: int = DEFAULT_BLOCK_SIZE) -> [int]:\n    messageBytes = message.encode(\"ascii\")\n\n    blockInts = []\n    for blockStart in range(0, len(messageBytes), blockSize):\n        blockInt = 0\n        for i in range(blockStart, min(blockStart + blockSize, len(messageBytes))):\n            blockInt += messageBytes[i] * (BYTE_SIZE ** (i % blockSize))\n        blockInts.append(blockInt)\n    return blockInts\n\n\ndef getTextFromBlocks(\n    blockInts: [int], messageLength: int, blockSize: int = DEFAULT_BLOCK_SIZE\n) -> str:\n    message = []\n    for blockInt in blockInts:\n        blockMessage = []\n        for i in range(blockSize - 1, -1, -1):\n            if len(message) + i < messageLength:\n                asciiNumber = blockInt // (BYTE_SIZE ** i)\n                blockInt = blockInt % (BYTE_SIZE ** i)\n                blockMessage.insert(0, chr(asciiNumber))\n        message.extend(blockMessage)\n    return \"\".join(message)\n\n\ndef encryptMessage(\n    message: str, key: (int, int), blockSize: int = DEFAULT_BLOCK_SIZE\n) -> [int]:\n    encryptedBlocks = []\n    n, e = key\n\n    for block in getBlocksFromText(message, blockSize):\n        encryptedBlocks.append(pow(block, e, n))\n    return encryptedBlocks\n\n\ndef decryptMessage(\n    encryptedBlocks: [int],\n    messageLength: int,\n    key: (int, int),\n    blockSize: int = DEFAULT_BLOCK_SIZE,\n) -> str:\n    decryptedBlocks = []\n    n, d = key\n    for block in encryptedBlocks:\n        decryptedBlocks.append(pow(block, d, n))\n    return getTextFromBlocks(decryptedBlocks, messageLength, blockSize)\n\n\ndef readKeyFile(keyFilename: str) -> (int, int, int):\n    with open(keyFilename) as fo:\n        content = fo.read()\n    keySize, n, EorD = content.split(\",\")\n    return (int(keySize), int(n), int(EorD))\n\n\ndef encryptAndWriteToFile(\n    messageFilename: str,\n    keyFilename: str,\n    message: str,\n    blockSize: int = DEFAULT_BLOCK_SIZE,\n) -> str:\n    keySize, n, e = readKeyFile(keyFilename)\n    if keySize < blockSize * 8:\n        sys.exit(\n            \"ERROR: Block size is %s bits and key size is %s bits. The RSA cipher \"\n            \"requires the block size to be equal to or greater than the key size. \"\n            \"Either decrease the block size or use different keys.\"\n            % (blockSize * 8, keySize)\n        )\n\n    encryptedBlocks = encryptMessage(message, (n, e), blockSize)\n\n    for i in range(len(encryptedBlocks)):\n        encryptedBlocks[i] = str(encryptedBlocks[i])\n    encryptedContent = \",\".join(encryptedBlocks)\n    encryptedContent = f\"{len(message)}_{blockSize}_{encryptedContent}\"\n    with open(messageFilename, \"w\") as fo:\n        fo.write(encryptedContent)\n    return encryptedContent\n\n\ndef readFromFileAndDecrypt(messageFilename: str, keyFilename: str) -> str:\n    keySize, n, d = readKeyFile(keyFilename)\n    with open(messageFilename) as fo:\n        content = fo.read()\n    messageLength, blockSize, encryptedMessage = content.split(\"_\")\n    messageLength = int(messageLength)\n    blockSize = int(blockSize)\n\n    if keySize < blockSize * 8:\n        sys.exit(\n            \"ERROR: Block size is %s bits and key size is %s bits. The RSA cipher \"\n            \"requires the block size to be equal to or greater than the key size. \"\n            \"Did you specify the correct key file and encrypted file?\"\n            % (blockSize * 8, keySize)\n        )\n\n    encryptedBlocks = []\n    for block in encryptedMessage.split(\",\"):\n        encryptedBlocks.append(int(block))\n\n    return decryptMessage(encryptedBlocks, messageLength, (n, d), blockSize)\n\n",
        "source_code_len": 3983,
        "target_code": "    elif mode == \"decrypt\":\n        privkey_filename = \"rsa_privkey.txt\"\n        print(\"Reading from %s and decrypting...\" % (filename))\n        decrypted_text = read_from_file_and_decrypt(filename, privkey_filename)\n        print(\"writing decryption to rsa_decryption.txt...\")\n        with open(\"rsa_decryption.txt\", \"w\") as dec:\n            dec.write(decrypted_text)\n\n        print(\"\\nDecryption:\")\n        print(decrypted_text)\n\n",
        "target_code_len": 432,
        "diff_format": "@@ -31,118 +138,11 @@\n     elif mode == \"decrypt\":\n-        privKeyFilename = \"rsa_privkey.txt\"\n+        privkey_filename = \"rsa_privkey.txt\"\n         print(\"Reading from %s and decrypting...\" % (filename))\n-        decryptedText = readFromFileAndDecrypt(filename, privKeyFilename)\n+        decrypted_text = read_from_file_and_decrypt(filename, privkey_filename)\n         print(\"writing decryption to rsa_decryption.txt...\")\n         with open(\"rsa_decryption.txt\", \"w\") as dec:\n-            dec.write(decryptedText)\n+            dec.write(decrypted_text)\n \n         print(\"\\nDecryption:\")\n-        print(decryptedText)\n-\n-\n-def getBlocksFromText(message: int, blockSize: int = DEFAULT_BLOCK_SIZE) -> [int]:\n-    messageBytes = message.encode(\"ascii\")\n-\n-    blockInts = []\n-    for blockStart in range(0, len(messageBytes), blockSize):\n-        blockInt = 0\n-        for i in range(blockStart, min(blockStart + blockSize, len(messageBytes))):\n-            blockInt += messageBytes[i] * (BYTE_SIZE ** (i % blockSize))\n-        blockInts.append(blockInt)\n-    return blockInts\n-\n-\n-def getTextFromBlocks(\n-    blockInts: [int], messageLength: int, blockSize: int = DEFAULT_BLOCK_SIZE\n-) -> str:\n-    message = []\n-    for blockInt in blockInts:\n-        blockMessage = []\n-        for i in range(blockSize - 1, -1, -1):\n-            if len(message) + i < messageLength:\n-                asciiNumber = blockInt // (BYTE_SIZE ** i)\n-                blockInt = blockInt % (BYTE_SIZE ** i)\n-                blockMessage.insert(0, chr(asciiNumber))\n-        message.extend(blockMessage)\n-    return \"\".join(message)\n-\n-\n-def encryptMessage(\n-    message: str, key: (int, int), blockSize: int = DEFAULT_BLOCK_SIZE\n-) -> [int]:\n-    encryptedBlocks = []\n-    n, e = key\n-\n-    for block in getBlocksFromText(message, blockSize):\n-        encryptedBlocks.append(pow(block, e, n))\n-    return encryptedBlocks\n-\n-\n-def decryptMessage(\n-    encryptedBlocks: [int],\n-    messageLength: int,\n-    key: (int, int),\n-    blockSize: int = DEFAULT_BLOCK_SIZE,\n-) -> str:\n-    decryptedBlocks = []\n-    n, d = key\n-    for block in encryptedBlocks:\n-        decryptedBlocks.append(pow(block, d, n))\n-    return getTextFromBlocks(decryptedBlocks, messageLength, blockSize)\n-\n-\n-def readKeyFile(keyFilename: str) -> (int, int, int):\n-    with open(keyFilename) as fo:\n-        content = fo.read()\n-    keySize, n, EorD = content.split(\",\")\n-    return (int(keySize), int(n), int(EorD))\n-\n-\n-def encryptAndWriteToFile(\n-    messageFilename: str,\n-    keyFilename: str,\n-    message: str,\n-    blockSize: int = DEFAULT_BLOCK_SIZE,\n-) -> str:\n-    keySize, n, e = readKeyFile(keyFilename)\n-    if keySize < blockSize * 8:\n-        sys.exit(\n-            \"ERROR: Block size is %s bits and key size is %s bits. The RSA cipher \"\n-            \"requires the block size to be equal to or greater than the key size. \"\n-            \"Either decrease the block size or use different keys.\"\n-            % (blockSize * 8, keySize)\n-        )\n-\n-    encryptedBlocks = encryptMessage(message, (n, e), blockSize)\n-\n-    for i in range(len(encryptedBlocks)):\n-        encryptedBlocks[i] = str(encryptedBlocks[i])\n-    encryptedContent = \",\".join(encryptedBlocks)\n-    encryptedContent = f\"{len(message)}_{blockSize}_{encryptedContent}\"\n-    with open(messageFilename, \"w\") as fo:\n-        fo.write(encryptedContent)\n-    return encryptedContent\n-\n-\n-def readFromFileAndDecrypt(messageFilename: str, keyFilename: str) -> str:\n-    keySize, n, d = readKeyFile(keyFilename)\n-    with open(messageFilename) as fo:\n-        content = fo.read()\n-    messageLength, blockSize, encryptedMessage = content.split(\"_\")\n-    messageLength = int(messageLength)\n-    blockSize = int(blockSize)\n-\n-    if keySize < blockSize * 8:\n-        sys.exit(\n-            \"ERROR: Block size is %s bits and key size is %s bits. The RSA cipher \"\n-            \"requires the block size to be equal to or greater than the key size. \"\n-            \"Did you specify the correct key file and encrypted file?\"\n-            % (blockSize * 8, keySize)\n-        )\n-\n-    encryptedBlocks = []\n-    for block in encryptedMessage.split(\",\"):\n-        encryptedBlocks.append(int(block))\n-\n-    return decryptMessage(encryptedBlocks, messageLength, (n, d), blockSize)\n+        print(decrypted_text)\n \n",
        "source_code_with_indent": "    <DED>elif mode == \"decrypt\":\n        <IND>privKeyFilename = \"rsa_privkey.txt\"\n        print(\"Reading from %s and decrypting...\" % (filename))\n        decryptedText = readFromFileAndDecrypt(filename, privKeyFilename)\n        print(\"writing decryption to rsa_decryption.txt...\")\n        with open(\"rsa_decryption.txt\", \"w\") as dec:\n            <IND>dec.write(decryptedText)\n\n        <DED>print(\"\\nDecryption:\")\n        print(decryptedText)\n\n\n<DED><DED>def getBlocksFromText(message: int, blockSize: int = DEFAULT_BLOCK_SIZE) -> [int]:\n    <IND>messageBytes = message.encode(\"ascii\")\n\n    blockInts = []\n    for blockStart in range(0, len(messageBytes), blockSize):\n        <IND>blockInt = 0\n        for i in range(blockStart, min(blockStart + blockSize, len(messageBytes))):\n            <IND>blockInt += messageBytes[i] * (BYTE_SIZE ** (i % blockSize))\n        <DED>blockInts.append(blockInt)\n    <DED>return blockInts\n\n\n<DED>def getTextFromBlocks(\n    blockInts: [int], messageLength: int, blockSize: int = DEFAULT_BLOCK_SIZE\n) -> str:\n    <IND>message = []\n    for blockInt in blockInts:\n        <IND>blockMessage = []\n        for i in range(blockSize - 1, -1, -1):\n            <IND>if len(message) + i < messageLength:\n                <IND>asciiNumber = blockInt // (BYTE_SIZE ** i)\n                blockInt = blockInt % (BYTE_SIZE ** i)\n                blockMessage.insert(0, chr(asciiNumber))\n        <DED><DED>message.extend(blockMessage)\n    <DED>return \"\".join(message)\n\n\n<DED>def encryptMessage(\n    message: str, key: (int, int), blockSize: int = DEFAULT_BLOCK_SIZE\n) -> [int]:\n    <IND>encryptedBlocks = []\n    n, e = key\n\n    for block in getBlocksFromText(message, blockSize):\n        <IND>encryptedBlocks.append(pow(block, e, n))\n    <DED>return encryptedBlocks\n\n\n<DED>def decryptMessage(\n    encryptedBlocks: [int],\n    messageLength: int,\n    key: (int, int),\n    blockSize: int = DEFAULT_BLOCK_SIZE,\n) -> str:\n    <IND>decryptedBlocks = []\n    n, d = key\n    for block in encryptedBlocks:\n        <IND>decryptedBlocks.append(pow(block, d, n))\n    <DED>return getTextFromBlocks(decryptedBlocks, messageLength, blockSize)\n\n\n<DED>def readKeyFile(keyFilename: str) -> (int, int, int):\n    <IND>with open(keyFilename) as fo:\n        <IND>content = fo.read()\n    <DED>keySize, n, EorD = content.split(\",\")\n    return (int(keySize), int(n), int(EorD))\n\n\n<DED>def encryptAndWriteToFile(\n    messageFilename: str,\n    keyFilename: str,\n    message: str,\n    blockSize: int = DEFAULT_BLOCK_SIZE,\n) -> str:\n    <IND>keySize, n, e = readKeyFile(keyFilename)\n    if keySize < blockSize * 8:\n        <IND>sys.exit(\n            \"ERROR: Block size is %s bits and key size is %s bits. The RSA cipher \"\n            \"requires the block size to be equal to or greater than the key size. \"\n            \"Either decrease the block size or use different keys.\"\n            % (blockSize * 8, keySize)\n        )\n\n    <DED>encryptedBlocks = encryptMessage(message, (n, e), blockSize)\n\n    for i in range(len(encryptedBlocks)):\n        <IND>encryptedBlocks[i] = str(encryptedBlocks[i])\n    <DED>encryptedContent = \",\".join(encryptedBlocks)\n    encryptedContent = f\"{len(message)}_{blockSize}_{encryptedContent}\"\n    with open(messageFilename, \"w\") as fo:\n        <IND>fo.write(encryptedContent)\n    <DED>return encryptedContent\n\n\n<DED>def readFromFileAndDecrypt(messageFilename: str, keyFilename: str) -> str:\n    <IND>keySize, n, d = readKeyFile(keyFilename)\n    with open(messageFilename) as fo:\n        <IND>content = fo.read()\n    <DED>messageLength, blockSize, encryptedMessage = content.split(\"_\")\n    messageLength = int(messageLength)\n    blockSize = int(blockSize)\n\n    if keySize < blockSize * 8:\n        <IND>sys.exit(\n            \"ERROR: Block size is %s bits and key size is %s bits. The RSA cipher \"\n            \"requires the block size to be equal to or greater than the key size. \"\n            \"Did you specify the correct key file and encrypted file?\"\n            % (blockSize * 8, keySize)\n        )\n\n    <DED>encryptedBlocks = []\n    for block in encryptedMessage.split(\",\"):\n        <IND>encryptedBlocks.append(int(block))\n\n    <DED>return decryptMessage(encryptedBlocks, messageLength, (n, d), blockSize)\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    <DED>elif mode == \"decrypt\":\n        <IND>privkey_filename = \"rsa_privkey.txt\"\n        print(\"Reading from %s and decrypting...\" % (filename))\n        decrypted_text = read_from_file_and_decrypt(filename, privkey_filename)\n        print(\"writing decryption to rsa_decryption.txt...\")\n        with open(\"rsa_decryption.txt\", \"w\") as dec:\n            <IND>dec.write(decrypted_text)\n\n        <DED>print(\"\\nDecryption:\")\n        print(decrypted_text)\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "TheAlgorithms/Python",
    "commit": "60895366c0f50844af2737130ed98c2510e90060",
    "filename": "ciphers/rsa_cipher.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/TheAlgorithms-Python/ciphers/rsa_cipher.py",
    "file_hunks_size": 3,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "ciphers/rsa_cipher.py:82:21 Invalid type [31]: Expression `[int]` is not a valid type.",
    "message": " Expression `[int]` is not a valid type.",
    "rule_id": "Invalid type [31]",
    "warning_line_no": 82,
    "warning_line": "    encryptedBlocks: [int],",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    elif mode == \"decrypt\":\n        privKeyFilename = \"rsa_privkey.txt\"\n        print(\"Reading from %s and decrypting...\" % (filename))\n        decryptedText = readFromFileAndDecrypt(filename, privKeyFilename)\n        print(\"writing decryption to rsa_decryption.txt...\")\n        with open(\"rsa_decryption.txt\", \"w\") as dec:\n            dec.write(decryptedText)\n\n        print(\"\\nDecryption:\")\n        print(decryptedText)\n\n\ndef getBlocksFromText(message: int, blockSize: int = DEFAULT_BLOCK_SIZE) -> [int]:\n    messageBytes = message.encode(\"ascii\")\n\n    blockInts = []\n    for blockStart in range(0, len(messageBytes), blockSize):\n        blockInt = 0\n        for i in range(blockStart, min(blockStart + blockSize, len(messageBytes))):\n            blockInt += messageBytes[i] * (BYTE_SIZE ** (i % blockSize))\n        blockInts.append(blockInt)\n    return blockInts\n\n\ndef getTextFromBlocks(\n    blockInts: [int], messageLength: int, blockSize: int = DEFAULT_BLOCK_SIZE\n) -> str:\n    message = []\n    for blockInt in blockInts:\n        blockMessage = []\n        for i in range(blockSize - 1, -1, -1):\n            if len(message) + i < messageLength:\n                asciiNumber = blockInt // (BYTE_SIZE ** i)\n                blockInt = blockInt % (BYTE_SIZE ** i)\n                blockMessage.insert(0, chr(asciiNumber))\n        message.extend(blockMessage)\n    return \"\".join(message)\n\n\ndef encryptMessage(\n    message: str, key: (int, int), blockSize: int = DEFAULT_BLOCK_SIZE\n) -> [int]:\n    encryptedBlocks = []\n    n, e = key\n\n    for block in getBlocksFromText(message, blockSize):\n        encryptedBlocks.append(pow(block, e, n))\n    return encryptedBlocks\n\n\ndef decryptMessage(\n    encryptedBlocks: [int],\n    messageLength: int,\n    key: (int, int),\n    blockSize: int = DEFAULT_BLOCK_SIZE,\n) -> str:\n    decryptedBlocks = []\n    n, d = key\n    for block in encryptedBlocks:\n        decryptedBlocks.append(pow(block, d, n))\n    return getTextFromBlocks(decryptedBlocks, messageLength, blockSize)\n\n\ndef readKeyFile(keyFilename: str) -> (int, int, int):\n    with open(keyFilename) as fo:\n        content = fo.read()\n    keySize, n, EorD = content.split(\",\")\n    return (int(keySize), int(n), int(EorD))\n\n\ndef encryptAndWriteToFile(\n    messageFilename: str,\n    keyFilename: str,\n    message: str,\n    blockSize: int = DEFAULT_BLOCK_SIZE,\n) -> str:\n    keySize, n, e = readKeyFile(keyFilename)\n    if keySize < blockSize * 8:\n        sys.exit(\n            \"ERROR: Block size is %s bits and key size is %s bits. The RSA cipher \"\n            \"requires the block size to be equal to or greater than the key size. \"\n            \"Either decrease the block size or use different keys.\"\n            % (blockSize * 8, keySize)\n        )\n\n    encryptedBlocks = encryptMessage(message, (n, e), blockSize)\n\n    for i in range(len(encryptedBlocks)):\n        encryptedBlocks[i] = str(encryptedBlocks[i])\n    encryptedContent = \",\".join(encryptedBlocks)\n    encryptedContent = f\"{len(message)}_{blockSize}_{encryptedContent}\"\n    with open(messageFilename, \"w\") as fo:\n        fo.write(encryptedContent)\n    return encryptedContent\n\n\ndef readFromFileAndDecrypt(messageFilename: str, keyFilename: str) -> str:\n    keySize, n, d = readKeyFile(keyFilename)\n    with open(messageFilename) as fo:\n        content = fo.read()\n    messageLength, blockSize, encryptedMessage = content.split(\"_\")\n    messageLength = int(messageLength)\n    blockSize = int(blockSize)\n\n    if keySize < blockSize * 8:\n        sys.exit(\n            \"ERROR: Block size is %s bits and key size is %s bits. The RSA cipher \"\n            \"requires the block size to be equal to or greater than the key size. \"\n            \"Did you specify the correct key file and encrypted file?\"\n            % (blockSize * 8, keySize)\n        )\n\n    encryptedBlocks = []\n    for block in encryptedMessage.split(\",\"):\n        encryptedBlocks.append(int(block))\n\n    return decryptMessage(encryptedBlocks, messageLength, (n, d), blockSize)\n\n",
        "source_code_len": 3983,
        "target_code": "    elif mode == \"decrypt\":\n        privkey_filename = \"rsa_privkey.txt\"\n        print(\"Reading from %s and decrypting...\" % (filename))\n        decrypted_text = read_from_file_and_decrypt(filename, privkey_filename)\n        print(\"writing decryption to rsa_decryption.txt...\")\n        with open(\"rsa_decryption.txt\", \"w\") as dec:\n            dec.write(decrypted_text)\n\n        print(\"\\nDecryption:\")\n        print(decrypted_text)\n\n",
        "target_code_len": 432,
        "diff_format": "@@ -31,118 +138,11 @@\n     elif mode == \"decrypt\":\n-        privKeyFilename = \"rsa_privkey.txt\"\n+        privkey_filename = \"rsa_privkey.txt\"\n         print(\"Reading from %s and decrypting...\" % (filename))\n-        decryptedText = readFromFileAndDecrypt(filename, privKeyFilename)\n+        decrypted_text = read_from_file_and_decrypt(filename, privkey_filename)\n         print(\"writing decryption to rsa_decryption.txt...\")\n         with open(\"rsa_decryption.txt\", \"w\") as dec:\n-            dec.write(decryptedText)\n+            dec.write(decrypted_text)\n \n         print(\"\\nDecryption:\")\n-        print(decryptedText)\n-\n-\n-def getBlocksFromText(message: int, blockSize: int = DEFAULT_BLOCK_SIZE) -> [int]:\n-    messageBytes = message.encode(\"ascii\")\n-\n-    blockInts = []\n-    for blockStart in range(0, len(messageBytes), blockSize):\n-        blockInt = 0\n-        for i in range(blockStart, min(blockStart + blockSize, len(messageBytes))):\n-            blockInt += messageBytes[i] * (BYTE_SIZE ** (i % blockSize))\n-        blockInts.append(blockInt)\n-    return blockInts\n-\n-\n-def getTextFromBlocks(\n-    blockInts: [int], messageLength: int, blockSize: int = DEFAULT_BLOCK_SIZE\n-) -> str:\n-    message = []\n-    for blockInt in blockInts:\n-        blockMessage = []\n-        for i in range(blockSize - 1, -1, -1):\n-            if len(message) + i < messageLength:\n-                asciiNumber = blockInt // (BYTE_SIZE ** i)\n-                blockInt = blockInt % (BYTE_SIZE ** i)\n-                blockMessage.insert(0, chr(asciiNumber))\n-        message.extend(blockMessage)\n-    return \"\".join(message)\n-\n-\n-def encryptMessage(\n-    message: str, key: (int, int), blockSize: int = DEFAULT_BLOCK_SIZE\n-) -> [int]:\n-    encryptedBlocks = []\n-    n, e = key\n-\n-    for block in getBlocksFromText(message, blockSize):\n-        encryptedBlocks.append(pow(block, e, n))\n-    return encryptedBlocks\n-\n-\n-def decryptMessage(\n-    encryptedBlocks: [int],\n-    messageLength: int,\n-    key: (int, int),\n-    blockSize: int = DEFAULT_BLOCK_SIZE,\n-) -> str:\n-    decryptedBlocks = []\n-    n, d = key\n-    for block in encryptedBlocks:\n-        decryptedBlocks.append(pow(block, d, n))\n-    return getTextFromBlocks(decryptedBlocks, messageLength, blockSize)\n-\n-\n-def readKeyFile(keyFilename: str) -> (int, int, int):\n-    with open(keyFilename) as fo:\n-        content = fo.read()\n-    keySize, n, EorD = content.split(\",\")\n-    return (int(keySize), int(n), int(EorD))\n-\n-\n-def encryptAndWriteToFile(\n-    messageFilename: str,\n-    keyFilename: str,\n-    message: str,\n-    blockSize: int = DEFAULT_BLOCK_SIZE,\n-) -> str:\n-    keySize, n, e = readKeyFile(keyFilename)\n-    if keySize < blockSize * 8:\n-        sys.exit(\n-            \"ERROR: Block size is %s bits and key size is %s bits. The RSA cipher \"\n-            \"requires the block size to be equal to or greater than the key size. \"\n-            \"Either decrease the block size or use different keys.\"\n-            % (blockSize * 8, keySize)\n-        )\n-\n-    encryptedBlocks = encryptMessage(message, (n, e), blockSize)\n-\n-    for i in range(len(encryptedBlocks)):\n-        encryptedBlocks[i] = str(encryptedBlocks[i])\n-    encryptedContent = \",\".join(encryptedBlocks)\n-    encryptedContent = f\"{len(message)}_{blockSize}_{encryptedContent}\"\n-    with open(messageFilename, \"w\") as fo:\n-        fo.write(encryptedContent)\n-    return encryptedContent\n-\n-\n-def readFromFileAndDecrypt(messageFilename: str, keyFilename: str) -> str:\n-    keySize, n, d = readKeyFile(keyFilename)\n-    with open(messageFilename) as fo:\n-        content = fo.read()\n-    messageLength, blockSize, encryptedMessage = content.split(\"_\")\n-    messageLength = int(messageLength)\n-    blockSize = int(blockSize)\n-\n-    if keySize < blockSize * 8:\n-        sys.exit(\n-            \"ERROR: Block size is %s bits and key size is %s bits. The RSA cipher \"\n-            \"requires the block size to be equal to or greater than the key size. \"\n-            \"Did you specify the correct key file and encrypted file?\"\n-            % (blockSize * 8, keySize)\n-        )\n-\n-    encryptedBlocks = []\n-    for block in encryptedMessage.split(\",\"):\n-        encryptedBlocks.append(int(block))\n-\n-    return decryptMessage(encryptedBlocks, messageLength, (n, d), blockSize)\n+        print(decrypted_text)\n \n",
        "source_code_with_indent": "    <DED>elif mode == \"decrypt\":\n        <IND>privKeyFilename = \"rsa_privkey.txt\"\n        print(\"Reading from %s and decrypting...\" % (filename))\n        decryptedText = readFromFileAndDecrypt(filename, privKeyFilename)\n        print(\"writing decryption to rsa_decryption.txt...\")\n        with open(\"rsa_decryption.txt\", \"w\") as dec:\n            <IND>dec.write(decryptedText)\n\n        <DED>print(\"\\nDecryption:\")\n        print(decryptedText)\n\n\n<DED><DED>def getBlocksFromText(message: int, blockSize: int = DEFAULT_BLOCK_SIZE) -> [int]:\n    <IND>messageBytes = message.encode(\"ascii\")\n\n    blockInts = []\n    for blockStart in range(0, len(messageBytes), blockSize):\n        <IND>blockInt = 0\n        for i in range(blockStart, min(blockStart + blockSize, len(messageBytes))):\n            <IND>blockInt += messageBytes[i] * (BYTE_SIZE ** (i % blockSize))\n        <DED>blockInts.append(blockInt)\n    <DED>return blockInts\n\n\n<DED>def getTextFromBlocks(\n    blockInts: [int], messageLength: int, blockSize: int = DEFAULT_BLOCK_SIZE\n) -> str:\n    <IND>message = []\n    for blockInt in blockInts:\n        <IND>blockMessage = []\n        for i in range(blockSize - 1, -1, -1):\n            <IND>if len(message) + i < messageLength:\n                <IND>asciiNumber = blockInt // (BYTE_SIZE ** i)\n                blockInt = blockInt % (BYTE_SIZE ** i)\n                blockMessage.insert(0, chr(asciiNumber))\n        <DED><DED>message.extend(blockMessage)\n    <DED>return \"\".join(message)\n\n\n<DED>def encryptMessage(\n    message: str, key: (int, int), blockSize: int = DEFAULT_BLOCK_SIZE\n) -> [int]:\n    <IND>encryptedBlocks = []\n    n, e = key\n\n    for block in getBlocksFromText(message, blockSize):\n        <IND>encryptedBlocks.append(pow(block, e, n))\n    <DED>return encryptedBlocks\n\n\n<DED>def decryptMessage(\n    encryptedBlocks: [int],\n    messageLength: int,\n    key: (int, int),\n    blockSize: int = DEFAULT_BLOCK_SIZE,\n) -> str:\n    <IND>decryptedBlocks = []\n    n, d = key\n    for block in encryptedBlocks:\n        <IND>decryptedBlocks.append(pow(block, d, n))\n    <DED>return getTextFromBlocks(decryptedBlocks, messageLength, blockSize)\n\n\n<DED>def readKeyFile(keyFilename: str) -> (int, int, int):\n    <IND>with open(keyFilename) as fo:\n        <IND>content = fo.read()\n    <DED>keySize, n, EorD = content.split(\",\")\n    return (int(keySize), int(n), int(EorD))\n\n\n<DED>def encryptAndWriteToFile(\n    messageFilename: str,\n    keyFilename: str,\n    message: str,\n    blockSize: int = DEFAULT_BLOCK_SIZE,\n) -> str:\n    <IND>keySize, n, e = readKeyFile(keyFilename)\n    if keySize < blockSize * 8:\n        <IND>sys.exit(\n            \"ERROR: Block size is %s bits and key size is %s bits. The RSA cipher \"\n            \"requires the block size to be equal to or greater than the key size. \"\n            \"Either decrease the block size or use different keys.\"\n            % (blockSize * 8, keySize)\n        )\n\n    <DED>encryptedBlocks = encryptMessage(message, (n, e), blockSize)\n\n    for i in range(len(encryptedBlocks)):\n        <IND>encryptedBlocks[i] = str(encryptedBlocks[i])\n    <DED>encryptedContent = \",\".join(encryptedBlocks)\n    encryptedContent = f\"{len(message)}_{blockSize}_{encryptedContent}\"\n    with open(messageFilename, \"w\") as fo:\n        <IND>fo.write(encryptedContent)\n    <DED>return encryptedContent\n\n\n<DED>def readFromFileAndDecrypt(messageFilename: str, keyFilename: str) -> str:\n    <IND>keySize, n, d = readKeyFile(keyFilename)\n    with open(messageFilename) as fo:\n        <IND>content = fo.read()\n    <DED>messageLength, blockSize, encryptedMessage = content.split(\"_\")\n    messageLength = int(messageLength)\n    blockSize = int(blockSize)\n\n    if keySize < blockSize * 8:\n        <IND>sys.exit(\n            \"ERROR: Block size is %s bits and key size is %s bits. The RSA cipher \"\n            \"requires the block size to be equal to or greater than the key size. \"\n            \"Did you specify the correct key file and encrypted file?\"\n            % (blockSize * 8, keySize)\n        )\n\n    <DED>encryptedBlocks = []\n    for block in encryptedMessage.split(\",\"):\n        <IND>encryptedBlocks.append(int(block))\n\n    <DED>return decryptMessage(encryptedBlocks, messageLength, (n, d), blockSize)\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    <DED>elif mode == \"decrypt\":\n        <IND>privkey_filename = \"rsa_privkey.txt\"\n        print(\"Reading from %s and decrypting...\" % (filename))\n        decrypted_text = read_from_file_and_decrypt(filename, privkey_filename)\n        print(\"writing decryption to rsa_decryption.txt...\")\n        with open(\"rsa_decryption.txt\", \"w\") as dec:\n            <IND>dec.write(decrypted_text)\n\n        <DED>print(\"\\nDecryption:\")\n        print(decrypted_text)\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "TheAlgorithms/Python",
    "commit": "60895366c0f50844af2737130ed98c2510e90060",
    "filename": "ciphers/rsa_cipher.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/TheAlgorithms-Python/ciphers/rsa_cipher.py",
    "file_hunks_size": 3,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "ciphers/rsa_cipher.py:84:10 Invalid type [31]: Expression `(int, int)` is not a valid type.",
    "message": " Expression `(int, int)` is not a valid type.",
    "rule_id": "Invalid type [31]",
    "warning_line_no": 84,
    "warning_line": "    key: (int, int),",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    elif mode == \"decrypt\":\n        privKeyFilename = \"rsa_privkey.txt\"\n        print(\"Reading from %s and decrypting...\" % (filename))\n        decryptedText = readFromFileAndDecrypt(filename, privKeyFilename)\n        print(\"writing decryption to rsa_decryption.txt...\")\n        with open(\"rsa_decryption.txt\", \"w\") as dec:\n            dec.write(decryptedText)\n\n        print(\"\\nDecryption:\")\n        print(decryptedText)\n\n\ndef getBlocksFromText(message: int, blockSize: int = DEFAULT_BLOCK_SIZE) -> [int]:\n    messageBytes = message.encode(\"ascii\")\n\n    blockInts = []\n    for blockStart in range(0, len(messageBytes), blockSize):\n        blockInt = 0\n        for i in range(blockStart, min(blockStart + blockSize, len(messageBytes))):\n            blockInt += messageBytes[i] * (BYTE_SIZE ** (i % blockSize))\n        blockInts.append(blockInt)\n    return blockInts\n\n\ndef getTextFromBlocks(\n    blockInts: [int], messageLength: int, blockSize: int = DEFAULT_BLOCK_SIZE\n) -> str:\n    message = []\n    for blockInt in blockInts:\n        blockMessage = []\n        for i in range(blockSize - 1, -1, -1):\n            if len(message) + i < messageLength:\n                asciiNumber = blockInt // (BYTE_SIZE ** i)\n                blockInt = blockInt % (BYTE_SIZE ** i)\n                blockMessage.insert(0, chr(asciiNumber))\n        message.extend(blockMessage)\n    return \"\".join(message)\n\n\ndef encryptMessage(\n    message: str, key: (int, int), blockSize: int = DEFAULT_BLOCK_SIZE\n) -> [int]:\n    encryptedBlocks = []\n    n, e = key\n\n    for block in getBlocksFromText(message, blockSize):\n        encryptedBlocks.append(pow(block, e, n))\n    return encryptedBlocks\n\n\ndef decryptMessage(\n    encryptedBlocks: [int],\n    messageLength: int,\n    key: (int, int),\n    blockSize: int = DEFAULT_BLOCK_SIZE,\n) -> str:\n    decryptedBlocks = []\n    n, d = key\n    for block in encryptedBlocks:\n        decryptedBlocks.append(pow(block, d, n))\n    return getTextFromBlocks(decryptedBlocks, messageLength, blockSize)\n\n\ndef readKeyFile(keyFilename: str) -> (int, int, int):\n    with open(keyFilename) as fo:\n        content = fo.read()\n    keySize, n, EorD = content.split(\",\")\n    return (int(keySize), int(n), int(EorD))\n\n\ndef encryptAndWriteToFile(\n    messageFilename: str,\n    keyFilename: str,\n    message: str,\n    blockSize: int = DEFAULT_BLOCK_SIZE,\n) -> str:\n    keySize, n, e = readKeyFile(keyFilename)\n    if keySize < blockSize * 8:\n        sys.exit(\n            \"ERROR: Block size is %s bits and key size is %s bits. The RSA cipher \"\n            \"requires the block size to be equal to or greater than the key size. \"\n            \"Either decrease the block size or use different keys.\"\n            % (blockSize * 8, keySize)\n        )\n\n    encryptedBlocks = encryptMessage(message, (n, e), blockSize)\n\n    for i in range(len(encryptedBlocks)):\n        encryptedBlocks[i] = str(encryptedBlocks[i])\n    encryptedContent = \",\".join(encryptedBlocks)\n    encryptedContent = f\"{len(message)}_{blockSize}_{encryptedContent}\"\n    with open(messageFilename, \"w\") as fo:\n        fo.write(encryptedContent)\n    return encryptedContent\n\n\ndef readFromFileAndDecrypt(messageFilename: str, keyFilename: str) -> str:\n    keySize, n, d = readKeyFile(keyFilename)\n    with open(messageFilename) as fo:\n        content = fo.read()\n    messageLength, blockSize, encryptedMessage = content.split(\"_\")\n    messageLength = int(messageLength)\n    blockSize = int(blockSize)\n\n    if keySize < blockSize * 8:\n        sys.exit(\n            \"ERROR: Block size is %s bits and key size is %s bits. The RSA cipher \"\n            \"requires the block size to be equal to or greater than the key size. \"\n            \"Did you specify the correct key file and encrypted file?\"\n            % (blockSize * 8, keySize)\n        )\n\n    encryptedBlocks = []\n    for block in encryptedMessage.split(\",\"):\n        encryptedBlocks.append(int(block))\n\n    return decryptMessage(encryptedBlocks, messageLength, (n, d), blockSize)\n\n",
        "source_code_len": 3983,
        "target_code": "    elif mode == \"decrypt\":\n        privkey_filename = \"rsa_privkey.txt\"\n        print(\"Reading from %s and decrypting...\" % (filename))\n        decrypted_text = read_from_file_and_decrypt(filename, privkey_filename)\n        print(\"writing decryption to rsa_decryption.txt...\")\n        with open(\"rsa_decryption.txt\", \"w\") as dec:\n            dec.write(decrypted_text)\n\n        print(\"\\nDecryption:\")\n        print(decrypted_text)\n\n",
        "target_code_len": 432,
        "diff_format": "@@ -31,118 +138,11 @@\n     elif mode == \"decrypt\":\n-        privKeyFilename = \"rsa_privkey.txt\"\n+        privkey_filename = \"rsa_privkey.txt\"\n         print(\"Reading from %s and decrypting...\" % (filename))\n-        decryptedText = readFromFileAndDecrypt(filename, privKeyFilename)\n+        decrypted_text = read_from_file_and_decrypt(filename, privkey_filename)\n         print(\"writing decryption to rsa_decryption.txt...\")\n         with open(\"rsa_decryption.txt\", \"w\") as dec:\n-            dec.write(decryptedText)\n+            dec.write(decrypted_text)\n \n         print(\"\\nDecryption:\")\n-        print(decryptedText)\n-\n-\n-def getBlocksFromText(message: int, blockSize: int = DEFAULT_BLOCK_SIZE) -> [int]:\n-    messageBytes = message.encode(\"ascii\")\n-\n-    blockInts = []\n-    for blockStart in range(0, len(messageBytes), blockSize):\n-        blockInt = 0\n-        for i in range(blockStart, min(blockStart + blockSize, len(messageBytes))):\n-            blockInt += messageBytes[i] * (BYTE_SIZE ** (i % blockSize))\n-        blockInts.append(blockInt)\n-    return blockInts\n-\n-\n-def getTextFromBlocks(\n-    blockInts: [int], messageLength: int, blockSize: int = DEFAULT_BLOCK_SIZE\n-) -> str:\n-    message = []\n-    for blockInt in blockInts:\n-        blockMessage = []\n-        for i in range(blockSize - 1, -1, -1):\n-            if len(message) + i < messageLength:\n-                asciiNumber = blockInt // (BYTE_SIZE ** i)\n-                blockInt = blockInt % (BYTE_SIZE ** i)\n-                blockMessage.insert(0, chr(asciiNumber))\n-        message.extend(blockMessage)\n-    return \"\".join(message)\n-\n-\n-def encryptMessage(\n-    message: str, key: (int, int), blockSize: int = DEFAULT_BLOCK_SIZE\n-) -> [int]:\n-    encryptedBlocks = []\n-    n, e = key\n-\n-    for block in getBlocksFromText(message, blockSize):\n-        encryptedBlocks.append(pow(block, e, n))\n-    return encryptedBlocks\n-\n-\n-def decryptMessage(\n-    encryptedBlocks: [int],\n-    messageLength: int,\n-    key: (int, int),\n-    blockSize: int = DEFAULT_BLOCK_SIZE,\n-) -> str:\n-    decryptedBlocks = []\n-    n, d = key\n-    for block in encryptedBlocks:\n-        decryptedBlocks.append(pow(block, d, n))\n-    return getTextFromBlocks(decryptedBlocks, messageLength, blockSize)\n-\n-\n-def readKeyFile(keyFilename: str) -> (int, int, int):\n-    with open(keyFilename) as fo:\n-        content = fo.read()\n-    keySize, n, EorD = content.split(\",\")\n-    return (int(keySize), int(n), int(EorD))\n-\n-\n-def encryptAndWriteToFile(\n-    messageFilename: str,\n-    keyFilename: str,\n-    message: str,\n-    blockSize: int = DEFAULT_BLOCK_SIZE,\n-) -> str:\n-    keySize, n, e = readKeyFile(keyFilename)\n-    if keySize < blockSize * 8:\n-        sys.exit(\n-            \"ERROR: Block size is %s bits and key size is %s bits. The RSA cipher \"\n-            \"requires the block size to be equal to or greater than the key size. \"\n-            \"Either decrease the block size or use different keys.\"\n-            % (blockSize * 8, keySize)\n-        )\n-\n-    encryptedBlocks = encryptMessage(message, (n, e), blockSize)\n-\n-    for i in range(len(encryptedBlocks)):\n-        encryptedBlocks[i] = str(encryptedBlocks[i])\n-    encryptedContent = \",\".join(encryptedBlocks)\n-    encryptedContent = f\"{len(message)}_{blockSize}_{encryptedContent}\"\n-    with open(messageFilename, \"w\") as fo:\n-        fo.write(encryptedContent)\n-    return encryptedContent\n-\n-\n-def readFromFileAndDecrypt(messageFilename: str, keyFilename: str) -> str:\n-    keySize, n, d = readKeyFile(keyFilename)\n-    with open(messageFilename) as fo:\n-        content = fo.read()\n-    messageLength, blockSize, encryptedMessage = content.split(\"_\")\n-    messageLength = int(messageLength)\n-    blockSize = int(blockSize)\n-\n-    if keySize < blockSize * 8:\n-        sys.exit(\n-            \"ERROR: Block size is %s bits and key size is %s bits. The RSA cipher \"\n-            \"requires the block size to be equal to or greater than the key size. \"\n-            \"Did you specify the correct key file and encrypted file?\"\n-            % (blockSize * 8, keySize)\n-        )\n-\n-    encryptedBlocks = []\n-    for block in encryptedMessage.split(\",\"):\n-        encryptedBlocks.append(int(block))\n-\n-    return decryptMessage(encryptedBlocks, messageLength, (n, d), blockSize)\n+        print(decrypted_text)\n \n",
        "source_code_with_indent": "    <DED>elif mode == \"decrypt\":\n        <IND>privKeyFilename = \"rsa_privkey.txt\"\n        print(\"Reading from %s and decrypting...\" % (filename))\n        decryptedText = readFromFileAndDecrypt(filename, privKeyFilename)\n        print(\"writing decryption to rsa_decryption.txt...\")\n        with open(\"rsa_decryption.txt\", \"w\") as dec:\n            <IND>dec.write(decryptedText)\n\n        <DED>print(\"\\nDecryption:\")\n        print(decryptedText)\n\n\n<DED><DED>def getBlocksFromText(message: int, blockSize: int = DEFAULT_BLOCK_SIZE) -> [int]:\n    <IND>messageBytes = message.encode(\"ascii\")\n\n    blockInts = []\n    for blockStart in range(0, len(messageBytes), blockSize):\n        <IND>blockInt = 0\n        for i in range(blockStart, min(blockStart + blockSize, len(messageBytes))):\n            <IND>blockInt += messageBytes[i] * (BYTE_SIZE ** (i % blockSize))\n        <DED>blockInts.append(blockInt)\n    <DED>return blockInts\n\n\n<DED>def getTextFromBlocks(\n    blockInts: [int], messageLength: int, blockSize: int = DEFAULT_BLOCK_SIZE\n) -> str:\n    <IND>message = []\n    for blockInt in blockInts:\n        <IND>blockMessage = []\n        for i in range(blockSize - 1, -1, -1):\n            <IND>if len(message) + i < messageLength:\n                <IND>asciiNumber = blockInt // (BYTE_SIZE ** i)\n                blockInt = blockInt % (BYTE_SIZE ** i)\n                blockMessage.insert(0, chr(asciiNumber))\n        <DED><DED>message.extend(blockMessage)\n    <DED>return \"\".join(message)\n\n\n<DED>def encryptMessage(\n    message: str, key: (int, int), blockSize: int = DEFAULT_BLOCK_SIZE\n) -> [int]:\n    <IND>encryptedBlocks = []\n    n, e = key\n\n    for block in getBlocksFromText(message, blockSize):\n        <IND>encryptedBlocks.append(pow(block, e, n))\n    <DED>return encryptedBlocks\n\n\n<DED>def decryptMessage(\n    encryptedBlocks: [int],\n    messageLength: int,\n    key: (int, int),\n    blockSize: int = DEFAULT_BLOCK_SIZE,\n) -> str:\n    <IND>decryptedBlocks = []\n    n, d = key\n    for block in encryptedBlocks:\n        <IND>decryptedBlocks.append(pow(block, d, n))\n    <DED>return getTextFromBlocks(decryptedBlocks, messageLength, blockSize)\n\n\n<DED>def readKeyFile(keyFilename: str) -> (int, int, int):\n    <IND>with open(keyFilename) as fo:\n        <IND>content = fo.read()\n    <DED>keySize, n, EorD = content.split(\",\")\n    return (int(keySize), int(n), int(EorD))\n\n\n<DED>def encryptAndWriteToFile(\n    messageFilename: str,\n    keyFilename: str,\n    message: str,\n    blockSize: int = DEFAULT_BLOCK_SIZE,\n) -> str:\n    <IND>keySize, n, e = readKeyFile(keyFilename)\n    if keySize < blockSize * 8:\n        <IND>sys.exit(\n            \"ERROR: Block size is %s bits and key size is %s bits. The RSA cipher \"\n            \"requires the block size to be equal to or greater than the key size. \"\n            \"Either decrease the block size or use different keys.\"\n            % (blockSize * 8, keySize)\n        )\n\n    <DED>encryptedBlocks = encryptMessage(message, (n, e), blockSize)\n\n    for i in range(len(encryptedBlocks)):\n        <IND>encryptedBlocks[i] = str(encryptedBlocks[i])\n    <DED>encryptedContent = \",\".join(encryptedBlocks)\n    encryptedContent = f\"{len(message)}_{blockSize}_{encryptedContent}\"\n    with open(messageFilename, \"w\") as fo:\n        <IND>fo.write(encryptedContent)\n    <DED>return encryptedContent\n\n\n<DED>def readFromFileAndDecrypt(messageFilename: str, keyFilename: str) -> str:\n    <IND>keySize, n, d = readKeyFile(keyFilename)\n    with open(messageFilename) as fo:\n        <IND>content = fo.read()\n    <DED>messageLength, blockSize, encryptedMessage = content.split(\"_\")\n    messageLength = int(messageLength)\n    blockSize = int(blockSize)\n\n    if keySize < blockSize * 8:\n        <IND>sys.exit(\n            \"ERROR: Block size is %s bits and key size is %s bits. The RSA cipher \"\n            \"requires the block size to be equal to or greater than the key size. \"\n            \"Did you specify the correct key file and encrypted file?\"\n            % (blockSize * 8, keySize)\n        )\n\n    <DED>encryptedBlocks = []\n    for block in encryptedMessage.split(\",\"):\n        <IND>encryptedBlocks.append(int(block))\n\n    <DED>return decryptMessage(encryptedBlocks, messageLength, (n, d), blockSize)\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    <DED>elif mode == \"decrypt\":\n        <IND>privkey_filename = \"rsa_privkey.txt\"\n        print(\"Reading from %s and decrypting...\" % (filename))\n        decrypted_text = read_from_file_and_decrypt(filename, privkey_filename)\n        print(\"writing decryption to rsa_decryption.txt...\")\n        with open(\"rsa_decryption.txt\", \"w\") as dec:\n            <IND>dec.write(decrypted_text)\n\n        <DED>print(\"\\nDecryption:\")\n        print(decrypted_text)\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "TheAlgorithms/Python",
    "commit": "60895366c0f50844af2737130ed98c2510e90060",
    "filename": "ciphers/rsa_cipher.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/TheAlgorithms-Python/ciphers/rsa_cipher.py",
    "file_hunks_size": 3,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "ciphers/rsa_cipher.py:94:38 Invalid type [31]: Expression `(int, int, int)` is not a valid type.",
    "message": " Expression `(int, int, int)` is not a valid type.",
    "rule_id": "Invalid type [31]",
    "warning_line_no": 94,
    "warning_line": "def readKeyFile(keyFilename: str) -> (int, int, int):",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    elif mode == \"decrypt\":\n        privKeyFilename = \"rsa_privkey.txt\"\n        print(\"Reading from %s and decrypting...\" % (filename))\n        decryptedText = readFromFileAndDecrypt(filename, privKeyFilename)\n        print(\"writing decryption to rsa_decryption.txt...\")\n        with open(\"rsa_decryption.txt\", \"w\") as dec:\n            dec.write(decryptedText)\n\n        print(\"\\nDecryption:\")\n        print(decryptedText)\n\n\ndef getBlocksFromText(message: int, blockSize: int = DEFAULT_BLOCK_SIZE) -> [int]:\n    messageBytes = message.encode(\"ascii\")\n\n    blockInts = []\n    for blockStart in range(0, len(messageBytes), blockSize):\n        blockInt = 0\n        for i in range(blockStart, min(blockStart + blockSize, len(messageBytes))):\n            blockInt += messageBytes[i] * (BYTE_SIZE ** (i % blockSize))\n        blockInts.append(blockInt)\n    return blockInts\n\n\ndef getTextFromBlocks(\n    blockInts: [int], messageLength: int, blockSize: int = DEFAULT_BLOCK_SIZE\n) -> str:\n    message = []\n    for blockInt in blockInts:\n        blockMessage = []\n        for i in range(blockSize - 1, -1, -1):\n            if len(message) + i < messageLength:\n                asciiNumber = blockInt // (BYTE_SIZE ** i)\n                blockInt = blockInt % (BYTE_SIZE ** i)\n                blockMessage.insert(0, chr(asciiNumber))\n        message.extend(blockMessage)\n    return \"\".join(message)\n\n\ndef encryptMessage(\n    message: str, key: (int, int), blockSize: int = DEFAULT_BLOCK_SIZE\n) -> [int]:\n    encryptedBlocks = []\n    n, e = key\n\n    for block in getBlocksFromText(message, blockSize):\n        encryptedBlocks.append(pow(block, e, n))\n    return encryptedBlocks\n\n\ndef decryptMessage(\n    encryptedBlocks: [int],\n    messageLength: int,\n    key: (int, int),\n    blockSize: int = DEFAULT_BLOCK_SIZE,\n) -> str:\n    decryptedBlocks = []\n    n, d = key\n    for block in encryptedBlocks:\n        decryptedBlocks.append(pow(block, d, n))\n    return getTextFromBlocks(decryptedBlocks, messageLength, blockSize)\n\n\ndef readKeyFile(keyFilename: str) -> (int, int, int):\n    with open(keyFilename) as fo:\n        content = fo.read()\n    keySize, n, EorD = content.split(\",\")\n    return (int(keySize), int(n), int(EorD))\n\n\ndef encryptAndWriteToFile(\n    messageFilename: str,\n    keyFilename: str,\n    message: str,\n    blockSize: int = DEFAULT_BLOCK_SIZE,\n) -> str:\n    keySize, n, e = readKeyFile(keyFilename)\n    if keySize < blockSize * 8:\n        sys.exit(\n            \"ERROR: Block size is %s bits and key size is %s bits. The RSA cipher \"\n            \"requires the block size to be equal to or greater than the key size. \"\n            \"Either decrease the block size or use different keys.\"\n            % (blockSize * 8, keySize)\n        )\n\n    encryptedBlocks = encryptMessage(message, (n, e), blockSize)\n\n    for i in range(len(encryptedBlocks)):\n        encryptedBlocks[i] = str(encryptedBlocks[i])\n    encryptedContent = \",\".join(encryptedBlocks)\n    encryptedContent = f\"{len(message)}_{blockSize}_{encryptedContent}\"\n    with open(messageFilename, \"w\") as fo:\n        fo.write(encryptedContent)\n    return encryptedContent\n\n\ndef readFromFileAndDecrypt(messageFilename: str, keyFilename: str) -> str:\n    keySize, n, d = readKeyFile(keyFilename)\n    with open(messageFilename) as fo:\n        content = fo.read()\n    messageLength, blockSize, encryptedMessage = content.split(\"_\")\n    messageLength = int(messageLength)\n    blockSize = int(blockSize)\n\n    if keySize < blockSize * 8:\n        sys.exit(\n            \"ERROR: Block size is %s bits and key size is %s bits. The RSA cipher \"\n            \"requires the block size to be equal to or greater than the key size. \"\n            \"Did you specify the correct key file and encrypted file?\"\n            % (blockSize * 8, keySize)\n        )\n\n    encryptedBlocks = []\n    for block in encryptedMessage.split(\",\"):\n        encryptedBlocks.append(int(block))\n\n    return decryptMessage(encryptedBlocks, messageLength, (n, d), blockSize)\n\n",
        "source_code_len": 3983,
        "target_code": "    elif mode == \"decrypt\":\n        privkey_filename = \"rsa_privkey.txt\"\n        print(\"Reading from %s and decrypting...\" % (filename))\n        decrypted_text = read_from_file_and_decrypt(filename, privkey_filename)\n        print(\"writing decryption to rsa_decryption.txt...\")\n        with open(\"rsa_decryption.txt\", \"w\") as dec:\n            dec.write(decrypted_text)\n\n        print(\"\\nDecryption:\")\n        print(decrypted_text)\n\n",
        "target_code_len": 432,
        "diff_format": "@@ -31,118 +138,11 @@\n     elif mode == \"decrypt\":\n-        privKeyFilename = \"rsa_privkey.txt\"\n+        privkey_filename = \"rsa_privkey.txt\"\n         print(\"Reading from %s and decrypting...\" % (filename))\n-        decryptedText = readFromFileAndDecrypt(filename, privKeyFilename)\n+        decrypted_text = read_from_file_and_decrypt(filename, privkey_filename)\n         print(\"writing decryption to rsa_decryption.txt...\")\n         with open(\"rsa_decryption.txt\", \"w\") as dec:\n-            dec.write(decryptedText)\n+            dec.write(decrypted_text)\n \n         print(\"\\nDecryption:\")\n-        print(decryptedText)\n-\n-\n-def getBlocksFromText(message: int, blockSize: int = DEFAULT_BLOCK_SIZE) -> [int]:\n-    messageBytes = message.encode(\"ascii\")\n-\n-    blockInts = []\n-    for blockStart in range(0, len(messageBytes), blockSize):\n-        blockInt = 0\n-        for i in range(blockStart, min(blockStart + blockSize, len(messageBytes))):\n-            blockInt += messageBytes[i] * (BYTE_SIZE ** (i % blockSize))\n-        blockInts.append(blockInt)\n-    return blockInts\n-\n-\n-def getTextFromBlocks(\n-    blockInts: [int], messageLength: int, blockSize: int = DEFAULT_BLOCK_SIZE\n-) -> str:\n-    message = []\n-    for blockInt in blockInts:\n-        blockMessage = []\n-        for i in range(blockSize - 1, -1, -1):\n-            if len(message) + i < messageLength:\n-                asciiNumber = blockInt // (BYTE_SIZE ** i)\n-                blockInt = blockInt % (BYTE_SIZE ** i)\n-                blockMessage.insert(0, chr(asciiNumber))\n-        message.extend(blockMessage)\n-    return \"\".join(message)\n-\n-\n-def encryptMessage(\n-    message: str, key: (int, int), blockSize: int = DEFAULT_BLOCK_SIZE\n-) -> [int]:\n-    encryptedBlocks = []\n-    n, e = key\n-\n-    for block in getBlocksFromText(message, blockSize):\n-        encryptedBlocks.append(pow(block, e, n))\n-    return encryptedBlocks\n-\n-\n-def decryptMessage(\n-    encryptedBlocks: [int],\n-    messageLength: int,\n-    key: (int, int),\n-    blockSize: int = DEFAULT_BLOCK_SIZE,\n-) -> str:\n-    decryptedBlocks = []\n-    n, d = key\n-    for block in encryptedBlocks:\n-        decryptedBlocks.append(pow(block, d, n))\n-    return getTextFromBlocks(decryptedBlocks, messageLength, blockSize)\n-\n-\n-def readKeyFile(keyFilename: str) -> (int, int, int):\n-    with open(keyFilename) as fo:\n-        content = fo.read()\n-    keySize, n, EorD = content.split(\",\")\n-    return (int(keySize), int(n), int(EorD))\n-\n-\n-def encryptAndWriteToFile(\n-    messageFilename: str,\n-    keyFilename: str,\n-    message: str,\n-    blockSize: int = DEFAULT_BLOCK_SIZE,\n-) -> str:\n-    keySize, n, e = readKeyFile(keyFilename)\n-    if keySize < blockSize * 8:\n-        sys.exit(\n-            \"ERROR: Block size is %s bits and key size is %s bits. The RSA cipher \"\n-            \"requires the block size to be equal to or greater than the key size. \"\n-            \"Either decrease the block size or use different keys.\"\n-            % (blockSize * 8, keySize)\n-        )\n-\n-    encryptedBlocks = encryptMessage(message, (n, e), blockSize)\n-\n-    for i in range(len(encryptedBlocks)):\n-        encryptedBlocks[i] = str(encryptedBlocks[i])\n-    encryptedContent = \",\".join(encryptedBlocks)\n-    encryptedContent = f\"{len(message)}_{blockSize}_{encryptedContent}\"\n-    with open(messageFilename, \"w\") as fo:\n-        fo.write(encryptedContent)\n-    return encryptedContent\n-\n-\n-def readFromFileAndDecrypt(messageFilename: str, keyFilename: str) -> str:\n-    keySize, n, d = readKeyFile(keyFilename)\n-    with open(messageFilename) as fo:\n-        content = fo.read()\n-    messageLength, blockSize, encryptedMessage = content.split(\"_\")\n-    messageLength = int(messageLength)\n-    blockSize = int(blockSize)\n-\n-    if keySize < blockSize * 8:\n-        sys.exit(\n-            \"ERROR: Block size is %s bits and key size is %s bits. The RSA cipher \"\n-            \"requires the block size to be equal to or greater than the key size. \"\n-            \"Did you specify the correct key file and encrypted file?\"\n-            % (blockSize * 8, keySize)\n-        )\n-\n-    encryptedBlocks = []\n-    for block in encryptedMessage.split(\",\"):\n-        encryptedBlocks.append(int(block))\n-\n-    return decryptMessage(encryptedBlocks, messageLength, (n, d), blockSize)\n+        print(decrypted_text)\n \n",
        "source_code_with_indent": "    <DED>elif mode == \"decrypt\":\n        <IND>privKeyFilename = \"rsa_privkey.txt\"\n        print(\"Reading from %s and decrypting...\" % (filename))\n        decryptedText = readFromFileAndDecrypt(filename, privKeyFilename)\n        print(\"writing decryption to rsa_decryption.txt...\")\n        with open(\"rsa_decryption.txt\", \"w\") as dec:\n            <IND>dec.write(decryptedText)\n\n        <DED>print(\"\\nDecryption:\")\n        print(decryptedText)\n\n\n<DED><DED>def getBlocksFromText(message: int, blockSize: int = DEFAULT_BLOCK_SIZE) -> [int]:\n    <IND>messageBytes = message.encode(\"ascii\")\n\n    blockInts = []\n    for blockStart in range(0, len(messageBytes), blockSize):\n        <IND>blockInt = 0\n        for i in range(blockStart, min(blockStart + blockSize, len(messageBytes))):\n            <IND>blockInt += messageBytes[i] * (BYTE_SIZE ** (i % blockSize))\n        <DED>blockInts.append(blockInt)\n    <DED>return blockInts\n\n\n<DED>def getTextFromBlocks(\n    blockInts: [int], messageLength: int, blockSize: int = DEFAULT_BLOCK_SIZE\n) -> str:\n    <IND>message = []\n    for blockInt in blockInts:\n        <IND>blockMessage = []\n        for i in range(blockSize - 1, -1, -1):\n            <IND>if len(message) + i < messageLength:\n                <IND>asciiNumber = blockInt // (BYTE_SIZE ** i)\n                blockInt = blockInt % (BYTE_SIZE ** i)\n                blockMessage.insert(0, chr(asciiNumber))\n        <DED><DED>message.extend(blockMessage)\n    <DED>return \"\".join(message)\n\n\n<DED>def encryptMessage(\n    message: str, key: (int, int), blockSize: int = DEFAULT_BLOCK_SIZE\n) -> [int]:\n    <IND>encryptedBlocks = []\n    n, e = key\n\n    for block in getBlocksFromText(message, blockSize):\n        <IND>encryptedBlocks.append(pow(block, e, n))\n    <DED>return encryptedBlocks\n\n\n<DED>def decryptMessage(\n    encryptedBlocks: [int],\n    messageLength: int,\n    key: (int, int),\n    blockSize: int = DEFAULT_BLOCK_SIZE,\n) -> str:\n    <IND>decryptedBlocks = []\n    n, d = key\n    for block in encryptedBlocks:\n        <IND>decryptedBlocks.append(pow(block, d, n))\n    <DED>return getTextFromBlocks(decryptedBlocks, messageLength, blockSize)\n\n\n<DED>def readKeyFile(keyFilename: str) -> (int, int, int):\n    <IND>with open(keyFilename) as fo:\n        <IND>content = fo.read()\n    <DED>keySize, n, EorD = content.split(\",\")\n    return (int(keySize), int(n), int(EorD))\n\n\n<DED>def encryptAndWriteToFile(\n    messageFilename: str,\n    keyFilename: str,\n    message: str,\n    blockSize: int = DEFAULT_BLOCK_SIZE,\n) -> str:\n    <IND>keySize, n, e = readKeyFile(keyFilename)\n    if keySize < blockSize * 8:\n        <IND>sys.exit(\n            \"ERROR: Block size is %s bits and key size is %s bits. The RSA cipher \"\n            \"requires the block size to be equal to or greater than the key size. \"\n            \"Either decrease the block size or use different keys.\"\n            % (blockSize * 8, keySize)\n        )\n\n    <DED>encryptedBlocks = encryptMessage(message, (n, e), blockSize)\n\n    for i in range(len(encryptedBlocks)):\n        <IND>encryptedBlocks[i] = str(encryptedBlocks[i])\n    <DED>encryptedContent = \",\".join(encryptedBlocks)\n    encryptedContent = f\"{len(message)}_{blockSize}_{encryptedContent}\"\n    with open(messageFilename, \"w\") as fo:\n        <IND>fo.write(encryptedContent)\n    <DED>return encryptedContent\n\n\n<DED>def readFromFileAndDecrypt(messageFilename: str, keyFilename: str) -> str:\n    <IND>keySize, n, d = readKeyFile(keyFilename)\n    with open(messageFilename) as fo:\n        <IND>content = fo.read()\n    <DED>messageLength, blockSize, encryptedMessage = content.split(\"_\")\n    messageLength = int(messageLength)\n    blockSize = int(blockSize)\n\n    if keySize < blockSize * 8:\n        <IND>sys.exit(\n            \"ERROR: Block size is %s bits and key size is %s bits. The RSA cipher \"\n            \"requires the block size to be equal to or greater than the key size. \"\n            \"Did you specify the correct key file and encrypted file?\"\n            % (blockSize * 8, keySize)\n        )\n\n    <DED>encryptedBlocks = []\n    for block in encryptedMessage.split(\",\"):\n        <IND>encryptedBlocks.append(int(block))\n\n    <DED>return decryptMessage(encryptedBlocks, messageLength, (n, d), blockSize)\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    <DED>elif mode == \"decrypt\":\n        <IND>privkey_filename = \"rsa_privkey.txt\"\n        print(\"Reading from %s and decrypting...\" % (filename))\n        decrypted_text = read_from_file_and_decrypt(filename, privkey_filename)\n        print(\"writing decryption to rsa_decryption.txt...\")\n        with open(\"rsa_decryption.txt\", \"w\") as dec:\n            <IND>dec.write(decrypted_text)\n\n        <DED>print(\"\\nDecryption:\")\n        print(decrypted_text)\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "TheAlgorithms/Python",
    "commit": "60895366c0f50844af2737130ed98c2510e90060",
    "filename": "ciphers/rsa_factorization.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/TheAlgorithms-Python/ciphers/rsa_factorization.py",
    "file_hunks_size": 1,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": true,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "ciphers/rsa_factorization.py:16:41 Invalid type [31]: Expression `[int]` is not a valid type.",
    "message": " Expression `[int]` is not a valid type.",
    "rule_id": "Invalid type [31]",
    "warning_line_no": 16,
    "warning_line": "def rsafactor(d: int, e: int, N: int) -> [int]:",
    "min_patch": [
      {
        "hunk_fit_TFix": true,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\ndef rsafactor(d: int, e: int, N: int) -> [int]:\n    \"\"\"\n",
        "source_code_len": 57,
        "target_code": "\ndef rsafactor(d: int, e: int, N: int) -> list[int]:\n    \"\"\"\n",
        "target_code_len": 61,
        "diff_format": "@@ -15,3 +15,3 @@\n \n-def rsafactor(d: int, e: int, N: int) -> [int]:\n+def rsafactor(d: int, e: int, N: int) -> list[int]:\n     \"\"\"\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\ndef rsafactor(d: int, e: int, N: int) -> [int]:\n    <IND>",
        "target_code_with_indent": "\ndef rsafactor(d: int, e: int, N: int) -> list[int]:\n    <IND>"
      }
    ]
  },
  {
    "project": "TheAlgorithms/Python",
    "commit": "60895366c0f50844af2737130ed98c2510e90060",
    "filename": "ciphers/shuffled_shift_cipher.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/TheAlgorithms-Python/ciphers/shuffled_shift_cipher.py",
    "file_hunks_size": 9,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "ciphers/shuffled_shift_cipher.py:29:23 Incompatible variable type [9]: passcode is declared to have type `str` but is used as type `None`.",
    "message": " passcode is declared to have type `str` but is used as type `None`.",
    "rule_id": "Incompatible variable type [9]",
    "warning_line_no": 29,
    "warning_line": "    def __init__(self, passcode: str = None):",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "import string\n\n",
        "source_code_len": 15,
        "target_code": "import string\nfrom typing import Optional\n\n",
        "target_code_len": 43,
        "diff_format": "@@ -2,2 +2,3 @@\n import string\n+from typing import Optional\n \n",
        "source_code_with_indent": "import string\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "import string\nfrom typing import Optional\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": true,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n    def __init__(self, passcode: str = None):\n        \"\"\"\n",
        "source_code_len": 59,
        "target_code": "\n    def __init__(self, passcode: Optional[str] = None) -> None:\n        \"\"\"\n",
        "target_code_len": 77,
        "diff_format": "@@ -28,3 +29,3 @@\n \n-    def __init__(self, passcode: str = None):\n+    def __init__(self, passcode: Optional[str] = None) -> None:\n         \"\"\"\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\n    def __init__(self, passcode: str = None):\n        <IND>",
        "target_code_with_indent": "\n    def __init__(self, passcode: Optional[str] = None) -> None:\n        <IND>"
      }
    ]
  },
  {
    "project": "TheAlgorithms/Python",
    "commit": "60895366c0f50844af2737130ed98c2510e90060",
    "filename": "ciphers/trafid_cipher.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/TheAlgorithms-Python/ciphers/trafid_cipher.py",
    "file_hunks_size": 3,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": true,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "ciphers/trafid_cipher.py:19:64 Invalid type [31]: Expression `(str, str, str)` is not a valid type.",
    "message": " Expression `(str, str, str)` is not a valid type.",
    "rule_id": "Invalid type [31]",
    "warning_line_no": 19,
    "warning_line": "def __decryptPart(messagePart: str, character2Number: dict) -> (str, str, str):",
    "min_patch": [
      {
        "hunk_fit_TFix": true,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\ndef __decryptPart(messagePart: str, character2Number: dict) -> (str, str, str):\n    tmp, thisPart = \"\", \"\"\n",
        "source_code_len": 108,
        "target_code": "\ndef __decryptPart(\n    messagePart: str, character2Number: dict[str, str]\n) -> tuple[str, str, str]:\n    tmp, thisPart = \"\", \"\"\n",
        "target_code_len": 129,
        "diff_format": "@@ -18,3 +18,5 @@\n \n-def __decryptPart(messagePart: str, character2Number: dict) -> (str, str, str):\n+def __decryptPart(\n+    messagePart: str, character2Number: dict[str, str]\n+) -> tuple[str, str, str]:\n     tmp, thisPart = \"\", \"\"\n",
        "source_code_with_indent": "\n<DED>def __decryptPart(messagePart: str, character2Number: dict) -> (str, str, str):\n    <IND>tmp, thisPart = \"\", \"\"\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n<DED>def __decryptPart(\n    messagePart: str, character2Number: dict[str, str]\n) -> tuple[str, str, str]:\n    <IND>tmp, thisPart = \"\", \"\"\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "TheAlgorithms/Python",
    "commit": "60895366c0f50844af2737130ed98c2510e90060",
    "filename": "ciphers/trafid_cipher.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/TheAlgorithms-Python/ciphers/trafid_cipher.py",
    "file_hunks_size": 3,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": true,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "ciphers/trafid_cipher.py:35:47 Invalid type [31]: Expression `(str, str, dict, dict)` is not a valid type.",
    "message": " Expression `(str, str, dict, dict)` is not a valid type.",
    "rule_id": "Invalid type [31]",
    "warning_line_no": 35,
    "warning_line": "def __prepare(message: str, alphabet: str) -> (str, str, dict, dict):",
    "min_patch": [
      {
        "hunk_fit_TFix": true,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\ndef __prepare(message: str, alphabet: str) -> (str, str, dict, dict):\n    # Validate message and alphabet, set to upper and remove spaces\n",
        "source_code_len": 139,
        "target_code": "\ndef __prepare(\n    message: str, alphabet: str\n) -> tuple[str, str, dict[str, str], dict[str, str]]:\n    # Validate message and alphabet, set to upper and remove spaces\n",
        "target_code_len": 170,
        "diff_format": "@@ -34,3 +36,5 @@\n \n-def __prepare(message: str, alphabet: str) -> (str, str, dict, dict):\n+def __prepare(\n+    message: str, alphabet: str\n+) -> tuple[str, str, dict[str, str], dict[str, str]]:\n     # Validate message and alphabet, set to upper and remove spaces\n",
        "source_code_with_indent": "\n<DED>def __prepare(message: str, alphabet: str) -> (str, str, dict, dict):\n    # Validate message and alphabet, set to upper and remove spaces\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n<DED>def __prepare(\n    message: str, alphabet: str\n) -> tuple[str, str, dict[str, str], dict[str, str]]:\n    # Validate message and alphabet, set to upper and remove spaces\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "TheAlgorithms/Python",
    "commit": "60895366c0f50844af2737130ed98c2510e90060",
    "filename": "ciphers/xor_cipher.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/TheAlgorithms-Python/ciphers/xor_cipher.py",
    "file_hunks_size": 2,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": true,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "ciphers/xor_cipher.py:31:49 Invalid type [31]: Expression `[str]` is not a valid type.",
    "message": " Expression `[str]` is not a valid type.",
    "rule_id": "Invalid type [31]",
    "warning_line_no": 31,
    "warning_line": "    def encrypt(self, content: str, key: int) -> [str]:",
    "min_patch": [
      {
        "hunk_fit_TFix": true,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n    def encrypt(self, content: str, key: int) -> [str]:\n        \"\"\"\n",
        "source_code_len": 69,
        "target_code": "\n    def encrypt(self, content: str, key: int) -> list[str]:\n        \"\"\"\n",
        "target_code_len": 73,
        "diff_format": "@@ -30,3 +30,3 @@\n \n-    def encrypt(self, content: str, key: int) -> [str]:\n+    def encrypt(self, content: str, key: int) -> list[str]:\n         \"\"\"\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\n    <DED>def encrypt(self, content: str, key: int) -> [str]:\n        <IND>",
        "target_code_with_indent": "\n    <DED>def encrypt(self, content: str, key: int) -> list[str]:\n        <IND>"
      }
    ]
  },
  {
    "project": "TheAlgorithms/Python",
    "commit": "60895366c0f50844af2737130ed98c2510e90060",
    "filename": "ciphers/xor_cipher.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/TheAlgorithms-Python/ciphers/xor_cipher.py",
    "file_hunks_size": 2,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": true,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "ciphers/xor_cipher.py:56:49 Invalid type [31]: Expression `[str]` is not a valid type.",
    "message": " Expression `[str]` is not a valid type.",
    "rule_id": "Invalid type [31]",
    "warning_line_no": 56,
    "warning_line": "    def decrypt(self, content: str, key: int) -> [str]:",
    "min_patch": [
      {
        "hunk_fit_TFix": true,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n    def decrypt(self, content: str, key: int) -> [str]:\n        \"\"\"\n",
        "source_code_len": 69,
        "target_code": "\n    def decrypt(self, content: str, key: int) -> list[str]:\n        \"\"\"\n",
        "target_code_len": 73,
        "diff_format": "@@ -55,3 +55,3 @@\n \n-    def decrypt(self, content: str, key: int) -> [str]:\n+    def decrypt(self, content: str, key: int) -> list[str]:\n         \"\"\"\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\n    <DED>def decrypt(self, content: str, key: int) -> [str]:\n        <IND>",
        "target_code_with_indent": "\n    <DED>def decrypt(self, content: str, key: int) -> list[str]:\n        <IND>"
      }
    ]
  }
]