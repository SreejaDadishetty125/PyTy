[
  {
    "project": "pantsbuild/pants",
    "commit": "08bc2add6e98feefdce36f6f094a15e3e598b1e7",
    "filename": "src/python/pants/engine/exp/graph.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/pantsbuild-pants/src/python/pants/engine/exp/graph.py",
    "file_hunks_size": 10,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "src/python/pants/engine/exp/graph.py:23:18 Invalid type [31]: Expression `pants.util.objects.datatype(\"SourceRoots\", [\"buildroot\", \"srcroots\"])` is not a valid type.",
    "message": " Expression `pants.util.objects.datatype(\"SourceRoots\", [\"buildroot\", \"srcroots\"])` is not a valid type.",
    "rule_id": "Invalid type [31]",
    "warning_line_no": 23,
    "warning_line": "class SourceRoots(datatype('SourceRoots', ['buildroot', 'srcroots'])):"
  },
  {
    "project": "pantsbuild/pants",
    "commit": "08bc2add6e98feefdce36f6f094a15e3e598b1e7",
    "filename": "src/python/pants/engine/exp/graph.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/pantsbuild-pants/src/python/pants/engine/exp/graph.py",
    "file_hunks_size": 10,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "src/python/pants/engine/exp/graph.py:27:16 Invalid type [31]: Expression `pants.util.objects.datatype(\"Directory\", [\"path\"])` is not a valid type.",
    "message": " Expression `pants.util.objects.datatype(\"Directory\", [\"path\"])` is not a valid type.",
    "rule_id": "Invalid type [31]",
    "warning_line_no": 27,
    "warning_line": "class Directory(datatype('Directory', ['path'])):"
  },
  {
    "project": "pantsbuild/pants",
    "commit": "08bc2add6e98feefdce36f6f094a15e3e598b1e7",
    "filename": "src/python/pants/engine/exp/graph.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/pantsbuild-pants/src/python/pants/engine/exp/graph.py",
    "file_hunks_size": 10,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "src/python/pants/engine/exp/graph.py:31:30 Invalid type [31]: Expression `pants.util.objects.datatype(\"RecursiveSubDirectories\", [\"directory\", \"dependencies\"])` is not a valid type.",
    "message": " Expression `pants.util.objects.datatype(\"RecursiveSubDirectories\", [\"directory\", \"dependencies\"])` is not a valid type.",
    "rule_id": "Invalid type [31]",
    "warning_line_no": 31,
    "warning_line": "class RecursiveSubDirectories(datatype('RecursiveSubDirectories', ['directory', 'dependencies'])):"
  },
  {
    "project": "pantsbuild/pants",
    "commit": "08bc2add6e98feefdce36f6f094a15e3e598b1e7",
    "filename": "src/python/pants/engine/exp/graph.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/pantsbuild-pants/src/python/pants/engine/exp/graph.py",
    "file_hunks_size": 10,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "src/python/pants/engine/exp/graph.py:35:21 Invalid type [31]: Expression `pants.util.objects.datatype(\"SubDirectories\", [\"directory\", \"dependencies\"])` is not a valid type.",
    "message": " Expression `pants.util.objects.datatype(\"SubDirectories\", [\"directory\", \"dependencies\"])` is not a valid type.",
    "rule_id": "Invalid type [31]",
    "warning_line_no": 35,
    "warning_line": "class SubDirectories(datatype('SubDirectories', ['directory', 'dependencies'])):"
  },
  {
    "project": "pantsbuild/pants",
    "commit": "08bc2add6e98feefdce36f6f094a15e3e598b1e7",
    "filename": "src/python/pants/engine/exp/scheduler.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/pantsbuild-pants/src/python/pants/engine/exp/scheduler.py",
    "file_hunks_size": 13,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "src/python/pants/engine/exp/scheduler.py:35:13 Invalid type [31]: Expression `pants.util.objects.datatype(\"Subject\", [\"product\", \"optional\"])` is not a valid type.",
    "message": " Expression `pants.util.objects.datatype(\"Subject\", [\"product\", \"optional\"])` is not a valid type.",
    "rule_id": "Invalid type [31]",
    "warning_line_no": 35,
    "warning_line": "class Select(datatype('Subject', ['product', 'optional']), Selector):",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\nclass Selector(AbstractClass):\n  @abstractproperty\n  def optional(self):\n    \"\"\"Return true if this Selector is optional. It may result in a `None` match.\"\"\"\n\n  @abstractmethod\n  def construct_node(self, subject, variants):\n    \"\"\"Constructs a Node for this Selector and the given Subject/Variants.\n\n    May return None if the Selector can be known statically to not be satisfiable for the inputs.\n    \"\"\"\n\n\nclass Select(datatype('Subject', ['product', 'optional']), Selector):\n  \"\"\"Selects the given Product for the Subject provided to the constructor.\n\n  If optional=True and no matching product can be produced, will return None.\n  \"\"\"\n\n  def __new__(self, product, optional=False):\n    return super(Select, self).__new__(self, product, optional)\n\n  def construct_node(self, subject, variants):\n    return SelectNode(subject, self.product, variants, None)\n\n\nclass SelectVariant(datatype('Variant', ['product', 'variant_key']), Selector):\n  \"\"\"Selects the matching Product and variant name for the Subject provided to the constructor.\n\n  For example: a SelectVariant with a variant_key of \"thrift\" and a product of type ApacheThrift\n  will only match when a consumer passes a variant value for \"thrift\" that matches the name of an\n  ApacheThrift value.\n  \"\"\"\n  optional = False\n\n  def construct_node(self, subject, variants):\n    return SelectNode(subject, self.product, variants, self.variant_key)\n\n\nclass SelectDependencies(datatype('Dependencies', ['product', 'deps_product']), Selector):\n  \"\"\"Selects a product for each of the dependencies of a product for the Subject.\n\n  The dependencies declared on `deps_product` will be provided to the requesting task\n  in the order they were declared.\n  \"\"\"\n  optional = False\n\n  def construct_node(self, subject, variants):\n    return DependenciesNode(subject, self.product, variants, self.deps_product)\n\n\nclass SelectProjection(datatype('Projection', ['product', 'projected_product', 'fields', 'input_product']), Selector):\n  \"\"\"Selects a field of the given Subject to produce a Subject, Product dependency from.\n\n  Projecting an input allows for deduplication in the graph, where multiple Subjects\n  resolve to a single backing Subject instead.\n  \"\"\"\n  optional = False\n\n  def construct_node(self, subject, variants):\n    # Input product type doesn't match: not satisfiable.\n    if not type(subject) == self.input_product:\n      return None\n\n    # Find the fields of the Subject to project.\n    values = []\n    for field in self.fields:\n      values.append(getattr(subject, field))\n    projected_subject = self.projected_product(*values)\n    return SelectNode(projected_subject, self.product, variants, None)\n\n\nclass SelectLiteral(datatype('Literal', ['subject', 'product']), Selector):\n  \"\"\"Selects a literal Subject (other than the one applied to the selector).\"\"\"\n  optional = False\n\n  def construct_node(self, subject, variants):\n    # NB: Intentionally ignores subject parameter to provide a literal subject.\n    return SelectNode(self.subject, self.product, variants, None)\n\n\nclass SchedulingError(Exception):\n  \"\"\"Indicates inability to make a scheduling promise.\"\"\"\n\n\nclass PartiallyConsumedInputsError(SchedulingError):\n  \"\"\"No task was able to consume a particular literal product for a subject, although some tried.\n",
        "source_code_len": 3277,
        "target_code": "\nclass PartiallyConsumedInputsError(Exception):\n  \"\"\"No task was able to consume a particular literal product for a subject, although some tried.\n",
        "target_code_len": 146,
        "diff_format": "@@ -21,88 +20,3 @@\n \n-class Selector(AbstractClass):\n-  @abstractproperty\n-  def optional(self):\n-    \"\"\"Return true if this Selector is optional. It may result in a `None` match.\"\"\"\n-\n-  @abstractmethod\n-  def construct_node(self, subject, variants):\n-    \"\"\"Constructs a Node for this Selector and the given Subject/Variants.\n-\n-    May return None if the Selector can be known statically to not be satisfiable for the inputs.\n-    \"\"\"\n-\n-\n-class Select(datatype('Subject', ['product', 'optional']), Selector):\n-  \"\"\"Selects the given Product for the Subject provided to the constructor.\n-\n-  If optional=True and no matching product can be produced, will return None.\n-  \"\"\"\n-\n-  def __new__(self, product, optional=False):\n-    return super(Select, self).__new__(self, product, optional)\n-\n-  def construct_node(self, subject, variants):\n-    return SelectNode(subject, self.product, variants, None)\n-\n-\n-class SelectVariant(datatype('Variant', ['product', 'variant_key']), Selector):\n-  \"\"\"Selects the matching Product and variant name for the Subject provided to the constructor.\n-\n-  For example: a SelectVariant with a variant_key of \"thrift\" and a product of type ApacheThrift\n-  will only match when a consumer passes a variant value for \"thrift\" that matches the name of an\n-  ApacheThrift value.\n-  \"\"\"\n-  optional = False\n-\n-  def construct_node(self, subject, variants):\n-    return SelectNode(subject, self.product, variants, self.variant_key)\n-\n-\n-class SelectDependencies(datatype('Dependencies', ['product', 'deps_product']), Selector):\n-  \"\"\"Selects a product for each of the dependencies of a product for the Subject.\n-\n-  The dependencies declared on `deps_product` will be provided to the requesting task\n-  in the order they were declared.\n-  \"\"\"\n-  optional = False\n-\n-  def construct_node(self, subject, variants):\n-    return DependenciesNode(subject, self.product, variants, self.deps_product)\n-\n-\n-class SelectProjection(datatype('Projection', ['product', 'projected_product', 'fields', 'input_product']), Selector):\n-  \"\"\"Selects a field of the given Subject to produce a Subject, Product dependency from.\n-\n-  Projecting an input allows for deduplication in the graph, where multiple Subjects\n-  resolve to a single backing Subject instead.\n-  \"\"\"\n-  optional = False\n-\n-  def construct_node(self, subject, variants):\n-    # Input product type doesn't match: not satisfiable.\n-    if not type(subject) == self.input_product:\n-      return None\n-\n-    # Find the fields of the Subject to project.\n-    values = []\n-    for field in self.fields:\n-      values.append(getattr(subject, field))\n-    projected_subject = self.projected_product(*values)\n-    return SelectNode(projected_subject, self.product, variants, None)\n-\n-\n-class SelectLiteral(datatype('Literal', ['subject', 'product']), Selector):\n-  \"\"\"Selects a literal Subject (other than the one applied to the selector).\"\"\"\n-  optional = False\n-\n-  def construct_node(self, subject, variants):\n-    # NB: Intentionally ignores subject parameter to provide a literal subject.\n-    return SelectNode(self.subject, self.product, variants, None)\n-\n-\n-class SchedulingError(Exception):\n-  \"\"\"Indicates inability to make a scheduling promise.\"\"\"\n-\n-\n-class PartiallyConsumedInputsError(SchedulingError):\n+class PartiallyConsumedInputsError(Exception):\n   \"\"\"No task was able to consume a particular literal product for a subject, although some tried.\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\nclass Selector(AbstractClass):\n  <IND>@abstractproperty\n  def optional(self):\n    <IND>\"\"\"Return true if this Selector is optional. It may result in a `None` match.\"\"\"\n\n  <DED>@abstractmethod\n  def construct_node(self, subject, variants):\n    <IND>\"\"\"Constructs a Node for this Selector and the given Subject/Variants.\n\n    May return None if the Selector can be known statically to not be satisfiable for the inputs.\n    \"\"\"\n\n\n<DED><DED>class Select(datatype('Subject', ['product', 'optional']), Selector):\n  <IND>\"\"\"Selects the given Product for the Subject provided to the constructor.\n\n  If optional=True and no matching product can be produced, will return None.\n  \"\"\"\n\n  def __new__(self, product, optional=False):\n    <IND>return super(Select, self).__new__(self, product, optional)\n\n  <DED>def construct_node(self, subject, variants):\n    <IND>return SelectNode(subject, self.product, variants, None)\n\n\n<DED><DED>class SelectVariant(datatype('Variant', ['product', 'variant_key']), Selector):\n  <IND>\"\"\"Selects the matching Product and variant name for the Subject provided to the constructor.\n\n  For example: a SelectVariant with a variant_key of \"thrift\" and a product of type ApacheThrift\n  will only match when a consumer passes a variant value for \"thrift\" that matches the name of an\n  ApacheThrift value.\n  \"\"\"\n  optional = False\n\n  def construct_node(self, subject, variants):\n    <IND>return SelectNode(subject, self.product, variants, self.variant_key)\n\n\n<DED><DED>class SelectDependencies(datatype('Dependencies', ['product', 'deps_product']), Selector):\n  <IND>\"\"\"Selects a product for each of the dependencies of a product for the Subject.\n\n  The dependencies declared on `deps_product` will be provided to the requesting task\n  in the order they were declared.\n  \"\"\"\n  optional = False\n\n  def construct_node(self, subject, variants):\n    <IND>return DependenciesNode(subject, self.product, variants, self.deps_product)\n\n\n<DED><DED>class SelectProjection(datatype('Projection', ['product', 'projected_product', 'fields', 'input_product']), Selector):\n  <IND>\"\"\"Selects a field of the given Subject to produce a Subject, Product dependency from.\n\n  Projecting an input allows for deduplication in the graph, where multiple Subjects\n  resolve to a single backing Subject instead.\n  \"\"\"\n  optional = False\n\n  def construct_node(self, subject, variants):\n    # Input product type doesn't match: not satisfiable.\n    <IND>if not type(subject) == self.input_product:\n      <IND>return None\n\n    # Find the fields of the Subject to project.\n    <DED>values = []\n    for field in self.fields:\n      <IND>values.append(getattr(subject, field))\n    <DED>projected_subject = self.projected_product(*values)\n    return SelectNode(projected_subject, self.product, variants, None)\n\n\n<DED><DED>class SelectLiteral(datatype('Literal', ['subject', 'product']), Selector):\n  <IND>\"\"\"Selects a literal Subject (other than the one applied to the selector).\"\"\"\n  optional = False\n\n  def construct_node(self, subject, variants):\n    # NB: Intentionally ignores subject parameter to provide a literal subject.\n    <IND>return SelectNode(self.subject, self.product, variants, None)\n\n\n<DED><DED>class SchedulingError(Exception):\n  <IND>\"\"\"Indicates inability to make a scheduling promise.\"\"\"\n\n\n<DED>class PartiallyConsumedInputsError(SchedulingError):\n  <IND>",
        "target_code_with_indent": "\nclass PartiallyConsumedInputsError(Exception):\n  <IND>"
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": true,
        "has_suppression": false,
        "source_code": "\nclass ConflictingProducersError(SchedulingError):\n  \"\"\"Indicates that there was more than one source of a product for a given subject.\n\n  TODO: This will need to be legal in order to support multiple Planners producing a\n  (mergeable) Classpath for one subject, for example. see:\n    https://github.com/pantsbuild/pants/issues/2526\n  \"\"\"\n\n  def __init__(self, subject, product, matches):\n    msgs = '\\n  '.join('{}: {}'.format(k, v) for k, v in matches.items())\n    msg = 'More than one source of {} for {}:\\n  {}'.format(product.__name__, subject, msgs)\n    super(ConflictingProducersError, self).__init__(msg)\n\n\nclass State(object):\n  @classmethod\n  def raise_unrecognized(cls, state):\n    raise ValueError('Unrecognized Node State: {}'.format(state))\n\n\nclass Noop(datatype('Noop', ['msg']), State):\n  \"\"\"Indicates that a Node did not have the inputs which would be needed for it to execute.\"\"\"\n  pass\n\n\nclass Return(datatype('Return', ['value']), State):\n  \"\"\"Indicates that a Node successfully returned a value.\"\"\"\n  pass\n\n\nclass Throw(datatype('Throw', ['exc']), State):\n  \"\"\"Indicates that a Node should have been able to return a value, but failed.\"\"\"\n  pass\n\n\nclass Waiting(datatype('Waiting', ['dependencies']), State):\n  \"\"\"Indicates that a Node is waiting for some/all of the dependencies to become available.\n\n  Some Nodes will return different dependency Nodes based on where they are in their lifecycle,\n  but all returned dependencies are recorded for the lifetime of a ProductGraph.\n  \"\"\"\n  pass\n\n\nclass Node(object):\n  @abstractproperty\n  def subject(self):\n    \"\"\"The subject for this Node.\"\"\"\n\n  @abstractproperty\n  def product(self):\n    \"\"\"The output product for this Node.\"\"\"\n\n  @abstractproperty\n  def variants(self):\n    \"\"\"The variants for this Node.\"\"\"\n\n  @abstractmethod\n  def step(self, dependency_states, node_builder):\n    \"\"\"Given a dict of the dependency States for this Node, returns the current State of the Node.\n\n    The NodeBuilder parameter provides a way to construct Nodes that require information about\n    installed tasks.\n\n    After this method returns a non-Waiting state, it will never be visited again for this Node.\n    \"\"\"\n\n\nclass SelectNode(datatype('SelectNode', ['subject', 'product', 'variants', 'variant_key']), Node):\n  \"\"\"A Node that selects a product for a subject.\n\n  A Select can be satisfied by multiple sources, but fails if multiple sources produce a value. The\n  'variants' field represents variant configuration that is propagated to dependencies. When\n  a task needs to consume a product as configured by the variants map, it uses the SelectVariant\n  selector, which introduces the 'variant' value to restrict the names of values selected by a\n  SelectNode.\n  \"\"\"\n\n  def _variants_node(self):\n    if self.product != Variants:\n      return SelectNode(self.subject, Variants, self.variants, None)\n    return None\n\n  def _select_literal(self, candidate, variant_value):\n    \"\"\"Looks for has-a or is-a relationships between the given value and the requested product.\n\n    Returns the resulting product value, or None if no match was made.\n    \"\"\"\n    def items():\n      # Check whether the subject is-a instance of the product.\n      yield candidate\n      # Else, check whether it has-a instance of the product.\n      if isinstance(candidate, Target):\n        for configuration in candidate.configurations:\n          yield configuration\n\n    # TODO: returning only the first literal configuration of a given type/variant. Need to\n    # define mergeability for products.\n    for item in items():\n      if not isinstance(item, self.product):\n        continue\n      if variant_value and not getattr(item, 'name', None) == variant_value:\n        continue\n      return item\n    return None\n\n  def step(self, dependency_states, node_builder):\n    # Request default Variants for the subject, so that if there are any we can propagate\n    # them to task nodes.\n    variants = self.variants\n    variants_node = self._variants_node()\n    if variants_node:\n      dep_state = dependency_states.get(variants_node, None)\n      if dep_state is None or type(dep_state) == Waiting:\n        return Waiting([variants_node])\n      elif type(dep_state) == Return:\n        # A subject's variants are overridden by any dependent's requested variants, so\n        # we merge them left to right here.\n        variants = Variants.merge(dep_state.value.default.items(), variants)\n\n    # If there is a variant_key, see whether it has been configured.\n    variant_value = None\n    if self.variant_key:\n      variant_values = [value for key, value in variants\n                        if key == self.variant_key] if variants else None\n      if not variant_values:\n        # Select cannot be satisfied: no variant configured for this key.\n        return Noop('Variant key {} was not configured in variants {}'.format(\n          self.variant_key, variants))\n      variant_value = variant_values[0]\n\n    # If the Subject \"is a\" or \"has a\" Product, then we're done.\n    literal_value = self._select_literal(self.subject, variant_value)\n    if literal_value is not None:\n      return Return(literal_value)\n\n    # Else, attempt to use a configured task to compute the value.\n    has_waiting_dep = False\n    dependencies = list(node_builder.task_nodes(self.subject, self.product, variants))\n    matches = {}\n    for dep in dependencies:\n      dep_state = dependency_states.get(dep, None)\n      if dep_state is None or type(dep_state) == Waiting:\n        has_waiting_dep = True\n        continue\n      elif type(dep_state) == Throw:\n        return dep_state\n      elif type(dep_state) == Noop:\n        continue\n      elif type(dep_state) != Return:\n        State.raise_unrecognized(dep_state)\n      # We computed a value: see whether we can use it.\n      literal_value = self._select_literal(dep_state.value, variant_value)\n      if literal_value is not None:\n        matches[dep] = literal_value\n    if has_waiting_dep:\n      return Waiting(dependencies)\n    elif len(matches) > 1:\n      # TODO: Multiple successful tasks are not currently supported. We should allow for this\n      # by adding support for \"mergeable\" products. see:\n      #   https://github.com/pantsbuild/pants/issues/2526\n      return Throw(ConflictingProducersError(self.subject, self.product, matches))\n    elif len(matches) == 1:\n      return Return(matches.values()[0])\n    return Noop('No source of {}.'.format(self))\n\n\nclass DependenciesNode(datatype('DependenciesNode', ['subject', 'product', 'variants', 'dep_product']), Node):\n  \"\"\"A Node that selects the given Product for each of the dependencies of this subject.\n\n  Begins by selecting the `dep_product` for the subject, and then selects a product for each\n  of dep_products' dependencies.\n\n  The value produced by this Node guarantees that the order of the provided values matches the\n  order of declaration in the `dependencies` list of the `dep_product`.\n  \"\"\"\n\n  def _dep_product_node(self):\n    return SelectNode(self.subject, self.dep_product, self.variants, None)\n\n  def _dep_node(self, dependency):\n    variants = self.variants\n    if isinstance(dependency, Address):\n      # If a subject has literal variants for particular dependencies, they win over all else.\n      dependency, literal_variants = parse_variants(dependency)\n      variants = Variants.merge(variants, literal_variants)\n    return SelectNode(dependency, self.product, variants, None)\n\n  def step(self, dependency_states, node_builder):\n    # Request the product we need in order to request dependencies.\n    dep_product_node = self._dep_product_node()\n    dep_product_state = dependency_states.get(dep_product_node, None)\n    if dep_product_state is None or type(dep_product_state) == Waiting:\n      return Waiting([dep_product_node])\n    elif type(dep_product_state) == Throw:\n      return dep_product_state\n    elif type(dep_product_state) == Noop:\n      return Noop('Could not compute {} to determine dependencies.'.format(dep_product_node))\n    elif type(dep_product_state) != Return:\n      State.raise_unrecognized(dep_product_state)\n\n    # The product and its dependency list are available.\n    dep_product = dep_product_state.value\n    dependencies = [self._dep_node(d) for d in dep_product.dependencies]\n    for dependency in dependencies:\n      dep_state = dependency_states.get(dependency, None)\n      if dep_state is None or type(dep_state) == Waiting:\n        # One of the dependencies is not yet available. Indicate that we are waiting for all\n        # of them.\n        return Waiting([dep_product_node] + dependencies)\n      elif type(dep_state) == Throw:\n        return dep_state\n      elif type(dep_state) == Noop:\n        return Throw(ValueError('No source of explicit dependency {}'.format(dependency)))\n      elif type(dep_state) != Return:\n        raise State.raise_unrecognized(dep_state)\n    # All dependencies are present! Set our value to a list of the resulting values.\n    return Return([dependency_states[d].value for d in dependencies])\n\n\nclass TaskNode(datatype('TaskNode', ['subject', 'product', 'variants', 'func', 'clause']), Node):\n\n  def step(self, dependency_states, node_builder):\n    # Compute dependencies.\n    dep_values = []\n    dependencies = []\n    for select in self.clause:\n      dep = select.construct_node(self.subject, self.variants)\n      if dep is None:\n        return Noop('Dependency {} is not satisfiable.'.format(select))\n      dependencies.append(dep)\n\n    # If all dependency Nodes are Return, execute the Node.\n    for dep_select, dep_key in zip(self.clause, dependencies):\n      dep_state = dependency_states.get(dep_key, None)\n      if dep_state is None or type(dep_state) == Waiting:\n        return Waiting(dependencies)\n      elif type(dep_state) == Return:\n        dep_values.append(dep_state.value)\n      elif type(dep_state) == Noop:\n        if dep_select.optional:\n          dep_values.append(None)\n        else:\n          return Noop('Was missing (at least) input {}.'.format(dep_key))\n      elif type(dep_state) == Throw:\n        return dep_state\n      else:\n        State.raise_unrecognized(dep_state)\n    try:\n      return Return(self.func(*dep_values))\n    except Exception as e:\n      return Throw(e)\n\n\nclass ProductGraph(object):\n",
        "source_code_len": 10229,
        "target_code": "\nclass ProductGraph(object):\n",
        "target_code_len": 29,
        "diff_format": "@@ -134,256 +48,2 @@\n \n-class ConflictingProducersError(SchedulingError):\n-  \"\"\"Indicates that there was more than one source of a product for a given subject.\n-\n-  TODO: This will need to be legal in order to support multiple Planners producing a\n-  (mergeable) Classpath for one subject, for example. see:\n-    https://github.com/pantsbuild/pants/issues/2526\n-  \"\"\"\n-\n-  def __init__(self, subject, product, matches):\n-    msgs = '\\n  '.join('{}: {}'.format(k, v) for k, v in matches.items())\n-    msg = 'More than one source of {} for {}:\\n  {}'.format(product.__name__, subject, msgs)\n-    super(ConflictingProducersError, self).__init__(msg)\n-\n-\n-class State(object):\n-  @classmethod\n-  def raise_unrecognized(cls, state):\n-    raise ValueError('Unrecognized Node State: {}'.format(state))\n-\n-\n-class Noop(datatype('Noop', ['msg']), State):\n-  \"\"\"Indicates that a Node did not have the inputs which would be needed for it to execute.\"\"\"\n-  pass\n-\n-\n-class Return(datatype('Return', ['value']), State):\n-  \"\"\"Indicates that a Node successfully returned a value.\"\"\"\n-  pass\n-\n-\n-class Throw(datatype('Throw', ['exc']), State):\n-  \"\"\"Indicates that a Node should have been able to return a value, but failed.\"\"\"\n-  pass\n-\n-\n-class Waiting(datatype('Waiting', ['dependencies']), State):\n-  \"\"\"Indicates that a Node is waiting for some/all of the dependencies to become available.\n-\n-  Some Nodes will return different dependency Nodes based on where they are in their lifecycle,\n-  but all returned dependencies are recorded for the lifetime of a ProductGraph.\n-  \"\"\"\n-  pass\n-\n-\n-class Node(object):\n-  @abstractproperty\n-  def subject(self):\n-    \"\"\"The subject for this Node.\"\"\"\n-\n-  @abstractproperty\n-  def product(self):\n-    \"\"\"The output product for this Node.\"\"\"\n-\n-  @abstractproperty\n-  def variants(self):\n-    \"\"\"The variants for this Node.\"\"\"\n-\n-  @abstractmethod\n-  def step(self, dependency_states, node_builder):\n-    \"\"\"Given a dict of the dependency States for this Node, returns the current State of the Node.\n-\n-    The NodeBuilder parameter provides a way to construct Nodes that require information about\n-    installed tasks.\n-\n-    After this method returns a non-Waiting state, it will never be visited again for this Node.\n-    \"\"\"\n-\n-\n-class SelectNode(datatype('SelectNode', ['subject', 'product', 'variants', 'variant_key']), Node):\n-  \"\"\"A Node that selects a product for a subject.\n-\n-  A Select can be satisfied by multiple sources, but fails if multiple sources produce a value. The\n-  'variants' field represents variant configuration that is propagated to dependencies. When\n-  a task needs to consume a product as configured by the variants map, it uses the SelectVariant\n-  selector, which introduces the 'variant' value to restrict the names of values selected by a\n-  SelectNode.\n-  \"\"\"\n-\n-  def _variants_node(self):\n-    if self.product != Variants:\n-      return SelectNode(self.subject, Variants, self.variants, None)\n-    return None\n-\n-  def _select_literal(self, candidate, variant_value):\n-    \"\"\"Looks for has-a or is-a relationships between the given value and the requested product.\n-\n-    Returns the resulting product value, or None if no match was made.\n-    \"\"\"\n-    def items():\n-      # Check whether the subject is-a instance of the product.\n-      yield candidate\n-      # Else, check whether it has-a instance of the product.\n-      if isinstance(candidate, Target):\n-        for configuration in candidate.configurations:\n-          yield configuration\n-\n-    # TODO: returning only the first literal configuration of a given type/variant. Need to\n-    # define mergeability for products.\n-    for item in items():\n-      if not isinstance(item, self.product):\n-        continue\n-      if variant_value and not getattr(item, 'name', None) == variant_value:\n-        continue\n-      return item\n-    return None\n-\n-  def step(self, dependency_states, node_builder):\n-    # Request default Variants for the subject, so that if there are any we can propagate\n-    # them to task nodes.\n-    variants = self.variants\n-    variants_node = self._variants_node()\n-    if variants_node:\n-      dep_state = dependency_states.get(variants_node, None)\n-      if dep_state is None or type(dep_state) == Waiting:\n-        return Waiting([variants_node])\n-      elif type(dep_state) == Return:\n-        # A subject's variants are overridden by any dependent's requested variants, so\n-        # we merge them left to right here.\n-        variants = Variants.merge(dep_state.value.default.items(), variants)\n-\n-    # If there is a variant_key, see whether it has been configured.\n-    variant_value = None\n-    if self.variant_key:\n-      variant_values = [value for key, value in variants\n-                        if key == self.variant_key] if variants else None\n-      if not variant_values:\n-        # Select cannot be satisfied: no variant configured for this key.\n-        return Noop('Variant key {} was not configured in variants {}'.format(\n-          self.variant_key, variants))\n-      variant_value = variant_values[0]\n-\n-    # If the Subject \"is a\" or \"has a\" Product, then we're done.\n-    literal_value = self._select_literal(self.subject, variant_value)\n-    if literal_value is not None:\n-      return Return(literal_value)\n-\n-    # Else, attempt to use a configured task to compute the value.\n-    has_waiting_dep = False\n-    dependencies = list(node_builder.task_nodes(self.subject, self.product, variants))\n-    matches = {}\n-    for dep in dependencies:\n-      dep_state = dependency_states.get(dep, None)\n-      if dep_state is None or type(dep_state) == Waiting:\n-        has_waiting_dep = True\n-        continue\n-      elif type(dep_state) == Throw:\n-        return dep_state\n-      elif type(dep_state) == Noop:\n-        continue\n-      elif type(dep_state) != Return:\n-        State.raise_unrecognized(dep_state)\n-      # We computed a value: see whether we can use it.\n-      literal_value = self._select_literal(dep_state.value, variant_value)\n-      if literal_value is not None:\n-        matches[dep] = literal_value\n-    if has_waiting_dep:\n-      return Waiting(dependencies)\n-    elif len(matches) > 1:\n-      # TODO: Multiple successful tasks are not currently supported. We should allow for this\n-      # by adding support for \"mergeable\" products. see:\n-      #   https://github.com/pantsbuild/pants/issues/2526\n-      return Throw(ConflictingProducersError(self.subject, self.product, matches))\n-    elif len(matches) == 1:\n-      return Return(matches.values()[0])\n-    return Noop('No source of {}.'.format(self))\n-\n-\n-class DependenciesNode(datatype('DependenciesNode', ['subject', 'product', 'variants', 'dep_product']), Node):\n-  \"\"\"A Node that selects the given Product for each of the dependencies of this subject.\n-\n-  Begins by selecting the `dep_product` for the subject, and then selects a product for each\n-  of dep_products' dependencies.\n-\n-  The value produced by this Node guarantees that the order of the provided values matches the\n-  order of declaration in the `dependencies` list of the `dep_product`.\n-  \"\"\"\n-\n-  def _dep_product_node(self):\n-    return SelectNode(self.subject, self.dep_product, self.variants, None)\n-\n-  def _dep_node(self, dependency):\n-    variants = self.variants\n-    if isinstance(dependency, Address):\n-      # If a subject has literal variants for particular dependencies, they win over all else.\n-      dependency, literal_variants = parse_variants(dependency)\n-      variants = Variants.merge(variants, literal_variants)\n-    return SelectNode(dependency, self.product, variants, None)\n-\n-  def step(self, dependency_states, node_builder):\n-    # Request the product we need in order to request dependencies.\n-    dep_product_node = self._dep_product_node()\n-    dep_product_state = dependency_states.get(dep_product_node, None)\n-    if dep_product_state is None or type(dep_product_state) == Waiting:\n-      return Waiting([dep_product_node])\n-    elif type(dep_product_state) == Throw:\n-      return dep_product_state\n-    elif type(dep_product_state) == Noop:\n-      return Noop('Could not compute {} to determine dependencies.'.format(dep_product_node))\n-    elif type(dep_product_state) != Return:\n-      State.raise_unrecognized(dep_product_state)\n-\n-    # The product and its dependency list are available.\n-    dep_product = dep_product_state.value\n-    dependencies = [self._dep_node(d) for d in dep_product.dependencies]\n-    for dependency in dependencies:\n-      dep_state = dependency_states.get(dependency, None)\n-      if dep_state is None or type(dep_state) == Waiting:\n-        # One of the dependencies is not yet available. Indicate that we are waiting for all\n-        # of them.\n-        return Waiting([dep_product_node] + dependencies)\n-      elif type(dep_state) == Throw:\n-        return dep_state\n-      elif type(dep_state) == Noop:\n-        return Throw(ValueError('No source of explicit dependency {}'.format(dependency)))\n-      elif type(dep_state) != Return:\n-        raise State.raise_unrecognized(dep_state)\n-    # All dependencies are present! Set our value to a list of the resulting values.\n-    return Return([dependency_states[d].value for d in dependencies])\n-\n-\n-class TaskNode(datatype('TaskNode', ['subject', 'product', 'variants', 'func', 'clause']), Node):\n-\n-  def step(self, dependency_states, node_builder):\n-    # Compute dependencies.\n-    dep_values = []\n-    dependencies = []\n-    for select in self.clause:\n-      dep = select.construct_node(self.subject, self.variants)\n-      if dep is None:\n-        return Noop('Dependency {} is not satisfiable.'.format(select))\n-      dependencies.append(dep)\n-\n-    # If all dependency Nodes are Return, execute the Node.\n-    for dep_select, dep_key in zip(self.clause, dependencies):\n-      dep_state = dependency_states.get(dep_key, None)\n-      if dep_state is None or type(dep_state) == Waiting:\n-        return Waiting(dependencies)\n-      elif type(dep_state) == Return:\n-        dep_values.append(dep_state.value)\n-      elif type(dep_state) == Noop:\n-        if dep_select.optional:\n-          dep_values.append(None)\n-        else:\n-          return Noop('Was missing (at least) input {}.'.format(dep_key))\n-      elif type(dep_state) == Throw:\n-        return dep_state\n-      else:\n-        State.raise_unrecognized(dep_state)\n-    try:\n-      return Return(self.func(*dep_values))\n-    except Exception as e:\n-      return Throw(e)\n-\n-\n class ProductGraph(object):\n",
        "source_code_with_indent": "\n<DED><DED>class ConflictingProducersError(SchedulingError):\n  <IND>\"\"\"Indicates that there was more than one source of a product for a given subject.\n\n  TODO: This will need to be legal in order to support multiple Planners producing a\n  (mergeable) Classpath for one subject, for example. see:\n    https://github.com/pantsbuild/pants/issues/2526\n  \"\"\"\n\n  def __init__(self, subject, product, matches):\n    <IND>msgs = '\\n  '.join('{}: {}'.format(k, v) for k, v in matches.items())\n    msg = 'More than one source of {} for {}:\\n  {}'.format(product.__name__, subject, msgs)\n    super(ConflictingProducersError, self).__init__(msg)\n\n\n<DED><DED>class State(object):\n  <IND>@classmethod\n  def raise_unrecognized(cls, state):\n    <IND>raise ValueError('Unrecognized Node State: {}'.format(state))\n\n\n<DED><DED>class Noop(datatype('Noop', ['msg']), State):\n  <IND>\"\"\"Indicates that a Node did not have the inputs which would be needed for it to execute.\"\"\"\n  pass\n\n\n<DED>class Return(datatype('Return', ['value']), State):\n  <IND>\"\"\"Indicates that a Node successfully returned a value.\"\"\"\n  pass\n\n\n<DED>class Throw(datatype('Throw', ['exc']), State):\n  <IND>\"\"\"Indicates that a Node should have been able to return a value, but failed.\"\"\"\n  pass\n\n\n<DED>class Waiting(datatype('Waiting', ['dependencies']), State):\n  <IND>\"\"\"Indicates that a Node is waiting for some/all of the dependencies to become available.\n\n  Some Nodes will return different dependency Nodes based on where they are in their lifecycle,\n  but all returned dependencies are recorded for the lifetime of a ProductGraph.\n  \"\"\"\n  pass\n\n\n<DED>class Node(object):\n  <IND>@abstractproperty\n  def subject(self):\n    <IND>\"\"\"The subject for this Node.\"\"\"\n\n  <DED>@abstractproperty\n  def product(self):\n    <IND>\"\"\"The output product for this Node.\"\"\"\n\n  <DED>@abstractproperty\n  def variants(self):\n    <IND>\"\"\"The variants for this Node.\"\"\"\n\n  <DED>@abstractmethod\n  def step(self, dependency_states, node_builder):\n    <IND>\"\"\"Given a dict of the dependency States for this Node, returns the current State of the Node.\n\n    The NodeBuilder parameter provides a way to construct Nodes that require information about\n    installed tasks.\n\n    After this method returns a non-Waiting state, it will never be visited again for this Node.\n    \"\"\"\n\n\n<DED><DED>class SelectNode(datatype('SelectNode', ['subject', 'product', 'variants', 'variant_key']), Node):\n  <IND>\"\"\"A Node that selects a product for a subject.\n\n  A Select can be satisfied by multiple sources, but fails if multiple sources produce a value. The\n  'variants' field represents variant configuration that is propagated to dependencies. When\n  a task needs to consume a product as configured by the variants map, it uses the SelectVariant\n  selector, which introduces the 'variant' value to restrict the names of values selected by a\n  SelectNode.\n  \"\"\"\n\n  def _variants_node(self):\n    <IND>if self.product != Variants:\n      <IND>return SelectNode(self.subject, Variants, self.variants, None)\n    <DED>return None\n\n  <DED>def _select_literal(self, candidate, variant_value):\n    <IND>\"\"\"Looks for has-a or is-a relationships between the given value and the requested product.\n\n    Returns the resulting product value, or None if no match was made.\n    \"\"\"\n    def items():\n      # Check whether the subject is-a instance of the product.\n      <IND>yield candidate\n      # Else, check whether it has-a instance of the product.\n      if isinstance(candidate, Target):\n        <IND>for configuration in candidate.configurations:\n          <IND>yield configuration\n\n    # TODO: returning only the first literal configuration of a given type/variant. Need to\n    # define mergeability for products.\n    <DED><DED><DED>for item in items():\n      <IND>if not isinstance(item, self.product):\n        <IND>continue\n      <DED>if variant_value and not getattr(item, 'name', None) == variant_value:\n        <IND>continue\n      <DED>return item\n    <DED>return None\n\n  <DED>def step(self, dependency_states, node_builder):\n    # Request default Variants for the subject, so that if there are any we can propagate\n    # them to task nodes.\n    <IND>variants = self.variants\n    variants_node = self._variants_node()\n    if variants_node:\n      <IND>dep_state = dependency_states.get(variants_node, None)\n      if dep_state is None or type(dep_state) == Waiting:\n        <IND>return Waiting([variants_node])\n      <DED>elif type(dep_state) == Return:\n        # A subject's variants are overridden by any dependent's requested variants, so\n        # we merge them left to right here.\n        <IND>variants = Variants.merge(dep_state.value.default.items(), variants)\n\n    # If there is a variant_key, see whether it has been configured.\n    <DED><DED>variant_value = None\n    if self.variant_key:\n      <IND>variant_values = [value for key, value in variants\n                        if key == self.variant_key] if variants else None\n      if not variant_values:\n        # Select cannot be satisfied: no variant configured for this key.\n        <IND>return Noop('Variant key {} was not configured in variants {}'.format(\n          self.variant_key, variants))\n      <DED>variant_value = variant_values[0]\n\n    # If the Subject \"is a\" or \"has a\" Product, then we're done.\n    <DED>literal_value = self._select_literal(self.subject, variant_value)\n    if literal_value is not None:\n      <IND>return Return(literal_value)\n\n    # Else, attempt to use a configured task to compute the value.\n    <DED>has_waiting_dep = False\n    dependencies = list(node_builder.task_nodes(self.subject, self.product, variants))\n    matches = {}\n    for dep in dependencies:\n      <IND>dep_state = dependency_states.get(dep, None)\n      if dep_state is None or type(dep_state) == Waiting:\n        <IND>has_waiting_dep = True\n        continue\n      <DED>elif type(dep_state) == Throw:\n        <IND>return dep_state\n      <DED>elif type(dep_state) == Noop:\n        <IND>continue\n      <DED>elif type(dep_state) != Return:\n        <IND>State.raise_unrecognized(dep_state)\n      # We computed a value: see whether we can use it.\n      <DED>literal_value = self._select_literal(dep_state.value, variant_value)\n      if literal_value is not None:\n        <IND>matches[dep] = literal_value\n    <DED><DED>if has_waiting_dep:\n      <IND>return Waiting(dependencies)\n    <DED>elif len(matches) > 1:\n      # TODO: Multiple successful tasks are not currently supported. We should allow for this\n      # by adding support for \"mergeable\" products. see:\n      #   https://github.com/pantsbuild/pants/issues/2526\n      <IND>return Throw(ConflictingProducersError(self.subject, self.product, matches))\n    <DED>elif len(matches) == 1:\n      <IND>return Return(matches.values()[0])\n    <DED>return Noop('No source of {}.'.format(self))\n\n\n<DED><DED>class DependenciesNode(datatype('DependenciesNode', ['subject', 'product', 'variants', 'dep_product']), Node):\n  <IND>\"\"\"A Node that selects the given Product for each of the dependencies of this subject.\n\n  Begins by selecting the `dep_product` for the subject, and then selects a product for each\n  of dep_products' dependencies.\n\n  The value produced by this Node guarantees that the order of the provided values matches the\n  order of declaration in the `dependencies` list of the `dep_product`.\n  \"\"\"\n\n  def _dep_product_node(self):\n    <IND>return SelectNode(self.subject, self.dep_product, self.variants, None)\n\n  <DED>def _dep_node(self, dependency):\n    <IND>variants = self.variants\n    if isinstance(dependency, Address):\n      # If a subject has literal variants for particular dependencies, they win over all else.\n      <IND>dependency, literal_variants = parse_variants(dependency)\n      variants = Variants.merge(variants, literal_variants)\n    <DED>return SelectNode(dependency, self.product, variants, None)\n\n  <DED>def step(self, dependency_states, node_builder):\n    # Request the product we need in order to request dependencies.\n    <IND>dep_product_node = self._dep_product_node()\n    dep_product_state = dependency_states.get(dep_product_node, None)\n    if dep_product_state is None or type(dep_product_state) == Waiting:\n      <IND>return Waiting([dep_product_node])\n    <DED>elif type(dep_product_state) == Throw:\n      <IND>return dep_product_state\n    <DED>elif type(dep_product_state) == Noop:\n      <IND>return Noop('Could not compute {} to determine dependencies.'.format(dep_product_node))\n    <DED>elif type(dep_product_state) != Return:\n      <IND>State.raise_unrecognized(dep_product_state)\n\n    # The product and its dependency list are available.\n    <DED>dep_product = dep_product_state.value\n    dependencies = [self._dep_node(d) for d in dep_product.dependencies]\n    for dependency in dependencies:\n      <IND>dep_state = dependency_states.get(dependency, None)\n      if dep_state is None or type(dep_state) == Waiting:\n        # One of the dependencies is not yet available. Indicate that we are waiting for all\n        # of them.\n        <IND>return Waiting([dep_product_node] + dependencies)\n      <DED>elif type(dep_state) == Throw:\n        <IND>return dep_state\n      <DED>elif type(dep_state) == Noop:\n        <IND>return Throw(ValueError('No source of explicit dependency {}'.format(dependency)))\n      <DED>elif type(dep_state) != Return:\n        <IND>raise State.raise_unrecognized(dep_state)\n    # All dependencies are present! Set our value to a list of the resulting values.\n    <DED><DED>return Return([dependency_states[d].value for d in dependencies])\n\n\n<DED><DED>class TaskNode(datatype('TaskNode', ['subject', 'product', 'variants', 'func', 'clause']), Node):\n\n  <IND>def step(self, dependency_states, node_builder):\n    # Compute dependencies.\n    <IND>dep_values = []\n    dependencies = []\n    for select in self.clause:\n      <IND>dep = select.construct_node(self.subject, self.variants)\n      if dep is None:\n        <IND>return Noop('Dependency {} is not satisfiable.'.format(select))\n      <DED>dependencies.append(dep)\n\n    # If all dependency Nodes are Return, execute the Node.\n    <DED>for dep_select, dep_key in zip(self.clause, dependencies):\n      <IND>dep_state = dependency_states.get(dep_key, None)\n      if dep_state is None or type(dep_state) == Waiting:\n        <IND>return Waiting(dependencies)\n      <DED>elif type(dep_state) == Return:\n        <IND>dep_values.append(dep_state.value)\n      <DED>elif type(dep_state) == Noop:\n        <IND>if dep_select.optional:\n          <IND>dep_values.append(None)\n        <DED>else:\n          <IND>return Noop('Was missing (at least) input {}.'.format(dep_key))\n      <DED><DED>elif type(dep_state) == Throw:\n        <IND>return dep_state\n      <DED>else:\n        <IND>State.raise_unrecognized(dep_state)\n    <DED><DED>try:\n      <IND>return Return(self.func(*dep_values))\n    <DED>except Exception as e:\n      <IND>return Throw(e)\n\n\n<DED><DED><DED>class ProductGraph(object):\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n<DED><DED>class ProductGraph(object):\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "pantsbuild/pants",
    "commit": "08bc2add6e98feefdce36f6f094a15e3e598b1e7",
    "filename": "src/python/pants/engine/exp/scheduler.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/pantsbuild-pants/src/python/pants/engine/exp/scheduler.py",
    "file_hunks_size": 13,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "src/python/pants/engine/exp/scheduler.py:48:20 Invalid type [31]: Expression `pants.util.objects.datatype(\"Variant\", [\"product\", \"variant_key\"])` is not a valid type.",
    "message": " Expression `pants.util.objects.datatype(\"Variant\", [\"product\", \"variant_key\"])` is not a valid type.",
    "rule_id": "Invalid type [31]",
    "warning_line_no": 48,
    "warning_line": "class SelectVariant(datatype('Variant', ['product', 'variant_key']), Selector):",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\nclass Selector(AbstractClass):\n  @abstractproperty\n  def optional(self):\n    \"\"\"Return true if this Selector is optional. It may result in a `None` match.\"\"\"\n\n  @abstractmethod\n  def construct_node(self, subject, variants):\n    \"\"\"Constructs a Node for this Selector and the given Subject/Variants.\n\n    May return None if the Selector can be known statically to not be satisfiable for the inputs.\n    \"\"\"\n\n\nclass Select(datatype('Subject', ['product', 'optional']), Selector):\n  \"\"\"Selects the given Product for the Subject provided to the constructor.\n\n  If optional=True and no matching product can be produced, will return None.\n  \"\"\"\n\n  def __new__(self, product, optional=False):\n    return super(Select, self).__new__(self, product, optional)\n\n  def construct_node(self, subject, variants):\n    return SelectNode(subject, self.product, variants, None)\n\n\nclass SelectVariant(datatype('Variant', ['product', 'variant_key']), Selector):\n  \"\"\"Selects the matching Product and variant name for the Subject provided to the constructor.\n\n  For example: a SelectVariant with a variant_key of \"thrift\" and a product of type ApacheThrift\n  will only match when a consumer passes a variant value for \"thrift\" that matches the name of an\n  ApacheThrift value.\n  \"\"\"\n  optional = False\n\n  def construct_node(self, subject, variants):\n    return SelectNode(subject, self.product, variants, self.variant_key)\n\n\nclass SelectDependencies(datatype('Dependencies', ['product', 'deps_product']), Selector):\n  \"\"\"Selects a product for each of the dependencies of a product for the Subject.\n\n  The dependencies declared on `deps_product` will be provided to the requesting task\n  in the order they were declared.\n  \"\"\"\n  optional = False\n\n  def construct_node(self, subject, variants):\n    return DependenciesNode(subject, self.product, variants, self.deps_product)\n\n\nclass SelectProjection(datatype('Projection', ['product', 'projected_product', 'fields', 'input_product']), Selector):\n  \"\"\"Selects a field of the given Subject to produce a Subject, Product dependency from.\n\n  Projecting an input allows for deduplication in the graph, where multiple Subjects\n  resolve to a single backing Subject instead.\n  \"\"\"\n  optional = False\n\n  def construct_node(self, subject, variants):\n    # Input product type doesn't match: not satisfiable.\n    if not type(subject) == self.input_product:\n      return None\n\n    # Find the fields of the Subject to project.\n    values = []\n    for field in self.fields:\n      values.append(getattr(subject, field))\n    projected_subject = self.projected_product(*values)\n    return SelectNode(projected_subject, self.product, variants, None)\n\n\nclass SelectLiteral(datatype('Literal', ['subject', 'product']), Selector):\n  \"\"\"Selects a literal Subject (other than the one applied to the selector).\"\"\"\n  optional = False\n\n  def construct_node(self, subject, variants):\n    # NB: Intentionally ignores subject parameter to provide a literal subject.\n    return SelectNode(self.subject, self.product, variants, None)\n\n\nclass SchedulingError(Exception):\n  \"\"\"Indicates inability to make a scheduling promise.\"\"\"\n\n\nclass PartiallyConsumedInputsError(SchedulingError):\n  \"\"\"No task was able to consume a particular literal product for a subject, although some tried.\n",
        "source_code_len": 3277,
        "target_code": "\nclass PartiallyConsumedInputsError(Exception):\n  \"\"\"No task was able to consume a particular literal product for a subject, although some tried.\n",
        "target_code_len": 146,
        "diff_format": "@@ -21,88 +20,3 @@\n \n-class Selector(AbstractClass):\n-  @abstractproperty\n-  def optional(self):\n-    \"\"\"Return true if this Selector is optional. It may result in a `None` match.\"\"\"\n-\n-  @abstractmethod\n-  def construct_node(self, subject, variants):\n-    \"\"\"Constructs a Node for this Selector and the given Subject/Variants.\n-\n-    May return None if the Selector can be known statically to not be satisfiable for the inputs.\n-    \"\"\"\n-\n-\n-class Select(datatype('Subject', ['product', 'optional']), Selector):\n-  \"\"\"Selects the given Product for the Subject provided to the constructor.\n-\n-  If optional=True and no matching product can be produced, will return None.\n-  \"\"\"\n-\n-  def __new__(self, product, optional=False):\n-    return super(Select, self).__new__(self, product, optional)\n-\n-  def construct_node(self, subject, variants):\n-    return SelectNode(subject, self.product, variants, None)\n-\n-\n-class SelectVariant(datatype('Variant', ['product', 'variant_key']), Selector):\n-  \"\"\"Selects the matching Product and variant name for the Subject provided to the constructor.\n-\n-  For example: a SelectVariant with a variant_key of \"thrift\" and a product of type ApacheThrift\n-  will only match when a consumer passes a variant value for \"thrift\" that matches the name of an\n-  ApacheThrift value.\n-  \"\"\"\n-  optional = False\n-\n-  def construct_node(self, subject, variants):\n-    return SelectNode(subject, self.product, variants, self.variant_key)\n-\n-\n-class SelectDependencies(datatype('Dependencies', ['product', 'deps_product']), Selector):\n-  \"\"\"Selects a product for each of the dependencies of a product for the Subject.\n-\n-  The dependencies declared on `deps_product` will be provided to the requesting task\n-  in the order they were declared.\n-  \"\"\"\n-  optional = False\n-\n-  def construct_node(self, subject, variants):\n-    return DependenciesNode(subject, self.product, variants, self.deps_product)\n-\n-\n-class SelectProjection(datatype('Projection', ['product', 'projected_product', 'fields', 'input_product']), Selector):\n-  \"\"\"Selects a field of the given Subject to produce a Subject, Product dependency from.\n-\n-  Projecting an input allows for deduplication in the graph, where multiple Subjects\n-  resolve to a single backing Subject instead.\n-  \"\"\"\n-  optional = False\n-\n-  def construct_node(self, subject, variants):\n-    # Input product type doesn't match: not satisfiable.\n-    if not type(subject) == self.input_product:\n-      return None\n-\n-    # Find the fields of the Subject to project.\n-    values = []\n-    for field in self.fields:\n-      values.append(getattr(subject, field))\n-    projected_subject = self.projected_product(*values)\n-    return SelectNode(projected_subject, self.product, variants, None)\n-\n-\n-class SelectLiteral(datatype('Literal', ['subject', 'product']), Selector):\n-  \"\"\"Selects a literal Subject (other than the one applied to the selector).\"\"\"\n-  optional = False\n-\n-  def construct_node(self, subject, variants):\n-    # NB: Intentionally ignores subject parameter to provide a literal subject.\n-    return SelectNode(self.subject, self.product, variants, None)\n-\n-\n-class SchedulingError(Exception):\n-  \"\"\"Indicates inability to make a scheduling promise.\"\"\"\n-\n-\n-class PartiallyConsumedInputsError(SchedulingError):\n+class PartiallyConsumedInputsError(Exception):\n   \"\"\"No task was able to consume a particular literal product for a subject, although some tried.\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\nclass Selector(AbstractClass):\n  <IND>@abstractproperty\n  def optional(self):\n    <IND>\"\"\"Return true if this Selector is optional. It may result in a `None` match.\"\"\"\n\n  <DED>@abstractmethod\n  def construct_node(self, subject, variants):\n    <IND>\"\"\"Constructs a Node for this Selector and the given Subject/Variants.\n\n    May return None if the Selector can be known statically to not be satisfiable for the inputs.\n    \"\"\"\n\n\n<DED><DED>class Select(datatype('Subject', ['product', 'optional']), Selector):\n  <IND>\"\"\"Selects the given Product for the Subject provided to the constructor.\n\n  If optional=True and no matching product can be produced, will return None.\n  \"\"\"\n\n  def __new__(self, product, optional=False):\n    <IND>return super(Select, self).__new__(self, product, optional)\n\n  <DED>def construct_node(self, subject, variants):\n    <IND>return SelectNode(subject, self.product, variants, None)\n\n\n<DED><DED>class SelectVariant(datatype('Variant', ['product', 'variant_key']), Selector):\n  <IND>\"\"\"Selects the matching Product and variant name for the Subject provided to the constructor.\n\n  For example: a SelectVariant with a variant_key of \"thrift\" and a product of type ApacheThrift\n  will only match when a consumer passes a variant value for \"thrift\" that matches the name of an\n  ApacheThrift value.\n  \"\"\"\n  optional = False\n\n  def construct_node(self, subject, variants):\n    <IND>return SelectNode(subject, self.product, variants, self.variant_key)\n\n\n<DED><DED>class SelectDependencies(datatype('Dependencies', ['product', 'deps_product']), Selector):\n  <IND>\"\"\"Selects a product for each of the dependencies of a product for the Subject.\n\n  The dependencies declared on `deps_product` will be provided to the requesting task\n  in the order they were declared.\n  \"\"\"\n  optional = False\n\n  def construct_node(self, subject, variants):\n    <IND>return DependenciesNode(subject, self.product, variants, self.deps_product)\n\n\n<DED><DED>class SelectProjection(datatype('Projection', ['product', 'projected_product', 'fields', 'input_product']), Selector):\n  <IND>\"\"\"Selects a field of the given Subject to produce a Subject, Product dependency from.\n\n  Projecting an input allows for deduplication in the graph, where multiple Subjects\n  resolve to a single backing Subject instead.\n  \"\"\"\n  optional = False\n\n  def construct_node(self, subject, variants):\n    # Input product type doesn't match: not satisfiable.\n    <IND>if not type(subject) == self.input_product:\n      <IND>return None\n\n    # Find the fields of the Subject to project.\n    <DED>values = []\n    for field in self.fields:\n      <IND>values.append(getattr(subject, field))\n    <DED>projected_subject = self.projected_product(*values)\n    return SelectNode(projected_subject, self.product, variants, None)\n\n\n<DED><DED>class SelectLiteral(datatype('Literal', ['subject', 'product']), Selector):\n  <IND>\"\"\"Selects a literal Subject (other than the one applied to the selector).\"\"\"\n  optional = False\n\n  def construct_node(self, subject, variants):\n    # NB: Intentionally ignores subject parameter to provide a literal subject.\n    <IND>return SelectNode(self.subject, self.product, variants, None)\n\n\n<DED><DED>class SchedulingError(Exception):\n  <IND>\"\"\"Indicates inability to make a scheduling promise.\"\"\"\n\n\n<DED>class PartiallyConsumedInputsError(SchedulingError):\n  <IND>",
        "target_code_with_indent": "\nclass PartiallyConsumedInputsError(Exception):\n  <IND>"
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": true,
        "has_suppression": false,
        "source_code": "\nclass ConflictingProducersError(SchedulingError):\n  \"\"\"Indicates that there was more than one source of a product for a given subject.\n\n  TODO: This will need to be legal in order to support multiple Planners producing a\n  (mergeable) Classpath for one subject, for example. see:\n    https://github.com/pantsbuild/pants/issues/2526\n  \"\"\"\n\n  def __init__(self, subject, product, matches):\n    msgs = '\\n  '.join('{}: {}'.format(k, v) for k, v in matches.items())\n    msg = 'More than one source of {} for {}:\\n  {}'.format(product.__name__, subject, msgs)\n    super(ConflictingProducersError, self).__init__(msg)\n\n\nclass State(object):\n  @classmethod\n  def raise_unrecognized(cls, state):\n    raise ValueError('Unrecognized Node State: {}'.format(state))\n\n\nclass Noop(datatype('Noop', ['msg']), State):\n  \"\"\"Indicates that a Node did not have the inputs which would be needed for it to execute.\"\"\"\n  pass\n\n\nclass Return(datatype('Return', ['value']), State):\n  \"\"\"Indicates that a Node successfully returned a value.\"\"\"\n  pass\n\n\nclass Throw(datatype('Throw', ['exc']), State):\n  \"\"\"Indicates that a Node should have been able to return a value, but failed.\"\"\"\n  pass\n\n\nclass Waiting(datatype('Waiting', ['dependencies']), State):\n  \"\"\"Indicates that a Node is waiting for some/all of the dependencies to become available.\n\n  Some Nodes will return different dependency Nodes based on where they are in their lifecycle,\n  but all returned dependencies are recorded for the lifetime of a ProductGraph.\n  \"\"\"\n  pass\n\n\nclass Node(object):\n  @abstractproperty\n  def subject(self):\n    \"\"\"The subject for this Node.\"\"\"\n\n  @abstractproperty\n  def product(self):\n    \"\"\"The output product for this Node.\"\"\"\n\n  @abstractproperty\n  def variants(self):\n    \"\"\"The variants for this Node.\"\"\"\n\n  @abstractmethod\n  def step(self, dependency_states, node_builder):\n    \"\"\"Given a dict of the dependency States for this Node, returns the current State of the Node.\n\n    The NodeBuilder parameter provides a way to construct Nodes that require information about\n    installed tasks.\n\n    After this method returns a non-Waiting state, it will never be visited again for this Node.\n    \"\"\"\n\n\nclass SelectNode(datatype('SelectNode', ['subject', 'product', 'variants', 'variant_key']), Node):\n  \"\"\"A Node that selects a product for a subject.\n\n  A Select can be satisfied by multiple sources, but fails if multiple sources produce a value. The\n  'variants' field represents variant configuration that is propagated to dependencies. When\n  a task needs to consume a product as configured by the variants map, it uses the SelectVariant\n  selector, which introduces the 'variant' value to restrict the names of values selected by a\n  SelectNode.\n  \"\"\"\n\n  def _variants_node(self):\n    if self.product != Variants:\n      return SelectNode(self.subject, Variants, self.variants, None)\n    return None\n\n  def _select_literal(self, candidate, variant_value):\n    \"\"\"Looks for has-a or is-a relationships between the given value and the requested product.\n\n    Returns the resulting product value, or None if no match was made.\n    \"\"\"\n    def items():\n      # Check whether the subject is-a instance of the product.\n      yield candidate\n      # Else, check whether it has-a instance of the product.\n      if isinstance(candidate, Target):\n        for configuration in candidate.configurations:\n          yield configuration\n\n    # TODO: returning only the first literal configuration of a given type/variant. Need to\n    # define mergeability for products.\n    for item in items():\n      if not isinstance(item, self.product):\n        continue\n      if variant_value and not getattr(item, 'name', None) == variant_value:\n        continue\n      return item\n    return None\n\n  def step(self, dependency_states, node_builder):\n    # Request default Variants for the subject, so that if there are any we can propagate\n    # them to task nodes.\n    variants = self.variants\n    variants_node = self._variants_node()\n    if variants_node:\n      dep_state = dependency_states.get(variants_node, None)\n      if dep_state is None or type(dep_state) == Waiting:\n        return Waiting([variants_node])\n      elif type(dep_state) == Return:\n        # A subject's variants are overridden by any dependent's requested variants, so\n        # we merge them left to right here.\n        variants = Variants.merge(dep_state.value.default.items(), variants)\n\n    # If there is a variant_key, see whether it has been configured.\n    variant_value = None\n    if self.variant_key:\n      variant_values = [value for key, value in variants\n                        if key == self.variant_key] if variants else None\n      if not variant_values:\n        # Select cannot be satisfied: no variant configured for this key.\n        return Noop('Variant key {} was not configured in variants {}'.format(\n          self.variant_key, variants))\n      variant_value = variant_values[0]\n\n    # If the Subject \"is a\" or \"has a\" Product, then we're done.\n    literal_value = self._select_literal(self.subject, variant_value)\n    if literal_value is not None:\n      return Return(literal_value)\n\n    # Else, attempt to use a configured task to compute the value.\n    has_waiting_dep = False\n    dependencies = list(node_builder.task_nodes(self.subject, self.product, variants))\n    matches = {}\n    for dep in dependencies:\n      dep_state = dependency_states.get(dep, None)\n      if dep_state is None or type(dep_state) == Waiting:\n        has_waiting_dep = True\n        continue\n      elif type(dep_state) == Throw:\n        return dep_state\n      elif type(dep_state) == Noop:\n        continue\n      elif type(dep_state) != Return:\n        State.raise_unrecognized(dep_state)\n      # We computed a value: see whether we can use it.\n      literal_value = self._select_literal(dep_state.value, variant_value)\n      if literal_value is not None:\n        matches[dep] = literal_value\n    if has_waiting_dep:\n      return Waiting(dependencies)\n    elif len(matches) > 1:\n      # TODO: Multiple successful tasks are not currently supported. We should allow for this\n      # by adding support for \"mergeable\" products. see:\n      #   https://github.com/pantsbuild/pants/issues/2526\n      return Throw(ConflictingProducersError(self.subject, self.product, matches))\n    elif len(matches) == 1:\n      return Return(matches.values()[0])\n    return Noop('No source of {}.'.format(self))\n\n\nclass DependenciesNode(datatype('DependenciesNode', ['subject', 'product', 'variants', 'dep_product']), Node):\n  \"\"\"A Node that selects the given Product for each of the dependencies of this subject.\n\n  Begins by selecting the `dep_product` for the subject, and then selects a product for each\n  of dep_products' dependencies.\n\n  The value produced by this Node guarantees that the order of the provided values matches the\n  order of declaration in the `dependencies` list of the `dep_product`.\n  \"\"\"\n\n  def _dep_product_node(self):\n    return SelectNode(self.subject, self.dep_product, self.variants, None)\n\n  def _dep_node(self, dependency):\n    variants = self.variants\n    if isinstance(dependency, Address):\n      # If a subject has literal variants for particular dependencies, they win over all else.\n      dependency, literal_variants = parse_variants(dependency)\n      variants = Variants.merge(variants, literal_variants)\n    return SelectNode(dependency, self.product, variants, None)\n\n  def step(self, dependency_states, node_builder):\n    # Request the product we need in order to request dependencies.\n    dep_product_node = self._dep_product_node()\n    dep_product_state = dependency_states.get(dep_product_node, None)\n    if dep_product_state is None or type(dep_product_state) == Waiting:\n      return Waiting([dep_product_node])\n    elif type(dep_product_state) == Throw:\n      return dep_product_state\n    elif type(dep_product_state) == Noop:\n      return Noop('Could not compute {} to determine dependencies.'.format(dep_product_node))\n    elif type(dep_product_state) != Return:\n      State.raise_unrecognized(dep_product_state)\n\n    # The product and its dependency list are available.\n    dep_product = dep_product_state.value\n    dependencies = [self._dep_node(d) for d in dep_product.dependencies]\n    for dependency in dependencies:\n      dep_state = dependency_states.get(dependency, None)\n      if dep_state is None or type(dep_state) == Waiting:\n        # One of the dependencies is not yet available. Indicate that we are waiting for all\n        # of them.\n        return Waiting([dep_product_node] + dependencies)\n      elif type(dep_state) == Throw:\n        return dep_state\n      elif type(dep_state) == Noop:\n        return Throw(ValueError('No source of explicit dependency {}'.format(dependency)))\n      elif type(dep_state) != Return:\n        raise State.raise_unrecognized(dep_state)\n    # All dependencies are present! Set our value to a list of the resulting values.\n    return Return([dependency_states[d].value for d in dependencies])\n\n\nclass TaskNode(datatype('TaskNode', ['subject', 'product', 'variants', 'func', 'clause']), Node):\n\n  def step(self, dependency_states, node_builder):\n    # Compute dependencies.\n    dep_values = []\n    dependencies = []\n    for select in self.clause:\n      dep = select.construct_node(self.subject, self.variants)\n      if dep is None:\n        return Noop('Dependency {} is not satisfiable.'.format(select))\n      dependencies.append(dep)\n\n    # If all dependency Nodes are Return, execute the Node.\n    for dep_select, dep_key in zip(self.clause, dependencies):\n      dep_state = dependency_states.get(dep_key, None)\n      if dep_state is None or type(dep_state) == Waiting:\n        return Waiting(dependencies)\n      elif type(dep_state) == Return:\n        dep_values.append(dep_state.value)\n      elif type(dep_state) == Noop:\n        if dep_select.optional:\n          dep_values.append(None)\n        else:\n          return Noop('Was missing (at least) input {}.'.format(dep_key))\n      elif type(dep_state) == Throw:\n        return dep_state\n      else:\n        State.raise_unrecognized(dep_state)\n    try:\n      return Return(self.func(*dep_values))\n    except Exception as e:\n      return Throw(e)\n\n\nclass ProductGraph(object):\n",
        "source_code_len": 10229,
        "target_code": "\nclass ProductGraph(object):\n",
        "target_code_len": 29,
        "diff_format": "@@ -134,256 +48,2 @@\n \n-class ConflictingProducersError(SchedulingError):\n-  \"\"\"Indicates that there was more than one source of a product for a given subject.\n-\n-  TODO: This will need to be legal in order to support multiple Planners producing a\n-  (mergeable) Classpath for one subject, for example. see:\n-    https://github.com/pantsbuild/pants/issues/2526\n-  \"\"\"\n-\n-  def __init__(self, subject, product, matches):\n-    msgs = '\\n  '.join('{}: {}'.format(k, v) for k, v in matches.items())\n-    msg = 'More than one source of {} for {}:\\n  {}'.format(product.__name__, subject, msgs)\n-    super(ConflictingProducersError, self).__init__(msg)\n-\n-\n-class State(object):\n-  @classmethod\n-  def raise_unrecognized(cls, state):\n-    raise ValueError('Unrecognized Node State: {}'.format(state))\n-\n-\n-class Noop(datatype('Noop', ['msg']), State):\n-  \"\"\"Indicates that a Node did not have the inputs which would be needed for it to execute.\"\"\"\n-  pass\n-\n-\n-class Return(datatype('Return', ['value']), State):\n-  \"\"\"Indicates that a Node successfully returned a value.\"\"\"\n-  pass\n-\n-\n-class Throw(datatype('Throw', ['exc']), State):\n-  \"\"\"Indicates that a Node should have been able to return a value, but failed.\"\"\"\n-  pass\n-\n-\n-class Waiting(datatype('Waiting', ['dependencies']), State):\n-  \"\"\"Indicates that a Node is waiting for some/all of the dependencies to become available.\n-\n-  Some Nodes will return different dependency Nodes based on where they are in their lifecycle,\n-  but all returned dependencies are recorded for the lifetime of a ProductGraph.\n-  \"\"\"\n-  pass\n-\n-\n-class Node(object):\n-  @abstractproperty\n-  def subject(self):\n-    \"\"\"The subject for this Node.\"\"\"\n-\n-  @abstractproperty\n-  def product(self):\n-    \"\"\"The output product for this Node.\"\"\"\n-\n-  @abstractproperty\n-  def variants(self):\n-    \"\"\"The variants for this Node.\"\"\"\n-\n-  @abstractmethod\n-  def step(self, dependency_states, node_builder):\n-    \"\"\"Given a dict of the dependency States for this Node, returns the current State of the Node.\n-\n-    The NodeBuilder parameter provides a way to construct Nodes that require information about\n-    installed tasks.\n-\n-    After this method returns a non-Waiting state, it will never be visited again for this Node.\n-    \"\"\"\n-\n-\n-class SelectNode(datatype('SelectNode', ['subject', 'product', 'variants', 'variant_key']), Node):\n-  \"\"\"A Node that selects a product for a subject.\n-\n-  A Select can be satisfied by multiple sources, but fails if multiple sources produce a value. The\n-  'variants' field represents variant configuration that is propagated to dependencies. When\n-  a task needs to consume a product as configured by the variants map, it uses the SelectVariant\n-  selector, which introduces the 'variant' value to restrict the names of values selected by a\n-  SelectNode.\n-  \"\"\"\n-\n-  def _variants_node(self):\n-    if self.product != Variants:\n-      return SelectNode(self.subject, Variants, self.variants, None)\n-    return None\n-\n-  def _select_literal(self, candidate, variant_value):\n-    \"\"\"Looks for has-a or is-a relationships between the given value and the requested product.\n-\n-    Returns the resulting product value, or None if no match was made.\n-    \"\"\"\n-    def items():\n-      # Check whether the subject is-a instance of the product.\n-      yield candidate\n-      # Else, check whether it has-a instance of the product.\n-      if isinstance(candidate, Target):\n-        for configuration in candidate.configurations:\n-          yield configuration\n-\n-    # TODO: returning only the first literal configuration of a given type/variant. Need to\n-    # define mergeability for products.\n-    for item in items():\n-      if not isinstance(item, self.product):\n-        continue\n-      if variant_value and not getattr(item, 'name', None) == variant_value:\n-        continue\n-      return item\n-    return None\n-\n-  def step(self, dependency_states, node_builder):\n-    # Request default Variants for the subject, so that if there are any we can propagate\n-    # them to task nodes.\n-    variants = self.variants\n-    variants_node = self._variants_node()\n-    if variants_node:\n-      dep_state = dependency_states.get(variants_node, None)\n-      if dep_state is None or type(dep_state) == Waiting:\n-        return Waiting([variants_node])\n-      elif type(dep_state) == Return:\n-        # A subject's variants are overridden by any dependent's requested variants, so\n-        # we merge them left to right here.\n-        variants = Variants.merge(dep_state.value.default.items(), variants)\n-\n-    # If there is a variant_key, see whether it has been configured.\n-    variant_value = None\n-    if self.variant_key:\n-      variant_values = [value for key, value in variants\n-                        if key == self.variant_key] if variants else None\n-      if not variant_values:\n-        # Select cannot be satisfied: no variant configured for this key.\n-        return Noop('Variant key {} was not configured in variants {}'.format(\n-          self.variant_key, variants))\n-      variant_value = variant_values[0]\n-\n-    # If the Subject \"is a\" or \"has a\" Product, then we're done.\n-    literal_value = self._select_literal(self.subject, variant_value)\n-    if literal_value is not None:\n-      return Return(literal_value)\n-\n-    # Else, attempt to use a configured task to compute the value.\n-    has_waiting_dep = False\n-    dependencies = list(node_builder.task_nodes(self.subject, self.product, variants))\n-    matches = {}\n-    for dep in dependencies:\n-      dep_state = dependency_states.get(dep, None)\n-      if dep_state is None or type(dep_state) == Waiting:\n-        has_waiting_dep = True\n-        continue\n-      elif type(dep_state) == Throw:\n-        return dep_state\n-      elif type(dep_state) == Noop:\n-        continue\n-      elif type(dep_state) != Return:\n-        State.raise_unrecognized(dep_state)\n-      # We computed a value: see whether we can use it.\n-      literal_value = self._select_literal(dep_state.value, variant_value)\n-      if literal_value is not None:\n-        matches[dep] = literal_value\n-    if has_waiting_dep:\n-      return Waiting(dependencies)\n-    elif len(matches) > 1:\n-      # TODO: Multiple successful tasks are not currently supported. We should allow for this\n-      # by adding support for \"mergeable\" products. see:\n-      #   https://github.com/pantsbuild/pants/issues/2526\n-      return Throw(ConflictingProducersError(self.subject, self.product, matches))\n-    elif len(matches) == 1:\n-      return Return(matches.values()[0])\n-    return Noop('No source of {}.'.format(self))\n-\n-\n-class DependenciesNode(datatype('DependenciesNode', ['subject', 'product', 'variants', 'dep_product']), Node):\n-  \"\"\"A Node that selects the given Product for each of the dependencies of this subject.\n-\n-  Begins by selecting the `dep_product` for the subject, and then selects a product for each\n-  of dep_products' dependencies.\n-\n-  The value produced by this Node guarantees that the order of the provided values matches the\n-  order of declaration in the `dependencies` list of the `dep_product`.\n-  \"\"\"\n-\n-  def _dep_product_node(self):\n-    return SelectNode(self.subject, self.dep_product, self.variants, None)\n-\n-  def _dep_node(self, dependency):\n-    variants = self.variants\n-    if isinstance(dependency, Address):\n-      # If a subject has literal variants for particular dependencies, they win over all else.\n-      dependency, literal_variants = parse_variants(dependency)\n-      variants = Variants.merge(variants, literal_variants)\n-    return SelectNode(dependency, self.product, variants, None)\n-\n-  def step(self, dependency_states, node_builder):\n-    # Request the product we need in order to request dependencies.\n-    dep_product_node = self._dep_product_node()\n-    dep_product_state = dependency_states.get(dep_product_node, None)\n-    if dep_product_state is None or type(dep_product_state) == Waiting:\n-      return Waiting([dep_product_node])\n-    elif type(dep_product_state) == Throw:\n-      return dep_product_state\n-    elif type(dep_product_state) == Noop:\n-      return Noop('Could not compute {} to determine dependencies.'.format(dep_product_node))\n-    elif type(dep_product_state) != Return:\n-      State.raise_unrecognized(dep_product_state)\n-\n-    # The product and its dependency list are available.\n-    dep_product = dep_product_state.value\n-    dependencies = [self._dep_node(d) for d in dep_product.dependencies]\n-    for dependency in dependencies:\n-      dep_state = dependency_states.get(dependency, None)\n-      if dep_state is None or type(dep_state) == Waiting:\n-        # One of the dependencies is not yet available. Indicate that we are waiting for all\n-        # of them.\n-        return Waiting([dep_product_node] + dependencies)\n-      elif type(dep_state) == Throw:\n-        return dep_state\n-      elif type(dep_state) == Noop:\n-        return Throw(ValueError('No source of explicit dependency {}'.format(dependency)))\n-      elif type(dep_state) != Return:\n-        raise State.raise_unrecognized(dep_state)\n-    # All dependencies are present! Set our value to a list of the resulting values.\n-    return Return([dependency_states[d].value for d in dependencies])\n-\n-\n-class TaskNode(datatype('TaskNode', ['subject', 'product', 'variants', 'func', 'clause']), Node):\n-\n-  def step(self, dependency_states, node_builder):\n-    # Compute dependencies.\n-    dep_values = []\n-    dependencies = []\n-    for select in self.clause:\n-      dep = select.construct_node(self.subject, self.variants)\n-      if dep is None:\n-        return Noop('Dependency {} is not satisfiable.'.format(select))\n-      dependencies.append(dep)\n-\n-    # If all dependency Nodes are Return, execute the Node.\n-    for dep_select, dep_key in zip(self.clause, dependencies):\n-      dep_state = dependency_states.get(dep_key, None)\n-      if dep_state is None or type(dep_state) == Waiting:\n-        return Waiting(dependencies)\n-      elif type(dep_state) == Return:\n-        dep_values.append(dep_state.value)\n-      elif type(dep_state) == Noop:\n-        if dep_select.optional:\n-          dep_values.append(None)\n-        else:\n-          return Noop('Was missing (at least) input {}.'.format(dep_key))\n-      elif type(dep_state) == Throw:\n-        return dep_state\n-      else:\n-        State.raise_unrecognized(dep_state)\n-    try:\n-      return Return(self.func(*dep_values))\n-    except Exception as e:\n-      return Throw(e)\n-\n-\n class ProductGraph(object):\n",
        "source_code_with_indent": "\n<DED><DED>class ConflictingProducersError(SchedulingError):\n  <IND>\"\"\"Indicates that there was more than one source of a product for a given subject.\n\n  TODO: This will need to be legal in order to support multiple Planners producing a\n  (mergeable) Classpath for one subject, for example. see:\n    https://github.com/pantsbuild/pants/issues/2526\n  \"\"\"\n\n  def __init__(self, subject, product, matches):\n    <IND>msgs = '\\n  '.join('{}: {}'.format(k, v) for k, v in matches.items())\n    msg = 'More than one source of {} for {}:\\n  {}'.format(product.__name__, subject, msgs)\n    super(ConflictingProducersError, self).__init__(msg)\n\n\n<DED><DED>class State(object):\n  <IND>@classmethod\n  def raise_unrecognized(cls, state):\n    <IND>raise ValueError('Unrecognized Node State: {}'.format(state))\n\n\n<DED><DED>class Noop(datatype('Noop', ['msg']), State):\n  <IND>\"\"\"Indicates that a Node did not have the inputs which would be needed for it to execute.\"\"\"\n  pass\n\n\n<DED>class Return(datatype('Return', ['value']), State):\n  <IND>\"\"\"Indicates that a Node successfully returned a value.\"\"\"\n  pass\n\n\n<DED>class Throw(datatype('Throw', ['exc']), State):\n  <IND>\"\"\"Indicates that a Node should have been able to return a value, but failed.\"\"\"\n  pass\n\n\n<DED>class Waiting(datatype('Waiting', ['dependencies']), State):\n  <IND>\"\"\"Indicates that a Node is waiting for some/all of the dependencies to become available.\n\n  Some Nodes will return different dependency Nodes based on where they are in their lifecycle,\n  but all returned dependencies are recorded for the lifetime of a ProductGraph.\n  \"\"\"\n  pass\n\n\n<DED>class Node(object):\n  <IND>@abstractproperty\n  def subject(self):\n    <IND>\"\"\"The subject for this Node.\"\"\"\n\n  <DED>@abstractproperty\n  def product(self):\n    <IND>\"\"\"The output product for this Node.\"\"\"\n\n  <DED>@abstractproperty\n  def variants(self):\n    <IND>\"\"\"The variants for this Node.\"\"\"\n\n  <DED>@abstractmethod\n  def step(self, dependency_states, node_builder):\n    <IND>\"\"\"Given a dict of the dependency States for this Node, returns the current State of the Node.\n\n    The NodeBuilder parameter provides a way to construct Nodes that require information about\n    installed tasks.\n\n    After this method returns a non-Waiting state, it will never be visited again for this Node.\n    \"\"\"\n\n\n<DED><DED>class SelectNode(datatype('SelectNode', ['subject', 'product', 'variants', 'variant_key']), Node):\n  <IND>\"\"\"A Node that selects a product for a subject.\n\n  A Select can be satisfied by multiple sources, but fails if multiple sources produce a value. The\n  'variants' field represents variant configuration that is propagated to dependencies. When\n  a task needs to consume a product as configured by the variants map, it uses the SelectVariant\n  selector, which introduces the 'variant' value to restrict the names of values selected by a\n  SelectNode.\n  \"\"\"\n\n  def _variants_node(self):\n    <IND>if self.product != Variants:\n      <IND>return SelectNode(self.subject, Variants, self.variants, None)\n    <DED>return None\n\n  <DED>def _select_literal(self, candidate, variant_value):\n    <IND>\"\"\"Looks for has-a or is-a relationships between the given value and the requested product.\n\n    Returns the resulting product value, or None if no match was made.\n    \"\"\"\n    def items():\n      # Check whether the subject is-a instance of the product.\n      <IND>yield candidate\n      # Else, check whether it has-a instance of the product.\n      if isinstance(candidate, Target):\n        <IND>for configuration in candidate.configurations:\n          <IND>yield configuration\n\n    # TODO: returning only the first literal configuration of a given type/variant. Need to\n    # define mergeability for products.\n    <DED><DED><DED>for item in items():\n      <IND>if not isinstance(item, self.product):\n        <IND>continue\n      <DED>if variant_value and not getattr(item, 'name', None) == variant_value:\n        <IND>continue\n      <DED>return item\n    <DED>return None\n\n  <DED>def step(self, dependency_states, node_builder):\n    # Request default Variants for the subject, so that if there are any we can propagate\n    # them to task nodes.\n    <IND>variants = self.variants\n    variants_node = self._variants_node()\n    if variants_node:\n      <IND>dep_state = dependency_states.get(variants_node, None)\n      if dep_state is None or type(dep_state) == Waiting:\n        <IND>return Waiting([variants_node])\n      <DED>elif type(dep_state) == Return:\n        # A subject's variants are overridden by any dependent's requested variants, so\n        # we merge them left to right here.\n        <IND>variants = Variants.merge(dep_state.value.default.items(), variants)\n\n    # If there is a variant_key, see whether it has been configured.\n    <DED><DED>variant_value = None\n    if self.variant_key:\n      <IND>variant_values = [value for key, value in variants\n                        if key == self.variant_key] if variants else None\n      if not variant_values:\n        # Select cannot be satisfied: no variant configured for this key.\n        <IND>return Noop('Variant key {} was not configured in variants {}'.format(\n          self.variant_key, variants))\n      <DED>variant_value = variant_values[0]\n\n    # If the Subject \"is a\" or \"has a\" Product, then we're done.\n    <DED>literal_value = self._select_literal(self.subject, variant_value)\n    if literal_value is not None:\n      <IND>return Return(literal_value)\n\n    # Else, attempt to use a configured task to compute the value.\n    <DED>has_waiting_dep = False\n    dependencies = list(node_builder.task_nodes(self.subject, self.product, variants))\n    matches = {}\n    for dep in dependencies:\n      <IND>dep_state = dependency_states.get(dep, None)\n      if dep_state is None or type(dep_state) == Waiting:\n        <IND>has_waiting_dep = True\n        continue\n      <DED>elif type(dep_state) == Throw:\n        <IND>return dep_state\n      <DED>elif type(dep_state) == Noop:\n        <IND>continue\n      <DED>elif type(dep_state) != Return:\n        <IND>State.raise_unrecognized(dep_state)\n      # We computed a value: see whether we can use it.\n      <DED>literal_value = self._select_literal(dep_state.value, variant_value)\n      if literal_value is not None:\n        <IND>matches[dep] = literal_value\n    <DED><DED>if has_waiting_dep:\n      <IND>return Waiting(dependencies)\n    <DED>elif len(matches) > 1:\n      # TODO: Multiple successful tasks are not currently supported. We should allow for this\n      # by adding support for \"mergeable\" products. see:\n      #   https://github.com/pantsbuild/pants/issues/2526\n      <IND>return Throw(ConflictingProducersError(self.subject, self.product, matches))\n    <DED>elif len(matches) == 1:\n      <IND>return Return(matches.values()[0])\n    <DED>return Noop('No source of {}.'.format(self))\n\n\n<DED><DED>class DependenciesNode(datatype('DependenciesNode', ['subject', 'product', 'variants', 'dep_product']), Node):\n  <IND>\"\"\"A Node that selects the given Product for each of the dependencies of this subject.\n\n  Begins by selecting the `dep_product` for the subject, and then selects a product for each\n  of dep_products' dependencies.\n\n  The value produced by this Node guarantees that the order of the provided values matches the\n  order of declaration in the `dependencies` list of the `dep_product`.\n  \"\"\"\n\n  def _dep_product_node(self):\n    <IND>return SelectNode(self.subject, self.dep_product, self.variants, None)\n\n  <DED>def _dep_node(self, dependency):\n    <IND>variants = self.variants\n    if isinstance(dependency, Address):\n      # If a subject has literal variants for particular dependencies, they win over all else.\n      <IND>dependency, literal_variants = parse_variants(dependency)\n      variants = Variants.merge(variants, literal_variants)\n    <DED>return SelectNode(dependency, self.product, variants, None)\n\n  <DED>def step(self, dependency_states, node_builder):\n    # Request the product we need in order to request dependencies.\n    <IND>dep_product_node = self._dep_product_node()\n    dep_product_state = dependency_states.get(dep_product_node, None)\n    if dep_product_state is None or type(dep_product_state) == Waiting:\n      <IND>return Waiting([dep_product_node])\n    <DED>elif type(dep_product_state) == Throw:\n      <IND>return dep_product_state\n    <DED>elif type(dep_product_state) == Noop:\n      <IND>return Noop('Could not compute {} to determine dependencies.'.format(dep_product_node))\n    <DED>elif type(dep_product_state) != Return:\n      <IND>State.raise_unrecognized(dep_product_state)\n\n    # The product and its dependency list are available.\n    <DED>dep_product = dep_product_state.value\n    dependencies = [self._dep_node(d) for d in dep_product.dependencies]\n    for dependency in dependencies:\n      <IND>dep_state = dependency_states.get(dependency, None)\n      if dep_state is None or type(dep_state) == Waiting:\n        # One of the dependencies is not yet available. Indicate that we are waiting for all\n        # of them.\n        <IND>return Waiting([dep_product_node] + dependencies)\n      <DED>elif type(dep_state) == Throw:\n        <IND>return dep_state\n      <DED>elif type(dep_state) == Noop:\n        <IND>return Throw(ValueError('No source of explicit dependency {}'.format(dependency)))\n      <DED>elif type(dep_state) != Return:\n        <IND>raise State.raise_unrecognized(dep_state)\n    # All dependencies are present! Set our value to a list of the resulting values.\n    <DED><DED>return Return([dependency_states[d].value for d in dependencies])\n\n\n<DED><DED>class TaskNode(datatype('TaskNode', ['subject', 'product', 'variants', 'func', 'clause']), Node):\n\n  <IND>def step(self, dependency_states, node_builder):\n    # Compute dependencies.\n    <IND>dep_values = []\n    dependencies = []\n    for select in self.clause:\n      <IND>dep = select.construct_node(self.subject, self.variants)\n      if dep is None:\n        <IND>return Noop('Dependency {} is not satisfiable.'.format(select))\n      <DED>dependencies.append(dep)\n\n    # If all dependency Nodes are Return, execute the Node.\n    <DED>for dep_select, dep_key in zip(self.clause, dependencies):\n      <IND>dep_state = dependency_states.get(dep_key, None)\n      if dep_state is None or type(dep_state) == Waiting:\n        <IND>return Waiting(dependencies)\n      <DED>elif type(dep_state) == Return:\n        <IND>dep_values.append(dep_state.value)\n      <DED>elif type(dep_state) == Noop:\n        <IND>if dep_select.optional:\n          <IND>dep_values.append(None)\n        <DED>else:\n          <IND>return Noop('Was missing (at least) input {}.'.format(dep_key))\n      <DED><DED>elif type(dep_state) == Throw:\n        <IND>return dep_state\n      <DED>else:\n        <IND>State.raise_unrecognized(dep_state)\n    <DED><DED>try:\n      <IND>return Return(self.func(*dep_values))\n    <DED>except Exception as e:\n      <IND>return Throw(e)\n\n\n<DED><DED><DED>class ProductGraph(object):\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n<DED><DED>class ProductGraph(object):\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "pantsbuild/pants",
    "commit": "08bc2add6e98feefdce36f6f094a15e3e598b1e7",
    "filename": "src/python/pants/engine/exp/scheduler.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/pantsbuild-pants/src/python/pants/engine/exp/scheduler.py",
    "file_hunks_size": 13,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "src/python/pants/engine/exp/scheduler.py:61:25 Invalid type [31]: Expression `pants.util.objects.datatype(\"Dependencies\", [\"product\", \"deps_product\"])` is not a valid type.",
    "message": " Expression `pants.util.objects.datatype(\"Dependencies\", [\"product\", \"deps_product\"])` is not a valid type.",
    "rule_id": "Invalid type [31]",
    "warning_line_no": 61,
    "warning_line": "class SelectDependencies(datatype('Dependencies', ['product', 'deps_product']), Selector):",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\nclass Selector(AbstractClass):\n  @abstractproperty\n  def optional(self):\n    \"\"\"Return true if this Selector is optional. It may result in a `None` match.\"\"\"\n\n  @abstractmethod\n  def construct_node(self, subject, variants):\n    \"\"\"Constructs a Node for this Selector and the given Subject/Variants.\n\n    May return None if the Selector can be known statically to not be satisfiable for the inputs.\n    \"\"\"\n\n\nclass Select(datatype('Subject', ['product', 'optional']), Selector):\n  \"\"\"Selects the given Product for the Subject provided to the constructor.\n\n  If optional=True and no matching product can be produced, will return None.\n  \"\"\"\n\n  def __new__(self, product, optional=False):\n    return super(Select, self).__new__(self, product, optional)\n\n  def construct_node(self, subject, variants):\n    return SelectNode(subject, self.product, variants, None)\n\n\nclass SelectVariant(datatype('Variant', ['product', 'variant_key']), Selector):\n  \"\"\"Selects the matching Product and variant name for the Subject provided to the constructor.\n\n  For example: a SelectVariant with a variant_key of \"thrift\" and a product of type ApacheThrift\n  will only match when a consumer passes a variant value for \"thrift\" that matches the name of an\n  ApacheThrift value.\n  \"\"\"\n  optional = False\n\n  def construct_node(self, subject, variants):\n    return SelectNode(subject, self.product, variants, self.variant_key)\n\n\nclass SelectDependencies(datatype('Dependencies', ['product', 'deps_product']), Selector):\n  \"\"\"Selects a product for each of the dependencies of a product for the Subject.\n\n  The dependencies declared on `deps_product` will be provided to the requesting task\n  in the order they were declared.\n  \"\"\"\n  optional = False\n\n  def construct_node(self, subject, variants):\n    return DependenciesNode(subject, self.product, variants, self.deps_product)\n\n\nclass SelectProjection(datatype('Projection', ['product', 'projected_product', 'fields', 'input_product']), Selector):\n  \"\"\"Selects a field of the given Subject to produce a Subject, Product dependency from.\n\n  Projecting an input allows for deduplication in the graph, where multiple Subjects\n  resolve to a single backing Subject instead.\n  \"\"\"\n  optional = False\n\n  def construct_node(self, subject, variants):\n    # Input product type doesn't match: not satisfiable.\n    if not type(subject) == self.input_product:\n      return None\n\n    # Find the fields of the Subject to project.\n    values = []\n    for field in self.fields:\n      values.append(getattr(subject, field))\n    projected_subject = self.projected_product(*values)\n    return SelectNode(projected_subject, self.product, variants, None)\n\n\nclass SelectLiteral(datatype('Literal', ['subject', 'product']), Selector):\n  \"\"\"Selects a literal Subject (other than the one applied to the selector).\"\"\"\n  optional = False\n\n  def construct_node(self, subject, variants):\n    # NB: Intentionally ignores subject parameter to provide a literal subject.\n    return SelectNode(self.subject, self.product, variants, None)\n\n\nclass SchedulingError(Exception):\n  \"\"\"Indicates inability to make a scheduling promise.\"\"\"\n\n\nclass PartiallyConsumedInputsError(SchedulingError):\n  \"\"\"No task was able to consume a particular literal product for a subject, although some tried.\n",
        "source_code_len": 3277,
        "target_code": "\nclass PartiallyConsumedInputsError(Exception):\n  \"\"\"No task was able to consume a particular literal product for a subject, although some tried.\n",
        "target_code_len": 146,
        "diff_format": "@@ -21,88 +20,3 @@\n \n-class Selector(AbstractClass):\n-  @abstractproperty\n-  def optional(self):\n-    \"\"\"Return true if this Selector is optional. It may result in a `None` match.\"\"\"\n-\n-  @abstractmethod\n-  def construct_node(self, subject, variants):\n-    \"\"\"Constructs a Node for this Selector and the given Subject/Variants.\n-\n-    May return None if the Selector can be known statically to not be satisfiable for the inputs.\n-    \"\"\"\n-\n-\n-class Select(datatype('Subject', ['product', 'optional']), Selector):\n-  \"\"\"Selects the given Product for the Subject provided to the constructor.\n-\n-  If optional=True and no matching product can be produced, will return None.\n-  \"\"\"\n-\n-  def __new__(self, product, optional=False):\n-    return super(Select, self).__new__(self, product, optional)\n-\n-  def construct_node(self, subject, variants):\n-    return SelectNode(subject, self.product, variants, None)\n-\n-\n-class SelectVariant(datatype('Variant', ['product', 'variant_key']), Selector):\n-  \"\"\"Selects the matching Product and variant name for the Subject provided to the constructor.\n-\n-  For example: a SelectVariant with a variant_key of \"thrift\" and a product of type ApacheThrift\n-  will only match when a consumer passes a variant value for \"thrift\" that matches the name of an\n-  ApacheThrift value.\n-  \"\"\"\n-  optional = False\n-\n-  def construct_node(self, subject, variants):\n-    return SelectNode(subject, self.product, variants, self.variant_key)\n-\n-\n-class SelectDependencies(datatype('Dependencies', ['product', 'deps_product']), Selector):\n-  \"\"\"Selects a product for each of the dependencies of a product for the Subject.\n-\n-  The dependencies declared on `deps_product` will be provided to the requesting task\n-  in the order they were declared.\n-  \"\"\"\n-  optional = False\n-\n-  def construct_node(self, subject, variants):\n-    return DependenciesNode(subject, self.product, variants, self.deps_product)\n-\n-\n-class SelectProjection(datatype('Projection', ['product', 'projected_product', 'fields', 'input_product']), Selector):\n-  \"\"\"Selects a field of the given Subject to produce a Subject, Product dependency from.\n-\n-  Projecting an input allows for deduplication in the graph, where multiple Subjects\n-  resolve to a single backing Subject instead.\n-  \"\"\"\n-  optional = False\n-\n-  def construct_node(self, subject, variants):\n-    # Input product type doesn't match: not satisfiable.\n-    if not type(subject) == self.input_product:\n-      return None\n-\n-    # Find the fields of the Subject to project.\n-    values = []\n-    for field in self.fields:\n-      values.append(getattr(subject, field))\n-    projected_subject = self.projected_product(*values)\n-    return SelectNode(projected_subject, self.product, variants, None)\n-\n-\n-class SelectLiteral(datatype('Literal', ['subject', 'product']), Selector):\n-  \"\"\"Selects a literal Subject (other than the one applied to the selector).\"\"\"\n-  optional = False\n-\n-  def construct_node(self, subject, variants):\n-    # NB: Intentionally ignores subject parameter to provide a literal subject.\n-    return SelectNode(self.subject, self.product, variants, None)\n-\n-\n-class SchedulingError(Exception):\n-  \"\"\"Indicates inability to make a scheduling promise.\"\"\"\n-\n-\n-class PartiallyConsumedInputsError(SchedulingError):\n+class PartiallyConsumedInputsError(Exception):\n   \"\"\"No task was able to consume a particular literal product for a subject, although some tried.\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\nclass Selector(AbstractClass):\n  <IND>@abstractproperty\n  def optional(self):\n    <IND>\"\"\"Return true if this Selector is optional. It may result in a `None` match.\"\"\"\n\n  <DED>@abstractmethod\n  def construct_node(self, subject, variants):\n    <IND>\"\"\"Constructs a Node for this Selector and the given Subject/Variants.\n\n    May return None if the Selector can be known statically to not be satisfiable for the inputs.\n    \"\"\"\n\n\n<DED><DED>class Select(datatype('Subject', ['product', 'optional']), Selector):\n  <IND>\"\"\"Selects the given Product for the Subject provided to the constructor.\n\n  If optional=True and no matching product can be produced, will return None.\n  \"\"\"\n\n  def __new__(self, product, optional=False):\n    <IND>return super(Select, self).__new__(self, product, optional)\n\n  <DED>def construct_node(self, subject, variants):\n    <IND>return SelectNode(subject, self.product, variants, None)\n\n\n<DED><DED>class SelectVariant(datatype('Variant', ['product', 'variant_key']), Selector):\n  <IND>\"\"\"Selects the matching Product and variant name for the Subject provided to the constructor.\n\n  For example: a SelectVariant with a variant_key of \"thrift\" and a product of type ApacheThrift\n  will only match when a consumer passes a variant value for \"thrift\" that matches the name of an\n  ApacheThrift value.\n  \"\"\"\n  optional = False\n\n  def construct_node(self, subject, variants):\n    <IND>return SelectNode(subject, self.product, variants, self.variant_key)\n\n\n<DED><DED>class SelectDependencies(datatype('Dependencies', ['product', 'deps_product']), Selector):\n  <IND>\"\"\"Selects a product for each of the dependencies of a product for the Subject.\n\n  The dependencies declared on `deps_product` will be provided to the requesting task\n  in the order they were declared.\n  \"\"\"\n  optional = False\n\n  def construct_node(self, subject, variants):\n    <IND>return DependenciesNode(subject, self.product, variants, self.deps_product)\n\n\n<DED><DED>class SelectProjection(datatype('Projection', ['product', 'projected_product', 'fields', 'input_product']), Selector):\n  <IND>\"\"\"Selects a field of the given Subject to produce a Subject, Product dependency from.\n\n  Projecting an input allows for deduplication in the graph, where multiple Subjects\n  resolve to a single backing Subject instead.\n  \"\"\"\n  optional = False\n\n  def construct_node(self, subject, variants):\n    # Input product type doesn't match: not satisfiable.\n    <IND>if not type(subject) == self.input_product:\n      <IND>return None\n\n    # Find the fields of the Subject to project.\n    <DED>values = []\n    for field in self.fields:\n      <IND>values.append(getattr(subject, field))\n    <DED>projected_subject = self.projected_product(*values)\n    return SelectNode(projected_subject, self.product, variants, None)\n\n\n<DED><DED>class SelectLiteral(datatype('Literal', ['subject', 'product']), Selector):\n  <IND>\"\"\"Selects a literal Subject (other than the one applied to the selector).\"\"\"\n  optional = False\n\n  def construct_node(self, subject, variants):\n    # NB: Intentionally ignores subject parameter to provide a literal subject.\n    <IND>return SelectNode(self.subject, self.product, variants, None)\n\n\n<DED><DED>class SchedulingError(Exception):\n  <IND>\"\"\"Indicates inability to make a scheduling promise.\"\"\"\n\n\n<DED>class PartiallyConsumedInputsError(SchedulingError):\n  <IND>",
        "target_code_with_indent": "\nclass PartiallyConsumedInputsError(Exception):\n  <IND>"
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": true,
        "has_suppression": false,
        "source_code": "\nclass ConflictingProducersError(SchedulingError):\n  \"\"\"Indicates that there was more than one source of a product for a given subject.\n\n  TODO: This will need to be legal in order to support multiple Planners producing a\n  (mergeable) Classpath for one subject, for example. see:\n    https://github.com/pantsbuild/pants/issues/2526\n  \"\"\"\n\n  def __init__(self, subject, product, matches):\n    msgs = '\\n  '.join('{}: {}'.format(k, v) for k, v in matches.items())\n    msg = 'More than one source of {} for {}:\\n  {}'.format(product.__name__, subject, msgs)\n    super(ConflictingProducersError, self).__init__(msg)\n\n\nclass State(object):\n  @classmethod\n  def raise_unrecognized(cls, state):\n    raise ValueError('Unrecognized Node State: {}'.format(state))\n\n\nclass Noop(datatype('Noop', ['msg']), State):\n  \"\"\"Indicates that a Node did not have the inputs which would be needed for it to execute.\"\"\"\n  pass\n\n\nclass Return(datatype('Return', ['value']), State):\n  \"\"\"Indicates that a Node successfully returned a value.\"\"\"\n  pass\n\n\nclass Throw(datatype('Throw', ['exc']), State):\n  \"\"\"Indicates that a Node should have been able to return a value, but failed.\"\"\"\n  pass\n\n\nclass Waiting(datatype('Waiting', ['dependencies']), State):\n  \"\"\"Indicates that a Node is waiting for some/all of the dependencies to become available.\n\n  Some Nodes will return different dependency Nodes based on where they are in their lifecycle,\n  but all returned dependencies are recorded for the lifetime of a ProductGraph.\n  \"\"\"\n  pass\n\n\nclass Node(object):\n  @abstractproperty\n  def subject(self):\n    \"\"\"The subject for this Node.\"\"\"\n\n  @abstractproperty\n  def product(self):\n    \"\"\"The output product for this Node.\"\"\"\n\n  @abstractproperty\n  def variants(self):\n    \"\"\"The variants for this Node.\"\"\"\n\n  @abstractmethod\n  def step(self, dependency_states, node_builder):\n    \"\"\"Given a dict of the dependency States for this Node, returns the current State of the Node.\n\n    The NodeBuilder parameter provides a way to construct Nodes that require information about\n    installed tasks.\n\n    After this method returns a non-Waiting state, it will never be visited again for this Node.\n    \"\"\"\n\n\nclass SelectNode(datatype('SelectNode', ['subject', 'product', 'variants', 'variant_key']), Node):\n  \"\"\"A Node that selects a product for a subject.\n\n  A Select can be satisfied by multiple sources, but fails if multiple sources produce a value. The\n  'variants' field represents variant configuration that is propagated to dependencies. When\n  a task needs to consume a product as configured by the variants map, it uses the SelectVariant\n  selector, which introduces the 'variant' value to restrict the names of values selected by a\n  SelectNode.\n  \"\"\"\n\n  def _variants_node(self):\n    if self.product != Variants:\n      return SelectNode(self.subject, Variants, self.variants, None)\n    return None\n\n  def _select_literal(self, candidate, variant_value):\n    \"\"\"Looks for has-a or is-a relationships between the given value and the requested product.\n\n    Returns the resulting product value, or None if no match was made.\n    \"\"\"\n    def items():\n      # Check whether the subject is-a instance of the product.\n      yield candidate\n      # Else, check whether it has-a instance of the product.\n      if isinstance(candidate, Target):\n        for configuration in candidate.configurations:\n          yield configuration\n\n    # TODO: returning only the first literal configuration of a given type/variant. Need to\n    # define mergeability for products.\n    for item in items():\n      if not isinstance(item, self.product):\n        continue\n      if variant_value and not getattr(item, 'name', None) == variant_value:\n        continue\n      return item\n    return None\n\n  def step(self, dependency_states, node_builder):\n    # Request default Variants for the subject, so that if there are any we can propagate\n    # them to task nodes.\n    variants = self.variants\n    variants_node = self._variants_node()\n    if variants_node:\n      dep_state = dependency_states.get(variants_node, None)\n      if dep_state is None or type(dep_state) == Waiting:\n        return Waiting([variants_node])\n      elif type(dep_state) == Return:\n        # A subject's variants are overridden by any dependent's requested variants, so\n        # we merge them left to right here.\n        variants = Variants.merge(dep_state.value.default.items(), variants)\n\n    # If there is a variant_key, see whether it has been configured.\n    variant_value = None\n    if self.variant_key:\n      variant_values = [value for key, value in variants\n                        if key == self.variant_key] if variants else None\n      if not variant_values:\n        # Select cannot be satisfied: no variant configured for this key.\n        return Noop('Variant key {} was not configured in variants {}'.format(\n          self.variant_key, variants))\n      variant_value = variant_values[0]\n\n    # If the Subject \"is a\" or \"has a\" Product, then we're done.\n    literal_value = self._select_literal(self.subject, variant_value)\n    if literal_value is not None:\n      return Return(literal_value)\n\n    # Else, attempt to use a configured task to compute the value.\n    has_waiting_dep = False\n    dependencies = list(node_builder.task_nodes(self.subject, self.product, variants))\n    matches = {}\n    for dep in dependencies:\n      dep_state = dependency_states.get(dep, None)\n      if dep_state is None or type(dep_state) == Waiting:\n        has_waiting_dep = True\n        continue\n      elif type(dep_state) == Throw:\n        return dep_state\n      elif type(dep_state) == Noop:\n        continue\n      elif type(dep_state) != Return:\n        State.raise_unrecognized(dep_state)\n      # We computed a value: see whether we can use it.\n      literal_value = self._select_literal(dep_state.value, variant_value)\n      if literal_value is not None:\n        matches[dep] = literal_value\n    if has_waiting_dep:\n      return Waiting(dependencies)\n    elif len(matches) > 1:\n      # TODO: Multiple successful tasks are not currently supported. We should allow for this\n      # by adding support for \"mergeable\" products. see:\n      #   https://github.com/pantsbuild/pants/issues/2526\n      return Throw(ConflictingProducersError(self.subject, self.product, matches))\n    elif len(matches) == 1:\n      return Return(matches.values()[0])\n    return Noop('No source of {}.'.format(self))\n\n\nclass DependenciesNode(datatype('DependenciesNode', ['subject', 'product', 'variants', 'dep_product']), Node):\n  \"\"\"A Node that selects the given Product for each of the dependencies of this subject.\n\n  Begins by selecting the `dep_product` for the subject, and then selects a product for each\n  of dep_products' dependencies.\n\n  The value produced by this Node guarantees that the order of the provided values matches the\n  order of declaration in the `dependencies` list of the `dep_product`.\n  \"\"\"\n\n  def _dep_product_node(self):\n    return SelectNode(self.subject, self.dep_product, self.variants, None)\n\n  def _dep_node(self, dependency):\n    variants = self.variants\n    if isinstance(dependency, Address):\n      # If a subject has literal variants for particular dependencies, they win over all else.\n      dependency, literal_variants = parse_variants(dependency)\n      variants = Variants.merge(variants, literal_variants)\n    return SelectNode(dependency, self.product, variants, None)\n\n  def step(self, dependency_states, node_builder):\n    # Request the product we need in order to request dependencies.\n    dep_product_node = self._dep_product_node()\n    dep_product_state = dependency_states.get(dep_product_node, None)\n    if dep_product_state is None or type(dep_product_state) == Waiting:\n      return Waiting([dep_product_node])\n    elif type(dep_product_state) == Throw:\n      return dep_product_state\n    elif type(dep_product_state) == Noop:\n      return Noop('Could not compute {} to determine dependencies.'.format(dep_product_node))\n    elif type(dep_product_state) != Return:\n      State.raise_unrecognized(dep_product_state)\n\n    # The product and its dependency list are available.\n    dep_product = dep_product_state.value\n    dependencies = [self._dep_node(d) for d in dep_product.dependencies]\n    for dependency in dependencies:\n      dep_state = dependency_states.get(dependency, None)\n      if dep_state is None or type(dep_state) == Waiting:\n        # One of the dependencies is not yet available. Indicate that we are waiting for all\n        # of them.\n        return Waiting([dep_product_node] + dependencies)\n      elif type(dep_state) == Throw:\n        return dep_state\n      elif type(dep_state) == Noop:\n        return Throw(ValueError('No source of explicit dependency {}'.format(dependency)))\n      elif type(dep_state) != Return:\n        raise State.raise_unrecognized(dep_state)\n    # All dependencies are present! Set our value to a list of the resulting values.\n    return Return([dependency_states[d].value for d in dependencies])\n\n\nclass TaskNode(datatype('TaskNode', ['subject', 'product', 'variants', 'func', 'clause']), Node):\n\n  def step(self, dependency_states, node_builder):\n    # Compute dependencies.\n    dep_values = []\n    dependencies = []\n    for select in self.clause:\n      dep = select.construct_node(self.subject, self.variants)\n      if dep is None:\n        return Noop('Dependency {} is not satisfiable.'.format(select))\n      dependencies.append(dep)\n\n    # If all dependency Nodes are Return, execute the Node.\n    for dep_select, dep_key in zip(self.clause, dependencies):\n      dep_state = dependency_states.get(dep_key, None)\n      if dep_state is None or type(dep_state) == Waiting:\n        return Waiting(dependencies)\n      elif type(dep_state) == Return:\n        dep_values.append(dep_state.value)\n      elif type(dep_state) == Noop:\n        if dep_select.optional:\n          dep_values.append(None)\n        else:\n          return Noop('Was missing (at least) input {}.'.format(dep_key))\n      elif type(dep_state) == Throw:\n        return dep_state\n      else:\n        State.raise_unrecognized(dep_state)\n    try:\n      return Return(self.func(*dep_values))\n    except Exception as e:\n      return Throw(e)\n\n\nclass ProductGraph(object):\n",
        "source_code_len": 10229,
        "target_code": "\nclass ProductGraph(object):\n",
        "target_code_len": 29,
        "diff_format": "@@ -134,256 +48,2 @@\n \n-class ConflictingProducersError(SchedulingError):\n-  \"\"\"Indicates that there was more than one source of a product for a given subject.\n-\n-  TODO: This will need to be legal in order to support multiple Planners producing a\n-  (mergeable) Classpath for one subject, for example. see:\n-    https://github.com/pantsbuild/pants/issues/2526\n-  \"\"\"\n-\n-  def __init__(self, subject, product, matches):\n-    msgs = '\\n  '.join('{}: {}'.format(k, v) for k, v in matches.items())\n-    msg = 'More than one source of {} for {}:\\n  {}'.format(product.__name__, subject, msgs)\n-    super(ConflictingProducersError, self).__init__(msg)\n-\n-\n-class State(object):\n-  @classmethod\n-  def raise_unrecognized(cls, state):\n-    raise ValueError('Unrecognized Node State: {}'.format(state))\n-\n-\n-class Noop(datatype('Noop', ['msg']), State):\n-  \"\"\"Indicates that a Node did not have the inputs which would be needed for it to execute.\"\"\"\n-  pass\n-\n-\n-class Return(datatype('Return', ['value']), State):\n-  \"\"\"Indicates that a Node successfully returned a value.\"\"\"\n-  pass\n-\n-\n-class Throw(datatype('Throw', ['exc']), State):\n-  \"\"\"Indicates that a Node should have been able to return a value, but failed.\"\"\"\n-  pass\n-\n-\n-class Waiting(datatype('Waiting', ['dependencies']), State):\n-  \"\"\"Indicates that a Node is waiting for some/all of the dependencies to become available.\n-\n-  Some Nodes will return different dependency Nodes based on where they are in their lifecycle,\n-  but all returned dependencies are recorded for the lifetime of a ProductGraph.\n-  \"\"\"\n-  pass\n-\n-\n-class Node(object):\n-  @abstractproperty\n-  def subject(self):\n-    \"\"\"The subject for this Node.\"\"\"\n-\n-  @abstractproperty\n-  def product(self):\n-    \"\"\"The output product for this Node.\"\"\"\n-\n-  @abstractproperty\n-  def variants(self):\n-    \"\"\"The variants for this Node.\"\"\"\n-\n-  @abstractmethod\n-  def step(self, dependency_states, node_builder):\n-    \"\"\"Given a dict of the dependency States for this Node, returns the current State of the Node.\n-\n-    The NodeBuilder parameter provides a way to construct Nodes that require information about\n-    installed tasks.\n-\n-    After this method returns a non-Waiting state, it will never be visited again for this Node.\n-    \"\"\"\n-\n-\n-class SelectNode(datatype('SelectNode', ['subject', 'product', 'variants', 'variant_key']), Node):\n-  \"\"\"A Node that selects a product for a subject.\n-\n-  A Select can be satisfied by multiple sources, but fails if multiple sources produce a value. The\n-  'variants' field represents variant configuration that is propagated to dependencies. When\n-  a task needs to consume a product as configured by the variants map, it uses the SelectVariant\n-  selector, which introduces the 'variant' value to restrict the names of values selected by a\n-  SelectNode.\n-  \"\"\"\n-\n-  def _variants_node(self):\n-    if self.product != Variants:\n-      return SelectNode(self.subject, Variants, self.variants, None)\n-    return None\n-\n-  def _select_literal(self, candidate, variant_value):\n-    \"\"\"Looks for has-a or is-a relationships between the given value and the requested product.\n-\n-    Returns the resulting product value, or None if no match was made.\n-    \"\"\"\n-    def items():\n-      # Check whether the subject is-a instance of the product.\n-      yield candidate\n-      # Else, check whether it has-a instance of the product.\n-      if isinstance(candidate, Target):\n-        for configuration in candidate.configurations:\n-          yield configuration\n-\n-    # TODO: returning only the first literal configuration of a given type/variant. Need to\n-    # define mergeability for products.\n-    for item in items():\n-      if not isinstance(item, self.product):\n-        continue\n-      if variant_value and not getattr(item, 'name', None) == variant_value:\n-        continue\n-      return item\n-    return None\n-\n-  def step(self, dependency_states, node_builder):\n-    # Request default Variants for the subject, so that if there are any we can propagate\n-    # them to task nodes.\n-    variants = self.variants\n-    variants_node = self._variants_node()\n-    if variants_node:\n-      dep_state = dependency_states.get(variants_node, None)\n-      if dep_state is None or type(dep_state) == Waiting:\n-        return Waiting([variants_node])\n-      elif type(dep_state) == Return:\n-        # A subject's variants are overridden by any dependent's requested variants, so\n-        # we merge them left to right here.\n-        variants = Variants.merge(dep_state.value.default.items(), variants)\n-\n-    # If there is a variant_key, see whether it has been configured.\n-    variant_value = None\n-    if self.variant_key:\n-      variant_values = [value for key, value in variants\n-                        if key == self.variant_key] if variants else None\n-      if not variant_values:\n-        # Select cannot be satisfied: no variant configured for this key.\n-        return Noop('Variant key {} was not configured in variants {}'.format(\n-          self.variant_key, variants))\n-      variant_value = variant_values[0]\n-\n-    # If the Subject \"is a\" or \"has a\" Product, then we're done.\n-    literal_value = self._select_literal(self.subject, variant_value)\n-    if literal_value is not None:\n-      return Return(literal_value)\n-\n-    # Else, attempt to use a configured task to compute the value.\n-    has_waiting_dep = False\n-    dependencies = list(node_builder.task_nodes(self.subject, self.product, variants))\n-    matches = {}\n-    for dep in dependencies:\n-      dep_state = dependency_states.get(dep, None)\n-      if dep_state is None or type(dep_state) == Waiting:\n-        has_waiting_dep = True\n-        continue\n-      elif type(dep_state) == Throw:\n-        return dep_state\n-      elif type(dep_state) == Noop:\n-        continue\n-      elif type(dep_state) != Return:\n-        State.raise_unrecognized(dep_state)\n-      # We computed a value: see whether we can use it.\n-      literal_value = self._select_literal(dep_state.value, variant_value)\n-      if literal_value is not None:\n-        matches[dep] = literal_value\n-    if has_waiting_dep:\n-      return Waiting(dependencies)\n-    elif len(matches) > 1:\n-      # TODO: Multiple successful tasks are not currently supported. We should allow for this\n-      # by adding support for \"mergeable\" products. see:\n-      #   https://github.com/pantsbuild/pants/issues/2526\n-      return Throw(ConflictingProducersError(self.subject, self.product, matches))\n-    elif len(matches) == 1:\n-      return Return(matches.values()[0])\n-    return Noop('No source of {}.'.format(self))\n-\n-\n-class DependenciesNode(datatype('DependenciesNode', ['subject', 'product', 'variants', 'dep_product']), Node):\n-  \"\"\"A Node that selects the given Product for each of the dependencies of this subject.\n-\n-  Begins by selecting the `dep_product` for the subject, and then selects a product for each\n-  of dep_products' dependencies.\n-\n-  The value produced by this Node guarantees that the order of the provided values matches the\n-  order of declaration in the `dependencies` list of the `dep_product`.\n-  \"\"\"\n-\n-  def _dep_product_node(self):\n-    return SelectNode(self.subject, self.dep_product, self.variants, None)\n-\n-  def _dep_node(self, dependency):\n-    variants = self.variants\n-    if isinstance(dependency, Address):\n-      # If a subject has literal variants for particular dependencies, they win over all else.\n-      dependency, literal_variants = parse_variants(dependency)\n-      variants = Variants.merge(variants, literal_variants)\n-    return SelectNode(dependency, self.product, variants, None)\n-\n-  def step(self, dependency_states, node_builder):\n-    # Request the product we need in order to request dependencies.\n-    dep_product_node = self._dep_product_node()\n-    dep_product_state = dependency_states.get(dep_product_node, None)\n-    if dep_product_state is None or type(dep_product_state) == Waiting:\n-      return Waiting([dep_product_node])\n-    elif type(dep_product_state) == Throw:\n-      return dep_product_state\n-    elif type(dep_product_state) == Noop:\n-      return Noop('Could not compute {} to determine dependencies.'.format(dep_product_node))\n-    elif type(dep_product_state) != Return:\n-      State.raise_unrecognized(dep_product_state)\n-\n-    # The product and its dependency list are available.\n-    dep_product = dep_product_state.value\n-    dependencies = [self._dep_node(d) for d in dep_product.dependencies]\n-    for dependency in dependencies:\n-      dep_state = dependency_states.get(dependency, None)\n-      if dep_state is None or type(dep_state) == Waiting:\n-        # One of the dependencies is not yet available. Indicate that we are waiting for all\n-        # of them.\n-        return Waiting([dep_product_node] + dependencies)\n-      elif type(dep_state) == Throw:\n-        return dep_state\n-      elif type(dep_state) == Noop:\n-        return Throw(ValueError('No source of explicit dependency {}'.format(dependency)))\n-      elif type(dep_state) != Return:\n-        raise State.raise_unrecognized(dep_state)\n-    # All dependencies are present! Set our value to a list of the resulting values.\n-    return Return([dependency_states[d].value for d in dependencies])\n-\n-\n-class TaskNode(datatype('TaskNode', ['subject', 'product', 'variants', 'func', 'clause']), Node):\n-\n-  def step(self, dependency_states, node_builder):\n-    # Compute dependencies.\n-    dep_values = []\n-    dependencies = []\n-    for select in self.clause:\n-      dep = select.construct_node(self.subject, self.variants)\n-      if dep is None:\n-        return Noop('Dependency {} is not satisfiable.'.format(select))\n-      dependencies.append(dep)\n-\n-    # If all dependency Nodes are Return, execute the Node.\n-    for dep_select, dep_key in zip(self.clause, dependencies):\n-      dep_state = dependency_states.get(dep_key, None)\n-      if dep_state is None or type(dep_state) == Waiting:\n-        return Waiting(dependencies)\n-      elif type(dep_state) == Return:\n-        dep_values.append(dep_state.value)\n-      elif type(dep_state) == Noop:\n-        if dep_select.optional:\n-          dep_values.append(None)\n-        else:\n-          return Noop('Was missing (at least) input {}.'.format(dep_key))\n-      elif type(dep_state) == Throw:\n-        return dep_state\n-      else:\n-        State.raise_unrecognized(dep_state)\n-    try:\n-      return Return(self.func(*dep_values))\n-    except Exception as e:\n-      return Throw(e)\n-\n-\n class ProductGraph(object):\n",
        "source_code_with_indent": "\n<DED><DED>class ConflictingProducersError(SchedulingError):\n  <IND>\"\"\"Indicates that there was more than one source of a product for a given subject.\n\n  TODO: This will need to be legal in order to support multiple Planners producing a\n  (mergeable) Classpath for one subject, for example. see:\n    https://github.com/pantsbuild/pants/issues/2526\n  \"\"\"\n\n  def __init__(self, subject, product, matches):\n    <IND>msgs = '\\n  '.join('{}: {}'.format(k, v) for k, v in matches.items())\n    msg = 'More than one source of {} for {}:\\n  {}'.format(product.__name__, subject, msgs)\n    super(ConflictingProducersError, self).__init__(msg)\n\n\n<DED><DED>class State(object):\n  <IND>@classmethod\n  def raise_unrecognized(cls, state):\n    <IND>raise ValueError('Unrecognized Node State: {}'.format(state))\n\n\n<DED><DED>class Noop(datatype('Noop', ['msg']), State):\n  <IND>\"\"\"Indicates that a Node did not have the inputs which would be needed for it to execute.\"\"\"\n  pass\n\n\n<DED>class Return(datatype('Return', ['value']), State):\n  <IND>\"\"\"Indicates that a Node successfully returned a value.\"\"\"\n  pass\n\n\n<DED>class Throw(datatype('Throw', ['exc']), State):\n  <IND>\"\"\"Indicates that a Node should have been able to return a value, but failed.\"\"\"\n  pass\n\n\n<DED>class Waiting(datatype('Waiting', ['dependencies']), State):\n  <IND>\"\"\"Indicates that a Node is waiting for some/all of the dependencies to become available.\n\n  Some Nodes will return different dependency Nodes based on where they are in their lifecycle,\n  but all returned dependencies are recorded for the lifetime of a ProductGraph.\n  \"\"\"\n  pass\n\n\n<DED>class Node(object):\n  <IND>@abstractproperty\n  def subject(self):\n    <IND>\"\"\"The subject for this Node.\"\"\"\n\n  <DED>@abstractproperty\n  def product(self):\n    <IND>\"\"\"The output product for this Node.\"\"\"\n\n  <DED>@abstractproperty\n  def variants(self):\n    <IND>\"\"\"The variants for this Node.\"\"\"\n\n  <DED>@abstractmethod\n  def step(self, dependency_states, node_builder):\n    <IND>\"\"\"Given a dict of the dependency States for this Node, returns the current State of the Node.\n\n    The NodeBuilder parameter provides a way to construct Nodes that require information about\n    installed tasks.\n\n    After this method returns a non-Waiting state, it will never be visited again for this Node.\n    \"\"\"\n\n\n<DED><DED>class SelectNode(datatype('SelectNode', ['subject', 'product', 'variants', 'variant_key']), Node):\n  <IND>\"\"\"A Node that selects a product for a subject.\n\n  A Select can be satisfied by multiple sources, but fails if multiple sources produce a value. The\n  'variants' field represents variant configuration that is propagated to dependencies. When\n  a task needs to consume a product as configured by the variants map, it uses the SelectVariant\n  selector, which introduces the 'variant' value to restrict the names of values selected by a\n  SelectNode.\n  \"\"\"\n\n  def _variants_node(self):\n    <IND>if self.product != Variants:\n      <IND>return SelectNode(self.subject, Variants, self.variants, None)\n    <DED>return None\n\n  <DED>def _select_literal(self, candidate, variant_value):\n    <IND>\"\"\"Looks for has-a or is-a relationships between the given value and the requested product.\n\n    Returns the resulting product value, or None if no match was made.\n    \"\"\"\n    def items():\n      # Check whether the subject is-a instance of the product.\n      <IND>yield candidate\n      # Else, check whether it has-a instance of the product.\n      if isinstance(candidate, Target):\n        <IND>for configuration in candidate.configurations:\n          <IND>yield configuration\n\n    # TODO: returning only the first literal configuration of a given type/variant. Need to\n    # define mergeability for products.\n    <DED><DED><DED>for item in items():\n      <IND>if not isinstance(item, self.product):\n        <IND>continue\n      <DED>if variant_value and not getattr(item, 'name', None) == variant_value:\n        <IND>continue\n      <DED>return item\n    <DED>return None\n\n  <DED>def step(self, dependency_states, node_builder):\n    # Request default Variants for the subject, so that if there are any we can propagate\n    # them to task nodes.\n    <IND>variants = self.variants\n    variants_node = self._variants_node()\n    if variants_node:\n      <IND>dep_state = dependency_states.get(variants_node, None)\n      if dep_state is None or type(dep_state) == Waiting:\n        <IND>return Waiting([variants_node])\n      <DED>elif type(dep_state) == Return:\n        # A subject's variants are overridden by any dependent's requested variants, so\n        # we merge them left to right here.\n        <IND>variants = Variants.merge(dep_state.value.default.items(), variants)\n\n    # If there is a variant_key, see whether it has been configured.\n    <DED><DED>variant_value = None\n    if self.variant_key:\n      <IND>variant_values = [value for key, value in variants\n                        if key == self.variant_key] if variants else None\n      if not variant_values:\n        # Select cannot be satisfied: no variant configured for this key.\n        <IND>return Noop('Variant key {} was not configured in variants {}'.format(\n          self.variant_key, variants))\n      <DED>variant_value = variant_values[0]\n\n    # If the Subject \"is a\" or \"has a\" Product, then we're done.\n    <DED>literal_value = self._select_literal(self.subject, variant_value)\n    if literal_value is not None:\n      <IND>return Return(literal_value)\n\n    # Else, attempt to use a configured task to compute the value.\n    <DED>has_waiting_dep = False\n    dependencies = list(node_builder.task_nodes(self.subject, self.product, variants))\n    matches = {}\n    for dep in dependencies:\n      <IND>dep_state = dependency_states.get(dep, None)\n      if dep_state is None or type(dep_state) == Waiting:\n        <IND>has_waiting_dep = True\n        continue\n      <DED>elif type(dep_state) == Throw:\n        <IND>return dep_state\n      <DED>elif type(dep_state) == Noop:\n        <IND>continue\n      <DED>elif type(dep_state) != Return:\n        <IND>State.raise_unrecognized(dep_state)\n      # We computed a value: see whether we can use it.\n      <DED>literal_value = self._select_literal(dep_state.value, variant_value)\n      if literal_value is not None:\n        <IND>matches[dep] = literal_value\n    <DED><DED>if has_waiting_dep:\n      <IND>return Waiting(dependencies)\n    <DED>elif len(matches) > 1:\n      # TODO: Multiple successful tasks are not currently supported. We should allow for this\n      # by adding support for \"mergeable\" products. see:\n      #   https://github.com/pantsbuild/pants/issues/2526\n      <IND>return Throw(ConflictingProducersError(self.subject, self.product, matches))\n    <DED>elif len(matches) == 1:\n      <IND>return Return(matches.values()[0])\n    <DED>return Noop('No source of {}.'.format(self))\n\n\n<DED><DED>class DependenciesNode(datatype('DependenciesNode', ['subject', 'product', 'variants', 'dep_product']), Node):\n  <IND>\"\"\"A Node that selects the given Product for each of the dependencies of this subject.\n\n  Begins by selecting the `dep_product` for the subject, and then selects a product for each\n  of dep_products' dependencies.\n\n  The value produced by this Node guarantees that the order of the provided values matches the\n  order of declaration in the `dependencies` list of the `dep_product`.\n  \"\"\"\n\n  def _dep_product_node(self):\n    <IND>return SelectNode(self.subject, self.dep_product, self.variants, None)\n\n  <DED>def _dep_node(self, dependency):\n    <IND>variants = self.variants\n    if isinstance(dependency, Address):\n      # If a subject has literal variants for particular dependencies, they win over all else.\n      <IND>dependency, literal_variants = parse_variants(dependency)\n      variants = Variants.merge(variants, literal_variants)\n    <DED>return SelectNode(dependency, self.product, variants, None)\n\n  <DED>def step(self, dependency_states, node_builder):\n    # Request the product we need in order to request dependencies.\n    <IND>dep_product_node = self._dep_product_node()\n    dep_product_state = dependency_states.get(dep_product_node, None)\n    if dep_product_state is None or type(dep_product_state) == Waiting:\n      <IND>return Waiting([dep_product_node])\n    <DED>elif type(dep_product_state) == Throw:\n      <IND>return dep_product_state\n    <DED>elif type(dep_product_state) == Noop:\n      <IND>return Noop('Could not compute {} to determine dependencies.'.format(dep_product_node))\n    <DED>elif type(dep_product_state) != Return:\n      <IND>State.raise_unrecognized(dep_product_state)\n\n    # The product and its dependency list are available.\n    <DED>dep_product = dep_product_state.value\n    dependencies = [self._dep_node(d) for d in dep_product.dependencies]\n    for dependency in dependencies:\n      <IND>dep_state = dependency_states.get(dependency, None)\n      if dep_state is None or type(dep_state) == Waiting:\n        # One of the dependencies is not yet available. Indicate that we are waiting for all\n        # of them.\n        <IND>return Waiting([dep_product_node] + dependencies)\n      <DED>elif type(dep_state) == Throw:\n        <IND>return dep_state\n      <DED>elif type(dep_state) == Noop:\n        <IND>return Throw(ValueError('No source of explicit dependency {}'.format(dependency)))\n      <DED>elif type(dep_state) != Return:\n        <IND>raise State.raise_unrecognized(dep_state)\n    # All dependencies are present! Set our value to a list of the resulting values.\n    <DED><DED>return Return([dependency_states[d].value for d in dependencies])\n\n\n<DED><DED>class TaskNode(datatype('TaskNode', ['subject', 'product', 'variants', 'func', 'clause']), Node):\n\n  <IND>def step(self, dependency_states, node_builder):\n    # Compute dependencies.\n    <IND>dep_values = []\n    dependencies = []\n    for select in self.clause:\n      <IND>dep = select.construct_node(self.subject, self.variants)\n      if dep is None:\n        <IND>return Noop('Dependency {} is not satisfiable.'.format(select))\n      <DED>dependencies.append(dep)\n\n    # If all dependency Nodes are Return, execute the Node.\n    <DED>for dep_select, dep_key in zip(self.clause, dependencies):\n      <IND>dep_state = dependency_states.get(dep_key, None)\n      if dep_state is None or type(dep_state) == Waiting:\n        <IND>return Waiting(dependencies)\n      <DED>elif type(dep_state) == Return:\n        <IND>dep_values.append(dep_state.value)\n      <DED>elif type(dep_state) == Noop:\n        <IND>if dep_select.optional:\n          <IND>dep_values.append(None)\n        <DED>else:\n          <IND>return Noop('Was missing (at least) input {}.'.format(dep_key))\n      <DED><DED>elif type(dep_state) == Throw:\n        <IND>return dep_state\n      <DED>else:\n        <IND>State.raise_unrecognized(dep_state)\n    <DED><DED>try:\n      <IND>return Return(self.func(*dep_values))\n    <DED>except Exception as e:\n      <IND>return Throw(e)\n\n\n<DED><DED><DED>class ProductGraph(object):\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n<DED><DED>class ProductGraph(object):\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "pantsbuild/pants",
    "commit": "08bc2add6e98feefdce36f6f094a15e3e598b1e7",
    "filename": "src/python/pants/engine/exp/scheduler.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/pantsbuild-pants/src/python/pants/engine/exp/scheduler.py",
    "file_hunks_size": 13,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "src/python/pants/engine/exp/scheduler.py:73:23 Invalid type [31]: Expression `pants.util.objects.datatype(\"Projection\", [\"product\", \"projected_product\", \"fields\", \"input_product\"])` is not a valid type.",
    "message": " Expression `pants.util.objects.datatype(\"Projection\", [\"product\", \"projected_product\", \"fields\", \"input_product\"])` is not a valid type.",
    "rule_id": "Invalid type [31]",
    "warning_line_no": 73,
    "warning_line": "class SelectProjection(datatype('Projection', ['product', 'projected_product', 'fields', 'input_product']), Selector):",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\nclass Selector(AbstractClass):\n  @abstractproperty\n  def optional(self):\n    \"\"\"Return true if this Selector is optional. It may result in a `None` match.\"\"\"\n\n  @abstractmethod\n  def construct_node(self, subject, variants):\n    \"\"\"Constructs a Node for this Selector and the given Subject/Variants.\n\n    May return None if the Selector can be known statically to not be satisfiable for the inputs.\n    \"\"\"\n\n\nclass Select(datatype('Subject', ['product', 'optional']), Selector):\n  \"\"\"Selects the given Product for the Subject provided to the constructor.\n\n  If optional=True and no matching product can be produced, will return None.\n  \"\"\"\n\n  def __new__(self, product, optional=False):\n    return super(Select, self).__new__(self, product, optional)\n\n  def construct_node(self, subject, variants):\n    return SelectNode(subject, self.product, variants, None)\n\n\nclass SelectVariant(datatype('Variant', ['product', 'variant_key']), Selector):\n  \"\"\"Selects the matching Product and variant name for the Subject provided to the constructor.\n\n  For example: a SelectVariant with a variant_key of \"thrift\" and a product of type ApacheThrift\n  will only match when a consumer passes a variant value for \"thrift\" that matches the name of an\n  ApacheThrift value.\n  \"\"\"\n  optional = False\n\n  def construct_node(self, subject, variants):\n    return SelectNode(subject, self.product, variants, self.variant_key)\n\n\nclass SelectDependencies(datatype('Dependencies', ['product', 'deps_product']), Selector):\n  \"\"\"Selects a product for each of the dependencies of a product for the Subject.\n\n  The dependencies declared on `deps_product` will be provided to the requesting task\n  in the order they were declared.\n  \"\"\"\n  optional = False\n\n  def construct_node(self, subject, variants):\n    return DependenciesNode(subject, self.product, variants, self.deps_product)\n\n\nclass SelectProjection(datatype('Projection', ['product', 'projected_product', 'fields', 'input_product']), Selector):\n  \"\"\"Selects a field of the given Subject to produce a Subject, Product dependency from.\n\n  Projecting an input allows for deduplication in the graph, where multiple Subjects\n  resolve to a single backing Subject instead.\n  \"\"\"\n  optional = False\n\n  def construct_node(self, subject, variants):\n    # Input product type doesn't match: not satisfiable.\n    if not type(subject) == self.input_product:\n      return None\n\n    # Find the fields of the Subject to project.\n    values = []\n    for field in self.fields:\n      values.append(getattr(subject, field))\n    projected_subject = self.projected_product(*values)\n    return SelectNode(projected_subject, self.product, variants, None)\n\n\nclass SelectLiteral(datatype('Literal', ['subject', 'product']), Selector):\n  \"\"\"Selects a literal Subject (other than the one applied to the selector).\"\"\"\n  optional = False\n\n  def construct_node(self, subject, variants):\n    # NB: Intentionally ignores subject parameter to provide a literal subject.\n    return SelectNode(self.subject, self.product, variants, None)\n\n\nclass SchedulingError(Exception):\n  \"\"\"Indicates inability to make a scheduling promise.\"\"\"\n\n\nclass PartiallyConsumedInputsError(SchedulingError):\n  \"\"\"No task was able to consume a particular literal product for a subject, although some tried.\n",
        "source_code_len": 3277,
        "target_code": "\nclass PartiallyConsumedInputsError(Exception):\n  \"\"\"No task was able to consume a particular literal product for a subject, although some tried.\n",
        "target_code_len": 146,
        "diff_format": "@@ -21,88 +20,3 @@\n \n-class Selector(AbstractClass):\n-  @abstractproperty\n-  def optional(self):\n-    \"\"\"Return true if this Selector is optional. It may result in a `None` match.\"\"\"\n-\n-  @abstractmethod\n-  def construct_node(self, subject, variants):\n-    \"\"\"Constructs a Node for this Selector and the given Subject/Variants.\n-\n-    May return None if the Selector can be known statically to not be satisfiable for the inputs.\n-    \"\"\"\n-\n-\n-class Select(datatype('Subject', ['product', 'optional']), Selector):\n-  \"\"\"Selects the given Product for the Subject provided to the constructor.\n-\n-  If optional=True and no matching product can be produced, will return None.\n-  \"\"\"\n-\n-  def __new__(self, product, optional=False):\n-    return super(Select, self).__new__(self, product, optional)\n-\n-  def construct_node(self, subject, variants):\n-    return SelectNode(subject, self.product, variants, None)\n-\n-\n-class SelectVariant(datatype('Variant', ['product', 'variant_key']), Selector):\n-  \"\"\"Selects the matching Product and variant name for the Subject provided to the constructor.\n-\n-  For example: a SelectVariant with a variant_key of \"thrift\" and a product of type ApacheThrift\n-  will only match when a consumer passes a variant value for \"thrift\" that matches the name of an\n-  ApacheThrift value.\n-  \"\"\"\n-  optional = False\n-\n-  def construct_node(self, subject, variants):\n-    return SelectNode(subject, self.product, variants, self.variant_key)\n-\n-\n-class SelectDependencies(datatype('Dependencies', ['product', 'deps_product']), Selector):\n-  \"\"\"Selects a product for each of the dependencies of a product for the Subject.\n-\n-  The dependencies declared on `deps_product` will be provided to the requesting task\n-  in the order they were declared.\n-  \"\"\"\n-  optional = False\n-\n-  def construct_node(self, subject, variants):\n-    return DependenciesNode(subject, self.product, variants, self.deps_product)\n-\n-\n-class SelectProjection(datatype('Projection', ['product', 'projected_product', 'fields', 'input_product']), Selector):\n-  \"\"\"Selects a field of the given Subject to produce a Subject, Product dependency from.\n-\n-  Projecting an input allows for deduplication in the graph, where multiple Subjects\n-  resolve to a single backing Subject instead.\n-  \"\"\"\n-  optional = False\n-\n-  def construct_node(self, subject, variants):\n-    # Input product type doesn't match: not satisfiable.\n-    if not type(subject) == self.input_product:\n-      return None\n-\n-    # Find the fields of the Subject to project.\n-    values = []\n-    for field in self.fields:\n-      values.append(getattr(subject, field))\n-    projected_subject = self.projected_product(*values)\n-    return SelectNode(projected_subject, self.product, variants, None)\n-\n-\n-class SelectLiteral(datatype('Literal', ['subject', 'product']), Selector):\n-  \"\"\"Selects a literal Subject (other than the one applied to the selector).\"\"\"\n-  optional = False\n-\n-  def construct_node(self, subject, variants):\n-    # NB: Intentionally ignores subject parameter to provide a literal subject.\n-    return SelectNode(self.subject, self.product, variants, None)\n-\n-\n-class SchedulingError(Exception):\n-  \"\"\"Indicates inability to make a scheduling promise.\"\"\"\n-\n-\n-class PartiallyConsumedInputsError(SchedulingError):\n+class PartiallyConsumedInputsError(Exception):\n   \"\"\"No task was able to consume a particular literal product for a subject, although some tried.\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\nclass Selector(AbstractClass):\n  <IND>@abstractproperty\n  def optional(self):\n    <IND>\"\"\"Return true if this Selector is optional. It may result in a `None` match.\"\"\"\n\n  <DED>@abstractmethod\n  def construct_node(self, subject, variants):\n    <IND>\"\"\"Constructs a Node for this Selector and the given Subject/Variants.\n\n    May return None if the Selector can be known statically to not be satisfiable for the inputs.\n    \"\"\"\n\n\n<DED><DED>class Select(datatype('Subject', ['product', 'optional']), Selector):\n  <IND>\"\"\"Selects the given Product for the Subject provided to the constructor.\n\n  If optional=True and no matching product can be produced, will return None.\n  \"\"\"\n\n  def __new__(self, product, optional=False):\n    <IND>return super(Select, self).__new__(self, product, optional)\n\n  <DED>def construct_node(self, subject, variants):\n    <IND>return SelectNode(subject, self.product, variants, None)\n\n\n<DED><DED>class SelectVariant(datatype('Variant', ['product', 'variant_key']), Selector):\n  <IND>\"\"\"Selects the matching Product and variant name for the Subject provided to the constructor.\n\n  For example: a SelectVariant with a variant_key of \"thrift\" and a product of type ApacheThrift\n  will only match when a consumer passes a variant value for \"thrift\" that matches the name of an\n  ApacheThrift value.\n  \"\"\"\n  optional = False\n\n  def construct_node(self, subject, variants):\n    <IND>return SelectNode(subject, self.product, variants, self.variant_key)\n\n\n<DED><DED>class SelectDependencies(datatype('Dependencies', ['product', 'deps_product']), Selector):\n  <IND>\"\"\"Selects a product for each of the dependencies of a product for the Subject.\n\n  The dependencies declared on `deps_product` will be provided to the requesting task\n  in the order they were declared.\n  \"\"\"\n  optional = False\n\n  def construct_node(self, subject, variants):\n    <IND>return DependenciesNode(subject, self.product, variants, self.deps_product)\n\n\n<DED><DED>class SelectProjection(datatype('Projection', ['product', 'projected_product', 'fields', 'input_product']), Selector):\n  <IND>\"\"\"Selects a field of the given Subject to produce a Subject, Product dependency from.\n\n  Projecting an input allows for deduplication in the graph, where multiple Subjects\n  resolve to a single backing Subject instead.\n  \"\"\"\n  optional = False\n\n  def construct_node(self, subject, variants):\n    # Input product type doesn't match: not satisfiable.\n    <IND>if not type(subject) == self.input_product:\n      <IND>return None\n\n    # Find the fields of the Subject to project.\n    <DED>values = []\n    for field in self.fields:\n      <IND>values.append(getattr(subject, field))\n    <DED>projected_subject = self.projected_product(*values)\n    return SelectNode(projected_subject, self.product, variants, None)\n\n\n<DED><DED>class SelectLiteral(datatype('Literal', ['subject', 'product']), Selector):\n  <IND>\"\"\"Selects a literal Subject (other than the one applied to the selector).\"\"\"\n  optional = False\n\n  def construct_node(self, subject, variants):\n    # NB: Intentionally ignores subject parameter to provide a literal subject.\n    <IND>return SelectNode(self.subject, self.product, variants, None)\n\n\n<DED><DED>class SchedulingError(Exception):\n  <IND>\"\"\"Indicates inability to make a scheduling promise.\"\"\"\n\n\n<DED>class PartiallyConsumedInputsError(SchedulingError):\n  <IND>",
        "target_code_with_indent": "\nclass PartiallyConsumedInputsError(Exception):\n  <IND>"
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": true,
        "has_suppression": false,
        "source_code": "\nclass ConflictingProducersError(SchedulingError):\n  \"\"\"Indicates that there was more than one source of a product for a given subject.\n\n  TODO: This will need to be legal in order to support multiple Planners producing a\n  (mergeable) Classpath for one subject, for example. see:\n    https://github.com/pantsbuild/pants/issues/2526\n  \"\"\"\n\n  def __init__(self, subject, product, matches):\n    msgs = '\\n  '.join('{}: {}'.format(k, v) for k, v in matches.items())\n    msg = 'More than one source of {} for {}:\\n  {}'.format(product.__name__, subject, msgs)\n    super(ConflictingProducersError, self).__init__(msg)\n\n\nclass State(object):\n  @classmethod\n  def raise_unrecognized(cls, state):\n    raise ValueError('Unrecognized Node State: {}'.format(state))\n\n\nclass Noop(datatype('Noop', ['msg']), State):\n  \"\"\"Indicates that a Node did not have the inputs which would be needed for it to execute.\"\"\"\n  pass\n\n\nclass Return(datatype('Return', ['value']), State):\n  \"\"\"Indicates that a Node successfully returned a value.\"\"\"\n  pass\n\n\nclass Throw(datatype('Throw', ['exc']), State):\n  \"\"\"Indicates that a Node should have been able to return a value, but failed.\"\"\"\n  pass\n\n\nclass Waiting(datatype('Waiting', ['dependencies']), State):\n  \"\"\"Indicates that a Node is waiting for some/all of the dependencies to become available.\n\n  Some Nodes will return different dependency Nodes based on where they are in their lifecycle,\n  but all returned dependencies are recorded for the lifetime of a ProductGraph.\n  \"\"\"\n  pass\n\n\nclass Node(object):\n  @abstractproperty\n  def subject(self):\n    \"\"\"The subject for this Node.\"\"\"\n\n  @abstractproperty\n  def product(self):\n    \"\"\"The output product for this Node.\"\"\"\n\n  @abstractproperty\n  def variants(self):\n    \"\"\"The variants for this Node.\"\"\"\n\n  @abstractmethod\n  def step(self, dependency_states, node_builder):\n    \"\"\"Given a dict of the dependency States for this Node, returns the current State of the Node.\n\n    The NodeBuilder parameter provides a way to construct Nodes that require information about\n    installed tasks.\n\n    After this method returns a non-Waiting state, it will never be visited again for this Node.\n    \"\"\"\n\n\nclass SelectNode(datatype('SelectNode', ['subject', 'product', 'variants', 'variant_key']), Node):\n  \"\"\"A Node that selects a product for a subject.\n\n  A Select can be satisfied by multiple sources, but fails if multiple sources produce a value. The\n  'variants' field represents variant configuration that is propagated to dependencies. When\n  a task needs to consume a product as configured by the variants map, it uses the SelectVariant\n  selector, which introduces the 'variant' value to restrict the names of values selected by a\n  SelectNode.\n  \"\"\"\n\n  def _variants_node(self):\n    if self.product != Variants:\n      return SelectNode(self.subject, Variants, self.variants, None)\n    return None\n\n  def _select_literal(self, candidate, variant_value):\n    \"\"\"Looks for has-a or is-a relationships between the given value and the requested product.\n\n    Returns the resulting product value, or None if no match was made.\n    \"\"\"\n    def items():\n      # Check whether the subject is-a instance of the product.\n      yield candidate\n      # Else, check whether it has-a instance of the product.\n      if isinstance(candidate, Target):\n        for configuration in candidate.configurations:\n          yield configuration\n\n    # TODO: returning only the first literal configuration of a given type/variant. Need to\n    # define mergeability for products.\n    for item in items():\n      if not isinstance(item, self.product):\n        continue\n      if variant_value and not getattr(item, 'name', None) == variant_value:\n        continue\n      return item\n    return None\n\n  def step(self, dependency_states, node_builder):\n    # Request default Variants for the subject, so that if there are any we can propagate\n    # them to task nodes.\n    variants = self.variants\n    variants_node = self._variants_node()\n    if variants_node:\n      dep_state = dependency_states.get(variants_node, None)\n      if dep_state is None or type(dep_state) == Waiting:\n        return Waiting([variants_node])\n      elif type(dep_state) == Return:\n        # A subject's variants are overridden by any dependent's requested variants, so\n        # we merge them left to right here.\n        variants = Variants.merge(dep_state.value.default.items(), variants)\n\n    # If there is a variant_key, see whether it has been configured.\n    variant_value = None\n    if self.variant_key:\n      variant_values = [value for key, value in variants\n                        if key == self.variant_key] if variants else None\n      if not variant_values:\n        # Select cannot be satisfied: no variant configured for this key.\n        return Noop('Variant key {} was not configured in variants {}'.format(\n          self.variant_key, variants))\n      variant_value = variant_values[0]\n\n    # If the Subject \"is a\" or \"has a\" Product, then we're done.\n    literal_value = self._select_literal(self.subject, variant_value)\n    if literal_value is not None:\n      return Return(literal_value)\n\n    # Else, attempt to use a configured task to compute the value.\n    has_waiting_dep = False\n    dependencies = list(node_builder.task_nodes(self.subject, self.product, variants))\n    matches = {}\n    for dep in dependencies:\n      dep_state = dependency_states.get(dep, None)\n      if dep_state is None or type(dep_state) == Waiting:\n        has_waiting_dep = True\n        continue\n      elif type(dep_state) == Throw:\n        return dep_state\n      elif type(dep_state) == Noop:\n        continue\n      elif type(dep_state) != Return:\n        State.raise_unrecognized(dep_state)\n      # We computed a value: see whether we can use it.\n      literal_value = self._select_literal(dep_state.value, variant_value)\n      if literal_value is not None:\n        matches[dep] = literal_value\n    if has_waiting_dep:\n      return Waiting(dependencies)\n    elif len(matches) > 1:\n      # TODO: Multiple successful tasks are not currently supported. We should allow for this\n      # by adding support for \"mergeable\" products. see:\n      #   https://github.com/pantsbuild/pants/issues/2526\n      return Throw(ConflictingProducersError(self.subject, self.product, matches))\n    elif len(matches) == 1:\n      return Return(matches.values()[0])\n    return Noop('No source of {}.'.format(self))\n\n\nclass DependenciesNode(datatype('DependenciesNode', ['subject', 'product', 'variants', 'dep_product']), Node):\n  \"\"\"A Node that selects the given Product for each of the dependencies of this subject.\n\n  Begins by selecting the `dep_product` for the subject, and then selects a product for each\n  of dep_products' dependencies.\n\n  The value produced by this Node guarantees that the order of the provided values matches the\n  order of declaration in the `dependencies` list of the `dep_product`.\n  \"\"\"\n\n  def _dep_product_node(self):\n    return SelectNode(self.subject, self.dep_product, self.variants, None)\n\n  def _dep_node(self, dependency):\n    variants = self.variants\n    if isinstance(dependency, Address):\n      # If a subject has literal variants for particular dependencies, they win over all else.\n      dependency, literal_variants = parse_variants(dependency)\n      variants = Variants.merge(variants, literal_variants)\n    return SelectNode(dependency, self.product, variants, None)\n\n  def step(self, dependency_states, node_builder):\n    # Request the product we need in order to request dependencies.\n    dep_product_node = self._dep_product_node()\n    dep_product_state = dependency_states.get(dep_product_node, None)\n    if dep_product_state is None or type(dep_product_state) == Waiting:\n      return Waiting([dep_product_node])\n    elif type(dep_product_state) == Throw:\n      return dep_product_state\n    elif type(dep_product_state) == Noop:\n      return Noop('Could not compute {} to determine dependencies.'.format(dep_product_node))\n    elif type(dep_product_state) != Return:\n      State.raise_unrecognized(dep_product_state)\n\n    # The product and its dependency list are available.\n    dep_product = dep_product_state.value\n    dependencies = [self._dep_node(d) for d in dep_product.dependencies]\n    for dependency in dependencies:\n      dep_state = dependency_states.get(dependency, None)\n      if dep_state is None or type(dep_state) == Waiting:\n        # One of the dependencies is not yet available. Indicate that we are waiting for all\n        # of them.\n        return Waiting([dep_product_node] + dependencies)\n      elif type(dep_state) == Throw:\n        return dep_state\n      elif type(dep_state) == Noop:\n        return Throw(ValueError('No source of explicit dependency {}'.format(dependency)))\n      elif type(dep_state) != Return:\n        raise State.raise_unrecognized(dep_state)\n    # All dependencies are present! Set our value to a list of the resulting values.\n    return Return([dependency_states[d].value for d in dependencies])\n\n\nclass TaskNode(datatype('TaskNode', ['subject', 'product', 'variants', 'func', 'clause']), Node):\n\n  def step(self, dependency_states, node_builder):\n    # Compute dependencies.\n    dep_values = []\n    dependencies = []\n    for select in self.clause:\n      dep = select.construct_node(self.subject, self.variants)\n      if dep is None:\n        return Noop('Dependency {} is not satisfiable.'.format(select))\n      dependencies.append(dep)\n\n    # If all dependency Nodes are Return, execute the Node.\n    for dep_select, dep_key in zip(self.clause, dependencies):\n      dep_state = dependency_states.get(dep_key, None)\n      if dep_state is None or type(dep_state) == Waiting:\n        return Waiting(dependencies)\n      elif type(dep_state) == Return:\n        dep_values.append(dep_state.value)\n      elif type(dep_state) == Noop:\n        if dep_select.optional:\n          dep_values.append(None)\n        else:\n          return Noop('Was missing (at least) input {}.'.format(dep_key))\n      elif type(dep_state) == Throw:\n        return dep_state\n      else:\n        State.raise_unrecognized(dep_state)\n    try:\n      return Return(self.func(*dep_values))\n    except Exception as e:\n      return Throw(e)\n\n\nclass ProductGraph(object):\n",
        "source_code_len": 10229,
        "target_code": "\nclass ProductGraph(object):\n",
        "target_code_len": 29,
        "diff_format": "@@ -134,256 +48,2 @@\n \n-class ConflictingProducersError(SchedulingError):\n-  \"\"\"Indicates that there was more than one source of a product for a given subject.\n-\n-  TODO: This will need to be legal in order to support multiple Planners producing a\n-  (mergeable) Classpath for one subject, for example. see:\n-    https://github.com/pantsbuild/pants/issues/2526\n-  \"\"\"\n-\n-  def __init__(self, subject, product, matches):\n-    msgs = '\\n  '.join('{}: {}'.format(k, v) for k, v in matches.items())\n-    msg = 'More than one source of {} for {}:\\n  {}'.format(product.__name__, subject, msgs)\n-    super(ConflictingProducersError, self).__init__(msg)\n-\n-\n-class State(object):\n-  @classmethod\n-  def raise_unrecognized(cls, state):\n-    raise ValueError('Unrecognized Node State: {}'.format(state))\n-\n-\n-class Noop(datatype('Noop', ['msg']), State):\n-  \"\"\"Indicates that a Node did not have the inputs which would be needed for it to execute.\"\"\"\n-  pass\n-\n-\n-class Return(datatype('Return', ['value']), State):\n-  \"\"\"Indicates that a Node successfully returned a value.\"\"\"\n-  pass\n-\n-\n-class Throw(datatype('Throw', ['exc']), State):\n-  \"\"\"Indicates that a Node should have been able to return a value, but failed.\"\"\"\n-  pass\n-\n-\n-class Waiting(datatype('Waiting', ['dependencies']), State):\n-  \"\"\"Indicates that a Node is waiting for some/all of the dependencies to become available.\n-\n-  Some Nodes will return different dependency Nodes based on where they are in their lifecycle,\n-  but all returned dependencies are recorded for the lifetime of a ProductGraph.\n-  \"\"\"\n-  pass\n-\n-\n-class Node(object):\n-  @abstractproperty\n-  def subject(self):\n-    \"\"\"The subject for this Node.\"\"\"\n-\n-  @abstractproperty\n-  def product(self):\n-    \"\"\"The output product for this Node.\"\"\"\n-\n-  @abstractproperty\n-  def variants(self):\n-    \"\"\"The variants for this Node.\"\"\"\n-\n-  @abstractmethod\n-  def step(self, dependency_states, node_builder):\n-    \"\"\"Given a dict of the dependency States for this Node, returns the current State of the Node.\n-\n-    The NodeBuilder parameter provides a way to construct Nodes that require information about\n-    installed tasks.\n-\n-    After this method returns a non-Waiting state, it will never be visited again for this Node.\n-    \"\"\"\n-\n-\n-class SelectNode(datatype('SelectNode', ['subject', 'product', 'variants', 'variant_key']), Node):\n-  \"\"\"A Node that selects a product for a subject.\n-\n-  A Select can be satisfied by multiple sources, but fails if multiple sources produce a value. The\n-  'variants' field represents variant configuration that is propagated to dependencies. When\n-  a task needs to consume a product as configured by the variants map, it uses the SelectVariant\n-  selector, which introduces the 'variant' value to restrict the names of values selected by a\n-  SelectNode.\n-  \"\"\"\n-\n-  def _variants_node(self):\n-    if self.product != Variants:\n-      return SelectNode(self.subject, Variants, self.variants, None)\n-    return None\n-\n-  def _select_literal(self, candidate, variant_value):\n-    \"\"\"Looks for has-a or is-a relationships between the given value and the requested product.\n-\n-    Returns the resulting product value, or None if no match was made.\n-    \"\"\"\n-    def items():\n-      # Check whether the subject is-a instance of the product.\n-      yield candidate\n-      # Else, check whether it has-a instance of the product.\n-      if isinstance(candidate, Target):\n-        for configuration in candidate.configurations:\n-          yield configuration\n-\n-    # TODO: returning only the first literal configuration of a given type/variant. Need to\n-    # define mergeability for products.\n-    for item in items():\n-      if not isinstance(item, self.product):\n-        continue\n-      if variant_value and not getattr(item, 'name', None) == variant_value:\n-        continue\n-      return item\n-    return None\n-\n-  def step(self, dependency_states, node_builder):\n-    # Request default Variants for the subject, so that if there are any we can propagate\n-    # them to task nodes.\n-    variants = self.variants\n-    variants_node = self._variants_node()\n-    if variants_node:\n-      dep_state = dependency_states.get(variants_node, None)\n-      if dep_state is None or type(dep_state) == Waiting:\n-        return Waiting([variants_node])\n-      elif type(dep_state) == Return:\n-        # A subject's variants are overridden by any dependent's requested variants, so\n-        # we merge them left to right here.\n-        variants = Variants.merge(dep_state.value.default.items(), variants)\n-\n-    # If there is a variant_key, see whether it has been configured.\n-    variant_value = None\n-    if self.variant_key:\n-      variant_values = [value for key, value in variants\n-                        if key == self.variant_key] if variants else None\n-      if not variant_values:\n-        # Select cannot be satisfied: no variant configured for this key.\n-        return Noop('Variant key {} was not configured in variants {}'.format(\n-          self.variant_key, variants))\n-      variant_value = variant_values[0]\n-\n-    # If the Subject \"is a\" or \"has a\" Product, then we're done.\n-    literal_value = self._select_literal(self.subject, variant_value)\n-    if literal_value is not None:\n-      return Return(literal_value)\n-\n-    # Else, attempt to use a configured task to compute the value.\n-    has_waiting_dep = False\n-    dependencies = list(node_builder.task_nodes(self.subject, self.product, variants))\n-    matches = {}\n-    for dep in dependencies:\n-      dep_state = dependency_states.get(dep, None)\n-      if dep_state is None or type(dep_state) == Waiting:\n-        has_waiting_dep = True\n-        continue\n-      elif type(dep_state) == Throw:\n-        return dep_state\n-      elif type(dep_state) == Noop:\n-        continue\n-      elif type(dep_state) != Return:\n-        State.raise_unrecognized(dep_state)\n-      # We computed a value: see whether we can use it.\n-      literal_value = self._select_literal(dep_state.value, variant_value)\n-      if literal_value is not None:\n-        matches[dep] = literal_value\n-    if has_waiting_dep:\n-      return Waiting(dependencies)\n-    elif len(matches) > 1:\n-      # TODO: Multiple successful tasks are not currently supported. We should allow for this\n-      # by adding support for \"mergeable\" products. see:\n-      #   https://github.com/pantsbuild/pants/issues/2526\n-      return Throw(ConflictingProducersError(self.subject, self.product, matches))\n-    elif len(matches) == 1:\n-      return Return(matches.values()[0])\n-    return Noop('No source of {}.'.format(self))\n-\n-\n-class DependenciesNode(datatype('DependenciesNode', ['subject', 'product', 'variants', 'dep_product']), Node):\n-  \"\"\"A Node that selects the given Product for each of the dependencies of this subject.\n-\n-  Begins by selecting the `dep_product` for the subject, and then selects a product for each\n-  of dep_products' dependencies.\n-\n-  The value produced by this Node guarantees that the order of the provided values matches the\n-  order of declaration in the `dependencies` list of the `dep_product`.\n-  \"\"\"\n-\n-  def _dep_product_node(self):\n-    return SelectNode(self.subject, self.dep_product, self.variants, None)\n-\n-  def _dep_node(self, dependency):\n-    variants = self.variants\n-    if isinstance(dependency, Address):\n-      # If a subject has literal variants for particular dependencies, they win over all else.\n-      dependency, literal_variants = parse_variants(dependency)\n-      variants = Variants.merge(variants, literal_variants)\n-    return SelectNode(dependency, self.product, variants, None)\n-\n-  def step(self, dependency_states, node_builder):\n-    # Request the product we need in order to request dependencies.\n-    dep_product_node = self._dep_product_node()\n-    dep_product_state = dependency_states.get(dep_product_node, None)\n-    if dep_product_state is None or type(dep_product_state) == Waiting:\n-      return Waiting([dep_product_node])\n-    elif type(dep_product_state) == Throw:\n-      return dep_product_state\n-    elif type(dep_product_state) == Noop:\n-      return Noop('Could not compute {} to determine dependencies.'.format(dep_product_node))\n-    elif type(dep_product_state) != Return:\n-      State.raise_unrecognized(dep_product_state)\n-\n-    # The product and its dependency list are available.\n-    dep_product = dep_product_state.value\n-    dependencies = [self._dep_node(d) for d in dep_product.dependencies]\n-    for dependency in dependencies:\n-      dep_state = dependency_states.get(dependency, None)\n-      if dep_state is None or type(dep_state) == Waiting:\n-        # One of the dependencies is not yet available. Indicate that we are waiting for all\n-        # of them.\n-        return Waiting([dep_product_node] + dependencies)\n-      elif type(dep_state) == Throw:\n-        return dep_state\n-      elif type(dep_state) == Noop:\n-        return Throw(ValueError('No source of explicit dependency {}'.format(dependency)))\n-      elif type(dep_state) != Return:\n-        raise State.raise_unrecognized(dep_state)\n-    # All dependencies are present! Set our value to a list of the resulting values.\n-    return Return([dependency_states[d].value for d in dependencies])\n-\n-\n-class TaskNode(datatype('TaskNode', ['subject', 'product', 'variants', 'func', 'clause']), Node):\n-\n-  def step(self, dependency_states, node_builder):\n-    # Compute dependencies.\n-    dep_values = []\n-    dependencies = []\n-    for select in self.clause:\n-      dep = select.construct_node(self.subject, self.variants)\n-      if dep is None:\n-        return Noop('Dependency {} is not satisfiable.'.format(select))\n-      dependencies.append(dep)\n-\n-    # If all dependency Nodes are Return, execute the Node.\n-    for dep_select, dep_key in zip(self.clause, dependencies):\n-      dep_state = dependency_states.get(dep_key, None)\n-      if dep_state is None or type(dep_state) == Waiting:\n-        return Waiting(dependencies)\n-      elif type(dep_state) == Return:\n-        dep_values.append(dep_state.value)\n-      elif type(dep_state) == Noop:\n-        if dep_select.optional:\n-          dep_values.append(None)\n-        else:\n-          return Noop('Was missing (at least) input {}.'.format(dep_key))\n-      elif type(dep_state) == Throw:\n-        return dep_state\n-      else:\n-        State.raise_unrecognized(dep_state)\n-    try:\n-      return Return(self.func(*dep_values))\n-    except Exception as e:\n-      return Throw(e)\n-\n-\n class ProductGraph(object):\n",
        "source_code_with_indent": "\n<DED><DED>class ConflictingProducersError(SchedulingError):\n  <IND>\"\"\"Indicates that there was more than one source of a product for a given subject.\n\n  TODO: This will need to be legal in order to support multiple Planners producing a\n  (mergeable) Classpath for one subject, for example. see:\n    https://github.com/pantsbuild/pants/issues/2526\n  \"\"\"\n\n  def __init__(self, subject, product, matches):\n    <IND>msgs = '\\n  '.join('{}: {}'.format(k, v) for k, v in matches.items())\n    msg = 'More than one source of {} for {}:\\n  {}'.format(product.__name__, subject, msgs)\n    super(ConflictingProducersError, self).__init__(msg)\n\n\n<DED><DED>class State(object):\n  <IND>@classmethod\n  def raise_unrecognized(cls, state):\n    <IND>raise ValueError('Unrecognized Node State: {}'.format(state))\n\n\n<DED><DED>class Noop(datatype('Noop', ['msg']), State):\n  <IND>\"\"\"Indicates that a Node did not have the inputs which would be needed for it to execute.\"\"\"\n  pass\n\n\n<DED>class Return(datatype('Return', ['value']), State):\n  <IND>\"\"\"Indicates that a Node successfully returned a value.\"\"\"\n  pass\n\n\n<DED>class Throw(datatype('Throw', ['exc']), State):\n  <IND>\"\"\"Indicates that a Node should have been able to return a value, but failed.\"\"\"\n  pass\n\n\n<DED>class Waiting(datatype('Waiting', ['dependencies']), State):\n  <IND>\"\"\"Indicates that a Node is waiting for some/all of the dependencies to become available.\n\n  Some Nodes will return different dependency Nodes based on where they are in their lifecycle,\n  but all returned dependencies are recorded for the lifetime of a ProductGraph.\n  \"\"\"\n  pass\n\n\n<DED>class Node(object):\n  <IND>@abstractproperty\n  def subject(self):\n    <IND>\"\"\"The subject for this Node.\"\"\"\n\n  <DED>@abstractproperty\n  def product(self):\n    <IND>\"\"\"The output product for this Node.\"\"\"\n\n  <DED>@abstractproperty\n  def variants(self):\n    <IND>\"\"\"The variants for this Node.\"\"\"\n\n  <DED>@abstractmethod\n  def step(self, dependency_states, node_builder):\n    <IND>\"\"\"Given a dict of the dependency States for this Node, returns the current State of the Node.\n\n    The NodeBuilder parameter provides a way to construct Nodes that require information about\n    installed tasks.\n\n    After this method returns a non-Waiting state, it will never be visited again for this Node.\n    \"\"\"\n\n\n<DED><DED>class SelectNode(datatype('SelectNode', ['subject', 'product', 'variants', 'variant_key']), Node):\n  <IND>\"\"\"A Node that selects a product for a subject.\n\n  A Select can be satisfied by multiple sources, but fails if multiple sources produce a value. The\n  'variants' field represents variant configuration that is propagated to dependencies. When\n  a task needs to consume a product as configured by the variants map, it uses the SelectVariant\n  selector, which introduces the 'variant' value to restrict the names of values selected by a\n  SelectNode.\n  \"\"\"\n\n  def _variants_node(self):\n    <IND>if self.product != Variants:\n      <IND>return SelectNode(self.subject, Variants, self.variants, None)\n    <DED>return None\n\n  <DED>def _select_literal(self, candidate, variant_value):\n    <IND>\"\"\"Looks for has-a or is-a relationships between the given value and the requested product.\n\n    Returns the resulting product value, or None if no match was made.\n    \"\"\"\n    def items():\n      # Check whether the subject is-a instance of the product.\n      <IND>yield candidate\n      # Else, check whether it has-a instance of the product.\n      if isinstance(candidate, Target):\n        <IND>for configuration in candidate.configurations:\n          <IND>yield configuration\n\n    # TODO: returning only the first literal configuration of a given type/variant. Need to\n    # define mergeability for products.\n    <DED><DED><DED>for item in items():\n      <IND>if not isinstance(item, self.product):\n        <IND>continue\n      <DED>if variant_value and not getattr(item, 'name', None) == variant_value:\n        <IND>continue\n      <DED>return item\n    <DED>return None\n\n  <DED>def step(self, dependency_states, node_builder):\n    # Request default Variants for the subject, so that if there are any we can propagate\n    # them to task nodes.\n    <IND>variants = self.variants\n    variants_node = self._variants_node()\n    if variants_node:\n      <IND>dep_state = dependency_states.get(variants_node, None)\n      if dep_state is None or type(dep_state) == Waiting:\n        <IND>return Waiting([variants_node])\n      <DED>elif type(dep_state) == Return:\n        # A subject's variants are overridden by any dependent's requested variants, so\n        # we merge them left to right here.\n        <IND>variants = Variants.merge(dep_state.value.default.items(), variants)\n\n    # If there is a variant_key, see whether it has been configured.\n    <DED><DED>variant_value = None\n    if self.variant_key:\n      <IND>variant_values = [value for key, value in variants\n                        if key == self.variant_key] if variants else None\n      if not variant_values:\n        # Select cannot be satisfied: no variant configured for this key.\n        <IND>return Noop('Variant key {} was not configured in variants {}'.format(\n          self.variant_key, variants))\n      <DED>variant_value = variant_values[0]\n\n    # If the Subject \"is a\" or \"has a\" Product, then we're done.\n    <DED>literal_value = self._select_literal(self.subject, variant_value)\n    if literal_value is not None:\n      <IND>return Return(literal_value)\n\n    # Else, attempt to use a configured task to compute the value.\n    <DED>has_waiting_dep = False\n    dependencies = list(node_builder.task_nodes(self.subject, self.product, variants))\n    matches = {}\n    for dep in dependencies:\n      <IND>dep_state = dependency_states.get(dep, None)\n      if dep_state is None or type(dep_state) == Waiting:\n        <IND>has_waiting_dep = True\n        continue\n      <DED>elif type(dep_state) == Throw:\n        <IND>return dep_state\n      <DED>elif type(dep_state) == Noop:\n        <IND>continue\n      <DED>elif type(dep_state) != Return:\n        <IND>State.raise_unrecognized(dep_state)\n      # We computed a value: see whether we can use it.\n      <DED>literal_value = self._select_literal(dep_state.value, variant_value)\n      if literal_value is not None:\n        <IND>matches[dep] = literal_value\n    <DED><DED>if has_waiting_dep:\n      <IND>return Waiting(dependencies)\n    <DED>elif len(matches) > 1:\n      # TODO: Multiple successful tasks are not currently supported. We should allow for this\n      # by adding support for \"mergeable\" products. see:\n      #   https://github.com/pantsbuild/pants/issues/2526\n      <IND>return Throw(ConflictingProducersError(self.subject, self.product, matches))\n    <DED>elif len(matches) == 1:\n      <IND>return Return(matches.values()[0])\n    <DED>return Noop('No source of {}.'.format(self))\n\n\n<DED><DED>class DependenciesNode(datatype('DependenciesNode', ['subject', 'product', 'variants', 'dep_product']), Node):\n  <IND>\"\"\"A Node that selects the given Product for each of the dependencies of this subject.\n\n  Begins by selecting the `dep_product` for the subject, and then selects a product for each\n  of dep_products' dependencies.\n\n  The value produced by this Node guarantees that the order of the provided values matches the\n  order of declaration in the `dependencies` list of the `dep_product`.\n  \"\"\"\n\n  def _dep_product_node(self):\n    <IND>return SelectNode(self.subject, self.dep_product, self.variants, None)\n\n  <DED>def _dep_node(self, dependency):\n    <IND>variants = self.variants\n    if isinstance(dependency, Address):\n      # If a subject has literal variants for particular dependencies, they win over all else.\n      <IND>dependency, literal_variants = parse_variants(dependency)\n      variants = Variants.merge(variants, literal_variants)\n    <DED>return SelectNode(dependency, self.product, variants, None)\n\n  <DED>def step(self, dependency_states, node_builder):\n    # Request the product we need in order to request dependencies.\n    <IND>dep_product_node = self._dep_product_node()\n    dep_product_state = dependency_states.get(dep_product_node, None)\n    if dep_product_state is None or type(dep_product_state) == Waiting:\n      <IND>return Waiting([dep_product_node])\n    <DED>elif type(dep_product_state) == Throw:\n      <IND>return dep_product_state\n    <DED>elif type(dep_product_state) == Noop:\n      <IND>return Noop('Could not compute {} to determine dependencies.'.format(dep_product_node))\n    <DED>elif type(dep_product_state) != Return:\n      <IND>State.raise_unrecognized(dep_product_state)\n\n    # The product and its dependency list are available.\n    <DED>dep_product = dep_product_state.value\n    dependencies = [self._dep_node(d) for d in dep_product.dependencies]\n    for dependency in dependencies:\n      <IND>dep_state = dependency_states.get(dependency, None)\n      if dep_state is None or type(dep_state) == Waiting:\n        # One of the dependencies is not yet available. Indicate that we are waiting for all\n        # of them.\n        <IND>return Waiting([dep_product_node] + dependencies)\n      <DED>elif type(dep_state) == Throw:\n        <IND>return dep_state\n      <DED>elif type(dep_state) == Noop:\n        <IND>return Throw(ValueError('No source of explicit dependency {}'.format(dependency)))\n      <DED>elif type(dep_state) != Return:\n        <IND>raise State.raise_unrecognized(dep_state)\n    # All dependencies are present! Set our value to a list of the resulting values.\n    <DED><DED>return Return([dependency_states[d].value for d in dependencies])\n\n\n<DED><DED>class TaskNode(datatype('TaskNode', ['subject', 'product', 'variants', 'func', 'clause']), Node):\n\n  <IND>def step(self, dependency_states, node_builder):\n    # Compute dependencies.\n    <IND>dep_values = []\n    dependencies = []\n    for select in self.clause:\n      <IND>dep = select.construct_node(self.subject, self.variants)\n      if dep is None:\n        <IND>return Noop('Dependency {} is not satisfiable.'.format(select))\n      <DED>dependencies.append(dep)\n\n    # If all dependency Nodes are Return, execute the Node.\n    <DED>for dep_select, dep_key in zip(self.clause, dependencies):\n      <IND>dep_state = dependency_states.get(dep_key, None)\n      if dep_state is None or type(dep_state) == Waiting:\n        <IND>return Waiting(dependencies)\n      <DED>elif type(dep_state) == Return:\n        <IND>dep_values.append(dep_state.value)\n      <DED>elif type(dep_state) == Noop:\n        <IND>if dep_select.optional:\n          <IND>dep_values.append(None)\n        <DED>else:\n          <IND>return Noop('Was missing (at least) input {}.'.format(dep_key))\n      <DED><DED>elif type(dep_state) == Throw:\n        <IND>return dep_state\n      <DED>else:\n        <IND>State.raise_unrecognized(dep_state)\n    <DED><DED>try:\n      <IND>return Return(self.func(*dep_values))\n    <DED>except Exception as e:\n      <IND>return Throw(e)\n\n\n<DED><DED><DED>class ProductGraph(object):\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n<DED><DED>class ProductGraph(object):\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "pantsbuild/pants",
    "commit": "08bc2add6e98feefdce36f6f094a15e3e598b1e7",
    "filename": "src/python/pants/engine/exp/scheduler.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/pantsbuild-pants/src/python/pants/engine/exp/scheduler.py",
    "file_hunks_size": 13,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "src/python/pants/engine/exp/scheduler.py:94:20 Invalid type [31]: Expression `pants.util.objects.datatype(\"Literal\", [\"subject\", \"product\"])` is not a valid type.",
    "message": " Expression `pants.util.objects.datatype(\"Literal\", [\"subject\", \"product\"])` is not a valid type.",
    "rule_id": "Invalid type [31]",
    "warning_line_no": 94,
    "warning_line": "class SelectLiteral(datatype('Literal', ['subject', 'product']), Selector):",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\nclass Selector(AbstractClass):\n  @abstractproperty\n  def optional(self):\n    \"\"\"Return true if this Selector is optional. It may result in a `None` match.\"\"\"\n\n  @abstractmethod\n  def construct_node(self, subject, variants):\n    \"\"\"Constructs a Node for this Selector and the given Subject/Variants.\n\n    May return None if the Selector can be known statically to not be satisfiable for the inputs.\n    \"\"\"\n\n\nclass Select(datatype('Subject', ['product', 'optional']), Selector):\n  \"\"\"Selects the given Product for the Subject provided to the constructor.\n\n  If optional=True and no matching product can be produced, will return None.\n  \"\"\"\n\n  def __new__(self, product, optional=False):\n    return super(Select, self).__new__(self, product, optional)\n\n  def construct_node(self, subject, variants):\n    return SelectNode(subject, self.product, variants, None)\n\n\nclass SelectVariant(datatype('Variant', ['product', 'variant_key']), Selector):\n  \"\"\"Selects the matching Product and variant name for the Subject provided to the constructor.\n\n  For example: a SelectVariant with a variant_key of \"thrift\" and a product of type ApacheThrift\n  will only match when a consumer passes a variant value for \"thrift\" that matches the name of an\n  ApacheThrift value.\n  \"\"\"\n  optional = False\n\n  def construct_node(self, subject, variants):\n    return SelectNode(subject, self.product, variants, self.variant_key)\n\n\nclass SelectDependencies(datatype('Dependencies', ['product', 'deps_product']), Selector):\n  \"\"\"Selects a product for each of the dependencies of a product for the Subject.\n\n  The dependencies declared on `deps_product` will be provided to the requesting task\n  in the order they were declared.\n  \"\"\"\n  optional = False\n\n  def construct_node(self, subject, variants):\n    return DependenciesNode(subject, self.product, variants, self.deps_product)\n\n\nclass SelectProjection(datatype('Projection', ['product', 'projected_product', 'fields', 'input_product']), Selector):\n  \"\"\"Selects a field of the given Subject to produce a Subject, Product dependency from.\n\n  Projecting an input allows for deduplication in the graph, where multiple Subjects\n  resolve to a single backing Subject instead.\n  \"\"\"\n  optional = False\n\n  def construct_node(self, subject, variants):\n    # Input product type doesn't match: not satisfiable.\n    if not type(subject) == self.input_product:\n      return None\n\n    # Find the fields of the Subject to project.\n    values = []\n    for field in self.fields:\n      values.append(getattr(subject, field))\n    projected_subject = self.projected_product(*values)\n    return SelectNode(projected_subject, self.product, variants, None)\n\n\nclass SelectLiteral(datatype('Literal', ['subject', 'product']), Selector):\n  \"\"\"Selects a literal Subject (other than the one applied to the selector).\"\"\"\n  optional = False\n\n  def construct_node(self, subject, variants):\n    # NB: Intentionally ignores subject parameter to provide a literal subject.\n    return SelectNode(self.subject, self.product, variants, None)\n\n\nclass SchedulingError(Exception):\n  \"\"\"Indicates inability to make a scheduling promise.\"\"\"\n\n\nclass PartiallyConsumedInputsError(SchedulingError):\n  \"\"\"No task was able to consume a particular literal product for a subject, although some tried.\n",
        "source_code_len": 3277,
        "target_code": "\nclass PartiallyConsumedInputsError(Exception):\n  \"\"\"No task was able to consume a particular literal product for a subject, although some tried.\n",
        "target_code_len": 146,
        "diff_format": "@@ -21,88 +20,3 @@\n \n-class Selector(AbstractClass):\n-  @abstractproperty\n-  def optional(self):\n-    \"\"\"Return true if this Selector is optional. It may result in a `None` match.\"\"\"\n-\n-  @abstractmethod\n-  def construct_node(self, subject, variants):\n-    \"\"\"Constructs a Node for this Selector and the given Subject/Variants.\n-\n-    May return None if the Selector can be known statically to not be satisfiable for the inputs.\n-    \"\"\"\n-\n-\n-class Select(datatype('Subject', ['product', 'optional']), Selector):\n-  \"\"\"Selects the given Product for the Subject provided to the constructor.\n-\n-  If optional=True and no matching product can be produced, will return None.\n-  \"\"\"\n-\n-  def __new__(self, product, optional=False):\n-    return super(Select, self).__new__(self, product, optional)\n-\n-  def construct_node(self, subject, variants):\n-    return SelectNode(subject, self.product, variants, None)\n-\n-\n-class SelectVariant(datatype('Variant', ['product', 'variant_key']), Selector):\n-  \"\"\"Selects the matching Product and variant name for the Subject provided to the constructor.\n-\n-  For example: a SelectVariant with a variant_key of \"thrift\" and a product of type ApacheThrift\n-  will only match when a consumer passes a variant value for \"thrift\" that matches the name of an\n-  ApacheThrift value.\n-  \"\"\"\n-  optional = False\n-\n-  def construct_node(self, subject, variants):\n-    return SelectNode(subject, self.product, variants, self.variant_key)\n-\n-\n-class SelectDependencies(datatype('Dependencies', ['product', 'deps_product']), Selector):\n-  \"\"\"Selects a product for each of the dependencies of a product for the Subject.\n-\n-  The dependencies declared on `deps_product` will be provided to the requesting task\n-  in the order they were declared.\n-  \"\"\"\n-  optional = False\n-\n-  def construct_node(self, subject, variants):\n-    return DependenciesNode(subject, self.product, variants, self.deps_product)\n-\n-\n-class SelectProjection(datatype('Projection', ['product', 'projected_product', 'fields', 'input_product']), Selector):\n-  \"\"\"Selects a field of the given Subject to produce a Subject, Product dependency from.\n-\n-  Projecting an input allows for deduplication in the graph, where multiple Subjects\n-  resolve to a single backing Subject instead.\n-  \"\"\"\n-  optional = False\n-\n-  def construct_node(self, subject, variants):\n-    # Input product type doesn't match: not satisfiable.\n-    if not type(subject) == self.input_product:\n-      return None\n-\n-    # Find the fields of the Subject to project.\n-    values = []\n-    for field in self.fields:\n-      values.append(getattr(subject, field))\n-    projected_subject = self.projected_product(*values)\n-    return SelectNode(projected_subject, self.product, variants, None)\n-\n-\n-class SelectLiteral(datatype('Literal', ['subject', 'product']), Selector):\n-  \"\"\"Selects a literal Subject (other than the one applied to the selector).\"\"\"\n-  optional = False\n-\n-  def construct_node(self, subject, variants):\n-    # NB: Intentionally ignores subject parameter to provide a literal subject.\n-    return SelectNode(self.subject, self.product, variants, None)\n-\n-\n-class SchedulingError(Exception):\n-  \"\"\"Indicates inability to make a scheduling promise.\"\"\"\n-\n-\n-class PartiallyConsumedInputsError(SchedulingError):\n+class PartiallyConsumedInputsError(Exception):\n   \"\"\"No task was able to consume a particular literal product for a subject, although some tried.\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\nclass Selector(AbstractClass):\n  <IND>@abstractproperty\n  def optional(self):\n    <IND>\"\"\"Return true if this Selector is optional. It may result in a `None` match.\"\"\"\n\n  <DED>@abstractmethod\n  def construct_node(self, subject, variants):\n    <IND>\"\"\"Constructs a Node for this Selector and the given Subject/Variants.\n\n    May return None if the Selector can be known statically to not be satisfiable for the inputs.\n    \"\"\"\n\n\n<DED><DED>class Select(datatype('Subject', ['product', 'optional']), Selector):\n  <IND>\"\"\"Selects the given Product for the Subject provided to the constructor.\n\n  If optional=True and no matching product can be produced, will return None.\n  \"\"\"\n\n  def __new__(self, product, optional=False):\n    <IND>return super(Select, self).__new__(self, product, optional)\n\n  <DED>def construct_node(self, subject, variants):\n    <IND>return SelectNode(subject, self.product, variants, None)\n\n\n<DED><DED>class SelectVariant(datatype('Variant', ['product', 'variant_key']), Selector):\n  <IND>\"\"\"Selects the matching Product and variant name for the Subject provided to the constructor.\n\n  For example: a SelectVariant with a variant_key of \"thrift\" and a product of type ApacheThrift\n  will only match when a consumer passes a variant value for \"thrift\" that matches the name of an\n  ApacheThrift value.\n  \"\"\"\n  optional = False\n\n  def construct_node(self, subject, variants):\n    <IND>return SelectNode(subject, self.product, variants, self.variant_key)\n\n\n<DED><DED>class SelectDependencies(datatype('Dependencies', ['product', 'deps_product']), Selector):\n  <IND>\"\"\"Selects a product for each of the dependencies of a product for the Subject.\n\n  The dependencies declared on `deps_product` will be provided to the requesting task\n  in the order they were declared.\n  \"\"\"\n  optional = False\n\n  def construct_node(self, subject, variants):\n    <IND>return DependenciesNode(subject, self.product, variants, self.deps_product)\n\n\n<DED><DED>class SelectProjection(datatype('Projection', ['product', 'projected_product', 'fields', 'input_product']), Selector):\n  <IND>\"\"\"Selects a field of the given Subject to produce a Subject, Product dependency from.\n\n  Projecting an input allows for deduplication in the graph, where multiple Subjects\n  resolve to a single backing Subject instead.\n  \"\"\"\n  optional = False\n\n  def construct_node(self, subject, variants):\n    # Input product type doesn't match: not satisfiable.\n    <IND>if not type(subject) == self.input_product:\n      <IND>return None\n\n    # Find the fields of the Subject to project.\n    <DED>values = []\n    for field in self.fields:\n      <IND>values.append(getattr(subject, field))\n    <DED>projected_subject = self.projected_product(*values)\n    return SelectNode(projected_subject, self.product, variants, None)\n\n\n<DED><DED>class SelectLiteral(datatype('Literal', ['subject', 'product']), Selector):\n  <IND>\"\"\"Selects a literal Subject (other than the one applied to the selector).\"\"\"\n  optional = False\n\n  def construct_node(self, subject, variants):\n    # NB: Intentionally ignores subject parameter to provide a literal subject.\n    <IND>return SelectNode(self.subject, self.product, variants, None)\n\n\n<DED><DED>class SchedulingError(Exception):\n  <IND>\"\"\"Indicates inability to make a scheduling promise.\"\"\"\n\n\n<DED>class PartiallyConsumedInputsError(SchedulingError):\n  <IND>",
        "target_code_with_indent": "\nclass PartiallyConsumedInputsError(Exception):\n  <IND>"
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": true,
        "has_suppression": false,
        "source_code": "\nclass ConflictingProducersError(SchedulingError):\n  \"\"\"Indicates that there was more than one source of a product for a given subject.\n\n  TODO: This will need to be legal in order to support multiple Planners producing a\n  (mergeable) Classpath for one subject, for example. see:\n    https://github.com/pantsbuild/pants/issues/2526\n  \"\"\"\n\n  def __init__(self, subject, product, matches):\n    msgs = '\\n  '.join('{}: {}'.format(k, v) for k, v in matches.items())\n    msg = 'More than one source of {} for {}:\\n  {}'.format(product.__name__, subject, msgs)\n    super(ConflictingProducersError, self).__init__(msg)\n\n\nclass State(object):\n  @classmethod\n  def raise_unrecognized(cls, state):\n    raise ValueError('Unrecognized Node State: {}'.format(state))\n\n\nclass Noop(datatype('Noop', ['msg']), State):\n  \"\"\"Indicates that a Node did not have the inputs which would be needed for it to execute.\"\"\"\n  pass\n\n\nclass Return(datatype('Return', ['value']), State):\n  \"\"\"Indicates that a Node successfully returned a value.\"\"\"\n  pass\n\n\nclass Throw(datatype('Throw', ['exc']), State):\n  \"\"\"Indicates that a Node should have been able to return a value, but failed.\"\"\"\n  pass\n\n\nclass Waiting(datatype('Waiting', ['dependencies']), State):\n  \"\"\"Indicates that a Node is waiting for some/all of the dependencies to become available.\n\n  Some Nodes will return different dependency Nodes based on where they are in their lifecycle,\n  but all returned dependencies are recorded for the lifetime of a ProductGraph.\n  \"\"\"\n  pass\n\n\nclass Node(object):\n  @abstractproperty\n  def subject(self):\n    \"\"\"The subject for this Node.\"\"\"\n\n  @abstractproperty\n  def product(self):\n    \"\"\"The output product for this Node.\"\"\"\n\n  @abstractproperty\n  def variants(self):\n    \"\"\"The variants for this Node.\"\"\"\n\n  @abstractmethod\n  def step(self, dependency_states, node_builder):\n    \"\"\"Given a dict of the dependency States for this Node, returns the current State of the Node.\n\n    The NodeBuilder parameter provides a way to construct Nodes that require information about\n    installed tasks.\n\n    After this method returns a non-Waiting state, it will never be visited again for this Node.\n    \"\"\"\n\n\nclass SelectNode(datatype('SelectNode', ['subject', 'product', 'variants', 'variant_key']), Node):\n  \"\"\"A Node that selects a product for a subject.\n\n  A Select can be satisfied by multiple sources, but fails if multiple sources produce a value. The\n  'variants' field represents variant configuration that is propagated to dependencies. When\n  a task needs to consume a product as configured by the variants map, it uses the SelectVariant\n  selector, which introduces the 'variant' value to restrict the names of values selected by a\n  SelectNode.\n  \"\"\"\n\n  def _variants_node(self):\n    if self.product != Variants:\n      return SelectNode(self.subject, Variants, self.variants, None)\n    return None\n\n  def _select_literal(self, candidate, variant_value):\n    \"\"\"Looks for has-a or is-a relationships between the given value and the requested product.\n\n    Returns the resulting product value, or None if no match was made.\n    \"\"\"\n    def items():\n      # Check whether the subject is-a instance of the product.\n      yield candidate\n      # Else, check whether it has-a instance of the product.\n      if isinstance(candidate, Target):\n        for configuration in candidate.configurations:\n          yield configuration\n\n    # TODO: returning only the first literal configuration of a given type/variant. Need to\n    # define mergeability for products.\n    for item in items():\n      if not isinstance(item, self.product):\n        continue\n      if variant_value and not getattr(item, 'name', None) == variant_value:\n        continue\n      return item\n    return None\n\n  def step(self, dependency_states, node_builder):\n    # Request default Variants for the subject, so that if there are any we can propagate\n    # them to task nodes.\n    variants = self.variants\n    variants_node = self._variants_node()\n    if variants_node:\n      dep_state = dependency_states.get(variants_node, None)\n      if dep_state is None or type(dep_state) == Waiting:\n        return Waiting([variants_node])\n      elif type(dep_state) == Return:\n        # A subject's variants are overridden by any dependent's requested variants, so\n        # we merge them left to right here.\n        variants = Variants.merge(dep_state.value.default.items(), variants)\n\n    # If there is a variant_key, see whether it has been configured.\n    variant_value = None\n    if self.variant_key:\n      variant_values = [value for key, value in variants\n                        if key == self.variant_key] if variants else None\n      if not variant_values:\n        # Select cannot be satisfied: no variant configured for this key.\n        return Noop('Variant key {} was not configured in variants {}'.format(\n          self.variant_key, variants))\n      variant_value = variant_values[0]\n\n    # If the Subject \"is a\" or \"has a\" Product, then we're done.\n    literal_value = self._select_literal(self.subject, variant_value)\n    if literal_value is not None:\n      return Return(literal_value)\n\n    # Else, attempt to use a configured task to compute the value.\n    has_waiting_dep = False\n    dependencies = list(node_builder.task_nodes(self.subject, self.product, variants))\n    matches = {}\n    for dep in dependencies:\n      dep_state = dependency_states.get(dep, None)\n      if dep_state is None or type(dep_state) == Waiting:\n        has_waiting_dep = True\n        continue\n      elif type(dep_state) == Throw:\n        return dep_state\n      elif type(dep_state) == Noop:\n        continue\n      elif type(dep_state) != Return:\n        State.raise_unrecognized(dep_state)\n      # We computed a value: see whether we can use it.\n      literal_value = self._select_literal(dep_state.value, variant_value)\n      if literal_value is not None:\n        matches[dep] = literal_value\n    if has_waiting_dep:\n      return Waiting(dependencies)\n    elif len(matches) > 1:\n      # TODO: Multiple successful tasks are not currently supported. We should allow for this\n      # by adding support for \"mergeable\" products. see:\n      #   https://github.com/pantsbuild/pants/issues/2526\n      return Throw(ConflictingProducersError(self.subject, self.product, matches))\n    elif len(matches) == 1:\n      return Return(matches.values()[0])\n    return Noop('No source of {}.'.format(self))\n\n\nclass DependenciesNode(datatype('DependenciesNode', ['subject', 'product', 'variants', 'dep_product']), Node):\n  \"\"\"A Node that selects the given Product for each of the dependencies of this subject.\n\n  Begins by selecting the `dep_product` for the subject, and then selects a product for each\n  of dep_products' dependencies.\n\n  The value produced by this Node guarantees that the order of the provided values matches the\n  order of declaration in the `dependencies` list of the `dep_product`.\n  \"\"\"\n\n  def _dep_product_node(self):\n    return SelectNode(self.subject, self.dep_product, self.variants, None)\n\n  def _dep_node(self, dependency):\n    variants = self.variants\n    if isinstance(dependency, Address):\n      # If a subject has literal variants for particular dependencies, they win over all else.\n      dependency, literal_variants = parse_variants(dependency)\n      variants = Variants.merge(variants, literal_variants)\n    return SelectNode(dependency, self.product, variants, None)\n\n  def step(self, dependency_states, node_builder):\n    # Request the product we need in order to request dependencies.\n    dep_product_node = self._dep_product_node()\n    dep_product_state = dependency_states.get(dep_product_node, None)\n    if dep_product_state is None or type(dep_product_state) == Waiting:\n      return Waiting([dep_product_node])\n    elif type(dep_product_state) == Throw:\n      return dep_product_state\n    elif type(dep_product_state) == Noop:\n      return Noop('Could not compute {} to determine dependencies.'.format(dep_product_node))\n    elif type(dep_product_state) != Return:\n      State.raise_unrecognized(dep_product_state)\n\n    # The product and its dependency list are available.\n    dep_product = dep_product_state.value\n    dependencies = [self._dep_node(d) for d in dep_product.dependencies]\n    for dependency in dependencies:\n      dep_state = dependency_states.get(dependency, None)\n      if dep_state is None or type(dep_state) == Waiting:\n        # One of the dependencies is not yet available. Indicate that we are waiting for all\n        # of them.\n        return Waiting([dep_product_node] + dependencies)\n      elif type(dep_state) == Throw:\n        return dep_state\n      elif type(dep_state) == Noop:\n        return Throw(ValueError('No source of explicit dependency {}'.format(dependency)))\n      elif type(dep_state) != Return:\n        raise State.raise_unrecognized(dep_state)\n    # All dependencies are present! Set our value to a list of the resulting values.\n    return Return([dependency_states[d].value for d in dependencies])\n\n\nclass TaskNode(datatype('TaskNode', ['subject', 'product', 'variants', 'func', 'clause']), Node):\n\n  def step(self, dependency_states, node_builder):\n    # Compute dependencies.\n    dep_values = []\n    dependencies = []\n    for select in self.clause:\n      dep = select.construct_node(self.subject, self.variants)\n      if dep is None:\n        return Noop('Dependency {} is not satisfiable.'.format(select))\n      dependencies.append(dep)\n\n    # If all dependency Nodes are Return, execute the Node.\n    for dep_select, dep_key in zip(self.clause, dependencies):\n      dep_state = dependency_states.get(dep_key, None)\n      if dep_state is None or type(dep_state) == Waiting:\n        return Waiting(dependencies)\n      elif type(dep_state) == Return:\n        dep_values.append(dep_state.value)\n      elif type(dep_state) == Noop:\n        if dep_select.optional:\n          dep_values.append(None)\n        else:\n          return Noop('Was missing (at least) input {}.'.format(dep_key))\n      elif type(dep_state) == Throw:\n        return dep_state\n      else:\n        State.raise_unrecognized(dep_state)\n    try:\n      return Return(self.func(*dep_values))\n    except Exception as e:\n      return Throw(e)\n\n\nclass ProductGraph(object):\n",
        "source_code_len": 10229,
        "target_code": "\nclass ProductGraph(object):\n",
        "target_code_len": 29,
        "diff_format": "@@ -134,256 +48,2 @@\n \n-class ConflictingProducersError(SchedulingError):\n-  \"\"\"Indicates that there was more than one source of a product for a given subject.\n-\n-  TODO: This will need to be legal in order to support multiple Planners producing a\n-  (mergeable) Classpath for one subject, for example. see:\n-    https://github.com/pantsbuild/pants/issues/2526\n-  \"\"\"\n-\n-  def __init__(self, subject, product, matches):\n-    msgs = '\\n  '.join('{}: {}'.format(k, v) for k, v in matches.items())\n-    msg = 'More than one source of {} for {}:\\n  {}'.format(product.__name__, subject, msgs)\n-    super(ConflictingProducersError, self).__init__(msg)\n-\n-\n-class State(object):\n-  @classmethod\n-  def raise_unrecognized(cls, state):\n-    raise ValueError('Unrecognized Node State: {}'.format(state))\n-\n-\n-class Noop(datatype('Noop', ['msg']), State):\n-  \"\"\"Indicates that a Node did not have the inputs which would be needed for it to execute.\"\"\"\n-  pass\n-\n-\n-class Return(datatype('Return', ['value']), State):\n-  \"\"\"Indicates that a Node successfully returned a value.\"\"\"\n-  pass\n-\n-\n-class Throw(datatype('Throw', ['exc']), State):\n-  \"\"\"Indicates that a Node should have been able to return a value, but failed.\"\"\"\n-  pass\n-\n-\n-class Waiting(datatype('Waiting', ['dependencies']), State):\n-  \"\"\"Indicates that a Node is waiting for some/all of the dependencies to become available.\n-\n-  Some Nodes will return different dependency Nodes based on where they are in their lifecycle,\n-  but all returned dependencies are recorded for the lifetime of a ProductGraph.\n-  \"\"\"\n-  pass\n-\n-\n-class Node(object):\n-  @abstractproperty\n-  def subject(self):\n-    \"\"\"The subject for this Node.\"\"\"\n-\n-  @abstractproperty\n-  def product(self):\n-    \"\"\"The output product for this Node.\"\"\"\n-\n-  @abstractproperty\n-  def variants(self):\n-    \"\"\"The variants for this Node.\"\"\"\n-\n-  @abstractmethod\n-  def step(self, dependency_states, node_builder):\n-    \"\"\"Given a dict of the dependency States for this Node, returns the current State of the Node.\n-\n-    The NodeBuilder parameter provides a way to construct Nodes that require information about\n-    installed tasks.\n-\n-    After this method returns a non-Waiting state, it will never be visited again for this Node.\n-    \"\"\"\n-\n-\n-class SelectNode(datatype('SelectNode', ['subject', 'product', 'variants', 'variant_key']), Node):\n-  \"\"\"A Node that selects a product for a subject.\n-\n-  A Select can be satisfied by multiple sources, but fails if multiple sources produce a value. The\n-  'variants' field represents variant configuration that is propagated to dependencies. When\n-  a task needs to consume a product as configured by the variants map, it uses the SelectVariant\n-  selector, which introduces the 'variant' value to restrict the names of values selected by a\n-  SelectNode.\n-  \"\"\"\n-\n-  def _variants_node(self):\n-    if self.product != Variants:\n-      return SelectNode(self.subject, Variants, self.variants, None)\n-    return None\n-\n-  def _select_literal(self, candidate, variant_value):\n-    \"\"\"Looks for has-a or is-a relationships between the given value and the requested product.\n-\n-    Returns the resulting product value, or None if no match was made.\n-    \"\"\"\n-    def items():\n-      # Check whether the subject is-a instance of the product.\n-      yield candidate\n-      # Else, check whether it has-a instance of the product.\n-      if isinstance(candidate, Target):\n-        for configuration in candidate.configurations:\n-          yield configuration\n-\n-    # TODO: returning only the first literal configuration of a given type/variant. Need to\n-    # define mergeability for products.\n-    for item in items():\n-      if not isinstance(item, self.product):\n-        continue\n-      if variant_value and not getattr(item, 'name', None) == variant_value:\n-        continue\n-      return item\n-    return None\n-\n-  def step(self, dependency_states, node_builder):\n-    # Request default Variants for the subject, so that if there are any we can propagate\n-    # them to task nodes.\n-    variants = self.variants\n-    variants_node = self._variants_node()\n-    if variants_node:\n-      dep_state = dependency_states.get(variants_node, None)\n-      if dep_state is None or type(dep_state) == Waiting:\n-        return Waiting([variants_node])\n-      elif type(dep_state) == Return:\n-        # A subject's variants are overridden by any dependent's requested variants, so\n-        # we merge them left to right here.\n-        variants = Variants.merge(dep_state.value.default.items(), variants)\n-\n-    # If there is a variant_key, see whether it has been configured.\n-    variant_value = None\n-    if self.variant_key:\n-      variant_values = [value for key, value in variants\n-                        if key == self.variant_key] if variants else None\n-      if not variant_values:\n-        # Select cannot be satisfied: no variant configured for this key.\n-        return Noop('Variant key {} was not configured in variants {}'.format(\n-          self.variant_key, variants))\n-      variant_value = variant_values[0]\n-\n-    # If the Subject \"is a\" or \"has a\" Product, then we're done.\n-    literal_value = self._select_literal(self.subject, variant_value)\n-    if literal_value is not None:\n-      return Return(literal_value)\n-\n-    # Else, attempt to use a configured task to compute the value.\n-    has_waiting_dep = False\n-    dependencies = list(node_builder.task_nodes(self.subject, self.product, variants))\n-    matches = {}\n-    for dep in dependencies:\n-      dep_state = dependency_states.get(dep, None)\n-      if dep_state is None or type(dep_state) == Waiting:\n-        has_waiting_dep = True\n-        continue\n-      elif type(dep_state) == Throw:\n-        return dep_state\n-      elif type(dep_state) == Noop:\n-        continue\n-      elif type(dep_state) != Return:\n-        State.raise_unrecognized(dep_state)\n-      # We computed a value: see whether we can use it.\n-      literal_value = self._select_literal(dep_state.value, variant_value)\n-      if literal_value is not None:\n-        matches[dep] = literal_value\n-    if has_waiting_dep:\n-      return Waiting(dependencies)\n-    elif len(matches) > 1:\n-      # TODO: Multiple successful tasks are not currently supported. We should allow for this\n-      # by adding support for \"mergeable\" products. see:\n-      #   https://github.com/pantsbuild/pants/issues/2526\n-      return Throw(ConflictingProducersError(self.subject, self.product, matches))\n-    elif len(matches) == 1:\n-      return Return(matches.values()[0])\n-    return Noop('No source of {}.'.format(self))\n-\n-\n-class DependenciesNode(datatype('DependenciesNode', ['subject', 'product', 'variants', 'dep_product']), Node):\n-  \"\"\"A Node that selects the given Product for each of the dependencies of this subject.\n-\n-  Begins by selecting the `dep_product` for the subject, and then selects a product for each\n-  of dep_products' dependencies.\n-\n-  The value produced by this Node guarantees that the order of the provided values matches the\n-  order of declaration in the `dependencies` list of the `dep_product`.\n-  \"\"\"\n-\n-  def _dep_product_node(self):\n-    return SelectNode(self.subject, self.dep_product, self.variants, None)\n-\n-  def _dep_node(self, dependency):\n-    variants = self.variants\n-    if isinstance(dependency, Address):\n-      # If a subject has literal variants for particular dependencies, they win over all else.\n-      dependency, literal_variants = parse_variants(dependency)\n-      variants = Variants.merge(variants, literal_variants)\n-    return SelectNode(dependency, self.product, variants, None)\n-\n-  def step(self, dependency_states, node_builder):\n-    # Request the product we need in order to request dependencies.\n-    dep_product_node = self._dep_product_node()\n-    dep_product_state = dependency_states.get(dep_product_node, None)\n-    if dep_product_state is None or type(dep_product_state) == Waiting:\n-      return Waiting([dep_product_node])\n-    elif type(dep_product_state) == Throw:\n-      return dep_product_state\n-    elif type(dep_product_state) == Noop:\n-      return Noop('Could not compute {} to determine dependencies.'.format(dep_product_node))\n-    elif type(dep_product_state) != Return:\n-      State.raise_unrecognized(dep_product_state)\n-\n-    # The product and its dependency list are available.\n-    dep_product = dep_product_state.value\n-    dependencies = [self._dep_node(d) for d in dep_product.dependencies]\n-    for dependency in dependencies:\n-      dep_state = dependency_states.get(dependency, None)\n-      if dep_state is None or type(dep_state) == Waiting:\n-        # One of the dependencies is not yet available. Indicate that we are waiting for all\n-        # of them.\n-        return Waiting([dep_product_node] + dependencies)\n-      elif type(dep_state) == Throw:\n-        return dep_state\n-      elif type(dep_state) == Noop:\n-        return Throw(ValueError('No source of explicit dependency {}'.format(dependency)))\n-      elif type(dep_state) != Return:\n-        raise State.raise_unrecognized(dep_state)\n-    # All dependencies are present! Set our value to a list of the resulting values.\n-    return Return([dependency_states[d].value for d in dependencies])\n-\n-\n-class TaskNode(datatype('TaskNode', ['subject', 'product', 'variants', 'func', 'clause']), Node):\n-\n-  def step(self, dependency_states, node_builder):\n-    # Compute dependencies.\n-    dep_values = []\n-    dependencies = []\n-    for select in self.clause:\n-      dep = select.construct_node(self.subject, self.variants)\n-      if dep is None:\n-        return Noop('Dependency {} is not satisfiable.'.format(select))\n-      dependencies.append(dep)\n-\n-    # If all dependency Nodes are Return, execute the Node.\n-    for dep_select, dep_key in zip(self.clause, dependencies):\n-      dep_state = dependency_states.get(dep_key, None)\n-      if dep_state is None or type(dep_state) == Waiting:\n-        return Waiting(dependencies)\n-      elif type(dep_state) == Return:\n-        dep_values.append(dep_state.value)\n-      elif type(dep_state) == Noop:\n-        if dep_select.optional:\n-          dep_values.append(None)\n-        else:\n-          return Noop('Was missing (at least) input {}.'.format(dep_key))\n-      elif type(dep_state) == Throw:\n-        return dep_state\n-      else:\n-        State.raise_unrecognized(dep_state)\n-    try:\n-      return Return(self.func(*dep_values))\n-    except Exception as e:\n-      return Throw(e)\n-\n-\n class ProductGraph(object):\n",
        "source_code_with_indent": "\n<DED><DED>class ConflictingProducersError(SchedulingError):\n  <IND>\"\"\"Indicates that there was more than one source of a product for a given subject.\n\n  TODO: This will need to be legal in order to support multiple Planners producing a\n  (mergeable) Classpath for one subject, for example. see:\n    https://github.com/pantsbuild/pants/issues/2526\n  \"\"\"\n\n  def __init__(self, subject, product, matches):\n    <IND>msgs = '\\n  '.join('{}: {}'.format(k, v) for k, v in matches.items())\n    msg = 'More than one source of {} for {}:\\n  {}'.format(product.__name__, subject, msgs)\n    super(ConflictingProducersError, self).__init__(msg)\n\n\n<DED><DED>class State(object):\n  <IND>@classmethod\n  def raise_unrecognized(cls, state):\n    <IND>raise ValueError('Unrecognized Node State: {}'.format(state))\n\n\n<DED><DED>class Noop(datatype('Noop', ['msg']), State):\n  <IND>\"\"\"Indicates that a Node did not have the inputs which would be needed for it to execute.\"\"\"\n  pass\n\n\n<DED>class Return(datatype('Return', ['value']), State):\n  <IND>\"\"\"Indicates that a Node successfully returned a value.\"\"\"\n  pass\n\n\n<DED>class Throw(datatype('Throw', ['exc']), State):\n  <IND>\"\"\"Indicates that a Node should have been able to return a value, but failed.\"\"\"\n  pass\n\n\n<DED>class Waiting(datatype('Waiting', ['dependencies']), State):\n  <IND>\"\"\"Indicates that a Node is waiting for some/all of the dependencies to become available.\n\n  Some Nodes will return different dependency Nodes based on where they are in their lifecycle,\n  but all returned dependencies are recorded for the lifetime of a ProductGraph.\n  \"\"\"\n  pass\n\n\n<DED>class Node(object):\n  <IND>@abstractproperty\n  def subject(self):\n    <IND>\"\"\"The subject for this Node.\"\"\"\n\n  <DED>@abstractproperty\n  def product(self):\n    <IND>\"\"\"The output product for this Node.\"\"\"\n\n  <DED>@abstractproperty\n  def variants(self):\n    <IND>\"\"\"The variants for this Node.\"\"\"\n\n  <DED>@abstractmethod\n  def step(self, dependency_states, node_builder):\n    <IND>\"\"\"Given a dict of the dependency States for this Node, returns the current State of the Node.\n\n    The NodeBuilder parameter provides a way to construct Nodes that require information about\n    installed tasks.\n\n    After this method returns a non-Waiting state, it will never be visited again for this Node.\n    \"\"\"\n\n\n<DED><DED>class SelectNode(datatype('SelectNode', ['subject', 'product', 'variants', 'variant_key']), Node):\n  <IND>\"\"\"A Node that selects a product for a subject.\n\n  A Select can be satisfied by multiple sources, but fails if multiple sources produce a value. The\n  'variants' field represents variant configuration that is propagated to dependencies. When\n  a task needs to consume a product as configured by the variants map, it uses the SelectVariant\n  selector, which introduces the 'variant' value to restrict the names of values selected by a\n  SelectNode.\n  \"\"\"\n\n  def _variants_node(self):\n    <IND>if self.product != Variants:\n      <IND>return SelectNode(self.subject, Variants, self.variants, None)\n    <DED>return None\n\n  <DED>def _select_literal(self, candidate, variant_value):\n    <IND>\"\"\"Looks for has-a or is-a relationships between the given value and the requested product.\n\n    Returns the resulting product value, or None if no match was made.\n    \"\"\"\n    def items():\n      # Check whether the subject is-a instance of the product.\n      <IND>yield candidate\n      # Else, check whether it has-a instance of the product.\n      if isinstance(candidate, Target):\n        <IND>for configuration in candidate.configurations:\n          <IND>yield configuration\n\n    # TODO: returning only the first literal configuration of a given type/variant. Need to\n    # define mergeability for products.\n    <DED><DED><DED>for item in items():\n      <IND>if not isinstance(item, self.product):\n        <IND>continue\n      <DED>if variant_value and not getattr(item, 'name', None) == variant_value:\n        <IND>continue\n      <DED>return item\n    <DED>return None\n\n  <DED>def step(self, dependency_states, node_builder):\n    # Request default Variants for the subject, so that if there are any we can propagate\n    # them to task nodes.\n    <IND>variants = self.variants\n    variants_node = self._variants_node()\n    if variants_node:\n      <IND>dep_state = dependency_states.get(variants_node, None)\n      if dep_state is None or type(dep_state) == Waiting:\n        <IND>return Waiting([variants_node])\n      <DED>elif type(dep_state) == Return:\n        # A subject's variants are overridden by any dependent's requested variants, so\n        # we merge them left to right here.\n        <IND>variants = Variants.merge(dep_state.value.default.items(), variants)\n\n    # If there is a variant_key, see whether it has been configured.\n    <DED><DED>variant_value = None\n    if self.variant_key:\n      <IND>variant_values = [value for key, value in variants\n                        if key == self.variant_key] if variants else None\n      if not variant_values:\n        # Select cannot be satisfied: no variant configured for this key.\n        <IND>return Noop('Variant key {} was not configured in variants {}'.format(\n          self.variant_key, variants))\n      <DED>variant_value = variant_values[0]\n\n    # If the Subject \"is a\" or \"has a\" Product, then we're done.\n    <DED>literal_value = self._select_literal(self.subject, variant_value)\n    if literal_value is not None:\n      <IND>return Return(literal_value)\n\n    # Else, attempt to use a configured task to compute the value.\n    <DED>has_waiting_dep = False\n    dependencies = list(node_builder.task_nodes(self.subject, self.product, variants))\n    matches = {}\n    for dep in dependencies:\n      <IND>dep_state = dependency_states.get(dep, None)\n      if dep_state is None or type(dep_state) == Waiting:\n        <IND>has_waiting_dep = True\n        continue\n      <DED>elif type(dep_state) == Throw:\n        <IND>return dep_state\n      <DED>elif type(dep_state) == Noop:\n        <IND>continue\n      <DED>elif type(dep_state) != Return:\n        <IND>State.raise_unrecognized(dep_state)\n      # We computed a value: see whether we can use it.\n      <DED>literal_value = self._select_literal(dep_state.value, variant_value)\n      if literal_value is not None:\n        <IND>matches[dep] = literal_value\n    <DED><DED>if has_waiting_dep:\n      <IND>return Waiting(dependencies)\n    <DED>elif len(matches) > 1:\n      # TODO: Multiple successful tasks are not currently supported. We should allow for this\n      # by adding support for \"mergeable\" products. see:\n      #   https://github.com/pantsbuild/pants/issues/2526\n      <IND>return Throw(ConflictingProducersError(self.subject, self.product, matches))\n    <DED>elif len(matches) == 1:\n      <IND>return Return(matches.values()[0])\n    <DED>return Noop('No source of {}.'.format(self))\n\n\n<DED><DED>class DependenciesNode(datatype('DependenciesNode', ['subject', 'product', 'variants', 'dep_product']), Node):\n  <IND>\"\"\"A Node that selects the given Product for each of the dependencies of this subject.\n\n  Begins by selecting the `dep_product` for the subject, and then selects a product for each\n  of dep_products' dependencies.\n\n  The value produced by this Node guarantees that the order of the provided values matches the\n  order of declaration in the `dependencies` list of the `dep_product`.\n  \"\"\"\n\n  def _dep_product_node(self):\n    <IND>return SelectNode(self.subject, self.dep_product, self.variants, None)\n\n  <DED>def _dep_node(self, dependency):\n    <IND>variants = self.variants\n    if isinstance(dependency, Address):\n      # If a subject has literal variants for particular dependencies, they win over all else.\n      <IND>dependency, literal_variants = parse_variants(dependency)\n      variants = Variants.merge(variants, literal_variants)\n    <DED>return SelectNode(dependency, self.product, variants, None)\n\n  <DED>def step(self, dependency_states, node_builder):\n    # Request the product we need in order to request dependencies.\n    <IND>dep_product_node = self._dep_product_node()\n    dep_product_state = dependency_states.get(dep_product_node, None)\n    if dep_product_state is None or type(dep_product_state) == Waiting:\n      <IND>return Waiting([dep_product_node])\n    <DED>elif type(dep_product_state) == Throw:\n      <IND>return dep_product_state\n    <DED>elif type(dep_product_state) == Noop:\n      <IND>return Noop('Could not compute {} to determine dependencies.'.format(dep_product_node))\n    <DED>elif type(dep_product_state) != Return:\n      <IND>State.raise_unrecognized(dep_product_state)\n\n    # The product and its dependency list are available.\n    <DED>dep_product = dep_product_state.value\n    dependencies = [self._dep_node(d) for d in dep_product.dependencies]\n    for dependency in dependencies:\n      <IND>dep_state = dependency_states.get(dependency, None)\n      if dep_state is None or type(dep_state) == Waiting:\n        # One of the dependencies is not yet available. Indicate that we are waiting for all\n        # of them.\n        <IND>return Waiting([dep_product_node] + dependencies)\n      <DED>elif type(dep_state) == Throw:\n        <IND>return dep_state\n      <DED>elif type(dep_state) == Noop:\n        <IND>return Throw(ValueError('No source of explicit dependency {}'.format(dependency)))\n      <DED>elif type(dep_state) != Return:\n        <IND>raise State.raise_unrecognized(dep_state)\n    # All dependencies are present! Set our value to a list of the resulting values.\n    <DED><DED>return Return([dependency_states[d].value for d in dependencies])\n\n\n<DED><DED>class TaskNode(datatype('TaskNode', ['subject', 'product', 'variants', 'func', 'clause']), Node):\n\n  <IND>def step(self, dependency_states, node_builder):\n    # Compute dependencies.\n    <IND>dep_values = []\n    dependencies = []\n    for select in self.clause:\n      <IND>dep = select.construct_node(self.subject, self.variants)\n      if dep is None:\n        <IND>return Noop('Dependency {} is not satisfiable.'.format(select))\n      <DED>dependencies.append(dep)\n\n    # If all dependency Nodes are Return, execute the Node.\n    <DED>for dep_select, dep_key in zip(self.clause, dependencies):\n      <IND>dep_state = dependency_states.get(dep_key, None)\n      if dep_state is None or type(dep_state) == Waiting:\n        <IND>return Waiting(dependencies)\n      <DED>elif type(dep_state) == Return:\n        <IND>dep_values.append(dep_state.value)\n      <DED>elif type(dep_state) == Noop:\n        <IND>if dep_select.optional:\n          <IND>dep_values.append(None)\n        <DED>else:\n          <IND>return Noop('Was missing (at least) input {}.'.format(dep_key))\n      <DED><DED>elif type(dep_state) == Throw:\n        <IND>return dep_state\n      <DED>else:\n        <IND>State.raise_unrecognized(dep_state)\n    <DED><DED>try:\n      <IND>return Return(self.func(*dep_values))\n    <DED>except Exception as e:\n      <IND>return Throw(e)\n\n\n<DED><DED><DED>class ProductGraph(object):\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n<DED><DED>class ProductGraph(object):\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "pantsbuild/pants",
    "commit": "08bc2add6e98feefdce36f6f094a15e3e598b1e7",
    "filename": "src/python/pants/engine/exp/scheduler.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/pantsbuild-pants/src/python/pants/engine/exp/scheduler.py",
    "file_hunks_size": 13,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": true,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "src/python/pants/engine/exp/scheduler.py:155:11 Invalid type [31]: Expression `pants.util.objects.datatype(\"Noop\", [\"msg\"])` is not a valid type.",
    "message": " Expression `pants.util.objects.datatype(\"Noop\", [\"msg\"])` is not a valid type.",
    "rule_id": "Invalid type [31]",
    "warning_line_no": 155,
    "warning_line": "class Noop(datatype('Noop', ['msg']), State):",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": true,
        "has_suppression": false,
        "source_code": "\nclass ConflictingProducersError(SchedulingError):\n  \"\"\"Indicates that there was more than one source of a product for a given subject.\n\n  TODO: This will need to be legal in order to support multiple Planners producing a\n  (mergeable) Classpath for one subject, for example. see:\n    https://github.com/pantsbuild/pants/issues/2526\n  \"\"\"\n\n  def __init__(self, subject, product, matches):\n    msgs = '\\n  '.join('{}: {}'.format(k, v) for k, v in matches.items())\n    msg = 'More than one source of {} for {}:\\n  {}'.format(product.__name__, subject, msgs)\n    super(ConflictingProducersError, self).__init__(msg)\n\n\nclass State(object):\n  @classmethod\n  def raise_unrecognized(cls, state):\n    raise ValueError('Unrecognized Node State: {}'.format(state))\n\n\nclass Noop(datatype('Noop', ['msg']), State):\n  \"\"\"Indicates that a Node did not have the inputs which would be needed for it to execute.\"\"\"\n  pass\n\n\nclass Return(datatype('Return', ['value']), State):\n  \"\"\"Indicates that a Node successfully returned a value.\"\"\"\n  pass\n\n\nclass Throw(datatype('Throw', ['exc']), State):\n  \"\"\"Indicates that a Node should have been able to return a value, but failed.\"\"\"\n  pass\n\n\nclass Waiting(datatype('Waiting', ['dependencies']), State):\n  \"\"\"Indicates that a Node is waiting for some/all of the dependencies to become available.\n\n  Some Nodes will return different dependency Nodes based on where they are in their lifecycle,\n  but all returned dependencies are recorded for the lifetime of a ProductGraph.\n  \"\"\"\n  pass\n\n\nclass Node(object):\n  @abstractproperty\n  def subject(self):\n    \"\"\"The subject for this Node.\"\"\"\n\n  @abstractproperty\n  def product(self):\n    \"\"\"The output product for this Node.\"\"\"\n\n  @abstractproperty\n  def variants(self):\n    \"\"\"The variants for this Node.\"\"\"\n\n  @abstractmethod\n  def step(self, dependency_states, node_builder):\n    \"\"\"Given a dict of the dependency States for this Node, returns the current State of the Node.\n\n    The NodeBuilder parameter provides a way to construct Nodes that require information about\n    installed tasks.\n\n    After this method returns a non-Waiting state, it will never be visited again for this Node.\n    \"\"\"\n\n\nclass SelectNode(datatype('SelectNode', ['subject', 'product', 'variants', 'variant_key']), Node):\n  \"\"\"A Node that selects a product for a subject.\n\n  A Select can be satisfied by multiple sources, but fails if multiple sources produce a value. The\n  'variants' field represents variant configuration that is propagated to dependencies. When\n  a task needs to consume a product as configured by the variants map, it uses the SelectVariant\n  selector, which introduces the 'variant' value to restrict the names of values selected by a\n  SelectNode.\n  \"\"\"\n\n  def _variants_node(self):\n    if self.product != Variants:\n      return SelectNode(self.subject, Variants, self.variants, None)\n    return None\n\n  def _select_literal(self, candidate, variant_value):\n    \"\"\"Looks for has-a or is-a relationships between the given value and the requested product.\n\n    Returns the resulting product value, or None if no match was made.\n    \"\"\"\n    def items():\n      # Check whether the subject is-a instance of the product.\n      yield candidate\n      # Else, check whether it has-a instance of the product.\n      if isinstance(candidate, Target):\n        for configuration in candidate.configurations:\n          yield configuration\n\n    # TODO: returning only the first literal configuration of a given type/variant. Need to\n    # define mergeability for products.\n    for item in items():\n      if not isinstance(item, self.product):\n        continue\n      if variant_value and not getattr(item, 'name', None) == variant_value:\n        continue\n      return item\n    return None\n\n  def step(self, dependency_states, node_builder):\n    # Request default Variants for the subject, so that if there are any we can propagate\n    # them to task nodes.\n    variants = self.variants\n    variants_node = self._variants_node()\n    if variants_node:\n      dep_state = dependency_states.get(variants_node, None)\n      if dep_state is None or type(dep_state) == Waiting:\n        return Waiting([variants_node])\n      elif type(dep_state) == Return:\n        # A subject's variants are overridden by any dependent's requested variants, so\n        # we merge them left to right here.\n        variants = Variants.merge(dep_state.value.default.items(), variants)\n\n    # If there is a variant_key, see whether it has been configured.\n    variant_value = None\n    if self.variant_key:\n      variant_values = [value for key, value in variants\n                        if key == self.variant_key] if variants else None\n      if not variant_values:\n        # Select cannot be satisfied: no variant configured for this key.\n        return Noop('Variant key {} was not configured in variants {}'.format(\n          self.variant_key, variants))\n      variant_value = variant_values[0]\n\n    # If the Subject \"is a\" or \"has a\" Product, then we're done.\n    literal_value = self._select_literal(self.subject, variant_value)\n    if literal_value is not None:\n      return Return(literal_value)\n\n    # Else, attempt to use a configured task to compute the value.\n    has_waiting_dep = False\n    dependencies = list(node_builder.task_nodes(self.subject, self.product, variants))\n    matches = {}\n    for dep in dependencies:\n      dep_state = dependency_states.get(dep, None)\n      if dep_state is None or type(dep_state) == Waiting:\n        has_waiting_dep = True\n        continue\n      elif type(dep_state) == Throw:\n        return dep_state\n      elif type(dep_state) == Noop:\n        continue\n      elif type(dep_state) != Return:\n        State.raise_unrecognized(dep_state)\n      # We computed a value: see whether we can use it.\n      literal_value = self._select_literal(dep_state.value, variant_value)\n      if literal_value is not None:\n        matches[dep] = literal_value\n    if has_waiting_dep:\n      return Waiting(dependencies)\n    elif len(matches) > 1:\n      # TODO: Multiple successful tasks are not currently supported. We should allow for this\n      # by adding support for \"mergeable\" products. see:\n      #   https://github.com/pantsbuild/pants/issues/2526\n      return Throw(ConflictingProducersError(self.subject, self.product, matches))\n    elif len(matches) == 1:\n      return Return(matches.values()[0])\n    return Noop('No source of {}.'.format(self))\n\n\nclass DependenciesNode(datatype('DependenciesNode', ['subject', 'product', 'variants', 'dep_product']), Node):\n  \"\"\"A Node that selects the given Product for each of the dependencies of this subject.\n\n  Begins by selecting the `dep_product` for the subject, and then selects a product for each\n  of dep_products' dependencies.\n\n  The value produced by this Node guarantees that the order of the provided values matches the\n  order of declaration in the `dependencies` list of the `dep_product`.\n  \"\"\"\n\n  def _dep_product_node(self):\n    return SelectNode(self.subject, self.dep_product, self.variants, None)\n\n  def _dep_node(self, dependency):\n    variants = self.variants\n    if isinstance(dependency, Address):\n      # If a subject has literal variants for particular dependencies, they win over all else.\n      dependency, literal_variants = parse_variants(dependency)\n      variants = Variants.merge(variants, literal_variants)\n    return SelectNode(dependency, self.product, variants, None)\n\n  def step(self, dependency_states, node_builder):\n    # Request the product we need in order to request dependencies.\n    dep_product_node = self._dep_product_node()\n    dep_product_state = dependency_states.get(dep_product_node, None)\n    if dep_product_state is None or type(dep_product_state) == Waiting:\n      return Waiting([dep_product_node])\n    elif type(dep_product_state) == Throw:\n      return dep_product_state\n    elif type(dep_product_state) == Noop:\n      return Noop('Could not compute {} to determine dependencies.'.format(dep_product_node))\n    elif type(dep_product_state) != Return:\n      State.raise_unrecognized(dep_product_state)\n\n    # The product and its dependency list are available.\n    dep_product = dep_product_state.value\n    dependencies = [self._dep_node(d) for d in dep_product.dependencies]\n    for dependency in dependencies:\n      dep_state = dependency_states.get(dependency, None)\n      if dep_state is None or type(dep_state) == Waiting:\n        # One of the dependencies is not yet available. Indicate that we are waiting for all\n        # of them.\n        return Waiting([dep_product_node] + dependencies)\n      elif type(dep_state) == Throw:\n        return dep_state\n      elif type(dep_state) == Noop:\n        return Throw(ValueError('No source of explicit dependency {}'.format(dependency)))\n      elif type(dep_state) != Return:\n        raise State.raise_unrecognized(dep_state)\n    # All dependencies are present! Set our value to a list of the resulting values.\n    return Return([dependency_states[d].value for d in dependencies])\n\n\nclass TaskNode(datatype('TaskNode', ['subject', 'product', 'variants', 'func', 'clause']), Node):\n\n  def step(self, dependency_states, node_builder):\n    # Compute dependencies.\n    dep_values = []\n    dependencies = []\n    for select in self.clause:\n      dep = select.construct_node(self.subject, self.variants)\n      if dep is None:\n        return Noop('Dependency {} is not satisfiable.'.format(select))\n      dependencies.append(dep)\n\n    # If all dependency Nodes are Return, execute the Node.\n    for dep_select, dep_key in zip(self.clause, dependencies):\n      dep_state = dependency_states.get(dep_key, None)\n      if dep_state is None or type(dep_state) == Waiting:\n        return Waiting(dependencies)\n      elif type(dep_state) == Return:\n        dep_values.append(dep_state.value)\n      elif type(dep_state) == Noop:\n        if dep_select.optional:\n          dep_values.append(None)\n        else:\n          return Noop('Was missing (at least) input {}.'.format(dep_key))\n      elif type(dep_state) == Throw:\n        return dep_state\n      else:\n        State.raise_unrecognized(dep_state)\n    try:\n      return Return(self.func(*dep_values))\n    except Exception as e:\n      return Throw(e)\n\n\nclass ProductGraph(object):\n",
        "source_code_len": 10229,
        "target_code": "\nclass ProductGraph(object):\n",
        "target_code_len": 29,
        "diff_format": "@@ -134,256 +48,2 @@\n \n-class ConflictingProducersError(SchedulingError):\n-  \"\"\"Indicates that there was more than one source of a product for a given subject.\n-\n-  TODO: This will need to be legal in order to support multiple Planners producing a\n-  (mergeable) Classpath for one subject, for example. see:\n-    https://github.com/pantsbuild/pants/issues/2526\n-  \"\"\"\n-\n-  def __init__(self, subject, product, matches):\n-    msgs = '\\n  '.join('{}: {}'.format(k, v) for k, v in matches.items())\n-    msg = 'More than one source of {} for {}:\\n  {}'.format(product.__name__, subject, msgs)\n-    super(ConflictingProducersError, self).__init__(msg)\n-\n-\n-class State(object):\n-  @classmethod\n-  def raise_unrecognized(cls, state):\n-    raise ValueError('Unrecognized Node State: {}'.format(state))\n-\n-\n-class Noop(datatype('Noop', ['msg']), State):\n-  \"\"\"Indicates that a Node did not have the inputs which would be needed for it to execute.\"\"\"\n-  pass\n-\n-\n-class Return(datatype('Return', ['value']), State):\n-  \"\"\"Indicates that a Node successfully returned a value.\"\"\"\n-  pass\n-\n-\n-class Throw(datatype('Throw', ['exc']), State):\n-  \"\"\"Indicates that a Node should have been able to return a value, but failed.\"\"\"\n-  pass\n-\n-\n-class Waiting(datatype('Waiting', ['dependencies']), State):\n-  \"\"\"Indicates that a Node is waiting for some/all of the dependencies to become available.\n-\n-  Some Nodes will return different dependency Nodes based on where they are in their lifecycle,\n-  but all returned dependencies are recorded for the lifetime of a ProductGraph.\n-  \"\"\"\n-  pass\n-\n-\n-class Node(object):\n-  @abstractproperty\n-  def subject(self):\n-    \"\"\"The subject for this Node.\"\"\"\n-\n-  @abstractproperty\n-  def product(self):\n-    \"\"\"The output product for this Node.\"\"\"\n-\n-  @abstractproperty\n-  def variants(self):\n-    \"\"\"The variants for this Node.\"\"\"\n-\n-  @abstractmethod\n-  def step(self, dependency_states, node_builder):\n-    \"\"\"Given a dict of the dependency States for this Node, returns the current State of the Node.\n-\n-    The NodeBuilder parameter provides a way to construct Nodes that require information about\n-    installed tasks.\n-\n-    After this method returns a non-Waiting state, it will never be visited again for this Node.\n-    \"\"\"\n-\n-\n-class SelectNode(datatype('SelectNode', ['subject', 'product', 'variants', 'variant_key']), Node):\n-  \"\"\"A Node that selects a product for a subject.\n-\n-  A Select can be satisfied by multiple sources, but fails if multiple sources produce a value. The\n-  'variants' field represents variant configuration that is propagated to dependencies. When\n-  a task needs to consume a product as configured by the variants map, it uses the SelectVariant\n-  selector, which introduces the 'variant' value to restrict the names of values selected by a\n-  SelectNode.\n-  \"\"\"\n-\n-  def _variants_node(self):\n-    if self.product != Variants:\n-      return SelectNode(self.subject, Variants, self.variants, None)\n-    return None\n-\n-  def _select_literal(self, candidate, variant_value):\n-    \"\"\"Looks for has-a or is-a relationships between the given value and the requested product.\n-\n-    Returns the resulting product value, or None if no match was made.\n-    \"\"\"\n-    def items():\n-      # Check whether the subject is-a instance of the product.\n-      yield candidate\n-      # Else, check whether it has-a instance of the product.\n-      if isinstance(candidate, Target):\n-        for configuration in candidate.configurations:\n-          yield configuration\n-\n-    # TODO: returning only the first literal configuration of a given type/variant. Need to\n-    # define mergeability for products.\n-    for item in items():\n-      if not isinstance(item, self.product):\n-        continue\n-      if variant_value and not getattr(item, 'name', None) == variant_value:\n-        continue\n-      return item\n-    return None\n-\n-  def step(self, dependency_states, node_builder):\n-    # Request default Variants for the subject, so that if there are any we can propagate\n-    # them to task nodes.\n-    variants = self.variants\n-    variants_node = self._variants_node()\n-    if variants_node:\n-      dep_state = dependency_states.get(variants_node, None)\n-      if dep_state is None or type(dep_state) == Waiting:\n-        return Waiting([variants_node])\n-      elif type(dep_state) == Return:\n-        # A subject's variants are overridden by any dependent's requested variants, so\n-        # we merge them left to right here.\n-        variants = Variants.merge(dep_state.value.default.items(), variants)\n-\n-    # If there is a variant_key, see whether it has been configured.\n-    variant_value = None\n-    if self.variant_key:\n-      variant_values = [value for key, value in variants\n-                        if key == self.variant_key] if variants else None\n-      if not variant_values:\n-        # Select cannot be satisfied: no variant configured for this key.\n-        return Noop('Variant key {} was not configured in variants {}'.format(\n-          self.variant_key, variants))\n-      variant_value = variant_values[0]\n-\n-    # If the Subject \"is a\" or \"has a\" Product, then we're done.\n-    literal_value = self._select_literal(self.subject, variant_value)\n-    if literal_value is not None:\n-      return Return(literal_value)\n-\n-    # Else, attempt to use a configured task to compute the value.\n-    has_waiting_dep = False\n-    dependencies = list(node_builder.task_nodes(self.subject, self.product, variants))\n-    matches = {}\n-    for dep in dependencies:\n-      dep_state = dependency_states.get(dep, None)\n-      if dep_state is None or type(dep_state) == Waiting:\n-        has_waiting_dep = True\n-        continue\n-      elif type(dep_state) == Throw:\n-        return dep_state\n-      elif type(dep_state) == Noop:\n-        continue\n-      elif type(dep_state) != Return:\n-        State.raise_unrecognized(dep_state)\n-      # We computed a value: see whether we can use it.\n-      literal_value = self._select_literal(dep_state.value, variant_value)\n-      if literal_value is not None:\n-        matches[dep] = literal_value\n-    if has_waiting_dep:\n-      return Waiting(dependencies)\n-    elif len(matches) > 1:\n-      # TODO: Multiple successful tasks are not currently supported. We should allow for this\n-      # by adding support for \"mergeable\" products. see:\n-      #   https://github.com/pantsbuild/pants/issues/2526\n-      return Throw(ConflictingProducersError(self.subject, self.product, matches))\n-    elif len(matches) == 1:\n-      return Return(matches.values()[0])\n-    return Noop('No source of {}.'.format(self))\n-\n-\n-class DependenciesNode(datatype('DependenciesNode', ['subject', 'product', 'variants', 'dep_product']), Node):\n-  \"\"\"A Node that selects the given Product for each of the dependencies of this subject.\n-\n-  Begins by selecting the `dep_product` for the subject, and then selects a product for each\n-  of dep_products' dependencies.\n-\n-  The value produced by this Node guarantees that the order of the provided values matches the\n-  order of declaration in the `dependencies` list of the `dep_product`.\n-  \"\"\"\n-\n-  def _dep_product_node(self):\n-    return SelectNode(self.subject, self.dep_product, self.variants, None)\n-\n-  def _dep_node(self, dependency):\n-    variants = self.variants\n-    if isinstance(dependency, Address):\n-      # If a subject has literal variants for particular dependencies, they win over all else.\n-      dependency, literal_variants = parse_variants(dependency)\n-      variants = Variants.merge(variants, literal_variants)\n-    return SelectNode(dependency, self.product, variants, None)\n-\n-  def step(self, dependency_states, node_builder):\n-    # Request the product we need in order to request dependencies.\n-    dep_product_node = self._dep_product_node()\n-    dep_product_state = dependency_states.get(dep_product_node, None)\n-    if dep_product_state is None or type(dep_product_state) == Waiting:\n-      return Waiting([dep_product_node])\n-    elif type(dep_product_state) == Throw:\n-      return dep_product_state\n-    elif type(dep_product_state) == Noop:\n-      return Noop('Could not compute {} to determine dependencies.'.format(dep_product_node))\n-    elif type(dep_product_state) != Return:\n-      State.raise_unrecognized(dep_product_state)\n-\n-    # The product and its dependency list are available.\n-    dep_product = dep_product_state.value\n-    dependencies = [self._dep_node(d) for d in dep_product.dependencies]\n-    for dependency in dependencies:\n-      dep_state = dependency_states.get(dependency, None)\n-      if dep_state is None or type(dep_state) == Waiting:\n-        # One of the dependencies is not yet available. Indicate that we are waiting for all\n-        # of them.\n-        return Waiting([dep_product_node] + dependencies)\n-      elif type(dep_state) == Throw:\n-        return dep_state\n-      elif type(dep_state) == Noop:\n-        return Throw(ValueError('No source of explicit dependency {}'.format(dependency)))\n-      elif type(dep_state) != Return:\n-        raise State.raise_unrecognized(dep_state)\n-    # All dependencies are present! Set our value to a list of the resulting values.\n-    return Return([dependency_states[d].value for d in dependencies])\n-\n-\n-class TaskNode(datatype('TaskNode', ['subject', 'product', 'variants', 'func', 'clause']), Node):\n-\n-  def step(self, dependency_states, node_builder):\n-    # Compute dependencies.\n-    dep_values = []\n-    dependencies = []\n-    for select in self.clause:\n-      dep = select.construct_node(self.subject, self.variants)\n-      if dep is None:\n-        return Noop('Dependency {} is not satisfiable.'.format(select))\n-      dependencies.append(dep)\n-\n-    # If all dependency Nodes are Return, execute the Node.\n-    for dep_select, dep_key in zip(self.clause, dependencies):\n-      dep_state = dependency_states.get(dep_key, None)\n-      if dep_state is None or type(dep_state) == Waiting:\n-        return Waiting(dependencies)\n-      elif type(dep_state) == Return:\n-        dep_values.append(dep_state.value)\n-      elif type(dep_state) == Noop:\n-        if dep_select.optional:\n-          dep_values.append(None)\n-        else:\n-          return Noop('Was missing (at least) input {}.'.format(dep_key))\n-      elif type(dep_state) == Throw:\n-        return dep_state\n-      else:\n-        State.raise_unrecognized(dep_state)\n-    try:\n-      return Return(self.func(*dep_values))\n-    except Exception as e:\n-      return Throw(e)\n-\n-\n class ProductGraph(object):\n",
        "source_code_with_indent": "\n<DED><DED>class ConflictingProducersError(SchedulingError):\n  <IND>\"\"\"Indicates that there was more than one source of a product for a given subject.\n\n  TODO: This will need to be legal in order to support multiple Planners producing a\n  (mergeable) Classpath for one subject, for example. see:\n    https://github.com/pantsbuild/pants/issues/2526\n  \"\"\"\n\n  def __init__(self, subject, product, matches):\n    <IND>msgs = '\\n  '.join('{}: {}'.format(k, v) for k, v in matches.items())\n    msg = 'More than one source of {} for {}:\\n  {}'.format(product.__name__, subject, msgs)\n    super(ConflictingProducersError, self).__init__(msg)\n\n\n<DED><DED>class State(object):\n  <IND>@classmethod\n  def raise_unrecognized(cls, state):\n    <IND>raise ValueError('Unrecognized Node State: {}'.format(state))\n\n\n<DED><DED>class Noop(datatype('Noop', ['msg']), State):\n  <IND>\"\"\"Indicates that a Node did not have the inputs which would be needed for it to execute.\"\"\"\n  pass\n\n\n<DED>class Return(datatype('Return', ['value']), State):\n  <IND>\"\"\"Indicates that a Node successfully returned a value.\"\"\"\n  pass\n\n\n<DED>class Throw(datatype('Throw', ['exc']), State):\n  <IND>\"\"\"Indicates that a Node should have been able to return a value, but failed.\"\"\"\n  pass\n\n\n<DED>class Waiting(datatype('Waiting', ['dependencies']), State):\n  <IND>\"\"\"Indicates that a Node is waiting for some/all of the dependencies to become available.\n\n  Some Nodes will return different dependency Nodes based on where they are in their lifecycle,\n  but all returned dependencies are recorded for the lifetime of a ProductGraph.\n  \"\"\"\n  pass\n\n\n<DED>class Node(object):\n  <IND>@abstractproperty\n  def subject(self):\n    <IND>\"\"\"The subject for this Node.\"\"\"\n\n  <DED>@abstractproperty\n  def product(self):\n    <IND>\"\"\"The output product for this Node.\"\"\"\n\n  <DED>@abstractproperty\n  def variants(self):\n    <IND>\"\"\"The variants for this Node.\"\"\"\n\n  <DED>@abstractmethod\n  def step(self, dependency_states, node_builder):\n    <IND>\"\"\"Given a dict of the dependency States for this Node, returns the current State of the Node.\n\n    The NodeBuilder parameter provides a way to construct Nodes that require information about\n    installed tasks.\n\n    After this method returns a non-Waiting state, it will never be visited again for this Node.\n    \"\"\"\n\n\n<DED><DED>class SelectNode(datatype('SelectNode', ['subject', 'product', 'variants', 'variant_key']), Node):\n  <IND>\"\"\"A Node that selects a product for a subject.\n\n  A Select can be satisfied by multiple sources, but fails if multiple sources produce a value. The\n  'variants' field represents variant configuration that is propagated to dependencies. When\n  a task needs to consume a product as configured by the variants map, it uses the SelectVariant\n  selector, which introduces the 'variant' value to restrict the names of values selected by a\n  SelectNode.\n  \"\"\"\n\n  def _variants_node(self):\n    <IND>if self.product != Variants:\n      <IND>return SelectNode(self.subject, Variants, self.variants, None)\n    <DED>return None\n\n  <DED>def _select_literal(self, candidate, variant_value):\n    <IND>\"\"\"Looks for has-a or is-a relationships between the given value and the requested product.\n\n    Returns the resulting product value, or None if no match was made.\n    \"\"\"\n    def items():\n      # Check whether the subject is-a instance of the product.\n      <IND>yield candidate\n      # Else, check whether it has-a instance of the product.\n      if isinstance(candidate, Target):\n        <IND>for configuration in candidate.configurations:\n          <IND>yield configuration\n\n    # TODO: returning only the first literal configuration of a given type/variant. Need to\n    # define mergeability for products.\n    <DED><DED><DED>for item in items():\n      <IND>if not isinstance(item, self.product):\n        <IND>continue\n      <DED>if variant_value and not getattr(item, 'name', None) == variant_value:\n        <IND>continue\n      <DED>return item\n    <DED>return None\n\n  <DED>def step(self, dependency_states, node_builder):\n    # Request default Variants for the subject, so that if there are any we can propagate\n    # them to task nodes.\n    <IND>variants = self.variants\n    variants_node = self._variants_node()\n    if variants_node:\n      <IND>dep_state = dependency_states.get(variants_node, None)\n      if dep_state is None or type(dep_state) == Waiting:\n        <IND>return Waiting([variants_node])\n      <DED>elif type(dep_state) == Return:\n        # A subject's variants are overridden by any dependent's requested variants, so\n        # we merge them left to right here.\n        <IND>variants = Variants.merge(dep_state.value.default.items(), variants)\n\n    # If there is a variant_key, see whether it has been configured.\n    <DED><DED>variant_value = None\n    if self.variant_key:\n      <IND>variant_values = [value for key, value in variants\n                        if key == self.variant_key] if variants else None\n      if not variant_values:\n        # Select cannot be satisfied: no variant configured for this key.\n        <IND>return Noop('Variant key {} was not configured in variants {}'.format(\n          self.variant_key, variants))\n      <DED>variant_value = variant_values[0]\n\n    # If the Subject \"is a\" or \"has a\" Product, then we're done.\n    <DED>literal_value = self._select_literal(self.subject, variant_value)\n    if literal_value is not None:\n      <IND>return Return(literal_value)\n\n    # Else, attempt to use a configured task to compute the value.\n    <DED>has_waiting_dep = False\n    dependencies = list(node_builder.task_nodes(self.subject, self.product, variants))\n    matches = {}\n    for dep in dependencies:\n      <IND>dep_state = dependency_states.get(dep, None)\n      if dep_state is None or type(dep_state) == Waiting:\n        <IND>has_waiting_dep = True\n        continue\n      <DED>elif type(dep_state) == Throw:\n        <IND>return dep_state\n      <DED>elif type(dep_state) == Noop:\n        <IND>continue\n      <DED>elif type(dep_state) != Return:\n        <IND>State.raise_unrecognized(dep_state)\n      # We computed a value: see whether we can use it.\n      <DED>literal_value = self._select_literal(dep_state.value, variant_value)\n      if literal_value is not None:\n        <IND>matches[dep] = literal_value\n    <DED><DED>if has_waiting_dep:\n      <IND>return Waiting(dependencies)\n    <DED>elif len(matches) > 1:\n      # TODO: Multiple successful tasks are not currently supported. We should allow for this\n      # by adding support for \"mergeable\" products. see:\n      #   https://github.com/pantsbuild/pants/issues/2526\n      <IND>return Throw(ConflictingProducersError(self.subject, self.product, matches))\n    <DED>elif len(matches) == 1:\n      <IND>return Return(matches.values()[0])\n    <DED>return Noop('No source of {}.'.format(self))\n\n\n<DED><DED>class DependenciesNode(datatype('DependenciesNode', ['subject', 'product', 'variants', 'dep_product']), Node):\n  <IND>\"\"\"A Node that selects the given Product for each of the dependencies of this subject.\n\n  Begins by selecting the `dep_product` for the subject, and then selects a product for each\n  of dep_products' dependencies.\n\n  The value produced by this Node guarantees that the order of the provided values matches the\n  order of declaration in the `dependencies` list of the `dep_product`.\n  \"\"\"\n\n  def _dep_product_node(self):\n    <IND>return SelectNode(self.subject, self.dep_product, self.variants, None)\n\n  <DED>def _dep_node(self, dependency):\n    <IND>variants = self.variants\n    if isinstance(dependency, Address):\n      # If a subject has literal variants for particular dependencies, they win over all else.\n      <IND>dependency, literal_variants = parse_variants(dependency)\n      variants = Variants.merge(variants, literal_variants)\n    <DED>return SelectNode(dependency, self.product, variants, None)\n\n  <DED>def step(self, dependency_states, node_builder):\n    # Request the product we need in order to request dependencies.\n    <IND>dep_product_node = self._dep_product_node()\n    dep_product_state = dependency_states.get(dep_product_node, None)\n    if dep_product_state is None or type(dep_product_state) == Waiting:\n      <IND>return Waiting([dep_product_node])\n    <DED>elif type(dep_product_state) == Throw:\n      <IND>return dep_product_state\n    <DED>elif type(dep_product_state) == Noop:\n      <IND>return Noop('Could not compute {} to determine dependencies.'.format(dep_product_node))\n    <DED>elif type(dep_product_state) != Return:\n      <IND>State.raise_unrecognized(dep_product_state)\n\n    # The product and its dependency list are available.\n    <DED>dep_product = dep_product_state.value\n    dependencies = [self._dep_node(d) for d in dep_product.dependencies]\n    for dependency in dependencies:\n      <IND>dep_state = dependency_states.get(dependency, None)\n      if dep_state is None or type(dep_state) == Waiting:\n        # One of the dependencies is not yet available. Indicate that we are waiting for all\n        # of them.\n        <IND>return Waiting([dep_product_node] + dependencies)\n      <DED>elif type(dep_state) == Throw:\n        <IND>return dep_state\n      <DED>elif type(dep_state) == Noop:\n        <IND>return Throw(ValueError('No source of explicit dependency {}'.format(dependency)))\n      <DED>elif type(dep_state) != Return:\n        <IND>raise State.raise_unrecognized(dep_state)\n    # All dependencies are present! Set our value to a list of the resulting values.\n    <DED><DED>return Return([dependency_states[d].value for d in dependencies])\n\n\n<DED><DED>class TaskNode(datatype('TaskNode', ['subject', 'product', 'variants', 'func', 'clause']), Node):\n\n  <IND>def step(self, dependency_states, node_builder):\n    # Compute dependencies.\n    <IND>dep_values = []\n    dependencies = []\n    for select in self.clause:\n      <IND>dep = select.construct_node(self.subject, self.variants)\n      if dep is None:\n        <IND>return Noop('Dependency {} is not satisfiable.'.format(select))\n      <DED>dependencies.append(dep)\n\n    # If all dependency Nodes are Return, execute the Node.\n    <DED>for dep_select, dep_key in zip(self.clause, dependencies):\n      <IND>dep_state = dependency_states.get(dep_key, None)\n      if dep_state is None or type(dep_state) == Waiting:\n        <IND>return Waiting(dependencies)\n      <DED>elif type(dep_state) == Return:\n        <IND>dep_values.append(dep_state.value)\n      <DED>elif type(dep_state) == Noop:\n        <IND>if dep_select.optional:\n          <IND>dep_values.append(None)\n        <DED>else:\n          <IND>return Noop('Was missing (at least) input {}.'.format(dep_key))\n      <DED><DED>elif type(dep_state) == Throw:\n        <IND>return dep_state\n      <DED>else:\n        <IND>State.raise_unrecognized(dep_state)\n    <DED><DED>try:\n      <IND>return Return(self.func(*dep_values))\n    <DED>except Exception as e:\n      <IND>return Throw(e)\n\n\n<DED><DED><DED>class ProductGraph(object):\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n<DED><DED>class ProductGraph(object):\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "pantsbuild/pants",
    "commit": "08bc2add6e98feefdce36f6f094a15e3e598b1e7",
    "filename": "src/python/pants/engine/exp/scheduler.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/pantsbuild-pants/src/python/pants/engine/exp/scheduler.py",
    "file_hunks_size": 13,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": true,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "src/python/pants/engine/exp/scheduler.py:160:13 Invalid type [31]: Expression `pants.util.objects.datatype(\"Return\", [\"value\"])` is not a valid type.",
    "message": " Expression `pants.util.objects.datatype(\"Return\", [\"value\"])` is not a valid type.",
    "rule_id": "Invalid type [31]",
    "warning_line_no": 160,
    "warning_line": "class Return(datatype('Return', ['value']), State):",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": true,
        "has_suppression": false,
        "source_code": "\nclass ConflictingProducersError(SchedulingError):\n  \"\"\"Indicates that there was more than one source of a product for a given subject.\n\n  TODO: This will need to be legal in order to support multiple Planners producing a\n  (mergeable) Classpath for one subject, for example. see:\n    https://github.com/pantsbuild/pants/issues/2526\n  \"\"\"\n\n  def __init__(self, subject, product, matches):\n    msgs = '\\n  '.join('{}: {}'.format(k, v) for k, v in matches.items())\n    msg = 'More than one source of {} for {}:\\n  {}'.format(product.__name__, subject, msgs)\n    super(ConflictingProducersError, self).__init__(msg)\n\n\nclass State(object):\n  @classmethod\n  def raise_unrecognized(cls, state):\n    raise ValueError('Unrecognized Node State: {}'.format(state))\n\n\nclass Noop(datatype('Noop', ['msg']), State):\n  \"\"\"Indicates that a Node did not have the inputs which would be needed for it to execute.\"\"\"\n  pass\n\n\nclass Return(datatype('Return', ['value']), State):\n  \"\"\"Indicates that a Node successfully returned a value.\"\"\"\n  pass\n\n\nclass Throw(datatype('Throw', ['exc']), State):\n  \"\"\"Indicates that a Node should have been able to return a value, but failed.\"\"\"\n  pass\n\n\nclass Waiting(datatype('Waiting', ['dependencies']), State):\n  \"\"\"Indicates that a Node is waiting for some/all of the dependencies to become available.\n\n  Some Nodes will return different dependency Nodes based on where they are in their lifecycle,\n  but all returned dependencies are recorded for the lifetime of a ProductGraph.\n  \"\"\"\n  pass\n\n\nclass Node(object):\n  @abstractproperty\n  def subject(self):\n    \"\"\"The subject for this Node.\"\"\"\n\n  @abstractproperty\n  def product(self):\n    \"\"\"The output product for this Node.\"\"\"\n\n  @abstractproperty\n  def variants(self):\n    \"\"\"The variants for this Node.\"\"\"\n\n  @abstractmethod\n  def step(self, dependency_states, node_builder):\n    \"\"\"Given a dict of the dependency States for this Node, returns the current State of the Node.\n\n    The NodeBuilder parameter provides a way to construct Nodes that require information about\n    installed tasks.\n\n    After this method returns a non-Waiting state, it will never be visited again for this Node.\n    \"\"\"\n\n\nclass SelectNode(datatype('SelectNode', ['subject', 'product', 'variants', 'variant_key']), Node):\n  \"\"\"A Node that selects a product for a subject.\n\n  A Select can be satisfied by multiple sources, but fails if multiple sources produce a value. The\n  'variants' field represents variant configuration that is propagated to dependencies. When\n  a task needs to consume a product as configured by the variants map, it uses the SelectVariant\n  selector, which introduces the 'variant' value to restrict the names of values selected by a\n  SelectNode.\n  \"\"\"\n\n  def _variants_node(self):\n    if self.product != Variants:\n      return SelectNode(self.subject, Variants, self.variants, None)\n    return None\n\n  def _select_literal(self, candidate, variant_value):\n    \"\"\"Looks for has-a or is-a relationships between the given value and the requested product.\n\n    Returns the resulting product value, or None if no match was made.\n    \"\"\"\n    def items():\n      # Check whether the subject is-a instance of the product.\n      yield candidate\n      # Else, check whether it has-a instance of the product.\n      if isinstance(candidate, Target):\n        for configuration in candidate.configurations:\n          yield configuration\n\n    # TODO: returning only the first literal configuration of a given type/variant. Need to\n    # define mergeability for products.\n    for item in items():\n      if not isinstance(item, self.product):\n        continue\n      if variant_value and not getattr(item, 'name', None) == variant_value:\n        continue\n      return item\n    return None\n\n  def step(self, dependency_states, node_builder):\n    # Request default Variants for the subject, so that if there are any we can propagate\n    # them to task nodes.\n    variants = self.variants\n    variants_node = self._variants_node()\n    if variants_node:\n      dep_state = dependency_states.get(variants_node, None)\n      if dep_state is None or type(dep_state) == Waiting:\n        return Waiting([variants_node])\n      elif type(dep_state) == Return:\n        # A subject's variants are overridden by any dependent's requested variants, so\n        # we merge them left to right here.\n        variants = Variants.merge(dep_state.value.default.items(), variants)\n\n    # If there is a variant_key, see whether it has been configured.\n    variant_value = None\n    if self.variant_key:\n      variant_values = [value for key, value in variants\n                        if key == self.variant_key] if variants else None\n      if not variant_values:\n        # Select cannot be satisfied: no variant configured for this key.\n        return Noop('Variant key {} was not configured in variants {}'.format(\n          self.variant_key, variants))\n      variant_value = variant_values[0]\n\n    # If the Subject \"is a\" or \"has a\" Product, then we're done.\n    literal_value = self._select_literal(self.subject, variant_value)\n    if literal_value is not None:\n      return Return(literal_value)\n\n    # Else, attempt to use a configured task to compute the value.\n    has_waiting_dep = False\n    dependencies = list(node_builder.task_nodes(self.subject, self.product, variants))\n    matches = {}\n    for dep in dependencies:\n      dep_state = dependency_states.get(dep, None)\n      if dep_state is None or type(dep_state) == Waiting:\n        has_waiting_dep = True\n        continue\n      elif type(dep_state) == Throw:\n        return dep_state\n      elif type(dep_state) == Noop:\n        continue\n      elif type(dep_state) != Return:\n        State.raise_unrecognized(dep_state)\n      # We computed a value: see whether we can use it.\n      literal_value = self._select_literal(dep_state.value, variant_value)\n      if literal_value is not None:\n        matches[dep] = literal_value\n    if has_waiting_dep:\n      return Waiting(dependencies)\n    elif len(matches) > 1:\n      # TODO: Multiple successful tasks are not currently supported. We should allow for this\n      # by adding support for \"mergeable\" products. see:\n      #   https://github.com/pantsbuild/pants/issues/2526\n      return Throw(ConflictingProducersError(self.subject, self.product, matches))\n    elif len(matches) == 1:\n      return Return(matches.values()[0])\n    return Noop('No source of {}.'.format(self))\n\n\nclass DependenciesNode(datatype('DependenciesNode', ['subject', 'product', 'variants', 'dep_product']), Node):\n  \"\"\"A Node that selects the given Product for each of the dependencies of this subject.\n\n  Begins by selecting the `dep_product` for the subject, and then selects a product for each\n  of dep_products' dependencies.\n\n  The value produced by this Node guarantees that the order of the provided values matches the\n  order of declaration in the `dependencies` list of the `dep_product`.\n  \"\"\"\n\n  def _dep_product_node(self):\n    return SelectNode(self.subject, self.dep_product, self.variants, None)\n\n  def _dep_node(self, dependency):\n    variants = self.variants\n    if isinstance(dependency, Address):\n      # If a subject has literal variants for particular dependencies, they win over all else.\n      dependency, literal_variants = parse_variants(dependency)\n      variants = Variants.merge(variants, literal_variants)\n    return SelectNode(dependency, self.product, variants, None)\n\n  def step(self, dependency_states, node_builder):\n    # Request the product we need in order to request dependencies.\n    dep_product_node = self._dep_product_node()\n    dep_product_state = dependency_states.get(dep_product_node, None)\n    if dep_product_state is None or type(dep_product_state) == Waiting:\n      return Waiting([dep_product_node])\n    elif type(dep_product_state) == Throw:\n      return dep_product_state\n    elif type(dep_product_state) == Noop:\n      return Noop('Could not compute {} to determine dependencies.'.format(dep_product_node))\n    elif type(dep_product_state) != Return:\n      State.raise_unrecognized(dep_product_state)\n\n    # The product and its dependency list are available.\n    dep_product = dep_product_state.value\n    dependencies = [self._dep_node(d) for d in dep_product.dependencies]\n    for dependency in dependencies:\n      dep_state = dependency_states.get(dependency, None)\n      if dep_state is None or type(dep_state) == Waiting:\n        # One of the dependencies is not yet available. Indicate that we are waiting for all\n        # of them.\n        return Waiting([dep_product_node] + dependencies)\n      elif type(dep_state) == Throw:\n        return dep_state\n      elif type(dep_state) == Noop:\n        return Throw(ValueError('No source of explicit dependency {}'.format(dependency)))\n      elif type(dep_state) != Return:\n        raise State.raise_unrecognized(dep_state)\n    # All dependencies are present! Set our value to a list of the resulting values.\n    return Return([dependency_states[d].value for d in dependencies])\n\n\nclass TaskNode(datatype('TaskNode', ['subject', 'product', 'variants', 'func', 'clause']), Node):\n\n  def step(self, dependency_states, node_builder):\n    # Compute dependencies.\n    dep_values = []\n    dependencies = []\n    for select in self.clause:\n      dep = select.construct_node(self.subject, self.variants)\n      if dep is None:\n        return Noop('Dependency {} is not satisfiable.'.format(select))\n      dependencies.append(dep)\n\n    # If all dependency Nodes are Return, execute the Node.\n    for dep_select, dep_key in zip(self.clause, dependencies):\n      dep_state = dependency_states.get(dep_key, None)\n      if dep_state is None or type(dep_state) == Waiting:\n        return Waiting(dependencies)\n      elif type(dep_state) == Return:\n        dep_values.append(dep_state.value)\n      elif type(dep_state) == Noop:\n        if dep_select.optional:\n          dep_values.append(None)\n        else:\n          return Noop('Was missing (at least) input {}.'.format(dep_key))\n      elif type(dep_state) == Throw:\n        return dep_state\n      else:\n        State.raise_unrecognized(dep_state)\n    try:\n      return Return(self.func(*dep_values))\n    except Exception as e:\n      return Throw(e)\n\n\nclass ProductGraph(object):\n",
        "source_code_len": 10229,
        "target_code": "\nclass ProductGraph(object):\n",
        "target_code_len": 29,
        "diff_format": "@@ -134,256 +48,2 @@\n \n-class ConflictingProducersError(SchedulingError):\n-  \"\"\"Indicates that there was more than one source of a product for a given subject.\n-\n-  TODO: This will need to be legal in order to support multiple Planners producing a\n-  (mergeable) Classpath for one subject, for example. see:\n-    https://github.com/pantsbuild/pants/issues/2526\n-  \"\"\"\n-\n-  def __init__(self, subject, product, matches):\n-    msgs = '\\n  '.join('{}: {}'.format(k, v) for k, v in matches.items())\n-    msg = 'More than one source of {} for {}:\\n  {}'.format(product.__name__, subject, msgs)\n-    super(ConflictingProducersError, self).__init__(msg)\n-\n-\n-class State(object):\n-  @classmethod\n-  def raise_unrecognized(cls, state):\n-    raise ValueError('Unrecognized Node State: {}'.format(state))\n-\n-\n-class Noop(datatype('Noop', ['msg']), State):\n-  \"\"\"Indicates that a Node did not have the inputs which would be needed for it to execute.\"\"\"\n-  pass\n-\n-\n-class Return(datatype('Return', ['value']), State):\n-  \"\"\"Indicates that a Node successfully returned a value.\"\"\"\n-  pass\n-\n-\n-class Throw(datatype('Throw', ['exc']), State):\n-  \"\"\"Indicates that a Node should have been able to return a value, but failed.\"\"\"\n-  pass\n-\n-\n-class Waiting(datatype('Waiting', ['dependencies']), State):\n-  \"\"\"Indicates that a Node is waiting for some/all of the dependencies to become available.\n-\n-  Some Nodes will return different dependency Nodes based on where they are in their lifecycle,\n-  but all returned dependencies are recorded for the lifetime of a ProductGraph.\n-  \"\"\"\n-  pass\n-\n-\n-class Node(object):\n-  @abstractproperty\n-  def subject(self):\n-    \"\"\"The subject for this Node.\"\"\"\n-\n-  @abstractproperty\n-  def product(self):\n-    \"\"\"The output product for this Node.\"\"\"\n-\n-  @abstractproperty\n-  def variants(self):\n-    \"\"\"The variants for this Node.\"\"\"\n-\n-  @abstractmethod\n-  def step(self, dependency_states, node_builder):\n-    \"\"\"Given a dict of the dependency States for this Node, returns the current State of the Node.\n-\n-    The NodeBuilder parameter provides a way to construct Nodes that require information about\n-    installed tasks.\n-\n-    After this method returns a non-Waiting state, it will never be visited again for this Node.\n-    \"\"\"\n-\n-\n-class SelectNode(datatype('SelectNode', ['subject', 'product', 'variants', 'variant_key']), Node):\n-  \"\"\"A Node that selects a product for a subject.\n-\n-  A Select can be satisfied by multiple sources, but fails if multiple sources produce a value. The\n-  'variants' field represents variant configuration that is propagated to dependencies. When\n-  a task needs to consume a product as configured by the variants map, it uses the SelectVariant\n-  selector, which introduces the 'variant' value to restrict the names of values selected by a\n-  SelectNode.\n-  \"\"\"\n-\n-  def _variants_node(self):\n-    if self.product != Variants:\n-      return SelectNode(self.subject, Variants, self.variants, None)\n-    return None\n-\n-  def _select_literal(self, candidate, variant_value):\n-    \"\"\"Looks for has-a or is-a relationships between the given value and the requested product.\n-\n-    Returns the resulting product value, or None if no match was made.\n-    \"\"\"\n-    def items():\n-      # Check whether the subject is-a instance of the product.\n-      yield candidate\n-      # Else, check whether it has-a instance of the product.\n-      if isinstance(candidate, Target):\n-        for configuration in candidate.configurations:\n-          yield configuration\n-\n-    # TODO: returning only the first literal configuration of a given type/variant. Need to\n-    # define mergeability for products.\n-    for item in items():\n-      if not isinstance(item, self.product):\n-        continue\n-      if variant_value and not getattr(item, 'name', None) == variant_value:\n-        continue\n-      return item\n-    return None\n-\n-  def step(self, dependency_states, node_builder):\n-    # Request default Variants for the subject, so that if there are any we can propagate\n-    # them to task nodes.\n-    variants = self.variants\n-    variants_node = self._variants_node()\n-    if variants_node:\n-      dep_state = dependency_states.get(variants_node, None)\n-      if dep_state is None or type(dep_state) == Waiting:\n-        return Waiting([variants_node])\n-      elif type(dep_state) == Return:\n-        # A subject's variants are overridden by any dependent's requested variants, so\n-        # we merge them left to right here.\n-        variants = Variants.merge(dep_state.value.default.items(), variants)\n-\n-    # If there is a variant_key, see whether it has been configured.\n-    variant_value = None\n-    if self.variant_key:\n-      variant_values = [value for key, value in variants\n-                        if key == self.variant_key] if variants else None\n-      if not variant_values:\n-        # Select cannot be satisfied: no variant configured for this key.\n-        return Noop('Variant key {} was not configured in variants {}'.format(\n-          self.variant_key, variants))\n-      variant_value = variant_values[0]\n-\n-    # If the Subject \"is a\" or \"has a\" Product, then we're done.\n-    literal_value = self._select_literal(self.subject, variant_value)\n-    if literal_value is not None:\n-      return Return(literal_value)\n-\n-    # Else, attempt to use a configured task to compute the value.\n-    has_waiting_dep = False\n-    dependencies = list(node_builder.task_nodes(self.subject, self.product, variants))\n-    matches = {}\n-    for dep in dependencies:\n-      dep_state = dependency_states.get(dep, None)\n-      if dep_state is None or type(dep_state) == Waiting:\n-        has_waiting_dep = True\n-        continue\n-      elif type(dep_state) == Throw:\n-        return dep_state\n-      elif type(dep_state) == Noop:\n-        continue\n-      elif type(dep_state) != Return:\n-        State.raise_unrecognized(dep_state)\n-      # We computed a value: see whether we can use it.\n-      literal_value = self._select_literal(dep_state.value, variant_value)\n-      if literal_value is not None:\n-        matches[dep] = literal_value\n-    if has_waiting_dep:\n-      return Waiting(dependencies)\n-    elif len(matches) > 1:\n-      # TODO: Multiple successful tasks are not currently supported. We should allow for this\n-      # by adding support for \"mergeable\" products. see:\n-      #   https://github.com/pantsbuild/pants/issues/2526\n-      return Throw(ConflictingProducersError(self.subject, self.product, matches))\n-    elif len(matches) == 1:\n-      return Return(matches.values()[0])\n-    return Noop('No source of {}.'.format(self))\n-\n-\n-class DependenciesNode(datatype('DependenciesNode', ['subject', 'product', 'variants', 'dep_product']), Node):\n-  \"\"\"A Node that selects the given Product for each of the dependencies of this subject.\n-\n-  Begins by selecting the `dep_product` for the subject, and then selects a product for each\n-  of dep_products' dependencies.\n-\n-  The value produced by this Node guarantees that the order of the provided values matches the\n-  order of declaration in the `dependencies` list of the `dep_product`.\n-  \"\"\"\n-\n-  def _dep_product_node(self):\n-    return SelectNode(self.subject, self.dep_product, self.variants, None)\n-\n-  def _dep_node(self, dependency):\n-    variants = self.variants\n-    if isinstance(dependency, Address):\n-      # If a subject has literal variants for particular dependencies, they win over all else.\n-      dependency, literal_variants = parse_variants(dependency)\n-      variants = Variants.merge(variants, literal_variants)\n-    return SelectNode(dependency, self.product, variants, None)\n-\n-  def step(self, dependency_states, node_builder):\n-    # Request the product we need in order to request dependencies.\n-    dep_product_node = self._dep_product_node()\n-    dep_product_state = dependency_states.get(dep_product_node, None)\n-    if dep_product_state is None or type(dep_product_state) == Waiting:\n-      return Waiting([dep_product_node])\n-    elif type(dep_product_state) == Throw:\n-      return dep_product_state\n-    elif type(dep_product_state) == Noop:\n-      return Noop('Could not compute {} to determine dependencies.'.format(dep_product_node))\n-    elif type(dep_product_state) != Return:\n-      State.raise_unrecognized(dep_product_state)\n-\n-    # The product and its dependency list are available.\n-    dep_product = dep_product_state.value\n-    dependencies = [self._dep_node(d) for d in dep_product.dependencies]\n-    for dependency in dependencies:\n-      dep_state = dependency_states.get(dependency, None)\n-      if dep_state is None or type(dep_state) == Waiting:\n-        # One of the dependencies is not yet available. Indicate that we are waiting for all\n-        # of them.\n-        return Waiting([dep_product_node] + dependencies)\n-      elif type(dep_state) == Throw:\n-        return dep_state\n-      elif type(dep_state) == Noop:\n-        return Throw(ValueError('No source of explicit dependency {}'.format(dependency)))\n-      elif type(dep_state) != Return:\n-        raise State.raise_unrecognized(dep_state)\n-    # All dependencies are present! Set our value to a list of the resulting values.\n-    return Return([dependency_states[d].value for d in dependencies])\n-\n-\n-class TaskNode(datatype('TaskNode', ['subject', 'product', 'variants', 'func', 'clause']), Node):\n-\n-  def step(self, dependency_states, node_builder):\n-    # Compute dependencies.\n-    dep_values = []\n-    dependencies = []\n-    for select in self.clause:\n-      dep = select.construct_node(self.subject, self.variants)\n-      if dep is None:\n-        return Noop('Dependency {} is not satisfiable.'.format(select))\n-      dependencies.append(dep)\n-\n-    # If all dependency Nodes are Return, execute the Node.\n-    for dep_select, dep_key in zip(self.clause, dependencies):\n-      dep_state = dependency_states.get(dep_key, None)\n-      if dep_state is None or type(dep_state) == Waiting:\n-        return Waiting(dependencies)\n-      elif type(dep_state) == Return:\n-        dep_values.append(dep_state.value)\n-      elif type(dep_state) == Noop:\n-        if dep_select.optional:\n-          dep_values.append(None)\n-        else:\n-          return Noop('Was missing (at least) input {}.'.format(dep_key))\n-      elif type(dep_state) == Throw:\n-        return dep_state\n-      else:\n-        State.raise_unrecognized(dep_state)\n-    try:\n-      return Return(self.func(*dep_values))\n-    except Exception as e:\n-      return Throw(e)\n-\n-\n class ProductGraph(object):\n",
        "source_code_with_indent": "\n<DED><DED>class ConflictingProducersError(SchedulingError):\n  <IND>\"\"\"Indicates that there was more than one source of a product for a given subject.\n\n  TODO: This will need to be legal in order to support multiple Planners producing a\n  (mergeable) Classpath for one subject, for example. see:\n    https://github.com/pantsbuild/pants/issues/2526\n  \"\"\"\n\n  def __init__(self, subject, product, matches):\n    <IND>msgs = '\\n  '.join('{}: {}'.format(k, v) for k, v in matches.items())\n    msg = 'More than one source of {} for {}:\\n  {}'.format(product.__name__, subject, msgs)\n    super(ConflictingProducersError, self).__init__(msg)\n\n\n<DED><DED>class State(object):\n  <IND>@classmethod\n  def raise_unrecognized(cls, state):\n    <IND>raise ValueError('Unrecognized Node State: {}'.format(state))\n\n\n<DED><DED>class Noop(datatype('Noop', ['msg']), State):\n  <IND>\"\"\"Indicates that a Node did not have the inputs which would be needed for it to execute.\"\"\"\n  pass\n\n\n<DED>class Return(datatype('Return', ['value']), State):\n  <IND>\"\"\"Indicates that a Node successfully returned a value.\"\"\"\n  pass\n\n\n<DED>class Throw(datatype('Throw', ['exc']), State):\n  <IND>\"\"\"Indicates that a Node should have been able to return a value, but failed.\"\"\"\n  pass\n\n\n<DED>class Waiting(datatype('Waiting', ['dependencies']), State):\n  <IND>\"\"\"Indicates that a Node is waiting for some/all of the dependencies to become available.\n\n  Some Nodes will return different dependency Nodes based on where they are in their lifecycle,\n  but all returned dependencies are recorded for the lifetime of a ProductGraph.\n  \"\"\"\n  pass\n\n\n<DED>class Node(object):\n  <IND>@abstractproperty\n  def subject(self):\n    <IND>\"\"\"The subject for this Node.\"\"\"\n\n  <DED>@abstractproperty\n  def product(self):\n    <IND>\"\"\"The output product for this Node.\"\"\"\n\n  <DED>@abstractproperty\n  def variants(self):\n    <IND>\"\"\"The variants for this Node.\"\"\"\n\n  <DED>@abstractmethod\n  def step(self, dependency_states, node_builder):\n    <IND>\"\"\"Given a dict of the dependency States for this Node, returns the current State of the Node.\n\n    The NodeBuilder parameter provides a way to construct Nodes that require information about\n    installed tasks.\n\n    After this method returns a non-Waiting state, it will never be visited again for this Node.\n    \"\"\"\n\n\n<DED><DED>class SelectNode(datatype('SelectNode', ['subject', 'product', 'variants', 'variant_key']), Node):\n  <IND>\"\"\"A Node that selects a product for a subject.\n\n  A Select can be satisfied by multiple sources, but fails if multiple sources produce a value. The\n  'variants' field represents variant configuration that is propagated to dependencies. When\n  a task needs to consume a product as configured by the variants map, it uses the SelectVariant\n  selector, which introduces the 'variant' value to restrict the names of values selected by a\n  SelectNode.\n  \"\"\"\n\n  def _variants_node(self):\n    <IND>if self.product != Variants:\n      <IND>return SelectNode(self.subject, Variants, self.variants, None)\n    <DED>return None\n\n  <DED>def _select_literal(self, candidate, variant_value):\n    <IND>\"\"\"Looks for has-a or is-a relationships between the given value and the requested product.\n\n    Returns the resulting product value, or None if no match was made.\n    \"\"\"\n    def items():\n      # Check whether the subject is-a instance of the product.\n      <IND>yield candidate\n      # Else, check whether it has-a instance of the product.\n      if isinstance(candidate, Target):\n        <IND>for configuration in candidate.configurations:\n          <IND>yield configuration\n\n    # TODO: returning only the first literal configuration of a given type/variant. Need to\n    # define mergeability for products.\n    <DED><DED><DED>for item in items():\n      <IND>if not isinstance(item, self.product):\n        <IND>continue\n      <DED>if variant_value and not getattr(item, 'name', None) == variant_value:\n        <IND>continue\n      <DED>return item\n    <DED>return None\n\n  <DED>def step(self, dependency_states, node_builder):\n    # Request default Variants for the subject, so that if there are any we can propagate\n    # them to task nodes.\n    <IND>variants = self.variants\n    variants_node = self._variants_node()\n    if variants_node:\n      <IND>dep_state = dependency_states.get(variants_node, None)\n      if dep_state is None or type(dep_state) == Waiting:\n        <IND>return Waiting([variants_node])\n      <DED>elif type(dep_state) == Return:\n        # A subject's variants are overridden by any dependent's requested variants, so\n        # we merge them left to right here.\n        <IND>variants = Variants.merge(dep_state.value.default.items(), variants)\n\n    # If there is a variant_key, see whether it has been configured.\n    <DED><DED>variant_value = None\n    if self.variant_key:\n      <IND>variant_values = [value for key, value in variants\n                        if key == self.variant_key] if variants else None\n      if not variant_values:\n        # Select cannot be satisfied: no variant configured for this key.\n        <IND>return Noop('Variant key {} was not configured in variants {}'.format(\n          self.variant_key, variants))\n      <DED>variant_value = variant_values[0]\n\n    # If the Subject \"is a\" or \"has a\" Product, then we're done.\n    <DED>literal_value = self._select_literal(self.subject, variant_value)\n    if literal_value is not None:\n      <IND>return Return(literal_value)\n\n    # Else, attempt to use a configured task to compute the value.\n    <DED>has_waiting_dep = False\n    dependencies = list(node_builder.task_nodes(self.subject, self.product, variants))\n    matches = {}\n    for dep in dependencies:\n      <IND>dep_state = dependency_states.get(dep, None)\n      if dep_state is None or type(dep_state) == Waiting:\n        <IND>has_waiting_dep = True\n        continue\n      <DED>elif type(dep_state) == Throw:\n        <IND>return dep_state\n      <DED>elif type(dep_state) == Noop:\n        <IND>continue\n      <DED>elif type(dep_state) != Return:\n        <IND>State.raise_unrecognized(dep_state)\n      # We computed a value: see whether we can use it.\n      <DED>literal_value = self._select_literal(dep_state.value, variant_value)\n      if literal_value is not None:\n        <IND>matches[dep] = literal_value\n    <DED><DED>if has_waiting_dep:\n      <IND>return Waiting(dependencies)\n    <DED>elif len(matches) > 1:\n      # TODO: Multiple successful tasks are not currently supported. We should allow for this\n      # by adding support for \"mergeable\" products. see:\n      #   https://github.com/pantsbuild/pants/issues/2526\n      <IND>return Throw(ConflictingProducersError(self.subject, self.product, matches))\n    <DED>elif len(matches) == 1:\n      <IND>return Return(matches.values()[0])\n    <DED>return Noop('No source of {}.'.format(self))\n\n\n<DED><DED>class DependenciesNode(datatype('DependenciesNode', ['subject', 'product', 'variants', 'dep_product']), Node):\n  <IND>\"\"\"A Node that selects the given Product for each of the dependencies of this subject.\n\n  Begins by selecting the `dep_product` for the subject, and then selects a product for each\n  of dep_products' dependencies.\n\n  The value produced by this Node guarantees that the order of the provided values matches the\n  order of declaration in the `dependencies` list of the `dep_product`.\n  \"\"\"\n\n  def _dep_product_node(self):\n    <IND>return SelectNode(self.subject, self.dep_product, self.variants, None)\n\n  <DED>def _dep_node(self, dependency):\n    <IND>variants = self.variants\n    if isinstance(dependency, Address):\n      # If a subject has literal variants for particular dependencies, they win over all else.\n      <IND>dependency, literal_variants = parse_variants(dependency)\n      variants = Variants.merge(variants, literal_variants)\n    <DED>return SelectNode(dependency, self.product, variants, None)\n\n  <DED>def step(self, dependency_states, node_builder):\n    # Request the product we need in order to request dependencies.\n    <IND>dep_product_node = self._dep_product_node()\n    dep_product_state = dependency_states.get(dep_product_node, None)\n    if dep_product_state is None or type(dep_product_state) == Waiting:\n      <IND>return Waiting([dep_product_node])\n    <DED>elif type(dep_product_state) == Throw:\n      <IND>return dep_product_state\n    <DED>elif type(dep_product_state) == Noop:\n      <IND>return Noop('Could not compute {} to determine dependencies.'.format(dep_product_node))\n    <DED>elif type(dep_product_state) != Return:\n      <IND>State.raise_unrecognized(dep_product_state)\n\n    # The product and its dependency list are available.\n    <DED>dep_product = dep_product_state.value\n    dependencies = [self._dep_node(d) for d in dep_product.dependencies]\n    for dependency in dependencies:\n      <IND>dep_state = dependency_states.get(dependency, None)\n      if dep_state is None or type(dep_state) == Waiting:\n        # One of the dependencies is not yet available. Indicate that we are waiting for all\n        # of them.\n        <IND>return Waiting([dep_product_node] + dependencies)\n      <DED>elif type(dep_state) == Throw:\n        <IND>return dep_state\n      <DED>elif type(dep_state) == Noop:\n        <IND>return Throw(ValueError('No source of explicit dependency {}'.format(dependency)))\n      <DED>elif type(dep_state) != Return:\n        <IND>raise State.raise_unrecognized(dep_state)\n    # All dependencies are present! Set our value to a list of the resulting values.\n    <DED><DED>return Return([dependency_states[d].value for d in dependencies])\n\n\n<DED><DED>class TaskNode(datatype('TaskNode', ['subject', 'product', 'variants', 'func', 'clause']), Node):\n\n  <IND>def step(self, dependency_states, node_builder):\n    # Compute dependencies.\n    <IND>dep_values = []\n    dependencies = []\n    for select in self.clause:\n      <IND>dep = select.construct_node(self.subject, self.variants)\n      if dep is None:\n        <IND>return Noop('Dependency {} is not satisfiable.'.format(select))\n      <DED>dependencies.append(dep)\n\n    # If all dependency Nodes are Return, execute the Node.\n    <DED>for dep_select, dep_key in zip(self.clause, dependencies):\n      <IND>dep_state = dependency_states.get(dep_key, None)\n      if dep_state is None or type(dep_state) == Waiting:\n        <IND>return Waiting(dependencies)\n      <DED>elif type(dep_state) == Return:\n        <IND>dep_values.append(dep_state.value)\n      <DED>elif type(dep_state) == Noop:\n        <IND>if dep_select.optional:\n          <IND>dep_values.append(None)\n        <DED>else:\n          <IND>return Noop('Was missing (at least) input {}.'.format(dep_key))\n      <DED><DED>elif type(dep_state) == Throw:\n        <IND>return dep_state\n      <DED>else:\n        <IND>State.raise_unrecognized(dep_state)\n    <DED><DED>try:\n      <IND>return Return(self.func(*dep_values))\n    <DED>except Exception as e:\n      <IND>return Throw(e)\n\n\n<DED><DED><DED>class ProductGraph(object):\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n<DED><DED>class ProductGraph(object):\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "pantsbuild/pants",
    "commit": "08bc2add6e98feefdce36f6f094a15e3e598b1e7",
    "filename": "src/python/pants/engine/exp/scheduler.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/pantsbuild-pants/src/python/pants/engine/exp/scheduler.py",
    "file_hunks_size": 13,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": true,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "src/python/pants/engine/exp/scheduler.py:165:12 Invalid type [31]: Expression `pants.util.objects.datatype(\"Throw\", [\"exc\"])` is not a valid type.",
    "message": " Expression `pants.util.objects.datatype(\"Throw\", [\"exc\"])` is not a valid type.",
    "rule_id": "Invalid type [31]",
    "warning_line_no": 165,
    "warning_line": "class Throw(datatype('Throw', ['exc']), State):",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": true,
        "has_suppression": false,
        "source_code": "\nclass ConflictingProducersError(SchedulingError):\n  \"\"\"Indicates that there was more than one source of a product for a given subject.\n\n  TODO: This will need to be legal in order to support multiple Planners producing a\n  (mergeable) Classpath for one subject, for example. see:\n    https://github.com/pantsbuild/pants/issues/2526\n  \"\"\"\n\n  def __init__(self, subject, product, matches):\n    msgs = '\\n  '.join('{}: {}'.format(k, v) for k, v in matches.items())\n    msg = 'More than one source of {} for {}:\\n  {}'.format(product.__name__, subject, msgs)\n    super(ConflictingProducersError, self).__init__(msg)\n\n\nclass State(object):\n  @classmethod\n  def raise_unrecognized(cls, state):\n    raise ValueError('Unrecognized Node State: {}'.format(state))\n\n\nclass Noop(datatype('Noop', ['msg']), State):\n  \"\"\"Indicates that a Node did not have the inputs which would be needed for it to execute.\"\"\"\n  pass\n\n\nclass Return(datatype('Return', ['value']), State):\n  \"\"\"Indicates that a Node successfully returned a value.\"\"\"\n  pass\n\n\nclass Throw(datatype('Throw', ['exc']), State):\n  \"\"\"Indicates that a Node should have been able to return a value, but failed.\"\"\"\n  pass\n\n\nclass Waiting(datatype('Waiting', ['dependencies']), State):\n  \"\"\"Indicates that a Node is waiting for some/all of the dependencies to become available.\n\n  Some Nodes will return different dependency Nodes based on where they are in their lifecycle,\n  but all returned dependencies are recorded for the lifetime of a ProductGraph.\n  \"\"\"\n  pass\n\n\nclass Node(object):\n  @abstractproperty\n  def subject(self):\n    \"\"\"The subject for this Node.\"\"\"\n\n  @abstractproperty\n  def product(self):\n    \"\"\"The output product for this Node.\"\"\"\n\n  @abstractproperty\n  def variants(self):\n    \"\"\"The variants for this Node.\"\"\"\n\n  @abstractmethod\n  def step(self, dependency_states, node_builder):\n    \"\"\"Given a dict of the dependency States for this Node, returns the current State of the Node.\n\n    The NodeBuilder parameter provides a way to construct Nodes that require information about\n    installed tasks.\n\n    After this method returns a non-Waiting state, it will never be visited again for this Node.\n    \"\"\"\n\n\nclass SelectNode(datatype('SelectNode', ['subject', 'product', 'variants', 'variant_key']), Node):\n  \"\"\"A Node that selects a product for a subject.\n\n  A Select can be satisfied by multiple sources, but fails if multiple sources produce a value. The\n  'variants' field represents variant configuration that is propagated to dependencies. When\n  a task needs to consume a product as configured by the variants map, it uses the SelectVariant\n  selector, which introduces the 'variant' value to restrict the names of values selected by a\n  SelectNode.\n  \"\"\"\n\n  def _variants_node(self):\n    if self.product != Variants:\n      return SelectNode(self.subject, Variants, self.variants, None)\n    return None\n\n  def _select_literal(self, candidate, variant_value):\n    \"\"\"Looks for has-a or is-a relationships between the given value and the requested product.\n\n    Returns the resulting product value, or None if no match was made.\n    \"\"\"\n    def items():\n      # Check whether the subject is-a instance of the product.\n      yield candidate\n      # Else, check whether it has-a instance of the product.\n      if isinstance(candidate, Target):\n        for configuration in candidate.configurations:\n          yield configuration\n\n    # TODO: returning only the first literal configuration of a given type/variant. Need to\n    # define mergeability for products.\n    for item in items():\n      if not isinstance(item, self.product):\n        continue\n      if variant_value and not getattr(item, 'name', None) == variant_value:\n        continue\n      return item\n    return None\n\n  def step(self, dependency_states, node_builder):\n    # Request default Variants for the subject, so that if there are any we can propagate\n    # them to task nodes.\n    variants = self.variants\n    variants_node = self._variants_node()\n    if variants_node:\n      dep_state = dependency_states.get(variants_node, None)\n      if dep_state is None or type(dep_state) == Waiting:\n        return Waiting([variants_node])\n      elif type(dep_state) == Return:\n        # A subject's variants are overridden by any dependent's requested variants, so\n        # we merge them left to right here.\n        variants = Variants.merge(dep_state.value.default.items(), variants)\n\n    # If there is a variant_key, see whether it has been configured.\n    variant_value = None\n    if self.variant_key:\n      variant_values = [value for key, value in variants\n                        if key == self.variant_key] if variants else None\n      if not variant_values:\n        # Select cannot be satisfied: no variant configured for this key.\n        return Noop('Variant key {} was not configured in variants {}'.format(\n          self.variant_key, variants))\n      variant_value = variant_values[0]\n\n    # If the Subject \"is a\" or \"has a\" Product, then we're done.\n    literal_value = self._select_literal(self.subject, variant_value)\n    if literal_value is not None:\n      return Return(literal_value)\n\n    # Else, attempt to use a configured task to compute the value.\n    has_waiting_dep = False\n    dependencies = list(node_builder.task_nodes(self.subject, self.product, variants))\n    matches = {}\n    for dep in dependencies:\n      dep_state = dependency_states.get(dep, None)\n      if dep_state is None or type(dep_state) == Waiting:\n        has_waiting_dep = True\n        continue\n      elif type(dep_state) == Throw:\n        return dep_state\n      elif type(dep_state) == Noop:\n        continue\n      elif type(dep_state) != Return:\n        State.raise_unrecognized(dep_state)\n      # We computed a value: see whether we can use it.\n      literal_value = self._select_literal(dep_state.value, variant_value)\n      if literal_value is not None:\n        matches[dep] = literal_value\n    if has_waiting_dep:\n      return Waiting(dependencies)\n    elif len(matches) > 1:\n      # TODO: Multiple successful tasks are not currently supported. We should allow for this\n      # by adding support for \"mergeable\" products. see:\n      #   https://github.com/pantsbuild/pants/issues/2526\n      return Throw(ConflictingProducersError(self.subject, self.product, matches))\n    elif len(matches) == 1:\n      return Return(matches.values()[0])\n    return Noop('No source of {}.'.format(self))\n\n\nclass DependenciesNode(datatype('DependenciesNode', ['subject', 'product', 'variants', 'dep_product']), Node):\n  \"\"\"A Node that selects the given Product for each of the dependencies of this subject.\n\n  Begins by selecting the `dep_product` for the subject, and then selects a product for each\n  of dep_products' dependencies.\n\n  The value produced by this Node guarantees that the order of the provided values matches the\n  order of declaration in the `dependencies` list of the `dep_product`.\n  \"\"\"\n\n  def _dep_product_node(self):\n    return SelectNode(self.subject, self.dep_product, self.variants, None)\n\n  def _dep_node(self, dependency):\n    variants = self.variants\n    if isinstance(dependency, Address):\n      # If a subject has literal variants for particular dependencies, they win over all else.\n      dependency, literal_variants = parse_variants(dependency)\n      variants = Variants.merge(variants, literal_variants)\n    return SelectNode(dependency, self.product, variants, None)\n\n  def step(self, dependency_states, node_builder):\n    # Request the product we need in order to request dependencies.\n    dep_product_node = self._dep_product_node()\n    dep_product_state = dependency_states.get(dep_product_node, None)\n    if dep_product_state is None or type(dep_product_state) == Waiting:\n      return Waiting([dep_product_node])\n    elif type(dep_product_state) == Throw:\n      return dep_product_state\n    elif type(dep_product_state) == Noop:\n      return Noop('Could not compute {} to determine dependencies.'.format(dep_product_node))\n    elif type(dep_product_state) != Return:\n      State.raise_unrecognized(dep_product_state)\n\n    # The product and its dependency list are available.\n    dep_product = dep_product_state.value\n    dependencies = [self._dep_node(d) for d in dep_product.dependencies]\n    for dependency in dependencies:\n      dep_state = dependency_states.get(dependency, None)\n      if dep_state is None or type(dep_state) == Waiting:\n        # One of the dependencies is not yet available. Indicate that we are waiting for all\n        # of them.\n        return Waiting([dep_product_node] + dependencies)\n      elif type(dep_state) == Throw:\n        return dep_state\n      elif type(dep_state) == Noop:\n        return Throw(ValueError('No source of explicit dependency {}'.format(dependency)))\n      elif type(dep_state) != Return:\n        raise State.raise_unrecognized(dep_state)\n    # All dependencies are present! Set our value to a list of the resulting values.\n    return Return([dependency_states[d].value for d in dependencies])\n\n\nclass TaskNode(datatype('TaskNode', ['subject', 'product', 'variants', 'func', 'clause']), Node):\n\n  def step(self, dependency_states, node_builder):\n    # Compute dependencies.\n    dep_values = []\n    dependencies = []\n    for select in self.clause:\n      dep = select.construct_node(self.subject, self.variants)\n      if dep is None:\n        return Noop('Dependency {} is not satisfiable.'.format(select))\n      dependencies.append(dep)\n\n    # If all dependency Nodes are Return, execute the Node.\n    for dep_select, dep_key in zip(self.clause, dependencies):\n      dep_state = dependency_states.get(dep_key, None)\n      if dep_state is None or type(dep_state) == Waiting:\n        return Waiting(dependencies)\n      elif type(dep_state) == Return:\n        dep_values.append(dep_state.value)\n      elif type(dep_state) == Noop:\n        if dep_select.optional:\n          dep_values.append(None)\n        else:\n          return Noop('Was missing (at least) input {}.'.format(dep_key))\n      elif type(dep_state) == Throw:\n        return dep_state\n      else:\n        State.raise_unrecognized(dep_state)\n    try:\n      return Return(self.func(*dep_values))\n    except Exception as e:\n      return Throw(e)\n\n\nclass ProductGraph(object):\n",
        "source_code_len": 10229,
        "target_code": "\nclass ProductGraph(object):\n",
        "target_code_len": 29,
        "diff_format": "@@ -134,256 +48,2 @@\n \n-class ConflictingProducersError(SchedulingError):\n-  \"\"\"Indicates that there was more than one source of a product for a given subject.\n-\n-  TODO: This will need to be legal in order to support multiple Planners producing a\n-  (mergeable) Classpath for one subject, for example. see:\n-    https://github.com/pantsbuild/pants/issues/2526\n-  \"\"\"\n-\n-  def __init__(self, subject, product, matches):\n-    msgs = '\\n  '.join('{}: {}'.format(k, v) for k, v in matches.items())\n-    msg = 'More than one source of {} for {}:\\n  {}'.format(product.__name__, subject, msgs)\n-    super(ConflictingProducersError, self).__init__(msg)\n-\n-\n-class State(object):\n-  @classmethod\n-  def raise_unrecognized(cls, state):\n-    raise ValueError('Unrecognized Node State: {}'.format(state))\n-\n-\n-class Noop(datatype('Noop', ['msg']), State):\n-  \"\"\"Indicates that a Node did not have the inputs which would be needed for it to execute.\"\"\"\n-  pass\n-\n-\n-class Return(datatype('Return', ['value']), State):\n-  \"\"\"Indicates that a Node successfully returned a value.\"\"\"\n-  pass\n-\n-\n-class Throw(datatype('Throw', ['exc']), State):\n-  \"\"\"Indicates that a Node should have been able to return a value, but failed.\"\"\"\n-  pass\n-\n-\n-class Waiting(datatype('Waiting', ['dependencies']), State):\n-  \"\"\"Indicates that a Node is waiting for some/all of the dependencies to become available.\n-\n-  Some Nodes will return different dependency Nodes based on where they are in their lifecycle,\n-  but all returned dependencies are recorded for the lifetime of a ProductGraph.\n-  \"\"\"\n-  pass\n-\n-\n-class Node(object):\n-  @abstractproperty\n-  def subject(self):\n-    \"\"\"The subject for this Node.\"\"\"\n-\n-  @abstractproperty\n-  def product(self):\n-    \"\"\"The output product for this Node.\"\"\"\n-\n-  @abstractproperty\n-  def variants(self):\n-    \"\"\"The variants for this Node.\"\"\"\n-\n-  @abstractmethod\n-  def step(self, dependency_states, node_builder):\n-    \"\"\"Given a dict of the dependency States for this Node, returns the current State of the Node.\n-\n-    The NodeBuilder parameter provides a way to construct Nodes that require information about\n-    installed tasks.\n-\n-    After this method returns a non-Waiting state, it will never be visited again for this Node.\n-    \"\"\"\n-\n-\n-class SelectNode(datatype('SelectNode', ['subject', 'product', 'variants', 'variant_key']), Node):\n-  \"\"\"A Node that selects a product for a subject.\n-\n-  A Select can be satisfied by multiple sources, but fails if multiple sources produce a value. The\n-  'variants' field represents variant configuration that is propagated to dependencies. When\n-  a task needs to consume a product as configured by the variants map, it uses the SelectVariant\n-  selector, which introduces the 'variant' value to restrict the names of values selected by a\n-  SelectNode.\n-  \"\"\"\n-\n-  def _variants_node(self):\n-    if self.product != Variants:\n-      return SelectNode(self.subject, Variants, self.variants, None)\n-    return None\n-\n-  def _select_literal(self, candidate, variant_value):\n-    \"\"\"Looks for has-a or is-a relationships between the given value and the requested product.\n-\n-    Returns the resulting product value, or None if no match was made.\n-    \"\"\"\n-    def items():\n-      # Check whether the subject is-a instance of the product.\n-      yield candidate\n-      # Else, check whether it has-a instance of the product.\n-      if isinstance(candidate, Target):\n-        for configuration in candidate.configurations:\n-          yield configuration\n-\n-    # TODO: returning only the first literal configuration of a given type/variant. Need to\n-    # define mergeability for products.\n-    for item in items():\n-      if not isinstance(item, self.product):\n-        continue\n-      if variant_value and not getattr(item, 'name', None) == variant_value:\n-        continue\n-      return item\n-    return None\n-\n-  def step(self, dependency_states, node_builder):\n-    # Request default Variants for the subject, so that if there are any we can propagate\n-    # them to task nodes.\n-    variants = self.variants\n-    variants_node = self._variants_node()\n-    if variants_node:\n-      dep_state = dependency_states.get(variants_node, None)\n-      if dep_state is None or type(dep_state) == Waiting:\n-        return Waiting([variants_node])\n-      elif type(dep_state) == Return:\n-        # A subject's variants are overridden by any dependent's requested variants, so\n-        # we merge them left to right here.\n-        variants = Variants.merge(dep_state.value.default.items(), variants)\n-\n-    # If there is a variant_key, see whether it has been configured.\n-    variant_value = None\n-    if self.variant_key:\n-      variant_values = [value for key, value in variants\n-                        if key == self.variant_key] if variants else None\n-      if not variant_values:\n-        # Select cannot be satisfied: no variant configured for this key.\n-        return Noop('Variant key {} was not configured in variants {}'.format(\n-          self.variant_key, variants))\n-      variant_value = variant_values[0]\n-\n-    # If the Subject \"is a\" or \"has a\" Product, then we're done.\n-    literal_value = self._select_literal(self.subject, variant_value)\n-    if literal_value is not None:\n-      return Return(literal_value)\n-\n-    # Else, attempt to use a configured task to compute the value.\n-    has_waiting_dep = False\n-    dependencies = list(node_builder.task_nodes(self.subject, self.product, variants))\n-    matches = {}\n-    for dep in dependencies:\n-      dep_state = dependency_states.get(dep, None)\n-      if dep_state is None or type(dep_state) == Waiting:\n-        has_waiting_dep = True\n-        continue\n-      elif type(dep_state) == Throw:\n-        return dep_state\n-      elif type(dep_state) == Noop:\n-        continue\n-      elif type(dep_state) != Return:\n-        State.raise_unrecognized(dep_state)\n-      # We computed a value: see whether we can use it.\n-      literal_value = self._select_literal(dep_state.value, variant_value)\n-      if literal_value is not None:\n-        matches[dep] = literal_value\n-    if has_waiting_dep:\n-      return Waiting(dependencies)\n-    elif len(matches) > 1:\n-      # TODO: Multiple successful tasks are not currently supported. We should allow for this\n-      # by adding support for \"mergeable\" products. see:\n-      #   https://github.com/pantsbuild/pants/issues/2526\n-      return Throw(ConflictingProducersError(self.subject, self.product, matches))\n-    elif len(matches) == 1:\n-      return Return(matches.values()[0])\n-    return Noop('No source of {}.'.format(self))\n-\n-\n-class DependenciesNode(datatype('DependenciesNode', ['subject', 'product', 'variants', 'dep_product']), Node):\n-  \"\"\"A Node that selects the given Product for each of the dependencies of this subject.\n-\n-  Begins by selecting the `dep_product` for the subject, and then selects a product for each\n-  of dep_products' dependencies.\n-\n-  The value produced by this Node guarantees that the order of the provided values matches the\n-  order of declaration in the `dependencies` list of the `dep_product`.\n-  \"\"\"\n-\n-  def _dep_product_node(self):\n-    return SelectNode(self.subject, self.dep_product, self.variants, None)\n-\n-  def _dep_node(self, dependency):\n-    variants = self.variants\n-    if isinstance(dependency, Address):\n-      # If a subject has literal variants for particular dependencies, they win over all else.\n-      dependency, literal_variants = parse_variants(dependency)\n-      variants = Variants.merge(variants, literal_variants)\n-    return SelectNode(dependency, self.product, variants, None)\n-\n-  def step(self, dependency_states, node_builder):\n-    # Request the product we need in order to request dependencies.\n-    dep_product_node = self._dep_product_node()\n-    dep_product_state = dependency_states.get(dep_product_node, None)\n-    if dep_product_state is None or type(dep_product_state) == Waiting:\n-      return Waiting([dep_product_node])\n-    elif type(dep_product_state) == Throw:\n-      return dep_product_state\n-    elif type(dep_product_state) == Noop:\n-      return Noop('Could not compute {} to determine dependencies.'.format(dep_product_node))\n-    elif type(dep_product_state) != Return:\n-      State.raise_unrecognized(dep_product_state)\n-\n-    # The product and its dependency list are available.\n-    dep_product = dep_product_state.value\n-    dependencies = [self._dep_node(d) for d in dep_product.dependencies]\n-    for dependency in dependencies:\n-      dep_state = dependency_states.get(dependency, None)\n-      if dep_state is None or type(dep_state) == Waiting:\n-        # One of the dependencies is not yet available. Indicate that we are waiting for all\n-        # of them.\n-        return Waiting([dep_product_node] + dependencies)\n-      elif type(dep_state) == Throw:\n-        return dep_state\n-      elif type(dep_state) == Noop:\n-        return Throw(ValueError('No source of explicit dependency {}'.format(dependency)))\n-      elif type(dep_state) != Return:\n-        raise State.raise_unrecognized(dep_state)\n-    # All dependencies are present! Set our value to a list of the resulting values.\n-    return Return([dependency_states[d].value for d in dependencies])\n-\n-\n-class TaskNode(datatype('TaskNode', ['subject', 'product', 'variants', 'func', 'clause']), Node):\n-\n-  def step(self, dependency_states, node_builder):\n-    # Compute dependencies.\n-    dep_values = []\n-    dependencies = []\n-    for select in self.clause:\n-      dep = select.construct_node(self.subject, self.variants)\n-      if dep is None:\n-        return Noop('Dependency {} is not satisfiable.'.format(select))\n-      dependencies.append(dep)\n-\n-    # If all dependency Nodes are Return, execute the Node.\n-    for dep_select, dep_key in zip(self.clause, dependencies):\n-      dep_state = dependency_states.get(dep_key, None)\n-      if dep_state is None or type(dep_state) == Waiting:\n-        return Waiting(dependencies)\n-      elif type(dep_state) == Return:\n-        dep_values.append(dep_state.value)\n-      elif type(dep_state) == Noop:\n-        if dep_select.optional:\n-          dep_values.append(None)\n-        else:\n-          return Noop('Was missing (at least) input {}.'.format(dep_key))\n-      elif type(dep_state) == Throw:\n-        return dep_state\n-      else:\n-        State.raise_unrecognized(dep_state)\n-    try:\n-      return Return(self.func(*dep_values))\n-    except Exception as e:\n-      return Throw(e)\n-\n-\n class ProductGraph(object):\n",
        "source_code_with_indent": "\n<DED><DED>class ConflictingProducersError(SchedulingError):\n  <IND>\"\"\"Indicates that there was more than one source of a product for a given subject.\n\n  TODO: This will need to be legal in order to support multiple Planners producing a\n  (mergeable) Classpath for one subject, for example. see:\n    https://github.com/pantsbuild/pants/issues/2526\n  \"\"\"\n\n  def __init__(self, subject, product, matches):\n    <IND>msgs = '\\n  '.join('{}: {}'.format(k, v) for k, v in matches.items())\n    msg = 'More than one source of {} for {}:\\n  {}'.format(product.__name__, subject, msgs)\n    super(ConflictingProducersError, self).__init__(msg)\n\n\n<DED><DED>class State(object):\n  <IND>@classmethod\n  def raise_unrecognized(cls, state):\n    <IND>raise ValueError('Unrecognized Node State: {}'.format(state))\n\n\n<DED><DED>class Noop(datatype('Noop', ['msg']), State):\n  <IND>\"\"\"Indicates that a Node did not have the inputs which would be needed for it to execute.\"\"\"\n  pass\n\n\n<DED>class Return(datatype('Return', ['value']), State):\n  <IND>\"\"\"Indicates that a Node successfully returned a value.\"\"\"\n  pass\n\n\n<DED>class Throw(datatype('Throw', ['exc']), State):\n  <IND>\"\"\"Indicates that a Node should have been able to return a value, but failed.\"\"\"\n  pass\n\n\n<DED>class Waiting(datatype('Waiting', ['dependencies']), State):\n  <IND>\"\"\"Indicates that a Node is waiting for some/all of the dependencies to become available.\n\n  Some Nodes will return different dependency Nodes based on where they are in their lifecycle,\n  but all returned dependencies are recorded for the lifetime of a ProductGraph.\n  \"\"\"\n  pass\n\n\n<DED>class Node(object):\n  <IND>@abstractproperty\n  def subject(self):\n    <IND>\"\"\"The subject for this Node.\"\"\"\n\n  <DED>@abstractproperty\n  def product(self):\n    <IND>\"\"\"The output product for this Node.\"\"\"\n\n  <DED>@abstractproperty\n  def variants(self):\n    <IND>\"\"\"The variants for this Node.\"\"\"\n\n  <DED>@abstractmethod\n  def step(self, dependency_states, node_builder):\n    <IND>\"\"\"Given a dict of the dependency States for this Node, returns the current State of the Node.\n\n    The NodeBuilder parameter provides a way to construct Nodes that require information about\n    installed tasks.\n\n    After this method returns a non-Waiting state, it will never be visited again for this Node.\n    \"\"\"\n\n\n<DED><DED>class SelectNode(datatype('SelectNode', ['subject', 'product', 'variants', 'variant_key']), Node):\n  <IND>\"\"\"A Node that selects a product for a subject.\n\n  A Select can be satisfied by multiple sources, but fails if multiple sources produce a value. The\n  'variants' field represents variant configuration that is propagated to dependencies. When\n  a task needs to consume a product as configured by the variants map, it uses the SelectVariant\n  selector, which introduces the 'variant' value to restrict the names of values selected by a\n  SelectNode.\n  \"\"\"\n\n  def _variants_node(self):\n    <IND>if self.product != Variants:\n      <IND>return SelectNode(self.subject, Variants, self.variants, None)\n    <DED>return None\n\n  <DED>def _select_literal(self, candidate, variant_value):\n    <IND>\"\"\"Looks for has-a or is-a relationships between the given value and the requested product.\n\n    Returns the resulting product value, or None if no match was made.\n    \"\"\"\n    def items():\n      # Check whether the subject is-a instance of the product.\n      <IND>yield candidate\n      # Else, check whether it has-a instance of the product.\n      if isinstance(candidate, Target):\n        <IND>for configuration in candidate.configurations:\n          <IND>yield configuration\n\n    # TODO: returning only the first literal configuration of a given type/variant. Need to\n    # define mergeability for products.\n    <DED><DED><DED>for item in items():\n      <IND>if not isinstance(item, self.product):\n        <IND>continue\n      <DED>if variant_value and not getattr(item, 'name', None) == variant_value:\n        <IND>continue\n      <DED>return item\n    <DED>return None\n\n  <DED>def step(self, dependency_states, node_builder):\n    # Request default Variants for the subject, so that if there are any we can propagate\n    # them to task nodes.\n    <IND>variants = self.variants\n    variants_node = self._variants_node()\n    if variants_node:\n      <IND>dep_state = dependency_states.get(variants_node, None)\n      if dep_state is None or type(dep_state) == Waiting:\n        <IND>return Waiting([variants_node])\n      <DED>elif type(dep_state) == Return:\n        # A subject's variants are overridden by any dependent's requested variants, so\n        # we merge them left to right here.\n        <IND>variants = Variants.merge(dep_state.value.default.items(), variants)\n\n    # If there is a variant_key, see whether it has been configured.\n    <DED><DED>variant_value = None\n    if self.variant_key:\n      <IND>variant_values = [value for key, value in variants\n                        if key == self.variant_key] if variants else None\n      if not variant_values:\n        # Select cannot be satisfied: no variant configured for this key.\n        <IND>return Noop('Variant key {} was not configured in variants {}'.format(\n          self.variant_key, variants))\n      <DED>variant_value = variant_values[0]\n\n    # If the Subject \"is a\" or \"has a\" Product, then we're done.\n    <DED>literal_value = self._select_literal(self.subject, variant_value)\n    if literal_value is not None:\n      <IND>return Return(literal_value)\n\n    # Else, attempt to use a configured task to compute the value.\n    <DED>has_waiting_dep = False\n    dependencies = list(node_builder.task_nodes(self.subject, self.product, variants))\n    matches = {}\n    for dep in dependencies:\n      <IND>dep_state = dependency_states.get(dep, None)\n      if dep_state is None or type(dep_state) == Waiting:\n        <IND>has_waiting_dep = True\n        continue\n      <DED>elif type(dep_state) == Throw:\n        <IND>return dep_state\n      <DED>elif type(dep_state) == Noop:\n        <IND>continue\n      <DED>elif type(dep_state) != Return:\n        <IND>State.raise_unrecognized(dep_state)\n      # We computed a value: see whether we can use it.\n      <DED>literal_value = self._select_literal(dep_state.value, variant_value)\n      if literal_value is not None:\n        <IND>matches[dep] = literal_value\n    <DED><DED>if has_waiting_dep:\n      <IND>return Waiting(dependencies)\n    <DED>elif len(matches) > 1:\n      # TODO: Multiple successful tasks are not currently supported. We should allow for this\n      # by adding support for \"mergeable\" products. see:\n      #   https://github.com/pantsbuild/pants/issues/2526\n      <IND>return Throw(ConflictingProducersError(self.subject, self.product, matches))\n    <DED>elif len(matches) == 1:\n      <IND>return Return(matches.values()[0])\n    <DED>return Noop('No source of {}.'.format(self))\n\n\n<DED><DED>class DependenciesNode(datatype('DependenciesNode', ['subject', 'product', 'variants', 'dep_product']), Node):\n  <IND>\"\"\"A Node that selects the given Product for each of the dependencies of this subject.\n\n  Begins by selecting the `dep_product` for the subject, and then selects a product for each\n  of dep_products' dependencies.\n\n  The value produced by this Node guarantees that the order of the provided values matches the\n  order of declaration in the `dependencies` list of the `dep_product`.\n  \"\"\"\n\n  def _dep_product_node(self):\n    <IND>return SelectNode(self.subject, self.dep_product, self.variants, None)\n\n  <DED>def _dep_node(self, dependency):\n    <IND>variants = self.variants\n    if isinstance(dependency, Address):\n      # If a subject has literal variants for particular dependencies, they win over all else.\n      <IND>dependency, literal_variants = parse_variants(dependency)\n      variants = Variants.merge(variants, literal_variants)\n    <DED>return SelectNode(dependency, self.product, variants, None)\n\n  <DED>def step(self, dependency_states, node_builder):\n    # Request the product we need in order to request dependencies.\n    <IND>dep_product_node = self._dep_product_node()\n    dep_product_state = dependency_states.get(dep_product_node, None)\n    if dep_product_state is None or type(dep_product_state) == Waiting:\n      <IND>return Waiting([dep_product_node])\n    <DED>elif type(dep_product_state) == Throw:\n      <IND>return dep_product_state\n    <DED>elif type(dep_product_state) == Noop:\n      <IND>return Noop('Could not compute {} to determine dependencies.'.format(dep_product_node))\n    <DED>elif type(dep_product_state) != Return:\n      <IND>State.raise_unrecognized(dep_product_state)\n\n    # The product and its dependency list are available.\n    <DED>dep_product = dep_product_state.value\n    dependencies = [self._dep_node(d) for d in dep_product.dependencies]\n    for dependency in dependencies:\n      <IND>dep_state = dependency_states.get(dependency, None)\n      if dep_state is None or type(dep_state) == Waiting:\n        # One of the dependencies is not yet available. Indicate that we are waiting for all\n        # of them.\n        <IND>return Waiting([dep_product_node] + dependencies)\n      <DED>elif type(dep_state) == Throw:\n        <IND>return dep_state\n      <DED>elif type(dep_state) == Noop:\n        <IND>return Throw(ValueError('No source of explicit dependency {}'.format(dependency)))\n      <DED>elif type(dep_state) != Return:\n        <IND>raise State.raise_unrecognized(dep_state)\n    # All dependencies are present! Set our value to a list of the resulting values.\n    <DED><DED>return Return([dependency_states[d].value for d in dependencies])\n\n\n<DED><DED>class TaskNode(datatype('TaskNode', ['subject', 'product', 'variants', 'func', 'clause']), Node):\n\n  <IND>def step(self, dependency_states, node_builder):\n    # Compute dependencies.\n    <IND>dep_values = []\n    dependencies = []\n    for select in self.clause:\n      <IND>dep = select.construct_node(self.subject, self.variants)\n      if dep is None:\n        <IND>return Noop('Dependency {} is not satisfiable.'.format(select))\n      <DED>dependencies.append(dep)\n\n    # If all dependency Nodes are Return, execute the Node.\n    <DED>for dep_select, dep_key in zip(self.clause, dependencies):\n      <IND>dep_state = dependency_states.get(dep_key, None)\n      if dep_state is None or type(dep_state) == Waiting:\n        <IND>return Waiting(dependencies)\n      <DED>elif type(dep_state) == Return:\n        <IND>dep_values.append(dep_state.value)\n      <DED>elif type(dep_state) == Noop:\n        <IND>if dep_select.optional:\n          <IND>dep_values.append(None)\n        <DED>else:\n          <IND>return Noop('Was missing (at least) input {}.'.format(dep_key))\n      <DED><DED>elif type(dep_state) == Throw:\n        <IND>return dep_state\n      <DED>else:\n        <IND>State.raise_unrecognized(dep_state)\n    <DED><DED>try:\n      <IND>return Return(self.func(*dep_values))\n    <DED>except Exception as e:\n      <IND>return Throw(e)\n\n\n<DED><DED><DED>class ProductGraph(object):\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n<DED><DED>class ProductGraph(object):\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "pantsbuild/pants",
    "commit": "08bc2add6e98feefdce36f6f094a15e3e598b1e7",
    "filename": "src/python/pants/engine/exp/scheduler.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/pantsbuild-pants/src/python/pants/engine/exp/scheduler.py",
    "file_hunks_size": 13,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": true,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "src/python/pants/engine/exp/scheduler.py:170:14 Invalid type [31]: Expression `pants.util.objects.datatype(\"Waiting\", [\"dependencies\"])` is not a valid type.",
    "message": " Expression `pants.util.objects.datatype(\"Waiting\", [\"dependencies\"])` is not a valid type.",
    "rule_id": "Invalid type [31]",
    "warning_line_no": 170,
    "warning_line": "class Waiting(datatype('Waiting', ['dependencies']), State):",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": true,
        "has_suppression": false,
        "source_code": "\nclass ConflictingProducersError(SchedulingError):\n  \"\"\"Indicates that there was more than one source of a product for a given subject.\n\n  TODO: This will need to be legal in order to support multiple Planners producing a\n  (mergeable) Classpath for one subject, for example. see:\n    https://github.com/pantsbuild/pants/issues/2526\n  \"\"\"\n\n  def __init__(self, subject, product, matches):\n    msgs = '\\n  '.join('{}: {}'.format(k, v) for k, v in matches.items())\n    msg = 'More than one source of {} for {}:\\n  {}'.format(product.__name__, subject, msgs)\n    super(ConflictingProducersError, self).__init__(msg)\n\n\nclass State(object):\n  @classmethod\n  def raise_unrecognized(cls, state):\n    raise ValueError('Unrecognized Node State: {}'.format(state))\n\n\nclass Noop(datatype('Noop', ['msg']), State):\n  \"\"\"Indicates that a Node did not have the inputs which would be needed for it to execute.\"\"\"\n  pass\n\n\nclass Return(datatype('Return', ['value']), State):\n  \"\"\"Indicates that a Node successfully returned a value.\"\"\"\n  pass\n\n\nclass Throw(datatype('Throw', ['exc']), State):\n  \"\"\"Indicates that a Node should have been able to return a value, but failed.\"\"\"\n  pass\n\n\nclass Waiting(datatype('Waiting', ['dependencies']), State):\n  \"\"\"Indicates that a Node is waiting for some/all of the dependencies to become available.\n\n  Some Nodes will return different dependency Nodes based on where they are in their lifecycle,\n  but all returned dependencies are recorded for the lifetime of a ProductGraph.\n  \"\"\"\n  pass\n\n\nclass Node(object):\n  @abstractproperty\n  def subject(self):\n    \"\"\"The subject for this Node.\"\"\"\n\n  @abstractproperty\n  def product(self):\n    \"\"\"The output product for this Node.\"\"\"\n\n  @abstractproperty\n  def variants(self):\n    \"\"\"The variants for this Node.\"\"\"\n\n  @abstractmethod\n  def step(self, dependency_states, node_builder):\n    \"\"\"Given a dict of the dependency States for this Node, returns the current State of the Node.\n\n    The NodeBuilder parameter provides a way to construct Nodes that require information about\n    installed tasks.\n\n    After this method returns a non-Waiting state, it will never be visited again for this Node.\n    \"\"\"\n\n\nclass SelectNode(datatype('SelectNode', ['subject', 'product', 'variants', 'variant_key']), Node):\n  \"\"\"A Node that selects a product for a subject.\n\n  A Select can be satisfied by multiple sources, but fails if multiple sources produce a value. The\n  'variants' field represents variant configuration that is propagated to dependencies. When\n  a task needs to consume a product as configured by the variants map, it uses the SelectVariant\n  selector, which introduces the 'variant' value to restrict the names of values selected by a\n  SelectNode.\n  \"\"\"\n\n  def _variants_node(self):\n    if self.product != Variants:\n      return SelectNode(self.subject, Variants, self.variants, None)\n    return None\n\n  def _select_literal(self, candidate, variant_value):\n    \"\"\"Looks for has-a or is-a relationships between the given value and the requested product.\n\n    Returns the resulting product value, or None if no match was made.\n    \"\"\"\n    def items():\n      # Check whether the subject is-a instance of the product.\n      yield candidate\n      # Else, check whether it has-a instance of the product.\n      if isinstance(candidate, Target):\n        for configuration in candidate.configurations:\n          yield configuration\n\n    # TODO: returning only the first literal configuration of a given type/variant. Need to\n    # define mergeability for products.\n    for item in items():\n      if not isinstance(item, self.product):\n        continue\n      if variant_value and not getattr(item, 'name', None) == variant_value:\n        continue\n      return item\n    return None\n\n  def step(self, dependency_states, node_builder):\n    # Request default Variants for the subject, so that if there are any we can propagate\n    # them to task nodes.\n    variants = self.variants\n    variants_node = self._variants_node()\n    if variants_node:\n      dep_state = dependency_states.get(variants_node, None)\n      if dep_state is None or type(dep_state) == Waiting:\n        return Waiting([variants_node])\n      elif type(dep_state) == Return:\n        # A subject's variants are overridden by any dependent's requested variants, so\n        # we merge them left to right here.\n        variants = Variants.merge(dep_state.value.default.items(), variants)\n\n    # If there is a variant_key, see whether it has been configured.\n    variant_value = None\n    if self.variant_key:\n      variant_values = [value for key, value in variants\n                        if key == self.variant_key] if variants else None\n      if not variant_values:\n        # Select cannot be satisfied: no variant configured for this key.\n        return Noop('Variant key {} was not configured in variants {}'.format(\n          self.variant_key, variants))\n      variant_value = variant_values[0]\n\n    # If the Subject \"is a\" or \"has a\" Product, then we're done.\n    literal_value = self._select_literal(self.subject, variant_value)\n    if literal_value is not None:\n      return Return(literal_value)\n\n    # Else, attempt to use a configured task to compute the value.\n    has_waiting_dep = False\n    dependencies = list(node_builder.task_nodes(self.subject, self.product, variants))\n    matches = {}\n    for dep in dependencies:\n      dep_state = dependency_states.get(dep, None)\n      if dep_state is None or type(dep_state) == Waiting:\n        has_waiting_dep = True\n        continue\n      elif type(dep_state) == Throw:\n        return dep_state\n      elif type(dep_state) == Noop:\n        continue\n      elif type(dep_state) != Return:\n        State.raise_unrecognized(dep_state)\n      # We computed a value: see whether we can use it.\n      literal_value = self._select_literal(dep_state.value, variant_value)\n      if literal_value is not None:\n        matches[dep] = literal_value\n    if has_waiting_dep:\n      return Waiting(dependencies)\n    elif len(matches) > 1:\n      # TODO: Multiple successful tasks are not currently supported. We should allow for this\n      # by adding support for \"mergeable\" products. see:\n      #   https://github.com/pantsbuild/pants/issues/2526\n      return Throw(ConflictingProducersError(self.subject, self.product, matches))\n    elif len(matches) == 1:\n      return Return(matches.values()[0])\n    return Noop('No source of {}.'.format(self))\n\n\nclass DependenciesNode(datatype('DependenciesNode', ['subject', 'product', 'variants', 'dep_product']), Node):\n  \"\"\"A Node that selects the given Product for each of the dependencies of this subject.\n\n  Begins by selecting the `dep_product` for the subject, and then selects a product for each\n  of dep_products' dependencies.\n\n  The value produced by this Node guarantees that the order of the provided values matches the\n  order of declaration in the `dependencies` list of the `dep_product`.\n  \"\"\"\n\n  def _dep_product_node(self):\n    return SelectNode(self.subject, self.dep_product, self.variants, None)\n\n  def _dep_node(self, dependency):\n    variants = self.variants\n    if isinstance(dependency, Address):\n      # If a subject has literal variants for particular dependencies, they win over all else.\n      dependency, literal_variants = parse_variants(dependency)\n      variants = Variants.merge(variants, literal_variants)\n    return SelectNode(dependency, self.product, variants, None)\n\n  def step(self, dependency_states, node_builder):\n    # Request the product we need in order to request dependencies.\n    dep_product_node = self._dep_product_node()\n    dep_product_state = dependency_states.get(dep_product_node, None)\n    if dep_product_state is None or type(dep_product_state) == Waiting:\n      return Waiting([dep_product_node])\n    elif type(dep_product_state) == Throw:\n      return dep_product_state\n    elif type(dep_product_state) == Noop:\n      return Noop('Could not compute {} to determine dependencies.'.format(dep_product_node))\n    elif type(dep_product_state) != Return:\n      State.raise_unrecognized(dep_product_state)\n\n    # The product and its dependency list are available.\n    dep_product = dep_product_state.value\n    dependencies = [self._dep_node(d) for d in dep_product.dependencies]\n    for dependency in dependencies:\n      dep_state = dependency_states.get(dependency, None)\n      if dep_state is None or type(dep_state) == Waiting:\n        # One of the dependencies is not yet available. Indicate that we are waiting for all\n        # of them.\n        return Waiting([dep_product_node] + dependencies)\n      elif type(dep_state) == Throw:\n        return dep_state\n      elif type(dep_state) == Noop:\n        return Throw(ValueError('No source of explicit dependency {}'.format(dependency)))\n      elif type(dep_state) != Return:\n        raise State.raise_unrecognized(dep_state)\n    # All dependencies are present! Set our value to a list of the resulting values.\n    return Return([dependency_states[d].value for d in dependencies])\n\n\nclass TaskNode(datatype('TaskNode', ['subject', 'product', 'variants', 'func', 'clause']), Node):\n\n  def step(self, dependency_states, node_builder):\n    # Compute dependencies.\n    dep_values = []\n    dependencies = []\n    for select in self.clause:\n      dep = select.construct_node(self.subject, self.variants)\n      if dep is None:\n        return Noop('Dependency {} is not satisfiable.'.format(select))\n      dependencies.append(dep)\n\n    # If all dependency Nodes are Return, execute the Node.\n    for dep_select, dep_key in zip(self.clause, dependencies):\n      dep_state = dependency_states.get(dep_key, None)\n      if dep_state is None or type(dep_state) == Waiting:\n        return Waiting(dependencies)\n      elif type(dep_state) == Return:\n        dep_values.append(dep_state.value)\n      elif type(dep_state) == Noop:\n        if dep_select.optional:\n          dep_values.append(None)\n        else:\n          return Noop('Was missing (at least) input {}.'.format(dep_key))\n      elif type(dep_state) == Throw:\n        return dep_state\n      else:\n        State.raise_unrecognized(dep_state)\n    try:\n      return Return(self.func(*dep_values))\n    except Exception as e:\n      return Throw(e)\n\n\nclass ProductGraph(object):\n",
        "source_code_len": 10229,
        "target_code": "\nclass ProductGraph(object):\n",
        "target_code_len": 29,
        "diff_format": "@@ -134,256 +48,2 @@\n \n-class ConflictingProducersError(SchedulingError):\n-  \"\"\"Indicates that there was more than one source of a product for a given subject.\n-\n-  TODO: This will need to be legal in order to support multiple Planners producing a\n-  (mergeable) Classpath for one subject, for example. see:\n-    https://github.com/pantsbuild/pants/issues/2526\n-  \"\"\"\n-\n-  def __init__(self, subject, product, matches):\n-    msgs = '\\n  '.join('{}: {}'.format(k, v) for k, v in matches.items())\n-    msg = 'More than one source of {} for {}:\\n  {}'.format(product.__name__, subject, msgs)\n-    super(ConflictingProducersError, self).__init__(msg)\n-\n-\n-class State(object):\n-  @classmethod\n-  def raise_unrecognized(cls, state):\n-    raise ValueError('Unrecognized Node State: {}'.format(state))\n-\n-\n-class Noop(datatype('Noop', ['msg']), State):\n-  \"\"\"Indicates that a Node did not have the inputs which would be needed for it to execute.\"\"\"\n-  pass\n-\n-\n-class Return(datatype('Return', ['value']), State):\n-  \"\"\"Indicates that a Node successfully returned a value.\"\"\"\n-  pass\n-\n-\n-class Throw(datatype('Throw', ['exc']), State):\n-  \"\"\"Indicates that a Node should have been able to return a value, but failed.\"\"\"\n-  pass\n-\n-\n-class Waiting(datatype('Waiting', ['dependencies']), State):\n-  \"\"\"Indicates that a Node is waiting for some/all of the dependencies to become available.\n-\n-  Some Nodes will return different dependency Nodes based on where they are in their lifecycle,\n-  but all returned dependencies are recorded for the lifetime of a ProductGraph.\n-  \"\"\"\n-  pass\n-\n-\n-class Node(object):\n-  @abstractproperty\n-  def subject(self):\n-    \"\"\"The subject for this Node.\"\"\"\n-\n-  @abstractproperty\n-  def product(self):\n-    \"\"\"The output product for this Node.\"\"\"\n-\n-  @abstractproperty\n-  def variants(self):\n-    \"\"\"The variants for this Node.\"\"\"\n-\n-  @abstractmethod\n-  def step(self, dependency_states, node_builder):\n-    \"\"\"Given a dict of the dependency States for this Node, returns the current State of the Node.\n-\n-    The NodeBuilder parameter provides a way to construct Nodes that require information about\n-    installed tasks.\n-\n-    After this method returns a non-Waiting state, it will never be visited again for this Node.\n-    \"\"\"\n-\n-\n-class SelectNode(datatype('SelectNode', ['subject', 'product', 'variants', 'variant_key']), Node):\n-  \"\"\"A Node that selects a product for a subject.\n-\n-  A Select can be satisfied by multiple sources, but fails if multiple sources produce a value. The\n-  'variants' field represents variant configuration that is propagated to dependencies. When\n-  a task needs to consume a product as configured by the variants map, it uses the SelectVariant\n-  selector, which introduces the 'variant' value to restrict the names of values selected by a\n-  SelectNode.\n-  \"\"\"\n-\n-  def _variants_node(self):\n-    if self.product != Variants:\n-      return SelectNode(self.subject, Variants, self.variants, None)\n-    return None\n-\n-  def _select_literal(self, candidate, variant_value):\n-    \"\"\"Looks for has-a or is-a relationships between the given value and the requested product.\n-\n-    Returns the resulting product value, or None if no match was made.\n-    \"\"\"\n-    def items():\n-      # Check whether the subject is-a instance of the product.\n-      yield candidate\n-      # Else, check whether it has-a instance of the product.\n-      if isinstance(candidate, Target):\n-        for configuration in candidate.configurations:\n-          yield configuration\n-\n-    # TODO: returning only the first literal configuration of a given type/variant. Need to\n-    # define mergeability for products.\n-    for item in items():\n-      if not isinstance(item, self.product):\n-        continue\n-      if variant_value and not getattr(item, 'name', None) == variant_value:\n-        continue\n-      return item\n-    return None\n-\n-  def step(self, dependency_states, node_builder):\n-    # Request default Variants for the subject, so that if there are any we can propagate\n-    # them to task nodes.\n-    variants = self.variants\n-    variants_node = self._variants_node()\n-    if variants_node:\n-      dep_state = dependency_states.get(variants_node, None)\n-      if dep_state is None or type(dep_state) == Waiting:\n-        return Waiting([variants_node])\n-      elif type(dep_state) == Return:\n-        # A subject's variants are overridden by any dependent's requested variants, so\n-        # we merge them left to right here.\n-        variants = Variants.merge(dep_state.value.default.items(), variants)\n-\n-    # If there is a variant_key, see whether it has been configured.\n-    variant_value = None\n-    if self.variant_key:\n-      variant_values = [value for key, value in variants\n-                        if key == self.variant_key] if variants else None\n-      if not variant_values:\n-        # Select cannot be satisfied: no variant configured for this key.\n-        return Noop('Variant key {} was not configured in variants {}'.format(\n-          self.variant_key, variants))\n-      variant_value = variant_values[0]\n-\n-    # If the Subject \"is a\" or \"has a\" Product, then we're done.\n-    literal_value = self._select_literal(self.subject, variant_value)\n-    if literal_value is not None:\n-      return Return(literal_value)\n-\n-    # Else, attempt to use a configured task to compute the value.\n-    has_waiting_dep = False\n-    dependencies = list(node_builder.task_nodes(self.subject, self.product, variants))\n-    matches = {}\n-    for dep in dependencies:\n-      dep_state = dependency_states.get(dep, None)\n-      if dep_state is None or type(dep_state) == Waiting:\n-        has_waiting_dep = True\n-        continue\n-      elif type(dep_state) == Throw:\n-        return dep_state\n-      elif type(dep_state) == Noop:\n-        continue\n-      elif type(dep_state) != Return:\n-        State.raise_unrecognized(dep_state)\n-      # We computed a value: see whether we can use it.\n-      literal_value = self._select_literal(dep_state.value, variant_value)\n-      if literal_value is not None:\n-        matches[dep] = literal_value\n-    if has_waiting_dep:\n-      return Waiting(dependencies)\n-    elif len(matches) > 1:\n-      # TODO: Multiple successful tasks are not currently supported. We should allow for this\n-      # by adding support for \"mergeable\" products. see:\n-      #   https://github.com/pantsbuild/pants/issues/2526\n-      return Throw(ConflictingProducersError(self.subject, self.product, matches))\n-    elif len(matches) == 1:\n-      return Return(matches.values()[0])\n-    return Noop('No source of {}.'.format(self))\n-\n-\n-class DependenciesNode(datatype('DependenciesNode', ['subject', 'product', 'variants', 'dep_product']), Node):\n-  \"\"\"A Node that selects the given Product for each of the dependencies of this subject.\n-\n-  Begins by selecting the `dep_product` for the subject, and then selects a product for each\n-  of dep_products' dependencies.\n-\n-  The value produced by this Node guarantees that the order of the provided values matches the\n-  order of declaration in the `dependencies` list of the `dep_product`.\n-  \"\"\"\n-\n-  def _dep_product_node(self):\n-    return SelectNode(self.subject, self.dep_product, self.variants, None)\n-\n-  def _dep_node(self, dependency):\n-    variants = self.variants\n-    if isinstance(dependency, Address):\n-      # If a subject has literal variants for particular dependencies, they win over all else.\n-      dependency, literal_variants = parse_variants(dependency)\n-      variants = Variants.merge(variants, literal_variants)\n-    return SelectNode(dependency, self.product, variants, None)\n-\n-  def step(self, dependency_states, node_builder):\n-    # Request the product we need in order to request dependencies.\n-    dep_product_node = self._dep_product_node()\n-    dep_product_state = dependency_states.get(dep_product_node, None)\n-    if dep_product_state is None or type(dep_product_state) == Waiting:\n-      return Waiting([dep_product_node])\n-    elif type(dep_product_state) == Throw:\n-      return dep_product_state\n-    elif type(dep_product_state) == Noop:\n-      return Noop('Could not compute {} to determine dependencies.'.format(dep_product_node))\n-    elif type(dep_product_state) != Return:\n-      State.raise_unrecognized(dep_product_state)\n-\n-    # The product and its dependency list are available.\n-    dep_product = dep_product_state.value\n-    dependencies = [self._dep_node(d) for d in dep_product.dependencies]\n-    for dependency in dependencies:\n-      dep_state = dependency_states.get(dependency, None)\n-      if dep_state is None or type(dep_state) == Waiting:\n-        # One of the dependencies is not yet available. Indicate that we are waiting for all\n-        # of them.\n-        return Waiting([dep_product_node] + dependencies)\n-      elif type(dep_state) == Throw:\n-        return dep_state\n-      elif type(dep_state) == Noop:\n-        return Throw(ValueError('No source of explicit dependency {}'.format(dependency)))\n-      elif type(dep_state) != Return:\n-        raise State.raise_unrecognized(dep_state)\n-    # All dependencies are present! Set our value to a list of the resulting values.\n-    return Return([dependency_states[d].value for d in dependencies])\n-\n-\n-class TaskNode(datatype('TaskNode', ['subject', 'product', 'variants', 'func', 'clause']), Node):\n-\n-  def step(self, dependency_states, node_builder):\n-    # Compute dependencies.\n-    dep_values = []\n-    dependencies = []\n-    for select in self.clause:\n-      dep = select.construct_node(self.subject, self.variants)\n-      if dep is None:\n-        return Noop('Dependency {} is not satisfiable.'.format(select))\n-      dependencies.append(dep)\n-\n-    # If all dependency Nodes are Return, execute the Node.\n-    for dep_select, dep_key in zip(self.clause, dependencies):\n-      dep_state = dependency_states.get(dep_key, None)\n-      if dep_state is None or type(dep_state) == Waiting:\n-        return Waiting(dependencies)\n-      elif type(dep_state) == Return:\n-        dep_values.append(dep_state.value)\n-      elif type(dep_state) == Noop:\n-        if dep_select.optional:\n-          dep_values.append(None)\n-        else:\n-          return Noop('Was missing (at least) input {}.'.format(dep_key))\n-      elif type(dep_state) == Throw:\n-        return dep_state\n-      else:\n-        State.raise_unrecognized(dep_state)\n-    try:\n-      return Return(self.func(*dep_values))\n-    except Exception as e:\n-      return Throw(e)\n-\n-\n class ProductGraph(object):\n",
        "source_code_with_indent": "\n<DED><DED>class ConflictingProducersError(SchedulingError):\n  <IND>\"\"\"Indicates that there was more than one source of a product for a given subject.\n\n  TODO: This will need to be legal in order to support multiple Planners producing a\n  (mergeable) Classpath for one subject, for example. see:\n    https://github.com/pantsbuild/pants/issues/2526\n  \"\"\"\n\n  def __init__(self, subject, product, matches):\n    <IND>msgs = '\\n  '.join('{}: {}'.format(k, v) for k, v in matches.items())\n    msg = 'More than one source of {} for {}:\\n  {}'.format(product.__name__, subject, msgs)\n    super(ConflictingProducersError, self).__init__(msg)\n\n\n<DED><DED>class State(object):\n  <IND>@classmethod\n  def raise_unrecognized(cls, state):\n    <IND>raise ValueError('Unrecognized Node State: {}'.format(state))\n\n\n<DED><DED>class Noop(datatype('Noop', ['msg']), State):\n  <IND>\"\"\"Indicates that a Node did not have the inputs which would be needed for it to execute.\"\"\"\n  pass\n\n\n<DED>class Return(datatype('Return', ['value']), State):\n  <IND>\"\"\"Indicates that a Node successfully returned a value.\"\"\"\n  pass\n\n\n<DED>class Throw(datatype('Throw', ['exc']), State):\n  <IND>\"\"\"Indicates that a Node should have been able to return a value, but failed.\"\"\"\n  pass\n\n\n<DED>class Waiting(datatype('Waiting', ['dependencies']), State):\n  <IND>\"\"\"Indicates that a Node is waiting for some/all of the dependencies to become available.\n\n  Some Nodes will return different dependency Nodes based on where they are in their lifecycle,\n  but all returned dependencies are recorded for the lifetime of a ProductGraph.\n  \"\"\"\n  pass\n\n\n<DED>class Node(object):\n  <IND>@abstractproperty\n  def subject(self):\n    <IND>\"\"\"The subject for this Node.\"\"\"\n\n  <DED>@abstractproperty\n  def product(self):\n    <IND>\"\"\"The output product for this Node.\"\"\"\n\n  <DED>@abstractproperty\n  def variants(self):\n    <IND>\"\"\"The variants for this Node.\"\"\"\n\n  <DED>@abstractmethod\n  def step(self, dependency_states, node_builder):\n    <IND>\"\"\"Given a dict of the dependency States for this Node, returns the current State of the Node.\n\n    The NodeBuilder parameter provides a way to construct Nodes that require information about\n    installed tasks.\n\n    After this method returns a non-Waiting state, it will never be visited again for this Node.\n    \"\"\"\n\n\n<DED><DED>class SelectNode(datatype('SelectNode', ['subject', 'product', 'variants', 'variant_key']), Node):\n  <IND>\"\"\"A Node that selects a product for a subject.\n\n  A Select can be satisfied by multiple sources, but fails if multiple sources produce a value. The\n  'variants' field represents variant configuration that is propagated to dependencies. When\n  a task needs to consume a product as configured by the variants map, it uses the SelectVariant\n  selector, which introduces the 'variant' value to restrict the names of values selected by a\n  SelectNode.\n  \"\"\"\n\n  def _variants_node(self):\n    <IND>if self.product != Variants:\n      <IND>return SelectNode(self.subject, Variants, self.variants, None)\n    <DED>return None\n\n  <DED>def _select_literal(self, candidate, variant_value):\n    <IND>\"\"\"Looks for has-a or is-a relationships between the given value and the requested product.\n\n    Returns the resulting product value, or None if no match was made.\n    \"\"\"\n    def items():\n      # Check whether the subject is-a instance of the product.\n      <IND>yield candidate\n      # Else, check whether it has-a instance of the product.\n      if isinstance(candidate, Target):\n        <IND>for configuration in candidate.configurations:\n          <IND>yield configuration\n\n    # TODO: returning only the first literal configuration of a given type/variant. Need to\n    # define mergeability for products.\n    <DED><DED><DED>for item in items():\n      <IND>if not isinstance(item, self.product):\n        <IND>continue\n      <DED>if variant_value and not getattr(item, 'name', None) == variant_value:\n        <IND>continue\n      <DED>return item\n    <DED>return None\n\n  <DED>def step(self, dependency_states, node_builder):\n    # Request default Variants for the subject, so that if there are any we can propagate\n    # them to task nodes.\n    <IND>variants = self.variants\n    variants_node = self._variants_node()\n    if variants_node:\n      <IND>dep_state = dependency_states.get(variants_node, None)\n      if dep_state is None or type(dep_state) == Waiting:\n        <IND>return Waiting([variants_node])\n      <DED>elif type(dep_state) == Return:\n        # A subject's variants are overridden by any dependent's requested variants, so\n        # we merge them left to right here.\n        <IND>variants = Variants.merge(dep_state.value.default.items(), variants)\n\n    # If there is a variant_key, see whether it has been configured.\n    <DED><DED>variant_value = None\n    if self.variant_key:\n      <IND>variant_values = [value for key, value in variants\n                        if key == self.variant_key] if variants else None\n      if not variant_values:\n        # Select cannot be satisfied: no variant configured for this key.\n        <IND>return Noop('Variant key {} was not configured in variants {}'.format(\n          self.variant_key, variants))\n      <DED>variant_value = variant_values[0]\n\n    # If the Subject \"is a\" or \"has a\" Product, then we're done.\n    <DED>literal_value = self._select_literal(self.subject, variant_value)\n    if literal_value is not None:\n      <IND>return Return(literal_value)\n\n    # Else, attempt to use a configured task to compute the value.\n    <DED>has_waiting_dep = False\n    dependencies = list(node_builder.task_nodes(self.subject, self.product, variants))\n    matches = {}\n    for dep in dependencies:\n      <IND>dep_state = dependency_states.get(dep, None)\n      if dep_state is None or type(dep_state) == Waiting:\n        <IND>has_waiting_dep = True\n        continue\n      <DED>elif type(dep_state) == Throw:\n        <IND>return dep_state\n      <DED>elif type(dep_state) == Noop:\n        <IND>continue\n      <DED>elif type(dep_state) != Return:\n        <IND>State.raise_unrecognized(dep_state)\n      # We computed a value: see whether we can use it.\n      <DED>literal_value = self._select_literal(dep_state.value, variant_value)\n      if literal_value is not None:\n        <IND>matches[dep] = literal_value\n    <DED><DED>if has_waiting_dep:\n      <IND>return Waiting(dependencies)\n    <DED>elif len(matches) > 1:\n      # TODO: Multiple successful tasks are not currently supported. We should allow for this\n      # by adding support for \"mergeable\" products. see:\n      #   https://github.com/pantsbuild/pants/issues/2526\n      <IND>return Throw(ConflictingProducersError(self.subject, self.product, matches))\n    <DED>elif len(matches) == 1:\n      <IND>return Return(matches.values()[0])\n    <DED>return Noop('No source of {}.'.format(self))\n\n\n<DED><DED>class DependenciesNode(datatype('DependenciesNode', ['subject', 'product', 'variants', 'dep_product']), Node):\n  <IND>\"\"\"A Node that selects the given Product for each of the dependencies of this subject.\n\n  Begins by selecting the `dep_product` for the subject, and then selects a product for each\n  of dep_products' dependencies.\n\n  The value produced by this Node guarantees that the order of the provided values matches the\n  order of declaration in the `dependencies` list of the `dep_product`.\n  \"\"\"\n\n  def _dep_product_node(self):\n    <IND>return SelectNode(self.subject, self.dep_product, self.variants, None)\n\n  <DED>def _dep_node(self, dependency):\n    <IND>variants = self.variants\n    if isinstance(dependency, Address):\n      # If a subject has literal variants for particular dependencies, they win over all else.\n      <IND>dependency, literal_variants = parse_variants(dependency)\n      variants = Variants.merge(variants, literal_variants)\n    <DED>return SelectNode(dependency, self.product, variants, None)\n\n  <DED>def step(self, dependency_states, node_builder):\n    # Request the product we need in order to request dependencies.\n    <IND>dep_product_node = self._dep_product_node()\n    dep_product_state = dependency_states.get(dep_product_node, None)\n    if dep_product_state is None or type(dep_product_state) == Waiting:\n      <IND>return Waiting([dep_product_node])\n    <DED>elif type(dep_product_state) == Throw:\n      <IND>return dep_product_state\n    <DED>elif type(dep_product_state) == Noop:\n      <IND>return Noop('Could not compute {} to determine dependencies.'.format(dep_product_node))\n    <DED>elif type(dep_product_state) != Return:\n      <IND>State.raise_unrecognized(dep_product_state)\n\n    # The product and its dependency list are available.\n    <DED>dep_product = dep_product_state.value\n    dependencies = [self._dep_node(d) for d in dep_product.dependencies]\n    for dependency in dependencies:\n      <IND>dep_state = dependency_states.get(dependency, None)\n      if dep_state is None or type(dep_state) == Waiting:\n        # One of the dependencies is not yet available. Indicate that we are waiting for all\n        # of them.\n        <IND>return Waiting([dep_product_node] + dependencies)\n      <DED>elif type(dep_state) == Throw:\n        <IND>return dep_state\n      <DED>elif type(dep_state) == Noop:\n        <IND>return Throw(ValueError('No source of explicit dependency {}'.format(dependency)))\n      <DED>elif type(dep_state) != Return:\n        <IND>raise State.raise_unrecognized(dep_state)\n    # All dependencies are present! Set our value to a list of the resulting values.\n    <DED><DED>return Return([dependency_states[d].value for d in dependencies])\n\n\n<DED><DED>class TaskNode(datatype('TaskNode', ['subject', 'product', 'variants', 'func', 'clause']), Node):\n\n  <IND>def step(self, dependency_states, node_builder):\n    # Compute dependencies.\n    <IND>dep_values = []\n    dependencies = []\n    for select in self.clause:\n      <IND>dep = select.construct_node(self.subject, self.variants)\n      if dep is None:\n        <IND>return Noop('Dependency {} is not satisfiable.'.format(select))\n      <DED>dependencies.append(dep)\n\n    # If all dependency Nodes are Return, execute the Node.\n    <DED>for dep_select, dep_key in zip(self.clause, dependencies):\n      <IND>dep_state = dependency_states.get(dep_key, None)\n      if dep_state is None or type(dep_state) == Waiting:\n        <IND>return Waiting(dependencies)\n      <DED>elif type(dep_state) == Return:\n        <IND>dep_values.append(dep_state.value)\n      <DED>elif type(dep_state) == Noop:\n        <IND>if dep_select.optional:\n          <IND>dep_values.append(None)\n        <DED>else:\n          <IND>return Noop('Was missing (at least) input {}.'.format(dep_key))\n      <DED><DED>elif type(dep_state) == Throw:\n        <IND>return dep_state\n      <DED>else:\n        <IND>State.raise_unrecognized(dep_state)\n    <DED><DED>try:\n      <IND>return Return(self.func(*dep_values))\n    <DED>except Exception as e:\n      <IND>return Throw(e)\n\n\n<DED><DED><DED>class ProductGraph(object):\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n<DED><DED>class ProductGraph(object):\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "pantsbuild/pants",
    "commit": "08bc2add6e98feefdce36f6f094a15e3e598b1e7",
    "filename": "src/python/pants/engine/exp/scheduler.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/pantsbuild-pants/src/python/pants/engine/exp/scheduler.py",
    "file_hunks_size": 13,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": true,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "src/python/pants/engine/exp/scheduler.py:203:17 Invalid type [31]: Expression `pants.util.objects.datatype(\"SelectNode\", [\"subject\", \"product\", \"variants\", \"variant_key\"])` is not a valid type.",
    "message": " Expression `pants.util.objects.datatype(\"SelectNode\", [\"subject\", \"product\", \"variants\", \"variant_key\"])` is not a valid type.",
    "rule_id": "Invalid type [31]",
    "warning_line_no": 203,
    "warning_line": "class SelectNode(datatype('SelectNode', ['subject', 'product', 'variants', 'variant_key']), Node):",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": true,
        "has_suppression": false,
        "source_code": "\nclass ConflictingProducersError(SchedulingError):\n  \"\"\"Indicates that there was more than one source of a product for a given subject.\n\n  TODO: This will need to be legal in order to support multiple Planners producing a\n  (mergeable) Classpath for one subject, for example. see:\n    https://github.com/pantsbuild/pants/issues/2526\n  \"\"\"\n\n  def __init__(self, subject, product, matches):\n    msgs = '\\n  '.join('{}: {}'.format(k, v) for k, v in matches.items())\n    msg = 'More than one source of {} for {}:\\n  {}'.format(product.__name__, subject, msgs)\n    super(ConflictingProducersError, self).__init__(msg)\n\n\nclass State(object):\n  @classmethod\n  def raise_unrecognized(cls, state):\n    raise ValueError('Unrecognized Node State: {}'.format(state))\n\n\nclass Noop(datatype('Noop', ['msg']), State):\n  \"\"\"Indicates that a Node did not have the inputs which would be needed for it to execute.\"\"\"\n  pass\n\n\nclass Return(datatype('Return', ['value']), State):\n  \"\"\"Indicates that a Node successfully returned a value.\"\"\"\n  pass\n\n\nclass Throw(datatype('Throw', ['exc']), State):\n  \"\"\"Indicates that a Node should have been able to return a value, but failed.\"\"\"\n  pass\n\n\nclass Waiting(datatype('Waiting', ['dependencies']), State):\n  \"\"\"Indicates that a Node is waiting for some/all of the dependencies to become available.\n\n  Some Nodes will return different dependency Nodes based on where they are in their lifecycle,\n  but all returned dependencies are recorded for the lifetime of a ProductGraph.\n  \"\"\"\n  pass\n\n\nclass Node(object):\n  @abstractproperty\n  def subject(self):\n    \"\"\"The subject for this Node.\"\"\"\n\n  @abstractproperty\n  def product(self):\n    \"\"\"The output product for this Node.\"\"\"\n\n  @abstractproperty\n  def variants(self):\n    \"\"\"The variants for this Node.\"\"\"\n\n  @abstractmethod\n  def step(self, dependency_states, node_builder):\n    \"\"\"Given a dict of the dependency States for this Node, returns the current State of the Node.\n\n    The NodeBuilder parameter provides a way to construct Nodes that require information about\n    installed tasks.\n\n    After this method returns a non-Waiting state, it will never be visited again for this Node.\n    \"\"\"\n\n\nclass SelectNode(datatype('SelectNode', ['subject', 'product', 'variants', 'variant_key']), Node):\n  \"\"\"A Node that selects a product for a subject.\n\n  A Select can be satisfied by multiple sources, but fails if multiple sources produce a value. The\n  'variants' field represents variant configuration that is propagated to dependencies. When\n  a task needs to consume a product as configured by the variants map, it uses the SelectVariant\n  selector, which introduces the 'variant' value to restrict the names of values selected by a\n  SelectNode.\n  \"\"\"\n\n  def _variants_node(self):\n    if self.product != Variants:\n      return SelectNode(self.subject, Variants, self.variants, None)\n    return None\n\n  def _select_literal(self, candidate, variant_value):\n    \"\"\"Looks for has-a or is-a relationships between the given value and the requested product.\n\n    Returns the resulting product value, or None if no match was made.\n    \"\"\"\n    def items():\n      # Check whether the subject is-a instance of the product.\n      yield candidate\n      # Else, check whether it has-a instance of the product.\n      if isinstance(candidate, Target):\n        for configuration in candidate.configurations:\n          yield configuration\n\n    # TODO: returning only the first literal configuration of a given type/variant. Need to\n    # define mergeability for products.\n    for item in items():\n      if not isinstance(item, self.product):\n        continue\n      if variant_value and not getattr(item, 'name', None) == variant_value:\n        continue\n      return item\n    return None\n\n  def step(self, dependency_states, node_builder):\n    # Request default Variants for the subject, so that if there are any we can propagate\n    # them to task nodes.\n    variants = self.variants\n    variants_node = self._variants_node()\n    if variants_node:\n      dep_state = dependency_states.get(variants_node, None)\n      if dep_state is None or type(dep_state) == Waiting:\n        return Waiting([variants_node])\n      elif type(dep_state) == Return:\n        # A subject's variants are overridden by any dependent's requested variants, so\n        # we merge them left to right here.\n        variants = Variants.merge(dep_state.value.default.items(), variants)\n\n    # If there is a variant_key, see whether it has been configured.\n    variant_value = None\n    if self.variant_key:\n      variant_values = [value for key, value in variants\n                        if key == self.variant_key] if variants else None\n      if not variant_values:\n        # Select cannot be satisfied: no variant configured for this key.\n        return Noop('Variant key {} was not configured in variants {}'.format(\n          self.variant_key, variants))\n      variant_value = variant_values[0]\n\n    # If the Subject \"is a\" or \"has a\" Product, then we're done.\n    literal_value = self._select_literal(self.subject, variant_value)\n    if literal_value is not None:\n      return Return(literal_value)\n\n    # Else, attempt to use a configured task to compute the value.\n    has_waiting_dep = False\n    dependencies = list(node_builder.task_nodes(self.subject, self.product, variants))\n    matches = {}\n    for dep in dependencies:\n      dep_state = dependency_states.get(dep, None)\n      if dep_state is None or type(dep_state) == Waiting:\n        has_waiting_dep = True\n        continue\n      elif type(dep_state) == Throw:\n        return dep_state\n      elif type(dep_state) == Noop:\n        continue\n      elif type(dep_state) != Return:\n        State.raise_unrecognized(dep_state)\n      # We computed a value: see whether we can use it.\n      literal_value = self._select_literal(dep_state.value, variant_value)\n      if literal_value is not None:\n        matches[dep] = literal_value\n    if has_waiting_dep:\n      return Waiting(dependencies)\n    elif len(matches) > 1:\n      # TODO: Multiple successful tasks are not currently supported. We should allow for this\n      # by adding support for \"mergeable\" products. see:\n      #   https://github.com/pantsbuild/pants/issues/2526\n      return Throw(ConflictingProducersError(self.subject, self.product, matches))\n    elif len(matches) == 1:\n      return Return(matches.values()[0])\n    return Noop('No source of {}.'.format(self))\n\n\nclass DependenciesNode(datatype('DependenciesNode', ['subject', 'product', 'variants', 'dep_product']), Node):\n  \"\"\"A Node that selects the given Product for each of the dependencies of this subject.\n\n  Begins by selecting the `dep_product` for the subject, and then selects a product for each\n  of dep_products' dependencies.\n\n  The value produced by this Node guarantees that the order of the provided values matches the\n  order of declaration in the `dependencies` list of the `dep_product`.\n  \"\"\"\n\n  def _dep_product_node(self):\n    return SelectNode(self.subject, self.dep_product, self.variants, None)\n\n  def _dep_node(self, dependency):\n    variants = self.variants\n    if isinstance(dependency, Address):\n      # If a subject has literal variants for particular dependencies, they win over all else.\n      dependency, literal_variants = parse_variants(dependency)\n      variants = Variants.merge(variants, literal_variants)\n    return SelectNode(dependency, self.product, variants, None)\n\n  def step(self, dependency_states, node_builder):\n    # Request the product we need in order to request dependencies.\n    dep_product_node = self._dep_product_node()\n    dep_product_state = dependency_states.get(dep_product_node, None)\n    if dep_product_state is None or type(dep_product_state) == Waiting:\n      return Waiting([dep_product_node])\n    elif type(dep_product_state) == Throw:\n      return dep_product_state\n    elif type(dep_product_state) == Noop:\n      return Noop('Could not compute {} to determine dependencies.'.format(dep_product_node))\n    elif type(dep_product_state) != Return:\n      State.raise_unrecognized(dep_product_state)\n\n    # The product and its dependency list are available.\n    dep_product = dep_product_state.value\n    dependencies = [self._dep_node(d) for d in dep_product.dependencies]\n    for dependency in dependencies:\n      dep_state = dependency_states.get(dependency, None)\n      if dep_state is None or type(dep_state) == Waiting:\n        # One of the dependencies is not yet available. Indicate that we are waiting for all\n        # of them.\n        return Waiting([dep_product_node] + dependencies)\n      elif type(dep_state) == Throw:\n        return dep_state\n      elif type(dep_state) == Noop:\n        return Throw(ValueError('No source of explicit dependency {}'.format(dependency)))\n      elif type(dep_state) != Return:\n        raise State.raise_unrecognized(dep_state)\n    # All dependencies are present! Set our value to a list of the resulting values.\n    return Return([dependency_states[d].value for d in dependencies])\n\n\nclass TaskNode(datatype('TaskNode', ['subject', 'product', 'variants', 'func', 'clause']), Node):\n\n  def step(self, dependency_states, node_builder):\n    # Compute dependencies.\n    dep_values = []\n    dependencies = []\n    for select in self.clause:\n      dep = select.construct_node(self.subject, self.variants)\n      if dep is None:\n        return Noop('Dependency {} is not satisfiable.'.format(select))\n      dependencies.append(dep)\n\n    # If all dependency Nodes are Return, execute the Node.\n    for dep_select, dep_key in zip(self.clause, dependencies):\n      dep_state = dependency_states.get(dep_key, None)\n      if dep_state is None or type(dep_state) == Waiting:\n        return Waiting(dependencies)\n      elif type(dep_state) == Return:\n        dep_values.append(dep_state.value)\n      elif type(dep_state) == Noop:\n        if dep_select.optional:\n          dep_values.append(None)\n        else:\n          return Noop('Was missing (at least) input {}.'.format(dep_key))\n      elif type(dep_state) == Throw:\n        return dep_state\n      else:\n        State.raise_unrecognized(dep_state)\n    try:\n      return Return(self.func(*dep_values))\n    except Exception as e:\n      return Throw(e)\n\n\nclass ProductGraph(object):\n",
        "source_code_len": 10229,
        "target_code": "\nclass ProductGraph(object):\n",
        "target_code_len": 29,
        "diff_format": "@@ -134,256 +48,2 @@\n \n-class ConflictingProducersError(SchedulingError):\n-  \"\"\"Indicates that there was more than one source of a product for a given subject.\n-\n-  TODO: This will need to be legal in order to support multiple Planners producing a\n-  (mergeable) Classpath for one subject, for example. see:\n-    https://github.com/pantsbuild/pants/issues/2526\n-  \"\"\"\n-\n-  def __init__(self, subject, product, matches):\n-    msgs = '\\n  '.join('{}: {}'.format(k, v) for k, v in matches.items())\n-    msg = 'More than one source of {} for {}:\\n  {}'.format(product.__name__, subject, msgs)\n-    super(ConflictingProducersError, self).__init__(msg)\n-\n-\n-class State(object):\n-  @classmethod\n-  def raise_unrecognized(cls, state):\n-    raise ValueError('Unrecognized Node State: {}'.format(state))\n-\n-\n-class Noop(datatype('Noop', ['msg']), State):\n-  \"\"\"Indicates that a Node did not have the inputs which would be needed for it to execute.\"\"\"\n-  pass\n-\n-\n-class Return(datatype('Return', ['value']), State):\n-  \"\"\"Indicates that a Node successfully returned a value.\"\"\"\n-  pass\n-\n-\n-class Throw(datatype('Throw', ['exc']), State):\n-  \"\"\"Indicates that a Node should have been able to return a value, but failed.\"\"\"\n-  pass\n-\n-\n-class Waiting(datatype('Waiting', ['dependencies']), State):\n-  \"\"\"Indicates that a Node is waiting for some/all of the dependencies to become available.\n-\n-  Some Nodes will return different dependency Nodes based on where they are in their lifecycle,\n-  but all returned dependencies are recorded for the lifetime of a ProductGraph.\n-  \"\"\"\n-  pass\n-\n-\n-class Node(object):\n-  @abstractproperty\n-  def subject(self):\n-    \"\"\"The subject for this Node.\"\"\"\n-\n-  @abstractproperty\n-  def product(self):\n-    \"\"\"The output product for this Node.\"\"\"\n-\n-  @abstractproperty\n-  def variants(self):\n-    \"\"\"The variants for this Node.\"\"\"\n-\n-  @abstractmethod\n-  def step(self, dependency_states, node_builder):\n-    \"\"\"Given a dict of the dependency States for this Node, returns the current State of the Node.\n-\n-    The NodeBuilder parameter provides a way to construct Nodes that require information about\n-    installed tasks.\n-\n-    After this method returns a non-Waiting state, it will never be visited again for this Node.\n-    \"\"\"\n-\n-\n-class SelectNode(datatype('SelectNode', ['subject', 'product', 'variants', 'variant_key']), Node):\n-  \"\"\"A Node that selects a product for a subject.\n-\n-  A Select can be satisfied by multiple sources, but fails if multiple sources produce a value. The\n-  'variants' field represents variant configuration that is propagated to dependencies. When\n-  a task needs to consume a product as configured by the variants map, it uses the SelectVariant\n-  selector, which introduces the 'variant' value to restrict the names of values selected by a\n-  SelectNode.\n-  \"\"\"\n-\n-  def _variants_node(self):\n-    if self.product != Variants:\n-      return SelectNode(self.subject, Variants, self.variants, None)\n-    return None\n-\n-  def _select_literal(self, candidate, variant_value):\n-    \"\"\"Looks for has-a or is-a relationships between the given value and the requested product.\n-\n-    Returns the resulting product value, or None if no match was made.\n-    \"\"\"\n-    def items():\n-      # Check whether the subject is-a instance of the product.\n-      yield candidate\n-      # Else, check whether it has-a instance of the product.\n-      if isinstance(candidate, Target):\n-        for configuration in candidate.configurations:\n-          yield configuration\n-\n-    # TODO: returning only the first literal configuration of a given type/variant. Need to\n-    # define mergeability for products.\n-    for item in items():\n-      if not isinstance(item, self.product):\n-        continue\n-      if variant_value and not getattr(item, 'name', None) == variant_value:\n-        continue\n-      return item\n-    return None\n-\n-  def step(self, dependency_states, node_builder):\n-    # Request default Variants for the subject, so that if there are any we can propagate\n-    # them to task nodes.\n-    variants = self.variants\n-    variants_node = self._variants_node()\n-    if variants_node:\n-      dep_state = dependency_states.get(variants_node, None)\n-      if dep_state is None or type(dep_state) == Waiting:\n-        return Waiting([variants_node])\n-      elif type(dep_state) == Return:\n-        # A subject's variants are overridden by any dependent's requested variants, so\n-        # we merge them left to right here.\n-        variants = Variants.merge(dep_state.value.default.items(), variants)\n-\n-    # If there is a variant_key, see whether it has been configured.\n-    variant_value = None\n-    if self.variant_key:\n-      variant_values = [value for key, value in variants\n-                        if key == self.variant_key] if variants else None\n-      if not variant_values:\n-        # Select cannot be satisfied: no variant configured for this key.\n-        return Noop('Variant key {} was not configured in variants {}'.format(\n-          self.variant_key, variants))\n-      variant_value = variant_values[0]\n-\n-    # If the Subject \"is a\" or \"has a\" Product, then we're done.\n-    literal_value = self._select_literal(self.subject, variant_value)\n-    if literal_value is not None:\n-      return Return(literal_value)\n-\n-    # Else, attempt to use a configured task to compute the value.\n-    has_waiting_dep = False\n-    dependencies = list(node_builder.task_nodes(self.subject, self.product, variants))\n-    matches = {}\n-    for dep in dependencies:\n-      dep_state = dependency_states.get(dep, None)\n-      if dep_state is None or type(dep_state) == Waiting:\n-        has_waiting_dep = True\n-        continue\n-      elif type(dep_state) == Throw:\n-        return dep_state\n-      elif type(dep_state) == Noop:\n-        continue\n-      elif type(dep_state) != Return:\n-        State.raise_unrecognized(dep_state)\n-      # We computed a value: see whether we can use it.\n-      literal_value = self._select_literal(dep_state.value, variant_value)\n-      if literal_value is not None:\n-        matches[dep] = literal_value\n-    if has_waiting_dep:\n-      return Waiting(dependencies)\n-    elif len(matches) > 1:\n-      # TODO: Multiple successful tasks are not currently supported. We should allow for this\n-      # by adding support for \"mergeable\" products. see:\n-      #   https://github.com/pantsbuild/pants/issues/2526\n-      return Throw(ConflictingProducersError(self.subject, self.product, matches))\n-    elif len(matches) == 1:\n-      return Return(matches.values()[0])\n-    return Noop('No source of {}.'.format(self))\n-\n-\n-class DependenciesNode(datatype('DependenciesNode', ['subject', 'product', 'variants', 'dep_product']), Node):\n-  \"\"\"A Node that selects the given Product for each of the dependencies of this subject.\n-\n-  Begins by selecting the `dep_product` for the subject, and then selects a product for each\n-  of dep_products' dependencies.\n-\n-  The value produced by this Node guarantees that the order of the provided values matches the\n-  order of declaration in the `dependencies` list of the `dep_product`.\n-  \"\"\"\n-\n-  def _dep_product_node(self):\n-    return SelectNode(self.subject, self.dep_product, self.variants, None)\n-\n-  def _dep_node(self, dependency):\n-    variants = self.variants\n-    if isinstance(dependency, Address):\n-      # If a subject has literal variants for particular dependencies, they win over all else.\n-      dependency, literal_variants = parse_variants(dependency)\n-      variants = Variants.merge(variants, literal_variants)\n-    return SelectNode(dependency, self.product, variants, None)\n-\n-  def step(self, dependency_states, node_builder):\n-    # Request the product we need in order to request dependencies.\n-    dep_product_node = self._dep_product_node()\n-    dep_product_state = dependency_states.get(dep_product_node, None)\n-    if dep_product_state is None or type(dep_product_state) == Waiting:\n-      return Waiting([dep_product_node])\n-    elif type(dep_product_state) == Throw:\n-      return dep_product_state\n-    elif type(dep_product_state) == Noop:\n-      return Noop('Could not compute {} to determine dependencies.'.format(dep_product_node))\n-    elif type(dep_product_state) != Return:\n-      State.raise_unrecognized(dep_product_state)\n-\n-    # The product and its dependency list are available.\n-    dep_product = dep_product_state.value\n-    dependencies = [self._dep_node(d) for d in dep_product.dependencies]\n-    for dependency in dependencies:\n-      dep_state = dependency_states.get(dependency, None)\n-      if dep_state is None or type(dep_state) == Waiting:\n-        # One of the dependencies is not yet available. Indicate that we are waiting for all\n-        # of them.\n-        return Waiting([dep_product_node] + dependencies)\n-      elif type(dep_state) == Throw:\n-        return dep_state\n-      elif type(dep_state) == Noop:\n-        return Throw(ValueError('No source of explicit dependency {}'.format(dependency)))\n-      elif type(dep_state) != Return:\n-        raise State.raise_unrecognized(dep_state)\n-    # All dependencies are present! Set our value to a list of the resulting values.\n-    return Return([dependency_states[d].value for d in dependencies])\n-\n-\n-class TaskNode(datatype('TaskNode', ['subject', 'product', 'variants', 'func', 'clause']), Node):\n-\n-  def step(self, dependency_states, node_builder):\n-    # Compute dependencies.\n-    dep_values = []\n-    dependencies = []\n-    for select in self.clause:\n-      dep = select.construct_node(self.subject, self.variants)\n-      if dep is None:\n-        return Noop('Dependency {} is not satisfiable.'.format(select))\n-      dependencies.append(dep)\n-\n-    # If all dependency Nodes are Return, execute the Node.\n-    for dep_select, dep_key in zip(self.clause, dependencies):\n-      dep_state = dependency_states.get(dep_key, None)\n-      if dep_state is None or type(dep_state) == Waiting:\n-        return Waiting(dependencies)\n-      elif type(dep_state) == Return:\n-        dep_values.append(dep_state.value)\n-      elif type(dep_state) == Noop:\n-        if dep_select.optional:\n-          dep_values.append(None)\n-        else:\n-          return Noop('Was missing (at least) input {}.'.format(dep_key))\n-      elif type(dep_state) == Throw:\n-        return dep_state\n-      else:\n-        State.raise_unrecognized(dep_state)\n-    try:\n-      return Return(self.func(*dep_values))\n-    except Exception as e:\n-      return Throw(e)\n-\n-\n class ProductGraph(object):\n",
        "source_code_with_indent": "\n<DED><DED>class ConflictingProducersError(SchedulingError):\n  <IND>\"\"\"Indicates that there was more than one source of a product for a given subject.\n\n  TODO: This will need to be legal in order to support multiple Planners producing a\n  (mergeable) Classpath for one subject, for example. see:\n    https://github.com/pantsbuild/pants/issues/2526\n  \"\"\"\n\n  def __init__(self, subject, product, matches):\n    <IND>msgs = '\\n  '.join('{}: {}'.format(k, v) for k, v in matches.items())\n    msg = 'More than one source of {} for {}:\\n  {}'.format(product.__name__, subject, msgs)\n    super(ConflictingProducersError, self).__init__(msg)\n\n\n<DED><DED>class State(object):\n  <IND>@classmethod\n  def raise_unrecognized(cls, state):\n    <IND>raise ValueError('Unrecognized Node State: {}'.format(state))\n\n\n<DED><DED>class Noop(datatype('Noop', ['msg']), State):\n  <IND>\"\"\"Indicates that a Node did not have the inputs which would be needed for it to execute.\"\"\"\n  pass\n\n\n<DED>class Return(datatype('Return', ['value']), State):\n  <IND>\"\"\"Indicates that a Node successfully returned a value.\"\"\"\n  pass\n\n\n<DED>class Throw(datatype('Throw', ['exc']), State):\n  <IND>\"\"\"Indicates that a Node should have been able to return a value, but failed.\"\"\"\n  pass\n\n\n<DED>class Waiting(datatype('Waiting', ['dependencies']), State):\n  <IND>\"\"\"Indicates that a Node is waiting for some/all of the dependencies to become available.\n\n  Some Nodes will return different dependency Nodes based on where they are in their lifecycle,\n  but all returned dependencies are recorded for the lifetime of a ProductGraph.\n  \"\"\"\n  pass\n\n\n<DED>class Node(object):\n  <IND>@abstractproperty\n  def subject(self):\n    <IND>\"\"\"The subject for this Node.\"\"\"\n\n  <DED>@abstractproperty\n  def product(self):\n    <IND>\"\"\"The output product for this Node.\"\"\"\n\n  <DED>@abstractproperty\n  def variants(self):\n    <IND>\"\"\"The variants for this Node.\"\"\"\n\n  <DED>@abstractmethod\n  def step(self, dependency_states, node_builder):\n    <IND>\"\"\"Given a dict of the dependency States for this Node, returns the current State of the Node.\n\n    The NodeBuilder parameter provides a way to construct Nodes that require information about\n    installed tasks.\n\n    After this method returns a non-Waiting state, it will never be visited again for this Node.\n    \"\"\"\n\n\n<DED><DED>class SelectNode(datatype('SelectNode', ['subject', 'product', 'variants', 'variant_key']), Node):\n  <IND>\"\"\"A Node that selects a product for a subject.\n\n  A Select can be satisfied by multiple sources, but fails if multiple sources produce a value. The\n  'variants' field represents variant configuration that is propagated to dependencies. When\n  a task needs to consume a product as configured by the variants map, it uses the SelectVariant\n  selector, which introduces the 'variant' value to restrict the names of values selected by a\n  SelectNode.\n  \"\"\"\n\n  def _variants_node(self):\n    <IND>if self.product != Variants:\n      <IND>return SelectNode(self.subject, Variants, self.variants, None)\n    <DED>return None\n\n  <DED>def _select_literal(self, candidate, variant_value):\n    <IND>\"\"\"Looks for has-a or is-a relationships between the given value and the requested product.\n\n    Returns the resulting product value, or None if no match was made.\n    \"\"\"\n    def items():\n      # Check whether the subject is-a instance of the product.\n      <IND>yield candidate\n      # Else, check whether it has-a instance of the product.\n      if isinstance(candidate, Target):\n        <IND>for configuration in candidate.configurations:\n          <IND>yield configuration\n\n    # TODO: returning only the first literal configuration of a given type/variant. Need to\n    # define mergeability for products.\n    <DED><DED><DED>for item in items():\n      <IND>if not isinstance(item, self.product):\n        <IND>continue\n      <DED>if variant_value and not getattr(item, 'name', None) == variant_value:\n        <IND>continue\n      <DED>return item\n    <DED>return None\n\n  <DED>def step(self, dependency_states, node_builder):\n    # Request default Variants for the subject, so that if there are any we can propagate\n    # them to task nodes.\n    <IND>variants = self.variants\n    variants_node = self._variants_node()\n    if variants_node:\n      <IND>dep_state = dependency_states.get(variants_node, None)\n      if dep_state is None or type(dep_state) == Waiting:\n        <IND>return Waiting([variants_node])\n      <DED>elif type(dep_state) == Return:\n        # A subject's variants are overridden by any dependent's requested variants, so\n        # we merge them left to right here.\n        <IND>variants = Variants.merge(dep_state.value.default.items(), variants)\n\n    # If there is a variant_key, see whether it has been configured.\n    <DED><DED>variant_value = None\n    if self.variant_key:\n      <IND>variant_values = [value for key, value in variants\n                        if key == self.variant_key] if variants else None\n      if not variant_values:\n        # Select cannot be satisfied: no variant configured for this key.\n        <IND>return Noop('Variant key {} was not configured in variants {}'.format(\n          self.variant_key, variants))\n      <DED>variant_value = variant_values[0]\n\n    # If the Subject \"is a\" or \"has a\" Product, then we're done.\n    <DED>literal_value = self._select_literal(self.subject, variant_value)\n    if literal_value is not None:\n      <IND>return Return(literal_value)\n\n    # Else, attempt to use a configured task to compute the value.\n    <DED>has_waiting_dep = False\n    dependencies = list(node_builder.task_nodes(self.subject, self.product, variants))\n    matches = {}\n    for dep in dependencies:\n      <IND>dep_state = dependency_states.get(dep, None)\n      if dep_state is None or type(dep_state) == Waiting:\n        <IND>has_waiting_dep = True\n        continue\n      <DED>elif type(dep_state) == Throw:\n        <IND>return dep_state\n      <DED>elif type(dep_state) == Noop:\n        <IND>continue\n      <DED>elif type(dep_state) != Return:\n        <IND>State.raise_unrecognized(dep_state)\n      # We computed a value: see whether we can use it.\n      <DED>literal_value = self._select_literal(dep_state.value, variant_value)\n      if literal_value is not None:\n        <IND>matches[dep] = literal_value\n    <DED><DED>if has_waiting_dep:\n      <IND>return Waiting(dependencies)\n    <DED>elif len(matches) > 1:\n      # TODO: Multiple successful tasks are not currently supported. We should allow for this\n      # by adding support for \"mergeable\" products. see:\n      #   https://github.com/pantsbuild/pants/issues/2526\n      <IND>return Throw(ConflictingProducersError(self.subject, self.product, matches))\n    <DED>elif len(matches) == 1:\n      <IND>return Return(matches.values()[0])\n    <DED>return Noop('No source of {}.'.format(self))\n\n\n<DED><DED>class DependenciesNode(datatype('DependenciesNode', ['subject', 'product', 'variants', 'dep_product']), Node):\n  <IND>\"\"\"A Node that selects the given Product for each of the dependencies of this subject.\n\n  Begins by selecting the `dep_product` for the subject, and then selects a product for each\n  of dep_products' dependencies.\n\n  The value produced by this Node guarantees that the order of the provided values matches the\n  order of declaration in the `dependencies` list of the `dep_product`.\n  \"\"\"\n\n  def _dep_product_node(self):\n    <IND>return SelectNode(self.subject, self.dep_product, self.variants, None)\n\n  <DED>def _dep_node(self, dependency):\n    <IND>variants = self.variants\n    if isinstance(dependency, Address):\n      # If a subject has literal variants for particular dependencies, they win over all else.\n      <IND>dependency, literal_variants = parse_variants(dependency)\n      variants = Variants.merge(variants, literal_variants)\n    <DED>return SelectNode(dependency, self.product, variants, None)\n\n  <DED>def step(self, dependency_states, node_builder):\n    # Request the product we need in order to request dependencies.\n    <IND>dep_product_node = self._dep_product_node()\n    dep_product_state = dependency_states.get(dep_product_node, None)\n    if dep_product_state is None or type(dep_product_state) == Waiting:\n      <IND>return Waiting([dep_product_node])\n    <DED>elif type(dep_product_state) == Throw:\n      <IND>return dep_product_state\n    <DED>elif type(dep_product_state) == Noop:\n      <IND>return Noop('Could not compute {} to determine dependencies.'.format(dep_product_node))\n    <DED>elif type(dep_product_state) != Return:\n      <IND>State.raise_unrecognized(dep_product_state)\n\n    # The product and its dependency list are available.\n    <DED>dep_product = dep_product_state.value\n    dependencies = [self._dep_node(d) for d in dep_product.dependencies]\n    for dependency in dependencies:\n      <IND>dep_state = dependency_states.get(dependency, None)\n      if dep_state is None or type(dep_state) == Waiting:\n        # One of the dependencies is not yet available. Indicate that we are waiting for all\n        # of them.\n        <IND>return Waiting([dep_product_node] + dependencies)\n      <DED>elif type(dep_state) == Throw:\n        <IND>return dep_state\n      <DED>elif type(dep_state) == Noop:\n        <IND>return Throw(ValueError('No source of explicit dependency {}'.format(dependency)))\n      <DED>elif type(dep_state) != Return:\n        <IND>raise State.raise_unrecognized(dep_state)\n    # All dependencies are present! Set our value to a list of the resulting values.\n    <DED><DED>return Return([dependency_states[d].value for d in dependencies])\n\n\n<DED><DED>class TaskNode(datatype('TaskNode', ['subject', 'product', 'variants', 'func', 'clause']), Node):\n\n  <IND>def step(self, dependency_states, node_builder):\n    # Compute dependencies.\n    <IND>dep_values = []\n    dependencies = []\n    for select in self.clause:\n      <IND>dep = select.construct_node(self.subject, self.variants)\n      if dep is None:\n        <IND>return Noop('Dependency {} is not satisfiable.'.format(select))\n      <DED>dependencies.append(dep)\n\n    # If all dependency Nodes are Return, execute the Node.\n    <DED>for dep_select, dep_key in zip(self.clause, dependencies):\n      <IND>dep_state = dependency_states.get(dep_key, None)\n      if dep_state is None or type(dep_state) == Waiting:\n        <IND>return Waiting(dependencies)\n      <DED>elif type(dep_state) == Return:\n        <IND>dep_values.append(dep_state.value)\n      <DED>elif type(dep_state) == Noop:\n        <IND>if dep_select.optional:\n          <IND>dep_values.append(None)\n        <DED>else:\n          <IND>return Noop('Was missing (at least) input {}.'.format(dep_key))\n      <DED><DED>elif type(dep_state) == Throw:\n        <IND>return dep_state\n      <DED>else:\n        <IND>State.raise_unrecognized(dep_state)\n    <DED><DED>try:\n      <IND>return Return(self.func(*dep_values))\n    <DED>except Exception as e:\n      <IND>return Throw(e)\n\n\n<DED><DED><DED>class ProductGraph(object):\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n<DED><DED>class ProductGraph(object):\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "pantsbuild/pants",
    "commit": "08bc2add6e98feefdce36f6f094a15e3e598b1e7",
    "filename": "src/python/pants/engine/exp/scheduler.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/pantsbuild-pants/src/python/pants/engine/exp/scheduler.py",
    "file_hunks_size": 13,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": true,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "src/python/pants/engine/exp/scheduler.py:302:23 Invalid type [31]: Expression `pants.util.objects.datatype(\"DependenciesNode\", [\"subject\", \"product\", \"variants\", \"dep_product\"])` is not a valid type.",
    "message": " Expression `pants.util.objects.datatype(\"DependenciesNode\", [\"subject\", \"product\", \"variants\", \"dep_product\"])` is not a valid type.",
    "rule_id": "Invalid type [31]",
    "warning_line_no": 302,
    "warning_line": "class DependenciesNode(datatype('DependenciesNode', ['subject', 'product', 'variants', 'dep_product']), Node):",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": true,
        "has_suppression": false,
        "source_code": "\nclass ConflictingProducersError(SchedulingError):\n  \"\"\"Indicates that there was more than one source of a product for a given subject.\n\n  TODO: This will need to be legal in order to support multiple Planners producing a\n  (mergeable) Classpath for one subject, for example. see:\n    https://github.com/pantsbuild/pants/issues/2526\n  \"\"\"\n\n  def __init__(self, subject, product, matches):\n    msgs = '\\n  '.join('{}: {}'.format(k, v) for k, v in matches.items())\n    msg = 'More than one source of {} for {}:\\n  {}'.format(product.__name__, subject, msgs)\n    super(ConflictingProducersError, self).__init__(msg)\n\n\nclass State(object):\n  @classmethod\n  def raise_unrecognized(cls, state):\n    raise ValueError('Unrecognized Node State: {}'.format(state))\n\n\nclass Noop(datatype('Noop', ['msg']), State):\n  \"\"\"Indicates that a Node did not have the inputs which would be needed for it to execute.\"\"\"\n  pass\n\n\nclass Return(datatype('Return', ['value']), State):\n  \"\"\"Indicates that a Node successfully returned a value.\"\"\"\n  pass\n\n\nclass Throw(datatype('Throw', ['exc']), State):\n  \"\"\"Indicates that a Node should have been able to return a value, but failed.\"\"\"\n  pass\n\n\nclass Waiting(datatype('Waiting', ['dependencies']), State):\n  \"\"\"Indicates that a Node is waiting for some/all of the dependencies to become available.\n\n  Some Nodes will return different dependency Nodes based on where they are in their lifecycle,\n  but all returned dependencies are recorded for the lifetime of a ProductGraph.\n  \"\"\"\n  pass\n\n\nclass Node(object):\n  @abstractproperty\n  def subject(self):\n    \"\"\"The subject for this Node.\"\"\"\n\n  @abstractproperty\n  def product(self):\n    \"\"\"The output product for this Node.\"\"\"\n\n  @abstractproperty\n  def variants(self):\n    \"\"\"The variants for this Node.\"\"\"\n\n  @abstractmethod\n  def step(self, dependency_states, node_builder):\n    \"\"\"Given a dict of the dependency States for this Node, returns the current State of the Node.\n\n    The NodeBuilder parameter provides a way to construct Nodes that require information about\n    installed tasks.\n\n    After this method returns a non-Waiting state, it will never be visited again for this Node.\n    \"\"\"\n\n\nclass SelectNode(datatype('SelectNode', ['subject', 'product', 'variants', 'variant_key']), Node):\n  \"\"\"A Node that selects a product for a subject.\n\n  A Select can be satisfied by multiple sources, but fails if multiple sources produce a value. The\n  'variants' field represents variant configuration that is propagated to dependencies. When\n  a task needs to consume a product as configured by the variants map, it uses the SelectVariant\n  selector, which introduces the 'variant' value to restrict the names of values selected by a\n  SelectNode.\n  \"\"\"\n\n  def _variants_node(self):\n    if self.product != Variants:\n      return SelectNode(self.subject, Variants, self.variants, None)\n    return None\n\n  def _select_literal(self, candidate, variant_value):\n    \"\"\"Looks for has-a or is-a relationships between the given value and the requested product.\n\n    Returns the resulting product value, or None if no match was made.\n    \"\"\"\n    def items():\n      # Check whether the subject is-a instance of the product.\n      yield candidate\n      # Else, check whether it has-a instance of the product.\n      if isinstance(candidate, Target):\n        for configuration in candidate.configurations:\n          yield configuration\n\n    # TODO: returning only the first literal configuration of a given type/variant. Need to\n    # define mergeability for products.\n    for item in items():\n      if not isinstance(item, self.product):\n        continue\n      if variant_value and not getattr(item, 'name', None) == variant_value:\n        continue\n      return item\n    return None\n\n  def step(self, dependency_states, node_builder):\n    # Request default Variants for the subject, so that if there are any we can propagate\n    # them to task nodes.\n    variants = self.variants\n    variants_node = self._variants_node()\n    if variants_node:\n      dep_state = dependency_states.get(variants_node, None)\n      if dep_state is None or type(dep_state) == Waiting:\n        return Waiting([variants_node])\n      elif type(dep_state) == Return:\n        # A subject's variants are overridden by any dependent's requested variants, so\n        # we merge them left to right here.\n        variants = Variants.merge(dep_state.value.default.items(), variants)\n\n    # If there is a variant_key, see whether it has been configured.\n    variant_value = None\n    if self.variant_key:\n      variant_values = [value for key, value in variants\n                        if key == self.variant_key] if variants else None\n      if not variant_values:\n        # Select cannot be satisfied: no variant configured for this key.\n        return Noop('Variant key {} was not configured in variants {}'.format(\n          self.variant_key, variants))\n      variant_value = variant_values[0]\n\n    # If the Subject \"is a\" or \"has a\" Product, then we're done.\n    literal_value = self._select_literal(self.subject, variant_value)\n    if literal_value is not None:\n      return Return(literal_value)\n\n    # Else, attempt to use a configured task to compute the value.\n    has_waiting_dep = False\n    dependencies = list(node_builder.task_nodes(self.subject, self.product, variants))\n    matches = {}\n    for dep in dependencies:\n      dep_state = dependency_states.get(dep, None)\n      if dep_state is None or type(dep_state) == Waiting:\n        has_waiting_dep = True\n        continue\n      elif type(dep_state) == Throw:\n        return dep_state\n      elif type(dep_state) == Noop:\n        continue\n      elif type(dep_state) != Return:\n        State.raise_unrecognized(dep_state)\n      # We computed a value: see whether we can use it.\n      literal_value = self._select_literal(dep_state.value, variant_value)\n      if literal_value is not None:\n        matches[dep] = literal_value\n    if has_waiting_dep:\n      return Waiting(dependencies)\n    elif len(matches) > 1:\n      # TODO: Multiple successful tasks are not currently supported. We should allow for this\n      # by adding support for \"mergeable\" products. see:\n      #   https://github.com/pantsbuild/pants/issues/2526\n      return Throw(ConflictingProducersError(self.subject, self.product, matches))\n    elif len(matches) == 1:\n      return Return(matches.values()[0])\n    return Noop('No source of {}.'.format(self))\n\n\nclass DependenciesNode(datatype('DependenciesNode', ['subject', 'product', 'variants', 'dep_product']), Node):\n  \"\"\"A Node that selects the given Product for each of the dependencies of this subject.\n\n  Begins by selecting the `dep_product` for the subject, and then selects a product for each\n  of dep_products' dependencies.\n\n  The value produced by this Node guarantees that the order of the provided values matches the\n  order of declaration in the `dependencies` list of the `dep_product`.\n  \"\"\"\n\n  def _dep_product_node(self):\n    return SelectNode(self.subject, self.dep_product, self.variants, None)\n\n  def _dep_node(self, dependency):\n    variants = self.variants\n    if isinstance(dependency, Address):\n      # If a subject has literal variants for particular dependencies, they win over all else.\n      dependency, literal_variants = parse_variants(dependency)\n      variants = Variants.merge(variants, literal_variants)\n    return SelectNode(dependency, self.product, variants, None)\n\n  def step(self, dependency_states, node_builder):\n    # Request the product we need in order to request dependencies.\n    dep_product_node = self._dep_product_node()\n    dep_product_state = dependency_states.get(dep_product_node, None)\n    if dep_product_state is None or type(dep_product_state) == Waiting:\n      return Waiting([dep_product_node])\n    elif type(dep_product_state) == Throw:\n      return dep_product_state\n    elif type(dep_product_state) == Noop:\n      return Noop('Could not compute {} to determine dependencies.'.format(dep_product_node))\n    elif type(dep_product_state) != Return:\n      State.raise_unrecognized(dep_product_state)\n\n    # The product and its dependency list are available.\n    dep_product = dep_product_state.value\n    dependencies = [self._dep_node(d) for d in dep_product.dependencies]\n    for dependency in dependencies:\n      dep_state = dependency_states.get(dependency, None)\n      if dep_state is None or type(dep_state) == Waiting:\n        # One of the dependencies is not yet available. Indicate that we are waiting for all\n        # of them.\n        return Waiting([dep_product_node] + dependencies)\n      elif type(dep_state) == Throw:\n        return dep_state\n      elif type(dep_state) == Noop:\n        return Throw(ValueError('No source of explicit dependency {}'.format(dependency)))\n      elif type(dep_state) != Return:\n        raise State.raise_unrecognized(dep_state)\n    # All dependencies are present! Set our value to a list of the resulting values.\n    return Return([dependency_states[d].value for d in dependencies])\n\n\nclass TaskNode(datatype('TaskNode', ['subject', 'product', 'variants', 'func', 'clause']), Node):\n\n  def step(self, dependency_states, node_builder):\n    # Compute dependencies.\n    dep_values = []\n    dependencies = []\n    for select in self.clause:\n      dep = select.construct_node(self.subject, self.variants)\n      if dep is None:\n        return Noop('Dependency {} is not satisfiable.'.format(select))\n      dependencies.append(dep)\n\n    # If all dependency Nodes are Return, execute the Node.\n    for dep_select, dep_key in zip(self.clause, dependencies):\n      dep_state = dependency_states.get(dep_key, None)\n      if dep_state is None or type(dep_state) == Waiting:\n        return Waiting(dependencies)\n      elif type(dep_state) == Return:\n        dep_values.append(dep_state.value)\n      elif type(dep_state) == Noop:\n        if dep_select.optional:\n          dep_values.append(None)\n        else:\n          return Noop('Was missing (at least) input {}.'.format(dep_key))\n      elif type(dep_state) == Throw:\n        return dep_state\n      else:\n        State.raise_unrecognized(dep_state)\n    try:\n      return Return(self.func(*dep_values))\n    except Exception as e:\n      return Throw(e)\n\n\nclass ProductGraph(object):\n",
        "source_code_len": 10229,
        "target_code": "\nclass ProductGraph(object):\n",
        "target_code_len": 29,
        "diff_format": "@@ -134,256 +48,2 @@\n \n-class ConflictingProducersError(SchedulingError):\n-  \"\"\"Indicates that there was more than one source of a product for a given subject.\n-\n-  TODO: This will need to be legal in order to support multiple Planners producing a\n-  (mergeable) Classpath for one subject, for example. see:\n-    https://github.com/pantsbuild/pants/issues/2526\n-  \"\"\"\n-\n-  def __init__(self, subject, product, matches):\n-    msgs = '\\n  '.join('{}: {}'.format(k, v) for k, v in matches.items())\n-    msg = 'More than one source of {} for {}:\\n  {}'.format(product.__name__, subject, msgs)\n-    super(ConflictingProducersError, self).__init__(msg)\n-\n-\n-class State(object):\n-  @classmethod\n-  def raise_unrecognized(cls, state):\n-    raise ValueError('Unrecognized Node State: {}'.format(state))\n-\n-\n-class Noop(datatype('Noop', ['msg']), State):\n-  \"\"\"Indicates that a Node did not have the inputs which would be needed for it to execute.\"\"\"\n-  pass\n-\n-\n-class Return(datatype('Return', ['value']), State):\n-  \"\"\"Indicates that a Node successfully returned a value.\"\"\"\n-  pass\n-\n-\n-class Throw(datatype('Throw', ['exc']), State):\n-  \"\"\"Indicates that a Node should have been able to return a value, but failed.\"\"\"\n-  pass\n-\n-\n-class Waiting(datatype('Waiting', ['dependencies']), State):\n-  \"\"\"Indicates that a Node is waiting for some/all of the dependencies to become available.\n-\n-  Some Nodes will return different dependency Nodes based on where they are in their lifecycle,\n-  but all returned dependencies are recorded for the lifetime of a ProductGraph.\n-  \"\"\"\n-  pass\n-\n-\n-class Node(object):\n-  @abstractproperty\n-  def subject(self):\n-    \"\"\"The subject for this Node.\"\"\"\n-\n-  @abstractproperty\n-  def product(self):\n-    \"\"\"The output product for this Node.\"\"\"\n-\n-  @abstractproperty\n-  def variants(self):\n-    \"\"\"The variants for this Node.\"\"\"\n-\n-  @abstractmethod\n-  def step(self, dependency_states, node_builder):\n-    \"\"\"Given a dict of the dependency States for this Node, returns the current State of the Node.\n-\n-    The NodeBuilder parameter provides a way to construct Nodes that require information about\n-    installed tasks.\n-\n-    After this method returns a non-Waiting state, it will never be visited again for this Node.\n-    \"\"\"\n-\n-\n-class SelectNode(datatype('SelectNode', ['subject', 'product', 'variants', 'variant_key']), Node):\n-  \"\"\"A Node that selects a product for a subject.\n-\n-  A Select can be satisfied by multiple sources, but fails if multiple sources produce a value. The\n-  'variants' field represents variant configuration that is propagated to dependencies. When\n-  a task needs to consume a product as configured by the variants map, it uses the SelectVariant\n-  selector, which introduces the 'variant' value to restrict the names of values selected by a\n-  SelectNode.\n-  \"\"\"\n-\n-  def _variants_node(self):\n-    if self.product != Variants:\n-      return SelectNode(self.subject, Variants, self.variants, None)\n-    return None\n-\n-  def _select_literal(self, candidate, variant_value):\n-    \"\"\"Looks for has-a or is-a relationships between the given value and the requested product.\n-\n-    Returns the resulting product value, or None if no match was made.\n-    \"\"\"\n-    def items():\n-      # Check whether the subject is-a instance of the product.\n-      yield candidate\n-      # Else, check whether it has-a instance of the product.\n-      if isinstance(candidate, Target):\n-        for configuration in candidate.configurations:\n-          yield configuration\n-\n-    # TODO: returning only the first literal configuration of a given type/variant. Need to\n-    # define mergeability for products.\n-    for item in items():\n-      if not isinstance(item, self.product):\n-        continue\n-      if variant_value and not getattr(item, 'name', None) == variant_value:\n-        continue\n-      return item\n-    return None\n-\n-  def step(self, dependency_states, node_builder):\n-    # Request default Variants for the subject, so that if there are any we can propagate\n-    # them to task nodes.\n-    variants = self.variants\n-    variants_node = self._variants_node()\n-    if variants_node:\n-      dep_state = dependency_states.get(variants_node, None)\n-      if dep_state is None or type(dep_state) == Waiting:\n-        return Waiting([variants_node])\n-      elif type(dep_state) == Return:\n-        # A subject's variants are overridden by any dependent's requested variants, so\n-        # we merge them left to right here.\n-        variants = Variants.merge(dep_state.value.default.items(), variants)\n-\n-    # If there is a variant_key, see whether it has been configured.\n-    variant_value = None\n-    if self.variant_key:\n-      variant_values = [value for key, value in variants\n-                        if key == self.variant_key] if variants else None\n-      if not variant_values:\n-        # Select cannot be satisfied: no variant configured for this key.\n-        return Noop('Variant key {} was not configured in variants {}'.format(\n-          self.variant_key, variants))\n-      variant_value = variant_values[0]\n-\n-    # If the Subject \"is a\" or \"has a\" Product, then we're done.\n-    literal_value = self._select_literal(self.subject, variant_value)\n-    if literal_value is not None:\n-      return Return(literal_value)\n-\n-    # Else, attempt to use a configured task to compute the value.\n-    has_waiting_dep = False\n-    dependencies = list(node_builder.task_nodes(self.subject, self.product, variants))\n-    matches = {}\n-    for dep in dependencies:\n-      dep_state = dependency_states.get(dep, None)\n-      if dep_state is None or type(dep_state) == Waiting:\n-        has_waiting_dep = True\n-        continue\n-      elif type(dep_state) == Throw:\n-        return dep_state\n-      elif type(dep_state) == Noop:\n-        continue\n-      elif type(dep_state) != Return:\n-        State.raise_unrecognized(dep_state)\n-      # We computed a value: see whether we can use it.\n-      literal_value = self._select_literal(dep_state.value, variant_value)\n-      if literal_value is not None:\n-        matches[dep] = literal_value\n-    if has_waiting_dep:\n-      return Waiting(dependencies)\n-    elif len(matches) > 1:\n-      # TODO: Multiple successful tasks are not currently supported. We should allow for this\n-      # by adding support for \"mergeable\" products. see:\n-      #   https://github.com/pantsbuild/pants/issues/2526\n-      return Throw(ConflictingProducersError(self.subject, self.product, matches))\n-    elif len(matches) == 1:\n-      return Return(matches.values()[0])\n-    return Noop('No source of {}.'.format(self))\n-\n-\n-class DependenciesNode(datatype('DependenciesNode', ['subject', 'product', 'variants', 'dep_product']), Node):\n-  \"\"\"A Node that selects the given Product for each of the dependencies of this subject.\n-\n-  Begins by selecting the `dep_product` for the subject, and then selects a product for each\n-  of dep_products' dependencies.\n-\n-  The value produced by this Node guarantees that the order of the provided values matches the\n-  order of declaration in the `dependencies` list of the `dep_product`.\n-  \"\"\"\n-\n-  def _dep_product_node(self):\n-    return SelectNode(self.subject, self.dep_product, self.variants, None)\n-\n-  def _dep_node(self, dependency):\n-    variants = self.variants\n-    if isinstance(dependency, Address):\n-      # If a subject has literal variants for particular dependencies, they win over all else.\n-      dependency, literal_variants = parse_variants(dependency)\n-      variants = Variants.merge(variants, literal_variants)\n-    return SelectNode(dependency, self.product, variants, None)\n-\n-  def step(self, dependency_states, node_builder):\n-    # Request the product we need in order to request dependencies.\n-    dep_product_node = self._dep_product_node()\n-    dep_product_state = dependency_states.get(dep_product_node, None)\n-    if dep_product_state is None or type(dep_product_state) == Waiting:\n-      return Waiting([dep_product_node])\n-    elif type(dep_product_state) == Throw:\n-      return dep_product_state\n-    elif type(dep_product_state) == Noop:\n-      return Noop('Could not compute {} to determine dependencies.'.format(dep_product_node))\n-    elif type(dep_product_state) != Return:\n-      State.raise_unrecognized(dep_product_state)\n-\n-    # The product and its dependency list are available.\n-    dep_product = dep_product_state.value\n-    dependencies = [self._dep_node(d) for d in dep_product.dependencies]\n-    for dependency in dependencies:\n-      dep_state = dependency_states.get(dependency, None)\n-      if dep_state is None or type(dep_state) == Waiting:\n-        # One of the dependencies is not yet available. Indicate that we are waiting for all\n-        # of them.\n-        return Waiting([dep_product_node] + dependencies)\n-      elif type(dep_state) == Throw:\n-        return dep_state\n-      elif type(dep_state) == Noop:\n-        return Throw(ValueError('No source of explicit dependency {}'.format(dependency)))\n-      elif type(dep_state) != Return:\n-        raise State.raise_unrecognized(dep_state)\n-    # All dependencies are present! Set our value to a list of the resulting values.\n-    return Return([dependency_states[d].value for d in dependencies])\n-\n-\n-class TaskNode(datatype('TaskNode', ['subject', 'product', 'variants', 'func', 'clause']), Node):\n-\n-  def step(self, dependency_states, node_builder):\n-    # Compute dependencies.\n-    dep_values = []\n-    dependencies = []\n-    for select in self.clause:\n-      dep = select.construct_node(self.subject, self.variants)\n-      if dep is None:\n-        return Noop('Dependency {} is not satisfiable.'.format(select))\n-      dependencies.append(dep)\n-\n-    # If all dependency Nodes are Return, execute the Node.\n-    for dep_select, dep_key in zip(self.clause, dependencies):\n-      dep_state = dependency_states.get(dep_key, None)\n-      if dep_state is None or type(dep_state) == Waiting:\n-        return Waiting(dependencies)\n-      elif type(dep_state) == Return:\n-        dep_values.append(dep_state.value)\n-      elif type(dep_state) == Noop:\n-        if dep_select.optional:\n-          dep_values.append(None)\n-        else:\n-          return Noop('Was missing (at least) input {}.'.format(dep_key))\n-      elif type(dep_state) == Throw:\n-        return dep_state\n-      else:\n-        State.raise_unrecognized(dep_state)\n-    try:\n-      return Return(self.func(*dep_values))\n-    except Exception as e:\n-      return Throw(e)\n-\n-\n class ProductGraph(object):\n",
        "source_code_with_indent": "\n<DED><DED>class ConflictingProducersError(SchedulingError):\n  <IND>\"\"\"Indicates that there was more than one source of a product for a given subject.\n\n  TODO: This will need to be legal in order to support multiple Planners producing a\n  (mergeable) Classpath for one subject, for example. see:\n    https://github.com/pantsbuild/pants/issues/2526\n  \"\"\"\n\n  def __init__(self, subject, product, matches):\n    <IND>msgs = '\\n  '.join('{}: {}'.format(k, v) for k, v in matches.items())\n    msg = 'More than one source of {} for {}:\\n  {}'.format(product.__name__, subject, msgs)\n    super(ConflictingProducersError, self).__init__(msg)\n\n\n<DED><DED>class State(object):\n  <IND>@classmethod\n  def raise_unrecognized(cls, state):\n    <IND>raise ValueError('Unrecognized Node State: {}'.format(state))\n\n\n<DED><DED>class Noop(datatype('Noop', ['msg']), State):\n  <IND>\"\"\"Indicates that a Node did not have the inputs which would be needed for it to execute.\"\"\"\n  pass\n\n\n<DED>class Return(datatype('Return', ['value']), State):\n  <IND>\"\"\"Indicates that a Node successfully returned a value.\"\"\"\n  pass\n\n\n<DED>class Throw(datatype('Throw', ['exc']), State):\n  <IND>\"\"\"Indicates that a Node should have been able to return a value, but failed.\"\"\"\n  pass\n\n\n<DED>class Waiting(datatype('Waiting', ['dependencies']), State):\n  <IND>\"\"\"Indicates that a Node is waiting for some/all of the dependencies to become available.\n\n  Some Nodes will return different dependency Nodes based on where they are in their lifecycle,\n  but all returned dependencies are recorded for the lifetime of a ProductGraph.\n  \"\"\"\n  pass\n\n\n<DED>class Node(object):\n  <IND>@abstractproperty\n  def subject(self):\n    <IND>\"\"\"The subject for this Node.\"\"\"\n\n  <DED>@abstractproperty\n  def product(self):\n    <IND>\"\"\"The output product for this Node.\"\"\"\n\n  <DED>@abstractproperty\n  def variants(self):\n    <IND>\"\"\"The variants for this Node.\"\"\"\n\n  <DED>@abstractmethod\n  def step(self, dependency_states, node_builder):\n    <IND>\"\"\"Given a dict of the dependency States for this Node, returns the current State of the Node.\n\n    The NodeBuilder parameter provides a way to construct Nodes that require information about\n    installed tasks.\n\n    After this method returns a non-Waiting state, it will never be visited again for this Node.\n    \"\"\"\n\n\n<DED><DED>class SelectNode(datatype('SelectNode', ['subject', 'product', 'variants', 'variant_key']), Node):\n  <IND>\"\"\"A Node that selects a product for a subject.\n\n  A Select can be satisfied by multiple sources, but fails if multiple sources produce a value. The\n  'variants' field represents variant configuration that is propagated to dependencies. When\n  a task needs to consume a product as configured by the variants map, it uses the SelectVariant\n  selector, which introduces the 'variant' value to restrict the names of values selected by a\n  SelectNode.\n  \"\"\"\n\n  def _variants_node(self):\n    <IND>if self.product != Variants:\n      <IND>return SelectNode(self.subject, Variants, self.variants, None)\n    <DED>return None\n\n  <DED>def _select_literal(self, candidate, variant_value):\n    <IND>\"\"\"Looks for has-a or is-a relationships between the given value and the requested product.\n\n    Returns the resulting product value, or None if no match was made.\n    \"\"\"\n    def items():\n      # Check whether the subject is-a instance of the product.\n      <IND>yield candidate\n      # Else, check whether it has-a instance of the product.\n      if isinstance(candidate, Target):\n        <IND>for configuration in candidate.configurations:\n          <IND>yield configuration\n\n    # TODO: returning only the first literal configuration of a given type/variant. Need to\n    # define mergeability for products.\n    <DED><DED><DED>for item in items():\n      <IND>if not isinstance(item, self.product):\n        <IND>continue\n      <DED>if variant_value and not getattr(item, 'name', None) == variant_value:\n        <IND>continue\n      <DED>return item\n    <DED>return None\n\n  <DED>def step(self, dependency_states, node_builder):\n    # Request default Variants for the subject, so that if there are any we can propagate\n    # them to task nodes.\n    <IND>variants = self.variants\n    variants_node = self._variants_node()\n    if variants_node:\n      <IND>dep_state = dependency_states.get(variants_node, None)\n      if dep_state is None or type(dep_state) == Waiting:\n        <IND>return Waiting([variants_node])\n      <DED>elif type(dep_state) == Return:\n        # A subject's variants are overridden by any dependent's requested variants, so\n        # we merge them left to right here.\n        <IND>variants = Variants.merge(dep_state.value.default.items(), variants)\n\n    # If there is a variant_key, see whether it has been configured.\n    <DED><DED>variant_value = None\n    if self.variant_key:\n      <IND>variant_values = [value for key, value in variants\n                        if key == self.variant_key] if variants else None\n      if not variant_values:\n        # Select cannot be satisfied: no variant configured for this key.\n        <IND>return Noop('Variant key {} was not configured in variants {}'.format(\n          self.variant_key, variants))\n      <DED>variant_value = variant_values[0]\n\n    # If the Subject \"is a\" or \"has a\" Product, then we're done.\n    <DED>literal_value = self._select_literal(self.subject, variant_value)\n    if literal_value is not None:\n      <IND>return Return(literal_value)\n\n    # Else, attempt to use a configured task to compute the value.\n    <DED>has_waiting_dep = False\n    dependencies = list(node_builder.task_nodes(self.subject, self.product, variants))\n    matches = {}\n    for dep in dependencies:\n      <IND>dep_state = dependency_states.get(dep, None)\n      if dep_state is None or type(dep_state) == Waiting:\n        <IND>has_waiting_dep = True\n        continue\n      <DED>elif type(dep_state) == Throw:\n        <IND>return dep_state\n      <DED>elif type(dep_state) == Noop:\n        <IND>continue\n      <DED>elif type(dep_state) != Return:\n        <IND>State.raise_unrecognized(dep_state)\n      # We computed a value: see whether we can use it.\n      <DED>literal_value = self._select_literal(dep_state.value, variant_value)\n      if literal_value is not None:\n        <IND>matches[dep] = literal_value\n    <DED><DED>if has_waiting_dep:\n      <IND>return Waiting(dependencies)\n    <DED>elif len(matches) > 1:\n      # TODO: Multiple successful tasks are not currently supported. We should allow for this\n      # by adding support for \"mergeable\" products. see:\n      #   https://github.com/pantsbuild/pants/issues/2526\n      <IND>return Throw(ConflictingProducersError(self.subject, self.product, matches))\n    <DED>elif len(matches) == 1:\n      <IND>return Return(matches.values()[0])\n    <DED>return Noop('No source of {}.'.format(self))\n\n\n<DED><DED>class DependenciesNode(datatype('DependenciesNode', ['subject', 'product', 'variants', 'dep_product']), Node):\n  <IND>\"\"\"A Node that selects the given Product for each of the dependencies of this subject.\n\n  Begins by selecting the `dep_product` for the subject, and then selects a product for each\n  of dep_products' dependencies.\n\n  The value produced by this Node guarantees that the order of the provided values matches the\n  order of declaration in the `dependencies` list of the `dep_product`.\n  \"\"\"\n\n  def _dep_product_node(self):\n    <IND>return SelectNode(self.subject, self.dep_product, self.variants, None)\n\n  <DED>def _dep_node(self, dependency):\n    <IND>variants = self.variants\n    if isinstance(dependency, Address):\n      # If a subject has literal variants for particular dependencies, they win over all else.\n      <IND>dependency, literal_variants = parse_variants(dependency)\n      variants = Variants.merge(variants, literal_variants)\n    <DED>return SelectNode(dependency, self.product, variants, None)\n\n  <DED>def step(self, dependency_states, node_builder):\n    # Request the product we need in order to request dependencies.\n    <IND>dep_product_node = self._dep_product_node()\n    dep_product_state = dependency_states.get(dep_product_node, None)\n    if dep_product_state is None or type(dep_product_state) == Waiting:\n      <IND>return Waiting([dep_product_node])\n    <DED>elif type(dep_product_state) == Throw:\n      <IND>return dep_product_state\n    <DED>elif type(dep_product_state) == Noop:\n      <IND>return Noop('Could not compute {} to determine dependencies.'.format(dep_product_node))\n    <DED>elif type(dep_product_state) != Return:\n      <IND>State.raise_unrecognized(dep_product_state)\n\n    # The product and its dependency list are available.\n    <DED>dep_product = dep_product_state.value\n    dependencies = [self._dep_node(d) for d in dep_product.dependencies]\n    for dependency in dependencies:\n      <IND>dep_state = dependency_states.get(dependency, None)\n      if dep_state is None or type(dep_state) == Waiting:\n        # One of the dependencies is not yet available. Indicate that we are waiting for all\n        # of them.\n        <IND>return Waiting([dep_product_node] + dependencies)\n      <DED>elif type(dep_state) == Throw:\n        <IND>return dep_state\n      <DED>elif type(dep_state) == Noop:\n        <IND>return Throw(ValueError('No source of explicit dependency {}'.format(dependency)))\n      <DED>elif type(dep_state) != Return:\n        <IND>raise State.raise_unrecognized(dep_state)\n    # All dependencies are present! Set our value to a list of the resulting values.\n    <DED><DED>return Return([dependency_states[d].value for d in dependencies])\n\n\n<DED><DED>class TaskNode(datatype('TaskNode', ['subject', 'product', 'variants', 'func', 'clause']), Node):\n\n  <IND>def step(self, dependency_states, node_builder):\n    # Compute dependencies.\n    <IND>dep_values = []\n    dependencies = []\n    for select in self.clause:\n      <IND>dep = select.construct_node(self.subject, self.variants)\n      if dep is None:\n        <IND>return Noop('Dependency {} is not satisfiable.'.format(select))\n      <DED>dependencies.append(dep)\n\n    # If all dependency Nodes are Return, execute the Node.\n    <DED>for dep_select, dep_key in zip(self.clause, dependencies):\n      <IND>dep_state = dependency_states.get(dep_key, None)\n      if dep_state is None or type(dep_state) == Waiting:\n        <IND>return Waiting(dependencies)\n      <DED>elif type(dep_state) == Return:\n        <IND>dep_values.append(dep_state.value)\n      <DED>elif type(dep_state) == Noop:\n        <IND>if dep_select.optional:\n          <IND>dep_values.append(None)\n        <DED>else:\n          <IND>return Noop('Was missing (at least) input {}.'.format(dep_key))\n      <DED><DED>elif type(dep_state) == Throw:\n        <IND>return dep_state\n      <DED>else:\n        <IND>State.raise_unrecognized(dep_state)\n    <DED><DED>try:\n      <IND>return Return(self.func(*dep_values))\n    <DED>except Exception as e:\n      <IND>return Throw(e)\n\n\n<DED><DED><DED>class ProductGraph(object):\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n<DED><DED>class ProductGraph(object):\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "pantsbuild/pants",
    "commit": "08bc2add6e98feefdce36f6f094a15e3e598b1e7",
    "filename": "src/python/pants/engine/exp/scheduler.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/pantsbuild-pants/src/python/pants/engine/exp/scheduler.py",
    "file_hunks_size": 13,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": true,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "src/python/pants/engine/exp/scheduler.py:355:15 Invalid type [31]: Expression `pants.util.objects.datatype(\"TaskNode\", [\"subject\", \"product\", \"variants\", \"func\", \"clause\"])` is not a valid type.",
    "message": " Expression `pants.util.objects.datatype(\"TaskNode\", [\"subject\", \"product\", \"variants\", \"func\", \"clause\"])` is not a valid type.",
    "rule_id": "Invalid type [31]",
    "warning_line_no": 355,
    "warning_line": "class TaskNode(datatype('TaskNode', ['subject', 'product', 'variants', 'func', 'clause']), Node):",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": true,
        "has_suppression": false,
        "source_code": "\nclass ConflictingProducersError(SchedulingError):\n  \"\"\"Indicates that there was more than one source of a product for a given subject.\n\n  TODO: This will need to be legal in order to support multiple Planners producing a\n  (mergeable) Classpath for one subject, for example. see:\n    https://github.com/pantsbuild/pants/issues/2526\n  \"\"\"\n\n  def __init__(self, subject, product, matches):\n    msgs = '\\n  '.join('{}: {}'.format(k, v) for k, v in matches.items())\n    msg = 'More than one source of {} for {}:\\n  {}'.format(product.__name__, subject, msgs)\n    super(ConflictingProducersError, self).__init__(msg)\n\n\nclass State(object):\n  @classmethod\n  def raise_unrecognized(cls, state):\n    raise ValueError('Unrecognized Node State: {}'.format(state))\n\n\nclass Noop(datatype('Noop', ['msg']), State):\n  \"\"\"Indicates that a Node did not have the inputs which would be needed for it to execute.\"\"\"\n  pass\n\n\nclass Return(datatype('Return', ['value']), State):\n  \"\"\"Indicates that a Node successfully returned a value.\"\"\"\n  pass\n\n\nclass Throw(datatype('Throw', ['exc']), State):\n  \"\"\"Indicates that a Node should have been able to return a value, but failed.\"\"\"\n  pass\n\n\nclass Waiting(datatype('Waiting', ['dependencies']), State):\n  \"\"\"Indicates that a Node is waiting for some/all of the dependencies to become available.\n\n  Some Nodes will return different dependency Nodes based on where they are in their lifecycle,\n  but all returned dependencies are recorded for the lifetime of a ProductGraph.\n  \"\"\"\n  pass\n\n\nclass Node(object):\n  @abstractproperty\n  def subject(self):\n    \"\"\"The subject for this Node.\"\"\"\n\n  @abstractproperty\n  def product(self):\n    \"\"\"The output product for this Node.\"\"\"\n\n  @abstractproperty\n  def variants(self):\n    \"\"\"The variants for this Node.\"\"\"\n\n  @abstractmethod\n  def step(self, dependency_states, node_builder):\n    \"\"\"Given a dict of the dependency States for this Node, returns the current State of the Node.\n\n    The NodeBuilder parameter provides a way to construct Nodes that require information about\n    installed tasks.\n\n    After this method returns a non-Waiting state, it will never be visited again for this Node.\n    \"\"\"\n\n\nclass SelectNode(datatype('SelectNode', ['subject', 'product', 'variants', 'variant_key']), Node):\n  \"\"\"A Node that selects a product for a subject.\n\n  A Select can be satisfied by multiple sources, but fails if multiple sources produce a value. The\n  'variants' field represents variant configuration that is propagated to dependencies. When\n  a task needs to consume a product as configured by the variants map, it uses the SelectVariant\n  selector, which introduces the 'variant' value to restrict the names of values selected by a\n  SelectNode.\n  \"\"\"\n\n  def _variants_node(self):\n    if self.product != Variants:\n      return SelectNode(self.subject, Variants, self.variants, None)\n    return None\n\n  def _select_literal(self, candidate, variant_value):\n    \"\"\"Looks for has-a or is-a relationships between the given value and the requested product.\n\n    Returns the resulting product value, or None if no match was made.\n    \"\"\"\n    def items():\n      # Check whether the subject is-a instance of the product.\n      yield candidate\n      # Else, check whether it has-a instance of the product.\n      if isinstance(candidate, Target):\n        for configuration in candidate.configurations:\n          yield configuration\n\n    # TODO: returning only the first literal configuration of a given type/variant. Need to\n    # define mergeability for products.\n    for item in items():\n      if not isinstance(item, self.product):\n        continue\n      if variant_value and not getattr(item, 'name', None) == variant_value:\n        continue\n      return item\n    return None\n\n  def step(self, dependency_states, node_builder):\n    # Request default Variants for the subject, so that if there are any we can propagate\n    # them to task nodes.\n    variants = self.variants\n    variants_node = self._variants_node()\n    if variants_node:\n      dep_state = dependency_states.get(variants_node, None)\n      if dep_state is None or type(dep_state) == Waiting:\n        return Waiting([variants_node])\n      elif type(dep_state) == Return:\n        # A subject's variants are overridden by any dependent's requested variants, so\n        # we merge them left to right here.\n        variants = Variants.merge(dep_state.value.default.items(), variants)\n\n    # If there is a variant_key, see whether it has been configured.\n    variant_value = None\n    if self.variant_key:\n      variant_values = [value for key, value in variants\n                        if key == self.variant_key] if variants else None\n      if not variant_values:\n        # Select cannot be satisfied: no variant configured for this key.\n        return Noop('Variant key {} was not configured in variants {}'.format(\n          self.variant_key, variants))\n      variant_value = variant_values[0]\n\n    # If the Subject \"is a\" or \"has a\" Product, then we're done.\n    literal_value = self._select_literal(self.subject, variant_value)\n    if literal_value is not None:\n      return Return(literal_value)\n\n    # Else, attempt to use a configured task to compute the value.\n    has_waiting_dep = False\n    dependencies = list(node_builder.task_nodes(self.subject, self.product, variants))\n    matches = {}\n    for dep in dependencies:\n      dep_state = dependency_states.get(dep, None)\n      if dep_state is None or type(dep_state) == Waiting:\n        has_waiting_dep = True\n        continue\n      elif type(dep_state) == Throw:\n        return dep_state\n      elif type(dep_state) == Noop:\n        continue\n      elif type(dep_state) != Return:\n        State.raise_unrecognized(dep_state)\n      # We computed a value: see whether we can use it.\n      literal_value = self._select_literal(dep_state.value, variant_value)\n      if literal_value is not None:\n        matches[dep] = literal_value\n    if has_waiting_dep:\n      return Waiting(dependencies)\n    elif len(matches) > 1:\n      # TODO: Multiple successful tasks are not currently supported. We should allow for this\n      # by adding support for \"mergeable\" products. see:\n      #   https://github.com/pantsbuild/pants/issues/2526\n      return Throw(ConflictingProducersError(self.subject, self.product, matches))\n    elif len(matches) == 1:\n      return Return(matches.values()[0])\n    return Noop('No source of {}.'.format(self))\n\n\nclass DependenciesNode(datatype('DependenciesNode', ['subject', 'product', 'variants', 'dep_product']), Node):\n  \"\"\"A Node that selects the given Product for each of the dependencies of this subject.\n\n  Begins by selecting the `dep_product` for the subject, and then selects a product for each\n  of dep_products' dependencies.\n\n  The value produced by this Node guarantees that the order of the provided values matches the\n  order of declaration in the `dependencies` list of the `dep_product`.\n  \"\"\"\n\n  def _dep_product_node(self):\n    return SelectNode(self.subject, self.dep_product, self.variants, None)\n\n  def _dep_node(self, dependency):\n    variants = self.variants\n    if isinstance(dependency, Address):\n      # If a subject has literal variants for particular dependencies, they win over all else.\n      dependency, literal_variants = parse_variants(dependency)\n      variants = Variants.merge(variants, literal_variants)\n    return SelectNode(dependency, self.product, variants, None)\n\n  def step(self, dependency_states, node_builder):\n    # Request the product we need in order to request dependencies.\n    dep_product_node = self._dep_product_node()\n    dep_product_state = dependency_states.get(dep_product_node, None)\n    if dep_product_state is None or type(dep_product_state) == Waiting:\n      return Waiting([dep_product_node])\n    elif type(dep_product_state) == Throw:\n      return dep_product_state\n    elif type(dep_product_state) == Noop:\n      return Noop('Could not compute {} to determine dependencies.'.format(dep_product_node))\n    elif type(dep_product_state) != Return:\n      State.raise_unrecognized(dep_product_state)\n\n    # The product and its dependency list are available.\n    dep_product = dep_product_state.value\n    dependencies = [self._dep_node(d) for d in dep_product.dependencies]\n    for dependency in dependencies:\n      dep_state = dependency_states.get(dependency, None)\n      if dep_state is None or type(dep_state) == Waiting:\n        # One of the dependencies is not yet available. Indicate that we are waiting for all\n        # of them.\n        return Waiting([dep_product_node] + dependencies)\n      elif type(dep_state) == Throw:\n        return dep_state\n      elif type(dep_state) == Noop:\n        return Throw(ValueError('No source of explicit dependency {}'.format(dependency)))\n      elif type(dep_state) != Return:\n        raise State.raise_unrecognized(dep_state)\n    # All dependencies are present! Set our value to a list of the resulting values.\n    return Return([dependency_states[d].value for d in dependencies])\n\n\nclass TaskNode(datatype('TaskNode', ['subject', 'product', 'variants', 'func', 'clause']), Node):\n\n  def step(self, dependency_states, node_builder):\n    # Compute dependencies.\n    dep_values = []\n    dependencies = []\n    for select in self.clause:\n      dep = select.construct_node(self.subject, self.variants)\n      if dep is None:\n        return Noop('Dependency {} is not satisfiable.'.format(select))\n      dependencies.append(dep)\n\n    # If all dependency Nodes are Return, execute the Node.\n    for dep_select, dep_key in zip(self.clause, dependencies):\n      dep_state = dependency_states.get(dep_key, None)\n      if dep_state is None or type(dep_state) == Waiting:\n        return Waiting(dependencies)\n      elif type(dep_state) == Return:\n        dep_values.append(dep_state.value)\n      elif type(dep_state) == Noop:\n        if dep_select.optional:\n          dep_values.append(None)\n        else:\n          return Noop('Was missing (at least) input {}.'.format(dep_key))\n      elif type(dep_state) == Throw:\n        return dep_state\n      else:\n        State.raise_unrecognized(dep_state)\n    try:\n      return Return(self.func(*dep_values))\n    except Exception as e:\n      return Throw(e)\n\n\nclass ProductGraph(object):\n",
        "source_code_len": 10229,
        "target_code": "\nclass ProductGraph(object):\n",
        "target_code_len": 29,
        "diff_format": "@@ -134,256 +48,2 @@\n \n-class ConflictingProducersError(SchedulingError):\n-  \"\"\"Indicates that there was more than one source of a product for a given subject.\n-\n-  TODO: This will need to be legal in order to support multiple Planners producing a\n-  (mergeable) Classpath for one subject, for example. see:\n-    https://github.com/pantsbuild/pants/issues/2526\n-  \"\"\"\n-\n-  def __init__(self, subject, product, matches):\n-    msgs = '\\n  '.join('{}: {}'.format(k, v) for k, v in matches.items())\n-    msg = 'More than one source of {} for {}:\\n  {}'.format(product.__name__, subject, msgs)\n-    super(ConflictingProducersError, self).__init__(msg)\n-\n-\n-class State(object):\n-  @classmethod\n-  def raise_unrecognized(cls, state):\n-    raise ValueError('Unrecognized Node State: {}'.format(state))\n-\n-\n-class Noop(datatype('Noop', ['msg']), State):\n-  \"\"\"Indicates that a Node did not have the inputs which would be needed for it to execute.\"\"\"\n-  pass\n-\n-\n-class Return(datatype('Return', ['value']), State):\n-  \"\"\"Indicates that a Node successfully returned a value.\"\"\"\n-  pass\n-\n-\n-class Throw(datatype('Throw', ['exc']), State):\n-  \"\"\"Indicates that a Node should have been able to return a value, but failed.\"\"\"\n-  pass\n-\n-\n-class Waiting(datatype('Waiting', ['dependencies']), State):\n-  \"\"\"Indicates that a Node is waiting for some/all of the dependencies to become available.\n-\n-  Some Nodes will return different dependency Nodes based on where they are in their lifecycle,\n-  but all returned dependencies are recorded for the lifetime of a ProductGraph.\n-  \"\"\"\n-  pass\n-\n-\n-class Node(object):\n-  @abstractproperty\n-  def subject(self):\n-    \"\"\"The subject for this Node.\"\"\"\n-\n-  @abstractproperty\n-  def product(self):\n-    \"\"\"The output product for this Node.\"\"\"\n-\n-  @abstractproperty\n-  def variants(self):\n-    \"\"\"The variants for this Node.\"\"\"\n-\n-  @abstractmethod\n-  def step(self, dependency_states, node_builder):\n-    \"\"\"Given a dict of the dependency States for this Node, returns the current State of the Node.\n-\n-    The NodeBuilder parameter provides a way to construct Nodes that require information about\n-    installed tasks.\n-\n-    After this method returns a non-Waiting state, it will never be visited again for this Node.\n-    \"\"\"\n-\n-\n-class SelectNode(datatype('SelectNode', ['subject', 'product', 'variants', 'variant_key']), Node):\n-  \"\"\"A Node that selects a product for a subject.\n-\n-  A Select can be satisfied by multiple sources, but fails if multiple sources produce a value. The\n-  'variants' field represents variant configuration that is propagated to dependencies. When\n-  a task needs to consume a product as configured by the variants map, it uses the SelectVariant\n-  selector, which introduces the 'variant' value to restrict the names of values selected by a\n-  SelectNode.\n-  \"\"\"\n-\n-  def _variants_node(self):\n-    if self.product != Variants:\n-      return SelectNode(self.subject, Variants, self.variants, None)\n-    return None\n-\n-  def _select_literal(self, candidate, variant_value):\n-    \"\"\"Looks for has-a or is-a relationships between the given value and the requested product.\n-\n-    Returns the resulting product value, or None if no match was made.\n-    \"\"\"\n-    def items():\n-      # Check whether the subject is-a instance of the product.\n-      yield candidate\n-      # Else, check whether it has-a instance of the product.\n-      if isinstance(candidate, Target):\n-        for configuration in candidate.configurations:\n-          yield configuration\n-\n-    # TODO: returning only the first literal configuration of a given type/variant. Need to\n-    # define mergeability for products.\n-    for item in items():\n-      if not isinstance(item, self.product):\n-        continue\n-      if variant_value and not getattr(item, 'name', None) == variant_value:\n-        continue\n-      return item\n-    return None\n-\n-  def step(self, dependency_states, node_builder):\n-    # Request default Variants for the subject, so that if there are any we can propagate\n-    # them to task nodes.\n-    variants = self.variants\n-    variants_node = self._variants_node()\n-    if variants_node:\n-      dep_state = dependency_states.get(variants_node, None)\n-      if dep_state is None or type(dep_state) == Waiting:\n-        return Waiting([variants_node])\n-      elif type(dep_state) == Return:\n-        # A subject's variants are overridden by any dependent's requested variants, so\n-        # we merge them left to right here.\n-        variants = Variants.merge(dep_state.value.default.items(), variants)\n-\n-    # If there is a variant_key, see whether it has been configured.\n-    variant_value = None\n-    if self.variant_key:\n-      variant_values = [value for key, value in variants\n-                        if key == self.variant_key] if variants else None\n-      if not variant_values:\n-        # Select cannot be satisfied: no variant configured for this key.\n-        return Noop('Variant key {} was not configured in variants {}'.format(\n-          self.variant_key, variants))\n-      variant_value = variant_values[0]\n-\n-    # If the Subject \"is a\" or \"has a\" Product, then we're done.\n-    literal_value = self._select_literal(self.subject, variant_value)\n-    if literal_value is not None:\n-      return Return(literal_value)\n-\n-    # Else, attempt to use a configured task to compute the value.\n-    has_waiting_dep = False\n-    dependencies = list(node_builder.task_nodes(self.subject, self.product, variants))\n-    matches = {}\n-    for dep in dependencies:\n-      dep_state = dependency_states.get(dep, None)\n-      if dep_state is None or type(dep_state) == Waiting:\n-        has_waiting_dep = True\n-        continue\n-      elif type(dep_state) == Throw:\n-        return dep_state\n-      elif type(dep_state) == Noop:\n-        continue\n-      elif type(dep_state) != Return:\n-        State.raise_unrecognized(dep_state)\n-      # We computed a value: see whether we can use it.\n-      literal_value = self._select_literal(dep_state.value, variant_value)\n-      if literal_value is not None:\n-        matches[dep] = literal_value\n-    if has_waiting_dep:\n-      return Waiting(dependencies)\n-    elif len(matches) > 1:\n-      # TODO: Multiple successful tasks are not currently supported. We should allow for this\n-      # by adding support for \"mergeable\" products. see:\n-      #   https://github.com/pantsbuild/pants/issues/2526\n-      return Throw(ConflictingProducersError(self.subject, self.product, matches))\n-    elif len(matches) == 1:\n-      return Return(matches.values()[0])\n-    return Noop('No source of {}.'.format(self))\n-\n-\n-class DependenciesNode(datatype('DependenciesNode', ['subject', 'product', 'variants', 'dep_product']), Node):\n-  \"\"\"A Node that selects the given Product for each of the dependencies of this subject.\n-\n-  Begins by selecting the `dep_product` for the subject, and then selects a product for each\n-  of dep_products' dependencies.\n-\n-  The value produced by this Node guarantees that the order of the provided values matches the\n-  order of declaration in the `dependencies` list of the `dep_product`.\n-  \"\"\"\n-\n-  def _dep_product_node(self):\n-    return SelectNode(self.subject, self.dep_product, self.variants, None)\n-\n-  def _dep_node(self, dependency):\n-    variants = self.variants\n-    if isinstance(dependency, Address):\n-      # If a subject has literal variants for particular dependencies, they win over all else.\n-      dependency, literal_variants = parse_variants(dependency)\n-      variants = Variants.merge(variants, literal_variants)\n-    return SelectNode(dependency, self.product, variants, None)\n-\n-  def step(self, dependency_states, node_builder):\n-    # Request the product we need in order to request dependencies.\n-    dep_product_node = self._dep_product_node()\n-    dep_product_state = dependency_states.get(dep_product_node, None)\n-    if dep_product_state is None or type(dep_product_state) == Waiting:\n-      return Waiting([dep_product_node])\n-    elif type(dep_product_state) == Throw:\n-      return dep_product_state\n-    elif type(dep_product_state) == Noop:\n-      return Noop('Could not compute {} to determine dependencies.'.format(dep_product_node))\n-    elif type(dep_product_state) != Return:\n-      State.raise_unrecognized(dep_product_state)\n-\n-    # The product and its dependency list are available.\n-    dep_product = dep_product_state.value\n-    dependencies = [self._dep_node(d) for d in dep_product.dependencies]\n-    for dependency in dependencies:\n-      dep_state = dependency_states.get(dependency, None)\n-      if dep_state is None or type(dep_state) == Waiting:\n-        # One of the dependencies is not yet available. Indicate that we are waiting for all\n-        # of them.\n-        return Waiting([dep_product_node] + dependencies)\n-      elif type(dep_state) == Throw:\n-        return dep_state\n-      elif type(dep_state) == Noop:\n-        return Throw(ValueError('No source of explicit dependency {}'.format(dependency)))\n-      elif type(dep_state) != Return:\n-        raise State.raise_unrecognized(dep_state)\n-    # All dependencies are present! Set our value to a list of the resulting values.\n-    return Return([dependency_states[d].value for d in dependencies])\n-\n-\n-class TaskNode(datatype('TaskNode', ['subject', 'product', 'variants', 'func', 'clause']), Node):\n-\n-  def step(self, dependency_states, node_builder):\n-    # Compute dependencies.\n-    dep_values = []\n-    dependencies = []\n-    for select in self.clause:\n-      dep = select.construct_node(self.subject, self.variants)\n-      if dep is None:\n-        return Noop('Dependency {} is not satisfiable.'.format(select))\n-      dependencies.append(dep)\n-\n-    # If all dependency Nodes are Return, execute the Node.\n-    for dep_select, dep_key in zip(self.clause, dependencies):\n-      dep_state = dependency_states.get(dep_key, None)\n-      if dep_state is None or type(dep_state) == Waiting:\n-        return Waiting(dependencies)\n-      elif type(dep_state) == Return:\n-        dep_values.append(dep_state.value)\n-      elif type(dep_state) == Noop:\n-        if dep_select.optional:\n-          dep_values.append(None)\n-        else:\n-          return Noop('Was missing (at least) input {}.'.format(dep_key))\n-      elif type(dep_state) == Throw:\n-        return dep_state\n-      else:\n-        State.raise_unrecognized(dep_state)\n-    try:\n-      return Return(self.func(*dep_values))\n-    except Exception as e:\n-      return Throw(e)\n-\n-\n class ProductGraph(object):\n",
        "source_code_with_indent": "\n<DED><DED>class ConflictingProducersError(SchedulingError):\n  <IND>\"\"\"Indicates that there was more than one source of a product for a given subject.\n\n  TODO: This will need to be legal in order to support multiple Planners producing a\n  (mergeable) Classpath for one subject, for example. see:\n    https://github.com/pantsbuild/pants/issues/2526\n  \"\"\"\n\n  def __init__(self, subject, product, matches):\n    <IND>msgs = '\\n  '.join('{}: {}'.format(k, v) for k, v in matches.items())\n    msg = 'More than one source of {} for {}:\\n  {}'.format(product.__name__, subject, msgs)\n    super(ConflictingProducersError, self).__init__(msg)\n\n\n<DED><DED>class State(object):\n  <IND>@classmethod\n  def raise_unrecognized(cls, state):\n    <IND>raise ValueError('Unrecognized Node State: {}'.format(state))\n\n\n<DED><DED>class Noop(datatype('Noop', ['msg']), State):\n  <IND>\"\"\"Indicates that a Node did not have the inputs which would be needed for it to execute.\"\"\"\n  pass\n\n\n<DED>class Return(datatype('Return', ['value']), State):\n  <IND>\"\"\"Indicates that a Node successfully returned a value.\"\"\"\n  pass\n\n\n<DED>class Throw(datatype('Throw', ['exc']), State):\n  <IND>\"\"\"Indicates that a Node should have been able to return a value, but failed.\"\"\"\n  pass\n\n\n<DED>class Waiting(datatype('Waiting', ['dependencies']), State):\n  <IND>\"\"\"Indicates that a Node is waiting for some/all of the dependencies to become available.\n\n  Some Nodes will return different dependency Nodes based on where they are in their lifecycle,\n  but all returned dependencies are recorded for the lifetime of a ProductGraph.\n  \"\"\"\n  pass\n\n\n<DED>class Node(object):\n  <IND>@abstractproperty\n  def subject(self):\n    <IND>\"\"\"The subject for this Node.\"\"\"\n\n  <DED>@abstractproperty\n  def product(self):\n    <IND>\"\"\"The output product for this Node.\"\"\"\n\n  <DED>@abstractproperty\n  def variants(self):\n    <IND>\"\"\"The variants for this Node.\"\"\"\n\n  <DED>@abstractmethod\n  def step(self, dependency_states, node_builder):\n    <IND>\"\"\"Given a dict of the dependency States for this Node, returns the current State of the Node.\n\n    The NodeBuilder parameter provides a way to construct Nodes that require information about\n    installed tasks.\n\n    After this method returns a non-Waiting state, it will never be visited again for this Node.\n    \"\"\"\n\n\n<DED><DED>class SelectNode(datatype('SelectNode', ['subject', 'product', 'variants', 'variant_key']), Node):\n  <IND>\"\"\"A Node that selects a product for a subject.\n\n  A Select can be satisfied by multiple sources, but fails if multiple sources produce a value. The\n  'variants' field represents variant configuration that is propagated to dependencies. When\n  a task needs to consume a product as configured by the variants map, it uses the SelectVariant\n  selector, which introduces the 'variant' value to restrict the names of values selected by a\n  SelectNode.\n  \"\"\"\n\n  def _variants_node(self):\n    <IND>if self.product != Variants:\n      <IND>return SelectNode(self.subject, Variants, self.variants, None)\n    <DED>return None\n\n  <DED>def _select_literal(self, candidate, variant_value):\n    <IND>\"\"\"Looks for has-a or is-a relationships between the given value and the requested product.\n\n    Returns the resulting product value, or None if no match was made.\n    \"\"\"\n    def items():\n      # Check whether the subject is-a instance of the product.\n      <IND>yield candidate\n      # Else, check whether it has-a instance of the product.\n      if isinstance(candidate, Target):\n        <IND>for configuration in candidate.configurations:\n          <IND>yield configuration\n\n    # TODO: returning only the first literal configuration of a given type/variant. Need to\n    # define mergeability for products.\n    <DED><DED><DED>for item in items():\n      <IND>if not isinstance(item, self.product):\n        <IND>continue\n      <DED>if variant_value and not getattr(item, 'name', None) == variant_value:\n        <IND>continue\n      <DED>return item\n    <DED>return None\n\n  <DED>def step(self, dependency_states, node_builder):\n    # Request default Variants for the subject, so that if there are any we can propagate\n    # them to task nodes.\n    <IND>variants = self.variants\n    variants_node = self._variants_node()\n    if variants_node:\n      <IND>dep_state = dependency_states.get(variants_node, None)\n      if dep_state is None or type(dep_state) == Waiting:\n        <IND>return Waiting([variants_node])\n      <DED>elif type(dep_state) == Return:\n        # A subject's variants are overridden by any dependent's requested variants, so\n        # we merge them left to right here.\n        <IND>variants = Variants.merge(dep_state.value.default.items(), variants)\n\n    # If there is a variant_key, see whether it has been configured.\n    <DED><DED>variant_value = None\n    if self.variant_key:\n      <IND>variant_values = [value for key, value in variants\n                        if key == self.variant_key] if variants else None\n      if not variant_values:\n        # Select cannot be satisfied: no variant configured for this key.\n        <IND>return Noop('Variant key {} was not configured in variants {}'.format(\n          self.variant_key, variants))\n      <DED>variant_value = variant_values[0]\n\n    # If the Subject \"is a\" or \"has a\" Product, then we're done.\n    <DED>literal_value = self._select_literal(self.subject, variant_value)\n    if literal_value is not None:\n      <IND>return Return(literal_value)\n\n    # Else, attempt to use a configured task to compute the value.\n    <DED>has_waiting_dep = False\n    dependencies = list(node_builder.task_nodes(self.subject, self.product, variants))\n    matches = {}\n    for dep in dependencies:\n      <IND>dep_state = dependency_states.get(dep, None)\n      if dep_state is None or type(dep_state) == Waiting:\n        <IND>has_waiting_dep = True\n        continue\n      <DED>elif type(dep_state) == Throw:\n        <IND>return dep_state\n      <DED>elif type(dep_state) == Noop:\n        <IND>continue\n      <DED>elif type(dep_state) != Return:\n        <IND>State.raise_unrecognized(dep_state)\n      # We computed a value: see whether we can use it.\n      <DED>literal_value = self._select_literal(dep_state.value, variant_value)\n      if literal_value is not None:\n        <IND>matches[dep] = literal_value\n    <DED><DED>if has_waiting_dep:\n      <IND>return Waiting(dependencies)\n    <DED>elif len(matches) > 1:\n      # TODO: Multiple successful tasks are not currently supported. We should allow for this\n      # by adding support for \"mergeable\" products. see:\n      #   https://github.com/pantsbuild/pants/issues/2526\n      <IND>return Throw(ConflictingProducersError(self.subject, self.product, matches))\n    <DED>elif len(matches) == 1:\n      <IND>return Return(matches.values()[0])\n    <DED>return Noop('No source of {}.'.format(self))\n\n\n<DED><DED>class DependenciesNode(datatype('DependenciesNode', ['subject', 'product', 'variants', 'dep_product']), Node):\n  <IND>\"\"\"A Node that selects the given Product for each of the dependencies of this subject.\n\n  Begins by selecting the `dep_product` for the subject, and then selects a product for each\n  of dep_products' dependencies.\n\n  The value produced by this Node guarantees that the order of the provided values matches the\n  order of declaration in the `dependencies` list of the `dep_product`.\n  \"\"\"\n\n  def _dep_product_node(self):\n    <IND>return SelectNode(self.subject, self.dep_product, self.variants, None)\n\n  <DED>def _dep_node(self, dependency):\n    <IND>variants = self.variants\n    if isinstance(dependency, Address):\n      # If a subject has literal variants for particular dependencies, they win over all else.\n      <IND>dependency, literal_variants = parse_variants(dependency)\n      variants = Variants.merge(variants, literal_variants)\n    <DED>return SelectNode(dependency, self.product, variants, None)\n\n  <DED>def step(self, dependency_states, node_builder):\n    # Request the product we need in order to request dependencies.\n    <IND>dep_product_node = self._dep_product_node()\n    dep_product_state = dependency_states.get(dep_product_node, None)\n    if dep_product_state is None or type(dep_product_state) == Waiting:\n      <IND>return Waiting([dep_product_node])\n    <DED>elif type(dep_product_state) == Throw:\n      <IND>return dep_product_state\n    <DED>elif type(dep_product_state) == Noop:\n      <IND>return Noop('Could not compute {} to determine dependencies.'.format(dep_product_node))\n    <DED>elif type(dep_product_state) != Return:\n      <IND>State.raise_unrecognized(dep_product_state)\n\n    # The product and its dependency list are available.\n    <DED>dep_product = dep_product_state.value\n    dependencies = [self._dep_node(d) for d in dep_product.dependencies]\n    for dependency in dependencies:\n      <IND>dep_state = dependency_states.get(dependency, None)\n      if dep_state is None or type(dep_state) == Waiting:\n        # One of the dependencies is not yet available. Indicate that we are waiting for all\n        # of them.\n        <IND>return Waiting([dep_product_node] + dependencies)\n      <DED>elif type(dep_state) == Throw:\n        <IND>return dep_state\n      <DED>elif type(dep_state) == Noop:\n        <IND>return Throw(ValueError('No source of explicit dependency {}'.format(dependency)))\n      <DED>elif type(dep_state) != Return:\n        <IND>raise State.raise_unrecognized(dep_state)\n    # All dependencies are present! Set our value to a list of the resulting values.\n    <DED><DED>return Return([dependency_states[d].value for d in dependencies])\n\n\n<DED><DED>class TaskNode(datatype('TaskNode', ['subject', 'product', 'variants', 'func', 'clause']), Node):\n\n  <IND>def step(self, dependency_states, node_builder):\n    # Compute dependencies.\n    <IND>dep_values = []\n    dependencies = []\n    for select in self.clause:\n      <IND>dep = select.construct_node(self.subject, self.variants)\n      if dep is None:\n        <IND>return Noop('Dependency {} is not satisfiable.'.format(select))\n      <DED>dependencies.append(dep)\n\n    # If all dependency Nodes are Return, execute the Node.\n    <DED>for dep_select, dep_key in zip(self.clause, dependencies):\n      <IND>dep_state = dependency_states.get(dep_key, None)\n      if dep_state is None or type(dep_state) == Waiting:\n        <IND>return Waiting(dependencies)\n      <DED>elif type(dep_state) == Return:\n        <IND>dep_values.append(dep_state.value)\n      <DED>elif type(dep_state) == Noop:\n        <IND>if dep_select.optional:\n          <IND>dep_values.append(None)\n        <DED>else:\n          <IND>return Noop('Was missing (at least) input {}.'.format(dep_key))\n      <DED><DED>elif type(dep_state) == Throw:\n        <IND>return dep_state\n      <DED>else:\n        <IND>State.raise_unrecognized(dep_state)\n    <DED><DED>try:\n      <IND>return Return(self.func(*dep_values))\n    <DED>except Exception as e:\n      <IND>return Throw(e)\n\n\n<DED><DED><DED>class ProductGraph(object):\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n<DED><DED>class ProductGraph(object):\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  }
]