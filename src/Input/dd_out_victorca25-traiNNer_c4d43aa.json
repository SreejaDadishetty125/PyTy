[
  {
    "project": "victorca25/traiNNer",
    "commit": "c4d43aab78b8c3cda9ef3c129390dfe73eca7c26",
    "filename": "opencv_transforms/transforms.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/victorca25-traiNNer/opencv_transforms/transforms.py",
    "file_hunks_size": 18,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "opencv_transforms/transforms.py:1686:59 Unsupported operand [58]: `>=` is not supported for operand types `numbers.Number` and `int`.",
    "message": " `>=` is not supported for operand types `numbers.Number` and `int`.",
    "rule_id": "Unsupported operand [58]",
    "warning_line_no": 1686,
    "warning_line": "        assert isinstance(min_quality, numbers.Number) and min_quality >= 0, 'min_quality should be a positive value'",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\nclass RandomGaussianNoise:\n    \"\"\"Applying gaussian noise on the given CV Image randomly with a given probability.\n\n        Args:\n            p (float): probability of the image being noised. Default value is 0.5\n            mean (float): Mean (\u201ccentre\u201d) of the Gaussian distribution. Default=0.0\n            std (float): Standard deviation (spread or \u201cwidth\u201d) sigma of the Gaussian distribution. Default=1.0\n            gtype ('str': ``color`` or ``bw``): Type of Gaussian noise to add, either colored or black and white. \n                Default='color' (Note: can introduce color noise during training)\n            random_params (bool): if enabled, will randomly get the parameters for the noise function\n                on each iteration. It uses the \"mean\" and \"std\" parameters as the mean and variance range\n                to sample from. \n        \"\"\"\n\n    def __init__(self, p:float=0.5, mean=0, std:float=1.0, gtype='color', random_params = False):\n        assert isinstance(mean, numbers.Number) and mean >= 0, 'mean should be a positive value'\n        assert isinstance(std, numbers.Number) and std >= 0, 'std should be a positive value'\n        assert isinstance(p, numbers.Number) and p >= 0, 'p should be a positive value'\n        assert isinstance(gtype, str), 'gtype is a string'\n        self.p = p\n        self.gtype = gtype\n        self.mean = mean\n        self.std = std\n        self.random_params = random_params\n\n    @staticmethod\n    def get_params(mean, std):\n        \"\"\"Get parameters for gaussian noise\n\n        Returns:\n            sequence: params to be passed to the affine transformation\n        \"\"\"\n        mean = np.random.uniform(-mean, mean) #= 0\n        std = np.random.uniform(0.1, std) #(4, 200)\n\n        return mean, std\n\n    def __call__(self, img):\n        \"\"\"\n        Args:\n            img (np.ndarray): Image to be noised.\n\n        Returns:\n            np.ndarray: Randomly noised image.\n        \"\"\"\n        if random.random() < self.p:\n            if self.random_params:\n                mean, std = self.get_params(self.mean, self.std) \n            else:\n                mean, std = self.mean, self.std\n            return EF.noise_gaussian(img, mean=mean, std=std, gtype=self.gtype)\n        return img\n\n    def __repr__(self):\n        return self.__class__.__name__ + '(p={})'.format(self.p)\n\n\nclass RandomPoissonNoise:\n    \"\"\"Applying Poisson noise on the given CV Image randomly with a given probability.\n\n        Args:\n            p (float): probability of the image being noised. Default value is 0.5\n        \"\"\"\n\n    def __init__(self, p:float=0.5):\n        assert isinstance(p, numbers.Number) and p >= 0, 'p should be a positive value'\n        self.p = p\n\n    def __call__(self, img):\n        \"\"\"\n        Args:\n            img (np.ndarray): Image to be noised.\n\n        Returns:\n            np.ndarray: Randomly noised image.\n        \"\"\"\n        if random.random() < self.p:\n            return EF.noise_poisson(img)\n        return img\n\n    def __repr__(self):\n        return self.__class__.__name__ + '(p={})'.format(self.p)\n\n\nclass RandomSPNoise:\n    \"\"\"Applying salt and pepper noise on the given CV Image randomly with a given probability.\n\n        Args:\n            p (float): probability of the image being noised. Default value is 0.5\n            prob (float): probability (threshold) that controls level of S&P noise\n        \"\"\"\n\n    def __init__(self, p:float=0.5, prob:float=0.1):\n        assert isinstance(p, numbers.Number) and p >= 0, 'p should be a positive value'\n        assert isinstance(prob, numbers.Number) and prob >= 0, 'p should be a positive value'\n        self.p = p\n        self.prob = prob\n\n    def __call__(self, img):\n        \"\"\"\n        Args:\n            img (np.ndarray): Image to be noised.\n\n        Returns:\n            np.ndarray: Randomly noised image.\n        \"\"\"\n        if random.random() < self.p:\n            return EF.noise_salt_and_pepper(img, self.prob)\n        return img\n\n    def __repr__(self):\n        return self.__class__.__name__ + '(p={})'.format(self.p)\n\n\nclass RandomSpeckleNoise:\n    \"\"\"Applying speckle noise on the given CV Image randomly with a given probability.\n\n        Args:\n            p (float): probability of the image being noised. Default value is 0.5\n            std (float): Standard deviation (spread or \u201cwidth\u201d) sigma of the Gaussian distribution.\n                Default=0.12. Random range should be around (0.04, 0.2)\n            gtype ('str': ``color`` or ``bw``): Type of noise to add, either colored or black and white. \n                Default='color' (Note: can introduce color noise during training)\n            random_params (bool): if enabled, will randomly get the parameters for the noise function\n                on each iteration. It uses the \"std\" parameter as the maximum variance to sample from. \n        \"\"\"\n\n    def __init__(self, p:float=0.5, std:float=0.12, gtype='color', random_params = False):\n        assert isinstance(std, numbers.Number) and std >= 0, 'std should be a positive value'\n        assert isinstance(p, numbers.Number) and p >= 0, 'p should be a positive value'\n        assert isinstance(gtype, str), 'gtype is a string'\n        self.p = p\n        self.std = std\n        self.gtype = gtype\n        self.random_params = random_params\n\n    @staticmethod\n    def get_params(mean, std):\n        \"\"\"Get parameters for speckle noise\n\n        Returns:\n            sequence: params to be passed to the affine transformation\n        \"\"\"\n        #Variance of random distribution. variance = (standard deviation) ** 2. Default : 0.01\n        std = np.random.uniform(0.04, std) #(0.04, 0.2)\n\n        return std\n\n    def __call__(self, img):\n        \"\"\"\n        Args:\n            img (np.ndarray): Image to be noised.\n\n        Returns:\n            np.ndarray: Randomly noised image.\n        \"\"\"\n        if random.random() < self.p:\n            if self.random_params:\n                std = get_params(self.std)\n            else:\n                std = self.std\n            return EF.noise_speckle(img, mean=0.0, std=std, gtype=self.gtype)\n        return img\n\n    def __repr__(self):\n        return self.__class__.__name__ + '(p={})'.format(self.p)\n\nclass RandomCompression:\n    \"\"\"Applying JPEG compression on the given CV Image randomly with a given probability.\n\n        Args:\n            p (float): probability of the image being noised. Default value is 0.5\n            quality (int: [0,100]): Compression quality for the image. Lower values represent \n                higher compression and lower quality. Default=20\n            random_params (bool): if enabled, will randomly get the parameters for the noise function\n                on each iteration. It uses the \"quality\" parameter as maximum quality to randomly \n                sample with the minimum being 10% quality.\n        \"\"\"\n\n    def __init__(self, p:float=0.5, min_quality=20, max_quality=90, image_type='.jpg', random_params = True):\n        assert isinstance(min_quality, numbers.Number) and min_quality >= 0, 'min_quality should be a positive value'\n        assert isinstance(max_quality, numbers.Number) and max_quality >= 0, 'max_quality should be a positive value'\n        assert isinstance(p, numbers.Number) and p >= 0, 'p should be a positive value'\n        self.p = p\n        self.min_quality = min_quality\n        self.max_quality = max_quality\n        self.image_type = image_type\n        self.random_params = random_params\n\n    @staticmethod\n    def get_params(min_quality, max_quality):\n        \"\"\"Get compression level for JPEG noise\n\n        Returns:\n",
        "source_code_len": 7580,
        "target_code": "\n\nclass RandomGaussianNoise(RandomBase):\n    \"\"\"Apply gaussian noise on the given image randomly with a\n    given probability.\n    Args:\n        p (float): probability of the image being noised.\n            Default value is 0.5\n        mean (float): Mean (\u201ccenter\u201d) of the Gaussian distribution.\n            Default=0.0\n        var_limit ((float, float) or float): variance range for noise.\n            If var_limit is a single float, the range will be\n            (0, var_limit). Should be in range [0, 255] if using\n            `sigma_calc='sig'` or squared values of that range if\n            `sigma_calc='var'`. Default: (10.0, 50.0).\n        prob_color: Probably for selecting the type of Gaussian noise\n            to add, either colored or grayscale (``color`` or ``gray``),\n            in range [0.0, 1.0], higher means more chance of `color`.\n            (Note: Color type can introduce color noise during training)\n        multi: select to randomly generate multichannel-AWGN (MC-AWGN)\n            in addition to regular AWGN.\n        mode: select between Gaussian or Speckle noise modes\n        sigma_calc: select if var_limit is to be considered as the\n            variance (final sigma will be ``sigma = var ** 0.5``) or\n            sigma range (var_limit will be used directly for sigma).\n            In: `var`, `sig`.\n    \"\"\"\n\n    def __init__(self, p:float=0.5, mean:float=0.0,\n        var_limit=(10.0, 50.0), prob_color:float=0.5,\n        multi:bool=True, mode:str='gauss', sigma_calc:str='sig'):\n        super(RandomGaussianNoise, self).__init__(p=p)\n\n        if not isinstance(mean, numbers.Number) or mean < 0:\n            raise ValueError('Mean should be a positive value')\n        if isinstance(var_limit, (tuple, list)):\n            if var_limit[0] < 0 or var_limit[1] < 0:\n                raise ValueError(\n                    f\"var_limit values: {var_limit} should be non negative.\")\n            self.var_limit = var_limit\n        elif isinstance(var_limit, (int, float)):\n            if var_limit < 0:\n                raise ValueError(\"var_limit should be non negative.\")\n            self.var_limit = (0, var_limit)\n        else:\n            raise TypeError(\n                \"Expected var_limit type to be one of (int, float, \"\n                f\"tuple, list), got {type(var_limit)}\"\n            )\n\n        if not isinstance(prob_color, (int, float)):\n            raise ValueError('prob_color must be a number in [0, 1]')\n        self.prob_color = prob_color\n        self.mean = mean\n        self.mode = mode\n        self.multi = multi\n        self.sigma_calc = sigma_calc\n        self.params = self.get_params()\n\n    def apply(self, img, **params):\n        return EF.noise_gaussian(img, **params)\n\n    def get_params(self):\n        \"\"\"Get parameters for gaussian noise\n        Returns:\n            dict: params to be passed to the affine transformation\n        \"\"\"\n        # mean = random.uniform(-self.mean, self.mean) #= 0\n\n        gtype = 'color' if random.random() < self.prob_color else 'gray'\n\n        multi = False\n        if self.multi and random.random() > 0.66 and gtype == 'color':\n            # will only apply MC-AWGN 33% of the time\n            multi = True\n        if multi:\n            lim = self.var_limit\n            sigma = [random.uniform(lim[0], lim[1]) for _ in range(3)]\n            if self.mode == \"gauss\":\n                sigma = [(v ** 0.5) for v in sigma]\n        else:\n            # ref wide range: (4, 200)\n            var = random.uniform(self.var_limit[0], self.var_limit[1])\n\n            if self.mode == \"gauss\":\n                if self.sigma_calc == 'var':\n                    sigma = (var ** 0.5)\n                elif self.sigma_calc == 'sig':\n                    # no need to var/255 if image range in [0,255]\n                    sigma = var\n            elif self.mode == \"speckle\":\n                sigma = var\n\n        return {\"mean\": self.mean,\n                \"std\": sigma,\n                \"mode\": self.mode,\n                \"gtype\": gtype,\n                \"rounds\": False,\n                \"clip\": True,\n            }\n\n\nclass RandomPoissonNoise(RandomBase):\n    \"\"\"Apply Poisson noise on the given image randomly with\n    a given probability.\n    Args:\n        p: probability of the image being noised. Default value is 0.5\n    \"\"\"\n\n    def __init__(self, p:float=0.5):\n        super(RandomPoissonNoise, self).__init__(p=p)\n\n    def apply(self, img, **params):\n        return EF.noise_poisson(img, **params)\n\n\nclass RandomSPNoise(RandomBase):\n    \"\"\"Apply salt and pepper noise on the given image randomly\n    with a given probability.\n    Args:\n        p: probability of the image being noised. Default value is 0.5\n        prob: probability (threshold) that controls level of S&P noise\n    \"\"\"\n\n    def __init__(self, p:float=0.5, prob:float=0.1):\n        super(RandomSPNoise, self).__init__(p=p)\n\n        if not isinstance(prob, numbers.Number) or prob < 0:\n            raise ValueError(\"prob should be a positive value.\"\n                             f\"Got: {prob}\")\n        self.prob = prob\n        self.params = self.get_params()\n\n    def get_params(self):\n        \"\"\"Get parameters for noise.\n        Returns: dict of parameters.\n        \"\"\"\n        return {\"prob\": self.prob}\n\n    def apply(self, img, **params):\n        return EF.noise_salt_and_pepper(img, **params)\n\n\nclass RandomSpeckleNoise(RandomGaussianNoise):\n    \"\"\" Apply speckle noise on the given CV Image randomly with\n    a given probability. Note that it reuses RandomGaussianNoise\n    as a base, since the function is shared.\n    Args:\n        p: probability of the image being noised.\n            Default value is 0.5\n        mean: Mean (\u201ccenter\u201d) of the Gaussian distribution.\n            Default=0.0\n        var_limit ((float, float) or float): variance range for noise.\n            If var_limit is a single float, the range will be\n            (0, var_limit). Random range should be around (0.04, 0.2),\n            in range [0, 1.0]\n        prob_color: Probably for selecting the type of Gaussian noise\n            to add, either colored or grayscale (``color`` or ``gray``),\n            in range [0.0, 1.0], higher means more chance of `color`.\n            (Note: Color type can introduce color noise during training)\n    \"\"\"\n    def __init__(self, p:float=0.5, mean:float=0.0,\n        var_limit=(0.04, 0.12), prob_color:float=0.5,\n        sigma_calc:str='var'):\n\n        super(RandomSpeckleNoise, self).__init__(p=p, mean=mean,\n            var_limit=var_limit, prob_color=prob_color, multi=False,\n            mode='speckle', sigma_calc=sigma_calc)\n\n\nclass RandomCompression(RandomBase):\n    \"\"\"Apply compression to the given image randomly\n    with a given probability. Accepts JPEG and WEBP compression\n    types. For the compression quality, lower values represent\n    higher compression (lower quality).\n    Args:\n        p: probability of the image being noised. Default value is 0.5\n        quality (int: [0,100]):\n        min_quality: lower bound on the image quality. In [0, 100]\n            range for jpeg and [1, 100] for webp.\n        max_quality: upper bound on the image quality. In [0, 100]\n            range for jpeg and [1, 100] for webp.\n        compression_type: should be 'jpeg'/'jpg' or 'webp'.\n    \"\"\"\n\n    def __init__(self, p:float=0.5, min_quality:int=20,\n        max_quality:int=90, compression_type:str='.jpg'):\n        super(RandomCompression, self).__init__(p=p)\n\n        self.compression_type = compression_type\n        low_q_thresh = 1 if compression_type == \".webp\" else 0\n        if not  low_q_thresh <= min_quality <= 100:\n            raise ValueError(f\"Invalid min_quality. Got: {min_quality}\")\n        if not  low_q_thresh <= max_quality <= 100:\n            raise ValueError(f\"Invalid max_quality. Got: {max_quality}\")\n\n        self.min_quality = min_quality\n        self.max_quality = max_quality\n        self.params = self.get_params()\n\n    def get_params(self):\n        \"\"\"Get compression level for JPEG noise.\n            Randomize quality between min_quality and max_quality.\n        Returns:\n",
        "target_code_len": 8074,
        "diff_format": "@@ -1505,195 +1506,204 @@\n \n-class RandomGaussianNoise:\n-    \"\"\"Applying gaussian noise on the given CV Image randomly with a given probability.\n-\n-        Args:\n-            p (float): probability of the image being noised. Default value is 0.5\n-            mean (float): Mean (\u201ccentre\u201d) of the Gaussian distribution. Default=0.0\n-            std (float): Standard deviation (spread or \u201cwidth\u201d) sigma of the Gaussian distribution. Default=1.0\n-            gtype ('str': ``color`` or ``bw``): Type of Gaussian noise to add, either colored or black and white. \n-                Default='color' (Note: can introduce color noise during training)\n-            random_params (bool): if enabled, will randomly get the parameters for the noise function\n-                on each iteration. It uses the \"mean\" and \"std\" parameters as the mean and variance range\n-                to sample from. \n-        \"\"\"\n-\n-    def __init__(self, p:float=0.5, mean=0, std:float=1.0, gtype='color', random_params = False):\n-        assert isinstance(mean, numbers.Number) and mean >= 0, 'mean should be a positive value'\n-        assert isinstance(std, numbers.Number) and std >= 0, 'std should be a positive value'\n-        assert isinstance(p, numbers.Number) and p >= 0, 'p should be a positive value'\n-        assert isinstance(gtype, str), 'gtype is a string'\n-        self.p = p\n-        self.gtype = gtype\n+\n+class RandomGaussianNoise(RandomBase):\n+    \"\"\"Apply gaussian noise on the given image randomly with a\n+    given probability.\n+    Args:\n+        p (float): probability of the image being noised.\n+            Default value is 0.5\n+        mean (float): Mean (\u201ccenter\u201d) of the Gaussian distribution.\n+            Default=0.0\n+        var_limit ((float, float) or float): variance range for noise.\n+            If var_limit is a single float, the range will be\n+            (0, var_limit). Should be in range [0, 255] if using\n+            `sigma_calc='sig'` or squared values of that range if\n+            `sigma_calc='var'`. Default: (10.0, 50.0).\n+        prob_color: Probably for selecting the type of Gaussian noise\n+            to add, either colored or grayscale (``color`` or ``gray``),\n+            in range [0.0, 1.0], higher means more chance of `color`.\n+            (Note: Color type can introduce color noise during training)\n+        multi: select to randomly generate multichannel-AWGN (MC-AWGN)\n+            in addition to regular AWGN.\n+        mode: select between Gaussian or Speckle noise modes\n+        sigma_calc: select if var_limit is to be considered as the\n+            variance (final sigma will be ``sigma = var ** 0.5``) or\n+            sigma range (var_limit will be used directly for sigma).\n+            In: `var`, `sig`.\n+    \"\"\"\n+\n+    def __init__(self, p:float=0.5, mean:float=0.0,\n+        var_limit=(10.0, 50.0), prob_color:float=0.5,\n+        multi:bool=True, mode:str='gauss', sigma_calc:str='sig'):\n+        super(RandomGaussianNoise, self).__init__(p=p)\n+\n+        if not isinstance(mean, numbers.Number) or mean < 0:\n+            raise ValueError('Mean should be a positive value')\n+        if isinstance(var_limit, (tuple, list)):\n+            if var_limit[0] < 0 or var_limit[1] < 0:\n+                raise ValueError(\n+                    f\"var_limit values: {var_limit} should be non negative.\")\n+            self.var_limit = var_limit\n+        elif isinstance(var_limit, (int, float)):\n+            if var_limit < 0:\n+                raise ValueError(\"var_limit should be non negative.\")\n+            self.var_limit = (0, var_limit)\n+        else:\n+            raise TypeError(\n+                \"Expected var_limit type to be one of (int, float, \"\n+                f\"tuple, list), got {type(var_limit)}\"\n+            )\n+\n+        if not isinstance(prob_color, (int, float)):\n+            raise ValueError('prob_color must be a number in [0, 1]')\n+        self.prob_color = prob_color\n         self.mean = mean\n-        self.std = std\n-        self.random_params = random_params\n-\n-    @staticmethod\n-    def get_params(mean, std):\n+        self.mode = mode\n+        self.multi = multi\n+        self.sigma_calc = sigma_calc\n+        self.params = self.get_params()\n+\n+    def apply(self, img, **params):\n+        return EF.noise_gaussian(img, **params)\n+\n+    def get_params(self):\n         \"\"\"Get parameters for gaussian noise\n-\n-        Returns:\n-            sequence: params to be passed to the affine transformation\n-        \"\"\"\n-        mean = np.random.uniform(-mean, mean) #= 0\n-        std = np.random.uniform(0.1, std) #(4, 200)\n-\n-        return mean, std\n-\n-    def __call__(self, img):\n-        \"\"\"\n-        Args:\n-            img (np.ndarray): Image to be noised.\n-\n-        Returns:\n-            np.ndarray: Randomly noised image.\n-        \"\"\"\n-        if random.random() < self.p:\n-            if self.random_params:\n-                mean, std = self.get_params(self.mean, self.std) \n-            else:\n-                mean, std = self.mean, self.std\n-            return EF.noise_gaussian(img, mean=mean, std=std, gtype=self.gtype)\n-        return img\n-\n-    def __repr__(self):\n-        return self.__class__.__name__ + '(p={})'.format(self.p)\n-\n-\n-class RandomPoissonNoise:\n-    \"\"\"Applying Poisson noise on the given CV Image randomly with a given probability.\n-\n-        Args:\n-            p (float): probability of the image being noised. Default value is 0.5\n-        \"\"\"\n+        Returns:\n+            dict: params to be passed to the affine transformation\n+        \"\"\"\n+        # mean = random.uniform(-self.mean, self.mean) #= 0\n+\n+        gtype = 'color' if random.random() < self.prob_color else 'gray'\n+\n+        multi = False\n+        if self.multi and random.random() > 0.66 and gtype == 'color':\n+            # will only apply MC-AWGN 33% of the time\n+            multi = True\n+        if multi:\n+            lim = self.var_limit\n+            sigma = [random.uniform(lim[0], lim[1]) for _ in range(3)]\n+            if self.mode == \"gauss\":\n+                sigma = [(v ** 0.5) for v in sigma]\n+        else:\n+            # ref wide range: (4, 200)\n+            var = random.uniform(self.var_limit[0], self.var_limit[1])\n+\n+            if self.mode == \"gauss\":\n+                if self.sigma_calc == 'var':\n+                    sigma = (var ** 0.5)\n+                elif self.sigma_calc == 'sig':\n+                    # no need to var/255 if image range in [0,255]\n+                    sigma = var\n+            elif self.mode == \"speckle\":\n+                sigma = var\n+\n+        return {\"mean\": self.mean,\n+                \"std\": sigma,\n+                \"mode\": self.mode,\n+                \"gtype\": gtype,\n+                \"rounds\": False,\n+                \"clip\": True,\n+            }\n+\n+\n+class RandomPoissonNoise(RandomBase):\n+    \"\"\"Apply Poisson noise on the given image randomly with\n+    a given probability.\n+    Args:\n+        p: probability of the image being noised. Default value is 0.5\n+    \"\"\"\n \n     def __init__(self, p:float=0.5):\n-        assert isinstance(p, numbers.Number) and p >= 0, 'p should be a positive value'\n-        self.p = p\n-\n-    def __call__(self, img):\n-        \"\"\"\n-        Args:\n-            img (np.ndarray): Image to be noised.\n-\n-        Returns:\n-            np.ndarray: Randomly noised image.\n-        \"\"\"\n-        if random.random() < self.p:\n-            return EF.noise_poisson(img)\n-        return img\n-\n-    def __repr__(self):\n-        return self.__class__.__name__ + '(p={})'.format(self.p)\n-\n-\n-class RandomSPNoise:\n-    \"\"\"Applying salt and pepper noise on the given CV Image randomly with a given probability.\n-\n-        Args:\n-            p (float): probability of the image being noised. Default value is 0.5\n-            prob (float): probability (threshold) that controls level of S&P noise\n-        \"\"\"\n+        super(RandomPoissonNoise, self).__init__(p=p)\n+\n+    def apply(self, img, **params):\n+        return EF.noise_poisson(img, **params)\n+\n+\n+class RandomSPNoise(RandomBase):\n+    \"\"\"Apply salt and pepper noise on the given image randomly\n+    with a given probability.\n+    Args:\n+        p: probability of the image being noised. Default value is 0.5\n+        prob: probability (threshold) that controls level of S&P noise\n+    \"\"\"\n \n     def __init__(self, p:float=0.5, prob:float=0.1):\n-        assert isinstance(p, numbers.Number) and p >= 0, 'p should be a positive value'\n-        assert isinstance(prob, numbers.Number) and prob >= 0, 'p should be a positive value'\n-        self.p = p\n+        super(RandomSPNoise, self).__init__(p=p)\n+\n+        if not isinstance(prob, numbers.Number) or prob < 0:\n+            raise ValueError(\"prob should be a positive value.\"\n+                             f\"Got: {prob}\")\n         self.prob = prob\n-\n-    def __call__(self, img):\n-        \"\"\"\n-        Args:\n-            img (np.ndarray): Image to be noised.\n-\n-        Returns:\n-            np.ndarray: Randomly noised image.\n-        \"\"\"\n-        if random.random() < self.p:\n-            return EF.noise_salt_and_pepper(img, self.prob)\n-        return img\n-\n-    def __repr__(self):\n-        return self.__class__.__name__ + '(p={})'.format(self.p)\n-\n-\n-class RandomSpeckleNoise:\n-    \"\"\"Applying speckle noise on the given CV Image randomly with a given probability.\n-\n-        Args:\n-            p (float): probability of the image being noised. Default value is 0.5\n-            std (float): Standard deviation (spread or \u201cwidth\u201d) sigma of the Gaussian distribution.\n-                Default=0.12. Random range should be around (0.04, 0.2)\n-            gtype ('str': ``color`` or ``bw``): Type of noise to add, either colored or black and white. \n-                Default='color' (Note: can introduce color noise during training)\n-            random_params (bool): if enabled, will randomly get the parameters for the noise function\n-                on each iteration. It uses the \"std\" parameter as the maximum variance to sample from. \n-        \"\"\"\n-\n-    def __init__(self, p:float=0.5, std:float=0.12, gtype='color', random_params = False):\n-        assert isinstance(std, numbers.Number) and std >= 0, 'std should be a positive value'\n-        assert isinstance(p, numbers.Number) and p >= 0, 'p should be a positive value'\n-        assert isinstance(gtype, str), 'gtype is a string'\n-        self.p = p\n-        self.std = std\n-        self.gtype = gtype\n-        self.random_params = random_params\n-\n-    @staticmethod\n-    def get_params(mean, std):\n-        \"\"\"Get parameters for speckle noise\n-\n-        Returns:\n-            sequence: params to be passed to the affine transformation\n-        \"\"\"\n-        #Variance of random distribution. variance = (standard deviation) ** 2. Default : 0.01\n-        std = np.random.uniform(0.04, std) #(0.04, 0.2)\n-\n-        return std\n-\n-    def __call__(self, img):\n-        \"\"\"\n-        Args:\n-            img (np.ndarray): Image to be noised.\n-\n-        Returns:\n-            np.ndarray: Randomly noised image.\n-        \"\"\"\n-        if random.random() < self.p:\n-            if self.random_params:\n-                std = get_params(self.std)\n-            else:\n-                std = self.std\n-            return EF.noise_speckle(img, mean=0.0, std=std, gtype=self.gtype)\n-        return img\n-\n-    def __repr__(self):\n-        return self.__class__.__name__ + '(p={})'.format(self.p)\n-\n-class RandomCompression:\n-    \"\"\"Applying JPEG compression on the given CV Image randomly with a given probability.\n-\n-        Args:\n-            p (float): probability of the image being noised. Default value is 0.5\n-            quality (int: [0,100]): Compression quality for the image. Lower values represent \n-                higher compression and lower quality. Default=20\n-            random_params (bool): if enabled, will randomly get the parameters for the noise function\n-                on each iteration. It uses the \"quality\" parameter as maximum quality to randomly \n-                sample with the minimum being 10% quality.\n-        \"\"\"\n-\n-    def __init__(self, p:float=0.5, min_quality=20, max_quality=90, image_type='.jpg', random_params = True):\n-        assert isinstance(min_quality, numbers.Number) and min_quality >= 0, 'min_quality should be a positive value'\n-        assert isinstance(max_quality, numbers.Number) and max_quality >= 0, 'max_quality should be a positive value'\n-        assert isinstance(p, numbers.Number) and p >= 0, 'p should be a positive value'\n-        self.p = p\n+        self.params = self.get_params()\n+\n+    def get_params(self):\n+        \"\"\"Get parameters for noise.\n+        Returns: dict of parameters.\n+        \"\"\"\n+        return {\"prob\": self.prob}\n+\n+    def apply(self, img, **params):\n+        return EF.noise_salt_and_pepper(img, **params)\n+\n+\n+class RandomSpeckleNoise(RandomGaussianNoise):\n+    \"\"\" Apply speckle noise on the given CV Image randomly with\n+    a given probability. Note that it reuses RandomGaussianNoise\n+    as a base, since the function is shared.\n+    Args:\n+        p: probability of the image being noised.\n+            Default value is 0.5\n+        mean: Mean (\u201ccenter\u201d) of the Gaussian distribution.\n+            Default=0.0\n+        var_limit ((float, float) or float): variance range for noise.\n+            If var_limit is a single float, the range will be\n+            (0, var_limit). Random range should be around (0.04, 0.2),\n+            in range [0, 1.0]\n+        prob_color: Probably for selecting the type of Gaussian noise\n+            to add, either colored or grayscale (``color`` or ``gray``),\n+            in range [0.0, 1.0], higher means more chance of `color`.\n+            (Note: Color type can introduce color noise during training)\n+    \"\"\"\n+    def __init__(self, p:float=0.5, mean:float=0.0,\n+        var_limit=(0.04, 0.12), prob_color:float=0.5,\n+        sigma_calc:str='var'):\n+\n+        super(RandomSpeckleNoise, self).__init__(p=p, mean=mean,\n+            var_limit=var_limit, prob_color=prob_color, multi=False,\n+            mode='speckle', sigma_calc=sigma_calc)\n+\n+\n+class RandomCompression(RandomBase):\n+    \"\"\"Apply compression to the given image randomly\n+    with a given probability. Accepts JPEG and WEBP compression\n+    types. For the compression quality, lower values represent\n+    higher compression (lower quality).\n+    Args:\n+        p: probability of the image being noised. Default value is 0.5\n+        quality (int: [0,100]):\n+        min_quality: lower bound on the image quality. In [0, 100]\n+            range for jpeg and [1, 100] for webp.\n+        max_quality: upper bound on the image quality. In [0, 100]\n+            range for jpeg and [1, 100] for webp.\n+        compression_type: should be 'jpeg'/'jpg' or 'webp'.\n+    \"\"\"\n+\n+    def __init__(self, p:float=0.5, min_quality:int=20,\n+        max_quality:int=90, compression_type:str='.jpg'):\n+        super(RandomCompression, self).__init__(p=p)\n+\n+        self.compression_type = compression_type\n+        low_q_thresh = 1 if compression_type == \".webp\" else 0\n+        if not  low_q_thresh <= min_quality <= 100:\n+            raise ValueError(f\"Invalid min_quality. Got: {min_quality}\")\n+        if not  low_q_thresh <= max_quality <= 100:\n+            raise ValueError(f\"Invalid max_quality. Got: {max_quality}\")\n+\n         self.min_quality = min_quality\n         self.max_quality = max_quality\n-        self.image_type = image_type\n-        self.random_params = random_params\n-\n-    @staticmethod\n-    def get_params(min_quality, max_quality):\n-        \"\"\"Get compression level for JPEG noise\n-\n+        self.params = self.get_params()\n+\n+    def get_params(self):\n+        \"\"\"Get compression level for JPEG noise.\n+            Randomize quality between min_quality and max_quality.\n         Returns:\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\n<DED><DED>class RandomGaussianNoise:\n    <IND>\"\"\"Applying gaussian noise on the given CV Image randomly with a given probability.\n\n        Args:\n            p (float): probability of the image being noised. Default value is 0.5\n            mean (float): Mean (\u201ccentre\u201d) of the Gaussian distribution. Default=0.0\n            std (float): Standard deviation (spread or \u201cwidth\u201d) sigma of the Gaussian distribution. Default=1.0\n            gtype ('str': ``color`` or ``bw``): Type of Gaussian noise to add, either colored or black and white. \n                Default='color' (Note: can introduce color noise during training)\n            random_params (bool): if enabled, will randomly get the parameters for the noise function\n                on each iteration. It uses the \"mean\" and \"std\" parameters as the mean and variance range\n                to sample from. \n        \"\"\"\n\n    def __init__(self, p:float=0.5, mean=0, std:float=1.0, gtype='color', random_params = False):\n        <IND>assert isinstance(mean, numbers.Number) and mean >= 0, 'mean should be a positive value'\n        assert isinstance(std, numbers.Number) and std >= 0, 'std should be a positive value'\n        assert isinstance(p, numbers.Number) and p >= 0, 'p should be a positive value'\n        assert isinstance(gtype, str), 'gtype is a string'\n        self.p = p\n        self.gtype = gtype\n        self.mean = mean\n        self.std = std\n        self.random_params = random_params\n\n    <DED>@staticmethod\n    def get_params(mean, std):\n        <IND>\"\"\"Get parameters for gaussian noise\n\n        Returns:\n            sequence: params to be passed to the affine transformation\n        \"\"\"\n        mean = np.random.uniform(-mean, mean) #= 0\n        std = np.random.uniform(0.1, std) #(4, 200)\n\n        return mean, std\n\n    <DED>def __call__(self, img):\n        <IND>\"\"\"\n        Args:\n            img (np.ndarray): Image to be noised.\n\n        Returns:\n            np.ndarray: Randomly noised image.\n        \"\"\"\n        if random.random() < self.p:\n            <IND>if self.random_params:\n                <IND>mean, std = self.get_params(self.mean, self.std) \n            <DED>else:\n                <IND>mean, std = self.mean, self.std\n            <DED>return EF.noise_gaussian(img, mean=mean, std=std, gtype=self.gtype)\n        <DED>return img\n\n    <DED>def __repr__(self):\n        <IND>return self.__class__.__name__ + '(p={})'.format(self.p)\n\n\n<DED><DED>class RandomPoissonNoise:\n    <IND>\"\"\"Applying Poisson noise on the given CV Image randomly with a given probability.\n\n        Args:\n            p (float): probability of the image being noised. Default value is 0.5\n        \"\"\"\n\n    def __init__(self, p:float=0.5):\n        <IND>assert isinstance(p, numbers.Number) and p >= 0, 'p should be a positive value'\n        self.p = p\n\n    <DED>def __call__(self, img):\n        <IND>\"\"\"\n        Args:\n            img (np.ndarray): Image to be noised.\n\n        Returns:\n            np.ndarray: Randomly noised image.\n        \"\"\"\n        if random.random() < self.p:\n            <IND>return EF.noise_poisson(img)\n        <DED>return img\n\n    <DED>def __repr__(self):\n        <IND>return self.__class__.__name__ + '(p={})'.format(self.p)\n\n\n<DED><DED>class RandomSPNoise:\n    <IND>\"\"\"Applying salt and pepper noise on the given CV Image randomly with a given probability.\n\n        Args:\n            p (float): probability of the image being noised. Default value is 0.5\n            prob (float): probability (threshold) that controls level of S&P noise\n        \"\"\"\n\n    def __init__(self, p:float=0.5, prob:float=0.1):\n        <IND>assert isinstance(p, numbers.Number) and p >= 0, 'p should be a positive value'\n        assert isinstance(prob, numbers.Number) and prob >= 0, 'p should be a positive value'\n        self.p = p\n        self.prob = prob\n\n    <DED>def __call__(self, img):\n        <IND>\"\"\"\n        Args:\n            img (np.ndarray): Image to be noised.\n\n        Returns:\n            np.ndarray: Randomly noised image.\n        \"\"\"\n        if random.random() < self.p:\n            <IND>return EF.noise_salt_and_pepper(img, self.prob)\n        <DED>return img\n\n    <DED>def __repr__(self):\n        <IND>return self.__class__.__name__ + '(p={})'.format(self.p)\n\n\n<DED><DED>class RandomSpeckleNoise:\n    <IND>\"\"\"Applying speckle noise on the given CV Image randomly with a given probability.\n\n        Args:\n            p (float): probability of the image being noised. Default value is 0.5\n            std (float): Standard deviation (spread or \u201cwidth\u201d) sigma of the Gaussian distribution.\n                Default=0.12. Random range should be around (0.04, 0.2)\n            gtype ('str': ``color`` or ``bw``): Type of noise to add, either colored or black and white. \n                Default='color' (Note: can introduce color noise during training)\n            random_params (bool): if enabled, will randomly get the parameters for the noise function\n                on each iteration. It uses the \"std\" parameter as the maximum variance to sample from. \n        \"\"\"\n\n    def __init__(self, p:float=0.5, std:float=0.12, gtype='color', random_params = False):\n        <IND>assert isinstance(std, numbers.Number) and std >= 0, 'std should be a positive value'\n        assert isinstance(p, numbers.Number) and p >= 0, 'p should be a positive value'\n        assert isinstance(gtype, str), 'gtype is a string'\n        self.p = p\n        self.std = std\n        self.gtype = gtype\n        self.random_params = random_params\n\n    <DED>@staticmethod\n    def get_params(mean, std):\n        <IND>\"\"\"Get parameters for speckle noise\n\n        Returns:\n            sequence: params to be passed to the affine transformation\n        \"\"\"\n        #Variance of random distribution. variance = (standard deviation) ** 2. Default : 0.01\n        std = np.random.uniform(0.04, std) #(0.04, 0.2)\n\n        return std\n\n    <DED>def __call__(self, img):\n        <IND>\"\"\"\n        Args:\n            img (np.ndarray): Image to be noised.\n\n        Returns:\n            np.ndarray: Randomly noised image.\n        \"\"\"\n        if random.random() < self.p:\n            <IND>if self.random_params:\n                <IND>std = get_params(self.std)\n            <DED>else:\n                <IND>std = self.std\n            <DED>return EF.noise_speckle(img, mean=0.0, std=std, gtype=self.gtype)\n        <DED>return img\n\n    <DED>def __repr__(self):\n        <IND>return self.__class__.__name__ + '(p={})'.format(self.p)\n\n<DED><DED>class RandomCompression:\n    <IND>\"\"\"Applying JPEG compression on the given CV Image randomly with a given probability.\n\n        Args:\n            p (float): probability of the image being noised. Default value is 0.5\n            quality (int: [0,100]): Compression quality for the image. Lower values represent \n                higher compression and lower quality. Default=20\n            random_params (bool): if enabled, will randomly get the parameters for the noise function\n                on each iteration. It uses the \"quality\" parameter as maximum quality to randomly \n                sample with the minimum being 10% quality.\n        \"\"\"\n\n    def __init__(self, p:float=0.5, min_quality=20, max_quality=90, image_type='.jpg', random_params = True):\n        <IND>assert isinstance(min_quality, numbers.Number) and min_quality >= 0, 'min_quality should be a positive value'\n        assert isinstance(max_quality, numbers.Number) and max_quality >= 0, 'max_quality should be a positive value'\n        assert isinstance(p, numbers.Number) and p >= 0, 'p should be a positive value'\n        self.p = p\n        self.min_quality = min_quality\n        self.max_quality = max_quality\n        self.image_type = image_type\n        self.random_params = random_params\n\n    <DED>@staticmethod\n    def get_params(min_quality, max_quality):\n        <IND>",
        "target_code_with_indent": "\n\n<DED><DED>class RandomGaussianNoise(RandomBase):\n    <IND>\"\"\"Apply gaussian noise on the given image randomly with a\n    given probability.\n    Args:\n        p (float): probability of the image being noised.\n            Default value is 0.5\n        mean (float): Mean (\u201ccenter\u201d) of the Gaussian distribution.\n            Default=0.0\n        var_limit ((float, float) or float): variance range for noise.\n            If var_limit is a single float, the range will be\n            (0, var_limit). Should be in range [0, 255] if using\n            `sigma_calc='sig'` or squared values of that range if\n            `sigma_calc='var'`. Default: (10.0, 50.0).\n        prob_color: Probably for selecting the type of Gaussian noise\n            to add, either colored or grayscale (``color`` or ``gray``),\n            in range [0.0, 1.0], higher means more chance of `color`.\n            (Note: Color type can introduce color noise during training)\n        multi: select to randomly generate multichannel-AWGN (MC-AWGN)\n            in addition to regular AWGN.\n        mode: select between Gaussian or Speckle noise modes\n        sigma_calc: select if var_limit is to be considered as the\n            variance (final sigma will be ``sigma = var ** 0.5``) or\n            sigma range (var_limit will be used directly for sigma).\n            In: `var`, `sig`.\n    \"\"\"\n\n    def __init__(self, p:float=0.5, mean:float=0.0,\n        var_limit=(10.0, 50.0), prob_color:float=0.5,\n        multi:bool=True, mode:str='gauss', sigma_calc:str='sig'):\n        <IND>super(RandomGaussianNoise, self).__init__(p=p)\n\n        if not isinstance(mean, numbers.Number) or mean < 0:\n            <IND>raise ValueError('Mean should be a positive value')\n        <DED>if isinstance(var_limit, (tuple, list)):\n            <IND>if var_limit[0] < 0 or var_limit[1] < 0:\n                <IND>raise ValueError(\n                    f\"var_limit values: {var_limit} should be non negative.\")\n            <DED>self.var_limit = var_limit\n        <DED>elif isinstance(var_limit, (int, float)):\n            <IND>if var_limit < 0:\n                <IND>raise ValueError(\"var_limit should be non negative.\")\n            <DED>self.var_limit = (0, var_limit)\n        <DED>else:\n            <IND>raise TypeError(\n                \"Expected var_limit type to be one of (int, float, \"\n                f\"tuple, list), got {type(var_limit)}\"\n            )\n\n        <DED>if not isinstance(prob_color, (int, float)):\n            <IND>raise ValueError('prob_color must be a number in [0, 1]')\n        <DED>self.prob_color = prob_color\n        self.mean = mean\n        self.mode = mode\n        self.multi = multi\n        self.sigma_calc = sigma_calc\n        self.params = self.get_params()\n\n    <DED>def apply(self, img, **params):\n        <IND>return EF.noise_gaussian(img, **params)\n\n    <DED>def get_params(self):\n        <IND>\"\"\"Get parameters for gaussian noise\n        Returns:\n            dict: params to be passed to the affine transformation\n        \"\"\"\n        # mean = random.uniform(-self.mean, self.mean) #= 0\n\n        gtype = 'color' if random.random() < self.prob_color else 'gray'\n\n        multi = False\n        if self.multi and random.random() > 0.66 and gtype == 'color':\n            # will only apply MC-AWGN 33% of the time\n            <IND>multi = True\n        <DED>if multi:\n            <IND>lim = self.var_limit\n            sigma = [random.uniform(lim[0], lim[1]) for _ in range(3)]\n            if self.mode == \"gauss\":\n                <IND>sigma = [(v ** 0.5) for v in sigma]\n        <DED><DED>else:\n            # ref wide range: (4, 200)\n            <IND>var = random.uniform(self.var_limit[0], self.var_limit[1])\n\n            if self.mode == \"gauss\":\n                <IND>if self.sigma_calc == 'var':\n                    <IND>sigma = (var ** 0.5)\n                <DED>elif self.sigma_calc == 'sig':\n                    # no need to var/255 if image range in [0,255]\n                    <IND>sigma = var\n            <DED><DED>elif self.mode == \"speckle\":\n                <IND>sigma = var\n\n        <DED><DED>return {\"mean\": self.mean,\n                \"std\": sigma,\n                \"mode\": self.mode,\n                \"gtype\": gtype,\n                \"rounds\": False,\n                \"clip\": True,\n            }\n\n\n<DED><DED>class RandomPoissonNoise(RandomBase):\n    <IND>\"\"\"Apply Poisson noise on the given image randomly with\n    a given probability.\n    Args:\n        p: probability of the image being noised. Default value is 0.5\n    \"\"\"\n\n    def __init__(self, p:float=0.5):\n        <IND>super(RandomPoissonNoise, self).__init__(p=p)\n\n    <DED>def apply(self, img, **params):\n        <IND>return EF.noise_poisson(img, **params)\n\n\n<DED><DED>class RandomSPNoise(RandomBase):\n    <IND>\"\"\"Apply salt and pepper noise on the given image randomly\n    with a given probability.\n    Args:\n        p: probability of the image being noised. Default value is 0.5\n        prob: probability (threshold) that controls level of S&P noise\n    \"\"\"\n\n    def __init__(self, p:float=0.5, prob:float=0.1):\n        <IND>super(RandomSPNoise, self).__init__(p=p)\n\n        if not isinstance(prob, numbers.Number) or prob < 0:\n            <IND>raise ValueError(\"prob should be a positive value.\"\n                             f\"Got: {prob}\")\n        <DED>self.prob = prob\n        self.params = self.get_params()\n\n    <DED>def get_params(self):\n        <IND>\"\"\"Get parameters for noise.\n        Returns: dict of parameters.\n        \"\"\"\n        return {\"prob\": self.prob}\n\n    <DED>def apply(self, img, **params):\n        <IND>return EF.noise_salt_and_pepper(img, **params)\n\n\n<DED><DED>class RandomSpeckleNoise(RandomGaussianNoise):\n    <IND>\"\"\" Apply speckle noise on the given CV Image randomly with\n    a given probability. Note that it reuses RandomGaussianNoise\n    as a base, since the function is shared.\n    Args:\n        p: probability of the image being noised.\n            Default value is 0.5\n        mean: Mean (\u201ccenter\u201d) of the Gaussian distribution.\n            Default=0.0\n        var_limit ((float, float) or float): variance range for noise.\n            If var_limit is a single float, the range will be\n            (0, var_limit). Random range should be around (0.04, 0.2),\n            in range [0, 1.0]\n        prob_color: Probably for selecting the type of Gaussian noise\n            to add, either colored or grayscale (``color`` or ``gray``),\n            in range [0.0, 1.0], higher means more chance of `color`.\n            (Note: Color type can introduce color noise during training)\n    \"\"\"\n    def __init__(self, p:float=0.5, mean:float=0.0,\n        var_limit=(0.04, 0.12), prob_color:float=0.5,\n        sigma_calc:str='var'):\n\n        <IND>super(RandomSpeckleNoise, self).__init__(p=p, mean=mean,\n            var_limit=var_limit, prob_color=prob_color, multi=False,\n            mode='speckle', sigma_calc=sigma_calc)\n\n\n<DED><DED>class RandomCompression(RandomBase):\n    <IND>\"\"\"Apply compression to the given image randomly\n    with a given probability. Accepts JPEG and WEBP compression\n    types. For the compression quality, lower values represent\n    higher compression (lower quality).\n    Args:\n        p: probability of the image being noised. Default value is 0.5\n        quality (int: [0,100]):\n        min_quality: lower bound on the image quality. In [0, 100]\n            range for jpeg and [1, 100] for webp.\n        max_quality: upper bound on the image quality. In [0, 100]\n            range for jpeg and [1, 100] for webp.\n        compression_type: should be 'jpeg'/'jpg' or 'webp'.\n    \"\"\"\n\n    def __init__(self, p:float=0.5, min_quality:int=20,\n        max_quality:int=90, compression_type:str='.jpg'):\n        <IND>super(RandomCompression, self).__init__(p=p)\n\n        self.compression_type = compression_type\n        low_q_thresh = 1 if compression_type == \".webp\" else 0\n        if not  low_q_thresh <= min_quality <= 100:\n            <IND>raise ValueError(f\"Invalid min_quality. Got: {min_quality}\")\n        <DED>if not  low_q_thresh <= max_quality <= 100:\n            <IND>raise ValueError(f\"Invalid max_quality. Got: {max_quality}\")\n\n        <DED>self.min_quality = min_quality\n        self.max_quality = max_quality\n        self.params = self.get_params()\n\n    <DED>def get_params(self):\n        <IND>"
      }
    ]
  },
  {
    "project": "victorca25/traiNNer",
    "commit": "c4d43aab78b8c3cda9ef3c129390dfe73eca7c26",
    "filename": "opencv_transforms/transforms.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/victorca25-traiNNer/opencv_transforms/transforms.py",
    "file_hunks_size": 18,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "opencv_transforms/transforms.py:1687:59 Unsupported operand [58]: `>=` is not supported for operand types `numbers.Number` and `int`.",
    "message": " `>=` is not supported for operand types `numbers.Number` and `int`.",
    "rule_id": "Unsupported operand [58]",
    "warning_line_no": 1687,
    "warning_line": "        assert isinstance(max_quality, numbers.Number) and max_quality >= 0, 'max_quality should be a positive value'",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\nclass RandomGaussianNoise:\n    \"\"\"Applying gaussian noise on the given CV Image randomly with a given probability.\n\n        Args:\n            p (float): probability of the image being noised. Default value is 0.5\n            mean (float): Mean (\u201ccentre\u201d) of the Gaussian distribution. Default=0.0\n            std (float): Standard deviation (spread or \u201cwidth\u201d) sigma of the Gaussian distribution. Default=1.0\n            gtype ('str': ``color`` or ``bw``): Type of Gaussian noise to add, either colored or black and white. \n                Default='color' (Note: can introduce color noise during training)\n            random_params (bool): if enabled, will randomly get the parameters for the noise function\n                on each iteration. It uses the \"mean\" and \"std\" parameters as the mean and variance range\n                to sample from. \n        \"\"\"\n\n    def __init__(self, p:float=0.5, mean=0, std:float=1.0, gtype='color', random_params = False):\n        assert isinstance(mean, numbers.Number) and mean >= 0, 'mean should be a positive value'\n        assert isinstance(std, numbers.Number) and std >= 0, 'std should be a positive value'\n        assert isinstance(p, numbers.Number) and p >= 0, 'p should be a positive value'\n        assert isinstance(gtype, str), 'gtype is a string'\n        self.p = p\n        self.gtype = gtype\n        self.mean = mean\n        self.std = std\n        self.random_params = random_params\n\n    @staticmethod\n    def get_params(mean, std):\n        \"\"\"Get parameters for gaussian noise\n\n        Returns:\n            sequence: params to be passed to the affine transformation\n        \"\"\"\n        mean = np.random.uniform(-mean, mean) #= 0\n        std = np.random.uniform(0.1, std) #(4, 200)\n\n        return mean, std\n\n    def __call__(self, img):\n        \"\"\"\n        Args:\n            img (np.ndarray): Image to be noised.\n\n        Returns:\n            np.ndarray: Randomly noised image.\n        \"\"\"\n        if random.random() < self.p:\n            if self.random_params:\n                mean, std = self.get_params(self.mean, self.std) \n            else:\n                mean, std = self.mean, self.std\n            return EF.noise_gaussian(img, mean=mean, std=std, gtype=self.gtype)\n        return img\n\n    def __repr__(self):\n        return self.__class__.__name__ + '(p={})'.format(self.p)\n\n\nclass RandomPoissonNoise:\n    \"\"\"Applying Poisson noise on the given CV Image randomly with a given probability.\n\n        Args:\n            p (float): probability of the image being noised. Default value is 0.5\n        \"\"\"\n\n    def __init__(self, p:float=0.5):\n        assert isinstance(p, numbers.Number) and p >= 0, 'p should be a positive value'\n        self.p = p\n\n    def __call__(self, img):\n        \"\"\"\n        Args:\n            img (np.ndarray): Image to be noised.\n\n        Returns:\n            np.ndarray: Randomly noised image.\n        \"\"\"\n        if random.random() < self.p:\n            return EF.noise_poisson(img)\n        return img\n\n    def __repr__(self):\n        return self.__class__.__name__ + '(p={})'.format(self.p)\n\n\nclass RandomSPNoise:\n    \"\"\"Applying salt and pepper noise on the given CV Image randomly with a given probability.\n\n        Args:\n            p (float): probability of the image being noised. Default value is 0.5\n            prob (float): probability (threshold) that controls level of S&P noise\n        \"\"\"\n\n    def __init__(self, p:float=0.5, prob:float=0.1):\n        assert isinstance(p, numbers.Number) and p >= 0, 'p should be a positive value'\n        assert isinstance(prob, numbers.Number) and prob >= 0, 'p should be a positive value'\n        self.p = p\n        self.prob = prob\n\n    def __call__(self, img):\n        \"\"\"\n        Args:\n            img (np.ndarray): Image to be noised.\n\n        Returns:\n            np.ndarray: Randomly noised image.\n        \"\"\"\n        if random.random() < self.p:\n            return EF.noise_salt_and_pepper(img, self.prob)\n        return img\n\n    def __repr__(self):\n        return self.__class__.__name__ + '(p={})'.format(self.p)\n\n\nclass RandomSpeckleNoise:\n    \"\"\"Applying speckle noise on the given CV Image randomly with a given probability.\n\n        Args:\n            p (float): probability of the image being noised. Default value is 0.5\n            std (float): Standard deviation (spread or \u201cwidth\u201d) sigma of the Gaussian distribution.\n                Default=0.12. Random range should be around (0.04, 0.2)\n            gtype ('str': ``color`` or ``bw``): Type of noise to add, either colored or black and white. \n                Default='color' (Note: can introduce color noise during training)\n            random_params (bool): if enabled, will randomly get the parameters for the noise function\n                on each iteration. It uses the \"std\" parameter as the maximum variance to sample from. \n        \"\"\"\n\n    def __init__(self, p:float=0.5, std:float=0.12, gtype='color', random_params = False):\n        assert isinstance(std, numbers.Number) and std >= 0, 'std should be a positive value'\n        assert isinstance(p, numbers.Number) and p >= 0, 'p should be a positive value'\n        assert isinstance(gtype, str), 'gtype is a string'\n        self.p = p\n        self.std = std\n        self.gtype = gtype\n        self.random_params = random_params\n\n    @staticmethod\n    def get_params(mean, std):\n        \"\"\"Get parameters for speckle noise\n\n        Returns:\n            sequence: params to be passed to the affine transformation\n        \"\"\"\n        #Variance of random distribution. variance = (standard deviation) ** 2. Default : 0.01\n        std = np.random.uniform(0.04, std) #(0.04, 0.2)\n\n        return std\n\n    def __call__(self, img):\n        \"\"\"\n        Args:\n            img (np.ndarray): Image to be noised.\n\n        Returns:\n            np.ndarray: Randomly noised image.\n        \"\"\"\n        if random.random() < self.p:\n            if self.random_params:\n                std = get_params(self.std)\n            else:\n                std = self.std\n            return EF.noise_speckle(img, mean=0.0, std=std, gtype=self.gtype)\n        return img\n\n    def __repr__(self):\n        return self.__class__.__name__ + '(p={})'.format(self.p)\n\nclass RandomCompression:\n    \"\"\"Applying JPEG compression on the given CV Image randomly with a given probability.\n\n        Args:\n            p (float): probability of the image being noised. Default value is 0.5\n            quality (int: [0,100]): Compression quality for the image. Lower values represent \n                higher compression and lower quality. Default=20\n            random_params (bool): if enabled, will randomly get the parameters for the noise function\n                on each iteration. It uses the \"quality\" parameter as maximum quality to randomly \n                sample with the minimum being 10% quality.\n        \"\"\"\n\n    def __init__(self, p:float=0.5, min_quality=20, max_quality=90, image_type='.jpg', random_params = True):\n        assert isinstance(min_quality, numbers.Number) and min_quality >= 0, 'min_quality should be a positive value'\n        assert isinstance(max_quality, numbers.Number) and max_quality >= 0, 'max_quality should be a positive value'\n        assert isinstance(p, numbers.Number) and p >= 0, 'p should be a positive value'\n        self.p = p\n        self.min_quality = min_quality\n        self.max_quality = max_quality\n        self.image_type = image_type\n        self.random_params = random_params\n\n    @staticmethod\n    def get_params(min_quality, max_quality):\n        \"\"\"Get compression level for JPEG noise\n\n        Returns:\n",
        "source_code_len": 7580,
        "target_code": "\n\nclass RandomGaussianNoise(RandomBase):\n    \"\"\"Apply gaussian noise on the given image randomly with a\n    given probability.\n    Args:\n        p (float): probability of the image being noised.\n            Default value is 0.5\n        mean (float): Mean (\u201ccenter\u201d) of the Gaussian distribution.\n            Default=0.0\n        var_limit ((float, float) or float): variance range for noise.\n            If var_limit is a single float, the range will be\n            (0, var_limit). Should be in range [0, 255] if using\n            `sigma_calc='sig'` or squared values of that range if\n            `sigma_calc='var'`. Default: (10.0, 50.0).\n        prob_color: Probably for selecting the type of Gaussian noise\n            to add, either colored or grayscale (``color`` or ``gray``),\n            in range [0.0, 1.0], higher means more chance of `color`.\n            (Note: Color type can introduce color noise during training)\n        multi: select to randomly generate multichannel-AWGN (MC-AWGN)\n            in addition to regular AWGN.\n        mode: select between Gaussian or Speckle noise modes\n        sigma_calc: select if var_limit is to be considered as the\n            variance (final sigma will be ``sigma = var ** 0.5``) or\n            sigma range (var_limit will be used directly for sigma).\n            In: `var`, `sig`.\n    \"\"\"\n\n    def __init__(self, p:float=0.5, mean:float=0.0,\n        var_limit=(10.0, 50.0), prob_color:float=0.5,\n        multi:bool=True, mode:str='gauss', sigma_calc:str='sig'):\n        super(RandomGaussianNoise, self).__init__(p=p)\n\n        if not isinstance(mean, numbers.Number) or mean < 0:\n            raise ValueError('Mean should be a positive value')\n        if isinstance(var_limit, (tuple, list)):\n            if var_limit[0] < 0 or var_limit[1] < 0:\n                raise ValueError(\n                    f\"var_limit values: {var_limit} should be non negative.\")\n            self.var_limit = var_limit\n        elif isinstance(var_limit, (int, float)):\n            if var_limit < 0:\n                raise ValueError(\"var_limit should be non negative.\")\n            self.var_limit = (0, var_limit)\n        else:\n            raise TypeError(\n                \"Expected var_limit type to be one of (int, float, \"\n                f\"tuple, list), got {type(var_limit)}\"\n            )\n\n        if not isinstance(prob_color, (int, float)):\n            raise ValueError('prob_color must be a number in [0, 1]')\n        self.prob_color = prob_color\n        self.mean = mean\n        self.mode = mode\n        self.multi = multi\n        self.sigma_calc = sigma_calc\n        self.params = self.get_params()\n\n    def apply(self, img, **params):\n        return EF.noise_gaussian(img, **params)\n\n    def get_params(self):\n        \"\"\"Get parameters for gaussian noise\n        Returns:\n            dict: params to be passed to the affine transformation\n        \"\"\"\n        # mean = random.uniform(-self.mean, self.mean) #= 0\n\n        gtype = 'color' if random.random() < self.prob_color else 'gray'\n\n        multi = False\n        if self.multi and random.random() > 0.66 and gtype == 'color':\n            # will only apply MC-AWGN 33% of the time\n            multi = True\n        if multi:\n            lim = self.var_limit\n            sigma = [random.uniform(lim[0], lim[1]) for _ in range(3)]\n            if self.mode == \"gauss\":\n                sigma = [(v ** 0.5) for v in sigma]\n        else:\n            # ref wide range: (4, 200)\n            var = random.uniform(self.var_limit[0], self.var_limit[1])\n\n            if self.mode == \"gauss\":\n                if self.sigma_calc == 'var':\n                    sigma = (var ** 0.5)\n                elif self.sigma_calc == 'sig':\n                    # no need to var/255 if image range in [0,255]\n                    sigma = var\n            elif self.mode == \"speckle\":\n                sigma = var\n\n        return {\"mean\": self.mean,\n                \"std\": sigma,\n                \"mode\": self.mode,\n                \"gtype\": gtype,\n                \"rounds\": False,\n                \"clip\": True,\n            }\n\n\nclass RandomPoissonNoise(RandomBase):\n    \"\"\"Apply Poisson noise on the given image randomly with\n    a given probability.\n    Args:\n        p: probability of the image being noised. Default value is 0.5\n    \"\"\"\n\n    def __init__(self, p:float=0.5):\n        super(RandomPoissonNoise, self).__init__(p=p)\n\n    def apply(self, img, **params):\n        return EF.noise_poisson(img, **params)\n\n\nclass RandomSPNoise(RandomBase):\n    \"\"\"Apply salt and pepper noise on the given image randomly\n    with a given probability.\n    Args:\n        p: probability of the image being noised. Default value is 0.5\n        prob: probability (threshold) that controls level of S&P noise\n    \"\"\"\n\n    def __init__(self, p:float=0.5, prob:float=0.1):\n        super(RandomSPNoise, self).__init__(p=p)\n\n        if not isinstance(prob, numbers.Number) or prob < 0:\n            raise ValueError(\"prob should be a positive value.\"\n                             f\"Got: {prob}\")\n        self.prob = prob\n        self.params = self.get_params()\n\n    def get_params(self):\n        \"\"\"Get parameters for noise.\n        Returns: dict of parameters.\n        \"\"\"\n        return {\"prob\": self.prob}\n\n    def apply(self, img, **params):\n        return EF.noise_salt_and_pepper(img, **params)\n\n\nclass RandomSpeckleNoise(RandomGaussianNoise):\n    \"\"\" Apply speckle noise on the given CV Image randomly with\n    a given probability. Note that it reuses RandomGaussianNoise\n    as a base, since the function is shared.\n    Args:\n        p: probability of the image being noised.\n            Default value is 0.5\n        mean: Mean (\u201ccenter\u201d) of the Gaussian distribution.\n            Default=0.0\n        var_limit ((float, float) or float): variance range for noise.\n            If var_limit is a single float, the range will be\n            (0, var_limit). Random range should be around (0.04, 0.2),\n            in range [0, 1.0]\n        prob_color: Probably for selecting the type of Gaussian noise\n            to add, either colored or grayscale (``color`` or ``gray``),\n            in range [0.0, 1.0], higher means more chance of `color`.\n            (Note: Color type can introduce color noise during training)\n    \"\"\"\n    def __init__(self, p:float=0.5, mean:float=0.0,\n        var_limit=(0.04, 0.12), prob_color:float=0.5,\n        sigma_calc:str='var'):\n\n        super(RandomSpeckleNoise, self).__init__(p=p, mean=mean,\n            var_limit=var_limit, prob_color=prob_color, multi=False,\n            mode='speckle', sigma_calc=sigma_calc)\n\n\nclass RandomCompression(RandomBase):\n    \"\"\"Apply compression to the given image randomly\n    with a given probability. Accepts JPEG and WEBP compression\n    types. For the compression quality, lower values represent\n    higher compression (lower quality).\n    Args:\n        p: probability of the image being noised. Default value is 0.5\n        quality (int: [0,100]):\n        min_quality: lower bound on the image quality. In [0, 100]\n            range for jpeg and [1, 100] for webp.\n        max_quality: upper bound on the image quality. In [0, 100]\n            range for jpeg and [1, 100] for webp.\n        compression_type: should be 'jpeg'/'jpg' or 'webp'.\n    \"\"\"\n\n    def __init__(self, p:float=0.5, min_quality:int=20,\n        max_quality:int=90, compression_type:str='.jpg'):\n        super(RandomCompression, self).__init__(p=p)\n\n        self.compression_type = compression_type\n        low_q_thresh = 1 if compression_type == \".webp\" else 0\n        if not  low_q_thresh <= min_quality <= 100:\n            raise ValueError(f\"Invalid min_quality. Got: {min_quality}\")\n        if not  low_q_thresh <= max_quality <= 100:\n            raise ValueError(f\"Invalid max_quality. Got: {max_quality}\")\n\n        self.min_quality = min_quality\n        self.max_quality = max_quality\n        self.params = self.get_params()\n\n    def get_params(self):\n        \"\"\"Get compression level for JPEG noise.\n            Randomize quality between min_quality and max_quality.\n        Returns:\n",
        "target_code_len": 8074,
        "diff_format": "@@ -1505,195 +1506,204 @@\n \n-class RandomGaussianNoise:\n-    \"\"\"Applying gaussian noise on the given CV Image randomly with a given probability.\n-\n-        Args:\n-            p (float): probability of the image being noised. Default value is 0.5\n-            mean (float): Mean (\u201ccentre\u201d) of the Gaussian distribution. Default=0.0\n-            std (float): Standard deviation (spread or \u201cwidth\u201d) sigma of the Gaussian distribution. Default=1.0\n-            gtype ('str': ``color`` or ``bw``): Type of Gaussian noise to add, either colored or black and white. \n-                Default='color' (Note: can introduce color noise during training)\n-            random_params (bool): if enabled, will randomly get the parameters for the noise function\n-                on each iteration. It uses the \"mean\" and \"std\" parameters as the mean and variance range\n-                to sample from. \n-        \"\"\"\n-\n-    def __init__(self, p:float=0.5, mean=0, std:float=1.0, gtype='color', random_params = False):\n-        assert isinstance(mean, numbers.Number) and mean >= 0, 'mean should be a positive value'\n-        assert isinstance(std, numbers.Number) and std >= 0, 'std should be a positive value'\n-        assert isinstance(p, numbers.Number) and p >= 0, 'p should be a positive value'\n-        assert isinstance(gtype, str), 'gtype is a string'\n-        self.p = p\n-        self.gtype = gtype\n+\n+class RandomGaussianNoise(RandomBase):\n+    \"\"\"Apply gaussian noise on the given image randomly with a\n+    given probability.\n+    Args:\n+        p (float): probability of the image being noised.\n+            Default value is 0.5\n+        mean (float): Mean (\u201ccenter\u201d) of the Gaussian distribution.\n+            Default=0.0\n+        var_limit ((float, float) or float): variance range for noise.\n+            If var_limit is a single float, the range will be\n+            (0, var_limit). Should be in range [0, 255] if using\n+            `sigma_calc='sig'` or squared values of that range if\n+            `sigma_calc='var'`. Default: (10.0, 50.0).\n+        prob_color: Probably for selecting the type of Gaussian noise\n+            to add, either colored or grayscale (``color`` or ``gray``),\n+            in range [0.0, 1.0], higher means more chance of `color`.\n+            (Note: Color type can introduce color noise during training)\n+        multi: select to randomly generate multichannel-AWGN (MC-AWGN)\n+            in addition to regular AWGN.\n+        mode: select between Gaussian or Speckle noise modes\n+        sigma_calc: select if var_limit is to be considered as the\n+            variance (final sigma will be ``sigma = var ** 0.5``) or\n+            sigma range (var_limit will be used directly for sigma).\n+            In: `var`, `sig`.\n+    \"\"\"\n+\n+    def __init__(self, p:float=0.5, mean:float=0.0,\n+        var_limit=(10.0, 50.0), prob_color:float=0.5,\n+        multi:bool=True, mode:str='gauss', sigma_calc:str='sig'):\n+        super(RandomGaussianNoise, self).__init__(p=p)\n+\n+        if not isinstance(mean, numbers.Number) or mean < 0:\n+            raise ValueError('Mean should be a positive value')\n+        if isinstance(var_limit, (tuple, list)):\n+            if var_limit[0] < 0 or var_limit[1] < 0:\n+                raise ValueError(\n+                    f\"var_limit values: {var_limit} should be non negative.\")\n+            self.var_limit = var_limit\n+        elif isinstance(var_limit, (int, float)):\n+            if var_limit < 0:\n+                raise ValueError(\"var_limit should be non negative.\")\n+            self.var_limit = (0, var_limit)\n+        else:\n+            raise TypeError(\n+                \"Expected var_limit type to be one of (int, float, \"\n+                f\"tuple, list), got {type(var_limit)}\"\n+            )\n+\n+        if not isinstance(prob_color, (int, float)):\n+            raise ValueError('prob_color must be a number in [0, 1]')\n+        self.prob_color = prob_color\n         self.mean = mean\n-        self.std = std\n-        self.random_params = random_params\n-\n-    @staticmethod\n-    def get_params(mean, std):\n+        self.mode = mode\n+        self.multi = multi\n+        self.sigma_calc = sigma_calc\n+        self.params = self.get_params()\n+\n+    def apply(self, img, **params):\n+        return EF.noise_gaussian(img, **params)\n+\n+    def get_params(self):\n         \"\"\"Get parameters for gaussian noise\n-\n-        Returns:\n-            sequence: params to be passed to the affine transformation\n-        \"\"\"\n-        mean = np.random.uniform(-mean, mean) #= 0\n-        std = np.random.uniform(0.1, std) #(4, 200)\n-\n-        return mean, std\n-\n-    def __call__(self, img):\n-        \"\"\"\n-        Args:\n-            img (np.ndarray): Image to be noised.\n-\n-        Returns:\n-            np.ndarray: Randomly noised image.\n-        \"\"\"\n-        if random.random() < self.p:\n-            if self.random_params:\n-                mean, std = self.get_params(self.mean, self.std) \n-            else:\n-                mean, std = self.mean, self.std\n-            return EF.noise_gaussian(img, mean=mean, std=std, gtype=self.gtype)\n-        return img\n-\n-    def __repr__(self):\n-        return self.__class__.__name__ + '(p={})'.format(self.p)\n-\n-\n-class RandomPoissonNoise:\n-    \"\"\"Applying Poisson noise on the given CV Image randomly with a given probability.\n-\n-        Args:\n-            p (float): probability of the image being noised. Default value is 0.5\n-        \"\"\"\n+        Returns:\n+            dict: params to be passed to the affine transformation\n+        \"\"\"\n+        # mean = random.uniform(-self.mean, self.mean) #= 0\n+\n+        gtype = 'color' if random.random() < self.prob_color else 'gray'\n+\n+        multi = False\n+        if self.multi and random.random() > 0.66 and gtype == 'color':\n+            # will only apply MC-AWGN 33% of the time\n+            multi = True\n+        if multi:\n+            lim = self.var_limit\n+            sigma = [random.uniform(lim[0], lim[1]) for _ in range(3)]\n+            if self.mode == \"gauss\":\n+                sigma = [(v ** 0.5) for v in sigma]\n+        else:\n+            # ref wide range: (4, 200)\n+            var = random.uniform(self.var_limit[0], self.var_limit[1])\n+\n+            if self.mode == \"gauss\":\n+                if self.sigma_calc == 'var':\n+                    sigma = (var ** 0.5)\n+                elif self.sigma_calc == 'sig':\n+                    # no need to var/255 if image range in [0,255]\n+                    sigma = var\n+            elif self.mode == \"speckle\":\n+                sigma = var\n+\n+        return {\"mean\": self.mean,\n+                \"std\": sigma,\n+                \"mode\": self.mode,\n+                \"gtype\": gtype,\n+                \"rounds\": False,\n+                \"clip\": True,\n+            }\n+\n+\n+class RandomPoissonNoise(RandomBase):\n+    \"\"\"Apply Poisson noise on the given image randomly with\n+    a given probability.\n+    Args:\n+        p: probability of the image being noised. Default value is 0.5\n+    \"\"\"\n \n     def __init__(self, p:float=0.5):\n-        assert isinstance(p, numbers.Number) and p >= 0, 'p should be a positive value'\n-        self.p = p\n-\n-    def __call__(self, img):\n-        \"\"\"\n-        Args:\n-            img (np.ndarray): Image to be noised.\n-\n-        Returns:\n-            np.ndarray: Randomly noised image.\n-        \"\"\"\n-        if random.random() < self.p:\n-            return EF.noise_poisson(img)\n-        return img\n-\n-    def __repr__(self):\n-        return self.__class__.__name__ + '(p={})'.format(self.p)\n-\n-\n-class RandomSPNoise:\n-    \"\"\"Applying salt and pepper noise on the given CV Image randomly with a given probability.\n-\n-        Args:\n-            p (float): probability of the image being noised. Default value is 0.5\n-            prob (float): probability (threshold) that controls level of S&P noise\n-        \"\"\"\n+        super(RandomPoissonNoise, self).__init__(p=p)\n+\n+    def apply(self, img, **params):\n+        return EF.noise_poisson(img, **params)\n+\n+\n+class RandomSPNoise(RandomBase):\n+    \"\"\"Apply salt and pepper noise on the given image randomly\n+    with a given probability.\n+    Args:\n+        p: probability of the image being noised. Default value is 0.5\n+        prob: probability (threshold) that controls level of S&P noise\n+    \"\"\"\n \n     def __init__(self, p:float=0.5, prob:float=0.1):\n-        assert isinstance(p, numbers.Number) and p >= 0, 'p should be a positive value'\n-        assert isinstance(prob, numbers.Number) and prob >= 0, 'p should be a positive value'\n-        self.p = p\n+        super(RandomSPNoise, self).__init__(p=p)\n+\n+        if not isinstance(prob, numbers.Number) or prob < 0:\n+            raise ValueError(\"prob should be a positive value.\"\n+                             f\"Got: {prob}\")\n         self.prob = prob\n-\n-    def __call__(self, img):\n-        \"\"\"\n-        Args:\n-            img (np.ndarray): Image to be noised.\n-\n-        Returns:\n-            np.ndarray: Randomly noised image.\n-        \"\"\"\n-        if random.random() < self.p:\n-            return EF.noise_salt_and_pepper(img, self.prob)\n-        return img\n-\n-    def __repr__(self):\n-        return self.__class__.__name__ + '(p={})'.format(self.p)\n-\n-\n-class RandomSpeckleNoise:\n-    \"\"\"Applying speckle noise on the given CV Image randomly with a given probability.\n-\n-        Args:\n-            p (float): probability of the image being noised. Default value is 0.5\n-            std (float): Standard deviation (spread or \u201cwidth\u201d) sigma of the Gaussian distribution.\n-                Default=0.12. Random range should be around (0.04, 0.2)\n-            gtype ('str': ``color`` or ``bw``): Type of noise to add, either colored or black and white. \n-                Default='color' (Note: can introduce color noise during training)\n-            random_params (bool): if enabled, will randomly get the parameters for the noise function\n-                on each iteration. It uses the \"std\" parameter as the maximum variance to sample from. \n-        \"\"\"\n-\n-    def __init__(self, p:float=0.5, std:float=0.12, gtype='color', random_params = False):\n-        assert isinstance(std, numbers.Number) and std >= 0, 'std should be a positive value'\n-        assert isinstance(p, numbers.Number) and p >= 0, 'p should be a positive value'\n-        assert isinstance(gtype, str), 'gtype is a string'\n-        self.p = p\n-        self.std = std\n-        self.gtype = gtype\n-        self.random_params = random_params\n-\n-    @staticmethod\n-    def get_params(mean, std):\n-        \"\"\"Get parameters for speckle noise\n-\n-        Returns:\n-            sequence: params to be passed to the affine transformation\n-        \"\"\"\n-        #Variance of random distribution. variance = (standard deviation) ** 2. Default : 0.01\n-        std = np.random.uniform(0.04, std) #(0.04, 0.2)\n-\n-        return std\n-\n-    def __call__(self, img):\n-        \"\"\"\n-        Args:\n-            img (np.ndarray): Image to be noised.\n-\n-        Returns:\n-            np.ndarray: Randomly noised image.\n-        \"\"\"\n-        if random.random() < self.p:\n-            if self.random_params:\n-                std = get_params(self.std)\n-            else:\n-                std = self.std\n-            return EF.noise_speckle(img, mean=0.0, std=std, gtype=self.gtype)\n-        return img\n-\n-    def __repr__(self):\n-        return self.__class__.__name__ + '(p={})'.format(self.p)\n-\n-class RandomCompression:\n-    \"\"\"Applying JPEG compression on the given CV Image randomly with a given probability.\n-\n-        Args:\n-            p (float): probability of the image being noised. Default value is 0.5\n-            quality (int: [0,100]): Compression quality for the image. Lower values represent \n-                higher compression and lower quality. Default=20\n-            random_params (bool): if enabled, will randomly get the parameters for the noise function\n-                on each iteration. It uses the \"quality\" parameter as maximum quality to randomly \n-                sample with the minimum being 10% quality.\n-        \"\"\"\n-\n-    def __init__(self, p:float=0.5, min_quality=20, max_quality=90, image_type='.jpg', random_params = True):\n-        assert isinstance(min_quality, numbers.Number) and min_quality >= 0, 'min_quality should be a positive value'\n-        assert isinstance(max_quality, numbers.Number) and max_quality >= 0, 'max_quality should be a positive value'\n-        assert isinstance(p, numbers.Number) and p >= 0, 'p should be a positive value'\n-        self.p = p\n+        self.params = self.get_params()\n+\n+    def get_params(self):\n+        \"\"\"Get parameters for noise.\n+        Returns: dict of parameters.\n+        \"\"\"\n+        return {\"prob\": self.prob}\n+\n+    def apply(self, img, **params):\n+        return EF.noise_salt_and_pepper(img, **params)\n+\n+\n+class RandomSpeckleNoise(RandomGaussianNoise):\n+    \"\"\" Apply speckle noise on the given CV Image randomly with\n+    a given probability. Note that it reuses RandomGaussianNoise\n+    as a base, since the function is shared.\n+    Args:\n+        p: probability of the image being noised.\n+            Default value is 0.5\n+        mean: Mean (\u201ccenter\u201d) of the Gaussian distribution.\n+            Default=0.0\n+        var_limit ((float, float) or float): variance range for noise.\n+            If var_limit is a single float, the range will be\n+            (0, var_limit). Random range should be around (0.04, 0.2),\n+            in range [0, 1.0]\n+        prob_color: Probably for selecting the type of Gaussian noise\n+            to add, either colored or grayscale (``color`` or ``gray``),\n+            in range [0.0, 1.0], higher means more chance of `color`.\n+            (Note: Color type can introduce color noise during training)\n+    \"\"\"\n+    def __init__(self, p:float=0.5, mean:float=0.0,\n+        var_limit=(0.04, 0.12), prob_color:float=0.5,\n+        sigma_calc:str='var'):\n+\n+        super(RandomSpeckleNoise, self).__init__(p=p, mean=mean,\n+            var_limit=var_limit, prob_color=prob_color, multi=False,\n+            mode='speckle', sigma_calc=sigma_calc)\n+\n+\n+class RandomCompression(RandomBase):\n+    \"\"\"Apply compression to the given image randomly\n+    with a given probability. Accepts JPEG and WEBP compression\n+    types. For the compression quality, lower values represent\n+    higher compression (lower quality).\n+    Args:\n+        p: probability of the image being noised. Default value is 0.5\n+        quality (int: [0,100]):\n+        min_quality: lower bound on the image quality. In [0, 100]\n+            range for jpeg and [1, 100] for webp.\n+        max_quality: upper bound on the image quality. In [0, 100]\n+            range for jpeg and [1, 100] for webp.\n+        compression_type: should be 'jpeg'/'jpg' or 'webp'.\n+    \"\"\"\n+\n+    def __init__(self, p:float=0.5, min_quality:int=20,\n+        max_quality:int=90, compression_type:str='.jpg'):\n+        super(RandomCompression, self).__init__(p=p)\n+\n+        self.compression_type = compression_type\n+        low_q_thresh = 1 if compression_type == \".webp\" else 0\n+        if not  low_q_thresh <= min_quality <= 100:\n+            raise ValueError(f\"Invalid min_quality. Got: {min_quality}\")\n+        if not  low_q_thresh <= max_quality <= 100:\n+            raise ValueError(f\"Invalid max_quality. Got: {max_quality}\")\n+\n         self.min_quality = min_quality\n         self.max_quality = max_quality\n-        self.image_type = image_type\n-        self.random_params = random_params\n-\n-    @staticmethod\n-    def get_params(min_quality, max_quality):\n-        \"\"\"Get compression level for JPEG noise\n-\n+        self.params = self.get_params()\n+\n+    def get_params(self):\n+        \"\"\"Get compression level for JPEG noise.\n+            Randomize quality between min_quality and max_quality.\n         Returns:\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\n<DED><DED>class RandomGaussianNoise:\n    <IND>\"\"\"Applying gaussian noise on the given CV Image randomly with a given probability.\n\n        Args:\n            p (float): probability of the image being noised. Default value is 0.5\n            mean (float): Mean (\u201ccentre\u201d) of the Gaussian distribution. Default=0.0\n            std (float): Standard deviation (spread or \u201cwidth\u201d) sigma of the Gaussian distribution. Default=1.0\n            gtype ('str': ``color`` or ``bw``): Type of Gaussian noise to add, either colored or black and white. \n                Default='color' (Note: can introduce color noise during training)\n            random_params (bool): if enabled, will randomly get the parameters for the noise function\n                on each iteration. It uses the \"mean\" and \"std\" parameters as the mean and variance range\n                to sample from. \n        \"\"\"\n\n    def __init__(self, p:float=0.5, mean=0, std:float=1.0, gtype='color', random_params = False):\n        <IND>assert isinstance(mean, numbers.Number) and mean >= 0, 'mean should be a positive value'\n        assert isinstance(std, numbers.Number) and std >= 0, 'std should be a positive value'\n        assert isinstance(p, numbers.Number) and p >= 0, 'p should be a positive value'\n        assert isinstance(gtype, str), 'gtype is a string'\n        self.p = p\n        self.gtype = gtype\n        self.mean = mean\n        self.std = std\n        self.random_params = random_params\n\n    <DED>@staticmethod\n    def get_params(mean, std):\n        <IND>\"\"\"Get parameters for gaussian noise\n\n        Returns:\n            sequence: params to be passed to the affine transformation\n        \"\"\"\n        mean = np.random.uniform(-mean, mean) #= 0\n        std = np.random.uniform(0.1, std) #(4, 200)\n\n        return mean, std\n\n    <DED>def __call__(self, img):\n        <IND>\"\"\"\n        Args:\n            img (np.ndarray): Image to be noised.\n\n        Returns:\n            np.ndarray: Randomly noised image.\n        \"\"\"\n        if random.random() < self.p:\n            <IND>if self.random_params:\n                <IND>mean, std = self.get_params(self.mean, self.std) \n            <DED>else:\n                <IND>mean, std = self.mean, self.std\n            <DED>return EF.noise_gaussian(img, mean=mean, std=std, gtype=self.gtype)\n        <DED>return img\n\n    <DED>def __repr__(self):\n        <IND>return self.__class__.__name__ + '(p={})'.format(self.p)\n\n\n<DED><DED>class RandomPoissonNoise:\n    <IND>\"\"\"Applying Poisson noise on the given CV Image randomly with a given probability.\n\n        Args:\n            p (float): probability of the image being noised. Default value is 0.5\n        \"\"\"\n\n    def __init__(self, p:float=0.5):\n        <IND>assert isinstance(p, numbers.Number) and p >= 0, 'p should be a positive value'\n        self.p = p\n\n    <DED>def __call__(self, img):\n        <IND>\"\"\"\n        Args:\n            img (np.ndarray): Image to be noised.\n\n        Returns:\n            np.ndarray: Randomly noised image.\n        \"\"\"\n        if random.random() < self.p:\n            <IND>return EF.noise_poisson(img)\n        <DED>return img\n\n    <DED>def __repr__(self):\n        <IND>return self.__class__.__name__ + '(p={})'.format(self.p)\n\n\n<DED><DED>class RandomSPNoise:\n    <IND>\"\"\"Applying salt and pepper noise on the given CV Image randomly with a given probability.\n\n        Args:\n            p (float): probability of the image being noised. Default value is 0.5\n            prob (float): probability (threshold) that controls level of S&P noise\n        \"\"\"\n\n    def __init__(self, p:float=0.5, prob:float=0.1):\n        <IND>assert isinstance(p, numbers.Number) and p >= 0, 'p should be a positive value'\n        assert isinstance(prob, numbers.Number) and prob >= 0, 'p should be a positive value'\n        self.p = p\n        self.prob = prob\n\n    <DED>def __call__(self, img):\n        <IND>\"\"\"\n        Args:\n            img (np.ndarray): Image to be noised.\n\n        Returns:\n            np.ndarray: Randomly noised image.\n        \"\"\"\n        if random.random() < self.p:\n            <IND>return EF.noise_salt_and_pepper(img, self.prob)\n        <DED>return img\n\n    <DED>def __repr__(self):\n        <IND>return self.__class__.__name__ + '(p={})'.format(self.p)\n\n\n<DED><DED>class RandomSpeckleNoise:\n    <IND>\"\"\"Applying speckle noise on the given CV Image randomly with a given probability.\n\n        Args:\n            p (float): probability of the image being noised. Default value is 0.5\n            std (float): Standard deviation (spread or \u201cwidth\u201d) sigma of the Gaussian distribution.\n                Default=0.12. Random range should be around (0.04, 0.2)\n            gtype ('str': ``color`` or ``bw``): Type of noise to add, either colored or black and white. \n                Default='color' (Note: can introduce color noise during training)\n            random_params (bool): if enabled, will randomly get the parameters for the noise function\n                on each iteration. It uses the \"std\" parameter as the maximum variance to sample from. \n        \"\"\"\n\n    def __init__(self, p:float=0.5, std:float=0.12, gtype='color', random_params = False):\n        <IND>assert isinstance(std, numbers.Number) and std >= 0, 'std should be a positive value'\n        assert isinstance(p, numbers.Number) and p >= 0, 'p should be a positive value'\n        assert isinstance(gtype, str), 'gtype is a string'\n        self.p = p\n        self.std = std\n        self.gtype = gtype\n        self.random_params = random_params\n\n    <DED>@staticmethod\n    def get_params(mean, std):\n        <IND>\"\"\"Get parameters for speckle noise\n\n        Returns:\n            sequence: params to be passed to the affine transformation\n        \"\"\"\n        #Variance of random distribution. variance = (standard deviation) ** 2. Default : 0.01\n        std = np.random.uniform(0.04, std) #(0.04, 0.2)\n\n        return std\n\n    <DED>def __call__(self, img):\n        <IND>\"\"\"\n        Args:\n            img (np.ndarray): Image to be noised.\n\n        Returns:\n            np.ndarray: Randomly noised image.\n        \"\"\"\n        if random.random() < self.p:\n            <IND>if self.random_params:\n                <IND>std = get_params(self.std)\n            <DED>else:\n                <IND>std = self.std\n            <DED>return EF.noise_speckle(img, mean=0.0, std=std, gtype=self.gtype)\n        <DED>return img\n\n    <DED>def __repr__(self):\n        <IND>return self.__class__.__name__ + '(p={})'.format(self.p)\n\n<DED><DED>class RandomCompression:\n    <IND>\"\"\"Applying JPEG compression on the given CV Image randomly with a given probability.\n\n        Args:\n            p (float): probability of the image being noised. Default value is 0.5\n            quality (int: [0,100]): Compression quality for the image. Lower values represent \n                higher compression and lower quality. Default=20\n            random_params (bool): if enabled, will randomly get the parameters for the noise function\n                on each iteration. It uses the \"quality\" parameter as maximum quality to randomly \n                sample with the minimum being 10% quality.\n        \"\"\"\n\n    def __init__(self, p:float=0.5, min_quality=20, max_quality=90, image_type='.jpg', random_params = True):\n        <IND>assert isinstance(min_quality, numbers.Number) and min_quality >= 0, 'min_quality should be a positive value'\n        assert isinstance(max_quality, numbers.Number) and max_quality >= 0, 'max_quality should be a positive value'\n        assert isinstance(p, numbers.Number) and p >= 0, 'p should be a positive value'\n        self.p = p\n        self.min_quality = min_quality\n        self.max_quality = max_quality\n        self.image_type = image_type\n        self.random_params = random_params\n\n    <DED>@staticmethod\n    def get_params(min_quality, max_quality):\n        <IND>",
        "target_code_with_indent": "\n\n<DED><DED>class RandomGaussianNoise(RandomBase):\n    <IND>\"\"\"Apply gaussian noise on the given image randomly with a\n    given probability.\n    Args:\n        p (float): probability of the image being noised.\n            Default value is 0.5\n        mean (float): Mean (\u201ccenter\u201d) of the Gaussian distribution.\n            Default=0.0\n        var_limit ((float, float) or float): variance range for noise.\n            If var_limit is a single float, the range will be\n            (0, var_limit). Should be in range [0, 255] if using\n            `sigma_calc='sig'` or squared values of that range if\n            `sigma_calc='var'`. Default: (10.0, 50.0).\n        prob_color: Probably for selecting the type of Gaussian noise\n            to add, either colored or grayscale (``color`` or ``gray``),\n            in range [0.0, 1.0], higher means more chance of `color`.\n            (Note: Color type can introduce color noise during training)\n        multi: select to randomly generate multichannel-AWGN (MC-AWGN)\n            in addition to regular AWGN.\n        mode: select between Gaussian or Speckle noise modes\n        sigma_calc: select if var_limit is to be considered as the\n            variance (final sigma will be ``sigma = var ** 0.5``) or\n            sigma range (var_limit will be used directly for sigma).\n            In: `var`, `sig`.\n    \"\"\"\n\n    def __init__(self, p:float=0.5, mean:float=0.0,\n        var_limit=(10.0, 50.0), prob_color:float=0.5,\n        multi:bool=True, mode:str='gauss', sigma_calc:str='sig'):\n        <IND>super(RandomGaussianNoise, self).__init__(p=p)\n\n        if not isinstance(mean, numbers.Number) or mean < 0:\n            <IND>raise ValueError('Mean should be a positive value')\n        <DED>if isinstance(var_limit, (tuple, list)):\n            <IND>if var_limit[0] < 0 or var_limit[1] < 0:\n                <IND>raise ValueError(\n                    f\"var_limit values: {var_limit} should be non negative.\")\n            <DED>self.var_limit = var_limit\n        <DED>elif isinstance(var_limit, (int, float)):\n            <IND>if var_limit < 0:\n                <IND>raise ValueError(\"var_limit should be non negative.\")\n            <DED>self.var_limit = (0, var_limit)\n        <DED>else:\n            <IND>raise TypeError(\n                \"Expected var_limit type to be one of (int, float, \"\n                f\"tuple, list), got {type(var_limit)}\"\n            )\n\n        <DED>if not isinstance(prob_color, (int, float)):\n            <IND>raise ValueError('prob_color must be a number in [0, 1]')\n        <DED>self.prob_color = prob_color\n        self.mean = mean\n        self.mode = mode\n        self.multi = multi\n        self.sigma_calc = sigma_calc\n        self.params = self.get_params()\n\n    <DED>def apply(self, img, **params):\n        <IND>return EF.noise_gaussian(img, **params)\n\n    <DED>def get_params(self):\n        <IND>\"\"\"Get parameters for gaussian noise\n        Returns:\n            dict: params to be passed to the affine transformation\n        \"\"\"\n        # mean = random.uniform(-self.mean, self.mean) #= 0\n\n        gtype = 'color' if random.random() < self.prob_color else 'gray'\n\n        multi = False\n        if self.multi and random.random() > 0.66 and gtype == 'color':\n            # will only apply MC-AWGN 33% of the time\n            <IND>multi = True\n        <DED>if multi:\n            <IND>lim = self.var_limit\n            sigma = [random.uniform(lim[0], lim[1]) for _ in range(3)]\n            if self.mode == \"gauss\":\n                <IND>sigma = [(v ** 0.5) for v in sigma]\n        <DED><DED>else:\n            # ref wide range: (4, 200)\n            <IND>var = random.uniform(self.var_limit[0], self.var_limit[1])\n\n            if self.mode == \"gauss\":\n                <IND>if self.sigma_calc == 'var':\n                    <IND>sigma = (var ** 0.5)\n                <DED>elif self.sigma_calc == 'sig':\n                    # no need to var/255 if image range in [0,255]\n                    <IND>sigma = var\n            <DED><DED>elif self.mode == \"speckle\":\n                <IND>sigma = var\n\n        <DED><DED>return {\"mean\": self.mean,\n                \"std\": sigma,\n                \"mode\": self.mode,\n                \"gtype\": gtype,\n                \"rounds\": False,\n                \"clip\": True,\n            }\n\n\n<DED><DED>class RandomPoissonNoise(RandomBase):\n    <IND>\"\"\"Apply Poisson noise on the given image randomly with\n    a given probability.\n    Args:\n        p: probability of the image being noised. Default value is 0.5\n    \"\"\"\n\n    def __init__(self, p:float=0.5):\n        <IND>super(RandomPoissonNoise, self).__init__(p=p)\n\n    <DED>def apply(self, img, **params):\n        <IND>return EF.noise_poisson(img, **params)\n\n\n<DED><DED>class RandomSPNoise(RandomBase):\n    <IND>\"\"\"Apply salt and pepper noise on the given image randomly\n    with a given probability.\n    Args:\n        p: probability of the image being noised. Default value is 0.5\n        prob: probability (threshold) that controls level of S&P noise\n    \"\"\"\n\n    def __init__(self, p:float=0.5, prob:float=0.1):\n        <IND>super(RandomSPNoise, self).__init__(p=p)\n\n        if not isinstance(prob, numbers.Number) or prob < 0:\n            <IND>raise ValueError(\"prob should be a positive value.\"\n                             f\"Got: {prob}\")\n        <DED>self.prob = prob\n        self.params = self.get_params()\n\n    <DED>def get_params(self):\n        <IND>\"\"\"Get parameters for noise.\n        Returns: dict of parameters.\n        \"\"\"\n        return {\"prob\": self.prob}\n\n    <DED>def apply(self, img, **params):\n        <IND>return EF.noise_salt_and_pepper(img, **params)\n\n\n<DED><DED>class RandomSpeckleNoise(RandomGaussianNoise):\n    <IND>\"\"\" Apply speckle noise on the given CV Image randomly with\n    a given probability. Note that it reuses RandomGaussianNoise\n    as a base, since the function is shared.\n    Args:\n        p: probability of the image being noised.\n            Default value is 0.5\n        mean: Mean (\u201ccenter\u201d) of the Gaussian distribution.\n            Default=0.0\n        var_limit ((float, float) or float): variance range for noise.\n            If var_limit is a single float, the range will be\n            (0, var_limit). Random range should be around (0.04, 0.2),\n            in range [0, 1.0]\n        prob_color: Probably for selecting the type of Gaussian noise\n            to add, either colored or grayscale (``color`` or ``gray``),\n            in range [0.0, 1.0], higher means more chance of `color`.\n            (Note: Color type can introduce color noise during training)\n    \"\"\"\n    def __init__(self, p:float=0.5, mean:float=0.0,\n        var_limit=(0.04, 0.12), prob_color:float=0.5,\n        sigma_calc:str='var'):\n\n        <IND>super(RandomSpeckleNoise, self).__init__(p=p, mean=mean,\n            var_limit=var_limit, prob_color=prob_color, multi=False,\n            mode='speckle', sigma_calc=sigma_calc)\n\n\n<DED><DED>class RandomCompression(RandomBase):\n    <IND>\"\"\"Apply compression to the given image randomly\n    with a given probability. Accepts JPEG and WEBP compression\n    types. For the compression quality, lower values represent\n    higher compression (lower quality).\n    Args:\n        p: probability of the image being noised. Default value is 0.5\n        quality (int: [0,100]):\n        min_quality: lower bound on the image quality. In [0, 100]\n            range for jpeg and [1, 100] for webp.\n        max_quality: upper bound on the image quality. In [0, 100]\n            range for jpeg and [1, 100] for webp.\n        compression_type: should be 'jpeg'/'jpg' or 'webp'.\n    \"\"\"\n\n    def __init__(self, p:float=0.5, min_quality:int=20,\n        max_quality:int=90, compression_type:str='.jpg'):\n        <IND>super(RandomCompression, self).__init__(p=p)\n\n        self.compression_type = compression_type\n        low_q_thresh = 1 if compression_type == \".webp\" else 0\n        if not  low_q_thresh <= min_quality <= 100:\n            <IND>raise ValueError(f\"Invalid min_quality. Got: {min_quality}\")\n        <DED>if not  low_q_thresh <= max_quality <= 100:\n            <IND>raise ValueError(f\"Invalid max_quality. Got: {max_quality}\")\n\n        <DED>self.min_quality = min_quality\n        self.max_quality = max_quality\n        self.params = self.get_params()\n\n    <DED>def get_params(self):\n        <IND>"
      }
    ]
  },
  {
    "project": "victorca25/traiNNer",
    "commit": "c4d43aab78b8c3cda9ef3c129390dfe73eca7c26",
    "filename": "opencv_transforms/transforms.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/victorca25-traiNNer/opencv_transforms/transforms.py",
    "file_hunks_size": 18,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "opencv_transforms/transforms.py:2387:57 Unsupported operand [58]: `>=` is not supported for operand types `numbers.Number` and `int`.",
    "message": " `>=` is not supported for operand types `numbers.Number` and `int`.",
    "rule_id": "Unsupported operand [58]",
    "warning_line_no": 2387,
    "warning_line": "        assert isinstance(rgb_range, numbers.Number) and rgb_range >= 0, 'rgb_range should be a positive value'"
  }
]