[
  {
    "project": "nvaccess/nvda",
    "commit": "00cd67b737bc5b23a6f5e31cf28110b64ebf2fee",
    "filename": "source/hwIo.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/nvaccess-nvda/source/hwIo/base.py",
    "file_hunks_size": 4,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "source/hwIo.py:95:2 Incompatible return type [7]: Expected `Tuple[int, ctypes.c_char_p]` but got `Tuple[int, ctypes.Array[ctypes.c_char]]`.",
    "message": " Expected `Tuple[int, ctypes.c_char_p]` but got `Tuple[int, ctypes.Array[ctypes.c_char]]`.",
    "rule_id": "Incompatible return type [7]",
    "warning_line_no": 95,
    "warning_line": "\t\treturn ("
  },
  {
    "project": "nvaccess/nvda",
    "commit": "00cd67b737bc5b23a6f5e31cf28110b64ebf2fee",
    "filename": "source/hwIo.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/nvaccess-nvda/source/hwIo/base.py",
    "file_hunks_size": 4,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "source/hwIo.py:141:3 Incompatible attribute type [8]: Attribute `_ioDone` declared in class `IoBase` has type `BoundMethod[typing.Callable(IoBase._ioDone)[[Named(self, IoBase), Named(error, unknown), Named(numberOfBytes, int), Named(overlapped, unknown)], typing.Any], IoBase]` but is used as type `None`.",
    "message": " Attribute `_ioDone` declared in class `IoBase` has type `BoundMethod[typing.Callable(IoBase._ioDone)[[Named(self, IoBase), Named(error, unknown), Named(numberOfBytes, int), Named(overlapped, unknown)], typing.Any], IoBase]` but is used as type `None`.",
    "rule_id": "Incompatible attribute type [8]",
    "warning_line_no": 141,
    "warning_line": "\t\t\tself._ioDone = None"
  },
  {
    "project": "nvaccess/nvda",
    "commit": "00cd67b737bc5b23a6f5e31cf28110b64ebf2fee",
    "filename": "source/hwIo.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/nvaccess-nvda/source/hwIo/base.py",
    "file_hunks_size": 4,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": true,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "source/hwIo.py:245:15 Unsupported operand [58]: `*` is not supported for operand types `typing.Type[ctypes.c_ushort]` and `int`.",
    "message": " `*` is not supported for operand types `typing.Type[ctypes.c_ushort]` and `int`.",
    "rule_id": "Unsupported operand [58]",
    "warning_line_no": 245,
    "warning_line": "\t\t(\"Reserved\", USHORT * 17),",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": true,
        "has_suppression": false,
        "source_code": "\nclass HIDP_CAPS (ctypes.Structure):\n\t_fields_ = (\n\t\t(\"Usage\", USHORT),\n\t\t(\"UsagePage\", USHORT),\n\t\t(\"InputReportByteLength\", USHORT),\n\t\t(\"OutputReportByteLength\", USHORT),\n\t\t(\"FeatureReportByteLength\", USHORT),\n\t\t(\"Reserved\", USHORT * 17),\n\t\t(\"NumberLinkCollectionNodes\", USHORT),\n\t\t(\"NumberInputButtonCaps\", USHORT),\n\t\t(\"NumberInputValueCaps\", USHORT),\n\t\t(\"NumberInputDataIndices\", USHORT),\n\t\t(\"NumberOutputButtonCaps\", USHORT),\n\t\t(\"NumberOutputValueCaps\", USHORT),\n\t\t(\"NumberOutputDataIndices\", USHORT),\n\t\t(\"NumberFeatureButtonCaps\", USHORT),\n\t\t(\"NumberFeatureValueCaps\", USHORT),\n\t\t(\"NumberFeatureDataIndices\", USHORT)\n\t)\n\nclass Hid(IoBase):\n\t\"\"\"Raw I/O for HID devices.\n\t\"\"\"\n\t_featureSize: int\n\n\tdef __init__(self, path: str, onReceive: Callable[[bytes], None], exclusive: bool = True):\n\t\t\"\"\"Constructor.\n\t\t@param path: The device path.\n\t\t\tThis can be retrieved using L{hwPortUtils.listHidDevices}.\n\t\t@param onReceive: A callable taking a received input report as its only argument.\n\t\t@param exclusive: Whether to block other application's access to this device.\n\t\t\"\"\"\n\t\tif _isDebug():\n\t\t\tlog.debug(\"Opening device %s\" % path)\n\t\thandle = CreateFile(\n\t\t\tpath,\n\t\t\twinKernel.GENERIC_READ | winKernel.GENERIC_WRITE,\n\t\t\t0 if exclusive else winKernel.FILE_SHARE_READ|winKernel.FILE_SHARE_WRITE,\n\t\t\tNone,\n\t\t\twinKernel.OPEN_EXISTING,\n\t\t\tFILE_FLAG_OVERLAPPED,\n\t\t\tNone\n\t\t)\n\t\tif handle == INVALID_HANDLE_VALUE:\n\t\t\tif _isDebug():\n\t\t\t\tlog.debug(\"Open failed: %s\" % ctypes.WinError())\n\t\t\traise ctypes.WinError()\n\t\tpd = ctypes.c_void_p()\n\t\tif not ctypes.windll.hid.HidD_GetPreparsedData(handle, byref(pd)):\n\t\t\traise ctypes.WinError()\n\t\tcaps = HIDP_CAPS()\n\t\tctypes.windll.hid.HidP_GetCaps(pd, byref(caps))\n\t\tctypes.windll.hid.HidD_FreePreparsedData(pd)\n\t\tif _isDebug():\n\t\t\tlog.debug(\"Report byte lengths: input %d, output %d, feature %d\"\n\t\t\t\t% (caps.InputReportByteLength, caps.OutputReportByteLength,\n\t\t\t\t\tcaps.FeatureReportByteLength))\n\t\tself._featureSize = caps.FeatureReportByteLength\n\t\tself._writeSize = caps.OutputReportByteLength\n\t\t# Reading any less than caps.InputReportByteLength is an error.\n\t\tsuper(Hid, self).__init__(handle, onReceive,\n\t\t\tonReceiveSize=caps.InputReportByteLength\n\t\t)\n\n\tdef _prepareWriteBuffer(self, data: bytes) -> Tuple[int, ctypes.c_char_p]:\n\t\t\"\"\" For HID devices, the buffer to be written must match the\n\t\tOutputReportByteLength fetched from HIDP_CAPS, to ensure this is the case\n\t\twe create a buffer of that size. We also check that data is not bigger than\n\t\tthe write size, which we do not currently support. If it becomes necessary to\n\t\tsupport this, we could split the data and send it several chunks.\n\t\t\"\"\"\n\t\t# On Windows 7, writing any less than caps.OutputReportByteLength is also an error.\n\t\t# See also: http://www.onarm.com/forum/20152/\n\t\tif len(data) > self._writeSize:\n\t\t\tlog.error(u\"Attempting to send a buffer larger than supported.\")\n\t\t\traise RuntimeError(\"Unable to send buffer of: %d\", len(data))\n\t\treturn (\n\t\t\tself._writeSize,\n\t\t\tctypes.create_string_buffer(data, self._writeSize)\n\t\t)\n\n\tdef getFeature(self, reportId: bytes) -> bytes:\n\t\t\"\"\"Get a feature report from this device.\n\t\t@param reportId: The report id.\n\t\t@return: The report, including the report id.\n\t\t\"\"\"\n\t\tbuf = ctypes.create_string_buffer(reportId, size=self._featureSize)\n\t\tif not ctypes.windll.hid.HidD_GetFeature(self._file, buf, self._featureSize):\n\t\t\tif _isDebug():\n\t\t\t\tlog.debug(\"Get feature %r failed: %s\"\n\t\t\t\t\t% (reportId, ctypes.WinError()))\n\t\t\traise ctypes.WinError()\n\t\tif _isDebug():\n\t\t\tlog.debug(\"Get feature: %r\" % buf.raw)\n\t\treturn buf.raw\n\n\tdef setFeature(self, report: bytes) -> None:\n\t\t\"\"\"Send a feature report to this device.\n\t\t@param report: The report, including its id.\n\t\t\"\"\"\n\t\tbuf = ctypes.create_string_buffer(report, size=len(report))\n\t\tbufSize = ctypes.sizeof(buf)\n\t\tif _isDebug():\n\t\t\tlog.debug(\"Set feature: %r\" % report)\n\t\tresult = ctypes.windll.hid.HidD_SetFeature(\n\t\t\tself._file,\n\t\t\tbuf,\n\t\t\tbufSize\n\t\t)\n\t\tif not result:\n\t\t\tif _isDebug():\n\t\t\t\tlog.debug(\"Set feature failed: %s\" % ctypes.WinError())\n\t\t\traise ctypes.WinError()\n\n\tdef setOutputReport(self, report: bytes) -> None:\n\t\t\"\"\"\n\t\tWrite the given report to the device using HidD_SetOutputReport.\n\t\tThis is instead of using the standard WriteFile which may freeze with some USB HID implementations.\n\t\t@param report: The report, including its id.\n\t\t\"\"\"\n\t\tbuf = ctypes.create_string_buffer(report, size=len(report))\n\t\tbufSize = ctypes.sizeof(buf)\n\t\tif _isDebug():\n\t\t\tlog.debug(\"Set output report: %r\" % report)\n\t\tresult = ctypes.windll.hid.HidD_SetOutputReport(\n\t\t\tself._writeFile,\n\t\t\tbuf,\n\t\t\tbufSize\n\t\t)\n\t\tif not result:\n\t\t\tif _isDebug():\n\t\t\t\tlog.debug(\"Set output report failed: %s\" % ctypes.WinError())\n\t\t\traise ctypes.WinError()\n\n\tdef close(self):\n\t\tsuper(Hid, self).close()\n\t\twinKernel.closeHandle(self._file)\n\t\tself._file = None\n\n",
        "source_code_len": 4819,
        "target_code": "\n\n",
        "target_code_len": 2,
        "diff_format": "@@ -237,140 +237,2 @@\n \n-class HIDP_CAPS (ctypes.Structure):\n-\t_fields_ = (\n-\t\t(\"Usage\", USHORT),\n-\t\t(\"UsagePage\", USHORT),\n-\t\t(\"InputReportByteLength\", USHORT),\n-\t\t(\"OutputReportByteLength\", USHORT),\n-\t\t(\"FeatureReportByteLength\", USHORT),\n-\t\t(\"Reserved\", USHORT * 17),\n-\t\t(\"NumberLinkCollectionNodes\", USHORT),\n-\t\t(\"NumberInputButtonCaps\", USHORT),\n-\t\t(\"NumberInputValueCaps\", USHORT),\n-\t\t(\"NumberInputDataIndices\", USHORT),\n-\t\t(\"NumberOutputButtonCaps\", USHORT),\n-\t\t(\"NumberOutputValueCaps\", USHORT),\n-\t\t(\"NumberOutputDataIndices\", USHORT),\n-\t\t(\"NumberFeatureButtonCaps\", USHORT),\n-\t\t(\"NumberFeatureValueCaps\", USHORT),\n-\t\t(\"NumberFeatureDataIndices\", USHORT)\n-\t)\n-\n-class Hid(IoBase):\n-\t\"\"\"Raw I/O for HID devices.\n-\t\"\"\"\n-\t_featureSize: int\n-\n-\tdef __init__(self, path: str, onReceive: Callable[[bytes], None], exclusive: bool = True):\n-\t\t\"\"\"Constructor.\n-\t\t@param path: The device path.\n-\t\t\tThis can be retrieved using L{hwPortUtils.listHidDevices}.\n-\t\t@param onReceive: A callable taking a received input report as its only argument.\n-\t\t@param exclusive: Whether to block other application's access to this device.\n-\t\t\"\"\"\n-\t\tif _isDebug():\n-\t\t\tlog.debug(\"Opening device %s\" % path)\n-\t\thandle = CreateFile(\n-\t\t\tpath,\n-\t\t\twinKernel.GENERIC_READ | winKernel.GENERIC_WRITE,\n-\t\t\t0 if exclusive else winKernel.FILE_SHARE_READ|winKernel.FILE_SHARE_WRITE,\n-\t\t\tNone,\n-\t\t\twinKernel.OPEN_EXISTING,\n-\t\t\tFILE_FLAG_OVERLAPPED,\n-\t\t\tNone\n-\t\t)\n-\t\tif handle == INVALID_HANDLE_VALUE:\n-\t\t\tif _isDebug():\n-\t\t\t\tlog.debug(\"Open failed: %s\" % ctypes.WinError())\n-\t\t\traise ctypes.WinError()\n-\t\tpd = ctypes.c_void_p()\n-\t\tif not ctypes.windll.hid.HidD_GetPreparsedData(handle, byref(pd)):\n-\t\t\traise ctypes.WinError()\n-\t\tcaps = HIDP_CAPS()\n-\t\tctypes.windll.hid.HidP_GetCaps(pd, byref(caps))\n-\t\tctypes.windll.hid.HidD_FreePreparsedData(pd)\n-\t\tif _isDebug():\n-\t\t\tlog.debug(\"Report byte lengths: input %d, output %d, feature %d\"\n-\t\t\t\t% (caps.InputReportByteLength, caps.OutputReportByteLength,\n-\t\t\t\t\tcaps.FeatureReportByteLength))\n-\t\tself._featureSize = caps.FeatureReportByteLength\n-\t\tself._writeSize = caps.OutputReportByteLength\n-\t\t# Reading any less than caps.InputReportByteLength is an error.\n-\t\tsuper(Hid, self).__init__(handle, onReceive,\n-\t\t\tonReceiveSize=caps.InputReportByteLength\n-\t\t)\n-\n-\tdef _prepareWriteBuffer(self, data: bytes) -> Tuple[int, ctypes.c_char_p]:\n-\t\t\"\"\" For HID devices, the buffer to be written must match the\n-\t\tOutputReportByteLength fetched from HIDP_CAPS, to ensure this is the case\n-\t\twe create a buffer of that size. We also check that data is not bigger than\n-\t\tthe write size, which we do not currently support. If it becomes necessary to\n-\t\tsupport this, we could split the data and send it several chunks.\n-\t\t\"\"\"\n-\t\t# On Windows 7, writing any less than caps.OutputReportByteLength is also an error.\n-\t\t# See also: http://www.onarm.com/forum/20152/\n-\t\tif len(data) > self._writeSize:\n-\t\t\tlog.error(u\"Attempting to send a buffer larger than supported.\")\n-\t\t\traise RuntimeError(\"Unable to send buffer of: %d\", len(data))\n-\t\treturn (\n-\t\t\tself._writeSize,\n-\t\t\tctypes.create_string_buffer(data, self._writeSize)\n-\t\t)\n-\n-\tdef getFeature(self, reportId: bytes) -> bytes:\n-\t\t\"\"\"Get a feature report from this device.\n-\t\t@param reportId: The report id.\n-\t\t@return: The report, including the report id.\n-\t\t\"\"\"\n-\t\tbuf = ctypes.create_string_buffer(reportId, size=self._featureSize)\n-\t\tif not ctypes.windll.hid.HidD_GetFeature(self._file, buf, self._featureSize):\n-\t\t\tif _isDebug():\n-\t\t\t\tlog.debug(\"Get feature %r failed: %s\"\n-\t\t\t\t\t% (reportId, ctypes.WinError()))\n-\t\t\traise ctypes.WinError()\n-\t\tif _isDebug():\n-\t\t\tlog.debug(\"Get feature: %r\" % buf.raw)\n-\t\treturn buf.raw\n-\n-\tdef setFeature(self, report: bytes) -> None:\n-\t\t\"\"\"Send a feature report to this device.\n-\t\t@param report: The report, including its id.\n-\t\t\"\"\"\n-\t\tbuf = ctypes.create_string_buffer(report, size=len(report))\n-\t\tbufSize = ctypes.sizeof(buf)\n-\t\tif _isDebug():\n-\t\t\tlog.debug(\"Set feature: %r\" % report)\n-\t\tresult = ctypes.windll.hid.HidD_SetFeature(\n-\t\t\tself._file,\n-\t\t\tbuf,\n-\t\t\tbufSize\n-\t\t)\n-\t\tif not result:\n-\t\t\tif _isDebug():\n-\t\t\t\tlog.debug(\"Set feature failed: %s\" % ctypes.WinError())\n-\t\t\traise ctypes.WinError()\n-\n-\tdef setOutputReport(self, report: bytes) -> None:\n-\t\t\"\"\"\n-\t\tWrite the given report to the device using HidD_SetOutputReport.\n-\t\tThis is instead of using the standard WriteFile which may freeze with some USB HID implementations.\n-\t\t@param report: The report, including its id.\n-\t\t\"\"\"\n-\t\tbuf = ctypes.create_string_buffer(report, size=len(report))\n-\t\tbufSize = ctypes.sizeof(buf)\n-\t\tif _isDebug():\n-\t\t\tlog.debug(\"Set output report: %r\" % report)\n-\t\tresult = ctypes.windll.hid.HidD_SetOutputReport(\n-\t\t\tself._writeFile,\n-\t\t\tbuf,\n-\t\t\tbufSize\n-\t\t)\n-\t\tif not result:\n-\t\t\tif _isDebug():\n-\t\t\t\tlog.debug(\"Set output report failed: %s\" % ctypes.WinError())\n-\t\t\traise ctypes.WinError()\n-\n-\tdef close(self):\n-\t\tsuper(Hid, self).close()\n-\t\twinKernel.closeHandle(self._file)\n-\t\tself._file = None\n \n",
        "source_code_with_indent": "\n<DED><DED>class HIDP_CAPS (ctypes.Structure):\n\t<IND>_fields_ = (\n  (\"Usage\", USHORT),\n  (\"UsagePage\", USHORT),\n  (\"InputReportByteLength\", USHORT),\n  (\"OutputReportByteLength\", USHORT),\n  (\"FeatureReportByteLength\", USHORT),\n  (\"Reserved\", USHORT * 17),\n  (\"NumberLinkCollectionNodes\", USHORT),\n  (\"NumberInputButtonCaps\", USHORT),\n  (\"NumberInputValueCaps\", USHORT),\n  (\"NumberInputDataIndices\", USHORT),\n  (\"NumberOutputButtonCaps\", USHORT),\n  (\"NumberOutputValueCaps\", USHORT),\n  (\"NumberOutputDataIndices\", USHORT),\n  (\"NumberFeatureButtonCaps\", USHORT),\n  (\"NumberFeatureValueCaps\", USHORT),\n  (\"NumberFeatureDataIndices\", USHORT)\n )\n\n<DED>class Hid(IoBase):\n\t<IND>\"\"\"Raw I/O for HID devices.\n\t\"\"\"\n _featureSize: int\n\n def __init__(self, path: str, onReceive: Callable[[bytes], None], exclusive: bool = True):\n\t\t<IND>\"\"\"Constructor.\n\t\t@param path: The device path.\n\t\t\tThis can be retrieved using L{hwPortUtils.listHidDevices}.\n\t\t@param onReceive: A callable taking a received input report as its only argument.\n\t\t@param exclusive: Whether to block other application's access to this device.\n\t\t\"\"\"\n  if _isDebug():\n\t\t\t<IND>log.debug(\"Opening device %s\" % path)\n  <DED>handle = CreateFile(\n   path,\n   winKernel.GENERIC_READ | winKernel.GENERIC_WRITE,\n   0 if exclusive else winKernel.FILE_SHARE_READ|winKernel.FILE_SHARE_WRITE,\n   None,\n   winKernel.OPEN_EXISTING,\n   FILE_FLAG_OVERLAPPED,\n   None\n  )\n  if handle == INVALID_HANDLE_VALUE:\n\t\t\t<IND>if _isDebug():\n\t\t\t\t<IND>log.debug(\"Open failed: %s\" % ctypes.WinError())\n   <DED>raise ctypes.WinError()\n  <DED>pd = ctypes.c_void_p()\n  if not ctypes.windll.hid.HidD_GetPreparsedData(handle, byref(pd)):\n\t\t\t<IND>raise ctypes.WinError()\n  <DED>caps = HIDP_CAPS()\n  ctypes.windll.hid.HidP_GetCaps(pd, byref(caps))\n  ctypes.windll.hid.HidD_FreePreparsedData(pd)\n  if _isDebug():\n\t\t\t<IND>log.debug(\"Report byte lengths: input %d, output %d, feature %d\"\n    % (caps.InputReportByteLength, caps.OutputReportByteLength,\n     caps.FeatureReportByteLength))\n  <DED>self._featureSize = caps.FeatureReportByteLength\n  self._writeSize = caps.OutputReportByteLength\n  # Reading any less than caps.InputReportByteLength is an error.\n  super(Hid, self).__init__(handle, onReceive,\n   onReceiveSize=caps.InputReportByteLength\n  )\n\n <DED>def _prepareWriteBuffer(self, data: bytes) -> Tuple[int, ctypes.c_char_p]:\n\t\t<IND>\"\"\" For HID devices, the buffer to be written must match the\n\t\tOutputReportByteLength fetched from HIDP_CAPS, to ensure this is the case\n\t\twe create a buffer of that size. We also check that data is not bigger than\n\t\tthe write size, which we do not currently support. If it becomes necessary to\n\t\tsupport this, we could split the data and send it several chunks.\n\t\t\"\"\"\n  # On Windows 7, writing any less than caps.OutputReportByteLength is also an error.\n  # See also: http://www.onarm.com/forum/20152/\n  if len(data) > self._writeSize:\n\t\t\t<IND>log.error(u\"Attempting to send a buffer larger than supported.\")\n   raise RuntimeError(\"Unable to send buffer of: %d\", len(data))\n  <DED>return (\n   self._writeSize,\n   ctypes.create_string_buffer(data, self._writeSize)\n  )\n\n <DED>def getFeature(self, reportId: bytes) -> bytes:\n\t\t<IND>\"\"\"Get a feature report from this device.\n\t\t@param reportId: The report id.\n\t\t@return: The report, including the report id.\n\t\t\"\"\"\n  buf = ctypes.create_string_buffer(reportId, size=self._featureSize)\n  if not ctypes.windll.hid.HidD_GetFeature(self._file, buf, self._featureSize):\n\t\t\t<IND>if _isDebug():\n\t\t\t\t<IND>log.debug(\"Get feature %r failed: %s\"\n     % (reportId, ctypes.WinError()))\n   <DED>raise ctypes.WinError()\n  <DED>if _isDebug():\n\t\t\t<IND>log.debug(\"Get feature: %r\" % buf.raw)\n  <DED>return buf.raw\n\n <DED>def setFeature(self, report: bytes) -> None:\n\t\t<IND>\"\"\"Send a feature report to this device.\n\t\t@param report: The report, including its id.\n\t\t\"\"\"\n  buf = ctypes.create_string_buffer(report, size=len(report))\n  bufSize = ctypes.sizeof(buf)\n  if _isDebug():\n\t\t\t<IND>log.debug(\"Set feature: %r\" % report)\n  <DED>result = ctypes.windll.hid.HidD_SetFeature(\n   self._file,\n   buf,\n   bufSize\n  )\n  if not result:\n\t\t\t<IND>if _isDebug():\n\t\t\t\t<IND>log.debug(\"Set feature failed: %s\" % ctypes.WinError())\n   <DED>raise ctypes.WinError()\n\n <DED><DED>def setOutputReport(self, report: bytes) -> None:\n\t\t<IND>\"\"\"\n\t\tWrite the given report to the device using HidD_SetOutputReport.\n\t\tThis is instead of using the standard WriteFile which may freeze with some USB HID implementations.\n\t\t@param report: The report, including its id.\n\t\t\"\"\"\n  buf = ctypes.create_string_buffer(report, size=len(report))\n  bufSize = ctypes.sizeof(buf)\n  if _isDebug():\n\t\t\t<IND>log.debug(\"Set output report: %r\" % report)\n  <DED>result = ctypes.windll.hid.HidD_SetOutputReport(\n   self._writeFile,\n   buf,\n   bufSize\n  )\n  if not result:\n\t\t\t<IND>if _isDebug():\n\t\t\t\t<IND>log.debug(\"Set output report failed: %s\" % ctypes.WinError())\n   <DED>raise ctypes.WinError()\n\n <DED><DED>def close(self):\n\t\t<IND>super(Hid, self).close()\n  winKernel.closeHandle(self._file)\n  self._file = None\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  }
]