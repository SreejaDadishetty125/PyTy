[
  {
    "project": "abhinavsingh/proxy.py",
    "commit": "5b5c77ed24760efb215e6a5a503e2f64a2c16dd8",
    "filename": "proxy/http/proxy/server.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/abhinavsingh-proxy.py/proxy/http/proxy/server.py",
    "file_hunks_size": 17,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "proxy/http/proxy/server.py:389:67 Incompatible parameter type [6]: Expected `str` for 2nd parameter `private_key_path` to call `gen_public_key` but got `Optional[str]`.",
    "message": " Expected `str` for 2nd parameter `private_key_path` to call `gen_public_key` but got `Optional[str]`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 389,
    "warning_line": "            resp = gen_public_key(public_key_path=public_key_path, private_key_path=private_key_path,"
  },
  {
    "project": "abhinavsingh/proxy.py",
    "commit": "5b5c77ed24760efb215e6a5a503e2f64a2c16dd8",
    "filename": "proxy/http/proxy/server.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/abhinavsingh-proxy.py/proxy/http/proxy/server.py",
    "file_hunks_size": 17,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "proxy/http/proxy/server.py:400:46 Incompatible parameter type [6]: Expected `str` for 2nd parameter `key_path` to call `gen_csr` but got `Optional[str]`.",
    "message": " Expected `str` for 2nd parameter `key_path` to call `gen_csr` but got `Optional[str]`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 400,
    "warning_line": "            resp = gen_csr(csr_path=csr_path, key_path=private_key_path, password=private_key_password,"
  },
  {
    "project": "abhinavsingh/proxy.py",
    "commit": "5b5c77ed24760efb215e6a5a503e2f64a2c16dd8",
    "filename": "proxy/http/proxy/server.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/abhinavsingh-proxy.py/proxy/http/proxy/server.py",
    "file_hunks_size": 17,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "proxy/http/proxy/server.py:412:72 Incompatible parameter type [6]: Expected `str` for 3rd parameter `ca_key_path` to call `sign_csr` but got `Optional[str]`.",
    "message": " Expected `str` for 3rd parameter `ca_key_path` to call `sign_csr` but got `Optional[str]`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 412,
    "warning_line": "            resp = sign_csr(csr_path=csr_path, crt_path=cert_file_path, ca_key_path=ca_key_path,"
  },
  {
    "project": "abhinavsingh/proxy.py",
    "commit": "5b5c77ed24760efb215e6a5a503e2f64a2c16dd8",
    "filename": "proxy/http/proxy/server.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/abhinavsingh-proxy.py/proxy/http/proxy/server.py",
    "file_hunks_size": 17,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "proxy/http/proxy/server.py:413:61 Incompatible parameter type [6]: Expected `str` for 5th parameter `ca_crt_path` to call `sign_csr` but got `Optional[str]`.",
    "message": " Expected `str` for 5th parameter `ca_crt_path` to call `sign_csr` but got `Optional[str]`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 413,
    "warning_line": "                            ca_key_password=ca_key_password, ca_crt_path=ca_crt_path,"
  },
  {
    "project": "abhinavsingh/proxy.py",
    "commit": "5b5c77ed24760efb215e6a5a503e2f64a2c16dd8",
    "filename": "proxy/http/websocket.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/abhinavsingh-proxy.py/proxy/http/websocket/frame.py",
    "file_hunks_size": 3,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "proxy/http/websocket.py:111:53 Unsupported operand [58]: `|` is not supported for operand types `int` and `Optional[int]`.",
    "message": " `|` is not supported for operand types `int` and `Optional[int]`.",
    "rule_id": "Unsupported operand [58]",
    "warning_line_no": 111,
    "warning_line": "                    (1 << 7 if self.masked else 0) | self.payload_length"
  },
  {
    "project": "abhinavsingh/proxy.py",
    "commit": "5b5c77ed24760efb215e6a5a503e2f64a2c16dd8",
    "filename": "proxy/http/websocket.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/abhinavsingh-proxy.py/proxy/http/websocket/frame.py",
    "file_hunks_size": 3,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "proxy/http/websocket.py:114:13 Unsupported operand [58]: `<` is not supported for operand types `Optional[int]` and `int`.",
    "message": " `<` is not supported for operand types `Optional[int]` and `int`.",
    "rule_id": "Unsupported operand [58]",
    "warning_line_no": 114,
    "warning_line": "        elif self.payload_length < 1 << 16:"
  },
  {
    "project": "abhinavsingh/proxy.py",
    "commit": "5b5c77ed24760efb215e6a5a503e2f64a2c16dd8",
    "filename": "proxy/http/websocket.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/abhinavsingh-proxy.py/proxy/http/websocket/frame.py",
    "file_hunks_size": 3,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "proxy/http/websocket.py:122:13 Unsupported operand [58]: `<` is not supported for operand types `Optional[int]` and `int`.",
    "message": " `<` is not supported for operand types `Optional[int]` and `int`.",
    "rule_id": "Unsupported operand [58]",
    "warning_line_no": 122,
    "warning_line": "        elif self.payload_length < 1 << 64:"
  },
  {
    "project": "abhinavsingh/proxy.py",
    "commit": "5b5c77ed24760efb215e6a5a503e2f64a2c16dd8",
    "filename": "proxy/http/websocket.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/abhinavsingh-proxy.py/proxy/http/websocket/frame.py",
    "file_hunks_size": 3,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "proxy/http/websocket.py:136:38 Incompatible parameter type [6]: Expected `bytes` for 1st positional only parameter to call `WebsocketFrame.apply_mask` but got `Optional[bytes]`.",
    "message": " Expected `bytes` for 1st positional only parameter to call `WebsocketFrame.apply_mask` but got `Optional[bytes]`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 136,
    "warning_line": "            raw.write(self.apply_mask(self.data, mask))"
  },
  {
    "project": "abhinavsingh/proxy.py",
    "commit": "5b5c77ed24760efb215e6a5a503e2f64a2c16dd8",
    "filename": "proxy/http/websocket.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/abhinavsingh-proxy.py/proxy/http/websocket/frame.py",
    "file_hunks_size": 3,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "proxy/http/websocket.py:164:15 Unsupported operand [58]: `+` is not supported for operand types `int` and `Optional[int]`.",
    "message": " `+` is not supported for operand types `int` and `Optional[int]`.",
    "rule_id": "Unsupported operand [58]",
    "warning_line_no": 164,
    "warning_line": "        cur += self.payload_length"
  },
  {
    "project": "abhinavsingh/proxy.py",
    "commit": "5b5c77ed24760efb215e6a5a503e2f64a2c16dd8",
    "filename": "proxy/http/websocket.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/abhinavsingh-proxy.py/proxy/http/websocket/frame.py",
    "file_hunks_size": 3,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "proxy/http/websocket.py:167:40 Incompatible parameter type [6]: Expected `bytes` for 1st positional only parameter to call `WebsocketFrame.apply_mask` but got `Optional[bytes]`.",
    "message": " Expected `bytes` for 1st positional only parameter to call `WebsocketFrame.apply_mask` but got `Optional[bytes]`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 167,
    "warning_line": "            self.data = self.apply_mask(self.data, self.mask)"
  },
  {
    "project": "abhinavsingh/proxy.py",
    "commit": "5b5c77ed24760efb215e6a5a503e2f64a2c16dd8",
    "filename": "proxy/http/websocket.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/abhinavsingh-proxy.py/proxy/http/websocket/frame.py",
    "file_hunks_size": 3,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": true,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "proxy/http/websocket.py:245:16 Call error [29]: `Optional[typing.Callable[[WebsocketFrame], None]]` is not a function.",
    "message": " `Optional[typing.Callable[[WebsocketFrame], None]]` is not a function.",
    "rule_id": "Call error [29]",
    "warning_line_no": 245,
    "warning_line": "                self.on_message(frame)",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": true,
        "has_suppression": false,
        "source_code": "        return base64.b64encode(sha1.digest())\n\n\nclass WebsocketClient(TcpConnection):\n\n    def __init__(self,\n                 hostname: Union[ipaddress.IPv4Address, ipaddress.IPv6Address],\n                 port: int,\n                 path: bytes = b'/',\n                 on_message: Optional[Callable[[WebsocketFrame], None]] = None) -> None:\n        super().__init__(tcpConnectionTypes.CLIENT)\n        self.hostname: Union[ipaddress.IPv4Address,\n                             ipaddress.IPv6Address] = hostname\n        self.port: int = port\n        self.path: bytes = path\n        self.sock: socket.socket = new_socket_connection(\n            (str(self.hostname), self.port))\n        self.on_message: Optional[Callable[[\n            WebsocketFrame], None]] = on_message\n        self.upgrade()\n        self.sock.setblocking(False)\n        self.selector: selectors.DefaultSelector = selectors.DefaultSelector()\n\n    @property\n    def connection(self) -> Union[ssl.SSLSocket, socket.socket]:\n        return self.sock\n\n    def upgrade(self) -> None:\n        key = base64.b64encode(secrets.token_bytes(16))\n        self.sock.send(build_websocket_handshake_request(key, url=self.path))\n        response = HttpParser(httpParserTypes.RESPONSE_PARSER)\n        response.parse(self.sock.recv(DEFAULT_BUFFER_SIZE))\n        accept = response.header(b'Sec-Websocket-Accept')\n        assert WebsocketFrame.key_to_accept(key) == accept\n\n    def ping(self, data: Optional[bytes] = None) -> None:\n        pass\n\n    def pong(self, data: Optional[bytes] = None) -> None:\n        pass\n\n    def shutdown(self, _data: Optional[bytes] = None) -> None:\n        \"\"\"Closes connection with the server.\"\"\"\n        super().close()\n\n    def run_once(self) -> bool:\n        ev = selectors.EVENT_READ\n        if self.has_buffer():\n            ev |= selectors.EVENT_WRITE\n        self.selector.register(self.sock.fileno(), ev)\n        events = self.selector.select(timeout=1)\n        self.selector.unregister(self.sock)\n        for _, mask in events:\n            if mask & selectors.EVENT_READ and self.on_message:\n                raw = self.recv()\n                if raw is None or raw.tobytes() == b'':\n                    self.closed = True\n                    logger.debug('Websocket connection closed by server')\n                    return True\n                frame = WebsocketFrame()\n                # TODO(abhinavsingh): Remove .tobytes after parser is\n                # memoryview compliant\n                frame.parse(raw.tobytes())\n                self.on_message(frame)\n            elif mask & selectors.EVENT_WRITE:\n                logger.debug(self.buffer)\n                self.flush()\n        return False\n\n    def run(self) -> None:\n        logger.debug('running')\n        try:\n            while not self.closed:\n                teardown = self.run_once()\n                if teardown:\n                    break\n        except KeyboardInterrupt:\n            pass\n        finally:\n            try:\n                self.selector.unregister(self.sock)\n                self.sock.shutdown(socket.SHUT_WR)\n            except Exception as e:\n                logging.exception(\n                    'Exception while shutdown of websocket client', exc_info=e)\n            self.sock.close()\n        logger.info('done')\n",
        "source_code_len": 3290,
        "target_code": "        return base64.b64encode(sha1.digest())\n",
        "target_code_len": 47,
        "diff_format": "@@ -182,87 +172,1 @@\n         return base64.b64encode(sha1.digest())\n-\n-\n-class WebsocketClient(TcpConnection):\n-\n-    def __init__(self,\n-                 hostname: Union[ipaddress.IPv4Address, ipaddress.IPv6Address],\n-                 port: int,\n-                 path: bytes = b'/',\n-                 on_message: Optional[Callable[[WebsocketFrame], None]] = None) -> None:\n-        super().__init__(tcpConnectionTypes.CLIENT)\n-        self.hostname: Union[ipaddress.IPv4Address,\n-                             ipaddress.IPv6Address] = hostname\n-        self.port: int = port\n-        self.path: bytes = path\n-        self.sock: socket.socket = new_socket_connection(\n-            (str(self.hostname), self.port))\n-        self.on_message: Optional[Callable[[\n-            WebsocketFrame], None]] = on_message\n-        self.upgrade()\n-        self.sock.setblocking(False)\n-        self.selector: selectors.DefaultSelector = selectors.DefaultSelector()\n-\n-    @property\n-    def connection(self) -> Union[ssl.SSLSocket, socket.socket]:\n-        return self.sock\n-\n-    def upgrade(self) -> None:\n-        key = base64.b64encode(secrets.token_bytes(16))\n-        self.sock.send(build_websocket_handshake_request(key, url=self.path))\n-        response = HttpParser(httpParserTypes.RESPONSE_PARSER)\n-        response.parse(self.sock.recv(DEFAULT_BUFFER_SIZE))\n-        accept = response.header(b'Sec-Websocket-Accept')\n-        assert WebsocketFrame.key_to_accept(key) == accept\n-\n-    def ping(self, data: Optional[bytes] = None) -> None:\n-        pass\n-\n-    def pong(self, data: Optional[bytes] = None) -> None:\n-        pass\n-\n-    def shutdown(self, _data: Optional[bytes] = None) -> None:\n-        \"\"\"Closes connection with the server.\"\"\"\n-        super().close()\n-\n-    def run_once(self) -> bool:\n-        ev = selectors.EVENT_READ\n-        if self.has_buffer():\n-            ev |= selectors.EVENT_WRITE\n-        self.selector.register(self.sock.fileno(), ev)\n-        events = self.selector.select(timeout=1)\n-        self.selector.unregister(self.sock)\n-        for _, mask in events:\n-            if mask & selectors.EVENT_READ and self.on_message:\n-                raw = self.recv()\n-                if raw is None or raw.tobytes() == b'':\n-                    self.closed = True\n-                    logger.debug('Websocket connection closed by server')\n-                    return True\n-                frame = WebsocketFrame()\n-                # TODO(abhinavsingh): Remove .tobytes after parser is\n-                # memoryview compliant\n-                frame.parse(raw.tobytes())\n-                self.on_message(frame)\n-            elif mask & selectors.EVENT_WRITE:\n-                logger.debug(self.buffer)\n-                self.flush()\n-        return False\n-\n-    def run(self) -> None:\n-        logger.debug('running')\n-        try:\n-            while not self.closed:\n-                teardown = self.run_once()\n-                if teardown:\n-                    break\n-        except KeyboardInterrupt:\n-            pass\n-        finally:\n-            try:\n-                self.selector.unregister(self.sock)\n-                self.sock.shutdown(socket.SHUT_WR)\n-            except Exception as e:\n-                logging.exception(\n-                    'Exception while shutdown of websocket client', exc_info=e)\n-            self.sock.close()\n-        logger.info('done')\n",
        "source_code_with_indent": "        return base64.b64encode(sha1.digest())\n\n\n<DED><DED>class WebsocketClient(TcpConnection):\n\n    <IND>def __init__(self,\n                 hostname: Union[ipaddress.IPv4Address, ipaddress.IPv6Address],\n                 port: int,\n                 path: bytes = b'/',\n                 on_message: Optional[Callable[[WebsocketFrame], None]] = None) -> None:\n        <IND>super().__init__(tcpConnectionTypes.CLIENT)\n        self.hostname: Union[ipaddress.IPv4Address,\n                             ipaddress.IPv6Address] = hostname\n        self.port: int = port\n        self.path: bytes = path\n        self.sock: socket.socket = new_socket_connection(\n            (str(self.hostname), self.port))\n        self.on_message: Optional[Callable[[\n            WebsocketFrame], None]] = on_message\n        self.upgrade()\n        self.sock.setblocking(False)\n        self.selector: selectors.DefaultSelector = selectors.DefaultSelector()\n\n    <DED>@property\n    def connection(self) -> Union[ssl.SSLSocket, socket.socket]:\n        <IND>return self.sock\n\n    <DED>def upgrade(self) -> None:\n        <IND>key = base64.b64encode(secrets.token_bytes(16))\n        self.sock.send(build_websocket_handshake_request(key, url=self.path))\n        response = HttpParser(httpParserTypes.RESPONSE_PARSER)\n        response.parse(self.sock.recv(DEFAULT_BUFFER_SIZE))\n        accept = response.header(b'Sec-Websocket-Accept')\n        assert WebsocketFrame.key_to_accept(key) == accept\n\n    <DED>def ping(self, data: Optional[bytes] = None) -> None:\n        <IND>pass\n\n    <DED>def pong(self, data: Optional[bytes] = None) -> None:\n        <IND>pass\n\n    <DED>def shutdown(self, _data: Optional[bytes] = None) -> None:\n        <IND>\"\"\"Closes connection with the server.\"\"\"\n        super().close()\n\n    <DED>def run_once(self) -> bool:\n        <IND>ev = selectors.EVENT_READ\n        if self.has_buffer():\n            <IND>ev |= selectors.EVENT_WRITE\n        <DED>self.selector.register(self.sock.fileno(), ev)\n        events = self.selector.select(timeout=1)\n        self.selector.unregister(self.sock)\n        for _, mask in events:\n            <IND>if mask & selectors.EVENT_READ and self.on_message:\n                <IND>raw = self.recv()\n                if raw is None or raw.tobytes() == b'':\n                    <IND>self.closed = True\n                    logger.debug('Websocket connection closed by server')\n                    return True\n                <DED>frame = WebsocketFrame()\n                # TODO(abhinavsingh): Remove .tobytes after parser is\n                # memoryview compliant\n                frame.parse(raw.tobytes())\n                self.on_message(frame)\n            <DED>elif mask & selectors.EVENT_WRITE:\n                <IND>logger.debug(self.buffer)\n                self.flush()\n        <DED><DED>return False\n\n    <DED>def run(self) -> None:\n        <IND>logger.debug('running')\n        try:\n            <IND>while not self.closed:\n                <IND>teardown = self.run_once()\n                if teardown:\n                    <IND>break\n        <DED><DED><DED>except KeyboardInterrupt:\n            <IND>pass\n        <DED>finally:\n            <IND>try:\n                <IND>self.selector.unregister(self.sock)\n                self.sock.shutdown(socket.SHUT_WR)\n            <DED>except Exception as e:\n                <IND>logging.exception(\n                    'Exception while shutdown of websocket client', exc_info=e)\n            <DED>self.sock.close()\n        <DED>logger.info('done')\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "        return base64.b64encode(sha1.digest())\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  }
]