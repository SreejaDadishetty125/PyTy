[
  {
    "project": "Qiskit/qiskit-terra",
    "commit": "a1b0aa2443875b29c6c636279a706ef25860dda9",
    "filename": "qiskit/circuit/library/n_local/qaoa_ansatz.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/Qiskit-qiskit-terra/qiskit/circuit/library/n_local/qaoa_ansatz.py",
    "file_hunks_size": 6,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "qiskit/circuit/library/n_local/qaoa_ansatz.py:191:36 Incompatible parameter type [6]: Expected `typing.Union[QuantumCircuit, qiskit.circuit.instruction.Instruction]` for 1st positional only parameter to call `qiskit.opflow.state_fns.circuit_state_fn.CircuitStateFn.__init__` but got `Optional[QuantumCircuit]`.",
    "message": " Expected `typing.Union[QuantumCircuit, qiskit.circuit.instruction.Instruction]` for 1st positional only parameter to call `qiskit.opflow.state_fns.circuit_state_fn.CircuitStateFn.__init__` but got `Optional[QuantumCircuit]`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 191,
    "warning_line": "        circuit_op = CircuitStateFn(self.initial_state)",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n    def _build(self) -> None:\n        \"\"\"Build the circuit.\"\"\"\n        if self._data:\n            return\n\n        self._check_configuration()\n        self._data = []\n\n        # calculate bounds, num_parameters, mixer\n        self._calculate_parameters()\n\n        # parameterize circuit and build it\n        param_vector = ParameterVector(\"\u03b8\", self._num_parameters)\n        circuit = self._construct_circuit(param_vector)\n\n        # append(replace) the circuit to this\n        self.compose(circuit, inplace=True)\n\n    def _reset_registers(self, num_qubits):\n        \"\"\"Set the registers and qubits to the new size.\"\"\"\n        self._qregs = []\n        self._qubits = []\n        self._qubit_set = set()\n\n        if num_qubits > 0:\n            qr = QuantumRegister(num_qubits, \"q\")\n            self.add_register(qr)\n\n",
        "source_code_len": 814,
        "target_code": "\n    @property\n    def num_qubits(self) -> int:\n        \"\"\"Return the number of qubits, specified by the size of the cost operator.\"\"\"\n        if self.cost_operator is not None:\n            return self.cost_operator.num_qubits\n        return 0\n\n",
        "target_code_len": 245,
        "diff_format": "@@ -111,29 +108,8 @@\n \n-    def _build(self) -> None:\n-        \"\"\"Build the circuit.\"\"\"\n-        if self._data:\n-            return\n-\n-        self._check_configuration()\n-        self._data = []\n-\n-        # calculate bounds, num_parameters, mixer\n-        self._calculate_parameters()\n-\n-        # parameterize circuit and build it\n-        param_vector = ParameterVector(\"\u03b8\", self._num_parameters)\n-        circuit = self._construct_circuit(param_vector)\n-\n-        # append(replace) the circuit to this\n-        self.compose(circuit, inplace=True)\n-\n-    def _reset_registers(self, num_qubits):\n-        \"\"\"Set the registers and qubits to the new size.\"\"\"\n-        self._qregs = []\n-        self._qubits = []\n-        self._qubit_set = set()\n-\n-        if num_qubits > 0:\n-            qr = QuantumRegister(num_qubits, \"q\")\n-            self.add_register(qr)\n+    @property\n+    def num_qubits(self) -> int:\n+        \"\"\"Return the number of qubits, specified by the size of the cost operator.\"\"\"\n+        if self.cost_operator is not None:\n+            return self.cost_operator.num_qubits\n+        return 0\n \n",
        "source_code_with_indent": "\n    <DED>def _build(self) -> None:\n        <IND>\"\"\"Build the circuit.\"\"\"\n        if self._data:\n            <IND>return\n\n        <DED>self._check_configuration()\n        self._data = []\n\n        # calculate bounds, num_parameters, mixer\n        self._calculate_parameters()\n\n        # parameterize circuit and build it\n        param_vector = ParameterVector(\"\u03b8\", self._num_parameters)\n        circuit = self._construct_circuit(param_vector)\n\n        # append(replace) the circuit to this\n        self.compose(circuit, inplace=True)\n\n    <DED>def _reset_registers(self, num_qubits):\n        <IND>\"\"\"Set the registers and qubits to the new size.\"\"\"\n        self._qregs = []\n        self._qubits = []\n        self._qubit_set = set()\n\n        if num_qubits > 0:\n            <IND>qr = QuantumRegister(num_qubits, \"q\")\n            self.add_register(qr)\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n    <DED>@property\n    def num_qubits(self) -> int:\n        <IND>\"\"\"Return the number of qubits, specified by the size of the cost operator.\"\"\"\n        if self.cost_operator is not None:\n            <IND>return self.cost_operator.num_qubits\n        <DED>return 0\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n    def _calculate_parameters(self):\n        \"\"\"Calculated internal parameters of the circuit to be built.\"\"\"\n        from qiskit.opflow import OperatorBase\n\n        if isinstance(self._mixer, QuantumCircuit):\n            self._num_parameters = (1 + self._mixer.num_parameters) * self._reps\n            self._bounds = [(None, None)] * self._reps + [\n                (None, None)\n            ] * self._reps * self._mixer.num_parameters\n        elif isinstance(self._mixer, OperatorBase):\n            self._num_parameters = 2 * self._reps\n            self._bounds = [(None, None)] * self._reps + [(None, None)] * self._reps\n        elif self._mixer is None:\n            self._num_parameters = 2 * self._reps\n            self._bounds = [(None, None)] * self._reps + [(0, 2 * np.pi)] * self._reps\n\n    def _construct_circuit(self, parameters) -> QuantumCircuit:\n        \"\"\"Construct a parameterized circuit.\"\"\"\n        if not len(parameters) == self._num_parameters:\n            raise ValueError(\n                \"Incorrect number of angles: expecting {}, but {} given.\".format(\n                    self._num_parameters, len(parameters)\n                )\n            )\n\n        # local imports to avoid circular imports\n        from qiskit.opflow import CircuitStateFn\n        from qiskit.opflow import CircuitOp, EvolutionFactory\n        from qiskit.opflow import OperatorBase\n\n        circuit_op = CircuitStateFn(self.initial_state)\n\n        # iterate over layers\n        for idx in range(self._reps):\n            # the first [:self._reps] parameters are used for the cost operator,\n            # so we apply them here\n            circuit_op = (self._cost_operator * parameters[idx]).exp_i().compose(circuit_op)\n            mixer = self.mixer_operator\n            if isinstance(mixer, OperatorBase):\n                mixer = cast(OperatorBase, mixer)\n                # we apply beta parameter in case of operator based mixer.\n                circuit_op = (mixer * parameters[idx + self._reps]).exp_i().compose(circuit_op)\n            else:\n                # mixer as a quantum circuit that can be parameterized\n                mixer = cast(QuantumCircuit, mixer)\n                num_params = mixer.num_parameters\n                # the remaining [self._p:] parameters are used for the mixer,\n                # there may be multiple layers, so parameters are grouped by layers.\n                param_values = parameters[\n                    self._reps + num_params * idx : self._reps + num_params * (idx + 1)\n                ]\n                param_dict = dict(zip(mixer.parameters, param_values))\n                mixer = mixer.assign_parameters(param_dict)\n                circuit_op = CircuitOp(mixer).compose(circuit_op)\n\n        evolution = EvolutionFactory.build(self._cost_operator)\n        circuit_op = evolution.convert(circuit_op)\n        return circuit_op.to_circuit()\n\n",
        "source_code_len": 2876,
        "target_code": "\n    @property\n    def operators(self):\n        \"\"\"The operators that are evolved in this circuit.\n\n        Returns:\n             List[Union[OperatorBase, QuantumCircuit]]: The operators to be evolved (and circuits)\n                in this ansatz.\n        \"\"\"\n        return [self.cost_operator, self.mixer_operator]\n\n",
        "target_code_len": 318,
        "diff_format": "@@ -160,60 +136,11 @@\n \n-    def _calculate_parameters(self):\n-        \"\"\"Calculated internal parameters of the circuit to be built.\"\"\"\n-        from qiskit.opflow import OperatorBase\n-\n-        if isinstance(self._mixer, QuantumCircuit):\n-            self._num_parameters = (1 + self._mixer.num_parameters) * self._reps\n-            self._bounds = [(None, None)] * self._reps + [\n-                (None, None)\n-            ] * self._reps * self._mixer.num_parameters\n-        elif isinstance(self._mixer, OperatorBase):\n-            self._num_parameters = 2 * self._reps\n-            self._bounds = [(None, None)] * self._reps + [(None, None)] * self._reps\n-        elif self._mixer is None:\n-            self._num_parameters = 2 * self._reps\n-            self._bounds = [(None, None)] * self._reps + [(0, 2 * np.pi)] * self._reps\n-\n-    def _construct_circuit(self, parameters) -> QuantumCircuit:\n-        \"\"\"Construct a parameterized circuit.\"\"\"\n-        if not len(parameters) == self._num_parameters:\n-            raise ValueError(\n-                \"Incorrect number of angles: expecting {}, but {} given.\".format(\n-                    self._num_parameters, len(parameters)\n-                )\n-            )\n-\n-        # local imports to avoid circular imports\n-        from qiskit.opflow import CircuitStateFn\n-        from qiskit.opflow import CircuitOp, EvolutionFactory\n-        from qiskit.opflow import OperatorBase\n-\n-        circuit_op = CircuitStateFn(self.initial_state)\n-\n-        # iterate over layers\n-        for idx in range(self._reps):\n-            # the first [:self._reps] parameters are used for the cost operator,\n-            # so we apply them here\n-            circuit_op = (self._cost_operator * parameters[idx]).exp_i().compose(circuit_op)\n-            mixer = self.mixer_operator\n-            if isinstance(mixer, OperatorBase):\n-                mixer = cast(OperatorBase, mixer)\n-                # we apply beta parameter in case of operator based mixer.\n-                circuit_op = (mixer * parameters[idx + self._reps]).exp_i().compose(circuit_op)\n-            else:\n-                # mixer as a quantum circuit that can be parameterized\n-                mixer = cast(QuantumCircuit, mixer)\n-                num_params = mixer.num_parameters\n-                # the remaining [self._p:] parameters are used for the mixer,\n-                # there may be multiple layers, so parameters are grouped by layers.\n-                param_values = parameters[\n-                    self._reps + num_params * idx : self._reps + num_params * (idx + 1)\n-                ]\n-                param_dict = dict(zip(mixer.parameters, param_values))\n-                mixer = mixer.assign_parameters(param_dict)\n-                circuit_op = CircuitOp(mixer).compose(circuit_op)\n-\n-        evolution = EvolutionFactory.build(self._cost_operator)\n-        circuit_op = evolution.convert(circuit_op)\n-        return circuit_op.to_circuit()\n+    @property\n+    def operators(self):\n+        \"\"\"The operators that are evolved in this circuit.\n+\n+        Returns:\n+             List[Union[OperatorBase, QuantumCircuit]]: The operators to be evolved (and circuits)\n+                in this ansatz.\n+        \"\"\"\n+        return [self.cost_operator, self.mixer_operator]\n \n",
        "source_code_with_indent": "\n    <DED>def _calculate_parameters(self):\n        <IND>\"\"\"Calculated internal parameters of the circuit to be built.\"\"\"\n        from qiskit.opflow import OperatorBase\n\n        if isinstance(self._mixer, QuantumCircuit):\n            <IND>self._num_parameters = (1 + self._mixer.num_parameters) * self._reps\n            self._bounds = [(None, None)] * self._reps + [\n                (None, None)\n            ] * self._reps * self._mixer.num_parameters\n        <DED>elif isinstance(self._mixer, OperatorBase):\n            <IND>self._num_parameters = 2 * self._reps\n            self._bounds = [(None, None)] * self._reps + [(None, None)] * self._reps\n        <DED>elif self._mixer is None:\n            <IND>self._num_parameters = 2 * self._reps\n            self._bounds = [(None, None)] * self._reps + [(0, 2 * np.pi)] * self._reps\n\n    <DED><DED>def _construct_circuit(self, parameters) -> QuantumCircuit:\n        <IND>\"\"\"Construct a parameterized circuit.\"\"\"\n        if not len(parameters) == self._num_parameters:\n            <IND>raise ValueError(\n                \"Incorrect number of angles: expecting {}, but {} given.\".format(\n                    self._num_parameters, len(parameters)\n                )\n            )\n\n        # local imports to avoid circular imports\n        <DED>from qiskit.opflow import CircuitStateFn\n        from qiskit.opflow import CircuitOp, EvolutionFactory\n        from qiskit.opflow import OperatorBase\n\n        circuit_op = CircuitStateFn(self.initial_state)\n\n        # iterate over layers\n        for idx in range(self._reps):\n            # the first [:self._reps] parameters are used for the cost operator,\n            # so we apply them here\n            <IND>circuit_op = (self._cost_operator * parameters[idx]).exp_i().compose(circuit_op)\n            mixer = self.mixer_operator\n            if isinstance(mixer, OperatorBase):\n                <IND>mixer = cast(OperatorBase, mixer)\n                # we apply beta parameter in case of operator based mixer.\n                circuit_op = (mixer * parameters[idx + self._reps]).exp_i().compose(circuit_op)\n            <DED>else:\n                # mixer as a quantum circuit that can be parameterized\n                <IND>mixer = cast(QuantumCircuit, mixer)\n                num_params = mixer.num_parameters\n                # the remaining [self._p:] parameters are used for the mixer,\n                # there may be multiple layers, so parameters are grouped by layers.\n                param_values = parameters[\n                    self._reps + num_params * idx : self._reps + num_params * (idx + 1)\n                ]\n                param_dict = dict(zip(mixer.parameters, param_values))\n                mixer = mixer.assign_parameters(param_dict)\n                circuit_op = CircuitOp(mixer).compose(circuit_op)\n\n        <DED><DED>evolution = EvolutionFactory.build(self._cost_operator)\n        circuit_op = evolution.convert(circuit_op)\n        return circuit_op.to_circuit()\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n    <DED>@property\n    def operators(self):\n        <IND>\"\"\"The operators that are evolved in this circuit.\n\n        Returns:\n             List[Union[OperatorBase, QuantumCircuit]]: The operators to be evolved (and circuits)\n                in this ansatz.\n        \"\"\"\n        return [self.cost_operator, self.mixer_operator]\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": true,
        "has_suppression": false,
        "source_code": "        self._invalidate()\n\n        num_qubits = cost_operator.num_qubits if cost_operator else None\n        self._reset_registers(num_qubits)\n\n",
        "source_code_len": 144,
        "target_code": "        self._invalidate()\n\n",
        "target_code_len": 28,
        "diff_format": "@@ -237,5 +164,2 @@\n         self._invalidate()\n-\n-        num_qubits = cost_operator.num_qubits if cost_operator else None\n-        self._reset_registers(num_qubits)\n \n",
        "source_code_with_indent": "        self._invalidate()\n\n        num_qubits = cost_operator.num_qubits if cost_operator else None\n        self._reset_registers(num_qubits)\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "        self._invalidate()\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  }
]