[
  {
    "project": "terrencepreilly/darglint",
    "commit": "951a23546ed7f675b4af7bad40a3c173311d3dfb",
    "filename": "darglint/docstring/sphinx.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/terrencepreilly-darglint/darglint/docstring/sphinx.py",
    "file_hunks_size": 4,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "darglint/docstring/sphinx.py:81:4 Inconsistent override [15]: `darglint.docstring.sphinx.Docstring.get_types` overrides method defined in `BaseDocstring` inconsistently. Returned type `Union[None, List[str], str]` is not a subtype of the overridden return `Union[None, List[Optional[str]], str]`.",
    "message": " `darglint.docstring.sphinx.Docstring.get_types` overrides method defined in `BaseDocstring` inconsistently. Returned type `Union[None, List[str], str]` is not a subtype of the overridden return `Union[None, List[Optional[str]], str]`.",
    "rule_id": "Inconsistent override [15]",
    "warning_line_no": 81,
    "warning_line": "    def get_types(self, section):",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "        # type: (Sections) -> Optional[str]\n        if section == Sections.SHORT_DESCRIPTION:\n            pass\n        elif section == Sections.LONG_DESCRIPTION:\n            pass\n        elif section == Sections.ARGUMENTS_SECTION:\n            pass\n        elif section == Sections.RAISES_SECTION:\n            pass\n        elif section == Sections.YIELDS_SECTION:\n            pass\n        elif section == Sections.RETURNS_SECTION:\n            pass\n        elif section == Sections.VARIABLES_SECTION:\n            pass\n        elif section == Sections.NOQAS:\n            pass\n        return None\n\n    def get_types(self, section):\n        # type: (Sections) -> Optional[Union[str, List[str]]]\n        if section == Sections.SHORT_DESCRIPTION:\n            pass\n        elif section == Sections.LONG_DESCRIPTION:\n            pass\n        elif section == Sections.ARGUMENTS_SECTION:\n            pass\n        elif section == Sections.RAISES_SECTION:\n            pass\n        elif section == Sections.YIELDS_SECTION:\n            pass\n",
        "source_code_len": 1026,
        "target_code": "        # type: (Sections) -> Optional[str]\n        return_value = ''\n        nodes = []  # type: Optional[List[Node]]\n\n        if section == Sections.SHORT_DESCRIPTION:\n            nodes = self._lookup.get(NodeType.SHORT_DESCRIPTION, None)\n        elif section == Sections.LONG_DESCRIPTION:\n            nodes = self._lookup.get(NodeType.LONG_DESCRIPTION, None)\n        elif section == Sections.ARGUMENTS_SECTION:\n            nodes = self._lookup.get(NodeType.ARGS_SECTION, None)\n        elif section == Sections.RAISES_SECTION:\n            nodes = self._lookup.get(NodeType.RAISES_SECTION, None)\n        elif section == Sections.YIELDS_SECTION:\n            nodes = self._lookup.get(NodeType.YIELDS_SECTION, None)\n        elif section == Sections.RETURNS_SECTION:\n            nodes = self._lookup.get(NodeType.RETURNS_SECTION, None)\n        elif section == Sections.VARIABLES_SECTION:\n            nodes = self._lookup.get(NodeType.VARIABLES_SECTION, None)\n        elif section == Sections.NOQAS:\n            nodes = self._lookup.get(NodeType.NOQA, None)\n        else:\n            raise Exception(\n                'Unsupported section type, {}'.format(section)\n            )\n\n        if nodes is None:\n            return None\n\n        for node in nodes:\n            return_value += '\\n' + node.reconstruct_string()\n\n        return return_value\n\n    def _get_argument_types(self):\n        # type: () ->  List[Optional[str]]\n        \"\"\"Get a list of types corresponding to arguments.\n\n        Returns:\n            A dictionary matching arguments to types.\n\n        \"\"\"\n        # FIXME: We need to impose a consistent ordering on\n        # both args and the argument types. (Probably alphabetically).\n        argtypes = list()  # type: List[Optional[str]]\n\n        for section in self._lookup[NodeType.ARGS_SECTION]:\n            is_type = section.first_instance(NodeType.TYPE)\n            if not is_type:\n                continue\n            description = section.first_instance(NodeType.ITEM_DEFINITION)\n            if description is None:\n                argtypes.append(description)\n            else:\n                argtypes.append(description.reconstruct_string().strip())\n\n        return argtypes\n\n    def _get_variable_types(self):\n        # FIXME: We need to impose a consistent ordering on\n        # both vars and the variable types. (Probably alphabetically).\n        vartypes = list()  # type: List[Optional[str]]\n\n        for section in self._lookup[NodeType.VARIABLES_SECTION]:\n            is_type = section.first_instance(NodeType.TYPE)\n            if not is_type:\n                continue\n            description = section.first_instance(NodeType.ITEM_DEFINITION)\n            if description is None:\n                vartypes.append(description)\n            else:\n                vartypes.append(description.reconstruct_string().strip())\n\n        return vartypes\n\n    def get_types(self, section):\n        # type: (Sections) -> Optional[Union[str, List[Optional[str]]]]\n        if section == Sections.ARGUMENTS_SECTION:\n            if NodeType.ARGS_SECTION not in self._lookup:\n                return None\n            return self._get_argument_types()\n        elif section == Sections.VARIABLES_SECTION:\n            if NodeType.VARIABLES_SECTION not in self._lookup:\n                return None\n            pass\n",
        "target_code_len": 3322,
        "diff_format": "@@ -62,31 +64,84 @@\n         # type: (Sections) -> Optional[str]\n+        return_value = ''\n+        nodes = []  # type: Optional[List[Node]]\n+\n         if section == Sections.SHORT_DESCRIPTION:\n-            pass\n+            nodes = self._lookup.get(NodeType.SHORT_DESCRIPTION, None)\n         elif section == Sections.LONG_DESCRIPTION:\n-            pass\n+            nodes = self._lookup.get(NodeType.LONG_DESCRIPTION, None)\n         elif section == Sections.ARGUMENTS_SECTION:\n-            pass\n+            nodes = self._lookup.get(NodeType.ARGS_SECTION, None)\n         elif section == Sections.RAISES_SECTION:\n-            pass\n+            nodes = self._lookup.get(NodeType.RAISES_SECTION, None)\n         elif section == Sections.YIELDS_SECTION:\n-            pass\n+            nodes = self._lookup.get(NodeType.YIELDS_SECTION, None)\n         elif section == Sections.RETURNS_SECTION:\n-            pass\n+            nodes = self._lookup.get(NodeType.RETURNS_SECTION, None)\n         elif section == Sections.VARIABLES_SECTION:\n-            pass\n+            nodes = self._lookup.get(NodeType.VARIABLES_SECTION, None)\n         elif section == Sections.NOQAS:\n-            pass\n-        return None\n+            nodes = self._lookup.get(NodeType.NOQA, None)\n+        else:\n+            raise Exception(\n+                'Unsupported section type, {}'.format(section)\n+            )\n+\n+        if nodes is None:\n+            return None\n+\n+        for node in nodes:\n+            return_value += '\\n' + node.reconstruct_string()\n+\n+        return return_value\n+\n+    def _get_argument_types(self):\n+        # type: () ->  List[Optional[str]]\n+        \"\"\"Get a list of types corresponding to arguments.\n+\n+        Returns:\n+            A dictionary matching arguments to types.\n+\n+        \"\"\"\n+        # FIXME: We need to impose a consistent ordering on\n+        # both args and the argument types. (Probably alphabetically).\n+        argtypes = list()  # type: List[Optional[str]]\n+\n+        for section in self._lookup[NodeType.ARGS_SECTION]:\n+            is_type = section.first_instance(NodeType.TYPE)\n+            if not is_type:\n+                continue\n+            description = section.first_instance(NodeType.ITEM_DEFINITION)\n+            if description is None:\n+                argtypes.append(description)\n+            else:\n+                argtypes.append(description.reconstruct_string().strip())\n+\n+        return argtypes\n+\n+    def _get_variable_types(self):\n+        # FIXME: We need to impose a consistent ordering on\n+        # both vars and the variable types. (Probably alphabetically).\n+        vartypes = list()  # type: List[Optional[str]]\n+\n+        for section in self._lookup[NodeType.VARIABLES_SECTION]:\n+            is_type = section.first_instance(NodeType.TYPE)\n+            if not is_type:\n+                continue\n+            description = section.first_instance(NodeType.ITEM_DEFINITION)\n+            if description is None:\n+                vartypes.append(description)\n+            else:\n+                vartypes.append(description.reconstruct_string().strip())\n+\n+        return vartypes\n \n     def get_types(self, section):\n-        # type: (Sections) -> Optional[Union[str, List[str]]]\n-        if section == Sections.SHORT_DESCRIPTION:\n-            pass\n-        elif section == Sections.LONG_DESCRIPTION:\n-            pass\n-        elif section == Sections.ARGUMENTS_SECTION:\n-            pass\n-        elif section == Sections.RAISES_SECTION:\n-            pass\n-        elif section == Sections.YIELDS_SECTION:\n+        # type: (Sections) -> Optional[Union[str, List[Optional[str]]]]\n+        if section == Sections.ARGUMENTS_SECTION:\n+            if NodeType.ARGS_SECTION not in self._lookup:\n+                return None\n+            return self._get_argument_types()\n+        elif section == Sections.VARIABLES_SECTION:\n+            if NodeType.VARIABLES_SECTION not in self._lookup:\n+                return None\n             pass\n",
        "source_code_with_indent": "        # type: (Sections) -> Optional[str]\n        <IND>if section == Sections.SHORT_DESCRIPTION:\n            <IND>pass\n        <DED>elif section == Sections.LONG_DESCRIPTION:\n            <IND>pass\n        <DED>elif section == Sections.ARGUMENTS_SECTION:\n            <IND>pass\n        <DED>elif section == Sections.RAISES_SECTION:\n            <IND>pass\n        <DED>elif section == Sections.YIELDS_SECTION:\n            <IND>pass\n        <DED>elif section == Sections.RETURNS_SECTION:\n            <IND>pass\n        <DED>elif section == Sections.VARIABLES_SECTION:\n            <IND>pass\n        <DED>elif section == Sections.NOQAS:\n            <IND>pass\n        <DED>return None\n\n    <DED>def get_types(self, section):\n        # type: (Sections) -> Optional[Union[str, List[str]]]\n        <IND>if section == Sections.SHORT_DESCRIPTION:\n            <IND>pass\n        <DED>elif section == Sections.LONG_DESCRIPTION:\n            <IND>pass\n        <DED>elif section == Sections.ARGUMENTS_SECTION:\n            <IND>pass\n        <DED>elif section == Sections.RAISES_SECTION:\n            <IND>pass\n        <DED>elif section == Sections.YIELDS_SECTION:\n            <IND>pass\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "        # type: (Sections) -> Optional[str]\n        <IND>return_value = ''\n        nodes = []  # type: Optional[List[Node]]\n\n        if section == Sections.SHORT_DESCRIPTION:\n            <IND>nodes = self._lookup.get(NodeType.SHORT_DESCRIPTION, None)\n        <DED>elif section == Sections.LONG_DESCRIPTION:\n            <IND>nodes = self._lookup.get(NodeType.LONG_DESCRIPTION, None)\n        <DED>elif section == Sections.ARGUMENTS_SECTION:\n            <IND>nodes = self._lookup.get(NodeType.ARGS_SECTION, None)\n        <DED>elif section == Sections.RAISES_SECTION:\n            <IND>nodes = self._lookup.get(NodeType.RAISES_SECTION, None)\n        <DED>elif section == Sections.YIELDS_SECTION:\n            <IND>nodes = self._lookup.get(NodeType.YIELDS_SECTION, None)\n        <DED>elif section == Sections.RETURNS_SECTION:\n            <IND>nodes = self._lookup.get(NodeType.RETURNS_SECTION, None)\n        <DED>elif section == Sections.VARIABLES_SECTION:\n            <IND>nodes = self._lookup.get(NodeType.VARIABLES_SECTION, None)\n        <DED>elif section == Sections.NOQAS:\n            <IND>nodes = self._lookup.get(NodeType.NOQA, None)\n        <DED>else:\n            <IND>raise Exception(\n                'Unsupported section type, {}'.format(section)\n            )\n\n        <DED>if nodes is None:\n            <IND>return None\n\n        <DED>for node in nodes:\n            <IND>return_value += '\\n' + node.reconstruct_string()\n\n        <DED>return return_value\n\n    <DED>def _get_argument_types(self):\n        # type: () ->  List[Optional[str]]\n        <IND>\"\"\"Get a list of types corresponding to arguments.\n\n        Returns:\n            A dictionary matching arguments to types.\n\n        \"\"\"\n        # FIXME: We need to impose a consistent ordering on\n        # both args and the argument types. (Probably alphabetically).\n        argtypes = list()  # type: List[Optional[str]]\n\n        for section in self._lookup[NodeType.ARGS_SECTION]:\n            <IND>is_type = section.first_instance(NodeType.TYPE)\n            if not is_type:\n                <IND>continue\n            <DED>description = section.first_instance(NodeType.ITEM_DEFINITION)\n            if description is None:\n                <IND>argtypes.append(description)\n            <DED>else:\n                <IND>argtypes.append(description.reconstruct_string().strip())\n\n        <DED><DED>return argtypes\n\n    <DED>def _get_variable_types(self):\n        # FIXME: We need to impose a consistent ordering on\n        # both vars and the variable types. (Probably alphabetically).\n        <IND>vartypes = list()  # type: List[Optional[str]]\n\n        for section in self._lookup[NodeType.VARIABLES_SECTION]:\n            <IND>is_type = section.first_instance(NodeType.TYPE)\n            if not is_type:\n                <IND>continue\n            <DED>description = section.first_instance(NodeType.ITEM_DEFINITION)\n            if description is None:\n                <IND>vartypes.append(description)\n            <DED>else:\n                <IND>vartypes.append(description.reconstruct_string().strip())\n\n        <DED><DED>return vartypes\n\n    <DED>def get_types(self, section):\n        # type: (Sections) -> Optional[Union[str, List[Optional[str]]]]\n        <IND>if section == Sections.ARGUMENTS_SECTION:\n            <IND>if NodeType.ARGS_SECTION not in self._lookup:\n                <IND>return None\n            <DED>return self._get_argument_types()\n        <DED>elif section == Sections.VARIABLES_SECTION:\n            <IND>if NodeType.VARIABLES_SECTION not in self._lookup:\n                <IND>return None\n            <DED>pass\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  }
]