[
  {
    "project": "samuelcolvin/pydantic",
    "commit": "db697cc7998e758f9532f702d5bf245067796bb8",
    "filename": "pydantic/main.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/samuelcolvin-pydantic/pydantic/main.py",
    "file_hunks_size": 7,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "pydantic/main.py:908:24 Incompatible parameter type [6]: Expected `AbstractSet[Optional[str]]` for 1st positional only parameter to call `set.__isub__` but got `typing.Set[Union[int, str]]`.",
    "message": " Expected `AbstractSet[Optional[str]]` for 1st positional only parameter to call `set.__isub__` but got `typing.Set[Union[int, str]]`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 908,
    "warning_line": "                keys -= {k for k, v in exclude.items() if v is ...}"
  },
  {
    "project": "samuelcolvin/pydantic",
    "commit": "db697cc7998e758f9532f702d5bf245067796bb8",
    "filename": "pydantic/main.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/samuelcolvin-pydantic/pydantic/main.py",
    "file_hunks_size": 7,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "pydantic/main.py:910:24 Incompatible parameter type [6]: Expected `AbstractSet[Optional[str]]` for 1st positional only parameter to call `set.__isub__` but got `AbstractSet[Union[int, str]]`.",
    "message": " Expected `AbstractSet[Optional[str]]` for 1st positional only parameter to call `set.__isub__` but got `AbstractSet[Union[int, str]]`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 910,
    "warning_line": "                keys -= exclude"
  },
  {
    "project": "samuelcolvin/pydantic",
    "commit": "db697cc7998e758f9532f702d5bf245067796bb8",
    "filename": "pydantic/utils.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/samuelcolvin-pydantic/pydantic/utils.py",
    "file_hunks_size": 3,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "pydantic/utils.py:543:31 Unsupported operand [58]: `+` is not supported for operand types `int` and `Union[int, str]`.",
    "message": " `+` is not supported for operand types `int` and `Union[int, str]`.",
    "rule_id": "Unsupported operand [58]",
    "warning_line_no": 543,
    "warning_line": "            return {v_length + i if i < 0 else i for i in items}",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    def __init__(self, value: Any, items: Union['AbstractSetIntStr', 'MappingIntStrAny']) -> None:\n        if TYPE_CHECKING:\n            self._items: Union['AbstractSetIntStr', 'MappingIntStrAny']\n            self._type: Type[Union[set, dict]]  # type: ignore\n\n        # For further type checks speed-up\n        if isinstance(items, Mapping):\n            self._type = dict\n        elif isinstance(items, AbstractSet):\n            self._type = set\n        else:\n            raise TypeError(f'Unexpected type of exclude value {items.__class__}')\n\n        if isinstance(value, (list, tuple)):\n            items = self._normalize_indexes(items, len(value))\n\n        self._items = items\n\n    @no_type_check\n    def is_excluded(self, item: Any) -> bool:\n        \"\"\"\n        Check if item is fully excluded\n        (value considered excluded if self._type is set and item contained in self._items\n         or self._type is dict and self._items.get(item) is ...\n\n        :param item: key or index of a value\n        \"\"\"\n        if self._type is set:\n            return item in self._items\n        return self._items.get(item) is ...\n\n    @no_type_check\n    def is_included(self, item: Any) -> bool:\n        \"\"\"\n        Check if value is contained in self._items\n\n        :param item: key or index of value\n        \"\"\"\n        return item in self._items\n\n    @no_type_check\n    def for_element(self, e: 'IntStr') -> Optional[Union['AbstractSetIntStr', 'MappingIntStrAny']]:\n        \"\"\"\n        :param e: key or index of element on value\n        :return: raw values for elemet if self._items is dict and contain needed element\n        \"\"\"\n\n        if self._type is dict:\n            item = self._items.get(e)\n            return item if item is not ... else None\n        return None\n\n    @no_type_check\n    def _normalize_indexes(\n        self, items: Union['AbstractSetIntStr', 'MappingIntStrAny'], v_length: int\n    ) -> Union['AbstractSetIntStr', 'DictIntStrAny']:\n        \"\"\"\n        :param items: dict or set of indexes which will be normalized\n        :param v_length: length of sequence indexes of which will be\n\n        >>> self._normalize_indexes({0, -2, -1}, 4)\n        {0, 2, 3}\n        >>> self._normalize_indexes({'__all__'}, 4)\n        {0, 1, 2, 3}\n        \"\"\"\n        if any(not isinstance(i, int) and i != '__all__' for i in items):\n            raise TypeError(\n                'Excluding fields from a sequence of sub-models or dicts must be performed index-wise: '\n                'expected integer keys or keyword \"__all__\"'\n            )\n        if self._type is set:\n            if '__all__' in items:\n                if items != {'__all__'}:\n                    raise ValueError('set with keyword \"__all__\" must not contain other elements')\n                return {i for i in range(v_length)}\n            return {v_length + i if i < 0 else i for i in items}\n        else:\n            all_items = items.get('__all__')\n            for i, v in items.items():\n                if not (isinstance(v, Mapping) or isinstance(v, AbstractSet) or v is ...):\n                    raise TypeError(f'Unexpected type of exclude value for index \"{i}\" {v.__class__}')\n            normalized_items = {v_length + i if i < 0 else i: v for i, v in items.items() if i != '__all__'}\n            if all_items:\n                default: Type[Union[Set[Any], Dict[Any, Any]]]\n                if isinstance(all_items, Mapping):\n                    default = dict\n                elif isinstance(all_items, AbstractSet):\n                    default = set\n                else:\n                    for i in range(v_length):\n                        normalized_items.setdefault(i, ...)\n                    return normalized_items\n                for i in range(v_length):\n                    normalized_item = normalized_items.setdefault(i, default())\n                    if normalized_item is not ...:\n                        normalized_items[i] = update_normalized_all(normalized_item, all_items)\n            return normalized_items\n\n",
        "source_code_len": 4014,
        "target_code": "    def __init__(self, value: Any, items: Union['AbstractSetIntStr', 'MappingIntStrAny']) -> None:\n        items = self._coerce_items(items)\n\n        if isinstance(value, (list, tuple)):\n            items = self._normalize_indexes(items, len(value))\n\n        self._items: 'MappingIntStrAny' = items\n\n    def is_excluded(self, item: Any) -> bool:\n        \"\"\"\n        Check if item is fully excluded.\n\n        :param item: key or index of a value\n        \"\"\"\n        return self.is_true(self._items.get(item))\n\n    def is_included(self, item: Any) -> bool:\n        \"\"\"\n        Check if value is contained in self._items\n\n        :param item: key or index of value\n        \"\"\"\n        return item in self._items\n\n    def for_element(self, e: 'IntStr') -> Optional[Union['AbstractSetIntStr', 'MappingIntStrAny']]:\n        \"\"\"\n        :param e: key or index of element on value\n        :return: raw values for elemet if self._items is dict and contain needed element\n        \"\"\"\n\n        item = self._items.get(e)\n        return item if not self.is_true(item) else None\n\n    def _normalize_indexes(self, items: 'MappingIntStrAny', v_length: int) -> 'DictIntStrAny':\n        \"\"\"\n        :param items: dict or set of indexes which will be normalized\n        :param v_length: length of sequence indexes of which will be\n\n        >>> self._normalize_indexes({0: True, -2: True, -1: True}, 4)\n        {0: True, 2: True, 3: True}\n        >>> self._normalize_indexes({'__all__': True}, 4)\n        {0: True, 1: True, 2: True, 3: True}\n        \"\"\"\n\n        normalized_items: 'DictIntStrAny' = {}\n        all_items = None\n        for i, v in items.items():\n            if not (isinstance(v, Mapping) or isinstance(v, AbstractSet) or self.is_true(v)):\n                raise TypeError(f'Unexpected type of exclude value for index \"{i}\" {v.__class__}')\n            if i == '__all__':\n                all_items = self._coerce_value(v)\n                continue\n            if not isinstance(i, int):\n                raise TypeError(\n                    'Excluding fields from a sequence of sub-models or dicts must be performed index-wise: '\n                    'expected integer keys or keyword \"__all__\"'\n                )\n            normalized_i = v_length + i if i < 0 else i\n            normalized_items[normalized_i] = self.merge(v, normalized_items.get(normalized_i))\n\n        if not all_items:\n            return normalized_items\n        if self.is_true(all_items):\n            for i in range(v_length):\n                normalized_items.setdefault(i, ...)\n            return normalized_items\n        for i in range(v_length):\n            normalized_item = normalized_items.setdefault(i, {})\n            if not self.is_true(normalized_item):\n                normalized_items[i] = self.merge(all_items, normalized_item)\n        return normalized_items\n\n    @classmethod\n    def merge(cls, base: Any, override: Any, intersect: bool = False) -> Any:\n        \"\"\"\n        Merge a ``base`` item with an ``override`` item.\n\n        Both ``base`` and ``override`` are converted to dictionaries if possible.\n        Sets are converted to dictionaries with the sets entries as keys and\n        Ellipsis as values.\n\n        Each key-value pair existing in ``base`` is merged with ``override``,\n        while the rest of the key-value pairs are updated recursively with this function.\n\n        Merging takes place based on the \"union\" of keys if ``intersect`` is\n        set to ``False`` (default) and on the intersection of keys if\n        ``intersect`` is set to ``True``.\n        \"\"\"\n        override = cls._coerce_value(override)\n        base = cls._coerce_value(base)\n        if override is None:\n            return base\n        if cls.is_true(base) or base is None:\n            return override\n        if cls.is_true(override):\n            return base if intersect else override\n\n        # intersection or union of keys while preserving ordering:\n        if intersect:\n            merge_keys = [k for k in base if k in override] + [k for k in override if k in base]\n        else:\n            merge_keys = list(base) + [k for k in override if k not in base]\n\n        merged: 'DictIntStrAny' = {}\n        for k in merge_keys:\n            merged_item = cls.merge(base.get(k), override.get(k), intersect=intersect)\n            if merged_item is not None:\n                merged[k] = merged_item\n\n        return merged\n\n    @staticmethod\n    def _coerce_items(items: Union['AbstractSetIntStr', 'MappingIntStrAny']) -> 'MappingIntStrAny':\n        if isinstance(items, Mapping):\n            pass\n        elif isinstance(items, AbstractSet):\n            items = dict.fromkeys(items, ...)\n        else:\n            raise TypeError(f'Unexpected type of exclude value {items.__class__}')\n        return items\n\n    @classmethod\n    def _coerce_value(cls, value: Any) -> Any:\n        if value is None or cls.is_true(value):\n            return value\n        return cls._coerce_items(value)\n\n    @staticmethod\n    def is_true(v: Any) -> bool:\n        return v is True or v is ...\n\n",
        "target_code_len": 5048,
        "diff_format": "@@ -468,98 +424,131 @@\n     def __init__(self, value: Any, items: Union['AbstractSetIntStr', 'MappingIntStrAny']) -> None:\n-        if TYPE_CHECKING:\n-            self._items: Union['AbstractSetIntStr', 'MappingIntStrAny']\n-            self._type: Type[Union[set, dict]]  # type: ignore\n-\n-        # For further type checks speed-up\n+        items = self._coerce_items(items)\n+\n+        if isinstance(value, (list, tuple)):\n+            items = self._normalize_indexes(items, len(value))\n+\n+        self._items: 'MappingIntStrAny' = items\n+\n+    def is_excluded(self, item: Any) -> bool:\n+        \"\"\"\n+        Check if item is fully excluded.\n+\n+        :param item: key or index of a value\n+        \"\"\"\n+        return self.is_true(self._items.get(item))\n+\n+    def is_included(self, item: Any) -> bool:\n+        \"\"\"\n+        Check if value is contained in self._items\n+\n+        :param item: key or index of value\n+        \"\"\"\n+        return item in self._items\n+\n+    def for_element(self, e: 'IntStr') -> Optional[Union['AbstractSetIntStr', 'MappingIntStrAny']]:\n+        \"\"\"\n+        :param e: key or index of element on value\n+        :return: raw values for elemet if self._items is dict and contain needed element\n+        \"\"\"\n+\n+        item = self._items.get(e)\n+        return item if not self.is_true(item) else None\n+\n+    def _normalize_indexes(self, items: 'MappingIntStrAny', v_length: int) -> 'DictIntStrAny':\n+        \"\"\"\n+        :param items: dict or set of indexes which will be normalized\n+        :param v_length: length of sequence indexes of which will be\n+\n+        >>> self._normalize_indexes({0: True, -2: True, -1: True}, 4)\n+        {0: True, 2: True, 3: True}\n+        >>> self._normalize_indexes({'__all__': True}, 4)\n+        {0: True, 1: True, 2: True, 3: True}\n+        \"\"\"\n+\n+        normalized_items: 'DictIntStrAny' = {}\n+        all_items = None\n+        for i, v in items.items():\n+            if not (isinstance(v, Mapping) or isinstance(v, AbstractSet) or self.is_true(v)):\n+                raise TypeError(f'Unexpected type of exclude value for index \"{i}\" {v.__class__}')\n+            if i == '__all__':\n+                all_items = self._coerce_value(v)\n+                continue\n+            if not isinstance(i, int):\n+                raise TypeError(\n+                    'Excluding fields from a sequence of sub-models or dicts must be performed index-wise: '\n+                    'expected integer keys or keyword \"__all__\"'\n+                )\n+            normalized_i = v_length + i if i < 0 else i\n+            normalized_items[normalized_i] = self.merge(v, normalized_items.get(normalized_i))\n+\n+        if not all_items:\n+            return normalized_items\n+        if self.is_true(all_items):\n+            for i in range(v_length):\n+                normalized_items.setdefault(i, ...)\n+            return normalized_items\n+        for i in range(v_length):\n+            normalized_item = normalized_items.setdefault(i, {})\n+            if not self.is_true(normalized_item):\n+                normalized_items[i] = self.merge(all_items, normalized_item)\n+        return normalized_items\n+\n+    @classmethod\n+    def merge(cls, base: Any, override: Any, intersect: bool = False) -> Any:\n+        \"\"\"\n+        Merge a ``base`` item with an ``override`` item.\n+\n+        Both ``base`` and ``override`` are converted to dictionaries if possible.\n+        Sets are converted to dictionaries with the sets entries as keys and\n+        Ellipsis as values.\n+\n+        Each key-value pair existing in ``base`` is merged with ``override``,\n+        while the rest of the key-value pairs are updated recursively with this function.\n+\n+        Merging takes place based on the \"union\" of keys if ``intersect`` is\n+        set to ``False`` (default) and on the intersection of keys if\n+        ``intersect`` is set to ``True``.\n+        \"\"\"\n+        override = cls._coerce_value(override)\n+        base = cls._coerce_value(base)\n+        if override is None:\n+            return base\n+        if cls.is_true(base) or base is None:\n+            return override\n+        if cls.is_true(override):\n+            return base if intersect else override\n+\n+        # intersection or union of keys while preserving ordering:\n+        if intersect:\n+            merge_keys = [k for k in base if k in override] + [k for k in override if k in base]\n+        else:\n+            merge_keys = list(base) + [k for k in override if k not in base]\n+\n+        merged: 'DictIntStrAny' = {}\n+        for k in merge_keys:\n+            merged_item = cls.merge(base.get(k), override.get(k), intersect=intersect)\n+            if merged_item is not None:\n+                merged[k] = merged_item\n+\n+        return merged\n+\n+    @staticmethod\n+    def _coerce_items(items: Union['AbstractSetIntStr', 'MappingIntStrAny']) -> 'MappingIntStrAny':\n         if isinstance(items, Mapping):\n-            self._type = dict\n+            pass\n         elif isinstance(items, AbstractSet):\n-            self._type = set\n+            items = dict.fromkeys(items, ...)\n         else:\n             raise TypeError(f'Unexpected type of exclude value {items.__class__}')\n-\n-        if isinstance(value, (list, tuple)):\n-            items = self._normalize_indexes(items, len(value))\n-\n-        self._items = items\n-\n-    @no_type_check\n-    def is_excluded(self, item: Any) -> bool:\n-        \"\"\"\n-        Check if item is fully excluded\n-        (value considered excluded if self._type is set and item contained in self._items\n-         or self._type is dict and self._items.get(item) is ...\n-\n-        :param item: key or index of a value\n-        \"\"\"\n-        if self._type is set:\n-            return item in self._items\n-        return self._items.get(item) is ...\n-\n-    @no_type_check\n-    def is_included(self, item: Any) -> bool:\n-        \"\"\"\n-        Check if value is contained in self._items\n-\n-        :param item: key or index of value\n-        \"\"\"\n-        return item in self._items\n-\n-    @no_type_check\n-    def for_element(self, e: 'IntStr') -> Optional[Union['AbstractSetIntStr', 'MappingIntStrAny']]:\n-        \"\"\"\n-        :param e: key or index of element on value\n-        :return: raw values for elemet if self._items is dict and contain needed element\n-        \"\"\"\n-\n-        if self._type is dict:\n-            item = self._items.get(e)\n-            return item if item is not ... else None\n-        return None\n-\n-    @no_type_check\n-    def _normalize_indexes(\n-        self, items: Union['AbstractSetIntStr', 'MappingIntStrAny'], v_length: int\n-    ) -> Union['AbstractSetIntStr', 'DictIntStrAny']:\n-        \"\"\"\n-        :param items: dict or set of indexes which will be normalized\n-        :param v_length: length of sequence indexes of which will be\n-\n-        >>> self._normalize_indexes({0, -2, -1}, 4)\n-        {0, 2, 3}\n-        >>> self._normalize_indexes({'__all__'}, 4)\n-        {0, 1, 2, 3}\n-        \"\"\"\n-        if any(not isinstance(i, int) and i != '__all__' for i in items):\n-            raise TypeError(\n-                'Excluding fields from a sequence of sub-models or dicts must be performed index-wise: '\n-                'expected integer keys or keyword \"__all__\"'\n-            )\n-        if self._type is set:\n-            if '__all__' in items:\n-                if items != {'__all__'}:\n-                    raise ValueError('set with keyword \"__all__\" must not contain other elements')\n-                return {i for i in range(v_length)}\n-            return {v_length + i if i < 0 else i for i in items}\n-        else:\n-            all_items = items.get('__all__')\n-            for i, v in items.items():\n-                if not (isinstance(v, Mapping) or isinstance(v, AbstractSet) or v is ...):\n-                    raise TypeError(f'Unexpected type of exclude value for index \"{i}\" {v.__class__}')\n-            normalized_items = {v_length + i if i < 0 else i: v for i, v in items.items() if i != '__all__'}\n-            if all_items:\n-                default: Type[Union[Set[Any], Dict[Any, Any]]]\n-                if isinstance(all_items, Mapping):\n-                    default = dict\n-                elif isinstance(all_items, AbstractSet):\n-                    default = set\n-                else:\n-                    for i in range(v_length):\n-                        normalized_items.setdefault(i, ...)\n-                    return normalized_items\n-                for i in range(v_length):\n-                    normalized_item = normalized_items.setdefault(i, default())\n-                    if normalized_item is not ...:\n-                        normalized_items[i] = update_normalized_all(normalized_item, all_items)\n-            return normalized_items\n+        return items\n+\n+    @classmethod\n+    def _coerce_value(cls, value: Any) -> Any:\n+        if value is None or cls.is_true(value):\n+            return value\n+        return cls._coerce_items(value)\n+\n+    @staticmethod\n+    def is_true(v: Any) -> bool:\n+        return v is True or v is ...\n \n",
        "source_code_with_indent": "    def __init__(self, value: Any, items: Union['AbstractSetIntStr', 'MappingIntStrAny']) -> None:\n        <IND>if TYPE_CHECKING:\n            <IND>self._items: Union['AbstractSetIntStr', 'MappingIntStrAny']\n            self._type: Type[Union[set, dict]]  # type: ignore\n\n        # For further type checks speed-up\n        <DED>if isinstance(items, Mapping):\n            <IND>self._type = dict\n        <DED>elif isinstance(items, AbstractSet):\n            <IND>self._type = set\n        <DED>else:\n            <IND>raise TypeError(f'Unexpected type of exclude value {items.__class__}')\n\n        <DED>if isinstance(value, (list, tuple)):\n            <IND>items = self._normalize_indexes(items, len(value))\n\n        <DED>self._items = items\n\n    <DED>@no_type_check\n    def is_excluded(self, item: Any) -> bool:\n        <IND>\"\"\"\n        Check if item is fully excluded\n        (value considered excluded if self._type is set and item contained in self._items\n         or self._type is dict and self._items.get(item) is ...\n\n        :param item: key or index of a value\n        \"\"\"\n        if self._type is set:\n            <IND>return item in self._items\n        <DED>return self._items.get(item) is ...\n\n    <DED>@no_type_check\n    def is_included(self, item: Any) -> bool:\n        <IND>\"\"\"\n        Check if value is contained in self._items\n\n        :param item: key or index of value\n        \"\"\"\n        return item in self._items\n\n    <DED>@no_type_check\n    def for_element(self, e: 'IntStr') -> Optional[Union['AbstractSetIntStr', 'MappingIntStrAny']]:\n        <IND>\"\"\"\n        :param e: key or index of element on value\n        :return: raw values for elemet if self._items is dict and contain needed element\n        \"\"\"\n\n        if self._type is dict:\n            <IND>item = self._items.get(e)\n            return item if item is not ... else None\n        <DED>return None\n\n    <DED>@no_type_check\n    def _normalize_indexes(\n        self, items: Union['AbstractSetIntStr', 'MappingIntStrAny'], v_length: int\n    ) -> Union['AbstractSetIntStr', 'DictIntStrAny']:\n        <IND>\"\"\"\n        :param items: dict or set of indexes which will be normalized\n        :param v_length: length of sequence indexes of which will be\n\n        >>> self._normalize_indexes({0, -2, -1}, 4)\n        {0, 2, 3}\n        >>> self._normalize_indexes({'__all__'}, 4)\n        {0, 1, 2, 3}\n        \"\"\"\n        if any(not isinstance(i, int) and i != '__all__' for i in items):\n            <IND>raise TypeError(\n                'Excluding fields from a sequence of sub-models or dicts must be performed index-wise: '\n                'expected integer keys or keyword \"__all__\"'\n            )\n        <DED>if self._type is set:\n            <IND>if '__all__' in items:\n                <IND>if items != {'__all__'}:\n                    <IND>raise ValueError('set with keyword \"__all__\" must not contain other elements')\n                <DED>return {i for i in range(v_length)}\n            <DED>return {v_length + i if i < 0 else i for i in items}\n        <DED>else:\n            <IND>all_items = items.get('__all__')\n            for i, v in items.items():\n                <IND>if not (isinstance(v, Mapping) or isinstance(v, AbstractSet) or v is ...):\n                    <IND>raise TypeError(f'Unexpected type of exclude value for index \"{i}\" {v.__class__}')\n            <DED><DED>normalized_items = {v_length + i if i < 0 else i: v for i, v in items.items() if i != '__all__'}\n            if all_items:\n                <IND>default: Type[Union[Set[Any], Dict[Any, Any]]]\n                if isinstance(all_items, Mapping):\n                    <IND>default = dict\n                <DED>elif isinstance(all_items, AbstractSet):\n                    <IND>default = set\n                <DED>else:\n                    <IND>for i in range(v_length):\n                        <IND>normalized_items.setdefault(i, ...)\n                    <DED>return normalized_items\n                <DED>for i in range(v_length):\n                    <IND>normalized_item = normalized_items.setdefault(i, default())\n                    if normalized_item is not ...:\n                        <IND>normalized_items[i] = update_normalized_all(normalized_item, all_items)\n            <DED><DED><DED>return normalized_items\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    def __init__(self, value: Any, items: Union['AbstractSetIntStr', 'MappingIntStrAny']) -> None:\n        <IND>items = self._coerce_items(items)\n\n        if isinstance(value, (list, tuple)):\n            <IND>items = self._normalize_indexes(items, len(value))\n\n        <DED>self._items: 'MappingIntStrAny' = items\n\n    <DED>def is_excluded(self, item: Any) -> bool:\n        <IND>\"\"\"\n        Check if item is fully excluded.\n\n        :param item: key or index of a value\n        \"\"\"\n        return self.is_true(self._items.get(item))\n\n    <DED>def is_included(self, item: Any) -> bool:\n        <IND>\"\"\"\n        Check if value is contained in self._items\n\n        :param item: key or index of value\n        \"\"\"\n        return item in self._items\n\n    <DED>def for_element(self, e: 'IntStr') -> Optional[Union['AbstractSetIntStr', 'MappingIntStrAny']]:\n        <IND>\"\"\"\n        :param e: key or index of element on value\n        :return: raw values for elemet if self._items is dict and contain needed element\n        \"\"\"\n\n        item = self._items.get(e)\n        return item if not self.is_true(item) else None\n\n    <DED>def _normalize_indexes(self, items: 'MappingIntStrAny', v_length: int) -> 'DictIntStrAny':\n        <IND>\"\"\"\n        :param items: dict or set of indexes which will be normalized\n        :param v_length: length of sequence indexes of which will be\n\n        >>> self._normalize_indexes({0: True, -2: True, -1: True}, 4)\n        {0: True, 2: True, 3: True}\n        >>> self._normalize_indexes({'__all__': True}, 4)\n        {0: True, 1: True, 2: True, 3: True}\n        \"\"\"\n\n        normalized_items: 'DictIntStrAny' = {}\n        all_items = None\n        for i, v in items.items():\n            <IND>if not (isinstance(v, Mapping) or isinstance(v, AbstractSet) or self.is_true(v)):\n                <IND>raise TypeError(f'Unexpected type of exclude value for index \"{i}\" {v.__class__}')\n            <DED>if i == '__all__':\n                <IND>all_items = self._coerce_value(v)\n                continue\n            <DED>if not isinstance(i, int):\n                <IND>raise TypeError(\n                    'Excluding fields from a sequence of sub-models or dicts must be performed index-wise: '\n                    'expected integer keys or keyword \"__all__\"'\n                )\n            <DED>normalized_i = v_length + i if i < 0 else i\n            normalized_items[normalized_i] = self.merge(v, normalized_items.get(normalized_i))\n\n        <DED>if not all_items:\n            <IND>return normalized_items\n        <DED>if self.is_true(all_items):\n            <IND>for i in range(v_length):\n                <IND>normalized_items.setdefault(i, ...)\n            <DED>return normalized_items\n        <DED>for i in range(v_length):\n            <IND>normalized_item = normalized_items.setdefault(i, {})\n            if not self.is_true(normalized_item):\n                <IND>normalized_items[i] = self.merge(all_items, normalized_item)\n        <DED><DED>return normalized_items\n\n    <DED>@classmethod\n    def merge(cls, base: Any, override: Any, intersect: bool = False) -> Any:\n        <IND>\"\"\"\n        Merge a ``base`` item with an ``override`` item.\n\n        Both ``base`` and ``override`` are converted to dictionaries if possible.\n        Sets are converted to dictionaries with the sets entries as keys and\n        Ellipsis as values.\n\n        Each key-value pair existing in ``base`` is merged with ``override``,\n        while the rest of the key-value pairs are updated recursively with this function.\n\n        Merging takes place based on the \"union\" of keys if ``intersect`` is\n        set to ``False`` (default) and on the intersection of keys if\n        ``intersect`` is set to ``True``.\n        \"\"\"\n        override = cls._coerce_value(override)\n        base = cls._coerce_value(base)\n        if override is None:\n            <IND>return base\n        <DED>if cls.is_true(base) or base is None:\n            <IND>return override\n        <DED>if cls.is_true(override):\n            <IND>return base if intersect else override\n\n        # intersection or union of keys while preserving ordering:\n        <DED>if intersect:\n            <IND>merge_keys = [k for k in base if k in override] + [k for k in override if k in base]\n        <DED>else:\n            <IND>merge_keys = list(base) + [k for k in override if k not in base]\n\n        <DED>merged: 'DictIntStrAny' = {}\n        for k in merge_keys:\n            <IND>merged_item = cls.merge(base.get(k), override.get(k), intersect=intersect)\n            if merged_item is not None:\n                <IND>merged[k] = merged_item\n\n        <DED><DED>return merged\n\n    <DED>@staticmethod\n    def _coerce_items(items: Union['AbstractSetIntStr', 'MappingIntStrAny']) -> 'MappingIntStrAny':\n        <IND>if isinstance(items, Mapping):\n            <IND>pass\n        <DED>elif isinstance(items, AbstractSet):\n            <IND>items = dict.fromkeys(items, ...)\n        <DED>else:\n            <IND>raise TypeError(f'Unexpected type of exclude value {items.__class__}')\n        <DED>return items\n\n    <DED>@classmethod\n    def _coerce_value(cls, value: Any) -> Any:\n        <IND>if value is None or cls.is_true(value):\n            <IND>return value\n        <DED>return cls._coerce_items(value)\n\n    <DED>@staticmethod\n    def is_true(v: Any) -> bool:\n        <IND>return v is True or v is ...\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "samuelcolvin/pydantic",
    "commit": "db697cc7998e758f9532f702d5bf245067796bb8",
    "filename": "pydantic/utils.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/samuelcolvin-pydantic/pydantic/utils.py",
    "file_hunks_size": 3,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "pydantic/utils.py:543:36 Unsupported operand [58]: `<` is not supported for operand types `Union[int, str]` and `int`.",
    "message": " `<` is not supported for operand types `Union[int, str]` and `int`.",
    "rule_id": "Unsupported operand [58]",
    "warning_line_no": 543,
    "warning_line": "            return {v_length + i if i < 0 else i for i in items}",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    def __init__(self, value: Any, items: Union['AbstractSetIntStr', 'MappingIntStrAny']) -> None:\n        if TYPE_CHECKING:\n            self._items: Union['AbstractSetIntStr', 'MappingIntStrAny']\n            self._type: Type[Union[set, dict]]  # type: ignore\n\n        # For further type checks speed-up\n        if isinstance(items, Mapping):\n            self._type = dict\n        elif isinstance(items, AbstractSet):\n            self._type = set\n        else:\n            raise TypeError(f'Unexpected type of exclude value {items.__class__}')\n\n        if isinstance(value, (list, tuple)):\n            items = self._normalize_indexes(items, len(value))\n\n        self._items = items\n\n    @no_type_check\n    def is_excluded(self, item: Any) -> bool:\n        \"\"\"\n        Check if item is fully excluded\n        (value considered excluded if self._type is set and item contained in self._items\n         or self._type is dict and self._items.get(item) is ...\n\n        :param item: key or index of a value\n        \"\"\"\n        if self._type is set:\n            return item in self._items\n        return self._items.get(item) is ...\n\n    @no_type_check\n    def is_included(self, item: Any) -> bool:\n        \"\"\"\n        Check if value is contained in self._items\n\n        :param item: key or index of value\n        \"\"\"\n        return item in self._items\n\n    @no_type_check\n    def for_element(self, e: 'IntStr') -> Optional[Union['AbstractSetIntStr', 'MappingIntStrAny']]:\n        \"\"\"\n        :param e: key or index of element on value\n        :return: raw values for elemet if self._items is dict and contain needed element\n        \"\"\"\n\n        if self._type is dict:\n            item = self._items.get(e)\n            return item if item is not ... else None\n        return None\n\n    @no_type_check\n    def _normalize_indexes(\n        self, items: Union['AbstractSetIntStr', 'MappingIntStrAny'], v_length: int\n    ) -> Union['AbstractSetIntStr', 'DictIntStrAny']:\n        \"\"\"\n        :param items: dict or set of indexes which will be normalized\n        :param v_length: length of sequence indexes of which will be\n\n        >>> self._normalize_indexes({0, -2, -1}, 4)\n        {0, 2, 3}\n        >>> self._normalize_indexes({'__all__'}, 4)\n        {0, 1, 2, 3}\n        \"\"\"\n        if any(not isinstance(i, int) and i != '__all__' for i in items):\n            raise TypeError(\n                'Excluding fields from a sequence of sub-models or dicts must be performed index-wise: '\n                'expected integer keys or keyword \"__all__\"'\n            )\n        if self._type is set:\n            if '__all__' in items:\n                if items != {'__all__'}:\n                    raise ValueError('set with keyword \"__all__\" must not contain other elements')\n                return {i for i in range(v_length)}\n            return {v_length + i if i < 0 else i for i in items}\n        else:\n            all_items = items.get('__all__')\n            for i, v in items.items():\n                if not (isinstance(v, Mapping) or isinstance(v, AbstractSet) or v is ...):\n                    raise TypeError(f'Unexpected type of exclude value for index \"{i}\" {v.__class__}')\n            normalized_items = {v_length + i if i < 0 else i: v for i, v in items.items() if i != '__all__'}\n            if all_items:\n                default: Type[Union[Set[Any], Dict[Any, Any]]]\n                if isinstance(all_items, Mapping):\n                    default = dict\n                elif isinstance(all_items, AbstractSet):\n                    default = set\n                else:\n                    for i in range(v_length):\n                        normalized_items.setdefault(i, ...)\n                    return normalized_items\n                for i in range(v_length):\n                    normalized_item = normalized_items.setdefault(i, default())\n                    if normalized_item is not ...:\n                        normalized_items[i] = update_normalized_all(normalized_item, all_items)\n            return normalized_items\n\n",
        "source_code_len": 4014,
        "target_code": "    def __init__(self, value: Any, items: Union['AbstractSetIntStr', 'MappingIntStrAny']) -> None:\n        items = self._coerce_items(items)\n\n        if isinstance(value, (list, tuple)):\n            items = self._normalize_indexes(items, len(value))\n\n        self._items: 'MappingIntStrAny' = items\n\n    def is_excluded(self, item: Any) -> bool:\n        \"\"\"\n        Check if item is fully excluded.\n\n        :param item: key or index of a value\n        \"\"\"\n        return self.is_true(self._items.get(item))\n\n    def is_included(self, item: Any) -> bool:\n        \"\"\"\n        Check if value is contained in self._items\n\n        :param item: key or index of value\n        \"\"\"\n        return item in self._items\n\n    def for_element(self, e: 'IntStr') -> Optional[Union['AbstractSetIntStr', 'MappingIntStrAny']]:\n        \"\"\"\n        :param e: key or index of element on value\n        :return: raw values for elemet if self._items is dict and contain needed element\n        \"\"\"\n\n        item = self._items.get(e)\n        return item if not self.is_true(item) else None\n\n    def _normalize_indexes(self, items: 'MappingIntStrAny', v_length: int) -> 'DictIntStrAny':\n        \"\"\"\n        :param items: dict or set of indexes which will be normalized\n        :param v_length: length of sequence indexes of which will be\n\n        >>> self._normalize_indexes({0: True, -2: True, -1: True}, 4)\n        {0: True, 2: True, 3: True}\n        >>> self._normalize_indexes({'__all__': True}, 4)\n        {0: True, 1: True, 2: True, 3: True}\n        \"\"\"\n\n        normalized_items: 'DictIntStrAny' = {}\n        all_items = None\n        for i, v in items.items():\n            if not (isinstance(v, Mapping) or isinstance(v, AbstractSet) or self.is_true(v)):\n                raise TypeError(f'Unexpected type of exclude value for index \"{i}\" {v.__class__}')\n            if i == '__all__':\n                all_items = self._coerce_value(v)\n                continue\n            if not isinstance(i, int):\n                raise TypeError(\n                    'Excluding fields from a sequence of sub-models or dicts must be performed index-wise: '\n                    'expected integer keys or keyword \"__all__\"'\n                )\n            normalized_i = v_length + i if i < 0 else i\n            normalized_items[normalized_i] = self.merge(v, normalized_items.get(normalized_i))\n\n        if not all_items:\n            return normalized_items\n        if self.is_true(all_items):\n            for i in range(v_length):\n                normalized_items.setdefault(i, ...)\n            return normalized_items\n        for i in range(v_length):\n            normalized_item = normalized_items.setdefault(i, {})\n            if not self.is_true(normalized_item):\n                normalized_items[i] = self.merge(all_items, normalized_item)\n        return normalized_items\n\n    @classmethod\n    def merge(cls, base: Any, override: Any, intersect: bool = False) -> Any:\n        \"\"\"\n        Merge a ``base`` item with an ``override`` item.\n\n        Both ``base`` and ``override`` are converted to dictionaries if possible.\n        Sets are converted to dictionaries with the sets entries as keys and\n        Ellipsis as values.\n\n        Each key-value pair existing in ``base`` is merged with ``override``,\n        while the rest of the key-value pairs are updated recursively with this function.\n\n        Merging takes place based on the \"union\" of keys if ``intersect`` is\n        set to ``False`` (default) and on the intersection of keys if\n        ``intersect`` is set to ``True``.\n        \"\"\"\n        override = cls._coerce_value(override)\n        base = cls._coerce_value(base)\n        if override is None:\n            return base\n        if cls.is_true(base) or base is None:\n            return override\n        if cls.is_true(override):\n            return base if intersect else override\n\n        # intersection or union of keys while preserving ordering:\n        if intersect:\n            merge_keys = [k for k in base if k in override] + [k for k in override if k in base]\n        else:\n            merge_keys = list(base) + [k for k in override if k not in base]\n\n        merged: 'DictIntStrAny' = {}\n        for k in merge_keys:\n            merged_item = cls.merge(base.get(k), override.get(k), intersect=intersect)\n            if merged_item is not None:\n                merged[k] = merged_item\n\n        return merged\n\n    @staticmethod\n    def _coerce_items(items: Union['AbstractSetIntStr', 'MappingIntStrAny']) -> 'MappingIntStrAny':\n        if isinstance(items, Mapping):\n            pass\n        elif isinstance(items, AbstractSet):\n            items = dict.fromkeys(items, ...)\n        else:\n            raise TypeError(f'Unexpected type of exclude value {items.__class__}')\n        return items\n\n    @classmethod\n    def _coerce_value(cls, value: Any) -> Any:\n        if value is None or cls.is_true(value):\n            return value\n        return cls._coerce_items(value)\n\n    @staticmethod\n    def is_true(v: Any) -> bool:\n        return v is True or v is ...\n\n",
        "target_code_len": 5048,
        "diff_format": "@@ -468,98 +424,131 @@\n     def __init__(self, value: Any, items: Union['AbstractSetIntStr', 'MappingIntStrAny']) -> None:\n-        if TYPE_CHECKING:\n-            self._items: Union['AbstractSetIntStr', 'MappingIntStrAny']\n-            self._type: Type[Union[set, dict]]  # type: ignore\n-\n-        # For further type checks speed-up\n+        items = self._coerce_items(items)\n+\n+        if isinstance(value, (list, tuple)):\n+            items = self._normalize_indexes(items, len(value))\n+\n+        self._items: 'MappingIntStrAny' = items\n+\n+    def is_excluded(self, item: Any) -> bool:\n+        \"\"\"\n+        Check if item is fully excluded.\n+\n+        :param item: key or index of a value\n+        \"\"\"\n+        return self.is_true(self._items.get(item))\n+\n+    def is_included(self, item: Any) -> bool:\n+        \"\"\"\n+        Check if value is contained in self._items\n+\n+        :param item: key or index of value\n+        \"\"\"\n+        return item in self._items\n+\n+    def for_element(self, e: 'IntStr') -> Optional[Union['AbstractSetIntStr', 'MappingIntStrAny']]:\n+        \"\"\"\n+        :param e: key or index of element on value\n+        :return: raw values for elemet if self._items is dict and contain needed element\n+        \"\"\"\n+\n+        item = self._items.get(e)\n+        return item if not self.is_true(item) else None\n+\n+    def _normalize_indexes(self, items: 'MappingIntStrAny', v_length: int) -> 'DictIntStrAny':\n+        \"\"\"\n+        :param items: dict or set of indexes which will be normalized\n+        :param v_length: length of sequence indexes of which will be\n+\n+        >>> self._normalize_indexes({0: True, -2: True, -1: True}, 4)\n+        {0: True, 2: True, 3: True}\n+        >>> self._normalize_indexes({'__all__': True}, 4)\n+        {0: True, 1: True, 2: True, 3: True}\n+        \"\"\"\n+\n+        normalized_items: 'DictIntStrAny' = {}\n+        all_items = None\n+        for i, v in items.items():\n+            if not (isinstance(v, Mapping) or isinstance(v, AbstractSet) or self.is_true(v)):\n+                raise TypeError(f'Unexpected type of exclude value for index \"{i}\" {v.__class__}')\n+            if i == '__all__':\n+                all_items = self._coerce_value(v)\n+                continue\n+            if not isinstance(i, int):\n+                raise TypeError(\n+                    'Excluding fields from a sequence of sub-models or dicts must be performed index-wise: '\n+                    'expected integer keys or keyword \"__all__\"'\n+                )\n+            normalized_i = v_length + i if i < 0 else i\n+            normalized_items[normalized_i] = self.merge(v, normalized_items.get(normalized_i))\n+\n+        if not all_items:\n+            return normalized_items\n+        if self.is_true(all_items):\n+            for i in range(v_length):\n+                normalized_items.setdefault(i, ...)\n+            return normalized_items\n+        for i in range(v_length):\n+            normalized_item = normalized_items.setdefault(i, {})\n+            if not self.is_true(normalized_item):\n+                normalized_items[i] = self.merge(all_items, normalized_item)\n+        return normalized_items\n+\n+    @classmethod\n+    def merge(cls, base: Any, override: Any, intersect: bool = False) -> Any:\n+        \"\"\"\n+        Merge a ``base`` item with an ``override`` item.\n+\n+        Both ``base`` and ``override`` are converted to dictionaries if possible.\n+        Sets are converted to dictionaries with the sets entries as keys and\n+        Ellipsis as values.\n+\n+        Each key-value pair existing in ``base`` is merged with ``override``,\n+        while the rest of the key-value pairs are updated recursively with this function.\n+\n+        Merging takes place based on the \"union\" of keys if ``intersect`` is\n+        set to ``False`` (default) and on the intersection of keys if\n+        ``intersect`` is set to ``True``.\n+        \"\"\"\n+        override = cls._coerce_value(override)\n+        base = cls._coerce_value(base)\n+        if override is None:\n+            return base\n+        if cls.is_true(base) or base is None:\n+            return override\n+        if cls.is_true(override):\n+            return base if intersect else override\n+\n+        # intersection or union of keys while preserving ordering:\n+        if intersect:\n+            merge_keys = [k for k in base if k in override] + [k for k in override if k in base]\n+        else:\n+            merge_keys = list(base) + [k for k in override if k not in base]\n+\n+        merged: 'DictIntStrAny' = {}\n+        for k in merge_keys:\n+            merged_item = cls.merge(base.get(k), override.get(k), intersect=intersect)\n+            if merged_item is not None:\n+                merged[k] = merged_item\n+\n+        return merged\n+\n+    @staticmethod\n+    def _coerce_items(items: Union['AbstractSetIntStr', 'MappingIntStrAny']) -> 'MappingIntStrAny':\n         if isinstance(items, Mapping):\n-            self._type = dict\n+            pass\n         elif isinstance(items, AbstractSet):\n-            self._type = set\n+            items = dict.fromkeys(items, ...)\n         else:\n             raise TypeError(f'Unexpected type of exclude value {items.__class__}')\n-\n-        if isinstance(value, (list, tuple)):\n-            items = self._normalize_indexes(items, len(value))\n-\n-        self._items = items\n-\n-    @no_type_check\n-    def is_excluded(self, item: Any) -> bool:\n-        \"\"\"\n-        Check if item is fully excluded\n-        (value considered excluded if self._type is set and item contained in self._items\n-         or self._type is dict and self._items.get(item) is ...\n-\n-        :param item: key or index of a value\n-        \"\"\"\n-        if self._type is set:\n-            return item in self._items\n-        return self._items.get(item) is ...\n-\n-    @no_type_check\n-    def is_included(self, item: Any) -> bool:\n-        \"\"\"\n-        Check if value is contained in self._items\n-\n-        :param item: key or index of value\n-        \"\"\"\n-        return item in self._items\n-\n-    @no_type_check\n-    def for_element(self, e: 'IntStr') -> Optional[Union['AbstractSetIntStr', 'MappingIntStrAny']]:\n-        \"\"\"\n-        :param e: key or index of element on value\n-        :return: raw values for elemet if self._items is dict and contain needed element\n-        \"\"\"\n-\n-        if self._type is dict:\n-            item = self._items.get(e)\n-            return item if item is not ... else None\n-        return None\n-\n-    @no_type_check\n-    def _normalize_indexes(\n-        self, items: Union['AbstractSetIntStr', 'MappingIntStrAny'], v_length: int\n-    ) -> Union['AbstractSetIntStr', 'DictIntStrAny']:\n-        \"\"\"\n-        :param items: dict or set of indexes which will be normalized\n-        :param v_length: length of sequence indexes of which will be\n-\n-        >>> self._normalize_indexes({0, -2, -1}, 4)\n-        {0, 2, 3}\n-        >>> self._normalize_indexes({'__all__'}, 4)\n-        {0, 1, 2, 3}\n-        \"\"\"\n-        if any(not isinstance(i, int) and i != '__all__' for i in items):\n-            raise TypeError(\n-                'Excluding fields from a sequence of sub-models or dicts must be performed index-wise: '\n-                'expected integer keys or keyword \"__all__\"'\n-            )\n-        if self._type is set:\n-            if '__all__' in items:\n-                if items != {'__all__'}:\n-                    raise ValueError('set with keyword \"__all__\" must not contain other elements')\n-                return {i for i in range(v_length)}\n-            return {v_length + i if i < 0 else i for i in items}\n-        else:\n-            all_items = items.get('__all__')\n-            for i, v in items.items():\n-                if not (isinstance(v, Mapping) or isinstance(v, AbstractSet) or v is ...):\n-                    raise TypeError(f'Unexpected type of exclude value for index \"{i}\" {v.__class__}')\n-            normalized_items = {v_length + i if i < 0 else i: v for i, v in items.items() if i != '__all__'}\n-            if all_items:\n-                default: Type[Union[Set[Any], Dict[Any, Any]]]\n-                if isinstance(all_items, Mapping):\n-                    default = dict\n-                elif isinstance(all_items, AbstractSet):\n-                    default = set\n-                else:\n-                    for i in range(v_length):\n-                        normalized_items.setdefault(i, ...)\n-                    return normalized_items\n-                for i in range(v_length):\n-                    normalized_item = normalized_items.setdefault(i, default())\n-                    if normalized_item is not ...:\n-                        normalized_items[i] = update_normalized_all(normalized_item, all_items)\n-            return normalized_items\n+        return items\n+\n+    @classmethod\n+    def _coerce_value(cls, value: Any) -> Any:\n+        if value is None or cls.is_true(value):\n+            return value\n+        return cls._coerce_items(value)\n+\n+    @staticmethod\n+    def is_true(v: Any) -> bool:\n+        return v is True or v is ...\n \n",
        "source_code_with_indent": "    def __init__(self, value: Any, items: Union['AbstractSetIntStr', 'MappingIntStrAny']) -> None:\n        <IND>if TYPE_CHECKING:\n            <IND>self._items: Union['AbstractSetIntStr', 'MappingIntStrAny']\n            self._type: Type[Union[set, dict]]  # type: ignore\n\n        # For further type checks speed-up\n        <DED>if isinstance(items, Mapping):\n            <IND>self._type = dict\n        <DED>elif isinstance(items, AbstractSet):\n            <IND>self._type = set\n        <DED>else:\n            <IND>raise TypeError(f'Unexpected type of exclude value {items.__class__}')\n\n        <DED>if isinstance(value, (list, tuple)):\n            <IND>items = self._normalize_indexes(items, len(value))\n\n        <DED>self._items = items\n\n    <DED>@no_type_check\n    def is_excluded(self, item: Any) -> bool:\n        <IND>\"\"\"\n        Check if item is fully excluded\n        (value considered excluded if self._type is set and item contained in self._items\n         or self._type is dict and self._items.get(item) is ...\n\n        :param item: key or index of a value\n        \"\"\"\n        if self._type is set:\n            <IND>return item in self._items\n        <DED>return self._items.get(item) is ...\n\n    <DED>@no_type_check\n    def is_included(self, item: Any) -> bool:\n        <IND>\"\"\"\n        Check if value is contained in self._items\n\n        :param item: key or index of value\n        \"\"\"\n        return item in self._items\n\n    <DED>@no_type_check\n    def for_element(self, e: 'IntStr') -> Optional[Union['AbstractSetIntStr', 'MappingIntStrAny']]:\n        <IND>\"\"\"\n        :param e: key or index of element on value\n        :return: raw values for elemet if self._items is dict and contain needed element\n        \"\"\"\n\n        if self._type is dict:\n            <IND>item = self._items.get(e)\n            return item if item is not ... else None\n        <DED>return None\n\n    <DED>@no_type_check\n    def _normalize_indexes(\n        self, items: Union['AbstractSetIntStr', 'MappingIntStrAny'], v_length: int\n    ) -> Union['AbstractSetIntStr', 'DictIntStrAny']:\n        <IND>\"\"\"\n        :param items: dict or set of indexes which will be normalized\n        :param v_length: length of sequence indexes of which will be\n\n        >>> self._normalize_indexes({0, -2, -1}, 4)\n        {0, 2, 3}\n        >>> self._normalize_indexes({'__all__'}, 4)\n        {0, 1, 2, 3}\n        \"\"\"\n        if any(not isinstance(i, int) and i != '__all__' for i in items):\n            <IND>raise TypeError(\n                'Excluding fields from a sequence of sub-models or dicts must be performed index-wise: '\n                'expected integer keys or keyword \"__all__\"'\n            )\n        <DED>if self._type is set:\n            <IND>if '__all__' in items:\n                <IND>if items != {'__all__'}:\n                    <IND>raise ValueError('set with keyword \"__all__\" must not contain other elements')\n                <DED>return {i for i in range(v_length)}\n            <DED>return {v_length + i if i < 0 else i for i in items}\n        <DED>else:\n            <IND>all_items = items.get('__all__')\n            for i, v in items.items():\n                <IND>if not (isinstance(v, Mapping) or isinstance(v, AbstractSet) or v is ...):\n                    <IND>raise TypeError(f'Unexpected type of exclude value for index \"{i}\" {v.__class__}')\n            <DED><DED>normalized_items = {v_length + i if i < 0 else i: v for i, v in items.items() if i != '__all__'}\n            if all_items:\n                <IND>default: Type[Union[Set[Any], Dict[Any, Any]]]\n                if isinstance(all_items, Mapping):\n                    <IND>default = dict\n                <DED>elif isinstance(all_items, AbstractSet):\n                    <IND>default = set\n                <DED>else:\n                    <IND>for i in range(v_length):\n                        <IND>normalized_items.setdefault(i, ...)\n                    <DED>return normalized_items\n                <DED>for i in range(v_length):\n                    <IND>normalized_item = normalized_items.setdefault(i, default())\n                    if normalized_item is not ...:\n                        <IND>normalized_items[i] = update_normalized_all(normalized_item, all_items)\n            <DED><DED><DED>return normalized_items\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    def __init__(self, value: Any, items: Union['AbstractSetIntStr', 'MappingIntStrAny']) -> None:\n        <IND>items = self._coerce_items(items)\n\n        if isinstance(value, (list, tuple)):\n            <IND>items = self._normalize_indexes(items, len(value))\n\n        <DED>self._items: 'MappingIntStrAny' = items\n\n    <DED>def is_excluded(self, item: Any) -> bool:\n        <IND>\"\"\"\n        Check if item is fully excluded.\n\n        :param item: key or index of a value\n        \"\"\"\n        return self.is_true(self._items.get(item))\n\n    <DED>def is_included(self, item: Any) -> bool:\n        <IND>\"\"\"\n        Check if value is contained in self._items\n\n        :param item: key or index of value\n        \"\"\"\n        return item in self._items\n\n    <DED>def for_element(self, e: 'IntStr') -> Optional[Union['AbstractSetIntStr', 'MappingIntStrAny']]:\n        <IND>\"\"\"\n        :param e: key or index of element on value\n        :return: raw values for elemet if self._items is dict and contain needed element\n        \"\"\"\n\n        item = self._items.get(e)\n        return item if not self.is_true(item) else None\n\n    <DED>def _normalize_indexes(self, items: 'MappingIntStrAny', v_length: int) -> 'DictIntStrAny':\n        <IND>\"\"\"\n        :param items: dict or set of indexes which will be normalized\n        :param v_length: length of sequence indexes of which will be\n\n        >>> self._normalize_indexes({0: True, -2: True, -1: True}, 4)\n        {0: True, 2: True, 3: True}\n        >>> self._normalize_indexes({'__all__': True}, 4)\n        {0: True, 1: True, 2: True, 3: True}\n        \"\"\"\n\n        normalized_items: 'DictIntStrAny' = {}\n        all_items = None\n        for i, v in items.items():\n            <IND>if not (isinstance(v, Mapping) or isinstance(v, AbstractSet) or self.is_true(v)):\n                <IND>raise TypeError(f'Unexpected type of exclude value for index \"{i}\" {v.__class__}')\n            <DED>if i == '__all__':\n                <IND>all_items = self._coerce_value(v)\n                continue\n            <DED>if not isinstance(i, int):\n                <IND>raise TypeError(\n                    'Excluding fields from a sequence of sub-models or dicts must be performed index-wise: '\n                    'expected integer keys or keyword \"__all__\"'\n                )\n            <DED>normalized_i = v_length + i if i < 0 else i\n            normalized_items[normalized_i] = self.merge(v, normalized_items.get(normalized_i))\n\n        <DED>if not all_items:\n            <IND>return normalized_items\n        <DED>if self.is_true(all_items):\n            <IND>for i in range(v_length):\n                <IND>normalized_items.setdefault(i, ...)\n            <DED>return normalized_items\n        <DED>for i in range(v_length):\n            <IND>normalized_item = normalized_items.setdefault(i, {})\n            if not self.is_true(normalized_item):\n                <IND>normalized_items[i] = self.merge(all_items, normalized_item)\n        <DED><DED>return normalized_items\n\n    <DED>@classmethod\n    def merge(cls, base: Any, override: Any, intersect: bool = False) -> Any:\n        <IND>\"\"\"\n        Merge a ``base`` item with an ``override`` item.\n\n        Both ``base`` and ``override`` are converted to dictionaries if possible.\n        Sets are converted to dictionaries with the sets entries as keys and\n        Ellipsis as values.\n\n        Each key-value pair existing in ``base`` is merged with ``override``,\n        while the rest of the key-value pairs are updated recursively with this function.\n\n        Merging takes place based on the \"union\" of keys if ``intersect`` is\n        set to ``False`` (default) and on the intersection of keys if\n        ``intersect`` is set to ``True``.\n        \"\"\"\n        override = cls._coerce_value(override)\n        base = cls._coerce_value(base)\n        if override is None:\n            <IND>return base\n        <DED>if cls.is_true(base) or base is None:\n            <IND>return override\n        <DED>if cls.is_true(override):\n            <IND>return base if intersect else override\n\n        # intersection or union of keys while preserving ordering:\n        <DED>if intersect:\n            <IND>merge_keys = [k for k in base if k in override] + [k for k in override if k in base]\n        <DED>else:\n            <IND>merge_keys = list(base) + [k for k in override if k not in base]\n\n        <DED>merged: 'DictIntStrAny' = {}\n        for k in merge_keys:\n            <IND>merged_item = cls.merge(base.get(k), override.get(k), intersect=intersect)\n            if merged_item is not None:\n                <IND>merged[k] = merged_item\n\n        <DED><DED>return merged\n\n    <DED>@staticmethod\n    def _coerce_items(items: Union['AbstractSetIntStr', 'MappingIntStrAny']) -> 'MappingIntStrAny':\n        <IND>if isinstance(items, Mapping):\n            <IND>pass\n        <DED>elif isinstance(items, AbstractSet):\n            <IND>items = dict.fromkeys(items, ...)\n        <DED>else:\n            <IND>raise TypeError(f'Unexpected type of exclude value {items.__class__}')\n        <DED>return items\n\n    <DED>@classmethod\n    def _coerce_value(cls, value: Any) -> Any:\n        <IND>if value is None or cls.is_true(value):\n            <IND>return value\n        <DED>return cls._coerce_items(value)\n\n    <DED>@staticmethod\n    def is_true(v: Any) -> bool:\n        <IND>return v is True or v is ...\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  }
]