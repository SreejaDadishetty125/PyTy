[
  {
    "project": "TheAlgorithms/Python",
    "commit": "f3ba9b6c508a24cd0e10fb08d0235c1f838fb73a",
    "filename": "backtracking/all_subsequences.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/TheAlgorithms-Python/backtracking/all_subsequences.py",
    "file_hunks_size": 2,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "backtracking/all_subsequences.py:45:0 Incompatible variable type [9]: sequence is declared to have type `List[int]` but is used as type `List[str]`.",
    "message": " sequence is declared to have type `List[int]` but is used as type `List[str]`.",
    "rule_id": "Incompatible variable type [9]",
    "warning_line_no": 45,
    "warning_line": "sequence = [\"A\", \"B\", \"C\"]",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n\"\"\"\nremove the comment to take an input from the user\n\nprint(\"Enter the elements\")\nsequence = list(map(int, input().split()))\n\"\"\"\n\nsequence = [3, 1, 2, 4]\ngenerate_all_subsequences(sequence)\n\nsequence = [\"A\", \"B\", \"C\"]\ngenerate_all_subsequences(sequence)\n",
        "source_code_len": 256,
        "target_code": "\nif __name__ == \"__main__\":\n    seq: List[Any] = [3, 1, 2, 4]\n    generate_all_subsequences(seq)\n\n    seq.clear()\n    seq.extend([\"A\", \"B\", \"C\"])\n    generate_all_subsequences(seq)\n",
        "target_code_len": 181,
        "diff_format": "@@ -34,13 +33,8 @@\n \n-\"\"\"\n-remove the comment to take an input from the user\n+if __name__ == \"__main__\":\n+    seq: List[Any] = [3, 1, 2, 4]\n+    generate_all_subsequences(seq)\n \n-print(\"Enter the elements\")\n-sequence = list(map(int, input().split()))\n-\"\"\"\n-\n-sequence = [3, 1, 2, 4]\n-generate_all_subsequences(sequence)\n-\n-sequence = [\"A\", \"B\", \"C\"]\n-generate_all_subsequences(sequence)\n+    seq.clear()\n+    seq.extend([\"A\", \"B\", \"C\"])\n+    generate_all_subsequences(seq)\n",
        "source_code_with_indent": "\n<DED>\"\"\"\nremove the comment to take an input from the user\n\nprint(\"Enter the elements\")\nsequence = list(map(int, input().split()))\n\"\"\"\n\nsequence = [3, 1, 2, 4]\ngenerate_all_subsequences(sequence)\n\nsequence = [\"A\", \"B\", \"C\"]\ngenerate_all_subsequences(sequence)\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n<DED>if __name__ == \"__main__\":\n    <IND>seq: List[Any] = [3, 1, 2, 4]\n    generate_all_subsequences(seq)\n\n    seq.clear()\n    seq.extend([\"A\", \"B\", \"C\"])\n    generate_all_subsequences(seq)\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "TheAlgorithms/Python",
    "commit": "f3ba9b6c508a24cd0e10fb08d0235c1f838fb73a",
    "filename": "backtracking/knight_tour.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/TheAlgorithms-Python/backtracking/knight_tour.py",
    "file_hunks_size": 4,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "backtracking/knight_tour.py:88:47 Incompatible parameter type [6]: Expected `typing.Tuple[int]` for 2nd positional only parameter to call `open_knight_tour_helper` but got `typing.Tuple[int, int]`.",
    "message": " Expected `typing.Tuple[int]` for 2nd positional only parameter to call `open_knight_tour_helper` but got `typing.Tuple[int, int]`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 88,
    "warning_line": "            if open_knight_tour_helper(board, (i, j), 1):",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\nfrom __future__ import annotations\n\n\ndef get_valid_pos(position: tuple[int], n: int) -> list[tuple[int]]:\n    \"\"\"\n",
        "source_code_len": 115,
        "target_code": "\nfrom typing import List, Tuple\n\n\ndef get_valid_pos(position: Tuple[int, int], n: int) -> List[Tuple[int, int]]:\n    \"\"\"\n",
        "target_code_len": 121,
        "diff_format": "@@ -2,6 +2,6 @@\n \n-from __future__ import annotations\n+from typing import List, Tuple\n \n \n-def get_valid_pos(position: tuple[int], n: int) -> list[tuple[int]]:\n+def get_valid_pos(position: Tuple[int, int], n: int) -> List[Tuple[int, int]]:\n     \"\"\"\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\nfrom __future__ import annotations\n\n\ndef get_valid_pos(position: tuple[int], n: int) -> list[tuple[int]]:\n    <IND>",
        "target_code_with_indent": "\nfrom typing import List, Tuple\n\n\ndef get_valid_pos(position: Tuple[int, int], n: int) -> List[Tuple[int, int]]:\n    <IND>"
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\ndef open_knight_tour_helper(board: list[list[int]], pos: tuple[int], curr: int) -> bool:\n    \"\"\"\n",
        "source_code_len": 98,
        "target_code": "\ndef open_knight_tour_helper(\n    board: List[List[int]], pos: Tuple[int, int], curr: int\n) -> bool:\n    \"\"\"\n",
        "target_code_len": 109,
        "diff_format": "@@ -48,3 +48,5 @@\n \n-def open_knight_tour_helper(board: list[list[int]], pos: tuple[int], curr: int) -> bool:\n+def open_knight_tour_helper(\n+    board: List[List[int]], pos: Tuple[int, int], curr: int\n+) -> bool:\n     \"\"\"\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\n<DED>def open_knight_tour_helper(board: list[list[int]], pos: tuple[int], curr: int) -> bool:\n    <IND>",
        "target_code_with_indent": "\n<DED>def open_knight_tour_helper(\n    board: List[List[int]], pos: Tuple[int, int], curr: int\n) -> bool:\n    <IND>"
      }
    ]
  },
  {
    "project": "TheAlgorithms/Python",
    "commit": "f3ba9b6c508a24cd0e10fb08d0235c1f838fb73a",
    "filename": "backtracking/n_queens_math.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/TheAlgorithms-Python/backtracking/n_queens_math.py",
    "file_hunks_size": 5,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "backtracking/n_queens_math.py:109:8 Incompatible variable type [9]: possible_board is declared to have type `typing.List[int]` but is used as type `typing.List[str]`.",
    "message": " possible_board is declared to have type `typing.List[int]` but is used as type `typing.List[str]`.",
    "rule_id": "Incompatible variable type [9]",
    "warning_line_no": 109,
    "warning_line": "        possible_board = [\". \" * i + \"Q \" + \". \" * (n - 1 - i) for i in possible_board]",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n    \"\"\" Get next row in the current board (possible_board) to fill it with a queen \"\"\"\n    row = len(possible_board)\n\n    \"\"\"\n    If row is equal to the size of the board it means there are a queen in each row in\n    the current board (possible_board)\n    \"\"\"\n    if row == n:\n        \"\"\"\n        We convert the variable possible_board that looks like this: [1, 3, 0, 2] to\n        this: ['. Q . . ', '. . . Q ', 'Q . . . ', '. . Q . ']\n        \"\"\"\n        possible_board = [\". \" * i + \"Q \" + \". \" * (n - 1 - i) for i in possible_board]\n        boards.append(possible_board)\n        return\n\n    \"\"\" We iterate each column in the row to find all possible results in each row \"\"\"\n    for col in range(n):\n\n        \"\"\"\n        We apply that we learned previously. First we check that in the current board\n        (possible_board) there are not other same value because if there is it means\n        that there are a collision in vertical. Then we apply the two formulas we\n        learned before:\n\n        45\u00ba: y - x = b or 45: row - col = b\n        135\u00ba: y + x = b or row + col = b.\n\n        And we verify if the results of this two formulas not exist in their variables\n        respectively.  (diagonal_right_collisions, diagonal_left_collisions)\n\n        If any or these are True it means there is a collision so we continue to the\n        next value in the for loop.\n        \"\"\"\n        if (\n",
        "source_code_len": 1393,
        "target_code": "\n    # Get next row in the current board (possible_board) to fill it with a queen\n    row = len(possible_board)\n\n    # If row is equal to the size of the board it means there are a queen in each row in\n    # the current board (possible_board)\n    if row == n:\n        # We convert the variable possible_board that looks like this: [1, 3, 0, 2] to\n        # this: ['. Q . . ', '. . . Q ', 'Q . . . ', '. . Q . ']\n        boards.append([\". \" * i + \"Q \" + \". \" * (n - 1 - i) for i in possible_board])\n        return\n\n    # We iterate each column in the row to find all possible results in each row\n    for col in range(n):\n\n        # We apply that we learned previously. First we check that in the current board\n        # (possible_board) there are not other same value because if there is it means\n        # that there are a collision in vertical. Then we apply the two formulas we\n        # learned before:\n        #\n        # 45\u00ba: y - x = b or 45: row - col = b\n        # 135\u00ba: y + x = b or row + col = b.\n        #\n        # And we verify if the results of this two formulas not exist in their variables\n        # respectively.  (diagonal_right_collisions, diagonal_left_collisions)\n        #\n        # If any or these are True it means there is a collision so we continue to the\n        # next value in the for loop.\n        if (\n",
        "target_code_len": 1332,
        "diff_format": "@@ -96,36 +96,29 @@\n \n-    \"\"\" Get next row in the current board (possible_board) to fill it with a queen \"\"\"\n+    # Get next row in the current board (possible_board) to fill it with a queen\n     row = len(possible_board)\n \n-    \"\"\"\n-    If row is equal to the size of the board it means there are a queen in each row in\n-    the current board (possible_board)\n-    \"\"\"\n+    # If row is equal to the size of the board it means there are a queen in each row in\n+    # the current board (possible_board)\n     if row == n:\n-        \"\"\"\n-        We convert the variable possible_board that looks like this: [1, 3, 0, 2] to\n-        this: ['. Q . . ', '. . . Q ', 'Q . . . ', '. . Q . ']\n-        \"\"\"\n-        possible_board = [\". \" * i + \"Q \" + \". \" * (n - 1 - i) for i in possible_board]\n-        boards.append(possible_board)\n+        # We convert the variable possible_board that looks like this: [1, 3, 0, 2] to\n+        # this: ['. Q . . ', '. . . Q ', 'Q . . . ', '. . Q . ']\n+        boards.append([\". \" * i + \"Q \" + \". \" * (n - 1 - i) for i in possible_board])\n         return\n \n-    \"\"\" We iterate each column in the row to find all possible results in each row \"\"\"\n+    # We iterate each column in the row to find all possible results in each row\n     for col in range(n):\n \n-        \"\"\"\n-        We apply that we learned previously. First we check that in the current board\n-        (possible_board) there are not other same value because if there is it means\n-        that there are a collision in vertical. Then we apply the two formulas we\n-        learned before:\n-\n-        45\u00ba: y - x = b or 45: row - col = b\n-        135\u00ba: y + x = b or row + col = b.\n-\n-        And we verify if the results of this two formulas not exist in their variables\n-        respectively.  (diagonal_right_collisions, diagonal_left_collisions)\n-\n-        If any or these are True it means there is a collision so we continue to the\n-        next value in the for loop.\n-        \"\"\"\n+        # We apply that we learned previously. First we check that in the current board\n+        # (possible_board) there are not other same value because if there is it means\n+        # that there are a collision in vertical. Then we apply the two formulas we\n+        # learned before:\n+        #\n+        # 45\u00ba: y - x = b or 45: row - col = b\n+        # 135\u00ba: y + x = b or row + col = b.\n+        #\n+        # And we verify if the results of this two formulas not exist in their variables\n+        # respectively.  (diagonal_right_collisions, diagonal_left_collisions)\n+        #\n+        # If any or these are True it means there is a collision so we continue to the\n+        # next value in the for loop.\n         if (\n",
        "source_code_with_indent": "\n    \"\"\" Get next row in the current board (possible_board) to fill it with a queen \"\"\"\n    row = len(possible_board)\n\n    \"\"\"\n    If row is equal to the size of the board it means there are a queen in each row in\n    the current board (possible_board)\n    \"\"\"\n    if row == n:\n        <IND>\"\"\"\n        We convert the variable possible_board that looks like this: [1, 3, 0, 2] to\n        this: ['. Q . . ', '. . . Q ', 'Q . . . ', '. . Q . ']\n        \"\"\"\n        possible_board = [\". \" * i + \"Q \" + \". \" * (n - 1 - i) for i in possible_board]\n        boards.append(possible_board)\n        return\n\n    <DED>\"\"\" We iterate each column in the row to find all possible results in each row \"\"\"\n    for col in range(n):\n\n        <IND>\"\"\"\n        We apply that we learned previously. First we check that in the current board\n        (possible_board) there are not other same value because if there is it means\n        that there are a collision in vertical. Then we apply the two formulas we\n        learned before:\n\n        45\u00ba: y - x = b or 45: row - col = b\n        135\u00ba: y + x = b or row + col = b.\n\n        And we verify if the results of this two formulas not exist in their variables\n        respectively.  (diagonal_right_collisions, diagonal_left_collisions)\n\n        If any or these are True it means there is a collision so we continue to the\n        next value in the for loop.\n        \"\"\"\n        if (\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n    # Get next row in the current board (possible_board) to fill it with a queen\n    row = len(possible_board)\n\n    # If row is equal to the size of the board it means there are a queen in each row in\n    # the current board (possible_board)\n    if row == n:\n        # We convert the variable possible_board that looks like this: [1, 3, 0, 2] to\n        # this: ['. Q . . ', '. . . Q ', 'Q . . . ', '. . Q . ']\n        <IND>boards.append([\". \" * i + \"Q \" + \". \" * (n - 1 - i) for i in possible_board])\n        return\n\n    # We iterate each column in the row to find all possible results in each row\n    <DED>for col in range(n):\n\n        # We apply that we learned previously. First we check that in the current board\n        # (possible_board) there are not other same value because if there is it means\n        # that there are a collision in vertical. Then we apply the two formulas we\n        # learned before:\n        #\n        # 45\u00ba: y - x = b or 45: row - col = b\n        # 135\u00ba: y + x = b or row + col = b.\n        #\n        # And we verify if the results of this two formulas not exist in their variables\n        # respectively.  (diagonal_right_collisions, diagonal_left_collisions)\n        #\n        # If any or these are True it means there is a collision so we continue to the\n        # next value in the for loop.\n        <IND>if (\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "TheAlgorithms/Python",
    "commit": "f3ba9b6c508a24cd0e10fb08d0235c1f838fb73a",
    "filename": "backtracking/n_queens_math.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/TheAlgorithms-Python/backtracking/n_queens_math.py",
    "file_hunks_size": 5,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "backtracking/n_queens_math.py:110:22 Incompatible parameter type [6]: Expected `typing.List[str]` for 1st positional only parameter to call `list.append` but got `typing.List[int]`.",
    "message": " Expected `typing.List[str]` for 1st positional only parameter to call `list.append` but got `typing.List[int]`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 110,
    "warning_line": "        boards.append(possible_board)",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n    \"\"\" Get next row in the current board (possible_board) to fill it with a queen \"\"\"\n    row = len(possible_board)\n\n    \"\"\"\n    If row is equal to the size of the board it means there are a queen in each row in\n    the current board (possible_board)\n    \"\"\"\n    if row == n:\n        \"\"\"\n        We convert the variable possible_board that looks like this: [1, 3, 0, 2] to\n        this: ['. Q . . ', '. . . Q ', 'Q . . . ', '. . Q . ']\n        \"\"\"\n        possible_board = [\". \" * i + \"Q \" + \". \" * (n - 1 - i) for i in possible_board]\n        boards.append(possible_board)\n        return\n\n    \"\"\" We iterate each column in the row to find all possible results in each row \"\"\"\n    for col in range(n):\n\n        \"\"\"\n        We apply that we learned previously. First we check that in the current board\n        (possible_board) there are not other same value because if there is it means\n        that there are a collision in vertical. Then we apply the two formulas we\n        learned before:\n\n        45\u00ba: y - x = b or 45: row - col = b\n        135\u00ba: y + x = b or row + col = b.\n\n        And we verify if the results of this two formulas not exist in their variables\n        respectively.  (diagonal_right_collisions, diagonal_left_collisions)\n\n        If any or these are True it means there is a collision so we continue to the\n        next value in the for loop.\n        \"\"\"\n        if (\n",
        "source_code_len": 1393,
        "target_code": "\n    # Get next row in the current board (possible_board) to fill it with a queen\n    row = len(possible_board)\n\n    # If row is equal to the size of the board it means there are a queen in each row in\n    # the current board (possible_board)\n    if row == n:\n        # We convert the variable possible_board that looks like this: [1, 3, 0, 2] to\n        # this: ['. Q . . ', '. . . Q ', 'Q . . . ', '. . Q . ']\n        boards.append([\". \" * i + \"Q \" + \". \" * (n - 1 - i) for i in possible_board])\n        return\n\n    # We iterate each column in the row to find all possible results in each row\n    for col in range(n):\n\n        # We apply that we learned previously. First we check that in the current board\n        # (possible_board) there are not other same value because if there is it means\n        # that there are a collision in vertical. Then we apply the two formulas we\n        # learned before:\n        #\n        # 45\u00ba: y - x = b or 45: row - col = b\n        # 135\u00ba: y + x = b or row + col = b.\n        #\n        # And we verify if the results of this two formulas not exist in their variables\n        # respectively.  (diagonal_right_collisions, diagonal_left_collisions)\n        #\n        # If any or these are True it means there is a collision so we continue to the\n        # next value in the for loop.\n        if (\n",
        "target_code_len": 1332,
        "diff_format": "@@ -96,36 +96,29 @@\n \n-    \"\"\" Get next row in the current board (possible_board) to fill it with a queen \"\"\"\n+    # Get next row in the current board (possible_board) to fill it with a queen\n     row = len(possible_board)\n \n-    \"\"\"\n-    If row is equal to the size of the board it means there are a queen in each row in\n-    the current board (possible_board)\n-    \"\"\"\n+    # If row is equal to the size of the board it means there are a queen in each row in\n+    # the current board (possible_board)\n     if row == n:\n-        \"\"\"\n-        We convert the variable possible_board that looks like this: [1, 3, 0, 2] to\n-        this: ['. Q . . ', '. . . Q ', 'Q . . . ', '. . Q . ']\n-        \"\"\"\n-        possible_board = [\". \" * i + \"Q \" + \". \" * (n - 1 - i) for i in possible_board]\n-        boards.append(possible_board)\n+        # We convert the variable possible_board that looks like this: [1, 3, 0, 2] to\n+        # this: ['. Q . . ', '. . . Q ', 'Q . . . ', '. . Q . ']\n+        boards.append([\". \" * i + \"Q \" + \". \" * (n - 1 - i) for i in possible_board])\n         return\n \n-    \"\"\" We iterate each column in the row to find all possible results in each row \"\"\"\n+    # We iterate each column in the row to find all possible results in each row\n     for col in range(n):\n \n-        \"\"\"\n-        We apply that we learned previously. First we check that in the current board\n-        (possible_board) there are not other same value because if there is it means\n-        that there are a collision in vertical. Then we apply the two formulas we\n-        learned before:\n-\n-        45\u00ba: y - x = b or 45: row - col = b\n-        135\u00ba: y + x = b or row + col = b.\n-\n-        And we verify if the results of this two formulas not exist in their variables\n-        respectively.  (diagonal_right_collisions, diagonal_left_collisions)\n-\n-        If any or these are True it means there is a collision so we continue to the\n-        next value in the for loop.\n-        \"\"\"\n+        # We apply that we learned previously. First we check that in the current board\n+        # (possible_board) there are not other same value because if there is it means\n+        # that there are a collision in vertical. Then we apply the two formulas we\n+        # learned before:\n+        #\n+        # 45\u00ba: y - x = b or 45: row - col = b\n+        # 135\u00ba: y + x = b or row + col = b.\n+        #\n+        # And we verify if the results of this two formulas not exist in their variables\n+        # respectively.  (diagonal_right_collisions, diagonal_left_collisions)\n+        #\n+        # If any or these are True it means there is a collision so we continue to the\n+        # next value in the for loop.\n         if (\n",
        "source_code_with_indent": "\n    \"\"\" Get next row in the current board (possible_board) to fill it with a queen \"\"\"\n    row = len(possible_board)\n\n    \"\"\"\n    If row is equal to the size of the board it means there are a queen in each row in\n    the current board (possible_board)\n    \"\"\"\n    if row == n:\n        <IND>\"\"\"\n        We convert the variable possible_board that looks like this: [1, 3, 0, 2] to\n        this: ['. Q . . ', '. . . Q ', 'Q . . . ', '. . Q . ']\n        \"\"\"\n        possible_board = [\". \" * i + \"Q \" + \". \" * (n - 1 - i) for i in possible_board]\n        boards.append(possible_board)\n        return\n\n    <DED>\"\"\" We iterate each column in the row to find all possible results in each row \"\"\"\n    for col in range(n):\n\n        <IND>\"\"\"\n        We apply that we learned previously. First we check that in the current board\n        (possible_board) there are not other same value because if there is it means\n        that there are a collision in vertical. Then we apply the two formulas we\n        learned before:\n\n        45\u00ba: y - x = b or 45: row - col = b\n        135\u00ba: y + x = b or row + col = b.\n\n        And we verify if the results of this two formulas not exist in their variables\n        respectively.  (diagonal_right_collisions, diagonal_left_collisions)\n\n        If any or these are True it means there is a collision so we continue to the\n        next value in the for loop.\n        \"\"\"\n        if (\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n    # Get next row in the current board (possible_board) to fill it with a queen\n    row = len(possible_board)\n\n    # If row is equal to the size of the board it means there are a queen in each row in\n    # the current board (possible_board)\n    if row == n:\n        # We convert the variable possible_board that looks like this: [1, 3, 0, 2] to\n        # this: ['. Q . . ', '. . . Q ', 'Q . . . ', '. . Q . ']\n        <IND>boards.append([\". \" * i + \"Q \" + \". \" * (n - 1 - i) for i in possible_board])\n        return\n\n    # We iterate each column in the row to find all possible results in each row\n    <DED>for col in range(n):\n\n        # We apply that we learned previously. First we check that in the current board\n        # (possible_board) there are not other same value because if there is it means\n        # that there are a collision in vertical. Then we apply the two formulas we\n        # learned before:\n        #\n        # 45\u00ba: y - x = b or 45: row - col = b\n        # 135\u00ba: y + x = b or row + col = b.\n        #\n        # And we verify if the results of this two formulas not exist in their variables\n        # respectively.  (diagonal_right_collisions, diagonal_left_collisions)\n        #\n        # If any or these are True it means there is a collision so we continue to the\n        # next value in the for loop.\n        <IND>if (\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "TheAlgorithms/Python",
    "commit": "f3ba9b6c508a24cd0e10fb08d0235c1f838fb73a",
    "filename": "backtracking/sudoku.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/TheAlgorithms-Python/backtracking/sudoku.py",
    "file_hunks_size": 10,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "backtracking/sudoku.py:91:16 Incompatible return type [7]: Expected `Tuple[int, int]` but got implicit return value of `None`.",
    "message": " Expected `Tuple[int, int]` but got implicit return value of `None`.",
    "rule_id": "Incompatible return type [7]",
    "warning_line_no": 91,
    "warning_line": "                return i, j",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "from typing import List, Tuple, Union\n\n",
        "source_code_len": 39,
        "target_code": "\"\"\"\nGiven a partially filled 9\u00d79 2D array, the objective is to fill a 9\u00d79\nsquare grid with digits numbered 1 to 9, so that every row, column, and\nand each of the nine 3\u00d73 sub-grids contains all of the digits.\n\nThis can be solved using Backtracking and is similar to n-queens.\nWe check to see if a cell is safe or not and recursively call the\nfunction on the next column to see if it returns True. if yes, we\nhave solved the puzzle. else, we backtrack and place another number\nin that cell and repeat this process.\n\"\"\"\nfrom typing import List, Optional, Tuple\n\n",
        "target_code_len": 560,
        "diff_format": "@@ -1,2 +1,13 @@\n-from typing import List, Tuple, Union\n+\"\"\"\n+Given a partially filled 9\u00d79 2D array, the objective is to fill a 9\u00d79\n+square grid with digits numbered 1 to 9, so that every row, column, and\n+and each of the nine 3\u00d73 sub-grids contains all of the digits.\n+\n+This can be solved using Backtracking and is similar to n-queens.\n+We check to see if a cell is safe or not and recursively call the\n+function on the next column to see if it returns True. if yes, we\n+have solved the puzzle. else, we backtrack and place another number\n+in that cell and repeat this process.\n+\"\"\"\n+from typing import List, Optional, Tuple\n \n",
        "source_code_with_indent": "from typing import List, Tuple, Union\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\"\"\"\nGiven a partially filled 9\u00d79 2D array, the objective is to fill a 9\u00d79\nsquare grid with digits numbered 1 to 9, so that every row, column, and\nand each of the nine 3\u00d73 sub-grids contains all of the digits.\n\nThis can be solved using Backtracking and is similar to n-queens.\nWe check to see if a cell is safe or not and recursively call the\nfunction on the next column to see if it returns True. if yes, we\nhave solved the puzzle. else, we backtrack and place another number\nin that cell and repeat this process.\n\"\"\"\nfrom typing import List, Optional, Tuple\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\ndef find_empty_location(grid: Matrix) -> Tuple[int, int]:\n    \"\"\"\n",
        "source_code_len": 67,
        "target_code": "\ndef find_empty_location(grid: Matrix) -> Optional[Tuple[int, int]]:\n    \"\"\"\n",
        "target_code_len": 77,
        "diff_format": "@@ -82,3 +82,3 @@\n \n-def find_empty_location(grid: Matrix) -> Tuple[int, int]:\n+def find_empty_location(grid: Matrix) -> Optional[Tuple[int, int]]:\n     \"\"\"\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\n<DED>def find_empty_location(grid: Matrix) -> Tuple[int, int]:\n    <IND>",
        "target_code_with_indent": "\n<DED>def find_empty_location(grid: Matrix) -> Optional[Tuple[int, int]]:\n    <IND>"
      },
      {
        "hunk_fit_TFix": true,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "                return i, j\n\n\ndef sudoku(grid: Matrix) -> Union[Matrix, bool]:\n    \"\"\"\n",
        "source_code_len": 87,
        "target_code": "                return i, j\n    return None\n\n\ndef sudoku(grid: Matrix) -> Optional[Matrix]:\n    \"\"\"\n",
        "target_code_len": 100,
        "diff_format": "@@ -91,5 +91,6 @@\n                 return i, j\n+    return None\n \n \n-def sudoku(grid: Matrix) -> Union[Matrix, bool]:\n+def sudoku(grid: Matrix) -> Optional[Matrix]:\n     \"\"\"\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "                <IND>return i, j\n\n\n<DED><DED><DED><DED>def sudoku(grid: Matrix) -> Union[Matrix, bool]:\n    <IND>",
        "target_code_with_indent": "                <IND>return i, j\n    <DED><DED><DED>return None\n\n\n<DED>def sudoku(grid: Matrix) -> Optional[Matrix]:\n    <IND>"
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n    row, column = find_empty_location(grid)\n\n",
        "source_code_len": 46,
        "target_code": "\n    location = find_empty_location(grid)\n    if location is not None:\n        row, column = location\n    else:\n        # If the location is ``None``, then the grid is solved.\n        return grid\n\n",
        "target_code_len": 197,
        "diff_format": "@@ -116,3 +117,8 @@\n \n-    row, column = find_empty_location(grid)\n+    location = find_empty_location(grid)\n+    if location is not None:\n+        row, column = location\n+    else:\n+        # If the location is ``None``, then the grid is solved.\n+        return grid\n \n",
        "source_code_with_indent": "\n    <DED>row, column = find_empty_location(grid)\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n    <DED>location = find_empty_location(grid)\n    if location is not None:\n        <IND>row, column = location\n    <DED>else:\n        # If the location is ``None``, then the grid is solved.\n        <IND>return grid\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n    return False\n\n",
        "source_code_len": 19,
        "target_code": "\n    return None\n\n",
        "target_code_len": 18,
        "diff_format": "@@ -127,3 +133,3 @@\n \n-    return False\n+    return None\n \n",
        "source_code_with_indent": "\n    <DED><DED>return False\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n    <DED><DED>return None\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "TheAlgorithms/Python",
    "commit": "f3ba9b6c508a24cd0e10fb08d0235c1f838fb73a",
    "filename": "backtracking/sudoku.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/TheAlgorithms-Python/backtracking/sudoku.py",
    "file_hunks_size": 10,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "backtracking/sudoku.py:149:27 Incompatible parameter type [6]: Expected `List[List[int]]` for 1st positional only parameter to call `print_solution` but got `Union[List[List[int]], bool]`.",
    "message": " Expected `List[List[int]]` for 1st positional only parameter to call `print_solution` but got `Union[List[List[int]], bool]`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 149,
    "warning_line": "            print_solution(solution)",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "from typing import List, Tuple, Union\n\n",
        "source_code_len": 39,
        "target_code": "\"\"\"\nGiven a partially filled 9\u00d79 2D array, the objective is to fill a 9\u00d79\nsquare grid with digits numbered 1 to 9, so that every row, column, and\nand each of the nine 3\u00d73 sub-grids contains all of the digits.\n\nThis can be solved using Backtracking and is similar to n-queens.\nWe check to see if a cell is safe or not and recursively call the\nfunction on the next column to see if it returns True. if yes, we\nhave solved the puzzle. else, we backtrack and place another number\nin that cell and repeat this process.\n\"\"\"\nfrom typing import List, Optional, Tuple\n\n",
        "target_code_len": 560,
        "diff_format": "@@ -1,2 +1,13 @@\n-from typing import List, Tuple, Union\n+\"\"\"\n+Given a partially filled 9\u00d79 2D array, the objective is to fill a 9\u00d79\n+square grid with digits numbered 1 to 9, so that every row, column, and\n+and each of the nine 3\u00d73 sub-grids contains all of the digits.\n+\n+This can be solved using Backtracking and is similar to n-queens.\n+We check to see if a cell is safe or not and recursively call the\n+function on the next column to see if it returns True. if yes, we\n+have solved the puzzle. else, we backtrack and place another number\n+in that cell and repeat this process.\n+\"\"\"\n+from typing import List, Optional, Tuple\n \n",
        "source_code_with_indent": "from typing import List, Tuple, Union\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\"\"\"\nGiven a partially filled 9\u00d79 2D array, the objective is to fill a 9\u00d79\nsquare grid with digits numbered 1 to 9, so that every row, column, and\nand each of the nine 3\u00d73 sub-grids contains all of the digits.\n\nThis can be solved using Backtracking and is similar to n-queens.\nWe check to see if a cell is safe or not and recursively call the\nfunction on the next column to see if it returns True. if yes, we\nhave solved the puzzle. else, we backtrack and place another number\nin that cell and repeat this process.\n\"\"\"\nfrom typing import List, Optional, Tuple\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\ndef find_empty_location(grid: Matrix) -> Tuple[int, int]:\n    \"\"\"\n",
        "source_code_len": 67,
        "target_code": "\ndef find_empty_location(grid: Matrix) -> Optional[Tuple[int, int]]:\n    \"\"\"\n",
        "target_code_len": 77,
        "diff_format": "@@ -82,3 +82,3 @@\n \n-def find_empty_location(grid: Matrix) -> Tuple[int, int]:\n+def find_empty_location(grid: Matrix) -> Optional[Tuple[int, int]]:\n     \"\"\"\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\n<DED>def find_empty_location(grid: Matrix) -> Tuple[int, int]:\n    <IND>",
        "target_code_with_indent": "\n<DED>def find_empty_location(grid: Matrix) -> Optional[Tuple[int, int]]:\n    <IND>"
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "                return i, j\n\n\ndef sudoku(grid: Matrix) -> Union[Matrix, bool]:\n    \"\"\"\n",
        "source_code_len": 87,
        "target_code": "                return i, j\n    return None\n\n\ndef sudoku(grid: Matrix) -> Optional[Matrix]:\n    \"\"\"\n",
        "target_code_len": 100,
        "diff_format": "@@ -91,5 +91,6 @@\n                 return i, j\n+    return None\n \n \n-def sudoku(grid: Matrix) -> Union[Matrix, bool]:\n+def sudoku(grid: Matrix) -> Optional[Matrix]:\n     \"\"\"\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "                <IND>return i, j\n\n\n<DED><DED><DED><DED>def sudoku(grid: Matrix) -> Union[Matrix, bool]:\n    <IND>",
        "target_code_with_indent": "                <IND>return i, j\n    <DED><DED><DED>return None\n\n\n<DED>def sudoku(grid: Matrix) -> Optional[Matrix]:\n    <IND>"
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n    row, column = find_empty_location(grid)\n\n",
        "source_code_len": 46,
        "target_code": "\n    location = find_empty_location(grid)\n    if location is not None:\n        row, column = location\n    else:\n        # If the location is ``None``, then the grid is solved.\n        return grid\n\n",
        "target_code_len": 197,
        "diff_format": "@@ -116,3 +117,8 @@\n \n-    row, column = find_empty_location(grid)\n+    location = find_empty_location(grid)\n+    if location is not None:\n+        row, column = location\n+    else:\n+        # If the location is ``None``, then the grid is solved.\n+        return grid\n \n",
        "source_code_with_indent": "\n    <DED>row, column = find_empty_location(grid)\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n    <DED>location = find_empty_location(grid)\n    if location is not None:\n        <IND>row, column = location\n    <DED>else:\n        # If the location is ``None``, then the grid is solved.\n        <IND>return grid\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n    return False\n\n",
        "source_code_len": 19,
        "target_code": "\n    return None\n\n",
        "target_code_len": 18,
        "diff_format": "@@ -127,3 +133,3 @@\n \n-    return False\n+    return None\n \n",
        "source_code_with_indent": "\n    <DED><DED>return False\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n    <DED><DED>return None\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  }
]