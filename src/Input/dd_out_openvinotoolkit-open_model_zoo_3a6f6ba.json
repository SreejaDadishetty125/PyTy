[
  {
    "project": "openvinotoolkit/open_model_zoo",
    "commit": "3a6f6ba09e0f5d3de8737b5b1d45cc2014b4b8af",
    "filename": "tools/accuracy_checker/accuracy_checker/metrics/regression.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/openvinotoolkit-open_model_zoo/tools/accuracy_checker/accuracy_checker/metrics/regression.py",
    "file_hunks_size": 12,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "tools/accuracy_checker/accuracy_checker/metrics/regression.py:55:4 Inconsistent override [15]: `annotation_types` overrides attribute defined in `tools.accuracy_checker.accuracy_checker.metrics.metric.Metric` inconsistently. Type `typing.Tuple[typing.Type[tools.accuracy_checker.accuracy_checker.representation.regression_representation.RegressionAnnotation], typing.Type[tools.accuracy_checker.accuracy_checker.representation.regression_representation.FeaturesRegressionAnnotation], typing.Type[tools.accuracy_checker.accuracy_checker.representation.depth_estimation.DepthEstimationAnnotation], typing.Type[tools.accuracy_checker.accuracy_checker.representation.image_processing.ImageProcessingAnnotation]]` is not a subtype of the overridden attribute `typing.Tuple[]`.",
    "message": " `annotation_types` overrides attribute defined in `tools.accuracy_checker.accuracy_checker.metrics.metric.Metric` inconsistently. Type `typing.Tuple[typing.Type[tools.accuracy_checker.accuracy_checker.representation.regression_representation.RegressionAnnotation], typing.Type[tools.accuracy_checker.accuracy_checker.representation.regression_representation.FeaturesRegressionAnnotation], typing.Type[tools.accuracy_checker.accuracy_checker.representation.depth_estimation.DepthEstimationAnnotation], typing.Type[tools.accuracy_checker.accuracy_checker.representation.image_processing.ImageProcessingAnnotation]]` is not a subtype of the overridden attribute `typing.Tuple[]`.",
    "rule_id": "Inconsistent override [15]",
    "warning_line_no": 55,
    "warning_line": "    annotation_types = ("
  },
  {
    "project": "openvinotoolkit/open_model_zoo",
    "commit": "3a6f6ba09e0f5d3de8737b5b1d45cc2014b4b8af",
    "filename": "tools/accuracy_checker/accuracy_checker/metrics/regression.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/openvinotoolkit-open_model_zoo/tools/accuracy_checker/accuracy_checker/metrics/regression.py",
    "file_hunks_size": 12,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "tools/accuracy_checker/accuracy_checker/metrics/regression.py:58:4 Inconsistent override [15]: `prediction_types` overrides attribute defined in `tools.accuracy_checker.accuracy_checker.metrics.metric.Metric` inconsistently. Type `typing.Tuple[typing.Type[tools.accuracy_checker.accuracy_checker.representation.regression_representation.RegressionPrediction], typing.Type[tools.accuracy_checker.accuracy_checker.representation.depth_estimation.DepthEstimationPrediction], typing.Type[tools.accuracy_checker.accuracy_checker.representation.image_processing.ImageProcessingPrediction]]` is not a subtype of the overridden attribute `typing.Tuple[]`.",
    "message": " `prediction_types` overrides attribute defined in `tools.accuracy_checker.accuracy_checker.metrics.metric.Metric` inconsistently. Type `typing.Tuple[typing.Type[tools.accuracy_checker.accuracy_checker.representation.regression_representation.RegressionPrediction], typing.Type[tools.accuracy_checker.accuracy_checker.representation.depth_estimation.DepthEstimationPrediction], typing.Type[tools.accuracy_checker.accuracy_checker.representation.image_processing.ImageProcessingPrediction]]` is not a subtype of the overridden attribute `typing.Tuple[]`.",
    "rule_id": "Inconsistent override [15]",
    "warning_line_no": 58,
    "warning_line": "    prediction_types = (RegressionPrediction, DepthEstimationPrediction, ImageProcessingPrediction)"
  },
  {
    "project": "openvinotoolkit/open_model_zoo",
    "commit": "3a6f6ba09e0f5d3de8737b5b1d45cc2014b4b8af",
    "filename": "tools/accuracy_checker/accuracy_checker/metrics/regression.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/openvinotoolkit-open_model_zoo/tools/accuracy_checker/accuracy_checker/metrics/regression.py",
    "file_hunks_size": 12,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": true,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "tools/accuracy_checker/accuracy_checker/metrics/regression.py:552:4 Inconsistent override [15]: `annotation_types` overrides attribute defined in `BaseRegressionMetric` inconsistently. Type `typing.Tuple[typing.Type[tools.accuracy_checker.accuracy_checker.representation.super_resolution_representation.SuperResolutionAnnotation], typing.Type[tools.accuracy_checker.accuracy_checker.representation.image_inpainting.ImageInpaintingAnnotation], typing.Type[tools.accuracy_checker.accuracy_checker.representation.image_processing.ImageProcessingAnnotation], typing.Type[tools.accuracy_checker.accuracy_checker.representation.style_transfer.StyleTransferAnnotation]]` is not a subtype of the overridden attribute `typing.Tuple[typing.Type[tools.accuracy_checker.accuracy_checker.representation.regression_representation.RegressionAnnotation], typing.Type[tools.accuracy_checker.accuracy_checker.representation.regression_representation.FeaturesRegressionAnnotation], typing.Type[tools.accuracy_checker.accuracy_checker.representation.depth_estimation.DepthEstimationAnnotation], typing.Type[tools.accuracy_checker.accuracy_checker.representation.image_processing.ImageProcessingAnnotation]]`.",
    "message": " `annotation_types` overrides attribute defined in `BaseRegressionMetric` inconsistently. Type `typing.Tuple[typing.Type[tools.accuracy_checker.accuracy_checker.representation.super_resolution_representation.SuperResolutionAnnotation], typing.Type[tools.accuracy_checker.accuracy_checker.representation.image_inpainting.ImageInpaintingAnnotation], typing.Type[tools.accuracy_checker.accuracy_checker.representation.image_processing.ImageProcessingAnnotation], typing.Type[tools.accuracy_checker.accuracy_checker.representation.style_transfer.StyleTransferAnnotation]]` is not a subtype of the overridden attribute `typing.Tuple[typing.Type[tools.accuracy_checker.accuracy_checker.representation.regression_representation.RegressionAnnotation], typing.Type[tools.accuracy_checker.accuracy_checker.representation.regression_representation.FeaturesRegressionAnnotation], typing.Type[tools.accuracy_checker.accuracy_checker.representation.depth_estimation.DepthEstimationAnnotation], typing.Type[tools.accuracy_checker.accuracy_checker.representation.image_processing.ImageProcessingAnnotation]]`.",
    "rule_id": "Inconsistent override [15]",
    "warning_line_no": 552,
    "warning_line": "    annotation_types = (SuperResolutionAnnotation, ImageInpaintingAnnotation, ImageProcessingAnnotation,",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": true,
        "has_suppression": false,
        "source_code": "\nclass PeakSignalToNoiseRatio(BaseRegressionMetric):\n    __provider__ = 'psnr'\n\n    annotation_types = (SuperResolutionAnnotation, ImageInpaintingAnnotation, ImageProcessingAnnotation,\n                        StyleTransferAnnotation)\n    prediction_types = (SuperResolutionPrediction, ImageInpaintingPrediction, ImageProcessingPrediction,\n                        StyleTransferPrediction)\n\n    @classmethod\n    def parameters(cls):\n        parameters = super().parameters()\n        parameters.update({\n            'scale_border': NumberField(\n                optional=True, min_value=0, default=4, description=\"Scale border.\", value_type=int\n            ),\n            'color_order': StringField(\n                optional=True, choices=['BGR', 'RGB'], default='RGB',\n                description=\"The field specified which color order BGR or RGB will be used during metric calculation.\"\n            ),\n            'normalized_images': BoolField(optional=True, default=False, description='images in [0, 1] range or not')\n        })\n\n        return parameters\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(self._psnr_differ, *args, **kwargs)\n        self.meta['target'] = 'higher-better'\n\n    def configure(self):\n        super().configure()\n        self.scale_border = self.get_value_from_config('scale_border')\n        color_order = self.get_value_from_config('color_order')\n        channel_order = {\n            'BGR': [2, 1, 0],\n            'RGB': [0, 1, 2],\n        }\n        self.meta['postfix'] = 'Db'\n        self.channel_order = channel_order[color_order]\n        self.normalized_images = self.get_value_from_config('normalized_images')\n        self.color_scale = 255 if not self.normalized_images else 1\n\n    def _psnr_differ(self, annotation_image, prediction_image):\n        prediction = np.asarray(prediction_image).astype(np.float)\n        ground_truth = np.asarray(annotation_image).astype(np.float)\n\n        height, width = prediction.shape[:2]\n        prediction = prediction[\n            self.scale_border:height - self.scale_border,\n            self.scale_border:width - self.scale_border\n        ]\n        ground_truth = ground_truth[\n            self.scale_border:height - self.scale_border,\n            self.scale_border:width - self.scale_border\n        ]\n        image_difference = (prediction - ground_truth) / self.color_scale\n        if len(ground_truth.shape) == 3 and ground_truth.shape[2] == 3:\n            r_channel_diff = image_difference[:, :, self.channel_order[0]]\n            g_channel_diff = image_difference[:, :, self.channel_order[1]]\n            b_channel_diff = image_difference[:, :, self.channel_order[2]]\n\n            channels_diff = (r_channel_diff * 65.738 + g_channel_diff * 129.057 + b_channel_diff * 25.064) / 256\n\n            mse = np.mean(channels_diff ** 2)\n            if mse == 0:\n                return np.Infinity\n        else:\n            mse = np.mean(image_difference ** 2)\n\n        return -10 * math.log10(mse)\n\n\n",
        "source_code_len": 2991,
        "target_code": "\n\n",
        "target_code_len": 2,
        "diff_format": "@@ -548,72 +565,2 @@\n \n-class PeakSignalToNoiseRatio(BaseRegressionMetric):\n-    __provider__ = 'psnr'\n-\n-    annotation_types = (SuperResolutionAnnotation, ImageInpaintingAnnotation, ImageProcessingAnnotation,\n-                        StyleTransferAnnotation)\n-    prediction_types = (SuperResolutionPrediction, ImageInpaintingPrediction, ImageProcessingPrediction,\n-                        StyleTransferPrediction)\n-\n-    @classmethod\n-    def parameters(cls):\n-        parameters = super().parameters()\n-        parameters.update({\n-            'scale_border': NumberField(\n-                optional=True, min_value=0, default=4, description=\"Scale border.\", value_type=int\n-            ),\n-            'color_order': StringField(\n-                optional=True, choices=['BGR', 'RGB'], default='RGB',\n-                description=\"The field specified which color order BGR or RGB will be used during metric calculation.\"\n-            ),\n-            'normalized_images': BoolField(optional=True, default=False, description='images in [0, 1] range or not')\n-        })\n-\n-        return parameters\n-\n-    def __init__(self, *args, **kwargs):\n-        super().__init__(self._psnr_differ, *args, **kwargs)\n-        self.meta['target'] = 'higher-better'\n-\n-    def configure(self):\n-        super().configure()\n-        self.scale_border = self.get_value_from_config('scale_border')\n-        color_order = self.get_value_from_config('color_order')\n-        channel_order = {\n-            'BGR': [2, 1, 0],\n-            'RGB': [0, 1, 2],\n-        }\n-        self.meta['postfix'] = 'Db'\n-        self.channel_order = channel_order[color_order]\n-        self.normalized_images = self.get_value_from_config('normalized_images')\n-        self.color_scale = 255 if not self.normalized_images else 1\n-\n-    def _psnr_differ(self, annotation_image, prediction_image):\n-        prediction = np.asarray(prediction_image).astype(np.float)\n-        ground_truth = np.asarray(annotation_image).astype(np.float)\n-\n-        height, width = prediction.shape[:2]\n-        prediction = prediction[\n-            self.scale_border:height - self.scale_border,\n-            self.scale_border:width - self.scale_border\n-        ]\n-        ground_truth = ground_truth[\n-            self.scale_border:height - self.scale_border,\n-            self.scale_border:width - self.scale_border\n-        ]\n-        image_difference = (prediction - ground_truth) / self.color_scale\n-        if len(ground_truth.shape) == 3 and ground_truth.shape[2] == 3:\n-            r_channel_diff = image_difference[:, :, self.channel_order[0]]\n-            g_channel_diff = image_difference[:, :, self.channel_order[1]]\n-            b_channel_diff = image_difference[:, :, self.channel_order[2]]\n-\n-            channels_diff = (r_channel_diff * 65.738 + g_channel_diff * 129.057 + b_channel_diff * 25.064) / 256\n-\n-            mse = np.mean(channels_diff ** 2)\n-            if mse == 0:\n-                return np.Infinity\n-        else:\n-            mse = np.mean(image_difference ** 2)\n-\n-        return -10 * math.log10(mse)\n-\n \n",
        "source_code_with_indent": "\n<DED>class PeakSignalToNoiseRatio(BaseRegressionMetric):\n    <IND>__provider__ = 'psnr'\n\n    annotation_types = (SuperResolutionAnnotation, ImageInpaintingAnnotation, ImageProcessingAnnotation,\n                        StyleTransferAnnotation)\n    prediction_types = (SuperResolutionPrediction, ImageInpaintingPrediction, ImageProcessingPrediction,\n                        StyleTransferPrediction)\n\n    @classmethod\n    def parameters(cls):\n        <IND>parameters = super().parameters()\n        parameters.update({\n            'scale_border': NumberField(\n                optional=True, min_value=0, default=4, description=\"Scale border.\", value_type=int\n            ),\n            'color_order': StringField(\n                optional=True, choices=['BGR', 'RGB'], default='RGB',\n                description=\"The field specified which color order BGR or RGB will be used during metric calculation.\"\n            ),\n            'normalized_images': BoolField(optional=True, default=False, description='images in [0, 1] range or not')\n        })\n\n        return parameters\n\n    <DED>def __init__(self, *args, **kwargs):\n        <IND>super().__init__(self._psnr_differ, *args, **kwargs)\n        self.meta['target'] = 'higher-better'\n\n    <DED>def configure(self):\n        <IND>super().configure()\n        self.scale_border = self.get_value_from_config('scale_border')\n        color_order = self.get_value_from_config('color_order')\n        channel_order = {\n            'BGR': [2, 1, 0],\n            'RGB': [0, 1, 2],\n        }\n        self.meta['postfix'] = 'Db'\n        self.channel_order = channel_order[color_order]\n        self.normalized_images = self.get_value_from_config('normalized_images')\n        self.color_scale = 255 if not self.normalized_images else 1\n\n    <DED>def _psnr_differ(self, annotation_image, prediction_image):\n        <IND>prediction = np.asarray(prediction_image).astype(np.float)\n        ground_truth = np.asarray(annotation_image).astype(np.float)\n\n        height, width = prediction.shape[:2]\n        prediction = prediction[\n            self.scale_border:height - self.scale_border,\n            self.scale_border:width - self.scale_border\n        ]\n        ground_truth = ground_truth[\n            self.scale_border:height - self.scale_border,\n            self.scale_border:width - self.scale_border\n        ]\n        image_difference = (prediction - ground_truth) / self.color_scale\n        if len(ground_truth.shape) == 3 and ground_truth.shape[2] == 3:\n            <IND>r_channel_diff = image_difference[:, :, self.channel_order[0]]\n            g_channel_diff = image_difference[:, :, self.channel_order[1]]\n            b_channel_diff = image_difference[:, :, self.channel_order[2]]\n\n            channels_diff = (r_channel_diff * 65.738 + g_channel_diff * 129.057 + b_channel_diff * 25.064) / 256\n\n            mse = np.mean(channels_diff ** 2)\n            if mse == 0:\n                <IND>return np.Infinity\n        <DED><DED>else:\n            <IND>mse = np.mean(image_difference ** 2)\n\n        <DED>return -10 * math.log10(mse)\n\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "openvinotoolkit/open_model_zoo",
    "commit": "3a6f6ba09e0f5d3de8737b5b1d45cc2014b4b8af",
    "filename": "tools/accuracy_checker/accuracy_checker/metrics/regression.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/openvinotoolkit-open_model_zoo/tools/accuracy_checker/accuracy_checker/metrics/regression.py",
    "file_hunks_size": 12,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": true,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "tools/accuracy_checker/accuracy_checker/metrics/regression.py:554:4 Inconsistent override [15]: `prediction_types` overrides attribute defined in `BaseRegressionMetric` inconsistently. Type `typing.Tuple[typing.Type[tools.accuracy_checker.accuracy_checker.representation.super_resolution_representation.SuperResolutionPrediction], typing.Type[tools.accuracy_checker.accuracy_checker.representation.image_inpainting.ImageInpaintingPrediction], typing.Type[tools.accuracy_checker.accuracy_checker.representation.image_processing.ImageProcessingPrediction], typing.Type[tools.accuracy_checker.accuracy_checker.representation.style_transfer.StyleTransferPrediction]]` is not a subtype of the overridden attribute `typing.Tuple[typing.Type[tools.accuracy_checker.accuracy_checker.representation.regression_representation.RegressionPrediction], typing.Type[tools.accuracy_checker.accuracy_checker.representation.depth_estimation.DepthEstimationPrediction], typing.Type[tools.accuracy_checker.accuracy_checker.representation.image_processing.ImageProcessingPrediction]]`.",
    "message": " `prediction_types` overrides attribute defined in `BaseRegressionMetric` inconsistently. Type `typing.Tuple[typing.Type[tools.accuracy_checker.accuracy_checker.representation.super_resolution_representation.SuperResolutionPrediction], typing.Type[tools.accuracy_checker.accuracy_checker.representation.image_inpainting.ImageInpaintingPrediction], typing.Type[tools.accuracy_checker.accuracy_checker.representation.image_processing.ImageProcessingPrediction], typing.Type[tools.accuracy_checker.accuracy_checker.representation.style_transfer.StyleTransferPrediction]]` is not a subtype of the overridden attribute `typing.Tuple[typing.Type[tools.accuracy_checker.accuracy_checker.representation.regression_representation.RegressionPrediction], typing.Type[tools.accuracy_checker.accuracy_checker.representation.depth_estimation.DepthEstimationPrediction], typing.Type[tools.accuracy_checker.accuracy_checker.representation.image_processing.ImageProcessingPrediction]]`.",
    "rule_id": "Inconsistent override [15]",
    "warning_line_no": 554,
    "warning_line": "    prediction_types = (SuperResolutionPrediction, ImageInpaintingPrediction, ImageProcessingPrediction,",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": true,
        "has_suppression": false,
        "source_code": "\nclass PeakSignalToNoiseRatio(BaseRegressionMetric):\n    __provider__ = 'psnr'\n\n    annotation_types = (SuperResolutionAnnotation, ImageInpaintingAnnotation, ImageProcessingAnnotation,\n                        StyleTransferAnnotation)\n    prediction_types = (SuperResolutionPrediction, ImageInpaintingPrediction, ImageProcessingPrediction,\n                        StyleTransferPrediction)\n\n    @classmethod\n    def parameters(cls):\n        parameters = super().parameters()\n        parameters.update({\n            'scale_border': NumberField(\n                optional=True, min_value=0, default=4, description=\"Scale border.\", value_type=int\n            ),\n            'color_order': StringField(\n                optional=True, choices=['BGR', 'RGB'], default='RGB',\n                description=\"The field specified which color order BGR or RGB will be used during metric calculation.\"\n            ),\n            'normalized_images': BoolField(optional=True, default=False, description='images in [0, 1] range or not')\n        })\n\n        return parameters\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(self._psnr_differ, *args, **kwargs)\n        self.meta['target'] = 'higher-better'\n\n    def configure(self):\n        super().configure()\n        self.scale_border = self.get_value_from_config('scale_border')\n        color_order = self.get_value_from_config('color_order')\n        channel_order = {\n            'BGR': [2, 1, 0],\n            'RGB': [0, 1, 2],\n        }\n        self.meta['postfix'] = 'Db'\n        self.channel_order = channel_order[color_order]\n        self.normalized_images = self.get_value_from_config('normalized_images')\n        self.color_scale = 255 if not self.normalized_images else 1\n\n    def _psnr_differ(self, annotation_image, prediction_image):\n        prediction = np.asarray(prediction_image).astype(np.float)\n        ground_truth = np.asarray(annotation_image).astype(np.float)\n\n        height, width = prediction.shape[:2]\n        prediction = prediction[\n            self.scale_border:height - self.scale_border,\n            self.scale_border:width - self.scale_border\n        ]\n        ground_truth = ground_truth[\n            self.scale_border:height - self.scale_border,\n            self.scale_border:width - self.scale_border\n        ]\n        image_difference = (prediction - ground_truth) / self.color_scale\n        if len(ground_truth.shape) == 3 and ground_truth.shape[2] == 3:\n            r_channel_diff = image_difference[:, :, self.channel_order[0]]\n            g_channel_diff = image_difference[:, :, self.channel_order[1]]\n            b_channel_diff = image_difference[:, :, self.channel_order[2]]\n\n            channels_diff = (r_channel_diff * 65.738 + g_channel_diff * 129.057 + b_channel_diff * 25.064) / 256\n\n            mse = np.mean(channels_diff ** 2)\n            if mse == 0:\n                return np.Infinity\n        else:\n            mse = np.mean(image_difference ** 2)\n\n        return -10 * math.log10(mse)\n\n\n",
        "source_code_len": 2991,
        "target_code": "\n\n",
        "target_code_len": 2,
        "diff_format": "@@ -548,72 +565,2 @@\n \n-class PeakSignalToNoiseRatio(BaseRegressionMetric):\n-    __provider__ = 'psnr'\n-\n-    annotation_types = (SuperResolutionAnnotation, ImageInpaintingAnnotation, ImageProcessingAnnotation,\n-                        StyleTransferAnnotation)\n-    prediction_types = (SuperResolutionPrediction, ImageInpaintingPrediction, ImageProcessingPrediction,\n-                        StyleTransferPrediction)\n-\n-    @classmethod\n-    def parameters(cls):\n-        parameters = super().parameters()\n-        parameters.update({\n-            'scale_border': NumberField(\n-                optional=True, min_value=0, default=4, description=\"Scale border.\", value_type=int\n-            ),\n-            'color_order': StringField(\n-                optional=True, choices=['BGR', 'RGB'], default='RGB',\n-                description=\"The field specified which color order BGR or RGB will be used during metric calculation.\"\n-            ),\n-            'normalized_images': BoolField(optional=True, default=False, description='images in [0, 1] range or not')\n-        })\n-\n-        return parameters\n-\n-    def __init__(self, *args, **kwargs):\n-        super().__init__(self._psnr_differ, *args, **kwargs)\n-        self.meta['target'] = 'higher-better'\n-\n-    def configure(self):\n-        super().configure()\n-        self.scale_border = self.get_value_from_config('scale_border')\n-        color_order = self.get_value_from_config('color_order')\n-        channel_order = {\n-            'BGR': [2, 1, 0],\n-            'RGB': [0, 1, 2],\n-        }\n-        self.meta['postfix'] = 'Db'\n-        self.channel_order = channel_order[color_order]\n-        self.normalized_images = self.get_value_from_config('normalized_images')\n-        self.color_scale = 255 if not self.normalized_images else 1\n-\n-    def _psnr_differ(self, annotation_image, prediction_image):\n-        prediction = np.asarray(prediction_image).astype(np.float)\n-        ground_truth = np.asarray(annotation_image).astype(np.float)\n-\n-        height, width = prediction.shape[:2]\n-        prediction = prediction[\n-            self.scale_border:height - self.scale_border,\n-            self.scale_border:width - self.scale_border\n-        ]\n-        ground_truth = ground_truth[\n-            self.scale_border:height - self.scale_border,\n-            self.scale_border:width - self.scale_border\n-        ]\n-        image_difference = (prediction - ground_truth) / self.color_scale\n-        if len(ground_truth.shape) == 3 and ground_truth.shape[2] == 3:\n-            r_channel_diff = image_difference[:, :, self.channel_order[0]]\n-            g_channel_diff = image_difference[:, :, self.channel_order[1]]\n-            b_channel_diff = image_difference[:, :, self.channel_order[2]]\n-\n-            channels_diff = (r_channel_diff * 65.738 + g_channel_diff * 129.057 + b_channel_diff * 25.064) / 256\n-\n-            mse = np.mean(channels_diff ** 2)\n-            if mse == 0:\n-                return np.Infinity\n-        else:\n-            mse = np.mean(image_difference ** 2)\n-\n-        return -10 * math.log10(mse)\n-\n \n",
        "source_code_with_indent": "\n<DED>class PeakSignalToNoiseRatio(BaseRegressionMetric):\n    <IND>__provider__ = 'psnr'\n\n    annotation_types = (SuperResolutionAnnotation, ImageInpaintingAnnotation, ImageProcessingAnnotation,\n                        StyleTransferAnnotation)\n    prediction_types = (SuperResolutionPrediction, ImageInpaintingPrediction, ImageProcessingPrediction,\n                        StyleTransferPrediction)\n\n    @classmethod\n    def parameters(cls):\n        <IND>parameters = super().parameters()\n        parameters.update({\n            'scale_border': NumberField(\n                optional=True, min_value=0, default=4, description=\"Scale border.\", value_type=int\n            ),\n            'color_order': StringField(\n                optional=True, choices=['BGR', 'RGB'], default='RGB',\n                description=\"The field specified which color order BGR or RGB will be used during metric calculation.\"\n            ),\n            'normalized_images': BoolField(optional=True, default=False, description='images in [0, 1] range or not')\n        })\n\n        return parameters\n\n    <DED>def __init__(self, *args, **kwargs):\n        <IND>super().__init__(self._psnr_differ, *args, **kwargs)\n        self.meta['target'] = 'higher-better'\n\n    <DED>def configure(self):\n        <IND>super().configure()\n        self.scale_border = self.get_value_from_config('scale_border')\n        color_order = self.get_value_from_config('color_order')\n        channel_order = {\n            'BGR': [2, 1, 0],\n            'RGB': [0, 1, 2],\n        }\n        self.meta['postfix'] = 'Db'\n        self.channel_order = channel_order[color_order]\n        self.normalized_images = self.get_value_from_config('normalized_images')\n        self.color_scale = 255 if not self.normalized_images else 1\n\n    <DED>def _psnr_differ(self, annotation_image, prediction_image):\n        <IND>prediction = np.asarray(prediction_image).astype(np.float)\n        ground_truth = np.asarray(annotation_image).astype(np.float)\n\n        height, width = prediction.shape[:2]\n        prediction = prediction[\n            self.scale_border:height - self.scale_border,\n            self.scale_border:width - self.scale_border\n        ]\n        ground_truth = ground_truth[\n            self.scale_border:height - self.scale_border,\n            self.scale_border:width - self.scale_border\n        ]\n        image_difference = (prediction - ground_truth) / self.color_scale\n        if len(ground_truth.shape) == 3 and ground_truth.shape[2] == 3:\n            <IND>r_channel_diff = image_difference[:, :, self.channel_order[0]]\n            g_channel_diff = image_difference[:, :, self.channel_order[1]]\n            b_channel_diff = image_difference[:, :, self.channel_order[2]]\n\n            channels_diff = (r_channel_diff * 65.738 + g_channel_diff * 129.057 + b_channel_diff * 25.064) / 256\n\n            mse = np.mean(channels_diff ** 2)\n            if mse == 0:\n                <IND>return np.Infinity\n        <DED><DED>else:\n            <IND>mse = np.mean(image_difference ** 2)\n\n        <DED>return -10 * math.log10(mse)\n\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "openvinotoolkit/open_model_zoo",
    "commit": "3a6f6ba09e0f5d3de8737b5b1d45cc2014b4b8af",
    "filename": "tools/accuracy_checker/accuracy_checker/metrics/regression.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/openvinotoolkit-open_model_zoo/tools/accuracy_checker/accuracy_checker/metrics/regression.py",
    "file_hunks_size": 12,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "tools/accuracy_checker/accuracy_checker/metrics/regression.py:638:4 Inconsistent override [15]: `annotation_types` overrides attribute defined in `BaseRegressionMetric` inconsistently. Type `typing.Tuple[typing.Type[tools.accuracy_checker.accuracy_checker.representation.regression_representation.GazeVectorAnnotation]]` is not a subtype of the overridden attribute `typing.Tuple[typing.Type[tools.accuracy_checker.accuracy_checker.representation.regression_representation.RegressionAnnotation], typing.Type[tools.accuracy_checker.accuracy_checker.representation.regression_representation.FeaturesRegressionAnnotation], typing.Type[tools.accuracy_checker.accuracy_checker.representation.depth_estimation.DepthEstimationAnnotation], typing.Type[tools.accuracy_checker.accuracy_checker.representation.image_processing.ImageProcessingAnnotation]]`.",
    "message": " `annotation_types` overrides attribute defined in `BaseRegressionMetric` inconsistently. Type `typing.Tuple[typing.Type[tools.accuracy_checker.accuracy_checker.representation.regression_representation.GazeVectorAnnotation]]` is not a subtype of the overridden attribute `typing.Tuple[typing.Type[tools.accuracy_checker.accuracy_checker.representation.regression_representation.RegressionAnnotation], typing.Type[tools.accuracy_checker.accuracy_checker.representation.regression_representation.FeaturesRegressionAnnotation], typing.Type[tools.accuracy_checker.accuracy_checker.representation.depth_estimation.DepthEstimationAnnotation], typing.Type[tools.accuracy_checker.accuracy_checker.representation.image_processing.ImageProcessingAnnotation]]`.",
    "rule_id": "Inconsistent override [15]",
    "warning_line_no": 638,
    "warning_line": "    annotation_types = (GazeVectorAnnotation, )"
  },
  {
    "project": "openvinotoolkit/open_model_zoo",
    "commit": "3a6f6ba09e0f5d3de8737b5b1d45cc2014b4b8af",
    "filename": "tools/accuracy_checker/accuracy_checker/metrics/regression.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/openvinotoolkit-open_model_zoo/tools/accuracy_checker/accuracy_checker/metrics/regression.py",
    "file_hunks_size": 12,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "tools/accuracy_checker/accuracy_checker/metrics/regression.py:639:4 Inconsistent override [15]: `prediction_types` overrides attribute defined in `BaseRegressionMetric` inconsistently. Type `typing.Tuple[typing.Type[tools.accuracy_checker.accuracy_checker.representation.regression_representation.GazeVectorPrediction]]` is not a subtype of the overridden attribute `typing.Tuple[typing.Type[tools.accuracy_checker.accuracy_checker.representation.regression_representation.RegressionPrediction], typing.Type[tools.accuracy_checker.accuracy_checker.representation.depth_estimation.DepthEstimationPrediction], typing.Type[tools.accuracy_checker.accuracy_checker.representation.image_processing.ImageProcessingPrediction]]`.",
    "message": " `prediction_types` overrides attribute defined in `BaseRegressionMetric` inconsistently. Type `typing.Tuple[typing.Type[tools.accuracy_checker.accuracy_checker.representation.regression_representation.GazeVectorPrediction]]` is not a subtype of the overridden attribute `typing.Tuple[typing.Type[tools.accuracy_checker.accuracy_checker.representation.regression_representation.RegressionPrediction], typing.Type[tools.accuracy_checker.accuracy_checker.representation.depth_estimation.DepthEstimationPrediction], typing.Type[tools.accuracy_checker.accuracy_checker.representation.image_processing.ImageProcessingPrediction]]`.",
    "rule_id": "Inconsistent override [15]",
    "warning_line_no": 639,
    "warning_line": "    prediction_types = (GazeVectorPrediction, )"
  },
  {
    "project": "openvinotoolkit/open_model_zoo",
    "commit": "3a6f6ba09e0f5d3de8737b5b1d45cc2014b4b8af",
    "filename": "tools/accuracy_checker/accuracy_checker/metrics/regression.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/openvinotoolkit-open_model_zoo/tools/accuracy_checker/accuracy_checker/metrics/regression.py",
    "file_hunks_size": 12,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": true,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "tools/accuracy_checker/accuracy_checker/metrics/regression.py:663:4 Inconsistent override [15]: `annotation_types` overrides attribute defined in `BaseRegressionMetric` inconsistently. Type `typing.Tuple[typing.Type[tools.accuracy_checker.accuracy_checker.representation.image_inpainting.ImageInpaintingAnnotation], typing.Type[tools.accuracy_checker.accuracy_checker.representation.image_processing.ImageProcessingAnnotation], typing.Type[tools.accuracy_checker.accuracy_checker.representation.super_resolution_representation.SuperResolutionAnnotation], typing.Type[tools.accuracy_checker.accuracy_checker.representation.style_transfer.StyleTransferAnnotation]]` is not a subtype of the overridden attribute `typing.Tuple[typing.Type[tools.accuracy_checker.accuracy_checker.representation.regression_representation.RegressionAnnotation], typing.Type[tools.accuracy_checker.accuracy_checker.representation.regression_representation.FeaturesRegressionAnnotation], typing.Type[tools.accuracy_checker.accuracy_checker.representation.depth_estimation.DepthEstimationAnnotation], typing.Type[tools.accuracy_checker.accuracy_checker.representation.image_processing.ImageProcessingAnnotation]]`.",
    "message": " `annotation_types` overrides attribute defined in `BaseRegressionMetric` inconsistently. Type `typing.Tuple[typing.Type[tools.accuracy_checker.accuracy_checker.representation.image_inpainting.ImageInpaintingAnnotation], typing.Type[tools.accuracy_checker.accuracy_checker.representation.image_processing.ImageProcessingAnnotation], typing.Type[tools.accuracy_checker.accuracy_checker.representation.super_resolution_representation.SuperResolutionAnnotation], typing.Type[tools.accuracy_checker.accuracy_checker.representation.style_transfer.StyleTransferAnnotation]]` is not a subtype of the overridden attribute `typing.Tuple[typing.Type[tools.accuracy_checker.accuracy_checker.representation.regression_representation.RegressionAnnotation], typing.Type[tools.accuracy_checker.accuracy_checker.representation.regression_representation.FeaturesRegressionAnnotation], typing.Type[tools.accuracy_checker.accuracy_checker.representation.depth_estimation.DepthEstimationAnnotation], typing.Type[tools.accuracy_checker.accuracy_checker.representation.image_processing.ImageProcessingAnnotation]]`.",
    "rule_id": "Inconsistent override [15]",
    "warning_line_no": 663,
    "warning_line": "    annotation_types = (ImageInpaintingAnnotation, ImageProcessingAnnotation, SuperResolutionAnnotation,",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": true,
        "has_suppression": false,
        "source_code": "        super().__init__(angle_differ, *args, **kwargs)\n\n\ndef _ssim(annotation_image, prediction_image):\n    prediction = np.asarray(prediction_image)\n    ground_truth = np.asarray(annotation_image)\n    if len(ground_truth.shape) < len(prediction.shape) and prediction.shape[-1] == 1:\n        prediction = np.squeeze(prediction)\n    mu_x = np.mean(prediction)\n    mu_y = np.mean(ground_truth)\n    var_x = np.var(prediction)\n    var_y = np.var(ground_truth)\n    sig_xy = np.mean((prediction - mu_x)*(ground_truth - mu_y))\n    c1 = (0.01 * 2**8-1)**2\n    c2 = (0.03 * 2**8-1)**2\n    mssim = (2*mu_x*mu_y + c1)*(2*sig_xy + c2)/((mu_x**2 + mu_y**2 + c1)*(var_x + var_y + c2))\n    return mssim\n\n\nclass StructuralSimilarity(BaseRegressionMetric):\n    __provider__ = 'ssim'\n    annotation_types = (ImageInpaintingAnnotation, ImageProcessingAnnotation, SuperResolutionAnnotation,\n                        StyleTransferAnnotation)\n    prediction_types = (ImageInpaintingPrediction, ImageProcessingPrediction, SuperResolutionPrediction,\n                        StyleTransferPrediction)\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(_ssim, *args, **kwargs)\n        self.meta['target'] = 'higher-better'\n\n",
        "source_code_len": 1213,
        "target_code": "        super().__init__(angle_differ, *args, **kwargs)\n\n",
        "target_code_len": 57,
        "diff_format": "@@ -642,30 +589,2 @@\n         super().__init__(angle_differ, *args, **kwargs)\n-\n-\n-def _ssim(annotation_image, prediction_image):\n-    prediction = np.asarray(prediction_image)\n-    ground_truth = np.asarray(annotation_image)\n-    if len(ground_truth.shape) < len(prediction.shape) and prediction.shape[-1] == 1:\n-        prediction = np.squeeze(prediction)\n-    mu_x = np.mean(prediction)\n-    mu_y = np.mean(ground_truth)\n-    var_x = np.var(prediction)\n-    var_y = np.var(ground_truth)\n-    sig_xy = np.mean((prediction - mu_x)*(ground_truth - mu_y))\n-    c1 = (0.01 * 2**8-1)**2\n-    c2 = (0.03 * 2**8-1)**2\n-    mssim = (2*mu_x*mu_y + c1)*(2*sig_xy + c2)/((mu_x**2 + mu_y**2 + c1)*(var_x + var_y + c2))\n-    return mssim\n-\n-\n-class StructuralSimilarity(BaseRegressionMetric):\n-    __provider__ = 'ssim'\n-    annotation_types = (ImageInpaintingAnnotation, ImageProcessingAnnotation, SuperResolutionAnnotation,\n-                        StyleTransferAnnotation)\n-    prediction_types = (ImageInpaintingPrediction, ImageProcessingPrediction, SuperResolutionPrediction,\n-                        StyleTransferPrediction)\n-\n-    def __init__(self, *args, **kwargs):\n-        super().__init__(_ssim, *args, **kwargs)\n-        self.meta['target'] = 'higher-better'\n \n",
        "source_code_with_indent": "        <IND>super().__init__(angle_differ, *args, **kwargs)\n\n\n<DED><DED>def _ssim(annotation_image, prediction_image):\n    <IND>prediction = np.asarray(prediction_image)\n    ground_truth = np.asarray(annotation_image)\n    if len(ground_truth.shape) < len(prediction.shape) and prediction.shape[-1] == 1:\n        <IND>prediction = np.squeeze(prediction)\n    <DED>mu_x = np.mean(prediction)\n    mu_y = np.mean(ground_truth)\n    var_x = np.var(prediction)\n    var_y = np.var(ground_truth)\n    sig_xy = np.mean((prediction - mu_x)*(ground_truth - mu_y))\n    c1 = (0.01 * 2**8-1)**2\n    c2 = (0.03 * 2**8-1)**2\n    mssim = (2*mu_x*mu_y + c1)*(2*sig_xy + c2)/((mu_x**2 + mu_y**2 + c1)*(var_x + var_y + c2))\n    return mssim\n\n\n<DED>class StructuralSimilarity(BaseRegressionMetric):\n    <IND>__provider__ = 'ssim'\n    annotation_types = (ImageInpaintingAnnotation, ImageProcessingAnnotation, SuperResolutionAnnotation,\n                        StyleTransferAnnotation)\n    prediction_types = (ImageInpaintingPrediction, ImageProcessingPrediction, SuperResolutionPrediction,\n                        StyleTransferPrediction)\n\n    def __init__(self, *args, **kwargs):\n        <IND>super().__init__(_ssim, *args, **kwargs)\n        self.meta['target'] = 'higher-better'\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "        <IND>super().__init__(angle_differ, *args, **kwargs)\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "openvinotoolkit/open_model_zoo",
    "commit": "3a6f6ba09e0f5d3de8737b5b1d45cc2014b4b8af",
    "filename": "tools/accuracy_checker/accuracy_checker/metrics/regression.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/openvinotoolkit-open_model_zoo/tools/accuracy_checker/accuracy_checker/metrics/regression.py",
    "file_hunks_size": 12,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": true,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "tools/accuracy_checker/accuracy_checker/metrics/regression.py:665:4 Inconsistent override [15]: `prediction_types` overrides attribute defined in `BaseRegressionMetric` inconsistently. Type `typing.Tuple[typing.Type[tools.accuracy_checker.accuracy_checker.representation.image_inpainting.ImageInpaintingPrediction], typing.Type[tools.accuracy_checker.accuracy_checker.representation.image_processing.ImageProcessingPrediction], typing.Type[tools.accuracy_checker.accuracy_checker.representation.super_resolution_representation.SuperResolutionPrediction], typing.Type[tools.accuracy_checker.accuracy_checker.representation.style_transfer.StyleTransferPrediction]]` is not a subtype of the overridden attribute `typing.Tuple[typing.Type[tools.accuracy_checker.accuracy_checker.representation.regression_representation.RegressionPrediction], typing.Type[tools.accuracy_checker.accuracy_checker.representation.depth_estimation.DepthEstimationPrediction], typing.Type[tools.accuracy_checker.accuracy_checker.representation.image_processing.ImageProcessingPrediction]]`.",
    "message": " `prediction_types` overrides attribute defined in `BaseRegressionMetric` inconsistently. Type `typing.Tuple[typing.Type[tools.accuracy_checker.accuracy_checker.representation.image_inpainting.ImageInpaintingPrediction], typing.Type[tools.accuracy_checker.accuracy_checker.representation.image_processing.ImageProcessingPrediction], typing.Type[tools.accuracy_checker.accuracy_checker.representation.super_resolution_representation.SuperResolutionPrediction], typing.Type[tools.accuracy_checker.accuracy_checker.representation.style_transfer.StyleTransferPrediction]]` is not a subtype of the overridden attribute `typing.Tuple[typing.Type[tools.accuracy_checker.accuracy_checker.representation.regression_representation.RegressionPrediction], typing.Type[tools.accuracy_checker.accuracy_checker.representation.depth_estimation.DepthEstimationPrediction], typing.Type[tools.accuracy_checker.accuracy_checker.representation.image_processing.ImageProcessingPrediction]]`.",
    "rule_id": "Inconsistent override [15]",
    "warning_line_no": 665,
    "warning_line": "    prediction_types = (ImageInpaintingPrediction, ImageProcessingPrediction, SuperResolutionPrediction,",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": true,
        "has_suppression": false,
        "source_code": "        super().__init__(angle_differ, *args, **kwargs)\n\n\ndef _ssim(annotation_image, prediction_image):\n    prediction = np.asarray(prediction_image)\n    ground_truth = np.asarray(annotation_image)\n    if len(ground_truth.shape) < len(prediction.shape) and prediction.shape[-1] == 1:\n        prediction = np.squeeze(prediction)\n    mu_x = np.mean(prediction)\n    mu_y = np.mean(ground_truth)\n    var_x = np.var(prediction)\n    var_y = np.var(ground_truth)\n    sig_xy = np.mean((prediction - mu_x)*(ground_truth - mu_y))\n    c1 = (0.01 * 2**8-1)**2\n    c2 = (0.03 * 2**8-1)**2\n    mssim = (2*mu_x*mu_y + c1)*(2*sig_xy + c2)/((mu_x**2 + mu_y**2 + c1)*(var_x + var_y + c2))\n    return mssim\n\n\nclass StructuralSimilarity(BaseRegressionMetric):\n    __provider__ = 'ssim'\n    annotation_types = (ImageInpaintingAnnotation, ImageProcessingAnnotation, SuperResolutionAnnotation,\n                        StyleTransferAnnotation)\n    prediction_types = (ImageInpaintingPrediction, ImageProcessingPrediction, SuperResolutionPrediction,\n                        StyleTransferPrediction)\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(_ssim, *args, **kwargs)\n        self.meta['target'] = 'higher-better'\n\n",
        "source_code_len": 1213,
        "target_code": "        super().__init__(angle_differ, *args, **kwargs)\n\n",
        "target_code_len": 57,
        "diff_format": "@@ -642,30 +589,2 @@\n         super().__init__(angle_differ, *args, **kwargs)\n-\n-\n-def _ssim(annotation_image, prediction_image):\n-    prediction = np.asarray(prediction_image)\n-    ground_truth = np.asarray(annotation_image)\n-    if len(ground_truth.shape) < len(prediction.shape) and prediction.shape[-1] == 1:\n-        prediction = np.squeeze(prediction)\n-    mu_x = np.mean(prediction)\n-    mu_y = np.mean(ground_truth)\n-    var_x = np.var(prediction)\n-    var_y = np.var(ground_truth)\n-    sig_xy = np.mean((prediction - mu_x)*(ground_truth - mu_y))\n-    c1 = (0.01 * 2**8-1)**2\n-    c2 = (0.03 * 2**8-1)**2\n-    mssim = (2*mu_x*mu_y + c1)*(2*sig_xy + c2)/((mu_x**2 + mu_y**2 + c1)*(var_x + var_y + c2))\n-    return mssim\n-\n-\n-class StructuralSimilarity(BaseRegressionMetric):\n-    __provider__ = 'ssim'\n-    annotation_types = (ImageInpaintingAnnotation, ImageProcessingAnnotation, SuperResolutionAnnotation,\n-                        StyleTransferAnnotation)\n-    prediction_types = (ImageInpaintingPrediction, ImageProcessingPrediction, SuperResolutionPrediction,\n-                        StyleTransferPrediction)\n-\n-    def __init__(self, *args, **kwargs):\n-        super().__init__(_ssim, *args, **kwargs)\n-        self.meta['target'] = 'higher-better'\n \n",
        "source_code_with_indent": "        <IND>super().__init__(angle_differ, *args, **kwargs)\n\n\n<DED><DED>def _ssim(annotation_image, prediction_image):\n    <IND>prediction = np.asarray(prediction_image)\n    ground_truth = np.asarray(annotation_image)\n    if len(ground_truth.shape) < len(prediction.shape) and prediction.shape[-1] == 1:\n        <IND>prediction = np.squeeze(prediction)\n    <DED>mu_x = np.mean(prediction)\n    mu_y = np.mean(ground_truth)\n    var_x = np.var(prediction)\n    var_y = np.var(ground_truth)\n    sig_xy = np.mean((prediction - mu_x)*(ground_truth - mu_y))\n    c1 = (0.01 * 2**8-1)**2\n    c2 = (0.03 * 2**8-1)**2\n    mssim = (2*mu_x*mu_y + c1)*(2*sig_xy + c2)/((mu_x**2 + mu_y**2 + c1)*(var_x + var_y + c2))\n    return mssim\n\n\n<DED>class StructuralSimilarity(BaseRegressionMetric):\n    <IND>__provider__ = 'ssim'\n    annotation_types = (ImageInpaintingAnnotation, ImageProcessingAnnotation, SuperResolutionAnnotation,\n                        StyleTransferAnnotation)\n    prediction_types = (ImageInpaintingPrediction, ImageProcessingPrediction, SuperResolutionPrediction,\n                        StyleTransferPrediction)\n\n    def __init__(self, *args, **kwargs):\n        <IND>super().__init__(_ssim, *args, **kwargs)\n        self.meta['target'] = 'higher-better'\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "        <IND>super().__init__(angle_differ, *args, **kwargs)\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "openvinotoolkit/open_model_zoo",
    "commit": "3a6f6ba09e0f5d3de8737b5b1d45cc2014b4b8af",
    "filename": "tools/accuracy_checker/accuracy_checker/metrics/regression.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/openvinotoolkit-open_model_zoo/tools/accuracy_checker/accuracy_checker/metrics/regression.py",
    "file_hunks_size": 12,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "tools/accuracy_checker/accuracy_checker/metrics/regression.py:752:4 Inconsistent override [15]: `annotation_types` overrides attribute defined in `BaseRegressionMetric` inconsistently. Type `typing.Tuple[typing.Type[tools.accuracy_checker.accuracy_checker.representation.optical_flow.OpticalFlowAnnotation]]` is not a subtype of the overridden attribute `typing.Tuple[typing.Type[tools.accuracy_checker.accuracy_checker.representation.regression_representation.RegressionAnnotation], typing.Type[tools.accuracy_checker.accuracy_checker.representation.regression_representation.FeaturesRegressionAnnotation], typing.Type[tools.accuracy_checker.accuracy_checker.representation.depth_estimation.DepthEstimationAnnotation], typing.Type[tools.accuracy_checker.accuracy_checker.representation.image_processing.ImageProcessingAnnotation]]`.",
    "message": " `annotation_types` overrides attribute defined in `BaseRegressionMetric` inconsistently. Type `typing.Tuple[typing.Type[tools.accuracy_checker.accuracy_checker.representation.optical_flow.OpticalFlowAnnotation]]` is not a subtype of the overridden attribute `typing.Tuple[typing.Type[tools.accuracy_checker.accuracy_checker.representation.regression_representation.RegressionAnnotation], typing.Type[tools.accuracy_checker.accuracy_checker.representation.regression_representation.FeaturesRegressionAnnotation], typing.Type[tools.accuracy_checker.accuracy_checker.representation.depth_estimation.DepthEstimationAnnotation], typing.Type[tools.accuracy_checker.accuracy_checker.representation.image_processing.ImageProcessingAnnotation]]`.",
    "rule_id": "Inconsistent override [15]",
    "warning_line_no": 752,
    "warning_line": "    annotation_types = (OpticalFlowAnnotation, )"
  },
  {
    "project": "openvinotoolkit/open_model_zoo",
    "commit": "3a6f6ba09e0f5d3de8737b5b1d45cc2014b4b8af",
    "filename": "tools/accuracy_checker/accuracy_checker/metrics/regression.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/openvinotoolkit-open_model_zoo/tools/accuracy_checker/accuracy_checker/metrics/regression.py",
    "file_hunks_size": 12,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "tools/accuracy_checker/accuracy_checker/metrics/regression.py:753:4 Inconsistent override [15]: `prediction_types` overrides attribute defined in `BaseRegressionMetric` inconsistently. Type `typing.Tuple[typing.Type[tools.accuracy_checker.accuracy_checker.representation.optical_flow.OpticalFlowPrediction]]` is not a subtype of the overridden attribute `typing.Tuple[typing.Type[tools.accuracy_checker.accuracy_checker.representation.regression_representation.RegressionPrediction], typing.Type[tools.accuracy_checker.accuracy_checker.representation.depth_estimation.DepthEstimationPrediction], typing.Type[tools.accuracy_checker.accuracy_checker.representation.image_processing.ImageProcessingPrediction]]`.",
    "message": " `prediction_types` overrides attribute defined in `BaseRegressionMetric` inconsistently. Type `typing.Tuple[typing.Type[tools.accuracy_checker.accuracy_checker.representation.optical_flow.OpticalFlowPrediction]]` is not a subtype of the overridden attribute `typing.Tuple[typing.Type[tools.accuracy_checker.accuracy_checker.representation.regression_representation.RegressionPrediction], typing.Type[tools.accuracy_checker.accuracy_checker.representation.depth_estimation.DepthEstimationPrediction], typing.Type[tools.accuracy_checker.accuracy_checker.representation.image_processing.ImageProcessingPrediction]]`.",
    "rule_id": "Inconsistent override [15]",
    "warning_line_no": 753,
    "warning_line": "    prediction_types = (OpticalFlowPrediction, )"
  }
]