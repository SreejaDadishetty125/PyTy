[
  {
    "project": "jina-ai/jina",
    "commit": "60ad4e12dcf778d5e705ff529517202408188183",
    "filename": "jina/drivers/querylang/queryset/dunderkey.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/jina-ai-jina/jina/drivers/querylang/queryset/dunderkey.py",
    "file_hunks_size": 9,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "jina/drivers/querylang/queryset/dunderkey.py:69:4 Incompatible return type [7]: Expected `typing.Union[Tuple[str, None], Tuple[str, str]]` but got `typing.Union[Tuple[str, None], typing.Tuple[str, ...]]`.",
    "message": " Expected `typing.Union[Tuple[str, None], Tuple[str, str]]` but got `typing.Union[Tuple[str, None], typing.Tuple[str, ...]]`.",
    "rule_id": "Incompatible return type [7]",
    "warning_line_no": 69,
    "warning_line": "    return tuple(parts) if len(parts) > 1 else (parts[0], None)",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "## underscore separated keys\nfrom typing import Tuple, Dict, Any\nfrom google.protobuf.struct_pb2 import Struct\n",
        "source_code_len": 111,
        "target_code": "## underscore separated keys\nfrom typing import Tuple, Dict, Any, Optional\nfrom google.protobuf.struct_pb2 import Struct\n",
        "target_code_len": 121,
        "diff_format": "@@ -34,3 +34,3 @@\n ## underscore separated keys\n-from typing import Tuple, Dict, Any\n+from typing import Tuple, Dict, Any, Optional\n from google.protobuf.struct_pb2 import Struct\n",
        "source_code_with_indent": "## underscore separated keys\nfrom typing import Tuple, Dict, Any\nfrom google.protobuf.struct_pb2 import Struct\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "## underscore separated keys\nfrom typing import Tuple, Dict, Any, Optional\nfrom google.protobuf.struct_pb2 import Struct\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\ndef dunder_partition(key: str) -> Union[Tuple[str, str], Tuple[str, None]]:\n    \"\"\"Splits a dunderkey into 2 parts\n",
        "source_code_len": 116,
        "target_code": "\ndef dunder_partition(key: str) -> Tuple[str, Optional[str]]:\n    \"\"\"Splits a dunderkey into 2 parts\n",
        "target_code_len": 101,
        "diff_format": "@@ -54,3 +54,3 @@\n \n-def dunder_partition(key: str) -> Union[Tuple[str, str], Tuple[str, None]]:\n+def dunder_partition(key: str) -> Tuple[str, Optional[str]]:\n     \"\"\"Splits a dunderkey into 2 parts\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\n<DED>def dunder_partition(key: str) -> Union[Tuple[str, str], Tuple[str, None]]:\n    <IND>",
        "target_code_with_indent": "\n<DED>def dunder_partition(key: str) -> Tuple[str, Optional[str]]:\n    <IND>"
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    \"\"\"\n    parts = key.rsplit('__', 1)\n    return tuple(parts) if len(parts) > 1 else (parts[0], None)\n\n",
        "source_code_len": 105,
        "target_code": "    \"\"\"\n    part1: str\n    part2: Optional[str]\n    try:\n        part1, part2 = key.rsplit('__', 1)\n    except ValueError:\n        part1, part2 = key, None\n    return part1, part2\n\n",
        "target_code_len": 181,
        "diff_format": "@@ -67,4 +67,9 @@\n     \"\"\"\n-    parts = key.rsplit('__', 1)\n-    return tuple(parts) if len(parts) > 1 else (parts[0], None)\n+    part1: str\n+    part2: Optional[str]\n+    try:\n+        part1, part2 = key.rsplit('__', 1)\n+    except ValueError:\n+        part1, part2 = key, None\n+    return part1, part2\n \n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\n    parts = key.rsplit('__', 1)\n    return tuple(parts) if len(parts) > 1 else (parts[0], None)\n\n",
        "target_code_with_indent": "\n    part1: str\n    part2: Optional[str]\n    try:\n        <IND>part1, part2 = key.rsplit('__', 1)\n    <DED>except ValueError:\n        <IND>part1, part2 = key, None\n    <DED>return part1, part2\n\n"
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\ndef dunder_last(key: str) -> str:\n    \"\"\"Returns the last part of the dunder key\n",
        "source_code_len": 82,
        "target_code": "\ndef dunder_last(key: str) -> Optional[str]:\n    \"\"\"Returns the last part of the dunder key\n",
        "target_code_len": 92,
        "diff_format": "@@ -83,3 +88,3 @@\n \n-def dunder_last(key: str) -> str:\n+def dunder_last(key: str) -> Optional[str]:\n     \"\"\"Returns the last part of the dunder key\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\n<DED>def dunder_last(key: str) -> str:\n    <IND>",
        "target_code_with_indent": "\n<DED>def dunder_last(key: str) -> Optional[str]:\n    <IND>"
      }
    ]
  },
  {
    "project": "jina-ai/jina",
    "commit": "60ad4e12dcf778d5e705ff529517202408188183",
    "filename": "jina/drivers/querylang/queryset/dunderkey.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/jina-ai-jina/jina/drivers/querylang/queryset/dunderkey.py",
    "file_hunks_size": 9,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "jina/drivers/querylang/queryset/dunderkey.py:93:4 Incompatible return type [7]: Expected `str` but got `typing.Optional[str]`.",
    "message": " Expected `str` but got `typing.Optional[str]`.",
    "rule_id": "Incompatible return type [7]",
    "warning_line_no": 93,
    "warning_line": "    return dunder_partition(key)[1]",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "## underscore separated keys\nfrom typing import Tuple, Dict, Any\nfrom google.protobuf.struct_pb2 import Struct\n",
        "source_code_len": 111,
        "target_code": "## underscore separated keys\nfrom typing import Tuple, Dict, Any, Optional\nfrom google.protobuf.struct_pb2 import Struct\n",
        "target_code_len": 121,
        "diff_format": "@@ -34,3 +34,3 @@\n ## underscore separated keys\n-from typing import Tuple, Dict, Any\n+from typing import Tuple, Dict, Any, Optional\n from google.protobuf.struct_pb2 import Struct\n",
        "source_code_with_indent": "## underscore separated keys\nfrom typing import Tuple, Dict, Any\nfrom google.protobuf.struct_pb2 import Struct\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "## underscore separated keys\nfrom typing import Tuple, Dict, Any, Optional\nfrom google.protobuf.struct_pb2 import Struct\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\ndef dunder_partition(key: str) -> Union[Tuple[str, str], Tuple[str, None]]:\n    \"\"\"Splits a dunderkey into 2 parts\n",
        "source_code_len": 116,
        "target_code": "\ndef dunder_partition(key: str) -> Tuple[str, Optional[str]]:\n    \"\"\"Splits a dunderkey into 2 parts\n",
        "target_code_len": 101,
        "diff_format": "@@ -54,3 +54,3 @@\n \n-def dunder_partition(key: str) -> Union[Tuple[str, str], Tuple[str, None]]:\n+def dunder_partition(key: str) -> Tuple[str, Optional[str]]:\n     \"\"\"Splits a dunderkey into 2 parts\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\n<DED>def dunder_partition(key: str) -> Union[Tuple[str, str], Tuple[str, None]]:\n    <IND>",
        "target_code_with_indent": "\n<DED>def dunder_partition(key: str) -> Tuple[str, Optional[str]]:\n    <IND>"
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    \"\"\"\n    parts = key.rsplit('__', 1)\n    return tuple(parts) if len(parts) > 1 else (parts[0], None)\n\n",
        "source_code_len": 105,
        "target_code": "    \"\"\"\n    part1: str\n    part2: Optional[str]\n    try:\n        part1, part2 = key.rsplit('__', 1)\n    except ValueError:\n        part1, part2 = key, None\n    return part1, part2\n\n",
        "target_code_len": 181,
        "diff_format": "@@ -67,4 +67,9 @@\n     \"\"\"\n-    parts = key.rsplit('__', 1)\n-    return tuple(parts) if len(parts) > 1 else (parts[0], None)\n+    part1: str\n+    part2: Optional[str]\n+    try:\n+        part1, part2 = key.rsplit('__', 1)\n+    except ValueError:\n+        part1, part2 = key, None\n+    return part1, part2\n \n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\n    parts = key.rsplit('__', 1)\n    return tuple(parts) if len(parts) > 1 else (parts[0], None)\n\n",
        "target_code_with_indent": "\n    part1: str\n    part2: Optional[str]\n    try:\n        <IND>part1, part2 = key.rsplit('__', 1)\n    <DED>except ValueError:\n        <IND>part1, part2 = key, None\n    <DED>return part1, part2\n\n"
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\ndef dunder_last(key: str) -> str:\n    \"\"\"Returns the last part of the dunder key\n",
        "source_code_len": 82,
        "target_code": "\ndef dunder_last(key: str) -> Optional[str]:\n    \"\"\"Returns the last part of the dunder key\n",
        "target_code_len": 92,
        "diff_format": "@@ -83,3 +88,3 @@\n \n-def dunder_last(key: str) -> str:\n+def dunder_last(key: str) -> Optional[str]:\n     \"\"\"Returns the last part of the dunder key\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\n<DED>def dunder_last(key: str) -> str:\n    <IND>",
        "target_code_with_indent": "\n<DED>def dunder_last(key: str) -> Optional[str]:\n    <IND>"
      }
    ]
  },
  {
    "project": "jina-ai/jina",
    "commit": "60ad4e12dcf778d5e705ff529517202408188183",
    "filename": "jina/drivers/querylang/queryset/dunderkey.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/jina-ai-jina/jina/drivers/querylang/queryset/dunderkey.py",
    "file_hunks_size": 9,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "jina/drivers/querylang/queryset/dunderkey.py:121:19 Incompatible parameter type [6]: Expected `str` for 2nd positional only parameter to call `list.__setitem__` but got `int`.",
    "message": " Expected `str` for 2nd positional only parameter to call `list.__setitem__` but got `int`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 121,
    "warning_line": "        parts[0] = int(parts[0])  # parse int parameter",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    if isinstance(_dict, Struct):\n        return dunder_get(json_format.MessageToDict(_dict), key)\n\n    parts = key.split('__', 1)\n\n    try:\n        parts[0] = int(parts[0])  # parse int parameter\n    except ValueError:\n        pass\n\n    if isinstance(parts[0], int):\n        result = guard_iter(_dict)[parts[0]]\n    elif isinstance(_dict, dict):\n        result = _dict[parts[0]]\n    else:\n        result = getattr(_dict, parts[0])\n    return result if len(parts) == 1 else dunder_get(result, parts[1])\n\n",
        "source_code_len": 504,
        "target_code": "    if isinstance(_dict, Struct):\n        _dict = json_format.MessageToDict(_dict)\n\n    try:\n        part1, part2 = key.split('__', 1)\n    except ValueError:\n        part1, part2 = key, ''\n\n    try:\n        result = _dict[int(part1)]\n    except ValueError:\n        if isinstance(_dict, dict):\n            result = _dict[part1]\n        else:\n            result = getattr(_dict, part1)\n\n    return dunder_get(result, part2) if part2 else result\n\n",
        "target_code_len": 444,
        "diff_format": "@@ -115,18 +120,18 @@\n     if isinstance(_dict, Struct):\n-        return dunder_get(json_format.MessageToDict(_dict), key)\n-\n-    parts = key.split('__', 1)\n+        _dict = json_format.MessageToDict(_dict)\n \n     try:\n-        parts[0] = int(parts[0])  # parse int parameter\n+        part1, part2 = key.split('__', 1)\n     except ValueError:\n-        pass\n+        part1, part2 = key, ''\n \n-    if isinstance(parts[0], int):\n-        result = guard_iter(_dict)[parts[0]]\n-    elif isinstance(_dict, dict):\n-        result = _dict[parts[0]]\n-    else:\n-        result = getattr(_dict, parts[0])\n-    return result if len(parts) == 1 else dunder_get(result, parts[1])\n+    try:\n+        result = _dict[int(part1)]\n+    except ValueError:\n+        if isinstance(_dict, dict):\n+            result = _dict[part1]\n+        else:\n+            result = getattr(_dict, part1)\n+\n+    return dunder_get(result, part2) if part2 else result\n \n",
        "source_code_with_indent": "    if isinstance(_dict, Struct):\n        <IND>return dunder_get(json_format.MessageToDict(_dict), key)\n\n    <DED>parts = key.split('__', 1)\n\n    try:\n        <IND>parts[0] = int(parts[0])  # parse int parameter\n    <DED>except ValueError:\n        <IND>pass\n\n    <DED>if isinstance(parts[0], int):\n        <IND>result = guard_iter(_dict)[parts[0]]\n    <DED>elif isinstance(_dict, dict):\n        <IND>result = _dict[parts[0]]\n    <DED>else:\n        <IND>result = getattr(_dict, parts[0])\n    <DED>return result if len(parts) == 1 else dunder_get(result, parts[1])\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    if isinstance(_dict, Struct):\n        <IND>_dict = json_format.MessageToDict(_dict)\n\n    <DED>try:\n        <IND>part1, part2 = key.split('__', 1)\n    <DED>except ValueError:\n        <IND>part1, part2 = key, ''\n\n    <DED>try:\n        <IND>result = _dict[int(part1)]\n    <DED>except ValueError:\n        <IND>if isinstance(_dict, dict):\n            <IND>result = _dict[part1]\n        <DED>else:\n            <IND>result = getattr(_dict, part1)\n\n    <DED><DED>return dunder_get(result, part2) if part2 else result\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "jina-ai/jina",
    "commit": "60ad4e12dcf778d5e705ff529517202408188183",
    "filename": "jina/drivers/querylang/queryset/lookup.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/jina-ai-jina/jina/drivers/querylang/queryset/lookup.py",
    "file_hunks_size": 4,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "jina/drivers/querylang/queryset/lookup.py:118:56 Incompatible parameter type [6]: Expected `List[typing.Any]` for 2nd positional only parameter to call `include_keys` but got `typing.Tuple[typing.Any, ...]`.",
    "message": " Expected `List[typing.Any]` for 2nd positional only parameter to call `include_keys` but got `typing.Tuple[typing.Any, ...]`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 118,
    "warning_line": "        result = (f(d) for d in include_keys(self.data, args))",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\ndef include_keys(items: Iterable[Dict], fields: List) -> Iterable[Dict]:\n    \"\"\"Function to keep only specified fields in data\n",
        "source_code_len": 128,
        "target_code": "\ndef include_keys(items: Iterable[Dict[str, Any]], fields: Iterable[str]) -> Iterable[Dict]:\n    \"\"\"Function to keep only specified fields in data\n",
        "target_code_len": 147,
        "diff_format": "@@ -299,3 +299,3 @@\n \n-def include_keys(items: Iterable[Dict], fields: List) -> Iterable[Dict]:\n+def include_keys(items: Iterable[Dict[str, Any]], fields: Iterable[str]) -> Iterable[Dict]:\n     \"\"\"Function to keep only specified fields in data\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\ndef include_keys(items: Iterable[Dict], fields: List) -> Iterable[Dict]:\n    <IND>",
        "target_code_with_indent": "\ndef include_keys(items: Iterable[Dict[str, Any]], fields: Iterable[str]) -> Iterable[Dict]:\n    <IND>"
      }
    ]
  },
  {
    "project": "jina-ai/jina",
    "commit": "60ad4e12dcf778d5e705ff529517202408188183",
    "filename": "jina/drivers/querylang/queryset/lookup.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/jina-ai-jina/jina/drivers/querylang/queryset/lookup.py",
    "file_hunks_size": 4,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "jina/drivers/querylang/queryset/lookup.py:252:4 Inconsistent override [15]: `jina.drivers.querylang.queryset.lookup.LookupNode.evaluate` overrides method defined in `LookupTreeElem` inconsistently. Returned type `bool` is not a subtype of the overridden return `None`.",
    "message": " `jina.drivers.querylang.queryset.lookup.LookupNode.evaluate` overrides method defined in `LookupTreeElem` inconsistently. Returned type `bool` is not a subtype of the overridden return `None`.",
    "rule_id": "Inconsistent override [15]",
    "warning_line_no": 252,
    "warning_line": "    def evaluate(self, item: Dict) -> bool:",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n    def evaluate(self, item: Dict) -> None:\n        raise NotImplementedError\n",
        "source_code_len": 79,
        "target_code": "\n    def evaluate(self, item: Dict) -> bool:\n        raise NotImplementedError\n",
        "target_code_len": 79,
        "diff_format": "@@ -216,3 +216,3 @@\n \n-    def evaluate(self, item: Dict) -> None:\n+    def evaluate(self, item: Dict) -> bool:\n         raise NotImplementedError\n",
        "source_code_with_indent": "\n    <DED>def evaluate(self, item: Dict) -> None:\n        <IND>raise NotImplementedError\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n    <DED>def evaluate(self, item: Dict) -> bool:\n        <IND>raise NotImplementedError\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "jina-ai/jina",
    "commit": "60ad4e12dcf778d5e705ff529517202408188183",
    "filename": "jina/drivers/querylang/queryset/lookup.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/jina-ai-jina/jina/drivers/querylang/queryset/lookup.py",
    "file_hunks_size": 4,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "jina/drivers/querylang/queryset/lookup.py:278:4 Inconsistent override [15]: `jina.drivers.querylang.queryset.lookup.LookupLeaf.evaluate` overrides method defined in `LookupTreeElem` inconsistently. Returned type `bool` is not a subtype of the overridden return `None`.",
    "message": " `jina.drivers.querylang.queryset.lookup.LookupLeaf.evaluate` overrides method defined in `LookupTreeElem` inconsistently. Returned type `bool` is not a subtype of the overridden return `None`.",
    "rule_id": "Inconsistent override [15]",
    "warning_line_no": 278,
    "warning_line": "    def evaluate(self, item: Dict) -> bool:",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n    def evaluate(self, item: Dict) -> None:\n        raise NotImplementedError\n",
        "source_code_len": 79,
        "target_code": "\n    def evaluate(self, item: Dict) -> bool:\n        raise NotImplementedError\n",
        "target_code_len": 79,
        "diff_format": "@@ -216,3 +216,3 @@\n \n-    def evaluate(self, item: Dict) -> None:\n+    def evaluate(self, item: Dict) -> bool:\n         raise NotImplementedError\n",
        "source_code_with_indent": "\n    <DED>def evaluate(self, item: Dict) -> None:\n        <IND>raise NotImplementedError\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n    <DED>def evaluate(self, item: Dict) -> bool:\n        <IND>raise NotImplementedError\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  }
]