[
  {
    "project": "stac-utils/pystac",
    "commit": "c78f832a0462f27f17b420e93af7970c5f285e2d",
    "filename": "pystac/cache.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/stac-utils-pystac/pystac/cache.py",
    "file_hunks_size": 3,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": true,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "pystac/cache.py:271:4 Inconsistent override [14]: `pystac.cache.ResolvedObjectCollectionCache.cache` overrides method defined in `CollectionCache` inconsistently. Parameter of type `Dict[str, typing.Any]` is not a supertype of the overridden parameter `Union[Dict[str, typing.Any], Collection]`.",
    "message": " `pystac.cache.ResolvedObjectCollectionCache.cache` overrides method defined in `CollectionCache` inconsistently. Parameter of type `Dict[str, typing.Any]` is not a supertype of the overridden parameter `Union[Dict[str, typing.Any], Collection]`.",
    "rule_id": "Inconsistent override [14]",
    "warning_line_no": 271,
    "warning_line": "    def cache(self, collection: Dict[str, Any], href: Optional[str] = None) -> None:",
    "min_patch": [
      {
        "hunk_fit_TFix": true,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n    def cache(self, collection: Dict[str, Any], href: Optional[str] = None) -> None:\n        super().cache(collection, href)\n",
        "source_code_len": 126,
        "target_code": "\n    def cache(self,\n              collection: Union[\"Collection\", Dict[str, Any]],\n              href: Optional[str] = None) -> None:\n        super().cache(collection, href)\n",
        "target_code_len": 175,
        "diff_format": "@@ -270,3 +270,5 @@\n \n-    def cache(self, collection: Dict[str, Any], href: Optional[str] = None) -> None:\n+    def cache(self,\n+              collection: Union[\"Collection\", Dict[str, Any]],\n+              href: Optional[str] = None) -> None:\n         super().cache(collection, href)\n",
        "source_code_with_indent": "\n    <DED>def cache(self, collection: Dict[str, Any], href: Optional[str] = None) -> None:\n        <IND>super().cache(collection, href)\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n    <DED>def cache(self,\n              collection: Union[\"Collection\", Dict[str, Any]],\n              href: Optional[str] = None) -> None:\n        <IND>super().cache(collection, href)\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "stac-utils/pystac",
    "commit": "c78f832a0462f27f17b420e93af7970c5f285e2d",
    "filename": "pystac/catalog.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/stac-utils-pystac/pystac/catalog.py",
    "file_hunks_size": 29,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "pystac/catalog.py:147:4 Inconsistent override [15]: `pystac.catalog.Catalog.set_root` overrides method defined in `STACObject` inconsistently. Returned type `None` is not a subtype of the overridden return `STACObject`.",
    "message": " `pystac.catalog.Catalog.set_root` overrides method defined in `STACObject` inconsistently. Returned type `None` is not a subtype of the overridden return `STACObject`.",
    "rule_id": "Inconsistent override [15]",
    "warning_line_no": 147,
    "warning_line": "    def set_root(self, root: Optional[\"Catalog\"]) -> None:"
  },
  {
    "project": "stac-utils/pystac",
    "commit": "c78f832a0462f27f17b420e93af7970c5f285e2d",
    "filename": "pystac/catalog.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/stac-utils-pystac/pystac/catalog.py",
    "file_hunks_size": 29,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "pystac/catalog.py:477:18 Incompatible parameter type [6]: Expected `CatalogType` for 1st positional only parameter to call `Catalog.save` but got `Optional[CatalogType]`.",
    "message": " Expected `CatalogType` for 1st positional only parameter to call `Catalog.save` but got `Optional[CatalogType]`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 477,
    "warning_line": "        self.save(catalog_type)",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n    def save(self, catalog_type: CatalogType = None) -> None:\n        \"\"\"Save this catalog and all it's children/item to files determined by the object's\n",
        "source_code_len": 155,
        "target_code": "\n    def save(self, catalog_type: Optional[CatalogType] = None) -> None:\n        \"\"\"Save this catalog and all it's children/item to files determined by the object's\n",
        "target_code_len": 165,
        "diff_format": "@@ -615,3 +617,3 @@\n \n-    def save(self, catalog_type: CatalogType = None) -> None:\n+    def save(self, catalog_type: Optional[CatalogType] = None) -> None:\n         \"\"\"Save this catalog and all it's children/item to files determined by the object's\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\n    <DED>def save(self, catalog_type: CatalogType = None) -> None:\n        <IND>",
        "target_code_with_indent": "\n    <DED>def save(self, catalog_type: Optional[CatalogType] = None) -> None:\n        <IND>"
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "        # include a self link if this is the root catalog or if ABSOLUTE_PUBLISHED catalog\n        if ((self.get_self_href() == self.get_root_link().get_absolute_href()\n             and root.catalog_type != CatalogType.SELF_CONTAINED)\n                or root.catalog_type == CatalogType.ABSOLUTE_PUBLISHED):\n            include_self_link = True\n\n        self.save_object(include_self_link=include_self_link)\n\n        self.catalog_type = catalog_type\n\n",
        "source_code_len": 451,
        "target_code": "        # include a self link if this is the root catalog or if ABSOLUTE_PUBLISHED catalog\n        if root.catalog_type == CatalogType.ABSOLUTE_PUBLISHED:\n            include_self_link = True\n        elif root.catalog_type != CatalogType.SELF_CONTAINED:\n            root_link = self.get_root_link()\n            if root_link and root_link.get_absolute_href() == self.get_self_href():\n                include_self_link = True\n\n        self.save_object(include_self_link=include_self_link)\n        if catalog_type is not None:\n            self.catalog_type = catalog_type\n\n",
        "target_code_len": 570,
        "diff_format": "@@ -654,10 +656,12 @@\n         # include a self link if this is the root catalog or if ABSOLUTE_PUBLISHED catalog\n-        if ((self.get_self_href() == self.get_root_link().get_absolute_href()\n-             and root.catalog_type != CatalogType.SELF_CONTAINED)\n-                or root.catalog_type == CatalogType.ABSOLUTE_PUBLISHED):\n+        if root.catalog_type == CatalogType.ABSOLUTE_PUBLISHED:\n             include_self_link = True\n+        elif root.catalog_type != CatalogType.SELF_CONTAINED:\n+            root_link = self.get_root_link()\n+            if root_link and root_link.get_absolute_href() == self.get_self_href():\n+                include_self_link = True\n \n         self.save_object(include_self_link=include_self_link)\n-\n-        self.catalog_type = catalog_type\n+        if catalog_type is not None:\n+            self.catalog_type = catalog_type\n \n",
        "source_code_with_indent": "        # include a self link if this is the root catalog or if ABSOLUTE_PUBLISHED catalog\n        if ((self.get_self_href() == self.get_root_link().get_absolute_href()\n             and root.catalog_type != CatalogType.SELF_CONTAINED)\n                or root.catalog_type == CatalogType.ABSOLUTE_PUBLISHED):\n            <IND>include_self_link = True\n\n        <DED>self.save_object(include_self_link=include_self_link)\n\n        self.catalog_type = catalog_type\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "        # include a self link if this is the root catalog or if ABSOLUTE_PUBLISHED catalog\n        if root.catalog_type == CatalogType.ABSOLUTE_PUBLISHED:\n            <IND>include_self_link = True\n        <DED>elif root.catalog_type != CatalogType.SELF_CONTAINED:\n            <IND>root_link = self.get_root_link()\n            if root_link and root_link.get_absolute_href() == self.get_self_href():\n                <IND>include_self_link = True\n\n        <DED><DED>self.save_object(include_self_link=include_self_link)\n        if catalog_type is not None:\n            <IND>self.catalog_type = catalog_type\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "stac-utils/pystac",
    "commit": "c78f832a0462f27f17b420e93af7970c5f285e2d",
    "filename": "pystac/catalog.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/stac-utils-pystac/pystac/catalog.py",
    "file_hunks_size": 29,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": true,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "pystac/catalog.py:546:29 Incompatible variable type [9]: parent_ids is declared to have type `List[str]` but is used as type `None`.",
    "message": " parent_ids is declared to have type `List[str]` but is used as type `None`.",
    "rule_id": "Incompatible variable type [9]",
    "warning_line_no": 546,
    "warning_line": "                             parent_ids: List[str] = None,",
    "min_patch": [
      {
        "hunk_fit_TFix": true,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "                             defaults: Optional[Dict[str, Any]] = None,\n                             parent_ids: List[str] = None,\n                             **kwargs: Any) -> List[\"Catalog\"]:\n",
        "source_code_len": 195,
        "target_code": "                             defaults: Optional[Dict[str, Any]] = None,\n                             parent_ids: Optional[List[str]] = None,\n                             **kwargs: Any) -> List[\"Catalog\"]:\n",
        "target_code_len": 205,
        "diff_format": "@@ -545,3 +545,3 @@\n                              defaults: Optional[Dict[str, Any]] = None,\n-                             parent_ids: List[str] = None,\n+                             parent_ids: Optional[List[str]] = None,\n                              **kwargs: Any) -> List[\"Catalog\"]:\n",
        "source_code_with_indent": "                             defaults: Optional[Dict[str, Any]] = None,\n                             parent_ids: List[str] = None,\n                             **kwargs: Any) -> List[\"Catalog\"]:\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "                             defaults: Optional[Dict[str, Any]] = None,\n                             parent_ids: Optional[List[str]] = None,\n                             **kwargs: Any) -> List[\"Catalog\"]:\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "stac-utils/pystac",
    "commit": "c78f832a0462f27f17b420e93af7970c5f285e2d",
    "filename": "pystac/catalog.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/stac-utils-pystac/pystac/catalog.py",
    "file_hunks_size": 29,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "pystac/catalog.py:586:39 Incompatible parameter type [6]: Expected `typing.Reversible[Variable[_T]]` for 1st positional only parameter to call `reversed.__init__` but got `typing.ValuesView[typing.Any]`.",
    "message": " Expected `typing.Reversible[Variable[_T]]` for 1st positional only parameter to call `reversed.__init__` but got `typing.ValuesView[typing.Any]`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 586,
    "warning_line": "                    for id in reversed(item_parts.values())]):",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "            id_iter = reversed(parent_ids)\n            if all(['{}'.format(id) == next(id_iter, None)\n                    for id in reversed(item_parts.values())]):\n                # Skip items for which the sub-catalog structure already\n",
        "source_code_len": 238,
        "target_code": "            id_iter = reversed(parent_ids)\n            if all([\n                    '{}'.format(id) == next(id_iter, None)\n                    for id in reversed(list(item_parts.values()))\n            ]):\n                # Skip items for which the sub-catalog structure already\n",
        "target_code_len": 278,
        "diff_format": "@@ -584,4 +584,6 @@\n             id_iter = reversed(parent_ids)\n-            if all(['{}'.format(id) == next(id_iter, None)\n-                    for id in reversed(item_parts.values())]):\n+            if all([\n+                    '{}'.format(id) == next(id_iter, None)\n+                    for id in reversed(list(item_parts.values()))\n+            ]):\n                 # Skip items for which the sub-catalog structure already\n",
        "source_code_with_indent": "            id_iter = reversed(parent_ids)\n            if all(['{}'.format(id) == next(id_iter, None)\n                    for id in reversed(item_parts.values())]):\n                # Skip items for which the sub-catalog structure already\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "            id_iter = reversed(parent_ids)\n            if all([\n                    '{}'.format(id) == next(id_iter, None)\n                    for id in reversed(list(item_parts.values()))\n            ]):\n                # Skip items for which the sub-catalog structure already\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "stac-utils/pystac",
    "commit": "c78f832a0462f27f17b420e93af7970c5f285e2d",
    "filename": "pystac/catalog.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/stac-utils-pystac/pystac/catalog.py",
    "file_hunks_size": 29,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "pystac/catalog.py:616:19 Incompatible variable type [9]: catalog_type is declared to have type `CatalogType` but is used as type `None`.",
    "message": " catalog_type is declared to have type `CatalogType` but is used as type `None`.",
    "rule_id": "Incompatible variable type [9]",
    "warning_line_no": 616,
    "warning_line": "    def save(self, catalog_type: CatalogType = None) -> None:",
    "min_patch": [
      {
        "hunk_fit_TFix": true,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n    def save(self, catalog_type: CatalogType = None) -> None:\n        \"\"\"Save this catalog and all it's children/item to files determined by the object's\n",
        "source_code_len": 155,
        "target_code": "\n    def save(self, catalog_type: Optional[CatalogType] = None) -> None:\n        \"\"\"Save this catalog and all it's children/item to files determined by the object's\n",
        "target_code_len": 165,
        "diff_format": "@@ -615,3 +617,3 @@\n \n-    def save(self, catalog_type: CatalogType = None) -> None:\n+    def save(self, catalog_type: Optional[CatalogType] = None) -> None:\n         \"\"\"Save this catalog and all it's children/item to files determined by the object's\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\n    <DED>def save(self, catalog_type: CatalogType = None) -> None:\n        <IND>",
        "target_code_with_indent": "\n    <DED>def save(self, catalog_type: Optional[CatalogType] = None) -> None:\n        <IND>"
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "        # include a self link if this is the root catalog or if ABSOLUTE_PUBLISHED catalog\n        if ((self.get_self_href() == self.get_root_link().get_absolute_href()\n             and root.catalog_type != CatalogType.SELF_CONTAINED)\n                or root.catalog_type == CatalogType.ABSOLUTE_PUBLISHED):\n            include_self_link = True\n\n        self.save_object(include_self_link=include_self_link)\n\n        self.catalog_type = catalog_type\n\n",
        "source_code_len": 451,
        "target_code": "        # include a self link if this is the root catalog or if ABSOLUTE_PUBLISHED catalog\n        if root.catalog_type == CatalogType.ABSOLUTE_PUBLISHED:\n            include_self_link = True\n        elif root.catalog_type != CatalogType.SELF_CONTAINED:\n            root_link = self.get_root_link()\n            if root_link and root_link.get_absolute_href() == self.get_self_href():\n                include_self_link = True\n\n        self.save_object(include_self_link=include_self_link)\n        if catalog_type is not None:\n            self.catalog_type = catalog_type\n\n",
        "target_code_len": 570,
        "diff_format": "@@ -654,10 +656,12 @@\n         # include a self link if this is the root catalog or if ABSOLUTE_PUBLISHED catalog\n-        if ((self.get_self_href() == self.get_root_link().get_absolute_href()\n-             and root.catalog_type != CatalogType.SELF_CONTAINED)\n-                or root.catalog_type == CatalogType.ABSOLUTE_PUBLISHED):\n+        if root.catalog_type == CatalogType.ABSOLUTE_PUBLISHED:\n             include_self_link = True\n+        elif root.catalog_type != CatalogType.SELF_CONTAINED:\n+            root_link = self.get_root_link()\n+            if root_link and root_link.get_absolute_href() == self.get_self_href():\n+                include_self_link = True\n \n         self.save_object(include_self_link=include_self_link)\n-\n-        self.catalog_type = catalog_type\n+        if catalog_type is not None:\n+            self.catalog_type = catalog_type\n \n",
        "source_code_with_indent": "        # include a self link if this is the root catalog or if ABSOLUTE_PUBLISHED catalog\n        if ((self.get_self_href() == self.get_root_link().get_absolute_href()\n             and root.catalog_type != CatalogType.SELF_CONTAINED)\n                or root.catalog_type == CatalogType.ABSOLUTE_PUBLISHED):\n            <IND>include_self_link = True\n\n        <DED>self.save_object(include_self_link=include_self_link)\n\n        self.catalog_type = catalog_type\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "        # include a self link if this is the root catalog or if ABSOLUTE_PUBLISHED catalog\n        if root.catalog_type == CatalogType.ABSOLUTE_PUBLISHED:\n            <IND>include_self_link = True\n        <DED>elif root.catalog_type != CatalogType.SELF_CONTAINED:\n            <IND>root_link = self.get_root_link()\n            if root_link and root_link.get_absolute_href() == self.get_self_href():\n                <IND>include_self_link = True\n\n        <DED><DED>self.save_object(include_self_link=include_self_link)\n        if catalog_type is not None:\n            <IND>self.catalog_type = catalog_type\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "stac-utils/pystac",
    "commit": "c78f832a0462f27f17b420e93af7970c5f285e2d",
    "filename": "pystac/collection.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/stac-utils-pystac/pystac/collection.py",
    "file_hunks_size": 11,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "pystac/collection.py:270:19 Unsupported operand [58]: `+` is not supported for operand types `Optional[List[float]]` and `List[Optional[Datetime]]`.",
    "message": " `+` is not supported for operand types `Optional[List[float]]` and `List[Optional[Datetime]]`.",
    "rule_id": "Unsupported operand [58]",
    "warning_line_no": 270,
    "warning_line": "            return item.bbox + ["
  },
  {
    "project": "stac-utils/pystac",
    "commit": "c78f832a0462f27f17b420e93af7970c5f285e2d",
    "filename": "pystac/collection.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/stac-utils-pystac/pystac/collection.py",
    "file_hunks_size": 11,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "pystac/collection.py:440:4 Inconsistent override [14]: `pystac.collection.Collection.add_item` overrides method defined in `Catalog` inconsistently. Could not find parameter `strategy` in overriding signature.",
    "message": " `pystac.collection.Collection.add_item` overrides method defined in `Catalog` inconsistently. Could not find parameter `strategy` in overriding signature.",
    "rule_id": "Inconsistent override [14]",
    "warning_line_no": 440,
    "warning_line": "    def add_item(self, item: \"ItemType\", title: Optional[str] = None) -> None:"
  },
  {
    "project": "stac-utils/pystac",
    "commit": "c78f832a0462f27f17b420e93af7970c5f285e2d",
    "filename": "pystac/extensions/file.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/stac-utils-pystac/pystac/extensions/file.py",
    "file_hunks_size": 5,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": true,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "pystac/extensions/file.py:69:4 Inconsistent override [14]: `pystac.extensions.file.FileItemExt._set_property` overrides method defined in `ItemExtension` inconsistently. Could not find parameter `pop_if_none` in overriding signature.",
    "message": " `pystac.extensions.file.FileItemExt._set_property` overrides method defined in `ItemExtension` inconsistently. Could not find parameter `pop_if_none` in overriding signature.",
    "rule_id": "Inconsistent override [14]",
    "warning_line_no": 69,
    "warning_line": "    def _set_property(self, key: str, value: Any, asset: Optional[Asset]) -> None:",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": true,
        "has_suppression": false,
        "source_code": "\n    def _set_property(self, key: str, value: Any, asset: Optional[Asset]) -> None:\n        target = self.item.properties if asset is None else asset.properties\n        if value is None:\n            target.pop(key, None)\n        else:\n            target[key] = value\n\n    @property\n",
        "source_code_len": 282,
        "target_code": "\n    @property\n",
        "target_code_len": 15,
        "diff_format": "@@ -68,9 +68,2 @@\n \n-    def _set_property(self, key: str, value: Any, asset: Optional[Asset]) -> None:\n-        target = self.item.properties if asset is None else asset.properties\n-        if value is None:\n-            target.pop(key, None)\n-        else:\n-            target[key] = value\n-\n     @property\n",
        "source_code_with_indent": "\n    <DED>def _set_property(self, key: str, value: Any, asset: Optional[Asset]) -> None:\n        <IND>target = self.item.properties if asset is None else asset.properties\n        if value is None:\n            <IND>target.pop(key, None)\n        <DED>else:\n            <IND>target[key] = value\n\n    <DED><DED>@property\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n    <DED>@property\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "stac-utils/pystac",
    "commit": "c78f832a0462f27f17b420e93af7970c5f285e2d",
    "filename": "pystac/extensions/single_file_stac.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/stac-utils-pystac/pystac/extensions/single_file_stac.py",
    "file_hunks_size": 13,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "pystac/extensions/single_file_stac.py:87:4 Inconsistent override [14]: `pystac.extensions.single_file_stac.SingleFileSTACCatalogExt.enable_extension` overrides method defined in `pystac.extensions.base.STACObjectExtension` inconsistently. Could not find parameter `stac_object` in overriding signature.",
    "message": " `pystac.extensions.single_file_stac.SingleFileSTACCatalogExt.enable_extension` overrides method defined in `pystac.extensions.base.STACObjectExtension` inconsistently. Could not find parameter `stac_object` in overriding signature.",
    "rule_id": "Inconsistent override [14]",
    "warning_line_no": 87,
    "warning_line": "    def enable_extension(cls, catalog: Catalog):",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "from pystac.item import Item\nfrom typing import List, Optional, cast\nfrom pystac.catalog import Catalog\n\nfrom pystac import (STACError, Extensions)\nfrom pystac.collection import Collection\nfrom pystac.extensions.base import (CatalogExtension, ExtensionDefinition, ExtendedObject)\n",
        "source_code_len": 280,
        "target_code": "from pystac.item import Item\nfrom typing import Dict, List, Optional, cast\n\nimport pystac as ps\nfrom pystac.extensions.base import (CatalogExtension, ExtensionDefinition, ExtendedObject)\n",
        "target_code_len": 187,
        "diff_format": "@@ -1,7 +1,5 @@\n from pystac.item import Item\n-from typing import List, Optional, cast\n-from pystac.catalog import Catalog\n+from typing import Dict, List, Optional, cast\n \n-from pystac import (STACError, Extensions)\n-from pystac.collection import Collection\n+import pystac as ps\n from pystac.extensions.base import (CatalogExtension, ExtensionDefinition, ExtendedObject)\n",
        "source_code_with_indent": "from pystac.item import Item\nfrom typing import List, Optional, cast\nfrom pystac.catalog import Catalog\n\nfrom pystac import (STACError, Extensions)\nfrom pystac.collection import Collection\nfrom pystac.extensions.base import (CatalogExtension, ExtensionDefinition, ExtendedObject)\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "from pystac.item import Item\nfrom typing import Dict, List, Optional, cast\n\nimport pystac as ps\nfrom pystac.extensions.base import (CatalogExtension, ExtensionDefinition, ExtendedObject)\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\ndef create_single_file_stac(catalog: Catalog):\n    \"\"\"Creates a Single File STAC from a STAC catalog.\n",
        "source_code_len": 103,
        "target_code": "\ndef create_single_file_stac(catalog: ps.Catalog) -> ps.Catalog:\n    \"\"\"Creates a Single File STAC from a STAC catalog.\n",
        "target_code_len": 120,
        "diff_format": "@@ -9,3 +7,3 @@\n \n-def create_single_file_stac(catalog: Catalog):\n+def create_single_file_stac(catalog: ps.Catalog) -> ps.Catalog:\n     \"\"\"Creates a Single File STAC from a STAC catalog.\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\ndef create_single_file_stac(catalog: Catalog):\n    <IND>",
        "target_code_with_indent": "\ndef create_single_file_stac(catalog: ps.Catalog) -> ps.Catalog:\n    <IND>"
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    \"\"\"\n    collections = {}\n    items = []\n    for root, _, cat_items in catalog.walk():\n        if issubclass(type(root), Collection):\n            new_collection = root.clone()\n",
        "source_code_len": 179,
        "target_code": "    \"\"\"\n    collections: Dict[str, ps.Collection] = {}\n    items: List[ps.Item] = []\n    for root, _, cat_items in catalog.walk():\n        if isinstance(root, ps.Collection):\n            new_collection = root.clone()\n",
        "target_code_len": 217,
        "diff_format": "@@ -23,6 +21,6 @@\n     \"\"\"\n-    collections = {}\n-    items = []\n+    collections: Dict[str, ps.Collection] = {}\n+    items: List[ps.Item] = []\n     for root, _, cat_items in catalog.walk():\n-        if issubclass(type(root), Collection):\n+        if isinstance(root, ps.Collection):\n             new_collection = root.clone()\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\n    collections = {}\n    items = []\n    for root, _, cat_items in catalog.walk():\n        <IND>if issubclass(type(root), Collection):\n            <IND>new_collection = root.clone()\n",
        "target_code_with_indent": "\n    collections: Dict[str, ps.Collection] = {}\n    items: List[ps.Item] = []\n    for root, _, cat_items in catalog.walk():\n        <IND>if isinstance(root, ps.Collection):\n            <IND>new_collection = root.clone()\n"
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    result.clear_links()\n    result.ext.enable(Extensions.SINGLE_FILE_STAC)\n    sfs_ext = cast(\"SingleFileSTACCatalogExt\", result.ext[Extensions.SINGLE_FILE_STAC])\n    sfs_ext.apply(features=items, collections=filtered_collections)\n",
        "source_code_len": 232,
        "target_code": "    result.clear_links()\n    result.ext.enable(ps.Extensions.SINGLE_FILE_STAC)\n    sfs_ext = cast(\"SingleFileSTACCatalogExt\", result.ext[ps.Extensions.SINGLE_FILE_STAC])\n    sfs_ext.apply(features=items, collections=filtered_collections)\n",
        "target_code_len": 238,
        "diff_format": "@@ -43,4 +41,4 @@\n     result.clear_links()\n-    result.ext.enable(Extensions.SINGLE_FILE_STAC)\n-    sfs_ext = cast(\"SingleFileSTACCatalogExt\", result.ext[Extensions.SINGLE_FILE_STAC])\n+    result.ext.enable(ps.Extensions.SINGLE_FILE_STAC)\n+    sfs_ext = cast(\"SingleFileSTACCatalogExt\", result.ext[ps.Extensions.SINGLE_FILE_STAC])\n     sfs_ext.apply(features=items, collections=filtered_collections)\n",
        "source_code_with_indent": "    result.clear_links()\n    result.ext.enable(Extensions.SINGLE_FILE_STAC)\n    sfs_ext = cast(\"SingleFileSTACCatalogExt\", result.ext[Extensions.SINGLE_FILE_STAC])\n    sfs_ext.apply(features=items, collections=filtered_collections)\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    result.clear_links()\n    result.ext.enable(ps.Extensions.SINGLE_FILE_STAC)\n    sfs_ext = cast(\"SingleFileSTACCatalogExt\", result.ext[ps.Extensions.SINGLE_FILE_STAC])\n    sfs_ext.apply(features=items, collections=filtered_collections)\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    \"\"\"\n    def __init__(self, catalog: Catalog):\n        if catalog.stac_extensions is None:\n            catalog.stac_extensions = [str(Extensions.SINGLE_FILE_STAC)]\n        elif str(Extensions.SINGLE_FILE_STAC) not in catalog.stac_extensions:\n            catalog.stac_extensions.append(str(Extensions.SINGLE_FILE_STAC))\n\n",
        "source_code_len": 323,
        "target_code": "    \"\"\"\n    def __init__(self, catalog: ps.Catalog) -> None:\n        if catalog.stac_extensions is None:\n            catalog.stac_extensions = [str(ps.Extensions.SINGLE_FILE_STAC)]\n        elif str(ps.Extensions.SINGLE_FILE_STAC) not in catalog.stac_extensions:\n            catalog.stac_extensions.append(str(ps.Extensions.SINGLE_FILE_STAC))\n\n",
        "target_code_len": 343,
        "diff_format": "@@ -66,7 +64,7 @@\n     \"\"\"\n-    def __init__(self, catalog: Catalog):\n+    def __init__(self, catalog: ps.Catalog) -> None:\n         if catalog.stac_extensions is None:\n-            catalog.stac_extensions = [str(Extensions.SINGLE_FILE_STAC)]\n-        elif str(Extensions.SINGLE_FILE_STAC) not in catalog.stac_extensions:\n-            catalog.stac_extensions.append(str(Extensions.SINGLE_FILE_STAC))\n+            catalog.stac_extensions = [str(ps.Extensions.SINGLE_FILE_STAC)]\n+        elif str(ps.Extensions.SINGLE_FILE_STAC) not in catalog.stac_extensions:\n+            catalog.stac_extensions.append(str(ps.Extensions.SINGLE_FILE_STAC))\n \n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\n    def __init__(self, catalog: Catalog):\n        <IND>if catalog.stac_extensions is None:\n            <IND>catalog.stac_extensions = [str(Extensions.SINGLE_FILE_STAC)]\n        <DED>elif str(Extensions.SINGLE_FILE_STAC) not in catalog.stac_extensions:\n            <IND>catalog.stac_extensions.append(str(Extensions.SINGLE_FILE_STAC))\n\n",
        "target_code_with_indent": "\n    def __init__(self, catalog: ps.Catalog) -> None:\n        <IND>if catalog.stac_extensions is None:\n            <IND>catalog.stac_extensions = [str(ps.Extensions.SINGLE_FILE_STAC)]\n        <DED>elif str(ps.Extensions.SINGLE_FILE_STAC) not in catalog.stac_extensions:\n            <IND>catalog.stac_extensions.append(str(ps.Extensions.SINGLE_FILE_STAC))\n\n"
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n    def apply(self, features: List[Item], collections: Optional[List[Collection]] = None):\n        \"\"\"\n",
        "source_code_len": 104,
        "target_code": "\n    def apply(self,\n              features: List[Item],\n              collections: Optional[List[ps.Collection]] = None) -> None:\n        \"\"\"\n",
        "target_code_len": 143,
        "diff_format": "@@ -74,3 +72,5 @@\n \n-    def apply(self, features: List[Item], collections: Optional[List[Collection]] = None):\n+    def apply(self,\n+              features: List[Item],\n+              collections: Optional[List[ps.Collection]] = None) -> None:\n         \"\"\"\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\n    <DED>def apply(self, features: List[Item], collections: Optional[List[Collection]] = None):\n        <IND>",
        "target_code_with_indent": "\n    <DED>def apply(self,\n              features: List[Item],\n              collections: Optional[List[ps.Collection]] = None) -> None:\n        <IND>"
      },
      {
        "hunk_fit_TFix": true,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    @classmethod\n    def enable_extension(cls, catalog: Catalog):\n        # Ensure the 'type' property is correct so that the Catalog is valid GeoJSON.\n        catalog.extra_fields['type'] = 'FeatureCollection'\n\n",
        "source_code_len": 212,
        "target_code": "    @classmethod\n    def enable_extension(cls, stac_object: ps.STACObject) -> None:\n        # Ensure the 'type' property is correct so that the Catalog is valid GeoJSON.\n        if isinstance(stac_object, ps.Catalog):\n            stac_object.extra_fields['type'] = 'FeatureCollection'\n\n",
        "target_code_len": 286,
        "diff_format": "@@ -86,5 +86,6 @@\n     @classmethod\n-    def enable_extension(cls, catalog: Catalog):\n+    def enable_extension(cls, stac_object: ps.STACObject) -> None:\n         # Ensure the 'type' property is correct so that the Catalog is valid GeoJSON.\n-        catalog.extra_fields['type'] = 'FeatureCollection'\n+        if isinstance(stac_object, ps.Catalog):\n+            stac_object.extra_fields['type'] = 'FeatureCollection'\n \n",
        "source_code_with_indent": "    <DED>@classmethod\n    def enable_extension(cls, catalog: Catalog):\n        # Ensure the 'type' property is correct so that the Catalog is valid GeoJSON.\n        <IND>catalog.extra_fields['type'] = 'FeatureCollection'\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    <DED>@classmethod\n    def enable_extension(cls, stac_object: ps.STACObject) -> None:\n        # Ensure the 'type' property is correct so that the Catalog is valid GeoJSON.\n        <IND>if isinstance(stac_object, ps.Catalog):\n            <IND>stac_object.extra_fields['type'] = 'FeatureCollection'\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "        if features is None:\n            raise STACError('Invalid Single File STAC: does not have \"features\" property.')\n\n",
        "source_code_len": 122,
        "target_code": "        if features is None:\n            raise ps.STACError('Invalid Single File STAC: does not have \"features\" property.')\n\n",
        "target_code_len": 125,
        "diff_format": "@@ -99,3 +100,3 @@\n         if features is None:\n-            raise STACError('Invalid Single File STAC: does not have \"features\" property.')\n+            raise ps.STACError('Invalid Single File STAC: does not have \"features\" property.')\n \n",
        "source_code_with_indent": "        if features is None:\n            <IND>raise STACError('Invalid Single File STAC: does not have \"features\" property.')\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "        if features is None:\n            <IND>raise ps.STACError('Invalid Single File STAC: does not have \"features\" property.')\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    @property\n    def collections(self) -> Optional[List[Collection]]:\n        \"\"\"Get or sets a list of :class:`~pystac.Collection` objects contained\n",
        "source_code_len": 150,
        "target_code": "    @property\n    def collections(self) -> Optional[List[ps.Collection]]:\n        \"\"\"Get or sets a list of :class:`~pystac.Collection` objects contained\n",
        "target_code_len": 153,
        "diff_format": "@@ -108,3 +109,3 @@\n     @property\n-    def collections(self) -> Optional[List[Collection]]:\n+    def collections(self) -> Optional[List[ps.Collection]]:\n         \"\"\"Get or sets a list of :class:`~pystac.Collection` objects contained\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "    <DED>@property\n    def collections(self) -> Optional[List[Collection]]:\n        <IND>",
        "target_code_with_indent": "    <DED>@property\n    def collections(self) -> Optional[List[ps.Collection]]:\n        <IND>"
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "        else:\n            return [Collection.from_dict(col) for col in collections]\n\n    @collections.setter\n    def collections(self, v: Optional[List[Collection]]) -> None:\n        if v is not None:\n",
        "source_code_len": 201,
        "target_code": "        else:\n            return [ps.Collection.from_dict(col) for col in collections]\n\n    @collections.setter\n    def collections(self, v: Optional[List[ps.Collection]]) -> None:\n        if v is not None:\n",
        "target_code_len": 207,
        "diff_format": "@@ -117,6 +118,6 @@\n         else:\n-            return [Collection.from_dict(col) for col in collections]\n+            return [ps.Collection.from_dict(col) for col in collections]\n \n     @collections.setter\n-    def collections(self, v: Optional[List[Collection]]) -> None:\n+    def collections(self, v: Optional[List[ps.Collection]]) -> None:\n         if v is not None:\n",
        "source_code_with_indent": "        <DED>else:\n            <IND>return [Collection.from_dict(col) for col in collections]\n\n    <DED><DED>@collections.setter\n    def collections(self, v: Optional[List[Collection]]) -> None:\n        <IND>if v is not None:\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "        <DED>else:\n            <IND>return [ps.Collection.from_dict(col) for col in collections]\n\n    <DED><DED>@collections.setter\n    def collections(self, v: Optional[List[ps.Collection]]) -> None:\n        <IND>if v is not None:\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    @classmethod\n    def from_catalog(cls, catalog: Catalog):\n        return SingleFileSTACCatalogExt(catalog)\n",
        "source_code_len": 111,
        "target_code": "    @classmethod\n    def from_catalog(cls, catalog: ps.Catalog) -> \"SingleFileSTACCatalogExt\":\n        return SingleFileSTACCatalogExt(catalog)\n",
        "target_code_len": 144,
        "diff_format": "@@ -131,3 +132,3 @@\n     @classmethod\n-    def from_catalog(cls, catalog: Catalog):\n+    def from_catalog(cls, catalog: ps.Catalog) -> \"SingleFileSTACCatalogExt\":\n         return SingleFileSTACCatalogExt(catalog)\n",
        "source_code_with_indent": "    <DED>@classmethod\n    def from_catalog(cls, catalog: Catalog):\n        <IND>return SingleFileSTACCatalogExt(catalog)\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    <DED>@classmethod\n    def from_catalog(cls, catalog: ps.Catalog) -> \"SingleFileSTACCatalogExt\":\n        <IND>return SingleFileSTACCatalogExt(catalog)\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\nSFS_EXTENSION_DEFINITION = ExtensionDefinition(Extensions.SINGLE_FILE_STAC,\n                                               [ExtendedObject(Catalog, SingleFileSTACCatalogExt)])\n",
        "source_code_len": 177,
        "target_code": "\nSFS_EXTENSION_DEFINITION: ExtensionDefinition = ExtensionDefinition(\n    ps.Extensions.SINGLE_FILE_STAC, [ExtendedObject(ps.Catalog, SingleFileSTACCatalogExt)])\n",
        "target_code_len": 162,
        "diff_format": "@@ -135,3 +136,3 @@\n \n-SFS_EXTENSION_DEFINITION = ExtensionDefinition(Extensions.SINGLE_FILE_STAC,\n-                                               [ExtendedObject(Catalog, SingleFileSTACCatalogExt)])\n+SFS_EXTENSION_DEFINITION: ExtensionDefinition = ExtensionDefinition(\n+    ps.Extensions.SINGLE_FILE_STAC, [ExtendedObject(ps.Catalog, SingleFileSTACCatalogExt)])\n",
        "source_code_with_indent": "\n<DED><DED>SFS_EXTENSION_DEFINITION = ExtensionDefinition(Extensions.SINGLE_FILE_STAC,\n                                               [ExtendedObject(Catalog, SingleFileSTACCatalogExt)])\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n<DED><DED>SFS_EXTENSION_DEFINITION: ExtensionDefinition = ExtensionDefinition(\n    ps.Extensions.SINGLE_FILE_STAC, [ExtendedObject(ps.Catalog, SingleFileSTACCatalogExt)])\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "stac-utils/pystac",
    "commit": "c78f832a0462f27f17b420e93af7970c5f285e2d",
    "filename": "pystac/item.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/stac-utils-pystac/pystac/item.py",
    "file_hunks_size": 9,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "pystac/item.py:797:4 Inconsistent override [15]: `pystac.item.Item.set_self_href` overrides method defined in `ps.stac_object.LinkMixin` inconsistently. Returned type `None` is not a subtype of the overridden return `ps.stac_object.LinkMixin`.",
    "message": " `pystac.item.Item.set_self_href` overrides method defined in `ps.stac_object.LinkMixin` inconsistently. Returned type `None` is not a subtype of the overridden return `ps.stac_object.LinkMixin`.",
    "rule_id": "Inconsistent override [15]",
    "warning_line_no": 797,
    "warning_line": "    def set_self_href(self, href: str) -> None:"
  },
  {
    "project": "stac-utils/pystac",
    "commit": "c78f832a0462f27f17b420e93af7970c5f285e2d",
    "filename": "pystac/stac_io.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/stac-utils-pystac/pystac/stac_io.py",
    "file_hunks_size": 3,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "pystac/stac_io.py:139:15 Call error [29]: `Optional[typing.Callable[[Dict[str, typing.Any], Optional[str], Optional[Catalog]], STACObject]]` is not a function.",
    "message": " `Optional[typing.Callable[[Dict[str, typing.Any], Optional[str], Optional[Catalog]], STACObject]]` is not a function.",
    "rule_id": "Call error [29]",
    "warning_line_no": 139,
    "warning_line": "        return cls.stac_object_from_dict(d, uri, root)",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\nif TYPE_CHECKING:\n    from pystac.stac_object import STACObject\n    from pystac.catalog import Catalog\n\n",
        "source_code_len": 105,
        "target_code": "\nimport pystac.serialization\n\nif TYPE_CHECKING:\n    from pystac.stac_object import STACObject as STACObjectType\n    from pystac.catalog import Catalog as CatalogType\n\n",
        "target_code_len": 167,
        "diff_format": "@@ -8,5 +8,7 @@\n \n+import pystac.serialization\n+\n if TYPE_CHECKING:\n-    from pystac.stac_object import STACObject\n-    from pystac.catalog import Catalog\n+    from pystac.stac_object import STACObject as STACObjectType\n+    from pystac.catalog import Catalog as CatalogType\n \n",
        "source_code_with_indent": "\nif TYPE_CHECKING:\n    <IND>from pystac.stac_object import STACObject\n    from pystac.catalog import Catalog\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\nimport pystac.serialization\n\nif TYPE_CHECKING:\n    <IND>from pystac.stac_object import STACObject as STACObjectType\n    from pystac.catalog import Catalog as CatalogType\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n    # Replaced in __init__ to account for extension objects.\n    stac_object_from_dict: Optional[Callable[[Dict[str, Any], Optional[str], Optional[\"Catalog\"]],\n                                             \"STACObject\"]] = None\n\n",
        "source_code_len": 229,
        "target_code": "\n    @staticmethod\n    def stac_object_from_dict(d: Dict[str, Any],\n                              href: Optional[str] = None,\n                              root: Optional[\"CatalogType\"] = None) -> \"STACObjectType\":\n        return pystac.serialization.stac_object_from_dict(d, href, root)\n\n",
        "target_code_len": 289,
        "diff_format": "@@ -57,5 +59,7 @@\n \n-    # Replaced in __init__ to account for extension objects.\n-    stac_object_from_dict: Optional[Callable[[Dict[str, Any], Optional[str], Optional[\"Catalog\"]],\n-                                             \"STACObject\"]] = None\n+    @staticmethod\n+    def stac_object_from_dict(d: Dict[str, Any],\n+                              href: Optional[str] = None,\n+                              root: Optional[\"CatalogType\"] = None) -> \"STACObjectType\":\n+        return pystac.serialization.stac_object_from_dict(d, href, root)\n \n",
        "source_code_with_indent": "\n    # Replaced in __init__ to account for extension objects.\n    stac_object_from_dict: Optional[Callable[[Dict[str, Any], Optional[str], Optional[\"Catalog\"]],\n                                             \"STACObject\"]] = None\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n    @staticmethod\n    def stac_object_from_dict(d: Dict[str, Any],\n                              href: Optional[str] = None,\n                              root: Optional[\"CatalogType\"] = None) -> \"STACObjectType\":\n        <IND>return pystac.serialization.stac_object_from_dict(d, href, root)\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    @classmethod\n    def read_stac_object(cls, uri: str, root: Optional[\"Catalog\"] = None) -> \"STACObject\":\n        \"\"\"Read a STACObject from a JSON file at the given URI.\n",
        "source_code_len": 172,
        "target_code": "    @classmethod\n    def read_stac_object(cls, uri: str, root: Optional[\"CatalogType\"] = None) -> \"STACObjectType\":\n        \"\"\"Read a STACObject from a JSON file at the given URI.\n",
        "target_code_len": 180,
        "diff_format": "@@ -118,3 +122,3 @@\n     @classmethod\n-    def read_stac_object(cls, uri: str, root: Optional[\"Catalog\"] = None) -> \"STACObject\":\n+    def read_stac_object(cls, uri: str, root: Optional[\"CatalogType\"] = None) -> \"STACObjectType\":\n         \"\"\"Read a STACObject from a JSON file at the given URI.\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "    <DED>@classmethod\n    def read_stac_object(cls, uri: str, root: Optional[\"Catalog\"] = None) -> \"STACObject\":\n        <IND>",
        "target_code_with_indent": "    <DED>@classmethod\n    def read_stac_object(cls, uri: str, root: Optional[\"CatalogType\"] = None) -> \"STACObjectType\":\n        <IND>"
      }
    ]
  },
  {
    "project": "stac-utils/pystac",
    "commit": "c78f832a0462f27f17b420e93af7970c5f285e2d",
    "filename": "pystac/stac_object.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/stac-utils-pystac/pystac/stac_object.py",
    "file_hunks_size": 20,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "pystac/stac_object.py:456:12 Call error [29]: `Optional[typing.Callable[[Dict[str, typing.Any], Optional[str], Optional[CatalogType]], STACObject]]` is not a function.",
    "message": " `Optional[typing.Callable[[Dict[str, typing.Any], Optional[str], Optional[CatalogType]], STACObject]]` is not a function.",
    "rule_id": "Call error [29]",
    "warning_line_no": 456,
    "warning_line": "        o = STAC_IO.stac_object_from_dict(d, href, None)"
  },
  {
    "project": "stac-utils/pystac",
    "commit": "c78f832a0462f27f17b420e93af7970c5f285e2d",
    "filename": "pystac/validation/stac_validator.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/stac-utils-pystac/pystac/validation/stac_validator.py",
    "file_hunks_size": 6,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "pystac/validation/stac_validator.py:166:4 Inconsistent override [14]: `pystac.validation.stac_validator.JsonSchemaSTACValidator.validate_core` overrides method defined in `STACValidator` inconsistently. Parameter of type `STACObjectType` is not a supertype of the overridden parameter `str`.",
    "message": " `pystac.validation.stac_validator.JsonSchemaSTACValidator.validate_core` overrides method defined in `STACValidator` inconsistently. Parameter of type `STACObjectType` is not a supertype of the overridden parameter `str`.",
    "rule_id": "Inconsistent override [14]",
    "warning_line_no": 166,
    "warning_line": "    def validate_core(self,",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "                      stac_dict: Dict[str, Any],\n                      stac_object_type: str,\n                      stac_version: str,\n                      href: Optional[str] = None):\n        \"\"\"Validate a core stac object.\n",
        "source_code_len": 226,
        "target_code": "                      stac_dict: Dict[str, Any],\n                      stac_object_type: STACObjectType,\n                      stac_version: str,\n                      href: Optional[str] = None) -> Any:\n        \"\"\"Validate a core stac object.\n",
        "target_code_len": 244,
        "diff_format": "@@ -27,5 +27,5 @@\n                       stac_dict: Dict[str, Any],\n-                      stac_object_type: str,\n+                      stac_object_type: STACObjectType,\n                       stac_version: str,\n-                      href: Optional[str] = None):\n+                      href: Optional[str] = None) -> Any:\n         \"\"\"Validate a core stac object.\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "                      stac_dict: Dict[str, Any],\n                      stac_object_type: str,\n                      stac_version: str,\n                      href: Optional[str] = None):\n        <IND>",
        "target_code_with_indent": "                      stac_dict: Dict[str, Any],\n                      stac_object_type: STACObjectType,\n                      stac_version: str,\n                      href: Optional[str] = None) -> Any:\n        <IND>"
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "                 stac_dict: Dict[str, Any],\n                 stac_object_type: str,\n                 stac_version: str,\n                 extensions: List[str],\n                 href: Optional[str] = None):\n        \"\"\"Validate a STAC object JSON.\n",
        "source_code_len": 246,
        "target_code": "                 stac_dict: Dict[str, Any],\n                 stac_object_type: STACObjectType,\n                 stac_version: str,\n                 extensions: List[str],\n                 href: Optional[str] = None) -> List[Any]:\n        \"\"\"Validate a STAC object JSON.\n",
        "target_code_len": 270,
        "diff_format": "@@ -66,6 +66,6 @@\n                  stac_dict: Dict[str, Any],\n-                 stac_object_type: str,\n+                 stac_object_type: STACObjectType,\n                  stac_version: str,\n                  extensions: List[str],\n-                 href: Optional[str] = None):\n+                 href: Optional[str] = None) -> List[Any]:\n         \"\"\"Validate a STAC object JSON.\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "                 stac_dict: Dict[str, Any],\n                 stac_object_type: str,\n                 stac_version: str,\n                 extensions: List[str],\n                 href: Optional[str] = None):\n        <IND>",
        "target_code_with_indent": "                 stac_dict: Dict[str, Any],\n                 stac_object_type: STACObjectType,\n                 stac_version: str,\n                 extensions: List[str],\n                 href: Optional[str] = None) -> List[Any]:\n        <IND>"
      }
    ]
  },
  {
    "project": "stac-utils/pystac",
    "commit": "c78f832a0462f27f17b420e93af7970c5f285e2d",
    "filename": "pystac/validation/stac_validator.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/stac-utils-pystac/pystac/validation/stac_validator.py",
    "file_hunks_size": 6,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "pystac/validation/stac_validator.py:199:4 Inconsistent override [14]: `pystac.validation.stac_validator.JsonSchemaSTACValidator.validate_extension` overrides method defined in `STACValidator` inconsistently. Parameter of type `STACObjectType` is not a supertype of the overridden parameter `str`.",
    "message": " `pystac.validation.stac_validator.JsonSchemaSTACValidator.validate_extension` overrides method defined in `STACValidator` inconsistently. Parameter of type `STACObjectType` is not a supertype of the overridden parameter `str`.",
    "rule_id": "Inconsistent override [14]",
    "warning_line_no": 199,
    "warning_line": "    def validate_extension(self,",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "                           stac_dict: Dict[str, Any],\n                           stac_object_type: str,\n                           stac_version: str,\n                           extension_id: str,\n                           href: Optional[str] = None):\n        \"\"\"Validate an extension stac object.\n",
        "source_code_len": 298,
        "target_code": "                           stac_dict: Dict[str, Any],\n                           stac_object_type: STACObjectType,\n                           stac_version: str,\n                           extension_id: str,\n                           href: Optional[str] = None) -> Any:\n        \"\"\"Validate an extension stac object.\n",
        "target_code_len": 316,
        "diff_format": "@@ -46,6 +46,6 @@\n                            stac_dict: Dict[str, Any],\n-                           stac_object_type: str,\n+                           stac_object_type: STACObjectType,\n                            stac_version: str,\n                            extension_id: str,\n-                           href: Optional[str] = None):\n+                           href: Optional[str] = None) -> Any:\n         \"\"\"Validate an extension stac object.\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "                           stac_dict: Dict[str, Any],\n                           stac_object_type: str,\n                           stac_version: str,\n                           extension_id: str,\n                           href: Optional[str] = None):\n        <IND>",
        "target_code_with_indent": "                           stac_dict: Dict[str, Any],\n                           stac_object_type: STACObjectType,\n                           stac_version: str,\n                           extension_id: str,\n                           href: Optional[str] = None) -> Any:\n        <IND>"
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "                 stac_dict: Dict[str, Any],\n                 stac_object_type: str,\n                 stac_version: str,\n                 extensions: List[str],\n                 href: Optional[str] = None):\n        \"\"\"Validate a STAC object JSON.\n",
        "source_code_len": 246,
        "target_code": "                 stac_dict: Dict[str, Any],\n                 stac_object_type: STACObjectType,\n                 stac_version: str,\n                 extensions: List[str],\n                 href: Optional[str] = None) -> List[Any]:\n        \"\"\"Validate a STAC object JSON.\n",
        "target_code_len": 270,
        "diff_format": "@@ -66,6 +66,6 @@\n                  stac_dict: Dict[str, Any],\n-                 stac_object_type: str,\n+                 stac_object_type: STACObjectType,\n                  stac_version: str,\n                  extensions: List[str],\n-                 href: Optional[str] = None):\n+                 href: Optional[str] = None) -> List[Any]:\n         \"\"\"Validate a STAC object JSON.\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "                 stac_dict: Dict[str, Any],\n                 stac_object_type: str,\n                 stac_version: str,\n                 extensions: List[str],\n                 href: Optional[str] = None):\n        <IND>",
        "target_code_with_indent": "                 stac_dict: Dict[str, Any],\n                 stac_object_type: STACObjectType,\n                 stac_version: str,\n                 extensions: List[str],\n                 href: Optional[str] = None) -> List[Any]:\n        <IND>"
      }
    ]
  }
]