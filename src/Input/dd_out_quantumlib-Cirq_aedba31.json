[
  {
    "project": "quantumlib/Cirq",
    "commit": "aedba31ad854aeb52566a56d1dfbefc7830a7abe",
    "filename": "cirq/examples/bernstein-vasirani.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/quantumlib-Cirq/cirq/examples/bernstein_vazirani.py",
    "file_hunks_size": 2,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "cirq/examples/bernstein-vasirani.py:50:59 Unsupported operand [58]: `&` is not supported for operand types `str` and `int`.",
    "message": " `&` is not supported for operand types `str` and `int`.",
    "rule_id": "Unsupported operand [58]",
    "warning_line_no": 50,
    "warning_line": "  O_layer = [cirq.Z(qubits[i]) for i in range(n_qubits) if a & (1 << i)]",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\ndef bv(n_qubits: int,\n       a: str,\n       shots: int = NUM_SHOTS\n       ) -> collections.Counter:\n  \"\"\"Creates and executes the circuit for Bernstein-Vazirani algorithm.\n\n  Args:\n    n_qubits: integer < 30, number of qubits in the simulated circuit.\n    a: integer < 2**n_qubits, representing the unknown bit string.\n    circuit_name: string to identify the circuit\n    device: type of the device used\n    shots: number of times the circuit has been executed.\n\n  Returns:\n    Result object, containing measurement data after the circuit has run.\n  \"\"\"\n  # 1. Define a sequence of qubits.\n  qubits = [cirq.google.XmonQubit(0, x) for x in range(n_qubits)]\n  # 2. Create a circuit (qubits start in the |0> state).\n  circuit = cirq.circuits.Circuit()\n  # 3. Apply Hadamard gates to the inputs.\n  H_layer = [cirq.H(qubit) for qubit in qubits]\n  circuit.append(H_layer)\n  # 4. Apply the inner-product oracle\n  O_layer = [cirq.Z(qubits[i]) for i in range(n_qubits) if a & (1 << i)]\n  circuit.append(O_layer)\n  # 5. Apply Hadamard gates to the outputs\n  circuit.append(H_layer)\n  # 6. Apply measurement layer\n  circuit.append([cirq.ops.MeasurementGate('result {}'.format(i)).on(qubit)\n                  for i, qubit in enumerate(qubits)])\n\n  # 7. Debug step\n  print(circuit)\n  # 8. Run and collect results\n  simulator = cirq.google.Simulator()\n  results = collections.Counter()\n  for k in range(NUM_SHOTS):\n        result = simulator.run(circuit)\n        print('{0}sth run, results: {1}'.format(\n            k, sorted(list(result.measurements.items()))))\n        next_result = ''.join([str(int(\n            result.measurements['result {}'.format(i)][0]))\n                               for i in range(n_qubits)])\n        results[next_result]+=1\n  return results\n\ndef main(argv):\n  \"\"\"Demonstrates Bernstein-Vazirani algorithm.\n\n  Generates random number which could be represented with the given number of\n  qubits and uses it as the argument for BV circuit.\n  Shows that the returned measurement corresponds to the bit representation\n  of the generated number.\n  Args:\n    argv: unused.\n  \"\"\"\n  del argv  # Unused.\n  n_qubits = NUM_QUBITS\n  a = random.randrange(2**n_qubits - 1)\n  a_bitstring = bin(a)[2:].zfill(n_qubits)\n  print('Expected bitstring: {}'.format(a_bitstring))\n  results = bv(n_qubits, a)\n  print('Results: {}'.format(results))\n  print('Returned bitstring: ', results.most_common(1)[0])\n\nif __name__ == '__main__':\n  app.run(main)\n",
        "source_code_len": 2442,
        "target_code": "\n\ndef bitstring(bits):\n    return ''.join(str(int(b)) for b in bits)\n\n\ndef bv(n_qubits: int,\n       a: int,\n       shots: int = NUM_SHOTS\n       ) -> collections.Counter:\n    \"\"\"Creates and executes the circuit for Bernstein-Vazirani algorithm.\n\n    Args:\n        n_qubits: integer < 30, number of qubits in the simulated circuit.\n        a: integer < 2**n_qubits, representing the unknown bit string.\n        circuit_name: string to identify the circuit\n        device: type of the device used\n        shots: number of times the circuit has been executed.\n\n    Returns:\n        Result object, containing measurement data after the circuit has run.\n    \"\"\"\n    # 1. Define a sequence of qubits.\n    qubits = [cirq.google.XmonQubit(0, x) for x in range(n_qubits)]\n    # 2. Create a circuit (qubits start in the |0> state).\n    circuit = cirq.circuits.Circuit()\n    # 3. Apply Hadamard gates to the inputs.\n    H_layer = [cirq.H(qubit) for qubit in qubits]\n    circuit.append(H_layer)\n    # 4. Apply the inner-product oracle\n    O_layer = [cirq.Z(qubits[i]) for i in range(n_qubits) if a & (1 << i)]\n    circuit.append(O_layer)\n    # 5. Apply Hadamard gates to the outputs\n    circuit.append(H_layer)\n    # 6. Apply measurement layer\n    circuit.append(cirq.ops.MeasurementGate('result').on(qubit)\n                   for i, qubit in enumerate(qubits))\n\n    # 7. Debug step\n    print(circuit)\n    # 8. Run and collect results\n    simulator = cirq.google.Simulator()\n    result = simulator.run(circuit, repetitions=NUM_SHOTS)\n    result_bits = result.measurements['result']  # 2D array of (rep, qubit)\n    result_strs = [bitstring(bits) for bits in result_bits]\n    return collections.Counter(result_strs)\n\n\n\ndef main(argv):\n    \"\"\"Demonstrates Bernstein-Vazirani algorithm.\n\n    Generates random number which could be represented with the given number of\n    qubits and uses it as the argument for BV circuit.\n    Shows that the returned measurement corresponds to the bit representation\n    of the generated number.\n\n    Args:\n        argv: unused.\n    \"\"\"\n    del argv  # Unused.\n    n_qubits = NUM_QUBITS\n    a = random.randrange(2**n_qubits - 1)\n    a_bits = [bool(a & (1 << i)) for i in range(n_qubits)]\n    a_bitstring = bitstring(a_bits)\n    print('Expected bitstring: {}'.format(a_bitstring))\n    results = bv(n_qubits, a)\n    print('Results: {}'.format(results))\n    print('Returned bitstring: ', results.most_common(1)[0])\n\n\nif __name__ == '__main__':\n    app.run(main)\n",
        "target_code_len": 2477,
        "diff_format": "@@ -25,69 +26,73 @@\n \n+\n+def bitstring(bits):\n+    return ''.join(str(int(b)) for b in bits)\n+\n+\n def bv(n_qubits: int,\n-       a: str,\n+       a: int,\n        shots: int = NUM_SHOTS\n        ) -> collections.Counter:\n-  \"\"\"Creates and executes the circuit for Bernstein-Vazirani algorithm.\n+    \"\"\"Creates and executes the circuit for Bernstein-Vazirani algorithm.\n \n-  Args:\n-    n_qubits: integer < 30, number of qubits in the simulated circuit.\n-    a: integer < 2**n_qubits, representing the unknown bit string.\n-    circuit_name: string to identify the circuit\n-    device: type of the device used\n-    shots: number of times the circuit has been executed.\n+    Args:\n+        n_qubits: integer < 30, number of qubits in the simulated circuit.\n+        a: integer < 2**n_qubits, representing the unknown bit string.\n+        circuit_name: string to identify the circuit\n+        device: type of the device used\n+        shots: number of times the circuit has been executed.\n \n-  Returns:\n-    Result object, containing measurement data after the circuit has run.\n-  \"\"\"\n-  # 1. Define a sequence of qubits.\n-  qubits = [cirq.google.XmonQubit(0, x) for x in range(n_qubits)]\n-  # 2. Create a circuit (qubits start in the |0> state).\n-  circuit = cirq.circuits.Circuit()\n-  # 3. Apply Hadamard gates to the inputs.\n-  H_layer = [cirq.H(qubit) for qubit in qubits]\n-  circuit.append(H_layer)\n-  # 4. Apply the inner-product oracle\n-  O_layer = [cirq.Z(qubits[i]) for i in range(n_qubits) if a & (1 << i)]\n-  circuit.append(O_layer)\n-  # 5. Apply Hadamard gates to the outputs\n-  circuit.append(H_layer)\n-  # 6. Apply measurement layer\n-  circuit.append([cirq.ops.MeasurementGate('result {}'.format(i)).on(qubit)\n-                  for i, qubit in enumerate(qubits)])\n+    Returns:\n+        Result object, containing measurement data after the circuit has run.\n+    \"\"\"\n+    # 1. Define a sequence of qubits.\n+    qubits = [cirq.google.XmonQubit(0, x) for x in range(n_qubits)]\n+    # 2. Create a circuit (qubits start in the |0> state).\n+    circuit = cirq.circuits.Circuit()\n+    # 3. Apply Hadamard gates to the inputs.\n+    H_layer = [cirq.H(qubit) for qubit in qubits]\n+    circuit.append(H_layer)\n+    # 4. Apply the inner-product oracle\n+    O_layer = [cirq.Z(qubits[i]) for i in range(n_qubits) if a & (1 << i)]\n+    circuit.append(O_layer)\n+    # 5. Apply Hadamard gates to the outputs\n+    circuit.append(H_layer)\n+    # 6. Apply measurement layer\n+    circuit.append(cirq.ops.MeasurementGate('result').on(qubit)\n+                   for i, qubit in enumerate(qubits))\n \n-  # 7. Debug step\n-  print(circuit)\n-  # 8. Run and collect results\n-  simulator = cirq.google.Simulator()\n-  results = collections.Counter()\n-  for k in range(NUM_SHOTS):\n-        result = simulator.run(circuit)\n-        print('{0}sth run, results: {1}'.format(\n-            k, sorted(list(result.measurements.items()))))\n-        next_result = ''.join([str(int(\n-            result.measurements['result {}'.format(i)][0]))\n-                               for i in range(n_qubits)])\n-        results[next_result]+=1\n-  return results\n+    # 7. Debug step\n+    print(circuit)\n+    # 8. Run and collect results\n+    simulator = cirq.google.Simulator()\n+    result = simulator.run(circuit, repetitions=NUM_SHOTS)\n+    result_bits = result.measurements['result']  # 2D array of (rep, qubit)\n+    result_strs = [bitstring(bits) for bits in result_bits]\n+    return collections.Counter(result_strs)\n+\n+\n \n def main(argv):\n-  \"\"\"Demonstrates Bernstein-Vazirani algorithm.\n+    \"\"\"Demonstrates Bernstein-Vazirani algorithm.\n \n-  Generates random number which could be represented with the given number of\n-  qubits and uses it as the argument for BV circuit.\n-  Shows that the returned measurement corresponds to the bit representation\n-  of the generated number.\n-  Args:\n-    argv: unused.\n-  \"\"\"\n-  del argv  # Unused.\n-  n_qubits = NUM_QUBITS\n-  a = random.randrange(2**n_qubits - 1)\n-  a_bitstring = bin(a)[2:].zfill(n_qubits)\n-  print('Expected bitstring: {}'.format(a_bitstring))\n-  results = bv(n_qubits, a)\n-  print('Results: {}'.format(results))\n-  print('Returned bitstring: ', results.most_common(1)[0])\n+    Generates random number which could be represented with the given number of\n+    qubits and uses it as the argument for BV circuit.\n+    Shows that the returned measurement corresponds to the bit representation\n+    of the generated number.\n+\n+    Args:\n+        argv: unused.\n+    \"\"\"\n+    del argv  # Unused.\n+    n_qubits = NUM_QUBITS\n+    a = random.randrange(2**n_qubits - 1)\n+    a_bits = [bool(a & (1 << i)) for i in range(n_qubits)]\n+    a_bitstring = bitstring(a_bits)\n+    print('Expected bitstring: {}'.format(a_bitstring))\n+    results = bv(n_qubits, a)\n+    print('Results: {}'.format(results))\n+    print('Returned bitstring: ', results.most_common(1)[0])\n+\n \n if __name__ == '__main__':\n-  app.run(main)\n+    app.run(main)\n",
        "source_code_with_indent": "\ndef bv(n_qubits: int,\n       a: str,\n       shots: int = NUM_SHOTS\n       ) -> collections.Counter:\n  <IND>\"\"\"Creates and executes the circuit for Bernstein-Vazirani algorithm.\n\n  Args:\n    n_qubits: integer < 30, number of qubits in the simulated circuit.\n    a: integer < 2**n_qubits, representing the unknown bit string.\n    circuit_name: string to identify the circuit\n    device: type of the device used\n    shots: number of times the circuit has been executed.\n\n  Returns:\n    Result object, containing measurement data after the circuit has run.\n  \"\"\"\n  # 1. Define a sequence of qubits.\n  qubits = [cirq.google.XmonQubit(0, x) for x in range(n_qubits)]\n  # 2. Create a circuit (qubits start in the |0> state).\n  circuit = cirq.circuits.Circuit()\n  # 3. Apply Hadamard gates to the inputs.\n  H_layer = [cirq.H(qubit) for qubit in qubits]\n  circuit.append(H_layer)\n  # 4. Apply the inner-product oracle\n  O_layer = [cirq.Z(qubits[i]) for i in range(n_qubits) if a & (1 << i)]\n  circuit.append(O_layer)\n  # 5. Apply Hadamard gates to the outputs\n  circuit.append(H_layer)\n  # 6. Apply measurement layer\n  circuit.append([cirq.ops.MeasurementGate('result {}'.format(i)).on(qubit)\n                  for i, qubit in enumerate(qubits)])\n\n  # 7. Debug step\n  print(circuit)\n  # 8. Run and collect results\n  simulator = cirq.google.Simulator()\n  results = collections.Counter()\n  for k in range(NUM_SHOTS):\n        <IND>result = simulator.run(circuit)\n        print('{0}sth run, results: {1}'.format(\n            k, sorted(list(result.measurements.items()))))\n        next_result = ''.join([str(int(\n            result.measurements['result {}'.format(i)][0]))\n                               for i in range(n_qubits)])\n        results[next_result]+=1\n  <DED>return results\n\n<DED>def main(argv):\n  <IND>\"\"\"Demonstrates Bernstein-Vazirani algorithm.\n\n  Generates random number which could be represented with the given number of\n  qubits and uses it as the argument for BV circuit.\n  Shows that the returned measurement corresponds to the bit representation\n  of the generated number.\n  Args:\n    argv: unused.\n  \"\"\"\n  del argv  # Unused.\n  n_qubits = NUM_QUBITS\n  a = random.randrange(2**n_qubits - 1)\n  a_bitstring = bin(a)[2:].zfill(n_qubits)\n  print('Expected bitstring: {}'.format(a_bitstring))\n  results = bv(n_qubits, a)\n  print('Results: {}'.format(results))\n  print('Returned bitstring: ', results.most_common(1)[0])\n\n<DED>if __name__ == '__main__':\n  <IND>app.run(main)\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n\ndef bitstring(bits):\n    <IND>return ''.join(str(int(b)) for b in bits)\n\n\n<DED>def bv(n_qubits: int,\n       a: int,\n       shots: int = NUM_SHOTS\n       ) -> collections.Counter:\n    <IND>\"\"\"Creates and executes the circuit for Bernstein-Vazirani algorithm.\n\n    Args:\n        n_qubits: integer < 30, number of qubits in the simulated circuit.\n        a: integer < 2**n_qubits, representing the unknown bit string.\n        circuit_name: string to identify the circuit\n        device: type of the device used\n        shots: number of times the circuit has been executed.\n\n    Returns:\n        Result object, containing measurement data after the circuit has run.\n    \"\"\"\n    # 1. Define a sequence of qubits.\n    qubits = [cirq.google.XmonQubit(0, x) for x in range(n_qubits)]\n    # 2. Create a circuit (qubits start in the |0> state).\n    circuit = cirq.circuits.Circuit()\n    # 3. Apply Hadamard gates to the inputs.\n    H_layer = [cirq.H(qubit) for qubit in qubits]\n    circuit.append(H_layer)\n    # 4. Apply the inner-product oracle\n    O_layer = [cirq.Z(qubits[i]) for i in range(n_qubits) if a & (1 << i)]\n    circuit.append(O_layer)\n    # 5. Apply Hadamard gates to the outputs\n    circuit.append(H_layer)\n    # 6. Apply measurement layer\n    circuit.append(cirq.ops.MeasurementGate('result').on(qubit)\n                   for i, qubit in enumerate(qubits))\n\n    # 7. Debug step\n    print(circuit)\n    # 8. Run and collect results\n    simulator = cirq.google.Simulator()\n    result = simulator.run(circuit, repetitions=NUM_SHOTS)\n    result_bits = result.measurements['result']  # 2D array of (rep, qubit)\n    result_strs = [bitstring(bits) for bits in result_bits]\n    return collections.Counter(result_strs)\n\n\n\n<DED>def main(argv):\n    <IND>\"\"\"Demonstrates Bernstein-Vazirani algorithm.\n\n    Generates random number which could be represented with the given number of\n    qubits and uses it as the argument for BV circuit.\n    Shows that the returned measurement corresponds to the bit representation\n    of the generated number.\n\n    Args:\n        argv: unused.\n    \"\"\"\n    del argv  # Unused.\n    n_qubits = NUM_QUBITS\n    a = random.randrange(2**n_qubits - 1)\n    a_bits = [bool(a & (1 << i)) for i in range(n_qubits)]\n    a_bitstring = bitstring(a_bits)\n    print('Expected bitstring: {}'.format(a_bitstring))\n    results = bv(n_qubits, a)\n    print('Results: {}'.format(results))\n    print('Returned bitstring: ', results.most_common(1)[0])\n\n\n<DED>if __name__ == '__main__':\n    <IND>app.run(main)\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  }
]