[
  {
    "project": "great-expectations/great_expectations",
    "commit": "6cd804579baed5906513245520bf6e5c0b23c5b9",
    "filename": "great_expectations/render/renderer/content_block/expectation_string.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/great-expectations-great_expectations/great_expectations/render/renderer/content_block/expectation_string.py",
    "file_hunks_size": 5,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "great_expectations/render/renderer/content_block/expectation_string.py:83:44 Invalid type [31]: Expression `(str, str)` is not a valid type.",
    "message": " Expression `(str, str)` is not a valid type.",
    "rule_id": "Invalid type [31]",
    "warning_line_no": 83,
    "warning_line": "def handle_strict_min_max(params: dict) -> (str, str):",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": ")\nfrom great_expectations.render.types import (\n    RenderedGraphContent,\n    RenderedStringTemplateContent,\n)\nfrom great_expectations.render.util import num_to_str, ordinal\n\n\ndef substitute_none_for_missing(kwargs, kwarg_list):\n    \"\"\"Utility function to plug Nones in when optional parameters are not specified in expectation kwargs.\n\n    Example:\n        Input:\n            kwargs={\"a\":1, \"b\":2},\n            kwarg_list=[\"c\", \"d\"]\n\n        Output: {\"a\":1, \"b\":2, \"c\": None, \"d\": None}\n\n    This is helpful for standardizing the input objects for rendering functions.\n    The alternative is lots of awkward `if \"some_param\" not in kwargs or kwargs[\"some_param\"] == None:` clauses in renderers.\n    \"\"\"\n\n    new_kwargs = copy.deepcopy(kwargs)\n    for kwarg in kwarg_list:\n        if kwarg not in new_kwargs:\n            new_kwargs[kwarg] = None\n    return new_kwargs\n\n\n# NOTE: the method is pretty dirty\ndef parse_row_condition_string_pandas_engine(condition_string):\n    if len(condition_string) == 0:\n        condition_string = \"True\"\n\n    template_str = \"if \"\n    params = dict()\n\n    condition_string = (\n        condition_string.replace(\"&\", \" AND \")\n        .replace(\" and \", \" AND \")\n        .replace(\"|\", \" OR \")\n        .replace(\" or \", \" OR \")\n        .replace(\"~\", \" NOT \")\n        .replace(\" not \", \" NOT \")\n    )\n    condition_string = \" \".join(condition_string.split())\n\n    # replace tuples of values by lists of values\n    tuples_list = re.findall(r\"\\([^\\(\\)]*,[^\\(\\)]*\\)\", condition_string)\n    for value_tuple in tuples_list:\n        value_list = value_tuple.replace(\"(\", \"[\").replace(\")\", \"]\")\n        condition_string = condition_string.replace(value_tuple, value_list)\n\n    # divide the whole condition into smaller parts\n    conditions_list = re.split(r\"AND|OR|NOT(?! in)|\\(|\\)\", condition_string)\n    conditions_list = [\n        condition.strip()\n        for condition in conditions_list\n        if condition != \"\" and condition != \" \"\n    ]\n\n    for i, condition in enumerate(conditions_list):\n        params[\"row_condition__\" + str(i)] = condition.replace(\" NOT \", \" not \")\n        condition_string = condition_string.replace(\n            condition, \"$row_condition__\" + str(i)\n        )\n\n    template_str += condition_string.lower()\n\n    return template_str, params\n\n\ndef handle_strict_min_max(params: dict) -> (str, str):\n    \"\"\"\n    Utility function for the at least and at most conditions based on strictness.\n\n    Args:\n        params: dictionary containing \"strict_min\" and \"strict_max\" booleans.\n\n    Returns:\n        tuple of strings to use for the at least condition and the at most condition\n    \"\"\"\n\n    at_least_str = (\n        \"greater than\"\n        if params.get(\"strict_min\") is True\n        else \"greater than or equal to\"\n    )\n    at_most_str = (\n        \"less than\" if params.get(\"strict_max\") is True else \"less than or equal to\"\n    )\n\n    return at_least_str, at_most_str\n\n",
        "source_code_len": 2921,
        "target_code": ")\nfrom great_expectations.render.types import RenderedStringTemplateContent\n\n",
        "target_code_len": 77,
        "diff_format": "@@ -11,94 +3,3 @@\n )\n-from great_expectations.render.types import (\n-    RenderedGraphContent,\n-    RenderedStringTemplateContent,\n-)\n-from great_expectations.render.util import num_to_str, ordinal\n-\n-\n-def substitute_none_for_missing(kwargs, kwarg_list):\n-    \"\"\"Utility function to plug Nones in when optional parameters are not specified in expectation kwargs.\n-\n-    Example:\n-        Input:\n-            kwargs={\"a\":1, \"b\":2},\n-            kwarg_list=[\"c\", \"d\"]\n-\n-        Output: {\"a\":1, \"b\":2, \"c\": None, \"d\": None}\n-\n-    This is helpful for standardizing the input objects for rendering functions.\n-    The alternative is lots of awkward `if \"some_param\" not in kwargs or kwargs[\"some_param\"] == None:` clauses in renderers.\n-    \"\"\"\n-\n-    new_kwargs = copy.deepcopy(kwargs)\n-    for kwarg in kwarg_list:\n-        if kwarg not in new_kwargs:\n-            new_kwargs[kwarg] = None\n-    return new_kwargs\n-\n-\n-# NOTE: the method is pretty dirty\n-def parse_row_condition_string_pandas_engine(condition_string):\n-    if len(condition_string) == 0:\n-        condition_string = \"True\"\n-\n-    template_str = \"if \"\n-    params = dict()\n-\n-    condition_string = (\n-        condition_string.replace(\"&\", \" AND \")\n-        .replace(\" and \", \" AND \")\n-        .replace(\"|\", \" OR \")\n-        .replace(\" or \", \" OR \")\n-        .replace(\"~\", \" NOT \")\n-        .replace(\" not \", \" NOT \")\n-    )\n-    condition_string = \" \".join(condition_string.split())\n-\n-    # replace tuples of values by lists of values\n-    tuples_list = re.findall(r\"\\([^\\(\\)]*,[^\\(\\)]*\\)\", condition_string)\n-    for value_tuple in tuples_list:\n-        value_list = value_tuple.replace(\"(\", \"[\").replace(\")\", \"]\")\n-        condition_string = condition_string.replace(value_tuple, value_list)\n-\n-    # divide the whole condition into smaller parts\n-    conditions_list = re.split(r\"AND|OR|NOT(?! in)|\\(|\\)\", condition_string)\n-    conditions_list = [\n-        condition.strip()\n-        for condition in conditions_list\n-        if condition != \"\" and condition != \" \"\n-    ]\n-\n-    for i, condition in enumerate(conditions_list):\n-        params[\"row_condition__\" + str(i)] = condition.replace(\" NOT \", \" not \")\n-        condition_string = condition_string.replace(\n-            condition, \"$row_condition__\" + str(i)\n-        )\n-\n-    template_str += condition_string.lower()\n-\n-    return template_str, params\n-\n-\n-def handle_strict_min_max(params: dict) -> (str, str):\n-    \"\"\"\n-    Utility function for the at least and at most conditions based on strictness.\n-\n-    Args:\n-        params: dictionary containing \"strict_min\" and \"strict_max\" booleans.\n-\n-    Returns:\n-        tuple of strings to use for the at least condition and the at most condition\n-    \"\"\"\n-\n-    at_least_str = (\n-        \"greater than\"\n-        if params.get(\"strict_min\") is True\n-        else \"greater than or equal to\"\n-    )\n-    at_most_str = (\n-        \"less than\" if params.get(\"strict_max\") is True else \"less than or equal to\"\n-    )\n-\n-    return at_least_str, at_most_str\n+from great_expectations.render.types import RenderedStringTemplateContent\n \n",
        "source_code_with_indent": ")\nfrom great_expectations.render.types import (\n    RenderedGraphContent,\n    RenderedStringTemplateContent,\n)\nfrom great_expectations.render.util import num_to_str, ordinal\n\n\ndef substitute_none_for_missing(kwargs, kwarg_list):\n    <IND>\"\"\"Utility function to plug Nones in when optional parameters are not specified in expectation kwargs.\n\n    Example:\n        Input:\n            kwargs={\"a\":1, \"b\":2},\n            kwarg_list=[\"c\", \"d\"]\n\n        Output: {\"a\":1, \"b\":2, \"c\": None, \"d\": None}\n\n    This is helpful for standardizing the input objects for rendering functions.\n    The alternative is lots of awkward `if \"some_param\" not in kwargs or kwargs[\"some_param\"] == None:` clauses in renderers.\n    \"\"\"\n\n    new_kwargs = copy.deepcopy(kwargs)\n    for kwarg in kwarg_list:\n        <IND>if kwarg not in new_kwargs:\n            <IND>new_kwargs[kwarg] = None\n    <DED><DED>return new_kwargs\n\n\n# NOTE: the method is pretty dirty\n<DED>def parse_row_condition_string_pandas_engine(condition_string):\n    <IND>if len(condition_string) == 0:\n        <IND>condition_string = \"True\"\n\n    <DED>template_str = \"if \"\n    params = dict()\n\n    condition_string = (\n        condition_string.replace(\"&\", \" AND \")\n        .replace(\" and \", \" AND \")\n        .replace(\"|\", \" OR \")\n        .replace(\" or \", \" OR \")\n        .replace(\"~\", \" NOT \")\n        .replace(\" not \", \" NOT \")\n    )\n    condition_string = \" \".join(condition_string.split())\n\n    # replace tuples of values by lists of values\n    tuples_list = re.findall(r\"\\([^\\(\\)]*,[^\\(\\)]*\\)\", condition_string)\n    for value_tuple in tuples_list:\n        <IND>value_list = value_tuple.replace(\"(\", \"[\").replace(\")\", \"]\")\n        condition_string = condition_string.replace(value_tuple, value_list)\n\n    # divide the whole condition into smaller parts\n    <DED>conditions_list = re.split(r\"AND|OR|NOT(?! in)|\\(|\\)\", condition_string)\n    conditions_list = [\n        condition.strip()\n        for condition in conditions_list\n        if condition != \"\" and condition != \" \"\n    ]\n\n    for i, condition in enumerate(conditions_list):\n        <IND>params[\"row_condition__\" + str(i)] = condition.replace(\" NOT \", \" not \")\n        condition_string = condition_string.replace(\n            condition, \"$row_condition__\" + str(i)\n        )\n\n    <DED>template_str += condition_string.lower()\n\n    return template_str, params\n\n\n<DED>def handle_strict_min_max(params: dict) -> (str, str):\n    <IND>\"\"\"\n    Utility function for the at least and at most conditions based on strictness.\n\n    Args:\n        params: dictionary containing \"strict_min\" and \"strict_max\" booleans.\n\n    Returns:\n        tuple of strings to use for the at least condition and the at most condition\n    \"\"\"\n\n    at_least_str = (\n        \"greater than\"\n        if params.get(\"strict_min\") is True\n        else \"greater than or equal to\"\n    )\n    at_most_str = (\n        \"less than\" if params.get(\"strict_max\") is True else \"less than or equal to\"\n    )\n\n    return at_least_str, at_most_str\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": ")\nfrom great_expectations.render.types import RenderedStringTemplateContent\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  }
]