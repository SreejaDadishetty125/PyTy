[
  {
    "project": "trailofbits/manticore",
    "commit": "169904561a19af964a45543482ff798be651edc4",
    "filename": "manticore/abitypes.py",
    "min_patch_found": false,
    "full_warning_msg": "manticore/abitypes.py:226:36 Incompatible parameter type [6]: Expected `typing.Type[Warning]` for 2nd parameter `category` to call `warnings.simplefilter` but got `str`.",
    "exception": "PatchSet should only have 1 Patch, but it has 0",
    "dd_fail": true
  },
  {
    "project": "trailofbits/manticore",
    "commit": "169904561a19af964a45543482ff798be651edc4",
    "filename": "manticore/ethereum/__init__.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/trailofbits-manticore/manticore/ethereum/__init__.py",
    "file_hunks_size": 2,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "manticore/ethereum/__init__.py:472:33 Incompatible variable type [9]: workspace_url is declared to have type `str` but is used as type `None`.",
    "message": " workspace_url is declared to have type `str` but is used as type `None`.",
    "rule_id": "Incompatible variable type [9]",
    "warning_line_no": 472,
    "warning_line": "    def __init__(self, procs=10, workspace_url: str=None, policy: str='random'):",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\nlogger = logging.getLogger(__name__)\n\ninit_logging()  # FIXME(mark): emitting a warning in abi.py does not work unless this is called a second time here\n\n\ndef flagged(flag):\n    \"\"\"\n    Return special character denoting concretization happened.\n    \"\"\"\n    return '(*)' if flag else ''\n\n\ndef write_findings(method, lead_space, address, pc, at_init=\"\"):\n    \"\"\"\n    Writes contract address and EVM program counter indicating whether counter was read at constructor\n    :param method: pointer to the object with the write method\n    :param lead_space: leading white space\n    :param address: contract address\n    :param pc: program counter\n    :param at_init: Boolean\n    :return: pass\n    \"\"\"\n    method.write(f'{lead_space}Contract: 0x:{address}')\n    method.write(f'{lead_space}EVM Program counter: 0x{pc}{\" (at constructor)\" if at_init else \"\"}\\n')\n\n#\n# Plugins\n#\n\n\nclass FilterFunctions(Plugin):\n    def __init__(self, regexp=r'.*', mutability='both', depth='both', fallback=False, include=True, **kwargs):\n        \"\"\"\n            Constrain input based on function metadata. Include or avoid functions selected by the specified criteria.\n\n            Examples:\n            #Do not explore any human transactions that end up calling a constant function\n            no_human_constant = FilterFunctions(depth='human', mutability='constant', include=False)\n\n            #At human tx depth only accept synthetic check functions\n            only_tests = FilterFunctions(regexp=r'mcore_.*', depth='human', include=False)\n\n            :param regexp: a regular expression over the name of the function '.*' will match all functions\n            :param mutability: mutable, constant or both will match functions declared in the abi to be of such class\n            :param depth: match functions in internal transactions, in human initiated transactions or in both types\n            :param fallback: if True include the fallback function. Hash will be 00000000 for it\n            :param include: if False exclude the selected functions, if True include them\n        \"\"\"\n        super().__init__(**kwargs)\n        depth = depth.lower()\n        if depth not in ('human', 'internal', 'both'):\n            raise ValueError\n        mutability = mutability.lower()\n        if mutability not in ('mutable', 'constant', 'both'):\n            raise ValueError\n\n        #fixme better names for member variables\n        self._regexp = regexp\n        self._mutability = mutability\n        self._depth = depth\n        self._fallback = fallback\n        self._include = include\n\n    def will_open_transaction_callback(self, state, tx):\n        world = state.platform\n        tx_cnt = len(world.all_transactions)\n        # Constrain input only once per tx, per plugin\n        if state.context.get('constrained%d' % id(self), 0) != tx_cnt:\n            state.context['constrained%d' % id(self)] = tx_cnt\n\n            if self._depth == 'human' and not tx.is_human:\n                return\n            if self._depth == 'internal' and tx.is_human:\n                return\n\n            #Get metadata if any for the target address of current tx\n            md = self.manticore.get_metadata(tx.address)\n            if md is None:\n                return\n            #Let's compile  the list of interesting hashes\n            selected_functions = []\n\n            for func_hsh in md.function_selectors:\n                abi = md.get_abi(func_hsh)\n                if abi['type'] == 'fallback':\n                    continue\n                if self._mutability == 'constant' and not abi.get('constant', False):\n                    continue\n                if self._mutability == 'mutable' and abi.get('constant', False):\n                    continue\n                if not re.match(self._regexp, abi['name']):\n                    continue\n                selected_functions.append(func_hsh)\n\n            if self._fallback and md.has_non_default_fallback_function:\n                selected_functions.append(md.fallback_function_selector)\n\n            if self._include:\n                # constrain the input so it can take only the interesting values\n                constraint = reduce(Operators.OR, (tx.data[:4] == x for x in selected_functions))\n                state.constrain(constraint)\n            else:\n                #Avoid all not selected hashes\n                for func_hsh in md.function_selectors:\n                    if func_hsh in selected_functions:\n                        constraint = tx.data[:4] != func_hsh\n                        state.constrain(constraint)\n\n\nclass LoopDepthLimiter(Plugin):\n    ''' This just aborts explorations that are too deep '''\n\n    def __init__(self, loop_count_threshold=5, **kwargs):\n        super().__init__(**kwargs)\n        self.loop_count_threshold = loop_count_threshold\n\n    def will_start_run_callback(self, *args):\n        with self.manticore.locked_context('seen_rep', dict) as reps:\n            reps.clear()\n\n    def will_execute_instruction_callback(self, state, pc, insn):\n        world = state.platform\n        with self.manticore.locked_context('seen_rep', dict) as reps:\n            item = (world.current_transaction.sort == 'CREATE', world.current_transaction.address, pc)\n            if item not in reps:\n                reps[item] = 0\n            reps[item] += 1\n            if reps[item] > self.loop_count_threshold:\n                state.abandon()\n\n\nclass VerboseTrace(Plugin):\n    def will_evm_execute_instruction_callback(self, state, instruction, arguments):\n        current_vm = state.platform.current_vm\n        state.setdefault('str_trace', []).append(str(current_vm))\n\n    def on_finalize(self, state, testcase):\n        with testcase.open_stream('str_trace') as str_trace_f:\n            str_trace_f.write('\\n'.join(state.context.get('str_trace', [])))\n\n\ndef calculate_coverage(runtime_bytecode, seen):\n    \"\"\" Calculates what percentage of runtime_bytecode has been seen \"\"\"\n    count, total = 0, 0\n    bytecode = SolidityMetadata._without_metadata(runtime_bytecode)\n    for i in EVMAsm.disassemble_all(bytecode):\n        if i.pc in seen:\n            count += 1\n        total += 1\n\n    if total == 0:\n        #No runtime_bytecode\n        return 0\n    return count * 100.0 / total\n\n\nclass ManticoreEVM(Manticore):\n    \"\"\" Manticore EVM manager\n\n        Usage Ex::\n\n            from manticore.ethereum import ManticoreEVM, ABI\n            m = ManticoreEVM()\n            #And now make the contract account to analyze\n            source_code = '''\n                pragma solidity ^0.4.15;\n                contract AnInt {\n                    uint private i=0;\n                    function set(uint value){\n                        i=value\n                    }\n                }\n            '''\n            #Initialize user and contracts\n            user_account = m.create_account(balance=1000)\n            contract_account = m.solidity_create_contract(source_code, owner=user_account, balance=0)\n            contract_account.set(12345, value=100)\n\n            m.finalize()\n    \"\"\"\n\n    def make_symbolic_buffer(self, size, name=None):\n        \"\"\" Creates a symbolic buffer of size bytes to be used in transactions.\n            You can operate on it normally and add constraints to manticore.constraints\n            via manticore.constrain(constraint_expression)\n\n            Example use::\n\n                symbolic_data = m.make_symbolic_buffer(320)\n                m.constrain(symbolic_data[0] == 0x65)\n                m.transaction(caller=attacker_account,\n                                address=contract_account,\n                                data=symbolic_data,\n                                value=100000 )\n        \"\"\"\n        avoid_collisions = False\n        if name is None:\n            name = 'TXBUFFER'\n            avoid_collisions = True\n        return self.constraints.new_array(index_bits=256, name=name, index_max=size, value_bits=8, taint=frozenset(), avoid_collisions=avoid_collisions)\n\n    def make_symbolic_value(self, nbits=256, name=None):\n        \"\"\" Creates a symbolic value, normally a uint256, to be used in transactions.\n            You can operate on it normally and add constraints to manticore.constraints\n            via manticore.constrain(constraint_expression)\n\n            Example use::\n\n                symbolic_value = m.make_symbolic_value()\n                m.constrain(symbolic_value > 100)\n                m.constrain(symbolic_value < 1000)\n                m.transaction(caller=attacker_account,\n                                address=contract_account,\n                                data=data,\n                                value=symbolic_value )\n\n        \"\"\"\n        avoid_collisions = False\n        if name is None:\n            name = 'TXVALUE'\n            avoid_collisions = True\n        return self.constraints.new_bitvec(nbits, name=name, avoid_collisions=avoid_collisions)\n\n    def make_symbolic_address(self, name=None, select='both'):\n        if select not in ('both', 'normal', 'contract'):\n            raise EthereumError('Wrong selection type')\n        if select in ('normal', 'contract'):\n            # FIXME need to select contracts or normal accounts\n            raise NotImplemented\n        avoid_collisions = False\n        if name is None:\n            name = 'TXADDR'\n            avoid_collisions = True\n        return self.constraints.new_bitvec(160, name=name, avoid_collisions=avoid_collisions)\n\n        constraint = symbolic_address == 0\n        for contract_account_i in map(int, self._accounts.values()):\n            constraint = Operators.OR(symbolic_address == contract_account_i, constraint)\n        self.constrain(constraint)\n        return symbolic_address\n\n    def constrain(self, constraint):\n        if self.count_states() == 0:\n            self.constraints.add(constraint)\n        else:\n            for state in self.all_states:\n                state.constrain(constraint)\n\n    @staticmethod\n    def compile(source_code, contract_name=None, libraries=None, runtime=False, solc_bin=None, solc_remaps=[]):\n        \"\"\" Get initialization bytecode from a Solidity source code \"\"\"\n        name, source_code, init_bytecode, runtime_bytecode, srcmap, srcmap_runtime, hashes, abi, warnings = ManticoreEVM._compile(source_code, contract_name, libraries, solc_bin, solc_remaps)\n        if runtime:\n            return runtime_bytecode\n        return init_bytecode\n\n    @staticmethod\n    def _link(bytecode, libraries=None):\n        has_dependencies = '_' in bytecode\n        hex_contract = bytecode\n        if has_dependencies:\n            deps = {}\n            pos = 0\n            while pos < len(hex_contract):\n                if hex_contract[pos] == '_':\n                    # __/tmp/tmp_9k7_l:Manticore______________\n                    lib_placeholder = hex_contract[pos:pos + 40]\n                    lib_name = lib_placeholder.split(':')[1].split('_')[0]\n                    deps.setdefault(lib_name, []).append(pos)\n                    pos += 40\n                else:\n                    pos += 2\n\n            if libraries is None:\n                raise DependencyError(deps.keys())\n            libraries = dict(libraries)\n            hex_contract_lst = list(hex_contract)\n            for lib_name, pos_lst in deps.items():\n                try:\n                    lib_address = libraries[lib_name]\n                except KeyError:\n                    raise DependencyError([lib_name])\n                for pos in pos_lst:\n                    hex_contract_lst[pos:pos + 40] = '%040x' % int(lib_address)\n            hex_contract = ''.join(hex_contract_lst)\n        return bytearray(binascii.unhexlify(hex_contract))\n\n    @staticmethod\n    def _run_solc(source_file, solc_bin=None, solc_remaps=[], working_dir=None):\n        \"\"\" Compile a source file with the Solidity compiler\n\n            :param source_file: a file object for the source file\n            :param solc_bin: path to solc binary\n            :param solc_remaps: solc import remaps\n            :return: output, warnings\n        \"\"\"\n        if solc_bin is not None:\n            solc = solc_bin\n        else:\n            solc = \"solc\"\n\n        #check solc version\n        supported_versions = ('0.4.18', '0.4.21')\n\n        try:\n            installed_version_output = check_output([solc, \"--version\"])\n        except OSError:\n            raise EthereumError(\"Solidity compiler not installed.\")\n\n        m = re.match(r\".*Version: (?P<version>(?P<major>\\d+)\\.(?P<minor>\\d+)\\.(?P<build>\\d+)).*\\+(?P<commit>[^\\s]+).*\", installed_version_output.decode(), re.DOTALL | re.IGNORECASE)\n\n        if not m or m.groupdict()['version'] not in supported_versions:\n            #Fixme https://github.com/trailofbits/manticore/issues/847\n            #logger.warning(\"Unsupported solc version %s\", installed_version)\n            pass\n\n        # solc path search is a mess\n        # https://solidity.readthedocs.io/en/latest/layout-of-source-files.html\n\n        relative_filepath = source_file.name\n\n        if not working_dir:\n            working_dir = os.getcwd()\n        elif relative_filepath.startswith(working_dir):\n            relative_filepath = relative_filepath[len(working_dir) + 1:]\n\n        # If someone pass an absolute path to the file, we don't have to put cwd\n        additional_kwargs = {'cwd': working_dir} if working_dir else {}\n\n        solc_invocation = [solc] + list(solc_remaps) + [\n            '--combined-json', 'abi,srcmap,srcmap-runtime,bin,hashes,bin-runtime',\n            '--allow-paths', '.',\n            relative_filepath\n        ]\n\n        p = Popen(solc_invocation, stdout=PIPE, stderr=PIPE, **additional_kwargs)\n        stdout, stderr = p.communicate()\n\n        stdout, stderr = stdout.decode(), stderr.decode()\n\n        # See #1123 - solc fails when run within snap\n        # and https://forum.snapcraft.io/t/interfaces-allow-access-tmp-directory/5129\n        if stdout == '' and f'\"\"{relative_filepath}\"\" is not found' in stderr:\n            raise EthereumError(\n                'Solidity compilation failed with error: {}\\n'\n                'Did you install solc from snap Linux universal packages?\\n'\n                \"If so, the problem is likely due to snap's sandbox restricting access to /tmp\\n\"\n                '\\n'\n                'Here are some potential solutions:\\n'\n                ' 1) Remove solc from snap and install it different way\\n'\n                ' 2) Reinstall solc from snap in developer mode, so there is no sandbox\\n'\n                \" 3) Find a way to add /tmp to the solc's sandbox. If you do, \"\n                \"send us a PR so we could add it here!\".format(stderr)\n            )\n\n        try:\n            return json.loads(stdout), stderr\n        except ValueError:\n            raise EthereumError('Solidity compilation error:\\n\\n{}'.format(stderr))\n\n    @staticmethod\n    def _compile(source_code, contract_name, libraries=None, solc_bin=None, solc_remaps=[], working_dir=None):\n        \"\"\" Compile a Solidity contract, used internally\n\n            :param source_code: solidity source as either a string or a file handle\n            :param contract_name: a string with the name of the contract to analyze\n            :param libraries: an itemizable of pairs (library_name, address)\n            :param solc_bin: path to solc binary\n            :param solc_remaps: solc import remaps\n            :param working_dir: working directory for solc compilation (defaults to current)\n            :return: name, source_code, bytecode, srcmap, srcmap_runtime, hashes\n            :return: name, source_code, bytecode, runtime, srcmap, srcmap_runtime, hashes, abi, warnings\n        \"\"\"\n\n        if isinstance(source_code, str):\n            with tempfile.NamedTemporaryFile('w+') as temp:\n                temp.write(source_code)\n                temp.flush()\n                output, warnings = ManticoreEVM._run_solc(temp, solc_bin, solc_remaps, working_dir=working_dir)\n        elif isinstance(source_code, io.IOBase):\n            output, warnings = ManticoreEVM._run_solc(source_code, solc_bin, solc_remaps, working_dir=working_dir)\n            source_code.seek(0)\n            source_code = source_code.read()\n        else:\n            raise TypeError(f'source code bad type: {type(source_code).__name__}')\n\n        contracts = output.get('contracts', [])\n        if len(contracts) != 1 and contract_name is None:\n            raise EthereumError('Solidity file must contain exactly one contract or you must use a contract parameter to specify one.')\n\n        name, contract = None, None\n        if contract_name is None:\n            name, contract = list(contracts.items())[0]\n        else:\n            for n, c in contracts.items():\n                if n.split(\":\")[1] == contract_name:\n                    name, contract = n, c\n                    break\n\n        if name is None:\n            raise ValueError('Specified contract not found')\n\n        name = name.split(':')[1]\n\n        if contract['bin'] == '':\n            raise EthereumError('Solidity failed to compile your contract.')\n\n        bytecode = ManticoreEVM._link(contract['bin'], libraries)\n        srcmap = contract['srcmap'].split(';')\n        srcmap_runtime = contract['srcmap-runtime'].split(';')\n        hashes = {str(x): str(y) for x, y in contract['hashes'].items()}\n        abi = json.loads(contract['abi'])\n        runtime = ManticoreEVM._link(contract['bin-runtime'], libraries)\n        return name, source_code, bytecode, runtime, srcmap, srcmap_runtime, hashes, abi, warnings\n\n    @property\n    def accounts(self):\n        return dict(self._accounts)\n\n    def account_name(self, address):\n        for name, account in self._accounts.items():\n            if account.address == address:\n                return name\n        return '0x{:x}'.format(address)\n\n    @property\n    def normal_accounts(self):\n        return {name: account for name, account in self._accounts.items() if not isinstance(account, EVMContract)}\n\n    @property\n    def contract_accounts(self):\n        return {name: account for name, account in self._accounts.items() if isinstance(account, EVMContract)}\n\n    def get_account(self, name):\n        return self._accounts[name]\n\n    def __init__(self, procs=10, workspace_url: str=None, policy: str='random'):\n        \"\"\"\n        A Manticore EVM manager\n        :param procs:, number of workers to use in the exploration\n        :param workspace_url: workspace folder name\n        :param policy: scheduling priority\n        \"\"\"\n        self._accounts = dict()\n        self._serializer = PickleSerializer()\n\n        self._config_procs = procs\n        # Make the constraint store\n        constraints = ConstraintSet()\n        # make the ethereum world state\n        world = evm.EVMWorld(constraints, initial_timestamp=1524785992)\n        initial_state = State(constraints, world)\n        super().__init__(initial_state, workspace_url=workspace_url, policy=policy)\n\n        self.constraints = ConstraintSet()\n        self.detectors = {}\n        self.metadata: Dict[int, SolidityMetadata] = {}\n\n        # The following should go to manticore.context so we can use multiprocessing\n        self.context['ethereum'] = {}\n        self.context['ethereum']['_saved_states'] = set()\n        self.context['ethereum']['_final_states'] = set()\n        self.context['ethereum']['_completed_transactions'] = 0\n        self.context['ethereum']['_sha3_states'] = dict()\n        self.context['ethereum']['_known_sha3'] = set()\n\n        self._executor.subscribe('did_load_state', self._load_state_callback)\n        self._executor.subscribe('will_terminate_state', self._terminate_state_callback)\n        self._executor.subscribe('did_evm_execute_instruction', self._did_evm_execute_instruction_callback)\n        self._executor.subscribe('did_read_code', self._did_evm_read_code)\n        self._executor.subscribe('on_symbolic_sha3', self._on_symbolic_sha3_callback)\n        self._executor.subscribe('on_concrete_sha3', self._on_concrete_sha3_callback)\n\n    @property\n    def world(self):\n        \"\"\" The world instance or None if there is more than one state \"\"\"\n        return self.get_world()\n\n    @property\n    def completed_transactions(self):\n        with self.locked_context('ethereum') as context:\n            return context['_completed_transactions']\n\n    @property\n    def _running_state_ids(self):\n        \"\"\" IDs of the running states\"\"\"\n        with self.locked_context('ethereum') as context:\n            if self.initial_state is not None:\n                return (-1,) + tuple(context['_saved_states'])\n            else:\n                return tuple(context['_saved_states'])\n\n    @property\n    def _terminated_state_ids(self):\n        \"\"\" IDs of the terminated states \"\"\"\n        with self.locked_context('ethereum') as context:\n            return tuple(context['_final_states'])\n\n    @property\n    def _all_state_ids(self):\n        \"\"\" IDs of the all states\n\n            Note: state with id -1 is already in memory and it is not backed on the storage\n        \"\"\"\n        return self._running_state_ids + self._terminated_state_ids\n\n    @property\n    def running_states(self):\n        \"\"\" Iterates over the running states\"\"\"\n        for state_id in self._running_state_ids:\n            state = self.load(state_id)\n            yield state\n            self.save(state, state_id=state_id)  # overwrite old\n\n    @property\n    def terminated_states(self):\n        \"\"\" Iterates over the terminated states\"\"\"\n        for state_id in self._terminated_state_ids:\n            state = self.load(state_id)\n            yield state\n            self.save(state, state_id=state_id)  # overwrite old\n\n    @property\n    def all_states(self):\n        \"\"\" Iterates over the all states (terminated and alive)\"\"\"\n        for state_id in self._all_state_ids:\n            state = self.load(state_id)\n            yield state\n            self.save(state, state_id=state_id)  # overwrite old\n\n    def count_states(self):\n        \"\"\" Total states count \"\"\"\n        return len(self._all_state_ids)\n\n    def count_running_states(self):\n        \"\"\" Running states count \"\"\"\n        return len(self._running_state_ids)\n\n    def count_terminated_states(self):\n        \"\"\" Terminated states count \"\"\"\n        return len(self._terminated_state_ids)\n\n    def _terminate_state_id(self, state_id):\n        \"\"\" Manually terminates a states by state_id.\n            Moves the state from the running list into the terminated list\n        \"\"\"\n\n        if state_id != -1:\n            # Move state from running to final\n            with self.locked_context('ethereum') as eth_context:\n                saved_states = eth_context['_saved_states']\n                final_states = eth_context['_final_states']\n                if state_id in saved_states:\n                    saved_states.remove(state_id)\n                    final_states.add(state_id)\n                    eth_context['_saved_states'] = saved_states  # TODO This two may be not needed in py3?\n                    eth_context['_final_states'] = final_states\n        else:\n            assert state_id == -1\n            state_id = self.save(self._initial_state, final=True)\n            self._initial_state = None\n        return state_id\n\n    def _revive_state_id(self, state_id):\n        \"\"\" Manually revive a state by state_id.\n            Moves the state from the final list into the running list\n        \"\"\"\n\n        # Move state from final to running\n        if state_id != -1:\n            with self.locked_context('ethereum') as eth_context:\n                saved_states = eth_context['_saved_states']\n                final_states = eth_context['_final_states']\n                if state_id in final_states:\n                    final_states.remove(state_id)\n                    saved_states.add(state_id)\n                    eth_context['_saved_states'] = saved_states\n                    eth_context['_final_states'] = final_states\n        return state_id\n\n    # deprecate this 5 in favor of for sta in m.all_states: do stuff?\n\n    def get_world(self, state_id=None):\n        \"\"\" Returns the evm world of `state_id` state. \"\"\"\n        state = self.load(state_id)\n        if state is None:\n            return None\n        else:\n            return state.platform\n\n    def get_balance(self, address, state_id=None):\n        \"\"\" Balance for account `address` on state `state_id` \"\"\"\n        if isinstance(address, EVMAccount):\n            address = int(address)\n        return self.get_world(state_id).get_balance(address)\n\n    def get_storage_data(self, address, offset, state_id=None):\n        \"\"\" Storage data for `offset` on account `address` on state `state_id` \"\"\"\n        if isinstance(address, EVMAccount):\n            address = int(address)\n        return self.get_world(state_id).get_storage_data(address, offset)\n\n    def get_code(self, address, state_id=None):\n        \"\"\" Storage data for `offset` on account `address` on state `state_id` \"\"\"\n        if isinstance(address, EVMAccount):\n            address = int(address)\n        return self.get_world(state_id).get_code(address)\n\n    def last_return(self, state_id=None):\n        \"\"\" Last returned buffer for state `state_id` \"\"\"\n        state = self.load(state_id)\n        return state.platform.last_return_data\n\n    def transactions(self, state_id=None):\n        \"\"\" Transactions list for state `state_id` \"\"\"\n        state = self.load(state_id)\n        return state.platform.transactions\n\n    def human_transactions(self, state_id=None):\n        \"\"\" Transactions list for state `state_id` \"\"\"\n        state = self.load(state_id)\n        return state.platform.human_transactions\n\n    def make_symbolic_arguments(self, types):\n        \"\"\"\n            Make a reasonable serialization of the symbolic argument types\n        \"\"\"\n        # FIXME this is more naive than reasonable.\n        return ABI.deserialize(types, self.make_symbolic_buffer(32, name=\"INITARGS\"))\n\n    def solidity_create_contract(self, source_code, owner, name=None, contract_name=None, libraries=None,\n                                 balance=0, address=None, args=(), solc_bin=None, solc_remaps=[],\n                                 working_dir=None, gas=90000):\n        \"\"\" Creates a solidity contract and library dependencies\n\n            :param str source_code: solidity source code\n            :param owner: owner account (will be default caller in any transactions)\n            :type owner: int or EVMAccount\n            :param contract_name: Name of the contract to analyze (optional if there is a single one in the source code)\n            :type contract_name: str\n            :param balance: balance to be transferred on creation\n            :type balance: int or SValue\n            :param address: the address for the new contract (optional)\n            :type address: int or EVMAccount\n            :param tuple args: constructor arguments\n            :param solc_bin: path to solc binary\n            :type solc_bin: str\n            :param solc_remaps: solc import remaps\n            :type solc_remaps: list of str\n            :param working_dir: working directory for solc compilation (defaults to current)\n            :type working_dir: str\n            :param gas: gas budget for each contract creation needed (may be more than one if several related contracts defined in the solidity source)\n            :type gas: int\n            :rtype: EVMAccount\n        \"\"\"\n        if libraries is None:\n            deps = {}\n        else:\n            deps = dict(libraries)\n\n        contract_names = [contract_name]\n        while contract_names:\n            contract_name_i = contract_names.pop()\n            try:\n                compile_results = self._compile(source_code, contract_name_i,\n                                                libraries=deps, solc_bin=solc_bin, solc_remaps=solc_remaps,\n                                                working_dir=working_dir)\n                md = SolidityMetadata(*compile_results)\n                if contract_name_i == contract_name:\n                    constructor_types = md.get_constructor_arguments()\n                    if args is None:\n                        args = self.make_symbolic_arguments(constructor_types)\n                    contract_account = self.create_contract(owner=owner,\n                                                            balance=balance,\n                                                            address=address,\n                                                            init=md._init_bytecode + ABI.serialize(constructor_types, *args),\n                                                            name=name,\n                                                            gas=gas)\n                else:\n                    contract_account = self.create_contract(owner=owner, init=md._init_bytecode)\n\n                if contract_account is None:\n                    raise EthereumError(\"Failed to build contract %s\" % contract_name_i)\n                self.metadata[int(contract_account)] = md\n\n                deps[contract_name_i] = contract_account\n            except DependencyError as e:\n                contract_names.append(contract_name_i)\n                for lib_name in e.lib_names:\n                    if lib_name not in deps:\n                        contract_names.append(lib_name)\n\n        if not self.count_running_states() or len(self.get_code(contract_account)) == 0:\n            return None\n        return contract_account\n\n    def get_nonce(self, address):\n        # type forgiveness:\n        address = int(address)\n        # get all nonces for states containing this address:\n        nonces = set(state.platform.get_nonce(address) for state in self.running_states if address in state.platform)\n        if not nonces:\n            raise NoAliveStates(\"There are no alive states containing address %x\" % address)\n        elif len(nonces) != 1:\n            # if there are multiple states with this address, they all have to have the same nonce:\n            raise EthereumError(\"Cannot increase the nonce of address %x because it exists in multiple states with different nonces\" % address)\n        else:\n            return next(iter(nonces))\n\n    def create_contract(self, owner, balance=0, address=None, init=None, name=None, gas=21000):\n        \"\"\" Creates a contract\n\n            :param owner: owner account (will be default caller in any transactions)\n            :type owner: int or EVMAccount\n            :param balance: balance to be transferred on creation\n            :type balance: int or SValue\n            :param int address: the address for the new contract (optional)\n            :param str init: initializing evm bytecode and arguments\n            :param str name: a unique name for reference\n            :param gas: gas budget for the creation/initialization of the contract\n            :rtype: EVMAccount\n        \"\"\"\n        if not self.count_running_states():\n            raise NoAliveStates\n\n        nonce = self.get_nonce(owner)\n        expected_address = evm.EVMWorld.calculate_new_address(int(owner), nonce=nonce)\n\n        if address is None:\n            address = expected_address\n        elif address != expected_address:\n            raise EthereumError(\"Address was expected to be %x but was given %x\" % (expected_address, address))\n\n        # Name check\n        if name is None:\n            name = self._get_uniq_name(\"contract\")\n        if name in self._accounts:\n            # Account name already used\n            raise EthereumError(\"Name already used\")\n\n        self._transaction('CREATE', owner, balance, address, data=init, gaslimit=gas)\n        # TODO detect failure in the constructor\n\n        self._accounts[name] = EVMContract(address=address, manticore=self, default_caller=owner, name=name)\n        return self.accounts[name]\n\n    def _get_uniq_name(self, stem):\n        count = 0\n        for name_i in self.accounts.keys():\n            if name_i.startswith(stem):\n                try:\n                    count = max(count, int(name_i[len(stem):]) + 1)\n                except:\n                    pass\n        name = \"{:s}{:d}\".format(stem, count)\n        assert name not in self.accounts\n        return name\n\n    def _all_addresses(self):\n        \"\"\" Returns all addresses in all running states \"\"\"\n        ret = set()\n        for state in self.running_states:\n            ret |= set(state.platform.accounts)\n        return ret\n\n    def new_address(self):\n        \"\"\" Create a fresh 160bit address \"\"\"\n        all_addresses = self._all_addresses()\n        while True:\n            new_address = random.randint(100, pow(2, 160))\n            if new_address not in all_addresses:\n                return new_address\n\n    def transaction(self, caller, address, value, data, gas=21000):\n        \"\"\" Issue a symbolic transaction in all running states\n\n            :param caller: the address of the account sending the transaction\n            :type caller: int or EVMAccount\n            :param address: the address of the contract to call\n            :type address: int or EVMAccount\n            :param value: balance to be transfered on creation\n            :type value: int or SValue\n            :param data: initial data\n            :param gas: gas budget\n            :raises NoAliveStates: if there are no alive states to execute\n        \"\"\"\n        self._transaction('CALL', caller, value=value, address=address, data=data, gaslimit=gas)\n\n    def create_account(self, balance=0, address=None, code=None, name=None):\n        \"\"\" Low level creates an account. This won't generate a transaction.\n\n            :param balance: balance to be set on creation (optional)\n            :type balance: int or SValue\n            :param address: the address for the new account (optional)\n            :type address: int\n            :param code: the runtime code for the new account (None means normal account) (optional)\n            :param name: a global account name eg. for use as reference in the reports (optional)\n            :return: an EVMAccount\n        \"\"\"\n        # Need at least one state where to apply this\n        if not self.count_running_states():\n            raise NoAliveStates\n\n        # Name check\n        if name is None:\n            if code is None:\n                name = self._get_uniq_name(\"normal\")\n            else:\n                name = self._get_uniq_name(\"contract\")\n        if name in self._accounts:\n            # Account name already used\n            raise EthereumError(\"Name already used\")\n\n        #Balance check\n        if not isinstance(balance, int):\n            raise EthereumError(\"Balance invalid type\")\n\n        if isinstance(code, str):\n            code = bytearray(code)\n        if code is not None and not isinstance(code, (bytearray, Array)):\n            raise EthereumError(\"code bad type\")\n\n        # Address check\n        # Let's just choose the address ourself. This is not yellow paper material\n        if address is None:\n            address = self.new_address()\n        if not isinstance(address, int):\n            raise EthereumError(\"A concrete address is needed\")\n        assert address is not None\n        if address in map(int, self.accounts.values()):\n            # Address already used\n            raise EthereumError(\"Address already used\")\n\n        # To avoid going full crazy we maintain a global list of addresses\n        # Different states may CREATE a different set of accounts.\n        # Accounts created by a human have the same address in all states.\n        for state in self.running_states:\n            world = state.platform\n\n            if '_pending_transaction' in state.context:\n                raise EthereumError(\"This is bad. There should not be a pending transaction\")\n\n            if address in world.accounts:\n                # Address already used\n                raise EthereumError(\"This is bad. Same address is used for different contracts in different states\")\n            world.create_account(address, balance, code=code, storage=None)\n\n        self._accounts[name] = EVMAccount(address, manticore=self, name=name)\n        return self.accounts[name]\n\n    def _migrate_tx_expressions(self, state, caller, address, value, data):\n            # Copy global constraints into each state.\n            # We should somehow remember what has been copied to each state\n            # In a second transaction we should only add new constraints.\n            # And actually only constraints related to whatever we are using in\n            # the tx. This is a FIXME\n            global_constraints = self.constraints\n\n            # Normally users will be making these symbolic expressions by creating\n            # global symbolic variables via ManticoreEVM.make_.... and those\n            # global expressions need to be imported into each state when a tx\n            # actually happens\n\n            if issymbolic(caller):\n                caller = state.migrate_expression(caller)\n\n            if issymbolic(address):\n                address = state.migrate_expression(address)\n\n            if issymbolic(value):\n                value = state.migrate_expression(value)\n\n            if issymbolic(data):\n                if isinstance(data, ArrayProxy):  # FIXME is this necessary here?\n                    data = data.array\n                data = state.migrate_expression(data)\n                if isinstance(data, Array):\n                    data = ArrayProxy(data)\n\n            for c in global_constraints:\n                state.constrain(c)\n\n            return caller, address, value, data\n\n    def _transaction(self, sort, caller, value=0, address=None, data=None, gaslimit=0, price=1):\n        \"\"\" Initiates a transaction\n\n            :param caller: caller account\n            :type caller: int or EVMAccount\n            :param int address: the address for the transaction (optional)\n            :param value: value to be transferred\n            :param price: the price of gas for this transaction. Mostly unused.\n            :type value: int or SValue\n            :param str data: initializing evm bytecode and arguments or transaction call data\n            :param gaslimit: gas budget\n            :rtype: EVMAccount\n        \"\"\"\n        #Type Forgiveness\n        if isinstance(address, EVMAccount):\n            address = int(address)\n        if isinstance(caller, EVMAccount):\n            caller = int(caller)\n        #Defaults, call data is empty\n        if data is None:\n            data = bytearray(b\"\")\n        if isinstance(data, (str, bytes)):\n            data = bytearray(data)\n        if not isinstance(data, (bytearray, Array)):\n            raise TypeError(\"code bad type\")\n\n        # Check types\n        if not isinstance(caller, (int, BitVec)):\n            raise TypeError(\"Caller invalid type\")\n\n        if not isinstance(value, (int, BitVec)):\n            raise TypeError(\"Value invalid type\")\n\n        if not isinstance(address, (int, BitVec)):\n            raise TypeError(\"address invalid type\")\n\n        if not isinstance(price, int):\n            raise TypeError(\"Price invalid type\")\n\n        # Check argument consistency and set defaults ...\n        if sort not in ('CREATE', 'CALL'):\n            raise ValueError('unsupported transaction type')\n\n        if sort == 'CREATE':\n            # When creating data is the init_bytecode + arguments\n            if len(data) == 0:\n                raise EthereumError(\"An initialization bytecode is needed for a CREATE\")\n\n        assert address is not None\n        assert caller is not None\n\n        # Transactions (like everything else) need at least one running state\n        if not self.count_running_states():\n            raise NoAliveStates\n\n        # To avoid going full crazy, we maintain a global list of addresses\n        for state in self.running_states:\n            world = state.platform\n\n            if '_pending_transaction' in state.context:\n                raise EthereumError(\"This is bad. It should not be a pending transaction\")\n\n            # Choose an address here, because it will be dependent on the caller's nonce in this state\n            if address is None:\n                if issymbolic(caller):\n                    # TODO (ESultanik): In order to handle this case, we are going to have to do something like fork\n                    # over all possible caller addresses.\n                    # But this edge case will likely be extremely rare, if ever ecountered.\n                    raise EthereumError(\"Manticore does not currently support contracts with symbolic addresses creating new contracts\")\n                address = world.new_address(caller)\n\n            # Migrate any expression to state specific constraint set\n            caller_migrated, address_migrated, value_migrated, data_migrated = self._migrate_tx_expressions(state, caller, address, value, data)\n\n            # Different states may CREATE a different set of accounts. Accounts\n            # that were crated by a human have the same address in all states.\n            # This diverges from the yellow paper but at least we check that we\n            # are not trying to create an already used address here\n            if sort == 'CREATE':\n                if address in world.accounts:\n                    # Address already used\n                    raise EthereumError(\"This is bad. Same address is used for different contracts in different states\")\n\n            state.context['_pending_transaction'] = (sort, caller_migrated, address_migrated, value_migrated, data_migrated, gaslimit, price)\n\n        # run over potentially several states and\n        # generating potentially several others\n        self.run(procs=self._config_procs)\n\n        return address\n\n    def multi_tx_analysis(self, solidity_filename, working_dir=None, contract_name=None,\n                          tx_limit=None, tx_use_coverage=True,\n                          tx_send_ether=True, tx_account=\"attacker\", args=None):\n        owner_account = self.create_account(balance=1000, name='owner')\n        attacker_account = self.create_account(balance=1000, name='attacker')\n\n        # Pretty print\n        logger.info(\"Starting symbolic create contract\")\n\n        with open(solidity_filename) as f:\n            contract_account = self.solidity_create_contract(f, contract_name=contract_name, owner=owner_account,\n                                                             args=args, working_dir=working_dir)\n\n        if tx_account == \"attacker\":\n            tx_account = [attacker_account]\n        elif tx_account == \"owner\":\n            tx_account = [owner_account]\n        elif tx_account == \"combo1\":\n            tx_account = [owner_account, attacker_account]\n        else:\n            raise EthereumError('The account to perform the symbolic exploration of the contract should be \"attacker\", \"owner\" or \"combo1\"')\n\n        if contract_account is None:\n            logger.info(\"Failed to create contract: exception in constructor\")\n            return\n\n        prev_coverage = 0\n        current_coverage = 0\n        tx_no = 0\n        while (current_coverage < 100 or not tx_use_coverage) and not self.is_shutdown():\n            try:\n                logger.info(\"Starting symbolic transaction: %d\", tx_no)\n\n                # run_symbolic_tx\n                symbolic_data = self.make_symbolic_buffer(320)\n                if tx_send_ether:\n                    value = self.make_symbolic_value()\n                else:\n                    value = 0\n                self.transaction(caller=tx_account[min(tx_no, len(tx_account) - 1)],\n                                 address=contract_account,\n                                 data=symbolic_data,\n                                 value=value,\n                                 gas=2100000)\n                logger.info(\"%d alive states, %d terminated states\", self.count_running_states(), self.count_terminated_states())\n            except NoAliveStates:\n                break\n\n            # Check if the maximum number of tx was reached\n            if tx_limit is not None and tx_no + 1 == tx_limit:\n                break\n\n            # Check if coverage has improved or not\n            if tx_use_coverage:\n                prev_coverage = current_coverage\n                current_coverage = self.global_coverage(contract_account)\n                found_new_coverage = prev_coverage < current_coverage\n\n                if not found_new_coverage:\n                    break\n\n            tx_no += 1\n\n    def run(self, **kwargs):\n        \"\"\" Run any pending transaction on any running state \"\"\"\n        # Check if there is a pending transaction\n        with self.locked_context('ethereum') as context:\n            # there are no states added to the executor queue\n            assert len(self._executor.list()) == 0\n            for state_id in context['_saved_states']:\n                self._executor.put(state_id)\n            context['_saved_states'] = set()\n\n        # A callback will use _pending_transaction and issue the transaction\n        # in each state (see load_state_callback)\n        super().run(**kwargs)\n\n        with self.locked_context('ethereum') as context:\n            if len(context['_saved_states']) == 1:\n                self._initial_state = self._executor._workspace.load_state(context['_saved_states'].pop(), delete=True)\n                self._executor.forward_events_from(self._initial_state, True)\n                context['_saved_states'] = set()\n                assert self._running_state_ids == (-1,)\n\n    def save(self, state, state_id=None, final=False):\n        \"\"\" Save a state in secondary storage and add it to running or final lists\n\n            :param state: A manticore State\n            :param state_id: if not None force state_id (overwrite)\n            :param final: True if state is final\n            :returns: a state id\n        \"\"\"\n        # If overwriting then the state_id must be known\n        if state_id is not None:\n            if state_id not in self._all_state_ids:\n                raise EthereumError(\"Trying to overwrite unknown state_id\")\n            with self.locked_context('ethereum') as context:\n                context['_final_states'].discard(state_id)\n                context['_saved_states'].discard(state_id)\n\n        if state_id != -1:\n            # save the state to secondary storage\n            state_id = self._executor._workspace.save_state(state, state_id=state_id)\n\n            with self.locked_context('ethereum') as context:\n                if final:\n                    # Keep it on a private list\n                    context['_final_states'].add(state_id)\n                else:\n                    # Keep it on a private list\n                    context['_saved_states'].add(state_id)\n        return state_id\n\n    def load(self, state_id=None):\n        \"\"\" Load one of the running or final states.\n\n            :param state_id: If None it assumes there is a single running state\n            :type state_id: int or None\n        \"\"\"\n        state = None\n        if state_id is None:\n            #a single state was assumed\n            state_count = self.count_running_states()\n            if state_count == 1:\n                #Get the ID of the single running state\n                state_id = self._running_state_ids[0]\n            elif state_count == 0:\n                raise NoAliveStates\n            else:\n                raise EthereumError(\"More than one state running; you must specify a state id.\")\n\n        if state_id == -1:\n            state = self.initial_state\n        else:\n            state = self._executor._workspace.load_state(state_id, delete=False)\n            #froward events from newly loaded object\n            self._executor.forward_events_from(state, True)\n        return state\n\n    # Callbacks\n    def _on_symbolic_sha3_callback(self, state, data, known_hashes):\n        \"\"\" INTERNAL USE \"\"\"\n        assert issymbolic(data), 'Data should be symbolic here!'\n\n        with self.locked_context('ethereum') as context:\n            known_sha3 = context.get('_known_sha3', None)\n            if known_sha3 is None:\n                known_sha3 = set()\n\n            sha3_states = context.get('_sha3_states', [])\n            results = []\n            # If know_hashes is true then there is a _known_ solution for the hash\n            known_hashes_cond = False\n            for key, value in known_sha3:\n                assert not issymbolic(key), \"Saved sha3 data,hash pairs should be concrete\"\n                cond = key == data\n\n                #TODO consider disabling this solver query.\n                if not state.can_be_true(cond):\n                    continue\n\n                results.append((key, value))\n                known_hashes_cond = Operators.OR(cond, known_hashes_cond)\n\n            # adding a single random example so we can explore further in case\n            # there are not known sha3 pairs that match yet\n            if not results:\n                data_concrete = state.solve_one(data)\n                s = sha3.keccak_256(data_concrete)\n                data_hash = int(s.hexdigest(), 16)\n                results.append((data_concrete, data_hash))\n                known_hashes_cond = data_concrete == data\n                known_sha3.add((data_concrete, data_hash))\n            not_known_hashes_cond = Operators.NOT(known_hashes_cond)\n\n            # We need to fork/save the state\n            #################################\n            # save the state to secondary storage\n            # Build and enqueue a state for each solution\n            with state as temp_state:\n                if temp_state.can_be_true(not_known_hashes_cond):\n                    temp_state.constrain(not_known_hashes_cond)\n                    state_id = self._executor._workspace.save_state(temp_state)\n                    sha3_states[state_id] = [hsh for buf, hsh in known_sha3]\n            context['_sha3_states'] = sha3_states\n\n            if not state.can_be_true(known_hashes_cond):\n                raise TerminateState(\"There is no matching sha3 pair, bailing out\")\n            state.constrain(known_hashes_cond)\n\n            #send known hashes to evm\n            known_hashes.update(results)\n\n    def _on_concrete_sha3_callback(self, state, buf, value):\n        \"\"\" INTERNAL USE \"\"\"\n        with self.locked_context('ethereum', dict) as ethereum_context:\n            known_sha3 = ethereum_context.get('_known_sha3', None)\n            if known_sha3 is None:\n                known_sha3 = set()\n            known_sha3.add((buf, value))\n            ethereum_context['_known_sha3'] = known_sha3\n\n    def _terminate_state_callback(self, state, state_id, e):\n        \"\"\" INTERNAL USE\n            Every time a state finishes executing the last transaction, we save it in\n            our private list\n        \"\"\"\n        if isinstance(e, AbandonState):\n            #do nothing\n            return\n        world = state.platform\n        state.context['last_exception'] = e\n        e.testcase = False  # Do not generate a testcase file\n\n        if not world.all_transactions:\n            logger.debug(\"Something went wrong: search terminated in the middle of an ongoing tx\")\n            self.save(state, final=True)\n            return\n\n        tx = world.all_transactions[-1]\n\n        #we initiated the Tx; we need process the outcome for now.\n        #Fixme incomplete.\n        if tx.is_human():\n            if tx.sort == 'CREATE':\n                if tx.result == 'RETURN':\n                    world.set_code(tx.address, tx.return_data)\n                else:\n                    world.delete_account(tx.address)\n        else:\n            logger.info(\"Manticore exception: state should be terminated only at the end of the human transaction\")\n\n        #Human tx that ends in this wont modify the storage so finalize and\n        # generate a testcase. FIXME This should be configurable as REVERT and\n        # THROW; it actually changes the balance and nonce? of some accounts\n        if tx.result in {'SELFDESTRUCT', 'REVERT', 'THROW', 'TXERROR'}:\n            self.save(state, final=True)\n        elif tx.result in {'RETURN', 'STOP'}:\n            # if not a revert, we save the state for further transactions\n            self.save(state)  # Add to running states\n        else:\n            logger.debug(\"Exception in state. Discarding it\")\n\n    #Callbacks\n    def _load_state_callback(self, state, state_id):\n        \"\"\" INTERNAL USE\n            If a state was just loaded from storage, we do the pending transaction\n        \"\"\"\n        if '_pending_transaction' not in state.context:\n            return\n        world = state.platform\n        ty, caller, address, value, data, gaslimit, price = state.context['_pending_transaction']\n        del state.context['_pending_transaction']\n\n        if ty == 'CALL':\n            world.transaction(address=address, caller=caller, data=data, value=value, price=price, gas=gaslimit)\n        else:\n            assert ty == 'CREATE'\n            world.create_contract(caller=caller, address=address, balance=value, init=data, price=price, gas=gaslimit)\n\n    def _did_evm_execute_instruction_callback(self, state, instruction, arguments, result):\n        \"\"\" INTERNAL USE \"\"\"\n        #logger.debug(\"%s\", state.platform.current_vm)\n        #TODO move to a plugin\n        at_init = state.platform.current_transaction.sort == 'CREATE'\n        if at_init:\n            coverage_context_name = 'init_coverage'\n        else:\n            coverage_context_name = 'runtime_coverage'\n\n        with self.locked_context(coverage_context_name, set) as coverage:\n            coverage.add((state.platform.current_vm.address, instruction.pc))\n\n        state.context.setdefault('evm.trace', []).append((state.platform.current_vm.address, instruction.pc, at_init))\n\n    def _did_evm_read_code(self, state, offset, size):\n        \"\"\" INTERNAL USE \"\"\"\n        with self.locked_context('code_data', set) as code_data:\n            for i in range(offset, offset + size):\n                code_data.add((state.platform.current_vm.address, i))\n\n    def get_metadata(self, address) -> Optional[SolidityMetadata]:\n        \"\"\" Gets the solidity metadata for address.\n            This is available only if address is a contract created from solidity\n        \"\"\"\n        return self.metadata.get(int(address))\n\n    def register_detector(self, d):\n        if not isinstance(d, Detector):\n            raise EthereumError(\"Not a Detector\")\n        if d.name in self.detectors:\n            raise EthereumError(\"Detector already registered\")\n        self.detectors[d.name] = d\n        self.register_plugin(d)\n        return d.name\n\n    def unregister_detector(self, d):\n        if not isinstance(d, (Detector, str)):\n            raise EthereumError(\"Not a Detector\")\n        name = d\n        if isinstance(d, Detector):\n            name = d.name\n        if name not in self.detectors:\n            raise EthereumError(\"Detector not registered\")\n        d = self.detectors[name]\n        del self.detectors[name]\n        self.unregister_plugin(d)\n\n    @property\n    def workspace(self):\n        return self._executor._workspace._store.uri\n\n    def generate_testcase(self, state, message='', only_if=None, name='user'):\n        \"\"\"\n        Generate a testcase to the workspace for the given program state. The details of what\n        a testcase is depends on the type of Platform the state is, but involves serializing the state,\n        and generating an input (concretizing symbolic variables) to trigger this state.\n\n        The only_if parameter should be a symbolic expression. If this argument is provided, and the expression\n        *can be true* in this state, a testcase is generated such that the expression will be true in the state.\n        If it *is impossible* for the expression to be true in the state, a testcase is not generated.\n\n        This is useful for conveniently checking a particular invariant in a state, and generating a testcase if\n        the invariant can be violated.\n\n        For example, invariant: \"balance\" must not be 0. We can check if this can be violated and generate a\n        testcase::\n\n            m.generate_testcase(state, 'balance CAN be 0', only_if=balance == 0)\n            # testcase generated with an input that will violate invariant (make balance == 0)\n\n        :param manticore.core.state.State state:\n        :param str message: longer description of the testcase condition\n        :param manticore.core.smtlib.Bool only_if: only if this expr can be true, generate testcase. if is None, generate testcase unconditionally.\n        :param str name: short string used as the prefix for the workspace key (e.g. filename prefix for testcase files)\n        :return: If a testcase was generated\n        :rtype: bool\n        \"\"\"\n        if only_if is None:\n            self._generate_testcase_callback(state, name, message)\n            return True\n        else:\n            with state as temp_state:\n                temp_state.constrain(only_if)\n                if temp_state.is_feasible():\n                    self._generate_testcase_callback(temp_state, name, message)\n                    return True\n\n        return False\n\n    def current_location(self, state):\n        world = state.platform\n        address = world.current_vm.address\n        pc = world.current_vm.pc\n        at_init = world.current_transaction.sort == 'CREATE'\n        output = io.StringIO()\n        write_findings(output, '', address, pc, at_init)\n        md = self.get_metadata(address)\n        if md is not None:\n            src = md.get_source_for(pc, runtime=not at_init)\n            output.write('Snippet:\\n')\n            output.write(src.replace('\\n', '\\n  ').strip())\n            output.write('\\n')\n        return output.getvalue()\n\n    def _generate_testcase_callback(self, state, name, message=''):\n        \"\"\"\n        Create a serialized description of a given state.\n        :param state: The state to generate information about\n        :param message: Accompanying message\n        \"\"\"\n        # workspace should not be responsible for formating the output\n        # each object knows its secrets, and each class should be able to report its\n        # final state\n        #super()._generate_testcase_callback(state, name, message)\n        # TODO(mark): Refactor ManticoreOutput to let the platform be more in control\n        #  so this function can be fully ported to EVMWorld.generate_workspace_files.\n        blockchain = state.platform\n\n        testcase = self._output.testcase(name.replace(' ', '_'))\n        last_tx = blockchain.last_transaction\n        if last_tx:\n            message = message + last_tx.result\n        logger.info(\"Generated testcase No. {} - {}\".format(testcase.num, message))\n\n        local_findings = set()\n        for detector in self.detectors.values():\n            for address, pc, finding, at_init, constraint in detector.get_findings(state):\n                if (address, pc, finding, at_init) not in local_findings:\n                    local_findings.add((address, pc, finding, at_init, constraint))\n\n        if len(local_findings):\n            with testcase.open_stream('findings') as findings:\n                for address, pc, finding, at_init, constraint in local_findings:\n                    findings.write('- %s -\\n' % finding)\n                    write_findings(findings, '  ', address, pc, at_init)\n                    md = self.get_metadata(address)\n                    if md is not None:\n                        src = md.get_source_for(pc, runtime=not at_init)\n                        findings.write('  Snippet:\\n')\n                        findings.write(src.replace('\\n', '\\n    ').strip())\n                        findings.write('\\n')\n\n        with testcase.open_stream('summary') as stream:\n            is_something_symbolic = state.platform.dump(stream, state, self, message)\n\n            with self.locked_context('ethereum') as context:\n                known_sha3 = context.get('_known_sha3', None)\n                if known_sha3:\n                    stream.write(\"Known hashes:\\n\")\n                    for key, value in known_sha3:\n                        stream.write('%s::%x\\n' % (binascii.hexlify(key), value))\n\n            if is_something_symbolic:\n                stream.write('\\n\\n(*) Example solution given. Value is symbolic and may take other values\\n')\n\n        # Transactions\n\n        with testcase.open_stream('tx') as tx_summary:\n            with testcase.open_stream('tx.json') as txjson:\n                txlist = []\n                is_something_symbolic = False\n\n                for sym_tx in blockchain.human_transactions:  # external transactions\n                    tx_summary.write(\"Transactions No. %d\\n\" % blockchain.transactions.index(sym_tx))\n\n                    conc_tx = sym_tx.concretize(state)\n                    txlist.append(conc_tx.to_dict(self))\n\n                    is_something_symbolic = sym_tx.dump(tx_summary, state, self, conc_tx=conc_tx)\n\n                if is_something_symbolic:\n                    tx_summary.write('\\n\\n(*) Example solution given. Value is symbolic and may take other values\\n')\n\n                json.dump(txlist, txjson)\n\n        # logs\n        with testcase.open_stream('logs') as logs_summary:\n            is_something_symbolic = False\n            for log_item in blockchain.logs:\n                is_log_symbolic = issymbolic(log_item.memlog)\n                is_something_symbolic = is_log_symbolic or is_something_symbolic\n                solved_memlog = state.solve_one(log_item.memlog)\n                printable_bytes = ''.join([c for c in map(chr, solved_memlog) if c in string.printable])\n\n                logs_summary.write(\"Address: %x\\n\" % log_item.address)\n                logs_summary.write(\"Memlog: %s (%s) %s\\n\" % (binascii.hexlify(solved_memlog).decode(), printable_bytes, flagged(is_log_symbolic)))\n                logs_summary.write(\"Topics:\\n\")\n                for i, topic in enumerate(log_item.topics):\n                    logs_summary.write(\"\\t%d) %x %s\" % (i, state.solve_one(topic), flagged(issymbolic(topic))))\n\n        with testcase.open_stream('constraints') as smt_summary:\n            smt_summary.write(str(state.constraints))\n\n        with testcase.open_stream('pkl', binary=True) as statef:\n            self._serializer.serialize(state, statef)\n\n        trace = state.context.get('evm.trace')\n        if trace:\n            with testcase.open_stream('trace') as f:\n                self._emit_trace_file(f, trace)\n        return testcase\n\n    @staticmethod\n    def _emit_trace_file(filestream, trace):\n        \"\"\"\n        :param filestream: file object for the workspace trace file\n        :param trace: list of (contract address, pc) tuples\n        :type trace: list[tuple(int, int)]\n        \"\"\"\n        for contract, pc, at_init in trace:\n            if pc == 0:\n                filestream.write('---\\n')\n            ln = '0x{:x}:0x{:x} {}\\n'.format(contract, pc, '*' if at_init else '')\n            filestream.write(ln)\n\n    @property\n    def global_findings(self):\n        global_findings = set()\n        for detector in self.detectors.values():\n            for address, pc, finding, at_init in detector.global_findings:\n                if (address, pc, finding, at_init) not in global_findings:\n                    global_findings.add((address, pc, finding, at_init))\n        return global_findings\n\n    def finalize(self):\n        \"\"\"\n        Terminate and generate testcases for all currently alive states (contract states that cleanly executed\n        to a STOP or RETURN in the last symbolic transaction).\n        \"\"\"\n        logger.debug(\"Finalizing %d states.\", self.count_states())\n\n        def finalizer(state_id):\n            state_id = self._terminate_state_id(state_id)\n            st = self.load(state_id)\n            logger.debug(\"Generating testcase for state_id %d\", state_id)\n            self._generate_testcase_callback(st, 'test', '')\n\n        def worker_finalize(q):\n            try:\n                while True:\n                    finalizer(q.get_nowait())\n            except EmptyQueue:\n                pass\n\n        q = Queue()\n        for state_id in self._all_state_ids:\n            #we need to remove -1 state before forking because it may be in memory\n            if state_id == -1:\n                finalizer(-1)\n            else:\n                q.put(state_id)\n\n        report_workers = []\n        for _ in range(self._config_procs):\n            proc = Process(target=worker_finalize, args=(q,))\n            proc.start()\n            report_workers.append(proc)\n\n        for proc in report_workers:\n            proc.join()\n\n        #global summary\n        if len(self.global_findings):\n            with self._output.save_stream('global.findings') as global_findings:\n                for address, pc, finding, at_init in self.global_findings:\n                    global_findings.write('- %s -\\n' % finding)\n                    write_findings(global_findings, '  ', address, pc, at_init)\n                    md = self.get_metadata(address)\n                    if md is not None:\n                        source_code_snippet = md.get_source_for(pc, runtime=not at_init)\n                        global_findings.write('  Solidity snippet:\\n')\n                        global_findings.write('    '.join(source_code_snippet.splitlines(True)))\n                        global_findings.write('\\n')\n\n        with self._output.save_stream('manticore.yml') as f:\n            config.save(f)\n\n        with self._output.save_stream('global.summary') as global_summary:\n            # (accounts created by contract code are not in this list )\n            global_summary.write(\"Global runtime coverage:\\n\")\n            for address in self.contract_accounts.values():\n                global_summary.write(\"{:x}: {:2.2f}%\\n\".format(int(address), self.global_coverage(address)))\n\n                md = self.get_metadata(address)\n                if md is not None and len(md.warnings) > 0:\n                    global_summary.write('\\n\\nCompiler warnings for %s:\\n' % md.name)\n                    global_summary.write(md.warnings)\n\n        for address, md in self.metadata.items():\n            with self._output.save_stream('global_%s.sol' % md.name) as global_src:\n                global_src.write(md.source_code)\n            with self._output.save_stream('global_%s_runtime.bytecode' % md.name, binary=True) as global_runtime_bytecode:\n                global_runtime_bytecode.write(md.runtime_bytecode)\n            with self._output.save_stream('global_%s_init.bytecode' % md.name, binary=True) as global_init_bytecode:\n                global_init_bytecode.write(md.init_bytecode)\n\n            with self._output.save_stream('global_%s.runtime_asm' % md.name) as global_runtime_asm:\n                runtime_bytecode = md.runtime_bytecode\n\n                with self.locked_context('runtime_coverage') as seen:\n\n                    count, total = 0, 0\n                    for i in EVMAsm.disassemble_all(runtime_bytecode):\n                        if (address, i.pc) in seen:\n                            count += 1\n                            global_runtime_asm.write('*')\n                        else:\n                            global_runtime_asm.write(' ')\n\n                        global_runtime_asm.write('%4x: %s\\n' % (i.pc, i))\n                        total += 1\n\n            with self._output.save_stream('global_%s.init_asm' % md.name) as global_init_asm:\n                with self.locked_context('init_coverage') as seen:\n                    count, total = 0, 0\n                    for i in EVMAsm.disassemble_all(md.init_bytecode):\n                        if (address, i.pc) in seen:\n                            count += 1\n                            global_init_asm.write('*')\n                        else:\n                            global_init_asm.write(' ')\n\n                        global_init_asm.write('%4x: %s\\n' % (i.pc, i))\n                        total += 1\n\n            with self._output.save_stream('global_%s.init_visited' % md.name) as f:\n                with self.locked_context('init_coverage') as seen:\n                    visited = set((o for (a, o) in seen if a == address))\n                    for o in sorted(visited):\n                        f.write('0x%x\\n' % o)\n\n            with self._output.save_stream('global_%s.runtime_visited' % md.name) as f:\n                with self.locked_context('runtime_coverage') as seen:\n                    visited = set()\n                    for (a, o) in seen:\n                        if a == address:\n                            visited.add(o)\n                    for o in sorted(visited):\n                        f.write('0x%x\\n' % o)\n\n        # delete actual streams from storage\n        for state_id in self._all_state_ids:\n            # state_id -1 is always only on memory\n            if state_id != -1:\n                self._executor._workspace.rm_state(state_id)\n\n        # clean up lists\n        with self.locked_context('ethereum') as eth_context:\n            eth_context['_saved_states'] = set()\n            eth_context['_final_states'] = set()\n\n        logger.info(\"Results in %s\", self.workspace)\n\n    def global_coverage(self, account):\n        \"\"\" Returns code coverage for the contract on `account_address`.\n            This sums up all the visited code lines from any of the explored\n            states.\n        \"\"\"\n        account_address = int(account)\n        runtime_bytecode = None\n        #Search one state in which the account_address exists\n        for state in self.all_states:\n            world = state.platform\n            if account_address in world:\n                code = world.get_code(account_address)\n                runtime_bytecode = state.solve_one(code)\n                break\n        else:\n            return 0.0\n        with self.locked_context('runtime_coverage') as coverage:\n            seen = {off for addr, off in coverage if addr == account_address}\n        return calculate_coverage(runtime_bytecode, seen)\n\n    # TODO: Find a better way to suppress execution of Manticore._did_finish_run_callback\n    # We suppress because otherwise we log it many times and it looks weird.\n    def _did_finish_run_callback(self):\n        pass\n\n    def __repr__(self):\n        return self.__str__()\n\n    def __str__(self):\n        return \"<ManticoreEVM | Alive States: {}; Terminated States: {}>\".format(\n            self.count_running_states(),\n            self.count_terminated_states()\n        )\n",
        "source_code_len": 70238,
        "target_code": "\nfrom ..exceptions import NoAliveStates, EthereumError\nfrom ..platforms import evm\n",
        "target_code_len": 83,
        "diff_format": "@@ -35,1623 +11,3 @@\n \n-logger = logging.getLogger(__name__)\n-\n-init_logging()  # FIXME(mark): emitting a warning in abi.py does not work unless this is called a second time here\n-\n-\n-def flagged(flag):\n-    \"\"\"\n-    Return special character denoting concretization happened.\n-    \"\"\"\n-    return '(*)' if flag else ''\n-\n-\n-def write_findings(method, lead_space, address, pc, at_init=\"\"):\n-    \"\"\"\n-    Writes contract address and EVM program counter indicating whether counter was read at constructor\n-    :param method: pointer to the object with the write method\n-    :param lead_space: leading white space\n-    :param address: contract address\n-    :param pc: program counter\n-    :param at_init: Boolean\n-    :return: pass\n-    \"\"\"\n-    method.write(f'{lead_space}Contract: 0x:{address}')\n-    method.write(f'{lead_space}EVM Program counter: 0x{pc}{\" (at constructor)\" if at_init else \"\"}\\n')\n-\n-#\n-# Plugins\n-#\n-\n-\n-class FilterFunctions(Plugin):\n-    def __init__(self, regexp=r'.*', mutability='both', depth='both', fallback=False, include=True, **kwargs):\n-        \"\"\"\n-            Constrain input based on function metadata. Include or avoid functions selected by the specified criteria.\n-\n-            Examples:\n-            #Do not explore any human transactions that end up calling a constant function\n-            no_human_constant = FilterFunctions(depth='human', mutability='constant', include=False)\n-\n-            #At human tx depth only accept synthetic check functions\n-            only_tests = FilterFunctions(regexp=r'mcore_.*', depth='human', include=False)\n-\n-            :param regexp: a regular expression over the name of the function '.*' will match all functions\n-            :param mutability: mutable, constant or both will match functions declared in the abi to be of such class\n-            :param depth: match functions in internal transactions, in human initiated transactions or in both types\n-            :param fallback: if True include the fallback function. Hash will be 00000000 for it\n-            :param include: if False exclude the selected functions, if True include them\n-        \"\"\"\n-        super().__init__(**kwargs)\n-        depth = depth.lower()\n-        if depth not in ('human', 'internal', 'both'):\n-            raise ValueError\n-        mutability = mutability.lower()\n-        if mutability not in ('mutable', 'constant', 'both'):\n-            raise ValueError\n-\n-        #fixme better names for member variables\n-        self._regexp = regexp\n-        self._mutability = mutability\n-        self._depth = depth\n-        self._fallback = fallback\n-        self._include = include\n-\n-    def will_open_transaction_callback(self, state, tx):\n-        world = state.platform\n-        tx_cnt = len(world.all_transactions)\n-        # Constrain input only once per tx, per plugin\n-        if state.context.get('constrained%d' % id(self), 0) != tx_cnt:\n-            state.context['constrained%d' % id(self)] = tx_cnt\n-\n-            if self._depth == 'human' and not tx.is_human:\n-                return\n-            if self._depth == 'internal' and tx.is_human:\n-                return\n-\n-            #Get metadata if any for the target address of current tx\n-            md = self.manticore.get_metadata(tx.address)\n-            if md is None:\n-                return\n-            #Let's compile  the list of interesting hashes\n-            selected_functions = []\n-\n-            for func_hsh in md.function_selectors:\n-                abi = md.get_abi(func_hsh)\n-                if abi['type'] == 'fallback':\n-                    continue\n-                if self._mutability == 'constant' and not abi.get('constant', False):\n-                    continue\n-                if self._mutability == 'mutable' and abi.get('constant', False):\n-                    continue\n-                if not re.match(self._regexp, abi['name']):\n-                    continue\n-                selected_functions.append(func_hsh)\n-\n-            if self._fallback and md.has_non_default_fallback_function:\n-                selected_functions.append(md.fallback_function_selector)\n-\n-            if self._include:\n-                # constrain the input so it can take only the interesting values\n-                constraint = reduce(Operators.OR, (tx.data[:4] == x for x in selected_functions))\n-                state.constrain(constraint)\n-            else:\n-                #Avoid all not selected hashes\n-                for func_hsh in md.function_selectors:\n-                    if func_hsh in selected_functions:\n-                        constraint = tx.data[:4] != func_hsh\n-                        state.constrain(constraint)\n-\n-\n-class LoopDepthLimiter(Plugin):\n-    ''' This just aborts explorations that are too deep '''\n-\n-    def __init__(self, loop_count_threshold=5, **kwargs):\n-        super().__init__(**kwargs)\n-        self.loop_count_threshold = loop_count_threshold\n-\n-    def will_start_run_callback(self, *args):\n-        with self.manticore.locked_context('seen_rep', dict) as reps:\n-            reps.clear()\n-\n-    def will_execute_instruction_callback(self, state, pc, insn):\n-        world = state.platform\n-        with self.manticore.locked_context('seen_rep', dict) as reps:\n-            item = (world.current_transaction.sort == 'CREATE', world.current_transaction.address, pc)\n-            if item not in reps:\n-                reps[item] = 0\n-            reps[item] += 1\n-            if reps[item] > self.loop_count_threshold:\n-                state.abandon()\n-\n-\n-class VerboseTrace(Plugin):\n-    def will_evm_execute_instruction_callback(self, state, instruction, arguments):\n-        current_vm = state.platform.current_vm\n-        state.setdefault('str_trace', []).append(str(current_vm))\n-\n-    def on_finalize(self, state, testcase):\n-        with testcase.open_stream('str_trace') as str_trace_f:\n-            str_trace_f.write('\\n'.join(state.context.get('str_trace', [])))\n-\n-\n-def calculate_coverage(runtime_bytecode, seen):\n-    \"\"\" Calculates what percentage of runtime_bytecode has been seen \"\"\"\n-    count, total = 0, 0\n-    bytecode = SolidityMetadata._without_metadata(runtime_bytecode)\n-    for i in EVMAsm.disassemble_all(bytecode):\n-        if i.pc in seen:\n-            count += 1\n-        total += 1\n-\n-    if total == 0:\n-        #No runtime_bytecode\n-        return 0\n-    return count * 100.0 / total\n-\n-\n-class ManticoreEVM(Manticore):\n-    \"\"\" Manticore EVM manager\n-\n-        Usage Ex::\n-\n-            from manticore.ethereum import ManticoreEVM, ABI\n-            m = ManticoreEVM()\n-            #And now make the contract account to analyze\n-            source_code = '''\n-                pragma solidity ^0.4.15;\n-                contract AnInt {\n-                    uint private i=0;\n-                    function set(uint value){\n-                        i=value\n-                    }\n-                }\n-            '''\n-            #Initialize user and contracts\n-            user_account = m.create_account(balance=1000)\n-            contract_account = m.solidity_create_contract(source_code, owner=user_account, balance=0)\n-            contract_account.set(12345, value=100)\n-\n-            m.finalize()\n-    \"\"\"\n-\n-    def make_symbolic_buffer(self, size, name=None):\n-        \"\"\" Creates a symbolic buffer of size bytes to be used in transactions.\n-            You can operate on it normally and add constraints to manticore.constraints\n-            via manticore.constrain(constraint_expression)\n-\n-            Example use::\n-\n-                symbolic_data = m.make_symbolic_buffer(320)\n-                m.constrain(symbolic_data[0] == 0x65)\n-                m.transaction(caller=attacker_account,\n-                                address=contract_account,\n-                                data=symbolic_data,\n-                                value=100000 )\n-        \"\"\"\n-        avoid_collisions = False\n-        if name is None:\n-            name = 'TXBUFFER'\n-            avoid_collisions = True\n-        return self.constraints.new_array(index_bits=256, name=name, index_max=size, value_bits=8, taint=frozenset(), avoid_collisions=avoid_collisions)\n-\n-    def make_symbolic_value(self, nbits=256, name=None):\n-        \"\"\" Creates a symbolic value, normally a uint256, to be used in transactions.\n-            You can operate on it normally and add constraints to manticore.constraints\n-            via manticore.constrain(constraint_expression)\n-\n-            Example use::\n-\n-                symbolic_value = m.make_symbolic_value()\n-                m.constrain(symbolic_value > 100)\n-                m.constrain(symbolic_value < 1000)\n-                m.transaction(caller=attacker_account,\n-                                address=contract_account,\n-                                data=data,\n-                                value=symbolic_value )\n-\n-        \"\"\"\n-        avoid_collisions = False\n-        if name is None:\n-            name = 'TXVALUE'\n-            avoid_collisions = True\n-        return self.constraints.new_bitvec(nbits, name=name, avoid_collisions=avoid_collisions)\n-\n-    def make_symbolic_address(self, name=None, select='both'):\n-        if select not in ('both', 'normal', 'contract'):\n-            raise EthereumError('Wrong selection type')\n-        if select in ('normal', 'contract'):\n-            # FIXME need to select contracts or normal accounts\n-            raise NotImplemented\n-        avoid_collisions = False\n-        if name is None:\n-            name = 'TXADDR'\n-            avoid_collisions = True\n-        return self.constraints.new_bitvec(160, name=name, avoid_collisions=avoid_collisions)\n-\n-        constraint = symbolic_address == 0\n-        for contract_account_i in map(int, self._accounts.values()):\n-            constraint = Operators.OR(symbolic_address == contract_account_i, constraint)\n-        self.constrain(constraint)\n-        return symbolic_address\n-\n-    def constrain(self, constraint):\n-        if self.count_states() == 0:\n-            self.constraints.add(constraint)\n-        else:\n-            for state in self.all_states:\n-                state.constrain(constraint)\n-\n-    @staticmethod\n-    def compile(source_code, contract_name=None, libraries=None, runtime=False, solc_bin=None, solc_remaps=[]):\n-        \"\"\" Get initialization bytecode from a Solidity source code \"\"\"\n-        name, source_code, init_bytecode, runtime_bytecode, srcmap, srcmap_runtime, hashes, abi, warnings = ManticoreEVM._compile(source_code, contract_name, libraries, solc_bin, solc_remaps)\n-        if runtime:\n-            return runtime_bytecode\n-        return init_bytecode\n-\n-    @staticmethod\n-    def _link(bytecode, libraries=None):\n-        has_dependencies = '_' in bytecode\n-        hex_contract = bytecode\n-        if has_dependencies:\n-            deps = {}\n-            pos = 0\n-            while pos < len(hex_contract):\n-                if hex_contract[pos] == '_':\n-                    # __/tmp/tmp_9k7_l:Manticore______________\n-                    lib_placeholder = hex_contract[pos:pos + 40]\n-                    lib_name = lib_placeholder.split(':')[1].split('_')[0]\n-                    deps.setdefault(lib_name, []).append(pos)\n-                    pos += 40\n-                else:\n-                    pos += 2\n-\n-            if libraries is None:\n-                raise DependencyError(deps.keys())\n-            libraries = dict(libraries)\n-            hex_contract_lst = list(hex_contract)\n-            for lib_name, pos_lst in deps.items():\n-                try:\n-                    lib_address = libraries[lib_name]\n-                except KeyError:\n-                    raise DependencyError([lib_name])\n-                for pos in pos_lst:\n-                    hex_contract_lst[pos:pos + 40] = '%040x' % int(lib_address)\n-            hex_contract = ''.join(hex_contract_lst)\n-        return bytearray(binascii.unhexlify(hex_contract))\n-\n-    @staticmethod\n-    def _run_solc(source_file, solc_bin=None, solc_remaps=[], working_dir=None):\n-        \"\"\" Compile a source file with the Solidity compiler\n-\n-            :param source_file: a file object for the source file\n-            :param solc_bin: path to solc binary\n-            :param solc_remaps: solc import remaps\n-            :return: output, warnings\n-        \"\"\"\n-        if solc_bin is not None:\n-            solc = solc_bin\n-        else:\n-            solc = \"solc\"\n-\n-        #check solc version\n-        supported_versions = ('0.4.18', '0.4.21')\n-\n-        try:\n-            installed_version_output = check_output([solc, \"--version\"])\n-        except OSError:\n-            raise EthereumError(\"Solidity compiler not installed.\")\n-\n-        m = re.match(r\".*Version: (?P<version>(?P<major>\\d+)\\.(?P<minor>\\d+)\\.(?P<build>\\d+)).*\\+(?P<commit>[^\\s]+).*\", installed_version_output.decode(), re.DOTALL | re.IGNORECASE)\n-\n-        if not m or m.groupdict()['version'] not in supported_versions:\n-            #Fixme https://github.com/trailofbits/manticore/issues/847\n-            #logger.warning(\"Unsupported solc version %s\", installed_version)\n-            pass\n-\n-        # solc path search is a mess\n-        # https://solidity.readthedocs.io/en/latest/layout-of-source-files.html\n-\n-        relative_filepath = source_file.name\n-\n-        if not working_dir:\n-            working_dir = os.getcwd()\n-        elif relative_filepath.startswith(working_dir):\n-            relative_filepath = relative_filepath[len(working_dir) + 1:]\n-\n-        # If someone pass an absolute path to the file, we don't have to put cwd\n-        additional_kwargs = {'cwd': working_dir} if working_dir else {}\n-\n-        solc_invocation = [solc] + list(solc_remaps) + [\n-            '--combined-json', 'abi,srcmap,srcmap-runtime,bin,hashes,bin-runtime',\n-            '--allow-paths', '.',\n-            relative_filepath\n-        ]\n-\n-        p = Popen(solc_invocation, stdout=PIPE, stderr=PIPE, **additional_kwargs)\n-        stdout, stderr = p.communicate()\n-\n-        stdout, stderr = stdout.decode(), stderr.decode()\n-\n-        # See #1123 - solc fails when run within snap\n-        # and https://forum.snapcraft.io/t/interfaces-allow-access-tmp-directory/5129\n-        if stdout == '' and f'\"\"{relative_filepath}\"\" is not found' in stderr:\n-            raise EthereumError(\n-                'Solidity compilation failed with error: {}\\n'\n-                'Did you install solc from snap Linux universal packages?\\n'\n-                \"If so, the problem is likely due to snap's sandbox restricting access to /tmp\\n\"\n-                '\\n'\n-                'Here are some potential solutions:\\n'\n-                ' 1) Remove solc from snap and install it different way\\n'\n-                ' 2) Reinstall solc from snap in developer mode, so there is no sandbox\\n'\n-                \" 3) Find a way to add /tmp to the solc's sandbox. If you do, \"\n-                \"send us a PR so we could add it here!\".format(stderr)\n-            )\n-\n-        try:\n-            return json.loads(stdout), stderr\n-        except ValueError:\n-            raise EthereumError('Solidity compilation error:\\n\\n{}'.format(stderr))\n-\n-    @staticmethod\n-    def _compile(source_code, contract_name, libraries=None, solc_bin=None, solc_remaps=[], working_dir=None):\n-        \"\"\" Compile a Solidity contract, used internally\n-\n-            :param source_code: solidity source as either a string or a file handle\n-            :param contract_name: a string with the name of the contract to analyze\n-            :param libraries: an itemizable of pairs (library_name, address)\n-            :param solc_bin: path to solc binary\n-            :param solc_remaps: solc import remaps\n-            :param working_dir: working directory for solc compilation (defaults to current)\n-            :return: name, source_code, bytecode, srcmap, srcmap_runtime, hashes\n-            :return: name, source_code, bytecode, runtime, srcmap, srcmap_runtime, hashes, abi, warnings\n-        \"\"\"\n-\n-        if isinstance(source_code, str):\n-            with tempfile.NamedTemporaryFile('w+') as temp:\n-                temp.write(source_code)\n-                temp.flush()\n-                output, warnings = ManticoreEVM._run_solc(temp, solc_bin, solc_remaps, working_dir=working_dir)\n-        elif isinstance(source_code, io.IOBase):\n-            output, warnings = ManticoreEVM._run_solc(source_code, solc_bin, solc_remaps, working_dir=working_dir)\n-            source_code.seek(0)\n-            source_code = source_code.read()\n-        else:\n-            raise TypeError(f'source code bad type: {type(source_code).__name__}')\n-\n-        contracts = output.get('contracts', [])\n-        if len(contracts) != 1 and contract_name is None:\n-            raise EthereumError('Solidity file must contain exactly one contract or you must use a contract parameter to specify one.')\n-\n-        name, contract = None, None\n-        if contract_name is None:\n-            name, contract = list(contracts.items())[0]\n-        else:\n-            for n, c in contracts.items():\n-                if n.split(\":\")[1] == contract_name:\n-                    name, contract = n, c\n-                    break\n-\n-        if name is None:\n-            raise ValueError('Specified contract not found')\n-\n-        name = name.split(':')[1]\n-\n-        if contract['bin'] == '':\n-            raise EthereumError('Solidity failed to compile your contract.')\n-\n-        bytecode = ManticoreEVM._link(contract['bin'], libraries)\n-        srcmap = contract['srcmap'].split(';')\n-        srcmap_runtime = contract['srcmap-runtime'].split(';')\n-        hashes = {str(x): str(y) for x, y in contract['hashes'].items()}\n-        abi = json.loads(contract['abi'])\n-        runtime = ManticoreEVM._link(contract['bin-runtime'], libraries)\n-        return name, source_code, bytecode, runtime, srcmap, srcmap_runtime, hashes, abi, warnings\n-\n-    @property\n-    def accounts(self):\n-        return dict(self._accounts)\n-\n-    def account_name(self, address):\n-        for name, account in self._accounts.items():\n-            if account.address == address:\n-                return name\n-        return '0x{:x}'.format(address)\n-\n-    @property\n-    def normal_accounts(self):\n-        return {name: account for name, account in self._accounts.items() if not isinstance(account, EVMContract)}\n-\n-    @property\n-    def contract_accounts(self):\n-        return {name: account for name, account in self._accounts.items() if isinstance(account, EVMContract)}\n-\n-    def get_account(self, name):\n-        return self._accounts[name]\n-\n-    def __init__(self, procs=10, workspace_url: str=None, policy: str='random'):\n-        \"\"\"\n-        A Manticore EVM manager\n-        :param procs:, number of workers to use in the exploration\n-        :param workspace_url: workspace folder name\n-        :param policy: scheduling priority\n-        \"\"\"\n-        self._accounts = dict()\n-        self._serializer = PickleSerializer()\n-\n-        self._config_procs = procs\n-        # Make the constraint store\n-        constraints = ConstraintSet()\n-        # make the ethereum world state\n-        world = evm.EVMWorld(constraints, initial_timestamp=1524785992)\n-        initial_state = State(constraints, world)\n-        super().__init__(initial_state, workspace_url=workspace_url, policy=policy)\n-\n-        self.constraints = ConstraintSet()\n-        self.detectors = {}\n-        self.metadata: Dict[int, SolidityMetadata] = {}\n-\n-        # The following should go to manticore.context so we can use multiprocessing\n-        self.context['ethereum'] = {}\n-        self.context['ethereum']['_saved_states'] = set()\n-        self.context['ethereum']['_final_states'] = set()\n-        self.context['ethereum']['_completed_transactions'] = 0\n-        self.context['ethereum']['_sha3_states'] = dict()\n-        self.context['ethereum']['_known_sha3'] = set()\n-\n-        self._executor.subscribe('did_load_state', self._load_state_callback)\n-        self._executor.subscribe('will_terminate_state', self._terminate_state_callback)\n-        self._executor.subscribe('did_evm_execute_instruction', self._did_evm_execute_instruction_callback)\n-        self._executor.subscribe('did_read_code', self._did_evm_read_code)\n-        self._executor.subscribe('on_symbolic_sha3', self._on_symbolic_sha3_callback)\n-        self._executor.subscribe('on_concrete_sha3', self._on_concrete_sha3_callback)\n-\n-    @property\n-    def world(self):\n-        \"\"\" The world instance or None if there is more than one state \"\"\"\n-        return self.get_world()\n-\n-    @property\n-    def completed_transactions(self):\n-        with self.locked_context('ethereum') as context:\n-            return context['_completed_transactions']\n-\n-    @property\n-    def _running_state_ids(self):\n-        \"\"\" IDs of the running states\"\"\"\n-        with self.locked_context('ethereum') as context:\n-            if self.initial_state is not None:\n-                return (-1,) + tuple(context['_saved_states'])\n-            else:\n-                return tuple(context['_saved_states'])\n-\n-    @property\n-    def _terminated_state_ids(self):\n-        \"\"\" IDs of the terminated states \"\"\"\n-        with self.locked_context('ethereum') as context:\n-            return tuple(context['_final_states'])\n-\n-    @property\n-    def _all_state_ids(self):\n-        \"\"\" IDs of the all states\n-\n-            Note: state with id -1 is already in memory and it is not backed on the storage\n-        \"\"\"\n-        return self._running_state_ids + self._terminated_state_ids\n-\n-    @property\n-    def running_states(self):\n-        \"\"\" Iterates over the running states\"\"\"\n-        for state_id in self._running_state_ids:\n-            state = self.load(state_id)\n-            yield state\n-            self.save(state, state_id=state_id)  # overwrite old\n-\n-    @property\n-    def terminated_states(self):\n-        \"\"\" Iterates over the terminated states\"\"\"\n-        for state_id in self._terminated_state_ids:\n-            state = self.load(state_id)\n-            yield state\n-            self.save(state, state_id=state_id)  # overwrite old\n-\n-    @property\n-    def all_states(self):\n-        \"\"\" Iterates over the all states (terminated and alive)\"\"\"\n-        for state_id in self._all_state_ids:\n-            state = self.load(state_id)\n-            yield state\n-            self.save(state, state_id=state_id)  # overwrite old\n-\n-    def count_states(self):\n-        \"\"\" Total states count \"\"\"\n-        return len(self._all_state_ids)\n-\n-    def count_running_states(self):\n-        \"\"\" Running states count \"\"\"\n-        return len(self._running_state_ids)\n-\n-    def count_terminated_states(self):\n-        \"\"\" Terminated states count \"\"\"\n-        return len(self._terminated_state_ids)\n-\n-    def _terminate_state_id(self, state_id):\n-        \"\"\" Manually terminates a states by state_id.\n-            Moves the state from the running list into the terminated list\n-        \"\"\"\n-\n-        if state_id != -1:\n-            # Move state from running to final\n-            with self.locked_context('ethereum') as eth_context:\n-                saved_states = eth_context['_saved_states']\n-                final_states = eth_context['_final_states']\n-                if state_id in saved_states:\n-                    saved_states.remove(state_id)\n-                    final_states.add(state_id)\n-                    eth_context['_saved_states'] = saved_states  # TODO This two may be not needed in py3?\n-                    eth_context['_final_states'] = final_states\n-        else:\n-            assert state_id == -1\n-            state_id = self.save(self._initial_state, final=True)\n-            self._initial_state = None\n-        return state_id\n-\n-    def _revive_state_id(self, state_id):\n-        \"\"\" Manually revive a state by state_id.\n-            Moves the state from the final list into the running list\n-        \"\"\"\n-\n-        # Move state from final to running\n-        if state_id != -1:\n-            with self.locked_context('ethereum') as eth_context:\n-                saved_states = eth_context['_saved_states']\n-                final_states = eth_context['_final_states']\n-                if state_id in final_states:\n-                    final_states.remove(state_id)\n-                    saved_states.add(state_id)\n-                    eth_context['_saved_states'] = saved_states\n-                    eth_context['_final_states'] = final_states\n-        return state_id\n-\n-    # deprecate this 5 in favor of for sta in m.all_states: do stuff?\n-\n-    def get_world(self, state_id=None):\n-        \"\"\" Returns the evm world of `state_id` state. \"\"\"\n-        state = self.load(state_id)\n-        if state is None:\n-            return None\n-        else:\n-            return state.platform\n-\n-    def get_balance(self, address, state_id=None):\n-        \"\"\" Balance for account `address` on state `state_id` \"\"\"\n-        if isinstance(address, EVMAccount):\n-            address = int(address)\n-        return self.get_world(state_id).get_balance(address)\n-\n-    def get_storage_data(self, address, offset, state_id=None):\n-        \"\"\" Storage data for `offset` on account `address` on state `state_id` \"\"\"\n-        if isinstance(address, EVMAccount):\n-            address = int(address)\n-        return self.get_world(state_id).get_storage_data(address, offset)\n-\n-    def get_code(self, address, state_id=None):\n-        \"\"\" Storage data for `offset` on account `address` on state `state_id` \"\"\"\n-        if isinstance(address, EVMAccount):\n-            address = int(address)\n-        return self.get_world(state_id).get_code(address)\n-\n-    def last_return(self, state_id=None):\n-        \"\"\" Last returned buffer for state `state_id` \"\"\"\n-        state = self.load(state_id)\n-        return state.platform.last_return_data\n-\n-    def transactions(self, state_id=None):\n-        \"\"\" Transactions list for state `state_id` \"\"\"\n-        state = self.load(state_id)\n-        return state.platform.transactions\n-\n-    def human_transactions(self, state_id=None):\n-        \"\"\" Transactions list for state `state_id` \"\"\"\n-        state = self.load(state_id)\n-        return state.platform.human_transactions\n-\n-    def make_symbolic_arguments(self, types):\n-        \"\"\"\n-            Make a reasonable serialization of the symbolic argument types\n-        \"\"\"\n-        # FIXME this is more naive than reasonable.\n-        return ABI.deserialize(types, self.make_symbolic_buffer(32, name=\"INITARGS\"))\n-\n-    def solidity_create_contract(self, source_code, owner, name=None, contract_name=None, libraries=None,\n-                                 balance=0, address=None, args=(), solc_bin=None, solc_remaps=[],\n-                                 working_dir=None, gas=90000):\n-        \"\"\" Creates a solidity contract and library dependencies\n-\n-            :param str source_code: solidity source code\n-            :param owner: owner account (will be default caller in any transactions)\n-            :type owner: int or EVMAccount\n-            :param contract_name: Name of the contract to analyze (optional if there is a single one in the source code)\n-            :type contract_name: str\n-            :param balance: balance to be transferred on creation\n-            :type balance: int or SValue\n-            :param address: the address for the new contract (optional)\n-            :type address: int or EVMAccount\n-            :param tuple args: constructor arguments\n-            :param solc_bin: path to solc binary\n-            :type solc_bin: str\n-            :param solc_remaps: solc import remaps\n-            :type solc_remaps: list of str\n-            :param working_dir: working directory for solc compilation (defaults to current)\n-            :type working_dir: str\n-            :param gas: gas budget for each contract creation needed (may be more than one if several related contracts defined in the solidity source)\n-            :type gas: int\n-            :rtype: EVMAccount\n-        \"\"\"\n-        if libraries is None:\n-            deps = {}\n-        else:\n-            deps = dict(libraries)\n-\n-        contract_names = [contract_name]\n-        while contract_names:\n-            contract_name_i = contract_names.pop()\n-            try:\n-                compile_results = self._compile(source_code, contract_name_i,\n-                                                libraries=deps, solc_bin=solc_bin, solc_remaps=solc_remaps,\n-                                                working_dir=working_dir)\n-                md = SolidityMetadata(*compile_results)\n-                if contract_name_i == contract_name:\n-                    constructor_types = md.get_constructor_arguments()\n-                    if args is None:\n-                        args = self.make_symbolic_arguments(constructor_types)\n-                    contract_account = self.create_contract(owner=owner,\n-                                                            balance=balance,\n-                                                            address=address,\n-                                                            init=md._init_bytecode + ABI.serialize(constructor_types, *args),\n-                                                            name=name,\n-                                                            gas=gas)\n-                else:\n-                    contract_account = self.create_contract(owner=owner, init=md._init_bytecode)\n-\n-                if contract_account is None:\n-                    raise EthereumError(\"Failed to build contract %s\" % contract_name_i)\n-                self.metadata[int(contract_account)] = md\n-\n-                deps[contract_name_i] = contract_account\n-            except DependencyError as e:\n-                contract_names.append(contract_name_i)\n-                for lib_name in e.lib_names:\n-                    if lib_name not in deps:\n-                        contract_names.append(lib_name)\n-\n-        if not self.count_running_states() or len(self.get_code(contract_account)) == 0:\n-            return None\n-        return contract_account\n-\n-    def get_nonce(self, address):\n-        # type forgiveness:\n-        address = int(address)\n-        # get all nonces for states containing this address:\n-        nonces = set(state.platform.get_nonce(address) for state in self.running_states if address in state.platform)\n-        if not nonces:\n-            raise NoAliveStates(\"There are no alive states containing address %x\" % address)\n-        elif len(nonces) != 1:\n-            # if there are multiple states with this address, they all have to have the same nonce:\n-            raise EthereumError(\"Cannot increase the nonce of address %x because it exists in multiple states with different nonces\" % address)\n-        else:\n-            return next(iter(nonces))\n-\n-    def create_contract(self, owner, balance=0, address=None, init=None, name=None, gas=21000):\n-        \"\"\" Creates a contract\n-\n-            :param owner: owner account (will be default caller in any transactions)\n-            :type owner: int or EVMAccount\n-            :param balance: balance to be transferred on creation\n-            :type balance: int or SValue\n-            :param int address: the address for the new contract (optional)\n-            :param str init: initializing evm bytecode and arguments\n-            :param str name: a unique name for reference\n-            :param gas: gas budget for the creation/initialization of the contract\n-            :rtype: EVMAccount\n-        \"\"\"\n-        if not self.count_running_states():\n-            raise NoAliveStates\n-\n-        nonce = self.get_nonce(owner)\n-        expected_address = evm.EVMWorld.calculate_new_address(int(owner), nonce=nonce)\n-\n-        if address is None:\n-            address = expected_address\n-        elif address != expected_address:\n-            raise EthereumError(\"Address was expected to be %x but was given %x\" % (expected_address, address))\n-\n-        # Name check\n-        if name is None:\n-            name = self._get_uniq_name(\"contract\")\n-        if name in self._accounts:\n-            # Account name already used\n-            raise EthereumError(\"Name already used\")\n-\n-        self._transaction('CREATE', owner, balance, address, data=init, gaslimit=gas)\n-        # TODO detect failure in the constructor\n-\n-        self._accounts[name] = EVMContract(address=address, manticore=self, default_caller=owner, name=name)\n-        return self.accounts[name]\n-\n-    def _get_uniq_name(self, stem):\n-        count = 0\n-        for name_i in self.accounts.keys():\n-            if name_i.startswith(stem):\n-                try:\n-                    count = max(count, int(name_i[len(stem):]) + 1)\n-                except:\n-                    pass\n-        name = \"{:s}{:d}\".format(stem, count)\n-        assert name not in self.accounts\n-        return name\n-\n-    def _all_addresses(self):\n-        \"\"\" Returns all addresses in all running states \"\"\"\n-        ret = set()\n-        for state in self.running_states:\n-            ret |= set(state.platform.accounts)\n-        return ret\n-\n-    def new_address(self):\n-        \"\"\" Create a fresh 160bit address \"\"\"\n-        all_addresses = self._all_addresses()\n-        while True:\n-            new_address = random.randint(100, pow(2, 160))\n-            if new_address not in all_addresses:\n-                return new_address\n-\n-    def transaction(self, caller, address, value, data, gas=21000):\n-        \"\"\" Issue a symbolic transaction in all running states\n-\n-            :param caller: the address of the account sending the transaction\n-            :type caller: int or EVMAccount\n-            :param address: the address of the contract to call\n-            :type address: int or EVMAccount\n-            :param value: balance to be transfered on creation\n-            :type value: int or SValue\n-            :param data: initial data\n-            :param gas: gas budget\n-            :raises NoAliveStates: if there are no alive states to execute\n-        \"\"\"\n-        self._transaction('CALL', caller, value=value, address=address, data=data, gaslimit=gas)\n-\n-    def create_account(self, balance=0, address=None, code=None, name=None):\n-        \"\"\" Low level creates an account. This won't generate a transaction.\n-\n-            :param balance: balance to be set on creation (optional)\n-            :type balance: int or SValue\n-            :param address: the address for the new account (optional)\n-            :type address: int\n-            :param code: the runtime code for the new account (None means normal account) (optional)\n-            :param name: a global account name eg. for use as reference in the reports (optional)\n-            :return: an EVMAccount\n-        \"\"\"\n-        # Need at least one state where to apply this\n-        if not self.count_running_states():\n-            raise NoAliveStates\n-\n-        # Name check\n-        if name is None:\n-            if code is None:\n-                name = self._get_uniq_name(\"normal\")\n-            else:\n-                name = self._get_uniq_name(\"contract\")\n-        if name in self._accounts:\n-            # Account name already used\n-            raise EthereumError(\"Name already used\")\n-\n-        #Balance check\n-        if not isinstance(balance, int):\n-            raise EthereumError(\"Balance invalid type\")\n-\n-        if isinstance(code, str):\n-            code = bytearray(code)\n-        if code is not None and not isinstance(code, (bytearray, Array)):\n-            raise EthereumError(\"code bad type\")\n-\n-        # Address check\n-        # Let's just choose the address ourself. This is not yellow paper material\n-        if address is None:\n-            address = self.new_address()\n-        if not isinstance(address, int):\n-            raise EthereumError(\"A concrete address is needed\")\n-        assert address is not None\n-        if address in map(int, self.accounts.values()):\n-            # Address already used\n-            raise EthereumError(\"Address already used\")\n-\n-        # To avoid going full crazy we maintain a global list of addresses\n-        # Different states may CREATE a different set of accounts.\n-        # Accounts created by a human have the same address in all states.\n-        for state in self.running_states:\n-            world = state.platform\n-\n-            if '_pending_transaction' in state.context:\n-                raise EthereumError(\"This is bad. There should not be a pending transaction\")\n-\n-            if address in world.accounts:\n-                # Address already used\n-                raise EthereumError(\"This is bad. Same address is used for different contracts in different states\")\n-            world.create_account(address, balance, code=code, storage=None)\n-\n-        self._accounts[name] = EVMAccount(address, manticore=self, name=name)\n-        return self.accounts[name]\n-\n-    def _migrate_tx_expressions(self, state, caller, address, value, data):\n-            # Copy global constraints into each state.\n-            # We should somehow remember what has been copied to each state\n-            # In a second transaction we should only add new constraints.\n-            # And actually only constraints related to whatever we are using in\n-            # the tx. This is a FIXME\n-            global_constraints = self.constraints\n-\n-            # Normally users will be making these symbolic expressions by creating\n-            # global symbolic variables via ManticoreEVM.make_.... and those\n-            # global expressions need to be imported into each state when a tx\n-            # actually happens\n-\n-            if issymbolic(caller):\n-                caller = state.migrate_expression(caller)\n-\n-            if issymbolic(address):\n-                address = state.migrate_expression(address)\n-\n-            if issymbolic(value):\n-                value = state.migrate_expression(value)\n-\n-            if issymbolic(data):\n-                if isinstance(data, ArrayProxy):  # FIXME is this necessary here?\n-                    data = data.array\n-                data = state.migrate_expression(data)\n-                if isinstance(data, Array):\n-                    data = ArrayProxy(data)\n-\n-            for c in global_constraints:\n-                state.constrain(c)\n-\n-            return caller, address, value, data\n-\n-    def _transaction(self, sort, caller, value=0, address=None, data=None, gaslimit=0, price=1):\n-        \"\"\" Initiates a transaction\n-\n-            :param caller: caller account\n-            :type caller: int or EVMAccount\n-            :param int address: the address for the transaction (optional)\n-            :param value: value to be transferred\n-            :param price: the price of gas for this transaction. Mostly unused.\n-            :type value: int or SValue\n-            :param str data: initializing evm bytecode and arguments or transaction call data\n-            :param gaslimit: gas budget\n-            :rtype: EVMAccount\n-        \"\"\"\n-        #Type Forgiveness\n-        if isinstance(address, EVMAccount):\n-            address = int(address)\n-        if isinstance(caller, EVMAccount):\n-            caller = int(caller)\n-        #Defaults, call data is empty\n-        if data is None:\n-            data = bytearray(b\"\")\n-        if isinstance(data, (str, bytes)):\n-            data = bytearray(data)\n-        if not isinstance(data, (bytearray, Array)):\n-            raise TypeError(\"code bad type\")\n-\n-        # Check types\n-        if not isinstance(caller, (int, BitVec)):\n-            raise TypeError(\"Caller invalid type\")\n-\n-        if not isinstance(value, (int, BitVec)):\n-            raise TypeError(\"Value invalid type\")\n-\n-        if not isinstance(address, (int, BitVec)):\n-            raise TypeError(\"address invalid type\")\n-\n-        if not isinstance(price, int):\n-            raise TypeError(\"Price invalid type\")\n-\n-        # Check argument consistency and set defaults ...\n-        if sort not in ('CREATE', 'CALL'):\n-            raise ValueError('unsupported transaction type')\n-\n-        if sort == 'CREATE':\n-            # When creating data is the init_bytecode + arguments\n-            if len(data) == 0:\n-                raise EthereumError(\"An initialization bytecode is needed for a CREATE\")\n-\n-        assert address is not None\n-        assert caller is not None\n-\n-        # Transactions (like everything else) need at least one running state\n-        if not self.count_running_states():\n-            raise NoAliveStates\n-\n-        # To avoid going full crazy, we maintain a global list of addresses\n-        for state in self.running_states:\n-            world = state.platform\n-\n-            if '_pending_transaction' in state.context:\n-                raise EthereumError(\"This is bad. It should not be a pending transaction\")\n-\n-            # Choose an address here, because it will be dependent on the caller's nonce in this state\n-            if address is None:\n-                if issymbolic(caller):\n-                    # TODO (ESultanik): In order to handle this case, we are going to have to do something like fork\n-                    # over all possible caller addresses.\n-                    # But this edge case will likely be extremely rare, if ever ecountered.\n-                    raise EthereumError(\"Manticore does not currently support contracts with symbolic addresses creating new contracts\")\n-                address = world.new_address(caller)\n-\n-            # Migrate any expression to state specific constraint set\n-            caller_migrated, address_migrated, value_migrated, data_migrated = self._migrate_tx_expressions(state, caller, address, value, data)\n-\n-            # Different states may CREATE a different set of accounts. Accounts\n-            # that were crated by a human have the same address in all states.\n-            # This diverges from the yellow paper but at least we check that we\n-            # are not trying to create an already used address here\n-            if sort == 'CREATE':\n-                if address in world.accounts:\n-                    # Address already used\n-                    raise EthereumError(\"This is bad. Same address is used for different contracts in different states\")\n-\n-            state.context['_pending_transaction'] = (sort, caller_migrated, address_migrated, value_migrated, data_migrated, gaslimit, price)\n-\n-        # run over potentially several states and\n-        # generating potentially several others\n-        self.run(procs=self._config_procs)\n-\n-        return address\n-\n-    def multi_tx_analysis(self, solidity_filename, working_dir=None, contract_name=None,\n-                          tx_limit=None, tx_use_coverage=True,\n-                          tx_send_ether=True, tx_account=\"attacker\", args=None):\n-        owner_account = self.create_account(balance=1000, name='owner')\n-        attacker_account = self.create_account(balance=1000, name='attacker')\n-\n-        # Pretty print\n-        logger.info(\"Starting symbolic create contract\")\n-\n-        with open(solidity_filename) as f:\n-            contract_account = self.solidity_create_contract(f, contract_name=contract_name, owner=owner_account,\n-                                                             args=args, working_dir=working_dir)\n-\n-        if tx_account == \"attacker\":\n-            tx_account = [attacker_account]\n-        elif tx_account == \"owner\":\n-            tx_account = [owner_account]\n-        elif tx_account == \"combo1\":\n-            tx_account = [owner_account, attacker_account]\n-        else:\n-            raise EthereumError('The account to perform the symbolic exploration of the contract should be \"attacker\", \"owner\" or \"combo1\"')\n-\n-        if contract_account is None:\n-            logger.info(\"Failed to create contract: exception in constructor\")\n-            return\n-\n-        prev_coverage = 0\n-        current_coverage = 0\n-        tx_no = 0\n-        while (current_coverage < 100 or not tx_use_coverage) and not self.is_shutdown():\n-            try:\n-                logger.info(\"Starting symbolic transaction: %d\", tx_no)\n-\n-                # run_symbolic_tx\n-                symbolic_data = self.make_symbolic_buffer(320)\n-                if tx_send_ether:\n-                    value = self.make_symbolic_value()\n-                else:\n-                    value = 0\n-                self.transaction(caller=tx_account[min(tx_no, len(tx_account) - 1)],\n-                                 address=contract_account,\n-                                 data=symbolic_data,\n-                                 value=value,\n-                                 gas=2100000)\n-                logger.info(\"%d alive states, %d terminated states\", self.count_running_states(), self.count_terminated_states())\n-            except NoAliveStates:\n-                break\n-\n-            # Check if the maximum number of tx was reached\n-            if tx_limit is not None and tx_no + 1 == tx_limit:\n-                break\n-\n-            # Check if coverage has improved or not\n-            if tx_use_coverage:\n-                prev_coverage = current_coverage\n-                current_coverage = self.global_coverage(contract_account)\n-                found_new_coverage = prev_coverage < current_coverage\n-\n-                if not found_new_coverage:\n-                    break\n-\n-            tx_no += 1\n-\n-    def run(self, **kwargs):\n-        \"\"\" Run any pending transaction on any running state \"\"\"\n-        # Check if there is a pending transaction\n-        with self.locked_context('ethereum') as context:\n-            # there are no states added to the executor queue\n-            assert len(self._executor.list()) == 0\n-            for state_id in context['_saved_states']:\n-                self._executor.put(state_id)\n-            context['_saved_states'] = set()\n-\n-        # A callback will use _pending_transaction and issue the transaction\n-        # in each state (see load_state_callback)\n-        super().run(**kwargs)\n-\n-        with self.locked_context('ethereum') as context:\n-            if len(context['_saved_states']) == 1:\n-                self._initial_state = self._executor._workspace.load_state(context['_saved_states'].pop(), delete=True)\n-                self._executor.forward_events_from(self._initial_state, True)\n-                context['_saved_states'] = set()\n-                assert self._running_state_ids == (-1,)\n-\n-    def save(self, state, state_id=None, final=False):\n-        \"\"\" Save a state in secondary storage and add it to running or final lists\n-\n-            :param state: A manticore State\n-            :param state_id: if not None force state_id (overwrite)\n-            :param final: True if state is final\n-            :returns: a state id\n-        \"\"\"\n-        # If overwriting then the state_id must be known\n-        if state_id is not None:\n-            if state_id not in self._all_state_ids:\n-                raise EthereumError(\"Trying to overwrite unknown state_id\")\n-            with self.locked_context('ethereum') as context:\n-                context['_final_states'].discard(state_id)\n-                context['_saved_states'].discard(state_id)\n-\n-        if state_id != -1:\n-            # save the state to secondary storage\n-            state_id = self._executor._workspace.save_state(state, state_id=state_id)\n-\n-            with self.locked_context('ethereum') as context:\n-                if final:\n-                    # Keep it on a private list\n-                    context['_final_states'].add(state_id)\n-                else:\n-                    # Keep it on a private list\n-                    context['_saved_states'].add(state_id)\n-        return state_id\n-\n-    def load(self, state_id=None):\n-        \"\"\" Load one of the running or final states.\n-\n-            :param state_id: If None it assumes there is a single running state\n-            :type state_id: int or None\n-        \"\"\"\n-        state = None\n-        if state_id is None:\n-            #a single state was assumed\n-            state_count = self.count_running_states()\n-            if state_count == 1:\n-                #Get the ID of the single running state\n-                state_id = self._running_state_ids[0]\n-            elif state_count == 0:\n-                raise NoAliveStates\n-            else:\n-                raise EthereumError(\"More than one state running; you must specify a state id.\")\n-\n-        if state_id == -1:\n-            state = self.initial_state\n-        else:\n-            state = self._executor._workspace.load_state(state_id, delete=False)\n-            #froward events from newly loaded object\n-            self._executor.forward_events_from(state, True)\n-        return state\n-\n-    # Callbacks\n-    def _on_symbolic_sha3_callback(self, state, data, known_hashes):\n-        \"\"\" INTERNAL USE \"\"\"\n-        assert issymbolic(data), 'Data should be symbolic here!'\n-\n-        with self.locked_context('ethereum') as context:\n-            known_sha3 = context.get('_known_sha3', None)\n-            if known_sha3 is None:\n-                known_sha3 = set()\n-\n-            sha3_states = context.get('_sha3_states', [])\n-            results = []\n-            # If know_hashes is true then there is a _known_ solution for the hash\n-            known_hashes_cond = False\n-            for key, value in known_sha3:\n-                assert not issymbolic(key), \"Saved sha3 data,hash pairs should be concrete\"\n-                cond = key == data\n-\n-                #TODO consider disabling this solver query.\n-                if not state.can_be_true(cond):\n-                    continue\n-\n-                results.append((key, value))\n-                known_hashes_cond = Operators.OR(cond, known_hashes_cond)\n-\n-            # adding a single random example so we can explore further in case\n-            # there are not known sha3 pairs that match yet\n-            if not results:\n-                data_concrete = state.solve_one(data)\n-                s = sha3.keccak_256(data_concrete)\n-                data_hash = int(s.hexdigest(), 16)\n-                results.append((data_concrete, data_hash))\n-                known_hashes_cond = data_concrete == data\n-                known_sha3.add((data_concrete, data_hash))\n-            not_known_hashes_cond = Operators.NOT(known_hashes_cond)\n-\n-            # We need to fork/save the state\n-            #################################\n-            # save the state to secondary storage\n-            # Build and enqueue a state for each solution\n-            with state as temp_state:\n-                if temp_state.can_be_true(not_known_hashes_cond):\n-                    temp_state.constrain(not_known_hashes_cond)\n-                    state_id = self._executor._workspace.save_state(temp_state)\n-                    sha3_states[state_id] = [hsh for buf, hsh in known_sha3]\n-            context['_sha3_states'] = sha3_states\n-\n-            if not state.can_be_true(known_hashes_cond):\n-                raise TerminateState(\"There is no matching sha3 pair, bailing out\")\n-            state.constrain(known_hashes_cond)\n-\n-            #send known hashes to evm\n-            known_hashes.update(results)\n-\n-    def _on_concrete_sha3_callback(self, state, buf, value):\n-        \"\"\" INTERNAL USE \"\"\"\n-        with self.locked_context('ethereum', dict) as ethereum_context:\n-            known_sha3 = ethereum_context.get('_known_sha3', None)\n-            if known_sha3 is None:\n-                known_sha3 = set()\n-            known_sha3.add((buf, value))\n-            ethereum_context['_known_sha3'] = known_sha3\n-\n-    def _terminate_state_callback(self, state, state_id, e):\n-        \"\"\" INTERNAL USE\n-            Every time a state finishes executing the last transaction, we save it in\n-            our private list\n-        \"\"\"\n-        if isinstance(e, AbandonState):\n-            #do nothing\n-            return\n-        world = state.platform\n-        state.context['last_exception'] = e\n-        e.testcase = False  # Do not generate a testcase file\n-\n-        if not world.all_transactions:\n-            logger.debug(\"Something went wrong: search terminated in the middle of an ongoing tx\")\n-            self.save(state, final=True)\n-            return\n-\n-        tx = world.all_transactions[-1]\n-\n-        #we initiated the Tx; we need process the outcome for now.\n-        #Fixme incomplete.\n-        if tx.is_human():\n-            if tx.sort == 'CREATE':\n-                if tx.result == 'RETURN':\n-                    world.set_code(tx.address, tx.return_data)\n-                else:\n-                    world.delete_account(tx.address)\n-        else:\n-            logger.info(\"Manticore exception: state should be terminated only at the end of the human transaction\")\n-\n-        #Human tx that ends in this wont modify the storage so finalize and\n-        # generate a testcase. FIXME This should be configurable as REVERT and\n-        # THROW; it actually changes the balance and nonce? of some accounts\n-        if tx.result in {'SELFDESTRUCT', 'REVERT', 'THROW', 'TXERROR'}:\n-            self.save(state, final=True)\n-        elif tx.result in {'RETURN', 'STOP'}:\n-            # if not a revert, we save the state for further transactions\n-            self.save(state)  # Add to running states\n-        else:\n-            logger.debug(\"Exception in state. Discarding it\")\n-\n-    #Callbacks\n-    def _load_state_callback(self, state, state_id):\n-        \"\"\" INTERNAL USE\n-            If a state was just loaded from storage, we do the pending transaction\n-        \"\"\"\n-        if '_pending_transaction' not in state.context:\n-            return\n-        world = state.platform\n-        ty, caller, address, value, data, gaslimit, price = state.context['_pending_transaction']\n-        del state.context['_pending_transaction']\n-\n-        if ty == 'CALL':\n-            world.transaction(address=address, caller=caller, data=data, value=value, price=price, gas=gaslimit)\n-        else:\n-            assert ty == 'CREATE'\n-            world.create_contract(caller=caller, address=address, balance=value, init=data, price=price, gas=gaslimit)\n-\n-    def _did_evm_execute_instruction_callback(self, state, instruction, arguments, result):\n-        \"\"\" INTERNAL USE \"\"\"\n-        #logger.debug(\"%s\", state.platform.current_vm)\n-        #TODO move to a plugin\n-        at_init = state.platform.current_transaction.sort == 'CREATE'\n-        if at_init:\n-            coverage_context_name = 'init_coverage'\n-        else:\n-            coverage_context_name = 'runtime_coverage'\n-\n-        with self.locked_context(coverage_context_name, set) as coverage:\n-            coverage.add((state.platform.current_vm.address, instruction.pc))\n-\n-        state.context.setdefault('evm.trace', []).append((state.platform.current_vm.address, instruction.pc, at_init))\n-\n-    def _did_evm_read_code(self, state, offset, size):\n-        \"\"\" INTERNAL USE \"\"\"\n-        with self.locked_context('code_data', set) as code_data:\n-            for i in range(offset, offset + size):\n-                code_data.add((state.platform.current_vm.address, i))\n-\n-    def get_metadata(self, address) -> Optional[SolidityMetadata]:\n-        \"\"\" Gets the solidity metadata for address.\n-            This is available only if address is a contract created from solidity\n-        \"\"\"\n-        return self.metadata.get(int(address))\n-\n-    def register_detector(self, d):\n-        if not isinstance(d, Detector):\n-            raise EthereumError(\"Not a Detector\")\n-        if d.name in self.detectors:\n-            raise EthereumError(\"Detector already registered\")\n-        self.detectors[d.name] = d\n-        self.register_plugin(d)\n-        return d.name\n-\n-    def unregister_detector(self, d):\n-        if not isinstance(d, (Detector, str)):\n-            raise EthereumError(\"Not a Detector\")\n-        name = d\n-        if isinstance(d, Detector):\n-            name = d.name\n-        if name not in self.detectors:\n-            raise EthereumError(\"Detector not registered\")\n-        d = self.detectors[name]\n-        del self.detectors[name]\n-        self.unregister_plugin(d)\n-\n-    @property\n-    def workspace(self):\n-        return self._executor._workspace._store.uri\n-\n-    def generate_testcase(self, state, message='', only_if=None, name='user'):\n-        \"\"\"\n-        Generate a testcase to the workspace for the given program state. The details of what\n-        a testcase is depends on the type of Platform the state is, but involves serializing the state,\n-        and generating an input (concretizing symbolic variables) to trigger this state.\n-\n-        The only_if parameter should be a symbolic expression. If this argument is provided, and the expression\n-        *can be true* in this state, a testcase is generated such that the expression will be true in the state.\n-        If it *is impossible* for the expression to be true in the state, a testcase is not generated.\n-\n-        This is useful for conveniently checking a particular invariant in a state, and generating a testcase if\n-        the invariant can be violated.\n-\n-        For example, invariant: \"balance\" must not be 0. We can check if this can be violated and generate a\n-        testcase::\n-\n-            m.generate_testcase(state, 'balance CAN be 0', only_if=balance == 0)\n-            # testcase generated with an input that will violate invariant (make balance == 0)\n-\n-        :param manticore.core.state.State state:\n-        :param str message: longer description of the testcase condition\n-        :param manticore.core.smtlib.Bool only_if: only if this expr can be true, generate testcase. if is None, generate testcase unconditionally.\n-        :param str name: short string used as the prefix for the workspace key (e.g. filename prefix for testcase files)\n-        :return: If a testcase was generated\n-        :rtype: bool\n-        \"\"\"\n-        if only_if is None:\n-            self._generate_testcase_callback(state, name, message)\n-            return True\n-        else:\n-            with state as temp_state:\n-                temp_state.constrain(only_if)\n-                if temp_state.is_feasible():\n-                    self._generate_testcase_callback(temp_state, name, message)\n-                    return True\n-\n-        return False\n-\n-    def current_location(self, state):\n-        world = state.platform\n-        address = world.current_vm.address\n-        pc = world.current_vm.pc\n-        at_init = world.current_transaction.sort == 'CREATE'\n-        output = io.StringIO()\n-        write_findings(output, '', address, pc, at_init)\n-        md = self.get_metadata(address)\n-        if md is not None:\n-            src = md.get_source_for(pc, runtime=not at_init)\n-            output.write('Snippet:\\n')\n-            output.write(src.replace('\\n', '\\n  ').strip())\n-            output.write('\\n')\n-        return output.getvalue()\n-\n-    def _generate_testcase_callback(self, state, name, message=''):\n-        \"\"\"\n-        Create a serialized description of a given state.\n-        :param state: The state to generate information about\n-        :param message: Accompanying message\n-        \"\"\"\n-        # workspace should not be responsible for formating the output\n-        # each object knows its secrets, and each class should be able to report its\n-        # final state\n-        #super()._generate_testcase_callback(state, name, message)\n-        # TODO(mark): Refactor ManticoreOutput to let the platform be more in control\n-        #  so this function can be fully ported to EVMWorld.generate_workspace_files.\n-        blockchain = state.platform\n-\n-        testcase = self._output.testcase(name.replace(' ', '_'))\n-        last_tx = blockchain.last_transaction\n-        if last_tx:\n-            message = message + last_tx.result\n-        logger.info(\"Generated testcase No. {} - {}\".format(testcase.num, message))\n-\n-        local_findings = set()\n-        for detector in self.detectors.values():\n-            for address, pc, finding, at_init, constraint in detector.get_findings(state):\n-                if (address, pc, finding, at_init) not in local_findings:\n-                    local_findings.add((address, pc, finding, at_init, constraint))\n-\n-        if len(local_findings):\n-            with testcase.open_stream('findings') as findings:\n-                for address, pc, finding, at_init, constraint in local_findings:\n-                    findings.write('- %s -\\n' % finding)\n-                    write_findings(findings, '  ', address, pc, at_init)\n-                    md = self.get_metadata(address)\n-                    if md is not None:\n-                        src = md.get_source_for(pc, runtime=not at_init)\n-                        findings.write('  Snippet:\\n')\n-                        findings.write(src.replace('\\n', '\\n    ').strip())\n-                        findings.write('\\n')\n-\n-        with testcase.open_stream('summary') as stream:\n-            is_something_symbolic = state.platform.dump(stream, state, self, message)\n-\n-            with self.locked_context('ethereum') as context:\n-                known_sha3 = context.get('_known_sha3', None)\n-                if known_sha3:\n-                    stream.write(\"Known hashes:\\n\")\n-                    for key, value in known_sha3:\n-                        stream.write('%s::%x\\n' % (binascii.hexlify(key), value))\n-\n-            if is_something_symbolic:\n-                stream.write('\\n\\n(*) Example solution given. Value is symbolic and may take other values\\n')\n-\n-        # Transactions\n-\n-        with testcase.open_stream('tx') as tx_summary:\n-            with testcase.open_stream('tx.json') as txjson:\n-                txlist = []\n-                is_something_symbolic = False\n-\n-                for sym_tx in blockchain.human_transactions:  # external transactions\n-                    tx_summary.write(\"Transactions No. %d\\n\" % blockchain.transactions.index(sym_tx))\n-\n-                    conc_tx = sym_tx.concretize(state)\n-                    txlist.append(conc_tx.to_dict(self))\n-\n-                    is_something_symbolic = sym_tx.dump(tx_summary, state, self, conc_tx=conc_tx)\n-\n-                if is_something_symbolic:\n-                    tx_summary.write('\\n\\n(*) Example solution given. Value is symbolic and may take other values\\n')\n-\n-                json.dump(txlist, txjson)\n-\n-        # logs\n-        with testcase.open_stream('logs') as logs_summary:\n-            is_something_symbolic = False\n-            for log_item in blockchain.logs:\n-                is_log_symbolic = issymbolic(log_item.memlog)\n-                is_something_symbolic = is_log_symbolic or is_something_symbolic\n-                solved_memlog = state.solve_one(log_item.memlog)\n-                printable_bytes = ''.join([c for c in map(chr, solved_memlog) if c in string.printable])\n-\n-                logs_summary.write(\"Address: %x\\n\" % log_item.address)\n-                logs_summary.write(\"Memlog: %s (%s) %s\\n\" % (binascii.hexlify(solved_memlog).decode(), printable_bytes, flagged(is_log_symbolic)))\n-                logs_summary.write(\"Topics:\\n\")\n-                for i, topic in enumerate(log_item.topics):\n-                    logs_summary.write(\"\\t%d) %x %s\" % (i, state.solve_one(topic), flagged(issymbolic(topic))))\n-\n-        with testcase.open_stream('constraints') as smt_summary:\n-            smt_summary.write(str(state.constraints))\n-\n-        with testcase.open_stream('pkl', binary=True) as statef:\n-            self._serializer.serialize(state, statef)\n-\n-        trace = state.context.get('evm.trace')\n-        if trace:\n-            with testcase.open_stream('trace') as f:\n-                self._emit_trace_file(f, trace)\n-        return testcase\n-\n-    @staticmethod\n-    def _emit_trace_file(filestream, trace):\n-        \"\"\"\n-        :param filestream: file object for the workspace trace file\n-        :param trace: list of (contract address, pc) tuples\n-        :type trace: list[tuple(int, int)]\n-        \"\"\"\n-        for contract, pc, at_init in trace:\n-            if pc == 0:\n-                filestream.write('---\\n')\n-            ln = '0x{:x}:0x{:x} {}\\n'.format(contract, pc, '*' if at_init else '')\n-            filestream.write(ln)\n-\n-    @property\n-    def global_findings(self):\n-        global_findings = set()\n-        for detector in self.detectors.values():\n-            for address, pc, finding, at_init in detector.global_findings:\n-                if (address, pc, finding, at_init) not in global_findings:\n-                    global_findings.add((address, pc, finding, at_init))\n-        return global_findings\n-\n-    def finalize(self):\n-        \"\"\"\n-        Terminate and generate testcases for all currently alive states (contract states that cleanly executed\n-        to a STOP or RETURN in the last symbolic transaction).\n-        \"\"\"\n-        logger.debug(\"Finalizing %d states.\", self.count_states())\n-\n-        def finalizer(state_id):\n-            state_id = self._terminate_state_id(state_id)\n-            st = self.load(state_id)\n-            logger.debug(\"Generating testcase for state_id %d\", state_id)\n-            self._generate_testcase_callback(st, 'test', '')\n-\n-        def worker_finalize(q):\n-            try:\n-                while True:\n-                    finalizer(q.get_nowait())\n-            except EmptyQueue:\n-                pass\n-\n-        q = Queue()\n-        for state_id in self._all_state_ids:\n-            #we need to remove -1 state before forking because it may be in memory\n-            if state_id == -1:\n-                finalizer(-1)\n-            else:\n-                q.put(state_id)\n-\n-        report_workers = []\n-        for _ in range(self._config_procs):\n-            proc = Process(target=worker_finalize, args=(q,))\n-            proc.start()\n-            report_workers.append(proc)\n-\n-        for proc in report_workers:\n-            proc.join()\n-\n-        #global summary\n-        if len(self.global_findings):\n-            with self._output.save_stream('global.findings') as global_findings:\n-                for address, pc, finding, at_init in self.global_findings:\n-                    global_findings.write('- %s -\\n' % finding)\n-                    write_findings(global_findings, '  ', address, pc, at_init)\n-                    md = self.get_metadata(address)\n-                    if md is not None:\n-                        source_code_snippet = md.get_source_for(pc, runtime=not at_init)\n-                        global_findings.write('  Solidity snippet:\\n')\n-                        global_findings.write('    '.join(source_code_snippet.splitlines(True)))\n-                        global_findings.write('\\n')\n-\n-        with self._output.save_stream('manticore.yml') as f:\n-            config.save(f)\n-\n-        with self._output.save_stream('global.summary') as global_summary:\n-            # (accounts created by contract code are not in this list )\n-            global_summary.write(\"Global runtime coverage:\\n\")\n-            for address in self.contract_accounts.values():\n-                global_summary.write(\"{:x}: {:2.2f}%\\n\".format(int(address), self.global_coverage(address)))\n-\n-                md = self.get_metadata(address)\n-                if md is not None and len(md.warnings) > 0:\n-                    global_summary.write('\\n\\nCompiler warnings for %s:\\n' % md.name)\n-                    global_summary.write(md.warnings)\n-\n-        for address, md in self.metadata.items():\n-            with self._output.save_stream('global_%s.sol' % md.name) as global_src:\n-                global_src.write(md.source_code)\n-            with self._output.save_stream('global_%s_runtime.bytecode' % md.name, binary=True) as global_runtime_bytecode:\n-                global_runtime_bytecode.write(md.runtime_bytecode)\n-            with self._output.save_stream('global_%s_init.bytecode' % md.name, binary=True) as global_init_bytecode:\n-                global_init_bytecode.write(md.init_bytecode)\n-\n-            with self._output.save_stream('global_%s.runtime_asm' % md.name) as global_runtime_asm:\n-                runtime_bytecode = md.runtime_bytecode\n-\n-                with self.locked_context('runtime_coverage') as seen:\n-\n-                    count, total = 0, 0\n-                    for i in EVMAsm.disassemble_all(runtime_bytecode):\n-                        if (address, i.pc) in seen:\n-                            count += 1\n-                            global_runtime_asm.write('*')\n-                        else:\n-                            global_runtime_asm.write(' ')\n-\n-                        global_runtime_asm.write('%4x: %s\\n' % (i.pc, i))\n-                        total += 1\n-\n-            with self._output.save_stream('global_%s.init_asm' % md.name) as global_init_asm:\n-                with self.locked_context('init_coverage') as seen:\n-                    count, total = 0, 0\n-                    for i in EVMAsm.disassemble_all(md.init_bytecode):\n-                        if (address, i.pc) in seen:\n-                            count += 1\n-                            global_init_asm.write('*')\n-                        else:\n-                            global_init_asm.write(' ')\n-\n-                        global_init_asm.write('%4x: %s\\n' % (i.pc, i))\n-                        total += 1\n-\n-            with self._output.save_stream('global_%s.init_visited' % md.name) as f:\n-                with self.locked_context('init_coverage') as seen:\n-                    visited = set((o for (a, o) in seen if a == address))\n-                    for o in sorted(visited):\n-                        f.write('0x%x\\n' % o)\n-\n-            with self._output.save_stream('global_%s.runtime_visited' % md.name) as f:\n-                with self.locked_context('runtime_coverage') as seen:\n-                    visited = set()\n-                    for (a, o) in seen:\n-                        if a == address:\n-                            visited.add(o)\n-                    for o in sorted(visited):\n-                        f.write('0x%x\\n' % o)\n-\n-        # delete actual streams from storage\n-        for state_id in self._all_state_ids:\n-            # state_id -1 is always only on memory\n-            if state_id != -1:\n-                self._executor._workspace.rm_state(state_id)\n-\n-        # clean up lists\n-        with self.locked_context('ethereum') as eth_context:\n-            eth_context['_saved_states'] = set()\n-            eth_context['_final_states'] = set()\n-\n-        logger.info(\"Results in %s\", self.workspace)\n-\n-    def global_coverage(self, account):\n-        \"\"\" Returns code coverage for the contract on `account_address`.\n-            This sums up all the visited code lines from any of the explored\n-            states.\n-        \"\"\"\n-        account_address = int(account)\n-        runtime_bytecode = None\n-        #Search one state in which the account_address exists\n-        for state in self.all_states:\n-            world = state.platform\n-            if account_address in world:\n-                code = world.get_code(account_address)\n-                runtime_bytecode = state.solve_one(code)\n-                break\n-        else:\n-            return 0.0\n-        with self.locked_context('runtime_coverage') as coverage:\n-            seen = {off for addr, off in coverage if addr == account_address}\n-        return calculate_coverage(runtime_bytecode, seen)\n-\n-    # TODO: Find a better way to suppress execution of Manticore._did_finish_run_callback\n-    # We suppress because otherwise we log it many times and it looks weird.\n-    def _did_finish_run_callback(self):\n-        pass\n-\n-    def __repr__(self):\n-        return self.__str__()\n-\n-    def __str__(self):\n-        return \"<ManticoreEVM | Alive States: {}; Terminated States: {}>\".format(\n-            self.count_running_states(),\n-            self.count_terminated_states()\n-        )\n+from ..exceptions import NoAliveStates, EthereumError\n+from ..platforms import evm\n",
        "source_code_with_indent": "\nlogger = logging.getLogger(__name__)\n\ninit_logging()  # FIXME(mark): emitting a warning in abi.py does not work unless this is called a second time here\n\n\ndef flagged(flag):\n    <IND>\"\"\"\n    Return special character denoting concretization happened.\n    \"\"\"\n    return '(*)' if flag else ''\n\n\n<DED>def write_findings(method, lead_space, address, pc, at_init=\"\"):\n    <IND>\"\"\"\n    Writes contract address and EVM program counter indicating whether counter was read at constructor\n    :param method: pointer to the object with the write method\n    :param lead_space: leading white space\n    :param address: contract address\n    :param pc: program counter\n    :param at_init: Boolean\n    :return: pass\n    \"\"\"\n    method.write(f'{lead_space}Contract: 0x:{address}')\n    method.write(f'{lead_space}EVM Program counter: 0x{pc}{\" (at constructor)\" if at_init else \"\"}\\n')\n\n#\n# Plugins\n#\n\n\n<DED>class FilterFunctions(Plugin):\n    <IND>def __init__(self, regexp=r'.*', mutability='both', depth='both', fallback=False, include=True, **kwargs):\n        <IND>\"\"\"\n            Constrain input based on function metadata. Include or avoid functions selected by the specified criteria.\n\n            Examples:\n            #Do not explore any human transactions that end up calling a constant function\n            no_human_constant = FilterFunctions(depth='human', mutability='constant', include=False)\n\n            #At human tx depth only accept synthetic check functions\n            only_tests = FilterFunctions(regexp=r'mcore_.*', depth='human', include=False)\n\n            :param regexp: a regular expression over the name of the function '.*' will match all functions\n            :param mutability: mutable, constant or both will match functions declared in the abi to be of such class\n            :param depth: match functions in internal transactions, in human initiated transactions or in both types\n            :param fallback: if True include the fallback function. Hash will be 00000000 for it\n            :param include: if False exclude the selected functions, if True include them\n        \"\"\"\n        super().__init__(**kwargs)\n        depth = depth.lower()\n        if depth not in ('human', 'internal', 'both'):\n            <IND>raise ValueError\n        <DED>mutability = mutability.lower()\n        if mutability not in ('mutable', 'constant', 'both'):\n            <IND>raise ValueError\n\n        #fixme better names for member variables\n        <DED>self._regexp = regexp\n        self._mutability = mutability\n        self._depth = depth\n        self._fallback = fallback\n        self._include = include\n\n    <DED>def will_open_transaction_callback(self, state, tx):\n        <IND>world = state.platform\n        tx_cnt = len(world.all_transactions)\n        # Constrain input only once per tx, per plugin\n        if state.context.get('constrained%d' % id(self), 0) != tx_cnt:\n            <IND>state.context['constrained%d' % id(self)] = tx_cnt\n\n            if self._depth == 'human' and not tx.is_human:\n                <IND>return\n            <DED>if self._depth == 'internal' and tx.is_human:\n                <IND>return\n\n            #Get metadata if any for the target address of current tx\n            <DED>md = self.manticore.get_metadata(tx.address)\n            if md is None:\n                <IND>return\n            #Let's compile  the list of interesting hashes\n            <DED>selected_functions = []\n\n            for func_hsh in md.function_selectors:\n                <IND>abi = md.get_abi(func_hsh)\n                if abi['type'] == 'fallback':\n                    <IND>continue\n                <DED>if self._mutability == 'constant' and not abi.get('constant', False):\n                    <IND>continue\n                <DED>if self._mutability == 'mutable' and abi.get('constant', False):\n                    <IND>continue\n                <DED>if not re.match(self._regexp, abi['name']):\n                    <IND>continue\n                <DED>selected_functions.append(func_hsh)\n\n            <DED>if self._fallback and md.has_non_default_fallback_function:\n                <IND>selected_functions.append(md.fallback_function_selector)\n\n            <DED>if self._include:\n                # constrain the input so it can take only the interesting values\n                <IND>constraint = reduce(Operators.OR, (tx.data[:4] == x for x in selected_functions))\n                state.constrain(constraint)\n            <DED>else:\n                #Avoid all not selected hashes\n                <IND>for func_hsh in md.function_selectors:\n                    <IND>if func_hsh in selected_functions:\n                        <IND>constraint = tx.data[:4] != func_hsh\n                        state.constrain(constraint)\n\n\n<DED><DED><DED><DED><DED><DED>class LoopDepthLimiter(Plugin):\n    <IND>''' This just aborts explorations that are too deep '''\n\n    def __init__(self, loop_count_threshold=5, **kwargs):\n        <IND>super().__init__(**kwargs)\n        self.loop_count_threshold = loop_count_threshold\n\n    <DED>def will_start_run_callback(self, *args):\n        <IND>with self.manticore.locked_context('seen_rep', dict) as reps:\n            <IND>reps.clear()\n\n    <DED><DED>def will_execute_instruction_callback(self, state, pc, insn):\n        <IND>world = state.platform\n        with self.manticore.locked_context('seen_rep', dict) as reps:\n            <IND>item = (world.current_transaction.sort == 'CREATE', world.current_transaction.address, pc)\n            if item not in reps:\n                <IND>reps[item] = 0\n            <DED>reps[item] += 1\n            if reps[item] > self.loop_count_threshold:\n                <IND>state.abandon()\n\n\n<DED><DED><DED><DED>class VerboseTrace(Plugin):\n    <IND>def will_evm_execute_instruction_callback(self, state, instruction, arguments):\n        <IND>current_vm = state.platform.current_vm\n        state.setdefault('str_trace', []).append(str(current_vm))\n\n    <DED>def on_finalize(self, state, testcase):\n        <IND>with testcase.open_stream('str_trace') as str_trace_f:\n            <IND>str_trace_f.write('\\n'.join(state.context.get('str_trace', [])))\n\n\n<DED><DED><DED>def calculate_coverage(runtime_bytecode, seen):\n    <IND>\"\"\" Calculates what percentage of runtime_bytecode has been seen \"\"\"\n    count, total = 0, 0\n    bytecode = SolidityMetadata._without_metadata(runtime_bytecode)\n    for i in EVMAsm.disassemble_all(bytecode):\n        <IND>if i.pc in seen:\n            <IND>count += 1\n        <DED>total += 1\n\n    <DED>if total == 0:\n        #No runtime_bytecode\n        <IND>return 0\n    <DED>return count * 100.0 / total\n\n\n<DED>class ManticoreEVM(Manticore):\n    <IND>\"\"\" Manticore EVM manager\n\n        Usage Ex::\n\n            from manticore.ethereum import ManticoreEVM, ABI\n            m = ManticoreEVM()\n            #And now make the contract account to analyze\n            source_code = '''\n                pragma solidity ^0.4.15;\n                contract AnInt {\n                    uint private i=0;\n                    function set(uint value){\n                        i=value\n                    }\n                }\n            '''\n            #Initialize user and contracts\n            user_account = m.create_account(balance=1000)\n            contract_account = m.solidity_create_contract(source_code, owner=user_account, balance=0)\n            contract_account.set(12345, value=100)\n\n            m.finalize()\n    \"\"\"\n\n    def make_symbolic_buffer(self, size, name=None):\n        <IND>\"\"\" Creates a symbolic buffer of size bytes to be used in transactions.\n            You can operate on it normally and add constraints to manticore.constraints\n            via manticore.constrain(constraint_expression)\n\n            Example use::\n\n                symbolic_data = m.make_symbolic_buffer(320)\n                m.constrain(symbolic_data[0] == 0x65)\n                m.transaction(caller=attacker_account,\n                                address=contract_account,\n                                data=symbolic_data,\n                                value=100000 )\n        \"\"\"\n        avoid_collisions = False\n        if name is None:\n            <IND>name = 'TXBUFFER'\n            avoid_collisions = True\n        <DED>return self.constraints.new_array(index_bits=256, name=name, index_max=size, value_bits=8, taint=frozenset(), avoid_collisions=avoid_collisions)\n\n    <DED>def make_symbolic_value(self, nbits=256, name=None):\n        <IND>\"\"\" Creates a symbolic value, normally a uint256, to be used in transactions.\n            You can operate on it normally and add constraints to manticore.constraints\n            via manticore.constrain(constraint_expression)\n\n            Example use::\n\n                symbolic_value = m.make_symbolic_value()\n                m.constrain(symbolic_value > 100)\n                m.constrain(symbolic_value < 1000)\n                m.transaction(caller=attacker_account,\n                                address=contract_account,\n                                data=data,\n                                value=symbolic_value )\n\n        \"\"\"\n        avoid_collisions = False\n        if name is None:\n            <IND>name = 'TXVALUE'\n            avoid_collisions = True\n        <DED>return self.constraints.new_bitvec(nbits, name=name, avoid_collisions=avoid_collisions)\n\n    <DED>def make_symbolic_address(self, name=None, select='both'):\n        <IND>if select not in ('both', 'normal', 'contract'):\n            <IND>raise EthereumError('Wrong selection type')\n        <DED>if select in ('normal', 'contract'):\n            # FIXME need to select contracts or normal accounts\n            <IND>raise NotImplemented\n        <DED>avoid_collisions = False\n        if name is None:\n            <IND>name = 'TXADDR'\n            avoid_collisions = True\n        <DED>return self.constraints.new_bitvec(160, name=name, avoid_collisions=avoid_collisions)\n\n        constraint = symbolic_address == 0\n        for contract_account_i in map(int, self._accounts.values()):\n            <IND>constraint = Operators.OR(symbolic_address == contract_account_i, constraint)\n        <DED>self.constrain(constraint)\n        return symbolic_address\n\n    <DED>def constrain(self, constraint):\n        <IND>if self.count_states() == 0:\n            <IND>self.constraints.add(constraint)\n        <DED>else:\n            <IND>for state in self.all_states:\n                <IND>state.constrain(constraint)\n\n    <DED><DED><DED>@staticmethod\n    def compile(source_code, contract_name=None, libraries=None, runtime=False, solc_bin=None, solc_remaps=[]):\n        <IND>\"\"\" Get initialization bytecode from a Solidity source code \"\"\"\n        name, source_code, init_bytecode, runtime_bytecode, srcmap, srcmap_runtime, hashes, abi, warnings = ManticoreEVM._compile(source_code, contract_name, libraries, solc_bin, solc_remaps)\n        if runtime:\n            <IND>return runtime_bytecode\n        <DED>return init_bytecode\n\n    <DED>@staticmethod\n    def _link(bytecode, libraries=None):\n        <IND>has_dependencies = '_' in bytecode\n        hex_contract = bytecode\n        if has_dependencies:\n            <IND>deps = {}\n            pos = 0\n            while pos < len(hex_contract):\n                <IND>if hex_contract[pos] == '_':\n                    # __/tmp/tmp_9k7_l:Manticore______________\n                    <IND>lib_placeholder = hex_contract[pos:pos + 40]\n                    lib_name = lib_placeholder.split(':')[1].split('_')[0]\n                    deps.setdefault(lib_name, []).append(pos)\n                    pos += 40\n                <DED>else:\n                    <IND>pos += 2\n\n            <DED><DED>if libraries is None:\n                <IND>raise DependencyError(deps.keys())\n            <DED>libraries = dict(libraries)\n            hex_contract_lst = list(hex_contract)\n            for lib_name, pos_lst in deps.items():\n                <IND>try:\n                    <IND>lib_address = libraries[lib_name]\n                <DED>except KeyError:\n                    <IND>raise DependencyError([lib_name])\n                <DED>for pos in pos_lst:\n                    <IND>hex_contract_lst[pos:pos + 40] = '%040x' % int(lib_address)\n            <DED><DED>hex_contract = ''.join(hex_contract_lst)\n        <DED>return bytearray(binascii.unhexlify(hex_contract))\n\n    <DED>@staticmethod\n    def _run_solc(source_file, solc_bin=None, solc_remaps=[], working_dir=None):\n        <IND>\"\"\" Compile a source file with the Solidity compiler\n\n            :param source_file: a file object for the source file\n            :param solc_bin: path to solc binary\n            :param solc_remaps: solc import remaps\n            :return: output, warnings\n        \"\"\"\n        if solc_bin is not None:\n            <IND>solc = solc_bin\n        <DED>else:\n            <IND>solc = \"solc\"\n\n        #check solc version\n        <DED>supported_versions = ('0.4.18', '0.4.21')\n\n        try:\n            <IND>installed_version_output = check_output([solc, \"--version\"])\n        <DED>except OSError:\n            <IND>raise EthereumError(\"Solidity compiler not installed.\")\n\n        <DED>m = re.match(r\".*Version: (?P<version>(?P<major>\\d+)\\.(?P<minor>\\d+)\\.(?P<build>\\d+)).*\\+(?P<commit>[^\\s]+).*\", installed_version_output.decode(), re.DOTALL | re.IGNORECASE)\n\n        if not m or m.groupdict()['version'] not in supported_versions:\n            #Fixme https://github.com/trailofbits/manticore/issues/847\n            #logger.warning(\"Unsupported solc version %s\", installed_version)\n            <IND>pass\n\n        # solc path search is a mess\n        # https://solidity.readthedocs.io/en/latest/layout-of-source-files.html\n\n        <DED>relative_filepath = source_file.name\n\n        if not working_dir:\n            <IND>working_dir = os.getcwd()\n        <DED>elif relative_filepath.startswith(working_dir):\n            <IND>relative_filepath = relative_filepath[len(working_dir) + 1:]\n\n        # If someone pass an absolute path to the file, we don't have to put cwd\n        <DED>additional_kwargs = {'cwd': working_dir} if working_dir else {}\n\n        solc_invocation = [solc] + list(solc_remaps) + [\n            '--combined-json', 'abi,srcmap,srcmap-runtime,bin,hashes,bin-runtime',\n            '--allow-paths', '.',\n            relative_filepath\n        ]\n\n        p = Popen(solc_invocation, stdout=PIPE, stderr=PIPE, **additional_kwargs)\n        stdout, stderr = p.communicate()\n\n        stdout, stderr = stdout.decode(), stderr.decode()\n\n        # See #1123 - solc fails when run within snap\n        # and https://forum.snapcraft.io/t/interfaces-allow-access-tmp-directory/5129\n        if stdout == '' and f'\"\"{relative_filepath}\"\" is not found' in stderr:\n            <IND>raise EthereumError(\n                'Solidity compilation failed with error: {}\\n'\n                'Did you install solc from snap Linux universal packages?\\n'\n                \"If so, the problem is likely due to snap's sandbox restricting access to /tmp\\n\"\n                '\\n'\n                'Here are some potential solutions:\\n'\n                ' 1) Remove solc from snap and install it different way\\n'\n                ' 2) Reinstall solc from snap in developer mode, so there is no sandbox\\n'\n                \" 3) Find a way to add /tmp to the solc's sandbox. If you do, \"\n                \"send us a PR so we could add it here!\".format(stderr)\n            )\n\n        <DED>try:\n            <IND>return json.loads(stdout), stderr\n        <DED>except ValueError:\n            <IND>raise EthereumError('Solidity compilation error:\\n\\n{}'.format(stderr))\n\n    <DED><DED>@staticmethod\n    def _compile(source_code, contract_name, libraries=None, solc_bin=None, solc_remaps=[], working_dir=None):\n        <IND>\"\"\" Compile a Solidity contract, used internally\n\n            :param source_code: solidity source as either a string or a file handle\n            :param contract_name: a string with the name of the contract to analyze\n            :param libraries: an itemizable of pairs (library_name, address)\n            :param solc_bin: path to solc binary\n            :param solc_remaps: solc import remaps\n            :param working_dir: working directory for solc compilation (defaults to current)\n            :return: name, source_code, bytecode, srcmap, srcmap_runtime, hashes\n            :return: name, source_code, bytecode, runtime, srcmap, srcmap_runtime, hashes, abi, warnings\n        \"\"\"\n\n        if isinstance(source_code, str):\n            <IND>with tempfile.NamedTemporaryFile('w+') as temp:\n                <IND>temp.write(source_code)\n                temp.flush()\n                output, warnings = ManticoreEVM._run_solc(temp, solc_bin, solc_remaps, working_dir=working_dir)\n        <DED><DED>elif isinstance(source_code, io.IOBase):\n            <IND>output, warnings = ManticoreEVM._run_solc(source_code, solc_bin, solc_remaps, working_dir=working_dir)\n            source_code.seek(0)\n            source_code = source_code.read()\n        <DED>else:\n            <IND>raise TypeError(f'source code bad type: {type(source_code).__name__}')\n\n        <DED>contracts = output.get('contracts', [])\n        if len(contracts) != 1 and contract_name is None:\n            <IND>raise EthereumError('Solidity file must contain exactly one contract or you must use a contract parameter to specify one.')\n\n        <DED>name, contract = None, None\n        if contract_name is None:\n            <IND>name, contract = list(contracts.items())[0]\n        <DED>else:\n            <IND>for n, c in contracts.items():\n                <IND>if n.split(\":\")[1] == contract_name:\n                    <IND>name, contract = n, c\n                    break\n\n        <DED><DED><DED>if name is None:\n            <IND>raise ValueError('Specified contract not found')\n\n        <DED>name = name.split(':')[1]\n\n        if contract['bin'] == '':\n            <IND>raise EthereumError('Solidity failed to compile your contract.')\n\n        <DED>bytecode = ManticoreEVM._link(contract['bin'], libraries)\n        srcmap = contract['srcmap'].split(';')\n        srcmap_runtime = contract['srcmap-runtime'].split(';')\n        hashes = {str(x): str(y) for x, y in contract['hashes'].items()}\n        abi = json.loads(contract['abi'])\n        runtime = ManticoreEVM._link(contract['bin-runtime'], libraries)\n        return name, source_code, bytecode, runtime, srcmap, srcmap_runtime, hashes, abi, warnings\n\n    <DED>@property\n    def accounts(self):\n        <IND>return dict(self._accounts)\n\n    <DED>def account_name(self, address):\n        <IND>for name, account in self._accounts.items():\n            <IND>if account.address == address:\n                <IND>return name\n        <DED><DED>return '0x{:x}'.format(address)\n\n    <DED>@property\n    def normal_accounts(self):\n        <IND>return {name: account for name, account in self._accounts.items() if not isinstance(account, EVMContract)}\n\n    <DED>@property\n    def contract_accounts(self):\n        <IND>return {name: account for name, account in self._accounts.items() if isinstance(account, EVMContract)}\n\n    <DED>def get_account(self, name):\n        <IND>return self._accounts[name]\n\n    <DED>def __init__(self, procs=10, workspace_url: str=None, policy: str='random'):\n        <IND>\"\"\"\n        A Manticore EVM manager\n        :param procs:, number of workers to use in the exploration\n        :param workspace_url: workspace folder name\n        :param policy: scheduling priority\n        \"\"\"\n        self._accounts = dict()\n        self._serializer = PickleSerializer()\n\n        self._config_procs = procs\n        # Make the constraint store\n        constraints = ConstraintSet()\n        # make the ethereum world state\n        world = evm.EVMWorld(constraints, initial_timestamp=1524785992)\n        initial_state = State(constraints, world)\n        super().__init__(initial_state, workspace_url=workspace_url, policy=policy)\n\n        self.constraints = ConstraintSet()\n        self.detectors = {}\n        self.metadata: Dict[int, SolidityMetadata] = {}\n\n        # The following should go to manticore.context so we can use multiprocessing\n        self.context['ethereum'] = {}\n        self.context['ethereum']['_saved_states'] = set()\n        self.context['ethereum']['_final_states'] = set()\n        self.context['ethereum']['_completed_transactions'] = 0\n        self.context['ethereum']['_sha3_states'] = dict()\n        self.context['ethereum']['_known_sha3'] = set()\n\n        self._executor.subscribe('did_load_state', self._load_state_callback)\n        self._executor.subscribe('will_terminate_state', self._terminate_state_callback)\n        self._executor.subscribe('did_evm_execute_instruction', self._did_evm_execute_instruction_callback)\n        self._executor.subscribe('did_read_code', self._did_evm_read_code)\n        self._executor.subscribe('on_symbolic_sha3', self._on_symbolic_sha3_callback)\n        self._executor.subscribe('on_concrete_sha3', self._on_concrete_sha3_callback)\n\n    <DED>@property\n    def world(self):\n        <IND>\"\"\" The world instance or None if there is more than one state \"\"\"\n        return self.get_world()\n\n    <DED>@property\n    def completed_transactions(self):\n        <IND>with self.locked_context('ethereum') as context:\n            <IND>return context['_completed_transactions']\n\n    <DED><DED>@property\n    def _running_state_ids(self):\n        <IND>\"\"\" IDs of the running states\"\"\"\n        with self.locked_context('ethereum') as context:\n            <IND>if self.initial_state is not None:\n                <IND>return (-1,) + tuple(context['_saved_states'])\n            <DED>else:\n                <IND>return tuple(context['_saved_states'])\n\n    <DED><DED><DED>@property\n    def _terminated_state_ids(self):\n        <IND>\"\"\" IDs of the terminated states \"\"\"\n        with self.locked_context('ethereum') as context:\n            <IND>return tuple(context['_final_states'])\n\n    <DED><DED>@property\n    def _all_state_ids(self):\n        <IND>\"\"\" IDs of the all states\n\n            Note: state with id -1 is already in memory and it is not backed on the storage\n        \"\"\"\n        return self._running_state_ids + self._terminated_state_ids\n\n    <DED>@property\n    def running_states(self):\n        <IND>\"\"\" Iterates over the running states\"\"\"\n        for state_id in self._running_state_ids:\n            <IND>state = self.load(state_id)\n            yield state\n            self.save(state, state_id=state_id)  # overwrite old\n\n    <DED><DED>@property\n    def terminated_states(self):\n        <IND>\"\"\" Iterates over the terminated states\"\"\"\n        for state_id in self._terminated_state_ids:\n            <IND>state = self.load(state_id)\n            yield state\n            self.save(state, state_id=state_id)  # overwrite old\n\n    <DED><DED>@property\n    def all_states(self):\n        <IND>\"\"\" Iterates over the all states (terminated and alive)\"\"\"\n        for state_id in self._all_state_ids:\n            <IND>state = self.load(state_id)\n            yield state\n            self.save(state, state_id=state_id)  # overwrite old\n\n    <DED><DED>def count_states(self):\n        <IND>\"\"\" Total states count \"\"\"\n        return len(self._all_state_ids)\n\n    <DED>def count_running_states(self):\n        <IND>\"\"\" Running states count \"\"\"\n        return len(self._running_state_ids)\n\n    <DED>def count_terminated_states(self):\n        <IND>\"\"\" Terminated states count \"\"\"\n        return len(self._terminated_state_ids)\n\n    <DED>def _terminate_state_id(self, state_id):\n        <IND>\"\"\" Manually terminates a states by state_id.\n            Moves the state from the running list into the terminated list\n        \"\"\"\n\n        if state_id != -1:\n            # Move state from running to final\n            <IND>with self.locked_context('ethereum') as eth_context:\n                <IND>saved_states = eth_context['_saved_states']\n                final_states = eth_context['_final_states']\n                if state_id in saved_states:\n                    <IND>saved_states.remove(state_id)\n                    final_states.add(state_id)\n                    eth_context['_saved_states'] = saved_states  # TODO This two may be not needed in py3?\n                    eth_context['_final_states'] = final_states\n        <DED><DED><DED>else:\n            <IND>assert state_id == -1\n            state_id = self.save(self._initial_state, final=True)\n            self._initial_state = None\n        <DED>return state_id\n\n    <DED>def _revive_state_id(self, state_id):\n        <IND>\"\"\" Manually revive a state by state_id.\n            Moves the state from the final list into the running list\n        \"\"\"\n\n        # Move state from final to running\n        if state_id != -1:\n            <IND>with self.locked_context('ethereum') as eth_context:\n                <IND>saved_states = eth_context['_saved_states']\n                final_states = eth_context['_final_states']\n                if state_id in final_states:\n                    <IND>final_states.remove(state_id)\n                    saved_states.add(state_id)\n                    eth_context['_saved_states'] = saved_states\n                    eth_context['_final_states'] = final_states\n        <DED><DED><DED>return state_id\n\n    # deprecate this 5 in favor of for sta in m.all_states: do stuff?\n\n    <DED>def get_world(self, state_id=None):\n        <IND>\"\"\" Returns the evm world of `state_id` state. \"\"\"\n        state = self.load(state_id)\n        if state is None:\n            <IND>return None\n        <DED>else:\n            <IND>return state.platform\n\n    <DED><DED>def get_balance(self, address, state_id=None):\n        <IND>\"\"\" Balance for account `address` on state `state_id` \"\"\"\n        if isinstance(address, EVMAccount):\n            <IND>address = int(address)\n        <DED>return self.get_world(state_id).get_balance(address)\n\n    <DED>def get_storage_data(self, address, offset, state_id=None):\n        <IND>\"\"\" Storage data for `offset` on account `address` on state `state_id` \"\"\"\n        if isinstance(address, EVMAccount):\n            <IND>address = int(address)\n        <DED>return self.get_world(state_id).get_storage_data(address, offset)\n\n    <DED>def get_code(self, address, state_id=None):\n        <IND>\"\"\" Storage data for `offset` on account `address` on state `state_id` \"\"\"\n        if isinstance(address, EVMAccount):\n            <IND>address = int(address)\n        <DED>return self.get_world(state_id).get_code(address)\n\n    <DED>def last_return(self, state_id=None):\n        <IND>\"\"\" Last returned buffer for state `state_id` \"\"\"\n        state = self.load(state_id)\n        return state.platform.last_return_data\n\n    <DED>def transactions(self, state_id=None):\n        <IND>\"\"\" Transactions list for state `state_id` \"\"\"\n        state = self.load(state_id)\n        return state.platform.transactions\n\n    <DED>def human_transactions(self, state_id=None):\n        <IND>\"\"\" Transactions list for state `state_id` \"\"\"\n        state = self.load(state_id)\n        return state.platform.human_transactions\n\n    <DED>def make_symbolic_arguments(self, types):\n        <IND>\"\"\"\n            Make a reasonable serialization of the symbolic argument types\n        \"\"\"\n        # FIXME this is more naive than reasonable.\n        return ABI.deserialize(types, self.make_symbolic_buffer(32, name=\"INITARGS\"))\n\n    <DED>def solidity_create_contract(self, source_code, owner, name=None, contract_name=None, libraries=None,\n                                 balance=0, address=None, args=(), solc_bin=None, solc_remaps=[],\n                                 working_dir=None, gas=90000):\n        <IND>\"\"\" Creates a solidity contract and library dependencies\n\n            :param str source_code: solidity source code\n            :param owner: owner account (will be default caller in any transactions)\n            :type owner: int or EVMAccount\n            :param contract_name: Name of the contract to analyze (optional if there is a single one in the source code)\n            :type contract_name: str\n            :param balance: balance to be transferred on creation\n            :type balance: int or SValue\n            :param address: the address for the new contract (optional)\n            :type address: int or EVMAccount\n            :param tuple args: constructor arguments\n            :param solc_bin: path to solc binary\n            :type solc_bin: str\n            :param solc_remaps: solc import remaps\n            :type solc_remaps: list of str\n            :param working_dir: working directory for solc compilation (defaults to current)\n            :type working_dir: str\n            :param gas: gas budget for each contract creation needed (may be more than one if several related contracts defined in the solidity source)\n            :type gas: int\n            :rtype: EVMAccount\n        \"\"\"\n        if libraries is None:\n            <IND>deps = {}\n        <DED>else:\n            <IND>deps = dict(libraries)\n\n        <DED>contract_names = [contract_name]\n        while contract_names:\n            <IND>contract_name_i = contract_names.pop()\n            try:\n                <IND>compile_results = self._compile(source_code, contract_name_i,\n                                                libraries=deps, solc_bin=solc_bin, solc_remaps=solc_remaps,\n                                                working_dir=working_dir)\n                md = SolidityMetadata(*compile_results)\n                if contract_name_i == contract_name:\n                    <IND>constructor_types = md.get_constructor_arguments()\n                    if args is None:\n                        <IND>args = self.make_symbolic_arguments(constructor_types)\n                    <DED>contract_account = self.create_contract(owner=owner,\n                                                            balance=balance,\n                                                            address=address,\n                                                            init=md._init_bytecode + ABI.serialize(constructor_types, *args),\n                                                            name=name,\n                                                            gas=gas)\n                <DED>else:\n                    <IND>contract_account = self.create_contract(owner=owner, init=md._init_bytecode)\n\n                <DED>if contract_account is None:\n                    <IND>raise EthereumError(\"Failed to build contract %s\" % contract_name_i)\n                <DED>self.metadata[int(contract_account)] = md\n\n                deps[contract_name_i] = contract_account\n            <DED>except DependencyError as e:\n                <IND>contract_names.append(contract_name_i)\n                for lib_name in e.lib_names:\n                    <IND>if lib_name not in deps:\n                        <IND>contract_names.append(lib_name)\n\n        <DED><DED><DED><DED>if not self.count_running_states() or len(self.get_code(contract_account)) == 0:\n            <IND>return None\n        <DED>return contract_account\n\n    <DED>def get_nonce(self, address):\n        # type forgiveness:\n        <IND>address = int(address)\n        # get all nonces for states containing this address:\n        nonces = set(state.platform.get_nonce(address) for state in self.running_states if address in state.platform)\n        if not nonces:\n            <IND>raise NoAliveStates(\"There are no alive states containing address %x\" % address)\n        <DED>elif len(nonces) != 1:\n            # if there are multiple states with this address, they all have to have the same nonce:\n            <IND>raise EthereumError(\"Cannot increase the nonce of address %x because it exists in multiple states with different nonces\" % address)\n        <DED>else:\n            <IND>return next(iter(nonces))\n\n    <DED><DED>def create_contract(self, owner, balance=0, address=None, init=None, name=None, gas=21000):\n        <IND>\"\"\" Creates a contract\n\n            :param owner: owner account (will be default caller in any transactions)\n            :type owner: int or EVMAccount\n            :param balance: balance to be transferred on creation\n            :type balance: int or SValue\n            :param int address: the address for the new contract (optional)\n            :param str init: initializing evm bytecode and arguments\n            :param str name: a unique name for reference\n            :param gas: gas budget for the creation/initialization of the contract\n            :rtype: EVMAccount\n        \"\"\"\n        if not self.count_running_states():\n            <IND>raise NoAliveStates\n\n        <DED>nonce = self.get_nonce(owner)\n        expected_address = evm.EVMWorld.calculate_new_address(int(owner), nonce=nonce)\n\n        if address is None:\n            <IND>address = expected_address\n        <DED>elif address != expected_address:\n            <IND>raise EthereumError(\"Address was expected to be %x but was given %x\" % (expected_address, address))\n\n        # Name check\n        <DED>if name is None:\n            <IND>name = self._get_uniq_name(\"contract\")\n        <DED>if name in self._accounts:\n            # Account name already used\n            <IND>raise EthereumError(\"Name already used\")\n\n        <DED>self._transaction('CREATE', owner, balance, address, data=init, gaslimit=gas)\n        # TODO detect failure in the constructor\n\n        self._accounts[name] = EVMContract(address=address, manticore=self, default_caller=owner, name=name)\n        return self.accounts[name]\n\n    <DED>def _get_uniq_name(self, stem):\n        <IND>count = 0\n        for name_i in self.accounts.keys():\n            <IND>if name_i.startswith(stem):\n                <IND>try:\n                    <IND>count = max(count, int(name_i[len(stem):]) + 1)\n                <DED>except:\n                    <IND>pass\n        <DED><DED><DED>name = \"{:s}{:d}\".format(stem, count)\n        assert name not in self.accounts\n        return name\n\n    <DED>def _all_addresses(self):\n        <IND>\"\"\" Returns all addresses in all running states \"\"\"\n        ret = set()\n        for state in self.running_states:\n            <IND>ret |= set(state.platform.accounts)\n        <DED>return ret\n\n    <DED>def new_address(self):\n        <IND>\"\"\" Create a fresh 160bit address \"\"\"\n        all_addresses = self._all_addresses()\n        while True:\n            <IND>new_address = random.randint(100, pow(2, 160))\n            if new_address not in all_addresses:\n                <IND>return new_address\n\n    <DED><DED><DED>def transaction(self, caller, address, value, data, gas=21000):\n        <IND>\"\"\" Issue a symbolic transaction in all running states\n\n            :param caller: the address of the account sending the transaction\n            :type caller: int or EVMAccount\n            :param address: the address of the contract to call\n            :type address: int or EVMAccount\n            :param value: balance to be transfered on creation\n            :type value: int or SValue\n            :param data: initial data\n            :param gas: gas budget\n            :raises NoAliveStates: if there are no alive states to execute\n        \"\"\"\n        self._transaction('CALL', caller, value=value, address=address, data=data, gaslimit=gas)\n\n    <DED>def create_account(self, balance=0, address=None, code=None, name=None):\n        <IND>\"\"\" Low level creates an account. This won't generate a transaction.\n\n            :param balance: balance to be set on creation (optional)\n            :type balance: int or SValue\n            :param address: the address for the new account (optional)\n            :type address: int\n            :param code: the runtime code for the new account (None means normal account) (optional)\n            :param name: a global account name eg. for use as reference in the reports (optional)\n            :return: an EVMAccount\n        \"\"\"\n        # Need at least one state where to apply this\n        if not self.count_running_states():\n            <IND>raise NoAliveStates\n\n        # Name check\n        <DED>if name is None:\n            <IND>if code is None:\n                <IND>name = self._get_uniq_name(\"normal\")\n            <DED>else:\n                <IND>name = self._get_uniq_name(\"contract\")\n        <DED><DED>if name in self._accounts:\n            # Account name already used\n            <IND>raise EthereumError(\"Name already used\")\n\n        #Balance check\n        <DED>if not isinstance(balance, int):\n            <IND>raise EthereumError(\"Balance invalid type\")\n\n        <DED>if isinstance(code, str):\n            <IND>code = bytearray(code)\n        <DED>if code is not None and not isinstance(code, (bytearray, Array)):\n            <IND>raise EthereumError(\"code bad type\")\n\n        # Address check\n        # Let's just choose the address ourself. This is not yellow paper material\n        <DED>if address is None:\n            <IND>address = self.new_address()\n        <DED>if not isinstance(address, int):\n            <IND>raise EthereumError(\"A concrete address is needed\")\n        <DED>assert address is not None\n        if address in map(int, self.accounts.values()):\n            # Address already used\n            <IND>raise EthereumError(\"Address already used\")\n\n        # To avoid going full crazy we maintain a global list of addresses\n        # Different states may CREATE a different set of accounts.\n        # Accounts created by a human have the same address in all states.\n        <DED>for state in self.running_states:\n            <IND>world = state.platform\n\n            if '_pending_transaction' in state.context:\n                <IND>raise EthereumError(\"This is bad. There should not be a pending transaction\")\n\n            <DED>if address in world.accounts:\n                # Address already used\n                <IND>raise EthereumError(\"This is bad. Same address is used for different contracts in different states\")\n            <DED>world.create_account(address, balance, code=code, storage=None)\n\n        <DED>self._accounts[name] = EVMAccount(address, manticore=self, name=name)\n        return self.accounts[name]\n\n    <DED>def _migrate_tx_expressions(self, state, caller, address, value, data):\n            # Copy global constraints into each state.\n            # We should somehow remember what has been copied to each state\n            # In a second transaction we should only add new constraints.\n            # And actually only constraints related to whatever we are using in\n            # the tx. This is a FIXME\n            <IND>global_constraints = self.constraints\n\n            # Normally users will be making these symbolic expressions by creating\n            # global symbolic variables via ManticoreEVM.make_.... and those\n            # global expressions need to be imported into each state when a tx\n            # actually happens\n\n            if issymbolic(caller):\n                <IND>caller = state.migrate_expression(caller)\n\n            <DED>if issymbolic(address):\n                <IND>address = state.migrate_expression(address)\n\n            <DED>if issymbolic(value):\n                <IND>value = state.migrate_expression(value)\n\n            <DED>if issymbolic(data):\n                <IND>if isinstance(data, ArrayProxy):  # FIXME is this necessary here?\n                    <IND>data = data.array\n                <DED>data = state.migrate_expression(data)\n                if isinstance(data, Array):\n                    <IND>data = ArrayProxy(data)\n\n            <DED><DED>for c in global_constraints:\n                <IND>state.constrain(c)\n\n            <DED>return caller, address, value, data\n\n    <DED>def _transaction(self, sort, caller, value=0, address=None, data=None, gaslimit=0, price=1):\n        <IND>\"\"\" Initiates a transaction\n\n            :param caller: caller account\n            :type caller: int or EVMAccount\n            :param int address: the address for the transaction (optional)\n            :param value: value to be transferred\n            :param price: the price of gas for this transaction. Mostly unused.\n            :type value: int or SValue\n            :param str data: initializing evm bytecode and arguments or transaction call data\n            :param gaslimit: gas budget\n            :rtype: EVMAccount\n        \"\"\"\n        #Type Forgiveness\n        if isinstance(address, EVMAccount):\n            <IND>address = int(address)\n        <DED>if isinstance(caller, EVMAccount):\n            <IND>caller = int(caller)\n        #Defaults, call data is empty\n        <DED>if data is None:\n            <IND>data = bytearray(b\"\")\n        <DED>if isinstance(data, (str, bytes)):\n            <IND>data = bytearray(data)\n        <DED>if not isinstance(data, (bytearray, Array)):\n            <IND>raise TypeError(\"code bad type\")\n\n        # Check types\n        <DED>if not isinstance(caller, (int, BitVec)):\n            <IND>raise TypeError(\"Caller invalid type\")\n\n        <DED>if not isinstance(value, (int, BitVec)):\n            <IND>raise TypeError(\"Value invalid type\")\n\n        <DED>if not isinstance(address, (int, BitVec)):\n            <IND>raise TypeError(\"address invalid type\")\n\n        <DED>if not isinstance(price, int):\n            <IND>raise TypeError(\"Price invalid type\")\n\n        # Check argument consistency and set defaults ...\n        <DED>if sort not in ('CREATE', 'CALL'):\n            <IND>raise ValueError('unsupported transaction type')\n\n        <DED>if sort == 'CREATE':\n            # When creating data is the init_bytecode + arguments\n            <IND>if len(data) == 0:\n                <IND>raise EthereumError(\"An initialization bytecode is needed for a CREATE\")\n\n        <DED><DED>assert address is not None\n        assert caller is not None\n\n        # Transactions (like everything else) need at least one running state\n        if not self.count_running_states():\n            <IND>raise NoAliveStates\n\n        # To avoid going full crazy, we maintain a global list of addresses\n        <DED>for state in self.running_states:\n            <IND>world = state.platform\n\n            if '_pending_transaction' in state.context:\n                <IND>raise EthereumError(\"This is bad. It should not be a pending transaction\")\n\n            # Choose an address here, because it will be dependent on the caller's nonce in this state\n            <DED>if address is None:\n                <IND>if issymbolic(caller):\n                    # TODO (ESultanik): In order to handle this case, we are going to have to do something like fork\n                    # over all possible caller addresses.\n                    # But this edge case will likely be extremely rare, if ever ecountered.\n                    <IND>raise EthereumError(\"Manticore does not currently support contracts with symbolic addresses creating new contracts\")\n                <DED>address = world.new_address(caller)\n\n            # Migrate any expression to state specific constraint set\n            <DED>caller_migrated, address_migrated, value_migrated, data_migrated = self._migrate_tx_expressions(state, caller, address, value, data)\n\n            # Different states may CREATE a different set of accounts. Accounts\n            # that were crated by a human have the same address in all states.\n            # This diverges from the yellow paper but at least we check that we\n            # are not trying to create an already used address here\n            if sort == 'CREATE':\n                <IND>if address in world.accounts:\n                    # Address already used\n                    <IND>raise EthereumError(\"This is bad. Same address is used for different contracts in different states\")\n\n            <DED><DED>state.context['_pending_transaction'] = (sort, caller_migrated, address_migrated, value_migrated, data_migrated, gaslimit, price)\n\n        # run over potentially several states and\n        # generating potentially several others\n        <DED>self.run(procs=self._config_procs)\n\n        return address\n\n    <DED>def multi_tx_analysis(self, solidity_filename, working_dir=None, contract_name=None,\n                          tx_limit=None, tx_use_coverage=True,\n                          tx_send_ether=True, tx_account=\"attacker\", args=None):\n        <IND>owner_account = self.create_account(balance=1000, name='owner')\n        attacker_account = self.create_account(balance=1000, name='attacker')\n\n        # Pretty print\n        logger.info(\"Starting symbolic create contract\")\n\n        with open(solidity_filename) as f:\n            <IND>contract_account = self.solidity_create_contract(f, contract_name=contract_name, owner=owner_account,\n                                                             args=args, working_dir=working_dir)\n\n        <DED>if tx_account == \"attacker\":\n            <IND>tx_account = [attacker_account]\n        <DED>elif tx_account == \"owner\":\n            <IND>tx_account = [owner_account]\n        <DED>elif tx_account == \"combo1\":\n            <IND>tx_account = [owner_account, attacker_account]\n        <DED>else:\n            <IND>raise EthereumError('The account to perform the symbolic exploration of the contract should be \"attacker\", \"owner\" or \"combo1\"')\n\n        <DED>if contract_account is None:\n            <IND>logger.info(\"Failed to create contract: exception in constructor\")\n            return\n\n        <DED>prev_coverage = 0\n        current_coverage = 0\n        tx_no = 0\n        while (current_coverage < 100 or not tx_use_coverage) and not self.is_shutdown():\n            <IND>try:\n                <IND>logger.info(\"Starting symbolic transaction: %d\", tx_no)\n\n                # run_symbolic_tx\n                symbolic_data = self.make_symbolic_buffer(320)\n                if tx_send_ether:\n                    <IND>value = self.make_symbolic_value()\n                <DED>else:\n                    <IND>value = 0\n                <DED>self.transaction(caller=tx_account[min(tx_no, len(tx_account) - 1)],\n                                 address=contract_account,\n                                 data=symbolic_data,\n                                 value=value,\n                                 gas=2100000)\n                logger.info(\"%d alive states, %d terminated states\", self.count_running_states(), self.count_terminated_states())\n            <DED>except NoAliveStates:\n                <IND>break\n\n            # Check if the maximum number of tx was reached\n            <DED>if tx_limit is not None and tx_no + 1 == tx_limit:\n                <IND>break\n\n            # Check if coverage has improved or not\n            <DED>if tx_use_coverage:\n                <IND>prev_coverage = current_coverage\n                current_coverage = self.global_coverage(contract_account)\n                found_new_coverage = prev_coverage < current_coverage\n\n                if not found_new_coverage:\n                    <IND>break\n\n            <DED><DED>tx_no += 1\n\n    <DED><DED>def run(self, **kwargs):\n        <IND>\"\"\" Run any pending transaction on any running state \"\"\"\n        # Check if there is a pending transaction\n        with self.locked_context('ethereum') as context:\n            # there are no states added to the executor queue\n            <IND>assert len(self._executor.list()) == 0\n            for state_id in context['_saved_states']:\n                <IND>self._executor.put(state_id)\n            <DED>context['_saved_states'] = set()\n\n        # A callback will use _pending_transaction and issue the transaction\n        # in each state (see load_state_callback)\n        <DED>super().run(**kwargs)\n\n        with self.locked_context('ethereum') as context:\n            <IND>if len(context['_saved_states']) == 1:\n                <IND>self._initial_state = self._executor._workspace.load_state(context['_saved_states'].pop(), delete=True)\n                self._executor.forward_events_from(self._initial_state, True)\n                context['_saved_states'] = set()\n                assert self._running_state_ids == (-1,)\n\n    <DED><DED><DED>def save(self, state, state_id=None, final=False):\n        <IND>\"\"\" Save a state in secondary storage and add it to running or final lists\n\n            :param state: A manticore State\n            :param state_id: if not None force state_id (overwrite)\n            :param final: True if state is final\n            :returns: a state id\n        \"\"\"\n        # If overwriting then the state_id must be known\n        if state_id is not None:\n            <IND>if state_id not in self._all_state_ids:\n                <IND>raise EthereumError(\"Trying to overwrite unknown state_id\")\n            <DED>with self.locked_context('ethereum') as context:\n                <IND>context['_final_states'].discard(state_id)\n                context['_saved_states'].discard(state_id)\n\n        <DED><DED>if state_id != -1:\n            # save the state to secondary storage\n            <IND>state_id = self._executor._workspace.save_state(state, state_id=state_id)\n\n            with self.locked_context('ethereum') as context:\n                <IND>if final:\n                    # Keep it on a private list\n                    <IND>context['_final_states'].add(state_id)\n                <DED>else:\n                    # Keep it on a private list\n                    <IND>context['_saved_states'].add(state_id)\n        <DED><DED><DED>return state_id\n\n    <DED>def load(self, state_id=None):\n        <IND>\"\"\" Load one of the running or final states.\n\n            :param state_id: If None it assumes there is a single running state\n            :type state_id: int or None\n        \"\"\"\n        state = None\n        if state_id is None:\n            #a single state was assumed\n            <IND>state_count = self.count_running_states()\n            if state_count == 1:\n                #Get the ID of the single running state\n                <IND>state_id = self._running_state_ids[0]\n            <DED>elif state_count == 0:\n                <IND>raise NoAliveStates\n            <DED>else:\n                <IND>raise EthereumError(\"More than one state running; you must specify a state id.\")\n\n        <DED><DED>if state_id == -1:\n            <IND>state = self.initial_state\n        <DED>else:\n            <IND>state = self._executor._workspace.load_state(state_id, delete=False)\n            #froward events from newly loaded object\n            self._executor.forward_events_from(state, True)\n        <DED>return state\n\n    # Callbacks\n    <DED>def _on_symbolic_sha3_callback(self, state, data, known_hashes):\n        <IND>\"\"\" INTERNAL USE \"\"\"\n        assert issymbolic(data), 'Data should be symbolic here!'\n\n        with self.locked_context('ethereum') as context:\n            <IND>known_sha3 = context.get('_known_sha3', None)\n            if known_sha3 is None:\n                <IND>known_sha3 = set()\n\n            <DED>sha3_states = context.get('_sha3_states', [])\n            results = []\n            # If know_hashes is true then there is a _known_ solution for the hash\n            known_hashes_cond = False\n            for key, value in known_sha3:\n                <IND>assert not issymbolic(key), \"Saved sha3 data,hash pairs should be concrete\"\n                cond = key == data\n\n                #TODO consider disabling this solver query.\n                if not state.can_be_true(cond):\n                    <IND>continue\n\n                <DED>results.append((key, value))\n                known_hashes_cond = Operators.OR(cond, known_hashes_cond)\n\n            # adding a single random example so we can explore further in case\n            # there are not known sha3 pairs that match yet\n            <DED>if not results:\n                <IND>data_concrete = state.solve_one(data)\n                s = sha3.keccak_256(data_concrete)\n                data_hash = int(s.hexdigest(), 16)\n                results.append((data_concrete, data_hash))\n                known_hashes_cond = data_concrete == data\n                known_sha3.add((data_concrete, data_hash))\n            <DED>not_known_hashes_cond = Operators.NOT(known_hashes_cond)\n\n            # We need to fork/save the state\n            #################################\n            # save the state to secondary storage\n            # Build and enqueue a state for each solution\n            with state as temp_state:\n                <IND>if temp_state.can_be_true(not_known_hashes_cond):\n                    <IND>temp_state.constrain(not_known_hashes_cond)\n                    state_id = self._executor._workspace.save_state(temp_state)\n                    sha3_states[state_id] = [hsh for buf, hsh in known_sha3]\n            <DED><DED>context['_sha3_states'] = sha3_states\n\n            if not state.can_be_true(known_hashes_cond):\n                <IND>raise TerminateState(\"There is no matching sha3 pair, bailing out\")\n            <DED>state.constrain(known_hashes_cond)\n\n            #send known hashes to evm\n            known_hashes.update(results)\n\n    <DED><DED>def _on_concrete_sha3_callback(self, state, buf, value):\n        <IND>\"\"\" INTERNAL USE \"\"\"\n        with self.locked_context('ethereum', dict) as ethereum_context:\n            <IND>known_sha3 = ethereum_context.get('_known_sha3', None)\n            if known_sha3 is None:\n                <IND>known_sha3 = set()\n            <DED>known_sha3.add((buf, value))\n            ethereum_context['_known_sha3'] = known_sha3\n\n    <DED><DED>def _terminate_state_callback(self, state, state_id, e):\n        <IND>\"\"\" INTERNAL USE\n            Every time a state finishes executing the last transaction, we save it in\n            our private list\n        \"\"\"\n        if isinstance(e, AbandonState):\n            #do nothing\n            <IND>return\n        <DED>world = state.platform\n        state.context['last_exception'] = e\n        e.testcase = False  # Do not generate a testcase file\n\n        if not world.all_transactions:\n            <IND>logger.debug(\"Something went wrong: search terminated in the middle of an ongoing tx\")\n            self.save(state, final=True)\n            return\n\n        <DED>tx = world.all_transactions[-1]\n\n        #we initiated the Tx; we need process the outcome for now.\n        #Fixme incomplete.\n        if tx.is_human():\n            <IND>if tx.sort == 'CREATE':\n                <IND>if tx.result == 'RETURN':\n                    <IND>world.set_code(tx.address, tx.return_data)\n                <DED>else:\n                    <IND>world.delete_account(tx.address)\n        <DED><DED><DED>else:\n            <IND>logger.info(\"Manticore exception: state should be terminated only at the end of the human transaction\")\n\n        #Human tx that ends in this wont modify the storage so finalize and\n        # generate a testcase. FIXME This should be configurable as REVERT and\n        # THROW; it actually changes the balance and nonce? of some accounts\n        <DED>if tx.result in {'SELFDESTRUCT', 'REVERT', 'THROW', 'TXERROR'}:\n            <IND>self.save(state, final=True)\n        <DED>elif tx.result in {'RETURN', 'STOP'}:\n            # if not a revert, we save the state for further transactions\n            <IND>self.save(state)  # Add to running states\n        <DED>else:\n            <IND>logger.debug(\"Exception in state. Discarding it\")\n\n    #Callbacks\n    <DED><DED>def _load_state_callback(self, state, state_id):\n        <IND>\"\"\" INTERNAL USE\n            If a state was just loaded from storage, we do the pending transaction\n        \"\"\"\n        if '_pending_transaction' not in state.context:\n            <IND>return\n        <DED>world = state.platform\n        ty, caller, address, value, data, gaslimit, price = state.context['_pending_transaction']\n        del state.context['_pending_transaction']\n\n        if ty == 'CALL':\n            <IND>world.transaction(address=address, caller=caller, data=data, value=value, price=price, gas=gaslimit)\n        <DED>else:\n            <IND>assert ty == 'CREATE'\n            world.create_contract(caller=caller, address=address, balance=value, init=data, price=price, gas=gaslimit)\n\n    <DED><DED>def _did_evm_execute_instruction_callback(self, state, instruction, arguments, result):\n        <IND>\"\"\" INTERNAL USE \"\"\"\n        #logger.debug(\"%s\", state.platform.current_vm)\n        #TODO move to a plugin\n        at_init = state.platform.current_transaction.sort == 'CREATE'\n        if at_init:\n            <IND>coverage_context_name = 'init_coverage'\n        <DED>else:\n            <IND>coverage_context_name = 'runtime_coverage'\n\n        <DED>with self.locked_context(coverage_context_name, set) as coverage:\n            <IND>coverage.add((state.platform.current_vm.address, instruction.pc))\n\n        <DED>state.context.setdefault('evm.trace', []).append((state.platform.current_vm.address, instruction.pc, at_init))\n\n    <DED>def _did_evm_read_code(self, state, offset, size):\n        <IND>\"\"\" INTERNAL USE \"\"\"\n        with self.locked_context('code_data', set) as code_data:\n            <IND>for i in range(offset, offset + size):\n                <IND>code_data.add((state.platform.current_vm.address, i))\n\n    <DED><DED><DED>def get_metadata(self, address) -> Optional[SolidityMetadata]:\n        <IND>\"\"\" Gets the solidity metadata for address.\n            This is available only if address is a contract created from solidity\n        \"\"\"\n        return self.metadata.get(int(address))\n\n    <DED>def register_detector(self, d):\n        <IND>if not isinstance(d, Detector):\n            <IND>raise EthereumError(\"Not a Detector\")\n        <DED>if d.name in self.detectors:\n            <IND>raise EthereumError(\"Detector already registered\")\n        <DED>self.detectors[d.name] = d\n        self.register_plugin(d)\n        return d.name\n\n    <DED>def unregister_detector(self, d):\n        <IND>if not isinstance(d, (Detector, str)):\n            <IND>raise EthereumError(\"Not a Detector\")\n        <DED>name = d\n        if isinstance(d, Detector):\n            <IND>name = d.name\n        <DED>if name not in self.detectors:\n            <IND>raise EthereumError(\"Detector not registered\")\n        <DED>d = self.detectors[name]\n        del self.detectors[name]\n        self.unregister_plugin(d)\n\n    <DED>@property\n    def workspace(self):\n        <IND>return self._executor._workspace._store.uri\n\n    <DED>def generate_testcase(self, state, message='', only_if=None, name='user'):\n        <IND>\"\"\"\n        Generate a testcase to the workspace for the given program state. The details of what\n        a testcase is depends on the type of Platform the state is, but involves serializing the state,\n        and generating an input (concretizing symbolic variables) to trigger this state.\n\n        The only_if parameter should be a symbolic expression. If this argument is provided, and the expression\n        *can be true* in this state, a testcase is generated such that the expression will be true in the state.\n        If it *is impossible* for the expression to be true in the state, a testcase is not generated.\n\n        This is useful for conveniently checking a particular invariant in a state, and generating a testcase if\n        the invariant can be violated.\n\n        For example, invariant: \"balance\" must not be 0. We can check if this can be violated and generate a\n        testcase::\n\n            m.generate_testcase(state, 'balance CAN be 0', only_if=balance == 0)\n            # testcase generated with an input that will violate invariant (make balance == 0)\n\n        :param manticore.core.state.State state:\n        :param str message: longer description of the testcase condition\n        :param manticore.core.smtlib.Bool only_if: only if this expr can be true, generate testcase. if is None, generate testcase unconditionally.\n        :param str name: short string used as the prefix for the workspace key (e.g. filename prefix for testcase files)\n        :return: If a testcase was generated\n        :rtype: bool\n        \"\"\"\n        if only_if is None:\n            <IND>self._generate_testcase_callback(state, name, message)\n            return True\n        <DED>else:\n            <IND>with state as temp_state:\n                <IND>temp_state.constrain(only_if)\n                if temp_state.is_feasible():\n                    <IND>self._generate_testcase_callback(temp_state, name, message)\n                    return True\n\n        <DED><DED><DED>return False\n\n    <DED>def current_location(self, state):\n        <IND>world = state.platform\n        address = world.current_vm.address\n        pc = world.current_vm.pc\n        at_init = world.current_transaction.sort == 'CREATE'\n        output = io.StringIO()\n        write_findings(output, '', address, pc, at_init)\n        md = self.get_metadata(address)\n        if md is not None:\n            <IND>src = md.get_source_for(pc, runtime=not at_init)\n            output.write('Snippet:\\n')\n            output.write(src.replace('\\n', '\\n  ').strip())\n            output.write('\\n')\n        <DED>return output.getvalue()\n\n    <DED>def _generate_testcase_callback(self, state, name, message=''):\n        <IND>\"\"\"\n        Create a serialized description of a given state.\n        :param state: The state to generate information about\n        :param message: Accompanying message\n        \"\"\"\n        # workspace should not be responsible for formating the output\n        # each object knows its secrets, and each class should be able to report its\n        # final state\n        #super()._generate_testcase_callback(state, name, message)\n        # TODO(mark): Refactor ManticoreOutput to let the platform be more in control\n        #  so this function can be fully ported to EVMWorld.generate_workspace_files.\n        blockchain = state.platform\n\n        testcase = self._output.testcase(name.replace(' ', '_'))\n        last_tx = blockchain.last_transaction\n        if last_tx:\n            <IND>message = message + last_tx.result\n        <DED>logger.info(\"Generated testcase No. {} - {}\".format(testcase.num, message))\n\n        local_findings = set()\n        for detector in self.detectors.values():\n            <IND>for address, pc, finding, at_init, constraint in detector.get_findings(state):\n                <IND>if (address, pc, finding, at_init) not in local_findings:\n                    <IND>local_findings.add((address, pc, finding, at_init, constraint))\n\n        <DED><DED><DED>if len(local_findings):\n            <IND>with testcase.open_stream('findings') as findings:\n                <IND>for address, pc, finding, at_init, constraint in local_findings:\n                    <IND>findings.write('- %s -\\n' % finding)\n                    write_findings(findings, '  ', address, pc, at_init)\n                    md = self.get_metadata(address)\n                    if md is not None:\n                        <IND>src = md.get_source_for(pc, runtime=not at_init)\n                        findings.write('  Snippet:\\n')\n                        findings.write(src.replace('\\n', '\\n    ').strip())\n                        findings.write('\\n')\n\n        <DED><DED><DED><DED>with testcase.open_stream('summary') as stream:\n            <IND>is_something_symbolic = state.platform.dump(stream, state, self, message)\n\n            with self.locked_context('ethereum') as context:\n                <IND>known_sha3 = context.get('_known_sha3', None)\n                if known_sha3:\n                    <IND>stream.write(\"Known hashes:\\n\")\n                    for key, value in known_sha3:\n                        <IND>stream.write('%s::%x\\n' % (binascii.hexlify(key), value))\n\n            <DED><DED><DED>if is_something_symbolic:\n                <IND>stream.write('\\n\\n(*) Example solution given. Value is symbolic and may take other values\\n')\n\n        # Transactions\n\n        <DED><DED>with testcase.open_stream('tx') as tx_summary:\n            <IND>with testcase.open_stream('tx.json') as txjson:\n                <IND>txlist = []\n                is_something_symbolic = False\n\n                for sym_tx in blockchain.human_transactions:  # external transactions\n                    <IND>tx_summary.write(\"Transactions No. %d\\n\" % blockchain.transactions.index(sym_tx))\n\n                    conc_tx = sym_tx.concretize(state)\n                    txlist.append(conc_tx.to_dict(self))\n\n                    is_something_symbolic = sym_tx.dump(tx_summary, state, self, conc_tx=conc_tx)\n\n                <DED>if is_something_symbolic:\n                    <IND>tx_summary.write('\\n\\n(*) Example solution given. Value is symbolic and may take other values\\n')\n\n                <DED>json.dump(txlist, txjson)\n\n        # logs\n        <DED><DED>with testcase.open_stream('logs') as logs_summary:\n            <IND>is_something_symbolic = False\n            for log_item in blockchain.logs:\n                <IND>is_log_symbolic = issymbolic(log_item.memlog)\n                is_something_symbolic = is_log_symbolic or is_something_symbolic\n                solved_memlog = state.solve_one(log_item.memlog)\n                printable_bytes = ''.join([c for c in map(chr, solved_memlog) if c in string.printable])\n\n                logs_summary.write(\"Address: %x\\n\" % log_item.address)\n                logs_summary.write(\"Memlog: %s (%s) %s\\n\" % (binascii.hexlify(solved_memlog).decode(), printable_bytes, flagged(is_log_symbolic)))\n                logs_summary.write(\"Topics:\\n\")\n                for i, topic in enumerate(log_item.topics):\n                    <IND>logs_summary.write(\"\\t%d) %x %s\" % (i, state.solve_one(topic), flagged(issymbolic(topic))))\n\n        <DED><DED><DED>with testcase.open_stream('constraints') as smt_summary:\n            <IND>smt_summary.write(str(state.constraints))\n\n        <DED>with testcase.open_stream('pkl', binary=True) as statef:\n            <IND>self._serializer.serialize(state, statef)\n\n        <DED>trace = state.context.get('evm.trace')\n        if trace:\n            <IND>with testcase.open_stream('trace') as f:\n                <IND>self._emit_trace_file(f, trace)\n        <DED><DED>return testcase\n\n    <DED>@staticmethod\n    def _emit_trace_file(filestream, trace):\n        <IND>\"\"\"\n        :param filestream: file object for the workspace trace file\n        :param trace: list of (contract address, pc) tuples\n        :type trace: list[tuple(int, int)]\n        \"\"\"\n        for contract, pc, at_init in trace:\n            <IND>if pc == 0:\n                <IND>filestream.write('---\\n')\n            <DED>ln = '0x{:x}:0x{:x} {}\\n'.format(contract, pc, '*' if at_init else '')\n            filestream.write(ln)\n\n    <DED><DED>@property\n    def global_findings(self):\n        <IND>global_findings = set()\n        for detector in self.detectors.values():\n            <IND>for address, pc, finding, at_init in detector.global_findings:\n                <IND>if (address, pc, finding, at_init) not in global_findings:\n                    <IND>global_findings.add((address, pc, finding, at_init))\n        <DED><DED><DED>return global_findings\n\n    <DED>def finalize(self):\n        <IND>\"\"\"\n        Terminate and generate testcases for all currently alive states (contract states that cleanly executed\n        to a STOP or RETURN in the last symbolic transaction).\n        \"\"\"\n        logger.debug(\"Finalizing %d states.\", self.count_states())\n\n        def finalizer(state_id):\n            <IND>state_id = self._terminate_state_id(state_id)\n            st = self.load(state_id)\n            logger.debug(\"Generating testcase for state_id %d\", state_id)\n            self._generate_testcase_callback(st, 'test', '')\n\n        <DED>def worker_finalize(q):\n            <IND>try:\n                <IND>while True:\n                    <IND>finalizer(q.get_nowait())\n            <DED><DED>except EmptyQueue:\n                <IND>pass\n\n        <DED><DED>q = Queue()\n        for state_id in self._all_state_ids:\n            #we need to remove -1 state before forking because it may be in memory\n            <IND>if state_id == -1:\n                <IND>finalizer(-1)\n            <DED>else:\n                <IND>q.put(state_id)\n\n        <DED><DED>report_workers = []\n        for _ in range(self._config_procs):\n            <IND>proc = Process(target=worker_finalize, args=(q,))\n            proc.start()\n            report_workers.append(proc)\n\n        <DED>for proc in report_workers:\n            <IND>proc.join()\n\n        #global summary\n        <DED>if len(self.global_findings):\n            <IND>with self._output.save_stream('global.findings') as global_findings:\n                <IND>for address, pc, finding, at_init in self.global_findings:\n                    <IND>global_findings.write('- %s -\\n' % finding)\n                    write_findings(global_findings, '  ', address, pc, at_init)\n                    md = self.get_metadata(address)\n                    if md is not None:\n                        <IND>source_code_snippet = md.get_source_for(pc, runtime=not at_init)\n                        global_findings.write('  Solidity snippet:\\n')\n                        global_findings.write('    '.join(source_code_snippet.splitlines(True)))\n                        global_findings.write('\\n')\n\n        <DED><DED><DED><DED>with self._output.save_stream('manticore.yml') as f:\n            <IND>config.save(f)\n\n        <DED>with self._output.save_stream('global.summary') as global_summary:\n            # (accounts created by contract code are not in this list )\n            <IND>global_summary.write(\"Global runtime coverage:\\n\")\n            for address in self.contract_accounts.values():\n                <IND>global_summary.write(\"{:x}: {:2.2f}%\\n\".format(int(address), self.global_coverage(address)))\n\n                md = self.get_metadata(address)\n                if md is not None and len(md.warnings) > 0:\n                    <IND>global_summary.write('\\n\\nCompiler warnings for %s:\\n' % md.name)\n                    global_summary.write(md.warnings)\n\n        <DED><DED><DED>for address, md in self.metadata.items():\n            <IND>with self._output.save_stream('global_%s.sol' % md.name) as global_src:\n                <IND>global_src.write(md.source_code)\n            <DED>with self._output.save_stream('global_%s_runtime.bytecode' % md.name, binary=True) as global_runtime_bytecode:\n                <IND>global_runtime_bytecode.write(md.runtime_bytecode)\n            <DED>with self._output.save_stream('global_%s_init.bytecode' % md.name, binary=True) as global_init_bytecode:\n                <IND>global_init_bytecode.write(md.init_bytecode)\n\n            <DED>with self._output.save_stream('global_%s.runtime_asm' % md.name) as global_runtime_asm:\n                <IND>runtime_bytecode = md.runtime_bytecode\n\n                with self.locked_context('runtime_coverage') as seen:\n\n                    <IND>count, total = 0, 0\n                    for i in EVMAsm.disassemble_all(runtime_bytecode):\n                        <IND>if (address, i.pc) in seen:\n                            <IND>count += 1\n                            global_runtime_asm.write('*')\n                        <DED>else:\n                            <IND>global_runtime_asm.write(' ')\n\n                        <DED>global_runtime_asm.write('%4x: %s\\n' % (i.pc, i))\n                        total += 1\n\n            <DED><DED><DED>with self._output.save_stream('global_%s.init_asm' % md.name) as global_init_asm:\n                <IND>with self.locked_context('init_coverage') as seen:\n                    <IND>count, total = 0, 0\n                    for i in EVMAsm.disassemble_all(md.init_bytecode):\n                        <IND>if (address, i.pc) in seen:\n                            <IND>count += 1\n                            global_init_asm.write('*')\n                        <DED>else:\n                            <IND>global_init_asm.write(' ')\n\n                        <DED>global_init_asm.write('%4x: %s\\n' % (i.pc, i))\n                        total += 1\n\n            <DED><DED><DED>with self._output.save_stream('global_%s.init_visited' % md.name) as f:\n                <IND>with self.locked_context('init_coverage') as seen:\n                    <IND>visited = set((o for (a, o) in seen if a == address))\n                    for o in sorted(visited):\n                        <IND>f.write('0x%x\\n' % o)\n\n            <DED><DED><DED>with self._output.save_stream('global_%s.runtime_visited' % md.name) as f:\n                <IND>with self.locked_context('runtime_coverage') as seen:\n                    <IND>visited = set()\n                    for (a, o) in seen:\n                        <IND>if a == address:\n                            <IND>visited.add(o)\n                    <DED><DED>for o in sorted(visited):\n                        <IND>f.write('0x%x\\n' % o)\n\n        # delete actual streams from storage\n        <DED><DED><DED><DED>for state_id in self._all_state_ids:\n            # state_id -1 is always only on memory\n            <IND>if state_id != -1:\n                <IND>self._executor._workspace.rm_state(state_id)\n\n        # clean up lists\n        <DED><DED>with self.locked_context('ethereum') as eth_context:\n            <IND>eth_context['_saved_states'] = set()\n            eth_context['_final_states'] = set()\n\n        <DED>logger.info(\"Results in %s\", self.workspace)\n\n    <DED>def global_coverage(self, account):\n        <IND>\"\"\" Returns code coverage for the contract on `account_address`.\n            This sums up all the visited code lines from any of the explored\n            states.\n        \"\"\"\n        account_address = int(account)\n        runtime_bytecode = None\n        #Search one state in which the account_address exists\n        for state in self.all_states:\n            <IND>world = state.platform\n            if account_address in world:\n                <IND>code = world.get_code(account_address)\n                runtime_bytecode = state.solve_one(code)\n                break\n        <DED><DED>else:\n            <IND>return 0.0\n        <DED>with self.locked_context('runtime_coverage') as coverage:\n            <IND>seen = {off for addr, off in coverage if addr == account_address}\n        <DED>return calculate_coverage(runtime_bytecode, seen)\n\n    # TODO: Find a better way to suppress execution of Manticore._did_finish_run_callback\n    # We suppress because otherwise we log it many times and it looks weird.\n    <DED>def _did_finish_run_callback(self):\n        <IND>pass\n\n    <DED>def __repr__(self):\n        <IND>return self.__str__()\n\n    <DED>def __str__(self):\n        <IND>return \"<ManticoreEVM | Alive States: {}; Terminated States: {}>\".format(\n            self.count_running_states(),\n            self.count_terminated_states()\n        )\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\nfrom ..exceptions import NoAliveStates, EthereumError\nfrom ..platforms import evm\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "trailofbits/manticore",
    "commit": "169904561a19af964a45543482ff798be651edc4",
    "filename": "tests/auto/make_tests.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/trailofbits-manticore/tests/auto/make_tests.py",
    "file_hunks_size": 2,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "tests/auto/make_tests.py:6:12 Unbound name [10]: Name `file` is used but not defined in the current scope.",
    "message": " Name `file` is used but not defined in the current scope.",
    "rule_id": "Unbound name [10]",
    "warning_line_no": 6,
    "warning_line": "tests_str = file(sys.argv[1], 'r').read().split('\\n')",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "tests = []\ntests_str = file(sys.argv[1], 'r').read().split('\\n')\nfor t_str in tests_str:\n",
        "source_code_len": 89,
        "target_code": "tests = []\n\nwith open(sys.argv[1], 'r') as f:\n    tests_str = f.read().split('\\n')\n\nfor t_str in tests_str:\n",
        "target_code_len": 108,
        "diff_format": "@@ -5,3 +5,6 @@\n tests = []\n-tests_str = file(sys.argv[1], 'r').read().split('\\n')\n+\n+with open(sys.argv[1], 'r') as f:\n+    tests_str = f.read().split('\\n')\n+\n for t_str in tests_str:\n",
        "source_code_with_indent": "tests = []\ntests_str = file(sys.argv[1], 'r').read().split('\\n')\nfor t_str in tests_str:\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "tests = []\n\nwith open(sys.argv[1], 'r') as f:\n    <IND>tests_str = f.read().split('\\n')\n\n<DED>for t_str in tests_str:\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  }
]