[
  {
    "project": "google/openhtf",
    "commit": "4646aa6b9ba67532ce7e8743ce16d7bd4369ad3d",
    "filename": "openhtf/core/diagnoses_lib.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/google-openhtf/openhtf/core/diagnoses_lib.py",
    "file_hunks_size": 6,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": true,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "openhtf/core/diagnoses_lib.py:287:2 Incompatible variable type [9]: values_to_enums is declared to have type `DefaultDict[str, Type[DiagResultEnum]]` but is used as type `DefaultDict[Variable[collections._KT], List[Variable[_T]]]`.",
    "message": " values_to_enums is declared to have type `DefaultDict[str, Type[DiagResultEnum]]` but is used as type `DefaultDict[Variable[collections._KT], List[Variable[_T]]]`.",
    "rule_id": "Incompatible variable type [9]",
    "warning_line_no": 287,
    "warning_line": "  values_to_enums = collections.defaultdict(",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": true,
        "has_suppression": false,
        "source_code": "\ndef check_for_duplicate_results(\n    phase_iterator: Iterator[phase_descriptor.PhaseDescriptor],\n    test_diagnosers: Sequence['BaseTestDiagnoser']) -> None:\n  \"\"\"Check for any results with the same enum value in different ResultTypes.\n\n  Args:\n    phase_iterator: iterator over the phases to check.\n    test_diagnosers: list of test level diagnosers.\n\n  Raises:\n    DuplicateResultError: when duplicate enum values are found.\n  \"\"\"\n  all_result_enums = set()  # type: Set[Type['DiagResultEnum']]\n  for phase in phase_iterator:\n    for phase_diag in phase.diagnosers:\n      all_result_enums.add(phase_diag.result_type)\n  for test_diag in test_diagnosers:\n    all_result_enums.add(test_diag.result_type)\n\n  values_to_enums = collections.defaultdict(\n      list)  # type: DefaultDict[str, Type['DiagResultEnum']]\n  for enum_cls in all_result_enums:\n    for entry in enum_cls:\n      values_to_enums[entry.value].append(enum_cls)\n\n  duplicates = []  # type: List[str]\n  for result_value, enum_classes in sorted(values_to_enums.items()):\n    if len(enum_classes) > 1:\n      duplicates.append('Value \"{}\" defined by {}'.format(\n          result_value, enum_classes))\n  if not duplicates:\n    return\n  raise DuplicateResultError('Duplicate DiagResultEnum values: {}'.format(\n      '\\n'.join(duplicates)))\n\n\ndef _check_diagnoser(diagnoser: '_BaseDiagnoser',\n",
        "source_code_len": 1351,
        "target_code": "\ndef _check_diagnoser(diagnoser: '_BaseDiagnoser',\n",
        "target_code_len": 51,
        "diff_format": "@@ -267,38 +261,2 @@\n \n-def check_for_duplicate_results(\n-    phase_iterator: Iterator[phase_descriptor.PhaseDescriptor],\n-    test_diagnosers: Sequence['BaseTestDiagnoser']) -> None:\n-  \"\"\"Check for any results with the same enum value in different ResultTypes.\n-\n-  Args:\n-    phase_iterator: iterator over the phases to check.\n-    test_diagnosers: list of test level diagnosers.\n-\n-  Raises:\n-    DuplicateResultError: when duplicate enum values are found.\n-  \"\"\"\n-  all_result_enums = set()  # type: Set[Type['DiagResultEnum']]\n-  for phase in phase_iterator:\n-    for phase_diag in phase.diagnosers:\n-      all_result_enums.add(phase_diag.result_type)\n-  for test_diag in test_diagnosers:\n-    all_result_enums.add(test_diag.result_type)\n-\n-  values_to_enums = collections.defaultdict(\n-      list)  # type: DefaultDict[str, Type['DiagResultEnum']]\n-  for enum_cls in all_result_enums:\n-    for entry in enum_cls:\n-      values_to_enums[entry.value].append(enum_cls)\n-\n-  duplicates = []  # type: List[str]\n-  for result_value, enum_classes in sorted(values_to_enums.items()):\n-    if len(enum_classes) > 1:\n-      duplicates.append('Value \"{}\" defined by {}'.format(\n-          result_value, enum_classes))\n-  if not duplicates:\n-    return\n-  raise DuplicateResultError('Duplicate DiagResultEnum values: {}'.format(\n-      '\\n'.join(duplicates)))\n-\n-\n def _check_diagnoser(diagnoser: '_BaseDiagnoser',\n",
        "source_code_with_indent": "\n<DED><DED><DED>def check_for_duplicate_results(\n    phase_iterator: Iterator[phase_descriptor.PhaseDescriptor],\n    test_diagnosers: Sequence['BaseTestDiagnoser']) -> None:\n  <IND>\"\"\"Check for any results with the same enum value in different ResultTypes.\n\n  Args:\n    phase_iterator: iterator over the phases to check.\n    test_diagnosers: list of test level diagnosers.\n\n  Raises:\n    DuplicateResultError: when duplicate enum values are found.\n  \"\"\"\n  all_result_enums = set()  # type: Set[Type['DiagResultEnum']]\n  for phase in phase_iterator:\n    <IND>for phase_diag in phase.diagnosers:\n      <IND>all_result_enums.add(phase_diag.result_type)\n  <DED><DED>for test_diag in test_diagnosers:\n    <IND>all_result_enums.add(test_diag.result_type)\n\n  <DED>values_to_enums = collections.defaultdict(\n      list)  # type: DefaultDict[str, Type['DiagResultEnum']]\n  for enum_cls in all_result_enums:\n    <IND>for entry in enum_cls:\n      <IND>values_to_enums[entry.value].append(enum_cls)\n\n  <DED><DED>duplicates = []  # type: List[str]\n  for result_value, enum_classes in sorted(values_to_enums.items()):\n    <IND>if len(enum_classes) > 1:\n      <IND>duplicates.append('Value \"{}\" defined by {}'.format(\n          result_value, enum_classes))\n  <DED><DED>if not duplicates:\n    <IND>return\n  <DED>raise DuplicateResultError('Duplicate DiagResultEnum values: {}'.format(\n      '\\n'.join(duplicates)))\n\n\n<DED>def _check_diagnoser(diagnoser: '_BaseDiagnoser',\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n<DED><DED><DED>def _check_diagnoser(diagnoser: '_BaseDiagnoser',\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "google/openhtf",
    "commit": "4646aa6b9ba67532ce7e8743ce16d7bd4369ad3d",
    "filename": "openhtf/core/diagnoses_lib.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/google-openhtf/openhtf/core/diagnoses_lib.py",
    "file_hunks_size": 6,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "openhtf/core/diagnoses_lib.py:414:2 Inconsistent override [14]: `openhtf.core.diagnoses_lib.PhaseDiagnoser.run` overrides method defined in `BasePhaseDiagnoser` inconsistently. Parameter of type `test_record.PhaseRecord` is not a supertype of the overridden parameter `phase_descriptor.PhaseDescriptor`.",
    "message": " `openhtf.core.diagnoses_lib.PhaseDiagnoser.run` overrides method defined in `BasePhaseDiagnoser` inconsistently. Parameter of type `test_record.PhaseRecord` is not a supertype of the overridden parameter `phase_descriptor.PhaseDescriptor`.",
    "rule_id": "Inconsistent override [14]",
    "warning_line_no": 414,
    "warning_line": "  def run(self, phase_record: test_record.PhaseRecord) -> DiagnoserReturnT:",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "  @abc.abstractmethod\n  def run(self,\n          phase_record: phase_descriptor.PhaseDescriptor) -> DiagnoserReturnT:\n    \"\"\"Must be implemented to return list of Diagnoses instances.\n",
        "source_code_len": 183,
        "target_code": "  @abc.abstractmethod\n  def run(self, phase_record: test_record.PhaseRecord) -> DiagnoserReturnT:\n    \"\"\"Must be implemented to return list of Diagnoses instances.\n",
        "target_code_len": 164,
        "diff_format": "@@ -379,4 +337,3 @@\n   @abc.abstractmethod\n-  def run(self,\n-          phase_record: phase_descriptor.PhaseDescriptor) -> DiagnoserReturnT:\n+  def run(self, phase_record: test_record.PhaseRecord) -> DiagnoserReturnT:\n     \"\"\"Must be implemented to return list of Diagnoses instances.\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "  @abc.abstractmethod\n  def run(self,\n          phase_record: phase_descriptor.PhaseDescriptor) -> DiagnoserReturnT:\n    <IND>",
        "target_code_with_indent": "  @abc.abstractmethod\n  def run(self, phase_record: test_record.PhaseRecord) -> DiagnoserReturnT:\n    <IND>"
      }
    ]
  },
  {
    "project": "google/openhtf",
    "commit": "4646aa6b9ba67532ce7e8743ce16d7bd4369ad3d",
    "filename": "openhtf/core/diagnoses_lib.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/google-openhtf/openhtf/core/diagnoses_lib.py",
    "file_hunks_size": 6,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": true,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "openhtf/core/diagnoses_lib.py:556:19 Incompatible parameter type [6]: Expected `Sequence[_BaseDiagnoser]` for 1st positional only parameter to call `check_diagnosers` but got `typing.Tuple[BasePhaseDiagnoser, ...]`.",
    "message": " Expected `Sequence[_BaseDiagnoser]` for 1st positional only parameter to call `check_diagnosers` but got `typing.Tuple[BasePhaseDiagnoser, ...]`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 556,
    "warning_line": "  check_diagnosers(diagnosers, BasePhaseDiagnoser)",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": true,
        "has_suppression": false,
        "source_code": "        attr.asdict(self, filter=_diagnosis_serialize_filter))\n\n\ndef diagnose(\n    *diagnosers: BasePhaseDiagnoser\n) -> Callable[[phase_descriptor.PhaseT], phase_descriptor.PhaseDescriptor]:\n  \"\"\"Decorator to add diagnosers to a PhaseDescriptor.\"\"\"\n  check_diagnosers(diagnosers, BasePhaseDiagnoser)\n  diags = list(diagnosers)\n\n  def decorate(\n      wrapped_phase: phase_descriptor.PhaseT\n  ) -> phase_descriptor.PhaseDescriptor:\n    \"\"\"Phase decorator to be returned.\"\"\"\n    phase = phase_descriptor.PhaseDescriptor.wrap_or_copy(wrapped_phase)\n    phase.diagnosers.extend(diags)\n    return phase\n\n  return decorate\n",
        "source_code_len": 616,
        "target_code": "        attr.asdict(self, filter=_diagnosis_serialize_filter))\n",
        "target_code_len": 63,
        "diff_format": "@@ -549,19 +506,1 @@\n         attr.asdict(self, filter=_diagnosis_serialize_filter))\n-\n-\n-def diagnose(\n-    *diagnosers: BasePhaseDiagnoser\n-) -> Callable[[phase_descriptor.PhaseT], phase_descriptor.PhaseDescriptor]:\n-  \"\"\"Decorator to add diagnosers to a PhaseDescriptor.\"\"\"\n-  check_diagnosers(diagnosers, BasePhaseDiagnoser)\n-  diags = list(diagnosers)\n-\n-  def decorate(\n-      wrapped_phase: phase_descriptor.PhaseT\n-  ) -> phase_descriptor.PhaseDescriptor:\n-    \"\"\"Phase decorator to be returned.\"\"\"\n-    phase = phase_descriptor.PhaseDescriptor.wrap_or_copy(wrapped_phase)\n-    phase.diagnosers.extend(diags)\n-    return phase\n-\n-  return decorate\n",
        "source_code_with_indent": "        attr.asdict(self, filter=_diagnosis_serialize_filter))\n\n\n<DED><DED>def diagnose(\n    *diagnosers: BasePhaseDiagnoser\n) -> Callable[[phase_descriptor.PhaseT], phase_descriptor.PhaseDescriptor]:\n  <IND>\"\"\"Decorator to add diagnosers to a PhaseDescriptor.\"\"\"\n  check_diagnosers(diagnosers, BasePhaseDiagnoser)\n  diags = list(diagnosers)\n\n  def decorate(\n      wrapped_phase: phase_descriptor.PhaseT\n  ) -> phase_descriptor.PhaseDescriptor:\n    <IND>\"\"\"Phase decorator to be returned.\"\"\"\n    phase = phase_descriptor.PhaseDescriptor.wrap_or_copy(wrapped_phase)\n    phase.diagnosers.extend(diags)\n    return phase\n\n  <DED>return decorate\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "        attr.asdict(self, filter=_diagnosis_serialize_filter))\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "google/openhtf",
    "commit": "4646aa6b9ba67532ce7e8743ce16d7bd4369ad3d",
    "filename": "openhtf/core/diagnoses_lib.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/google-openhtf/openhtf/core/diagnoses_lib.py",
    "file_hunks_size": 6,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": true,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "openhtf/core/diagnoses_lib.py:556:31 Incompatible parameter type [6]: Expected `Type[_BaseDiagnoser]` for 2nd positional only parameter to call `check_diagnosers` but got `Type[BasePhaseDiagnoser]`.",
    "message": " Expected `Type[_BaseDiagnoser]` for 2nd positional only parameter to call `check_diagnosers` but got `Type[BasePhaseDiagnoser]`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 556,
    "warning_line": "  check_diagnosers(diagnosers, BasePhaseDiagnoser)",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": true,
        "has_suppression": false,
        "source_code": "        attr.asdict(self, filter=_diagnosis_serialize_filter))\n\n\ndef diagnose(\n    *diagnosers: BasePhaseDiagnoser\n) -> Callable[[phase_descriptor.PhaseT], phase_descriptor.PhaseDescriptor]:\n  \"\"\"Decorator to add diagnosers to a PhaseDescriptor.\"\"\"\n  check_diagnosers(diagnosers, BasePhaseDiagnoser)\n  diags = list(diagnosers)\n\n  def decorate(\n      wrapped_phase: phase_descriptor.PhaseT\n  ) -> phase_descriptor.PhaseDescriptor:\n    \"\"\"Phase decorator to be returned.\"\"\"\n    phase = phase_descriptor.PhaseDescriptor.wrap_or_copy(wrapped_phase)\n    phase.diagnosers.extend(diags)\n    return phase\n\n  return decorate\n",
        "source_code_len": 616,
        "target_code": "        attr.asdict(self, filter=_diagnosis_serialize_filter))\n",
        "target_code_len": 63,
        "diff_format": "@@ -549,19 +506,1 @@\n         attr.asdict(self, filter=_diagnosis_serialize_filter))\n-\n-\n-def diagnose(\n-    *diagnosers: BasePhaseDiagnoser\n-) -> Callable[[phase_descriptor.PhaseT], phase_descriptor.PhaseDescriptor]:\n-  \"\"\"Decorator to add diagnosers to a PhaseDescriptor.\"\"\"\n-  check_diagnosers(diagnosers, BasePhaseDiagnoser)\n-  diags = list(diagnosers)\n-\n-  def decorate(\n-      wrapped_phase: phase_descriptor.PhaseT\n-  ) -> phase_descriptor.PhaseDescriptor:\n-    \"\"\"Phase decorator to be returned.\"\"\"\n-    phase = phase_descriptor.PhaseDescriptor.wrap_or_copy(wrapped_phase)\n-    phase.diagnosers.extend(diags)\n-    return phase\n-\n-  return decorate\n",
        "source_code_with_indent": "        attr.asdict(self, filter=_diagnosis_serialize_filter))\n\n\n<DED><DED>def diagnose(\n    *diagnosers: BasePhaseDiagnoser\n) -> Callable[[phase_descriptor.PhaseT], phase_descriptor.PhaseDescriptor]:\n  <IND>\"\"\"Decorator to add diagnosers to a PhaseDescriptor.\"\"\"\n  check_diagnosers(diagnosers, BasePhaseDiagnoser)\n  diags = list(diagnosers)\n\n  def decorate(\n      wrapped_phase: phase_descriptor.PhaseT\n  ) -> phase_descriptor.PhaseDescriptor:\n    <IND>\"\"\"Phase decorator to be returned.\"\"\"\n    phase = phase_descriptor.PhaseDescriptor.wrap_or_copy(wrapped_phase)\n    phase.diagnosers.extend(diags)\n    return phase\n\n  <DED>return decorate\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "        attr.asdict(self, filter=_diagnosis_serialize_filter))\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "google/openhtf",
    "commit": "4646aa6b9ba67532ce7e8743ce16d7bd4369ad3d",
    "filename": "openhtf/core/measurements.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/google-openhtf/openhtf/core/measurements.py",
    "file_hunks_size": 14,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": true,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "openhtf/core/measurements.py:862:2 Incompatible variable type [9]: Unable to unpack `List[Measurement]`, expected a tuple.",
    "message": " Unable to unpack `List[Measurement]`, expected a tuple.",
    "rule_id": "Incompatible variable type [9]",
    "warning_line_no": 862,
    "warning_line": "  measurements = [_maybe_make(meas) for meas in measurements]",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": true,
        "has_suppression": false,
        "source_code": "del Collection._custom_setattr\n\n\ndef measures(\n    *measurements: Union[Text, Measurement], **kwargs: Any\n) -> Callable[[phase_descriptor.PhaseT], phase_descriptor.PhaseDescriptor]:\n  \"\"\"Decorator-maker used to declare measurements for phases.\n\n  See the measurements module docstring for examples of usage.\n\n  Args:\n    *measurements: Measurement objects to declare, or a string name from which\n      to create a Measurement.\n    **kwargs: Keyword arguments to pass to Measurement constructor if we're\n      constructing one.  Note that if kwargs are provided, the length of\n      measurements must be 1, and that value must be a string containing the\n      measurement name.  For valid kwargs, see the definition of the Measurement\n      class.\n\n  Raises:\n    InvalidMeasurementTypeError: When the measurement is not defined correctly.\n\n  Returns:\n    A decorator that declares the measurement(s) for the decorated phase.\n  \"\"\"\n\n  def _maybe_make(meas: Union[Text, Measurement]) -> Measurement:\n    \"\"\"Turn strings into Measurement objects if necessary.\"\"\"\n    if isinstance(meas, Measurement):\n      return meas\n    elif isinstance(meas, six.string_types):\n      return Measurement(meas, **kwargs)\n    raise InvalidMeasurementTypeError('Expected Measurement or string', meas)\n\n  # In case we're declaring a measurement inline, we can only declare one.\n  if kwargs and len(measurements) != 1:\n    raise InvalidMeasurementTypeError(\n        'If @measures kwargs are provided, a single measurement name must be '\n        'provided as a positional arg first.')\n\n  # Unlikely, but let's make sure we don't allow overriding initial outcome.\n  if 'outcome' in kwargs:\n    raise ValueError('Cannot specify outcome in measurement declaration!')\n\n  measurements = [_maybe_make(meas) for meas in measurements]\n\n  # 'measurements' is guaranteed to be a list of Measurement objects here.\n  def decorate(\n      wrapped_phase: phase_descriptor.PhaseT\n  ) -> phase_descriptor.PhaseDescriptor:\n    \"\"\"Phase decorator to be returned.\"\"\"\n    phase = phase_descriptor.PhaseDescriptor.wrap_or_copy(wrapped_phase)\n    duplicate_names = (\n        set(m.name for m in measurements)\n        & set(m.name for m in phase.measurements))\n    if duplicate_names:\n      raise DuplicateNameError('Measurement names duplicated', duplicate_names)\n\n    phase.measurements.extend(measurements)\n    return phase\n\n  return decorate\n",
        "source_code_len": 2397,
        "target_code": "del Collection._custom_setattr\n",
        "target_code_len": 31,
        "diff_format": "@@ -818,62 +829,1 @@\n del Collection._custom_setattr\n-\n-\n-def measures(\n-    *measurements: Union[Text, Measurement], **kwargs: Any\n-) -> Callable[[phase_descriptor.PhaseT], phase_descriptor.PhaseDescriptor]:\n-  \"\"\"Decorator-maker used to declare measurements for phases.\n-\n-  See the measurements module docstring for examples of usage.\n-\n-  Args:\n-    *measurements: Measurement objects to declare, or a string name from which\n-      to create a Measurement.\n-    **kwargs: Keyword arguments to pass to Measurement constructor if we're\n-      constructing one.  Note that if kwargs are provided, the length of\n-      measurements must be 1, and that value must be a string containing the\n-      measurement name.  For valid kwargs, see the definition of the Measurement\n-      class.\n-\n-  Raises:\n-    InvalidMeasurementTypeError: When the measurement is not defined correctly.\n-\n-  Returns:\n-    A decorator that declares the measurement(s) for the decorated phase.\n-  \"\"\"\n-\n-  def _maybe_make(meas: Union[Text, Measurement]) -> Measurement:\n-    \"\"\"Turn strings into Measurement objects if necessary.\"\"\"\n-    if isinstance(meas, Measurement):\n-      return meas\n-    elif isinstance(meas, six.string_types):\n-      return Measurement(meas, **kwargs)\n-    raise InvalidMeasurementTypeError('Expected Measurement or string', meas)\n-\n-  # In case we're declaring a measurement inline, we can only declare one.\n-  if kwargs and len(measurements) != 1:\n-    raise InvalidMeasurementTypeError(\n-        'If @measures kwargs are provided, a single measurement name must be '\n-        'provided as a positional arg first.')\n-\n-  # Unlikely, but let's make sure we don't allow overriding initial outcome.\n-  if 'outcome' in kwargs:\n-    raise ValueError('Cannot specify outcome in measurement declaration!')\n-\n-  measurements = [_maybe_make(meas) for meas in measurements]\n-\n-  # 'measurements' is guaranteed to be a list of Measurement objects here.\n-  def decorate(\n-      wrapped_phase: phase_descriptor.PhaseT\n-  ) -> phase_descriptor.PhaseDescriptor:\n-    \"\"\"Phase decorator to be returned.\"\"\"\n-    phase = phase_descriptor.PhaseDescriptor.wrap_or_copy(wrapped_phase)\n-    duplicate_names = (\n-        set(m.name for m in measurements)\n-        & set(m.name for m in phase.measurements))\n-    if duplicate_names:\n-      raise DuplicateNameError('Measurement names duplicated', duplicate_names)\n-\n-    phase.measurements.extend(measurements)\n-    return phase\n-\n-  return decorate\n",
        "source_code_with_indent": "del Collection._custom_setattr\n\n\ndef measures(\n    *measurements: Union[Text, Measurement], **kwargs: Any\n) -> Callable[[phase_descriptor.PhaseT], phase_descriptor.PhaseDescriptor]:\n  <IND>\"\"\"Decorator-maker used to declare measurements for phases.\n\n  See the measurements module docstring for examples of usage.\n\n  Args:\n    *measurements: Measurement objects to declare, or a string name from which\n      to create a Measurement.\n    **kwargs: Keyword arguments to pass to Measurement constructor if we're\n      constructing one.  Note that if kwargs are provided, the length of\n      measurements must be 1, and that value must be a string containing the\n      measurement name.  For valid kwargs, see the definition of the Measurement\n      class.\n\n  Raises:\n    InvalidMeasurementTypeError: When the measurement is not defined correctly.\n\n  Returns:\n    A decorator that declares the measurement(s) for the decorated phase.\n  \"\"\"\n\n  def _maybe_make(meas: Union[Text, Measurement]) -> Measurement:\n    <IND>\"\"\"Turn strings into Measurement objects if necessary.\"\"\"\n    if isinstance(meas, Measurement):\n      <IND>return meas\n    <DED>elif isinstance(meas, six.string_types):\n      <IND>return Measurement(meas, **kwargs)\n    <DED>raise InvalidMeasurementTypeError('Expected Measurement or string', meas)\n\n  # In case we're declaring a measurement inline, we can only declare one.\n  <DED>if kwargs and len(measurements) != 1:\n    <IND>raise InvalidMeasurementTypeError(\n        'If @measures kwargs are provided, a single measurement name must be '\n        'provided as a positional arg first.')\n\n  # Unlikely, but let's make sure we don't allow overriding initial outcome.\n  <DED>if 'outcome' in kwargs:\n    <IND>raise ValueError('Cannot specify outcome in measurement declaration!')\n\n  <DED>measurements = [_maybe_make(meas) for meas in measurements]\n\n  # 'measurements' is guaranteed to be a list of Measurement objects here.\n  def decorate(\n      wrapped_phase: phase_descriptor.PhaseT\n  ) -> phase_descriptor.PhaseDescriptor:\n    <IND>\"\"\"Phase decorator to be returned.\"\"\"\n    phase = phase_descriptor.PhaseDescriptor.wrap_or_copy(wrapped_phase)\n    duplicate_names = (\n        set(m.name for m in measurements)\n        & set(m.name for m in phase.measurements))\n    if duplicate_names:\n      <IND>raise DuplicateNameError('Measurement names duplicated', duplicate_names)\n\n    <DED>phase.measurements.extend(measurements)\n    return phase\n\n  <DED>return decorate\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "del Collection._custom_setattr\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "google/openhtf",
    "commit": "4646aa6b9ba67532ce7e8743ce16d7bd4369ad3d",
    "filename": "openhtf/core/phase_group.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/google-openhtf/openhtf/core/phase_group.py",
    "file_hunks_size": 1,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": true,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "openhtf/core/phase_group.py:144:11 Incompatible variable type [9]: name is declared to have type `str` but is used as type `None`.",
    "message": " name is declared to have type `str` but is used as type `None`.",
    "rule_id": "Incompatible variable type [9]",
    "warning_line_no": 144,
    "warning_line": "           name: Text = None) -> 'PhaseGroup':",
    "min_patch": [
      {
        "hunk_fit_TFix": true,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "           main_phases: phase_collections.SequenceInitializerT,\n           name: Text = None) -> 'PhaseGroup':\n    \"\"\"Returns PhaseGroup with additional main phases.\"\"\"\n",
        "source_code_len": 169,
        "target_code": "           main_phases: phase_collections.SequenceInitializerT,\n           name: Optional[Text] = None) -> 'PhaseGroup':\n    \"\"\"Returns PhaseGroup with additional main phases.\"\"\"\n",
        "target_code_len": 179,
        "diff_format": "@@ -143,3 +143,3 @@\n            main_phases: phase_collections.SequenceInitializerT,\n-           name: Text = None) -> 'PhaseGroup':\n+           name: Optional[Text] = None) -> 'PhaseGroup':\n     \"\"\"Returns PhaseGroup with additional main phases.\"\"\"\n",
        "source_code_with_indent": "           main_phases: phase_collections.SequenceInitializerT,\n           name: Text = None) -> 'PhaseGroup':\n    <IND>\"\"\"Returns PhaseGroup with additional main phases.\"\"\"\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "           main_phases: phase_collections.SequenceInitializerT,\n           name: Optional[Text] = None) -> 'PhaseGroup':\n    <IND>\"\"\"Returns PhaseGroup with additional main phases.\"\"\"\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "google/openhtf",
    "commit": "4646aa6b9ba67532ce7e8743ce16d7bd4369ad3d",
    "filename": "openhtf/plugs/__init__.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/google-openhtf/openhtf/plugs/__init__.py",
    "file_hunks_size": 1,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": true,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "openhtf/plugs/__init__.py:169:15 Incompatible variable type [9]: plug_types is declared to have type `Set[Type[base_plugs.BasePlug]]` but is used as type `None`.",
    "message": " plug_types is declared to have type `Set[Type[base_plugs.BasePlug]]` but is used as type `None`.",
    "rule_id": "Incompatible variable type [9]",
    "warning_line_no": 169,
    "warning_line": "               plug_types: Set[Type[base_plugs.BasePlug]] = None,",
    "min_patch": [
      {
        "hunk_fit_TFix": true,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "  def __init__(self,\n               plug_types: Set[Type[base_plugs.BasePlug]] = None,\n               record_logger: Optional[logging.Logger] = None):\n",
        "source_code_len": 151,
        "target_code": "  def __init__(self,\n               plug_types: Optional[Set[Type[base_plugs.BasePlug]]] = None,\n               record_logger: Optional[logging.Logger] = None):\n",
        "target_code_len": 161,
        "diff_format": "@@ -168,3 +168,3 @@\n   def __init__(self,\n-               plug_types: Set[Type[base_plugs.BasePlug]] = None,\n+               plug_types: Optional[Set[Type[base_plugs.BasePlug]]] = None,\n                record_logger: Optional[logging.Logger] = None):\n",
        "source_code_with_indent": "  def __init__(self,\n               plug_types: Set[Type[base_plugs.BasePlug]] = None,\n               record_logger: Optional[logging.Logger] = None):\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "  def __init__(self,\n               plug_types: Optional[Set[Type[base_plugs.BasePlug]]] = None,\n               record_logger: Optional[logging.Logger] = None):\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  }
]