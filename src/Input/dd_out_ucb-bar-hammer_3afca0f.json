[
  {
    "project": "ucb-bar/hammer",
    "commit": "3afca0f00301e87b3112d42284a6acfd3c083c42",
    "filename": "src/hammer-vlsi/hammer_vlsi/hammer_vlsi_impl.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/ucb-bar-hammer/src/hammer-vlsi/hammer_vlsi/hammer_vlsi_impl.py",
    "file_hunks_size": 13,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": true,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "src/hammer-vlsi/hammer_vlsi/hammer_vlsi_impl.py:1554:99 Invalid type [31]: Expression `src.hammer.__sub__(vlsi.hammer_vlsi.constraints.Optional[src.hammer.__sub__(vlsi.hammer_vlsi.constraints.List[typing.Callable[([hammer_tech.Library], bool)]])])` is not a valid type.",
    "message": " Expression `src.hammer.__sub__(vlsi.hammer_vlsi.constraints.Optional[src.hammer.__sub__(vlsi.hammer_vlsi.constraints.List[typing.Callable[([hammer_tech.Library], bool)]])])` is not a valid type.",
    "rule_id": "Invalid type [31]",
    "warning_line_no": 1554,
    "warning_line": "                                                                           temp=c.temp)])  # type: Optional[List[Callable[[hammer_tech.Library],bool]]]",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": true,
        "has_suppression": false,
        "source_code": "        self.tcl_append(cmd, self.output, clean)\n\n\nclass CadenceTool(HasSDCSupport, HasCPFSupport, HasUPFSupport, TCLTool, HammerTool):\n    \"\"\"Mix-in trait with functions useful for Cadence-based tools.\"\"\"\n\n    @property\n    def config_dirs(self) -> List[str]:\n        # Override this to pull in Cadence-common configs.\n        return [self.get_setting(\"cadence.common_path\")] + super().config_dirs\n\n    @property\n    def env_vars(self) -> Dict[str, str]:\n        \"\"\"\n        Get the list of environment variables required for this tool.\n        Note to subclasses: remember to include variables from super().env_vars!\n        \"\"\"\n        # Use the base extra_env_variables and ensure that our custom variables are on top.\n        list_of_vars = self.get_setting(\"cadence.extra_env_vars\")  # type: List[Dict[str, Any]]\n        assert isinstance(list_of_vars, list)\n\n        cadence_vars = {\n            \"CDS_LIC_FILE\": self.get_setting(\"cadence.CDS_LIC_FILE\"),\n            \"CADENCE_HOME\": self.get_setting(\"cadence.cadence_home\")\n        }\n\n        return reduce(add_dicts, [dict(super().env_vars)] + list_of_vars + [cadence_vars], {})\n\n    def version_number(self, version: str) -> int:\n        \"\"\"\n        Assumes versions look like MAJOR_ISRMINOR and we will have less than 100 minor versions.\n        \"\"\"\n        main_version = int(version.split(\"_\")[0]) # type: int\n        minor_version = 0 # type: int\n        if \"_\" in version:\n            minor_version = int(version.split(\"_\")[1][3:])\n        return main_version * 100 + minor_version\n\n    def get_timing_libs(self, corner: Optional[MMMCCorner] = None) -> str:\n        \"\"\"\n        Helper function to get the list of ASCII timing .lib files in space separated format.\n        Note that Cadence tools support ECSM, so we can use the ECSM-based filter.\n\n        :param corner: Optional corner to consider. If supplied, this will use filter_for_mmmc to select libraries that\n        match a given corner (voltage/temperature).\n        :return: List of lib files separated by spaces\n        \"\"\"\n        pre_filters = optional_map(corner, lambda c: [self.filter_for_mmmc(voltage=c.voltage,\n                                                                           temp=c.temp)])  # type: Optional[List[Callable[[hammer_tech.Library],bool]]]\n\n        lib_args = self.technology.read_libs([hammer_tech.filters.timing_lib_with_ecsm_filter],\n                                             hammer_tech.HammerTechnologyUtils.to_plain_item,\n                                             extra_pre_filters=pre_filters)\n        return \" \".join(lib_args)\n\n    def get_mmmc_qrc(self, corner: MMMCCorner) -> str:\n        lib_args = self.technology.read_libs([hammer_tech.filters.qrc_tech_filter],\n                                             hammer_tech.HammerTechnologyUtils.to_plain_item,\n                                             extra_pre_filters=[\n                                                 self.filter_for_mmmc(voltage=corner.voltage, temp=corner.temp)])\n        return \" \".join(lib_args)\n\n    def get_qrc_tech(self) -> str:\n        \"\"\"\n        Helper function to get the list of rc corner tech files in space separated format.\n\n        :return: List of qrc tech files separated by spaces\n        \"\"\"\n        lib_args = self.technology.read_libs([\n            hammer_tech.filters.qrc_tech_filter\n        ], hammer_tech.HammerTechnologyUtils.to_plain_item)\n        return \" \".join(lib_args)\n\n    def generate_mmmc_script(self) -> str:\n        \"\"\"\n        Output for the mmmc.tcl script.\n        Innovus (init_design) requires that the timing script be placed in a separate file.\n\n        :return: Contents of the mmmc script.\n        \"\"\"\n        mmmc_output = []  # type: List[str]\n\n        def append_mmmc(cmd: str) -> None:\n            self.verbose_tcl_append(cmd, mmmc_output)\n\n        # Create an Innovus constraint mode.\n        constraint_mode = \"my_constraint_mode\"\n        sdc_files = []  # type: List[str]\n\n        # Generate constraints\n        clock_constraints_fragment = os.path.join(self.run_dir, \"clock_constraints_fragment.sdc\")\n        with open(clock_constraints_fragment, \"w\") as f:\n            f.write(self.sdc_clock_constraints)\n        sdc_files.append(clock_constraints_fragment)\n\n        # Generate port constraints.\n        pin_constraints_fragment = os.path.join(self.run_dir, \"pin_constraints_fragment.sdc\")\n        with open(pin_constraints_fragment, \"w\") as f:\n            f.write(self.sdc_pin_constraints)\n        sdc_files.append(pin_constraints_fragment)\n\n        # Add the post-synthesis SDC, if present.\n        post_synth_sdc = self.post_synth_sdc\n        if post_synth_sdc is not None:\n            sdc_files.append(post_synth_sdc)\n\n        # TODO: add floorplanning SDC\n        if len(sdc_files) > 0:\n            sdc_files_arg = \"-sdc_files [list {sdc_files}]\".format(\n                sdc_files=\" \".join(sdc_files)\n            )\n        else:\n            blank_sdc = os.path.join(self.run_dir, \"blank.sdc\")\n            self.run_executable([\"touch\", blank_sdc])\n            sdc_files_arg = \"-sdc_files {{ {} }}\".format(blank_sdc)\n        append_mmmc(\"create_constraint_mode -name {name} {sdc_files_arg}\".format(\n            name=constraint_mode,\n            sdc_files_arg=sdc_files_arg\n        ))\n\n        corners = self.get_mmmc_corners()  # type: List[MMMCCorner]\n        # In parallel, create the delay corners\n        if corners:\n            setup_corner = corners[0]  # type: MMMCCorner\n            hold_corner = corners[0]  # type: MMMCCorner\n            # TODO(colins): handle more than one corner and do something with extra corners\n            for corner in corners:\n                if corner.type is MMMCCornerType.Setup:\n                    setup_corner = corner\n                if corner.type is MMMCCornerType.Hold:\n                    hold_corner = corner\n\n            # First, create Innovus library sets\n            append_mmmc(\"create_library_set -name {name} -timing [list {list}]\".format(\n                name=\"{n}.setup_set\".format(n=setup_corner.name),\n                list=self.get_timing_libs(setup_corner)\n            ))\n            append_mmmc(\"create_library_set -name {name} -timing [list {list}]\".format(\n                name=\"{n}.hold_set\".format(n=hold_corner.name),\n                list=self.get_timing_libs(hold_corner)\n            ))\n            # Skip opconds for now\n            # Next, create Innovus timing conditions\n            append_mmmc(\"create_timing_condition -name {name} -library_sets [list {list}]\".format(\n                name=\"{n}.setup_cond\".format(n=setup_corner.name),\n                list=\"{n}.setup_set\".format(n=setup_corner.name)\n            ))\n            append_mmmc(\"create_timing_condition -name {name} -library_sets [list {list}]\".format(\n                name=\"{n}.hold_cond\".format(n=hold_corner.name),\n                list=\"{n}.hold_set\".format(n=hold_corner.name)\n            ))\n            # Next, create Innovus rc corners from qrc tech files\n            append_mmmc(\"create_rc_corner -name {name} -temperature {tempInCelsius} {qrc}\".format(\n                name=\"{n}.setup_rc\".format(n=setup_corner.name),\n                tempInCelsius=str(setup_corner.temp.value),\n                qrc=\"-qrc_tech {}\".format(self.get_mmmc_qrc(setup_corner)) if self.get_mmmc_qrc(setup_corner) != '' else ''\n            ))\n            append_mmmc(\"create_rc_corner -name {name} -temperature {tempInCelsius} {qrc}\".format(\n                name=\"{n}.hold_rc\".format(n=hold_corner.name),\n                tempInCelsius=str(hold_corner.temp.value),\n                qrc=\"-qrc_tech {}\".format(self.get_mmmc_qrc(hold_corner)) if self.get_mmmc_qrc(hold_corner) != '' else ''\n            ))\n            # Next, create an Innovus delay corner.\n            append_mmmc(\n                \"create_delay_corner -name {name}_delay -timing_condition {name}_cond -rc_corner {name}_rc\".format(\n                    name=\"{n}.setup\".format(n=setup_corner.name)\n                ))\n            append_mmmc(\n                \"create_delay_corner -name {name}_delay -timing_condition {name}_cond -rc_corner {name}_rc\".format(\n                    name=\"{n}.hold\".format(n=hold_corner.name)\n                ))\n            # Next, create the analysis views\n            append_mmmc(\"create_analysis_view -name {name}_view -delay_corner {name}_delay -constraint_mode {constraint}\".format(\n                name=\"{n}.setup\".format(n=setup_corner.name), constraint=constraint_mode))\n            append_mmmc(\"create_analysis_view -name {name}_view -delay_corner {name}_delay -constraint_mode {constraint}\".format(\n                name=\"{n}.hold\".format(n=hold_corner.name), constraint=constraint_mode))\n            # Finally, apply the analysis view.\n            append_mmmc(\"set_analysis_view -setup {{ {setup_view} }} -hold {{ {hold_view} }}\".format(\n                setup_view=\"{n}.setup_view\".format(n=setup_corner.name),\n                hold_view=\"{n}.hold_view\".format(n=hold_corner.name)\n            ))\n        else:\n            # First, create an Innovus library set.\n            library_set_name = \"my_lib_set\"\n            append_mmmc(\"create_library_set -name {name} -timing [list {list}]\".format(\n                name=library_set_name,\n                list=self.get_timing_libs()\n            ))\n            # Next, create an Innovus timing condition.\n            timing_condition_name = \"my_timing_condition\"\n            append_mmmc(\"create_timing_condition -name {name} -library_sets [list {list}]\".format(\n                name=timing_condition_name,\n                list=library_set_name\n            ))\n            # extra junk: -opcond ...\n            rc_corner_name = \"rc_cond\"\n            append_mmmc(\"create_rc_corner -name {name} -temperature {tempInCelsius} {qrc}\".format(\n                name=rc_corner_name,\n                tempInCelsius=120,  # TODO: this should come from tech config\n                qrc=\"-qrc_tech {}\".format(self.get_qrc_tech()) if self.get_qrc_tech() != '' else ''\n            ))\n            # Next, create an Innovus delay corner.\n            delay_corner_name = \"my_delay_corner\"\n            append_mmmc(\n                \"create_delay_corner -name {name} -timing_condition {timing_cond} -rc_corner {rc}\".format(\n                    name=delay_corner_name,\n                    timing_cond=timing_condition_name,\n                    rc=rc_corner_name\n                ))\n            # extra junk: -rc_corner my_rc_corner_maybe_worst\n            # Next, create an Innovus analysis view.\n            analysis_view_name = \"my_view\"\n            append_mmmc(\"create_analysis_view -name {name} -delay_corner {corner} -constraint_mode {constraint}\".format(\n                name=analysis_view_name, corner=delay_corner_name, constraint=constraint_mode))\n            # Finally, apply the analysis view.\n            # TODO: introduce different views of setup/hold and true multi-corner\n            append_mmmc(\"set_analysis_view -setup {{ {setup_view} }} -hold {{ {hold_view} }}\".format(\n                setup_view=analysis_view_name,\n                hold_view=analysis_view_name\n            ))\n\n        return \"\\n\".join(mmmc_output)\n\n    def generate_dont_use_commands(self) -> List[str]:\n        \"\"\"\n        Generate a list of dont_use commands for Cadence tools.\n        \"\"\"\n\n        def map_cell(in_cell: str) -> str:\n            # \"*/\" is needed for \"get_db lib_cells <cell_expression>\"\n            if in_cell.startswith(\"*/\"):\n                mapped_cell = in_cell  # type: str\n            else:\n                mapped_cell = \"*/\" + in_cell\n\n            # Check for cell existence first to avoid Genus erroring out.\n            get_db_str = \"[get_db lib_cells {mapped_cell}]\".format(mapped_cell=mapped_cell)\n            # Escaped version for puts.\n            get_db_str_escaped = get_db_str.replace('[', '\\[').replace(']', '\\]')\n            return \"\"\"\nputs \"set_dont_use {get_db_str_escaped}\"\nif {{ {get_db_str} ne \"\" }} {{\n    set_dont_use {get_db_str}\n}} else {{\n    puts \"WARNING: cell {mapped_cell} was not found for set_dont_use\"\n}}\n            \"\"\".format(get_db_str=get_db_str, get_db_str_escaped=get_db_str_escaped, mapped_cell=mapped_cell)\n\n        return list(map(map_cell, self.get_dont_use_list()))\n\n    def generate_power_spec_commands(self) -> List[str]:\n        \"\"\"\n        Generate commands to load a power specification for Cadence tools.\n        \"\"\"\n\n        power_spec_type = str(self.get_setting(\"vlsi.inputs.power_spec_type\"))  # type: str\n        power_spec_arg = \"\"  # type: str\n        if power_spec_type == \"cpf\":\n            power_spec_arg = \"cpf\"\n        elif power_spec_type == \"upf\":\n            power_spec_arg = \"1801\"\n        else:\n            self.logger.error(\n                \"Invalid power specification type '{tpe}'; only 'cpf' or 'upf' supported\".format(tpe=power_spec_type))\n            return []\n\n        power_spec_contents = \"\"  # type: str\n        power_spec_mode = str(self.get_setting(\"vlsi.inputs.power_spec_mode\"))  # type: str\n        if power_spec_mode == \"empty\":\n            return []\n        elif power_spec_mode == \"auto\":\n            if power_spec_type == \"cpf\":\n                power_spec_contents = self.cpf_power_specification\n            elif power_spec_type == \"upf\":\n                power_spec_contents = self.upf_power_specification\n        elif power_spec_mode == \"manual\":\n            power_spec_contents = str(self.get_setting(\"vlsi.inputs.power_spec_contents\"))\n        else:\n            self.logger.error(\"Invalid power specification mode '{mode}'; using 'empty'.\".format(mode=power_spec_mode))\n            return []\n\n        # Write the power spec contents to file and include it\n        power_spec_file = os.path.join(self.run_dir, \"power_spec.{tpe}\".format(tpe=power_spec_type))\n        with open(power_spec_file, \"w\") as f:\n            f.write(power_spec_contents)\n        return [\"read_power_intent -{arg} {path}\".format(arg=power_spec_arg, path=power_spec_file),\n                \"commit_power_intent\"]\n\n\n",
        "source_code_len": 14014,
        "target_code": "        self.tcl_append(cmd, self.output, clean)\n\n",
        "target_code_len": 50,
        "diff_format": "@@ -1506,289 +1506,2 @@\n         self.tcl_append(cmd, self.output, clean)\n-\n-\n-class CadenceTool(HasSDCSupport, HasCPFSupport, HasUPFSupport, TCLTool, HammerTool):\n-    \"\"\"Mix-in trait with functions useful for Cadence-based tools.\"\"\"\n-\n-    @property\n-    def config_dirs(self) -> List[str]:\n-        # Override this to pull in Cadence-common configs.\n-        return [self.get_setting(\"cadence.common_path\")] + super().config_dirs\n-\n-    @property\n-    def env_vars(self) -> Dict[str, str]:\n-        \"\"\"\n-        Get the list of environment variables required for this tool.\n-        Note to subclasses: remember to include variables from super().env_vars!\n-        \"\"\"\n-        # Use the base extra_env_variables and ensure that our custom variables are on top.\n-        list_of_vars = self.get_setting(\"cadence.extra_env_vars\")  # type: List[Dict[str, Any]]\n-        assert isinstance(list_of_vars, list)\n-\n-        cadence_vars = {\n-            \"CDS_LIC_FILE\": self.get_setting(\"cadence.CDS_LIC_FILE\"),\n-            \"CADENCE_HOME\": self.get_setting(\"cadence.cadence_home\")\n-        }\n-\n-        return reduce(add_dicts, [dict(super().env_vars)] + list_of_vars + [cadence_vars], {})\n-\n-    def version_number(self, version: str) -> int:\n-        \"\"\"\n-        Assumes versions look like MAJOR_ISRMINOR and we will have less than 100 minor versions.\n-        \"\"\"\n-        main_version = int(version.split(\"_\")[0]) # type: int\n-        minor_version = 0 # type: int\n-        if \"_\" in version:\n-            minor_version = int(version.split(\"_\")[1][3:])\n-        return main_version * 100 + minor_version\n-\n-    def get_timing_libs(self, corner: Optional[MMMCCorner] = None) -> str:\n-        \"\"\"\n-        Helper function to get the list of ASCII timing .lib files in space separated format.\n-        Note that Cadence tools support ECSM, so we can use the ECSM-based filter.\n-\n-        :param corner: Optional corner to consider. If supplied, this will use filter_for_mmmc to select libraries that\n-        match a given corner (voltage/temperature).\n-        :return: List of lib files separated by spaces\n-        \"\"\"\n-        pre_filters = optional_map(corner, lambda c: [self.filter_for_mmmc(voltage=c.voltage,\n-                                                                           temp=c.temp)])  # type: Optional[List[Callable[[hammer_tech.Library],bool]]]\n-\n-        lib_args = self.technology.read_libs([hammer_tech.filters.timing_lib_with_ecsm_filter],\n-                                             hammer_tech.HammerTechnologyUtils.to_plain_item,\n-                                             extra_pre_filters=pre_filters)\n-        return \" \".join(lib_args)\n-\n-    def get_mmmc_qrc(self, corner: MMMCCorner) -> str:\n-        lib_args = self.technology.read_libs([hammer_tech.filters.qrc_tech_filter],\n-                                             hammer_tech.HammerTechnologyUtils.to_plain_item,\n-                                             extra_pre_filters=[\n-                                                 self.filter_for_mmmc(voltage=corner.voltage, temp=corner.temp)])\n-        return \" \".join(lib_args)\n-\n-    def get_qrc_tech(self) -> str:\n-        \"\"\"\n-        Helper function to get the list of rc corner tech files in space separated format.\n-\n-        :return: List of qrc tech files separated by spaces\n-        \"\"\"\n-        lib_args = self.technology.read_libs([\n-            hammer_tech.filters.qrc_tech_filter\n-        ], hammer_tech.HammerTechnologyUtils.to_plain_item)\n-        return \" \".join(lib_args)\n-\n-    def generate_mmmc_script(self) -> str:\n-        \"\"\"\n-        Output for the mmmc.tcl script.\n-        Innovus (init_design) requires that the timing script be placed in a separate file.\n-\n-        :return: Contents of the mmmc script.\n-        \"\"\"\n-        mmmc_output = []  # type: List[str]\n-\n-        def append_mmmc(cmd: str) -> None:\n-            self.verbose_tcl_append(cmd, mmmc_output)\n-\n-        # Create an Innovus constraint mode.\n-        constraint_mode = \"my_constraint_mode\"\n-        sdc_files = []  # type: List[str]\n-\n-        # Generate constraints\n-        clock_constraints_fragment = os.path.join(self.run_dir, \"clock_constraints_fragment.sdc\")\n-        with open(clock_constraints_fragment, \"w\") as f:\n-            f.write(self.sdc_clock_constraints)\n-        sdc_files.append(clock_constraints_fragment)\n-\n-        # Generate port constraints.\n-        pin_constraints_fragment = os.path.join(self.run_dir, \"pin_constraints_fragment.sdc\")\n-        with open(pin_constraints_fragment, \"w\") as f:\n-            f.write(self.sdc_pin_constraints)\n-        sdc_files.append(pin_constraints_fragment)\n-\n-        # Add the post-synthesis SDC, if present.\n-        post_synth_sdc = self.post_synth_sdc\n-        if post_synth_sdc is not None:\n-            sdc_files.append(post_synth_sdc)\n-\n-        # TODO: add floorplanning SDC\n-        if len(sdc_files) > 0:\n-            sdc_files_arg = \"-sdc_files [list {sdc_files}]\".format(\n-                sdc_files=\" \".join(sdc_files)\n-            )\n-        else:\n-            blank_sdc = os.path.join(self.run_dir, \"blank.sdc\")\n-            self.run_executable([\"touch\", blank_sdc])\n-            sdc_files_arg = \"-sdc_files {{ {} }}\".format(blank_sdc)\n-        append_mmmc(\"create_constraint_mode -name {name} {sdc_files_arg}\".format(\n-            name=constraint_mode,\n-            sdc_files_arg=sdc_files_arg\n-        ))\n-\n-        corners = self.get_mmmc_corners()  # type: List[MMMCCorner]\n-        # In parallel, create the delay corners\n-        if corners:\n-            setup_corner = corners[0]  # type: MMMCCorner\n-            hold_corner = corners[0]  # type: MMMCCorner\n-            # TODO(colins): handle more than one corner and do something with extra corners\n-            for corner in corners:\n-                if corner.type is MMMCCornerType.Setup:\n-                    setup_corner = corner\n-                if corner.type is MMMCCornerType.Hold:\n-                    hold_corner = corner\n-\n-            # First, create Innovus library sets\n-            append_mmmc(\"create_library_set -name {name} -timing [list {list}]\".format(\n-                name=\"{n}.setup_set\".format(n=setup_corner.name),\n-                list=self.get_timing_libs(setup_corner)\n-            ))\n-            append_mmmc(\"create_library_set -name {name} -timing [list {list}]\".format(\n-                name=\"{n}.hold_set\".format(n=hold_corner.name),\n-                list=self.get_timing_libs(hold_corner)\n-            ))\n-            # Skip opconds for now\n-            # Next, create Innovus timing conditions\n-            append_mmmc(\"create_timing_condition -name {name} -library_sets [list {list}]\".format(\n-                name=\"{n}.setup_cond\".format(n=setup_corner.name),\n-                list=\"{n}.setup_set\".format(n=setup_corner.name)\n-            ))\n-            append_mmmc(\"create_timing_condition -name {name} -library_sets [list {list}]\".format(\n-                name=\"{n}.hold_cond\".format(n=hold_corner.name),\n-                list=\"{n}.hold_set\".format(n=hold_corner.name)\n-            ))\n-            # Next, create Innovus rc corners from qrc tech files\n-            append_mmmc(\"create_rc_corner -name {name} -temperature {tempInCelsius} {qrc}\".format(\n-                name=\"{n}.setup_rc\".format(n=setup_corner.name),\n-                tempInCelsius=str(setup_corner.temp.value),\n-                qrc=\"-qrc_tech {}\".format(self.get_mmmc_qrc(setup_corner)) if self.get_mmmc_qrc(setup_corner) != '' else ''\n-            ))\n-            append_mmmc(\"create_rc_corner -name {name} -temperature {tempInCelsius} {qrc}\".format(\n-                name=\"{n}.hold_rc\".format(n=hold_corner.name),\n-                tempInCelsius=str(hold_corner.temp.value),\n-                qrc=\"-qrc_tech {}\".format(self.get_mmmc_qrc(hold_corner)) if self.get_mmmc_qrc(hold_corner) != '' else ''\n-            ))\n-            # Next, create an Innovus delay corner.\n-            append_mmmc(\n-                \"create_delay_corner -name {name}_delay -timing_condition {name}_cond -rc_corner {name}_rc\".format(\n-                    name=\"{n}.setup\".format(n=setup_corner.name)\n-                ))\n-            append_mmmc(\n-                \"create_delay_corner -name {name}_delay -timing_condition {name}_cond -rc_corner {name}_rc\".format(\n-                    name=\"{n}.hold\".format(n=hold_corner.name)\n-                ))\n-            # Next, create the analysis views\n-            append_mmmc(\"create_analysis_view -name {name}_view -delay_corner {name}_delay -constraint_mode {constraint}\".format(\n-                name=\"{n}.setup\".format(n=setup_corner.name), constraint=constraint_mode))\n-            append_mmmc(\"create_analysis_view -name {name}_view -delay_corner {name}_delay -constraint_mode {constraint}\".format(\n-                name=\"{n}.hold\".format(n=hold_corner.name), constraint=constraint_mode))\n-            # Finally, apply the analysis view.\n-            append_mmmc(\"set_analysis_view -setup {{ {setup_view} }} -hold {{ {hold_view} }}\".format(\n-                setup_view=\"{n}.setup_view\".format(n=setup_corner.name),\n-                hold_view=\"{n}.hold_view\".format(n=hold_corner.name)\n-            ))\n-        else:\n-            # First, create an Innovus library set.\n-            library_set_name = \"my_lib_set\"\n-            append_mmmc(\"create_library_set -name {name} -timing [list {list}]\".format(\n-                name=library_set_name,\n-                list=self.get_timing_libs()\n-            ))\n-            # Next, create an Innovus timing condition.\n-            timing_condition_name = \"my_timing_condition\"\n-            append_mmmc(\"create_timing_condition -name {name} -library_sets [list {list}]\".format(\n-                name=timing_condition_name,\n-                list=library_set_name\n-            ))\n-            # extra junk: -opcond ...\n-            rc_corner_name = \"rc_cond\"\n-            append_mmmc(\"create_rc_corner -name {name} -temperature {tempInCelsius} {qrc}\".format(\n-                name=rc_corner_name,\n-                tempInCelsius=120,  # TODO: this should come from tech config\n-                qrc=\"-qrc_tech {}\".format(self.get_qrc_tech()) if self.get_qrc_tech() != '' else ''\n-            ))\n-            # Next, create an Innovus delay corner.\n-            delay_corner_name = \"my_delay_corner\"\n-            append_mmmc(\n-                \"create_delay_corner -name {name} -timing_condition {timing_cond} -rc_corner {rc}\".format(\n-                    name=delay_corner_name,\n-                    timing_cond=timing_condition_name,\n-                    rc=rc_corner_name\n-                ))\n-            # extra junk: -rc_corner my_rc_corner_maybe_worst\n-            # Next, create an Innovus analysis view.\n-            analysis_view_name = \"my_view\"\n-            append_mmmc(\"create_analysis_view -name {name} -delay_corner {corner} -constraint_mode {constraint}\".format(\n-                name=analysis_view_name, corner=delay_corner_name, constraint=constraint_mode))\n-            # Finally, apply the analysis view.\n-            # TODO: introduce different views of setup/hold and true multi-corner\n-            append_mmmc(\"set_analysis_view -setup {{ {setup_view} }} -hold {{ {hold_view} }}\".format(\n-                setup_view=analysis_view_name,\n-                hold_view=analysis_view_name\n-            ))\n-\n-        return \"\\n\".join(mmmc_output)\n-\n-    def generate_dont_use_commands(self) -> List[str]:\n-        \"\"\"\n-        Generate a list of dont_use commands for Cadence tools.\n-        \"\"\"\n-\n-        def map_cell(in_cell: str) -> str:\n-            # \"*/\" is needed for \"get_db lib_cells <cell_expression>\"\n-            if in_cell.startswith(\"*/\"):\n-                mapped_cell = in_cell  # type: str\n-            else:\n-                mapped_cell = \"*/\" + in_cell\n-\n-            # Check for cell existence first to avoid Genus erroring out.\n-            get_db_str = \"[get_db lib_cells {mapped_cell}]\".format(mapped_cell=mapped_cell)\n-            # Escaped version for puts.\n-            get_db_str_escaped = get_db_str.replace('[', '\\[').replace(']', '\\]')\n-            return \"\"\"\n-puts \"set_dont_use {get_db_str_escaped}\"\n-if {{ {get_db_str} ne \"\" }} {{\n-    set_dont_use {get_db_str}\n-}} else {{\n-    puts \"WARNING: cell {mapped_cell} was not found for set_dont_use\"\n-}}\n-            \"\"\".format(get_db_str=get_db_str, get_db_str_escaped=get_db_str_escaped, mapped_cell=mapped_cell)\n-\n-        return list(map(map_cell, self.get_dont_use_list()))\n-\n-    def generate_power_spec_commands(self) -> List[str]:\n-        \"\"\"\n-        Generate commands to load a power specification for Cadence tools.\n-        \"\"\"\n-\n-        power_spec_type = str(self.get_setting(\"vlsi.inputs.power_spec_type\"))  # type: str\n-        power_spec_arg = \"\"  # type: str\n-        if power_spec_type == \"cpf\":\n-            power_spec_arg = \"cpf\"\n-        elif power_spec_type == \"upf\":\n-            power_spec_arg = \"1801\"\n-        else:\n-            self.logger.error(\n-                \"Invalid power specification type '{tpe}'; only 'cpf' or 'upf' supported\".format(tpe=power_spec_type))\n-            return []\n-\n-        power_spec_contents = \"\"  # type: str\n-        power_spec_mode = str(self.get_setting(\"vlsi.inputs.power_spec_mode\"))  # type: str\n-        if power_spec_mode == \"empty\":\n-            return []\n-        elif power_spec_mode == \"auto\":\n-            if power_spec_type == \"cpf\":\n-                power_spec_contents = self.cpf_power_specification\n-            elif power_spec_type == \"upf\":\n-                power_spec_contents = self.upf_power_specification\n-        elif power_spec_mode == \"manual\":\n-            power_spec_contents = str(self.get_setting(\"vlsi.inputs.power_spec_contents\"))\n-        else:\n-            self.logger.error(\"Invalid power specification mode '{mode}'; using 'empty'.\".format(mode=power_spec_mode))\n-            return []\n-\n-        # Write the power spec contents to file and include it\n-        power_spec_file = os.path.join(self.run_dir, \"power_spec.{tpe}\".format(tpe=power_spec_type))\n-        with open(power_spec_file, \"w\") as f:\n-            f.write(power_spec_contents)\n-        return [\"read_power_intent -{arg} {path}\".format(arg=power_spec_arg, path=power_spec_file),\n-                \"commit_power_intent\"]\n-\n \n",
        "source_code_with_indent": "        <IND>self.tcl_append(cmd, self.output, clean)\n\n\n<DED><DED>class CadenceTool(HasSDCSupport, HasCPFSupport, HasUPFSupport, TCLTool, HammerTool):\n    <IND>\"\"\"Mix-in trait with functions useful for Cadence-based tools.\"\"\"\n\n    @property\n    def config_dirs(self) -> List[str]:\n        # Override this to pull in Cadence-common configs.\n        <IND>return [self.get_setting(\"cadence.common_path\")] + super().config_dirs\n\n    <DED>@property\n    def env_vars(self) -> Dict[str, str]:\n        <IND>\"\"\"\n        Get the list of environment variables required for this tool.\n        Note to subclasses: remember to include variables from super().env_vars!\n        \"\"\"\n        # Use the base extra_env_variables and ensure that our custom variables are on top.\n        list_of_vars = self.get_setting(\"cadence.extra_env_vars\")  # type: List[Dict[str, Any]]\n        assert isinstance(list_of_vars, list)\n\n        cadence_vars = {\n            \"CDS_LIC_FILE\": self.get_setting(\"cadence.CDS_LIC_FILE\"),\n            \"CADENCE_HOME\": self.get_setting(\"cadence.cadence_home\")\n        }\n\n        return reduce(add_dicts, [dict(super().env_vars)] + list_of_vars + [cadence_vars], {})\n\n    <DED>def version_number(self, version: str) -> int:\n        <IND>\"\"\"\n        Assumes versions look like MAJOR_ISRMINOR and we will have less than 100 minor versions.\n        \"\"\"\n        main_version = int(version.split(\"_\")[0]) # type: int\n        minor_version = 0 # type: int\n        if \"_\" in version:\n            <IND>minor_version = int(version.split(\"_\")[1][3:])\n        <DED>return main_version * 100 + minor_version\n\n    <DED>def get_timing_libs(self, corner: Optional[MMMCCorner] = None) -> str:\n        <IND>\"\"\"\n        Helper function to get the list of ASCII timing .lib files in space separated format.\n        Note that Cadence tools support ECSM, so we can use the ECSM-based filter.\n\n        :param corner: Optional corner to consider. If supplied, this will use filter_for_mmmc to select libraries that\n        match a given corner (voltage/temperature).\n        :return: List of lib files separated by spaces\n        \"\"\"\n        pre_filters = optional_map(corner, lambda c: [self.filter_for_mmmc(voltage=c.voltage,\n                                                                           temp=c.temp)])  # type: Optional[List[Callable[[hammer_tech.Library],bool]]]\n\n        lib_args = self.technology.read_libs([hammer_tech.filters.timing_lib_with_ecsm_filter],\n                                             hammer_tech.HammerTechnologyUtils.to_plain_item,\n                                             extra_pre_filters=pre_filters)\n        return \" \".join(lib_args)\n\n    <DED>def get_mmmc_qrc(self, corner: MMMCCorner) -> str:\n        <IND>lib_args = self.technology.read_libs([hammer_tech.filters.qrc_tech_filter],\n                                             hammer_tech.HammerTechnologyUtils.to_plain_item,\n                                             extra_pre_filters=[\n                                                 self.filter_for_mmmc(voltage=corner.voltage, temp=corner.temp)])\n        return \" \".join(lib_args)\n\n    <DED>def get_qrc_tech(self) -> str:\n        <IND>\"\"\"\n        Helper function to get the list of rc corner tech files in space separated format.\n\n        :return: List of qrc tech files separated by spaces\n        \"\"\"\n        lib_args = self.technology.read_libs([\n            hammer_tech.filters.qrc_tech_filter\n        ], hammer_tech.HammerTechnologyUtils.to_plain_item)\n        return \" \".join(lib_args)\n\n    <DED>def generate_mmmc_script(self) -> str:\n        <IND>\"\"\"\n        Output for the mmmc.tcl script.\n        Innovus (init_design) requires that the timing script be placed in a separate file.\n\n        :return: Contents of the mmmc script.\n        \"\"\"\n        mmmc_output = []  # type: List[str]\n\n        def append_mmmc(cmd: str) -> None:\n            <IND>self.verbose_tcl_append(cmd, mmmc_output)\n\n        # Create an Innovus constraint mode.\n        <DED>constraint_mode = \"my_constraint_mode\"\n        sdc_files = []  # type: List[str]\n\n        # Generate constraints\n        clock_constraints_fragment = os.path.join(self.run_dir, \"clock_constraints_fragment.sdc\")\n        with open(clock_constraints_fragment, \"w\") as f:\n            <IND>f.write(self.sdc_clock_constraints)\n        <DED>sdc_files.append(clock_constraints_fragment)\n\n        # Generate port constraints.\n        pin_constraints_fragment = os.path.join(self.run_dir, \"pin_constraints_fragment.sdc\")\n        with open(pin_constraints_fragment, \"w\") as f:\n            <IND>f.write(self.sdc_pin_constraints)\n        <DED>sdc_files.append(pin_constraints_fragment)\n\n        # Add the post-synthesis SDC, if present.\n        post_synth_sdc = self.post_synth_sdc\n        if post_synth_sdc is not None:\n            <IND>sdc_files.append(post_synth_sdc)\n\n        # TODO: add floorplanning SDC\n        <DED>if len(sdc_files) > 0:\n            <IND>sdc_files_arg = \"-sdc_files [list {sdc_files}]\".format(\n                sdc_files=\" \".join(sdc_files)\n            )\n        <DED>else:\n            <IND>blank_sdc = os.path.join(self.run_dir, \"blank.sdc\")\n            self.run_executable([\"touch\", blank_sdc])\n            sdc_files_arg = \"-sdc_files {{ {} }}\".format(blank_sdc)\n        <DED>append_mmmc(\"create_constraint_mode -name {name} {sdc_files_arg}\".format(\n            name=constraint_mode,\n            sdc_files_arg=sdc_files_arg\n        ))\n\n        corners = self.get_mmmc_corners()  # type: List[MMMCCorner]\n        # In parallel, create the delay corners\n        if corners:\n            <IND>setup_corner = corners[0]  # type: MMMCCorner\n            hold_corner = corners[0]  # type: MMMCCorner\n            # TODO(colins): handle more than one corner and do something with extra corners\n            for corner in corners:\n                <IND>if corner.type is MMMCCornerType.Setup:\n                    <IND>setup_corner = corner\n                <DED>if corner.type is MMMCCornerType.Hold:\n                    <IND>hold_corner = corner\n\n            # First, create Innovus library sets\n            <DED><DED>append_mmmc(\"create_library_set -name {name} -timing [list {list}]\".format(\n                name=\"{n}.setup_set\".format(n=setup_corner.name),\n                list=self.get_timing_libs(setup_corner)\n            ))\n            append_mmmc(\"create_library_set -name {name} -timing [list {list}]\".format(\n                name=\"{n}.hold_set\".format(n=hold_corner.name),\n                list=self.get_timing_libs(hold_corner)\n            ))\n            # Skip opconds for now\n            # Next, create Innovus timing conditions\n            append_mmmc(\"create_timing_condition -name {name} -library_sets [list {list}]\".format(\n                name=\"{n}.setup_cond\".format(n=setup_corner.name),\n                list=\"{n}.setup_set\".format(n=setup_corner.name)\n            ))\n            append_mmmc(\"create_timing_condition -name {name} -library_sets [list {list}]\".format(\n                name=\"{n}.hold_cond\".format(n=hold_corner.name),\n                list=\"{n}.hold_set\".format(n=hold_corner.name)\n            ))\n            # Next, create Innovus rc corners from qrc tech files\n            append_mmmc(\"create_rc_corner -name {name} -temperature {tempInCelsius} {qrc}\".format(\n                name=\"{n}.setup_rc\".format(n=setup_corner.name),\n                tempInCelsius=str(setup_corner.temp.value),\n                qrc=\"-qrc_tech {}\".format(self.get_mmmc_qrc(setup_corner)) if self.get_mmmc_qrc(setup_corner) != '' else ''\n            ))\n            append_mmmc(\"create_rc_corner -name {name} -temperature {tempInCelsius} {qrc}\".format(\n                name=\"{n}.hold_rc\".format(n=hold_corner.name),\n                tempInCelsius=str(hold_corner.temp.value),\n                qrc=\"-qrc_tech {}\".format(self.get_mmmc_qrc(hold_corner)) if self.get_mmmc_qrc(hold_corner) != '' else ''\n            ))\n            # Next, create an Innovus delay corner.\n            append_mmmc(\n                \"create_delay_corner -name {name}_delay -timing_condition {name}_cond -rc_corner {name}_rc\".format(\n                    name=\"{n}.setup\".format(n=setup_corner.name)\n                ))\n            append_mmmc(\n                \"create_delay_corner -name {name}_delay -timing_condition {name}_cond -rc_corner {name}_rc\".format(\n                    name=\"{n}.hold\".format(n=hold_corner.name)\n                ))\n            # Next, create the analysis views\n            append_mmmc(\"create_analysis_view -name {name}_view -delay_corner {name}_delay -constraint_mode {constraint}\".format(\n                name=\"{n}.setup\".format(n=setup_corner.name), constraint=constraint_mode))\n            append_mmmc(\"create_analysis_view -name {name}_view -delay_corner {name}_delay -constraint_mode {constraint}\".format(\n                name=\"{n}.hold\".format(n=hold_corner.name), constraint=constraint_mode))\n            # Finally, apply the analysis view.\n            append_mmmc(\"set_analysis_view -setup {{ {setup_view} }} -hold {{ {hold_view} }}\".format(\n                setup_view=\"{n}.setup_view\".format(n=setup_corner.name),\n                hold_view=\"{n}.hold_view\".format(n=hold_corner.name)\n            ))\n        <DED>else:\n            # First, create an Innovus library set.\n            <IND>library_set_name = \"my_lib_set\"\n            append_mmmc(\"create_library_set -name {name} -timing [list {list}]\".format(\n                name=library_set_name,\n                list=self.get_timing_libs()\n            ))\n            # Next, create an Innovus timing condition.\n            timing_condition_name = \"my_timing_condition\"\n            append_mmmc(\"create_timing_condition -name {name} -library_sets [list {list}]\".format(\n                name=timing_condition_name,\n                list=library_set_name\n            ))\n            # extra junk: -opcond ...\n            rc_corner_name = \"rc_cond\"\n            append_mmmc(\"create_rc_corner -name {name} -temperature {tempInCelsius} {qrc}\".format(\n                name=rc_corner_name,\n                tempInCelsius=120,  # TODO: this should come from tech config\n                qrc=\"-qrc_tech {}\".format(self.get_qrc_tech()) if self.get_qrc_tech() != '' else ''\n            ))\n            # Next, create an Innovus delay corner.\n            delay_corner_name = \"my_delay_corner\"\n            append_mmmc(\n                \"create_delay_corner -name {name} -timing_condition {timing_cond} -rc_corner {rc}\".format(\n                    name=delay_corner_name,\n                    timing_cond=timing_condition_name,\n                    rc=rc_corner_name\n                ))\n            # extra junk: -rc_corner my_rc_corner_maybe_worst\n            # Next, create an Innovus analysis view.\n            analysis_view_name = \"my_view\"\n            append_mmmc(\"create_analysis_view -name {name} -delay_corner {corner} -constraint_mode {constraint}\".format(\n                name=analysis_view_name, corner=delay_corner_name, constraint=constraint_mode))\n            # Finally, apply the analysis view.\n            # TODO: introduce different views of setup/hold and true multi-corner\n            append_mmmc(\"set_analysis_view -setup {{ {setup_view} }} -hold {{ {hold_view} }}\".format(\n                setup_view=analysis_view_name,\n                hold_view=analysis_view_name\n            ))\n\n        <DED>return \"\\n\".join(mmmc_output)\n\n    <DED>def generate_dont_use_commands(self) -> List[str]:\n        <IND>\"\"\"\n        Generate a list of dont_use commands for Cadence tools.\n        \"\"\"\n\n        def map_cell(in_cell: str) -> str:\n            # \"*/\" is needed for \"get_db lib_cells <cell_expression>\"\n            <IND>if in_cell.startswith(\"*/\"):\n                <IND>mapped_cell = in_cell  # type: str\n            <DED>else:\n                <IND>mapped_cell = \"*/\" + in_cell\n\n            # Check for cell existence first to avoid Genus erroring out.\n            <DED>get_db_str = \"[get_db lib_cells {mapped_cell}]\".format(mapped_cell=mapped_cell)\n            # Escaped version for puts.\n            get_db_str_escaped = get_db_str.replace('[', '\\[').replace(']', '\\]')\n            return \"\"\"\nputs \"set_dont_use {get_db_str_escaped}\"\nif {{ {get_db_str} ne \"\" }} {{\n    set_dont_use {get_db_str}\n}} else {{\n    puts \"WARNING: cell {mapped_cell} was not found for set_dont_use\"\n}}\n            \"\"\".format(get_db_str=get_db_str, get_db_str_escaped=get_db_str_escaped, mapped_cell=mapped_cell)\n\n        <DED>return list(map(map_cell, self.get_dont_use_list()))\n\n    <DED>def generate_power_spec_commands(self) -> List[str]:\n        <IND>\"\"\"\n        Generate commands to load a power specification for Cadence tools.\n        \"\"\"\n\n        power_spec_type = str(self.get_setting(\"vlsi.inputs.power_spec_type\"))  # type: str\n        power_spec_arg = \"\"  # type: str\n        if power_spec_type == \"cpf\":\n            <IND>power_spec_arg = \"cpf\"\n        <DED>elif power_spec_type == \"upf\":\n            <IND>power_spec_arg = \"1801\"\n        <DED>else:\n            <IND>self.logger.error(\n                \"Invalid power specification type '{tpe}'; only 'cpf' or 'upf' supported\".format(tpe=power_spec_type))\n            return []\n\n        <DED>power_spec_contents = \"\"  # type: str\n        power_spec_mode = str(self.get_setting(\"vlsi.inputs.power_spec_mode\"))  # type: str\n        if power_spec_mode == \"empty\":\n            <IND>return []\n        <DED>elif power_spec_mode == \"auto\":\n            <IND>if power_spec_type == \"cpf\":\n                <IND>power_spec_contents = self.cpf_power_specification\n            <DED>elif power_spec_type == \"upf\":\n                <IND>power_spec_contents = self.upf_power_specification\n        <DED><DED>elif power_spec_mode == \"manual\":\n            <IND>power_spec_contents = str(self.get_setting(\"vlsi.inputs.power_spec_contents\"))\n        <DED>else:\n            <IND>self.logger.error(\"Invalid power specification mode '{mode}'; using 'empty'.\".format(mode=power_spec_mode))\n            return []\n\n        # Write the power spec contents to file and include it\n        <DED>power_spec_file = os.path.join(self.run_dir, \"power_spec.{tpe}\".format(tpe=power_spec_type))\n        with open(power_spec_file, \"w\") as f:\n            <IND>f.write(power_spec_contents)\n        <DED>return [\"read_power_intent -{arg} {path}\".format(arg=power_spec_arg, path=power_spec_file),\n                \"commit_power_intent\"]\n\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "        <IND>self.tcl_append(cmd, self.output, clean)\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "ucb-bar/hammer",
    "commit": "3afca0f00301e87b3112d42284a6acfd3c083c42",
    "filename": "src/hammer-vlsi/hammer_vlsi/hammer_vlsi_impl.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/ucb-bar-hammer/src/hammer-vlsi/hammer_vlsi/hammer_vlsi_impl.py",
    "file_hunks_size": 13,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": true,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "src/hammer-vlsi/hammer_vlsi/hammer_vlsi_impl.py:1586:34 Invalid type [31]: Expression `src.hammer.__sub__(vlsi.hammer_vlsi.constraints.List[str])` is not a valid type.",
    "message": " Expression `src.hammer.__sub__(vlsi.hammer_vlsi.constraints.List[str])` is not a valid type.",
    "rule_id": "Invalid type [31]",
    "warning_line_no": 1586,
    "warning_line": "        mmmc_output = []  # type: List[str]",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": true,
        "has_suppression": false,
        "source_code": "        self.tcl_append(cmd, self.output, clean)\n\n\nclass CadenceTool(HasSDCSupport, HasCPFSupport, HasUPFSupport, TCLTool, HammerTool):\n    \"\"\"Mix-in trait with functions useful for Cadence-based tools.\"\"\"\n\n    @property\n    def config_dirs(self) -> List[str]:\n        # Override this to pull in Cadence-common configs.\n        return [self.get_setting(\"cadence.common_path\")] + super().config_dirs\n\n    @property\n    def env_vars(self) -> Dict[str, str]:\n        \"\"\"\n        Get the list of environment variables required for this tool.\n        Note to subclasses: remember to include variables from super().env_vars!\n        \"\"\"\n        # Use the base extra_env_variables and ensure that our custom variables are on top.\n        list_of_vars = self.get_setting(\"cadence.extra_env_vars\")  # type: List[Dict[str, Any]]\n        assert isinstance(list_of_vars, list)\n\n        cadence_vars = {\n            \"CDS_LIC_FILE\": self.get_setting(\"cadence.CDS_LIC_FILE\"),\n            \"CADENCE_HOME\": self.get_setting(\"cadence.cadence_home\")\n        }\n\n        return reduce(add_dicts, [dict(super().env_vars)] + list_of_vars + [cadence_vars], {})\n\n    def version_number(self, version: str) -> int:\n        \"\"\"\n        Assumes versions look like MAJOR_ISRMINOR and we will have less than 100 minor versions.\n        \"\"\"\n        main_version = int(version.split(\"_\")[0]) # type: int\n        minor_version = 0 # type: int\n        if \"_\" in version:\n            minor_version = int(version.split(\"_\")[1][3:])\n        return main_version * 100 + minor_version\n\n    def get_timing_libs(self, corner: Optional[MMMCCorner] = None) -> str:\n        \"\"\"\n        Helper function to get the list of ASCII timing .lib files in space separated format.\n        Note that Cadence tools support ECSM, so we can use the ECSM-based filter.\n\n        :param corner: Optional corner to consider. If supplied, this will use filter_for_mmmc to select libraries that\n        match a given corner (voltage/temperature).\n        :return: List of lib files separated by spaces\n        \"\"\"\n        pre_filters = optional_map(corner, lambda c: [self.filter_for_mmmc(voltage=c.voltage,\n                                                                           temp=c.temp)])  # type: Optional[List[Callable[[hammer_tech.Library],bool]]]\n\n        lib_args = self.technology.read_libs([hammer_tech.filters.timing_lib_with_ecsm_filter],\n                                             hammer_tech.HammerTechnologyUtils.to_plain_item,\n                                             extra_pre_filters=pre_filters)\n        return \" \".join(lib_args)\n\n    def get_mmmc_qrc(self, corner: MMMCCorner) -> str:\n        lib_args = self.technology.read_libs([hammer_tech.filters.qrc_tech_filter],\n                                             hammer_tech.HammerTechnologyUtils.to_plain_item,\n                                             extra_pre_filters=[\n                                                 self.filter_for_mmmc(voltage=corner.voltage, temp=corner.temp)])\n        return \" \".join(lib_args)\n\n    def get_qrc_tech(self) -> str:\n        \"\"\"\n        Helper function to get the list of rc corner tech files in space separated format.\n\n        :return: List of qrc tech files separated by spaces\n        \"\"\"\n        lib_args = self.technology.read_libs([\n            hammer_tech.filters.qrc_tech_filter\n        ], hammer_tech.HammerTechnologyUtils.to_plain_item)\n        return \" \".join(lib_args)\n\n    def generate_mmmc_script(self) -> str:\n        \"\"\"\n        Output for the mmmc.tcl script.\n        Innovus (init_design) requires that the timing script be placed in a separate file.\n\n        :return: Contents of the mmmc script.\n        \"\"\"\n        mmmc_output = []  # type: List[str]\n\n        def append_mmmc(cmd: str) -> None:\n            self.verbose_tcl_append(cmd, mmmc_output)\n\n        # Create an Innovus constraint mode.\n        constraint_mode = \"my_constraint_mode\"\n        sdc_files = []  # type: List[str]\n\n        # Generate constraints\n        clock_constraints_fragment = os.path.join(self.run_dir, \"clock_constraints_fragment.sdc\")\n        with open(clock_constraints_fragment, \"w\") as f:\n            f.write(self.sdc_clock_constraints)\n        sdc_files.append(clock_constraints_fragment)\n\n        # Generate port constraints.\n        pin_constraints_fragment = os.path.join(self.run_dir, \"pin_constraints_fragment.sdc\")\n        with open(pin_constraints_fragment, \"w\") as f:\n            f.write(self.sdc_pin_constraints)\n        sdc_files.append(pin_constraints_fragment)\n\n        # Add the post-synthesis SDC, if present.\n        post_synth_sdc = self.post_synth_sdc\n        if post_synth_sdc is not None:\n            sdc_files.append(post_synth_sdc)\n\n        # TODO: add floorplanning SDC\n        if len(sdc_files) > 0:\n            sdc_files_arg = \"-sdc_files [list {sdc_files}]\".format(\n                sdc_files=\" \".join(sdc_files)\n            )\n        else:\n            blank_sdc = os.path.join(self.run_dir, \"blank.sdc\")\n            self.run_executable([\"touch\", blank_sdc])\n            sdc_files_arg = \"-sdc_files {{ {} }}\".format(blank_sdc)\n        append_mmmc(\"create_constraint_mode -name {name} {sdc_files_arg}\".format(\n            name=constraint_mode,\n            sdc_files_arg=sdc_files_arg\n        ))\n\n        corners = self.get_mmmc_corners()  # type: List[MMMCCorner]\n        # In parallel, create the delay corners\n        if corners:\n            setup_corner = corners[0]  # type: MMMCCorner\n            hold_corner = corners[0]  # type: MMMCCorner\n            # TODO(colins): handle more than one corner and do something with extra corners\n            for corner in corners:\n                if corner.type is MMMCCornerType.Setup:\n                    setup_corner = corner\n                if corner.type is MMMCCornerType.Hold:\n                    hold_corner = corner\n\n            # First, create Innovus library sets\n            append_mmmc(\"create_library_set -name {name} -timing [list {list}]\".format(\n                name=\"{n}.setup_set\".format(n=setup_corner.name),\n                list=self.get_timing_libs(setup_corner)\n            ))\n            append_mmmc(\"create_library_set -name {name} -timing [list {list}]\".format(\n                name=\"{n}.hold_set\".format(n=hold_corner.name),\n                list=self.get_timing_libs(hold_corner)\n            ))\n            # Skip opconds for now\n            # Next, create Innovus timing conditions\n            append_mmmc(\"create_timing_condition -name {name} -library_sets [list {list}]\".format(\n                name=\"{n}.setup_cond\".format(n=setup_corner.name),\n                list=\"{n}.setup_set\".format(n=setup_corner.name)\n            ))\n            append_mmmc(\"create_timing_condition -name {name} -library_sets [list {list}]\".format(\n                name=\"{n}.hold_cond\".format(n=hold_corner.name),\n                list=\"{n}.hold_set\".format(n=hold_corner.name)\n            ))\n            # Next, create Innovus rc corners from qrc tech files\n            append_mmmc(\"create_rc_corner -name {name} -temperature {tempInCelsius} {qrc}\".format(\n                name=\"{n}.setup_rc\".format(n=setup_corner.name),\n                tempInCelsius=str(setup_corner.temp.value),\n                qrc=\"-qrc_tech {}\".format(self.get_mmmc_qrc(setup_corner)) if self.get_mmmc_qrc(setup_corner) != '' else ''\n            ))\n            append_mmmc(\"create_rc_corner -name {name} -temperature {tempInCelsius} {qrc}\".format(\n                name=\"{n}.hold_rc\".format(n=hold_corner.name),\n                tempInCelsius=str(hold_corner.temp.value),\n                qrc=\"-qrc_tech {}\".format(self.get_mmmc_qrc(hold_corner)) if self.get_mmmc_qrc(hold_corner) != '' else ''\n            ))\n            # Next, create an Innovus delay corner.\n            append_mmmc(\n                \"create_delay_corner -name {name}_delay -timing_condition {name}_cond -rc_corner {name}_rc\".format(\n                    name=\"{n}.setup\".format(n=setup_corner.name)\n                ))\n            append_mmmc(\n                \"create_delay_corner -name {name}_delay -timing_condition {name}_cond -rc_corner {name}_rc\".format(\n                    name=\"{n}.hold\".format(n=hold_corner.name)\n                ))\n            # Next, create the analysis views\n            append_mmmc(\"create_analysis_view -name {name}_view -delay_corner {name}_delay -constraint_mode {constraint}\".format(\n                name=\"{n}.setup\".format(n=setup_corner.name), constraint=constraint_mode))\n            append_mmmc(\"create_analysis_view -name {name}_view -delay_corner {name}_delay -constraint_mode {constraint}\".format(\n                name=\"{n}.hold\".format(n=hold_corner.name), constraint=constraint_mode))\n            # Finally, apply the analysis view.\n            append_mmmc(\"set_analysis_view -setup {{ {setup_view} }} -hold {{ {hold_view} }}\".format(\n                setup_view=\"{n}.setup_view\".format(n=setup_corner.name),\n                hold_view=\"{n}.hold_view\".format(n=hold_corner.name)\n            ))\n        else:\n            # First, create an Innovus library set.\n            library_set_name = \"my_lib_set\"\n            append_mmmc(\"create_library_set -name {name} -timing [list {list}]\".format(\n                name=library_set_name,\n                list=self.get_timing_libs()\n            ))\n            # Next, create an Innovus timing condition.\n            timing_condition_name = \"my_timing_condition\"\n            append_mmmc(\"create_timing_condition -name {name} -library_sets [list {list}]\".format(\n                name=timing_condition_name,\n                list=library_set_name\n            ))\n            # extra junk: -opcond ...\n            rc_corner_name = \"rc_cond\"\n            append_mmmc(\"create_rc_corner -name {name} -temperature {tempInCelsius} {qrc}\".format(\n                name=rc_corner_name,\n                tempInCelsius=120,  # TODO: this should come from tech config\n                qrc=\"-qrc_tech {}\".format(self.get_qrc_tech()) if self.get_qrc_tech() != '' else ''\n            ))\n            # Next, create an Innovus delay corner.\n            delay_corner_name = \"my_delay_corner\"\n            append_mmmc(\n                \"create_delay_corner -name {name} -timing_condition {timing_cond} -rc_corner {rc}\".format(\n                    name=delay_corner_name,\n                    timing_cond=timing_condition_name,\n                    rc=rc_corner_name\n                ))\n            # extra junk: -rc_corner my_rc_corner_maybe_worst\n            # Next, create an Innovus analysis view.\n            analysis_view_name = \"my_view\"\n            append_mmmc(\"create_analysis_view -name {name} -delay_corner {corner} -constraint_mode {constraint}\".format(\n                name=analysis_view_name, corner=delay_corner_name, constraint=constraint_mode))\n            # Finally, apply the analysis view.\n            # TODO: introduce different views of setup/hold and true multi-corner\n            append_mmmc(\"set_analysis_view -setup {{ {setup_view} }} -hold {{ {hold_view} }}\".format(\n                setup_view=analysis_view_name,\n                hold_view=analysis_view_name\n            ))\n\n        return \"\\n\".join(mmmc_output)\n\n    def generate_dont_use_commands(self) -> List[str]:\n        \"\"\"\n        Generate a list of dont_use commands for Cadence tools.\n        \"\"\"\n\n        def map_cell(in_cell: str) -> str:\n            # \"*/\" is needed for \"get_db lib_cells <cell_expression>\"\n            if in_cell.startswith(\"*/\"):\n                mapped_cell = in_cell  # type: str\n            else:\n                mapped_cell = \"*/\" + in_cell\n\n            # Check for cell existence first to avoid Genus erroring out.\n            get_db_str = \"[get_db lib_cells {mapped_cell}]\".format(mapped_cell=mapped_cell)\n            # Escaped version for puts.\n            get_db_str_escaped = get_db_str.replace('[', '\\[').replace(']', '\\]')\n            return \"\"\"\nputs \"set_dont_use {get_db_str_escaped}\"\nif {{ {get_db_str} ne \"\" }} {{\n    set_dont_use {get_db_str}\n}} else {{\n    puts \"WARNING: cell {mapped_cell} was not found for set_dont_use\"\n}}\n            \"\"\".format(get_db_str=get_db_str, get_db_str_escaped=get_db_str_escaped, mapped_cell=mapped_cell)\n\n        return list(map(map_cell, self.get_dont_use_list()))\n\n    def generate_power_spec_commands(self) -> List[str]:\n        \"\"\"\n        Generate commands to load a power specification for Cadence tools.\n        \"\"\"\n\n        power_spec_type = str(self.get_setting(\"vlsi.inputs.power_spec_type\"))  # type: str\n        power_spec_arg = \"\"  # type: str\n        if power_spec_type == \"cpf\":\n            power_spec_arg = \"cpf\"\n        elif power_spec_type == \"upf\":\n            power_spec_arg = \"1801\"\n        else:\n            self.logger.error(\n                \"Invalid power specification type '{tpe}'; only 'cpf' or 'upf' supported\".format(tpe=power_spec_type))\n            return []\n\n        power_spec_contents = \"\"  # type: str\n        power_spec_mode = str(self.get_setting(\"vlsi.inputs.power_spec_mode\"))  # type: str\n        if power_spec_mode == \"empty\":\n            return []\n        elif power_spec_mode == \"auto\":\n            if power_spec_type == \"cpf\":\n                power_spec_contents = self.cpf_power_specification\n            elif power_spec_type == \"upf\":\n                power_spec_contents = self.upf_power_specification\n        elif power_spec_mode == \"manual\":\n            power_spec_contents = str(self.get_setting(\"vlsi.inputs.power_spec_contents\"))\n        else:\n            self.logger.error(\"Invalid power specification mode '{mode}'; using 'empty'.\".format(mode=power_spec_mode))\n            return []\n\n        # Write the power spec contents to file and include it\n        power_spec_file = os.path.join(self.run_dir, \"power_spec.{tpe}\".format(tpe=power_spec_type))\n        with open(power_spec_file, \"w\") as f:\n            f.write(power_spec_contents)\n        return [\"read_power_intent -{arg} {path}\".format(arg=power_spec_arg, path=power_spec_file),\n                \"commit_power_intent\"]\n\n\n",
        "source_code_len": 14014,
        "target_code": "        self.tcl_append(cmd, self.output, clean)\n\n",
        "target_code_len": 50,
        "diff_format": "@@ -1506,289 +1506,2 @@\n         self.tcl_append(cmd, self.output, clean)\n-\n-\n-class CadenceTool(HasSDCSupport, HasCPFSupport, HasUPFSupport, TCLTool, HammerTool):\n-    \"\"\"Mix-in trait with functions useful for Cadence-based tools.\"\"\"\n-\n-    @property\n-    def config_dirs(self) -> List[str]:\n-        # Override this to pull in Cadence-common configs.\n-        return [self.get_setting(\"cadence.common_path\")] + super().config_dirs\n-\n-    @property\n-    def env_vars(self) -> Dict[str, str]:\n-        \"\"\"\n-        Get the list of environment variables required for this tool.\n-        Note to subclasses: remember to include variables from super().env_vars!\n-        \"\"\"\n-        # Use the base extra_env_variables and ensure that our custom variables are on top.\n-        list_of_vars = self.get_setting(\"cadence.extra_env_vars\")  # type: List[Dict[str, Any]]\n-        assert isinstance(list_of_vars, list)\n-\n-        cadence_vars = {\n-            \"CDS_LIC_FILE\": self.get_setting(\"cadence.CDS_LIC_FILE\"),\n-            \"CADENCE_HOME\": self.get_setting(\"cadence.cadence_home\")\n-        }\n-\n-        return reduce(add_dicts, [dict(super().env_vars)] + list_of_vars + [cadence_vars], {})\n-\n-    def version_number(self, version: str) -> int:\n-        \"\"\"\n-        Assumes versions look like MAJOR_ISRMINOR and we will have less than 100 minor versions.\n-        \"\"\"\n-        main_version = int(version.split(\"_\")[0]) # type: int\n-        minor_version = 0 # type: int\n-        if \"_\" in version:\n-            minor_version = int(version.split(\"_\")[1][3:])\n-        return main_version * 100 + minor_version\n-\n-    def get_timing_libs(self, corner: Optional[MMMCCorner] = None) -> str:\n-        \"\"\"\n-        Helper function to get the list of ASCII timing .lib files in space separated format.\n-        Note that Cadence tools support ECSM, so we can use the ECSM-based filter.\n-\n-        :param corner: Optional corner to consider. If supplied, this will use filter_for_mmmc to select libraries that\n-        match a given corner (voltage/temperature).\n-        :return: List of lib files separated by spaces\n-        \"\"\"\n-        pre_filters = optional_map(corner, lambda c: [self.filter_for_mmmc(voltage=c.voltage,\n-                                                                           temp=c.temp)])  # type: Optional[List[Callable[[hammer_tech.Library],bool]]]\n-\n-        lib_args = self.technology.read_libs([hammer_tech.filters.timing_lib_with_ecsm_filter],\n-                                             hammer_tech.HammerTechnologyUtils.to_plain_item,\n-                                             extra_pre_filters=pre_filters)\n-        return \" \".join(lib_args)\n-\n-    def get_mmmc_qrc(self, corner: MMMCCorner) -> str:\n-        lib_args = self.technology.read_libs([hammer_tech.filters.qrc_tech_filter],\n-                                             hammer_tech.HammerTechnologyUtils.to_plain_item,\n-                                             extra_pre_filters=[\n-                                                 self.filter_for_mmmc(voltage=corner.voltage, temp=corner.temp)])\n-        return \" \".join(lib_args)\n-\n-    def get_qrc_tech(self) -> str:\n-        \"\"\"\n-        Helper function to get the list of rc corner tech files in space separated format.\n-\n-        :return: List of qrc tech files separated by spaces\n-        \"\"\"\n-        lib_args = self.technology.read_libs([\n-            hammer_tech.filters.qrc_tech_filter\n-        ], hammer_tech.HammerTechnologyUtils.to_plain_item)\n-        return \" \".join(lib_args)\n-\n-    def generate_mmmc_script(self) -> str:\n-        \"\"\"\n-        Output for the mmmc.tcl script.\n-        Innovus (init_design) requires that the timing script be placed in a separate file.\n-\n-        :return: Contents of the mmmc script.\n-        \"\"\"\n-        mmmc_output = []  # type: List[str]\n-\n-        def append_mmmc(cmd: str) -> None:\n-            self.verbose_tcl_append(cmd, mmmc_output)\n-\n-        # Create an Innovus constraint mode.\n-        constraint_mode = \"my_constraint_mode\"\n-        sdc_files = []  # type: List[str]\n-\n-        # Generate constraints\n-        clock_constraints_fragment = os.path.join(self.run_dir, \"clock_constraints_fragment.sdc\")\n-        with open(clock_constraints_fragment, \"w\") as f:\n-            f.write(self.sdc_clock_constraints)\n-        sdc_files.append(clock_constraints_fragment)\n-\n-        # Generate port constraints.\n-        pin_constraints_fragment = os.path.join(self.run_dir, \"pin_constraints_fragment.sdc\")\n-        with open(pin_constraints_fragment, \"w\") as f:\n-            f.write(self.sdc_pin_constraints)\n-        sdc_files.append(pin_constraints_fragment)\n-\n-        # Add the post-synthesis SDC, if present.\n-        post_synth_sdc = self.post_synth_sdc\n-        if post_synth_sdc is not None:\n-            sdc_files.append(post_synth_sdc)\n-\n-        # TODO: add floorplanning SDC\n-        if len(sdc_files) > 0:\n-            sdc_files_arg = \"-sdc_files [list {sdc_files}]\".format(\n-                sdc_files=\" \".join(sdc_files)\n-            )\n-        else:\n-            blank_sdc = os.path.join(self.run_dir, \"blank.sdc\")\n-            self.run_executable([\"touch\", blank_sdc])\n-            sdc_files_arg = \"-sdc_files {{ {} }}\".format(blank_sdc)\n-        append_mmmc(\"create_constraint_mode -name {name} {sdc_files_arg}\".format(\n-            name=constraint_mode,\n-            sdc_files_arg=sdc_files_arg\n-        ))\n-\n-        corners = self.get_mmmc_corners()  # type: List[MMMCCorner]\n-        # In parallel, create the delay corners\n-        if corners:\n-            setup_corner = corners[0]  # type: MMMCCorner\n-            hold_corner = corners[0]  # type: MMMCCorner\n-            # TODO(colins): handle more than one corner and do something with extra corners\n-            for corner in corners:\n-                if corner.type is MMMCCornerType.Setup:\n-                    setup_corner = corner\n-                if corner.type is MMMCCornerType.Hold:\n-                    hold_corner = corner\n-\n-            # First, create Innovus library sets\n-            append_mmmc(\"create_library_set -name {name} -timing [list {list}]\".format(\n-                name=\"{n}.setup_set\".format(n=setup_corner.name),\n-                list=self.get_timing_libs(setup_corner)\n-            ))\n-            append_mmmc(\"create_library_set -name {name} -timing [list {list}]\".format(\n-                name=\"{n}.hold_set\".format(n=hold_corner.name),\n-                list=self.get_timing_libs(hold_corner)\n-            ))\n-            # Skip opconds for now\n-            # Next, create Innovus timing conditions\n-            append_mmmc(\"create_timing_condition -name {name} -library_sets [list {list}]\".format(\n-                name=\"{n}.setup_cond\".format(n=setup_corner.name),\n-                list=\"{n}.setup_set\".format(n=setup_corner.name)\n-            ))\n-            append_mmmc(\"create_timing_condition -name {name} -library_sets [list {list}]\".format(\n-                name=\"{n}.hold_cond\".format(n=hold_corner.name),\n-                list=\"{n}.hold_set\".format(n=hold_corner.name)\n-            ))\n-            # Next, create Innovus rc corners from qrc tech files\n-            append_mmmc(\"create_rc_corner -name {name} -temperature {tempInCelsius} {qrc}\".format(\n-                name=\"{n}.setup_rc\".format(n=setup_corner.name),\n-                tempInCelsius=str(setup_corner.temp.value),\n-                qrc=\"-qrc_tech {}\".format(self.get_mmmc_qrc(setup_corner)) if self.get_mmmc_qrc(setup_corner) != '' else ''\n-            ))\n-            append_mmmc(\"create_rc_corner -name {name} -temperature {tempInCelsius} {qrc}\".format(\n-                name=\"{n}.hold_rc\".format(n=hold_corner.name),\n-                tempInCelsius=str(hold_corner.temp.value),\n-                qrc=\"-qrc_tech {}\".format(self.get_mmmc_qrc(hold_corner)) if self.get_mmmc_qrc(hold_corner) != '' else ''\n-            ))\n-            # Next, create an Innovus delay corner.\n-            append_mmmc(\n-                \"create_delay_corner -name {name}_delay -timing_condition {name}_cond -rc_corner {name}_rc\".format(\n-                    name=\"{n}.setup\".format(n=setup_corner.name)\n-                ))\n-            append_mmmc(\n-                \"create_delay_corner -name {name}_delay -timing_condition {name}_cond -rc_corner {name}_rc\".format(\n-                    name=\"{n}.hold\".format(n=hold_corner.name)\n-                ))\n-            # Next, create the analysis views\n-            append_mmmc(\"create_analysis_view -name {name}_view -delay_corner {name}_delay -constraint_mode {constraint}\".format(\n-                name=\"{n}.setup\".format(n=setup_corner.name), constraint=constraint_mode))\n-            append_mmmc(\"create_analysis_view -name {name}_view -delay_corner {name}_delay -constraint_mode {constraint}\".format(\n-                name=\"{n}.hold\".format(n=hold_corner.name), constraint=constraint_mode))\n-            # Finally, apply the analysis view.\n-            append_mmmc(\"set_analysis_view -setup {{ {setup_view} }} -hold {{ {hold_view} }}\".format(\n-                setup_view=\"{n}.setup_view\".format(n=setup_corner.name),\n-                hold_view=\"{n}.hold_view\".format(n=hold_corner.name)\n-            ))\n-        else:\n-            # First, create an Innovus library set.\n-            library_set_name = \"my_lib_set\"\n-            append_mmmc(\"create_library_set -name {name} -timing [list {list}]\".format(\n-                name=library_set_name,\n-                list=self.get_timing_libs()\n-            ))\n-            # Next, create an Innovus timing condition.\n-            timing_condition_name = \"my_timing_condition\"\n-            append_mmmc(\"create_timing_condition -name {name} -library_sets [list {list}]\".format(\n-                name=timing_condition_name,\n-                list=library_set_name\n-            ))\n-            # extra junk: -opcond ...\n-            rc_corner_name = \"rc_cond\"\n-            append_mmmc(\"create_rc_corner -name {name} -temperature {tempInCelsius} {qrc}\".format(\n-                name=rc_corner_name,\n-                tempInCelsius=120,  # TODO: this should come from tech config\n-                qrc=\"-qrc_tech {}\".format(self.get_qrc_tech()) if self.get_qrc_tech() != '' else ''\n-            ))\n-            # Next, create an Innovus delay corner.\n-            delay_corner_name = \"my_delay_corner\"\n-            append_mmmc(\n-                \"create_delay_corner -name {name} -timing_condition {timing_cond} -rc_corner {rc}\".format(\n-                    name=delay_corner_name,\n-                    timing_cond=timing_condition_name,\n-                    rc=rc_corner_name\n-                ))\n-            # extra junk: -rc_corner my_rc_corner_maybe_worst\n-            # Next, create an Innovus analysis view.\n-            analysis_view_name = \"my_view\"\n-            append_mmmc(\"create_analysis_view -name {name} -delay_corner {corner} -constraint_mode {constraint}\".format(\n-                name=analysis_view_name, corner=delay_corner_name, constraint=constraint_mode))\n-            # Finally, apply the analysis view.\n-            # TODO: introduce different views of setup/hold and true multi-corner\n-            append_mmmc(\"set_analysis_view -setup {{ {setup_view} }} -hold {{ {hold_view} }}\".format(\n-                setup_view=analysis_view_name,\n-                hold_view=analysis_view_name\n-            ))\n-\n-        return \"\\n\".join(mmmc_output)\n-\n-    def generate_dont_use_commands(self) -> List[str]:\n-        \"\"\"\n-        Generate a list of dont_use commands for Cadence tools.\n-        \"\"\"\n-\n-        def map_cell(in_cell: str) -> str:\n-            # \"*/\" is needed for \"get_db lib_cells <cell_expression>\"\n-            if in_cell.startswith(\"*/\"):\n-                mapped_cell = in_cell  # type: str\n-            else:\n-                mapped_cell = \"*/\" + in_cell\n-\n-            # Check for cell existence first to avoid Genus erroring out.\n-            get_db_str = \"[get_db lib_cells {mapped_cell}]\".format(mapped_cell=mapped_cell)\n-            # Escaped version for puts.\n-            get_db_str_escaped = get_db_str.replace('[', '\\[').replace(']', '\\]')\n-            return \"\"\"\n-puts \"set_dont_use {get_db_str_escaped}\"\n-if {{ {get_db_str} ne \"\" }} {{\n-    set_dont_use {get_db_str}\n-}} else {{\n-    puts \"WARNING: cell {mapped_cell} was not found for set_dont_use\"\n-}}\n-            \"\"\".format(get_db_str=get_db_str, get_db_str_escaped=get_db_str_escaped, mapped_cell=mapped_cell)\n-\n-        return list(map(map_cell, self.get_dont_use_list()))\n-\n-    def generate_power_spec_commands(self) -> List[str]:\n-        \"\"\"\n-        Generate commands to load a power specification for Cadence tools.\n-        \"\"\"\n-\n-        power_spec_type = str(self.get_setting(\"vlsi.inputs.power_spec_type\"))  # type: str\n-        power_spec_arg = \"\"  # type: str\n-        if power_spec_type == \"cpf\":\n-            power_spec_arg = \"cpf\"\n-        elif power_spec_type == \"upf\":\n-            power_spec_arg = \"1801\"\n-        else:\n-            self.logger.error(\n-                \"Invalid power specification type '{tpe}'; only 'cpf' or 'upf' supported\".format(tpe=power_spec_type))\n-            return []\n-\n-        power_spec_contents = \"\"  # type: str\n-        power_spec_mode = str(self.get_setting(\"vlsi.inputs.power_spec_mode\"))  # type: str\n-        if power_spec_mode == \"empty\":\n-            return []\n-        elif power_spec_mode == \"auto\":\n-            if power_spec_type == \"cpf\":\n-                power_spec_contents = self.cpf_power_specification\n-            elif power_spec_type == \"upf\":\n-                power_spec_contents = self.upf_power_specification\n-        elif power_spec_mode == \"manual\":\n-            power_spec_contents = str(self.get_setting(\"vlsi.inputs.power_spec_contents\"))\n-        else:\n-            self.logger.error(\"Invalid power specification mode '{mode}'; using 'empty'.\".format(mode=power_spec_mode))\n-            return []\n-\n-        # Write the power spec contents to file and include it\n-        power_spec_file = os.path.join(self.run_dir, \"power_spec.{tpe}\".format(tpe=power_spec_type))\n-        with open(power_spec_file, \"w\") as f:\n-            f.write(power_spec_contents)\n-        return [\"read_power_intent -{arg} {path}\".format(arg=power_spec_arg, path=power_spec_file),\n-                \"commit_power_intent\"]\n-\n \n",
        "source_code_with_indent": "        <IND>self.tcl_append(cmd, self.output, clean)\n\n\n<DED><DED>class CadenceTool(HasSDCSupport, HasCPFSupport, HasUPFSupport, TCLTool, HammerTool):\n    <IND>\"\"\"Mix-in trait with functions useful for Cadence-based tools.\"\"\"\n\n    @property\n    def config_dirs(self) -> List[str]:\n        # Override this to pull in Cadence-common configs.\n        <IND>return [self.get_setting(\"cadence.common_path\")] + super().config_dirs\n\n    <DED>@property\n    def env_vars(self) -> Dict[str, str]:\n        <IND>\"\"\"\n        Get the list of environment variables required for this tool.\n        Note to subclasses: remember to include variables from super().env_vars!\n        \"\"\"\n        # Use the base extra_env_variables and ensure that our custom variables are on top.\n        list_of_vars = self.get_setting(\"cadence.extra_env_vars\")  # type: List[Dict[str, Any]]\n        assert isinstance(list_of_vars, list)\n\n        cadence_vars = {\n            \"CDS_LIC_FILE\": self.get_setting(\"cadence.CDS_LIC_FILE\"),\n            \"CADENCE_HOME\": self.get_setting(\"cadence.cadence_home\")\n        }\n\n        return reduce(add_dicts, [dict(super().env_vars)] + list_of_vars + [cadence_vars], {})\n\n    <DED>def version_number(self, version: str) -> int:\n        <IND>\"\"\"\n        Assumes versions look like MAJOR_ISRMINOR and we will have less than 100 minor versions.\n        \"\"\"\n        main_version = int(version.split(\"_\")[0]) # type: int\n        minor_version = 0 # type: int\n        if \"_\" in version:\n            <IND>minor_version = int(version.split(\"_\")[1][3:])\n        <DED>return main_version * 100 + minor_version\n\n    <DED>def get_timing_libs(self, corner: Optional[MMMCCorner] = None) -> str:\n        <IND>\"\"\"\n        Helper function to get the list of ASCII timing .lib files in space separated format.\n        Note that Cadence tools support ECSM, so we can use the ECSM-based filter.\n\n        :param corner: Optional corner to consider. If supplied, this will use filter_for_mmmc to select libraries that\n        match a given corner (voltage/temperature).\n        :return: List of lib files separated by spaces\n        \"\"\"\n        pre_filters = optional_map(corner, lambda c: [self.filter_for_mmmc(voltage=c.voltage,\n                                                                           temp=c.temp)])  # type: Optional[List[Callable[[hammer_tech.Library],bool]]]\n\n        lib_args = self.technology.read_libs([hammer_tech.filters.timing_lib_with_ecsm_filter],\n                                             hammer_tech.HammerTechnologyUtils.to_plain_item,\n                                             extra_pre_filters=pre_filters)\n        return \" \".join(lib_args)\n\n    <DED>def get_mmmc_qrc(self, corner: MMMCCorner) -> str:\n        <IND>lib_args = self.technology.read_libs([hammer_tech.filters.qrc_tech_filter],\n                                             hammer_tech.HammerTechnologyUtils.to_plain_item,\n                                             extra_pre_filters=[\n                                                 self.filter_for_mmmc(voltage=corner.voltage, temp=corner.temp)])\n        return \" \".join(lib_args)\n\n    <DED>def get_qrc_tech(self) -> str:\n        <IND>\"\"\"\n        Helper function to get the list of rc corner tech files in space separated format.\n\n        :return: List of qrc tech files separated by spaces\n        \"\"\"\n        lib_args = self.technology.read_libs([\n            hammer_tech.filters.qrc_tech_filter\n        ], hammer_tech.HammerTechnologyUtils.to_plain_item)\n        return \" \".join(lib_args)\n\n    <DED>def generate_mmmc_script(self) -> str:\n        <IND>\"\"\"\n        Output for the mmmc.tcl script.\n        Innovus (init_design) requires that the timing script be placed in a separate file.\n\n        :return: Contents of the mmmc script.\n        \"\"\"\n        mmmc_output = []  # type: List[str]\n\n        def append_mmmc(cmd: str) -> None:\n            <IND>self.verbose_tcl_append(cmd, mmmc_output)\n\n        # Create an Innovus constraint mode.\n        <DED>constraint_mode = \"my_constraint_mode\"\n        sdc_files = []  # type: List[str]\n\n        # Generate constraints\n        clock_constraints_fragment = os.path.join(self.run_dir, \"clock_constraints_fragment.sdc\")\n        with open(clock_constraints_fragment, \"w\") as f:\n            <IND>f.write(self.sdc_clock_constraints)\n        <DED>sdc_files.append(clock_constraints_fragment)\n\n        # Generate port constraints.\n        pin_constraints_fragment = os.path.join(self.run_dir, \"pin_constraints_fragment.sdc\")\n        with open(pin_constraints_fragment, \"w\") as f:\n            <IND>f.write(self.sdc_pin_constraints)\n        <DED>sdc_files.append(pin_constraints_fragment)\n\n        # Add the post-synthesis SDC, if present.\n        post_synth_sdc = self.post_synth_sdc\n        if post_synth_sdc is not None:\n            <IND>sdc_files.append(post_synth_sdc)\n\n        # TODO: add floorplanning SDC\n        <DED>if len(sdc_files) > 0:\n            <IND>sdc_files_arg = \"-sdc_files [list {sdc_files}]\".format(\n                sdc_files=\" \".join(sdc_files)\n            )\n        <DED>else:\n            <IND>blank_sdc = os.path.join(self.run_dir, \"blank.sdc\")\n            self.run_executable([\"touch\", blank_sdc])\n            sdc_files_arg = \"-sdc_files {{ {} }}\".format(blank_sdc)\n        <DED>append_mmmc(\"create_constraint_mode -name {name} {sdc_files_arg}\".format(\n            name=constraint_mode,\n            sdc_files_arg=sdc_files_arg\n        ))\n\n        corners = self.get_mmmc_corners()  # type: List[MMMCCorner]\n        # In parallel, create the delay corners\n        if corners:\n            <IND>setup_corner = corners[0]  # type: MMMCCorner\n            hold_corner = corners[0]  # type: MMMCCorner\n            # TODO(colins): handle more than one corner and do something with extra corners\n            for corner in corners:\n                <IND>if corner.type is MMMCCornerType.Setup:\n                    <IND>setup_corner = corner\n                <DED>if corner.type is MMMCCornerType.Hold:\n                    <IND>hold_corner = corner\n\n            # First, create Innovus library sets\n            <DED><DED>append_mmmc(\"create_library_set -name {name} -timing [list {list}]\".format(\n                name=\"{n}.setup_set\".format(n=setup_corner.name),\n                list=self.get_timing_libs(setup_corner)\n            ))\n            append_mmmc(\"create_library_set -name {name} -timing [list {list}]\".format(\n                name=\"{n}.hold_set\".format(n=hold_corner.name),\n                list=self.get_timing_libs(hold_corner)\n            ))\n            # Skip opconds for now\n            # Next, create Innovus timing conditions\n            append_mmmc(\"create_timing_condition -name {name} -library_sets [list {list}]\".format(\n                name=\"{n}.setup_cond\".format(n=setup_corner.name),\n                list=\"{n}.setup_set\".format(n=setup_corner.name)\n            ))\n            append_mmmc(\"create_timing_condition -name {name} -library_sets [list {list}]\".format(\n                name=\"{n}.hold_cond\".format(n=hold_corner.name),\n                list=\"{n}.hold_set\".format(n=hold_corner.name)\n            ))\n            # Next, create Innovus rc corners from qrc tech files\n            append_mmmc(\"create_rc_corner -name {name} -temperature {tempInCelsius} {qrc}\".format(\n                name=\"{n}.setup_rc\".format(n=setup_corner.name),\n                tempInCelsius=str(setup_corner.temp.value),\n                qrc=\"-qrc_tech {}\".format(self.get_mmmc_qrc(setup_corner)) if self.get_mmmc_qrc(setup_corner) != '' else ''\n            ))\n            append_mmmc(\"create_rc_corner -name {name} -temperature {tempInCelsius} {qrc}\".format(\n                name=\"{n}.hold_rc\".format(n=hold_corner.name),\n                tempInCelsius=str(hold_corner.temp.value),\n                qrc=\"-qrc_tech {}\".format(self.get_mmmc_qrc(hold_corner)) if self.get_mmmc_qrc(hold_corner) != '' else ''\n            ))\n            # Next, create an Innovus delay corner.\n            append_mmmc(\n                \"create_delay_corner -name {name}_delay -timing_condition {name}_cond -rc_corner {name}_rc\".format(\n                    name=\"{n}.setup\".format(n=setup_corner.name)\n                ))\n            append_mmmc(\n                \"create_delay_corner -name {name}_delay -timing_condition {name}_cond -rc_corner {name}_rc\".format(\n                    name=\"{n}.hold\".format(n=hold_corner.name)\n                ))\n            # Next, create the analysis views\n            append_mmmc(\"create_analysis_view -name {name}_view -delay_corner {name}_delay -constraint_mode {constraint}\".format(\n                name=\"{n}.setup\".format(n=setup_corner.name), constraint=constraint_mode))\n            append_mmmc(\"create_analysis_view -name {name}_view -delay_corner {name}_delay -constraint_mode {constraint}\".format(\n                name=\"{n}.hold\".format(n=hold_corner.name), constraint=constraint_mode))\n            # Finally, apply the analysis view.\n            append_mmmc(\"set_analysis_view -setup {{ {setup_view} }} -hold {{ {hold_view} }}\".format(\n                setup_view=\"{n}.setup_view\".format(n=setup_corner.name),\n                hold_view=\"{n}.hold_view\".format(n=hold_corner.name)\n            ))\n        <DED>else:\n            # First, create an Innovus library set.\n            <IND>library_set_name = \"my_lib_set\"\n            append_mmmc(\"create_library_set -name {name} -timing [list {list}]\".format(\n                name=library_set_name,\n                list=self.get_timing_libs()\n            ))\n            # Next, create an Innovus timing condition.\n            timing_condition_name = \"my_timing_condition\"\n            append_mmmc(\"create_timing_condition -name {name} -library_sets [list {list}]\".format(\n                name=timing_condition_name,\n                list=library_set_name\n            ))\n            # extra junk: -opcond ...\n            rc_corner_name = \"rc_cond\"\n            append_mmmc(\"create_rc_corner -name {name} -temperature {tempInCelsius} {qrc}\".format(\n                name=rc_corner_name,\n                tempInCelsius=120,  # TODO: this should come from tech config\n                qrc=\"-qrc_tech {}\".format(self.get_qrc_tech()) if self.get_qrc_tech() != '' else ''\n            ))\n            # Next, create an Innovus delay corner.\n            delay_corner_name = \"my_delay_corner\"\n            append_mmmc(\n                \"create_delay_corner -name {name} -timing_condition {timing_cond} -rc_corner {rc}\".format(\n                    name=delay_corner_name,\n                    timing_cond=timing_condition_name,\n                    rc=rc_corner_name\n                ))\n            # extra junk: -rc_corner my_rc_corner_maybe_worst\n            # Next, create an Innovus analysis view.\n            analysis_view_name = \"my_view\"\n            append_mmmc(\"create_analysis_view -name {name} -delay_corner {corner} -constraint_mode {constraint}\".format(\n                name=analysis_view_name, corner=delay_corner_name, constraint=constraint_mode))\n            # Finally, apply the analysis view.\n            # TODO: introduce different views of setup/hold and true multi-corner\n            append_mmmc(\"set_analysis_view -setup {{ {setup_view} }} -hold {{ {hold_view} }}\".format(\n                setup_view=analysis_view_name,\n                hold_view=analysis_view_name\n            ))\n\n        <DED>return \"\\n\".join(mmmc_output)\n\n    <DED>def generate_dont_use_commands(self) -> List[str]:\n        <IND>\"\"\"\n        Generate a list of dont_use commands for Cadence tools.\n        \"\"\"\n\n        def map_cell(in_cell: str) -> str:\n            # \"*/\" is needed for \"get_db lib_cells <cell_expression>\"\n            <IND>if in_cell.startswith(\"*/\"):\n                <IND>mapped_cell = in_cell  # type: str\n            <DED>else:\n                <IND>mapped_cell = \"*/\" + in_cell\n\n            # Check for cell existence first to avoid Genus erroring out.\n            <DED>get_db_str = \"[get_db lib_cells {mapped_cell}]\".format(mapped_cell=mapped_cell)\n            # Escaped version for puts.\n            get_db_str_escaped = get_db_str.replace('[', '\\[').replace(']', '\\]')\n            return \"\"\"\nputs \"set_dont_use {get_db_str_escaped}\"\nif {{ {get_db_str} ne \"\" }} {{\n    set_dont_use {get_db_str}\n}} else {{\n    puts \"WARNING: cell {mapped_cell} was not found for set_dont_use\"\n}}\n            \"\"\".format(get_db_str=get_db_str, get_db_str_escaped=get_db_str_escaped, mapped_cell=mapped_cell)\n\n        <DED>return list(map(map_cell, self.get_dont_use_list()))\n\n    <DED>def generate_power_spec_commands(self) -> List[str]:\n        <IND>\"\"\"\n        Generate commands to load a power specification for Cadence tools.\n        \"\"\"\n\n        power_spec_type = str(self.get_setting(\"vlsi.inputs.power_spec_type\"))  # type: str\n        power_spec_arg = \"\"  # type: str\n        if power_spec_type == \"cpf\":\n            <IND>power_spec_arg = \"cpf\"\n        <DED>elif power_spec_type == \"upf\":\n            <IND>power_spec_arg = \"1801\"\n        <DED>else:\n            <IND>self.logger.error(\n                \"Invalid power specification type '{tpe}'; only 'cpf' or 'upf' supported\".format(tpe=power_spec_type))\n            return []\n\n        <DED>power_spec_contents = \"\"  # type: str\n        power_spec_mode = str(self.get_setting(\"vlsi.inputs.power_spec_mode\"))  # type: str\n        if power_spec_mode == \"empty\":\n            <IND>return []\n        <DED>elif power_spec_mode == \"auto\":\n            <IND>if power_spec_type == \"cpf\":\n                <IND>power_spec_contents = self.cpf_power_specification\n            <DED>elif power_spec_type == \"upf\":\n                <IND>power_spec_contents = self.upf_power_specification\n        <DED><DED>elif power_spec_mode == \"manual\":\n            <IND>power_spec_contents = str(self.get_setting(\"vlsi.inputs.power_spec_contents\"))\n        <DED>else:\n            <IND>self.logger.error(\"Invalid power specification mode '{mode}'; using 'empty'.\".format(mode=power_spec_mode))\n            return []\n\n        # Write the power spec contents to file and include it\n        <DED>power_spec_file = os.path.join(self.run_dir, \"power_spec.{tpe}\".format(tpe=power_spec_type))\n        with open(power_spec_file, \"w\") as f:\n            <IND>f.write(power_spec_contents)\n        <DED>return [\"read_power_intent -{arg} {path}\".format(arg=power_spec_arg, path=power_spec_file),\n                \"commit_power_intent\"]\n\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "        <IND>self.tcl_append(cmd, self.output, clean)\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "ucb-bar/hammer",
    "commit": "3afca0f00301e87b3112d42284a6acfd3c083c42",
    "filename": "src/hammer-vlsi/hammer_vlsi/hammer_vlsi_impl.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/ucb-bar-hammer/src/hammer-vlsi/hammer_vlsi/hammer_vlsi_impl.py",
    "file_hunks_size": 13,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": true,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "src/hammer-vlsi/hammer_vlsi/hammer_vlsi_impl.py:1586:34 Invalid type [31]: Expression `src.hammer.__sub__(vlsi.hammer_vlsi.constraints.List[str])` is not a valid type.",
    "message": " Expression `src.hammer.__sub__(vlsi.hammer_vlsi.constraints.List[str])` is not a valid type.",
    "rule_id": "Invalid type [31]",
    "warning_line_no": 1586,
    "warning_line": "        mmmc_output = []  # type: List[str]",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": true,
        "has_suppression": false,
        "source_code": "        self.tcl_append(cmd, self.output, clean)\n\n\nclass CadenceTool(HasSDCSupport, HasCPFSupport, HasUPFSupport, TCLTool, HammerTool):\n    \"\"\"Mix-in trait with functions useful for Cadence-based tools.\"\"\"\n\n    @property\n    def config_dirs(self) -> List[str]:\n        # Override this to pull in Cadence-common configs.\n        return [self.get_setting(\"cadence.common_path\")] + super().config_dirs\n\n    @property\n    def env_vars(self) -> Dict[str, str]:\n        \"\"\"\n        Get the list of environment variables required for this tool.\n        Note to subclasses: remember to include variables from super().env_vars!\n        \"\"\"\n        # Use the base extra_env_variables and ensure that our custom variables are on top.\n        list_of_vars = self.get_setting(\"cadence.extra_env_vars\")  # type: List[Dict[str, Any]]\n        assert isinstance(list_of_vars, list)\n\n        cadence_vars = {\n            \"CDS_LIC_FILE\": self.get_setting(\"cadence.CDS_LIC_FILE\"),\n            \"CADENCE_HOME\": self.get_setting(\"cadence.cadence_home\")\n        }\n\n        return reduce(add_dicts, [dict(super().env_vars)] + list_of_vars + [cadence_vars], {})\n\n    def version_number(self, version: str) -> int:\n        \"\"\"\n        Assumes versions look like MAJOR_ISRMINOR and we will have less than 100 minor versions.\n        \"\"\"\n        main_version = int(version.split(\"_\")[0]) # type: int\n        minor_version = 0 # type: int\n        if \"_\" in version:\n            minor_version = int(version.split(\"_\")[1][3:])\n        return main_version * 100 + minor_version\n\n    def get_timing_libs(self, corner: Optional[MMMCCorner] = None) -> str:\n        \"\"\"\n        Helper function to get the list of ASCII timing .lib files in space separated format.\n        Note that Cadence tools support ECSM, so we can use the ECSM-based filter.\n\n        :param corner: Optional corner to consider. If supplied, this will use filter_for_mmmc to select libraries that\n        match a given corner (voltage/temperature).\n        :return: List of lib files separated by spaces\n        \"\"\"\n        pre_filters = optional_map(corner, lambda c: [self.filter_for_mmmc(voltage=c.voltage,\n                                                                           temp=c.temp)])  # type: Optional[List[Callable[[hammer_tech.Library],bool]]]\n\n        lib_args = self.technology.read_libs([hammer_tech.filters.timing_lib_with_ecsm_filter],\n                                             hammer_tech.HammerTechnologyUtils.to_plain_item,\n                                             extra_pre_filters=pre_filters)\n        return \" \".join(lib_args)\n\n    def get_mmmc_qrc(self, corner: MMMCCorner) -> str:\n        lib_args = self.technology.read_libs([hammer_tech.filters.qrc_tech_filter],\n                                             hammer_tech.HammerTechnologyUtils.to_plain_item,\n                                             extra_pre_filters=[\n                                                 self.filter_for_mmmc(voltage=corner.voltage, temp=corner.temp)])\n        return \" \".join(lib_args)\n\n    def get_qrc_tech(self) -> str:\n        \"\"\"\n        Helper function to get the list of rc corner tech files in space separated format.\n\n        :return: List of qrc tech files separated by spaces\n        \"\"\"\n        lib_args = self.technology.read_libs([\n            hammer_tech.filters.qrc_tech_filter\n        ], hammer_tech.HammerTechnologyUtils.to_plain_item)\n        return \" \".join(lib_args)\n\n    def generate_mmmc_script(self) -> str:\n        \"\"\"\n        Output for the mmmc.tcl script.\n        Innovus (init_design) requires that the timing script be placed in a separate file.\n\n        :return: Contents of the mmmc script.\n        \"\"\"\n        mmmc_output = []  # type: List[str]\n\n        def append_mmmc(cmd: str) -> None:\n            self.verbose_tcl_append(cmd, mmmc_output)\n\n        # Create an Innovus constraint mode.\n        constraint_mode = \"my_constraint_mode\"\n        sdc_files = []  # type: List[str]\n\n        # Generate constraints\n        clock_constraints_fragment = os.path.join(self.run_dir, \"clock_constraints_fragment.sdc\")\n        with open(clock_constraints_fragment, \"w\") as f:\n            f.write(self.sdc_clock_constraints)\n        sdc_files.append(clock_constraints_fragment)\n\n        # Generate port constraints.\n        pin_constraints_fragment = os.path.join(self.run_dir, \"pin_constraints_fragment.sdc\")\n        with open(pin_constraints_fragment, \"w\") as f:\n            f.write(self.sdc_pin_constraints)\n        sdc_files.append(pin_constraints_fragment)\n\n        # Add the post-synthesis SDC, if present.\n        post_synth_sdc = self.post_synth_sdc\n        if post_synth_sdc is not None:\n            sdc_files.append(post_synth_sdc)\n\n        # TODO: add floorplanning SDC\n        if len(sdc_files) > 0:\n            sdc_files_arg = \"-sdc_files [list {sdc_files}]\".format(\n                sdc_files=\" \".join(sdc_files)\n            )\n        else:\n            blank_sdc = os.path.join(self.run_dir, \"blank.sdc\")\n            self.run_executable([\"touch\", blank_sdc])\n            sdc_files_arg = \"-sdc_files {{ {} }}\".format(blank_sdc)\n        append_mmmc(\"create_constraint_mode -name {name} {sdc_files_arg}\".format(\n            name=constraint_mode,\n            sdc_files_arg=sdc_files_arg\n        ))\n\n        corners = self.get_mmmc_corners()  # type: List[MMMCCorner]\n        # In parallel, create the delay corners\n        if corners:\n            setup_corner = corners[0]  # type: MMMCCorner\n            hold_corner = corners[0]  # type: MMMCCorner\n            # TODO(colins): handle more than one corner and do something with extra corners\n            for corner in corners:\n                if corner.type is MMMCCornerType.Setup:\n                    setup_corner = corner\n                if corner.type is MMMCCornerType.Hold:\n                    hold_corner = corner\n\n            # First, create Innovus library sets\n            append_mmmc(\"create_library_set -name {name} -timing [list {list}]\".format(\n                name=\"{n}.setup_set\".format(n=setup_corner.name),\n                list=self.get_timing_libs(setup_corner)\n            ))\n            append_mmmc(\"create_library_set -name {name} -timing [list {list}]\".format(\n                name=\"{n}.hold_set\".format(n=hold_corner.name),\n                list=self.get_timing_libs(hold_corner)\n            ))\n            # Skip opconds for now\n            # Next, create Innovus timing conditions\n            append_mmmc(\"create_timing_condition -name {name} -library_sets [list {list}]\".format(\n                name=\"{n}.setup_cond\".format(n=setup_corner.name),\n                list=\"{n}.setup_set\".format(n=setup_corner.name)\n            ))\n            append_mmmc(\"create_timing_condition -name {name} -library_sets [list {list}]\".format(\n                name=\"{n}.hold_cond\".format(n=hold_corner.name),\n                list=\"{n}.hold_set\".format(n=hold_corner.name)\n            ))\n            # Next, create Innovus rc corners from qrc tech files\n            append_mmmc(\"create_rc_corner -name {name} -temperature {tempInCelsius} {qrc}\".format(\n                name=\"{n}.setup_rc\".format(n=setup_corner.name),\n                tempInCelsius=str(setup_corner.temp.value),\n                qrc=\"-qrc_tech {}\".format(self.get_mmmc_qrc(setup_corner)) if self.get_mmmc_qrc(setup_corner) != '' else ''\n            ))\n            append_mmmc(\"create_rc_corner -name {name} -temperature {tempInCelsius} {qrc}\".format(\n                name=\"{n}.hold_rc\".format(n=hold_corner.name),\n                tempInCelsius=str(hold_corner.temp.value),\n                qrc=\"-qrc_tech {}\".format(self.get_mmmc_qrc(hold_corner)) if self.get_mmmc_qrc(hold_corner) != '' else ''\n            ))\n            # Next, create an Innovus delay corner.\n            append_mmmc(\n                \"create_delay_corner -name {name}_delay -timing_condition {name}_cond -rc_corner {name}_rc\".format(\n                    name=\"{n}.setup\".format(n=setup_corner.name)\n                ))\n            append_mmmc(\n                \"create_delay_corner -name {name}_delay -timing_condition {name}_cond -rc_corner {name}_rc\".format(\n                    name=\"{n}.hold\".format(n=hold_corner.name)\n                ))\n            # Next, create the analysis views\n            append_mmmc(\"create_analysis_view -name {name}_view -delay_corner {name}_delay -constraint_mode {constraint}\".format(\n                name=\"{n}.setup\".format(n=setup_corner.name), constraint=constraint_mode))\n            append_mmmc(\"create_analysis_view -name {name}_view -delay_corner {name}_delay -constraint_mode {constraint}\".format(\n                name=\"{n}.hold\".format(n=hold_corner.name), constraint=constraint_mode))\n            # Finally, apply the analysis view.\n            append_mmmc(\"set_analysis_view -setup {{ {setup_view} }} -hold {{ {hold_view} }}\".format(\n                setup_view=\"{n}.setup_view\".format(n=setup_corner.name),\n                hold_view=\"{n}.hold_view\".format(n=hold_corner.name)\n            ))\n        else:\n            # First, create an Innovus library set.\n            library_set_name = \"my_lib_set\"\n            append_mmmc(\"create_library_set -name {name} -timing [list {list}]\".format(\n                name=library_set_name,\n                list=self.get_timing_libs()\n            ))\n            # Next, create an Innovus timing condition.\n            timing_condition_name = \"my_timing_condition\"\n            append_mmmc(\"create_timing_condition -name {name} -library_sets [list {list}]\".format(\n                name=timing_condition_name,\n                list=library_set_name\n            ))\n            # extra junk: -opcond ...\n            rc_corner_name = \"rc_cond\"\n            append_mmmc(\"create_rc_corner -name {name} -temperature {tempInCelsius} {qrc}\".format(\n                name=rc_corner_name,\n                tempInCelsius=120,  # TODO: this should come from tech config\n                qrc=\"-qrc_tech {}\".format(self.get_qrc_tech()) if self.get_qrc_tech() != '' else ''\n            ))\n            # Next, create an Innovus delay corner.\n            delay_corner_name = \"my_delay_corner\"\n            append_mmmc(\n                \"create_delay_corner -name {name} -timing_condition {timing_cond} -rc_corner {rc}\".format(\n                    name=delay_corner_name,\n                    timing_cond=timing_condition_name,\n                    rc=rc_corner_name\n                ))\n            # extra junk: -rc_corner my_rc_corner_maybe_worst\n            # Next, create an Innovus analysis view.\n            analysis_view_name = \"my_view\"\n            append_mmmc(\"create_analysis_view -name {name} -delay_corner {corner} -constraint_mode {constraint}\".format(\n                name=analysis_view_name, corner=delay_corner_name, constraint=constraint_mode))\n            # Finally, apply the analysis view.\n            # TODO: introduce different views of setup/hold and true multi-corner\n            append_mmmc(\"set_analysis_view -setup {{ {setup_view} }} -hold {{ {hold_view} }}\".format(\n                setup_view=analysis_view_name,\n                hold_view=analysis_view_name\n            ))\n\n        return \"\\n\".join(mmmc_output)\n\n    def generate_dont_use_commands(self) -> List[str]:\n        \"\"\"\n        Generate a list of dont_use commands for Cadence tools.\n        \"\"\"\n\n        def map_cell(in_cell: str) -> str:\n            # \"*/\" is needed for \"get_db lib_cells <cell_expression>\"\n            if in_cell.startswith(\"*/\"):\n                mapped_cell = in_cell  # type: str\n            else:\n                mapped_cell = \"*/\" + in_cell\n\n            # Check for cell existence first to avoid Genus erroring out.\n            get_db_str = \"[get_db lib_cells {mapped_cell}]\".format(mapped_cell=mapped_cell)\n            # Escaped version for puts.\n            get_db_str_escaped = get_db_str.replace('[', '\\[').replace(']', '\\]')\n            return \"\"\"\nputs \"set_dont_use {get_db_str_escaped}\"\nif {{ {get_db_str} ne \"\" }} {{\n    set_dont_use {get_db_str}\n}} else {{\n    puts \"WARNING: cell {mapped_cell} was not found for set_dont_use\"\n}}\n            \"\"\".format(get_db_str=get_db_str, get_db_str_escaped=get_db_str_escaped, mapped_cell=mapped_cell)\n\n        return list(map(map_cell, self.get_dont_use_list()))\n\n    def generate_power_spec_commands(self) -> List[str]:\n        \"\"\"\n        Generate commands to load a power specification for Cadence tools.\n        \"\"\"\n\n        power_spec_type = str(self.get_setting(\"vlsi.inputs.power_spec_type\"))  # type: str\n        power_spec_arg = \"\"  # type: str\n        if power_spec_type == \"cpf\":\n            power_spec_arg = \"cpf\"\n        elif power_spec_type == \"upf\":\n            power_spec_arg = \"1801\"\n        else:\n            self.logger.error(\n                \"Invalid power specification type '{tpe}'; only 'cpf' or 'upf' supported\".format(tpe=power_spec_type))\n            return []\n\n        power_spec_contents = \"\"  # type: str\n        power_spec_mode = str(self.get_setting(\"vlsi.inputs.power_spec_mode\"))  # type: str\n        if power_spec_mode == \"empty\":\n            return []\n        elif power_spec_mode == \"auto\":\n            if power_spec_type == \"cpf\":\n                power_spec_contents = self.cpf_power_specification\n            elif power_spec_type == \"upf\":\n                power_spec_contents = self.upf_power_specification\n        elif power_spec_mode == \"manual\":\n            power_spec_contents = str(self.get_setting(\"vlsi.inputs.power_spec_contents\"))\n        else:\n            self.logger.error(\"Invalid power specification mode '{mode}'; using 'empty'.\".format(mode=power_spec_mode))\n            return []\n\n        # Write the power spec contents to file and include it\n        power_spec_file = os.path.join(self.run_dir, \"power_spec.{tpe}\".format(tpe=power_spec_type))\n        with open(power_spec_file, \"w\") as f:\n            f.write(power_spec_contents)\n        return [\"read_power_intent -{arg} {path}\".format(arg=power_spec_arg, path=power_spec_file),\n                \"commit_power_intent\"]\n\n\n",
        "source_code_len": 14014,
        "target_code": "        self.tcl_append(cmd, self.output, clean)\n\n",
        "target_code_len": 50,
        "diff_format": "@@ -1506,289 +1506,2 @@\n         self.tcl_append(cmd, self.output, clean)\n-\n-\n-class CadenceTool(HasSDCSupport, HasCPFSupport, HasUPFSupport, TCLTool, HammerTool):\n-    \"\"\"Mix-in trait with functions useful for Cadence-based tools.\"\"\"\n-\n-    @property\n-    def config_dirs(self) -> List[str]:\n-        # Override this to pull in Cadence-common configs.\n-        return [self.get_setting(\"cadence.common_path\")] + super().config_dirs\n-\n-    @property\n-    def env_vars(self) -> Dict[str, str]:\n-        \"\"\"\n-        Get the list of environment variables required for this tool.\n-        Note to subclasses: remember to include variables from super().env_vars!\n-        \"\"\"\n-        # Use the base extra_env_variables and ensure that our custom variables are on top.\n-        list_of_vars = self.get_setting(\"cadence.extra_env_vars\")  # type: List[Dict[str, Any]]\n-        assert isinstance(list_of_vars, list)\n-\n-        cadence_vars = {\n-            \"CDS_LIC_FILE\": self.get_setting(\"cadence.CDS_LIC_FILE\"),\n-            \"CADENCE_HOME\": self.get_setting(\"cadence.cadence_home\")\n-        }\n-\n-        return reduce(add_dicts, [dict(super().env_vars)] + list_of_vars + [cadence_vars], {})\n-\n-    def version_number(self, version: str) -> int:\n-        \"\"\"\n-        Assumes versions look like MAJOR_ISRMINOR and we will have less than 100 minor versions.\n-        \"\"\"\n-        main_version = int(version.split(\"_\")[0]) # type: int\n-        minor_version = 0 # type: int\n-        if \"_\" in version:\n-            minor_version = int(version.split(\"_\")[1][3:])\n-        return main_version * 100 + minor_version\n-\n-    def get_timing_libs(self, corner: Optional[MMMCCorner] = None) -> str:\n-        \"\"\"\n-        Helper function to get the list of ASCII timing .lib files in space separated format.\n-        Note that Cadence tools support ECSM, so we can use the ECSM-based filter.\n-\n-        :param corner: Optional corner to consider. If supplied, this will use filter_for_mmmc to select libraries that\n-        match a given corner (voltage/temperature).\n-        :return: List of lib files separated by spaces\n-        \"\"\"\n-        pre_filters = optional_map(corner, lambda c: [self.filter_for_mmmc(voltage=c.voltage,\n-                                                                           temp=c.temp)])  # type: Optional[List[Callable[[hammer_tech.Library],bool]]]\n-\n-        lib_args = self.technology.read_libs([hammer_tech.filters.timing_lib_with_ecsm_filter],\n-                                             hammer_tech.HammerTechnologyUtils.to_plain_item,\n-                                             extra_pre_filters=pre_filters)\n-        return \" \".join(lib_args)\n-\n-    def get_mmmc_qrc(self, corner: MMMCCorner) -> str:\n-        lib_args = self.technology.read_libs([hammer_tech.filters.qrc_tech_filter],\n-                                             hammer_tech.HammerTechnologyUtils.to_plain_item,\n-                                             extra_pre_filters=[\n-                                                 self.filter_for_mmmc(voltage=corner.voltage, temp=corner.temp)])\n-        return \" \".join(lib_args)\n-\n-    def get_qrc_tech(self) -> str:\n-        \"\"\"\n-        Helper function to get the list of rc corner tech files in space separated format.\n-\n-        :return: List of qrc tech files separated by spaces\n-        \"\"\"\n-        lib_args = self.technology.read_libs([\n-            hammer_tech.filters.qrc_tech_filter\n-        ], hammer_tech.HammerTechnologyUtils.to_plain_item)\n-        return \" \".join(lib_args)\n-\n-    def generate_mmmc_script(self) -> str:\n-        \"\"\"\n-        Output for the mmmc.tcl script.\n-        Innovus (init_design) requires that the timing script be placed in a separate file.\n-\n-        :return: Contents of the mmmc script.\n-        \"\"\"\n-        mmmc_output = []  # type: List[str]\n-\n-        def append_mmmc(cmd: str) -> None:\n-            self.verbose_tcl_append(cmd, mmmc_output)\n-\n-        # Create an Innovus constraint mode.\n-        constraint_mode = \"my_constraint_mode\"\n-        sdc_files = []  # type: List[str]\n-\n-        # Generate constraints\n-        clock_constraints_fragment = os.path.join(self.run_dir, \"clock_constraints_fragment.sdc\")\n-        with open(clock_constraints_fragment, \"w\") as f:\n-            f.write(self.sdc_clock_constraints)\n-        sdc_files.append(clock_constraints_fragment)\n-\n-        # Generate port constraints.\n-        pin_constraints_fragment = os.path.join(self.run_dir, \"pin_constraints_fragment.sdc\")\n-        with open(pin_constraints_fragment, \"w\") as f:\n-            f.write(self.sdc_pin_constraints)\n-        sdc_files.append(pin_constraints_fragment)\n-\n-        # Add the post-synthesis SDC, if present.\n-        post_synth_sdc = self.post_synth_sdc\n-        if post_synth_sdc is not None:\n-            sdc_files.append(post_synth_sdc)\n-\n-        # TODO: add floorplanning SDC\n-        if len(sdc_files) > 0:\n-            sdc_files_arg = \"-sdc_files [list {sdc_files}]\".format(\n-                sdc_files=\" \".join(sdc_files)\n-            )\n-        else:\n-            blank_sdc = os.path.join(self.run_dir, \"blank.sdc\")\n-            self.run_executable([\"touch\", blank_sdc])\n-            sdc_files_arg = \"-sdc_files {{ {} }}\".format(blank_sdc)\n-        append_mmmc(\"create_constraint_mode -name {name} {sdc_files_arg}\".format(\n-            name=constraint_mode,\n-            sdc_files_arg=sdc_files_arg\n-        ))\n-\n-        corners = self.get_mmmc_corners()  # type: List[MMMCCorner]\n-        # In parallel, create the delay corners\n-        if corners:\n-            setup_corner = corners[0]  # type: MMMCCorner\n-            hold_corner = corners[0]  # type: MMMCCorner\n-            # TODO(colins): handle more than one corner and do something with extra corners\n-            for corner in corners:\n-                if corner.type is MMMCCornerType.Setup:\n-                    setup_corner = corner\n-                if corner.type is MMMCCornerType.Hold:\n-                    hold_corner = corner\n-\n-            # First, create Innovus library sets\n-            append_mmmc(\"create_library_set -name {name} -timing [list {list}]\".format(\n-                name=\"{n}.setup_set\".format(n=setup_corner.name),\n-                list=self.get_timing_libs(setup_corner)\n-            ))\n-            append_mmmc(\"create_library_set -name {name} -timing [list {list}]\".format(\n-                name=\"{n}.hold_set\".format(n=hold_corner.name),\n-                list=self.get_timing_libs(hold_corner)\n-            ))\n-            # Skip opconds for now\n-            # Next, create Innovus timing conditions\n-            append_mmmc(\"create_timing_condition -name {name} -library_sets [list {list}]\".format(\n-                name=\"{n}.setup_cond\".format(n=setup_corner.name),\n-                list=\"{n}.setup_set\".format(n=setup_corner.name)\n-            ))\n-            append_mmmc(\"create_timing_condition -name {name} -library_sets [list {list}]\".format(\n-                name=\"{n}.hold_cond\".format(n=hold_corner.name),\n-                list=\"{n}.hold_set\".format(n=hold_corner.name)\n-            ))\n-            # Next, create Innovus rc corners from qrc tech files\n-            append_mmmc(\"create_rc_corner -name {name} -temperature {tempInCelsius} {qrc}\".format(\n-                name=\"{n}.setup_rc\".format(n=setup_corner.name),\n-                tempInCelsius=str(setup_corner.temp.value),\n-                qrc=\"-qrc_tech {}\".format(self.get_mmmc_qrc(setup_corner)) if self.get_mmmc_qrc(setup_corner) != '' else ''\n-            ))\n-            append_mmmc(\"create_rc_corner -name {name} -temperature {tempInCelsius} {qrc}\".format(\n-                name=\"{n}.hold_rc\".format(n=hold_corner.name),\n-                tempInCelsius=str(hold_corner.temp.value),\n-                qrc=\"-qrc_tech {}\".format(self.get_mmmc_qrc(hold_corner)) if self.get_mmmc_qrc(hold_corner) != '' else ''\n-            ))\n-            # Next, create an Innovus delay corner.\n-            append_mmmc(\n-                \"create_delay_corner -name {name}_delay -timing_condition {name}_cond -rc_corner {name}_rc\".format(\n-                    name=\"{n}.setup\".format(n=setup_corner.name)\n-                ))\n-            append_mmmc(\n-                \"create_delay_corner -name {name}_delay -timing_condition {name}_cond -rc_corner {name}_rc\".format(\n-                    name=\"{n}.hold\".format(n=hold_corner.name)\n-                ))\n-            # Next, create the analysis views\n-            append_mmmc(\"create_analysis_view -name {name}_view -delay_corner {name}_delay -constraint_mode {constraint}\".format(\n-                name=\"{n}.setup\".format(n=setup_corner.name), constraint=constraint_mode))\n-            append_mmmc(\"create_analysis_view -name {name}_view -delay_corner {name}_delay -constraint_mode {constraint}\".format(\n-                name=\"{n}.hold\".format(n=hold_corner.name), constraint=constraint_mode))\n-            # Finally, apply the analysis view.\n-            append_mmmc(\"set_analysis_view -setup {{ {setup_view} }} -hold {{ {hold_view} }}\".format(\n-                setup_view=\"{n}.setup_view\".format(n=setup_corner.name),\n-                hold_view=\"{n}.hold_view\".format(n=hold_corner.name)\n-            ))\n-        else:\n-            # First, create an Innovus library set.\n-            library_set_name = \"my_lib_set\"\n-            append_mmmc(\"create_library_set -name {name} -timing [list {list}]\".format(\n-                name=library_set_name,\n-                list=self.get_timing_libs()\n-            ))\n-            # Next, create an Innovus timing condition.\n-            timing_condition_name = \"my_timing_condition\"\n-            append_mmmc(\"create_timing_condition -name {name} -library_sets [list {list}]\".format(\n-                name=timing_condition_name,\n-                list=library_set_name\n-            ))\n-            # extra junk: -opcond ...\n-            rc_corner_name = \"rc_cond\"\n-            append_mmmc(\"create_rc_corner -name {name} -temperature {tempInCelsius} {qrc}\".format(\n-                name=rc_corner_name,\n-                tempInCelsius=120,  # TODO: this should come from tech config\n-                qrc=\"-qrc_tech {}\".format(self.get_qrc_tech()) if self.get_qrc_tech() != '' else ''\n-            ))\n-            # Next, create an Innovus delay corner.\n-            delay_corner_name = \"my_delay_corner\"\n-            append_mmmc(\n-                \"create_delay_corner -name {name} -timing_condition {timing_cond} -rc_corner {rc}\".format(\n-                    name=delay_corner_name,\n-                    timing_cond=timing_condition_name,\n-                    rc=rc_corner_name\n-                ))\n-            # extra junk: -rc_corner my_rc_corner_maybe_worst\n-            # Next, create an Innovus analysis view.\n-            analysis_view_name = \"my_view\"\n-            append_mmmc(\"create_analysis_view -name {name} -delay_corner {corner} -constraint_mode {constraint}\".format(\n-                name=analysis_view_name, corner=delay_corner_name, constraint=constraint_mode))\n-            # Finally, apply the analysis view.\n-            # TODO: introduce different views of setup/hold and true multi-corner\n-            append_mmmc(\"set_analysis_view -setup {{ {setup_view} }} -hold {{ {hold_view} }}\".format(\n-                setup_view=analysis_view_name,\n-                hold_view=analysis_view_name\n-            ))\n-\n-        return \"\\n\".join(mmmc_output)\n-\n-    def generate_dont_use_commands(self) -> List[str]:\n-        \"\"\"\n-        Generate a list of dont_use commands for Cadence tools.\n-        \"\"\"\n-\n-        def map_cell(in_cell: str) -> str:\n-            # \"*/\" is needed for \"get_db lib_cells <cell_expression>\"\n-            if in_cell.startswith(\"*/\"):\n-                mapped_cell = in_cell  # type: str\n-            else:\n-                mapped_cell = \"*/\" + in_cell\n-\n-            # Check for cell existence first to avoid Genus erroring out.\n-            get_db_str = \"[get_db lib_cells {mapped_cell}]\".format(mapped_cell=mapped_cell)\n-            # Escaped version for puts.\n-            get_db_str_escaped = get_db_str.replace('[', '\\[').replace(']', '\\]')\n-            return \"\"\"\n-puts \"set_dont_use {get_db_str_escaped}\"\n-if {{ {get_db_str} ne \"\" }} {{\n-    set_dont_use {get_db_str}\n-}} else {{\n-    puts \"WARNING: cell {mapped_cell} was not found for set_dont_use\"\n-}}\n-            \"\"\".format(get_db_str=get_db_str, get_db_str_escaped=get_db_str_escaped, mapped_cell=mapped_cell)\n-\n-        return list(map(map_cell, self.get_dont_use_list()))\n-\n-    def generate_power_spec_commands(self) -> List[str]:\n-        \"\"\"\n-        Generate commands to load a power specification for Cadence tools.\n-        \"\"\"\n-\n-        power_spec_type = str(self.get_setting(\"vlsi.inputs.power_spec_type\"))  # type: str\n-        power_spec_arg = \"\"  # type: str\n-        if power_spec_type == \"cpf\":\n-            power_spec_arg = \"cpf\"\n-        elif power_spec_type == \"upf\":\n-            power_spec_arg = \"1801\"\n-        else:\n-            self.logger.error(\n-                \"Invalid power specification type '{tpe}'; only 'cpf' or 'upf' supported\".format(tpe=power_spec_type))\n-            return []\n-\n-        power_spec_contents = \"\"  # type: str\n-        power_spec_mode = str(self.get_setting(\"vlsi.inputs.power_spec_mode\"))  # type: str\n-        if power_spec_mode == \"empty\":\n-            return []\n-        elif power_spec_mode == \"auto\":\n-            if power_spec_type == \"cpf\":\n-                power_spec_contents = self.cpf_power_specification\n-            elif power_spec_type == \"upf\":\n-                power_spec_contents = self.upf_power_specification\n-        elif power_spec_mode == \"manual\":\n-            power_spec_contents = str(self.get_setting(\"vlsi.inputs.power_spec_contents\"))\n-        else:\n-            self.logger.error(\"Invalid power specification mode '{mode}'; using 'empty'.\".format(mode=power_spec_mode))\n-            return []\n-\n-        # Write the power spec contents to file and include it\n-        power_spec_file = os.path.join(self.run_dir, \"power_spec.{tpe}\".format(tpe=power_spec_type))\n-        with open(power_spec_file, \"w\") as f:\n-            f.write(power_spec_contents)\n-        return [\"read_power_intent -{arg} {path}\".format(arg=power_spec_arg, path=power_spec_file),\n-                \"commit_power_intent\"]\n-\n \n",
        "source_code_with_indent": "        <IND>self.tcl_append(cmd, self.output, clean)\n\n\n<DED><DED>class CadenceTool(HasSDCSupport, HasCPFSupport, HasUPFSupport, TCLTool, HammerTool):\n    <IND>\"\"\"Mix-in trait with functions useful for Cadence-based tools.\"\"\"\n\n    @property\n    def config_dirs(self) -> List[str]:\n        # Override this to pull in Cadence-common configs.\n        <IND>return [self.get_setting(\"cadence.common_path\")] + super().config_dirs\n\n    <DED>@property\n    def env_vars(self) -> Dict[str, str]:\n        <IND>\"\"\"\n        Get the list of environment variables required for this tool.\n        Note to subclasses: remember to include variables from super().env_vars!\n        \"\"\"\n        # Use the base extra_env_variables and ensure that our custom variables are on top.\n        list_of_vars = self.get_setting(\"cadence.extra_env_vars\")  # type: List[Dict[str, Any]]\n        assert isinstance(list_of_vars, list)\n\n        cadence_vars = {\n            \"CDS_LIC_FILE\": self.get_setting(\"cadence.CDS_LIC_FILE\"),\n            \"CADENCE_HOME\": self.get_setting(\"cadence.cadence_home\")\n        }\n\n        return reduce(add_dicts, [dict(super().env_vars)] + list_of_vars + [cadence_vars], {})\n\n    <DED>def version_number(self, version: str) -> int:\n        <IND>\"\"\"\n        Assumes versions look like MAJOR_ISRMINOR and we will have less than 100 minor versions.\n        \"\"\"\n        main_version = int(version.split(\"_\")[0]) # type: int\n        minor_version = 0 # type: int\n        if \"_\" in version:\n            <IND>minor_version = int(version.split(\"_\")[1][3:])\n        <DED>return main_version * 100 + minor_version\n\n    <DED>def get_timing_libs(self, corner: Optional[MMMCCorner] = None) -> str:\n        <IND>\"\"\"\n        Helper function to get the list of ASCII timing .lib files in space separated format.\n        Note that Cadence tools support ECSM, so we can use the ECSM-based filter.\n\n        :param corner: Optional corner to consider. If supplied, this will use filter_for_mmmc to select libraries that\n        match a given corner (voltage/temperature).\n        :return: List of lib files separated by spaces\n        \"\"\"\n        pre_filters = optional_map(corner, lambda c: [self.filter_for_mmmc(voltage=c.voltage,\n                                                                           temp=c.temp)])  # type: Optional[List[Callable[[hammer_tech.Library],bool]]]\n\n        lib_args = self.technology.read_libs([hammer_tech.filters.timing_lib_with_ecsm_filter],\n                                             hammer_tech.HammerTechnologyUtils.to_plain_item,\n                                             extra_pre_filters=pre_filters)\n        return \" \".join(lib_args)\n\n    <DED>def get_mmmc_qrc(self, corner: MMMCCorner) -> str:\n        <IND>lib_args = self.technology.read_libs([hammer_tech.filters.qrc_tech_filter],\n                                             hammer_tech.HammerTechnologyUtils.to_plain_item,\n                                             extra_pre_filters=[\n                                                 self.filter_for_mmmc(voltage=corner.voltage, temp=corner.temp)])\n        return \" \".join(lib_args)\n\n    <DED>def get_qrc_tech(self) -> str:\n        <IND>\"\"\"\n        Helper function to get the list of rc corner tech files in space separated format.\n\n        :return: List of qrc tech files separated by spaces\n        \"\"\"\n        lib_args = self.technology.read_libs([\n            hammer_tech.filters.qrc_tech_filter\n        ], hammer_tech.HammerTechnologyUtils.to_plain_item)\n        return \" \".join(lib_args)\n\n    <DED>def generate_mmmc_script(self) -> str:\n        <IND>\"\"\"\n        Output for the mmmc.tcl script.\n        Innovus (init_design) requires that the timing script be placed in a separate file.\n\n        :return: Contents of the mmmc script.\n        \"\"\"\n        mmmc_output = []  # type: List[str]\n\n        def append_mmmc(cmd: str) -> None:\n            <IND>self.verbose_tcl_append(cmd, mmmc_output)\n\n        # Create an Innovus constraint mode.\n        <DED>constraint_mode = \"my_constraint_mode\"\n        sdc_files = []  # type: List[str]\n\n        # Generate constraints\n        clock_constraints_fragment = os.path.join(self.run_dir, \"clock_constraints_fragment.sdc\")\n        with open(clock_constraints_fragment, \"w\") as f:\n            <IND>f.write(self.sdc_clock_constraints)\n        <DED>sdc_files.append(clock_constraints_fragment)\n\n        # Generate port constraints.\n        pin_constraints_fragment = os.path.join(self.run_dir, \"pin_constraints_fragment.sdc\")\n        with open(pin_constraints_fragment, \"w\") as f:\n            <IND>f.write(self.sdc_pin_constraints)\n        <DED>sdc_files.append(pin_constraints_fragment)\n\n        # Add the post-synthesis SDC, if present.\n        post_synth_sdc = self.post_synth_sdc\n        if post_synth_sdc is not None:\n            <IND>sdc_files.append(post_synth_sdc)\n\n        # TODO: add floorplanning SDC\n        <DED>if len(sdc_files) > 0:\n            <IND>sdc_files_arg = \"-sdc_files [list {sdc_files}]\".format(\n                sdc_files=\" \".join(sdc_files)\n            )\n        <DED>else:\n            <IND>blank_sdc = os.path.join(self.run_dir, \"blank.sdc\")\n            self.run_executable([\"touch\", blank_sdc])\n            sdc_files_arg = \"-sdc_files {{ {} }}\".format(blank_sdc)\n        <DED>append_mmmc(\"create_constraint_mode -name {name} {sdc_files_arg}\".format(\n            name=constraint_mode,\n            sdc_files_arg=sdc_files_arg\n        ))\n\n        corners = self.get_mmmc_corners()  # type: List[MMMCCorner]\n        # In parallel, create the delay corners\n        if corners:\n            <IND>setup_corner = corners[0]  # type: MMMCCorner\n            hold_corner = corners[0]  # type: MMMCCorner\n            # TODO(colins): handle more than one corner and do something with extra corners\n            for corner in corners:\n                <IND>if corner.type is MMMCCornerType.Setup:\n                    <IND>setup_corner = corner\n                <DED>if corner.type is MMMCCornerType.Hold:\n                    <IND>hold_corner = corner\n\n            # First, create Innovus library sets\n            <DED><DED>append_mmmc(\"create_library_set -name {name} -timing [list {list}]\".format(\n                name=\"{n}.setup_set\".format(n=setup_corner.name),\n                list=self.get_timing_libs(setup_corner)\n            ))\n            append_mmmc(\"create_library_set -name {name} -timing [list {list}]\".format(\n                name=\"{n}.hold_set\".format(n=hold_corner.name),\n                list=self.get_timing_libs(hold_corner)\n            ))\n            # Skip opconds for now\n            # Next, create Innovus timing conditions\n            append_mmmc(\"create_timing_condition -name {name} -library_sets [list {list}]\".format(\n                name=\"{n}.setup_cond\".format(n=setup_corner.name),\n                list=\"{n}.setup_set\".format(n=setup_corner.name)\n            ))\n            append_mmmc(\"create_timing_condition -name {name} -library_sets [list {list}]\".format(\n                name=\"{n}.hold_cond\".format(n=hold_corner.name),\n                list=\"{n}.hold_set\".format(n=hold_corner.name)\n            ))\n            # Next, create Innovus rc corners from qrc tech files\n            append_mmmc(\"create_rc_corner -name {name} -temperature {tempInCelsius} {qrc}\".format(\n                name=\"{n}.setup_rc\".format(n=setup_corner.name),\n                tempInCelsius=str(setup_corner.temp.value),\n                qrc=\"-qrc_tech {}\".format(self.get_mmmc_qrc(setup_corner)) if self.get_mmmc_qrc(setup_corner) != '' else ''\n            ))\n            append_mmmc(\"create_rc_corner -name {name} -temperature {tempInCelsius} {qrc}\".format(\n                name=\"{n}.hold_rc\".format(n=hold_corner.name),\n                tempInCelsius=str(hold_corner.temp.value),\n                qrc=\"-qrc_tech {}\".format(self.get_mmmc_qrc(hold_corner)) if self.get_mmmc_qrc(hold_corner) != '' else ''\n            ))\n            # Next, create an Innovus delay corner.\n            append_mmmc(\n                \"create_delay_corner -name {name}_delay -timing_condition {name}_cond -rc_corner {name}_rc\".format(\n                    name=\"{n}.setup\".format(n=setup_corner.name)\n                ))\n            append_mmmc(\n                \"create_delay_corner -name {name}_delay -timing_condition {name}_cond -rc_corner {name}_rc\".format(\n                    name=\"{n}.hold\".format(n=hold_corner.name)\n                ))\n            # Next, create the analysis views\n            append_mmmc(\"create_analysis_view -name {name}_view -delay_corner {name}_delay -constraint_mode {constraint}\".format(\n                name=\"{n}.setup\".format(n=setup_corner.name), constraint=constraint_mode))\n            append_mmmc(\"create_analysis_view -name {name}_view -delay_corner {name}_delay -constraint_mode {constraint}\".format(\n                name=\"{n}.hold\".format(n=hold_corner.name), constraint=constraint_mode))\n            # Finally, apply the analysis view.\n            append_mmmc(\"set_analysis_view -setup {{ {setup_view} }} -hold {{ {hold_view} }}\".format(\n                setup_view=\"{n}.setup_view\".format(n=setup_corner.name),\n                hold_view=\"{n}.hold_view\".format(n=hold_corner.name)\n            ))\n        <DED>else:\n            # First, create an Innovus library set.\n            <IND>library_set_name = \"my_lib_set\"\n            append_mmmc(\"create_library_set -name {name} -timing [list {list}]\".format(\n                name=library_set_name,\n                list=self.get_timing_libs()\n            ))\n            # Next, create an Innovus timing condition.\n            timing_condition_name = \"my_timing_condition\"\n            append_mmmc(\"create_timing_condition -name {name} -library_sets [list {list}]\".format(\n                name=timing_condition_name,\n                list=library_set_name\n            ))\n            # extra junk: -opcond ...\n            rc_corner_name = \"rc_cond\"\n            append_mmmc(\"create_rc_corner -name {name} -temperature {tempInCelsius} {qrc}\".format(\n                name=rc_corner_name,\n                tempInCelsius=120,  # TODO: this should come from tech config\n                qrc=\"-qrc_tech {}\".format(self.get_qrc_tech()) if self.get_qrc_tech() != '' else ''\n            ))\n            # Next, create an Innovus delay corner.\n            delay_corner_name = \"my_delay_corner\"\n            append_mmmc(\n                \"create_delay_corner -name {name} -timing_condition {timing_cond} -rc_corner {rc}\".format(\n                    name=delay_corner_name,\n                    timing_cond=timing_condition_name,\n                    rc=rc_corner_name\n                ))\n            # extra junk: -rc_corner my_rc_corner_maybe_worst\n            # Next, create an Innovus analysis view.\n            analysis_view_name = \"my_view\"\n            append_mmmc(\"create_analysis_view -name {name} -delay_corner {corner} -constraint_mode {constraint}\".format(\n                name=analysis_view_name, corner=delay_corner_name, constraint=constraint_mode))\n            # Finally, apply the analysis view.\n            # TODO: introduce different views of setup/hold and true multi-corner\n            append_mmmc(\"set_analysis_view -setup {{ {setup_view} }} -hold {{ {hold_view} }}\".format(\n                setup_view=analysis_view_name,\n                hold_view=analysis_view_name\n            ))\n\n        <DED>return \"\\n\".join(mmmc_output)\n\n    <DED>def generate_dont_use_commands(self) -> List[str]:\n        <IND>\"\"\"\n        Generate a list of dont_use commands for Cadence tools.\n        \"\"\"\n\n        def map_cell(in_cell: str) -> str:\n            # \"*/\" is needed for \"get_db lib_cells <cell_expression>\"\n            <IND>if in_cell.startswith(\"*/\"):\n                <IND>mapped_cell = in_cell  # type: str\n            <DED>else:\n                <IND>mapped_cell = \"*/\" + in_cell\n\n            # Check for cell existence first to avoid Genus erroring out.\n            <DED>get_db_str = \"[get_db lib_cells {mapped_cell}]\".format(mapped_cell=mapped_cell)\n            # Escaped version for puts.\n            get_db_str_escaped = get_db_str.replace('[', '\\[').replace(']', '\\]')\n            return \"\"\"\nputs \"set_dont_use {get_db_str_escaped}\"\nif {{ {get_db_str} ne \"\" }} {{\n    set_dont_use {get_db_str}\n}} else {{\n    puts \"WARNING: cell {mapped_cell} was not found for set_dont_use\"\n}}\n            \"\"\".format(get_db_str=get_db_str, get_db_str_escaped=get_db_str_escaped, mapped_cell=mapped_cell)\n\n        <DED>return list(map(map_cell, self.get_dont_use_list()))\n\n    <DED>def generate_power_spec_commands(self) -> List[str]:\n        <IND>\"\"\"\n        Generate commands to load a power specification for Cadence tools.\n        \"\"\"\n\n        power_spec_type = str(self.get_setting(\"vlsi.inputs.power_spec_type\"))  # type: str\n        power_spec_arg = \"\"  # type: str\n        if power_spec_type == \"cpf\":\n            <IND>power_spec_arg = \"cpf\"\n        <DED>elif power_spec_type == \"upf\":\n            <IND>power_spec_arg = \"1801\"\n        <DED>else:\n            <IND>self.logger.error(\n                \"Invalid power specification type '{tpe}'; only 'cpf' or 'upf' supported\".format(tpe=power_spec_type))\n            return []\n\n        <DED>power_spec_contents = \"\"  # type: str\n        power_spec_mode = str(self.get_setting(\"vlsi.inputs.power_spec_mode\"))  # type: str\n        if power_spec_mode == \"empty\":\n            <IND>return []\n        <DED>elif power_spec_mode == \"auto\":\n            <IND>if power_spec_type == \"cpf\":\n                <IND>power_spec_contents = self.cpf_power_specification\n            <DED>elif power_spec_type == \"upf\":\n                <IND>power_spec_contents = self.upf_power_specification\n        <DED><DED>elif power_spec_mode == \"manual\":\n            <IND>power_spec_contents = str(self.get_setting(\"vlsi.inputs.power_spec_contents\"))\n        <DED>else:\n            <IND>self.logger.error(\"Invalid power specification mode '{mode}'; using 'empty'.\".format(mode=power_spec_mode))\n            return []\n\n        # Write the power spec contents to file and include it\n        <DED>power_spec_file = os.path.join(self.run_dir, \"power_spec.{tpe}\".format(tpe=power_spec_type))\n        with open(power_spec_file, \"w\") as f:\n            <IND>f.write(power_spec_contents)\n        <DED>return [\"read_power_intent -{arg} {path}\".format(arg=power_spec_arg, path=power_spec_file),\n                \"commit_power_intent\"]\n\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "        <IND>self.tcl_append(cmd, self.output, clean)\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "ucb-bar/hammer",
    "commit": "3afca0f00301e87b3112d42284a6acfd3c083c42",
    "filename": "src/hammer-vlsi/hammer_vlsi/hammer_vlsi_impl.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/ucb-bar-hammer/src/hammer-vlsi/hammer_vlsi/hammer_vlsi_impl.py",
    "file_hunks_size": 13,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": true,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "src/hammer-vlsi/hammer_vlsi/hammer_vlsi_impl.py:1593:32 Invalid type [31]: Expression `src.hammer.__sub__(vlsi.hammer_vlsi.constraints.List[str])` is not a valid type.",
    "message": " Expression `src.hammer.__sub__(vlsi.hammer_vlsi.constraints.List[str])` is not a valid type.",
    "rule_id": "Invalid type [31]",
    "warning_line_no": 1593,
    "warning_line": "        sdc_files = []  # type: List[str]",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": true,
        "has_suppression": false,
        "source_code": "        self.tcl_append(cmd, self.output, clean)\n\n\nclass CadenceTool(HasSDCSupport, HasCPFSupport, HasUPFSupport, TCLTool, HammerTool):\n    \"\"\"Mix-in trait with functions useful for Cadence-based tools.\"\"\"\n\n    @property\n    def config_dirs(self) -> List[str]:\n        # Override this to pull in Cadence-common configs.\n        return [self.get_setting(\"cadence.common_path\")] + super().config_dirs\n\n    @property\n    def env_vars(self) -> Dict[str, str]:\n        \"\"\"\n        Get the list of environment variables required for this tool.\n        Note to subclasses: remember to include variables from super().env_vars!\n        \"\"\"\n        # Use the base extra_env_variables and ensure that our custom variables are on top.\n        list_of_vars = self.get_setting(\"cadence.extra_env_vars\")  # type: List[Dict[str, Any]]\n        assert isinstance(list_of_vars, list)\n\n        cadence_vars = {\n            \"CDS_LIC_FILE\": self.get_setting(\"cadence.CDS_LIC_FILE\"),\n            \"CADENCE_HOME\": self.get_setting(\"cadence.cadence_home\")\n        }\n\n        return reduce(add_dicts, [dict(super().env_vars)] + list_of_vars + [cadence_vars], {})\n\n    def version_number(self, version: str) -> int:\n        \"\"\"\n        Assumes versions look like MAJOR_ISRMINOR and we will have less than 100 minor versions.\n        \"\"\"\n        main_version = int(version.split(\"_\")[0]) # type: int\n        minor_version = 0 # type: int\n        if \"_\" in version:\n            minor_version = int(version.split(\"_\")[1][3:])\n        return main_version * 100 + minor_version\n\n    def get_timing_libs(self, corner: Optional[MMMCCorner] = None) -> str:\n        \"\"\"\n        Helper function to get the list of ASCII timing .lib files in space separated format.\n        Note that Cadence tools support ECSM, so we can use the ECSM-based filter.\n\n        :param corner: Optional corner to consider. If supplied, this will use filter_for_mmmc to select libraries that\n        match a given corner (voltage/temperature).\n        :return: List of lib files separated by spaces\n        \"\"\"\n        pre_filters = optional_map(corner, lambda c: [self.filter_for_mmmc(voltage=c.voltage,\n                                                                           temp=c.temp)])  # type: Optional[List[Callable[[hammer_tech.Library],bool]]]\n\n        lib_args = self.technology.read_libs([hammer_tech.filters.timing_lib_with_ecsm_filter],\n                                             hammer_tech.HammerTechnologyUtils.to_plain_item,\n                                             extra_pre_filters=pre_filters)\n        return \" \".join(lib_args)\n\n    def get_mmmc_qrc(self, corner: MMMCCorner) -> str:\n        lib_args = self.technology.read_libs([hammer_tech.filters.qrc_tech_filter],\n                                             hammer_tech.HammerTechnologyUtils.to_plain_item,\n                                             extra_pre_filters=[\n                                                 self.filter_for_mmmc(voltage=corner.voltage, temp=corner.temp)])\n        return \" \".join(lib_args)\n\n    def get_qrc_tech(self) -> str:\n        \"\"\"\n        Helper function to get the list of rc corner tech files in space separated format.\n\n        :return: List of qrc tech files separated by spaces\n        \"\"\"\n        lib_args = self.technology.read_libs([\n            hammer_tech.filters.qrc_tech_filter\n        ], hammer_tech.HammerTechnologyUtils.to_plain_item)\n        return \" \".join(lib_args)\n\n    def generate_mmmc_script(self) -> str:\n        \"\"\"\n        Output for the mmmc.tcl script.\n        Innovus (init_design) requires that the timing script be placed in a separate file.\n\n        :return: Contents of the mmmc script.\n        \"\"\"\n        mmmc_output = []  # type: List[str]\n\n        def append_mmmc(cmd: str) -> None:\n            self.verbose_tcl_append(cmd, mmmc_output)\n\n        # Create an Innovus constraint mode.\n        constraint_mode = \"my_constraint_mode\"\n        sdc_files = []  # type: List[str]\n\n        # Generate constraints\n        clock_constraints_fragment = os.path.join(self.run_dir, \"clock_constraints_fragment.sdc\")\n        with open(clock_constraints_fragment, \"w\") as f:\n            f.write(self.sdc_clock_constraints)\n        sdc_files.append(clock_constraints_fragment)\n\n        # Generate port constraints.\n        pin_constraints_fragment = os.path.join(self.run_dir, \"pin_constraints_fragment.sdc\")\n        with open(pin_constraints_fragment, \"w\") as f:\n            f.write(self.sdc_pin_constraints)\n        sdc_files.append(pin_constraints_fragment)\n\n        # Add the post-synthesis SDC, if present.\n        post_synth_sdc = self.post_synth_sdc\n        if post_synth_sdc is not None:\n            sdc_files.append(post_synth_sdc)\n\n        # TODO: add floorplanning SDC\n        if len(sdc_files) > 0:\n            sdc_files_arg = \"-sdc_files [list {sdc_files}]\".format(\n                sdc_files=\" \".join(sdc_files)\n            )\n        else:\n            blank_sdc = os.path.join(self.run_dir, \"blank.sdc\")\n            self.run_executable([\"touch\", blank_sdc])\n            sdc_files_arg = \"-sdc_files {{ {} }}\".format(blank_sdc)\n        append_mmmc(\"create_constraint_mode -name {name} {sdc_files_arg}\".format(\n            name=constraint_mode,\n            sdc_files_arg=sdc_files_arg\n        ))\n\n        corners = self.get_mmmc_corners()  # type: List[MMMCCorner]\n        # In parallel, create the delay corners\n        if corners:\n            setup_corner = corners[0]  # type: MMMCCorner\n            hold_corner = corners[0]  # type: MMMCCorner\n            # TODO(colins): handle more than one corner and do something with extra corners\n            for corner in corners:\n                if corner.type is MMMCCornerType.Setup:\n                    setup_corner = corner\n                if corner.type is MMMCCornerType.Hold:\n                    hold_corner = corner\n\n            # First, create Innovus library sets\n            append_mmmc(\"create_library_set -name {name} -timing [list {list}]\".format(\n                name=\"{n}.setup_set\".format(n=setup_corner.name),\n                list=self.get_timing_libs(setup_corner)\n            ))\n            append_mmmc(\"create_library_set -name {name} -timing [list {list}]\".format(\n                name=\"{n}.hold_set\".format(n=hold_corner.name),\n                list=self.get_timing_libs(hold_corner)\n            ))\n            # Skip opconds for now\n            # Next, create Innovus timing conditions\n            append_mmmc(\"create_timing_condition -name {name} -library_sets [list {list}]\".format(\n                name=\"{n}.setup_cond\".format(n=setup_corner.name),\n                list=\"{n}.setup_set\".format(n=setup_corner.name)\n            ))\n            append_mmmc(\"create_timing_condition -name {name} -library_sets [list {list}]\".format(\n                name=\"{n}.hold_cond\".format(n=hold_corner.name),\n                list=\"{n}.hold_set\".format(n=hold_corner.name)\n            ))\n            # Next, create Innovus rc corners from qrc tech files\n            append_mmmc(\"create_rc_corner -name {name} -temperature {tempInCelsius} {qrc}\".format(\n                name=\"{n}.setup_rc\".format(n=setup_corner.name),\n                tempInCelsius=str(setup_corner.temp.value),\n                qrc=\"-qrc_tech {}\".format(self.get_mmmc_qrc(setup_corner)) if self.get_mmmc_qrc(setup_corner) != '' else ''\n            ))\n            append_mmmc(\"create_rc_corner -name {name} -temperature {tempInCelsius} {qrc}\".format(\n                name=\"{n}.hold_rc\".format(n=hold_corner.name),\n                tempInCelsius=str(hold_corner.temp.value),\n                qrc=\"-qrc_tech {}\".format(self.get_mmmc_qrc(hold_corner)) if self.get_mmmc_qrc(hold_corner) != '' else ''\n            ))\n            # Next, create an Innovus delay corner.\n            append_mmmc(\n                \"create_delay_corner -name {name}_delay -timing_condition {name}_cond -rc_corner {name}_rc\".format(\n                    name=\"{n}.setup\".format(n=setup_corner.name)\n                ))\n            append_mmmc(\n                \"create_delay_corner -name {name}_delay -timing_condition {name}_cond -rc_corner {name}_rc\".format(\n                    name=\"{n}.hold\".format(n=hold_corner.name)\n                ))\n            # Next, create the analysis views\n            append_mmmc(\"create_analysis_view -name {name}_view -delay_corner {name}_delay -constraint_mode {constraint}\".format(\n                name=\"{n}.setup\".format(n=setup_corner.name), constraint=constraint_mode))\n            append_mmmc(\"create_analysis_view -name {name}_view -delay_corner {name}_delay -constraint_mode {constraint}\".format(\n                name=\"{n}.hold\".format(n=hold_corner.name), constraint=constraint_mode))\n            # Finally, apply the analysis view.\n            append_mmmc(\"set_analysis_view -setup {{ {setup_view} }} -hold {{ {hold_view} }}\".format(\n                setup_view=\"{n}.setup_view\".format(n=setup_corner.name),\n                hold_view=\"{n}.hold_view\".format(n=hold_corner.name)\n            ))\n        else:\n            # First, create an Innovus library set.\n            library_set_name = \"my_lib_set\"\n            append_mmmc(\"create_library_set -name {name} -timing [list {list}]\".format(\n                name=library_set_name,\n                list=self.get_timing_libs()\n            ))\n            # Next, create an Innovus timing condition.\n            timing_condition_name = \"my_timing_condition\"\n            append_mmmc(\"create_timing_condition -name {name} -library_sets [list {list}]\".format(\n                name=timing_condition_name,\n                list=library_set_name\n            ))\n            # extra junk: -opcond ...\n            rc_corner_name = \"rc_cond\"\n            append_mmmc(\"create_rc_corner -name {name} -temperature {tempInCelsius} {qrc}\".format(\n                name=rc_corner_name,\n                tempInCelsius=120,  # TODO: this should come from tech config\n                qrc=\"-qrc_tech {}\".format(self.get_qrc_tech()) if self.get_qrc_tech() != '' else ''\n            ))\n            # Next, create an Innovus delay corner.\n            delay_corner_name = \"my_delay_corner\"\n            append_mmmc(\n                \"create_delay_corner -name {name} -timing_condition {timing_cond} -rc_corner {rc}\".format(\n                    name=delay_corner_name,\n                    timing_cond=timing_condition_name,\n                    rc=rc_corner_name\n                ))\n            # extra junk: -rc_corner my_rc_corner_maybe_worst\n            # Next, create an Innovus analysis view.\n            analysis_view_name = \"my_view\"\n            append_mmmc(\"create_analysis_view -name {name} -delay_corner {corner} -constraint_mode {constraint}\".format(\n                name=analysis_view_name, corner=delay_corner_name, constraint=constraint_mode))\n            # Finally, apply the analysis view.\n            # TODO: introduce different views of setup/hold and true multi-corner\n            append_mmmc(\"set_analysis_view -setup {{ {setup_view} }} -hold {{ {hold_view} }}\".format(\n                setup_view=analysis_view_name,\n                hold_view=analysis_view_name\n            ))\n\n        return \"\\n\".join(mmmc_output)\n\n    def generate_dont_use_commands(self) -> List[str]:\n        \"\"\"\n        Generate a list of dont_use commands for Cadence tools.\n        \"\"\"\n\n        def map_cell(in_cell: str) -> str:\n            # \"*/\" is needed for \"get_db lib_cells <cell_expression>\"\n            if in_cell.startswith(\"*/\"):\n                mapped_cell = in_cell  # type: str\n            else:\n                mapped_cell = \"*/\" + in_cell\n\n            # Check for cell existence first to avoid Genus erroring out.\n            get_db_str = \"[get_db lib_cells {mapped_cell}]\".format(mapped_cell=mapped_cell)\n            # Escaped version for puts.\n            get_db_str_escaped = get_db_str.replace('[', '\\[').replace(']', '\\]')\n            return \"\"\"\nputs \"set_dont_use {get_db_str_escaped}\"\nif {{ {get_db_str} ne \"\" }} {{\n    set_dont_use {get_db_str}\n}} else {{\n    puts \"WARNING: cell {mapped_cell} was not found for set_dont_use\"\n}}\n            \"\"\".format(get_db_str=get_db_str, get_db_str_escaped=get_db_str_escaped, mapped_cell=mapped_cell)\n\n        return list(map(map_cell, self.get_dont_use_list()))\n\n    def generate_power_spec_commands(self) -> List[str]:\n        \"\"\"\n        Generate commands to load a power specification for Cadence tools.\n        \"\"\"\n\n        power_spec_type = str(self.get_setting(\"vlsi.inputs.power_spec_type\"))  # type: str\n        power_spec_arg = \"\"  # type: str\n        if power_spec_type == \"cpf\":\n            power_spec_arg = \"cpf\"\n        elif power_spec_type == \"upf\":\n            power_spec_arg = \"1801\"\n        else:\n            self.logger.error(\n                \"Invalid power specification type '{tpe}'; only 'cpf' or 'upf' supported\".format(tpe=power_spec_type))\n            return []\n\n        power_spec_contents = \"\"  # type: str\n        power_spec_mode = str(self.get_setting(\"vlsi.inputs.power_spec_mode\"))  # type: str\n        if power_spec_mode == \"empty\":\n            return []\n        elif power_spec_mode == \"auto\":\n            if power_spec_type == \"cpf\":\n                power_spec_contents = self.cpf_power_specification\n            elif power_spec_type == \"upf\":\n                power_spec_contents = self.upf_power_specification\n        elif power_spec_mode == \"manual\":\n            power_spec_contents = str(self.get_setting(\"vlsi.inputs.power_spec_contents\"))\n        else:\n            self.logger.error(\"Invalid power specification mode '{mode}'; using 'empty'.\".format(mode=power_spec_mode))\n            return []\n\n        # Write the power spec contents to file and include it\n        power_spec_file = os.path.join(self.run_dir, \"power_spec.{tpe}\".format(tpe=power_spec_type))\n        with open(power_spec_file, \"w\") as f:\n            f.write(power_spec_contents)\n        return [\"read_power_intent -{arg} {path}\".format(arg=power_spec_arg, path=power_spec_file),\n                \"commit_power_intent\"]\n\n\n",
        "source_code_len": 14014,
        "target_code": "        self.tcl_append(cmd, self.output, clean)\n\n",
        "target_code_len": 50,
        "diff_format": "@@ -1506,289 +1506,2 @@\n         self.tcl_append(cmd, self.output, clean)\n-\n-\n-class CadenceTool(HasSDCSupport, HasCPFSupport, HasUPFSupport, TCLTool, HammerTool):\n-    \"\"\"Mix-in trait with functions useful for Cadence-based tools.\"\"\"\n-\n-    @property\n-    def config_dirs(self) -> List[str]:\n-        # Override this to pull in Cadence-common configs.\n-        return [self.get_setting(\"cadence.common_path\")] + super().config_dirs\n-\n-    @property\n-    def env_vars(self) -> Dict[str, str]:\n-        \"\"\"\n-        Get the list of environment variables required for this tool.\n-        Note to subclasses: remember to include variables from super().env_vars!\n-        \"\"\"\n-        # Use the base extra_env_variables and ensure that our custom variables are on top.\n-        list_of_vars = self.get_setting(\"cadence.extra_env_vars\")  # type: List[Dict[str, Any]]\n-        assert isinstance(list_of_vars, list)\n-\n-        cadence_vars = {\n-            \"CDS_LIC_FILE\": self.get_setting(\"cadence.CDS_LIC_FILE\"),\n-            \"CADENCE_HOME\": self.get_setting(\"cadence.cadence_home\")\n-        }\n-\n-        return reduce(add_dicts, [dict(super().env_vars)] + list_of_vars + [cadence_vars], {})\n-\n-    def version_number(self, version: str) -> int:\n-        \"\"\"\n-        Assumes versions look like MAJOR_ISRMINOR and we will have less than 100 minor versions.\n-        \"\"\"\n-        main_version = int(version.split(\"_\")[0]) # type: int\n-        minor_version = 0 # type: int\n-        if \"_\" in version:\n-            minor_version = int(version.split(\"_\")[1][3:])\n-        return main_version * 100 + minor_version\n-\n-    def get_timing_libs(self, corner: Optional[MMMCCorner] = None) -> str:\n-        \"\"\"\n-        Helper function to get the list of ASCII timing .lib files in space separated format.\n-        Note that Cadence tools support ECSM, so we can use the ECSM-based filter.\n-\n-        :param corner: Optional corner to consider. If supplied, this will use filter_for_mmmc to select libraries that\n-        match a given corner (voltage/temperature).\n-        :return: List of lib files separated by spaces\n-        \"\"\"\n-        pre_filters = optional_map(corner, lambda c: [self.filter_for_mmmc(voltage=c.voltage,\n-                                                                           temp=c.temp)])  # type: Optional[List[Callable[[hammer_tech.Library],bool]]]\n-\n-        lib_args = self.technology.read_libs([hammer_tech.filters.timing_lib_with_ecsm_filter],\n-                                             hammer_tech.HammerTechnologyUtils.to_plain_item,\n-                                             extra_pre_filters=pre_filters)\n-        return \" \".join(lib_args)\n-\n-    def get_mmmc_qrc(self, corner: MMMCCorner) -> str:\n-        lib_args = self.technology.read_libs([hammer_tech.filters.qrc_tech_filter],\n-                                             hammer_tech.HammerTechnologyUtils.to_plain_item,\n-                                             extra_pre_filters=[\n-                                                 self.filter_for_mmmc(voltage=corner.voltage, temp=corner.temp)])\n-        return \" \".join(lib_args)\n-\n-    def get_qrc_tech(self) -> str:\n-        \"\"\"\n-        Helper function to get the list of rc corner tech files in space separated format.\n-\n-        :return: List of qrc tech files separated by spaces\n-        \"\"\"\n-        lib_args = self.technology.read_libs([\n-            hammer_tech.filters.qrc_tech_filter\n-        ], hammer_tech.HammerTechnologyUtils.to_plain_item)\n-        return \" \".join(lib_args)\n-\n-    def generate_mmmc_script(self) -> str:\n-        \"\"\"\n-        Output for the mmmc.tcl script.\n-        Innovus (init_design) requires that the timing script be placed in a separate file.\n-\n-        :return: Contents of the mmmc script.\n-        \"\"\"\n-        mmmc_output = []  # type: List[str]\n-\n-        def append_mmmc(cmd: str) -> None:\n-            self.verbose_tcl_append(cmd, mmmc_output)\n-\n-        # Create an Innovus constraint mode.\n-        constraint_mode = \"my_constraint_mode\"\n-        sdc_files = []  # type: List[str]\n-\n-        # Generate constraints\n-        clock_constraints_fragment = os.path.join(self.run_dir, \"clock_constraints_fragment.sdc\")\n-        with open(clock_constraints_fragment, \"w\") as f:\n-            f.write(self.sdc_clock_constraints)\n-        sdc_files.append(clock_constraints_fragment)\n-\n-        # Generate port constraints.\n-        pin_constraints_fragment = os.path.join(self.run_dir, \"pin_constraints_fragment.sdc\")\n-        with open(pin_constraints_fragment, \"w\") as f:\n-            f.write(self.sdc_pin_constraints)\n-        sdc_files.append(pin_constraints_fragment)\n-\n-        # Add the post-synthesis SDC, if present.\n-        post_synth_sdc = self.post_synth_sdc\n-        if post_synth_sdc is not None:\n-            sdc_files.append(post_synth_sdc)\n-\n-        # TODO: add floorplanning SDC\n-        if len(sdc_files) > 0:\n-            sdc_files_arg = \"-sdc_files [list {sdc_files}]\".format(\n-                sdc_files=\" \".join(sdc_files)\n-            )\n-        else:\n-            blank_sdc = os.path.join(self.run_dir, \"blank.sdc\")\n-            self.run_executable([\"touch\", blank_sdc])\n-            sdc_files_arg = \"-sdc_files {{ {} }}\".format(blank_sdc)\n-        append_mmmc(\"create_constraint_mode -name {name} {sdc_files_arg}\".format(\n-            name=constraint_mode,\n-            sdc_files_arg=sdc_files_arg\n-        ))\n-\n-        corners = self.get_mmmc_corners()  # type: List[MMMCCorner]\n-        # In parallel, create the delay corners\n-        if corners:\n-            setup_corner = corners[0]  # type: MMMCCorner\n-            hold_corner = corners[0]  # type: MMMCCorner\n-            # TODO(colins): handle more than one corner and do something with extra corners\n-            for corner in corners:\n-                if corner.type is MMMCCornerType.Setup:\n-                    setup_corner = corner\n-                if corner.type is MMMCCornerType.Hold:\n-                    hold_corner = corner\n-\n-            # First, create Innovus library sets\n-            append_mmmc(\"create_library_set -name {name} -timing [list {list}]\".format(\n-                name=\"{n}.setup_set\".format(n=setup_corner.name),\n-                list=self.get_timing_libs(setup_corner)\n-            ))\n-            append_mmmc(\"create_library_set -name {name} -timing [list {list}]\".format(\n-                name=\"{n}.hold_set\".format(n=hold_corner.name),\n-                list=self.get_timing_libs(hold_corner)\n-            ))\n-            # Skip opconds for now\n-            # Next, create Innovus timing conditions\n-            append_mmmc(\"create_timing_condition -name {name} -library_sets [list {list}]\".format(\n-                name=\"{n}.setup_cond\".format(n=setup_corner.name),\n-                list=\"{n}.setup_set\".format(n=setup_corner.name)\n-            ))\n-            append_mmmc(\"create_timing_condition -name {name} -library_sets [list {list}]\".format(\n-                name=\"{n}.hold_cond\".format(n=hold_corner.name),\n-                list=\"{n}.hold_set\".format(n=hold_corner.name)\n-            ))\n-            # Next, create Innovus rc corners from qrc tech files\n-            append_mmmc(\"create_rc_corner -name {name} -temperature {tempInCelsius} {qrc}\".format(\n-                name=\"{n}.setup_rc\".format(n=setup_corner.name),\n-                tempInCelsius=str(setup_corner.temp.value),\n-                qrc=\"-qrc_tech {}\".format(self.get_mmmc_qrc(setup_corner)) if self.get_mmmc_qrc(setup_corner) != '' else ''\n-            ))\n-            append_mmmc(\"create_rc_corner -name {name} -temperature {tempInCelsius} {qrc}\".format(\n-                name=\"{n}.hold_rc\".format(n=hold_corner.name),\n-                tempInCelsius=str(hold_corner.temp.value),\n-                qrc=\"-qrc_tech {}\".format(self.get_mmmc_qrc(hold_corner)) if self.get_mmmc_qrc(hold_corner) != '' else ''\n-            ))\n-            # Next, create an Innovus delay corner.\n-            append_mmmc(\n-                \"create_delay_corner -name {name}_delay -timing_condition {name}_cond -rc_corner {name}_rc\".format(\n-                    name=\"{n}.setup\".format(n=setup_corner.name)\n-                ))\n-            append_mmmc(\n-                \"create_delay_corner -name {name}_delay -timing_condition {name}_cond -rc_corner {name}_rc\".format(\n-                    name=\"{n}.hold\".format(n=hold_corner.name)\n-                ))\n-            # Next, create the analysis views\n-            append_mmmc(\"create_analysis_view -name {name}_view -delay_corner {name}_delay -constraint_mode {constraint}\".format(\n-                name=\"{n}.setup\".format(n=setup_corner.name), constraint=constraint_mode))\n-            append_mmmc(\"create_analysis_view -name {name}_view -delay_corner {name}_delay -constraint_mode {constraint}\".format(\n-                name=\"{n}.hold\".format(n=hold_corner.name), constraint=constraint_mode))\n-            # Finally, apply the analysis view.\n-            append_mmmc(\"set_analysis_view -setup {{ {setup_view} }} -hold {{ {hold_view} }}\".format(\n-                setup_view=\"{n}.setup_view\".format(n=setup_corner.name),\n-                hold_view=\"{n}.hold_view\".format(n=hold_corner.name)\n-            ))\n-        else:\n-            # First, create an Innovus library set.\n-            library_set_name = \"my_lib_set\"\n-            append_mmmc(\"create_library_set -name {name} -timing [list {list}]\".format(\n-                name=library_set_name,\n-                list=self.get_timing_libs()\n-            ))\n-            # Next, create an Innovus timing condition.\n-            timing_condition_name = \"my_timing_condition\"\n-            append_mmmc(\"create_timing_condition -name {name} -library_sets [list {list}]\".format(\n-                name=timing_condition_name,\n-                list=library_set_name\n-            ))\n-            # extra junk: -opcond ...\n-            rc_corner_name = \"rc_cond\"\n-            append_mmmc(\"create_rc_corner -name {name} -temperature {tempInCelsius} {qrc}\".format(\n-                name=rc_corner_name,\n-                tempInCelsius=120,  # TODO: this should come from tech config\n-                qrc=\"-qrc_tech {}\".format(self.get_qrc_tech()) if self.get_qrc_tech() != '' else ''\n-            ))\n-            # Next, create an Innovus delay corner.\n-            delay_corner_name = \"my_delay_corner\"\n-            append_mmmc(\n-                \"create_delay_corner -name {name} -timing_condition {timing_cond} -rc_corner {rc}\".format(\n-                    name=delay_corner_name,\n-                    timing_cond=timing_condition_name,\n-                    rc=rc_corner_name\n-                ))\n-            # extra junk: -rc_corner my_rc_corner_maybe_worst\n-            # Next, create an Innovus analysis view.\n-            analysis_view_name = \"my_view\"\n-            append_mmmc(\"create_analysis_view -name {name} -delay_corner {corner} -constraint_mode {constraint}\".format(\n-                name=analysis_view_name, corner=delay_corner_name, constraint=constraint_mode))\n-            # Finally, apply the analysis view.\n-            # TODO: introduce different views of setup/hold and true multi-corner\n-            append_mmmc(\"set_analysis_view -setup {{ {setup_view} }} -hold {{ {hold_view} }}\".format(\n-                setup_view=analysis_view_name,\n-                hold_view=analysis_view_name\n-            ))\n-\n-        return \"\\n\".join(mmmc_output)\n-\n-    def generate_dont_use_commands(self) -> List[str]:\n-        \"\"\"\n-        Generate a list of dont_use commands for Cadence tools.\n-        \"\"\"\n-\n-        def map_cell(in_cell: str) -> str:\n-            # \"*/\" is needed for \"get_db lib_cells <cell_expression>\"\n-            if in_cell.startswith(\"*/\"):\n-                mapped_cell = in_cell  # type: str\n-            else:\n-                mapped_cell = \"*/\" + in_cell\n-\n-            # Check for cell existence first to avoid Genus erroring out.\n-            get_db_str = \"[get_db lib_cells {mapped_cell}]\".format(mapped_cell=mapped_cell)\n-            # Escaped version for puts.\n-            get_db_str_escaped = get_db_str.replace('[', '\\[').replace(']', '\\]')\n-            return \"\"\"\n-puts \"set_dont_use {get_db_str_escaped}\"\n-if {{ {get_db_str} ne \"\" }} {{\n-    set_dont_use {get_db_str}\n-}} else {{\n-    puts \"WARNING: cell {mapped_cell} was not found for set_dont_use\"\n-}}\n-            \"\"\".format(get_db_str=get_db_str, get_db_str_escaped=get_db_str_escaped, mapped_cell=mapped_cell)\n-\n-        return list(map(map_cell, self.get_dont_use_list()))\n-\n-    def generate_power_spec_commands(self) -> List[str]:\n-        \"\"\"\n-        Generate commands to load a power specification for Cadence tools.\n-        \"\"\"\n-\n-        power_spec_type = str(self.get_setting(\"vlsi.inputs.power_spec_type\"))  # type: str\n-        power_spec_arg = \"\"  # type: str\n-        if power_spec_type == \"cpf\":\n-            power_spec_arg = \"cpf\"\n-        elif power_spec_type == \"upf\":\n-            power_spec_arg = \"1801\"\n-        else:\n-            self.logger.error(\n-                \"Invalid power specification type '{tpe}'; only 'cpf' or 'upf' supported\".format(tpe=power_spec_type))\n-            return []\n-\n-        power_spec_contents = \"\"  # type: str\n-        power_spec_mode = str(self.get_setting(\"vlsi.inputs.power_spec_mode\"))  # type: str\n-        if power_spec_mode == \"empty\":\n-            return []\n-        elif power_spec_mode == \"auto\":\n-            if power_spec_type == \"cpf\":\n-                power_spec_contents = self.cpf_power_specification\n-            elif power_spec_type == \"upf\":\n-                power_spec_contents = self.upf_power_specification\n-        elif power_spec_mode == \"manual\":\n-            power_spec_contents = str(self.get_setting(\"vlsi.inputs.power_spec_contents\"))\n-        else:\n-            self.logger.error(\"Invalid power specification mode '{mode}'; using 'empty'.\".format(mode=power_spec_mode))\n-            return []\n-\n-        # Write the power spec contents to file and include it\n-        power_spec_file = os.path.join(self.run_dir, \"power_spec.{tpe}\".format(tpe=power_spec_type))\n-        with open(power_spec_file, \"w\") as f:\n-            f.write(power_spec_contents)\n-        return [\"read_power_intent -{arg} {path}\".format(arg=power_spec_arg, path=power_spec_file),\n-                \"commit_power_intent\"]\n-\n \n",
        "source_code_with_indent": "        <IND>self.tcl_append(cmd, self.output, clean)\n\n\n<DED><DED>class CadenceTool(HasSDCSupport, HasCPFSupport, HasUPFSupport, TCLTool, HammerTool):\n    <IND>\"\"\"Mix-in trait with functions useful for Cadence-based tools.\"\"\"\n\n    @property\n    def config_dirs(self) -> List[str]:\n        # Override this to pull in Cadence-common configs.\n        <IND>return [self.get_setting(\"cadence.common_path\")] + super().config_dirs\n\n    <DED>@property\n    def env_vars(self) -> Dict[str, str]:\n        <IND>\"\"\"\n        Get the list of environment variables required for this tool.\n        Note to subclasses: remember to include variables from super().env_vars!\n        \"\"\"\n        # Use the base extra_env_variables and ensure that our custom variables are on top.\n        list_of_vars = self.get_setting(\"cadence.extra_env_vars\")  # type: List[Dict[str, Any]]\n        assert isinstance(list_of_vars, list)\n\n        cadence_vars = {\n            \"CDS_LIC_FILE\": self.get_setting(\"cadence.CDS_LIC_FILE\"),\n            \"CADENCE_HOME\": self.get_setting(\"cadence.cadence_home\")\n        }\n\n        return reduce(add_dicts, [dict(super().env_vars)] + list_of_vars + [cadence_vars], {})\n\n    <DED>def version_number(self, version: str) -> int:\n        <IND>\"\"\"\n        Assumes versions look like MAJOR_ISRMINOR and we will have less than 100 minor versions.\n        \"\"\"\n        main_version = int(version.split(\"_\")[0]) # type: int\n        minor_version = 0 # type: int\n        if \"_\" in version:\n            <IND>minor_version = int(version.split(\"_\")[1][3:])\n        <DED>return main_version * 100 + minor_version\n\n    <DED>def get_timing_libs(self, corner: Optional[MMMCCorner] = None) -> str:\n        <IND>\"\"\"\n        Helper function to get the list of ASCII timing .lib files in space separated format.\n        Note that Cadence tools support ECSM, so we can use the ECSM-based filter.\n\n        :param corner: Optional corner to consider. If supplied, this will use filter_for_mmmc to select libraries that\n        match a given corner (voltage/temperature).\n        :return: List of lib files separated by spaces\n        \"\"\"\n        pre_filters = optional_map(corner, lambda c: [self.filter_for_mmmc(voltage=c.voltage,\n                                                                           temp=c.temp)])  # type: Optional[List[Callable[[hammer_tech.Library],bool]]]\n\n        lib_args = self.technology.read_libs([hammer_tech.filters.timing_lib_with_ecsm_filter],\n                                             hammer_tech.HammerTechnologyUtils.to_plain_item,\n                                             extra_pre_filters=pre_filters)\n        return \" \".join(lib_args)\n\n    <DED>def get_mmmc_qrc(self, corner: MMMCCorner) -> str:\n        <IND>lib_args = self.technology.read_libs([hammer_tech.filters.qrc_tech_filter],\n                                             hammer_tech.HammerTechnologyUtils.to_plain_item,\n                                             extra_pre_filters=[\n                                                 self.filter_for_mmmc(voltage=corner.voltage, temp=corner.temp)])\n        return \" \".join(lib_args)\n\n    <DED>def get_qrc_tech(self) -> str:\n        <IND>\"\"\"\n        Helper function to get the list of rc corner tech files in space separated format.\n\n        :return: List of qrc tech files separated by spaces\n        \"\"\"\n        lib_args = self.technology.read_libs([\n            hammer_tech.filters.qrc_tech_filter\n        ], hammer_tech.HammerTechnologyUtils.to_plain_item)\n        return \" \".join(lib_args)\n\n    <DED>def generate_mmmc_script(self) -> str:\n        <IND>\"\"\"\n        Output for the mmmc.tcl script.\n        Innovus (init_design) requires that the timing script be placed in a separate file.\n\n        :return: Contents of the mmmc script.\n        \"\"\"\n        mmmc_output = []  # type: List[str]\n\n        def append_mmmc(cmd: str) -> None:\n            <IND>self.verbose_tcl_append(cmd, mmmc_output)\n\n        # Create an Innovus constraint mode.\n        <DED>constraint_mode = \"my_constraint_mode\"\n        sdc_files = []  # type: List[str]\n\n        # Generate constraints\n        clock_constraints_fragment = os.path.join(self.run_dir, \"clock_constraints_fragment.sdc\")\n        with open(clock_constraints_fragment, \"w\") as f:\n            <IND>f.write(self.sdc_clock_constraints)\n        <DED>sdc_files.append(clock_constraints_fragment)\n\n        # Generate port constraints.\n        pin_constraints_fragment = os.path.join(self.run_dir, \"pin_constraints_fragment.sdc\")\n        with open(pin_constraints_fragment, \"w\") as f:\n            <IND>f.write(self.sdc_pin_constraints)\n        <DED>sdc_files.append(pin_constraints_fragment)\n\n        # Add the post-synthesis SDC, if present.\n        post_synth_sdc = self.post_synth_sdc\n        if post_synth_sdc is not None:\n            <IND>sdc_files.append(post_synth_sdc)\n\n        # TODO: add floorplanning SDC\n        <DED>if len(sdc_files) > 0:\n            <IND>sdc_files_arg = \"-sdc_files [list {sdc_files}]\".format(\n                sdc_files=\" \".join(sdc_files)\n            )\n        <DED>else:\n            <IND>blank_sdc = os.path.join(self.run_dir, \"blank.sdc\")\n            self.run_executable([\"touch\", blank_sdc])\n            sdc_files_arg = \"-sdc_files {{ {} }}\".format(blank_sdc)\n        <DED>append_mmmc(\"create_constraint_mode -name {name} {sdc_files_arg}\".format(\n            name=constraint_mode,\n            sdc_files_arg=sdc_files_arg\n        ))\n\n        corners = self.get_mmmc_corners()  # type: List[MMMCCorner]\n        # In parallel, create the delay corners\n        if corners:\n            <IND>setup_corner = corners[0]  # type: MMMCCorner\n            hold_corner = corners[0]  # type: MMMCCorner\n            # TODO(colins): handle more than one corner and do something with extra corners\n            for corner in corners:\n                <IND>if corner.type is MMMCCornerType.Setup:\n                    <IND>setup_corner = corner\n                <DED>if corner.type is MMMCCornerType.Hold:\n                    <IND>hold_corner = corner\n\n            # First, create Innovus library sets\n            <DED><DED>append_mmmc(\"create_library_set -name {name} -timing [list {list}]\".format(\n                name=\"{n}.setup_set\".format(n=setup_corner.name),\n                list=self.get_timing_libs(setup_corner)\n            ))\n            append_mmmc(\"create_library_set -name {name} -timing [list {list}]\".format(\n                name=\"{n}.hold_set\".format(n=hold_corner.name),\n                list=self.get_timing_libs(hold_corner)\n            ))\n            # Skip opconds for now\n            # Next, create Innovus timing conditions\n            append_mmmc(\"create_timing_condition -name {name} -library_sets [list {list}]\".format(\n                name=\"{n}.setup_cond\".format(n=setup_corner.name),\n                list=\"{n}.setup_set\".format(n=setup_corner.name)\n            ))\n            append_mmmc(\"create_timing_condition -name {name} -library_sets [list {list}]\".format(\n                name=\"{n}.hold_cond\".format(n=hold_corner.name),\n                list=\"{n}.hold_set\".format(n=hold_corner.name)\n            ))\n            # Next, create Innovus rc corners from qrc tech files\n            append_mmmc(\"create_rc_corner -name {name} -temperature {tempInCelsius} {qrc}\".format(\n                name=\"{n}.setup_rc\".format(n=setup_corner.name),\n                tempInCelsius=str(setup_corner.temp.value),\n                qrc=\"-qrc_tech {}\".format(self.get_mmmc_qrc(setup_corner)) if self.get_mmmc_qrc(setup_corner) != '' else ''\n            ))\n            append_mmmc(\"create_rc_corner -name {name} -temperature {tempInCelsius} {qrc}\".format(\n                name=\"{n}.hold_rc\".format(n=hold_corner.name),\n                tempInCelsius=str(hold_corner.temp.value),\n                qrc=\"-qrc_tech {}\".format(self.get_mmmc_qrc(hold_corner)) if self.get_mmmc_qrc(hold_corner) != '' else ''\n            ))\n            # Next, create an Innovus delay corner.\n            append_mmmc(\n                \"create_delay_corner -name {name}_delay -timing_condition {name}_cond -rc_corner {name}_rc\".format(\n                    name=\"{n}.setup\".format(n=setup_corner.name)\n                ))\n            append_mmmc(\n                \"create_delay_corner -name {name}_delay -timing_condition {name}_cond -rc_corner {name}_rc\".format(\n                    name=\"{n}.hold\".format(n=hold_corner.name)\n                ))\n            # Next, create the analysis views\n            append_mmmc(\"create_analysis_view -name {name}_view -delay_corner {name}_delay -constraint_mode {constraint}\".format(\n                name=\"{n}.setup\".format(n=setup_corner.name), constraint=constraint_mode))\n            append_mmmc(\"create_analysis_view -name {name}_view -delay_corner {name}_delay -constraint_mode {constraint}\".format(\n                name=\"{n}.hold\".format(n=hold_corner.name), constraint=constraint_mode))\n            # Finally, apply the analysis view.\n            append_mmmc(\"set_analysis_view -setup {{ {setup_view} }} -hold {{ {hold_view} }}\".format(\n                setup_view=\"{n}.setup_view\".format(n=setup_corner.name),\n                hold_view=\"{n}.hold_view\".format(n=hold_corner.name)\n            ))\n        <DED>else:\n            # First, create an Innovus library set.\n            <IND>library_set_name = \"my_lib_set\"\n            append_mmmc(\"create_library_set -name {name} -timing [list {list}]\".format(\n                name=library_set_name,\n                list=self.get_timing_libs()\n            ))\n            # Next, create an Innovus timing condition.\n            timing_condition_name = \"my_timing_condition\"\n            append_mmmc(\"create_timing_condition -name {name} -library_sets [list {list}]\".format(\n                name=timing_condition_name,\n                list=library_set_name\n            ))\n            # extra junk: -opcond ...\n            rc_corner_name = \"rc_cond\"\n            append_mmmc(\"create_rc_corner -name {name} -temperature {tempInCelsius} {qrc}\".format(\n                name=rc_corner_name,\n                tempInCelsius=120,  # TODO: this should come from tech config\n                qrc=\"-qrc_tech {}\".format(self.get_qrc_tech()) if self.get_qrc_tech() != '' else ''\n            ))\n            # Next, create an Innovus delay corner.\n            delay_corner_name = \"my_delay_corner\"\n            append_mmmc(\n                \"create_delay_corner -name {name} -timing_condition {timing_cond} -rc_corner {rc}\".format(\n                    name=delay_corner_name,\n                    timing_cond=timing_condition_name,\n                    rc=rc_corner_name\n                ))\n            # extra junk: -rc_corner my_rc_corner_maybe_worst\n            # Next, create an Innovus analysis view.\n            analysis_view_name = \"my_view\"\n            append_mmmc(\"create_analysis_view -name {name} -delay_corner {corner} -constraint_mode {constraint}\".format(\n                name=analysis_view_name, corner=delay_corner_name, constraint=constraint_mode))\n            # Finally, apply the analysis view.\n            # TODO: introduce different views of setup/hold and true multi-corner\n            append_mmmc(\"set_analysis_view -setup {{ {setup_view} }} -hold {{ {hold_view} }}\".format(\n                setup_view=analysis_view_name,\n                hold_view=analysis_view_name\n            ))\n\n        <DED>return \"\\n\".join(mmmc_output)\n\n    <DED>def generate_dont_use_commands(self) -> List[str]:\n        <IND>\"\"\"\n        Generate a list of dont_use commands for Cadence tools.\n        \"\"\"\n\n        def map_cell(in_cell: str) -> str:\n            # \"*/\" is needed for \"get_db lib_cells <cell_expression>\"\n            <IND>if in_cell.startswith(\"*/\"):\n                <IND>mapped_cell = in_cell  # type: str\n            <DED>else:\n                <IND>mapped_cell = \"*/\" + in_cell\n\n            # Check for cell existence first to avoid Genus erroring out.\n            <DED>get_db_str = \"[get_db lib_cells {mapped_cell}]\".format(mapped_cell=mapped_cell)\n            # Escaped version for puts.\n            get_db_str_escaped = get_db_str.replace('[', '\\[').replace(']', '\\]')\n            return \"\"\"\nputs \"set_dont_use {get_db_str_escaped}\"\nif {{ {get_db_str} ne \"\" }} {{\n    set_dont_use {get_db_str}\n}} else {{\n    puts \"WARNING: cell {mapped_cell} was not found for set_dont_use\"\n}}\n            \"\"\".format(get_db_str=get_db_str, get_db_str_escaped=get_db_str_escaped, mapped_cell=mapped_cell)\n\n        <DED>return list(map(map_cell, self.get_dont_use_list()))\n\n    <DED>def generate_power_spec_commands(self) -> List[str]:\n        <IND>\"\"\"\n        Generate commands to load a power specification for Cadence tools.\n        \"\"\"\n\n        power_spec_type = str(self.get_setting(\"vlsi.inputs.power_spec_type\"))  # type: str\n        power_spec_arg = \"\"  # type: str\n        if power_spec_type == \"cpf\":\n            <IND>power_spec_arg = \"cpf\"\n        <DED>elif power_spec_type == \"upf\":\n            <IND>power_spec_arg = \"1801\"\n        <DED>else:\n            <IND>self.logger.error(\n                \"Invalid power specification type '{tpe}'; only 'cpf' or 'upf' supported\".format(tpe=power_spec_type))\n            return []\n\n        <DED>power_spec_contents = \"\"  # type: str\n        power_spec_mode = str(self.get_setting(\"vlsi.inputs.power_spec_mode\"))  # type: str\n        if power_spec_mode == \"empty\":\n            <IND>return []\n        <DED>elif power_spec_mode == \"auto\":\n            <IND>if power_spec_type == \"cpf\":\n                <IND>power_spec_contents = self.cpf_power_specification\n            <DED>elif power_spec_type == \"upf\":\n                <IND>power_spec_contents = self.upf_power_specification\n        <DED><DED>elif power_spec_mode == \"manual\":\n            <IND>power_spec_contents = str(self.get_setting(\"vlsi.inputs.power_spec_contents\"))\n        <DED>else:\n            <IND>self.logger.error(\"Invalid power specification mode '{mode}'; using 'empty'.\".format(mode=power_spec_mode))\n            return []\n\n        # Write the power spec contents to file and include it\n        <DED>power_spec_file = os.path.join(self.run_dir, \"power_spec.{tpe}\".format(tpe=power_spec_type))\n        with open(power_spec_file, \"w\") as f:\n            <IND>f.write(power_spec_contents)\n        <DED>return [\"read_power_intent -{arg} {path}\".format(arg=power_spec_arg, path=power_spec_file),\n                \"commit_power_intent\"]\n\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "        <IND>self.tcl_append(cmd, self.output, clean)\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "ucb-bar/hammer",
    "commit": "3afca0f00301e87b3112d42284a6acfd3c083c42",
    "filename": "src/hammer-vlsi/hammer_vlsi/hammer_vlsi_impl.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/ucb-bar-hammer/src/hammer-vlsi/hammer_vlsi/hammer_vlsi_impl.py",
    "file_hunks_size": 13,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": true,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "src/hammer-vlsi/hammer_vlsi/hammer_vlsi_impl.py:1626:51 Invalid type [31]: Expression `src.hammer.__sub__(vlsi.hammer_vlsi.constraints.List[src.hammer.__sub__(vlsi.hammer_vlsi.constraints.MMMCCorner)])` is not a valid type.",
    "message": " Expression `src.hammer.__sub__(vlsi.hammer_vlsi.constraints.List[src.hammer.__sub__(vlsi.hammer_vlsi.constraints.MMMCCorner)])` is not a valid type.",
    "rule_id": "Invalid type [31]",
    "warning_line_no": 1626,
    "warning_line": "        corners = self.get_mmmc_corners()  # type: List[MMMCCorner]",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": true,
        "has_suppression": false,
        "source_code": "        self.tcl_append(cmd, self.output, clean)\n\n\nclass CadenceTool(HasSDCSupport, HasCPFSupport, HasUPFSupport, TCLTool, HammerTool):\n    \"\"\"Mix-in trait with functions useful for Cadence-based tools.\"\"\"\n\n    @property\n    def config_dirs(self) -> List[str]:\n        # Override this to pull in Cadence-common configs.\n        return [self.get_setting(\"cadence.common_path\")] + super().config_dirs\n\n    @property\n    def env_vars(self) -> Dict[str, str]:\n        \"\"\"\n        Get the list of environment variables required for this tool.\n        Note to subclasses: remember to include variables from super().env_vars!\n        \"\"\"\n        # Use the base extra_env_variables and ensure that our custom variables are on top.\n        list_of_vars = self.get_setting(\"cadence.extra_env_vars\")  # type: List[Dict[str, Any]]\n        assert isinstance(list_of_vars, list)\n\n        cadence_vars = {\n            \"CDS_LIC_FILE\": self.get_setting(\"cadence.CDS_LIC_FILE\"),\n            \"CADENCE_HOME\": self.get_setting(\"cadence.cadence_home\")\n        }\n\n        return reduce(add_dicts, [dict(super().env_vars)] + list_of_vars + [cadence_vars], {})\n\n    def version_number(self, version: str) -> int:\n        \"\"\"\n        Assumes versions look like MAJOR_ISRMINOR and we will have less than 100 minor versions.\n        \"\"\"\n        main_version = int(version.split(\"_\")[0]) # type: int\n        minor_version = 0 # type: int\n        if \"_\" in version:\n            minor_version = int(version.split(\"_\")[1][3:])\n        return main_version * 100 + minor_version\n\n    def get_timing_libs(self, corner: Optional[MMMCCorner] = None) -> str:\n        \"\"\"\n        Helper function to get the list of ASCII timing .lib files in space separated format.\n        Note that Cadence tools support ECSM, so we can use the ECSM-based filter.\n\n        :param corner: Optional corner to consider. If supplied, this will use filter_for_mmmc to select libraries that\n        match a given corner (voltage/temperature).\n        :return: List of lib files separated by spaces\n        \"\"\"\n        pre_filters = optional_map(corner, lambda c: [self.filter_for_mmmc(voltage=c.voltage,\n                                                                           temp=c.temp)])  # type: Optional[List[Callable[[hammer_tech.Library],bool]]]\n\n        lib_args = self.technology.read_libs([hammer_tech.filters.timing_lib_with_ecsm_filter],\n                                             hammer_tech.HammerTechnologyUtils.to_plain_item,\n                                             extra_pre_filters=pre_filters)\n        return \" \".join(lib_args)\n\n    def get_mmmc_qrc(self, corner: MMMCCorner) -> str:\n        lib_args = self.technology.read_libs([hammer_tech.filters.qrc_tech_filter],\n                                             hammer_tech.HammerTechnologyUtils.to_plain_item,\n                                             extra_pre_filters=[\n                                                 self.filter_for_mmmc(voltage=corner.voltage, temp=corner.temp)])\n        return \" \".join(lib_args)\n\n    def get_qrc_tech(self) -> str:\n        \"\"\"\n        Helper function to get the list of rc corner tech files in space separated format.\n\n        :return: List of qrc tech files separated by spaces\n        \"\"\"\n        lib_args = self.technology.read_libs([\n            hammer_tech.filters.qrc_tech_filter\n        ], hammer_tech.HammerTechnologyUtils.to_plain_item)\n        return \" \".join(lib_args)\n\n    def generate_mmmc_script(self) -> str:\n        \"\"\"\n        Output for the mmmc.tcl script.\n        Innovus (init_design) requires that the timing script be placed in a separate file.\n\n        :return: Contents of the mmmc script.\n        \"\"\"\n        mmmc_output = []  # type: List[str]\n\n        def append_mmmc(cmd: str) -> None:\n            self.verbose_tcl_append(cmd, mmmc_output)\n\n        # Create an Innovus constraint mode.\n        constraint_mode = \"my_constraint_mode\"\n        sdc_files = []  # type: List[str]\n\n        # Generate constraints\n        clock_constraints_fragment = os.path.join(self.run_dir, \"clock_constraints_fragment.sdc\")\n        with open(clock_constraints_fragment, \"w\") as f:\n            f.write(self.sdc_clock_constraints)\n        sdc_files.append(clock_constraints_fragment)\n\n        # Generate port constraints.\n        pin_constraints_fragment = os.path.join(self.run_dir, \"pin_constraints_fragment.sdc\")\n        with open(pin_constraints_fragment, \"w\") as f:\n            f.write(self.sdc_pin_constraints)\n        sdc_files.append(pin_constraints_fragment)\n\n        # Add the post-synthesis SDC, if present.\n        post_synth_sdc = self.post_synth_sdc\n        if post_synth_sdc is not None:\n            sdc_files.append(post_synth_sdc)\n\n        # TODO: add floorplanning SDC\n        if len(sdc_files) > 0:\n            sdc_files_arg = \"-sdc_files [list {sdc_files}]\".format(\n                sdc_files=\" \".join(sdc_files)\n            )\n        else:\n            blank_sdc = os.path.join(self.run_dir, \"blank.sdc\")\n            self.run_executable([\"touch\", blank_sdc])\n            sdc_files_arg = \"-sdc_files {{ {} }}\".format(blank_sdc)\n        append_mmmc(\"create_constraint_mode -name {name} {sdc_files_arg}\".format(\n            name=constraint_mode,\n            sdc_files_arg=sdc_files_arg\n        ))\n\n        corners = self.get_mmmc_corners()  # type: List[MMMCCorner]\n        # In parallel, create the delay corners\n        if corners:\n            setup_corner = corners[0]  # type: MMMCCorner\n            hold_corner = corners[0]  # type: MMMCCorner\n            # TODO(colins): handle more than one corner and do something with extra corners\n            for corner in corners:\n                if corner.type is MMMCCornerType.Setup:\n                    setup_corner = corner\n                if corner.type is MMMCCornerType.Hold:\n                    hold_corner = corner\n\n            # First, create Innovus library sets\n            append_mmmc(\"create_library_set -name {name} -timing [list {list}]\".format(\n                name=\"{n}.setup_set\".format(n=setup_corner.name),\n                list=self.get_timing_libs(setup_corner)\n            ))\n            append_mmmc(\"create_library_set -name {name} -timing [list {list}]\".format(\n                name=\"{n}.hold_set\".format(n=hold_corner.name),\n                list=self.get_timing_libs(hold_corner)\n            ))\n            # Skip opconds for now\n            # Next, create Innovus timing conditions\n            append_mmmc(\"create_timing_condition -name {name} -library_sets [list {list}]\".format(\n                name=\"{n}.setup_cond\".format(n=setup_corner.name),\n                list=\"{n}.setup_set\".format(n=setup_corner.name)\n            ))\n            append_mmmc(\"create_timing_condition -name {name} -library_sets [list {list}]\".format(\n                name=\"{n}.hold_cond\".format(n=hold_corner.name),\n                list=\"{n}.hold_set\".format(n=hold_corner.name)\n            ))\n            # Next, create Innovus rc corners from qrc tech files\n            append_mmmc(\"create_rc_corner -name {name} -temperature {tempInCelsius} {qrc}\".format(\n                name=\"{n}.setup_rc\".format(n=setup_corner.name),\n                tempInCelsius=str(setup_corner.temp.value),\n                qrc=\"-qrc_tech {}\".format(self.get_mmmc_qrc(setup_corner)) if self.get_mmmc_qrc(setup_corner) != '' else ''\n            ))\n            append_mmmc(\"create_rc_corner -name {name} -temperature {tempInCelsius} {qrc}\".format(\n                name=\"{n}.hold_rc\".format(n=hold_corner.name),\n                tempInCelsius=str(hold_corner.temp.value),\n                qrc=\"-qrc_tech {}\".format(self.get_mmmc_qrc(hold_corner)) if self.get_mmmc_qrc(hold_corner) != '' else ''\n            ))\n            # Next, create an Innovus delay corner.\n            append_mmmc(\n                \"create_delay_corner -name {name}_delay -timing_condition {name}_cond -rc_corner {name}_rc\".format(\n                    name=\"{n}.setup\".format(n=setup_corner.name)\n                ))\n            append_mmmc(\n                \"create_delay_corner -name {name}_delay -timing_condition {name}_cond -rc_corner {name}_rc\".format(\n                    name=\"{n}.hold\".format(n=hold_corner.name)\n                ))\n            # Next, create the analysis views\n            append_mmmc(\"create_analysis_view -name {name}_view -delay_corner {name}_delay -constraint_mode {constraint}\".format(\n                name=\"{n}.setup\".format(n=setup_corner.name), constraint=constraint_mode))\n            append_mmmc(\"create_analysis_view -name {name}_view -delay_corner {name}_delay -constraint_mode {constraint}\".format(\n                name=\"{n}.hold\".format(n=hold_corner.name), constraint=constraint_mode))\n            # Finally, apply the analysis view.\n            append_mmmc(\"set_analysis_view -setup {{ {setup_view} }} -hold {{ {hold_view} }}\".format(\n                setup_view=\"{n}.setup_view\".format(n=setup_corner.name),\n                hold_view=\"{n}.hold_view\".format(n=hold_corner.name)\n            ))\n        else:\n            # First, create an Innovus library set.\n            library_set_name = \"my_lib_set\"\n            append_mmmc(\"create_library_set -name {name} -timing [list {list}]\".format(\n                name=library_set_name,\n                list=self.get_timing_libs()\n            ))\n            # Next, create an Innovus timing condition.\n            timing_condition_name = \"my_timing_condition\"\n            append_mmmc(\"create_timing_condition -name {name} -library_sets [list {list}]\".format(\n                name=timing_condition_name,\n                list=library_set_name\n            ))\n            # extra junk: -opcond ...\n            rc_corner_name = \"rc_cond\"\n            append_mmmc(\"create_rc_corner -name {name} -temperature {tempInCelsius} {qrc}\".format(\n                name=rc_corner_name,\n                tempInCelsius=120,  # TODO: this should come from tech config\n                qrc=\"-qrc_tech {}\".format(self.get_qrc_tech()) if self.get_qrc_tech() != '' else ''\n            ))\n            # Next, create an Innovus delay corner.\n            delay_corner_name = \"my_delay_corner\"\n            append_mmmc(\n                \"create_delay_corner -name {name} -timing_condition {timing_cond} -rc_corner {rc}\".format(\n                    name=delay_corner_name,\n                    timing_cond=timing_condition_name,\n                    rc=rc_corner_name\n                ))\n            # extra junk: -rc_corner my_rc_corner_maybe_worst\n            # Next, create an Innovus analysis view.\n            analysis_view_name = \"my_view\"\n            append_mmmc(\"create_analysis_view -name {name} -delay_corner {corner} -constraint_mode {constraint}\".format(\n                name=analysis_view_name, corner=delay_corner_name, constraint=constraint_mode))\n            # Finally, apply the analysis view.\n            # TODO: introduce different views of setup/hold and true multi-corner\n            append_mmmc(\"set_analysis_view -setup {{ {setup_view} }} -hold {{ {hold_view} }}\".format(\n                setup_view=analysis_view_name,\n                hold_view=analysis_view_name\n            ))\n\n        return \"\\n\".join(mmmc_output)\n\n    def generate_dont_use_commands(self) -> List[str]:\n        \"\"\"\n        Generate a list of dont_use commands for Cadence tools.\n        \"\"\"\n\n        def map_cell(in_cell: str) -> str:\n            # \"*/\" is needed for \"get_db lib_cells <cell_expression>\"\n            if in_cell.startswith(\"*/\"):\n                mapped_cell = in_cell  # type: str\n            else:\n                mapped_cell = \"*/\" + in_cell\n\n            # Check for cell existence first to avoid Genus erroring out.\n            get_db_str = \"[get_db lib_cells {mapped_cell}]\".format(mapped_cell=mapped_cell)\n            # Escaped version for puts.\n            get_db_str_escaped = get_db_str.replace('[', '\\[').replace(']', '\\]')\n            return \"\"\"\nputs \"set_dont_use {get_db_str_escaped}\"\nif {{ {get_db_str} ne \"\" }} {{\n    set_dont_use {get_db_str}\n}} else {{\n    puts \"WARNING: cell {mapped_cell} was not found for set_dont_use\"\n}}\n            \"\"\".format(get_db_str=get_db_str, get_db_str_escaped=get_db_str_escaped, mapped_cell=mapped_cell)\n\n        return list(map(map_cell, self.get_dont_use_list()))\n\n    def generate_power_spec_commands(self) -> List[str]:\n        \"\"\"\n        Generate commands to load a power specification for Cadence tools.\n        \"\"\"\n\n        power_spec_type = str(self.get_setting(\"vlsi.inputs.power_spec_type\"))  # type: str\n        power_spec_arg = \"\"  # type: str\n        if power_spec_type == \"cpf\":\n            power_spec_arg = \"cpf\"\n        elif power_spec_type == \"upf\":\n            power_spec_arg = \"1801\"\n        else:\n            self.logger.error(\n                \"Invalid power specification type '{tpe}'; only 'cpf' or 'upf' supported\".format(tpe=power_spec_type))\n            return []\n\n        power_spec_contents = \"\"  # type: str\n        power_spec_mode = str(self.get_setting(\"vlsi.inputs.power_spec_mode\"))  # type: str\n        if power_spec_mode == \"empty\":\n            return []\n        elif power_spec_mode == \"auto\":\n            if power_spec_type == \"cpf\":\n                power_spec_contents = self.cpf_power_specification\n            elif power_spec_type == \"upf\":\n                power_spec_contents = self.upf_power_specification\n        elif power_spec_mode == \"manual\":\n            power_spec_contents = str(self.get_setting(\"vlsi.inputs.power_spec_contents\"))\n        else:\n            self.logger.error(\"Invalid power specification mode '{mode}'; using 'empty'.\".format(mode=power_spec_mode))\n            return []\n\n        # Write the power spec contents to file and include it\n        power_spec_file = os.path.join(self.run_dir, \"power_spec.{tpe}\".format(tpe=power_spec_type))\n        with open(power_spec_file, \"w\") as f:\n            f.write(power_spec_contents)\n        return [\"read_power_intent -{arg} {path}\".format(arg=power_spec_arg, path=power_spec_file),\n                \"commit_power_intent\"]\n\n\n",
        "source_code_len": 14014,
        "target_code": "        self.tcl_append(cmd, self.output, clean)\n\n",
        "target_code_len": 50,
        "diff_format": "@@ -1506,289 +1506,2 @@\n         self.tcl_append(cmd, self.output, clean)\n-\n-\n-class CadenceTool(HasSDCSupport, HasCPFSupport, HasUPFSupport, TCLTool, HammerTool):\n-    \"\"\"Mix-in trait with functions useful for Cadence-based tools.\"\"\"\n-\n-    @property\n-    def config_dirs(self) -> List[str]:\n-        # Override this to pull in Cadence-common configs.\n-        return [self.get_setting(\"cadence.common_path\")] + super().config_dirs\n-\n-    @property\n-    def env_vars(self) -> Dict[str, str]:\n-        \"\"\"\n-        Get the list of environment variables required for this tool.\n-        Note to subclasses: remember to include variables from super().env_vars!\n-        \"\"\"\n-        # Use the base extra_env_variables and ensure that our custom variables are on top.\n-        list_of_vars = self.get_setting(\"cadence.extra_env_vars\")  # type: List[Dict[str, Any]]\n-        assert isinstance(list_of_vars, list)\n-\n-        cadence_vars = {\n-            \"CDS_LIC_FILE\": self.get_setting(\"cadence.CDS_LIC_FILE\"),\n-            \"CADENCE_HOME\": self.get_setting(\"cadence.cadence_home\")\n-        }\n-\n-        return reduce(add_dicts, [dict(super().env_vars)] + list_of_vars + [cadence_vars], {})\n-\n-    def version_number(self, version: str) -> int:\n-        \"\"\"\n-        Assumes versions look like MAJOR_ISRMINOR and we will have less than 100 minor versions.\n-        \"\"\"\n-        main_version = int(version.split(\"_\")[0]) # type: int\n-        minor_version = 0 # type: int\n-        if \"_\" in version:\n-            minor_version = int(version.split(\"_\")[1][3:])\n-        return main_version * 100 + minor_version\n-\n-    def get_timing_libs(self, corner: Optional[MMMCCorner] = None) -> str:\n-        \"\"\"\n-        Helper function to get the list of ASCII timing .lib files in space separated format.\n-        Note that Cadence tools support ECSM, so we can use the ECSM-based filter.\n-\n-        :param corner: Optional corner to consider. If supplied, this will use filter_for_mmmc to select libraries that\n-        match a given corner (voltage/temperature).\n-        :return: List of lib files separated by spaces\n-        \"\"\"\n-        pre_filters = optional_map(corner, lambda c: [self.filter_for_mmmc(voltage=c.voltage,\n-                                                                           temp=c.temp)])  # type: Optional[List[Callable[[hammer_tech.Library],bool]]]\n-\n-        lib_args = self.technology.read_libs([hammer_tech.filters.timing_lib_with_ecsm_filter],\n-                                             hammer_tech.HammerTechnologyUtils.to_plain_item,\n-                                             extra_pre_filters=pre_filters)\n-        return \" \".join(lib_args)\n-\n-    def get_mmmc_qrc(self, corner: MMMCCorner) -> str:\n-        lib_args = self.technology.read_libs([hammer_tech.filters.qrc_tech_filter],\n-                                             hammer_tech.HammerTechnologyUtils.to_plain_item,\n-                                             extra_pre_filters=[\n-                                                 self.filter_for_mmmc(voltage=corner.voltage, temp=corner.temp)])\n-        return \" \".join(lib_args)\n-\n-    def get_qrc_tech(self) -> str:\n-        \"\"\"\n-        Helper function to get the list of rc corner tech files in space separated format.\n-\n-        :return: List of qrc tech files separated by spaces\n-        \"\"\"\n-        lib_args = self.technology.read_libs([\n-            hammer_tech.filters.qrc_tech_filter\n-        ], hammer_tech.HammerTechnologyUtils.to_plain_item)\n-        return \" \".join(lib_args)\n-\n-    def generate_mmmc_script(self) -> str:\n-        \"\"\"\n-        Output for the mmmc.tcl script.\n-        Innovus (init_design) requires that the timing script be placed in a separate file.\n-\n-        :return: Contents of the mmmc script.\n-        \"\"\"\n-        mmmc_output = []  # type: List[str]\n-\n-        def append_mmmc(cmd: str) -> None:\n-            self.verbose_tcl_append(cmd, mmmc_output)\n-\n-        # Create an Innovus constraint mode.\n-        constraint_mode = \"my_constraint_mode\"\n-        sdc_files = []  # type: List[str]\n-\n-        # Generate constraints\n-        clock_constraints_fragment = os.path.join(self.run_dir, \"clock_constraints_fragment.sdc\")\n-        with open(clock_constraints_fragment, \"w\") as f:\n-            f.write(self.sdc_clock_constraints)\n-        sdc_files.append(clock_constraints_fragment)\n-\n-        # Generate port constraints.\n-        pin_constraints_fragment = os.path.join(self.run_dir, \"pin_constraints_fragment.sdc\")\n-        with open(pin_constraints_fragment, \"w\") as f:\n-            f.write(self.sdc_pin_constraints)\n-        sdc_files.append(pin_constraints_fragment)\n-\n-        # Add the post-synthesis SDC, if present.\n-        post_synth_sdc = self.post_synth_sdc\n-        if post_synth_sdc is not None:\n-            sdc_files.append(post_synth_sdc)\n-\n-        # TODO: add floorplanning SDC\n-        if len(sdc_files) > 0:\n-            sdc_files_arg = \"-sdc_files [list {sdc_files}]\".format(\n-                sdc_files=\" \".join(sdc_files)\n-            )\n-        else:\n-            blank_sdc = os.path.join(self.run_dir, \"blank.sdc\")\n-            self.run_executable([\"touch\", blank_sdc])\n-            sdc_files_arg = \"-sdc_files {{ {} }}\".format(blank_sdc)\n-        append_mmmc(\"create_constraint_mode -name {name} {sdc_files_arg}\".format(\n-            name=constraint_mode,\n-            sdc_files_arg=sdc_files_arg\n-        ))\n-\n-        corners = self.get_mmmc_corners()  # type: List[MMMCCorner]\n-        # In parallel, create the delay corners\n-        if corners:\n-            setup_corner = corners[0]  # type: MMMCCorner\n-            hold_corner = corners[0]  # type: MMMCCorner\n-            # TODO(colins): handle more than one corner and do something with extra corners\n-            for corner in corners:\n-                if corner.type is MMMCCornerType.Setup:\n-                    setup_corner = corner\n-                if corner.type is MMMCCornerType.Hold:\n-                    hold_corner = corner\n-\n-            # First, create Innovus library sets\n-            append_mmmc(\"create_library_set -name {name} -timing [list {list}]\".format(\n-                name=\"{n}.setup_set\".format(n=setup_corner.name),\n-                list=self.get_timing_libs(setup_corner)\n-            ))\n-            append_mmmc(\"create_library_set -name {name} -timing [list {list}]\".format(\n-                name=\"{n}.hold_set\".format(n=hold_corner.name),\n-                list=self.get_timing_libs(hold_corner)\n-            ))\n-            # Skip opconds for now\n-            # Next, create Innovus timing conditions\n-            append_mmmc(\"create_timing_condition -name {name} -library_sets [list {list}]\".format(\n-                name=\"{n}.setup_cond\".format(n=setup_corner.name),\n-                list=\"{n}.setup_set\".format(n=setup_corner.name)\n-            ))\n-            append_mmmc(\"create_timing_condition -name {name} -library_sets [list {list}]\".format(\n-                name=\"{n}.hold_cond\".format(n=hold_corner.name),\n-                list=\"{n}.hold_set\".format(n=hold_corner.name)\n-            ))\n-            # Next, create Innovus rc corners from qrc tech files\n-            append_mmmc(\"create_rc_corner -name {name} -temperature {tempInCelsius} {qrc}\".format(\n-                name=\"{n}.setup_rc\".format(n=setup_corner.name),\n-                tempInCelsius=str(setup_corner.temp.value),\n-                qrc=\"-qrc_tech {}\".format(self.get_mmmc_qrc(setup_corner)) if self.get_mmmc_qrc(setup_corner) != '' else ''\n-            ))\n-            append_mmmc(\"create_rc_corner -name {name} -temperature {tempInCelsius} {qrc}\".format(\n-                name=\"{n}.hold_rc\".format(n=hold_corner.name),\n-                tempInCelsius=str(hold_corner.temp.value),\n-                qrc=\"-qrc_tech {}\".format(self.get_mmmc_qrc(hold_corner)) if self.get_mmmc_qrc(hold_corner) != '' else ''\n-            ))\n-            # Next, create an Innovus delay corner.\n-            append_mmmc(\n-                \"create_delay_corner -name {name}_delay -timing_condition {name}_cond -rc_corner {name}_rc\".format(\n-                    name=\"{n}.setup\".format(n=setup_corner.name)\n-                ))\n-            append_mmmc(\n-                \"create_delay_corner -name {name}_delay -timing_condition {name}_cond -rc_corner {name}_rc\".format(\n-                    name=\"{n}.hold\".format(n=hold_corner.name)\n-                ))\n-            # Next, create the analysis views\n-            append_mmmc(\"create_analysis_view -name {name}_view -delay_corner {name}_delay -constraint_mode {constraint}\".format(\n-                name=\"{n}.setup\".format(n=setup_corner.name), constraint=constraint_mode))\n-            append_mmmc(\"create_analysis_view -name {name}_view -delay_corner {name}_delay -constraint_mode {constraint}\".format(\n-                name=\"{n}.hold\".format(n=hold_corner.name), constraint=constraint_mode))\n-            # Finally, apply the analysis view.\n-            append_mmmc(\"set_analysis_view -setup {{ {setup_view} }} -hold {{ {hold_view} }}\".format(\n-                setup_view=\"{n}.setup_view\".format(n=setup_corner.name),\n-                hold_view=\"{n}.hold_view\".format(n=hold_corner.name)\n-            ))\n-        else:\n-            # First, create an Innovus library set.\n-            library_set_name = \"my_lib_set\"\n-            append_mmmc(\"create_library_set -name {name} -timing [list {list}]\".format(\n-                name=library_set_name,\n-                list=self.get_timing_libs()\n-            ))\n-            # Next, create an Innovus timing condition.\n-            timing_condition_name = \"my_timing_condition\"\n-            append_mmmc(\"create_timing_condition -name {name} -library_sets [list {list}]\".format(\n-                name=timing_condition_name,\n-                list=library_set_name\n-            ))\n-            # extra junk: -opcond ...\n-            rc_corner_name = \"rc_cond\"\n-            append_mmmc(\"create_rc_corner -name {name} -temperature {tempInCelsius} {qrc}\".format(\n-                name=rc_corner_name,\n-                tempInCelsius=120,  # TODO: this should come from tech config\n-                qrc=\"-qrc_tech {}\".format(self.get_qrc_tech()) if self.get_qrc_tech() != '' else ''\n-            ))\n-            # Next, create an Innovus delay corner.\n-            delay_corner_name = \"my_delay_corner\"\n-            append_mmmc(\n-                \"create_delay_corner -name {name} -timing_condition {timing_cond} -rc_corner {rc}\".format(\n-                    name=delay_corner_name,\n-                    timing_cond=timing_condition_name,\n-                    rc=rc_corner_name\n-                ))\n-            # extra junk: -rc_corner my_rc_corner_maybe_worst\n-            # Next, create an Innovus analysis view.\n-            analysis_view_name = \"my_view\"\n-            append_mmmc(\"create_analysis_view -name {name} -delay_corner {corner} -constraint_mode {constraint}\".format(\n-                name=analysis_view_name, corner=delay_corner_name, constraint=constraint_mode))\n-            # Finally, apply the analysis view.\n-            # TODO: introduce different views of setup/hold and true multi-corner\n-            append_mmmc(\"set_analysis_view -setup {{ {setup_view} }} -hold {{ {hold_view} }}\".format(\n-                setup_view=analysis_view_name,\n-                hold_view=analysis_view_name\n-            ))\n-\n-        return \"\\n\".join(mmmc_output)\n-\n-    def generate_dont_use_commands(self) -> List[str]:\n-        \"\"\"\n-        Generate a list of dont_use commands for Cadence tools.\n-        \"\"\"\n-\n-        def map_cell(in_cell: str) -> str:\n-            # \"*/\" is needed for \"get_db lib_cells <cell_expression>\"\n-            if in_cell.startswith(\"*/\"):\n-                mapped_cell = in_cell  # type: str\n-            else:\n-                mapped_cell = \"*/\" + in_cell\n-\n-            # Check for cell existence first to avoid Genus erroring out.\n-            get_db_str = \"[get_db lib_cells {mapped_cell}]\".format(mapped_cell=mapped_cell)\n-            # Escaped version for puts.\n-            get_db_str_escaped = get_db_str.replace('[', '\\[').replace(']', '\\]')\n-            return \"\"\"\n-puts \"set_dont_use {get_db_str_escaped}\"\n-if {{ {get_db_str} ne \"\" }} {{\n-    set_dont_use {get_db_str}\n-}} else {{\n-    puts \"WARNING: cell {mapped_cell} was not found for set_dont_use\"\n-}}\n-            \"\"\".format(get_db_str=get_db_str, get_db_str_escaped=get_db_str_escaped, mapped_cell=mapped_cell)\n-\n-        return list(map(map_cell, self.get_dont_use_list()))\n-\n-    def generate_power_spec_commands(self) -> List[str]:\n-        \"\"\"\n-        Generate commands to load a power specification for Cadence tools.\n-        \"\"\"\n-\n-        power_spec_type = str(self.get_setting(\"vlsi.inputs.power_spec_type\"))  # type: str\n-        power_spec_arg = \"\"  # type: str\n-        if power_spec_type == \"cpf\":\n-            power_spec_arg = \"cpf\"\n-        elif power_spec_type == \"upf\":\n-            power_spec_arg = \"1801\"\n-        else:\n-            self.logger.error(\n-                \"Invalid power specification type '{tpe}'; only 'cpf' or 'upf' supported\".format(tpe=power_spec_type))\n-            return []\n-\n-        power_spec_contents = \"\"  # type: str\n-        power_spec_mode = str(self.get_setting(\"vlsi.inputs.power_spec_mode\"))  # type: str\n-        if power_spec_mode == \"empty\":\n-            return []\n-        elif power_spec_mode == \"auto\":\n-            if power_spec_type == \"cpf\":\n-                power_spec_contents = self.cpf_power_specification\n-            elif power_spec_type == \"upf\":\n-                power_spec_contents = self.upf_power_specification\n-        elif power_spec_mode == \"manual\":\n-            power_spec_contents = str(self.get_setting(\"vlsi.inputs.power_spec_contents\"))\n-        else:\n-            self.logger.error(\"Invalid power specification mode '{mode}'; using 'empty'.\".format(mode=power_spec_mode))\n-            return []\n-\n-        # Write the power spec contents to file and include it\n-        power_spec_file = os.path.join(self.run_dir, \"power_spec.{tpe}\".format(tpe=power_spec_type))\n-        with open(power_spec_file, \"w\") as f:\n-            f.write(power_spec_contents)\n-        return [\"read_power_intent -{arg} {path}\".format(arg=power_spec_arg, path=power_spec_file),\n-                \"commit_power_intent\"]\n-\n \n",
        "source_code_with_indent": "        <IND>self.tcl_append(cmd, self.output, clean)\n\n\n<DED><DED>class CadenceTool(HasSDCSupport, HasCPFSupport, HasUPFSupport, TCLTool, HammerTool):\n    <IND>\"\"\"Mix-in trait with functions useful for Cadence-based tools.\"\"\"\n\n    @property\n    def config_dirs(self) -> List[str]:\n        # Override this to pull in Cadence-common configs.\n        <IND>return [self.get_setting(\"cadence.common_path\")] + super().config_dirs\n\n    <DED>@property\n    def env_vars(self) -> Dict[str, str]:\n        <IND>\"\"\"\n        Get the list of environment variables required for this tool.\n        Note to subclasses: remember to include variables from super().env_vars!\n        \"\"\"\n        # Use the base extra_env_variables and ensure that our custom variables are on top.\n        list_of_vars = self.get_setting(\"cadence.extra_env_vars\")  # type: List[Dict[str, Any]]\n        assert isinstance(list_of_vars, list)\n\n        cadence_vars = {\n            \"CDS_LIC_FILE\": self.get_setting(\"cadence.CDS_LIC_FILE\"),\n            \"CADENCE_HOME\": self.get_setting(\"cadence.cadence_home\")\n        }\n\n        return reduce(add_dicts, [dict(super().env_vars)] + list_of_vars + [cadence_vars], {})\n\n    <DED>def version_number(self, version: str) -> int:\n        <IND>\"\"\"\n        Assumes versions look like MAJOR_ISRMINOR and we will have less than 100 minor versions.\n        \"\"\"\n        main_version = int(version.split(\"_\")[0]) # type: int\n        minor_version = 0 # type: int\n        if \"_\" in version:\n            <IND>minor_version = int(version.split(\"_\")[1][3:])\n        <DED>return main_version * 100 + minor_version\n\n    <DED>def get_timing_libs(self, corner: Optional[MMMCCorner] = None) -> str:\n        <IND>\"\"\"\n        Helper function to get the list of ASCII timing .lib files in space separated format.\n        Note that Cadence tools support ECSM, so we can use the ECSM-based filter.\n\n        :param corner: Optional corner to consider. If supplied, this will use filter_for_mmmc to select libraries that\n        match a given corner (voltage/temperature).\n        :return: List of lib files separated by spaces\n        \"\"\"\n        pre_filters = optional_map(corner, lambda c: [self.filter_for_mmmc(voltage=c.voltage,\n                                                                           temp=c.temp)])  # type: Optional[List[Callable[[hammer_tech.Library],bool]]]\n\n        lib_args = self.technology.read_libs([hammer_tech.filters.timing_lib_with_ecsm_filter],\n                                             hammer_tech.HammerTechnologyUtils.to_plain_item,\n                                             extra_pre_filters=pre_filters)\n        return \" \".join(lib_args)\n\n    <DED>def get_mmmc_qrc(self, corner: MMMCCorner) -> str:\n        <IND>lib_args = self.technology.read_libs([hammer_tech.filters.qrc_tech_filter],\n                                             hammer_tech.HammerTechnologyUtils.to_plain_item,\n                                             extra_pre_filters=[\n                                                 self.filter_for_mmmc(voltage=corner.voltage, temp=corner.temp)])\n        return \" \".join(lib_args)\n\n    <DED>def get_qrc_tech(self) -> str:\n        <IND>\"\"\"\n        Helper function to get the list of rc corner tech files in space separated format.\n\n        :return: List of qrc tech files separated by spaces\n        \"\"\"\n        lib_args = self.technology.read_libs([\n            hammer_tech.filters.qrc_tech_filter\n        ], hammer_tech.HammerTechnologyUtils.to_plain_item)\n        return \" \".join(lib_args)\n\n    <DED>def generate_mmmc_script(self) -> str:\n        <IND>\"\"\"\n        Output for the mmmc.tcl script.\n        Innovus (init_design) requires that the timing script be placed in a separate file.\n\n        :return: Contents of the mmmc script.\n        \"\"\"\n        mmmc_output = []  # type: List[str]\n\n        def append_mmmc(cmd: str) -> None:\n            <IND>self.verbose_tcl_append(cmd, mmmc_output)\n\n        # Create an Innovus constraint mode.\n        <DED>constraint_mode = \"my_constraint_mode\"\n        sdc_files = []  # type: List[str]\n\n        # Generate constraints\n        clock_constraints_fragment = os.path.join(self.run_dir, \"clock_constraints_fragment.sdc\")\n        with open(clock_constraints_fragment, \"w\") as f:\n            <IND>f.write(self.sdc_clock_constraints)\n        <DED>sdc_files.append(clock_constraints_fragment)\n\n        # Generate port constraints.\n        pin_constraints_fragment = os.path.join(self.run_dir, \"pin_constraints_fragment.sdc\")\n        with open(pin_constraints_fragment, \"w\") as f:\n            <IND>f.write(self.sdc_pin_constraints)\n        <DED>sdc_files.append(pin_constraints_fragment)\n\n        # Add the post-synthesis SDC, if present.\n        post_synth_sdc = self.post_synth_sdc\n        if post_synth_sdc is not None:\n            <IND>sdc_files.append(post_synth_sdc)\n\n        # TODO: add floorplanning SDC\n        <DED>if len(sdc_files) > 0:\n            <IND>sdc_files_arg = \"-sdc_files [list {sdc_files}]\".format(\n                sdc_files=\" \".join(sdc_files)\n            )\n        <DED>else:\n            <IND>blank_sdc = os.path.join(self.run_dir, \"blank.sdc\")\n            self.run_executable([\"touch\", blank_sdc])\n            sdc_files_arg = \"-sdc_files {{ {} }}\".format(blank_sdc)\n        <DED>append_mmmc(\"create_constraint_mode -name {name} {sdc_files_arg}\".format(\n            name=constraint_mode,\n            sdc_files_arg=sdc_files_arg\n        ))\n\n        corners = self.get_mmmc_corners()  # type: List[MMMCCorner]\n        # In parallel, create the delay corners\n        if corners:\n            <IND>setup_corner = corners[0]  # type: MMMCCorner\n            hold_corner = corners[0]  # type: MMMCCorner\n            # TODO(colins): handle more than one corner and do something with extra corners\n            for corner in corners:\n                <IND>if corner.type is MMMCCornerType.Setup:\n                    <IND>setup_corner = corner\n                <DED>if corner.type is MMMCCornerType.Hold:\n                    <IND>hold_corner = corner\n\n            # First, create Innovus library sets\n            <DED><DED>append_mmmc(\"create_library_set -name {name} -timing [list {list}]\".format(\n                name=\"{n}.setup_set\".format(n=setup_corner.name),\n                list=self.get_timing_libs(setup_corner)\n            ))\n            append_mmmc(\"create_library_set -name {name} -timing [list {list}]\".format(\n                name=\"{n}.hold_set\".format(n=hold_corner.name),\n                list=self.get_timing_libs(hold_corner)\n            ))\n            # Skip opconds for now\n            # Next, create Innovus timing conditions\n            append_mmmc(\"create_timing_condition -name {name} -library_sets [list {list}]\".format(\n                name=\"{n}.setup_cond\".format(n=setup_corner.name),\n                list=\"{n}.setup_set\".format(n=setup_corner.name)\n            ))\n            append_mmmc(\"create_timing_condition -name {name} -library_sets [list {list}]\".format(\n                name=\"{n}.hold_cond\".format(n=hold_corner.name),\n                list=\"{n}.hold_set\".format(n=hold_corner.name)\n            ))\n            # Next, create Innovus rc corners from qrc tech files\n            append_mmmc(\"create_rc_corner -name {name} -temperature {tempInCelsius} {qrc}\".format(\n                name=\"{n}.setup_rc\".format(n=setup_corner.name),\n                tempInCelsius=str(setup_corner.temp.value),\n                qrc=\"-qrc_tech {}\".format(self.get_mmmc_qrc(setup_corner)) if self.get_mmmc_qrc(setup_corner) != '' else ''\n            ))\n            append_mmmc(\"create_rc_corner -name {name} -temperature {tempInCelsius} {qrc}\".format(\n                name=\"{n}.hold_rc\".format(n=hold_corner.name),\n                tempInCelsius=str(hold_corner.temp.value),\n                qrc=\"-qrc_tech {}\".format(self.get_mmmc_qrc(hold_corner)) if self.get_mmmc_qrc(hold_corner) != '' else ''\n            ))\n            # Next, create an Innovus delay corner.\n            append_mmmc(\n                \"create_delay_corner -name {name}_delay -timing_condition {name}_cond -rc_corner {name}_rc\".format(\n                    name=\"{n}.setup\".format(n=setup_corner.name)\n                ))\n            append_mmmc(\n                \"create_delay_corner -name {name}_delay -timing_condition {name}_cond -rc_corner {name}_rc\".format(\n                    name=\"{n}.hold\".format(n=hold_corner.name)\n                ))\n            # Next, create the analysis views\n            append_mmmc(\"create_analysis_view -name {name}_view -delay_corner {name}_delay -constraint_mode {constraint}\".format(\n                name=\"{n}.setup\".format(n=setup_corner.name), constraint=constraint_mode))\n            append_mmmc(\"create_analysis_view -name {name}_view -delay_corner {name}_delay -constraint_mode {constraint}\".format(\n                name=\"{n}.hold\".format(n=hold_corner.name), constraint=constraint_mode))\n            # Finally, apply the analysis view.\n            append_mmmc(\"set_analysis_view -setup {{ {setup_view} }} -hold {{ {hold_view} }}\".format(\n                setup_view=\"{n}.setup_view\".format(n=setup_corner.name),\n                hold_view=\"{n}.hold_view\".format(n=hold_corner.name)\n            ))\n        <DED>else:\n            # First, create an Innovus library set.\n            <IND>library_set_name = \"my_lib_set\"\n            append_mmmc(\"create_library_set -name {name} -timing [list {list}]\".format(\n                name=library_set_name,\n                list=self.get_timing_libs()\n            ))\n            # Next, create an Innovus timing condition.\n            timing_condition_name = \"my_timing_condition\"\n            append_mmmc(\"create_timing_condition -name {name} -library_sets [list {list}]\".format(\n                name=timing_condition_name,\n                list=library_set_name\n            ))\n            # extra junk: -opcond ...\n            rc_corner_name = \"rc_cond\"\n            append_mmmc(\"create_rc_corner -name {name} -temperature {tempInCelsius} {qrc}\".format(\n                name=rc_corner_name,\n                tempInCelsius=120,  # TODO: this should come from tech config\n                qrc=\"-qrc_tech {}\".format(self.get_qrc_tech()) if self.get_qrc_tech() != '' else ''\n            ))\n            # Next, create an Innovus delay corner.\n            delay_corner_name = \"my_delay_corner\"\n            append_mmmc(\n                \"create_delay_corner -name {name} -timing_condition {timing_cond} -rc_corner {rc}\".format(\n                    name=delay_corner_name,\n                    timing_cond=timing_condition_name,\n                    rc=rc_corner_name\n                ))\n            # extra junk: -rc_corner my_rc_corner_maybe_worst\n            # Next, create an Innovus analysis view.\n            analysis_view_name = \"my_view\"\n            append_mmmc(\"create_analysis_view -name {name} -delay_corner {corner} -constraint_mode {constraint}\".format(\n                name=analysis_view_name, corner=delay_corner_name, constraint=constraint_mode))\n            # Finally, apply the analysis view.\n            # TODO: introduce different views of setup/hold and true multi-corner\n            append_mmmc(\"set_analysis_view -setup {{ {setup_view} }} -hold {{ {hold_view} }}\".format(\n                setup_view=analysis_view_name,\n                hold_view=analysis_view_name\n            ))\n\n        <DED>return \"\\n\".join(mmmc_output)\n\n    <DED>def generate_dont_use_commands(self) -> List[str]:\n        <IND>\"\"\"\n        Generate a list of dont_use commands for Cadence tools.\n        \"\"\"\n\n        def map_cell(in_cell: str) -> str:\n            # \"*/\" is needed for \"get_db lib_cells <cell_expression>\"\n            <IND>if in_cell.startswith(\"*/\"):\n                <IND>mapped_cell = in_cell  # type: str\n            <DED>else:\n                <IND>mapped_cell = \"*/\" + in_cell\n\n            # Check for cell existence first to avoid Genus erroring out.\n            <DED>get_db_str = \"[get_db lib_cells {mapped_cell}]\".format(mapped_cell=mapped_cell)\n            # Escaped version for puts.\n            get_db_str_escaped = get_db_str.replace('[', '\\[').replace(']', '\\]')\n            return \"\"\"\nputs \"set_dont_use {get_db_str_escaped}\"\nif {{ {get_db_str} ne \"\" }} {{\n    set_dont_use {get_db_str}\n}} else {{\n    puts \"WARNING: cell {mapped_cell} was not found for set_dont_use\"\n}}\n            \"\"\".format(get_db_str=get_db_str, get_db_str_escaped=get_db_str_escaped, mapped_cell=mapped_cell)\n\n        <DED>return list(map(map_cell, self.get_dont_use_list()))\n\n    <DED>def generate_power_spec_commands(self) -> List[str]:\n        <IND>\"\"\"\n        Generate commands to load a power specification for Cadence tools.\n        \"\"\"\n\n        power_spec_type = str(self.get_setting(\"vlsi.inputs.power_spec_type\"))  # type: str\n        power_spec_arg = \"\"  # type: str\n        if power_spec_type == \"cpf\":\n            <IND>power_spec_arg = \"cpf\"\n        <DED>elif power_spec_type == \"upf\":\n            <IND>power_spec_arg = \"1801\"\n        <DED>else:\n            <IND>self.logger.error(\n                \"Invalid power specification type '{tpe}'; only 'cpf' or 'upf' supported\".format(tpe=power_spec_type))\n            return []\n\n        <DED>power_spec_contents = \"\"  # type: str\n        power_spec_mode = str(self.get_setting(\"vlsi.inputs.power_spec_mode\"))  # type: str\n        if power_spec_mode == \"empty\":\n            <IND>return []\n        <DED>elif power_spec_mode == \"auto\":\n            <IND>if power_spec_type == \"cpf\":\n                <IND>power_spec_contents = self.cpf_power_specification\n            <DED>elif power_spec_type == \"upf\":\n                <IND>power_spec_contents = self.upf_power_specification\n        <DED><DED>elif power_spec_mode == \"manual\":\n            <IND>power_spec_contents = str(self.get_setting(\"vlsi.inputs.power_spec_contents\"))\n        <DED>else:\n            <IND>self.logger.error(\"Invalid power specification mode '{mode}'; using 'empty'.\".format(mode=power_spec_mode))\n            return []\n\n        # Write the power spec contents to file and include it\n        <DED>power_spec_file = os.path.join(self.run_dir, \"power_spec.{tpe}\".format(tpe=power_spec_type))\n        with open(power_spec_file, \"w\") as f:\n            <IND>f.write(power_spec_contents)\n        <DED>return [\"read_power_intent -{arg} {path}\".format(arg=power_spec_arg, path=power_spec_file),\n                \"commit_power_intent\"]\n\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "        <IND>self.tcl_append(cmd, self.output, clean)\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "ucb-bar/hammer",
    "commit": "3afca0f00301e87b3112d42284a6acfd3c083c42",
    "filename": "src/hammer-vlsi/hammer_vlsi/hammer_vlsi_impl.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/ucb-bar-hammer/src/hammer-vlsi/hammer_vlsi/hammer_vlsi_impl.py",
    "file_hunks_size": 13,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": true,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "src/hammer-vlsi/hammer_vlsi/hammer_vlsi_impl.py:1629:47 Invalid type [31]: Expression `src.hammer.__sub__(vlsi.hammer_vlsi.constraints.MMMCCorner)` is not a valid type.",
    "message": " Expression `src.hammer.__sub__(vlsi.hammer_vlsi.constraints.MMMCCorner)` is not a valid type.",
    "rule_id": "Invalid type [31]",
    "warning_line_no": 1629,
    "warning_line": "            setup_corner = corners[0]  # type: MMMCCorner",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": true,
        "has_suppression": false,
        "source_code": "        self.tcl_append(cmd, self.output, clean)\n\n\nclass CadenceTool(HasSDCSupport, HasCPFSupport, HasUPFSupport, TCLTool, HammerTool):\n    \"\"\"Mix-in trait with functions useful for Cadence-based tools.\"\"\"\n\n    @property\n    def config_dirs(self) -> List[str]:\n        # Override this to pull in Cadence-common configs.\n        return [self.get_setting(\"cadence.common_path\")] + super().config_dirs\n\n    @property\n    def env_vars(self) -> Dict[str, str]:\n        \"\"\"\n        Get the list of environment variables required for this tool.\n        Note to subclasses: remember to include variables from super().env_vars!\n        \"\"\"\n        # Use the base extra_env_variables and ensure that our custom variables are on top.\n        list_of_vars = self.get_setting(\"cadence.extra_env_vars\")  # type: List[Dict[str, Any]]\n        assert isinstance(list_of_vars, list)\n\n        cadence_vars = {\n            \"CDS_LIC_FILE\": self.get_setting(\"cadence.CDS_LIC_FILE\"),\n            \"CADENCE_HOME\": self.get_setting(\"cadence.cadence_home\")\n        }\n\n        return reduce(add_dicts, [dict(super().env_vars)] + list_of_vars + [cadence_vars], {})\n\n    def version_number(self, version: str) -> int:\n        \"\"\"\n        Assumes versions look like MAJOR_ISRMINOR and we will have less than 100 minor versions.\n        \"\"\"\n        main_version = int(version.split(\"_\")[0]) # type: int\n        minor_version = 0 # type: int\n        if \"_\" in version:\n            minor_version = int(version.split(\"_\")[1][3:])\n        return main_version * 100 + minor_version\n\n    def get_timing_libs(self, corner: Optional[MMMCCorner] = None) -> str:\n        \"\"\"\n        Helper function to get the list of ASCII timing .lib files in space separated format.\n        Note that Cadence tools support ECSM, so we can use the ECSM-based filter.\n\n        :param corner: Optional corner to consider. If supplied, this will use filter_for_mmmc to select libraries that\n        match a given corner (voltage/temperature).\n        :return: List of lib files separated by spaces\n        \"\"\"\n        pre_filters = optional_map(corner, lambda c: [self.filter_for_mmmc(voltage=c.voltage,\n                                                                           temp=c.temp)])  # type: Optional[List[Callable[[hammer_tech.Library],bool]]]\n\n        lib_args = self.technology.read_libs([hammer_tech.filters.timing_lib_with_ecsm_filter],\n                                             hammer_tech.HammerTechnologyUtils.to_plain_item,\n                                             extra_pre_filters=pre_filters)\n        return \" \".join(lib_args)\n\n    def get_mmmc_qrc(self, corner: MMMCCorner) -> str:\n        lib_args = self.technology.read_libs([hammer_tech.filters.qrc_tech_filter],\n                                             hammer_tech.HammerTechnologyUtils.to_plain_item,\n                                             extra_pre_filters=[\n                                                 self.filter_for_mmmc(voltage=corner.voltage, temp=corner.temp)])\n        return \" \".join(lib_args)\n\n    def get_qrc_tech(self) -> str:\n        \"\"\"\n        Helper function to get the list of rc corner tech files in space separated format.\n\n        :return: List of qrc tech files separated by spaces\n        \"\"\"\n        lib_args = self.technology.read_libs([\n            hammer_tech.filters.qrc_tech_filter\n        ], hammer_tech.HammerTechnologyUtils.to_plain_item)\n        return \" \".join(lib_args)\n\n    def generate_mmmc_script(self) -> str:\n        \"\"\"\n        Output for the mmmc.tcl script.\n        Innovus (init_design) requires that the timing script be placed in a separate file.\n\n        :return: Contents of the mmmc script.\n        \"\"\"\n        mmmc_output = []  # type: List[str]\n\n        def append_mmmc(cmd: str) -> None:\n            self.verbose_tcl_append(cmd, mmmc_output)\n\n        # Create an Innovus constraint mode.\n        constraint_mode = \"my_constraint_mode\"\n        sdc_files = []  # type: List[str]\n\n        # Generate constraints\n        clock_constraints_fragment = os.path.join(self.run_dir, \"clock_constraints_fragment.sdc\")\n        with open(clock_constraints_fragment, \"w\") as f:\n            f.write(self.sdc_clock_constraints)\n        sdc_files.append(clock_constraints_fragment)\n\n        # Generate port constraints.\n        pin_constraints_fragment = os.path.join(self.run_dir, \"pin_constraints_fragment.sdc\")\n        with open(pin_constraints_fragment, \"w\") as f:\n            f.write(self.sdc_pin_constraints)\n        sdc_files.append(pin_constraints_fragment)\n\n        # Add the post-synthesis SDC, if present.\n        post_synth_sdc = self.post_synth_sdc\n        if post_synth_sdc is not None:\n            sdc_files.append(post_synth_sdc)\n\n        # TODO: add floorplanning SDC\n        if len(sdc_files) > 0:\n            sdc_files_arg = \"-sdc_files [list {sdc_files}]\".format(\n                sdc_files=\" \".join(sdc_files)\n            )\n        else:\n            blank_sdc = os.path.join(self.run_dir, \"blank.sdc\")\n            self.run_executable([\"touch\", blank_sdc])\n            sdc_files_arg = \"-sdc_files {{ {} }}\".format(blank_sdc)\n        append_mmmc(\"create_constraint_mode -name {name} {sdc_files_arg}\".format(\n            name=constraint_mode,\n            sdc_files_arg=sdc_files_arg\n        ))\n\n        corners = self.get_mmmc_corners()  # type: List[MMMCCorner]\n        # In parallel, create the delay corners\n        if corners:\n            setup_corner = corners[0]  # type: MMMCCorner\n            hold_corner = corners[0]  # type: MMMCCorner\n            # TODO(colins): handle more than one corner and do something with extra corners\n            for corner in corners:\n                if corner.type is MMMCCornerType.Setup:\n                    setup_corner = corner\n                if corner.type is MMMCCornerType.Hold:\n                    hold_corner = corner\n\n            # First, create Innovus library sets\n            append_mmmc(\"create_library_set -name {name} -timing [list {list}]\".format(\n                name=\"{n}.setup_set\".format(n=setup_corner.name),\n                list=self.get_timing_libs(setup_corner)\n            ))\n            append_mmmc(\"create_library_set -name {name} -timing [list {list}]\".format(\n                name=\"{n}.hold_set\".format(n=hold_corner.name),\n                list=self.get_timing_libs(hold_corner)\n            ))\n            # Skip opconds for now\n            # Next, create Innovus timing conditions\n            append_mmmc(\"create_timing_condition -name {name} -library_sets [list {list}]\".format(\n                name=\"{n}.setup_cond\".format(n=setup_corner.name),\n                list=\"{n}.setup_set\".format(n=setup_corner.name)\n            ))\n            append_mmmc(\"create_timing_condition -name {name} -library_sets [list {list}]\".format(\n                name=\"{n}.hold_cond\".format(n=hold_corner.name),\n                list=\"{n}.hold_set\".format(n=hold_corner.name)\n            ))\n            # Next, create Innovus rc corners from qrc tech files\n            append_mmmc(\"create_rc_corner -name {name} -temperature {tempInCelsius} {qrc}\".format(\n                name=\"{n}.setup_rc\".format(n=setup_corner.name),\n                tempInCelsius=str(setup_corner.temp.value),\n                qrc=\"-qrc_tech {}\".format(self.get_mmmc_qrc(setup_corner)) if self.get_mmmc_qrc(setup_corner) != '' else ''\n            ))\n            append_mmmc(\"create_rc_corner -name {name} -temperature {tempInCelsius} {qrc}\".format(\n                name=\"{n}.hold_rc\".format(n=hold_corner.name),\n                tempInCelsius=str(hold_corner.temp.value),\n                qrc=\"-qrc_tech {}\".format(self.get_mmmc_qrc(hold_corner)) if self.get_mmmc_qrc(hold_corner) != '' else ''\n            ))\n            # Next, create an Innovus delay corner.\n            append_mmmc(\n                \"create_delay_corner -name {name}_delay -timing_condition {name}_cond -rc_corner {name}_rc\".format(\n                    name=\"{n}.setup\".format(n=setup_corner.name)\n                ))\n            append_mmmc(\n                \"create_delay_corner -name {name}_delay -timing_condition {name}_cond -rc_corner {name}_rc\".format(\n                    name=\"{n}.hold\".format(n=hold_corner.name)\n                ))\n            # Next, create the analysis views\n            append_mmmc(\"create_analysis_view -name {name}_view -delay_corner {name}_delay -constraint_mode {constraint}\".format(\n                name=\"{n}.setup\".format(n=setup_corner.name), constraint=constraint_mode))\n            append_mmmc(\"create_analysis_view -name {name}_view -delay_corner {name}_delay -constraint_mode {constraint}\".format(\n                name=\"{n}.hold\".format(n=hold_corner.name), constraint=constraint_mode))\n            # Finally, apply the analysis view.\n            append_mmmc(\"set_analysis_view -setup {{ {setup_view} }} -hold {{ {hold_view} }}\".format(\n                setup_view=\"{n}.setup_view\".format(n=setup_corner.name),\n                hold_view=\"{n}.hold_view\".format(n=hold_corner.name)\n            ))\n        else:\n            # First, create an Innovus library set.\n            library_set_name = \"my_lib_set\"\n            append_mmmc(\"create_library_set -name {name} -timing [list {list}]\".format(\n                name=library_set_name,\n                list=self.get_timing_libs()\n            ))\n            # Next, create an Innovus timing condition.\n            timing_condition_name = \"my_timing_condition\"\n            append_mmmc(\"create_timing_condition -name {name} -library_sets [list {list}]\".format(\n                name=timing_condition_name,\n                list=library_set_name\n            ))\n            # extra junk: -opcond ...\n            rc_corner_name = \"rc_cond\"\n            append_mmmc(\"create_rc_corner -name {name} -temperature {tempInCelsius} {qrc}\".format(\n                name=rc_corner_name,\n                tempInCelsius=120,  # TODO: this should come from tech config\n                qrc=\"-qrc_tech {}\".format(self.get_qrc_tech()) if self.get_qrc_tech() != '' else ''\n            ))\n            # Next, create an Innovus delay corner.\n            delay_corner_name = \"my_delay_corner\"\n            append_mmmc(\n                \"create_delay_corner -name {name} -timing_condition {timing_cond} -rc_corner {rc}\".format(\n                    name=delay_corner_name,\n                    timing_cond=timing_condition_name,\n                    rc=rc_corner_name\n                ))\n            # extra junk: -rc_corner my_rc_corner_maybe_worst\n            # Next, create an Innovus analysis view.\n            analysis_view_name = \"my_view\"\n            append_mmmc(\"create_analysis_view -name {name} -delay_corner {corner} -constraint_mode {constraint}\".format(\n                name=analysis_view_name, corner=delay_corner_name, constraint=constraint_mode))\n            # Finally, apply the analysis view.\n            # TODO: introduce different views of setup/hold and true multi-corner\n            append_mmmc(\"set_analysis_view -setup {{ {setup_view} }} -hold {{ {hold_view} }}\".format(\n                setup_view=analysis_view_name,\n                hold_view=analysis_view_name\n            ))\n\n        return \"\\n\".join(mmmc_output)\n\n    def generate_dont_use_commands(self) -> List[str]:\n        \"\"\"\n        Generate a list of dont_use commands for Cadence tools.\n        \"\"\"\n\n        def map_cell(in_cell: str) -> str:\n            # \"*/\" is needed for \"get_db lib_cells <cell_expression>\"\n            if in_cell.startswith(\"*/\"):\n                mapped_cell = in_cell  # type: str\n            else:\n                mapped_cell = \"*/\" + in_cell\n\n            # Check for cell existence first to avoid Genus erroring out.\n            get_db_str = \"[get_db lib_cells {mapped_cell}]\".format(mapped_cell=mapped_cell)\n            # Escaped version for puts.\n            get_db_str_escaped = get_db_str.replace('[', '\\[').replace(']', '\\]')\n            return \"\"\"\nputs \"set_dont_use {get_db_str_escaped}\"\nif {{ {get_db_str} ne \"\" }} {{\n    set_dont_use {get_db_str}\n}} else {{\n    puts \"WARNING: cell {mapped_cell} was not found for set_dont_use\"\n}}\n            \"\"\".format(get_db_str=get_db_str, get_db_str_escaped=get_db_str_escaped, mapped_cell=mapped_cell)\n\n        return list(map(map_cell, self.get_dont_use_list()))\n\n    def generate_power_spec_commands(self) -> List[str]:\n        \"\"\"\n        Generate commands to load a power specification for Cadence tools.\n        \"\"\"\n\n        power_spec_type = str(self.get_setting(\"vlsi.inputs.power_spec_type\"))  # type: str\n        power_spec_arg = \"\"  # type: str\n        if power_spec_type == \"cpf\":\n            power_spec_arg = \"cpf\"\n        elif power_spec_type == \"upf\":\n            power_spec_arg = \"1801\"\n        else:\n            self.logger.error(\n                \"Invalid power specification type '{tpe}'; only 'cpf' or 'upf' supported\".format(tpe=power_spec_type))\n            return []\n\n        power_spec_contents = \"\"  # type: str\n        power_spec_mode = str(self.get_setting(\"vlsi.inputs.power_spec_mode\"))  # type: str\n        if power_spec_mode == \"empty\":\n            return []\n        elif power_spec_mode == \"auto\":\n            if power_spec_type == \"cpf\":\n                power_spec_contents = self.cpf_power_specification\n            elif power_spec_type == \"upf\":\n                power_spec_contents = self.upf_power_specification\n        elif power_spec_mode == \"manual\":\n            power_spec_contents = str(self.get_setting(\"vlsi.inputs.power_spec_contents\"))\n        else:\n            self.logger.error(\"Invalid power specification mode '{mode}'; using 'empty'.\".format(mode=power_spec_mode))\n            return []\n\n        # Write the power spec contents to file and include it\n        power_spec_file = os.path.join(self.run_dir, \"power_spec.{tpe}\".format(tpe=power_spec_type))\n        with open(power_spec_file, \"w\") as f:\n            f.write(power_spec_contents)\n        return [\"read_power_intent -{arg} {path}\".format(arg=power_spec_arg, path=power_spec_file),\n                \"commit_power_intent\"]\n\n\n",
        "source_code_len": 14014,
        "target_code": "        self.tcl_append(cmd, self.output, clean)\n\n",
        "target_code_len": 50,
        "diff_format": "@@ -1506,289 +1506,2 @@\n         self.tcl_append(cmd, self.output, clean)\n-\n-\n-class CadenceTool(HasSDCSupport, HasCPFSupport, HasUPFSupport, TCLTool, HammerTool):\n-    \"\"\"Mix-in trait with functions useful for Cadence-based tools.\"\"\"\n-\n-    @property\n-    def config_dirs(self) -> List[str]:\n-        # Override this to pull in Cadence-common configs.\n-        return [self.get_setting(\"cadence.common_path\")] + super().config_dirs\n-\n-    @property\n-    def env_vars(self) -> Dict[str, str]:\n-        \"\"\"\n-        Get the list of environment variables required for this tool.\n-        Note to subclasses: remember to include variables from super().env_vars!\n-        \"\"\"\n-        # Use the base extra_env_variables and ensure that our custom variables are on top.\n-        list_of_vars = self.get_setting(\"cadence.extra_env_vars\")  # type: List[Dict[str, Any]]\n-        assert isinstance(list_of_vars, list)\n-\n-        cadence_vars = {\n-            \"CDS_LIC_FILE\": self.get_setting(\"cadence.CDS_LIC_FILE\"),\n-            \"CADENCE_HOME\": self.get_setting(\"cadence.cadence_home\")\n-        }\n-\n-        return reduce(add_dicts, [dict(super().env_vars)] + list_of_vars + [cadence_vars], {})\n-\n-    def version_number(self, version: str) -> int:\n-        \"\"\"\n-        Assumes versions look like MAJOR_ISRMINOR and we will have less than 100 minor versions.\n-        \"\"\"\n-        main_version = int(version.split(\"_\")[0]) # type: int\n-        minor_version = 0 # type: int\n-        if \"_\" in version:\n-            minor_version = int(version.split(\"_\")[1][3:])\n-        return main_version * 100 + minor_version\n-\n-    def get_timing_libs(self, corner: Optional[MMMCCorner] = None) -> str:\n-        \"\"\"\n-        Helper function to get the list of ASCII timing .lib files in space separated format.\n-        Note that Cadence tools support ECSM, so we can use the ECSM-based filter.\n-\n-        :param corner: Optional corner to consider. If supplied, this will use filter_for_mmmc to select libraries that\n-        match a given corner (voltage/temperature).\n-        :return: List of lib files separated by spaces\n-        \"\"\"\n-        pre_filters = optional_map(corner, lambda c: [self.filter_for_mmmc(voltage=c.voltage,\n-                                                                           temp=c.temp)])  # type: Optional[List[Callable[[hammer_tech.Library],bool]]]\n-\n-        lib_args = self.technology.read_libs([hammer_tech.filters.timing_lib_with_ecsm_filter],\n-                                             hammer_tech.HammerTechnologyUtils.to_plain_item,\n-                                             extra_pre_filters=pre_filters)\n-        return \" \".join(lib_args)\n-\n-    def get_mmmc_qrc(self, corner: MMMCCorner) -> str:\n-        lib_args = self.technology.read_libs([hammer_tech.filters.qrc_tech_filter],\n-                                             hammer_tech.HammerTechnologyUtils.to_plain_item,\n-                                             extra_pre_filters=[\n-                                                 self.filter_for_mmmc(voltage=corner.voltage, temp=corner.temp)])\n-        return \" \".join(lib_args)\n-\n-    def get_qrc_tech(self) -> str:\n-        \"\"\"\n-        Helper function to get the list of rc corner tech files in space separated format.\n-\n-        :return: List of qrc tech files separated by spaces\n-        \"\"\"\n-        lib_args = self.technology.read_libs([\n-            hammer_tech.filters.qrc_tech_filter\n-        ], hammer_tech.HammerTechnologyUtils.to_plain_item)\n-        return \" \".join(lib_args)\n-\n-    def generate_mmmc_script(self) -> str:\n-        \"\"\"\n-        Output for the mmmc.tcl script.\n-        Innovus (init_design) requires that the timing script be placed in a separate file.\n-\n-        :return: Contents of the mmmc script.\n-        \"\"\"\n-        mmmc_output = []  # type: List[str]\n-\n-        def append_mmmc(cmd: str) -> None:\n-            self.verbose_tcl_append(cmd, mmmc_output)\n-\n-        # Create an Innovus constraint mode.\n-        constraint_mode = \"my_constraint_mode\"\n-        sdc_files = []  # type: List[str]\n-\n-        # Generate constraints\n-        clock_constraints_fragment = os.path.join(self.run_dir, \"clock_constraints_fragment.sdc\")\n-        with open(clock_constraints_fragment, \"w\") as f:\n-            f.write(self.sdc_clock_constraints)\n-        sdc_files.append(clock_constraints_fragment)\n-\n-        # Generate port constraints.\n-        pin_constraints_fragment = os.path.join(self.run_dir, \"pin_constraints_fragment.sdc\")\n-        with open(pin_constraints_fragment, \"w\") as f:\n-            f.write(self.sdc_pin_constraints)\n-        sdc_files.append(pin_constraints_fragment)\n-\n-        # Add the post-synthesis SDC, if present.\n-        post_synth_sdc = self.post_synth_sdc\n-        if post_synth_sdc is not None:\n-            sdc_files.append(post_synth_sdc)\n-\n-        # TODO: add floorplanning SDC\n-        if len(sdc_files) > 0:\n-            sdc_files_arg = \"-sdc_files [list {sdc_files}]\".format(\n-                sdc_files=\" \".join(sdc_files)\n-            )\n-        else:\n-            blank_sdc = os.path.join(self.run_dir, \"blank.sdc\")\n-            self.run_executable([\"touch\", blank_sdc])\n-            sdc_files_arg = \"-sdc_files {{ {} }}\".format(blank_sdc)\n-        append_mmmc(\"create_constraint_mode -name {name} {sdc_files_arg}\".format(\n-            name=constraint_mode,\n-            sdc_files_arg=sdc_files_arg\n-        ))\n-\n-        corners = self.get_mmmc_corners()  # type: List[MMMCCorner]\n-        # In parallel, create the delay corners\n-        if corners:\n-            setup_corner = corners[0]  # type: MMMCCorner\n-            hold_corner = corners[0]  # type: MMMCCorner\n-            # TODO(colins): handle more than one corner and do something with extra corners\n-            for corner in corners:\n-                if corner.type is MMMCCornerType.Setup:\n-                    setup_corner = corner\n-                if corner.type is MMMCCornerType.Hold:\n-                    hold_corner = corner\n-\n-            # First, create Innovus library sets\n-            append_mmmc(\"create_library_set -name {name} -timing [list {list}]\".format(\n-                name=\"{n}.setup_set\".format(n=setup_corner.name),\n-                list=self.get_timing_libs(setup_corner)\n-            ))\n-            append_mmmc(\"create_library_set -name {name} -timing [list {list}]\".format(\n-                name=\"{n}.hold_set\".format(n=hold_corner.name),\n-                list=self.get_timing_libs(hold_corner)\n-            ))\n-            # Skip opconds for now\n-            # Next, create Innovus timing conditions\n-            append_mmmc(\"create_timing_condition -name {name} -library_sets [list {list}]\".format(\n-                name=\"{n}.setup_cond\".format(n=setup_corner.name),\n-                list=\"{n}.setup_set\".format(n=setup_corner.name)\n-            ))\n-            append_mmmc(\"create_timing_condition -name {name} -library_sets [list {list}]\".format(\n-                name=\"{n}.hold_cond\".format(n=hold_corner.name),\n-                list=\"{n}.hold_set\".format(n=hold_corner.name)\n-            ))\n-            # Next, create Innovus rc corners from qrc tech files\n-            append_mmmc(\"create_rc_corner -name {name} -temperature {tempInCelsius} {qrc}\".format(\n-                name=\"{n}.setup_rc\".format(n=setup_corner.name),\n-                tempInCelsius=str(setup_corner.temp.value),\n-                qrc=\"-qrc_tech {}\".format(self.get_mmmc_qrc(setup_corner)) if self.get_mmmc_qrc(setup_corner) != '' else ''\n-            ))\n-            append_mmmc(\"create_rc_corner -name {name} -temperature {tempInCelsius} {qrc}\".format(\n-                name=\"{n}.hold_rc\".format(n=hold_corner.name),\n-                tempInCelsius=str(hold_corner.temp.value),\n-                qrc=\"-qrc_tech {}\".format(self.get_mmmc_qrc(hold_corner)) if self.get_mmmc_qrc(hold_corner) != '' else ''\n-            ))\n-            # Next, create an Innovus delay corner.\n-            append_mmmc(\n-                \"create_delay_corner -name {name}_delay -timing_condition {name}_cond -rc_corner {name}_rc\".format(\n-                    name=\"{n}.setup\".format(n=setup_corner.name)\n-                ))\n-            append_mmmc(\n-                \"create_delay_corner -name {name}_delay -timing_condition {name}_cond -rc_corner {name}_rc\".format(\n-                    name=\"{n}.hold\".format(n=hold_corner.name)\n-                ))\n-            # Next, create the analysis views\n-            append_mmmc(\"create_analysis_view -name {name}_view -delay_corner {name}_delay -constraint_mode {constraint}\".format(\n-                name=\"{n}.setup\".format(n=setup_corner.name), constraint=constraint_mode))\n-            append_mmmc(\"create_analysis_view -name {name}_view -delay_corner {name}_delay -constraint_mode {constraint}\".format(\n-                name=\"{n}.hold\".format(n=hold_corner.name), constraint=constraint_mode))\n-            # Finally, apply the analysis view.\n-            append_mmmc(\"set_analysis_view -setup {{ {setup_view} }} -hold {{ {hold_view} }}\".format(\n-                setup_view=\"{n}.setup_view\".format(n=setup_corner.name),\n-                hold_view=\"{n}.hold_view\".format(n=hold_corner.name)\n-            ))\n-        else:\n-            # First, create an Innovus library set.\n-            library_set_name = \"my_lib_set\"\n-            append_mmmc(\"create_library_set -name {name} -timing [list {list}]\".format(\n-                name=library_set_name,\n-                list=self.get_timing_libs()\n-            ))\n-            # Next, create an Innovus timing condition.\n-            timing_condition_name = \"my_timing_condition\"\n-            append_mmmc(\"create_timing_condition -name {name} -library_sets [list {list}]\".format(\n-                name=timing_condition_name,\n-                list=library_set_name\n-            ))\n-            # extra junk: -opcond ...\n-            rc_corner_name = \"rc_cond\"\n-            append_mmmc(\"create_rc_corner -name {name} -temperature {tempInCelsius} {qrc}\".format(\n-                name=rc_corner_name,\n-                tempInCelsius=120,  # TODO: this should come from tech config\n-                qrc=\"-qrc_tech {}\".format(self.get_qrc_tech()) if self.get_qrc_tech() != '' else ''\n-            ))\n-            # Next, create an Innovus delay corner.\n-            delay_corner_name = \"my_delay_corner\"\n-            append_mmmc(\n-                \"create_delay_corner -name {name} -timing_condition {timing_cond} -rc_corner {rc}\".format(\n-                    name=delay_corner_name,\n-                    timing_cond=timing_condition_name,\n-                    rc=rc_corner_name\n-                ))\n-            # extra junk: -rc_corner my_rc_corner_maybe_worst\n-            # Next, create an Innovus analysis view.\n-            analysis_view_name = \"my_view\"\n-            append_mmmc(\"create_analysis_view -name {name} -delay_corner {corner} -constraint_mode {constraint}\".format(\n-                name=analysis_view_name, corner=delay_corner_name, constraint=constraint_mode))\n-            # Finally, apply the analysis view.\n-            # TODO: introduce different views of setup/hold and true multi-corner\n-            append_mmmc(\"set_analysis_view -setup {{ {setup_view} }} -hold {{ {hold_view} }}\".format(\n-                setup_view=analysis_view_name,\n-                hold_view=analysis_view_name\n-            ))\n-\n-        return \"\\n\".join(mmmc_output)\n-\n-    def generate_dont_use_commands(self) -> List[str]:\n-        \"\"\"\n-        Generate a list of dont_use commands for Cadence tools.\n-        \"\"\"\n-\n-        def map_cell(in_cell: str) -> str:\n-            # \"*/\" is needed for \"get_db lib_cells <cell_expression>\"\n-            if in_cell.startswith(\"*/\"):\n-                mapped_cell = in_cell  # type: str\n-            else:\n-                mapped_cell = \"*/\" + in_cell\n-\n-            # Check for cell existence first to avoid Genus erroring out.\n-            get_db_str = \"[get_db lib_cells {mapped_cell}]\".format(mapped_cell=mapped_cell)\n-            # Escaped version for puts.\n-            get_db_str_escaped = get_db_str.replace('[', '\\[').replace(']', '\\]')\n-            return \"\"\"\n-puts \"set_dont_use {get_db_str_escaped}\"\n-if {{ {get_db_str} ne \"\" }} {{\n-    set_dont_use {get_db_str}\n-}} else {{\n-    puts \"WARNING: cell {mapped_cell} was not found for set_dont_use\"\n-}}\n-            \"\"\".format(get_db_str=get_db_str, get_db_str_escaped=get_db_str_escaped, mapped_cell=mapped_cell)\n-\n-        return list(map(map_cell, self.get_dont_use_list()))\n-\n-    def generate_power_spec_commands(self) -> List[str]:\n-        \"\"\"\n-        Generate commands to load a power specification for Cadence tools.\n-        \"\"\"\n-\n-        power_spec_type = str(self.get_setting(\"vlsi.inputs.power_spec_type\"))  # type: str\n-        power_spec_arg = \"\"  # type: str\n-        if power_spec_type == \"cpf\":\n-            power_spec_arg = \"cpf\"\n-        elif power_spec_type == \"upf\":\n-            power_spec_arg = \"1801\"\n-        else:\n-            self.logger.error(\n-                \"Invalid power specification type '{tpe}'; only 'cpf' or 'upf' supported\".format(tpe=power_spec_type))\n-            return []\n-\n-        power_spec_contents = \"\"  # type: str\n-        power_spec_mode = str(self.get_setting(\"vlsi.inputs.power_spec_mode\"))  # type: str\n-        if power_spec_mode == \"empty\":\n-            return []\n-        elif power_spec_mode == \"auto\":\n-            if power_spec_type == \"cpf\":\n-                power_spec_contents = self.cpf_power_specification\n-            elif power_spec_type == \"upf\":\n-                power_spec_contents = self.upf_power_specification\n-        elif power_spec_mode == \"manual\":\n-            power_spec_contents = str(self.get_setting(\"vlsi.inputs.power_spec_contents\"))\n-        else:\n-            self.logger.error(\"Invalid power specification mode '{mode}'; using 'empty'.\".format(mode=power_spec_mode))\n-            return []\n-\n-        # Write the power spec contents to file and include it\n-        power_spec_file = os.path.join(self.run_dir, \"power_spec.{tpe}\".format(tpe=power_spec_type))\n-        with open(power_spec_file, \"w\") as f:\n-            f.write(power_spec_contents)\n-        return [\"read_power_intent -{arg} {path}\".format(arg=power_spec_arg, path=power_spec_file),\n-                \"commit_power_intent\"]\n-\n \n",
        "source_code_with_indent": "        <IND>self.tcl_append(cmd, self.output, clean)\n\n\n<DED><DED>class CadenceTool(HasSDCSupport, HasCPFSupport, HasUPFSupport, TCLTool, HammerTool):\n    <IND>\"\"\"Mix-in trait with functions useful for Cadence-based tools.\"\"\"\n\n    @property\n    def config_dirs(self) -> List[str]:\n        # Override this to pull in Cadence-common configs.\n        <IND>return [self.get_setting(\"cadence.common_path\")] + super().config_dirs\n\n    <DED>@property\n    def env_vars(self) -> Dict[str, str]:\n        <IND>\"\"\"\n        Get the list of environment variables required for this tool.\n        Note to subclasses: remember to include variables from super().env_vars!\n        \"\"\"\n        # Use the base extra_env_variables and ensure that our custom variables are on top.\n        list_of_vars = self.get_setting(\"cadence.extra_env_vars\")  # type: List[Dict[str, Any]]\n        assert isinstance(list_of_vars, list)\n\n        cadence_vars = {\n            \"CDS_LIC_FILE\": self.get_setting(\"cadence.CDS_LIC_FILE\"),\n            \"CADENCE_HOME\": self.get_setting(\"cadence.cadence_home\")\n        }\n\n        return reduce(add_dicts, [dict(super().env_vars)] + list_of_vars + [cadence_vars], {})\n\n    <DED>def version_number(self, version: str) -> int:\n        <IND>\"\"\"\n        Assumes versions look like MAJOR_ISRMINOR and we will have less than 100 minor versions.\n        \"\"\"\n        main_version = int(version.split(\"_\")[0]) # type: int\n        minor_version = 0 # type: int\n        if \"_\" in version:\n            <IND>minor_version = int(version.split(\"_\")[1][3:])\n        <DED>return main_version * 100 + minor_version\n\n    <DED>def get_timing_libs(self, corner: Optional[MMMCCorner] = None) -> str:\n        <IND>\"\"\"\n        Helper function to get the list of ASCII timing .lib files in space separated format.\n        Note that Cadence tools support ECSM, so we can use the ECSM-based filter.\n\n        :param corner: Optional corner to consider. If supplied, this will use filter_for_mmmc to select libraries that\n        match a given corner (voltage/temperature).\n        :return: List of lib files separated by spaces\n        \"\"\"\n        pre_filters = optional_map(corner, lambda c: [self.filter_for_mmmc(voltage=c.voltage,\n                                                                           temp=c.temp)])  # type: Optional[List[Callable[[hammer_tech.Library],bool]]]\n\n        lib_args = self.technology.read_libs([hammer_tech.filters.timing_lib_with_ecsm_filter],\n                                             hammer_tech.HammerTechnologyUtils.to_plain_item,\n                                             extra_pre_filters=pre_filters)\n        return \" \".join(lib_args)\n\n    <DED>def get_mmmc_qrc(self, corner: MMMCCorner) -> str:\n        <IND>lib_args = self.technology.read_libs([hammer_tech.filters.qrc_tech_filter],\n                                             hammer_tech.HammerTechnologyUtils.to_plain_item,\n                                             extra_pre_filters=[\n                                                 self.filter_for_mmmc(voltage=corner.voltage, temp=corner.temp)])\n        return \" \".join(lib_args)\n\n    <DED>def get_qrc_tech(self) -> str:\n        <IND>\"\"\"\n        Helper function to get the list of rc corner tech files in space separated format.\n\n        :return: List of qrc tech files separated by spaces\n        \"\"\"\n        lib_args = self.technology.read_libs([\n            hammer_tech.filters.qrc_tech_filter\n        ], hammer_tech.HammerTechnologyUtils.to_plain_item)\n        return \" \".join(lib_args)\n\n    <DED>def generate_mmmc_script(self) -> str:\n        <IND>\"\"\"\n        Output for the mmmc.tcl script.\n        Innovus (init_design) requires that the timing script be placed in a separate file.\n\n        :return: Contents of the mmmc script.\n        \"\"\"\n        mmmc_output = []  # type: List[str]\n\n        def append_mmmc(cmd: str) -> None:\n            <IND>self.verbose_tcl_append(cmd, mmmc_output)\n\n        # Create an Innovus constraint mode.\n        <DED>constraint_mode = \"my_constraint_mode\"\n        sdc_files = []  # type: List[str]\n\n        # Generate constraints\n        clock_constraints_fragment = os.path.join(self.run_dir, \"clock_constraints_fragment.sdc\")\n        with open(clock_constraints_fragment, \"w\") as f:\n            <IND>f.write(self.sdc_clock_constraints)\n        <DED>sdc_files.append(clock_constraints_fragment)\n\n        # Generate port constraints.\n        pin_constraints_fragment = os.path.join(self.run_dir, \"pin_constraints_fragment.sdc\")\n        with open(pin_constraints_fragment, \"w\") as f:\n            <IND>f.write(self.sdc_pin_constraints)\n        <DED>sdc_files.append(pin_constraints_fragment)\n\n        # Add the post-synthesis SDC, if present.\n        post_synth_sdc = self.post_synth_sdc\n        if post_synth_sdc is not None:\n            <IND>sdc_files.append(post_synth_sdc)\n\n        # TODO: add floorplanning SDC\n        <DED>if len(sdc_files) > 0:\n            <IND>sdc_files_arg = \"-sdc_files [list {sdc_files}]\".format(\n                sdc_files=\" \".join(sdc_files)\n            )\n        <DED>else:\n            <IND>blank_sdc = os.path.join(self.run_dir, \"blank.sdc\")\n            self.run_executable([\"touch\", blank_sdc])\n            sdc_files_arg = \"-sdc_files {{ {} }}\".format(blank_sdc)\n        <DED>append_mmmc(\"create_constraint_mode -name {name} {sdc_files_arg}\".format(\n            name=constraint_mode,\n            sdc_files_arg=sdc_files_arg\n        ))\n\n        corners = self.get_mmmc_corners()  # type: List[MMMCCorner]\n        # In parallel, create the delay corners\n        if corners:\n            <IND>setup_corner = corners[0]  # type: MMMCCorner\n            hold_corner = corners[0]  # type: MMMCCorner\n            # TODO(colins): handle more than one corner and do something with extra corners\n            for corner in corners:\n                <IND>if corner.type is MMMCCornerType.Setup:\n                    <IND>setup_corner = corner\n                <DED>if corner.type is MMMCCornerType.Hold:\n                    <IND>hold_corner = corner\n\n            # First, create Innovus library sets\n            <DED><DED>append_mmmc(\"create_library_set -name {name} -timing [list {list}]\".format(\n                name=\"{n}.setup_set\".format(n=setup_corner.name),\n                list=self.get_timing_libs(setup_corner)\n            ))\n            append_mmmc(\"create_library_set -name {name} -timing [list {list}]\".format(\n                name=\"{n}.hold_set\".format(n=hold_corner.name),\n                list=self.get_timing_libs(hold_corner)\n            ))\n            # Skip opconds for now\n            # Next, create Innovus timing conditions\n            append_mmmc(\"create_timing_condition -name {name} -library_sets [list {list}]\".format(\n                name=\"{n}.setup_cond\".format(n=setup_corner.name),\n                list=\"{n}.setup_set\".format(n=setup_corner.name)\n            ))\n            append_mmmc(\"create_timing_condition -name {name} -library_sets [list {list}]\".format(\n                name=\"{n}.hold_cond\".format(n=hold_corner.name),\n                list=\"{n}.hold_set\".format(n=hold_corner.name)\n            ))\n            # Next, create Innovus rc corners from qrc tech files\n            append_mmmc(\"create_rc_corner -name {name} -temperature {tempInCelsius} {qrc}\".format(\n                name=\"{n}.setup_rc\".format(n=setup_corner.name),\n                tempInCelsius=str(setup_corner.temp.value),\n                qrc=\"-qrc_tech {}\".format(self.get_mmmc_qrc(setup_corner)) if self.get_mmmc_qrc(setup_corner) != '' else ''\n            ))\n            append_mmmc(\"create_rc_corner -name {name} -temperature {tempInCelsius} {qrc}\".format(\n                name=\"{n}.hold_rc\".format(n=hold_corner.name),\n                tempInCelsius=str(hold_corner.temp.value),\n                qrc=\"-qrc_tech {}\".format(self.get_mmmc_qrc(hold_corner)) if self.get_mmmc_qrc(hold_corner) != '' else ''\n            ))\n            # Next, create an Innovus delay corner.\n            append_mmmc(\n                \"create_delay_corner -name {name}_delay -timing_condition {name}_cond -rc_corner {name}_rc\".format(\n                    name=\"{n}.setup\".format(n=setup_corner.name)\n                ))\n            append_mmmc(\n                \"create_delay_corner -name {name}_delay -timing_condition {name}_cond -rc_corner {name}_rc\".format(\n                    name=\"{n}.hold\".format(n=hold_corner.name)\n                ))\n            # Next, create the analysis views\n            append_mmmc(\"create_analysis_view -name {name}_view -delay_corner {name}_delay -constraint_mode {constraint}\".format(\n                name=\"{n}.setup\".format(n=setup_corner.name), constraint=constraint_mode))\n            append_mmmc(\"create_analysis_view -name {name}_view -delay_corner {name}_delay -constraint_mode {constraint}\".format(\n                name=\"{n}.hold\".format(n=hold_corner.name), constraint=constraint_mode))\n            # Finally, apply the analysis view.\n            append_mmmc(\"set_analysis_view -setup {{ {setup_view} }} -hold {{ {hold_view} }}\".format(\n                setup_view=\"{n}.setup_view\".format(n=setup_corner.name),\n                hold_view=\"{n}.hold_view\".format(n=hold_corner.name)\n            ))\n        <DED>else:\n            # First, create an Innovus library set.\n            <IND>library_set_name = \"my_lib_set\"\n            append_mmmc(\"create_library_set -name {name} -timing [list {list}]\".format(\n                name=library_set_name,\n                list=self.get_timing_libs()\n            ))\n            # Next, create an Innovus timing condition.\n            timing_condition_name = \"my_timing_condition\"\n            append_mmmc(\"create_timing_condition -name {name} -library_sets [list {list}]\".format(\n                name=timing_condition_name,\n                list=library_set_name\n            ))\n            # extra junk: -opcond ...\n            rc_corner_name = \"rc_cond\"\n            append_mmmc(\"create_rc_corner -name {name} -temperature {tempInCelsius} {qrc}\".format(\n                name=rc_corner_name,\n                tempInCelsius=120,  # TODO: this should come from tech config\n                qrc=\"-qrc_tech {}\".format(self.get_qrc_tech()) if self.get_qrc_tech() != '' else ''\n            ))\n            # Next, create an Innovus delay corner.\n            delay_corner_name = \"my_delay_corner\"\n            append_mmmc(\n                \"create_delay_corner -name {name} -timing_condition {timing_cond} -rc_corner {rc}\".format(\n                    name=delay_corner_name,\n                    timing_cond=timing_condition_name,\n                    rc=rc_corner_name\n                ))\n            # extra junk: -rc_corner my_rc_corner_maybe_worst\n            # Next, create an Innovus analysis view.\n            analysis_view_name = \"my_view\"\n            append_mmmc(\"create_analysis_view -name {name} -delay_corner {corner} -constraint_mode {constraint}\".format(\n                name=analysis_view_name, corner=delay_corner_name, constraint=constraint_mode))\n            # Finally, apply the analysis view.\n            # TODO: introduce different views of setup/hold and true multi-corner\n            append_mmmc(\"set_analysis_view -setup {{ {setup_view} }} -hold {{ {hold_view} }}\".format(\n                setup_view=analysis_view_name,\n                hold_view=analysis_view_name\n            ))\n\n        <DED>return \"\\n\".join(mmmc_output)\n\n    <DED>def generate_dont_use_commands(self) -> List[str]:\n        <IND>\"\"\"\n        Generate a list of dont_use commands for Cadence tools.\n        \"\"\"\n\n        def map_cell(in_cell: str) -> str:\n            # \"*/\" is needed for \"get_db lib_cells <cell_expression>\"\n            <IND>if in_cell.startswith(\"*/\"):\n                <IND>mapped_cell = in_cell  # type: str\n            <DED>else:\n                <IND>mapped_cell = \"*/\" + in_cell\n\n            # Check for cell existence first to avoid Genus erroring out.\n            <DED>get_db_str = \"[get_db lib_cells {mapped_cell}]\".format(mapped_cell=mapped_cell)\n            # Escaped version for puts.\n            get_db_str_escaped = get_db_str.replace('[', '\\[').replace(']', '\\]')\n            return \"\"\"\nputs \"set_dont_use {get_db_str_escaped}\"\nif {{ {get_db_str} ne \"\" }} {{\n    set_dont_use {get_db_str}\n}} else {{\n    puts \"WARNING: cell {mapped_cell} was not found for set_dont_use\"\n}}\n            \"\"\".format(get_db_str=get_db_str, get_db_str_escaped=get_db_str_escaped, mapped_cell=mapped_cell)\n\n        <DED>return list(map(map_cell, self.get_dont_use_list()))\n\n    <DED>def generate_power_spec_commands(self) -> List[str]:\n        <IND>\"\"\"\n        Generate commands to load a power specification for Cadence tools.\n        \"\"\"\n\n        power_spec_type = str(self.get_setting(\"vlsi.inputs.power_spec_type\"))  # type: str\n        power_spec_arg = \"\"  # type: str\n        if power_spec_type == \"cpf\":\n            <IND>power_spec_arg = \"cpf\"\n        <DED>elif power_spec_type == \"upf\":\n            <IND>power_spec_arg = \"1801\"\n        <DED>else:\n            <IND>self.logger.error(\n                \"Invalid power specification type '{tpe}'; only 'cpf' or 'upf' supported\".format(tpe=power_spec_type))\n            return []\n\n        <DED>power_spec_contents = \"\"  # type: str\n        power_spec_mode = str(self.get_setting(\"vlsi.inputs.power_spec_mode\"))  # type: str\n        if power_spec_mode == \"empty\":\n            <IND>return []\n        <DED>elif power_spec_mode == \"auto\":\n            <IND>if power_spec_type == \"cpf\":\n                <IND>power_spec_contents = self.cpf_power_specification\n            <DED>elif power_spec_type == \"upf\":\n                <IND>power_spec_contents = self.upf_power_specification\n        <DED><DED>elif power_spec_mode == \"manual\":\n            <IND>power_spec_contents = str(self.get_setting(\"vlsi.inputs.power_spec_contents\"))\n        <DED>else:\n            <IND>self.logger.error(\"Invalid power specification mode '{mode}'; using 'empty'.\".format(mode=power_spec_mode))\n            return []\n\n        # Write the power spec contents to file and include it\n        <DED>power_spec_file = os.path.join(self.run_dir, \"power_spec.{tpe}\".format(tpe=power_spec_type))\n        with open(power_spec_file, \"w\") as f:\n            <IND>f.write(power_spec_contents)\n        <DED>return [\"read_power_intent -{arg} {path}\".format(arg=power_spec_arg, path=power_spec_file),\n                \"commit_power_intent\"]\n\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "        <IND>self.tcl_append(cmd, self.output, clean)\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "ucb-bar/hammer",
    "commit": "3afca0f00301e87b3112d42284a6acfd3c083c42",
    "filename": "src/hammer-vlsi/hammer_vlsi/hammer_vlsi_impl.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/ucb-bar-hammer/src/hammer-vlsi/hammer_vlsi/hammer_vlsi_impl.py",
    "file_hunks_size": 13,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": true,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "src/hammer-vlsi/hammer_vlsi/hammer_vlsi_impl.py:1630:46 Invalid type [31]: Expression `src.hammer.__sub__(vlsi.hammer_vlsi.constraints.MMMCCorner)` is not a valid type.",
    "message": " Expression `src.hammer.__sub__(vlsi.hammer_vlsi.constraints.MMMCCorner)` is not a valid type.",
    "rule_id": "Invalid type [31]",
    "warning_line_no": 1630,
    "warning_line": "            hold_corner = corners[0]  # type: MMMCCorner",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": true,
        "has_suppression": false,
        "source_code": "        self.tcl_append(cmd, self.output, clean)\n\n\nclass CadenceTool(HasSDCSupport, HasCPFSupport, HasUPFSupport, TCLTool, HammerTool):\n    \"\"\"Mix-in trait with functions useful for Cadence-based tools.\"\"\"\n\n    @property\n    def config_dirs(self) -> List[str]:\n        # Override this to pull in Cadence-common configs.\n        return [self.get_setting(\"cadence.common_path\")] + super().config_dirs\n\n    @property\n    def env_vars(self) -> Dict[str, str]:\n        \"\"\"\n        Get the list of environment variables required for this tool.\n        Note to subclasses: remember to include variables from super().env_vars!\n        \"\"\"\n        # Use the base extra_env_variables and ensure that our custom variables are on top.\n        list_of_vars = self.get_setting(\"cadence.extra_env_vars\")  # type: List[Dict[str, Any]]\n        assert isinstance(list_of_vars, list)\n\n        cadence_vars = {\n            \"CDS_LIC_FILE\": self.get_setting(\"cadence.CDS_LIC_FILE\"),\n            \"CADENCE_HOME\": self.get_setting(\"cadence.cadence_home\")\n        }\n\n        return reduce(add_dicts, [dict(super().env_vars)] + list_of_vars + [cadence_vars], {})\n\n    def version_number(self, version: str) -> int:\n        \"\"\"\n        Assumes versions look like MAJOR_ISRMINOR and we will have less than 100 minor versions.\n        \"\"\"\n        main_version = int(version.split(\"_\")[0]) # type: int\n        minor_version = 0 # type: int\n        if \"_\" in version:\n            minor_version = int(version.split(\"_\")[1][3:])\n        return main_version * 100 + minor_version\n\n    def get_timing_libs(self, corner: Optional[MMMCCorner] = None) -> str:\n        \"\"\"\n        Helper function to get the list of ASCII timing .lib files in space separated format.\n        Note that Cadence tools support ECSM, so we can use the ECSM-based filter.\n\n        :param corner: Optional corner to consider. If supplied, this will use filter_for_mmmc to select libraries that\n        match a given corner (voltage/temperature).\n        :return: List of lib files separated by spaces\n        \"\"\"\n        pre_filters = optional_map(corner, lambda c: [self.filter_for_mmmc(voltage=c.voltage,\n                                                                           temp=c.temp)])  # type: Optional[List[Callable[[hammer_tech.Library],bool]]]\n\n        lib_args = self.technology.read_libs([hammer_tech.filters.timing_lib_with_ecsm_filter],\n                                             hammer_tech.HammerTechnologyUtils.to_plain_item,\n                                             extra_pre_filters=pre_filters)\n        return \" \".join(lib_args)\n\n    def get_mmmc_qrc(self, corner: MMMCCorner) -> str:\n        lib_args = self.technology.read_libs([hammer_tech.filters.qrc_tech_filter],\n                                             hammer_tech.HammerTechnologyUtils.to_plain_item,\n                                             extra_pre_filters=[\n                                                 self.filter_for_mmmc(voltage=corner.voltage, temp=corner.temp)])\n        return \" \".join(lib_args)\n\n    def get_qrc_tech(self) -> str:\n        \"\"\"\n        Helper function to get the list of rc corner tech files in space separated format.\n\n        :return: List of qrc tech files separated by spaces\n        \"\"\"\n        lib_args = self.technology.read_libs([\n            hammer_tech.filters.qrc_tech_filter\n        ], hammer_tech.HammerTechnologyUtils.to_plain_item)\n        return \" \".join(lib_args)\n\n    def generate_mmmc_script(self) -> str:\n        \"\"\"\n        Output for the mmmc.tcl script.\n        Innovus (init_design) requires that the timing script be placed in a separate file.\n\n        :return: Contents of the mmmc script.\n        \"\"\"\n        mmmc_output = []  # type: List[str]\n\n        def append_mmmc(cmd: str) -> None:\n            self.verbose_tcl_append(cmd, mmmc_output)\n\n        # Create an Innovus constraint mode.\n        constraint_mode = \"my_constraint_mode\"\n        sdc_files = []  # type: List[str]\n\n        # Generate constraints\n        clock_constraints_fragment = os.path.join(self.run_dir, \"clock_constraints_fragment.sdc\")\n        with open(clock_constraints_fragment, \"w\") as f:\n            f.write(self.sdc_clock_constraints)\n        sdc_files.append(clock_constraints_fragment)\n\n        # Generate port constraints.\n        pin_constraints_fragment = os.path.join(self.run_dir, \"pin_constraints_fragment.sdc\")\n        with open(pin_constraints_fragment, \"w\") as f:\n            f.write(self.sdc_pin_constraints)\n        sdc_files.append(pin_constraints_fragment)\n\n        # Add the post-synthesis SDC, if present.\n        post_synth_sdc = self.post_synth_sdc\n        if post_synth_sdc is not None:\n            sdc_files.append(post_synth_sdc)\n\n        # TODO: add floorplanning SDC\n        if len(sdc_files) > 0:\n            sdc_files_arg = \"-sdc_files [list {sdc_files}]\".format(\n                sdc_files=\" \".join(sdc_files)\n            )\n        else:\n            blank_sdc = os.path.join(self.run_dir, \"blank.sdc\")\n            self.run_executable([\"touch\", blank_sdc])\n            sdc_files_arg = \"-sdc_files {{ {} }}\".format(blank_sdc)\n        append_mmmc(\"create_constraint_mode -name {name} {sdc_files_arg}\".format(\n            name=constraint_mode,\n            sdc_files_arg=sdc_files_arg\n        ))\n\n        corners = self.get_mmmc_corners()  # type: List[MMMCCorner]\n        # In parallel, create the delay corners\n        if corners:\n            setup_corner = corners[0]  # type: MMMCCorner\n            hold_corner = corners[0]  # type: MMMCCorner\n            # TODO(colins): handle more than one corner and do something with extra corners\n            for corner in corners:\n                if corner.type is MMMCCornerType.Setup:\n                    setup_corner = corner\n                if corner.type is MMMCCornerType.Hold:\n                    hold_corner = corner\n\n            # First, create Innovus library sets\n            append_mmmc(\"create_library_set -name {name} -timing [list {list}]\".format(\n                name=\"{n}.setup_set\".format(n=setup_corner.name),\n                list=self.get_timing_libs(setup_corner)\n            ))\n            append_mmmc(\"create_library_set -name {name} -timing [list {list}]\".format(\n                name=\"{n}.hold_set\".format(n=hold_corner.name),\n                list=self.get_timing_libs(hold_corner)\n            ))\n            # Skip opconds for now\n            # Next, create Innovus timing conditions\n            append_mmmc(\"create_timing_condition -name {name} -library_sets [list {list}]\".format(\n                name=\"{n}.setup_cond\".format(n=setup_corner.name),\n                list=\"{n}.setup_set\".format(n=setup_corner.name)\n            ))\n            append_mmmc(\"create_timing_condition -name {name} -library_sets [list {list}]\".format(\n                name=\"{n}.hold_cond\".format(n=hold_corner.name),\n                list=\"{n}.hold_set\".format(n=hold_corner.name)\n            ))\n            # Next, create Innovus rc corners from qrc tech files\n            append_mmmc(\"create_rc_corner -name {name} -temperature {tempInCelsius} {qrc}\".format(\n                name=\"{n}.setup_rc\".format(n=setup_corner.name),\n                tempInCelsius=str(setup_corner.temp.value),\n                qrc=\"-qrc_tech {}\".format(self.get_mmmc_qrc(setup_corner)) if self.get_mmmc_qrc(setup_corner) != '' else ''\n            ))\n            append_mmmc(\"create_rc_corner -name {name} -temperature {tempInCelsius} {qrc}\".format(\n                name=\"{n}.hold_rc\".format(n=hold_corner.name),\n                tempInCelsius=str(hold_corner.temp.value),\n                qrc=\"-qrc_tech {}\".format(self.get_mmmc_qrc(hold_corner)) if self.get_mmmc_qrc(hold_corner) != '' else ''\n            ))\n            # Next, create an Innovus delay corner.\n            append_mmmc(\n                \"create_delay_corner -name {name}_delay -timing_condition {name}_cond -rc_corner {name}_rc\".format(\n                    name=\"{n}.setup\".format(n=setup_corner.name)\n                ))\n            append_mmmc(\n                \"create_delay_corner -name {name}_delay -timing_condition {name}_cond -rc_corner {name}_rc\".format(\n                    name=\"{n}.hold\".format(n=hold_corner.name)\n                ))\n            # Next, create the analysis views\n            append_mmmc(\"create_analysis_view -name {name}_view -delay_corner {name}_delay -constraint_mode {constraint}\".format(\n                name=\"{n}.setup\".format(n=setup_corner.name), constraint=constraint_mode))\n            append_mmmc(\"create_analysis_view -name {name}_view -delay_corner {name}_delay -constraint_mode {constraint}\".format(\n                name=\"{n}.hold\".format(n=hold_corner.name), constraint=constraint_mode))\n            # Finally, apply the analysis view.\n            append_mmmc(\"set_analysis_view -setup {{ {setup_view} }} -hold {{ {hold_view} }}\".format(\n                setup_view=\"{n}.setup_view\".format(n=setup_corner.name),\n                hold_view=\"{n}.hold_view\".format(n=hold_corner.name)\n            ))\n        else:\n            # First, create an Innovus library set.\n            library_set_name = \"my_lib_set\"\n            append_mmmc(\"create_library_set -name {name} -timing [list {list}]\".format(\n                name=library_set_name,\n                list=self.get_timing_libs()\n            ))\n            # Next, create an Innovus timing condition.\n            timing_condition_name = \"my_timing_condition\"\n            append_mmmc(\"create_timing_condition -name {name} -library_sets [list {list}]\".format(\n                name=timing_condition_name,\n                list=library_set_name\n            ))\n            # extra junk: -opcond ...\n            rc_corner_name = \"rc_cond\"\n            append_mmmc(\"create_rc_corner -name {name} -temperature {tempInCelsius} {qrc}\".format(\n                name=rc_corner_name,\n                tempInCelsius=120,  # TODO: this should come from tech config\n                qrc=\"-qrc_tech {}\".format(self.get_qrc_tech()) if self.get_qrc_tech() != '' else ''\n            ))\n            # Next, create an Innovus delay corner.\n            delay_corner_name = \"my_delay_corner\"\n            append_mmmc(\n                \"create_delay_corner -name {name} -timing_condition {timing_cond} -rc_corner {rc}\".format(\n                    name=delay_corner_name,\n                    timing_cond=timing_condition_name,\n                    rc=rc_corner_name\n                ))\n            # extra junk: -rc_corner my_rc_corner_maybe_worst\n            # Next, create an Innovus analysis view.\n            analysis_view_name = \"my_view\"\n            append_mmmc(\"create_analysis_view -name {name} -delay_corner {corner} -constraint_mode {constraint}\".format(\n                name=analysis_view_name, corner=delay_corner_name, constraint=constraint_mode))\n            # Finally, apply the analysis view.\n            # TODO: introduce different views of setup/hold and true multi-corner\n            append_mmmc(\"set_analysis_view -setup {{ {setup_view} }} -hold {{ {hold_view} }}\".format(\n                setup_view=analysis_view_name,\n                hold_view=analysis_view_name\n            ))\n\n        return \"\\n\".join(mmmc_output)\n\n    def generate_dont_use_commands(self) -> List[str]:\n        \"\"\"\n        Generate a list of dont_use commands for Cadence tools.\n        \"\"\"\n\n        def map_cell(in_cell: str) -> str:\n            # \"*/\" is needed for \"get_db lib_cells <cell_expression>\"\n            if in_cell.startswith(\"*/\"):\n                mapped_cell = in_cell  # type: str\n            else:\n                mapped_cell = \"*/\" + in_cell\n\n            # Check for cell existence first to avoid Genus erroring out.\n            get_db_str = \"[get_db lib_cells {mapped_cell}]\".format(mapped_cell=mapped_cell)\n            # Escaped version for puts.\n            get_db_str_escaped = get_db_str.replace('[', '\\[').replace(']', '\\]')\n            return \"\"\"\nputs \"set_dont_use {get_db_str_escaped}\"\nif {{ {get_db_str} ne \"\" }} {{\n    set_dont_use {get_db_str}\n}} else {{\n    puts \"WARNING: cell {mapped_cell} was not found for set_dont_use\"\n}}\n            \"\"\".format(get_db_str=get_db_str, get_db_str_escaped=get_db_str_escaped, mapped_cell=mapped_cell)\n\n        return list(map(map_cell, self.get_dont_use_list()))\n\n    def generate_power_spec_commands(self) -> List[str]:\n        \"\"\"\n        Generate commands to load a power specification for Cadence tools.\n        \"\"\"\n\n        power_spec_type = str(self.get_setting(\"vlsi.inputs.power_spec_type\"))  # type: str\n        power_spec_arg = \"\"  # type: str\n        if power_spec_type == \"cpf\":\n            power_spec_arg = \"cpf\"\n        elif power_spec_type == \"upf\":\n            power_spec_arg = \"1801\"\n        else:\n            self.logger.error(\n                \"Invalid power specification type '{tpe}'; only 'cpf' or 'upf' supported\".format(tpe=power_spec_type))\n            return []\n\n        power_spec_contents = \"\"  # type: str\n        power_spec_mode = str(self.get_setting(\"vlsi.inputs.power_spec_mode\"))  # type: str\n        if power_spec_mode == \"empty\":\n            return []\n        elif power_spec_mode == \"auto\":\n            if power_spec_type == \"cpf\":\n                power_spec_contents = self.cpf_power_specification\n            elif power_spec_type == \"upf\":\n                power_spec_contents = self.upf_power_specification\n        elif power_spec_mode == \"manual\":\n            power_spec_contents = str(self.get_setting(\"vlsi.inputs.power_spec_contents\"))\n        else:\n            self.logger.error(\"Invalid power specification mode '{mode}'; using 'empty'.\".format(mode=power_spec_mode))\n            return []\n\n        # Write the power spec contents to file and include it\n        power_spec_file = os.path.join(self.run_dir, \"power_spec.{tpe}\".format(tpe=power_spec_type))\n        with open(power_spec_file, \"w\") as f:\n            f.write(power_spec_contents)\n        return [\"read_power_intent -{arg} {path}\".format(arg=power_spec_arg, path=power_spec_file),\n                \"commit_power_intent\"]\n\n\n",
        "source_code_len": 14014,
        "target_code": "        self.tcl_append(cmd, self.output, clean)\n\n",
        "target_code_len": 50,
        "diff_format": "@@ -1506,289 +1506,2 @@\n         self.tcl_append(cmd, self.output, clean)\n-\n-\n-class CadenceTool(HasSDCSupport, HasCPFSupport, HasUPFSupport, TCLTool, HammerTool):\n-    \"\"\"Mix-in trait with functions useful for Cadence-based tools.\"\"\"\n-\n-    @property\n-    def config_dirs(self) -> List[str]:\n-        # Override this to pull in Cadence-common configs.\n-        return [self.get_setting(\"cadence.common_path\")] + super().config_dirs\n-\n-    @property\n-    def env_vars(self) -> Dict[str, str]:\n-        \"\"\"\n-        Get the list of environment variables required for this tool.\n-        Note to subclasses: remember to include variables from super().env_vars!\n-        \"\"\"\n-        # Use the base extra_env_variables and ensure that our custom variables are on top.\n-        list_of_vars = self.get_setting(\"cadence.extra_env_vars\")  # type: List[Dict[str, Any]]\n-        assert isinstance(list_of_vars, list)\n-\n-        cadence_vars = {\n-            \"CDS_LIC_FILE\": self.get_setting(\"cadence.CDS_LIC_FILE\"),\n-            \"CADENCE_HOME\": self.get_setting(\"cadence.cadence_home\")\n-        }\n-\n-        return reduce(add_dicts, [dict(super().env_vars)] + list_of_vars + [cadence_vars], {})\n-\n-    def version_number(self, version: str) -> int:\n-        \"\"\"\n-        Assumes versions look like MAJOR_ISRMINOR and we will have less than 100 minor versions.\n-        \"\"\"\n-        main_version = int(version.split(\"_\")[0]) # type: int\n-        minor_version = 0 # type: int\n-        if \"_\" in version:\n-            minor_version = int(version.split(\"_\")[1][3:])\n-        return main_version * 100 + minor_version\n-\n-    def get_timing_libs(self, corner: Optional[MMMCCorner] = None) -> str:\n-        \"\"\"\n-        Helper function to get the list of ASCII timing .lib files in space separated format.\n-        Note that Cadence tools support ECSM, so we can use the ECSM-based filter.\n-\n-        :param corner: Optional corner to consider. If supplied, this will use filter_for_mmmc to select libraries that\n-        match a given corner (voltage/temperature).\n-        :return: List of lib files separated by spaces\n-        \"\"\"\n-        pre_filters = optional_map(corner, lambda c: [self.filter_for_mmmc(voltage=c.voltage,\n-                                                                           temp=c.temp)])  # type: Optional[List[Callable[[hammer_tech.Library],bool]]]\n-\n-        lib_args = self.technology.read_libs([hammer_tech.filters.timing_lib_with_ecsm_filter],\n-                                             hammer_tech.HammerTechnologyUtils.to_plain_item,\n-                                             extra_pre_filters=pre_filters)\n-        return \" \".join(lib_args)\n-\n-    def get_mmmc_qrc(self, corner: MMMCCorner) -> str:\n-        lib_args = self.technology.read_libs([hammer_tech.filters.qrc_tech_filter],\n-                                             hammer_tech.HammerTechnologyUtils.to_plain_item,\n-                                             extra_pre_filters=[\n-                                                 self.filter_for_mmmc(voltage=corner.voltage, temp=corner.temp)])\n-        return \" \".join(lib_args)\n-\n-    def get_qrc_tech(self) -> str:\n-        \"\"\"\n-        Helper function to get the list of rc corner tech files in space separated format.\n-\n-        :return: List of qrc tech files separated by spaces\n-        \"\"\"\n-        lib_args = self.technology.read_libs([\n-            hammer_tech.filters.qrc_tech_filter\n-        ], hammer_tech.HammerTechnologyUtils.to_plain_item)\n-        return \" \".join(lib_args)\n-\n-    def generate_mmmc_script(self) -> str:\n-        \"\"\"\n-        Output for the mmmc.tcl script.\n-        Innovus (init_design) requires that the timing script be placed in a separate file.\n-\n-        :return: Contents of the mmmc script.\n-        \"\"\"\n-        mmmc_output = []  # type: List[str]\n-\n-        def append_mmmc(cmd: str) -> None:\n-            self.verbose_tcl_append(cmd, mmmc_output)\n-\n-        # Create an Innovus constraint mode.\n-        constraint_mode = \"my_constraint_mode\"\n-        sdc_files = []  # type: List[str]\n-\n-        # Generate constraints\n-        clock_constraints_fragment = os.path.join(self.run_dir, \"clock_constraints_fragment.sdc\")\n-        with open(clock_constraints_fragment, \"w\") as f:\n-            f.write(self.sdc_clock_constraints)\n-        sdc_files.append(clock_constraints_fragment)\n-\n-        # Generate port constraints.\n-        pin_constraints_fragment = os.path.join(self.run_dir, \"pin_constraints_fragment.sdc\")\n-        with open(pin_constraints_fragment, \"w\") as f:\n-            f.write(self.sdc_pin_constraints)\n-        sdc_files.append(pin_constraints_fragment)\n-\n-        # Add the post-synthesis SDC, if present.\n-        post_synth_sdc = self.post_synth_sdc\n-        if post_synth_sdc is not None:\n-            sdc_files.append(post_synth_sdc)\n-\n-        # TODO: add floorplanning SDC\n-        if len(sdc_files) > 0:\n-            sdc_files_arg = \"-sdc_files [list {sdc_files}]\".format(\n-                sdc_files=\" \".join(sdc_files)\n-            )\n-        else:\n-            blank_sdc = os.path.join(self.run_dir, \"blank.sdc\")\n-            self.run_executable([\"touch\", blank_sdc])\n-            sdc_files_arg = \"-sdc_files {{ {} }}\".format(blank_sdc)\n-        append_mmmc(\"create_constraint_mode -name {name} {sdc_files_arg}\".format(\n-            name=constraint_mode,\n-            sdc_files_arg=sdc_files_arg\n-        ))\n-\n-        corners = self.get_mmmc_corners()  # type: List[MMMCCorner]\n-        # In parallel, create the delay corners\n-        if corners:\n-            setup_corner = corners[0]  # type: MMMCCorner\n-            hold_corner = corners[0]  # type: MMMCCorner\n-            # TODO(colins): handle more than one corner and do something with extra corners\n-            for corner in corners:\n-                if corner.type is MMMCCornerType.Setup:\n-                    setup_corner = corner\n-                if corner.type is MMMCCornerType.Hold:\n-                    hold_corner = corner\n-\n-            # First, create Innovus library sets\n-            append_mmmc(\"create_library_set -name {name} -timing [list {list}]\".format(\n-                name=\"{n}.setup_set\".format(n=setup_corner.name),\n-                list=self.get_timing_libs(setup_corner)\n-            ))\n-            append_mmmc(\"create_library_set -name {name} -timing [list {list}]\".format(\n-                name=\"{n}.hold_set\".format(n=hold_corner.name),\n-                list=self.get_timing_libs(hold_corner)\n-            ))\n-            # Skip opconds for now\n-            # Next, create Innovus timing conditions\n-            append_mmmc(\"create_timing_condition -name {name} -library_sets [list {list}]\".format(\n-                name=\"{n}.setup_cond\".format(n=setup_corner.name),\n-                list=\"{n}.setup_set\".format(n=setup_corner.name)\n-            ))\n-            append_mmmc(\"create_timing_condition -name {name} -library_sets [list {list}]\".format(\n-                name=\"{n}.hold_cond\".format(n=hold_corner.name),\n-                list=\"{n}.hold_set\".format(n=hold_corner.name)\n-            ))\n-            # Next, create Innovus rc corners from qrc tech files\n-            append_mmmc(\"create_rc_corner -name {name} -temperature {tempInCelsius} {qrc}\".format(\n-                name=\"{n}.setup_rc\".format(n=setup_corner.name),\n-                tempInCelsius=str(setup_corner.temp.value),\n-                qrc=\"-qrc_tech {}\".format(self.get_mmmc_qrc(setup_corner)) if self.get_mmmc_qrc(setup_corner) != '' else ''\n-            ))\n-            append_mmmc(\"create_rc_corner -name {name} -temperature {tempInCelsius} {qrc}\".format(\n-                name=\"{n}.hold_rc\".format(n=hold_corner.name),\n-                tempInCelsius=str(hold_corner.temp.value),\n-                qrc=\"-qrc_tech {}\".format(self.get_mmmc_qrc(hold_corner)) if self.get_mmmc_qrc(hold_corner) != '' else ''\n-            ))\n-            # Next, create an Innovus delay corner.\n-            append_mmmc(\n-                \"create_delay_corner -name {name}_delay -timing_condition {name}_cond -rc_corner {name}_rc\".format(\n-                    name=\"{n}.setup\".format(n=setup_corner.name)\n-                ))\n-            append_mmmc(\n-                \"create_delay_corner -name {name}_delay -timing_condition {name}_cond -rc_corner {name}_rc\".format(\n-                    name=\"{n}.hold\".format(n=hold_corner.name)\n-                ))\n-            # Next, create the analysis views\n-            append_mmmc(\"create_analysis_view -name {name}_view -delay_corner {name}_delay -constraint_mode {constraint}\".format(\n-                name=\"{n}.setup\".format(n=setup_corner.name), constraint=constraint_mode))\n-            append_mmmc(\"create_analysis_view -name {name}_view -delay_corner {name}_delay -constraint_mode {constraint}\".format(\n-                name=\"{n}.hold\".format(n=hold_corner.name), constraint=constraint_mode))\n-            # Finally, apply the analysis view.\n-            append_mmmc(\"set_analysis_view -setup {{ {setup_view} }} -hold {{ {hold_view} }}\".format(\n-                setup_view=\"{n}.setup_view\".format(n=setup_corner.name),\n-                hold_view=\"{n}.hold_view\".format(n=hold_corner.name)\n-            ))\n-        else:\n-            # First, create an Innovus library set.\n-            library_set_name = \"my_lib_set\"\n-            append_mmmc(\"create_library_set -name {name} -timing [list {list}]\".format(\n-                name=library_set_name,\n-                list=self.get_timing_libs()\n-            ))\n-            # Next, create an Innovus timing condition.\n-            timing_condition_name = \"my_timing_condition\"\n-            append_mmmc(\"create_timing_condition -name {name} -library_sets [list {list}]\".format(\n-                name=timing_condition_name,\n-                list=library_set_name\n-            ))\n-            # extra junk: -opcond ...\n-            rc_corner_name = \"rc_cond\"\n-            append_mmmc(\"create_rc_corner -name {name} -temperature {tempInCelsius} {qrc}\".format(\n-                name=rc_corner_name,\n-                tempInCelsius=120,  # TODO: this should come from tech config\n-                qrc=\"-qrc_tech {}\".format(self.get_qrc_tech()) if self.get_qrc_tech() != '' else ''\n-            ))\n-            # Next, create an Innovus delay corner.\n-            delay_corner_name = \"my_delay_corner\"\n-            append_mmmc(\n-                \"create_delay_corner -name {name} -timing_condition {timing_cond} -rc_corner {rc}\".format(\n-                    name=delay_corner_name,\n-                    timing_cond=timing_condition_name,\n-                    rc=rc_corner_name\n-                ))\n-            # extra junk: -rc_corner my_rc_corner_maybe_worst\n-            # Next, create an Innovus analysis view.\n-            analysis_view_name = \"my_view\"\n-            append_mmmc(\"create_analysis_view -name {name} -delay_corner {corner} -constraint_mode {constraint}\".format(\n-                name=analysis_view_name, corner=delay_corner_name, constraint=constraint_mode))\n-            # Finally, apply the analysis view.\n-            # TODO: introduce different views of setup/hold and true multi-corner\n-            append_mmmc(\"set_analysis_view -setup {{ {setup_view} }} -hold {{ {hold_view} }}\".format(\n-                setup_view=analysis_view_name,\n-                hold_view=analysis_view_name\n-            ))\n-\n-        return \"\\n\".join(mmmc_output)\n-\n-    def generate_dont_use_commands(self) -> List[str]:\n-        \"\"\"\n-        Generate a list of dont_use commands for Cadence tools.\n-        \"\"\"\n-\n-        def map_cell(in_cell: str) -> str:\n-            # \"*/\" is needed for \"get_db lib_cells <cell_expression>\"\n-            if in_cell.startswith(\"*/\"):\n-                mapped_cell = in_cell  # type: str\n-            else:\n-                mapped_cell = \"*/\" + in_cell\n-\n-            # Check for cell existence first to avoid Genus erroring out.\n-            get_db_str = \"[get_db lib_cells {mapped_cell}]\".format(mapped_cell=mapped_cell)\n-            # Escaped version for puts.\n-            get_db_str_escaped = get_db_str.replace('[', '\\[').replace(']', '\\]')\n-            return \"\"\"\n-puts \"set_dont_use {get_db_str_escaped}\"\n-if {{ {get_db_str} ne \"\" }} {{\n-    set_dont_use {get_db_str}\n-}} else {{\n-    puts \"WARNING: cell {mapped_cell} was not found for set_dont_use\"\n-}}\n-            \"\"\".format(get_db_str=get_db_str, get_db_str_escaped=get_db_str_escaped, mapped_cell=mapped_cell)\n-\n-        return list(map(map_cell, self.get_dont_use_list()))\n-\n-    def generate_power_spec_commands(self) -> List[str]:\n-        \"\"\"\n-        Generate commands to load a power specification for Cadence tools.\n-        \"\"\"\n-\n-        power_spec_type = str(self.get_setting(\"vlsi.inputs.power_spec_type\"))  # type: str\n-        power_spec_arg = \"\"  # type: str\n-        if power_spec_type == \"cpf\":\n-            power_spec_arg = \"cpf\"\n-        elif power_spec_type == \"upf\":\n-            power_spec_arg = \"1801\"\n-        else:\n-            self.logger.error(\n-                \"Invalid power specification type '{tpe}'; only 'cpf' or 'upf' supported\".format(tpe=power_spec_type))\n-            return []\n-\n-        power_spec_contents = \"\"  # type: str\n-        power_spec_mode = str(self.get_setting(\"vlsi.inputs.power_spec_mode\"))  # type: str\n-        if power_spec_mode == \"empty\":\n-            return []\n-        elif power_spec_mode == \"auto\":\n-            if power_spec_type == \"cpf\":\n-                power_spec_contents = self.cpf_power_specification\n-            elif power_spec_type == \"upf\":\n-                power_spec_contents = self.upf_power_specification\n-        elif power_spec_mode == \"manual\":\n-            power_spec_contents = str(self.get_setting(\"vlsi.inputs.power_spec_contents\"))\n-        else:\n-            self.logger.error(\"Invalid power specification mode '{mode}'; using 'empty'.\".format(mode=power_spec_mode))\n-            return []\n-\n-        # Write the power spec contents to file and include it\n-        power_spec_file = os.path.join(self.run_dir, \"power_spec.{tpe}\".format(tpe=power_spec_type))\n-        with open(power_spec_file, \"w\") as f:\n-            f.write(power_spec_contents)\n-        return [\"read_power_intent -{arg} {path}\".format(arg=power_spec_arg, path=power_spec_file),\n-                \"commit_power_intent\"]\n-\n \n",
        "source_code_with_indent": "        <IND>self.tcl_append(cmd, self.output, clean)\n\n\n<DED><DED>class CadenceTool(HasSDCSupport, HasCPFSupport, HasUPFSupport, TCLTool, HammerTool):\n    <IND>\"\"\"Mix-in trait with functions useful for Cadence-based tools.\"\"\"\n\n    @property\n    def config_dirs(self) -> List[str]:\n        # Override this to pull in Cadence-common configs.\n        <IND>return [self.get_setting(\"cadence.common_path\")] + super().config_dirs\n\n    <DED>@property\n    def env_vars(self) -> Dict[str, str]:\n        <IND>\"\"\"\n        Get the list of environment variables required for this tool.\n        Note to subclasses: remember to include variables from super().env_vars!\n        \"\"\"\n        # Use the base extra_env_variables and ensure that our custom variables are on top.\n        list_of_vars = self.get_setting(\"cadence.extra_env_vars\")  # type: List[Dict[str, Any]]\n        assert isinstance(list_of_vars, list)\n\n        cadence_vars = {\n            \"CDS_LIC_FILE\": self.get_setting(\"cadence.CDS_LIC_FILE\"),\n            \"CADENCE_HOME\": self.get_setting(\"cadence.cadence_home\")\n        }\n\n        return reduce(add_dicts, [dict(super().env_vars)] + list_of_vars + [cadence_vars], {})\n\n    <DED>def version_number(self, version: str) -> int:\n        <IND>\"\"\"\n        Assumes versions look like MAJOR_ISRMINOR and we will have less than 100 minor versions.\n        \"\"\"\n        main_version = int(version.split(\"_\")[0]) # type: int\n        minor_version = 0 # type: int\n        if \"_\" in version:\n            <IND>minor_version = int(version.split(\"_\")[1][3:])\n        <DED>return main_version * 100 + minor_version\n\n    <DED>def get_timing_libs(self, corner: Optional[MMMCCorner] = None) -> str:\n        <IND>\"\"\"\n        Helper function to get the list of ASCII timing .lib files in space separated format.\n        Note that Cadence tools support ECSM, so we can use the ECSM-based filter.\n\n        :param corner: Optional corner to consider. If supplied, this will use filter_for_mmmc to select libraries that\n        match a given corner (voltage/temperature).\n        :return: List of lib files separated by spaces\n        \"\"\"\n        pre_filters = optional_map(corner, lambda c: [self.filter_for_mmmc(voltage=c.voltage,\n                                                                           temp=c.temp)])  # type: Optional[List[Callable[[hammer_tech.Library],bool]]]\n\n        lib_args = self.technology.read_libs([hammer_tech.filters.timing_lib_with_ecsm_filter],\n                                             hammer_tech.HammerTechnologyUtils.to_plain_item,\n                                             extra_pre_filters=pre_filters)\n        return \" \".join(lib_args)\n\n    <DED>def get_mmmc_qrc(self, corner: MMMCCorner) -> str:\n        <IND>lib_args = self.technology.read_libs([hammer_tech.filters.qrc_tech_filter],\n                                             hammer_tech.HammerTechnologyUtils.to_plain_item,\n                                             extra_pre_filters=[\n                                                 self.filter_for_mmmc(voltage=corner.voltage, temp=corner.temp)])\n        return \" \".join(lib_args)\n\n    <DED>def get_qrc_tech(self) -> str:\n        <IND>\"\"\"\n        Helper function to get the list of rc corner tech files in space separated format.\n\n        :return: List of qrc tech files separated by spaces\n        \"\"\"\n        lib_args = self.technology.read_libs([\n            hammer_tech.filters.qrc_tech_filter\n        ], hammer_tech.HammerTechnologyUtils.to_plain_item)\n        return \" \".join(lib_args)\n\n    <DED>def generate_mmmc_script(self) -> str:\n        <IND>\"\"\"\n        Output for the mmmc.tcl script.\n        Innovus (init_design) requires that the timing script be placed in a separate file.\n\n        :return: Contents of the mmmc script.\n        \"\"\"\n        mmmc_output = []  # type: List[str]\n\n        def append_mmmc(cmd: str) -> None:\n            <IND>self.verbose_tcl_append(cmd, mmmc_output)\n\n        # Create an Innovus constraint mode.\n        <DED>constraint_mode = \"my_constraint_mode\"\n        sdc_files = []  # type: List[str]\n\n        # Generate constraints\n        clock_constraints_fragment = os.path.join(self.run_dir, \"clock_constraints_fragment.sdc\")\n        with open(clock_constraints_fragment, \"w\") as f:\n            <IND>f.write(self.sdc_clock_constraints)\n        <DED>sdc_files.append(clock_constraints_fragment)\n\n        # Generate port constraints.\n        pin_constraints_fragment = os.path.join(self.run_dir, \"pin_constraints_fragment.sdc\")\n        with open(pin_constraints_fragment, \"w\") as f:\n            <IND>f.write(self.sdc_pin_constraints)\n        <DED>sdc_files.append(pin_constraints_fragment)\n\n        # Add the post-synthesis SDC, if present.\n        post_synth_sdc = self.post_synth_sdc\n        if post_synth_sdc is not None:\n            <IND>sdc_files.append(post_synth_sdc)\n\n        # TODO: add floorplanning SDC\n        <DED>if len(sdc_files) > 0:\n            <IND>sdc_files_arg = \"-sdc_files [list {sdc_files}]\".format(\n                sdc_files=\" \".join(sdc_files)\n            )\n        <DED>else:\n            <IND>blank_sdc = os.path.join(self.run_dir, \"blank.sdc\")\n            self.run_executable([\"touch\", blank_sdc])\n            sdc_files_arg = \"-sdc_files {{ {} }}\".format(blank_sdc)\n        <DED>append_mmmc(\"create_constraint_mode -name {name} {sdc_files_arg}\".format(\n            name=constraint_mode,\n            sdc_files_arg=sdc_files_arg\n        ))\n\n        corners = self.get_mmmc_corners()  # type: List[MMMCCorner]\n        # In parallel, create the delay corners\n        if corners:\n            <IND>setup_corner = corners[0]  # type: MMMCCorner\n            hold_corner = corners[0]  # type: MMMCCorner\n            # TODO(colins): handle more than one corner and do something with extra corners\n            for corner in corners:\n                <IND>if corner.type is MMMCCornerType.Setup:\n                    <IND>setup_corner = corner\n                <DED>if corner.type is MMMCCornerType.Hold:\n                    <IND>hold_corner = corner\n\n            # First, create Innovus library sets\n            <DED><DED>append_mmmc(\"create_library_set -name {name} -timing [list {list}]\".format(\n                name=\"{n}.setup_set\".format(n=setup_corner.name),\n                list=self.get_timing_libs(setup_corner)\n            ))\n            append_mmmc(\"create_library_set -name {name} -timing [list {list}]\".format(\n                name=\"{n}.hold_set\".format(n=hold_corner.name),\n                list=self.get_timing_libs(hold_corner)\n            ))\n            # Skip opconds for now\n            # Next, create Innovus timing conditions\n            append_mmmc(\"create_timing_condition -name {name} -library_sets [list {list}]\".format(\n                name=\"{n}.setup_cond\".format(n=setup_corner.name),\n                list=\"{n}.setup_set\".format(n=setup_corner.name)\n            ))\n            append_mmmc(\"create_timing_condition -name {name} -library_sets [list {list}]\".format(\n                name=\"{n}.hold_cond\".format(n=hold_corner.name),\n                list=\"{n}.hold_set\".format(n=hold_corner.name)\n            ))\n            # Next, create Innovus rc corners from qrc tech files\n            append_mmmc(\"create_rc_corner -name {name} -temperature {tempInCelsius} {qrc}\".format(\n                name=\"{n}.setup_rc\".format(n=setup_corner.name),\n                tempInCelsius=str(setup_corner.temp.value),\n                qrc=\"-qrc_tech {}\".format(self.get_mmmc_qrc(setup_corner)) if self.get_mmmc_qrc(setup_corner) != '' else ''\n            ))\n            append_mmmc(\"create_rc_corner -name {name} -temperature {tempInCelsius} {qrc}\".format(\n                name=\"{n}.hold_rc\".format(n=hold_corner.name),\n                tempInCelsius=str(hold_corner.temp.value),\n                qrc=\"-qrc_tech {}\".format(self.get_mmmc_qrc(hold_corner)) if self.get_mmmc_qrc(hold_corner) != '' else ''\n            ))\n            # Next, create an Innovus delay corner.\n            append_mmmc(\n                \"create_delay_corner -name {name}_delay -timing_condition {name}_cond -rc_corner {name}_rc\".format(\n                    name=\"{n}.setup\".format(n=setup_corner.name)\n                ))\n            append_mmmc(\n                \"create_delay_corner -name {name}_delay -timing_condition {name}_cond -rc_corner {name}_rc\".format(\n                    name=\"{n}.hold\".format(n=hold_corner.name)\n                ))\n            # Next, create the analysis views\n            append_mmmc(\"create_analysis_view -name {name}_view -delay_corner {name}_delay -constraint_mode {constraint}\".format(\n                name=\"{n}.setup\".format(n=setup_corner.name), constraint=constraint_mode))\n            append_mmmc(\"create_analysis_view -name {name}_view -delay_corner {name}_delay -constraint_mode {constraint}\".format(\n                name=\"{n}.hold\".format(n=hold_corner.name), constraint=constraint_mode))\n            # Finally, apply the analysis view.\n            append_mmmc(\"set_analysis_view -setup {{ {setup_view} }} -hold {{ {hold_view} }}\".format(\n                setup_view=\"{n}.setup_view\".format(n=setup_corner.name),\n                hold_view=\"{n}.hold_view\".format(n=hold_corner.name)\n            ))\n        <DED>else:\n            # First, create an Innovus library set.\n            <IND>library_set_name = \"my_lib_set\"\n            append_mmmc(\"create_library_set -name {name} -timing [list {list}]\".format(\n                name=library_set_name,\n                list=self.get_timing_libs()\n            ))\n            # Next, create an Innovus timing condition.\n            timing_condition_name = \"my_timing_condition\"\n            append_mmmc(\"create_timing_condition -name {name} -library_sets [list {list}]\".format(\n                name=timing_condition_name,\n                list=library_set_name\n            ))\n            # extra junk: -opcond ...\n            rc_corner_name = \"rc_cond\"\n            append_mmmc(\"create_rc_corner -name {name} -temperature {tempInCelsius} {qrc}\".format(\n                name=rc_corner_name,\n                tempInCelsius=120,  # TODO: this should come from tech config\n                qrc=\"-qrc_tech {}\".format(self.get_qrc_tech()) if self.get_qrc_tech() != '' else ''\n            ))\n            # Next, create an Innovus delay corner.\n            delay_corner_name = \"my_delay_corner\"\n            append_mmmc(\n                \"create_delay_corner -name {name} -timing_condition {timing_cond} -rc_corner {rc}\".format(\n                    name=delay_corner_name,\n                    timing_cond=timing_condition_name,\n                    rc=rc_corner_name\n                ))\n            # extra junk: -rc_corner my_rc_corner_maybe_worst\n            # Next, create an Innovus analysis view.\n            analysis_view_name = \"my_view\"\n            append_mmmc(\"create_analysis_view -name {name} -delay_corner {corner} -constraint_mode {constraint}\".format(\n                name=analysis_view_name, corner=delay_corner_name, constraint=constraint_mode))\n            # Finally, apply the analysis view.\n            # TODO: introduce different views of setup/hold and true multi-corner\n            append_mmmc(\"set_analysis_view -setup {{ {setup_view} }} -hold {{ {hold_view} }}\".format(\n                setup_view=analysis_view_name,\n                hold_view=analysis_view_name\n            ))\n\n        <DED>return \"\\n\".join(mmmc_output)\n\n    <DED>def generate_dont_use_commands(self) -> List[str]:\n        <IND>\"\"\"\n        Generate a list of dont_use commands for Cadence tools.\n        \"\"\"\n\n        def map_cell(in_cell: str) -> str:\n            # \"*/\" is needed for \"get_db lib_cells <cell_expression>\"\n            <IND>if in_cell.startswith(\"*/\"):\n                <IND>mapped_cell = in_cell  # type: str\n            <DED>else:\n                <IND>mapped_cell = \"*/\" + in_cell\n\n            # Check for cell existence first to avoid Genus erroring out.\n            <DED>get_db_str = \"[get_db lib_cells {mapped_cell}]\".format(mapped_cell=mapped_cell)\n            # Escaped version for puts.\n            get_db_str_escaped = get_db_str.replace('[', '\\[').replace(']', '\\]')\n            return \"\"\"\nputs \"set_dont_use {get_db_str_escaped}\"\nif {{ {get_db_str} ne \"\" }} {{\n    set_dont_use {get_db_str}\n}} else {{\n    puts \"WARNING: cell {mapped_cell} was not found for set_dont_use\"\n}}\n            \"\"\".format(get_db_str=get_db_str, get_db_str_escaped=get_db_str_escaped, mapped_cell=mapped_cell)\n\n        <DED>return list(map(map_cell, self.get_dont_use_list()))\n\n    <DED>def generate_power_spec_commands(self) -> List[str]:\n        <IND>\"\"\"\n        Generate commands to load a power specification for Cadence tools.\n        \"\"\"\n\n        power_spec_type = str(self.get_setting(\"vlsi.inputs.power_spec_type\"))  # type: str\n        power_spec_arg = \"\"  # type: str\n        if power_spec_type == \"cpf\":\n            <IND>power_spec_arg = \"cpf\"\n        <DED>elif power_spec_type == \"upf\":\n            <IND>power_spec_arg = \"1801\"\n        <DED>else:\n            <IND>self.logger.error(\n                \"Invalid power specification type '{tpe}'; only 'cpf' or 'upf' supported\".format(tpe=power_spec_type))\n            return []\n\n        <DED>power_spec_contents = \"\"  # type: str\n        power_spec_mode = str(self.get_setting(\"vlsi.inputs.power_spec_mode\"))  # type: str\n        if power_spec_mode == \"empty\":\n            <IND>return []\n        <DED>elif power_spec_mode == \"auto\":\n            <IND>if power_spec_type == \"cpf\":\n                <IND>power_spec_contents = self.cpf_power_specification\n            <DED>elif power_spec_type == \"upf\":\n                <IND>power_spec_contents = self.upf_power_specification\n        <DED><DED>elif power_spec_mode == \"manual\":\n            <IND>power_spec_contents = str(self.get_setting(\"vlsi.inputs.power_spec_contents\"))\n        <DED>else:\n            <IND>self.logger.error(\"Invalid power specification mode '{mode}'; using 'empty'.\".format(mode=power_spec_mode))\n            return []\n\n        # Write the power spec contents to file and include it\n        <DED>power_spec_file = os.path.join(self.run_dir, \"power_spec.{tpe}\".format(tpe=power_spec_type))\n        with open(power_spec_file, \"w\") as f:\n            <IND>f.write(power_spec_contents)\n        <DED>return [\"read_power_intent -{arg} {path}\".format(arg=power_spec_arg, path=power_spec_file),\n                \"commit_power_intent\"]\n\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "        <IND>self.tcl_append(cmd, self.output, clean)\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "ucb-bar/hammer",
    "commit": "3afca0f00301e87b3112d42284a6acfd3c083c42",
    "filename": "src/hammer-vlsi/hammer_vlsi/hammer_vlsi_impl.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/ucb-bar-hammer/src/hammer-vlsi/hammer_vlsi/hammer_vlsi_impl.py",
    "file_hunks_size": 13,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "src/hammer-vlsi/hammer_vlsi/hammer_vlsi_impl.py:1855:74 Invalid type [31]: Expression `src.hammer.__sub__(vlsi.hammer_vlsi.constraints.List[src.hammer.__sub__(vlsi.hammer_vlsi.constraints.Dict[(str, src.hammer.__sub__(vlsi.hammer_vlsi.constraints.Any))])])` is not a valid type.",
    "message": " Expression `src.hammer.__sub__(vlsi.hammer_vlsi.constraints.List[src.hammer.__sub__(vlsi.hammer_vlsi.constraints.Dict[(str, src.hammer.__sub__(vlsi.hammer_vlsi.constraints.Any))])])` is not a valid type.",
    "rule_id": "Invalid type [31]",
    "warning_line_no": 1855,
    "warning_line": "        list_of_vars = self.get_setting(\"mentor.extra_env_vars\")  # type: List[Dict[str, Any]]"
  }
]