[
  {
    "project": "datatheorem/strongarm",
    "commit": "ab620d78b4ce7f933cedc25960307f2c3b03c1a8",
    "filename": "strongarm/cli/utils.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/datatheorem-strongarm/strongarm/cli/utils.py",
    "file_hunks_size": 28,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "strongarm/cli/utils.py:83:4 Incompatible return type [7]: Expected `strongarm.macho.macho_binary.MachoBinary` but got `typing.Optional[strongarm.macho.macho_binary.MachoBinary]`.",
    "message": " Expected `strongarm.macho.macho_binary.MachoBinary` but got `typing.Optional[strongarm.macho.macho_binary.MachoBinary]`.",
    "rule_id": "Incompatible return type [7]",
    "warning_line_no": 83,
    "warning_line": "    return parsed_binary",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n    # Sanity checks\n    if not parser or len(binary_slices) == 0:\n        raise ValueError('Could not parse {} as a Mach-O or FAT'.format(parser.filename))\n\n    parsed_binary = None\n    if len(binary_slices) == 1:\n        # only one slice - return that\n        parsed_binary = binary_slices[0]\n    else:\n        # multiple slices - return 64 bit slice if there is one\n        for slice in binary_slices:\n            parsed_binary = slice\n            if parsed_binary.cpu_type == CPU_TYPE.ARM64:\n                break\n    return parsed_binary\n",
        "source_code_len": 543,
        "target_code": "\n    # Sanity checks (an empty list is falsey)\n    if not binary_slices:\n        raise ValueError(f'Could not parse {parser.filename} as a Mach-O or FAT')\n\n    parsed_binary = binary_slices[0]\n    # Return 64 bit slice if there is one\n    for binary_slice in binary_slices:\n        parsed_binary = binary_slice\n        if parsed_binary.cpu_type == CPU_TYPE.ARM64:\n            break\n    return parsed_binary\n",
        "target_code_len": 407,
        "diff_format": "@@ -68,16 +71,12 @@\n \n-    # Sanity checks\n-    if not parser or len(binary_slices) == 0:\n-        raise ValueError('Could not parse {} as a Mach-O or FAT'.format(parser.filename))\n-\n-    parsed_binary = None\n-    if len(binary_slices) == 1:\n-        # only one slice - return that\n-        parsed_binary = binary_slices[0]\n-    else:\n-        # multiple slices - return 64 bit slice if there is one\n-        for slice in binary_slices:\n-            parsed_binary = slice\n-            if parsed_binary.cpu_type == CPU_TYPE.ARM64:\n-                break\n+    # Sanity checks (an empty list is falsey)\n+    if not binary_slices:\n+        raise ValueError(f'Could not parse {parser.filename} as a Mach-O or FAT')\n+\n+    parsed_binary = binary_slices[0]\n+    # Return 64 bit slice if there is one\n+    for binary_slice in binary_slices:\n+        parsed_binary = binary_slice\n+        if parsed_binary.cpu_type == CPU_TYPE.ARM64:\n+            break\n     return parsed_binary\n",
        "source_code_with_indent": "\n    # Sanity checks\n    if not parser or len(binary_slices) == 0:\n        <IND>raise ValueError('Could not parse {} as a Mach-O or FAT'.format(parser.filename))\n\n    <DED>parsed_binary = None\n    if len(binary_slices) == 1:\n        # only one slice - return that\n        <IND>parsed_binary = binary_slices[0]\n    <DED>else:\n        # multiple slices - return 64 bit slice if there is one\n        <IND>for slice in binary_slices:\n            <IND>parsed_binary = slice\n            if parsed_binary.cpu_type == CPU_TYPE.ARM64:\n                <IND>break\n    <DED><DED><DED>return parsed_binary\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n    # Sanity checks (an empty list is falsey)\n    if not binary_slices:\n        <IND>raise ValueError(f'Could not parse {parser.filename} as a Mach-O or FAT')\n\n    <DED>parsed_binary = binary_slices[0]\n    # Return 64 bit slice if there is one\n    for binary_slice in binary_slices:\n        <IND>parsed_binary = binary_slice\n        if parsed_binary.cpu_type == CPU_TYPE.ARM64:\n            <IND>break\n    <DED><DED>return parsed_binary\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "datatheorem/strongarm",
    "commit": "ab620d78b4ce7f933cedc25960307f2c3b03c1a8",
    "filename": "strongarm/macho/arch_independent_structs.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/datatheorem-strongarm/strongarm/macho/arch_independent_structs.py",
    "file_hunks_size": 5,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "strongarm/macho/arch_independent_structs.py:59:4 Incompatible attribute type [8]: Attribute `_32_BIT_STRUCT` declared in class `ArchIndependentStructure` has type `Union[Type[CFString32], Type[DylibCommand], Type[MachoDyldInfoCommand], Type[MachoDysymtabCommand], Type[MachoEncryptionInfo32Command], Type[MachoHeader32], Type[MachoLinkeditDataCommand], Type[MachoLoadCommand], Type[MachoNlist32], Type[MachoSection32Raw], Type[MachoSegmentCommand32], Type[MachoSymtabCommand], Type[ObjcCategoryRaw32], Type[ObjcClassRaw32], Type[ObjcDataRaw32], Type[ObjcMethod32], Type[ObjcMethodList], Type[ObjcProtocolRaw32]]` but is used as type `None`.",
    "message": " Attribute `_32_BIT_STRUCT` declared in class `ArchIndependentStructure` has type `Union[Type[CFString32], Type[DylibCommand], Type[MachoDyldInfoCommand], Type[MachoDysymtabCommand], Type[MachoEncryptionInfo32Command], Type[MachoHeader32], Type[MachoLinkeditDataCommand], Type[MachoLoadCommand], Type[MachoNlist32], Type[MachoSection32Raw], Type[MachoSegmentCommand32], Type[MachoSymtabCommand], Type[ObjcCategoryRaw32], Type[ObjcClassRaw32], Type[ObjcDataRaw32], Type[ObjcMethod32], Type[ObjcMethodList], Type[ObjcProtocolRaw32]]` but is used as type `None`.",
    "rule_id": "Incompatible attribute type [8]",
    "warning_line_no": 59,
    "warning_line": "    _32_BIT_STRUCT: '_32_BIT_STRUCT_ALIAS' = None"
  },
  {
    "project": "datatheorem/strongarm",
    "commit": "ab620d78b4ce7f933cedc25960307f2c3b03c1a8",
    "filename": "strongarm/macho/arch_independent_structs.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/datatheorem-strongarm/strongarm/macho/arch_independent_structs.py",
    "file_hunks_size": 5,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "strongarm/macho/arch_independent_structs.py:60:4 Incompatible attribute type [8]: Attribute `_64_BIT_STRUCT` declared in class `ArchIndependentStructure` has type `Union[Type[CFString64], Type[DylibCommand], Type[MachoDyldInfoCommand], Type[MachoDysymtabCommand], Type[MachoEncryptionInfo64Command], Type[MachoHeader64], Type[MachoLinkeditDataCommand], Type[MachoLoadCommand], Type[MachoNlist64], Type[MachoSection64Raw], Type[MachoSegmentCommand64], Type[MachoSymtabCommand], Type[ObjcCategoryRaw64], Type[ObjcClassRaw64], Type[ObjcDataRaw64], Type[ObjcMethod64], Type[ObjcMethodList], Type[ObjcProtocolRaw64]]` but is used as type `None`.",
    "message": " Attribute `_64_BIT_STRUCT` declared in class `ArchIndependentStructure` has type `Union[Type[CFString64], Type[DylibCommand], Type[MachoDyldInfoCommand], Type[MachoDysymtabCommand], Type[MachoEncryptionInfo64Command], Type[MachoHeader64], Type[MachoLinkeditDataCommand], Type[MachoLoadCommand], Type[MachoNlist64], Type[MachoSection64Raw], Type[MachoSegmentCommand64], Type[MachoSymtabCommand], Type[ObjcCategoryRaw64], Type[ObjcClassRaw64], Type[ObjcDataRaw64], Type[ObjcMethod64], Type[ObjcMethodList], Type[ObjcProtocolRaw64]]` but is used as type `None`.",
    "rule_id": "Incompatible attribute type [8]",
    "warning_line_no": 60,
    "warning_line": "    _64_BIT_STRUCT: '_64_BIT_STRUCT_ALIAS' = None"
  },
  {
    "project": "datatheorem/strongarm",
    "commit": "ab620d78b4ce7f933cedc25960307f2c3b03c1a8",
    "filename": "strongarm/macho/arch_independent_structs.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/datatheorem-strongarm/strongarm/macho/arch_independent_structs.py",
    "file_hunks_size": 5,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "strongarm/macho/arch_independent_structs.py:144:4 Inconsistent override [15]: `_32_BIT_STRUCT` overrides attribute defined in `ArchIndependentStructure` inconsistently. Type `Type[ObjcProtocolList32]` is not a subtype of the overridden attribute `Union[Type[CFString32], Type[DylibCommand], Type[MachoDyldInfoCommand], Type[MachoDysymtabCommand], Type[MachoEncryptionInfo32Command], Type[MachoHeader32], Type[MachoLinkeditDataCommand], Type[MachoLoadCommand], Type[MachoNlist32], Type[MachoSection32Raw], Type[MachoSegmentCommand32], Type[MachoSymtabCommand], Type[ObjcCategoryRaw32], Type[ObjcClassRaw32], Type[ObjcDataRaw32], Type[ObjcMethod32], Type[ObjcMethodList], Type[ObjcProtocolRaw32]]`.",
    "message": " `_32_BIT_STRUCT` overrides attribute defined in `ArchIndependentStructure` inconsistently. Type `Type[ObjcProtocolList32]` is not a subtype of the overridden attribute `Union[Type[CFString32], Type[DylibCommand], Type[MachoDyldInfoCommand], Type[MachoDysymtabCommand], Type[MachoEncryptionInfo32Command], Type[MachoHeader32], Type[MachoLinkeditDataCommand], Type[MachoLoadCommand], Type[MachoNlist32], Type[MachoSection32Raw], Type[MachoSegmentCommand32], Type[MachoSymtabCommand], Type[ObjcCategoryRaw32], Type[ObjcClassRaw32], Type[ObjcDataRaw32], Type[ObjcMethod32], Type[ObjcMethodList], Type[ObjcProtocolRaw32]]`.",
    "rule_id": "Inconsistent override [15]",
    "warning_line_no": 144,
    "warning_line": "    _32_BIT_STRUCT = ObjcProtocolList32"
  },
  {
    "project": "datatheorem/strongarm",
    "commit": "ab620d78b4ce7f933cedc25960307f2c3b03c1a8",
    "filename": "strongarm/macho/arch_independent_structs.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/datatheorem-strongarm/strongarm/macho/arch_independent_structs.py",
    "file_hunks_size": 5,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "strongarm/macho/arch_independent_structs.py:145:4 Inconsistent override [15]: `_64_BIT_STRUCT` overrides attribute defined in `ArchIndependentStructure` inconsistently. Type `Type[ObjcProtocolList64]` is not a subtype of the overridden attribute `Union[Type[CFString64], Type[DylibCommand], Type[MachoDyldInfoCommand], Type[MachoDysymtabCommand], Type[MachoEncryptionInfo64Command], Type[MachoHeader64], Type[MachoLinkeditDataCommand], Type[MachoLoadCommand], Type[MachoNlist64], Type[MachoSection64Raw], Type[MachoSegmentCommand64], Type[MachoSymtabCommand], Type[ObjcCategoryRaw64], Type[ObjcClassRaw64], Type[ObjcDataRaw64], Type[ObjcMethod64], Type[ObjcMethodList], Type[ObjcProtocolRaw64]]`.",
    "message": " `_64_BIT_STRUCT` overrides attribute defined in `ArchIndependentStructure` inconsistently. Type `Type[ObjcProtocolList64]` is not a subtype of the overridden attribute `Union[Type[CFString64], Type[DylibCommand], Type[MachoDyldInfoCommand], Type[MachoDysymtabCommand], Type[MachoEncryptionInfo64Command], Type[MachoHeader64], Type[MachoLinkeditDataCommand], Type[MachoLoadCommand], Type[MachoNlist64], Type[MachoSection64Raw], Type[MachoSegmentCommand64], Type[MachoSymtabCommand], Type[ObjcCategoryRaw64], Type[ObjcClassRaw64], Type[ObjcDataRaw64], Type[ObjcMethod64], Type[ObjcMethodList], Type[ObjcProtocolRaw64]]`.",
    "rule_id": "Inconsistent override [15]",
    "warning_line_no": 145,
    "warning_line": "    _64_BIT_STRUCT = ObjcProtocolList64"
  },
  {
    "project": "datatheorem/strongarm",
    "commit": "ab620d78b4ce7f933cedc25960307f2c3b03c1a8",
    "filename": "strongarm/macho/arch_independent_structs.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/datatheorem-strongarm/strongarm/macho/arch_independent_structs.py",
    "file_hunks_size": 5,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": true,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "strongarm/macho/arch_independent_structs.py:179:8 Incompatible attribute type [8]: Attribute `fileoff` declared in class `DylibCommandStruct` has type `int` but is used as type `None`.",
    "message": " Attribute `fileoff` declared in class `DylibCommandStruct` has type `int` but is used as type `None`.",
    "rule_id": "Incompatible attribute type [8]",
    "warning_line_no": 179,
    "warning_line": "        self.fileoff: int = None",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": true,
        "has_suppression": false,
        "source_code": "\n    def __init__(self, binary: 'MachoBinary', binary_offset: int, virtual=False) -> None:\n        super(DylibCommandStruct, self).__init__(binary, binary_offset, virtual)\n        self.fileoff: int = None\n\n\n",
        "source_code_len": 207,
        "target_code": "\n\n",
        "target_code_len": 2,
        "diff_format": "@@ -176,6 +198,2 @@\n \n-    def __init__(self, binary: 'MachoBinary', binary_offset: int, virtual=False) -> None:\n-        super(DylibCommandStruct, self).__init__(binary, binary_offset, virtual)\n-        self.fileoff: int = None\n-\n \n",
        "source_code_with_indent": "\n    def __init__(self, binary: 'MachoBinary', binary_offset: int, virtual=False) -> None:\n        <IND>super(DylibCommandStruct, self).__init__(binary, binary_offset, virtual)\n        self.fileoff: int = None\n\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "datatheorem/strongarm",
    "commit": "ab620d78b4ce7f933cedc25960307f2c3b03c1a8",
    "filename": "strongarm/macho/codesign/codesign_definitions.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/datatheorem-strongarm/strongarm/macho/codesign/codesign_definitions.py",
    "file_hunks_size": 5,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": true,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "strongarm/macho/codesign/codesign_definitions.py:38:39 Unsupported operand [58]: `+` is not supported for operand types `typing.List[typing.Tuple[str, typing.Type[c_uint32]]]` and `typing.List[typing.Tuple[str, typing.Type[typing.Union[c_uint32, c_uint8]]]]`.",
    "message": " `+` is not supported for operand types `typing.List[typing.Tuple[str, typing.Type[c_uint32]]]` and `typing.List[typing.Tuple[str, typing.Type[typing.Union[c_uint32, c_uint8]]]]`.",
    "rule_id": "Unsupported operand [58]",
    "warning_line_no": 38,
    "warning_line": "    _fields_ = CSBlobStruct._fields_ + [",
    "min_patch": [
      {
        "hunk_fit_TFix": true,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "class CSCodeDirectoryStruct(BigEndianStructure):\n    _fields_ = CSBlobStruct._fields_ + [\n        ('version', c_uint32),\n",
        "source_code_len": 121,
        "target_code": "class CSCodeDirectoryStruct(BigEndianStructure):\n    _fields_ = [\n        ('magic', c_uint32),\n        ('length', c_uint32),\n        ('version', c_uint32),\n",
        "target_code_len": 156,
        "diff_format": "@@ -37,3 +36,5 @@\n class CSCodeDirectoryStruct(BigEndianStructure):\n-    _fields_ = CSBlobStruct._fields_ + [\n+    _fields_ = [\n+        ('magic', c_uint32),\n+        ('length', c_uint32),\n         ('version', c_uint32),\n",
        "source_code_with_indent": "<DED>class CSCodeDirectoryStruct(BigEndianStructure):\n    <IND>_fields_ = CSBlobStruct._fields_ + [\n        ('version', c_uint32),\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "<DED>class CSCodeDirectoryStruct(BigEndianStructure):\n    <IND>_fields_ = [\n        ('magic', c_uint32),\n        ('length', c_uint32),\n        ('version', c_uint32),\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "datatheorem/strongarm",
    "commit": "ab620d78b4ce7f933cedc25960307f2c3b03c1a8",
    "filename": "strongarm/macho/codesign/codesign_definitions.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/datatheorem-strongarm/strongarm/macho/codesign/codesign_definitions.py",
    "file_hunks_size": 5,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "strongarm/macho/codesign/codesign_definitions.py:64:4 Inconsistent override [15]: `_32_BIT_STRUCT` overrides attribute defined in `ArchIndependentStructure` inconsistently. Type `typing.Type[CSBlobStruct]` is not a subtype of the overridden attribute `typing.Union[typing.Type[strongarm.macho.macho_definitions.CFString32], typing.Type[strongarm.macho.macho_definitions.DylibCommand], typing.Type[strongarm.macho.macho_definitions.MachoDyldInfoCommand], typing.Type[strongarm.macho.macho_definitions.MachoDysymtabCommand], typing.Type[strongarm.macho.macho_definitions.MachoEncryptionInfo32Command], typing.Type[strongarm.macho.macho_definitions.MachoHeader32], typing.Type[strongarm.macho.macho_definitions.MachoLinkeditDataCommand], typing.Type[strongarm.macho.macho_definitions.MachoLoadCommand], typing.Type[strongarm.macho.macho_definitions.MachoNlist32], typing.Type[strongarm.macho.macho_definitions.MachoSection32Raw], typing.Type[strongarm.macho.macho_definitions.MachoSegmentCommand32], typing.Type[strongarm.macho.macho_definitions.MachoSymtabCommand], typing.Type[strongarm.macho.macho_definitions.ObjcCategoryRaw32], typing.Type[strongarm.macho.macho_definitions.ObjcClassRaw32], typing.Type[strongarm.macho.macho_definitions.ObjcDataRaw32], typing.Type[strongarm.macho.macho_definitions.ObjcMethod32], typing.Type[strongarm.macho.macho_definitions.ObjcMethodList], typing.Type[strongarm.macho.macho_definitions.ObjcProtocolRaw32]]`.",
    "message": " `_32_BIT_STRUCT` overrides attribute defined in `ArchIndependentStructure` inconsistently. Type `typing.Type[CSBlobStruct]` is not a subtype of the overridden attribute `typing.Union[typing.Type[strongarm.macho.macho_definitions.CFString32], typing.Type[strongarm.macho.macho_definitions.DylibCommand], typing.Type[strongarm.macho.macho_definitions.MachoDyldInfoCommand], typing.Type[strongarm.macho.macho_definitions.MachoDysymtabCommand], typing.Type[strongarm.macho.macho_definitions.MachoEncryptionInfo32Command], typing.Type[strongarm.macho.macho_definitions.MachoHeader32], typing.Type[strongarm.macho.macho_definitions.MachoLinkeditDataCommand], typing.Type[strongarm.macho.macho_definitions.MachoLoadCommand], typing.Type[strongarm.macho.macho_definitions.MachoNlist32], typing.Type[strongarm.macho.macho_definitions.MachoSection32Raw], typing.Type[strongarm.macho.macho_definitions.MachoSegmentCommand32], typing.Type[strongarm.macho.macho_definitions.MachoSymtabCommand], typing.Type[strongarm.macho.macho_definitions.ObjcCategoryRaw32], typing.Type[strongarm.macho.macho_definitions.ObjcClassRaw32], typing.Type[strongarm.macho.macho_definitions.ObjcDataRaw32], typing.Type[strongarm.macho.macho_definitions.ObjcMethod32], typing.Type[strongarm.macho.macho_definitions.ObjcMethodList], typing.Type[strongarm.macho.macho_definitions.ObjcProtocolRaw32]]`.",
    "rule_id": "Inconsistent override [15]",
    "warning_line_no": 64,
    "warning_line": "    _32_BIT_STRUCT = CSBlobStruct"
  },
  {
    "project": "datatheorem/strongarm",
    "commit": "ab620d78b4ce7f933cedc25960307f2c3b03c1a8",
    "filename": "strongarm/macho/codesign/codesign_definitions.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/datatheorem-strongarm/strongarm/macho/codesign/codesign_definitions.py",
    "file_hunks_size": 5,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "strongarm/macho/codesign/codesign_definitions.py:65:4 Inconsistent override [15]: `_64_BIT_STRUCT` overrides attribute defined in `ArchIndependentStructure` inconsistently. Type `typing.Type[CSBlobStruct]` is not a subtype of the overridden attribute `typing.Union[typing.Type[strongarm.macho.macho_definitions.CFString64], typing.Type[strongarm.macho.macho_definitions.DylibCommand], typing.Type[strongarm.macho.macho_definitions.MachoDyldInfoCommand], typing.Type[strongarm.macho.macho_definitions.MachoDysymtabCommand], typing.Type[strongarm.macho.macho_definitions.MachoEncryptionInfo64Command], typing.Type[strongarm.macho.macho_definitions.MachoHeader64], typing.Type[strongarm.macho.macho_definitions.MachoLinkeditDataCommand], typing.Type[strongarm.macho.macho_definitions.MachoLoadCommand], typing.Type[strongarm.macho.macho_definitions.MachoNlist64], typing.Type[strongarm.macho.macho_definitions.MachoSection64Raw], typing.Type[strongarm.macho.macho_definitions.MachoSegmentCommand64], typing.Type[strongarm.macho.macho_definitions.MachoSymtabCommand], typing.Type[strongarm.macho.macho_definitions.ObjcCategoryRaw64], typing.Type[strongarm.macho.macho_definitions.ObjcClassRaw64], typing.Type[strongarm.macho.macho_definitions.ObjcDataRaw64], typing.Type[strongarm.macho.macho_definitions.ObjcMethod64], typing.Type[strongarm.macho.macho_definitions.ObjcMethodList], typing.Type[strongarm.macho.macho_definitions.ObjcProtocolRaw64]]`.",
    "message": " `_64_BIT_STRUCT` overrides attribute defined in `ArchIndependentStructure` inconsistently. Type `typing.Type[CSBlobStruct]` is not a subtype of the overridden attribute `typing.Union[typing.Type[strongarm.macho.macho_definitions.CFString64], typing.Type[strongarm.macho.macho_definitions.DylibCommand], typing.Type[strongarm.macho.macho_definitions.MachoDyldInfoCommand], typing.Type[strongarm.macho.macho_definitions.MachoDysymtabCommand], typing.Type[strongarm.macho.macho_definitions.MachoEncryptionInfo64Command], typing.Type[strongarm.macho.macho_definitions.MachoHeader64], typing.Type[strongarm.macho.macho_definitions.MachoLinkeditDataCommand], typing.Type[strongarm.macho.macho_definitions.MachoLoadCommand], typing.Type[strongarm.macho.macho_definitions.MachoNlist64], typing.Type[strongarm.macho.macho_definitions.MachoSection64Raw], typing.Type[strongarm.macho.macho_definitions.MachoSegmentCommand64], typing.Type[strongarm.macho.macho_definitions.MachoSymtabCommand], typing.Type[strongarm.macho.macho_definitions.ObjcCategoryRaw64], typing.Type[strongarm.macho.macho_definitions.ObjcClassRaw64], typing.Type[strongarm.macho.macho_definitions.ObjcDataRaw64], typing.Type[strongarm.macho.macho_definitions.ObjcMethod64], typing.Type[strongarm.macho.macho_definitions.ObjcMethodList], typing.Type[strongarm.macho.macho_definitions.ObjcProtocolRaw64]]`.",
    "rule_id": "Inconsistent override [15]",
    "warning_line_no": 65,
    "warning_line": "    _64_BIT_STRUCT = CSBlobStruct"
  },
  {
    "project": "datatheorem/strongarm",
    "commit": "ab620d78b4ce7f933cedc25960307f2c3b03c1a8",
    "filename": "strongarm/macho/codesign/codesign_definitions.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/datatheorem-strongarm/strongarm/macho/codesign/codesign_definitions.py",
    "file_hunks_size": 5,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "strongarm/macho/codesign/codesign_definitions.py:69:4 Inconsistent override [15]: `_32_BIT_STRUCT` overrides attribute defined in `ArchIndependentStructure` inconsistently. Type `typing.Type[CSSuperblobStruct]` is not a subtype of the overridden attribute `typing.Union[typing.Type[strongarm.macho.macho_definitions.CFString32], typing.Type[strongarm.macho.macho_definitions.DylibCommand], typing.Type[strongarm.macho.macho_definitions.MachoDyldInfoCommand], typing.Type[strongarm.macho.macho_definitions.MachoDysymtabCommand], typing.Type[strongarm.macho.macho_definitions.MachoEncryptionInfo32Command], typing.Type[strongarm.macho.macho_definitions.MachoHeader32], typing.Type[strongarm.macho.macho_definitions.MachoLinkeditDataCommand], typing.Type[strongarm.macho.macho_definitions.MachoLoadCommand], typing.Type[strongarm.macho.macho_definitions.MachoNlist32], typing.Type[strongarm.macho.macho_definitions.MachoSection32Raw], typing.Type[strongarm.macho.macho_definitions.MachoSegmentCommand32], typing.Type[strongarm.macho.macho_definitions.MachoSymtabCommand], typing.Type[strongarm.macho.macho_definitions.ObjcCategoryRaw32], typing.Type[strongarm.macho.macho_definitions.ObjcClassRaw32], typing.Type[strongarm.macho.macho_definitions.ObjcDataRaw32], typing.Type[strongarm.macho.macho_definitions.ObjcMethod32], typing.Type[strongarm.macho.macho_definitions.ObjcMethodList], typing.Type[strongarm.macho.macho_definitions.ObjcProtocolRaw32]]`.",
    "message": " `_32_BIT_STRUCT` overrides attribute defined in `ArchIndependentStructure` inconsistently. Type `typing.Type[CSSuperblobStruct]` is not a subtype of the overridden attribute `typing.Union[typing.Type[strongarm.macho.macho_definitions.CFString32], typing.Type[strongarm.macho.macho_definitions.DylibCommand], typing.Type[strongarm.macho.macho_definitions.MachoDyldInfoCommand], typing.Type[strongarm.macho.macho_definitions.MachoDysymtabCommand], typing.Type[strongarm.macho.macho_definitions.MachoEncryptionInfo32Command], typing.Type[strongarm.macho.macho_definitions.MachoHeader32], typing.Type[strongarm.macho.macho_definitions.MachoLinkeditDataCommand], typing.Type[strongarm.macho.macho_definitions.MachoLoadCommand], typing.Type[strongarm.macho.macho_definitions.MachoNlist32], typing.Type[strongarm.macho.macho_definitions.MachoSection32Raw], typing.Type[strongarm.macho.macho_definitions.MachoSegmentCommand32], typing.Type[strongarm.macho.macho_definitions.MachoSymtabCommand], typing.Type[strongarm.macho.macho_definitions.ObjcCategoryRaw32], typing.Type[strongarm.macho.macho_definitions.ObjcClassRaw32], typing.Type[strongarm.macho.macho_definitions.ObjcDataRaw32], typing.Type[strongarm.macho.macho_definitions.ObjcMethod32], typing.Type[strongarm.macho.macho_definitions.ObjcMethodList], typing.Type[strongarm.macho.macho_definitions.ObjcProtocolRaw32]]`.",
    "rule_id": "Inconsistent override [15]",
    "warning_line_no": 69,
    "warning_line": "    _32_BIT_STRUCT = CSSuperblobStruct"
  },
  {
    "project": "datatheorem/strongarm",
    "commit": "ab620d78b4ce7f933cedc25960307f2c3b03c1a8",
    "filename": "strongarm/macho/codesign/codesign_definitions.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/datatheorem-strongarm/strongarm/macho/codesign/codesign_definitions.py",
    "file_hunks_size": 5,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "strongarm/macho/codesign/codesign_definitions.py:70:4 Inconsistent override [15]: `_64_BIT_STRUCT` overrides attribute defined in `ArchIndependentStructure` inconsistently. Type `typing.Type[CSSuperblobStruct]` is not a subtype of the overridden attribute `typing.Union[typing.Type[strongarm.macho.macho_definitions.CFString64], typing.Type[strongarm.macho.macho_definitions.DylibCommand], typing.Type[strongarm.macho.macho_definitions.MachoDyldInfoCommand], typing.Type[strongarm.macho.macho_definitions.MachoDysymtabCommand], typing.Type[strongarm.macho.macho_definitions.MachoEncryptionInfo64Command], typing.Type[strongarm.macho.macho_definitions.MachoHeader64], typing.Type[strongarm.macho.macho_definitions.MachoLinkeditDataCommand], typing.Type[strongarm.macho.macho_definitions.MachoLoadCommand], typing.Type[strongarm.macho.macho_definitions.MachoNlist64], typing.Type[strongarm.macho.macho_definitions.MachoSection64Raw], typing.Type[strongarm.macho.macho_definitions.MachoSegmentCommand64], typing.Type[strongarm.macho.macho_definitions.MachoSymtabCommand], typing.Type[strongarm.macho.macho_definitions.ObjcCategoryRaw64], typing.Type[strongarm.macho.macho_definitions.ObjcClassRaw64], typing.Type[strongarm.macho.macho_definitions.ObjcDataRaw64], typing.Type[strongarm.macho.macho_definitions.ObjcMethod64], typing.Type[strongarm.macho.macho_definitions.ObjcMethodList], typing.Type[strongarm.macho.macho_definitions.ObjcProtocolRaw64]]`.",
    "message": " `_64_BIT_STRUCT` overrides attribute defined in `ArchIndependentStructure` inconsistently. Type `typing.Type[CSSuperblobStruct]` is not a subtype of the overridden attribute `typing.Union[typing.Type[strongarm.macho.macho_definitions.CFString64], typing.Type[strongarm.macho.macho_definitions.DylibCommand], typing.Type[strongarm.macho.macho_definitions.MachoDyldInfoCommand], typing.Type[strongarm.macho.macho_definitions.MachoDysymtabCommand], typing.Type[strongarm.macho.macho_definitions.MachoEncryptionInfo64Command], typing.Type[strongarm.macho.macho_definitions.MachoHeader64], typing.Type[strongarm.macho.macho_definitions.MachoLinkeditDataCommand], typing.Type[strongarm.macho.macho_definitions.MachoLoadCommand], typing.Type[strongarm.macho.macho_definitions.MachoNlist64], typing.Type[strongarm.macho.macho_definitions.MachoSection64Raw], typing.Type[strongarm.macho.macho_definitions.MachoSegmentCommand64], typing.Type[strongarm.macho.macho_definitions.MachoSymtabCommand], typing.Type[strongarm.macho.macho_definitions.ObjcCategoryRaw64], typing.Type[strongarm.macho.macho_definitions.ObjcClassRaw64], typing.Type[strongarm.macho.macho_definitions.ObjcDataRaw64], typing.Type[strongarm.macho.macho_definitions.ObjcMethod64], typing.Type[strongarm.macho.macho_definitions.ObjcMethodList], typing.Type[strongarm.macho.macho_definitions.ObjcProtocolRaw64]]`.",
    "rule_id": "Inconsistent override [15]",
    "warning_line_no": 70,
    "warning_line": "    _64_BIT_STRUCT = CSSuperblobStruct"
  },
  {
    "project": "datatheorem/strongarm",
    "commit": "ab620d78b4ce7f933cedc25960307f2c3b03c1a8",
    "filename": "strongarm/macho/codesign/codesign_definitions.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/datatheorem-strongarm/strongarm/macho/codesign/codesign_definitions.py",
    "file_hunks_size": 5,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "strongarm/macho/codesign/codesign_definitions.py:74:4 Inconsistent override [15]: `_32_BIT_STRUCT` overrides attribute defined in `ArchIndependentStructure` inconsistently. Type `typing.Type[CSCodeDirectoryStruct]` is not a subtype of the overridden attribute `typing.Union[typing.Type[strongarm.macho.macho_definitions.CFString32], typing.Type[strongarm.macho.macho_definitions.DylibCommand], typing.Type[strongarm.macho.macho_definitions.MachoDyldInfoCommand], typing.Type[strongarm.macho.macho_definitions.MachoDysymtabCommand], typing.Type[strongarm.macho.macho_definitions.MachoEncryptionInfo32Command], typing.Type[strongarm.macho.macho_definitions.MachoHeader32], typing.Type[strongarm.macho.macho_definitions.MachoLinkeditDataCommand], typing.Type[strongarm.macho.macho_definitions.MachoLoadCommand], typing.Type[strongarm.macho.macho_definitions.MachoNlist32], typing.Type[strongarm.macho.macho_definitions.MachoSection32Raw], typing.Type[strongarm.macho.macho_definitions.MachoSegmentCommand32], typing.Type[strongarm.macho.macho_definitions.MachoSymtabCommand], typing.Type[strongarm.macho.macho_definitions.ObjcCategoryRaw32], typing.Type[strongarm.macho.macho_definitions.ObjcClassRaw32], typing.Type[strongarm.macho.macho_definitions.ObjcDataRaw32], typing.Type[strongarm.macho.macho_definitions.ObjcMethod32], typing.Type[strongarm.macho.macho_definitions.ObjcMethodList], typing.Type[strongarm.macho.macho_definitions.ObjcProtocolRaw32]]`.",
    "message": " `_32_BIT_STRUCT` overrides attribute defined in `ArchIndependentStructure` inconsistently. Type `typing.Type[CSCodeDirectoryStruct]` is not a subtype of the overridden attribute `typing.Union[typing.Type[strongarm.macho.macho_definitions.CFString32], typing.Type[strongarm.macho.macho_definitions.DylibCommand], typing.Type[strongarm.macho.macho_definitions.MachoDyldInfoCommand], typing.Type[strongarm.macho.macho_definitions.MachoDysymtabCommand], typing.Type[strongarm.macho.macho_definitions.MachoEncryptionInfo32Command], typing.Type[strongarm.macho.macho_definitions.MachoHeader32], typing.Type[strongarm.macho.macho_definitions.MachoLinkeditDataCommand], typing.Type[strongarm.macho.macho_definitions.MachoLoadCommand], typing.Type[strongarm.macho.macho_definitions.MachoNlist32], typing.Type[strongarm.macho.macho_definitions.MachoSection32Raw], typing.Type[strongarm.macho.macho_definitions.MachoSegmentCommand32], typing.Type[strongarm.macho.macho_definitions.MachoSymtabCommand], typing.Type[strongarm.macho.macho_definitions.ObjcCategoryRaw32], typing.Type[strongarm.macho.macho_definitions.ObjcClassRaw32], typing.Type[strongarm.macho.macho_definitions.ObjcDataRaw32], typing.Type[strongarm.macho.macho_definitions.ObjcMethod32], typing.Type[strongarm.macho.macho_definitions.ObjcMethodList], typing.Type[strongarm.macho.macho_definitions.ObjcProtocolRaw32]]`.",
    "rule_id": "Inconsistent override [15]",
    "warning_line_no": 74,
    "warning_line": "    _32_BIT_STRUCT = CSCodeDirectoryStruct"
  },
  {
    "project": "datatheorem/strongarm",
    "commit": "ab620d78b4ce7f933cedc25960307f2c3b03c1a8",
    "filename": "strongarm/macho/codesign/codesign_definitions.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/datatheorem-strongarm/strongarm/macho/codesign/codesign_definitions.py",
    "file_hunks_size": 5,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "strongarm/macho/codesign/codesign_definitions.py:75:4 Inconsistent override [15]: `_64_BIT_STRUCT` overrides attribute defined in `ArchIndependentStructure` inconsistently. Type `typing.Type[CSCodeDirectoryStruct]` is not a subtype of the overridden attribute `typing.Union[typing.Type[strongarm.macho.macho_definitions.CFString64], typing.Type[strongarm.macho.macho_definitions.DylibCommand], typing.Type[strongarm.macho.macho_definitions.MachoDyldInfoCommand], typing.Type[strongarm.macho.macho_definitions.MachoDysymtabCommand], typing.Type[strongarm.macho.macho_definitions.MachoEncryptionInfo64Command], typing.Type[strongarm.macho.macho_definitions.MachoHeader64], typing.Type[strongarm.macho.macho_definitions.MachoLinkeditDataCommand], typing.Type[strongarm.macho.macho_definitions.MachoLoadCommand], typing.Type[strongarm.macho.macho_definitions.MachoNlist64], typing.Type[strongarm.macho.macho_definitions.MachoSection64Raw], typing.Type[strongarm.macho.macho_definitions.MachoSegmentCommand64], typing.Type[strongarm.macho.macho_definitions.MachoSymtabCommand], typing.Type[strongarm.macho.macho_definitions.ObjcCategoryRaw64], typing.Type[strongarm.macho.macho_definitions.ObjcClassRaw64], typing.Type[strongarm.macho.macho_definitions.ObjcDataRaw64], typing.Type[strongarm.macho.macho_definitions.ObjcMethod64], typing.Type[strongarm.macho.macho_definitions.ObjcMethodList], typing.Type[strongarm.macho.macho_definitions.ObjcProtocolRaw64]]`.",
    "message": " `_64_BIT_STRUCT` overrides attribute defined in `ArchIndependentStructure` inconsistently. Type `typing.Type[CSCodeDirectoryStruct]` is not a subtype of the overridden attribute `typing.Union[typing.Type[strongarm.macho.macho_definitions.CFString64], typing.Type[strongarm.macho.macho_definitions.DylibCommand], typing.Type[strongarm.macho.macho_definitions.MachoDyldInfoCommand], typing.Type[strongarm.macho.macho_definitions.MachoDysymtabCommand], typing.Type[strongarm.macho.macho_definitions.MachoEncryptionInfo64Command], typing.Type[strongarm.macho.macho_definitions.MachoHeader64], typing.Type[strongarm.macho.macho_definitions.MachoLinkeditDataCommand], typing.Type[strongarm.macho.macho_definitions.MachoLoadCommand], typing.Type[strongarm.macho.macho_definitions.MachoNlist64], typing.Type[strongarm.macho.macho_definitions.MachoSection64Raw], typing.Type[strongarm.macho.macho_definitions.MachoSegmentCommand64], typing.Type[strongarm.macho.macho_definitions.MachoSymtabCommand], typing.Type[strongarm.macho.macho_definitions.ObjcCategoryRaw64], typing.Type[strongarm.macho.macho_definitions.ObjcClassRaw64], typing.Type[strongarm.macho.macho_definitions.ObjcDataRaw64], typing.Type[strongarm.macho.macho_definitions.ObjcMethod64], typing.Type[strongarm.macho.macho_definitions.ObjcMethodList], typing.Type[strongarm.macho.macho_definitions.ObjcProtocolRaw64]]`.",
    "rule_id": "Inconsistent override [15]",
    "warning_line_no": 75,
    "warning_line": "    _64_BIT_STRUCT = CSCodeDirectoryStruct"
  },
  {
    "project": "datatheorem/strongarm",
    "commit": "ab620d78b4ce7f933cedc25960307f2c3b03c1a8",
    "filename": "strongarm/macho/codesign/codesign_definitions.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/datatheorem-strongarm/strongarm/macho/codesign/codesign_definitions.py",
    "file_hunks_size": 5,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "strongarm/macho/codesign/codesign_definitions.py:79:4 Inconsistent override [15]: `_32_BIT_STRUCT` overrides attribute defined in `ArchIndependentStructure` inconsistently. Type `typing.Type[CSBlobIndexStruct]` is not a subtype of the overridden attribute `typing.Union[typing.Type[strongarm.macho.macho_definitions.CFString32], typing.Type[strongarm.macho.macho_definitions.DylibCommand], typing.Type[strongarm.macho.macho_definitions.MachoDyldInfoCommand], typing.Type[strongarm.macho.macho_definitions.MachoDysymtabCommand], typing.Type[strongarm.macho.macho_definitions.MachoEncryptionInfo32Command], typing.Type[strongarm.macho.macho_definitions.MachoHeader32], typing.Type[strongarm.macho.macho_definitions.MachoLinkeditDataCommand], typing.Type[strongarm.macho.macho_definitions.MachoLoadCommand], typing.Type[strongarm.macho.macho_definitions.MachoNlist32], typing.Type[strongarm.macho.macho_definitions.MachoSection32Raw], typing.Type[strongarm.macho.macho_definitions.MachoSegmentCommand32], typing.Type[strongarm.macho.macho_definitions.MachoSymtabCommand], typing.Type[strongarm.macho.macho_definitions.ObjcCategoryRaw32], typing.Type[strongarm.macho.macho_definitions.ObjcClassRaw32], typing.Type[strongarm.macho.macho_definitions.ObjcDataRaw32], typing.Type[strongarm.macho.macho_definitions.ObjcMethod32], typing.Type[strongarm.macho.macho_definitions.ObjcMethodList], typing.Type[strongarm.macho.macho_definitions.ObjcProtocolRaw32]]`.",
    "message": " `_32_BIT_STRUCT` overrides attribute defined in `ArchIndependentStructure` inconsistently. Type `typing.Type[CSBlobIndexStruct]` is not a subtype of the overridden attribute `typing.Union[typing.Type[strongarm.macho.macho_definitions.CFString32], typing.Type[strongarm.macho.macho_definitions.DylibCommand], typing.Type[strongarm.macho.macho_definitions.MachoDyldInfoCommand], typing.Type[strongarm.macho.macho_definitions.MachoDysymtabCommand], typing.Type[strongarm.macho.macho_definitions.MachoEncryptionInfo32Command], typing.Type[strongarm.macho.macho_definitions.MachoHeader32], typing.Type[strongarm.macho.macho_definitions.MachoLinkeditDataCommand], typing.Type[strongarm.macho.macho_definitions.MachoLoadCommand], typing.Type[strongarm.macho.macho_definitions.MachoNlist32], typing.Type[strongarm.macho.macho_definitions.MachoSection32Raw], typing.Type[strongarm.macho.macho_definitions.MachoSegmentCommand32], typing.Type[strongarm.macho.macho_definitions.MachoSymtabCommand], typing.Type[strongarm.macho.macho_definitions.ObjcCategoryRaw32], typing.Type[strongarm.macho.macho_definitions.ObjcClassRaw32], typing.Type[strongarm.macho.macho_definitions.ObjcDataRaw32], typing.Type[strongarm.macho.macho_definitions.ObjcMethod32], typing.Type[strongarm.macho.macho_definitions.ObjcMethodList], typing.Type[strongarm.macho.macho_definitions.ObjcProtocolRaw32]]`.",
    "rule_id": "Inconsistent override [15]",
    "warning_line_no": 79,
    "warning_line": "    _32_BIT_STRUCT = CSBlobIndexStruct"
  },
  {
    "project": "datatheorem/strongarm",
    "commit": "ab620d78b4ce7f933cedc25960307f2c3b03c1a8",
    "filename": "strongarm/macho/codesign/codesign_definitions.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/datatheorem-strongarm/strongarm/macho/codesign/codesign_definitions.py",
    "file_hunks_size": 5,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "strongarm/macho/codesign/codesign_definitions.py:80:4 Inconsistent override [15]: `_64_BIT_STRUCT` overrides attribute defined in `ArchIndependentStructure` inconsistently. Type `typing.Type[CSBlobIndexStruct]` is not a subtype of the overridden attribute `typing.Union[typing.Type[strongarm.macho.macho_definitions.CFString64], typing.Type[strongarm.macho.macho_definitions.DylibCommand], typing.Type[strongarm.macho.macho_definitions.MachoDyldInfoCommand], typing.Type[strongarm.macho.macho_definitions.MachoDysymtabCommand], typing.Type[strongarm.macho.macho_definitions.MachoEncryptionInfo64Command], typing.Type[strongarm.macho.macho_definitions.MachoHeader64], typing.Type[strongarm.macho.macho_definitions.MachoLinkeditDataCommand], typing.Type[strongarm.macho.macho_definitions.MachoLoadCommand], typing.Type[strongarm.macho.macho_definitions.MachoNlist64], typing.Type[strongarm.macho.macho_definitions.MachoSection64Raw], typing.Type[strongarm.macho.macho_definitions.MachoSegmentCommand64], typing.Type[strongarm.macho.macho_definitions.MachoSymtabCommand], typing.Type[strongarm.macho.macho_definitions.ObjcCategoryRaw64], typing.Type[strongarm.macho.macho_definitions.ObjcClassRaw64], typing.Type[strongarm.macho.macho_definitions.ObjcDataRaw64], typing.Type[strongarm.macho.macho_definitions.ObjcMethod64], typing.Type[strongarm.macho.macho_definitions.ObjcMethodList], typing.Type[strongarm.macho.macho_definitions.ObjcProtocolRaw64]]`.",
    "message": " `_64_BIT_STRUCT` overrides attribute defined in `ArchIndependentStructure` inconsistently. Type `typing.Type[CSBlobIndexStruct]` is not a subtype of the overridden attribute `typing.Union[typing.Type[strongarm.macho.macho_definitions.CFString64], typing.Type[strongarm.macho.macho_definitions.DylibCommand], typing.Type[strongarm.macho.macho_definitions.MachoDyldInfoCommand], typing.Type[strongarm.macho.macho_definitions.MachoDysymtabCommand], typing.Type[strongarm.macho.macho_definitions.MachoEncryptionInfo64Command], typing.Type[strongarm.macho.macho_definitions.MachoHeader64], typing.Type[strongarm.macho.macho_definitions.MachoLinkeditDataCommand], typing.Type[strongarm.macho.macho_definitions.MachoLoadCommand], typing.Type[strongarm.macho.macho_definitions.MachoNlist64], typing.Type[strongarm.macho.macho_definitions.MachoSection64Raw], typing.Type[strongarm.macho.macho_definitions.MachoSegmentCommand64], typing.Type[strongarm.macho.macho_definitions.MachoSymtabCommand], typing.Type[strongarm.macho.macho_definitions.ObjcCategoryRaw64], typing.Type[strongarm.macho.macho_definitions.ObjcClassRaw64], typing.Type[strongarm.macho.macho_definitions.ObjcDataRaw64], typing.Type[strongarm.macho.macho_definitions.ObjcMethod64], typing.Type[strongarm.macho.macho_definitions.ObjcMethodList], typing.Type[strongarm.macho.macho_definitions.ObjcProtocolRaw64]]`.",
    "rule_id": "Inconsistent override [15]",
    "warning_line_no": 80,
    "warning_line": "    _64_BIT_STRUCT = CSBlobIndexStruct"
  },
  {
    "project": "datatheorem/strongarm",
    "commit": "ab620d78b4ce7f933cedc25960307f2c3b03c1a8",
    "filename": "strongarm/macho/codesign/codesign_parser.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/datatheorem-strongarm/strongarm/macho/codesign/codesign_parser.py",
    "file_hunks_size": 5,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "strongarm/macho/codesign/codesign_parser.py:24:8 Incompatible attribute type [8]: Attribute `entitlements` declared in class `CodesignParser` has type `bytearray` but is used as type `None`.",
    "message": " Attribute `entitlements` declared in class `CodesignParser` has type `bytearray` but is used as type `None`.",
    "rule_id": "Incompatible attribute type [8]",
    "warning_line_no": 24,
    "warning_line": "        self.entitlements: bytearray = None",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "# -*- coding: utf-8 -*-\nfrom strongarm.debug_util import DebugUtil\n",
        "source_code_len": 67,
        "target_code": "# -*- coding: utf-8 -*-\nfrom typing import Optional\n\nfrom strongarm.debug_util import DebugUtil\n",
        "target_code_len": 96,
        "diff_format": "@@ -1,2 +1,4 @@\n # -*- coding: utf-8 -*-\n+from typing import Optional\n+\n from strongarm.debug_util import DebugUtil\n",
        "source_code_with_indent": "# -*- coding: utf-8 -*-\nfrom strongarm.debug_util import DebugUtil\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "# -*- coding: utf-8 -*-\nfrom typing import Optional\n\nfrom strongarm.debug_util import DebugUtil\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n    def __init__(self, binary: MachoBinary):\n        self.binary = binary\n        self.entitlements: bytearray = None\n        self.signing_identifier: str = None\n        self.signing_team_id: str = None\n\n",
        "source_code_len": 205,
        "target_code": "\n    def __init__(self, binary: MachoBinary) -> None:\n        self.binary = binary\n        self.entitlements: Optional[bytearray] = None\n        self.signing_identifier: Optional[str] = None\n        self.signing_team_id: Optional[str] = None\n\n",
        "target_code_len": 243,
        "diff_format": "@@ -21,7 +23,7 @@\n \n-    def __init__(self, binary: MachoBinary):\n+    def __init__(self, binary: MachoBinary) -> None:\n         self.binary = binary\n-        self.entitlements: bytearray = None\n-        self.signing_identifier: str = None\n-        self.signing_team_id: str = None\n+        self.entitlements: Optional[bytearray] = None\n+        self.signing_identifier: Optional[str] = None\n+        self.signing_team_id: Optional[str] = None\n \n",
        "source_code_with_indent": "\n    def __init__(self, binary: MachoBinary):\n        <IND>self.binary = binary\n        self.entitlements: bytearray = None\n        self.signing_identifier: str = None\n        self.signing_team_id: str = None\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n    def __init__(self, binary: MachoBinary) -> None:\n        <IND>self.binary = binary\n        self.entitlements: Optional[bytearray] = None\n        self.signing_identifier: Optional[str] = None\n        self.signing_team_id: Optional[str] = None\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "datatheorem/strongarm",
    "commit": "ab620d78b4ce7f933cedc25960307f2c3b03c1a8",
    "filename": "strongarm/macho/codesign/codesign_parser.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/datatheorem-strongarm/strongarm/macho/codesign/codesign_parser.py",
    "file_hunks_size": 5,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "strongarm/macho/codesign/codesign_parser.py:25:8 Incompatible attribute type [8]: Attribute `signing_identifier` declared in class `CodesignParser` has type `str` but is used as type `None`.",
    "message": " Attribute `signing_identifier` declared in class `CodesignParser` has type `str` but is used as type `None`.",
    "rule_id": "Incompatible attribute type [8]",
    "warning_line_no": 25,
    "warning_line": "        self.signing_identifier: str = None",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "# -*- coding: utf-8 -*-\nfrom strongarm.debug_util import DebugUtil\n",
        "source_code_len": 67,
        "target_code": "# -*- coding: utf-8 -*-\nfrom typing import Optional\n\nfrom strongarm.debug_util import DebugUtil\n",
        "target_code_len": 96,
        "diff_format": "@@ -1,2 +1,4 @@\n # -*- coding: utf-8 -*-\n+from typing import Optional\n+\n from strongarm.debug_util import DebugUtil\n",
        "source_code_with_indent": "# -*- coding: utf-8 -*-\nfrom strongarm.debug_util import DebugUtil\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "# -*- coding: utf-8 -*-\nfrom typing import Optional\n\nfrom strongarm.debug_util import DebugUtil\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n    def __init__(self, binary: MachoBinary):\n        self.binary = binary\n        self.entitlements: bytearray = None\n        self.signing_identifier: str = None\n        self.signing_team_id: str = None\n\n",
        "source_code_len": 205,
        "target_code": "\n    def __init__(self, binary: MachoBinary) -> None:\n        self.binary = binary\n        self.entitlements: Optional[bytearray] = None\n        self.signing_identifier: Optional[str] = None\n        self.signing_team_id: Optional[str] = None\n\n",
        "target_code_len": 243,
        "diff_format": "@@ -21,7 +23,7 @@\n \n-    def __init__(self, binary: MachoBinary):\n+    def __init__(self, binary: MachoBinary) -> None:\n         self.binary = binary\n-        self.entitlements: bytearray = None\n-        self.signing_identifier: str = None\n-        self.signing_team_id: str = None\n+        self.entitlements: Optional[bytearray] = None\n+        self.signing_identifier: Optional[str] = None\n+        self.signing_team_id: Optional[str] = None\n \n",
        "source_code_with_indent": "\n    def __init__(self, binary: MachoBinary):\n        <IND>self.binary = binary\n        self.entitlements: bytearray = None\n        self.signing_identifier: str = None\n        self.signing_team_id: str = None\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n    def __init__(self, binary: MachoBinary) -> None:\n        <IND>self.binary = binary\n        self.entitlements: Optional[bytearray] = None\n        self.signing_identifier: Optional[str] = None\n        self.signing_team_id: Optional[str] = None\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "datatheorem/strongarm",
    "commit": "ab620d78b4ce7f933cedc25960307f2c3b03c1a8",
    "filename": "strongarm/macho/codesign/codesign_parser.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/datatheorem-strongarm/strongarm/macho/codesign/codesign_parser.py",
    "file_hunks_size": 5,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "strongarm/macho/codesign/codesign_parser.py:26:8 Incompatible attribute type [8]: Attribute `signing_team_id` declared in class `CodesignParser` has type `str` but is used as type `None`.",
    "message": " Attribute `signing_team_id` declared in class `CodesignParser` has type `str` but is used as type `None`.",
    "rule_id": "Incompatible attribute type [8]",
    "warning_line_no": 26,
    "warning_line": "        self.signing_team_id: str = None",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "# -*- coding: utf-8 -*-\nfrom strongarm.debug_util import DebugUtil\n",
        "source_code_len": 67,
        "target_code": "# -*- coding: utf-8 -*-\nfrom typing import Optional\n\nfrom strongarm.debug_util import DebugUtil\n",
        "target_code_len": 96,
        "diff_format": "@@ -1,2 +1,4 @@\n # -*- coding: utf-8 -*-\n+from typing import Optional\n+\n from strongarm.debug_util import DebugUtil\n",
        "source_code_with_indent": "# -*- coding: utf-8 -*-\nfrom strongarm.debug_util import DebugUtil\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "# -*- coding: utf-8 -*-\nfrom typing import Optional\n\nfrom strongarm.debug_util import DebugUtil\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n    def __init__(self, binary: MachoBinary):\n        self.binary = binary\n        self.entitlements: bytearray = None\n        self.signing_identifier: str = None\n        self.signing_team_id: str = None\n\n",
        "source_code_len": 205,
        "target_code": "\n    def __init__(self, binary: MachoBinary) -> None:\n        self.binary = binary\n        self.entitlements: Optional[bytearray] = None\n        self.signing_identifier: Optional[str] = None\n        self.signing_team_id: Optional[str] = None\n\n",
        "target_code_len": 243,
        "diff_format": "@@ -21,7 +23,7 @@\n \n-    def __init__(self, binary: MachoBinary):\n+    def __init__(self, binary: MachoBinary) -> None:\n         self.binary = binary\n-        self.entitlements: bytearray = None\n-        self.signing_identifier: str = None\n-        self.signing_team_id: str = None\n+        self.entitlements: Optional[bytearray] = None\n+        self.signing_identifier: Optional[str] = None\n+        self.signing_team_id: Optional[str] = None\n \n",
        "source_code_with_indent": "\n    def __init__(self, binary: MachoBinary):\n        <IND>self.binary = binary\n        self.entitlements: bytearray = None\n        self.signing_identifier: str = None\n        self.signing_team_id: str = None\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n    def __init__(self, binary: MachoBinary) -> None:\n        <IND>self.binary = binary\n        self.entitlements: Optional[bytearray] = None\n        self.signing_identifier: Optional[str] = None\n        self.signing_team_id: Optional[str] = None\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "datatheorem/strongarm",
    "commit": "ab620d78b4ce7f933cedc25960307f2c3b03c1a8",
    "filename": "strongarm/macho/codesign/codesign_parser.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/datatheorem-strongarm/strongarm/macho/codesign/codesign_parser.py",
    "file_hunks_size": 5,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "strongarm/macho/codesign/codesign_parser.py:114:8 Incompatible attribute type [8]: Attribute `signing_identifier` declared in class `CodesignParser` has type `str` but is used as type `typing.Optional[str]`.",
    "message": " Attribute `signing_identifier` declared in class `CodesignParser` has type `str` but is used as type `typing.Optional[str]`.",
    "rule_id": "Incompatible attribute type [8]",
    "warning_line_no": 114,
    "warning_line": "        self.signing_identifier = identifier_string",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "# -*- coding: utf-8 -*-\nfrom strongarm.debug_util import DebugUtil\n",
        "source_code_len": 67,
        "target_code": "# -*- coding: utf-8 -*-\nfrom typing import Optional\n\nfrom strongarm.debug_util import DebugUtil\n",
        "target_code_len": 96,
        "diff_format": "@@ -1,2 +1,4 @@\n # -*- coding: utf-8 -*-\n+from typing import Optional\n+\n from strongarm.debug_util import DebugUtil\n",
        "source_code_with_indent": "# -*- coding: utf-8 -*-\nfrom strongarm.debug_util import DebugUtil\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "# -*- coding: utf-8 -*-\nfrom typing import Optional\n\nfrom strongarm.debug_util import DebugUtil\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n    def __init__(self, binary: MachoBinary):\n        self.binary = binary\n        self.entitlements: bytearray = None\n        self.signing_identifier: str = None\n        self.signing_team_id: str = None\n\n",
        "source_code_len": 205,
        "target_code": "\n    def __init__(self, binary: MachoBinary) -> None:\n        self.binary = binary\n        self.entitlements: Optional[bytearray] = None\n        self.signing_identifier: Optional[str] = None\n        self.signing_team_id: Optional[str] = None\n\n",
        "target_code_len": 243,
        "diff_format": "@@ -21,7 +23,7 @@\n \n-    def __init__(self, binary: MachoBinary):\n+    def __init__(self, binary: MachoBinary) -> None:\n         self.binary = binary\n-        self.entitlements: bytearray = None\n-        self.signing_identifier: str = None\n-        self.signing_team_id: str = None\n+        self.entitlements: Optional[bytearray] = None\n+        self.signing_identifier: Optional[str] = None\n+        self.signing_team_id: Optional[str] = None\n \n",
        "source_code_with_indent": "\n    def __init__(self, binary: MachoBinary):\n        <IND>self.binary = binary\n        self.entitlements: bytearray = None\n        self.signing_identifier: str = None\n        self.signing_team_id: str = None\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n    def __init__(self, binary: MachoBinary) -> None:\n        <IND>self.binary = binary\n        self.entitlements: Optional[bytearray] = None\n        self.signing_identifier: Optional[str] = None\n        self.signing_team_id: Optional[str] = None\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "datatheorem/strongarm",
    "commit": "ab620d78b4ce7f933cedc25960307f2c3b03c1a8",
    "filename": "strongarm/macho/codesign/codesign_parser.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/datatheorem-strongarm/strongarm/macho/codesign/codesign_parser.py",
    "file_hunks_size": 5,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "strongarm/macho/codesign/codesign_parser.py:122:12 Incompatible attribute type [8]: Attribute `signing_team_id` declared in class `CodesignParser` has type `str` but is used as type `typing.Optional[str]`.",
    "message": " Attribute `signing_team_id` declared in class `CodesignParser` has type `str` but is used as type `typing.Optional[str]`.",
    "rule_id": "Incompatible attribute type [8]",
    "warning_line_no": 122,
    "warning_line": "            self.signing_team_id = team_id_string",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "# -*- coding: utf-8 -*-\nfrom strongarm.debug_util import DebugUtil\n",
        "source_code_len": 67,
        "target_code": "# -*- coding: utf-8 -*-\nfrom typing import Optional\n\nfrom strongarm.debug_util import DebugUtil\n",
        "target_code_len": 96,
        "diff_format": "@@ -1,2 +1,4 @@\n # -*- coding: utf-8 -*-\n+from typing import Optional\n+\n from strongarm.debug_util import DebugUtil\n",
        "source_code_with_indent": "# -*- coding: utf-8 -*-\nfrom strongarm.debug_util import DebugUtil\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "# -*- coding: utf-8 -*-\nfrom typing import Optional\n\nfrom strongarm.debug_util import DebugUtil\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n    def __init__(self, binary: MachoBinary):\n        self.binary = binary\n        self.entitlements: bytearray = None\n        self.signing_identifier: str = None\n        self.signing_team_id: str = None\n\n",
        "source_code_len": 205,
        "target_code": "\n    def __init__(self, binary: MachoBinary) -> None:\n        self.binary = binary\n        self.entitlements: Optional[bytearray] = None\n        self.signing_identifier: Optional[str] = None\n        self.signing_team_id: Optional[str] = None\n\n",
        "target_code_len": 243,
        "diff_format": "@@ -21,7 +23,7 @@\n \n-    def __init__(self, binary: MachoBinary):\n+    def __init__(self, binary: MachoBinary) -> None:\n         self.binary = binary\n-        self.entitlements: bytearray = None\n-        self.signing_identifier: str = None\n-        self.signing_team_id: str = None\n+        self.entitlements: Optional[bytearray] = None\n+        self.signing_identifier: Optional[str] = None\n+        self.signing_team_id: Optional[str] = None\n \n",
        "source_code_with_indent": "\n    def __init__(self, binary: MachoBinary):\n        <IND>self.binary = binary\n        self.entitlements: bytearray = None\n        self.signing_identifier: str = None\n        self.signing_team_id: str = None\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n    def __init__(self, binary: MachoBinary) -> None:\n        <IND>self.binary = binary\n        self.entitlements: Optional[bytearray] = None\n        self.signing_identifier: Optional[str] = None\n        self.signing_team_id: Optional[str] = None\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "datatheorem/strongarm",
    "commit": "ab620d78b4ce7f933cedc25960307f2c3b03c1a8",
    "filename": "strongarm/macho/macho_analyzer.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/datatheorem-strongarm/strongarm/macho/macho_analyzer.py",
    "file_hunks_size": 14,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": true,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "strongarm/macho/macho_analyzer.py:40:8 Incompatible attribute type [8]: Attribute `_dyld_info_parser` declared in class `MachoAnalyzer` has type `DyldInfoParser` but is used as type `None`.",
    "message": " Attribute `_dyld_info_parser` declared in class `MachoAnalyzer` has type `DyldInfoParser` but is used as type `None`.",
    "rule_id": "Incompatible attribute type [8]",
    "warning_line_no": 40,
    "warning_line": "        self._dyld_info_parser: DyldInfoParser = None",
    "min_patch": [
      {
        "hunk_fit_TFix": true,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "        # Worker to parse dyld bytecode stream and extract dyld stub addresses to the DyldBoundSymbol they represent\n        self._dyld_info_parser: DyldInfoParser = None\n        # Each __stubs function calls a single dyld stub address, which has a corresponding DyldBoundSymbol.\n        # Map of each __stub function to the associated name of the DyldBoundSymbol\n        self._imported_symbol_addresses_to_names: Dict[int, str] = None\n\n",
        "source_code_len": 437,
        "target_code": "        # Worker to parse dyld bytecode stream and extract dyld stub addresses to the DyldBoundSymbol they represent\n        self._dyld_info_parser: Optional[DyldInfoParser] = None\n        # Each __stubs function calls a single dyld stub address, which has a corresponding DyldBoundSymbol.\n        # Map of each __stub function to the associated name of the DyldBoundSymbol\n        self._imported_symbol_addresses_to_names: Dict[int, str] = {}\n\n",
        "target_code_len": 445,
        "diff_format": "@@ -39,6 +42,6 @@\n         # Worker to parse dyld bytecode stream and extract dyld stub addresses to the DyldBoundSymbol they represent\n-        self._dyld_info_parser: DyldInfoParser = None\n+        self._dyld_info_parser: Optional[DyldInfoParser] = None\n         # Each __stubs function calls a single dyld stub address, which has a corresponding DyldBoundSymbol.\n         # Map of each __stub function to the associated name of the DyldBoundSymbol\n-        self._imported_symbol_addresses_to_names: Dict[int, str] = None\n+        self._imported_symbol_addresses_to_names: Dict[int, str] = {}\n \n",
        "source_code_with_indent": "        # Worker to parse dyld bytecode stream and extract dyld stub addresses to the DyldBoundSymbol they represent\n        self._dyld_info_parser: DyldInfoParser = None\n        # Each __stubs function calls a single dyld stub address, which has a corresponding DyldBoundSymbol.\n        # Map of each __stub function to the associated name of the DyldBoundSymbol\n        self._imported_symbol_addresses_to_names: Dict[int, str] = None\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "        # Worker to parse dyld bytecode stream and extract dyld stub addresses to the DyldBoundSymbol they represent\n        self._dyld_info_parser: Optional[DyldInfoParser] = None\n        # Each __stubs function calls a single dyld stub address, which has a corresponding DyldBoundSymbol.\n        # Map of each __stub function to the associated name of the DyldBoundSymbol\n        self._imported_symbol_addresses_to_names: Dict[int, str] = {}\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "datatheorem/strongarm",
    "commit": "ab620d78b4ce7f933cedc25960307f2c3b03c1a8",
    "filename": "strongarm/macho/macho_analyzer.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/datatheorem-strongarm/strongarm/macho/macho_analyzer.py",
    "file_hunks_size": 14,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": true,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "strongarm/macho/macho_analyzer.py:43:8 Incompatible attribute type [8]: Attribute `_imported_symbol_addresses_to_names` declared in class `MachoAnalyzer` has type `Dict[int, str]` but is used as type `None`.",
    "message": " Attribute `_imported_symbol_addresses_to_names` declared in class `MachoAnalyzer` has type `Dict[int, str]` but is used as type `None`.",
    "rule_id": "Incompatible attribute type [8]",
    "warning_line_no": 43,
    "warning_line": "        self._imported_symbol_addresses_to_names: Dict[int, str] = None",
    "min_patch": [
      {
        "hunk_fit_TFix": true,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "        # Worker to parse dyld bytecode stream and extract dyld stub addresses to the DyldBoundSymbol they represent\n        self._dyld_info_parser: DyldInfoParser = None\n        # Each __stubs function calls a single dyld stub address, which has a corresponding DyldBoundSymbol.\n        # Map of each __stub function to the associated name of the DyldBoundSymbol\n        self._imported_symbol_addresses_to_names: Dict[int, str] = None\n\n",
        "source_code_len": 437,
        "target_code": "        # Worker to parse dyld bytecode stream and extract dyld stub addresses to the DyldBoundSymbol they represent\n        self._dyld_info_parser: Optional[DyldInfoParser] = None\n        # Each __stubs function calls a single dyld stub address, which has a corresponding DyldBoundSymbol.\n        # Map of each __stub function to the associated name of the DyldBoundSymbol\n        self._imported_symbol_addresses_to_names: Dict[int, str] = {}\n\n",
        "target_code_len": 445,
        "diff_format": "@@ -39,6 +42,6 @@\n         # Worker to parse dyld bytecode stream and extract dyld stub addresses to the DyldBoundSymbol they represent\n-        self._dyld_info_parser: DyldInfoParser = None\n+        self._dyld_info_parser: Optional[DyldInfoParser] = None\n         # Each __stubs function calls a single dyld stub address, which has a corresponding DyldBoundSymbol.\n         # Map of each __stub function to the associated name of the DyldBoundSymbol\n-        self._imported_symbol_addresses_to_names: Dict[int, str] = None\n+        self._imported_symbol_addresses_to_names: Dict[int, str] = {}\n \n",
        "source_code_with_indent": "        # Worker to parse dyld bytecode stream and extract dyld stub addresses to the DyldBoundSymbol they represent\n        self._dyld_info_parser: DyldInfoParser = None\n        # Each __stubs function calls a single dyld stub address, which has a corresponding DyldBoundSymbol.\n        # Map of each __stub function to the associated name of the DyldBoundSymbol\n        self._imported_symbol_addresses_to_names: Dict[int, str] = None\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "        # Worker to parse dyld bytecode stream and extract dyld stub addresses to the DyldBoundSymbol they represent\n        self._dyld_info_parser: Optional[DyldInfoParser] = None\n        # Each __stubs function calls a single dyld stub address, which has a corresponding DyldBoundSymbol.\n        # Map of each __stub function to the associated name of the DyldBoundSymbol\n        self._imported_symbol_addresses_to_names: Dict[int, str] = {}\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "datatheorem/strongarm",
    "commit": "ab620d78b4ce7f933cedc25960307f2c3b03c1a8",
    "filename": "strongarm/macho/macho_analyzer.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/datatheorem-strongarm/strongarm/macho/macho_analyzer.py",
    "file_hunks_size": 14,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": true,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "strongarm/macho/macho_analyzer.py:50:8 Incompatible attribute type [8]: Attribute `_objc_helper` declared in class `MachoAnalyzer` has type `ObjcRuntimeDataParser` but is used as type `None`.",
    "message": " Attribute `_objc_helper` declared in class `MachoAnalyzer` has type `ObjcRuntimeDataParser` but is used as type `None`.",
    "rule_id": "Incompatible attribute type [8]",
    "warning_line_no": 50,
    "warning_line": "        self._objc_helper: ObjcRuntimeDataParser = None",
    "min_patch": [
      {
        "hunk_fit_TFix": true,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "        self.imp_stubs = MachoImpStubsParser(binary, self.cs).imp_stubs\n        self._objc_helper: ObjcRuntimeDataParser = None\n        self._objc_method_list: List[ObjcMethodInfo] = None\n\n",
        "source_code_len": 189,
        "target_code": "        self.imp_stubs = MachoImpStubsParser(binary, self.cs).imp_stubs\n        self._objc_helper: Optional[ObjcRuntimeDataParser] = None\n        self._objc_method_list: List[ObjcMethodInfo] = []\n\n",
        "target_code_len": 197,
        "diff_format": "@@ -49,4 +52,4 @@\n         self.imp_stubs = MachoImpStubsParser(binary, self.cs).imp_stubs\n-        self._objc_helper: ObjcRuntimeDataParser = None\n-        self._objc_method_list: List[ObjcMethodInfo] = None\n+        self._objc_helper: Optional[ObjcRuntimeDataParser] = None\n+        self._objc_method_list: List[ObjcMethodInfo] = []\n \n",
        "source_code_with_indent": "        self.imp_stubs = MachoImpStubsParser(binary, self.cs).imp_stubs\n        self._objc_helper: ObjcRuntimeDataParser = None\n        self._objc_method_list: List[ObjcMethodInfo] = None\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "        self.imp_stubs = MachoImpStubsParser(binary, self.cs).imp_stubs\n        self._objc_helper: Optional[ObjcRuntimeDataParser] = None\n        self._objc_method_list: List[ObjcMethodInfo] = []\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "datatheorem/strongarm",
    "commit": "ab620d78b4ce7f933cedc25960307f2c3b03c1a8",
    "filename": "strongarm/macho/macho_analyzer.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/datatheorem-strongarm/strongarm/macho/macho_analyzer.py",
    "file_hunks_size": 14,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": true,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "strongarm/macho/macho_analyzer.py:51:8 Incompatible attribute type [8]: Attribute `_objc_method_list` declared in class `MachoAnalyzer` has type `List[strongarm.objc.objc_analyzer.ObjcMethodInfo]` but is used as type `None`.",
    "message": " Attribute `_objc_method_list` declared in class `MachoAnalyzer` has type `List[strongarm.objc.objc_analyzer.ObjcMethodInfo]` but is used as type `None`.",
    "rule_id": "Incompatible attribute type [8]",
    "warning_line_no": 51,
    "warning_line": "        self._objc_method_list: List[ObjcMethodInfo] = None",
    "min_patch": [
      {
        "hunk_fit_TFix": true,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "        self.imp_stubs = MachoImpStubsParser(binary, self.cs).imp_stubs\n        self._objc_helper: ObjcRuntimeDataParser = None\n        self._objc_method_list: List[ObjcMethodInfo] = None\n\n",
        "source_code_len": 189,
        "target_code": "        self.imp_stubs = MachoImpStubsParser(binary, self.cs).imp_stubs\n        self._objc_helper: Optional[ObjcRuntimeDataParser] = None\n        self._objc_method_list: List[ObjcMethodInfo] = []\n\n",
        "target_code_len": 197,
        "diff_format": "@@ -49,4 +52,4 @@\n         self.imp_stubs = MachoImpStubsParser(binary, self.cs).imp_stubs\n-        self._objc_helper: ObjcRuntimeDataParser = None\n-        self._objc_method_list: List[ObjcMethodInfo] = None\n+        self._objc_helper: Optional[ObjcRuntimeDataParser] = None\n+        self._objc_method_list: List[ObjcMethodInfo] = []\n \n",
        "source_code_with_indent": "        self.imp_stubs = MachoImpStubsParser(binary, self.cs).imp_stubs\n        self._objc_helper: ObjcRuntimeDataParser = None\n        self._objc_method_list: List[ObjcMethodInfo] = None\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "        self.imp_stubs = MachoImpStubsParser(binary, self.cs).imp_stubs\n        self._objc_helper: Optional[ObjcRuntimeDataParser] = None\n        self._objc_method_list: List[ObjcMethodInfo] = []\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "datatheorem/strongarm",
    "commit": "ab620d78b4ce7f933cedc25960307f2c3b03c1a8",
    "filename": "strongarm/macho/macho_analyzer.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/datatheorem-strongarm/strongarm/macho/macho_analyzer.py",
    "file_hunks_size": 14,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": true,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "strongarm/macho/macho_analyzer.py:89:8 Incompatible variable type [9]: categories is declared to have type `List[ObjcCategory]` but is used as type `List[ObjcClass]`.",
    "message": " categories is declared to have type `List[ObjcCategory]` but is used as type `List[ObjcClass]`.",
    "rule_id": "Incompatible variable type [9]",
    "warning_line_no": 89,
    "warning_line": "        categories: List[ObjcCategory] = [c for c in all_classes if type(c) == ObjcCategory]",
    "min_patch": [
      {
        "hunk_fit_TFix": true,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "        all_classes = self.objc_classes()\n        categories: List[ObjcCategory] = [c for c in all_classes if type(c) == ObjcCategory]\n        return categories\n",
        "source_code_len": 161,
        "target_code": "        all_classes = self.objc_classes()\n        categories: List[ObjcCategory] = [c for c in all_classes if isinstance(c, ObjcCategory)]\n        return categories\n",
        "target_code_len": 165,
        "diff_format": "@@ -88,3 +91,3 @@\n         all_classes = self.objc_classes()\n-        categories: List[ObjcCategory] = [c for c in all_classes if type(c) == ObjcCategory]\n+        categories: List[ObjcCategory] = [c for c in all_classes if isinstance(c, ObjcCategory)]\n         return categories\n",
        "source_code_with_indent": "        all_classes = self.objc_classes()\n        categories: List[ObjcCategory] = [c for c in all_classes if type(c) == ObjcCategory]\n        return categories\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "        all_classes = self.objc_classes()\n        categories: List[ObjcCategory] = [c for c in all_classes if isinstance(c, ObjcCategory)]\n        return categories\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "datatheorem/strongarm",
    "commit": "ab620d78b4ce7f933cedc25960307f2c3b03c1a8",
    "filename": "strongarm/macho/macho_analyzer.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/datatheorem-strongarm/strongarm/macho/macho_analyzer.py",
    "file_hunks_size": 14,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": true,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "strongarm/macho/macho_analyzer.py:327:12 Incompatible return type [7]: Expected `Set[str]` but got `List[Variable[_T]]`.",
    "message": " Expected `Set[str]` but got `List[Variable[_T]]`.",
    "rule_id": "Incompatible return type [7]",
    "warning_line_no": 327,
    "warning_line": "            return []",
    "min_patch": [
      {
        "hunk_fit_TFix": true,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "        if '__cstring' not in self.binary.sections:\n            return []\n\n",
        "source_code_len": 75,
        "target_code": "        if '__cstring' not in self.binary.sections:\n            return set()\n\n",
        "target_code_len": 78,
        "diff_format": "@@ -326,3 +318,3 @@\n         if '__cstring' not in self.binary.sections:\n-            return []\n+            return set()\n \n",
        "source_code_with_indent": "        if '__cstring' not in self.binary.sections:\n            <IND>return []\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "        if '__cstring' not in self.binary.sections:\n            <IND>return set()\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "datatheorem/strongarm",
    "commit": "ab620d78b4ce7f933cedc25960307f2c3b03c1a8",
    "filename": "strongarm/macho/macho_binary.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/datatheorem-strongarm/strongarm/macho/macho_binary.py",
    "file_hunks_size": 33,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "strongarm/macho/macho_binary.py:63:8 Incompatible attribute type [8]: Attribute `is_64bit` declared in class `MachoBinary` has type `bool` but is used as type `None`.",
    "message": " Attribute `is_64bit` declared in class `MachoBinary` has type `bool` but is used as type `None`.",
    "rule_id": "Incompatible attribute type [8]",
    "warning_line_no": 63,
    "warning_line": "        self.is_64bit: bool = None",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "# -*- coding: utf-8 -*-\nfrom typing import List, Tuple, Optional, Dict, Union\n\n",
        "source_code_len": 79,
        "target_code": "# -*- coding: utf-8 -*-\nfrom typing import List, Dict, Tuple, Any, Type, Optional\nfrom typing import TYPE_CHECKING\n\nfrom ctypes import c_uint64, c_uint32, sizeof\n\n",
        "target_code_len": 163,
        "diff_format": "@@ -1,3 +1,6 @@\n # -*- coding: utf-8 -*-\n-from typing import List, Tuple, Optional, Dict, Union\n+from typing import List, Dict, Tuple, Any, Type, Optional\n+from typing import TYPE_CHECKING\n+\n+from ctypes import c_uint64, c_uint32, sizeof\n \n",
        "source_code_with_indent": "# -*- coding: utf-8 -*-\nfrom typing import List, Tuple, Optional, Dict, Union\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "# -*- coding: utf-8 -*-\nfrom typing import List, Dict, Tuple, Any, Type, Optional\nfrom typing import TYPE_CHECKING\n\nfrom ctypes import c_uint64, c_uint32, sizeof\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "from strongarm.macho.macho_load_commands import MachoLoadCommands\nfrom strongarm.macho.arch_independent_structs import \\\n    MachoHeaderStruct, \\\n    MachoSegmentCommandStruct, \\\n    MachoSectionRawStruct, \\\n    MachoEncryptionInfoStruct, \\\n    MachoNlistStruct, \\\n    CFStringStruct, \\\n    DylibCommandStruct, \\\n    MachoLoadCommandStruct, \\\n    MachoSymtabCommandStruct, \\\n    MachoDysymtabCommandStruct, \\\n    MachoDyldInfoCommandStruct, \\\n    MachoLinkeditDataCommandStruct\n\nfrom ctypes import c_uint64, c_uint32, sizeof\n\n",
        "source_code_len": 526,
        "target_code": "from strongarm.macho.macho_load_commands import MachoLoadCommands\nfrom strongarm.macho.arch_independent_structs import (\n    ArchIndependentStructure,\n    MachoHeaderStruct,\n    MachoSegmentCommandStruct,\n    MachoSectionRawStruct,\n    MachoEncryptionInfoStruct,\n    MachoNlistStruct,\n    CFStringStruct,\n    DylibCommandStruct,\n    MachoLoadCommandStruct,\n    MachoSymtabCommandStruct,\n    MachoDysymtabCommandStruct,\n    MachoDyldInfoCommandStruct,\n    MachoLinkeditDataCommandStruct,\n)\n\nif TYPE_CHECKING:\n    from strongarm.macho.codesign import CodesignParser\n\n",
        "target_code_len": 565,
        "diff_format": "@@ -7,17 +10,20 @@\n from strongarm.macho.macho_load_commands import MachoLoadCommands\n-from strongarm.macho.arch_independent_structs import \\\n-    MachoHeaderStruct, \\\n-    MachoSegmentCommandStruct, \\\n-    MachoSectionRawStruct, \\\n-    MachoEncryptionInfoStruct, \\\n-    MachoNlistStruct, \\\n-    CFStringStruct, \\\n-    DylibCommandStruct, \\\n-    MachoLoadCommandStruct, \\\n-    MachoSymtabCommandStruct, \\\n-    MachoDysymtabCommandStruct, \\\n-    MachoDyldInfoCommandStruct, \\\n-    MachoLinkeditDataCommandStruct\n-\n-from ctypes import c_uint64, c_uint32, sizeof\n+from strongarm.macho.arch_independent_structs import (\n+    ArchIndependentStructure,\n+    MachoHeaderStruct,\n+    MachoSegmentCommandStruct,\n+    MachoSectionRawStruct,\n+    MachoEncryptionInfoStruct,\n+    MachoNlistStruct,\n+    CFStringStruct,\n+    DylibCommandStruct,\n+    MachoLoadCommandStruct,\n+    MachoSymtabCommandStruct,\n+    MachoDysymtabCommandStruct,\n+    MachoDyldInfoCommandStruct,\n+    MachoLinkeditDataCommandStruct,\n+)\n+\n+if TYPE_CHECKING:\n+    from strongarm.macho.codesign import CodesignParser\n \n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent": "from strongarm.macho.macho_load_commands import MachoLoadCommands\nfrom strongarm.macho.arch_independent_structs import (\n    ArchIndependentStructure,\n    MachoHeaderStruct,\n    MachoSegmentCommandStruct,\n    MachoSectionRawStruct,\n    MachoEncryptionInfoStruct,\n    MachoNlistStruct,\n    CFStringStruct,\n    DylibCommandStruct,\n    MachoLoadCommandStruct,\n    MachoSymtabCommandStruct,\n    MachoDysymtabCommandStruct,\n    MachoDyldInfoCommandStruct,\n    MachoLinkeditDataCommandStruct,\n)\n\nif TYPE_CHECKING:\n    <IND>from strongarm.macho.codesign import CodesignParser\n\n",
        "target_code_with_indent_exact_match": true,
        "source_code_with_indent": "from strongarm.macho.macho_load_commands import MachoLoadCommands\nfrom strongarm.macho.arch_independent_structs import    MachoHeaderStruct,    MachoSegmentCommandStruct,    MachoSectionRawStruct,    MachoEncryptionInfoStruct,    MachoNlistStruct,    CFStringStruct,    DylibCommandStruct,    MachoLoadCommandStruct,    MachoSymtabCommandStruct,    MachoDysymtabCommandStruct,    MachoDyldInfoCommandStruct,    MachoLinkeditDataCommandStruct\n\nfrom ctypes import c_uint64, c_uint32, sizeof\n\n"
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "        # generic Mach-O header info\n        self.is_64bit: bool = None\n        self.is_swap: bool = None\n        self.cpu_type: CPU_TYPE = None\n        self._load_commands_end_addr = None\n\n        # Mach-O header data\n        self.header: MachoHeaderStruct = None\n        self.header_flags: List[int] = None\n        self.file_type: MachoFileType = None\n\n        # segment and section commands from Mach-O header\n        self.segment_commands: Dict[str, MachoSegmentCommandStruct] = None\n        self.sections: Dict[str, MachoSection] = None\n        # also store specific interesting sections which are useful to us\n        self.dysymtab: MachoDysymtabCommandStruct = None\n        self.symtab: MachoSymtabCommandStruct = None\n        self.encryption_info: MachoEncryptionInfoStruct = None\n        self.dyld_info: MachoDyldInfoCommandStruct = None\n        self.load_dylib_commands: List[DylibCommandStruct] = None\n        self.code_signature_cmd: MachoLinkeditDataCommandStruct = None\n\n        self.__codesign_parser: CodesignParser = None\n\n",
        "source_code_len": 1040,
        "target_code": "        # generic Mach-O header info\n        self.is_64bit: bool = False\n        self.is_swap: bool = False\n        self.cpu_type: CPU_TYPE = CPU_TYPE.UNKNOWN\n        self._load_commands_end_addr = 0\n\n        # Mach-O header data\n        self._header: Optional[MachoHeaderStruct] = None\n        self.header_flags: List[int] = []\n        self.file_type: MachoFileType = MachoFileType.MH_EXECUTE\n\n        # segment and section commands from Mach-O header\n        self.segment_commands: Dict[str, MachoSegmentCommandStruct] = {}\n        self.sections: Dict[str, MachoSection] = {}\n        # also store specific interesting sections which are useful to us\n        self._dysymtab: Optional[MachoDysymtabCommandStruct] = None\n        self._symtab: Optional[MachoSymtabCommandStruct] = None\n        self._encryption_info: Optional[MachoEncryptionInfoStruct] = None\n        self._dyld_info: Optional[MachoDyldInfoCommandStruct] = None\n        self.load_dylib_commands: List[DylibCommandStruct] = []\n        self._code_signature_cmd: Optional[MachoLinkeditDataCommandStruct] = None\n\n        self.__codesign_parser: Optional[CodesignParser] = None\n\n",
        "target_code_len": 1139,
        "diff_format": "@@ -62,24 +68,24 @@\n         # generic Mach-O header info\n-        self.is_64bit: bool = None\n-        self.is_swap: bool = None\n-        self.cpu_type: CPU_TYPE = None\n-        self._load_commands_end_addr = None\n+        self.is_64bit: bool = False\n+        self.is_swap: bool = False\n+        self.cpu_type: CPU_TYPE = CPU_TYPE.UNKNOWN\n+        self._load_commands_end_addr = 0\n \n         # Mach-O header data\n-        self.header: MachoHeaderStruct = None\n-        self.header_flags: List[int] = None\n-        self.file_type: MachoFileType = None\n+        self._header: Optional[MachoHeaderStruct] = None\n+        self.header_flags: List[int] = []\n+        self.file_type: MachoFileType = MachoFileType.MH_EXECUTE\n \n         # segment and section commands from Mach-O header\n-        self.segment_commands: Dict[str, MachoSegmentCommandStruct] = None\n-        self.sections: Dict[str, MachoSection] = None\n+        self.segment_commands: Dict[str, MachoSegmentCommandStruct] = {}\n+        self.sections: Dict[str, MachoSection] = {}\n         # also store specific interesting sections which are useful to us\n-        self.dysymtab: MachoDysymtabCommandStruct = None\n-        self.symtab: MachoSymtabCommandStruct = None\n-        self.encryption_info: MachoEncryptionInfoStruct = None\n-        self.dyld_info: MachoDyldInfoCommandStruct = None\n-        self.load_dylib_commands: List[DylibCommandStruct] = None\n-        self.code_signature_cmd: MachoLinkeditDataCommandStruct = None\n-\n-        self.__codesign_parser: CodesignParser = None\n+        self._dysymtab: Optional[MachoDysymtabCommandStruct] = None\n+        self._symtab: Optional[MachoSymtabCommandStruct] = None\n+        self._encryption_info: Optional[MachoEncryptionInfoStruct] = None\n+        self._dyld_info: Optional[MachoDyldInfoCommandStruct] = None\n+        self.load_dylib_commands: List[DylibCommandStruct] = []\n+        self._code_signature_cmd: Optional[MachoLinkeditDataCommandStruct] = None\n+\n+        self.__codesign_parser: Optional[CodesignParser] = None\n \n",
        "source_code_with_indent": "        # generic Mach-O header info\n        self.is_64bit: bool = None\n        self.is_swap: bool = None\n        self.cpu_type: CPU_TYPE = None\n        self._load_commands_end_addr = None\n\n        # Mach-O header data\n        self.header: MachoHeaderStruct = None\n        self.header_flags: List[int] = None\n        self.file_type: MachoFileType = None\n\n        # segment and section commands from Mach-O header\n        self.segment_commands: Dict[str, MachoSegmentCommandStruct] = None\n        self.sections: Dict[str, MachoSection] = None\n        # also store specific interesting sections which are useful to us\n        self.dysymtab: MachoDysymtabCommandStruct = None\n        self.symtab: MachoSymtabCommandStruct = None\n        self.encryption_info: MachoEncryptionInfoStruct = None\n        self.dyld_info: MachoDyldInfoCommandStruct = None\n        self.load_dylib_commands: List[DylibCommandStruct] = None\n        self.code_signature_cmd: MachoLinkeditDataCommandStruct = None\n\n        self.__codesign_parser: CodesignParser = None\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "        # generic Mach-O header info\n        self.is_64bit: bool = False\n        self.is_swap: bool = False\n        self.cpu_type: CPU_TYPE = CPU_TYPE.UNKNOWN\n        self._load_commands_end_addr = 0\n\n        # Mach-O header data\n        self._header: Optional[MachoHeaderStruct] = None\n        self.header_flags: List[int] = []\n        self.file_type: MachoFileType = MachoFileType.MH_EXECUTE\n\n        # segment and section commands from Mach-O header\n        self.segment_commands: Dict[str, MachoSegmentCommandStruct] = {}\n        self.sections: Dict[str, MachoSection] = {}\n        # also store specific interesting sections which are useful to us\n        self._dysymtab: Optional[MachoDysymtabCommandStruct] = None\n        self._symtab: Optional[MachoSymtabCommandStruct] = None\n        self._encryption_info: Optional[MachoEncryptionInfoStruct] = None\n        self._dyld_info: Optional[MachoDyldInfoCommandStruct] = None\n        self.load_dylib_commands: List[DylibCommandStruct] = []\n        self._code_signature_cmd: Optional[MachoLinkeditDataCommandStruct] = None\n\n        self.__codesign_parser: Optional[CodesignParser] = None\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    @property\n    def slice_magic(self) -> c_uint32:\n        \"\"\"Read magic number identifier from this Mach-O slice\n        \"\"\"\n        return self.read_word(0, virtual=False, word_type=c_uint32)\n\n",
        "source_code_len": 197,
        "target_code": "    @property\n    def slice_magic(self) -> int:\n        \"\"\"Read magic number identifier from this Mach-O slice\n        \"\"\"\n        magic = self.read_word(0, virtual=False, word_type=c_uint32)\n        if magic:\n            return magic\n        else:\n            raise ValueError('Could not read magic value.')\n\n",
        "target_code_len": 310,
        "diff_format": "@@ -124,6 +131,10 @@\n     @property\n-    def slice_magic(self) -> c_uint32:\n+    def slice_magic(self) -> int:\n         \"\"\"Read magic number identifier from this Mach-O slice\n         \"\"\"\n-        return self.read_word(0, virtual=False, word_type=c_uint32)\n+        magic = self.read_word(0, virtual=False, word_type=c_uint32)\n+        if magic:\n+            return magic\n+        else:\n+            raise ValueError('Could not read magic value.')\n \n",
        "source_code_with_indent": "    <DED>@property\n    def slice_magic(self) -> c_uint32:\n        <IND>\"\"\"Read magic number identifier from this Mach-O slice\n        \"\"\"\n        return self.read_word(0, virtual=False, word_type=c_uint32)\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    <DED>@property\n    def slice_magic(self) -> int:\n        <IND>\"\"\"Read magic number identifier from this Mach-O slice\n        \"\"\"\n        magic = self.read_word(0, virtual=False, word_type=c_uint32)\n        if magic:\n            <IND>return magic\n        <DED>else:\n            <IND>raise ValueError('Could not read magic value.')\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "        \"\"\"\n        self.header = MachoHeaderStruct(self, 0)\n\n",
        "source_code_len": 62,
        "target_code": "        \"\"\"\n        self._header = MachoHeaderStruct(self, 0)\n\n",
        "target_code_len": 63,
        "diff_format": "@@ -152,3 +163,3 @@\n         \"\"\"\n-        self.header = MachoHeaderStruct(self, 0)\n+        self._header = MachoHeaderStruct(self, 0)\n \n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\n        self.header = MachoHeaderStruct(self, 0)\n\n",
        "target_code_with_indent": "\n        self._header = MachoHeaderStruct(self, 0)\n\n"
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "                                      MachoLoadCommands.LC_ENCRYPTION_INFO_64]:\n                self.encryption_info = MachoEncryptionInfoStruct(self, offset)\n\n            elif load_command.cmd == MachoLoadCommands.LC_SYMTAB:\n                self.symtab = MachoSymtabCommandStruct(self, offset)\n\n            elif load_command.cmd == MachoLoadCommands.LC_DYSYMTAB:\n                self.dysymtab = MachoDysymtabCommandStruct(self, offset)\n\n            elif load_command.cmd in [MachoLoadCommands.LC_DYLD_INFO, MachoLoadCommands.LC_DYLD_INFO_ONLY]:\n                self.dyld_info = MachoDyldInfoCommandStruct(self, offset)\n\n",
        "source_code_len": 621,
        "target_code": "                                      MachoLoadCommands.LC_ENCRYPTION_INFO_64]:\n                self._encryption_info = MachoEncryptionInfoStruct(self, offset)\n\n            elif load_command.cmd == MachoLoadCommands.LC_SYMTAB:\n                self._symtab = MachoSymtabCommandStruct(self, offset)\n\n            elif load_command.cmd == MachoLoadCommands.LC_DYSYMTAB:\n                self._dysymtab = MachoDysymtabCommandStruct(self, offset)\n\n            elif load_command.cmd in [MachoLoadCommands.LC_DYLD_INFO, MachoLoadCommands.LC_DYLD_INFO_ONLY]:\n                self._dyld_info = MachoDyldInfoCommandStruct(self, offset)\n\n",
        "target_code_len": 625,
        "diff_format": "@@ -208,12 +220,12 @@\n                                       MachoLoadCommands.LC_ENCRYPTION_INFO_64]:\n-                self.encryption_info = MachoEncryptionInfoStruct(self, offset)\n+                self._encryption_info = MachoEncryptionInfoStruct(self, offset)\n \n             elif load_command.cmd == MachoLoadCommands.LC_SYMTAB:\n-                self.symtab = MachoSymtabCommandStruct(self, offset)\n+                self._symtab = MachoSymtabCommandStruct(self, offset)\n \n             elif load_command.cmd == MachoLoadCommands.LC_DYSYMTAB:\n-                self.dysymtab = MachoDysymtabCommandStruct(self, offset)\n+                self._dysymtab = MachoDysymtabCommandStruct(self, offset)\n \n             elif load_command.cmd in [MachoLoadCommands.LC_DYLD_INFO, MachoLoadCommands.LC_DYLD_INFO_ONLY]:\n-                self.dyld_info = MachoDyldInfoCommandStruct(self, offset)\n+                self._dyld_info = MachoDyldInfoCommandStruct(self, offset)\n \n",
        "source_code_with_indent": "                                      MachoLoadCommands.LC_ENCRYPTION_INFO_64]:\n                <IND>self.encryption_info = MachoEncryptionInfoStruct(self, offset)\n\n            <DED>elif load_command.cmd == MachoLoadCommands.LC_SYMTAB:\n                <IND>self.symtab = MachoSymtabCommandStruct(self, offset)\n\n            <DED>elif load_command.cmd == MachoLoadCommands.LC_DYSYMTAB:\n                <IND>self.dysymtab = MachoDysymtabCommandStruct(self, offset)\n\n            <DED>elif load_command.cmd in [MachoLoadCommands.LC_DYLD_INFO, MachoLoadCommands.LC_DYLD_INFO_ONLY]:\n                <IND>self.dyld_info = MachoDyldInfoCommandStruct(self, offset)\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "                                      MachoLoadCommands.LC_ENCRYPTION_INFO_64]:\n                <IND>self._encryption_info = MachoEncryptionInfoStruct(self, offset)\n\n            <DED>elif load_command.cmd == MachoLoadCommands.LC_SYMTAB:\n                <IND>self._symtab = MachoSymtabCommandStruct(self, offset)\n\n            <DED>elif load_command.cmd == MachoLoadCommands.LC_DYSYMTAB:\n                <IND>self._dysymtab = MachoDysymtabCommandStruct(self, offset)\n\n            <DED>elif load_command.cmd in [MachoLoadCommands.LC_DYLD_INFO, MachoLoadCommands.LC_DYLD_INFO_ONLY]:\n                <IND>self._dyld_info = MachoDyldInfoCommandStruct(self, offset)\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "            elif load_command.cmd == MachoLoadCommands.LC_CODE_SIGNATURE:\n                self.code_signature_cmd = MachoLinkeditDataCommandStruct(self, offset)\n\n",
        "source_code_len": 162,
        "target_code": "            elif load_command.cmd == MachoLoadCommands.LC_CODE_SIGNATURE:\n                self._code_signature_cmd = MachoLinkeditDataCommandStruct(self, offset)\n\n",
        "target_code_len": 163,
        "diff_format": "@@ -225,3 +236,3 @@\n             elif load_command.cmd == MachoLoadCommands.LC_CODE_SIGNATURE:\n-                self.code_signature_cmd = MachoLinkeditDataCommandStruct(self, offset)\n+                self._code_signature_cmd = MachoLinkeditDataCommandStruct(self, offset)\n \n",
        "source_code_with_indent": "            <DED>elif load_command.cmd == MachoLoadCommands.LC_CODE_SIGNATURE:\n                <IND>self.code_signature_cmd = MachoLinkeditDataCommandStruct(self, offset)\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "            <DED>elif load_command.cmd == MachoLoadCommands.LC_CODE_SIGNATURE:\n                <IND>self._code_signature_cmd = MachoLinkeditDataCommandStruct(self, offset)\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "            indirect_symtab_entry = self.read_word(indirect_symtab_off, virtual=False, word_type=c_uint32)\n            indirect_symtab.append(int(indirect_symtab_entry.value))\n            # traverse to next pointer\n",
        "source_code_len": 215,
        "target_code": "            indirect_symtab_entry = self.read_word(indirect_symtab_off, virtual=False, word_type=c_uint32)\n            if not indirect_symtab_entry:\n                continue\n            indirect_symtab.append(int(indirect_symtab_entry))\n            # traverse to next pointer\n",
        "target_code_len": 276,
        "diff_format": "@@ -398,3 +410,5 @@\n             indirect_symtab_entry = self.read_word(indirect_symtab_off, virtual=False, word_type=c_uint32)\n-            indirect_symtab.append(int(indirect_symtab_entry.value))\n+            if not indirect_symtab_entry:\n+                continue\n+            indirect_symtab.append(int(indirect_symtab_entry))\n             # traverse to next pointer\n",
        "source_code_with_indent": "            <IND>indirect_symtab_entry = self.read_word(indirect_symtab_off, virtual=False, word_type=c_uint32)\n            indirect_symtab.append(int(indirect_symtab_entry.value))\n            # traverse to next pointer\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "            <IND>indirect_symtab_entry = self.read_word(indirect_symtab_off, virtual=False, word_type=c_uint32)\n            if not indirect_symtab_entry:\n                <IND>continue\n            <DED>indirect_symtab.append(int(indirect_symtab_entry))\n            # traverse to next pointer\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "                  address: int,\n                  virtual=True,\n                  word_type=None) -> Optional[Union[c_uint32, c_uint64]]:\n        \"\"\"Attempt to read a word from the binary at a virtual address. Returns None if the address is invalid.\n",
        "source_code_len": 250,
        "target_code": "                  address: int,\n                  virtual: bool = True,\n                  word_type: Any = None) -> Optional[int]:\n        \"\"\"Attempt to read a word from the binary at a virtual address. Returns None if the address is invalid.\n",
        "target_code_len": 243,
        "diff_format": "@@ -568,4 +595,4 @@\n                   address: int,\n-                  virtual=True,\n-                  word_type=None) -> Optional[Union[c_uint32, c_uint64]]:\n+                  virtual: bool = True,\n+                  word_type: Any = None) -> Optional[int]:\n         \"\"\"Attempt to read a word from the binary at a virtual address. Returns None if the address is invalid.\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "                  address: int,\n                  virtual=True,\n                  word_type=None) -> Optional[Union[c_uint32, c_uint64]]:\n        <IND>",
        "target_code_with_indent": "                  address: int,\n                  virtual: bool = True,\n                  word_type: Any = None) -> Optional[int]:\n        <IND>"
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    @property\n    def _codesign_parser(self) -> 'CodesignParser':\n        from strongarm.macho.codesign import CodesignParser\n        if not self.__codesign_parser:\n",
        "source_code_len": 165,
        "target_code": "    @property\n    def header(self) -> MachoHeaderStruct:\n        if self._header:\n            return self._header\n        else:\n            raise RuntimeError('Failed to parse Mach-O')\n\n    @property\n    def dysymtab(self) -> MachoDysymtabCommandStruct:\n        if self._dysymtab:\n            return self._dysymtab\n        else:\n            raise RuntimeError('Failed to parse Mach-O')\n\n    @property\n    def symtab(self) -> MachoSymtabCommandStruct:\n        if self._symtab:\n            return self._symtab\n        else:\n            raise RuntimeError('Failed to parse Mach-O')\n\n    @property\n    def encryption_info(self) -> MachoEncryptionInfoStruct:\n        if self._encryption_info:\n            return self._encryption_info\n        else:\n            raise RuntimeError('Failed to parse Mach-O')\n\n    @property\n    def dyld_info(self) -> MachoDyldInfoCommandStruct:\n        if self._dyld_info:\n            return self._dyld_info\n        else:\n            raise RuntimeError('Failed to parse Mach-O')\n\n    @property\n    def code_signature_cmd(self) -> MachoLinkeditDataCommandStruct:\n        if self._code_signature_cmd:\n            return self._code_signature_cmd\n        else:\n            raise RuntimeError('Failed to parse Mach-O')\n\n    @property\n    def _codesign_parser(self) -> 'CodesignParser':\n        if not self.__codesign_parser:\n",
        "target_code_len": 1345,
        "diff_format": "@@ -583,4 +613,45 @@\n     @property\n+    def header(self) -> MachoHeaderStruct:\n+        if self._header:\n+            return self._header\n+        else:\n+            raise RuntimeError('Failed to parse Mach-O')\n+\n+    @property\n+    def dysymtab(self) -> MachoDysymtabCommandStruct:\n+        if self._dysymtab:\n+            return self._dysymtab\n+        else:\n+            raise RuntimeError('Failed to parse Mach-O')\n+\n+    @property\n+    def symtab(self) -> MachoSymtabCommandStruct:\n+        if self._symtab:\n+            return self._symtab\n+        else:\n+            raise RuntimeError('Failed to parse Mach-O')\n+\n+    @property\n+    def encryption_info(self) -> MachoEncryptionInfoStruct:\n+        if self._encryption_info:\n+            return self._encryption_info\n+        else:\n+            raise RuntimeError('Failed to parse Mach-O')\n+\n+    @property\n+    def dyld_info(self) -> MachoDyldInfoCommandStruct:\n+        if self._dyld_info:\n+            return self._dyld_info\n+        else:\n+            raise RuntimeError('Failed to parse Mach-O')\n+\n+    @property\n+    def code_signature_cmd(self) -> MachoLinkeditDataCommandStruct:\n+        if self._code_signature_cmd:\n+            return self._code_signature_cmd\n+        else:\n+            raise RuntimeError('Failed to parse Mach-O')\n+\n+    @property\n     def _codesign_parser(self) -> 'CodesignParser':\n-        from strongarm.macho.codesign import CodesignParser\n         if not self.__codesign_parser:\n",
        "source_code_with_indent": "    <DED>@property\n    def _codesign_parser(self) -> 'CodesignParser':\n        <IND>from strongarm.macho.codesign import CodesignParser\n        if not self.__codesign_parser:\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    <DED>@property\n    def header(self) -> MachoHeaderStruct:\n        <IND>if self._header:\n            <IND>return self._header\n        <DED>else:\n            <IND>raise RuntimeError('Failed to parse Mach-O')\n\n    <DED><DED>@property\n    def dysymtab(self) -> MachoDysymtabCommandStruct:\n        <IND>if self._dysymtab:\n            <IND>return self._dysymtab\n        <DED>else:\n            <IND>raise RuntimeError('Failed to parse Mach-O')\n\n    <DED><DED>@property\n    def symtab(self) -> MachoSymtabCommandStruct:\n        <IND>if self._symtab:\n            <IND>return self._symtab\n        <DED>else:\n            <IND>raise RuntimeError('Failed to parse Mach-O')\n\n    <DED><DED>@property\n    def encryption_info(self) -> MachoEncryptionInfoStruct:\n        <IND>if self._encryption_info:\n            <IND>return self._encryption_info\n        <DED>else:\n            <IND>raise RuntimeError('Failed to parse Mach-O')\n\n    <DED><DED>@property\n    def dyld_info(self) -> MachoDyldInfoCommandStruct:\n        <IND>if self._dyld_info:\n            <IND>return self._dyld_info\n        <DED>else:\n            <IND>raise RuntimeError('Failed to parse Mach-O')\n\n    <DED><DED>@property\n    def code_signature_cmd(self) -> MachoLinkeditDataCommandStruct:\n        <IND>if self._code_signature_cmd:\n            <IND>return self._code_signature_cmd\n        <DED>else:\n            <IND>raise RuntimeError('Failed to parse Mach-O')\n\n    <DED><DED>@property\n    def _codesign_parser(self) -> 'CodesignParser':\n        <IND>if not self.__codesign_parser:\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "datatheorem/strongarm",
    "commit": "ab620d78b4ce7f933cedc25960307f2c3b03c1a8",
    "filename": "strongarm/macho/macho_binary.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/datatheorem-strongarm/strongarm/macho/macho_binary.py",
    "file_hunks_size": 33,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "strongarm/macho/macho_binary.py:64:8 Incompatible attribute type [8]: Attribute `is_swap` declared in class `MachoBinary` has type `bool` but is used as type `None`.",
    "message": " Attribute `is_swap` declared in class `MachoBinary` has type `bool` but is used as type `None`.",
    "rule_id": "Incompatible attribute type [8]",
    "warning_line_no": 64,
    "warning_line": "        self.is_swap: bool = None",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "# -*- coding: utf-8 -*-\nfrom typing import List, Tuple, Optional, Dict, Union\n\n",
        "source_code_len": 79,
        "target_code": "# -*- coding: utf-8 -*-\nfrom typing import List, Dict, Tuple, Any, Type, Optional\nfrom typing import TYPE_CHECKING\n\nfrom ctypes import c_uint64, c_uint32, sizeof\n\n",
        "target_code_len": 163,
        "diff_format": "@@ -1,3 +1,6 @@\n # -*- coding: utf-8 -*-\n-from typing import List, Tuple, Optional, Dict, Union\n+from typing import List, Dict, Tuple, Any, Type, Optional\n+from typing import TYPE_CHECKING\n+\n+from ctypes import c_uint64, c_uint32, sizeof\n \n",
        "source_code_with_indent": "# -*- coding: utf-8 -*-\nfrom typing import List, Tuple, Optional, Dict, Union\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "# -*- coding: utf-8 -*-\nfrom typing import List, Dict, Tuple, Any, Type, Optional\nfrom typing import TYPE_CHECKING\n\nfrom ctypes import c_uint64, c_uint32, sizeof\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "from strongarm.macho.macho_load_commands import MachoLoadCommands\nfrom strongarm.macho.arch_independent_structs import \\\n    MachoHeaderStruct, \\\n    MachoSegmentCommandStruct, \\\n    MachoSectionRawStruct, \\\n    MachoEncryptionInfoStruct, \\\n    MachoNlistStruct, \\\n    CFStringStruct, \\\n    DylibCommandStruct, \\\n    MachoLoadCommandStruct, \\\n    MachoSymtabCommandStruct, \\\n    MachoDysymtabCommandStruct, \\\n    MachoDyldInfoCommandStruct, \\\n    MachoLinkeditDataCommandStruct\n\nfrom ctypes import c_uint64, c_uint32, sizeof\n\n",
        "source_code_len": 526,
        "target_code": "from strongarm.macho.macho_load_commands import MachoLoadCommands\nfrom strongarm.macho.arch_independent_structs import (\n    ArchIndependentStructure,\n    MachoHeaderStruct,\n    MachoSegmentCommandStruct,\n    MachoSectionRawStruct,\n    MachoEncryptionInfoStruct,\n    MachoNlistStruct,\n    CFStringStruct,\n    DylibCommandStruct,\n    MachoLoadCommandStruct,\n    MachoSymtabCommandStruct,\n    MachoDysymtabCommandStruct,\n    MachoDyldInfoCommandStruct,\n    MachoLinkeditDataCommandStruct,\n)\n\nif TYPE_CHECKING:\n    from strongarm.macho.codesign import CodesignParser\n\n",
        "target_code_len": 565,
        "diff_format": "@@ -7,17 +10,20 @@\n from strongarm.macho.macho_load_commands import MachoLoadCommands\n-from strongarm.macho.arch_independent_structs import \\\n-    MachoHeaderStruct, \\\n-    MachoSegmentCommandStruct, \\\n-    MachoSectionRawStruct, \\\n-    MachoEncryptionInfoStruct, \\\n-    MachoNlistStruct, \\\n-    CFStringStruct, \\\n-    DylibCommandStruct, \\\n-    MachoLoadCommandStruct, \\\n-    MachoSymtabCommandStruct, \\\n-    MachoDysymtabCommandStruct, \\\n-    MachoDyldInfoCommandStruct, \\\n-    MachoLinkeditDataCommandStruct\n-\n-from ctypes import c_uint64, c_uint32, sizeof\n+from strongarm.macho.arch_independent_structs import (\n+    ArchIndependentStructure,\n+    MachoHeaderStruct,\n+    MachoSegmentCommandStruct,\n+    MachoSectionRawStruct,\n+    MachoEncryptionInfoStruct,\n+    MachoNlistStruct,\n+    CFStringStruct,\n+    DylibCommandStruct,\n+    MachoLoadCommandStruct,\n+    MachoSymtabCommandStruct,\n+    MachoDysymtabCommandStruct,\n+    MachoDyldInfoCommandStruct,\n+    MachoLinkeditDataCommandStruct,\n+)\n+\n+if TYPE_CHECKING:\n+    from strongarm.macho.codesign import CodesignParser\n \n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent": "from strongarm.macho.macho_load_commands import MachoLoadCommands\nfrom strongarm.macho.arch_independent_structs import (\n    ArchIndependentStructure,\n    MachoHeaderStruct,\n    MachoSegmentCommandStruct,\n    MachoSectionRawStruct,\n    MachoEncryptionInfoStruct,\n    MachoNlistStruct,\n    CFStringStruct,\n    DylibCommandStruct,\n    MachoLoadCommandStruct,\n    MachoSymtabCommandStruct,\n    MachoDysymtabCommandStruct,\n    MachoDyldInfoCommandStruct,\n    MachoLinkeditDataCommandStruct,\n)\n\nif TYPE_CHECKING:\n    <IND>from strongarm.macho.codesign import CodesignParser\n\n",
        "target_code_with_indent_exact_match": true,
        "source_code_with_indent": "from strongarm.macho.macho_load_commands import MachoLoadCommands\nfrom strongarm.macho.arch_independent_structs import    MachoHeaderStruct,    MachoSegmentCommandStruct,    MachoSectionRawStruct,    MachoEncryptionInfoStruct,    MachoNlistStruct,    CFStringStruct,    DylibCommandStruct,    MachoLoadCommandStruct,    MachoSymtabCommandStruct,    MachoDysymtabCommandStruct,    MachoDyldInfoCommandStruct,    MachoLinkeditDataCommandStruct\n\nfrom ctypes import c_uint64, c_uint32, sizeof\n\n"
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "        # generic Mach-O header info\n        self.is_64bit: bool = None\n        self.is_swap: bool = None\n        self.cpu_type: CPU_TYPE = None\n        self._load_commands_end_addr = None\n\n        # Mach-O header data\n        self.header: MachoHeaderStruct = None\n        self.header_flags: List[int] = None\n        self.file_type: MachoFileType = None\n\n        # segment and section commands from Mach-O header\n        self.segment_commands: Dict[str, MachoSegmentCommandStruct] = None\n        self.sections: Dict[str, MachoSection] = None\n        # also store specific interesting sections which are useful to us\n        self.dysymtab: MachoDysymtabCommandStruct = None\n        self.symtab: MachoSymtabCommandStruct = None\n        self.encryption_info: MachoEncryptionInfoStruct = None\n        self.dyld_info: MachoDyldInfoCommandStruct = None\n        self.load_dylib_commands: List[DylibCommandStruct] = None\n        self.code_signature_cmd: MachoLinkeditDataCommandStruct = None\n\n        self.__codesign_parser: CodesignParser = None\n\n",
        "source_code_len": 1040,
        "target_code": "        # generic Mach-O header info\n        self.is_64bit: bool = False\n        self.is_swap: bool = False\n        self.cpu_type: CPU_TYPE = CPU_TYPE.UNKNOWN\n        self._load_commands_end_addr = 0\n\n        # Mach-O header data\n        self._header: Optional[MachoHeaderStruct] = None\n        self.header_flags: List[int] = []\n        self.file_type: MachoFileType = MachoFileType.MH_EXECUTE\n\n        # segment and section commands from Mach-O header\n        self.segment_commands: Dict[str, MachoSegmentCommandStruct] = {}\n        self.sections: Dict[str, MachoSection] = {}\n        # also store specific interesting sections which are useful to us\n        self._dysymtab: Optional[MachoDysymtabCommandStruct] = None\n        self._symtab: Optional[MachoSymtabCommandStruct] = None\n        self._encryption_info: Optional[MachoEncryptionInfoStruct] = None\n        self._dyld_info: Optional[MachoDyldInfoCommandStruct] = None\n        self.load_dylib_commands: List[DylibCommandStruct] = []\n        self._code_signature_cmd: Optional[MachoLinkeditDataCommandStruct] = None\n\n        self.__codesign_parser: Optional[CodesignParser] = None\n\n",
        "target_code_len": 1139,
        "diff_format": "@@ -62,24 +68,24 @@\n         # generic Mach-O header info\n-        self.is_64bit: bool = None\n-        self.is_swap: bool = None\n-        self.cpu_type: CPU_TYPE = None\n-        self._load_commands_end_addr = None\n+        self.is_64bit: bool = False\n+        self.is_swap: bool = False\n+        self.cpu_type: CPU_TYPE = CPU_TYPE.UNKNOWN\n+        self._load_commands_end_addr = 0\n \n         # Mach-O header data\n-        self.header: MachoHeaderStruct = None\n-        self.header_flags: List[int] = None\n-        self.file_type: MachoFileType = None\n+        self._header: Optional[MachoHeaderStruct] = None\n+        self.header_flags: List[int] = []\n+        self.file_type: MachoFileType = MachoFileType.MH_EXECUTE\n \n         # segment and section commands from Mach-O header\n-        self.segment_commands: Dict[str, MachoSegmentCommandStruct] = None\n-        self.sections: Dict[str, MachoSection] = None\n+        self.segment_commands: Dict[str, MachoSegmentCommandStruct] = {}\n+        self.sections: Dict[str, MachoSection] = {}\n         # also store specific interesting sections which are useful to us\n-        self.dysymtab: MachoDysymtabCommandStruct = None\n-        self.symtab: MachoSymtabCommandStruct = None\n-        self.encryption_info: MachoEncryptionInfoStruct = None\n-        self.dyld_info: MachoDyldInfoCommandStruct = None\n-        self.load_dylib_commands: List[DylibCommandStruct] = None\n-        self.code_signature_cmd: MachoLinkeditDataCommandStruct = None\n-\n-        self.__codesign_parser: CodesignParser = None\n+        self._dysymtab: Optional[MachoDysymtabCommandStruct] = None\n+        self._symtab: Optional[MachoSymtabCommandStruct] = None\n+        self._encryption_info: Optional[MachoEncryptionInfoStruct] = None\n+        self._dyld_info: Optional[MachoDyldInfoCommandStruct] = None\n+        self.load_dylib_commands: List[DylibCommandStruct] = []\n+        self._code_signature_cmd: Optional[MachoLinkeditDataCommandStruct] = None\n+\n+        self.__codesign_parser: Optional[CodesignParser] = None\n \n",
        "source_code_with_indent": "        # generic Mach-O header info\n        self.is_64bit: bool = None\n        self.is_swap: bool = None\n        self.cpu_type: CPU_TYPE = None\n        self._load_commands_end_addr = None\n\n        # Mach-O header data\n        self.header: MachoHeaderStruct = None\n        self.header_flags: List[int] = None\n        self.file_type: MachoFileType = None\n\n        # segment and section commands from Mach-O header\n        self.segment_commands: Dict[str, MachoSegmentCommandStruct] = None\n        self.sections: Dict[str, MachoSection] = None\n        # also store specific interesting sections which are useful to us\n        self.dysymtab: MachoDysymtabCommandStruct = None\n        self.symtab: MachoSymtabCommandStruct = None\n        self.encryption_info: MachoEncryptionInfoStruct = None\n        self.dyld_info: MachoDyldInfoCommandStruct = None\n        self.load_dylib_commands: List[DylibCommandStruct] = None\n        self.code_signature_cmd: MachoLinkeditDataCommandStruct = None\n\n        self.__codesign_parser: CodesignParser = None\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "        # generic Mach-O header info\n        self.is_64bit: bool = False\n        self.is_swap: bool = False\n        self.cpu_type: CPU_TYPE = CPU_TYPE.UNKNOWN\n        self._load_commands_end_addr = 0\n\n        # Mach-O header data\n        self._header: Optional[MachoHeaderStruct] = None\n        self.header_flags: List[int] = []\n        self.file_type: MachoFileType = MachoFileType.MH_EXECUTE\n\n        # segment and section commands from Mach-O header\n        self.segment_commands: Dict[str, MachoSegmentCommandStruct] = {}\n        self.sections: Dict[str, MachoSection] = {}\n        # also store specific interesting sections which are useful to us\n        self._dysymtab: Optional[MachoDysymtabCommandStruct] = None\n        self._symtab: Optional[MachoSymtabCommandStruct] = None\n        self._encryption_info: Optional[MachoEncryptionInfoStruct] = None\n        self._dyld_info: Optional[MachoDyldInfoCommandStruct] = None\n        self.load_dylib_commands: List[DylibCommandStruct] = []\n        self._code_signature_cmd: Optional[MachoLinkeditDataCommandStruct] = None\n\n        self.__codesign_parser: Optional[CodesignParser] = None\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    @property\n    def slice_magic(self) -> c_uint32:\n        \"\"\"Read magic number identifier from this Mach-O slice\n        \"\"\"\n        return self.read_word(0, virtual=False, word_type=c_uint32)\n\n",
        "source_code_len": 197,
        "target_code": "    @property\n    def slice_magic(self) -> int:\n        \"\"\"Read magic number identifier from this Mach-O slice\n        \"\"\"\n        magic = self.read_word(0, virtual=False, word_type=c_uint32)\n        if magic:\n            return magic\n        else:\n            raise ValueError('Could not read magic value.')\n\n",
        "target_code_len": 310,
        "diff_format": "@@ -124,6 +131,10 @@\n     @property\n-    def slice_magic(self) -> c_uint32:\n+    def slice_magic(self) -> int:\n         \"\"\"Read magic number identifier from this Mach-O slice\n         \"\"\"\n-        return self.read_word(0, virtual=False, word_type=c_uint32)\n+        magic = self.read_word(0, virtual=False, word_type=c_uint32)\n+        if magic:\n+            return magic\n+        else:\n+            raise ValueError('Could not read magic value.')\n \n",
        "source_code_with_indent": "    <DED>@property\n    def slice_magic(self) -> c_uint32:\n        <IND>\"\"\"Read magic number identifier from this Mach-O slice\n        \"\"\"\n        return self.read_word(0, virtual=False, word_type=c_uint32)\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    <DED>@property\n    def slice_magic(self) -> int:\n        <IND>\"\"\"Read magic number identifier from this Mach-O slice\n        \"\"\"\n        magic = self.read_word(0, virtual=False, word_type=c_uint32)\n        if magic:\n            <IND>return magic\n        <DED>else:\n            <IND>raise ValueError('Could not read magic value.')\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "        \"\"\"\n        self.header = MachoHeaderStruct(self, 0)\n\n",
        "source_code_len": 62,
        "target_code": "        \"\"\"\n        self._header = MachoHeaderStruct(self, 0)\n\n",
        "target_code_len": 63,
        "diff_format": "@@ -152,3 +163,3 @@\n         \"\"\"\n-        self.header = MachoHeaderStruct(self, 0)\n+        self._header = MachoHeaderStruct(self, 0)\n \n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\n        self.header = MachoHeaderStruct(self, 0)\n\n",
        "target_code_with_indent": "\n        self._header = MachoHeaderStruct(self, 0)\n\n"
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "                                      MachoLoadCommands.LC_ENCRYPTION_INFO_64]:\n                self.encryption_info = MachoEncryptionInfoStruct(self, offset)\n\n            elif load_command.cmd == MachoLoadCommands.LC_SYMTAB:\n                self.symtab = MachoSymtabCommandStruct(self, offset)\n\n            elif load_command.cmd == MachoLoadCommands.LC_DYSYMTAB:\n                self.dysymtab = MachoDysymtabCommandStruct(self, offset)\n\n            elif load_command.cmd in [MachoLoadCommands.LC_DYLD_INFO, MachoLoadCommands.LC_DYLD_INFO_ONLY]:\n                self.dyld_info = MachoDyldInfoCommandStruct(self, offset)\n\n",
        "source_code_len": 621,
        "target_code": "                                      MachoLoadCommands.LC_ENCRYPTION_INFO_64]:\n                self._encryption_info = MachoEncryptionInfoStruct(self, offset)\n\n            elif load_command.cmd == MachoLoadCommands.LC_SYMTAB:\n                self._symtab = MachoSymtabCommandStruct(self, offset)\n\n            elif load_command.cmd == MachoLoadCommands.LC_DYSYMTAB:\n                self._dysymtab = MachoDysymtabCommandStruct(self, offset)\n\n            elif load_command.cmd in [MachoLoadCommands.LC_DYLD_INFO, MachoLoadCommands.LC_DYLD_INFO_ONLY]:\n                self._dyld_info = MachoDyldInfoCommandStruct(self, offset)\n\n",
        "target_code_len": 625,
        "diff_format": "@@ -208,12 +220,12 @@\n                                       MachoLoadCommands.LC_ENCRYPTION_INFO_64]:\n-                self.encryption_info = MachoEncryptionInfoStruct(self, offset)\n+                self._encryption_info = MachoEncryptionInfoStruct(self, offset)\n \n             elif load_command.cmd == MachoLoadCommands.LC_SYMTAB:\n-                self.symtab = MachoSymtabCommandStruct(self, offset)\n+                self._symtab = MachoSymtabCommandStruct(self, offset)\n \n             elif load_command.cmd == MachoLoadCommands.LC_DYSYMTAB:\n-                self.dysymtab = MachoDysymtabCommandStruct(self, offset)\n+                self._dysymtab = MachoDysymtabCommandStruct(self, offset)\n \n             elif load_command.cmd in [MachoLoadCommands.LC_DYLD_INFO, MachoLoadCommands.LC_DYLD_INFO_ONLY]:\n-                self.dyld_info = MachoDyldInfoCommandStruct(self, offset)\n+                self._dyld_info = MachoDyldInfoCommandStruct(self, offset)\n \n",
        "source_code_with_indent": "                                      MachoLoadCommands.LC_ENCRYPTION_INFO_64]:\n                <IND>self.encryption_info = MachoEncryptionInfoStruct(self, offset)\n\n            <DED>elif load_command.cmd == MachoLoadCommands.LC_SYMTAB:\n                <IND>self.symtab = MachoSymtabCommandStruct(self, offset)\n\n            <DED>elif load_command.cmd == MachoLoadCommands.LC_DYSYMTAB:\n                <IND>self.dysymtab = MachoDysymtabCommandStruct(self, offset)\n\n            <DED>elif load_command.cmd in [MachoLoadCommands.LC_DYLD_INFO, MachoLoadCommands.LC_DYLD_INFO_ONLY]:\n                <IND>self.dyld_info = MachoDyldInfoCommandStruct(self, offset)\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "                                      MachoLoadCommands.LC_ENCRYPTION_INFO_64]:\n                <IND>self._encryption_info = MachoEncryptionInfoStruct(self, offset)\n\n            <DED>elif load_command.cmd == MachoLoadCommands.LC_SYMTAB:\n                <IND>self._symtab = MachoSymtabCommandStruct(self, offset)\n\n            <DED>elif load_command.cmd == MachoLoadCommands.LC_DYSYMTAB:\n                <IND>self._dysymtab = MachoDysymtabCommandStruct(self, offset)\n\n            <DED>elif load_command.cmd in [MachoLoadCommands.LC_DYLD_INFO, MachoLoadCommands.LC_DYLD_INFO_ONLY]:\n                <IND>self._dyld_info = MachoDyldInfoCommandStruct(self, offset)\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "            elif load_command.cmd == MachoLoadCommands.LC_CODE_SIGNATURE:\n                self.code_signature_cmd = MachoLinkeditDataCommandStruct(self, offset)\n\n",
        "source_code_len": 162,
        "target_code": "            elif load_command.cmd == MachoLoadCommands.LC_CODE_SIGNATURE:\n                self._code_signature_cmd = MachoLinkeditDataCommandStruct(self, offset)\n\n",
        "target_code_len": 163,
        "diff_format": "@@ -225,3 +236,3 @@\n             elif load_command.cmd == MachoLoadCommands.LC_CODE_SIGNATURE:\n-                self.code_signature_cmd = MachoLinkeditDataCommandStruct(self, offset)\n+                self._code_signature_cmd = MachoLinkeditDataCommandStruct(self, offset)\n \n",
        "source_code_with_indent": "            <DED>elif load_command.cmd == MachoLoadCommands.LC_CODE_SIGNATURE:\n                <IND>self.code_signature_cmd = MachoLinkeditDataCommandStruct(self, offset)\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "            <DED>elif load_command.cmd == MachoLoadCommands.LC_CODE_SIGNATURE:\n                <IND>self._code_signature_cmd = MachoLinkeditDataCommandStruct(self, offset)\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "            indirect_symtab_entry = self.read_word(indirect_symtab_off, virtual=False, word_type=c_uint32)\n            indirect_symtab.append(int(indirect_symtab_entry.value))\n            # traverse to next pointer\n",
        "source_code_len": 215,
        "target_code": "            indirect_symtab_entry = self.read_word(indirect_symtab_off, virtual=False, word_type=c_uint32)\n            if not indirect_symtab_entry:\n                continue\n            indirect_symtab.append(int(indirect_symtab_entry))\n            # traverse to next pointer\n",
        "target_code_len": 276,
        "diff_format": "@@ -398,3 +410,5 @@\n             indirect_symtab_entry = self.read_word(indirect_symtab_off, virtual=False, word_type=c_uint32)\n-            indirect_symtab.append(int(indirect_symtab_entry.value))\n+            if not indirect_symtab_entry:\n+                continue\n+            indirect_symtab.append(int(indirect_symtab_entry))\n             # traverse to next pointer\n",
        "source_code_with_indent": "            <IND>indirect_symtab_entry = self.read_word(indirect_symtab_off, virtual=False, word_type=c_uint32)\n            indirect_symtab.append(int(indirect_symtab_entry.value))\n            # traverse to next pointer\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "            <IND>indirect_symtab_entry = self.read_word(indirect_symtab_off, virtual=False, word_type=c_uint32)\n            if not indirect_symtab_entry:\n                <IND>continue\n            <DED>indirect_symtab.append(int(indirect_symtab_entry))\n            # traverse to next pointer\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "                  address: int,\n                  virtual=True,\n                  word_type=None) -> Optional[Union[c_uint32, c_uint64]]:\n        \"\"\"Attempt to read a word from the binary at a virtual address. Returns None if the address is invalid.\n",
        "source_code_len": 250,
        "target_code": "                  address: int,\n                  virtual: bool = True,\n                  word_type: Any = None) -> Optional[int]:\n        \"\"\"Attempt to read a word from the binary at a virtual address. Returns None if the address is invalid.\n",
        "target_code_len": 243,
        "diff_format": "@@ -568,4 +595,4 @@\n                   address: int,\n-                  virtual=True,\n-                  word_type=None) -> Optional[Union[c_uint32, c_uint64]]:\n+                  virtual: bool = True,\n+                  word_type: Any = None) -> Optional[int]:\n         \"\"\"Attempt to read a word from the binary at a virtual address. Returns None if the address is invalid.\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "                  address: int,\n                  virtual=True,\n                  word_type=None) -> Optional[Union[c_uint32, c_uint64]]:\n        <IND>",
        "target_code_with_indent": "                  address: int,\n                  virtual: bool = True,\n                  word_type: Any = None) -> Optional[int]:\n        <IND>"
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    @property\n    def _codesign_parser(self) -> 'CodesignParser':\n        from strongarm.macho.codesign import CodesignParser\n        if not self.__codesign_parser:\n",
        "source_code_len": 165,
        "target_code": "    @property\n    def header(self) -> MachoHeaderStruct:\n        if self._header:\n            return self._header\n        else:\n            raise RuntimeError('Failed to parse Mach-O')\n\n    @property\n    def dysymtab(self) -> MachoDysymtabCommandStruct:\n        if self._dysymtab:\n            return self._dysymtab\n        else:\n            raise RuntimeError('Failed to parse Mach-O')\n\n    @property\n    def symtab(self) -> MachoSymtabCommandStruct:\n        if self._symtab:\n            return self._symtab\n        else:\n            raise RuntimeError('Failed to parse Mach-O')\n\n    @property\n    def encryption_info(self) -> MachoEncryptionInfoStruct:\n        if self._encryption_info:\n            return self._encryption_info\n        else:\n            raise RuntimeError('Failed to parse Mach-O')\n\n    @property\n    def dyld_info(self) -> MachoDyldInfoCommandStruct:\n        if self._dyld_info:\n            return self._dyld_info\n        else:\n            raise RuntimeError('Failed to parse Mach-O')\n\n    @property\n    def code_signature_cmd(self) -> MachoLinkeditDataCommandStruct:\n        if self._code_signature_cmd:\n            return self._code_signature_cmd\n        else:\n            raise RuntimeError('Failed to parse Mach-O')\n\n    @property\n    def _codesign_parser(self) -> 'CodesignParser':\n        if not self.__codesign_parser:\n",
        "target_code_len": 1345,
        "diff_format": "@@ -583,4 +613,45 @@\n     @property\n+    def header(self) -> MachoHeaderStruct:\n+        if self._header:\n+            return self._header\n+        else:\n+            raise RuntimeError('Failed to parse Mach-O')\n+\n+    @property\n+    def dysymtab(self) -> MachoDysymtabCommandStruct:\n+        if self._dysymtab:\n+            return self._dysymtab\n+        else:\n+            raise RuntimeError('Failed to parse Mach-O')\n+\n+    @property\n+    def symtab(self) -> MachoSymtabCommandStruct:\n+        if self._symtab:\n+            return self._symtab\n+        else:\n+            raise RuntimeError('Failed to parse Mach-O')\n+\n+    @property\n+    def encryption_info(self) -> MachoEncryptionInfoStruct:\n+        if self._encryption_info:\n+            return self._encryption_info\n+        else:\n+            raise RuntimeError('Failed to parse Mach-O')\n+\n+    @property\n+    def dyld_info(self) -> MachoDyldInfoCommandStruct:\n+        if self._dyld_info:\n+            return self._dyld_info\n+        else:\n+            raise RuntimeError('Failed to parse Mach-O')\n+\n+    @property\n+    def code_signature_cmd(self) -> MachoLinkeditDataCommandStruct:\n+        if self._code_signature_cmd:\n+            return self._code_signature_cmd\n+        else:\n+            raise RuntimeError('Failed to parse Mach-O')\n+\n+    @property\n     def _codesign_parser(self) -> 'CodesignParser':\n-        from strongarm.macho.codesign import CodesignParser\n         if not self.__codesign_parser:\n",
        "source_code_with_indent": "    <DED>@property\n    def _codesign_parser(self) -> 'CodesignParser':\n        <IND>from strongarm.macho.codesign import CodesignParser\n        if not self.__codesign_parser:\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    <DED>@property\n    def header(self) -> MachoHeaderStruct:\n        <IND>if self._header:\n            <IND>return self._header\n        <DED>else:\n            <IND>raise RuntimeError('Failed to parse Mach-O')\n\n    <DED><DED>@property\n    def dysymtab(self) -> MachoDysymtabCommandStruct:\n        <IND>if self._dysymtab:\n            <IND>return self._dysymtab\n        <DED>else:\n            <IND>raise RuntimeError('Failed to parse Mach-O')\n\n    <DED><DED>@property\n    def symtab(self) -> MachoSymtabCommandStruct:\n        <IND>if self._symtab:\n            <IND>return self._symtab\n        <DED>else:\n            <IND>raise RuntimeError('Failed to parse Mach-O')\n\n    <DED><DED>@property\n    def encryption_info(self) -> MachoEncryptionInfoStruct:\n        <IND>if self._encryption_info:\n            <IND>return self._encryption_info\n        <DED>else:\n            <IND>raise RuntimeError('Failed to parse Mach-O')\n\n    <DED><DED>@property\n    def dyld_info(self) -> MachoDyldInfoCommandStruct:\n        <IND>if self._dyld_info:\n            <IND>return self._dyld_info\n        <DED>else:\n            <IND>raise RuntimeError('Failed to parse Mach-O')\n\n    <DED><DED>@property\n    def code_signature_cmd(self) -> MachoLinkeditDataCommandStruct:\n        <IND>if self._code_signature_cmd:\n            <IND>return self._code_signature_cmd\n        <DED>else:\n            <IND>raise RuntimeError('Failed to parse Mach-O')\n\n    <DED><DED>@property\n    def _codesign_parser(self) -> 'CodesignParser':\n        <IND>if not self.__codesign_parser:\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "datatheorem/strongarm",
    "commit": "ab620d78b4ce7f933cedc25960307f2c3b03c1a8",
    "filename": "strongarm/macho/macho_binary.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/datatheorem-strongarm/strongarm/macho/macho_binary.py",
    "file_hunks_size": 33,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "strongarm/macho/macho_binary.py:65:8 Incompatible attribute type [8]: Attribute `cpu_type` declared in class `MachoBinary` has type `CPU_TYPE` but is used as type `None`.",
    "message": " Attribute `cpu_type` declared in class `MachoBinary` has type `CPU_TYPE` but is used as type `None`.",
    "rule_id": "Incompatible attribute type [8]",
    "warning_line_no": 65,
    "warning_line": "        self.cpu_type: CPU_TYPE = None",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "# -*- coding: utf-8 -*-\nfrom typing import List, Tuple, Optional, Dict, Union\n\n",
        "source_code_len": 79,
        "target_code": "# -*- coding: utf-8 -*-\nfrom typing import List, Dict, Tuple, Any, Type, Optional\nfrom typing import TYPE_CHECKING\n\nfrom ctypes import c_uint64, c_uint32, sizeof\n\n",
        "target_code_len": 163,
        "diff_format": "@@ -1,3 +1,6 @@\n # -*- coding: utf-8 -*-\n-from typing import List, Tuple, Optional, Dict, Union\n+from typing import List, Dict, Tuple, Any, Type, Optional\n+from typing import TYPE_CHECKING\n+\n+from ctypes import c_uint64, c_uint32, sizeof\n \n",
        "source_code_with_indent": "# -*- coding: utf-8 -*-\nfrom typing import List, Tuple, Optional, Dict, Union\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "# -*- coding: utf-8 -*-\nfrom typing import List, Dict, Tuple, Any, Type, Optional\nfrom typing import TYPE_CHECKING\n\nfrom ctypes import c_uint64, c_uint32, sizeof\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "from strongarm.macho.macho_load_commands import MachoLoadCommands\nfrom strongarm.macho.arch_independent_structs import \\\n    MachoHeaderStruct, \\\n    MachoSegmentCommandStruct, \\\n    MachoSectionRawStruct, \\\n    MachoEncryptionInfoStruct, \\\n    MachoNlistStruct, \\\n    CFStringStruct, \\\n    DylibCommandStruct, \\\n    MachoLoadCommandStruct, \\\n    MachoSymtabCommandStruct, \\\n    MachoDysymtabCommandStruct, \\\n    MachoDyldInfoCommandStruct, \\\n    MachoLinkeditDataCommandStruct\n\nfrom ctypes import c_uint64, c_uint32, sizeof\n\n",
        "source_code_len": 526,
        "target_code": "from strongarm.macho.macho_load_commands import MachoLoadCommands\nfrom strongarm.macho.arch_independent_structs import (\n    ArchIndependentStructure,\n    MachoHeaderStruct,\n    MachoSegmentCommandStruct,\n    MachoSectionRawStruct,\n    MachoEncryptionInfoStruct,\n    MachoNlistStruct,\n    CFStringStruct,\n    DylibCommandStruct,\n    MachoLoadCommandStruct,\n    MachoSymtabCommandStruct,\n    MachoDysymtabCommandStruct,\n    MachoDyldInfoCommandStruct,\n    MachoLinkeditDataCommandStruct,\n)\n\nif TYPE_CHECKING:\n    from strongarm.macho.codesign import CodesignParser\n\n",
        "target_code_len": 565,
        "diff_format": "@@ -7,17 +10,20 @@\n from strongarm.macho.macho_load_commands import MachoLoadCommands\n-from strongarm.macho.arch_independent_structs import \\\n-    MachoHeaderStruct, \\\n-    MachoSegmentCommandStruct, \\\n-    MachoSectionRawStruct, \\\n-    MachoEncryptionInfoStruct, \\\n-    MachoNlistStruct, \\\n-    CFStringStruct, \\\n-    DylibCommandStruct, \\\n-    MachoLoadCommandStruct, \\\n-    MachoSymtabCommandStruct, \\\n-    MachoDysymtabCommandStruct, \\\n-    MachoDyldInfoCommandStruct, \\\n-    MachoLinkeditDataCommandStruct\n-\n-from ctypes import c_uint64, c_uint32, sizeof\n+from strongarm.macho.arch_independent_structs import (\n+    ArchIndependentStructure,\n+    MachoHeaderStruct,\n+    MachoSegmentCommandStruct,\n+    MachoSectionRawStruct,\n+    MachoEncryptionInfoStruct,\n+    MachoNlistStruct,\n+    CFStringStruct,\n+    DylibCommandStruct,\n+    MachoLoadCommandStruct,\n+    MachoSymtabCommandStruct,\n+    MachoDysymtabCommandStruct,\n+    MachoDyldInfoCommandStruct,\n+    MachoLinkeditDataCommandStruct,\n+)\n+\n+if TYPE_CHECKING:\n+    from strongarm.macho.codesign import CodesignParser\n \n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent": "from strongarm.macho.macho_load_commands import MachoLoadCommands\nfrom strongarm.macho.arch_independent_structs import (\n    ArchIndependentStructure,\n    MachoHeaderStruct,\n    MachoSegmentCommandStruct,\n    MachoSectionRawStruct,\n    MachoEncryptionInfoStruct,\n    MachoNlistStruct,\n    CFStringStruct,\n    DylibCommandStruct,\n    MachoLoadCommandStruct,\n    MachoSymtabCommandStruct,\n    MachoDysymtabCommandStruct,\n    MachoDyldInfoCommandStruct,\n    MachoLinkeditDataCommandStruct,\n)\n\nif TYPE_CHECKING:\n    <IND>from strongarm.macho.codesign import CodesignParser\n\n",
        "target_code_with_indent_exact_match": true,
        "source_code_with_indent": "from strongarm.macho.macho_load_commands import MachoLoadCommands\nfrom strongarm.macho.arch_independent_structs import    MachoHeaderStruct,    MachoSegmentCommandStruct,    MachoSectionRawStruct,    MachoEncryptionInfoStruct,    MachoNlistStruct,    CFStringStruct,    DylibCommandStruct,    MachoLoadCommandStruct,    MachoSymtabCommandStruct,    MachoDysymtabCommandStruct,    MachoDyldInfoCommandStruct,    MachoLinkeditDataCommandStruct\n\nfrom ctypes import c_uint64, c_uint32, sizeof\n\n"
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "        # generic Mach-O header info\n        self.is_64bit: bool = None\n        self.is_swap: bool = None\n        self.cpu_type: CPU_TYPE = None\n        self._load_commands_end_addr = None\n\n        # Mach-O header data\n        self.header: MachoHeaderStruct = None\n        self.header_flags: List[int] = None\n        self.file_type: MachoFileType = None\n\n        # segment and section commands from Mach-O header\n        self.segment_commands: Dict[str, MachoSegmentCommandStruct] = None\n        self.sections: Dict[str, MachoSection] = None\n        # also store specific interesting sections which are useful to us\n        self.dysymtab: MachoDysymtabCommandStruct = None\n        self.symtab: MachoSymtabCommandStruct = None\n        self.encryption_info: MachoEncryptionInfoStruct = None\n        self.dyld_info: MachoDyldInfoCommandStruct = None\n        self.load_dylib_commands: List[DylibCommandStruct] = None\n        self.code_signature_cmd: MachoLinkeditDataCommandStruct = None\n\n        self.__codesign_parser: CodesignParser = None\n\n",
        "source_code_len": 1040,
        "target_code": "        # generic Mach-O header info\n        self.is_64bit: bool = False\n        self.is_swap: bool = False\n        self.cpu_type: CPU_TYPE = CPU_TYPE.UNKNOWN\n        self._load_commands_end_addr = 0\n\n        # Mach-O header data\n        self._header: Optional[MachoHeaderStruct] = None\n        self.header_flags: List[int] = []\n        self.file_type: MachoFileType = MachoFileType.MH_EXECUTE\n\n        # segment and section commands from Mach-O header\n        self.segment_commands: Dict[str, MachoSegmentCommandStruct] = {}\n        self.sections: Dict[str, MachoSection] = {}\n        # also store specific interesting sections which are useful to us\n        self._dysymtab: Optional[MachoDysymtabCommandStruct] = None\n        self._symtab: Optional[MachoSymtabCommandStruct] = None\n        self._encryption_info: Optional[MachoEncryptionInfoStruct] = None\n        self._dyld_info: Optional[MachoDyldInfoCommandStruct] = None\n        self.load_dylib_commands: List[DylibCommandStruct] = []\n        self._code_signature_cmd: Optional[MachoLinkeditDataCommandStruct] = None\n\n        self.__codesign_parser: Optional[CodesignParser] = None\n\n",
        "target_code_len": 1139,
        "diff_format": "@@ -62,24 +68,24 @@\n         # generic Mach-O header info\n-        self.is_64bit: bool = None\n-        self.is_swap: bool = None\n-        self.cpu_type: CPU_TYPE = None\n-        self._load_commands_end_addr = None\n+        self.is_64bit: bool = False\n+        self.is_swap: bool = False\n+        self.cpu_type: CPU_TYPE = CPU_TYPE.UNKNOWN\n+        self._load_commands_end_addr = 0\n \n         # Mach-O header data\n-        self.header: MachoHeaderStruct = None\n-        self.header_flags: List[int] = None\n-        self.file_type: MachoFileType = None\n+        self._header: Optional[MachoHeaderStruct] = None\n+        self.header_flags: List[int] = []\n+        self.file_type: MachoFileType = MachoFileType.MH_EXECUTE\n \n         # segment and section commands from Mach-O header\n-        self.segment_commands: Dict[str, MachoSegmentCommandStruct] = None\n-        self.sections: Dict[str, MachoSection] = None\n+        self.segment_commands: Dict[str, MachoSegmentCommandStruct] = {}\n+        self.sections: Dict[str, MachoSection] = {}\n         # also store specific interesting sections which are useful to us\n-        self.dysymtab: MachoDysymtabCommandStruct = None\n-        self.symtab: MachoSymtabCommandStruct = None\n-        self.encryption_info: MachoEncryptionInfoStruct = None\n-        self.dyld_info: MachoDyldInfoCommandStruct = None\n-        self.load_dylib_commands: List[DylibCommandStruct] = None\n-        self.code_signature_cmd: MachoLinkeditDataCommandStruct = None\n-\n-        self.__codesign_parser: CodesignParser = None\n+        self._dysymtab: Optional[MachoDysymtabCommandStruct] = None\n+        self._symtab: Optional[MachoSymtabCommandStruct] = None\n+        self._encryption_info: Optional[MachoEncryptionInfoStruct] = None\n+        self._dyld_info: Optional[MachoDyldInfoCommandStruct] = None\n+        self.load_dylib_commands: List[DylibCommandStruct] = []\n+        self._code_signature_cmd: Optional[MachoLinkeditDataCommandStruct] = None\n+\n+        self.__codesign_parser: Optional[CodesignParser] = None\n \n",
        "source_code_with_indent": "        # generic Mach-O header info\n        self.is_64bit: bool = None\n        self.is_swap: bool = None\n        self.cpu_type: CPU_TYPE = None\n        self._load_commands_end_addr = None\n\n        # Mach-O header data\n        self.header: MachoHeaderStruct = None\n        self.header_flags: List[int] = None\n        self.file_type: MachoFileType = None\n\n        # segment and section commands from Mach-O header\n        self.segment_commands: Dict[str, MachoSegmentCommandStruct] = None\n        self.sections: Dict[str, MachoSection] = None\n        # also store specific interesting sections which are useful to us\n        self.dysymtab: MachoDysymtabCommandStruct = None\n        self.symtab: MachoSymtabCommandStruct = None\n        self.encryption_info: MachoEncryptionInfoStruct = None\n        self.dyld_info: MachoDyldInfoCommandStruct = None\n        self.load_dylib_commands: List[DylibCommandStruct] = None\n        self.code_signature_cmd: MachoLinkeditDataCommandStruct = None\n\n        self.__codesign_parser: CodesignParser = None\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "        # generic Mach-O header info\n        self.is_64bit: bool = False\n        self.is_swap: bool = False\n        self.cpu_type: CPU_TYPE = CPU_TYPE.UNKNOWN\n        self._load_commands_end_addr = 0\n\n        # Mach-O header data\n        self._header: Optional[MachoHeaderStruct] = None\n        self.header_flags: List[int] = []\n        self.file_type: MachoFileType = MachoFileType.MH_EXECUTE\n\n        # segment and section commands from Mach-O header\n        self.segment_commands: Dict[str, MachoSegmentCommandStruct] = {}\n        self.sections: Dict[str, MachoSection] = {}\n        # also store specific interesting sections which are useful to us\n        self._dysymtab: Optional[MachoDysymtabCommandStruct] = None\n        self._symtab: Optional[MachoSymtabCommandStruct] = None\n        self._encryption_info: Optional[MachoEncryptionInfoStruct] = None\n        self._dyld_info: Optional[MachoDyldInfoCommandStruct] = None\n        self.load_dylib_commands: List[DylibCommandStruct] = []\n        self._code_signature_cmd: Optional[MachoLinkeditDataCommandStruct] = None\n\n        self.__codesign_parser: Optional[CodesignParser] = None\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    @property\n    def slice_magic(self) -> c_uint32:\n        \"\"\"Read magic number identifier from this Mach-O slice\n        \"\"\"\n        return self.read_word(0, virtual=False, word_type=c_uint32)\n\n",
        "source_code_len": 197,
        "target_code": "    @property\n    def slice_magic(self) -> int:\n        \"\"\"Read magic number identifier from this Mach-O slice\n        \"\"\"\n        magic = self.read_word(0, virtual=False, word_type=c_uint32)\n        if magic:\n            return magic\n        else:\n            raise ValueError('Could not read magic value.')\n\n",
        "target_code_len": 310,
        "diff_format": "@@ -124,6 +131,10 @@\n     @property\n-    def slice_magic(self) -> c_uint32:\n+    def slice_magic(self) -> int:\n         \"\"\"Read magic number identifier from this Mach-O slice\n         \"\"\"\n-        return self.read_word(0, virtual=False, word_type=c_uint32)\n+        magic = self.read_word(0, virtual=False, word_type=c_uint32)\n+        if magic:\n+            return magic\n+        else:\n+            raise ValueError('Could not read magic value.')\n \n",
        "source_code_with_indent": "    <DED>@property\n    def slice_magic(self) -> c_uint32:\n        <IND>\"\"\"Read magic number identifier from this Mach-O slice\n        \"\"\"\n        return self.read_word(0, virtual=False, word_type=c_uint32)\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    <DED>@property\n    def slice_magic(self) -> int:\n        <IND>\"\"\"Read magic number identifier from this Mach-O slice\n        \"\"\"\n        magic = self.read_word(0, virtual=False, word_type=c_uint32)\n        if magic:\n            <IND>return magic\n        <DED>else:\n            <IND>raise ValueError('Could not read magic value.')\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "        \"\"\"\n        self.header = MachoHeaderStruct(self, 0)\n\n",
        "source_code_len": 62,
        "target_code": "        \"\"\"\n        self._header = MachoHeaderStruct(self, 0)\n\n",
        "target_code_len": 63,
        "diff_format": "@@ -152,3 +163,3 @@\n         \"\"\"\n-        self.header = MachoHeaderStruct(self, 0)\n+        self._header = MachoHeaderStruct(self, 0)\n \n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\n        self.header = MachoHeaderStruct(self, 0)\n\n",
        "target_code_with_indent": "\n        self._header = MachoHeaderStruct(self, 0)\n\n"
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "                                      MachoLoadCommands.LC_ENCRYPTION_INFO_64]:\n                self.encryption_info = MachoEncryptionInfoStruct(self, offset)\n\n            elif load_command.cmd == MachoLoadCommands.LC_SYMTAB:\n                self.symtab = MachoSymtabCommandStruct(self, offset)\n\n            elif load_command.cmd == MachoLoadCommands.LC_DYSYMTAB:\n                self.dysymtab = MachoDysymtabCommandStruct(self, offset)\n\n            elif load_command.cmd in [MachoLoadCommands.LC_DYLD_INFO, MachoLoadCommands.LC_DYLD_INFO_ONLY]:\n                self.dyld_info = MachoDyldInfoCommandStruct(self, offset)\n\n",
        "source_code_len": 621,
        "target_code": "                                      MachoLoadCommands.LC_ENCRYPTION_INFO_64]:\n                self._encryption_info = MachoEncryptionInfoStruct(self, offset)\n\n            elif load_command.cmd == MachoLoadCommands.LC_SYMTAB:\n                self._symtab = MachoSymtabCommandStruct(self, offset)\n\n            elif load_command.cmd == MachoLoadCommands.LC_DYSYMTAB:\n                self._dysymtab = MachoDysymtabCommandStruct(self, offset)\n\n            elif load_command.cmd in [MachoLoadCommands.LC_DYLD_INFO, MachoLoadCommands.LC_DYLD_INFO_ONLY]:\n                self._dyld_info = MachoDyldInfoCommandStruct(self, offset)\n\n",
        "target_code_len": 625,
        "diff_format": "@@ -208,12 +220,12 @@\n                                       MachoLoadCommands.LC_ENCRYPTION_INFO_64]:\n-                self.encryption_info = MachoEncryptionInfoStruct(self, offset)\n+                self._encryption_info = MachoEncryptionInfoStruct(self, offset)\n \n             elif load_command.cmd == MachoLoadCommands.LC_SYMTAB:\n-                self.symtab = MachoSymtabCommandStruct(self, offset)\n+                self._symtab = MachoSymtabCommandStruct(self, offset)\n \n             elif load_command.cmd == MachoLoadCommands.LC_DYSYMTAB:\n-                self.dysymtab = MachoDysymtabCommandStruct(self, offset)\n+                self._dysymtab = MachoDysymtabCommandStruct(self, offset)\n \n             elif load_command.cmd in [MachoLoadCommands.LC_DYLD_INFO, MachoLoadCommands.LC_DYLD_INFO_ONLY]:\n-                self.dyld_info = MachoDyldInfoCommandStruct(self, offset)\n+                self._dyld_info = MachoDyldInfoCommandStruct(self, offset)\n \n",
        "source_code_with_indent": "                                      MachoLoadCommands.LC_ENCRYPTION_INFO_64]:\n                <IND>self.encryption_info = MachoEncryptionInfoStruct(self, offset)\n\n            <DED>elif load_command.cmd == MachoLoadCommands.LC_SYMTAB:\n                <IND>self.symtab = MachoSymtabCommandStruct(self, offset)\n\n            <DED>elif load_command.cmd == MachoLoadCommands.LC_DYSYMTAB:\n                <IND>self.dysymtab = MachoDysymtabCommandStruct(self, offset)\n\n            <DED>elif load_command.cmd in [MachoLoadCommands.LC_DYLD_INFO, MachoLoadCommands.LC_DYLD_INFO_ONLY]:\n                <IND>self.dyld_info = MachoDyldInfoCommandStruct(self, offset)\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "                                      MachoLoadCommands.LC_ENCRYPTION_INFO_64]:\n                <IND>self._encryption_info = MachoEncryptionInfoStruct(self, offset)\n\n            <DED>elif load_command.cmd == MachoLoadCommands.LC_SYMTAB:\n                <IND>self._symtab = MachoSymtabCommandStruct(self, offset)\n\n            <DED>elif load_command.cmd == MachoLoadCommands.LC_DYSYMTAB:\n                <IND>self._dysymtab = MachoDysymtabCommandStruct(self, offset)\n\n            <DED>elif load_command.cmd in [MachoLoadCommands.LC_DYLD_INFO, MachoLoadCommands.LC_DYLD_INFO_ONLY]:\n                <IND>self._dyld_info = MachoDyldInfoCommandStruct(self, offset)\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "            elif load_command.cmd == MachoLoadCommands.LC_CODE_SIGNATURE:\n                self.code_signature_cmd = MachoLinkeditDataCommandStruct(self, offset)\n\n",
        "source_code_len": 162,
        "target_code": "            elif load_command.cmd == MachoLoadCommands.LC_CODE_SIGNATURE:\n                self._code_signature_cmd = MachoLinkeditDataCommandStruct(self, offset)\n\n",
        "target_code_len": 163,
        "diff_format": "@@ -225,3 +236,3 @@\n             elif load_command.cmd == MachoLoadCommands.LC_CODE_SIGNATURE:\n-                self.code_signature_cmd = MachoLinkeditDataCommandStruct(self, offset)\n+                self._code_signature_cmd = MachoLinkeditDataCommandStruct(self, offset)\n \n",
        "source_code_with_indent": "            <DED>elif load_command.cmd == MachoLoadCommands.LC_CODE_SIGNATURE:\n                <IND>self.code_signature_cmd = MachoLinkeditDataCommandStruct(self, offset)\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "            <DED>elif load_command.cmd == MachoLoadCommands.LC_CODE_SIGNATURE:\n                <IND>self._code_signature_cmd = MachoLinkeditDataCommandStruct(self, offset)\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "            indirect_symtab_entry = self.read_word(indirect_symtab_off, virtual=False, word_type=c_uint32)\n            indirect_symtab.append(int(indirect_symtab_entry.value))\n            # traverse to next pointer\n",
        "source_code_len": 215,
        "target_code": "            indirect_symtab_entry = self.read_word(indirect_symtab_off, virtual=False, word_type=c_uint32)\n            if not indirect_symtab_entry:\n                continue\n            indirect_symtab.append(int(indirect_symtab_entry))\n            # traverse to next pointer\n",
        "target_code_len": 276,
        "diff_format": "@@ -398,3 +410,5 @@\n             indirect_symtab_entry = self.read_word(indirect_symtab_off, virtual=False, word_type=c_uint32)\n-            indirect_symtab.append(int(indirect_symtab_entry.value))\n+            if not indirect_symtab_entry:\n+                continue\n+            indirect_symtab.append(int(indirect_symtab_entry))\n             # traverse to next pointer\n",
        "source_code_with_indent": "            <IND>indirect_symtab_entry = self.read_word(indirect_symtab_off, virtual=False, word_type=c_uint32)\n            indirect_symtab.append(int(indirect_symtab_entry.value))\n            # traverse to next pointer\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "            <IND>indirect_symtab_entry = self.read_word(indirect_symtab_off, virtual=False, word_type=c_uint32)\n            if not indirect_symtab_entry:\n                <IND>continue\n            <DED>indirect_symtab.append(int(indirect_symtab_entry))\n            # traverse to next pointer\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "                  address: int,\n                  virtual=True,\n                  word_type=None) -> Optional[Union[c_uint32, c_uint64]]:\n        \"\"\"Attempt to read a word from the binary at a virtual address. Returns None if the address is invalid.\n",
        "source_code_len": 250,
        "target_code": "                  address: int,\n                  virtual: bool = True,\n                  word_type: Any = None) -> Optional[int]:\n        \"\"\"Attempt to read a word from the binary at a virtual address. Returns None if the address is invalid.\n",
        "target_code_len": 243,
        "diff_format": "@@ -568,4 +595,4 @@\n                   address: int,\n-                  virtual=True,\n-                  word_type=None) -> Optional[Union[c_uint32, c_uint64]]:\n+                  virtual: bool = True,\n+                  word_type: Any = None) -> Optional[int]:\n         \"\"\"Attempt to read a word from the binary at a virtual address. Returns None if the address is invalid.\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "                  address: int,\n                  virtual=True,\n                  word_type=None) -> Optional[Union[c_uint32, c_uint64]]:\n        <IND>",
        "target_code_with_indent": "                  address: int,\n                  virtual: bool = True,\n                  word_type: Any = None) -> Optional[int]:\n        <IND>"
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    @property\n    def _codesign_parser(self) -> 'CodesignParser':\n        from strongarm.macho.codesign import CodesignParser\n        if not self.__codesign_parser:\n",
        "source_code_len": 165,
        "target_code": "    @property\n    def header(self) -> MachoHeaderStruct:\n        if self._header:\n            return self._header\n        else:\n            raise RuntimeError('Failed to parse Mach-O')\n\n    @property\n    def dysymtab(self) -> MachoDysymtabCommandStruct:\n        if self._dysymtab:\n            return self._dysymtab\n        else:\n            raise RuntimeError('Failed to parse Mach-O')\n\n    @property\n    def symtab(self) -> MachoSymtabCommandStruct:\n        if self._symtab:\n            return self._symtab\n        else:\n            raise RuntimeError('Failed to parse Mach-O')\n\n    @property\n    def encryption_info(self) -> MachoEncryptionInfoStruct:\n        if self._encryption_info:\n            return self._encryption_info\n        else:\n            raise RuntimeError('Failed to parse Mach-O')\n\n    @property\n    def dyld_info(self) -> MachoDyldInfoCommandStruct:\n        if self._dyld_info:\n            return self._dyld_info\n        else:\n            raise RuntimeError('Failed to parse Mach-O')\n\n    @property\n    def code_signature_cmd(self) -> MachoLinkeditDataCommandStruct:\n        if self._code_signature_cmd:\n            return self._code_signature_cmd\n        else:\n            raise RuntimeError('Failed to parse Mach-O')\n\n    @property\n    def _codesign_parser(self) -> 'CodesignParser':\n        if not self.__codesign_parser:\n",
        "target_code_len": 1345,
        "diff_format": "@@ -583,4 +613,45 @@\n     @property\n+    def header(self) -> MachoHeaderStruct:\n+        if self._header:\n+            return self._header\n+        else:\n+            raise RuntimeError('Failed to parse Mach-O')\n+\n+    @property\n+    def dysymtab(self) -> MachoDysymtabCommandStruct:\n+        if self._dysymtab:\n+            return self._dysymtab\n+        else:\n+            raise RuntimeError('Failed to parse Mach-O')\n+\n+    @property\n+    def symtab(self) -> MachoSymtabCommandStruct:\n+        if self._symtab:\n+            return self._symtab\n+        else:\n+            raise RuntimeError('Failed to parse Mach-O')\n+\n+    @property\n+    def encryption_info(self) -> MachoEncryptionInfoStruct:\n+        if self._encryption_info:\n+            return self._encryption_info\n+        else:\n+            raise RuntimeError('Failed to parse Mach-O')\n+\n+    @property\n+    def dyld_info(self) -> MachoDyldInfoCommandStruct:\n+        if self._dyld_info:\n+            return self._dyld_info\n+        else:\n+            raise RuntimeError('Failed to parse Mach-O')\n+\n+    @property\n+    def code_signature_cmd(self) -> MachoLinkeditDataCommandStruct:\n+        if self._code_signature_cmd:\n+            return self._code_signature_cmd\n+        else:\n+            raise RuntimeError('Failed to parse Mach-O')\n+\n+    @property\n     def _codesign_parser(self) -> 'CodesignParser':\n-        from strongarm.macho.codesign import CodesignParser\n         if not self.__codesign_parser:\n",
        "source_code_with_indent": "    <DED>@property\n    def _codesign_parser(self) -> 'CodesignParser':\n        <IND>from strongarm.macho.codesign import CodesignParser\n        if not self.__codesign_parser:\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    <DED>@property\n    def header(self) -> MachoHeaderStruct:\n        <IND>if self._header:\n            <IND>return self._header\n        <DED>else:\n            <IND>raise RuntimeError('Failed to parse Mach-O')\n\n    <DED><DED>@property\n    def dysymtab(self) -> MachoDysymtabCommandStruct:\n        <IND>if self._dysymtab:\n            <IND>return self._dysymtab\n        <DED>else:\n            <IND>raise RuntimeError('Failed to parse Mach-O')\n\n    <DED><DED>@property\n    def symtab(self) -> MachoSymtabCommandStruct:\n        <IND>if self._symtab:\n            <IND>return self._symtab\n        <DED>else:\n            <IND>raise RuntimeError('Failed to parse Mach-O')\n\n    <DED><DED>@property\n    def encryption_info(self) -> MachoEncryptionInfoStruct:\n        <IND>if self._encryption_info:\n            <IND>return self._encryption_info\n        <DED>else:\n            <IND>raise RuntimeError('Failed to parse Mach-O')\n\n    <DED><DED>@property\n    def dyld_info(self) -> MachoDyldInfoCommandStruct:\n        <IND>if self._dyld_info:\n            <IND>return self._dyld_info\n        <DED>else:\n            <IND>raise RuntimeError('Failed to parse Mach-O')\n\n    <DED><DED>@property\n    def code_signature_cmd(self) -> MachoLinkeditDataCommandStruct:\n        <IND>if self._code_signature_cmd:\n            <IND>return self._code_signature_cmd\n        <DED>else:\n            <IND>raise RuntimeError('Failed to parse Mach-O')\n\n    <DED><DED>@property\n    def _codesign_parser(self) -> 'CodesignParser':\n        <IND>if not self.__codesign_parser:\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "datatheorem/strongarm",
    "commit": "ab620d78b4ce7f933cedc25960307f2c3b03c1a8",
    "filename": "strongarm/macho/macho_binary.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/datatheorem-strongarm/strongarm/macho/macho_binary.py",
    "file_hunks_size": 33,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "strongarm/macho/macho_binary.py:69:8 Incompatible attribute type [8]: Attribute `header` declared in class `MachoBinary` has type `MachoHeaderStruct` but is used as type `None`.",
    "message": " Attribute `header` declared in class `MachoBinary` has type `MachoHeaderStruct` but is used as type `None`.",
    "rule_id": "Incompatible attribute type [8]",
    "warning_line_no": 69,
    "warning_line": "        self.header: MachoHeaderStruct = None",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "# -*- coding: utf-8 -*-\nfrom typing import List, Tuple, Optional, Dict, Union\n\n",
        "source_code_len": 79,
        "target_code": "# -*- coding: utf-8 -*-\nfrom typing import List, Dict, Tuple, Any, Type, Optional\nfrom typing import TYPE_CHECKING\n\nfrom ctypes import c_uint64, c_uint32, sizeof\n\n",
        "target_code_len": 163,
        "diff_format": "@@ -1,3 +1,6 @@\n # -*- coding: utf-8 -*-\n-from typing import List, Tuple, Optional, Dict, Union\n+from typing import List, Dict, Tuple, Any, Type, Optional\n+from typing import TYPE_CHECKING\n+\n+from ctypes import c_uint64, c_uint32, sizeof\n \n",
        "source_code_with_indent": "# -*- coding: utf-8 -*-\nfrom typing import List, Tuple, Optional, Dict, Union\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "# -*- coding: utf-8 -*-\nfrom typing import List, Dict, Tuple, Any, Type, Optional\nfrom typing import TYPE_CHECKING\n\nfrom ctypes import c_uint64, c_uint32, sizeof\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "from strongarm.macho.macho_load_commands import MachoLoadCommands\nfrom strongarm.macho.arch_independent_structs import \\\n    MachoHeaderStruct, \\\n    MachoSegmentCommandStruct, \\\n    MachoSectionRawStruct, \\\n    MachoEncryptionInfoStruct, \\\n    MachoNlistStruct, \\\n    CFStringStruct, \\\n    DylibCommandStruct, \\\n    MachoLoadCommandStruct, \\\n    MachoSymtabCommandStruct, \\\n    MachoDysymtabCommandStruct, \\\n    MachoDyldInfoCommandStruct, \\\n    MachoLinkeditDataCommandStruct\n\nfrom ctypes import c_uint64, c_uint32, sizeof\n\n",
        "source_code_len": 526,
        "target_code": "from strongarm.macho.macho_load_commands import MachoLoadCommands\nfrom strongarm.macho.arch_independent_structs import (\n    ArchIndependentStructure,\n    MachoHeaderStruct,\n    MachoSegmentCommandStruct,\n    MachoSectionRawStruct,\n    MachoEncryptionInfoStruct,\n    MachoNlistStruct,\n    CFStringStruct,\n    DylibCommandStruct,\n    MachoLoadCommandStruct,\n    MachoSymtabCommandStruct,\n    MachoDysymtabCommandStruct,\n    MachoDyldInfoCommandStruct,\n    MachoLinkeditDataCommandStruct,\n)\n\nif TYPE_CHECKING:\n    from strongarm.macho.codesign import CodesignParser\n\n",
        "target_code_len": 565,
        "diff_format": "@@ -7,17 +10,20 @@\n from strongarm.macho.macho_load_commands import MachoLoadCommands\n-from strongarm.macho.arch_independent_structs import \\\n-    MachoHeaderStruct, \\\n-    MachoSegmentCommandStruct, \\\n-    MachoSectionRawStruct, \\\n-    MachoEncryptionInfoStruct, \\\n-    MachoNlistStruct, \\\n-    CFStringStruct, \\\n-    DylibCommandStruct, \\\n-    MachoLoadCommandStruct, \\\n-    MachoSymtabCommandStruct, \\\n-    MachoDysymtabCommandStruct, \\\n-    MachoDyldInfoCommandStruct, \\\n-    MachoLinkeditDataCommandStruct\n-\n-from ctypes import c_uint64, c_uint32, sizeof\n+from strongarm.macho.arch_independent_structs import (\n+    ArchIndependentStructure,\n+    MachoHeaderStruct,\n+    MachoSegmentCommandStruct,\n+    MachoSectionRawStruct,\n+    MachoEncryptionInfoStruct,\n+    MachoNlistStruct,\n+    CFStringStruct,\n+    DylibCommandStruct,\n+    MachoLoadCommandStruct,\n+    MachoSymtabCommandStruct,\n+    MachoDysymtabCommandStruct,\n+    MachoDyldInfoCommandStruct,\n+    MachoLinkeditDataCommandStruct,\n+)\n+\n+if TYPE_CHECKING:\n+    from strongarm.macho.codesign import CodesignParser\n \n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent": "from strongarm.macho.macho_load_commands import MachoLoadCommands\nfrom strongarm.macho.arch_independent_structs import (\n    ArchIndependentStructure,\n    MachoHeaderStruct,\n    MachoSegmentCommandStruct,\n    MachoSectionRawStruct,\n    MachoEncryptionInfoStruct,\n    MachoNlistStruct,\n    CFStringStruct,\n    DylibCommandStruct,\n    MachoLoadCommandStruct,\n    MachoSymtabCommandStruct,\n    MachoDysymtabCommandStruct,\n    MachoDyldInfoCommandStruct,\n    MachoLinkeditDataCommandStruct,\n)\n\nif TYPE_CHECKING:\n    <IND>from strongarm.macho.codesign import CodesignParser\n\n",
        "target_code_with_indent_exact_match": true,
        "source_code_with_indent": "from strongarm.macho.macho_load_commands import MachoLoadCommands\nfrom strongarm.macho.arch_independent_structs import    MachoHeaderStruct,    MachoSegmentCommandStruct,    MachoSectionRawStruct,    MachoEncryptionInfoStruct,    MachoNlistStruct,    CFStringStruct,    DylibCommandStruct,    MachoLoadCommandStruct,    MachoSymtabCommandStruct,    MachoDysymtabCommandStruct,    MachoDyldInfoCommandStruct,    MachoLinkeditDataCommandStruct\n\nfrom ctypes import c_uint64, c_uint32, sizeof\n\n"
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "        # generic Mach-O header info\n        self.is_64bit: bool = None\n        self.is_swap: bool = None\n        self.cpu_type: CPU_TYPE = None\n        self._load_commands_end_addr = None\n\n        # Mach-O header data\n        self.header: MachoHeaderStruct = None\n        self.header_flags: List[int] = None\n        self.file_type: MachoFileType = None\n\n        # segment and section commands from Mach-O header\n        self.segment_commands: Dict[str, MachoSegmentCommandStruct] = None\n        self.sections: Dict[str, MachoSection] = None\n        # also store specific interesting sections which are useful to us\n        self.dysymtab: MachoDysymtabCommandStruct = None\n        self.symtab: MachoSymtabCommandStruct = None\n        self.encryption_info: MachoEncryptionInfoStruct = None\n        self.dyld_info: MachoDyldInfoCommandStruct = None\n        self.load_dylib_commands: List[DylibCommandStruct] = None\n        self.code_signature_cmd: MachoLinkeditDataCommandStruct = None\n\n        self.__codesign_parser: CodesignParser = None\n\n",
        "source_code_len": 1040,
        "target_code": "        # generic Mach-O header info\n        self.is_64bit: bool = False\n        self.is_swap: bool = False\n        self.cpu_type: CPU_TYPE = CPU_TYPE.UNKNOWN\n        self._load_commands_end_addr = 0\n\n        # Mach-O header data\n        self._header: Optional[MachoHeaderStruct] = None\n        self.header_flags: List[int] = []\n        self.file_type: MachoFileType = MachoFileType.MH_EXECUTE\n\n        # segment and section commands from Mach-O header\n        self.segment_commands: Dict[str, MachoSegmentCommandStruct] = {}\n        self.sections: Dict[str, MachoSection] = {}\n        # also store specific interesting sections which are useful to us\n        self._dysymtab: Optional[MachoDysymtabCommandStruct] = None\n        self._symtab: Optional[MachoSymtabCommandStruct] = None\n        self._encryption_info: Optional[MachoEncryptionInfoStruct] = None\n        self._dyld_info: Optional[MachoDyldInfoCommandStruct] = None\n        self.load_dylib_commands: List[DylibCommandStruct] = []\n        self._code_signature_cmd: Optional[MachoLinkeditDataCommandStruct] = None\n\n        self.__codesign_parser: Optional[CodesignParser] = None\n\n",
        "target_code_len": 1139,
        "diff_format": "@@ -62,24 +68,24 @@\n         # generic Mach-O header info\n-        self.is_64bit: bool = None\n-        self.is_swap: bool = None\n-        self.cpu_type: CPU_TYPE = None\n-        self._load_commands_end_addr = None\n+        self.is_64bit: bool = False\n+        self.is_swap: bool = False\n+        self.cpu_type: CPU_TYPE = CPU_TYPE.UNKNOWN\n+        self._load_commands_end_addr = 0\n \n         # Mach-O header data\n-        self.header: MachoHeaderStruct = None\n-        self.header_flags: List[int] = None\n-        self.file_type: MachoFileType = None\n+        self._header: Optional[MachoHeaderStruct] = None\n+        self.header_flags: List[int] = []\n+        self.file_type: MachoFileType = MachoFileType.MH_EXECUTE\n \n         # segment and section commands from Mach-O header\n-        self.segment_commands: Dict[str, MachoSegmentCommandStruct] = None\n-        self.sections: Dict[str, MachoSection] = None\n+        self.segment_commands: Dict[str, MachoSegmentCommandStruct] = {}\n+        self.sections: Dict[str, MachoSection] = {}\n         # also store specific interesting sections which are useful to us\n-        self.dysymtab: MachoDysymtabCommandStruct = None\n-        self.symtab: MachoSymtabCommandStruct = None\n-        self.encryption_info: MachoEncryptionInfoStruct = None\n-        self.dyld_info: MachoDyldInfoCommandStruct = None\n-        self.load_dylib_commands: List[DylibCommandStruct] = None\n-        self.code_signature_cmd: MachoLinkeditDataCommandStruct = None\n-\n-        self.__codesign_parser: CodesignParser = None\n+        self._dysymtab: Optional[MachoDysymtabCommandStruct] = None\n+        self._symtab: Optional[MachoSymtabCommandStruct] = None\n+        self._encryption_info: Optional[MachoEncryptionInfoStruct] = None\n+        self._dyld_info: Optional[MachoDyldInfoCommandStruct] = None\n+        self.load_dylib_commands: List[DylibCommandStruct] = []\n+        self._code_signature_cmd: Optional[MachoLinkeditDataCommandStruct] = None\n+\n+        self.__codesign_parser: Optional[CodesignParser] = None\n \n",
        "source_code_with_indent": "        # generic Mach-O header info\n        self.is_64bit: bool = None\n        self.is_swap: bool = None\n        self.cpu_type: CPU_TYPE = None\n        self._load_commands_end_addr = None\n\n        # Mach-O header data\n        self.header: MachoHeaderStruct = None\n        self.header_flags: List[int] = None\n        self.file_type: MachoFileType = None\n\n        # segment and section commands from Mach-O header\n        self.segment_commands: Dict[str, MachoSegmentCommandStruct] = None\n        self.sections: Dict[str, MachoSection] = None\n        # also store specific interesting sections which are useful to us\n        self.dysymtab: MachoDysymtabCommandStruct = None\n        self.symtab: MachoSymtabCommandStruct = None\n        self.encryption_info: MachoEncryptionInfoStruct = None\n        self.dyld_info: MachoDyldInfoCommandStruct = None\n        self.load_dylib_commands: List[DylibCommandStruct] = None\n        self.code_signature_cmd: MachoLinkeditDataCommandStruct = None\n\n        self.__codesign_parser: CodesignParser = None\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "        # generic Mach-O header info\n        self.is_64bit: bool = False\n        self.is_swap: bool = False\n        self.cpu_type: CPU_TYPE = CPU_TYPE.UNKNOWN\n        self._load_commands_end_addr = 0\n\n        # Mach-O header data\n        self._header: Optional[MachoHeaderStruct] = None\n        self.header_flags: List[int] = []\n        self.file_type: MachoFileType = MachoFileType.MH_EXECUTE\n\n        # segment and section commands from Mach-O header\n        self.segment_commands: Dict[str, MachoSegmentCommandStruct] = {}\n        self.sections: Dict[str, MachoSection] = {}\n        # also store specific interesting sections which are useful to us\n        self._dysymtab: Optional[MachoDysymtabCommandStruct] = None\n        self._symtab: Optional[MachoSymtabCommandStruct] = None\n        self._encryption_info: Optional[MachoEncryptionInfoStruct] = None\n        self._dyld_info: Optional[MachoDyldInfoCommandStruct] = None\n        self.load_dylib_commands: List[DylibCommandStruct] = []\n        self._code_signature_cmd: Optional[MachoLinkeditDataCommandStruct] = None\n\n        self.__codesign_parser: Optional[CodesignParser] = None\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    @property\n    def slice_magic(self) -> c_uint32:\n        \"\"\"Read magic number identifier from this Mach-O slice\n        \"\"\"\n        return self.read_word(0, virtual=False, word_type=c_uint32)\n\n",
        "source_code_len": 197,
        "target_code": "    @property\n    def slice_magic(self) -> int:\n        \"\"\"Read magic number identifier from this Mach-O slice\n        \"\"\"\n        magic = self.read_word(0, virtual=False, word_type=c_uint32)\n        if magic:\n            return magic\n        else:\n            raise ValueError('Could not read magic value.')\n\n",
        "target_code_len": 310,
        "diff_format": "@@ -124,6 +131,10 @@\n     @property\n-    def slice_magic(self) -> c_uint32:\n+    def slice_magic(self) -> int:\n         \"\"\"Read magic number identifier from this Mach-O slice\n         \"\"\"\n-        return self.read_word(0, virtual=False, word_type=c_uint32)\n+        magic = self.read_word(0, virtual=False, word_type=c_uint32)\n+        if magic:\n+            return magic\n+        else:\n+            raise ValueError('Could not read magic value.')\n \n",
        "source_code_with_indent": "    <DED>@property\n    def slice_magic(self) -> c_uint32:\n        <IND>\"\"\"Read magic number identifier from this Mach-O slice\n        \"\"\"\n        return self.read_word(0, virtual=False, word_type=c_uint32)\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    <DED>@property\n    def slice_magic(self) -> int:\n        <IND>\"\"\"Read magic number identifier from this Mach-O slice\n        \"\"\"\n        magic = self.read_word(0, virtual=False, word_type=c_uint32)\n        if magic:\n            <IND>return magic\n        <DED>else:\n            <IND>raise ValueError('Could not read magic value.')\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "        \"\"\"\n        self.header = MachoHeaderStruct(self, 0)\n\n",
        "source_code_len": 62,
        "target_code": "        \"\"\"\n        self._header = MachoHeaderStruct(self, 0)\n\n",
        "target_code_len": 63,
        "diff_format": "@@ -152,3 +163,3 @@\n         \"\"\"\n-        self.header = MachoHeaderStruct(self, 0)\n+        self._header = MachoHeaderStruct(self, 0)\n \n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\n        self.header = MachoHeaderStruct(self, 0)\n\n",
        "target_code_with_indent": "\n        self._header = MachoHeaderStruct(self, 0)\n\n"
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "                                      MachoLoadCommands.LC_ENCRYPTION_INFO_64]:\n                self.encryption_info = MachoEncryptionInfoStruct(self, offset)\n\n            elif load_command.cmd == MachoLoadCommands.LC_SYMTAB:\n                self.symtab = MachoSymtabCommandStruct(self, offset)\n\n            elif load_command.cmd == MachoLoadCommands.LC_DYSYMTAB:\n                self.dysymtab = MachoDysymtabCommandStruct(self, offset)\n\n            elif load_command.cmd in [MachoLoadCommands.LC_DYLD_INFO, MachoLoadCommands.LC_DYLD_INFO_ONLY]:\n                self.dyld_info = MachoDyldInfoCommandStruct(self, offset)\n\n",
        "source_code_len": 621,
        "target_code": "                                      MachoLoadCommands.LC_ENCRYPTION_INFO_64]:\n                self._encryption_info = MachoEncryptionInfoStruct(self, offset)\n\n            elif load_command.cmd == MachoLoadCommands.LC_SYMTAB:\n                self._symtab = MachoSymtabCommandStruct(self, offset)\n\n            elif load_command.cmd == MachoLoadCommands.LC_DYSYMTAB:\n                self._dysymtab = MachoDysymtabCommandStruct(self, offset)\n\n            elif load_command.cmd in [MachoLoadCommands.LC_DYLD_INFO, MachoLoadCommands.LC_DYLD_INFO_ONLY]:\n                self._dyld_info = MachoDyldInfoCommandStruct(self, offset)\n\n",
        "target_code_len": 625,
        "diff_format": "@@ -208,12 +220,12 @@\n                                       MachoLoadCommands.LC_ENCRYPTION_INFO_64]:\n-                self.encryption_info = MachoEncryptionInfoStruct(self, offset)\n+                self._encryption_info = MachoEncryptionInfoStruct(self, offset)\n \n             elif load_command.cmd == MachoLoadCommands.LC_SYMTAB:\n-                self.symtab = MachoSymtabCommandStruct(self, offset)\n+                self._symtab = MachoSymtabCommandStruct(self, offset)\n \n             elif load_command.cmd == MachoLoadCommands.LC_DYSYMTAB:\n-                self.dysymtab = MachoDysymtabCommandStruct(self, offset)\n+                self._dysymtab = MachoDysymtabCommandStruct(self, offset)\n \n             elif load_command.cmd in [MachoLoadCommands.LC_DYLD_INFO, MachoLoadCommands.LC_DYLD_INFO_ONLY]:\n-                self.dyld_info = MachoDyldInfoCommandStruct(self, offset)\n+                self._dyld_info = MachoDyldInfoCommandStruct(self, offset)\n \n",
        "source_code_with_indent": "                                      MachoLoadCommands.LC_ENCRYPTION_INFO_64]:\n                <IND>self.encryption_info = MachoEncryptionInfoStruct(self, offset)\n\n            <DED>elif load_command.cmd == MachoLoadCommands.LC_SYMTAB:\n                <IND>self.symtab = MachoSymtabCommandStruct(self, offset)\n\n            <DED>elif load_command.cmd == MachoLoadCommands.LC_DYSYMTAB:\n                <IND>self.dysymtab = MachoDysymtabCommandStruct(self, offset)\n\n            <DED>elif load_command.cmd in [MachoLoadCommands.LC_DYLD_INFO, MachoLoadCommands.LC_DYLD_INFO_ONLY]:\n                <IND>self.dyld_info = MachoDyldInfoCommandStruct(self, offset)\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "                                      MachoLoadCommands.LC_ENCRYPTION_INFO_64]:\n                <IND>self._encryption_info = MachoEncryptionInfoStruct(self, offset)\n\n            <DED>elif load_command.cmd == MachoLoadCommands.LC_SYMTAB:\n                <IND>self._symtab = MachoSymtabCommandStruct(self, offset)\n\n            <DED>elif load_command.cmd == MachoLoadCommands.LC_DYSYMTAB:\n                <IND>self._dysymtab = MachoDysymtabCommandStruct(self, offset)\n\n            <DED>elif load_command.cmd in [MachoLoadCommands.LC_DYLD_INFO, MachoLoadCommands.LC_DYLD_INFO_ONLY]:\n                <IND>self._dyld_info = MachoDyldInfoCommandStruct(self, offset)\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "            elif load_command.cmd == MachoLoadCommands.LC_CODE_SIGNATURE:\n                self.code_signature_cmd = MachoLinkeditDataCommandStruct(self, offset)\n\n",
        "source_code_len": 162,
        "target_code": "            elif load_command.cmd == MachoLoadCommands.LC_CODE_SIGNATURE:\n                self._code_signature_cmd = MachoLinkeditDataCommandStruct(self, offset)\n\n",
        "target_code_len": 163,
        "diff_format": "@@ -225,3 +236,3 @@\n             elif load_command.cmd == MachoLoadCommands.LC_CODE_SIGNATURE:\n-                self.code_signature_cmd = MachoLinkeditDataCommandStruct(self, offset)\n+                self._code_signature_cmd = MachoLinkeditDataCommandStruct(self, offset)\n \n",
        "source_code_with_indent": "            <DED>elif load_command.cmd == MachoLoadCommands.LC_CODE_SIGNATURE:\n                <IND>self.code_signature_cmd = MachoLinkeditDataCommandStruct(self, offset)\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "            <DED>elif load_command.cmd == MachoLoadCommands.LC_CODE_SIGNATURE:\n                <IND>self._code_signature_cmd = MachoLinkeditDataCommandStruct(self, offset)\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "            indirect_symtab_entry = self.read_word(indirect_symtab_off, virtual=False, word_type=c_uint32)\n            indirect_symtab.append(int(indirect_symtab_entry.value))\n            # traverse to next pointer\n",
        "source_code_len": 215,
        "target_code": "            indirect_symtab_entry = self.read_word(indirect_symtab_off, virtual=False, word_type=c_uint32)\n            if not indirect_symtab_entry:\n                continue\n            indirect_symtab.append(int(indirect_symtab_entry))\n            # traverse to next pointer\n",
        "target_code_len": 276,
        "diff_format": "@@ -398,3 +410,5 @@\n             indirect_symtab_entry = self.read_word(indirect_symtab_off, virtual=False, word_type=c_uint32)\n-            indirect_symtab.append(int(indirect_symtab_entry.value))\n+            if not indirect_symtab_entry:\n+                continue\n+            indirect_symtab.append(int(indirect_symtab_entry))\n             # traverse to next pointer\n",
        "source_code_with_indent": "            <IND>indirect_symtab_entry = self.read_word(indirect_symtab_off, virtual=False, word_type=c_uint32)\n            indirect_symtab.append(int(indirect_symtab_entry.value))\n            # traverse to next pointer\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "            <IND>indirect_symtab_entry = self.read_word(indirect_symtab_off, virtual=False, word_type=c_uint32)\n            if not indirect_symtab_entry:\n                <IND>continue\n            <DED>indirect_symtab.append(int(indirect_symtab_entry))\n            # traverse to next pointer\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "                  address: int,\n                  virtual=True,\n                  word_type=None) -> Optional[Union[c_uint32, c_uint64]]:\n        \"\"\"Attempt to read a word from the binary at a virtual address. Returns None if the address is invalid.\n",
        "source_code_len": 250,
        "target_code": "                  address: int,\n                  virtual: bool = True,\n                  word_type: Any = None) -> Optional[int]:\n        \"\"\"Attempt to read a word from the binary at a virtual address. Returns None if the address is invalid.\n",
        "target_code_len": 243,
        "diff_format": "@@ -568,4 +595,4 @@\n                   address: int,\n-                  virtual=True,\n-                  word_type=None) -> Optional[Union[c_uint32, c_uint64]]:\n+                  virtual: bool = True,\n+                  word_type: Any = None) -> Optional[int]:\n         \"\"\"Attempt to read a word from the binary at a virtual address. Returns None if the address is invalid.\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "                  address: int,\n                  virtual=True,\n                  word_type=None) -> Optional[Union[c_uint32, c_uint64]]:\n        <IND>",
        "target_code_with_indent": "                  address: int,\n                  virtual: bool = True,\n                  word_type: Any = None) -> Optional[int]:\n        <IND>"
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    @property\n    def _codesign_parser(self) -> 'CodesignParser':\n        from strongarm.macho.codesign import CodesignParser\n        if not self.__codesign_parser:\n",
        "source_code_len": 165,
        "target_code": "    @property\n    def header(self) -> MachoHeaderStruct:\n        if self._header:\n            return self._header\n        else:\n            raise RuntimeError('Failed to parse Mach-O')\n\n    @property\n    def dysymtab(self) -> MachoDysymtabCommandStruct:\n        if self._dysymtab:\n            return self._dysymtab\n        else:\n            raise RuntimeError('Failed to parse Mach-O')\n\n    @property\n    def symtab(self) -> MachoSymtabCommandStruct:\n        if self._symtab:\n            return self._symtab\n        else:\n            raise RuntimeError('Failed to parse Mach-O')\n\n    @property\n    def encryption_info(self) -> MachoEncryptionInfoStruct:\n        if self._encryption_info:\n            return self._encryption_info\n        else:\n            raise RuntimeError('Failed to parse Mach-O')\n\n    @property\n    def dyld_info(self) -> MachoDyldInfoCommandStruct:\n        if self._dyld_info:\n            return self._dyld_info\n        else:\n            raise RuntimeError('Failed to parse Mach-O')\n\n    @property\n    def code_signature_cmd(self) -> MachoLinkeditDataCommandStruct:\n        if self._code_signature_cmd:\n            return self._code_signature_cmd\n        else:\n            raise RuntimeError('Failed to parse Mach-O')\n\n    @property\n    def _codesign_parser(self) -> 'CodesignParser':\n        if not self.__codesign_parser:\n",
        "target_code_len": 1345,
        "diff_format": "@@ -583,4 +613,45 @@\n     @property\n+    def header(self) -> MachoHeaderStruct:\n+        if self._header:\n+            return self._header\n+        else:\n+            raise RuntimeError('Failed to parse Mach-O')\n+\n+    @property\n+    def dysymtab(self) -> MachoDysymtabCommandStruct:\n+        if self._dysymtab:\n+            return self._dysymtab\n+        else:\n+            raise RuntimeError('Failed to parse Mach-O')\n+\n+    @property\n+    def symtab(self) -> MachoSymtabCommandStruct:\n+        if self._symtab:\n+            return self._symtab\n+        else:\n+            raise RuntimeError('Failed to parse Mach-O')\n+\n+    @property\n+    def encryption_info(self) -> MachoEncryptionInfoStruct:\n+        if self._encryption_info:\n+            return self._encryption_info\n+        else:\n+            raise RuntimeError('Failed to parse Mach-O')\n+\n+    @property\n+    def dyld_info(self) -> MachoDyldInfoCommandStruct:\n+        if self._dyld_info:\n+            return self._dyld_info\n+        else:\n+            raise RuntimeError('Failed to parse Mach-O')\n+\n+    @property\n+    def code_signature_cmd(self) -> MachoLinkeditDataCommandStruct:\n+        if self._code_signature_cmd:\n+            return self._code_signature_cmd\n+        else:\n+            raise RuntimeError('Failed to parse Mach-O')\n+\n+    @property\n     def _codesign_parser(self) -> 'CodesignParser':\n-        from strongarm.macho.codesign import CodesignParser\n         if not self.__codesign_parser:\n",
        "source_code_with_indent": "    <DED>@property\n    def _codesign_parser(self) -> 'CodesignParser':\n        <IND>from strongarm.macho.codesign import CodesignParser\n        if not self.__codesign_parser:\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    <DED>@property\n    def header(self) -> MachoHeaderStruct:\n        <IND>if self._header:\n            <IND>return self._header\n        <DED>else:\n            <IND>raise RuntimeError('Failed to parse Mach-O')\n\n    <DED><DED>@property\n    def dysymtab(self) -> MachoDysymtabCommandStruct:\n        <IND>if self._dysymtab:\n            <IND>return self._dysymtab\n        <DED>else:\n            <IND>raise RuntimeError('Failed to parse Mach-O')\n\n    <DED><DED>@property\n    def symtab(self) -> MachoSymtabCommandStruct:\n        <IND>if self._symtab:\n            <IND>return self._symtab\n        <DED>else:\n            <IND>raise RuntimeError('Failed to parse Mach-O')\n\n    <DED><DED>@property\n    def encryption_info(self) -> MachoEncryptionInfoStruct:\n        <IND>if self._encryption_info:\n            <IND>return self._encryption_info\n        <DED>else:\n            <IND>raise RuntimeError('Failed to parse Mach-O')\n\n    <DED><DED>@property\n    def dyld_info(self) -> MachoDyldInfoCommandStruct:\n        <IND>if self._dyld_info:\n            <IND>return self._dyld_info\n        <DED>else:\n            <IND>raise RuntimeError('Failed to parse Mach-O')\n\n    <DED><DED>@property\n    def code_signature_cmd(self) -> MachoLinkeditDataCommandStruct:\n        <IND>if self._code_signature_cmd:\n            <IND>return self._code_signature_cmd\n        <DED>else:\n            <IND>raise RuntimeError('Failed to parse Mach-O')\n\n    <DED><DED>@property\n    def _codesign_parser(self) -> 'CodesignParser':\n        <IND>if not self.__codesign_parser:\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "datatheorem/strongarm",
    "commit": "ab620d78b4ce7f933cedc25960307f2c3b03c1a8",
    "filename": "strongarm/macho/macho_binary.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/datatheorem-strongarm/strongarm/macho/macho_binary.py",
    "file_hunks_size": 33,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "strongarm/macho/macho_binary.py:70:8 Incompatible attribute type [8]: Attribute `header_flags` declared in class `MachoBinary` has type `List[int]` but is used as type `None`.",
    "message": " Attribute `header_flags` declared in class `MachoBinary` has type `List[int]` but is used as type `None`.",
    "rule_id": "Incompatible attribute type [8]",
    "warning_line_no": 70,
    "warning_line": "        self.header_flags: List[int] = None",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "# -*- coding: utf-8 -*-\nfrom typing import List, Tuple, Optional, Dict, Union\n\n",
        "source_code_len": 79,
        "target_code": "# -*- coding: utf-8 -*-\nfrom typing import List, Dict, Tuple, Any, Type, Optional\nfrom typing import TYPE_CHECKING\n\nfrom ctypes import c_uint64, c_uint32, sizeof\n\n",
        "target_code_len": 163,
        "diff_format": "@@ -1,3 +1,6 @@\n # -*- coding: utf-8 -*-\n-from typing import List, Tuple, Optional, Dict, Union\n+from typing import List, Dict, Tuple, Any, Type, Optional\n+from typing import TYPE_CHECKING\n+\n+from ctypes import c_uint64, c_uint32, sizeof\n \n",
        "source_code_with_indent": "# -*- coding: utf-8 -*-\nfrom typing import List, Tuple, Optional, Dict, Union\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "# -*- coding: utf-8 -*-\nfrom typing import List, Dict, Tuple, Any, Type, Optional\nfrom typing import TYPE_CHECKING\n\nfrom ctypes import c_uint64, c_uint32, sizeof\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "from strongarm.macho.macho_load_commands import MachoLoadCommands\nfrom strongarm.macho.arch_independent_structs import \\\n    MachoHeaderStruct, \\\n    MachoSegmentCommandStruct, \\\n    MachoSectionRawStruct, \\\n    MachoEncryptionInfoStruct, \\\n    MachoNlistStruct, \\\n    CFStringStruct, \\\n    DylibCommandStruct, \\\n    MachoLoadCommandStruct, \\\n    MachoSymtabCommandStruct, \\\n    MachoDysymtabCommandStruct, \\\n    MachoDyldInfoCommandStruct, \\\n    MachoLinkeditDataCommandStruct\n\nfrom ctypes import c_uint64, c_uint32, sizeof\n\n",
        "source_code_len": 526,
        "target_code": "from strongarm.macho.macho_load_commands import MachoLoadCommands\nfrom strongarm.macho.arch_independent_structs import (\n    ArchIndependentStructure,\n    MachoHeaderStruct,\n    MachoSegmentCommandStruct,\n    MachoSectionRawStruct,\n    MachoEncryptionInfoStruct,\n    MachoNlistStruct,\n    CFStringStruct,\n    DylibCommandStruct,\n    MachoLoadCommandStruct,\n    MachoSymtabCommandStruct,\n    MachoDysymtabCommandStruct,\n    MachoDyldInfoCommandStruct,\n    MachoLinkeditDataCommandStruct,\n)\n\nif TYPE_CHECKING:\n    from strongarm.macho.codesign import CodesignParser\n\n",
        "target_code_len": 565,
        "diff_format": "@@ -7,17 +10,20 @@\n from strongarm.macho.macho_load_commands import MachoLoadCommands\n-from strongarm.macho.arch_independent_structs import \\\n-    MachoHeaderStruct, \\\n-    MachoSegmentCommandStruct, \\\n-    MachoSectionRawStruct, \\\n-    MachoEncryptionInfoStruct, \\\n-    MachoNlistStruct, \\\n-    CFStringStruct, \\\n-    DylibCommandStruct, \\\n-    MachoLoadCommandStruct, \\\n-    MachoSymtabCommandStruct, \\\n-    MachoDysymtabCommandStruct, \\\n-    MachoDyldInfoCommandStruct, \\\n-    MachoLinkeditDataCommandStruct\n-\n-from ctypes import c_uint64, c_uint32, sizeof\n+from strongarm.macho.arch_independent_structs import (\n+    ArchIndependentStructure,\n+    MachoHeaderStruct,\n+    MachoSegmentCommandStruct,\n+    MachoSectionRawStruct,\n+    MachoEncryptionInfoStruct,\n+    MachoNlistStruct,\n+    CFStringStruct,\n+    DylibCommandStruct,\n+    MachoLoadCommandStruct,\n+    MachoSymtabCommandStruct,\n+    MachoDysymtabCommandStruct,\n+    MachoDyldInfoCommandStruct,\n+    MachoLinkeditDataCommandStruct,\n+)\n+\n+if TYPE_CHECKING:\n+    from strongarm.macho.codesign import CodesignParser\n \n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent": "from strongarm.macho.macho_load_commands import MachoLoadCommands\nfrom strongarm.macho.arch_independent_structs import (\n    ArchIndependentStructure,\n    MachoHeaderStruct,\n    MachoSegmentCommandStruct,\n    MachoSectionRawStruct,\n    MachoEncryptionInfoStruct,\n    MachoNlistStruct,\n    CFStringStruct,\n    DylibCommandStruct,\n    MachoLoadCommandStruct,\n    MachoSymtabCommandStruct,\n    MachoDysymtabCommandStruct,\n    MachoDyldInfoCommandStruct,\n    MachoLinkeditDataCommandStruct,\n)\n\nif TYPE_CHECKING:\n    <IND>from strongarm.macho.codesign import CodesignParser\n\n",
        "target_code_with_indent_exact_match": true,
        "source_code_with_indent": "from strongarm.macho.macho_load_commands import MachoLoadCommands\nfrom strongarm.macho.arch_independent_structs import    MachoHeaderStruct,    MachoSegmentCommandStruct,    MachoSectionRawStruct,    MachoEncryptionInfoStruct,    MachoNlistStruct,    CFStringStruct,    DylibCommandStruct,    MachoLoadCommandStruct,    MachoSymtabCommandStruct,    MachoDysymtabCommandStruct,    MachoDyldInfoCommandStruct,    MachoLinkeditDataCommandStruct\n\nfrom ctypes import c_uint64, c_uint32, sizeof\n\n"
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "        # generic Mach-O header info\n        self.is_64bit: bool = None\n        self.is_swap: bool = None\n        self.cpu_type: CPU_TYPE = None\n        self._load_commands_end_addr = None\n\n        # Mach-O header data\n        self.header: MachoHeaderStruct = None\n        self.header_flags: List[int] = None\n        self.file_type: MachoFileType = None\n\n        # segment and section commands from Mach-O header\n        self.segment_commands: Dict[str, MachoSegmentCommandStruct] = None\n        self.sections: Dict[str, MachoSection] = None\n        # also store specific interesting sections which are useful to us\n        self.dysymtab: MachoDysymtabCommandStruct = None\n        self.symtab: MachoSymtabCommandStruct = None\n        self.encryption_info: MachoEncryptionInfoStruct = None\n        self.dyld_info: MachoDyldInfoCommandStruct = None\n        self.load_dylib_commands: List[DylibCommandStruct] = None\n        self.code_signature_cmd: MachoLinkeditDataCommandStruct = None\n\n        self.__codesign_parser: CodesignParser = None\n\n",
        "source_code_len": 1040,
        "target_code": "        # generic Mach-O header info\n        self.is_64bit: bool = False\n        self.is_swap: bool = False\n        self.cpu_type: CPU_TYPE = CPU_TYPE.UNKNOWN\n        self._load_commands_end_addr = 0\n\n        # Mach-O header data\n        self._header: Optional[MachoHeaderStruct] = None\n        self.header_flags: List[int] = []\n        self.file_type: MachoFileType = MachoFileType.MH_EXECUTE\n\n        # segment and section commands from Mach-O header\n        self.segment_commands: Dict[str, MachoSegmentCommandStruct] = {}\n        self.sections: Dict[str, MachoSection] = {}\n        # also store specific interesting sections which are useful to us\n        self._dysymtab: Optional[MachoDysymtabCommandStruct] = None\n        self._symtab: Optional[MachoSymtabCommandStruct] = None\n        self._encryption_info: Optional[MachoEncryptionInfoStruct] = None\n        self._dyld_info: Optional[MachoDyldInfoCommandStruct] = None\n        self.load_dylib_commands: List[DylibCommandStruct] = []\n        self._code_signature_cmd: Optional[MachoLinkeditDataCommandStruct] = None\n\n        self.__codesign_parser: Optional[CodesignParser] = None\n\n",
        "target_code_len": 1139,
        "diff_format": "@@ -62,24 +68,24 @@\n         # generic Mach-O header info\n-        self.is_64bit: bool = None\n-        self.is_swap: bool = None\n-        self.cpu_type: CPU_TYPE = None\n-        self._load_commands_end_addr = None\n+        self.is_64bit: bool = False\n+        self.is_swap: bool = False\n+        self.cpu_type: CPU_TYPE = CPU_TYPE.UNKNOWN\n+        self._load_commands_end_addr = 0\n \n         # Mach-O header data\n-        self.header: MachoHeaderStruct = None\n-        self.header_flags: List[int] = None\n-        self.file_type: MachoFileType = None\n+        self._header: Optional[MachoHeaderStruct] = None\n+        self.header_flags: List[int] = []\n+        self.file_type: MachoFileType = MachoFileType.MH_EXECUTE\n \n         # segment and section commands from Mach-O header\n-        self.segment_commands: Dict[str, MachoSegmentCommandStruct] = None\n-        self.sections: Dict[str, MachoSection] = None\n+        self.segment_commands: Dict[str, MachoSegmentCommandStruct] = {}\n+        self.sections: Dict[str, MachoSection] = {}\n         # also store specific interesting sections which are useful to us\n-        self.dysymtab: MachoDysymtabCommandStruct = None\n-        self.symtab: MachoSymtabCommandStruct = None\n-        self.encryption_info: MachoEncryptionInfoStruct = None\n-        self.dyld_info: MachoDyldInfoCommandStruct = None\n-        self.load_dylib_commands: List[DylibCommandStruct] = None\n-        self.code_signature_cmd: MachoLinkeditDataCommandStruct = None\n-\n-        self.__codesign_parser: CodesignParser = None\n+        self._dysymtab: Optional[MachoDysymtabCommandStruct] = None\n+        self._symtab: Optional[MachoSymtabCommandStruct] = None\n+        self._encryption_info: Optional[MachoEncryptionInfoStruct] = None\n+        self._dyld_info: Optional[MachoDyldInfoCommandStruct] = None\n+        self.load_dylib_commands: List[DylibCommandStruct] = []\n+        self._code_signature_cmd: Optional[MachoLinkeditDataCommandStruct] = None\n+\n+        self.__codesign_parser: Optional[CodesignParser] = None\n \n",
        "source_code_with_indent": "        # generic Mach-O header info\n        self.is_64bit: bool = None\n        self.is_swap: bool = None\n        self.cpu_type: CPU_TYPE = None\n        self._load_commands_end_addr = None\n\n        # Mach-O header data\n        self.header: MachoHeaderStruct = None\n        self.header_flags: List[int] = None\n        self.file_type: MachoFileType = None\n\n        # segment and section commands from Mach-O header\n        self.segment_commands: Dict[str, MachoSegmentCommandStruct] = None\n        self.sections: Dict[str, MachoSection] = None\n        # also store specific interesting sections which are useful to us\n        self.dysymtab: MachoDysymtabCommandStruct = None\n        self.symtab: MachoSymtabCommandStruct = None\n        self.encryption_info: MachoEncryptionInfoStruct = None\n        self.dyld_info: MachoDyldInfoCommandStruct = None\n        self.load_dylib_commands: List[DylibCommandStruct] = None\n        self.code_signature_cmd: MachoLinkeditDataCommandStruct = None\n\n        self.__codesign_parser: CodesignParser = None\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "        # generic Mach-O header info\n        self.is_64bit: bool = False\n        self.is_swap: bool = False\n        self.cpu_type: CPU_TYPE = CPU_TYPE.UNKNOWN\n        self._load_commands_end_addr = 0\n\n        # Mach-O header data\n        self._header: Optional[MachoHeaderStruct] = None\n        self.header_flags: List[int] = []\n        self.file_type: MachoFileType = MachoFileType.MH_EXECUTE\n\n        # segment and section commands from Mach-O header\n        self.segment_commands: Dict[str, MachoSegmentCommandStruct] = {}\n        self.sections: Dict[str, MachoSection] = {}\n        # also store specific interesting sections which are useful to us\n        self._dysymtab: Optional[MachoDysymtabCommandStruct] = None\n        self._symtab: Optional[MachoSymtabCommandStruct] = None\n        self._encryption_info: Optional[MachoEncryptionInfoStruct] = None\n        self._dyld_info: Optional[MachoDyldInfoCommandStruct] = None\n        self.load_dylib_commands: List[DylibCommandStruct] = []\n        self._code_signature_cmd: Optional[MachoLinkeditDataCommandStruct] = None\n\n        self.__codesign_parser: Optional[CodesignParser] = None\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    @property\n    def slice_magic(self) -> c_uint32:\n        \"\"\"Read magic number identifier from this Mach-O slice\n        \"\"\"\n        return self.read_word(0, virtual=False, word_type=c_uint32)\n\n",
        "source_code_len": 197,
        "target_code": "    @property\n    def slice_magic(self) -> int:\n        \"\"\"Read magic number identifier from this Mach-O slice\n        \"\"\"\n        magic = self.read_word(0, virtual=False, word_type=c_uint32)\n        if magic:\n            return magic\n        else:\n            raise ValueError('Could not read magic value.')\n\n",
        "target_code_len": 310,
        "diff_format": "@@ -124,6 +131,10 @@\n     @property\n-    def slice_magic(self) -> c_uint32:\n+    def slice_magic(self) -> int:\n         \"\"\"Read magic number identifier from this Mach-O slice\n         \"\"\"\n-        return self.read_word(0, virtual=False, word_type=c_uint32)\n+        magic = self.read_word(0, virtual=False, word_type=c_uint32)\n+        if magic:\n+            return magic\n+        else:\n+            raise ValueError('Could not read magic value.')\n \n",
        "source_code_with_indent": "    <DED>@property\n    def slice_magic(self) -> c_uint32:\n        <IND>\"\"\"Read magic number identifier from this Mach-O slice\n        \"\"\"\n        return self.read_word(0, virtual=False, word_type=c_uint32)\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    <DED>@property\n    def slice_magic(self) -> int:\n        <IND>\"\"\"Read magic number identifier from this Mach-O slice\n        \"\"\"\n        magic = self.read_word(0, virtual=False, word_type=c_uint32)\n        if magic:\n            <IND>return magic\n        <DED>else:\n            <IND>raise ValueError('Could not read magic value.')\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "        \"\"\"\n        self.header = MachoHeaderStruct(self, 0)\n\n",
        "source_code_len": 62,
        "target_code": "        \"\"\"\n        self._header = MachoHeaderStruct(self, 0)\n\n",
        "target_code_len": 63,
        "diff_format": "@@ -152,3 +163,3 @@\n         \"\"\"\n-        self.header = MachoHeaderStruct(self, 0)\n+        self._header = MachoHeaderStruct(self, 0)\n \n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\n        self.header = MachoHeaderStruct(self, 0)\n\n",
        "target_code_with_indent": "\n        self._header = MachoHeaderStruct(self, 0)\n\n"
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "                                      MachoLoadCommands.LC_ENCRYPTION_INFO_64]:\n                self.encryption_info = MachoEncryptionInfoStruct(self, offset)\n\n            elif load_command.cmd == MachoLoadCommands.LC_SYMTAB:\n                self.symtab = MachoSymtabCommandStruct(self, offset)\n\n            elif load_command.cmd == MachoLoadCommands.LC_DYSYMTAB:\n                self.dysymtab = MachoDysymtabCommandStruct(self, offset)\n\n            elif load_command.cmd in [MachoLoadCommands.LC_DYLD_INFO, MachoLoadCommands.LC_DYLD_INFO_ONLY]:\n                self.dyld_info = MachoDyldInfoCommandStruct(self, offset)\n\n",
        "source_code_len": 621,
        "target_code": "                                      MachoLoadCommands.LC_ENCRYPTION_INFO_64]:\n                self._encryption_info = MachoEncryptionInfoStruct(self, offset)\n\n            elif load_command.cmd == MachoLoadCommands.LC_SYMTAB:\n                self._symtab = MachoSymtabCommandStruct(self, offset)\n\n            elif load_command.cmd == MachoLoadCommands.LC_DYSYMTAB:\n                self._dysymtab = MachoDysymtabCommandStruct(self, offset)\n\n            elif load_command.cmd in [MachoLoadCommands.LC_DYLD_INFO, MachoLoadCommands.LC_DYLD_INFO_ONLY]:\n                self._dyld_info = MachoDyldInfoCommandStruct(self, offset)\n\n",
        "target_code_len": 625,
        "diff_format": "@@ -208,12 +220,12 @@\n                                       MachoLoadCommands.LC_ENCRYPTION_INFO_64]:\n-                self.encryption_info = MachoEncryptionInfoStruct(self, offset)\n+                self._encryption_info = MachoEncryptionInfoStruct(self, offset)\n \n             elif load_command.cmd == MachoLoadCommands.LC_SYMTAB:\n-                self.symtab = MachoSymtabCommandStruct(self, offset)\n+                self._symtab = MachoSymtabCommandStruct(self, offset)\n \n             elif load_command.cmd == MachoLoadCommands.LC_DYSYMTAB:\n-                self.dysymtab = MachoDysymtabCommandStruct(self, offset)\n+                self._dysymtab = MachoDysymtabCommandStruct(self, offset)\n \n             elif load_command.cmd in [MachoLoadCommands.LC_DYLD_INFO, MachoLoadCommands.LC_DYLD_INFO_ONLY]:\n-                self.dyld_info = MachoDyldInfoCommandStruct(self, offset)\n+                self._dyld_info = MachoDyldInfoCommandStruct(self, offset)\n \n",
        "source_code_with_indent": "                                      MachoLoadCommands.LC_ENCRYPTION_INFO_64]:\n                <IND>self.encryption_info = MachoEncryptionInfoStruct(self, offset)\n\n            <DED>elif load_command.cmd == MachoLoadCommands.LC_SYMTAB:\n                <IND>self.symtab = MachoSymtabCommandStruct(self, offset)\n\n            <DED>elif load_command.cmd == MachoLoadCommands.LC_DYSYMTAB:\n                <IND>self.dysymtab = MachoDysymtabCommandStruct(self, offset)\n\n            <DED>elif load_command.cmd in [MachoLoadCommands.LC_DYLD_INFO, MachoLoadCommands.LC_DYLD_INFO_ONLY]:\n                <IND>self.dyld_info = MachoDyldInfoCommandStruct(self, offset)\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "                                      MachoLoadCommands.LC_ENCRYPTION_INFO_64]:\n                <IND>self._encryption_info = MachoEncryptionInfoStruct(self, offset)\n\n            <DED>elif load_command.cmd == MachoLoadCommands.LC_SYMTAB:\n                <IND>self._symtab = MachoSymtabCommandStruct(self, offset)\n\n            <DED>elif load_command.cmd == MachoLoadCommands.LC_DYSYMTAB:\n                <IND>self._dysymtab = MachoDysymtabCommandStruct(self, offset)\n\n            <DED>elif load_command.cmd in [MachoLoadCommands.LC_DYLD_INFO, MachoLoadCommands.LC_DYLD_INFO_ONLY]:\n                <IND>self._dyld_info = MachoDyldInfoCommandStruct(self, offset)\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "            elif load_command.cmd == MachoLoadCommands.LC_CODE_SIGNATURE:\n                self.code_signature_cmd = MachoLinkeditDataCommandStruct(self, offset)\n\n",
        "source_code_len": 162,
        "target_code": "            elif load_command.cmd == MachoLoadCommands.LC_CODE_SIGNATURE:\n                self._code_signature_cmd = MachoLinkeditDataCommandStruct(self, offset)\n\n",
        "target_code_len": 163,
        "diff_format": "@@ -225,3 +236,3 @@\n             elif load_command.cmd == MachoLoadCommands.LC_CODE_SIGNATURE:\n-                self.code_signature_cmd = MachoLinkeditDataCommandStruct(self, offset)\n+                self._code_signature_cmd = MachoLinkeditDataCommandStruct(self, offset)\n \n",
        "source_code_with_indent": "            <DED>elif load_command.cmd == MachoLoadCommands.LC_CODE_SIGNATURE:\n                <IND>self.code_signature_cmd = MachoLinkeditDataCommandStruct(self, offset)\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "            <DED>elif load_command.cmd == MachoLoadCommands.LC_CODE_SIGNATURE:\n                <IND>self._code_signature_cmd = MachoLinkeditDataCommandStruct(self, offset)\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "            indirect_symtab_entry = self.read_word(indirect_symtab_off, virtual=False, word_type=c_uint32)\n            indirect_symtab.append(int(indirect_symtab_entry.value))\n            # traverse to next pointer\n",
        "source_code_len": 215,
        "target_code": "            indirect_symtab_entry = self.read_word(indirect_symtab_off, virtual=False, word_type=c_uint32)\n            if not indirect_symtab_entry:\n                continue\n            indirect_symtab.append(int(indirect_symtab_entry))\n            # traverse to next pointer\n",
        "target_code_len": 276,
        "diff_format": "@@ -398,3 +410,5 @@\n             indirect_symtab_entry = self.read_word(indirect_symtab_off, virtual=False, word_type=c_uint32)\n-            indirect_symtab.append(int(indirect_symtab_entry.value))\n+            if not indirect_symtab_entry:\n+                continue\n+            indirect_symtab.append(int(indirect_symtab_entry))\n             # traverse to next pointer\n",
        "source_code_with_indent": "            <IND>indirect_symtab_entry = self.read_word(indirect_symtab_off, virtual=False, word_type=c_uint32)\n            indirect_symtab.append(int(indirect_symtab_entry.value))\n            # traverse to next pointer\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "            <IND>indirect_symtab_entry = self.read_word(indirect_symtab_off, virtual=False, word_type=c_uint32)\n            if not indirect_symtab_entry:\n                <IND>continue\n            <DED>indirect_symtab.append(int(indirect_symtab_entry))\n            # traverse to next pointer\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "                  address: int,\n                  virtual=True,\n                  word_type=None) -> Optional[Union[c_uint32, c_uint64]]:\n        \"\"\"Attempt to read a word from the binary at a virtual address. Returns None if the address is invalid.\n",
        "source_code_len": 250,
        "target_code": "                  address: int,\n                  virtual: bool = True,\n                  word_type: Any = None) -> Optional[int]:\n        \"\"\"Attempt to read a word from the binary at a virtual address. Returns None if the address is invalid.\n",
        "target_code_len": 243,
        "diff_format": "@@ -568,4 +595,4 @@\n                   address: int,\n-                  virtual=True,\n-                  word_type=None) -> Optional[Union[c_uint32, c_uint64]]:\n+                  virtual: bool = True,\n+                  word_type: Any = None) -> Optional[int]:\n         \"\"\"Attempt to read a word from the binary at a virtual address. Returns None if the address is invalid.\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "                  address: int,\n                  virtual=True,\n                  word_type=None) -> Optional[Union[c_uint32, c_uint64]]:\n        <IND>",
        "target_code_with_indent": "                  address: int,\n                  virtual: bool = True,\n                  word_type: Any = None) -> Optional[int]:\n        <IND>"
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    @property\n    def _codesign_parser(self) -> 'CodesignParser':\n        from strongarm.macho.codesign import CodesignParser\n        if not self.__codesign_parser:\n",
        "source_code_len": 165,
        "target_code": "    @property\n    def header(self) -> MachoHeaderStruct:\n        if self._header:\n            return self._header\n        else:\n            raise RuntimeError('Failed to parse Mach-O')\n\n    @property\n    def dysymtab(self) -> MachoDysymtabCommandStruct:\n        if self._dysymtab:\n            return self._dysymtab\n        else:\n            raise RuntimeError('Failed to parse Mach-O')\n\n    @property\n    def symtab(self) -> MachoSymtabCommandStruct:\n        if self._symtab:\n            return self._symtab\n        else:\n            raise RuntimeError('Failed to parse Mach-O')\n\n    @property\n    def encryption_info(self) -> MachoEncryptionInfoStruct:\n        if self._encryption_info:\n            return self._encryption_info\n        else:\n            raise RuntimeError('Failed to parse Mach-O')\n\n    @property\n    def dyld_info(self) -> MachoDyldInfoCommandStruct:\n        if self._dyld_info:\n            return self._dyld_info\n        else:\n            raise RuntimeError('Failed to parse Mach-O')\n\n    @property\n    def code_signature_cmd(self) -> MachoLinkeditDataCommandStruct:\n        if self._code_signature_cmd:\n            return self._code_signature_cmd\n        else:\n            raise RuntimeError('Failed to parse Mach-O')\n\n    @property\n    def _codesign_parser(self) -> 'CodesignParser':\n        if not self.__codesign_parser:\n",
        "target_code_len": 1345,
        "diff_format": "@@ -583,4 +613,45 @@\n     @property\n+    def header(self) -> MachoHeaderStruct:\n+        if self._header:\n+            return self._header\n+        else:\n+            raise RuntimeError('Failed to parse Mach-O')\n+\n+    @property\n+    def dysymtab(self) -> MachoDysymtabCommandStruct:\n+        if self._dysymtab:\n+            return self._dysymtab\n+        else:\n+            raise RuntimeError('Failed to parse Mach-O')\n+\n+    @property\n+    def symtab(self) -> MachoSymtabCommandStruct:\n+        if self._symtab:\n+            return self._symtab\n+        else:\n+            raise RuntimeError('Failed to parse Mach-O')\n+\n+    @property\n+    def encryption_info(self) -> MachoEncryptionInfoStruct:\n+        if self._encryption_info:\n+            return self._encryption_info\n+        else:\n+            raise RuntimeError('Failed to parse Mach-O')\n+\n+    @property\n+    def dyld_info(self) -> MachoDyldInfoCommandStruct:\n+        if self._dyld_info:\n+            return self._dyld_info\n+        else:\n+            raise RuntimeError('Failed to parse Mach-O')\n+\n+    @property\n+    def code_signature_cmd(self) -> MachoLinkeditDataCommandStruct:\n+        if self._code_signature_cmd:\n+            return self._code_signature_cmd\n+        else:\n+            raise RuntimeError('Failed to parse Mach-O')\n+\n+    @property\n     def _codesign_parser(self) -> 'CodesignParser':\n-        from strongarm.macho.codesign import CodesignParser\n         if not self.__codesign_parser:\n",
        "source_code_with_indent": "    <DED>@property\n    def _codesign_parser(self) -> 'CodesignParser':\n        <IND>from strongarm.macho.codesign import CodesignParser\n        if not self.__codesign_parser:\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    <DED>@property\n    def header(self) -> MachoHeaderStruct:\n        <IND>if self._header:\n            <IND>return self._header\n        <DED>else:\n            <IND>raise RuntimeError('Failed to parse Mach-O')\n\n    <DED><DED>@property\n    def dysymtab(self) -> MachoDysymtabCommandStruct:\n        <IND>if self._dysymtab:\n            <IND>return self._dysymtab\n        <DED>else:\n            <IND>raise RuntimeError('Failed to parse Mach-O')\n\n    <DED><DED>@property\n    def symtab(self) -> MachoSymtabCommandStruct:\n        <IND>if self._symtab:\n            <IND>return self._symtab\n        <DED>else:\n            <IND>raise RuntimeError('Failed to parse Mach-O')\n\n    <DED><DED>@property\n    def encryption_info(self) -> MachoEncryptionInfoStruct:\n        <IND>if self._encryption_info:\n            <IND>return self._encryption_info\n        <DED>else:\n            <IND>raise RuntimeError('Failed to parse Mach-O')\n\n    <DED><DED>@property\n    def dyld_info(self) -> MachoDyldInfoCommandStruct:\n        <IND>if self._dyld_info:\n            <IND>return self._dyld_info\n        <DED>else:\n            <IND>raise RuntimeError('Failed to parse Mach-O')\n\n    <DED><DED>@property\n    def code_signature_cmd(self) -> MachoLinkeditDataCommandStruct:\n        <IND>if self._code_signature_cmd:\n            <IND>return self._code_signature_cmd\n        <DED>else:\n            <IND>raise RuntimeError('Failed to parse Mach-O')\n\n    <DED><DED>@property\n    def _codesign_parser(self) -> 'CodesignParser':\n        <IND>if not self.__codesign_parser:\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "datatheorem/strongarm",
    "commit": "ab620d78b4ce7f933cedc25960307f2c3b03c1a8",
    "filename": "strongarm/macho/macho_binary.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/datatheorem-strongarm/strongarm/macho/macho_binary.py",
    "file_hunks_size": 33,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "strongarm/macho/macho_binary.py:71:8 Incompatible attribute type [8]: Attribute `file_type` declared in class `MachoBinary` has type `MachoFileType` but is used as type `None`.",
    "message": " Attribute `file_type` declared in class `MachoBinary` has type `MachoFileType` but is used as type `None`.",
    "rule_id": "Incompatible attribute type [8]",
    "warning_line_no": 71,
    "warning_line": "        self.file_type: MachoFileType = None",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "# -*- coding: utf-8 -*-\nfrom typing import List, Tuple, Optional, Dict, Union\n\n",
        "source_code_len": 79,
        "target_code": "# -*- coding: utf-8 -*-\nfrom typing import List, Dict, Tuple, Any, Type, Optional\nfrom typing import TYPE_CHECKING\n\nfrom ctypes import c_uint64, c_uint32, sizeof\n\n",
        "target_code_len": 163,
        "diff_format": "@@ -1,3 +1,6 @@\n # -*- coding: utf-8 -*-\n-from typing import List, Tuple, Optional, Dict, Union\n+from typing import List, Dict, Tuple, Any, Type, Optional\n+from typing import TYPE_CHECKING\n+\n+from ctypes import c_uint64, c_uint32, sizeof\n \n",
        "source_code_with_indent": "# -*- coding: utf-8 -*-\nfrom typing import List, Tuple, Optional, Dict, Union\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "# -*- coding: utf-8 -*-\nfrom typing import List, Dict, Tuple, Any, Type, Optional\nfrom typing import TYPE_CHECKING\n\nfrom ctypes import c_uint64, c_uint32, sizeof\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "from strongarm.macho.macho_load_commands import MachoLoadCommands\nfrom strongarm.macho.arch_independent_structs import \\\n    MachoHeaderStruct, \\\n    MachoSegmentCommandStruct, \\\n    MachoSectionRawStruct, \\\n    MachoEncryptionInfoStruct, \\\n    MachoNlistStruct, \\\n    CFStringStruct, \\\n    DylibCommandStruct, \\\n    MachoLoadCommandStruct, \\\n    MachoSymtabCommandStruct, \\\n    MachoDysymtabCommandStruct, \\\n    MachoDyldInfoCommandStruct, \\\n    MachoLinkeditDataCommandStruct\n\nfrom ctypes import c_uint64, c_uint32, sizeof\n\n",
        "source_code_len": 526,
        "target_code": "from strongarm.macho.macho_load_commands import MachoLoadCommands\nfrom strongarm.macho.arch_independent_structs import (\n    ArchIndependentStructure,\n    MachoHeaderStruct,\n    MachoSegmentCommandStruct,\n    MachoSectionRawStruct,\n    MachoEncryptionInfoStruct,\n    MachoNlistStruct,\n    CFStringStruct,\n    DylibCommandStruct,\n    MachoLoadCommandStruct,\n    MachoSymtabCommandStruct,\n    MachoDysymtabCommandStruct,\n    MachoDyldInfoCommandStruct,\n    MachoLinkeditDataCommandStruct,\n)\n\nif TYPE_CHECKING:\n    from strongarm.macho.codesign import CodesignParser\n\n",
        "target_code_len": 565,
        "diff_format": "@@ -7,17 +10,20 @@\n from strongarm.macho.macho_load_commands import MachoLoadCommands\n-from strongarm.macho.arch_independent_structs import \\\n-    MachoHeaderStruct, \\\n-    MachoSegmentCommandStruct, \\\n-    MachoSectionRawStruct, \\\n-    MachoEncryptionInfoStruct, \\\n-    MachoNlistStruct, \\\n-    CFStringStruct, \\\n-    DylibCommandStruct, \\\n-    MachoLoadCommandStruct, \\\n-    MachoSymtabCommandStruct, \\\n-    MachoDysymtabCommandStruct, \\\n-    MachoDyldInfoCommandStruct, \\\n-    MachoLinkeditDataCommandStruct\n-\n-from ctypes import c_uint64, c_uint32, sizeof\n+from strongarm.macho.arch_independent_structs import (\n+    ArchIndependentStructure,\n+    MachoHeaderStruct,\n+    MachoSegmentCommandStruct,\n+    MachoSectionRawStruct,\n+    MachoEncryptionInfoStruct,\n+    MachoNlistStruct,\n+    CFStringStruct,\n+    DylibCommandStruct,\n+    MachoLoadCommandStruct,\n+    MachoSymtabCommandStruct,\n+    MachoDysymtabCommandStruct,\n+    MachoDyldInfoCommandStruct,\n+    MachoLinkeditDataCommandStruct,\n+)\n+\n+if TYPE_CHECKING:\n+    from strongarm.macho.codesign import CodesignParser\n \n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent": "from strongarm.macho.macho_load_commands import MachoLoadCommands\nfrom strongarm.macho.arch_independent_structs import (\n    ArchIndependentStructure,\n    MachoHeaderStruct,\n    MachoSegmentCommandStruct,\n    MachoSectionRawStruct,\n    MachoEncryptionInfoStruct,\n    MachoNlistStruct,\n    CFStringStruct,\n    DylibCommandStruct,\n    MachoLoadCommandStruct,\n    MachoSymtabCommandStruct,\n    MachoDysymtabCommandStruct,\n    MachoDyldInfoCommandStruct,\n    MachoLinkeditDataCommandStruct,\n)\n\nif TYPE_CHECKING:\n    <IND>from strongarm.macho.codesign import CodesignParser\n\n",
        "target_code_with_indent_exact_match": true,
        "source_code_with_indent": "from strongarm.macho.macho_load_commands import MachoLoadCommands\nfrom strongarm.macho.arch_independent_structs import    MachoHeaderStruct,    MachoSegmentCommandStruct,    MachoSectionRawStruct,    MachoEncryptionInfoStruct,    MachoNlistStruct,    CFStringStruct,    DylibCommandStruct,    MachoLoadCommandStruct,    MachoSymtabCommandStruct,    MachoDysymtabCommandStruct,    MachoDyldInfoCommandStruct,    MachoLinkeditDataCommandStruct\n\nfrom ctypes import c_uint64, c_uint32, sizeof\n\n"
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "        # generic Mach-O header info\n        self.is_64bit: bool = None\n        self.is_swap: bool = None\n        self.cpu_type: CPU_TYPE = None\n        self._load_commands_end_addr = None\n\n        # Mach-O header data\n        self.header: MachoHeaderStruct = None\n        self.header_flags: List[int] = None\n        self.file_type: MachoFileType = None\n\n        # segment and section commands from Mach-O header\n        self.segment_commands: Dict[str, MachoSegmentCommandStruct] = None\n        self.sections: Dict[str, MachoSection] = None\n        # also store specific interesting sections which are useful to us\n        self.dysymtab: MachoDysymtabCommandStruct = None\n        self.symtab: MachoSymtabCommandStruct = None\n        self.encryption_info: MachoEncryptionInfoStruct = None\n        self.dyld_info: MachoDyldInfoCommandStruct = None\n        self.load_dylib_commands: List[DylibCommandStruct] = None\n        self.code_signature_cmd: MachoLinkeditDataCommandStruct = None\n\n        self.__codesign_parser: CodesignParser = None\n\n",
        "source_code_len": 1040,
        "target_code": "        # generic Mach-O header info\n        self.is_64bit: bool = False\n        self.is_swap: bool = False\n        self.cpu_type: CPU_TYPE = CPU_TYPE.UNKNOWN\n        self._load_commands_end_addr = 0\n\n        # Mach-O header data\n        self._header: Optional[MachoHeaderStruct] = None\n        self.header_flags: List[int] = []\n        self.file_type: MachoFileType = MachoFileType.MH_EXECUTE\n\n        # segment and section commands from Mach-O header\n        self.segment_commands: Dict[str, MachoSegmentCommandStruct] = {}\n        self.sections: Dict[str, MachoSection] = {}\n        # also store specific interesting sections which are useful to us\n        self._dysymtab: Optional[MachoDysymtabCommandStruct] = None\n        self._symtab: Optional[MachoSymtabCommandStruct] = None\n        self._encryption_info: Optional[MachoEncryptionInfoStruct] = None\n        self._dyld_info: Optional[MachoDyldInfoCommandStruct] = None\n        self.load_dylib_commands: List[DylibCommandStruct] = []\n        self._code_signature_cmd: Optional[MachoLinkeditDataCommandStruct] = None\n\n        self.__codesign_parser: Optional[CodesignParser] = None\n\n",
        "target_code_len": 1139,
        "diff_format": "@@ -62,24 +68,24 @@\n         # generic Mach-O header info\n-        self.is_64bit: bool = None\n-        self.is_swap: bool = None\n-        self.cpu_type: CPU_TYPE = None\n-        self._load_commands_end_addr = None\n+        self.is_64bit: bool = False\n+        self.is_swap: bool = False\n+        self.cpu_type: CPU_TYPE = CPU_TYPE.UNKNOWN\n+        self._load_commands_end_addr = 0\n \n         # Mach-O header data\n-        self.header: MachoHeaderStruct = None\n-        self.header_flags: List[int] = None\n-        self.file_type: MachoFileType = None\n+        self._header: Optional[MachoHeaderStruct] = None\n+        self.header_flags: List[int] = []\n+        self.file_type: MachoFileType = MachoFileType.MH_EXECUTE\n \n         # segment and section commands from Mach-O header\n-        self.segment_commands: Dict[str, MachoSegmentCommandStruct] = None\n-        self.sections: Dict[str, MachoSection] = None\n+        self.segment_commands: Dict[str, MachoSegmentCommandStruct] = {}\n+        self.sections: Dict[str, MachoSection] = {}\n         # also store specific interesting sections which are useful to us\n-        self.dysymtab: MachoDysymtabCommandStruct = None\n-        self.symtab: MachoSymtabCommandStruct = None\n-        self.encryption_info: MachoEncryptionInfoStruct = None\n-        self.dyld_info: MachoDyldInfoCommandStruct = None\n-        self.load_dylib_commands: List[DylibCommandStruct] = None\n-        self.code_signature_cmd: MachoLinkeditDataCommandStruct = None\n-\n-        self.__codesign_parser: CodesignParser = None\n+        self._dysymtab: Optional[MachoDysymtabCommandStruct] = None\n+        self._symtab: Optional[MachoSymtabCommandStruct] = None\n+        self._encryption_info: Optional[MachoEncryptionInfoStruct] = None\n+        self._dyld_info: Optional[MachoDyldInfoCommandStruct] = None\n+        self.load_dylib_commands: List[DylibCommandStruct] = []\n+        self._code_signature_cmd: Optional[MachoLinkeditDataCommandStruct] = None\n+\n+        self.__codesign_parser: Optional[CodesignParser] = None\n \n",
        "source_code_with_indent": "        # generic Mach-O header info\n        self.is_64bit: bool = None\n        self.is_swap: bool = None\n        self.cpu_type: CPU_TYPE = None\n        self._load_commands_end_addr = None\n\n        # Mach-O header data\n        self.header: MachoHeaderStruct = None\n        self.header_flags: List[int] = None\n        self.file_type: MachoFileType = None\n\n        # segment and section commands from Mach-O header\n        self.segment_commands: Dict[str, MachoSegmentCommandStruct] = None\n        self.sections: Dict[str, MachoSection] = None\n        # also store specific interesting sections which are useful to us\n        self.dysymtab: MachoDysymtabCommandStruct = None\n        self.symtab: MachoSymtabCommandStruct = None\n        self.encryption_info: MachoEncryptionInfoStruct = None\n        self.dyld_info: MachoDyldInfoCommandStruct = None\n        self.load_dylib_commands: List[DylibCommandStruct] = None\n        self.code_signature_cmd: MachoLinkeditDataCommandStruct = None\n\n        self.__codesign_parser: CodesignParser = None\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "        # generic Mach-O header info\n        self.is_64bit: bool = False\n        self.is_swap: bool = False\n        self.cpu_type: CPU_TYPE = CPU_TYPE.UNKNOWN\n        self._load_commands_end_addr = 0\n\n        # Mach-O header data\n        self._header: Optional[MachoHeaderStruct] = None\n        self.header_flags: List[int] = []\n        self.file_type: MachoFileType = MachoFileType.MH_EXECUTE\n\n        # segment and section commands from Mach-O header\n        self.segment_commands: Dict[str, MachoSegmentCommandStruct] = {}\n        self.sections: Dict[str, MachoSection] = {}\n        # also store specific interesting sections which are useful to us\n        self._dysymtab: Optional[MachoDysymtabCommandStruct] = None\n        self._symtab: Optional[MachoSymtabCommandStruct] = None\n        self._encryption_info: Optional[MachoEncryptionInfoStruct] = None\n        self._dyld_info: Optional[MachoDyldInfoCommandStruct] = None\n        self.load_dylib_commands: List[DylibCommandStruct] = []\n        self._code_signature_cmd: Optional[MachoLinkeditDataCommandStruct] = None\n\n        self.__codesign_parser: Optional[CodesignParser] = None\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    @property\n    def slice_magic(self) -> c_uint32:\n        \"\"\"Read magic number identifier from this Mach-O slice\n        \"\"\"\n        return self.read_word(0, virtual=False, word_type=c_uint32)\n\n",
        "source_code_len": 197,
        "target_code": "    @property\n    def slice_magic(self) -> int:\n        \"\"\"Read magic number identifier from this Mach-O slice\n        \"\"\"\n        magic = self.read_word(0, virtual=False, word_type=c_uint32)\n        if magic:\n            return magic\n        else:\n            raise ValueError('Could not read magic value.')\n\n",
        "target_code_len": 310,
        "diff_format": "@@ -124,6 +131,10 @@\n     @property\n-    def slice_magic(self) -> c_uint32:\n+    def slice_magic(self) -> int:\n         \"\"\"Read magic number identifier from this Mach-O slice\n         \"\"\"\n-        return self.read_word(0, virtual=False, word_type=c_uint32)\n+        magic = self.read_word(0, virtual=False, word_type=c_uint32)\n+        if magic:\n+            return magic\n+        else:\n+            raise ValueError('Could not read magic value.')\n \n",
        "source_code_with_indent": "    <DED>@property\n    def slice_magic(self) -> c_uint32:\n        <IND>\"\"\"Read magic number identifier from this Mach-O slice\n        \"\"\"\n        return self.read_word(0, virtual=False, word_type=c_uint32)\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    <DED>@property\n    def slice_magic(self) -> int:\n        <IND>\"\"\"Read magic number identifier from this Mach-O slice\n        \"\"\"\n        magic = self.read_word(0, virtual=False, word_type=c_uint32)\n        if magic:\n            <IND>return magic\n        <DED>else:\n            <IND>raise ValueError('Could not read magic value.')\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "        \"\"\"\n        self.header = MachoHeaderStruct(self, 0)\n\n",
        "source_code_len": 62,
        "target_code": "        \"\"\"\n        self._header = MachoHeaderStruct(self, 0)\n\n",
        "target_code_len": 63,
        "diff_format": "@@ -152,3 +163,3 @@\n         \"\"\"\n-        self.header = MachoHeaderStruct(self, 0)\n+        self._header = MachoHeaderStruct(self, 0)\n \n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\n        self.header = MachoHeaderStruct(self, 0)\n\n",
        "target_code_with_indent": "\n        self._header = MachoHeaderStruct(self, 0)\n\n"
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "                                      MachoLoadCommands.LC_ENCRYPTION_INFO_64]:\n                self.encryption_info = MachoEncryptionInfoStruct(self, offset)\n\n            elif load_command.cmd == MachoLoadCommands.LC_SYMTAB:\n                self.symtab = MachoSymtabCommandStruct(self, offset)\n\n            elif load_command.cmd == MachoLoadCommands.LC_DYSYMTAB:\n                self.dysymtab = MachoDysymtabCommandStruct(self, offset)\n\n            elif load_command.cmd in [MachoLoadCommands.LC_DYLD_INFO, MachoLoadCommands.LC_DYLD_INFO_ONLY]:\n                self.dyld_info = MachoDyldInfoCommandStruct(self, offset)\n\n",
        "source_code_len": 621,
        "target_code": "                                      MachoLoadCommands.LC_ENCRYPTION_INFO_64]:\n                self._encryption_info = MachoEncryptionInfoStruct(self, offset)\n\n            elif load_command.cmd == MachoLoadCommands.LC_SYMTAB:\n                self._symtab = MachoSymtabCommandStruct(self, offset)\n\n            elif load_command.cmd == MachoLoadCommands.LC_DYSYMTAB:\n                self._dysymtab = MachoDysymtabCommandStruct(self, offset)\n\n            elif load_command.cmd in [MachoLoadCommands.LC_DYLD_INFO, MachoLoadCommands.LC_DYLD_INFO_ONLY]:\n                self._dyld_info = MachoDyldInfoCommandStruct(self, offset)\n\n",
        "target_code_len": 625,
        "diff_format": "@@ -208,12 +220,12 @@\n                                       MachoLoadCommands.LC_ENCRYPTION_INFO_64]:\n-                self.encryption_info = MachoEncryptionInfoStruct(self, offset)\n+                self._encryption_info = MachoEncryptionInfoStruct(self, offset)\n \n             elif load_command.cmd == MachoLoadCommands.LC_SYMTAB:\n-                self.symtab = MachoSymtabCommandStruct(self, offset)\n+                self._symtab = MachoSymtabCommandStruct(self, offset)\n \n             elif load_command.cmd == MachoLoadCommands.LC_DYSYMTAB:\n-                self.dysymtab = MachoDysymtabCommandStruct(self, offset)\n+                self._dysymtab = MachoDysymtabCommandStruct(self, offset)\n \n             elif load_command.cmd in [MachoLoadCommands.LC_DYLD_INFO, MachoLoadCommands.LC_DYLD_INFO_ONLY]:\n-                self.dyld_info = MachoDyldInfoCommandStruct(self, offset)\n+                self._dyld_info = MachoDyldInfoCommandStruct(self, offset)\n \n",
        "source_code_with_indent": "                                      MachoLoadCommands.LC_ENCRYPTION_INFO_64]:\n                <IND>self.encryption_info = MachoEncryptionInfoStruct(self, offset)\n\n            <DED>elif load_command.cmd == MachoLoadCommands.LC_SYMTAB:\n                <IND>self.symtab = MachoSymtabCommandStruct(self, offset)\n\n            <DED>elif load_command.cmd == MachoLoadCommands.LC_DYSYMTAB:\n                <IND>self.dysymtab = MachoDysymtabCommandStruct(self, offset)\n\n            <DED>elif load_command.cmd in [MachoLoadCommands.LC_DYLD_INFO, MachoLoadCommands.LC_DYLD_INFO_ONLY]:\n                <IND>self.dyld_info = MachoDyldInfoCommandStruct(self, offset)\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "                                      MachoLoadCommands.LC_ENCRYPTION_INFO_64]:\n                <IND>self._encryption_info = MachoEncryptionInfoStruct(self, offset)\n\n            <DED>elif load_command.cmd == MachoLoadCommands.LC_SYMTAB:\n                <IND>self._symtab = MachoSymtabCommandStruct(self, offset)\n\n            <DED>elif load_command.cmd == MachoLoadCommands.LC_DYSYMTAB:\n                <IND>self._dysymtab = MachoDysymtabCommandStruct(self, offset)\n\n            <DED>elif load_command.cmd in [MachoLoadCommands.LC_DYLD_INFO, MachoLoadCommands.LC_DYLD_INFO_ONLY]:\n                <IND>self._dyld_info = MachoDyldInfoCommandStruct(self, offset)\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "            elif load_command.cmd == MachoLoadCommands.LC_CODE_SIGNATURE:\n                self.code_signature_cmd = MachoLinkeditDataCommandStruct(self, offset)\n\n",
        "source_code_len": 162,
        "target_code": "            elif load_command.cmd == MachoLoadCommands.LC_CODE_SIGNATURE:\n                self._code_signature_cmd = MachoLinkeditDataCommandStruct(self, offset)\n\n",
        "target_code_len": 163,
        "diff_format": "@@ -225,3 +236,3 @@\n             elif load_command.cmd == MachoLoadCommands.LC_CODE_SIGNATURE:\n-                self.code_signature_cmd = MachoLinkeditDataCommandStruct(self, offset)\n+                self._code_signature_cmd = MachoLinkeditDataCommandStruct(self, offset)\n \n",
        "source_code_with_indent": "            <DED>elif load_command.cmd == MachoLoadCommands.LC_CODE_SIGNATURE:\n                <IND>self.code_signature_cmd = MachoLinkeditDataCommandStruct(self, offset)\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "            <DED>elif load_command.cmd == MachoLoadCommands.LC_CODE_SIGNATURE:\n                <IND>self._code_signature_cmd = MachoLinkeditDataCommandStruct(self, offset)\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "            indirect_symtab_entry = self.read_word(indirect_symtab_off, virtual=False, word_type=c_uint32)\n            indirect_symtab.append(int(indirect_symtab_entry.value))\n            # traverse to next pointer\n",
        "source_code_len": 215,
        "target_code": "            indirect_symtab_entry = self.read_word(indirect_symtab_off, virtual=False, word_type=c_uint32)\n            if not indirect_symtab_entry:\n                continue\n            indirect_symtab.append(int(indirect_symtab_entry))\n            # traverse to next pointer\n",
        "target_code_len": 276,
        "diff_format": "@@ -398,3 +410,5 @@\n             indirect_symtab_entry = self.read_word(indirect_symtab_off, virtual=False, word_type=c_uint32)\n-            indirect_symtab.append(int(indirect_symtab_entry.value))\n+            if not indirect_symtab_entry:\n+                continue\n+            indirect_symtab.append(int(indirect_symtab_entry))\n             # traverse to next pointer\n",
        "source_code_with_indent": "            <IND>indirect_symtab_entry = self.read_word(indirect_symtab_off, virtual=False, word_type=c_uint32)\n            indirect_symtab.append(int(indirect_symtab_entry.value))\n            # traverse to next pointer\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "            <IND>indirect_symtab_entry = self.read_word(indirect_symtab_off, virtual=False, word_type=c_uint32)\n            if not indirect_symtab_entry:\n                <IND>continue\n            <DED>indirect_symtab.append(int(indirect_symtab_entry))\n            # traverse to next pointer\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "                  address: int,\n                  virtual=True,\n                  word_type=None) -> Optional[Union[c_uint32, c_uint64]]:\n        \"\"\"Attempt to read a word from the binary at a virtual address. Returns None if the address is invalid.\n",
        "source_code_len": 250,
        "target_code": "                  address: int,\n                  virtual: bool = True,\n                  word_type: Any = None) -> Optional[int]:\n        \"\"\"Attempt to read a word from the binary at a virtual address. Returns None if the address is invalid.\n",
        "target_code_len": 243,
        "diff_format": "@@ -568,4 +595,4 @@\n                   address: int,\n-                  virtual=True,\n-                  word_type=None) -> Optional[Union[c_uint32, c_uint64]]:\n+                  virtual: bool = True,\n+                  word_type: Any = None) -> Optional[int]:\n         \"\"\"Attempt to read a word from the binary at a virtual address. Returns None if the address is invalid.\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "                  address: int,\n                  virtual=True,\n                  word_type=None) -> Optional[Union[c_uint32, c_uint64]]:\n        <IND>",
        "target_code_with_indent": "                  address: int,\n                  virtual: bool = True,\n                  word_type: Any = None) -> Optional[int]:\n        <IND>"
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    @property\n    def _codesign_parser(self) -> 'CodesignParser':\n        from strongarm.macho.codesign import CodesignParser\n        if not self.__codesign_parser:\n",
        "source_code_len": 165,
        "target_code": "    @property\n    def header(self) -> MachoHeaderStruct:\n        if self._header:\n            return self._header\n        else:\n            raise RuntimeError('Failed to parse Mach-O')\n\n    @property\n    def dysymtab(self) -> MachoDysymtabCommandStruct:\n        if self._dysymtab:\n            return self._dysymtab\n        else:\n            raise RuntimeError('Failed to parse Mach-O')\n\n    @property\n    def symtab(self) -> MachoSymtabCommandStruct:\n        if self._symtab:\n            return self._symtab\n        else:\n            raise RuntimeError('Failed to parse Mach-O')\n\n    @property\n    def encryption_info(self) -> MachoEncryptionInfoStruct:\n        if self._encryption_info:\n            return self._encryption_info\n        else:\n            raise RuntimeError('Failed to parse Mach-O')\n\n    @property\n    def dyld_info(self) -> MachoDyldInfoCommandStruct:\n        if self._dyld_info:\n            return self._dyld_info\n        else:\n            raise RuntimeError('Failed to parse Mach-O')\n\n    @property\n    def code_signature_cmd(self) -> MachoLinkeditDataCommandStruct:\n        if self._code_signature_cmd:\n            return self._code_signature_cmd\n        else:\n            raise RuntimeError('Failed to parse Mach-O')\n\n    @property\n    def _codesign_parser(self) -> 'CodesignParser':\n        if not self.__codesign_parser:\n",
        "target_code_len": 1345,
        "diff_format": "@@ -583,4 +613,45 @@\n     @property\n+    def header(self) -> MachoHeaderStruct:\n+        if self._header:\n+            return self._header\n+        else:\n+            raise RuntimeError('Failed to parse Mach-O')\n+\n+    @property\n+    def dysymtab(self) -> MachoDysymtabCommandStruct:\n+        if self._dysymtab:\n+            return self._dysymtab\n+        else:\n+            raise RuntimeError('Failed to parse Mach-O')\n+\n+    @property\n+    def symtab(self) -> MachoSymtabCommandStruct:\n+        if self._symtab:\n+            return self._symtab\n+        else:\n+            raise RuntimeError('Failed to parse Mach-O')\n+\n+    @property\n+    def encryption_info(self) -> MachoEncryptionInfoStruct:\n+        if self._encryption_info:\n+            return self._encryption_info\n+        else:\n+            raise RuntimeError('Failed to parse Mach-O')\n+\n+    @property\n+    def dyld_info(self) -> MachoDyldInfoCommandStruct:\n+        if self._dyld_info:\n+            return self._dyld_info\n+        else:\n+            raise RuntimeError('Failed to parse Mach-O')\n+\n+    @property\n+    def code_signature_cmd(self) -> MachoLinkeditDataCommandStruct:\n+        if self._code_signature_cmd:\n+            return self._code_signature_cmd\n+        else:\n+            raise RuntimeError('Failed to parse Mach-O')\n+\n+    @property\n     def _codesign_parser(self) -> 'CodesignParser':\n-        from strongarm.macho.codesign import CodesignParser\n         if not self.__codesign_parser:\n",
        "source_code_with_indent": "    <DED>@property\n    def _codesign_parser(self) -> 'CodesignParser':\n        <IND>from strongarm.macho.codesign import CodesignParser\n        if not self.__codesign_parser:\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    <DED>@property\n    def header(self) -> MachoHeaderStruct:\n        <IND>if self._header:\n            <IND>return self._header\n        <DED>else:\n            <IND>raise RuntimeError('Failed to parse Mach-O')\n\n    <DED><DED>@property\n    def dysymtab(self) -> MachoDysymtabCommandStruct:\n        <IND>if self._dysymtab:\n            <IND>return self._dysymtab\n        <DED>else:\n            <IND>raise RuntimeError('Failed to parse Mach-O')\n\n    <DED><DED>@property\n    def symtab(self) -> MachoSymtabCommandStruct:\n        <IND>if self._symtab:\n            <IND>return self._symtab\n        <DED>else:\n            <IND>raise RuntimeError('Failed to parse Mach-O')\n\n    <DED><DED>@property\n    def encryption_info(self) -> MachoEncryptionInfoStruct:\n        <IND>if self._encryption_info:\n            <IND>return self._encryption_info\n        <DED>else:\n            <IND>raise RuntimeError('Failed to parse Mach-O')\n\n    <DED><DED>@property\n    def dyld_info(self) -> MachoDyldInfoCommandStruct:\n        <IND>if self._dyld_info:\n            <IND>return self._dyld_info\n        <DED>else:\n            <IND>raise RuntimeError('Failed to parse Mach-O')\n\n    <DED><DED>@property\n    def code_signature_cmd(self) -> MachoLinkeditDataCommandStruct:\n        <IND>if self._code_signature_cmd:\n            <IND>return self._code_signature_cmd\n        <DED>else:\n            <IND>raise RuntimeError('Failed to parse Mach-O')\n\n    <DED><DED>@property\n    def _codesign_parser(self) -> 'CodesignParser':\n        <IND>if not self.__codesign_parser:\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "datatheorem/strongarm",
    "commit": "ab620d78b4ce7f933cedc25960307f2c3b03c1a8",
    "filename": "strongarm/macho/macho_binary.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/datatheorem-strongarm/strongarm/macho/macho_binary.py",
    "file_hunks_size": 33,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "strongarm/macho/macho_binary.py:74:8 Incompatible attribute type [8]: Attribute `segment_commands` declared in class `MachoBinary` has type `Dict[str, MachoSegmentCommandStruct]` but is used as type `None`.",
    "message": " Attribute `segment_commands` declared in class `MachoBinary` has type `Dict[str, MachoSegmentCommandStruct]` but is used as type `None`.",
    "rule_id": "Incompatible attribute type [8]",
    "warning_line_no": 74,
    "warning_line": "        self.segment_commands: Dict[str, MachoSegmentCommandStruct] = None",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "# -*- coding: utf-8 -*-\nfrom typing import List, Tuple, Optional, Dict, Union\n\n",
        "source_code_len": 79,
        "target_code": "# -*- coding: utf-8 -*-\nfrom typing import List, Dict, Tuple, Any, Type, Optional\nfrom typing import TYPE_CHECKING\n\nfrom ctypes import c_uint64, c_uint32, sizeof\n\n",
        "target_code_len": 163,
        "diff_format": "@@ -1,3 +1,6 @@\n # -*- coding: utf-8 -*-\n-from typing import List, Tuple, Optional, Dict, Union\n+from typing import List, Dict, Tuple, Any, Type, Optional\n+from typing import TYPE_CHECKING\n+\n+from ctypes import c_uint64, c_uint32, sizeof\n \n",
        "source_code_with_indent": "# -*- coding: utf-8 -*-\nfrom typing import List, Tuple, Optional, Dict, Union\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "# -*- coding: utf-8 -*-\nfrom typing import List, Dict, Tuple, Any, Type, Optional\nfrom typing import TYPE_CHECKING\n\nfrom ctypes import c_uint64, c_uint32, sizeof\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "from strongarm.macho.macho_load_commands import MachoLoadCommands\nfrom strongarm.macho.arch_independent_structs import \\\n    MachoHeaderStruct, \\\n    MachoSegmentCommandStruct, \\\n    MachoSectionRawStruct, \\\n    MachoEncryptionInfoStruct, \\\n    MachoNlistStruct, \\\n    CFStringStruct, \\\n    DylibCommandStruct, \\\n    MachoLoadCommandStruct, \\\n    MachoSymtabCommandStruct, \\\n    MachoDysymtabCommandStruct, \\\n    MachoDyldInfoCommandStruct, \\\n    MachoLinkeditDataCommandStruct\n\nfrom ctypes import c_uint64, c_uint32, sizeof\n\n",
        "source_code_len": 526,
        "target_code": "from strongarm.macho.macho_load_commands import MachoLoadCommands\nfrom strongarm.macho.arch_independent_structs import (\n    ArchIndependentStructure,\n    MachoHeaderStruct,\n    MachoSegmentCommandStruct,\n    MachoSectionRawStruct,\n    MachoEncryptionInfoStruct,\n    MachoNlistStruct,\n    CFStringStruct,\n    DylibCommandStruct,\n    MachoLoadCommandStruct,\n    MachoSymtabCommandStruct,\n    MachoDysymtabCommandStruct,\n    MachoDyldInfoCommandStruct,\n    MachoLinkeditDataCommandStruct,\n)\n\nif TYPE_CHECKING:\n    from strongarm.macho.codesign import CodesignParser\n\n",
        "target_code_len": 565,
        "diff_format": "@@ -7,17 +10,20 @@\n from strongarm.macho.macho_load_commands import MachoLoadCommands\n-from strongarm.macho.arch_independent_structs import \\\n-    MachoHeaderStruct, \\\n-    MachoSegmentCommandStruct, \\\n-    MachoSectionRawStruct, \\\n-    MachoEncryptionInfoStruct, \\\n-    MachoNlistStruct, \\\n-    CFStringStruct, \\\n-    DylibCommandStruct, \\\n-    MachoLoadCommandStruct, \\\n-    MachoSymtabCommandStruct, \\\n-    MachoDysymtabCommandStruct, \\\n-    MachoDyldInfoCommandStruct, \\\n-    MachoLinkeditDataCommandStruct\n-\n-from ctypes import c_uint64, c_uint32, sizeof\n+from strongarm.macho.arch_independent_structs import (\n+    ArchIndependentStructure,\n+    MachoHeaderStruct,\n+    MachoSegmentCommandStruct,\n+    MachoSectionRawStruct,\n+    MachoEncryptionInfoStruct,\n+    MachoNlistStruct,\n+    CFStringStruct,\n+    DylibCommandStruct,\n+    MachoLoadCommandStruct,\n+    MachoSymtabCommandStruct,\n+    MachoDysymtabCommandStruct,\n+    MachoDyldInfoCommandStruct,\n+    MachoLinkeditDataCommandStruct,\n+)\n+\n+if TYPE_CHECKING:\n+    from strongarm.macho.codesign import CodesignParser\n \n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent": "from strongarm.macho.macho_load_commands import MachoLoadCommands\nfrom strongarm.macho.arch_independent_structs import (\n    ArchIndependentStructure,\n    MachoHeaderStruct,\n    MachoSegmentCommandStruct,\n    MachoSectionRawStruct,\n    MachoEncryptionInfoStruct,\n    MachoNlistStruct,\n    CFStringStruct,\n    DylibCommandStruct,\n    MachoLoadCommandStruct,\n    MachoSymtabCommandStruct,\n    MachoDysymtabCommandStruct,\n    MachoDyldInfoCommandStruct,\n    MachoLinkeditDataCommandStruct,\n)\n\nif TYPE_CHECKING:\n    <IND>from strongarm.macho.codesign import CodesignParser\n\n",
        "target_code_with_indent_exact_match": true,
        "source_code_with_indent": "from strongarm.macho.macho_load_commands import MachoLoadCommands\nfrom strongarm.macho.arch_independent_structs import    MachoHeaderStruct,    MachoSegmentCommandStruct,    MachoSectionRawStruct,    MachoEncryptionInfoStruct,    MachoNlistStruct,    CFStringStruct,    DylibCommandStruct,    MachoLoadCommandStruct,    MachoSymtabCommandStruct,    MachoDysymtabCommandStruct,    MachoDyldInfoCommandStruct,    MachoLinkeditDataCommandStruct\n\nfrom ctypes import c_uint64, c_uint32, sizeof\n\n"
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "        # generic Mach-O header info\n        self.is_64bit: bool = None\n        self.is_swap: bool = None\n        self.cpu_type: CPU_TYPE = None\n        self._load_commands_end_addr = None\n\n        # Mach-O header data\n        self.header: MachoHeaderStruct = None\n        self.header_flags: List[int] = None\n        self.file_type: MachoFileType = None\n\n        # segment and section commands from Mach-O header\n        self.segment_commands: Dict[str, MachoSegmentCommandStruct] = None\n        self.sections: Dict[str, MachoSection] = None\n        # also store specific interesting sections which are useful to us\n        self.dysymtab: MachoDysymtabCommandStruct = None\n        self.symtab: MachoSymtabCommandStruct = None\n        self.encryption_info: MachoEncryptionInfoStruct = None\n        self.dyld_info: MachoDyldInfoCommandStruct = None\n        self.load_dylib_commands: List[DylibCommandStruct] = None\n        self.code_signature_cmd: MachoLinkeditDataCommandStruct = None\n\n        self.__codesign_parser: CodesignParser = None\n\n",
        "source_code_len": 1040,
        "target_code": "        # generic Mach-O header info\n        self.is_64bit: bool = False\n        self.is_swap: bool = False\n        self.cpu_type: CPU_TYPE = CPU_TYPE.UNKNOWN\n        self._load_commands_end_addr = 0\n\n        # Mach-O header data\n        self._header: Optional[MachoHeaderStruct] = None\n        self.header_flags: List[int] = []\n        self.file_type: MachoFileType = MachoFileType.MH_EXECUTE\n\n        # segment and section commands from Mach-O header\n        self.segment_commands: Dict[str, MachoSegmentCommandStruct] = {}\n        self.sections: Dict[str, MachoSection] = {}\n        # also store specific interesting sections which are useful to us\n        self._dysymtab: Optional[MachoDysymtabCommandStruct] = None\n        self._symtab: Optional[MachoSymtabCommandStruct] = None\n        self._encryption_info: Optional[MachoEncryptionInfoStruct] = None\n        self._dyld_info: Optional[MachoDyldInfoCommandStruct] = None\n        self.load_dylib_commands: List[DylibCommandStruct] = []\n        self._code_signature_cmd: Optional[MachoLinkeditDataCommandStruct] = None\n\n        self.__codesign_parser: Optional[CodesignParser] = None\n\n",
        "target_code_len": 1139,
        "diff_format": "@@ -62,24 +68,24 @@\n         # generic Mach-O header info\n-        self.is_64bit: bool = None\n-        self.is_swap: bool = None\n-        self.cpu_type: CPU_TYPE = None\n-        self._load_commands_end_addr = None\n+        self.is_64bit: bool = False\n+        self.is_swap: bool = False\n+        self.cpu_type: CPU_TYPE = CPU_TYPE.UNKNOWN\n+        self._load_commands_end_addr = 0\n \n         # Mach-O header data\n-        self.header: MachoHeaderStruct = None\n-        self.header_flags: List[int] = None\n-        self.file_type: MachoFileType = None\n+        self._header: Optional[MachoHeaderStruct] = None\n+        self.header_flags: List[int] = []\n+        self.file_type: MachoFileType = MachoFileType.MH_EXECUTE\n \n         # segment and section commands from Mach-O header\n-        self.segment_commands: Dict[str, MachoSegmentCommandStruct] = None\n-        self.sections: Dict[str, MachoSection] = None\n+        self.segment_commands: Dict[str, MachoSegmentCommandStruct] = {}\n+        self.sections: Dict[str, MachoSection] = {}\n         # also store specific interesting sections which are useful to us\n-        self.dysymtab: MachoDysymtabCommandStruct = None\n-        self.symtab: MachoSymtabCommandStruct = None\n-        self.encryption_info: MachoEncryptionInfoStruct = None\n-        self.dyld_info: MachoDyldInfoCommandStruct = None\n-        self.load_dylib_commands: List[DylibCommandStruct] = None\n-        self.code_signature_cmd: MachoLinkeditDataCommandStruct = None\n-\n-        self.__codesign_parser: CodesignParser = None\n+        self._dysymtab: Optional[MachoDysymtabCommandStruct] = None\n+        self._symtab: Optional[MachoSymtabCommandStruct] = None\n+        self._encryption_info: Optional[MachoEncryptionInfoStruct] = None\n+        self._dyld_info: Optional[MachoDyldInfoCommandStruct] = None\n+        self.load_dylib_commands: List[DylibCommandStruct] = []\n+        self._code_signature_cmd: Optional[MachoLinkeditDataCommandStruct] = None\n+\n+        self.__codesign_parser: Optional[CodesignParser] = None\n \n",
        "source_code_with_indent": "        # generic Mach-O header info\n        self.is_64bit: bool = None\n        self.is_swap: bool = None\n        self.cpu_type: CPU_TYPE = None\n        self._load_commands_end_addr = None\n\n        # Mach-O header data\n        self.header: MachoHeaderStruct = None\n        self.header_flags: List[int] = None\n        self.file_type: MachoFileType = None\n\n        # segment and section commands from Mach-O header\n        self.segment_commands: Dict[str, MachoSegmentCommandStruct] = None\n        self.sections: Dict[str, MachoSection] = None\n        # also store specific interesting sections which are useful to us\n        self.dysymtab: MachoDysymtabCommandStruct = None\n        self.symtab: MachoSymtabCommandStruct = None\n        self.encryption_info: MachoEncryptionInfoStruct = None\n        self.dyld_info: MachoDyldInfoCommandStruct = None\n        self.load_dylib_commands: List[DylibCommandStruct] = None\n        self.code_signature_cmd: MachoLinkeditDataCommandStruct = None\n\n        self.__codesign_parser: CodesignParser = None\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "        # generic Mach-O header info\n        self.is_64bit: bool = False\n        self.is_swap: bool = False\n        self.cpu_type: CPU_TYPE = CPU_TYPE.UNKNOWN\n        self._load_commands_end_addr = 0\n\n        # Mach-O header data\n        self._header: Optional[MachoHeaderStruct] = None\n        self.header_flags: List[int] = []\n        self.file_type: MachoFileType = MachoFileType.MH_EXECUTE\n\n        # segment and section commands from Mach-O header\n        self.segment_commands: Dict[str, MachoSegmentCommandStruct] = {}\n        self.sections: Dict[str, MachoSection] = {}\n        # also store specific interesting sections which are useful to us\n        self._dysymtab: Optional[MachoDysymtabCommandStruct] = None\n        self._symtab: Optional[MachoSymtabCommandStruct] = None\n        self._encryption_info: Optional[MachoEncryptionInfoStruct] = None\n        self._dyld_info: Optional[MachoDyldInfoCommandStruct] = None\n        self.load_dylib_commands: List[DylibCommandStruct] = []\n        self._code_signature_cmd: Optional[MachoLinkeditDataCommandStruct] = None\n\n        self.__codesign_parser: Optional[CodesignParser] = None\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    @property\n    def slice_magic(self) -> c_uint32:\n        \"\"\"Read magic number identifier from this Mach-O slice\n        \"\"\"\n        return self.read_word(0, virtual=False, word_type=c_uint32)\n\n",
        "source_code_len": 197,
        "target_code": "    @property\n    def slice_magic(self) -> int:\n        \"\"\"Read magic number identifier from this Mach-O slice\n        \"\"\"\n        magic = self.read_word(0, virtual=False, word_type=c_uint32)\n        if magic:\n            return magic\n        else:\n            raise ValueError('Could not read magic value.')\n\n",
        "target_code_len": 310,
        "diff_format": "@@ -124,6 +131,10 @@\n     @property\n-    def slice_magic(self) -> c_uint32:\n+    def slice_magic(self) -> int:\n         \"\"\"Read magic number identifier from this Mach-O slice\n         \"\"\"\n-        return self.read_word(0, virtual=False, word_type=c_uint32)\n+        magic = self.read_word(0, virtual=False, word_type=c_uint32)\n+        if magic:\n+            return magic\n+        else:\n+            raise ValueError('Could not read magic value.')\n \n",
        "source_code_with_indent": "    <DED>@property\n    def slice_magic(self) -> c_uint32:\n        <IND>\"\"\"Read magic number identifier from this Mach-O slice\n        \"\"\"\n        return self.read_word(0, virtual=False, word_type=c_uint32)\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    <DED>@property\n    def slice_magic(self) -> int:\n        <IND>\"\"\"Read magic number identifier from this Mach-O slice\n        \"\"\"\n        magic = self.read_word(0, virtual=False, word_type=c_uint32)\n        if magic:\n            <IND>return magic\n        <DED>else:\n            <IND>raise ValueError('Could not read magic value.')\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "        \"\"\"\n        self.header = MachoHeaderStruct(self, 0)\n\n",
        "source_code_len": 62,
        "target_code": "        \"\"\"\n        self._header = MachoHeaderStruct(self, 0)\n\n",
        "target_code_len": 63,
        "diff_format": "@@ -152,3 +163,3 @@\n         \"\"\"\n-        self.header = MachoHeaderStruct(self, 0)\n+        self._header = MachoHeaderStruct(self, 0)\n \n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\n        self.header = MachoHeaderStruct(self, 0)\n\n",
        "target_code_with_indent": "\n        self._header = MachoHeaderStruct(self, 0)\n\n"
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "                                      MachoLoadCommands.LC_ENCRYPTION_INFO_64]:\n                self.encryption_info = MachoEncryptionInfoStruct(self, offset)\n\n            elif load_command.cmd == MachoLoadCommands.LC_SYMTAB:\n                self.symtab = MachoSymtabCommandStruct(self, offset)\n\n            elif load_command.cmd == MachoLoadCommands.LC_DYSYMTAB:\n                self.dysymtab = MachoDysymtabCommandStruct(self, offset)\n\n            elif load_command.cmd in [MachoLoadCommands.LC_DYLD_INFO, MachoLoadCommands.LC_DYLD_INFO_ONLY]:\n                self.dyld_info = MachoDyldInfoCommandStruct(self, offset)\n\n",
        "source_code_len": 621,
        "target_code": "                                      MachoLoadCommands.LC_ENCRYPTION_INFO_64]:\n                self._encryption_info = MachoEncryptionInfoStruct(self, offset)\n\n            elif load_command.cmd == MachoLoadCommands.LC_SYMTAB:\n                self._symtab = MachoSymtabCommandStruct(self, offset)\n\n            elif load_command.cmd == MachoLoadCommands.LC_DYSYMTAB:\n                self._dysymtab = MachoDysymtabCommandStruct(self, offset)\n\n            elif load_command.cmd in [MachoLoadCommands.LC_DYLD_INFO, MachoLoadCommands.LC_DYLD_INFO_ONLY]:\n                self._dyld_info = MachoDyldInfoCommandStruct(self, offset)\n\n",
        "target_code_len": 625,
        "diff_format": "@@ -208,12 +220,12 @@\n                                       MachoLoadCommands.LC_ENCRYPTION_INFO_64]:\n-                self.encryption_info = MachoEncryptionInfoStruct(self, offset)\n+                self._encryption_info = MachoEncryptionInfoStruct(self, offset)\n \n             elif load_command.cmd == MachoLoadCommands.LC_SYMTAB:\n-                self.symtab = MachoSymtabCommandStruct(self, offset)\n+                self._symtab = MachoSymtabCommandStruct(self, offset)\n \n             elif load_command.cmd == MachoLoadCommands.LC_DYSYMTAB:\n-                self.dysymtab = MachoDysymtabCommandStruct(self, offset)\n+                self._dysymtab = MachoDysymtabCommandStruct(self, offset)\n \n             elif load_command.cmd in [MachoLoadCommands.LC_DYLD_INFO, MachoLoadCommands.LC_DYLD_INFO_ONLY]:\n-                self.dyld_info = MachoDyldInfoCommandStruct(self, offset)\n+                self._dyld_info = MachoDyldInfoCommandStruct(self, offset)\n \n",
        "source_code_with_indent": "                                      MachoLoadCommands.LC_ENCRYPTION_INFO_64]:\n                <IND>self.encryption_info = MachoEncryptionInfoStruct(self, offset)\n\n            <DED>elif load_command.cmd == MachoLoadCommands.LC_SYMTAB:\n                <IND>self.symtab = MachoSymtabCommandStruct(self, offset)\n\n            <DED>elif load_command.cmd == MachoLoadCommands.LC_DYSYMTAB:\n                <IND>self.dysymtab = MachoDysymtabCommandStruct(self, offset)\n\n            <DED>elif load_command.cmd in [MachoLoadCommands.LC_DYLD_INFO, MachoLoadCommands.LC_DYLD_INFO_ONLY]:\n                <IND>self.dyld_info = MachoDyldInfoCommandStruct(self, offset)\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "                                      MachoLoadCommands.LC_ENCRYPTION_INFO_64]:\n                <IND>self._encryption_info = MachoEncryptionInfoStruct(self, offset)\n\n            <DED>elif load_command.cmd == MachoLoadCommands.LC_SYMTAB:\n                <IND>self._symtab = MachoSymtabCommandStruct(self, offset)\n\n            <DED>elif load_command.cmd == MachoLoadCommands.LC_DYSYMTAB:\n                <IND>self._dysymtab = MachoDysymtabCommandStruct(self, offset)\n\n            <DED>elif load_command.cmd in [MachoLoadCommands.LC_DYLD_INFO, MachoLoadCommands.LC_DYLD_INFO_ONLY]:\n                <IND>self._dyld_info = MachoDyldInfoCommandStruct(self, offset)\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "            elif load_command.cmd == MachoLoadCommands.LC_CODE_SIGNATURE:\n                self.code_signature_cmd = MachoLinkeditDataCommandStruct(self, offset)\n\n",
        "source_code_len": 162,
        "target_code": "            elif load_command.cmd == MachoLoadCommands.LC_CODE_SIGNATURE:\n                self._code_signature_cmd = MachoLinkeditDataCommandStruct(self, offset)\n\n",
        "target_code_len": 163,
        "diff_format": "@@ -225,3 +236,3 @@\n             elif load_command.cmd == MachoLoadCommands.LC_CODE_SIGNATURE:\n-                self.code_signature_cmd = MachoLinkeditDataCommandStruct(self, offset)\n+                self._code_signature_cmd = MachoLinkeditDataCommandStruct(self, offset)\n \n",
        "source_code_with_indent": "            <DED>elif load_command.cmd == MachoLoadCommands.LC_CODE_SIGNATURE:\n                <IND>self.code_signature_cmd = MachoLinkeditDataCommandStruct(self, offset)\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "            <DED>elif load_command.cmd == MachoLoadCommands.LC_CODE_SIGNATURE:\n                <IND>self._code_signature_cmd = MachoLinkeditDataCommandStruct(self, offset)\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "            indirect_symtab_entry = self.read_word(indirect_symtab_off, virtual=False, word_type=c_uint32)\n            indirect_symtab.append(int(indirect_symtab_entry.value))\n            # traverse to next pointer\n",
        "source_code_len": 215,
        "target_code": "            indirect_symtab_entry = self.read_word(indirect_symtab_off, virtual=False, word_type=c_uint32)\n            if not indirect_symtab_entry:\n                continue\n            indirect_symtab.append(int(indirect_symtab_entry))\n            # traverse to next pointer\n",
        "target_code_len": 276,
        "diff_format": "@@ -398,3 +410,5 @@\n             indirect_symtab_entry = self.read_word(indirect_symtab_off, virtual=False, word_type=c_uint32)\n-            indirect_symtab.append(int(indirect_symtab_entry.value))\n+            if not indirect_symtab_entry:\n+                continue\n+            indirect_symtab.append(int(indirect_symtab_entry))\n             # traverse to next pointer\n",
        "source_code_with_indent": "            <IND>indirect_symtab_entry = self.read_word(indirect_symtab_off, virtual=False, word_type=c_uint32)\n            indirect_symtab.append(int(indirect_symtab_entry.value))\n            # traverse to next pointer\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "            <IND>indirect_symtab_entry = self.read_word(indirect_symtab_off, virtual=False, word_type=c_uint32)\n            if not indirect_symtab_entry:\n                <IND>continue\n            <DED>indirect_symtab.append(int(indirect_symtab_entry))\n            # traverse to next pointer\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "                  address: int,\n                  virtual=True,\n                  word_type=None) -> Optional[Union[c_uint32, c_uint64]]:\n        \"\"\"Attempt to read a word from the binary at a virtual address. Returns None if the address is invalid.\n",
        "source_code_len": 250,
        "target_code": "                  address: int,\n                  virtual: bool = True,\n                  word_type: Any = None) -> Optional[int]:\n        \"\"\"Attempt to read a word from the binary at a virtual address. Returns None if the address is invalid.\n",
        "target_code_len": 243,
        "diff_format": "@@ -568,4 +595,4 @@\n                   address: int,\n-                  virtual=True,\n-                  word_type=None) -> Optional[Union[c_uint32, c_uint64]]:\n+                  virtual: bool = True,\n+                  word_type: Any = None) -> Optional[int]:\n         \"\"\"Attempt to read a word from the binary at a virtual address. Returns None if the address is invalid.\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "                  address: int,\n                  virtual=True,\n                  word_type=None) -> Optional[Union[c_uint32, c_uint64]]:\n        <IND>",
        "target_code_with_indent": "                  address: int,\n                  virtual: bool = True,\n                  word_type: Any = None) -> Optional[int]:\n        <IND>"
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    @property\n    def _codesign_parser(self) -> 'CodesignParser':\n        from strongarm.macho.codesign import CodesignParser\n        if not self.__codesign_parser:\n",
        "source_code_len": 165,
        "target_code": "    @property\n    def header(self) -> MachoHeaderStruct:\n        if self._header:\n            return self._header\n        else:\n            raise RuntimeError('Failed to parse Mach-O')\n\n    @property\n    def dysymtab(self) -> MachoDysymtabCommandStruct:\n        if self._dysymtab:\n            return self._dysymtab\n        else:\n            raise RuntimeError('Failed to parse Mach-O')\n\n    @property\n    def symtab(self) -> MachoSymtabCommandStruct:\n        if self._symtab:\n            return self._symtab\n        else:\n            raise RuntimeError('Failed to parse Mach-O')\n\n    @property\n    def encryption_info(self) -> MachoEncryptionInfoStruct:\n        if self._encryption_info:\n            return self._encryption_info\n        else:\n            raise RuntimeError('Failed to parse Mach-O')\n\n    @property\n    def dyld_info(self) -> MachoDyldInfoCommandStruct:\n        if self._dyld_info:\n            return self._dyld_info\n        else:\n            raise RuntimeError('Failed to parse Mach-O')\n\n    @property\n    def code_signature_cmd(self) -> MachoLinkeditDataCommandStruct:\n        if self._code_signature_cmd:\n            return self._code_signature_cmd\n        else:\n            raise RuntimeError('Failed to parse Mach-O')\n\n    @property\n    def _codesign_parser(self) -> 'CodesignParser':\n        if not self.__codesign_parser:\n",
        "target_code_len": 1345,
        "diff_format": "@@ -583,4 +613,45 @@\n     @property\n+    def header(self) -> MachoHeaderStruct:\n+        if self._header:\n+            return self._header\n+        else:\n+            raise RuntimeError('Failed to parse Mach-O')\n+\n+    @property\n+    def dysymtab(self) -> MachoDysymtabCommandStruct:\n+        if self._dysymtab:\n+            return self._dysymtab\n+        else:\n+            raise RuntimeError('Failed to parse Mach-O')\n+\n+    @property\n+    def symtab(self) -> MachoSymtabCommandStruct:\n+        if self._symtab:\n+            return self._symtab\n+        else:\n+            raise RuntimeError('Failed to parse Mach-O')\n+\n+    @property\n+    def encryption_info(self) -> MachoEncryptionInfoStruct:\n+        if self._encryption_info:\n+            return self._encryption_info\n+        else:\n+            raise RuntimeError('Failed to parse Mach-O')\n+\n+    @property\n+    def dyld_info(self) -> MachoDyldInfoCommandStruct:\n+        if self._dyld_info:\n+            return self._dyld_info\n+        else:\n+            raise RuntimeError('Failed to parse Mach-O')\n+\n+    @property\n+    def code_signature_cmd(self) -> MachoLinkeditDataCommandStruct:\n+        if self._code_signature_cmd:\n+            return self._code_signature_cmd\n+        else:\n+            raise RuntimeError('Failed to parse Mach-O')\n+\n+    @property\n     def _codesign_parser(self) -> 'CodesignParser':\n-        from strongarm.macho.codesign import CodesignParser\n         if not self.__codesign_parser:\n",
        "source_code_with_indent": "    <DED>@property\n    def _codesign_parser(self) -> 'CodesignParser':\n        <IND>from strongarm.macho.codesign import CodesignParser\n        if not self.__codesign_parser:\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    <DED>@property\n    def header(self) -> MachoHeaderStruct:\n        <IND>if self._header:\n            <IND>return self._header\n        <DED>else:\n            <IND>raise RuntimeError('Failed to parse Mach-O')\n\n    <DED><DED>@property\n    def dysymtab(self) -> MachoDysymtabCommandStruct:\n        <IND>if self._dysymtab:\n            <IND>return self._dysymtab\n        <DED>else:\n            <IND>raise RuntimeError('Failed to parse Mach-O')\n\n    <DED><DED>@property\n    def symtab(self) -> MachoSymtabCommandStruct:\n        <IND>if self._symtab:\n            <IND>return self._symtab\n        <DED>else:\n            <IND>raise RuntimeError('Failed to parse Mach-O')\n\n    <DED><DED>@property\n    def encryption_info(self) -> MachoEncryptionInfoStruct:\n        <IND>if self._encryption_info:\n            <IND>return self._encryption_info\n        <DED>else:\n            <IND>raise RuntimeError('Failed to parse Mach-O')\n\n    <DED><DED>@property\n    def dyld_info(self) -> MachoDyldInfoCommandStruct:\n        <IND>if self._dyld_info:\n            <IND>return self._dyld_info\n        <DED>else:\n            <IND>raise RuntimeError('Failed to parse Mach-O')\n\n    <DED><DED>@property\n    def code_signature_cmd(self) -> MachoLinkeditDataCommandStruct:\n        <IND>if self._code_signature_cmd:\n            <IND>return self._code_signature_cmd\n        <DED>else:\n            <IND>raise RuntimeError('Failed to parse Mach-O')\n\n    <DED><DED>@property\n    def _codesign_parser(self) -> 'CodesignParser':\n        <IND>if not self.__codesign_parser:\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "datatheorem/strongarm",
    "commit": "ab620d78b4ce7f933cedc25960307f2c3b03c1a8",
    "filename": "strongarm/macho/macho_binary.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/datatheorem-strongarm/strongarm/macho/macho_binary.py",
    "file_hunks_size": 33,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "strongarm/macho/macho_binary.py:75:8 Incompatible attribute type [8]: Attribute `sections` declared in class `MachoBinary` has type `Dict[str, MachoSection]` but is used as type `None`.",
    "message": " Attribute `sections` declared in class `MachoBinary` has type `Dict[str, MachoSection]` but is used as type `None`.",
    "rule_id": "Incompatible attribute type [8]",
    "warning_line_no": 75,
    "warning_line": "        self.sections: Dict[str, MachoSection] = None",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "# -*- coding: utf-8 -*-\nfrom typing import List, Tuple, Optional, Dict, Union\n\n",
        "source_code_len": 79,
        "target_code": "# -*- coding: utf-8 -*-\nfrom typing import List, Dict, Tuple, Any, Type, Optional\nfrom typing import TYPE_CHECKING\n\nfrom ctypes import c_uint64, c_uint32, sizeof\n\n",
        "target_code_len": 163,
        "diff_format": "@@ -1,3 +1,6 @@\n # -*- coding: utf-8 -*-\n-from typing import List, Tuple, Optional, Dict, Union\n+from typing import List, Dict, Tuple, Any, Type, Optional\n+from typing import TYPE_CHECKING\n+\n+from ctypes import c_uint64, c_uint32, sizeof\n \n",
        "source_code_with_indent": "# -*- coding: utf-8 -*-\nfrom typing import List, Tuple, Optional, Dict, Union\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "# -*- coding: utf-8 -*-\nfrom typing import List, Dict, Tuple, Any, Type, Optional\nfrom typing import TYPE_CHECKING\n\nfrom ctypes import c_uint64, c_uint32, sizeof\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "from strongarm.macho.macho_load_commands import MachoLoadCommands\nfrom strongarm.macho.arch_independent_structs import \\\n    MachoHeaderStruct, \\\n    MachoSegmentCommandStruct, \\\n    MachoSectionRawStruct, \\\n    MachoEncryptionInfoStruct, \\\n    MachoNlistStruct, \\\n    CFStringStruct, \\\n    DylibCommandStruct, \\\n    MachoLoadCommandStruct, \\\n    MachoSymtabCommandStruct, \\\n    MachoDysymtabCommandStruct, \\\n    MachoDyldInfoCommandStruct, \\\n    MachoLinkeditDataCommandStruct\n\nfrom ctypes import c_uint64, c_uint32, sizeof\n\n",
        "source_code_len": 526,
        "target_code": "from strongarm.macho.macho_load_commands import MachoLoadCommands\nfrom strongarm.macho.arch_independent_structs import (\n    ArchIndependentStructure,\n    MachoHeaderStruct,\n    MachoSegmentCommandStruct,\n    MachoSectionRawStruct,\n    MachoEncryptionInfoStruct,\n    MachoNlistStruct,\n    CFStringStruct,\n    DylibCommandStruct,\n    MachoLoadCommandStruct,\n    MachoSymtabCommandStruct,\n    MachoDysymtabCommandStruct,\n    MachoDyldInfoCommandStruct,\n    MachoLinkeditDataCommandStruct,\n)\n\nif TYPE_CHECKING:\n    from strongarm.macho.codesign import CodesignParser\n\n",
        "target_code_len": 565,
        "diff_format": "@@ -7,17 +10,20 @@\n from strongarm.macho.macho_load_commands import MachoLoadCommands\n-from strongarm.macho.arch_independent_structs import \\\n-    MachoHeaderStruct, \\\n-    MachoSegmentCommandStruct, \\\n-    MachoSectionRawStruct, \\\n-    MachoEncryptionInfoStruct, \\\n-    MachoNlistStruct, \\\n-    CFStringStruct, \\\n-    DylibCommandStruct, \\\n-    MachoLoadCommandStruct, \\\n-    MachoSymtabCommandStruct, \\\n-    MachoDysymtabCommandStruct, \\\n-    MachoDyldInfoCommandStruct, \\\n-    MachoLinkeditDataCommandStruct\n-\n-from ctypes import c_uint64, c_uint32, sizeof\n+from strongarm.macho.arch_independent_structs import (\n+    ArchIndependentStructure,\n+    MachoHeaderStruct,\n+    MachoSegmentCommandStruct,\n+    MachoSectionRawStruct,\n+    MachoEncryptionInfoStruct,\n+    MachoNlistStruct,\n+    CFStringStruct,\n+    DylibCommandStruct,\n+    MachoLoadCommandStruct,\n+    MachoSymtabCommandStruct,\n+    MachoDysymtabCommandStruct,\n+    MachoDyldInfoCommandStruct,\n+    MachoLinkeditDataCommandStruct,\n+)\n+\n+if TYPE_CHECKING:\n+    from strongarm.macho.codesign import CodesignParser\n \n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent": "from strongarm.macho.macho_load_commands import MachoLoadCommands\nfrom strongarm.macho.arch_independent_structs import (\n    ArchIndependentStructure,\n    MachoHeaderStruct,\n    MachoSegmentCommandStruct,\n    MachoSectionRawStruct,\n    MachoEncryptionInfoStruct,\n    MachoNlistStruct,\n    CFStringStruct,\n    DylibCommandStruct,\n    MachoLoadCommandStruct,\n    MachoSymtabCommandStruct,\n    MachoDysymtabCommandStruct,\n    MachoDyldInfoCommandStruct,\n    MachoLinkeditDataCommandStruct,\n)\n\nif TYPE_CHECKING:\n    <IND>from strongarm.macho.codesign import CodesignParser\n\n",
        "target_code_with_indent_exact_match": true,
        "source_code_with_indent": "from strongarm.macho.macho_load_commands import MachoLoadCommands\nfrom strongarm.macho.arch_independent_structs import    MachoHeaderStruct,    MachoSegmentCommandStruct,    MachoSectionRawStruct,    MachoEncryptionInfoStruct,    MachoNlistStruct,    CFStringStruct,    DylibCommandStruct,    MachoLoadCommandStruct,    MachoSymtabCommandStruct,    MachoDysymtabCommandStruct,    MachoDyldInfoCommandStruct,    MachoLinkeditDataCommandStruct\n\nfrom ctypes import c_uint64, c_uint32, sizeof\n\n"
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "        # generic Mach-O header info\n        self.is_64bit: bool = None\n        self.is_swap: bool = None\n        self.cpu_type: CPU_TYPE = None\n        self._load_commands_end_addr = None\n\n        # Mach-O header data\n        self.header: MachoHeaderStruct = None\n        self.header_flags: List[int] = None\n        self.file_type: MachoFileType = None\n\n        # segment and section commands from Mach-O header\n        self.segment_commands: Dict[str, MachoSegmentCommandStruct] = None\n        self.sections: Dict[str, MachoSection] = None\n        # also store specific interesting sections which are useful to us\n        self.dysymtab: MachoDysymtabCommandStruct = None\n        self.symtab: MachoSymtabCommandStruct = None\n        self.encryption_info: MachoEncryptionInfoStruct = None\n        self.dyld_info: MachoDyldInfoCommandStruct = None\n        self.load_dylib_commands: List[DylibCommandStruct] = None\n        self.code_signature_cmd: MachoLinkeditDataCommandStruct = None\n\n        self.__codesign_parser: CodesignParser = None\n\n",
        "source_code_len": 1040,
        "target_code": "        # generic Mach-O header info\n        self.is_64bit: bool = False\n        self.is_swap: bool = False\n        self.cpu_type: CPU_TYPE = CPU_TYPE.UNKNOWN\n        self._load_commands_end_addr = 0\n\n        # Mach-O header data\n        self._header: Optional[MachoHeaderStruct] = None\n        self.header_flags: List[int] = []\n        self.file_type: MachoFileType = MachoFileType.MH_EXECUTE\n\n        # segment and section commands from Mach-O header\n        self.segment_commands: Dict[str, MachoSegmentCommandStruct] = {}\n        self.sections: Dict[str, MachoSection] = {}\n        # also store specific interesting sections which are useful to us\n        self._dysymtab: Optional[MachoDysymtabCommandStruct] = None\n        self._symtab: Optional[MachoSymtabCommandStruct] = None\n        self._encryption_info: Optional[MachoEncryptionInfoStruct] = None\n        self._dyld_info: Optional[MachoDyldInfoCommandStruct] = None\n        self.load_dylib_commands: List[DylibCommandStruct] = []\n        self._code_signature_cmd: Optional[MachoLinkeditDataCommandStruct] = None\n\n        self.__codesign_parser: Optional[CodesignParser] = None\n\n",
        "target_code_len": 1139,
        "diff_format": "@@ -62,24 +68,24 @@\n         # generic Mach-O header info\n-        self.is_64bit: bool = None\n-        self.is_swap: bool = None\n-        self.cpu_type: CPU_TYPE = None\n-        self._load_commands_end_addr = None\n+        self.is_64bit: bool = False\n+        self.is_swap: bool = False\n+        self.cpu_type: CPU_TYPE = CPU_TYPE.UNKNOWN\n+        self._load_commands_end_addr = 0\n \n         # Mach-O header data\n-        self.header: MachoHeaderStruct = None\n-        self.header_flags: List[int] = None\n-        self.file_type: MachoFileType = None\n+        self._header: Optional[MachoHeaderStruct] = None\n+        self.header_flags: List[int] = []\n+        self.file_type: MachoFileType = MachoFileType.MH_EXECUTE\n \n         # segment and section commands from Mach-O header\n-        self.segment_commands: Dict[str, MachoSegmentCommandStruct] = None\n-        self.sections: Dict[str, MachoSection] = None\n+        self.segment_commands: Dict[str, MachoSegmentCommandStruct] = {}\n+        self.sections: Dict[str, MachoSection] = {}\n         # also store specific interesting sections which are useful to us\n-        self.dysymtab: MachoDysymtabCommandStruct = None\n-        self.symtab: MachoSymtabCommandStruct = None\n-        self.encryption_info: MachoEncryptionInfoStruct = None\n-        self.dyld_info: MachoDyldInfoCommandStruct = None\n-        self.load_dylib_commands: List[DylibCommandStruct] = None\n-        self.code_signature_cmd: MachoLinkeditDataCommandStruct = None\n-\n-        self.__codesign_parser: CodesignParser = None\n+        self._dysymtab: Optional[MachoDysymtabCommandStruct] = None\n+        self._symtab: Optional[MachoSymtabCommandStruct] = None\n+        self._encryption_info: Optional[MachoEncryptionInfoStruct] = None\n+        self._dyld_info: Optional[MachoDyldInfoCommandStruct] = None\n+        self.load_dylib_commands: List[DylibCommandStruct] = []\n+        self._code_signature_cmd: Optional[MachoLinkeditDataCommandStruct] = None\n+\n+        self.__codesign_parser: Optional[CodesignParser] = None\n \n",
        "source_code_with_indent": "        # generic Mach-O header info\n        self.is_64bit: bool = None\n        self.is_swap: bool = None\n        self.cpu_type: CPU_TYPE = None\n        self._load_commands_end_addr = None\n\n        # Mach-O header data\n        self.header: MachoHeaderStruct = None\n        self.header_flags: List[int] = None\n        self.file_type: MachoFileType = None\n\n        # segment and section commands from Mach-O header\n        self.segment_commands: Dict[str, MachoSegmentCommandStruct] = None\n        self.sections: Dict[str, MachoSection] = None\n        # also store specific interesting sections which are useful to us\n        self.dysymtab: MachoDysymtabCommandStruct = None\n        self.symtab: MachoSymtabCommandStruct = None\n        self.encryption_info: MachoEncryptionInfoStruct = None\n        self.dyld_info: MachoDyldInfoCommandStruct = None\n        self.load_dylib_commands: List[DylibCommandStruct] = None\n        self.code_signature_cmd: MachoLinkeditDataCommandStruct = None\n\n        self.__codesign_parser: CodesignParser = None\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "        # generic Mach-O header info\n        self.is_64bit: bool = False\n        self.is_swap: bool = False\n        self.cpu_type: CPU_TYPE = CPU_TYPE.UNKNOWN\n        self._load_commands_end_addr = 0\n\n        # Mach-O header data\n        self._header: Optional[MachoHeaderStruct] = None\n        self.header_flags: List[int] = []\n        self.file_type: MachoFileType = MachoFileType.MH_EXECUTE\n\n        # segment and section commands from Mach-O header\n        self.segment_commands: Dict[str, MachoSegmentCommandStruct] = {}\n        self.sections: Dict[str, MachoSection] = {}\n        # also store specific interesting sections which are useful to us\n        self._dysymtab: Optional[MachoDysymtabCommandStruct] = None\n        self._symtab: Optional[MachoSymtabCommandStruct] = None\n        self._encryption_info: Optional[MachoEncryptionInfoStruct] = None\n        self._dyld_info: Optional[MachoDyldInfoCommandStruct] = None\n        self.load_dylib_commands: List[DylibCommandStruct] = []\n        self._code_signature_cmd: Optional[MachoLinkeditDataCommandStruct] = None\n\n        self.__codesign_parser: Optional[CodesignParser] = None\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    @property\n    def slice_magic(self) -> c_uint32:\n        \"\"\"Read magic number identifier from this Mach-O slice\n        \"\"\"\n        return self.read_word(0, virtual=False, word_type=c_uint32)\n\n",
        "source_code_len": 197,
        "target_code": "    @property\n    def slice_magic(self) -> int:\n        \"\"\"Read magic number identifier from this Mach-O slice\n        \"\"\"\n        magic = self.read_word(0, virtual=False, word_type=c_uint32)\n        if magic:\n            return magic\n        else:\n            raise ValueError('Could not read magic value.')\n\n",
        "target_code_len": 310,
        "diff_format": "@@ -124,6 +131,10 @@\n     @property\n-    def slice_magic(self) -> c_uint32:\n+    def slice_magic(self) -> int:\n         \"\"\"Read magic number identifier from this Mach-O slice\n         \"\"\"\n-        return self.read_word(0, virtual=False, word_type=c_uint32)\n+        magic = self.read_word(0, virtual=False, word_type=c_uint32)\n+        if magic:\n+            return magic\n+        else:\n+            raise ValueError('Could not read magic value.')\n \n",
        "source_code_with_indent": "    <DED>@property\n    def slice_magic(self) -> c_uint32:\n        <IND>\"\"\"Read magic number identifier from this Mach-O slice\n        \"\"\"\n        return self.read_word(0, virtual=False, word_type=c_uint32)\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    <DED>@property\n    def slice_magic(self) -> int:\n        <IND>\"\"\"Read magic number identifier from this Mach-O slice\n        \"\"\"\n        magic = self.read_word(0, virtual=False, word_type=c_uint32)\n        if magic:\n            <IND>return magic\n        <DED>else:\n            <IND>raise ValueError('Could not read magic value.')\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "        \"\"\"\n        self.header = MachoHeaderStruct(self, 0)\n\n",
        "source_code_len": 62,
        "target_code": "        \"\"\"\n        self._header = MachoHeaderStruct(self, 0)\n\n",
        "target_code_len": 63,
        "diff_format": "@@ -152,3 +163,3 @@\n         \"\"\"\n-        self.header = MachoHeaderStruct(self, 0)\n+        self._header = MachoHeaderStruct(self, 0)\n \n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\n        self.header = MachoHeaderStruct(self, 0)\n\n",
        "target_code_with_indent": "\n        self._header = MachoHeaderStruct(self, 0)\n\n"
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "                                      MachoLoadCommands.LC_ENCRYPTION_INFO_64]:\n                self.encryption_info = MachoEncryptionInfoStruct(self, offset)\n\n            elif load_command.cmd == MachoLoadCommands.LC_SYMTAB:\n                self.symtab = MachoSymtabCommandStruct(self, offset)\n\n            elif load_command.cmd == MachoLoadCommands.LC_DYSYMTAB:\n                self.dysymtab = MachoDysymtabCommandStruct(self, offset)\n\n            elif load_command.cmd in [MachoLoadCommands.LC_DYLD_INFO, MachoLoadCommands.LC_DYLD_INFO_ONLY]:\n                self.dyld_info = MachoDyldInfoCommandStruct(self, offset)\n\n",
        "source_code_len": 621,
        "target_code": "                                      MachoLoadCommands.LC_ENCRYPTION_INFO_64]:\n                self._encryption_info = MachoEncryptionInfoStruct(self, offset)\n\n            elif load_command.cmd == MachoLoadCommands.LC_SYMTAB:\n                self._symtab = MachoSymtabCommandStruct(self, offset)\n\n            elif load_command.cmd == MachoLoadCommands.LC_DYSYMTAB:\n                self._dysymtab = MachoDysymtabCommandStruct(self, offset)\n\n            elif load_command.cmd in [MachoLoadCommands.LC_DYLD_INFO, MachoLoadCommands.LC_DYLD_INFO_ONLY]:\n                self._dyld_info = MachoDyldInfoCommandStruct(self, offset)\n\n",
        "target_code_len": 625,
        "diff_format": "@@ -208,12 +220,12 @@\n                                       MachoLoadCommands.LC_ENCRYPTION_INFO_64]:\n-                self.encryption_info = MachoEncryptionInfoStruct(self, offset)\n+                self._encryption_info = MachoEncryptionInfoStruct(self, offset)\n \n             elif load_command.cmd == MachoLoadCommands.LC_SYMTAB:\n-                self.symtab = MachoSymtabCommandStruct(self, offset)\n+                self._symtab = MachoSymtabCommandStruct(self, offset)\n \n             elif load_command.cmd == MachoLoadCommands.LC_DYSYMTAB:\n-                self.dysymtab = MachoDysymtabCommandStruct(self, offset)\n+                self._dysymtab = MachoDysymtabCommandStruct(self, offset)\n \n             elif load_command.cmd in [MachoLoadCommands.LC_DYLD_INFO, MachoLoadCommands.LC_DYLD_INFO_ONLY]:\n-                self.dyld_info = MachoDyldInfoCommandStruct(self, offset)\n+                self._dyld_info = MachoDyldInfoCommandStruct(self, offset)\n \n",
        "source_code_with_indent": "                                      MachoLoadCommands.LC_ENCRYPTION_INFO_64]:\n                <IND>self.encryption_info = MachoEncryptionInfoStruct(self, offset)\n\n            <DED>elif load_command.cmd == MachoLoadCommands.LC_SYMTAB:\n                <IND>self.symtab = MachoSymtabCommandStruct(self, offset)\n\n            <DED>elif load_command.cmd == MachoLoadCommands.LC_DYSYMTAB:\n                <IND>self.dysymtab = MachoDysymtabCommandStruct(self, offset)\n\n            <DED>elif load_command.cmd in [MachoLoadCommands.LC_DYLD_INFO, MachoLoadCommands.LC_DYLD_INFO_ONLY]:\n                <IND>self.dyld_info = MachoDyldInfoCommandStruct(self, offset)\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "                                      MachoLoadCommands.LC_ENCRYPTION_INFO_64]:\n                <IND>self._encryption_info = MachoEncryptionInfoStruct(self, offset)\n\n            <DED>elif load_command.cmd == MachoLoadCommands.LC_SYMTAB:\n                <IND>self._symtab = MachoSymtabCommandStruct(self, offset)\n\n            <DED>elif load_command.cmd == MachoLoadCommands.LC_DYSYMTAB:\n                <IND>self._dysymtab = MachoDysymtabCommandStruct(self, offset)\n\n            <DED>elif load_command.cmd in [MachoLoadCommands.LC_DYLD_INFO, MachoLoadCommands.LC_DYLD_INFO_ONLY]:\n                <IND>self._dyld_info = MachoDyldInfoCommandStruct(self, offset)\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "            elif load_command.cmd == MachoLoadCommands.LC_CODE_SIGNATURE:\n                self.code_signature_cmd = MachoLinkeditDataCommandStruct(self, offset)\n\n",
        "source_code_len": 162,
        "target_code": "            elif load_command.cmd == MachoLoadCommands.LC_CODE_SIGNATURE:\n                self._code_signature_cmd = MachoLinkeditDataCommandStruct(self, offset)\n\n",
        "target_code_len": 163,
        "diff_format": "@@ -225,3 +236,3 @@\n             elif load_command.cmd == MachoLoadCommands.LC_CODE_SIGNATURE:\n-                self.code_signature_cmd = MachoLinkeditDataCommandStruct(self, offset)\n+                self._code_signature_cmd = MachoLinkeditDataCommandStruct(self, offset)\n \n",
        "source_code_with_indent": "            <DED>elif load_command.cmd == MachoLoadCommands.LC_CODE_SIGNATURE:\n                <IND>self.code_signature_cmd = MachoLinkeditDataCommandStruct(self, offset)\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "            <DED>elif load_command.cmd == MachoLoadCommands.LC_CODE_SIGNATURE:\n                <IND>self._code_signature_cmd = MachoLinkeditDataCommandStruct(self, offset)\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "            indirect_symtab_entry = self.read_word(indirect_symtab_off, virtual=False, word_type=c_uint32)\n            indirect_symtab.append(int(indirect_symtab_entry.value))\n            # traverse to next pointer\n",
        "source_code_len": 215,
        "target_code": "            indirect_symtab_entry = self.read_word(indirect_symtab_off, virtual=False, word_type=c_uint32)\n            if not indirect_symtab_entry:\n                continue\n            indirect_symtab.append(int(indirect_symtab_entry))\n            # traverse to next pointer\n",
        "target_code_len": 276,
        "diff_format": "@@ -398,3 +410,5 @@\n             indirect_symtab_entry = self.read_word(indirect_symtab_off, virtual=False, word_type=c_uint32)\n-            indirect_symtab.append(int(indirect_symtab_entry.value))\n+            if not indirect_symtab_entry:\n+                continue\n+            indirect_symtab.append(int(indirect_symtab_entry))\n             # traverse to next pointer\n",
        "source_code_with_indent": "            <IND>indirect_symtab_entry = self.read_word(indirect_symtab_off, virtual=False, word_type=c_uint32)\n            indirect_symtab.append(int(indirect_symtab_entry.value))\n            # traverse to next pointer\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "            <IND>indirect_symtab_entry = self.read_word(indirect_symtab_off, virtual=False, word_type=c_uint32)\n            if not indirect_symtab_entry:\n                <IND>continue\n            <DED>indirect_symtab.append(int(indirect_symtab_entry))\n            # traverse to next pointer\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "                  address: int,\n                  virtual=True,\n                  word_type=None) -> Optional[Union[c_uint32, c_uint64]]:\n        \"\"\"Attempt to read a word from the binary at a virtual address. Returns None if the address is invalid.\n",
        "source_code_len": 250,
        "target_code": "                  address: int,\n                  virtual: bool = True,\n                  word_type: Any = None) -> Optional[int]:\n        \"\"\"Attempt to read a word from the binary at a virtual address. Returns None if the address is invalid.\n",
        "target_code_len": 243,
        "diff_format": "@@ -568,4 +595,4 @@\n                   address: int,\n-                  virtual=True,\n-                  word_type=None) -> Optional[Union[c_uint32, c_uint64]]:\n+                  virtual: bool = True,\n+                  word_type: Any = None) -> Optional[int]:\n         \"\"\"Attempt to read a word from the binary at a virtual address. Returns None if the address is invalid.\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "                  address: int,\n                  virtual=True,\n                  word_type=None) -> Optional[Union[c_uint32, c_uint64]]:\n        <IND>",
        "target_code_with_indent": "                  address: int,\n                  virtual: bool = True,\n                  word_type: Any = None) -> Optional[int]:\n        <IND>"
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    @property\n    def _codesign_parser(self) -> 'CodesignParser':\n        from strongarm.macho.codesign import CodesignParser\n        if not self.__codesign_parser:\n",
        "source_code_len": 165,
        "target_code": "    @property\n    def header(self) -> MachoHeaderStruct:\n        if self._header:\n            return self._header\n        else:\n            raise RuntimeError('Failed to parse Mach-O')\n\n    @property\n    def dysymtab(self) -> MachoDysymtabCommandStruct:\n        if self._dysymtab:\n            return self._dysymtab\n        else:\n            raise RuntimeError('Failed to parse Mach-O')\n\n    @property\n    def symtab(self) -> MachoSymtabCommandStruct:\n        if self._symtab:\n            return self._symtab\n        else:\n            raise RuntimeError('Failed to parse Mach-O')\n\n    @property\n    def encryption_info(self) -> MachoEncryptionInfoStruct:\n        if self._encryption_info:\n            return self._encryption_info\n        else:\n            raise RuntimeError('Failed to parse Mach-O')\n\n    @property\n    def dyld_info(self) -> MachoDyldInfoCommandStruct:\n        if self._dyld_info:\n            return self._dyld_info\n        else:\n            raise RuntimeError('Failed to parse Mach-O')\n\n    @property\n    def code_signature_cmd(self) -> MachoLinkeditDataCommandStruct:\n        if self._code_signature_cmd:\n            return self._code_signature_cmd\n        else:\n            raise RuntimeError('Failed to parse Mach-O')\n\n    @property\n    def _codesign_parser(self) -> 'CodesignParser':\n        if not self.__codesign_parser:\n",
        "target_code_len": 1345,
        "diff_format": "@@ -583,4 +613,45 @@\n     @property\n+    def header(self) -> MachoHeaderStruct:\n+        if self._header:\n+            return self._header\n+        else:\n+            raise RuntimeError('Failed to parse Mach-O')\n+\n+    @property\n+    def dysymtab(self) -> MachoDysymtabCommandStruct:\n+        if self._dysymtab:\n+            return self._dysymtab\n+        else:\n+            raise RuntimeError('Failed to parse Mach-O')\n+\n+    @property\n+    def symtab(self) -> MachoSymtabCommandStruct:\n+        if self._symtab:\n+            return self._symtab\n+        else:\n+            raise RuntimeError('Failed to parse Mach-O')\n+\n+    @property\n+    def encryption_info(self) -> MachoEncryptionInfoStruct:\n+        if self._encryption_info:\n+            return self._encryption_info\n+        else:\n+            raise RuntimeError('Failed to parse Mach-O')\n+\n+    @property\n+    def dyld_info(self) -> MachoDyldInfoCommandStruct:\n+        if self._dyld_info:\n+            return self._dyld_info\n+        else:\n+            raise RuntimeError('Failed to parse Mach-O')\n+\n+    @property\n+    def code_signature_cmd(self) -> MachoLinkeditDataCommandStruct:\n+        if self._code_signature_cmd:\n+            return self._code_signature_cmd\n+        else:\n+            raise RuntimeError('Failed to parse Mach-O')\n+\n+    @property\n     def _codesign_parser(self) -> 'CodesignParser':\n-        from strongarm.macho.codesign import CodesignParser\n         if not self.__codesign_parser:\n",
        "source_code_with_indent": "    <DED>@property\n    def _codesign_parser(self) -> 'CodesignParser':\n        <IND>from strongarm.macho.codesign import CodesignParser\n        if not self.__codesign_parser:\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    <DED>@property\n    def header(self) -> MachoHeaderStruct:\n        <IND>if self._header:\n            <IND>return self._header\n        <DED>else:\n            <IND>raise RuntimeError('Failed to parse Mach-O')\n\n    <DED><DED>@property\n    def dysymtab(self) -> MachoDysymtabCommandStruct:\n        <IND>if self._dysymtab:\n            <IND>return self._dysymtab\n        <DED>else:\n            <IND>raise RuntimeError('Failed to parse Mach-O')\n\n    <DED><DED>@property\n    def symtab(self) -> MachoSymtabCommandStruct:\n        <IND>if self._symtab:\n            <IND>return self._symtab\n        <DED>else:\n            <IND>raise RuntimeError('Failed to parse Mach-O')\n\n    <DED><DED>@property\n    def encryption_info(self) -> MachoEncryptionInfoStruct:\n        <IND>if self._encryption_info:\n            <IND>return self._encryption_info\n        <DED>else:\n            <IND>raise RuntimeError('Failed to parse Mach-O')\n\n    <DED><DED>@property\n    def dyld_info(self) -> MachoDyldInfoCommandStruct:\n        <IND>if self._dyld_info:\n            <IND>return self._dyld_info\n        <DED>else:\n            <IND>raise RuntimeError('Failed to parse Mach-O')\n\n    <DED><DED>@property\n    def code_signature_cmd(self) -> MachoLinkeditDataCommandStruct:\n        <IND>if self._code_signature_cmd:\n            <IND>return self._code_signature_cmd\n        <DED>else:\n            <IND>raise RuntimeError('Failed to parse Mach-O')\n\n    <DED><DED>@property\n    def _codesign_parser(self) -> 'CodesignParser':\n        <IND>if not self.__codesign_parser:\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "datatheorem/strongarm",
    "commit": "ab620d78b4ce7f933cedc25960307f2c3b03c1a8",
    "filename": "strongarm/macho/macho_binary.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/datatheorem-strongarm/strongarm/macho/macho_binary.py",
    "file_hunks_size": 33,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "strongarm/macho/macho_binary.py:77:8 Incompatible attribute type [8]: Attribute `dysymtab` declared in class `MachoBinary` has type `MachoDysymtabCommandStruct` but is used as type `None`.",
    "message": " Attribute `dysymtab` declared in class `MachoBinary` has type `MachoDysymtabCommandStruct` but is used as type `None`.",
    "rule_id": "Incompatible attribute type [8]",
    "warning_line_no": 77,
    "warning_line": "        self.dysymtab: MachoDysymtabCommandStruct = None",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "# -*- coding: utf-8 -*-\nfrom typing import List, Tuple, Optional, Dict, Union\n\n",
        "source_code_len": 79,
        "target_code": "# -*- coding: utf-8 -*-\nfrom typing import List, Dict, Tuple, Any, Type, Optional\nfrom typing import TYPE_CHECKING\n\nfrom ctypes import c_uint64, c_uint32, sizeof\n\n",
        "target_code_len": 163,
        "diff_format": "@@ -1,3 +1,6 @@\n # -*- coding: utf-8 -*-\n-from typing import List, Tuple, Optional, Dict, Union\n+from typing import List, Dict, Tuple, Any, Type, Optional\n+from typing import TYPE_CHECKING\n+\n+from ctypes import c_uint64, c_uint32, sizeof\n \n",
        "source_code_with_indent": "# -*- coding: utf-8 -*-\nfrom typing import List, Tuple, Optional, Dict, Union\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "# -*- coding: utf-8 -*-\nfrom typing import List, Dict, Tuple, Any, Type, Optional\nfrom typing import TYPE_CHECKING\n\nfrom ctypes import c_uint64, c_uint32, sizeof\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "from strongarm.macho.macho_load_commands import MachoLoadCommands\nfrom strongarm.macho.arch_independent_structs import \\\n    MachoHeaderStruct, \\\n    MachoSegmentCommandStruct, \\\n    MachoSectionRawStruct, \\\n    MachoEncryptionInfoStruct, \\\n    MachoNlistStruct, \\\n    CFStringStruct, \\\n    DylibCommandStruct, \\\n    MachoLoadCommandStruct, \\\n    MachoSymtabCommandStruct, \\\n    MachoDysymtabCommandStruct, \\\n    MachoDyldInfoCommandStruct, \\\n    MachoLinkeditDataCommandStruct\n\nfrom ctypes import c_uint64, c_uint32, sizeof\n\n",
        "source_code_len": 526,
        "target_code": "from strongarm.macho.macho_load_commands import MachoLoadCommands\nfrom strongarm.macho.arch_independent_structs import (\n    ArchIndependentStructure,\n    MachoHeaderStruct,\n    MachoSegmentCommandStruct,\n    MachoSectionRawStruct,\n    MachoEncryptionInfoStruct,\n    MachoNlistStruct,\n    CFStringStruct,\n    DylibCommandStruct,\n    MachoLoadCommandStruct,\n    MachoSymtabCommandStruct,\n    MachoDysymtabCommandStruct,\n    MachoDyldInfoCommandStruct,\n    MachoLinkeditDataCommandStruct,\n)\n\nif TYPE_CHECKING:\n    from strongarm.macho.codesign import CodesignParser\n\n",
        "target_code_len": 565,
        "diff_format": "@@ -7,17 +10,20 @@\n from strongarm.macho.macho_load_commands import MachoLoadCommands\n-from strongarm.macho.arch_independent_structs import \\\n-    MachoHeaderStruct, \\\n-    MachoSegmentCommandStruct, \\\n-    MachoSectionRawStruct, \\\n-    MachoEncryptionInfoStruct, \\\n-    MachoNlistStruct, \\\n-    CFStringStruct, \\\n-    DylibCommandStruct, \\\n-    MachoLoadCommandStruct, \\\n-    MachoSymtabCommandStruct, \\\n-    MachoDysymtabCommandStruct, \\\n-    MachoDyldInfoCommandStruct, \\\n-    MachoLinkeditDataCommandStruct\n-\n-from ctypes import c_uint64, c_uint32, sizeof\n+from strongarm.macho.arch_independent_structs import (\n+    ArchIndependentStructure,\n+    MachoHeaderStruct,\n+    MachoSegmentCommandStruct,\n+    MachoSectionRawStruct,\n+    MachoEncryptionInfoStruct,\n+    MachoNlistStruct,\n+    CFStringStruct,\n+    DylibCommandStruct,\n+    MachoLoadCommandStruct,\n+    MachoSymtabCommandStruct,\n+    MachoDysymtabCommandStruct,\n+    MachoDyldInfoCommandStruct,\n+    MachoLinkeditDataCommandStruct,\n+)\n+\n+if TYPE_CHECKING:\n+    from strongarm.macho.codesign import CodesignParser\n \n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent": "from strongarm.macho.macho_load_commands import MachoLoadCommands\nfrom strongarm.macho.arch_independent_structs import (\n    ArchIndependentStructure,\n    MachoHeaderStruct,\n    MachoSegmentCommandStruct,\n    MachoSectionRawStruct,\n    MachoEncryptionInfoStruct,\n    MachoNlistStruct,\n    CFStringStruct,\n    DylibCommandStruct,\n    MachoLoadCommandStruct,\n    MachoSymtabCommandStruct,\n    MachoDysymtabCommandStruct,\n    MachoDyldInfoCommandStruct,\n    MachoLinkeditDataCommandStruct,\n)\n\nif TYPE_CHECKING:\n    <IND>from strongarm.macho.codesign import CodesignParser\n\n",
        "target_code_with_indent_exact_match": true,
        "source_code_with_indent": "from strongarm.macho.macho_load_commands import MachoLoadCommands\nfrom strongarm.macho.arch_independent_structs import    MachoHeaderStruct,    MachoSegmentCommandStruct,    MachoSectionRawStruct,    MachoEncryptionInfoStruct,    MachoNlistStruct,    CFStringStruct,    DylibCommandStruct,    MachoLoadCommandStruct,    MachoSymtabCommandStruct,    MachoDysymtabCommandStruct,    MachoDyldInfoCommandStruct,    MachoLinkeditDataCommandStruct\n\nfrom ctypes import c_uint64, c_uint32, sizeof\n\n"
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "        # generic Mach-O header info\n        self.is_64bit: bool = None\n        self.is_swap: bool = None\n        self.cpu_type: CPU_TYPE = None\n        self._load_commands_end_addr = None\n\n        # Mach-O header data\n        self.header: MachoHeaderStruct = None\n        self.header_flags: List[int] = None\n        self.file_type: MachoFileType = None\n\n        # segment and section commands from Mach-O header\n        self.segment_commands: Dict[str, MachoSegmentCommandStruct] = None\n        self.sections: Dict[str, MachoSection] = None\n        # also store specific interesting sections which are useful to us\n        self.dysymtab: MachoDysymtabCommandStruct = None\n        self.symtab: MachoSymtabCommandStruct = None\n        self.encryption_info: MachoEncryptionInfoStruct = None\n        self.dyld_info: MachoDyldInfoCommandStruct = None\n        self.load_dylib_commands: List[DylibCommandStruct] = None\n        self.code_signature_cmd: MachoLinkeditDataCommandStruct = None\n\n        self.__codesign_parser: CodesignParser = None\n\n",
        "source_code_len": 1040,
        "target_code": "        # generic Mach-O header info\n        self.is_64bit: bool = False\n        self.is_swap: bool = False\n        self.cpu_type: CPU_TYPE = CPU_TYPE.UNKNOWN\n        self._load_commands_end_addr = 0\n\n        # Mach-O header data\n        self._header: Optional[MachoHeaderStruct] = None\n        self.header_flags: List[int] = []\n        self.file_type: MachoFileType = MachoFileType.MH_EXECUTE\n\n        # segment and section commands from Mach-O header\n        self.segment_commands: Dict[str, MachoSegmentCommandStruct] = {}\n        self.sections: Dict[str, MachoSection] = {}\n        # also store specific interesting sections which are useful to us\n        self._dysymtab: Optional[MachoDysymtabCommandStruct] = None\n        self._symtab: Optional[MachoSymtabCommandStruct] = None\n        self._encryption_info: Optional[MachoEncryptionInfoStruct] = None\n        self._dyld_info: Optional[MachoDyldInfoCommandStruct] = None\n        self.load_dylib_commands: List[DylibCommandStruct] = []\n        self._code_signature_cmd: Optional[MachoLinkeditDataCommandStruct] = None\n\n        self.__codesign_parser: Optional[CodesignParser] = None\n\n",
        "target_code_len": 1139,
        "diff_format": "@@ -62,24 +68,24 @@\n         # generic Mach-O header info\n-        self.is_64bit: bool = None\n-        self.is_swap: bool = None\n-        self.cpu_type: CPU_TYPE = None\n-        self._load_commands_end_addr = None\n+        self.is_64bit: bool = False\n+        self.is_swap: bool = False\n+        self.cpu_type: CPU_TYPE = CPU_TYPE.UNKNOWN\n+        self._load_commands_end_addr = 0\n \n         # Mach-O header data\n-        self.header: MachoHeaderStruct = None\n-        self.header_flags: List[int] = None\n-        self.file_type: MachoFileType = None\n+        self._header: Optional[MachoHeaderStruct] = None\n+        self.header_flags: List[int] = []\n+        self.file_type: MachoFileType = MachoFileType.MH_EXECUTE\n \n         # segment and section commands from Mach-O header\n-        self.segment_commands: Dict[str, MachoSegmentCommandStruct] = None\n-        self.sections: Dict[str, MachoSection] = None\n+        self.segment_commands: Dict[str, MachoSegmentCommandStruct] = {}\n+        self.sections: Dict[str, MachoSection] = {}\n         # also store specific interesting sections which are useful to us\n-        self.dysymtab: MachoDysymtabCommandStruct = None\n-        self.symtab: MachoSymtabCommandStruct = None\n-        self.encryption_info: MachoEncryptionInfoStruct = None\n-        self.dyld_info: MachoDyldInfoCommandStruct = None\n-        self.load_dylib_commands: List[DylibCommandStruct] = None\n-        self.code_signature_cmd: MachoLinkeditDataCommandStruct = None\n-\n-        self.__codesign_parser: CodesignParser = None\n+        self._dysymtab: Optional[MachoDysymtabCommandStruct] = None\n+        self._symtab: Optional[MachoSymtabCommandStruct] = None\n+        self._encryption_info: Optional[MachoEncryptionInfoStruct] = None\n+        self._dyld_info: Optional[MachoDyldInfoCommandStruct] = None\n+        self.load_dylib_commands: List[DylibCommandStruct] = []\n+        self._code_signature_cmd: Optional[MachoLinkeditDataCommandStruct] = None\n+\n+        self.__codesign_parser: Optional[CodesignParser] = None\n \n",
        "source_code_with_indent": "        # generic Mach-O header info\n        self.is_64bit: bool = None\n        self.is_swap: bool = None\n        self.cpu_type: CPU_TYPE = None\n        self._load_commands_end_addr = None\n\n        # Mach-O header data\n        self.header: MachoHeaderStruct = None\n        self.header_flags: List[int] = None\n        self.file_type: MachoFileType = None\n\n        # segment and section commands from Mach-O header\n        self.segment_commands: Dict[str, MachoSegmentCommandStruct] = None\n        self.sections: Dict[str, MachoSection] = None\n        # also store specific interesting sections which are useful to us\n        self.dysymtab: MachoDysymtabCommandStruct = None\n        self.symtab: MachoSymtabCommandStruct = None\n        self.encryption_info: MachoEncryptionInfoStruct = None\n        self.dyld_info: MachoDyldInfoCommandStruct = None\n        self.load_dylib_commands: List[DylibCommandStruct] = None\n        self.code_signature_cmd: MachoLinkeditDataCommandStruct = None\n\n        self.__codesign_parser: CodesignParser = None\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "        # generic Mach-O header info\n        self.is_64bit: bool = False\n        self.is_swap: bool = False\n        self.cpu_type: CPU_TYPE = CPU_TYPE.UNKNOWN\n        self._load_commands_end_addr = 0\n\n        # Mach-O header data\n        self._header: Optional[MachoHeaderStruct] = None\n        self.header_flags: List[int] = []\n        self.file_type: MachoFileType = MachoFileType.MH_EXECUTE\n\n        # segment and section commands from Mach-O header\n        self.segment_commands: Dict[str, MachoSegmentCommandStruct] = {}\n        self.sections: Dict[str, MachoSection] = {}\n        # also store specific interesting sections which are useful to us\n        self._dysymtab: Optional[MachoDysymtabCommandStruct] = None\n        self._symtab: Optional[MachoSymtabCommandStruct] = None\n        self._encryption_info: Optional[MachoEncryptionInfoStruct] = None\n        self._dyld_info: Optional[MachoDyldInfoCommandStruct] = None\n        self.load_dylib_commands: List[DylibCommandStruct] = []\n        self._code_signature_cmd: Optional[MachoLinkeditDataCommandStruct] = None\n\n        self.__codesign_parser: Optional[CodesignParser] = None\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    @property\n    def slice_magic(self) -> c_uint32:\n        \"\"\"Read magic number identifier from this Mach-O slice\n        \"\"\"\n        return self.read_word(0, virtual=False, word_type=c_uint32)\n\n",
        "source_code_len": 197,
        "target_code": "    @property\n    def slice_magic(self) -> int:\n        \"\"\"Read magic number identifier from this Mach-O slice\n        \"\"\"\n        magic = self.read_word(0, virtual=False, word_type=c_uint32)\n        if magic:\n            return magic\n        else:\n            raise ValueError('Could not read magic value.')\n\n",
        "target_code_len": 310,
        "diff_format": "@@ -124,6 +131,10 @@\n     @property\n-    def slice_magic(self) -> c_uint32:\n+    def slice_magic(self) -> int:\n         \"\"\"Read magic number identifier from this Mach-O slice\n         \"\"\"\n-        return self.read_word(0, virtual=False, word_type=c_uint32)\n+        magic = self.read_word(0, virtual=False, word_type=c_uint32)\n+        if magic:\n+            return magic\n+        else:\n+            raise ValueError('Could not read magic value.')\n \n",
        "source_code_with_indent": "    <DED>@property\n    def slice_magic(self) -> c_uint32:\n        <IND>\"\"\"Read magic number identifier from this Mach-O slice\n        \"\"\"\n        return self.read_word(0, virtual=False, word_type=c_uint32)\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    <DED>@property\n    def slice_magic(self) -> int:\n        <IND>\"\"\"Read magic number identifier from this Mach-O slice\n        \"\"\"\n        magic = self.read_word(0, virtual=False, word_type=c_uint32)\n        if magic:\n            <IND>return magic\n        <DED>else:\n            <IND>raise ValueError('Could not read magic value.')\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "        \"\"\"\n        self.header = MachoHeaderStruct(self, 0)\n\n",
        "source_code_len": 62,
        "target_code": "        \"\"\"\n        self._header = MachoHeaderStruct(self, 0)\n\n",
        "target_code_len": 63,
        "diff_format": "@@ -152,3 +163,3 @@\n         \"\"\"\n-        self.header = MachoHeaderStruct(self, 0)\n+        self._header = MachoHeaderStruct(self, 0)\n \n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\n        self.header = MachoHeaderStruct(self, 0)\n\n",
        "target_code_with_indent": "\n        self._header = MachoHeaderStruct(self, 0)\n\n"
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "                                      MachoLoadCommands.LC_ENCRYPTION_INFO_64]:\n                self.encryption_info = MachoEncryptionInfoStruct(self, offset)\n\n            elif load_command.cmd == MachoLoadCommands.LC_SYMTAB:\n                self.symtab = MachoSymtabCommandStruct(self, offset)\n\n            elif load_command.cmd == MachoLoadCommands.LC_DYSYMTAB:\n                self.dysymtab = MachoDysymtabCommandStruct(self, offset)\n\n            elif load_command.cmd in [MachoLoadCommands.LC_DYLD_INFO, MachoLoadCommands.LC_DYLD_INFO_ONLY]:\n                self.dyld_info = MachoDyldInfoCommandStruct(self, offset)\n\n",
        "source_code_len": 621,
        "target_code": "                                      MachoLoadCommands.LC_ENCRYPTION_INFO_64]:\n                self._encryption_info = MachoEncryptionInfoStruct(self, offset)\n\n            elif load_command.cmd == MachoLoadCommands.LC_SYMTAB:\n                self._symtab = MachoSymtabCommandStruct(self, offset)\n\n            elif load_command.cmd == MachoLoadCommands.LC_DYSYMTAB:\n                self._dysymtab = MachoDysymtabCommandStruct(self, offset)\n\n            elif load_command.cmd in [MachoLoadCommands.LC_DYLD_INFO, MachoLoadCommands.LC_DYLD_INFO_ONLY]:\n                self._dyld_info = MachoDyldInfoCommandStruct(self, offset)\n\n",
        "target_code_len": 625,
        "diff_format": "@@ -208,12 +220,12 @@\n                                       MachoLoadCommands.LC_ENCRYPTION_INFO_64]:\n-                self.encryption_info = MachoEncryptionInfoStruct(self, offset)\n+                self._encryption_info = MachoEncryptionInfoStruct(self, offset)\n \n             elif load_command.cmd == MachoLoadCommands.LC_SYMTAB:\n-                self.symtab = MachoSymtabCommandStruct(self, offset)\n+                self._symtab = MachoSymtabCommandStruct(self, offset)\n \n             elif load_command.cmd == MachoLoadCommands.LC_DYSYMTAB:\n-                self.dysymtab = MachoDysymtabCommandStruct(self, offset)\n+                self._dysymtab = MachoDysymtabCommandStruct(self, offset)\n \n             elif load_command.cmd in [MachoLoadCommands.LC_DYLD_INFO, MachoLoadCommands.LC_DYLD_INFO_ONLY]:\n-                self.dyld_info = MachoDyldInfoCommandStruct(self, offset)\n+                self._dyld_info = MachoDyldInfoCommandStruct(self, offset)\n \n",
        "source_code_with_indent": "                                      MachoLoadCommands.LC_ENCRYPTION_INFO_64]:\n                <IND>self.encryption_info = MachoEncryptionInfoStruct(self, offset)\n\n            <DED>elif load_command.cmd == MachoLoadCommands.LC_SYMTAB:\n                <IND>self.symtab = MachoSymtabCommandStruct(self, offset)\n\n            <DED>elif load_command.cmd == MachoLoadCommands.LC_DYSYMTAB:\n                <IND>self.dysymtab = MachoDysymtabCommandStruct(self, offset)\n\n            <DED>elif load_command.cmd in [MachoLoadCommands.LC_DYLD_INFO, MachoLoadCommands.LC_DYLD_INFO_ONLY]:\n                <IND>self.dyld_info = MachoDyldInfoCommandStruct(self, offset)\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "                                      MachoLoadCommands.LC_ENCRYPTION_INFO_64]:\n                <IND>self._encryption_info = MachoEncryptionInfoStruct(self, offset)\n\n            <DED>elif load_command.cmd == MachoLoadCommands.LC_SYMTAB:\n                <IND>self._symtab = MachoSymtabCommandStruct(self, offset)\n\n            <DED>elif load_command.cmd == MachoLoadCommands.LC_DYSYMTAB:\n                <IND>self._dysymtab = MachoDysymtabCommandStruct(self, offset)\n\n            <DED>elif load_command.cmd in [MachoLoadCommands.LC_DYLD_INFO, MachoLoadCommands.LC_DYLD_INFO_ONLY]:\n                <IND>self._dyld_info = MachoDyldInfoCommandStruct(self, offset)\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "            elif load_command.cmd == MachoLoadCommands.LC_CODE_SIGNATURE:\n                self.code_signature_cmd = MachoLinkeditDataCommandStruct(self, offset)\n\n",
        "source_code_len": 162,
        "target_code": "            elif load_command.cmd == MachoLoadCommands.LC_CODE_SIGNATURE:\n                self._code_signature_cmd = MachoLinkeditDataCommandStruct(self, offset)\n\n",
        "target_code_len": 163,
        "diff_format": "@@ -225,3 +236,3 @@\n             elif load_command.cmd == MachoLoadCommands.LC_CODE_SIGNATURE:\n-                self.code_signature_cmd = MachoLinkeditDataCommandStruct(self, offset)\n+                self._code_signature_cmd = MachoLinkeditDataCommandStruct(self, offset)\n \n",
        "source_code_with_indent": "            <DED>elif load_command.cmd == MachoLoadCommands.LC_CODE_SIGNATURE:\n                <IND>self.code_signature_cmd = MachoLinkeditDataCommandStruct(self, offset)\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "            <DED>elif load_command.cmd == MachoLoadCommands.LC_CODE_SIGNATURE:\n                <IND>self._code_signature_cmd = MachoLinkeditDataCommandStruct(self, offset)\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "            indirect_symtab_entry = self.read_word(indirect_symtab_off, virtual=False, word_type=c_uint32)\n            indirect_symtab.append(int(indirect_symtab_entry.value))\n            # traverse to next pointer\n",
        "source_code_len": 215,
        "target_code": "            indirect_symtab_entry = self.read_word(indirect_symtab_off, virtual=False, word_type=c_uint32)\n            if not indirect_symtab_entry:\n                continue\n            indirect_symtab.append(int(indirect_symtab_entry))\n            # traverse to next pointer\n",
        "target_code_len": 276,
        "diff_format": "@@ -398,3 +410,5 @@\n             indirect_symtab_entry = self.read_word(indirect_symtab_off, virtual=False, word_type=c_uint32)\n-            indirect_symtab.append(int(indirect_symtab_entry.value))\n+            if not indirect_symtab_entry:\n+                continue\n+            indirect_symtab.append(int(indirect_symtab_entry))\n             # traverse to next pointer\n",
        "source_code_with_indent": "            <IND>indirect_symtab_entry = self.read_word(indirect_symtab_off, virtual=False, word_type=c_uint32)\n            indirect_symtab.append(int(indirect_symtab_entry.value))\n            # traverse to next pointer\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "            <IND>indirect_symtab_entry = self.read_word(indirect_symtab_off, virtual=False, word_type=c_uint32)\n            if not indirect_symtab_entry:\n                <IND>continue\n            <DED>indirect_symtab.append(int(indirect_symtab_entry))\n            # traverse to next pointer\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "                  address: int,\n                  virtual=True,\n                  word_type=None) -> Optional[Union[c_uint32, c_uint64]]:\n        \"\"\"Attempt to read a word from the binary at a virtual address. Returns None if the address is invalid.\n",
        "source_code_len": 250,
        "target_code": "                  address: int,\n                  virtual: bool = True,\n                  word_type: Any = None) -> Optional[int]:\n        \"\"\"Attempt to read a word from the binary at a virtual address. Returns None if the address is invalid.\n",
        "target_code_len": 243,
        "diff_format": "@@ -568,4 +595,4 @@\n                   address: int,\n-                  virtual=True,\n-                  word_type=None) -> Optional[Union[c_uint32, c_uint64]]:\n+                  virtual: bool = True,\n+                  word_type: Any = None) -> Optional[int]:\n         \"\"\"Attempt to read a word from the binary at a virtual address. Returns None if the address is invalid.\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "                  address: int,\n                  virtual=True,\n                  word_type=None) -> Optional[Union[c_uint32, c_uint64]]:\n        <IND>",
        "target_code_with_indent": "                  address: int,\n                  virtual: bool = True,\n                  word_type: Any = None) -> Optional[int]:\n        <IND>"
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    @property\n    def _codesign_parser(self) -> 'CodesignParser':\n        from strongarm.macho.codesign import CodesignParser\n        if not self.__codesign_parser:\n",
        "source_code_len": 165,
        "target_code": "    @property\n    def header(self) -> MachoHeaderStruct:\n        if self._header:\n            return self._header\n        else:\n            raise RuntimeError('Failed to parse Mach-O')\n\n    @property\n    def dysymtab(self) -> MachoDysymtabCommandStruct:\n        if self._dysymtab:\n            return self._dysymtab\n        else:\n            raise RuntimeError('Failed to parse Mach-O')\n\n    @property\n    def symtab(self) -> MachoSymtabCommandStruct:\n        if self._symtab:\n            return self._symtab\n        else:\n            raise RuntimeError('Failed to parse Mach-O')\n\n    @property\n    def encryption_info(self) -> MachoEncryptionInfoStruct:\n        if self._encryption_info:\n            return self._encryption_info\n        else:\n            raise RuntimeError('Failed to parse Mach-O')\n\n    @property\n    def dyld_info(self) -> MachoDyldInfoCommandStruct:\n        if self._dyld_info:\n            return self._dyld_info\n        else:\n            raise RuntimeError('Failed to parse Mach-O')\n\n    @property\n    def code_signature_cmd(self) -> MachoLinkeditDataCommandStruct:\n        if self._code_signature_cmd:\n            return self._code_signature_cmd\n        else:\n            raise RuntimeError('Failed to parse Mach-O')\n\n    @property\n    def _codesign_parser(self) -> 'CodesignParser':\n        if not self.__codesign_parser:\n",
        "target_code_len": 1345,
        "diff_format": "@@ -583,4 +613,45 @@\n     @property\n+    def header(self) -> MachoHeaderStruct:\n+        if self._header:\n+            return self._header\n+        else:\n+            raise RuntimeError('Failed to parse Mach-O')\n+\n+    @property\n+    def dysymtab(self) -> MachoDysymtabCommandStruct:\n+        if self._dysymtab:\n+            return self._dysymtab\n+        else:\n+            raise RuntimeError('Failed to parse Mach-O')\n+\n+    @property\n+    def symtab(self) -> MachoSymtabCommandStruct:\n+        if self._symtab:\n+            return self._symtab\n+        else:\n+            raise RuntimeError('Failed to parse Mach-O')\n+\n+    @property\n+    def encryption_info(self) -> MachoEncryptionInfoStruct:\n+        if self._encryption_info:\n+            return self._encryption_info\n+        else:\n+            raise RuntimeError('Failed to parse Mach-O')\n+\n+    @property\n+    def dyld_info(self) -> MachoDyldInfoCommandStruct:\n+        if self._dyld_info:\n+            return self._dyld_info\n+        else:\n+            raise RuntimeError('Failed to parse Mach-O')\n+\n+    @property\n+    def code_signature_cmd(self) -> MachoLinkeditDataCommandStruct:\n+        if self._code_signature_cmd:\n+            return self._code_signature_cmd\n+        else:\n+            raise RuntimeError('Failed to parse Mach-O')\n+\n+    @property\n     def _codesign_parser(self) -> 'CodesignParser':\n-        from strongarm.macho.codesign import CodesignParser\n         if not self.__codesign_parser:\n",
        "source_code_with_indent": "    <DED>@property\n    def _codesign_parser(self) -> 'CodesignParser':\n        <IND>from strongarm.macho.codesign import CodesignParser\n        if not self.__codesign_parser:\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    <DED>@property\n    def header(self) -> MachoHeaderStruct:\n        <IND>if self._header:\n            <IND>return self._header\n        <DED>else:\n            <IND>raise RuntimeError('Failed to parse Mach-O')\n\n    <DED><DED>@property\n    def dysymtab(self) -> MachoDysymtabCommandStruct:\n        <IND>if self._dysymtab:\n            <IND>return self._dysymtab\n        <DED>else:\n            <IND>raise RuntimeError('Failed to parse Mach-O')\n\n    <DED><DED>@property\n    def symtab(self) -> MachoSymtabCommandStruct:\n        <IND>if self._symtab:\n            <IND>return self._symtab\n        <DED>else:\n            <IND>raise RuntimeError('Failed to parse Mach-O')\n\n    <DED><DED>@property\n    def encryption_info(self) -> MachoEncryptionInfoStruct:\n        <IND>if self._encryption_info:\n            <IND>return self._encryption_info\n        <DED>else:\n            <IND>raise RuntimeError('Failed to parse Mach-O')\n\n    <DED><DED>@property\n    def dyld_info(self) -> MachoDyldInfoCommandStruct:\n        <IND>if self._dyld_info:\n            <IND>return self._dyld_info\n        <DED>else:\n            <IND>raise RuntimeError('Failed to parse Mach-O')\n\n    <DED><DED>@property\n    def code_signature_cmd(self) -> MachoLinkeditDataCommandStruct:\n        <IND>if self._code_signature_cmd:\n            <IND>return self._code_signature_cmd\n        <DED>else:\n            <IND>raise RuntimeError('Failed to parse Mach-O')\n\n    <DED><DED>@property\n    def _codesign_parser(self) -> 'CodesignParser':\n        <IND>if not self.__codesign_parser:\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "datatheorem/strongarm",
    "commit": "ab620d78b4ce7f933cedc25960307f2c3b03c1a8",
    "filename": "strongarm/macho/macho_binary.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/datatheorem-strongarm/strongarm/macho/macho_binary.py",
    "file_hunks_size": 33,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "strongarm/macho/macho_binary.py:78:8 Incompatible attribute type [8]: Attribute `symtab` declared in class `MachoBinary` has type `MachoSymtabCommandStruct` but is used as type `None`.",
    "message": " Attribute `symtab` declared in class `MachoBinary` has type `MachoSymtabCommandStruct` but is used as type `None`.",
    "rule_id": "Incompatible attribute type [8]",
    "warning_line_no": 78,
    "warning_line": "        self.symtab: MachoSymtabCommandStruct = None",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "# -*- coding: utf-8 -*-\nfrom typing import List, Tuple, Optional, Dict, Union\n\n",
        "source_code_len": 79,
        "target_code": "# -*- coding: utf-8 -*-\nfrom typing import List, Dict, Tuple, Any, Type, Optional\nfrom typing import TYPE_CHECKING\n\nfrom ctypes import c_uint64, c_uint32, sizeof\n\n",
        "target_code_len": 163,
        "diff_format": "@@ -1,3 +1,6 @@\n # -*- coding: utf-8 -*-\n-from typing import List, Tuple, Optional, Dict, Union\n+from typing import List, Dict, Tuple, Any, Type, Optional\n+from typing import TYPE_CHECKING\n+\n+from ctypes import c_uint64, c_uint32, sizeof\n \n",
        "source_code_with_indent": "# -*- coding: utf-8 -*-\nfrom typing import List, Tuple, Optional, Dict, Union\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "# -*- coding: utf-8 -*-\nfrom typing import List, Dict, Tuple, Any, Type, Optional\nfrom typing import TYPE_CHECKING\n\nfrom ctypes import c_uint64, c_uint32, sizeof\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "from strongarm.macho.macho_load_commands import MachoLoadCommands\nfrom strongarm.macho.arch_independent_structs import \\\n    MachoHeaderStruct, \\\n    MachoSegmentCommandStruct, \\\n    MachoSectionRawStruct, \\\n    MachoEncryptionInfoStruct, \\\n    MachoNlistStruct, \\\n    CFStringStruct, \\\n    DylibCommandStruct, \\\n    MachoLoadCommandStruct, \\\n    MachoSymtabCommandStruct, \\\n    MachoDysymtabCommandStruct, \\\n    MachoDyldInfoCommandStruct, \\\n    MachoLinkeditDataCommandStruct\n\nfrom ctypes import c_uint64, c_uint32, sizeof\n\n",
        "source_code_len": 526,
        "target_code": "from strongarm.macho.macho_load_commands import MachoLoadCommands\nfrom strongarm.macho.arch_independent_structs import (\n    ArchIndependentStructure,\n    MachoHeaderStruct,\n    MachoSegmentCommandStruct,\n    MachoSectionRawStruct,\n    MachoEncryptionInfoStruct,\n    MachoNlistStruct,\n    CFStringStruct,\n    DylibCommandStruct,\n    MachoLoadCommandStruct,\n    MachoSymtabCommandStruct,\n    MachoDysymtabCommandStruct,\n    MachoDyldInfoCommandStruct,\n    MachoLinkeditDataCommandStruct,\n)\n\nif TYPE_CHECKING:\n    from strongarm.macho.codesign import CodesignParser\n\n",
        "target_code_len": 565,
        "diff_format": "@@ -7,17 +10,20 @@\n from strongarm.macho.macho_load_commands import MachoLoadCommands\n-from strongarm.macho.arch_independent_structs import \\\n-    MachoHeaderStruct, \\\n-    MachoSegmentCommandStruct, \\\n-    MachoSectionRawStruct, \\\n-    MachoEncryptionInfoStruct, \\\n-    MachoNlistStruct, \\\n-    CFStringStruct, \\\n-    DylibCommandStruct, \\\n-    MachoLoadCommandStruct, \\\n-    MachoSymtabCommandStruct, \\\n-    MachoDysymtabCommandStruct, \\\n-    MachoDyldInfoCommandStruct, \\\n-    MachoLinkeditDataCommandStruct\n-\n-from ctypes import c_uint64, c_uint32, sizeof\n+from strongarm.macho.arch_independent_structs import (\n+    ArchIndependentStructure,\n+    MachoHeaderStruct,\n+    MachoSegmentCommandStruct,\n+    MachoSectionRawStruct,\n+    MachoEncryptionInfoStruct,\n+    MachoNlistStruct,\n+    CFStringStruct,\n+    DylibCommandStruct,\n+    MachoLoadCommandStruct,\n+    MachoSymtabCommandStruct,\n+    MachoDysymtabCommandStruct,\n+    MachoDyldInfoCommandStruct,\n+    MachoLinkeditDataCommandStruct,\n+)\n+\n+if TYPE_CHECKING:\n+    from strongarm.macho.codesign import CodesignParser\n \n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent": "from strongarm.macho.macho_load_commands import MachoLoadCommands\nfrom strongarm.macho.arch_independent_structs import (\n    ArchIndependentStructure,\n    MachoHeaderStruct,\n    MachoSegmentCommandStruct,\n    MachoSectionRawStruct,\n    MachoEncryptionInfoStruct,\n    MachoNlistStruct,\n    CFStringStruct,\n    DylibCommandStruct,\n    MachoLoadCommandStruct,\n    MachoSymtabCommandStruct,\n    MachoDysymtabCommandStruct,\n    MachoDyldInfoCommandStruct,\n    MachoLinkeditDataCommandStruct,\n)\n\nif TYPE_CHECKING:\n    <IND>from strongarm.macho.codesign import CodesignParser\n\n",
        "target_code_with_indent_exact_match": true,
        "source_code_with_indent": "from strongarm.macho.macho_load_commands import MachoLoadCommands\nfrom strongarm.macho.arch_independent_structs import    MachoHeaderStruct,    MachoSegmentCommandStruct,    MachoSectionRawStruct,    MachoEncryptionInfoStruct,    MachoNlistStruct,    CFStringStruct,    DylibCommandStruct,    MachoLoadCommandStruct,    MachoSymtabCommandStruct,    MachoDysymtabCommandStruct,    MachoDyldInfoCommandStruct,    MachoLinkeditDataCommandStruct\n\nfrom ctypes import c_uint64, c_uint32, sizeof\n\n"
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "        # generic Mach-O header info\n        self.is_64bit: bool = None\n        self.is_swap: bool = None\n        self.cpu_type: CPU_TYPE = None\n        self._load_commands_end_addr = None\n\n        # Mach-O header data\n        self.header: MachoHeaderStruct = None\n        self.header_flags: List[int] = None\n        self.file_type: MachoFileType = None\n\n        # segment and section commands from Mach-O header\n        self.segment_commands: Dict[str, MachoSegmentCommandStruct] = None\n        self.sections: Dict[str, MachoSection] = None\n        # also store specific interesting sections which are useful to us\n        self.dysymtab: MachoDysymtabCommandStruct = None\n        self.symtab: MachoSymtabCommandStruct = None\n        self.encryption_info: MachoEncryptionInfoStruct = None\n        self.dyld_info: MachoDyldInfoCommandStruct = None\n        self.load_dylib_commands: List[DylibCommandStruct] = None\n        self.code_signature_cmd: MachoLinkeditDataCommandStruct = None\n\n        self.__codesign_parser: CodesignParser = None\n\n",
        "source_code_len": 1040,
        "target_code": "        # generic Mach-O header info\n        self.is_64bit: bool = False\n        self.is_swap: bool = False\n        self.cpu_type: CPU_TYPE = CPU_TYPE.UNKNOWN\n        self._load_commands_end_addr = 0\n\n        # Mach-O header data\n        self._header: Optional[MachoHeaderStruct] = None\n        self.header_flags: List[int] = []\n        self.file_type: MachoFileType = MachoFileType.MH_EXECUTE\n\n        # segment and section commands from Mach-O header\n        self.segment_commands: Dict[str, MachoSegmentCommandStruct] = {}\n        self.sections: Dict[str, MachoSection] = {}\n        # also store specific interesting sections which are useful to us\n        self._dysymtab: Optional[MachoDysymtabCommandStruct] = None\n        self._symtab: Optional[MachoSymtabCommandStruct] = None\n        self._encryption_info: Optional[MachoEncryptionInfoStruct] = None\n        self._dyld_info: Optional[MachoDyldInfoCommandStruct] = None\n        self.load_dylib_commands: List[DylibCommandStruct] = []\n        self._code_signature_cmd: Optional[MachoLinkeditDataCommandStruct] = None\n\n        self.__codesign_parser: Optional[CodesignParser] = None\n\n",
        "target_code_len": 1139,
        "diff_format": "@@ -62,24 +68,24 @@\n         # generic Mach-O header info\n-        self.is_64bit: bool = None\n-        self.is_swap: bool = None\n-        self.cpu_type: CPU_TYPE = None\n-        self._load_commands_end_addr = None\n+        self.is_64bit: bool = False\n+        self.is_swap: bool = False\n+        self.cpu_type: CPU_TYPE = CPU_TYPE.UNKNOWN\n+        self._load_commands_end_addr = 0\n \n         # Mach-O header data\n-        self.header: MachoHeaderStruct = None\n-        self.header_flags: List[int] = None\n-        self.file_type: MachoFileType = None\n+        self._header: Optional[MachoHeaderStruct] = None\n+        self.header_flags: List[int] = []\n+        self.file_type: MachoFileType = MachoFileType.MH_EXECUTE\n \n         # segment and section commands from Mach-O header\n-        self.segment_commands: Dict[str, MachoSegmentCommandStruct] = None\n-        self.sections: Dict[str, MachoSection] = None\n+        self.segment_commands: Dict[str, MachoSegmentCommandStruct] = {}\n+        self.sections: Dict[str, MachoSection] = {}\n         # also store specific interesting sections which are useful to us\n-        self.dysymtab: MachoDysymtabCommandStruct = None\n-        self.symtab: MachoSymtabCommandStruct = None\n-        self.encryption_info: MachoEncryptionInfoStruct = None\n-        self.dyld_info: MachoDyldInfoCommandStruct = None\n-        self.load_dylib_commands: List[DylibCommandStruct] = None\n-        self.code_signature_cmd: MachoLinkeditDataCommandStruct = None\n-\n-        self.__codesign_parser: CodesignParser = None\n+        self._dysymtab: Optional[MachoDysymtabCommandStruct] = None\n+        self._symtab: Optional[MachoSymtabCommandStruct] = None\n+        self._encryption_info: Optional[MachoEncryptionInfoStruct] = None\n+        self._dyld_info: Optional[MachoDyldInfoCommandStruct] = None\n+        self.load_dylib_commands: List[DylibCommandStruct] = []\n+        self._code_signature_cmd: Optional[MachoLinkeditDataCommandStruct] = None\n+\n+        self.__codesign_parser: Optional[CodesignParser] = None\n \n",
        "source_code_with_indent": "        # generic Mach-O header info\n        self.is_64bit: bool = None\n        self.is_swap: bool = None\n        self.cpu_type: CPU_TYPE = None\n        self._load_commands_end_addr = None\n\n        # Mach-O header data\n        self.header: MachoHeaderStruct = None\n        self.header_flags: List[int] = None\n        self.file_type: MachoFileType = None\n\n        # segment and section commands from Mach-O header\n        self.segment_commands: Dict[str, MachoSegmentCommandStruct] = None\n        self.sections: Dict[str, MachoSection] = None\n        # also store specific interesting sections which are useful to us\n        self.dysymtab: MachoDysymtabCommandStruct = None\n        self.symtab: MachoSymtabCommandStruct = None\n        self.encryption_info: MachoEncryptionInfoStruct = None\n        self.dyld_info: MachoDyldInfoCommandStruct = None\n        self.load_dylib_commands: List[DylibCommandStruct] = None\n        self.code_signature_cmd: MachoLinkeditDataCommandStruct = None\n\n        self.__codesign_parser: CodesignParser = None\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "        # generic Mach-O header info\n        self.is_64bit: bool = False\n        self.is_swap: bool = False\n        self.cpu_type: CPU_TYPE = CPU_TYPE.UNKNOWN\n        self._load_commands_end_addr = 0\n\n        # Mach-O header data\n        self._header: Optional[MachoHeaderStruct] = None\n        self.header_flags: List[int] = []\n        self.file_type: MachoFileType = MachoFileType.MH_EXECUTE\n\n        # segment and section commands from Mach-O header\n        self.segment_commands: Dict[str, MachoSegmentCommandStruct] = {}\n        self.sections: Dict[str, MachoSection] = {}\n        # also store specific interesting sections which are useful to us\n        self._dysymtab: Optional[MachoDysymtabCommandStruct] = None\n        self._symtab: Optional[MachoSymtabCommandStruct] = None\n        self._encryption_info: Optional[MachoEncryptionInfoStruct] = None\n        self._dyld_info: Optional[MachoDyldInfoCommandStruct] = None\n        self.load_dylib_commands: List[DylibCommandStruct] = []\n        self._code_signature_cmd: Optional[MachoLinkeditDataCommandStruct] = None\n\n        self.__codesign_parser: Optional[CodesignParser] = None\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    @property\n    def slice_magic(self) -> c_uint32:\n        \"\"\"Read magic number identifier from this Mach-O slice\n        \"\"\"\n        return self.read_word(0, virtual=False, word_type=c_uint32)\n\n",
        "source_code_len": 197,
        "target_code": "    @property\n    def slice_magic(self) -> int:\n        \"\"\"Read magic number identifier from this Mach-O slice\n        \"\"\"\n        magic = self.read_word(0, virtual=False, word_type=c_uint32)\n        if magic:\n            return magic\n        else:\n            raise ValueError('Could not read magic value.')\n\n",
        "target_code_len": 310,
        "diff_format": "@@ -124,6 +131,10 @@\n     @property\n-    def slice_magic(self) -> c_uint32:\n+    def slice_magic(self) -> int:\n         \"\"\"Read magic number identifier from this Mach-O slice\n         \"\"\"\n-        return self.read_word(0, virtual=False, word_type=c_uint32)\n+        magic = self.read_word(0, virtual=False, word_type=c_uint32)\n+        if magic:\n+            return magic\n+        else:\n+            raise ValueError('Could not read magic value.')\n \n",
        "source_code_with_indent": "    <DED>@property\n    def slice_magic(self) -> c_uint32:\n        <IND>\"\"\"Read magic number identifier from this Mach-O slice\n        \"\"\"\n        return self.read_word(0, virtual=False, word_type=c_uint32)\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    <DED>@property\n    def slice_magic(self) -> int:\n        <IND>\"\"\"Read magic number identifier from this Mach-O slice\n        \"\"\"\n        magic = self.read_word(0, virtual=False, word_type=c_uint32)\n        if magic:\n            <IND>return magic\n        <DED>else:\n            <IND>raise ValueError('Could not read magic value.')\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "        \"\"\"\n        self.header = MachoHeaderStruct(self, 0)\n\n",
        "source_code_len": 62,
        "target_code": "        \"\"\"\n        self._header = MachoHeaderStruct(self, 0)\n\n",
        "target_code_len": 63,
        "diff_format": "@@ -152,3 +163,3 @@\n         \"\"\"\n-        self.header = MachoHeaderStruct(self, 0)\n+        self._header = MachoHeaderStruct(self, 0)\n \n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\n        self.header = MachoHeaderStruct(self, 0)\n\n",
        "target_code_with_indent": "\n        self._header = MachoHeaderStruct(self, 0)\n\n"
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "                                      MachoLoadCommands.LC_ENCRYPTION_INFO_64]:\n                self.encryption_info = MachoEncryptionInfoStruct(self, offset)\n\n            elif load_command.cmd == MachoLoadCommands.LC_SYMTAB:\n                self.symtab = MachoSymtabCommandStruct(self, offset)\n\n            elif load_command.cmd == MachoLoadCommands.LC_DYSYMTAB:\n                self.dysymtab = MachoDysymtabCommandStruct(self, offset)\n\n            elif load_command.cmd in [MachoLoadCommands.LC_DYLD_INFO, MachoLoadCommands.LC_DYLD_INFO_ONLY]:\n                self.dyld_info = MachoDyldInfoCommandStruct(self, offset)\n\n",
        "source_code_len": 621,
        "target_code": "                                      MachoLoadCommands.LC_ENCRYPTION_INFO_64]:\n                self._encryption_info = MachoEncryptionInfoStruct(self, offset)\n\n            elif load_command.cmd == MachoLoadCommands.LC_SYMTAB:\n                self._symtab = MachoSymtabCommandStruct(self, offset)\n\n            elif load_command.cmd == MachoLoadCommands.LC_DYSYMTAB:\n                self._dysymtab = MachoDysymtabCommandStruct(self, offset)\n\n            elif load_command.cmd in [MachoLoadCommands.LC_DYLD_INFO, MachoLoadCommands.LC_DYLD_INFO_ONLY]:\n                self._dyld_info = MachoDyldInfoCommandStruct(self, offset)\n\n",
        "target_code_len": 625,
        "diff_format": "@@ -208,12 +220,12 @@\n                                       MachoLoadCommands.LC_ENCRYPTION_INFO_64]:\n-                self.encryption_info = MachoEncryptionInfoStruct(self, offset)\n+                self._encryption_info = MachoEncryptionInfoStruct(self, offset)\n \n             elif load_command.cmd == MachoLoadCommands.LC_SYMTAB:\n-                self.symtab = MachoSymtabCommandStruct(self, offset)\n+                self._symtab = MachoSymtabCommandStruct(self, offset)\n \n             elif load_command.cmd == MachoLoadCommands.LC_DYSYMTAB:\n-                self.dysymtab = MachoDysymtabCommandStruct(self, offset)\n+                self._dysymtab = MachoDysymtabCommandStruct(self, offset)\n \n             elif load_command.cmd in [MachoLoadCommands.LC_DYLD_INFO, MachoLoadCommands.LC_DYLD_INFO_ONLY]:\n-                self.dyld_info = MachoDyldInfoCommandStruct(self, offset)\n+                self._dyld_info = MachoDyldInfoCommandStruct(self, offset)\n \n",
        "source_code_with_indent": "                                      MachoLoadCommands.LC_ENCRYPTION_INFO_64]:\n                <IND>self.encryption_info = MachoEncryptionInfoStruct(self, offset)\n\n            <DED>elif load_command.cmd == MachoLoadCommands.LC_SYMTAB:\n                <IND>self.symtab = MachoSymtabCommandStruct(self, offset)\n\n            <DED>elif load_command.cmd == MachoLoadCommands.LC_DYSYMTAB:\n                <IND>self.dysymtab = MachoDysymtabCommandStruct(self, offset)\n\n            <DED>elif load_command.cmd in [MachoLoadCommands.LC_DYLD_INFO, MachoLoadCommands.LC_DYLD_INFO_ONLY]:\n                <IND>self.dyld_info = MachoDyldInfoCommandStruct(self, offset)\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "                                      MachoLoadCommands.LC_ENCRYPTION_INFO_64]:\n                <IND>self._encryption_info = MachoEncryptionInfoStruct(self, offset)\n\n            <DED>elif load_command.cmd == MachoLoadCommands.LC_SYMTAB:\n                <IND>self._symtab = MachoSymtabCommandStruct(self, offset)\n\n            <DED>elif load_command.cmd == MachoLoadCommands.LC_DYSYMTAB:\n                <IND>self._dysymtab = MachoDysymtabCommandStruct(self, offset)\n\n            <DED>elif load_command.cmd in [MachoLoadCommands.LC_DYLD_INFO, MachoLoadCommands.LC_DYLD_INFO_ONLY]:\n                <IND>self._dyld_info = MachoDyldInfoCommandStruct(self, offset)\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "            elif load_command.cmd == MachoLoadCommands.LC_CODE_SIGNATURE:\n                self.code_signature_cmd = MachoLinkeditDataCommandStruct(self, offset)\n\n",
        "source_code_len": 162,
        "target_code": "            elif load_command.cmd == MachoLoadCommands.LC_CODE_SIGNATURE:\n                self._code_signature_cmd = MachoLinkeditDataCommandStruct(self, offset)\n\n",
        "target_code_len": 163,
        "diff_format": "@@ -225,3 +236,3 @@\n             elif load_command.cmd == MachoLoadCommands.LC_CODE_SIGNATURE:\n-                self.code_signature_cmd = MachoLinkeditDataCommandStruct(self, offset)\n+                self._code_signature_cmd = MachoLinkeditDataCommandStruct(self, offset)\n \n",
        "source_code_with_indent": "            <DED>elif load_command.cmd == MachoLoadCommands.LC_CODE_SIGNATURE:\n                <IND>self.code_signature_cmd = MachoLinkeditDataCommandStruct(self, offset)\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "            <DED>elif load_command.cmd == MachoLoadCommands.LC_CODE_SIGNATURE:\n                <IND>self._code_signature_cmd = MachoLinkeditDataCommandStruct(self, offset)\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "            indirect_symtab_entry = self.read_word(indirect_symtab_off, virtual=False, word_type=c_uint32)\n            indirect_symtab.append(int(indirect_symtab_entry.value))\n            # traverse to next pointer\n",
        "source_code_len": 215,
        "target_code": "            indirect_symtab_entry = self.read_word(indirect_symtab_off, virtual=False, word_type=c_uint32)\n            if not indirect_symtab_entry:\n                continue\n            indirect_symtab.append(int(indirect_symtab_entry))\n            # traverse to next pointer\n",
        "target_code_len": 276,
        "diff_format": "@@ -398,3 +410,5 @@\n             indirect_symtab_entry = self.read_word(indirect_symtab_off, virtual=False, word_type=c_uint32)\n-            indirect_symtab.append(int(indirect_symtab_entry.value))\n+            if not indirect_symtab_entry:\n+                continue\n+            indirect_symtab.append(int(indirect_symtab_entry))\n             # traverse to next pointer\n",
        "source_code_with_indent": "            <IND>indirect_symtab_entry = self.read_word(indirect_symtab_off, virtual=False, word_type=c_uint32)\n            indirect_symtab.append(int(indirect_symtab_entry.value))\n            # traverse to next pointer\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "            <IND>indirect_symtab_entry = self.read_word(indirect_symtab_off, virtual=False, word_type=c_uint32)\n            if not indirect_symtab_entry:\n                <IND>continue\n            <DED>indirect_symtab.append(int(indirect_symtab_entry))\n            # traverse to next pointer\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "                  address: int,\n                  virtual=True,\n                  word_type=None) -> Optional[Union[c_uint32, c_uint64]]:\n        \"\"\"Attempt to read a word from the binary at a virtual address. Returns None if the address is invalid.\n",
        "source_code_len": 250,
        "target_code": "                  address: int,\n                  virtual: bool = True,\n                  word_type: Any = None) -> Optional[int]:\n        \"\"\"Attempt to read a word from the binary at a virtual address. Returns None if the address is invalid.\n",
        "target_code_len": 243,
        "diff_format": "@@ -568,4 +595,4 @@\n                   address: int,\n-                  virtual=True,\n-                  word_type=None) -> Optional[Union[c_uint32, c_uint64]]:\n+                  virtual: bool = True,\n+                  word_type: Any = None) -> Optional[int]:\n         \"\"\"Attempt to read a word from the binary at a virtual address. Returns None if the address is invalid.\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "                  address: int,\n                  virtual=True,\n                  word_type=None) -> Optional[Union[c_uint32, c_uint64]]:\n        <IND>",
        "target_code_with_indent": "                  address: int,\n                  virtual: bool = True,\n                  word_type: Any = None) -> Optional[int]:\n        <IND>"
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    @property\n    def _codesign_parser(self) -> 'CodesignParser':\n        from strongarm.macho.codesign import CodesignParser\n        if not self.__codesign_parser:\n",
        "source_code_len": 165,
        "target_code": "    @property\n    def header(self) -> MachoHeaderStruct:\n        if self._header:\n            return self._header\n        else:\n            raise RuntimeError('Failed to parse Mach-O')\n\n    @property\n    def dysymtab(self) -> MachoDysymtabCommandStruct:\n        if self._dysymtab:\n            return self._dysymtab\n        else:\n            raise RuntimeError('Failed to parse Mach-O')\n\n    @property\n    def symtab(self) -> MachoSymtabCommandStruct:\n        if self._symtab:\n            return self._symtab\n        else:\n            raise RuntimeError('Failed to parse Mach-O')\n\n    @property\n    def encryption_info(self) -> MachoEncryptionInfoStruct:\n        if self._encryption_info:\n            return self._encryption_info\n        else:\n            raise RuntimeError('Failed to parse Mach-O')\n\n    @property\n    def dyld_info(self) -> MachoDyldInfoCommandStruct:\n        if self._dyld_info:\n            return self._dyld_info\n        else:\n            raise RuntimeError('Failed to parse Mach-O')\n\n    @property\n    def code_signature_cmd(self) -> MachoLinkeditDataCommandStruct:\n        if self._code_signature_cmd:\n            return self._code_signature_cmd\n        else:\n            raise RuntimeError('Failed to parse Mach-O')\n\n    @property\n    def _codesign_parser(self) -> 'CodesignParser':\n        if not self.__codesign_parser:\n",
        "target_code_len": 1345,
        "diff_format": "@@ -583,4 +613,45 @@\n     @property\n+    def header(self) -> MachoHeaderStruct:\n+        if self._header:\n+            return self._header\n+        else:\n+            raise RuntimeError('Failed to parse Mach-O')\n+\n+    @property\n+    def dysymtab(self) -> MachoDysymtabCommandStruct:\n+        if self._dysymtab:\n+            return self._dysymtab\n+        else:\n+            raise RuntimeError('Failed to parse Mach-O')\n+\n+    @property\n+    def symtab(self) -> MachoSymtabCommandStruct:\n+        if self._symtab:\n+            return self._symtab\n+        else:\n+            raise RuntimeError('Failed to parse Mach-O')\n+\n+    @property\n+    def encryption_info(self) -> MachoEncryptionInfoStruct:\n+        if self._encryption_info:\n+            return self._encryption_info\n+        else:\n+            raise RuntimeError('Failed to parse Mach-O')\n+\n+    @property\n+    def dyld_info(self) -> MachoDyldInfoCommandStruct:\n+        if self._dyld_info:\n+            return self._dyld_info\n+        else:\n+            raise RuntimeError('Failed to parse Mach-O')\n+\n+    @property\n+    def code_signature_cmd(self) -> MachoLinkeditDataCommandStruct:\n+        if self._code_signature_cmd:\n+            return self._code_signature_cmd\n+        else:\n+            raise RuntimeError('Failed to parse Mach-O')\n+\n+    @property\n     def _codesign_parser(self) -> 'CodesignParser':\n-        from strongarm.macho.codesign import CodesignParser\n         if not self.__codesign_parser:\n",
        "source_code_with_indent": "    <DED>@property\n    def _codesign_parser(self) -> 'CodesignParser':\n        <IND>from strongarm.macho.codesign import CodesignParser\n        if not self.__codesign_parser:\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    <DED>@property\n    def header(self) -> MachoHeaderStruct:\n        <IND>if self._header:\n            <IND>return self._header\n        <DED>else:\n            <IND>raise RuntimeError('Failed to parse Mach-O')\n\n    <DED><DED>@property\n    def dysymtab(self) -> MachoDysymtabCommandStruct:\n        <IND>if self._dysymtab:\n            <IND>return self._dysymtab\n        <DED>else:\n            <IND>raise RuntimeError('Failed to parse Mach-O')\n\n    <DED><DED>@property\n    def symtab(self) -> MachoSymtabCommandStruct:\n        <IND>if self._symtab:\n            <IND>return self._symtab\n        <DED>else:\n            <IND>raise RuntimeError('Failed to parse Mach-O')\n\n    <DED><DED>@property\n    def encryption_info(self) -> MachoEncryptionInfoStruct:\n        <IND>if self._encryption_info:\n            <IND>return self._encryption_info\n        <DED>else:\n            <IND>raise RuntimeError('Failed to parse Mach-O')\n\n    <DED><DED>@property\n    def dyld_info(self) -> MachoDyldInfoCommandStruct:\n        <IND>if self._dyld_info:\n            <IND>return self._dyld_info\n        <DED>else:\n            <IND>raise RuntimeError('Failed to parse Mach-O')\n\n    <DED><DED>@property\n    def code_signature_cmd(self) -> MachoLinkeditDataCommandStruct:\n        <IND>if self._code_signature_cmd:\n            <IND>return self._code_signature_cmd\n        <DED>else:\n            <IND>raise RuntimeError('Failed to parse Mach-O')\n\n    <DED><DED>@property\n    def _codesign_parser(self) -> 'CodesignParser':\n        <IND>if not self.__codesign_parser:\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "datatheorem/strongarm",
    "commit": "ab620d78b4ce7f933cedc25960307f2c3b03c1a8",
    "filename": "strongarm/macho/macho_binary.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/datatheorem-strongarm/strongarm/macho/macho_binary.py",
    "file_hunks_size": 33,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "strongarm/macho/macho_binary.py:79:8 Incompatible attribute type [8]: Attribute `encryption_info` declared in class `MachoBinary` has type `MachoEncryptionInfoStruct` but is used as type `None`.",
    "message": " Attribute `encryption_info` declared in class `MachoBinary` has type `MachoEncryptionInfoStruct` but is used as type `None`.",
    "rule_id": "Incompatible attribute type [8]",
    "warning_line_no": 79,
    "warning_line": "        self.encryption_info: MachoEncryptionInfoStruct = None",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "# -*- coding: utf-8 -*-\nfrom typing import List, Tuple, Optional, Dict, Union\n\n",
        "source_code_len": 79,
        "target_code": "# -*- coding: utf-8 -*-\nfrom typing import List, Dict, Tuple, Any, Type, Optional\nfrom typing import TYPE_CHECKING\n\nfrom ctypes import c_uint64, c_uint32, sizeof\n\n",
        "target_code_len": 163,
        "diff_format": "@@ -1,3 +1,6 @@\n # -*- coding: utf-8 -*-\n-from typing import List, Tuple, Optional, Dict, Union\n+from typing import List, Dict, Tuple, Any, Type, Optional\n+from typing import TYPE_CHECKING\n+\n+from ctypes import c_uint64, c_uint32, sizeof\n \n",
        "source_code_with_indent": "# -*- coding: utf-8 -*-\nfrom typing import List, Tuple, Optional, Dict, Union\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "# -*- coding: utf-8 -*-\nfrom typing import List, Dict, Tuple, Any, Type, Optional\nfrom typing import TYPE_CHECKING\n\nfrom ctypes import c_uint64, c_uint32, sizeof\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "from strongarm.macho.macho_load_commands import MachoLoadCommands\nfrom strongarm.macho.arch_independent_structs import \\\n    MachoHeaderStruct, \\\n    MachoSegmentCommandStruct, \\\n    MachoSectionRawStruct, \\\n    MachoEncryptionInfoStruct, \\\n    MachoNlistStruct, \\\n    CFStringStruct, \\\n    DylibCommandStruct, \\\n    MachoLoadCommandStruct, \\\n    MachoSymtabCommandStruct, \\\n    MachoDysymtabCommandStruct, \\\n    MachoDyldInfoCommandStruct, \\\n    MachoLinkeditDataCommandStruct\n\nfrom ctypes import c_uint64, c_uint32, sizeof\n\n",
        "source_code_len": 526,
        "target_code": "from strongarm.macho.macho_load_commands import MachoLoadCommands\nfrom strongarm.macho.arch_independent_structs import (\n    ArchIndependentStructure,\n    MachoHeaderStruct,\n    MachoSegmentCommandStruct,\n    MachoSectionRawStruct,\n    MachoEncryptionInfoStruct,\n    MachoNlistStruct,\n    CFStringStruct,\n    DylibCommandStruct,\n    MachoLoadCommandStruct,\n    MachoSymtabCommandStruct,\n    MachoDysymtabCommandStruct,\n    MachoDyldInfoCommandStruct,\n    MachoLinkeditDataCommandStruct,\n)\n\nif TYPE_CHECKING:\n    from strongarm.macho.codesign import CodesignParser\n\n",
        "target_code_len": 565,
        "diff_format": "@@ -7,17 +10,20 @@\n from strongarm.macho.macho_load_commands import MachoLoadCommands\n-from strongarm.macho.arch_independent_structs import \\\n-    MachoHeaderStruct, \\\n-    MachoSegmentCommandStruct, \\\n-    MachoSectionRawStruct, \\\n-    MachoEncryptionInfoStruct, \\\n-    MachoNlistStruct, \\\n-    CFStringStruct, \\\n-    DylibCommandStruct, \\\n-    MachoLoadCommandStruct, \\\n-    MachoSymtabCommandStruct, \\\n-    MachoDysymtabCommandStruct, \\\n-    MachoDyldInfoCommandStruct, \\\n-    MachoLinkeditDataCommandStruct\n-\n-from ctypes import c_uint64, c_uint32, sizeof\n+from strongarm.macho.arch_independent_structs import (\n+    ArchIndependentStructure,\n+    MachoHeaderStruct,\n+    MachoSegmentCommandStruct,\n+    MachoSectionRawStruct,\n+    MachoEncryptionInfoStruct,\n+    MachoNlistStruct,\n+    CFStringStruct,\n+    DylibCommandStruct,\n+    MachoLoadCommandStruct,\n+    MachoSymtabCommandStruct,\n+    MachoDysymtabCommandStruct,\n+    MachoDyldInfoCommandStruct,\n+    MachoLinkeditDataCommandStruct,\n+)\n+\n+if TYPE_CHECKING:\n+    from strongarm.macho.codesign import CodesignParser\n \n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent": "from strongarm.macho.macho_load_commands import MachoLoadCommands\nfrom strongarm.macho.arch_independent_structs import (\n    ArchIndependentStructure,\n    MachoHeaderStruct,\n    MachoSegmentCommandStruct,\n    MachoSectionRawStruct,\n    MachoEncryptionInfoStruct,\n    MachoNlistStruct,\n    CFStringStruct,\n    DylibCommandStruct,\n    MachoLoadCommandStruct,\n    MachoSymtabCommandStruct,\n    MachoDysymtabCommandStruct,\n    MachoDyldInfoCommandStruct,\n    MachoLinkeditDataCommandStruct,\n)\n\nif TYPE_CHECKING:\n    <IND>from strongarm.macho.codesign import CodesignParser\n\n",
        "target_code_with_indent_exact_match": true,
        "source_code_with_indent": "from strongarm.macho.macho_load_commands import MachoLoadCommands\nfrom strongarm.macho.arch_independent_structs import    MachoHeaderStruct,    MachoSegmentCommandStruct,    MachoSectionRawStruct,    MachoEncryptionInfoStruct,    MachoNlistStruct,    CFStringStruct,    DylibCommandStruct,    MachoLoadCommandStruct,    MachoSymtabCommandStruct,    MachoDysymtabCommandStruct,    MachoDyldInfoCommandStruct,    MachoLinkeditDataCommandStruct\n\nfrom ctypes import c_uint64, c_uint32, sizeof\n\n"
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "        # generic Mach-O header info\n        self.is_64bit: bool = None\n        self.is_swap: bool = None\n        self.cpu_type: CPU_TYPE = None\n        self._load_commands_end_addr = None\n\n        # Mach-O header data\n        self.header: MachoHeaderStruct = None\n        self.header_flags: List[int] = None\n        self.file_type: MachoFileType = None\n\n        # segment and section commands from Mach-O header\n        self.segment_commands: Dict[str, MachoSegmentCommandStruct] = None\n        self.sections: Dict[str, MachoSection] = None\n        # also store specific interesting sections which are useful to us\n        self.dysymtab: MachoDysymtabCommandStruct = None\n        self.symtab: MachoSymtabCommandStruct = None\n        self.encryption_info: MachoEncryptionInfoStruct = None\n        self.dyld_info: MachoDyldInfoCommandStruct = None\n        self.load_dylib_commands: List[DylibCommandStruct] = None\n        self.code_signature_cmd: MachoLinkeditDataCommandStruct = None\n\n        self.__codesign_parser: CodesignParser = None\n\n",
        "source_code_len": 1040,
        "target_code": "        # generic Mach-O header info\n        self.is_64bit: bool = False\n        self.is_swap: bool = False\n        self.cpu_type: CPU_TYPE = CPU_TYPE.UNKNOWN\n        self._load_commands_end_addr = 0\n\n        # Mach-O header data\n        self._header: Optional[MachoHeaderStruct] = None\n        self.header_flags: List[int] = []\n        self.file_type: MachoFileType = MachoFileType.MH_EXECUTE\n\n        # segment and section commands from Mach-O header\n        self.segment_commands: Dict[str, MachoSegmentCommandStruct] = {}\n        self.sections: Dict[str, MachoSection] = {}\n        # also store specific interesting sections which are useful to us\n        self._dysymtab: Optional[MachoDysymtabCommandStruct] = None\n        self._symtab: Optional[MachoSymtabCommandStruct] = None\n        self._encryption_info: Optional[MachoEncryptionInfoStruct] = None\n        self._dyld_info: Optional[MachoDyldInfoCommandStruct] = None\n        self.load_dylib_commands: List[DylibCommandStruct] = []\n        self._code_signature_cmd: Optional[MachoLinkeditDataCommandStruct] = None\n\n        self.__codesign_parser: Optional[CodesignParser] = None\n\n",
        "target_code_len": 1139,
        "diff_format": "@@ -62,24 +68,24 @@\n         # generic Mach-O header info\n-        self.is_64bit: bool = None\n-        self.is_swap: bool = None\n-        self.cpu_type: CPU_TYPE = None\n-        self._load_commands_end_addr = None\n+        self.is_64bit: bool = False\n+        self.is_swap: bool = False\n+        self.cpu_type: CPU_TYPE = CPU_TYPE.UNKNOWN\n+        self._load_commands_end_addr = 0\n \n         # Mach-O header data\n-        self.header: MachoHeaderStruct = None\n-        self.header_flags: List[int] = None\n-        self.file_type: MachoFileType = None\n+        self._header: Optional[MachoHeaderStruct] = None\n+        self.header_flags: List[int] = []\n+        self.file_type: MachoFileType = MachoFileType.MH_EXECUTE\n \n         # segment and section commands from Mach-O header\n-        self.segment_commands: Dict[str, MachoSegmentCommandStruct] = None\n-        self.sections: Dict[str, MachoSection] = None\n+        self.segment_commands: Dict[str, MachoSegmentCommandStruct] = {}\n+        self.sections: Dict[str, MachoSection] = {}\n         # also store specific interesting sections which are useful to us\n-        self.dysymtab: MachoDysymtabCommandStruct = None\n-        self.symtab: MachoSymtabCommandStruct = None\n-        self.encryption_info: MachoEncryptionInfoStruct = None\n-        self.dyld_info: MachoDyldInfoCommandStruct = None\n-        self.load_dylib_commands: List[DylibCommandStruct] = None\n-        self.code_signature_cmd: MachoLinkeditDataCommandStruct = None\n-\n-        self.__codesign_parser: CodesignParser = None\n+        self._dysymtab: Optional[MachoDysymtabCommandStruct] = None\n+        self._symtab: Optional[MachoSymtabCommandStruct] = None\n+        self._encryption_info: Optional[MachoEncryptionInfoStruct] = None\n+        self._dyld_info: Optional[MachoDyldInfoCommandStruct] = None\n+        self.load_dylib_commands: List[DylibCommandStruct] = []\n+        self._code_signature_cmd: Optional[MachoLinkeditDataCommandStruct] = None\n+\n+        self.__codesign_parser: Optional[CodesignParser] = None\n \n",
        "source_code_with_indent": "        # generic Mach-O header info\n        self.is_64bit: bool = None\n        self.is_swap: bool = None\n        self.cpu_type: CPU_TYPE = None\n        self._load_commands_end_addr = None\n\n        # Mach-O header data\n        self.header: MachoHeaderStruct = None\n        self.header_flags: List[int] = None\n        self.file_type: MachoFileType = None\n\n        # segment and section commands from Mach-O header\n        self.segment_commands: Dict[str, MachoSegmentCommandStruct] = None\n        self.sections: Dict[str, MachoSection] = None\n        # also store specific interesting sections which are useful to us\n        self.dysymtab: MachoDysymtabCommandStruct = None\n        self.symtab: MachoSymtabCommandStruct = None\n        self.encryption_info: MachoEncryptionInfoStruct = None\n        self.dyld_info: MachoDyldInfoCommandStruct = None\n        self.load_dylib_commands: List[DylibCommandStruct] = None\n        self.code_signature_cmd: MachoLinkeditDataCommandStruct = None\n\n        self.__codesign_parser: CodesignParser = None\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "        # generic Mach-O header info\n        self.is_64bit: bool = False\n        self.is_swap: bool = False\n        self.cpu_type: CPU_TYPE = CPU_TYPE.UNKNOWN\n        self._load_commands_end_addr = 0\n\n        # Mach-O header data\n        self._header: Optional[MachoHeaderStruct] = None\n        self.header_flags: List[int] = []\n        self.file_type: MachoFileType = MachoFileType.MH_EXECUTE\n\n        # segment and section commands from Mach-O header\n        self.segment_commands: Dict[str, MachoSegmentCommandStruct] = {}\n        self.sections: Dict[str, MachoSection] = {}\n        # also store specific interesting sections which are useful to us\n        self._dysymtab: Optional[MachoDysymtabCommandStruct] = None\n        self._symtab: Optional[MachoSymtabCommandStruct] = None\n        self._encryption_info: Optional[MachoEncryptionInfoStruct] = None\n        self._dyld_info: Optional[MachoDyldInfoCommandStruct] = None\n        self.load_dylib_commands: List[DylibCommandStruct] = []\n        self._code_signature_cmd: Optional[MachoLinkeditDataCommandStruct] = None\n\n        self.__codesign_parser: Optional[CodesignParser] = None\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    @property\n    def slice_magic(self) -> c_uint32:\n        \"\"\"Read magic number identifier from this Mach-O slice\n        \"\"\"\n        return self.read_word(0, virtual=False, word_type=c_uint32)\n\n",
        "source_code_len": 197,
        "target_code": "    @property\n    def slice_magic(self) -> int:\n        \"\"\"Read magic number identifier from this Mach-O slice\n        \"\"\"\n        magic = self.read_word(0, virtual=False, word_type=c_uint32)\n        if magic:\n            return magic\n        else:\n            raise ValueError('Could not read magic value.')\n\n",
        "target_code_len": 310,
        "diff_format": "@@ -124,6 +131,10 @@\n     @property\n-    def slice_magic(self) -> c_uint32:\n+    def slice_magic(self) -> int:\n         \"\"\"Read magic number identifier from this Mach-O slice\n         \"\"\"\n-        return self.read_word(0, virtual=False, word_type=c_uint32)\n+        magic = self.read_word(0, virtual=False, word_type=c_uint32)\n+        if magic:\n+            return magic\n+        else:\n+            raise ValueError('Could not read magic value.')\n \n",
        "source_code_with_indent": "    <DED>@property\n    def slice_magic(self) -> c_uint32:\n        <IND>\"\"\"Read magic number identifier from this Mach-O slice\n        \"\"\"\n        return self.read_word(0, virtual=False, word_type=c_uint32)\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    <DED>@property\n    def slice_magic(self) -> int:\n        <IND>\"\"\"Read magic number identifier from this Mach-O slice\n        \"\"\"\n        magic = self.read_word(0, virtual=False, word_type=c_uint32)\n        if magic:\n            <IND>return magic\n        <DED>else:\n            <IND>raise ValueError('Could not read magic value.')\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "        \"\"\"\n        self.header = MachoHeaderStruct(self, 0)\n\n",
        "source_code_len": 62,
        "target_code": "        \"\"\"\n        self._header = MachoHeaderStruct(self, 0)\n\n",
        "target_code_len": 63,
        "diff_format": "@@ -152,3 +163,3 @@\n         \"\"\"\n-        self.header = MachoHeaderStruct(self, 0)\n+        self._header = MachoHeaderStruct(self, 0)\n \n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\n        self.header = MachoHeaderStruct(self, 0)\n\n",
        "target_code_with_indent": "\n        self._header = MachoHeaderStruct(self, 0)\n\n"
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "                                      MachoLoadCommands.LC_ENCRYPTION_INFO_64]:\n                self.encryption_info = MachoEncryptionInfoStruct(self, offset)\n\n            elif load_command.cmd == MachoLoadCommands.LC_SYMTAB:\n                self.symtab = MachoSymtabCommandStruct(self, offset)\n\n            elif load_command.cmd == MachoLoadCommands.LC_DYSYMTAB:\n                self.dysymtab = MachoDysymtabCommandStruct(self, offset)\n\n            elif load_command.cmd in [MachoLoadCommands.LC_DYLD_INFO, MachoLoadCommands.LC_DYLD_INFO_ONLY]:\n                self.dyld_info = MachoDyldInfoCommandStruct(self, offset)\n\n",
        "source_code_len": 621,
        "target_code": "                                      MachoLoadCommands.LC_ENCRYPTION_INFO_64]:\n                self._encryption_info = MachoEncryptionInfoStruct(self, offset)\n\n            elif load_command.cmd == MachoLoadCommands.LC_SYMTAB:\n                self._symtab = MachoSymtabCommandStruct(self, offset)\n\n            elif load_command.cmd == MachoLoadCommands.LC_DYSYMTAB:\n                self._dysymtab = MachoDysymtabCommandStruct(self, offset)\n\n            elif load_command.cmd in [MachoLoadCommands.LC_DYLD_INFO, MachoLoadCommands.LC_DYLD_INFO_ONLY]:\n                self._dyld_info = MachoDyldInfoCommandStruct(self, offset)\n\n",
        "target_code_len": 625,
        "diff_format": "@@ -208,12 +220,12 @@\n                                       MachoLoadCommands.LC_ENCRYPTION_INFO_64]:\n-                self.encryption_info = MachoEncryptionInfoStruct(self, offset)\n+                self._encryption_info = MachoEncryptionInfoStruct(self, offset)\n \n             elif load_command.cmd == MachoLoadCommands.LC_SYMTAB:\n-                self.symtab = MachoSymtabCommandStruct(self, offset)\n+                self._symtab = MachoSymtabCommandStruct(self, offset)\n \n             elif load_command.cmd == MachoLoadCommands.LC_DYSYMTAB:\n-                self.dysymtab = MachoDysymtabCommandStruct(self, offset)\n+                self._dysymtab = MachoDysymtabCommandStruct(self, offset)\n \n             elif load_command.cmd in [MachoLoadCommands.LC_DYLD_INFO, MachoLoadCommands.LC_DYLD_INFO_ONLY]:\n-                self.dyld_info = MachoDyldInfoCommandStruct(self, offset)\n+                self._dyld_info = MachoDyldInfoCommandStruct(self, offset)\n \n",
        "source_code_with_indent": "                                      MachoLoadCommands.LC_ENCRYPTION_INFO_64]:\n                <IND>self.encryption_info = MachoEncryptionInfoStruct(self, offset)\n\n            <DED>elif load_command.cmd == MachoLoadCommands.LC_SYMTAB:\n                <IND>self.symtab = MachoSymtabCommandStruct(self, offset)\n\n            <DED>elif load_command.cmd == MachoLoadCommands.LC_DYSYMTAB:\n                <IND>self.dysymtab = MachoDysymtabCommandStruct(self, offset)\n\n            <DED>elif load_command.cmd in [MachoLoadCommands.LC_DYLD_INFO, MachoLoadCommands.LC_DYLD_INFO_ONLY]:\n                <IND>self.dyld_info = MachoDyldInfoCommandStruct(self, offset)\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "                                      MachoLoadCommands.LC_ENCRYPTION_INFO_64]:\n                <IND>self._encryption_info = MachoEncryptionInfoStruct(self, offset)\n\n            <DED>elif load_command.cmd == MachoLoadCommands.LC_SYMTAB:\n                <IND>self._symtab = MachoSymtabCommandStruct(self, offset)\n\n            <DED>elif load_command.cmd == MachoLoadCommands.LC_DYSYMTAB:\n                <IND>self._dysymtab = MachoDysymtabCommandStruct(self, offset)\n\n            <DED>elif load_command.cmd in [MachoLoadCommands.LC_DYLD_INFO, MachoLoadCommands.LC_DYLD_INFO_ONLY]:\n                <IND>self._dyld_info = MachoDyldInfoCommandStruct(self, offset)\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "            elif load_command.cmd == MachoLoadCommands.LC_CODE_SIGNATURE:\n                self.code_signature_cmd = MachoLinkeditDataCommandStruct(self, offset)\n\n",
        "source_code_len": 162,
        "target_code": "            elif load_command.cmd == MachoLoadCommands.LC_CODE_SIGNATURE:\n                self._code_signature_cmd = MachoLinkeditDataCommandStruct(self, offset)\n\n",
        "target_code_len": 163,
        "diff_format": "@@ -225,3 +236,3 @@\n             elif load_command.cmd == MachoLoadCommands.LC_CODE_SIGNATURE:\n-                self.code_signature_cmd = MachoLinkeditDataCommandStruct(self, offset)\n+                self._code_signature_cmd = MachoLinkeditDataCommandStruct(self, offset)\n \n",
        "source_code_with_indent": "            <DED>elif load_command.cmd == MachoLoadCommands.LC_CODE_SIGNATURE:\n                <IND>self.code_signature_cmd = MachoLinkeditDataCommandStruct(self, offset)\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "            <DED>elif load_command.cmd == MachoLoadCommands.LC_CODE_SIGNATURE:\n                <IND>self._code_signature_cmd = MachoLinkeditDataCommandStruct(self, offset)\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "            indirect_symtab_entry = self.read_word(indirect_symtab_off, virtual=False, word_type=c_uint32)\n            indirect_symtab.append(int(indirect_symtab_entry.value))\n            # traverse to next pointer\n",
        "source_code_len": 215,
        "target_code": "            indirect_symtab_entry = self.read_word(indirect_symtab_off, virtual=False, word_type=c_uint32)\n            if not indirect_symtab_entry:\n                continue\n            indirect_symtab.append(int(indirect_symtab_entry))\n            # traverse to next pointer\n",
        "target_code_len": 276,
        "diff_format": "@@ -398,3 +410,5 @@\n             indirect_symtab_entry = self.read_word(indirect_symtab_off, virtual=False, word_type=c_uint32)\n-            indirect_symtab.append(int(indirect_symtab_entry.value))\n+            if not indirect_symtab_entry:\n+                continue\n+            indirect_symtab.append(int(indirect_symtab_entry))\n             # traverse to next pointer\n",
        "source_code_with_indent": "            <IND>indirect_symtab_entry = self.read_word(indirect_symtab_off, virtual=False, word_type=c_uint32)\n            indirect_symtab.append(int(indirect_symtab_entry.value))\n            # traverse to next pointer\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "            <IND>indirect_symtab_entry = self.read_word(indirect_symtab_off, virtual=False, word_type=c_uint32)\n            if not indirect_symtab_entry:\n                <IND>continue\n            <DED>indirect_symtab.append(int(indirect_symtab_entry))\n            # traverse to next pointer\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "                  address: int,\n                  virtual=True,\n                  word_type=None) -> Optional[Union[c_uint32, c_uint64]]:\n        \"\"\"Attempt to read a word from the binary at a virtual address. Returns None if the address is invalid.\n",
        "source_code_len": 250,
        "target_code": "                  address: int,\n                  virtual: bool = True,\n                  word_type: Any = None) -> Optional[int]:\n        \"\"\"Attempt to read a word from the binary at a virtual address. Returns None if the address is invalid.\n",
        "target_code_len": 243,
        "diff_format": "@@ -568,4 +595,4 @@\n                   address: int,\n-                  virtual=True,\n-                  word_type=None) -> Optional[Union[c_uint32, c_uint64]]:\n+                  virtual: bool = True,\n+                  word_type: Any = None) -> Optional[int]:\n         \"\"\"Attempt to read a word from the binary at a virtual address. Returns None if the address is invalid.\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "                  address: int,\n                  virtual=True,\n                  word_type=None) -> Optional[Union[c_uint32, c_uint64]]:\n        <IND>",
        "target_code_with_indent": "                  address: int,\n                  virtual: bool = True,\n                  word_type: Any = None) -> Optional[int]:\n        <IND>"
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    @property\n    def _codesign_parser(self) -> 'CodesignParser':\n        from strongarm.macho.codesign import CodesignParser\n        if not self.__codesign_parser:\n",
        "source_code_len": 165,
        "target_code": "    @property\n    def header(self) -> MachoHeaderStruct:\n        if self._header:\n            return self._header\n        else:\n            raise RuntimeError('Failed to parse Mach-O')\n\n    @property\n    def dysymtab(self) -> MachoDysymtabCommandStruct:\n        if self._dysymtab:\n            return self._dysymtab\n        else:\n            raise RuntimeError('Failed to parse Mach-O')\n\n    @property\n    def symtab(self) -> MachoSymtabCommandStruct:\n        if self._symtab:\n            return self._symtab\n        else:\n            raise RuntimeError('Failed to parse Mach-O')\n\n    @property\n    def encryption_info(self) -> MachoEncryptionInfoStruct:\n        if self._encryption_info:\n            return self._encryption_info\n        else:\n            raise RuntimeError('Failed to parse Mach-O')\n\n    @property\n    def dyld_info(self) -> MachoDyldInfoCommandStruct:\n        if self._dyld_info:\n            return self._dyld_info\n        else:\n            raise RuntimeError('Failed to parse Mach-O')\n\n    @property\n    def code_signature_cmd(self) -> MachoLinkeditDataCommandStruct:\n        if self._code_signature_cmd:\n            return self._code_signature_cmd\n        else:\n            raise RuntimeError('Failed to parse Mach-O')\n\n    @property\n    def _codesign_parser(self) -> 'CodesignParser':\n        if not self.__codesign_parser:\n",
        "target_code_len": 1345,
        "diff_format": "@@ -583,4 +613,45 @@\n     @property\n+    def header(self) -> MachoHeaderStruct:\n+        if self._header:\n+            return self._header\n+        else:\n+            raise RuntimeError('Failed to parse Mach-O')\n+\n+    @property\n+    def dysymtab(self) -> MachoDysymtabCommandStruct:\n+        if self._dysymtab:\n+            return self._dysymtab\n+        else:\n+            raise RuntimeError('Failed to parse Mach-O')\n+\n+    @property\n+    def symtab(self) -> MachoSymtabCommandStruct:\n+        if self._symtab:\n+            return self._symtab\n+        else:\n+            raise RuntimeError('Failed to parse Mach-O')\n+\n+    @property\n+    def encryption_info(self) -> MachoEncryptionInfoStruct:\n+        if self._encryption_info:\n+            return self._encryption_info\n+        else:\n+            raise RuntimeError('Failed to parse Mach-O')\n+\n+    @property\n+    def dyld_info(self) -> MachoDyldInfoCommandStruct:\n+        if self._dyld_info:\n+            return self._dyld_info\n+        else:\n+            raise RuntimeError('Failed to parse Mach-O')\n+\n+    @property\n+    def code_signature_cmd(self) -> MachoLinkeditDataCommandStruct:\n+        if self._code_signature_cmd:\n+            return self._code_signature_cmd\n+        else:\n+            raise RuntimeError('Failed to parse Mach-O')\n+\n+    @property\n     def _codesign_parser(self) -> 'CodesignParser':\n-        from strongarm.macho.codesign import CodesignParser\n         if not self.__codesign_parser:\n",
        "source_code_with_indent": "    <DED>@property\n    def _codesign_parser(self) -> 'CodesignParser':\n        <IND>from strongarm.macho.codesign import CodesignParser\n        if not self.__codesign_parser:\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    <DED>@property\n    def header(self) -> MachoHeaderStruct:\n        <IND>if self._header:\n            <IND>return self._header\n        <DED>else:\n            <IND>raise RuntimeError('Failed to parse Mach-O')\n\n    <DED><DED>@property\n    def dysymtab(self) -> MachoDysymtabCommandStruct:\n        <IND>if self._dysymtab:\n            <IND>return self._dysymtab\n        <DED>else:\n            <IND>raise RuntimeError('Failed to parse Mach-O')\n\n    <DED><DED>@property\n    def symtab(self) -> MachoSymtabCommandStruct:\n        <IND>if self._symtab:\n            <IND>return self._symtab\n        <DED>else:\n            <IND>raise RuntimeError('Failed to parse Mach-O')\n\n    <DED><DED>@property\n    def encryption_info(self) -> MachoEncryptionInfoStruct:\n        <IND>if self._encryption_info:\n            <IND>return self._encryption_info\n        <DED>else:\n            <IND>raise RuntimeError('Failed to parse Mach-O')\n\n    <DED><DED>@property\n    def dyld_info(self) -> MachoDyldInfoCommandStruct:\n        <IND>if self._dyld_info:\n            <IND>return self._dyld_info\n        <DED>else:\n            <IND>raise RuntimeError('Failed to parse Mach-O')\n\n    <DED><DED>@property\n    def code_signature_cmd(self) -> MachoLinkeditDataCommandStruct:\n        <IND>if self._code_signature_cmd:\n            <IND>return self._code_signature_cmd\n        <DED>else:\n            <IND>raise RuntimeError('Failed to parse Mach-O')\n\n    <DED><DED>@property\n    def _codesign_parser(self) -> 'CodesignParser':\n        <IND>if not self.__codesign_parser:\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "datatheorem/strongarm",
    "commit": "ab620d78b4ce7f933cedc25960307f2c3b03c1a8",
    "filename": "strongarm/macho/macho_binary.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/datatheorem-strongarm/strongarm/macho/macho_binary.py",
    "file_hunks_size": 33,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "strongarm/macho/macho_binary.py:80:8 Incompatible attribute type [8]: Attribute `dyld_info` declared in class `MachoBinary` has type `MachoDyldInfoCommandStruct` but is used as type `None`.",
    "message": " Attribute `dyld_info` declared in class `MachoBinary` has type `MachoDyldInfoCommandStruct` but is used as type `None`.",
    "rule_id": "Incompatible attribute type [8]",
    "warning_line_no": 80,
    "warning_line": "        self.dyld_info: MachoDyldInfoCommandStruct = None",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "# -*- coding: utf-8 -*-\nfrom typing import List, Tuple, Optional, Dict, Union\n\n",
        "source_code_len": 79,
        "target_code": "# -*- coding: utf-8 -*-\nfrom typing import List, Dict, Tuple, Any, Type, Optional\nfrom typing import TYPE_CHECKING\n\nfrom ctypes import c_uint64, c_uint32, sizeof\n\n",
        "target_code_len": 163,
        "diff_format": "@@ -1,3 +1,6 @@\n # -*- coding: utf-8 -*-\n-from typing import List, Tuple, Optional, Dict, Union\n+from typing import List, Dict, Tuple, Any, Type, Optional\n+from typing import TYPE_CHECKING\n+\n+from ctypes import c_uint64, c_uint32, sizeof\n \n",
        "source_code_with_indent": "# -*- coding: utf-8 -*-\nfrom typing import List, Tuple, Optional, Dict, Union\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "# -*- coding: utf-8 -*-\nfrom typing import List, Dict, Tuple, Any, Type, Optional\nfrom typing import TYPE_CHECKING\n\nfrom ctypes import c_uint64, c_uint32, sizeof\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "from strongarm.macho.macho_load_commands import MachoLoadCommands\nfrom strongarm.macho.arch_independent_structs import \\\n    MachoHeaderStruct, \\\n    MachoSegmentCommandStruct, \\\n    MachoSectionRawStruct, \\\n    MachoEncryptionInfoStruct, \\\n    MachoNlistStruct, \\\n    CFStringStruct, \\\n    DylibCommandStruct, \\\n    MachoLoadCommandStruct, \\\n    MachoSymtabCommandStruct, \\\n    MachoDysymtabCommandStruct, \\\n    MachoDyldInfoCommandStruct, \\\n    MachoLinkeditDataCommandStruct\n\nfrom ctypes import c_uint64, c_uint32, sizeof\n\n",
        "source_code_len": 526,
        "target_code": "from strongarm.macho.macho_load_commands import MachoLoadCommands\nfrom strongarm.macho.arch_independent_structs import (\n    ArchIndependentStructure,\n    MachoHeaderStruct,\n    MachoSegmentCommandStruct,\n    MachoSectionRawStruct,\n    MachoEncryptionInfoStruct,\n    MachoNlistStruct,\n    CFStringStruct,\n    DylibCommandStruct,\n    MachoLoadCommandStruct,\n    MachoSymtabCommandStruct,\n    MachoDysymtabCommandStruct,\n    MachoDyldInfoCommandStruct,\n    MachoLinkeditDataCommandStruct,\n)\n\nif TYPE_CHECKING:\n    from strongarm.macho.codesign import CodesignParser\n\n",
        "target_code_len": 565,
        "diff_format": "@@ -7,17 +10,20 @@\n from strongarm.macho.macho_load_commands import MachoLoadCommands\n-from strongarm.macho.arch_independent_structs import \\\n-    MachoHeaderStruct, \\\n-    MachoSegmentCommandStruct, \\\n-    MachoSectionRawStruct, \\\n-    MachoEncryptionInfoStruct, \\\n-    MachoNlistStruct, \\\n-    CFStringStruct, \\\n-    DylibCommandStruct, \\\n-    MachoLoadCommandStruct, \\\n-    MachoSymtabCommandStruct, \\\n-    MachoDysymtabCommandStruct, \\\n-    MachoDyldInfoCommandStruct, \\\n-    MachoLinkeditDataCommandStruct\n-\n-from ctypes import c_uint64, c_uint32, sizeof\n+from strongarm.macho.arch_independent_structs import (\n+    ArchIndependentStructure,\n+    MachoHeaderStruct,\n+    MachoSegmentCommandStruct,\n+    MachoSectionRawStruct,\n+    MachoEncryptionInfoStruct,\n+    MachoNlistStruct,\n+    CFStringStruct,\n+    DylibCommandStruct,\n+    MachoLoadCommandStruct,\n+    MachoSymtabCommandStruct,\n+    MachoDysymtabCommandStruct,\n+    MachoDyldInfoCommandStruct,\n+    MachoLinkeditDataCommandStruct,\n+)\n+\n+if TYPE_CHECKING:\n+    from strongarm.macho.codesign import CodesignParser\n \n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent": "from strongarm.macho.macho_load_commands import MachoLoadCommands\nfrom strongarm.macho.arch_independent_structs import (\n    ArchIndependentStructure,\n    MachoHeaderStruct,\n    MachoSegmentCommandStruct,\n    MachoSectionRawStruct,\n    MachoEncryptionInfoStruct,\n    MachoNlistStruct,\n    CFStringStruct,\n    DylibCommandStruct,\n    MachoLoadCommandStruct,\n    MachoSymtabCommandStruct,\n    MachoDysymtabCommandStruct,\n    MachoDyldInfoCommandStruct,\n    MachoLinkeditDataCommandStruct,\n)\n\nif TYPE_CHECKING:\n    <IND>from strongarm.macho.codesign import CodesignParser\n\n",
        "target_code_with_indent_exact_match": true,
        "source_code_with_indent": "from strongarm.macho.macho_load_commands import MachoLoadCommands\nfrom strongarm.macho.arch_independent_structs import    MachoHeaderStruct,    MachoSegmentCommandStruct,    MachoSectionRawStruct,    MachoEncryptionInfoStruct,    MachoNlistStruct,    CFStringStruct,    DylibCommandStruct,    MachoLoadCommandStruct,    MachoSymtabCommandStruct,    MachoDysymtabCommandStruct,    MachoDyldInfoCommandStruct,    MachoLinkeditDataCommandStruct\n\nfrom ctypes import c_uint64, c_uint32, sizeof\n\n"
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "        # generic Mach-O header info\n        self.is_64bit: bool = None\n        self.is_swap: bool = None\n        self.cpu_type: CPU_TYPE = None\n        self._load_commands_end_addr = None\n\n        # Mach-O header data\n        self.header: MachoHeaderStruct = None\n        self.header_flags: List[int] = None\n        self.file_type: MachoFileType = None\n\n        # segment and section commands from Mach-O header\n        self.segment_commands: Dict[str, MachoSegmentCommandStruct] = None\n        self.sections: Dict[str, MachoSection] = None\n        # also store specific interesting sections which are useful to us\n        self.dysymtab: MachoDysymtabCommandStruct = None\n        self.symtab: MachoSymtabCommandStruct = None\n        self.encryption_info: MachoEncryptionInfoStruct = None\n        self.dyld_info: MachoDyldInfoCommandStruct = None\n        self.load_dylib_commands: List[DylibCommandStruct] = None\n        self.code_signature_cmd: MachoLinkeditDataCommandStruct = None\n\n        self.__codesign_parser: CodesignParser = None\n\n",
        "source_code_len": 1040,
        "target_code": "        # generic Mach-O header info\n        self.is_64bit: bool = False\n        self.is_swap: bool = False\n        self.cpu_type: CPU_TYPE = CPU_TYPE.UNKNOWN\n        self._load_commands_end_addr = 0\n\n        # Mach-O header data\n        self._header: Optional[MachoHeaderStruct] = None\n        self.header_flags: List[int] = []\n        self.file_type: MachoFileType = MachoFileType.MH_EXECUTE\n\n        # segment and section commands from Mach-O header\n        self.segment_commands: Dict[str, MachoSegmentCommandStruct] = {}\n        self.sections: Dict[str, MachoSection] = {}\n        # also store specific interesting sections which are useful to us\n        self._dysymtab: Optional[MachoDysymtabCommandStruct] = None\n        self._symtab: Optional[MachoSymtabCommandStruct] = None\n        self._encryption_info: Optional[MachoEncryptionInfoStruct] = None\n        self._dyld_info: Optional[MachoDyldInfoCommandStruct] = None\n        self.load_dylib_commands: List[DylibCommandStruct] = []\n        self._code_signature_cmd: Optional[MachoLinkeditDataCommandStruct] = None\n\n        self.__codesign_parser: Optional[CodesignParser] = None\n\n",
        "target_code_len": 1139,
        "diff_format": "@@ -62,24 +68,24 @@\n         # generic Mach-O header info\n-        self.is_64bit: bool = None\n-        self.is_swap: bool = None\n-        self.cpu_type: CPU_TYPE = None\n-        self._load_commands_end_addr = None\n+        self.is_64bit: bool = False\n+        self.is_swap: bool = False\n+        self.cpu_type: CPU_TYPE = CPU_TYPE.UNKNOWN\n+        self._load_commands_end_addr = 0\n \n         # Mach-O header data\n-        self.header: MachoHeaderStruct = None\n-        self.header_flags: List[int] = None\n-        self.file_type: MachoFileType = None\n+        self._header: Optional[MachoHeaderStruct] = None\n+        self.header_flags: List[int] = []\n+        self.file_type: MachoFileType = MachoFileType.MH_EXECUTE\n \n         # segment and section commands from Mach-O header\n-        self.segment_commands: Dict[str, MachoSegmentCommandStruct] = None\n-        self.sections: Dict[str, MachoSection] = None\n+        self.segment_commands: Dict[str, MachoSegmentCommandStruct] = {}\n+        self.sections: Dict[str, MachoSection] = {}\n         # also store specific interesting sections which are useful to us\n-        self.dysymtab: MachoDysymtabCommandStruct = None\n-        self.symtab: MachoSymtabCommandStruct = None\n-        self.encryption_info: MachoEncryptionInfoStruct = None\n-        self.dyld_info: MachoDyldInfoCommandStruct = None\n-        self.load_dylib_commands: List[DylibCommandStruct] = None\n-        self.code_signature_cmd: MachoLinkeditDataCommandStruct = None\n-\n-        self.__codesign_parser: CodesignParser = None\n+        self._dysymtab: Optional[MachoDysymtabCommandStruct] = None\n+        self._symtab: Optional[MachoSymtabCommandStruct] = None\n+        self._encryption_info: Optional[MachoEncryptionInfoStruct] = None\n+        self._dyld_info: Optional[MachoDyldInfoCommandStruct] = None\n+        self.load_dylib_commands: List[DylibCommandStruct] = []\n+        self._code_signature_cmd: Optional[MachoLinkeditDataCommandStruct] = None\n+\n+        self.__codesign_parser: Optional[CodesignParser] = None\n \n",
        "source_code_with_indent": "        # generic Mach-O header info\n        self.is_64bit: bool = None\n        self.is_swap: bool = None\n        self.cpu_type: CPU_TYPE = None\n        self._load_commands_end_addr = None\n\n        # Mach-O header data\n        self.header: MachoHeaderStruct = None\n        self.header_flags: List[int] = None\n        self.file_type: MachoFileType = None\n\n        # segment and section commands from Mach-O header\n        self.segment_commands: Dict[str, MachoSegmentCommandStruct] = None\n        self.sections: Dict[str, MachoSection] = None\n        # also store specific interesting sections which are useful to us\n        self.dysymtab: MachoDysymtabCommandStruct = None\n        self.symtab: MachoSymtabCommandStruct = None\n        self.encryption_info: MachoEncryptionInfoStruct = None\n        self.dyld_info: MachoDyldInfoCommandStruct = None\n        self.load_dylib_commands: List[DylibCommandStruct] = None\n        self.code_signature_cmd: MachoLinkeditDataCommandStruct = None\n\n        self.__codesign_parser: CodesignParser = None\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "        # generic Mach-O header info\n        self.is_64bit: bool = False\n        self.is_swap: bool = False\n        self.cpu_type: CPU_TYPE = CPU_TYPE.UNKNOWN\n        self._load_commands_end_addr = 0\n\n        # Mach-O header data\n        self._header: Optional[MachoHeaderStruct] = None\n        self.header_flags: List[int] = []\n        self.file_type: MachoFileType = MachoFileType.MH_EXECUTE\n\n        # segment and section commands from Mach-O header\n        self.segment_commands: Dict[str, MachoSegmentCommandStruct] = {}\n        self.sections: Dict[str, MachoSection] = {}\n        # also store specific interesting sections which are useful to us\n        self._dysymtab: Optional[MachoDysymtabCommandStruct] = None\n        self._symtab: Optional[MachoSymtabCommandStruct] = None\n        self._encryption_info: Optional[MachoEncryptionInfoStruct] = None\n        self._dyld_info: Optional[MachoDyldInfoCommandStruct] = None\n        self.load_dylib_commands: List[DylibCommandStruct] = []\n        self._code_signature_cmd: Optional[MachoLinkeditDataCommandStruct] = None\n\n        self.__codesign_parser: Optional[CodesignParser] = None\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    @property\n    def slice_magic(self) -> c_uint32:\n        \"\"\"Read magic number identifier from this Mach-O slice\n        \"\"\"\n        return self.read_word(0, virtual=False, word_type=c_uint32)\n\n",
        "source_code_len": 197,
        "target_code": "    @property\n    def slice_magic(self) -> int:\n        \"\"\"Read magic number identifier from this Mach-O slice\n        \"\"\"\n        magic = self.read_word(0, virtual=False, word_type=c_uint32)\n        if magic:\n            return magic\n        else:\n            raise ValueError('Could not read magic value.')\n\n",
        "target_code_len": 310,
        "diff_format": "@@ -124,6 +131,10 @@\n     @property\n-    def slice_magic(self) -> c_uint32:\n+    def slice_magic(self) -> int:\n         \"\"\"Read magic number identifier from this Mach-O slice\n         \"\"\"\n-        return self.read_word(0, virtual=False, word_type=c_uint32)\n+        magic = self.read_word(0, virtual=False, word_type=c_uint32)\n+        if magic:\n+            return magic\n+        else:\n+            raise ValueError('Could not read magic value.')\n \n",
        "source_code_with_indent": "    <DED>@property\n    def slice_magic(self) -> c_uint32:\n        <IND>\"\"\"Read magic number identifier from this Mach-O slice\n        \"\"\"\n        return self.read_word(0, virtual=False, word_type=c_uint32)\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    <DED>@property\n    def slice_magic(self) -> int:\n        <IND>\"\"\"Read magic number identifier from this Mach-O slice\n        \"\"\"\n        magic = self.read_word(0, virtual=False, word_type=c_uint32)\n        if magic:\n            <IND>return magic\n        <DED>else:\n            <IND>raise ValueError('Could not read magic value.')\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "        \"\"\"\n        self.header = MachoHeaderStruct(self, 0)\n\n",
        "source_code_len": 62,
        "target_code": "        \"\"\"\n        self._header = MachoHeaderStruct(self, 0)\n\n",
        "target_code_len": 63,
        "diff_format": "@@ -152,3 +163,3 @@\n         \"\"\"\n-        self.header = MachoHeaderStruct(self, 0)\n+        self._header = MachoHeaderStruct(self, 0)\n \n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\n        self.header = MachoHeaderStruct(self, 0)\n\n",
        "target_code_with_indent": "\n        self._header = MachoHeaderStruct(self, 0)\n\n"
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "                                      MachoLoadCommands.LC_ENCRYPTION_INFO_64]:\n                self.encryption_info = MachoEncryptionInfoStruct(self, offset)\n\n            elif load_command.cmd == MachoLoadCommands.LC_SYMTAB:\n                self.symtab = MachoSymtabCommandStruct(self, offset)\n\n            elif load_command.cmd == MachoLoadCommands.LC_DYSYMTAB:\n                self.dysymtab = MachoDysymtabCommandStruct(self, offset)\n\n            elif load_command.cmd in [MachoLoadCommands.LC_DYLD_INFO, MachoLoadCommands.LC_DYLD_INFO_ONLY]:\n                self.dyld_info = MachoDyldInfoCommandStruct(self, offset)\n\n",
        "source_code_len": 621,
        "target_code": "                                      MachoLoadCommands.LC_ENCRYPTION_INFO_64]:\n                self._encryption_info = MachoEncryptionInfoStruct(self, offset)\n\n            elif load_command.cmd == MachoLoadCommands.LC_SYMTAB:\n                self._symtab = MachoSymtabCommandStruct(self, offset)\n\n            elif load_command.cmd == MachoLoadCommands.LC_DYSYMTAB:\n                self._dysymtab = MachoDysymtabCommandStruct(self, offset)\n\n            elif load_command.cmd in [MachoLoadCommands.LC_DYLD_INFO, MachoLoadCommands.LC_DYLD_INFO_ONLY]:\n                self._dyld_info = MachoDyldInfoCommandStruct(self, offset)\n\n",
        "target_code_len": 625,
        "diff_format": "@@ -208,12 +220,12 @@\n                                       MachoLoadCommands.LC_ENCRYPTION_INFO_64]:\n-                self.encryption_info = MachoEncryptionInfoStruct(self, offset)\n+                self._encryption_info = MachoEncryptionInfoStruct(self, offset)\n \n             elif load_command.cmd == MachoLoadCommands.LC_SYMTAB:\n-                self.symtab = MachoSymtabCommandStruct(self, offset)\n+                self._symtab = MachoSymtabCommandStruct(self, offset)\n \n             elif load_command.cmd == MachoLoadCommands.LC_DYSYMTAB:\n-                self.dysymtab = MachoDysymtabCommandStruct(self, offset)\n+                self._dysymtab = MachoDysymtabCommandStruct(self, offset)\n \n             elif load_command.cmd in [MachoLoadCommands.LC_DYLD_INFO, MachoLoadCommands.LC_DYLD_INFO_ONLY]:\n-                self.dyld_info = MachoDyldInfoCommandStruct(self, offset)\n+                self._dyld_info = MachoDyldInfoCommandStruct(self, offset)\n \n",
        "source_code_with_indent": "                                      MachoLoadCommands.LC_ENCRYPTION_INFO_64]:\n                <IND>self.encryption_info = MachoEncryptionInfoStruct(self, offset)\n\n            <DED>elif load_command.cmd == MachoLoadCommands.LC_SYMTAB:\n                <IND>self.symtab = MachoSymtabCommandStruct(self, offset)\n\n            <DED>elif load_command.cmd == MachoLoadCommands.LC_DYSYMTAB:\n                <IND>self.dysymtab = MachoDysymtabCommandStruct(self, offset)\n\n            <DED>elif load_command.cmd in [MachoLoadCommands.LC_DYLD_INFO, MachoLoadCommands.LC_DYLD_INFO_ONLY]:\n                <IND>self.dyld_info = MachoDyldInfoCommandStruct(self, offset)\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "                                      MachoLoadCommands.LC_ENCRYPTION_INFO_64]:\n                <IND>self._encryption_info = MachoEncryptionInfoStruct(self, offset)\n\n            <DED>elif load_command.cmd == MachoLoadCommands.LC_SYMTAB:\n                <IND>self._symtab = MachoSymtabCommandStruct(self, offset)\n\n            <DED>elif load_command.cmd == MachoLoadCommands.LC_DYSYMTAB:\n                <IND>self._dysymtab = MachoDysymtabCommandStruct(self, offset)\n\n            <DED>elif load_command.cmd in [MachoLoadCommands.LC_DYLD_INFO, MachoLoadCommands.LC_DYLD_INFO_ONLY]:\n                <IND>self._dyld_info = MachoDyldInfoCommandStruct(self, offset)\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "            elif load_command.cmd == MachoLoadCommands.LC_CODE_SIGNATURE:\n                self.code_signature_cmd = MachoLinkeditDataCommandStruct(self, offset)\n\n",
        "source_code_len": 162,
        "target_code": "            elif load_command.cmd == MachoLoadCommands.LC_CODE_SIGNATURE:\n                self._code_signature_cmd = MachoLinkeditDataCommandStruct(self, offset)\n\n",
        "target_code_len": 163,
        "diff_format": "@@ -225,3 +236,3 @@\n             elif load_command.cmd == MachoLoadCommands.LC_CODE_SIGNATURE:\n-                self.code_signature_cmd = MachoLinkeditDataCommandStruct(self, offset)\n+                self._code_signature_cmd = MachoLinkeditDataCommandStruct(self, offset)\n \n",
        "source_code_with_indent": "            <DED>elif load_command.cmd == MachoLoadCommands.LC_CODE_SIGNATURE:\n                <IND>self.code_signature_cmd = MachoLinkeditDataCommandStruct(self, offset)\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "            <DED>elif load_command.cmd == MachoLoadCommands.LC_CODE_SIGNATURE:\n                <IND>self._code_signature_cmd = MachoLinkeditDataCommandStruct(self, offset)\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "            indirect_symtab_entry = self.read_word(indirect_symtab_off, virtual=False, word_type=c_uint32)\n            indirect_symtab.append(int(indirect_symtab_entry.value))\n            # traverse to next pointer\n",
        "source_code_len": 215,
        "target_code": "            indirect_symtab_entry = self.read_word(indirect_symtab_off, virtual=False, word_type=c_uint32)\n            if not indirect_symtab_entry:\n                continue\n            indirect_symtab.append(int(indirect_symtab_entry))\n            # traverse to next pointer\n",
        "target_code_len": 276,
        "diff_format": "@@ -398,3 +410,5 @@\n             indirect_symtab_entry = self.read_word(indirect_symtab_off, virtual=False, word_type=c_uint32)\n-            indirect_symtab.append(int(indirect_symtab_entry.value))\n+            if not indirect_symtab_entry:\n+                continue\n+            indirect_symtab.append(int(indirect_symtab_entry))\n             # traverse to next pointer\n",
        "source_code_with_indent": "            <IND>indirect_symtab_entry = self.read_word(indirect_symtab_off, virtual=False, word_type=c_uint32)\n            indirect_symtab.append(int(indirect_symtab_entry.value))\n            # traverse to next pointer\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "            <IND>indirect_symtab_entry = self.read_word(indirect_symtab_off, virtual=False, word_type=c_uint32)\n            if not indirect_symtab_entry:\n                <IND>continue\n            <DED>indirect_symtab.append(int(indirect_symtab_entry))\n            # traverse to next pointer\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "                  address: int,\n                  virtual=True,\n                  word_type=None) -> Optional[Union[c_uint32, c_uint64]]:\n        \"\"\"Attempt to read a word from the binary at a virtual address. Returns None if the address is invalid.\n",
        "source_code_len": 250,
        "target_code": "                  address: int,\n                  virtual: bool = True,\n                  word_type: Any = None) -> Optional[int]:\n        \"\"\"Attempt to read a word from the binary at a virtual address. Returns None if the address is invalid.\n",
        "target_code_len": 243,
        "diff_format": "@@ -568,4 +595,4 @@\n                   address: int,\n-                  virtual=True,\n-                  word_type=None) -> Optional[Union[c_uint32, c_uint64]]:\n+                  virtual: bool = True,\n+                  word_type: Any = None) -> Optional[int]:\n         \"\"\"Attempt to read a word from the binary at a virtual address. Returns None if the address is invalid.\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "                  address: int,\n                  virtual=True,\n                  word_type=None) -> Optional[Union[c_uint32, c_uint64]]:\n        <IND>",
        "target_code_with_indent": "                  address: int,\n                  virtual: bool = True,\n                  word_type: Any = None) -> Optional[int]:\n        <IND>"
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    @property\n    def _codesign_parser(self) -> 'CodesignParser':\n        from strongarm.macho.codesign import CodesignParser\n        if not self.__codesign_parser:\n",
        "source_code_len": 165,
        "target_code": "    @property\n    def header(self) -> MachoHeaderStruct:\n        if self._header:\n            return self._header\n        else:\n            raise RuntimeError('Failed to parse Mach-O')\n\n    @property\n    def dysymtab(self) -> MachoDysymtabCommandStruct:\n        if self._dysymtab:\n            return self._dysymtab\n        else:\n            raise RuntimeError('Failed to parse Mach-O')\n\n    @property\n    def symtab(self) -> MachoSymtabCommandStruct:\n        if self._symtab:\n            return self._symtab\n        else:\n            raise RuntimeError('Failed to parse Mach-O')\n\n    @property\n    def encryption_info(self) -> MachoEncryptionInfoStruct:\n        if self._encryption_info:\n            return self._encryption_info\n        else:\n            raise RuntimeError('Failed to parse Mach-O')\n\n    @property\n    def dyld_info(self) -> MachoDyldInfoCommandStruct:\n        if self._dyld_info:\n            return self._dyld_info\n        else:\n            raise RuntimeError('Failed to parse Mach-O')\n\n    @property\n    def code_signature_cmd(self) -> MachoLinkeditDataCommandStruct:\n        if self._code_signature_cmd:\n            return self._code_signature_cmd\n        else:\n            raise RuntimeError('Failed to parse Mach-O')\n\n    @property\n    def _codesign_parser(self) -> 'CodesignParser':\n        if not self.__codesign_parser:\n",
        "target_code_len": 1345,
        "diff_format": "@@ -583,4 +613,45 @@\n     @property\n+    def header(self) -> MachoHeaderStruct:\n+        if self._header:\n+            return self._header\n+        else:\n+            raise RuntimeError('Failed to parse Mach-O')\n+\n+    @property\n+    def dysymtab(self) -> MachoDysymtabCommandStruct:\n+        if self._dysymtab:\n+            return self._dysymtab\n+        else:\n+            raise RuntimeError('Failed to parse Mach-O')\n+\n+    @property\n+    def symtab(self) -> MachoSymtabCommandStruct:\n+        if self._symtab:\n+            return self._symtab\n+        else:\n+            raise RuntimeError('Failed to parse Mach-O')\n+\n+    @property\n+    def encryption_info(self) -> MachoEncryptionInfoStruct:\n+        if self._encryption_info:\n+            return self._encryption_info\n+        else:\n+            raise RuntimeError('Failed to parse Mach-O')\n+\n+    @property\n+    def dyld_info(self) -> MachoDyldInfoCommandStruct:\n+        if self._dyld_info:\n+            return self._dyld_info\n+        else:\n+            raise RuntimeError('Failed to parse Mach-O')\n+\n+    @property\n+    def code_signature_cmd(self) -> MachoLinkeditDataCommandStruct:\n+        if self._code_signature_cmd:\n+            return self._code_signature_cmd\n+        else:\n+            raise RuntimeError('Failed to parse Mach-O')\n+\n+    @property\n     def _codesign_parser(self) -> 'CodesignParser':\n-        from strongarm.macho.codesign import CodesignParser\n         if not self.__codesign_parser:\n",
        "source_code_with_indent": "    <DED>@property\n    def _codesign_parser(self) -> 'CodesignParser':\n        <IND>from strongarm.macho.codesign import CodesignParser\n        if not self.__codesign_parser:\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    <DED>@property\n    def header(self) -> MachoHeaderStruct:\n        <IND>if self._header:\n            <IND>return self._header\n        <DED>else:\n            <IND>raise RuntimeError('Failed to parse Mach-O')\n\n    <DED><DED>@property\n    def dysymtab(self) -> MachoDysymtabCommandStruct:\n        <IND>if self._dysymtab:\n            <IND>return self._dysymtab\n        <DED>else:\n            <IND>raise RuntimeError('Failed to parse Mach-O')\n\n    <DED><DED>@property\n    def symtab(self) -> MachoSymtabCommandStruct:\n        <IND>if self._symtab:\n            <IND>return self._symtab\n        <DED>else:\n            <IND>raise RuntimeError('Failed to parse Mach-O')\n\n    <DED><DED>@property\n    def encryption_info(self) -> MachoEncryptionInfoStruct:\n        <IND>if self._encryption_info:\n            <IND>return self._encryption_info\n        <DED>else:\n            <IND>raise RuntimeError('Failed to parse Mach-O')\n\n    <DED><DED>@property\n    def dyld_info(self) -> MachoDyldInfoCommandStruct:\n        <IND>if self._dyld_info:\n            <IND>return self._dyld_info\n        <DED>else:\n            <IND>raise RuntimeError('Failed to parse Mach-O')\n\n    <DED><DED>@property\n    def code_signature_cmd(self) -> MachoLinkeditDataCommandStruct:\n        <IND>if self._code_signature_cmd:\n            <IND>return self._code_signature_cmd\n        <DED>else:\n            <IND>raise RuntimeError('Failed to parse Mach-O')\n\n    <DED><DED>@property\n    def _codesign_parser(self) -> 'CodesignParser':\n        <IND>if not self.__codesign_parser:\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "datatheorem/strongarm",
    "commit": "ab620d78b4ce7f933cedc25960307f2c3b03c1a8",
    "filename": "strongarm/macho/macho_binary.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/datatheorem-strongarm/strongarm/macho/macho_binary.py",
    "file_hunks_size": 33,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "strongarm/macho/macho_binary.py:81:8 Incompatible attribute type [8]: Attribute `load_dylib_commands` declared in class `MachoBinary` has type `List[DylibCommandStruct]` but is used as type `None`.",
    "message": " Attribute `load_dylib_commands` declared in class `MachoBinary` has type `List[DylibCommandStruct]` but is used as type `None`.",
    "rule_id": "Incompatible attribute type [8]",
    "warning_line_no": 81,
    "warning_line": "        self.load_dylib_commands: List[DylibCommandStruct] = None",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "# -*- coding: utf-8 -*-\nfrom typing import List, Tuple, Optional, Dict, Union\n\n",
        "source_code_len": 79,
        "target_code": "# -*- coding: utf-8 -*-\nfrom typing import List, Dict, Tuple, Any, Type, Optional\nfrom typing import TYPE_CHECKING\n\nfrom ctypes import c_uint64, c_uint32, sizeof\n\n",
        "target_code_len": 163,
        "diff_format": "@@ -1,3 +1,6 @@\n # -*- coding: utf-8 -*-\n-from typing import List, Tuple, Optional, Dict, Union\n+from typing import List, Dict, Tuple, Any, Type, Optional\n+from typing import TYPE_CHECKING\n+\n+from ctypes import c_uint64, c_uint32, sizeof\n \n",
        "source_code_with_indent": "# -*- coding: utf-8 -*-\nfrom typing import List, Tuple, Optional, Dict, Union\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "# -*- coding: utf-8 -*-\nfrom typing import List, Dict, Tuple, Any, Type, Optional\nfrom typing import TYPE_CHECKING\n\nfrom ctypes import c_uint64, c_uint32, sizeof\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "from strongarm.macho.macho_load_commands import MachoLoadCommands\nfrom strongarm.macho.arch_independent_structs import \\\n    MachoHeaderStruct, \\\n    MachoSegmentCommandStruct, \\\n    MachoSectionRawStruct, \\\n    MachoEncryptionInfoStruct, \\\n    MachoNlistStruct, \\\n    CFStringStruct, \\\n    DylibCommandStruct, \\\n    MachoLoadCommandStruct, \\\n    MachoSymtabCommandStruct, \\\n    MachoDysymtabCommandStruct, \\\n    MachoDyldInfoCommandStruct, \\\n    MachoLinkeditDataCommandStruct\n\nfrom ctypes import c_uint64, c_uint32, sizeof\n\n",
        "source_code_len": 526,
        "target_code": "from strongarm.macho.macho_load_commands import MachoLoadCommands\nfrom strongarm.macho.arch_independent_structs import (\n    ArchIndependentStructure,\n    MachoHeaderStruct,\n    MachoSegmentCommandStruct,\n    MachoSectionRawStruct,\n    MachoEncryptionInfoStruct,\n    MachoNlistStruct,\n    CFStringStruct,\n    DylibCommandStruct,\n    MachoLoadCommandStruct,\n    MachoSymtabCommandStruct,\n    MachoDysymtabCommandStruct,\n    MachoDyldInfoCommandStruct,\n    MachoLinkeditDataCommandStruct,\n)\n\nif TYPE_CHECKING:\n    from strongarm.macho.codesign import CodesignParser\n\n",
        "target_code_len": 565,
        "diff_format": "@@ -7,17 +10,20 @@\n from strongarm.macho.macho_load_commands import MachoLoadCommands\n-from strongarm.macho.arch_independent_structs import \\\n-    MachoHeaderStruct, \\\n-    MachoSegmentCommandStruct, \\\n-    MachoSectionRawStruct, \\\n-    MachoEncryptionInfoStruct, \\\n-    MachoNlistStruct, \\\n-    CFStringStruct, \\\n-    DylibCommandStruct, \\\n-    MachoLoadCommandStruct, \\\n-    MachoSymtabCommandStruct, \\\n-    MachoDysymtabCommandStruct, \\\n-    MachoDyldInfoCommandStruct, \\\n-    MachoLinkeditDataCommandStruct\n-\n-from ctypes import c_uint64, c_uint32, sizeof\n+from strongarm.macho.arch_independent_structs import (\n+    ArchIndependentStructure,\n+    MachoHeaderStruct,\n+    MachoSegmentCommandStruct,\n+    MachoSectionRawStruct,\n+    MachoEncryptionInfoStruct,\n+    MachoNlistStruct,\n+    CFStringStruct,\n+    DylibCommandStruct,\n+    MachoLoadCommandStruct,\n+    MachoSymtabCommandStruct,\n+    MachoDysymtabCommandStruct,\n+    MachoDyldInfoCommandStruct,\n+    MachoLinkeditDataCommandStruct,\n+)\n+\n+if TYPE_CHECKING:\n+    from strongarm.macho.codesign import CodesignParser\n \n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent": "from strongarm.macho.macho_load_commands import MachoLoadCommands\nfrom strongarm.macho.arch_independent_structs import (\n    ArchIndependentStructure,\n    MachoHeaderStruct,\n    MachoSegmentCommandStruct,\n    MachoSectionRawStruct,\n    MachoEncryptionInfoStruct,\n    MachoNlistStruct,\n    CFStringStruct,\n    DylibCommandStruct,\n    MachoLoadCommandStruct,\n    MachoSymtabCommandStruct,\n    MachoDysymtabCommandStruct,\n    MachoDyldInfoCommandStruct,\n    MachoLinkeditDataCommandStruct,\n)\n\nif TYPE_CHECKING:\n    <IND>from strongarm.macho.codesign import CodesignParser\n\n",
        "target_code_with_indent_exact_match": true,
        "source_code_with_indent": "from strongarm.macho.macho_load_commands import MachoLoadCommands\nfrom strongarm.macho.arch_independent_structs import    MachoHeaderStruct,    MachoSegmentCommandStruct,    MachoSectionRawStruct,    MachoEncryptionInfoStruct,    MachoNlistStruct,    CFStringStruct,    DylibCommandStruct,    MachoLoadCommandStruct,    MachoSymtabCommandStruct,    MachoDysymtabCommandStruct,    MachoDyldInfoCommandStruct,    MachoLinkeditDataCommandStruct\n\nfrom ctypes import c_uint64, c_uint32, sizeof\n\n"
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "        # generic Mach-O header info\n        self.is_64bit: bool = None\n        self.is_swap: bool = None\n        self.cpu_type: CPU_TYPE = None\n        self._load_commands_end_addr = None\n\n        # Mach-O header data\n        self.header: MachoHeaderStruct = None\n        self.header_flags: List[int] = None\n        self.file_type: MachoFileType = None\n\n        # segment and section commands from Mach-O header\n        self.segment_commands: Dict[str, MachoSegmentCommandStruct] = None\n        self.sections: Dict[str, MachoSection] = None\n        # also store specific interesting sections which are useful to us\n        self.dysymtab: MachoDysymtabCommandStruct = None\n        self.symtab: MachoSymtabCommandStruct = None\n        self.encryption_info: MachoEncryptionInfoStruct = None\n        self.dyld_info: MachoDyldInfoCommandStruct = None\n        self.load_dylib_commands: List[DylibCommandStruct] = None\n        self.code_signature_cmd: MachoLinkeditDataCommandStruct = None\n\n        self.__codesign_parser: CodesignParser = None\n\n",
        "source_code_len": 1040,
        "target_code": "        # generic Mach-O header info\n        self.is_64bit: bool = False\n        self.is_swap: bool = False\n        self.cpu_type: CPU_TYPE = CPU_TYPE.UNKNOWN\n        self._load_commands_end_addr = 0\n\n        # Mach-O header data\n        self._header: Optional[MachoHeaderStruct] = None\n        self.header_flags: List[int] = []\n        self.file_type: MachoFileType = MachoFileType.MH_EXECUTE\n\n        # segment and section commands from Mach-O header\n        self.segment_commands: Dict[str, MachoSegmentCommandStruct] = {}\n        self.sections: Dict[str, MachoSection] = {}\n        # also store specific interesting sections which are useful to us\n        self._dysymtab: Optional[MachoDysymtabCommandStruct] = None\n        self._symtab: Optional[MachoSymtabCommandStruct] = None\n        self._encryption_info: Optional[MachoEncryptionInfoStruct] = None\n        self._dyld_info: Optional[MachoDyldInfoCommandStruct] = None\n        self.load_dylib_commands: List[DylibCommandStruct] = []\n        self._code_signature_cmd: Optional[MachoLinkeditDataCommandStruct] = None\n\n        self.__codesign_parser: Optional[CodesignParser] = None\n\n",
        "target_code_len": 1139,
        "diff_format": "@@ -62,24 +68,24 @@\n         # generic Mach-O header info\n-        self.is_64bit: bool = None\n-        self.is_swap: bool = None\n-        self.cpu_type: CPU_TYPE = None\n-        self._load_commands_end_addr = None\n+        self.is_64bit: bool = False\n+        self.is_swap: bool = False\n+        self.cpu_type: CPU_TYPE = CPU_TYPE.UNKNOWN\n+        self._load_commands_end_addr = 0\n \n         # Mach-O header data\n-        self.header: MachoHeaderStruct = None\n-        self.header_flags: List[int] = None\n-        self.file_type: MachoFileType = None\n+        self._header: Optional[MachoHeaderStruct] = None\n+        self.header_flags: List[int] = []\n+        self.file_type: MachoFileType = MachoFileType.MH_EXECUTE\n \n         # segment and section commands from Mach-O header\n-        self.segment_commands: Dict[str, MachoSegmentCommandStruct] = None\n-        self.sections: Dict[str, MachoSection] = None\n+        self.segment_commands: Dict[str, MachoSegmentCommandStruct] = {}\n+        self.sections: Dict[str, MachoSection] = {}\n         # also store specific interesting sections which are useful to us\n-        self.dysymtab: MachoDysymtabCommandStruct = None\n-        self.symtab: MachoSymtabCommandStruct = None\n-        self.encryption_info: MachoEncryptionInfoStruct = None\n-        self.dyld_info: MachoDyldInfoCommandStruct = None\n-        self.load_dylib_commands: List[DylibCommandStruct] = None\n-        self.code_signature_cmd: MachoLinkeditDataCommandStruct = None\n-\n-        self.__codesign_parser: CodesignParser = None\n+        self._dysymtab: Optional[MachoDysymtabCommandStruct] = None\n+        self._symtab: Optional[MachoSymtabCommandStruct] = None\n+        self._encryption_info: Optional[MachoEncryptionInfoStruct] = None\n+        self._dyld_info: Optional[MachoDyldInfoCommandStruct] = None\n+        self.load_dylib_commands: List[DylibCommandStruct] = []\n+        self._code_signature_cmd: Optional[MachoLinkeditDataCommandStruct] = None\n+\n+        self.__codesign_parser: Optional[CodesignParser] = None\n \n",
        "source_code_with_indent": "        # generic Mach-O header info\n        self.is_64bit: bool = None\n        self.is_swap: bool = None\n        self.cpu_type: CPU_TYPE = None\n        self._load_commands_end_addr = None\n\n        # Mach-O header data\n        self.header: MachoHeaderStruct = None\n        self.header_flags: List[int] = None\n        self.file_type: MachoFileType = None\n\n        # segment and section commands from Mach-O header\n        self.segment_commands: Dict[str, MachoSegmentCommandStruct] = None\n        self.sections: Dict[str, MachoSection] = None\n        # also store specific interesting sections which are useful to us\n        self.dysymtab: MachoDysymtabCommandStruct = None\n        self.symtab: MachoSymtabCommandStruct = None\n        self.encryption_info: MachoEncryptionInfoStruct = None\n        self.dyld_info: MachoDyldInfoCommandStruct = None\n        self.load_dylib_commands: List[DylibCommandStruct] = None\n        self.code_signature_cmd: MachoLinkeditDataCommandStruct = None\n\n        self.__codesign_parser: CodesignParser = None\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "        # generic Mach-O header info\n        self.is_64bit: bool = False\n        self.is_swap: bool = False\n        self.cpu_type: CPU_TYPE = CPU_TYPE.UNKNOWN\n        self._load_commands_end_addr = 0\n\n        # Mach-O header data\n        self._header: Optional[MachoHeaderStruct] = None\n        self.header_flags: List[int] = []\n        self.file_type: MachoFileType = MachoFileType.MH_EXECUTE\n\n        # segment and section commands from Mach-O header\n        self.segment_commands: Dict[str, MachoSegmentCommandStruct] = {}\n        self.sections: Dict[str, MachoSection] = {}\n        # also store specific interesting sections which are useful to us\n        self._dysymtab: Optional[MachoDysymtabCommandStruct] = None\n        self._symtab: Optional[MachoSymtabCommandStruct] = None\n        self._encryption_info: Optional[MachoEncryptionInfoStruct] = None\n        self._dyld_info: Optional[MachoDyldInfoCommandStruct] = None\n        self.load_dylib_commands: List[DylibCommandStruct] = []\n        self._code_signature_cmd: Optional[MachoLinkeditDataCommandStruct] = None\n\n        self.__codesign_parser: Optional[CodesignParser] = None\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    @property\n    def slice_magic(self) -> c_uint32:\n        \"\"\"Read magic number identifier from this Mach-O slice\n        \"\"\"\n        return self.read_word(0, virtual=False, word_type=c_uint32)\n\n",
        "source_code_len": 197,
        "target_code": "    @property\n    def slice_magic(self) -> int:\n        \"\"\"Read magic number identifier from this Mach-O slice\n        \"\"\"\n        magic = self.read_word(0, virtual=False, word_type=c_uint32)\n        if magic:\n            return magic\n        else:\n            raise ValueError('Could not read magic value.')\n\n",
        "target_code_len": 310,
        "diff_format": "@@ -124,6 +131,10 @@\n     @property\n-    def slice_magic(self) -> c_uint32:\n+    def slice_magic(self) -> int:\n         \"\"\"Read magic number identifier from this Mach-O slice\n         \"\"\"\n-        return self.read_word(0, virtual=False, word_type=c_uint32)\n+        magic = self.read_word(0, virtual=False, word_type=c_uint32)\n+        if magic:\n+            return magic\n+        else:\n+            raise ValueError('Could not read magic value.')\n \n",
        "source_code_with_indent": "    <DED>@property\n    def slice_magic(self) -> c_uint32:\n        <IND>\"\"\"Read magic number identifier from this Mach-O slice\n        \"\"\"\n        return self.read_word(0, virtual=False, word_type=c_uint32)\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    <DED>@property\n    def slice_magic(self) -> int:\n        <IND>\"\"\"Read magic number identifier from this Mach-O slice\n        \"\"\"\n        magic = self.read_word(0, virtual=False, word_type=c_uint32)\n        if magic:\n            <IND>return magic\n        <DED>else:\n            <IND>raise ValueError('Could not read magic value.')\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "        \"\"\"\n        self.header = MachoHeaderStruct(self, 0)\n\n",
        "source_code_len": 62,
        "target_code": "        \"\"\"\n        self._header = MachoHeaderStruct(self, 0)\n\n",
        "target_code_len": 63,
        "diff_format": "@@ -152,3 +163,3 @@\n         \"\"\"\n-        self.header = MachoHeaderStruct(self, 0)\n+        self._header = MachoHeaderStruct(self, 0)\n \n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\n        self.header = MachoHeaderStruct(self, 0)\n\n",
        "target_code_with_indent": "\n        self._header = MachoHeaderStruct(self, 0)\n\n"
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "                                      MachoLoadCommands.LC_ENCRYPTION_INFO_64]:\n                self.encryption_info = MachoEncryptionInfoStruct(self, offset)\n\n            elif load_command.cmd == MachoLoadCommands.LC_SYMTAB:\n                self.symtab = MachoSymtabCommandStruct(self, offset)\n\n            elif load_command.cmd == MachoLoadCommands.LC_DYSYMTAB:\n                self.dysymtab = MachoDysymtabCommandStruct(self, offset)\n\n            elif load_command.cmd in [MachoLoadCommands.LC_DYLD_INFO, MachoLoadCommands.LC_DYLD_INFO_ONLY]:\n                self.dyld_info = MachoDyldInfoCommandStruct(self, offset)\n\n",
        "source_code_len": 621,
        "target_code": "                                      MachoLoadCommands.LC_ENCRYPTION_INFO_64]:\n                self._encryption_info = MachoEncryptionInfoStruct(self, offset)\n\n            elif load_command.cmd == MachoLoadCommands.LC_SYMTAB:\n                self._symtab = MachoSymtabCommandStruct(self, offset)\n\n            elif load_command.cmd == MachoLoadCommands.LC_DYSYMTAB:\n                self._dysymtab = MachoDysymtabCommandStruct(self, offset)\n\n            elif load_command.cmd in [MachoLoadCommands.LC_DYLD_INFO, MachoLoadCommands.LC_DYLD_INFO_ONLY]:\n                self._dyld_info = MachoDyldInfoCommandStruct(self, offset)\n\n",
        "target_code_len": 625,
        "diff_format": "@@ -208,12 +220,12 @@\n                                       MachoLoadCommands.LC_ENCRYPTION_INFO_64]:\n-                self.encryption_info = MachoEncryptionInfoStruct(self, offset)\n+                self._encryption_info = MachoEncryptionInfoStruct(self, offset)\n \n             elif load_command.cmd == MachoLoadCommands.LC_SYMTAB:\n-                self.symtab = MachoSymtabCommandStruct(self, offset)\n+                self._symtab = MachoSymtabCommandStruct(self, offset)\n \n             elif load_command.cmd == MachoLoadCommands.LC_DYSYMTAB:\n-                self.dysymtab = MachoDysymtabCommandStruct(self, offset)\n+                self._dysymtab = MachoDysymtabCommandStruct(self, offset)\n \n             elif load_command.cmd in [MachoLoadCommands.LC_DYLD_INFO, MachoLoadCommands.LC_DYLD_INFO_ONLY]:\n-                self.dyld_info = MachoDyldInfoCommandStruct(self, offset)\n+                self._dyld_info = MachoDyldInfoCommandStruct(self, offset)\n \n",
        "source_code_with_indent": "                                      MachoLoadCommands.LC_ENCRYPTION_INFO_64]:\n                <IND>self.encryption_info = MachoEncryptionInfoStruct(self, offset)\n\n            <DED>elif load_command.cmd == MachoLoadCommands.LC_SYMTAB:\n                <IND>self.symtab = MachoSymtabCommandStruct(self, offset)\n\n            <DED>elif load_command.cmd == MachoLoadCommands.LC_DYSYMTAB:\n                <IND>self.dysymtab = MachoDysymtabCommandStruct(self, offset)\n\n            <DED>elif load_command.cmd in [MachoLoadCommands.LC_DYLD_INFO, MachoLoadCommands.LC_DYLD_INFO_ONLY]:\n                <IND>self.dyld_info = MachoDyldInfoCommandStruct(self, offset)\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "                                      MachoLoadCommands.LC_ENCRYPTION_INFO_64]:\n                <IND>self._encryption_info = MachoEncryptionInfoStruct(self, offset)\n\n            <DED>elif load_command.cmd == MachoLoadCommands.LC_SYMTAB:\n                <IND>self._symtab = MachoSymtabCommandStruct(self, offset)\n\n            <DED>elif load_command.cmd == MachoLoadCommands.LC_DYSYMTAB:\n                <IND>self._dysymtab = MachoDysymtabCommandStruct(self, offset)\n\n            <DED>elif load_command.cmd in [MachoLoadCommands.LC_DYLD_INFO, MachoLoadCommands.LC_DYLD_INFO_ONLY]:\n                <IND>self._dyld_info = MachoDyldInfoCommandStruct(self, offset)\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "            elif load_command.cmd == MachoLoadCommands.LC_CODE_SIGNATURE:\n                self.code_signature_cmd = MachoLinkeditDataCommandStruct(self, offset)\n\n",
        "source_code_len": 162,
        "target_code": "            elif load_command.cmd == MachoLoadCommands.LC_CODE_SIGNATURE:\n                self._code_signature_cmd = MachoLinkeditDataCommandStruct(self, offset)\n\n",
        "target_code_len": 163,
        "diff_format": "@@ -225,3 +236,3 @@\n             elif load_command.cmd == MachoLoadCommands.LC_CODE_SIGNATURE:\n-                self.code_signature_cmd = MachoLinkeditDataCommandStruct(self, offset)\n+                self._code_signature_cmd = MachoLinkeditDataCommandStruct(self, offset)\n \n",
        "source_code_with_indent": "            <DED>elif load_command.cmd == MachoLoadCommands.LC_CODE_SIGNATURE:\n                <IND>self.code_signature_cmd = MachoLinkeditDataCommandStruct(self, offset)\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "            <DED>elif load_command.cmd == MachoLoadCommands.LC_CODE_SIGNATURE:\n                <IND>self._code_signature_cmd = MachoLinkeditDataCommandStruct(self, offset)\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "            indirect_symtab_entry = self.read_word(indirect_symtab_off, virtual=False, word_type=c_uint32)\n            indirect_symtab.append(int(indirect_symtab_entry.value))\n            # traverse to next pointer\n",
        "source_code_len": 215,
        "target_code": "            indirect_symtab_entry = self.read_word(indirect_symtab_off, virtual=False, word_type=c_uint32)\n            if not indirect_symtab_entry:\n                continue\n            indirect_symtab.append(int(indirect_symtab_entry))\n            # traverse to next pointer\n",
        "target_code_len": 276,
        "diff_format": "@@ -398,3 +410,5 @@\n             indirect_symtab_entry = self.read_word(indirect_symtab_off, virtual=False, word_type=c_uint32)\n-            indirect_symtab.append(int(indirect_symtab_entry.value))\n+            if not indirect_symtab_entry:\n+                continue\n+            indirect_symtab.append(int(indirect_symtab_entry))\n             # traverse to next pointer\n",
        "source_code_with_indent": "            <IND>indirect_symtab_entry = self.read_word(indirect_symtab_off, virtual=False, word_type=c_uint32)\n            indirect_symtab.append(int(indirect_symtab_entry.value))\n            # traverse to next pointer\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "            <IND>indirect_symtab_entry = self.read_word(indirect_symtab_off, virtual=False, word_type=c_uint32)\n            if not indirect_symtab_entry:\n                <IND>continue\n            <DED>indirect_symtab.append(int(indirect_symtab_entry))\n            # traverse to next pointer\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "                  address: int,\n                  virtual=True,\n                  word_type=None) -> Optional[Union[c_uint32, c_uint64]]:\n        \"\"\"Attempt to read a word from the binary at a virtual address. Returns None if the address is invalid.\n",
        "source_code_len": 250,
        "target_code": "                  address: int,\n                  virtual: bool = True,\n                  word_type: Any = None) -> Optional[int]:\n        \"\"\"Attempt to read a word from the binary at a virtual address. Returns None if the address is invalid.\n",
        "target_code_len": 243,
        "diff_format": "@@ -568,4 +595,4 @@\n                   address: int,\n-                  virtual=True,\n-                  word_type=None) -> Optional[Union[c_uint32, c_uint64]]:\n+                  virtual: bool = True,\n+                  word_type: Any = None) -> Optional[int]:\n         \"\"\"Attempt to read a word from the binary at a virtual address. Returns None if the address is invalid.\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "                  address: int,\n                  virtual=True,\n                  word_type=None) -> Optional[Union[c_uint32, c_uint64]]:\n        <IND>",
        "target_code_with_indent": "                  address: int,\n                  virtual: bool = True,\n                  word_type: Any = None) -> Optional[int]:\n        <IND>"
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    @property\n    def _codesign_parser(self) -> 'CodesignParser':\n        from strongarm.macho.codesign import CodesignParser\n        if not self.__codesign_parser:\n",
        "source_code_len": 165,
        "target_code": "    @property\n    def header(self) -> MachoHeaderStruct:\n        if self._header:\n            return self._header\n        else:\n            raise RuntimeError('Failed to parse Mach-O')\n\n    @property\n    def dysymtab(self) -> MachoDysymtabCommandStruct:\n        if self._dysymtab:\n            return self._dysymtab\n        else:\n            raise RuntimeError('Failed to parse Mach-O')\n\n    @property\n    def symtab(self) -> MachoSymtabCommandStruct:\n        if self._symtab:\n            return self._symtab\n        else:\n            raise RuntimeError('Failed to parse Mach-O')\n\n    @property\n    def encryption_info(self) -> MachoEncryptionInfoStruct:\n        if self._encryption_info:\n            return self._encryption_info\n        else:\n            raise RuntimeError('Failed to parse Mach-O')\n\n    @property\n    def dyld_info(self) -> MachoDyldInfoCommandStruct:\n        if self._dyld_info:\n            return self._dyld_info\n        else:\n            raise RuntimeError('Failed to parse Mach-O')\n\n    @property\n    def code_signature_cmd(self) -> MachoLinkeditDataCommandStruct:\n        if self._code_signature_cmd:\n            return self._code_signature_cmd\n        else:\n            raise RuntimeError('Failed to parse Mach-O')\n\n    @property\n    def _codesign_parser(self) -> 'CodesignParser':\n        if not self.__codesign_parser:\n",
        "target_code_len": 1345,
        "diff_format": "@@ -583,4 +613,45 @@\n     @property\n+    def header(self) -> MachoHeaderStruct:\n+        if self._header:\n+            return self._header\n+        else:\n+            raise RuntimeError('Failed to parse Mach-O')\n+\n+    @property\n+    def dysymtab(self) -> MachoDysymtabCommandStruct:\n+        if self._dysymtab:\n+            return self._dysymtab\n+        else:\n+            raise RuntimeError('Failed to parse Mach-O')\n+\n+    @property\n+    def symtab(self) -> MachoSymtabCommandStruct:\n+        if self._symtab:\n+            return self._symtab\n+        else:\n+            raise RuntimeError('Failed to parse Mach-O')\n+\n+    @property\n+    def encryption_info(self) -> MachoEncryptionInfoStruct:\n+        if self._encryption_info:\n+            return self._encryption_info\n+        else:\n+            raise RuntimeError('Failed to parse Mach-O')\n+\n+    @property\n+    def dyld_info(self) -> MachoDyldInfoCommandStruct:\n+        if self._dyld_info:\n+            return self._dyld_info\n+        else:\n+            raise RuntimeError('Failed to parse Mach-O')\n+\n+    @property\n+    def code_signature_cmd(self) -> MachoLinkeditDataCommandStruct:\n+        if self._code_signature_cmd:\n+            return self._code_signature_cmd\n+        else:\n+            raise RuntimeError('Failed to parse Mach-O')\n+\n+    @property\n     def _codesign_parser(self) -> 'CodesignParser':\n-        from strongarm.macho.codesign import CodesignParser\n         if not self.__codesign_parser:\n",
        "source_code_with_indent": "    <DED>@property\n    def _codesign_parser(self) -> 'CodesignParser':\n        <IND>from strongarm.macho.codesign import CodesignParser\n        if not self.__codesign_parser:\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    <DED>@property\n    def header(self) -> MachoHeaderStruct:\n        <IND>if self._header:\n            <IND>return self._header\n        <DED>else:\n            <IND>raise RuntimeError('Failed to parse Mach-O')\n\n    <DED><DED>@property\n    def dysymtab(self) -> MachoDysymtabCommandStruct:\n        <IND>if self._dysymtab:\n            <IND>return self._dysymtab\n        <DED>else:\n            <IND>raise RuntimeError('Failed to parse Mach-O')\n\n    <DED><DED>@property\n    def symtab(self) -> MachoSymtabCommandStruct:\n        <IND>if self._symtab:\n            <IND>return self._symtab\n        <DED>else:\n            <IND>raise RuntimeError('Failed to parse Mach-O')\n\n    <DED><DED>@property\n    def encryption_info(self) -> MachoEncryptionInfoStruct:\n        <IND>if self._encryption_info:\n            <IND>return self._encryption_info\n        <DED>else:\n            <IND>raise RuntimeError('Failed to parse Mach-O')\n\n    <DED><DED>@property\n    def dyld_info(self) -> MachoDyldInfoCommandStruct:\n        <IND>if self._dyld_info:\n            <IND>return self._dyld_info\n        <DED>else:\n            <IND>raise RuntimeError('Failed to parse Mach-O')\n\n    <DED><DED>@property\n    def code_signature_cmd(self) -> MachoLinkeditDataCommandStruct:\n        <IND>if self._code_signature_cmd:\n            <IND>return self._code_signature_cmd\n        <DED>else:\n            <IND>raise RuntimeError('Failed to parse Mach-O')\n\n    <DED><DED>@property\n    def _codesign_parser(self) -> 'CodesignParser':\n        <IND>if not self.__codesign_parser:\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "datatheorem/strongarm",
    "commit": "ab620d78b4ce7f933cedc25960307f2c3b03c1a8",
    "filename": "strongarm/macho/macho_binary.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/datatheorem-strongarm/strongarm/macho/macho_binary.py",
    "file_hunks_size": 33,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "strongarm/macho/macho_binary.py:82:8 Incompatible attribute type [8]: Attribute `code_signature_cmd` declared in class `MachoBinary` has type `MachoLinkeditDataCommandStruct` but is used as type `None`.",
    "message": " Attribute `code_signature_cmd` declared in class `MachoBinary` has type `MachoLinkeditDataCommandStruct` but is used as type `None`.",
    "rule_id": "Incompatible attribute type [8]",
    "warning_line_no": 82,
    "warning_line": "        self.code_signature_cmd: MachoLinkeditDataCommandStruct = None",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "# -*- coding: utf-8 -*-\nfrom typing import List, Tuple, Optional, Dict, Union\n\n",
        "source_code_len": 79,
        "target_code": "# -*- coding: utf-8 -*-\nfrom typing import List, Dict, Tuple, Any, Type, Optional\nfrom typing import TYPE_CHECKING\n\nfrom ctypes import c_uint64, c_uint32, sizeof\n\n",
        "target_code_len": 163,
        "diff_format": "@@ -1,3 +1,6 @@\n # -*- coding: utf-8 -*-\n-from typing import List, Tuple, Optional, Dict, Union\n+from typing import List, Dict, Tuple, Any, Type, Optional\n+from typing import TYPE_CHECKING\n+\n+from ctypes import c_uint64, c_uint32, sizeof\n \n",
        "source_code_with_indent": "# -*- coding: utf-8 -*-\nfrom typing import List, Tuple, Optional, Dict, Union\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "# -*- coding: utf-8 -*-\nfrom typing import List, Dict, Tuple, Any, Type, Optional\nfrom typing import TYPE_CHECKING\n\nfrom ctypes import c_uint64, c_uint32, sizeof\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "from strongarm.macho.macho_load_commands import MachoLoadCommands\nfrom strongarm.macho.arch_independent_structs import \\\n    MachoHeaderStruct, \\\n    MachoSegmentCommandStruct, \\\n    MachoSectionRawStruct, \\\n    MachoEncryptionInfoStruct, \\\n    MachoNlistStruct, \\\n    CFStringStruct, \\\n    DylibCommandStruct, \\\n    MachoLoadCommandStruct, \\\n    MachoSymtabCommandStruct, \\\n    MachoDysymtabCommandStruct, \\\n    MachoDyldInfoCommandStruct, \\\n    MachoLinkeditDataCommandStruct\n\nfrom ctypes import c_uint64, c_uint32, sizeof\n\n",
        "source_code_len": 526,
        "target_code": "from strongarm.macho.macho_load_commands import MachoLoadCommands\nfrom strongarm.macho.arch_independent_structs import (\n    ArchIndependentStructure,\n    MachoHeaderStruct,\n    MachoSegmentCommandStruct,\n    MachoSectionRawStruct,\n    MachoEncryptionInfoStruct,\n    MachoNlistStruct,\n    CFStringStruct,\n    DylibCommandStruct,\n    MachoLoadCommandStruct,\n    MachoSymtabCommandStruct,\n    MachoDysymtabCommandStruct,\n    MachoDyldInfoCommandStruct,\n    MachoLinkeditDataCommandStruct,\n)\n\nif TYPE_CHECKING:\n    from strongarm.macho.codesign import CodesignParser\n\n",
        "target_code_len": 565,
        "diff_format": "@@ -7,17 +10,20 @@\n from strongarm.macho.macho_load_commands import MachoLoadCommands\n-from strongarm.macho.arch_independent_structs import \\\n-    MachoHeaderStruct, \\\n-    MachoSegmentCommandStruct, \\\n-    MachoSectionRawStruct, \\\n-    MachoEncryptionInfoStruct, \\\n-    MachoNlistStruct, \\\n-    CFStringStruct, \\\n-    DylibCommandStruct, \\\n-    MachoLoadCommandStruct, \\\n-    MachoSymtabCommandStruct, \\\n-    MachoDysymtabCommandStruct, \\\n-    MachoDyldInfoCommandStruct, \\\n-    MachoLinkeditDataCommandStruct\n-\n-from ctypes import c_uint64, c_uint32, sizeof\n+from strongarm.macho.arch_independent_structs import (\n+    ArchIndependentStructure,\n+    MachoHeaderStruct,\n+    MachoSegmentCommandStruct,\n+    MachoSectionRawStruct,\n+    MachoEncryptionInfoStruct,\n+    MachoNlistStruct,\n+    CFStringStruct,\n+    DylibCommandStruct,\n+    MachoLoadCommandStruct,\n+    MachoSymtabCommandStruct,\n+    MachoDysymtabCommandStruct,\n+    MachoDyldInfoCommandStruct,\n+    MachoLinkeditDataCommandStruct,\n+)\n+\n+if TYPE_CHECKING:\n+    from strongarm.macho.codesign import CodesignParser\n \n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent": "from strongarm.macho.macho_load_commands import MachoLoadCommands\nfrom strongarm.macho.arch_independent_structs import (\n    ArchIndependentStructure,\n    MachoHeaderStruct,\n    MachoSegmentCommandStruct,\n    MachoSectionRawStruct,\n    MachoEncryptionInfoStruct,\n    MachoNlistStruct,\n    CFStringStruct,\n    DylibCommandStruct,\n    MachoLoadCommandStruct,\n    MachoSymtabCommandStruct,\n    MachoDysymtabCommandStruct,\n    MachoDyldInfoCommandStruct,\n    MachoLinkeditDataCommandStruct,\n)\n\nif TYPE_CHECKING:\n    <IND>from strongarm.macho.codesign import CodesignParser\n\n",
        "target_code_with_indent_exact_match": true,
        "source_code_with_indent": "from strongarm.macho.macho_load_commands import MachoLoadCommands\nfrom strongarm.macho.arch_independent_structs import    MachoHeaderStruct,    MachoSegmentCommandStruct,    MachoSectionRawStruct,    MachoEncryptionInfoStruct,    MachoNlistStruct,    CFStringStruct,    DylibCommandStruct,    MachoLoadCommandStruct,    MachoSymtabCommandStruct,    MachoDysymtabCommandStruct,    MachoDyldInfoCommandStruct,    MachoLinkeditDataCommandStruct\n\nfrom ctypes import c_uint64, c_uint32, sizeof\n\n"
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "        # generic Mach-O header info\n        self.is_64bit: bool = None\n        self.is_swap: bool = None\n        self.cpu_type: CPU_TYPE = None\n        self._load_commands_end_addr = None\n\n        # Mach-O header data\n        self.header: MachoHeaderStruct = None\n        self.header_flags: List[int] = None\n        self.file_type: MachoFileType = None\n\n        # segment and section commands from Mach-O header\n        self.segment_commands: Dict[str, MachoSegmentCommandStruct] = None\n        self.sections: Dict[str, MachoSection] = None\n        # also store specific interesting sections which are useful to us\n        self.dysymtab: MachoDysymtabCommandStruct = None\n        self.symtab: MachoSymtabCommandStruct = None\n        self.encryption_info: MachoEncryptionInfoStruct = None\n        self.dyld_info: MachoDyldInfoCommandStruct = None\n        self.load_dylib_commands: List[DylibCommandStruct] = None\n        self.code_signature_cmd: MachoLinkeditDataCommandStruct = None\n\n        self.__codesign_parser: CodesignParser = None\n\n",
        "source_code_len": 1040,
        "target_code": "        # generic Mach-O header info\n        self.is_64bit: bool = False\n        self.is_swap: bool = False\n        self.cpu_type: CPU_TYPE = CPU_TYPE.UNKNOWN\n        self._load_commands_end_addr = 0\n\n        # Mach-O header data\n        self._header: Optional[MachoHeaderStruct] = None\n        self.header_flags: List[int] = []\n        self.file_type: MachoFileType = MachoFileType.MH_EXECUTE\n\n        # segment and section commands from Mach-O header\n        self.segment_commands: Dict[str, MachoSegmentCommandStruct] = {}\n        self.sections: Dict[str, MachoSection] = {}\n        # also store specific interesting sections which are useful to us\n        self._dysymtab: Optional[MachoDysymtabCommandStruct] = None\n        self._symtab: Optional[MachoSymtabCommandStruct] = None\n        self._encryption_info: Optional[MachoEncryptionInfoStruct] = None\n        self._dyld_info: Optional[MachoDyldInfoCommandStruct] = None\n        self.load_dylib_commands: List[DylibCommandStruct] = []\n        self._code_signature_cmd: Optional[MachoLinkeditDataCommandStruct] = None\n\n        self.__codesign_parser: Optional[CodesignParser] = None\n\n",
        "target_code_len": 1139,
        "diff_format": "@@ -62,24 +68,24 @@\n         # generic Mach-O header info\n-        self.is_64bit: bool = None\n-        self.is_swap: bool = None\n-        self.cpu_type: CPU_TYPE = None\n-        self._load_commands_end_addr = None\n+        self.is_64bit: bool = False\n+        self.is_swap: bool = False\n+        self.cpu_type: CPU_TYPE = CPU_TYPE.UNKNOWN\n+        self._load_commands_end_addr = 0\n \n         # Mach-O header data\n-        self.header: MachoHeaderStruct = None\n-        self.header_flags: List[int] = None\n-        self.file_type: MachoFileType = None\n+        self._header: Optional[MachoHeaderStruct] = None\n+        self.header_flags: List[int] = []\n+        self.file_type: MachoFileType = MachoFileType.MH_EXECUTE\n \n         # segment and section commands from Mach-O header\n-        self.segment_commands: Dict[str, MachoSegmentCommandStruct] = None\n-        self.sections: Dict[str, MachoSection] = None\n+        self.segment_commands: Dict[str, MachoSegmentCommandStruct] = {}\n+        self.sections: Dict[str, MachoSection] = {}\n         # also store specific interesting sections which are useful to us\n-        self.dysymtab: MachoDysymtabCommandStruct = None\n-        self.symtab: MachoSymtabCommandStruct = None\n-        self.encryption_info: MachoEncryptionInfoStruct = None\n-        self.dyld_info: MachoDyldInfoCommandStruct = None\n-        self.load_dylib_commands: List[DylibCommandStruct] = None\n-        self.code_signature_cmd: MachoLinkeditDataCommandStruct = None\n-\n-        self.__codesign_parser: CodesignParser = None\n+        self._dysymtab: Optional[MachoDysymtabCommandStruct] = None\n+        self._symtab: Optional[MachoSymtabCommandStruct] = None\n+        self._encryption_info: Optional[MachoEncryptionInfoStruct] = None\n+        self._dyld_info: Optional[MachoDyldInfoCommandStruct] = None\n+        self.load_dylib_commands: List[DylibCommandStruct] = []\n+        self._code_signature_cmd: Optional[MachoLinkeditDataCommandStruct] = None\n+\n+        self.__codesign_parser: Optional[CodesignParser] = None\n \n",
        "source_code_with_indent": "        # generic Mach-O header info\n        self.is_64bit: bool = None\n        self.is_swap: bool = None\n        self.cpu_type: CPU_TYPE = None\n        self._load_commands_end_addr = None\n\n        # Mach-O header data\n        self.header: MachoHeaderStruct = None\n        self.header_flags: List[int] = None\n        self.file_type: MachoFileType = None\n\n        # segment and section commands from Mach-O header\n        self.segment_commands: Dict[str, MachoSegmentCommandStruct] = None\n        self.sections: Dict[str, MachoSection] = None\n        # also store specific interesting sections which are useful to us\n        self.dysymtab: MachoDysymtabCommandStruct = None\n        self.symtab: MachoSymtabCommandStruct = None\n        self.encryption_info: MachoEncryptionInfoStruct = None\n        self.dyld_info: MachoDyldInfoCommandStruct = None\n        self.load_dylib_commands: List[DylibCommandStruct] = None\n        self.code_signature_cmd: MachoLinkeditDataCommandStruct = None\n\n        self.__codesign_parser: CodesignParser = None\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "        # generic Mach-O header info\n        self.is_64bit: bool = False\n        self.is_swap: bool = False\n        self.cpu_type: CPU_TYPE = CPU_TYPE.UNKNOWN\n        self._load_commands_end_addr = 0\n\n        # Mach-O header data\n        self._header: Optional[MachoHeaderStruct] = None\n        self.header_flags: List[int] = []\n        self.file_type: MachoFileType = MachoFileType.MH_EXECUTE\n\n        # segment and section commands from Mach-O header\n        self.segment_commands: Dict[str, MachoSegmentCommandStruct] = {}\n        self.sections: Dict[str, MachoSection] = {}\n        # also store specific interesting sections which are useful to us\n        self._dysymtab: Optional[MachoDysymtabCommandStruct] = None\n        self._symtab: Optional[MachoSymtabCommandStruct] = None\n        self._encryption_info: Optional[MachoEncryptionInfoStruct] = None\n        self._dyld_info: Optional[MachoDyldInfoCommandStruct] = None\n        self.load_dylib_commands: List[DylibCommandStruct] = []\n        self._code_signature_cmd: Optional[MachoLinkeditDataCommandStruct] = None\n\n        self.__codesign_parser: Optional[CodesignParser] = None\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    @property\n    def slice_magic(self) -> c_uint32:\n        \"\"\"Read magic number identifier from this Mach-O slice\n        \"\"\"\n        return self.read_word(0, virtual=False, word_type=c_uint32)\n\n",
        "source_code_len": 197,
        "target_code": "    @property\n    def slice_magic(self) -> int:\n        \"\"\"Read magic number identifier from this Mach-O slice\n        \"\"\"\n        magic = self.read_word(0, virtual=False, word_type=c_uint32)\n        if magic:\n            return magic\n        else:\n            raise ValueError('Could not read magic value.')\n\n",
        "target_code_len": 310,
        "diff_format": "@@ -124,6 +131,10 @@\n     @property\n-    def slice_magic(self) -> c_uint32:\n+    def slice_magic(self) -> int:\n         \"\"\"Read magic number identifier from this Mach-O slice\n         \"\"\"\n-        return self.read_word(0, virtual=False, word_type=c_uint32)\n+        magic = self.read_word(0, virtual=False, word_type=c_uint32)\n+        if magic:\n+            return magic\n+        else:\n+            raise ValueError('Could not read magic value.')\n \n",
        "source_code_with_indent": "    <DED>@property\n    def slice_magic(self) -> c_uint32:\n        <IND>\"\"\"Read magic number identifier from this Mach-O slice\n        \"\"\"\n        return self.read_word(0, virtual=False, word_type=c_uint32)\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    <DED>@property\n    def slice_magic(self) -> int:\n        <IND>\"\"\"Read magic number identifier from this Mach-O slice\n        \"\"\"\n        magic = self.read_word(0, virtual=False, word_type=c_uint32)\n        if magic:\n            <IND>return magic\n        <DED>else:\n            <IND>raise ValueError('Could not read magic value.')\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "        \"\"\"\n        self.header = MachoHeaderStruct(self, 0)\n\n",
        "source_code_len": 62,
        "target_code": "        \"\"\"\n        self._header = MachoHeaderStruct(self, 0)\n\n",
        "target_code_len": 63,
        "diff_format": "@@ -152,3 +163,3 @@\n         \"\"\"\n-        self.header = MachoHeaderStruct(self, 0)\n+        self._header = MachoHeaderStruct(self, 0)\n \n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\n        self.header = MachoHeaderStruct(self, 0)\n\n",
        "target_code_with_indent": "\n        self._header = MachoHeaderStruct(self, 0)\n\n"
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "                                      MachoLoadCommands.LC_ENCRYPTION_INFO_64]:\n                self.encryption_info = MachoEncryptionInfoStruct(self, offset)\n\n            elif load_command.cmd == MachoLoadCommands.LC_SYMTAB:\n                self.symtab = MachoSymtabCommandStruct(self, offset)\n\n            elif load_command.cmd == MachoLoadCommands.LC_DYSYMTAB:\n                self.dysymtab = MachoDysymtabCommandStruct(self, offset)\n\n            elif load_command.cmd in [MachoLoadCommands.LC_DYLD_INFO, MachoLoadCommands.LC_DYLD_INFO_ONLY]:\n                self.dyld_info = MachoDyldInfoCommandStruct(self, offset)\n\n",
        "source_code_len": 621,
        "target_code": "                                      MachoLoadCommands.LC_ENCRYPTION_INFO_64]:\n                self._encryption_info = MachoEncryptionInfoStruct(self, offset)\n\n            elif load_command.cmd == MachoLoadCommands.LC_SYMTAB:\n                self._symtab = MachoSymtabCommandStruct(self, offset)\n\n            elif load_command.cmd == MachoLoadCommands.LC_DYSYMTAB:\n                self._dysymtab = MachoDysymtabCommandStruct(self, offset)\n\n            elif load_command.cmd in [MachoLoadCommands.LC_DYLD_INFO, MachoLoadCommands.LC_DYLD_INFO_ONLY]:\n                self._dyld_info = MachoDyldInfoCommandStruct(self, offset)\n\n",
        "target_code_len": 625,
        "diff_format": "@@ -208,12 +220,12 @@\n                                       MachoLoadCommands.LC_ENCRYPTION_INFO_64]:\n-                self.encryption_info = MachoEncryptionInfoStruct(self, offset)\n+                self._encryption_info = MachoEncryptionInfoStruct(self, offset)\n \n             elif load_command.cmd == MachoLoadCommands.LC_SYMTAB:\n-                self.symtab = MachoSymtabCommandStruct(self, offset)\n+                self._symtab = MachoSymtabCommandStruct(self, offset)\n \n             elif load_command.cmd == MachoLoadCommands.LC_DYSYMTAB:\n-                self.dysymtab = MachoDysymtabCommandStruct(self, offset)\n+                self._dysymtab = MachoDysymtabCommandStruct(self, offset)\n \n             elif load_command.cmd in [MachoLoadCommands.LC_DYLD_INFO, MachoLoadCommands.LC_DYLD_INFO_ONLY]:\n-                self.dyld_info = MachoDyldInfoCommandStruct(self, offset)\n+                self._dyld_info = MachoDyldInfoCommandStruct(self, offset)\n \n",
        "source_code_with_indent": "                                      MachoLoadCommands.LC_ENCRYPTION_INFO_64]:\n                <IND>self.encryption_info = MachoEncryptionInfoStruct(self, offset)\n\n            <DED>elif load_command.cmd == MachoLoadCommands.LC_SYMTAB:\n                <IND>self.symtab = MachoSymtabCommandStruct(self, offset)\n\n            <DED>elif load_command.cmd == MachoLoadCommands.LC_DYSYMTAB:\n                <IND>self.dysymtab = MachoDysymtabCommandStruct(self, offset)\n\n            <DED>elif load_command.cmd in [MachoLoadCommands.LC_DYLD_INFO, MachoLoadCommands.LC_DYLD_INFO_ONLY]:\n                <IND>self.dyld_info = MachoDyldInfoCommandStruct(self, offset)\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "                                      MachoLoadCommands.LC_ENCRYPTION_INFO_64]:\n                <IND>self._encryption_info = MachoEncryptionInfoStruct(self, offset)\n\n            <DED>elif load_command.cmd == MachoLoadCommands.LC_SYMTAB:\n                <IND>self._symtab = MachoSymtabCommandStruct(self, offset)\n\n            <DED>elif load_command.cmd == MachoLoadCommands.LC_DYSYMTAB:\n                <IND>self._dysymtab = MachoDysymtabCommandStruct(self, offset)\n\n            <DED>elif load_command.cmd in [MachoLoadCommands.LC_DYLD_INFO, MachoLoadCommands.LC_DYLD_INFO_ONLY]:\n                <IND>self._dyld_info = MachoDyldInfoCommandStruct(self, offset)\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "            elif load_command.cmd == MachoLoadCommands.LC_CODE_SIGNATURE:\n                self.code_signature_cmd = MachoLinkeditDataCommandStruct(self, offset)\n\n",
        "source_code_len": 162,
        "target_code": "            elif load_command.cmd == MachoLoadCommands.LC_CODE_SIGNATURE:\n                self._code_signature_cmd = MachoLinkeditDataCommandStruct(self, offset)\n\n",
        "target_code_len": 163,
        "diff_format": "@@ -225,3 +236,3 @@\n             elif load_command.cmd == MachoLoadCommands.LC_CODE_SIGNATURE:\n-                self.code_signature_cmd = MachoLinkeditDataCommandStruct(self, offset)\n+                self._code_signature_cmd = MachoLinkeditDataCommandStruct(self, offset)\n \n",
        "source_code_with_indent": "            <DED>elif load_command.cmd == MachoLoadCommands.LC_CODE_SIGNATURE:\n                <IND>self.code_signature_cmd = MachoLinkeditDataCommandStruct(self, offset)\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "            <DED>elif load_command.cmd == MachoLoadCommands.LC_CODE_SIGNATURE:\n                <IND>self._code_signature_cmd = MachoLinkeditDataCommandStruct(self, offset)\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "            indirect_symtab_entry = self.read_word(indirect_symtab_off, virtual=False, word_type=c_uint32)\n            indirect_symtab.append(int(indirect_symtab_entry.value))\n            # traverse to next pointer\n",
        "source_code_len": 215,
        "target_code": "            indirect_symtab_entry = self.read_word(indirect_symtab_off, virtual=False, word_type=c_uint32)\n            if not indirect_symtab_entry:\n                continue\n            indirect_symtab.append(int(indirect_symtab_entry))\n            # traverse to next pointer\n",
        "target_code_len": 276,
        "diff_format": "@@ -398,3 +410,5 @@\n             indirect_symtab_entry = self.read_word(indirect_symtab_off, virtual=False, word_type=c_uint32)\n-            indirect_symtab.append(int(indirect_symtab_entry.value))\n+            if not indirect_symtab_entry:\n+                continue\n+            indirect_symtab.append(int(indirect_symtab_entry))\n             # traverse to next pointer\n",
        "source_code_with_indent": "            <IND>indirect_symtab_entry = self.read_word(indirect_symtab_off, virtual=False, word_type=c_uint32)\n            indirect_symtab.append(int(indirect_symtab_entry.value))\n            # traverse to next pointer\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "            <IND>indirect_symtab_entry = self.read_word(indirect_symtab_off, virtual=False, word_type=c_uint32)\n            if not indirect_symtab_entry:\n                <IND>continue\n            <DED>indirect_symtab.append(int(indirect_symtab_entry))\n            # traverse to next pointer\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "                  address: int,\n                  virtual=True,\n                  word_type=None) -> Optional[Union[c_uint32, c_uint64]]:\n        \"\"\"Attempt to read a word from the binary at a virtual address. Returns None if the address is invalid.\n",
        "source_code_len": 250,
        "target_code": "                  address: int,\n                  virtual: bool = True,\n                  word_type: Any = None) -> Optional[int]:\n        \"\"\"Attempt to read a word from the binary at a virtual address. Returns None if the address is invalid.\n",
        "target_code_len": 243,
        "diff_format": "@@ -568,4 +595,4 @@\n                   address: int,\n-                  virtual=True,\n-                  word_type=None) -> Optional[Union[c_uint32, c_uint64]]:\n+                  virtual: bool = True,\n+                  word_type: Any = None) -> Optional[int]:\n         \"\"\"Attempt to read a word from the binary at a virtual address. Returns None if the address is invalid.\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "                  address: int,\n                  virtual=True,\n                  word_type=None) -> Optional[Union[c_uint32, c_uint64]]:\n        <IND>",
        "target_code_with_indent": "                  address: int,\n                  virtual: bool = True,\n                  word_type: Any = None) -> Optional[int]:\n        <IND>"
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    @property\n    def _codesign_parser(self) -> 'CodesignParser':\n        from strongarm.macho.codesign import CodesignParser\n        if not self.__codesign_parser:\n",
        "source_code_len": 165,
        "target_code": "    @property\n    def header(self) -> MachoHeaderStruct:\n        if self._header:\n            return self._header\n        else:\n            raise RuntimeError('Failed to parse Mach-O')\n\n    @property\n    def dysymtab(self) -> MachoDysymtabCommandStruct:\n        if self._dysymtab:\n            return self._dysymtab\n        else:\n            raise RuntimeError('Failed to parse Mach-O')\n\n    @property\n    def symtab(self) -> MachoSymtabCommandStruct:\n        if self._symtab:\n            return self._symtab\n        else:\n            raise RuntimeError('Failed to parse Mach-O')\n\n    @property\n    def encryption_info(self) -> MachoEncryptionInfoStruct:\n        if self._encryption_info:\n            return self._encryption_info\n        else:\n            raise RuntimeError('Failed to parse Mach-O')\n\n    @property\n    def dyld_info(self) -> MachoDyldInfoCommandStruct:\n        if self._dyld_info:\n            return self._dyld_info\n        else:\n            raise RuntimeError('Failed to parse Mach-O')\n\n    @property\n    def code_signature_cmd(self) -> MachoLinkeditDataCommandStruct:\n        if self._code_signature_cmd:\n            return self._code_signature_cmd\n        else:\n            raise RuntimeError('Failed to parse Mach-O')\n\n    @property\n    def _codesign_parser(self) -> 'CodesignParser':\n        if not self.__codesign_parser:\n",
        "target_code_len": 1345,
        "diff_format": "@@ -583,4 +613,45 @@\n     @property\n+    def header(self) -> MachoHeaderStruct:\n+        if self._header:\n+            return self._header\n+        else:\n+            raise RuntimeError('Failed to parse Mach-O')\n+\n+    @property\n+    def dysymtab(self) -> MachoDysymtabCommandStruct:\n+        if self._dysymtab:\n+            return self._dysymtab\n+        else:\n+            raise RuntimeError('Failed to parse Mach-O')\n+\n+    @property\n+    def symtab(self) -> MachoSymtabCommandStruct:\n+        if self._symtab:\n+            return self._symtab\n+        else:\n+            raise RuntimeError('Failed to parse Mach-O')\n+\n+    @property\n+    def encryption_info(self) -> MachoEncryptionInfoStruct:\n+        if self._encryption_info:\n+            return self._encryption_info\n+        else:\n+            raise RuntimeError('Failed to parse Mach-O')\n+\n+    @property\n+    def dyld_info(self) -> MachoDyldInfoCommandStruct:\n+        if self._dyld_info:\n+            return self._dyld_info\n+        else:\n+            raise RuntimeError('Failed to parse Mach-O')\n+\n+    @property\n+    def code_signature_cmd(self) -> MachoLinkeditDataCommandStruct:\n+        if self._code_signature_cmd:\n+            return self._code_signature_cmd\n+        else:\n+            raise RuntimeError('Failed to parse Mach-O')\n+\n+    @property\n     def _codesign_parser(self) -> 'CodesignParser':\n-        from strongarm.macho.codesign import CodesignParser\n         if not self.__codesign_parser:\n",
        "source_code_with_indent": "    <DED>@property\n    def _codesign_parser(self) -> 'CodesignParser':\n        <IND>from strongarm.macho.codesign import CodesignParser\n        if not self.__codesign_parser:\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    <DED>@property\n    def header(self) -> MachoHeaderStruct:\n        <IND>if self._header:\n            <IND>return self._header\n        <DED>else:\n            <IND>raise RuntimeError('Failed to parse Mach-O')\n\n    <DED><DED>@property\n    def dysymtab(self) -> MachoDysymtabCommandStruct:\n        <IND>if self._dysymtab:\n            <IND>return self._dysymtab\n        <DED>else:\n            <IND>raise RuntimeError('Failed to parse Mach-O')\n\n    <DED><DED>@property\n    def symtab(self) -> MachoSymtabCommandStruct:\n        <IND>if self._symtab:\n            <IND>return self._symtab\n        <DED>else:\n            <IND>raise RuntimeError('Failed to parse Mach-O')\n\n    <DED><DED>@property\n    def encryption_info(self) -> MachoEncryptionInfoStruct:\n        <IND>if self._encryption_info:\n            <IND>return self._encryption_info\n        <DED>else:\n            <IND>raise RuntimeError('Failed to parse Mach-O')\n\n    <DED><DED>@property\n    def dyld_info(self) -> MachoDyldInfoCommandStruct:\n        <IND>if self._dyld_info:\n            <IND>return self._dyld_info\n        <DED>else:\n            <IND>raise RuntimeError('Failed to parse Mach-O')\n\n    <DED><DED>@property\n    def code_signature_cmd(self) -> MachoLinkeditDataCommandStruct:\n        <IND>if self._code_signature_cmd:\n            <IND>return self._code_signature_cmd\n        <DED>else:\n            <IND>raise RuntimeError('Failed to parse Mach-O')\n\n    <DED><DED>@property\n    def _codesign_parser(self) -> 'CodesignParser':\n        <IND>if not self.__codesign_parser:\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "datatheorem/strongarm",
    "commit": "ab620d78b4ce7f933cedc25960307f2c3b03c1a8",
    "filename": "strongarm/macho/macho_binary.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/datatheorem-strongarm/strongarm/macho/macho_binary.py",
    "file_hunks_size": 33,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "strongarm/macho/macho_binary.py:84:8 Incompatible attribute type [8]: Attribute `_MachoBinary__codesign_parser` declared in class `MachoBinary` has type `CodesignParser` but is used as type `None`.",
    "message": " Attribute `_MachoBinary__codesign_parser` declared in class `MachoBinary` has type `CodesignParser` but is used as type `None`.",
    "rule_id": "Incompatible attribute type [8]",
    "warning_line_no": 84,
    "warning_line": "        self.__codesign_parser: CodesignParser = None",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "# -*- coding: utf-8 -*-\nfrom typing import List, Tuple, Optional, Dict, Union\n\n",
        "source_code_len": 79,
        "target_code": "# -*- coding: utf-8 -*-\nfrom typing import List, Dict, Tuple, Any, Type, Optional\nfrom typing import TYPE_CHECKING\n\nfrom ctypes import c_uint64, c_uint32, sizeof\n\n",
        "target_code_len": 163,
        "diff_format": "@@ -1,3 +1,6 @@\n # -*- coding: utf-8 -*-\n-from typing import List, Tuple, Optional, Dict, Union\n+from typing import List, Dict, Tuple, Any, Type, Optional\n+from typing import TYPE_CHECKING\n+\n+from ctypes import c_uint64, c_uint32, sizeof\n \n",
        "source_code_with_indent": "# -*- coding: utf-8 -*-\nfrom typing import List, Tuple, Optional, Dict, Union\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "# -*- coding: utf-8 -*-\nfrom typing import List, Dict, Tuple, Any, Type, Optional\nfrom typing import TYPE_CHECKING\n\nfrom ctypes import c_uint64, c_uint32, sizeof\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "from strongarm.macho.macho_load_commands import MachoLoadCommands\nfrom strongarm.macho.arch_independent_structs import \\\n    MachoHeaderStruct, \\\n    MachoSegmentCommandStruct, \\\n    MachoSectionRawStruct, \\\n    MachoEncryptionInfoStruct, \\\n    MachoNlistStruct, \\\n    CFStringStruct, \\\n    DylibCommandStruct, \\\n    MachoLoadCommandStruct, \\\n    MachoSymtabCommandStruct, \\\n    MachoDysymtabCommandStruct, \\\n    MachoDyldInfoCommandStruct, \\\n    MachoLinkeditDataCommandStruct\n\nfrom ctypes import c_uint64, c_uint32, sizeof\n\n",
        "source_code_len": 526,
        "target_code": "from strongarm.macho.macho_load_commands import MachoLoadCommands\nfrom strongarm.macho.arch_independent_structs import (\n    ArchIndependentStructure,\n    MachoHeaderStruct,\n    MachoSegmentCommandStruct,\n    MachoSectionRawStruct,\n    MachoEncryptionInfoStruct,\n    MachoNlistStruct,\n    CFStringStruct,\n    DylibCommandStruct,\n    MachoLoadCommandStruct,\n    MachoSymtabCommandStruct,\n    MachoDysymtabCommandStruct,\n    MachoDyldInfoCommandStruct,\n    MachoLinkeditDataCommandStruct,\n)\n\nif TYPE_CHECKING:\n    from strongarm.macho.codesign import CodesignParser\n\n",
        "target_code_len": 565,
        "diff_format": "@@ -7,17 +10,20 @@\n from strongarm.macho.macho_load_commands import MachoLoadCommands\n-from strongarm.macho.arch_independent_structs import \\\n-    MachoHeaderStruct, \\\n-    MachoSegmentCommandStruct, \\\n-    MachoSectionRawStruct, \\\n-    MachoEncryptionInfoStruct, \\\n-    MachoNlistStruct, \\\n-    CFStringStruct, \\\n-    DylibCommandStruct, \\\n-    MachoLoadCommandStruct, \\\n-    MachoSymtabCommandStruct, \\\n-    MachoDysymtabCommandStruct, \\\n-    MachoDyldInfoCommandStruct, \\\n-    MachoLinkeditDataCommandStruct\n-\n-from ctypes import c_uint64, c_uint32, sizeof\n+from strongarm.macho.arch_independent_structs import (\n+    ArchIndependentStructure,\n+    MachoHeaderStruct,\n+    MachoSegmentCommandStruct,\n+    MachoSectionRawStruct,\n+    MachoEncryptionInfoStruct,\n+    MachoNlistStruct,\n+    CFStringStruct,\n+    DylibCommandStruct,\n+    MachoLoadCommandStruct,\n+    MachoSymtabCommandStruct,\n+    MachoDysymtabCommandStruct,\n+    MachoDyldInfoCommandStruct,\n+    MachoLinkeditDataCommandStruct,\n+)\n+\n+if TYPE_CHECKING:\n+    from strongarm.macho.codesign import CodesignParser\n \n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent": "from strongarm.macho.macho_load_commands import MachoLoadCommands\nfrom strongarm.macho.arch_independent_structs import (\n    ArchIndependentStructure,\n    MachoHeaderStruct,\n    MachoSegmentCommandStruct,\n    MachoSectionRawStruct,\n    MachoEncryptionInfoStruct,\n    MachoNlistStruct,\n    CFStringStruct,\n    DylibCommandStruct,\n    MachoLoadCommandStruct,\n    MachoSymtabCommandStruct,\n    MachoDysymtabCommandStruct,\n    MachoDyldInfoCommandStruct,\n    MachoLinkeditDataCommandStruct,\n)\n\nif TYPE_CHECKING:\n    <IND>from strongarm.macho.codesign import CodesignParser\n\n",
        "target_code_with_indent_exact_match": true,
        "source_code_with_indent": "from strongarm.macho.macho_load_commands import MachoLoadCommands\nfrom strongarm.macho.arch_independent_structs import    MachoHeaderStruct,    MachoSegmentCommandStruct,    MachoSectionRawStruct,    MachoEncryptionInfoStruct,    MachoNlistStruct,    CFStringStruct,    DylibCommandStruct,    MachoLoadCommandStruct,    MachoSymtabCommandStruct,    MachoDysymtabCommandStruct,    MachoDyldInfoCommandStruct,    MachoLinkeditDataCommandStruct\n\nfrom ctypes import c_uint64, c_uint32, sizeof\n\n"
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "        # generic Mach-O header info\n        self.is_64bit: bool = None\n        self.is_swap: bool = None\n        self.cpu_type: CPU_TYPE = None\n        self._load_commands_end_addr = None\n\n        # Mach-O header data\n        self.header: MachoHeaderStruct = None\n        self.header_flags: List[int] = None\n        self.file_type: MachoFileType = None\n\n        # segment and section commands from Mach-O header\n        self.segment_commands: Dict[str, MachoSegmentCommandStruct] = None\n        self.sections: Dict[str, MachoSection] = None\n        # also store specific interesting sections which are useful to us\n        self.dysymtab: MachoDysymtabCommandStruct = None\n        self.symtab: MachoSymtabCommandStruct = None\n        self.encryption_info: MachoEncryptionInfoStruct = None\n        self.dyld_info: MachoDyldInfoCommandStruct = None\n        self.load_dylib_commands: List[DylibCommandStruct] = None\n        self.code_signature_cmd: MachoLinkeditDataCommandStruct = None\n\n        self.__codesign_parser: CodesignParser = None\n\n",
        "source_code_len": 1040,
        "target_code": "        # generic Mach-O header info\n        self.is_64bit: bool = False\n        self.is_swap: bool = False\n        self.cpu_type: CPU_TYPE = CPU_TYPE.UNKNOWN\n        self._load_commands_end_addr = 0\n\n        # Mach-O header data\n        self._header: Optional[MachoHeaderStruct] = None\n        self.header_flags: List[int] = []\n        self.file_type: MachoFileType = MachoFileType.MH_EXECUTE\n\n        # segment and section commands from Mach-O header\n        self.segment_commands: Dict[str, MachoSegmentCommandStruct] = {}\n        self.sections: Dict[str, MachoSection] = {}\n        # also store specific interesting sections which are useful to us\n        self._dysymtab: Optional[MachoDysymtabCommandStruct] = None\n        self._symtab: Optional[MachoSymtabCommandStruct] = None\n        self._encryption_info: Optional[MachoEncryptionInfoStruct] = None\n        self._dyld_info: Optional[MachoDyldInfoCommandStruct] = None\n        self.load_dylib_commands: List[DylibCommandStruct] = []\n        self._code_signature_cmd: Optional[MachoLinkeditDataCommandStruct] = None\n\n        self.__codesign_parser: Optional[CodesignParser] = None\n\n",
        "target_code_len": 1139,
        "diff_format": "@@ -62,24 +68,24 @@\n         # generic Mach-O header info\n-        self.is_64bit: bool = None\n-        self.is_swap: bool = None\n-        self.cpu_type: CPU_TYPE = None\n-        self._load_commands_end_addr = None\n+        self.is_64bit: bool = False\n+        self.is_swap: bool = False\n+        self.cpu_type: CPU_TYPE = CPU_TYPE.UNKNOWN\n+        self._load_commands_end_addr = 0\n \n         # Mach-O header data\n-        self.header: MachoHeaderStruct = None\n-        self.header_flags: List[int] = None\n-        self.file_type: MachoFileType = None\n+        self._header: Optional[MachoHeaderStruct] = None\n+        self.header_flags: List[int] = []\n+        self.file_type: MachoFileType = MachoFileType.MH_EXECUTE\n \n         # segment and section commands from Mach-O header\n-        self.segment_commands: Dict[str, MachoSegmentCommandStruct] = None\n-        self.sections: Dict[str, MachoSection] = None\n+        self.segment_commands: Dict[str, MachoSegmentCommandStruct] = {}\n+        self.sections: Dict[str, MachoSection] = {}\n         # also store specific interesting sections which are useful to us\n-        self.dysymtab: MachoDysymtabCommandStruct = None\n-        self.symtab: MachoSymtabCommandStruct = None\n-        self.encryption_info: MachoEncryptionInfoStruct = None\n-        self.dyld_info: MachoDyldInfoCommandStruct = None\n-        self.load_dylib_commands: List[DylibCommandStruct] = None\n-        self.code_signature_cmd: MachoLinkeditDataCommandStruct = None\n-\n-        self.__codesign_parser: CodesignParser = None\n+        self._dysymtab: Optional[MachoDysymtabCommandStruct] = None\n+        self._symtab: Optional[MachoSymtabCommandStruct] = None\n+        self._encryption_info: Optional[MachoEncryptionInfoStruct] = None\n+        self._dyld_info: Optional[MachoDyldInfoCommandStruct] = None\n+        self.load_dylib_commands: List[DylibCommandStruct] = []\n+        self._code_signature_cmd: Optional[MachoLinkeditDataCommandStruct] = None\n+\n+        self.__codesign_parser: Optional[CodesignParser] = None\n \n",
        "source_code_with_indent": "        # generic Mach-O header info\n        self.is_64bit: bool = None\n        self.is_swap: bool = None\n        self.cpu_type: CPU_TYPE = None\n        self._load_commands_end_addr = None\n\n        # Mach-O header data\n        self.header: MachoHeaderStruct = None\n        self.header_flags: List[int] = None\n        self.file_type: MachoFileType = None\n\n        # segment and section commands from Mach-O header\n        self.segment_commands: Dict[str, MachoSegmentCommandStruct] = None\n        self.sections: Dict[str, MachoSection] = None\n        # also store specific interesting sections which are useful to us\n        self.dysymtab: MachoDysymtabCommandStruct = None\n        self.symtab: MachoSymtabCommandStruct = None\n        self.encryption_info: MachoEncryptionInfoStruct = None\n        self.dyld_info: MachoDyldInfoCommandStruct = None\n        self.load_dylib_commands: List[DylibCommandStruct] = None\n        self.code_signature_cmd: MachoLinkeditDataCommandStruct = None\n\n        self.__codesign_parser: CodesignParser = None\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "        # generic Mach-O header info\n        self.is_64bit: bool = False\n        self.is_swap: bool = False\n        self.cpu_type: CPU_TYPE = CPU_TYPE.UNKNOWN\n        self._load_commands_end_addr = 0\n\n        # Mach-O header data\n        self._header: Optional[MachoHeaderStruct] = None\n        self.header_flags: List[int] = []\n        self.file_type: MachoFileType = MachoFileType.MH_EXECUTE\n\n        # segment and section commands from Mach-O header\n        self.segment_commands: Dict[str, MachoSegmentCommandStruct] = {}\n        self.sections: Dict[str, MachoSection] = {}\n        # also store specific interesting sections which are useful to us\n        self._dysymtab: Optional[MachoDysymtabCommandStruct] = None\n        self._symtab: Optional[MachoSymtabCommandStruct] = None\n        self._encryption_info: Optional[MachoEncryptionInfoStruct] = None\n        self._dyld_info: Optional[MachoDyldInfoCommandStruct] = None\n        self.load_dylib_commands: List[DylibCommandStruct] = []\n        self._code_signature_cmd: Optional[MachoLinkeditDataCommandStruct] = None\n\n        self.__codesign_parser: Optional[CodesignParser] = None\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    @property\n    def slice_magic(self) -> c_uint32:\n        \"\"\"Read magic number identifier from this Mach-O slice\n        \"\"\"\n        return self.read_word(0, virtual=False, word_type=c_uint32)\n\n",
        "source_code_len": 197,
        "target_code": "    @property\n    def slice_magic(self) -> int:\n        \"\"\"Read magic number identifier from this Mach-O slice\n        \"\"\"\n        magic = self.read_word(0, virtual=False, word_type=c_uint32)\n        if magic:\n            return magic\n        else:\n            raise ValueError('Could not read magic value.')\n\n",
        "target_code_len": 310,
        "diff_format": "@@ -124,6 +131,10 @@\n     @property\n-    def slice_magic(self) -> c_uint32:\n+    def slice_magic(self) -> int:\n         \"\"\"Read magic number identifier from this Mach-O slice\n         \"\"\"\n-        return self.read_word(0, virtual=False, word_type=c_uint32)\n+        magic = self.read_word(0, virtual=False, word_type=c_uint32)\n+        if magic:\n+            return magic\n+        else:\n+            raise ValueError('Could not read magic value.')\n \n",
        "source_code_with_indent": "    <DED>@property\n    def slice_magic(self) -> c_uint32:\n        <IND>\"\"\"Read magic number identifier from this Mach-O slice\n        \"\"\"\n        return self.read_word(0, virtual=False, word_type=c_uint32)\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    <DED>@property\n    def slice_magic(self) -> int:\n        <IND>\"\"\"Read magic number identifier from this Mach-O slice\n        \"\"\"\n        magic = self.read_word(0, virtual=False, word_type=c_uint32)\n        if magic:\n            <IND>return magic\n        <DED>else:\n            <IND>raise ValueError('Could not read magic value.')\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "        \"\"\"\n        self.header = MachoHeaderStruct(self, 0)\n\n",
        "source_code_len": 62,
        "target_code": "        \"\"\"\n        self._header = MachoHeaderStruct(self, 0)\n\n",
        "target_code_len": 63,
        "diff_format": "@@ -152,3 +163,3 @@\n         \"\"\"\n-        self.header = MachoHeaderStruct(self, 0)\n+        self._header = MachoHeaderStruct(self, 0)\n \n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\n        self.header = MachoHeaderStruct(self, 0)\n\n",
        "target_code_with_indent": "\n        self._header = MachoHeaderStruct(self, 0)\n\n"
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "                                      MachoLoadCommands.LC_ENCRYPTION_INFO_64]:\n                self.encryption_info = MachoEncryptionInfoStruct(self, offset)\n\n            elif load_command.cmd == MachoLoadCommands.LC_SYMTAB:\n                self.symtab = MachoSymtabCommandStruct(self, offset)\n\n            elif load_command.cmd == MachoLoadCommands.LC_DYSYMTAB:\n                self.dysymtab = MachoDysymtabCommandStruct(self, offset)\n\n            elif load_command.cmd in [MachoLoadCommands.LC_DYLD_INFO, MachoLoadCommands.LC_DYLD_INFO_ONLY]:\n                self.dyld_info = MachoDyldInfoCommandStruct(self, offset)\n\n",
        "source_code_len": 621,
        "target_code": "                                      MachoLoadCommands.LC_ENCRYPTION_INFO_64]:\n                self._encryption_info = MachoEncryptionInfoStruct(self, offset)\n\n            elif load_command.cmd == MachoLoadCommands.LC_SYMTAB:\n                self._symtab = MachoSymtabCommandStruct(self, offset)\n\n            elif load_command.cmd == MachoLoadCommands.LC_DYSYMTAB:\n                self._dysymtab = MachoDysymtabCommandStruct(self, offset)\n\n            elif load_command.cmd in [MachoLoadCommands.LC_DYLD_INFO, MachoLoadCommands.LC_DYLD_INFO_ONLY]:\n                self._dyld_info = MachoDyldInfoCommandStruct(self, offset)\n\n",
        "target_code_len": 625,
        "diff_format": "@@ -208,12 +220,12 @@\n                                       MachoLoadCommands.LC_ENCRYPTION_INFO_64]:\n-                self.encryption_info = MachoEncryptionInfoStruct(self, offset)\n+                self._encryption_info = MachoEncryptionInfoStruct(self, offset)\n \n             elif load_command.cmd == MachoLoadCommands.LC_SYMTAB:\n-                self.symtab = MachoSymtabCommandStruct(self, offset)\n+                self._symtab = MachoSymtabCommandStruct(self, offset)\n \n             elif load_command.cmd == MachoLoadCommands.LC_DYSYMTAB:\n-                self.dysymtab = MachoDysymtabCommandStruct(self, offset)\n+                self._dysymtab = MachoDysymtabCommandStruct(self, offset)\n \n             elif load_command.cmd in [MachoLoadCommands.LC_DYLD_INFO, MachoLoadCommands.LC_DYLD_INFO_ONLY]:\n-                self.dyld_info = MachoDyldInfoCommandStruct(self, offset)\n+                self._dyld_info = MachoDyldInfoCommandStruct(self, offset)\n \n",
        "source_code_with_indent": "                                      MachoLoadCommands.LC_ENCRYPTION_INFO_64]:\n                <IND>self.encryption_info = MachoEncryptionInfoStruct(self, offset)\n\n            <DED>elif load_command.cmd == MachoLoadCommands.LC_SYMTAB:\n                <IND>self.symtab = MachoSymtabCommandStruct(self, offset)\n\n            <DED>elif load_command.cmd == MachoLoadCommands.LC_DYSYMTAB:\n                <IND>self.dysymtab = MachoDysymtabCommandStruct(self, offset)\n\n            <DED>elif load_command.cmd in [MachoLoadCommands.LC_DYLD_INFO, MachoLoadCommands.LC_DYLD_INFO_ONLY]:\n                <IND>self.dyld_info = MachoDyldInfoCommandStruct(self, offset)\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "                                      MachoLoadCommands.LC_ENCRYPTION_INFO_64]:\n                <IND>self._encryption_info = MachoEncryptionInfoStruct(self, offset)\n\n            <DED>elif load_command.cmd == MachoLoadCommands.LC_SYMTAB:\n                <IND>self._symtab = MachoSymtabCommandStruct(self, offset)\n\n            <DED>elif load_command.cmd == MachoLoadCommands.LC_DYSYMTAB:\n                <IND>self._dysymtab = MachoDysymtabCommandStruct(self, offset)\n\n            <DED>elif load_command.cmd in [MachoLoadCommands.LC_DYLD_INFO, MachoLoadCommands.LC_DYLD_INFO_ONLY]:\n                <IND>self._dyld_info = MachoDyldInfoCommandStruct(self, offset)\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "            elif load_command.cmd == MachoLoadCommands.LC_CODE_SIGNATURE:\n                self.code_signature_cmd = MachoLinkeditDataCommandStruct(self, offset)\n\n",
        "source_code_len": 162,
        "target_code": "            elif load_command.cmd == MachoLoadCommands.LC_CODE_SIGNATURE:\n                self._code_signature_cmd = MachoLinkeditDataCommandStruct(self, offset)\n\n",
        "target_code_len": 163,
        "diff_format": "@@ -225,3 +236,3 @@\n             elif load_command.cmd == MachoLoadCommands.LC_CODE_SIGNATURE:\n-                self.code_signature_cmd = MachoLinkeditDataCommandStruct(self, offset)\n+                self._code_signature_cmd = MachoLinkeditDataCommandStruct(self, offset)\n \n",
        "source_code_with_indent": "            <DED>elif load_command.cmd == MachoLoadCommands.LC_CODE_SIGNATURE:\n                <IND>self.code_signature_cmd = MachoLinkeditDataCommandStruct(self, offset)\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "            <DED>elif load_command.cmd == MachoLoadCommands.LC_CODE_SIGNATURE:\n                <IND>self._code_signature_cmd = MachoLinkeditDataCommandStruct(self, offset)\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "            indirect_symtab_entry = self.read_word(indirect_symtab_off, virtual=False, word_type=c_uint32)\n            indirect_symtab.append(int(indirect_symtab_entry.value))\n            # traverse to next pointer\n",
        "source_code_len": 215,
        "target_code": "            indirect_symtab_entry = self.read_word(indirect_symtab_off, virtual=False, word_type=c_uint32)\n            if not indirect_symtab_entry:\n                continue\n            indirect_symtab.append(int(indirect_symtab_entry))\n            # traverse to next pointer\n",
        "target_code_len": 276,
        "diff_format": "@@ -398,3 +410,5 @@\n             indirect_symtab_entry = self.read_word(indirect_symtab_off, virtual=False, word_type=c_uint32)\n-            indirect_symtab.append(int(indirect_symtab_entry.value))\n+            if not indirect_symtab_entry:\n+                continue\n+            indirect_symtab.append(int(indirect_symtab_entry))\n             # traverse to next pointer\n",
        "source_code_with_indent": "            <IND>indirect_symtab_entry = self.read_word(indirect_symtab_off, virtual=False, word_type=c_uint32)\n            indirect_symtab.append(int(indirect_symtab_entry.value))\n            # traverse to next pointer\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "            <IND>indirect_symtab_entry = self.read_word(indirect_symtab_off, virtual=False, word_type=c_uint32)\n            if not indirect_symtab_entry:\n                <IND>continue\n            <DED>indirect_symtab.append(int(indirect_symtab_entry))\n            # traverse to next pointer\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "                  address: int,\n                  virtual=True,\n                  word_type=None) -> Optional[Union[c_uint32, c_uint64]]:\n        \"\"\"Attempt to read a word from the binary at a virtual address. Returns None if the address is invalid.\n",
        "source_code_len": 250,
        "target_code": "                  address: int,\n                  virtual: bool = True,\n                  word_type: Any = None) -> Optional[int]:\n        \"\"\"Attempt to read a word from the binary at a virtual address. Returns None if the address is invalid.\n",
        "target_code_len": 243,
        "diff_format": "@@ -568,4 +595,4 @@\n                   address: int,\n-                  virtual=True,\n-                  word_type=None) -> Optional[Union[c_uint32, c_uint64]]:\n+                  virtual: bool = True,\n+                  word_type: Any = None) -> Optional[int]:\n         \"\"\"Attempt to read a word from the binary at a virtual address. Returns None if the address is invalid.\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "                  address: int,\n                  virtual=True,\n                  word_type=None) -> Optional[Union[c_uint32, c_uint64]]:\n        <IND>",
        "target_code_with_indent": "                  address: int,\n                  virtual: bool = True,\n                  word_type: Any = None) -> Optional[int]:\n        <IND>"
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    @property\n    def _codesign_parser(self) -> 'CodesignParser':\n        from strongarm.macho.codesign import CodesignParser\n        if not self.__codesign_parser:\n",
        "source_code_len": 165,
        "target_code": "    @property\n    def header(self) -> MachoHeaderStruct:\n        if self._header:\n            return self._header\n        else:\n            raise RuntimeError('Failed to parse Mach-O')\n\n    @property\n    def dysymtab(self) -> MachoDysymtabCommandStruct:\n        if self._dysymtab:\n            return self._dysymtab\n        else:\n            raise RuntimeError('Failed to parse Mach-O')\n\n    @property\n    def symtab(self) -> MachoSymtabCommandStruct:\n        if self._symtab:\n            return self._symtab\n        else:\n            raise RuntimeError('Failed to parse Mach-O')\n\n    @property\n    def encryption_info(self) -> MachoEncryptionInfoStruct:\n        if self._encryption_info:\n            return self._encryption_info\n        else:\n            raise RuntimeError('Failed to parse Mach-O')\n\n    @property\n    def dyld_info(self) -> MachoDyldInfoCommandStruct:\n        if self._dyld_info:\n            return self._dyld_info\n        else:\n            raise RuntimeError('Failed to parse Mach-O')\n\n    @property\n    def code_signature_cmd(self) -> MachoLinkeditDataCommandStruct:\n        if self._code_signature_cmd:\n            return self._code_signature_cmd\n        else:\n            raise RuntimeError('Failed to parse Mach-O')\n\n    @property\n    def _codesign_parser(self) -> 'CodesignParser':\n        if not self.__codesign_parser:\n",
        "target_code_len": 1345,
        "diff_format": "@@ -583,4 +613,45 @@\n     @property\n+    def header(self) -> MachoHeaderStruct:\n+        if self._header:\n+            return self._header\n+        else:\n+            raise RuntimeError('Failed to parse Mach-O')\n+\n+    @property\n+    def dysymtab(self) -> MachoDysymtabCommandStruct:\n+        if self._dysymtab:\n+            return self._dysymtab\n+        else:\n+            raise RuntimeError('Failed to parse Mach-O')\n+\n+    @property\n+    def symtab(self) -> MachoSymtabCommandStruct:\n+        if self._symtab:\n+            return self._symtab\n+        else:\n+            raise RuntimeError('Failed to parse Mach-O')\n+\n+    @property\n+    def encryption_info(self) -> MachoEncryptionInfoStruct:\n+        if self._encryption_info:\n+            return self._encryption_info\n+        else:\n+            raise RuntimeError('Failed to parse Mach-O')\n+\n+    @property\n+    def dyld_info(self) -> MachoDyldInfoCommandStruct:\n+        if self._dyld_info:\n+            return self._dyld_info\n+        else:\n+            raise RuntimeError('Failed to parse Mach-O')\n+\n+    @property\n+    def code_signature_cmd(self) -> MachoLinkeditDataCommandStruct:\n+        if self._code_signature_cmd:\n+            return self._code_signature_cmd\n+        else:\n+            raise RuntimeError('Failed to parse Mach-O')\n+\n+    @property\n     def _codesign_parser(self) -> 'CodesignParser':\n-        from strongarm.macho.codesign import CodesignParser\n         if not self.__codesign_parser:\n",
        "source_code_with_indent": "    <DED>@property\n    def _codesign_parser(self) -> 'CodesignParser':\n        <IND>from strongarm.macho.codesign import CodesignParser\n        if not self.__codesign_parser:\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    <DED>@property\n    def header(self) -> MachoHeaderStruct:\n        <IND>if self._header:\n            <IND>return self._header\n        <DED>else:\n            <IND>raise RuntimeError('Failed to parse Mach-O')\n\n    <DED><DED>@property\n    def dysymtab(self) -> MachoDysymtabCommandStruct:\n        <IND>if self._dysymtab:\n            <IND>return self._dysymtab\n        <DED>else:\n            <IND>raise RuntimeError('Failed to parse Mach-O')\n\n    <DED><DED>@property\n    def symtab(self) -> MachoSymtabCommandStruct:\n        <IND>if self._symtab:\n            <IND>return self._symtab\n        <DED>else:\n            <IND>raise RuntimeError('Failed to parse Mach-O')\n\n    <DED><DED>@property\n    def encryption_info(self) -> MachoEncryptionInfoStruct:\n        <IND>if self._encryption_info:\n            <IND>return self._encryption_info\n        <DED>else:\n            <IND>raise RuntimeError('Failed to parse Mach-O')\n\n    <DED><DED>@property\n    def dyld_info(self) -> MachoDyldInfoCommandStruct:\n        <IND>if self._dyld_info:\n            <IND>return self._dyld_info\n        <DED>else:\n            <IND>raise RuntimeError('Failed to parse Mach-O')\n\n    <DED><DED>@property\n    def code_signature_cmd(self) -> MachoLinkeditDataCommandStruct:\n        <IND>if self._code_signature_cmd:\n            <IND>return self._code_signature_cmd\n        <DED>else:\n            <IND>raise RuntimeError('Failed to parse Mach-O')\n\n    <DED><DED>@property\n    def _codesign_parser(self) -> 'CodesignParser':\n        <IND>if not self.__codesign_parser:\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "datatheorem/strongarm",
    "commit": "ab620d78b4ce7f933cedc25960307f2c3b03c1a8",
    "filename": "strongarm/macho/macho_binary.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/datatheorem-strongarm/strongarm/macho/macho_binary.py",
    "file_hunks_size": 33,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "strongarm/macho/macho_binary.py:114:70 Incompatible parameter type [6]: Expected `Union[_SupportsTrunc, bytes, str, typing.SupportsInt, typing_extensions.SupportsIndex]` for 1st positional only parameter to call `int.__new__` but got `c_uint32`.",
    "message": " Expected `Union[_SupportsTrunc, bytes, str, typing.SupportsInt, typing_extensions.SupportsIndex]` for 1st positional only parameter to call `int.__new__` but got `c_uint32`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 114,
    "warning_line": "            DebugUtil.log(self, 'unsupported magic {}'.format(hex(int(self.slice_magic))))",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "# -*- coding: utf-8 -*-\nfrom typing import List, Tuple, Optional, Dict, Union\n\n",
        "source_code_len": 79,
        "target_code": "# -*- coding: utf-8 -*-\nfrom typing import List, Dict, Tuple, Any, Type, Optional\nfrom typing import TYPE_CHECKING\n\nfrom ctypes import c_uint64, c_uint32, sizeof\n\n",
        "target_code_len": 163,
        "diff_format": "@@ -1,3 +1,6 @@\n # -*- coding: utf-8 -*-\n-from typing import List, Tuple, Optional, Dict, Union\n+from typing import List, Dict, Tuple, Any, Type, Optional\n+from typing import TYPE_CHECKING\n+\n+from ctypes import c_uint64, c_uint32, sizeof\n \n",
        "source_code_with_indent": "# -*- coding: utf-8 -*-\nfrom typing import List, Tuple, Optional, Dict, Union\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "# -*- coding: utf-8 -*-\nfrom typing import List, Dict, Tuple, Any, Type, Optional\nfrom typing import TYPE_CHECKING\n\nfrom ctypes import c_uint64, c_uint32, sizeof\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "from strongarm.macho.macho_load_commands import MachoLoadCommands\nfrom strongarm.macho.arch_independent_structs import \\\n    MachoHeaderStruct, \\\n    MachoSegmentCommandStruct, \\\n    MachoSectionRawStruct, \\\n    MachoEncryptionInfoStruct, \\\n    MachoNlistStruct, \\\n    CFStringStruct, \\\n    DylibCommandStruct, \\\n    MachoLoadCommandStruct, \\\n    MachoSymtabCommandStruct, \\\n    MachoDysymtabCommandStruct, \\\n    MachoDyldInfoCommandStruct, \\\n    MachoLinkeditDataCommandStruct\n\nfrom ctypes import c_uint64, c_uint32, sizeof\n\n",
        "source_code_len": 526,
        "target_code": "from strongarm.macho.macho_load_commands import MachoLoadCommands\nfrom strongarm.macho.arch_independent_structs import (\n    ArchIndependentStructure,\n    MachoHeaderStruct,\n    MachoSegmentCommandStruct,\n    MachoSectionRawStruct,\n    MachoEncryptionInfoStruct,\n    MachoNlistStruct,\n    CFStringStruct,\n    DylibCommandStruct,\n    MachoLoadCommandStruct,\n    MachoSymtabCommandStruct,\n    MachoDysymtabCommandStruct,\n    MachoDyldInfoCommandStruct,\n    MachoLinkeditDataCommandStruct,\n)\n\nif TYPE_CHECKING:\n    from strongarm.macho.codesign import CodesignParser\n\n",
        "target_code_len": 565,
        "diff_format": "@@ -7,17 +10,20 @@\n from strongarm.macho.macho_load_commands import MachoLoadCommands\n-from strongarm.macho.arch_independent_structs import \\\n-    MachoHeaderStruct, \\\n-    MachoSegmentCommandStruct, \\\n-    MachoSectionRawStruct, \\\n-    MachoEncryptionInfoStruct, \\\n-    MachoNlistStruct, \\\n-    CFStringStruct, \\\n-    DylibCommandStruct, \\\n-    MachoLoadCommandStruct, \\\n-    MachoSymtabCommandStruct, \\\n-    MachoDysymtabCommandStruct, \\\n-    MachoDyldInfoCommandStruct, \\\n-    MachoLinkeditDataCommandStruct\n-\n-from ctypes import c_uint64, c_uint32, sizeof\n+from strongarm.macho.arch_independent_structs import (\n+    ArchIndependentStructure,\n+    MachoHeaderStruct,\n+    MachoSegmentCommandStruct,\n+    MachoSectionRawStruct,\n+    MachoEncryptionInfoStruct,\n+    MachoNlistStruct,\n+    CFStringStruct,\n+    DylibCommandStruct,\n+    MachoLoadCommandStruct,\n+    MachoSymtabCommandStruct,\n+    MachoDysymtabCommandStruct,\n+    MachoDyldInfoCommandStruct,\n+    MachoLinkeditDataCommandStruct,\n+)\n+\n+if TYPE_CHECKING:\n+    from strongarm.macho.codesign import CodesignParser\n \n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent": "from strongarm.macho.macho_load_commands import MachoLoadCommands\nfrom strongarm.macho.arch_independent_structs import (\n    ArchIndependentStructure,\n    MachoHeaderStruct,\n    MachoSegmentCommandStruct,\n    MachoSectionRawStruct,\n    MachoEncryptionInfoStruct,\n    MachoNlistStruct,\n    CFStringStruct,\n    DylibCommandStruct,\n    MachoLoadCommandStruct,\n    MachoSymtabCommandStruct,\n    MachoDysymtabCommandStruct,\n    MachoDyldInfoCommandStruct,\n    MachoLinkeditDataCommandStruct,\n)\n\nif TYPE_CHECKING:\n    <IND>from strongarm.macho.codesign import CodesignParser\n\n",
        "target_code_with_indent_exact_match": true,
        "source_code_with_indent": "from strongarm.macho.macho_load_commands import MachoLoadCommands\nfrom strongarm.macho.arch_independent_structs import    MachoHeaderStruct,    MachoSegmentCommandStruct,    MachoSectionRawStruct,    MachoEncryptionInfoStruct,    MachoNlistStruct,    CFStringStruct,    DylibCommandStruct,    MachoLoadCommandStruct,    MachoSymtabCommandStruct,    MachoDysymtabCommandStruct,    MachoDyldInfoCommandStruct,    MachoLinkeditDataCommandStruct\n\nfrom ctypes import c_uint64, c_uint32, sizeof\n\n"
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "        # generic Mach-O header info\n        self.is_64bit: bool = None\n        self.is_swap: bool = None\n        self.cpu_type: CPU_TYPE = None\n        self._load_commands_end_addr = None\n\n        # Mach-O header data\n        self.header: MachoHeaderStruct = None\n        self.header_flags: List[int] = None\n        self.file_type: MachoFileType = None\n\n        # segment and section commands from Mach-O header\n        self.segment_commands: Dict[str, MachoSegmentCommandStruct] = None\n        self.sections: Dict[str, MachoSection] = None\n        # also store specific interesting sections which are useful to us\n        self.dysymtab: MachoDysymtabCommandStruct = None\n        self.symtab: MachoSymtabCommandStruct = None\n        self.encryption_info: MachoEncryptionInfoStruct = None\n        self.dyld_info: MachoDyldInfoCommandStruct = None\n        self.load_dylib_commands: List[DylibCommandStruct] = None\n        self.code_signature_cmd: MachoLinkeditDataCommandStruct = None\n\n        self.__codesign_parser: CodesignParser = None\n\n",
        "source_code_len": 1040,
        "target_code": "        # generic Mach-O header info\n        self.is_64bit: bool = False\n        self.is_swap: bool = False\n        self.cpu_type: CPU_TYPE = CPU_TYPE.UNKNOWN\n        self._load_commands_end_addr = 0\n\n        # Mach-O header data\n        self._header: Optional[MachoHeaderStruct] = None\n        self.header_flags: List[int] = []\n        self.file_type: MachoFileType = MachoFileType.MH_EXECUTE\n\n        # segment and section commands from Mach-O header\n        self.segment_commands: Dict[str, MachoSegmentCommandStruct] = {}\n        self.sections: Dict[str, MachoSection] = {}\n        # also store specific interesting sections which are useful to us\n        self._dysymtab: Optional[MachoDysymtabCommandStruct] = None\n        self._symtab: Optional[MachoSymtabCommandStruct] = None\n        self._encryption_info: Optional[MachoEncryptionInfoStruct] = None\n        self._dyld_info: Optional[MachoDyldInfoCommandStruct] = None\n        self.load_dylib_commands: List[DylibCommandStruct] = []\n        self._code_signature_cmd: Optional[MachoLinkeditDataCommandStruct] = None\n\n        self.__codesign_parser: Optional[CodesignParser] = None\n\n",
        "target_code_len": 1139,
        "diff_format": "@@ -62,24 +68,24 @@\n         # generic Mach-O header info\n-        self.is_64bit: bool = None\n-        self.is_swap: bool = None\n-        self.cpu_type: CPU_TYPE = None\n-        self._load_commands_end_addr = None\n+        self.is_64bit: bool = False\n+        self.is_swap: bool = False\n+        self.cpu_type: CPU_TYPE = CPU_TYPE.UNKNOWN\n+        self._load_commands_end_addr = 0\n \n         # Mach-O header data\n-        self.header: MachoHeaderStruct = None\n-        self.header_flags: List[int] = None\n-        self.file_type: MachoFileType = None\n+        self._header: Optional[MachoHeaderStruct] = None\n+        self.header_flags: List[int] = []\n+        self.file_type: MachoFileType = MachoFileType.MH_EXECUTE\n \n         # segment and section commands from Mach-O header\n-        self.segment_commands: Dict[str, MachoSegmentCommandStruct] = None\n-        self.sections: Dict[str, MachoSection] = None\n+        self.segment_commands: Dict[str, MachoSegmentCommandStruct] = {}\n+        self.sections: Dict[str, MachoSection] = {}\n         # also store specific interesting sections which are useful to us\n-        self.dysymtab: MachoDysymtabCommandStruct = None\n-        self.symtab: MachoSymtabCommandStruct = None\n-        self.encryption_info: MachoEncryptionInfoStruct = None\n-        self.dyld_info: MachoDyldInfoCommandStruct = None\n-        self.load_dylib_commands: List[DylibCommandStruct] = None\n-        self.code_signature_cmd: MachoLinkeditDataCommandStruct = None\n-\n-        self.__codesign_parser: CodesignParser = None\n+        self._dysymtab: Optional[MachoDysymtabCommandStruct] = None\n+        self._symtab: Optional[MachoSymtabCommandStruct] = None\n+        self._encryption_info: Optional[MachoEncryptionInfoStruct] = None\n+        self._dyld_info: Optional[MachoDyldInfoCommandStruct] = None\n+        self.load_dylib_commands: List[DylibCommandStruct] = []\n+        self._code_signature_cmd: Optional[MachoLinkeditDataCommandStruct] = None\n+\n+        self.__codesign_parser: Optional[CodesignParser] = None\n \n",
        "source_code_with_indent": "        # generic Mach-O header info\n        self.is_64bit: bool = None\n        self.is_swap: bool = None\n        self.cpu_type: CPU_TYPE = None\n        self._load_commands_end_addr = None\n\n        # Mach-O header data\n        self.header: MachoHeaderStruct = None\n        self.header_flags: List[int] = None\n        self.file_type: MachoFileType = None\n\n        # segment and section commands from Mach-O header\n        self.segment_commands: Dict[str, MachoSegmentCommandStruct] = None\n        self.sections: Dict[str, MachoSection] = None\n        # also store specific interesting sections which are useful to us\n        self.dysymtab: MachoDysymtabCommandStruct = None\n        self.symtab: MachoSymtabCommandStruct = None\n        self.encryption_info: MachoEncryptionInfoStruct = None\n        self.dyld_info: MachoDyldInfoCommandStruct = None\n        self.load_dylib_commands: List[DylibCommandStruct] = None\n        self.code_signature_cmd: MachoLinkeditDataCommandStruct = None\n\n        self.__codesign_parser: CodesignParser = None\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "        # generic Mach-O header info\n        self.is_64bit: bool = False\n        self.is_swap: bool = False\n        self.cpu_type: CPU_TYPE = CPU_TYPE.UNKNOWN\n        self._load_commands_end_addr = 0\n\n        # Mach-O header data\n        self._header: Optional[MachoHeaderStruct] = None\n        self.header_flags: List[int] = []\n        self.file_type: MachoFileType = MachoFileType.MH_EXECUTE\n\n        # segment and section commands from Mach-O header\n        self.segment_commands: Dict[str, MachoSegmentCommandStruct] = {}\n        self.sections: Dict[str, MachoSection] = {}\n        # also store specific interesting sections which are useful to us\n        self._dysymtab: Optional[MachoDysymtabCommandStruct] = None\n        self._symtab: Optional[MachoSymtabCommandStruct] = None\n        self._encryption_info: Optional[MachoEncryptionInfoStruct] = None\n        self._dyld_info: Optional[MachoDyldInfoCommandStruct] = None\n        self.load_dylib_commands: List[DylibCommandStruct] = []\n        self._code_signature_cmd: Optional[MachoLinkeditDataCommandStruct] = None\n\n        self.__codesign_parser: Optional[CodesignParser] = None\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    @property\n    def slice_magic(self) -> c_uint32:\n        \"\"\"Read magic number identifier from this Mach-O slice\n        \"\"\"\n        return self.read_word(0, virtual=False, word_type=c_uint32)\n\n",
        "source_code_len": 197,
        "target_code": "    @property\n    def slice_magic(self) -> int:\n        \"\"\"Read magic number identifier from this Mach-O slice\n        \"\"\"\n        magic = self.read_word(0, virtual=False, word_type=c_uint32)\n        if magic:\n            return magic\n        else:\n            raise ValueError('Could not read magic value.')\n\n",
        "target_code_len": 310,
        "diff_format": "@@ -124,6 +131,10 @@\n     @property\n-    def slice_magic(self) -> c_uint32:\n+    def slice_magic(self) -> int:\n         \"\"\"Read magic number identifier from this Mach-O slice\n         \"\"\"\n-        return self.read_word(0, virtual=False, word_type=c_uint32)\n+        magic = self.read_word(0, virtual=False, word_type=c_uint32)\n+        if magic:\n+            return magic\n+        else:\n+            raise ValueError('Could not read magic value.')\n \n",
        "source_code_with_indent": "    <DED>@property\n    def slice_magic(self) -> c_uint32:\n        <IND>\"\"\"Read magic number identifier from this Mach-O slice\n        \"\"\"\n        return self.read_word(0, virtual=False, word_type=c_uint32)\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    <DED>@property\n    def slice_magic(self) -> int:\n        <IND>\"\"\"Read magic number identifier from this Mach-O slice\n        \"\"\"\n        magic = self.read_word(0, virtual=False, word_type=c_uint32)\n        if magic:\n            <IND>return magic\n        <DED>else:\n            <IND>raise ValueError('Could not read magic value.')\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "        \"\"\"\n        self.header = MachoHeaderStruct(self, 0)\n\n",
        "source_code_len": 62,
        "target_code": "        \"\"\"\n        self._header = MachoHeaderStruct(self, 0)\n\n",
        "target_code_len": 63,
        "diff_format": "@@ -152,3 +163,3 @@\n         \"\"\"\n-        self.header = MachoHeaderStruct(self, 0)\n+        self._header = MachoHeaderStruct(self, 0)\n \n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\n        self.header = MachoHeaderStruct(self, 0)\n\n",
        "target_code_with_indent": "\n        self._header = MachoHeaderStruct(self, 0)\n\n"
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "                                      MachoLoadCommands.LC_ENCRYPTION_INFO_64]:\n                self.encryption_info = MachoEncryptionInfoStruct(self, offset)\n\n            elif load_command.cmd == MachoLoadCommands.LC_SYMTAB:\n                self.symtab = MachoSymtabCommandStruct(self, offset)\n\n            elif load_command.cmd == MachoLoadCommands.LC_DYSYMTAB:\n                self.dysymtab = MachoDysymtabCommandStruct(self, offset)\n\n            elif load_command.cmd in [MachoLoadCommands.LC_DYLD_INFO, MachoLoadCommands.LC_DYLD_INFO_ONLY]:\n                self.dyld_info = MachoDyldInfoCommandStruct(self, offset)\n\n",
        "source_code_len": 621,
        "target_code": "                                      MachoLoadCommands.LC_ENCRYPTION_INFO_64]:\n                self._encryption_info = MachoEncryptionInfoStruct(self, offset)\n\n            elif load_command.cmd == MachoLoadCommands.LC_SYMTAB:\n                self._symtab = MachoSymtabCommandStruct(self, offset)\n\n            elif load_command.cmd == MachoLoadCommands.LC_DYSYMTAB:\n                self._dysymtab = MachoDysymtabCommandStruct(self, offset)\n\n            elif load_command.cmd in [MachoLoadCommands.LC_DYLD_INFO, MachoLoadCommands.LC_DYLD_INFO_ONLY]:\n                self._dyld_info = MachoDyldInfoCommandStruct(self, offset)\n\n",
        "target_code_len": 625,
        "diff_format": "@@ -208,12 +220,12 @@\n                                       MachoLoadCommands.LC_ENCRYPTION_INFO_64]:\n-                self.encryption_info = MachoEncryptionInfoStruct(self, offset)\n+                self._encryption_info = MachoEncryptionInfoStruct(self, offset)\n \n             elif load_command.cmd == MachoLoadCommands.LC_SYMTAB:\n-                self.symtab = MachoSymtabCommandStruct(self, offset)\n+                self._symtab = MachoSymtabCommandStruct(self, offset)\n \n             elif load_command.cmd == MachoLoadCommands.LC_DYSYMTAB:\n-                self.dysymtab = MachoDysymtabCommandStruct(self, offset)\n+                self._dysymtab = MachoDysymtabCommandStruct(self, offset)\n \n             elif load_command.cmd in [MachoLoadCommands.LC_DYLD_INFO, MachoLoadCommands.LC_DYLD_INFO_ONLY]:\n-                self.dyld_info = MachoDyldInfoCommandStruct(self, offset)\n+                self._dyld_info = MachoDyldInfoCommandStruct(self, offset)\n \n",
        "source_code_with_indent": "                                      MachoLoadCommands.LC_ENCRYPTION_INFO_64]:\n                <IND>self.encryption_info = MachoEncryptionInfoStruct(self, offset)\n\n            <DED>elif load_command.cmd == MachoLoadCommands.LC_SYMTAB:\n                <IND>self.symtab = MachoSymtabCommandStruct(self, offset)\n\n            <DED>elif load_command.cmd == MachoLoadCommands.LC_DYSYMTAB:\n                <IND>self.dysymtab = MachoDysymtabCommandStruct(self, offset)\n\n            <DED>elif load_command.cmd in [MachoLoadCommands.LC_DYLD_INFO, MachoLoadCommands.LC_DYLD_INFO_ONLY]:\n                <IND>self.dyld_info = MachoDyldInfoCommandStruct(self, offset)\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "                                      MachoLoadCommands.LC_ENCRYPTION_INFO_64]:\n                <IND>self._encryption_info = MachoEncryptionInfoStruct(self, offset)\n\n            <DED>elif load_command.cmd == MachoLoadCommands.LC_SYMTAB:\n                <IND>self._symtab = MachoSymtabCommandStruct(self, offset)\n\n            <DED>elif load_command.cmd == MachoLoadCommands.LC_DYSYMTAB:\n                <IND>self._dysymtab = MachoDysymtabCommandStruct(self, offset)\n\n            <DED>elif load_command.cmd in [MachoLoadCommands.LC_DYLD_INFO, MachoLoadCommands.LC_DYLD_INFO_ONLY]:\n                <IND>self._dyld_info = MachoDyldInfoCommandStruct(self, offset)\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "            elif load_command.cmd == MachoLoadCommands.LC_CODE_SIGNATURE:\n                self.code_signature_cmd = MachoLinkeditDataCommandStruct(self, offset)\n\n",
        "source_code_len": 162,
        "target_code": "            elif load_command.cmd == MachoLoadCommands.LC_CODE_SIGNATURE:\n                self._code_signature_cmd = MachoLinkeditDataCommandStruct(self, offset)\n\n",
        "target_code_len": 163,
        "diff_format": "@@ -225,3 +236,3 @@\n             elif load_command.cmd == MachoLoadCommands.LC_CODE_SIGNATURE:\n-                self.code_signature_cmd = MachoLinkeditDataCommandStruct(self, offset)\n+                self._code_signature_cmd = MachoLinkeditDataCommandStruct(self, offset)\n \n",
        "source_code_with_indent": "            <DED>elif load_command.cmd == MachoLoadCommands.LC_CODE_SIGNATURE:\n                <IND>self.code_signature_cmd = MachoLinkeditDataCommandStruct(self, offset)\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "            <DED>elif load_command.cmd == MachoLoadCommands.LC_CODE_SIGNATURE:\n                <IND>self._code_signature_cmd = MachoLinkeditDataCommandStruct(self, offset)\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "            indirect_symtab_entry = self.read_word(indirect_symtab_off, virtual=False, word_type=c_uint32)\n            indirect_symtab.append(int(indirect_symtab_entry.value))\n            # traverse to next pointer\n",
        "source_code_len": 215,
        "target_code": "            indirect_symtab_entry = self.read_word(indirect_symtab_off, virtual=False, word_type=c_uint32)\n            if not indirect_symtab_entry:\n                continue\n            indirect_symtab.append(int(indirect_symtab_entry))\n            # traverse to next pointer\n",
        "target_code_len": 276,
        "diff_format": "@@ -398,3 +410,5 @@\n             indirect_symtab_entry = self.read_word(indirect_symtab_off, virtual=False, word_type=c_uint32)\n-            indirect_symtab.append(int(indirect_symtab_entry.value))\n+            if not indirect_symtab_entry:\n+                continue\n+            indirect_symtab.append(int(indirect_symtab_entry))\n             # traverse to next pointer\n",
        "source_code_with_indent": "            <IND>indirect_symtab_entry = self.read_word(indirect_symtab_off, virtual=False, word_type=c_uint32)\n            indirect_symtab.append(int(indirect_symtab_entry.value))\n            # traverse to next pointer\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "            <IND>indirect_symtab_entry = self.read_word(indirect_symtab_off, virtual=False, word_type=c_uint32)\n            if not indirect_symtab_entry:\n                <IND>continue\n            <DED>indirect_symtab.append(int(indirect_symtab_entry))\n            # traverse to next pointer\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "                  address: int,\n                  virtual=True,\n                  word_type=None) -> Optional[Union[c_uint32, c_uint64]]:\n        \"\"\"Attempt to read a word from the binary at a virtual address. Returns None if the address is invalid.\n",
        "source_code_len": 250,
        "target_code": "                  address: int,\n                  virtual: bool = True,\n                  word_type: Any = None) -> Optional[int]:\n        \"\"\"Attempt to read a word from the binary at a virtual address. Returns None if the address is invalid.\n",
        "target_code_len": 243,
        "diff_format": "@@ -568,4 +595,4 @@\n                   address: int,\n-                  virtual=True,\n-                  word_type=None) -> Optional[Union[c_uint32, c_uint64]]:\n+                  virtual: bool = True,\n+                  word_type: Any = None) -> Optional[int]:\n         \"\"\"Attempt to read a word from the binary at a virtual address. Returns None if the address is invalid.\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "                  address: int,\n                  virtual=True,\n                  word_type=None) -> Optional[Union[c_uint32, c_uint64]]:\n        <IND>",
        "target_code_with_indent": "                  address: int,\n                  virtual: bool = True,\n                  word_type: Any = None) -> Optional[int]:\n        <IND>"
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    @property\n    def _codesign_parser(self) -> 'CodesignParser':\n        from strongarm.macho.codesign import CodesignParser\n        if not self.__codesign_parser:\n",
        "source_code_len": 165,
        "target_code": "    @property\n    def header(self) -> MachoHeaderStruct:\n        if self._header:\n            return self._header\n        else:\n            raise RuntimeError('Failed to parse Mach-O')\n\n    @property\n    def dysymtab(self) -> MachoDysymtabCommandStruct:\n        if self._dysymtab:\n            return self._dysymtab\n        else:\n            raise RuntimeError('Failed to parse Mach-O')\n\n    @property\n    def symtab(self) -> MachoSymtabCommandStruct:\n        if self._symtab:\n            return self._symtab\n        else:\n            raise RuntimeError('Failed to parse Mach-O')\n\n    @property\n    def encryption_info(self) -> MachoEncryptionInfoStruct:\n        if self._encryption_info:\n            return self._encryption_info\n        else:\n            raise RuntimeError('Failed to parse Mach-O')\n\n    @property\n    def dyld_info(self) -> MachoDyldInfoCommandStruct:\n        if self._dyld_info:\n            return self._dyld_info\n        else:\n            raise RuntimeError('Failed to parse Mach-O')\n\n    @property\n    def code_signature_cmd(self) -> MachoLinkeditDataCommandStruct:\n        if self._code_signature_cmd:\n            return self._code_signature_cmd\n        else:\n            raise RuntimeError('Failed to parse Mach-O')\n\n    @property\n    def _codesign_parser(self) -> 'CodesignParser':\n        if not self.__codesign_parser:\n",
        "target_code_len": 1345,
        "diff_format": "@@ -583,4 +613,45 @@\n     @property\n+    def header(self) -> MachoHeaderStruct:\n+        if self._header:\n+            return self._header\n+        else:\n+            raise RuntimeError('Failed to parse Mach-O')\n+\n+    @property\n+    def dysymtab(self) -> MachoDysymtabCommandStruct:\n+        if self._dysymtab:\n+            return self._dysymtab\n+        else:\n+            raise RuntimeError('Failed to parse Mach-O')\n+\n+    @property\n+    def symtab(self) -> MachoSymtabCommandStruct:\n+        if self._symtab:\n+            return self._symtab\n+        else:\n+            raise RuntimeError('Failed to parse Mach-O')\n+\n+    @property\n+    def encryption_info(self) -> MachoEncryptionInfoStruct:\n+        if self._encryption_info:\n+            return self._encryption_info\n+        else:\n+            raise RuntimeError('Failed to parse Mach-O')\n+\n+    @property\n+    def dyld_info(self) -> MachoDyldInfoCommandStruct:\n+        if self._dyld_info:\n+            return self._dyld_info\n+        else:\n+            raise RuntimeError('Failed to parse Mach-O')\n+\n+    @property\n+    def code_signature_cmd(self) -> MachoLinkeditDataCommandStruct:\n+        if self._code_signature_cmd:\n+            return self._code_signature_cmd\n+        else:\n+            raise RuntimeError('Failed to parse Mach-O')\n+\n+    @property\n     def _codesign_parser(self) -> 'CodesignParser':\n-        from strongarm.macho.codesign import CodesignParser\n         if not self.__codesign_parser:\n",
        "source_code_with_indent": "    <DED>@property\n    def _codesign_parser(self) -> 'CodesignParser':\n        <IND>from strongarm.macho.codesign import CodesignParser\n        if not self.__codesign_parser:\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    <DED>@property\n    def header(self) -> MachoHeaderStruct:\n        <IND>if self._header:\n            <IND>return self._header\n        <DED>else:\n            <IND>raise RuntimeError('Failed to parse Mach-O')\n\n    <DED><DED>@property\n    def dysymtab(self) -> MachoDysymtabCommandStruct:\n        <IND>if self._dysymtab:\n            <IND>return self._dysymtab\n        <DED>else:\n            <IND>raise RuntimeError('Failed to parse Mach-O')\n\n    <DED><DED>@property\n    def symtab(self) -> MachoSymtabCommandStruct:\n        <IND>if self._symtab:\n            <IND>return self._symtab\n        <DED>else:\n            <IND>raise RuntimeError('Failed to parse Mach-O')\n\n    <DED><DED>@property\n    def encryption_info(self) -> MachoEncryptionInfoStruct:\n        <IND>if self._encryption_info:\n            <IND>return self._encryption_info\n        <DED>else:\n            <IND>raise RuntimeError('Failed to parse Mach-O')\n\n    <DED><DED>@property\n    def dyld_info(self) -> MachoDyldInfoCommandStruct:\n        <IND>if self._dyld_info:\n            <IND>return self._dyld_info\n        <DED>else:\n            <IND>raise RuntimeError('Failed to parse Mach-O')\n\n    <DED><DED>@property\n    def code_signature_cmd(self) -> MachoLinkeditDataCommandStruct:\n        <IND>if self._code_signature_cmd:\n            <IND>return self._code_signature_cmd\n        <DED>else:\n            <IND>raise RuntimeError('Failed to parse Mach-O')\n\n    <DED><DED>@property\n    def _codesign_parser(self) -> 'CodesignParser':\n        <IND>if not self.__codesign_parser:\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "datatheorem/strongarm",
    "commit": "ab620d78b4ce7f933cedc25960307f2c3b03c1a8",
    "filename": "strongarm/macho/macho_binary.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/datatheorem-strongarm/strongarm/macho/macho_binary.py",
    "file_hunks_size": 33,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "strongarm/macho/macho_binary.py:128:8 Incompatible return type [7]: Expected `c_uint32` but got `Union[None, c_uint32, c_uint64]`.",
    "message": " Expected `c_uint32` but got `Union[None, c_uint32, c_uint64]`.",
    "rule_id": "Incompatible return type [7]",
    "warning_line_no": 128,
    "warning_line": "        return self.read_word(0, virtual=False, word_type=c_uint32)",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "# -*- coding: utf-8 -*-\nfrom typing import List, Tuple, Optional, Dict, Union\n\n",
        "source_code_len": 79,
        "target_code": "# -*- coding: utf-8 -*-\nfrom typing import List, Dict, Tuple, Any, Type, Optional\nfrom typing import TYPE_CHECKING\n\nfrom ctypes import c_uint64, c_uint32, sizeof\n\n",
        "target_code_len": 163,
        "diff_format": "@@ -1,3 +1,6 @@\n # -*- coding: utf-8 -*-\n-from typing import List, Tuple, Optional, Dict, Union\n+from typing import List, Dict, Tuple, Any, Type, Optional\n+from typing import TYPE_CHECKING\n+\n+from ctypes import c_uint64, c_uint32, sizeof\n \n",
        "source_code_with_indent": "# -*- coding: utf-8 -*-\nfrom typing import List, Tuple, Optional, Dict, Union\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "# -*- coding: utf-8 -*-\nfrom typing import List, Dict, Tuple, Any, Type, Optional\nfrom typing import TYPE_CHECKING\n\nfrom ctypes import c_uint64, c_uint32, sizeof\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "from strongarm.macho.macho_load_commands import MachoLoadCommands\nfrom strongarm.macho.arch_independent_structs import \\\n    MachoHeaderStruct, \\\n    MachoSegmentCommandStruct, \\\n    MachoSectionRawStruct, \\\n    MachoEncryptionInfoStruct, \\\n    MachoNlistStruct, \\\n    CFStringStruct, \\\n    DylibCommandStruct, \\\n    MachoLoadCommandStruct, \\\n    MachoSymtabCommandStruct, \\\n    MachoDysymtabCommandStruct, \\\n    MachoDyldInfoCommandStruct, \\\n    MachoLinkeditDataCommandStruct\n\nfrom ctypes import c_uint64, c_uint32, sizeof\n\n",
        "source_code_len": 526,
        "target_code": "from strongarm.macho.macho_load_commands import MachoLoadCommands\nfrom strongarm.macho.arch_independent_structs import (\n    ArchIndependentStructure,\n    MachoHeaderStruct,\n    MachoSegmentCommandStruct,\n    MachoSectionRawStruct,\n    MachoEncryptionInfoStruct,\n    MachoNlistStruct,\n    CFStringStruct,\n    DylibCommandStruct,\n    MachoLoadCommandStruct,\n    MachoSymtabCommandStruct,\n    MachoDysymtabCommandStruct,\n    MachoDyldInfoCommandStruct,\n    MachoLinkeditDataCommandStruct,\n)\n\nif TYPE_CHECKING:\n    from strongarm.macho.codesign import CodesignParser\n\n",
        "target_code_len": 565,
        "diff_format": "@@ -7,17 +10,20 @@\n from strongarm.macho.macho_load_commands import MachoLoadCommands\n-from strongarm.macho.arch_independent_structs import \\\n-    MachoHeaderStruct, \\\n-    MachoSegmentCommandStruct, \\\n-    MachoSectionRawStruct, \\\n-    MachoEncryptionInfoStruct, \\\n-    MachoNlistStruct, \\\n-    CFStringStruct, \\\n-    DylibCommandStruct, \\\n-    MachoLoadCommandStruct, \\\n-    MachoSymtabCommandStruct, \\\n-    MachoDysymtabCommandStruct, \\\n-    MachoDyldInfoCommandStruct, \\\n-    MachoLinkeditDataCommandStruct\n-\n-from ctypes import c_uint64, c_uint32, sizeof\n+from strongarm.macho.arch_independent_structs import (\n+    ArchIndependentStructure,\n+    MachoHeaderStruct,\n+    MachoSegmentCommandStruct,\n+    MachoSectionRawStruct,\n+    MachoEncryptionInfoStruct,\n+    MachoNlistStruct,\n+    CFStringStruct,\n+    DylibCommandStruct,\n+    MachoLoadCommandStruct,\n+    MachoSymtabCommandStruct,\n+    MachoDysymtabCommandStruct,\n+    MachoDyldInfoCommandStruct,\n+    MachoLinkeditDataCommandStruct,\n+)\n+\n+if TYPE_CHECKING:\n+    from strongarm.macho.codesign import CodesignParser\n \n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent": "from strongarm.macho.macho_load_commands import MachoLoadCommands\nfrom strongarm.macho.arch_independent_structs import (\n    ArchIndependentStructure,\n    MachoHeaderStruct,\n    MachoSegmentCommandStruct,\n    MachoSectionRawStruct,\n    MachoEncryptionInfoStruct,\n    MachoNlistStruct,\n    CFStringStruct,\n    DylibCommandStruct,\n    MachoLoadCommandStruct,\n    MachoSymtabCommandStruct,\n    MachoDysymtabCommandStruct,\n    MachoDyldInfoCommandStruct,\n    MachoLinkeditDataCommandStruct,\n)\n\nif TYPE_CHECKING:\n    <IND>from strongarm.macho.codesign import CodesignParser\n\n",
        "target_code_with_indent_exact_match": true,
        "source_code_with_indent": "from strongarm.macho.macho_load_commands import MachoLoadCommands\nfrom strongarm.macho.arch_independent_structs import    MachoHeaderStruct,    MachoSegmentCommandStruct,    MachoSectionRawStruct,    MachoEncryptionInfoStruct,    MachoNlistStruct,    CFStringStruct,    DylibCommandStruct,    MachoLoadCommandStruct,    MachoSymtabCommandStruct,    MachoDysymtabCommandStruct,    MachoDyldInfoCommandStruct,    MachoLinkeditDataCommandStruct\n\nfrom ctypes import c_uint64, c_uint32, sizeof\n\n"
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "        # generic Mach-O header info\n        self.is_64bit: bool = None\n        self.is_swap: bool = None\n        self.cpu_type: CPU_TYPE = None\n        self._load_commands_end_addr = None\n\n        # Mach-O header data\n        self.header: MachoHeaderStruct = None\n        self.header_flags: List[int] = None\n        self.file_type: MachoFileType = None\n\n        # segment and section commands from Mach-O header\n        self.segment_commands: Dict[str, MachoSegmentCommandStruct] = None\n        self.sections: Dict[str, MachoSection] = None\n        # also store specific interesting sections which are useful to us\n        self.dysymtab: MachoDysymtabCommandStruct = None\n        self.symtab: MachoSymtabCommandStruct = None\n        self.encryption_info: MachoEncryptionInfoStruct = None\n        self.dyld_info: MachoDyldInfoCommandStruct = None\n        self.load_dylib_commands: List[DylibCommandStruct] = None\n        self.code_signature_cmd: MachoLinkeditDataCommandStruct = None\n\n        self.__codesign_parser: CodesignParser = None\n\n",
        "source_code_len": 1040,
        "target_code": "        # generic Mach-O header info\n        self.is_64bit: bool = False\n        self.is_swap: bool = False\n        self.cpu_type: CPU_TYPE = CPU_TYPE.UNKNOWN\n        self._load_commands_end_addr = 0\n\n        # Mach-O header data\n        self._header: Optional[MachoHeaderStruct] = None\n        self.header_flags: List[int] = []\n        self.file_type: MachoFileType = MachoFileType.MH_EXECUTE\n\n        # segment and section commands from Mach-O header\n        self.segment_commands: Dict[str, MachoSegmentCommandStruct] = {}\n        self.sections: Dict[str, MachoSection] = {}\n        # also store specific interesting sections which are useful to us\n        self._dysymtab: Optional[MachoDysymtabCommandStruct] = None\n        self._symtab: Optional[MachoSymtabCommandStruct] = None\n        self._encryption_info: Optional[MachoEncryptionInfoStruct] = None\n        self._dyld_info: Optional[MachoDyldInfoCommandStruct] = None\n        self.load_dylib_commands: List[DylibCommandStruct] = []\n        self._code_signature_cmd: Optional[MachoLinkeditDataCommandStruct] = None\n\n        self.__codesign_parser: Optional[CodesignParser] = None\n\n",
        "target_code_len": 1139,
        "diff_format": "@@ -62,24 +68,24 @@\n         # generic Mach-O header info\n-        self.is_64bit: bool = None\n-        self.is_swap: bool = None\n-        self.cpu_type: CPU_TYPE = None\n-        self._load_commands_end_addr = None\n+        self.is_64bit: bool = False\n+        self.is_swap: bool = False\n+        self.cpu_type: CPU_TYPE = CPU_TYPE.UNKNOWN\n+        self._load_commands_end_addr = 0\n \n         # Mach-O header data\n-        self.header: MachoHeaderStruct = None\n-        self.header_flags: List[int] = None\n-        self.file_type: MachoFileType = None\n+        self._header: Optional[MachoHeaderStruct] = None\n+        self.header_flags: List[int] = []\n+        self.file_type: MachoFileType = MachoFileType.MH_EXECUTE\n \n         # segment and section commands from Mach-O header\n-        self.segment_commands: Dict[str, MachoSegmentCommandStruct] = None\n-        self.sections: Dict[str, MachoSection] = None\n+        self.segment_commands: Dict[str, MachoSegmentCommandStruct] = {}\n+        self.sections: Dict[str, MachoSection] = {}\n         # also store specific interesting sections which are useful to us\n-        self.dysymtab: MachoDysymtabCommandStruct = None\n-        self.symtab: MachoSymtabCommandStruct = None\n-        self.encryption_info: MachoEncryptionInfoStruct = None\n-        self.dyld_info: MachoDyldInfoCommandStruct = None\n-        self.load_dylib_commands: List[DylibCommandStruct] = None\n-        self.code_signature_cmd: MachoLinkeditDataCommandStruct = None\n-\n-        self.__codesign_parser: CodesignParser = None\n+        self._dysymtab: Optional[MachoDysymtabCommandStruct] = None\n+        self._symtab: Optional[MachoSymtabCommandStruct] = None\n+        self._encryption_info: Optional[MachoEncryptionInfoStruct] = None\n+        self._dyld_info: Optional[MachoDyldInfoCommandStruct] = None\n+        self.load_dylib_commands: List[DylibCommandStruct] = []\n+        self._code_signature_cmd: Optional[MachoLinkeditDataCommandStruct] = None\n+\n+        self.__codesign_parser: Optional[CodesignParser] = None\n \n",
        "source_code_with_indent": "        # generic Mach-O header info\n        self.is_64bit: bool = None\n        self.is_swap: bool = None\n        self.cpu_type: CPU_TYPE = None\n        self._load_commands_end_addr = None\n\n        # Mach-O header data\n        self.header: MachoHeaderStruct = None\n        self.header_flags: List[int] = None\n        self.file_type: MachoFileType = None\n\n        # segment and section commands from Mach-O header\n        self.segment_commands: Dict[str, MachoSegmentCommandStruct] = None\n        self.sections: Dict[str, MachoSection] = None\n        # also store specific interesting sections which are useful to us\n        self.dysymtab: MachoDysymtabCommandStruct = None\n        self.symtab: MachoSymtabCommandStruct = None\n        self.encryption_info: MachoEncryptionInfoStruct = None\n        self.dyld_info: MachoDyldInfoCommandStruct = None\n        self.load_dylib_commands: List[DylibCommandStruct] = None\n        self.code_signature_cmd: MachoLinkeditDataCommandStruct = None\n\n        self.__codesign_parser: CodesignParser = None\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "        # generic Mach-O header info\n        self.is_64bit: bool = False\n        self.is_swap: bool = False\n        self.cpu_type: CPU_TYPE = CPU_TYPE.UNKNOWN\n        self._load_commands_end_addr = 0\n\n        # Mach-O header data\n        self._header: Optional[MachoHeaderStruct] = None\n        self.header_flags: List[int] = []\n        self.file_type: MachoFileType = MachoFileType.MH_EXECUTE\n\n        # segment and section commands from Mach-O header\n        self.segment_commands: Dict[str, MachoSegmentCommandStruct] = {}\n        self.sections: Dict[str, MachoSection] = {}\n        # also store specific interesting sections which are useful to us\n        self._dysymtab: Optional[MachoDysymtabCommandStruct] = None\n        self._symtab: Optional[MachoSymtabCommandStruct] = None\n        self._encryption_info: Optional[MachoEncryptionInfoStruct] = None\n        self._dyld_info: Optional[MachoDyldInfoCommandStruct] = None\n        self.load_dylib_commands: List[DylibCommandStruct] = []\n        self._code_signature_cmd: Optional[MachoLinkeditDataCommandStruct] = None\n\n        self.__codesign_parser: Optional[CodesignParser] = None\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    @property\n    def slice_magic(self) -> c_uint32:\n        \"\"\"Read magic number identifier from this Mach-O slice\n        \"\"\"\n        return self.read_word(0, virtual=False, word_type=c_uint32)\n\n",
        "source_code_len": 197,
        "target_code": "    @property\n    def slice_magic(self) -> int:\n        \"\"\"Read magic number identifier from this Mach-O slice\n        \"\"\"\n        magic = self.read_word(0, virtual=False, word_type=c_uint32)\n        if magic:\n            return magic\n        else:\n            raise ValueError('Could not read magic value.')\n\n",
        "target_code_len": 310,
        "diff_format": "@@ -124,6 +131,10 @@\n     @property\n-    def slice_magic(self) -> c_uint32:\n+    def slice_magic(self) -> int:\n         \"\"\"Read magic number identifier from this Mach-O slice\n         \"\"\"\n-        return self.read_word(0, virtual=False, word_type=c_uint32)\n+        magic = self.read_word(0, virtual=False, word_type=c_uint32)\n+        if magic:\n+            return magic\n+        else:\n+            raise ValueError('Could not read magic value.')\n \n",
        "source_code_with_indent": "    <DED>@property\n    def slice_magic(self) -> c_uint32:\n        <IND>\"\"\"Read magic number identifier from this Mach-O slice\n        \"\"\"\n        return self.read_word(0, virtual=False, word_type=c_uint32)\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    <DED>@property\n    def slice_magic(self) -> int:\n        <IND>\"\"\"Read magic number identifier from this Mach-O slice\n        \"\"\"\n        magic = self.read_word(0, virtual=False, word_type=c_uint32)\n        if magic:\n            <IND>return magic\n        <DED>else:\n            <IND>raise ValueError('Could not read magic value.')\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "        \"\"\"\n        self.header = MachoHeaderStruct(self, 0)\n\n",
        "source_code_len": 62,
        "target_code": "        \"\"\"\n        self._header = MachoHeaderStruct(self, 0)\n\n",
        "target_code_len": 63,
        "diff_format": "@@ -152,3 +163,3 @@\n         \"\"\"\n-        self.header = MachoHeaderStruct(self, 0)\n+        self._header = MachoHeaderStruct(self, 0)\n \n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\n        self.header = MachoHeaderStruct(self, 0)\n\n",
        "target_code_with_indent": "\n        self._header = MachoHeaderStruct(self, 0)\n\n"
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "                                      MachoLoadCommands.LC_ENCRYPTION_INFO_64]:\n                self.encryption_info = MachoEncryptionInfoStruct(self, offset)\n\n            elif load_command.cmd == MachoLoadCommands.LC_SYMTAB:\n                self.symtab = MachoSymtabCommandStruct(self, offset)\n\n            elif load_command.cmd == MachoLoadCommands.LC_DYSYMTAB:\n                self.dysymtab = MachoDysymtabCommandStruct(self, offset)\n\n            elif load_command.cmd in [MachoLoadCommands.LC_DYLD_INFO, MachoLoadCommands.LC_DYLD_INFO_ONLY]:\n                self.dyld_info = MachoDyldInfoCommandStruct(self, offset)\n\n",
        "source_code_len": 621,
        "target_code": "                                      MachoLoadCommands.LC_ENCRYPTION_INFO_64]:\n                self._encryption_info = MachoEncryptionInfoStruct(self, offset)\n\n            elif load_command.cmd == MachoLoadCommands.LC_SYMTAB:\n                self._symtab = MachoSymtabCommandStruct(self, offset)\n\n            elif load_command.cmd == MachoLoadCommands.LC_DYSYMTAB:\n                self._dysymtab = MachoDysymtabCommandStruct(self, offset)\n\n            elif load_command.cmd in [MachoLoadCommands.LC_DYLD_INFO, MachoLoadCommands.LC_DYLD_INFO_ONLY]:\n                self._dyld_info = MachoDyldInfoCommandStruct(self, offset)\n\n",
        "target_code_len": 625,
        "diff_format": "@@ -208,12 +220,12 @@\n                                       MachoLoadCommands.LC_ENCRYPTION_INFO_64]:\n-                self.encryption_info = MachoEncryptionInfoStruct(self, offset)\n+                self._encryption_info = MachoEncryptionInfoStruct(self, offset)\n \n             elif load_command.cmd == MachoLoadCommands.LC_SYMTAB:\n-                self.symtab = MachoSymtabCommandStruct(self, offset)\n+                self._symtab = MachoSymtabCommandStruct(self, offset)\n \n             elif load_command.cmd == MachoLoadCommands.LC_DYSYMTAB:\n-                self.dysymtab = MachoDysymtabCommandStruct(self, offset)\n+                self._dysymtab = MachoDysymtabCommandStruct(self, offset)\n \n             elif load_command.cmd in [MachoLoadCommands.LC_DYLD_INFO, MachoLoadCommands.LC_DYLD_INFO_ONLY]:\n-                self.dyld_info = MachoDyldInfoCommandStruct(self, offset)\n+                self._dyld_info = MachoDyldInfoCommandStruct(self, offset)\n \n",
        "source_code_with_indent": "                                      MachoLoadCommands.LC_ENCRYPTION_INFO_64]:\n                <IND>self.encryption_info = MachoEncryptionInfoStruct(self, offset)\n\n            <DED>elif load_command.cmd == MachoLoadCommands.LC_SYMTAB:\n                <IND>self.symtab = MachoSymtabCommandStruct(self, offset)\n\n            <DED>elif load_command.cmd == MachoLoadCommands.LC_DYSYMTAB:\n                <IND>self.dysymtab = MachoDysymtabCommandStruct(self, offset)\n\n            <DED>elif load_command.cmd in [MachoLoadCommands.LC_DYLD_INFO, MachoLoadCommands.LC_DYLD_INFO_ONLY]:\n                <IND>self.dyld_info = MachoDyldInfoCommandStruct(self, offset)\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "                                      MachoLoadCommands.LC_ENCRYPTION_INFO_64]:\n                <IND>self._encryption_info = MachoEncryptionInfoStruct(self, offset)\n\n            <DED>elif load_command.cmd == MachoLoadCommands.LC_SYMTAB:\n                <IND>self._symtab = MachoSymtabCommandStruct(self, offset)\n\n            <DED>elif load_command.cmd == MachoLoadCommands.LC_DYSYMTAB:\n                <IND>self._dysymtab = MachoDysymtabCommandStruct(self, offset)\n\n            <DED>elif load_command.cmd in [MachoLoadCommands.LC_DYLD_INFO, MachoLoadCommands.LC_DYLD_INFO_ONLY]:\n                <IND>self._dyld_info = MachoDyldInfoCommandStruct(self, offset)\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "            elif load_command.cmd == MachoLoadCommands.LC_CODE_SIGNATURE:\n                self.code_signature_cmd = MachoLinkeditDataCommandStruct(self, offset)\n\n",
        "source_code_len": 162,
        "target_code": "            elif load_command.cmd == MachoLoadCommands.LC_CODE_SIGNATURE:\n                self._code_signature_cmd = MachoLinkeditDataCommandStruct(self, offset)\n\n",
        "target_code_len": 163,
        "diff_format": "@@ -225,3 +236,3 @@\n             elif load_command.cmd == MachoLoadCommands.LC_CODE_SIGNATURE:\n-                self.code_signature_cmd = MachoLinkeditDataCommandStruct(self, offset)\n+                self._code_signature_cmd = MachoLinkeditDataCommandStruct(self, offset)\n \n",
        "source_code_with_indent": "            <DED>elif load_command.cmd == MachoLoadCommands.LC_CODE_SIGNATURE:\n                <IND>self.code_signature_cmd = MachoLinkeditDataCommandStruct(self, offset)\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "            <DED>elif load_command.cmd == MachoLoadCommands.LC_CODE_SIGNATURE:\n                <IND>self._code_signature_cmd = MachoLinkeditDataCommandStruct(self, offset)\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "            indirect_symtab_entry = self.read_word(indirect_symtab_off, virtual=False, word_type=c_uint32)\n            indirect_symtab.append(int(indirect_symtab_entry.value))\n            # traverse to next pointer\n",
        "source_code_len": 215,
        "target_code": "            indirect_symtab_entry = self.read_word(indirect_symtab_off, virtual=False, word_type=c_uint32)\n            if not indirect_symtab_entry:\n                continue\n            indirect_symtab.append(int(indirect_symtab_entry))\n            # traverse to next pointer\n",
        "target_code_len": 276,
        "diff_format": "@@ -398,3 +410,5 @@\n             indirect_symtab_entry = self.read_word(indirect_symtab_off, virtual=False, word_type=c_uint32)\n-            indirect_symtab.append(int(indirect_symtab_entry.value))\n+            if not indirect_symtab_entry:\n+                continue\n+            indirect_symtab.append(int(indirect_symtab_entry))\n             # traverse to next pointer\n",
        "source_code_with_indent": "            <IND>indirect_symtab_entry = self.read_word(indirect_symtab_off, virtual=False, word_type=c_uint32)\n            indirect_symtab.append(int(indirect_symtab_entry.value))\n            # traverse to next pointer\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "            <IND>indirect_symtab_entry = self.read_word(indirect_symtab_off, virtual=False, word_type=c_uint32)\n            if not indirect_symtab_entry:\n                <IND>continue\n            <DED>indirect_symtab.append(int(indirect_symtab_entry))\n            # traverse to next pointer\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "                  address: int,\n                  virtual=True,\n                  word_type=None) -> Optional[Union[c_uint32, c_uint64]]:\n        \"\"\"Attempt to read a word from the binary at a virtual address. Returns None if the address is invalid.\n",
        "source_code_len": 250,
        "target_code": "                  address: int,\n                  virtual: bool = True,\n                  word_type: Any = None) -> Optional[int]:\n        \"\"\"Attempt to read a word from the binary at a virtual address. Returns None if the address is invalid.\n",
        "target_code_len": 243,
        "diff_format": "@@ -568,4 +595,4 @@\n                   address: int,\n-                  virtual=True,\n-                  word_type=None) -> Optional[Union[c_uint32, c_uint64]]:\n+                  virtual: bool = True,\n+                  word_type: Any = None) -> Optional[int]:\n         \"\"\"Attempt to read a word from the binary at a virtual address. Returns None if the address is invalid.\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "                  address: int,\n                  virtual=True,\n                  word_type=None) -> Optional[Union[c_uint32, c_uint64]]:\n        <IND>",
        "target_code_with_indent": "                  address: int,\n                  virtual: bool = True,\n                  word_type: Any = None) -> Optional[int]:\n        <IND>"
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    @property\n    def _codesign_parser(self) -> 'CodesignParser':\n        from strongarm.macho.codesign import CodesignParser\n        if not self.__codesign_parser:\n",
        "source_code_len": 165,
        "target_code": "    @property\n    def header(self) -> MachoHeaderStruct:\n        if self._header:\n            return self._header\n        else:\n            raise RuntimeError('Failed to parse Mach-O')\n\n    @property\n    def dysymtab(self) -> MachoDysymtabCommandStruct:\n        if self._dysymtab:\n            return self._dysymtab\n        else:\n            raise RuntimeError('Failed to parse Mach-O')\n\n    @property\n    def symtab(self) -> MachoSymtabCommandStruct:\n        if self._symtab:\n            return self._symtab\n        else:\n            raise RuntimeError('Failed to parse Mach-O')\n\n    @property\n    def encryption_info(self) -> MachoEncryptionInfoStruct:\n        if self._encryption_info:\n            return self._encryption_info\n        else:\n            raise RuntimeError('Failed to parse Mach-O')\n\n    @property\n    def dyld_info(self) -> MachoDyldInfoCommandStruct:\n        if self._dyld_info:\n            return self._dyld_info\n        else:\n            raise RuntimeError('Failed to parse Mach-O')\n\n    @property\n    def code_signature_cmd(self) -> MachoLinkeditDataCommandStruct:\n        if self._code_signature_cmd:\n            return self._code_signature_cmd\n        else:\n            raise RuntimeError('Failed to parse Mach-O')\n\n    @property\n    def _codesign_parser(self) -> 'CodesignParser':\n        if not self.__codesign_parser:\n",
        "target_code_len": 1345,
        "diff_format": "@@ -583,4 +613,45 @@\n     @property\n+    def header(self) -> MachoHeaderStruct:\n+        if self._header:\n+            return self._header\n+        else:\n+            raise RuntimeError('Failed to parse Mach-O')\n+\n+    @property\n+    def dysymtab(self) -> MachoDysymtabCommandStruct:\n+        if self._dysymtab:\n+            return self._dysymtab\n+        else:\n+            raise RuntimeError('Failed to parse Mach-O')\n+\n+    @property\n+    def symtab(self) -> MachoSymtabCommandStruct:\n+        if self._symtab:\n+            return self._symtab\n+        else:\n+            raise RuntimeError('Failed to parse Mach-O')\n+\n+    @property\n+    def encryption_info(self) -> MachoEncryptionInfoStruct:\n+        if self._encryption_info:\n+            return self._encryption_info\n+        else:\n+            raise RuntimeError('Failed to parse Mach-O')\n+\n+    @property\n+    def dyld_info(self) -> MachoDyldInfoCommandStruct:\n+        if self._dyld_info:\n+            return self._dyld_info\n+        else:\n+            raise RuntimeError('Failed to parse Mach-O')\n+\n+    @property\n+    def code_signature_cmd(self) -> MachoLinkeditDataCommandStruct:\n+        if self._code_signature_cmd:\n+            return self._code_signature_cmd\n+        else:\n+            raise RuntimeError('Failed to parse Mach-O')\n+\n+    @property\n     def _codesign_parser(self) -> 'CodesignParser':\n-        from strongarm.macho.codesign import CodesignParser\n         if not self.__codesign_parser:\n",
        "source_code_with_indent": "    <DED>@property\n    def _codesign_parser(self) -> 'CodesignParser':\n        <IND>from strongarm.macho.codesign import CodesignParser\n        if not self.__codesign_parser:\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    <DED>@property\n    def header(self) -> MachoHeaderStruct:\n        <IND>if self._header:\n            <IND>return self._header\n        <DED>else:\n            <IND>raise RuntimeError('Failed to parse Mach-O')\n\n    <DED><DED>@property\n    def dysymtab(self) -> MachoDysymtabCommandStruct:\n        <IND>if self._dysymtab:\n            <IND>return self._dysymtab\n        <DED>else:\n            <IND>raise RuntimeError('Failed to parse Mach-O')\n\n    <DED><DED>@property\n    def symtab(self) -> MachoSymtabCommandStruct:\n        <IND>if self._symtab:\n            <IND>return self._symtab\n        <DED>else:\n            <IND>raise RuntimeError('Failed to parse Mach-O')\n\n    <DED><DED>@property\n    def encryption_info(self) -> MachoEncryptionInfoStruct:\n        <IND>if self._encryption_info:\n            <IND>return self._encryption_info\n        <DED>else:\n            <IND>raise RuntimeError('Failed to parse Mach-O')\n\n    <DED><DED>@property\n    def dyld_info(self) -> MachoDyldInfoCommandStruct:\n        <IND>if self._dyld_info:\n            <IND>return self._dyld_info\n        <DED>else:\n            <IND>raise RuntimeError('Failed to parse Mach-O')\n\n    <DED><DED>@property\n    def code_signature_cmd(self) -> MachoLinkeditDataCommandStruct:\n        <IND>if self._code_signature_cmd:\n            <IND>return self._code_signature_cmd\n        <DED>else:\n            <IND>raise RuntimeError('Failed to parse Mach-O')\n\n    <DED><DED>@property\n    def _codesign_parser(self) -> 'CodesignParser':\n        <IND>if not self.__codesign_parser:\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "datatheorem/strongarm",
    "commit": "ab620d78b4ce7f933cedc25960307f2c3b03c1a8",
    "filename": "strongarm/macho/macho_binary.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/datatheorem-strongarm/strongarm/macho/macho_binary.py",
    "file_hunks_size": 33,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "strongarm/macho/macho_binary.py:273:44 Incompatible parameter type [6]: Expected `str` for 1st positional only parameter to call `dict.__getitem__` but got `int`.",
    "message": " Expected `str` for 1st positional only parameter to call `dict.__getitem__` but got `int`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 273,
    "warning_line": "        max_segment = self.segment_commands[0]",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "# -*- coding: utf-8 -*-\nfrom typing import List, Tuple, Optional, Dict, Union\n\n",
        "source_code_len": 79,
        "target_code": "# -*- coding: utf-8 -*-\nfrom typing import List, Dict, Tuple, Any, Type, Optional\nfrom typing import TYPE_CHECKING\n\nfrom ctypes import c_uint64, c_uint32, sizeof\n\n",
        "target_code_len": 163,
        "diff_format": "@@ -1,3 +1,6 @@\n # -*- coding: utf-8 -*-\n-from typing import List, Tuple, Optional, Dict, Union\n+from typing import List, Dict, Tuple, Any, Type, Optional\n+from typing import TYPE_CHECKING\n+\n+from ctypes import c_uint64, c_uint32, sizeof\n \n",
        "source_code_with_indent": "# -*- coding: utf-8 -*-\nfrom typing import List, Tuple, Optional, Dict, Union\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "# -*- coding: utf-8 -*-\nfrom typing import List, Dict, Tuple, Any, Type, Optional\nfrom typing import TYPE_CHECKING\n\nfrom ctypes import c_uint64, c_uint32, sizeof\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "from strongarm.macho.macho_load_commands import MachoLoadCommands\nfrom strongarm.macho.arch_independent_structs import \\\n    MachoHeaderStruct, \\\n    MachoSegmentCommandStruct, \\\n    MachoSectionRawStruct, \\\n    MachoEncryptionInfoStruct, \\\n    MachoNlistStruct, \\\n    CFStringStruct, \\\n    DylibCommandStruct, \\\n    MachoLoadCommandStruct, \\\n    MachoSymtabCommandStruct, \\\n    MachoDysymtabCommandStruct, \\\n    MachoDyldInfoCommandStruct, \\\n    MachoLinkeditDataCommandStruct\n\nfrom ctypes import c_uint64, c_uint32, sizeof\n\n",
        "source_code_len": 526,
        "target_code": "from strongarm.macho.macho_load_commands import MachoLoadCommands\nfrom strongarm.macho.arch_independent_structs import (\n    ArchIndependentStructure,\n    MachoHeaderStruct,\n    MachoSegmentCommandStruct,\n    MachoSectionRawStruct,\n    MachoEncryptionInfoStruct,\n    MachoNlistStruct,\n    CFStringStruct,\n    DylibCommandStruct,\n    MachoLoadCommandStruct,\n    MachoSymtabCommandStruct,\n    MachoDysymtabCommandStruct,\n    MachoDyldInfoCommandStruct,\n    MachoLinkeditDataCommandStruct,\n)\n\nif TYPE_CHECKING:\n    from strongarm.macho.codesign import CodesignParser\n\n",
        "target_code_len": 565,
        "diff_format": "@@ -7,17 +10,20 @@\n from strongarm.macho.macho_load_commands import MachoLoadCommands\n-from strongarm.macho.arch_independent_structs import \\\n-    MachoHeaderStruct, \\\n-    MachoSegmentCommandStruct, \\\n-    MachoSectionRawStruct, \\\n-    MachoEncryptionInfoStruct, \\\n-    MachoNlistStruct, \\\n-    CFStringStruct, \\\n-    DylibCommandStruct, \\\n-    MachoLoadCommandStruct, \\\n-    MachoSymtabCommandStruct, \\\n-    MachoDysymtabCommandStruct, \\\n-    MachoDyldInfoCommandStruct, \\\n-    MachoLinkeditDataCommandStruct\n-\n-from ctypes import c_uint64, c_uint32, sizeof\n+from strongarm.macho.arch_independent_structs import (\n+    ArchIndependentStructure,\n+    MachoHeaderStruct,\n+    MachoSegmentCommandStruct,\n+    MachoSectionRawStruct,\n+    MachoEncryptionInfoStruct,\n+    MachoNlistStruct,\n+    CFStringStruct,\n+    DylibCommandStruct,\n+    MachoLoadCommandStruct,\n+    MachoSymtabCommandStruct,\n+    MachoDysymtabCommandStruct,\n+    MachoDyldInfoCommandStruct,\n+    MachoLinkeditDataCommandStruct,\n+)\n+\n+if TYPE_CHECKING:\n+    from strongarm.macho.codesign import CodesignParser\n \n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent": "from strongarm.macho.macho_load_commands import MachoLoadCommands\nfrom strongarm.macho.arch_independent_structs import (\n    ArchIndependentStructure,\n    MachoHeaderStruct,\n    MachoSegmentCommandStruct,\n    MachoSectionRawStruct,\n    MachoEncryptionInfoStruct,\n    MachoNlistStruct,\n    CFStringStruct,\n    DylibCommandStruct,\n    MachoLoadCommandStruct,\n    MachoSymtabCommandStruct,\n    MachoDysymtabCommandStruct,\n    MachoDyldInfoCommandStruct,\n    MachoLinkeditDataCommandStruct,\n)\n\nif TYPE_CHECKING:\n    <IND>from strongarm.macho.codesign import CodesignParser\n\n",
        "target_code_with_indent_exact_match": true,
        "source_code_with_indent": "from strongarm.macho.macho_load_commands import MachoLoadCommands\nfrom strongarm.macho.arch_independent_structs import    MachoHeaderStruct,    MachoSegmentCommandStruct,    MachoSectionRawStruct,    MachoEncryptionInfoStruct,    MachoNlistStruct,    CFStringStruct,    DylibCommandStruct,    MachoLoadCommandStruct,    MachoSymtabCommandStruct,    MachoDysymtabCommandStruct,    MachoDyldInfoCommandStruct,    MachoLinkeditDataCommandStruct\n\nfrom ctypes import c_uint64, c_uint32, sizeof\n\n"
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "        # generic Mach-O header info\n        self.is_64bit: bool = None\n        self.is_swap: bool = None\n        self.cpu_type: CPU_TYPE = None\n        self._load_commands_end_addr = None\n\n        # Mach-O header data\n        self.header: MachoHeaderStruct = None\n        self.header_flags: List[int] = None\n        self.file_type: MachoFileType = None\n\n        # segment and section commands from Mach-O header\n        self.segment_commands: Dict[str, MachoSegmentCommandStruct] = None\n        self.sections: Dict[str, MachoSection] = None\n        # also store specific interesting sections which are useful to us\n        self.dysymtab: MachoDysymtabCommandStruct = None\n        self.symtab: MachoSymtabCommandStruct = None\n        self.encryption_info: MachoEncryptionInfoStruct = None\n        self.dyld_info: MachoDyldInfoCommandStruct = None\n        self.load_dylib_commands: List[DylibCommandStruct] = None\n        self.code_signature_cmd: MachoLinkeditDataCommandStruct = None\n\n        self.__codesign_parser: CodesignParser = None\n\n",
        "source_code_len": 1040,
        "target_code": "        # generic Mach-O header info\n        self.is_64bit: bool = False\n        self.is_swap: bool = False\n        self.cpu_type: CPU_TYPE = CPU_TYPE.UNKNOWN\n        self._load_commands_end_addr = 0\n\n        # Mach-O header data\n        self._header: Optional[MachoHeaderStruct] = None\n        self.header_flags: List[int] = []\n        self.file_type: MachoFileType = MachoFileType.MH_EXECUTE\n\n        # segment and section commands from Mach-O header\n        self.segment_commands: Dict[str, MachoSegmentCommandStruct] = {}\n        self.sections: Dict[str, MachoSection] = {}\n        # also store specific interesting sections which are useful to us\n        self._dysymtab: Optional[MachoDysymtabCommandStruct] = None\n        self._symtab: Optional[MachoSymtabCommandStruct] = None\n        self._encryption_info: Optional[MachoEncryptionInfoStruct] = None\n        self._dyld_info: Optional[MachoDyldInfoCommandStruct] = None\n        self.load_dylib_commands: List[DylibCommandStruct] = []\n        self._code_signature_cmd: Optional[MachoLinkeditDataCommandStruct] = None\n\n        self.__codesign_parser: Optional[CodesignParser] = None\n\n",
        "target_code_len": 1139,
        "diff_format": "@@ -62,24 +68,24 @@\n         # generic Mach-O header info\n-        self.is_64bit: bool = None\n-        self.is_swap: bool = None\n-        self.cpu_type: CPU_TYPE = None\n-        self._load_commands_end_addr = None\n+        self.is_64bit: bool = False\n+        self.is_swap: bool = False\n+        self.cpu_type: CPU_TYPE = CPU_TYPE.UNKNOWN\n+        self._load_commands_end_addr = 0\n \n         # Mach-O header data\n-        self.header: MachoHeaderStruct = None\n-        self.header_flags: List[int] = None\n-        self.file_type: MachoFileType = None\n+        self._header: Optional[MachoHeaderStruct] = None\n+        self.header_flags: List[int] = []\n+        self.file_type: MachoFileType = MachoFileType.MH_EXECUTE\n \n         # segment and section commands from Mach-O header\n-        self.segment_commands: Dict[str, MachoSegmentCommandStruct] = None\n-        self.sections: Dict[str, MachoSection] = None\n+        self.segment_commands: Dict[str, MachoSegmentCommandStruct] = {}\n+        self.sections: Dict[str, MachoSection] = {}\n         # also store specific interesting sections which are useful to us\n-        self.dysymtab: MachoDysymtabCommandStruct = None\n-        self.symtab: MachoSymtabCommandStruct = None\n-        self.encryption_info: MachoEncryptionInfoStruct = None\n-        self.dyld_info: MachoDyldInfoCommandStruct = None\n-        self.load_dylib_commands: List[DylibCommandStruct] = None\n-        self.code_signature_cmd: MachoLinkeditDataCommandStruct = None\n-\n-        self.__codesign_parser: CodesignParser = None\n+        self._dysymtab: Optional[MachoDysymtabCommandStruct] = None\n+        self._symtab: Optional[MachoSymtabCommandStruct] = None\n+        self._encryption_info: Optional[MachoEncryptionInfoStruct] = None\n+        self._dyld_info: Optional[MachoDyldInfoCommandStruct] = None\n+        self.load_dylib_commands: List[DylibCommandStruct] = []\n+        self._code_signature_cmd: Optional[MachoLinkeditDataCommandStruct] = None\n+\n+        self.__codesign_parser: Optional[CodesignParser] = None\n \n",
        "source_code_with_indent": "        # generic Mach-O header info\n        self.is_64bit: bool = None\n        self.is_swap: bool = None\n        self.cpu_type: CPU_TYPE = None\n        self._load_commands_end_addr = None\n\n        # Mach-O header data\n        self.header: MachoHeaderStruct = None\n        self.header_flags: List[int] = None\n        self.file_type: MachoFileType = None\n\n        # segment and section commands from Mach-O header\n        self.segment_commands: Dict[str, MachoSegmentCommandStruct] = None\n        self.sections: Dict[str, MachoSection] = None\n        # also store specific interesting sections which are useful to us\n        self.dysymtab: MachoDysymtabCommandStruct = None\n        self.symtab: MachoSymtabCommandStruct = None\n        self.encryption_info: MachoEncryptionInfoStruct = None\n        self.dyld_info: MachoDyldInfoCommandStruct = None\n        self.load_dylib_commands: List[DylibCommandStruct] = None\n        self.code_signature_cmd: MachoLinkeditDataCommandStruct = None\n\n        self.__codesign_parser: CodesignParser = None\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "        # generic Mach-O header info\n        self.is_64bit: bool = False\n        self.is_swap: bool = False\n        self.cpu_type: CPU_TYPE = CPU_TYPE.UNKNOWN\n        self._load_commands_end_addr = 0\n\n        # Mach-O header data\n        self._header: Optional[MachoHeaderStruct] = None\n        self.header_flags: List[int] = []\n        self.file_type: MachoFileType = MachoFileType.MH_EXECUTE\n\n        # segment and section commands from Mach-O header\n        self.segment_commands: Dict[str, MachoSegmentCommandStruct] = {}\n        self.sections: Dict[str, MachoSection] = {}\n        # also store specific interesting sections which are useful to us\n        self._dysymtab: Optional[MachoDysymtabCommandStruct] = None\n        self._symtab: Optional[MachoSymtabCommandStruct] = None\n        self._encryption_info: Optional[MachoEncryptionInfoStruct] = None\n        self._dyld_info: Optional[MachoDyldInfoCommandStruct] = None\n        self.load_dylib_commands: List[DylibCommandStruct] = []\n        self._code_signature_cmd: Optional[MachoLinkeditDataCommandStruct] = None\n\n        self.__codesign_parser: Optional[CodesignParser] = None\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "        self.symtab_contents = self._get_symtab_contents()\n        DebugUtil.log(self, \"parsed symtab, len = {}\".format(len(self.symtab_contents)))\n\n",
        "source_code_len": 149,
        "target_code": "        self.symtab_contents = self._get_symtab_contents()\n        DebugUtil.log(self, f\"parsed symtab, len = {len(self.symtab_contents)}\")\n\n        # Internal use\n        self._last_segment_command: Optional[MachoSegmentCommandStruct] = None\n\n",
        "target_code_len": 244,
        "diff_format": "@@ -96,3 +102,6 @@\n         self.symtab_contents = self._get_symtab_contents()\n-        DebugUtil.log(self, \"parsed symtab, len = {}\".format(len(self.symtab_contents)))\n+        DebugUtil.log(self, f\"parsed symtab, len = {len(self.symtab_contents)}\")\n+\n+        # Internal use\n+        self._last_segment_command: Optional[MachoSegmentCommandStruct] = None\n \n",
        "source_code_with_indent": "        self.symtab_contents = self._get_symtab_contents()\n        DebugUtil.log(self, \"parsed symtab, len = {}\".format(len(self.symtab_contents)))\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "        self.symtab_contents = self._get_symtab_contents()\n        DebugUtil.log(self, f\"parsed symtab, len = {len(self.symtab_contents)}\")\n\n        # Internal use\n        self._last_segment_command: Optional[MachoSegmentCommandStruct] = None\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    @property\n    def slice_magic(self) -> c_uint32:\n        \"\"\"Read magic number identifier from this Mach-O slice\n        \"\"\"\n        return self.read_word(0, virtual=False, word_type=c_uint32)\n\n",
        "source_code_len": 197,
        "target_code": "    @property\n    def slice_magic(self) -> int:\n        \"\"\"Read magic number identifier from this Mach-O slice\n        \"\"\"\n        magic = self.read_word(0, virtual=False, word_type=c_uint32)\n        if magic:\n            return magic\n        else:\n            raise ValueError('Could not read magic value.')\n\n",
        "target_code_len": 310,
        "diff_format": "@@ -124,6 +131,10 @@\n     @property\n-    def slice_magic(self) -> c_uint32:\n+    def slice_magic(self) -> int:\n         \"\"\"Read magic number identifier from this Mach-O slice\n         \"\"\"\n-        return self.read_word(0, virtual=False, word_type=c_uint32)\n+        magic = self.read_word(0, virtual=False, word_type=c_uint32)\n+        if magic:\n+            return magic\n+        else:\n+            raise ValueError('Could not read magic value.')\n \n",
        "source_code_with_indent": "    <DED>@property\n    def slice_magic(self) -> c_uint32:\n        <IND>\"\"\"Read magic number identifier from this Mach-O slice\n        \"\"\"\n        return self.read_word(0, virtual=False, word_type=c_uint32)\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    <DED>@property\n    def slice_magic(self) -> int:\n        <IND>\"\"\"Read magic number identifier from this Mach-O slice\n        \"\"\"\n        magic = self.read_word(0, virtual=False, word_type=c_uint32)\n        if magic:\n            <IND>return magic\n        <DED>else:\n            <IND>raise ValueError('Could not read magic value.')\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "        \"\"\"\n        self.header = MachoHeaderStruct(self, 0)\n\n",
        "source_code_len": 62,
        "target_code": "        \"\"\"\n        self._header = MachoHeaderStruct(self, 0)\n\n",
        "target_code_len": 63,
        "diff_format": "@@ -152,3 +163,3 @@\n         \"\"\"\n-        self.header = MachoHeaderStruct(self, 0)\n+        self._header = MachoHeaderStruct(self, 0)\n \n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\n        self.header = MachoHeaderStruct(self, 0)\n\n",
        "target_code_with_indent": "\n        self._header = MachoHeaderStruct(self, 0)\n\n"
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "                                      MachoLoadCommands.LC_ENCRYPTION_INFO_64]:\n                self.encryption_info = MachoEncryptionInfoStruct(self, offset)\n\n            elif load_command.cmd == MachoLoadCommands.LC_SYMTAB:\n                self.symtab = MachoSymtabCommandStruct(self, offset)\n\n            elif load_command.cmd == MachoLoadCommands.LC_DYSYMTAB:\n                self.dysymtab = MachoDysymtabCommandStruct(self, offset)\n\n            elif load_command.cmd in [MachoLoadCommands.LC_DYLD_INFO, MachoLoadCommands.LC_DYLD_INFO_ONLY]:\n                self.dyld_info = MachoDyldInfoCommandStruct(self, offset)\n\n",
        "source_code_len": 621,
        "target_code": "                                      MachoLoadCommands.LC_ENCRYPTION_INFO_64]:\n                self._encryption_info = MachoEncryptionInfoStruct(self, offset)\n\n            elif load_command.cmd == MachoLoadCommands.LC_SYMTAB:\n                self._symtab = MachoSymtabCommandStruct(self, offset)\n\n            elif load_command.cmd == MachoLoadCommands.LC_DYSYMTAB:\n                self._dysymtab = MachoDysymtabCommandStruct(self, offset)\n\n            elif load_command.cmd in [MachoLoadCommands.LC_DYLD_INFO, MachoLoadCommands.LC_DYLD_INFO_ONLY]:\n                self._dyld_info = MachoDyldInfoCommandStruct(self, offset)\n\n",
        "target_code_len": 625,
        "diff_format": "@@ -208,12 +220,12 @@\n                                       MachoLoadCommands.LC_ENCRYPTION_INFO_64]:\n-                self.encryption_info = MachoEncryptionInfoStruct(self, offset)\n+                self._encryption_info = MachoEncryptionInfoStruct(self, offset)\n \n             elif load_command.cmd == MachoLoadCommands.LC_SYMTAB:\n-                self.symtab = MachoSymtabCommandStruct(self, offset)\n+                self._symtab = MachoSymtabCommandStruct(self, offset)\n \n             elif load_command.cmd == MachoLoadCommands.LC_DYSYMTAB:\n-                self.dysymtab = MachoDysymtabCommandStruct(self, offset)\n+                self._dysymtab = MachoDysymtabCommandStruct(self, offset)\n \n             elif load_command.cmd in [MachoLoadCommands.LC_DYLD_INFO, MachoLoadCommands.LC_DYLD_INFO_ONLY]:\n-                self.dyld_info = MachoDyldInfoCommandStruct(self, offset)\n+                self._dyld_info = MachoDyldInfoCommandStruct(self, offset)\n \n",
        "source_code_with_indent": "                                      MachoLoadCommands.LC_ENCRYPTION_INFO_64]:\n                <IND>self.encryption_info = MachoEncryptionInfoStruct(self, offset)\n\n            <DED>elif load_command.cmd == MachoLoadCommands.LC_SYMTAB:\n                <IND>self.symtab = MachoSymtabCommandStruct(self, offset)\n\n            <DED>elif load_command.cmd == MachoLoadCommands.LC_DYSYMTAB:\n                <IND>self.dysymtab = MachoDysymtabCommandStruct(self, offset)\n\n            <DED>elif load_command.cmd in [MachoLoadCommands.LC_DYLD_INFO, MachoLoadCommands.LC_DYLD_INFO_ONLY]:\n                <IND>self.dyld_info = MachoDyldInfoCommandStruct(self, offset)\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "                                      MachoLoadCommands.LC_ENCRYPTION_INFO_64]:\n                <IND>self._encryption_info = MachoEncryptionInfoStruct(self, offset)\n\n            <DED>elif load_command.cmd == MachoLoadCommands.LC_SYMTAB:\n                <IND>self._symtab = MachoSymtabCommandStruct(self, offset)\n\n            <DED>elif load_command.cmd == MachoLoadCommands.LC_DYSYMTAB:\n                <IND>self._dysymtab = MachoDysymtabCommandStruct(self, offset)\n\n            <DED>elif load_command.cmd in [MachoLoadCommands.LC_DYLD_INFO, MachoLoadCommands.LC_DYLD_INFO_ONLY]:\n                <IND>self._dyld_info = MachoDyldInfoCommandStruct(self, offset)\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "            elif load_command.cmd == MachoLoadCommands.LC_CODE_SIGNATURE:\n                self.code_signature_cmd = MachoLinkeditDataCommandStruct(self, offset)\n\n",
        "source_code_len": 162,
        "target_code": "            elif load_command.cmd == MachoLoadCommands.LC_CODE_SIGNATURE:\n                self._code_signature_cmd = MachoLinkeditDataCommandStruct(self, offset)\n\n",
        "target_code_len": 163,
        "diff_format": "@@ -225,3 +236,3 @@\n             elif load_command.cmd == MachoLoadCommands.LC_CODE_SIGNATURE:\n-                self.code_signature_cmd = MachoLinkeditDataCommandStruct(self, offset)\n+                self._code_signature_cmd = MachoLinkeditDataCommandStruct(self, offset)\n \n",
        "source_code_with_indent": "            <DED>elif load_command.cmd == MachoLoadCommands.LC_CODE_SIGNATURE:\n                <IND>self.code_signature_cmd = MachoLinkeditDataCommandStruct(self, offset)\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "            <DED>elif load_command.cmd == MachoLoadCommands.LC_CODE_SIGNATURE:\n                <IND>self._code_signature_cmd = MachoLinkeditDataCommandStruct(self, offset)\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "        # if the address given is past the last declared section, translate based on the last section\n        # so, we need to keep track of the last seen section\n        max_segment = self.segment_commands[0]\n\n",
        "source_code_len": 211,
        "target_code": "        # if the address given is past the last declared section, translate based on the last section\n        # so, we need to keep track of the last seen sectio\n        if not self._last_segment_command:\n            return None\n        max_segment = self._last_segment_command\n\n",
        "target_code_len": 279,
        "diff_format": "@@ -271,4 +282,6 @@\n         # if the address given is past the last declared section, translate based on the last section\n-        # so, we need to keep track of the last seen section\n-        max_segment = self.segment_commands[0]\n+        # so, we need to keep track of the last seen sectio\n+        if not self._last_segment_command:\n+            return None\n+        max_segment = self._last_segment_command\n \n",
        "source_code_with_indent": "        # if the address given is past the last declared section, translate based on the last section\n        # so, we need to keep track of the last seen section\n        <DED>max_segment = self.segment_commands[0]\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "        # if the address given is past the last declared section, translate based on the last section\n        # so, we need to keep track of the last seen sectio\n        <DED>if not self._last_segment_command:\n            <IND>return None\n        <DED>max_segment = self._last_segment_command\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "            indirect_symtab_entry = self.read_word(indirect_symtab_off, virtual=False, word_type=c_uint32)\n            indirect_symtab.append(int(indirect_symtab_entry.value))\n            # traverse to next pointer\n",
        "source_code_len": 215,
        "target_code": "            indirect_symtab_entry = self.read_word(indirect_symtab_off, virtual=False, word_type=c_uint32)\n            if not indirect_symtab_entry:\n                continue\n            indirect_symtab.append(int(indirect_symtab_entry))\n            # traverse to next pointer\n",
        "target_code_len": 276,
        "diff_format": "@@ -398,3 +410,5 @@\n             indirect_symtab_entry = self.read_word(indirect_symtab_off, virtual=False, word_type=c_uint32)\n-            indirect_symtab.append(int(indirect_symtab_entry.value))\n+            if not indirect_symtab_entry:\n+                continue\n+            indirect_symtab.append(int(indirect_symtab_entry))\n             # traverse to next pointer\n",
        "source_code_with_indent": "            <IND>indirect_symtab_entry = self.read_word(indirect_symtab_off, virtual=False, word_type=c_uint32)\n            indirect_symtab.append(int(indirect_symtab_entry.value))\n            # traverse to next pointer\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "            <IND>indirect_symtab_entry = self.read_word(indirect_symtab_off, virtual=False, word_type=c_uint32)\n            if not indirect_symtab_entry:\n                <IND>continue\n            <DED>indirect_symtab.append(int(indirect_symtab_entry))\n            # traverse to next pointer\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "                  address: int,\n                  virtual=True,\n                  word_type=None) -> Optional[Union[c_uint32, c_uint64]]:\n        \"\"\"Attempt to read a word from the binary at a virtual address. Returns None if the address is invalid.\n",
        "source_code_len": 250,
        "target_code": "                  address: int,\n                  virtual: bool = True,\n                  word_type: Any = None) -> Optional[int]:\n        \"\"\"Attempt to read a word from the binary at a virtual address. Returns None if the address is invalid.\n",
        "target_code_len": 243,
        "diff_format": "@@ -568,4 +595,4 @@\n                   address: int,\n-                  virtual=True,\n-                  word_type=None) -> Optional[Union[c_uint32, c_uint64]]:\n+                  virtual: bool = True,\n+                  word_type: Any = None) -> Optional[int]:\n         \"\"\"Attempt to read a word from the binary at a virtual address. Returns None if the address is invalid.\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "                  address: int,\n                  virtual=True,\n                  word_type=None) -> Optional[Union[c_uint32, c_uint64]]:\n        <IND>",
        "target_code_with_indent": "                  address: int,\n                  virtual: bool = True,\n                  word_type: Any = None) -> Optional[int]:\n        <IND>"
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    @property\n    def _codesign_parser(self) -> 'CodesignParser':\n        from strongarm.macho.codesign import CodesignParser\n        if not self.__codesign_parser:\n",
        "source_code_len": 165,
        "target_code": "    @property\n    def header(self) -> MachoHeaderStruct:\n        if self._header:\n            return self._header\n        else:\n            raise RuntimeError('Failed to parse Mach-O')\n\n    @property\n    def dysymtab(self) -> MachoDysymtabCommandStruct:\n        if self._dysymtab:\n            return self._dysymtab\n        else:\n            raise RuntimeError('Failed to parse Mach-O')\n\n    @property\n    def symtab(self) -> MachoSymtabCommandStruct:\n        if self._symtab:\n            return self._symtab\n        else:\n            raise RuntimeError('Failed to parse Mach-O')\n\n    @property\n    def encryption_info(self) -> MachoEncryptionInfoStruct:\n        if self._encryption_info:\n            return self._encryption_info\n        else:\n            raise RuntimeError('Failed to parse Mach-O')\n\n    @property\n    def dyld_info(self) -> MachoDyldInfoCommandStruct:\n        if self._dyld_info:\n            return self._dyld_info\n        else:\n            raise RuntimeError('Failed to parse Mach-O')\n\n    @property\n    def code_signature_cmd(self) -> MachoLinkeditDataCommandStruct:\n        if self._code_signature_cmd:\n            return self._code_signature_cmd\n        else:\n            raise RuntimeError('Failed to parse Mach-O')\n\n    @property\n    def _codesign_parser(self) -> 'CodesignParser':\n        if not self.__codesign_parser:\n",
        "target_code_len": 1345,
        "diff_format": "@@ -583,4 +613,45 @@\n     @property\n+    def header(self) -> MachoHeaderStruct:\n+        if self._header:\n+            return self._header\n+        else:\n+            raise RuntimeError('Failed to parse Mach-O')\n+\n+    @property\n+    def dysymtab(self) -> MachoDysymtabCommandStruct:\n+        if self._dysymtab:\n+            return self._dysymtab\n+        else:\n+            raise RuntimeError('Failed to parse Mach-O')\n+\n+    @property\n+    def symtab(self) -> MachoSymtabCommandStruct:\n+        if self._symtab:\n+            return self._symtab\n+        else:\n+            raise RuntimeError('Failed to parse Mach-O')\n+\n+    @property\n+    def encryption_info(self) -> MachoEncryptionInfoStruct:\n+        if self._encryption_info:\n+            return self._encryption_info\n+        else:\n+            raise RuntimeError('Failed to parse Mach-O')\n+\n+    @property\n+    def dyld_info(self) -> MachoDyldInfoCommandStruct:\n+        if self._dyld_info:\n+            return self._dyld_info\n+        else:\n+            raise RuntimeError('Failed to parse Mach-O')\n+\n+    @property\n+    def code_signature_cmd(self) -> MachoLinkeditDataCommandStruct:\n+        if self._code_signature_cmd:\n+            return self._code_signature_cmd\n+        else:\n+            raise RuntimeError('Failed to parse Mach-O')\n+\n+    @property\n     def _codesign_parser(self) -> 'CodesignParser':\n-        from strongarm.macho.codesign import CodesignParser\n         if not self.__codesign_parser:\n",
        "source_code_with_indent": "    <DED>@property\n    def _codesign_parser(self) -> 'CodesignParser':\n        <IND>from strongarm.macho.codesign import CodesignParser\n        if not self.__codesign_parser:\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    <DED>@property\n    def header(self) -> MachoHeaderStruct:\n        <IND>if self._header:\n            <IND>return self._header\n        <DED>else:\n            <IND>raise RuntimeError('Failed to parse Mach-O')\n\n    <DED><DED>@property\n    def dysymtab(self) -> MachoDysymtabCommandStruct:\n        <IND>if self._dysymtab:\n            <IND>return self._dysymtab\n        <DED>else:\n            <IND>raise RuntimeError('Failed to parse Mach-O')\n\n    <DED><DED>@property\n    def symtab(self) -> MachoSymtabCommandStruct:\n        <IND>if self._symtab:\n            <IND>return self._symtab\n        <DED>else:\n            <IND>raise RuntimeError('Failed to parse Mach-O')\n\n    <DED><DED>@property\n    def encryption_info(self) -> MachoEncryptionInfoStruct:\n        <IND>if self._encryption_info:\n            <IND>return self._encryption_info\n        <DED>else:\n            <IND>raise RuntimeError('Failed to parse Mach-O')\n\n    <DED><DED>@property\n    def dyld_info(self) -> MachoDyldInfoCommandStruct:\n        <IND>if self._dyld_info:\n            <IND>return self._dyld_info\n        <DED>else:\n            <IND>raise RuntimeError('Failed to parse Mach-O')\n\n    <DED><DED>@property\n    def code_signature_cmd(self) -> MachoLinkeditDataCommandStruct:\n        <IND>if self._code_signature_cmd:\n            <IND>return self._code_signature_cmd\n        <DED>else:\n            <IND>raise RuntimeError('Failed to parse Mach-O')\n\n    <DED><DED>@property\n    def _codesign_parser(self) -> 'CodesignParser':\n        <IND>if not self.__codesign_parser:\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "datatheorem/strongarm",
    "commit": "ab620d78b4ce7f933cedc25960307f2c3b03c1a8",
    "filename": "strongarm/macho/macho_binary.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/datatheorem-strongarm/strongarm/macho/macho_binary.py",
    "file_hunks_size": 33,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "strongarm/macho/macho_binary.py:527:8 Incompatible return type [7]: Expected `str` but got `Optional[str]`.",
    "message": " Expected `str` but got `Optional[str]`.",
    "rule_id": "Incompatible return type [7]",
    "warning_line_no": 527,
    "warning_line": "        return source_name",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "            source_name = self.get_full_string_from_start_address(source_name_addr)\n        else:\n",
        "source_code_len": 98,
        "target_code": "            source_name = self.get_full_string_from_start_address(source_name_addr)\n            if not source_name:\n                source_name = '<unknown dylib>'\n        else:\n",
        "target_code_len": 178,
        "diff_format": "@@ -520,2 +545,4 @@\n             source_name = self.get_full_string_from_start_address(source_name_addr)\n+            if not source_name:\n+                source_name = '<unknown dylib>'\n         else:\n",
        "source_code_with_indent": "            source_name = self.get_full_string_from_start_address(source_name_addr)\n        <DED>else:\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "            source_name = self.get_full_string_from_start_address(source_name_addr)\n            if not source_name:\n                <IND>source_name = '<unknown dylib>'\n        <DED><DED>else:\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "datatheorem/strongarm",
    "commit": "ab620d78b4ce7f933cedc25960307f2c3b03c1a8",
    "filename": "strongarm/macho/macho_parse.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/datatheorem-strongarm/strongarm/macho/macho_parse.py",
    "file_hunks_size": 3,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": true,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "strongarm/macho/macho_parse.py:38:8 Incompatible attribute type [8]: Attribute `header` declared in class `MachoParser` has type `MachoFatHeader` but is used as type `None`.",
    "message": " Attribute `header` declared in class `MachoParser` has type `MachoFatHeader` but is used as type `None`.",
    "rule_id": "Incompatible attribute type [8]",
    "warning_line_no": 38,
    "warning_line": "        self.header: MachoFatHeader = None",
    "min_patch": [
      {
        "hunk_fit_TFix": true,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n        self.header: MachoFatHeader = None\n        self.is_swapped: bool = None\n        self.slices: List[MachoBinary] = []\n",
        "source_code_len": 125,
        "target_code": "\n        self.header: Optional[MachoFatHeader] = None\n        self.is_swapped: bool = False\n        self.slices: List[MachoBinary] = []\n",
        "target_code_len": 136,
        "diff_format": "@@ -37,4 +37,4 @@\n \n-        self.header: MachoFatHeader = None\n-        self.is_swapped: bool = None\n+        self.header: Optional[MachoFatHeader] = None\n+        self.is_swapped: bool = False\n         self.slices: List[MachoBinary] = []\n",
        "source_code_with_indent": "\n        self.header: MachoFatHeader = None\n        self.is_swapped: bool = None\n        self.slices: List[MachoBinary] = []\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n        self.header: Optional[MachoFatHeader] = None\n        self.is_swapped: bool = False\n        self.slices: List[MachoBinary] = []\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "datatheorem/strongarm",
    "commit": "ab620d78b4ce7f933cedc25960307f2c3b03c1a8",
    "filename": "strongarm/macho/macho_parse.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/datatheorem-strongarm/strongarm/macho/macho_parse.py",
    "file_hunks_size": 3,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": true,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "strongarm/macho/macho_parse.py:39:8 Incompatible attribute type [8]: Attribute `is_swapped` declared in class `MachoParser` has type `bool` but is used as type `None`.",
    "message": " Attribute `is_swapped` declared in class `MachoParser` has type `bool` but is used as type `None`.",
    "rule_id": "Incompatible attribute type [8]",
    "warning_line_no": 39,
    "warning_line": "        self.is_swapped: bool = None",
    "min_patch": [
      {
        "hunk_fit_TFix": true,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n        self.header: MachoFatHeader = None\n        self.is_swapped: bool = None\n        self.slices: List[MachoBinary] = []\n",
        "source_code_len": 125,
        "target_code": "\n        self.header: Optional[MachoFatHeader] = None\n        self.is_swapped: bool = False\n        self.slices: List[MachoBinary] = []\n",
        "target_code_len": 136,
        "diff_format": "@@ -37,4 +37,4 @@\n \n-        self.header: MachoFatHeader = None\n-        self.is_swapped: bool = None\n+        self.header: Optional[MachoFatHeader] = None\n+        self.is_swapped: bool = False\n         self.slices: List[MachoBinary] = []\n",
        "source_code_with_indent": "\n        self.header: MachoFatHeader = None\n        self.is_swapped: bool = None\n        self.slices: List[MachoBinary] = []\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n        self.header: Optional[MachoFatHeader] = None\n        self.is_swapped: bool = False\n        self.slices: List[MachoBinary] = []\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "datatheorem/strongarm",
    "commit": "ab620d78b4ce7f933cedc25960307f2c3b03c1a8",
    "filename": "strongarm/macho/macho_string_table_helper.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/datatheorem-strongarm/strongarm/macho/macho_string_table_helper.py",
    "file_hunks_size": 1,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": true,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "strongarm/macho/macho_string_table_helper.py:28:8 Incompatible attribute type [8]: Attribute `imported_symbols` declared in class `MachoStringTableHelper` has type `List[str]` but is used as type `None`.",
    "message": " Attribute `imported_symbols` declared in class `MachoStringTableHelper` has type `List[str]` but is used as type `None`.",
    "rule_id": "Incompatible attribute type [8]",
    "warning_line_no": 28,
    "warning_line": "        self.imported_symbols: List[str] = None",
    "min_patch": [
      {
        "hunk_fit_TFix": true,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "        self.string_table_entries = MachoStringTableHelper.transform_string_section(self.binary.get_raw_string_table())\n        self.imported_symbols: List[str] = None\n        self.exported_symbols: List[str] = None\n        self.parse_sym_lists()\n",
        "source_code_len": 247,
        "target_code": "        self.string_table_entries = MachoStringTableHelper.transform_string_section(self.binary.get_raw_string_table())\n        self.imported_symbols: List[str] = []\n        self.exported_symbols: List[str] = []\n        self.parse_sym_lists()\n",
        "target_code_len": 243,
        "diff_format": "@@ -27,4 +27,4 @@\n         self.string_table_entries = MachoStringTableHelper.transform_string_section(self.binary.get_raw_string_table())\n-        self.imported_symbols: List[str] = None\n-        self.exported_symbols: List[str] = None\n+        self.imported_symbols: List[str] = []\n+        self.exported_symbols: List[str] = []\n         self.parse_sym_lists()\n",
        "source_code_with_indent": "        self.string_table_entries = MachoStringTableHelper.transform_string_section(self.binary.get_raw_string_table())\n        self.imported_symbols: List[str] = None\n        self.exported_symbols: List[str] = None\n        self.parse_sym_lists()\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "        self.string_table_entries = MachoStringTableHelper.transform_string_section(self.binary.get_raw_string_table())\n        self.imported_symbols: List[str] = []\n        self.exported_symbols: List[str] = []\n        self.parse_sym_lists()\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "datatheorem/strongarm",
    "commit": "ab620d78b4ce7f933cedc25960307f2c3b03c1a8",
    "filename": "strongarm/macho/macho_string_table_helper.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/datatheorem-strongarm/strongarm/macho/macho_string_table_helper.py",
    "file_hunks_size": 1,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": true,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "strongarm/macho/macho_string_table_helper.py:29:8 Incompatible attribute type [8]: Attribute `exported_symbols` declared in class `MachoStringTableHelper` has type `List[str]` but is used as type `None`.",
    "message": " Attribute `exported_symbols` declared in class `MachoStringTableHelper` has type `List[str]` but is used as type `None`.",
    "rule_id": "Incompatible attribute type [8]",
    "warning_line_no": 29,
    "warning_line": "        self.exported_symbols: List[str] = None",
    "min_patch": [
      {
        "hunk_fit_TFix": true,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "        self.string_table_entries = MachoStringTableHelper.transform_string_section(self.binary.get_raw_string_table())\n        self.imported_symbols: List[str] = None\n        self.exported_symbols: List[str] = None\n        self.parse_sym_lists()\n",
        "source_code_len": 247,
        "target_code": "        self.string_table_entries = MachoStringTableHelper.transform_string_section(self.binary.get_raw_string_table())\n        self.imported_symbols: List[str] = []\n        self.exported_symbols: List[str] = []\n        self.parse_sym_lists()\n",
        "target_code_len": 243,
        "diff_format": "@@ -27,4 +27,4 @@\n         self.string_table_entries = MachoStringTableHelper.transform_string_section(self.binary.get_raw_string_table())\n-        self.imported_symbols: List[str] = None\n-        self.exported_symbols: List[str] = None\n+        self.imported_symbols: List[str] = []\n+        self.exported_symbols: List[str] = []\n         self.parse_sym_lists()\n",
        "source_code_with_indent": "        self.string_table_entries = MachoStringTableHelper.transform_string_section(self.binary.get_raw_string_table())\n        self.imported_symbols: List[str] = None\n        self.exported_symbols: List[str] = None\n        self.parse_sym_lists()\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "        self.string_table_entries = MachoStringTableHelper.transform_string_section(self.binary.get_raw_string_table())\n        self.imported_symbols: List[str] = []\n        self.exported_symbols: List[str] = []\n        self.parse_sym_lists()\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "datatheorem/strongarm",
    "commit": "ab620d78b4ce7f933cedc25960307f2c3b03c1a8",
    "filename": "strongarm/macho/objc_runtime_data_parser.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/datatheorem-strongarm/strongarm/macho/objc_runtime_data_parser.py",
    "file_hunks_size": 19,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": true,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "strongarm/macho/objc_runtime_data_parser.py:25:17 Incompatible variable type [9]: protocols is declared to have type `List[ObjcProtocol]` but is used as type `None`.",
    "message": " protocols is declared to have type `List[ObjcProtocol]` but is used as type `None`.",
    "rule_id": "Incompatible variable type [9]",
    "warning_line_no": 25,
    "warning_line": "                 protocols: List['ObjcProtocol'] = None) -> None:",
    "min_patch": [
      {
        "hunk_fit_TFix": true,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "                 selectors: List['ObjcSelector'],\n                 protocols: List['ObjcProtocol'] = None) -> None:\n        self.name = name\n",
        "source_code_len": 141,
        "target_code": "                 selectors: List['ObjcSelector'],\n                 protocols: List['ObjcProtocol'] = []) -> None:\n        self.name = name\n",
        "target_code_len": 139,
        "diff_format": "@@ -24,3 +25,3 @@\n                  selectors: List['ObjcSelector'],\n-                 protocols: List['ObjcProtocol'] = None) -> None:\n+                 protocols: List['ObjcProtocol'] = []) -> None:\n         self.name = name\n",
        "source_code_with_indent": "                 selectors: List['ObjcSelector'],\n                 protocols: List['ObjcProtocol'] = None) -> None:\n        <IND>self.name = name\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "                 selectors: List['ObjcSelector'],\n                 protocols: List['ObjcProtocol'] = []) -> None:\n        <IND>self.name = name\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "datatheorem/strongarm",
    "commit": "ab620d78b4ce7f933cedc25960307f2c3b03c1a8",
    "filename": "strongarm/macho/objc_runtime_data_parser.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/datatheorem-strongarm/strongarm/macho/objc_runtime_data_parser.py",
    "file_hunks_size": 19,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": true,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "strongarm/macho/objc_runtime_data_parser.py:42:17 Incompatible variable type [9]: protocols is declared to have type `List[ObjcProtocol]` but is used as type `None`.",
    "message": " protocols is declared to have type `List[ObjcProtocol]` but is used as type `None`.",
    "rule_id": "Incompatible variable type [9]",
    "warning_line_no": 42,
    "warning_line": "                 protocols: List['ObjcProtocol'] = None) -> None:",
    "min_patch": [
      {
        "hunk_fit_TFix": true,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "                 selectors: List['ObjcSelector'],\n                 protocols: List['ObjcProtocol'] = None) -> None:\n        super(ObjcCategory, self).__init__(raw_struct, name, selectors, protocols)\n",
        "source_code_len": 199,
        "target_code": "                 selectors: List['ObjcSelector'],\n                 protocols: List['ObjcProtocol'] = []) -> None:\n        super(ObjcCategory, self).__init__(raw_struct, name, selectors, protocols)\n",
        "target_code_len": 197,
        "diff_format": "@@ -41,3 +42,3 @@\n                  selectors: List['ObjcSelector'],\n-                 protocols: List['ObjcProtocol'] = None) -> None:\n+                 protocols: List['ObjcProtocol'] = []) -> None:\n         super(ObjcCategory, self).__init__(raw_struct, name, selectors, protocols)\n",
        "source_code_with_indent": "                 selectors: List['ObjcSelector'],\n                 protocols: List['ObjcProtocol'] = None) -> None:\n        <IND>super(ObjcCategory, self).__init__(raw_struct, name, selectors, protocols)\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "                 selectors: List['ObjcSelector'],\n                 protocols: List['ObjcProtocol'] = []) -> None:\n        <IND>super(ObjcCategory, self).__init__(raw_struct, name, selectors, protocols)\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "datatheorem/strongarm",
    "commit": "ab620d78b4ce7f933cedc25960307f2c3b03c1a8",
    "filename": "strongarm/macho/objc_runtime_data_parser.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/datatheorem-strongarm/strongarm/macho/objc_runtime_data_parser.py",
    "file_hunks_size": 19,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": true,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "strongarm/macho/objc_runtime_data_parser.py:144:74 Incompatible parameter type [6]: Expected `str` for 3rd positional only parameter to call `ObjcSelref.__init__` but got `Optional[str]`.",
    "message": " Expected `str` for 3rd positional only parameter to call `ObjcSelref.__init__` but got `Optional[str]`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 144,
    "warning_line": "            wrapped_selref = ObjcSelref(selref_ptr, selector_literal_ptr, selector_string)",
    "min_patch": [
      {
        "hunk_fit_TFix": true,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "            selector_string = self.binary.get_full_string_from_start_address(selector_literal_ptr)\n            wrapped_selref = ObjcSelref(selref_ptr, selector_literal_ptr, selector_string)\n",
        "source_code_len": 190,
        "target_code": "            selector_string = self.binary.get_full_string_from_start_address(selector_literal_ptr)\n            if not selector_string:\n                continue  # but all selectors should have a name\n            wrapped_selref = ObjcSelref(selref_ptr, selector_literal_ptr, selector_string)\n",
        "target_code_len": 291,
        "diff_format": "@@ -143,2 +144,4 @@\n             selector_string = self.binary.get_full_string_from_start_address(selector_literal_ptr)\n+            if not selector_string:\n+                continue  # but all selectors should have a name\n             wrapped_selref = ObjcSelref(selref_ptr, selector_literal_ptr, selector_string)\n",
        "source_code_with_indent": "            selector_string = self.binary.get_full_string_from_start_address(selector_literal_ptr)\n            wrapped_selref = ObjcSelref(selref_ptr, selector_literal_ptr, selector_string)\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "            <IND>selector_string = self.binary.get_full_string_from_start_address(selector_literal_ptr)\n            if not selector_string:\n                <IND>continue  # but all selectors should have a name\n            <DED>wrapped_selref = ObjcSelref(selref_ptr, selector_literal_ptr, selector_string)\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "datatheorem/strongarm",
    "commit": "ab620d78b4ce7f933cedc25960307f2c3b03c1a8",
    "filename": "strongarm/macho/objc_runtime_data_parser.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/datatheorem-strongarm/strongarm/macho/objc_runtime_data_parser.py",
    "file_hunks_size": 19,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "strongarm/macho/objc_runtime_data_parser.py:150:72 Incompatible parameter type [6]: Expected `str` for 1st positional only parameter to call `ObjcSelector.__init__` but got `Optional[str]`.",
    "message": " Expected `str` for 1st positional only parameter to call `ObjcSelector.__init__` but got `Optional[str]`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 150,
    "warning_line": "            self._selref_ptr_to_selector_map[selref_ptr] = ObjcSelector(selector_string, wrapped_selref, None)",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "            selector_string = self.binary.get_full_string_from_start_address(selector_literal_ptr)\n            wrapped_selref = ObjcSelref(selref_ptr, selector_literal_ptr, selector_string)\n",
        "source_code_len": 190,
        "target_code": "            selector_string = self.binary.get_full_string_from_start_address(selector_literal_ptr)\n            if not selector_string:\n                continue  # but all selectors should have a name\n            wrapped_selref = ObjcSelref(selref_ptr, selector_literal_ptr, selector_string)\n",
        "target_code_len": 291,
        "diff_format": "@@ -143,2 +144,4 @@\n             selector_string = self.binary.get_full_string_from_start_address(selector_literal_ptr)\n+            if not selector_string:\n+                continue  # but all selectors should have a name\n             wrapped_selref = ObjcSelref(selref_ptr, selector_literal_ptr, selector_string)\n",
        "source_code_with_indent": "            selector_string = self.binary.get_full_string_from_start_address(selector_literal_ptr)\n            wrapped_selref = ObjcSelref(selref_ptr, selector_literal_ptr, selector_string)\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "            <IND>selector_string = self.binary.get_full_string_from_start_address(selector_literal_ptr)\n            if not selector_string:\n                <IND>continue  # but all selectors should have a name\n            <DED>wrapped_selref = ObjcSelref(selref_ptr, selector_literal_ptr, selector_string)\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "datatheorem/strongarm",
    "commit": "ab620d78b4ce7f933cedc25960307f2c3b03c1a8",
    "filename": "strongarm/macho/objc_runtime_data_parser.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/datatheorem-strongarm/strongarm/macho/objc_runtime_data_parser.py",
    "file_hunks_size": 19,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "strongarm/macho/objc_runtime_data_parser.py:273:36 Incompatible parameter type [6]: Expected `str` for 1st positional only parameter to call `ObjcSelector.__init__` but got `Optional[str]`.",
    "message": " Expected `str` for 1st positional only parameter to call `ObjcSelector.__init__` but got `Optional[str]`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 273,
    "warning_line": "            selector = ObjcSelector(symbol_name, selref, method_ent.implementation)",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "            symbol_name = self.binary.get_full_string_from_start_address(method_ent.name)\n            # attempt to find corresponding selref\n            if method_ent.name in self._selector_literal_ptr_to_selref_map:\n                selref = self._selector_literal_ptr_to_selref_map[method_ent.name]\n            else:\n                selref = None\n\n",
        "source_code_len": 349,
        "target_code": "            symbol_name = self.binary.get_full_string_from_start_address(method_ent.name)\n            if not symbol_name:\n                raise ValueError(f'Could not find symbol name for {methlist_ptr}')\n            # attempt to find corresponding selref\n            selref = self._selector_literal_ptr_to_selref_map.get(method_ent.name)\n\n",
        "target_code_len": 340,
        "diff_format": "@@ -266,7 +270,6 @@\n             symbol_name = self.binary.get_full_string_from_start_address(method_ent.name)\n+            if not symbol_name:\n+                raise ValueError(f'Could not find symbol name for {methlist_ptr}')\n             # attempt to find corresponding selref\n-            if method_ent.name in self._selector_literal_ptr_to_selref_map:\n-                selref = self._selector_literal_ptr_to_selref_map[method_ent.name]\n-            else:\n-                selref = None\n+            selref = self._selector_literal_ptr_to_selref_map.get(method_ent.name)\n \n",
        "source_code_with_indent": "            symbol_name = self.binary.get_full_string_from_start_address(method_ent.name)\n            # attempt to find corresponding selref\n            if method_ent.name in self._selector_literal_ptr_to_selref_map:\n                <IND>selref = self._selector_literal_ptr_to_selref_map[method_ent.name]\n            <DED>else:\n                <IND>selref = None\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "            symbol_name = self.binary.get_full_string_from_start_address(method_ent.name)\n            if not symbol_name:\n                <IND>raise ValueError(f'Could not find symbol name for {methlist_ptr}')\n            # attempt to find corresponding selref\n            <DED>selref = self._selector_literal_ptr_to_selref_map.get(method_ent.name)\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "datatheorem/strongarm",
    "commit": "ab620d78b4ce7f933cedc25960307f2c3b03c1a8",
    "filename": "strongarm/macho/objc_runtime_data_parser.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/datatheorem-strongarm/strongarm/macho/objc_runtime_data_parser.py",
    "file_hunks_size": 19,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "strongarm/macho/objc_runtime_data_parser.py:273:49 Incompatible parameter type [6]: Expected `ObjcSelref` for 2nd positional only parameter to call `ObjcSelector.__init__` but got `Optional[ObjcSelref]`.",
    "message": " Expected `ObjcSelref` for 2nd positional only parameter to call `ObjcSelector.__init__` but got `Optional[ObjcSelref]`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 273,
    "warning_line": "            selector = ObjcSelector(symbol_name, selref, method_ent.implementation)",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n    def __init__(self, name: str, selref: 'ObjcSelref', implementation: Optional[int]) -> None:\n        self.name = name\n",
        "source_code_len": 122,
        "target_code": "\n    def __init__(self, name: str, selref: Optional['ObjcSelref'], implementation: Optional[int]) -> None:\n        self.name = name\n",
        "target_code_len": 132,
        "diff_format": "@@ -53,3 +54,3 @@\n \n-    def __init__(self, name: str, selref: 'ObjcSelref', implementation: Optional[int]) -> None:\n+    def __init__(self, name: str, selref: Optional['ObjcSelref'], implementation: Optional[int]) -> None:\n         self.name = name\n",
        "source_code_with_indent": "\n    def __init__(self, name: str, selref: 'ObjcSelref', implementation: Optional[int]) -> None:\n        <IND>self.name = name\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n    def __init__(self, name: str, selref: Optional['ObjcSelref'], implementation: Optional[int]) -> None:\n        <IND>self.name = name\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "datatheorem/strongarm",
    "commit": "ab620d78b4ce7f933cedc25960307f2c3b03c1a8",
    "filename": "strongarm/macho/objc_runtime_data_parser.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/datatheorem-strongarm/strongarm/macho/objc_runtime_data_parser.py",
    "file_hunks_size": 19,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "strongarm/macho/objc_runtime_data_parser.py:304:50 Incompatible parameter type [6]: Expected `str` for 2nd positional only parameter to call `ObjcClass.__init__` but got `Optional[str]`.",
    "message": " Expected `str` for 2nd positional only parameter to call `ObjcClass.__init__` but got `Optional[str]`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 304,
    "warning_line": "        return ObjcProtocol(objc_protocol_struct, name, selectors)",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "        name = self.binary.get_full_string_from_start_address(objc_protocol_struct.name)\n        selectors = []\n        if objc_protocol_struct.required_instance_methods:\n",
        "source_code_len": 171,
        "target_code": "        name = self.binary.get_full_string_from_start_address(objc_protocol_struct.name)\n        if not name:\n            name = '<unknown>'\n\n        selectors: List[ObjcSelector] = []\n        if objc_protocol_struct.required_instance_methods:\n",
        "target_code_len": 244,
        "diff_format": "@@ -293,3 +296,6 @@\n         name = self.binary.get_full_string_from_start_address(objc_protocol_struct.name)\n-        selectors = []\n+        if not name:\n+            name = '<unknown>'\n+\n+        selectors: List[ObjcSelector] = []\n         if objc_protocol_struct.required_instance_methods:\n",
        "source_code_with_indent": "        <IND>name = self.binary.get_full_string_from_start_address(objc_protocol_struct.name)\n        selectors = []\n        if objc_protocol_struct.required_instance_methods:\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "        <IND>name = self.binary.get_full_string_from_start_address(objc_protocol_struct.name)\n        if not name:\n            <IND>name = '<unknown>'\n\n        <DED>selectors: List[ObjcSelector] = []\n        if objc_protocol_struct.required_instance_methods:\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "datatheorem/strongarm",
    "commit": "ab620d78b4ce7f933cedc25960307f2c3b03c1a8",
    "filename": "strongarm/macho/objc_runtime_data_parser.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/datatheorem-strongarm/strongarm/macho/objc_runtime_data_parser.py",
    "file_hunks_size": 19,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "strongarm/macho/objc_runtime_data_parser.py:327:62 Incompatible parameter type [6]: Expected `str` for 3rd positional only parameter to call `ObjcCategory.__init__` but got `Optional[str]`.",
    "message": " Expected `str` for 3rd positional only parameter to call `ObjcCategory.__init__` but got `Optional[str]`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 327,
    "warning_line": "        return ObjcCategory(objc_category_struct, base_class, name, selectors, protocols)",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    def _parse_objc_category_entry(self, objc_category_struct: ObjcCategoryRawStruct) -> ObjcCategory:\n        selectors = []\n        protocols = []\n        name = self.binary.get_full_string_from_start_address(objc_category_struct.name)\n\n        # TODO(PT): if we want to parse the name of the base class, grab the destination pointer from entries in\n",
        "source_code_len": 352,
        "target_code": "    def _parse_objc_category_entry(self, objc_category_struct: ObjcCategoryRawStruct) -> ObjcCategory:\n        name = self.binary.get_full_string_from_start_address(objc_category_struct.name)\n        if not name:\n            name = '<unknown>'\n\n        selectors: List[ObjcSelector] = []\n        protocols: List[ObjcProtocol] = []\n        # TODO(PT): if we want to parse the name of the base class, grab the destination pointer from entries in\n",
        "target_code_len": 444,
        "diff_format": "@@ -306,6 +312,8 @@\n     def _parse_objc_category_entry(self, objc_category_struct: ObjcCategoryRawStruct) -> ObjcCategory:\n-        selectors = []\n-        protocols = []\n         name = self.binary.get_full_string_from_start_address(objc_category_struct.name)\n-\n+        if not name:\n+            name = '<unknown>'\n+\n+        selectors: List[ObjcSelector] = []\n+        protocols: List[ObjcProtocol] = []\n         # TODO(PT): if we want to parse the name of the base class, grab the destination pointer from entries in\n",
        "source_code_with_indent": "    <DED>def _parse_objc_category_entry(self, objc_category_struct: ObjcCategoryRawStruct) -> ObjcCategory:\n        <IND>selectors = []\n        protocols = []\n        name = self.binary.get_full_string_from_start_address(objc_category_struct.name)\n\n        # TODO(PT): if we want to parse the name of the base class, grab the destination pointer from entries in\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    <DED>def _parse_objc_category_entry(self, objc_category_struct: ObjcCategoryRawStruct) -> ObjcCategory:\n        <IND>name = self.binary.get_full_string_from_start_address(objc_category_struct.name)\n        if not name:\n            <IND>name = '<unknown>'\n\n        <DED>selectors: List[ObjcSelector] = []\n        protocols: List[ObjcProtocol] = []\n        # TODO(PT): if we want to parse the name of the base class, grab the destination pointer from entries in\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "datatheorem/strongarm",
    "commit": "ab620d78b4ce7f933cedc25960307f2c3b03c1a8",
    "filename": "strongarm/macho/objc_runtime_data_parser.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/datatheorem-strongarm/strongarm/macho/objc_runtime_data_parser.py",
    "file_hunks_size": 19,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "strongarm/macho/objc_runtime_data_parser.py:343:44 Incompatible parameter type [6]: Expected `str` for 2nd positional only parameter to call `ObjcClass.__init__` but got `Optional[str]`.",
    "message": " Expected `str` for 2nd positional only parameter to call `ObjcClass.__init__` but got `Optional[str]`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 343,
    "warning_line": "        return ObjcClass(objc_class_struct, name, selectors, protocols)",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "        name = self.binary.get_full_string_from_start_address(objc_data_struct.name)\n        selectors = []\n        protocols = []\n        # if the class implements no methods, base_methods will be the null pointer\n",
        "source_code_len": 215,
        "target_code": "        name = self.binary.get_full_string_from_start_address(objc_data_struct.name)\n        if not name:\n            name = '<unknown>'\n\n        selectors: List[ObjcSelector] = []\n        protocols: List[ObjcProtocol] = []\n        # if the class implements no methods, base_methods will be the null pointer\n",
        "target_code_len": 308,
        "diff_format": "@@ -332,4 +340,7 @@\n         name = self.binary.get_full_string_from_start_address(objc_data_struct.name)\n-        selectors = []\n-        protocols = []\n+        if not name:\n+            name = '<unknown>'\n+\n+        selectors: List[ObjcSelector] = []\n+        protocols: List[ObjcProtocol] = []\n         # if the class implements no methods, base_methods will be the null pointer\n",
        "source_code_with_indent": "        <IND>name = self.binary.get_full_string_from_start_address(objc_data_struct.name)\n        selectors = []\n        protocols = []\n        # if the class implements no methods, base_methods will be the null pointer\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "        <IND>name = self.binary.get_full_string_from_start_address(objc_data_struct.name)\n        if not name:\n            <IND>name = '<unknown>'\n\n        <DED>selectors: List[ObjcSelector] = []\n        protocols: List[ObjcProtocol] = []\n        # if the class implements no methods, base_methods will be the null pointer\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "datatheorem/strongarm",
    "commit": "ab620d78b4ce7f933cedc25960307f2c3b03c1a8",
    "filename": "strongarm/objc/objc_analyzer.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/datatheorem-strongarm/strongarm/objc/objc_analyzer.py",
    "file_hunks_size": 14,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": true,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "strongarm/objc/objc_analyzer.py:56:8 Incompatible attribute type [8]: Attribute `_call_targets` declared in class `ObjcFunctionAnalyzer` has type `List[ObjcBranchInstruction]` but is used as type `None`.",
    "message": " Attribute `_call_targets` declared in class `ObjcFunctionAnalyzer` has type `List[ObjcBranchInstruction]` but is used as type `None`.",
    "rule_id": "Incompatible attribute type [8]",
    "warning_line_no": 56,
    "warning_line": "        self._call_targets: List[ObjcBranchInstruction] = None",
    "min_patch": [
      {
        "hunk_fit_TFix": true,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n        self._call_targets: List[ObjcBranchInstruction] = None\n\n",
        "source_code_len": 65,
        "target_code": "\n        self._call_targets: List[ObjcBranchInstruction] = []\n\n",
        "target_code_len": 63,
        "diff_format": "@@ -55,3 +57,3 @@\n \n-        self._call_targets: List[ObjcBranchInstruction] = None\n+        self._call_targets: List[ObjcBranchInstruction] = []\n \n",
        "source_code_with_indent": "\n        self._call_targets: List[ObjcBranchInstruction] = None\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n        self._call_targets: List[ObjcBranchInstruction] = []\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "datatheorem/strongarm",
    "commit": "ab620d78b4ce7f933cedc25960307f2c3b03c1a8",
    "filename": "strongarm/objc/objc_analyzer.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/datatheorem-strongarm/strongarm/objc/objc_analyzer.py",
    "file_hunks_size": 14,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": true,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "strongarm/objc/objc_analyzer.py:81:45 Incompatible parameter type [6]: Expected `int` for 1st positional only parameter to call `ObjcFunctionAnalyzer.get_instruction_at_index` but got `Optional[int]`.",
    "message": " Expected `int` for 1st positional only parameter to call `ObjcFunctionAnalyzer.get_instruction_at_index` but got `Optional[int]`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 81,
    "warning_line": "        return self.get_instruction_at_index(index)",
    "min_patch": [
      {
        "hunk_fit_TFix": true,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "        index = self._get_instruction_index_of_address(address)\n        return self.get_instruction_at_index(index)\n",
        "source_code_len": 116,
        "target_code": "        index = self._get_instruction_index_of_address(address)\n        if not index:\n            return None\n        return self.get_instruction_at_index(index)\n",
        "target_code_len": 162,
        "diff_format": "@@ -80,2 +82,4 @@\n         index = self._get_instruction_index_of_address(address)\n+        if not index:\n+            return None\n         return self.get_instruction_at_index(index)\n",
        "source_code_with_indent": "        index = self._get_instruction_index_of_address(address)\n        return self.get_instruction_at_index(index)\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "        index = self._get_instruction_index_of_address(address)\n        if not index:\n            <IND>return None\n        <DED>return self.get_instruction_at_index(index)\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "datatheorem/strongarm",
    "commit": "ab620d78b4ce7f933cedc25960307f2c3b03c1a8",
    "filename": "strongarm/objc/objc_analyzer.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/datatheorem-strongarm/strongarm/objc/objc_analyzer.py",
    "file_hunks_size": 14,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": true,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "strongarm/objc/objc_analyzer.py:317:33 Unsupported operand [58]: `-` is not supported for operand types `Optional[int]` and `int`.",
    "message": " `-` is not supported for operand types `Optional[int]` and `int`.",
    "rule_id": "Unsupported operand [58]",
    "warning_line_no": 317,
    "warning_line": "        search_space_start_idx = msgsend_idx - 3",
    "min_patch": [
      {
        "hunk_fit_TFix": true,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "        msgsend_idx = self._get_instruction_index_of_address(msgsend_instr.address)\n        search_space_start_idx = msgsend_idx - 3\n",
        "source_code_len": 133,
        "target_code": "        msgsend_idx = self._get_instruction_index_of_address(msgsend_instr.address)\n        if not msgsend_idx:\n            raise ValueError(f'instruction index not found for address {msgsend_instr.address}')\n\n        search_space_start_idx = msgsend_idx - 3\n",
        "target_code_len": 259,
        "diff_format": "@@ -316,2 +325,5 @@\n         msgsend_idx = self._get_instruction_index_of_address(msgsend_instr.address)\n+        if not msgsend_idx:\n+            raise ValueError(f'instruction index not found for address {msgsend_instr.address}')\n+\n         search_space_start_idx = msgsend_idx - 3\n",
        "source_code_with_indent": "        <DED>msgsend_idx = self._get_instruction_index_of_address(msgsend_instr.address)\n        search_space_start_idx = msgsend_idx - 3\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "        <DED>msgsend_idx = self._get_instruction_index_of_address(msgsend_instr.address)\n        if not msgsend_idx:\n            <IND>raise ValueError(f'instruction index not found for address {msgsend_instr.address}')\n\n        <DED>search_space_start_idx = msgsend_idx - 3\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "datatheorem/strongarm",
    "commit": "ab620d78b4ce7f933cedc25960307f2c3b03c1a8",
    "filename": "strongarm/objc/objc_instruction.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/datatheorem-strongarm/strongarm/objc/objc_instruction.py",
    "file_hunks_size": 16,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": true,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "strongarm/objc/objc_instruction.py:22:8 Incompatible attribute type [8]: Attribute `is_msgSend_call` declared in class `ObjcInstruction` has type `bool` but is used as type `None`.",
    "message": " Attribute `is_msgSend_call` declared in class `ObjcInstruction` has type `bool` but is used as type `None`.",
    "rule_id": "Incompatible attribute type [8]",
    "warning_line_no": 22,
    "warning_line": "        self.is_msgSend_call: bool = None",
    "min_patch": [
      {
        "hunk_fit_TFix": true,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n        self.is_msgSend_call: bool = None\n        self.symbol: str = None\n\n",
        "source_code_len": 76,
        "target_code": "\n        self.is_msgSend_call: bool = False\n        self.symbol: str = ''\n\n",
        "target_code_len": 75,
        "diff_format": "@@ -21,4 +21,4 @@\n \n-        self.is_msgSend_call: bool = None\n-        self.symbol: str = None\n+        self.is_msgSend_call: bool = False\n+        self.symbol: str = ''\n \n",
        "source_code_with_indent": "\n        self.is_msgSend_call: bool = None\n        self.symbol: str = None\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n        self.is_msgSend_call: bool = False\n        self.symbol: str = ''\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "datatheorem/strongarm",
    "commit": "ab620d78b4ce7f933cedc25960307f2c3b03c1a8",
    "filename": "strongarm/objc/objc_instruction.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/datatheorem-strongarm/strongarm/objc/objc_instruction.py",
    "file_hunks_size": 16,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": true,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "strongarm/objc/objc_instruction.py:23:8 Incompatible attribute type [8]: Attribute `symbol` declared in class `ObjcInstruction` has type `str` but is used as type `None`.",
    "message": " Attribute `symbol` declared in class `ObjcInstruction` has type `str` but is used as type `None`.",
    "rule_id": "Incompatible attribute type [8]",
    "warning_line_no": 23,
    "warning_line": "        self.symbol: str = None",
    "min_patch": [
      {
        "hunk_fit_TFix": true,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n        self.is_msgSend_call: bool = None\n        self.symbol: str = None\n\n",
        "source_code_len": 76,
        "target_code": "\n        self.is_msgSend_call: bool = False\n        self.symbol: str = ''\n\n",
        "target_code_len": 75,
        "diff_format": "@@ -21,4 +21,4 @@\n \n-        self.is_msgSend_call: bool = None\n-        self.symbol: str = None\n+        self.is_msgSend_call: bool = False\n+        self.symbol: str = ''\n \n",
        "source_code_with_indent": "\n        self.is_msgSend_call: bool = None\n        self.symbol: str = None\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n        self.is_msgSend_call: bool = False\n        self.symbol: str = ''\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "datatheorem/strongarm",
    "commit": "ab620d78b4ce7f933cedc25960307f2c3b03c1a8",
    "filename": "strongarm/objc/objc_instruction.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/datatheorem-strongarm/strongarm/objc/objc_instruction.py",
    "file_hunks_size": 16,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "strongarm/objc/objc_instruction.py:72:8 Incompatible attribute type [8]: Attribute `symbol` declared in class `ObjcBranchInstruction` has type `str` but is used as type `None`.",
    "message": " Attribute `symbol` declared in class `ObjcBranchInstruction` has type `str` but is used as type `None`.",
    "rule_id": "Incompatible attribute type [8]",
    "warning_line_no": 72,
    "warning_line": "        self.symbol: str = None",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "# -*- coding: utf-8 -*-\nfrom typing import Union\nfrom typing import TYPE_CHECKING\n",
        "source_code_len": 82,
        "target_code": "# -*- coding: utf-8 -*-\nfrom typing import Optional, Union\nfrom typing import TYPE_CHECKING\n",
        "target_code_len": 92,
        "diff_format": "@@ -1,3 +1,3 @@\n # -*- coding: utf-8 -*-\n-from typing import Union\n+from typing import Optional, Union\n from typing import TYPE_CHECKING\n",
        "source_code_with_indent": "# -*- coding: utf-8 -*-\nfrom typing import Union\nfrom typing import TYPE_CHECKING\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "# -*- coding: utf-8 -*-\nfrom typing import Optional, Union\nfrom typing import TYPE_CHECKING\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n        self.symbol: str = None\n        self.selref: ObjcSelref = None\n        self.selector: ObjcSelector = None\n\n        self.is_external_c_call: bool = None\n        self.is_external_objc_call: bool = None\n\n        self.is_local_branch: bool = None\n\n",
        "source_code_len": 253,
        "target_code": "\n        self.symbol: str = ''\n        self.selref: Optional[ObjcSelref] = None\n        self.selector: Optional[ObjcSelector] = None\n\n        self.is_external_c_call: bool = False\n        self.is_external_objc_call: bool = False\n\n        self.is_local_branch: bool = False\n\n",
        "target_code_len": 274,
        "diff_format": "@@ -71,10 +71,10 @@\n \n-        self.symbol: str = None\n-        self.selref: ObjcSelref = None\n-        self.selector: ObjcSelector = None\n-\n-        self.is_external_c_call: bool = None\n-        self.is_external_objc_call: bool = None\n-\n-        self.is_local_branch: bool = None\n+        self.symbol: str = ''\n+        self.selref: Optional[ObjcSelref] = None\n+        self.selector: Optional[ObjcSelector] = None\n+\n+        self.is_external_c_call: bool = False\n+        self.is_external_objc_call: bool = False\n+\n+        self.is_local_branch: bool = False\n \n",
        "source_code_with_indent": "\n        self.symbol: str = None\n        self.selref: ObjcSelref = None\n        self.selector: ObjcSelector = None\n\n        self.is_external_c_call: bool = None\n        self.is_external_objc_call: bool = None\n\n        self.is_local_branch: bool = None\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n        self.symbol: str = ''\n        self.selref: Optional[ObjcSelref] = None\n        self.selector: Optional[ObjcSelector] = None\n\n        self.is_external_c_call: bool = False\n        self.is_external_objc_call: bool = False\n\n        self.is_local_branch: bool = False\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "datatheorem/strongarm",
    "commit": "ab620d78b4ce7f933cedc25960307f2c3b03c1a8",
    "filename": "strongarm/objc/objc_instruction.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/datatheorem-strongarm/strongarm/objc/objc_instruction.py",
    "file_hunks_size": 16,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "strongarm/objc/objc_instruction.py:73:8 Incompatible attribute type [8]: Attribute `selref` declared in class `ObjcBranchInstruction` has type `ObjcSelref` but is used as type `None`.",
    "message": " Attribute `selref` declared in class `ObjcBranchInstruction` has type `ObjcSelref` but is used as type `None`.",
    "rule_id": "Incompatible attribute type [8]",
    "warning_line_no": 73,
    "warning_line": "        self.selref: ObjcSelref = None",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "# -*- coding: utf-8 -*-\nfrom typing import Union\nfrom typing import TYPE_CHECKING\n",
        "source_code_len": 82,
        "target_code": "# -*- coding: utf-8 -*-\nfrom typing import Optional, Union\nfrom typing import TYPE_CHECKING\n",
        "target_code_len": 92,
        "diff_format": "@@ -1,3 +1,3 @@\n # -*- coding: utf-8 -*-\n-from typing import Union\n+from typing import Optional, Union\n from typing import TYPE_CHECKING\n",
        "source_code_with_indent": "# -*- coding: utf-8 -*-\nfrom typing import Union\nfrom typing import TYPE_CHECKING\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "# -*- coding: utf-8 -*-\nfrom typing import Optional, Union\nfrom typing import TYPE_CHECKING\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n        self.symbol: str = None\n        self.selref: ObjcSelref = None\n        self.selector: ObjcSelector = None\n\n        self.is_external_c_call: bool = None\n        self.is_external_objc_call: bool = None\n\n        self.is_local_branch: bool = None\n\n",
        "source_code_len": 253,
        "target_code": "\n        self.symbol: str = ''\n        self.selref: Optional[ObjcSelref] = None\n        self.selector: Optional[ObjcSelector] = None\n\n        self.is_external_c_call: bool = False\n        self.is_external_objc_call: bool = False\n\n        self.is_local_branch: bool = False\n\n",
        "target_code_len": 274,
        "diff_format": "@@ -71,10 +71,10 @@\n \n-        self.symbol: str = None\n-        self.selref: ObjcSelref = None\n-        self.selector: ObjcSelector = None\n-\n-        self.is_external_c_call: bool = None\n-        self.is_external_objc_call: bool = None\n-\n-        self.is_local_branch: bool = None\n+        self.symbol: str = ''\n+        self.selref: Optional[ObjcSelref] = None\n+        self.selector: Optional[ObjcSelector] = None\n+\n+        self.is_external_c_call: bool = False\n+        self.is_external_objc_call: bool = False\n+\n+        self.is_local_branch: bool = False\n \n",
        "source_code_with_indent": "\n        self.symbol: str = None\n        self.selref: ObjcSelref = None\n        self.selector: ObjcSelector = None\n\n        self.is_external_c_call: bool = None\n        self.is_external_objc_call: bool = None\n\n        self.is_local_branch: bool = None\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n        self.symbol: str = ''\n        self.selref: Optional[ObjcSelref] = None\n        self.selector: Optional[ObjcSelector] = None\n\n        self.is_external_c_call: bool = False\n        self.is_external_objc_call: bool = False\n\n        self.is_local_branch: bool = False\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "datatheorem/strongarm",
    "commit": "ab620d78b4ce7f933cedc25960307f2c3b03c1a8",
    "filename": "strongarm/objc/objc_instruction.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/datatheorem-strongarm/strongarm/objc/objc_instruction.py",
    "file_hunks_size": 16,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "strongarm/objc/objc_instruction.py:74:8 Incompatible attribute type [8]: Attribute `selector` declared in class `ObjcBranchInstruction` has type `ObjcSelector` but is used as type `None`.",
    "message": " Attribute `selector` declared in class `ObjcBranchInstruction` has type `ObjcSelector` but is used as type `None`.",
    "rule_id": "Incompatible attribute type [8]",
    "warning_line_no": 74,
    "warning_line": "        self.selector: ObjcSelector = None",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "# -*- coding: utf-8 -*-\nfrom typing import Union\nfrom typing import TYPE_CHECKING\n",
        "source_code_len": 82,
        "target_code": "# -*- coding: utf-8 -*-\nfrom typing import Optional, Union\nfrom typing import TYPE_CHECKING\n",
        "target_code_len": 92,
        "diff_format": "@@ -1,3 +1,3 @@\n # -*- coding: utf-8 -*-\n-from typing import Union\n+from typing import Optional, Union\n from typing import TYPE_CHECKING\n",
        "source_code_with_indent": "# -*- coding: utf-8 -*-\nfrom typing import Union\nfrom typing import TYPE_CHECKING\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "# -*- coding: utf-8 -*-\nfrom typing import Optional, Union\nfrom typing import TYPE_CHECKING\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n        self.symbol: str = None\n        self.selref: ObjcSelref = None\n        self.selector: ObjcSelector = None\n\n        self.is_external_c_call: bool = None\n        self.is_external_objc_call: bool = None\n\n        self.is_local_branch: bool = None\n\n",
        "source_code_len": 253,
        "target_code": "\n        self.symbol: str = ''\n        self.selref: Optional[ObjcSelref] = None\n        self.selector: Optional[ObjcSelector] = None\n\n        self.is_external_c_call: bool = False\n        self.is_external_objc_call: bool = False\n\n        self.is_local_branch: bool = False\n\n",
        "target_code_len": 274,
        "diff_format": "@@ -71,10 +71,10 @@\n \n-        self.symbol: str = None\n-        self.selref: ObjcSelref = None\n-        self.selector: ObjcSelector = None\n-\n-        self.is_external_c_call: bool = None\n-        self.is_external_objc_call: bool = None\n-\n-        self.is_local_branch: bool = None\n+        self.symbol: str = ''\n+        self.selref: Optional[ObjcSelref] = None\n+        self.selector: Optional[ObjcSelector] = None\n+\n+        self.is_external_c_call: bool = False\n+        self.is_external_objc_call: bool = False\n+\n+        self.is_local_branch: bool = False\n \n",
        "source_code_with_indent": "\n        self.symbol: str = None\n        self.selref: ObjcSelref = None\n        self.selector: ObjcSelector = None\n\n        self.is_external_c_call: bool = None\n        self.is_external_objc_call: bool = None\n\n        self.is_local_branch: bool = None\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n        self.symbol: str = ''\n        self.selref: Optional[ObjcSelref] = None\n        self.selector: Optional[ObjcSelector] = None\n\n        self.is_external_c_call: bool = False\n        self.is_external_objc_call: bool = False\n\n        self.is_local_branch: bool = False\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "datatheorem/strongarm",
    "commit": "ab620d78b4ce7f933cedc25960307f2c3b03c1a8",
    "filename": "strongarm/objc/objc_instruction.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/datatheorem-strongarm/strongarm/objc/objc_instruction.py",
    "file_hunks_size": 16,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "strongarm/objc/objc_instruction.py:76:8 Incompatible attribute type [8]: Attribute `is_external_c_call` declared in class `ObjcBranchInstruction` has type `bool` but is used as type `None`.",
    "message": " Attribute `is_external_c_call` declared in class `ObjcBranchInstruction` has type `bool` but is used as type `None`.",
    "rule_id": "Incompatible attribute type [8]",
    "warning_line_no": 76,
    "warning_line": "        self.is_external_c_call: bool = None",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "# -*- coding: utf-8 -*-\nfrom typing import Union\nfrom typing import TYPE_CHECKING\n",
        "source_code_len": 82,
        "target_code": "# -*- coding: utf-8 -*-\nfrom typing import Optional, Union\nfrom typing import TYPE_CHECKING\n",
        "target_code_len": 92,
        "diff_format": "@@ -1,3 +1,3 @@\n # -*- coding: utf-8 -*-\n-from typing import Union\n+from typing import Optional, Union\n from typing import TYPE_CHECKING\n",
        "source_code_with_indent": "# -*- coding: utf-8 -*-\nfrom typing import Union\nfrom typing import TYPE_CHECKING\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "# -*- coding: utf-8 -*-\nfrom typing import Optional, Union\nfrom typing import TYPE_CHECKING\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n        self.symbol: str = None\n        self.selref: ObjcSelref = None\n        self.selector: ObjcSelector = None\n\n        self.is_external_c_call: bool = None\n        self.is_external_objc_call: bool = None\n\n        self.is_local_branch: bool = None\n\n",
        "source_code_len": 253,
        "target_code": "\n        self.symbol: str = ''\n        self.selref: Optional[ObjcSelref] = None\n        self.selector: Optional[ObjcSelector] = None\n\n        self.is_external_c_call: bool = False\n        self.is_external_objc_call: bool = False\n\n        self.is_local_branch: bool = False\n\n",
        "target_code_len": 274,
        "diff_format": "@@ -71,10 +71,10 @@\n \n-        self.symbol: str = None\n-        self.selref: ObjcSelref = None\n-        self.selector: ObjcSelector = None\n-\n-        self.is_external_c_call: bool = None\n-        self.is_external_objc_call: bool = None\n-\n-        self.is_local_branch: bool = None\n+        self.symbol: str = ''\n+        self.selref: Optional[ObjcSelref] = None\n+        self.selector: Optional[ObjcSelector] = None\n+\n+        self.is_external_c_call: bool = False\n+        self.is_external_objc_call: bool = False\n+\n+        self.is_local_branch: bool = False\n \n",
        "source_code_with_indent": "\n        self.symbol: str = None\n        self.selref: ObjcSelref = None\n        self.selector: ObjcSelector = None\n\n        self.is_external_c_call: bool = None\n        self.is_external_objc_call: bool = None\n\n        self.is_local_branch: bool = None\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n        self.symbol: str = ''\n        self.selref: Optional[ObjcSelref] = None\n        self.selector: Optional[ObjcSelector] = None\n\n        self.is_external_c_call: bool = False\n        self.is_external_objc_call: bool = False\n\n        self.is_local_branch: bool = False\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "datatheorem/strongarm",
    "commit": "ab620d78b4ce7f933cedc25960307f2c3b03c1a8",
    "filename": "strongarm/objc/objc_instruction.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/datatheorem-strongarm/strongarm/objc/objc_instruction.py",
    "file_hunks_size": 16,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "strongarm/objc/objc_instruction.py:77:8 Incompatible attribute type [8]: Attribute `is_external_objc_call` declared in class `ObjcBranchInstruction` has type `bool` but is used as type `None`.",
    "message": " Attribute `is_external_objc_call` declared in class `ObjcBranchInstruction` has type `bool` but is used as type `None`.",
    "rule_id": "Incompatible attribute type [8]",
    "warning_line_no": 77,
    "warning_line": "        self.is_external_objc_call: bool = None",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "# -*- coding: utf-8 -*-\nfrom typing import Union\nfrom typing import TYPE_CHECKING\n",
        "source_code_len": 82,
        "target_code": "# -*- coding: utf-8 -*-\nfrom typing import Optional, Union\nfrom typing import TYPE_CHECKING\n",
        "target_code_len": 92,
        "diff_format": "@@ -1,3 +1,3 @@\n # -*- coding: utf-8 -*-\n-from typing import Union\n+from typing import Optional, Union\n from typing import TYPE_CHECKING\n",
        "source_code_with_indent": "# -*- coding: utf-8 -*-\nfrom typing import Union\nfrom typing import TYPE_CHECKING\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "# -*- coding: utf-8 -*-\nfrom typing import Optional, Union\nfrom typing import TYPE_CHECKING\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n        self.symbol: str = None\n        self.selref: ObjcSelref = None\n        self.selector: ObjcSelector = None\n\n        self.is_external_c_call: bool = None\n        self.is_external_objc_call: bool = None\n\n        self.is_local_branch: bool = None\n\n",
        "source_code_len": 253,
        "target_code": "\n        self.symbol: str = ''\n        self.selref: Optional[ObjcSelref] = None\n        self.selector: Optional[ObjcSelector] = None\n\n        self.is_external_c_call: bool = False\n        self.is_external_objc_call: bool = False\n\n        self.is_local_branch: bool = False\n\n",
        "target_code_len": 274,
        "diff_format": "@@ -71,10 +71,10 @@\n \n-        self.symbol: str = None\n-        self.selref: ObjcSelref = None\n-        self.selector: ObjcSelector = None\n-\n-        self.is_external_c_call: bool = None\n-        self.is_external_objc_call: bool = None\n-\n-        self.is_local_branch: bool = None\n+        self.symbol: str = ''\n+        self.selref: Optional[ObjcSelref] = None\n+        self.selector: Optional[ObjcSelector] = None\n+\n+        self.is_external_c_call: bool = False\n+        self.is_external_objc_call: bool = False\n+\n+        self.is_local_branch: bool = False\n \n",
        "source_code_with_indent": "\n        self.symbol: str = None\n        self.selref: ObjcSelref = None\n        self.selector: ObjcSelector = None\n\n        self.is_external_c_call: bool = None\n        self.is_external_objc_call: bool = None\n\n        self.is_local_branch: bool = None\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n        self.symbol: str = ''\n        self.selref: Optional[ObjcSelref] = None\n        self.selector: Optional[ObjcSelector] = None\n\n        self.is_external_c_call: bool = False\n        self.is_external_objc_call: bool = False\n\n        self.is_local_branch: bool = False\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "datatheorem/strongarm",
    "commit": "ab620d78b4ce7f933cedc25960307f2c3b03c1a8",
    "filename": "strongarm/objc/objc_instruction.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/datatheorem-strongarm/strongarm/objc/objc_instruction.py",
    "file_hunks_size": 16,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "strongarm/objc/objc_instruction.py:79:8 Incompatible attribute type [8]: Attribute `is_local_branch` declared in class `ObjcBranchInstruction` has type `bool` but is used as type `None`.",
    "message": " Attribute `is_local_branch` declared in class `ObjcBranchInstruction` has type `bool` but is used as type `None`.",
    "rule_id": "Incompatible attribute type [8]",
    "warning_line_no": 79,
    "warning_line": "        self.is_local_branch: bool = None",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "# -*- coding: utf-8 -*-\nfrom typing import Union\nfrom typing import TYPE_CHECKING\n",
        "source_code_len": 82,
        "target_code": "# -*- coding: utf-8 -*-\nfrom typing import Optional, Union\nfrom typing import TYPE_CHECKING\n",
        "target_code_len": 92,
        "diff_format": "@@ -1,3 +1,3 @@\n # -*- coding: utf-8 -*-\n-from typing import Union\n+from typing import Optional, Union\n from typing import TYPE_CHECKING\n",
        "source_code_with_indent": "# -*- coding: utf-8 -*-\nfrom typing import Union\nfrom typing import TYPE_CHECKING\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "# -*- coding: utf-8 -*-\nfrom typing import Optional, Union\nfrom typing import TYPE_CHECKING\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n        self.symbol: str = None\n        self.selref: ObjcSelref = None\n        self.selector: ObjcSelector = None\n\n        self.is_external_c_call: bool = None\n        self.is_external_objc_call: bool = None\n\n        self.is_local_branch: bool = None\n\n",
        "source_code_len": 253,
        "target_code": "\n        self.symbol: str = ''\n        self.selref: Optional[ObjcSelref] = None\n        self.selector: Optional[ObjcSelector] = None\n\n        self.is_external_c_call: bool = False\n        self.is_external_objc_call: bool = False\n\n        self.is_local_branch: bool = False\n\n",
        "target_code_len": 274,
        "diff_format": "@@ -71,10 +71,10 @@\n \n-        self.symbol: str = None\n-        self.selref: ObjcSelref = None\n-        self.selector: ObjcSelector = None\n-\n-        self.is_external_c_call: bool = None\n-        self.is_external_objc_call: bool = None\n-\n-        self.is_local_branch: bool = None\n+        self.symbol: str = ''\n+        self.selref: Optional[ObjcSelref] = None\n+        self.selector: Optional[ObjcSelector] = None\n+\n+        self.is_external_c_call: bool = False\n+        self.is_external_objc_call: bool = False\n+\n+        self.is_local_branch: bool = False\n \n",
        "source_code_with_indent": "\n        self.symbol: str = None\n        self.selref: ObjcSelref = None\n        self.selector: ObjcSelector = None\n\n        self.is_external_c_call: bool = None\n        self.is_external_objc_call: bool = None\n\n        self.is_local_branch: bool = None\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n        self.symbol: str = ''\n        self.selref: Optional[ObjcSelref] = None\n        self.selector: Optional[ObjcSelector] = None\n\n        self.is_external_c_call: bool = False\n        self.is_external_objc_call: bool = False\n\n        self.is_local_branch: bool = False\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "datatheorem/strongarm",
    "commit": "ab620d78b4ce7f933cedc25960307f2c3b03c1a8",
    "filename": "strongarm/objc/objc_instruction.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/datatheorem-strongarm/strongarm/objc/objc_instruction.py",
    "file_hunks_size": 16,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": true,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "strongarm/objc/objc_instruction.py:179:12 Incompatible attribute type [8]: Attribute `destination_address` declared in class `ObjcBranchInstruction` has type `int` but is used as type `None`.",
    "message": " Attribute `destination_address` declared in class `ObjcBranchInstruction` has type `int` but is used as type `None`.",
    "rule_id": "Incompatible attribute type [8]",
    "warning_line_no": 179,
    "warning_line": "            self.destination_address = None",
    "min_patch": [
      {
        "hunk_fit_TFix": true,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "            self.is_external_objc_call = True\n            self.destination_address = None\n            self.selref = None\n            self.selector = None\n\n",
        "source_code_len": 155,
        "target_code": "            self.is_external_objc_call = True\n            self.destination_address = 0\n            # self.selref: ObjcSelref\n            # self.selector: ObjcSelector\n\n",
        "target_code_len": 168,
        "diff_format": "@@ -178,5 +186,5 @@\n             self.is_external_objc_call = True\n-            self.destination_address = None\n-            self.selref = None\n-            self.selector = None\n+            self.destination_address = 0\n+            # self.selref: ObjcSelref\n+            # self.selector: ObjcSelector\n \n",
        "source_code_with_indent": "            <IND>self.is_external_objc_call = True\n            self.destination_address = None\n            self.selref = None\n            self.selector = None\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "            <IND>self.is_external_objc_call = True\n            self.destination_address = 0\n            # self.selref: ObjcSelref\n            # self.selector: ObjcSelector\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "datatheorem/strongarm",
    "commit": "ab620d78b4ce7f933cedc25960307f2c3b03c1a8",
    "filename": "strongarm/objc/objc_instruction.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/datatheorem-strongarm/strongarm/objc/objc_instruction.py",
    "file_hunks_size": 16,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": true,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "strongarm/objc/objc_instruction.py:180:12 Incompatible attribute type [8]: Attribute `selref` declared in class `ObjcBranchInstruction` has type `ObjcSelref` but is used as type `None`.",
    "message": " Attribute `selref` declared in class `ObjcBranchInstruction` has type `ObjcSelref` but is used as type `None`.",
    "rule_id": "Incompatible attribute type [8]",
    "warning_line_no": 180,
    "warning_line": "            self.selref = None",
    "min_patch": [
      {
        "hunk_fit_TFix": true,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "            self.is_external_objc_call = True\n            self.destination_address = None\n            self.selref = None\n            self.selector = None\n\n",
        "source_code_len": 155,
        "target_code": "            self.is_external_objc_call = True\n            self.destination_address = 0\n            # self.selref: ObjcSelref\n            # self.selector: ObjcSelector\n\n",
        "target_code_len": 168,
        "diff_format": "@@ -178,5 +186,5 @@\n             self.is_external_objc_call = True\n-            self.destination_address = None\n-            self.selref = None\n-            self.selector = None\n+            self.destination_address = 0\n+            # self.selref: ObjcSelref\n+            # self.selector: ObjcSelector\n \n",
        "source_code_with_indent": "            <IND>self.is_external_objc_call = True\n            self.destination_address = None\n            self.selref = None\n            self.selector = None\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "            <IND>self.is_external_objc_call = True\n            self.destination_address = 0\n            # self.selref: ObjcSelref\n            # self.selector: ObjcSelector\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "datatheorem/strongarm",
    "commit": "ab620d78b4ce7f933cedc25960307f2c3b03c1a8",
    "filename": "strongarm/objc/objc_instruction.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/datatheorem-strongarm/strongarm/objc/objc_instruction.py",
    "file_hunks_size": 16,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": true,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "strongarm/objc/objc_instruction.py:181:12 Incompatible attribute type [8]: Attribute `selector` declared in class `ObjcBranchInstruction` has type `ObjcSelector` but is used as type `None`.",
    "message": " Attribute `selector` declared in class `ObjcBranchInstruction` has type `ObjcSelector` but is used as type `None`.",
    "rule_id": "Incompatible attribute type [8]",
    "warning_line_no": 181,
    "warning_line": "            self.selector = None",
    "min_patch": [
      {
        "hunk_fit_TFix": true,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "            self.is_external_objc_call = True\n            self.destination_address = None\n            self.selref = None\n            self.selector = None\n\n",
        "source_code_len": 155,
        "target_code": "            self.is_external_objc_call = True\n            self.destination_address = 0\n            # self.selref: ObjcSelref\n            # self.selector: ObjcSelector\n\n",
        "target_code_len": 168,
        "diff_format": "@@ -178,5 +186,5 @@\n             self.is_external_objc_call = True\n-            self.destination_address = None\n-            self.selref = None\n-            self.selector = None\n+            self.destination_address = 0\n+            # self.selref: ObjcSelref\n+            # self.selector: ObjcSelector\n \n",
        "source_code_with_indent": "            <IND>self.is_external_objc_call = True\n            self.destination_address = None\n            self.selref = None\n            self.selector = None\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "            <IND>self.is_external_objc_call = True\n            self.destination_address = 0\n            # self.selref: ObjcSelref\n            # self.selector: ObjcSelector\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  }
]