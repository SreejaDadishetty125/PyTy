[
  {
    "project": "python/mypy",
    "commit": "f98f78216ba9d6ab68c8e69c19e9f3c7926c5efe",
    "filename": "mypy/build.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/python-mypy/mypy/build.py",
    "file_hunks_size": 39,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "mypy/build.py:1727:4 Incompatible attribute type [8]: Attribute `manager` declared in class `State` has type `BuildManager` but is used as type `None`.",
    "message": " Attribute `manager` declared in class `State` has type `BuildManager` but is used as type `None`.",
    "rule_id": "Incompatible attribute type [8]",
    "warning_line_no": 1727,
    "warning_line": "    manager = None  # type: BuildManager",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n    manager = None  # type: BuildManager\n    order_counter = 0  # type: ClassVar[int]\n    order = None  # type: int  # Order in which modules were encountered\n    id = None  # type: str  # Fully qualified module name\n    path = None  # type: Optional[str]  # Path to module source\n    abspath = None  # type: Optional[str]  # Absolute path to module source\n    xpath = None  # type: str  # Path or '<string>'\n    source = None  # type: Optional[str]  # Module source code\n    source_hash = None  # type: Optional[str]  # Hash calculated based on the source code\n    meta_source_hash = None  # type: Optional[str]  # Hash of the source given in the meta, if any\n    meta = None  # type: Optional[CacheMeta]\n    data = None  # type: Optional[str]\n    tree = None  # type: Optional[MypyFile]\n    # We keep both a list and set of dependencies. A set because it makes it efficient to\n",
        "source_code_len": 880,
        "target_code": "\n    manager: BuildManager\n    order_counter: ClassVar[int] = 0\n    order: int  # Order in which modules were encountered\n    id: str  # Fully qualified module name\n    path: Optional[str] = None  # Path to module source\n    abspath: Optional[str] = None  # Absolute path to module source\n    xpath: str  # Path or '<string>'\n    source: Optional[str] = None  # Module source code\n    source_hash: Optional[str] = None  # Hash calculated based on the source code\n    meta_source_hash: Optional[str] = None  # Hash of the source given in the meta, if any\n    meta: Optional[CacheMeta] = None\n    data: Optional[str] = None\n    tree: Optional[MypyFile] = None\n    # We keep both a list and set of dependencies. A set because it makes it efficient to\n",
        "target_code_len": 748,
        "diff_format": "@@ -1726,15 +1727,15 @@\n \n-    manager = None  # type: BuildManager\n-    order_counter = 0  # type: ClassVar[int]\n-    order = None  # type: int  # Order in which modules were encountered\n-    id = None  # type: str  # Fully qualified module name\n-    path = None  # type: Optional[str]  # Path to module source\n-    abspath = None  # type: Optional[str]  # Absolute path to module source\n-    xpath = None  # type: str  # Path or '<string>'\n-    source = None  # type: Optional[str]  # Module source code\n-    source_hash = None  # type: Optional[str]  # Hash calculated based on the source code\n-    meta_source_hash = None  # type: Optional[str]  # Hash of the source given in the meta, if any\n-    meta = None  # type: Optional[CacheMeta]\n-    data = None  # type: Optional[str]\n-    tree = None  # type: Optional[MypyFile]\n+    manager: BuildManager\n+    order_counter: ClassVar[int] = 0\n+    order: int  # Order in which modules were encountered\n+    id: str  # Fully qualified module name\n+    path: Optional[str] = None  # Path to module source\n+    abspath: Optional[str] = None  # Absolute path to module source\n+    xpath: str  # Path or '<string>'\n+    source: Optional[str] = None  # Module source code\n+    source_hash: Optional[str] = None  # Hash calculated based on the source code\n+    meta_source_hash: Optional[str] = None  # Hash of the source given in the meta, if any\n+    meta: Optional[CacheMeta] = None\n+    data: Optional[str] = None\n+    tree: Optional[MypyFile] = None\n     # We keep both a list and set of dependencies. A set because it makes it efficient to\n",
        "source_code_with_indent": "\n    manager = None  # type: BuildManager\n    order_counter = 0  # type: ClassVar[int]\n    order = None  # type: int  # Order in which modules were encountered\n    id = None  # type: str  # Fully qualified module name\n    path = None  # type: Optional[str]  # Path to module source\n    abspath = None  # type: Optional[str]  # Absolute path to module source\n    xpath = None  # type: str  # Path or '<string>'\n    source = None  # type: Optional[str]  # Module source code\n    source_hash = None  # type: Optional[str]  # Hash calculated based on the source code\n    meta_source_hash = None  # type: Optional[str]  # Hash of the source given in the meta, if any\n    meta = None  # type: Optional[CacheMeta]\n    data = None  # type: Optional[str]\n    tree = None  # type: Optional[MypyFile]\n    # We keep both a list and set of dependencies. A set because it makes it efficient to\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n    manager: BuildManager\n    order_counter: ClassVar[int] = 0\n    order: int  # Order in which modules were encountered\n    id: str  # Fully qualified module name\n    path: Optional[str] = None  # Path to module source\n    abspath: Optional[str] = None  # Absolute path to module source\n    xpath: str  # Path or '<string>'\n    source: Optional[str] = None  # Module source code\n    source_hash: Optional[str] = None  # Hash calculated based on the source code\n    meta_source_hash: Optional[str] = None  # Hash of the source given in the meta, if any\n    meta: Optional[CacheMeta] = None\n    data: Optional[str] = None\n    tree: Optional[MypyFile] = None\n    # We keep both a list and set of dependencies. A set because it makes it efficient to\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "python/mypy",
    "commit": "f98f78216ba9d6ab68c8e69c19e9f3c7926c5efe",
    "filename": "mypy/build.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/python-mypy/mypy/build.py",
    "file_hunks_size": 39,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "mypy/build.py:1729:4 Incompatible attribute type [8]: Attribute `order` declared in class `State` has type `int` but is used as type `None`.",
    "message": " Attribute `order` declared in class `State` has type `int` but is used as type `None`.",
    "rule_id": "Incompatible attribute type [8]",
    "warning_line_no": 1729,
    "warning_line": "    order = None  # type: int  # Order in which modules were encountered",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n    manager = None  # type: BuildManager\n    order_counter = 0  # type: ClassVar[int]\n    order = None  # type: int  # Order in which modules were encountered\n    id = None  # type: str  # Fully qualified module name\n    path = None  # type: Optional[str]  # Path to module source\n    abspath = None  # type: Optional[str]  # Absolute path to module source\n    xpath = None  # type: str  # Path or '<string>'\n    source = None  # type: Optional[str]  # Module source code\n    source_hash = None  # type: Optional[str]  # Hash calculated based on the source code\n    meta_source_hash = None  # type: Optional[str]  # Hash of the source given in the meta, if any\n    meta = None  # type: Optional[CacheMeta]\n    data = None  # type: Optional[str]\n    tree = None  # type: Optional[MypyFile]\n    # We keep both a list and set of dependencies. A set because it makes it efficient to\n",
        "source_code_len": 880,
        "target_code": "\n    manager: BuildManager\n    order_counter: ClassVar[int] = 0\n    order: int  # Order in which modules were encountered\n    id: str  # Fully qualified module name\n    path: Optional[str] = None  # Path to module source\n    abspath: Optional[str] = None  # Absolute path to module source\n    xpath: str  # Path or '<string>'\n    source: Optional[str] = None  # Module source code\n    source_hash: Optional[str] = None  # Hash calculated based on the source code\n    meta_source_hash: Optional[str] = None  # Hash of the source given in the meta, if any\n    meta: Optional[CacheMeta] = None\n    data: Optional[str] = None\n    tree: Optional[MypyFile] = None\n    # We keep both a list and set of dependencies. A set because it makes it efficient to\n",
        "target_code_len": 748,
        "diff_format": "@@ -1726,15 +1727,15 @@\n \n-    manager = None  # type: BuildManager\n-    order_counter = 0  # type: ClassVar[int]\n-    order = None  # type: int  # Order in which modules were encountered\n-    id = None  # type: str  # Fully qualified module name\n-    path = None  # type: Optional[str]  # Path to module source\n-    abspath = None  # type: Optional[str]  # Absolute path to module source\n-    xpath = None  # type: str  # Path or '<string>'\n-    source = None  # type: Optional[str]  # Module source code\n-    source_hash = None  # type: Optional[str]  # Hash calculated based on the source code\n-    meta_source_hash = None  # type: Optional[str]  # Hash of the source given in the meta, if any\n-    meta = None  # type: Optional[CacheMeta]\n-    data = None  # type: Optional[str]\n-    tree = None  # type: Optional[MypyFile]\n+    manager: BuildManager\n+    order_counter: ClassVar[int] = 0\n+    order: int  # Order in which modules were encountered\n+    id: str  # Fully qualified module name\n+    path: Optional[str] = None  # Path to module source\n+    abspath: Optional[str] = None  # Absolute path to module source\n+    xpath: str  # Path or '<string>'\n+    source: Optional[str] = None  # Module source code\n+    source_hash: Optional[str] = None  # Hash calculated based on the source code\n+    meta_source_hash: Optional[str] = None  # Hash of the source given in the meta, if any\n+    meta: Optional[CacheMeta] = None\n+    data: Optional[str] = None\n+    tree: Optional[MypyFile] = None\n     # We keep both a list and set of dependencies. A set because it makes it efficient to\n",
        "source_code_with_indent": "\n    manager = None  # type: BuildManager\n    order_counter = 0  # type: ClassVar[int]\n    order = None  # type: int  # Order in which modules were encountered\n    id = None  # type: str  # Fully qualified module name\n    path = None  # type: Optional[str]  # Path to module source\n    abspath = None  # type: Optional[str]  # Absolute path to module source\n    xpath = None  # type: str  # Path or '<string>'\n    source = None  # type: Optional[str]  # Module source code\n    source_hash = None  # type: Optional[str]  # Hash calculated based on the source code\n    meta_source_hash = None  # type: Optional[str]  # Hash of the source given in the meta, if any\n    meta = None  # type: Optional[CacheMeta]\n    data = None  # type: Optional[str]\n    tree = None  # type: Optional[MypyFile]\n    # We keep both a list and set of dependencies. A set because it makes it efficient to\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n    manager: BuildManager\n    order_counter: ClassVar[int] = 0\n    order: int  # Order in which modules were encountered\n    id: str  # Fully qualified module name\n    path: Optional[str] = None  # Path to module source\n    abspath: Optional[str] = None  # Absolute path to module source\n    xpath: str  # Path or '<string>'\n    source: Optional[str] = None  # Module source code\n    source_hash: Optional[str] = None  # Hash calculated based on the source code\n    meta_source_hash: Optional[str] = None  # Hash of the source given in the meta, if any\n    meta: Optional[CacheMeta] = None\n    data: Optional[str] = None\n    tree: Optional[MypyFile] = None\n    # We keep both a list and set of dependencies. A set because it makes it efficient to\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "python/mypy",
    "commit": "f98f78216ba9d6ab68c8e69c19e9f3c7926c5efe",
    "filename": "mypy/build.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/python-mypy/mypy/build.py",
    "file_hunks_size": 39,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "mypy/build.py:1730:4 Incompatible attribute type [8]: Attribute `id` declared in class `State` has type `str` but is used as type `None`.",
    "message": " Attribute `id` declared in class `State` has type `str` but is used as type `None`.",
    "rule_id": "Incompatible attribute type [8]",
    "warning_line_no": 1730,
    "warning_line": "    id = None  # type: str  # Fully qualified module name",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n    manager = None  # type: BuildManager\n    order_counter = 0  # type: ClassVar[int]\n    order = None  # type: int  # Order in which modules were encountered\n    id = None  # type: str  # Fully qualified module name\n    path = None  # type: Optional[str]  # Path to module source\n    abspath = None  # type: Optional[str]  # Absolute path to module source\n    xpath = None  # type: str  # Path or '<string>'\n    source = None  # type: Optional[str]  # Module source code\n    source_hash = None  # type: Optional[str]  # Hash calculated based on the source code\n    meta_source_hash = None  # type: Optional[str]  # Hash of the source given in the meta, if any\n    meta = None  # type: Optional[CacheMeta]\n    data = None  # type: Optional[str]\n    tree = None  # type: Optional[MypyFile]\n    # We keep both a list and set of dependencies. A set because it makes it efficient to\n",
        "source_code_len": 880,
        "target_code": "\n    manager: BuildManager\n    order_counter: ClassVar[int] = 0\n    order: int  # Order in which modules were encountered\n    id: str  # Fully qualified module name\n    path: Optional[str] = None  # Path to module source\n    abspath: Optional[str] = None  # Absolute path to module source\n    xpath: str  # Path or '<string>'\n    source: Optional[str] = None  # Module source code\n    source_hash: Optional[str] = None  # Hash calculated based on the source code\n    meta_source_hash: Optional[str] = None  # Hash of the source given in the meta, if any\n    meta: Optional[CacheMeta] = None\n    data: Optional[str] = None\n    tree: Optional[MypyFile] = None\n    # We keep both a list and set of dependencies. A set because it makes it efficient to\n",
        "target_code_len": 748,
        "diff_format": "@@ -1726,15 +1727,15 @@\n \n-    manager = None  # type: BuildManager\n-    order_counter = 0  # type: ClassVar[int]\n-    order = None  # type: int  # Order in which modules were encountered\n-    id = None  # type: str  # Fully qualified module name\n-    path = None  # type: Optional[str]  # Path to module source\n-    abspath = None  # type: Optional[str]  # Absolute path to module source\n-    xpath = None  # type: str  # Path or '<string>'\n-    source = None  # type: Optional[str]  # Module source code\n-    source_hash = None  # type: Optional[str]  # Hash calculated based on the source code\n-    meta_source_hash = None  # type: Optional[str]  # Hash of the source given in the meta, if any\n-    meta = None  # type: Optional[CacheMeta]\n-    data = None  # type: Optional[str]\n-    tree = None  # type: Optional[MypyFile]\n+    manager: BuildManager\n+    order_counter: ClassVar[int] = 0\n+    order: int  # Order in which modules were encountered\n+    id: str  # Fully qualified module name\n+    path: Optional[str] = None  # Path to module source\n+    abspath: Optional[str] = None  # Absolute path to module source\n+    xpath: str  # Path or '<string>'\n+    source: Optional[str] = None  # Module source code\n+    source_hash: Optional[str] = None  # Hash calculated based on the source code\n+    meta_source_hash: Optional[str] = None  # Hash of the source given in the meta, if any\n+    meta: Optional[CacheMeta] = None\n+    data: Optional[str] = None\n+    tree: Optional[MypyFile] = None\n     # We keep both a list and set of dependencies. A set because it makes it efficient to\n",
        "source_code_with_indent": "\n    manager = None  # type: BuildManager\n    order_counter = 0  # type: ClassVar[int]\n    order = None  # type: int  # Order in which modules were encountered\n    id = None  # type: str  # Fully qualified module name\n    path = None  # type: Optional[str]  # Path to module source\n    abspath = None  # type: Optional[str]  # Absolute path to module source\n    xpath = None  # type: str  # Path or '<string>'\n    source = None  # type: Optional[str]  # Module source code\n    source_hash = None  # type: Optional[str]  # Hash calculated based on the source code\n    meta_source_hash = None  # type: Optional[str]  # Hash of the source given in the meta, if any\n    meta = None  # type: Optional[CacheMeta]\n    data = None  # type: Optional[str]\n    tree = None  # type: Optional[MypyFile]\n    # We keep both a list and set of dependencies. A set because it makes it efficient to\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n    manager: BuildManager\n    order_counter: ClassVar[int] = 0\n    order: int  # Order in which modules were encountered\n    id: str  # Fully qualified module name\n    path: Optional[str] = None  # Path to module source\n    abspath: Optional[str] = None  # Absolute path to module source\n    xpath: str  # Path or '<string>'\n    source: Optional[str] = None  # Module source code\n    source_hash: Optional[str] = None  # Hash calculated based on the source code\n    meta_source_hash: Optional[str] = None  # Hash of the source given in the meta, if any\n    meta: Optional[CacheMeta] = None\n    data: Optional[str] = None\n    tree: Optional[MypyFile] = None\n    # We keep both a list and set of dependencies. A set because it makes it efficient to\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "python/mypy",
    "commit": "f98f78216ba9d6ab68c8e69c19e9f3c7926c5efe",
    "filename": "mypy/build.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/python-mypy/mypy/build.py",
    "file_hunks_size": 39,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "mypy/build.py:1733:4 Incompatible attribute type [8]: Attribute `xpath` declared in class `State` has type `str` but is used as type `None`.",
    "message": " Attribute `xpath` declared in class `State` has type `str` but is used as type `None`.",
    "rule_id": "Incompatible attribute type [8]",
    "warning_line_no": 1733,
    "warning_line": "    xpath = None  # type: str  # Path or '<string>'",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n    manager = None  # type: BuildManager\n    order_counter = 0  # type: ClassVar[int]\n    order = None  # type: int  # Order in which modules were encountered\n    id = None  # type: str  # Fully qualified module name\n    path = None  # type: Optional[str]  # Path to module source\n    abspath = None  # type: Optional[str]  # Absolute path to module source\n    xpath = None  # type: str  # Path or '<string>'\n    source = None  # type: Optional[str]  # Module source code\n    source_hash = None  # type: Optional[str]  # Hash calculated based on the source code\n    meta_source_hash = None  # type: Optional[str]  # Hash of the source given in the meta, if any\n    meta = None  # type: Optional[CacheMeta]\n    data = None  # type: Optional[str]\n    tree = None  # type: Optional[MypyFile]\n    # We keep both a list and set of dependencies. A set because it makes it efficient to\n",
        "source_code_len": 880,
        "target_code": "\n    manager: BuildManager\n    order_counter: ClassVar[int] = 0\n    order: int  # Order in which modules were encountered\n    id: str  # Fully qualified module name\n    path: Optional[str] = None  # Path to module source\n    abspath: Optional[str] = None  # Absolute path to module source\n    xpath: str  # Path or '<string>'\n    source: Optional[str] = None  # Module source code\n    source_hash: Optional[str] = None  # Hash calculated based on the source code\n    meta_source_hash: Optional[str] = None  # Hash of the source given in the meta, if any\n    meta: Optional[CacheMeta] = None\n    data: Optional[str] = None\n    tree: Optional[MypyFile] = None\n    # We keep both a list and set of dependencies. A set because it makes it efficient to\n",
        "target_code_len": 748,
        "diff_format": "@@ -1726,15 +1727,15 @@\n \n-    manager = None  # type: BuildManager\n-    order_counter = 0  # type: ClassVar[int]\n-    order = None  # type: int  # Order in which modules were encountered\n-    id = None  # type: str  # Fully qualified module name\n-    path = None  # type: Optional[str]  # Path to module source\n-    abspath = None  # type: Optional[str]  # Absolute path to module source\n-    xpath = None  # type: str  # Path or '<string>'\n-    source = None  # type: Optional[str]  # Module source code\n-    source_hash = None  # type: Optional[str]  # Hash calculated based on the source code\n-    meta_source_hash = None  # type: Optional[str]  # Hash of the source given in the meta, if any\n-    meta = None  # type: Optional[CacheMeta]\n-    data = None  # type: Optional[str]\n-    tree = None  # type: Optional[MypyFile]\n+    manager: BuildManager\n+    order_counter: ClassVar[int] = 0\n+    order: int  # Order in which modules were encountered\n+    id: str  # Fully qualified module name\n+    path: Optional[str] = None  # Path to module source\n+    abspath: Optional[str] = None  # Absolute path to module source\n+    xpath: str  # Path or '<string>'\n+    source: Optional[str] = None  # Module source code\n+    source_hash: Optional[str] = None  # Hash calculated based on the source code\n+    meta_source_hash: Optional[str] = None  # Hash of the source given in the meta, if any\n+    meta: Optional[CacheMeta] = None\n+    data: Optional[str] = None\n+    tree: Optional[MypyFile] = None\n     # We keep both a list and set of dependencies. A set because it makes it efficient to\n",
        "source_code_with_indent": "\n    manager = None  # type: BuildManager\n    order_counter = 0  # type: ClassVar[int]\n    order = None  # type: int  # Order in which modules were encountered\n    id = None  # type: str  # Fully qualified module name\n    path = None  # type: Optional[str]  # Path to module source\n    abspath = None  # type: Optional[str]  # Absolute path to module source\n    xpath = None  # type: str  # Path or '<string>'\n    source = None  # type: Optional[str]  # Module source code\n    source_hash = None  # type: Optional[str]  # Hash calculated based on the source code\n    meta_source_hash = None  # type: Optional[str]  # Hash of the source given in the meta, if any\n    meta = None  # type: Optional[CacheMeta]\n    data = None  # type: Optional[str]\n    tree = None  # type: Optional[MypyFile]\n    # We keep both a list and set of dependencies. A set because it makes it efficient to\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n    manager: BuildManager\n    order_counter: ClassVar[int] = 0\n    order: int  # Order in which modules were encountered\n    id: str  # Fully qualified module name\n    path: Optional[str] = None  # Path to module source\n    abspath: Optional[str] = None  # Absolute path to module source\n    xpath: str  # Path or '<string>'\n    source: Optional[str] = None  # Module source code\n    source_hash: Optional[str] = None  # Hash calculated based on the source code\n    meta_source_hash: Optional[str] = None  # Hash of the source given in the meta, if any\n    meta: Optional[CacheMeta] = None\n    data: Optional[str] = None\n    tree: Optional[MypyFile] = None\n    # We keep both a list and set of dependencies. A set because it makes it efficient to\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "python/mypy",
    "commit": "f98f78216ba9d6ab68c8e69c19e9f3c7926c5efe",
    "filename": "mypy/build.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/python-mypy/mypy/build.py",
    "file_hunks_size": 39,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "mypy/build.py:1744:4 Incompatible attribute type [8]: Attribute `dependencies` declared in class `State` has type `List[str]` but is used as type `None`.",
    "message": " Attribute `dependencies` declared in class `State` has type `List[str]` but is used as type `None`.",
    "rule_id": "Incompatible attribute type [8]",
    "warning_line_no": 1744,
    "warning_line": "    dependencies = None  # type: List[str]  # Modules directly imported by the module",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    # They should be managed with add_dependency and suppress_dependency.\n    dependencies = None  # type: List[str]  # Modules directly imported by the module\n    dependencies_set = None  # type: Set[str]  # The same but as a set for deduplication purposes\n    suppressed = None  # type: List[str]  # Suppressed/missing dependencies\n    suppressed_set = None  # type: Set[str]  # Suppressed/missing dependencies\n    priorities = None  # type: Dict[str, int]\n\n    # Map each dependency to the line number where it is first imported\n    dep_line_map = None  # type: Dict[str, int]\n\n    # Parent package, its parent, etc.\n    ancestors = None  # type: Optional[List[str]]\n\n    # List of (path, line number) tuples giving context for import\n    import_context = None  # type: List[Tuple[str, int]]\n\n    # The State from which this module was imported, if any\n    caller_state = None  # type: Optional[State]\n\n",
        "source_code_len": 906,
        "target_code": "    # They should be managed with add_dependency and suppress_dependency.\n    dependencies: List[str]  # Modules directly imported by the module\n    dependencies_set: Set[str]  # The same but as a set for deduplication purposes\n    suppressed: List[str]  # Suppressed/missing dependencies\n    suppressed_set: Set[str]  # Suppressed/missing dependencies\n    priorities: Dict[str, int]\n\n    # Map each dependency to the line number where it is first imported\n    dep_line_map: Dict[str, int]\n\n    # Parent package, its parent, etc.\n    ancestors: Optional[List[str]] = None\n\n    # List of (path, line number) tuples giving context for import\n    import_context: List[Tuple[str, int]]\n\n    # The State from which this module was imported, if any\n    caller_state: Optional[\"State\"] = None\n\n",
        "target_code_len": 787,
        "diff_format": "@@ -1743,19 +1744,19 @@\n     # They should be managed with add_dependency and suppress_dependency.\n-    dependencies = None  # type: List[str]  # Modules directly imported by the module\n-    dependencies_set = None  # type: Set[str]  # The same but as a set for deduplication purposes\n-    suppressed = None  # type: List[str]  # Suppressed/missing dependencies\n-    suppressed_set = None  # type: Set[str]  # Suppressed/missing dependencies\n-    priorities = None  # type: Dict[str, int]\n+    dependencies: List[str]  # Modules directly imported by the module\n+    dependencies_set: Set[str]  # The same but as a set for deduplication purposes\n+    suppressed: List[str]  # Suppressed/missing dependencies\n+    suppressed_set: Set[str]  # Suppressed/missing dependencies\n+    priorities: Dict[str, int]\n \n     # Map each dependency to the line number where it is first imported\n-    dep_line_map = None  # type: Dict[str, int]\n+    dep_line_map: Dict[str, int]\n \n     # Parent package, its parent, etc.\n-    ancestors = None  # type: Optional[List[str]]\n+    ancestors: Optional[List[str]] = None\n \n     # List of (path, line number) tuples giving context for import\n-    import_context = None  # type: List[Tuple[str, int]]\n+    import_context: List[Tuple[str, int]]\n \n     # The State from which this module was imported, if any\n-    caller_state = None  # type: Optional[State]\n+    caller_state: Optional[\"State\"] = None\n \n",
        "source_code_with_indent": "    # They should be managed with add_dependency and suppress_dependency.\n    dependencies = None  # type: List[str]  # Modules directly imported by the module\n    dependencies_set = None  # type: Set[str]  # The same but as a set for deduplication purposes\n    suppressed = None  # type: List[str]  # Suppressed/missing dependencies\n    suppressed_set = None  # type: Set[str]  # Suppressed/missing dependencies\n    priorities = None  # type: Dict[str, int]\n\n    # Map each dependency to the line number where it is first imported\n    dep_line_map = None  # type: Dict[str, int]\n\n    # Parent package, its parent, etc.\n    ancestors = None  # type: Optional[List[str]]\n\n    # List of (path, line number) tuples giving context for import\n    import_context = None  # type: List[Tuple[str, int]]\n\n    # The State from which this module was imported, if any\n    caller_state = None  # type: Optional[State]\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    # They should be managed with add_dependency and suppress_dependency.\n    dependencies: List[str]  # Modules directly imported by the module\n    dependencies_set: Set[str]  # The same but as a set for deduplication purposes\n    suppressed: List[str]  # Suppressed/missing dependencies\n    suppressed_set: Set[str]  # Suppressed/missing dependencies\n    priorities: Dict[str, int]\n\n    # Map each dependency to the line number where it is first imported\n    dep_line_map: Dict[str, int]\n\n    # Parent package, its parent, etc.\n    ancestors: Optional[List[str]] = None\n\n    # List of (path, line number) tuples giving context for import\n    import_context: List[Tuple[str, int]]\n\n    # The State from which this module was imported, if any\n    caller_state: Optional[\"State\"] = None\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "python/mypy",
    "commit": "f98f78216ba9d6ab68c8e69c19e9f3c7926c5efe",
    "filename": "mypy/build.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/python-mypy/mypy/build.py",
    "file_hunks_size": 39,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "mypy/build.py:1745:4 Incompatible attribute type [8]: Attribute `dependencies_set` declared in class `State` has type `Set[str]` but is used as type `None`.",
    "message": " Attribute `dependencies_set` declared in class `State` has type `Set[str]` but is used as type `None`.",
    "rule_id": "Incompatible attribute type [8]",
    "warning_line_no": 1745,
    "warning_line": "    dependencies_set = None  # type: Set[str]  # The same but as a set for deduplication purposes",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    # They should be managed with add_dependency and suppress_dependency.\n    dependencies = None  # type: List[str]  # Modules directly imported by the module\n    dependencies_set = None  # type: Set[str]  # The same but as a set for deduplication purposes\n    suppressed = None  # type: List[str]  # Suppressed/missing dependencies\n    suppressed_set = None  # type: Set[str]  # Suppressed/missing dependencies\n    priorities = None  # type: Dict[str, int]\n\n    # Map each dependency to the line number where it is first imported\n    dep_line_map = None  # type: Dict[str, int]\n\n    # Parent package, its parent, etc.\n    ancestors = None  # type: Optional[List[str]]\n\n    # List of (path, line number) tuples giving context for import\n    import_context = None  # type: List[Tuple[str, int]]\n\n    # The State from which this module was imported, if any\n    caller_state = None  # type: Optional[State]\n\n",
        "source_code_len": 906,
        "target_code": "    # They should be managed with add_dependency and suppress_dependency.\n    dependencies: List[str]  # Modules directly imported by the module\n    dependencies_set: Set[str]  # The same but as a set for deduplication purposes\n    suppressed: List[str]  # Suppressed/missing dependencies\n    suppressed_set: Set[str]  # Suppressed/missing dependencies\n    priorities: Dict[str, int]\n\n    # Map each dependency to the line number where it is first imported\n    dep_line_map: Dict[str, int]\n\n    # Parent package, its parent, etc.\n    ancestors: Optional[List[str]] = None\n\n    # List of (path, line number) tuples giving context for import\n    import_context: List[Tuple[str, int]]\n\n    # The State from which this module was imported, if any\n    caller_state: Optional[\"State\"] = None\n\n",
        "target_code_len": 787,
        "diff_format": "@@ -1743,19 +1744,19 @@\n     # They should be managed with add_dependency and suppress_dependency.\n-    dependencies = None  # type: List[str]  # Modules directly imported by the module\n-    dependencies_set = None  # type: Set[str]  # The same but as a set for deduplication purposes\n-    suppressed = None  # type: List[str]  # Suppressed/missing dependencies\n-    suppressed_set = None  # type: Set[str]  # Suppressed/missing dependencies\n-    priorities = None  # type: Dict[str, int]\n+    dependencies: List[str]  # Modules directly imported by the module\n+    dependencies_set: Set[str]  # The same but as a set for deduplication purposes\n+    suppressed: List[str]  # Suppressed/missing dependencies\n+    suppressed_set: Set[str]  # Suppressed/missing dependencies\n+    priorities: Dict[str, int]\n \n     # Map each dependency to the line number where it is first imported\n-    dep_line_map = None  # type: Dict[str, int]\n+    dep_line_map: Dict[str, int]\n \n     # Parent package, its parent, etc.\n-    ancestors = None  # type: Optional[List[str]]\n+    ancestors: Optional[List[str]] = None\n \n     # List of (path, line number) tuples giving context for import\n-    import_context = None  # type: List[Tuple[str, int]]\n+    import_context: List[Tuple[str, int]]\n \n     # The State from which this module was imported, if any\n-    caller_state = None  # type: Optional[State]\n+    caller_state: Optional[\"State\"] = None\n \n",
        "source_code_with_indent": "    # They should be managed with add_dependency and suppress_dependency.\n    dependencies = None  # type: List[str]  # Modules directly imported by the module\n    dependencies_set = None  # type: Set[str]  # The same but as a set for deduplication purposes\n    suppressed = None  # type: List[str]  # Suppressed/missing dependencies\n    suppressed_set = None  # type: Set[str]  # Suppressed/missing dependencies\n    priorities = None  # type: Dict[str, int]\n\n    # Map each dependency to the line number where it is first imported\n    dep_line_map = None  # type: Dict[str, int]\n\n    # Parent package, its parent, etc.\n    ancestors = None  # type: Optional[List[str]]\n\n    # List of (path, line number) tuples giving context for import\n    import_context = None  # type: List[Tuple[str, int]]\n\n    # The State from which this module was imported, if any\n    caller_state = None  # type: Optional[State]\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    # They should be managed with add_dependency and suppress_dependency.\n    dependencies: List[str]  # Modules directly imported by the module\n    dependencies_set: Set[str]  # The same but as a set for deduplication purposes\n    suppressed: List[str]  # Suppressed/missing dependencies\n    suppressed_set: Set[str]  # Suppressed/missing dependencies\n    priorities: Dict[str, int]\n\n    # Map each dependency to the line number where it is first imported\n    dep_line_map: Dict[str, int]\n\n    # Parent package, its parent, etc.\n    ancestors: Optional[List[str]] = None\n\n    # List of (path, line number) tuples giving context for import\n    import_context: List[Tuple[str, int]]\n\n    # The State from which this module was imported, if any\n    caller_state: Optional[\"State\"] = None\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "python/mypy",
    "commit": "f98f78216ba9d6ab68c8e69c19e9f3c7926c5efe",
    "filename": "mypy/build.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/python-mypy/mypy/build.py",
    "file_hunks_size": 39,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "mypy/build.py:1746:4 Incompatible attribute type [8]: Attribute `suppressed` declared in class `State` has type `List[str]` but is used as type `None`.",
    "message": " Attribute `suppressed` declared in class `State` has type `List[str]` but is used as type `None`.",
    "rule_id": "Incompatible attribute type [8]",
    "warning_line_no": 1746,
    "warning_line": "    suppressed = None  # type: List[str]  # Suppressed/missing dependencies",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    # They should be managed with add_dependency and suppress_dependency.\n    dependencies = None  # type: List[str]  # Modules directly imported by the module\n    dependencies_set = None  # type: Set[str]  # The same but as a set for deduplication purposes\n    suppressed = None  # type: List[str]  # Suppressed/missing dependencies\n    suppressed_set = None  # type: Set[str]  # Suppressed/missing dependencies\n    priorities = None  # type: Dict[str, int]\n\n    # Map each dependency to the line number where it is first imported\n    dep_line_map = None  # type: Dict[str, int]\n\n    # Parent package, its parent, etc.\n    ancestors = None  # type: Optional[List[str]]\n\n    # List of (path, line number) tuples giving context for import\n    import_context = None  # type: List[Tuple[str, int]]\n\n    # The State from which this module was imported, if any\n    caller_state = None  # type: Optional[State]\n\n",
        "source_code_len": 906,
        "target_code": "    # They should be managed with add_dependency and suppress_dependency.\n    dependencies: List[str]  # Modules directly imported by the module\n    dependencies_set: Set[str]  # The same but as a set for deduplication purposes\n    suppressed: List[str]  # Suppressed/missing dependencies\n    suppressed_set: Set[str]  # Suppressed/missing dependencies\n    priorities: Dict[str, int]\n\n    # Map each dependency to the line number where it is first imported\n    dep_line_map: Dict[str, int]\n\n    # Parent package, its parent, etc.\n    ancestors: Optional[List[str]] = None\n\n    # List of (path, line number) tuples giving context for import\n    import_context: List[Tuple[str, int]]\n\n    # The State from which this module was imported, if any\n    caller_state: Optional[\"State\"] = None\n\n",
        "target_code_len": 787,
        "diff_format": "@@ -1743,19 +1744,19 @@\n     # They should be managed with add_dependency and suppress_dependency.\n-    dependencies = None  # type: List[str]  # Modules directly imported by the module\n-    dependencies_set = None  # type: Set[str]  # The same but as a set for deduplication purposes\n-    suppressed = None  # type: List[str]  # Suppressed/missing dependencies\n-    suppressed_set = None  # type: Set[str]  # Suppressed/missing dependencies\n-    priorities = None  # type: Dict[str, int]\n+    dependencies: List[str]  # Modules directly imported by the module\n+    dependencies_set: Set[str]  # The same but as a set for deduplication purposes\n+    suppressed: List[str]  # Suppressed/missing dependencies\n+    suppressed_set: Set[str]  # Suppressed/missing dependencies\n+    priorities: Dict[str, int]\n \n     # Map each dependency to the line number where it is first imported\n-    dep_line_map = None  # type: Dict[str, int]\n+    dep_line_map: Dict[str, int]\n \n     # Parent package, its parent, etc.\n-    ancestors = None  # type: Optional[List[str]]\n+    ancestors: Optional[List[str]] = None\n \n     # List of (path, line number) tuples giving context for import\n-    import_context = None  # type: List[Tuple[str, int]]\n+    import_context: List[Tuple[str, int]]\n \n     # The State from which this module was imported, if any\n-    caller_state = None  # type: Optional[State]\n+    caller_state: Optional[\"State\"] = None\n \n",
        "source_code_with_indent": "    # They should be managed with add_dependency and suppress_dependency.\n    dependencies = None  # type: List[str]  # Modules directly imported by the module\n    dependencies_set = None  # type: Set[str]  # The same but as a set for deduplication purposes\n    suppressed = None  # type: List[str]  # Suppressed/missing dependencies\n    suppressed_set = None  # type: Set[str]  # Suppressed/missing dependencies\n    priorities = None  # type: Dict[str, int]\n\n    # Map each dependency to the line number where it is first imported\n    dep_line_map = None  # type: Dict[str, int]\n\n    # Parent package, its parent, etc.\n    ancestors = None  # type: Optional[List[str]]\n\n    # List of (path, line number) tuples giving context for import\n    import_context = None  # type: List[Tuple[str, int]]\n\n    # The State from which this module was imported, if any\n    caller_state = None  # type: Optional[State]\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    # They should be managed with add_dependency and suppress_dependency.\n    dependencies: List[str]  # Modules directly imported by the module\n    dependencies_set: Set[str]  # The same but as a set for deduplication purposes\n    suppressed: List[str]  # Suppressed/missing dependencies\n    suppressed_set: Set[str]  # Suppressed/missing dependencies\n    priorities: Dict[str, int]\n\n    # Map each dependency to the line number where it is first imported\n    dep_line_map: Dict[str, int]\n\n    # Parent package, its parent, etc.\n    ancestors: Optional[List[str]] = None\n\n    # List of (path, line number) tuples giving context for import\n    import_context: List[Tuple[str, int]]\n\n    # The State from which this module was imported, if any\n    caller_state: Optional[\"State\"] = None\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "python/mypy",
    "commit": "f98f78216ba9d6ab68c8e69c19e9f3c7926c5efe",
    "filename": "mypy/build.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/python-mypy/mypy/build.py",
    "file_hunks_size": 39,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "mypy/build.py:1747:4 Incompatible attribute type [8]: Attribute `suppressed_set` declared in class `State` has type `Set[str]` but is used as type `None`.",
    "message": " Attribute `suppressed_set` declared in class `State` has type `Set[str]` but is used as type `None`.",
    "rule_id": "Incompatible attribute type [8]",
    "warning_line_no": 1747,
    "warning_line": "    suppressed_set = None  # type: Set[str]  # Suppressed/missing dependencies",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    # They should be managed with add_dependency and suppress_dependency.\n    dependencies = None  # type: List[str]  # Modules directly imported by the module\n    dependencies_set = None  # type: Set[str]  # The same but as a set for deduplication purposes\n    suppressed = None  # type: List[str]  # Suppressed/missing dependencies\n    suppressed_set = None  # type: Set[str]  # Suppressed/missing dependencies\n    priorities = None  # type: Dict[str, int]\n\n    # Map each dependency to the line number where it is first imported\n    dep_line_map = None  # type: Dict[str, int]\n\n    # Parent package, its parent, etc.\n    ancestors = None  # type: Optional[List[str]]\n\n    # List of (path, line number) tuples giving context for import\n    import_context = None  # type: List[Tuple[str, int]]\n\n    # The State from which this module was imported, if any\n    caller_state = None  # type: Optional[State]\n\n",
        "source_code_len": 906,
        "target_code": "    # They should be managed with add_dependency and suppress_dependency.\n    dependencies: List[str]  # Modules directly imported by the module\n    dependencies_set: Set[str]  # The same but as a set for deduplication purposes\n    suppressed: List[str]  # Suppressed/missing dependencies\n    suppressed_set: Set[str]  # Suppressed/missing dependencies\n    priorities: Dict[str, int]\n\n    # Map each dependency to the line number where it is first imported\n    dep_line_map: Dict[str, int]\n\n    # Parent package, its parent, etc.\n    ancestors: Optional[List[str]] = None\n\n    # List of (path, line number) tuples giving context for import\n    import_context: List[Tuple[str, int]]\n\n    # The State from which this module was imported, if any\n    caller_state: Optional[\"State\"] = None\n\n",
        "target_code_len": 787,
        "diff_format": "@@ -1743,19 +1744,19 @@\n     # They should be managed with add_dependency and suppress_dependency.\n-    dependencies = None  # type: List[str]  # Modules directly imported by the module\n-    dependencies_set = None  # type: Set[str]  # The same but as a set for deduplication purposes\n-    suppressed = None  # type: List[str]  # Suppressed/missing dependencies\n-    suppressed_set = None  # type: Set[str]  # Suppressed/missing dependencies\n-    priorities = None  # type: Dict[str, int]\n+    dependencies: List[str]  # Modules directly imported by the module\n+    dependencies_set: Set[str]  # The same but as a set for deduplication purposes\n+    suppressed: List[str]  # Suppressed/missing dependencies\n+    suppressed_set: Set[str]  # Suppressed/missing dependencies\n+    priorities: Dict[str, int]\n \n     # Map each dependency to the line number where it is first imported\n-    dep_line_map = None  # type: Dict[str, int]\n+    dep_line_map: Dict[str, int]\n \n     # Parent package, its parent, etc.\n-    ancestors = None  # type: Optional[List[str]]\n+    ancestors: Optional[List[str]] = None\n \n     # List of (path, line number) tuples giving context for import\n-    import_context = None  # type: List[Tuple[str, int]]\n+    import_context: List[Tuple[str, int]]\n \n     # The State from which this module was imported, if any\n-    caller_state = None  # type: Optional[State]\n+    caller_state: Optional[\"State\"] = None\n \n",
        "source_code_with_indent": "    # They should be managed with add_dependency and suppress_dependency.\n    dependencies = None  # type: List[str]  # Modules directly imported by the module\n    dependencies_set = None  # type: Set[str]  # The same but as a set for deduplication purposes\n    suppressed = None  # type: List[str]  # Suppressed/missing dependencies\n    suppressed_set = None  # type: Set[str]  # Suppressed/missing dependencies\n    priorities = None  # type: Dict[str, int]\n\n    # Map each dependency to the line number where it is first imported\n    dep_line_map = None  # type: Dict[str, int]\n\n    # Parent package, its parent, etc.\n    ancestors = None  # type: Optional[List[str]]\n\n    # List of (path, line number) tuples giving context for import\n    import_context = None  # type: List[Tuple[str, int]]\n\n    # The State from which this module was imported, if any\n    caller_state = None  # type: Optional[State]\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    # They should be managed with add_dependency and suppress_dependency.\n    dependencies: List[str]  # Modules directly imported by the module\n    dependencies_set: Set[str]  # The same but as a set for deduplication purposes\n    suppressed: List[str]  # Suppressed/missing dependencies\n    suppressed_set: Set[str]  # Suppressed/missing dependencies\n    priorities: Dict[str, int]\n\n    # Map each dependency to the line number where it is first imported\n    dep_line_map: Dict[str, int]\n\n    # Parent package, its parent, etc.\n    ancestors: Optional[List[str]] = None\n\n    # List of (path, line number) tuples giving context for import\n    import_context: List[Tuple[str, int]]\n\n    # The State from which this module was imported, if any\n    caller_state: Optional[\"State\"] = None\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "python/mypy",
    "commit": "f98f78216ba9d6ab68c8e69c19e9f3c7926c5efe",
    "filename": "mypy/build.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/python-mypy/mypy/build.py",
    "file_hunks_size": 39,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "mypy/build.py:1748:4 Incompatible attribute type [8]: Attribute `priorities` declared in class `State` has type `Dict[str, int]` but is used as type `None`.",
    "message": " Attribute `priorities` declared in class `State` has type `Dict[str, int]` but is used as type `None`.",
    "rule_id": "Incompatible attribute type [8]",
    "warning_line_no": 1748,
    "warning_line": "    priorities = None  # type: Dict[str, int]",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    # They should be managed with add_dependency and suppress_dependency.\n    dependencies = None  # type: List[str]  # Modules directly imported by the module\n    dependencies_set = None  # type: Set[str]  # The same but as a set for deduplication purposes\n    suppressed = None  # type: List[str]  # Suppressed/missing dependencies\n    suppressed_set = None  # type: Set[str]  # Suppressed/missing dependencies\n    priorities = None  # type: Dict[str, int]\n\n    # Map each dependency to the line number where it is first imported\n    dep_line_map = None  # type: Dict[str, int]\n\n    # Parent package, its parent, etc.\n    ancestors = None  # type: Optional[List[str]]\n\n    # List of (path, line number) tuples giving context for import\n    import_context = None  # type: List[Tuple[str, int]]\n\n    # The State from which this module was imported, if any\n    caller_state = None  # type: Optional[State]\n\n",
        "source_code_len": 906,
        "target_code": "    # They should be managed with add_dependency and suppress_dependency.\n    dependencies: List[str]  # Modules directly imported by the module\n    dependencies_set: Set[str]  # The same but as a set for deduplication purposes\n    suppressed: List[str]  # Suppressed/missing dependencies\n    suppressed_set: Set[str]  # Suppressed/missing dependencies\n    priorities: Dict[str, int]\n\n    # Map each dependency to the line number where it is first imported\n    dep_line_map: Dict[str, int]\n\n    # Parent package, its parent, etc.\n    ancestors: Optional[List[str]] = None\n\n    # List of (path, line number) tuples giving context for import\n    import_context: List[Tuple[str, int]]\n\n    # The State from which this module was imported, if any\n    caller_state: Optional[\"State\"] = None\n\n",
        "target_code_len": 787,
        "diff_format": "@@ -1743,19 +1744,19 @@\n     # They should be managed with add_dependency and suppress_dependency.\n-    dependencies = None  # type: List[str]  # Modules directly imported by the module\n-    dependencies_set = None  # type: Set[str]  # The same but as a set for deduplication purposes\n-    suppressed = None  # type: List[str]  # Suppressed/missing dependencies\n-    suppressed_set = None  # type: Set[str]  # Suppressed/missing dependencies\n-    priorities = None  # type: Dict[str, int]\n+    dependencies: List[str]  # Modules directly imported by the module\n+    dependencies_set: Set[str]  # The same but as a set for deduplication purposes\n+    suppressed: List[str]  # Suppressed/missing dependencies\n+    suppressed_set: Set[str]  # Suppressed/missing dependencies\n+    priorities: Dict[str, int]\n \n     # Map each dependency to the line number where it is first imported\n-    dep_line_map = None  # type: Dict[str, int]\n+    dep_line_map: Dict[str, int]\n \n     # Parent package, its parent, etc.\n-    ancestors = None  # type: Optional[List[str]]\n+    ancestors: Optional[List[str]] = None\n \n     # List of (path, line number) tuples giving context for import\n-    import_context = None  # type: List[Tuple[str, int]]\n+    import_context: List[Tuple[str, int]]\n \n     # The State from which this module was imported, if any\n-    caller_state = None  # type: Optional[State]\n+    caller_state: Optional[\"State\"] = None\n \n",
        "source_code_with_indent": "    # They should be managed with add_dependency and suppress_dependency.\n    dependencies = None  # type: List[str]  # Modules directly imported by the module\n    dependencies_set = None  # type: Set[str]  # The same but as a set for deduplication purposes\n    suppressed = None  # type: List[str]  # Suppressed/missing dependencies\n    suppressed_set = None  # type: Set[str]  # Suppressed/missing dependencies\n    priorities = None  # type: Dict[str, int]\n\n    # Map each dependency to the line number where it is first imported\n    dep_line_map = None  # type: Dict[str, int]\n\n    # Parent package, its parent, etc.\n    ancestors = None  # type: Optional[List[str]]\n\n    # List of (path, line number) tuples giving context for import\n    import_context = None  # type: List[Tuple[str, int]]\n\n    # The State from which this module was imported, if any\n    caller_state = None  # type: Optional[State]\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    # They should be managed with add_dependency and suppress_dependency.\n    dependencies: List[str]  # Modules directly imported by the module\n    dependencies_set: Set[str]  # The same but as a set for deduplication purposes\n    suppressed: List[str]  # Suppressed/missing dependencies\n    suppressed_set: Set[str]  # Suppressed/missing dependencies\n    priorities: Dict[str, int]\n\n    # Map each dependency to the line number where it is first imported\n    dep_line_map: Dict[str, int]\n\n    # Parent package, its parent, etc.\n    ancestors: Optional[List[str]] = None\n\n    # List of (path, line number) tuples giving context for import\n    import_context: List[Tuple[str, int]]\n\n    # The State from which this module was imported, if any\n    caller_state: Optional[\"State\"] = None\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "python/mypy",
    "commit": "f98f78216ba9d6ab68c8e69c19e9f3c7926c5efe",
    "filename": "mypy/build.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/python-mypy/mypy/build.py",
    "file_hunks_size": 39,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "mypy/build.py:1751:4 Incompatible attribute type [8]: Attribute `dep_line_map` declared in class `State` has type `Dict[str, int]` but is used as type `None`.",
    "message": " Attribute `dep_line_map` declared in class `State` has type `Dict[str, int]` but is used as type `None`.",
    "rule_id": "Incompatible attribute type [8]",
    "warning_line_no": 1751,
    "warning_line": "    dep_line_map = None  # type: Dict[str, int]",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    # They should be managed with add_dependency and suppress_dependency.\n    dependencies = None  # type: List[str]  # Modules directly imported by the module\n    dependencies_set = None  # type: Set[str]  # The same but as a set for deduplication purposes\n    suppressed = None  # type: List[str]  # Suppressed/missing dependencies\n    suppressed_set = None  # type: Set[str]  # Suppressed/missing dependencies\n    priorities = None  # type: Dict[str, int]\n\n    # Map each dependency to the line number where it is first imported\n    dep_line_map = None  # type: Dict[str, int]\n\n    # Parent package, its parent, etc.\n    ancestors = None  # type: Optional[List[str]]\n\n    # List of (path, line number) tuples giving context for import\n    import_context = None  # type: List[Tuple[str, int]]\n\n    # The State from which this module was imported, if any\n    caller_state = None  # type: Optional[State]\n\n",
        "source_code_len": 906,
        "target_code": "    # They should be managed with add_dependency and suppress_dependency.\n    dependencies: List[str]  # Modules directly imported by the module\n    dependencies_set: Set[str]  # The same but as a set for deduplication purposes\n    suppressed: List[str]  # Suppressed/missing dependencies\n    suppressed_set: Set[str]  # Suppressed/missing dependencies\n    priorities: Dict[str, int]\n\n    # Map each dependency to the line number where it is first imported\n    dep_line_map: Dict[str, int]\n\n    # Parent package, its parent, etc.\n    ancestors: Optional[List[str]] = None\n\n    # List of (path, line number) tuples giving context for import\n    import_context: List[Tuple[str, int]]\n\n    # The State from which this module was imported, if any\n    caller_state: Optional[\"State\"] = None\n\n",
        "target_code_len": 787,
        "diff_format": "@@ -1743,19 +1744,19 @@\n     # They should be managed with add_dependency and suppress_dependency.\n-    dependencies = None  # type: List[str]  # Modules directly imported by the module\n-    dependencies_set = None  # type: Set[str]  # The same but as a set for deduplication purposes\n-    suppressed = None  # type: List[str]  # Suppressed/missing dependencies\n-    suppressed_set = None  # type: Set[str]  # Suppressed/missing dependencies\n-    priorities = None  # type: Dict[str, int]\n+    dependencies: List[str]  # Modules directly imported by the module\n+    dependencies_set: Set[str]  # The same but as a set for deduplication purposes\n+    suppressed: List[str]  # Suppressed/missing dependencies\n+    suppressed_set: Set[str]  # Suppressed/missing dependencies\n+    priorities: Dict[str, int]\n \n     # Map each dependency to the line number where it is first imported\n-    dep_line_map = None  # type: Dict[str, int]\n+    dep_line_map: Dict[str, int]\n \n     # Parent package, its parent, etc.\n-    ancestors = None  # type: Optional[List[str]]\n+    ancestors: Optional[List[str]] = None\n \n     # List of (path, line number) tuples giving context for import\n-    import_context = None  # type: List[Tuple[str, int]]\n+    import_context: List[Tuple[str, int]]\n \n     # The State from which this module was imported, if any\n-    caller_state = None  # type: Optional[State]\n+    caller_state: Optional[\"State\"] = None\n \n",
        "source_code_with_indent": "    # They should be managed with add_dependency and suppress_dependency.\n    dependencies = None  # type: List[str]  # Modules directly imported by the module\n    dependencies_set = None  # type: Set[str]  # The same but as a set for deduplication purposes\n    suppressed = None  # type: List[str]  # Suppressed/missing dependencies\n    suppressed_set = None  # type: Set[str]  # Suppressed/missing dependencies\n    priorities = None  # type: Dict[str, int]\n\n    # Map each dependency to the line number where it is first imported\n    dep_line_map = None  # type: Dict[str, int]\n\n    # Parent package, its parent, etc.\n    ancestors = None  # type: Optional[List[str]]\n\n    # List of (path, line number) tuples giving context for import\n    import_context = None  # type: List[Tuple[str, int]]\n\n    # The State from which this module was imported, if any\n    caller_state = None  # type: Optional[State]\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    # They should be managed with add_dependency and suppress_dependency.\n    dependencies: List[str]  # Modules directly imported by the module\n    dependencies_set: Set[str]  # The same but as a set for deduplication purposes\n    suppressed: List[str]  # Suppressed/missing dependencies\n    suppressed_set: Set[str]  # Suppressed/missing dependencies\n    priorities: Dict[str, int]\n\n    # Map each dependency to the line number where it is first imported\n    dep_line_map: Dict[str, int]\n\n    # Parent package, its parent, etc.\n    ancestors: Optional[List[str]] = None\n\n    # List of (path, line number) tuples giving context for import\n    import_context: List[Tuple[str, int]]\n\n    # The State from which this module was imported, if any\n    caller_state: Optional[\"State\"] = None\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "python/mypy",
    "commit": "f98f78216ba9d6ab68c8e69c19e9f3c7926c5efe",
    "filename": "mypy/build.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/python-mypy/mypy/build.py",
    "file_hunks_size": 39,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "mypy/build.py:1757:4 Incompatible attribute type [8]: Attribute `import_context` declared in class `State` has type `List[Tuple[str, int]]` but is used as type `None`.",
    "message": " Attribute `import_context` declared in class `State` has type `List[Tuple[str, int]]` but is used as type `None`.",
    "rule_id": "Incompatible attribute type [8]",
    "warning_line_no": 1757,
    "warning_line": "    import_context = None  # type: List[Tuple[str, int]]",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    # They should be managed with add_dependency and suppress_dependency.\n    dependencies = None  # type: List[str]  # Modules directly imported by the module\n    dependencies_set = None  # type: Set[str]  # The same but as a set for deduplication purposes\n    suppressed = None  # type: List[str]  # Suppressed/missing dependencies\n    suppressed_set = None  # type: Set[str]  # Suppressed/missing dependencies\n    priorities = None  # type: Dict[str, int]\n\n    # Map each dependency to the line number where it is first imported\n    dep_line_map = None  # type: Dict[str, int]\n\n    # Parent package, its parent, etc.\n    ancestors = None  # type: Optional[List[str]]\n\n    # List of (path, line number) tuples giving context for import\n    import_context = None  # type: List[Tuple[str, int]]\n\n    # The State from which this module was imported, if any\n    caller_state = None  # type: Optional[State]\n\n",
        "source_code_len": 906,
        "target_code": "    # They should be managed with add_dependency and suppress_dependency.\n    dependencies: List[str]  # Modules directly imported by the module\n    dependencies_set: Set[str]  # The same but as a set for deduplication purposes\n    suppressed: List[str]  # Suppressed/missing dependencies\n    suppressed_set: Set[str]  # Suppressed/missing dependencies\n    priorities: Dict[str, int]\n\n    # Map each dependency to the line number where it is first imported\n    dep_line_map: Dict[str, int]\n\n    # Parent package, its parent, etc.\n    ancestors: Optional[List[str]] = None\n\n    # List of (path, line number) tuples giving context for import\n    import_context: List[Tuple[str, int]]\n\n    # The State from which this module was imported, if any\n    caller_state: Optional[\"State\"] = None\n\n",
        "target_code_len": 787,
        "diff_format": "@@ -1743,19 +1744,19 @@\n     # They should be managed with add_dependency and suppress_dependency.\n-    dependencies = None  # type: List[str]  # Modules directly imported by the module\n-    dependencies_set = None  # type: Set[str]  # The same but as a set for deduplication purposes\n-    suppressed = None  # type: List[str]  # Suppressed/missing dependencies\n-    suppressed_set = None  # type: Set[str]  # Suppressed/missing dependencies\n-    priorities = None  # type: Dict[str, int]\n+    dependencies: List[str]  # Modules directly imported by the module\n+    dependencies_set: Set[str]  # The same but as a set for deduplication purposes\n+    suppressed: List[str]  # Suppressed/missing dependencies\n+    suppressed_set: Set[str]  # Suppressed/missing dependencies\n+    priorities: Dict[str, int]\n \n     # Map each dependency to the line number where it is first imported\n-    dep_line_map = None  # type: Dict[str, int]\n+    dep_line_map: Dict[str, int]\n \n     # Parent package, its parent, etc.\n-    ancestors = None  # type: Optional[List[str]]\n+    ancestors: Optional[List[str]] = None\n \n     # List of (path, line number) tuples giving context for import\n-    import_context = None  # type: List[Tuple[str, int]]\n+    import_context: List[Tuple[str, int]]\n \n     # The State from which this module was imported, if any\n-    caller_state = None  # type: Optional[State]\n+    caller_state: Optional[\"State\"] = None\n \n",
        "source_code_with_indent": "    # They should be managed with add_dependency and suppress_dependency.\n    dependencies = None  # type: List[str]  # Modules directly imported by the module\n    dependencies_set = None  # type: Set[str]  # The same but as a set for deduplication purposes\n    suppressed = None  # type: List[str]  # Suppressed/missing dependencies\n    suppressed_set = None  # type: Set[str]  # Suppressed/missing dependencies\n    priorities = None  # type: Dict[str, int]\n\n    # Map each dependency to the line number where it is first imported\n    dep_line_map = None  # type: Dict[str, int]\n\n    # Parent package, its parent, etc.\n    ancestors = None  # type: Optional[List[str]]\n\n    # List of (path, line number) tuples giving context for import\n    import_context = None  # type: List[Tuple[str, int]]\n\n    # The State from which this module was imported, if any\n    caller_state = None  # type: Optional[State]\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    # They should be managed with add_dependency and suppress_dependency.\n    dependencies: List[str]  # Modules directly imported by the module\n    dependencies_set: Set[str]  # The same but as a set for deduplication purposes\n    suppressed: List[str]  # Suppressed/missing dependencies\n    suppressed_set: Set[str]  # Suppressed/missing dependencies\n    priorities: Dict[str, int]\n\n    # Map each dependency to the line number where it is first imported\n    dep_line_map: Dict[str, int]\n\n    # Parent package, its parent, etc.\n    ancestors: Optional[List[str]] = None\n\n    # List of (path, line number) tuples giving context for import\n    import_context: List[Tuple[str, int]]\n\n    # The State from which this module was imported, if any\n    caller_state: Optional[\"State\"] = None\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "python/mypy",
    "commit": "f98f78216ba9d6ab68c8e69c19e9f3c7926c5efe",
    "filename": "mypy/build.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/python-mypy/mypy/build.py",
    "file_hunks_size": 39,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": true,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "mypy/build.py:1772:4 Incompatible attribute type [8]: Attribute `options` declared in class `State` has type `Options` but is used as type `None`.",
    "message": " Attribute `options` declared in class `State` has type `Options` but is used as type `None`.",
    "rule_id": "Incompatible attribute type [8]",
    "warning_line_no": 1772,
    "warning_line": "    options = None  # type: Options",
    "min_patch": [
      {
        "hunk_fit_TFix": true,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    # Contains a hash of the public interface in incremental mode\n    interface_hash = \"\"  # type: str\n\n    # Options, specialized for this file\n    options = None  # type: Options\n\n",
        "source_code_len": 182,
        "target_code": "    # Contains a hash of the public interface in incremental mode\n    interface_hash: str = \"\"\n\n    # Options, specialized for this file\n    options: Options\n\n",
        "target_code_len": 159,
        "diff_format": "@@ -1768,6 +1769,6 @@\n     # Contains a hash of the public interface in incremental mode\n-    interface_hash = \"\"  # type: str\n+    interface_hash: str = \"\"\n \n     # Options, specialized for this file\n-    options = None  # type: Options\n+    options: Options\n \n",
        "source_code_with_indent": "    # Contains a hash of the public interface in incremental mode\n    interface_hash = \"\"  # type: str\n\n    # Options, specialized for this file\n    options = None  # type: Options\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    # Contains a hash of the public interface in incremental mode\n    interface_hash: str = \"\"\n\n    # Options, specialized for this file\n    options: Options\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "python/mypy",
    "commit": "f98f78216ba9d6ab68c8e69c19e9f3c7926c5efe",
    "filename": "mypy/build.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/python-mypy/mypy/build.py",
    "file_hunks_size": 39,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": true,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "mypy/build.py:1782:4 Incompatible attribute type [8]: Attribute `early_errors` declared in class `State` has type `List[ErrorInfo]` but is used as type `None`.",
    "message": " Attribute `early_errors` declared in class `State` has type `List[ErrorInfo]` but is used as type `None`.",
    "rule_id": "Incompatible attribute type [8]",
    "warning_line_no": 1782,
    "warning_line": "    early_errors = None  # type: List[ErrorInfo]",
    "min_patch": [
      {
        "hunk_fit_TFix": true,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    # mode to keep reporting them.\n    early_errors = None  # type: List[ErrorInfo]\n\n",
        "source_code_len": 85,
        "target_code": "    # mode to keep reporting them.\n    early_errors: List[ErrorInfo]\n\n",
        "target_code_len": 70,
        "diff_format": "@@ -1781,3 +1782,3 @@\n     # mode to keep reporting them.\n-    early_errors = None  # type: List[ErrorInfo]\n+    early_errors: List[ErrorInfo]\n \n",
        "source_code_with_indent": "    # mode to keep reporting them.\n    early_errors = None  # type: List[ErrorInfo]\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    # mode to keep reporting them.\n    early_errors: List[ErrorInfo]\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "python/mypy",
    "commit": "f98f78216ba9d6ab68c8e69c19e9f3c7926c5efe",
    "filename": "mypy/checker.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/python-mypy/mypy/checker.py",
    "file_hunks_size": 47,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "mypy/checker.py:157:4 Incompatible attribute type [8]: Attribute `errors` declared in class `TypeChecker` has type `Errors` but is used as type `None`.",
    "message": " Attribute `errors` declared in class `TypeChecker` has type `Errors` but is used as type `None`.",
    "rule_id": "Incompatible attribute type [8]",
    "warning_line_no": 157,
    "warning_line": "    errors = None  # type: Errors",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    # Error message reporter\n    errors = None  # type: Errors\n    # Utility for generating messages\n    msg = None  # type: MessageBuilder\n    # Types of type checked nodes\n    type_map = None  # type: Dict[Expression, Type]\n\n    # Helper for managing conditional types\n    binder = None  # type: ConditionalTypeBinder\n    # Helper for type checking expressions\n    expr_checker = None  # type: mypy.checkexpr.ExpressionChecker\n\n    tscope = None  # type: Scope\n    scope = None  # type: CheckerScope\n    # Stack of function return types\n    return_types = None  # type: List[Type]\n    # Flags; true for dynamically typed functions\n    dynamic_funcs = None  # type: List[bool]\n    # Stack of collections of variables with partial types\n    partial_types = None  # type: List[PartialTypeScope]\n    # Vars for which partial type errors are already reported\n    # (to avoid logically duplicate errors with different error context).\n    partial_reported = None  # type: Set[Var]\n    globals = None  # type: SymbolTable\n    modules = None  # type: Dict[str, MypyFile]\n    # Nodes that couldn't be checked because some types weren't available. We'll run\n    # another pass and try these again.\n    deferred_nodes = None  # type: List[DeferredNode]\n    # Type checking pass number (0 = first pass)\n",
        "source_code_len": 1292,
        "target_code": "    # Error message reporter\n    errors: Errors\n    # Utility for generating messages\n    msg: MessageBuilder\n    # Types of type checked nodes\n    type_map: Dict[Expression, Type]\n\n    # Helper for managing conditional types\n    binder: ConditionalTypeBinder\n    # Helper for type checking expressions\n    expr_checker: mypy.checkexpr.ExpressionChecker\n\n    tscope: Scope\n    scope: \"CheckerScope\"\n    # Stack of function return types\n    return_types: List[Type]\n    # Flags; true for dynamically typed functions\n    dynamic_funcs: List[bool]\n    # Stack of collections of variables with partial types\n    partial_types: List[PartialTypeScope]\n    # Vars for which partial type errors are already reported\n    # (to avoid logically duplicate errors with different error context).\n    partial_reported: Set[Var]\n    globals: SymbolTable\n    modules: Dict[str, MypyFile]\n    # Nodes that couldn't be checked because some types weren't available. We'll run\n    # another pass and try these again.\n    deferred_nodes: List[DeferredNode]\n    # Type checking pass number (0 = first pass)\n",
        "target_code_len": 1084,
        "diff_format": "@@ -156,29 +156,29 @@\n     # Error message reporter\n-    errors = None  # type: Errors\n+    errors: Errors\n     # Utility for generating messages\n-    msg = None  # type: MessageBuilder\n+    msg: MessageBuilder\n     # Types of type checked nodes\n-    type_map = None  # type: Dict[Expression, Type]\n+    type_map: Dict[Expression, Type]\n \n     # Helper for managing conditional types\n-    binder = None  # type: ConditionalTypeBinder\n+    binder: ConditionalTypeBinder\n     # Helper for type checking expressions\n-    expr_checker = None  # type: mypy.checkexpr.ExpressionChecker\n-\n-    tscope = None  # type: Scope\n-    scope = None  # type: CheckerScope\n+    expr_checker: mypy.checkexpr.ExpressionChecker\n+\n+    tscope: Scope\n+    scope: \"CheckerScope\"\n     # Stack of function return types\n-    return_types = None  # type: List[Type]\n+    return_types: List[Type]\n     # Flags; true for dynamically typed functions\n-    dynamic_funcs = None  # type: List[bool]\n+    dynamic_funcs: List[bool]\n     # Stack of collections of variables with partial types\n-    partial_types = None  # type: List[PartialTypeScope]\n+    partial_types: List[PartialTypeScope]\n     # Vars for which partial type errors are already reported\n     # (to avoid logically duplicate errors with different error context).\n-    partial_reported = None  # type: Set[Var]\n-    globals = None  # type: SymbolTable\n-    modules = None  # type: Dict[str, MypyFile]\n+    partial_reported: Set[Var]\n+    globals: SymbolTable\n+    modules: Dict[str, MypyFile]\n     # Nodes that couldn't be checked because some types weren't available. We'll run\n     # another pass and try these again.\n-    deferred_nodes = None  # type: List[DeferredNode]\n+    deferred_nodes: List[DeferredNode]\n     # Type checking pass number (0 = first pass)\n",
        "source_code_with_indent": "    # Error message reporter\n    errors = None  # type: Errors\n    # Utility for generating messages\n    msg = None  # type: MessageBuilder\n    # Types of type checked nodes\n    type_map = None  # type: Dict[Expression, Type]\n\n    # Helper for managing conditional types\n    binder = None  # type: ConditionalTypeBinder\n    # Helper for type checking expressions\n    expr_checker = None  # type: mypy.checkexpr.ExpressionChecker\n\n    tscope = None  # type: Scope\n    scope = None  # type: CheckerScope\n    # Stack of function return types\n    return_types = None  # type: List[Type]\n    # Flags; true for dynamically typed functions\n    dynamic_funcs = None  # type: List[bool]\n    # Stack of collections of variables with partial types\n    partial_types = None  # type: List[PartialTypeScope]\n    # Vars for which partial type errors are already reported\n    # (to avoid logically duplicate errors with different error context).\n    partial_reported = None  # type: Set[Var]\n    globals = None  # type: SymbolTable\n    modules = None  # type: Dict[str, MypyFile]\n    # Nodes that couldn't be checked because some types weren't available. We'll run\n    # another pass and try these again.\n    deferred_nodes = None  # type: List[DeferredNode]\n    # Type checking pass number (0 = first pass)\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    # Error message reporter\n    errors: Errors\n    # Utility for generating messages\n    msg: MessageBuilder\n    # Types of type checked nodes\n    type_map: Dict[Expression, Type]\n\n    # Helper for managing conditional types\n    binder: ConditionalTypeBinder\n    # Helper for type checking expressions\n    expr_checker: mypy.checkexpr.ExpressionChecker\n\n    tscope: Scope\n    scope: \"CheckerScope\"\n    # Stack of function return types\n    return_types: List[Type]\n    # Flags; true for dynamically typed functions\n    dynamic_funcs: List[bool]\n    # Stack of collections of variables with partial types\n    partial_types: List[PartialTypeScope]\n    # Vars for which partial type errors are already reported\n    # (to avoid logically duplicate errors with different error context).\n    partial_reported: Set[Var]\n    globals: SymbolTable\n    modules: Dict[str, MypyFile]\n    # Nodes that couldn't be checked because some types weren't available. We'll run\n    # another pass and try these again.\n    deferred_nodes: List[DeferredNode]\n    # Type checking pass number (0 = first pass)\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "python/mypy",
    "commit": "f98f78216ba9d6ab68c8e69c19e9f3c7926c5efe",
    "filename": "mypy/checker.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/python-mypy/mypy/checker.py",
    "file_hunks_size": 47,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "mypy/checker.py:159:4 Incompatible attribute type [8]: Attribute `msg` declared in class `TypeChecker` has type `MessageBuilder` but is used as type `None`.",
    "message": " Attribute `msg` declared in class `TypeChecker` has type `MessageBuilder` but is used as type `None`.",
    "rule_id": "Incompatible attribute type [8]",
    "warning_line_no": 159,
    "warning_line": "    msg = None  # type: MessageBuilder",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    # Error message reporter\n    errors = None  # type: Errors\n    # Utility for generating messages\n    msg = None  # type: MessageBuilder\n    # Types of type checked nodes\n    type_map = None  # type: Dict[Expression, Type]\n\n    # Helper for managing conditional types\n    binder = None  # type: ConditionalTypeBinder\n    # Helper for type checking expressions\n    expr_checker = None  # type: mypy.checkexpr.ExpressionChecker\n\n    tscope = None  # type: Scope\n    scope = None  # type: CheckerScope\n    # Stack of function return types\n    return_types = None  # type: List[Type]\n    # Flags; true for dynamically typed functions\n    dynamic_funcs = None  # type: List[bool]\n    # Stack of collections of variables with partial types\n    partial_types = None  # type: List[PartialTypeScope]\n    # Vars for which partial type errors are already reported\n    # (to avoid logically duplicate errors with different error context).\n    partial_reported = None  # type: Set[Var]\n    globals = None  # type: SymbolTable\n    modules = None  # type: Dict[str, MypyFile]\n    # Nodes that couldn't be checked because some types weren't available. We'll run\n    # another pass and try these again.\n    deferred_nodes = None  # type: List[DeferredNode]\n    # Type checking pass number (0 = first pass)\n",
        "source_code_len": 1292,
        "target_code": "    # Error message reporter\n    errors: Errors\n    # Utility for generating messages\n    msg: MessageBuilder\n    # Types of type checked nodes\n    type_map: Dict[Expression, Type]\n\n    # Helper for managing conditional types\n    binder: ConditionalTypeBinder\n    # Helper for type checking expressions\n    expr_checker: mypy.checkexpr.ExpressionChecker\n\n    tscope: Scope\n    scope: \"CheckerScope\"\n    # Stack of function return types\n    return_types: List[Type]\n    # Flags; true for dynamically typed functions\n    dynamic_funcs: List[bool]\n    # Stack of collections of variables with partial types\n    partial_types: List[PartialTypeScope]\n    # Vars for which partial type errors are already reported\n    # (to avoid logically duplicate errors with different error context).\n    partial_reported: Set[Var]\n    globals: SymbolTable\n    modules: Dict[str, MypyFile]\n    # Nodes that couldn't be checked because some types weren't available. We'll run\n    # another pass and try these again.\n    deferred_nodes: List[DeferredNode]\n    # Type checking pass number (0 = first pass)\n",
        "target_code_len": 1084,
        "diff_format": "@@ -156,29 +156,29 @@\n     # Error message reporter\n-    errors = None  # type: Errors\n+    errors: Errors\n     # Utility for generating messages\n-    msg = None  # type: MessageBuilder\n+    msg: MessageBuilder\n     # Types of type checked nodes\n-    type_map = None  # type: Dict[Expression, Type]\n+    type_map: Dict[Expression, Type]\n \n     # Helper for managing conditional types\n-    binder = None  # type: ConditionalTypeBinder\n+    binder: ConditionalTypeBinder\n     # Helper for type checking expressions\n-    expr_checker = None  # type: mypy.checkexpr.ExpressionChecker\n-\n-    tscope = None  # type: Scope\n-    scope = None  # type: CheckerScope\n+    expr_checker: mypy.checkexpr.ExpressionChecker\n+\n+    tscope: Scope\n+    scope: \"CheckerScope\"\n     # Stack of function return types\n-    return_types = None  # type: List[Type]\n+    return_types: List[Type]\n     # Flags; true for dynamically typed functions\n-    dynamic_funcs = None  # type: List[bool]\n+    dynamic_funcs: List[bool]\n     # Stack of collections of variables with partial types\n-    partial_types = None  # type: List[PartialTypeScope]\n+    partial_types: List[PartialTypeScope]\n     # Vars for which partial type errors are already reported\n     # (to avoid logically duplicate errors with different error context).\n-    partial_reported = None  # type: Set[Var]\n-    globals = None  # type: SymbolTable\n-    modules = None  # type: Dict[str, MypyFile]\n+    partial_reported: Set[Var]\n+    globals: SymbolTable\n+    modules: Dict[str, MypyFile]\n     # Nodes that couldn't be checked because some types weren't available. We'll run\n     # another pass and try these again.\n-    deferred_nodes = None  # type: List[DeferredNode]\n+    deferred_nodes: List[DeferredNode]\n     # Type checking pass number (0 = first pass)\n",
        "source_code_with_indent": "    # Error message reporter\n    errors = None  # type: Errors\n    # Utility for generating messages\n    msg = None  # type: MessageBuilder\n    # Types of type checked nodes\n    type_map = None  # type: Dict[Expression, Type]\n\n    # Helper for managing conditional types\n    binder = None  # type: ConditionalTypeBinder\n    # Helper for type checking expressions\n    expr_checker = None  # type: mypy.checkexpr.ExpressionChecker\n\n    tscope = None  # type: Scope\n    scope = None  # type: CheckerScope\n    # Stack of function return types\n    return_types = None  # type: List[Type]\n    # Flags; true for dynamically typed functions\n    dynamic_funcs = None  # type: List[bool]\n    # Stack of collections of variables with partial types\n    partial_types = None  # type: List[PartialTypeScope]\n    # Vars for which partial type errors are already reported\n    # (to avoid logically duplicate errors with different error context).\n    partial_reported = None  # type: Set[Var]\n    globals = None  # type: SymbolTable\n    modules = None  # type: Dict[str, MypyFile]\n    # Nodes that couldn't be checked because some types weren't available. We'll run\n    # another pass and try these again.\n    deferred_nodes = None  # type: List[DeferredNode]\n    # Type checking pass number (0 = first pass)\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    # Error message reporter\n    errors: Errors\n    # Utility for generating messages\n    msg: MessageBuilder\n    # Types of type checked nodes\n    type_map: Dict[Expression, Type]\n\n    # Helper for managing conditional types\n    binder: ConditionalTypeBinder\n    # Helper for type checking expressions\n    expr_checker: mypy.checkexpr.ExpressionChecker\n\n    tscope: Scope\n    scope: \"CheckerScope\"\n    # Stack of function return types\n    return_types: List[Type]\n    # Flags; true for dynamically typed functions\n    dynamic_funcs: List[bool]\n    # Stack of collections of variables with partial types\n    partial_types: List[PartialTypeScope]\n    # Vars for which partial type errors are already reported\n    # (to avoid logically duplicate errors with different error context).\n    partial_reported: Set[Var]\n    globals: SymbolTable\n    modules: Dict[str, MypyFile]\n    # Nodes that couldn't be checked because some types weren't available. We'll run\n    # another pass and try these again.\n    deferred_nodes: List[DeferredNode]\n    # Type checking pass number (0 = first pass)\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "python/mypy",
    "commit": "f98f78216ba9d6ab68c8e69c19e9f3c7926c5efe",
    "filename": "mypy/checker.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/python-mypy/mypy/checker.py",
    "file_hunks_size": 47,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "mypy/checker.py:161:4 Incompatible attribute type [8]: Attribute `type_map` declared in class `TypeChecker` has type `Dict[Expression, Type]` but is used as type `None`.",
    "message": " Attribute `type_map` declared in class `TypeChecker` has type `Dict[Expression, Type]` but is used as type `None`.",
    "rule_id": "Incompatible attribute type [8]",
    "warning_line_no": 161,
    "warning_line": "    type_map = None  # type: Dict[Expression, Type]",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    # Error message reporter\n    errors = None  # type: Errors\n    # Utility for generating messages\n    msg = None  # type: MessageBuilder\n    # Types of type checked nodes\n    type_map = None  # type: Dict[Expression, Type]\n\n    # Helper for managing conditional types\n    binder = None  # type: ConditionalTypeBinder\n    # Helper for type checking expressions\n    expr_checker = None  # type: mypy.checkexpr.ExpressionChecker\n\n    tscope = None  # type: Scope\n    scope = None  # type: CheckerScope\n    # Stack of function return types\n    return_types = None  # type: List[Type]\n    # Flags; true for dynamically typed functions\n    dynamic_funcs = None  # type: List[bool]\n    # Stack of collections of variables with partial types\n    partial_types = None  # type: List[PartialTypeScope]\n    # Vars for which partial type errors are already reported\n    # (to avoid logically duplicate errors with different error context).\n    partial_reported = None  # type: Set[Var]\n    globals = None  # type: SymbolTable\n    modules = None  # type: Dict[str, MypyFile]\n    # Nodes that couldn't be checked because some types weren't available. We'll run\n    # another pass and try these again.\n    deferred_nodes = None  # type: List[DeferredNode]\n    # Type checking pass number (0 = first pass)\n",
        "source_code_len": 1292,
        "target_code": "    # Error message reporter\n    errors: Errors\n    # Utility for generating messages\n    msg: MessageBuilder\n    # Types of type checked nodes\n    type_map: Dict[Expression, Type]\n\n    # Helper for managing conditional types\n    binder: ConditionalTypeBinder\n    # Helper for type checking expressions\n    expr_checker: mypy.checkexpr.ExpressionChecker\n\n    tscope: Scope\n    scope: \"CheckerScope\"\n    # Stack of function return types\n    return_types: List[Type]\n    # Flags; true for dynamically typed functions\n    dynamic_funcs: List[bool]\n    # Stack of collections of variables with partial types\n    partial_types: List[PartialTypeScope]\n    # Vars for which partial type errors are already reported\n    # (to avoid logically duplicate errors with different error context).\n    partial_reported: Set[Var]\n    globals: SymbolTable\n    modules: Dict[str, MypyFile]\n    # Nodes that couldn't be checked because some types weren't available. We'll run\n    # another pass and try these again.\n    deferred_nodes: List[DeferredNode]\n    # Type checking pass number (0 = first pass)\n",
        "target_code_len": 1084,
        "diff_format": "@@ -156,29 +156,29 @@\n     # Error message reporter\n-    errors = None  # type: Errors\n+    errors: Errors\n     # Utility for generating messages\n-    msg = None  # type: MessageBuilder\n+    msg: MessageBuilder\n     # Types of type checked nodes\n-    type_map = None  # type: Dict[Expression, Type]\n+    type_map: Dict[Expression, Type]\n \n     # Helper for managing conditional types\n-    binder = None  # type: ConditionalTypeBinder\n+    binder: ConditionalTypeBinder\n     # Helper for type checking expressions\n-    expr_checker = None  # type: mypy.checkexpr.ExpressionChecker\n-\n-    tscope = None  # type: Scope\n-    scope = None  # type: CheckerScope\n+    expr_checker: mypy.checkexpr.ExpressionChecker\n+\n+    tscope: Scope\n+    scope: \"CheckerScope\"\n     # Stack of function return types\n-    return_types = None  # type: List[Type]\n+    return_types: List[Type]\n     # Flags; true for dynamically typed functions\n-    dynamic_funcs = None  # type: List[bool]\n+    dynamic_funcs: List[bool]\n     # Stack of collections of variables with partial types\n-    partial_types = None  # type: List[PartialTypeScope]\n+    partial_types: List[PartialTypeScope]\n     # Vars for which partial type errors are already reported\n     # (to avoid logically duplicate errors with different error context).\n-    partial_reported = None  # type: Set[Var]\n-    globals = None  # type: SymbolTable\n-    modules = None  # type: Dict[str, MypyFile]\n+    partial_reported: Set[Var]\n+    globals: SymbolTable\n+    modules: Dict[str, MypyFile]\n     # Nodes that couldn't be checked because some types weren't available. We'll run\n     # another pass and try these again.\n-    deferred_nodes = None  # type: List[DeferredNode]\n+    deferred_nodes: List[DeferredNode]\n     # Type checking pass number (0 = first pass)\n",
        "source_code_with_indent": "    # Error message reporter\n    errors = None  # type: Errors\n    # Utility for generating messages\n    msg = None  # type: MessageBuilder\n    # Types of type checked nodes\n    type_map = None  # type: Dict[Expression, Type]\n\n    # Helper for managing conditional types\n    binder = None  # type: ConditionalTypeBinder\n    # Helper for type checking expressions\n    expr_checker = None  # type: mypy.checkexpr.ExpressionChecker\n\n    tscope = None  # type: Scope\n    scope = None  # type: CheckerScope\n    # Stack of function return types\n    return_types = None  # type: List[Type]\n    # Flags; true for dynamically typed functions\n    dynamic_funcs = None  # type: List[bool]\n    # Stack of collections of variables with partial types\n    partial_types = None  # type: List[PartialTypeScope]\n    # Vars for which partial type errors are already reported\n    # (to avoid logically duplicate errors with different error context).\n    partial_reported = None  # type: Set[Var]\n    globals = None  # type: SymbolTable\n    modules = None  # type: Dict[str, MypyFile]\n    # Nodes that couldn't be checked because some types weren't available. We'll run\n    # another pass and try these again.\n    deferred_nodes = None  # type: List[DeferredNode]\n    # Type checking pass number (0 = first pass)\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    # Error message reporter\n    errors: Errors\n    # Utility for generating messages\n    msg: MessageBuilder\n    # Types of type checked nodes\n    type_map: Dict[Expression, Type]\n\n    # Helper for managing conditional types\n    binder: ConditionalTypeBinder\n    # Helper for type checking expressions\n    expr_checker: mypy.checkexpr.ExpressionChecker\n\n    tscope: Scope\n    scope: \"CheckerScope\"\n    # Stack of function return types\n    return_types: List[Type]\n    # Flags; true for dynamically typed functions\n    dynamic_funcs: List[bool]\n    # Stack of collections of variables with partial types\n    partial_types: List[PartialTypeScope]\n    # Vars for which partial type errors are already reported\n    # (to avoid logically duplicate errors with different error context).\n    partial_reported: Set[Var]\n    globals: SymbolTable\n    modules: Dict[str, MypyFile]\n    # Nodes that couldn't be checked because some types weren't available. We'll run\n    # another pass and try these again.\n    deferred_nodes: List[DeferredNode]\n    # Type checking pass number (0 = first pass)\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "python/mypy",
    "commit": "f98f78216ba9d6ab68c8e69c19e9f3c7926c5efe",
    "filename": "mypy/checker.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/python-mypy/mypy/checker.py",
    "file_hunks_size": 47,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "mypy/checker.py:164:4 Incompatible attribute type [8]: Attribute `binder` declared in class `TypeChecker` has type `ConditionalTypeBinder` but is used as type `None`.",
    "message": " Attribute `binder` declared in class `TypeChecker` has type `ConditionalTypeBinder` but is used as type `None`.",
    "rule_id": "Incompatible attribute type [8]",
    "warning_line_no": 164,
    "warning_line": "    binder = None  # type: ConditionalTypeBinder",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    # Error message reporter\n    errors = None  # type: Errors\n    # Utility for generating messages\n    msg = None  # type: MessageBuilder\n    # Types of type checked nodes\n    type_map = None  # type: Dict[Expression, Type]\n\n    # Helper for managing conditional types\n    binder = None  # type: ConditionalTypeBinder\n    # Helper for type checking expressions\n    expr_checker = None  # type: mypy.checkexpr.ExpressionChecker\n\n    tscope = None  # type: Scope\n    scope = None  # type: CheckerScope\n    # Stack of function return types\n    return_types = None  # type: List[Type]\n    # Flags; true for dynamically typed functions\n    dynamic_funcs = None  # type: List[bool]\n    # Stack of collections of variables with partial types\n    partial_types = None  # type: List[PartialTypeScope]\n    # Vars for which partial type errors are already reported\n    # (to avoid logically duplicate errors with different error context).\n    partial_reported = None  # type: Set[Var]\n    globals = None  # type: SymbolTable\n    modules = None  # type: Dict[str, MypyFile]\n    # Nodes that couldn't be checked because some types weren't available. We'll run\n    # another pass and try these again.\n    deferred_nodes = None  # type: List[DeferredNode]\n    # Type checking pass number (0 = first pass)\n",
        "source_code_len": 1292,
        "target_code": "    # Error message reporter\n    errors: Errors\n    # Utility for generating messages\n    msg: MessageBuilder\n    # Types of type checked nodes\n    type_map: Dict[Expression, Type]\n\n    # Helper for managing conditional types\n    binder: ConditionalTypeBinder\n    # Helper for type checking expressions\n    expr_checker: mypy.checkexpr.ExpressionChecker\n\n    tscope: Scope\n    scope: \"CheckerScope\"\n    # Stack of function return types\n    return_types: List[Type]\n    # Flags; true for dynamically typed functions\n    dynamic_funcs: List[bool]\n    # Stack of collections of variables with partial types\n    partial_types: List[PartialTypeScope]\n    # Vars for which partial type errors are already reported\n    # (to avoid logically duplicate errors with different error context).\n    partial_reported: Set[Var]\n    globals: SymbolTable\n    modules: Dict[str, MypyFile]\n    # Nodes that couldn't be checked because some types weren't available. We'll run\n    # another pass and try these again.\n    deferred_nodes: List[DeferredNode]\n    # Type checking pass number (0 = first pass)\n",
        "target_code_len": 1084,
        "diff_format": "@@ -156,29 +156,29 @@\n     # Error message reporter\n-    errors = None  # type: Errors\n+    errors: Errors\n     # Utility for generating messages\n-    msg = None  # type: MessageBuilder\n+    msg: MessageBuilder\n     # Types of type checked nodes\n-    type_map = None  # type: Dict[Expression, Type]\n+    type_map: Dict[Expression, Type]\n \n     # Helper for managing conditional types\n-    binder = None  # type: ConditionalTypeBinder\n+    binder: ConditionalTypeBinder\n     # Helper for type checking expressions\n-    expr_checker = None  # type: mypy.checkexpr.ExpressionChecker\n-\n-    tscope = None  # type: Scope\n-    scope = None  # type: CheckerScope\n+    expr_checker: mypy.checkexpr.ExpressionChecker\n+\n+    tscope: Scope\n+    scope: \"CheckerScope\"\n     # Stack of function return types\n-    return_types = None  # type: List[Type]\n+    return_types: List[Type]\n     # Flags; true for dynamically typed functions\n-    dynamic_funcs = None  # type: List[bool]\n+    dynamic_funcs: List[bool]\n     # Stack of collections of variables with partial types\n-    partial_types = None  # type: List[PartialTypeScope]\n+    partial_types: List[PartialTypeScope]\n     # Vars for which partial type errors are already reported\n     # (to avoid logically duplicate errors with different error context).\n-    partial_reported = None  # type: Set[Var]\n-    globals = None  # type: SymbolTable\n-    modules = None  # type: Dict[str, MypyFile]\n+    partial_reported: Set[Var]\n+    globals: SymbolTable\n+    modules: Dict[str, MypyFile]\n     # Nodes that couldn't be checked because some types weren't available. We'll run\n     # another pass and try these again.\n-    deferred_nodes = None  # type: List[DeferredNode]\n+    deferred_nodes: List[DeferredNode]\n     # Type checking pass number (0 = first pass)\n",
        "source_code_with_indent": "    # Error message reporter\n    errors = None  # type: Errors\n    # Utility for generating messages\n    msg = None  # type: MessageBuilder\n    # Types of type checked nodes\n    type_map = None  # type: Dict[Expression, Type]\n\n    # Helper for managing conditional types\n    binder = None  # type: ConditionalTypeBinder\n    # Helper for type checking expressions\n    expr_checker = None  # type: mypy.checkexpr.ExpressionChecker\n\n    tscope = None  # type: Scope\n    scope = None  # type: CheckerScope\n    # Stack of function return types\n    return_types = None  # type: List[Type]\n    # Flags; true for dynamically typed functions\n    dynamic_funcs = None  # type: List[bool]\n    # Stack of collections of variables with partial types\n    partial_types = None  # type: List[PartialTypeScope]\n    # Vars for which partial type errors are already reported\n    # (to avoid logically duplicate errors with different error context).\n    partial_reported = None  # type: Set[Var]\n    globals = None  # type: SymbolTable\n    modules = None  # type: Dict[str, MypyFile]\n    # Nodes that couldn't be checked because some types weren't available. We'll run\n    # another pass and try these again.\n    deferred_nodes = None  # type: List[DeferredNode]\n    # Type checking pass number (0 = first pass)\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    # Error message reporter\n    errors: Errors\n    # Utility for generating messages\n    msg: MessageBuilder\n    # Types of type checked nodes\n    type_map: Dict[Expression, Type]\n\n    # Helper for managing conditional types\n    binder: ConditionalTypeBinder\n    # Helper for type checking expressions\n    expr_checker: mypy.checkexpr.ExpressionChecker\n\n    tscope: Scope\n    scope: \"CheckerScope\"\n    # Stack of function return types\n    return_types: List[Type]\n    # Flags; true for dynamically typed functions\n    dynamic_funcs: List[bool]\n    # Stack of collections of variables with partial types\n    partial_types: List[PartialTypeScope]\n    # Vars for which partial type errors are already reported\n    # (to avoid logically duplicate errors with different error context).\n    partial_reported: Set[Var]\n    globals: SymbolTable\n    modules: Dict[str, MypyFile]\n    # Nodes that couldn't be checked because some types weren't available. We'll run\n    # another pass and try these again.\n    deferred_nodes: List[DeferredNode]\n    # Type checking pass number (0 = first pass)\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "python/mypy",
    "commit": "f98f78216ba9d6ab68c8e69c19e9f3c7926c5efe",
    "filename": "mypy/checker.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/python-mypy/mypy/checker.py",
    "file_hunks_size": 47,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "mypy/checker.py:166:4 Incompatible attribute type [8]: Attribute `expr_checker` declared in class `TypeChecker` has type `mypy.checkexpr.ExpressionChecker` but is used as type `None`.",
    "message": " Attribute `expr_checker` declared in class `TypeChecker` has type `mypy.checkexpr.ExpressionChecker` but is used as type `None`.",
    "rule_id": "Incompatible attribute type [8]",
    "warning_line_no": 166,
    "warning_line": "    expr_checker = None  # type: mypy.checkexpr.ExpressionChecker",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    # Error message reporter\n    errors = None  # type: Errors\n    # Utility for generating messages\n    msg = None  # type: MessageBuilder\n    # Types of type checked nodes\n    type_map = None  # type: Dict[Expression, Type]\n\n    # Helper for managing conditional types\n    binder = None  # type: ConditionalTypeBinder\n    # Helper for type checking expressions\n    expr_checker = None  # type: mypy.checkexpr.ExpressionChecker\n\n    tscope = None  # type: Scope\n    scope = None  # type: CheckerScope\n    # Stack of function return types\n    return_types = None  # type: List[Type]\n    # Flags; true for dynamically typed functions\n    dynamic_funcs = None  # type: List[bool]\n    # Stack of collections of variables with partial types\n    partial_types = None  # type: List[PartialTypeScope]\n    # Vars for which partial type errors are already reported\n    # (to avoid logically duplicate errors with different error context).\n    partial_reported = None  # type: Set[Var]\n    globals = None  # type: SymbolTable\n    modules = None  # type: Dict[str, MypyFile]\n    # Nodes that couldn't be checked because some types weren't available. We'll run\n    # another pass and try these again.\n    deferred_nodes = None  # type: List[DeferredNode]\n    # Type checking pass number (0 = first pass)\n",
        "source_code_len": 1292,
        "target_code": "    # Error message reporter\n    errors: Errors\n    # Utility for generating messages\n    msg: MessageBuilder\n    # Types of type checked nodes\n    type_map: Dict[Expression, Type]\n\n    # Helper for managing conditional types\n    binder: ConditionalTypeBinder\n    # Helper for type checking expressions\n    expr_checker: mypy.checkexpr.ExpressionChecker\n\n    tscope: Scope\n    scope: \"CheckerScope\"\n    # Stack of function return types\n    return_types: List[Type]\n    # Flags; true for dynamically typed functions\n    dynamic_funcs: List[bool]\n    # Stack of collections of variables with partial types\n    partial_types: List[PartialTypeScope]\n    # Vars for which partial type errors are already reported\n    # (to avoid logically duplicate errors with different error context).\n    partial_reported: Set[Var]\n    globals: SymbolTable\n    modules: Dict[str, MypyFile]\n    # Nodes that couldn't be checked because some types weren't available. We'll run\n    # another pass and try these again.\n    deferred_nodes: List[DeferredNode]\n    # Type checking pass number (0 = first pass)\n",
        "target_code_len": 1084,
        "diff_format": "@@ -156,29 +156,29 @@\n     # Error message reporter\n-    errors = None  # type: Errors\n+    errors: Errors\n     # Utility for generating messages\n-    msg = None  # type: MessageBuilder\n+    msg: MessageBuilder\n     # Types of type checked nodes\n-    type_map = None  # type: Dict[Expression, Type]\n+    type_map: Dict[Expression, Type]\n \n     # Helper for managing conditional types\n-    binder = None  # type: ConditionalTypeBinder\n+    binder: ConditionalTypeBinder\n     # Helper for type checking expressions\n-    expr_checker = None  # type: mypy.checkexpr.ExpressionChecker\n-\n-    tscope = None  # type: Scope\n-    scope = None  # type: CheckerScope\n+    expr_checker: mypy.checkexpr.ExpressionChecker\n+\n+    tscope: Scope\n+    scope: \"CheckerScope\"\n     # Stack of function return types\n-    return_types = None  # type: List[Type]\n+    return_types: List[Type]\n     # Flags; true for dynamically typed functions\n-    dynamic_funcs = None  # type: List[bool]\n+    dynamic_funcs: List[bool]\n     # Stack of collections of variables with partial types\n-    partial_types = None  # type: List[PartialTypeScope]\n+    partial_types: List[PartialTypeScope]\n     # Vars for which partial type errors are already reported\n     # (to avoid logically duplicate errors with different error context).\n-    partial_reported = None  # type: Set[Var]\n-    globals = None  # type: SymbolTable\n-    modules = None  # type: Dict[str, MypyFile]\n+    partial_reported: Set[Var]\n+    globals: SymbolTable\n+    modules: Dict[str, MypyFile]\n     # Nodes that couldn't be checked because some types weren't available. We'll run\n     # another pass and try these again.\n-    deferred_nodes = None  # type: List[DeferredNode]\n+    deferred_nodes: List[DeferredNode]\n     # Type checking pass number (0 = first pass)\n",
        "source_code_with_indent": "    # Error message reporter\n    errors = None  # type: Errors\n    # Utility for generating messages\n    msg = None  # type: MessageBuilder\n    # Types of type checked nodes\n    type_map = None  # type: Dict[Expression, Type]\n\n    # Helper for managing conditional types\n    binder = None  # type: ConditionalTypeBinder\n    # Helper for type checking expressions\n    expr_checker = None  # type: mypy.checkexpr.ExpressionChecker\n\n    tscope = None  # type: Scope\n    scope = None  # type: CheckerScope\n    # Stack of function return types\n    return_types = None  # type: List[Type]\n    # Flags; true for dynamically typed functions\n    dynamic_funcs = None  # type: List[bool]\n    # Stack of collections of variables with partial types\n    partial_types = None  # type: List[PartialTypeScope]\n    # Vars for which partial type errors are already reported\n    # (to avoid logically duplicate errors with different error context).\n    partial_reported = None  # type: Set[Var]\n    globals = None  # type: SymbolTable\n    modules = None  # type: Dict[str, MypyFile]\n    # Nodes that couldn't be checked because some types weren't available. We'll run\n    # another pass and try these again.\n    deferred_nodes = None  # type: List[DeferredNode]\n    # Type checking pass number (0 = first pass)\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    # Error message reporter\n    errors: Errors\n    # Utility for generating messages\n    msg: MessageBuilder\n    # Types of type checked nodes\n    type_map: Dict[Expression, Type]\n\n    # Helper for managing conditional types\n    binder: ConditionalTypeBinder\n    # Helper for type checking expressions\n    expr_checker: mypy.checkexpr.ExpressionChecker\n\n    tscope: Scope\n    scope: \"CheckerScope\"\n    # Stack of function return types\n    return_types: List[Type]\n    # Flags; true for dynamically typed functions\n    dynamic_funcs: List[bool]\n    # Stack of collections of variables with partial types\n    partial_types: List[PartialTypeScope]\n    # Vars for which partial type errors are already reported\n    # (to avoid logically duplicate errors with different error context).\n    partial_reported: Set[Var]\n    globals: SymbolTable\n    modules: Dict[str, MypyFile]\n    # Nodes that couldn't be checked because some types weren't available. We'll run\n    # another pass and try these again.\n    deferred_nodes: List[DeferredNode]\n    # Type checking pass number (0 = first pass)\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "python/mypy",
    "commit": "f98f78216ba9d6ab68c8e69c19e9f3c7926c5efe",
    "filename": "mypy/checker.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/python-mypy/mypy/checker.py",
    "file_hunks_size": 47,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "mypy/checker.py:168:4 Incompatible attribute type [8]: Attribute `tscope` declared in class `TypeChecker` has type `Scope` but is used as type `None`.",
    "message": " Attribute `tscope` declared in class `TypeChecker` has type `Scope` but is used as type `None`.",
    "rule_id": "Incompatible attribute type [8]",
    "warning_line_no": 168,
    "warning_line": "    tscope = None  # type: Scope",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    # Error message reporter\n    errors = None  # type: Errors\n    # Utility for generating messages\n    msg = None  # type: MessageBuilder\n    # Types of type checked nodes\n    type_map = None  # type: Dict[Expression, Type]\n\n    # Helper for managing conditional types\n    binder = None  # type: ConditionalTypeBinder\n    # Helper for type checking expressions\n    expr_checker = None  # type: mypy.checkexpr.ExpressionChecker\n\n    tscope = None  # type: Scope\n    scope = None  # type: CheckerScope\n    # Stack of function return types\n    return_types = None  # type: List[Type]\n    # Flags; true for dynamically typed functions\n    dynamic_funcs = None  # type: List[bool]\n    # Stack of collections of variables with partial types\n    partial_types = None  # type: List[PartialTypeScope]\n    # Vars for which partial type errors are already reported\n    # (to avoid logically duplicate errors with different error context).\n    partial_reported = None  # type: Set[Var]\n    globals = None  # type: SymbolTable\n    modules = None  # type: Dict[str, MypyFile]\n    # Nodes that couldn't be checked because some types weren't available. We'll run\n    # another pass and try these again.\n    deferred_nodes = None  # type: List[DeferredNode]\n    # Type checking pass number (0 = first pass)\n",
        "source_code_len": 1292,
        "target_code": "    # Error message reporter\n    errors: Errors\n    # Utility for generating messages\n    msg: MessageBuilder\n    # Types of type checked nodes\n    type_map: Dict[Expression, Type]\n\n    # Helper for managing conditional types\n    binder: ConditionalTypeBinder\n    # Helper for type checking expressions\n    expr_checker: mypy.checkexpr.ExpressionChecker\n\n    tscope: Scope\n    scope: \"CheckerScope\"\n    # Stack of function return types\n    return_types: List[Type]\n    # Flags; true for dynamically typed functions\n    dynamic_funcs: List[bool]\n    # Stack of collections of variables with partial types\n    partial_types: List[PartialTypeScope]\n    # Vars for which partial type errors are already reported\n    # (to avoid logically duplicate errors with different error context).\n    partial_reported: Set[Var]\n    globals: SymbolTable\n    modules: Dict[str, MypyFile]\n    # Nodes that couldn't be checked because some types weren't available. We'll run\n    # another pass and try these again.\n    deferred_nodes: List[DeferredNode]\n    # Type checking pass number (0 = first pass)\n",
        "target_code_len": 1084,
        "diff_format": "@@ -156,29 +156,29 @@\n     # Error message reporter\n-    errors = None  # type: Errors\n+    errors: Errors\n     # Utility for generating messages\n-    msg = None  # type: MessageBuilder\n+    msg: MessageBuilder\n     # Types of type checked nodes\n-    type_map = None  # type: Dict[Expression, Type]\n+    type_map: Dict[Expression, Type]\n \n     # Helper for managing conditional types\n-    binder = None  # type: ConditionalTypeBinder\n+    binder: ConditionalTypeBinder\n     # Helper for type checking expressions\n-    expr_checker = None  # type: mypy.checkexpr.ExpressionChecker\n-\n-    tscope = None  # type: Scope\n-    scope = None  # type: CheckerScope\n+    expr_checker: mypy.checkexpr.ExpressionChecker\n+\n+    tscope: Scope\n+    scope: \"CheckerScope\"\n     # Stack of function return types\n-    return_types = None  # type: List[Type]\n+    return_types: List[Type]\n     # Flags; true for dynamically typed functions\n-    dynamic_funcs = None  # type: List[bool]\n+    dynamic_funcs: List[bool]\n     # Stack of collections of variables with partial types\n-    partial_types = None  # type: List[PartialTypeScope]\n+    partial_types: List[PartialTypeScope]\n     # Vars for which partial type errors are already reported\n     # (to avoid logically duplicate errors with different error context).\n-    partial_reported = None  # type: Set[Var]\n-    globals = None  # type: SymbolTable\n-    modules = None  # type: Dict[str, MypyFile]\n+    partial_reported: Set[Var]\n+    globals: SymbolTable\n+    modules: Dict[str, MypyFile]\n     # Nodes that couldn't be checked because some types weren't available. We'll run\n     # another pass and try these again.\n-    deferred_nodes = None  # type: List[DeferredNode]\n+    deferred_nodes: List[DeferredNode]\n     # Type checking pass number (0 = first pass)\n",
        "source_code_with_indent": "    # Error message reporter\n    errors = None  # type: Errors\n    # Utility for generating messages\n    msg = None  # type: MessageBuilder\n    # Types of type checked nodes\n    type_map = None  # type: Dict[Expression, Type]\n\n    # Helper for managing conditional types\n    binder = None  # type: ConditionalTypeBinder\n    # Helper for type checking expressions\n    expr_checker = None  # type: mypy.checkexpr.ExpressionChecker\n\n    tscope = None  # type: Scope\n    scope = None  # type: CheckerScope\n    # Stack of function return types\n    return_types = None  # type: List[Type]\n    # Flags; true for dynamically typed functions\n    dynamic_funcs = None  # type: List[bool]\n    # Stack of collections of variables with partial types\n    partial_types = None  # type: List[PartialTypeScope]\n    # Vars for which partial type errors are already reported\n    # (to avoid logically duplicate errors with different error context).\n    partial_reported = None  # type: Set[Var]\n    globals = None  # type: SymbolTable\n    modules = None  # type: Dict[str, MypyFile]\n    # Nodes that couldn't be checked because some types weren't available. We'll run\n    # another pass and try these again.\n    deferred_nodes = None  # type: List[DeferredNode]\n    # Type checking pass number (0 = first pass)\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    # Error message reporter\n    errors: Errors\n    # Utility for generating messages\n    msg: MessageBuilder\n    # Types of type checked nodes\n    type_map: Dict[Expression, Type]\n\n    # Helper for managing conditional types\n    binder: ConditionalTypeBinder\n    # Helper for type checking expressions\n    expr_checker: mypy.checkexpr.ExpressionChecker\n\n    tscope: Scope\n    scope: \"CheckerScope\"\n    # Stack of function return types\n    return_types: List[Type]\n    # Flags; true for dynamically typed functions\n    dynamic_funcs: List[bool]\n    # Stack of collections of variables with partial types\n    partial_types: List[PartialTypeScope]\n    # Vars for which partial type errors are already reported\n    # (to avoid logically duplicate errors with different error context).\n    partial_reported: Set[Var]\n    globals: SymbolTable\n    modules: Dict[str, MypyFile]\n    # Nodes that couldn't be checked because some types weren't available. We'll run\n    # another pass and try these again.\n    deferred_nodes: List[DeferredNode]\n    # Type checking pass number (0 = first pass)\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "python/mypy",
    "commit": "f98f78216ba9d6ab68c8e69c19e9f3c7926c5efe",
    "filename": "mypy/checker.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/python-mypy/mypy/checker.py",
    "file_hunks_size": 47,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "mypy/checker.py:169:4 Incompatible attribute type [8]: Attribute `scope` declared in class `TypeChecker` has type `CheckerScope` but is used as type `None`.",
    "message": " Attribute `scope` declared in class `TypeChecker` has type `CheckerScope` but is used as type `None`.",
    "rule_id": "Incompatible attribute type [8]",
    "warning_line_no": 169,
    "warning_line": "    scope = None  # type: CheckerScope",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    # Error message reporter\n    errors = None  # type: Errors\n    # Utility for generating messages\n    msg = None  # type: MessageBuilder\n    # Types of type checked nodes\n    type_map = None  # type: Dict[Expression, Type]\n\n    # Helper for managing conditional types\n    binder = None  # type: ConditionalTypeBinder\n    # Helper for type checking expressions\n    expr_checker = None  # type: mypy.checkexpr.ExpressionChecker\n\n    tscope = None  # type: Scope\n    scope = None  # type: CheckerScope\n    # Stack of function return types\n    return_types = None  # type: List[Type]\n    # Flags; true for dynamically typed functions\n    dynamic_funcs = None  # type: List[bool]\n    # Stack of collections of variables with partial types\n    partial_types = None  # type: List[PartialTypeScope]\n    # Vars for which partial type errors are already reported\n    # (to avoid logically duplicate errors with different error context).\n    partial_reported = None  # type: Set[Var]\n    globals = None  # type: SymbolTable\n    modules = None  # type: Dict[str, MypyFile]\n    # Nodes that couldn't be checked because some types weren't available. We'll run\n    # another pass and try these again.\n    deferred_nodes = None  # type: List[DeferredNode]\n    # Type checking pass number (0 = first pass)\n",
        "source_code_len": 1292,
        "target_code": "    # Error message reporter\n    errors: Errors\n    # Utility for generating messages\n    msg: MessageBuilder\n    # Types of type checked nodes\n    type_map: Dict[Expression, Type]\n\n    # Helper for managing conditional types\n    binder: ConditionalTypeBinder\n    # Helper for type checking expressions\n    expr_checker: mypy.checkexpr.ExpressionChecker\n\n    tscope: Scope\n    scope: \"CheckerScope\"\n    # Stack of function return types\n    return_types: List[Type]\n    # Flags; true for dynamically typed functions\n    dynamic_funcs: List[bool]\n    # Stack of collections of variables with partial types\n    partial_types: List[PartialTypeScope]\n    # Vars for which partial type errors are already reported\n    # (to avoid logically duplicate errors with different error context).\n    partial_reported: Set[Var]\n    globals: SymbolTable\n    modules: Dict[str, MypyFile]\n    # Nodes that couldn't be checked because some types weren't available. We'll run\n    # another pass and try these again.\n    deferred_nodes: List[DeferredNode]\n    # Type checking pass number (0 = first pass)\n",
        "target_code_len": 1084,
        "diff_format": "@@ -156,29 +156,29 @@\n     # Error message reporter\n-    errors = None  # type: Errors\n+    errors: Errors\n     # Utility for generating messages\n-    msg = None  # type: MessageBuilder\n+    msg: MessageBuilder\n     # Types of type checked nodes\n-    type_map = None  # type: Dict[Expression, Type]\n+    type_map: Dict[Expression, Type]\n \n     # Helper for managing conditional types\n-    binder = None  # type: ConditionalTypeBinder\n+    binder: ConditionalTypeBinder\n     # Helper for type checking expressions\n-    expr_checker = None  # type: mypy.checkexpr.ExpressionChecker\n-\n-    tscope = None  # type: Scope\n-    scope = None  # type: CheckerScope\n+    expr_checker: mypy.checkexpr.ExpressionChecker\n+\n+    tscope: Scope\n+    scope: \"CheckerScope\"\n     # Stack of function return types\n-    return_types = None  # type: List[Type]\n+    return_types: List[Type]\n     # Flags; true for dynamically typed functions\n-    dynamic_funcs = None  # type: List[bool]\n+    dynamic_funcs: List[bool]\n     # Stack of collections of variables with partial types\n-    partial_types = None  # type: List[PartialTypeScope]\n+    partial_types: List[PartialTypeScope]\n     # Vars for which partial type errors are already reported\n     # (to avoid logically duplicate errors with different error context).\n-    partial_reported = None  # type: Set[Var]\n-    globals = None  # type: SymbolTable\n-    modules = None  # type: Dict[str, MypyFile]\n+    partial_reported: Set[Var]\n+    globals: SymbolTable\n+    modules: Dict[str, MypyFile]\n     # Nodes that couldn't be checked because some types weren't available. We'll run\n     # another pass and try these again.\n-    deferred_nodes = None  # type: List[DeferredNode]\n+    deferred_nodes: List[DeferredNode]\n     # Type checking pass number (0 = first pass)\n",
        "source_code_with_indent": "    # Error message reporter\n    errors = None  # type: Errors\n    # Utility for generating messages\n    msg = None  # type: MessageBuilder\n    # Types of type checked nodes\n    type_map = None  # type: Dict[Expression, Type]\n\n    # Helper for managing conditional types\n    binder = None  # type: ConditionalTypeBinder\n    # Helper for type checking expressions\n    expr_checker = None  # type: mypy.checkexpr.ExpressionChecker\n\n    tscope = None  # type: Scope\n    scope = None  # type: CheckerScope\n    # Stack of function return types\n    return_types = None  # type: List[Type]\n    # Flags; true for dynamically typed functions\n    dynamic_funcs = None  # type: List[bool]\n    # Stack of collections of variables with partial types\n    partial_types = None  # type: List[PartialTypeScope]\n    # Vars for which partial type errors are already reported\n    # (to avoid logically duplicate errors with different error context).\n    partial_reported = None  # type: Set[Var]\n    globals = None  # type: SymbolTable\n    modules = None  # type: Dict[str, MypyFile]\n    # Nodes that couldn't be checked because some types weren't available. We'll run\n    # another pass and try these again.\n    deferred_nodes = None  # type: List[DeferredNode]\n    # Type checking pass number (0 = first pass)\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    # Error message reporter\n    errors: Errors\n    # Utility for generating messages\n    msg: MessageBuilder\n    # Types of type checked nodes\n    type_map: Dict[Expression, Type]\n\n    # Helper for managing conditional types\n    binder: ConditionalTypeBinder\n    # Helper for type checking expressions\n    expr_checker: mypy.checkexpr.ExpressionChecker\n\n    tscope: Scope\n    scope: \"CheckerScope\"\n    # Stack of function return types\n    return_types: List[Type]\n    # Flags; true for dynamically typed functions\n    dynamic_funcs: List[bool]\n    # Stack of collections of variables with partial types\n    partial_types: List[PartialTypeScope]\n    # Vars for which partial type errors are already reported\n    # (to avoid logically duplicate errors with different error context).\n    partial_reported: Set[Var]\n    globals: SymbolTable\n    modules: Dict[str, MypyFile]\n    # Nodes that couldn't be checked because some types weren't available. We'll run\n    # another pass and try these again.\n    deferred_nodes: List[DeferredNode]\n    # Type checking pass number (0 = first pass)\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "python/mypy",
    "commit": "f98f78216ba9d6ab68c8e69c19e9f3c7926c5efe",
    "filename": "mypy/checker.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/python-mypy/mypy/checker.py",
    "file_hunks_size": 47,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "mypy/checker.py:171:4 Incompatible attribute type [8]: Attribute `return_types` declared in class `TypeChecker` has type `List[Type]` but is used as type `None`.",
    "message": " Attribute `return_types` declared in class `TypeChecker` has type `List[Type]` but is used as type `None`.",
    "rule_id": "Incompatible attribute type [8]",
    "warning_line_no": 171,
    "warning_line": "    return_types = None  # type: List[Type]",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    # Error message reporter\n    errors = None  # type: Errors\n    # Utility for generating messages\n    msg = None  # type: MessageBuilder\n    # Types of type checked nodes\n    type_map = None  # type: Dict[Expression, Type]\n\n    # Helper for managing conditional types\n    binder = None  # type: ConditionalTypeBinder\n    # Helper for type checking expressions\n    expr_checker = None  # type: mypy.checkexpr.ExpressionChecker\n\n    tscope = None  # type: Scope\n    scope = None  # type: CheckerScope\n    # Stack of function return types\n    return_types = None  # type: List[Type]\n    # Flags; true for dynamically typed functions\n    dynamic_funcs = None  # type: List[bool]\n    # Stack of collections of variables with partial types\n    partial_types = None  # type: List[PartialTypeScope]\n    # Vars for which partial type errors are already reported\n    # (to avoid logically duplicate errors with different error context).\n    partial_reported = None  # type: Set[Var]\n    globals = None  # type: SymbolTable\n    modules = None  # type: Dict[str, MypyFile]\n    # Nodes that couldn't be checked because some types weren't available. We'll run\n    # another pass and try these again.\n    deferred_nodes = None  # type: List[DeferredNode]\n    # Type checking pass number (0 = first pass)\n",
        "source_code_len": 1292,
        "target_code": "    # Error message reporter\n    errors: Errors\n    # Utility for generating messages\n    msg: MessageBuilder\n    # Types of type checked nodes\n    type_map: Dict[Expression, Type]\n\n    # Helper for managing conditional types\n    binder: ConditionalTypeBinder\n    # Helper for type checking expressions\n    expr_checker: mypy.checkexpr.ExpressionChecker\n\n    tscope: Scope\n    scope: \"CheckerScope\"\n    # Stack of function return types\n    return_types: List[Type]\n    # Flags; true for dynamically typed functions\n    dynamic_funcs: List[bool]\n    # Stack of collections of variables with partial types\n    partial_types: List[PartialTypeScope]\n    # Vars for which partial type errors are already reported\n    # (to avoid logically duplicate errors with different error context).\n    partial_reported: Set[Var]\n    globals: SymbolTable\n    modules: Dict[str, MypyFile]\n    # Nodes that couldn't be checked because some types weren't available. We'll run\n    # another pass and try these again.\n    deferred_nodes: List[DeferredNode]\n    # Type checking pass number (0 = first pass)\n",
        "target_code_len": 1084,
        "diff_format": "@@ -156,29 +156,29 @@\n     # Error message reporter\n-    errors = None  # type: Errors\n+    errors: Errors\n     # Utility for generating messages\n-    msg = None  # type: MessageBuilder\n+    msg: MessageBuilder\n     # Types of type checked nodes\n-    type_map = None  # type: Dict[Expression, Type]\n+    type_map: Dict[Expression, Type]\n \n     # Helper for managing conditional types\n-    binder = None  # type: ConditionalTypeBinder\n+    binder: ConditionalTypeBinder\n     # Helper for type checking expressions\n-    expr_checker = None  # type: mypy.checkexpr.ExpressionChecker\n-\n-    tscope = None  # type: Scope\n-    scope = None  # type: CheckerScope\n+    expr_checker: mypy.checkexpr.ExpressionChecker\n+\n+    tscope: Scope\n+    scope: \"CheckerScope\"\n     # Stack of function return types\n-    return_types = None  # type: List[Type]\n+    return_types: List[Type]\n     # Flags; true for dynamically typed functions\n-    dynamic_funcs = None  # type: List[bool]\n+    dynamic_funcs: List[bool]\n     # Stack of collections of variables with partial types\n-    partial_types = None  # type: List[PartialTypeScope]\n+    partial_types: List[PartialTypeScope]\n     # Vars for which partial type errors are already reported\n     # (to avoid logically duplicate errors with different error context).\n-    partial_reported = None  # type: Set[Var]\n-    globals = None  # type: SymbolTable\n-    modules = None  # type: Dict[str, MypyFile]\n+    partial_reported: Set[Var]\n+    globals: SymbolTable\n+    modules: Dict[str, MypyFile]\n     # Nodes that couldn't be checked because some types weren't available. We'll run\n     # another pass and try these again.\n-    deferred_nodes = None  # type: List[DeferredNode]\n+    deferred_nodes: List[DeferredNode]\n     # Type checking pass number (0 = first pass)\n",
        "source_code_with_indent": "    # Error message reporter\n    errors = None  # type: Errors\n    # Utility for generating messages\n    msg = None  # type: MessageBuilder\n    # Types of type checked nodes\n    type_map = None  # type: Dict[Expression, Type]\n\n    # Helper for managing conditional types\n    binder = None  # type: ConditionalTypeBinder\n    # Helper for type checking expressions\n    expr_checker = None  # type: mypy.checkexpr.ExpressionChecker\n\n    tscope = None  # type: Scope\n    scope = None  # type: CheckerScope\n    # Stack of function return types\n    return_types = None  # type: List[Type]\n    # Flags; true for dynamically typed functions\n    dynamic_funcs = None  # type: List[bool]\n    # Stack of collections of variables with partial types\n    partial_types = None  # type: List[PartialTypeScope]\n    # Vars for which partial type errors are already reported\n    # (to avoid logically duplicate errors with different error context).\n    partial_reported = None  # type: Set[Var]\n    globals = None  # type: SymbolTable\n    modules = None  # type: Dict[str, MypyFile]\n    # Nodes that couldn't be checked because some types weren't available. We'll run\n    # another pass and try these again.\n    deferred_nodes = None  # type: List[DeferredNode]\n    # Type checking pass number (0 = first pass)\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    # Error message reporter\n    errors: Errors\n    # Utility for generating messages\n    msg: MessageBuilder\n    # Types of type checked nodes\n    type_map: Dict[Expression, Type]\n\n    # Helper for managing conditional types\n    binder: ConditionalTypeBinder\n    # Helper for type checking expressions\n    expr_checker: mypy.checkexpr.ExpressionChecker\n\n    tscope: Scope\n    scope: \"CheckerScope\"\n    # Stack of function return types\n    return_types: List[Type]\n    # Flags; true for dynamically typed functions\n    dynamic_funcs: List[bool]\n    # Stack of collections of variables with partial types\n    partial_types: List[PartialTypeScope]\n    # Vars for which partial type errors are already reported\n    # (to avoid logically duplicate errors with different error context).\n    partial_reported: Set[Var]\n    globals: SymbolTable\n    modules: Dict[str, MypyFile]\n    # Nodes that couldn't be checked because some types weren't available. We'll run\n    # another pass and try these again.\n    deferred_nodes: List[DeferredNode]\n    # Type checking pass number (0 = first pass)\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "python/mypy",
    "commit": "f98f78216ba9d6ab68c8e69c19e9f3c7926c5efe",
    "filename": "mypy/checker.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/python-mypy/mypy/checker.py",
    "file_hunks_size": 47,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "mypy/checker.py:173:4 Incompatible attribute type [8]: Attribute `dynamic_funcs` declared in class `TypeChecker` has type `List[bool]` but is used as type `None`.",
    "message": " Attribute `dynamic_funcs` declared in class `TypeChecker` has type `List[bool]` but is used as type `None`.",
    "rule_id": "Incompatible attribute type [8]",
    "warning_line_no": 173,
    "warning_line": "    dynamic_funcs = None  # type: List[bool]",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    # Error message reporter\n    errors = None  # type: Errors\n    # Utility for generating messages\n    msg = None  # type: MessageBuilder\n    # Types of type checked nodes\n    type_map = None  # type: Dict[Expression, Type]\n\n    # Helper for managing conditional types\n    binder = None  # type: ConditionalTypeBinder\n    # Helper for type checking expressions\n    expr_checker = None  # type: mypy.checkexpr.ExpressionChecker\n\n    tscope = None  # type: Scope\n    scope = None  # type: CheckerScope\n    # Stack of function return types\n    return_types = None  # type: List[Type]\n    # Flags; true for dynamically typed functions\n    dynamic_funcs = None  # type: List[bool]\n    # Stack of collections of variables with partial types\n    partial_types = None  # type: List[PartialTypeScope]\n    # Vars for which partial type errors are already reported\n    # (to avoid logically duplicate errors with different error context).\n    partial_reported = None  # type: Set[Var]\n    globals = None  # type: SymbolTable\n    modules = None  # type: Dict[str, MypyFile]\n    # Nodes that couldn't be checked because some types weren't available. We'll run\n    # another pass and try these again.\n    deferred_nodes = None  # type: List[DeferredNode]\n    # Type checking pass number (0 = first pass)\n",
        "source_code_len": 1292,
        "target_code": "    # Error message reporter\n    errors: Errors\n    # Utility for generating messages\n    msg: MessageBuilder\n    # Types of type checked nodes\n    type_map: Dict[Expression, Type]\n\n    # Helper for managing conditional types\n    binder: ConditionalTypeBinder\n    # Helper for type checking expressions\n    expr_checker: mypy.checkexpr.ExpressionChecker\n\n    tscope: Scope\n    scope: \"CheckerScope\"\n    # Stack of function return types\n    return_types: List[Type]\n    # Flags; true for dynamically typed functions\n    dynamic_funcs: List[bool]\n    # Stack of collections of variables with partial types\n    partial_types: List[PartialTypeScope]\n    # Vars for which partial type errors are already reported\n    # (to avoid logically duplicate errors with different error context).\n    partial_reported: Set[Var]\n    globals: SymbolTable\n    modules: Dict[str, MypyFile]\n    # Nodes that couldn't be checked because some types weren't available. We'll run\n    # another pass and try these again.\n    deferred_nodes: List[DeferredNode]\n    # Type checking pass number (0 = first pass)\n",
        "target_code_len": 1084,
        "diff_format": "@@ -156,29 +156,29 @@\n     # Error message reporter\n-    errors = None  # type: Errors\n+    errors: Errors\n     # Utility for generating messages\n-    msg = None  # type: MessageBuilder\n+    msg: MessageBuilder\n     # Types of type checked nodes\n-    type_map = None  # type: Dict[Expression, Type]\n+    type_map: Dict[Expression, Type]\n \n     # Helper for managing conditional types\n-    binder = None  # type: ConditionalTypeBinder\n+    binder: ConditionalTypeBinder\n     # Helper for type checking expressions\n-    expr_checker = None  # type: mypy.checkexpr.ExpressionChecker\n-\n-    tscope = None  # type: Scope\n-    scope = None  # type: CheckerScope\n+    expr_checker: mypy.checkexpr.ExpressionChecker\n+\n+    tscope: Scope\n+    scope: \"CheckerScope\"\n     # Stack of function return types\n-    return_types = None  # type: List[Type]\n+    return_types: List[Type]\n     # Flags; true for dynamically typed functions\n-    dynamic_funcs = None  # type: List[bool]\n+    dynamic_funcs: List[bool]\n     # Stack of collections of variables with partial types\n-    partial_types = None  # type: List[PartialTypeScope]\n+    partial_types: List[PartialTypeScope]\n     # Vars for which partial type errors are already reported\n     # (to avoid logically duplicate errors with different error context).\n-    partial_reported = None  # type: Set[Var]\n-    globals = None  # type: SymbolTable\n-    modules = None  # type: Dict[str, MypyFile]\n+    partial_reported: Set[Var]\n+    globals: SymbolTable\n+    modules: Dict[str, MypyFile]\n     # Nodes that couldn't be checked because some types weren't available. We'll run\n     # another pass and try these again.\n-    deferred_nodes = None  # type: List[DeferredNode]\n+    deferred_nodes: List[DeferredNode]\n     # Type checking pass number (0 = first pass)\n",
        "source_code_with_indent": "    # Error message reporter\n    errors = None  # type: Errors\n    # Utility for generating messages\n    msg = None  # type: MessageBuilder\n    # Types of type checked nodes\n    type_map = None  # type: Dict[Expression, Type]\n\n    # Helper for managing conditional types\n    binder = None  # type: ConditionalTypeBinder\n    # Helper for type checking expressions\n    expr_checker = None  # type: mypy.checkexpr.ExpressionChecker\n\n    tscope = None  # type: Scope\n    scope = None  # type: CheckerScope\n    # Stack of function return types\n    return_types = None  # type: List[Type]\n    # Flags; true for dynamically typed functions\n    dynamic_funcs = None  # type: List[bool]\n    # Stack of collections of variables with partial types\n    partial_types = None  # type: List[PartialTypeScope]\n    # Vars for which partial type errors are already reported\n    # (to avoid logically duplicate errors with different error context).\n    partial_reported = None  # type: Set[Var]\n    globals = None  # type: SymbolTable\n    modules = None  # type: Dict[str, MypyFile]\n    # Nodes that couldn't be checked because some types weren't available. We'll run\n    # another pass and try these again.\n    deferred_nodes = None  # type: List[DeferredNode]\n    # Type checking pass number (0 = first pass)\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    # Error message reporter\n    errors: Errors\n    # Utility for generating messages\n    msg: MessageBuilder\n    # Types of type checked nodes\n    type_map: Dict[Expression, Type]\n\n    # Helper for managing conditional types\n    binder: ConditionalTypeBinder\n    # Helper for type checking expressions\n    expr_checker: mypy.checkexpr.ExpressionChecker\n\n    tscope: Scope\n    scope: \"CheckerScope\"\n    # Stack of function return types\n    return_types: List[Type]\n    # Flags; true for dynamically typed functions\n    dynamic_funcs: List[bool]\n    # Stack of collections of variables with partial types\n    partial_types: List[PartialTypeScope]\n    # Vars for which partial type errors are already reported\n    # (to avoid logically duplicate errors with different error context).\n    partial_reported: Set[Var]\n    globals: SymbolTable\n    modules: Dict[str, MypyFile]\n    # Nodes that couldn't be checked because some types weren't available. We'll run\n    # another pass and try these again.\n    deferred_nodes: List[DeferredNode]\n    # Type checking pass number (0 = first pass)\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "python/mypy",
    "commit": "f98f78216ba9d6ab68c8e69c19e9f3c7926c5efe",
    "filename": "mypy/checker.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/python-mypy/mypy/checker.py",
    "file_hunks_size": 47,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "mypy/checker.py:175:4 Incompatible attribute type [8]: Attribute `partial_types` declared in class `TypeChecker` has type `List[PartialTypeScope]` but is used as type `None`.",
    "message": " Attribute `partial_types` declared in class `TypeChecker` has type `List[PartialTypeScope]` but is used as type `None`.",
    "rule_id": "Incompatible attribute type [8]",
    "warning_line_no": 175,
    "warning_line": "    partial_types = None  # type: List[PartialTypeScope]",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    # Error message reporter\n    errors = None  # type: Errors\n    # Utility for generating messages\n    msg = None  # type: MessageBuilder\n    # Types of type checked nodes\n    type_map = None  # type: Dict[Expression, Type]\n\n    # Helper for managing conditional types\n    binder = None  # type: ConditionalTypeBinder\n    # Helper for type checking expressions\n    expr_checker = None  # type: mypy.checkexpr.ExpressionChecker\n\n    tscope = None  # type: Scope\n    scope = None  # type: CheckerScope\n    # Stack of function return types\n    return_types = None  # type: List[Type]\n    # Flags; true for dynamically typed functions\n    dynamic_funcs = None  # type: List[bool]\n    # Stack of collections of variables with partial types\n    partial_types = None  # type: List[PartialTypeScope]\n    # Vars for which partial type errors are already reported\n    # (to avoid logically duplicate errors with different error context).\n    partial_reported = None  # type: Set[Var]\n    globals = None  # type: SymbolTable\n    modules = None  # type: Dict[str, MypyFile]\n    # Nodes that couldn't be checked because some types weren't available. We'll run\n    # another pass and try these again.\n    deferred_nodes = None  # type: List[DeferredNode]\n    # Type checking pass number (0 = first pass)\n",
        "source_code_len": 1292,
        "target_code": "    # Error message reporter\n    errors: Errors\n    # Utility for generating messages\n    msg: MessageBuilder\n    # Types of type checked nodes\n    type_map: Dict[Expression, Type]\n\n    # Helper for managing conditional types\n    binder: ConditionalTypeBinder\n    # Helper for type checking expressions\n    expr_checker: mypy.checkexpr.ExpressionChecker\n\n    tscope: Scope\n    scope: \"CheckerScope\"\n    # Stack of function return types\n    return_types: List[Type]\n    # Flags; true for dynamically typed functions\n    dynamic_funcs: List[bool]\n    # Stack of collections of variables with partial types\n    partial_types: List[PartialTypeScope]\n    # Vars for which partial type errors are already reported\n    # (to avoid logically duplicate errors with different error context).\n    partial_reported: Set[Var]\n    globals: SymbolTable\n    modules: Dict[str, MypyFile]\n    # Nodes that couldn't be checked because some types weren't available. We'll run\n    # another pass and try these again.\n    deferred_nodes: List[DeferredNode]\n    # Type checking pass number (0 = first pass)\n",
        "target_code_len": 1084,
        "diff_format": "@@ -156,29 +156,29 @@\n     # Error message reporter\n-    errors = None  # type: Errors\n+    errors: Errors\n     # Utility for generating messages\n-    msg = None  # type: MessageBuilder\n+    msg: MessageBuilder\n     # Types of type checked nodes\n-    type_map = None  # type: Dict[Expression, Type]\n+    type_map: Dict[Expression, Type]\n \n     # Helper for managing conditional types\n-    binder = None  # type: ConditionalTypeBinder\n+    binder: ConditionalTypeBinder\n     # Helper for type checking expressions\n-    expr_checker = None  # type: mypy.checkexpr.ExpressionChecker\n-\n-    tscope = None  # type: Scope\n-    scope = None  # type: CheckerScope\n+    expr_checker: mypy.checkexpr.ExpressionChecker\n+\n+    tscope: Scope\n+    scope: \"CheckerScope\"\n     # Stack of function return types\n-    return_types = None  # type: List[Type]\n+    return_types: List[Type]\n     # Flags; true for dynamically typed functions\n-    dynamic_funcs = None  # type: List[bool]\n+    dynamic_funcs: List[bool]\n     # Stack of collections of variables with partial types\n-    partial_types = None  # type: List[PartialTypeScope]\n+    partial_types: List[PartialTypeScope]\n     # Vars for which partial type errors are already reported\n     # (to avoid logically duplicate errors with different error context).\n-    partial_reported = None  # type: Set[Var]\n-    globals = None  # type: SymbolTable\n-    modules = None  # type: Dict[str, MypyFile]\n+    partial_reported: Set[Var]\n+    globals: SymbolTable\n+    modules: Dict[str, MypyFile]\n     # Nodes that couldn't be checked because some types weren't available. We'll run\n     # another pass and try these again.\n-    deferred_nodes = None  # type: List[DeferredNode]\n+    deferred_nodes: List[DeferredNode]\n     # Type checking pass number (0 = first pass)\n",
        "source_code_with_indent": "    # Error message reporter\n    errors = None  # type: Errors\n    # Utility for generating messages\n    msg = None  # type: MessageBuilder\n    # Types of type checked nodes\n    type_map = None  # type: Dict[Expression, Type]\n\n    # Helper for managing conditional types\n    binder = None  # type: ConditionalTypeBinder\n    # Helper for type checking expressions\n    expr_checker = None  # type: mypy.checkexpr.ExpressionChecker\n\n    tscope = None  # type: Scope\n    scope = None  # type: CheckerScope\n    # Stack of function return types\n    return_types = None  # type: List[Type]\n    # Flags; true for dynamically typed functions\n    dynamic_funcs = None  # type: List[bool]\n    # Stack of collections of variables with partial types\n    partial_types = None  # type: List[PartialTypeScope]\n    # Vars for which partial type errors are already reported\n    # (to avoid logically duplicate errors with different error context).\n    partial_reported = None  # type: Set[Var]\n    globals = None  # type: SymbolTable\n    modules = None  # type: Dict[str, MypyFile]\n    # Nodes that couldn't be checked because some types weren't available. We'll run\n    # another pass and try these again.\n    deferred_nodes = None  # type: List[DeferredNode]\n    # Type checking pass number (0 = first pass)\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    # Error message reporter\n    errors: Errors\n    # Utility for generating messages\n    msg: MessageBuilder\n    # Types of type checked nodes\n    type_map: Dict[Expression, Type]\n\n    # Helper for managing conditional types\n    binder: ConditionalTypeBinder\n    # Helper for type checking expressions\n    expr_checker: mypy.checkexpr.ExpressionChecker\n\n    tscope: Scope\n    scope: \"CheckerScope\"\n    # Stack of function return types\n    return_types: List[Type]\n    # Flags; true for dynamically typed functions\n    dynamic_funcs: List[bool]\n    # Stack of collections of variables with partial types\n    partial_types: List[PartialTypeScope]\n    # Vars for which partial type errors are already reported\n    # (to avoid logically duplicate errors with different error context).\n    partial_reported: Set[Var]\n    globals: SymbolTable\n    modules: Dict[str, MypyFile]\n    # Nodes that couldn't be checked because some types weren't available. We'll run\n    # another pass and try these again.\n    deferred_nodes: List[DeferredNode]\n    # Type checking pass number (0 = first pass)\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "python/mypy",
    "commit": "f98f78216ba9d6ab68c8e69c19e9f3c7926c5efe",
    "filename": "mypy/checker.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/python-mypy/mypy/checker.py",
    "file_hunks_size": 47,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "mypy/checker.py:178:4 Incompatible attribute type [8]: Attribute `partial_reported` declared in class `TypeChecker` has type `Set[Var]` but is used as type `None`.",
    "message": " Attribute `partial_reported` declared in class `TypeChecker` has type `Set[Var]` but is used as type `None`.",
    "rule_id": "Incompatible attribute type [8]",
    "warning_line_no": 178,
    "warning_line": "    partial_reported = None  # type: Set[Var]",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    # Error message reporter\n    errors = None  # type: Errors\n    # Utility for generating messages\n    msg = None  # type: MessageBuilder\n    # Types of type checked nodes\n    type_map = None  # type: Dict[Expression, Type]\n\n    # Helper for managing conditional types\n    binder = None  # type: ConditionalTypeBinder\n    # Helper for type checking expressions\n    expr_checker = None  # type: mypy.checkexpr.ExpressionChecker\n\n    tscope = None  # type: Scope\n    scope = None  # type: CheckerScope\n    # Stack of function return types\n    return_types = None  # type: List[Type]\n    # Flags; true for dynamically typed functions\n    dynamic_funcs = None  # type: List[bool]\n    # Stack of collections of variables with partial types\n    partial_types = None  # type: List[PartialTypeScope]\n    # Vars for which partial type errors are already reported\n    # (to avoid logically duplicate errors with different error context).\n    partial_reported = None  # type: Set[Var]\n    globals = None  # type: SymbolTable\n    modules = None  # type: Dict[str, MypyFile]\n    # Nodes that couldn't be checked because some types weren't available. We'll run\n    # another pass and try these again.\n    deferred_nodes = None  # type: List[DeferredNode]\n    # Type checking pass number (0 = first pass)\n",
        "source_code_len": 1292,
        "target_code": "    # Error message reporter\n    errors: Errors\n    # Utility for generating messages\n    msg: MessageBuilder\n    # Types of type checked nodes\n    type_map: Dict[Expression, Type]\n\n    # Helper for managing conditional types\n    binder: ConditionalTypeBinder\n    # Helper for type checking expressions\n    expr_checker: mypy.checkexpr.ExpressionChecker\n\n    tscope: Scope\n    scope: \"CheckerScope\"\n    # Stack of function return types\n    return_types: List[Type]\n    # Flags; true for dynamically typed functions\n    dynamic_funcs: List[bool]\n    # Stack of collections of variables with partial types\n    partial_types: List[PartialTypeScope]\n    # Vars for which partial type errors are already reported\n    # (to avoid logically duplicate errors with different error context).\n    partial_reported: Set[Var]\n    globals: SymbolTable\n    modules: Dict[str, MypyFile]\n    # Nodes that couldn't be checked because some types weren't available. We'll run\n    # another pass and try these again.\n    deferred_nodes: List[DeferredNode]\n    # Type checking pass number (0 = first pass)\n",
        "target_code_len": 1084,
        "diff_format": "@@ -156,29 +156,29 @@\n     # Error message reporter\n-    errors = None  # type: Errors\n+    errors: Errors\n     # Utility for generating messages\n-    msg = None  # type: MessageBuilder\n+    msg: MessageBuilder\n     # Types of type checked nodes\n-    type_map = None  # type: Dict[Expression, Type]\n+    type_map: Dict[Expression, Type]\n \n     # Helper for managing conditional types\n-    binder = None  # type: ConditionalTypeBinder\n+    binder: ConditionalTypeBinder\n     # Helper for type checking expressions\n-    expr_checker = None  # type: mypy.checkexpr.ExpressionChecker\n-\n-    tscope = None  # type: Scope\n-    scope = None  # type: CheckerScope\n+    expr_checker: mypy.checkexpr.ExpressionChecker\n+\n+    tscope: Scope\n+    scope: \"CheckerScope\"\n     # Stack of function return types\n-    return_types = None  # type: List[Type]\n+    return_types: List[Type]\n     # Flags; true for dynamically typed functions\n-    dynamic_funcs = None  # type: List[bool]\n+    dynamic_funcs: List[bool]\n     # Stack of collections of variables with partial types\n-    partial_types = None  # type: List[PartialTypeScope]\n+    partial_types: List[PartialTypeScope]\n     # Vars for which partial type errors are already reported\n     # (to avoid logically duplicate errors with different error context).\n-    partial_reported = None  # type: Set[Var]\n-    globals = None  # type: SymbolTable\n-    modules = None  # type: Dict[str, MypyFile]\n+    partial_reported: Set[Var]\n+    globals: SymbolTable\n+    modules: Dict[str, MypyFile]\n     # Nodes that couldn't be checked because some types weren't available. We'll run\n     # another pass and try these again.\n-    deferred_nodes = None  # type: List[DeferredNode]\n+    deferred_nodes: List[DeferredNode]\n     # Type checking pass number (0 = first pass)\n",
        "source_code_with_indent": "    # Error message reporter\n    errors = None  # type: Errors\n    # Utility for generating messages\n    msg = None  # type: MessageBuilder\n    # Types of type checked nodes\n    type_map = None  # type: Dict[Expression, Type]\n\n    # Helper for managing conditional types\n    binder = None  # type: ConditionalTypeBinder\n    # Helper for type checking expressions\n    expr_checker = None  # type: mypy.checkexpr.ExpressionChecker\n\n    tscope = None  # type: Scope\n    scope = None  # type: CheckerScope\n    # Stack of function return types\n    return_types = None  # type: List[Type]\n    # Flags; true for dynamically typed functions\n    dynamic_funcs = None  # type: List[bool]\n    # Stack of collections of variables with partial types\n    partial_types = None  # type: List[PartialTypeScope]\n    # Vars for which partial type errors are already reported\n    # (to avoid logically duplicate errors with different error context).\n    partial_reported = None  # type: Set[Var]\n    globals = None  # type: SymbolTable\n    modules = None  # type: Dict[str, MypyFile]\n    # Nodes that couldn't be checked because some types weren't available. We'll run\n    # another pass and try these again.\n    deferred_nodes = None  # type: List[DeferredNode]\n    # Type checking pass number (0 = first pass)\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    # Error message reporter\n    errors: Errors\n    # Utility for generating messages\n    msg: MessageBuilder\n    # Types of type checked nodes\n    type_map: Dict[Expression, Type]\n\n    # Helper for managing conditional types\n    binder: ConditionalTypeBinder\n    # Helper for type checking expressions\n    expr_checker: mypy.checkexpr.ExpressionChecker\n\n    tscope: Scope\n    scope: \"CheckerScope\"\n    # Stack of function return types\n    return_types: List[Type]\n    # Flags; true for dynamically typed functions\n    dynamic_funcs: List[bool]\n    # Stack of collections of variables with partial types\n    partial_types: List[PartialTypeScope]\n    # Vars for which partial type errors are already reported\n    # (to avoid logically duplicate errors with different error context).\n    partial_reported: Set[Var]\n    globals: SymbolTable\n    modules: Dict[str, MypyFile]\n    # Nodes that couldn't be checked because some types weren't available. We'll run\n    # another pass and try these again.\n    deferred_nodes: List[DeferredNode]\n    # Type checking pass number (0 = first pass)\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "python/mypy",
    "commit": "f98f78216ba9d6ab68c8e69c19e9f3c7926c5efe",
    "filename": "mypy/checker.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/python-mypy/mypy/checker.py",
    "file_hunks_size": 47,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "mypy/checker.py:179:4 Incompatible attribute type [8]: Attribute `globals` declared in class `TypeChecker` has type `SymbolTable` but is used as type `None`.",
    "message": " Attribute `globals` declared in class `TypeChecker` has type `SymbolTable` but is used as type `None`.",
    "rule_id": "Incompatible attribute type [8]",
    "warning_line_no": 179,
    "warning_line": "    globals = None  # type: SymbolTable",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    # Error message reporter\n    errors = None  # type: Errors\n    # Utility for generating messages\n    msg = None  # type: MessageBuilder\n    # Types of type checked nodes\n    type_map = None  # type: Dict[Expression, Type]\n\n    # Helper for managing conditional types\n    binder = None  # type: ConditionalTypeBinder\n    # Helper for type checking expressions\n    expr_checker = None  # type: mypy.checkexpr.ExpressionChecker\n\n    tscope = None  # type: Scope\n    scope = None  # type: CheckerScope\n    # Stack of function return types\n    return_types = None  # type: List[Type]\n    # Flags; true for dynamically typed functions\n    dynamic_funcs = None  # type: List[bool]\n    # Stack of collections of variables with partial types\n    partial_types = None  # type: List[PartialTypeScope]\n    # Vars for which partial type errors are already reported\n    # (to avoid logically duplicate errors with different error context).\n    partial_reported = None  # type: Set[Var]\n    globals = None  # type: SymbolTable\n    modules = None  # type: Dict[str, MypyFile]\n    # Nodes that couldn't be checked because some types weren't available. We'll run\n    # another pass and try these again.\n    deferred_nodes = None  # type: List[DeferredNode]\n    # Type checking pass number (0 = first pass)\n",
        "source_code_len": 1292,
        "target_code": "    # Error message reporter\n    errors: Errors\n    # Utility for generating messages\n    msg: MessageBuilder\n    # Types of type checked nodes\n    type_map: Dict[Expression, Type]\n\n    # Helper for managing conditional types\n    binder: ConditionalTypeBinder\n    # Helper for type checking expressions\n    expr_checker: mypy.checkexpr.ExpressionChecker\n\n    tscope: Scope\n    scope: \"CheckerScope\"\n    # Stack of function return types\n    return_types: List[Type]\n    # Flags; true for dynamically typed functions\n    dynamic_funcs: List[bool]\n    # Stack of collections of variables with partial types\n    partial_types: List[PartialTypeScope]\n    # Vars for which partial type errors are already reported\n    # (to avoid logically duplicate errors with different error context).\n    partial_reported: Set[Var]\n    globals: SymbolTable\n    modules: Dict[str, MypyFile]\n    # Nodes that couldn't be checked because some types weren't available. We'll run\n    # another pass and try these again.\n    deferred_nodes: List[DeferredNode]\n    # Type checking pass number (0 = first pass)\n",
        "target_code_len": 1084,
        "diff_format": "@@ -156,29 +156,29 @@\n     # Error message reporter\n-    errors = None  # type: Errors\n+    errors: Errors\n     # Utility for generating messages\n-    msg = None  # type: MessageBuilder\n+    msg: MessageBuilder\n     # Types of type checked nodes\n-    type_map = None  # type: Dict[Expression, Type]\n+    type_map: Dict[Expression, Type]\n \n     # Helper for managing conditional types\n-    binder = None  # type: ConditionalTypeBinder\n+    binder: ConditionalTypeBinder\n     # Helper for type checking expressions\n-    expr_checker = None  # type: mypy.checkexpr.ExpressionChecker\n-\n-    tscope = None  # type: Scope\n-    scope = None  # type: CheckerScope\n+    expr_checker: mypy.checkexpr.ExpressionChecker\n+\n+    tscope: Scope\n+    scope: \"CheckerScope\"\n     # Stack of function return types\n-    return_types = None  # type: List[Type]\n+    return_types: List[Type]\n     # Flags; true for dynamically typed functions\n-    dynamic_funcs = None  # type: List[bool]\n+    dynamic_funcs: List[bool]\n     # Stack of collections of variables with partial types\n-    partial_types = None  # type: List[PartialTypeScope]\n+    partial_types: List[PartialTypeScope]\n     # Vars for which partial type errors are already reported\n     # (to avoid logically duplicate errors with different error context).\n-    partial_reported = None  # type: Set[Var]\n-    globals = None  # type: SymbolTable\n-    modules = None  # type: Dict[str, MypyFile]\n+    partial_reported: Set[Var]\n+    globals: SymbolTable\n+    modules: Dict[str, MypyFile]\n     # Nodes that couldn't be checked because some types weren't available. We'll run\n     # another pass and try these again.\n-    deferred_nodes = None  # type: List[DeferredNode]\n+    deferred_nodes: List[DeferredNode]\n     # Type checking pass number (0 = first pass)\n",
        "source_code_with_indent": "    # Error message reporter\n    errors = None  # type: Errors\n    # Utility for generating messages\n    msg = None  # type: MessageBuilder\n    # Types of type checked nodes\n    type_map = None  # type: Dict[Expression, Type]\n\n    # Helper for managing conditional types\n    binder = None  # type: ConditionalTypeBinder\n    # Helper for type checking expressions\n    expr_checker = None  # type: mypy.checkexpr.ExpressionChecker\n\n    tscope = None  # type: Scope\n    scope = None  # type: CheckerScope\n    # Stack of function return types\n    return_types = None  # type: List[Type]\n    # Flags; true for dynamically typed functions\n    dynamic_funcs = None  # type: List[bool]\n    # Stack of collections of variables with partial types\n    partial_types = None  # type: List[PartialTypeScope]\n    # Vars for which partial type errors are already reported\n    # (to avoid logically duplicate errors with different error context).\n    partial_reported = None  # type: Set[Var]\n    globals = None  # type: SymbolTable\n    modules = None  # type: Dict[str, MypyFile]\n    # Nodes that couldn't be checked because some types weren't available. We'll run\n    # another pass and try these again.\n    deferred_nodes = None  # type: List[DeferredNode]\n    # Type checking pass number (0 = first pass)\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    # Error message reporter\n    errors: Errors\n    # Utility for generating messages\n    msg: MessageBuilder\n    # Types of type checked nodes\n    type_map: Dict[Expression, Type]\n\n    # Helper for managing conditional types\n    binder: ConditionalTypeBinder\n    # Helper for type checking expressions\n    expr_checker: mypy.checkexpr.ExpressionChecker\n\n    tscope: Scope\n    scope: \"CheckerScope\"\n    # Stack of function return types\n    return_types: List[Type]\n    # Flags; true for dynamically typed functions\n    dynamic_funcs: List[bool]\n    # Stack of collections of variables with partial types\n    partial_types: List[PartialTypeScope]\n    # Vars for which partial type errors are already reported\n    # (to avoid logically duplicate errors with different error context).\n    partial_reported: Set[Var]\n    globals: SymbolTable\n    modules: Dict[str, MypyFile]\n    # Nodes that couldn't be checked because some types weren't available. We'll run\n    # another pass and try these again.\n    deferred_nodes: List[DeferredNode]\n    # Type checking pass number (0 = first pass)\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "python/mypy",
    "commit": "f98f78216ba9d6ab68c8e69c19e9f3c7926c5efe",
    "filename": "mypy/checker.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/python-mypy/mypy/checker.py",
    "file_hunks_size": 47,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "mypy/checker.py:180:4 Incompatible attribute type [8]: Attribute `modules` declared in class `TypeChecker` has type `Dict[str, MypyFile]` but is used as type `None`.",
    "message": " Attribute `modules` declared in class `TypeChecker` has type `Dict[str, MypyFile]` but is used as type `None`.",
    "rule_id": "Incompatible attribute type [8]",
    "warning_line_no": 180,
    "warning_line": "    modules = None  # type: Dict[str, MypyFile]",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    # Error message reporter\n    errors = None  # type: Errors\n    # Utility for generating messages\n    msg = None  # type: MessageBuilder\n    # Types of type checked nodes\n    type_map = None  # type: Dict[Expression, Type]\n\n    # Helper for managing conditional types\n    binder = None  # type: ConditionalTypeBinder\n    # Helper for type checking expressions\n    expr_checker = None  # type: mypy.checkexpr.ExpressionChecker\n\n    tscope = None  # type: Scope\n    scope = None  # type: CheckerScope\n    # Stack of function return types\n    return_types = None  # type: List[Type]\n    # Flags; true for dynamically typed functions\n    dynamic_funcs = None  # type: List[bool]\n    # Stack of collections of variables with partial types\n    partial_types = None  # type: List[PartialTypeScope]\n    # Vars for which partial type errors are already reported\n    # (to avoid logically duplicate errors with different error context).\n    partial_reported = None  # type: Set[Var]\n    globals = None  # type: SymbolTable\n    modules = None  # type: Dict[str, MypyFile]\n    # Nodes that couldn't be checked because some types weren't available. We'll run\n    # another pass and try these again.\n    deferred_nodes = None  # type: List[DeferredNode]\n    # Type checking pass number (0 = first pass)\n",
        "source_code_len": 1292,
        "target_code": "    # Error message reporter\n    errors: Errors\n    # Utility for generating messages\n    msg: MessageBuilder\n    # Types of type checked nodes\n    type_map: Dict[Expression, Type]\n\n    # Helper for managing conditional types\n    binder: ConditionalTypeBinder\n    # Helper for type checking expressions\n    expr_checker: mypy.checkexpr.ExpressionChecker\n\n    tscope: Scope\n    scope: \"CheckerScope\"\n    # Stack of function return types\n    return_types: List[Type]\n    # Flags; true for dynamically typed functions\n    dynamic_funcs: List[bool]\n    # Stack of collections of variables with partial types\n    partial_types: List[PartialTypeScope]\n    # Vars for which partial type errors are already reported\n    # (to avoid logically duplicate errors with different error context).\n    partial_reported: Set[Var]\n    globals: SymbolTable\n    modules: Dict[str, MypyFile]\n    # Nodes that couldn't be checked because some types weren't available. We'll run\n    # another pass and try these again.\n    deferred_nodes: List[DeferredNode]\n    # Type checking pass number (0 = first pass)\n",
        "target_code_len": 1084,
        "diff_format": "@@ -156,29 +156,29 @@\n     # Error message reporter\n-    errors = None  # type: Errors\n+    errors: Errors\n     # Utility for generating messages\n-    msg = None  # type: MessageBuilder\n+    msg: MessageBuilder\n     # Types of type checked nodes\n-    type_map = None  # type: Dict[Expression, Type]\n+    type_map: Dict[Expression, Type]\n \n     # Helper for managing conditional types\n-    binder = None  # type: ConditionalTypeBinder\n+    binder: ConditionalTypeBinder\n     # Helper for type checking expressions\n-    expr_checker = None  # type: mypy.checkexpr.ExpressionChecker\n-\n-    tscope = None  # type: Scope\n-    scope = None  # type: CheckerScope\n+    expr_checker: mypy.checkexpr.ExpressionChecker\n+\n+    tscope: Scope\n+    scope: \"CheckerScope\"\n     # Stack of function return types\n-    return_types = None  # type: List[Type]\n+    return_types: List[Type]\n     # Flags; true for dynamically typed functions\n-    dynamic_funcs = None  # type: List[bool]\n+    dynamic_funcs: List[bool]\n     # Stack of collections of variables with partial types\n-    partial_types = None  # type: List[PartialTypeScope]\n+    partial_types: List[PartialTypeScope]\n     # Vars for which partial type errors are already reported\n     # (to avoid logically duplicate errors with different error context).\n-    partial_reported = None  # type: Set[Var]\n-    globals = None  # type: SymbolTable\n-    modules = None  # type: Dict[str, MypyFile]\n+    partial_reported: Set[Var]\n+    globals: SymbolTable\n+    modules: Dict[str, MypyFile]\n     # Nodes that couldn't be checked because some types weren't available. We'll run\n     # another pass and try these again.\n-    deferred_nodes = None  # type: List[DeferredNode]\n+    deferred_nodes: List[DeferredNode]\n     # Type checking pass number (0 = first pass)\n",
        "source_code_with_indent": "    # Error message reporter\n    errors = None  # type: Errors\n    # Utility for generating messages\n    msg = None  # type: MessageBuilder\n    # Types of type checked nodes\n    type_map = None  # type: Dict[Expression, Type]\n\n    # Helper for managing conditional types\n    binder = None  # type: ConditionalTypeBinder\n    # Helper for type checking expressions\n    expr_checker = None  # type: mypy.checkexpr.ExpressionChecker\n\n    tscope = None  # type: Scope\n    scope = None  # type: CheckerScope\n    # Stack of function return types\n    return_types = None  # type: List[Type]\n    # Flags; true for dynamically typed functions\n    dynamic_funcs = None  # type: List[bool]\n    # Stack of collections of variables with partial types\n    partial_types = None  # type: List[PartialTypeScope]\n    # Vars for which partial type errors are already reported\n    # (to avoid logically duplicate errors with different error context).\n    partial_reported = None  # type: Set[Var]\n    globals = None  # type: SymbolTable\n    modules = None  # type: Dict[str, MypyFile]\n    # Nodes that couldn't be checked because some types weren't available. We'll run\n    # another pass and try these again.\n    deferred_nodes = None  # type: List[DeferredNode]\n    # Type checking pass number (0 = first pass)\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    # Error message reporter\n    errors: Errors\n    # Utility for generating messages\n    msg: MessageBuilder\n    # Types of type checked nodes\n    type_map: Dict[Expression, Type]\n\n    # Helper for managing conditional types\n    binder: ConditionalTypeBinder\n    # Helper for type checking expressions\n    expr_checker: mypy.checkexpr.ExpressionChecker\n\n    tscope: Scope\n    scope: \"CheckerScope\"\n    # Stack of function return types\n    return_types: List[Type]\n    # Flags; true for dynamically typed functions\n    dynamic_funcs: List[bool]\n    # Stack of collections of variables with partial types\n    partial_types: List[PartialTypeScope]\n    # Vars for which partial type errors are already reported\n    # (to avoid logically duplicate errors with different error context).\n    partial_reported: Set[Var]\n    globals: SymbolTable\n    modules: Dict[str, MypyFile]\n    # Nodes that couldn't be checked because some types weren't available. We'll run\n    # another pass and try these again.\n    deferred_nodes: List[DeferredNode]\n    # Type checking pass number (0 = first pass)\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "python/mypy",
    "commit": "f98f78216ba9d6ab68c8e69c19e9f3c7926c5efe",
    "filename": "mypy/checker.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/python-mypy/mypy/checker.py",
    "file_hunks_size": 47,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "mypy/checker.py:183:4 Incompatible attribute type [8]: Attribute `deferred_nodes` declared in class `TypeChecker` has type `List[DeferredNode]` but is used as type `None`.",
    "message": " Attribute `deferred_nodes` declared in class `TypeChecker` has type `List[DeferredNode]` but is used as type `None`.",
    "rule_id": "Incompatible attribute type [8]",
    "warning_line_no": 183,
    "warning_line": "    deferred_nodes = None  # type: List[DeferredNode]",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    # Error message reporter\n    errors = None  # type: Errors\n    # Utility for generating messages\n    msg = None  # type: MessageBuilder\n    # Types of type checked nodes\n    type_map = None  # type: Dict[Expression, Type]\n\n    # Helper for managing conditional types\n    binder = None  # type: ConditionalTypeBinder\n    # Helper for type checking expressions\n    expr_checker = None  # type: mypy.checkexpr.ExpressionChecker\n\n    tscope = None  # type: Scope\n    scope = None  # type: CheckerScope\n    # Stack of function return types\n    return_types = None  # type: List[Type]\n    # Flags; true for dynamically typed functions\n    dynamic_funcs = None  # type: List[bool]\n    # Stack of collections of variables with partial types\n    partial_types = None  # type: List[PartialTypeScope]\n    # Vars for which partial type errors are already reported\n    # (to avoid logically duplicate errors with different error context).\n    partial_reported = None  # type: Set[Var]\n    globals = None  # type: SymbolTable\n    modules = None  # type: Dict[str, MypyFile]\n    # Nodes that couldn't be checked because some types weren't available. We'll run\n    # another pass and try these again.\n    deferred_nodes = None  # type: List[DeferredNode]\n    # Type checking pass number (0 = first pass)\n",
        "source_code_len": 1292,
        "target_code": "    # Error message reporter\n    errors: Errors\n    # Utility for generating messages\n    msg: MessageBuilder\n    # Types of type checked nodes\n    type_map: Dict[Expression, Type]\n\n    # Helper for managing conditional types\n    binder: ConditionalTypeBinder\n    # Helper for type checking expressions\n    expr_checker: mypy.checkexpr.ExpressionChecker\n\n    tscope: Scope\n    scope: \"CheckerScope\"\n    # Stack of function return types\n    return_types: List[Type]\n    # Flags; true for dynamically typed functions\n    dynamic_funcs: List[bool]\n    # Stack of collections of variables with partial types\n    partial_types: List[PartialTypeScope]\n    # Vars for which partial type errors are already reported\n    # (to avoid logically duplicate errors with different error context).\n    partial_reported: Set[Var]\n    globals: SymbolTable\n    modules: Dict[str, MypyFile]\n    # Nodes that couldn't be checked because some types weren't available. We'll run\n    # another pass and try these again.\n    deferred_nodes: List[DeferredNode]\n    # Type checking pass number (0 = first pass)\n",
        "target_code_len": 1084,
        "diff_format": "@@ -156,29 +156,29 @@\n     # Error message reporter\n-    errors = None  # type: Errors\n+    errors: Errors\n     # Utility for generating messages\n-    msg = None  # type: MessageBuilder\n+    msg: MessageBuilder\n     # Types of type checked nodes\n-    type_map = None  # type: Dict[Expression, Type]\n+    type_map: Dict[Expression, Type]\n \n     # Helper for managing conditional types\n-    binder = None  # type: ConditionalTypeBinder\n+    binder: ConditionalTypeBinder\n     # Helper for type checking expressions\n-    expr_checker = None  # type: mypy.checkexpr.ExpressionChecker\n-\n-    tscope = None  # type: Scope\n-    scope = None  # type: CheckerScope\n+    expr_checker: mypy.checkexpr.ExpressionChecker\n+\n+    tscope: Scope\n+    scope: \"CheckerScope\"\n     # Stack of function return types\n-    return_types = None  # type: List[Type]\n+    return_types: List[Type]\n     # Flags; true for dynamically typed functions\n-    dynamic_funcs = None  # type: List[bool]\n+    dynamic_funcs: List[bool]\n     # Stack of collections of variables with partial types\n-    partial_types = None  # type: List[PartialTypeScope]\n+    partial_types: List[PartialTypeScope]\n     # Vars for which partial type errors are already reported\n     # (to avoid logically duplicate errors with different error context).\n-    partial_reported = None  # type: Set[Var]\n-    globals = None  # type: SymbolTable\n-    modules = None  # type: Dict[str, MypyFile]\n+    partial_reported: Set[Var]\n+    globals: SymbolTable\n+    modules: Dict[str, MypyFile]\n     # Nodes that couldn't be checked because some types weren't available. We'll run\n     # another pass and try these again.\n-    deferred_nodes = None  # type: List[DeferredNode]\n+    deferred_nodes: List[DeferredNode]\n     # Type checking pass number (0 = first pass)\n",
        "source_code_with_indent": "    # Error message reporter\n    errors = None  # type: Errors\n    # Utility for generating messages\n    msg = None  # type: MessageBuilder\n    # Types of type checked nodes\n    type_map = None  # type: Dict[Expression, Type]\n\n    # Helper for managing conditional types\n    binder = None  # type: ConditionalTypeBinder\n    # Helper for type checking expressions\n    expr_checker = None  # type: mypy.checkexpr.ExpressionChecker\n\n    tscope = None  # type: Scope\n    scope = None  # type: CheckerScope\n    # Stack of function return types\n    return_types = None  # type: List[Type]\n    # Flags; true for dynamically typed functions\n    dynamic_funcs = None  # type: List[bool]\n    # Stack of collections of variables with partial types\n    partial_types = None  # type: List[PartialTypeScope]\n    # Vars for which partial type errors are already reported\n    # (to avoid logically duplicate errors with different error context).\n    partial_reported = None  # type: Set[Var]\n    globals = None  # type: SymbolTable\n    modules = None  # type: Dict[str, MypyFile]\n    # Nodes that couldn't be checked because some types weren't available. We'll run\n    # another pass and try these again.\n    deferred_nodes = None  # type: List[DeferredNode]\n    # Type checking pass number (0 = first pass)\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    # Error message reporter\n    errors: Errors\n    # Utility for generating messages\n    msg: MessageBuilder\n    # Types of type checked nodes\n    type_map: Dict[Expression, Type]\n\n    # Helper for managing conditional types\n    binder: ConditionalTypeBinder\n    # Helper for type checking expressions\n    expr_checker: mypy.checkexpr.ExpressionChecker\n\n    tscope: Scope\n    scope: \"CheckerScope\"\n    # Stack of function return types\n    return_types: List[Type]\n    # Flags; true for dynamically typed functions\n    dynamic_funcs: List[bool]\n    # Stack of collections of variables with partial types\n    partial_types: List[PartialTypeScope]\n    # Vars for which partial type errors are already reported\n    # (to avoid logically duplicate errors with different error context).\n    partial_reported: Set[Var]\n    globals: SymbolTable\n    modules: Dict[str, MypyFile]\n    # Nodes that couldn't be checked because some types weren't available. We'll run\n    # another pass and try these again.\n    deferred_nodes: List[DeferredNode]\n    # Type checking pass number (0 = first pass)\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "python/mypy",
    "commit": "f98f78216ba9d6ab68c8e69c19e9f3c7926c5efe",
    "filename": "mypy/checker.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/python-mypy/mypy/checker.py",
    "file_hunks_size": 47,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": true,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "mypy/checker.py:195:4 Incompatible attribute type [8]: Attribute `options` declared in class `TypeChecker` has type `Options` but is used as type `None`.",
    "message": " Attribute `options` declared in class `TypeChecker` has type `Options` but is used as type `None`.",
    "rule_id": "Incompatible attribute type [8]",
    "warning_line_no": 195,
    "warning_line": "    options = None  # type: Options",
    "min_patch": [
      {
        "hunk_fit_TFix": true,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    suppress_none_errors = False  # TODO: Get it from options instead\n    options = None  # type: Options\n    # Used for collecting inferred attribute types so that they can be checked\n    # for consistency.\n    inferred_attribute_types = None  # type: Optional[Dict[Var, Type]]\n    # Don't infer partial None types if we are processing assignment from Union\n    no_partial_types = False  # type: bool\n\n",
        "source_code_len": 403,
        "target_code": "    suppress_none_errors = False  # TODO: Get it from options instead\n    options: Options\n    # Used for collecting inferred attribute types so that they can be checked\n    # for consistency.\n    inferred_attribute_types: Optional[Dict[Var, Type]] = None\n    # Don't infer partial None types if we are processing assignment from Union\n    no_partial_types: bool = False\n\n",
        "target_code_len": 372,
        "diff_format": "@@ -194,8 +194,8 @@\n     suppress_none_errors = False  # TODO: Get it from options instead\n-    options = None  # type: Options\n+    options: Options\n     # Used for collecting inferred attribute types so that they can be checked\n     # for consistency.\n-    inferred_attribute_types = None  # type: Optional[Dict[Var, Type]]\n+    inferred_attribute_types: Optional[Dict[Var, Type]] = None\n     # Don't infer partial None types if we are processing assignment from Union\n-    no_partial_types = False  # type: bool\n+    no_partial_types: bool = False\n \n",
        "source_code_with_indent": "    suppress_none_errors = False  # TODO: Get it from options instead\n    options = None  # type: Options\n    # Used for collecting inferred attribute types so that they can be checked\n    # for consistency.\n    inferred_attribute_types = None  # type: Optional[Dict[Var, Type]]\n    # Don't infer partial None types if we are processing assignment from Union\n    no_partial_types = False  # type: bool\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    suppress_none_errors = False  # TODO: Get it from options instead\n    options: Options\n    # Used for collecting inferred attribute types so that they can be checked\n    # for consistency.\n    inferred_attribute_types: Optional[Dict[Var, Type]] = None\n    # Don't infer partial None types if we are processing assignment from Union\n    no_partial_types: bool = False\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "python/mypy",
    "commit": "f98f78216ba9d6ab68c8e69c19e9f3c7926c5efe",
    "filename": "mypy/checker.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/python-mypy/mypy/checker.py",
    "file_hunks_size": 47,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": true,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "mypy/checker.py:204:4 Incompatible attribute type [8]: Attribute `module_refs` declared in class `TypeChecker` has type `Set[str]` but is used as type `None`.",
    "message": " Attribute `module_refs` declared in class `TypeChecker` has type `Set[str]` but is used as type `None`.",
    "rule_id": "Incompatible attribute type [8]",
    "warning_line_no": 204,
    "warning_line": "    module_refs = None  # type: Set[str]",
    "min_patch": [
      {
        "hunk_fit_TFix": true,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    # directly or indirectly.\n    module_refs = None  # type: Set[str]\n\n",
        "source_code_len": 72,
        "target_code": "    # directly or indirectly.\n    module_refs: Set[str]\n\n",
        "target_code_len": 57,
        "diff_format": "@@ -203,3 +203,3 @@\n     # directly or indirectly.\n-    module_refs = None  # type: Set[str]\n+    module_refs: Set[str]\n \n",
        "source_code_with_indent": "    # directly or indirectly.\n    module_refs = None  # type: Set[str]\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    # directly or indirectly.\n    module_refs: Set[str]\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "python/mypy",
    "commit": "f98f78216ba9d6ab68c8e69c19e9f3c7926c5efe",
    "filename": "mypy/checker.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/python-mypy/mypy/checker.py",
    "file_hunks_size": 47,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": true,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "mypy/checker.py:208:4 Incompatible attribute type [8]: Attribute `plugin` declared in class `TypeChecker` has type `Plugin` but is used as type `None`.",
    "message": " Attribute `plugin` declared in class `TypeChecker` has type `Plugin` but is used as type `None`.",
    "rule_id": "Incompatible attribute type [8]",
    "warning_line_no": 208,
    "warning_line": "    plugin = None  # type: Plugin",
    "min_patch": [
      {
        "hunk_fit_TFix": true,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    # functions such as open(), etc.\n    plugin = None  # type: Plugin\n\n",
        "source_code_len": 72,
        "target_code": "    # functions such as open(), etc.\n    plugin: Plugin\n\n",
        "target_code_len": 57,
        "diff_format": "@@ -207,3 +207,3 @@\n     # functions such as open(), etc.\n-    plugin = None  # type: Plugin\n+    plugin: Plugin\n \n",
        "source_code_with_indent": "    # functions such as open(), etc.\n    plugin = None  # type: Plugin\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    # functions such as open(), etc.\n    plugin: Plugin\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "python/mypy",
    "commit": "f98f78216ba9d6ab68c8e69c19e9f3c7926c5efe",
    "filename": "mypy/checker.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/python-mypy/mypy/checker.py",
    "file_hunks_size": 47,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": true,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "mypy/checker.py:5603:4 Incompatible attribute type [8]: Attribute `stack` declared in class `CheckerScope` has type `List[Union[FuncItem, MypyFile, TypeInfo]]` but is used as type `None`.",
    "message": " Attribute `stack` declared in class `CheckerScope` has type `List[Union[FuncItem, MypyFile, TypeInfo]]` but is used as type `None`.",
    "rule_id": "Incompatible attribute type [8]",
    "warning_line_no": 5603,
    "warning_line": "    stack = None  # type: List[Union[TypeInfo, FuncItem, MypyFile]]",
    "min_patch": [
      {
        "hunk_fit_TFix": true,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    # We keep two stacks combined, to maintain the relative order\n    stack = None  # type: List[Union[TypeInfo, FuncItem, MypyFile]]\n\n",
        "source_code_len": 135,
        "target_code": "    # We keep two stacks combined, to maintain the relative order\n    stack: List[Union[TypeInfo, FuncItem, MypyFile]]\n\n",
        "target_code_len": 120,
        "diff_format": "@@ -5602,3 +5605,3 @@\n     # We keep two stacks combined, to maintain the relative order\n-    stack = None  # type: List[Union[TypeInfo, FuncItem, MypyFile]]\n+    stack: List[Union[TypeInfo, FuncItem, MypyFile]]\n \n",
        "source_code_with_indent": "    # We keep two stacks combined, to maintain the relative order\n    <IND>stack = None  # type: List[Union[TypeInfo, FuncItem, MypyFile]]\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    # We keep two stacks combined, to maintain the relative order\n    <IND>stack: List[Union[TypeInfo, FuncItem, MypyFile]]\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "python/mypy",
    "commit": "f98f78216ba9d6ab68c8e69c19e9f3c7926c5efe",
    "filename": "mypy/checkexpr.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/python-mypy/mypy/checkexpr.py",
    "file_hunks_size": 40,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "mypy/checkexpr.py:149:4 Incompatible attribute type [8]: Attribute `chk` declared in class `ExpressionChecker` has type `mypy.checker.TypeChecker` but is used as type `None`.",
    "message": " Attribute `chk` declared in class `ExpressionChecker` has type `mypy.checker.TypeChecker` but is used as type `None`.",
    "rule_id": "Incompatible attribute type [8]",
    "warning_line_no": 149,
    "warning_line": "    chk = None  # type: mypy.checker.TypeChecker",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    # Some services are provided by a TypeChecker instance.\n    chk = None  # type: mypy.checker.TypeChecker\n    # This is shared with TypeChecker, but stored also here for convenience.\n    msg = None  # type: MessageBuilder\n    # Type context for type inference\n    type_context = None  # type: List[Optional[Type]]\n\n    strfrm_checker = None  # type: StringFormatterChecker\n    plugin = None  # type: Plugin\n\n",
        "source_code_len": 411,
        "target_code": "    # Some services are provided by a TypeChecker instance.\n    chk: \"mypy.checker.TypeChecker\"\n    # This is shared with TypeChecker, but stored also here for convenience.\n    msg: MessageBuilder\n    # Type context for type inference\n    type_context: List[Optional[Type]]\n\n    strfrm_checker: StringFormatterChecker\n    plugin: Plugin\n\n",
        "target_code_len": 338,
        "diff_format": "@@ -148,10 +152,10 @@\n     # Some services are provided by a TypeChecker instance.\n-    chk = None  # type: mypy.checker.TypeChecker\n+    chk: \"mypy.checker.TypeChecker\"\n     # This is shared with TypeChecker, but stored also here for convenience.\n-    msg = None  # type: MessageBuilder\n+    msg: MessageBuilder\n     # Type context for type inference\n-    type_context = None  # type: List[Optional[Type]]\n-\n-    strfrm_checker = None  # type: StringFormatterChecker\n-    plugin = None  # type: Plugin\n+    type_context: List[Optional[Type]]\n+\n+    strfrm_checker: StringFormatterChecker\n+    plugin: Plugin\n \n",
        "source_code_with_indent": "    # Some services are provided by a TypeChecker instance.\n    chk = None  # type: mypy.checker.TypeChecker\n    # This is shared with TypeChecker, but stored also here for convenience.\n    msg = None  # type: MessageBuilder\n    # Type context for type inference\n    type_context = None  # type: List[Optional[Type]]\n\n    strfrm_checker = None  # type: StringFormatterChecker\n    plugin = None  # type: Plugin\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    # Some services are provided by a TypeChecker instance.\n    chk: \"mypy.checker.TypeChecker\"\n    # This is shared with TypeChecker, but stored also here for convenience.\n    msg: MessageBuilder\n    # Type context for type inference\n    type_context: List[Optional[Type]]\n\n    strfrm_checker: StringFormatterChecker\n    plugin: Plugin\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "python/mypy",
    "commit": "f98f78216ba9d6ab68c8e69c19e9f3c7926c5efe",
    "filename": "mypy/checkexpr.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/python-mypy/mypy/checkexpr.py",
    "file_hunks_size": 40,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "mypy/checkexpr.py:151:4 Incompatible attribute type [8]: Attribute `msg` declared in class `ExpressionChecker` has type `MessageBuilder` but is used as type `None`.",
    "message": " Attribute `msg` declared in class `ExpressionChecker` has type `MessageBuilder` but is used as type `None`.",
    "rule_id": "Incompatible attribute type [8]",
    "warning_line_no": 151,
    "warning_line": "    msg = None  # type: MessageBuilder",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    # Some services are provided by a TypeChecker instance.\n    chk = None  # type: mypy.checker.TypeChecker\n    # This is shared with TypeChecker, but stored also here for convenience.\n    msg = None  # type: MessageBuilder\n    # Type context for type inference\n    type_context = None  # type: List[Optional[Type]]\n\n    strfrm_checker = None  # type: StringFormatterChecker\n    plugin = None  # type: Plugin\n\n",
        "source_code_len": 411,
        "target_code": "    # Some services are provided by a TypeChecker instance.\n    chk: \"mypy.checker.TypeChecker\"\n    # This is shared with TypeChecker, but stored also here for convenience.\n    msg: MessageBuilder\n    # Type context for type inference\n    type_context: List[Optional[Type]]\n\n    strfrm_checker: StringFormatterChecker\n    plugin: Plugin\n\n",
        "target_code_len": 338,
        "diff_format": "@@ -148,10 +152,10 @@\n     # Some services are provided by a TypeChecker instance.\n-    chk = None  # type: mypy.checker.TypeChecker\n+    chk: \"mypy.checker.TypeChecker\"\n     # This is shared with TypeChecker, but stored also here for convenience.\n-    msg = None  # type: MessageBuilder\n+    msg: MessageBuilder\n     # Type context for type inference\n-    type_context = None  # type: List[Optional[Type]]\n-\n-    strfrm_checker = None  # type: StringFormatterChecker\n-    plugin = None  # type: Plugin\n+    type_context: List[Optional[Type]]\n+\n+    strfrm_checker: StringFormatterChecker\n+    plugin: Plugin\n \n",
        "source_code_with_indent": "    # Some services are provided by a TypeChecker instance.\n    chk = None  # type: mypy.checker.TypeChecker\n    # This is shared with TypeChecker, but stored also here for convenience.\n    msg = None  # type: MessageBuilder\n    # Type context for type inference\n    type_context = None  # type: List[Optional[Type]]\n\n    strfrm_checker = None  # type: StringFormatterChecker\n    plugin = None  # type: Plugin\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    # Some services are provided by a TypeChecker instance.\n    chk: \"mypy.checker.TypeChecker\"\n    # This is shared with TypeChecker, but stored also here for convenience.\n    msg: MessageBuilder\n    # Type context for type inference\n    type_context: List[Optional[Type]]\n\n    strfrm_checker: StringFormatterChecker\n    plugin: Plugin\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "python/mypy",
    "commit": "f98f78216ba9d6ab68c8e69c19e9f3c7926c5efe",
    "filename": "mypy/checkexpr.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/python-mypy/mypy/checkexpr.py",
    "file_hunks_size": 40,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "mypy/checkexpr.py:153:4 Incompatible attribute type [8]: Attribute `type_context` declared in class `ExpressionChecker` has type `List[Optional[Type]]` but is used as type `None`.",
    "message": " Attribute `type_context` declared in class `ExpressionChecker` has type `List[Optional[Type]]` but is used as type `None`.",
    "rule_id": "Incompatible attribute type [8]",
    "warning_line_no": 153,
    "warning_line": "    type_context = None  # type: List[Optional[Type]]",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    # Some services are provided by a TypeChecker instance.\n    chk = None  # type: mypy.checker.TypeChecker\n    # This is shared with TypeChecker, but stored also here for convenience.\n    msg = None  # type: MessageBuilder\n    # Type context for type inference\n    type_context = None  # type: List[Optional[Type]]\n\n    strfrm_checker = None  # type: StringFormatterChecker\n    plugin = None  # type: Plugin\n\n",
        "source_code_len": 411,
        "target_code": "    # Some services are provided by a TypeChecker instance.\n    chk: \"mypy.checker.TypeChecker\"\n    # This is shared with TypeChecker, but stored also here for convenience.\n    msg: MessageBuilder\n    # Type context for type inference\n    type_context: List[Optional[Type]]\n\n    strfrm_checker: StringFormatterChecker\n    plugin: Plugin\n\n",
        "target_code_len": 338,
        "diff_format": "@@ -148,10 +152,10 @@\n     # Some services are provided by a TypeChecker instance.\n-    chk = None  # type: mypy.checker.TypeChecker\n+    chk: \"mypy.checker.TypeChecker\"\n     # This is shared with TypeChecker, but stored also here for convenience.\n-    msg = None  # type: MessageBuilder\n+    msg: MessageBuilder\n     # Type context for type inference\n-    type_context = None  # type: List[Optional[Type]]\n-\n-    strfrm_checker = None  # type: StringFormatterChecker\n-    plugin = None  # type: Plugin\n+    type_context: List[Optional[Type]]\n+\n+    strfrm_checker: StringFormatterChecker\n+    plugin: Plugin\n \n",
        "source_code_with_indent": "    # Some services are provided by a TypeChecker instance.\n    chk = None  # type: mypy.checker.TypeChecker\n    # This is shared with TypeChecker, but stored also here for convenience.\n    msg = None  # type: MessageBuilder\n    # Type context for type inference\n    type_context = None  # type: List[Optional[Type]]\n\n    strfrm_checker = None  # type: StringFormatterChecker\n    plugin = None  # type: Plugin\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    # Some services are provided by a TypeChecker instance.\n    chk: \"mypy.checker.TypeChecker\"\n    # This is shared with TypeChecker, but stored also here for convenience.\n    msg: MessageBuilder\n    # Type context for type inference\n    type_context: List[Optional[Type]]\n\n    strfrm_checker: StringFormatterChecker\n    plugin: Plugin\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "python/mypy",
    "commit": "f98f78216ba9d6ab68c8e69c19e9f3c7926c5efe",
    "filename": "mypy/checkexpr.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/python-mypy/mypy/checkexpr.py",
    "file_hunks_size": 40,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "mypy/checkexpr.py:155:4 Incompatible attribute type [8]: Attribute `strfrm_checker` declared in class `ExpressionChecker` has type `StringFormatterChecker` but is used as type `None`.",
    "message": " Attribute `strfrm_checker` declared in class `ExpressionChecker` has type `StringFormatterChecker` but is used as type `None`.",
    "rule_id": "Incompatible attribute type [8]",
    "warning_line_no": 155,
    "warning_line": "    strfrm_checker = None  # type: StringFormatterChecker",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    # Some services are provided by a TypeChecker instance.\n    chk = None  # type: mypy.checker.TypeChecker\n    # This is shared with TypeChecker, but stored also here for convenience.\n    msg = None  # type: MessageBuilder\n    # Type context for type inference\n    type_context = None  # type: List[Optional[Type]]\n\n    strfrm_checker = None  # type: StringFormatterChecker\n    plugin = None  # type: Plugin\n\n",
        "source_code_len": 411,
        "target_code": "    # Some services are provided by a TypeChecker instance.\n    chk: \"mypy.checker.TypeChecker\"\n    # This is shared with TypeChecker, but stored also here for convenience.\n    msg: MessageBuilder\n    # Type context for type inference\n    type_context: List[Optional[Type]]\n\n    strfrm_checker: StringFormatterChecker\n    plugin: Plugin\n\n",
        "target_code_len": 338,
        "diff_format": "@@ -148,10 +152,10 @@\n     # Some services are provided by a TypeChecker instance.\n-    chk = None  # type: mypy.checker.TypeChecker\n+    chk: \"mypy.checker.TypeChecker\"\n     # This is shared with TypeChecker, but stored also here for convenience.\n-    msg = None  # type: MessageBuilder\n+    msg: MessageBuilder\n     # Type context for type inference\n-    type_context = None  # type: List[Optional[Type]]\n-\n-    strfrm_checker = None  # type: StringFormatterChecker\n-    plugin = None  # type: Plugin\n+    type_context: List[Optional[Type]]\n+\n+    strfrm_checker: StringFormatterChecker\n+    plugin: Plugin\n \n",
        "source_code_with_indent": "    # Some services are provided by a TypeChecker instance.\n    chk = None  # type: mypy.checker.TypeChecker\n    # This is shared with TypeChecker, but stored also here for convenience.\n    msg = None  # type: MessageBuilder\n    # Type context for type inference\n    type_context = None  # type: List[Optional[Type]]\n\n    strfrm_checker = None  # type: StringFormatterChecker\n    plugin = None  # type: Plugin\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    # Some services are provided by a TypeChecker instance.\n    chk: \"mypy.checker.TypeChecker\"\n    # This is shared with TypeChecker, but stored also here for convenience.\n    msg: MessageBuilder\n    # Type context for type inference\n    type_context: List[Optional[Type]]\n\n    strfrm_checker: StringFormatterChecker\n    plugin: Plugin\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "python/mypy",
    "commit": "f98f78216ba9d6ab68c8e69c19e9f3c7926c5efe",
    "filename": "mypy/checkexpr.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/python-mypy/mypy/checkexpr.py",
    "file_hunks_size": 40,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "mypy/checkexpr.py:156:4 Incompatible attribute type [8]: Attribute `plugin` declared in class `ExpressionChecker` has type `Plugin` but is used as type `None`.",
    "message": " Attribute `plugin` declared in class `ExpressionChecker` has type `Plugin` but is used as type `None`.",
    "rule_id": "Incompatible attribute type [8]",
    "warning_line_no": 156,
    "warning_line": "    plugin = None  # type: Plugin",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    # Some services are provided by a TypeChecker instance.\n    chk = None  # type: mypy.checker.TypeChecker\n    # This is shared with TypeChecker, but stored also here for convenience.\n    msg = None  # type: MessageBuilder\n    # Type context for type inference\n    type_context = None  # type: List[Optional[Type]]\n\n    strfrm_checker = None  # type: StringFormatterChecker\n    plugin = None  # type: Plugin\n\n",
        "source_code_len": 411,
        "target_code": "    # Some services are provided by a TypeChecker instance.\n    chk: \"mypy.checker.TypeChecker\"\n    # This is shared with TypeChecker, but stored also here for convenience.\n    msg: MessageBuilder\n    # Type context for type inference\n    type_context: List[Optional[Type]]\n\n    strfrm_checker: StringFormatterChecker\n    plugin: Plugin\n\n",
        "target_code_len": 338,
        "diff_format": "@@ -148,10 +152,10 @@\n     # Some services are provided by a TypeChecker instance.\n-    chk = None  # type: mypy.checker.TypeChecker\n+    chk: \"mypy.checker.TypeChecker\"\n     # This is shared with TypeChecker, but stored also here for convenience.\n-    msg = None  # type: MessageBuilder\n+    msg: MessageBuilder\n     # Type context for type inference\n-    type_context = None  # type: List[Optional[Type]]\n-\n-    strfrm_checker = None  # type: StringFormatterChecker\n-    plugin = None  # type: Plugin\n+    type_context: List[Optional[Type]]\n+\n+    strfrm_checker: StringFormatterChecker\n+    plugin: Plugin\n \n",
        "source_code_with_indent": "    # Some services are provided by a TypeChecker instance.\n    chk = None  # type: mypy.checker.TypeChecker\n    # This is shared with TypeChecker, but stored also here for convenience.\n    msg = None  # type: MessageBuilder\n    # Type context for type inference\n    type_context = None  # type: List[Optional[Type]]\n\n    strfrm_checker = None  # type: StringFormatterChecker\n    plugin = None  # type: Plugin\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    # Some services are provided by a TypeChecker instance.\n    chk: \"mypy.checker.TypeChecker\"\n    # This is shared with TypeChecker, but stored also here for convenience.\n    msg: MessageBuilder\n    # Type context for type inference\n    type_context: List[Optional[Type]]\n\n    strfrm_checker: StringFormatterChecker\n    plugin: Plugin\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "python/mypy",
    "commit": "f98f78216ba9d6ab68c8e69c19e9f3c7926c5efe",
    "filename": "mypy/checkstrformat.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/python-mypy/mypy/checkstrformat.py",
    "file_hunks_size": 11,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": true,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "mypy/checkstrformat.py:173:4 Incompatible attribute type [8]: Attribute `chk` declared in class `StringFormatterChecker` has type `mypy.checker.TypeChecker` but is used as type `None`.",
    "message": " Attribute `chk` declared in class `StringFormatterChecker` has type `mypy.checker.TypeChecker` but is used as type `None`.",
    "rule_id": "Incompatible attribute type [8]",
    "warning_line_no": 173,
    "warning_line": "    chk = None  # type: mypy.checker.TypeChecker",
    "min_patch": [
      {
        "hunk_fit_TFix": true,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    # Some services are provided by a TypeChecker instance.\n    chk = None  # type: mypy.checker.TypeChecker\n    # This is shared with TypeChecker, but stored also here for convenience.\n    msg = None  # type: MessageBuilder\n    # Some services are provided by a ExpressionChecker instance.\n    exprchk = None  # type: mypy.checkexpr.ExpressionChecker\n\n",
        "source_code_len": 353,
        "target_code": "    # Some services are provided by a TypeChecker instance.\n    chk: \"mypy.checker.TypeChecker\"\n    # This is shared with TypeChecker, but stored also here for convenience.\n    msg: MessageBuilder\n    # Some services are provided by a ExpressionChecker instance.\n    exprchk: \"mypy.checkexpr.ExpressionChecker\"\n\n",
        "target_code_len": 312,
        "diff_format": "@@ -172,7 +185,7 @@\n     # Some services are provided by a TypeChecker instance.\n-    chk = None  # type: mypy.checker.TypeChecker\n+    chk: \"mypy.checker.TypeChecker\"\n     # This is shared with TypeChecker, but stored also here for convenience.\n-    msg = None  # type: MessageBuilder\n+    msg: MessageBuilder\n     # Some services are provided by a ExpressionChecker instance.\n-    exprchk = None  # type: mypy.checkexpr.ExpressionChecker\n+    exprchk: \"mypy.checkexpr.ExpressionChecker\"\n \n",
        "source_code_with_indent": "    # Some services are provided by a TypeChecker instance.\n    chk = None  # type: mypy.checker.TypeChecker\n    # This is shared with TypeChecker, but stored also here for convenience.\n    msg = None  # type: MessageBuilder\n    # Some services are provided by a ExpressionChecker instance.\n    exprchk = None  # type: mypy.checkexpr.ExpressionChecker\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    # Some services are provided by a TypeChecker instance.\n    chk: \"mypy.checker.TypeChecker\"\n    # This is shared with TypeChecker, but stored also here for convenience.\n    msg: MessageBuilder\n    # Some services are provided by a ExpressionChecker instance.\n    exprchk: \"mypy.checkexpr.ExpressionChecker\"\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "python/mypy",
    "commit": "f98f78216ba9d6ab68c8e69c19e9f3c7926c5efe",
    "filename": "mypy/checkstrformat.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/python-mypy/mypy/checkstrformat.py",
    "file_hunks_size": 11,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": true,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "mypy/checkstrformat.py:175:4 Incompatible attribute type [8]: Attribute `msg` declared in class `StringFormatterChecker` has type `MessageBuilder` but is used as type `None`.",
    "message": " Attribute `msg` declared in class `StringFormatterChecker` has type `MessageBuilder` but is used as type `None`.",
    "rule_id": "Incompatible attribute type [8]",
    "warning_line_no": 175,
    "warning_line": "    msg = None  # type: MessageBuilder",
    "min_patch": [
      {
        "hunk_fit_TFix": true,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    # Some services are provided by a TypeChecker instance.\n    chk = None  # type: mypy.checker.TypeChecker\n    # This is shared with TypeChecker, but stored also here for convenience.\n    msg = None  # type: MessageBuilder\n    # Some services are provided by a ExpressionChecker instance.\n    exprchk = None  # type: mypy.checkexpr.ExpressionChecker\n\n",
        "source_code_len": 353,
        "target_code": "    # Some services are provided by a TypeChecker instance.\n    chk: \"mypy.checker.TypeChecker\"\n    # This is shared with TypeChecker, but stored also here for convenience.\n    msg: MessageBuilder\n    # Some services are provided by a ExpressionChecker instance.\n    exprchk: \"mypy.checkexpr.ExpressionChecker\"\n\n",
        "target_code_len": 312,
        "diff_format": "@@ -172,7 +185,7 @@\n     # Some services are provided by a TypeChecker instance.\n-    chk = None  # type: mypy.checker.TypeChecker\n+    chk: \"mypy.checker.TypeChecker\"\n     # This is shared with TypeChecker, but stored also here for convenience.\n-    msg = None  # type: MessageBuilder\n+    msg: MessageBuilder\n     # Some services are provided by a ExpressionChecker instance.\n-    exprchk = None  # type: mypy.checkexpr.ExpressionChecker\n+    exprchk: \"mypy.checkexpr.ExpressionChecker\"\n \n",
        "source_code_with_indent": "    # Some services are provided by a TypeChecker instance.\n    chk = None  # type: mypy.checker.TypeChecker\n    # This is shared with TypeChecker, but stored also here for convenience.\n    msg = None  # type: MessageBuilder\n    # Some services are provided by a ExpressionChecker instance.\n    exprchk = None  # type: mypy.checkexpr.ExpressionChecker\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    # Some services are provided by a TypeChecker instance.\n    chk: \"mypy.checker.TypeChecker\"\n    # This is shared with TypeChecker, but stored also here for convenience.\n    msg: MessageBuilder\n    # Some services are provided by a ExpressionChecker instance.\n    exprchk: \"mypy.checkexpr.ExpressionChecker\"\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "python/mypy",
    "commit": "f98f78216ba9d6ab68c8e69c19e9f3c7926c5efe",
    "filename": "mypy/checkstrformat.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/python-mypy/mypy/checkstrformat.py",
    "file_hunks_size": 11,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": true,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "mypy/checkstrformat.py:177:4 Incompatible attribute type [8]: Attribute `exprchk` declared in class `StringFormatterChecker` has type `mypy.checkexpr.ExpressionChecker` but is used as type `None`.",
    "message": " Attribute `exprchk` declared in class `StringFormatterChecker` has type `mypy.checkexpr.ExpressionChecker` but is used as type `None`.",
    "rule_id": "Incompatible attribute type [8]",
    "warning_line_no": 177,
    "warning_line": "    exprchk = None  # type: mypy.checkexpr.ExpressionChecker",
    "min_patch": [
      {
        "hunk_fit_TFix": true,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    # Some services are provided by a TypeChecker instance.\n    chk = None  # type: mypy.checker.TypeChecker\n    # This is shared with TypeChecker, but stored also here for convenience.\n    msg = None  # type: MessageBuilder\n    # Some services are provided by a ExpressionChecker instance.\n    exprchk = None  # type: mypy.checkexpr.ExpressionChecker\n\n",
        "source_code_len": 353,
        "target_code": "    # Some services are provided by a TypeChecker instance.\n    chk: \"mypy.checker.TypeChecker\"\n    # This is shared with TypeChecker, but stored also here for convenience.\n    msg: MessageBuilder\n    # Some services are provided by a ExpressionChecker instance.\n    exprchk: \"mypy.checkexpr.ExpressionChecker\"\n\n",
        "target_code_len": 312,
        "diff_format": "@@ -172,7 +185,7 @@\n     # Some services are provided by a TypeChecker instance.\n-    chk = None  # type: mypy.checker.TypeChecker\n+    chk: \"mypy.checker.TypeChecker\"\n     # This is shared with TypeChecker, but stored also here for convenience.\n-    msg = None  # type: MessageBuilder\n+    msg: MessageBuilder\n     # Some services are provided by a ExpressionChecker instance.\n-    exprchk = None  # type: mypy.checkexpr.ExpressionChecker\n+    exprchk: \"mypy.checkexpr.ExpressionChecker\"\n \n",
        "source_code_with_indent": "    # Some services are provided by a TypeChecker instance.\n    chk = None  # type: mypy.checker.TypeChecker\n    # This is shared with TypeChecker, but stored also here for convenience.\n    msg = None  # type: MessageBuilder\n    # Some services are provided by a ExpressionChecker instance.\n    exprchk = None  # type: mypy.checkexpr.ExpressionChecker\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    # Some services are provided by a TypeChecker instance.\n    chk: \"mypy.checker.TypeChecker\"\n    # This is shared with TypeChecker, but stored also here for convenience.\n    msg: MessageBuilder\n    # Some services are provided by a ExpressionChecker instance.\n    exprchk: \"mypy.checkexpr.ExpressionChecker\"\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "python/mypy",
    "commit": "f98f78216ba9d6ab68c8e69c19e9f3c7926c5efe",
    "filename": "mypy/constraints.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/python-mypy/mypy/constraints.py",
    "file_hunks_size": 10,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": true,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "mypy/constraints.py:31:4 Incompatible attribute type [8]: Attribute `type_var` declared in class `Constraint` has type `TypeVarId` but is used as type `None`.",
    "message": " Attribute `type_var` declared in class `Constraint` has type `TypeVarId` but is used as type `None`.",
    "rule_id": "Incompatible attribute type [8]",
    "warning_line_no": 31,
    "warning_line": "    type_var = None  # type: TypeVarId",
    "min_patch": [
      {
        "hunk_fit_TFix": true,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n    type_var = None  # type: TypeVarId\n    op = 0           # SUBTYPE_OF or SUPERTYPE_OF\n    target = None    # type: Type\n\n",
        "source_code_len": 125,
        "target_code": "\n    type_var: TypeVarId\n    op = 0           # SUBTYPE_OF or SUPERTYPE_OF\n    target: Type\n\n",
        "target_code_len": 93,
        "diff_format": "@@ -30,5 +30,5 @@\n \n-    type_var = None  # type: TypeVarId\n+    type_var: TypeVarId\n     op = 0           # SUBTYPE_OF or SUPERTYPE_OF\n-    target = None    # type: Type\n+    target: Type\n \n",
        "source_code_with_indent": "\n    type_var = None  # type: TypeVarId\n    op = 0           # SUBTYPE_OF or SUPERTYPE_OF\n    target = None    # type: Type\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n    type_var: TypeVarId\n    op = 0           # SUBTYPE_OF or SUPERTYPE_OF\n    target: Type\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "python/mypy",
    "commit": "f98f78216ba9d6ab68c8e69c19e9f3c7926c5efe",
    "filename": "mypy/constraints.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/python-mypy/mypy/constraints.py",
    "file_hunks_size": 10,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": true,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "mypy/constraints.py:33:4 Incompatible attribute type [8]: Attribute `target` declared in class `Constraint` has type `Type` but is used as type `None`.",
    "message": " Attribute `target` declared in class `Constraint` has type `Type` but is used as type `None`.",
    "rule_id": "Incompatible attribute type [8]",
    "warning_line_no": 33,
    "warning_line": "    target = None    # type: Type",
    "min_patch": [
      {
        "hunk_fit_TFix": true,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n    type_var = None  # type: TypeVarId\n    op = 0           # SUBTYPE_OF or SUPERTYPE_OF\n    target = None    # type: Type\n\n",
        "source_code_len": 125,
        "target_code": "\n    type_var: TypeVarId\n    op = 0           # SUBTYPE_OF or SUPERTYPE_OF\n    target: Type\n\n",
        "target_code_len": 93,
        "diff_format": "@@ -30,5 +30,5 @@\n \n-    type_var = None  # type: TypeVarId\n+    type_var: TypeVarId\n     op = 0           # SUBTYPE_OF or SUPERTYPE_OF\n-    target = None    # type: Type\n+    target: Type\n \n",
        "source_code_with_indent": "\n    type_var = None  # type: TypeVarId\n    op = 0           # SUBTYPE_OF or SUPERTYPE_OF\n    target = None    # type: Type\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n    type_var: TypeVarId\n    op = 0           # SUBTYPE_OF or SUPERTYPE_OF\n    target: Type\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "python/mypy",
    "commit": "f98f78216ba9d6ab68c8e69c19e9f3c7926c5efe",
    "filename": "mypy/constraints.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/python-mypy/mypy/constraints.py",
    "file_hunks_size": 10,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": true,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "mypy/constraints.py:271:4 Incompatible attribute type [8]: Attribute `actual` declared in class `ConstraintBuilderVisitor` has type `ProperType` but is used as type `None`.",
    "message": " Attribute `actual` declared in class `ConstraintBuilderVisitor` has type `ProperType` but is used as type `None`.",
    "rule_id": "Incompatible attribute type [8]",
    "warning_line_no": 271,
    "warning_line": "    actual = None  # type: ProperType",
    "min_patch": [
      {
        "hunk_fit_TFix": true,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    # TODO: The value may be None. Is that actually correct?\n    actual = None  # type: ProperType\n\n",
        "source_code_len": 100,
        "target_code": "    # TODO: The value may be None. Is that actually correct?\n    actual: ProperType\n\n",
        "target_code_len": 85,
        "diff_format": "@@ -270,3 +270,3 @@\n     # TODO: The value may be None. Is that actually correct?\n-    actual = None  # type: ProperType\n+    actual: ProperType\n \n",
        "source_code_with_indent": "    # TODO: The value may be None. Is that actually correct?\n    actual = None  # type: ProperType\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    # TODO: The value may be None. Is that actually correct?\n    actual: ProperType\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "python/mypy",
    "commit": "f98f78216ba9d6ab68c8e69c19e9f3c7926c5efe",
    "filename": "mypy/errors.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/python-mypy/mypy/errors.py",
    "file_hunks_size": 13,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": true,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "mypy/errors.py:26:4 Incompatible attribute type [8]: Attribute `import_ctx` declared in class `ErrorInfo` has type `List[Tuple[str, int]]` but is used as type `None`.",
    "message": " Attribute `import_ctx` declared in class `ErrorInfo` has type `List[Tuple[str, int]]` but is used as type `None`.",
    "rule_id": "Incompatible attribute type [8]",
    "warning_line_no": 26,
    "warning_line": "    import_ctx = None  # type: List[Tuple[str, int]]",
    "min_patch": [
      {
        "hunk_fit_TFix": true,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    # related to this error. Each item is a (path, line number) tuple.\n    import_ctx = None  # type: List[Tuple[str, int]]\n\n",
        "source_code_len": 125,
        "target_code": "    # related to this error. Each item is a (path, line number) tuple.\n    import_ctx: List[Tuple[str, int]]\n\n",
        "target_code_len": 110,
        "diff_format": "@@ -25,3 +25,3 @@\n     # related to this error. Each item is a (path, line number) tuple.\n-    import_ctx = None  # type: List[Tuple[str, int]]\n+    import_ctx: List[Tuple[str, int]]\n \n",
        "source_code_with_indent": "    # related to this error. Each item is a (path, line number) tuple.\n    import_ctx = None  # type: List[Tuple[str, int]]\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    # related to this error. Each item is a (path, line number) tuple.\n    import_ctx: List[Tuple[str, int]]\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "python/mypy",
    "commit": "f98f78216ba9d6ab68c8e69c19e9f3c7926c5efe",
    "filename": "mypy/errors.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/python-mypy/mypy/errors.py",
    "file_hunks_size": 13,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": true,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "mypy/errors.py:63:4 Incompatible attribute type [8]: Attribute `origin` declared in class `ErrorInfo` has type `Tuple[str, int, int]` but is used as type `None`.",
    "message": " Attribute `origin` declared in class `ErrorInfo` has type `Tuple[str, int, int]` but is used as type `None`.",
    "rule_id": "Incompatible attribute type [8]",
    "warning_line_no": 63,
    "warning_line": "    origin = None  # type: Tuple[str, int, int]",
    "min_patch": [
      {
        "hunk_fit_TFix": true,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    # If end line number is unknown, use line number.\n    origin = None  # type: Tuple[str, int, int]\n\n    # Fine-grained incremental target where this was reported\n    target = None  # type: Optional[str]\n\n",
        "source_code_len": 207,
        "target_code": "    # If end line number is unknown, use line number.\n    origin: Tuple[str, int, int]\n\n    # Fine-grained incremental target where this was reported\n    target: Optional[str] = None\n\n",
        "target_code_len": 184,
        "diff_format": "@@ -62,6 +62,6 @@\n     # If end line number is unknown, use line number.\n-    origin = None  # type: Tuple[str, int, int]\n+    origin: Tuple[str, int, int]\n \n     # Fine-grained incremental target where this was reported\n-    target = None  # type: Optional[str]\n+    target: Optional[str] = None\n \n",
        "source_code_with_indent": "    # If end line number is unknown, use line number.\n    origin = None  # type: Tuple[str, int, int]\n\n    # Fine-grained incremental target where this was reported\n    target = None  # type: Optional[str]\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    # If end line number is unknown, use line number.\n    origin: Tuple[str, int, int]\n\n    # Fine-grained incremental target where this was reported\n    target: Optional[str] = None\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "python/mypy",
    "commit": "f98f78216ba9d6ab68c8e69c19e9f3c7926c5efe",
    "filename": "mypy/errors.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/python-mypy/mypy/errors.py",
    "file_hunks_size": 13,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "mypy/errors.py:123:4 Incompatible attribute type [8]: Attribute `error_info_map` declared in class `Errors` has type `Dict[str, List[ErrorInfo]]` but is used as type `None`.",
    "message": " Attribute `error_info_map` declared in class `Errors` has type `Dict[str, List[ErrorInfo]]` but is used as type `None`.",
    "rule_id": "Incompatible attribute type [8]",
    "warning_line_no": 123,
    "warning_line": "    error_info_map = None  # type: Dict[str, List[ErrorInfo]]",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    # files were processed.\n    error_info_map = None  # type: Dict[str, List[ErrorInfo]]\n\n    # Files that we have reported the errors for\n    flushed_files = None  # type: Set[str]\n\n    # Current error context: nested import context/stack, as a list of (path, line) pairs.\n    import_ctx = None  # type: List[Tuple[str, int]]\n\n    # Path name prefix that is removed from all paths, if set.\n    ignore_prefix = None  # type: Optional[str]\n\n    # Path to current file.\n    file = ''  # type: str\n\n",
        "source_code_len": 497,
        "target_code": "    # files were processed.\n    error_info_map: Dict[str, List[ErrorInfo]]\n\n    # Files that we have reported the errors for\n    flushed_files: Set[str]\n\n    # Current error context: nested import context/stack, as a list of (path, line) pairs.\n    import_ctx: List[Tuple[str, int]]\n\n    # Path name prefix that is removed from all paths, if set.\n    ignore_prefix: Optional[str] = None\n\n    # Path to current file.\n    file: str = \"\"\n\n",
        "target_code_len": 436,
        "diff_format": "@@ -122,15 +122,15 @@\n     # files were processed.\n-    error_info_map = None  # type: Dict[str, List[ErrorInfo]]\n+    error_info_map: Dict[str, List[ErrorInfo]]\n \n     # Files that we have reported the errors for\n-    flushed_files = None  # type: Set[str]\n+    flushed_files: Set[str]\n \n     # Current error context: nested import context/stack, as a list of (path, line) pairs.\n-    import_ctx = None  # type: List[Tuple[str, int]]\n+    import_ctx: List[Tuple[str, int]]\n \n     # Path name prefix that is removed from all paths, if set.\n-    ignore_prefix = None  # type: Optional[str]\n+    ignore_prefix: Optional[str] = None\n \n     # Path to current file.\n-    file = ''  # type: str\n+    file: str = \"\"\n \n",
        "source_code_with_indent": "    # files were processed.\n    error_info_map = None  # type: Dict[str, List[ErrorInfo]]\n\n    # Files that we have reported the errors for\n    flushed_files = None  # type: Set[str]\n\n    # Current error context: nested import context/stack, as a list of (path, line) pairs.\n    import_ctx = None  # type: List[Tuple[str, int]]\n\n    # Path name prefix that is removed from all paths, if set.\n    ignore_prefix = None  # type: Optional[str]\n\n    # Path to current file.\n    file = ''  # type: str\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    # files were processed.\n    error_info_map: Dict[str, List[ErrorInfo]]\n\n    # Files that we have reported the errors for\n    flushed_files: Set[str]\n\n    # Current error context: nested import context/stack, as a list of (path, line) pairs.\n    import_ctx: List[Tuple[str, int]]\n\n    # Path name prefix that is removed from all paths, if set.\n    ignore_prefix: Optional[str] = None\n\n    # Path to current file.\n    file: str = \"\"\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "python/mypy",
    "commit": "f98f78216ba9d6ab68c8e69c19e9f3c7926c5efe",
    "filename": "mypy/errors.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/python-mypy/mypy/errors.py",
    "file_hunks_size": 13,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "mypy/errors.py:126:4 Incompatible attribute type [8]: Attribute `flushed_files` declared in class `Errors` has type `Set[str]` but is used as type `None`.",
    "message": " Attribute `flushed_files` declared in class `Errors` has type `Set[str]` but is used as type `None`.",
    "rule_id": "Incompatible attribute type [8]",
    "warning_line_no": 126,
    "warning_line": "    flushed_files = None  # type: Set[str]",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    # files were processed.\n    error_info_map = None  # type: Dict[str, List[ErrorInfo]]\n\n    # Files that we have reported the errors for\n    flushed_files = None  # type: Set[str]\n\n    # Current error context: nested import context/stack, as a list of (path, line) pairs.\n    import_ctx = None  # type: List[Tuple[str, int]]\n\n    # Path name prefix that is removed from all paths, if set.\n    ignore_prefix = None  # type: Optional[str]\n\n    # Path to current file.\n    file = ''  # type: str\n\n",
        "source_code_len": 497,
        "target_code": "    # files were processed.\n    error_info_map: Dict[str, List[ErrorInfo]]\n\n    # Files that we have reported the errors for\n    flushed_files: Set[str]\n\n    # Current error context: nested import context/stack, as a list of (path, line) pairs.\n    import_ctx: List[Tuple[str, int]]\n\n    # Path name prefix that is removed from all paths, if set.\n    ignore_prefix: Optional[str] = None\n\n    # Path to current file.\n    file: str = \"\"\n\n",
        "target_code_len": 436,
        "diff_format": "@@ -122,15 +122,15 @@\n     # files were processed.\n-    error_info_map = None  # type: Dict[str, List[ErrorInfo]]\n+    error_info_map: Dict[str, List[ErrorInfo]]\n \n     # Files that we have reported the errors for\n-    flushed_files = None  # type: Set[str]\n+    flushed_files: Set[str]\n \n     # Current error context: nested import context/stack, as a list of (path, line) pairs.\n-    import_ctx = None  # type: List[Tuple[str, int]]\n+    import_ctx: List[Tuple[str, int]]\n \n     # Path name prefix that is removed from all paths, if set.\n-    ignore_prefix = None  # type: Optional[str]\n+    ignore_prefix: Optional[str] = None\n \n     # Path to current file.\n-    file = ''  # type: str\n+    file: str = \"\"\n \n",
        "source_code_with_indent": "    # files were processed.\n    error_info_map = None  # type: Dict[str, List[ErrorInfo]]\n\n    # Files that we have reported the errors for\n    flushed_files = None  # type: Set[str]\n\n    # Current error context: nested import context/stack, as a list of (path, line) pairs.\n    import_ctx = None  # type: List[Tuple[str, int]]\n\n    # Path name prefix that is removed from all paths, if set.\n    ignore_prefix = None  # type: Optional[str]\n\n    # Path to current file.\n    file = ''  # type: str\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    # files were processed.\n    error_info_map: Dict[str, List[ErrorInfo]]\n\n    # Files that we have reported the errors for\n    flushed_files: Set[str]\n\n    # Current error context: nested import context/stack, as a list of (path, line) pairs.\n    import_ctx: List[Tuple[str, int]]\n\n    # Path name prefix that is removed from all paths, if set.\n    ignore_prefix: Optional[str] = None\n\n    # Path to current file.\n    file: str = \"\"\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "python/mypy",
    "commit": "f98f78216ba9d6ab68c8e69c19e9f3c7926c5efe",
    "filename": "mypy/errors.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/python-mypy/mypy/errors.py",
    "file_hunks_size": 13,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "mypy/errors.py:129:4 Incompatible attribute type [8]: Attribute `import_ctx` declared in class `Errors` has type `List[Tuple[str, int]]` but is used as type `None`.",
    "message": " Attribute `import_ctx` declared in class `Errors` has type `List[Tuple[str, int]]` but is used as type `None`.",
    "rule_id": "Incompatible attribute type [8]",
    "warning_line_no": 129,
    "warning_line": "    import_ctx = None  # type: List[Tuple[str, int]]",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    # files were processed.\n    error_info_map = None  # type: Dict[str, List[ErrorInfo]]\n\n    # Files that we have reported the errors for\n    flushed_files = None  # type: Set[str]\n\n    # Current error context: nested import context/stack, as a list of (path, line) pairs.\n    import_ctx = None  # type: List[Tuple[str, int]]\n\n    # Path name prefix that is removed from all paths, if set.\n    ignore_prefix = None  # type: Optional[str]\n\n    # Path to current file.\n    file = ''  # type: str\n\n",
        "source_code_len": 497,
        "target_code": "    # files were processed.\n    error_info_map: Dict[str, List[ErrorInfo]]\n\n    # Files that we have reported the errors for\n    flushed_files: Set[str]\n\n    # Current error context: nested import context/stack, as a list of (path, line) pairs.\n    import_ctx: List[Tuple[str, int]]\n\n    # Path name prefix that is removed from all paths, if set.\n    ignore_prefix: Optional[str] = None\n\n    # Path to current file.\n    file: str = \"\"\n\n",
        "target_code_len": 436,
        "diff_format": "@@ -122,15 +122,15 @@\n     # files were processed.\n-    error_info_map = None  # type: Dict[str, List[ErrorInfo]]\n+    error_info_map: Dict[str, List[ErrorInfo]]\n \n     # Files that we have reported the errors for\n-    flushed_files = None  # type: Set[str]\n+    flushed_files: Set[str]\n \n     # Current error context: nested import context/stack, as a list of (path, line) pairs.\n-    import_ctx = None  # type: List[Tuple[str, int]]\n+    import_ctx: List[Tuple[str, int]]\n \n     # Path name prefix that is removed from all paths, if set.\n-    ignore_prefix = None  # type: Optional[str]\n+    ignore_prefix: Optional[str] = None\n \n     # Path to current file.\n-    file = ''  # type: str\n+    file: str = \"\"\n \n",
        "source_code_with_indent": "    # files were processed.\n    error_info_map = None  # type: Dict[str, List[ErrorInfo]]\n\n    # Files that we have reported the errors for\n    flushed_files = None  # type: Set[str]\n\n    # Current error context: nested import context/stack, as a list of (path, line) pairs.\n    import_ctx = None  # type: List[Tuple[str, int]]\n\n    # Path name prefix that is removed from all paths, if set.\n    ignore_prefix = None  # type: Optional[str]\n\n    # Path to current file.\n    file = ''  # type: str\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    # files were processed.\n    error_info_map: Dict[str, List[ErrorInfo]]\n\n    # Files that we have reported the errors for\n    flushed_files: Set[str]\n\n    # Current error context: nested import context/stack, as a list of (path, line) pairs.\n    import_ctx: List[Tuple[str, int]]\n\n    # Path name prefix that is removed from all paths, if set.\n    ignore_prefix: Optional[str] = None\n\n    # Path to current file.\n    file: str = \"\"\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "python/mypy",
    "commit": "f98f78216ba9d6ab68c8e69c19e9f3c7926c5efe",
    "filename": "mypy/errors.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/python-mypy/mypy/errors.py",
    "file_hunks_size": 13,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "mypy/errors.py:139:4 Incompatible attribute type [8]: Attribute `ignored_lines` declared in class `Errors` has type `Dict[str, Dict[int, List[str]]]` but is used as type `None`.",
    "message": " Attribute `ignored_lines` declared in class `Errors` has type `Dict[str, Dict[int, List[str]]]` but is used as type `None`.",
    "rule_id": "Incompatible attribute type [8]",
    "warning_line_no": 139,
    "warning_line": "    ignored_lines = None  # type: Dict[str, Dict[int, List[str]]]",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    # (path -> line -> error-codes)\n    ignored_lines = None  # type: Dict[str, Dict[int, List[str]]]\n\n    # Lines on which an error was actually ignored.\n    used_ignored_lines = None  # type: Dict[str, Set[int]]\n\n    # Files where all errors should be ignored.\n    ignored_files = None  # type: Set[str]\n\n    # Collection of reported only_once messages.\n    only_once_messages = None  # type: Set[str]\n\n    # Set to True to show \"In function \"foo\":\" messages.\n    show_error_context = False  # type: bool\n\n    # Set to True to show column numbers in error messages.\n    show_column_numbers = False  # type: bool\n\n    # Set to True to show absolute file paths in error messages.\n    show_absolute_path = False  # type: bool\n\n",
        "source_code_len": 726,
        "target_code": "    # (path -> line -> error-codes)\n    ignored_lines: Dict[str, Dict[int, List[str]]]\n\n    # Lines on which an error was actually ignored.\n    used_ignored_lines: Dict[str, Set[int]]\n\n    # Files where all errors should be ignored.\n    ignored_files: Set[str]\n\n    # Collection of reported only_once messages.\n    only_once_messages: Set[str]\n\n    # Set to True to show \"In function \"foo\":\" messages.\n    show_error_context: bool = False\n\n    # Set to True to show column numbers in error messages.\n    show_column_numbers: bool = False\n\n    # Set to True to show absolute file paths in error messages.\n    show_absolute_path: bool = False\n\n",
        "target_code_len": 642,
        "diff_format": "@@ -138,21 +138,21 @@\n     # (path -> line -> error-codes)\n-    ignored_lines = None  # type: Dict[str, Dict[int, List[str]]]\n+    ignored_lines: Dict[str, Dict[int, List[str]]]\n \n     # Lines on which an error was actually ignored.\n-    used_ignored_lines = None  # type: Dict[str, Set[int]]\n+    used_ignored_lines: Dict[str, Set[int]]\n \n     # Files where all errors should be ignored.\n-    ignored_files = None  # type: Set[str]\n+    ignored_files: Set[str]\n \n     # Collection of reported only_once messages.\n-    only_once_messages = None  # type: Set[str]\n+    only_once_messages: Set[str]\n \n     # Set to True to show \"In function \"foo\":\" messages.\n-    show_error_context = False  # type: bool\n+    show_error_context: bool = False\n \n     # Set to True to show column numbers in error messages.\n-    show_column_numbers = False  # type: bool\n+    show_column_numbers: bool = False\n \n     # Set to True to show absolute file paths in error messages.\n-    show_absolute_path = False  # type: bool\n+    show_absolute_path: bool = False\n \n",
        "source_code_with_indent": "    # (path -> line -> error-codes)\n    ignored_lines = None  # type: Dict[str, Dict[int, List[str]]]\n\n    # Lines on which an error was actually ignored.\n    used_ignored_lines = None  # type: Dict[str, Set[int]]\n\n    # Files where all errors should be ignored.\n    ignored_files = None  # type: Set[str]\n\n    # Collection of reported only_once messages.\n    only_once_messages = None  # type: Set[str]\n\n    # Set to True to show \"In function \"foo\":\" messages.\n    show_error_context = False  # type: bool\n\n    # Set to True to show column numbers in error messages.\n    show_column_numbers = False  # type: bool\n\n    # Set to True to show absolute file paths in error messages.\n    show_absolute_path = False  # type: bool\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    # (path -> line -> error-codes)\n    ignored_lines: Dict[str, Dict[int, List[str]]]\n\n    # Lines on which an error was actually ignored.\n    used_ignored_lines: Dict[str, Set[int]]\n\n    # Files where all errors should be ignored.\n    ignored_files: Set[str]\n\n    # Collection of reported only_once messages.\n    only_once_messages: Set[str]\n\n    # Set to True to show \"In function \"foo\":\" messages.\n    show_error_context: bool = False\n\n    # Set to True to show column numbers in error messages.\n    show_column_numbers: bool = False\n\n    # Set to True to show absolute file paths in error messages.\n    show_absolute_path: bool = False\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "python/mypy",
    "commit": "f98f78216ba9d6ab68c8e69c19e9f3c7926c5efe",
    "filename": "mypy/errors.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/python-mypy/mypy/errors.py",
    "file_hunks_size": 13,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "mypy/errors.py:142:4 Incompatible attribute type [8]: Attribute `used_ignored_lines` declared in class `Errors` has type `Dict[str, Set[int]]` but is used as type `None`.",
    "message": " Attribute `used_ignored_lines` declared in class `Errors` has type `Dict[str, Set[int]]` but is used as type `None`.",
    "rule_id": "Incompatible attribute type [8]",
    "warning_line_no": 142,
    "warning_line": "    used_ignored_lines = None  # type: Dict[str, Set[int]]",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    # (path -> line -> error-codes)\n    ignored_lines = None  # type: Dict[str, Dict[int, List[str]]]\n\n    # Lines on which an error was actually ignored.\n    used_ignored_lines = None  # type: Dict[str, Set[int]]\n\n    # Files where all errors should be ignored.\n    ignored_files = None  # type: Set[str]\n\n    # Collection of reported only_once messages.\n    only_once_messages = None  # type: Set[str]\n\n    # Set to True to show \"In function \"foo\":\" messages.\n    show_error_context = False  # type: bool\n\n    # Set to True to show column numbers in error messages.\n    show_column_numbers = False  # type: bool\n\n    # Set to True to show absolute file paths in error messages.\n    show_absolute_path = False  # type: bool\n\n",
        "source_code_len": 726,
        "target_code": "    # (path -> line -> error-codes)\n    ignored_lines: Dict[str, Dict[int, List[str]]]\n\n    # Lines on which an error was actually ignored.\n    used_ignored_lines: Dict[str, Set[int]]\n\n    # Files where all errors should be ignored.\n    ignored_files: Set[str]\n\n    # Collection of reported only_once messages.\n    only_once_messages: Set[str]\n\n    # Set to True to show \"In function \"foo\":\" messages.\n    show_error_context: bool = False\n\n    # Set to True to show column numbers in error messages.\n    show_column_numbers: bool = False\n\n    # Set to True to show absolute file paths in error messages.\n    show_absolute_path: bool = False\n\n",
        "target_code_len": 642,
        "diff_format": "@@ -138,21 +138,21 @@\n     # (path -> line -> error-codes)\n-    ignored_lines = None  # type: Dict[str, Dict[int, List[str]]]\n+    ignored_lines: Dict[str, Dict[int, List[str]]]\n \n     # Lines on which an error was actually ignored.\n-    used_ignored_lines = None  # type: Dict[str, Set[int]]\n+    used_ignored_lines: Dict[str, Set[int]]\n \n     # Files where all errors should be ignored.\n-    ignored_files = None  # type: Set[str]\n+    ignored_files: Set[str]\n \n     # Collection of reported only_once messages.\n-    only_once_messages = None  # type: Set[str]\n+    only_once_messages: Set[str]\n \n     # Set to True to show \"In function \"foo\":\" messages.\n-    show_error_context = False  # type: bool\n+    show_error_context: bool = False\n \n     # Set to True to show column numbers in error messages.\n-    show_column_numbers = False  # type: bool\n+    show_column_numbers: bool = False\n \n     # Set to True to show absolute file paths in error messages.\n-    show_absolute_path = False  # type: bool\n+    show_absolute_path: bool = False\n \n",
        "source_code_with_indent": "    # (path -> line -> error-codes)\n    ignored_lines = None  # type: Dict[str, Dict[int, List[str]]]\n\n    # Lines on which an error was actually ignored.\n    used_ignored_lines = None  # type: Dict[str, Set[int]]\n\n    # Files where all errors should be ignored.\n    ignored_files = None  # type: Set[str]\n\n    # Collection of reported only_once messages.\n    only_once_messages = None  # type: Set[str]\n\n    # Set to True to show \"In function \"foo\":\" messages.\n    show_error_context = False  # type: bool\n\n    # Set to True to show column numbers in error messages.\n    show_column_numbers = False  # type: bool\n\n    # Set to True to show absolute file paths in error messages.\n    show_absolute_path = False  # type: bool\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    # (path -> line -> error-codes)\n    ignored_lines: Dict[str, Dict[int, List[str]]]\n\n    # Lines on which an error was actually ignored.\n    used_ignored_lines: Dict[str, Set[int]]\n\n    # Files where all errors should be ignored.\n    ignored_files: Set[str]\n\n    # Collection of reported only_once messages.\n    only_once_messages: Set[str]\n\n    # Set to True to show \"In function \"foo\":\" messages.\n    show_error_context: bool = False\n\n    # Set to True to show column numbers in error messages.\n    show_column_numbers: bool = False\n\n    # Set to True to show absolute file paths in error messages.\n    show_absolute_path: bool = False\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "python/mypy",
    "commit": "f98f78216ba9d6ab68c8e69c19e9f3c7926c5efe",
    "filename": "mypy/errors.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/python-mypy/mypy/errors.py",
    "file_hunks_size": 13,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "mypy/errors.py:145:4 Incompatible attribute type [8]: Attribute `ignored_files` declared in class `Errors` has type `Set[str]` but is used as type `None`.",
    "message": " Attribute `ignored_files` declared in class `Errors` has type `Set[str]` but is used as type `None`.",
    "rule_id": "Incompatible attribute type [8]",
    "warning_line_no": 145,
    "warning_line": "    ignored_files = None  # type: Set[str]",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    # (path -> line -> error-codes)\n    ignored_lines = None  # type: Dict[str, Dict[int, List[str]]]\n\n    # Lines on which an error was actually ignored.\n    used_ignored_lines = None  # type: Dict[str, Set[int]]\n\n    # Files where all errors should be ignored.\n    ignored_files = None  # type: Set[str]\n\n    # Collection of reported only_once messages.\n    only_once_messages = None  # type: Set[str]\n\n    # Set to True to show \"In function \"foo\":\" messages.\n    show_error_context = False  # type: bool\n\n    # Set to True to show column numbers in error messages.\n    show_column_numbers = False  # type: bool\n\n    # Set to True to show absolute file paths in error messages.\n    show_absolute_path = False  # type: bool\n\n",
        "source_code_len": 726,
        "target_code": "    # (path -> line -> error-codes)\n    ignored_lines: Dict[str, Dict[int, List[str]]]\n\n    # Lines on which an error was actually ignored.\n    used_ignored_lines: Dict[str, Set[int]]\n\n    # Files where all errors should be ignored.\n    ignored_files: Set[str]\n\n    # Collection of reported only_once messages.\n    only_once_messages: Set[str]\n\n    # Set to True to show \"In function \"foo\":\" messages.\n    show_error_context: bool = False\n\n    # Set to True to show column numbers in error messages.\n    show_column_numbers: bool = False\n\n    # Set to True to show absolute file paths in error messages.\n    show_absolute_path: bool = False\n\n",
        "target_code_len": 642,
        "diff_format": "@@ -138,21 +138,21 @@\n     # (path -> line -> error-codes)\n-    ignored_lines = None  # type: Dict[str, Dict[int, List[str]]]\n+    ignored_lines: Dict[str, Dict[int, List[str]]]\n \n     # Lines on which an error was actually ignored.\n-    used_ignored_lines = None  # type: Dict[str, Set[int]]\n+    used_ignored_lines: Dict[str, Set[int]]\n \n     # Files where all errors should be ignored.\n-    ignored_files = None  # type: Set[str]\n+    ignored_files: Set[str]\n \n     # Collection of reported only_once messages.\n-    only_once_messages = None  # type: Set[str]\n+    only_once_messages: Set[str]\n \n     # Set to True to show \"In function \"foo\":\" messages.\n-    show_error_context = False  # type: bool\n+    show_error_context: bool = False\n \n     # Set to True to show column numbers in error messages.\n-    show_column_numbers = False  # type: bool\n+    show_column_numbers: bool = False\n \n     # Set to True to show absolute file paths in error messages.\n-    show_absolute_path = False  # type: bool\n+    show_absolute_path: bool = False\n \n",
        "source_code_with_indent": "    # (path -> line -> error-codes)\n    ignored_lines = None  # type: Dict[str, Dict[int, List[str]]]\n\n    # Lines on which an error was actually ignored.\n    used_ignored_lines = None  # type: Dict[str, Set[int]]\n\n    # Files where all errors should be ignored.\n    ignored_files = None  # type: Set[str]\n\n    # Collection of reported only_once messages.\n    only_once_messages = None  # type: Set[str]\n\n    # Set to True to show \"In function \"foo\":\" messages.\n    show_error_context = False  # type: bool\n\n    # Set to True to show column numbers in error messages.\n    show_column_numbers = False  # type: bool\n\n    # Set to True to show absolute file paths in error messages.\n    show_absolute_path = False  # type: bool\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    # (path -> line -> error-codes)\n    ignored_lines: Dict[str, Dict[int, List[str]]]\n\n    # Lines on which an error was actually ignored.\n    used_ignored_lines: Dict[str, Set[int]]\n\n    # Files where all errors should be ignored.\n    ignored_files: Set[str]\n\n    # Collection of reported only_once messages.\n    only_once_messages: Set[str]\n\n    # Set to True to show \"In function \"foo\":\" messages.\n    show_error_context: bool = False\n\n    # Set to True to show column numbers in error messages.\n    show_column_numbers: bool = False\n\n    # Set to True to show absolute file paths in error messages.\n    show_absolute_path: bool = False\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "python/mypy",
    "commit": "f98f78216ba9d6ab68c8e69c19e9f3c7926c5efe",
    "filename": "mypy/errors.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/python-mypy/mypy/errors.py",
    "file_hunks_size": 13,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "mypy/errors.py:148:4 Incompatible attribute type [8]: Attribute `only_once_messages` declared in class `Errors` has type `Set[str]` but is used as type `None`.",
    "message": " Attribute `only_once_messages` declared in class `Errors` has type `Set[str]` but is used as type `None`.",
    "rule_id": "Incompatible attribute type [8]",
    "warning_line_no": 148,
    "warning_line": "    only_once_messages = None  # type: Set[str]",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    # (path -> line -> error-codes)\n    ignored_lines = None  # type: Dict[str, Dict[int, List[str]]]\n\n    # Lines on which an error was actually ignored.\n    used_ignored_lines = None  # type: Dict[str, Set[int]]\n\n    # Files where all errors should be ignored.\n    ignored_files = None  # type: Set[str]\n\n    # Collection of reported only_once messages.\n    only_once_messages = None  # type: Set[str]\n\n    # Set to True to show \"In function \"foo\":\" messages.\n    show_error_context = False  # type: bool\n\n    # Set to True to show column numbers in error messages.\n    show_column_numbers = False  # type: bool\n\n    # Set to True to show absolute file paths in error messages.\n    show_absolute_path = False  # type: bool\n\n",
        "source_code_len": 726,
        "target_code": "    # (path -> line -> error-codes)\n    ignored_lines: Dict[str, Dict[int, List[str]]]\n\n    # Lines on which an error was actually ignored.\n    used_ignored_lines: Dict[str, Set[int]]\n\n    # Files where all errors should be ignored.\n    ignored_files: Set[str]\n\n    # Collection of reported only_once messages.\n    only_once_messages: Set[str]\n\n    # Set to True to show \"In function \"foo\":\" messages.\n    show_error_context: bool = False\n\n    # Set to True to show column numbers in error messages.\n    show_column_numbers: bool = False\n\n    # Set to True to show absolute file paths in error messages.\n    show_absolute_path: bool = False\n\n",
        "target_code_len": 642,
        "diff_format": "@@ -138,21 +138,21 @@\n     # (path -> line -> error-codes)\n-    ignored_lines = None  # type: Dict[str, Dict[int, List[str]]]\n+    ignored_lines: Dict[str, Dict[int, List[str]]]\n \n     # Lines on which an error was actually ignored.\n-    used_ignored_lines = None  # type: Dict[str, Set[int]]\n+    used_ignored_lines: Dict[str, Set[int]]\n \n     # Files where all errors should be ignored.\n-    ignored_files = None  # type: Set[str]\n+    ignored_files: Set[str]\n \n     # Collection of reported only_once messages.\n-    only_once_messages = None  # type: Set[str]\n+    only_once_messages: Set[str]\n \n     # Set to True to show \"In function \"foo\":\" messages.\n-    show_error_context = False  # type: bool\n+    show_error_context: bool = False\n \n     # Set to True to show column numbers in error messages.\n-    show_column_numbers = False  # type: bool\n+    show_column_numbers: bool = False\n \n     # Set to True to show absolute file paths in error messages.\n-    show_absolute_path = False  # type: bool\n+    show_absolute_path: bool = False\n \n",
        "source_code_with_indent": "    # (path -> line -> error-codes)\n    ignored_lines = None  # type: Dict[str, Dict[int, List[str]]]\n\n    # Lines on which an error was actually ignored.\n    used_ignored_lines = None  # type: Dict[str, Set[int]]\n\n    # Files where all errors should be ignored.\n    ignored_files = None  # type: Set[str]\n\n    # Collection of reported only_once messages.\n    only_once_messages = None  # type: Set[str]\n\n    # Set to True to show \"In function \"foo\":\" messages.\n    show_error_context = False  # type: bool\n\n    # Set to True to show column numbers in error messages.\n    show_column_numbers = False  # type: bool\n\n    # Set to True to show absolute file paths in error messages.\n    show_absolute_path = False  # type: bool\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    # (path -> line -> error-codes)\n    ignored_lines: Dict[str, Dict[int, List[str]]]\n\n    # Lines on which an error was actually ignored.\n    used_ignored_lines: Dict[str, Set[int]]\n\n    # Files where all errors should be ignored.\n    ignored_files: Set[str]\n\n    # Collection of reported only_once messages.\n    only_once_messages: Set[str]\n\n    # Set to True to show \"In function \"foo\":\" messages.\n    show_error_context: bool = False\n\n    # Set to True to show column numbers in error messages.\n    show_column_numbers: bool = False\n\n    # Set to True to show absolute file paths in error messages.\n    show_absolute_path: bool = False\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "python/mypy",
    "commit": "f98f78216ba9d6ab68c8e69c19e9f3c7926c5efe",
    "filename": "mypy/errors.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/python-mypy/mypy/errors.py",
    "file_hunks_size": 13,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": true,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "mypy/errors.py:730:4 Incompatible attribute type [8]: Attribute `messages` declared in class `CompileError` has type `List[str]` but is used as type `None`.",
    "message": " Attribute `messages` declared in class `CompileError` has type `List[str]` but is used as type `None`.",
    "rule_id": "Incompatible attribute type [8]",
    "warning_line_no": 730,
    "warning_line": "    messages = None  # type: List[str]",
    "min_patch": [
      {
        "hunk_fit_TFix": true,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n    messages = None  # type: List[str]\n    use_stdout = False\n    # Can be set in case there was a module with a blocking error\n    module_with_blocker = None  # type: Optional[str]\n\n",
        "source_code_len": 184,
        "target_code": "\n    messages: List[str]\n    use_stdout = False\n    # Can be set in case there was a module with a blocking error\n    module_with_blocker: Optional[str] = None\n\n",
        "target_code_len": 161,
        "diff_format": "@@ -729,6 +729,6 @@\n \n-    messages = None  # type: List[str]\n+    messages: List[str]\n     use_stdout = False\n     # Can be set in case there was a module with a blocking error\n-    module_with_blocker = None  # type: Optional[str]\n+    module_with_blocker: Optional[str] = None\n \n",
        "source_code_with_indent": "\n    messages = None  # type: List[str]\n    use_stdout = False\n    # Can be set in case there was a module with a blocking error\n    module_with_blocker = None  # type: Optional[str]\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n    messages: List[str]\n    use_stdout = False\n    # Can be set in case there was a module with a blocking error\n    module_with_blocker: Optional[str] = None\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "python/mypy",
    "commit": "f98f78216ba9d6ab68c8e69c19e9f3c7926c5efe",
    "filename": "mypy/expandtype.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/python-mypy/mypy/expandtype.py",
    "file_hunks_size": 5,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": true,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "mypy/expandtype.py:60:4 Incompatible attribute type [8]: Attribute `variables` declared in class `ExpandTypeVisitor` has type `Mapping[TypeVarId, Type]` but is used as type `None`.",
    "message": " Attribute `variables` declared in class `ExpandTypeVisitor` has type `Mapping[TypeVarId, Type]` but is used as type `None`.",
    "rule_id": "Incompatible attribute type [8]",
    "warning_line_no": 60,
    "warning_line": "    variables = None  # type: Mapping[TypeVarId, Type]  # TypeVar id -> TypeVar value",
    "min_patch": [
      {
        "hunk_fit_TFix": true,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n    variables = None  # type: Mapping[TypeVarId, Type]  # TypeVar id -> TypeVar value\n\n",
        "source_code_len": 88,
        "target_code": "\n    variables: Mapping[TypeVarId, Type]  # TypeVar id -> TypeVar value\n\n",
        "target_code_len": 73,
        "diff_format": "@@ -59,3 +59,3 @@\n \n-    variables = None  # type: Mapping[TypeVarId, Type]  # TypeVar id -> TypeVar value\n+    variables: Mapping[TypeVarId, Type]  # TypeVar id -> TypeVar value\n \n",
        "source_code_with_indent": "\n    variables = None  # type: Mapping[TypeVarId, Type]  # TypeVar id -> TypeVar value\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n    variables: Mapping[TypeVarId, Type]  # TypeVar id -> TypeVar value\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "python/mypy",
    "commit": "f98f78216ba9d6ab68c8e69c19e9f3c7926c5efe",
    "filename": "mypy/messages.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/python-mypy/mypy/messages.py",
    "file_hunks_size": 17,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": true,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "mypy/messages.py:102:4 Incompatible attribute type [8]: Attribute `errors` declared in class `MessageBuilder` has type `Errors` but is used as type `None`.",
    "message": " Attribute `errors` declared in class `MessageBuilder` has type `Errors` but is used as type `None`.",
    "rule_id": "Incompatible attribute type [8]",
    "warning_line_no": 102,
    "warning_line": "    errors = None  # type: Errors",
    "min_patch": [
      {
        "hunk_fit_TFix": true,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    # import context.\n    errors = None  # type: Errors\n\n    modules = None  # type: Dict[str, MypyFile]\n\n",
        "source_code_len": 106,
        "target_code": "    # import context.\n    errors: Errors\n\n    modules: Dict[str, MypyFile]\n\n",
        "target_code_len": 76,
        "diff_format": "@@ -101,5 +101,5 @@\n     # import context.\n-    errors = None  # type: Errors\n-\n-    modules = None  # type: Dict[str, MypyFile]\n+    errors: Errors\n+\n+    modules: Dict[str, MypyFile]\n \n",
        "source_code_with_indent": "    # import context.\n    errors = None  # type: Errors\n\n    modules = None  # type: Dict[str, MypyFile]\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    # import context.\n    errors: Errors\n\n    modules: Dict[str, MypyFile]\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "python/mypy",
    "commit": "f98f78216ba9d6ab68c8e69c19e9f3c7926c5efe",
    "filename": "mypy/messages.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/python-mypy/mypy/messages.py",
    "file_hunks_size": 17,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": true,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "mypy/messages.py:104:4 Incompatible attribute type [8]: Attribute `modules` declared in class `MessageBuilder` has type `Dict[str, MypyFile]` but is used as type `None`.",
    "message": " Attribute `modules` declared in class `MessageBuilder` has type `Dict[str, MypyFile]` but is used as type `None`.",
    "rule_id": "Incompatible attribute type [8]",
    "warning_line_no": 104,
    "warning_line": "    modules = None  # type: Dict[str, MypyFile]",
    "min_patch": [
      {
        "hunk_fit_TFix": true,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    # import context.\n    errors = None  # type: Errors\n\n    modules = None  # type: Dict[str, MypyFile]\n\n",
        "source_code_len": 106,
        "target_code": "    # import context.\n    errors: Errors\n\n    modules: Dict[str, MypyFile]\n\n",
        "target_code_len": 76,
        "diff_format": "@@ -101,5 +101,5 @@\n     # import context.\n-    errors = None  # type: Errors\n-\n-    modules = None  # type: Dict[str, MypyFile]\n+    errors: Errors\n+\n+    modules: Dict[str, MypyFile]\n \n",
        "source_code_with_indent": "    # import context.\n    errors = None  # type: Errors\n\n    modules = None  # type: Dict[str, MypyFile]\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    # import context.\n    errors: Errors\n\n    modules: Dict[str, MypyFile]\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "python/mypy",
    "commit": "f98f78216ba9d6ab68c8e69c19e9f3c7926c5efe",
    "filename": "mypy/semanal.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/python-mypy/mypy/semanal.py",
    "file_hunks_size": 39,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "mypy/semanal.py:162:4 Incompatible attribute type [8]: Attribute `modules` declared in class `SemanticAnalyzer` has type `Dict[str, MypyFile]` but is used as type `None`.",
    "message": " Attribute `modules` declared in class `SemanticAnalyzer` has type `Dict[str, MypyFile]` but is used as type `None`.",
    "rule_id": "Incompatible attribute type [8]",
    "warning_line_no": 162,
    "warning_line": "    modules = None  # type: Dict[str, MypyFile]"
  },
  {
    "project": "python/mypy",
    "commit": "f98f78216ba9d6ab68c8e69c19e9f3c7926c5efe",
    "filename": "mypy/semanal.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/python-mypy/mypy/semanal.py",
    "file_hunks_size": 39,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "mypy/semanal.py:164:4 Incompatible attribute type [8]: Attribute `globals` declared in class `SemanticAnalyzer` has type `SymbolTable` but is used as type `None`.",
    "message": " Attribute `globals` declared in class `SemanticAnalyzer` has type `SymbolTable` but is used as type `None`.",
    "rule_id": "Incompatible attribute type [8]",
    "warning_line_no": 164,
    "warning_line": "    globals = None  # type: SymbolTable"
  },
  {
    "project": "python/mypy",
    "commit": "f98f78216ba9d6ab68c8e69c19e9f3c7926c5efe",
    "filename": "mypy/semanal.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/python-mypy/mypy/semanal.py",
    "file_hunks_size": 39,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "mypy/semanal.py:166:4 Incompatible attribute type [8]: Attribute `global_decls` declared in class `SemanticAnalyzer` has type `List[Set[str]]` but is used as type `None`.",
    "message": " Attribute `global_decls` declared in class `SemanticAnalyzer` has type `List[Set[str]]` but is used as type `None`.",
    "rule_id": "Incompatible attribute type [8]",
    "warning_line_no": 166,
    "warning_line": "    global_decls = None  # type: List[Set[str]]"
  },
  {
    "project": "python/mypy",
    "commit": "f98f78216ba9d6ab68c8e69c19e9f3c7926c5efe",
    "filename": "mypy/semanal.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/python-mypy/mypy/semanal.py",
    "file_hunks_size": 39,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "mypy/semanal.py:168:4 Incompatible attribute type [8]: Attribute `nonlocal_decls` declared in class `SemanticAnalyzer` has type `List[Set[str]]` but is used as type `None`.",
    "message": " Attribute `nonlocal_decls` declared in class `SemanticAnalyzer` has type `List[Set[str]]` but is used as type `None`.",
    "rule_id": "Incompatible attribute type [8]",
    "warning_line_no": 168,
    "warning_line": "    nonlocal_decls = None  # type: List[Set[str]]"
  },
  {
    "project": "python/mypy",
    "commit": "f98f78216ba9d6ab68c8e69c19e9f3c7926c5efe",
    "filename": "mypy/semanal.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/python-mypy/mypy/semanal.py",
    "file_hunks_size": 39,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "mypy/semanal.py:170:4 Incompatible attribute type [8]: Attribute `locals` declared in class `SemanticAnalyzer` has type `List[Optional[SymbolTable]]` but is used as type `None`.",
    "message": " Attribute `locals` declared in class `SemanticAnalyzer` has type `List[Optional[SymbolTable]]` but is used as type `None`.",
    "rule_id": "Incompatible attribute type [8]",
    "warning_line_no": 170,
    "warning_line": "    locals = None  # type: List[Optional[SymbolTable]]"
  },
  {
    "project": "python/mypy",
    "commit": "f98f78216ba9d6ab68c8e69c19e9f3c7926c5efe",
    "filename": "mypy/semanal.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/python-mypy/mypy/semanal.py",
    "file_hunks_size": 39,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "mypy/semanal.py:172:4 Incompatible attribute type [8]: Attribute `is_comprehension_stack` declared in class `SemanticAnalyzer` has type `List[bool]` but is used as type `None`.",
    "message": " Attribute `is_comprehension_stack` declared in class `SemanticAnalyzer` has type `List[bool]` but is used as type `None`.",
    "rule_id": "Incompatible attribute type [8]",
    "warning_line_no": 172,
    "warning_line": "    is_comprehension_stack = None  # type: List[bool]"
  },
  {
    "project": "python/mypy",
    "commit": "f98f78216ba9d6ab68c8e69c19e9f3c7926c5efe",
    "filename": "mypy/semanal.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/python-mypy/mypy/semanal.py",
    "file_hunks_size": 39,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "mypy/semanal.py:174:4 Incompatible attribute type [8]: Attribute `block_depth` declared in class `SemanticAnalyzer` has type `List[int]` but is used as type `None`.",
    "message": " Attribute `block_depth` declared in class `SemanticAnalyzer` has type `List[int]` but is used as type `None`.",
    "rule_id": "Incompatible attribute type [8]",
    "warning_line_no": 174,
    "warning_line": "    block_depth = None  # type: List[int]"
  },
  {
    "project": "python/mypy",
    "commit": "f98f78216ba9d6ab68c8e69c19e9f3c7926c5efe",
    "filename": "mypy/semanal.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/python-mypy/mypy/semanal.py",
    "file_hunks_size": 39,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "mypy/semanal.py:178:4 Incompatible attribute type [8]: Attribute `type_stack` declared in class `SemanticAnalyzer` has type `List[Optional[TypeInfo]]` but is used as type `None`.",
    "message": " Attribute `type_stack` declared in class `SemanticAnalyzer` has type `List[Optional[TypeInfo]]` but is used as type `None`.",
    "rule_id": "Incompatible attribute type [8]",
    "warning_line_no": 178,
    "warning_line": "    type_stack = None  # type: List[Optional[TypeInfo]]"
  },
  {
    "project": "python/mypy",
    "commit": "f98f78216ba9d6ab68c8e69c19e9f3c7926c5efe",
    "filename": "mypy/semanal.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/python-mypy/mypy/semanal.py",
    "file_hunks_size": 39,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "mypy/semanal.py:180:4 Incompatible attribute type [8]: Attribute `tvar_scope` declared in class `SemanticAnalyzer` has type `TypeVarLikeScope` but is used as type `None`.",
    "message": " Attribute `tvar_scope` declared in class `SemanticAnalyzer` has type `TypeVarLikeScope` but is used as type `None`.",
    "rule_id": "Incompatible attribute type [8]",
    "warning_line_no": 180,
    "warning_line": "    tvar_scope = None  # type: TypeVarLikeScope"
  },
  {
    "project": "python/mypy",
    "commit": "f98f78216ba9d6ab68c8e69c19e9f3c7926c5efe",
    "filename": "mypy/semanal.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/python-mypy/mypy/semanal.py",
    "file_hunks_size": 39,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "mypy/semanal.py:182:4 Incompatible attribute type [8]: Attribute `options` declared in class `SemanticAnalyzer` has type `Options` but is used as type `None`.",
    "message": " Attribute `options` declared in class `SemanticAnalyzer` has type `Options` but is used as type `None`.",
    "rule_id": "Incompatible attribute type [8]",
    "warning_line_no": 182,
    "warning_line": "    options = None  # type: Options"
  },
  {
    "project": "python/mypy",
    "commit": "f98f78216ba9d6ab68c8e69c19e9f3c7926c5efe",
    "filename": "mypy/semanal.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/python-mypy/mypy/semanal.py",
    "file_hunks_size": 39,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "mypy/semanal.py:185:4 Incompatible attribute type [8]: Attribute `function_stack` declared in class `SemanticAnalyzer` has type `List[FuncItem]` but is used as type `None`.",
    "message": " Attribute `function_stack` declared in class `SemanticAnalyzer` has type `List[FuncItem]` but is used as type `None`.",
    "rule_id": "Incompatible attribute type [8]",
    "warning_line_no": 185,
    "warning_line": "    function_stack = None  # type: List[FuncItem]"
  },
  {
    "project": "python/mypy",
    "commit": "f98f78216ba9d6ab68c8e69c19e9f3c7926c5efe",
    "filename": "mypy/semanal.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/python-mypy/mypy/semanal.py",
    "file_hunks_size": 39,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "mypy/semanal.py:206:4 Incompatible attribute type [8]: Attribute `missing_names` declared in class `SemanticAnalyzer` has type `List[Set[str]]` but is used as type `None`.",
    "message": " Attribute `missing_names` declared in class `SemanticAnalyzer` has type `List[Set[str]]` but is used as type `None`.",
    "rule_id": "Incompatible attribute type [8]",
    "warning_line_no": 206,
    "warning_line": "    missing_names = None  # type: List[Set[str]]"
  },
  {
    "project": "python/mypy",
    "commit": "f98f78216ba9d6ab68c8e69c19e9f3c7926c5efe",
    "filename": "mypy/semanal.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/python-mypy/mypy/semanal.py",
    "file_hunks_size": 39,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "mypy/semanal.py:208:4 Incompatible attribute type [8]: Attribute `patches` declared in class `SemanticAnalyzer` has type `List[Tuple[int, typing.Callable[[], None]]]` but is used as type `None`.",
    "message": " Attribute `patches` declared in class `SemanticAnalyzer` has type `List[Tuple[int, typing.Callable[[], None]]]` but is used as type `None`.",
    "rule_id": "Incompatible attribute type [8]",
    "warning_line_no": 208,
    "warning_line": "    patches = None  # type: List[Tuple[int, Callable[[], None]]]"
  },
  {
    "project": "python/mypy",
    "commit": "f98f78216ba9d6ab68c8e69c19e9f3c7926c5efe",
    "filename": "mypy/semanal.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/python-mypy/mypy/semanal.py",
    "file_hunks_size": 39,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "mypy/semanal.py:213:4 Incompatible attribute type [8]: Attribute `imports` declared in class `SemanticAnalyzer` has type `Set[str]` but is used as type `None`.",
    "message": " Attribute `imports` declared in class `SemanticAnalyzer` has type `Set[str]` but is used as type `None`.",
    "rule_id": "Incompatible attribute type [8]",
    "warning_line_no": 213,
    "warning_line": "    imports = None  # type: Set[str]  # Imported modules (during phase 2 analysis)",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    _is_typeshed_stub_file = False  # Are we analyzing a typeshed stub file?\n    imports = None  # type: Set[str]  # Imported modules (during phase 2 analysis)\n    # Note: some imports (and therefore dependencies) might\n    # not be found in phase 1, for example due to * imports.\n    errors = None  # type: Errors     # Keeps track of generated errors\n    plugin = None  # type: Plugin     # Mypy plugin for special casing of library features\n    statement = None  # type: Optional[Statement]  # Statement/definition being analyzed\n    future_import_flags = None  # type: Set[str]\n\n",
        "source_code_len": 583,
        "target_code": "    _is_typeshed_stub_file = False  # Are we analyzing a typeshed stub file?\n    imports: Set[str]  # Imported modules (during phase 2 analysis)\n    # Note: some imports (and therefore dependencies) might\n    # not be found in phase 1, for example due to * imports.\n    errors: Errors  # Keeps track of generated errors\n    plugin: Plugin  # Mypy plugin for special casing of library features\n    statement: Optional[Statement] = None  # Statement/definition being analyzed\n    future_import_flags: Set[str]\n\n",
        "target_code_len": 509,
        "diff_format": "@@ -212,9 +212,9 @@\n     _is_typeshed_stub_file = False  # Are we analyzing a typeshed stub file?\n-    imports = None  # type: Set[str]  # Imported modules (during phase 2 analysis)\n+    imports: Set[str]  # Imported modules (during phase 2 analysis)\n     # Note: some imports (and therefore dependencies) might\n     # not be found in phase 1, for example due to * imports.\n-    errors = None  # type: Errors     # Keeps track of generated errors\n-    plugin = None  # type: Plugin     # Mypy plugin for special casing of library features\n-    statement = None  # type: Optional[Statement]  # Statement/definition being analyzed\n-    future_import_flags = None  # type: Set[str]\n+    errors: Errors  # Keeps track of generated errors\n+    plugin: Plugin  # Mypy plugin for special casing of library features\n+    statement: Optional[Statement] = None  # Statement/definition being analyzed\n+    future_import_flags: Set[str]\n \n",
        "source_code_with_indent": "    _is_typeshed_stub_file = False  # Are we analyzing a typeshed stub file?\n    imports = None  # type: Set[str]  # Imported modules (during phase 2 analysis)\n    # Note: some imports (and therefore dependencies) might\n    # not be found in phase 1, for example due to * imports.\n    errors = None  # type: Errors     # Keeps track of generated errors\n    plugin = None  # type: Plugin     # Mypy plugin for special casing of library features\n    statement = None  # type: Optional[Statement]  # Statement/definition being analyzed\n    future_import_flags = None  # type: Set[str]\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    _is_typeshed_stub_file = False  # Are we analyzing a typeshed stub file?\n    imports: Set[str]  # Imported modules (during phase 2 analysis)\n    # Note: some imports (and therefore dependencies) might\n    # not be found in phase 1, for example due to * imports.\n    errors: Errors  # Keeps track of generated errors\n    plugin: Plugin  # Mypy plugin for special casing of library features\n    statement: Optional[Statement] = None  # Statement/definition being analyzed\n    future_import_flags: Set[str]\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "python/mypy",
    "commit": "f98f78216ba9d6ab68c8e69c19e9f3c7926c5efe",
    "filename": "mypy/semanal.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/python-mypy/mypy/semanal.py",
    "file_hunks_size": 39,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "mypy/semanal.py:216:4 Incompatible attribute type [8]: Attribute `errors` declared in class `SemanticAnalyzer` has type `Errors` but is used as type `None`.",
    "message": " Attribute `errors` declared in class `SemanticAnalyzer` has type `Errors` but is used as type `None`.",
    "rule_id": "Incompatible attribute type [8]",
    "warning_line_no": 216,
    "warning_line": "    errors = None  # type: Errors     # Keeps track of generated errors",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    _is_typeshed_stub_file = False  # Are we analyzing a typeshed stub file?\n    imports = None  # type: Set[str]  # Imported modules (during phase 2 analysis)\n    # Note: some imports (and therefore dependencies) might\n    # not be found in phase 1, for example due to * imports.\n    errors = None  # type: Errors     # Keeps track of generated errors\n    plugin = None  # type: Plugin     # Mypy plugin for special casing of library features\n    statement = None  # type: Optional[Statement]  # Statement/definition being analyzed\n    future_import_flags = None  # type: Set[str]\n\n",
        "source_code_len": 583,
        "target_code": "    _is_typeshed_stub_file = False  # Are we analyzing a typeshed stub file?\n    imports: Set[str]  # Imported modules (during phase 2 analysis)\n    # Note: some imports (and therefore dependencies) might\n    # not be found in phase 1, for example due to * imports.\n    errors: Errors  # Keeps track of generated errors\n    plugin: Plugin  # Mypy plugin for special casing of library features\n    statement: Optional[Statement] = None  # Statement/definition being analyzed\n    future_import_flags: Set[str]\n\n",
        "target_code_len": 509,
        "diff_format": "@@ -212,9 +212,9 @@\n     _is_typeshed_stub_file = False  # Are we analyzing a typeshed stub file?\n-    imports = None  # type: Set[str]  # Imported modules (during phase 2 analysis)\n+    imports: Set[str]  # Imported modules (during phase 2 analysis)\n     # Note: some imports (and therefore dependencies) might\n     # not be found in phase 1, for example due to * imports.\n-    errors = None  # type: Errors     # Keeps track of generated errors\n-    plugin = None  # type: Plugin     # Mypy plugin for special casing of library features\n-    statement = None  # type: Optional[Statement]  # Statement/definition being analyzed\n-    future_import_flags = None  # type: Set[str]\n+    errors: Errors  # Keeps track of generated errors\n+    plugin: Plugin  # Mypy plugin for special casing of library features\n+    statement: Optional[Statement] = None  # Statement/definition being analyzed\n+    future_import_flags: Set[str]\n \n",
        "source_code_with_indent": "    _is_typeshed_stub_file = False  # Are we analyzing a typeshed stub file?\n    imports = None  # type: Set[str]  # Imported modules (during phase 2 analysis)\n    # Note: some imports (and therefore dependencies) might\n    # not be found in phase 1, for example due to * imports.\n    errors = None  # type: Errors     # Keeps track of generated errors\n    plugin = None  # type: Plugin     # Mypy plugin for special casing of library features\n    statement = None  # type: Optional[Statement]  # Statement/definition being analyzed\n    future_import_flags = None  # type: Set[str]\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    _is_typeshed_stub_file = False  # Are we analyzing a typeshed stub file?\n    imports: Set[str]  # Imported modules (during phase 2 analysis)\n    # Note: some imports (and therefore dependencies) might\n    # not be found in phase 1, for example due to * imports.\n    errors: Errors  # Keeps track of generated errors\n    plugin: Plugin  # Mypy plugin for special casing of library features\n    statement: Optional[Statement] = None  # Statement/definition being analyzed\n    future_import_flags: Set[str]\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "python/mypy",
    "commit": "f98f78216ba9d6ab68c8e69c19e9f3c7926c5efe",
    "filename": "mypy/semanal.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/python-mypy/mypy/semanal.py",
    "file_hunks_size": 39,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "mypy/semanal.py:217:4 Incompatible attribute type [8]: Attribute `plugin` declared in class `SemanticAnalyzer` has type `Plugin` but is used as type `None`.",
    "message": " Attribute `plugin` declared in class `SemanticAnalyzer` has type `Plugin` but is used as type `None`.",
    "rule_id": "Incompatible attribute type [8]",
    "warning_line_no": 217,
    "warning_line": "    plugin = None  # type: Plugin     # Mypy plugin for special casing of library features",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    _is_typeshed_stub_file = False  # Are we analyzing a typeshed stub file?\n    imports = None  # type: Set[str]  # Imported modules (during phase 2 analysis)\n    # Note: some imports (and therefore dependencies) might\n    # not be found in phase 1, for example due to * imports.\n    errors = None  # type: Errors     # Keeps track of generated errors\n    plugin = None  # type: Plugin     # Mypy plugin for special casing of library features\n    statement = None  # type: Optional[Statement]  # Statement/definition being analyzed\n    future_import_flags = None  # type: Set[str]\n\n",
        "source_code_len": 583,
        "target_code": "    _is_typeshed_stub_file = False  # Are we analyzing a typeshed stub file?\n    imports: Set[str]  # Imported modules (during phase 2 analysis)\n    # Note: some imports (and therefore dependencies) might\n    # not be found in phase 1, for example due to * imports.\n    errors: Errors  # Keeps track of generated errors\n    plugin: Plugin  # Mypy plugin for special casing of library features\n    statement: Optional[Statement] = None  # Statement/definition being analyzed\n    future_import_flags: Set[str]\n\n",
        "target_code_len": 509,
        "diff_format": "@@ -212,9 +212,9 @@\n     _is_typeshed_stub_file = False  # Are we analyzing a typeshed stub file?\n-    imports = None  # type: Set[str]  # Imported modules (during phase 2 analysis)\n+    imports: Set[str]  # Imported modules (during phase 2 analysis)\n     # Note: some imports (and therefore dependencies) might\n     # not be found in phase 1, for example due to * imports.\n-    errors = None  # type: Errors     # Keeps track of generated errors\n-    plugin = None  # type: Plugin     # Mypy plugin for special casing of library features\n-    statement = None  # type: Optional[Statement]  # Statement/definition being analyzed\n-    future_import_flags = None  # type: Set[str]\n+    errors: Errors  # Keeps track of generated errors\n+    plugin: Plugin  # Mypy plugin for special casing of library features\n+    statement: Optional[Statement] = None  # Statement/definition being analyzed\n+    future_import_flags: Set[str]\n \n",
        "source_code_with_indent": "    _is_typeshed_stub_file = False  # Are we analyzing a typeshed stub file?\n    imports = None  # type: Set[str]  # Imported modules (during phase 2 analysis)\n    # Note: some imports (and therefore dependencies) might\n    # not be found in phase 1, for example due to * imports.\n    errors = None  # type: Errors     # Keeps track of generated errors\n    plugin = None  # type: Plugin     # Mypy plugin for special casing of library features\n    statement = None  # type: Optional[Statement]  # Statement/definition being analyzed\n    future_import_flags = None  # type: Set[str]\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    _is_typeshed_stub_file = False  # Are we analyzing a typeshed stub file?\n    imports: Set[str]  # Imported modules (during phase 2 analysis)\n    # Note: some imports (and therefore dependencies) might\n    # not be found in phase 1, for example due to * imports.\n    errors: Errors  # Keeps track of generated errors\n    plugin: Plugin  # Mypy plugin for special casing of library features\n    statement: Optional[Statement] = None  # Statement/definition being analyzed\n    future_import_flags: Set[str]\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "python/mypy",
    "commit": "f98f78216ba9d6ab68c8e69c19e9f3c7926c5efe",
    "filename": "mypy/semanal.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/python-mypy/mypy/semanal.py",
    "file_hunks_size": 39,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "mypy/semanal.py:219:4 Incompatible attribute type [8]: Attribute `future_import_flags` declared in class `SemanticAnalyzer` has type `Set[str]` but is used as type `None`.",
    "message": " Attribute `future_import_flags` declared in class `SemanticAnalyzer` has type `Set[str]` but is used as type `None`.",
    "rule_id": "Incompatible attribute type [8]",
    "warning_line_no": 219,
    "warning_line": "    future_import_flags = None  # type: Set[str]",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    _is_typeshed_stub_file = False  # Are we analyzing a typeshed stub file?\n    imports = None  # type: Set[str]  # Imported modules (during phase 2 analysis)\n    # Note: some imports (and therefore dependencies) might\n    # not be found in phase 1, for example due to * imports.\n    errors = None  # type: Errors     # Keeps track of generated errors\n    plugin = None  # type: Plugin     # Mypy plugin for special casing of library features\n    statement = None  # type: Optional[Statement]  # Statement/definition being analyzed\n    future_import_flags = None  # type: Set[str]\n\n",
        "source_code_len": 583,
        "target_code": "    _is_typeshed_stub_file = False  # Are we analyzing a typeshed stub file?\n    imports: Set[str]  # Imported modules (during phase 2 analysis)\n    # Note: some imports (and therefore dependencies) might\n    # not be found in phase 1, for example due to * imports.\n    errors: Errors  # Keeps track of generated errors\n    plugin: Plugin  # Mypy plugin for special casing of library features\n    statement: Optional[Statement] = None  # Statement/definition being analyzed\n    future_import_flags: Set[str]\n\n",
        "target_code_len": 509,
        "diff_format": "@@ -212,9 +212,9 @@\n     _is_typeshed_stub_file = False  # Are we analyzing a typeshed stub file?\n-    imports = None  # type: Set[str]  # Imported modules (during phase 2 analysis)\n+    imports: Set[str]  # Imported modules (during phase 2 analysis)\n     # Note: some imports (and therefore dependencies) might\n     # not be found in phase 1, for example due to * imports.\n-    errors = None  # type: Errors     # Keeps track of generated errors\n-    plugin = None  # type: Plugin     # Mypy plugin for special casing of library features\n-    statement = None  # type: Optional[Statement]  # Statement/definition being analyzed\n-    future_import_flags = None  # type: Set[str]\n+    errors: Errors  # Keeps track of generated errors\n+    plugin: Plugin  # Mypy plugin for special casing of library features\n+    statement: Optional[Statement] = None  # Statement/definition being analyzed\n+    future_import_flags: Set[str]\n \n",
        "source_code_with_indent": "    _is_typeshed_stub_file = False  # Are we analyzing a typeshed stub file?\n    imports = None  # type: Set[str]  # Imported modules (during phase 2 analysis)\n    # Note: some imports (and therefore dependencies) might\n    # not be found in phase 1, for example due to * imports.\n    errors = None  # type: Errors     # Keeps track of generated errors\n    plugin = None  # type: Plugin     # Mypy plugin for special casing of library features\n    statement = None  # type: Optional[Statement]  # Statement/definition being analyzed\n    future_import_flags = None  # type: Set[str]\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    _is_typeshed_stub_file = False  # Are we analyzing a typeshed stub file?\n    imports: Set[str]  # Imported modules (during phase 2 analysis)\n    # Note: some imports (and therefore dependencies) might\n    # not be found in phase 1, for example due to * imports.\n    errors: Errors  # Keeps track of generated errors\n    plugin: Plugin  # Mypy plugin for special casing of library features\n    statement: Optional[Statement] = None  # Statement/definition being analyzed\n    future_import_flags: Set[str]\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "python/mypy",
    "commit": "f98f78216ba9d6ab68c8e69c19e9f3c7926c5efe",
    "filename": "mypy/test/data.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/python-mypy/mypy/test/data.py",
    "file_hunks_size": 13,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "mypy/test/data.py:191:4 Incompatible attribute type [8]: Attribute `parent` declared in class `DataDrivenTestCase` has type `DataSuiteCollector` but is used as type `None`.",
    "message": " Attribute `parent` declared in class `DataDrivenTestCase` has type `DataSuiteCollector` but is used as type `None`.",
    "rule_id": "Incompatible attribute type [8]",
    "warning_line_no": 191,
    "warning_line": "    parent = None  # type: DataSuiteCollector"
  },
  {
    "project": "python/mypy",
    "commit": "f98f78216ba9d6ab68c8e69c19e9f3c7926c5efe",
    "filename": "mypy/test/data.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/python-mypy/mypy/test/data.py",
    "file_hunks_size": 13,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "mypy/test/data.py:193:4 Incompatible attribute type [8]: Attribute `input` declared in class `DataDrivenTestCase` has type `List[str]` but is used as type `None`.",
    "message": " Attribute `input` declared in class `DataDrivenTestCase` has type `List[str]` but is used as type `None`.",
    "rule_id": "Incompatible attribute type [8]",
    "warning_line_no": 193,
    "warning_line": "    input = None  # type: List[str]"
  },
  {
    "project": "python/mypy",
    "commit": "f98f78216ba9d6ab68c8e69c19e9f3c7926c5efe",
    "filename": "mypy/test/data.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/python-mypy/mypy/test/data.py",
    "file_hunks_size": 13,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "mypy/test/data.py:194:4 Incompatible attribute type [8]: Attribute `output` declared in class `DataDrivenTestCase` has type `List[str]` but is used as type `None`.",
    "message": " Attribute `output` declared in class `DataDrivenTestCase` has type `List[str]` but is used as type `None`.",
    "rule_id": "Incompatible attribute type [8]",
    "warning_line_no": 194,
    "warning_line": "    output = None  # type: List[str]  # Output for the first pass"
  },
  {
    "project": "python/mypy",
    "commit": "f98f78216ba9d6ab68c8e69c19e9f3c7926c5efe",
    "filename": "mypy/test/data.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/python-mypy/mypy/test/data.py",
    "file_hunks_size": 13,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "mypy/test/data.py:195:4 Incompatible attribute type [8]: Attribute `output2` declared in class `DataDrivenTestCase` has type `Dict[int, List[str]]` but is used as type `None`.",
    "message": " Attribute `output2` declared in class `DataDrivenTestCase` has type `Dict[int, List[str]]` but is used as type `None`.",
    "rule_id": "Incompatible attribute type [8]",
    "warning_line_no": 195,
    "warning_line": "    output2 = None  # type: Dict[int, List[str]]  # Output for runs 2+, indexed by run number"
  },
  {
    "project": "python/mypy",
    "commit": "f98f78216ba9d6ab68c8e69c19e9f3c7926c5efe",
    "filename": "mypy/test/data.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/python-mypy/mypy/test/data.py",
    "file_hunks_size": 13,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "mypy/test/data.py:202:4 Incompatible attribute type [8]: Attribute `files` declared in class `DataDrivenTestCase` has type `List[Tuple[str, str]]` but is used as type `None`.",
    "message": " Attribute `files` declared in class `DataDrivenTestCase` has type `List[Tuple[str, str]]` but is used as type `None`.",
    "rule_id": "Incompatible attribute type [8]",
    "warning_line_no": 202,
    "warning_line": "    files = None  # type: List[Tuple[str, str]]"
  },
  {
    "project": "python/mypy",
    "commit": "f98f78216ba9d6ab68c8e69c19e9f3c7926c5efe",
    "filename": "mypy/test/data.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/python-mypy/mypy/test/data.py",
    "file_hunks_size": 13,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "mypy/test/data.py:203:4 Incompatible attribute type [8]: Attribute `expected_stale_modules` declared in class `DataDrivenTestCase` has type `Dict[int, Set[str]]` but is used as type `None`.",
    "message": " Attribute `expected_stale_modules` declared in class `DataDrivenTestCase` has type `Dict[int, Set[str]]` but is used as type `None`.",
    "rule_id": "Incompatible attribute type [8]",
    "warning_line_no": 203,
    "warning_line": "    expected_stale_modules = None  # type: Dict[int, Set[str]]"
  },
  {
    "project": "python/mypy",
    "commit": "f98f78216ba9d6ab68c8e69c19e9f3c7926c5efe",
    "filename": "mypy/test/data.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/python-mypy/mypy/test/data.py",
    "file_hunks_size": 13,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "mypy/test/data.py:204:4 Incompatible attribute type [8]: Attribute `expected_rechecked_modules` declared in class `DataDrivenTestCase` has type `Dict[int, Set[str]]` but is used as type `None`.",
    "message": " Attribute `expected_rechecked_modules` declared in class `DataDrivenTestCase` has type `Dict[int, Set[str]]` but is used as type `None`.",
    "rule_id": "Incompatible attribute type [8]",
    "warning_line_no": 204,
    "warning_line": "    expected_rechecked_modules = None  # type: Dict[int, Set[str]]"
  },
  {
    "project": "python/mypy",
    "commit": "f98f78216ba9d6ab68c8e69c19e9f3c7926c5efe",
    "filename": "mypy/test/data.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/python-mypy/mypy/test/data.py",
    "file_hunks_size": 13,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "mypy/test/data.py:205:4 Incompatible attribute type [8]: Attribute `expected_fine_grained_targets` declared in class `DataDrivenTestCase` has type `Dict[int, List[str]]` but is used as type `None`.",
    "message": " Attribute `expected_fine_grained_targets` declared in class `DataDrivenTestCase` has type `Dict[int, List[str]]` but is used as type `None`.",
    "rule_id": "Incompatible attribute type [8]",
    "warning_line_no": 205,
    "warning_line": "    expected_fine_grained_targets = None  # type: Dict[int, List[str]]"
  },
  {
    "project": "python/mypy",
    "commit": "f98f78216ba9d6ab68c8e69c19e9f3c7926c5efe",
    "filename": "mypy/test/data.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/python-mypy/mypy/test/data.py",
    "file_hunks_size": 13,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "mypy/test/data.py:212:4 Incompatible attribute type [8]: Attribute `last_line` declared in class `DataDrivenTestCase` has type `int` but is used as type `None`.",
    "message": " Attribute `last_line` declared in class `DataDrivenTestCase` has type `int` but is used as type `None`.",
    "rule_id": "Incompatible attribute type [8]",
    "warning_line_no": 212,
    "warning_line": "    last_line = None  # type: int"
  },
  {
    "project": "python/mypy",
    "commit": "f98f78216ba9d6ab68c8e69c19e9f3c7926c5efe",
    "filename": "mypy/test/data.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/python-mypy/mypy/test/data.py",
    "file_hunks_size": 13,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "mypy/test/data.py:213:4 Incompatible attribute type [8]: Attribute `output_files` declared in class `DataDrivenTestCase` has type `List[Tuple[str, str]]` but is used as type `None`.",
    "message": " Attribute `output_files` declared in class `DataDrivenTestCase` has type `List[Tuple[str, str]]` but is used as type `None`.",
    "rule_id": "Incompatible attribute type [8]",
    "warning_line_no": 213,
    "warning_line": "    output_files = None  # type: List[Tuple[str, str]] # Path and contents for output files"
  },
  {
    "project": "python/mypy",
    "commit": "f98f78216ba9d6ab68c8e69c19e9f3c7926c5efe",
    "filename": "mypy/test/data.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/python-mypy/mypy/test/data.py",
    "file_hunks_size": 13,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "mypy/test/data.py:214:4 Incompatible attribute type [8]: Attribute `deleted_paths` declared in class `DataDrivenTestCase` has type `Dict[int, Set[str]]` but is used as type `None`.",
    "message": " Attribute `deleted_paths` declared in class `DataDrivenTestCase` has type `Dict[int, Set[str]]` but is used as type `None`.",
    "rule_id": "Incompatible attribute type [8]",
    "warning_line_no": 214,
    "warning_line": "    deleted_paths = None  # type: Dict[int, Set[str]]  # Mapping run number -> paths"
  },
  {
    "project": "python/mypy",
    "commit": "f98f78216ba9d6ab68c8e69c19e9f3c7926c5efe",
    "filename": "mypy/test/data.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/python-mypy/mypy/test/data.py",
    "file_hunks_size": 13,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "mypy/test/data.py:215:4 Incompatible attribute type [8]: Attribute `triggered` declared in class `DataDrivenTestCase` has type `List[str]` but is used as type `None`.",
    "message": " Attribute `triggered` declared in class `DataDrivenTestCase` has type `List[str]` but is used as type `None`.",
    "rule_id": "Incompatible attribute type [8]",
    "warning_line_no": 215,
    "warning_line": "    triggered = None  # type: List[str]  # Active triggers (one line per incremental step)"
  },
  {
    "project": "python/mypy",
    "commit": "f98f78216ba9d6ab68c8e69c19e9f3c7926c5efe",
    "filename": "mypy/test/data.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/python-mypy/mypy/test/data.py",
    "file_hunks_size": 13,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": true,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "mypy/test/data.py:357:4 Incompatible attribute type [8]: Attribute `data` declared in class `TestItem` has type `List[str]` but is used as type `None`.",
    "message": " Attribute `data` declared in class `TestItem` has type `List[str]` but is used as type `None`.",
    "rule_id": "Incompatible attribute type [8]",
    "warning_line_no": 357,
    "warning_line": "    data = None  # type: List[str]",
    "min_patch": [
      {
        "hunk_fit_TFix": true,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n    id = ''\n    arg = ''  # type: Optional[str]\n\n    # Text data, array of 8-bit strings\n    data = None  # type: List[str]\n\n",
        "source_code_len": 126,
        "target_code": "\n    id = \"\"\n    arg: Optional[str] = \"\"\n\n    # Text data, array of 8-bit strings\n    data: List[str]\n\n",
        "target_code_len": 103,
        "diff_format": "@@ -352,7 +352,7 @@\n \n-    id = ''\n-    arg = ''  # type: Optional[str]\n+    id = \"\"\n+    arg: Optional[str] = \"\"\n \n     # Text data, array of 8-bit strings\n-    data = None  # type: List[str]\n+    data: List[str]\n \n",
        "source_code_with_indent": "\n    id = ''\n    arg = ''  # type: Optional[str]\n\n    # Text data, array of 8-bit strings\n    data = None  # type: List[str]\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n    id = \"\"\n    arg: Optional[str] = \"\"\n\n    # Text data, array of 8-bit strings\n    data: List[str]\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "python/mypy",
    "commit": "f98f78216ba9d6ab68c8e69c19e9f3c7926c5efe",
    "filename": "mypy/test/data.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/python-mypy/mypy/test/data.py",
    "file_hunks_size": 13,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "mypy/test/data.py:629:4 Incompatible attribute type [8]: Attribute `files` declared in class `DataSuite` has type `List[str]` but is used as type `None`.",
    "message": " Attribute `files` declared in class `DataSuite` has type `List[str]` but is used as type `None`.",
    "rule_id": "Incompatible attribute type [8]",
    "warning_line_no": 629,
    "warning_line": "    files = None  # type: List[str]"
  },
  {
    "project": "python/mypy",
    "commit": "f98f78216ba9d6ab68c8e69c19e9f3c7926c5efe",
    "filename": "mypy/types.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/python-mypy/mypy/types.py",
    "file_hunks_size": 30,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": true,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "mypy/types.py:347:4 Incompatible attribute type [8]: Attribute `id` declared in class `TypeVarLikeDef` has type `TypeVarId` but is used as type `None`.",
    "message": " Attribute `id` declared in class `TypeVarLikeDef` has type `TypeVarId` but is used as type `None`.",
    "rule_id": "Incompatible attribute type [8]",
    "warning_line_no": 347,
    "warning_line": "    id = None  # type: TypeVarId",
    "min_patch": [
      {
        "hunk_fit_TFix": true,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    fullname = ''  # Fully qualified name\n    id = None  # type: TypeVarId\n\n",
        "source_code_len": 76,
        "target_code": "    fullname = ''  # Fully qualified name\n    id: TypeVarId\n\n",
        "target_code_len": 61,
        "diff_format": "@@ -346,3 +352,3 @@\n     fullname = ''  # Fully qualified name\n-    id = None  # type: TypeVarId\n+    id: TypeVarId\n \n",
        "source_code_with_indent": "    fullname = ''  # Fully qualified name\n    id = None  # type: TypeVarId\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    fullname = ''  # Fully qualified name\n    id: TypeVarId\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "python/mypy",
    "commit": "f98f78216ba9d6ab68c8e69c19e9f3c7926c5efe",
    "filename": "mypy/types.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/python-mypy/mypy/types.py",
    "file_hunks_size": 30,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "mypy/types.py:372:4 Incompatible attribute type [8]: Attribute `values` declared in class `TypeVarDef` has type `List[Type]` but is used as type `None`.",
    "message": " Attribute `values` declared in class `TypeVarDef` has type `List[Type]` but is used as type `None`.",
    "rule_id": "Incompatible attribute type [8]",
    "warning_line_no": 372,
    "warning_line": "    values = None  # type: List[Type]  # Value restriction, empty list if no restriction"
  },
  {
    "project": "python/mypy",
    "commit": "f98f78216ba9d6ab68c8e69c19e9f3c7926c5efe",
    "filename": "mypy/types.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/python-mypy/mypy/types.py",
    "file_hunks_size": 30,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "mypy/types.py:373:4 Incompatible attribute type [8]: Attribute `upper_bound` declared in class `TypeVarDef` has type `Type` but is used as type `None`.",
    "message": " Attribute `upper_bound` declared in class `TypeVarDef` has type `Type` but is used as type `None`.",
    "rule_id": "Incompatible attribute type [8]",
    "warning_line_no": 373,
    "warning_line": "    upper_bound = None  # type: Type"
  },
  {
    "project": "python/mypy",
    "commit": "f98f78216ba9d6ab68c8e69c19e9f3c7926c5efe",
    "filename": "mypy/types.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/python-mypy/mypy/types.py",
    "file_hunks_size": 30,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "mypy/types.py:538:4 Incompatible attribute type [8]: Attribute `typ` declared in class `CallableArgument` has type `Type` but is used as type `None`.",
    "message": " Attribute `typ` declared in class `CallableArgument` has type `Type` but is used as type `None`.",
    "rule_id": "Incompatible attribute type [8]",
    "warning_line_no": 538,
    "warning_line": "    typ = None          # type: Type",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    \"\"\"\n    typ = None          # type: Type\n    name = None         # type: Optional[str]\n    constructor = None  # type: Optional[str]\n\n",
        "source_code_len": 138,
        "target_code": "    \"\"\"\n\n    typ: Type\n    name: Optional[str] = None\n    constructor: Optional[str] = None\n\n",
        "target_code_len": 93,
        "diff_format": "@@ -537,5 +544,6 @@\n     \"\"\"\n-    typ = None          # type: Type\n-    name = None         # type: Optional[str]\n-    constructor = None  # type: Optional[str]\n+\n+    typ: Type\n+    name: Optional[str] = None\n+    constructor: Optional[str] = None\n \n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\n    typ = None          # type: Type\n    name = None         # type: Optional[str]\n    constructor = None  # type: Optional[str]\n\n",
        "target_code_with_indent": "\n\n    typ: Type\n    name: Optional[str] = None\n    constructor: Optional[str] = None\n\n"
      }
    ]
  },
  {
    "project": "python/mypy",
    "commit": "f98f78216ba9d6ab68c8e69c19e9f3c7926c5efe",
    "filename": "mypy/types.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/python-mypy/mypy/types.py",
    "file_hunks_size": 30,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": true,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "mypy/types.py:566:4 Incompatible attribute type [8]: Attribute `items` declared in class `TypeList` has type `List[Type]` but is used as type `None`.",
    "message": " Attribute `items` declared in class `TypeList` has type `List[Type]` but is used as type `None`.",
    "rule_id": "Incompatible attribute type [8]",
    "warning_line_no": 566,
    "warning_line": "    items = None  # type: List[Type]",
    "min_patch": [
      {
        "hunk_fit_TFix": true,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n    items = None  # type: List[Type]\n\n",
        "source_code_len": 39,
        "target_code": "\n    items: List[Type]\n\n",
        "target_code_len": 24,
        "diff_format": "@@ -565,3 +573,3 @@\n \n-    items = None  # type: List[Type]\n+    items: List[Type]\n \n",
        "source_code_with_indent": "\n    items = None  # type: List[Type]\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n    items: List[Type]\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "python/mypy",
    "commit": "f98f78216ba9d6ab68c8e69c19e9f3c7926c5efe",
    "filename": "mypy/types.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/python-mypy/mypy/types.py",
    "file_hunks_size": 30,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": true,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "mypy/types.py:1324:4 Incompatible attribute type [8]: Attribute `_items` declared in class `Overloaded` has type `List[CallableType]` but is used as type `None`.",
    "message": " Attribute `_items` declared in class `Overloaded` has type `List[CallableType]` but is used as type `None`.",
    "rule_id": "Incompatible attribute type [8]",
    "warning_line_no": 1324,
    "warning_line": "    _items = None  # type: List[CallableType]  # Must not be empty",
    "min_patch": [
      {
        "hunk_fit_TFix": true,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n    _items = None  # type: List[CallableType]  # Must not be empty\n\n",
        "source_code_len": 69,
        "target_code": "\n    _items: List[CallableType]  # Must not be empty\n\n",
        "target_code_len": 54,
        "diff_format": "@@ -1323,3 +1332,3 @@\n \n-    _items = None  # type: List[CallableType]  # Must not be empty\n+    _items: List[CallableType]  # Must not be empty\n \n",
        "source_code_with_indent": "\n    _items = None  # type: List[CallableType]  # Must not be empty\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n    _items: List[CallableType]  # Must not be empty\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "python/mypy",
    "commit": "f98f78216ba9d6ab68c8e69c19e9f3c7926c5efe",
    "filename": "mypy/types.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/python-mypy/mypy/types.py",
    "file_hunks_size": 30,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": true,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "mypy/types.py:1391:4 Incompatible attribute type [8]: Attribute `items` declared in class `TupleType` has type `List[Type]` but is used as type `None`.",
    "message": " Attribute `items` declared in class `TupleType` has type `List[Type]` but is used as type `None`.",
    "rule_id": "Incompatible attribute type [8]",
    "warning_line_no": 1391,
    "warning_line": "    items = None  # type: List[Type]",
    "min_patch": [
      {
        "hunk_fit_TFix": true,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n    items = None  # type: List[Type]\n    partial_fallback = None  # type: Instance\n    implicit = False\n",
        "source_code_len": 105,
        "target_code": "\n    items: List[Type]\n    partial_fallback: Instance\n    implicit = False\n",
        "target_code_len": 75,
        "diff_format": "@@ -1390,4 +1399,4 @@\n \n-    items = None  # type: List[Type]\n-    partial_fallback = None  # type: Instance\n+    items: List[Type]\n+    partial_fallback: Instance\n     implicit = False\n",
        "source_code_with_indent": "\n    items = None  # type: List[Type]\n    partial_fallback = None  # type: Instance\n    implicit = False\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n    items: List[Type]\n    partial_fallback: Instance\n    implicit = False\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "python/mypy",
    "commit": "f98f78216ba9d6ab68c8e69c19e9f3c7926c5efe",
    "filename": "mypy/types.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/python-mypy/mypy/types.py",
    "file_hunks_size": 30,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": true,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "mypy/types.py:1392:4 Incompatible attribute type [8]: Attribute `partial_fallback` declared in class `TupleType` has type `Instance` but is used as type `None`.",
    "message": " Attribute `partial_fallback` declared in class `TupleType` has type `Instance` but is used as type `None`.",
    "rule_id": "Incompatible attribute type [8]",
    "warning_line_no": 1392,
    "warning_line": "    partial_fallback = None  # type: Instance",
    "min_patch": [
      {
        "hunk_fit_TFix": true,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n    items = None  # type: List[Type]\n    partial_fallback = None  # type: Instance\n    implicit = False\n",
        "source_code_len": 105,
        "target_code": "\n    items: List[Type]\n    partial_fallback: Instance\n    implicit = False\n",
        "target_code_len": 75,
        "diff_format": "@@ -1390,4 +1399,4 @@\n \n-    items = None  # type: List[Type]\n-    partial_fallback = None  # type: Instance\n+    items: List[Type]\n+    partial_fallback: Instance\n     implicit = False\n",
        "source_code_with_indent": "\n    items = None  # type: List[Type]\n    partial_fallback = None  # type: Instance\n    implicit = False\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n    items: List[Type]\n    partial_fallback: Instance\n    implicit = False\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "python/mypy",
    "commit": "f98f78216ba9d6ab68c8e69c19e9f3c7926c5efe",
    "filename": "mypy/types.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/python-mypy/mypy/types.py",
    "file_hunks_size": 30,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": true,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "mypy/types.py:1466:4 Incompatible attribute type [8]: Attribute `items` declared in class `TypedDictType` has type `Dict[str, Type]` but is used as type `None`.",
    "message": " Attribute `items` declared in class `TypedDictType` has type `Dict[str, Type]` but is used as type `None`.",
    "rule_id": "Incompatible attribute type [8]",
    "warning_line_no": 1466,
    "warning_line": "    items = None  # type: OrderedDict[str, Type]  # item_name -> item_type",
    "min_patch": [
      {
        "hunk_fit_TFix": true,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n    items = None  # type: OrderedDict[str, Type]  # item_name -> item_type\n    required_keys = None  # type: Set[str]\n    fallback = None  # type: Instance\n\n",
        "source_code_len": 158,
        "target_code": "\n    items: \"OrderedDict[str, Type]\"  # item_name -> item_type\n    required_keys: Set[str]\n    fallback: Instance\n\n",
        "target_code_len": 115,
        "diff_format": "@@ -1465,5 +1474,5 @@\n \n-    items = None  # type: OrderedDict[str, Type]  # item_name -> item_type\n-    required_keys = None  # type: Set[str]\n-    fallback = None  # type: Instance\n+    items: \"OrderedDict[str, Type]\"  # item_name -> item_type\n+    required_keys: Set[str]\n+    fallback: Instance\n \n",
        "source_code_with_indent": "\n    items = None  # type: OrderedDict[str, Type]  # item_name -> item_type\n    required_keys = None  # type: Set[str]\n    fallback = None  # type: Instance\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n    items: \"OrderedDict[str, Type]\"  # item_name -> item_type\n    required_keys: Set[str]\n    fallback: Instance\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "python/mypy",
    "commit": "f98f78216ba9d6ab68c8e69c19e9f3c7926c5efe",
    "filename": "mypy/types.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/python-mypy/mypy/types.py",
    "file_hunks_size": 30,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": true,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "mypy/types.py:1467:4 Incompatible attribute type [8]: Attribute `required_keys` declared in class `TypedDictType` has type `Set[str]` but is used as type `None`.",
    "message": " Attribute `required_keys` declared in class `TypedDictType` has type `Set[str]` but is used as type `None`.",
    "rule_id": "Incompatible attribute type [8]",
    "warning_line_no": 1467,
    "warning_line": "    required_keys = None  # type: Set[str]",
    "min_patch": [
      {
        "hunk_fit_TFix": true,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n    items = None  # type: OrderedDict[str, Type]  # item_name -> item_type\n    required_keys = None  # type: Set[str]\n    fallback = None  # type: Instance\n\n",
        "source_code_len": 158,
        "target_code": "\n    items: \"OrderedDict[str, Type]\"  # item_name -> item_type\n    required_keys: Set[str]\n    fallback: Instance\n\n",
        "target_code_len": 115,
        "diff_format": "@@ -1465,5 +1474,5 @@\n \n-    items = None  # type: OrderedDict[str, Type]  # item_name -> item_type\n-    required_keys = None  # type: Set[str]\n-    fallback = None  # type: Instance\n+    items: \"OrderedDict[str, Type]\"  # item_name -> item_type\n+    required_keys: Set[str]\n+    fallback: Instance\n \n",
        "source_code_with_indent": "\n    items = None  # type: OrderedDict[str, Type]  # item_name -> item_type\n    required_keys = None  # type: Set[str]\n    fallback = None  # type: Instance\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n    items: \"OrderedDict[str, Type]\"  # item_name -> item_type\n    required_keys: Set[str]\n    fallback: Instance\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "python/mypy",
    "commit": "f98f78216ba9d6ab68c8e69c19e9f3c7926c5efe",
    "filename": "mypy/types.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/python-mypy/mypy/types.py",
    "file_hunks_size": 30,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": true,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "mypy/types.py:1468:4 Incompatible attribute type [8]: Attribute `fallback` declared in class `TypedDictType` has type `Instance` but is used as type `None`.",
    "message": " Attribute `fallback` declared in class `TypedDictType` has type `Instance` but is used as type `None`.",
    "rule_id": "Incompatible attribute type [8]",
    "warning_line_no": 1468,
    "warning_line": "    fallback = None  # type: Instance",
    "min_patch": [
      {
        "hunk_fit_TFix": true,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n    items = None  # type: OrderedDict[str, Type]  # item_name -> item_type\n    required_keys = None  # type: Set[str]\n    fallback = None  # type: Instance\n\n",
        "source_code_len": 158,
        "target_code": "\n    items: \"OrderedDict[str, Type]\"  # item_name -> item_type\n    required_keys: Set[str]\n    fallback: Instance\n\n",
        "target_code_len": 115,
        "diff_format": "@@ -1465,5 +1474,5 @@\n \n-    items = None  # type: OrderedDict[str, Type]  # item_name -> item_type\n-    required_keys = None  # type: Set[str]\n-    fallback = None  # type: Instance\n+    items: \"OrderedDict[str, Type]\"  # item_name -> item_type\n+    required_keys: Set[str]\n+    fallback: Instance\n \n",
        "source_code_with_indent": "\n    items = None  # type: OrderedDict[str, Type]  # item_name -> item_type\n    required_keys = None  # type: Set[str]\n    fallback = None  # type: Instance\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n    items: \"OrderedDict[str, Type]\"  # item_name -> item_type\n    required_keys: Set[str]\n    fallback: Instance\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "python/mypy",
    "commit": "f98f78216ba9d6ab68c8e69c19e9f3c7926c5efe",
    "filename": "mypy/types.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/python-mypy/mypy/types.py",
    "file_hunks_size": 30,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": true,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "mypy/types.py:1730:4 Incompatible attribute type [8]: Attribute `type` declared in class `StarType` has type `Type` but is used as type `None`.",
    "message": " Attribute `type` declared in class `StarType` has type `Type` but is used as type `None`.",
    "rule_id": "Incompatible attribute type [8]",
    "warning_line_no": 1730,
    "warning_line": "    type = None  # type: Type",
    "min_patch": [
      {
        "hunk_fit_TFix": true,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n    type = None  # type: Type\n\n",
        "source_code_len": 32,
        "target_code": "\n    type: Type\n\n",
        "target_code_len": 17,
        "diff_format": "@@ -1729,3 +1738,3 @@\n \n-    type = None  # type: Type\n+    type: Type\n \n",
        "source_code_with_indent": "\n    type = None  # type: Type\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n    type: Type\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "python/mypy",
    "commit": "f98f78216ba9d6ab68c8e69c19e9f3c7926c5efe",
    "filename": "mypy/types.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/python-mypy/mypy/types.py",
    "file_hunks_size": 30,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": true,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "mypy/types.py:1837:4 Incompatible attribute type [8]: Attribute `var` declared in class `PartialType` has type `mypy.nodes.Var` but is used as type `None`.",
    "message": " Attribute `var` declared in class `PartialType` has type `mypy.nodes.Var` but is used as type `None`.",
    "rule_id": "Incompatible attribute type [8]",
    "warning_line_no": 1837,
    "warning_line": "    var = None  # type: mypy.nodes.Var",
    "min_patch": [
      {
        "hunk_fit_TFix": true,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    # None for the 'None' partial type; otherwise a generic class\n    type = None  # type: Optional[mypy.nodes.TypeInfo]\n    var = None  # type: mypy.nodes.Var\n    # For partial defaultdict[K, V], the type V (K is unknown). If V is generic,\n    # the type argument is Any and will be replaced later.\n    value_type = None  # type: Optional[Instance]\n\n",
        "source_code_len": 351,
        "target_code": "    # None for the 'None' partial type; otherwise a generic class\n    type: Optional[mypy.nodes.TypeInfo] = None\n    var: mypy.nodes.Var\n    # For partial defaultdict[K, V], the type V (K is unknown). If V is generic,\n    # the type argument is Any and will be replaced later.\n    value_type: Optional[Instance] = None\n\n",
        "target_code_len": 320,
        "diff_format": "@@ -1835,7 +1844,7 @@\n     # None for the 'None' partial type; otherwise a generic class\n-    type = None  # type: Optional[mypy.nodes.TypeInfo]\n-    var = None  # type: mypy.nodes.Var\n+    type: Optional[mypy.nodes.TypeInfo] = None\n+    var: mypy.nodes.Var\n     # For partial defaultdict[K, V], the type V (K is unknown). If V is generic,\n     # the type argument is Any and will be replaced later.\n-    value_type = None  # type: Optional[Instance]\n+    value_type: Optional[Instance] = None\n \n",
        "source_code_with_indent": "    # None for the 'None' partial type; otherwise a generic class\n    type = None  # type: Optional[mypy.nodes.TypeInfo]\n    var = None  # type: mypy.nodes.Var\n    # For partial defaultdict[K, V], the type V (K is unknown). If V is generic,\n    # the type argument is Any and will be replaced later.\n    value_type = None  # type: Optional[Instance]\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    # None for the 'None' partial type; otherwise a generic class\n    type: Optional[mypy.nodes.TypeInfo] = None\n    var: mypy.nodes.Var\n    # For partial defaultdict[K, V], the type V (K is unknown). If V is generic,\n    # the type argument is Any and will be replaced later.\n    value_type: Optional[Instance] = None\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "python/mypy",
    "commit": "f98f78216ba9d6ab68c8e69c19e9f3c7926c5efe",
    "filename": "mypy/types.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/python-mypy/mypy/types.py",
    "file_hunks_size": 30,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": true,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "mypy/types.py:1901:4 Incompatible attribute type [8]: Attribute `item` declared in class `TypeType` has type `ProperType` but is used as type `None`.",
    "message": " Attribute `item` declared in class `TypeType` has type `ProperType` but is used as type `None`.",
    "rule_id": "Incompatible attribute type [8]",
    "warning_line_no": 1901,
    "warning_line": "    item = None  # type: ProperType",
    "min_patch": [
      {
        "hunk_fit_TFix": true,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    # a generic class instance, a union, Any, a type variable...\n    item = None  # type: ProperType\n\n",
        "source_code_len": 102,
        "target_code": "    # a generic class instance, a union, Any, a type variable...\n    item: ProperType\n\n",
        "target_code_len": 87,
        "diff_format": "@@ -1900,3 +1909,3 @@\n     # a generic class instance, a union, Any, a type variable...\n-    item = None  # type: ProperType\n+    item: ProperType\n \n",
        "source_code_with_indent": "    # a generic class instance, a union, Any, a type variable...\n    item = None  # type: ProperType\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    # a generic class instance, a union, Any, a type variable...\n    item: ProperType\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "python/mypy",
    "commit": "f98f78216ba9d6ab68c8e69c19e9f3c7926c5efe",
    "filename": "mypyc/test-data/fixtures/testutil.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/python-mypy/mypyc/test-data/fixtures/testutil.py",
    "file_hunks_size": 1,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": true,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "mypyc/test-data/fixtures/testutil.py:23:22 Invalid type [31]: Expression `typing.List[$local_mypyc?test.__sub__(data?fixtures?testutil$T)]` is not a valid type.",
    "message": " Expression `typing.List[$local_mypyc?test.__sub__(data?fixtures?testutil$T)]` is not a valid type.",
    "rule_id": "Invalid type [31]",
    "warning_line_no": 23,
    "warning_line": "    res = []  # type: List[T]",
    "min_patch": [
      {
        "hunk_fit_TFix": true,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "                  p: bool = False) -> Tuple[Sequence[T], Union[U, str]]:\n    res = []  # type: List[T]\n    i = -1\n",
        "source_code_len": 114,
        "target_code": "                  p: bool = False) -> Tuple[Sequence[T], Union[U, str]]:\n    res: List[T] = []\n    i = -1\n",
        "target_code_len": 106,
        "diff_format": "@@ -22,3 +22,3 @@\n                   p: bool = False) -> Tuple[Sequence[T], Union[U, str]]:\n-    res = []  # type: List[T]\n+    res: List[T] = []\n     i = -1\n",
        "source_code_with_indent": "                  p: bool = False) -> Tuple[Sequence[T], Union[U, str]]:\n    <IND>res = []  # type: List[T]\n    i = -1\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "                  p: bool = False) -> Tuple[Sequence[T], Union[U, str]]:\n    <IND>res: List[T] = []\n    i = -1\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  }
]