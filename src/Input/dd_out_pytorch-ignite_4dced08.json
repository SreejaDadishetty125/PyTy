[
  {
    "project": "pytorch/ignite",
    "commit": "4dced08f4ee294c36f54c4c64c7d60adb6aefc72",
    "filename": "ignite/engine/events.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/pytorch-ignite/ignite/engine/events.py",
    "file_hunks_size": 8,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "ignite/engine/events.py:70:35 Incompatible parameter type [6]: Expected `typing.Callable[..., typing.Any]` for 2nd positional only parameter to call `_check_signature` but got `Optional[typing.Callable[..., typing.Any]]`.",
    "message": " Expected `typing.Callable[..., typing.Any]` for 2nd positional only parameter to call `_check_signature` but got `Optional[typing.Callable[..., typing.Any]]`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 70,
    "warning_line": "        _check_signature(\"engine\", event_filter, \"event_filter\", \"event\")",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "import weakref\n\n",
        "source_code_len": 16,
        "target_code": "import weakref\nfrom types import DynamicClassAttribute\n\n",
        "target_code_len": 56,
        "diff_format": "@@ -5,2 +5,3 @@\n import weakref\n+from types import DynamicClassAttribute\n \n",
        "source_code_with_indent": "import weakref\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "import weakref\nfrom types import DynamicClassAttribute\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n\n__all__ = [\"Events\", \"State\"]\n\n\nclass EventWithFilter:\n    def __init__(self, event: Any, filter: Callable):\n        if not callable(filter):\n            raise TypeError(\"Argument filter should be callable\")\n        self.event = event\n        self.filter = filter\n\n    def __str__(self) -> str:\n        return \"<%s event=%s, filter=%r>\" % (self.__class__.__name__, self.event, self.filter)\n\n\nclass CallableEvents:\n    \"\"\"Base class for Events implementing call operator and storing event filter. This class should be inherited\n    for any custom events with event filtering feature:\n\n    .. code-block:: python\n\n        from ignite.engine.engine import CallableEvents\n\n        class CustomEvents(CallableEvents, Enum):\n            TEST_EVENT = \"test_event\"\n\n        engine = ...\n        engine.register_events(*CustomEvents, event_to_attr={CustomEvents.TEST_EVENT: \"test_event\"})\n\n        @engine.on(CustomEvents.TEST_EVENT(every=5))\n        def call_on_test_event_every(engine):\n            # do something\n\n    \"\"\"\n\n    def __call__(\n        self, event_filter: Optional[Callable] = None, every: Optional[int] = None, once: Optional[int] = None\n    ):\n\n",
        "source_code_len": 1156,
        "target_code": "\n__all__ = [\n    'Events',\n    'State'\n]\n\n\nclass CallableEventWithFilter:\n    \"\"\"Single Event containing a filter, specifying whether the event should\n    be run at the current event (if the event type is correct)\n\n    Args:\n        value (str): The actual enum value. Only needed for internal use. Do not touch!\n        event_filter (callable): A function taking the engine and the current event value as input and returning a\n            boolean to indicate whether this event should be executed. Defaults to None, which will result to a\n            function that always returns `True`\n        name (str, optional): The enum-name of the current object. Only needed for internal use. Do not touch!\n\n    \"\"\"\n\n    def __init__(self, value: str, event_filter: Optional[Callable] = None,\n                 name=None):\n        if event_filter is None:\n            event_filter = CallableEventWithFilter.default_event_filter\n        self.filter = event_filter\n\n        if not hasattr(self, '_value_'):\n            self._value_ = value\n\n        if not hasattr(self, '_name_') and name is not None:\n            self._name_ = name\n\n    # copied to be compatible to enum\n    @DynamicClassAttribute\n    def name(self):\n        \"\"\"The name of the Enum member.\"\"\"\n        return self._name_\n\n    @DynamicClassAttribute\n    def value(self):\n        \"\"\"The value of the Enum member.\"\"\"\n        return self._value_\n\n    # Will return CallableEventWithFilter but can't annotate that way due to python <= 3.7\n    def __call__(self, event_filter: Optional[Callable] = None,\n                 every: Optional[int] = None, once: Optional[int] = None) -> Any:\n        \"\"\"\n        Makes the event class callable and accepts either an arbitrary callable as filter\n        (which must take in the engine and current event value and return a boolean) or an every or once value\n\n        Args:\n            event_filter (callable, optional): a filter function to check if the event should be executed when\n                the event type was fired\n            every (int, optional): a value specifying how often the event should be fired\n            once (int, optional): a value specifying when the event should be fired (if only once)\n\n        Returns:\n            CallableEventWithFilter: A new event having the same value but a different filter function\n        \"\"\"\n\n",
        "target_code_len": 2340,
        "diff_format": "@@ -8,40 +9,60 @@\n \n-\n-__all__ = [\"Events\", \"State\"]\n-\n-\n-class EventWithFilter:\n-    def __init__(self, event: Any, filter: Callable):\n-        if not callable(filter):\n-            raise TypeError(\"Argument filter should be callable\")\n-        self.event = event\n-        self.filter = filter\n-\n-    def __str__(self) -> str:\n-        return \"<%s event=%s, filter=%r>\" % (self.__class__.__name__, self.event, self.filter)\n-\n-\n-class CallableEvents:\n-    \"\"\"Base class for Events implementing call operator and storing event filter. This class should be inherited\n-    for any custom events with event filtering feature:\n-\n-    .. code-block:: python\n-\n-        from ignite.engine.engine import CallableEvents\n-\n-        class CustomEvents(CallableEvents, Enum):\n-            TEST_EVENT = \"test_event\"\n-\n-        engine = ...\n-        engine.register_events(*CustomEvents, event_to_attr={CustomEvents.TEST_EVENT: \"test_event\"})\n-\n-        @engine.on(CustomEvents.TEST_EVENT(every=5))\n-        def call_on_test_event_every(engine):\n-            # do something\n-\n-    \"\"\"\n-\n-    def __call__(\n-        self, event_filter: Optional[Callable] = None, every: Optional[int] = None, once: Optional[int] = None\n-    ):\n+__all__ = [\n+    'Events',\n+    'State'\n+]\n+\n+\n+class CallableEventWithFilter:\n+    \"\"\"Single Event containing a filter, specifying whether the event should\n+    be run at the current event (if the event type is correct)\n+\n+    Args:\n+        value (str): The actual enum value. Only needed for internal use. Do not touch!\n+        event_filter (callable): A function taking the engine and the current event value as input and returning a\n+            boolean to indicate whether this event should be executed. Defaults to None, which will result to a\n+            function that always returns `True`\n+        name (str, optional): The enum-name of the current object. Only needed for internal use. Do not touch!\n+\n+    \"\"\"\n+\n+    def __init__(self, value: str, event_filter: Optional[Callable] = None,\n+                 name=None):\n+        if event_filter is None:\n+            event_filter = CallableEventWithFilter.default_event_filter\n+        self.filter = event_filter\n+\n+        if not hasattr(self, '_value_'):\n+            self._value_ = value\n+\n+        if not hasattr(self, '_name_') and name is not None:\n+            self._name_ = name\n+\n+    # copied to be compatible to enum\n+    @DynamicClassAttribute\n+    def name(self):\n+        \"\"\"The name of the Enum member.\"\"\"\n+        return self._name_\n+\n+    @DynamicClassAttribute\n+    def value(self):\n+        \"\"\"The value of the Enum member.\"\"\"\n+        return self._value_\n+\n+    # Will return CallableEventWithFilter but can't annotate that way due to python <= 3.7\n+    def __call__(self, event_filter: Optional[Callable] = None,\n+                 every: Optional[int] = None, once: Optional[int] = None) -> Any:\n+        \"\"\"\n+        Makes the event class callable and accepts either an arbitrary callable as filter\n+        (which must take in the engine and current event value and return a boolean) or an every or once value\n+\n+        Args:\n+            event_filter (callable, optional): a filter function to check if the event should be executed when\n+                the event type was fired\n+            every (int, optional): a value specifying how often the event should be fired\n+            once (int, optional): a value specifying when the event should be fired (if only once)\n+\n+        Returns:\n+            CallableEventWithFilter: A new event having the same value but a different filter function\n+        \"\"\"\n \n",
        "source_code_with_indent": "\n\n__all__ = [\"Events\", \"State\"]\n\n\nclass EventWithFilter:\n    <IND>def __init__(self, event: Any, filter: Callable):\n        <IND>if not callable(filter):\n            <IND>raise TypeError(\"Argument filter should be callable\")\n        <DED>self.event = event\n        self.filter = filter\n\n    <DED>def __str__(self) -> str:\n        <IND>return \"<%s event=%s, filter=%r>\" % (self.__class__.__name__, self.event, self.filter)\n\n\n<DED><DED>class CallableEvents:\n    <IND>\"\"\"Base class for Events implementing call operator and storing event filter. This class should be inherited\n    for any custom events with event filtering feature:\n\n    .. code-block:: python\n\n        from ignite.engine.engine import CallableEvents\n\n        class CustomEvents(CallableEvents, Enum):\n            TEST_EVENT = \"test_event\"\n\n        engine = ...\n        engine.register_events(*CustomEvents, event_to_attr={CustomEvents.TEST_EVENT: \"test_event\"})\n\n        @engine.on(CustomEvents.TEST_EVENT(every=5))\n        def call_on_test_event_every(engine):\n            # do something\n\n    \"\"\"\n\n    def __call__(\n        self, event_filter: Optional[Callable] = None, every: Optional[int] = None, once: Optional[int] = None\n    ):\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n__all__ = [\n    'Events',\n    'State'\n]\n\n\nclass CallableEventWithFilter:\n    <IND>\"\"\"Single Event containing a filter, specifying whether the event should\n    be run at the current event (if the event type is correct)\n\n    Args:\n        value (str): The actual enum value. Only needed for internal use. Do not touch!\n        event_filter (callable): A function taking the engine and the current event value as input and returning a\n            boolean to indicate whether this event should be executed. Defaults to None, which will result to a\n            function that always returns `True`\n        name (str, optional): The enum-name of the current object. Only needed for internal use. Do not touch!\n\n    \"\"\"\n\n    def __init__(self, value: str, event_filter: Optional[Callable] = None,\n                 name=None):\n        <IND>if event_filter is None:\n            <IND>event_filter = CallableEventWithFilter.default_event_filter\n        <DED>self.filter = event_filter\n\n        if not hasattr(self, '_value_'):\n            <IND>self._value_ = value\n\n        <DED>if not hasattr(self, '_name_') and name is not None:\n            <IND>self._name_ = name\n\n    # copied to be compatible to enum\n    <DED><DED>@DynamicClassAttribute\n    def name(self):\n        <IND>\"\"\"The name of the Enum member.\"\"\"\n        return self._name_\n\n    <DED>@DynamicClassAttribute\n    def value(self):\n        <IND>\"\"\"The value of the Enum member.\"\"\"\n        return self._value_\n\n    # Will return CallableEventWithFilter but can't annotate that way due to python <= 3.7\n    <DED>def __call__(self, event_filter: Optional[Callable] = None,\n                 every: Optional[int] = None, once: Optional[int] = None) -> Any:\n        <IND>\"\"\"\n        Makes the event class callable and accepts either an arbitrary callable as filter\n        (which must take in the engine and current event value and return a boolean) or an every or once value\n\n        Args:\n            event_filter (callable, optional): a filter function to check if the event should be executed when\n                the event type was fired\n            every (int, optional): a value specifying how often the event should be fired\n            once (int, optional): a value specifying when the event should be fired (if only once)\n\n        Returns:\n            CallableEventWithFilter: A new event having the same value but a different filter function\n        \"\"\"\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "                # Just return the event itself\n                return self\n            event_filter = CallableEvents.every_event_filter(every)\n\n        if once is not None:\n            event_filter = CallableEvents.once_event_filter(once)\n\n        # check signature:\n        _check_signature(\"engine\", event_filter, \"event_filter\", \"event\")\n\n        return EventWithFilter(self, event_filter)\n\n",
        "source_code_len": 394,
        "target_code": "                # Just return the event itself\n                event_filter = None\n            else:\n                event_filter = self.every_event_filter(every)\n\n        if once is not None:\n            event_filter = self.once_event_filter(once)\n\n        # check signature:\n        if event_filter is not None:\n            _check_signature(\"engine\", event_filter, \"event_filter\", \"event\")\n\n        return CallableEventWithFilter(self.value, event_filter, self.name)\n\n",
        "target_code_len": 470,
        "diff_format": "@@ -62,12 +83,14 @@\n                 # Just return the event itself\n-                return self\n-            event_filter = CallableEvents.every_event_filter(every)\n+                event_filter = None\n+            else:\n+                event_filter = self.every_event_filter(every)\n \n         if once is not None:\n-            event_filter = CallableEvents.once_event_filter(once)\n+            event_filter = self.once_event_filter(once)\n \n         # check signature:\n-        _check_signature(\"engine\", event_filter, \"event_filter\", \"event\")\n-\n-        return EventWithFilter(self, event_filter)\n+        if event_filter is not None:\n+            _check_signature(\"engine\", event_filter, \"event_filter\", \"event\")\n+\n+        return CallableEventWithFilter(self.value, event_filter, self.name)\n \n",
        "source_code_with_indent": "                # Just return the event itself\n                <IND>return self\n            <DED>event_filter = CallableEvents.every_event_filter(every)\n\n        <DED>if once is not None:\n            <IND>event_filter = CallableEvents.once_event_filter(once)\n\n        # check signature:\n        <DED>_check_signature(\"engine\", event_filter, \"event_filter\", \"event\")\n\n        return EventWithFilter(self, event_filter)\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "                # Just return the event itself\n                <IND>event_filter = None\n            <DED>else:\n                <IND>event_filter = self.every_event_filter(every)\n\n        <DED><DED>if once is not None:\n            <IND>event_filter = self.once_event_filter(once)\n\n        # check signature:\n        <DED>if event_filter is not None:\n            <IND>_check_signature(\"engine\", event_filter, \"event_filter\", \"event\")\n\n        <DED>return CallableEventWithFilter(self.value, event_filter, self.name)\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n\nclass Events(CallableEvents, Enum):\n    \"\"\"Events that are fired by the :class:`~ignite.engine.Engine` during execution.\n",
        "source_code_len": 123,
        "target_code": "\n    @staticmethod\n    def default_event_filter(engine, event: int) -> bool:\n        return True\n\n    def __str__(self) -> str:\n        return \"<event=%s, filter=%r>\" % (self.name, self.filter)\n\n    def __eq__(self, other):\n        if isinstance(other, CallableEventWithFilter):\n            return self.name == other.name\n        elif isinstance(other, str):\n            return self.name == other\n        else:\n            raise NotImplementedError\n\n    def __hash__(self):\n        return hash(self._name_)\n\n\nclass EventEnum(CallableEventWithFilter, Enum):\n    pass\n\n\nclass Events(EventEnum):\n    \"\"\"Events that are fired by the :class:`~ignite.engine.Engine` during execution.\n",
        "target_code_len": 678,
        "diff_format": "@@ -91,4 +114,26 @@\n \n-\n-class Events(CallableEvents, Enum):\n+    @staticmethod\n+    def default_event_filter(engine, event: int) -> bool:\n+        return True\n+\n+    def __str__(self) -> str:\n+        return \"<event=%s, filter=%r>\" % (self.name, self.filter)\n+\n+    def __eq__(self, other):\n+        if isinstance(other, CallableEventWithFilter):\n+            return self.name == other.name\n+        elif isinstance(other, str):\n+            return self.name == other\n+        else:\n+            raise NotImplementedError\n+\n+    def __hash__(self):\n+        return hash(self._name_)\n+\n+\n+class EventEnum(CallableEventWithFilter, Enum):\n+    pass\n+\n+\n+class Events(EventEnum):\n     \"\"\"Events that are fired by the :class:`~ignite.engine.Engine` during execution.\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\n\n<DED><DED>class Events(CallableEvents, Enum):\n    <IND>",
        "target_code_with_indent": "\n    <DED>@staticmethod\n    def default_event_filter(engine, event: int) -> bool:\n        <IND>return True\n\n    <DED>def __str__(self) -> str:\n        <IND>return \"<event=%s, filter=%r>\" % (self.name, self.filter)\n\n    <DED>def __eq__(self, other):\n        <IND>if isinstance(other, CallableEventWithFilter):\n            <IND>return self.name == other.name\n        <DED>elif isinstance(other, str):\n            <IND>return self.name == other\n        <DED>else:\n            <IND>raise NotImplementedError\n\n    <DED><DED>def __hash__(self):\n        <IND>return hash(self._name_)\n\n\n<DED><DED>class EventEnum(CallableEventWithFilter, Enum):\n    <IND>pass\n\n\n<DED>class Events(EventEnum):\n    <IND>"
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n    def get_event_attrib_value(self, event_name: Union[EventWithFilter, CallableEvents, Enum]) -> int:\n        if isinstance(event_name, EventWithFilter):\n            event_name = event_name.event\n        if event_name not in State.event_to_attr:\n",
        "source_code_len": 248,
        "target_code": "\n    def get_event_attrib_value(self, event_name: Union[CallableEventWithFilter, Enum]) -> int:\n        if event_name not in State.event_to_attr:\n",
        "target_code_len": 146,
        "diff_format": "@@ -185,5 +232,3 @@\n \n-    def get_event_attrib_value(self, event_name: Union[EventWithFilter, CallableEvents, Enum]) -> int:\n-        if isinstance(event_name, EventWithFilter):\n-            event_name = event_name.event\n+    def get_event_attrib_value(self, event_name: Union[CallableEventWithFilter, Enum]) -> int:\n         if event_name not in State.event_to_attr:\n",
        "source_code_with_indent": "\n    <DED><DED><DED>def get_event_attrib_value(self, event_name: Union[EventWithFilter, CallableEvents, Enum]) -> int:\n        <IND>if isinstance(event_name, EventWithFilter):\n            <IND>event_name = event_name.event\n        <DED>if event_name not in State.event_to_attr:\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n    <DED><DED><DED>def get_event_attrib_value(self, event_name: Union[CallableEventWithFilter, Enum]) -> int:\n        <IND>if event_name not in State.event_to_attr:\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n    def __init__(self, event_name: Union[EventWithFilter, CallableEvents, Enum], handler: Callable, engine):\n        self.event_name = event_name\n",
        "source_code_len": 147,
        "target_code": "\n    def __init__(self, event_name: Union[CallableEventWithFilter, Enum], handler: Callable, engine):\n        self.event_name = event_name\n",
        "target_code_len": 139,
        "diff_format": "@@ -230,3 +275,3 @@\n \n-    def __init__(self, event_name: Union[EventWithFilter, CallableEvents, Enum], handler: Callable, engine):\n+    def __init__(self, event_name: Union[CallableEventWithFilter, Enum], handler: Callable, engine):\n         self.event_name = event_name\n",
        "source_code_with_indent": "\n    def __init__(self, event_name: Union[EventWithFilter, CallableEvents, Enum], handler: Callable, engine):\n        <IND>self.event_name = event_name\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n    def __init__(self, event_name: Union[CallableEventWithFilter, Enum], handler: Callable, engine):\n        <IND>self.event_name = event_name\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "pytorch/ignite",
    "commit": "4dced08f4ee294c36f54c4c64c7d60adb6aefc72",
    "filename": "ignite/engine/events.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/pytorch-ignite/ignite/engine/events.py",
    "file_hunks_size": 8,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "ignite/engine/events.py:72:37 Incompatible parameter type [6]: Expected `typing.Callable[..., typing.Any]` for 2nd positional only parameter to call `EventWithFilter.__init__` but got `Optional[typing.Callable[..., typing.Any]]`.",
    "message": " Expected `typing.Callable[..., typing.Any]` for 2nd positional only parameter to call `EventWithFilter.__init__` but got `Optional[typing.Callable[..., typing.Any]]`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 72,
    "warning_line": "        return EventWithFilter(self, event_filter)",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "import weakref\n\n",
        "source_code_len": 16,
        "target_code": "import weakref\nfrom types import DynamicClassAttribute\n\n",
        "target_code_len": 56,
        "diff_format": "@@ -5,2 +5,3 @@\n import weakref\n+from types import DynamicClassAttribute\n \n",
        "source_code_with_indent": "import weakref\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "import weakref\nfrom types import DynamicClassAttribute\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n\n__all__ = [\"Events\", \"State\"]\n\n\nclass EventWithFilter:\n    def __init__(self, event: Any, filter: Callable):\n        if not callable(filter):\n            raise TypeError(\"Argument filter should be callable\")\n        self.event = event\n        self.filter = filter\n\n    def __str__(self) -> str:\n        return \"<%s event=%s, filter=%r>\" % (self.__class__.__name__, self.event, self.filter)\n\n\nclass CallableEvents:\n    \"\"\"Base class for Events implementing call operator and storing event filter. This class should be inherited\n    for any custom events with event filtering feature:\n\n    .. code-block:: python\n\n        from ignite.engine.engine import CallableEvents\n\n        class CustomEvents(CallableEvents, Enum):\n            TEST_EVENT = \"test_event\"\n\n        engine = ...\n        engine.register_events(*CustomEvents, event_to_attr={CustomEvents.TEST_EVENT: \"test_event\"})\n\n        @engine.on(CustomEvents.TEST_EVENT(every=5))\n        def call_on_test_event_every(engine):\n            # do something\n\n    \"\"\"\n\n    def __call__(\n        self, event_filter: Optional[Callable] = None, every: Optional[int] = None, once: Optional[int] = None\n    ):\n\n",
        "source_code_len": 1156,
        "target_code": "\n__all__ = [\n    'Events',\n    'State'\n]\n\n\nclass CallableEventWithFilter:\n    \"\"\"Single Event containing a filter, specifying whether the event should\n    be run at the current event (if the event type is correct)\n\n    Args:\n        value (str): The actual enum value. Only needed for internal use. Do not touch!\n        event_filter (callable): A function taking the engine and the current event value as input and returning a\n            boolean to indicate whether this event should be executed. Defaults to None, which will result to a\n            function that always returns `True`\n        name (str, optional): The enum-name of the current object. Only needed for internal use. Do not touch!\n\n    \"\"\"\n\n    def __init__(self, value: str, event_filter: Optional[Callable] = None,\n                 name=None):\n        if event_filter is None:\n            event_filter = CallableEventWithFilter.default_event_filter\n        self.filter = event_filter\n\n        if not hasattr(self, '_value_'):\n            self._value_ = value\n\n        if not hasattr(self, '_name_') and name is not None:\n            self._name_ = name\n\n    # copied to be compatible to enum\n    @DynamicClassAttribute\n    def name(self):\n        \"\"\"The name of the Enum member.\"\"\"\n        return self._name_\n\n    @DynamicClassAttribute\n    def value(self):\n        \"\"\"The value of the Enum member.\"\"\"\n        return self._value_\n\n    # Will return CallableEventWithFilter but can't annotate that way due to python <= 3.7\n    def __call__(self, event_filter: Optional[Callable] = None,\n                 every: Optional[int] = None, once: Optional[int] = None) -> Any:\n        \"\"\"\n        Makes the event class callable and accepts either an arbitrary callable as filter\n        (which must take in the engine and current event value and return a boolean) or an every or once value\n\n        Args:\n            event_filter (callable, optional): a filter function to check if the event should be executed when\n                the event type was fired\n            every (int, optional): a value specifying how often the event should be fired\n            once (int, optional): a value specifying when the event should be fired (if only once)\n\n        Returns:\n            CallableEventWithFilter: A new event having the same value but a different filter function\n        \"\"\"\n\n",
        "target_code_len": 2340,
        "diff_format": "@@ -8,40 +9,60 @@\n \n-\n-__all__ = [\"Events\", \"State\"]\n-\n-\n-class EventWithFilter:\n-    def __init__(self, event: Any, filter: Callable):\n-        if not callable(filter):\n-            raise TypeError(\"Argument filter should be callable\")\n-        self.event = event\n-        self.filter = filter\n-\n-    def __str__(self) -> str:\n-        return \"<%s event=%s, filter=%r>\" % (self.__class__.__name__, self.event, self.filter)\n-\n-\n-class CallableEvents:\n-    \"\"\"Base class for Events implementing call operator and storing event filter. This class should be inherited\n-    for any custom events with event filtering feature:\n-\n-    .. code-block:: python\n-\n-        from ignite.engine.engine import CallableEvents\n-\n-        class CustomEvents(CallableEvents, Enum):\n-            TEST_EVENT = \"test_event\"\n-\n-        engine = ...\n-        engine.register_events(*CustomEvents, event_to_attr={CustomEvents.TEST_EVENT: \"test_event\"})\n-\n-        @engine.on(CustomEvents.TEST_EVENT(every=5))\n-        def call_on_test_event_every(engine):\n-            # do something\n-\n-    \"\"\"\n-\n-    def __call__(\n-        self, event_filter: Optional[Callable] = None, every: Optional[int] = None, once: Optional[int] = None\n-    ):\n+__all__ = [\n+    'Events',\n+    'State'\n+]\n+\n+\n+class CallableEventWithFilter:\n+    \"\"\"Single Event containing a filter, specifying whether the event should\n+    be run at the current event (if the event type is correct)\n+\n+    Args:\n+        value (str): The actual enum value. Only needed for internal use. Do not touch!\n+        event_filter (callable): A function taking the engine and the current event value as input and returning a\n+            boolean to indicate whether this event should be executed. Defaults to None, which will result to a\n+            function that always returns `True`\n+        name (str, optional): The enum-name of the current object. Only needed for internal use. Do not touch!\n+\n+    \"\"\"\n+\n+    def __init__(self, value: str, event_filter: Optional[Callable] = None,\n+                 name=None):\n+        if event_filter is None:\n+            event_filter = CallableEventWithFilter.default_event_filter\n+        self.filter = event_filter\n+\n+        if not hasattr(self, '_value_'):\n+            self._value_ = value\n+\n+        if not hasattr(self, '_name_') and name is not None:\n+            self._name_ = name\n+\n+    # copied to be compatible to enum\n+    @DynamicClassAttribute\n+    def name(self):\n+        \"\"\"The name of the Enum member.\"\"\"\n+        return self._name_\n+\n+    @DynamicClassAttribute\n+    def value(self):\n+        \"\"\"The value of the Enum member.\"\"\"\n+        return self._value_\n+\n+    # Will return CallableEventWithFilter but can't annotate that way due to python <= 3.7\n+    def __call__(self, event_filter: Optional[Callable] = None,\n+                 every: Optional[int] = None, once: Optional[int] = None) -> Any:\n+        \"\"\"\n+        Makes the event class callable and accepts either an arbitrary callable as filter\n+        (which must take in the engine and current event value and return a boolean) or an every or once value\n+\n+        Args:\n+            event_filter (callable, optional): a filter function to check if the event should be executed when\n+                the event type was fired\n+            every (int, optional): a value specifying how often the event should be fired\n+            once (int, optional): a value specifying when the event should be fired (if only once)\n+\n+        Returns:\n+            CallableEventWithFilter: A new event having the same value but a different filter function\n+        \"\"\"\n \n",
        "source_code_with_indent": "\n\n__all__ = [\"Events\", \"State\"]\n\n\nclass EventWithFilter:\n    <IND>def __init__(self, event: Any, filter: Callable):\n        <IND>if not callable(filter):\n            <IND>raise TypeError(\"Argument filter should be callable\")\n        <DED>self.event = event\n        self.filter = filter\n\n    <DED>def __str__(self) -> str:\n        <IND>return \"<%s event=%s, filter=%r>\" % (self.__class__.__name__, self.event, self.filter)\n\n\n<DED><DED>class CallableEvents:\n    <IND>\"\"\"Base class for Events implementing call operator and storing event filter. This class should be inherited\n    for any custom events with event filtering feature:\n\n    .. code-block:: python\n\n        from ignite.engine.engine import CallableEvents\n\n        class CustomEvents(CallableEvents, Enum):\n            TEST_EVENT = \"test_event\"\n\n        engine = ...\n        engine.register_events(*CustomEvents, event_to_attr={CustomEvents.TEST_EVENT: \"test_event\"})\n\n        @engine.on(CustomEvents.TEST_EVENT(every=5))\n        def call_on_test_event_every(engine):\n            # do something\n\n    \"\"\"\n\n    def __call__(\n        self, event_filter: Optional[Callable] = None, every: Optional[int] = None, once: Optional[int] = None\n    ):\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n__all__ = [\n    'Events',\n    'State'\n]\n\n\nclass CallableEventWithFilter:\n    <IND>\"\"\"Single Event containing a filter, specifying whether the event should\n    be run at the current event (if the event type is correct)\n\n    Args:\n        value (str): The actual enum value. Only needed for internal use. Do not touch!\n        event_filter (callable): A function taking the engine and the current event value as input and returning a\n            boolean to indicate whether this event should be executed. Defaults to None, which will result to a\n            function that always returns `True`\n        name (str, optional): The enum-name of the current object. Only needed for internal use. Do not touch!\n\n    \"\"\"\n\n    def __init__(self, value: str, event_filter: Optional[Callable] = None,\n                 name=None):\n        <IND>if event_filter is None:\n            <IND>event_filter = CallableEventWithFilter.default_event_filter\n        <DED>self.filter = event_filter\n\n        if not hasattr(self, '_value_'):\n            <IND>self._value_ = value\n\n        <DED>if not hasattr(self, '_name_') and name is not None:\n            <IND>self._name_ = name\n\n    # copied to be compatible to enum\n    <DED><DED>@DynamicClassAttribute\n    def name(self):\n        <IND>\"\"\"The name of the Enum member.\"\"\"\n        return self._name_\n\n    <DED>@DynamicClassAttribute\n    def value(self):\n        <IND>\"\"\"The value of the Enum member.\"\"\"\n        return self._value_\n\n    # Will return CallableEventWithFilter but can't annotate that way due to python <= 3.7\n    <DED>def __call__(self, event_filter: Optional[Callable] = None,\n                 every: Optional[int] = None, once: Optional[int] = None) -> Any:\n        <IND>\"\"\"\n        Makes the event class callable and accepts either an arbitrary callable as filter\n        (which must take in the engine and current event value and return a boolean) or an every or once value\n\n        Args:\n            event_filter (callable, optional): a filter function to check if the event should be executed when\n                the event type was fired\n            every (int, optional): a value specifying how often the event should be fired\n            once (int, optional): a value specifying when the event should be fired (if only once)\n\n        Returns:\n            CallableEventWithFilter: A new event having the same value but a different filter function\n        \"\"\"\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "                # Just return the event itself\n                return self\n            event_filter = CallableEvents.every_event_filter(every)\n\n        if once is not None:\n            event_filter = CallableEvents.once_event_filter(once)\n\n        # check signature:\n        _check_signature(\"engine\", event_filter, \"event_filter\", \"event\")\n\n        return EventWithFilter(self, event_filter)\n\n",
        "source_code_len": 394,
        "target_code": "                # Just return the event itself\n                event_filter = None\n            else:\n                event_filter = self.every_event_filter(every)\n\n        if once is not None:\n            event_filter = self.once_event_filter(once)\n\n        # check signature:\n        if event_filter is not None:\n            _check_signature(\"engine\", event_filter, \"event_filter\", \"event\")\n\n        return CallableEventWithFilter(self.value, event_filter, self.name)\n\n",
        "target_code_len": 470,
        "diff_format": "@@ -62,12 +83,14 @@\n                 # Just return the event itself\n-                return self\n-            event_filter = CallableEvents.every_event_filter(every)\n+                event_filter = None\n+            else:\n+                event_filter = self.every_event_filter(every)\n \n         if once is not None:\n-            event_filter = CallableEvents.once_event_filter(once)\n+            event_filter = self.once_event_filter(once)\n \n         # check signature:\n-        _check_signature(\"engine\", event_filter, \"event_filter\", \"event\")\n-\n-        return EventWithFilter(self, event_filter)\n+        if event_filter is not None:\n+            _check_signature(\"engine\", event_filter, \"event_filter\", \"event\")\n+\n+        return CallableEventWithFilter(self.value, event_filter, self.name)\n \n",
        "source_code_with_indent": "                # Just return the event itself\n                <IND>return self\n            <DED>event_filter = CallableEvents.every_event_filter(every)\n\n        <DED>if once is not None:\n            <IND>event_filter = CallableEvents.once_event_filter(once)\n\n        # check signature:\n        <DED>_check_signature(\"engine\", event_filter, \"event_filter\", \"event\")\n\n        return EventWithFilter(self, event_filter)\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "                # Just return the event itself\n                <IND>event_filter = None\n            <DED>else:\n                <IND>event_filter = self.every_event_filter(every)\n\n        <DED><DED>if once is not None:\n            <IND>event_filter = self.once_event_filter(once)\n\n        # check signature:\n        <DED>if event_filter is not None:\n            <IND>_check_signature(\"engine\", event_filter, \"event_filter\", \"event\")\n\n        <DED>return CallableEventWithFilter(self.value, event_filter, self.name)\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n\nclass Events(CallableEvents, Enum):\n    \"\"\"Events that are fired by the :class:`~ignite.engine.Engine` during execution.\n",
        "source_code_len": 123,
        "target_code": "\n    @staticmethod\n    def default_event_filter(engine, event: int) -> bool:\n        return True\n\n    def __str__(self) -> str:\n        return \"<event=%s, filter=%r>\" % (self.name, self.filter)\n\n    def __eq__(self, other):\n        if isinstance(other, CallableEventWithFilter):\n            return self.name == other.name\n        elif isinstance(other, str):\n            return self.name == other\n        else:\n            raise NotImplementedError\n\n    def __hash__(self):\n        return hash(self._name_)\n\n\nclass EventEnum(CallableEventWithFilter, Enum):\n    pass\n\n\nclass Events(EventEnum):\n    \"\"\"Events that are fired by the :class:`~ignite.engine.Engine` during execution.\n",
        "target_code_len": 678,
        "diff_format": "@@ -91,4 +114,26 @@\n \n-\n-class Events(CallableEvents, Enum):\n+    @staticmethod\n+    def default_event_filter(engine, event: int) -> bool:\n+        return True\n+\n+    def __str__(self) -> str:\n+        return \"<event=%s, filter=%r>\" % (self.name, self.filter)\n+\n+    def __eq__(self, other):\n+        if isinstance(other, CallableEventWithFilter):\n+            return self.name == other.name\n+        elif isinstance(other, str):\n+            return self.name == other\n+        else:\n+            raise NotImplementedError\n+\n+    def __hash__(self):\n+        return hash(self._name_)\n+\n+\n+class EventEnum(CallableEventWithFilter, Enum):\n+    pass\n+\n+\n+class Events(EventEnum):\n     \"\"\"Events that are fired by the :class:`~ignite.engine.Engine` during execution.\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\n\n<DED><DED>class Events(CallableEvents, Enum):\n    <IND>",
        "target_code_with_indent": "\n    <DED>@staticmethod\n    def default_event_filter(engine, event: int) -> bool:\n        <IND>return True\n\n    <DED>def __str__(self) -> str:\n        <IND>return \"<event=%s, filter=%r>\" % (self.name, self.filter)\n\n    <DED>def __eq__(self, other):\n        <IND>if isinstance(other, CallableEventWithFilter):\n            <IND>return self.name == other.name\n        <DED>elif isinstance(other, str):\n            <IND>return self.name == other\n        <DED>else:\n            <IND>raise NotImplementedError\n\n    <DED><DED>def __hash__(self):\n        <IND>return hash(self._name_)\n\n\n<DED><DED>class EventEnum(CallableEventWithFilter, Enum):\n    <IND>pass\n\n\n<DED>class Events(EventEnum):\n    <IND>"
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n    def get_event_attrib_value(self, event_name: Union[EventWithFilter, CallableEvents, Enum]) -> int:\n        if isinstance(event_name, EventWithFilter):\n            event_name = event_name.event\n        if event_name not in State.event_to_attr:\n",
        "source_code_len": 248,
        "target_code": "\n    def get_event_attrib_value(self, event_name: Union[CallableEventWithFilter, Enum]) -> int:\n        if event_name not in State.event_to_attr:\n",
        "target_code_len": 146,
        "diff_format": "@@ -185,5 +232,3 @@\n \n-    def get_event_attrib_value(self, event_name: Union[EventWithFilter, CallableEvents, Enum]) -> int:\n-        if isinstance(event_name, EventWithFilter):\n-            event_name = event_name.event\n+    def get_event_attrib_value(self, event_name: Union[CallableEventWithFilter, Enum]) -> int:\n         if event_name not in State.event_to_attr:\n",
        "source_code_with_indent": "\n    <DED><DED><DED>def get_event_attrib_value(self, event_name: Union[EventWithFilter, CallableEvents, Enum]) -> int:\n        <IND>if isinstance(event_name, EventWithFilter):\n            <IND>event_name = event_name.event\n        <DED>if event_name not in State.event_to_attr:\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n    <DED><DED><DED>def get_event_attrib_value(self, event_name: Union[CallableEventWithFilter, Enum]) -> int:\n        <IND>if event_name not in State.event_to_attr:\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n    def __init__(self, event_name: Union[EventWithFilter, CallableEvents, Enum], handler: Callable, engine):\n        self.event_name = event_name\n",
        "source_code_len": 147,
        "target_code": "\n    def __init__(self, event_name: Union[CallableEventWithFilter, Enum], handler: Callable, engine):\n        self.event_name = event_name\n",
        "target_code_len": 139,
        "diff_format": "@@ -230,3 +275,3 @@\n \n-    def __init__(self, event_name: Union[EventWithFilter, CallableEvents, Enum], handler: Callable, engine):\n+    def __init__(self, event_name: Union[CallableEventWithFilter, Enum], handler: Callable, engine):\n         self.event_name = event_name\n",
        "source_code_with_indent": "\n    def __init__(self, event_name: Union[EventWithFilter, CallableEvents, Enum], handler: Callable, engine):\n        <IND>self.event_name = event_name\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n    def __init__(self, event_name: Union[CallableEventWithFilter, Enum], handler: Callable, engine):\n        <IND>self.event_name = event_name\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  }
]