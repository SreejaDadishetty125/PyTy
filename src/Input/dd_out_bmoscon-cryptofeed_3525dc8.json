[
  {
    "project": "bmoscon/cryptofeed",
    "commit": "3525dc8ce4d7836a9abaaa5662e58e5e27969a77",
    "filename": "cryptofeed/symbols.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/bmoscon-cryptofeed/cryptofeed/symbols.py",
    "file_hunks_size": 1,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "cryptofeed/symbols.py:149:8 Incompatible return type [7]: Expected `Dict[str, str]` but got implicit return value of `None`.",
    "message": " Expected `Dict[str, str]` but got implicit return value of `None`.",
    "rule_id": "Incompatible return type [7]",
    "warning_line_no": 149,
    "warning_line": "        raise_failure_explanation('BITFINEX', why, {\"tickers?symbols=ALL\": r1, \"pub:map:currency:sym\": r2})",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "associated with this software.\n\n\nSymbol generation code for exchanges\n'''\n\nimport logging\nimport string\nimport time\nfrom collections import defaultdict\nfrom typing import Dict, List, Optional, Tuple\n\nimport requests\nfrom requests import Response\n\nfrom cryptofeed.defines import *\n\n\nLOG = logging.getLogger('feedhandler')\n\nSYMBOL_SEP = '-'\n\n_symbols_retrieval_cache: Dict[str, Dict[str, str]] = {}\n_exchange_info = defaultdict(lambda: defaultdict(dict))\n\n\n_kraken_futures_product_type = {\n    'FI': 'Inverse Futures',\n    'FV': 'Vanilla Futures',\n    'PI': 'Perpetual Inverse Futures',\n    'PV': 'Perpetual Vanilla Futures',\n    'IN': 'Real Time Index',\n    'RR': 'Reference Rate',\n}\n\n\ndef raise_failure_explanation(feed_id: str, exception: BaseException, responses: Dict[str, Optional[Response]]):\n    LOG.critical('%s: encountered %r while processing response from exchange API', feed_id, exception)\n    if len(responses) > 1:\n        LOG.critical('%s: content of one of the %s responses was unexpected', feed_id, len(responses))\n    for url, r in responses.items():\n        if url:\n            LOG.critical('%s: requested URL: %s', feed_id, url)\n        if r:\n            LOG.critical('%s: unexpected response: %s', feed_id, r.text)\n    raise ValueError(f'Cryptofeed stopped because of an unexpected response from {feed_id}') from exception\n\n\ndef set_symbol_separator(separator: str):\n    global SYMBOL_SEP\n    SYMBOL_SEP = separator\n\n\ndef get_symbol_separator() -> str:\n    global SYMBOL_SEP\n    return SYMBOL_SEP\n\n\ndef gen_symbols(exchange: str, key_id=None) -> Dict[str, str]:\n    if exchange not in _symbols_retrieval_cache:\n        LOG.info(\"%s: Getting list of symbols\", exchange)\n        symbols = _exchange_function_map[exchange](key_id) if key_id else _exchange_function_map[exchange]()\n        LOG.info(\"%s: %s symbols\", exchange, len(symbols))\n\n        # log all retrieved symbols using debug level\n        for normalized, exch_sym in sorted(symbols.items()):\n            LOG.debug('%s: id-from-exch -> normalized: %-35s-> %s', exchange, exch_sym, normalized)\n\n        _symbols_retrieval_cache[exchange] = symbols\n    return _symbols_retrieval_cache[exchange]\n\n\ndef _binance_symbols(endpoint: str, exchange: str):\n    r = None\n    try:\n        ret = {}\n        r = requests.get(endpoint)\n        for symbol in r.json()['symbols']:\n            if symbol.get('status', 'TRADING') != \"TRADING\":\n                continue\n            if symbol.get('contractStatus', 'TRADING') != \"TRADING\":\n                continue\n            split = len(symbol['baseAsset'])\n            normalized = symbol['symbol'][:split] + SYMBOL_SEP + symbol['symbol'][split:]\n            ret[normalized] = symbol['symbol']\n            _exchange_info[exchange]['tick_size'][normalized] = symbol['filters'][0]['tickSize']\n            if \"contractType\" in symbol:\n                _exchange_info[exchange]['contract_type'][normalized] = symbol['contractType']\n        return ret\n    except Exception as why:\n        raise_failure_explanation(exchange, why, {endpoint: r})\n\n\ndef binance_symbols() -> Dict[str, str]:\n    return _binance_symbols('https://api.binance.com/api/v3/exchangeInfo', BINANCE)\n\n\ndef binance_us_symbols() -> Dict[str, str]:\n    return _binance_symbols('https://api.binance.us/api/v3/exchangeInfo', BINANCE_US)\n\n\ndef binance_futures_symbols() -> Dict[str, str]:\n    base = _binance_symbols('https://fapi.binance.com/fapi/v1/exchangeInfo', BINANCE_FUTURES)\n    add = {}\n    for symbol, orig in base.items():\n        if \"_\" in orig:\n            continue\n        add[f\"{symbol}-PINDEX\"] = f\"p{orig}\"\n    base.update(add)\n    return base\n\n\ndef binance_delivery_symbols() -> Dict[str, str]:\n    return _binance_symbols('https://dapi.binance.com/dapi/v1/exchangeInfo', BINANCE_DELIVERY)\n\n\ndef bitfinex_symbols() -> Dict[str, str]:\n    # doc: https://docs.bitfinex.com/docs/ws-general#supported-pairs\n    r1 = r2 = None\n    try:\n        r1 = requests.get('https://api.bitfinex.com/v2/tickers?symbols=ALL')\n        r2 = requests.get('https://api-pub.bitfinex.com/v2/conf/pub:map:currency:sym')\n        tickers: List[List[str]] = r1.json()\n        norm: List[Tuple[str, str]] = r2.json()[0]\n        norm: Dict[str, str] = dict(norm)\n        for k, v in dict(norm).items():\n            if k[-2:] == 'F0' or '-' in v:  # Do not convert BTCF0 -> BTC or PBTCETH -> PBTC-ETH\n                del norm[k]\n        norm['BCHN'] = 'BCH'  # Bitfinex uses BCHN, other exchanges use BCH\n\n        ret = {}\n        for symbol in [t[0] for t in tickers]:\n            if symbol[0] == 'f':\n                normalized = norm.get(symbol[1:], symbol[1:])\n            else:\n                if len(symbol) == 7:\n                    base, quote = symbol[1:4], symbol[4:]\n                else:\n                    base, quote = symbol[1:].split(':')\n                    assert ':' in symbol\n                normalized = norm.get(base, base) + SYMBOL_SEP + norm.get(quote, quote)\n            ret[normalized.upper()] = symbol\n        return ret\n    except ValueError as why:\n        raise_failure_explanation('BITFINEX', why, {\"tickers?symbols=ALL\": r1, \"pub:map:currency:sym\": r2})\n\n\ndef bitflyer_symbols() -> Dict[str, str]:\n    endpoint = r = None\n    try:\n        ret = {}\n        endpoints = ['https://api.bitflyer.com/v1/getmarkets/eu', 'https://api.bitflyer.com/v1/getmarkets/usa', 'https://api.bitflyer.com/v1/getmarkets']\n        for endpoint in endpoints:\n            r = requests.get(endpoint)\n            for entry in r.json():\n                normalized = entry['product_code'].replace(\"_\", SYMBOL_SEP)\n                ret[normalized] = entry['product_code']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('BITFLYER', why, {endpoint: r})\n\n\ndef bybit_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.bybit.com/v2/public/symbols')\n        ret = {}\n        for symbol in r.json()['result']:\n            quote = symbol['quote_currency']\n            if not symbol['name'].endswith(quote):\n                base, contract = symbol['name'].split(quote)\n                normalized = f\"{base}{SYMBOL_SEP}{quote}-{contract}\"\n            else:\n                normalized = f\"{symbol['base_currency']}{SYMBOL_SEP}{quote}\"\n            ret[normalized] = symbol['name']\n            _exchange_info[BYBIT]['tick_size'][normalized] = symbol['price_filter']['tick_size']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('BYBIT', why, {\"\": r})\n\n\ndef _ftx_helper(endpoint: str, exchange: str):\n    r = None\n    try:\n        r = requests.get(endpoint)\n        ret = {}\n        for data in r.json()['result']:\n            normalized = data['name'].replace(\"/\", SYMBOL_SEP)\n            symbol = data['name']\n            ret[normalized] = symbol\n            _exchange_info[exchange]['tick_size'][normalized] = data['priceIncrement']\n        return ret\n    except Exception as why:\n        raise_failure_explanation(exchange, why, {endpoint: r})\n\n\ndef ftx_symbols() -> Dict[str, str]:\n    return _ftx_helper('https://ftx.com/api/markets', FTX)\n\n\ndef ftx_us_symbols() -> Dict[str, str]:\n    return _ftx_helper('https://ftx.us/api/markets', FTX_US)\n\n\ndef coinbase_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.pro.coinbase.com/products')\n        ret = {}\n        for data in r.json():\n            normalized = data['id'].replace(\"-\", SYMBOL_SEP)\n            ret[normalized] = data['id']\n            _exchange_info[COINBASE]['tick_size'][normalized] = data['quote_increment']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('COINBASE', why, {\"\": r})\n\n\ndef gemini_symbols(*args) -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.gemini.com/v1/symbols')\n        ret = {}\n        for symbol in r.json():\n            std = f\"{symbol[:-3]}{SYMBOL_SEP}{symbol[-3:]}\"\n            std = std.upper()\n            ret[std] = symbol.upper()\n        return ret\n    except Exception as why:\n        raise_failure_explanation('GEMINI', why, {\"\": r})\n\n\ndef hitbtc_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        ret = {}\n        r = requests.get('https://api.hitbtc.com/api/2/public/symbol')\n        for symbol in r.json():\n            split = len(symbol['baseCurrency'])\n            normalized = symbol['id'][:split] + SYMBOL_SEP + symbol['id'][split:]\n            ret[normalized] = symbol['id']\n            _exchange_info[HITBTC]['tick_size'][normalized] = symbol['tickSize']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('HITBTC', why, {\"\": r})\n\n\ndef poloniex_id_symbol_mapping():\n    r = None\n    try:\n        r = requests.get('https://poloniex.com/public?command=returnTicker')\n        symbols = r.json()\n        ret = {}\n        for symbol in symbols:\n            ret[symbols[symbol]['id']] = symbol\n        return ret\n    except Exception as why:\n        raise_failure_explanation('POLONIEX', why, {\"\": r})\n\n\ndef poloniex_symbols() -> Dict[str, str]:\n    ret = {}\n    for _, value in poloniex_id_symbol_mapping().items():\n        std = value.replace(\"STR\", \"XLM\")\n        quote, base = std.split(\"_\")\n        ret[quote + SYMBOL_SEP + base] = value\n    return ret\n\n\ndef bitstamp_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://www.bitstamp.net/api/v2/trading-pairs-info/')\n        ret = {}\n        for data in r.json():\n            normalized = data['name'].replace(\"/\", SYMBOL_SEP)\n            symbol = data['url_symbol']\n            ret[normalized] = symbol\n        return ret\n    except Exception as why:\n        raise_failure_explanation('BITSTAMP', why, {\"\": r})\n\n\ndef kraken_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.kraken.com/0/public/AssetPairs')\n        data = r.json()\n        ret = {}\n        for symbol in data['result']:\n            if 'wsname' not in data['result'][symbol] or '.d' in symbol:\n                # https://blog.kraken.com/post/259/introducing-the-kraken-dark-pool/\n                # .d is for dark pool symbols\n                continue\n\n            base, quote = data['result'][symbol]['wsname'].split(\"/\")\n\n            normalized = f\"{base}{SYMBOL_SEP}{quote}\"\n            exch = data['result'][symbol]['wsname']\n            normalized = normalized.replace('XBT', 'BTC')\n            normalized = normalized.replace('XDG', 'DOG')\n            ret[normalized] = exch\n        return ret\n    except Exception as why:\n        raise_failure_explanation('KRAKEN', why, {\"\": r})\n\n\ndef kraken_rest_symbols() -> Dict[str, str]:\n    return {normalized: exchange.replace(\"/\", \"\") for normalized, exchange in kraken_symbols().items()}\n\n\ndef exx_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.exx.com/data/v1/tickers')\n        exchange = [key.upper() for key in r.json().keys()]\n        symbols = [key.replace(\"_\", SYMBOL_SEP) for key in exchange]\n        return dict(zip(symbols, exchange))\n    except Exception as why:\n        raise_failure_explanation('EXX', why, {\"\": r})\n\n\ndef huobi_common_symbols(url: str):\n    r = None\n    try:\n        r = requests.get(url)\n        ret = {}\n        for e in r.json()['data']:\n            if e['state'] == 'offline':\n                continue\n            normalized = f\"{e['base-currency'].upper()}{SYMBOL_SEP}{e['quote-currency'].upper()}\"\n            symbol = f\"{e['base-currency']}{e['quote-currency']}\"\n            ret[normalized] = symbol\n        return ret\n    except Exception as why:\n        raise_failure_explanation('HUOBI', why, {url: r})\n\n\ndef huobi_symbols() -> Dict[str, str]:\n    return huobi_common_symbols('https://api.huobi.pro/v1/common/symbols')\n\n\ndef huobi_us_symbols() -> Dict[str, str]:\n    return huobi_common_symbols('https://api.huobi.com/v1/common/symbols')\n\n\ndef huobi_dm_symbols() -> Dict[str, str]:\n    \"\"\"\n    Mapping is, for instance: {\"BTC_CW\":\"BTC190816\"}\n    See comments in exchange/huobi_dm.py\n    \"\"\"\n    mapping = {\n        \"this_week\": \"CW\",\n        \"next_week\": \"NW\",\n        \"quarter\": \"CQ\",\n        \"next_quarter\": \"NQ\"\n    }\n    r = None\n    try:\n        r = requests.get('https://www.hbdm.com/api/v1/contract_contract_info')\n        symbols = {}\n        for e in r.json()['data']:\n            symbols[f\"{e['symbol']}_{mapping[e['contract_type']]}\"] = e['contract_code']\n            _exchange_info[HUOBI_DM]['tick_size'][e['contract_code']] = e['price_tick']\n            _exchange_info[HUOBI_DM]['short_code_mappings'][f\"{e['symbol']}_{mapping[e['contract_type']]}\"] = e['contract_code']\n        return symbols\n    except Exception as why:\n        raise_failure_explanation('HUOBI_DM', why, {\"\": r})\n\n\ndef huobi_swap_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.hbdm.com/swap-api/v1/swap_contract_info')\n        symbols = {}\n        for e in r.json()['data']:\n            symbols[e['contract_code']] = e['contract_code']\n            _exchange_info[HUOBI_SWAP]['tick_size'][e['contract_code']] = e['price_tick']\n        return symbols\n    except Exception as why:\n        raise_failure_explanation('HUOBI_SWAP', why, {\"\": r})\n\n\ndef okcoin_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://www.okcoin.com/api/spot/v3/instruments')\n        ret = {}\n        for e in r.json():\n            ret[e['instrument_id']] = e['instrument_id']\n            _exchange_info[OKCOIN]['tick_size'][e['instrument_id']] = e['tick_size']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('OKCOIN', why, {\"\": r})\n\n\ndef okex_symbols(*args) -> Dict[str, str]:\n    urls = ['https://www.okex.com/api/spot/v3/instruments',\n            'https://www.okex.com/api/swap/v3/instruments',\n            'https://www.okex.com/api/futures/v3/instruments']\n    urls = urls + okex_compute_option_urls_from_underlyings()\n\n    symbols: Dict[str, str] = {}\n    for u in urls:\n        time.sleep(0.2)\n        symbols.update(okex_symbols_from_one_url(u))\n\n    for symbol in symbols:\n        instrument_type = 'futures'\n        dash_count = symbol.count(get_symbol_separator())\n        if dash_count == 1:  # BTC-USDT\n            instrument_type = 'spot'\n        if dash_count == 4:  # BTC-USD-201225-35000-P\n            instrument_type = 'option'\n        if symbol[-4:] == \"SWAP\":  # BTC-USDT-SWAP\n            instrument_type = 'swap'\n\n        _exchange_info[OKEX]['instrument_type'][symbol] = instrument_type\n\n    return symbols\n\n\ndef okex_compute_option_urls_from_underlyings() -> List[str]:\n    url = 'https://www.okex.com/api/option/v3/underlying'\n    r = None\n    try:\n        r = requests.get(url)\n        return [f'https://www.okex.com/api/option/v3/instruments/{underlying}' for underlying in r.json()]\n    except Exception as why:\n        raise_failure_explanation('OKEX', why, {url: r})\n\n\ndef okex_symbols_from_one_url(url: str) -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get(url)\n        ret = {}\n        for e in r.json():\n            ret[e['instrument_id']] = e['instrument_id']\n            _exchange_info[OKEX]['tick_size'][e['instrument_id']] = e['tick_size']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('OKEX', why, {url: r})\n\n\ndef bittrex_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.bittrex.com/api/v1.1/public/getmarkets')\n        r = r.json()['result']\n        return {f\"{e['MarketCurrency']}{SYMBOL_SEP}{e['BaseCurrency']}\": e['MarketName'] for e in r if e['IsActive']}\n    except Exception as why:\n        raise_failure_explanation('BITTREX', why, {\"\": r})\n\n\ndef bitcoincom_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.exchange.bitcoin.com/api/2/public/symbol')\n        return {f\"{data['baseCurrency']}{SYMBOL_SEP}{data['quoteCurrency'].replace('USD', 'USDT')}\": data['id'] for data in r.json()}\n    except Exception as why:\n        raise_failure_explanation('BITCOINCOM', why, {\"\": r})\n\n\ndef bitmax_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://bitmax.io/api/pro/v1/products')\n        ret = {}\n        for entry in r.json()['data']:\n            # Only \"Normal\" status symbols are tradeable\n            if entry['status'] == 'Normal':\n                normalized = f\"{entry['baseAsset']}{SYMBOL_SEP}{entry['quoteAsset']}\"\n                ret[normalized] = entry['symbol']\n                _exchange_info[BITMAX]['tick_size'][normalized] = entry['tickSize']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('BITMAX', why, {\"\": r})\n\n\ndef upbit_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.upbit.com/v1/market/all')\n        return {f\"{data['market'].split('-')[1]}{SYMBOL_SEP}{data['market'].split('-')[0]}\": data['market'] for data in r.json()}\n    except Exception as why:\n        raise_failure_explanation('UPBIT', why, {\"\": r})\n\n\ndef blockchain_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get(\"https://api.blockchain.com/mercury-gateway/v1/instruments\")\n        return {data[\"symbol\"].replace(\"-\", SYMBOL_SEP): data[\"symbol\"] for data in r.json()}\n    except Exception as why:\n        raise_failure_explanation('BLOCKCHAIN', why, {\"\": r})\n\n\ndef gateio_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get(\"https://api.gateio.ws/api/v4/spot/currency_pairs\")\n        return {data[\"id\"].replace(\"_\", SYMBOL_SEP): data['id'] for data in r.json()}\n    except Exception as why:\n        raise_failure_explanation('GATEIO', why, {\"\": r})\n\n\ndef bitmex_symbols() -> Dict[str, str]:\n    r = None\n    ret = {}\n    try:\n        r = requests.get(\"https://www.bitmex.com/api/v1/instrument/active\")\n        for entry in r.json():\n            components = []\n            components.append(entry['rootSymbol'])\n            components.append(entry['quoteCurrency'])\n\n            if entry['expiry']:\n                components.append(entry['symbol'][-3:])\n\n            normalized = SYMBOL_SEP.join(components)\n            normalized = normalized.replace(\"XBT\", \"BTC\")\n            ret[normalized] = entry['symbol']\n            _exchange_info[BITMEX]['tick_size'][normalized] = entry['tickSize']\n\n            if entry['expiry']:\n                _exchange_info[BITMEX]['expiry'][normalized] = entry['expiry']\n\n        return ret\n    except Exception as why:\n        raise_failure_explanation('BITMEX', why, {\"\": r})\n\n\ndef deribit_symbols() -> Dict[str, str]:\n    url = r = None\n    ret = {}\n    try:\n        # TODO: get currencies from https://www.deribit.com/api/v2/public/get_currencies\n        currencies = ['BTC', 'ETH']\n        for c in currencies:\n            url = f\"https://www.deribit.com/api/v2/public/get_instruments?currency={c}&expired=false\"\n            r = requests.get(url)\n            for entry in r.json()['result']:\n                split = entry['instrument_name'].split(\"-\")\n                normalized = split[0] + SYMBOL_SEP + entry['quote_currency'] + \"-\" + '-'.join(split[1:])\n                ret[normalized] = entry['instrument_name']\n                _exchange_info[DERIBIT]['tick_size'][normalized] = entry['tick_size']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('DERIBIT', why, {url: r})\n\n\ndef kraken_future_symbols() -> Dict[str, str]:\n    r = None\n    ret = {}\n    try:\n        r = requests.get('https://futures.kraken.com/derivatives/api/v3/instruments')\n        data = r.json()['instruments']\n        for entry in data:\n            if not entry['tradeable']:\n                continue\n            normalized = entry['symbol'].upper().replace(\"_\", \"-\")\n            symbol = normalized[3:6] + SYMBOL_SEP + normalized[6:9]\n            normalized = normalized.replace(normalized[3:9], symbol)\n            normalized = normalized.replace('XBT', 'BTC')\n\n            _exchange_info[KRAKEN_FUTURES]['tick_size'][normalized] = entry['tickSize']\n            _exchange_info[KRAKEN_FUTURES]['contract_size'][normalized] = entry['contractSize']\n            _exchange_info[KRAKEN_FUTURES]['underlying'][normalized] = entry['underlying']\n            _exchange_info[KRAKEN_FUTURES]['product_type'][normalized] = _kraken_futures_product_type[normalized[:2]]\n            ret[normalized] = entry['symbol']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('KRAKEN_FUTURES', why, {\"\": r})\n\n\ndef probit_symbols() -> Dict[str, str]:\n    # doc: https://docs-en.probit.com/reference-link/market\n    r = None\n    try:\n        r = requests.get('https://api.probit.com/api/exchange/v1/market')\n        return {entry['id']: entry['id'] for entry in r.json()['data']}\n    except Exception as why:\n        raise_failure_explanation('PROBIT', why, {\"\": r})\n\n\ndef coingecko_normalize_symbol(symbol: str) -> str:\n    # keep digits, letters and dots, replace others by space\n    symbol = ''.join(c if c.isalnum() or c in ('.', '+') else ' ' for c in symbol)\n    return coingecko_normalize(symbol.upper())\n\n\ndef coingecko_normalize_name(name: str) -> str:\n    # keep digits and letters, replace others by space (except when only composed by upper case letters, digits and dots)\n    if not all(c.isupper() or c.isdigit() or c == '.' for c in name):\n        name = ''.join(c if c.isalnum() else ' ' for c in name)\n    return coingecko_normalize(name)\n\n\ndef coingecko_normalize(sym: str) -> str:\n    sym = sym.strip()\n    # do not concatenate numbers => separate them with a dot\n    sym = list(sym)\n    if len(sym) > 4:\n        for i in range(2, len(sym) - 1):\n            if sym[i] == ' ' and sym[i - 1].isdigit() and sym[i + 1].isdigit():\n                sym[i] = '.'\n    sym = ''.join(sym)\n    # concatenate space-separated words => use CamelCase to distinguish the words\n    if ' ' in sym:\n        if sum(c.islower() for c in sym):  # if there is at least one lower case letter\n            sym = ' '.join(word[0].upper() + word[1:] for word in sym.split())  # Just capitalize initial letter of each word\n        else:  # CoinGecko may provide full upper-case as for \"THE STONE COIN\"\n            sym = string.capwords(sym)  # capwords converts \"THE STONE COIN\" to \"The Stone Coin\"\n        sym = sym.replace(' ', '')  # concatenate words\n    return sym\n\n\ndef is_name_short(coin: dict) -> bool:\n    \"\"\"return True if the coin name is enough short compared to the coin symbol.\"\"\"\n    return len(coin['name']) <= max(5, len(coin['symbol']) + 1)\n\n\ndef has_many_caps(name: str) -> bool:\n    \"\"\"return True if the symbol contains enough upper case letters, False if empty.\"\"\"\n    return str and sum(c.islower() for c in name) < (len(name) / 2)\n\n\ndef coingecko_normalize_all(coin: dict):\n    SYMBOL_TO_NORMALIZED = {'miota': 'IOTA'}\n    normalized = SYMBOL_TO_NORMALIZED.get(coin['symbol'])\n    if normalized:\n        coin['ns'] = coin['nn'] = normalized\n        return normalized\n\n    # ns = normalized symbol, nn = normalized name\n    coin['ns'] = coingecko_normalize_symbol(coin['symbol'])\n\n    ID_SUFFIX = '-bitcoin-token'\n    if coin['id'][-len(ID_SUFFIX):] == ID_SUFFIX:\n        coin['nn'] = 'BTC' + coin['ns']\n        return coin['nn']\n\n    name = coin['name']\n\n    prefixes = ('The ', 'the ')\n    for p in prefixes:\n        if name[:len(p)] == p:\n            coin['reduced-name'] = True\n            name = name[len(p):]\n            break\n\n    suffixes = ('coin', 'coins', 'money', 'finance', 'protocol', 'reward', 'rewards', 'token')\n    for s in suffixes:\n        if len(name) > len(s) and name[-len(s):].lower() == s:\n            # but keep suffix when lower-case concatenated\n            if name[-len(s)].islower() and name[-len(s) - 1] != ' ':\n                continue\n            # also keep suffix to avoid confusing nam: \"Bitcoin Token\" -> \"Bitcoin\"\n            if name[:-len(s)].strip().lower() == 'bitcoin':\n                continue\n            coin['reduced-name'] = True\n            name = name[:-len(s)]\n            break\n\n    coin['nn'] = coingecko_normalize_name(name)\n\n    if len(coin['nn']) < len(coin['ns']):\n        if 'reduced-name' in coin:\n            coin['reduced-name'] = False\n            name = coin['name']\n            coin['nn'] = coingecko_normalize_name(name)\n        elif not has_many_caps(name):\n            return coin['ns']\n\n    if not coin['ns']:  # coin['symbol'] may be an emoji that is striped when normalized\n        return coin['nn']\n\n    if coin.get('reduced-name') and coin['ns'].upper() != coin['nn'].upper():\n        return coin['ns']\n\n    i = coin['nn'].find('.')  # if there is a dot in normalized name => prefer the normalized symbol\n    if i >= 0:\n        if i > 1 and coin['nn'][i - 1].isdigit() and coin['nn'][i + 1].isdigit():\n            pass  # except when the dot separates digits\n        else:\n            return coin['ns']\n\n    if is_name_short(coin) and has_many_caps(name):\n        return coin['nn']\n\n    if 1.5 * len(coin['ns']) > len(coin['nn']) and any(c.islower() for c in coin['ns']):\n        return coin['nn']\n\n    return coin['ns']\n\n\ndef coingecko_symbols() -> Dict[str, str]:\n    r = None\n    intermediate = defaultdict(list)\n    try:\n        r = requests.get('https://api.coingecko.com/api/v3/coins/list')\n        all_coins = r.json()\n        # First pass: generate & compare normalized symbol/name, and then select the most pertinent\n        for coin in all_coins:\n            normalized = coingecko_normalize_all(coin)\n            intermediate[normalized].append(coin)\n            # Above line keeps together the coins having the same normalized symbol.\n            # To reduce collision, the coin['name'] is sometimes used in lieu of the coin['symbol'].\n            # The coin['name'] is not capitalized because lower case letters may be meaningful: cETH, yUSD, DATx, zLOT\n    except Exception as why:\n        raise_failure_explanation('COINGECKO', why, {\"\": r})\n\n    final = coingecko_second_pass(intermediate)\n    return coingecko_third_pass(final)\n\n\ndef coingecko_second_pass(intermediate: Dict[str, List[dict]]) -> Dict[str, List[dict]]:\n    # Second pass: fixes most of the symbol collisions\n    final = defaultdict(list)\n    for normalized, coins in intermediate.items():\n        if len(coins) == 1:\n            final[normalized].append(coins[0])\n            continue\n        set_normalized = False\n        for i in range(len(coins)):\n            if normalized == coins[i]['nn']:\n                coin = coins.pop(i)\n                final[normalized].append(coin)\n                set_normalized = True\n                break\n        rest: List[dict] = []\n        for coin in coins:\n            if '%' in coin['name']:\n                if len(coins) == 1:\n                    n = coin['ns']\n                else:\n                    n = coingecko_normalize_name(coin['id'])\n                final[n].append(coin)\n            else:\n                rest.append(coin)\n        if not rest:\n            continue\n        if not set_normalized:\n            rest.sort(key=lambda coin: len(coin['nn']), reverse=True)  # sort by the length of the normalized name\n            coin = rest.pop(0)\n            final[normalized].append(coin)\n        for coin in rest:\n            if coin['nn'] not in intermediate:\n                n = coin['nn']\n            elif coin.get('reduced-name'):\n                n = coingecko_normalize_name(coin['name'])\n            else:\n                n = coingecko_normalize_name(coin['id'])\n            final[n].append(coin)\n    return final\n\n\ndef coingecko_third_pass(final: Dict[str, List[dict]]) -> Dict[str, str]:\n    # Third pass: fixes some remaining collisions and fills the result\n    symbols = {}\n    for normalized, coins in final.items():\n        if len(coins) == 1:\n            symbols[normalized] = coins[0]['id']\n            continue\n        set_normalized = False\n        for i in range(len(coins)):\n            if normalized == coins[i]['nn']:\n                coin = coins.pop(i)\n                symbols[normalized] = coin['id']\n                set_normalized = True\n                break\n        rest: List[dict] = []\n        for coin in coins:\n            if '%' in coin['name']:\n                if len(coins) == 1:\n                    n = coin['ns']\n                else:\n                    n = coingecko_normalize_name(coin['id'])\n                symbols[n] = coin['id']\n            else:\n                rest.append(coin)\n        if not rest:\n            continue\n        if not set_normalized:\n            rest.sort(key=lambda coin: len(coin['nn']), reverse=True)  # sort by the length of the normalized name\n            coin = rest.pop(0)\n            symbols[normalized] = coin['id']\n        for coin in rest:\n            if coin['nn'] not in final:\n                n = coin['nn']\n            elif coin.get('reduced-name'):\n                n = coingecko_normalize_name(coin['name'])\n            else:\n                n = coingecko_normalize_name(coin['id'])\n            symbols[n] = coin['id']\n    return symbols\n\n\ndef whale_alert_coins(key_id: str) -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get(f'https://api.whale-alert.io/v1/status?api_key={key_id}')\n        # Same symbols, but on different blockchains (for instance USDT), are naturally overwritten.\n        return {s.upper(): s for b in r.json()['blockchains'] for s in b['symbols'] if s}\n    except Exception as why:\n        raise_failure_explanation('WHALES_ALERT', why, {\"\": r})\n\n\n_exchange_function_map = {\n    BITFINEX: bitfinex_symbols,\n    BITFLYER: bitflyer_symbols,\n    COINBASE: coinbase_symbols,\n    GEMINI: gemini_symbols,\n    HITBTC: hitbtc_symbols,\n    POLONIEX: poloniex_symbols,\n    PROBIT: probit_symbols,\n    BITSTAMP: bitstamp_symbols,\n    KRAKEN: kraken_symbols,\n    KRAKEN + 'REST': kraken_rest_symbols,\n    BINANCE: binance_symbols,\n    BINANCE_US: binance_us_symbols,\n    BINANCE_FUTURES: binance_futures_symbols,\n    BINANCE_DELIVERY: binance_delivery_symbols,\n    BLOCKCHAIN: blockchain_symbols,\n    EXX: exx_symbols,\n    HUOBI: huobi_symbols,\n    HUOBI_DM: huobi_dm_symbols,\n    HUOBI_SWAP: huobi_swap_symbols,\n    OKCOIN: okcoin_symbols,\n    OKEX: okex_symbols,\n    BYBIT: bybit_symbols,\n    FTX: ftx_symbols,\n    FTX_US: ftx_us_symbols,\n    BITTREX: bittrex_symbols,\n    BITCOINCOM: bitcoincom_symbols,\n    BITMAX: bitmax_symbols,\n    UPBIT: upbit_symbols,\n    GATEIO: gateio_symbols,\n    BITMEX: bitmex_symbols,\n    DERIBIT: deribit_symbols,\n    KRAKEN_FUTURES: kraken_future_symbols,\n    COINGECKO: coingecko_symbols,\n    WHALE_ALERT: whale_alert_coins\n}\n",
        "source_code_len": 30534,
        "target_code": "associated with this software.\n'''\nfrom typing import Dict, Tuple\n\n\nclass _Symbols:\n    def __init__(self):\n        self.data = {}\n\n    def set(self, exchange: str, normalized: dict, exchange_info: dict):\n        self.data[exchange] = {}\n        self.data[exchange]['normalized'] = normalized\n        self.data[exchange]['info'] = exchange_info\n\n    def get(self, exchange: str) -> Tuple[Dict, Dict]:\n        return self.data[exchange]['normalized'], self.data[exchange]['info']\n\n    def populated(self, exchange: str) -> bool:\n        return exchange in self.data\n\n\nSymbols = _Symbols()\n",
        "target_code_len": 588,
        "diff_format": "@@ -5,845 +5,22 @@\n associated with this software.\n+'''\n+from typing import Dict, Tuple\n \n \n-Symbol generation code for exchanges\n-'''\n+class _Symbols:\n+    def __init__(self):\n+        self.data = {}\n \n-import logging\n-import string\n-import time\n-from collections import defaultdict\n-from typing import Dict, List, Optional, Tuple\n+    def set(self, exchange: str, normalized: dict, exchange_info: dict):\n+        self.data[exchange] = {}\n+        self.data[exchange]['normalized'] = normalized\n+        self.data[exchange]['info'] = exchange_info\n \n-import requests\n-from requests import Response\n+    def get(self, exchange: str) -> Tuple[Dict, Dict]:\n+        return self.data[exchange]['normalized'], self.data[exchange]['info']\n \n-from cryptofeed.defines import *\n+    def populated(self, exchange: str) -> bool:\n+        return exchange in self.data\n \n \n-LOG = logging.getLogger('feedhandler')\n-\n-SYMBOL_SEP = '-'\n-\n-_symbols_retrieval_cache: Dict[str, Dict[str, str]] = {}\n-_exchange_info = defaultdict(lambda: defaultdict(dict))\n-\n-\n-_kraken_futures_product_type = {\n-    'FI': 'Inverse Futures',\n-    'FV': 'Vanilla Futures',\n-    'PI': 'Perpetual Inverse Futures',\n-    'PV': 'Perpetual Vanilla Futures',\n-    'IN': 'Real Time Index',\n-    'RR': 'Reference Rate',\n-}\n-\n-\n-def raise_failure_explanation(feed_id: str, exception: BaseException, responses: Dict[str, Optional[Response]]):\n-    LOG.critical('%s: encountered %r while processing response from exchange API', feed_id, exception)\n-    if len(responses) > 1:\n-        LOG.critical('%s: content of one of the %s responses was unexpected', feed_id, len(responses))\n-    for url, r in responses.items():\n-        if url:\n-            LOG.critical('%s: requested URL: %s', feed_id, url)\n-        if r:\n-            LOG.critical('%s: unexpected response: %s', feed_id, r.text)\n-    raise ValueError(f'Cryptofeed stopped because of an unexpected response from {feed_id}') from exception\n-\n-\n-def set_symbol_separator(separator: str):\n-    global SYMBOL_SEP\n-    SYMBOL_SEP = separator\n-\n-\n-def get_symbol_separator() -> str:\n-    global SYMBOL_SEP\n-    return SYMBOL_SEP\n-\n-\n-def gen_symbols(exchange: str, key_id=None) -> Dict[str, str]:\n-    if exchange not in _symbols_retrieval_cache:\n-        LOG.info(\"%s: Getting list of symbols\", exchange)\n-        symbols = _exchange_function_map[exchange](key_id) if key_id else _exchange_function_map[exchange]()\n-        LOG.info(\"%s: %s symbols\", exchange, len(symbols))\n-\n-        # log all retrieved symbols using debug level\n-        for normalized, exch_sym in sorted(symbols.items()):\n-            LOG.debug('%s: id-from-exch -> normalized: %-35s-> %s', exchange, exch_sym, normalized)\n-\n-        _symbols_retrieval_cache[exchange] = symbols\n-    return _symbols_retrieval_cache[exchange]\n-\n-\n-def _binance_symbols(endpoint: str, exchange: str):\n-    r = None\n-    try:\n-        ret = {}\n-        r = requests.get(endpoint)\n-        for symbol in r.json()['symbols']:\n-            if symbol.get('status', 'TRADING') != \"TRADING\":\n-                continue\n-            if symbol.get('contractStatus', 'TRADING') != \"TRADING\":\n-                continue\n-            split = len(symbol['baseAsset'])\n-            normalized = symbol['symbol'][:split] + SYMBOL_SEP + symbol['symbol'][split:]\n-            ret[normalized] = symbol['symbol']\n-            _exchange_info[exchange]['tick_size'][normalized] = symbol['filters'][0]['tickSize']\n-            if \"contractType\" in symbol:\n-                _exchange_info[exchange]['contract_type'][normalized] = symbol['contractType']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation(exchange, why, {endpoint: r})\n-\n-\n-def binance_symbols() -> Dict[str, str]:\n-    return _binance_symbols('https://api.binance.com/api/v3/exchangeInfo', BINANCE)\n-\n-\n-def binance_us_symbols() -> Dict[str, str]:\n-    return _binance_symbols('https://api.binance.us/api/v3/exchangeInfo', BINANCE_US)\n-\n-\n-def binance_futures_symbols() -> Dict[str, str]:\n-    base = _binance_symbols('https://fapi.binance.com/fapi/v1/exchangeInfo', BINANCE_FUTURES)\n-    add = {}\n-    for symbol, orig in base.items():\n-        if \"_\" in orig:\n-            continue\n-        add[f\"{symbol}-PINDEX\"] = f\"p{orig}\"\n-    base.update(add)\n-    return base\n-\n-\n-def binance_delivery_symbols() -> Dict[str, str]:\n-    return _binance_symbols('https://dapi.binance.com/dapi/v1/exchangeInfo', BINANCE_DELIVERY)\n-\n-\n-def bitfinex_symbols() -> Dict[str, str]:\n-    # doc: https://docs.bitfinex.com/docs/ws-general#supported-pairs\n-    r1 = r2 = None\n-    try:\n-        r1 = requests.get('https://api.bitfinex.com/v2/tickers?symbols=ALL')\n-        r2 = requests.get('https://api-pub.bitfinex.com/v2/conf/pub:map:currency:sym')\n-        tickers: List[List[str]] = r1.json()\n-        norm: List[Tuple[str, str]] = r2.json()[0]\n-        norm: Dict[str, str] = dict(norm)\n-        for k, v in dict(norm).items():\n-            if k[-2:] == 'F0' or '-' in v:  # Do not convert BTCF0 -> BTC or PBTCETH -> PBTC-ETH\n-                del norm[k]\n-        norm['BCHN'] = 'BCH'  # Bitfinex uses BCHN, other exchanges use BCH\n-\n-        ret = {}\n-        for symbol in [t[0] for t in tickers]:\n-            if symbol[0] == 'f':\n-                normalized = norm.get(symbol[1:], symbol[1:])\n-            else:\n-                if len(symbol) == 7:\n-                    base, quote = symbol[1:4], symbol[4:]\n-                else:\n-                    base, quote = symbol[1:].split(':')\n-                    assert ':' in symbol\n-                normalized = norm.get(base, base) + SYMBOL_SEP + norm.get(quote, quote)\n-            ret[normalized.upper()] = symbol\n-        return ret\n-    except ValueError as why:\n-        raise_failure_explanation('BITFINEX', why, {\"tickers?symbols=ALL\": r1, \"pub:map:currency:sym\": r2})\n-\n-\n-def bitflyer_symbols() -> Dict[str, str]:\n-    endpoint = r = None\n-    try:\n-        ret = {}\n-        endpoints = ['https://api.bitflyer.com/v1/getmarkets/eu', 'https://api.bitflyer.com/v1/getmarkets/usa', 'https://api.bitflyer.com/v1/getmarkets']\n-        for endpoint in endpoints:\n-            r = requests.get(endpoint)\n-            for entry in r.json():\n-                normalized = entry['product_code'].replace(\"_\", SYMBOL_SEP)\n-                ret[normalized] = entry['product_code']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('BITFLYER', why, {endpoint: r})\n-\n-\n-def bybit_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.bybit.com/v2/public/symbols')\n-        ret = {}\n-        for symbol in r.json()['result']:\n-            quote = symbol['quote_currency']\n-            if not symbol['name'].endswith(quote):\n-                base, contract = symbol['name'].split(quote)\n-                normalized = f\"{base}{SYMBOL_SEP}{quote}-{contract}\"\n-            else:\n-                normalized = f\"{symbol['base_currency']}{SYMBOL_SEP}{quote}\"\n-            ret[normalized] = symbol['name']\n-            _exchange_info[BYBIT]['tick_size'][normalized] = symbol['price_filter']['tick_size']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('BYBIT', why, {\"\": r})\n-\n-\n-def _ftx_helper(endpoint: str, exchange: str):\n-    r = None\n-    try:\n-        r = requests.get(endpoint)\n-        ret = {}\n-        for data in r.json()['result']:\n-            normalized = data['name'].replace(\"/\", SYMBOL_SEP)\n-            symbol = data['name']\n-            ret[normalized] = symbol\n-            _exchange_info[exchange]['tick_size'][normalized] = data['priceIncrement']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation(exchange, why, {endpoint: r})\n-\n-\n-def ftx_symbols() -> Dict[str, str]:\n-    return _ftx_helper('https://ftx.com/api/markets', FTX)\n-\n-\n-def ftx_us_symbols() -> Dict[str, str]:\n-    return _ftx_helper('https://ftx.us/api/markets', FTX_US)\n-\n-\n-def coinbase_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.pro.coinbase.com/products')\n-        ret = {}\n-        for data in r.json():\n-            normalized = data['id'].replace(\"-\", SYMBOL_SEP)\n-            ret[normalized] = data['id']\n-            _exchange_info[COINBASE]['tick_size'][normalized] = data['quote_increment']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('COINBASE', why, {\"\": r})\n-\n-\n-def gemini_symbols(*args) -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.gemini.com/v1/symbols')\n-        ret = {}\n-        for symbol in r.json():\n-            std = f\"{symbol[:-3]}{SYMBOL_SEP}{symbol[-3:]}\"\n-            std = std.upper()\n-            ret[std] = symbol.upper()\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('GEMINI', why, {\"\": r})\n-\n-\n-def hitbtc_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        ret = {}\n-        r = requests.get('https://api.hitbtc.com/api/2/public/symbol')\n-        for symbol in r.json():\n-            split = len(symbol['baseCurrency'])\n-            normalized = symbol['id'][:split] + SYMBOL_SEP + symbol['id'][split:]\n-            ret[normalized] = symbol['id']\n-            _exchange_info[HITBTC]['tick_size'][normalized] = symbol['tickSize']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('HITBTC', why, {\"\": r})\n-\n-\n-def poloniex_id_symbol_mapping():\n-    r = None\n-    try:\n-        r = requests.get('https://poloniex.com/public?command=returnTicker')\n-        symbols = r.json()\n-        ret = {}\n-        for symbol in symbols:\n-            ret[symbols[symbol]['id']] = symbol\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('POLONIEX', why, {\"\": r})\n-\n-\n-def poloniex_symbols() -> Dict[str, str]:\n-    ret = {}\n-    for _, value in poloniex_id_symbol_mapping().items():\n-        std = value.replace(\"STR\", \"XLM\")\n-        quote, base = std.split(\"_\")\n-        ret[quote + SYMBOL_SEP + base] = value\n-    return ret\n-\n-\n-def bitstamp_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://www.bitstamp.net/api/v2/trading-pairs-info/')\n-        ret = {}\n-        for data in r.json():\n-            normalized = data['name'].replace(\"/\", SYMBOL_SEP)\n-            symbol = data['url_symbol']\n-            ret[normalized] = symbol\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('BITSTAMP', why, {\"\": r})\n-\n-\n-def kraken_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.kraken.com/0/public/AssetPairs')\n-        data = r.json()\n-        ret = {}\n-        for symbol in data['result']:\n-            if 'wsname' not in data['result'][symbol] or '.d' in symbol:\n-                # https://blog.kraken.com/post/259/introducing-the-kraken-dark-pool/\n-                # .d is for dark pool symbols\n-                continue\n-\n-            base, quote = data['result'][symbol]['wsname'].split(\"/\")\n-\n-            normalized = f\"{base}{SYMBOL_SEP}{quote}\"\n-            exch = data['result'][symbol]['wsname']\n-            normalized = normalized.replace('XBT', 'BTC')\n-            normalized = normalized.replace('XDG', 'DOG')\n-            ret[normalized] = exch\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('KRAKEN', why, {\"\": r})\n-\n-\n-def kraken_rest_symbols() -> Dict[str, str]:\n-    return {normalized: exchange.replace(\"/\", \"\") for normalized, exchange in kraken_symbols().items()}\n-\n-\n-def exx_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.exx.com/data/v1/tickers')\n-        exchange = [key.upper() for key in r.json().keys()]\n-        symbols = [key.replace(\"_\", SYMBOL_SEP) for key in exchange]\n-        return dict(zip(symbols, exchange))\n-    except Exception as why:\n-        raise_failure_explanation('EXX', why, {\"\": r})\n-\n-\n-def huobi_common_symbols(url: str):\n-    r = None\n-    try:\n-        r = requests.get(url)\n-        ret = {}\n-        for e in r.json()['data']:\n-            if e['state'] == 'offline':\n-                continue\n-            normalized = f\"{e['base-currency'].upper()}{SYMBOL_SEP}{e['quote-currency'].upper()}\"\n-            symbol = f\"{e['base-currency']}{e['quote-currency']}\"\n-            ret[normalized] = symbol\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('HUOBI', why, {url: r})\n-\n-\n-def huobi_symbols() -> Dict[str, str]:\n-    return huobi_common_symbols('https://api.huobi.pro/v1/common/symbols')\n-\n-\n-def huobi_us_symbols() -> Dict[str, str]:\n-    return huobi_common_symbols('https://api.huobi.com/v1/common/symbols')\n-\n-\n-def huobi_dm_symbols() -> Dict[str, str]:\n-    \"\"\"\n-    Mapping is, for instance: {\"BTC_CW\":\"BTC190816\"}\n-    See comments in exchange/huobi_dm.py\n-    \"\"\"\n-    mapping = {\n-        \"this_week\": \"CW\",\n-        \"next_week\": \"NW\",\n-        \"quarter\": \"CQ\",\n-        \"next_quarter\": \"NQ\"\n-    }\n-    r = None\n-    try:\n-        r = requests.get('https://www.hbdm.com/api/v1/contract_contract_info')\n-        symbols = {}\n-        for e in r.json()['data']:\n-            symbols[f\"{e['symbol']}_{mapping[e['contract_type']]}\"] = e['contract_code']\n-            _exchange_info[HUOBI_DM]['tick_size'][e['contract_code']] = e['price_tick']\n-            _exchange_info[HUOBI_DM]['short_code_mappings'][f\"{e['symbol']}_{mapping[e['contract_type']]}\"] = e['contract_code']\n-        return symbols\n-    except Exception as why:\n-        raise_failure_explanation('HUOBI_DM', why, {\"\": r})\n-\n-\n-def huobi_swap_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.hbdm.com/swap-api/v1/swap_contract_info')\n-        symbols = {}\n-        for e in r.json()['data']:\n-            symbols[e['contract_code']] = e['contract_code']\n-            _exchange_info[HUOBI_SWAP]['tick_size'][e['contract_code']] = e['price_tick']\n-        return symbols\n-    except Exception as why:\n-        raise_failure_explanation('HUOBI_SWAP', why, {\"\": r})\n-\n-\n-def okcoin_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://www.okcoin.com/api/spot/v3/instruments')\n-        ret = {}\n-        for e in r.json():\n-            ret[e['instrument_id']] = e['instrument_id']\n-            _exchange_info[OKCOIN]['tick_size'][e['instrument_id']] = e['tick_size']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('OKCOIN', why, {\"\": r})\n-\n-\n-def okex_symbols(*args) -> Dict[str, str]:\n-    urls = ['https://www.okex.com/api/spot/v3/instruments',\n-            'https://www.okex.com/api/swap/v3/instruments',\n-            'https://www.okex.com/api/futures/v3/instruments']\n-    urls = urls + okex_compute_option_urls_from_underlyings()\n-\n-    symbols: Dict[str, str] = {}\n-    for u in urls:\n-        time.sleep(0.2)\n-        symbols.update(okex_symbols_from_one_url(u))\n-\n-    for symbol in symbols:\n-        instrument_type = 'futures'\n-        dash_count = symbol.count(get_symbol_separator())\n-        if dash_count == 1:  # BTC-USDT\n-            instrument_type = 'spot'\n-        if dash_count == 4:  # BTC-USD-201225-35000-P\n-            instrument_type = 'option'\n-        if symbol[-4:] == \"SWAP\":  # BTC-USDT-SWAP\n-            instrument_type = 'swap'\n-\n-        _exchange_info[OKEX]['instrument_type'][symbol] = instrument_type\n-\n-    return symbols\n-\n-\n-def okex_compute_option_urls_from_underlyings() -> List[str]:\n-    url = 'https://www.okex.com/api/option/v3/underlying'\n-    r = None\n-    try:\n-        r = requests.get(url)\n-        return [f'https://www.okex.com/api/option/v3/instruments/{underlying}' for underlying in r.json()]\n-    except Exception as why:\n-        raise_failure_explanation('OKEX', why, {url: r})\n-\n-\n-def okex_symbols_from_one_url(url: str) -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get(url)\n-        ret = {}\n-        for e in r.json():\n-            ret[e['instrument_id']] = e['instrument_id']\n-            _exchange_info[OKEX]['tick_size'][e['instrument_id']] = e['tick_size']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('OKEX', why, {url: r})\n-\n-\n-def bittrex_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.bittrex.com/api/v1.1/public/getmarkets')\n-        r = r.json()['result']\n-        return {f\"{e['MarketCurrency']}{SYMBOL_SEP}{e['BaseCurrency']}\": e['MarketName'] for e in r if e['IsActive']}\n-    except Exception as why:\n-        raise_failure_explanation('BITTREX', why, {\"\": r})\n-\n-\n-def bitcoincom_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.exchange.bitcoin.com/api/2/public/symbol')\n-        return {f\"{data['baseCurrency']}{SYMBOL_SEP}{data['quoteCurrency'].replace('USD', 'USDT')}\": data['id'] for data in r.json()}\n-    except Exception as why:\n-        raise_failure_explanation('BITCOINCOM', why, {\"\": r})\n-\n-\n-def bitmax_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://bitmax.io/api/pro/v1/products')\n-        ret = {}\n-        for entry in r.json()['data']:\n-            # Only \"Normal\" status symbols are tradeable\n-            if entry['status'] == 'Normal':\n-                normalized = f\"{entry['baseAsset']}{SYMBOL_SEP}{entry['quoteAsset']}\"\n-                ret[normalized] = entry['symbol']\n-                _exchange_info[BITMAX]['tick_size'][normalized] = entry['tickSize']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('BITMAX', why, {\"\": r})\n-\n-\n-def upbit_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.upbit.com/v1/market/all')\n-        return {f\"{data['market'].split('-')[1]}{SYMBOL_SEP}{data['market'].split('-')[0]}\": data['market'] for data in r.json()}\n-    except Exception as why:\n-        raise_failure_explanation('UPBIT', why, {\"\": r})\n-\n-\n-def blockchain_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get(\"https://api.blockchain.com/mercury-gateway/v1/instruments\")\n-        return {data[\"symbol\"].replace(\"-\", SYMBOL_SEP): data[\"symbol\"] for data in r.json()}\n-    except Exception as why:\n-        raise_failure_explanation('BLOCKCHAIN', why, {\"\": r})\n-\n-\n-def gateio_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get(\"https://api.gateio.ws/api/v4/spot/currency_pairs\")\n-        return {data[\"id\"].replace(\"_\", SYMBOL_SEP): data['id'] for data in r.json()}\n-    except Exception as why:\n-        raise_failure_explanation('GATEIO', why, {\"\": r})\n-\n-\n-def bitmex_symbols() -> Dict[str, str]:\n-    r = None\n-    ret = {}\n-    try:\n-        r = requests.get(\"https://www.bitmex.com/api/v1/instrument/active\")\n-        for entry in r.json():\n-            components = []\n-            components.append(entry['rootSymbol'])\n-            components.append(entry['quoteCurrency'])\n-\n-            if entry['expiry']:\n-                components.append(entry['symbol'][-3:])\n-\n-            normalized = SYMBOL_SEP.join(components)\n-            normalized = normalized.replace(\"XBT\", \"BTC\")\n-            ret[normalized] = entry['symbol']\n-            _exchange_info[BITMEX]['tick_size'][normalized] = entry['tickSize']\n-\n-            if entry['expiry']:\n-                _exchange_info[BITMEX]['expiry'][normalized] = entry['expiry']\n-\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('BITMEX', why, {\"\": r})\n-\n-\n-def deribit_symbols() -> Dict[str, str]:\n-    url = r = None\n-    ret = {}\n-    try:\n-        # TODO: get currencies from https://www.deribit.com/api/v2/public/get_currencies\n-        currencies = ['BTC', 'ETH']\n-        for c in currencies:\n-            url = f\"https://www.deribit.com/api/v2/public/get_instruments?currency={c}&expired=false\"\n-            r = requests.get(url)\n-            for entry in r.json()['result']:\n-                split = entry['instrument_name'].split(\"-\")\n-                normalized = split[0] + SYMBOL_SEP + entry['quote_currency'] + \"-\" + '-'.join(split[1:])\n-                ret[normalized] = entry['instrument_name']\n-                _exchange_info[DERIBIT]['tick_size'][normalized] = entry['tick_size']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('DERIBIT', why, {url: r})\n-\n-\n-def kraken_future_symbols() -> Dict[str, str]:\n-    r = None\n-    ret = {}\n-    try:\n-        r = requests.get('https://futures.kraken.com/derivatives/api/v3/instruments')\n-        data = r.json()['instruments']\n-        for entry in data:\n-            if not entry['tradeable']:\n-                continue\n-            normalized = entry['symbol'].upper().replace(\"_\", \"-\")\n-            symbol = normalized[3:6] + SYMBOL_SEP + normalized[6:9]\n-            normalized = normalized.replace(normalized[3:9], symbol)\n-            normalized = normalized.replace('XBT', 'BTC')\n-\n-            _exchange_info[KRAKEN_FUTURES]['tick_size'][normalized] = entry['tickSize']\n-            _exchange_info[KRAKEN_FUTURES]['contract_size'][normalized] = entry['contractSize']\n-            _exchange_info[KRAKEN_FUTURES]['underlying'][normalized] = entry['underlying']\n-            _exchange_info[KRAKEN_FUTURES]['product_type'][normalized] = _kraken_futures_product_type[normalized[:2]]\n-            ret[normalized] = entry['symbol']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('KRAKEN_FUTURES', why, {\"\": r})\n-\n-\n-def probit_symbols() -> Dict[str, str]:\n-    # doc: https://docs-en.probit.com/reference-link/market\n-    r = None\n-    try:\n-        r = requests.get('https://api.probit.com/api/exchange/v1/market')\n-        return {entry['id']: entry['id'] for entry in r.json()['data']}\n-    except Exception as why:\n-        raise_failure_explanation('PROBIT', why, {\"\": r})\n-\n-\n-def coingecko_normalize_symbol(symbol: str) -> str:\n-    # keep digits, letters and dots, replace others by space\n-    symbol = ''.join(c if c.isalnum() or c in ('.', '+') else ' ' for c in symbol)\n-    return coingecko_normalize(symbol.upper())\n-\n-\n-def coingecko_normalize_name(name: str) -> str:\n-    # keep digits and letters, replace others by space (except when only composed by upper case letters, digits and dots)\n-    if not all(c.isupper() or c.isdigit() or c == '.' for c in name):\n-        name = ''.join(c if c.isalnum() else ' ' for c in name)\n-    return coingecko_normalize(name)\n-\n-\n-def coingecko_normalize(sym: str) -> str:\n-    sym = sym.strip()\n-    # do not concatenate numbers => separate them with a dot\n-    sym = list(sym)\n-    if len(sym) > 4:\n-        for i in range(2, len(sym) - 1):\n-            if sym[i] == ' ' and sym[i - 1].isdigit() and sym[i + 1].isdigit():\n-                sym[i] = '.'\n-    sym = ''.join(sym)\n-    # concatenate space-separated words => use CamelCase to distinguish the words\n-    if ' ' in sym:\n-        if sum(c.islower() for c in sym):  # if there is at least one lower case letter\n-            sym = ' '.join(word[0].upper() + word[1:] for word in sym.split())  # Just capitalize initial letter of each word\n-        else:  # CoinGecko may provide full upper-case as for \"THE STONE COIN\"\n-            sym = string.capwords(sym)  # capwords converts \"THE STONE COIN\" to \"The Stone Coin\"\n-        sym = sym.replace(' ', '')  # concatenate words\n-    return sym\n-\n-\n-def is_name_short(coin: dict) -> bool:\n-    \"\"\"return True if the coin name is enough short compared to the coin symbol.\"\"\"\n-    return len(coin['name']) <= max(5, len(coin['symbol']) + 1)\n-\n-\n-def has_many_caps(name: str) -> bool:\n-    \"\"\"return True if the symbol contains enough upper case letters, False if empty.\"\"\"\n-    return str and sum(c.islower() for c in name) < (len(name) / 2)\n-\n-\n-def coingecko_normalize_all(coin: dict):\n-    SYMBOL_TO_NORMALIZED = {'miota': 'IOTA'}\n-    normalized = SYMBOL_TO_NORMALIZED.get(coin['symbol'])\n-    if normalized:\n-        coin['ns'] = coin['nn'] = normalized\n-        return normalized\n-\n-    # ns = normalized symbol, nn = normalized name\n-    coin['ns'] = coingecko_normalize_symbol(coin['symbol'])\n-\n-    ID_SUFFIX = '-bitcoin-token'\n-    if coin['id'][-len(ID_SUFFIX):] == ID_SUFFIX:\n-        coin['nn'] = 'BTC' + coin['ns']\n-        return coin['nn']\n-\n-    name = coin['name']\n-\n-    prefixes = ('The ', 'the ')\n-    for p in prefixes:\n-        if name[:len(p)] == p:\n-            coin['reduced-name'] = True\n-            name = name[len(p):]\n-            break\n-\n-    suffixes = ('coin', 'coins', 'money', 'finance', 'protocol', 'reward', 'rewards', 'token')\n-    for s in suffixes:\n-        if len(name) > len(s) and name[-len(s):].lower() == s:\n-            # but keep suffix when lower-case concatenated\n-            if name[-len(s)].islower() and name[-len(s) - 1] != ' ':\n-                continue\n-            # also keep suffix to avoid confusing nam: \"Bitcoin Token\" -> \"Bitcoin\"\n-            if name[:-len(s)].strip().lower() == 'bitcoin':\n-                continue\n-            coin['reduced-name'] = True\n-            name = name[:-len(s)]\n-            break\n-\n-    coin['nn'] = coingecko_normalize_name(name)\n-\n-    if len(coin['nn']) < len(coin['ns']):\n-        if 'reduced-name' in coin:\n-            coin['reduced-name'] = False\n-            name = coin['name']\n-            coin['nn'] = coingecko_normalize_name(name)\n-        elif not has_many_caps(name):\n-            return coin['ns']\n-\n-    if not coin['ns']:  # coin['symbol'] may be an emoji that is striped when normalized\n-        return coin['nn']\n-\n-    if coin.get('reduced-name') and coin['ns'].upper() != coin['nn'].upper():\n-        return coin['ns']\n-\n-    i = coin['nn'].find('.')  # if there is a dot in normalized name => prefer the normalized symbol\n-    if i >= 0:\n-        if i > 1 and coin['nn'][i - 1].isdigit() and coin['nn'][i + 1].isdigit():\n-            pass  # except when the dot separates digits\n-        else:\n-            return coin['ns']\n-\n-    if is_name_short(coin) and has_many_caps(name):\n-        return coin['nn']\n-\n-    if 1.5 * len(coin['ns']) > len(coin['nn']) and any(c.islower() for c in coin['ns']):\n-        return coin['nn']\n-\n-    return coin['ns']\n-\n-\n-def coingecko_symbols() -> Dict[str, str]:\n-    r = None\n-    intermediate = defaultdict(list)\n-    try:\n-        r = requests.get('https://api.coingecko.com/api/v3/coins/list')\n-        all_coins = r.json()\n-        # First pass: generate & compare normalized symbol/name, and then select the most pertinent\n-        for coin in all_coins:\n-            normalized = coingecko_normalize_all(coin)\n-            intermediate[normalized].append(coin)\n-            # Above line keeps together the coins having the same normalized symbol.\n-            # To reduce collision, the coin['name'] is sometimes used in lieu of the coin['symbol'].\n-            # The coin['name'] is not capitalized because lower case letters may be meaningful: cETH, yUSD, DATx, zLOT\n-    except Exception as why:\n-        raise_failure_explanation('COINGECKO', why, {\"\": r})\n-\n-    final = coingecko_second_pass(intermediate)\n-    return coingecko_third_pass(final)\n-\n-\n-def coingecko_second_pass(intermediate: Dict[str, List[dict]]) -> Dict[str, List[dict]]:\n-    # Second pass: fixes most of the symbol collisions\n-    final = defaultdict(list)\n-    for normalized, coins in intermediate.items():\n-        if len(coins) == 1:\n-            final[normalized].append(coins[0])\n-            continue\n-        set_normalized = False\n-        for i in range(len(coins)):\n-            if normalized == coins[i]['nn']:\n-                coin = coins.pop(i)\n-                final[normalized].append(coin)\n-                set_normalized = True\n-                break\n-        rest: List[dict] = []\n-        for coin in coins:\n-            if '%' in coin['name']:\n-                if len(coins) == 1:\n-                    n = coin['ns']\n-                else:\n-                    n = coingecko_normalize_name(coin['id'])\n-                final[n].append(coin)\n-            else:\n-                rest.append(coin)\n-        if not rest:\n-            continue\n-        if not set_normalized:\n-            rest.sort(key=lambda coin: len(coin['nn']), reverse=True)  # sort by the length of the normalized name\n-            coin = rest.pop(0)\n-            final[normalized].append(coin)\n-        for coin in rest:\n-            if coin['nn'] not in intermediate:\n-                n = coin['nn']\n-            elif coin.get('reduced-name'):\n-                n = coingecko_normalize_name(coin['name'])\n-            else:\n-                n = coingecko_normalize_name(coin['id'])\n-            final[n].append(coin)\n-    return final\n-\n-\n-def coingecko_third_pass(final: Dict[str, List[dict]]) -> Dict[str, str]:\n-    # Third pass: fixes some remaining collisions and fills the result\n-    symbols = {}\n-    for normalized, coins in final.items():\n-        if len(coins) == 1:\n-            symbols[normalized] = coins[0]['id']\n-            continue\n-        set_normalized = False\n-        for i in range(len(coins)):\n-            if normalized == coins[i]['nn']:\n-                coin = coins.pop(i)\n-                symbols[normalized] = coin['id']\n-                set_normalized = True\n-                break\n-        rest: List[dict] = []\n-        for coin in coins:\n-            if '%' in coin['name']:\n-                if len(coins) == 1:\n-                    n = coin['ns']\n-                else:\n-                    n = coingecko_normalize_name(coin['id'])\n-                symbols[n] = coin['id']\n-            else:\n-                rest.append(coin)\n-        if not rest:\n-            continue\n-        if not set_normalized:\n-            rest.sort(key=lambda coin: len(coin['nn']), reverse=True)  # sort by the length of the normalized name\n-            coin = rest.pop(0)\n-            symbols[normalized] = coin['id']\n-        for coin in rest:\n-            if coin['nn'] not in final:\n-                n = coin['nn']\n-            elif coin.get('reduced-name'):\n-                n = coingecko_normalize_name(coin['name'])\n-            else:\n-                n = coingecko_normalize_name(coin['id'])\n-            symbols[n] = coin['id']\n-    return symbols\n-\n-\n-def whale_alert_coins(key_id: str) -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get(f'https://api.whale-alert.io/v1/status?api_key={key_id}')\n-        # Same symbols, but on different blockchains (for instance USDT), are naturally overwritten.\n-        return {s.upper(): s for b in r.json()['blockchains'] for s in b['symbols'] if s}\n-    except Exception as why:\n-        raise_failure_explanation('WHALES_ALERT', why, {\"\": r})\n-\n-\n-_exchange_function_map = {\n-    BITFINEX: bitfinex_symbols,\n-    BITFLYER: bitflyer_symbols,\n-    COINBASE: coinbase_symbols,\n-    GEMINI: gemini_symbols,\n-    HITBTC: hitbtc_symbols,\n-    POLONIEX: poloniex_symbols,\n-    PROBIT: probit_symbols,\n-    BITSTAMP: bitstamp_symbols,\n-    KRAKEN: kraken_symbols,\n-    KRAKEN + 'REST': kraken_rest_symbols,\n-    BINANCE: binance_symbols,\n-    BINANCE_US: binance_us_symbols,\n-    BINANCE_FUTURES: binance_futures_symbols,\n-    BINANCE_DELIVERY: binance_delivery_symbols,\n-    BLOCKCHAIN: blockchain_symbols,\n-    EXX: exx_symbols,\n-    HUOBI: huobi_symbols,\n-    HUOBI_DM: huobi_dm_symbols,\n-    HUOBI_SWAP: huobi_swap_symbols,\n-    OKCOIN: okcoin_symbols,\n-    OKEX: okex_symbols,\n-    BYBIT: bybit_symbols,\n-    FTX: ftx_symbols,\n-    FTX_US: ftx_us_symbols,\n-    BITTREX: bittrex_symbols,\n-    BITCOINCOM: bitcoincom_symbols,\n-    BITMAX: bitmax_symbols,\n-    UPBIT: upbit_symbols,\n-    GATEIO: gateio_symbols,\n-    BITMEX: bitmex_symbols,\n-    DERIBIT: deribit_symbols,\n-    KRAKEN_FUTURES: kraken_future_symbols,\n-    COINGECKO: coingecko_symbols,\n-    WHALE_ALERT: whale_alert_coins\n-}\n+Symbols = _Symbols()\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\n\nimport logging\nimport string\nimport time\nfrom collections import defaultdict\nfrom typing import Dict, List, Optional, Tuple\n\nimport requests\nfrom requests import Response\n\nfrom cryptofeed.defines import *\n\n\nLOG = logging.getLogger('feedhandler')\n\nSYMBOL_SEP = '-'\n\n_symbols_retrieval_cache: Dict[str, Dict[str, str]] = {}\n_exchange_info = defaultdict(lambda: defaultdict(dict))\n\n\n_kraken_futures_product_type = {\n    'FI': 'Inverse Futures',\n    'FV': 'Vanilla Futures',\n    'PI': 'Perpetual Inverse Futures',\n    'PV': 'Perpetual Vanilla Futures',\n    'IN': 'Real Time Index',\n    'RR': 'Reference Rate',\n}\n\n\ndef raise_failure_explanation(feed_id: str, exception: BaseException, responses: Dict[str, Optional[Response]]):\n    <IND>LOG.critical('%s: encountered %r while processing response from exchange API', feed_id, exception)\n    if len(responses) > 1:\n        <IND>LOG.critical('%s: content of one of the %s responses was unexpected', feed_id, len(responses))\n    <DED>for url, r in responses.items():\n        <IND>if url:\n            <IND>LOG.critical('%s: requested URL: %s', feed_id, url)\n        <DED>if r:\n            <IND>LOG.critical('%s: unexpected response: %s', feed_id, r.text)\n    <DED><DED>raise ValueError(f'Cryptofeed stopped because of an unexpected response from {feed_id}') from exception\n\n\n<DED>def set_symbol_separator(separator: str):\n    <IND>global SYMBOL_SEP\n    SYMBOL_SEP = separator\n\n\n<DED>def get_symbol_separator() -> str:\n    <IND>global SYMBOL_SEP\n    return SYMBOL_SEP\n\n\n<DED>def gen_symbols(exchange: str, key_id=None) -> Dict[str, str]:\n    <IND>if exchange not in _symbols_retrieval_cache:\n        <IND>LOG.info(\"%s: Getting list of symbols\", exchange)\n        symbols = _exchange_function_map[exchange](key_id) if key_id else _exchange_function_map[exchange]()\n        LOG.info(\"%s: %s symbols\", exchange, len(symbols))\n\n        # log all retrieved symbols using debug level\n        for normalized, exch_sym in sorted(symbols.items()):\n            <IND>LOG.debug('%s: id-from-exch -> normalized: %-35s-> %s', exchange, exch_sym, normalized)\n\n        <DED>_symbols_retrieval_cache[exchange] = symbols\n    <DED>return _symbols_retrieval_cache[exchange]\n\n\n<DED>def _binance_symbols(endpoint: str, exchange: str):\n    <IND>r = None\n    try:\n        <IND>ret = {}\n        r = requests.get(endpoint)\n        for symbol in r.json()['symbols']:\n            <IND>if symbol.get('status', 'TRADING') != \"TRADING\":\n                <IND>continue\n            <DED>if symbol.get('contractStatus', 'TRADING') != \"TRADING\":\n                <IND>continue\n            <DED>split = len(symbol['baseAsset'])\n            normalized = symbol['symbol'][:split] + SYMBOL_SEP + symbol['symbol'][split:]\n            ret[normalized] = symbol['symbol']\n            _exchange_info[exchange]['tick_size'][normalized] = symbol['filters'][0]['tickSize']\n            if \"contractType\" in symbol:\n                <IND>_exchange_info[exchange]['contract_type'][normalized] = symbol['contractType']\n        <DED><DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation(exchange, why, {endpoint: r})\n\n\n<DED><DED>def binance_symbols() -> Dict[str, str]:\n    <IND>return _binance_symbols('https://api.binance.com/api/v3/exchangeInfo', BINANCE)\n\n\n<DED>def binance_us_symbols() -> Dict[str, str]:\n    <IND>return _binance_symbols('https://api.binance.us/api/v3/exchangeInfo', BINANCE_US)\n\n\n<DED>def binance_futures_symbols() -> Dict[str, str]:\n    <IND>base = _binance_symbols('https://fapi.binance.com/fapi/v1/exchangeInfo', BINANCE_FUTURES)\n    add = {}\n    for symbol, orig in base.items():\n        <IND>if \"_\" in orig:\n            <IND>continue\n        <DED>add[f\"{symbol}-PINDEX\"] = f\"p{orig}\"\n    <DED>base.update(add)\n    return base\n\n\n<DED>def binance_delivery_symbols() -> Dict[str, str]:\n    <IND>return _binance_symbols('https://dapi.binance.com/dapi/v1/exchangeInfo', BINANCE_DELIVERY)\n\n\n<DED>def bitfinex_symbols() -> Dict[str, str]:\n    # doc: https://docs.bitfinex.com/docs/ws-general#supported-pairs\n    <IND>r1 = r2 = None\n    try:\n        <IND>r1 = requests.get('https://api.bitfinex.com/v2/tickers?symbols=ALL')\n        r2 = requests.get('https://api-pub.bitfinex.com/v2/conf/pub:map:currency:sym')\n        tickers: List[List[str]] = r1.json()\n        norm: List[Tuple[str, str]] = r2.json()[0]\n        norm: Dict[str, str] = dict(norm)\n        for k, v in dict(norm).items():\n            <IND>if k[-2:] == 'F0' or '-' in v:  # Do not convert BTCF0 -> BTC or PBTCETH -> PBTC-ETH\n                <IND>del norm[k]\n        <DED><DED>norm['BCHN'] = 'BCH'  # Bitfinex uses BCHN, other exchanges use BCH\n\n        ret = {}\n        for symbol in [t[0] for t in tickers]:\n            <IND>if symbol[0] == 'f':\n                <IND>normalized = norm.get(symbol[1:], symbol[1:])\n            <DED>else:\n                <IND>if len(symbol) == 7:\n                    <IND>base, quote = symbol[1:4], symbol[4:]\n                <DED>else:\n                    <IND>base, quote = symbol[1:].split(':')\n                    assert ':' in symbol\n                <DED>normalized = norm.get(base, base) + SYMBOL_SEP + norm.get(quote, quote)\n            <DED>ret[normalized.upper()] = symbol\n        <DED>return ret\n    <DED>except ValueError as why:\n        <IND>raise_failure_explanation('BITFINEX', why, {\"tickers?symbols=ALL\": r1, \"pub:map:currency:sym\": r2})\n\n\n<DED><DED>def bitflyer_symbols() -> Dict[str, str]:\n    <IND>endpoint = r = None\n    try:\n        <IND>ret = {}\n        endpoints = ['https://api.bitflyer.com/v1/getmarkets/eu', 'https://api.bitflyer.com/v1/getmarkets/usa', 'https://api.bitflyer.com/v1/getmarkets']\n        for endpoint in endpoints:\n            <IND>r = requests.get(endpoint)\n            for entry in r.json():\n                <IND>normalized = entry['product_code'].replace(\"_\", SYMBOL_SEP)\n                ret[normalized] = entry['product_code']\n        <DED><DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BITFLYER', why, {endpoint: r})\n\n\n<DED><DED>def bybit_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.bybit.com/v2/public/symbols')\n        ret = {}\n        for symbol in r.json()['result']:\n            <IND>quote = symbol['quote_currency']\n            if not symbol['name'].endswith(quote):\n                <IND>base, contract = symbol['name'].split(quote)\n                normalized = f\"{base}{SYMBOL_SEP}{quote}-{contract}\"\n            <DED>else:\n                <IND>normalized = f\"{symbol['base_currency']}{SYMBOL_SEP}{quote}\"\n            <DED>ret[normalized] = symbol['name']\n            _exchange_info[BYBIT]['tick_size'][normalized] = symbol['price_filter']['tick_size']\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BYBIT', why, {\"\": r})\n\n\n<DED><DED>def _ftx_helper(endpoint: str, exchange: str):\n    <IND>r = None\n    try:\n        <IND>r = requests.get(endpoint)\n        ret = {}\n        for data in r.json()['result']:\n            <IND>normalized = data['name'].replace(\"/\", SYMBOL_SEP)\n            symbol = data['name']\n            ret[normalized] = symbol\n            _exchange_info[exchange]['tick_size'][normalized] = data['priceIncrement']\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation(exchange, why, {endpoint: r})\n\n\n<DED><DED>def ftx_symbols() -> Dict[str, str]:\n    <IND>return _ftx_helper('https://ftx.com/api/markets', FTX)\n\n\n<DED>def ftx_us_symbols() -> Dict[str, str]:\n    <IND>return _ftx_helper('https://ftx.us/api/markets', FTX_US)\n\n\n<DED>def coinbase_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.pro.coinbase.com/products')\n        ret = {}\n        for data in r.json():\n            <IND>normalized = data['id'].replace(\"-\", SYMBOL_SEP)\n            ret[normalized] = data['id']\n            _exchange_info[COINBASE]['tick_size'][normalized] = data['quote_increment']\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('COINBASE', why, {\"\": r})\n\n\n<DED><DED>def gemini_symbols(*args) -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.gemini.com/v1/symbols')\n        ret = {}\n        for symbol in r.json():\n            <IND>std = f\"{symbol[:-3]}{SYMBOL_SEP}{symbol[-3:]}\"\n            std = std.upper()\n            ret[std] = symbol.upper()\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('GEMINI', why, {\"\": r})\n\n\n<DED><DED>def hitbtc_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>ret = {}\n        r = requests.get('https://api.hitbtc.com/api/2/public/symbol')\n        for symbol in r.json():\n            <IND>split = len(symbol['baseCurrency'])\n            normalized = symbol['id'][:split] + SYMBOL_SEP + symbol['id'][split:]\n            ret[normalized] = symbol['id']\n            _exchange_info[HITBTC]['tick_size'][normalized] = symbol['tickSize']\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('HITBTC', why, {\"\": r})\n\n\n<DED><DED>def poloniex_id_symbol_mapping():\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://poloniex.com/public?command=returnTicker')\n        symbols = r.json()\n        ret = {}\n        for symbol in symbols:\n            <IND>ret[symbols[symbol]['id']] = symbol\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('POLONIEX', why, {\"\": r})\n\n\n<DED><DED>def poloniex_symbols() -> Dict[str, str]:\n    <IND>ret = {}\n    for _, value in poloniex_id_symbol_mapping().items():\n        <IND>std = value.replace(\"STR\", \"XLM\")\n        quote, base = std.split(\"_\")\n        ret[quote + SYMBOL_SEP + base] = value\n    <DED>return ret\n\n\n<DED>def bitstamp_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://www.bitstamp.net/api/v2/trading-pairs-info/')\n        ret = {}\n        for data in r.json():\n            <IND>normalized = data['name'].replace(\"/\", SYMBOL_SEP)\n            symbol = data['url_symbol']\n            ret[normalized] = symbol\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BITSTAMP', why, {\"\": r})\n\n\n<DED><DED>def kraken_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.kraken.com/0/public/AssetPairs')\n        data = r.json()\n        ret = {}\n        for symbol in data['result']:\n            <IND>if 'wsname' not in data['result'][symbol] or '.d' in symbol:\n                # https://blog.kraken.com/post/259/introducing-the-kraken-dark-pool/\n                # .d is for dark pool symbols\n                <IND>continue\n\n            <DED>base, quote = data['result'][symbol]['wsname'].split(\"/\")\n\n            normalized = f\"{base}{SYMBOL_SEP}{quote}\"\n            exch = data['result'][symbol]['wsname']\n            normalized = normalized.replace('XBT', 'BTC')\n            normalized = normalized.replace('XDG', 'DOG')\n            ret[normalized] = exch\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('KRAKEN', why, {\"\": r})\n\n\n<DED><DED>def kraken_rest_symbols() -> Dict[str, str]:\n    <IND>return {normalized: exchange.replace(\"/\", \"\") for normalized, exchange in kraken_symbols().items()}\n\n\n<DED>def exx_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.exx.com/data/v1/tickers')\n        exchange = [key.upper() for key in r.json().keys()]\n        symbols = [key.replace(\"_\", SYMBOL_SEP) for key in exchange]\n        return dict(zip(symbols, exchange))\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('EXX', why, {\"\": r})\n\n\n<DED><DED>def huobi_common_symbols(url: str):\n    <IND>r = None\n    try:\n        <IND>r = requests.get(url)\n        ret = {}\n        for e in r.json()['data']:\n            <IND>if e['state'] == 'offline':\n                <IND>continue\n            <DED>normalized = f\"{e['base-currency'].upper()}{SYMBOL_SEP}{e['quote-currency'].upper()}\"\n            symbol = f\"{e['base-currency']}{e['quote-currency']}\"\n            ret[normalized] = symbol\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('HUOBI', why, {url: r})\n\n\n<DED><DED>def huobi_symbols() -> Dict[str, str]:\n    <IND>return huobi_common_symbols('https://api.huobi.pro/v1/common/symbols')\n\n\n<DED>def huobi_us_symbols() -> Dict[str, str]:\n    <IND>return huobi_common_symbols('https://api.huobi.com/v1/common/symbols')\n\n\n<DED>def huobi_dm_symbols() -> Dict[str, str]:\n    <IND>\"\"\"\n    Mapping is, for instance: {\"BTC_CW\":\"BTC190816\"}\n    See comments in exchange/huobi_dm.py\n    \"\"\"\n    mapping = {\n        \"this_week\": \"CW\",\n        \"next_week\": \"NW\",\n        \"quarter\": \"CQ\",\n        \"next_quarter\": \"NQ\"\n    }\n    r = None\n    try:\n        <IND>r = requests.get('https://www.hbdm.com/api/v1/contract_contract_info')\n        symbols = {}\n        for e in r.json()['data']:\n            <IND>symbols[f\"{e['symbol']}_{mapping[e['contract_type']]}\"] = e['contract_code']\n            _exchange_info[HUOBI_DM]['tick_size'][e['contract_code']] = e['price_tick']\n            _exchange_info[HUOBI_DM]['short_code_mappings'][f\"{e['symbol']}_{mapping[e['contract_type']]}\"] = e['contract_code']\n        <DED>return symbols\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('HUOBI_DM', why, {\"\": r})\n\n\n<DED><DED>def huobi_swap_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.hbdm.com/swap-api/v1/swap_contract_info')\n        symbols = {}\n        for e in r.json()['data']:\n            <IND>symbols[e['contract_code']] = e['contract_code']\n            _exchange_info[HUOBI_SWAP]['tick_size'][e['contract_code']] = e['price_tick']\n        <DED>return symbols\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('HUOBI_SWAP', why, {\"\": r})\n\n\n<DED><DED>def okcoin_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://www.okcoin.com/api/spot/v3/instruments')\n        ret = {}\n        for e in r.json():\n            <IND>ret[e['instrument_id']] = e['instrument_id']\n            _exchange_info[OKCOIN]['tick_size'][e['instrument_id']] = e['tick_size']\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('OKCOIN', why, {\"\": r})\n\n\n<DED><DED>def okex_symbols(*args) -> Dict[str, str]:\n    <IND>urls = ['https://www.okex.com/api/spot/v3/instruments',\n            'https://www.okex.com/api/swap/v3/instruments',\n            'https://www.okex.com/api/futures/v3/instruments']\n    urls = urls + okex_compute_option_urls_from_underlyings()\n\n    symbols: Dict[str, str] = {}\n    for u in urls:\n        <IND>time.sleep(0.2)\n        symbols.update(okex_symbols_from_one_url(u))\n\n    <DED>for symbol in symbols:\n        <IND>instrument_type = 'futures'\n        dash_count = symbol.count(get_symbol_separator())\n        if dash_count == 1:  # BTC-USDT\n            <IND>instrument_type = 'spot'\n        <DED>if dash_count == 4:  # BTC-USD-201225-35000-P\n            <IND>instrument_type = 'option'\n        <DED>if symbol[-4:] == \"SWAP\":  # BTC-USDT-SWAP\n            <IND>instrument_type = 'swap'\n\n        <DED>_exchange_info[OKEX]['instrument_type'][symbol] = instrument_type\n\n    <DED>return symbols\n\n\n<DED>def okex_compute_option_urls_from_underlyings() -> List[str]:\n    <IND>url = 'https://www.okex.com/api/option/v3/underlying'\n    r = None\n    try:\n        <IND>r = requests.get(url)\n        return [f'https://www.okex.com/api/option/v3/instruments/{underlying}' for underlying in r.json()]\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('OKEX', why, {url: r})\n\n\n<DED><DED>def okex_symbols_from_one_url(url: str) -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get(url)\n        ret = {}\n        for e in r.json():\n            <IND>ret[e['instrument_id']] = e['instrument_id']\n            _exchange_info[OKEX]['tick_size'][e['instrument_id']] = e['tick_size']\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('OKEX', why, {url: r})\n\n\n<DED><DED>def bittrex_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.bittrex.com/api/v1.1/public/getmarkets')\n        r = r.json()['result']\n        return {f\"{e['MarketCurrency']}{SYMBOL_SEP}{e['BaseCurrency']}\": e['MarketName'] for e in r if e['IsActive']}\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BITTREX', why, {\"\": r})\n\n\n<DED><DED>def bitcoincom_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.exchange.bitcoin.com/api/2/public/symbol')\n        return {f\"{data['baseCurrency']}{SYMBOL_SEP}{data['quoteCurrency'].replace('USD', 'USDT')}\": data['id'] for data in r.json()}\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BITCOINCOM', why, {\"\": r})\n\n\n<DED><DED>def bitmax_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://bitmax.io/api/pro/v1/products')\n        ret = {}\n        for entry in r.json()['data']:\n            # Only \"Normal\" status symbols are tradeable\n            <IND>if entry['status'] == 'Normal':\n                <IND>normalized = f\"{entry['baseAsset']}{SYMBOL_SEP}{entry['quoteAsset']}\"\n                ret[normalized] = entry['symbol']\n                _exchange_info[BITMAX]['tick_size'][normalized] = entry['tickSize']\n        <DED><DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BITMAX', why, {\"\": r})\n\n\n<DED><DED>def upbit_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.upbit.com/v1/market/all')\n        return {f\"{data['market'].split('-')[1]}{SYMBOL_SEP}{data['market'].split('-')[0]}\": data['market'] for data in r.json()}\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('UPBIT', why, {\"\": r})\n\n\n<DED><DED>def blockchain_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get(\"https://api.blockchain.com/mercury-gateway/v1/instruments\")\n        return {data[\"symbol\"].replace(\"-\", SYMBOL_SEP): data[\"symbol\"] for data in r.json()}\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BLOCKCHAIN', why, {\"\": r})\n\n\n<DED><DED>def gateio_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get(\"https://api.gateio.ws/api/v4/spot/currency_pairs\")\n        return {data[\"id\"].replace(\"_\", SYMBOL_SEP): data['id'] for data in r.json()}\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('GATEIO', why, {\"\": r})\n\n\n<DED><DED>def bitmex_symbols() -> Dict[str, str]:\n    <IND>r = None\n    ret = {}\n    try:\n        <IND>r = requests.get(\"https://www.bitmex.com/api/v1/instrument/active\")\n        for entry in r.json():\n            <IND>components = []\n            components.append(entry['rootSymbol'])\n            components.append(entry['quoteCurrency'])\n\n            if entry['expiry']:\n                <IND>components.append(entry['symbol'][-3:])\n\n            <DED>normalized = SYMBOL_SEP.join(components)\n            normalized = normalized.replace(\"XBT\", \"BTC\")\n            ret[normalized] = entry['symbol']\n            _exchange_info[BITMEX]['tick_size'][normalized] = entry['tickSize']\n\n            if entry['expiry']:\n                <IND>_exchange_info[BITMEX]['expiry'][normalized] = entry['expiry']\n\n        <DED><DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BITMEX', why, {\"\": r})\n\n\n<DED><DED>def deribit_symbols() -> Dict[str, str]:\n    <IND>url = r = None\n    ret = {}\n    try:\n        # TODO: get currencies from https://www.deribit.com/api/v2/public/get_currencies\n        <IND>currencies = ['BTC', 'ETH']\n        for c in currencies:\n            <IND>url = f\"https://www.deribit.com/api/v2/public/get_instruments?currency={c}&expired=false\"\n            r = requests.get(url)\n            for entry in r.json()['result']:\n                <IND>split = entry['instrument_name'].split(\"-\")\n                normalized = split[0] + SYMBOL_SEP + entry['quote_currency'] + \"-\" + '-'.join(split[1:])\n                ret[normalized] = entry['instrument_name']\n                _exchange_info[DERIBIT]['tick_size'][normalized] = entry['tick_size']\n        <DED><DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('DERIBIT', why, {url: r})\n\n\n<DED><DED>def kraken_future_symbols() -> Dict[str, str]:\n    <IND>r = None\n    ret = {}\n    try:\n        <IND>r = requests.get('https://futures.kraken.com/derivatives/api/v3/instruments')\n        data = r.json()['instruments']\n        for entry in data:\n            <IND>if not entry['tradeable']:\n                <IND>continue\n            <DED>normalized = entry['symbol'].upper().replace(\"_\", \"-\")\n            symbol = normalized[3:6] + SYMBOL_SEP + normalized[6:9]\n            normalized = normalized.replace(normalized[3:9], symbol)\n            normalized = normalized.replace('XBT', 'BTC')\n\n            _exchange_info[KRAKEN_FUTURES]['tick_size'][normalized] = entry['tickSize']\n            _exchange_info[KRAKEN_FUTURES]['contract_size'][normalized] = entry['contractSize']\n            _exchange_info[KRAKEN_FUTURES]['underlying'][normalized] = entry['underlying']\n            _exchange_info[KRAKEN_FUTURES]['product_type'][normalized] = _kraken_futures_product_type[normalized[:2]]\n            ret[normalized] = entry['symbol']\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('KRAKEN_FUTURES', why, {\"\": r})\n\n\n<DED><DED>def probit_symbols() -> Dict[str, str]:\n    # doc: https://docs-en.probit.com/reference-link/market\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.probit.com/api/exchange/v1/market')\n        return {entry['id']: entry['id'] for entry in r.json()['data']}\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('PROBIT', why, {\"\": r})\n\n\n<DED><DED>def coingecko_normalize_symbol(symbol: str) -> str:\n    # keep digits, letters and dots, replace others by space\n    <IND>symbol = ''.join(c if c.isalnum() or c in ('.', '+') else ' ' for c in symbol)\n    return coingecko_normalize(symbol.upper())\n\n\n<DED>def coingecko_normalize_name(name: str) -> str:\n    # keep digits and letters, replace others by space (except when only composed by upper case letters, digits and dots)\n    <IND>if not all(c.isupper() or c.isdigit() or c == '.' for c in name):\n        <IND>name = ''.join(c if c.isalnum() else ' ' for c in name)\n    <DED>return coingecko_normalize(name)\n\n\n<DED>def coingecko_normalize(sym: str) -> str:\n    <IND>sym = sym.strip()\n    # do not concatenate numbers => separate them with a dot\n    sym = list(sym)\n    if len(sym) > 4:\n        <IND>for i in range(2, len(sym) - 1):\n            <IND>if sym[i] == ' ' and sym[i - 1].isdigit() and sym[i + 1].isdigit():\n                <IND>sym[i] = '.'\n    <DED><DED><DED>sym = ''.join(sym)\n    # concatenate space-separated words => use CamelCase to distinguish the words\n    if ' ' in sym:\n        <IND>if sum(c.islower() for c in sym):  # if there is at least one lower case letter\n            <IND>sym = ' '.join(word[0].upper() + word[1:] for word in sym.split())  # Just capitalize initial letter of each word\n        <DED>else:  # CoinGecko may provide full upper-case as for \"THE STONE COIN\"\n            <IND>sym = string.capwords(sym)  # capwords converts \"THE STONE COIN\" to \"The Stone Coin\"\n        <DED>sym = sym.replace(' ', '')  # concatenate words\n    <DED>return sym\n\n\n<DED>def is_name_short(coin: dict) -> bool:\n    <IND>\"\"\"return True if the coin name is enough short compared to the coin symbol.\"\"\"\n    return len(coin['name']) <= max(5, len(coin['symbol']) + 1)\n\n\n<DED>def has_many_caps(name: str) -> bool:\n    <IND>\"\"\"return True if the symbol contains enough upper case letters, False if empty.\"\"\"\n    return str and sum(c.islower() for c in name) < (len(name) / 2)\n\n\n<DED>def coingecko_normalize_all(coin: dict):\n    <IND>SYMBOL_TO_NORMALIZED = {'miota': 'IOTA'}\n    normalized = SYMBOL_TO_NORMALIZED.get(coin['symbol'])\n    if normalized:\n        <IND>coin['ns'] = coin['nn'] = normalized\n        return normalized\n\n    # ns = normalized symbol, nn = normalized name\n    <DED>coin['ns'] = coingecko_normalize_symbol(coin['symbol'])\n\n    ID_SUFFIX = '-bitcoin-token'\n    if coin['id'][-len(ID_SUFFIX):] == ID_SUFFIX:\n        <IND>coin['nn'] = 'BTC' + coin['ns']\n        return coin['nn']\n\n    <DED>name = coin['name']\n\n    prefixes = ('The ', 'the ')\n    for p in prefixes:\n        <IND>if name[:len(p)] == p:\n            <IND>coin['reduced-name'] = True\n            name = name[len(p):]\n            break\n\n    <DED><DED>suffixes = ('coin', 'coins', 'money', 'finance', 'protocol', 'reward', 'rewards', 'token')\n    for s in suffixes:\n        <IND>if len(name) > len(s) and name[-len(s):].lower() == s:\n            # but keep suffix when lower-case concatenated\n            <IND>if name[-len(s)].islower() and name[-len(s) - 1] != ' ':\n                <IND>continue\n            # also keep suffix to avoid confusing nam: \"Bitcoin Token\" -> \"Bitcoin\"\n            <DED>if name[:-len(s)].strip().lower() == 'bitcoin':\n                <IND>continue\n            <DED>coin['reduced-name'] = True\n            name = name[:-len(s)]\n            break\n\n    <DED><DED>coin['nn'] = coingecko_normalize_name(name)\n\n    if len(coin['nn']) < len(coin['ns']):\n        <IND>if 'reduced-name' in coin:\n            <IND>coin['reduced-name'] = False\n            name = coin['name']\n            coin['nn'] = coingecko_normalize_name(name)\n        <DED>elif not has_many_caps(name):\n            <IND>return coin['ns']\n\n    <DED><DED>if not coin['ns']:  # coin['symbol'] may be an emoji that is striped when normalized\n        <IND>return coin['nn']\n\n    <DED>if coin.get('reduced-name') and coin['ns'].upper() != coin['nn'].upper():\n        <IND>return coin['ns']\n\n    <DED>i = coin['nn'].find('.')  # if there is a dot in normalized name => prefer the normalized symbol\n    if i >= 0:\n        <IND>if i > 1 and coin['nn'][i - 1].isdigit() and coin['nn'][i + 1].isdigit():\n            <IND>pass  # except when the dot separates digits\n        <DED>else:\n            <IND>return coin['ns']\n\n    <DED><DED>if is_name_short(coin) and has_many_caps(name):\n        <IND>return coin['nn']\n\n    <DED>if 1.5 * len(coin['ns']) > len(coin['nn']) and any(c.islower() for c in coin['ns']):\n        <IND>return coin['nn']\n\n    <DED>return coin['ns']\n\n\n<DED>def coingecko_symbols() -> Dict[str, str]:\n    <IND>r = None\n    intermediate = defaultdict(list)\n    try:\n        <IND>r = requests.get('https://api.coingecko.com/api/v3/coins/list')\n        all_coins = r.json()\n        # First pass: generate & compare normalized symbol/name, and then select the most pertinent\n        for coin in all_coins:\n            <IND>normalized = coingecko_normalize_all(coin)\n            intermediate[normalized].append(coin)\n            # Above line keeps together the coins having the same normalized symbol.\n            # To reduce collision, the coin['name'] is sometimes used in lieu of the coin['symbol'].\n            # The coin['name'] is not capitalized because lower case letters may be meaningful: cETH, yUSD, DATx, zLOT\n    <DED><DED>except Exception as why:\n        <IND>raise_failure_explanation('COINGECKO', why, {\"\": r})\n\n    <DED>final = coingecko_second_pass(intermediate)\n    return coingecko_third_pass(final)\n\n\n<DED>def coingecko_second_pass(intermediate: Dict[str, List[dict]]) -> Dict[str, List[dict]]:\n    # Second pass: fixes most of the symbol collisions\n    <IND>final = defaultdict(list)\n    for normalized, coins in intermediate.items():\n        <IND>if len(coins) == 1:\n            <IND>final[normalized].append(coins[0])\n            continue\n        <DED>set_normalized = False\n        for i in range(len(coins)):\n            <IND>if normalized == coins[i]['nn']:\n                <IND>coin = coins.pop(i)\n                final[normalized].append(coin)\n                set_normalized = True\n                break\n        <DED><DED>rest: List[dict] = []\n        for coin in coins:\n            <IND>if '%' in coin['name']:\n                <IND>if len(coins) == 1:\n                    <IND>n = coin['ns']\n                <DED>else:\n                    <IND>n = coingecko_normalize_name(coin['id'])\n                <DED>final[n].append(coin)\n            <DED>else:\n                <IND>rest.append(coin)\n        <DED><DED>if not rest:\n            <IND>continue\n        <DED>if not set_normalized:\n            <IND>rest.sort(key=lambda coin: len(coin['nn']), reverse=True)  # sort by the length of the normalized name\n            coin = rest.pop(0)\n            final[normalized].append(coin)\n        <DED>for coin in rest:\n            <IND>if coin['nn'] not in intermediate:\n                <IND>n = coin['nn']\n            <DED>elif coin.get('reduced-name'):\n                <IND>n = coingecko_normalize_name(coin['name'])\n            <DED>else:\n                <IND>n = coingecko_normalize_name(coin['id'])\n            <DED>final[n].append(coin)\n    <DED><DED>return final\n\n\n<DED>def coingecko_third_pass(final: Dict[str, List[dict]]) -> Dict[str, str]:\n    # Third pass: fixes some remaining collisions and fills the result\n    <IND>symbols = {}\n    for normalized, coins in final.items():\n        <IND>if len(coins) == 1:\n            <IND>symbols[normalized] = coins[0]['id']\n            continue\n        <DED>set_normalized = False\n        for i in range(len(coins)):\n            <IND>if normalized == coins[i]['nn']:\n                <IND>coin = coins.pop(i)\n                symbols[normalized] = coin['id']\n                set_normalized = True\n                break\n        <DED><DED>rest: List[dict] = []\n        for coin in coins:\n            <IND>if '%' in coin['name']:\n                <IND>if len(coins) == 1:\n                    <IND>n = coin['ns']\n                <DED>else:\n                    <IND>n = coingecko_normalize_name(coin['id'])\n                <DED>symbols[n] = coin['id']\n            <DED>else:\n                <IND>rest.append(coin)\n        <DED><DED>if not rest:\n            <IND>continue\n        <DED>if not set_normalized:\n            <IND>rest.sort(key=lambda coin: len(coin['nn']), reverse=True)  # sort by the length of the normalized name\n            coin = rest.pop(0)\n            symbols[normalized] = coin['id']\n        <DED>for coin in rest:\n            <IND>if coin['nn'] not in final:\n                <IND>n = coin['nn']\n            <DED>elif coin.get('reduced-name'):\n                <IND>n = coingecko_normalize_name(coin['name'])\n            <DED>else:\n                <IND>n = coingecko_normalize_name(coin['id'])\n            <DED>symbols[n] = coin['id']\n    <DED><DED>return symbols\n\n\n<DED>def whale_alert_coins(key_id: str) -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get(f'https://api.whale-alert.io/v1/status?api_key={key_id}')\n        # Same symbols, but on different blockchains (for instance USDT), are naturally overwritten.\n        return {s.upper(): s for b in r.json()['blockchains'] for s in b['symbols'] if s}\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('WHALES_ALERT', why, {\"\": r})\n\n\n<DED><DED>_exchange_function_map = {\n    BITFINEX: bitfinex_symbols,\n    BITFLYER: bitflyer_symbols,\n    COINBASE: coinbase_symbols,\n    GEMINI: gemini_symbols,\n    HITBTC: hitbtc_symbols,\n    POLONIEX: poloniex_symbols,\n    PROBIT: probit_symbols,\n    BITSTAMP: bitstamp_symbols,\n    KRAKEN: kraken_symbols,\n    KRAKEN + 'REST': kraken_rest_symbols,\n    BINANCE: binance_symbols,\n    BINANCE_US: binance_us_symbols,\n    BINANCE_FUTURES: binance_futures_symbols,\n    BINANCE_DELIVERY: binance_delivery_symbols,\n    BLOCKCHAIN: blockchain_symbols,\n    EXX: exx_symbols,\n    HUOBI: huobi_symbols,\n    HUOBI_DM: huobi_dm_symbols,\n    HUOBI_SWAP: huobi_swap_symbols,\n    OKCOIN: okcoin_symbols,\n    OKEX: okex_symbols,\n    BYBIT: bybit_symbols,\n    FTX: ftx_symbols,\n    FTX_US: ftx_us_symbols,\n    BITTREX: bittrex_symbols,\n    BITCOINCOM: bitcoincom_symbols,\n    BITMAX: bitmax_symbols,\n    UPBIT: upbit_symbols,\n    GATEIO: gateio_symbols,\n    BITMEX: bitmex_symbols,\n    DERIBIT: deribit_symbols,\n    KRAKEN_FUTURES: kraken_future_symbols,\n    COINGECKO: coingecko_symbols,\n    WHALE_ALERT: whale_alert_coins\n}\n",
        "target_code_with_indent": "\nfrom typing import Dict, Tuple\n\n\nclass _Symbols:\n    <IND>def __init__(self):\n        <IND>self.data = {}\n\n    <DED>def set(self, exchange: str, normalized: dict, exchange_info: dict):\n        <IND>self.data[exchange] = {}\n        self.data[exchange]['normalized'] = normalized\n        self.data[exchange]['info'] = exchange_info\n\n    <DED>def get(self, exchange: str) -> Tuple[Dict, Dict]:\n        <IND>return self.data[exchange]['normalized'], self.data[exchange]['info']\n\n    <DED>def populated(self, exchange: str) -> bool:\n        <IND>return exchange in self.data\n\n\n<DED><DED>Symbols = _Symbols()\n"
      }
    ]
  },
  {
    "project": "bmoscon/cryptofeed",
    "commit": "3525dc8ce4d7836a9abaaa5662e58e5e27969a77",
    "filename": "cryptofeed/symbols.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/bmoscon-cryptofeed/cryptofeed/symbols.py",
    "file_hunks_size": 1,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "cryptofeed/symbols.py:164:8 Incompatible return type [7]: Expected `Dict[str, str]` but got implicit return value of `None`.",
    "message": " Expected `Dict[str, str]` but got implicit return value of `None`.",
    "rule_id": "Incompatible return type [7]",
    "warning_line_no": 164,
    "warning_line": "        raise_failure_explanation('BITFLYER', why, {endpoint: r})",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "associated with this software.\n\n\nSymbol generation code for exchanges\n'''\n\nimport logging\nimport string\nimport time\nfrom collections import defaultdict\nfrom typing import Dict, List, Optional, Tuple\n\nimport requests\nfrom requests import Response\n\nfrom cryptofeed.defines import *\n\n\nLOG = logging.getLogger('feedhandler')\n\nSYMBOL_SEP = '-'\n\n_symbols_retrieval_cache: Dict[str, Dict[str, str]] = {}\n_exchange_info = defaultdict(lambda: defaultdict(dict))\n\n\n_kraken_futures_product_type = {\n    'FI': 'Inverse Futures',\n    'FV': 'Vanilla Futures',\n    'PI': 'Perpetual Inverse Futures',\n    'PV': 'Perpetual Vanilla Futures',\n    'IN': 'Real Time Index',\n    'RR': 'Reference Rate',\n}\n\n\ndef raise_failure_explanation(feed_id: str, exception: BaseException, responses: Dict[str, Optional[Response]]):\n    LOG.critical('%s: encountered %r while processing response from exchange API', feed_id, exception)\n    if len(responses) > 1:\n        LOG.critical('%s: content of one of the %s responses was unexpected', feed_id, len(responses))\n    for url, r in responses.items():\n        if url:\n            LOG.critical('%s: requested URL: %s', feed_id, url)\n        if r:\n            LOG.critical('%s: unexpected response: %s', feed_id, r.text)\n    raise ValueError(f'Cryptofeed stopped because of an unexpected response from {feed_id}') from exception\n\n\ndef set_symbol_separator(separator: str):\n    global SYMBOL_SEP\n    SYMBOL_SEP = separator\n\n\ndef get_symbol_separator() -> str:\n    global SYMBOL_SEP\n    return SYMBOL_SEP\n\n\ndef gen_symbols(exchange: str, key_id=None) -> Dict[str, str]:\n    if exchange not in _symbols_retrieval_cache:\n        LOG.info(\"%s: Getting list of symbols\", exchange)\n        symbols = _exchange_function_map[exchange](key_id) if key_id else _exchange_function_map[exchange]()\n        LOG.info(\"%s: %s symbols\", exchange, len(symbols))\n\n        # log all retrieved symbols using debug level\n        for normalized, exch_sym in sorted(symbols.items()):\n            LOG.debug('%s: id-from-exch -> normalized: %-35s-> %s', exchange, exch_sym, normalized)\n\n        _symbols_retrieval_cache[exchange] = symbols\n    return _symbols_retrieval_cache[exchange]\n\n\ndef _binance_symbols(endpoint: str, exchange: str):\n    r = None\n    try:\n        ret = {}\n        r = requests.get(endpoint)\n        for symbol in r.json()['symbols']:\n            if symbol.get('status', 'TRADING') != \"TRADING\":\n                continue\n            if symbol.get('contractStatus', 'TRADING') != \"TRADING\":\n                continue\n            split = len(symbol['baseAsset'])\n            normalized = symbol['symbol'][:split] + SYMBOL_SEP + symbol['symbol'][split:]\n            ret[normalized] = symbol['symbol']\n            _exchange_info[exchange]['tick_size'][normalized] = symbol['filters'][0]['tickSize']\n            if \"contractType\" in symbol:\n                _exchange_info[exchange]['contract_type'][normalized] = symbol['contractType']\n        return ret\n    except Exception as why:\n        raise_failure_explanation(exchange, why, {endpoint: r})\n\n\ndef binance_symbols() -> Dict[str, str]:\n    return _binance_symbols('https://api.binance.com/api/v3/exchangeInfo', BINANCE)\n\n\ndef binance_us_symbols() -> Dict[str, str]:\n    return _binance_symbols('https://api.binance.us/api/v3/exchangeInfo', BINANCE_US)\n\n\ndef binance_futures_symbols() -> Dict[str, str]:\n    base = _binance_symbols('https://fapi.binance.com/fapi/v1/exchangeInfo', BINANCE_FUTURES)\n    add = {}\n    for symbol, orig in base.items():\n        if \"_\" in orig:\n            continue\n        add[f\"{symbol}-PINDEX\"] = f\"p{orig}\"\n    base.update(add)\n    return base\n\n\ndef binance_delivery_symbols() -> Dict[str, str]:\n    return _binance_symbols('https://dapi.binance.com/dapi/v1/exchangeInfo', BINANCE_DELIVERY)\n\n\ndef bitfinex_symbols() -> Dict[str, str]:\n    # doc: https://docs.bitfinex.com/docs/ws-general#supported-pairs\n    r1 = r2 = None\n    try:\n        r1 = requests.get('https://api.bitfinex.com/v2/tickers?symbols=ALL')\n        r2 = requests.get('https://api-pub.bitfinex.com/v2/conf/pub:map:currency:sym')\n        tickers: List[List[str]] = r1.json()\n        norm: List[Tuple[str, str]] = r2.json()[0]\n        norm: Dict[str, str] = dict(norm)\n        for k, v in dict(norm).items():\n            if k[-2:] == 'F0' or '-' in v:  # Do not convert BTCF0 -> BTC or PBTCETH -> PBTC-ETH\n                del norm[k]\n        norm['BCHN'] = 'BCH'  # Bitfinex uses BCHN, other exchanges use BCH\n\n        ret = {}\n        for symbol in [t[0] for t in tickers]:\n            if symbol[0] == 'f':\n                normalized = norm.get(symbol[1:], symbol[1:])\n            else:\n                if len(symbol) == 7:\n                    base, quote = symbol[1:4], symbol[4:]\n                else:\n                    base, quote = symbol[1:].split(':')\n                    assert ':' in symbol\n                normalized = norm.get(base, base) + SYMBOL_SEP + norm.get(quote, quote)\n            ret[normalized.upper()] = symbol\n        return ret\n    except ValueError as why:\n        raise_failure_explanation('BITFINEX', why, {\"tickers?symbols=ALL\": r1, \"pub:map:currency:sym\": r2})\n\n\ndef bitflyer_symbols() -> Dict[str, str]:\n    endpoint = r = None\n    try:\n        ret = {}\n        endpoints = ['https://api.bitflyer.com/v1/getmarkets/eu', 'https://api.bitflyer.com/v1/getmarkets/usa', 'https://api.bitflyer.com/v1/getmarkets']\n        for endpoint in endpoints:\n            r = requests.get(endpoint)\n            for entry in r.json():\n                normalized = entry['product_code'].replace(\"_\", SYMBOL_SEP)\n                ret[normalized] = entry['product_code']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('BITFLYER', why, {endpoint: r})\n\n\ndef bybit_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.bybit.com/v2/public/symbols')\n        ret = {}\n        for symbol in r.json()['result']:\n            quote = symbol['quote_currency']\n            if not symbol['name'].endswith(quote):\n                base, contract = symbol['name'].split(quote)\n                normalized = f\"{base}{SYMBOL_SEP}{quote}-{contract}\"\n            else:\n                normalized = f\"{symbol['base_currency']}{SYMBOL_SEP}{quote}\"\n            ret[normalized] = symbol['name']\n            _exchange_info[BYBIT]['tick_size'][normalized] = symbol['price_filter']['tick_size']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('BYBIT', why, {\"\": r})\n\n\ndef _ftx_helper(endpoint: str, exchange: str):\n    r = None\n    try:\n        r = requests.get(endpoint)\n        ret = {}\n        for data in r.json()['result']:\n            normalized = data['name'].replace(\"/\", SYMBOL_SEP)\n            symbol = data['name']\n            ret[normalized] = symbol\n            _exchange_info[exchange]['tick_size'][normalized] = data['priceIncrement']\n        return ret\n    except Exception as why:\n        raise_failure_explanation(exchange, why, {endpoint: r})\n\n\ndef ftx_symbols() -> Dict[str, str]:\n    return _ftx_helper('https://ftx.com/api/markets', FTX)\n\n\ndef ftx_us_symbols() -> Dict[str, str]:\n    return _ftx_helper('https://ftx.us/api/markets', FTX_US)\n\n\ndef coinbase_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.pro.coinbase.com/products')\n        ret = {}\n        for data in r.json():\n            normalized = data['id'].replace(\"-\", SYMBOL_SEP)\n            ret[normalized] = data['id']\n            _exchange_info[COINBASE]['tick_size'][normalized] = data['quote_increment']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('COINBASE', why, {\"\": r})\n\n\ndef gemini_symbols(*args) -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.gemini.com/v1/symbols')\n        ret = {}\n        for symbol in r.json():\n            std = f\"{symbol[:-3]}{SYMBOL_SEP}{symbol[-3:]}\"\n            std = std.upper()\n            ret[std] = symbol.upper()\n        return ret\n    except Exception as why:\n        raise_failure_explanation('GEMINI', why, {\"\": r})\n\n\ndef hitbtc_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        ret = {}\n        r = requests.get('https://api.hitbtc.com/api/2/public/symbol')\n        for symbol in r.json():\n            split = len(symbol['baseCurrency'])\n            normalized = symbol['id'][:split] + SYMBOL_SEP + symbol['id'][split:]\n            ret[normalized] = symbol['id']\n            _exchange_info[HITBTC]['tick_size'][normalized] = symbol['tickSize']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('HITBTC', why, {\"\": r})\n\n\ndef poloniex_id_symbol_mapping():\n    r = None\n    try:\n        r = requests.get('https://poloniex.com/public?command=returnTicker')\n        symbols = r.json()\n        ret = {}\n        for symbol in symbols:\n            ret[symbols[symbol]['id']] = symbol\n        return ret\n    except Exception as why:\n        raise_failure_explanation('POLONIEX', why, {\"\": r})\n\n\ndef poloniex_symbols() -> Dict[str, str]:\n    ret = {}\n    for _, value in poloniex_id_symbol_mapping().items():\n        std = value.replace(\"STR\", \"XLM\")\n        quote, base = std.split(\"_\")\n        ret[quote + SYMBOL_SEP + base] = value\n    return ret\n\n\ndef bitstamp_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://www.bitstamp.net/api/v2/trading-pairs-info/')\n        ret = {}\n        for data in r.json():\n            normalized = data['name'].replace(\"/\", SYMBOL_SEP)\n            symbol = data['url_symbol']\n            ret[normalized] = symbol\n        return ret\n    except Exception as why:\n        raise_failure_explanation('BITSTAMP', why, {\"\": r})\n\n\ndef kraken_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.kraken.com/0/public/AssetPairs')\n        data = r.json()\n        ret = {}\n        for symbol in data['result']:\n            if 'wsname' not in data['result'][symbol] or '.d' in symbol:\n                # https://blog.kraken.com/post/259/introducing-the-kraken-dark-pool/\n                # .d is for dark pool symbols\n                continue\n\n            base, quote = data['result'][symbol]['wsname'].split(\"/\")\n\n            normalized = f\"{base}{SYMBOL_SEP}{quote}\"\n            exch = data['result'][symbol]['wsname']\n            normalized = normalized.replace('XBT', 'BTC')\n            normalized = normalized.replace('XDG', 'DOG')\n            ret[normalized] = exch\n        return ret\n    except Exception as why:\n        raise_failure_explanation('KRAKEN', why, {\"\": r})\n\n\ndef kraken_rest_symbols() -> Dict[str, str]:\n    return {normalized: exchange.replace(\"/\", \"\") for normalized, exchange in kraken_symbols().items()}\n\n\ndef exx_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.exx.com/data/v1/tickers')\n        exchange = [key.upper() for key in r.json().keys()]\n        symbols = [key.replace(\"_\", SYMBOL_SEP) for key in exchange]\n        return dict(zip(symbols, exchange))\n    except Exception as why:\n        raise_failure_explanation('EXX', why, {\"\": r})\n\n\ndef huobi_common_symbols(url: str):\n    r = None\n    try:\n        r = requests.get(url)\n        ret = {}\n        for e in r.json()['data']:\n            if e['state'] == 'offline':\n                continue\n            normalized = f\"{e['base-currency'].upper()}{SYMBOL_SEP}{e['quote-currency'].upper()}\"\n            symbol = f\"{e['base-currency']}{e['quote-currency']}\"\n            ret[normalized] = symbol\n        return ret\n    except Exception as why:\n        raise_failure_explanation('HUOBI', why, {url: r})\n\n\ndef huobi_symbols() -> Dict[str, str]:\n    return huobi_common_symbols('https://api.huobi.pro/v1/common/symbols')\n\n\ndef huobi_us_symbols() -> Dict[str, str]:\n    return huobi_common_symbols('https://api.huobi.com/v1/common/symbols')\n\n\ndef huobi_dm_symbols() -> Dict[str, str]:\n    \"\"\"\n    Mapping is, for instance: {\"BTC_CW\":\"BTC190816\"}\n    See comments in exchange/huobi_dm.py\n    \"\"\"\n    mapping = {\n        \"this_week\": \"CW\",\n        \"next_week\": \"NW\",\n        \"quarter\": \"CQ\",\n        \"next_quarter\": \"NQ\"\n    }\n    r = None\n    try:\n        r = requests.get('https://www.hbdm.com/api/v1/contract_contract_info')\n        symbols = {}\n        for e in r.json()['data']:\n            symbols[f\"{e['symbol']}_{mapping[e['contract_type']]}\"] = e['contract_code']\n            _exchange_info[HUOBI_DM]['tick_size'][e['contract_code']] = e['price_tick']\n            _exchange_info[HUOBI_DM]['short_code_mappings'][f\"{e['symbol']}_{mapping[e['contract_type']]}\"] = e['contract_code']\n        return symbols\n    except Exception as why:\n        raise_failure_explanation('HUOBI_DM', why, {\"\": r})\n\n\ndef huobi_swap_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.hbdm.com/swap-api/v1/swap_contract_info')\n        symbols = {}\n        for e in r.json()['data']:\n            symbols[e['contract_code']] = e['contract_code']\n            _exchange_info[HUOBI_SWAP]['tick_size'][e['contract_code']] = e['price_tick']\n        return symbols\n    except Exception as why:\n        raise_failure_explanation('HUOBI_SWAP', why, {\"\": r})\n\n\ndef okcoin_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://www.okcoin.com/api/spot/v3/instruments')\n        ret = {}\n        for e in r.json():\n            ret[e['instrument_id']] = e['instrument_id']\n            _exchange_info[OKCOIN]['tick_size'][e['instrument_id']] = e['tick_size']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('OKCOIN', why, {\"\": r})\n\n\ndef okex_symbols(*args) -> Dict[str, str]:\n    urls = ['https://www.okex.com/api/spot/v3/instruments',\n            'https://www.okex.com/api/swap/v3/instruments',\n            'https://www.okex.com/api/futures/v3/instruments']\n    urls = urls + okex_compute_option_urls_from_underlyings()\n\n    symbols: Dict[str, str] = {}\n    for u in urls:\n        time.sleep(0.2)\n        symbols.update(okex_symbols_from_one_url(u))\n\n    for symbol in symbols:\n        instrument_type = 'futures'\n        dash_count = symbol.count(get_symbol_separator())\n        if dash_count == 1:  # BTC-USDT\n            instrument_type = 'spot'\n        if dash_count == 4:  # BTC-USD-201225-35000-P\n            instrument_type = 'option'\n        if symbol[-4:] == \"SWAP\":  # BTC-USDT-SWAP\n            instrument_type = 'swap'\n\n        _exchange_info[OKEX]['instrument_type'][symbol] = instrument_type\n\n    return symbols\n\n\ndef okex_compute_option_urls_from_underlyings() -> List[str]:\n    url = 'https://www.okex.com/api/option/v3/underlying'\n    r = None\n    try:\n        r = requests.get(url)\n        return [f'https://www.okex.com/api/option/v3/instruments/{underlying}' for underlying in r.json()]\n    except Exception as why:\n        raise_failure_explanation('OKEX', why, {url: r})\n\n\ndef okex_symbols_from_one_url(url: str) -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get(url)\n        ret = {}\n        for e in r.json():\n            ret[e['instrument_id']] = e['instrument_id']\n            _exchange_info[OKEX]['tick_size'][e['instrument_id']] = e['tick_size']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('OKEX', why, {url: r})\n\n\ndef bittrex_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.bittrex.com/api/v1.1/public/getmarkets')\n        r = r.json()['result']\n        return {f\"{e['MarketCurrency']}{SYMBOL_SEP}{e['BaseCurrency']}\": e['MarketName'] for e in r if e['IsActive']}\n    except Exception as why:\n        raise_failure_explanation('BITTREX', why, {\"\": r})\n\n\ndef bitcoincom_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.exchange.bitcoin.com/api/2/public/symbol')\n        return {f\"{data['baseCurrency']}{SYMBOL_SEP}{data['quoteCurrency'].replace('USD', 'USDT')}\": data['id'] for data in r.json()}\n    except Exception as why:\n        raise_failure_explanation('BITCOINCOM', why, {\"\": r})\n\n\ndef bitmax_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://bitmax.io/api/pro/v1/products')\n        ret = {}\n        for entry in r.json()['data']:\n            # Only \"Normal\" status symbols are tradeable\n            if entry['status'] == 'Normal':\n                normalized = f\"{entry['baseAsset']}{SYMBOL_SEP}{entry['quoteAsset']}\"\n                ret[normalized] = entry['symbol']\n                _exchange_info[BITMAX]['tick_size'][normalized] = entry['tickSize']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('BITMAX', why, {\"\": r})\n\n\ndef upbit_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.upbit.com/v1/market/all')\n        return {f\"{data['market'].split('-')[1]}{SYMBOL_SEP}{data['market'].split('-')[0]}\": data['market'] for data in r.json()}\n    except Exception as why:\n        raise_failure_explanation('UPBIT', why, {\"\": r})\n\n\ndef blockchain_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get(\"https://api.blockchain.com/mercury-gateway/v1/instruments\")\n        return {data[\"symbol\"].replace(\"-\", SYMBOL_SEP): data[\"symbol\"] for data in r.json()}\n    except Exception as why:\n        raise_failure_explanation('BLOCKCHAIN', why, {\"\": r})\n\n\ndef gateio_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get(\"https://api.gateio.ws/api/v4/spot/currency_pairs\")\n        return {data[\"id\"].replace(\"_\", SYMBOL_SEP): data['id'] for data in r.json()}\n    except Exception as why:\n        raise_failure_explanation('GATEIO', why, {\"\": r})\n\n\ndef bitmex_symbols() -> Dict[str, str]:\n    r = None\n    ret = {}\n    try:\n        r = requests.get(\"https://www.bitmex.com/api/v1/instrument/active\")\n        for entry in r.json():\n            components = []\n            components.append(entry['rootSymbol'])\n            components.append(entry['quoteCurrency'])\n\n            if entry['expiry']:\n                components.append(entry['symbol'][-3:])\n\n            normalized = SYMBOL_SEP.join(components)\n            normalized = normalized.replace(\"XBT\", \"BTC\")\n            ret[normalized] = entry['symbol']\n            _exchange_info[BITMEX]['tick_size'][normalized] = entry['tickSize']\n\n            if entry['expiry']:\n                _exchange_info[BITMEX]['expiry'][normalized] = entry['expiry']\n\n        return ret\n    except Exception as why:\n        raise_failure_explanation('BITMEX', why, {\"\": r})\n\n\ndef deribit_symbols() -> Dict[str, str]:\n    url = r = None\n    ret = {}\n    try:\n        # TODO: get currencies from https://www.deribit.com/api/v2/public/get_currencies\n        currencies = ['BTC', 'ETH']\n        for c in currencies:\n            url = f\"https://www.deribit.com/api/v2/public/get_instruments?currency={c}&expired=false\"\n            r = requests.get(url)\n            for entry in r.json()['result']:\n                split = entry['instrument_name'].split(\"-\")\n                normalized = split[0] + SYMBOL_SEP + entry['quote_currency'] + \"-\" + '-'.join(split[1:])\n                ret[normalized] = entry['instrument_name']\n                _exchange_info[DERIBIT]['tick_size'][normalized] = entry['tick_size']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('DERIBIT', why, {url: r})\n\n\ndef kraken_future_symbols() -> Dict[str, str]:\n    r = None\n    ret = {}\n    try:\n        r = requests.get('https://futures.kraken.com/derivatives/api/v3/instruments')\n        data = r.json()['instruments']\n        for entry in data:\n            if not entry['tradeable']:\n                continue\n            normalized = entry['symbol'].upper().replace(\"_\", \"-\")\n            symbol = normalized[3:6] + SYMBOL_SEP + normalized[6:9]\n            normalized = normalized.replace(normalized[3:9], symbol)\n            normalized = normalized.replace('XBT', 'BTC')\n\n            _exchange_info[KRAKEN_FUTURES]['tick_size'][normalized] = entry['tickSize']\n            _exchange_info[KRAKEN_FUTURES]['contract_size'][normalized] = entry['contractSize']\n            _exchange_info[KRAKEN_FUTURES]['underlying'][normalized] = entry['underlying']\n            _exchange_info[KRAKEN_FUTURES]['product_type'][normalized] = _kraken_futures_product_type[normalized[:2]]\n            ret[normalized] = entry['symbol']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('KRAKEN_FUTURES', why, {\"\": r})\n\n\ndef probit_symbols() -> Dict[str, str]:\n    # doc: https://docs-en.probit.com/reference-link/market\n    r = None\n    try:\n        r = requests.get('https://api.probit.com/api/exchange/v1/market')\n        return {entry['id']: entry['id'] for entry in r.json()['data']}\n    except Exception as why:\n        raise_failure_explanation('PROBIT', why, {\"\": r})\n\n\ndef coingecko_normalize_symbol(symbol: str) -> str:\n    # keep digits, letters and dots, replace others by space\n    symbol = ''.join(c if c.isalnum() or c in ('.', '+') else ' ' for c in symbol)\n    return coingecko_normalize(symbol.upper())\n\n\ndef coingecko_normalize_name(name: str) -> str:\n    # keep digits and letters, replace others by space (except when only composed by upper case letters, digits and dots)\n    if not all(c.isupper() or c.isdigit() or c == '.' for c in name):\n        name = ''.join(c if c.isalnum() else ' ' for c in name)\n    return coingecko_normalize(name)\n\n\ndef coingecko_normalize(sym: str) -> str:\n    sym = sym.strip()\n    # do not concatenate numbers => separate them with a dot\n    sym = list(sym)\n    if len(sym) > 4:\n        for i in range(2, len(sym) - 1):\n            if sym[i] == ' ' and sym[i - 1].isdigit() and sym[i + 1].isdigit():\n                sym[i] = '.'\n    sym = ''.join(sym)\n    # concatenate space-separated words => use CamelCase to distinguish the words\n    if ' ' in sym:\n        if sum(c.islower() for c in sym):  # if there is at least one lower case letter\n            sym = ' '.join(word[0].upper() + word[1:] for word in sym.split())  # Just capitalize initial letter of each word\n        else:  # CoinGecko may provide full upper-case as for \"THE STONE COIN\"\n            sym = string.capwords(sym)  # capwords converts \"THE STONE COIN\" to \"The Stone Coin\"\n        sym = sym.replace(' ', '')  # concatenate words\n    return sym\n\n\ndef is_name_short(coin: dict) -> bool:\n    \"\"\"return True if the coin name is enough short compared to the coin symbol.\"\"\"\n    return len(coin['name']) <= max(5, len(coin['symbol']) + 1)\n\n\ndef has_many_caps(name: str) -> bool:\n    \"\"\"return True if the symbol contains enough upper case letters, False if empty.\"\"\"\n    return str and sum(c.islower() for c in name) < (len(name) / 2)\n\n\ndef coingecko_normalize_all(coin: dict):\n    SYMBOL_TO_NORMALIZED = {'miota': 'IOTA'}\n    normalized = SYMBOL_TO_NORMALIZED.get(coin['symbol'])\n    if normalized:\n        coin['ns'] = coin['nn'] = normalized\n        return normalized\n\n    # ns = normalized symbol, nn = normalized name\n    coin['ns'] = coingecko_normalize_symbol(coin['symbol'])\n\n    ID_SUFFIX = '-bitcoin-token'\n    if coin['id'][-len(ID_SUFFIX):] == ID_SUFFIX:\n        coin['nn'] = 'BTC' + coin['ns']\n        return coin['nn']\n\n    name = coin['name']\n\n    prefixes = ('The ', 'the ')\n    for p in prefixes:\n        if name[:len(p)] == p:\n            coin['reduced-name'] = True\n            name = name[len(p):]\n            break\n\n    suffixes = ('coin', 'coins', 'money', 'finance', 'protocol', 'reward', 'rewards', 'token')\n    for s in suffixes:\n        if len(name) > len(s) and name[-len(s):].lower() == s:\n            # but keep suffix when lower-case concatenated\n            if name[-len(s)].islower() and name[-len(s) - 1] != ' ':\n                continue\n            # also keep suffix to avoid confusing nam: \"Bitcoin Token\" -> \"Bitcoin\"\n            if name[:-len(s)].strip().lower() == 'bitcoin':\n                continue\n            coin['reduced-name'] = True\n            name = name[:-len(s)]\n            break\n\n    coin['nn'] = coingecko_normalize_name(name)\n\n    if len(coin['nn']) < len(coin['ns']):\n        if 'reduced-name' in coin:\n            coin['reduced-name'] = False\n            name = coin['name']\n            coin['nn'] = coingecko_normalize_name(name)\n        elif not has_many_caps(name):\n            return coin['ns']\n\n    if not coin['ns']:  # coin['symbol'] may be an emoji that is striped when normalized\n        return coin['nn']\n\n    if coin.get('reduced-name') and coin['ns'].upper() != coin['nn'].upper():\n        return coin['ns']\n\n    i = coin['nn'].find('.')  # if there is a dot in normalized name => prefer the normalized symbol\n    if i >= 0:\n        if i > 1 and coin['nn'][i - 1].isdigit() and coin['nn'][i + 1].isdigit():\n            pass  # except when the dot separates digits\n        else:\n            return coin['ns']\n\n    if is_name_short(coin) and has_many_caps(name):\n        return coin['nn']\n\n    if 1.5 * len(coin['ns']) > len(coin['nn']) and any(c.islower() for c in coin['ns']):\n        return coin['nn']\n\n    return coin['ns']\n\n\ndef coingecko_symbols() -> Dict[str, str]:\n    r = None\n    intermediate = defaultdict(list)\n    try:\n        r = requests.get('https://api.coingecko.com/api/v3/coins/list')\n        all_coins = r.json()\n        # First pass: generate & compare normalized symbol/name, and then select the most pertinent\n        for coin in all_coins:\n            normalized = coingecko_normalize_all(coin)\n            intermediate[normalized].append(coin)\n            # Above line keeps together the coins having the same normalized symbol.\n            # To reduce collision, the coin['name'] is sometimes used in lieu of the coin['symbol'].\n            # The coin['name'] is not capitalized because lower case letters may be meaningful: cETH, yUSD, DATx, zLOT\n    except Exception as why:\n        raise_failure_explanation('COINGECKO', why, {\"\": r})\n\n    final = coingecko_second_pass(intermediate)\n    return coingecko_third_pass(final)\n\n\ndef coingecko_second_pass(intermediate: Dict[str, List[dict]]) -> Dict[str, List[dict]]:\n    # Second pass: fixes most of the symbol collisions\n    final = defaultdict(list)\n    for normalized, coins in intermediate.items():\n        if len(coins) == 1:\n            final[normalized].append(coins[0])\n            continue\n        set_normalized = False\n        for i in range(len(coins)):\n            if normalized == coins[i]['nn']:\n                coin = coins.pop(i)\n                final[normalized].append(coin)\n                set_normalized = True\n                break\n        rest: List[dict] = []\n        for coin in coins:\n            if '%' in coin['name']:\n                if len(coins) == 1:\n                    n = coin['ns']\n                else:\n                    n = coingecko_normalize_name(coin['id'])\n                final[n].append(coin)\n            else:\n                rest.append(coin)\n        if not rest:\n            continue\n        if not set_normalized:\n            rest.sort(key=lambda coin: len(coin['nn']), reverse=True)  # sort by the length of the normalized name\n            coin = rest.pop(0)\n            final[normalized].append(coin)\n        for coin in rest:\n            if coin['nn'] not in intermediate:\n                n = coin['nn']\n            elif coin.get('reduced-name'):\n                n = coingecko_normalize_name(coin['name'])\n            else:\n                n = coingecko_normalize_name(coin['id'])\n            final[n].append(coin)\n    return final\n\n\ndef coingecko_third_pass(final: Dict[str, List[dict]]) -> Dict[str, str]:\n    # Third pass: fixes some remaining collisions and fills the result\n    symbols = {}\n    for normalized, coins in final.items():\n        if len(coins) == 1:\n            symbols[normalized] = coins[0]['id']\n            continue\n        set_normalized = False\n        for i in range(len(coins)):\n            if normalized == coins[i]['nn']:\n                coin = coins.pop(i)\n                symbols[normalized] = coin['id']\n                set_normalized = True\n                break\n        rest: List[dict] = []\n        for coin in coins:\n            if '%' in coin['name']:\n                if len(coins) == 1:\n                    n = coin['ns']\n                else:\n                    n = coingecko_normalize_name(coin['id'])\n                symbols[n] = coin['id']\n            else:\n                rest.append(coin)\n        if not rest:\n            continue\n        if not set_normalized:\n            rest.sort(key=lambda coin: len(coin['nn']), reverse=True)  # sort by the length of the normalized name\n            coin = rest.pop(0)\n            symbols[normalized] = coin['id']\n        for coin in rest:\n            if coin['nn'] not in final:\n                n = coin['nn']\n            elif coin.get('reduced-name'):\n                n = coingecko_normalize_name(coin['name'])\n            else:\n                n = coingecko_normalize_name(coin['id'])\n            symbols[n] = coin['id']\n    return symbols\n\n\ndef whale_alert_coins(key_id: str) -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get(f'https://api.whale-alert.io/v1/status?api_key={key_id}')\n        # Same symbols, but on different blockchains (for instance USDT), are naturally overwritten.\n        return {s.upper(): s for b in r.json()['blockchains'] for s in b['symbols'] if s}\n    except Exception as why:\n        raise_failure_explanation('WHALES_ALERT', why, {\"\": r})\n\n\n_exchange_function_map = {\n    BITFINEX: bitfinex_symbols,\n    BITFLYER: bitflyer_symbols,\n    COINBASE: coinbase_symbols,\n    GEMINI: gemini_symbols,\n    HITBTC: hitbtc_symbols,\n    POLONIEX: poloniex_symbols,\n    PROBIT: probit_symbols,\n    BITSTAMP: bitstamp_symbols,\n    KRAKEN: kraken_symbols,\n    KRAKEN + 'REST': kraken_rest_symbols,\n    BINANCE: binance_symbols,\n    BINANCE_US: binance_us_symbols,\n    BINANCE_FUTURES: binance_futures_symbols,\n    BINANCE_DELIVERY: binance_delivery_symbols,\n    BLOCKCHAIN: blockchain_symbols,\n    EXX: exx_symbols,\n    HUOBI: huobi_symbols,\n    HUOBI_DM: huobi_dm_symbols,\n    HUOBI_SWAP: huobi_swap_symbols,\n    OKCOIN: okcoin_symbols,\n    OKEX: okex_symbols,\n    BYBIT: bybit_symbols,\n    FTX: ftx_symbols,\n    FTX_US: ftx_us_symbols,\n    BITTREX: bittrex_symbols,\n    BITCOINCOM: bitcoincom_symbols,\n    BITMAX: bitmax_symbols,\n    UPBIT: upbit_symbols,\n    GATEIO: gateio_symbols,\n    BITMEX: bitmex_symbols,\n    DERIBIT: deribit_symbols,\n    KRAKEN_FUTURES: kraken_future_symbols,\n    COINGECKO: coingecko_symbols,\n    WHALE_ALERT: whale_alert_coins\n}\n",
        "source_code_len": 30534,
        "target_code": "associated with this software.\n'''\nfrom typing import Dict, Tuple\n\n\nclass _Symbols:\n    def __init__(self):\n        self.data = {}\n\n    def set(self, exchange: str, normalized: dict, exchange_info: dict):\n        self.data[exchange] = {}\n        self.data[exchange]['normalized'] = normalized\n        self.data[exchange]['info'] = exchange_info\n\n    def get(self, exchange: str) -> Tuple[Dict, Dict]:\n        return self.data[exchange]['normalized'], self.data[exchange]['info']\n\n    def populated(self, exchange: str) -> bool:\n        return exchange in self.data\n\n\nSymbols = _Symbols()\n",
        "target_code_len": 588,
        "diff_format": "@@ -5,845 +5,22 @@\n associated with this software.\n+'''\n+from typing import Dict, Tuple\n \n \n-Symbol generation code for exchanges\n-'''\n+class _Symbols:\n+    def __init__(self):\n+        self.data = {}\n \n-import logging\n-import string\n-import time\n-from collections import defaultdict\n-from typing import Dict, List, Optional, Tuple\n+    def set(self, exchange: str, normalized: dict, exchange_info: dict):\n+        self.data[exchange] = {}\n+        self.data[exchange]['normalized'] = normalized\n+        self.data[exchange]['info'] = exchange_info\n \n-import requests\n-from requests import Response\n+    def get(self, exchange: str) -> Tuple[Dict, Dict]:\n+        return self.data[exchange]['normalized'], self.data[exchange]['info']\n \n-from cryptofeed.defines import *\n+    def populated(self, exchange: str) -> bool:\n+        return exchange in self.data\n \n \n-LOG = logging.getLogger('feedhandler')\n-\n-SYMBOL_SEP = '-'\n-\n-_symbols_retrieval_cache: Dict[str, Dict[str, str]] = {}\n-_exchange_info = defaultdict(lambda: defaultdict(dict))\n-\n-\n-_kraken_futures_product_type = {\n-    'FI': 'Inverse Futures',\n-    'FV': 'Vanilla Futures',\n-    'PI': 'Perpetual Inverse Futures',\n-    'PV': 'Perpetual Vanilla Futures',\n-    'IN': 'Real Time Index',\n-    'RR': 'Reference Rate',\n-}\n-\n-\n-def raise_failure_explanation(feed_id: str, exception: BaseException, responses: Dict[str, Optional[Response]]):\n-    LOG.critical('%s: encountered %r while processing response from exchange API', feed_id, exception)\n-    if len(responses) > 1:\n-        LOG.critical('%s: content of one of the %s responses was unexpected', feed_id, len(responses))\n-    for url, r in responses.items():\n-        if url:\n-            LOG.critical('%s: requested URL: %s', feed_id, url)\n-        if r:\n-            LOG.critical('%s: unexpected response: %s', feed_id, r.text)\n-    raise ValueError(f'Cryptofeed stopped because of an unexpected response from {feed_id}') from exception\n-\n-\n-def set_symbol_separator(separator: str):\n-    global SYMBOL_SEP\n-    SYMBOL_SEP = separator\n-\n-\n-def get_symbol_separator() -> str:\n-    global SYMBOL_SEP\n-    return SYMBOL_SEP\n-\n-\n-def gen_symbols(exchange: str, key_id=None) -> Dict[str, str]:\n-    if exchange not in _symbols_retrieval_cache:\n-        LOG.info(\"%s: Getting list of symbols\", exchange)\n-        symbols = _exchange_function_map[exchange](key_id) if key_id else _exchange_function_map[exchange]()\n-        LOG.info(\"%s: %s symbols\", exchange, len(symbols))\n-\n-        # log all retrieved symbols using debug level\n-        for normalized, exch_sym in sorted(symbols.items()):\n-            LOG.debug('%s: id-from-exch -> normalized: %-35s-> %s', exchange, exch_sym, normalized)\n-\n-        _symbols_retrieval_cache[exchange] = symbols\n-    return _symbols_retrieval_cache[exchange]\n-\n-\n-def _binance_symbols(endpoint: str, exchange: str):\n-    r = None\n-    try:\n-        ret = {}\n-        r = requests.get(endpoint)\n-        for symbol in r.json()['symbols']:\n-            if symbol.get('status', 'TRADING') != \"TRADING\":\n-                continue\n-            if symbol.get('contractStatus', 'TRADING') != \"TRADING\":\n-                continue\n-            split = len(symbol['baseAsset'])\n-            normalized = symbol['symbol'][:split] + SYMBOL_SEP + symbol['symbol'][split:]\n-            ret[normalized] = symbol['symbol']\n-            _exchange_info[exchange]['tick_size'][normalized] = symbol['filters'][0]['tickSize']\n-            if \"contractType\" in symbol:\n-                _exchange_info[exchange]['contract_type'][normalized] = symbol['contractType']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation(exchange, why, {endpoint: r})\n-\n-\n-def binance_symbols() -> Dict[str, str]:\n-    return _binance_symbols('https://api.binance.com/api/v3/exchangeInfo', BINANCE)\n-\n-\n-def binance_us_symbols() -> Dict[str, str]:\n-    return _binance_symbols('https://api.binance.us/api/v3/exchangeInfo', BINANCE_US)\n-\n-\n-def binance_futures_symbols() -> Dict[str, str]:\n-    base = _binance_symbols('https://fapi.binance.com/fapi/v1/exchangeInfo', BINANCE_FUTURES)\n-    add = {}\n-    for symbol, orig in base.items():\n-        if \"_\" in orig:\n-            continue\n-        add[f\"{symbol}-PINDEX\"] = f\"p{orig}\"\n-    base.update(add)\n-    return base\n-\n-\n-def binance_delivery_symbols() -> Dict[str, str]:\n-    return _binance_symbols('https://dapi.binance.com/dapi/v1/exchangeInfo', BINANCE_DELIVERY)\n-\n-\n-def bitfinex_symbols() -> Dict[str, str]:\n-    # doc: https://docs.bitfinex.com/docs/ws-general#supported-pairs\n-    r1 = r2 = None\n-    try:\n-        r1 = requests.get('https://api.bitfinex.com/v2/tickers?symbols=ALL')\n-        r2 = requests.get('https://api-pub.bitfinex.com/v2/conf/pub:map:currency:sym')\n-        tickers: List[List[str]] = r1.json()\n-        norm: List[Tuple[str, str]] = r2.json()[0]\n-        norm: Dict[str, str] = dict(norm)\n-        for k, v in dict(norm).items():\n-            if k[-2:] == 'F0' or '-' in v:  # Do not convert BTCF0 -> BTC or PBTCETH -> PBTC-ETH\n-                del norm[k]\n-        norm['BCHN'] = 'BCH'  # Bitfinex uses BCHN, other exchanges use BCH\n-\n-        ret = {}\n-        for symbol in [t[0] for t in tickers]:\n-            if symbol[0] == 'f':\n-                normalized = norm.get(symbol[1:], symbol[1:])\n-            else:\n-                if len(symbol) == 7:\n-                    base, quote = symbol[1:4], symbol[4:]\n-                else:\n-                    base, quote = symbol[1:].split(':')\n-                    assert ':' in symbol\n-                normalized = norm.get(base, base) + SYMBOL_SEP + norm.get(quote, quote)\n-            ret[normalized.upper()] = symbol\n-        return ret\n-    except ValueError as why:\n-        raise_failure_explanation('BITFINEX', why, {\"tickers?symbols=ALL\": r1, \"pub:map:currency:sym\": r2})\n-\n-\n-def bitflyer_symbols() -> Dict[str, str]:\n-    endpoint = r = None\n-    try:\n-        ret = {}\n-        endpoints = ['https://api.bitflyer.com/v1/getmarkets/eu', 'https://api.bitflyer.com/v1/getmarkets/usa', 'https://api.bitflyer.com/v1/getmarkets']\n-        for endpoint in endpoints:\n-            r = requests.get(endpoint)\n-            for entry in r.json():\n-                normalized = entry['product_code'].replace(\"_\", SYMBOL_SEP)\n-                ret[normalized] = entry['product_code']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('BITFLYER', why, {endpoint: r})\n-\n-\n-def bybit_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.bybit.com/v2/public/symbols')\n-        ret = {}\n-        for symbol in r.json()['result']:\n-            quote = symbol['quote_currency']\n-            if not symbol['name'].endswith(quote):\n-                base, contract = symbol['name'].split(quote)\n-                normalized = f\"{base}{SYMBOL_SEP}{quote}-{contract}\"\n-            else:\n-                normalized = f\"{symbol['base_currency']}{SYMBOL_SEP}{quote}\"\n-            ret[normalized] = symbol['name']\n-            _exchange_info[BYBIT]['tick_size'][normalized] = symbol['price_filter']['tick_size']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('BYBIT', why, {\"\": r})\n-\n-\n-def _ftx_helper(endpoint: str, exchange: str):\n-    r = None\n-    try:\n-        r = requests.get(endpoint)\n-        ret = {}\n-        for data in r.json()['result']:\n-            normalized = data['name'].replace(\"/\", SYMBOL_SEP)\n-            symbol = data['name']\n-            ret[normalized] = symbol\n-            _exchange_info[exchange]['tick_size'][normalized] = data['priceIncrement']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation(exchange, why, {endpoint: r})\n-\n-\n-def ftx_symbols() -> Dict[str, str]:\n-    return _ftx_helper('https://ftx.com/api/markets', FTX)\n-\n-\n-def ftx_us_symbols() -> Dict[str, str]:\n-    return _ftx_helper('https://ftx.us/api/markets', FTX_US)\n-\n-\n-def coinbase_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.pro.coinbase.com/products')\n-        ret = {}\n-        for data in r.json():\n-            normalized = data['id'].replace(\"-\", SYMBOL_SEP)\n-            ret[normalized] = data['id']\n-            _exchange_info[COINBASE]['tick_size'][normalized] = data['quote_increment']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('COINBASE', why, {\"\": r})\n-\n-\n-def gemini_symbols(*args) -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.gemini.com/v1/symbols')\n-        ret = {}\n-        for symbol in r.json():\n-            std = f\"{symbol[:-3]}{SYMBOL_SEP}{symbol[-3:]}\"\n-            std = std.upper()\n-            ret[std] = symbol.upper()\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('GEMINI', why, {\"\": r})\n-\n-\n-def hitbtc_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        ret = {}\n-        r = requests.get('https://api.hitbtc.com/api/2/public/symbol')\n-        for symbol in r.json():\n-            split = len(symbol['baseCurrency'])\n-            normalized = symbol['id'][:split] + SYMBOL_SEP + symbol['id'][split:]\n-            ret[normalized] = symbol['id']\n-            _exchange_info[HITBTC]['tick_size'][normalized] = symbol['tickSize']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('HITBTC', why, {\"\": r})\n-\n-\n-def poloniex_id_symbol_mapping():\n-    r = None\n-    try:\n-        r = requests.get('https://poloniex.com/public?command=returnTicker')\n-        symbols = r.json()\n-        ret = {}\n-        for symbol in symbols:\n-            ret[symbols[symbol]['id']] = symbol\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('POLONIEX', why, {\"\": r})\n-\n-\n-def poloniex_symbols() -> Dict[str, str]:\n-    ret = {}\n-    for _, value in poloniex_id_symbol_mapping().items():\n-        std = value.replace(\"STR\", \"XLM\")\n-        quote, base = std.split(\"_\")\n-        ret[quote + SYMBOL_SEP + base] = value\n-    return ret\n-\n-\n-def bitstamp_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://www.bitstamp.net/api/v2/trading-pairs-info/')\n-        ret = {}\n-        for data in r.json():\n-            normalized = data['name'].replace(\"/\", SYMBOL_SEP)\n-            symbol = data['url_symbol']\n-            ret[normalized] = symbol\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('BITSTAMP', why, {\"\": r})\n-\n-\n-def kraken_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.kraken.com/0/public/AssetPairs')\n-        data = r.json()\n-        ret = {}\n-        for symbol in data['result']:\n-            if 'wsname' not in data['result'][symbol] or '.d' in symbol:\n-                # https://blog.kraken.com/post/259/introducing-the-kraken-dark-pool/\n-                # .d is for dark pool symbols\n-                continue\n-\n-            base, quote = data['result'][symbol]['wsname'].split(\"/\")\n-\n-            normalized = f\"{base}{SYMBOL_SEP}{quote}\"\n-            exch = data['result'][symbol]['wsname']\n-            normalized = normalized.replace('XBT', 'BTC')\n-            normalized = normalized.replace('XDG', 'DOG')\n-            ret[normalized] = exch\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('KRAKEN', why, {\"\": r})\n-\n-\n-def kraken_rest_symbols() -> Dict[str, str]:\n-    return {normalized: exchange.replace(\"/\", \"\") for normalized, exchange in kraken_symbols().items()}\n-\n-\n-def exx_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.exx.com/data/v1/tickers')\n-        exchange = [key.upper() for key in r.json().keys()]\n-        symbols = [key.replace(\"_\", SYMBOL_SEP) for key in exchange]\n-        return dict(zip(symbols, exchange))\n-    except Exception as why:\n-        raise_failure_explanation('EXX', why, {\"\": r})\n-\n-\n-def huobi_common_symbols(url: str):\n-    r = None\n-    try:\n-        r = requests.get(url)\n-        ret = {}\n-        for e in r.json()['data']:\n-            if e['state'] == 'offline':\n-                continue\n-            normalized = f\"{e['base-currency'].upper()}{SYMBOL_SEP}{e['quote-currency'].upper()}\"\n-            symbol = f\"{e['base-currency']}{e['quote-currency']}\"\n-            ret[normalized] = symbol\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('HUOBI', why, {url: r})\n-\n-\n-def huobi_symbols() -> Dict[str, str]:\n-    return huobi_common_symbols('https://api.huobi.pro/v1/common/symbols')\n-\n-\n-def huobi_us_symbols() -> Dict[str, str]:\n-    return huobi_common_symbols('https://api.huobi.com/v1/common/symbols')\n-\n-\n-def huobi_dm_symbols() -> Dict[str, str]:\n-    \"\"\"\n-    Mapping is, for instance: {\"BTC_CW\":\"BTC190816\"}\n-    See comments in exchange/huobi_dm.py\n-    \"\"\"\n-    mapping = {\n-        \"this_week\": \"CW\",\n-        \"next_week\": \"NW\",\n-        \"quarter\": \"CQ\",\n-        \"next_quarter\": \"NQ\"\n-    }\n-    r = None\n-    try:\n-        r = requests.get('https://www.hbdm.com/api/v1/contract_contract_info')\n-        symbols = {}\n-        for e in r.json()['data']:\n-            symbols[f\"{e['symbol']}_{mapping[e['contract_type']]}\"] = e['contract_code']\n-            _exchange_info[HUOBI_DM]['tick_size'][e['contract_code']] = e['price_tick']\n-            _exchange_info[HUOBI_DM]['short_code_mappings'][f\"{e['symbol']}_{mapping[e['contract_type']]}\"] = e['contract_code']\n-        return symbols\n-    except Exception as why:\n-        raise_failure_explanation('HUOBI_DM', why, {\"\": r})\n-\n-\n-def huobi_swap_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.hbdm.com/swap-api/v1/swap_contract_info')\n-        symbols = {}\n-        for e in r.json()['data']:\n-            symbols[e['contract_code']] = e['contract_code']\n-            _exchange_info[HUOBI_SWAP]['tick_size'][e['contract_code']] = e['price_tick']\n-        return symbols\n-    except Exception as why:\n-        raise_failure_explanation('HUOBI_SWAP', why, {\"\": r})\n-\n-\n-def okcoin_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://www.okcoin.com/api/spot/v3/instruments')\n-        ret = {}\n-        for e in r.json():\n-            ret[e['instrument_id']] = e['instrument_id']\n-            _exchange_info[OKCOIN]['tick_size'][e['instrument_id']] = e['tick_size']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('OKCOIN', why, {\"\": r})\n-\n-\n-def okex_symbols(*args) -> Dict[str, str]:\n-    urls = ['https://www.okex.com/api/spot/v3/instruments',\n-            'https://www.okex.com/api/swap/v3/instruments',\n-            'https://www.okex.com/api/futures/v3/instruments']\n-    urls = urls + okex_compute_option_urls_from_underlyings()\n-\n-    symbols: Dict[str, str] = {}\n-    for u in urls:\n-        time.sleep(0.2)\n-        symbols.update(okex_symbols_from_one_url(u))\n-\n-    for symbol in symbols:\n-        instrument_type = 'futures'\n-        dash_count = symbol.count(get_symbol_separator())\n-        if dash_count == 1:  # BTC-USDT\n-            instrument_type = 'spot'\n-        if dash_count == 4:  # BTC-USD-201225-35000-P\n-            instrument_type = 'option'\n-        if symbol[-4:] == \"SWAP\":  # BTC-USDT-SWAP\n-            instrument_type = 'swap'\n-\n-        _exchange_info[OKEX]['instrument_type'][symbol] = instrument_type\n-\n-    return symbols\n-\n-\n-def okex_compute_option_urls_from_underlyings() -> List[str]:\n-    url = 'https://www.okex.com/api/option/v3/underlying'\n-    r = None\n-    try:\n-        r = requests.get(url)\n-        return [f'https://www.okex.com/api/option/v3/instruments/{underlying}' for underlying in r.json()]\n-    except Exception as why:\n-        raise_failure_explanation('OKEX', why, {url: r})\n-\n-\n-def okex_symbols_from_one_url(url: str) -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get(url)\n-        ret = {}\n-        for e in r.json():\n-            ret[e['instrument_id']] = e['instrument_id']\n-            _exchange_info[OKEX]['tick_size'][e['instrument_id']] = e['tick_size']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('OKEX', why, {url: r})\n-\n-\n-def bittrex_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.bittrex.com/api/v1.1/public/getmarkets')\n-        r = r.json()['result']\n-        return {f\"{e['MarketCurrency']}{SYMBOL_SEP}{e['BaseCurrency']}\": e['MarketName'] for e in r if e['IsActive']}\n-    except Exception as why:\n-        raise_failure_explanation('BITTREX', why, {\"\": r})\n-\n-\n-def bitcoincom_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.exchange.bitcoin.com/api/2/public/symbol')\n-        return {f\"{data['baseCurrency']}{SYMBOL_SEP}{data['quoteCurrency'].replace('USD', 'USDT')}\": data['id'] for data in r.json()}\n-    except Exception as why:\n-        raise_failure_explanation('BITCOINCOM', why, {\"\": r})\n-\n-\n-def bitmax_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://bitmax.io/api/pro/v1/products')\n-        ret = {}\n-        for entry in r.json()['data']:\n-            # Only \"Normal\" status symbols are tradeable\n-            if entry['status'] == 'Normal':\n-                normalized = f\"{entry['baseAsset']}{SYMBOL_SEP}{entry['quoteAsset']}\"\n-                ret[normalized] = entry['symbol']\n-                _exchange_info[BITMAX]['tick_size'][normalized] = entry['tickSize']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('BITMAX', why, {\"\": r})\n-\n-\n-def upbit_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.upbit.com/v1/market/all')\n-        return {f\"{data['market'].split('-')[1]}{SYMBOL_SEP}{data['market'].split('-')[0]}\": data['market'] for data in r.json()}\n-    except Exception as why:\n-        raise_failure_explanation('UPBIT', why, {\"\": r})\n-\n-\n-def blockchain_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get(\"https://api.blockchain.com/mercury-gateway/v1/instruments\")\n-        return {data[\"symbol\"].replace(\"-\", SYMBOL_SEP): data[\"symbol\"] for data in r.json()}\n-    except Exception as why:\n-        raise_failure_explanation('BLOCKCHAIN', why, {\"\": r})\n-\n-\n-def gateio_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get(\"https://api.gateio.ws/api/v4/spot/currency_pairs\")\n-        return {data[\"id\"].replace(\"_\", SYMBOL_SEP): data['id'] for data in r.json()}\n-    except Exception as why:\n-        raise_failure_explanation('GATEIO', why, {\"\": r})\n-\n-\n-def bitmex_symbols() -> Dict[str, str]:\n-    r = None\n-    ret = {}\n-    try:\n-        r = requests.get(\"https://www.bitmex.com/api/v1/instrument/active\")\n-        for entry in r.json():\n-            components = []\n-            components.append(entry['rootSymbol'])\n-            components.append(entry['quoteCurrency'])\n-\n-            if entry['expiry']:\n-                components.append(entry['symbol'][-3:])\n-\n-            normalized = SYMBOL_SEP.join(components)\n-            normalized = normalized.replace(\"XBT\", \"BTC\")\n-            ret[normalized] = entry['symbol']\n-            _exchange_info[BITMEX]['tick_size'][normalized] = entry['tickSize']\n-\n-            if entry['expiry']:\n-                _exchange_info[BITMEX]['expiry'][normalized] = entry['expiry']\n-\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('BITMEX', why, {\"\": r})\n-\n-\n-def deribit_symbols() -> Dict[str, str]:\n-    url = r = None\n-    ret = {}\n-    try:\n-        # TODO: get currencies from https://www.deribit.com/api/v2/public/get_currencies\n-        currencies = ['BTC', 'ETH']\n-        for c in currencies:\n-            url = f\"https://www.deribit.com/api/v2/public/get_instruments?currency={c}&expired=false\"\n-            r = requests.get(url)\n-            for entry in r.json()['result']:\n-                split = entry['instrument_name'].split(\"-\")\n-                normalized = split[0] + SYMBOL_SEP + entry['quote_currency'] + \"-\" + '-'.join(split[1:])\n-                ret[normalized] = entry['instrument_name']\n-                _exchange_info[DERIBIT]['tick_size'][normalized] = entry['tick_size']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('DERIBIT', why, {url: r})\n-\n-\n-def kraken_future_symbols() -> Dict[str, str]:\n-    r = None\n-    ret = {}\n-    try:\n-        r = requests.get('https://futures.kraken.com/derivatives/api/v3/instruments')\n-        data = r.json()['instruments']\n-        for entry in data:\n-            if not entry['tradeable']:\n-                continue\n-            normalized = entry['symbol'].upper().replace(\"_\", \"-\")\n-            symbol = normalized[3:6] + SYMBOL_SEP + normalized[6:9]\n-            normalized = normalized.replace(normalized[3:9], symbol)\n-            normalized = normalized.replace('XBT', 'BTC')\n-\n-            _exchange_info[KRAKEN_FUTURES]['tick_size'][normalized] = entry['tickSize']\n-            _exchange_info[KRAKEN_FUTURES]['contract_size'][normalized] = entry['contractSize']\n-            _exchange_info[KRAKEN_FUTURES]['underlying'][normalized] = entry['underlying']\n-            _exchange_info[KRAKEN_FUTURES]['product_type'][normalized] = _kraken_futures_product_type[normalized[:2]]\n-            ret[normalized] = entry['symbol']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('KRAKEN_FUTURES', why, {\"\": r})\n-\n-\n-def probit_symbols() -> Dict[str, str]:\n-    # doc: https://docs-en.probit.com/reference-link/market\n-    r = None\n-    try:\n-        r = requests.get('https://api.probit.com/api/exchange/v1/market')\n-        return {entry['id']: entry['id'] for entry in r.json()['data']}\n-    except Exception as why:\n-        raise_failure_explanation('PROBIT', why, {\"\": r})\n-\n-\n-def coingecko_normalize_symbol(symbol: str) -> str:\n-    # keep digits, letters and dots, replace others by space\n-    symbol = ''.join(c if c.isalnum() or c in ('.', '+') else ' ' for c in symbol)\n-    return coingecko_normalize(symbol.upper())\n-\n-\n-def coingecko_normalize_name(name: str) -> str:\n-    # keep digits and letters, replace others by space (except when only composed by upper case letters, digits and dots)\n-    if not all(c.isupper() or c.isdigit() or c == '.' for c in name):\n-        name = ''.join(c if c.isalnum() else ' ' for c in name)\n-    return coingecko_normalize(name)\n-\n-\n-def coingecko_normalize(sym: str) -> str:\n-    sym = sym.strip()\n-    # do not concatenate numbers => separate them with a dot\n-    sym = list(sym)\n-    if len(sym) > 4:\n-        for i in range(2, len(sym) - 1):\n-            if sym[i] == ' ' and sym[i - 1].isdigit() and sym[i + 1].isdigit():\n-                sym[i] = '.'\n-    sym = ''.join(sym)\n-    # concatenate space-separated words => use CamelCase to distinguish the words\n-    if ' ' in sym:\n-        if sum(c.islower() for c in sym):  # if there is at least one lower case letter\n-            sym = ' '.join(word[0].upper() + word[1:] for word in sym.split())  # Just capitalize initial letter of each word\n-        else:  # CoinGecko may provide full upper-case as for \"THE STONE COIN\"\n-            sym = string.capwords(sym)  # capwords converts \"THE STONE COIN\" to \"The Stone Coin\"\n-        sym = sym.replace(' ', '')  # concatenate words\n-    return sym\n-\n-\n-def is_name_short(coin: dict) -> bool:\n-    \"\"\"return True if the coin name is enough short compared to the coin symbol.\"\"\"\n-    return len(coin['name']) <= max(5, len(coin['symbol']) + 1)\n-\n-\n-def has_many_caps(name: str) -> bool:\n-    \"\"\"return True if the symbol contains enough upper case letters, False if empty.\"\"\"\n-    return str and sum(c.islower() for c in name) < (len(name) / 2)\n-\n-\n-def coingecko_normalize_all(coin: dict):\n-    SYMBOL_TO_NORMALIZED = {'miota': 'IOTA'}\n-    normalized = SYMBOL_TO_NORMALIZED.get(coin['symbol'])\n-    if normalized:\n-        coin['ns'] = coin['nn'] = normalized\n-        return normalized\n-\n-    # ns = normalized symbol, nn = normalized name\n-    coin['ns'] = coingecko_normalize_symbol(coin['symbol'])\n-\n-    ID_SUFFIX = '-bitcoin-token'\n-    if coin['id'][-len(ID_SUFFIX):] == ID_SUFFIX:\n-        coin['nn'] = 'BTC' + coin['ns']\n-        return coin['nn']\n-\n-    name = coin['name']\n-\n-    prefixes = ('The ', 'the ')\n-    for p in prefixes:\n-        if name[:len(p)] == p:\n-            coin['reduced-name'] = True\n-            name = name[len(p):]\n-            break\n-\n-    suffixes = ('coin', 'coins', 'money', 'finance', 'protocol', 'reward', 'rewards', 'token')\n-    for s in suffixes:\n-        if len(name) > len(s) and name[-len(s):].lower() == s:\n-            # but keep suffix when lower-case concatenated\n-            if name[-len(s)].islower() and name[-len(s) - 1] != ' ':\n-                continue\n-            # also keep suffix to avoid confusing nam: \"Bitcoin Token\" -> \"Bitcoin\"\n-            if name[:-len(s)].strip().lower() == 'bitcoin':\n-                continue\n-            coin['reduced-name'] = True\n-            name = name[:-len(s)]\n-            break\n-\n-    coin['nn'] = coingecko_normalize_name(name)\n-\n-    if len(coin['nn']) < len(coin['ns']):\n-        if 'reduced-name' in coin:\n-            coin['reduced-name'] = False\n-            name = coin['name']\n-            coin['nn'] = coingecko_normalize_name(name)\n-        elif not has_many_caps(name):\n-            return coin['ns']\n-\n-    if not coin['ns']:  # coin['symbol'] may be an emoji that is striped when normalized\n-        return coin['nn']\n-\n-    if coin.get('reduced-name') and coin['ns'].upper() != coin['nn'].upper():\n-        return coin['ns']\n-\n-    i = coin['nn'].find('.')  # if there is a dot in normalized name => prefer the normalized symbol\n-    if i >= 0:\n-        if i > 1 and coin['nn'][i - 1].isdigit() and coin['nn'][i + 1].isdigit():\n-            pass  # except when the dot separates digits\n-        else:\n-            return coin['ns']\n-\n-    if is_name_short(coin) and has_many_caps(name):\n-        return coin['nn']\n-\n-    if 1.5 * len(coin['ns']) > len(coin['nn']) and any(c.islower() for c in coin['ns']):\n-        return coin['nn']\n-\n-    return coin['ns']\n-\n-\n-def coingecko_symbols() -> Dict[str, str]:\n-    r = None\n-    intermediate = defaultdict(list)\n-    try:\n-        r = requests.get('https://api.coingecko.com/api/v3/coins/list')\n-        all_coins = r.json()\n-        # First pass: generate & compare normalized symbol/name, and then select the most pertinent\n-        for coin in all_coins:\n-            normalized = coingecko_normalize_all(coin)\n-            intermediate[normalized].append(coin)\n-            # Above line keeps together the coins having the same normalized symbol.\n-            # To reduce collision, the coin['name'] is sometimes used in lieu of the coin['symbol'].\n-            # The coin['name'] is not capitalized because lower case letters may be meaningful: cETH, yUSD, DATx, zLOT\n-    except Exception as why:\n-        raise_failure_explanation('COINGECKO', why, {\"\": r})\n-\n-    final = coingecko_second_pass(intermediate)\n-    return coingecko_third_pass(final)\n-\n-\n-def coingecko_second_pass(intermediate: Dict[str, List[dict]]) -> Dict[str, List[dict]]:\n-    # Second pass: fixes most of the symbol collisions\n-    final = defaultdict(list)\n-    for normalized, coins in intermediate.items():\n-        if len(coins) == 1:\n-            final[normalized].append(coins[0])\n-            continue\n-        set_normalized = False\n-        for i in range(len(coins)):\n-            if normalized == coins[i]['nn']:\n-                coin = coins.pop(i)\n-                final[normalized].append(coin)\n-                set_normalized = True\n-                break\n-        rest: List[dict] = []\n-        for coin in coins:\n-            if '%' in coin['name']:\n-                if len(coins) == 1:\n-                    n = coin['ns']\n-                else:\n-                    n = coingecko_normalize_name(coin['id'])\n-                final[n].append(coin)\n-            else:\n-                rest.append(coin)\n-        if not rest:\n-            continue\n-        if not set_normalized:\n-            rest.sort(key=lambda coin: len(coin['nn']), reverse=True)  # sort by the length of the normalized name\n-            coin = rest.pop(0)\n-            final[normalized].append(coin)\n-        for coin in rest:\n-            if coin['nn'] not in intermediate:\n-                n = coin['nn']\n-            elif coin.get('reduced-name'):\n-                n = coingecko_normalize_name(coin['name'])\n-            else:\n-                n = coingecko_normalize_name(coin['id'])\n-            final[n].append(coin)\n-    return final\n-\n-\n-def coingecko_third_pass(final: Dict[str, List[dict]]) -> Dict[str, str]:\n-    # Third pass: fixes some remaining collisions and fills the result\n-    symbols = {}\n-    for normalized, coins in final.items():\n-        if len(coins) == 1:\n-            symbols[normalized] = coins[0]['id']\n-            continue\n-        set_normalized = False\n-        for i in range(len(coins)):\n-            if normalized == coins[i]['nn']:\n-                coin = coins.pop(i)\n-                symbols[normalized] = coin['id']\n-                set_normalized = True\n-                break\n-        rest: List[dict] = []\n-        for coin in coins:\n-            if '%' in coin['name']:\n-                if len(coins) == 1:\n-                    n = coin['ns']\n-                else:\n-                    n = coingecko_normalize_name(coin['id'])\n-                symbols[n] = coin['id']\n-            else:\n-                rest.append(coin)\n-        if not rest:\n-            continue\n-        if not set_normalized:\n-            rest.sort(key=lambda coin: len(coin['nn']), reverse=True)  # sort by the length of the normalized name\n-            coin = rest.pop(0)\n-            symbols[normalized] = coin['id']\n-        for coin in rest:\n-            if coin['nn'] not in final:\n-                n = coin['nn']\n-            elif coin.get('reduced-name'):\n-                n = coingecko_normalize_name(coin['name'])\n-            else:\n-                n = coingecko_normalize_name(coin['id'])\n-            symbols[n] = coin['id']\n-    return symbols\n-\n-\n-def whale_alert_coins(key_id: str) -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get(f'https://api.whale-alert.io/v1/status?api_key={key_id}')\n-        # Same symbols, but on different blockchains (for instance USDT), are naturally overwritten.\n-        return {s.upper(): s for b in r.json()['blockchains'] for s in b['symbols'] if s}\n-    except Exception as why:\n-        raise_failure_explanation('WHALES_ALERT', why, {\"\": r})\n-\n-\n-_exchange_function_map = {\n-    BITFINEX: bitfinex_symbols,\n-    BITFLYER: bitflyer_symbols,\n-    COINBASE: coinbase_symbols,\n-    GEMINI: gemini_symbols,\n-    HITBTC: hitbtc_symbols,\n-    POLONIEX: poloniex_symbols,\n-    PROBIT: probit_symbols,\n-    BITSTAMP: bitstamp_symbols,\n-    KRAKEN: kraken_symbols,\n-    KRAKEN + 'REST': kraken_rest_symbols,\n-    BINANCE: binance_symbols,\n-    BINANCE_US: binance_us_symbols,\n-    BINANCE_FUTURES: binance_futures_symbols,\n-    BINANCE_DELIVERY: binance_delivery_symbols,\n-    BLOCKCHAIN: blockchain_symbols,\n-    EXX: exx_symbols,\n-    HUOBI: huobi_symbols,\n-    HUOBI_DM: huobi_dm_symbols,\n-    HUOBI_SWAP: huobi_swap_symbols,\n-    OKCOIN: okcoin_symbols,\n-    OKEX: okex_symbols,\n-    BYBIT: bybit_symbols,\n-    FTX: ftx_symbols,\n-    FTX_US: ftx_us_symbols,\n-    BITTREX: bittrex_symbols,\n-    BITCOINCOM: bitcoincom_symbols,\n-    BITMAX: bitmax_symbols,\n-    UPBIT: upbit_symbols,\n-    GATEIO: gateio_symbols,\n-    BITMEX: bitmex_symbols,\n-    DERIBIT: deribit_symbols,\n-    KRAKEN_FUTURES: kraken_future_symbols,\n-    COINGECKO: coingecko_symbols,\n-    WHALE_ALERT: whale_alert_coins\n-}\n+Symbols = _Symbols()\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\n\nimport logging\nimport string\nimport time\nfrom collections import defaultdict\nfrom typing import Dict, List, Optional, Tuple\n\nimport requests\nfrom requests import Response\n\nfrom cryptofeed.defines import *\n\n\nLOG = logging.getLogger('feedhandler')\n\nSYMBOL_SEP = '-'\n\n_symbols_retrieval_cache: Dict[str, Dict[str, str]] = {}\n_exchange_info = defaultdict(lambda: defaultdict(dict))\n\n\n_kraken_futures_product_type = {\n    'FI': 'Inverse Futures',\n    'FV': 'Vanilla Futures',\n    'PI': 'Perpetual Inverse Futures',\n    'PV': 'Perpetual Vanilla Futures',\n    'IN': 'Real Time Index',\n    'RR': 'Reference Rate',\n}\n\n\ndef raise_failure_explanation(feed_id: str, exception: BaseException, responses: Dict[str, Optional[Response]]):\n    <IND>LOG.critical('%s: encountered %r while processing response from exchange API', feed_id, exception)\n    if len(responses) > 1:\n        <IND>LOG.critical('%s: content of one of the %s responses was unexpected', feed_id, len(responses))\n    <DED>for url, r in responses.items():\n        <IND>if url:\n            <IND>LOG.critical('%s: requested URL: %s', feed_id, url)\n        <DED>if r:\n            <IND>LOG.critical('%s: unexpected response: %s', feed_id, r.text)\n    <DED><DED>raise ValueError(f'Cryptofeed stopped because of an unexpected response from {feed_id}') from exception\n\n\n<DED>def set_symbol_separator(separator: str):\n    <IND>global SYMBOL_SEP\n    SYMBOL_SEP = separator\n\n\n<DED>def get_symbol_separator() -> str:\n    <IND>global SYMBOL_SEP\n    return SYMBOL_SEP\n\n\n<DED>def gen_symbols(exchange: str, key_id=None) -> Dict[str, str]:\n    <IND>if exchange not in _symbols_retrieval_cache:\n        <IND>LOG.info(\"%s: Getting list of symbols\", exchange)\n        symbols = _exchange_function_map[exchange](key_id) if key_id else _exchange_function_map[exchange]()\n        LOG.info(\"%s: %s symbols\", exchange, len(symbols))\n\n        # log all retrieved symbols using debug level\n        for normalized, exch_sym in sorted(symbols.items()):\n            <IND>LOG.debug('%s: id-from-exch -> normalized: %-35s-> %s', exchange, exch_sym, normalized)\n\n        <DED>_symbols_retrieval_cache[exchange] = symbols\n    <DED>return _symbols_retrieval_cache[exchange]\n\n\n<DED>def _binance_symbols(endpoint: str, exchange: str):\n    <IND>r = None\n    try:\n        <IND>ret = {}\n        r = requests.get(endpoint)\n        for symbol in r.json()['symbols']:\n            <IND>if symbol.get('status', 'TRADING') != \"TRADING\":\n                <IND>continue\n            <DED>if symbol.get('contractStatus', 'TRADING') != \"TRADING\":\n                <IND>continue\n            <DED>split = len(symbol['baseAsset'])\n            normalized = symbol['symbol'][:split] + SYMBOL_SEP + symbol['symbol'][split:]\n            ret[normalized] = symbol['symbol']\n            _exchange_info[exchange]['tick_size'][normalized] = symbol['filters'][0]['tickSize']\n            if \"contractType\" in symbol:\n                <IND>_exchange_info[exchange]['contract_type'][normalized] = symbol['contractType']\n        <DED><DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation(exchange, why, {endpoint: r})\n\n\n<DED><DED>def binance_symbols() -> Dict[str, str]:\n    <IND>return _binance_symbols('https://api.binance.com/api/v3/exchangeInfo', BINANCE)\n\n\n<DED>def binance_us_symbols() -> Dict[str, str]:\n    <IND>return _binance_symbols('https://api.binance.us/api/v3/exchangeInfo', BINANCE_US)\n\n\n<DED>def binance_futures_symbols() -> Dict[str, str]:\n    <IND>base = _binance_symbols('https://fapi.binance.com/fapi/v1/exchangeInfo', BINANCE_FUTURES)\n    add = {}\n    for symbol, orig in base.items():\n        <IND>if \"_\" in orig:\n            <IND>continue\n        <DED>add[f\"{symbol}-PINDEX\"] = f\"p{orig}\"\n    <DED>base.update(add)\n    return base\n\n\n<DED>def binance_delivery_symbols() -> Dict[str, str]:\n    <IND>return _binance_symbols('https://dapi.binance.com/dapi/v1/exchangeInfo', BINANCE_DELIVERY)\n\n\n<DED>def bitfinex_symbols() -> Dict[str, str]:\n    # doc: https://docs.bitfinex.com/docs/ws-general#supported-pairs\n    <IND>r1 = r2 = None\n    try:\n        <IND>r1 = requests.get('https://api.bitfinex.com/v2/tickers?symbols=ALL')\n        r2 = requests.get('https://api-pub.bitfinex.com/v2/conf/pub:map:currency:sym')\n        tickers: List[List[str]] = r1.json()\n        norm: List[Tuple[str, str]] = r2.json()[0]\n        norm: Dict[str, str] = dict(norm)\n        for k, v in dict(norm).items():\n            <IND>if k[-2:] == 'F0' or '-' in v:  # Do not convert BTCF0 -> BTC or PBTCETH -> PBTC-ETH\n                <IND>del norm[k]\n        <DED><DED>norm['BCHN'] = 'BCH'  # Bitfinex uses BCHN, other exchanges use BCH\n\n        ret = {}\n        for symbol in [t[0] for t in tickers]:\n            <IND>if symbol[0] == 'f':\n                <IND>normalized = norm.get(symbol[1:], symbol[1:])\n            <DED>else:\n                <IND>if len(symbol) == 7:\n                    <IND>base, quote = symbol[1:4], symbol[4:]\n                <DED>else:\n                    <IND>base, quote = symbol[1:].split(':')\n                    assert ':' in symbol\n                <DED>normalized = norm.get(base, base) + SYMBOL_SEP + norm.get(quote, quote)\n            <DED>ret[normalized.upper()] = symbol\n        <DED>return ret\n    <DED>except ValueError as why:\n        <IND>raise_failure_explanation('BITFINEX', why, {\"tickers?symbols=ALL\": r1, \"pub:map:currency:sym\": r2})\n\n\n<DED><DED>def bitflyer_symbols() -> Dict[str, str]:\n    <IND>endpoint = r = None\n    try:\n        <IND>ret = {}\n        endpoints = ['https://api.bitflyer.com/v1/getmarkets/eu', 'https://api.bitflyer.com/v1/getmarkets/usa', 'https://api.bitflyer.com/v1/getmarkets']\n        for endpoint in endpoints:\n            <IND>r = requests.get(endpoint)\n            for entry in r.json():\n                <IND>normalized = entry['product_code'].replace(\"_\", SYMBOL_SEP)\n                ret[normalized] = entry['product_code']\n        <DED><DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BITFLYER', why, {endpoint: r})\n\n\n<DED><DED>def bybit_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.bybit.com/v2/public/symbols')\n        ret = {}\n        for symbol in r.json()['result']:\n            <IND>quote = symbol['quote_currency']\n            if not symbol['name'].endswith(quote):\n                <IND>base, contract = symbol['name'].split(quote)\n                normalized = f\"{base}{SYMBOL_SEP}{quote}-{contract}\"\n            <DED>else:\n                <IND>normalized = f\"{symbol['base_currency']}{SYMBOL_SEP}{quote}\"\n            <DED>ret[normalized] = symbol['name']\n            _exchange_info[BYBIT]['tick_size'][normalized] = symbol['price_filter']['tick_size']\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BYBIT', why, {\"\": r})\n\n\n<DED><DED>def _ftx_helper(endpoint: str, exchange: str):\n    <IND>r = None\n    try:\n        <IND>r = requests.get(endpoint)\n        ret = {}\n        for data in r.json()['result']:\n            <IND>normalized = data['name'].replace(\"/\", SYMBOL_SEP)\n            symbol = data['name']\n            ret[normalized] = symbol\n            _exchange_info[exchange]['tick_size'][normalized] = data['priceIncrement']\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation(exchange, why, {endpoint: r})\n\n\n<DED><DED>def ftx_symbols() -> Dict[str, str]:\n    <IND>return _ftx_helper('https://ftx.com/api/markets', FTX)\n\n\n<DED>def ftx_us_symbols() -> Dict[str, str]:\n    <IND>return _ftx_helper('https://ftx.us/api/markets', FTX_US)\n\n\n<DED>def coinbase_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.pro.coinbase.com/products')\n        ret = {}\n        for data in r.json():\n            <IND>normalized = data['id'].replace(\"-\", SYMBOL_SEP)\n            ret[normalized] = data['id']\n            _exchange_info[COINBASE]['tick_size'][normalized] = data['quote_increment']\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('COINBASE', why, {\"\": r})\n\n\n<DED><DED>def gemini_symbols(*args) -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.gemini.com/v1/symbols')\n        ret = {}\n        for symbol in r.json():\n            <IND>std = f\"{symbol[:-3]}{SYMBOL_SEP}{symbol[-3:]}\"\n            std = std.upper()\n            ret[std] = symbol.upper()\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('GEMINI', why, {\"\": r})\n\n\n<DED><DED>def hitbtc_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>ret = {}\n        r = requests.get('https://api.hitbtc.com/api/2/public/symbol')\n        for symbol in r.json():\n            <IND>split = len(symbol['baseCurrency'])\n            normalized = symbol['id'][:split] + SYMBOL_SEP + symbol['id'][split:]\n            ret[normalized] = symbol['id']\n            _exchange_info[HITBTC]['tick_size'][normalized] = symbol['tickSize']\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('HITBTC', why, {\"\": r})\n\n\n<DED><DED>def poloniex_id_symbol_mapping():\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://poloniex.com/public?command=returnTicker')\n        symbols = r.json()\n        ret = {}\n        for symbol in symbols:\n            <IND>ret[symbols[symbol]['id']] = symbol\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('POLONIEX', why, {\"\": r})\n\n\n<DED><DED>def poloniex_symbols() -> Dict[str, str]:\n    <IND>ret = {}\n    for _, value in poloniex_id_symbol_mapping().items():\n        <IND>std = value.replace(\"STR\", \"XLM\")\n        quote, base = std.split(\"_\")\n        ret[quote + SYMBOL_SEP + base] = value\n    <DED>return ret\n\n\n<DED>def bitstamp_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://www.bitstamp.net/api/v2/trading-pairs-info/')\n        ret = {}\n        for data in r.json():\n            <IND>normalized = data['name'].replace(\"/\", SYMBOL_SEP)\n            symbol = data['url_symbol']\n            ret[normalized] = symbol\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BITSTAMP', why, {\"\": r})\n\n\n<DED><DED>def kraken_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.kraken.com/0/public/AssetPairs')\n        data = r.json()\n        ret = {}\n        for symbol in data['result']:\n            <IND>if 'wsname' not in data['result'][symbol] or '.d' in symbol:\n                # https://blog.kraken.com/post/259/introducing-the-kraken-dark-pool/\n                # .d is for dark pool symbols\n                <IND>continue\n\n            <DED>base, quote = data['result'][symbol]['wsname'].split(\"/\")\n\n            normalized = f\"{base}{SYMBOL_SEP}{quote}\"\n            exch = data['result'][symbol]['wsname']\n            normalized = normalized.replace('XBT', 'BTC')\n            normalized = normalized.replace('XDG', 'DOG')\n            ret[normalized] = exch\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('KRAKEN', why, {\"\": r})\n\n\n<DED><DED>def kraken_rest_symbols() -> Dict[str, str]:\n    <IND>return {normalized: exchange.replace(\"/\", \"\") for normalized, exchange in kraken_symbols().items()}\n\n\n<DED>def exx_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.exx.com/data/v1/tickers')\n        exchange = [key.upper() for key in r.json().keys()]\n        symbols = [key.replace(\"_\", SYMBOL_SEP) for key in exchange]\n        return dict(zip(symbols, exchange))\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('EXX', why, {\"\": r})\n\n\n<DED><DED>def huobi_common_symbols(url: str):\n    <IND>r = None\n    try:\n        <IND>r = requests.get(url)\n        ret = {}\n        for e in r.json()['data']:\n            <IND>if e['state'] == 'offline':\n                <IND>continue\n            <DED>normalized = f\"{e['base-currency'].upper()}{SYMBOL_SEP}{e['quote-currency'].upper()}\"\n            symbol = f\"{e['base-currency']}{e['quote-currency']}\"\n            ret[normalized] = symbol\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('HUOBI', why, {url: r})\n\n\n<DED><DED>def huobi_symbols() -> Dict[str, str]:\n    <IND>return huobi_common_symbols('https://api.huobi.pro/v1/common/symbols')\n\n\n<DED>def huobi_us_symbols() -> Dict[str, str]:\n    <IND>return huobi_common_symbols('https://api.huobi.com/v1/common/symbols')\n\n\n<DED>def huobi_dm_symbols() -> Dict[str, str]:\n    <IND>\"\"\"\n    Mapping is, for instance: {\"BTC_CW\":\"BTC190816\"}\n    See comments in exchange/huobi_dm.py\n    \"\"\"\n    mapping = {\n        \"this_week\": \"CW\",\n        \"next_week\": \"NW\",\n        \"quarter\": \"CQ\",\n        \"next_quarter\": \"NQ\"\n    }\n    r = None\n    try:\n        <IND>r = requests.get('https://www.hbdm.com/api/v1/contract_contract_info')\n        symbols = {}\n        for e in r.json()['data']:\n            <IND>symbols[f\"{e['symbol']}_{mapping[e['contract_type']]}\"] = e['contract_code']\n            _exchange_info[HUOBI_DM]['tick_size'][e['contract_code']] = e['price_tick']\n            _exchange_info[HUOBI_DM]['short_code_mappings'][f\"{e['symbol']}_{mapping[e['contract_type']]}\"] = e['contract_code']\n        <DED>return symbols\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('HUOBI_DM', why, {\"\": r})\n\n\n<DED><DED>def huobi_swap_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.hbdm.com/swap-api/v1/swap_contract_info')\n        symbols = {}\n        for e in r.json()['data']:\n            <IND>symbols[e['contract_code']] = e['contract_code']\n            _exchange_info[HUOBI_SWAP]['tick_size'][e['contract_code']] = e['price_tick']\n        <DED>return symbols\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('HUOBI_SWAP', why, {\"\": r})\n\n\n<DED><DED>def okcoin_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://www.okcoin.com/api/spot/v3/instruments')\n        ret = {}\n        for e in r.json():\n            <IND>ret[e['instrument_id']] = e['instrument_id']\n            _exchange_info[OKCOIN]['tick_size'][e['instrument_id']] = e['tick_size']\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('OKCOIN', why, {\"\": r})\n\n\n<DED><DED>def okex_symbols(*args) -> Dict[str, str]:\n    <IND>urls = ['https://www.okex.com/api/spot/v3/instruments',\n            'https://www.okex.com/api/swap/v3/instruments',\n            'https://www.okex.com/api/futures/v3/instruments']\n    urls = urls + okex_compute_option_urls_from_underlyings()\n\n    symbols: Dict[str, str] = {}\n    for u in urls:\n        <IND>time.sleep(0.2)\n        symbols.update(okex_symbols_from_one_url(u))\n\n    <DED>for symbol in symbols:\n        <IND>instrument_type = 'futures'\n        dash_count = symbol.count(get_symbol_separator())\n        if dash_count == 1:  # BTC-USDT\n            <IND>instrument_type = 'spot'\n        <DED>if dash_count == 4:  # BTC-USD-201225-35000-P\n            <IND>instrument_type = 'option'\n        <DED>if symbol[-4:] == \"SWAP\":  # BTC-USDT-SWAP\n            <IND>instrument_type = 'swap'\n\n        <DED>_exchange_info[OKEX]['instrument_type'][symbol] = instrument_type\n\n    <DED>return symbols\n\n\n<DED>def okex_compute_option_urls_from_underlyings() -> List[str]:\n    <IND>url = 'https://www.okex.com/api/option/v3/underlying'\n    r = None\n    try:\n        <IND>r = requests.get(url)\n        return [f'https://www.okex.com/api/option/v3/instruments/{underlying}' for underlying in r.json()]\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('OKEX', why, {url: r})\n\n\n<DED><DED>def okex_symbols_from_one_url(url: str) -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get(url)\n        ret = {}\n        for e in r.json():\n            <IND>ret[e['instrument_id']] = e['instrument_id']\n            _exchange_info[OKEX]['tick_size'][e['instrument_id']] = e['tick_size']\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('OKEX', why, {url: r})\n\n\n<DED><DED>def bittrex_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.bittrex.com/api/v1.1/public/getmarkets')\n        r = r.json()['result']\n        return {f\"{e['MarketCurrency']}{SYMBOL_SEP}{e['BaseCurrency']}\": e['MarketName'] for e in r if e['IsActive']}\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BITTREX', why, {\"\": r})\n\n\n<DED><DED>def bitcoincom_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.exchange.bitcoin.com/api/2/public/symbol')\n        return {f\"{data['baseCurrency']}{SYMBOL_SEP}{data['quoteCurrency'].replace('USD', 'USDT')}\": data['id'] for data in r.json()}\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BITCOINCOM', why, {\"\": r})\n\n\n<DED><DED>def bitmax_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://bitmax.io/api/pro/v1/products')\n        ret = {}\n        for entry in r.json()['data']:\n            # Only \"Normal\" status symbols are tradeable\n            <IND>if entry['status'] == 'Normal':\n                <IND>normalized = f\"{entry['baseAsset']}{SYMBOL_SEP}{entry['quoteAsset']}\"\n                ret[normalized] = entry['symbol']\n                _exchange_info[BITMAX]['tick_size'][normalized] = entry['tickSize']\n        <DED><DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BITMAX', why, {\"\": r})\n\n\n<DED><DED>def upbit_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.upbit.com/v1/market/all')\n        return {f\"{data['market'].split('-')[1]}{SYMBOL_SEP}{data['market'].split('-')[0]}\": data['market'] for data in r.json()}\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('UPBIT', why, {\"\": r})\n\n\n<DED><DED>def blockchain_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get(\"https://api.blockchain.com/mercury-gateway/v1/instruments\")\n        return {data[\"symbol\"].replace(\"-\", SYMBOL_SEP): data[\"symbol\"] for data in r.json()}\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BLOCKCHAIN', why, {\"\": r})\n\n\n<DED><DED>def gateio_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get(\"https://api.gateio.ws/api/v4/spot/currency_pairs\")\n        return {data[\"id\"].replace(\"_\", SYMBOL_SEP): data['id'] for data in r.json()}\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('GATEIO', why, {\"\": r})\n\n\n<DED><DED>def bitmex_symbols() -> Dict[str, str]:\n    <IND>r = None\n    ret = {}\n    try:\n        <IND>r = requests.get(\"https://www.bitmex.com/api/v1/instrument/active\")\n        for entry in r.json():\n            <IND>components = []\n            components.append(entry['rootSymbol'])\n            components.append(entry['quoteCurrency'])\n\n            if entry['expiry']:\n                <IND>components.append(entry['symbol'][-3:])\n\n            <DED>normalized = SYMBOL_SEP.join(components)\n            normalized = normalized.replace(\"XBT\", \"BTC\")\n            ret[normalized] = entry['symbol']\n            _exchange_info[BITMEX]['tick_size'][normalized] = entry['tickSize']\n\n            if entry['expiry']:\n                <IND>_exchange_info[BITMEX]['expiry'][normalized] = entry['expiry']\n\n        <DED><DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BITMEX', why, {\"\": r})\n\n\n<DED><DED>def deribit_symbols() -> Dict[str, str]:\n    <IND>url = r = None\n    ret = {}\n    try:\n        # TODO: get currencies from https://www.deribit.com/api/v2/public/get_currencies\n        <IND>currencies = ['BTC', 'ETH']\n        for c in currencies:\n            <IND>url = f\"https://www.deribit.com/api/v2/public/get_instruments?currency={c}&expired=false\"\n            r = requests.get(url)\n            for entry in r.json()['result']:\n                <IND>split = entry['instrument_name'].split(\"-\")\n                normalized = split[0] + SYMBOL_SEP + entry['quote_currency'] + \"-\" + '-'.join(split[1:])\n                ret[normalized] = entry['instrument_name']\n                _exchange_info[DERIBIT]['tick_size'][normalized] = entry['tick_size']\n        <DED><DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('DERIBIT', why, {url: r})\n\n\n<DED><DED>def kraken_future_symbols() -> Dict[str, str]:\n    <IND>r = None\n    ret = {}\n    try:\n        <IND>r = requests.get('https://futures.kraken.com/derivatives/api/v3/instruments')\n        data = r.json()['instruments']\n        for entry in data:\n            <IND>if not entry['tradeable']:\n                <IND>continue\n            <DED>normalized = entry['symbol'].upper().replace(\"_\", \"-\")\n            symbol = normalized[3:6] + SYMBOL_SEP + normalized[6:9]\n            normalized = normalized.replace(normalized[3:9], symbol)\n            normalized = normalized.replace('XBT', 'BTC')\n\n            _exchange_info[KRAKEN_FUTURES]['tick_size'][normalized] = entry['tickSize']\n            _exchange_info[KRAKEN_FUTURES]['contract_size'][normalized] = entry['contractSize']\n            _exchange_info[KRAKEN_FUTURES]['underlying'][normalized] = entry['underlying']\n            _exchange_info[KRAKEN_FUTURES]['product_type'][normalized] = _kraken_futures_product_type[normalized[:2]]\n            ret[normalized] = entry['symbol']\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('KRAKEN_FUTURES', why, {\"\": r})\n\n\n<DED><DED>def probit_symbols() -> Dict[str, str]:\n    # doc: https://docs-en.probit.com/reference-link/market\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.probit.com/api/exchange/v1/market')\n        return {entry['id']: entry['id'] for entry in r.json()['data']}\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('PROBIT', why, {\"\": r})\n\n\n<DED><DED>def coingecko_normalize_symbol(symbol: str) -> str:\n    # keep digits, letters and dots, replace others by space\n    <IND>symbol = ''.join(c if c.isalnum() or c in ('.', '+') else ' ' for c in symbol)\n    return coingecko_normalize(symbol.upper())\n\n\n<DED>def coingecko_normalize_name(name: str) -> str:\n    # keep digits and letters, replace others by space (except when only composed by upper case letters, digits and dots)\n    <IND>if not all(c.isupper() or c.isdigit() or c == '.' for c in name):\n        <IND>name = ''.join(c if c.isalnum() else ' ' for c in name)\n    <DED>return coingecko_normalize(name)\n\n\n<DED>def coingecko_normalize(sym: str) -> str:\n    <IND>sym = sym.strip()\n    # do not concatenate numbers => separate them with a dot\n    sym = list(sym)\n    if len(sym) > 4:\n        <IND>for i in range(2, len(sym) - 1):\n            <IND>if sym[i] == ' ' and sym[i - 1].isdigit() and sym[i + 1].isdigit():\n                <IND>sym[i] = '.'\n    <DED><DED><DED>sym = ''.join(sym)\n    # concatenate space-separated words => use CamelCase to distinguish the words\n    if ' ' in sym:\n        <IND>if sum(c.islower() for c in sym):  # if there is at least one lower case letter\n            <IND>sym = ' '.join(word[0].upper() + word[1:] for word in sym.split())  # Just capitalize initial letter of each word\n        <DED>else:  # CoinGecko may provide full upper-case as for \"THE STONE COIN\"\n            <IND>sym = string.capwords(sym)  # capwords converts \"THE STONE COIN\" to \"The Stone Coin\"\n        <DED>sym = sym.replace(' ', '')  # concatenate words\n    <DED>return sym\n\n\n<DED>def is_name_short(coin: dict) -> bool:\n    <IND>\"\"\"return True if the coin name is enough short compared to the coin symbol.\"\"\"\n    return len(coin['name']) <= max(5, len(coin['symbol']) + 1)\n\n\n<DED>def has_many_caps(name: str) -> bool:\n    <IND>\"\"\"return True if the symbol contains enough upper case letters, False if empty.\"\"\"\n    return str and sum(c.islower() for c in name) < (len(name) / 2)\n\n\n<DED>def coingecko_normalize_all(coin: dict):\n    <IND>SYMBOL_TO_NORMALIZED = {'miota': 'IOTA'}\n    normalized = SYMBOL_TO_NORMALIZED.get(coin['symbol'])\n    if normalized:\n        <IND>coin['ns'] = coin['nn'] = normalized\n        return normalized\n\n    # ns = normalized symbol, nn = normalized name\n    <DED>coin['ns'] = coingecko_normalize_symbol(coin['symbol'])\n\n    ID_SUFFIX = '-bitcoin-token'\n    if coin['id'][-len(ID_SUFFIX):] == ID_SUFFIX:\n        <IND>coin['nn'] = 'BTC' + coin['ns']\n        return coin['nn']\n\n    <DED>name = coin['name']\n\n    prefixes = ('The ', 'the ')\n    for p in prefixes:\n        <IND>if name[:len(p)] == p:\n            <IND>coin['reduced-name'] = True\n            name = name[len(p):]\n            break\n\n    <DED><DED>suffixes = ('coin', 'coins', 'money', 'finance', 'protocol', 'reward', 'rewards', 'token')\n    for s in suffixes:\n        <IND>if len(name) > len(s) and name[-len(s):].lower() == s:\n            # but keep suffix when lower-case concatenated\n            <IND>if name[-len(s)].islower() and name[-len(s) - 1] != ' ':\n                <IND>continue\n            # also keep suffix to avoid confusing nam: \"Bitcoin Token\" -> \"Bitcoin\"\n            <DED>if name[:-len(s)].strip().lower() == 'bitcoin':\n                <IND>continue\n            <DED>coin['reduced-name'] = True\n            name = name[:-len(s)]\n            break\n\n    <DED><DED>coin['nn'] = coingecko_normalize_name(name)\n\n    if len(coin['nn']) < len(coin['ns']):\n        <IND>if 'reduced-name' in coin:\n            <IND>coin['reduced-name'] = False\n            name = coin['name']\n            coin['nn'] = coingecko_normalize_name(name)\n        <DED>elif not has_many_caps(name):\n            <IND>return coin['ns']\n\n    <DED><DED>if not coin['ns']:  # coin['symbol'] may be an emoji that is striped when normalized\n        <IND>return coin['nn']\n\n    <DED>if coin.get('reduced-name') and coin['ns'].upper() != coin['nn'].upper():\n        <IND>return coin['ns']\n\n    <DED>i = coin['nn'].find('.')  # if there is a dot in normalized name => prefer the normalized symbol\n    if i >= 0:\n        <IND>if i > 1 and coin['nn'][i - 1].isdigit() and coin['nn'][i + 1].isdigit():\n            <IND>pass  # except when the dot separates digits\n        <DED>else:\n            <IND>return coin['ns']\n\n    <DED><DED>if is_name_short(coin) and has_many_caps(name):\n        <IND>return coin['nn']\n\n    <DED>if 1.5 * len(coin['ns']) > len(coin['nn']) and any(c.islower() for c in coin['ns']):\n        <IND>return coin['nn']\n\n    <DED>return coin['ns']\n\n\n<DED>def coingecko_symbols() -> Dict[str, str]:\n    <IND>r = None\n    intermediate = defaultdict(list)\n    try:\n        <IND>r = requests.get('https://api.coingecko.com/api/v3/coins/list')\n        all_coins = r.json()\n        # First pass: generate & compare normalized symbol/name, and then select the most pertinent\n        for coin in all_coins:\n            <IND>normalized = coingecko_normalize_all(coin)\n            intermediate[normalized].append(coin)\n            # Above line keeps together the coins having the same normalized symbol.\n            # To reduce collision, the coin['name'] is sometimes used in lieu of the coin['symbol'].\n            # The coin['name'] is not capitalized because lower case letters may be meaningful: cETH, yUSD, DATx, zLOT\n    <DED><DED>except Exception as why:\n        <IND>raise_failure_explanation('COINGECKO', why, {\"\": r})\n\n    <DED>final = coingecko_second_pass(intermediate)\n    return coingecko_third_pass(final)\n\n\n<DED>def coingecko_second_pass(intermediate: Dict[str, List[dict]]) -> Dict[str, List[dict]]:\n    # Second pass: fixes most of the symbol collisions\n    <IND>final = defaultdict(list)\n    for normalized, coins in intermediate.items():\n        <IND>if len(coins) == 1:\n            <IND>final[normalized].append(coins[0])\n            continue\n        <DED>set_normalized = False\n        for i in range(len(coins)):\n            <IND>if normalized == coins[i]['nn']:\n                <IND>coin = coins.pop(i)\n                final[normalized].append(coin)\n                set_normalized = True\n                break\n        <DED><DED>rest: List[dict] = []\n        for coin in coins:\n            <IND>if '%' in coin['name']:\n                <IND>if len(coins) == 1:\n                    <IND>n = coin['ns']\n                <DED>else:\n                    <IND>n = coingecko_normalize_name(coin['id'])\n                <DED>final[n].append(coin)\n            <DED>else:\n                <IND>rest.append(coin)\n        <DED><DED>if not rest:\n            <IND>continue\n        <DED>if not set_normalized:\n            <IND>rest.sort(key=lambda coin: len(coin['nn']), reverse=True)  # sort by the length of the normalized name\n            coin = rest.pop(0)\n            final[normalized].append(coin)\n        <DED>for coin in rest:\n            <IND>if coin['nn'] not in intermediate:\n                <IND>n = coin['nn']\n            <DED>elif coin.get('reduced-name'):\n                <IND>n = coingecko_normalize_name(coin['name'])\n            <DED>else:\n                <IND>n = coingecko_normalize_name(coin['id'])\n            <DED>final[n].append(coin)\n    <DED><DED>return final\n\n\n<DED>def coingecko_third_pass(final: Dict[str, List[dict]]) -> Dict[str, str]:\n    # Third pass: fixes some remaining collisions and fills the result\n    <IND>symbols = {}\n    for normalized, coins in final.items():\n        <IND>if len(coins) == 1:\n            <IND>symbols[normalized] = coins[0]['id']\n            continue\n        <DED>set_normalized = False\n        for i in range(len(coins)):\n            <IND>if normalized == coins[i]['nn']:\n                <IND>coin = coins.pop(i)\n                symbols[normalized] = coin['id']\n                set_normalized = True\n                break\n        <DED><DED>rest: List[dict] = []\n        for coin in coins:\n            <IND>if '%' in coin['name']:\n                <IND>if len(coins) == 1:\n                    <IND>n = coin['ns']\n                <DED>else:\n                    <IND>n = coingecko_normalize_name(coin['id'])\n                <DED>symbols[n] = coin['id']\n            <DED>else:\n                <IND>rest.append(coin)\n        <DED><DED>if not rest:\n            <IND>continue\n        <DED>if not set_normalized:\n            <IND>rest.sort(key=lambda coin: len(coin['nn']), reverse=True)  # sort by the length of the normalized name\n            coin = rest.pop(0)\n            symbols[normalized] = coin['id']\n        <DED>for coin in rest:\n            <IND>if coin['nn'] not in final:\n                <IND>n = coin['nn']\n            <DED>elif coin.get('reduced-name'):\n                <IND>n = coingecko_normalize_name(coin['name'])\n            <DED>else:\n                <IND>n = coingecko_normalize_name(coin['id'])\n            <DED>symbols[n] = coin['id']\n    <DED><DED>return symbols\n\n\n<DED>def whale_alert_coins(key_id: str) -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get(f'https://api.whale-alert.io/v1/status?api_key={key_id}')\n        # Same symbols, but on different blockchains (for instance USDT), are naturally overwritten.\n        return {s.upper(): s for b in r.json()['blockchains'] for s in b['symbols'] if s}\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('WHALES_ALERT', why, {\"\": r})\n\n\n<DED><DED>_exchange_function_map = {\n    BITFINEX: bitfinex_symbols,\n    BITFLYER: bitflyer_symbols,\n    COINBASE: coinbase_symbols,\n    GEMINI: gemini_symbols,\n    HITBTC: hitbtc_symbols,\n    POLONIEX: poloniex_symbols,\n    PROBIT: probit_symbols,\n    BITSTAMP: bitstamp_symbols,\n    KRAKEN: kraken_symbols,\n    KRAKEN + 'REST': kraken_rest_symbols,\n    BINANCE: binance_symbols,\n    BINANCE_US: binance_us_symbols,\n    BINANCE_FUTURES: binance_futures_symbols,\n    BINANCE_DELIVERY: binance_delivery_symbols,\n    BLOCKCHAIN: blockchain_symbols,\n    EXX: exx_symbols,\n    HUOBI: huobi_symbols,\n    HUOBI_DM: huobi_dm_symbols,\n    HUOBI_SWAP: huobi_swap_symbols,\n    OKCOIN: okcoin_symbols,\n    OKEX: okex_symbols,\n    BYBIT: bybit_symbols,\n    FTX: ftx_symbols,\n    FTX_US: ftx_us_symbols,\n    BITTREX: bittrex_symbols,\n    BITCOINCOM: bitcoincom_symbols,\n    BITMAX: bitmax_symbols,\n    UPBIT: upbit_symbols,\n    GATEIO: gateio_symbols,\n    BITMEX: bitmex_symbols,\n    DERIBIT: deribit_symbols,\n    KRAKEN_FUTURES: kraken_future_symbols,\n    COINGECKO: coingecko_symbols,\n    WHALE_ALERT: whale_alert_coins\n}\n",
        "target_code_with_indent": "\nfrom typing import Dict, Tuple\n\n\nclass _Symbols:\n    <IND>def __init__(self):\n        <IND>self.data = {}\n\n    <DED>def set(self, exchange: str, normalized: dict, exchange_info: dict):\n        <IND>self.data[exchange] = {}\n        self.data[exchange]['normalized'] = normalized\n        self.data[exchange]['info'] = exchange_info\n\n    <DED>def get(self, exchange: str) -> Tuple[Dict, Dict]:\n        <IND>return self.data[exchange]['normalized'], self.data[exchange]['info']\n\n    <DED>def populated(self, exchange: str) -> bool:\n        <IND>return exchange in self.data\n\n\n<DED><DED>Symbols = _Symbols()\n"
      }
    ]
  },
  {
    "project": "bmoscon/cryptofeed",
    "commit": "3525dc8ce4d7836a9abaaa5662e58e5e27969a77",
    "filename": "cryptofeed/symbols.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/bmoscon-cryptofeed/cryptofeed/symbols.py",
    "file_hunks_size": 1,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "cryptofeed/symbols.py:164:51 Incompatible parameter type [6]: Expected `Dict[str, Optional[requests.models.Response]]` for 3rd positional only parameter to call `raise_failure_explanation` but got `Dict[None, Optional[requests.models.Response]]`.",
    "message": " Expected `Dict[str, Optional[requests.models.Response]]` for 3rd positional only parameter to call `raise_failure_explanation` but got `Dict[None, Optional[requests.models.Response]]`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 164,
    "warning_line": "        raise_failure_explanation('BITFLYER', why, {endpoint: r})",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "associated with this software.\n\n\nSymbol generation code for exchanges\n'''\n\nimport logging\nimport string\nimport time\nfrom collections import defaultdict\nfrom typing import Dict, List, Optional, Tuple\n\nimport requests\nfrom requests import Response\n\nfrom cryptofeed.defines import *\n\n\nLOG = logging.getLogger('feedhandler')\n\nSYMBOL_SEP = '-'\n\n_symbols_retrieval_cache: Dict[str, Dict[str, str]] = {}\n_exchange_info = defaultdict(lambda: defaultdict(dict))\n\n\n_kraken_futures_product_type = {\n    'FI': 'Inverse Futures',\n    'FV': 'Vanilla Futures',\n    'PI': 'Perpetual Inverse Futures',\n    'PV': 'Perpetual Vanilla Futures',\n    'IN': 'Real Time Index',\n    'RR': 'Reference Rate',\n}\n\n\ndef raise_failure_explanation(feed_id: str, exception: BaseException, responses: Dict[str, Optional[Response]]):\n    LOG.critical('%s: encountered %r while processing response from exchange API', feed_id, exception)\n    if len(responses) > 1:\n        LOG.critical('%s: content of one of the %s responses was unexpected', feed_id, len(responses))\n    for url, r in responses.items():\n        if url:\n            LOG.critical('%s: requested URL: %s', feed_id, url)\n        if r:\n            LOG.critical('%s: unexpected response: %s', feed_id, r.text)\n    raise ValueError(f'Cryptofeed stopped because of an unexpected response from {feed_id}') from exception\n\n\ndef set_symbol_separator(separator: str):\n    global SYMBOL_SEP\n    SYMBOL_SEP = separator\n\n\ndef get_symbol_separator() -> str:\n    global SYMBOL_SEP\n    return SYMBOL_SEP\n\n\ndef gen_symbols(exchange: str, key_id=None) -> Dict[str, str]:\n    if exchange not in _symbols_retrieval_cache:\n        LOG.info(\"%s: Getting list of symbols\", exchange)\n        symbols = _exchange_function_map[exchange](key_id) if key_id else _exchange_function_map[exchange]()\n        LOG.info(\"%s: %s symbols\", exchange, len(symbols))\n\n        # log all retrieved symbols using debug level\n        for normalized, exch_sym in sorted(symbols.items()):\n            LOG.debug('%s: id-from-exch -> normalized: %-35s-> %s', exchange, exch_sym, normalized)\n\n        _symbols_retrieval_cache[exchange] = symbols\n    return _symbols_retrieval_cache[exchange]\n\n\ndef _binance_symbols(endpoint: str, exchange: str):\n    r = None\n    try:\n        ret = {}\n        r = requests.get(endpoint)\n        for symbol in r.json()['symbols']:\n            if symbol.get('status', 'TRADING') != \"TRADING\":\n                continue\n            if symbol.get('contractStatus', 'TRADING') != \"TRADING\":\n                continue\n            split = len(symbol['baseAsset'])\n            normalized = symbol['symbol'][:split] + SYMBOL_SEP + symbol['symbol'][split:]\n            ret[normalized] = symbol['symbol']\n            _exchange_info[exchange]['tick_size'][normalized] = symbol['filters'][0]['tickSize']\n            if \"contractType\" in symbol:\n                _exchange_info[exchange]['contract_type'][normalized] = symbol['contractType']\n        return ret\n    except Exception as why:\n        raise_failure_explanation(exchange, why, {endpoint: r})\n\n\ndef binance_symbols() -> Dict[str, str]:\n    return _binance_symbols('https://api.binance.com/api/v3/exchangeInfo', BINANCE)\n\n\ndef binance_us_symbols() -> Dict[str, str]:\n    return _binance_symbols('https://api.binance.us/api/v3/exchangeInfo', BINANCE_US)\n\n\ndef binance_futures_symbols() -> Dict[str, str]:\n    base = _binance_symbols('https://fapi.binance.com/fapi/v1/exchangeInfo', BINANCE_FUTURES)\n    add = {}\n    for symbol, orig in base.items():\n        if \"_\" in orig:\n            continue\n        add[f\"{symbol}-PINDEX\"] = f\"p{orig}\"\n    base.update(add)\n    return base\n\n\ndef binance_delivery_symbols() -> Dict[str, str]:\n    return _binance_symbols('https://dapi.binance.com/dapi/v1/exchangeInfo', BINANCE_DELIVERY)\n\n\ndef bitfinex_symbols() -> Dict[str, str]:\n    # doc: https://docs.bitfinex.com/docs/ws-general#supported-pairs\n    r1 = r2 = None\n    try:\n        r1 = requests.get('https://api.bitfinex.com/v2/tickers?symbols=ALL')\n        r2 = requests.get('https://api-pub.bitfinex.com/v2/conf/pub:map:currency:sym')\n        tickers: List[List[str]] = r1.json()\n        norm: List[Tuple[str, str]] = r2.json()[0]\n        norm: Dict[str, str] = dict(norm)\n        for k, v in dict(norm).items():\n            if k[-2:] == 'F0' or '-' in v:  # Do not convert BTCF0 -> BTC or PBTCETH -> PBTC-ETH\n                del norm[k]\n        norm['BCHN'] = 'BCH'  # Bitfinex uses BCHN, other exchanges use BCH\n\n        ret = {}\n        for symbol in [t[0] for t in tickers]:\n            if symbol[0] == 'f':\n                normalized = norm.get(symbol[1:], symbol[1:])\n            else:\n                if len(symbol) == 7:\n                    base, quote = symbol[1:4], symbol[4:]\n                else:\n                    base, quote = symbol[1:].split(':')\n                    assert ':' in symbol\n                normalized = norm.get(base, base) + SYMBOL_SEP + norm.get(quote, quote)\n            ret[normalized.upper()] = symbol\n        return ret\n    except ValueError as why:\n        raise_failure_explanation('BITFINEX', why, {\"tickers?symbols=ALL\": r1, \"pub:map:currency:sym\": r2})\n\n\ndef bitflyer_symbols() -> Dict[str, str]:\n    endpoint = r = None\n    try:\n        ret = {}\n        endpoints = ['https://api.bitflyer.com/v1/getmarkets/eu', 'https://api.bitflyer.com/v1/getmarkets/usa', 'https://api.bitflyer.com/v1/getmarkets']\n        for endpoint in endpoints:\n            r = requests.get(endpoint)\n            for entry in r.json():\n                normalized = entry['product_code'].replace(\"_\", SYMBOL_SEP)\n                ret[normalized] = entry['product_code']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('BITFLYER', why, {endpoint: r})\n\n\ndef bybit_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.bybit.com/v2/public/symbols')\n        ret = {}\n        for symbol in r.json()['result']:\n            quote = symbol['quote_currency']\n            if not symbol['name'].endswith(quote):\n                base, contract = symbol['name'].split(quote)\n                normalized = f\"{base}{SYMBOL_SEP}{quote}-{contract}\"\n            else:\n                normalized = f\"{symbol['base_currency']}{SYMBOL_SEP}{quote}\"\n            ret[normalized] = symbol['name']\n            _exchange_info[BYBIT]['tick_size'][normalized] = symbol['price_filter']['tick_size']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('BYBIT', why, {\"\": r})\n\n\ndef _ftx_helper(endpoint: str, exchange: str):\n    r = None\n    try:\n        r = requests.get(endpoint)\n        ret = {}\n        for data in r.json()['result']:\n            normalized = data['name'].replace(\"/\", SYMBOL_SEP)\n            symbol = data['name']\n            ret[normalized] = symbol\n            _exchange_info[exchange]['tick_size'][normalized] = data['priceIncrement']\n        return ret\n    except Exception as why:\n        raise_failure_explanation(exchange, why, {endpoint: r})\n\n\ndef ftx_symbols() -> Dict[str, str]:\n    return _ftx_helper('https://ftx.com/api/markets', FTX)\n\n\ndef ftx_us_symbols() -> Dict[str, str]:\n    return _ftx_helper('https://ftx.us/api/markets', FTX_US)\n\n\ndef coinbase_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.pro.coinbase.com/products')\n        ret = {}\n        for data in r.json():\n            normalized = data['id'].replace(\"-\", SYMBOL_SEP)\n            ret[normalized] = data['id']\n            _exchange_info[COINBASE]['tick_size'][normalized] = data['quote_increment']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('COINBASE', why, {\"\": r})\n\n\ndef gemini_symbols(*args) -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.gemini.com/v1/symbols')\n        ret = {}\n        for symbol in r.json():\n            std = f\"{symbol[:-3]}{SYMBOL_SEP}{symbol[-3:]}\"\n            std = std.upper()\n            ret[std] = symbol.upper()\n        return ret\n    except Exception as why:\n        raise_failure_explanation('GEMINI', why, {\"\": r})\n\n\ndef hitbtc_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        ret = {}\n        r = requests.get('https://api.hitbtc.com/api/2/public/symbol')\n        for symbol in r.json():\n            split = len(symbol['baseCurrency'])\n            normalized = symbol['id'][:split] + SYMBOL_SEP + symbol['id'][split:]\n            ret[normalized] = symbol['id']\n            _exchange_info[HITBTC]['tick_size'][normalized] = symbol['tickSize']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('HITBTC', why, {\"\": r})\n\n\ndef poloniex_id_symbol_mapping():\n    r = None\n    try:\n        r = requests.get('https://poloniex.com/public?command=returnTicker')\n        symbols = r.json()\n        ret = {}\n        for symbol in symbols:\n            ret[symbols[symbol]['id']] = symbol\n        return ret\n    except Exception as why:\n        raise_failure_explanation('POLONIEX', why, {\"\": r})\n\n\ndef poloniex_symbols() -> Dict[str, str]:\n    ret = {}\n    for _, value in poloniex_id_symbol_mapping().items():\n        std = value.replace(\"STR\", \"XLM\")\n        quote, base = std.split(\"_\")\n        ret[quote + SYMBOL_SEP + base] = value\n    return ret\n\n\ndef bitstamp_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://www.bitstamp.net/api/v2/trading-pairs-info/')\n        ret = {}\n        for data in r.json():\n            normalized = data['name'].replace(\"/\", SYMBOL_SEP)\n            symbol = data['url_symbol']\n            ret[normalized] = symbol\n        return ret\n    except Exception as why:\n        raise_failure_explanation('BITSTAMP', why, {\"\": r})\n\n\ndef kraken_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.kraken.com/0/public/AssetPairs')\n        data = r.json()\n        ret = {}\n        for symbol in data['result']:\n            if 'wsname' not in data['result'][symbol] or '.d' in symbol:\n                # https://blog.kraken.com/post/259/introducing-the-kraken-dark-pool/\n                # .d is for dark pool symbols\n                continue\n\n            base, quote = data['result'][symbol]['wsname'].split(\"/\")\n\n            normalized = f\"{base}{SYMBOL_SEP}{quote}\"\n            exch = data['result'][symbol]['wsname']\n            normalized = normalized.replace('XBT', 'BTC')\n            normalized = normalized.replace('XDG', 'DOG')\n            ret[normalized] = exch\n        return ret\n    except Exception as why:\n        raise_failure_explanation('KRAKEN', why, {\"\": r})\n\n\ndef kraken_rest_symbols() -> Dict[str, str]:\n    return {normalized: exchange.replace(\"/\", \"\") for normalized, exchange in kraken_symbols().items()}\n\n\ndef exx_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.exx.com/data/v1/tickers')\n        exchange = [key.upper() for key in r.json().keys()]\n        symbols = [key.replace(\"_\", SYMBOL_SEP) for key in exchange]\n        return dict(zip(symbols, exchange))\n    except Exception as why:\n        raise_failure_explanation('EXX', why, {\"\": r})\n\n\ndef huobi_common_symbols(url: str):\n    r = None\n    try:\n        r = requests.get(url)\n        ret = {}\n        for e in r.json()['data']:\n            if e['state'] == 'offline':\n                continue\n            normalized = f\"{e['base-currency'].upper()}{SYMBOL_SEP}{e['quote-currency'].upper()}\"\n            symbol = f\"{e['base-currency']}{e['quote-currency']}\"\n            ret[normalized] = symbol\n        return ret\n    except Exception as why:\n        raise_failure_explanation('HUOBI', why, {url: r})\n\n\ndef huobi_symbols() -> Dict[str, str]:\n    return huobi_common_symbols('https://api.huobi.pro/v1/common/symbols')\n\n\ndef huobi_us_symbols() -> Dict[str, str]:\n    return huobi_common_symbols('https://api.huobi.com/v1/common/symbols')\n\n\ndef huobi_dm_symbols() -> Dict[str, str]:\n    \"\"\"\n    Mapping is, for instance: {\"BTC_CW\":\"BTC190816\"}\n    See comments in exchange/huobi_dm.py\n    \"\"\"\n    mapping = {\n        \"this_week\": \"CW\",\n        \"next_week\": \"NW\",\n        \"quarter\": \"CQ\",\n        \"next_quarter\": \"NQ\"\n    }\n    r = None\n    try:\n        r = requests.get('https://www.hbdm.com/api/v1/contract_contract_info')\n        symbols = {}\n        for e in r.json()['data']:\n            symbols[f\"{e['symbol']}_{mapping[e['contract_type']]}\"] = e['contract_code']\n            _exchange_info[HUOBI_DM]['tick_size'][e['contract_code']] = e['price_tick']\n            _exchange_info[HUOBI_DM]['short_code_mappings'][f\"{e['symbol']}_{mapping[e['contract_type']]}\"] = e['contract_code']\n        return symbols\n    except Exception as why:\n        raise_failure_explanation('HUOBI_DM', why, {\"\": r})\n\n\ndef huobi_swap_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.hbdm.com/swap-api/v1/swap_contract_info')\n        symbols = {}\n        for e in r.json()['data']:\n            symbols[e['contract_code']] = e['contract_code']\n            _exchange_info[HUOBI_SWAP]['tick_size'][e['contract_code']] = e['price_tick']\n        return symbols\n    except Exception as why:\n        raise_failure_explanation('HUOBI_SWAP', why, {\"\": r})\n\n\ndef okcoin_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://www.okcoin.com/api/spot/v3/instruments')\n        ret = {}\n        for e in r.json():\n            ret[e['instrument_id']] = e['instrument_id']\n            _exchange_info[OKCOIN]['tick_size'][e['instrument_id']] = e['tick_size']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('OKCOIN', why, {\"\": r})\n\n\ndef okex_symbols(*args) -> Dict[str, str]:\n    urls = ['https://www.okex.com/api/spot/v3/instruments',\n            'https://www.okex.com/api/swap/v3/instruments',\n            'https://www.okex.com/api/futures/v3/instruments']\n    urls = urls + okex_compute_option_urls_from_underlyings()\n\n    symbols: Dict[str, str] = {}\n    for u in urls:\n        time.sleep(0.2)\n        symbols.update(okex_symbols_from_one_url(u))\n\n    for symbol in symbols:\n        instrument_type = 'futures'\n        dash_count = symbol.count(get_symbol_separator())\n        if dash_count == 1:  # BTC-USDT\n            instrument_type = 'spot'\n        if dash_count == 4:  # BTC-USD-201225-35000-P\n            instrument_type = 'option'\n        if symbol[-4:] == \"SWAP\":  # BTC-USDT-SWAP\n            instrument_type = 'swap'\n\n        _exchange_info[OKEX]['instrument_type'][symbol] = instrument_type\n\n    return symbols\n\n\ndef okex_compute_option_urls_from_underlyings() -> List[str]:\n    url = 'https://www.okex.com/api/option/v3/underlying'\n    r = None\n    try:\n        r = requests.get(url)\n        return [f'https://www.okex.com/api/option/v3/instruments/{underlying}' for underlying in r.json()]\n    except Exception as why:\n        raise_failure_explanation('OKEX', why, {url: r})\n\n\ndef okex_symbols_from_one_url(url: str) -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get(url)\n        ret = {}\n        for e in r.json():\n            ret[e['instrument_id']] = e['instrument_id']\n            _exchange_info[OKEX]['tick_size'][e['instrument_id']] = e['tick_size']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('OKEX', why, {url: r})\n\n\ndef bittrex_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.bittrex.com/api/v1.1/public/getmarkets')\n        r = r.json()['result']\n        return {f\"{e['MarketCurrency']}{SYMBOL_SEP}{e['BaseCurrency']}\": e['MarketName'] for e in r if e['IsActive']}\n    except Exception as why:\n        raise_failure_explanation('BITTREX', why, {\"\": r})\n\n\ndef bitcoincom_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.exchange.bitcoin.com/api/2/public/symbol')\n        return {f\"{data['baseCurrency']}{SYMBOL_SEP}{data['quoteCurrency'].replace('USD', 'USDT')}\": data['id'] for data in r.json()}\n    except Exception as why:\n        raise_failure_explanation('BITCOINCOM', why, {\"\": r})\n\n\ndef bitmax_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://bitmax.io/api/pro/v1/products')\n        ret = {}\n        for entry in r.json()['data']:\n            # Only \"Normal\" status symbols are tradeable\n            if entry['status'] == 'Normal':\n                normalized = f\"{entry['baseAsset']}{SYMBOL_SEP}{entry['quoteAsset']}\"\n                ret[normalized] = entry['symbol']\n                _exchange_info[BITMAX]['tick_size'][normalized] = entry['tickSize']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('BITMAX', why, {\"\": r})\n\n\ndef upbit_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.upbit.com/v1/market/all')\n        return {f\"{data['market'].split('-')[1]}{SYMBOL_SEP}{data['market'].split('-')[0]}\": data['market'] for data in r.json()}\n    except Exception as why:\n        raise_failure_explanation('UPBIT', why, {\"\": r})\n\n\ndef blockchain_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get(\"https://api.blockchain.com/mercury-gateway/v1/instruments\")\n        return {data[\"symbol\"].replace(\"-\", SYMBOL_SEP): data[\"symbol\"] for data in r.json()}\n    except Exception as why:\n        raise_failure_explanation('BLOCKCHAIN', why, {\"\": r})\n\n\ndef gateio_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get(\"https://api.gateio.ws/api/v4/spot/currency_pairs\")\n        return {data[\"id\"].replace(\"_\", SYMBOL_SEP): data['id'] for data in r.json()}\n    except Exception as why:\n        raise_failure_explanation('GATEIO', why, {\"\": r})\n\n\ndef bitmex_symbols() -> Dict[str, str]:\n    r = None\n    ret = {}\n    try:\n        r = requests.get(\"https://www.bitmex.com/api/v1/instrument/active\")\n        for entry in r.json():\n            components = []\n            components.append(entry['rootSymbol'])\n            components.append(entry['quoteCurrency'])\n\n            if entry['expiry']:\n                components.append(entry['symbol'][-3:])\n\n            normalized = SYMBOL_SEP.join(components)\n            normalized = normalized.replace(\"XBT\", \"BTC\")\n            ret[normalized] = entry['symbol']\n            _exchange_info[BITMEX]['tick_size'][normalized] = entry['tickSize']\n\n            if entry['expiry']:\n                _exchange_info[BITMEX]['expiry'][normalized] = entry['expiry']\n\n        return ret\n    except Exception as why:\n        raise_failure_explanation('BITMEX', why, {\"\": r})\n\n\ndef deribit_symbols() -> Dict[str, str]:\n    url = r = None\n    ret = {}\n    try:\n        # TODO: get currencies from https://www.deribit.com/api/v2/public/get_currencies\n        currencies = ['BTC', 'ETH']\n        for c in currencies:\n            url = f\"https://www.deribit.com/api/v2/public/get_instruments?currency={c}&expired=false\"\n            r = requests.get(url)\n            for entry in r.json()['result']:\n                split = entry['instrument_name'].split(\"-\")\n                normalized = split[0] + SYMBOL_SEP + entry['quote_currency'] + \"-\" + '-'.join(split[1:])\n                ret[normalized] = entry['instrument_name']\n                _exchange_info[DERIBIT]['tick_size'][normalized] = entry['tick_size']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('DERIBIT', why, {url: r})\n\n\ndef kraken_future_symbols() -> Dict[str, str]:\n    r = None\n    ret = {}\n    try:\n        r = requests.get('https://futures.kraken.com/derivatives/api/v3/instruments')\n        data = r.json()['instruments']\n        for entry in data:\n            if not entry['tradeable']:\n                continue\n            normalized = entry['symbol'].upper().replace(\"_\", \"-\")\n            symbol = normalized[3:6] + SYMBOL_SEP + normalized[6:9]\n            normalized = normalized.replace(normalized[3:9], symbol)\n            normalized = normalized.replace('XBT', 'BTC')\n\n            _exchange_info[KRAKEN_FUTURES]['tick_size'][normalized] = entry['tickSize']\n            _exchange_info[KRAKEN_FUTURES]['contract_size'][normalized] = entry['contractSize']\n            _exchange_info[KRAKEN_FUTURES]['underlying'][normalized] = entry['underlying']\n            _exchange_info[KRAKEN_FUTURES]['product_type'][normalized] = _kraken_futures_product_type[normalized[:2]]\n            ret[normalized] = entry['symbol']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('KRAKEN_FUTURES', why, {\"\": r})\n\n\ndef probit_symbols() -> Dict[str, str]:\n    # doc: https://docs-en.probit.com/reference-link/market\n    r = None\n    try:\n        r = requests.get('https://api.probit.com/api/exchange/v1/market')\n        return {entry['id']: entry['id'] for entry in r.json()['data']}\n    except Exception as why:\n        raise_failure_explanation('PROBIT', why, {\"\": r})\n\n\ndef coingecko_normalize_symbol(symbol: str) -> str:\n    # keep digits, letters and dots, replace others by space\n    symbol = ''.join(c if c.isalnum() or c in ('.', '+') else ' ' for c in symbol)\n    return coingecko_normalize(symbol.upper())\n\n\ndef coingecko_normalize_name(name: str) -> str:\n    # keep digits and letters, replace others by space (except when only composed by upper case letters, digits and dots)\n    if not all(c.isupper() or c.isdigit() or c == '.' for c in name):\n        name = ''.join(c if c.isalnum() else ' ' for c in name)\n    return coingecko_normalize(name)\n\n\ndef coingecko_normalize(sym: str) -> str:\n    sym = sym.strip()\n    # do not concatenate numbers => separate them with a dot\n    sym = list(sym)\n    if len(sym) > 4:\n        for i in range(2, len(sym) - 1):\n            if sym[i] == ' ' and sym[i - 1].isdigit() and sym[i + 1].isdigit():\n                sym[i] = '.'\n    sym = ''.join(sym)\n    # concatenate space-separated words => use CamelCase to distinguish the words\n    if ' ' in sym:\n        if sum(c.islower() for c in sym):  # if there is at least one lower case letter\n            sym = ' '.join(word[0].upper() + word[1:] for word in sym.split())  # Just capitalize initial letter of each word\n        else:  # CoinGecko may provide full upper-case as for \"THE STONE COIN\"\n            sym = string.capwords(sym)  # capwords converts \"THE STONE COIN\" to \"The Stone Coin\"\n        sym = sym.replace(' ', '')  # concatenate words\n    return sym\n\n\ndef is_name_short(coin: dict) -> bool:\n    \"\"\"return True if the coin name is enough short compared to the coin symbol.\"\"\"\n    return len(coin['name']) <= max(5, len(coin['symbol']) + 1)\n\n\ndef has_many_caps(name: str) -> bool:\n    \"\"\"return True if the symbol contains enough upper case letters, False if empty.\"\"\"\n    return str and sum(c.islower() for c in name) < (len(name) / 2)\n\n\ndef coingecko_normalize_all(coin: dict):\n    SYMBOL_TO_NORMALIZED = {'miota': 'IOTA'}\n    normalized = SYMBOL_TO_NORMALIZED.get(coin['symbol'])\n    if normalized:\n        coin['ns'] = coin['nn'] = normalized\n        return normalized\n\n    # ns = normalized symbol, nn = normalized name\n    coin['ns'] = coingecko_normalize_symbol(coin['symbol'])\n\n    ID_SUFFIX = '-bitcoin-token'\n    if coin['id'][-len(ID_SUFFIX):] == ID_SUFFIX:\n        coin['nn'] = 'BTC' + coin['ns']\n        return coin['nn']\n\n    name = coin['name']\n\n    prefixes = ('The ', 'the ')\n    for p in prefixes:\n        if name[:len(p)] == p:\n            coin['reduced-name'] = True\n            name = name[len(p):]\n            break\n\n    suffixes = ('coin', 'coins', 'money', 'finance', 'protocol', 'reward', 'rewards', 'token')\n    for s in suffixes:\n        if len(name) > len(s) and name[-len(s):].lower() == s:\n            # but keep suffix when lower-case concatenated\n            if name[-len(s)].islower() and name[-len(s) - 1] != ' ':\n                continue\n            # also keep suffix to avoid confusing nam: \"Bitcoin Token\" -> \"Bitcoin\"\n            if name[:-len(s)].strip().lower() == 'bitcoin':\n                continue\n            coin['reduced-name'] = True\n            name = name[:-len(s)]\n            break\n\n    coin['nn'] = coingecko_normalize_name(name)\n\n    if len(coin['nn']) < len(coin['ns']):\n        if 'reduced-name' in coin:\n            coin['reduced-name'] = False\n            name = coin['name']\n            coin['nn'] = coingecko_normalize_name(name)\n        elif not has_many_caps(name):\n            return coin['ns']\n\n    if not coin['ns']:  # coin['symbol'] may be an emoji that is striped when normalized\n        return coin['nn']\n\n    if coin.get('reduced-name') and coin['ns'].upper() != coin['nn'].upper():\n        return coin['ns']\n\n    i = coin['nn'].find('.')  # if there is a dot in normalized name => prefer the normalized symbol\n    if i >= 0:\n        if i > 1 and coin['nn'][i - 1].isdigit() and coin['nn'][i + 1].isdigit():\n            pass  # except when the dot separates digits\n        else:\n            return coin['ns']\n\n    if is_name_short(coin) and has_many_caps(name):\n        return coin['nn']\n\n    if 1.5 * len(coin['ns']) > len(coin['nn']) and any(c.islower() for c in coin['ns']):\n        return coin['nn']\n\n    return coin['ns']\n\n\ndef coingecko_symbols() -> Dict[str, str]:\n    r = None\n    intermediate = defaultdict(list)\n    try:\n        r = requests.get('https://api.coingecko.com/api/v3/coins/list')\n        all_coins = r.json()\n        # First pass: generate & compare normalized symbol/name, and then select the most pertinent\n        for coin in all_coins:\n            normalized = coingecko_normalize_all(coin)\n            intermediate[normalized].append(coin)\n            # Above line keeps together the coins having the same normalized symbol.\n            # To reduce collision, the coin['name'] is sometimes used in lieu of the coin['symbol'].\n            # The coin['name'] is not capitalized because lower case letters may be meaningful: cETH, yUSD, DATx, zLOT\n    except Exception as why:\n        raise_failure_explanation('COINGECKO', why, {\"\": r})\n\n    final = coingecko_second_pass(intermediate)\n    return coingecko_third_pass(final)\n\n\ndef coingecko_second_pass(intermediate: Dict[str, List[dict]]) -> Dict[str, List[dict]]:\n    # Second pass: fixes most of the symbol collisions\n    final = defaultdict(list)\n    for normalized, coins in intermediate.items():\n        if len(coins) == 1:\n            final[normalized].append(coins[0])\n            continue\n        set_normalized = False\n        for i in range(len(coins)):\n            if normalized == coins[i]['nn']:\n                coin = coins.pop(i)\n                final[normalized].append(coin)\n                set_normalized = True\n                break\n        rest: List[dict] = []\n        for coin in coins:\n            if '%' in coin['name']:\n                if len(coins) == 1:\n                    n = coin['ns']\n                else:\n                    n = coingecko_normalize_name(coin['id'])\n                final[n].append(coin)\n            else:\n                rest.append(coin)\n        if not rest:\n            continue\n        if not set_normalized:\n            rest.sort(key=lambda coin: len(coin['nn']), reverse=True)  # sort by the length of the normalized name\n            coin = rest.pop(0)\n            final[normalized].append(coin)\n        for coin in rest:\n            if coin['nn'] not in intermediate:\n                n = coin['nn']\n            elif coin.get('reduced-name'):\n                n = coingecko_normalize_name(coin['name'])\n            else:\n                n = coingecko_normalize_name(coin['id'])\n            final[n].append(coin)\n    return final\n\n\ndef coingecko_third_pass(final: Dict[str, List[dict]]) -> Dict[str, str]:\n    # Third pass: fixes some remaining collisions and fills the result\n    symbols = {}\n    for normalized, coins in final.items():\n        if len(coins) == 1:\n            symbols[normalized] = coins[0]['id']\n            continue\n        set_normalized = False\n        for i in range(len(coins)):\n            if normalized == coins[i]['nn']:\n                coin = coins.pop(i)\n                symbols[normalized] = coin['id']\n                set_normalized = True\n                break\n        rest: List[dict] = []\n        for coin in coins:\n            if '%' in coin['name']:\n                if len(coins) == 1:\n                    n = coin['ns']\n                else:\n                    n = coingecko_normalize_name(coin['id'])\n                symbols[n] = coin['id']\n            else:\n                rest.append(coin)\n        if not rest:\n            continue\n        if not set_normalized:\n            rest.sort(key=lambda coin: len(coin['nn']), reverse=True)  # sort by the length of the normalized name\n            coin = rest.pop(0)\n            symbols[normalized] = coin['id']\n        for coin in rest:\n            if coin['nn'] not in final:\n                n = coin['nn']\n            elif coin.get('reduced-name'):\n                n = coingecko_normalize_name(coin['name'])\n            else:\n                n = coingecko_normalize_name(coin['id'])\n            symbols[n] = coin['id']\n    return symbols\n\n\ndef whale_alert_coins(key_id: str) -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get(f'https://api.whale-alert.io/v1/status?api_key={key_id}')\n        # Same symbols, but on different blockchains (for instance USDT), are naturally overwritten.\n        return {s.upper(): s for b in r.json()['blockchains'] for s in b['symbols'] if s}\n    except Exception as why:\n        raise_failure_explanation('WHALES_ALERT', why, {\"\": r})\n\n\n_exchange_function_map = {\n    BITFINEX: bitfinex_symbols,\n    BITFLYER: bitflyer_symbols,\n    COINBASE: coinbase_symbols,\n    GEMINI: gemini_symbols,\n    HITBTC: hitbtc_symbols,\n    POLONIEX: poloniex_symbols,\n    PROBIT: probit_symbols,\n    BITSTAMP: bitstamp_symbols,\n    KRAKEN: kraken_symbols,\n    KRAKEN + 'REST': kraken_rest_symbols,\n    BINANCE: binance_symbols,\n    BINANCE_US: binance_us_symbols,\n    BINANCE_FUTURES: binance_futures_symbols,\n    BINANCE_DELIVERY: binance_delivery_symbols,\n    BLOCKCHAIN: blockchain_symbols,\n    EXX: exx_symbols,\n    HUOBI: huobi_symbols,\n    HUOBI_DM: huobi_dm_symbols,\n    HUOBI_SWAP: huobi_swap_symbols,\n    OKCOIN: okcoin_symbols,\n    OKEX: okex_symbols,\n    BYBIT: bybit_symbols,\n    FTX: ftx_symbols,\n    FTX_US: ftx_us_symbols,\n    BITTREX: bittrex_symbols,\n    BITCOINCOM: bitcoincom_symbols,\n    BITMAX: bitmax_symbols,\n    UPBIT: upbit_symbols,\n    GATEIO: gateio_symbols,\n    BITMEX: bitmex_symbols,\n    DERIBIT: deribit_symbols,\n    KRAKEN_FUTURES: kraken_future_symbols,\n    COINGECKO: coingecko_symbols,\n    WHALE_ALERT: whale_alert_coins\n}\n",
        "source_code_len": 30534,
        "target_code": "associated with this software.\n'''\nfrom typing import Dict, Tuple\n\n\nclass _Symbols:\n    def __init__(self):\n        self.data = {}\n\n    def set(self, exchange: str, normalized: dict, exchange_info: dict):\n        self.data[exchange] = {}\n        self.data[exchange]['normalized'] = normalized\n        self.data[exchange]['info'] = exchange_info\n\n    def get(self, exchange: str) -> Tuple[Dict, Dict]:\n        return self.data[exchange]['normalized'], self.data[exchange]['info']\n\n    def populated(self, exchange: str) -> bool:\n        return exchange in self.data\n\n\nSymbols = _Symbols()\n",
        "target_code_len": 588,
        "diff_format": "@@ -5,845 +5,22 @@\n associated with this software.\n+'''\n+from typing import Dict, Tuple\n \n \n-Symbol generation code for exchanges\n-'''\n+class _Symbols:\n+    def __init__(self):\n+        self.data = {}\n \n-import logging\n-import string\n-import time\n-from collections import defaultdict\n-from typing import Dict, List, Optional, Tuple\n+    def set(self, exchange: str, normalized: dict, exchange_info: dict):\n+        self.data[exchange] = {}\n+        self.data[exchange]['normalized'] = normalized\n+        self.data[exchange]['info'] = exchange_info\n \n-import requests\n-from requests import Response\n+    def get(self, exchange: str) -> Tuple[Dict, Dict]:\n+        return self.data[exchange]['normalized'], self.data[exchange]['info']\n \n-from cryptofeed.defines import *\n+    def populated(self, exchange: str) -> bool:\n+        return exchange in self.data\n \n \n-LOG = logging.getLogger('feedhandler')\n-\n-SYMBOL_SEP = '-'\n-\n-_symbols_retrieval_cache: Dict[str, Dict[str, str]] = {}\n-_exchange_info = defaultdict(lambda: defaultdict(dict))\n-\n-\n-_kraken_futures_product_type = {\n-    'FI': 'Inverse Futures',\n-    'FV': 'Vanilla Futures',\n-    'PI': 'Perpetual Inverse Futures',\n-    'PV': 'Perpetual Vanilla Futures',\n-    'IN': 'Real Time Index',\n-    'RR': 'Reference Rate',\n-}\n-\n-\n-def raise_failure_explanation(feed_id: str, exception: BaseException, responses: Dict[str, Optional[Response]]):\n-    LOG.critical('%s: encountered %r while processing response from exchange API', feed_id, exception)\n-    if len(responses) > 1:\n-        LOG.critical('%s: content of one of the %s responses was unexpected', feed_id, len(responses))\n-    for url, r in responses.items():\n-        if url:\n-            LOG.critical('%s: requested URL: %s', feed_id, url)\n-        if r:\n-            LOG.critical('%s: unexpected response: %s', feed_id, r.text)\n-    raise ValueError(f'Cryptofeed stopped because of an unexpected response from {feed_id}') from exception\n-\n-\n-def set_symbol_separator(separator: str):\n-    global SYMBOL_SEP\n-    SYMBOL_SEP = separator\n-\n-\n-def get_symbol_separator() -> str:\n-    global SYMBOL_SEP\n-    return SYMBOL_SEP\n-\n-\n-def gen_symbols(exchange: str, key_id=None) -> Dict[str, str]:\n-    if exchange not in _symbols_retrieval_cache:\n-        LOG.info(\"%s: Getting list of symbols\", exchange)\n-        symbols = _exchange_function_map[exchange](key_id) if key_id else _exchange_function_map[exchange]()\n-        LOG.info(\"%s: %s symbols\", exchange, len(symbols))\n-\n-        # log all retrieved symbols using debug level\n-        for normalized, exch_sym in sorted(symbols.items()):\n-            LOG.debug('%s: id-from-exch -> normalized: %-35s-> %s', exchange, exch_sym, normalized)\n-\n-        _symbols_retrieval_cache[exchange] = symbols\n-    return _symbols_retrieval_cache[exchange]\n-\n-\n-def _binance_symbols(endpoint: str, exchange: str):\n-    r = None\n-    try:\n-        ret = {}\n-        r = requests.get(endpoint)\n-        for symbol in r.json()['symbols']:\n-            if symbol.get('status', 'TRADING') != \"TRADING\":\n-                continue\n-            if symbol.get('contractStatus', 'TRADING') != \"TRADING\":\n-                continue\n-            split = len(symbol['baseAsset'])\n-            normalized = symbol['symbol'][:split] + SYMBOL_SEP + symbol['symbol'][split:]\n-            ret[normalized] = symbol['symbol']\n-            _exchange_info[exchange]['tick_size'][normalized] = symbol['filters'][0]['tickSize']\n-            if \"contractType\" in symbol:\n-                _exchange_info[exchange]['contract_type'][normalized] = symbol['contractType']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation(exchange, why, {endpoint: r})\n-\n-\n-def binance_symbols() -> Dict[str, str]:\n-    return _binance_symbols('https://api.binance.com/api/v3/exchangeInfo', BINANCE)\n-\n-\n-def binance_us_symbols() -> Dict[str, str]:\n-    return _binance_symbols('https://api.binance.us/api/v3/exchangeInfo', BINANCE_US)\n-\n-\n-def binance_futures_symbols() -> Dict[str, str]:\n-    base = _binance_symbols('https://fapi.binance.com/fapi/v1/exchangeInfo', BINANCE_FUTURES)\n-    add = {}\n-    for symbol, orig in base.items():\n-        if \"_\" in orig:\n-            continue\n-        add[f\"{symbol}-PINDEX\"] = f\"p{orig}\"\n-    base.update(add)\n-    return base\n-\n-\n-def binance_delivery_symbols() -> Dict[str, str]:\n-    return _binance_symbols('https://dapi.binance.com/dapi/v1/exchangeInfo', BINANCE_DELIVERY)\n-\n-\n-def bitfinex_symbols() -> Dict[str, str]:\n-    # doc: https://docs.bitfinex.com/docs/ws-general#supported-pairs\n-    r1 = r2 = None\n-    try:\n-        r1 = requests.get('https://api.bitfinex.com/v2/tickers?symbols=ALL')\n-        r2 = requests.get('https://api-pub.bitfinex.com/v2/conf/pub:map:currency:sym')\n-        tickers: List[List[str]] = r1.json()\n-        norm: List[Tuple[str, str]] = r2.json()[0]\n-        norm: Dict[str, str] = dict(norm)\n-        for k, v in dict(norm).items():\n-            if k[-2:] == 'F0' or '-' in v:  # Do not convert BTCF0 -> BTC or PBTCETH -> PBTC-ETH\n-                del norm[k]\n-        norm['BCHN'] = 'BCH'  # Bitfinex uses BCHN, other exchanges use BCH\n-\n-        ret = {}\n-        for symbol in [t[0] for t in tickers]:\n-            if symbol[0] == 'f':\n-                normalized = norm.get(symbol[1:], symbol[1:])\n-            else:\n-                if len(symbol) == 7:\n-                    base, quote = symbol[1:4], symbol[4:]\n-                else:\n-                    base, quote = symbol[1:].split(':')\n-                    assert ':' in symbol\n-                normalized = norm.get(base, base) + SYMBOL_SEP + norm.get(quote, quote)\n-            ret[normalized.upper()] = symbol\n-        return ret\n-    except ValueError as why:\n-        raise_failure_explanation('BITFINEX', why, {\"tickers?symbols=ALL\": r1, \"pub:map:currency:sym\": r2})\n-\n-\n-def bitflyer_symbols() -> Dict[str, str]:\n-    endpoint = r = None\n-    try:\n-        ret = {}\n-        endpoints = ['https://api.bitflyer.com/v1/getmarkets/eu', 'https://api.bitflyer.com/v1/getmarkets/usa', 'https://api.bitflyer.com/v1/getmarkets']\n-        for endpoint in endpoints:\n-            r = requests.get(endpoint)\n-            for entry in r.json():\n-                normalized = entry['product_code'].replace(\"_\", SYMBOL_SEP)\n-                ret[normalized] = entry['product_code']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('BITFLYER', why, {endpoint: r})\n-\n-\n-def bybit_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.bybit.com/v2/public/symbols')\n-        ret = {}\n-        for symbol in r.json()['result']:\n-            quote = symbol['quote_currency']\n-            if not symbol['name'].endswith(quote):\n-                base, contract = symbol['name'].split(quote)\n-                normalized = f\"{base}{SYMBOL_SEP}{quote}-{contract}\"\n-            else:\n-                normalized = f\"{symbol['base_currency']}{SYMBOL_SEP}{quote}\"\n-            ret[normalized] = symbol['name']\n-            _exchange_info[BYBIT]['tick_size'][normalized] = symbol['price_filter']['tick_size']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('BYBIT', why, {\"\": r})\n-\n-\n-def _ftx_helper(endpoint: str, exchange: str):\n-    r = None\n-    try:\n-        r = requests.get(endpoint)\n-        ret = {}\n-        for data in r.json()['result']:\n-            normalized = data['name'].replace(\"/\", SYMBOL_SEP)\n-            symbol = data['name']\n-            ret[normalized] = symbol\n-            _exchange_info[exchange]['tick_size'][normalized] = data['priceIncrement']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation(exchange, why, {endpoint: r})\n-\n-\n-def ftx_symbols() -> Dict[str, str]:\n-    return _ftx_helper('https://ftx.com/api/markets', FTX)\n-\n-\n-def ftx_us_symbols() -> Dict[str, str]:\n-    return _ftx_helper('https://ftx.us/api/markets', FTX_US)\n-\n-\n-def coinbase_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.pro.coinbase.com/products')\n-        ret = {}\n-        for data in r.json():\n-            normalized = data['id'].replace(\"-\", SYMBOL_SEP)\n-            ret[normalized] = data['id']\n-            _exchange_info[COINBASE]['tick_size'][normalized] = data['quote_increment']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('COINBASE', why, {\"\": r})\n-\n-\n-def gemini_symbols(*args) -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.gemini.com/v1/symbols')\n-        ret = {}\n-        for symbol in r.json():\n-            std = f\"{symbol[:-3]}{SYMBOL_SEP}{symbol[-3:]}\"\n-            std = std.upper()\n-            ret[std] = symbol.upper()\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('GEMINI', why, {\"\": r})\n-\n-\n-def hitbtc_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        ret = {}\n-        r = requests.get('https://api.hitbtc.com/api/2/public/symbol')\n-        for symbol in r.json():\n-            split = len(symbol['baseCurrency'])\n-            normalized = symbol['id'][:split] + SYMBOL_SEP + symbol['id'][split:]\n-            ret[normalized] = symbol['id']\n-            _exchange_info[HITBTC]['tick_size'][normalized] = symbol['tickSize']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('HITBTC', why, {\"\": r})\n-\n-\n-def poloniex_id_symbol_mapping():\n-    r = None\n-    try:\n-        r = requests.get('https://poloniex.com/public?command=returnTicker')\n-        symbols = r.json()\n-        ret = {}\n-        for symbol in symbols:\n-            ret[symbols[symbol]['id']] = symbol\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('POLONIEX', why, {\"\": r})\n-\n-\n-def poloniex_symbols() -> Dict[str, str]:\n-    ret = {}\n-    for _, value in poloniex_id_symbol_mapping().items():\n-        std = value.replace(\"STR\", \"XLM\")\n-        quote, base = std.split(\"_\")\n-        ret[quote + SYMBOL_SEP + base] = value\n-    return ret\n-\n-\n-def bitstamp_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://www.bitstamp.net/api/v2/trading-pairs-info/')\n-        ret = {}\n-        for data in r.json():\n-            normalized = data['name'].replace(\"/\", SYMBOL_SEP)\n-            symbol = data['url_symbol']\n-            ret[normalized] = symbol\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('BITSTAMP', why, {\"\": r})\n-\n-\n-def kraken_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.kraken.com/0/public/AssetPairs')\n-        data = r.json()\n-        ret = {}\n-        for symbol in data['result']:\n-            if 'wsname' not in data['result'][symbol] or '.d' in symbol:\n-                # https://blog.kraken.com/post/259/introducing-the-kraken-dark-pool/\n-                # .d is for dark pool symbols\n-                continue\n-\n-            base, quote = data['result'][symbol]['wsname'].split(\"/\")\n-\n-            normalized = f\"{base}{SYMBOL_SEP}{quote}\"\n-            exch = data['result'][symbol]['wsname']\n-            normalized = normalized.replace('XBT', 'BTC')\n-            normalized = normalized.replace('XDG', 'DOG')\n-            ret[normalized] = exch\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('KRAKEN', why, {\"\": r})\n-\n-\n-def kraken_rest_symbols() -> Dict[str, str]:\n-    return {normalized: exchange.replace(\"/\", \"\") for normalized, exchange in kraken_symbols().items()}\n-\n-\n-def exx_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.exx.com/data/v1/tickers')\n-        exchange = [key.upper() for key in r.json().keys()]\n-        symbols = [key.replace(\"_\", SYMBOL_SEP) for key in exchange]\n-        return dict(zip(symbols, exchange))\n-    except Exception as why:\n-        raise_failure_explanation('EXX', why, {\"\": r})\n-\n-\n-def huobi_common_symbols(url: str):\n-    r = None\n-    try:\n-        r = requests.get(url)\n-        ret = {}\n-        for e in r.json()['data']:\n-            if e['state'] == 'offline':\n-                continue\n-            normalized = f\"{e['base-currency'].upper()}{SYMBOL_SEP}{e['quote-currency'].upper()}\"\n-            symbol = f\"{e['base-currency']}{e['quote-currency']}\"\n-            ret[normalized] = symbol\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('HUOBI', why, {url: r})\n-\n-\n-def huobi_symbols() -> Dict[str, str]:\n-    return huobi_common_symbols('https://api.huobi.pro/v1/common/symbols')\n-\n-\n-def huobi_us_symbols() -> Dict[str, str]:\n-    return huobi_common_symbols('https://api.huobi.com/v1/common/symbols')\n-\n-\n-def huobi_dm_symbols() -> Dict[str, str]:\n-    \"\"\"\n-    Mapping is, for instance: {\"BTC_CW\":\"BTC190816\"}\n-    See comments in exchange/huobi_dm.py\n-    \"\"\"\n-    mapping = {\n-        \"this_week\": \"CW\",\n-        \"next_week\": \"NW\",\n-        \"quarter\": \"CQ\",\n-        \"next_quarter\": \"NQ\"\n-    }\n-    r = None\n-    try:\n-        r = requests.get('https://www.hbdm.com/api/v1/contract_contract_info')\n-        symbols = {}\n-        for e in r.json()['data']:\n-            symbols[f\"{e['symbol']}_{mapping[e['contract_type']]}\"] = e['contract_code']\n-            _exchange_info[HUOBI_DM]['tick_size'][e['contract_code']] = e['price_tick']\n-            _exchange_info[HUOBI_DM]['short_code_mappings'][f\"{e['symbol']}_{mapping[e['contract_type']]}\"] = e['contract_code']\n-        return symbols\n-    except Exception as why:\n-        raise_failure_explanation('HUOBI_DM', why, {\"\": r})\n-\n-\n-def huobi_swap_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.hbdm.com/swap-api/v1/swap_contract_info')\n-        symbols = {}\n-        for e in r.json()['data']:\n-            symbols[e['contract_code']] = e['contract_code']\n-            _exchange_info[HUOBI_SWAP]['tick_size'][e['contract_code']] = e['price_tick']\n-        return symbols\n-    except Exception as why:\n-        raise_failure_explanation('HUOBI_SWAP', why, {\"\": r})\n-\n-\n-def okcoin_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://www.okcoin.com/api/spot/v3/instruments')\n-        ret = {}\n-        for e in r.json():\n-            ret[e['instrument_id']] = e['instrument_id']\n-            _exchange_info[OKCOIN]['tick_size'][e['instrument_id']] = e['tick_size']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('OKCOIN', why, {\"\": r})\n-\n-\n-def okex_symbols(*args) -> Dict[str, str]:\n-    urls = ['https://www.okex.com/api/spot/v3/instruments',\n-            'https://www.okex.com/api/swap/v3/instruments',\n-            'https://www.okex.com/api/futures/v3/instruments']\n-    urls = urls + okex_compute_option_urls_from_underlyings()\n-\n-    symbols: Dict[str, str] = {}\n-    for u in urls:\n-        time.sleep(0.2)\n-        symbols.update(okex_symbols_from_one_url(u))\n-\n-    for symbol in symbols:\n-        instrument_type = 'futures'\n-        dash_count = symbol.count(get_symbol_separator())\n-        if dash_count == 1:  # BTC-USDT\n-            instrument_type = 'spot'\n-        if dash_count == 4:  # BTC-USD-201225-35000-P\n-            instrument_type = 'option'\n-        if symbol[-4:] == \"SWAP\":  # BTC-USDT-SWAP\n-            instrument_type = 'swap'\n-\n-        _exchange_info[OKEX]['instrument_type'][symbol] = instrument_type\n-\n-    return symbols\n-\n-\n-def okex_compute_option_urls_from_underlyings() -> List[str]:\n-    url = 'https://www.okex.com/api/option/v3/underlying'\n-    r = None\n-    try:\n-        r = requests.get(url)\n-        return [f'https://www.okex.com/api/option/v3/instruments/{underlying}' for underlying in r.json()]\n-    except Exception as why:\n-        raise_failure_explanation('OKEX', why, {url: r})\n-\n-\n-def okex_symbols_from_one_url(url: str) -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get(url)\n-        ret = {}\n-        for e in r.json():\n-            ret[e['instrument_id']] = e['instrument_id']\n-            _exchange_info[OKEX]['tick_size'][e['instrument_id']] = e['tick_size']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('OKEX', why, {url: r})\n-\n-\n-def bittrex_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.bittrex.com/api/v1.1/public/getmarkets')\n-        r = r.json()['result']\n-        return {f\"{e['MarketCurrency']}{SYMBOL_SEP}{e['BaseCurrency']}\": e['MarketName'] for e in r if e['IsActive']}\n-    except Exception as why:\n-        raise_failure_explanation('BITTREX', why, {\"\": r})\n-\n-\n-def bitcoincom_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.exchange.bitcoin.com/api/2/public/symbol')\n-        return {f\"{data['baseCurrency']}{SYMBOL_SEP}{data['quoteCurrency'].replace('USD', 'USDT')}\": data['id'] for data in r.json()}\n-    except Exception as why:\n-        raise_failure_explanation('BITCOINCOM', why, {\"\": r})\n-\n-\n-def bitmax_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://bitmax.io/api/pro/v1/products')\n-        ret = {}\n-        for entry in r.json()['data']:\n-            # Only \"Normal\" status symbols are tradeable\n-            if entry['status'] == 'Normal':\n-                normalized = f\"{entry['baseAsset']}{SYMBOL_SEP}{entry['quoteAsset']}\"\n-                ret[normalized] = entry['symbol']\n-                _exchange_info[BITMAX]['tick_size'][normalized] = entry['tickSize']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('BITMAX', why, {\"\": r})\n-\n-\n-def upbit_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.upbit.com/v1/market/all')\n-        return {f\"{data['market'].split('-')[1]}{SYMBOL_SEP}{data['market'].split('-')[0]}\": data['market'] for data in r.json()}\n-    except Exception as why:\n-        raise_failure_explanation('UPBIT', why, {\"\": r})\n-\n-\n-def blockchain_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get(\"https://api.blockchain.com/mercury-gateway/v1/instruments\")\n-        return {data[\"symbol\"].replace(\"-\", SYMBOL_SEP): data[\"symbol\"] for data in r.json()}\n-    except Exception as why:\n-        raise_failure_explanation('BLOCKCHAIN', why, {\"\": r})\n-\n-\n-def gateio_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get(\"https://api.gateio.ws/api/v4/spot/currency_pairs\")\n-        return {data[\"id\"].replace(\"_\", SYMBOL_SEP): data['id'] for data in r.json()}\n-    except Exception as why:\n-        raise_failure_explanation('GATEIO', why, {\"\": r})\n-\n-\n-def bitmex_symbols() -> Dict[str, str]:\n-    r = None\n-    ret = {}\n-    try:\n-        r = requests.get(\"https://www.bitmex.com/api/v1/instrument/active\")\n-        for entry in r.json():\n-            components = []\n-            components.append(entry['rootSymbol'])\n-            components.append(entry['quoteCurrency'])\n-\n-            if entry['expiry']:\n-                components.append(entry['symbol'][-3:])\n-\n-            normalized = SYMBOL_SEP.join(components)\n-            normalized = normalized.replace(\"XBT\", \"BTC\")\n-            ret[normalized] = entry['symbol']\n-            _exchange_info[BITMEX]['tick_size'][normalized] = entry['tickSize']\n-\n-            if entry['expiry']:\n-                _exchange_info[BITMEX]['expiry'][normalized] = entry['expiry']\n-\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('BITMEX', why, {\"\": r})\n-\n-\n-def deribit_symbols() -> Dict[str, str]:\n-    url = r = None\n-    ret = {}\n-    try:\n-        # TODO: get currencies from https://www.deribit.com/api/v2/public/get_currencies\n-        currencies = ['BTC', 'ETH']\n-        for c in currencies:\n-            url = f\"https://www.deribit.com/api/v2/public/get_instruments?currency={c}&expired=false\"\n-            r = requests.get(url)\n-            for entry in r.json()['result']:\n-                split = entry['instrument_name'].split(\"-\")\n-                normalized = split[0] + SYMBOL_SEP + entry['quote_currency'] + \"-\" + '-'.join(split[1:])\n-                ret[normalized] = entry['instrument_name']\n-                _exchange_info[DERIBIT]['tick_size'][normalized] = entry['tick_size']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('DERIBIT', why, {url: r})\n-\n-\n-def kraken_future_symbols() -> Dict[str, str]:\n-    r = None\n-    ret = {}\n-    try:\n-        r = requests.get('https://futures.kraken.com/derivatives/api/v3/instruments')\n-        data = r.json()['instruments']\n-        for entry in data:\n-            if not entry['tradeable']:\n-                continue\n-            normalized = entry['symbol'].upper().replace(\"_\", \"-\")\n-            symbol = normalized[3:6] + SYMBOL_SEP + normalized[6:9]\n-            normalized = normalized.replace(normalized[3:9], symbol)\n-            normalized = normalized.replace('XBT', 'BTC')\n-\n-            _exchange_info[KRAKEN_FUTURES]['tick_size'][normalized] = entry['tickSize']\n-            _exchange_info[KRAKEN_FUTURES]['contract_size'][normalized] = entry['contractSize']\n-            _exchange_info[KRAKEN_FUTURES]['underlying'][normalized] = entry['underlying']\n-            _exchange_info[KRAKEN_FUTURES]['product_type'][normalized] = _kraken_futures_product_type[normalized[:2]]\n-            ret[normalized] = entry['symbol']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('KRAKEN_FUTURES', why, {\"\": r})\n-\n-\n-def probit_symbols() -> Dict[str, str]:\n-    # doc: https://docs-en.probit.com/reference-link/market\n-    r = None\n-    try:\n-        r = requests.get('https://api.probit.com/api/exchange/v1/market')\n-        return {entry['id']: entry['id'] for entry in r.json()['data']}\n-    except Exception as why:\n-        raise_failure_explanation('PROBIT', why, {\"\": r})\n-\n-\n-def coingecko_normalize_symbol(symbol: str) -> str:\n-    # keep digits, letters and dots, replace others by space\n-    symbol = ''.join(c if c.isalnum() or c in ('.', '+') else ' ' for c in symbol)\n-    return coingecko_normalize(symbol.upper())\n-\n-\n-def coingecko_normalize_name(name: str) -> str:\n-    # keep digits and letters, replace others by space (except when only composed by upper case letters, digits and dots)\n-    if not all(c.isupper() or c.isdigit() or c == '.' for c in name):\n-        name = ''.join(c if c.isalnum() else ' ' for c in name)\n-    return coingecko_normalize(name)\n-\n-\n-def coingecko_normalize(sym: str) -> str:\n-    sym = sym.strip()\n-    # do not concatenate numbers => separate them with a dot\n-    sym = list(sym)\n-    if len(sym) > 4:\n-        for i in range(2, len(sym) - 1):\n-            if sym[i] == ' ' and sym[i - 1].isdigit() and sym[i + 1].isdigit():\n-                sym[i] = '.'\n-    sym = ''.join(sym)\n-    # concatenate space-separated words => use CamelCase to distinguish the words\n-    if ' ' in sym:\n-        if sum(c.islower() for c in sym):  # if there is at least one lower case letter\n-            sym = ' '.join(word[0].upper() + word[1:] for word in sym.split())  # Just capitalize initial letter of each word\n-        else:  # CoinGecko may provide full upper-case as for \"THE STONE COIN\"\n-            sym = string.capwords(sym)  # capwords converts \"THE STONE COIN\" to \"The Stone Coin\"\n-        sym = sym.replace(' ', '')  # concatenate words\n-    return sym\n-\n-\n-def is_name_short(coin: dict) -> bool:\n-    \"\"\"return True if the coin name is enough short compared to the coin symbol.\"\"\"\n-    return len(coin['name']) <= max(5, len(coin['symbol']) + 1)\n-\n-\n-def has_many_caps(name: str) -> bool:\n-    \"\"\"return True if the symbol contains enough upper case letters, False if empty.\"\"\"\n-    return str and sum(c.islower() for c in name) < (len(name) / 2)\n-\n-\n-def coingecko_normalize_all(coin: dict):\n-    SYMBOL_TO_NORMALIZED = {'miota': 'IOTA'}\n-    normalized = SYMBOL_TO_NORMALIZED.get(coin['symbol'])\n-    if normalized:\n-        coin['ns'] = coin['nn'] = normalized\n-        return normalized\n-\n-    # ns = normalized symbol, nn = normalized name\n-    coin['ns'] = coingecko_normalize_symbol(coin['symbol'])\n-\n-    ID_SUFFIX = '-bitcoin-token'\n-    if coin['id'][-len(ID_SUFFIX):] == ID_SUFFIX:\n-        coin['nn'] = 'BTC' + coin['ns']\n-        return coin['nn']\n-\n-    name = coin['name']\n-\n-    prefixes = ('The ', 'the ')\n-    for p in prefixes:\n-        if name[:len(p)] == p:\n-            coin['reduced-name'] = True\n-            name = name[len(p):]\n-            break\n-\n-    suffixes = ('coin', 'coins', 'money', 'finance', 'protocol', 'reward', 'rewards', 'token')\n-    for s in suffixes:\n-        if len(name) > len(s) and name[-len(s):].lower() == s:\n-            # but keep suffix when lower-case concatenated\n-            if name[-len(s)].islower() and name[-len(s) - 1] != ' ':\n-                continue\n-            # also keep suffix to avoid confusing nam: \"Bitcoin Token\" -> \"Bitcoin\"\n-            if name[:-len(s)].strip().lower() == 'bitcoin':\n-                continue\n-            coin['reduced-name'] = True\n-            name = name[:-len(s)]\n-            break\n-\n-    coin['nn'] = coingecko_normalize_name(name)\n-\n-    if len(coin['nn']) < len(coin['ns']):\n-        if 'reduced-name' in coin:\n-            coin['reduced-name'] = False\n-            name = coin['name']\n-            coin['nn'] = coingecko_normalize_name(name)\n-        elif not has_many_caps(name):\n-            return coin['ns']\n-\n-    if not coin['ns']:  # coin['symbol'] may be an emoji that is striped when normalized\n-        return coin['nn']\n-\n-    if coin.get('reduced-name') and coin['ns'].upper() != coin['nn'].upper():\n-        return coin['ns']\n-\n-    i = coin['nn'].find('.')  # if there is a dot in normalized name => prefer the normalized symbol\n-    if i >= 0:\n-        if i > 1 and coin['nn'][i - 1].isdigit() and coin['nn'][i + 1].isdigit():\n-            pass  # except when the dot separates digits\n-        else:\n-            return coin['ns']\n-\n-    if is_name_short(coin) and has_many_caps(name):\n-        return coin['nn']\n-\n-    if 1.5 * len(coin['ns']) > len(coin['nn']) and any(c.islower() for c in coin['ns']):\n-        return coin['nn']\n-\n-    return coin['ns']\n-\n-\n-def coingecko_symbols() -> Dict[str, str]:\n-    r = None\n-    intermediate = defaultdict(list)\n-    try:\n-        r = requests.get('https://api.coingecko.com/api/v3/coins/list')\n-        all_coins = r.json()\n-        # First pass: generate & compare normalized symbol/name, and then select the most pertinent\n-        for coin in all_coins:\n-            normalized = coingecko_normalize_all(coin)\n-            intermediate[normalized].append(coin)\n-            # Above line keeps together the coins having the same normalized symbol.\n-            # To reduce collision, the coin['name'] is sometimes used in lieu of the coin['symbol'].\n-            # The coin['name'] is not capitalized because lower case letters may be meaningful: cETH, yUSD, DATx, zLOT\n-    except Exception as why:\n-        raise_failure_explanation('COINGECKO', why, {\"\": r})\n-\n-    final = coingecko_second_pass(intermediate)\n-    return coingecko_third_pass(final)\n-\n-\n-def coingecko_second_pass(intermediate: Dict[str, List[dict]]) -> Dict[str, List[dict]]:\n-    # Second pass: fixes most of the symbol collisions\n-    final = defaultdict(list)\n-    for normalized, coins in intermediate.items():\n-        if len(coins) == 1:\n-            final[normalized].append(coins[0])\n-            continue\n-        set_normalized = False\n-        for i in range(len(coins)):\n-            if normalized == coins[i]['nn']:\n-                coin = coins.pop(i)\n-                final[normalized].append(coin)\n-                set_normalized = True\n-                break\n-        rest: List[dict] = []\n-        for coin in coins:\n-            if '%' in coin['name']:\n-                if len(coins) == 1:\n-                    n = coin['ns']\n-                else:\n-                    n = coingecko_normalize_name(coin['id'])\n-                final[n].append(coin)\n-            else:\n-                rest.append(coin)\n-        if not rest:\n-            continue\n-        if not set_normalized:\n-            rest.sort(key=lambda coin: len(coin['nn']), reverse=True)  # sort by the length of the normalized name\n-            coin = rest.pop(0)\n-            final[normalized].append(coin)\n-        for coin in rest:\n-            if coin['nn'] not in intermediate:\n-                n = coin['nn']\n-            elif coin.get('reduced-name'):\n-                n = coingecko_normalize_name(coin['name'])\n-            else:\n-                n = coingecko_normalize_name(coin['id'])\n-            final[n].append(coin)\n-    return final\n-\n-\n-def coingecko_third_pass(final: Dict[str, List[dict]]) -> Dict[str, str]:\n-    # Third pass: fixes some remaining collisions and fills the result\n-    symbols = {}\n-    for normalized, coins in final.items():\n-        if len(coins) == 1:\n-            symbols[normalized] = coins[0]['id']\n-            continue\n-        set_normalized = False\n-        for i in range(len(coins)):\n-            if normalized == coins[i]['nn']:\n-                coin = coins.pop(i)\n-                symbols[normalized] = coin['id']\n-                set_normalized = True\n-                break\n-        rest: List[dict] = []\n-        for coin in coins:\n-            if '%' in coin['name']:\n-                if len(coins) == 1:\n-                    n = coin['ns']\n-                else:\n-                    n = coingecko_normalize_name(coin['id'])\n-                symbols[n] = coin['id']\n-            else:\n-                rest.append(coin)\n-        if not rest:\n-            continue\n-        if not set_normalized:\n-            rest.sort(key=lambda coin: len(coin['nn']), reverse=True)  # sort by the length of the normalized name\n-            coin = rest.pop(0)\n-            symbols[normalized] = coin['id']\n-        for coin in rest:\n-            if coin['nn'] not in final:\n-                n = coin['nn']\n-            elif coin.get('reduced-name'):\n-                n = coingecko_normalize_name(coin['name'])\n-            else:\n-                n = coingecko_normalize_name(coin['id'])\n-            symbols[n] = coin['id']\n-    return symbols\n-\n-\n-def whale_alert_coins(key_id: str) -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get(f'https://api.whale-alert.io/v1/status?api_key={key_id}')\n-        # Same symbols, but on different blockchains (for instance USDT), are naturally overwritten.\n-        return {s.upper(): s for b in r.json()['blockchains'] for s in b['symbols'] if s}\n-    except Exception as why:\n-        raise_failure_explanation('WHALES_ALERT', why, {\"\": r})\n-\n-\n-_exchange_function_map = {\n-    BITFINEX: bitfinex_symbols,\n-    BITFLYER: bitflyer_symbols,\n-    COINBASE: coinbase_symbols,\n-    GEMINI: gemini_symbols,\n-    HITBTC: hitbtc_symbols,\n-    POLONIEX: poloniex_symbols,\n-    PROBIT: probit_symbols,\n-    BITSTAMP: bitstamp_symbols,\n-    KRAKEN: kraken_symbols,\n-    KRAKEN + 'REST': kraken_rest_symbols,\n-    BINANCE: binance_symbols,\n-    BINANCE_US: binance_us_symbols,\n-    BINANCE_FUTURES: binance_futures_symbols,\n-    BINANCE_DELIVERY: binance_delivery_symbols,\n-    BLOCKCHAIN: blockchain_symbols,\n-    EXX: exx_symbols,\n-    HUOBI: huobi_symbols,\n-    HUOBI_DM: huobi_dm_symbols,\n-    HUOBI_SWAP: huobi_swap_symbols,\n-    OKCOIN: okcoin_symbols,\n-    OKEX: okex_symbols,\n-    BYBIT: bybit_symbols,\n-    FTX: ftx_symbols,\n-    FTX_US: ftx_us_symbols,\n-    BITTREX: bittrex_symbols,\n-    BITCOINCOM: bitcoincom_symbols,\n-    BITMAX: bitmax_symbols,\n-    UPBIT: upbit_symbols,\n-    GATEIO: gateio_symbols,\n-    BITMEX: bitmex_symbols,\n-    DERIBIT: deribit_symbols,\n-    KRAKEN_FUTURES: kraken_future_symbols,\n-    COINGECKO: coingecko_symbols,\n-    WHALE_ALERT: whale_alert_coins\n-}\n+Symbols = _Symbols()\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\n\nimport logging\nimport string\nimport time\nfrom collections import defaultdict\nfrom typing import Dict, List, Optional, Tuple\n\nimport requests\nfrom requests import Response\n\nfrom cryptofeed.defines import *\n\n\nLOG = logging.getLogger('feedhandler')\n\nSYMBOL_SEP = '-'\n\n_symbols_retrieval_cache: Dict[str, Dict[str, str]] = {}\n_exchange_info = defaultdict(lambda: defaultdict(dict))\n\n\n_kraken_futures_product_type = {\n    'FI': 'Inverse Futures',\n    'FV': 'Vanilla Futures',\n    'PI': 'Perpetual Inverse Futures',\n    'PV': 'Perpetual Vanilla Futures',\n    'IN': 'Real Time Index',\n    'RR': 'Reference Rate',\n}\n\n\ndef raise_failure_explanation(feed_id: str, exception: BaseException, responses: Dict[str, Optional[Response]]):\n    <IND>LOG.critical('%s: encountered %r while processing response from exchange API', feed_id, exception)\n    if len(responses) > 1:\n        <IND>LOG.critical('%s: content of one of the %s responses was unexpected', feed_id, len(responses))\n    <DED>for url, r in responses.items():\n        <IND>if url:\n            <IND>LOG.critical('%s: requested URL: %s', feed_id, url)\n        <DED>if r:\n            <IND>LOG.critical('%s: unexpected response: %s', feed_id, r.text)\n    <DED><DED>raise ValueError(f'Cryptofeed stopped because of an unexpected response from {feed_id}') from exception\n\n\n<DED>def set_symbol_separator(separator: str):\n    <IND>global SYMBOL_SEP\n    SYMBOL_SEP = separator\n\n\n<DED>def get_symbol_separator() -> str:\n    <IND>global SYMBOL_SEP\n    return SYMBOL_SEP\n\n\n<DED>def gen_symbols(exchange: str, key_id=None) -> Dict[str, str]:\n    <IND>if exchange not in _symbols_retrieval_cache:\n        <IND>LOG.info(\"%s: Getting list of symbols\", exchange)\n        symbols = _exchange_function_map[exchange](key_id) if key_id else _exchange_function_map[exchange]()\n        LOG.info(\"%s: %s symbols\", exchange, len(symbols))\n\n        # log all retrieved symbols using debug level\n        for normalized, exch_sym in sorted(symbols.items()):\n            <IND>LOG.debug('%s: id-from-exch -> normalized: %-35s-> %s', exchange, exch_sym, normalized)\n\n        <DED>_symbols_retrieval_cache[exchange] = symbols\n    <DED>return _symbols_retrieval_cache[exchange]\n\n\n<DED>def _binance_symbols(endpoint: str, exchange: str):\n    <IND>r = None\n    try:\n        <IND>ret = {}\n        r = requests.get(endpoint)\n        for symbol in r.json()['symbols']:\n            <IND>if symbol.get('status', 'TRADING') != \"TRADING\":\n                <IND>continue\n            <DED>if symbol.get('contractStatus', 'TRADING') != \"TRADING\":\n                <IND>continue\n            <DED>split = len(symbol['baseAsset'])\n            normalized = symbol['symbol'][:split] + SYMBOL_SEP + symbol['symbol'][split:]\n            ret[normalized] = symbol['symbol']\n            _exchange_info[exchange]['tick_size'][normalized] = symbol['filters'][0]['tickSize']\n            if \"contractType\" in symbol:\n                <IND>_exchange_info[exchange]['contract_type'][normalized] = symbol['contractType']\n        <DED><DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation(exchange, why, {endpoint: r})\n\n\n<DED><DED>def binance_symbols() -> Dict[str, str]:\n    <IND>return _binance_symbols('https://api.binance.com/api/v3/exchangeInfo', BINANCE)\n\n\n<DED>def binance_us_symbols() -> Dict[str, str]:\n    <IND>return _binance_symbols('https://api.binance.us/api/v3/exchangeInfo', BINANCE_US)\n\n\n<DED>def binance_futures_symbols() -> Dict[str, str]:\n    <IND>base = _binance_symbols('https://fapi.binance.com/fapi/v1/exchangeInfo', BINANCE_FUTURES)\n    add = {}\n    for symbol, orig in base.items():\n        <IND>if \"_\" in orig:\n            <IND>continue\n        <DED>add[f\"{symbol}-PINDEX\"] = f\"p{orig}\"\n    <DED>base.update(add)\n    return base\n\n\n<DED>def binance_delivery_symbols() -> Dict[str, str]:\n    <IND>return _binance_symbols('https://dapi.binance.com/dapi/v1/exchangeInfo', BINANCE_DELIVERY)\n\n\n<DED>def bitfinex_symbols() -> Dict[str, str]:\n    # doc: https://docs.bitfinex.com/docs/ws-general#supported-pairs\n    <IND>r1 = r2 = None\n    try:\n        <IND>r1 = requests.get('https://api.bitfinex.com/v2/tickers?symbols=ALL')\n        r2 = requests.get('https://api-pub.bitfinex.com/v2/conf/pub:map:currency:sym')\n        tickers: List[List[str]] = r1.json()\n        norm: List[Tuple[str, str]] = r2.json()[0]\n        norm: Dict[str, str] = dict(norm)\n        for k, v in dict(norm).items():\n            <IND>if k[-2:] == 'F0' or '-' in v:  # Do not convert BTCF0 -> BTC or PBTCETH -> PBTC-ETH\n                <IND>del norm[k]\n        <DED><DED>norm['BCHN'] = 'BCH'  # Bitfinex uses BCHN, other exchanges use BCH\n\n        ret = {}\n        for symbol in [t[0] for t in tickers]:\n            <IND>if symbol[0] == 'f':\n                <IND>normalized = norm.get(symbol[1:], symbol[1:])\n            <DED>else:\n                <IND>if len(symbol) == 7:\n                    <IND>base, quote = symbol[1:4], symbol[4:]\n                <DED>else:\n                    <IND>base, quote = symbol[1:].split(':')\n                    assert ':' in symbol\n                <DED>normalized = norm.get(base, base) + SYMBOL_SEP + norm.get(quote, quote)\n            <DED>ret[normalized.upper()] = symbol\n        <DED>return ret\n    <DED>except ValueError as why:\n        <IND>raise_failure_explanation('BITFINEX', why, {\"tickers?symbols=ALL\": r1, \"pub:map:currency:sym\": r2})\n\n\n<DED><DED>def bitflyer_symbols() -> Dict[str, str]:\n    <IND>endpoint = r = None\n    try:\n        <IND>ret = {}\n        endpoints = ['https://api.bitflyer.com/v1/getmarkets/eu', 'https://api.bitflyer.com/v1/getmarkets/usa', 'https://api.bitflyer.com/v1/getmarkets']\n        for endpoint in endpoints:\n            <IND>r = requests.get(endpoint)\n            for entry in r.json():\n                <IND>normalized = entry['product_code'].replace(\"_\", SYMBOL_SEP)\n                ret[normalized] = entry['product_code']\n        <DED><DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BITFLYER', why, {endpoint: r})\n\n\n<DED><DED>def bybit_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.bybit.com/v2/public/symbols')\n        ret = {}\n        for symbol in r.json()['result']:\n            <IND>quote = symbol['quote_currency']\n            if not symbol['name'].endswith(quote):\n                <IND>base, contract = symbol['name'].split(quote)\n                normalized = f\"{base}{SYMBOL_SEP}{quote}-{contract}\"\n            <DED>else:\n                <IND>normalized = f\"{symbol['base_currency']}{SYMBOL_SEP}{quote}\"\n            <DED>ret[normalized] = symbol['name']\n            _exchange_info[BYBIT]['tick_size'][normalized] = symbol['price_filter']['tick_size']\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BYBIT', why, {\"\": r})\n\n\n<DED><DED>def _ftx_helper(endpoint: str, exchange: str):\n    <IND>r = None\n    try:\n        <IND>r = requests.get(endpoint)\n        ret = {}\n        for data in r.json()['result']:\n            <IND>normalized = data['name'].replace(\"/\", SYMBOL_SEP)\n            symbol = data['name']\n            ret[normalized] = symbol\n            _exchange_info[exchange]['tick_size'][normalized] = data['priceIncrement']\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation(exchange, why, {endpoint: r})\n\n\n<DED><DED>def ftx_symbols() -> Dict[str, str]:\n    <IND>return _ftx_helper('https://ftx.com/api/markets', FTX)\n\n\n<DED>def ftx_us_symbols() -> Dict[str, str]:\n    <IND>return _ftx_helper('https://ftx.us/api/markets', FTX_US)\n\n\n<DED>def coinbase_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.pro.coinbase.com/products')\n        ret = {}\n        for data in r.json():\n            <IND>normalized = data['id'].replace(\"-\", SYMBOL_SEP)\n            ret[normalized] = data['id']\n            _exchange_info[COINBASE]['tick_size'][normalized] = data['quote_increment']\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('COINBASE', why, {\"\": r})\n\n\n<DED><DED>def gemini_symbols(*args) -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.gemini.com/v1/symbols')\n        ret = {}\n        for symbol in r.json():\n            <IND>std = f\"{symbol[:-3]}{SYMBOL_SEP}{symbol[-3:]}\"\n            std = std.upper()\n            ret[std] = symbol.upper()\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('GEMINI', why, {\"\": r})\n\n\n<DED><DED>def hitbtc_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>ret = {}\n        r = requests.get('https://api.hitbtc.com/api/2/public/symbol')\n        for symbol in r.json():\n            <IND>split = len(symbol['baseCurrency'])\n            normalized = symbol['id'][:split] + SYMBOL_SEP + symbol['id'][split:]\n            ret[normalized] = symbol['id']\n            _exchange_info[HITBTC]['tick_size'][normalized] = symbol['tickSize']\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('HITBTC', why, {\"\": r})\n\n\n<DED><DED>def poloniex_id_symbol_mapping():\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://poloniex.com/public?command=returnTicker')\n        symbols = r.json()\n        ret = {}\n        for symbol in symbols:\n            <IND>ret[symbols[symbol]['id']] = symbol\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('POLONIEX', why, {\"\": r})\n\n\n<DED><DED>def poloniex_symbols() -> Dict[str, str]:\n    <IND>ret = {}\n    for _, value in poloniex_id_symbol_mapping().items():\n        <IND>std = value.replace(\"STR\", \"XLM\")\n        quote, base = std.split(\"_\")\n        ret[quote + SYMBOL_SEP + base] = value\n    <DED>return ret\n\n\n<DED>def bitstamp_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://www.bitstamp.net/api/v2/trading-pairs-info/')\n        ret = {}\n        for data in r.json():\n            <IND>normalized = data['name'].replace(\"/\", SYMBOL_SEP)\n            symbol = data['url_symbol']\n            ret[normalized] = symbol\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BITSTAMP', why, {\"\": r})\n\n\n<DED><DED>def kraken_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.kraken.com/0/public/AssetPairs')\n        data = r.json()\n        ret = {}\n        for symbol in data['result']:\n            <IND>if 'wsname' not in data['result'][symbol] or '.d' in symbol:\n                # https://blog.kraken.com/post/259/introducing-the-kraken-dark-pool/\n                # .d is for dark pool symbols\n                <IND>continue\n\n            <DED>base, quote = data['result'][symbol]['wsname'].split(\"/\")\n\n            normalized = f\"{base}{SYMBOL_SEP}{quote}\"\n            exch = data['result'][symbol]['wsname']\n            normalized = normalized.replace('XBT', 'BTC')\n            normalized = normalized.replace('XDG', 'DOG')\n            ret[normalized] = exch\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('KRAKEN', why, {\"\": r})\n\n\n<DED><DED>def kraken_rest_symbols() -> Dict[str, str]:\n    <IND>return {normalized: exchange.replace(\"/\", \"\") for normalized, exchange in kraken_symbols().items()}\n\n\n<DED>def exx_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.exx.com/data/v1/tickers')\n        exchange = [key.upper() for key in r.json().keys()]\n        symbols = [key.replace(\"_\", SYMBOL_SEP) for key in exchange]\n        return dict(zip(symbols, exchange))\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('EXX', why, {\"\": r})\n\n\n<DED><DED>def huobi_common_symbols(url: str):\n    <IND>r = None\n    try:\n        <IND>r = requests.get(url)\n        ret = {}\n        for e in r.json()['data']:\n            <IND>if e['state'] == 'offline':\n                <IND>continue\n            <DED>normalized = f\"{e['base-currency'].upper()}{SYMBOL_SEP}{e['quote-currency'].upper()}\"\n            symbol = f\"{e['base-currency']}{e['quote-currency']}\"\n            ret[normalized] = symbol\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('HUOBI', why, {url: r})\n\n\n<DED><DED>def huobi_symbols() -> Dict[str, str]:\n    <IND>return huobi_common_symbols('https://api.huobi.pro/v1/common/symbols')\n\n\n<DED>def huobi_us_symbols() -> Dict[str, str]:\n    <IND>return huobi_common_symbols('https://api.huobi.com/v1/common/symbols')\n\n\n<DED>def huobi_dm_symbols() -> Dict[str, str]:\n    <IND>\"\"\"\n    Mapping is, for instance: {\"BTC_CW\":\"BTC190816\"}\n    See comments in exchange/huobi_dm.py\n    \"\"\"\n    mapping = {\n        \"this_week\": \"CW\",\n        \"next_week\": \"NW\",\n        \"quarter\": \"CQ\",\n        \"next_quarter\": \"NQ\"\n    }\n    r = None\n    try:\n        <IND>r = requests.get('https://www.hbdm.com/api/v1/contract_contract_info')\n        symbols = {}\n        for e in r.json()['data']:\n            <IND>symbols[f\"{e['symbol']}_{mapping[e['contract_type']]}\"] = e['contract_code']\n            _exchange_info[HUOBI_DM]['tick_size'][e['contract_code']] = e['price_tick']\n            _exchange_info[HUOBI_DM]['short_code_mappings'][f\"{e['symbol']}_{mapping[e['contract_type']]}\"] = e['contract_code']\n        <DED>return symbols\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('HUOBI_DM', why, {\"\": r})\n\n\n<DED><DED>def huobi_swap_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.hbdm.com/swap-api/v1/swap_contract_info')\n        symbols = {}\n        for e in r.json()['data']:\n            <IND>symbols[e['contract_code']] = e['contract_code']\n            _exchange_info[HUOBI_SWAP]['tick_size'][e['contract_code']] = e['price_tick']\n        <DED>return symbols\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('HUOBI_SWAP', why, {\"\": r})\n\n\n<DED><DED>def okcoin_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://www.okcoin.com/api/spot/v3/instruments')\n        ret = {}\n        for e in r.json():\n            <IND>ret[e['instrument_id']] = e['instrument_id']\n            _exchange_info[OKCOIN]['tick_size'][e['instrument_id']] = e['tick_size']\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('OKCOIN', why, {\"\": r})\n\n\n<DED><DED>def okex_symbols(*args) -> Dict[str, str]:\n    <IND>urls = ['https://www.okex.com/api/spot/v3/instruments',\n            'https://www.okex.com/api/swap/v3/instruments',\n            'https://www.okex.com/api/futures/v3/instruments']\n    urls = urls + okex_compute_option_urls_from_underlyings()\n\n    symbols: Dict[str, str] = {}\n    for u in urls:\n        <IND>time.sleep(0.2)\n        symbols.update(okex_symbols_from_one_url(u))\n\n    <DED>for symbol in symbols:\n        <IND>instrument_type = 'futures'\n        dash_count = symbol.count(get_symbol_separator())\n        if dash_count == 1:  # BTC-USDT\n            <IND>instrument_type = 'spot'\n        <DED>if dash_count == 4:  # BTC-USD-201225-35000-P\n            <IND>instrument_type = 'option'\n        <DED>if symbol[-4:] == \"SWAP\":  # BTC-USDT-SWAP\n            <IND>instrument_type = 'swap'\n\n        <DED>_exchange_info[OKEX]['instrument_type'][symbol] = instrument_type\n\n    <DED>return symbols\n\n\n<DED>def okex_compute_option_urls_from_underlyings() -> List[str]:\n    <IND>url = 'https://www.okex.com/api/option/v3/underlying'\n    r = None\n    try:\n        <IND>r = requests.get(url)\n        return [f'https://www.okex.com/api/option/v3/instruments/{underlying}' for underlying in r.json()]\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('OKEX', why, {url: r})\n\n\n<DED><DED>def okex_symbols_from_one_url(url: str) -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get(url)\n        ret = {}\n        for e in r.json():\n            <IND>ret[e['instrument_id']] = e['instrument_id']\n            _exchange_info[OKEX]['tick_size'][e['instrument_id']] = e['tick_size']\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('OKEX', why, {url: r})\n\n\n<DED><DED>def bittrex_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.bittrex.com/api/v1.1/public/getmarkets')\n        r = r.json()['result']\n        return {f\"{e['MarketCurrency']}{SYMBOL_SEP}{e['BaseCurrency']}\": e['MarketName'] for e in r if e['IsActive']}\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BITTREX', why, {\"\": r})\n\n\n<DED><DED>def bitcoincom_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.exchange.bitcoin.com/api/2/public/symbol')\n        return {f\"{data['baseCurrency']}{SYMBOL_SEP}{data['quoteCurrency'].replace('USD', 'USDT')}\": data['id'] for data in r.json()}\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BITCOINCOM', why, {\"\": r})\n\n\n<DED><DED>def bitmax_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://bitmax.io/api/pro/v1/products')\n        ret = {}\n        for entry in r.json()['data']:\n            # Only \"Normal\" status symbols are tradeable\n            <IND>if entry['status'] == 'Normal':\n                <IND>normalized = f\"{entry['baseAsset']}{SYMBOL_SEP}{entry['quoteAsset']}\"\n                ret[normalized] = entry['symbol']\n                _exchange_info[BITMAX]['tick_size'][normalized] = entry['tickSize']\n        <DED><DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BITMAX', why, {\"\": r})\n\n\n<DED><DED>def upbit_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.upbit.com/v1/market/all')\n        return {f\"{data['market'].split('-')[1]}{SYMBOL_SEP}{data['market'].split('-')[0]}\": data['market'] for data in r.json()}\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('UPBIT', why, {\"\": r})\n\n\n<DED><DED>def blockchain_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get(\"https://api.blockchain.com/mercury-gateway/v1/instruments\")\n        return {data[\"symbol\"].replace(\"-\", SYMBOL_SEP): data[\"symbol\"] for data in r.json()}\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BLOCKCHAIN', why, {\"\": r})\n\n\n<DED><DED>def gateio_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get(\"https://api.gateio.ws/api/v4/spot/currency_pairs\")\n        return {data[\"id\"].replace(\"_\", SYMBOL_SEP): data['id'] for data in r.json()}\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('GATEIO', why, {\"\": r})\n\n\n<DED><DED>def bitmex_symbols() -> Dict[str, str]:\n    <IND>r = None\n    ret = {}\n    try:\n        <IND>r = requests.get(\"https://www.bitmex.com/api/v1/instrument/active\")\n        for entry in r.json():\n            <IND>components = []\n            components.append(entry['rootSymbol'])\n            components.append(entry['quoteCurrency'])\n\n            if entry['expiry']:\n                <IND>components.append(entry['symbol'][-3:])\n\n            <DED>normalized = SYMBOL_SEP.join(components)\n            normalized = normalized.replace(\"XBT\", \"BTC\")\n            ret[normalized] = entry['symbol']\n            _exchange_info[BITMEX]['tick_size'][normalized] = entry['tickSize']\n\n            if entry['expiry']:\n                <IND>_exchange_info[BITMEX]['expiry'][normalized] = entry['expiry']\n\n        <DED><DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BITMEX', why, {\"\": r})\n\n\n<DED><DED>def deribit_symbols() -> Dict[str, str]:\n    <IND>url = r = None\n    ret = {}\n    try:\n        # TODO: get currencies from https://www.deribit.com/api/v2/public/get_currencies\n        <IND>currencies = ['BTC', 'ETH']\n        for c in currencies:\n            <IND>url = f\"https://www.deribit.com/api/v2/public/get_instruments?currency={c}&expired=false\"\n            r = requests.get(url)\n            for entry in r.json()['result']:\n                <IND>split = entry['instrument_name'].split(\"-\")\n                normalized = split[0] + SYMBOL_SEP + entry['quote_currency'] + \"-\" + '-'.join(split[1:])\n                ret[normalized] = entry['instrument_name']\n                _exchange_info[DERIBIT]['tick_size'][normalized] = entry['tick_size']\n        <DED><DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('DERIBIT', why, {url: r})\n\n\n<DED><DED>def kraken_future_symbols() -> Dict[str, str]:\n    <IND>r = None\n    ret = {}\n    try:\n        <IND>r = requests.get('https://futures.kraken.com/derivatives/api/v3/instruments')\n        data = r.json()['instruments']\n        for entry in data:\n            <IND>if not entry['tradeable']:\n                <IND>continue\n            <DED>normalized = entry['symbol'].upper().replace(\"_\", \"-\")\n            symbol = normalized[3:6] + SYMBOL_SEP + normalized[6:9]\n            normalized = normalized.replace(normalized[3:9], symbol)\n            normalized = normalized.replace('XBT', 'BTC')\n\n            _exchange_info[KRAKEN_FUTURES]['tick_size'][normalized] = entry['tickSize']\n            _exchange_info[KRAKEN_FUTURES]['contract_size'][normalized] = entry['contractSize']\n            _exchange_info[KRAKEN_FUTURES]['underlying'][normalized] = entry['underlying']\n            _exchange_info[KRAKEN_FUTURES]['product_type'][normalized] = _kraken_futures_product_type[normalized[:2]]\n            ret[normalized] = entry['symbol']\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('KRAKEN_FUTURES', why, {\"\": r})\n\n\n<DED><DED>def probit_symbols() -> Dict[str, str]:\n    # doc: https://docs-en.probit.com/reference-link/market\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.probit.com/api/exchange/v1/market')\n        return {entry['id']: entry['id'] for entry in r.json()['data']}\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('PROBIT', why, {\"\": r})\n\n\n<DED><DED>def coingecko_normalize_symbol(symbol: str) -> str:\n    # keep digits, letters and dots, replace others by space\n    <IND>symbol = ''.join(c if c.isalnum() or c in ('.', '+') else ' ' for c in symbol)\n    return coingecko_normalize(symbol.upper())\n\n\n<DED>def coingecko_normalize_name(name: str) -> str:\n    # keep digits and letters, replace others by space (except when only composed by upper case letters, digits and dots)\n    <IND>if not all(c.isupper() or c.isdigit() or c == '.' for c in name):\n        <IND>name = ''.join(c if c.isalnum() else ' ' for c in name)\n    <DED>return coingecko_normalize(name)\n\n\n<DED>def coingecko_normalize(sym: str) -> str:\n    <IND>sym = sym.strip()\n    # do not concatenate numbers => separate them with a dot\n    sym = list(sym)\n    if len(sym) > 4:\n        <IND>for i in range(2, len(sym) - 1):\n            <IND>if sym[i] == ' ' and sym[i - 1].isdigit() and sym[i + 1].isdigit():\n                <IND>sym[i] = '.'\n    <DED><DED><DED>sym = ''.join(sym)\n    # concatenate space-separated words => use CamelCase to distinguish the words\n    if ' ' in sym:\n        <IND>if sum(c.islower() for c in sym):  # if there is at least one lower case letter\n            <IND>sym = ' '.join(word[0].upper() + word[1:] for word in sym.split())  # Just capitalize initial letter of each word\n        <DED>else:  # CoinGecko may provide full upper-case as for \"THE STONE COIN\"\n            <IND>sym = string.capwords(sym)  # capwords converts \"THE STONE COIN\" to \"The Stone Coin\"\n        <DED>sym = sym.replace(' ', '')  # concatenate words\n    <DED>return sym\n\n\n<DED>def is_name_short(coin: dict) -> bool:\n    <IND>\"\"\"return True if the coin name is enough short compared to the coin symbol.\"\"\"\n    return len(coin['name']) <= max(5, len(coin['symbol']) + 1)\n\n\n<DED>def has_many_caps(name: str) -> bool:\n    <IND>\"\"\"return True if the symbol contains enough upper case letters, False if empty.\"\"\"\n    return str and sum(c.islower() for c in name) < (len(name) / 2)\n\n\n<DED>def coingecko_normalize_all(coin: dict):\n    <IND>SYMBOL_TO_NORMALIZED = {'miota': 'IOTA'}\n    normalized = SYMBOL_TO_NORMALIZED.get(coin['symbol'])\n    if normalized:\n        <IND>coin['ns'] = coin['nn'] = normalized\n        return normalized\n\n    # ns = normalized symbol, nn = normalized name\n    <DED>coin['ns'] = coingecko_normalize_symbol(coin['symbol'])\n\n    ID_SUFFIX = '-bitcoin-token'\n    if coin['id'][-len(ID_SUFFIX):] == ID_SUFFIX:\n        <IND>coin['nn'] = 'BTC' + coin['ns']\n        return coin['nn']\n\n    <DED>name = coin['name']\n\n    prefixes = ('The ', 'the ')\n    for p in prefixes:\n        <IND>if name[:len(p)] == p:\n            <IND>coin['reduced-name'] = True\n            name = name[len(p):]\n            break\n\n    <DED><DED>suffixes = ('coin', 'coins', 'money', 'finance', 'protocol', 'reward', 'rewards', 'token')\n    for s in suffixes:\n        <IND>if len(name) > len(s) and name[-len(s):].lower() == s:\n            # but keep suffix when lower-case concatenated\n            <IND>if name[-len(s)].islower() and name[-len(s) - 1] != ' ':\n                <IND>continue\n            # also keep suffix to avoid confusing nam: \"Bitcoin Token\" -> \"Bitcoin\"\n            <DED>if name[:-len(s)].strip().lower() == 'bitcoin':\n                <IND>continue\n            <DED>coin['reduced-name'] = True\n            name = name[:-len(s)]\n            break\n\n    <DED><DED>coin['nn'] = coingecko_normalize_name(name)\n\n    if len(coin['nn']) < len(coin['ns']):\n        <IND>if 'reduced-name' in coin:\n            <IND>coin['reduced-name'] = False\n            name = coin['name']\n            coin['nn'] = coingecko_normalize_name(name)\n        <DED>elif not has_many_caps(name):\n            <IND>return coin['ns']\n\n    <DED><DED>if not coin['ns']:  # coin['symbol'] may be an emoji that is striped when normalized\n        <IND>return coin['nn']\n\n    <DED>if coin.get('reduced-name') and coin['ns'].upper() != coin['nn'].upper():\n        <IND>return coin['ns']\n\n    <DED>i = coin['nn'].find('.')  # if there is a dot in normalized name => prefer the normalized symbol\n    if i >= 0:\n        <IND>if i > 1 and coin['nn'][i - 1].isdigit() and coin['nn'][i + 1].isdigit():\n            <IND>pass  # except when the dot separates digits\n        <DED>else:\n            <IND>return coin['ns']\n\n    <DED><DED>if is_name_short(coin) and has_many_caps(name):\n        <IND>return coin['nn']\n\n    <DED>if 1.5 * len(coin['ns']) > len(coin['nn']) and any(c.islower() for c in coin['ns']):\n        <IND>return coin['nn']\n\n    <DED>return coin['ns']\n\n\n<DED>def coingecko_symbols() -> Dict[str, str]:\n    <IND>r = None\n    intermediate = defaultdict(list)\n    try:\n        <IND>r = requests.get('https://api.coingecko.com/api/v3/coins/list')\n        all_coins = r.json()\n        # First pass: generate & compare normalized symbol/name, and then select the most pertinent\n        for coin in all_coins:\n            <IND>normalized = coingecko_normalize_all(coin)\n            intermediate[normalized].append(coin)\n            # Above line keeps together the coins having the same normalized symbol.\n            # To reduce collision, the coin['name'] is sometimes used in lieu of the coin['symbol'].\n            # The coin['name'] is not capitalized because lower case letters may be meaningful: cETH, yUSD, DATx, zLOT\n    <DED><DED>except Exception as why:\n        <IND>raise_failure_explanation('COINGECKO', why, {\"\": r})\n\n    <DED>final = coingecko_second_pass(intermediate)\n    return coingecko_third_pass(final)\n\n\n<DED>def coingecko_second_pass(intermediate: Dict[str, List[dict]]) -> Dict[str, List[dict]]:\n    # Second pass: fixes most of the symbol collisions\n    <IND>final = defaultdict(list)\n    for normalized, coins in intermediate.items():\n        <IND>if len(coins) == 1:\n            <IND>final[normalized].append(coins[0])\n            continue\n        <DED>set_normalized = False\n        for i in range(len(coins)):\n            <IND>if normalized == coins[i]['nn']:\n                <IND>coin = coins.pop(i)\n                final[normalized].append(coin)\n                set_normalized = True\n                break\n        <DED><DED>rest: List[dict] = []\n        for coin in coins:\n            <IND>if '%' in coin['name']:\n                <IND>if len(coins) == 1:\n                    <IND>n = coin['ns']\n                <DED>else:\n                    <IND>n = coingecko_normalize_name(coin['id'])\n                <DED>final[n].append(coin)\n            <DED>else:\n                <IND>rest.append(coin)\n        <DED><DED>if not rest:\n            <IND>continue\n        <DED>if not set_normalized:\n            <IND>rest.sort(key=lambda coin: len(coin['nn']), reverse=True)  # sort by the length of the normalized name\n            coin = rest.pop(0)\n            final[normalized].append(coin)\n        <DED>for coin in rest:\n            <IND>if coin['nn'] not in intermediate:\n                <IND>n = coin['nn']\n            <DED>elif coin.get('reduced-name'):\n                <IND>n = coingecko_normalize_name(coin['name'])\n            <DED>else:\n                <IND>n = coingecko_normalize_name(coin['id'])\n            <DED>final[n].append(coin)\n    <DED><DED>return final\n\n\n<DED>def coingecko_third_pass(final: Dict[str, List[dict]]) -> Dict[str, str]:\n    # Third pass: fixes some remaining collisions and fills the result\n    <IND>symbols = {}\n    for normalized, coins in final.items():\n        <IND>if len(coins) == 1:\n            <IND>symbols[normalized] = coins[0]['id']\n            continue\n        <DED>set_normalized = False\n        for i in range(len(coins)):\n            <IND>if normalized == coins[i]['nn']:\n                <IND>coin = coins.pop(i)\n                symbols[normalized] = coin['id']\n                set_normalized = True\n                break\n        <DED><DED>rest: List[dict] = []\n        for coin in coins:\n            <IND>if '%' in coin['name']:\n                <IND>if len(coins) == 1:\n                    <IND>n = coin['ns']\n                <DED>else:\n                    <IND>n = coingecko_normalize_name(coin['id'])\n                <DED>symbols[n] = coin['id']\n            <DED>else:\n                <IND>rest.append(coin)\n        <DED><DED>if not rest:\n            <IND>continue\n        <DED>if not set_normalized:\n            <IND>rest.sort(key=lambda coin: len(coin['nn']), reverse=True)  # sort by the length of the normalized name\n            coin = rest.pop(0)\n            symbols[normalized] = coin['id']\n        <DED>for coin in rest:\n            <IND>if coin['nn'] not in final:\n                <IND>n = coin['nn']\n            <DED>elif coin.get('reduced-name'):\n                <IND>n = coingecko_normalize_name(coin['name'])\n            <DED>else:\n                <IND>n = coingecko_normalize_name(coin['id'])\n            <DED>symbols[n] = coin['id']\n    <DED><DED>return symbols\n\n\n<DED>def whale_alert_coins(key_id: str) -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get(f'https://api.whale-alert.io/v1/status?api_key={key_id}')\n        # Same symbols, but on different blockchains (for instance USDT), are naturally overwritten.\n        return {s.upper(): s for b in r.json()['blockchains'] for s in b['symbols'] if s}\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('WHALES_ALERT', why, {\"\": r})\n\n\n<DED><DED>_exchange_function_map = {\n    BITFINEX: bitfinex_symbols,\n    BITFLYER: bitflyer_symbols,\n    COINBASE: coinbase_symbols,\n    GEMINI: gemini_symbols,\n    HITBTC: hitbtc_symbols,\n    POLONIEX: poloniex_symbols,\n    PROBIT: probit_symbols,\n    BITSTAMP: bitstamp_symbols,\n    KRAKEN: kraken_symbols,\n    KRAKEN + 'REST': kraken_rest_symbols,\n    BINANCE: binance_symbols,\n    BINANCE_US: binance_us_symbols,\n    BINANCE_FUTURES: binance_futures_symbols,\n    BINANCE_DELIVERY: binance_delivery_symbols,\n    BLOCKCHAIN: blockchain_symbols,\n    EXX: exx_symbols,\n    HUOBI: huobi_symbols,\n    HUOBI_DM: huobi_dm_symbols,\n    HUOBI_SWAP: huobi_swap_symbols,\n    OKCOIN: okcoin_symbols,\n    OKEX: okex_symbols,\n    BYBIT: bybit_symbols,\n    FTX: ftx_symbols,\n    FTX_US: ftx_us_symbols,\n    BITTREX: bittrex_symbols,\n    BITCOINCOM: bitcoincom_symbols,\n    BITMAX: bitmax_symbols,\n    UPBIT: upbit_symbols,\n    GATEIO: gateio_symbols,\n    BITMEX: bitmex_symbols,\n    DERIBIT: deribit_symbols,\n    KRAKEN_FUTURES: kraken_future_symbols,\n    COINGECKO: coingecko_symbols,\n    WHALE_ALERT: whale_alert_coins\n}\n",
        "target_code_with_indent": "\nfrom typing import Dict, Tuple\n\n\nclass _Symbols:\n    <IND>def __init__(self):\n        <IND>self.data = {}\n\n    <DED>def set(self, exchange: str, normalized: dict, exchange_info: dict):\n        <IND>self.data[exchange] = {}\n        self.data[exchange]['normalized'] = normalized\n        self.data[exchange]['info'] = exchange_info\n\n    <DED>def get(self, exchange: str) -> Tuple[Dict, Dict]:\n        <IND>return self.data[exchange]['normalized'], self.data[exchange]['info']\n\n    <DED>def populated(self, exchange: str) -> bool:\n        <IND>return exchange in self.data\n\n\n<DED><DED>Symbols = _Symbols()\n"
      }
    ]
  },
  {
    "project": "bmoscon/cryptofeed",
    "commit": "3525dc8ce4d7836a9abaaa5662e58e5e27969a77",
    "filename": "cryptofeed/symbols.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/bmoscon-cryptofeed/cryptofeed/symbols.py",
    "file_hunks_size": 1,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "cryptofeed/symbols.py:183:8 Incompatible return type [7]: Expected `Dict[str, str]` but got implicit return value of `None`.",
    "message": " Expected `Dict[str, str]` but got implicit return value of `None`.",
    "rule_id": "Incompatible return type [7]",
    "warning_line_no": 183,
    "warning_line": "        raise_failure_explanation('BYBIT', why, {\"\": r})",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "associated with this software.\n\n\nSymbol generation code for exchanges\n'''\n\nimport logging\nimport string\nimport time\nfrom collections import defaultdict\nfrom typing import Dict, List, Optional, Tuple\n\nimport requests\nfrom requests import Response\n\nfrom cryptofeed.defines import *\n\n\nLOG = logging.getLogger('feedhandler')\n\nSYMBOL_SEP = '-'\n\n_symbols_retrieval_cache: Dict[str, Dict[str, str]] = {}\n_exchange_info = defaultdict(lambda: defaultdict(dict))\n\n\n_kraken_futures_product_type = {\n    'FI': 'Inverse Futures',\n    'FV': 'Vanilla Futures',\n    'PI': 'Perpetual Inverse Futures',\n    'PV': 'Perpetual Vanilla Futures',\n    'IN': 'Real Time Index',\n    'RR': 'Reference Rate',\n}\n\n\ndef raise_failure_explanation(feed_id: str, exception: BaseException, responses: Dict[str, Optional[Response]]):\n    LOG.critical('%s: encountered %r while processing response from exchange API', feed_id, exception)\n    if len(responses) > 1:\n        LOG.critical('%s: content of one of the %s responses was unexpected', feed_id, len(responses))\n    for url, r in responses.items():\n        if url:\n            LOG.critical('%s: requested URL: %s', feed_id, url)\n        if r:\n            LOG.critical('%s: unexpected response: %s', feed_id, r.text)\n    raise ValueError(f'Cryptofeed stopped because of an unexpected response from {feed_id}') from exception\n\n\ndef set_symbol_separator(separator: str):\n    global SYMBOL_SEP\n    SYMBOL_SEP = separator\n\n\ndef get_symbol_separator() -> str:\n    global SYMBOL_SEP\n    return SYMBOL_SEP\n\n\ndef gen_symbols(exchange: str, key_id=None) -> Dict[str, str]:\n    if exchange not in _symbols_retrieval_cache:\n        LOG.info(\"%s: Getting list of symbols\", exchange)\n        symbols = _exchange_function_map[exchange](key_id) if key_id else _exchange_function_map[exchange]()\n        LOG.info(\"%s: %s symbols\", exchange, len(symbols))\n\n        # log all retrieved symbols using debug level\n        for normalized, exch_sym in sorted(symbols.items()):\n            LOG.debug('%s: id-from-exch -> normalized: %-35s-> %s', exchange, exch_sym, normalized)\n\n        _symbols_retrieval_cache[exchange] = symbols\n    return _symbols_retrieval_cache[exchange]\n\n\ndef _binance_symbols(endpoint: str, exchange: str):\n    r = None\n    try:\n        ret = {}\n        r = requests.get(endpoint)\n        for symbol in r.json()['symbols']:\n            if symbol.get('status', 'TRADING') != \"TRADING\":\n                continue\n            if symbol.get('contractStatus', 'TRADING') != \"TRADING\":\n                continue\n            split = len(symbol['baseAsset'])\n            normalized = symbol['symbol'][:split] + SYMBOL_SEP + symbol['symbol'][split:]\n            ret[normalized] = symbol['symbol']\n            _exchange_info[exchange]['tick_size'][normalized] = symbol['filters'][0]['tickSize']\n            if \"contractType\" in symbol:\n                _exchange_info[exchange]['contract_type'][normalized] = symbol['contractType']\n        return ret\n    except Exception as why:\n        raise_failure_explanation(exchange, why, {endpoint: r})\n\n\ndef binance_symbols() -> Dict[str, str]:\n    return _binance_symbols('https://api.binance.com/api/v3/exchangeInfo', BINANCE)\n\n\ndef binance_us_symbols() -> Dict[str, str]:\n    return _binance_symbols('https://api.binance.us/api/v3/exchangeInfo', BINANCE_US)\n\n\ndef binance_futures_symbols() -> Dict[str, str]:\n    base = _binance_symbols('https://fapi.binance.com/fapi/v1/exchangeInfo', BINANCE_FUTURES)\n    add = {}\n    for symbol, orig in base.items():\n        if \"_\" in orig:\n            continue\n        add[f\"{symbol}-PINDEX\"] = f\"p{orig}\"\n    base.update(add)\n    return base\n\n\ndef binance_delivery_symbols() -> Dict[str, str]:\n    return _binance_symbols('https://dapi.binance.com/dapi/v1/exchangeInfo', BINANCE_DELIVERY)\n\n\ndef bitfinex_symbols() -> Dict[str, str]:\n    # doc: https://docs.bitfinex.com/docs/ws-general#supported-pairs\n    r1 = r2 = None\n    try:\n        r1 = requests.get('https://api.bitfinex.com/v2/tickers?symbols=ALL')\n        r2 = requests.get('https://api-pub.bitfinex.com/v2/conf/pub:map:currency:sym')\n        tickers: List[List[str]] = r1.json()\n        norm: List[Tuple[str, str]] = r2.json()[0]\n        norm: Dict[str, str] = dict(norm)\n        for k, v in dict(norm).items():\n            if k[-2:] == 'F0' or '-' in v:  # Do not convert BTCF0 -> BTC or PBTCETH -> PBTC-ETH\n                del norm[k]\n        norm['BCHN'] = 'BCH'  # Bitfinex uses BCHN, other exchanges use BCH\n\n        ret = {}\n        for symbol in [t[0] for t in tickers]:\n            if symbol[0] == 'f':\n                normalized = norm.get(symbol[1:], symbol[1:])\n            else:\n                if len(symbol) == 7:\n                    base, quote = symbol[1:4], symbol[4:]\n                else:\n                    base, quote = symbol[1:].split(':')\n                    assert ':' in symbol\n                normalized = norm.get(base, base) + SYMBOL_SEP + norm.get(quote, quote)\n            ret[normalized.upper()] = symbol\n        return ret\n    except ValueError as why:\n        raise_failure_explanation('BITFINEX', why, {\"tickers?symbols=ALL\": r1, \"pub:map:currency:sym\": r2})\n\n\ndef bitflyer_symbols() -> Dict[str, str]:\n    endpoint = r = None\n    try:\n        ret = {}\n        endpoints = ['https://api.bitflyer.com/v1/getmarkets/eu', 'https://api.bitflyer.com/v1/getmarkets/usa', 'https://api.bitflyer.com/v1/getmarkets']\n        for endpoint in endpoints:\n            r = requests.get(endpoint)\n            for entry in r.json():\n                normalized = entry['product_code'].replace(\"_\", SYMBOL_SEP)\n                ret[normalized] = entry['product_code']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('BITFLYER', why, {endpoint: r})\n\n\ndef bybit_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.bybit.com/v2/public/symbols')\n        ret = {}\n        for symbol in r.json()['result']:\n            quote = symbol['quote_currency']\n            if not symbol['name'].endswith(quote):\n                base, contract = symbol['name'].split(quote)\n                normalized = f\"{base}{SYMBOL_SEP}{quote}-{contract}\"\n            else:\n                normalized = f\"{symbol['base_currency']}{SYMBOL_SEP}{quote}\"\n            ret[normalized] = symbol['name']\n            _exchange_info[BYBIT]['tick_size'][normalized] = symbol['price_filter']['tick_size']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('BYBIT', why, {\"\": r})\n\n\ndef _ftx_helper(endpoint: str, exchange: str):\n    r = None\n    try:\n        r = requests.get(endpoint)\n        ret = {}\n        for data in r.json()['result']:\n            normalized = data['name'].replace(\"/\", SYMBOL_SEP)\n            symbol = data['name']\n            ret[normalized] = symbol\n            _exchange_info[exchange]['tick_size'][normalized] = data['priceIncrement']\n        return ret\n    except Exception as why:\n        raise_failure_explanation(exchange, why, {endpoint: r})\n\n\ndef ftx_symbols() -> Dict[str, str]:\n    return _ftx_helper('https://ftx.com/api/markets', FTX)\n\n\ndef ftx_us_symbols() -> Dict[str, str]:\n    return _ftx_helper('https://ftx.us/api/markets', FTX_US)\n\n\ndef coinbase_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.pro.coinbase.com/products')\n        ret = {}\n        for data in r.json():\n            normalized = data['id'].replace(\"-\", SYMBOL_SEP)\n            ret[normalized] = data['id']\n            _exchange_info[COINBASE]['tick_size'][normalized] = data['quote_increment']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('COINBASE', why, {\"\": r})\n\n\ndef gemini_symbols(*args) -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.gemini.com/v1/symbols')\n        ret = {}\n        for symbol in r.json():\n            std = f\"{symbol[:-3]}{SYMBOL_SEP}{symbol[-3:]}\"\n            std = std.upper()\n            ret[std] = symbol.upper()\n        return ret\n    except Exception as why:\n        raise_failure_explanation('GEMINI', why, {\"\": r})\n\n\ndef hitbtc_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        ret = {}\n        r = requests.get('https://api.hitbtc.com/api/2/public/symbol')\n        for symbol in r.json():\n            split = len(symbol['baseCurrency'])\n            normalized = symbol['id'][:split] + SYMBOL_SEP + symbol['id'][split:]\n            ret[normalized] = symbol['id']\n            _exchange_info[HITBTC]['tick_size'][normalized] = symbol['tickSize']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('HITBTC', why, {\"\": r})\n\n\ndef poloniex_id_symbol_mapping():\n    r = None\n    try:\n        r = requests.get('https://poloniex.com/public?command=returnTicker')\n        symbols = r.json()\n        ret = {}\n        for symbol in symbols:\n            ret[symbols[symbol]['id']] = symbol\n        return ret\n    except Exception as why:\n        raise_failure_explanation('POLONIEX', why, {\"\": r})\n\n\ndef poloniex_symbols() -> Dict[str, str]:\n    ret = {}\n    for _, value in poloniex_id_symbol_mapping().items():\n        std = value.replace(\"STR\", \"XLM\")\n        quote, base = std.split(\"_\")\n        ret[quote + SYMBOL_SEP + base] = value\n    return ret\n\n\ndef bitstamp_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://www.bitstamp.net/api/v2/trading-pairs-info/')\n        ret = {}\n        for data in r.json():\n            normalized = data['name'].replace(\"/\", SYMBOL_SEP)\n            symbol = data['url_symbol']\n            ret[normalized] = symbol\n        return ret\n    except Exception as why:\n        raise_failure_explanation('BITSTAMP', why, {\"\": r})\n\n\ndef kraken_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.kraken.com/0/public/AssetPairs')\n        data = r.json()\n        ret = {}\n        for symbol in data['result']:\n            if 'wsname' not in data['result'][symbol] or '.d' in symbol:\n                # https://blog.kraken.com/post/259/introducing-the-kraken-dark-pool/\n                # .d is for dark pool symbols\n                continue\n\n            base, quote = data['result'][symbol]['wsname'].split(\"/\")\n\n            normalized = f\"{base}{SYMBOL_SEP}{quote}\"\n            exch = data['result'][symbol]['wsname']\n            normalized = normalized.replace('XBT', 'BTC')\n            normalized = normalized.replace('XDG', 'DOG')\n            ret[normalized] = exch\n        return ret\n    except Exception as why:\n        raise_failure_explanation('KRAKEN', why, {\"\": r})\n\n\ndef kraken_rest_symbols() -> Dict[str, str]:\n    return {normalized: exchange.replace(\"/\", \"\") for normalized, exchange in kraken_symbols().items()}\n\n\ndef exx_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.exx.com/data/v1/tickers')\n        exchange = [key.upper() for key in r.json().keys()]\n        symbols = [key.replace(\"_\", SYMBOL_SEP) for key in exchange]\n        return dict(zip(symbols, exchange))\n    except Exception as why:\n        raise_failure_explanation('EXX', why, {\"\": r})\n\n\ndef huobi_common_symbols(url: str):\n    r = None\n    try:\n        r = requests.get(url)\n        ret = {}\n        for e in r.json()['data']:\n            if e['state'] == 'offline':\n                continue\n            normalized = f\"{e['base-currency'].upper()}{SYMBOL_SEP}{e['quote-currency'].upper()}\"\n            symbol = f\"{e['base-currency']}{e['quote-currency']}\"\n            ret[normalized] = symbol\n        return ret\n    except Exception as why:\n        raise_failure_explanation('HUOBI', why, {url: r})\n\n\ndef huobi_symbols() -> Dict[str, str]:\n    return huobi_common_symbols('https://api.huobi.pro/v1/common/symbols')\n\n\ndef huobi_us_symbols() -> Dict[str, str]:\n    return huobi_common_symbols('https://api.huobi.com/v1/common/symbols')\n\n\ndef huobi_dm_symbols() -> Dict[str, str]:\n    \"\"\"\n    Mapping is, for instance: {\"BTC_CW\":\"BTC190816\"}\n    See comments in exchange/huobi_dm.py\n    \"\"\"\n    mapping = {\n        \"this_week\": \"CW\",\n        \"next_week\": \"NW\",\n        \"quarter\": \"CQ\",\n        \"next_quarter\": \"NQ\"\n    }\n    r = None\n    try:\n        r = requests.get('https://www.hbdm.com/api/v1/contract_contract_info')\n        symbols = {}\n        for e in r.json()['data']:\n            symbols[f\"{e['symbol']}_{mapping[e['contract_type']]}\"] = e['contract_code']\n            _exchange_info[HUOBI_DM]['tick_size'][e['contract_code']] = e['price_tick']\n            _exchange_info[HUOBI_DM]['short_code_mappings'][f\"{e['symbol']}_{mapping[e['contract_type']]}\"] = e['contract_code']\n        return symbols\n    except Exception as why:\n        raise_failure_explanation('HUOBI_DM', why, {\"\": r})\n\n\ndef huobi_swap_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.hbdm.com/swap-api/v1/swap_contract_info')\n        symbols = {}\n        for e in r.json()['data']:\n            symbols[e['contract_code']] = e['contract_code']\n            _exchange_info[HUOBI_SWAP]['tick_size'][e['contract_code']] = e['price_tick']\n        return symbols\n    except Exception as why:\n        raise_failure_explanation('HUOBI_SWAP', why, {\"\": r})\n\n\ndef okcoin_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://www.okcoin.com/api/spot/v3/instruments')\n        ret = {}\n        for e in r.json():\n            ret[e['instrument_id']] = e['instrument_id']\n            _exchange_info[OKCOIN]['tick_size'][e['instrument_id']] = e['tick_size']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('OKCOIN', why, {\"\": r})\n\n\ndef okex_symbols(*args) -> Dict[str, str]:\n    urls = ['https://www.okex.com/api/spot/v3/instruments',\n            'https://www.okex.com/api/swap/v3/instruments',\n            'https://www.okex.com/api/futures/v3/instruments']\n    urls = urls + okex_compute_option_urls_from_underlyings()\n\n    symbols: Dict[str, str] = {}\n    for u in urls:\n        time.sleep(0.2)\n        symbols.update(okex_symbols_from_one_url(u))\n\n    for symbol in symbols:\n        instrument_type = 'futures'\n        dash_count = symbol.count(get_symbol_separator())\n        if dash_count == 1:  # BTC-USDT\n            instrument_type = 'spot'\n        if dash_count == 4:  # BTC-USD-201225-35000-P\n            instrument_type = 'option'\n        if symbol[-4:] == \"SWAP\":  # BTC-USDT-SWAP\n            instrument_type = 'swap'\n\n        _exchange_info[OKEX]['instrument_type'][symbol] = instrument_type\n\n    return symbols\n\n\ndef okex_compute_option_urls_from_underlyings() -> List[str]:\n    url = 'https://www.okex.com/api/option/v3/underlying'\n    r = None\n    try:\n        r = requests.get(url)\n        return [f'https://www.okex.com/api/option/v3/instruments/{underlying}' for underlying in r.json()]\n    except Exception as why:\n        raise_failure_explanation('OKEX', why, {url: r})\n\n\ndef okex_symbols_from_one_url(url: str) -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get(url)\n        ret = {}\n        for e in r.json():\n            ret[e['instrument_id']] = e['instrument_id']\n            _exchange_info[OKEX]['tick_size'][e['instrument_id']] = e['tick_size']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('OKEX', why, {url: r})\n\n\ndef bittrex_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.bittrex.com/api/v1.1/public/getmarkets')\n        r = r.json()['result']\n        return {f\"{e['MarketCurrency']}{SYMBOL_SEP}{e['BaseCurrency']}\": e['MarketName'] for e in r if e['IsActive']}\n    except Exception as why:\n        raise_failure_explanation('BITTREX', why, {\"\": r})\n\n\ndef bitcoincom_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.exchange.bitcoin.com/api/2/public/symbol')\n        return {f\"{data['baseCurrency']}{SYMBOL_SEP}{data['quoteCurrency'].replace('USD', 'USDT')}\": data['id'] for data in r.json()}\n    except Exception as why:\n        raise_failure_explanation('BITCOINCOM', why, {\"\": r})\n\n\ndef bitmax_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://bitmax.io/api/pro/v1/products')\n        ret = {}\n        for entry in r.json()['data']:\n            # Only \"Normal\" status symbols are tradeable\n            if entry['status'] == 'Normal':\n                normalized = f\"{entry['baseAsset']}{SYMBOL_SEP}{entry['quoteAsset']}\"\n                ret[normalized] = entry['symbol']\n                _exchange_info[BITMAX]['tick_size'][normalized] = entry['tickSize']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('BITMAX', why, {\"\": r})\n\n\ndef upbit_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.upbit.com/v1/market/all')\n        return {f\"{data['market'].split('-')[1]}{SYMBOL_SEP}{data['market'].split('-')[0]}\": data['market'] for data in r.json()}\n    except Exception as why:\n        raise_failure_explanation('UPBIT', why, {\"\": r})\n\n\ndef blockchain_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get(\"https://api.blockchain.com/mercury-gateway/v1/instruments\")\n        return {data[\"symbol\"].replace(\"-\", SYMBOL_SEP): data[\"symbol\"] for data in r.json()}\n    except Exception as why:\n        raise_failure_explanation('BLOCKCHAIN', why, {\"\": r})\n\n\ndef gateio_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get(\"https://api.gateio.ws/api/v4/spot/currency_pairs\")\n        return {data[\"id\"].replace(\"_\", SYMBOL_SEP): data['id'] for data in r.json()}\n    except Exception as why:\n        raise_failure_explanation('GATEIO', why, {\"\": r})\n\n\ndef bitmex_symbols() -> Dict[str, str]:\n    r = None\n    ret = {}\n    try:\n        r = requests.get(\"https://www.bitmex.com/api/v1/instrument/active\")\n        for entry in r.json():\n            components = []\n            components.append(entry['rootSymbol'])\n            components.append(entry['quoteCurrency'])\n\n            if entry['expiry']:\n                components.append(entry['symbol'][-3:])\n\n            normalized = SYMBOL_SEP.join(components)\n            normalized = normalized.replace(\"XBT\", \"BTC\")\n            ret[normalized] = entry['symbol']\n            _exchange_info[BITMEX]['tick_size'][normalized] = entry['tickSize']\n\n            if entry['expiry']:\n                _exchange_info[BITMEX]['expiry'][normalized] = entry['expiry']\n\n        return ret\n    except Exception as why:\n        raise_failure_explanation('BITMEX', why, {\"\": r})\n\n\ndef deribit_symbols() -> Dict[str, str]:\n    url = r = None\n    ret = {}\n    try:\n        # TODO: get currencies from https://www.deribit.com/api/v2/public/get_currencies\n        currencies = ['BTC', 'ETH']\n        for c in currencies:\n            url = f\"https://www.deribit.com/api/v2/public/get_instruments?currency={c}&expired=false\"\n            r = requests.get(url)\n            for entry in r.json()['result']:\n                split = entry['instrument_name'].split(\"-\")\n                normalized = split[0] + SYMBOL_SEP + entry['quote_currency'] + \"-\" + '-'.join(split[1:])\n                ret[normalized] = entry['instrument_name']\n                _exchange_info[DERIBIT]['tick_size'][normalized] = entry['tick_size']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('DERIBIT', why, {url: r})\n\n\ndef kraken_future_symbols() -> Dict[str, str]:\n    r = None\n    ret = {}\n    try:\n        r = requests.get('https://futures.kraken.com/derivatives/api/v3/instruments')\n        data = r.json()['instruments']\n        for entry in data:\n            if not entry['tradeable']:\n                continue\n            normalized = entry['symbol'].upper().replace(\"_\", \"-\")\n            symbol = normalized[3:6] + SYMBOL_SEP + normalized[6:9]\n            normalized = normalized.replace(normalized[3:9], symbol)\n            normalized = normalized.replace('XBT', 'BTC')\n\n            _exchange_info[KRAKEN_FUTURES]['tick_size'][normalized] = entry['tickSize']\n            _exchange_info[KRAKEN_FUTURES]['contract_size'][normalized] = entry['contractSize']\n            _exchange_info[KRAKEN_FUTURES]['underlying'][normalized] = entry['underlying']\n            _exchange_info[KRAKEN_FUTURES]['product_type'][normalized] = _kraken_futures_product_type[normalized[:2]]\n            ret[normalized] = entry['symbol']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('KRAKEN_FUTURES', why, {\"\": r})\n\n\ndef probit_symbols() -> Dict[str, str]:\n    # doc: https://docs-en.probit.com/reference-link/market\n    r = None\n    try:\n        r = requests.get('https://api.probit.com/api/exchange/v1/market')\n        return {entry['id']: entry['id'] for entry in r.json()['data']}\n    except Exception as why:\n        raise_failure_explanation('PROBIT', why, {\"\": r})\n\n\ndef coingecko_normalize_symbol(symbol: str) -> str:\n    # keep digits, letters and dots, replace others by space\n    symbol = ''.join(c if c.isalnum() or c in ('.', '+') else ' ' for c in symbol)\n    return coingecko_normalize(symbol.upper())\n\n\ndef coingecko_normalize_name(name: str) -> str:\n    # keep digits and letters, replace others by space (except when only composed by upper case letters, digits and dots)\n    if not all(c.isupper() or c.isdigit() or c == '.' for c in name):\n        name = ''.join(c if c.isalnum() else ' ' for c in name)\n    return coingecko_normalize(name)\n\n\ndef coingecko_normalize(sym: str) -> str:\n    sym = sym.strip()\n    # do not concatenate numbers => separate them with a dot\n    sym = list(sym)\n    if len(sym) > 4:\n        for i in range(2, len(sym) - 1):\n            if sym[i] == ' ' and sym[i - 1].isdigit() and sym[i + 1].isdigit():\n                sym[i] = '.'\n    sym = ''.join(sym)\n    # concatenate space-separated words => use CamelCase to distinguish the words\n    if ' ' in sym:\n        if sum(c.islower() for c in sym):  # if there is at least one lower case letter\n            sym = ' '.join(word[0].upper() + word[1:] for word in sym.split())  # Just capitalize initial letter of each word\n        else:  # CoinGecko may provide full upper-case as for \"THE STONE COIN\"\n            sym = string.capwords(sym)  # capwords converts \"THE STONE COIN\" to \"The Stone Coin\"\n        sym = sym.replace(' ', '')  # concatenate words\n    return sym\n\n\ndef is_name_short(coin: dict) -> bool:\n    \"\"\"return True if the coin name is enough short compared to the coin symbol.\"\"\"\n    return len(coin['name']) <= max(5, len(coin['symbol']) + 1)\n\n\ndef has_many_caps(name: str) -> bool:\n    \"\"\"return True if the symbol contains enough upper case letters, False if empty.\"\"\"\n    return str and sum(c.islower() for c in name) < (len(name) / 2)\n\n\ndef coingecko_normalize_all(coin: dict):\n    SYMBOL_TO_NORMALIZED = {'miota': 'IOTA'}\n    normalized = SYMBOL_TO_NORMALIZED.get(coin['symbol'])\n    if normalized:\n        coin['ns'] = coin['nn'] = normalized\n        return normalized\n\n    # ns = normalized symbol, nn = normalized name\n    coin['ns'] = coingecko_normalize_symbol(coin['symbol'])\n\n    ID_SUFFIX = '-bitcoin-token'\n    if coin['id'][-len(ID_SUFFIX):] == ID_SUFFIX:\n        coin['nn'] = 'BTC' + coin['ns']\n        return coin['nn']\n\n    name = coin['name']\n\n    prefixes = ('The ', 'the ')\n    for p in prefixes:\n        if name[:len(p)] == p:\n            coin['reduced-name'] = True\n            name = name[len(p):]\n            break\n\n    suffixes = ('coin', 'coins', 'money', 'finance', 'protocol', 'reward', 'rewards', 'token')\n    for s in suffixes:\n        if len(name) > len(s) and name[-len(s):].lower() == s:\n            # but keep suffix when lower-case concatenated\n            if name[-len(s)].islower() and name[-len(s) - 1] != ' ':\n                continue\n            # also keep suffix to avoid confusing nam: \"Bitcoin Token\" -> \"Bitcoin\"\n            if name[:-len(s)].strip().lower() == 'bitcoin':\n                continue\n            coin['reduced-name'] = True\n            name = name[:-len(s)]\n            break\n\n    coin['nn'] = coingecko_normalize_name(name)\n\n    if len(coin['nn']) < len(coin['ns']):\n        if 'reduced-name' in coin:\n            coin['reduced-name'] = False\n            name = coin['name']\n            coin['nn'] = coingecko_normalize_name(name)\n        elif not has_many_caps(name):\n            return coin['ns']\n\n    if not coin['ns']:  # coin['symbol'] may be an emoji that is striped when normalized\n        return coin['nn']\n\n    if coin.get('reduced-name') and coin['ns'].upper() != coin['nn'].upper():\n        return coin['ns']\n\n    i = coin['nn'].find('.')  # if there is a dot in normalized name => prefer the normalized symbol\n    if i >= 0:\n        if i > 1 and coin['nn'][i - 1].isdigit() and coin['nn'][i + 1].isdigit():\n            pass  # except when the dot separates digits\n        else:\n            return coin['ns']\n\n    if is_name_short(coin) and has_many_caps(name):\n        return coin['nn']\n\n    if 1.5 * len(coin['ns']) > len(coin['nn']) and any(c.islower() for c in coin['ns']):\n        return coin['nn']\n\n    return coin['ns']\n\n\ndef coingecko_symbols() -> Dict[str, str]:\n    r = None\n    intermediate = defaultdict(list)\n    try:\n        r = requests.get('https://api.coingecko.com/api/v3/coins/list')\n        all_coins = r.json()\n        # First pass: generate & compare normalized symbol/name, and then select the most pertinent\n        for coin in all_coins:\n            normalized = coingecko_normalize_all(coin)\n            intermediate[normalized].append(coin)\n            # Above line keeps together the coins having the same normalized symbol.\n            # To reduce collision, the coin['name'] is sometimes used in lieu of the coin['symbol'].\n            # The coin['name'] is not capitalized because lower case letters may be meaningful: cETH, yUSD, DATx, zLOT\n    except Exception as why:\n        raise_failure_explanation('COINGECKO', why, {\"\": r})\n\n    final = coingecko_second_pass(intermediate)\n    return coingecko_third_pass(final)\n\n\ndef coingecko_second_pass(intermediate: Dict[str, List[dict]]) -> Dict[str, List[dict]]:\n    # Second pass: fixes most of the symbol collisions\n    final = defaultdict(list)\n    for normalized, coins in intermediate.items():\n        if len(coins) == 1:\n            final[normalized].append(coins[0])\n            continue\n        set_normalized = False\n        for i in range(len(coins)):\n            if normalized == coins[i]['nn']:\n                coin = coins.pop(i)\n                final[normalized].append(coin)\n                set_normalized = True\n                break\n        rest: List[dict] = []\n        for coin in coins:\n            if '%' in coin['name']:\n                if len(coins) == 1:\n                    n = coin['ns']\n                else:\n                    n = coingecko_normalize_name(coin['id'])\n                final[n].append(coin)\n            else:\n                rest.append(coin)\n        if not rest:\n            continue\n        if not set_normalized:\n            rest.sort(key=lambda coin: len(coin['nn']), reverse=True)  # sort by the length of the normalized name\n            coin = rest.pop(0)\n            final[normalized].append(coin)\n        for coin in rest:\n            if coin['nn'] not in intermediate:\n                n = coin['nn']\n            elif coin.get('reduced-name'):\n                n = coingecko_normalize_name(coin['name'])\n            else:\n                n = coingecko_normalize_name(coin['id'])\n            final[n].append(coin)\n    return final\n\n\ndef coingecko_third_pass(final: Dict[str, List[dict]]) -> Dict[str, str]:\n    # Third pass: fixes some remaining collisions and fills the result\n    symbols = {}\n    for normalized, coins in final.items():\n        if len(coins) == 1:\n            symbols[normalized] = coins[0]['id']\n            continue\n        set_normalized = False\n        for i in range(len(coins)):\n            if normalized == coins[i]['nn']:\n                coin = coins.pop(i)\n                symbols[normalized] = coin['id']\n                set_normalized = True\n                break\n        rest: List[dict] = []\n        for coin in coins:\n            if '%' in coin['name']:\n                if len(coins) == 1:\n                    n = coin['ns']\n                else:\n                    n = coingecko_normalize_name(coin['id'])\n                symbols[n] = coin['id']\n            else:\n                rest.append(coin)\n        if not rest:\n            continue\n        if not set_normalized:\n            rest.sort(key=lambda coin: len(coin['nn']), reverse=True)  # sort by the length of the normalized name\n            coin = rest.pop(0)\n            symbols[normalized] = coin['id']\n        for coin in rest:\n            if coin['nn'] not in final:\n                n = coin['nn']\n            elif coin.get('reduced-name'):\n                n = coingecko_normalize_name(coin['name'])\n            else:\n                n = coingecko_normalize_name(coin['id'])\n            symbols[n] = coin['id']\n    return symbols\n\n\ndef whale_alert_coins(key_id: str) -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get(f'https://api.whale-alert.io/v1/status?api_key={key_id}')\n        # Same symbols, but on different blockchains (for instance USDT), are naturally overwritten.\n        return {s.upper(): s for b in r.json()['blockchains'] for s in b['symbols'] if s}\n    except Exception as why:\n        raise_failure_explanation('WHALES_ALERT', why, {\"\": r})\n\n\n_exchange_function_map = {\n    BITFINEX: bitfinex_symbols,\n    BITFLYER: bitflyer_symbols,\n    COINBASE: coinbase_symbols,\n    GEMINI: gemini_symbols,\n    HITBTC: hitbtc_symbols,\n    POLONIEX: poloniex_symbols,\n    PROBIT: probit_symbols,\n    BITSTAMP: bitstamp_symbols,\n    KRAKEN: kraken_symbols,\n    KRAKEN + 'REST': kraken_rest_symbols,\n    BINANCE: binance_symbols,\n    BINANCE_US: binance_us_symbols,\n    BINANCE_FUTURES: binance_futures_symbols,\n    BINANCE_DELIVERY: binance_delivery_symbols,\n    BLOCKCHAIN: blockchain_symbols,\n    EXX: exx_symbols,\n    HUOBI: huobi_symbols,\n    HUOBI_DM: huobi_dm_symbols,\n    HUOBI_SWAP: huobi_swap_symbols,\n    OKCOIN: okcoin_symbols,\n    OKEX: okex_symbols,\n    BYBIT: bybit_symbols,\n    FTX: ftx_symbols,\n    FTX_US: ftx_us_symbols,\n    BITTREX: bittrex_symbols,\n    BITCOINCOM: bitcoincom_symbols,\n    BITMAX: bitmax_symbols,\n    UPBIT: upbit_symbols,\n    GATEIO: gateio_symbols,\n    BITMEX: bitmex_symbols,\n    DERIBIT: deribit_symbols,\n    KRAKEN_FUTURES: kraken_future_symbols,\n    COINGECKO: coingecko_symbols,\n    WHALE_ALERT: whale_alert_coins\n}\n",
        "source_code_len": 30534,
        "target_code": "associated with this software.\n'''\nfrom typing import Dict, Tuple\n\n\nclass _Symbols:\n    def __init__(self):\n        self.data = {}\n\n    def set(self, exchange: str, normalized: dict, exchange_info: dict):\n        self.data[exchange] = {}\n        self.data[exchange]['normalized'] = normalized\n        self.data[exchange]['info'] = exchange_info\n\n    def get(self, exchange: str) -> Tuple[Dict, Dict]:\n        return self.data[exchange]['normalized'], self.data[exchange]['info']\n\n    def populated(self, exchange: str) -> bool:\n        return exchange in self.data\n\n\nSymbols = _Symbols()\n",
        "target_code_len": 588,
        "diff_format": "@@ -5,845 +5,22 @@\n associated with this software.\n+'''\n+from typing import Dict, Tuple\n \n \n-Symbol generation code for exchanges\n-'''\n+class _Symbols:\n+    def __init__(self):\n+        self.data = {}\n \n-import logging\n-import string\n-import time\n-from collections import defaultdict\n-from typing import Dict, List, Optional, Tuple\n+    def set(self, exchange: str, normalized: dict, exchange_info: dict):\n+        self.data[exchange] = {}\n+        self.data[exchange]['normalized'] = normalized\n+        self.data[exchange]['info'] = exchange_info\n \n-import requests\n-from requests import Response\n+    def get(self, exchange: str) -> Tuple[Dict, Dict]:\n+        return self.data[exchange]['normalized'], self.data[exchange]['info']\n \n-from cryptofeed.defines import *\n+    def populated(self, exchange: str) -> bool:\n+        return exchange in self.data\n \n \n-LOG = logging.getLogger('feedhandler')\n-\n-SYMBOL_SEP = '-'\n-\n-_symbols_retrieval_cache: Dict[str, Dict[str, str]] = {}\n-_exchange_info = defaultdict(lambda: defaultdict(dict))\n-\n-\n-_kraken_futures_product_type = {\n-    'FI': 'Inverse Futures',\n-    'FV': 'Vanilla Futures',\n-    'PI': 'Perpetual Inverse Futures',\n-    'PV': 'Perpetual Vanilla Futures',\n-    'IN': 'Real Time Index',\n-    'RR': 'Reference Rate',\n-}\n-\n-\n-def raise_failure_explanation(feed_id: str, exception: BaseException, responses: Dict[str, Optional[Response]]):\n-    LOG.critical('%s: encountered %r while processing response from exchange API', feed_id, exception)\n-    if len(responses) > 1:\n-        LOG.critical('%s: content of one of the %s responses was unexpected', feed_id, len(responses))\n-    for url, r in responses.items():\n-        if url:\n-            LOG.critical('%s: requested URL: %s', feed_id, url)\n-        if r:\n-            LOG.critical('%s: unexpected response: %s', feed_id, r.text)\n-    raise ValueError(f'Cryptofeed stopped because of an unexpected response from {feed_id}') from exception\n-\n-\n-def set_symbol_separator(separator: str):\n-    global SYMBOL_SEP\n-    SYMBOL_SEP = separator\n-\n-\n-def get_symbol_separator() -> str:\n-    global SYMBOL_SEP\n-    return SYMBOL_SEP\n-\n-\n-def gen_symbols(exchange: str, key_id=None) -> Dict[str, str]:\n-    if exchange not in _symbols_retrieval_cache:\n-        LOG.info(\"%s: Getting list of symbols\", exchange)\n-        symbols = _exchange_function_map[exchange](key_id) if key_id else _exchange_function_map[exchange]()\n-        LOG.info(\"%s: %s symbols\", exchange, len(symbols))\n-\n-        # log all retrieved symbols using debug level\n-        for normalized, exch_sym in sorted(symbols.items()):\n-            LOG.debug('%s: id-from-exch -> normalized: %-35s-> %s', exchange, exch_sym, normalized)\n-\n-        _symbols_retrieval_cache[exchange] = symbols\n-    return _symbols_retrieval_cache[exchange]\n-\n-\n-def _binance_symbols(endpoint: str, exchange: str):\n-    r = None\n-    try:\n-        ret = {}\n-        r = requests.get(endpoint)\n-        for symbol in r.json()['symbols']:\n-            if symbol.get('status', 'TRADING') != \"TRADING\":\n-                continue\n-            if symbol.get('contractStatus', 'TRADING') != \"TRADING\":\n-                continue\n-            split = len(symbol['baseAsset'])\n-            normalized = symbol['symbol'][:split] + SYMBOL_SEP + symbol['symbol'][split:]\n-            ret[normalized] = symbol['symbol']\n-            _exchange_info[exchange]['tick_size'][normalized] = symbol['filters'][0]['tickSize']\n-            if \"contractType\" in symbol:\n-                _exchange_info[exchange]['contract_type'][normalized] = symbol['contractType']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation(exchange, why, {endpoint: r})\n-\n-\n-def binance_symbols() -> Dict[str, str]:\n-    return _binance_symbols('https://api.binance.com/api/v3/exchangeInfo', BINANCE)\n-\n-\n-def binance_us_symbols() -> Dict[str, str]:\n-    return _binance_symbols('https://api.binance.us/api/v3/exchangeInfo', BINANCE_US)\n-\n-\n-def binance_futures_symbols() -> Dict[str, str]:\n-    base = _binance_symbols('https://fapi.binance.com/fapi/v1/exchangeInfo', BINANCE_FUTURES)\n-    add = {}\n-    for symbol, orig in base.items():\n-        if \"_\" in orig:\n-            continue\n-        add[f\"{symbol}-PINDEX\"] = f\"p{orig}\"\n-    base.update(add)\n-    return base\n-\n-\n-def binance_delivery_symbols() -> Dict[str, str]:\n-    return _binance_symbols('https://dapi.binance.com/dapi/v1/exchangeInfo', BINANCE_DELIVERY)\n-\n-\n-def bitfinex_symbols() -> Dict[str, str]:\n-    # doc: https://docs.bitfinex.com/docs/ws-general#supported-pairs\n-    r1 = r2 = None\n-    try:\n-        r1 = requests.get('https://api.bitfinex.com/v2/tickers?symbols=ALL')\n-        r2 = requests.get('https://api-pub.bitfinex.com/v2/conf/pub:map:currency:sym')\n-        tickers: List[List[str]] = r1.json()\n-        norm: List[Tuple[str, str]] = r2.json()[0]\n-        norm: Dict[str, str] = dict(norm)\n-        for k, v in dict(norm).items():\n-            if k[-2:] == 'F0' or '-' in v:  # Do not convert BTCF0 -> BTC or PBTCETH -> PBTC-ETH\n-                del norm[k]\n-        norm['BCHN'] = 'BCH'  # Bitfinex uses BCHN, other exchanges use BCH\n-\n-        ret = {}\n-        for symbol in [t[0] for t in tickers]:\n-            if symbol[0] == 'f':\n-                normalized = norm.get(symbol[1:], symbol[1:])\n-            else:\n-                if len(symbol) == 7:\n-                    base, quote = symbol[1:4], symbol[4:]\n-                else:\n-                    base, quote = symbol[1:].split(':')\n-                    assert ':' in symbol\n-                normalized = norm.get(base, base) + SYMBOL_SEP + norm.get(quote, quote)\n-            ret[normalized.upper()] = symbol\n-        return ret\n-    except ValueError as why:\n-        raise_failure_explanation('BITFINEX', why, {\"tickers?symbols=ALL\": r1, \"pub:map:currency:sym\": r2})\n-\n-\n-def bitflyer_symbols() -> Dict[str, str]:\n-    endpoint = r = None\n-    try:\n-        ret = {}\n-        endpoints = ['https://api.bitflyer.com/v1/getmarkets/eu', 'https://api.bitflyer.com/v1/getmarkets/usa', 'https://api.bitflyer.com/v1/getmarkets']\n-        for endpoint in endpoints:\n-            r = requests.get(endpoint)\n-            for entry in r.json():\n-                normalized = entry['product_code'].replace(\"_\", SYMBOL_SEP)\n-                ret[normalized] = entry['product_code']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('BITFLYER', why, {endpoint: r})\n-\n-\n-def bybit_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.bybit.com/v2/public/symbols')\n-        ret = {}\n-        for symbol in r.json()['result']:\n-            quote = symbol['quote_currency']\n-            if not symbol['name'].endswith(quote):\n-                base, contract = symbol['name'].split(quote)\n-                normalized = f\"{base}{SYMBOL_SEP}{quote}-{contract}\"\n-            else:\n-                normalized = f\"{symbol['base_currency']}{SYMBOL_SEP}{quote}\"\n-            ret[normalized] = symbol['name']\n-            _exchange_info[BYBIT]['tick_size'][normalized] = symbol['price_filter']['tick_size']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('BYBIT', why, {\"\": r})\n-\n-\n-def _ftx_helper(endpoint: str, exchange: str):\n-    r = None\n-    try:\n-        r = requests.get(endpoint)\n-        ret = {}\n-        for data in r.json()['result']:\n-            normalized = data['name'].replace(\"/\", SYMBOL_SEP)\n-            symbol = data['name']\n-            ret[normalized] = symbol\n-            _exchange_info[exchange]['tick_size'][normalized] = data['priceIncrement']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation(exchange, why, {endpoint: r})\n-\n-\n-def ftx_symbols() -> Dict[str, str]:\n-    return _ftx_helper('https://ftx.com/api/markets', FTX)\n-\n-\n-def ftx_us_symbols() -> Dict[str, str]:\n-    return _ftx_helper('https://ftx.us/api/markets', FTX_US)\n-\n-\n-def coinbase_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.pro.coinbase.com/products')\n-        ret = {}\n-        for data in r.json():\n-            normalized = data['id'].replace(\"-\", SYMBOL_SEP)\n-            ret[normalized] = data['id']\n-            _exchange_info[COINBASE]['tick_size'][normalized] = data['quote_increment']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('COINBASE', why, {\"\": r})\n-\n-\n-def gemini_symbols(*args) -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.gemini.com/v1/symbols')\n-        ret = {}\n-        for symbol in r.json():\n-            std = f\"{symbol[:-3]}{SYMBOL_SEP}{symbol[-3:]}\"\n-            std = std.upper()\n-            ret[std] = symbol.upper()\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('GEMINI', why, {\"\": r})\n-\n-\n-def hitbtc_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        ret = {}\n-        r = requests.get('https://api.hitbtc.com/api/2/public/symbol')\n-        for symbol in r.json():\n-            split = len(symbol['baseCurrency'])\n-            normalized = symbol['id'][:split] + SYMBOL_SEP + symbol['id'][split:]\n-            ret[normalized] = symbol['id']\n-            _exchange_info[HITBTC]['tick_size'][normalized] = symbol['tickSize']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('HITBTC', why, {\"\": r})\n-\n-\n-def poloniex_id_symbol_mapping():\n-    r = None\n-    try:\n-        r = requests.get('https://poloniex.com/public?command=returnTicker')\n-        symbols = r.json()\n-        ret = {}\n-        for symbol in symbols:\n-            ret[symbols[symbol]['id']] = symbol\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('POLONIEX', why, {\"\": r})\n-\n-\n-def poloniex_symbols() -> Dict[str, str]:\n-    ret = {}\n-    for _, value in poloniex_id_symbol_mapping().items():\n-        std = value.replace(\"STR\", \"XLM\")\n-        quote, base = std.split(\"_\")\n-        ret[quote + SYMBOL_SEP + base] = value\n-    return ret\n-\n-\n-def bitstamp_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://www.bitstamp.net/api/v2/trading-pairs-info/')\n-        ret = {}\n-        for data in r.json():\n-            normalized = data['name'].replace(\"/\", SYMBOL_SEP)\n-            symbol = data['url_symbol']\n-            ret[normalized] = symbol\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('BITSTAMP', why, {\"\": r})\n-\n-\n-def kraken_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.kraken.com/0/public/AssetPairs')\n-        data = r.json()\n-        ret = {}\n-        for symbol in data['result']:\n-            if 'wsname' not in data['result'][symbol] or '.d' in symbol:\n-                # https://blog.kraken.com/post/259/introducing-the-kraken-dark-pool/\n-                # .d is for dark pool symbols\n-                continue\n-\n-            base, quote = data['result'][symbol]['wsname'].split(\"/\")\n-\n-            normalized = f\"{base}{SYMBOL_SEP}{quote}\"\n-            exch = data['result'][symbol]['wsname']\n-            normalized = normalized.replace('XBT', 'BTC')\n-            normalized = normalized.replace('XDG', 'DOG')\n-            ret[normalized] = exch\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('KRAKEN', why, {\"\": r})\n-\n-\n-def kraken_rest_symbols() -> Dict[str, str]:\n-    return {normalized: exchange.replace(\"/\", \"\") for normalized, exchange in kraken_symbols().items()}\n-\n-\n-def exx_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.exx.com/data/v1/tickers')\n-        exchange = [key.upper() for key in r.json().keys()]\n-        symbols = [key.replace(\"_\", SYMBOL_SEP) for key in exchange]\n-        return dict(zip(symbols, exchange))\n-    except Exception as why:\n-        raise_failure_explanation('EXX', why, {\"\": r})\n-\n-\n-def huobi_common_symbols(url: str):\n-    r = None\n-    try:\n-        r = requests.get(url)\n-        ret = {}\n-        for e in r.json()['data']:\n-            if e['state'] == 'offline':\n-                continue\n-            normalized = f\"{e['base-currency'].upper()}{SYMBOL_SEP}{e['quote-currency'].upper()}\"\n-            symbol = f\"{e['base-currency']}{e['quote-currency']}\"\n-            ret[normalized] = symbol\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('HUOBI', why, {url: r})\n-\n-\n-def huobi_symbols() -> Dict[str, str]:\n-    return huobi_common_symbols('https://api.huobi.pro/v1/common/symbols')\n-\n-\n-def huobi_us_symbols() -> Dict[str, str]:\n-    return huobi_common_symbols('https://api.huobi.com/v1/common/symbols')\n-\n-\n-def huobi_dm_symbols() -> Dict[str, str]:\n-    \"\"\"\n-    Mapping is, for instance: {\"BTC_CW\":\"BTC190816\"}\n-    See comments in exchange/huobi_dm.py\n-    \"\"\"\n-    mapping = {\n-        \"this_week\": \"CW\",\n-        \"next_week\": \"NW\",\n-        \"quarter\": \"CQ\",\n-        \"next_quarter\": \"NQ\"\n-    }\n-    r = None\n-    try:\n-        r = requests.get('https://www.hbdm.com/api/v1/contract_contract_info')\n-        symbols = {}\n-        for e in r.json()['data']:\n-            symbols[f\"{e['symbol']}_{mapping[e['contract_type']]}\"] = e['contract_code']\n-            _exchange_info[HUOBI_DM]['tick_size'][e['contract_code']] = e['price_tick']\n-            _exchange_info[HUOBI_DM]['short_code_mappings'][f\"{e['symbol']}_{mapping[e['contract_type']]}\"] = e['contract_code']\n-        return symbols\n-    except Exception as why:\n-        raise_failure_explanation('HUOBI_DM', why, {\"\": r})\n-\n-\n-def huobi_swap_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.hbdm.com/swap-api/v1/swap_contract_info')\n-        symbols = {}\n-        for e in r.json()['data']:\n-            symbols[e['contract_code']] = e['contract_code']\n-            _exchange_info[HUOBI_SWAP]['tick_size'][e['contract_code']] = e['price_tick']\n-        return symbols\n-    except Exception as why:\n-        raise_failure_explanation('HUOBI_SWAP', why, {\"\": r})\n-\n-\n-def okcoin_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://www.okcoin.com/api/spot/v3/instruments')\n-        ret = {}\n-        for e in r.json():\n-            ret[e['instrument_id']] = e['instrument_id']\n-            _exchange_info[OKCOIN]['tick_size'][e['instrument_id']] = e['tick_size']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('OKCOIN', why, {\"\": r})\n-\n-\n-def okex_symbols(*args) -> Dict[str, str]:\n-    urls = ['https://www.okex.com/api/spot/v3/instruments',\n-            'https://www.okex.com/api/swap/v3/instruments',\n-            'https://www.okex.com/api/futures/v3/instruments']\n-    urls = urls + okex_compute_option_urls_from_underlyings()\n-\n-    symbols: Dict[str, str] = {}\n-    for u in urls:\n-        time.sleep(0.2)\n-        symbols.update(okex_symbols_from_one_url(u))\n-\n-    for symbol in symbols:\n-        instrument_type = 'futures'\n-        dash_count = symbol.count(get_symbol_separator())\n-        if dash_count == 1:  # BTC-USDT\n-            instrument_type = 'spot'\n-        if dash_count == 4:  # BTC-USD-201225-35000-P\n-            instrument_type = 'option'\n-        if symbol[-4:] == \"SWAP\":  # BTC-USDT-SWAP\n-            instrument_type = 'swap'\n-\n-        _exchange_info[OKEX]['instrument_type'][symbol] = instrument_type\n-\n-    return symbols\n-\n-\n-def okex_compute_option_urls_from_underlyings() -> List[str]:\n-    url = 'https://www.okex.com/api/option/v3/underlying'\n-    r = None\n-    try:\n-        r = requests.get(url)\n-        return [f'https://www.okex.com/api/option/v3/instruments/{underlying}' for underlying in r.json()]\n-    except Exception as why:\n-        raise_failure_explanation('OKEX', why, {url: r})\n-\n-\n-def okex_symbols_from_one_url(url: str) -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get(url)\n-        ret = {}\n-        for e in r.json():\n-            ret[e['instrument_id']] = e['instrument_id']\n-            _exchange_info[OKEX]['tick_size'][e['instrument_id']] = e['tick_size']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('OKEX', why, {url: r})\n-\n-\n-def bittrex_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.bittrex.com/api/v1.1/public/getmarkets')\n-        r = r.json()['result']\n-        return {f\"{e['MarketCurrency']}{SYMBOL_SEP}{e['BaseCurrency']}\": e['MarketName'] for e in r if e['IsActive']}\n-    except Exception as why:\n-        raise_failure_explanation('BITTREX', why, {\"\": r})\n-\n-\n-def bitcoincom_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.exchange.bitcoin.com/api/2/public/symbol')\n-        return {f\"{data['baseCurrency']}{SYMBOL_SEP}{data['quoteCurrency'].replace('USD', 'USDT')}\": data['id'] for data in r.json()}\n-    except Exception as why:\n-        raise_failure_explanation('BITCOINCOM', why, {\"\": r})\n-\n-\n-def bitmax_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://bitmax.io/api/pro/v1/products')\n-        ret = {}\n-        for entry in r.json()['data']:\n-            # Only \"Normal\" status symbols are tradeable\n-            if entry['status'] == 'Normal':\n-                normalized = f\"{entry['baseAsset']}{SYMBOL_SEP}{entry['quoteAsset']}\"\n-                ret[normalized] = entry['symbol']\n-                _exchange_info[BITMAX]['tick_size'][normalized] = entry['tickSize']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('BITMAX', why, {\"\": r})\n-\n-\n-def upbit_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.upbit.com/v1/market/all')\n-        return {f\"{data['market'].split('-')[1]}{SYMBOL_SEP}{data['market'].split('-')[0]}\": data['market'] for data in r.json()}\n-    except Exception as why:\n-        raise_failure_explanation('UPBIT', why, {\"\": r})\n-\n-\n-def blockchain_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get(\"https://api.blockchain.com/mercury-gateway/v1/instruments\")\n-        return {data[\"symbol\"].replace(\"-\", SYMBOL_SEP): data[\"symbol\"] for data in r.json()}\n-    except Exception as why:\n-        raise_failure_explanation('BLOCKCHAIN', why, {\"\": r})\n-\n-\n-def gateio_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get(\"https://api.gateio.ws/api/v4/spot/currency_pairs\")\n-        return {data[\"id\"].replace(\"_\", SYMBOL_SEP): data['id'] for data in r.json()}\n-    except Exception as why:\n-        raise_failure_explanation('GATEIO', why, {\"\": r})\n-\n-\n-def bitmex_symbols() -> Dict[str, str]:\n-    r = None\n-    ret = {}\n-    try:\n-        r = requests.get(\"https://www.bitmex.com/api/v1/instrument/active\")\n-        for entry in r.json():\n-            components = []\n-            components.append(entry['rootSymbol'])\n-            components.append(entry['quoteCurrency'])\n-\n-            if entry['expiry']:\n-                components.append(entry['symbol'][-3:])\n-\n-            normalized = SYMBOL_SEP.join(components)\n-            normalized = normalized.replace(\"XBT\", \"BTC\")\n-            ret[normalized] = entry['symbol']\n-            _exchange_info[BITMEX]['tick_size'][normalized] = entry['tickSize']\n-\n-            if entry['expiry']:\n-                _exchange_info[BITMEX]['expiry'][normalized] = entry['expiry']\n-\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('BITMEX', why, {\"\": r})\n-\n-\n-def deribit_symbols() -> Dict[str, str]:\n-    url = r = None\n-    ret = {}\n-    try:\n-        # TODO: get currencies from https://www.deribit.com/api/v2/public/get_currencies\n-        currencies = ['BTC', 'ETH']\n-        for c in currencies:\n-            url = f\"https://www.deribit.com/api/v2/public/get_instruments?currency={c}&expired=false\"\n-            r = requests.get(url)\n-            for entry in r.json()['result']:\n-                split = entry['instrument_name'].split(\"-\")\n-                normalized = split[0] + SYMBOL_SEP + entry['quote_currency'] + \"-\" + '-'.join(split[1:])\n-                ret[normalized] = entry['instrument_name']\n-                _exchange_info[DERIBIT]['tick_size'][normalized] = entry['tick_size']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('DERIBIT', why, {url: r})\n-\n-\n-def kraken_future_symbols() -> Dict[str, str]:\n-    r = None\n-    ret = {}\n-    try:\n-        r = requests.get('https://futures.kraken.com/derivatives/api/v3/instruments')\n-        data = r.json()['instruments']\n-        for entry in data:\n-            if not entry['tradeable']:\n-                continue\n-            normalized = entry['symbol'].upper().replace(\"_\", \"-\")\n-            symbol = normalized[3:6] + SYMBOL_SEP + normalized[6:9]\n-            normalized = normalized.replace(normalized[3:9], symbol)\n-            normalized = normalized.replace('XBT', 'BTC')\n-\n-            _exchange_info[KRAKEN_FUTURES]['tick_size'][normalized] = entry['tickSize']\n-            _exchange_info[KRAKEN_FUTURES]['contract_size'][normalized] = entry['contractSize']\n-            _exchange_info[KRAKEN_FUTURES]['underlying'][normalized] = entry['underlying']\n-            _exchange_info[KRAKEN_FUTURES]['product_type'][normalized] = _kraken_futures_product_type[normalized[:2]]\n-            ret[normalized] = entry['symbol']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('KRAKEN_FUTURES', why, {\"\": r})\n-\n-\n-def probit_symbols() -> Dict[str, str]:\n-    # doc: https://docs-en.probit.com/reference-link/market\n-    r = None\n-    try:\n-        r = requests.get('https://api.probit.com/api/exchange/v1/market')\n-        return {entry['id']: entry['id'] for entry in r.json()['data']}\n-    except Exception as why:\n-        raise_failure_explanation('PROBIT', why, {\"\": r})\n-\n-\n-def coingecko_normalize_symbol(symbol: str) -> str:\n-    # keep digits, letters and dots, replace others by space\n-    symbol = ''.join(c if c.isalnum() or c in ('.', '+') else ' ' for c in symbol)\n-    return coingecko_normalize(symbol.upper())\n-\n-\n-def coingecko_normalize_name(name: str) -> str:\n-    # keep digits and letters, replace others by space (except when only composed by upper case letters, digits and dots)\n-    if not all(c.isupper() or c.isdigit() or c == '.' for c in name):\n-        name = ''.join(c if c.isalnum() else ' ' for c in name)\n-    return coingecko_normalize(name)\n-\n-\n-def coingecko_normalize(sym: str) -> str:\n-    sym = sym.strip()\n-    # do not concatenate numbers => separate them with a dot\n-    sym = list(sym)\n-    if len(sym) > 4:\n-        for i in range(2, len(sym) - 1):\n-            if sym[i] == ' ' and sym[i - 1].isdigit() and sym[i + 1].isdigit():\n-                sym[i] = '.'\n-    sym = ''.join(sym)\n-    # concatenate space-separated words => use CamelCase to distinguish the words\n-    if ' ' in sym:\n-        if sum(c.islower() for c in sym):  # if there is at least one lower case letter\n-            sym = ' '.join(word[0].upper() + word[1:] for word in sym.split())  # Just capitalize initial letter of each word\n-        else:  # CoinGecko may provide full upper-case as for \"THE STONE COIN\"\n-            sym = string.capwords(sym)  # capwords converts \"THE STONE COIN\" to \"The Stone Coin\"\n-        sym = sym.replace(' ', '')  # concatenate words\n-    return sym\n-\n-\n-def is_name_short(coin: dict) -> bool:\n-    \"\"\"return True if the coin name is enough short compared to the coin symbol.\"\"\"\n-    return len(coin['name']) <= max(5, len(coin['symbol']) + 1)\n-\n-\n-def has_many_caps(name: str) -> bool:\n-    \"\"\"return True if the symbol contains enough upper case letters, False if empty.\"\"\"\n-    return str and sum(c.islower() for c in name) < (len(name) / 2)\n-\n-\n-def coingecko_normalize_all(coin: dict):\n-    SYMBOL_TO_NORMALIZED = {'miota': 'IOTA'}\n-    normalized = SYMBOL_TO_NORMALIZED.get(coin['symbol'])\n-    if normalized:\n-        coin['ns'] = coin['nn'] = normalized\n-        return normalized\n-\n-    # ns = normalized symbol, nn = normalized name\n-    coin['ns'] = coingecko_normalize_symbol(coin['symbol'])\n-\n-    ID_SUFFIX = '-bitcoin-token'\n-    if coin['id'][-len(ID_SUFFIX):] == ID_SUFFIX:\n-        coin['nn'] = 'BTC' + coin['ns']\n-        return coin['nn']\n-\n-    name = coin['name']\n-\n-    prefixes = ('The ', 'the ')\n-    for p in prefixes:\n-        if name[:len(p)] == p:\n-            coin['reduced-name'] = True\n-            name = name[len(p):]\n-            break\n-\n-    suffixes = ('coin', 'coins', 'money', 'finance', 'protocol', 'reward', 'rewards', 'token')\n-    for s in suffixes:\n-        if len(name) > len(s) and name[-len(s):].lower() == s:\n-            # but keep suffix when lower-case concatenated\n-            if name[-len(s)].islower() and name[-len(s) - 1] != ' ':\n-                continue\n-            # also keep suffix to avoid confusing nam: \"Bitcoin Token\" -> \"Bitcoin\"\n-            if name[:-len(s)].strip().lower() == 'bitcoin':\n-                continue\n-            coin['reduced-name'] = True\n-            name = name[:-len(s)]\n-            break\n-\n-    coin['nn'] = coingecko_normalize_name(name)\n-\n-    if len(coin['nn']) < len(coin['ns']):\n-        if 'reduced-name' in coin:\n-            coin['reduced-name'] = False\n-            name = coin['name']\n-            coin['nn'] = coingecko_normalize_name(name)\n-        elif not has_many_caps(name):\n-            return coin['ns']\n-\n-    if not coin['ns']:  # coin['symbol'] may be an emoji that is striped when normalized\n-        return coin['nn']\n-\n-    if coin.get('reduced-name') and coin['ns'].upper() != coin['nn'].upper():\n-        return coin['ns']\n-\n-    i = coin['nn'].find('.')  # if there is a dot in normalized name => prefer the normalized symbol\n-    if i >= 0:\n-        if i > 1 and coin['nn'][i - 1].isdigit() and coin['nn'][i + 1].isdigit():\n-            pass  # except when the dot separates digits\n-        else:\n-            return coin['ns']\n-\n-    if is_name_short(coin) and has_many_caps(name):\n-        return coin['nn']\n-\n-    if 1.5 * len(coin['ns']) > len(coin['nn']) and any(c.islower() for c in coin['ns']):\n-        return coin['nn']\n-\n-    return coin['ns']\n-\n-\n-def coingecko_symbols() -> Dict[str, str]:\n-    r = None\n-    intermediate = defaultdict(list)\n-    try:\n-        r = requests.get('https://api.coingecko.com/api/v3/coins/list')\n-        all_coins = r.json()\n-        # First pass: generate & compare normalized symbol/name, and then select the most pertinent\n-        for coin in all_coins:\n-            normalized = coingecko_normalize_all(coin)\n-            intermediate[normalized].append(coin)\n-            # Above line keeps together the coins having the same normalized symbol.\n-            # To reduce collision, the coin['name'] is sometimes used in lieu of the coin['symbol'].\n-            # The coin['name'] is not capitalized because lower case letters may be meaningful: cETH, yUSD, DATx, zLOT\n-    except Exception as why:\n-        raise_failure_explanation('COINGECKO', why, {\"\": r})\n-\n-    final = coingecko_second_pass(intermediate)\n-    return coingecko_third_pass(final)\n-\n-\n-def coingecko_second_pass(intermediate: Dict[str, List[dict]]) -> Dict[str, List[dict]]:\n-    # Second pass: fixes most of the symbol collisions\n-    final = defaultdict(list)\n-    for normalized, coins in intermediate.items():\n-        if len(coins) == 1:\n-            final[normalized].append(coins[0])\n-            continue\n-        set_normalized = False\n-        for i in range(len(coins)):\n-            if normalized == coins[i]['nn']:\n-                coin = coins.pop(i)\n-                final[normalized].append(coin)\n-                set_normalized = True\n-                break\n-        rest: List[dict] = []\n-        for coin in coins:\n-            if '%' in coin['name']:\n-                if len(coins) == 1:\n-                    n = coin['ns']\n-                else:\n-                    n = coingecko_normalize_name(coin['id'])\n-                final[n].append(coin)\n-            else:\n-                rest.append(coin)\n-        if not rest:\n-            continue\n-        if not set_normalized:\n-            rest.sort(key=lambda coin: len(coin['nn']), reverse=True)  # sort by the length of the normalized name\n-            coin = rest.pop(0)\n-            final[normalized].append(coin)\n-        for coin in rest:\n-            if coin['nn'] not in intermediate:\n-                n = coin['nn']\n-            elif coin.get('reduced-name'):\n-                n = coingecko_normalize_name(coin['name'])\n-            else:\n-                n = coingecko_normalize_name(coin['id'])\n-            final[n].append(coin)\n-    return final\n-\n-\n-def coingecko_third_pass(final: Dict[str, List[dict]]) -> Dict[str, str]:\n-    # Third pass: fixes some remaining collisions and fills the result\n-    symbols = {}\n-    for normalized, coins in final.items():\n-        if len(coins) == 1:\n-            symbols[normalized] = coins[0]['id']\n-            continue\n-        set_normalized = False\n-        for i in range(len(coins)):\n-            if normalized == coins[i]['nn']:\n-                coin = coins.pop(i)\n-                symbols[normalized] = coin['id']\n-                set_normalized = True\n-                break\n-        rest: List[dict] = []\n-        for coin in coins:\n-            if '%' in coin['name']:\n-                if len(coins) == 1:\n-                    n = coin['ns']\n-                else:\n-                    n = coingecko_normalize_name(coin['id'])\n-                symbols[n] = coin['id']\n-            else:\n-                rest.append(coin)\n-        if not rest:\n-            continue\n-        if not set_normalized:\n-            rest.sort(key=lambda coin: len(coin['nn']), reverse=True)  # sort by the length of the normalized name\n-            coin = rest.pop(0)\n-            symbols[normalized] = coin['id']\n-        for coin in rest:\n-            if coin['nn'] not in final:\n-                n = coin['nn']\n-            elif coin.get('reduced-name'):\n-                n = coingecko_normalize_name(coin['name'])\n-            else:\n-                n = coingecko_normalize_name(coin['id'])\n-            symbols[n] = coin['id']\n-    return symbols\n-\n-\n-def whale_alert_coins(key_id: str) -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get(f'https://api.whale-alert.io/v1/status?api_key={key_id}')\n-        # Same symbols, but on different blockchains (for instance USDT), are naturally overwritten.\n-        return {s.upper(): s for b in r.json()['blockchains'] for s in b['symbols'] if s}\n-    except Exception as why:\n-        raise_failure_explanation('WHALES_ALERT', why, {\"\": r})\n-\n-\n-_exchange_function_map = {\n-    BITFINEX: bitfinex_symbols,\n-    BITFLYER: bitflyer_symbols,\n-    COINBASE: coinbase_symbols,\n-    GEMINI: gemini_symbols,\n-    HITBTC: hitbtc_symbols,\n-    POLONIEX: poloniex_symbols,\n-    PROBIT: probit_symbols,\n-    BITSTAMP: bitstamp_symbols,\n-    KRAKEN: kraken_symbols,\n-    KRAKEN + 'REST': kraken_rest_symbols,\n-    BINANCE: binance_symbols,\n-    BINANCE_US: binance_us_symbols,\n-    BINANCE_FUTURES: binance_futures_symbols,\n-    BINANCE_DELIVERY: binance_delivery_symbols,\n-    BLOCKCHAIN: blockchain_symbols,\n-    EXX: exx_symbols,\n-    HUOBI: huobi_symbols,\n-    HUOBI_DM: huobi_dm_symbols,\n-    HUOBI_SWAP: huobi_swap_symbols,\n-    OKCOIN: okcoin_symbols,\n-    OKEX: okex_symbols,\n-    BYBIT: bybit_symbols,\n-    FTX: ftx_symbols,\n-    FTX_US: ftx_us_symbols,\n-    BITTREX: bittrex_symbols,\n-    BITCOINCOM: bitcoincom_symbols,\n-    BITMAX: bitmax_symbols,\n-    UPBIT: upbit_symbols,\n-    GATEIO: gateio_symbols,\n-    BITMEX: bitmex_symbols,\n-    DERIBIT: deribit_symbols,\n-    KRAKEN_FUTURES: kraken_future_symbols,\n-    COINGECKO: coingecko_symbols,\n-    WHALE_ALERT: whale_alert_coins\n-}\n+Symbols = _Symbols()\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\n\nimport logging\nimport string\nimport time\nfrom collections import defaultdict\nfrom typing import Dict, List, Optional, Tuple\n\nimport requests\nfrom requests import Response\n\nfrom cryptofeed.defines import *\n\n\nLOG = logging.getLogger('feedhandler')\n\nSYMBOL_SEP = '-'\n\n_symbols_retrieval_cache: Dict[str, Dict[str, str]] = {}\n_exchange_info = defaultdict(lambda: defaultdict(dict))\n\n\n_kraken_futures_product_type = {\n    'FI': 'Inverse Futures',\n    'FV': 'Vanilla Futures',\n    'PI': 'Perpetual Inverse Futures',\n    'PV': 'Perpetual Vanilla Futures',\n    'IN': 'Real Time Index',\n    'RR': 'Reference Rate',\n}\n\n\ndef raise_failure_explanation(feed_id: str, exception: BaseException, responses: Dict[str, Optional[Response]]):\n    <IND>LOG.critical('%s: encountered %r while processing response from exchange API', feed_id, exception)\n    if len(responses) > 1:\n        <IND>LOG.critical('%s: content of one of the %s responses was unexpected', feed_id, len(responses))\n    <DED>for url, r in responses.items():\n        <IND>if url:\n            <IND>LOG.critical('%s: requested URL: %s', feed_id, url)\n        <DED>if r:\n            <IND>LOG.critical('%s: unexpected response: %s', feed_id, r.text)\n    <DED><DED>raise ValueError(f'Cryptofeed stopped because of an unexpected response from {feed_id}') from exception\n\n\n<DED>def set_symbol_separator(separator: str):\n    <IND>global SYMBOL_SEP\n    SYMBOL_SEP = separator\n\n\n<DED>def get_symbol_separator() -> str:\n    <IND>global SYMBOL_SEP\n    return SYMBOL_SEP\n\n\n<DED>def gen_symbols(exchange: str, key_id=None) -> Dict[str, str]:\n    <IND>if exchange not in _symbols_retrieval_cache:\n        <IND>LOG.info(\"%s: Getting list of symbols\", exchange)\n        symbols = _exchange_function_map[exchange](key_id) if key_id else _exchange_function_map[exchange]()\n        LOG.info(\"%s: %s symbols\", exchange, len(symbols))\n\n        # log all retrieved symbols using debug level\n        for normalized, exch_sym in sorted(symbols.items()):\n            <IND>LOG.debug('%s: id-from-exch -> normalized: %-35s-> %s', exchange, exch_sym, normalized)\n\n        <DED>_symbols_retrieval_cache[exchange] = symbols\n    <DED>return _symbols_retrieval_cache[exchange]\n\n\n<DED>def _binance_symbols(endpoint: str, exchange: str):\n    <IND>r = None\n    try:\n        <IND>ret = {}\n        r = requests.get(endpoint)\n        for symbol in r.json()['symbols']:\n            <IND>if symbol.get('status', 'TRADING') != \"TRADING\":\n                <IND>continue\n            <DED>if symbol.get('contractStatus', 'TRADING') != \"TRADING\":\n                <IND>continue\n            <DED>split = len(symbol['baseAsset'])\n            normalized = symbol['symbol'][:split] + SYMBOL_SEP + symbol['symbol'][split:]\n            ret[normalized] = symbol['symbol']\n            _exchange_info[exchange]['tick_size'][normalized] = symbol['filters'][0]['tickSize']\n            if \"contractType\" in symbol:\n                <IND>_exchange_info[exchange]['contract_type'][normalized] = symbol['contractType']\n        <DED><DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation(exchange, why, {endpoint: r})\n\n\n<DED><DED>def binance_symbols() -> Dict[str, str]:\n    <IND>return _binance_symbols('https://api.binance.com/api/v3/exchangeInfo', BINANCE)\n\n\n<DED>def binance_us_symbols() -> Dict[str, str]:\n    <IND>return _binance_symbols('https://api.binance.us/api/v3/exchangeInfo', BINANCE_US)\n\n\n<DED>def binance_futures_symbols() -> Dict[str, str]:\n    <IND>base = _binance_symbols('https://fapi.binance.com/fapi/v1/exchangeInfo', BINANCE_FUTURES)\n    add = {}\n    for symbol, orig in base.items():\n        <IND>if \"_\" in orig:\n            <IND>continue\n        <DED>add[f\"{symbol}-PINDEX\"] = f\"p{orig}\"\n    <DED>base.update(add)\n    return base\n\n\n<DED>def binance_delivery_symbols() -> Dict[str, str]:\n    <IND>return _binance_symbols('https://dapi.binance.com/dapi/v1/exchangeInfo', BINANCE_DELIVERY)\n\n\n<DED>def bitfinex_symbols() -> Dict[str, str]:\n    # doc: https://docs.bitfinex.com/docs/ws-general#supported-pairs\n    <IND>r1 = r2 = None\n    try:\n        <IND>r1 = requests.get('https://api.bitfinex.com/v2/tickers?symbols=ALL')\n        r2 = requests.get('https://api-pub.bitfinex.com/v2/conf/pub:map:currency:sym')\n        tickers: List[List[str]] = r1.json()\n        norm: List[Tuple[str, str]] = r2.json()[0]\n        norm: Dict[str, str] = dict(norm)\n        for k, v in dict(norm).items():\n            <IND>if k[-2:] == 'F0' or '-' in v:  # Do not convert BTCF0 -> BTC or PBTCETH -> PBTC-ETH\n                <IND>del norm[k]\n        <DED><DED>norm['BCHN'] = 'BCH'  # Bitfinex uses BCHN, other exchanges use BCH\n\n        ret = {}\n        for symbol in [t[0] for t in tickers]:\n            <IND>if symbol[0] == 'f':\n                <IND>normalized = norm.get(symbol[1:], symbol[1:])\n            <DED>else:\n                <IND>if len(symbol) == 7:\n                    <IND>base, quote = symbol[1:4], symbol[4:]\n                <DED>else:\n                    <IND>base, quote = symbol[1:].split(':')\n                    assert ':' in symbol\n                <DED>normalized = norm.get(base, base) + SYMBOL_SEP + norm.get(quote, quote)\n            <DED>ret[normalized.upper()] = symbol\n        <DED>return ret\n    <DED>except ValueError as why:\n        <IND>raise_failure_explanation('BITFINEX', why, {\"tickers?symbols=ALL\": r1, \"pub:map:currency:sym\": r2})\n\n\n<DED><DED>def bitflyer_symbols() -> Dict[str, str]:\n    <IND>endpoint = r = None\n    try:\n        <IND>ret = {}\n        endpoints = ['https://api.bitflyer.com/v1/getmarkets/eu', 'https://api.bitflyer.com/v1/getmarkets/usa', 'https://api.bitflyer.com/v1/getmarkets']\n        for endpoint in endpoints:\n            <IND>r = requests.get(endpoint)\n            for entry in r.json():\n                <IND>normalized = entry['product_code'].replace(\"_\", SYMBOL_SEP)\n                ret[normalized] = entry['product_code']\n        <DED><DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BITFLYER', why, {endpoint: r})\n\n\n<DED><DED>def bybit_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.bybit.com/v2/public/symbols')\n        ret = {}\n        for symbol in r.json()['result']:\n            <IND>quote = symbol['quote_currency']\n            if not symbol['name'].endswith(quote):\n                <IND>base, contract = symbol['name'].split(quote)\n                normalized = f\"{base}{SYMBOL_SEP}{quote}-{contract}\"\n            <DED>else:\n                <IND>normalized = f\"{symbol['base_currency']}{SYMBOL_SEP}{quote}\"\n            <DED>ret[normalized] = symbol['name']\n            _exchange_info[BYBIT]['tick_size'][normalized] = symbol['price_filter']['tick_size']\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BYBIT', why, {\"\": r})\n\n\n<DED><DED>def _ftx_helper(endpoint: str, exchange: str):\n    <IND>r = None\n    try:\n        <IND>r = requests.get(endpoint)\n        ret = {}\n        for data in r.json()['result']:\n            <IND>normalized = data['name'].replace(\"/\", SYMBOL_SEP)\n            symbol = data['name']\n            ret[normalized] = symbol\n            _exchange_info[exchange]['tick_size'][normalized] = data['priceIncrement']\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation(exchange, why, {endpoint: r})\n\n\n<DED><DED>def ftx_symbols() -> Dict[str, str]:\n    <IND>return _ftx_helper('https://ftx.com/api/markets', FTX)\n\n\n<DED>def ftx_us_symbols() -> Dict[str, str]:\n    <IND>return _ftx_helper('https://ftx.us/api/markets', FTX_US)\n\n\n<DED>def coinbase_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.pro.coinbase.com/products')\n        ret = {}\n        for data in r.json():\n            <IND>normalized = data['id'].replace(\"-\", SYMBOL_SEP)\n            ret[normalized] = data['id']\n            _exchange_info[COINBASE]['tick_size'][normalized] = data['quote_increment']\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('COINBASE', why, {\"\": r})\n\n\n<DED><DED>def gemini_symbols(*args) -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.gemini.com/v1/symbols')\n        ret = {}\n        for symbol in r.json():\n            <IND>std = f\"{symbol[:-3]}{SYMBOL_SEP}{symbol[-3:]}\"\n            std = std.upper()\n            ret[std] = symbol.upper()\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('GEMINI', why, {\"\": r})\n\n\n<DED><DED>def hitbtc_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>ret = {}\n        r = requests.get('https://api.hitbtc.com/api/2/public/symbol')\n        for symbol in r.json():\n            <IND>split = len(symbol['baseCurrency'])\n            normalized = symbol['id'][:split] + SYMBOL_SEP + symbol['id'][split:]\n            ret[normalized] = symbol['id']\n            _exchange_info[HITBTC]['tick_size'][normalized] = symbol['tickSize']\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('HITBTC', why, {\"\": r})\n\n\n<DED><DED>def poloniex_id_symbol_mapping():\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://poloniex.com/public?command=returnTicker')\n        symbols = r.json()\n        ret = {}\n        for symbol in symbols:\n            <IND>ret[symbols[symbol]['id']] = symbol\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('POLONIEX', why, {\"\": r})\n\n\n<DED><DED>def poloniex_symbols() -> Dict[str, str]:\n    <IND>ret = {}\n    for _, value in poloniex_id_symbol_mapping().items():\n        <IND>std = value.replace(\"STR\", \"XLM\")\n        quote, base = std.split(\"_\")\n        ret[quote + SYMBOL_SEP + base] = value\n    <DED>return ret\n\n\n<DED>def bitstamp_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://www.bitstamp.net/api/v2/trading-pairs-info/')\n        ret = {}\n        for data in r.json():\n            <IND>normalized = data['name'].replace(\"/\", SYMBOL_SEP)\n            symbol = data['url_symbol']\n            ret[normalized] = symbol\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BITSTAMP', why, {\"\": r})\n\n\n<DED><DED>def kraken_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.kraken.com/0/public/AssetPairs')\n        data = r.json()\n        ret = {}\n        for symbol in data['result']:\n            <IND>if 'wsname' not in data['result'][symbol] or '.d' in symbol:\n                # https://blog.kraken.com/post/259/introducing-the-kraken-dark-pool/\n                # .d is for dark pool symbols\n                <IND>continue\n\n            <DED>base, quote = data['result'][symbol]['wsname'].split(\"/\")\n\n            normalized = f\"{base}{SYMBOL_SEP}{quote}\"\n            exch = data['result'][symbol]['wsname']\n            normalized = normalized.replace('XBT', 'BTC')\n            normalized = normalized.replace('XDG', 'DOG')\n            ret[normalized] = exch\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('KRAKEN', why, {\"\": r})\n\n\n<DED><DED>def kraken_rest_symbols() -> Dict[str, str]:\n    <IND>return {normalized: exchange.replace(\"/\", \"\") for normalized, exchange in kraken_symbols().items()}\n\n\n<DED>def exx_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.exx.com/data/v1/tickers')\n        exchange = [key.upper() for key in r.json().keys()]\n        symbols = [key.replace(\"_\", SYMBOL_SEP) for key in exchange]\n        return dict(zip(symbols, exchange))\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('EXX', why, {\"\": r})\n\n\n<DED><DED>def huobi_common_symbols(url: str):\n    <IND>r = None\n    try:\n        <IND>r = requests.get(url)\n        ret = {}\n        for e in r.json()['data']:\n            <IND>if e['state'] == 'offline':\n                <IND>continue\n            <DED>normalized = f\"{e['base-currency'].upper()}{SYMBOL_SEP}{e['quote-currency'].upper()}\"\n            symbol = f\"{e['base-currency']}{e['quote-currency']}\"\n            ret[normalized] = symbol\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('HUOBI', why, {url: r})\n\n\n<DED><DED>def huobi_symbols() -> Dict[str, str]:\n    <IND>return huobi_common_symbols('https://api.huobi.pro/v1/common/symbols')\n\n\n<DED>def huobi_us_symbols() -> Dict[str, str]:\n    <IND>return huobi_common_symbols('https://api.huobi.com/v1/common/symbols')\n\n\n<DED>def huobi_dm_symbols() -> Dict[str, str]:\n    <IND>\"\"\"\n    Mapping is, for instance: {\"BTC_CW\":\"BTC190816\"}\n    See comments in exchange/huobi_dm.py\n    \"\"\"\n    mapping = {\n        \"this_week\": \"CW\",\n        \"next_week\": \"NW\",\n        \"quarter\": \"CQ\",\n        \"next_quarter\": \"NQ\"\n    }\n    r = None\n    try:\n        <IND>r = requests.get('https://www.hbdm.com/api/v1/contract_contract_info')\n        symbols = {}\n        for e in r.json()['data']:\n            <IND>symbols[f\"{e['symbol']}_{mapping[e['contract_type']]}\"] = e['contract_code']\n            _exchange_info[HUOBI_DM]['tick_size'][e['contract_code']] = e['price_tick']\n            _exchange_info[HUOBI_DM]['short_code_mappings'][f\"{e['symbol']}_{mapping[e['contract_type']]}\"] = e['contract_code']\n        <DED>return symbols\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('HUOBI_DM', why, {\"\": r})\n\n\n<DED><DED>def huobi_swap_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.hbdm.com/swap-api/v1/swap_contract_info')\n        symbols = {}\n        for e in r.json()['data']:\n            <IND>symbols[e['contract_code']] = e['contract_code']\n            _exchange_info[HUOBI_SWAP]['tick_size'][e['contract_code']] = e['price_tick']\n        <DED>return symbols\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('HUOBI_SWAP', why, {\"\": r})\n\n\n<DED><DED>def okcoin_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://www.okcoin.com/api/spot/v3/instruments')\n        ret = {}\n        for e in r.json():\n            <IND>ret[e['instrument_id']] = e['instrument_id']\n            _exchange_info[OKCOIN]['tick_size'][e['instrument_id']] = e['tick_size']\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('OKCOIN', why, {\"\": r})\n\n\n<DED><DED>def okex_symbols(*args) -> Dict[str, str]:\n    <IND>urls = ['https://www.okex.com/api/spot/v3/instruments',\n            'https://www.okex.com/api/swap/v3/instruments',\n            'https://www.okex.com/api/futures/v3/instruments']\n    urls = urls + okex_compute_option_urls_from_underlyings()\n\n    symbols: Dict[str, str] = {}\n    for u in urls:\n        <IND>time.sleep(0.2)\n        symbols.update(okex_symbols_from_one_url(u))\n\n    <DED>for symbol in symbols:\n        <IND>instrument_type = 'futures'\n        dash_count = symbol.count(get_symbol_separator())\n        if dash_count == 1:  # BTC-USDT\n            <IND>instrument_type = 'spot'\n        <DED>if dash_count == 4:  # BTC-USD-201225-35000-P\n            <IND>instrument_type = 'option'\n        <DED>if symbol[-4:] == \"SWAP\":  # BTC-USDT-SWAP\n            <IND>instrument_type = 'swap'\n\n        <DED>_exchange_info[OKEX]['instrument_type'][symbol] = instrument_type\n\n    <DED>return symbols\n\n\n<DED>def okex_compute_option_urls_from_underlyings() -> List[str]:\n    <IND>url = 'https://www.okex.com/api/option/v3/underlying'\n    r = None\n    try:\n        <IND>r = requests.get(url)\n        return [f'https://www.okex.com/api/option/v3/instruments/{underlying}' for underlying in r.json()]\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('OKEX', why, {url: r})\n\n\n<DED><DED>def okex_symbols_from_one_url(url: str) -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get(url)\n        ret = {}\n        for e in r.json():\n            <IND>ret[e['instrument_id']] = e['instrument_id']\n            _exchange_info[OKEX]['tick_size'][e['instrument_id']] = e['tick_size']\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('OKEX', why, {url: r})\n\n\n<DED><DED>def bittrex_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.bittrex.com/api/v1.1/public/getmarkets')\n        r = r.json()['result']\n        return {f\"{e['MarketCurrency']}{SYMBOL_SEP}{e['BaseCurrency']}\": e['MarketName'] for e in r if e['IsActive']}\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BITTREX', why, {\"\": r})\n\n\n<DED><DED>def bitcoincom_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.exchange.bitcoin.com/api/2/public/symbol')\n        return {f\"{data['baseCurrency']}{SYMBOL_SEP}{data['quoteCurrency'].replace('USD', 'USDT')}\": data['id'] for data in r.json()}\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BITCOINCOM', why, {\"\": r})\n\n\n<DED><DED>def bitmax_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://bitmax.io/api/pro/v1/products')\n        ret = {}\n        for entry in r.json()['data']:\n            # Only \"Normal\" status symbols are tradeable\n            <IND>if entry['status'] == 'Normal':\n                <IND>normalized = f\"{entry['baseAsset']}{SYMBOL_SEP}{entry['quoteAsset']}\"\n                ret[normalized] = entry['symbol']\n                _exchange_info[BITMAX]['tick_size'][normalized] = entry['tickSize']\n        <DED><DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BITMAX', why, {\"\": r})\n\n\n<DED><DED>def upbit_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.upbit.com/v1/market/all')\n        return {f\"{data['market'].split('-')[1]}{SYMBOL_SEP}{data['market'].split('-')[0]}\": data['market'] for data in r.json()}\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('UPBIT', why, {\"\": r})\n\n\n<DED><DED>def blockchain_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get(\"https://api.blockchain.com/mercury-gateway/v1/instruments\")\n        return {data[\"symbol\"].replace(\"-\", SYMBOL_SEP): data[\"symbol\"] for data in r.json()}\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BLOCKCHAIN', why, {\"\": r})\n\n\n<DED><DED>def gateio_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get(\"https://api.gateio.ws/api/v4/spot/currency_pairs\")\n        return {data[\"id\"].replace(\"_\", SYMBOL_SEP): data['id'] for data in r.json()}\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('GATEIO', why, {\"\": r})\n\n\n<DED><DED>def bitmex_symbols() -> Dict[str, str]:\n    <IND>r = None\n    ret = {}\n    try:\n        <IND>r = requests.get(\"https://www.bitmex.com/api/v1/instrument/active\")\n        for entry in r.json():\n            <IND>components = []\n            components.append(entry['rootSymbol'])\n            components.append(entry['quoteCurrency'])\n\n            if entry['expiry']:\n                <IND>components.append(entry['symbol'][-3:])\n\n            <DED>normalized = SYMBOL_SEP.join(components)\n            normalized = normalized.replace(\"XBT\", \"BTC\")\n            ret[normalized] = entry['symbol']\n            _exchange_info[BITMEX]['tick_size'][normalized] = entry['tickSize']\n\n            if entry['expiry']:\n                <IND>_exchange_info[BITMEX]['expiry'][normalized] = entry['expiry']\n\n        <DED><DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BITMEX', why, {\"\": r})\n\n\n<DED><DED>def deribit_symbols() -> Dict[str, str]:\n    <IND>url = r = None\n    ret = {}\n    try:\n        # TODO: get currencies from https://www.deribit.com/api/v2/public/get_currencies\n        <IND>currencies = ['BTC', 'ETH']\n        for c in currencies:\n            <IND>url = f\"https://www.deribit.com/api/v2/public/get_instruments?currency={c}&expired=false\"\n            r = requests.get(url)\n            for entry in r.json()['result']:\n                <IND>split = entry['instrument_name'].split(\"-\")\n                normalized = split[0] + SYMBOL_SEP + entry['quote_currency'] + \"-\" + '-'.join(split[1:])\n                ret[normalized] = entry['instrument_name']\n                _exchange_info[DERIBIT]['tick_size'][normalized] = entry['tick_size']\n        <DED><DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('DERIBIT', why, {url: r})\n\n\n<DED><DED>def kraken_future_symbols() -> Dict[str, str]:\n    <IND>r = None\n    ret = {}\n    try:\n        <IND>r = requests.get('https://futures.kraken.com/derivatives/api/v3/instruments')\n        data = r.json()['instruments']\n        for entry in data:\n            <IND>if not entry['tradeable']:\n                <IND>continue\n            <DED>normalized = entry['symbol'].upper().replace(\"_\", \"-\")\n            symbol = normalized[3:6] + SYMBOL_SEP + normalized[6:9]\n            normalized = normalized.replace(normalized[3:9], symbol)\n            normalized = normalized.replace('XBT', 'BTC')\n\n            _exchange_info[KRAKEN_FUTURES]['tick_size'][normalized] = entry['tickSize']\n            _exchange_info[KRAKEN_FUTURES]['contract_size'][normalized] = entry['contractSize']\n            _exchange_info[KRAKEN_FUTURES]['underlying'][normalized] = entry['underlying']\n            _exchange_info[KRAKEN_FUTURES]['product_type'][normalized] = _kraken_futures_product_type[normalized[:2]]\n            ret[normalized] = entry['symbol']\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('KRAKEN_FUTURES', why, {\"\": r})\n\n\n<DED><DED>def probit_symbols() -> Dict[str, str]:\n    # doc: https://docs-en.probit.com/reference-link/market\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.probit.com/api/exchange/v1/market')\n        return {entry['id']: entry['id'] for entry in r.json()['data']}\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('PROBIT', why, {\"\": r})\n\n\n<DED><DED>def coingecko_normalize_symbol(symbol: str) -> str:\n    # keep digits, letters and dots, replace others by space\n    <IND>symbol = ''.join(c if c.isalnum() or c in ('.', '+') else ' ' for c in symbol)\n    return coingecko_normalize(symbol.upper())\n\n\n<DED>def coingecko_normalize_name(name: str) -> str:\n    # keep digits and letters, replace others by space (except when only composed by upper case letters, digits and dots)\n    <IND>if not all(c.isupper() or c.isdigit() or c == '.' for c in name):\n        <IND>name = ''.join(c if c.isalnum() else ' ' for c in name)\n    <DED>return coingecko_normalize(name)\n\n\n<DED>def coingecko_normalize(sym: str) -> str:\n    <IND>sym = sym.strip()\n    # do not concatenate numbers => separate them with a dot\n    sym = list(sym)\n    if len(sym) > 4:\n        <IND>for i in range(2, len(sym) - 1):\n            <IND>if sym[i] == ' ' and sym[i - 1].isdigit() and sym[i + 1].isdigit():\n                <IND>sym[i] = '.'\n    <DED><DED><DED>sym = ''.join(sym)\n    # concatenate space-separated words => use CamelCase to distinguish the words\n    if ' ' in sym:\n        <IND>if sum(c.islower() for c in sym):  # if there is at least one lower case letter\n            <IND>sym = ' '.join(word[0].upper() + word[1:] for word in sym.split())  # Just capitalize initial letter of each word\n        <DED>else:  # CoinGecko may provide full upper-case as for \"THE STONE COIN\"\n            <IND>sym = string.capwords(sym)  # capwords converts \"THE STONE COIN\" to \"The Stone Coin\"\n        <DED>sym = sym.replace(' ', '')  # concatenate words\n    <DED>return sym\n\n\n<DED>def is_name_short(coin: dict) -> bool:\n    <IND>\"\"\"return True if the coin name is enough short compared to the coin symbol.\"\"\"\n    return len(coin['name']) <= max(5, len(coin['symbol']) + 1)\n\n\n<DED>def has_many_caps(name: str) -> bool:\n    <IND>\"\"\"return True if the symbol contains enough upper case letters, False if empty.\"\"\"\n    return str and sum(c.islower() for c in name) < (len(name) / 2)\n\n\n<DED>def coingecko_normalize_all(coin: dict):\n    <IND>SYMBOL_TO_NORMALIZED = {'miota': 'IOTA'}\n    normalized = SYMBOL_TO_NORMALIZED.get(coin['symbol'])\n    if normalized:\n        <IND>coin['ns'] = coin['nn'] = normalized\n        return normalized\n\n    # ns = normalized symbol, nn = normalized name\n    <DED>coin['ns'] = coingecko_normalize_symbol(coin['symbol'])\n\n    ID_SUFFIX = '-bitcoin-token'\n    if coin['id'][-len(ID_SUFFIX):] == ID_SUFFIX:\n        <IND>coin['nn'] = 'BTC' + coin['ns']\n        return coin['nn']\n\n    <DED>name = coin['name']\n\n    prefixes = ('The ', 'the ')\n    for p in prefixes:\n        <IND>if name[:len(p)] == p:\n            <IND>coin['reduced-name'] = True\n            name = name[len(p):]\n            break\n\n    <DED><DED>suffixes = ('coin', 'coins', 'money', 'finance', 'protocol', 'reward', 'rewards', 'token')\n    for s in suffixes:\n        <IND>if len(name) > len(s) and name[-len(s):].lower() == s:\n            # but keep suffix when lower-case concatenated\n            <IND>if name[-len(s)].islower() and name[-len(s) - 1] != ' ':\n                <IND>continue\n            # also keep suffix to avoid confusing nam: \"Bitcoin Token\" -> \"Bitcoin\"\n            <DED>if name[:-len(s)].strip().lower() == 'bitcoin':\n                <IND>continue\n            <DED>coin['reduced-name'] = True\n            name = name[:-len(s)]\n            break\n\n    <DED><DED>coin['nn'] = coingecko_normalize_name(name)\n\n    if len(coin['nn']) < len(coin['ns']):\n        <IND>if 'reduced-name' in coin:\n            <IND>coin['reduced-name'] = False\n            name = coin['name']\n            coin['nn'] = coingecko_normalize_name(name)\n        <DED>elif not has_many_caps(name):\n            <IND>return coin['ns']\n\n    <DED><DED>if not coin['ns']:  # coin['symbol'] may be an emoji that is striped when normalized\n        <IND>return coin['nn']\n\n    <DED>if coin.get('reduced-name') and coin['ns'].upper() != coin['nn'].upper():\n        <IND>return coin['ns']\n\n    <DED>i = coin['nn'].find('.')  # if there is a dot in normalized name => prefer the normalized symbol\n    if i >= 0:\n        <IND>if i > 1 and coin['nn'][i - 1].isdigit() and coin['nn'][i + 1].isdigit():\n            <IND>pass  # except when the dot separates digits\n        <DED>else:\n            <IND>return coin['ns']\n\n    <DED><DED>if is_name_short(coin) and has_many_caps(name):\n        <IND>return coin['nn']\n\n    <DED>if 1.5 * len(coin['ns']) > len(coin['nn']) and any(c.islower() for c in coin['ns']):\n        <IND>return coin['nn']\n\n    <DED>return coin['ns']\n\n\n<DED>def coingecko_symbols() -> Dict[str, str]:\n    <IND>r = None\n    intermediate = defaultdict(list)\n    try:\n        <IND>r = requests.get('https://api.coingecko.com/api/v3/coins/list')\n        all_coins = r.json()\n        # First pass: generate & compare normalized symbol/name, and then select the most pertinent\n        for coin in all_coins:\n            <IND>normalized = coingecko_normalize_all(coin)\n            intermediate[normalized].append(coin)\n            # Above line keeps together the coins having the same normalized symbol.\n            # To reduce collision, the coin['name'] is sometimes used in lieu of the coin['symbol'].\n            # The coin['name'] is not capitalized because lower case letters may be meaningful: cETH, yUSD, DATx, zLOT\n    <DED><DED>except Exception as why:\n        <IND>raise_failure_explanation('COINGECKO', why, {\"\": r})\n\n    <DED>final = coingecko_second_pass(intermediate)\n    return coingecko_third_pass(final)\n\n\n<DED>def coingecko_second_pass(intermediate: Dict[str, List[dict]]) -> Dict[str, List[dict]]:\n    # Second pass: fixes most of the symbol collisions\n    <IND>final = defaultdict(list)\n    for normalized, coins in intermediate.items():\n        <IND>if len(coins) == 1:\n            <IND>final[normalized].append(coins[0])\n            continue\n        <DED>set_normalized = False\n        for i in range(len(coins)):\n            <IND>if normalized == coins[i]['nn']:\n                <IND>coin = coins.pop(i)\n                final[normalized].append(coin)\n                set_normalized = True\n                break\n        <DED><DED>rest: List[dict] = []\n        for coin in coins:\n            <IND>if '%' in coin['name']:\n                <IND>if len(coins) == 1:\n                    <IND>n = coin['ns']\n                <DED>else:\n                    <IND>n = coingecko_normalize_name(coin['id'])\n                <DED>final[n].append(coin)\n            <DED>else:\n                <IND>rest.append(coin)\n        <DED><DED>if not rest:\n            <IND>continue\n        <DED>if not set_normalized:\n            <IND>rest.sort(key=lambda coin: len(coin['nn']), reverse=True)  # sort by the length of the normalized name\n            coin = rest.pop(0)\n            final[normalized].append(coin)\n        <DED>for coin in rest:\n            <IND>if coin['nn'] not in intermediate:\n                <IND>n = coin['nn']\n            <DED>elif coin.get('reduced-name'):\n                <IND>n = coingecko_normalize_name(coin['name'])\n            <DED>else:\n                <IND>n = coingecko_normalize_name(coin['id'])\n            <DED>final[n].append(coin)\n    <DED><DED>return final\n\n\n<DED>def coingecko_third_pass(final: Dict[str, List[dict]]) -> Dict[str, str]:\n    # Third pass: fixes some remaining collisions and fills the result\n    <IND>symbols = {}\n    for normalized, coins in final.items():\n        <IND>if len(coins) == 1:\n            <IND>symbols[normalized] = coins[0]['id']\n            continue\n        <DED>set_normalized = False\n        for i in range(len(coins)):\n            <IND>if normalized == coins[i]['nn']:\n                <IND>coin = coins.pop(i)\n                symbols[normalized] = coin['id']\n                set_normalized = True\n                break\n        <DED><DED>rest: List[dict] = []\n        for coin in coins:\n            <IND>if '%' in coin['name']:\n                <IND>if len(coins) == 1:\n                    <IND>n = coin['ns']\n                <DED>else:\n                    <IND>n = coingecko_normalize_name(coin['id'])\n                <DED>symbols[n] = coin['id']\n            <DED>else:\n                <IND>rest.append(coin)\n        <DED><DED>if not rest:\n            <IND>continue\n        <DED>if not set_normalized:\n            <IND>rest.sort(key=lambda coin: len(coin['nn']), reverse=True)  # sort by the length of the normalized name\n            coin = rest.pop(0)\n            symbols[normalized] = coin['id']\n        <DED>for coin in rest:\n            <IND>if coin['nn'] not in final:\n                <IND>n = coin['nn']\n            <DED>elif coin.get('reduced-name'):\n                <IND>n = coingecko_normalize_name(coin['name'])\n            <DED>else:\n                <IND>n = coingecko_normalize_name(coin['id'])\n            <DED>symbols[n] = coin['id']\n    <DED><DED>return symbols\n\n\n<DED>def whale_alert_coins(key_id: str) -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get(f'https://api.whale-alert.io/v1/status?api_key={key_id}')\n        # Same symbols, but on different blockchains (for instance USDT), are naturally overwritten.\n        return {s.upper(): s for b in r.json()['blockchains'] for s in b['symbols'] if s}\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('WHALES_ALERT', why, {\"\": r})\n\n\n<DED><DED>_exchange_function_map = {\n    BITFINEX: bitfinex_symbols,\n    BITFLYER: bitflyer_symbols,\n    COINBASE: coinbase_symbols,\n    GEMINI: gemini_symbols,\n    HITBTC: hitbtc_symbols,\n    POLONIEX: poloniex_symbols,\n    PROBIT: probit_symbols,\n    BITSTAMP: bitstamp_symbols,\n    KRAKEN: kraken_symbols,\n    KRAKEN + 'REST': kraken_rest_symbols,\n    BINANCE: binance_symbols,\n    BINANCE_US: binance_us_symbols,\n    BINANCE_FUTURES: binance_futures_symbols,\n    BINANCE_DELIVERY: binance_delivery_symbols,\n    BLOCKCHAIN: blockchain_symbols,\n    EXX: exx_symbols,\n    HUOBI: huobi_symbols,\n    HUOBI_DM: huobi_dm_symbols,\n    HUOBI_SWAP: huobi_swap_symbols,\n    OKCOIN: okcoin_symbols,\n    OKEX: okex_symbols,\n    BYBIT: bybit_symbols,\n    FTX: ftx_symbols,\n    FTX_US: ftx_us_symbols,\n    BITTREX: bittrex_symbols,\n    BITCOINCOM: bitcoincom_symbols,\n    BITMAX: bitmax_symbols,\n    UPBIT: upbit_symbols,\n    GATEIO: gateio_symbols,\n    BITMEX: bitmex_symbols,\n    DERIBIT: deribit_symbols,\n    KRAKEN_FUTURES: kraken_future_symbols,\n    COINGECKO: coingecko_symbols,\n    WHALE_ALERT: whale_alert_coins\n}\n",
        "target_code_with_indent": "\nfrom typing import Dict, Tuple\n\n\nclass _Symbols:\n    <IND>def __init__(self):\n        <IND>self.data = {}\n\n    <DED>def set(self, exchange: str, normalized: dict, exchange_info: dict):\n        <IND>self.data[exchange] = {}\n        self.data[exchange]['normalized'] = normalized\n        self.data[exchange]['info'] = exchange_info\n\n    <DED>def get(self, exchange: str) -> Tuple[Dict, Dict]:\n        <IND>return self.data[exchange]['normalized'], self.data[exchange]['info']\n\n    <DED>def populated(self, exchange: str) -> bool:\n        <IND>return exchange in self.data\n\n\n<DED><DED>Symbols = _Symbols()\n"
      }
    ]
  },
  {
    "project": "bmoscon/cryptofeed",
    "commit": "3525dc8ce4d7836a9abaaa5662e58e5e27969a77",
    "filename": "cryptofeed/symbols.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/bmoscon-cryptofeed/cryptofeed/symbols.py",
    "file_hunks_size": 1,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "cryptofeed/symbols.py:220:8 Incompatible return type [7]: Expected `Dict[str, str]` but got implicit return value of `None`.",
    "message": " Expected `Dict[str, str]` but got implicit return value of `None`.",
    "rule_id": "Incompatible return type [7]",
    "warning_line_no": 220,
    "warning_line": "        raise_failure_explanation('COINBASE', why, {\"\": r})",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "associated with this software.\n\n\nSymbol generation code for exchanges\n'''\n\nimport logging\nimport string\nimport time\nfrom collections import defaultdict\nfrom typing import Dict, List, Optional, Tuple\n\nimport requests\nfrom requests import Response\n\nfrom cryptofeed.defines import *\n\n\nLOG = logging.getLogger('feedhandler')\n\nSYMBOL_SEP = '-'\n\n_symbols_retrieval_cache: Dict[str, Dict[str, str]] = {}\n_exchange_info = defaultdict(lambda: defaultdict(dict))\n\n\n_kraken_futures_product_type = {\n    'FI': 'Inverse Futures',\n    'FV': 'Vanilla Futures',\n    'PI': 'Perpetual Inverse Futures',\n    'PV': 'Perpetual Vanilla Futures',\n    'IN': 'Real Time Index',\n    'RR': 'Reference Rate',\n}\n\n\ndef raise_failure_explanation(feed_id: str, exception: BaseException, responses: Dict[str, Optional[Response]]):\n    LOG.critical('%s: encountered %r while processing response from exchange API', feed_id, exception)\n    if len(responses) > 1:\n        LOG.critical('%s: content of one of the %s responses was unexpected', feed_id, len(responses))\n    for url, r in responses.items():\n        if url:\n            LOG.critical('%s: requested URL: %s', feed_id, url)\n        if r:\n            LOG.critical('%s: unexpected response: %s', feed_id, r.text)\n    raise ValueError(f'Cryptofeed stopped because of an unexpected response from {feed_id}') from exception\n\n\ndef set_symbol_separator(separator: str):\n    global SYMBOL_SEP\n    SYMBOL_SEP = separator\n\n\ndef get_symbol_separator() -> str:\n    global SYMBOL_SEP\n    return SYMBOL_SEP\n\n\ndef gen_symbols(exchange: str, key_id=None) -> Dict[str, str]:\n    if exchange not in _symbols_retrieval_cache:\n        LOG.info(\"%s: Getting list of symbols\", exchange)\n        symbols = _exchange_function_map[exchange](key_id) if key_id else _exchange_function_map[exchange]()\n        LOG.info(\"%s: %s symbols\", exchange, len(symbols))\n\n        # log all retrieved symbols using debug level\n        for normalized, exch_sym in sorted(symbols.items()):\n            LOG.debug('%s: id-from-exch -> normalized: %-35s-> %s', exchange, exch_sym, normalized)\n\n        _symbols_retrieval_cache[exchange] = symbols\n    return _symbols_retrieval_cache[exchange]\n\n\ndef _binance_symbols(endpoint: str, exchange: str):\n    r = None\n    try:\n        ret = {}\n        r = requests.get(endpoint)\n        for symbol in r.json()['symbols']:\n            if symbol.get('status', 'TRADING') != \"TRADING\":\n                continue\n            if symbol.get('contractStatus', 'TRADING') != \"TRADING\":\n                continue\n            split = len(symbol['baseAsset'])\n            normalized = symbol['symbol'][:split] + SYMBOL_SEP + symbol['symbol'][split:]\n            ret[normalized] = symbol['symbol']\n            _exchange_info[exchange]['tick_size'][normalized] = symbol['filters'][0]['tickSize']\n            if \"contractType\" in symbol:\n                _exchange_info[exchange]['contract_type'][normalized] = symbol['contractType']\n        return ret\n    except Exception as why:\n        raise_failure_explanation(exchange, why, {endpoint: r})\n\n\ndef binance_symbols() -> Dict[str, str]:\n    return _binance_symbols('https://api.binance.com/api/v3/exchangeInfo', BINANCE)\n\n\ndef binance_us_symbols() -> Dict[str, str]:\n    return _binance_symbols('https://api.binance.us/api/v3/exchangeInfo', BINANCE_US)\n\n\ndef binance_futures_symbols() -> Dict[str, str]:\n    base = _binance_symbols('https://fapi.binance.com/fapi/v1/exchangeInfo', BINANCE_FUTURES)\n    add = {}\n    for symbol, orig in base.items():\n        if \"_\" in orig:\n            continue\n        add[f\"{symbol}-PINDEX\"] = f\"p{orig}\"\n    base.update(add)\n    return base\n\n\ndef binance_delivery_symbols() -> Dict[str, str]:\n    return _binance_symbols('https://dapi.binance.com/dapi/v1/exchangeInfo', BINANCE_DELIVERY)\n\n\ndef bitfinex_symbols() -> Dict[str, str]:\n    # doc: https://docs.bitfinex.com/docs/ws-general#supported-pairs\n    r1 = r2 = None\n    try:\n        r1 = requests.get('https://api.bitfinex.com/v2/tickers?symbols=ALL')\n        r2 = requests.get('https://api-pub.bitfinex.com/v2/conf/pub:map:currency:sym')\n        tickers: List[List[str]] = r1.json()\n        norm: List[Tuple[str, str]] = r2.json()[0]\n        norm: Dict[str, str] = dict(norm)\n        for k, v in dict(norm).items():\n            if k[-2:] == 'F0' or '-' in v:  # Do not convert BTCF0 -> BTC or PBTCETH -> PBTC-ETH\n                del norm[k]\n        norm['BCHN'] = 'BCH'  # Bitfinex uses BCHN, other exchanges use BCH\n\n        ret = {}\n        for symbol in [t[0] for t in tickers]:\n            if symbol[0] == 'f':\n                normalized = norm.get(symbol[1:], symbol[1:])\n            else:\n                if len(symbol) == 7:\n                    base, quote = symbol[1:4], symbol[4:]\n                else:\n                    base, quote = symbol[1:].split(':')\n                    assert ':' in symbol\n                normalized = norm.get(base, base) + SYMBOL_SEP + norm.get(quote, quote)\n            ret[normalized.upper()] = symbol\n        return ret\n    except ValueError as why:\n        raise_failure_explanation('BITFINEX', why, {\"tickers?symbols=ALL\": r1, \"pub:map:currency:sym\": r2})\n\n\ndef bitflyer_symbols() -> Dict[str, str]:\n    endpoint = r = None\n    try:\n        ret = {}\n        endpoints = ['https://api.bitflyer.com/v1/getmarkets/eu', 'https://api.bitflyer.com/v1/getmarkets/usa', 'https://api.bitflyer.com/v1/getmarkets']\n        for endpoint in endpoints:\n            r = requests.get(endpoint)\n            for entry in r.json():\n                normalized = entry['product_code'].replace(\"_\", SYMBOL_SEP)\n                ret[normalized] = entry['product_code']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('BITFLYER', why, {endpoint: r})\n\n\ndef bybit_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.bybit.com/v2/public/symbols')\n        ret = {}\n        for symbol in r.json()['result']:\n            quote = symbol['quote_currency']\n            if not symbol['name'].endswith(quote):\n                base, contract = symbol['name'].split(quote)\n                normalized = f\"{base}{SYMBOL_SEP}{quote}-{contract}\"\n            else:\n                normalized = f\"{symbol['base_currency']}{SYMBOL_SEP}{quote}\"\n            ret[normalized] = symbol['name']\n            _exchange_info[BYBIT]['tick_size'][normalized] = symbol['price_filter']['tick_size']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('BYBIT', why, {\"\": r})\n\n\ndef _ftx_helper(endpoint: str, exchange: str):\n    r = None\n    try:\n        r = requests.get(endpoint)\n        ret = {}\n        for data in r.json()['result']:\n            normalized = data['name'].replace(\"/\", SYMBOL_SEP)\n            symbol = data['name']\n            ret[normalized] = symbol\n            _exchange_info[exchange]['tick_size'][normalized] = data['priceIncrement']\n        return ret\n    except Exception as why:\n        raise_failure_explanation(exchange, why, {endpoint: r})\n\n\ndef ftx_symbols() -> Dict[str, str]:\n    return _ftx_helper('https://ftx.com/api/markets', FTX)\n\n\ndef ftx_us_symbols() -> Dict[str, str]:\n    return _ftx_helper('https://ftx.us/api/markets', FTX_US)\n\n\ndef coinbase_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.pro.coinbase.com/products')\n        ret = {}\n        for data in r.json():\n            normalized = data['id'].replace(\"-\", SYMBOL_SEP)\n            ret[normalized] = data['id']\n            _exchange_info[COINBASE]['tick_size'][normalized] = data['quote_increment']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('COINBASE', why, {\"\": r})\n\n\ndef gemini_symbols(*args) -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.gemini.com/v1/symbols')\n        ret = {}\n        for symbol in r.json():\n            std = f\"{symbol[:-3]}{SYMBOL_SEP}{symbol[-3:]}\"\n            std = std.upper()\n            ret[std] = symbol.upper()\n        return ret\n    except Exception as why:\n        raise_failure_explanation('GEMINI', why, {\"\": r})\n\n\ndef hitbtc_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        ret = {}\n        r = requests.get('https://api.hitbtc.com/api/2/public/symbol')\n        for symbol in r.json():\n            split = len(symbol['baseCurrency'])\n            normalized = symbol['id'][:split] + SYMBOL_SEP + symbol['id'][split:]\n            ret[normalized] = symbol['id']\n            _exchange_info[HITBTC]['tick_size'][normalized] = symbol['tickSize']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('HITBTC', why, {\"\": r})\n\n\ndef poloniex_id_symbol_mapping():\n    r = None\n    try:\n        r = requests.get('https://poloniex.com/public?command=returnTicker')\n        symbols = r.json()\n        ret = {}\n        for symbol in symbols:\n            ret[symbols[symbol]['id']] = symbol\n        return ret\n    except Exception as why:\n        raise_failure_explanation('POLONIEX', why, {\"\": r})\n\n\ndef poloniex_symbols() -> Dict[str, str]:\n    ret = {}\n    for _, value in poloniex_id_symbol_mapping().items():\n        std = value.replace(\"STR\", \"XLM\")\n        quote, base = std.split(\"_\")\n        ret[quote + SYMBOL_SEP + base] = value\n    return ret\n\n\ndef bitstamp_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://www.bitstamp.net/api/v2/trading-pairs-info/')\n        ret = {}\n        for data in r.json():\n            normalized = data['name'].replace(\"/\", SYMBOL_SEP)\n            symbol = data['url_symbol']\n            ret[normalized] = symbol\n        return ret\n    except Exception as why:\n        raise_failure_explanation('BITSTAMP', why, {\"\": r})\n\n\ndef kraken_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.kraken.com/0/public/AssetPairs')\n        data = r.json()\n        ret = {}\n        for symbol in data['result']:\n            if 'wsname' not in data['result'][symbol] or '.d' in symbol:\n                # https://blog.kraken.com/post/259/introducing-the-kraken-dark-pool/\n                # .d is for dark pool symbols\n                continue\n\n            base, quote = data['result'][symbol]['wsname'].split(\"/\")\n\n            normalized = f\"{base}{SYMBOL_SEP}{quote}\"\n            exch = data['result'][symbol]['wsname']\n            normalized = normalized.replace('XBT', 'BTC')\n            normalized = normalized.replace('XDG', 'DOG')\n            ret[normalized] = exch\n        return ret\n    except Exception as why:\n        raise_failure_explanation('KRAKEN', why, {\"\": r})\n\n\ndef kraken_rest_symbols() -> Dict[str, str]:\n    return {normalized: exchange.replace(\"/\", \"\") for normalized, exchange in kraken_symbols().items()}\n\n\ndef exx_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.exx.com/data/v1/tickers')\n        exchange = [key.upper() for key in r.json().keys()]\n        symbols = [key.replace(\"_\", SYMBOL_SEP) for key in exchange]\n        return dict(zip(symbols, exchange))\n    except Exception as why:\n        raise_failure_explanation('EXX', why, {\"\": r})\n\n\ndef huobi_common_symbols(url: str):\n    r = None\n    try:\n        r = requests.get(url)\n        ret = {}\n        for e in r.json()['data']:\n            if e['state'] == 'offline':\n                continue\n            normalized = f\"{e['base-currency'].upper()}{SYMBOL_SEP}{e['quote-currency'].upper()}\"\n            symbol = f\"{e['base-currency']}{e['quote-currency']}\"\n            ret[normalized] = symbol\n        return ret\n    except Exception as why:\n        raise_failure_explanation('HUOBI', why, {url: r})\n\n\ndef huobi_symbols() -> Dict[str, str]:\n    return huobi_common_symbols('https://api.huobi.pro/v1/common/symbols')\n\n\ndef huobi_us_symbols() -> Dict[str, str]:\n    return huobi_common_symbols('https://api.huobi.com/v1/common/symbols')\n\n\ndef huobi_dm_symbols() -> Dict[str, str]:\n    \"\"\"\n    Mapping is, for instance: {\"BTC_CW\":\"BTC190816\"}\n    See comments in exchange/huobi_dm.py\n    \"\"\"\n    mapping = {\n        \"this_week\": \"CW\",\n        \"next_week\": \"NW\",\n        \"quarter\": \"CQ\",\n        \"next_quarter\": \"NQ\"\n    }\n    r = None\n    try:\n        r = requests.get('https://www.hbdm.com/api/v1/contract_contract_info')\n        symbols = {}\n        for e in r.json()['data']:\n            symbols[f\"{e['symbol']}_{mapping[e['contract_type']]}\"] = e['contract_code']\n            _exchange_info[HUOBI_DM]['tick_size'][e['contract_code']] = e['price_tick']\n            _exchange_info[HUOBI_DM]['short_code_mappings'][f\"{e['symbol']}_{mapping[e['contract_type']]}\"] = e['contract_code']\n        return symbols\n    except Exception as why:\n        raise_failure_explanation('HUOBI_DM', why, {\"\": r})\n\n\ndef huobi_swap_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.hbdm.com/swap-api/v1/swap_contract_info')\n        symbols = {}\n        for e in r.json()['data']:\n            symbols[e['contract_code']] = e['contract_code']\n            _exchange_info[HUOBI_SWAP]['tick_size'][e['contract_code']] = e['price_tick']\n        return symbols\n    except Exception as why:\n        raise_failure_explanation('HUOBI_SWAP', why, {\"\": r})\n\n\ndef okcoin_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://www.okcoin.com/api/spot/v3/instruments')\n        ret = {}\n        for e in r.json():\n            ret[e['instrument_id']] = e['instrument_id']\n            _exchange_info[OKCOIN]['tick_size'][e['instrument_id']] = e['tick_size']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('OKCOIN', why, {\"\": r})\n\n\ndef okex_symbols(*args) -> Dict[str, str]:\n    urls = ['https://www.okex.com/api/spot/v3/instruments',\n            'https://www.okex.com/api/swap/v3/instruments',\n            'https://www.okex.com/api/futures/v3/instruments']\n    urls = urls + okex_compute_option_urls_from_underlyings()\n\n    symbols: Dict[str, str] = {}\n    for u in urls:\n        time.sleep(0.2)\n        symbols.update(okex_symbols_from_one_url(u))\n\n    for symbol in symbols:\n        instrument_type = 'futures'\n        dash_count = symbol.count(get_symbol_separator())\n        if dash_count == 1:  # BTC-USDT\n            instrument_type = 'spot'\n        if dash_count == 4:  # BTC-USD-201225-35000-P\n            instrument_type = 'option'\n        if symbol[-4:] == \"SWAP\":  # BTC-USDT-SWAP\n            instrument_type = 'swap'\n\n        _exchange_info[OKEX]['instrument_type'][symbol] = instrument_type\n\n    return symbols\n\n\ndef okex_compute_option_urls_from_underlyings() -> List[str]:\n    url = 'https://www.okex.com/api/option/v3/underlying'\n    r = None\n    try:\n        r = requests.get(url)\n        return [f'https://www.okex.com/api/option/v3/instruments/{underlying}' for underlying in r.json()]\n    except Exception as why:\n        raise_failure_explanation('OKEX', why, {url: r})\n\n\ndef okex_symbols_from_one_url(url: str) -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get(url)\n        ret = {}\n        for e in r.json():\n            ret[e['instrument_id']] = e['instrument_id']\n            _exchange_info[OKEX]['tick_size'][e['instrument_id']] = e['tick_size']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('OKEX', why, {url: r})\n\n\ndef bittrex_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.bittrex.com/api/v1.1/public/getmarkets')\n        r = r.json()['result']\n        return {f\"{e['MarketCurrency']}{SYMBOL_SEP}{e['BaseCurrency']}\": e['MarketName'] for e in r if e['IsActive']}\n    except Exception as why:\n        raise_failure_explanation('BITTREX', why, {\"\": r})\n\n\ndef bitcoincom_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.exchange.bitcoin.com/api/2/public/symbol')\n        return {f\"{data['baseCurrency']}{SYMBOL_SEP}{data['quoteCurrency'].replace('USD', 'USDT')}\": data['id'] for data in r.json()}\n    except Exception as why:\n        raise_failure_explanation('BITCOINCOM', why, {\"\": r})\n\n\ndef bitmax_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://bitmax.io/api/pro/v1/products')\n        ret = {}\n        for entry in r.json()['data']:\n            # Only \"Normal\" status symbols are tradeable\n            if entry['status'] == 'Normal':\n                normalized = f\"{entry['baseAsset']}{SYMBOL_SEP}{entry['quoteAsset']}\"\n                ret[normalized] = entry['symbol']\n                _exchange_info[BITMAX]['tick_size'][normalized] = entry['tickSize']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('BITMAX', why, {\"\": r})\n\n\ndef upbit_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.upbit.com/v1/market/all')\n        return {f\"{data['market'].split('-')[1]}{SYMBOL_SEP}{data['market'].split('-')[0]}\": data['market'] for data in r.json()}\n    except Exception as why:\n        raise_failure_explanation('UPBIT', why, {\"\": r})\n\n\ndef blockchain_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get(\"https://api.blockchain.com/mercury-gateway/v1/instruments\")\n        return {data[\"symbol\"].replace(\"-\", SYMBOL_SEP): data[\"symbol\"] for data in r.json()}\n    except Exception as why:\n        raise_failure_explanation('BLOCKCHAIN', why, {\"\": r})\n\n\ndef gateio_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get(\"https://api.gateio.ws/api/v4/spot/currency_pairs\")\n        return {data[\"id\"].replace(\"_\", SYMBOL_SEP): data['id'] for data in r.json()}\n    except Exception as why:\n        raise_failure_explanation('GATEIO', why, {\"\": r})\n\n\ndef bitmex_symbols() -> Dict[str, str]:\n    r = None\n    ret = {}\n    try:\n        r = requests.get(\"https://www.bitmex.com/api/v1/instrument/active\")\n        for entry in r.json():\n            components = []\n            components.append(entry['rootSymbol'])\n            components.append(entry['quoteCurrency'])\n\n            if entry['expiry']:\n                components.append(entry['symbol'][-3:])\n\n            normalized = SYMBOL_SEP.join(components)\n            normalized = normalized.replace(\"XBT\", \"BTC\")\n            ret[normalized] = entry['symbol']\n            _exchange_info[BITMEX]['tick_size'][normalized] = entry['tickSize']\n\n            if entry['expiry']:\n                _exchange_info[BITMEX]['expiry'][normalized] = entry['expiry']\n\n        return ret\n    except Exception as why:\n        raise_failure_explanation('BITMEX', why, {\"\": r})\n\n\ndef deribit_symbols() -> Dict[str, str]:\n    url = r = None\n    ret = {}\n    try:\n        # TODO: get currencies from https://www.deribit.com/api/v2/public/get_currencies\n        currencies = ['BTC', 'ETH']\n        for c in currencies:\n            url = f\"https://www.deribit.com/api/v2/public/get_instruments?currency={c}&expired=false\"\n            r = requests.get(url)\n            for entry in r.json()['result']:\n                split = entry['instrument_name'].split(\"-\")\n                normalized = split[0] + SYMBOL_SEP + entry['quote_currency'] + \"-\" + '-'.join(split[1:])\n                ret[normalized] = entry['instrument_name']\n                _exchange_info[DERIBIT]['tick_size'][normalized] = entry['tick_size']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('DERIBIT', why, {url: r})\n\n\ndef kraken_future_symbols() -> Dict[str, str]:\n    r = None\n    ret = {}\n    try:\n        r = requests.get('https://futures.kraken.com/derivatives/api/v3/instruments')\n        data = r.json()['instruments']\n        for entry in data:\n            if not entry['tradeable']:\n                continue\n            normalized = entry['symbol'].upper().replace(\"_\", \"-\")\n            symbol = normalized[3:6] + SYMBOL_SEP + normalized[6:9]\n            normalized = normalized.replace(normalized[3:9], symbol)\n            normalized = normalized.replace('XBT', 'BTC')\n\n            _exchange_info[KRAKEN_FUTURES]['tick_size'][normalized] = entry['tickSize']\n            _exchange_info[KRAKEN_FUTURES]['contract_size'][normalized] = entry['contractSize']\n            _exchange_info[KRAKEN_FUTURES]['underlying'][normalized] = entry['underlying']\n            _exchange_info[KRAKEN_FUTURES]['product_type'][normalized] = _kraken_futures_product_type[normalized[:2]]\n            ret[normalized] = entry['symbol']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('KRAKEN_FUTURES', why, {\"\": r})\n\n\ndef probit_symbols() -> Dict[str, str]:\n    # doc: https://docs-en.probit.com/reference-link/market\n    r = None\n    try:\n        r = requests.get('https://api.probit.com/api/exchange/v1/market')\n        return {entry['id']: entry['id'] for entry in r.json()['data']}\n    except Exception as why:\n        raise_failure_explanation('PROBIT', why, {\"\": r})\n\n\ndef coingecko_normalize_symbol(symbol: str) -> str:\n    # keep digits, letters and dots, replace others by space\n    symbol = ''.join(c if c.isalnum() or c in ('.', '+') else ' ' for c in symbol)\n    return coingecko_normalize(symbol.upper())\n\n\ndef coingecko_normalize_name(name: str) -> str:\n    # keep digits and letters, replace others by space (except when only composed by upper case letters, digits and dots)\n    if not all(c.isupper() or c.isdigit() or c == '.' for c in name):\n        name = ''.join(c if c.isalnum() else ' ' for c in name)\n    return coingecko_normalize(name)\n\n\ndef coingecko_normalize(sym: str) -> str:\n    sym = sym.strip()\n    # do not concatenate numbers => separate them with a dot\n    sym = list(sym)\n    if len(sym) > 4:\n        for i in range(2, len(sym) - 1):\n            if sym[i] == ' ' and sym[i - 1].isdigit() and sym[i + 1].isdigit():\n                sym[i] = '.'\n    sym = ''.join(sym)\n    # concatenate space-separated words => use CamelCase to distinguish the words\n    if ' ' in sym:\n        if sum(c.islower() for c in sym):  # if there is at least one lower case letter\n            sym = ' '.join(word[0].upper() + word[1:] for word in sym.split())  # Just capitalize initial letter of each word\n        else:  # CoinGecko may provide full upper-case as for \"THE STONE COIN\"\n            sym = string.capwords(sym)  # capwords converts \"THE STONE COIN\" to \"The Stone Coin\"\n        sym = sym.replace(' ', '')  # concatenate words\n    return sym\n\n\ndef is_name_short(coin: dict) -> bool:\n    \"\"\"return True if the coin name is enough short compared to the coin symbol.\"\"\"\n    return len(coin['name']) <= max(5, len(coin['symbol']) + 1)\n\n\ndef has_many_caps(name: str) -> bool:\n    \"\"\"return True if the symbol contains enough upper case letters, False if empty.\"\"\"\n    return str and sum(c.islower() for c in name) < (len(name) / 2)\n\n\ndef coingecko_normalize_all(coin: dict):\n    SYMBOL_TO_NORMALIZED = {'miota': 'IOTA'}\n    normalized = SYMBOL_TO_NORMALIZED.get(coin['symbol'])\n    if normalized:\n        coin['ns'] = coin['nn'] = normalized\n        return normalized\n\n    # ns = normalized symbol, nn = normalized name\n    coin['ns'] = coingecko_normalize_symbol(coin['symbol'])\n\n    ID_SUFFIX = '-bitcoin-token'\n    if coin['id'][-len(ID_SUFFIX):] == ID_SUFFIX:\n        coin['nn'] = 'BTC' + coin['ns']\n        return coin['nn']\n\n    name = coin['name']\n\n    prefixes = ('The ', 'the ')\n    for p in prefixes:\n        if name[:len(p)] == p:\n            coin['reduced-name'] = True\n            name = name[len(p):]\n            break\n\n    suffixes = ('coin', 'coins', 'money', 'finance', 'protocol', 'reward', 'rewards', 'token')\n    for s in suffixes:\n        if len(name) > len(s) and name[-len(s):].lower() == s:\n            # but keep suffix when lower-case concatenated\n            if name[-len(s)].islower() and name[-len(s) - 1] != ' ':\n                continue\n            # also keep suffix to avoid confusing nam: \"Bitcoin Token\" -> \"Bitcoin\"\n            if name[:-len(s)].strip().lower() == 'bitcoin':\n                continue\n            coin['reduced-name'] = True\n            name = name[:-len(s)]\n            break\n\n    coin['nn'] = coingecko_normalize_name(name)\n\n    if len(coin['nn']) < len(coin['ns']):\n        if 'reduced-name' in coin:\n            coin['reduced-name'] = False\n            name = coin['name']\n            coin['nn'] = coingecko_normalize_name(name)\n        elif not has_many_caps(name):\n            return coin['ns']\n\n    if not coin['ns']:  # coin['symbol'] may be an emoji that is striped when normalized\n        return coin['nn']\n\n    if coin.get('reduced-name') and coin['ns'].upper() != coin['nn'].upper():\n        return coin['ns']\n\n    i = coin['nn'].find('.')  # if there is a dot in normalized name => prefer the normalized symbol\n    if i >= 0:\n        if i > 1 and coin['nn'][i - 1].isdigit() and coin['nn'][i + 1].isdigit():\n            pass  # except when the dot separates digits\n        else:\n            return coin['ns']\n\n    if is_name_short(coin) and has_many_caps(name):\n        return coin['nn']\n\n    if 1.5 * len(coin['ns']) > len(coin['nn']) and any(c.islower() for c in coin['ns']):\n        return coin['nn']\n\n    return coin['ns']\n\n\ndef coingecko_symbols() -> Dict[str, str]:\n    r = None\n    intermediate = defaultdict(list)\n    try:\n        r = requests.get('https://api.coingecko.com/api/v3/coins/list')\n        all_coins = r.json()\n        # First pass: generate & compare normalized symbol/name, and then select the most pertinent\n        for coin in all_coins:\n            normalized = coingecko_normalize_all(coin)\n            intermediate[normalized].append(coin)\n            # Above line keeps together the coins having the same normalized symbol.\n            # To reduce collision, the coin['name'] is sometimes used in lieu of the coin['symbol'].\n            # The coin['name'] is not capitalized because lower case letters may be meaningful: cETH, yUSD, DATx, zLOT\n    except Exception as why:\n        raise_failure_explanation('COINGECKO', why, {\"\": r})\n\n    final = coingecko_second_pass(intermediate)\n    return coingecko_third_pass(final)\n\n\ndef coingecko_second_pass(intermediate: Dict[str, List[dict]]) -> Dict[str, List[dict]]:\n    # Second pass: fixes most of the symbol collisions\n    final = defaultdict(list)\n    for normalized, coins in intermediate.items():\n        if len(coins) == 1:\n            final[normalized].append(coins[0])\n            continue\n        set_normalized = False\n        for i in range(len(coins)):\n            if normalized == coins[i]['nn']:\n                coin = coins.pop(i)\n                final[normalized].append(coin)\n                set_normalized = True\n                break\n        rest: List[dict] = []\n        for coin in coins:\n            if '%' in coin['name']:\n                if len(coins) == 1:\n                    n = coin['ns']\n                else:\n                    n = coingecko_normalize_name(coin['id'])\n                final[n].append(coin)\n            else:\n                rest.append(coin)\n        if not rest:\n            continue\n        if not set_normalized:\n            rest.sort(key=lambda coin: len(coin['nn']), reverse=True)  # sort by the length of the normalized name\n            coin = rest.pop(0)\n            final[normalized].append(coin)\n        for coin in rest:\n            if coin['nn'] not in intermediate:\n                n = coin['nn']\n            elif coin.get('reduced-name'):\n                n = coingecko_normalize_name(coin['name'])\n            else:\n                n = coingecko_normalize_name(coin['id'])\n            final[n].append(coin)\n    return final\n\n\ndef coingecko_third_pass(final: Dict[str, List[dict]]) -> Dict[str, str]:\n    # Third pass: fixes some remaining collisions and fills the result\n    symbols = {}\n    for normalized, coins in final.items():\n        if len(coins) == 1:\n            symbols[normalized] = coins[0]['id']\n            continue\n        set_normalized = False\n        for i in range(len(coins)):\n            if normalized == coins[i]['nn']:\n                coin = coins.pop(i)\n                symbols[normalized] = coin['id']\n                set_normalized = True\n                break\n        rest: List[dict] = []\n        for coin in coins:\n            if '%' in coin['name']:\n                if len(coins) == 1:\n                    n = coin['ns']\n                else:\n                    n = coingecko_normalize_name(coin['id'])\n                symbols[n] = coin['id']\n            else:\n                rest.append(coin)\n        if not rest:\n            continue\n        if not set_normalized:\n            rest.sort(key=lambda coin: len(coin['nn']), reverse=True)  # sort by the length of the normalized name\n            coin = rest.pop(0)\n            symbols[normalized] = coin['id']\n        for coin in rest:\n            if coin['nn'] not in final:\n                n = coin['nn']\n            elif coin.get('reduced-name'):\n                n = coingecko_normalize_name(coin['name'])\n            else:\n                n = coingecko_normalize_name(coin['id'])\n            symbols[n] = coin['id']\n    return symbols\n\n\ndef whale_alert_coins(key_id: str) -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get(f'https://api.whale-alert.io/v1/status?api_key={key_id}')\n        # Same symbols, but on different blockchains (for instance USDT), are naturally overwritten.\n        return {s.upper(): s for b in r.json()['blockchains'] for s in b['symbols'] if s}\n    except Exception as why:\n        raise_failure_explanation('WHALES_ALERT', why, {\"\": r})\n\n\n_exchange_function_map = {\n    BITFINEX: bitfinex_symbols,\n    BITFLYER: bitflyer_symbols,\n    COINBASE: coinbase_symbols,\n    GEMINI: gemini_symbols,\n    HITBTC: hitbtc_symbols,\n    POLONIEX: poloniex_symbols,\n    PROBIT: probit_symbols,\n    BITSTAMP: bitstamp_symbols,\n    KRAKEN: kraken_symbols,\n    KRAKEN + 'REST': kraken_rest_symbols,\n    BINANCE: binance_symbols,\n    BINANCE_US: binance_us_symbols,\n    BINANCE_FUTURES: binance_futures_symbols,\n    BINANCE_DELIVERY: binance_delivery_symbols,\n    BLOCKCHAIN: blockchain_symbols,\n    EXX: exx_symbols,\n    HUOBI: huobi_symbols,\n    HUOBI_DM: huobi_dm_symbols,\n    HUOBI_SWAP: huobi_swap_symbols,\n    OKCOIN: okcoin_symbols,\n    OKEX: okex_symbols,\n    BYBIT: bybit_symbols,\n    FTX: ftx_symbols,\n    FTX_US: ftx_us_symbols,\n    BITTREX: bittrex_symbols,\n    BITCOINCOM: bitcoincom_symbols,\n    BITMAX: bitmax_symbols,\n    UPBIT: upbit_symbols,\n    GATEIO: gateio_symbols,\n    BITMEX: bitmex_symbols,\n    DERIBIT: deribit_symbols,\n    KRAKEN_FUTURES: kraken_future_symbols,\n    COINGECKO: coingecko_symbols,\n    WHALE_ALERT: whale_alert_coins\n}\n",
        "source_code_len": 30534,
        "target_code": "associated with this software.\n'''\nfrom typing import Dict, Tuple\n\n\nclass _Symbols:\n    def __init__(self):\n        self.data = {}\n\n    def set(self, exchange: str, normalized: dict, exchange_info: dict):\n        self.data[exchange] = {}\n        self.data[exchange]['normalized'] = normalized\n        self.data[exchange]['info'] = exchange_info\n\n    def get(self, exchange: str) -> Tuple[Dict, Dict]:\n        return self.data[exchange]['normalized'], self.data[exchange]['info']\n\n    def populated(self, exchange: str) -> bool:\n        return exchange in self.data\n\n\nSymbols = _Symbols()\n",
        "target_code_len": 588,
        "diff_format": "@@ -5,845 +5,22 @@\n associated with this software.\n+'''\n+from typing import Dict, Tuple\n \n \n-Symbol generation code for exchanges\n-'''\n+class _Symbols:\n+    def __init__(self):\n+        self.data = {}\n \n-import logging\n-import string\n-import time\n-from collections import defaultdict\n-from typing import Dict, List, Optional, Tuple\n+    def set(self, exchange: str, normalized: dict, exchange_info: dict):\n+        self.data[exchange] = {}\n+        self.data[exchange]['normalized'] = normalized\n+        self.data[exchange]['info'] = exchange_info\n \n-import requests\n-from requests import Response\n+    def get(self, exchange: str) -> Tuple[Dict, Dict]:\n+        return self.data[exchange]['normalized'], self.data[exchange]['info']\n \n-from cryptofeed.defines import *\n+    def populated(self, exchange: str) -> bool:\n+        return exchange in self.data\n \n \n-LOG = logging.getLogger('feedhandler')\n-\n-SYMBOL_SEP = '-'\n-\n-_symbols_retrieval_cache: Dict[str, Dict[str, str]] = {}\n-_exchange_info = defaultdict(lambda: defaultdict(dict))\n-\n-\n-_kraken_futures_product_type = {\n-    'FI': 'Inverse Futures',\n-    'FV': 'Vanilla Futures',\n-    'PI': 'Perpetual Inverse Futures',\n-    'PV': 'Perpetual Vanilla Futures',\n-    'IN': 'Real Time Index',\n-    'RR': 'Reference Rate',\n-}\n-\n-\n-def raise_failure_explanation(feed_id: str, exception: BaseException, responses: Dict[str, Optional[Response]]):\n-    LOG.critical('%s: encountered %r while processing response from exchange API', feed_id, exception)\n-    if len(responses) > 1:\n-        LOG.critical('%s: content of one of the %s responses was unexpected', feed_id, len(responses))\n-    for url, r in responses.items():\n-        if url:\n-            LOG.critical('%s: requested URL: %s', feed_id, url)\n-        if r:\n-            LOG.critical('%s: unexpected response: %s', feed_id, r.text)\n-    raise ValueError(f'Cryptofeed stopped because of an unexpected response from {feed_id}') from exception\n-\n-\n-def set_symbol_separator(separator: str):\n-    global SYMBOL_SEP\n-    SYMBOL_SEP = separator\n-\n-\n-def get_symbol_separator() -> str:\n-    global SYMBOL_SEP\n-    return SYMBOL_SEP\n-\n-\n-def gen_symbols(exchange: str, key_id=None) -> Dict[str, str]:\n-    if exchange not in _symbols_retrieval_cache:\n-        LOG.info(\"%s: Getting list of symbols\", exchange)\n-        symbols = _exchange_function_map[exchange](key_id) if key_id else _exchange_function_map[exchange]()\n-        LOG.info(\"%s: %s symbols\", exchange, len(symbols))\n-\n-        # log all retrieved symbols using debug level\n-        for normalized, exch_sym in sorted(symbols.items()):\n-            LOG.debug('%s: id-from-exch -> normalized: %-35s-> %s', exchange, exch_sym, normalized)\n-\n-        _symbols_retrieval_cache[exchange] = symbols\n-    return _symbols_retrieval_cache[exchange]\n-\n-\n-def _binance_symbols(endpoint: str, exchange: str):\n-    r = None\n-    try:\n-        ret = {}\n-        r = requests.get(endpoint)\n-        for symbol in r.json()['symbols']:\n-            if symbol.get('status', 'TRADING') != \"TRADING\":\n-                continue\n-            if symbol.get('contractStatus', 'TRADING') != \"TRADING\":\n-                continue\n-            split = len(symbol['baseAsset'])\n-            normalized = symbol['symbol'][:split] + SYMBOL_SEP + symbol['symbol'][split:]\n-            ret[normalized] = symbol['symbol']\n-            _exchange_info[exchange]['tick_size'][normalized] = symbol['filters'][0]['tickSize']\n-            if \"contractType\" in symbol:\n-                _exchange_info[exchange]['contract_type'][normalized] = symbol['contractType']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation(exchange, why, {endpoint: r})\n-\n-\n-def binance_symbols() -> Dict[str, str]:\n-    return _binance_symbols('https://api.binance.com/api/v3/exchangeInfo', BINANCE)\n-\n-\n-def binance_us_symbols() -> Dict[str, str]:\n-    return _binance_symbols('https://api.binance.us/api/v3/exchangeInfo', BINANCE_US)\n-\n-\n-def binance_futures_symbols() -> Dict[str, str]:\n-    base = _binance_symbols('https://fapi.binance.com/fapi/v1/exchangeInfo', BINANCE_FUTURES)\n-    add = {}\n-    for symbol, orig in base.items():\n-        if \"_\" in orig:\n-            continue\n-        add[f\"{symbol}-PINDEX\"] = f\"p{orig}\"\n-    base.update(add)\n-    return base\n-\n-\n-def binance_delivery_symbols() -> Dict[str, str]:\n-    return _binance_symbols('https://dapi.binance.com/dapi/v1/exchangeInfo', BINANCE_DELIVERY)\n-\n-\n-def bitfinex_symbols() -> Dict[str, str]:\n-    # doc: https://docs.bitfinex.com/docs/ws-general#supported-pairs\n-    r1 = r2 = None\n-    try:\n-        r1 = requests.get('https://api.bitfinex.com/v2/tickers?symbols=ALL')\n-        r2 = requests.get('https://api-pub.bitfinex.com/v2/conf/pub:map:currency:sym')\n-        tickers: List[List[str]] = r1.json()\n-        norm: List[Tuple[str, str]] = r2.json()[0]\n-        norm: Dict[str, str] = dict(norm)\n-        for k, v in dict(norm).items():\n-            if k[-2:] == 'F0' or '-' in v:  # Do not convert BTCF0 -> BTC or PBTCETH -> PBTC-ETH\n-                del norm[k]\n-        norm['BCHN'] = 'BCH'  # Bitfinex uses BCHN, other exchanges use BCH\n-\n-        ret = {}\n-        for symbol in [t[0] for t in tickers]:\n-            if symbol[0] == 'f':\n-                normalized = norm.get(symbol[1:], symbol[1:])\n-            else:\n-                if len(symbol) == 7:\n-                    base, quote = symbol[1:4], symbol[4:]\n-                else:\n-                    base, quote = symbol[1:].split(':')\n-                    assert ':' in symbol\n-                normalized = norm.get(base, base) + SYMBOL_SEP + norm.get(quote, quote)\n-            ret[normalized.upper()] = symbol\n-        return ret\n-    except ValueError as why:\n-        raise_failure_explanation('BITFINEX', why, {\"tickers?symbols=ALL\": r1, \"pub:map:currency:sym\": r2})\n-\n-\n-def bitflyer_symbols() -> Dict[str, str]:\n-    endpoint = r = None\n-    try:\n-        ret = {}\n-        endpoints = ['https://api.bitflyer.com/v1/getmarkets/eu', 'https://api.bitflyer.com/v1/getmarkets/usa', 'https://api.bitflyer.com/v1/getmarkets']\n-        for endpoint in endpoints:\n-            r = requests.get(endpoint)\n-            for entry in r.json():\n-                normalized = entry['product_code'].replace(\"_\", SYMBOL_SEP)\n-                ret[normalized] = entry['product_code']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('BITFLYER', why, {endpoint: r})\n-\n-\n-def bybit_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.bybit.com/v2/public/symbols')\n-        ret = {}\n-        for symbol in r.json()['result']:\n-            quote = symbol['quote_currency']\n-            if not symbol['name'].endswith(quote):\n-                base, contract = symbol['name'].split(quote)\n-                normalized = f\"{base}{SYMBOL_SEP}{quote}-{contract}\"\n-            else:\n-                normalized = f\"{symbol['base_currency']}{SYMBOL_SEP}{quote}\"\n-            ret[normalized] = symbol['name']\n-            _exchange_info[BYBIT]['tick_size'][normalized] = symbol['price_filter']['tick_size']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('BYBIT', why, {\"\": r})\n-\n-\n-def _ftx_helper(endpoint: str, exchange: str):\n-    r = None\n-    try:\n-        r = requests.get(endpoint)\n-        ret = {}\n-        for data in r.json()['result']:\n-            normalized = data['name'].replace(\"/\", SYMBOL_SEP)\n-            symbol = data['name']\n-            ret[normalized] = symbol\n-            _exchange_info[exchange]['tick_size'][normalized] = data['priceIncrement']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation(exchange, why, {endpoint: r})\n-\n-\n-def ftx_symbols() -> Dict[str, str]:\n-    return _ftx_helper('https://ftx.com/api/markets', FTX)\n-\n-\n-def ftx_us_symbols() -> Dict[str, str]:\n-    return _ftx_helper('https://ftx.us/api/markets', FTX_US)\n-\n-\n-def coinbase_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.pro.coinbase.com/products')\n-        ret = {}\n-        for data in r.json():\n-            normalized = data['id'].replace(\"-\", SYMBOL_SEP)\n-            ret[normalized] = data['id']\n-            _exchange_info[COINBASE]['tick_size'][normalized] = data['quote_increment']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('COINBASE', why, {\"\": r})\n-\n-\n-def gemini_symbols(*args) -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.gemini.com/v1/symbols')\n-        ret = {}\n-        for symbol in r.json():\n-            std = f\"{symbol[:-3]}{SYMBOL_SEP}{symbol[-3:]}\"\n-            std = std.upper()\n-            ret[std] = symbol.upper()\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('GEMINI', why, {\"\": r})\n-\n-\n-def hitbtc_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        ret = {}\n-        r = requests.get('https://api.hitbtc.com/api/2/public/symbol')\n-        for symbol in r.json():\n-            split = len(symbol['baseCurrency'])\n-            normalized = symbol['id'][:split] + SYMBOL_SEP + symbol['id'][split:]\n-            ret[normalized] = symbol['id']\n-            _exchange_info[HITBTC]['tick_size'][normalized] = symbol['tickSize']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('HITBTC', why, {\"\": r})\n-\n-\n-def poloniex_id_symbol_mapping():\n-    r = None\n-    try:\n-        r = requests.get('https://poloniex.com/public?command=returnTicker')\n-        symbols = r.json()\n-        ret = {}\n-        for symbol in symbols:\n-            ret[symbols[symbol]['id']] = symbol\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('POLONIEX', why, {\"\": r})\n-\n-\n-def poloniex_symbols() -> Dict[str, str]:\n-    ret = {}\n-    for _, value in poloniex_id_symbol_mapping().items():\n-        std = value.replace(\"STR\", \"XLM\")\n-        quote, base = std.split(\"_\")\n-        ret[quote + SYMBOL_SEP + base] = value\n-    return ret\n-\n-\n-def bitstamp_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://www.bitstamp.net/api/v2/trading-pairs-info/')\n-        ret = {}\n-        for data in r.json():\n-            normalized = data['name'].replace(\"/\", SYMBOL_SEP)\n-            symbol = data['url_symbol']\n-            ret[normalized] = symbol\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('BITSTAMP', why, {\"\": r})\n-\n-\n-def kraken_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.kraken.com/0/public/AssetPairs')\n-        data = r.json()\n-        ret = {}\n-        for symbol in data['result']:\n-            if 'wsname' not in data['result'][symbol] or '.d' in symbol:\n-                # https://blog.kraken.com/post/259/introducing-the-kraken-dark-pool/\n-                # .d is for dark pool symbols\n-                continue\n-\n-            base, quote = data['result'][symbol]['wsname'].split(\"/\")\n-\n-            normalized = f\"{base}{SYMBOL_SEP}{quote}\"\n-            exch = data['result'][symbol]['wsname']\n-            normalized = normalized.replace('XBT', 'BTC')\n-            normalized = normalized.replace('XDG', 'DOG')\n-            ret[normalized] = exch\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('KRAKEN', why, {\"\": r})\n-\n-\n-def kraken_rest_symbols() -> Dict[str, str]:\n-    return {normalized: exchange.replace(\"/\", \"\") for normalized, exchange in kraken_symbols().items()}\n-\n-\n-def exx_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.exx.com/data/v1/tickers')\n-        exchange = [key.upper() for key in r.json().keys()]\n-        symbols = [key.replace(\"_\", SYMBOL_SEP) for key in exchange]\n-        return dict(zip(symbols, exchange))\n-    except Exception as why:\n-        raise_failure_explanation('EXX', why, {\"\": r})\n-\n-\n-def huobi_common_symbols(url: str):\n-    r = None\n-    try:\n-        r = requests.get(url)\n-        ret = {}\n-        for e in r.json()['data']:\n-            if e['state'] == 'offline':\n-                continue\n-            normalized = f\"{e['base-currency'].upper()}{SYMBOL_SEP}{e['quote-currency'].upper()}\"\n-            symbol = f\"{e['base-currency']}{e['quote-currency']}\"\n-            ret[normalized] = symbol\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('HUOBI', why, {url: r})\n-\n-\n-def huobi_symbols() -> Dict[str, str]:\n-    return huobi_common_symbols('https://api.huobi.pro/v1/common/symbols')\n-\n-\n-def huobi_us_symbols() -> Dict[str, str]:\n-    return huobi_common_symbols('https://api.huobi.com/v1/common/symbols')\n-\n-\n-def huobi_dm_symbols() -> Dict[str, str]:\n-    \"\"\"\n-    Mapping is, for instance: {\"BTC_CW\":\"BTC190816\"}\n-    See comments in exchange/huobi_dm.py\n-    \"\"\"\n-    mapping = {\n-        \"this_week\": \"CW\",\n-        \"next_week\": \"NW\",\n-        \"quarter\": \"CQ\",\n-        \"next_quarter\": \"NQ\"\n-    }\n-    r = None\n-    try:\n-        r = requests.get('https://www.hbdm.com/api/v1/contract_contract_info')\n-        symbols = {}\n-        for e in r.json()['data']:\n-            symbols[f\"{e['symbol']}_{mapping[e['contract_type']]}\"] = e['contract_code']\n-            _exchange_info[HUOBI_DM]['tick_size'][e['contract_code']] = e['price_tick']\n-            _exchange_info[HUOBI_DM]['short_code_mappings'][f\"{e['symbol']}_{mapping[e['contract_type']]}\"] = e['contract_code']\n-        return symbols\n-    except Exception as why:\n-        raise_failure_explanation('HUOBI_DM', why, {\"\": r})\n-\n-\n-def huobi_swap_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.hbdm.com/swap-api/v1/swap_contract_info')\n-        symbols = {}\n-        for e in r.json()['data']:\n-            symbols[e['contract_code']] = e['contract_code']\n-            _exchange_info[HUOBI_SWAP]['tick_size'][e['contract_code']] = e['price_tick']\n-        return symbols\n-    except Exception as why:\n-        raise_failure_explanation('HUOBI_SWAP', why, {\"\": r})\n-\n-\n-def okcoin_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://www.okcoin.com/api/spot/v3/instruments')\n-        ret = {}\n-        for e in r.json():\n-            ret[e['instrument_id']] = e['instrument_id']\n-            _exchange_info[OKCOIN]['tick_size'][e['instrument_id']] = e['tick_size']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('OKCOIN', why, {\"\": r})\n-\n-\n-def okex_symbols(*args) -> Dict[str, str]:\n-    urls = ['https://www.okex.com/api/spot/v3/instruments',\n-            'https://www.okex.com/api/swap/v3/instruments',\n-            'https://www.okex.com/api/futures/v3/instruments']\n-    urls = urls + okex_compute_option_urls_from_underlyings()\n-\n-    symbols: Dict[str, str] = {}\n-    for u in urls:\n-        time.sleep(0.2)\n-        symbols.update(okex_symbols_from_one_url(u))\n-\n-    for symbol in symbols:\n-        instrument_type = 'futures'\n-        dash_count = symbol.count(get_symbol_separator())\n-        if dash_count == 1:  # BTC-USDT\n-            instrument_type = 'spot'\n-        if dash_count == 4:  # BTC-USD-201225-35000-P\n-            instrument_type = 'option'\n-        if symbol[-4:] == \"SWAP\":  # BTC-USDT-SWAP\n-            instrument_type = 'swap'\n-\n-        _exchange_info[OKEX]['instrument_type'][symbol] = instrument_type\n-\n-    return symbols\n-\n-\n-def okex_compute_option_urls_from_underlyings() -> List[str]:\n-    url = 'https://www.okex.com/api/option/v3/underlying'\n-    r = None\n-    try:\n-        r = requests.get(url)\n-        return [f'https://www.okex.com/api/option/v3/instruments/{underlying}' for underlying in r.json()]\n-    except Exception as why:\n-        raise_failure_explanation('OKEX', why, {url: r})\n-\n-\n-def okex_symbols_from_one_url(url: str) -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get(url)\n-        ret = {}\n-        for e in r.json():\n-            ret[e['instrument_id']] = e['instrument_id']\n-            _exchange_info[OKEX]['tick_size'][e['instrument_id']] = e['tick_size']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('OKEX', why, {url: r})\n-\n-\n-def bittrex_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.bittrex.com/api/v1.1/public/getmarkets')\n-        r = r.json()['result']\n-        return {f\"{e['MarketCurrency']}{SYMBOL_SEP}{e['BaseCurrency']}\": e['MarketName'] for e in r if e['IsActive']}\n-    except Exception as why:\n-        raise_failure_explanation('BITTREX', why, {\"\": r})\n-\n-\n-def bitcoincom_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.exchange.bitcoin.com/api/2/public/symbol')\n-        return {f\"{data['baseCurrency']}{SYMBOL_SEP}{data['quoteCurrency'].replace('USD', 'USDT')}\": data['id'] for data in r.json()}\n-    except Exception as why:\n-        raise_failure_explanation('BITCOINCOM', why, {\"\": r})\n-\n-\n-def bitmax_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://bitmax.io/api/pro/v1/products')\n-        ret = {}\n-        for entry in r.json()['data']:\n-            # Only \"Normal\" status symbols are tradeable\n-            if entry['status'] == 'Normal':\n-                normalized = f\"{entry['baseAsset']}{SYMBOL_SEP}{entry['quoteAsset']}\"\n-                ret[normalized] = entry['symbol']\n-                _exchange_info[BITMAX]['tick_size'][normalized] = entry['tickSize']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('BITMAX', why, {\"\": r})\n-\n-\n-def upbit_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.upbit.com/v1/market/all')\n-        return {f\"{data['market'].split('-')[1]}{SYMBOL_SEP}{data['market'].split('-')[0]}\": data['market'] for data in r.json()}\n-    except Exception as why:\n-        raise_failure_explanation('UPBIT', why, {\"\": r})\n-\n-\n-def blockchain_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get(\"https://api.blockchain.com/mercury-gateway/v1/instruments\")\n-        return {data[\"symbol\"].replace(\"-\", SYMBOL_SEP): data[\"symbol\"] for data in r.json()}\n-    except Exception as why:\n-        raise_failure_explanation('BLOCKCHAIN', why, {\"\": r})\n-\n-\n-def gateio_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get(\"https://api.gateio.ws/api/v4/spot/currency_pairs\")\n-        return {data[\"id\"].replace(\"_\", SYMBOL_SEP): data['id'] for data in r.json()}\n-    except Exception as why:\n-        raise_failure_explanation('GATEIO', why, {\"\": r})\n-\n-\n-def bitmex_symbols() -> Dict[str, str]:\n-    r = None\n-    ret = {}\n-    try:\n-        r = requests.get(\"https://www.bitmex.com/api/v1/instrument/active\")\n-        for entry in r.json():\n-            components = []\n-            components.append(entry['rootSymbol'])\n-            components.append(entry['quoteCurrency'])\n-\n-            if entry['expiry']:\n-                components.append(entry['symbol'][-3:])\n-\n-            normalized = SYMBOL_SEP.join(components)\n-            normalized = normalized.replace(\"XBT\", \"BTC\")\n-            ret[normalized] = entry['symbol']\n-            _exchange_info[BITMEX]['tick_size'][normalized] = entry['tickSize']\n-\n-            if entry['expiry']:\n-                _exchange_info[BITMEX]['expiry'][normalized] = entry['expiry']\n-\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('BITMEX', why, {\"\": r})\n-\n-\n-def deribit_symbols() -> Dict[str, str]:\n-    url = r = None\n-    ret = {}\n-    try:\n-        # TODO: get currencies from https://www.deribit.com/api/v2/public/get_currencies\n-        currencies = ['BTC', 'ETH']\n-        for c in currencies:\n-            url = f\"https://www.deribit.com/api/v2/public/get_instruments?currency={c}&expired=false\"\n-            r = requests.get(url)\n-            for entry in r.json()['result']:\n-                split = entry['instrument_name'].split(\"-\")\n-                normalized = split[0] + SYMBOL_SEP + entry['quote_currency'] + \"-\" + '-'.join(split[1:])\n-                ret[normalized] = entry['instrument_name']\n-                _exchange_info[DERIBIT]['tick_size'][normalized] = entry['tick_size']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('DERIBIT', why, {url: r})\n-\n-\n-def kraken_future_symbols() -> Dict[str, str]:\n-    r = None\n-    ret = {}\n-    try:\n-        r = requests.get('https://futures.kraken.com/derivatives/api/v3/instruments')\n-        data = r.json()['instruments']\n-        for entry in data:\n-            if not entry['tradeable']:\n-                continue\n-            normalized = entry['symbol'].upper().replace(\"_\", \"-\")\n-            symbol = normalized[3:6] + SYMBOL_SEP + normalized[6:9]\n-            normalized = normalized.replace(normalized[3:9], symbol)\n-            normalized = normalized.replace('XBT', 'BTC')\n-\n-            _exchange_info[KRAKEN_FUTURES]['tick_size'][normalized] = entry['tickSize']\n-            _exchange_info[KRAKEN_FUTURES]['contract_size'][normalized] = entry['contractSize']\n-            _exchange_info[KRAKEN_FUTURES]['underlying'][normalized] = entry['underlying']\n-            _exchange_info[KRAKEN_FUTURES]['product_type'][normalized] = _kraken_futures_product_type[normalized[:2]]\n-            ret[normalized] = entry['symbol']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('KRAKEN_FUTURES', why, {\"\": r})\n-\n-\n-def probit_symbols() -> Dict[str, str]:\n-    # doc: https://docs-en.probit.com/reference-link/market\n-    r = None\n-    try:\n-        r = requests.get('https://api.probit.com/api/exchange/v1/market')\n-        return {entry['id']: entry['id'] for entry in r.json()['data']}\n-    except Exception as why:\n-        raise_failure_explanation('PROBIT', why, {\"\": r})\n-\n-\n-def coingecko_normalize_symbol(symbol: str) -> str:\n-    # keep digits, letters and dots, replace others by space\n-    symbol = ''.join(c if c.isalnum() or c in ('.', '+') else ' ' for c in symbol)\n-    return coingecko_normalize(symbol.upper())\n-\n-\n-def coingecko_normalize_name(name: str) -> str:\n-    # keep digits and letters, replace others by space (except when only composed by upper case letters, digits and dots)\n-    if not all(c.isupper() or c.isdigit() or c == '.' for c in name):\n-        name = ''.join(c if c.isalnum() else ' ' for c in name)\n-    return coingecko_normalize(name)\n-\n-\n-def coingecko_normalize(sym: str) -> str:\n-    sym = sym.strip()\n-    # do not concatenate numbers => separate them with a dot\n-    sym = list(sym)\n-    if len(sym) > 4:\n-        for i in range(2, len(sym) - 1):\n-            if sym[i] == ' ' and sym[i - 1].isdigit() and sym[i + 1].isdigit():\n-                sym[i] = '.'\n-    sym = ''.join(sym)\n-    # concatenate space-separated words => use CamelCase to distinguish the words\n-    if ' ' in sym:\n-        if sum(c.islower() for c in sym):  # if there is at least one lower case letter\n-            sym = ' '.join(word[0].upper() + word[1:] for word in sym.split())  # Just capitalize initial letter of each word\n-        else:  # CoinGecko may provide full upper-case as for \"THE STONE COIN\"\n-            sym = string.capwords(sym)  # capwords converts \"THE STONE COIN\" to \"The Stone Coin\"\n-        sym = sym.replace(' ', '')  # concatenate words\n-    return sym\n-\n-\n-def is_name_short(coin: dict) -> bool:\n-    \"\"\"return True if the coin name is enough short compared to the coin symbol.\"\"\"\n-    return len(coin['name']) <= max(5, len(coin['symbol']) + 1)\n-\n-\n-def has_many_caps(name: str) -> bool:\n-    \"\"\"return True if the symbol contains enough upper case letters, False if empty.\"\"\"\n-    return str and sum(c.islower() for c in name) < (len(name) / 2)\n-\n-\n-def coingecko_normalize_all(coin: dict):\n-    SYMBOL_TO_NORMALIZED = {'miota': 'IOTA'}\n-    normalized = SYMBOL_TO_NORMALIZED.get(coin['symbol'])\n-    if normalized:\n-        coin['ns'] = coin['nn'] = normalized\n-        return normalized\n-\n-    # ns = normalized symbol, nn = normalized name\n-    coin['ns'] = coingecko_normalize_symbol(coin['symbol'])\n-\n-    ID_SUFFIX = '-bitcoin-token'\n-    if coin['id'][-len(ID_SUFFIX):] == ID_SUFFIX:\n-        coin['nn'] = 'BTC' + coin['ns']\n-        return coin['nn']\n-\n-    name = coin['name']\n-\n-    prefixes = ('The ', 'the ')\n-    for p in prefixes:\n-        if name[:len(p)] == p:\n-            coin['reduced-name'] = True\n-            name = name[len(p):]\n-            break\n-\n-    suffixes = ('coin', 'coins', 'money', 'finance', 'protocol', 'reward', 'rewards', 'token')\n-    for s in suffixes:\n-        if len(name) > len(s) and name[-len(s):].lower() == s:\n-            # but keep suffix when lower-case concatenated\n-            if name[-len(s)].islower() and name[-len(s) - 1] != ' ':\n-                continue\n-            # also keep suffix to avoid confusing nam: \"Bitcoin Token\" -> \"Bitcoin\"\n-            if name[:-len(s)].strip().lower() == 'bitcoin':\n-                continue\n-            coin['reduced-name'] = True\n-            name = name[:-len(s)]\n-            break\n-\n-    coin['nn'] = coingecko_normalize_name(name)\n-\n-    if len(coin['nn']) < len(coin['ns']):\n-        if 'reduced-name' in coin:\n-            coin['reduced-name'] = False\n-            name = coin['name']\n-            coin['nn'] = coingecko_normalize_name(name)\n-        elif not has_many_caps(name):\n-            return coin['ns']\n-\n-    if not coin['ns']:  # coin['symbol'] may be an emoji that is striped when normalized\n-        return coin['nn']\n-\n-    if coin.get('reduced-name') and coin['ns'].upper() != coin['nn'].upper():\n-        return coin['ns']\n-\n-    i = coin['nn'].find('.')  # if there is a dot in normalized name => prefer the normalized symbol\n-    if i >= 0:\n-        if i > 1 and coin['nn'][i - 1].isdigit() and coin['nn'][i + 1].isdigit():\n-            pass  # except when the dot separates digits\n-        else:\n-            return coin['ns']\n-\n-    if is_name_short(coin) and has_many_caps(name):\n-        return coin['nn']\n-\n-    if 1.5 * len(coin['ns']) > len(coin['nn']) and any(c.islower() for c in coin['ns']):\n-        return coin['nn']\n-\n-    return coin['ns']\n-\n-\n-def coingecko_symbols() -> Dict[str, str]:\n-    r = None\n-    intermediate = defaultdict(list)\n-    try:\n-        r = requests.get('https://api.coingecko.com/api/v3/coins/list')\n-        all_coins = r.json()\n-        # First pass: generate & compare normalized symbol/name, and then select the most pertinent\n-        for coin in all_coins:\n-            normalized = coingecko_normalize_all(coin)\n-            intermediate[normalized].append(coin)\n-            # Above line keeps together the coins having the same normalized symbol.\n-            # To reduce collision, the coin['name'] is sometimes used in lieu of the coin['symbol'].\n-            # The coin['name'] is not capitalized because lower case letters may be meaningful: cETH, yUSD, DATx, zLOT\n-    except Exception as why:\n-        raise_failure_explanation('COINGECKO', why, {\"\": r})\n-\n-    final = coingecko_second_pass(intermediate)\n-    return coingecko_third_pass(final)\n-\n-\n-def coingecko_second_pass(intermediate: Dict[str, List[dict]]) -> Dict[str, List[dict]]:\n-    # Second pass: fixes most of the symbol collisions\n-    final = defaultdict(list)\n-    for normalized, coins in intermediate.items():\n-        if len(coins) == 1:\n-            final[normalized].append(coins[0])\n-            continue\n-        set_normalized = False\n-        for i in range(len(coins)):\n-            if normalized == coins[i]['nn']:\n-                coin = coins.pop(i)\n-                final[normalized].append(coin)\n-                set_normalized = True\n-                break\n-        rest: List[dict] = []\n-        for coin in coins:\n-            if '%' in coin['name']:\n-                if len(coins) == 1:\n-                    n = coin['ns']\n-                else:\n-                    n = coingecko_normalize_name(coin['id'])\n-                final[n].append(coin)\n-            else:\n-                rest.append(coin)\n-        if not rest:\n-            continue\n-        if not set_normalized:\n-            rest.sort(key=lambda coin: len(coin['nn']), reverse=True)  # sort by the length of the normalized name\n-            coin = rest.pop(0)\n-            final[normalized].append(coin)\n-        for coin in rest:\n-            if coin['nn'] not in intermediate:\n-                n = coin['nn']\n-            elif coin.get('reduced-name'):\n-                n = coingecko_normalize_name(coin['name'])\n-            else:\n-                n = coingecko_normalize_name(coin['id'])\n-            final[n].append(coin)\n-    return final\n-\n-\n-def coingecko_third_pass(final: Dict[str, List[dict]]) -> Dict[str, str]:\n-    # Third pass: fixes some remaining collisions and fills the result\n-    symbols = {}\n-    for normalized, coins in final.items():\n-        if len(coins) == 1:\n-            symbols[normalized] = coins[0]['id']\n-            continue\n-        set_normalized = False\n-        for i in range(len(coins)):\n-            if normalized == coins[i]['nn']:\n-                coin = coins.pop(i)\n-                symbols[normalized] = coin['id']\n-                set_normalized = True\n-                break\n-        rest: List[dict] = []\n-        for coin in coins:\n-            if '%' in coin['name']:\n-                if len(coins) == 1:\n-                    n = coin['ns']\n-                else:\n-                    n = coingecko_normalize_name(coin['id'])\n-                symbols[n] = coin['id']\n-            else:\n-                rest.append(coin)\n-        if not rest:\n-            continue\n-        if not set_normalized:\n-            rest.sort(key=lambda coin: len(coin['nn']), reverse=True)  # sort by the length of the normalized name\n-            coin = rest.pop(0)\n-            symbols[normalized] = coin['id']\n-        for coin in rest:\n-            if coin['nn'] not in final:\n-                n = coin['nn']\n-            elif coin.get('reduced-name'):\n-                n = coingecko_normalize_name(coin['name'])\n-            else:\n-                n = coingecko_normalize_name(coin['id'])\n-            symbols[n] = coin['id']\n-    return symbols\n-\n-\n-def whale_alert_coins(key_id: str) -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get(f'https://api.whale-alert.io/v1/status?api_key={key_id}')\n-        # Same symbols, but on different blockchains (for instance USDT), are naturally overwritten.\n-        return {s.upper(): s for b in r.json()['blockchains'] for s in b['symbols'] if s}\n-    except Exception as why:\n-        raise_failure_explanation('WHALES_ALERT', why, {\"\": r})\n-\n-\n-_exchange_function_map = {\n-    BITFINEX: bitfinex_symbols,\n-    BITFLYER: bitflyer_symbols,\n-    COINBASE: coinbase_symbols,\n-    GEMINI: gemini_symbols,\n-    HITBTC: hitbtc_symbols,\n-    POLONIEX: poloniex_symbols,\n-    PROBIT: probit_symbols,\n-    BITSTAMP: bitstamp_symbols,\n-    KRAKEN: kraken_symbols,\n-    KRAKEN + 'REST': kraken_rest_symbols,\n-    BINANCE: binance_symbols,\n-    BINANCE_US: binance_us_symbols,\n-    BINANCE_FUTURES: binance_futures_symbols,\n-    BINANCE_DELIVERY: binance_delivery_symbols,\n-    BLOCKCHAIN: blockchain_symbols,\n-    EXX: exx_symbols,\n-    HUOBI: huobi_symbols,\n-    HUOBI_DM: huobi_dm_symbols,\n-    HUOBI_SWAP: huobi_swap_symbols,\n-    OKCOIN: okcoin_symbols,\n-    OKEX: okex_symbols,\n-    BYBIT: bybit_symbols,\n-    FTX: ftx_symbols,\n-    FTX_US: ftx_us_symbols,\n-    BITTREX: bittrex_symbols,\n-    BITCOINCOM: bitcoincom_symbols,\n-    BITMAX: bitmax_symbols,\n-    UPBIT: upbit_symbols,\n-    GATEIO: gateio_symbols,\n-    BITMEX: bitmex_symbols,\n-    DERIBIT: deribit_symbols,\n-    KRAKEN_FUTURES: kraken_future_symbols,\n-    COINGECKO: coingecko_symbols,\n-    WHALE_ALERT: whale_alert_coins\n-}\n+Symbols = _Symbols()\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\n\nimport logging\nimport string\nimport time\nfrom collections import defaultdict\nfrom typing import Dict, List, Optional, Tuple\n\nimport requests\nfrom requests import Response\n\nfrom cryptofeed.defines import *\n\n\nLOG = logging.getLogger('feedhandler')\n\nSYMBOL_SEP = '-'\n\n_symbols_retrieval_cache: Dict[str, Dict[str, str]] = {}\n_exchange_info = defaultdict(lambda: defaultdict(dict))\n\n\n_kraken_futures_product_type = {\n    'FI': 'Inverse Futures',\n    'FV': 'Vanilla Futures',\n    'PI': 'Perpetual Inverse Futures',\n    'PV': 'Perpetual Vanilla Futures',\n    'IN': 'Real Time Index',\n    'RR': 'Reference Rate',\n}\n\n\ndef raise_failure_explanation(feed_id: str, exception: BaseException, responses: Dict[str, Optional[Response]]):\n    <IND>LOG.critical('%s: encountered %r while processing response from exchange API', feed_id, exception)\n    if len(responses) > 1:\n        <IND>LOG.critical('%s: content of one of the %s responses was unexpected', feed_id, len(responses))\n    <DED>for url, r in responses.items():\n        <IND>if url:\n            <IND>LOG.critical('%s: requested URL: %s', feed_id, url)\n        <DED>if r:\n            <IND>LOG.critical('%s: unexpected response: %s', feed_id, r.text)\n    <DED><DED>raise ValueError(f'Cryptofeed stopped because of an unexpected response from {feed_id}') from exception\n\n\n<DED>def set_symbol_separator(separator: str):\n    <IND>global SYMBOL_SEP\n    SYMBOL_SEP = separator\n\n\n<DED>def get_symbol_separator() -> str:\n    <IND>global SYMBOL_SEP\n    return SYMBOL_SEP\n\n\n<DED>def gen_symbols(exchange: str, key_id=None) -> Dict[str, str]:\n    <IND>if exchange not in _symbols_retrieval_cache:\n        <IND>LOG.info(\"%s: Getting list of symbols\", exchange)\n        symbols = _exchange_function_map[exchange](key_id) if key_id else _exchange_function_map[exchange]()\n        LOG.info(\"%s: %s symbols\", exchange, len(symbols))\n\n        # log all retrieved symbols using debug level\n        for normalized, exch_sym in sorted(symbols.items()):\n            <IND>LOG.debug('%s: id-from-exch -> normalized: %-35s-> %s', exchange, exch_sym, normalized)\n\n        <DED>_symbols_retrieval_cache[exchange] = symbols\n    <DED>return _symbols_retrieval_cache[exchange]\n\n\n<DED>def _binance_symbols(endpoint: str, exchange: str):\n    <IND>r = None\n    try:\n        <IND>ret = {}\n        r = requests.get(endpoint)\n        for symbol in r.json()['symbols']:\n            <IND>if symbol.get('status', 'TRADING') != \"TRADING\":\n                <IND>continue\n            <DED>if symbol.get('contractStatus', 'TRADING') != \"TRADING\":\n                <IND>continue\n            <DED>split = len(symbol['baseAsset'])\n            normalized = symbol['symbol'][:split] + SYMBOL_SEP + symbol['symbol'][split:]\n            ret[normalized] = symbol['symbol']\n            _exchange_info[exchange]['tick_size'][normalized] = symbol['filters'][0]['tickSize']\n            if \"contractType\" in symbol:\n                <IND>_exchange_info[exchange]['contract_type'][normalized] = symbol['contractType']\n        <DED><DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation(exchange, why, {endpoint: r})\n\n\n<DED><DED>def binance_symbols() -> Dict[str, str]:\n    <IND>return _binance_symbols('https://api.binance.com/api/v3/exchangeInfo', BINANCE)\n\n\n<DED>def binance_us_symbols() -> Dict[str, str]:\n    <IND>return _binance_symbols('https://api.binance.us/api/v3/exchangeInfo', BINANCE_US)\n\n\n<DED>def binance_futures_symbols() -> Dict[str, str]:\n    <IND>base = _binance_symbols('https://fapi.binance.com/fapi/v1/exchangeInfo', BINANCE_FUTURES)\n    add = {}\n    for symbol, orig in base.items():\n        <IND>if \"_\" in orig:\n            <IND>continue\n        <DED>add[f\"{symbol}-PINDEX\"] = f\"p{orig}\"\n    <DED>base.update(add)\n    return base\n\n\n<DED>def binance_delivery_symbols() -> Dict[str, str]:\n    <IND>return _binance_symbols('https://dapi.binance.com/dapi/v1/exchangeInfo', BINANCE_DELIVERY)\n\n\n<DED>def bitfinex_symbols() -> Dict[str, str]:\n    # doc: https://docs.bitfinex.com/docs/ws-general#supported-pairs\n    <IND>r1 = r2 = None\n    try:\n        <IND>r1 = requests.get('https://api.bitfinex.com/v2/tickers?symbols=ALL')\n        r2 = requests.get('https://api-pub.bitfinex.com/v2/conf/pub:map:currency:sym')\n        tickers: List[List[str]] = r1.json()\n        norm: List[Tuple[str, str]] = r2.json()[0]\n        norm: Dict[str, str] = dict(norm)\n        for k, v in dict(norm).items():\n            <IND>if k[-2:] == 'F0' or '-' in v:  # Do not convert BTCF0 -> BTC or PBTCETH -> PBTC-ETH\n                <IND>del norm[k]\n        <DED><DED>norm['BCHN'] = 'BCH'  # Bitfinex uses BCHN, other exchanges use BCH\n\n        ret = {}\n        for symbol in [t[0] for t in tickers]:\n            <IND>if symbol[0] == 'f':\n                <IND>normalized = norm.get(symbol[1:], symbol[1:])\n            <DED>else:\n                <IND>if len(symbol) == 7:\n                    <IND>base, quote = symbol[1:4], symbol[4:]\n                <DED>else:\n                    <IND>base, quote = symbol[1:].split(':')\n                    assert ':' in symbol\n                <DED>normalized = norm.get(base, base) + SYMBOL_SEP + norm.get(quote, quote)\n            <DED>ret[normalized.upper()] = symbol\n        <DED>return ret\n    <DED>except ValueError as why:\n        <IND>raise_failure_explanation('BITFINEX', why, {\"tickers?symbols=ALL\": r1, \"pub:map:currency:sym\": r2})\n\n\n<DED><DED>def bitflyer_symbols() -> Dict[str, str]:\n    <IND>endpoint = r = None\n    try:\n        <IND>ret = {}\n        endpoints = ['https://api.bitflyer.com/v1/getmarkets/eu', 'https://api.bitflyer.com/v1/getmarkets/usa', 'https://api.bitflyer.com/v1/getmarkets']\n        for endpoint in endpoints:\n            <IND>r = requests.get(endpoint)\n            for entry in r.json():\n                <IND>normalized = entry['product_code'].replace(\"_\", SYMBOL_SEP)\n                ret[normalized] = entry['product_code']\n        <DED><DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BITFLYER', why, {endpoint: r})\n\n\n<DED><DED>def bybit_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.bybit.com/v2/public/symbols')\n        ret = {}\n        for symbol in r.json()['result']:\n            <IND>quote = symbol['quote_currency']\n            if not symbol['name'].endswith(quote):\n                <IND>base, contract = symbol['name'].split(quote)\n                normalized = f\"{base}{SYMBOL_SEP}{quote}-{contract}\"\n            <DED>else:\n                <IND>normalized = f\"{symbol['base_currency']}{SYMBOL_SEP}{quote}\"\n            <DED>ret[normalized] = symbol['name']\n            _exchange_info[BYBIT]['tick_size'][normalized] = symbol['price_filter']['tick_size']\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BYBIT', why, {\"\": r})\n\n\n<DED><DED>def _ftx_helper(endpoint: str, exchange: str):\n    <IND>r = None\n    try:\n        <IND>r = requests.get(endpoint)\n        ret = {}\n        for data in r.json()['result']:\n            <IND>normalized = data['name'].replace(\"/\", SYMBOL_SEP)\n            symbol = data['name']\n            ret[normalized] = symbol\n            _exchange_info[exchange]['tick_size'][normalized] = data['priceIncrement']\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation(exchange, why, {endpoint: r})\n\n\n<DED><DED>def ftx_symbols() -> Dict[str, str]:\n    <IND>return _ftx_helper('https://ftx.com/api/markets', FTX)\n\n\n<DED>def ftx_us_symbols() -> Dict[str, str]:\n    <IND>return _ftx_helper('https://ftx.us/api/markets', FTX_US)\n\n\n<DED>def coinbase_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.pro.coinbase.com/products')\n        ret = {}\n        for data in r.json():\n            <IND>normalized = data['id'].replace(\"-\", SYMBOL_SEP)\n            ret[normalized] = data['id']\n            _exchange_info[COINBASE]['tick_size'][normalized] = data['quote_increment']\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('COINBASE', why, {\"\": r})\n\n\n<DED><DED>def gemini_symbols(*args) -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.gemini.com/v1/symbols')\n        ret = {}\n        for symbol in r.json():\n            <IND>std = f\"{symbol[:-3]}{SYMBOL_SEP}{symbol[-3:]}\"\n            std = std.upper()\n            ret[std] = symbol.upper()\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('GEMINI', why, {\"\": r})\n\n\n<DED><DED>def hitbtc_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>ret = {}\n        r = requests.get('https://api.hitbtc.com/api/2/public/symbol')\n        for symbol in r.json():\n            <IND>split = len(symbol['baseCurrency'])\n            normalized = symbol['id'][:split] + SYMBOL_SEP + symbol['id'][split:]\n            ret[normalized] = symbol['id']\n            _exchange_info[HITBTC]['tick_size'][normalized] = symbol['tickSize']\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('HITBTC', why, {\"\": r})\n\n\n<DED><DED>def poloniex_id_symbol_mapping():\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://poloniex.com/public?command=returnTicker')\n        symbols = r.json()\n        ret = {}\n        for symbol in symbols:\n            <IND>ret[symbols[symbol]['id']] = symbol\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('POLONIEX', why, {\"\": r})\n\n\n<DED><DED>def poloniex_symbols() -> Dict[str, str]:\n    <IND>ret = {}\n    for _, value in poloniex_id_symbol_mapping().items():\n        <IND>std = value.replace(\"STR\", \"XLM\")\n        quote, base = std.split(\"_\")\n        ret[quote + SYMBOL_SEP + base] = value\n    <DED>return ret\n\n\n<DED>def bitstamp_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://www.bitstamp.net/api/v2/trading-pairs-info/')\n        ret = {}\n        for data in r.json():\n            <IND>normalized = data['name'].replace(\"/\", SYMBOL_SEP)\n            symbol = data['url_symbol']\n            ret[normalized] = symbol\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BITSTAMP', why, {\"\": r})\n\n\n<DED><DED>def kraken_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.kraken.com/0/public/AssetPairs')\n        data = r.json()\n        ret = {}\n        for symbol in data['result']:\n            <IND>if 'wsname' not in data['result'][symbol] or '.d' in symbol:\n                # https://blog.kraken.com/post/259/introducing-the-kraken-dark-pool/\n                # .d is for dark pool symbols\n                <IND>continue\n\n            <DED>base, quote = data['result'][symbol]['wsname'].split(\"/\")\n\n            normalized = f\"{base}{SYMBOL_SEP}{quote}\"\n            exch = data['result'][symbol]['wsname']\n            normalized = normalized.replace('XBT', 'BTC')\n            normalized = normalized.replace('XDG', 'DOG')\n            ret[normalized] = exch\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('KRAKEN', why, {\"\": r})\n\n\n<DED><DED>def kraken_rest_symbols() -> Dict[str, str]:\n    <IND>return {normalized: exchange.replace(\"/\", \"\") for normalized, exchange in kraken_symbols().items()}\n\n\n<DED>def exx_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.exx.com/data/v1/tickers')\n        exchange = [key.upper() for key in r.json().keys()]\n        symbols = [key.replace(\"_\", SYMBOL_SEP) for key in exchange]\n        return dict(zip(symbols, exchange))\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('EXX', why, {\"\": r})\n\n\n<DED><DED>def huobi_common_symbols(url: str):\n    <IND>r = None\n    try:\n        <IND>r = requests.get(url)\n        ret = {}\n        for e in r.json()['data']:\n            <IND>if e['state'] == 'offline':\n                <IND>continue\n            <DED>normalized = f\"{e['base-currency'].upper()}{SYMBOL_SEP}{e['quote-currency'].upper()}\"\n            symbol = f\"{e['base-currency']}{e['quote-currency']}\"\n            ret[normalized] = symbol\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('HUOBI', why, {url: r})\n\n\n<DED><DED>def huobi_symbols() -> Dict[str, str]:\n    <IND>return huobi_common_symbols('https://api.huobi.pro/v1/common/symbols')\n\n\n<DED>def huobi_us_symbols() -> Dict[str, str]:\n    <IND>return huobi_common_symbols('https://api.huobi.com/v1/common/symbols')\n\n\n<DED>def huobi_dm_symbols() -> Dict[str, str]:\n    <IND>\"\"\"\n    Mapping is, for instance: {\"BTC_CW\":\"BTC190816\"}\n    See comments in exchange/huobi_dm.py\n    \"\"\"\n    mapping = {\n        \"this_week\": \"CW\",\n        \"next_week\": \"NW\",\n        \"quarter\": \"CQ\",\n        \"next_quarter\": \"NQ\"\n    }\n    r = None\n    try:\n        <IND>r = requests.get('https://www.hbdm.com/api/v1/contract_contract_info')\n        symbols = {}\n        for e in r.json()['data']:\n            <IND>symbols[f\"{e['symbol']}_{mapping[e['contract_type']]}\"] = e['contract_code']\n            _exchange_info[HUOBI_DM]['tick_size'][e['contract_code']] = e['price_tick']\n            _exchange_info[HUOBI_DM]['short_code_mappings'][f\"{e['symbol']}_{mapping[e['contract_type']]}\"] = e['contract_code']\n        <DED>return symbols\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('HUOBI_DM', why, {\"\": r})\n\n\n<DED><DED>def huobi_swap_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.hbdm.com/swap-api/v1/swap_contract_info')\n        symbols = {}\n        for e in r.json()['data']:\n            <IND>symbols[e['contract_code']] = e['contract_code']\n            _exchange_info[HUOBI_SWAP]['tick_size'][e['contract_code']] = e['price_tick']\n        <DED>return symbols\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('HUOBI_SWAP', why, {\"\": r})\n\n\n<DED><DED>def okcoin_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://www.okcoin.com/api/spot/v3/instruments')\n        ret = {}\n        for e in r.json():\n            <IND>ret[e['instrument_id']] = e['instrument_id']\n            _exchange_info[OKCOIN]['tick_size'][e['instrument_id']] = e['tick_size']\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('OKCOIN', why, {\"\": r})\n\n\n<DED><DED>def okex_symbols(*args) -> Dict[str, str]:\n    <IND>urls = ['https://www.okex.com/api/spot/v3/instruments',\n            'https://www.okex.com/api/swap/v3/instruments',\n            'https://www.okex.com/api/futures/v3/instruments']\n    urls = urls + okex_compute_option_urls_from_underlyings()\n\n    symbols: Dict[str, str] = {}\n    for u in urls:\n        <IND>time.sleep(0.2)\n        symbols.update(okex_symbols_from_one_url(u))\n\n    <DED>for symbol in symbols:\n        <IND>instrument_type = 'futures'\n        dash_count = symbol.count(get_symbol_separator())\n        if dash_count == 1:  # BTC-USDT\n            <IND>instrument_type = 'spot'\n        <DED>if dash_count == 4:  # BTC-USD-201225-35000-P\n            <IND>instrument_type = 'option'\n        <DED>if symbol[-4:] == \"SWAP\":  # BTC-USDT-SWAP\n            <IND>instrument_type = 'swap'\n\n        <DED>_exchange_info[OKEX]['instrument_type'][symbol] = instrument_type\n\n    <DED>return symbols\n\n\n<DED>def okex_compute_option_urls_from_underlyings() -> List[str]:\n    <IND>url = 'https://www.okex.com/api/option/v3/underlying'\n    r = None\n    try:\n        <IND>r = requests.get(url)\n        return [f'https://www.okex.com/api/option/v3/instruments/{underlying}' for underlying in r.json()]\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('OKEX', why, {url: r})\n\n\n<DED><DED>def okex_symbols_from_one_url(url: str) -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get(url)\n        ret = {}\n        for e in r.json():\n            <IND>ret[e['instrument_id']] = e['instrument_id']\n            _exchange_info[OKEX]['tick_size'][e['instrument_id']] = e['tick_size']\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('OKEX', why, {url: r})\n\n\n<DED><DED>def bittrex_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.bittrex.com/api/v1.1/public/getmarkets')\n        r = r.json()['result']\n        return {f\"{e['MarketCurrency']}{SYMBOL_SEP}{e['BaseCurrency']}\": e['MarketName'] for e in r if e['IsActive']}\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BITTREX', why, {\"\": r})\n\n\n<DED><DED>def bitcoincom_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.exchange.bitcoin.com/api/2/public/symbol')\n        return {f\"{data['baseCurrency']}{SYMBOL_SEP}{data['quoteCurrency'].replace('USD', 'USDT')}\": data['id'] for data in r.json()}\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BITCOINCOM', why, {\"\": r})\n\n\n<DED><DED>def bitmax_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://bitmax.io/api/pro/v1/products')\n        ret = {}\n        for entry in r.json()['data']:\n            # Only \"Normal\" status symbols are tradeable\n            <IND>if entry['status'] == 'Normal':\n                <IND>normalized = f\"{entry['baseAsset']}{SYMBOL_SEP}{entry['quoteAsset']}\"\n                ret[normalized] = entry['symbol']\n                _exchange_info[BITMAX]['tick_size'][normalized] = entry['tickSize']\n        <DED><DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BITMAX', why, {\"\": r})\n\n\n<DED><DED>def upbit_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.upbit.com/v1/market/all')\n        return {f\"{data['market'].split('-')[1]}{SYMBOL_SEP}{data['market'].split('-')[0]}\": data['market'] for data in r.json()}\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('UPBIT', why, {\"\": r})\n\n\n<DED><DED>def blockchain_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get(\"https://api.blockchain.com/mercury-gateway/v1/instruments\")\n        return {data[\"symbol\"].replace(\"-\", SYMBOL_SEP): data[\"symbol\"] for data in r.json()}\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BLOCKCHAIN', why, {\"\": r})\n\n\n<DED><DED>def gateio_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get(\"https://api.gateio.ws/api/v4/spot/currency_pairs\")\n        return {data[\"id\"].replace(\"_\", SYMBOL_SEP): data['id'] for data in r.json()}\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('GATEIO', why, {\"\": r})\n\n\n<DED><DED>def bitmex_symbols() -> Dict[str, str]:\n    <IND>r = None\n    ret = {}\n    try:\n        <IND>r = requests.get(\"https://www.bitmex.com/api/v1/instrument/active\")\n        for entry in r.json():\n            <IND>components = []\n            components.append(entry['rootSymbol'])\n            components.append(entry['quoteCurrency'])\n\n            if entry['expiry']:\n                <IND>components.append(entry['symbol'][-3:])\n\n            <DED>normalized = SYMBOL_SEP.join(components)\n            normalized = normalized.replace(\"XBT\", \"BTC\")\n            ret[normalized] = entry['symbol']\n            _exchange_info[BITMEX]['tick_size'][normalized] = entry['tickSize']\n\n            if entry['expiry']:\n                <IND>_exchange_info[BITMEX]['expiry'][normalized] = entry['expiry']\n\n        <DED><DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BITMEX', why, {\"\": r})\n\n\n<DED><DED>def deribit_symbols() -> Dict[str, str]:\n    <IND>url = r = None\n    ret = {}\n    try:\n        # TODO: get currencies from https://www.deribit.com/api/v2/public/get_currencies\n        <IND>currencies = ['BTC', 'ETH']\n        for c in currencies:\n            <IND>url = f\"https://www.deribit.com/api/v2/public/get_instruments?currency={c}&expired=false\"\n            r = requests.get(url)\n            for entry in r.json()['result']:\n                <IND>split = entry['instrument_name'].split(\"-\")\n                normalized = split[0] + SYMBOL_SEP + entry['quote_currency'] + \"-\" + '-'.join(split[1:])\n                ret[normalized] = entry['instrument_name']\n                _exchange_info[DERIBIT]['tick_size'][normalized] = entry['tick_size']\n        <DED><DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('DERIBIT', why, {url: r})\n\n\n<DED><DED>def kraken_future_symbols() -> Dict[str, str]:\n    <IND>r = None\n    ret = {}\n    try:\n        <IND>r = requests.get('https://futures.kraken.com/derivatives/api/v3/instruments')\n        data = r.json()['instruments']\n        for entry in data:\n            <IND>if not entry['tradeable']:\n                <IND>continue\n            <DED>normalized = entry['symbol'].upper().replace(\"_\", \"-\")\n            symbol = normalized[3:6] + SYMBOL_SEP + normalized[6:9]\n            normalized = normalized.replace(normalized[3:9], symbol)\n            normalized = normalized.replace('XBT', 'BTC')\n\n            _exchange_info[KRAKEN_FUTURES]['tick_size'][normalized] = entry['tickSize']\n            _exchange_info[KRAKEN_FUTURES]['contract_size'][normalized] = entry['contractSize']\n            _exchange_info[KRAKEN_FUTURES]['underlying'][normalized] = entry['underlying']\n            _exchange_info[KRAKEN_FUTURES]['product_type'][normalized] = _kraken_futures_product_type[normalized[:2]]\n            ret[normalized] = entry['symbol']\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('KRAKEN_FUTURES', why, {\"\": r})\n\n\n<DED><DED>def probit_symbols() -> Dict[str, str]:\n    # doc: https://docs-en.probit.com/reference-link/market\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.probit.com/api/exchange/v1/market')\n        return {entry['id']: entry['id'] for entry in r.json()['data']}\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('PROBIT', why, {\"\": r})\n\n\n<DED><DED>def coingecko_normalize_symbol(symbol: str) -> str:\n    # keep digits, letters and dots, replace others by space\n    <IND>symbol = ''.join(c if c.isalnum() or c in ('.', '+') else ' ' for c in symbol)\n    return coingecko_normalize(symbol.upper())\n\n\n<DED>def coingecko_normalize_name(name: str) -> str:\n    # keep digits and letters, replace others by space (except when only composed by upper case letters, digits and dots)\n    <IND>if not all(c.isupper() or c.isdigit() or c == '.' for c in name):\n        <IND>name = ''.join(c if c.isalnum() else ' ' for c in name)\n    <DED>return coingecko_normalize(name)\n\n\n<DED>def coingecko_normalize(sym: str) -> str:\n    <IND>sym = sym.strip()\n    # do not concatenate numbers => separate them with a dot\n    sym = list(sym)\n    if len(sym) > 4:\n        <IND>for i in range(2, len(sym) - 1):\n            <IND>if sym[i] == ' ' and sym[i - 1].isdigit() and sym[i + 1].isdigit():\n                <IND>sym[i] = '.'\n    <DED><DED><DED>sym = ''.join(sym)\n    # concatenate space-separated words => use CamelCase to distinguish the words\n    if ' ' in sym:\n        <IND>if sum(c.islower() for c in sym):  # if there is at least one lower case letter\n            <IND>sym = ' '.join(word[0].upper() + word[1:] for word in sym.split())  # Just capitalize initial letter of each word\n        <DED>else:  # CoinGecko may provide full upper-case as for \"THE STONE COIN\"\n            <IND>sym = string.capwords(sym)  # capwords converts \"THE STONE COIN\" to \"The Stone Coin\"\n        <DED>sym = sym.replace(' ', '')  # concatenate words\n    <DED>return sym\n\n\n<DED>def is_name_short(coin: dict) -> bool:\n    <IND>\"\"\"return True if the coin name is enough short compared to the coin symbol.\"\"\"\n    return len(coin['name']) <= max(5, len(coin['symbol']) + 1)\n\n\n<DED>def has_many_caps(name: str) -> bool:\n    <IND>\"\"\"return True if the symbol contains enough upper case letters, False if empty.\"\"\"\n    return str and sum(c.islower() for c in name) < (len(name) / 2)\n\n\n<DED>def coingecko_normalize_all(coin: dict):\n    <IND>SYMBOL_TO_NORMALIZED = {'miota': 'IOTA'}\n    normalized = SYMBOL_TO_NORMALIZED.get(coin['symbol'])\n    if normalized:\n        <IND>coin['ns'] = coin['nn'] = normalized\n        return normalized\n\n    # ns = normalized symbol, nn = normalized name\n    <DED>coin['ns'] = coingecko_normalize_symbol(coin['symbol'])\n\n    ID_SUFFIX = '-bitcoin-token'\n    if coin['id'][-len(ID_SUFFIX):] == ID_SUFFIX:\n        <IND>coin['nn'] = 'BTC' + coin['ns']\n        return coin['nn']\n\n    <DED>name = coin['name']\n\n    prefixes = ('The ', 'the ')\n    for p in prefixes:\n        <IND>if name[:len(p)] == p:\n            <IND>coin['reduced-name'] = True\n            name = name[len(p):]\n            break\n\n    <DED><DED>suffixes = ('coin', 'coins', 'money', 'finance', 'protocol', 'reward', 'rewards', 'token')\n    for s in suffixes:\n        <IND>if len(name) > len(s) and name[-len(s):].lower() == s:\n            # but keep suffix when lower-case concatenated\n            <IND>if name[-len(s)].islower() and name[-len(s) - 1] != ' ':\n                <IND>continue\n            # also keep suffix to avoid confusing nam: \"Bitcoin Token\" -> \"Bitcoin\"\n            <DED>if name[:-len(s)].strip().lower() == 'bitcoin':\n                <IND>continue\n            <DED>coin['reduced-name'] = True\n            name = name[:-len(s)]\n            break\n\n    <DED><DED>coin['nn'] = coingecko_normalize_name(name)\n\n    if len(coin['nn']) < len(coin['ns']):\n        <IND>if 'reduced-name' in coin:\n            <IND>coin['reduced-name'] = False\n            name = coin['name']\n            coin['nn'] = coingecko_normalize_name(name)\n        <DED>elif not has_many_caps(name):\n            <IND>return coin['ns']\n\n    <DED><DED>if not coin['ns']:  # coin['symbol'] may be an emoji that is striped when normalized\n        <IND>return coin['nn']\n\n    <DED>if coin.get('reduced-name') and coin['ns'].upper() != coin['nn'].upper():\n        <IND>return coin['ns']\n\n    <DED>i = coin['nn'].find('.')  # if there is a dot in normalized name => prefer the normalized symbol\n    if i >= 0:\n        <IND>if i > 1 and coin['nn'][i - 1].isdigit() and coin['nn'][i + 1].isdigit():\n            <IND>pass  # except when the dot separates digits\n        <DED>else:\n            <IND>return coin['ns']\n\n    <DED><DED>if is_name_short(coin) and has_many_caps(name):\n        <IND>return coin['nn']\n\n    <DED>if 1.5 * len(coin['ns']) > len(coin['nn']) and any(c.islower() for c in coin['ns']):\n        <IND>return coin['nn']\n\n    <DED>return coin['ns']\n\n\n<DED>def coingecko_symbols() -> Dict[str, str]:\n    <IND>r = None\n    intermediate = defaultdict(list)\n    try:\n        <IND>r = requests.get('https://api.coingecko.com/api/v3/coins/list')\n        all_coins = r.json()\n        # First pass: generate & compare normalized symbol/name, and then select the most pertinent\n        for coin in all_coins:\n            <IND>normalized = coingecko_normalize_all(coin)\n            intermediate[normalized].append(coin)\n            # Above line keeps together the coins having the same normalized symbol.\n            # To reduce collision, the coin['name'] is sometimes used in lieu of the coin['symbol'].\n            # The coin['name'] is not capitalized because lower case letters may be meaningful: cETH, yUSD, DATx, zLOT\n    <DED><DED>except Exception as why:\n        <IND>raise_failure_explanation('COINGECKO', why, {\"\": r})\n\n    <DED>final = coingecko_second_pass(intermediate)\n    return coingecko_third_pass(final)\n\n\n<DED>def coingecko_second_pass(intermediate: Dict[str, List[dict]]) -> Dict[str, List[dict]]:\n    # Second pass: fixes most of the symbol collisions\n    <IND>final = defaultdict(list)\n    for normalized, coins in intermediate.items():\n        <IND>if len(coins) == 1:\n            <IND>final[normalized].append(coins[0])\n            continue\n        <DED>set_normalized = False\n        for i in range(len(coins)):\n            <IND>if normalized == coins[i]['nn']:\n                <IND>coin = coins.pop(i)\n                final[normalized].append(coin)\n                set_normalized = True\n                break\n        <DED><DED>rest: List[dict] = []\n        for coin in coins:\n            <IND>if '%' in coin['name']:\n                <IND>if len(coins) == 1:\n                    <IND>n = coin['ns']\n                <DED>else:\n                    <IND>n = coingecko_normalize_name(coin['id'])\n                <DED>final[n].append(coin)\n            <DED>else:\n                <IND>rest.append(coin)\n        <DED><DED>if not rest:\n            <IND>continue\n        <DED>if not set_normalized:\n            <IND>rest.sort(key=lambda coin: len(coin['nn']), reverse=True)  # sort by the length of the normalized name\n            coin = rest.pop(0)\n            final[normalized].append(coin)\n        <DED>for coin in rest:\n            <IND>if coin['nn'] not in intermediate:\n                <IND>n = coin['nn']\n            <DED>elif coin.get('reduced-name'):\n                <IND>n = coingecko_normalize_name(coin['name'])\n            <DED>else:\n                <IND>n = coingecko_normalize_name(coin['id'])\n            <DED>final[n].append(coin)\n    <DED><DED>return final\n\n\n<DED>def coingecko_third_pass(final: Dict[str, List[dict]]) -> Dict[str, str]:\n    # Third pass: fixes some remaining collisions and fills the result\n    <IND>symbols = {}\n    for normalized, coins in final.items():\n        <IND>if len(coins) == 1:\n            <IND>symbols[normalized] = coins[0]['id']\n            continue\n        <DED>set_normalized = False\n        for i in range(len(coins)):\n            <IND>if normalized == coins[i]['nn']:\n                <IND>coin = coins.pop(i)\n                symbols[normalized] = coin['id']\n                set_normalized = True\n                break\n        <DED><DED>rest: List[dict] = []\n        for coin in coins:\n            <IND>if '%' in coin['name']:\n                <IND>if len(coins) == 1:\n                    <IND>n = coin['ns']\n                <DED>else:\n                    <IND>n = coingecko_normalize_name(coin['id'])\n                <DED>symbols[n] = coin['id']\n            <DED>else:\n                <IND>rest.append(coin)\n        <DED><DED>if not rest:\n            <IND>continue\n        <DED>if not set_normalized:\n            <IND>rest.sort(key=lambda coin: len(coin['nn']), reverse=True)  # sort by the length of the normalized name\n            coin = rest.pop(0)\n            symbols[normalized] = coin['id']\n        <DED>for coin in rest:\n            <IND>if coin['nn'] not in final:\n                <IND>n = coin['nn']\n            <DED>elif coin.get('reduced-name'):\n                <IND>n = coingecko_normalize_name(coin['name'])\n            <DED>else:\n                <IND>n = coingecko_normalize_name(coin['id'])\n            <DED>symbols[n] = coin['id']\n    <DED><DED>return symbols\n\n\n<DED>def whale_alert_coins(key_id: str) -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get(f'https://api.whale-alert.io/v1/status?api_key={key_id}')\n        # Same symbols, but on different blockchains (for instance USDT), are naturally overwritten.\n        return {s.upper(): s for b in r.json()['blockchains'] for s in b['symbols'] if s}\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('WHALES_ALERT', why, {\"\": r})\n\n\n<DED><DED>_exchange_function_map = {\n    BITFINEX: bitfinex_symbols,\n    BITFLYER: bitflyer_symbols,\n    COINBASE: coinbase_symbols,\n    GEMINI: gemini_symbols,\n    HITBTC: hitbtc_symbols,\n    POLONIEX: poloniex_symbols,\n    PROBIT: probit_symbols,\n    BITSTAMP: bitstamp_symbols,\n    KRAKEN: kraken_symbols,\n    KRAKEN + 'REST': kraken_rest_symbols,\n    BINANCE: binance_symbols,\n    BINANCE_US: binance_us_symbols,\n    BINANCE_FUTURES: binance_futures_symbols,\n    BINANCE_DELIVERY: binance_delivery_symbols,\n    BLOCKCHAIN: blockchain_symbols,\n    EXX: exx_symbols,\n    HUOBI: huobi_symbols,\n    HUOBI_DM: huobi_dm_symbols,\n    HUOBI_SWAP: huobi_swap_symbols,\n    OKCOIN: okcoin_symbols,\n    OKEX: okex_symbols,\n    BYBIT: bybit_symbols,\n    FTX: ftx_symbols,\n    FTX_US: ftx_us_symbols,\n    BITTREX: bittrex_symbols,\n    BITCOINCOM: bitcoincom_symbols,\n    BITMAX: bitmax_symbols,\n    UPBIT: upbit_symbols,\n    GATEIO: gateio_symbols,\n    BITMEX: bitmex_symbols,\n    DERIBIT: deribit_symbols,\n    KRAKEN_FUTURES: kraken_future_symbols,\n    COINGECKO: coingecko_symbols,\n    WHALE_ALERT: whale_alert_coins\n}\n",
        "target_code_with_indent": "\nfrom typing import Dict, Tuple\n\n\nclass _Symbols:\n    <IND>def __init__(self):\n        <IND>self.data = {}\n\n    <DED>def set(self, exchange: str, normalized: dict, exchange_info: dict):\n        <IND>self.data[exchange] = {}\n        self.data[exchange]['normalized'] = normalized\n        self.data[exchange]['info'] = exchange_info\n\n    <DED>def get(self, exchange: str) -> Tuple[Dict, Dict]:\n        <IND>return self.data[exchange]['normalized'], self.data[exchange]['info']\n\n    <DED>def populated(self, exchange: str) -> bool:\n        <IND>return exchange in self.data\n\n\n<DED><DED>Symbols = _Symbols()\n"
      }
    ]
  },
  {
    "project": "bmoscon/cryptofeed",
    "commit": "3525dc8ce4d7836a9abaaa5662e58e5e27969a77",
    "filename": "cryptofeed/symbols.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/bmoscon-cryptofeed/cryptofeed/symbols.py",
    "file_hunks_size": 1,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "cryptofeed/symbols.py:234:8 Incompatible return type [7]: Expected `Dict[str, str]` but got implicit return value of `None`.",
    "message": " Expected `Dict[str, str]` but got implicit return value of `None`.",
    "rule_id": "Incompatible return type [7]",
    "warning_line_no": 234,
    "warning_line": "        raise_failure_explanation('GEMINI', why, {\"\": r})",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "associated with this software.\n\n\nSymbol generation code for exchanges\n'''\n\nimport logging\nimport string\nimport time\nfrom collections import defaultdict\nfrom typing import Dict, List, Optional, Tuple\n\nimport requests\nfrom requests import Response\n\nfrom cryptofeed.defines import *\n\n\nLOG = logging.getLogger('feedhandler')\n\nSYMBOL_SEP = '-'\n\n_symbols_retrieval_cache: Dict[str, Dict[str, str]] = {}\n_exchange_info = defaultdict(lambda: defaultdict(dict))\n\n\n_kraken_futures_product_type = {\n    'FI': 'Inverse Futures',\n    'FV': 'Vanilla Futures',\n    'PI': 'Perpetual Inverse Futures',\n    'PV': 'Perpetual Vanilla Futures',\n    'IN': 'Real Time Index',\n    'RR': 'Reference Rate',\n}\n\n\ndef raise_failure_explanation(feed_id: str, exception: BaseException, responses: Dict[str, Optional[Response]]):\n    LOG.critical('%s: encountered %r while processing response from exchange API', feed_id, exception)\n    if len(responses) > 1:\n        LOG.critical('%s: content of one of the %s responses was unexpected', feed_id, len(responses))\n    for url, r in responses.items():\n        if url:\n            LOG.critical('%s: requested URL: %s', feed_id, url)\n        if r:\n            LOG.critical('%s: unexpected response: %s', feed_id, r.text)\n    raise ValueError(f'Cryptofeed stopped because of an unexpected response from {feed_id}') from exception\n\n\ndef set_symbol_separator(separator: str):\n    global SYMBOL_SEP\n    SYMBOL_SEP = separator\n\n\ndef get_symbol_separator() -> str:\n    global SYMBOL_SEP\n    return SYMBOL_SEP\n\n\ndef gen_symbols(exchange: str, key_id=None) -> Dict[str, str]:\n    if exchange not in _symbols_retrieval_cache:\n        LOG.info(\"%s: Getting list of symbols\", exchange)\n        symbols = _exchange_function_map[exchange](key_id) if key_id else _exchange_function_map[exchange]()\n        LOG.info(\"%s: %s symbols\", exchange, len(symbols))\n\n        # log all retrieved symbols using debug level\n        for normalized, exch_sym in sorted(symbols.items()):\n            LOG.debug('%s: id-from-exch -> normalized: %-35s-> %s', exchange, exch_sym, normalized)\n\n        _symbols_retrieval_cache[exchange] = symbols\n    return _symbols_retrieval_cache[exchange]\n\n\ndef _binance_symbols(endpoint: str, exchange: str):\n    r = None\n    try:\n        ret = {}\n        r = requests.get(endpoint)\n        for symbol in r.json()['symbols']:\n            if symbol.get('status', 'TRADING') != \"TRADING\":\n                continue\n            if symbol.get('contractStatus', 'TRADING') != \"TRADING\":\n                continue\n            split = len(symbol['baseAsset'])\n            normalized = symbol['symbol'][:split] + SYMBOL_SEP + symbol['symbol'][split:]\n            ret[normalized] = symbol['symbol']\n            _exchange_info[exchange]['tick_size'][normalized] = symbol['filters'][0]['tickSize']\n            if \"contractType\" in symbol:\n                _exchange_info[exchange]['contract_type'][normalized] = symbol['contractType']\n        return ret\n    except Exception as why:\n        raise_failure_explanation(exchange, why, {endpoint: r})\n\n\ndef binance_symbols() -> Dict[str, str]:\n    return _binance_symbols('https://api.binance.com/api/v3/exchangeInfo', BINANCE)\n\n\ndef binance_us_symbols() -> Dict[str, str]:\n    return _binance_symbols('https://api.binance.us/api/v3/exchangeInfo', BINANCE_US)\n\n\ndef binance_futures_symbols() -> Dict[str, str]:\n    base = _binance_symbols('https://fapi.binance.com/fapi/v1/exchangeInfo', BINANCE_FUTURES)\n    add = {}\n    for symbol, orig in base.items():\n        if \"_\" in orig:\n            continue\n        add[f\"{symbol}-PINDEX\"] = f\"p{orig}\"\n    base.update(add)\n    return base\n\n\ndef binance_delivery_symbols() -> Dict[str, str]:\n    return _binance_symbols('https://dapi.binance.com/dapi/v1/exchangeInfo', BINANCE_DELIVERY)\n\n\ndef bitfinex_symbols() -> Dict[str, str]:\n    # doc: https://docs.bitfinex.com/docs/ws-general#supported-pairs\n    r1 = r2 = None\n    try:\n        r1 = requests.get('https://api.bitfinex.com/v2/tickers?symbols=ALL')\n        r2 = requests.get('https://api-pub.bitfinex.com/v2/conf/pub:map:currency:sym')\n        tickers: List[List[str]] = r1.json()\n        norm: List[Tuple[str, str]] = r2.json()[0]\n        norm: Dict[str, str] = dict(norm)\n        for k, v in dict(norm).items():\n            if k[-2:] == 'F0' or '-' in v:  # Do not convert BTCF0 -> BTC or PBTCETH -> PBTC-ETH\n                del norm[k]\n        norm['BCHN'] = 'BCH'  # Bitfinex uses BCHN, other exchanges use BCH\n\n        ret = {}\n        for symbol in [t[0] for t in tickers]:\n            if symbol[0] == 'f':\n                normalized = norm.get(symbol[1:], symbol[1:])\n            else:\n                if len(symbol) == 7:\n                    base, quote = symbol[1:4], symbol[4:]\n                else:\n                    base, quote = symbol[1:].split(':')\n                    assert ':' in symbol\n                normalized = norm.get(base, base) + SYMBOL_SEP + norm.get(quote, quote)\n            ret[normalized.upper()] = symbol\n        return ret\n    except ValueError as why:\n        raise_failure_explanation('BITFINEX', why, {\"tickers?symbols=ALL\": r1, \"pub:map:currency:sym\": r2})\n\n\ndef bitflyer_symbols() -> Dict[str, str]:\n    endpoint = r = None\n    try:\n        ret = {}\n        endpoints = ['https://api.bitflyer.com/v1/getmarkets/eu', 'https://api.bitflyer.com/v1/getmarkets/usa', 'https://api.bitflyer.com/v1/getmarkets']\n        for endpoint in endpoints:\n            r = requests.get(endpoint)\n            for entry in r.json():\n                normalized = entry['product_code'].replace(\"_\", SYMBOL_SEP)\n                ret[normalized] = entry['product_code']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('BITFLYER', why, {endpoint: r})\n\n\ndef bybit_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.bybit.com/v2/public/symbols')\n        ret = {}\n        for symbol in r.json()['result']:\n            quote = symbol['quote_currency']\n            if not symbol['name'].endswith(quote):\n                base, contract = symbol['name'].split(quote)\n                normalized = f\"{base}{SYMBOL_SEP}{quote}-{contract}\"\n            else:\n                normalized = f\"{symbol['base_currency']}{SYMBOL_SEP}{quote}\"\n            ret[normalized] = symbol['name']\n            _exchange_info[BYBIT]['tick_size'][normalized] = symbol['price_filter']['tick_size']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('BYBIT', why, {\"\": r})\n\n\ndef _ftx_helper(endpoint: str, exchange: str):\n    r = None\n    try:\n        r = requests.get(endpoint)\n        ret = {}\n        for data in r.json()['result']:\n            normalized = data['name'].replace(\"/\", SYMBOL_SEP)\n            symbol = data['name']\n            ret[normalized] = symbol\n            _exchange_info[exchange]['tick_size'][normalized] = data['priceIncrement']\n        return ret\n    except Exception as why:\n        raise_failure_explanation(exchange, why, {endpoint: r})\n\n\ndef ftx_symbols() -> Dict[str, str]:\n    return _ftx_helper('https://ftx.com/api/markets', FTX)\n\n\ndef ftx_us_symbols() -> Dict[str, str]:\n    return _ftx_helper('https://ftx.us/api/markets', FTX_US)\n\n\ndef coinbase_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.pro.coinbase.com/products')\n        ret = {}\n        for data in r.json():\n            normalized = data['id'].replace(\"-\", SYMBOL_SEP)\n            ret[normalized] = data['id']\n            _exchange_info[COINBASE]['tick_size'][normalized] = data['quote_increment']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('COINBASE', why, {\"\": r})\n\n\ndef gemini_symbols(*args) -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.gemini.com/v1/symbols')\n        ret = {}\n        for symbol in r.json():\n            std = f\"{symbol[:-3]}{SYMBOL_SEP}{symbol[-3:]}\"\n            std = std.upper()\n            ret[std] = symbol.upper()\n        return ret\n    except Exception as why:\n        raise_failure_explanation('GEMINI', why, {\"\": r})\n\n\ndef hitbtc_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        ret = {}\n        r = requests.get('https://api.hitbtc.com/api/2/public/symbol')\n        for symbol in r.json():\n            split = len(symbol['baseCurrency'])\n            normalized = symbol['id'][:split] + SYMBOL_SEP + symbol['id'][split:]\n            ret[normalized] = symbol['id']\n            _exchange_info[HITBTC]['tick_size'][normalized] = symbol['tickSize']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('HITBTC', why, {\"\": r})\n\n\ndef poloniex_id_symbol_mapping():\n    r = None\n    try:\n        r = requests.get('https://poloniex.com/public?command=returnTicker')\n        symbols = r.json()\n        ret = {}\n        for symbol in symbols:\n            ret[symbols[symbol]['id']] = symbol\n        return ret\n    except Exception as why:\n        raise_failure_explanation('POLONIEX', why, {\"\": r})\n\n\ndef poloniex_symbols() -> Dict[str, str]:\n    ret = {}\n    for _, value in poloniex_id_symbol_mapping().items():\n        std = value.replace(\"STR\", \"XLM\")\n        quote, base = std.split(\"_\")\n        ret[quote + SYMBOL_SEP + base] = value\n    return ret\n\n\ndef bitstamp_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://www.bitstamp.net/api/v2/trading-pairs-info/')\n        ret = {}\n        for data in r.json():\n            normalized = data['name'].replace(\"/\", SYMBOL_SEP)\n            symbol = data['url_symbol']\n            ret[normalized] = symbol\n        return ret\n    except Exception as why:\n        raise_failure_explanation('BITSTAMP', why, {\"\": r})\n\n\ndef kraken_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.kraken.com/0/public/AssetPairs')\n        data = r.json()\n        ret = {}\n        for symbol in data['result']:\n            if 'wsname' not in data['result'][symbol] or '.d' in symbol:\n                # https://blog.kraken.com/post/259/introducing-the-kraken-dark-pool/\n                # .d is for dark pool symbols\n                continue\n\n            base, quote = data['result'][symbol]['wsname'].split(\"/\")\n\n            normalized = f\"{base}{SYMBOL_SEP}{quote}\"\n            exch = data['result'][symbol]['wsname']\n            normalized = normalized.replace('XBT', 'BTC')\n            normalized = normalized.replace('XDG', 'DOG')\n            ret[normalized] = exch\n        return ret\n    except Exception as why:\n        raise_failure_explanation('KRAKEN', why, {\"\": r})\n\n\ndef kraken_rest_symbols() -> Dict[str, str]:\n    return {normalized: exchange.replace(\"/\", \"\") for normalized, exchange in kraken_symbols().items()}\n\n\ndef exx_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.exx.com/data/v1/tickers')\n        exchange = [key.upper() for key in r.json().keys()]\n        symbols = [key.replace(\"_\", SYMBOL_SEP) for key in exchange]\n        return dict(zip(symbols, exchange))\n    except Exception as why:\n        raise_failure_explanation('EXX', why, {\"\": r})\n\n\ndef huobi_common_symbols(url: str):\n    r = None\n    try:\n        r = requests.get(url)\n        ret = {}\n        for e in r.json()['data']:\n            if e['state'] == 'offline':\n                continue\n            normalized = f\"{e['base-currency'].upper()}{SYMBOL_SEP}{e['quote-currency'].upper()}\"\n            symbol = f\"{e['base-currency']}{e['quote-currency']}\"\n            ret[normalized] = symbol\n        return ret\n    except Exception as why:\n        raise_failure_explanation('HUOBI', why, {url: r})\n\n\ndef huobi_symbols() -> Dict[str, str]:\n    return huobi_common_symbols('https://api.huobi.pro/v1/common/symbols')\n\n\ndef huobi_us_symbols() -> Dict[str, str]:\n    return huobi_common_symbols('https://api.huobi.com/v1/common/symbols')\n\n\ndef huobi_dm_symbols() -> Dict[str, str]:\n    \"\"\"\n    Mapping is, for instance: {\"BTC_CW\":\"BTC190816\"}\n    See comments in exchange/huobi_dm.py\n    \"\"\"\n    mapping = {\n        \"this_week\": \"CW\",\n        \"next_week\": \"NW\",\n        \"quarter\": \"CQ\",\n        \"next_quarter\": \"NQ\"\n    }\n    r = None\n    try:\n        r = requests.get('https://www.hbdm.com/api/v1/contract_contract_info')\n        symbols = {}\n        for e in r.json()['data']:\n            symbols[f\"{e['symbol']}_{mapping[e['contract_type']]}\"] = e['contract_code']\n            _exchange_info[HUOBI_DM]['tick_size'][e['contract_code']] = e['price_tick']\n            _exchange_info[HUOBI_DM]['short_code_mappings'][f\"{e['symbol']}_{mapping[e['contract_type']]}\"] = e['contract_code']\n        return symbols\n    except Exception as why:\n        raise_failure_explanation('HUOBI_DM', why, {\"\": r})\n\n\ndef huobi_swap_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.hbdm.com/swap-api/v1/swap_contract_info')\n        symbols = {}\n        for e in r.json()['data']:\n            symbols[e['contract_code']] = e['contract_code']\n            _exchange_info[HUOBI_SWAP]['tick_size'][e['contract_code']] = e['price_tick']\n        return symbols\n    except Exception as why:\n        raise_failure_explanation('HUOBI_SWAP', why, {\"\": r})\n\n\ndef okcoin_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://www.okcoin.com/api/spot/v3/instruments')\n        ret = {}\n        for e in r.json():\n            ret[e['instrument_id']] = e['instrument_id']\n            _exchange_info[OKCOIN]['tick_size'][e['instrument_id']] = e['tick_size']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('OKCOIN', why, {\"\": r})\n\n\ndef okex_symbols(*args) -> Dict[str, str]:\n    urls = ['https://www.okex.com/api/spot/v3/instruments',\n            'https://www.okex.com/api/swap/v3/instruments',\n            'https://www.okex.com/api/futures/v3/instruments']\n    urls = urls + okex_compute_option_urls_from_underlyings()\n\n    symbols: Dict[str, str] = {}\n    for u in urls:\n        time.sleep(0.2)\n        symbols.update(okex_symbols_from_one_url(u))\n\n    for symbol in symbols:\n        instrument_type = 'futures'\n        dash_count = symbol.count(get_symbol_separator())\n        if dash_count == 1:  # BTC-USDT\n            instrument_type = 'spot'\n        if dash_count == 4:  # BTC-USD-201225-35000-P\n            instrument_type = 'option'\n        if symbol[-4:] == \"SWAP\":  # BTC-USDT-SWAP\n            instrument_type = 'swap'\n\n        _exchange_info[OKEX]['instrument_type'][symbol] = instrument_type\n\n    return symbols\n\n\ndef okex_compute_option_urls_from_underlyings() -> List[str]:\n    url = 'https://www.okex.com/api/option/v3/underlying'\n    r = None\n    try:\n        r = requests.get(url)\n        return [f'https://www.okex.com/api/option/v3/instruments/{underlying}' for underlying in r.json()]\n    except Exception as why:\n        raise_failure_explanation('OKEX', why, {url: r})\n\n\ndef okex_symbols_from_one_url(url: str) -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get(url)\n        ret = {}\n        for e in r.json():\n            ret[e['instrument_id']] = e['instrument_id']\n            _exchange_info[OKEX]['tick_size'][e['instrument_id']] = e['tick_size']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('OKEX', why, {url: r})\n\n\ndef bittrex_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.bittrex.com/api/v1.1/public/getmarkets')\n        r = r.json()['result']\n        return {f\"{e['MarketCurrency']}{SYMBOL_SEP}{e['BaseCurrency']}\": e['MarketName'] for e in r if e['IsActive']}\n    except Exception as why:\n        raise_failure_explanation('BITTREX', why, {\"\": r})\n\n\ndef bitcoincom_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.exchange.bitcoin.com/api/2/public/symbol')\n        return {f\"{data['baseCurrency']}{SYMBOL_SEP}{data['quoteCurrency'].replace('USD', 'USDT')}\": data['id'] for data in r.json()}\n    except Exception as why:\n        raise_failure_explanation('BITCOINCOM', why, {\"\": r})\n\n\ndef bitmax_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://bitmax.io/api/pro/v1/products')\n        ret = {}\n        for entry in r.json()['data']:\n            # Only \"Normal\" status symbols are tradeable\n            if entry['status'] == 'Normal':\n                normalized = f\"{entry['baseAsset']}{SYMBOL_SEP}{entry['quoteAsset']}\"\n                ret[normalized] = entry['symbol']\n                _exchange_info[BITMAX]['tick_size'][normalized] = entry['tickSize']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('BITMAX', why, {\"\": r})\n\n\ndef upbit_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.upbit.com/v1/market/all')\n        return {f\"{data['market'].split('-')[1]}{SYMBOL_SEP}{data['market'].split('-')[0]}\": data['market'] for data in r.json()}\n    except Exception as why:\n        raise_failure_explanation('UPBIT', why, {\"\": r})\n\n\ndef blockchain_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get(\"https://api.blockchain.com/mercury-gateway/v1/instruments\")\n        return {data[\"symbol\"].replace(\"-\", SYMBOL_SEP): data[\"symbol\"] for data in r.json()}\n    except Exception as why:\n        raise_failure_explanation('BLOCKCHAIN', why, {\"\": r})\n\n\ndef gateio_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get(\"https://api.gateio.ws/api/v4/spot/currency_pairs\")\n        return {data[\"id\"].replace(\"_\", SYMBOL_SEP): data['id'] for data in r.json()}\n    except Exception as why:\n        raise_failure_explanation('GATEIO', why, {\"\": r})\n\n\ndef bitmex_symbols() -> Dict[str, str]:\n    r = None\n    ret = {}\n    try:\n        r = requests.get(\"https://www.bitmex.com/api/v1/instrument/active\")\n        for entry in r.json():\n            components = []\n            components.append(entry['rootSymbol'])\n            components.append(entry['quoteCurrency'])\n\n            if entry['expiry']:\n                components.append(entry['symbol'][-3:])\n\n            normalized = SYMBOL_SEP.join(components)\n            normalized = normalized.replace(\"XBT\", \"BTC\")\n            ret[normalized] = entry['symbol']\n            _exchange_info[BITMEX]['tick_size'][normalized] = entry['tickSize']\n\n            if entry['expiry']:\n                _exchange_info[BITMEX]['expiry'][normalized] = entry['expiry']\n\n        return ret\n    except Exception as why:\n        raise_failure_explanation('BITMEX', why, {\"\": r})\n\n\ndef deribit_symbols() -> Dict[str, str]:\n    url = r = None\n    ret = {}\n    try:\n        # TODO: get currencies from https://www.deribit.com/api/v2/public/get_currencies\n        currencies = ['BTC', 'ETH']\n        for c in currencies:\n            url = f\"https://www.deribit.com/api/v2/public/get_instruments?currency={c}&expired=false\"\n            r = requests.get(url)\n            for entry in r.json()['result']:\n                split = entry['instrument_name'].split(\"-\")\n                normalized = split[0] + SYMBOL_SEP + entry['quote_currency'] + \"-\" + '-'.join(split[1:])\n                ret[normalized] = entry['instrument_name']\n                _exchange_info[DERIBIT]['tick_size'][normalized] = entry['tick_size']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('DERIBIT', why, {url: r})\n\n\ndef kraken_future_symbols() -> Dict[str, str]:\n    r = None\n    ret = {}\n    try:\n        r = requests.get('https://futures.kraken.com/derivatives/api/v3/instruments')\n        data = r.json()['instruments']\n        for entry in data:\n            if not entry['tradeable']:\n                continue\n            normalized = entry['symbol'].upper().replace(\"_\", \"-\")\n            symbol = normalized[3:6] + SYMBOL_SEP + normalized[6:9]\n            normalized = normalized.replace(normalized[3:9], symbol)\n            normalized = normalized.replace('XBT', 'BTC')\n\n            _exchange_info[KRAKEN_FUTURES]['tick_size'][normalized] = entry['tickSize']\n            _exchange_info[KRAKEN_FUTURES]['contract_size'][normalized] = entry['contractSize']\n            _exchange_info[KRAKEN_FUTURES]['underlying'][normalized] = entry['underlying']\n            _exchange_info[KRAKEN_FUTURES]['product_type'][normalized] = _kraken_futures_product_type[normalized[:2]]\n            ret[normalized] = entry['symbol']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('KRAKEN_FUTURES', why, {\"\": r})\n\n\ndef probit_symbols() -> Dict[str, str]:\n    # doc: https://docs-en.probit.com/reference-link/market\n    r = None\n    try:\n        r = requests.get('https://api.probit.com/api/exchange/v1/market')\n        return {entry['id']: entry['id'] for entry in r.json()['data']}\n    except Exception as why:\n        raise_failure_explanation('PROBIT', why, {\"\": r})\n\n\ndef coingecko_normalize_symbol(symbol: str) -> str:\n    # keep digits, letters and dots, replace others by space\n    symbol = ''.join(c if c.isalnum() or c in ('.', '+') else ' ' for c in symbol)\n    return coingecko_normalize(symbol.upper())\n\n\ndef coingecko_normalize_name(name: str) -> str:\n    # keep digits and letters, replace others by space (except when only composed by upper case letters, digits and dots)\n    if not all(c.isupper() or c.isdigit() or c == '.' for c in name):\n        name = ''.join(c if c.isalnum() else ' ' for c in name)\n    return coingecko_normalize(name)\n\n\ndef coingecko_normalize(sym: str) -> str:\n    sym = sym.strip()\n    # do not concatenate numbers => separate them with a dot\n    sym = list(sym)\n    if len(sym) > 4:\n        for i in range(2, len(sym) - 1):\n            if sym[i] == ' ' and sym[i - 1].isdigit() and sym[i + 1].isdigit():\n                sym[i] = '.'\n    sym = ''.join(sym)\n    # concatenate space-separated words => use CamelCase to distinguish the words\n    if ' ' in sym:\n        if sum(c.islower() for c in sym):  # if there is at least one lower case letter\n            sym = ' '.join(word[0].upper() + word[1:] for word in sym.split())  # Just capitalize initial letter of each word\n        else:  # CoinGecko may provide full upper-case as for \"THE STONE COIN\"\n            sym = string.capwords(sym)  # capwords converts \"THE STONE COIN\" to \"The Stone Coin\"\n        sym = sym.replace(' ', '')  # concatenate words\n    return sym\n\n\ndef is_name_short(coin: dict) -> bool:\n    \"\"\"return True if the coin name is enough short compared to the coin symbol.\"\"\"\n    return len(coin['name']) <= max(5, len(coin['symbol']) + 1)\n\n\ndef has_many_caps(name: str) -> bool:\n    \"\"\"return True if the symbol contains enough upper case letters, False if empty.\"\"\"\n    return str and sum(c.islower() for c in name) < (len(name) / 2)\n\n\ndef coingecko_normalize_all(coin: dict):\n    SYMBOL_TO_NORMALIZED = {'miota': 'IOTA'}\n    normalized = SYMBOL_TO_NORMALIZED.get(coin['symbol'])\n    if normalized:\n        coin['ns'] = coin['nn'] = normalized\n        return normalized\n\n    # ns = normalized symbol, nn = normalized name\n    coin['ns'] = coingecko_normalize_symbol(coin['symbol'])\n\n    ID_SUFFIX = '-bitcoin-token'\n    if coin['id'][-len(ID_SUFFIX):] == ID_SUFFIX:\n        coin['nn'] = 'BTC' + coin['ns']\n        return coin['nn']\n\n    name = coin['name']\n\n    prefixes = ('The ', 'the ')\n    for p in prefixes:\n        if name[:len(p)] == p:\n            coin['reduced-name'] = True\n            name = name[len(p):]\n            break\n\n    suffixes = ('coin', 'coins', 'money', 'finance', 'protocol', 'reward', 'rewards', 'token')\n    for s in suffixes:\n        if len(name) > len(s) and name[-len(s):].lower() == s:\n            # but keep suffix when lower-case concatenated\n            if name[-len(s)].islower() and name[-len(s) - 1] != ' ':\n                continue\n            # also keep suffix to avoid confusing nam: \"Bitcoin Token\" -> \"Bitcoin\"\n            if name[:-len(s)].strip().lower() == 'bitcoin':\n                continue\n            coin['reduced-name'] = True\n            name = name[:-len(s)]\n            break\n\n    coin['nn'] = coingecko_normalize_name(name)\n\n    if len(coin['nn']) < len(coin['ns']):\n        if 'reduced-name' in coin:\n            coin['reduced-name'] = False\n            name = coin['name']\n            coin['nn'] = coingecko_normalize_name(name)\n        elif not has_many_caps(name):\n            return coin['ns']\n\n    if not coin['ns']:  # coin['symbol'] may be an emoji that is striped when normalized\n        return coin['nn']\n\n    if coin.get('reduced-name') and coin['ns'].upper() != coin['nn'].upper():\n        return coin['ns']\n\n    i = coin['nn'].find('.')  # if there is a dot in normalized name => prefer the normalized symbol\n    if i >= 0:\n        if i > 1 and coin['nn'][i - 1].isdigit() and coin['nn'][i + 1].isdigit():\n            pass  # except when the dot separates digits\n        else:\n            return coin['ns']\n\n    if is_name_short(coin) and has_many_caps(name):\n        return coin['nn']\n\n    if 1.5 * len(coin['ns']) > len(coin['nn']) and any(c.islower() for c in coin['ns']):\n        return coin['nn']\n\n    return coin['ns']\n\n\ndef coingecko_symbols() -> Dict[str, str]:\n    r = None\n    intermediate = defaultdict(list)\n    try:\n        r = requests.get('https://api.coingecko.com/api/v3/coins/list')\n        all_coins = r.json()\n        # First pass: generate & compare normalized symbol/name, and then select the most pertinent\n        for coin in all_coins:\n            normalized = coingecko_normalize_all(coin)\n            intermediate[normalized].append(coin)\n            # Above line keeps together the coins having the same normalized symbol.\n            # To reduce collision, the coin['name'] is sometimes used in lieu of the coin['symbol'].\n            # The coin['name'] is not capitalized because lower case letters may be meaningful: cETH, yUSD, DATx, zLOT\n    except Exception as why:\n        raise_failure_explanation('COINGECKO', why, {\"\": r})\n\n    final = coingecko_second_pass(intermediate)\n    return coingecko_third_pass(final)\n\n\ndef coingecko_second_pass(intermediate: Dict[str, List[dict]]) -> Dict[str, List[dict]]:\n    # Second pass: fixes most of the symbol collisions\n    final = defaultdict(list)\n    for normalized, coins in intermediate.items():\n        if len(coins) == 1:\n            final[normalized].append(coins[0])\n            continue\n        set_normalized = False\n        for i in range(len(coins)):\n            if normalized == coins[i]['nn']:\n                coin = coins.pop(i)\n                final[normalized].append(coin)\n                set_normalized = True\n                break\n        rest: List[dict] = []\n        for coin in coins:\n            if '%' in coin['name']:\n                if len(coins) == 1:\n                    n = coin['ns']\n                else:\n                    n = coingecko_normalize_name(coin['id'])\n                final[n].append(coin)\n            else:\n                rest.append(coin)\n        if not rest:\n            continue\n        if not set_normalized:\n            rest.sort(key=lambda coin: len(coin['nn']), reverse=True)  # sort by the length of the normalized name\n            coin = rest.pop(0)\n            final[normalized].append(coin)\n        for coin in rest:\n            if coin['nn'] not in intermediate:\n                n = coin['nn']\n            elif coin.get('reduced-name'):\n                n = coingecko_normalize_name(coin['name'])\n            else:\n                n = coingecko_normalize_name(coin['id'])\n            final[n].append(coin)\n    return final\n\n\ndef coingecko_third_pass(final: Dict[str, List[dict]]) -> Dict[str, str]:\n    # Third pass: fixes some remaining collisions and fills the result\n    symbols = {}\n    for normalized, coins in final.items():\n        if len(coins) == 1:\n            symbols[normalized] = coins[0]['id']\n            continue\n        set_normalized = False\n        for i in range(len(coins)):\n            if normalized == coins[i]['nn']:\n                coin = coins.pop(i)\n                symbols[normalized] = coin['id']\n                set_normalized = True\n                break\n        rest: List[dict] = []\n        for coin in coins:\n            if '%' in coin['name']:\n                if len(coins) == 1:\n                    n = coin['ns']\n                else:\n                    n = coingecko_normalize_name(coin['id'])\n                symbols[n] = coin['id']\n            else:\n                rest.append(coin)\n        if not rest:\n            continue\n        if not set_normalized:\n            rest.sort(key=lambda coin: len(coin['nn']), reverse=True)  # sort by the length of the normalized name\n            coin = rest.pop(0)\n            symbols[normalized] = coin['id']\n        for coin in rest:\n            if coin['nn'] not in final:\n                n = coin['nn']\n            elif coin.get('reduced-name'):\n                n = coingecko_normalize_name(coin['name'])\n            else:\n                n = coingecko_normalize_name(coin['id'])\n            symbols[n] = coin['id']\n    return symbols\n\n\ndef whale_alert_coins(key_id: str) -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get(f'https://api.whale-alert.io/v1/status?api_key={key_id}')\n        # Same symbols, but on different blockchains (for instance USDT), are naturally overwritten.\n        return {s.upper(): s for b in r.json()['blockchains'] for s in b['symbols'] if s}\n    except Exception as why:\n        raise_failure_explanation('WHALES_ALERT', why, {\"\": r})\n\n\n_exchange_function_map = {\n    BITFINEX: bitfinex_symbols,\n    BITFLYER: bitflyer_symbols,\n    COINBASE: coinbase_symbols,\n    GEMINI: gemini_symbols,\n    HITBTC: hitbtc_symbols,\n    POLONIEX: poloniex_symbols,\n    PROBIT: probit_symbols,\n    BITSTAMP: bitstamp_symbols,\n    KRAKEN: kraken_symbols,\n    KRAKEN + 'REST': kraken_rest_symbols,\n    BINANCE: binance_symbols,\n    BINANCE_US: binance_us_symbols,\n    BINANCE_FUTURES: binance_futures_symbols,\n    BINANCE_DELIVERY: binance_delivery_symbols,\n    BLOCKCHAIN: blockchain_symbols,\n    EXX: exx_symbols,\n    HUOBI: huobi_symbols,\n    HUOBI_DM: huobi_dm_symbols,\n    HUOBI_SWAP: huobi_swap_symbols,\n    OKCOIN: okcoin_symbols,\n    OKEX: okex_symbols,\n    BYBIT: bybit_symbols,\n    FTX: ftx_symbols,\n    FTX_US: ftx_us_symbols,\n    BITTREX: bittrex_symbols,\n    BITCOINCOM: bitcoincom_symbols,\n    BITMAX: bitmax_symbols,\n    UPBIT: upbit_symbols,\n    GATEIO: gateio_symbols,\n    BITMEX: bitmex_symbols,\n    DERIBIT: deribit_symbols,\n    KRAKEN_FUTURES: kraken_future_symbols,\n    COINGECKO: coingecko_symbols,\n    WHALE_ALERT: whale_alert_coins\n}\n",
        "source_code_len": 30534,
        "target_code": "associated with this software.\n'''\nfrom typing import Dict, Tuple\n\n\nclass _Symbols:\n    def __init__(self):\n        self.data = {}\n\n    def set(self, exchange: str, normalized: dict, exchange_info: dict):\n        self.data[exchange] = {}\n        self.data[exchange]['normalized'] = normalized\n        self.data[exchange]['info'] = exchange_info\n\n    def get(self, exchange: str) -> Tuple[Dict, Dict]:\n        return self.data[exchange]['normalized'], self.data[exchange]['info']\n\n    def populated(self, exchange: str) -> bool:\n        return exchange in self.data\n\n\nSymbols = _Symbols()\n",
        "target_code_len": 588,
        "diff_format": "@@ -5,845 +5,22 @@\n associated with this software.\n+'''\n+from typing import Dict, Tuple\n \n \n-Symbol generation code for exchanges\n-'''\n+class _Symbols:\n+    def __init__(self):\n+        self.data = {}\n \n-import logging\n-import string\n-import time\n-from collections import defaultdict\n-from typing import Dict, List, Optional, Tuple\n+    def set(self, exchange: str, normalized: dict, exchange_info: dict):\n+        self.data[exchange] = {}\n+        self.data[exchange]['normalized'] = normalized\n+        self.data[exchange]['info'] = exchange_info\n \n-import requests\n-from requests import Response\n+    def get(self, exchange: str) -> Tuple[Dict, Dict]:\n+        return self.data[exchange]['normalized'], self.data[exchange]['info']\n \n-from cryptofeed.defines import *\n+    def populated(self, exchange: str) -> bool:\n+        return exchange in self.data\n \n \n-LOG = logging.getLogger('feedhandler')\n-\n-SYMBOL_SEP = '-'\n-\n-_symbols_retrieval_cache: Dict[str, Dict[str, str]] = {}\n-_exchange_info = defaultdict(lambda: defaultdict(dict))\n-\n-\n-_kraken_futures_product_type = {\n-    'FI': 'Inverse Futures',\n-    'FV': 'Vanilla Futures',\n-    'PI': 'Perpetual Inverse Futures',\n-    'PV': 'Perpetual Vanilla Futures',\n-    'IN': 'Real Time Index',\n-    'RR': 'Reference Rate',\n-}\n-\n-\n-def raise_failure_explanation(feed_id: str, exception: BaseException, responses: Dict[str, Optional[Response]]):\n-    LOG.critical('%s: encountered %r while processing response from exchange API', feed_id, exception)\n-    if len(responses) > 1:\n-        LOG.critical('%s: content of one of the %s responses was unexpected', feed_id, len(responses))\n-    for url, r in responses.items():\n-        if url:\n-            LOG.critical('%s: requested URL: %s', feed_id, url)\n-        if r:\n-            LOG.critical('%s: unexpected response: %s', feed_id, r.text)\n-    raise ValueError(f'Cryptofeed stopped because of an unexpected response from {feed_id}') from exception\n-\n-\n-def set_symbol_separator(separator: str):\n-    global SYMBOL_SEP\n-    SYMBOL_SEP = separator\n-\n-\n-def get_symbol_separator() -> str:\n-    global SYMBOL_SEP\n-    return SYMBOL_SEP\n-\n-\n-def gen_symbols(exchange: str, key_id=None) -> Dict[str, str]:\n-    if exchange not in _symbols_retrieval_cache:\n-        LOG.info(\"%s: Getting list of symbols\", exchange)\n-        symbols = _exchange_function_map[exchange](key_id) if key_id else _exchange_function_map[exchange]()\n-        LOG.info(\"%s: %s symbols\", exchange, len(symbols))\n-\n-        # log all retrieved symbols using debug level\n-        for normalized, exch_sym in sorted(symbols.items()):\n-            LOG.debug('%s: id-from-exch -> normalized: %-35s-> %s', exchange, exch_sym, normalized)\n-\n-        _symbols_retrieval_cache[exchange] = symbols\n-    return _symbols_retrieval_cache[exchange]\n-\n-\n-def _binance_symbols(endpoint: str, exchange: str):\n-    r = None\n-    try:\n-        ret = {}\n-        r = requests.get(endpoint)\n-        for symbol in r.json()['symbols']:\n-            if symbol.get('status', 'TRADING') != \"TRADING\":\n-                continue\n-            if symbol.get('contractStatus', 'TRADING') != \"TRADING\":\n-                continue\n-            split = len(symbol['baseAsset'])\n-            normalized = symbol['symbol'][:split] + SYMBOL_SEP + symbol['symbol'][split:]\n-            ret[normalized] = symbol['symbol']\n-            _exchange_info[exchange]['tick_size'][normalized] = symbol['filters'][0]['tickSize']\n-            if \"contractType\" in symbol:\n-                _exchange_info[exchange]['contract_type'][normalized] = symbol['contractType']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation(exchange, why, {endpoint: r})\n-\n-\n-def binance_symbols() -> Dict[str, str]:\n-    return _binance_symbols('https://api.binance.com/api/v3/exchangeInfo', BINANCE)\n-\n-\n-def binance_us_symbols() -> Dict[str, str]:\n-    return _binance_symbols('https://api.binance.us/api/v3/exchangeInfo', BINANCE_US)\n-\n-\n-def binance_futures_symbols() -> Dict[str, str]:\n-    base = _binance_symbols('https://fapi.binance.com/fapi/v1/exchangeInfo', BINANCE_FUTURES)\n-    add = {}\n-    for symbol, orig in base.items():\n-        if \"_\" in orig:\n-            continue\n-        add[f\"{symbol}-PINDEX\"] = f\"p{orig}\"\n-    base.update(add)\n-    return base\n-\n-\n-def binance_delivery_symbols() -> Dict[str, str]:\n-    return _binance_symbols('https://dapi.binance.com/dapi/v1/exchangeInfo', BINANCE_DELIVERY)\n-\n-\n-def bitfinex_symbols() -> Dict[str, str]:\n-    # doc: https://docs.bitfinex.com/docs/ws-general#supported-pairs\n-    r1 = r2 = None\n-    try:\n-        r1 = requests.get('https://api.bitfinex.com/v2/tickers?symbols=ALL')\n-        r2 = requests.get('https://api-pub.bitfinex.com/v2/conf/pub:map:currency:sym')\n-        tickers: List[List[str]] = r1.json()\n-        norm: List[Tuple[str, str]] = r2.json()[0]\n-        norm: Dict[str, str] = dict(norm)\n-        for k, v in dict(norm).items():\n-            if k[-2:] == 'F0' or '-' in v:  # Do not convert BTCF0 -> BTC or PBTCETH -> PBTC-ETH\n-                del norm[k]\n-        norm['BCHN'] = 'BCH'  # Bitfinex uses BCHN, other exchanges use BCH\n-\n-        ret = {}\n-        for symbol in [t[0] for t in tickers]:\n-            if symbol[0] == 'f':\n-                normalized = norm.get(symbol[1:], symbol[1:])\n-            else:\n-                if len(symbol) == 7:\n-                    base, quote = symbol[1:4], symbol[4:]\n-                else:\n-                    base, quote = symbol[1:].split(':')\n-                    assert ':' in symbol\n-                normalized = norm.get(base, base) + SYMBOL_SEP + norm.get(quote, quote)\n-            ret[normalized.upper()] = symbol\n-        return ret\n-    except ValueError as why:\n-        raise_failure_explanation('BITFINEX', why, {\"tickers?symbols=ALL\": r1, \"pub:map:currency:sym\": r2})\n-\n-\n-def bitflyer_symbols() -> Dict[str, str]:\n-    endpoint = r = None\n-    try:\n-        ret = {}\n-        endpoints = ['https://api.bitflyer.com/v1/getmarkets/eu', 'https://api.bitflyer.com/v1/getmarkets/usa', 'https://api.bitflyer.com/v1/getmarkets']\n-        for endpoint in endpoints:\n-            r = requests.get(endpoint)\n-            for entry in r.json():\n-                normalized = entry['product_code'].replace(\"_\", SYMBOL_SEP)\n-                ret[normalized] = entry['product_code']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('BITFLYER', why, {endpoint: r})\n-\n-\n-def bybit_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.bybit.com/v2/public/symbols')\n-        ret = {}\n-        for symbol in r.json()['result']:\n-            quote = symbol['quote_currency']\n-            if not symbol['name'].endswith(quote):\n-                base, contract = symbol['name'].split(quote)\n-                normalized = f\"{base}{SYMBOL_SEP}{quote}-{contract}\"\n-            else:\n-                normalized = f\"{symbol['base_currency']}{SYMBOL_SEP}{quote}\"\n-            ret[normalized] = symbol['name']\n-            _exchange_info[BYBIT]['tick_size'][normalized] = symbol['price_filter']['tick_size']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('BYBIT', why, {\"\": r})\n-\n-\n-def _ftx_helper(endpoint: str, exchange: str):\n-    r = None\n-    try:\n-        r = requests.get(endpoint)\n-        ret = {}\n-        for data in r.json()['result']:\n-            normalized = data['name'].replace(\"/\", SYMBOL_SEP)\n-            symbol = data['name']\n-            ret[normalized] = symbol\n-            _exchange_info[exchange]['tick_size'][normalized] = data['priceIncrement']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation(exchange, why, {endpoint: r})\n-\n-\n-def ftx_symbols() -> Dict[str, str]:\n-    return _ftx_helper('https://ftx.com/api/markets', FTX)\n-\n-\n-def ftx_us_symbols() -> Dict[str, str]:\n-    return _ftx_helper('https://ftx.us/api/markets', FTX_US)\n-\n-\n-def coinbase_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.pro.coinbase.com/products')\n-        ret = {}\n-        for data in r.json():\n-            normalized = data['id'].replace(\"-\", SYMBOL_SEP)\n-            ret[normalized] = data['id']\n-            _exchange_info[COINBASE]['tick_size'][normalized] = data['quote_increment']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('COINBASE', why, {\"\": r})\n-\n-\n-def gemini_symbols(*args) -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.gemini.com/v1/symbols')\n-        ret = {}\n-        for symbol in r.json():\n-            std = f\"{symbol[:-3]}{SYMBOL_SEP}{symbol[-3:]}\"\n-            std = std.upper()\n-            ret[std] = symbol.upper()\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('GEMINI', why, {\"\": r})\n-\n-\n-def hitbtc_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        ret = {}\n-        r = requests.get('https://api.hitbtc.com/api/2/public/symbol')\n-        for symbol in r.json():\n-            split = len(symbol['baseCurrency'])\n-            normalized = symbol['id'][:split] + SYMBOL_SEP + symbol['id'][split:]\n-            ret[normalized] = symbol['id']\n-            _exchange_info[HITBTC]['tick_size'][normalized] = symbol['tickSize']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('HITBTC', why, {\"\": r})\n-\n-\n-def poloniex_id_symbol_mapping():\n-    r = None\n-    try:\n-        r = requests.get('https://poloniex.com/public?command=returnTicker')\n-        symbols = r.json()\n-        ret = {}\n-        for symbol in symbols:\n-            ret[symbols[symbol]['id']] = symbol\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('POLONIEX', why, {\"\": r})\n-\n-\n-def poloniex_symbols() -> Dict[str, str]:\n-    ret = {}\n-    for _, value in poloniex_id_symbol_mapping().items():\n-        std = value.replace(\"STR\", \"XLM\")\n-        quote, base = std.split(\"_\")\n-        ret[quote + SYMBOL_SEP + base] = value\n-    return ret\n-\n-\n-def bitstamp_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://www.bitstamp.net/api/v2/trading-pairs-info/')\n-        ret = {}\n-        for data in r.json():\n-            normalized = data['name'].replace(\"/\", SYMBOL_SEP)\n-            symbol = data['url_symbol']\n-            ret[normalized] = symbol\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('BITSTAMP', why, {\"\": r})\n-\n-\n-def kraken_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.kraken.com/0/public/AssetPairs')\n-        data = r.json()\n-        ret = {}\n-        for symbol in data['result']:\n-            if 'wsname' not in data['result'][symbol] or '.d' in symbol:\n-                # https://blog.kraken.com/post/259/introducing-the-kraken-dark-pool/\n-                # .d is for dark pool symbols\n-                continue\n-\n-            base, quote = data['result'][symbol]['wsname'].split(\"/\")\n-\n-            normalized = f\"{base}{SYMBOL_SEP}{quote}\"\n-            exch = data['result'][symbol]['wsname']\n-            normalized = normalized.replace('XBT', 'BTC')\n-            normalized = normalized.replace('XDG', 'DOG')\n-            ret[normalized] = exch\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('KRAKEN', why, {\"\": r})\n-\n-\n-def kraken_rest_symbols() -> Dict[str, str]:\n-    return {normalized: exchange.replace(\"/\", \"\") for normalized, exchange in kraken_symbols().items()}\n-\n-\n-def exx_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.exx.com/data/v1/tickers')\n-        exchange = [key.upper() for key in r.json().keys()]\n-        symbols = [key.replace(\"_\", SYMBOL_SEP) for key in exchange]\n-        return dict(zip(symbols, exchange))\n-    except Exception as why:\n-        raise_failure_explanation('EXX', why, {\"\": r})\n-\n-\n-def huobi_common_symbols(url: str):\n-    r = None\n-    try:\n-        r = requests.get(url)\n-        ret = {}\n-        for e in r.json()['data']:\n-            if e['state'] == 'offline':\n-                continue\n-            normalized = f\"{e['base-currency'].upper()}{SYMBOL_SEP}{e['quote-currency'].upper()}\"\n-            symbol = f\"{e['base-currency']}{e['quote-currency']}\"\n-            ret[normalized] = symbol\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('HUOBI', why, {url: r})\n-\n-\n-def huobi_symbols() -> Dict[str, str]:\n-    return huobi_common_symbols('https://api.huobi.pro/v1/common/symbols')\n-\n-\n-def huobi_us_symbols() -> Dict[str, str]:\n-    return huobi_common_symbols('https://api.huobi.com/v1/common/symbols')\n-\n-\n-def huobi_dm_symbols() -> Dict[str, str]:\n-    \"\"\"\n-    Mapping is, for instance: {\"BTC_CW\":\"BTC190816\"}\n-    See comments in exchange/huobi_dm.py\n-    \"\"\"\n-    mapping = {\n-        \"this_week\": \"CW\",\n-        \"next_week\": \"NW\",\n-        \"quarter\": \"CQ\",\n-        \"next_quarter\": \"NQ\"\n-    }\n-    r = None\n-    try:\n-        r = requests.get('https://www.hbdm.com/api/v1/contract_contract_info')\n-        symbols = {}\n-        for e in r.json()['data']:\n-            symbols[f\"{e['symbol']}_{mapping[e['contract_type']]}\"] = e['contract_code']\n-            _exchange_info[HUOBI_DM]['tick_size'][e['contract_code']] = e['price_tick']\n-            _exchange_info[HUOBI_DM]['short_code_mappings'][f\"{e['symbol']}_{mapping[e['contract_type']]}\"] = e['contract_code']\n-        return symbols\n-    except Exception as why:\n-        raise_failure_explanation('HUOBI_DM', why, {\"\": r})\n-\n-\n-def huobi_swap_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.hbdm.com/swap-api/v1/swap_contract_info')\n-        symbols = {}\n-        for e in r.json()['data']:\n-            symbols[e['contract_code']] = e['contract_code']\n-            _exchange_info[HUOBI_SWAP]['tick_size'][e['contract_code']] = e['price_tick']\n-        return symbols\n-    except Exception as why:\n-        raise_failure_explanation('HUOBI_SWAP', why, {\"\": r})\n-\n-\n-def okcoin_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://www.okcoin.com/api/spot/v3/instruments')\n-        ret = {}\n-        for e in r.json():\n-            ret[e['instrument_id']] = e['instrument_id']\n-            _exchange_info[OKCOIN]['tick_size'][e['instrument_id']] = e['tick_size']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('OKCOIN', why, {\"\": r})\n-\n-\n-def okex_symbols(*args) -> Dict[str, str]:\n-    urls = ['https://www.okex.com/api/spot/v3/instruments',\n-            'https://www.okex.com/api/swap/v3/instruments',\n-            'https://www.okex.com/api/futures/v3/instruments']\n-    urls = urls + okex_compute_option_urls_from_underlyings()\n-\n-    symbols: Dict[str, str] = {}\n-    for u in urls:\n-        time.sleep(0.2)\n-        symbols.update(okex_symbols_from_one_url(u))\n-\n-    for symbol in symbols:\n-        instrument_type = 'futures'\n-        dash_count = symbol.count(get_symbol_separator())\n-        if dash_count == 1:  # BTC-USDT\n-            instrument_type = 'spot'\n-        if dash_count == 4:  # BTC-USD-201225-35000-P\n-            instrument_type = 'option'\n-        if symbol[-4:] == \"SWAP\":  # BTC-USDT-SWAP\n-            instrument_type = 'swap'\n-\n-        _exchange_info[OKEX]['instrument_type'][symbol] = instrument_type\n-\n-    return symbols\n-\n-\n-def okex_compute_option_urls_from_underlyings() -> List[str]:\n-    url = 'https://www.okex.com/api/option/v3/underlying'\n-    r = None\n-    try:\n-        r = requests.get(url)\n-        return [f'https://www.okex.com/api/option/v3/instruments/{underlying}' for underlying in r.json()]\n-    except Exception as why:\n-        raise_failure_explanation('OKEX', why, {url: r})\n-\n-\n-def okex_symbols_from_one_url(url: str) -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get(url)\n-        ret = {}\n-        for e in r.json():\n-            ret[e['instrument_id']] = e['instrument_id']\n-            _exchange_info[OKEX]['tick_size'][e['instrument_id']] = e['tick_size']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('OKEX', why, {url: r})\n-\n-\n-def bittrex_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.bittrex.com/api/v1.1/public/getmarkets')\n-        r = r.json()['result']\n-        return {f\"{e['MarketCurrency']}{SYMBOL_SEP}{e['BaseCurrency']}\": e['MarketName'] for e in r if e['IsActive']}\n-    except Exception as why:\n-        raise_failure_explanation('BITTREX', why, {\"\": r})\n-\n-\n-def bitcoincom_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.exchange.bitcoin.com/api/2/public/symbol')\n-        return {f\"{data['baseCurrency']}{SYMBOL_SEP}{data['quoteCurrency'].replace('USD', 'USDT')}\": data['id'] for data in r.json()}\n-    except Exception as why:\n-        raise_failure_explanation('BITCOINCOM', why, {\"\": r})\n-\n-\n-def bitmax_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://bitmax.io/api/pro/v1/products')\n-        ret = {}\n-        for entry in r.json()['data']:\n-            # Only \"Normal\" status symbols are tradeable\n-            if entry['status'] == 'Normal':\n-                normalized = f\"{entry['baseAsset']}{SYMBOL_SEP}{entry['quoteAsset']}\"\n-                ret[normalized] = entry['symbol']\n-                _exchange_info[BITMAX]['tick_size'][normalized] = entry['tickSize']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('BITMAX', why, {\"\": r})\n-\n-\n-def upbit_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.upbit.com/v1/market/all')\n-        return {f\"{data['market'].split('-')[1]}{SYMBOL_SEP}{data['market'].split('-')[0]}\": data['market'] for data in r.json()}\n-    except Exception as why:\n-        raise_failure_explanation('UPBIT', why, {\"\": r})\n-\n-\n-def blockchain_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get(\"https://api.blockchain.com/mercury-gateway/v1/instruments\")\n-        return {data[\"symbol\"].replace(\"-\", SYMBOL_SEP): data[\"symbol\"] for data in r.json()}\n-    except Exception as why:\n-        raise_failure_explanation('BLOCKCHAIN', why, {\"\": r})\n-\n-\n-def gateio_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get(\"https://api.gateio.ws/api/v4/spot/currency_pairs\")\n-        return {data[\"id\"].replace(\"_\", SYMBOL_SEP): data['id'] for data in r.json()}\n-    except Exception as why:\n-        raise_failure_explanation('GATEIO', why, {\"\": r})\n-\n-\n-def bitmex_symbols() -> Dict[str, str]:\n-    r = None\n-    ret = {}\n-    try:\n-        r = requests.get(\"https://www.bitmex.com/api/v1/instrument/active\")\n-        for entry in r.json():\n-            components = []\n-            components.append(entry['rootSymbol'])\n-            components.append(entry['quoteCurrency'])\n-\n-            if entry['expiry']:\n-                components.append(entry['symbol'][-3:])\n-\n-            normalized = SYMBOL_SEP.join(components)\n-            normalized = normalized.replace(\"XBT\", \"BTC\")\n-            ret[normalized] = entry['symbol']\n-            _exchange_info[BITMEX]['tick_size'][normalized] = entry['tickSize']\n-\n-            if entry['expiry']:\n-                _exchange_info[BITMEX]['expiry'][normalized] = entry['expiry']\n-\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('BITMEX', why, {\"\": r})\n-\n-\n-def deribit_symbols() -> Dict[str, str]:\n-    url = r = None\n-    ret = {}\n-    try:\n-        # TODO: get currencies from https://www.deribit.com/api/v2/public/get_currencies\n-        currencies = ['BTC', 'ETH']\n-        for c in currencies:\n-            url = f\"https://www.deribit.com/api/v2/public/get_instruments?currency={c}&expired=false\"\n-            r = requests.get(url)\n-            for entry in r.json()['result']:\n-                split = entry['instrument_name'].split(\"-\")\n-                normalized = split[0] + SYMBOL_SEP + entry['quote_currency'] + \"-\" + '-'.join(split[1:])\n-                ret[normalized] = entry['instrument_name']\n-                _exchange_info[DERIBIT]['tick_size'][normalized] = entry['tick_size']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('DERIBIT', why, {url: r})\n-\n-\n-def kraken_future_symbols() -> Dict[str, str]:\n-    r = None\n-    ret = {}\n-    try:\n-        r = requests.get('https://futures.kraken.com/derivatives/api/v3/instruments')\n-        data = r.json()['instruments']\n-        for entry in data:\n-            if not entry['tradeable']:\n-                continue\n-            normalized = entry['symbol'].upper().replace(\"_\", \"-\")\n-            symbol = normalized[3:6] + SYMBOL_SEP + normalized[6:9]\n-            normalized = normalized.replace(normalized[3:9], symbol)\n-            normalized = normalized.replace('XBT', 'BTC')\n-\n-            _exchange_info[KRAKEN_FUTURES]['tick_size'][normalized] = entry['tickSize']\n-            _exchange_info[KRAKEN_FUTURES]['contract_size'][normalized] = entry['contractSize']\n-            _exchange_info[KRAKEN_FUTURES]['underlying'][normalized] = entry['underlying']\n-            _exchange_info[KRAKEN_FUTURES]['product_type'][normalized] = _kraken_futures_product_type[normalized[:2]]\n-            ret[normalized] = entry['symbol']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('KRAKEN_FUTURES', why, {\"\": r})\n-\n-\n-def probit_symbols() -> Dict[str, str]:\n-    # doc: https://docs-en.probit.com/reference-link/market\n-    r = None\n-    try:\n-        r = requests.get('https://api.probit.com/api/exchange/v1/market')\n-        return {entry['id']: entry['id'] for entry in r.json()['data']}\n-    except Exception as why:\n-        raise_failure_explanation('PROBIT', why, {\"\": r})\n-\n-\n-def coingecko_normalize_symbol(symbol: str) -> str:\n-    # keep digits, letters and dots, replace others by space\n-    symbol = ''.join(c if c.isalnum() or c in ('.', '+') else ' ' for c in symbol)\n-    return coingecko_normalize(symbol.upper())\n-\n-\n-def coingecko_normalize_name(name: str) -> str:\n-    # keep digits and letters, replace others by space (except when only composed by upper case letters, digits and dots)\n-    if not all(c.isupper() or c.isdigit() or c == '.' for c in name):\n-        name = ''.join(c if c.isalnum() else ' ' for c in name)\n-    return coingecko_normalize(name)\n-\n-\n-def coingecko_normalize(sym: str) -> str:\n-    sym = sym.strip()\n-    # do not concatenate numbers => separate them with a dot\n-    sym = list(sym)\n-    if len(sym) > 4:\n-        for i in range(2, len(sym) - 1):\n-            if sym[i] == ' ' and sym[i - 1].isdigit() and sym[i + 1].isdigit():\n-                sym[i] = '.'\n-    sym = ''.join(sym)\n-    # concatenate space-separated words => use CamelCase to distinguish the words\n-    if ' ' in sym:\n-        if sum(c.islower() for c in sym):  # if there is at least one lower case letter\n-            sym = ' '.join(word[0].upper() + word[1:] for word in sym.split())  # Just capitalize initial letter of each word\n-        else:  # CoinGecko may provide full upper-case as for \"THE STONE COIN\"\n-            sym = string.capwords(sym)  # capwords converts \"THE STONE COIN\" to \"The Stone Coin\"\n-        sym = sym.replace(' ', '')  # concatenate words\n-    return sym\n-\n-\n-def is_name_short(coin: dict) -> bool:\n-    \"\"\"return True if the coin name is enough short compared to the coin symbol.\"\"\"\n-    return len(coin['name']) <= max(5, len(coin['symbol']) + 1)\n-\n-\n-def has_many_caps(name: str) -> bool:\n-    \"\"\"return True if the symbol contains enough upper case letters, False if empty.\"\"\"\n-    return str and sum(c.islower() for c in name) < (len(name) / 2)\n-\n-\n-def coingecko_normalize_all(coin: dict):\n-    SYMBOL_TO_NORMALIZED = {'miota': 'IOTA'}\n-    normalized = SYMBOL_TO_NORMALIZED.get(coin['symbol'])\n-    if normalized:\n-        coin['ns'] = coin['nn'] = normalized\n-        return normalized\n-\n-    # ns = normalized symbol, nn = normalized name\n-    coin['ns'] = coingecko_normalize_symbol(coin['symbol'])\n-\n-    ID_SUFFIX = '-bitcoin-token'\n-    if coin['id'][-len(ID_SUFFIX):] == ID_SUFFIX:\n-        coin['nn'] = 'BTC' + coin['ns']\n-        return coin['nn']\n-\n-    name = coin['name']\n-\n-    prefixes = ('The ', 'the ')\n-    for p in prefixes:\n-        if name[:len(p)] == p:\n-            coin['reduced-name'] = True\n-            name = name[len(p):]\n-            break\n-\n-    suffixes = ('coin', 'coins', 'money', 'finance', 'protocol', 'reward', 'rewards', 'token')\n-    for s in suffixes:\n-        if len(name) > len(s) and name[-len(s):].lower() == s:\n-            # but keep suffix when lower-case concatenated\n-            if name[-len(s)].islower() and name[-len(s) - 1] != ' ':\n-                continue\n-            # also keep suffix to avoid confusing nam: \"Bitcoin Token\" -> \"Bitcoin\"\n-            if name[:-len(s)].strip().lower() == 'bitcoin':\n-                continue\n-            coin['reduced-name'] = True\n-            name = name[:-len(s)]\n-            break\n-\n-    coin['nn'] = coingecko_normalize_name(name)\n-\n-    if len(coin['nn']) < len(coin['ns']):\n-        if 'reduced-name' in coin:\n-            coin['reduced-name'] = False\n-            name = coin['name']\n-            coin['nn'] = coingecko_normalize_name(name)\n-        elif not has_many_caps(name):\n-            return coin['ns']\n-\n-    if not coin['ns']:  # coin['symbol'] may be an emoji that is striped when normalized\n-        return coin['nn']\n-\n-    if coin.get('reduced-name') and coin['ns'].upper() != coin['nn'].upper():\n-        return coin['ns']\n-\n-    i = coin['nn'].find('.')  # if there is a dot in normalized name => prefer the normalized symbol\n-    if i >= 0:\n-        if i > 1 and coin['nn'][i - 1].isdigit() and coin['nn'][i + 1].isdigit():\n-            pass  # except when the dot separates digits\n-        else:\n-            return coin['ns']\n-\n-    if is_name_short(coin) and has_many_caps(name):\n-        return coin['nn']\n-\n-    if 1.5 * len(coin['ns']) > len(coin['nn']) and any(c.islower() for c in coin['ns']):\n-        return coin['nn']\n-\n-    return coin['ns']\n-\n-\n-def coingecko_symbols() -> Dict[str, str]:\n-    r = None\n-    intermediate = defaultdict(list)\n-    try:\n-        r = requests.get('https://api.coingecko.com/api/v3/coins/list')\n-        all_coins = r.json()\n-        # First pass: generate & compare normalized symbol/name, and then select the most pertinent\n-        for coin in all_coins:\n-            normalized = coingecko_normalize_all(coin)\n-            intermediate[normalized].append(coin)\n-            # Above line keeps together the coins having the same normalized symbol.\n-            # To reduce collision, the coin['name'] is sometimes used in lieu of the coin['symbol'].\n-            # The coin['name'] is not capitalized because lower case letters may be meaningful: cETH, yUSD, DATx, zLOT\n-    except Exception as why:\n-        raise_failure_explanation('COINGECKO', why, {\"\": r})\n-\n-    final = coingecko_second_pass(intermediate)\n-    return coingecko_third_pass(final)\n-\n-\n-def coingecko_second_pass(intermediate: Dict[str, List[dict]]) -> Dict[str, List[dict]]:\n-    # Second pass: fixes most of the symbol collisions\n-    final = defaultdict(list)\n-    for normalized, coins in intermediate.items():\n-        if len(coins) == 1:\n-            final[normalized].append(coins[0])\n-            continue\n-        set_normalized = False\n-        for i in range(len(coins)):\n-            if normalized == coins[i]['nn']:\n-                coin = coins.pop(i)\n-                final[normalized].append(coin)\n-                set_normalized = True\n-                break\n-        rest: List[dict] = []\n-        for coin in coins:\n-            if '%' in coin['name']:\n-                if len(coins) == 1:\n-                    n = coin['ns']\n-                else:\n-                    n = coingecko_normalize_name(coin['id'])\n-                final[n].append(coin)\n-            else:\n-                rest.append(coin)\n-        if not rest:\n-            continue\n-        if not set_normalized:\n-            rest.sort(key=lambda coin: len(coin['nn']), reverse=True)  # sort by the length of the normalized name\n-            coin = rest.pop(0)\n-            final[normalized].append(coin)\n-        for coin in rest:\n-            if coin['nn'] not in intermediate:\n-                n = coin['nn']\n-            elif coin.get('reduced-name'):\n-                n = coingecko_normalize_name(coin['name'])\n-            else:\n-                n = coingecko_normalize_name(coin['id'])\n-            final[n].append(coin)\n-    return final\n-\n-\n-def coingecko_third_pass(final: Dict[str, List[dict]]) -> Dict[str, str]:\n-    # Third pass: fixes some remaining collisions and fills the result\n-    symbols = {}\n-    for normalized, coins in final.items():\n-        if len(coins) == 1:\n-            symbols[normalized] = coins[0]['id']\n-            continue\n-        set_normalized = False\n-        for i in range(len(coins)):\n-            if normalized == coins[i]['nn']:\n-                coin = coins.pop(i)\n-                symbols[normalized] = coin['id']\n-                set_normalized = True\n-                break\n-        rest: List[dict] = []\n-        for coin in coins:\n-            if '%' in coin['name']:\n-                if len(coins) == 1:\n-                    n = coin['ns']\n-                else:\n-                    n = coingecko_normalize_name(coin['id'])\n-                symbols[n] = coin['id']\n-            else:\n-                rest.append(coin)\n-        if not rest:\n-            continue\n-        if not set_normalized:\n-            rest.sort(key=lambda coin: len(coin['nn']), reverse=True)  # sort by the length of the normalized name\n-            coin = rest.pop(0)\n-            symbols[normalized] = coin['id']\n-        for coin in rest:\n-            if coin['nn'] not in final:\n-                n = coin['nn']\n-            elif coin.get('reduced-name'):\n-                n = coingecko_normalize_name(coin['name'])\n-            else:\n-                n = coingecko_normalize_name(coin['id'])\n-            symbols[n] = coin['id']\n-    return symbols\n-\n-\n-def whale_alert_coins(key_id: str) -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get(f'https://api.whale-alert.io/v1/status?api_key={key_id}')\n-        # Same symbols, but on different blockchains (for instance USDT), are naturally overwritten.\n-        return {s.upper(): s for b in r.json()['blockchains'] for s in b['symbols'] if s}\n-    except Exception as why:\n-        raise_failure_explanation('WHALES_ALERT', why, {\"\": r})\n-\n-\n-_exchange_function_map = {\n-    BITFINEX: bitfinex_symbols,\n-    BITFLYER: bitflyer_symbols,\n-    COINBASE: coinbase_symbols,\n-    GEMINI: gemini_symbols,\n-    HITBTC: hitbtc_symbols,\n-    POLONIEX: poloniex_symbols,\n-    PROBIT: probit_symbols,\n-    BITSTAMP: bitstamp_symbols,\n-    KRAKEN: kraken_symbols,\n-    KRAKEN + 'REST': kraken_rest_symbols,\n-    BINANCE: binance_symbols,\n-    BINANCE_US: binance_us_symbols,\n-    BINANCE_FUTURES: binance_futures_symbols,\n-    BINANCE_DELIVERY: binance_delivery_symbols,\n-    BLOCKCHAIN: blockchain_symbols,\n-    EXX: exx_symbols,\n-    HUOBI: huobi_symbols,\n-    HUOBI_DM: huobi_dm_symbols,\n-    HUOBI_SWAP: huobi_swap_symbols,\n-    OKCOIN: okcoin_symbols,\n-    OKEX: okex_symbols,\n-    BYBIT: bybit_symbols,\n-    FTX: ftx_symbols,\n-    FTX_US: ftx_us_symbols,\n-    BITTREX: bittrex_symbols,\n-    BITCOINCOM: bitcoincom_symbols,\n-    BITMAX: bitmax_symbols,\n-    UPBIT: upbit_symbols,\n-    GATEIO: gateio_symbols,\n-    BITMEX: bitmex_symbols,\n-    DERIBIT: deribit_symbols,\n-    KRAKEN_FUTURES: kraken_future_symbols,\n-    COINGECKO: coingecko_symbols,\n-    WHALE_ALERT: whale_alert_coins\n-}\n+Symbols = _Symbols()\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\n\nimport logging\nimport string\nimport time\nfrom collections import defaultdict\nfrom typing import Dict, List, Optional, Tuple\n\nimport requests\nfrom requests import Response\n\nfrom cryptofeed.defines import *\n\n\nLOG = logging.getLogger('feedhandler')\n\nSYMBOL_SEP = '-'\n\n_symbols_retrieval_cache: Dict[str, Dict[str, str]] = {}\n_exchange_info = defaultdict(lambda: defaultdict(dict))\n\n\n_kraken_futures_product_type = {\n    'FI': 'Inverse Futures',\n    'FV': 'Vanilla Futures',\n    'PI': 'Perpetual Inverse Futures',\n    'PV': 'Perpetual Vanilla Futures',\n    'IN': 'Real Time Index',\n    'RR': 'Reference Rate',\n}\n\n\ndef raise_failure_explanation(feed_id: str, exception: BaseException, responses: Dict[str, Optional[Response]]):\n    <IND>LOG.critical('%s: encountered %r while processing response from exchange API', feed_id, exception)\n    if len(responses) > 1:\n        <IND>LOG.critical('%s: content of one of the %s responses was unexpected', feed_id, len(responses))\n    <DED>for url, r in responses.items():\n        <IND>if url:\n            <IND>LOG.critical('%s: requested URL: %s', feed_id, url)\n        <DED>if r:\n            <IND>LOG.critical('%s: unexpected response: %s', feed_id, r.text)\n    <DED><DED>raise ValueError(f'Cryptofeed stopped because of an unexpected response from {feed_id}') from exception\n\n\n<DED>def set_symbol_separator(separator: str):\n    <IND>global SYMBOL_SEP\n    SYMBOL_SEP = separator\n\n\n<DED>def get_symbol_separator() -> str:\n    <IND>global SYMBOL_SEP\n    return SYMBOL_SEP\n\n\n<DED>def gen_symbols(exchange: str, key_id=None) -> Dict[str, str]:\n    <IND>if exchange not in _symbols_retrieval_cache:\n        <IND>LOG.info(\"%s: Getting list of symbols\", exchange)\n        symbols = _exchange_function_map[exchange](key_id) if key_id else _exchange_function_map[exchange]()\n        LOG.info(\"%s: %s symbols\", exchange, len(symbols))\n\n        # log all retrieved symbols using debug level\n        for normalized, exch_sym in sorted(symbols.items()):\n            <IND>LOG.debug('%s: id-from-exch -> normalized: %-35s-> %s', exchange, exch_sym, normalized)\n\n        <DED>_symbols_retrieval_cache[exchange] = symbols\n    <DED>return _symbols_retrieval_cache[exchange]\n\n\n<DED>def _binance_symbols(endpoint: str, exchange: str):\n    <IND>r = None\n    try:\n        <IND>ret = {}\n        r = requests.get(endpoint)\n        for symbol in r.json()['symbols']:\n            <IND>if symbol.get('status', 'TRADING') != \"TRADING\":\n                <IND>continue\n            <DED>if symbol.get('contractStatus', 'TRADING') != \"TRADING\":\n                <IND>continue\n            <DED>split = len(symbol['baseAsset'])\n            normalized = symbol['symbol'][:split] + SYMBOL_SEP + symbol['symbol'][split:]\n            ret[normalized] = symbol['symbol']\n            _exchange_info[exchange]['tick_size'][normalized] = symbol['filters'][0]['tickSize']\n            if \"contractType\" in symbol:\n                <IND>_exchange_info[exchange]['contract_type'][normalized] = symbol['contractType']\n        <DED><DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation(exchange, why, {endpoint: r})\n\n\n<DED><DED>def binance_symbols() -> Dict[str, str]:\n    <IND>return _binance_symbols('https://api.binance.com/api/v3/exchangeInfo', BINANCE)\n\n\n<DED>def binance_us_symbols() -> Dict[str, str]:\n    <IND>return _binance_symbols('https://api.binance.us/api/v3/exchangeInfo', BINANCE_US)\n\n\n<DED>def binance_futures_symbols() -> Dict[str, str]:\n    <IND>base = _binance_symbols('https://fapi.binance.com/fapi/v1/exchangeInfo', BINANCE_FUTURES)\n    add = {}\n    for symbol, orig in base.items():\n        <IND>if \"_\" in orig:\n            <IND>continue\n        <DED>add[f\"{symbol}-PINDEX\"] = f\"p{orig}\"\n    <DED>base.update(add)\n    return base\n\n\n<DED>def binance_delivery_symbols() -> Dict[str, str]:\n    <IND>return _binance_symbols('https://dapi.binance.com/dapi/v1/exchangeInfo', BINANCE_DELIVERY)\n\n\n<DED>def bitfinex_symbols() -> Dict[str, str]:\n    # doc: https://docs.bitfinex.com/docs/ws-general#supported-pairs\n    <IND>r1 = r2 = None\n    try:\n        <IND>r1 = requests.get('https://api.bitfinex.com/v2/tickers?symbols=ALL')\n        r2 = requests.get('https://api-pub.bitfinex.com/v2/conf/pub:map:currency:sym')\n        tickers: List[List[str]] = r1.json()\n        norm: List[Tuple[str, str]] = r2.json()[0]\n        norm: Dict[str, str] = dict(norm)\n        for k, v in dict(norm).items():\n            <IND>if k[-2:] == 'F0' or '-' in v:  # Do not convert BTCF0 -> BTC or PBTCETH -> PBTC-ETH\n                <IND>del norm[k]\n        <DED><DED>norm['BCHN'] = 'BCH'  # Bitfinex uses BCHN, other exchanges use BCH\n\n        ret = {}\n        for symbol in [t[0] for t in tickers]:\n            <IND>if symbol[0] == 'f':\n                <IND>normalized = norm.get(symbol[1:], symbol[1:])\n            <DED>else:\n                <IND>if len(symbol) == 7:\n                    <IND>base, quote = symbol[1:4], symbol[4:]\n                <DED>else:\n                    <IND>base, quote = symbol[1:].split(':')\n                    assert ':' in symbol\n                <DED>normalized = norm.get(base, base) + SYMBOL_SEP + norm.get(quote, quote)\n            <DED>ret[normalized.upper()] = symbol\n        <DED>return ret\n    <DED>except ValueError as why:\n        <IND>raise_failure_explanation('BITFINEX', why, {\"tickers?symbols=ALL\": r1, \"pub:map:currency:sym\": r2})\n\n\n<DED><DED>def bitflyer_symbols() -> Dict[str, str]:\n    <IND>endpoint = r = None\n    try:\n        <IND>ret = {}\n        endpoints = ['https://api.bitflyer.com/v1/getmarkets/eu', 'https://api.bitflyer.com/v1/getmarkets/usa', 'https://api.bitflyer.com/v1/getmarkets']\n        for endpoint in endpoints:\n            <IND>r = requests.get(endpoint)\n            for entry in r.json():\n                <IND>normalized = entry['product_code'].replace(\"_\", SYMBOL_SEP)\n                ret[normalized] = entry['product_code']\n        <DED><DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BITFLYER', why, {endpoint: r})\n\n\n<DED><DED>def bybit_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.bybit.com/v2/public/symbols')\n        ret = {}\n        for symbol in r.json()['result']:\n            <IND>quote = symbol['quote_currency']\n            if not symbol['name'].endswith(quote):\n                <IND>base, contract = symbol['name'].split(quote)\n                normalized = f\"{base}{SYMBOL_SEP}{quote}-{contract}\"\n            <DED>else:\n                <IND>normalized = f\"{symbol['base_currency']}{SYMBOL_SEP}{quote}\"\n            <DED>ret[normalized] = symbol['name']\n            _exchange_info[BYBIT]['tick_size'][normalized] = symbol['price_filter']['tick_size']\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BYBIT', why, {\"\": r})\n\n\n<DED><DED>def _ftx_helper(endpoint: str, exchange: str):\n    <IND>r = None\n    try:\n        <IND>r = requests.get(endpoint)\n        ret = {}\n        for data in r.json()['result']:\n            <IND>normalized = data['name'].replace(\"/\", SYMBOL_SEP)\n            symbol = data['name']\n            ret[normalized] = symbol\n            _exchange_info[exchange]['tick_size'][normalized] = data['priceIncrement']\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation(exchange, why, {endpoint: r})\n\n\n<DED><DED>def ftx_symbols() -> Dict[str, str]:\n    <IND>return _ftx_helper('https://ftx.com/api/markets', FTX)\n\n\n<DED>def ftx_us_symbols() -> Dict[str, str]:\n    <IND>return _ftx_helper('https://ftx.us/api/markets', FTX_US)\n\n\n<DED>def coinbase_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.pro.coinbase.com/products')\n        ret = {}\n        for data in r.json():\n            <IND>normalized = data['id'].replace(\"-\", SYMBOL_SEP)\n            ret[normalized] = data['id']\n            _exchange_info[COINBASE]['tick_size'][normalized] = data['quote_increment']\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('COINBASE', why, {\"\": r})\n\n\n<DED><DED>def gemini_symbols(*args) -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.gemini.com/v1/symbols')\n        ret = {}\n        for symbol in r.json():\n            <IND>std = f\"{symbol[:-3]}{SYMBOL_SEP}{symbol[-3:]}\"\n            std = std.upper()\n            ret[std] = symbol.upper()\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('GEMINI', why, {\"\": r})\n\n\n<DED><DED>def hitbtc_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>ret = {}\n        r = requests.get('https://api.hitbtc.com/api/2/public/symbol')\n        for symbol in r.json():\n            <IND>split = len(symbol['baseCurrency'])\n            normalized = symbol['id'][:split] + SYMBOL_SEP + symbol['id'][split:]\n            ret[normalized] = symbol['id']\n            _exchange_info[HITBTC]['tick_size'][normalized] = symbol['tickSize']\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('HITBTC', why, {\"\": r})\n\n\n<DED><DED>def poloniex_id_symbol_mapping():\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://poloniex.com/public?command=returnTicker')\n        symbols = r.json()\n        ret = {}\n        for symbol in symbols:\n            <IND>ret[symbols[symbol]['id']] = symbol\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('POLONIEX', why, {\"\": r})\n\n\n<DED><DED>def poloniex_symbols() -> Dict[str, str]:\n    <IND>ret = {}\n    for _, value in poloniex_id_symbol_mapping().items():\n        <IND>std = value.replace(\"STR\", \"XLM\")\n        quote, base = std.split(\"_\")\n        ret[quote + SYMBOL_SEP + base] = value\n    <DED>return ret\n\n\n<DED>def bitstamp_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://www.bitstamp.net/api/v2/trading-pairs-info/')\n        ret = {}\n        for data in r.json():\n            <IND>normalized = data['name'].replace(\"/\", SYMBOL_SEP)\n            symbol = data['url_symbol']\n            ret[normalized] = symbol\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BITSTAMP', why, {\"\": r})\n\n\n<DED><DED>def kraken_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.kraken.com/0/public/AssetPairs')\n        data = r.json()\n        ret = {}\n        for symbol in data['result']:\n            <IND>if 'wsname' not in data['result'][symbol] or '.d' in symbol:\n                # https://blog.kraken.com/post/259/introducing-the-kraken-dark-pool/\n                # .d is for dark pool symbols\n                <IND>continue\n\n            <DED>base, quote = data['result'][symbol]['wsname'].split(\"/\")\n\n            normalized = f\"{base}{SYMBOL_SEP}{quote}\"\n            exch = data['result'][symbol]['wsname']\n            normalized = normalized.replace('XBT', 'BTC')\n            normalized = normalized.replace('XDG', 'DOG')\n            ret[normalized] = exch\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('KRAKEN', why, {\"\": r})\n\n\n<DED><DED>def kraken_rest_symbols() -> Dict[str, str]:\n    <IND>return {normalized: exchange.replace(\"/\", \"\") for normalized, exchange in kraken_symbols().items()}\n\n\n<DED>def exx_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.exx.com/data/v1/tickers')\n        exchange = [key.upper() for key in r.json().keys()]\n        symbols = [key.replace(\"_\", SYMBOL_SEP) for key in exchange]\n        return dict(zip(symbols, exchange))\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('EXX', why, {\"\": r})\n\n\n<DED><DED>def huobi_common_symbols(url: str):\n    <IND>r = None\n    try:\n        <IND>r = requests.get(url)\n        ret = {}\n        for e in r.json()['data']:\n            <IND>if e['state'] == 'offline':\n                <IND>continue\n            <DED>normalized = f\"{e['base-currency'].upper()}{SYMBOL_SEP}{e['quote-currency'].upper()}\"\n            symbol = f\"{e['base-currency']}{e['quote-currency']}\"\n            ret[normalized] = symbol\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('HUOBI', why, {url: r})\n\n\n<DED><DED>def huobi_symbols() -> Dict[str, str]:\n    <IND>return huobi_common_symbols('https://api.huobi.pro/v1/common/symbols')\n\n\n<DED>def huobi_us_symbols() -> Dict[str, str]:\n    <IND>return huobi_common_symbols('https://api.huobi.com/v1/common/symbols')\n\n\n<DED>def huobi_dm_symbols() -> Dict[str, str]:\n    <IND>\"\"\"\n    Mapping is, for instance: {\"BTC_CW\":\"BTC190816\"}\n    See comments in exchange/huobi_dm.py\n    \"\"\"\n    mapping = {\n        \"this_week\": \"CW\",\n        \"next_week\": \"NW\",\n        \"quarter\": \"CQ\",\n        \"next_quarter\": \"NQ\"\n    }\n    r = None\n    try:\n        <IND>r = requests.get('https://www.hbdm.com/api/v1/contract_contract_info')\n        symbols = {}\n        for e in r.json()['data']:\n            <IND>symbols[f\"{e['symbol']}_{mapping[e['contract_type']]}\"] = e['contract_code']\n            _exchange_info[HUOBI_DM]['tick_size'][e['contract_code']] = e['price_tick']\n            _exchange_info[HUOBI_DM]['short_code_mappings'][f\"{e['symbol']}_{mapping[e['contract_type']]}\"] = e['contract_code']\n        <DED>return symbols\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('HUOBI_DM', why, {\"\": r})\n\n\n<DED><DED>def huobi_swap_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.hbdm.com/swap-api/v1/swap_contract_info')\n        symbols = {}\n        for e in r.json()['data']:\n            <IND>symbols[e['contract_code']] = e['contract_code']\n            _exchange_info[HUOBI_SWAP]['tick_size'][e['contract_code']] = e['price_tick']\n        <DED>return symbols\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('HUOBI_SWAP', why, {\"\": r})\n\n\n<DED><DED>def okcoin_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://www.okcoin.com/api/spot/v3/instruments')\n        ret = {}\n        for e in r.json():\n            <IND>ret[e['instrument_id']] = e['instrument_id']\n            _exchange_info[OKCOIN]['tick_size'][e['instrument_id']] = e['tick_size']\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('OKCOIN', why, {\"\": r})\n\n\n<DED><DED>def okex_symbols(*args) -> Dict[str, str]:\n    <IND>urls = ['https://www.okex.com/api/spot/v3/instruments',\n            'https://www.okex.com/api/swap/v3/instruments',\n            'https://www.okex.com/api/futures/v3/instruments']\n    urls = urls + okex_compute_option_urls_from_underlyings()\n\n    symbols: Dict[str, str] = {}\n    for u in urls:\n        <IND>time.sleep(0.2)\n        symbols.update(okex_symbols_from_one_url(u))\n\n    <DED>for symbol in symbols:\n        <IND>instrument_type = 'futures'\n        dash_count = symbol.count(get_symbol_separator())\n        if dash_count == 1:  # BTC-USDT\n            <IND>instrument_type = 'spot'\n        <DED>if dash_count == 4:  # BTC-USD-201225-35000-P\n            <IND>instrument_type = 'option'\n        <DED>if symbol[-4:] == \"SWAP\":  # BTC-USDT-SWAP\n            <IND>instrument_type = 'swap'\n\n        <DED>_exchange_info[OKEX]['instrument_type'][symbol] = instrument_type\n\n    <DED>return symbols\n\n\n<DED>def okex_compute_option_urls_from_underlyings() -> List[str]:\n    <IND>url = 'https://www.okex.com/api/option/v3/underlying'\n    r = None\n    try:\n        <IND>r = requests.get(url)\n        return [f'https://www.okex.com/api/option/v3/instruments/{underlying}' for underlying in r.json()]\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('OKEX', why, {url: r})\n\n\n<DED><DED>def okex_symbols_from_one_url(url: str) -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get(url)\n        ret = {}\n        for e in r.json():\n            <IND>ret[e['instrument_id']] = e['instrument_id']\n            _exchange_info[OKEX]['tick_size'][e['instrument_id']] = e['tick_size']\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('OKEX', why, {url: r})\n\n\n<DED><DED>def bittrex_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.bittrex.com/api/v1.1/public/getmarkets')\n        r = r.json()['result']\n        return {f\"{e['MarketCurrency']}{SYMBOL_SEP}{e['BaseCurrency']}\": e['MarketName'] for e in r if e['IsActive']}\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BITTREX', why, {\"\": r})\n\n\n<DED><DED>def bitcoincom_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.exchange.bitcoin.com/api/2/public/symbol')\n        return {f\"{data['baseCurrency']}{SYMBOL_SEP}{data['quoteCurrency'].replace('USD', 'USDT')}\": data['id'] for data in r.json()}\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BITCOINCOM', why, {\"\": r})\n\n\n<DED><DED>def bitmax_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://bitmax.io/api/pro/v1/products')\n        ret = {}\n        for entry in r.json()['data']:\n            # Only \"Normal\" status symbols are tradeable\n            <IND>if entry['status'] == 'Normal':\n                <IND>normalized = f\"{entry['baseAsset']}{SYMBOL_SEP}{entry['quoteAsset']}\"\n                ret[normalized] = entry['symbol']\n                _exchange_info[BITMAX]['tick_size'][normalized] = entry['tickSize']\n        <DED><DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BITMAX', why, {\"\": r})\n\n\n<DED><DED>def upbit_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.upbit.com/v1/market/all')\n        return {f\"{data['market'].split('-')[1]}{SYMBOL_SEP}{data['market'].split('-')[0]}\": data['market'] for data in r.json()}\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('UPBIT', why, {\"\": r})\n\n\n<DED><DED>def blockchain_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get(\"https://api.blockchain.com/mercury-gateway/v1/instruments\")\n        return {data[\"symbol\"].replace(\"-\", SYMBOL_SEP): data[\"symbol\"] for data in r.json()}\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BLOCKCHAIN', why, {\"\": r})\n\n\n<DED><DED>def gateio_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get(\"https://api.gateio.ws/api/v4/spot/currency_pairs\")\n        return {data[\"id\"].replace(\"_\", SYMBOL_SEP): data['id'] for data in r.json()}\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('GATEIO', why, {\"\": r})\n\n\n<DED><DED>def bitmex_symbols() -> Dict[str, str]:\n    <IND>r = None\n    ret = {}\n    try:\n        <IND>r = requests.get(\"https://www.bitmex.com/api/v1/instrument/active\")\n        for entry in r.json():\n            <IND>components = []\n            components.append(entry['rootSymbol'])\n            components.append(entry['quoteCurrency'])\n\n            if entry['expiry']:\n                <IND>components.append(entry['symbol'][-3:])\n\n            <DED>normalized = SYMBOL_SEP.join(components)\n            normalized = normalized.replace(\"XBT\", \"BTC\")\n            ret[normalized] = entry['symbol']\n            _exchange_info[BITMEX]['tick_size'][normalized] = entry['tickSize']\n\n            if entry['expiry']:\n                <IND>_exchange_info[BITMEX]['expiry'][normalized] = entry['expiry']\n\n        <DED><DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BITMEX', why, {\"\": r})\n\n\n<DED><DED>def deribit_symbols() -> Dict[str, str]:\n    <IND>url = r = None\n    ret = {}\n    try:\n        # TODO: get currencies from https://www.deribit.com/api/v2/public/get_currencies\n        <IND>currencies = ['BTC', 'ETH']\n        for c in currencies:\n            <IND>url = f\"https://www.deribit.com/api/v2/public/get_instruments?currency={c}&expired=false\"\n            r = requests.get(url)\n            for entry in r.json()['result']:\n                <IND>split = entry['instrument_name'].split(\"-\")\n                normalized = split[0] + SYMBOL_SEP + entry['quote_currency'] + \"-\" + '-'.join(split[1:])\n                ret[normalized] = entry['instrument_name']\n                _exchange_info[DERIBIT]['tick_size'][normalized] = entry['tick_size']\n        <DED><DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('DERIBIT', why, {url: r})\n\n\n<DED><DED>def kraken_future_symbols() -> Dict[str, str]:\n    <IND>r = None\n    ret = {}\n    try:\n        <IND>r = requests.get('https://futures.kraken.com/derivatives/api/v3/instruments')\n        data = r.json()['instruments']\n        for entry in data:\n            <IND>if not entry['tradeable']:\n                <IND>continue\n            <DED>normalized = entry['symbol'].upper().replace(\"_\", \"-\")\n            symbol = normalized[3:6] + SYMBOL_SEP + normalized[6:9]\n            normalized = normalized.replace(normalized[3:9], symbol)\n            normalized = normalized.replace('XBT', 'BTC')\n\n            _exchange_info[KRAKEN_FUTURES]['tick_size'][normalized] = entry['tickSize']\n            _exchange_info[KRAKEN_FUTURES]['contract_size'][normalized] = entry['contractSize']\n            _exchange_info[KRAKEN_FUTURES]['underlying'][normalized] = entry['underlying']\n            _exchange_info[KRAKEN_FUTURES]['product_type'][normalized] = _kraken_futures_product_type[normalized[:2]]\n            ret[normalized] = entry['symbol']\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('KRAKEN_FUTURES', why, {\"\": r})\n\n\n<DED><DED>def probit_symbols() -> Dict[str, str]:\n    # doc: https://docs-en.probit.com/reference-link/market\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.probit.com/api/exchange/v1/market')\n        return {entry['id']: entry['id'] for entry in r.json()['data']}\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('PROBIT', why, {\"\": r})\n\n\n<DED><DED>def coingecko_normalize_symbol(symbol: str) -> str:\n    # keep digits, letters and dots, replace others by space\n    <IND>symbol = ''.join(c if c.isalnum() or c in ('.', '+') else ' ' for c in symbol)\n    return coingecko_normalize(symbol.upper())\n\n\n<DED>def coingecko_normalize_name(name: str) -> str:\n    # keep digits and letters, replace others by space (except when only composed by upper case letters, digits and dots)\n    <IND>if not all(c.isupper() or c.isdigit() or c == '.' for c in name):\n        <IND>name = ''.join(c if c.isalnum() else ' ' for c in name)\n    <DED>return coingecko_normalize(name)\n\n\n<DED>def coingecko_normalize(sym: str) -> str:\n    <IND>sym = sym.strip()\n    # do not concatenate numbers => separate them with a dot\n    sym = list(sym)\n    if len(sym) > 4:\n        <IND>for i in range(2, len(sym) - 1):\n            <IND>if sym[i] == ' ' and sym[i - 1].isdigit() and sym[i + 1].isdigit():\n                <IND>sym[i] = '.'\n    <DED><DED><DED>sym = ''.join(sym)\n    # concatenate space-separated words => use CamelCase to distinguish the words\n    if ' ' in sym:\n        <IND>if sum(c.islower() for c in sym):  # if there is at least one lower case letter\n            <IND>sym = ' '.join(word[0].upper() + word[1:] for word in sym.split())  # Just capitalize initial letter of each word\n        <DED>else:  # CoinGecko may provide full upper-case as for \"THE STONE COIN\"\n            <IND>sym = string.capwords(sym)  # capwords converts \"THE STONE COIN\" to \"The Stone Coin\"\n        <DED>sym = sym.replace(' ', '')  # concatenate words\n    <DED>return sym\n\n\n<DED>def is_name_short(coin: dict) -> bool:\n    <IND>\"\"\"return True if the coin name is enough short compared to the coin symbol.\"\"\"\n    return len(coin['name']) <= max(5, len(coin['symbol']) + 1)\n\n\n<DED>def has_many_caps(name: str) -> bool:\n    <IND>\"\"\"return True if the symbol contains enough upper case letters, False if empty.\"\"\"\n    return str and sum(c.islower() for c in name) < (len(name) / 2)\n\n\n<DED>def coingecko_normalize_all(coin: dict):\n    <IND>SYMBOL_TO_NORMALIZED = {'miota': 'IOTA'}\n    normalized = SYMBOL_TO_NORMALIZED.get(coin['symbol'])\n    if normalized:\n        <IND>coin['ns'] = coin['nn'] = normalized\n        return normalized\n\n    # ns = normalized symbol, nn = normalized name\n    <DED>coin['ns'] = coingecko_normalize_symbol(coin['symbol'])\n\n    ID_SUFFIX = '-bitcoin-token'\n    if coin['id'][-len(ID_SUFFIX):] == ID_SUFFIX:\n        <IND>coin['nn'] = 'BTC' + coin['ns']\n        return coin['nn']\n\n    <DED>name = coin['name']\n\n    prefixes = ('The ', 'the ')\n    for p in prefixes:\n        <IND>if name[:len(p)] == p:\n            <IND>coin['reduced-name'] = True\n            name = name[len(p):]\n            break\n\n    <DED><DED>suffixes = ('coin', 'coins', 'money', 'finance', 'protocol', 'reward', 'rewards', 'token')\n    for s in suffixes:\n        <IND>if len(name) > len(s) and name[-len(s):].lower() == s:\n            # but keep suffix when lower-case concatenated\n            <IND>if name[-len(s)].islower() and name[-len(s) - 1] != ' ':\n                <IND>continue\n            # also keep suffix to avoid confusing nam: \"Bitcoin Token\" -> \"Bitcoin\"\n            <DED>if name[:-len(s)].strip().lower() == 'bitcoin':\n                <IND>continue\n            <DED>coin['reduced-name'] = True\n            name = name[:-len(s)]\n            break\n\n    <DED><DED>coin['nn'] = coingecko_normalize_name(name)\n\n    if len(coin['nn']) < len(coin['ns']):\n        <IND>if 'reduced-name' in coin:\n            <IND>coin['reduced-name'] = False\n            name = coin['name']\n            coin['nn'] = coingecko_normalize_name(name)\n        <DED>elif not has_many_caps(name):\n            <IND>return coin['ns']\n\n    <DED><DED>if not coin['ns']:  # coin['symbol'] may be an emoji that is striped when normalized\n        <IND>return coin['nn']\n\n    <DED>if coin.get('reduced-name') and coin['ns'].upper() != coin['nn'].upper():\n        <IND>return coin['ns']\n\n    <DED>i = coin['nn'].find('.')  # if there is a dot in normalized name => prefer the normalized symbol\n    if i >= 0:\n        <IND>if i > 1 and coin['nn'][i - 1].isdigit() and coin['nn'][i + 1].isdigit():\n            <IND>pass  # except when the dot separates digits\n        <DED>else:\n            <IND>return coin['ns']\n\n    <DED><DED>if is_name_short(coin) and has_many_caps(name):\n        <IND>return coin['nn']\n\n    <DED>if 1.5 * len(coin['ns']) > len(coin['nn']) and any(c.islower() for c in coin['ns']):\n        <IND>return coin['nn']\n\n    <DED>return coin['ns']\n\n\n<DED>def coingecko_symbols() -> Dict[str, str]:\n    <IND>r = None\n    intermediate = defaultdict(list)\n    try:\n        <IND>r = requests.get('https://api.coingecko.com/api/v3/coins/list')\n        all_coins = r.json()\n        # First pass: generate & compare normalized symbol/name, and then select the most pertinent\n        for coin in all_coins:\n            <IND>normalized = coingecko_normalize_all(coin)\n            intermediate[normalized].append(coin)\n            # Above line keeps together the coins having the same normalized symbol.\n            # To reduce collision, the coin['name'] is sometimes used in lieu of the coin['symbol'].\n            # The coin['name'] is not capitalized because lower case letters may be meaningful: cETH, yUSD, DATx, zLOT\n    <DED><DED>except Exception as why:\n        <IND>raise_failure_explanation('COINGECKO', why, {\"\": r})\n\n    <DED>final = coingecko_second_pass(intermediate)\n    return coingecko_third_pass(final)\n\n\n<DED>def coingecko_second_pass(intermediate: Dict[str, List[dict]]) -> Dict[str, List[dict]]:\n    # Second pass: fixes most of the symbol collisions\n    <IND>final = defaultdict(list)\n    for normalized, coins in intermediate.items():\n        <IND>if len(coins) == 1:\n            <IND>final[normalized].append(coins[0])\n            continue\n        <DED>set_normalized = False\n        for i in range(len(coins)):\n            <IND>if normalized == coins[i]['nn']:\n                <IND>coin = coins.pop(i)\n                final[normalized].append(coin)\n                set_normalized = True\n                break\n        <DED><DED>rest: List[dict] = []\n        for coin in coins:\n            <IND>if '%' in coin['name']:\n                <IND>if len(coins) == 1:\n                    <IND>n = coin['ns']\n                <DED>else:\n                    <IND>n = coingecko_normalize_name(coin['id'])\n                <DED>final[n].append(coin)\n            <DED>else:\n                <IND>rest.append(coin)\n        <DED><DED>if not rest:\n            <IND>continue\n        <DED>if not set_normalized:\n            <IND>rest.sort(key=lambda coin: len(coin['nn']), reverse=True)  # sort by the length of the normalized name\n            coin = rest.pop(0)\n            final[normalized].append(coin)\n        <DED>for coin in rest:\n            <IND>if coin['nn'] not in intermediate:\n                <IND>n = coin['nn']\n            <DED>elif coin.get('reduced-name'):\n                <IND>n = coingecko_normalize_name(coin['name'])\n            <DED>else:\n                <IND>n = coingecko_normalize_name(coin['id'])\n            <DED>final[n].append(coin)\n    <DED><DED>return final\n\n\n<DED>def coingecko_third_pass(final: Dict[str, List[dict]]) -> Dict[str, str]:\n    # Third pass: fixes some remaining collisions and fills the result\n    <IND>symbols = {}\n    for normalized, coins in final.items():\n        <IND>if len(coins) == 1:\n            <IND>symbols[normalized] = coins[0]['id']\n            continue\n        <DED>set_normalized = False\n        for i in range(len(coins)):\n            <IND>if normalized == coins[i]['nn']:\n                <IND>coin = coins.pop(i)\n                symbols[normalized] = coin['id']\n                set_normalized = True\n                break\n        <DED><DED>rest: List[dict] = []\n        for coin in coins:\n            <IND>if '%' in coin['name']:\n                <IND>if len(coins) == 1:\n                    <IND>n = coin['ns']\n                <DED>else:\n                    <IND>n = coingecko_normalize_name(coin['id'])\n                <DED>symbols[n] = coin['id']\n            <DED>else:\n                <IND>rest.append(coin)\n        <DED><DED>if not rest:\n            <IND>continue\n        <DED>if not set_normalized:\n            <IND>rest.sort(key=lambda coin: len(coin['nn']), reverse=True)  # sort by the length of the normalized name\n            coin = rest.pop(0)\n            symbols[normalized] = coin['id']\n        <DED>for coin in rest:\n            <IND>if coin['nn'] not in final:\n                <IND>n = coin['nn']\n            <DED>elif coin.get('reduced-name'):\n                <IND>n = coingecko_normalize_name(coin['name'])\n            <DED>else:\n                <IND>n = coingecko_normalize_name(coin['id'])\n            <DED>symbols[n] = coin['id']\n    <DED><DED>return symbols\n\n\n<DED>def whale_alert_coins(key_id: str) -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get(f'https://api.whale-alert.io/v1/status?api_key={key_id}')\n        # Same symbols, but on different blockchains (for instance USDT), are naturally overwritten.\n        return {s.upper(): s for b in r.json()['blockchains'] for s in b['symbols'] if s}\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('WHALES_ALERT', why, {\"\": r})\n\n\n<DED><DED>_exchange_function_map = {\n    BITFINEX: bitfinex_symbols,\n    BITFLYER: bitflyer_symbols,\n    COINBASE: coinbase_symbols,\n    GEMINI: gemini_symbols,\n    HITBTC: hitbtc_symbols,\n    POLONIEX: poloniex_symbols,\n    PROBIT: probit_symbols,\n    BITSTAMP: bitstamp_symbols,\n    KRAKEN: kraken_symbols,\n    KRAKEN + 'REST': kraken_rest_symbols,\n    BINANCE: binance_symbols,\n    BINANCE_US: binance_us_symbols,\n    BINANCE_FUTURES: binance_futures_symbols,\n    BINANCE_DELIVERY: binance_delivery_symbols,\n    BLOCKCHAIN: blockchain_symbols,\n    EXX: exx_symbols,\n    HUOBI: huobi_symbols,\n    HUOBI_DM: huobi_dm_symbols,\n    HUOBI_SWAP: huobi_swap_symbols,\n    OKCOIN: okcoin_symbols,\n    OKEX: okex_symbols,\n    BYBIT: bybit_symbols,\n    FTX: ftx_symbols,\n    FTX_US: ftx_us_symbols,\n    BITTREX: bittrex_symbols,\n    BITCOINCOM: bitcoincom_symbols,\n    BITMAX: bitmax_symbols,\n    UPBIT: upbit_symbols,\n    GATEIO: gateio_symbols,\n    BITMEX: bitmex_symbols,\n    DERIBIT: deribit_symbols,\n    KRAKEN_FUTURES: kraken_future_symbols,\n    COINGECKO: coingecko_symbols,\n    WHALE_ALERT: whale_alert_coins\n}\n",
        "target_code_with_indent": "\nfrom typing import Dict, Tuple\n\n\nclass _Symbols:\n    <IND>def __init__(self):\n        <IND>self.data = {}\n\n    <DED>def set(self, exchange: str, normalized: dict, exchange_info: dict):\n        <IND>self.data[exchange] = {}\n        self.data[exchange]['normalized'] = normalized\n        self.data[exchange]['info'] = exchange_info\n\n    <DED>def get(self, exchange: str) -> Tuple[Dict, Dict]:\n        <IND>return self.data[exchange]['normalized'], self.data[exchange]['info']\n\n    <DED>def populated(self, exchange: str) -> bool:\n        <IND>return exchange in self.data\n\n\n<DED><DED>Symbols = _Symbols()\n"
      }
    ]
  },
  {
    "project": "bmoscon/cryptofeed",
    "commit": "3525dc8ce4d7836a9abaaa5662e58e5e27969a77",
    "filename": "cryptofeed/symbols.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/bmoscon-cryptofeed/cryptofeed/symbols.py",
    "file_hunks_size": 1,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "cryptofeed/symbols.py:249:8 Incompatible return type [7]: Expected `Dict[str, str]` but got implicit return value of `None`.",
    "message": " Expected `Dict[str, str]` but got implicit return value of `None`.",
    "rule_id": "Incompatible return type [7]",
    "warning_line_no": 249,
    "warning_line": "        raise_failure_explanation('HITBTC', why, {\"\": r})",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "associated with this software.\n\n\nSymbol generation code for exchanges\n'''\n\nimport logging\nimport string\nimport time\nfrom collections import defaultdict\nfrom typing import Dict, List, Optional, Tuple\n\nimport requests\nfrom requests import Response\n\nfrom cryptofeed.defines import *\n\n\nLOG = logging.getLogger('feedhandler')\n\nSYMBOL_SEP = '-'\n\n_symbols_retrieval_cache: Dict[str, Dict[str, str]] = {}\n_exchange_info = defaultdict(lambda: defaultdict(dict))\n\n\n_kraken_futures_product_type = {\n    'FI': 'Inverse Futures',\n    'FV': 'Vanilla Futures',\n    'PI': 'Perpetual Inverse Futures',\n    'PV': 'Perpetual Vanilla Futures',\n    'IN': 'Real Time Index',\n    'RR': 'Reference Rate',\n}\n\n\ndef raise_failure_explanation(feed_id: str, exception: BaseException, responses: Dict[str, Optional[Response]]):\n    LOG.critical('%s: encountered %r while processing response from exchange API', feed_id, exception)\n    if len(responses) > 1:\n        LOG.critical('%s: content of one of the %s responses was unexpected', feed_id, len(responses))\n    for url, r in responses.items():\n        if url:\n            LOG.critical('%s: requested URL: %s', feed_id, url)\n        if r:\n            LOG.critical('%s: unexpected response: %s', feed_id, r.text)\n    raise ValueError(f'Cryptofeed stopped because of an unexpected response from {feed_id}') from exception\n\n\ndef set_symbol_separator(separator: str):\n    global SYMBOL_SEP\n    SYMBOL_SEP = separator\n\n\ndef get_symbol_separator() -> str:\n    global SYMBOL_SEP\n    return SYMBOL_SEP\n\n\ndef gen_symbols(exchange: str, key_id=None) -> Dict[str, str]:\n    if exchange not in _symbols_retrieval_cache:\n        LOG.info(\"%s: Getting list of symbols\", exchange)\n        symbols = _exchange_function_map[exchange](key_id) if key_id else _exchange_function_map[exchange]()\n        LOG.info(\"%s: %s symbols\", exchange, len(symbols))\n\n        # log all retrieved symbols using debug level\n        for normalized, exch_sym in sorted(symbols.items()):\n            LOG.debug('%s: id-from-exch -> normalized: %-35s-> %s', exchange, exch_sym, normalized)\n\n        _symbols_retrieval_cache[exchange] = symbols\n    return _symbols_retrieval_cache[exchange]\n\n\ndef _binance_symbols(endpoint: str, exchange: str):\n    r = None\n    try:\n        ret = {}\n        r = requests.get(endpoint)\n        for symbol in r.json()['symbols']:\n            if symbol.get('status', 'TRADING') != \"TRADING\":\n                continue\n            if symbol.get('contractStatus', 'TRADING') != \"TRADING\":\n                continue\n            split = len(symbol['baseAsset'])\n            normalized = symbol['symbol'][:split] + SYMBOL_SEP + symbol['symbol'][split:]\n            ret[normalized] = symbol['symbol']\n            _exchange_info[exchange]['tick_size'][normalized] = symbol['filters'][0]['tickSize']\n            if \"contractType\" in symbol:\n                _exchange_info[exchange]['contract_type'][normalized] = symbol['contractType']\n        return ret\n    except Exception as why:\n        raise_failure_explanation(exchange, why, {endpoint: r})\n\n\ndef binance_symbols() -> Dict[str, str]:\n    return _binance_symbols('https://api.binance.com/api/v3/exchangeInfo', BINANCE)\n\n\ndef binance_us_symbols() -> Dict[str, str]:\n    return _binance_symbols('https://api.binance.us/api/v3/exchangeInfo', BINANCE_US)\n\n\ndef binance_futures_symbols() -> Dict[str, str]:\n    base = _binance_symbols('https://fapi.binance.com/fapi/v1/exchangeInfo', BINANCE_FUTURES)\n    add = {}\n    for symbol, orig in base.items():\n        if \"_\" in orig:\n            continue\n        add[f\"{symbol}-PINDEX\"] = f\"p{orig}\"\n    base.update(add)\n    return base\n\n\ndef binance_delivery_symbols() -> Dict[str, str]:\n    return _binance_symbols('https://dapi.binance.com/dapi/v1/exchangeInfo', BINANCE_DELIVERY)\n\n\ndef bitfinex_symbols() -> Dict[str, str]:\n    # doc: https://docs.bitfinex.com/docs/ws-general#supported-pairs\n    r1 = r2 = None\n    try:\n        r1 = requests.get('https://api.bitfinex.com/v2/tickers?symbols=ALL')\n        r2 = requests.get('https://api-pub.bitfinex.com/v2/conf/pub:map:currency:sym')\n        tickers: List[List[str]] = r1.json()\n        norm: List[Tuple[str, str]] = r2.json()[0]\n        norm: Dict[str, str] = dict(norm)\n        for k, v in dict(norm).items():\n            if k[-2:] == 'F0' or '-' in v:  # Do not convert BTCF0 -> BTC or PBTCETH -> PBTC-ETH\n                del norm[k]\n        norm['BCHN'] = 'BCH'  # Bitfinex uses BCHN, other exchanges use BCH\n\n        ret = {}\n        for symbol in [t[0] for t in tickers]:\n            if symbol[0] == 'f':\n                normalized = norm.get(symbol[1:], symbol[1:])\n            else:\n                if len(symbol) == 7:\n                    base, quote = symbol[1:4], symbol[4:]\n                else:\n                    base, quote = symbol[1:].split(':')\n                    assert ':' in symbol\n                normalized = norm.get(base, base) + SYMBOL_SEP + norm.get(quote, quote)\n            ret[normalized.upper()] = symbol\n        return ret\n    except ValueError as why:\n        raise_failure_explanation('BITFINEX', why, {\"tickers?symbols=ALL\": r1, \"pub:map:currency:sym\": r2})\n\n\ndef bitflyer_symbols() -> Dict[str, str]:\n    endpoint = r = None\n    try:\n        ret = {}\n        endpoints = ['https://api.bitflyer.com/v1/getmarkets/eu', 'https://api.bitflyer.com/v1/getmarkets/usa', 'https://api.bitflyer.com/v1/getmarkets']\n        for endpoint in endpoints:\n            r = requests.get(endpoint)\n            for entry in r.json():\n                normalized = entry['product_code'].replace(\"_\", SYMBOL_SEP)\n                ret[normalized] = entry['product_code']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('BITFLYER', why, {endpoint: r})\n\n\ndef bybit_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.bybit.com/v2/public/symbols')\n        ret = {}\n        for symbol in r.json()['result']:\n            quote = symbol['quote_currency']\n            if not symbol['name'].endswith(quote):\n                base, contract = symbol['name'].split(quote)\n                normalized = f\"{base}{SYMBOL_SEP}{quote}-{contract}\"\n            else:\n                normalized = f\"{symbol['base_currency']}{SYMBOL_SEP}{quote}\"\n            ret[normalized] = symbol['name']\n            _exchange_info[BYBIT]['tick_size'][normalized] = symbol['price_filter']['tick_size']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('BYBIT', why, {\"\": r})\n\n\ndef _ftx_helper(endpoint: str, exchange: str):\n    r = None\n    try:\n        r = requests.get(endpoint)\n        ret = {}\n        for data in r.json()['result']:\n            normalized = data['name'].replace(\"/\", SYMBOL_SEP)\n            symbol = data['name']\n            ret[normalized] = symbol\n            _exchange_info[exchange]['tick_size'][normalized] = data['priceIncrement']\n        return ret\n    except Exception as why:\n        raise_failure_explanation(exchange, why, {endpoint: r})\n\n\ndef ftx_symbols() -> Dict[str, str]:\n    return _ftx_helper('https://ftx.com/api/markets', FTX)\n\n\ndef ftx_us_symbols() -> Dict[str, str]:\n    return _ftx_helper('https://ftx.us/api/markets', FTX_US)\n\n\ndef coinbase_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.pro.coinbase.com/products')\n        ret = {}\n        for data in r.json():\n            normalized = data['id'].replace(\"-\", SYMBOL_SEP)\n            ret[normalized] = data['id']\n            _exchange_info[COINBASE]['tick_size'][normalized] = data['quote_increment']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('COINBASE', why, {\"\": r})\n\n\ndef gemini_symbols(*args) -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.gemini.com/v1/symbols')\n        ret = {}\n        for symbol in r.json():\n            std = f\"{symbol[:-3]}{SYMBOL_SEP}{symbol[-3:]}\"\n            std = std.upper()\n            ret[std] = symbol.upper()\n        return ret\n    except Exception as why:\n        raise_failure_explanation('GEMINI', why, {\"\": r})\n\n\ndef hitbtc_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        ret = {}\n        r = requests.get('https://api.hitbtc.com/api/2/public/symbol')\n        for symbol in r.json():\n            split = len(symbol['baseCurrency'])\n            normalized = symbol['id'][:split] + SYMBOL_SEP + symbol['id'][split:]\n            ret[normalized] = symbol['id']\n            _exchange_info[HITBTC]['tick_size'][normalized] = symbol['tickSize']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('HITBTC', why, {\"\": r})\n\n\ndef poloniex_id_symbol_mapping():\n    r = None\n    try:\n        r = requests.get('https://poloniex.com/public?command=returnTicker')\n        symbols = r.json()\n        ret = {}\n        for symbol in symbols:\n            ret[symbols[symbol]['id']] = symbol\n        return ret\n    except Exception as why:\n        raise_failure_explanation('POLONIEX', why, {\"\": r})\n\n\ndef poloniex_symbols() -> Dict[str, str]:\n    ret = {}\n    for _, value in poloniex_id_symbol_mapping().items():\n        std = value.replace(\"STR\", \"XLM\")\n        quote, base = std.split(\"_\")\n        ret[quote + SYMBOL_SEP + base] = value\n    return ret\n\n\ndef bitstamp_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://www.bitstamp.net/api/v2/trading-pairs-info/')\n        ret = {}\n        for data in r.json():\n            normalized = data['name'].replace(\"/\", SYMBOL_SEP)\n            symbol = data['url_symbol']\n            ret[normalized] = symbol\n        return ret\n    except Exception as why:\n        raise_failure_explanation('BITSTAMP', why, {\"\": r})\n\n\ndef kraken_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.kraken.com/0/public/AssetPairs')\n        data = r.json()\n        ret = {}\n        for symbol in data['result']:\n            if 'wsname' not in data['result'][symbol] or '.d' in symbol:\n                # https://blog.kraken.com/post/259/introducing-the-kraken-dark-pool/\n                # .d is for dark pool symbols\n                continue\n\n            base, quote = data['result'][symbol]['wsname'].split(\"/\")\n\n            normalized = f\"{base}{SYMBOL_SEP}{quote}\"\n            exch = data['result'][symbol]['wsname']\n            normalized = normalized.replace('XBT', 'BTC')\n            normalized = normalized.replace('XDG', 'DOG')\n            ret[normalized] = exch\n        return ret\n    except Exception as why:\n        raise_failure_explanation('KRAKEN', why, {\"\": r})\n\n\ndef kraken_rest_symbols() -> Dict[str, str]:\n    return {normalized: exchange.replace(\"/\", \"\") for normalized, exchange in kraken_symbols().items()}\n\n\ndef exx_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.exx.com/data/v1/tickers')\n        exchange = [key.upper() for key in r.json().keys()]\n        symbols = [key.replace(\"_\", SYMBOL_SEP) for key in exchange]\n        return dict(zip(symbols, exchange))\n    except Exception as why:\n        raise_failure_explanation('EXX', why, {\"\": r})\n\n\ndef huobi_common_symbols(url: str):\n    r = None\n    try:\n        r = requests.get(url)\n        ret = {}\n        for e in r.json()['data']:\n            if e['state'] == 'offline':\n                continue\n            normalized = f\"{e['base-currency'].upper()}{SYMBOL_SEP}{e['quote-currency'].upper()}\"\n            symbol = f\"{e['base-currency']}{e['quote-currency']}\"\n            ret[normalized] = symbol\n        return ret\n    except Exception as why:\n        raise_failure_explanation('HUOBI', why, {url: r})\n\n\ndef huobi_symbols() -> Dict[str, str]:\n    return huobi_common_symbols('https://api.huobi.pro/v1/common/symbols')\n\n\ndef huobi_us_symbols() -> Dict[str, str]:\n    return huobi_common_symbols('https://api.huobi.com/v1/common/symbols')\n\n\ndef huobi_dm_symbols() -> Dict[str, str]:\n    \"\"\"\n    Mapping is, for instance: {\"BTC_CW\":\"BTC190816\"}\n    See comments in exchange/huobi_dm.py\n    \"\"\"\n    mapping = {\n        \"this_week\": \"CW\",\n        \"next_week\": \"NW\",\n        \"quarter\": \"CQ\",\n        \"next_quarter\": \"NQ\"\n    }\n    r = None\n    try:\n        r = requests.get('https://www.hbdm.com/api/v1/contract_contract_info')\n        symbols = {}\n        for e in r.json()['data']:\n            symbols[f\"{e['symbol']}_{mapping[e['contract_type']]}\"] = e['contract_code']\n            _exchange_info[HUOBI_DM]['tick_size'][e['contract_code']] = e['price_tick']\n            _exchange_info[HUOBI_DM]['short_code_mappings'][f\"{e['symbol']}_{mapping[e['contract_type']]}\"] = e['contract_code']\n        return symbols\n    except Exception as why:\n        raise_failure_explanation('HUOBI_DM', why, {\"\": r})\n\n\ndef huobi_swap_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.hbdm.com/swap-api/v1/swap_contract_info')\n        symbols = {}\n        for e in r.json()['data']:\n            symbols[e['contract_code']] = e['contract_code']\n            _exchange_info[HUOBI_SWAP]['tick_size'][e['contract_code']] = e['price_tick']\n        return symbols\n    except Exception as why:\n        raise_failure_explanation('HUOBI_SWAP', why, {\"\": r})\n\n\ndef okcoin_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://www.okcoin.com/api/spot/v3/instruments')\n        ret = {}\n        for e in r.json():\n            ret[e['instrument_id']] = e['instrument_id']\n            _exchange_info[OKCOIN]['tick_size'][e['instrument_id']] = e['tick_size']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('OKCOIN', why, {\"\": r})\n\n\ndef okex_symbols(*args) -> Dict[str, str]:\n    urls = ['https://www.okex.com/api/spot/v3/instruments',\n            'https://www.okex.com/api/swap/v3/instruments',\n            'https://www.okex.com/api/futures/v3/instruments']\n    urls = urls + okex_compute_option_urls_from_underlyings()\n\n    symbols: Dict[str, str] = {}\n    for u in urls:\n        time.sleep(0.2)\n        symbols.update(okex_symbols_from_one_url(u))\n\n    for symbol in symbols:\n        instrument_type = 'futures'\n        dash_count = symbol.count(get_symbol_separator())\n        if dash_count == 1:  # BTC-USDT\n            instrument_type = 'spot'\n        if dash_count == 4:  # BTC-USD-201225-35000-P\n            instrument_type = 'option'\n        if symbol[-4:] == \"SWAP\":  # BTC-USDT-SWAP\n            instrument_type = 'swap'\n\n        _exchange_info[OKEX]['instrument_type'][symbol] = instrument_type\n\n    return symbols\n\n\ndef okex_compute_option_urls_from_underlyings() -> List[str]:\n    url = 'https://www.okex.com/api/option/v3/underlying'\n    r = None\n    try:\n        r = requests.get(url)\n        return [f'https://www.okex.com/api/option/v3/instruments/{underlying}' for underlying in r.json()]\n    except Exception as why:\n        raise_failure_explanation('OKEX', why, {url: r})\n\n\ndef okex_symbols_from_one_url(url: str) -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get(url)\n        ret = {}\n        for e in r.json():\n            ret[e['instrument_id']] = e['instrument_id']\n            _exchange_info[OKEX]['tick_size'][e['instrument_id']] = e['tick_size']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('OKEX', why, {url: r})\n\n\ndef bittrex_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.bittrex.com/api/v1.1/public/getmarkets')\n        r = r.json()['result']\n        return {f\"{e['MarketCurrency']}{SYMBOL_SEP}{e['BaseCurrency']}\": e['MarketName'] for e in r if e['IsActive']}\n    except Exception as why:\n        raise_failure_explanation('BITTREX', why, {\"\": r})\n\n\ndef bitcoincom_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.exchange.bitcoin.com/api/2/public/symbol')\n        return {f\"{data['baseCurrency']}{SYMBOL_SEP}{data['quoteCurrency'].replace('USD', 'USDT')}\": data['id'] for data in r.json()}\n    except Exception as why:\n        raise_failure_explanation('BITCOINCOM', why, {\"\": r})\n\n\ndef bitmax_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://bitmax.io/api/pro/v1/products')\n        ret = {}\n        for entry in r.json()['data']:\n            # Only \"Normal\" status symbols are tradeable\n            if entry['status'] == 'Normal':\n                normalized = f\"{entry['baseAsset']}{SYMBOL_SEP}{entry['quoteAsset']}\"\n                ret[normalized] = entry['symbol']\n                _exchange_info[BITMAX]['tick_size'][normalized] = entry['tickSize']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('BITMAX', why, {\"\": r})\n\n\ndef upbit_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.upbit.com/v1/market/all')\n        return {f\"{data['market'].split('-')[1]}{SYMBOL_SEP}{data['market'].split('-')[0]}\": data['market'] for data in r.json()}\n    except Exception as why:\n        raise_failure_explanation('UPBIT', why, {\"\": r})\n\n\ndef blockchain_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get(\"https://api.blockchain.com/mercury-gateway/v1/instruments\")\n        return {data[\"symbol\"].replace(\"-\", SYMBOL_SEP): data[\"symbol\"] for data in r.json()}\n    except Exception as why:\n        raise_failure_explanation('BLOCKCHAIN', why, {\"\": r})\n\n\ndef gateio_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get(\"https://api.gateio.ws/api/v4/spot/currency_pairs\")\n        return {data[\"id\"].replace(\"_\", SYMBOL_SEP): data['id'] for data in r.json()}\n    except Exception as why:\n        raise_failure_explanation('GATEIO', why, {\"\": r})\n\n\ndef bitmex_symbols() -> Dict[str, str]:\n    r = None\n    ret = {}\n    try:\n        r = requests.get(\"https://www.bitmex.com/api/v1/instrument/active\")\n        for entry in r.json():\n            components = []\n            components.append(entry['rootSymbol'])\n            components.append(entry['quoteCurrency'])\n\n            if entry['expiry']:\n                components.append(entry['symbol'][-3:])\n\n            normalized = SYMBOL_SEP.join(components)\n            normalized = normalized.replace(\"XBT\", \"BTC\")\n            ret[normalized] = entry['symbol']\n            _exchange_info[BITMEX]['tick_size'][normalized] = entry['tickSize']\n\n            if entry['expiry']:\n                _exchange_info[BITMEX]['expiry'][normalized] = entry['expiry']\n\n        return ret\n    except Exception as why:\n        raise_failure_explanation('BITMEX', why, {\"\": r})\n\n\ndef deribit_symbols() -> Dict[str, str]:\n    url = r = None\n    ret = {}\n    try:\n        # TODO: get currencies from https://www.deribit.com/api/v2/public/get_currencies\n        currencies = ['BTC', 'ETH']\n        for c in currencies:\n            url = f\"https://www.deribit.com/api/v2/public/get_instruments?currency={c}&expired=false\"\n            r = requests.get(url)\n            for entry in r.json()['result']:\n                split = entry['instrument_name'].split(\"-\")\n                normalized = split[0] + SYMBOL_SEP + entry['quote_currency'] + \"-\" + '-'.join(split[1:])\n                ret[normalized] = entry['instrument_name']\n                _exchange_info[DERIBIT]['tick_size'][normalized] = entry['tick_size']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('DERIBIT', why, {url: r})\n\n\ndef kraken_future_symbols() -> Dict[str, str]:\n    r = None\n    ret = {}\n    try:\n        r = requests.get('https://futures.kraken.com/derivatives/api/v3/instruments')\n        data = r.json()['instruments']\n        for entry in data:\n            if not entry['tradeable']:\n                continue\n            normalized = entry['symbol'].upper().replace(\"_\", \"-\")\n            symbol = normalized[3:6] + SYMBOL_SEP + normalized[6:9]\n            normalized = normalized.replace(normalized[3:9], symbol)\n            normalized = normalized.replace('XBT', 'BTC')\n\n            _exchange_info[KRAKEN_FUTURES]['tick_size'][normalized] = entry['tickSize']\n            _exchange_info[KRAKEN_FUTURES]['contract_size'][normalized] = entry['contractSize']\n            _exchange_info[KRAKEN_FUTURES]['underlying'][normalized] = entry['underlying']\n            _exchange_info[KRAKEN_FUTURES]['product_type'][normalized] = _kraken_futures_product_type[normalized[:2]]\n            ret[normalized] = entry['symbol']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('KRAKEN_FUTURES', why, {\"\": r})\n\n\ndef probit_symbols() -> Dict[str, str]:\n    # doc: https://docs-en.probit.com/reference-link/market\n    r = None\n    try:\n        r = requests.get('https://api.probit.com/api/exchange/v1/market')\n        return {entry['id']: entry['id'] for entry in r.json()['data']}\n    except Exception as why:\n        raise_failure_explanation('PROBIT', why, {\"\": r})\n\n\ndef coingecko_normalize_symbol(symbol: str) -> str:\n    # keep digits, letters and dots, replace others by space\n    symbol = ''.join(c if c.isalnum() or c in ('.', '+') else ' ' for c in symbol)\n    return coingecko_normalize(symbol.upper())\n\n\ndef coingecko_normalize_name(name: str) -> str:\n    # keep digits and letters, replace others by space (except when only composed by upper case letters, digits and dots)\n    if not all(c.isupper() or c.isdigit() or c == '.' for c in name):\n        name = ''.join(c if c.isalnum() else ' ' for c in name)\n    return coingecko_normalize(name)\n\n\ndef coingecko_normalize(sym: str) -> str:\n    sym = sym.strip()\n    # do not concatenate numbers => separate them with a dot\n    sym = list(sym)\n    if len(sym) > 4:\n        for i in range(2, len(sym) - 1):\n            if sym[i] == ' ' and sym[i - 1].isdigit() and sym[i + 1].isdigit():\n                sym[i] = '.'\n    sym = ''.join(sym)\n    # concatenate space-separated words => use CamelCase to distinguish the words\n    if ' ' in sym:\n        if sum(c.islower() for c in sym):  # if there is at least one lower case letter\n            sym = ' '.join(word[0].upper() + word[1:] for word in sym.split())  # Just capitalize initial letter of each word\n        else:  # CoinGecko may provide full upper-case as for \"THE STONE COIN\"\n            sym = string.capwords(sym)  # capwords converts \"THE STONE COIN\" to \"The Stone Coin\"\n        sym = sym.replace(' ', '')  # concatenate words\n    return sym\n\n\ndef is_name_short(coin: dict) -> bool:\n    \"\"\"return True if the coin name is enough short compared to the coin symbol.\"\"\"\n    return len(coin['name']) <= max(5, len(coin['symbol']) + 1)\n\n\ndef has_many_caps(name: str) -> bool:\n    \"\"\"return True if the symbol contains enough upper case letters, False if empty.\"\"\"\n    return str and sum(c.islower() for c in name) < (len(name) / 2)\n\n\ndef coingecko_normalize_all(coin: dict):\n    SYMBOL_TO_NORMALIZED = {'miota': 'IOTA'}\n    normalized = SYMBOL_TO_NORMALIZED.get(coin['symbol'])\n    if normalized:\n        coin['ns'] = coin['nn'] = normalized\n        return normalized\n\n    # ns = normalized symbol, nn = normalized name\n    coin['ns'] = coingecko_normalize_symbol(coin['symbol'])\n\n    ID_SUFFIX = '-bitcoin-token'\n    if coin['id'][-len(ID_SUFFIX):] == ID_SUFFIX:\n        coin['nn'] = 'BTC' + coin['ns']\n        return coin['nn']\n\n    name = coin['name']\n\n    prefixes = ('The ', 'the ')\n    for p in prefixes:\n        if name[:len(p)] == p:\n            coin['reduced-name'] = True\n            name = name[len(p):]\n            break\n\n    suffixes = ('coin', 'coins', 'money', 'finance', 'protocol', 'reward', 'rewards', 'token')\n    for s in suffixes:\n        if len(name) > len(s) and name[-len(s):].lower() == s:\n            # but keep suffix when lower-case concatenated\n            if name[-len(s)].islower() and name[-len(s) - 1] != ' ':\n                continue\n            # also keep suffix to avoid confusing nam: \"Bitcoin Token\" -> \"Bitcoin\"\n            if name[:-len(s)].strip().lower() == 'bitcoin':\n                continue\n            coin['reduced-name'] = True\n            name = name[:-len(s)]\n            break\n\n    coin['nn'] = coingecko_normalize_name(name)\n\n    if len(coin['nn']) < len(coin['ns']):\n        if 'reduced-name' in coin:\n            coin['reduced-name'] = False\n            name = coin['name']\n            coin['nn'] = coingecko_normalize_name(name)\n        elif not has_many_caps(name):\n            return coin['ns']\n\n    if not coin['ns']:  # coin['symbol'] may be an emoji that is striped when normalized\n        return coin['nn']\n\n    if coin.get('reduced-name') and coin['ns'].upper() != coin['nn'].upper():\n        return coin['ns']\n\n    i = coin['nn'].find('.')  # if there is a dot in normalized name => prefer the normalized symbol\n    if i >= 0:\n        if i > 1 and coin['nn'][i - 1].isdigit() and coin['nn'][i + 1].isdigit():\n            pass  # except when the dot separates digits\n        else:\n            return coin['ns']\n\n    if is_name_short(coin) and has_many_caps(name):\n        return coin['nn']\n\n    if 1.5 * len(coin['ns']) > len(coin['nn']) and any(c.islower() for c in coin['ns']):\n        return coin['nn']\n\n    return coin['ns']\n\n\ndef coingecko_symbols() -> Dict[str, str]:\n    r = None\n    intermediate = defaultdict(list)\n    try:\n        r = requests.get('https://api.coingecko.com/api/v3/coins/list')\n        all_coins = r.json()\n        # First pass: generate & compare normalized symbol/name, and then select the most pertinent\n        for coin in all_coins:\n            normalized = coingecko_normalize_all(coin)\n            intermediate[normalized].append(coin)\n            # Above line keeps together the coins having the same normalized symbol.\n            # To reduce collision, the coin['name'] is sometimes used in lieu of the coin['symbol'].\n            # The coin['name'] is not capitalized because lower case letters may be meaningful: cETH, yUSD, DATx, zLOT\n    except Exception as why:\n        raise_failure_explanation('COINGECKO', why, {\"\": r})\n\n    final = coingecko_second_pass(intermediate)\n    return coingecko_third_pass(final)\n\n\ndef coingecko_second_pass(intermediate: Dict[str, List[dict]]) -> Dict[str, List[dict]]:\n    # Second pass: fixes most of the symbol collisions\n    final = defaultdict(list)\n    for normalized, coins in intermediate.items():\n        if len(coins) == 1:\n            final[normalized].append(coins[0])\n            continue\n        set_normalized = False\n        for i in range(len(coins)):\n            if normalized == coins[i]['nn']:\n                coin = coins.pop(i)\n                final[normalized].append(coin)\n                set_normalized = True\n                break\n        rest: List[dict] = []\n        for coin in coins:\n            if '%' in coin['name']:\n                if len(coins) == 1:\n                    n = coin['ns']\n                else:\n                    n = coingecko_normalize_name(coin['id'])\n                final[n].append(coin)\n            else:\n                rest.append(coin)\n        if not rest:\n            continue\n        if not set_normalized:\n            rest.sort(key=lambda coin: len(coin['nn']), reverse=True)  # sort by the length of the normalized name\n            coin = rest.pop(0)\n            final[normalized].append(coin)\n        for coin in rest:\n            if coin['nn'] not in intermediate:\n                n = coin['nn']\n            elif coin.get('reduced-name'):\n                n = coingecko_normalize_name(coin['name'])\n            else:\n                n = coingecko_normalize_name(coin['id'])\n            final[n].append(coin)\n    return final\n\n\ndef coingecko_third_pass(final: Dict[str, List[dict]]) -> Dict[str, str]:\n    # Third pass: fixes some remaining collisions and fills the result\n    symbols = {}\n    for normalized, coins in final.items():\n        if len(coins) == 1:\n            symbols[normalized] = coins[0]['id']\n            continue\n        set_normalized = False\n        for i in range(len(coins)):\n            if normalized == coins[i]['nn']:\n                coin = coins.pop(i)\n                symbols[normalized] = coin['id']\n                set_normalized = True\n                break\n        rest: List[dict] = []\n        for coin in coins:\n            if '%' in coin['name']:\n                if len(coins) == 1:\n                    n = coin['ns']\n                else:\n                    n = coingecko_normalize_name(coin['id'])\n                symbols[n] = coin['id']\n            else:\n                rest.append(coin)\n        if not rest:\n            continue\n        if not set_normalized:\n            rest.sort(key=lambda coin: len(coin['nn']), reverse=True)  # sort by the length of the normalized name\n            coin = rest.pop(0)\n            symbols[normalized] = coin['id']\n        for coin in rest:\n            if coin['nn'] not in final:\n                n = coin['nn']\n            elif coin.get('reduced-name'):\n                n = coingecko_normalize_name(coin['name'])\n            else:\n                n = coingecko_normalize_name(coin['id'])\n            symbols[n] = coin['id']\n    return symbols\n\n\ndef whale_alert_coins(key_id: str) -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get(f'https://api.whale-alert.io/v1/status?api_key={key_id}')\n        # Same symbols, but on different blockchains (for instance USDT), are naturally overwritten.\n        return {s.upper(): s for b in r.json()['blockchains'] for s in b['symbols'] if s}\n    except Exception as why:\n        raise_failure_explanation('WHALES_ALERT', why, {\"\": r})\n\n\n_exchange_function_map = {\n    BITFINEX: bitfinex_symbols,\n    BITFLYER: bitflyer_symbols,\n    COINBASE: coinbase_symbols,\n    GEMINI: gemini_symbols,\n    HITBTC: hitbtc_symbols,\n    POLONIEX: poloniex_symbols,\n    PROBIT: probit_symbols,\n    BITSTAMP: bitstamp_symbols,\n    KRAKEN: kraken_symbols,\n    KRAKEN + 'REST': kraken_rest_symbols,\n    BINANCE: binance_symbols,\n    BINANCE_US: binance_us_symbols,\n    BINANCE_FUTURES: binance_futures_symbols,\n    BINANCE_DELIVERY: binance_delivery_symbols,\n    BLOCKCHAIN: blockchain_symbols,\n    EXX: exx_symbols,\n    HUOBI: huobi_symbols,\n    HUOBI_DM: huobi_dm_symbols,\n    HUOBI_SWAP: huobi_swap_symbols,\n    OKCOIN: okcoin_symbols,\n    OKEX: okex_symbols,\n    BYBIT: bybit_symbols,\n    FTX: ftx_symbols,\n    FTX_US: ftx_us_symbols,\n    BITTREX: bittrex_symbols,\n    BITCOINCOM: bitcoincom_symbols,\n    BITMAX: bitmax_symbols,\n    UPBIT: upbit_symbols,\n    GATEIO: gateio_symbols,\n    BITMEX: bitmex_symbols,\n    DERIBIT: deribit_symbols,\n    KRAKEN_FUTURES: kraken_future_symbols,\n    COINGECKO: coingecko_symbols,\n    WHALE_ALERT: whale_alert_coins\n}\n",
        "source_code_len": 30534,
        "target_code": "associated with this software.\n'''\nfrom typing import Dict, Tuple\n\n\nclass _Symbols:\n    def __init__(self):\n        self.data = {}\n\n    def set(self, exchange: str, normalized: dict, exchange_info: dict):\n        self.data[exchange] = {}\n        self.data[exchange]['normalized'] = normalized\n        self.data[exchange]['info'] = exchange_info\n\n    def get(self, exchange: str) -> Tuple[Dict, Dict]:\n        return self.data[exchange]['normalized'], self.data[exchange]['info']\n\n    def populated(self, exchange: str) -> bool:\n        return exchange in self.data\n\n\nSymbols = _Symbols()\n",
        "target_code_len": 588,
        "diff_format": "@@ -5,845 +5,22 @@\n associated with this software.\n+'''\n+from typing import Dict, Tuple\n \n \n-Symbol generation code for exchanges\n-'''\n+class _Symbols:\n+    def __init__(self):\n+        self.data = {}\n \n-import logging\n-import string\n-import time\n-from collections import defaultdict\n-from typing import Dict, List, Optional, Tuple\n+    def set(self, exchange: str, normalized: dict, exchange_info: dict):\n+        self.data[exchange] = {}\n+        self.data[exchange]['normalized'] = normalized\n+        self.data[exchange]['info'] = exchange_info\n \n-import requests\n-from requests import Response\n+    def get(self, exchange: str) -> Tuple[Dict, Dict]:\n+        return self.data[exchange]['normalized'], self.data[exchange]['info']\n \n-from cryptofeed.defines import *\n+    def populated(self, exchange: str) -> bool:\n+        return exchange in self.data\n \n \n-LOG = logging.getLogger('feedhandler')\n-\n-SYMBOL_SEP = '-'\n-\n-_symbols_retrieval_cache: Dict[str, Dict[str, str]] = {}\n-_exchange_info = defaultdict(lambda: defaultdict(dict))\n-\n-\n-_kraken_futures_product_type = {\n-    'FI': 'Inverse Futures',\n-    'FV': 'Vanilla Futures',\n-    'PI': 'Perpetual Inverse Futures',\n-    'PV': 'Perpetual Vanilla Futures',\n-    'IN': 'Real Time Index',\n-    'RR': 'Reference Rate',\n-}\n-\n-\n-def raise_failure_explanation(feed_id: str, exception: BaseException, responses: Dict[str, Optional[Response]]):\n-    LOG.critical('%s: encountered %r while processing response from exchange API', feed_id, exception)\n-    if len(responses) > 1:\n-        LOG.critical('%s: content of one of the %s responses was unexpected', feed_id, len(responses))\n-    for url, r in responses.items():\n-        if url:\n-            LOG.critical('%s: requested URL: %s', feed_id, url)\n-        if r:\n-            LOG.critical('%s: unexpected response: %s', feed_id, r.text)\n-    raise ValueError(f'Cryptofeed stopped because of an unexpected response from {feed_id}') from exception\n-\n-\n-def set_symbol_separator(separator: str):\n-    global SYMBOL_SEP\n-    SYMBOL_SEP = separator\n-\n-\n-def get_symbol_separator() -> str:\n-    global SYMBOL_SEP\n-    return SYMBOL_SEP\n-\n-\n-def gen_symbols(exchange: str, key_id=None) -> Dict[str, str]:\n-    if exchange not in _symbols_retrieval_cache:\n-        LOG.info(\"%s: Getting list of symbols\", exchange)\n-        symbols = _exchange_function_map[exchange](key_id) if key_id else _exchange_function_map[exchange]()\n-        LOG.info(\"%s: %s symbols\", exchange, len(symbols))\n-\n-        # log all retrieved symbols using debug level\n-        for normalized, exch_sym in sorted(symbols.items()):\n-            LOG.debug('%s: id-from-exch -> normalized: %-35s-> %s', exchange, exch_sym, normalized)\n-\n-        _symbols_retrieval_cache[exchange] = symbols\n-    return _symbols_retrieval_cache[exchange]\n-\n-\n-def _binance_symbols(endpoint: str, exchange: str):\n-    r = None\n-    try:\n-        ret = {}\n-        r = requests.get(endpoint)\n-        for symbol in r.json()['symbols']:\n-            if symbol.get('status', 'TRADING') != \"TRADING\":\n-                continue\n-            if symbol.get('contractStatus', 'TRADING') != \"TRADING\":\n-                continue\n-            split = len(symbol['baseAsset'])\n-            normalized = symbol['symbol'][:split] + SYMBOL_SEP + symbol['symbol'][split:]\n-            ret[normalized] = symbol['symbol']\n-            _exchange_info[exchange]['tick_size'][normalized] = symbol['filters'][0]['tickSize']\n-            if \"contractType\" in symbol:\n-                _exchange_info[exchange]['contract_type'][normalized] = symbol['contractType']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation(exchange, why, {endpoint: r})\n-\n-\n-def binance_symbols() -> Dict[str, str]:\n-    return _binance_symbols('https://api.binance.com/api/v3/exchangeInfo', BINANCE)\n-\n-\n-def binance_us_symbols() -> Dict[str, str]:\n-    return _binance_symbols('https://api.binance.us/api/v3/exchangeInfo', BINANCE_US)\n-\n-\n-def binance_futures_symbols() -> Dict[str, str]:\n-    base = _binance_symbols('https://fapi.binance.com/fapi/v1/exchangeInfo', BINANCE_FUTURES)\n-    add = {}\n-    for symbol, orig in base.items():\n-        if \"_\" in orig:\n-            continue\n-        add[f\"{symbol}-PINDEX\"] = f\"p{orig}\"\n-    base.update(add)\n-    return base\n-\n-\n-def binance_delivery_symbols() -> Dict[str, str]:\n-    return _binance_symbols('https://dapi.binance.com/dapi/v1/exchangeInfo', BINANCE_DELIVERY)\n-\n-\n-def bitfinex_symbols() -> Dict[str, str]:\n-    # doc: https://docs.bitfinex.com/docs/ws-general#supported-pairs\n-    r1 = r2 = None\n-    try:\n-        r1 = requests.get('https://api.bitfinex.com/v2/tickers?symbols=ALL')\n-        r2 = requests.get('https://api-pub.bitfinex.com/v2/conf/pub:map:currency:sym')\n-        tickers: List[List[str]] = r1.json()\n-        norm: List[Tuple[str, str]] = r2.json()[0]\n-        norm: Dict[str, str] = dict(norm)\n-        for k, v in dict(norm).items():\n-            if k[-2:] == 'F0' or '-' in v:  # Do not convert BTCF0 -> BTC or PBTCETH -> PBTC-ETH\n-                del norm[k]\n-        norm['BCHN'] = 'BCH'  # Bitfinex uses BCHN, other exchanges use BCH\n-\n-        ret = {}\n-        for symbol in [t[0] for t in tickers]:\n-            if symbol[0] == 'f':\n-                normalized = norm.get(symbol[1:], symbol[1:])\n-            else:\n-                if len(symbol) == 7:\n-                    base, quote = symbol[1:4], symbol[4:]\n-                else:\n-                    base, quote = symbol[1:].split(':')\n-                    assert ':' in symbol\n-                normalized = norm.get(base, base) + SYMBOL_SEP + norm.get(quote, quote)\n-            ret[normalized.upper()] = symbol\n-        return ret\n-    except ValueError as why:\n-        raise_failure_explanation('BITFINEX', why, {\"tickers?symbols=ALL\": r1, \"pub:map:currency:sym\": r2})\n-\n-\n-def bitflyer_symbols() -> Dict[str, str]:\n-    endpoint = r = None\n-    try:\n-        ret = {}\n-        endpoints = ['https://api.bitflyer.com/v1/getmarkets/eu', 'https://api.bitflyer.com/v1/getmarkets/usa', 'https://api.bitflyer.com/v1/getmarkets']\n-        for endpoint in endpoints:\n-            r = requests.get(endpoint)\n-            for entry in r.json():\n-                normalized = entry['product_code'].replace(\"_\", SYMBOL_SEP)\n-                ret[normalized] = entry['product_code']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('BITFLYER', why, {endpoint: r})\n-\n-\n-def bybit_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.bybit.com/v2/public/symbols')\n-        ret = {}\n-        for symbol in r.json()['result']:\n-            quote = symbol['quote_currency']\n-            if not symbol['name'].endswith(quote):\n-                base, contract = symbol['name'].split(quote)\n-                normalized = f\"{base}{SYMBOL_SEP}{quote}-{contract}\"\n-            else:\n-                normalized = f\"{symbol['base_currency']}{SYMBOL_SEP}{quote}\"\n-            ret[normalized] = symbol['name']\n-            _exchange_info[BYBIT]['tick_size'][normalized] = symbol['price_filter']['tick_size']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('BYBIT', why, {\"\": r})\n-\n-\n-def _ftx_helper(endpoint: str, exchange: str):\n-    r = None\n-    try:\n-        r = requests.get(endpoint)\n-        ret = {}\n-        for data in r.json()['result']:\n-            normalized = data['name'].replace(\"/\", SYMBOL_SEP)\n-            symbol = data['name']\n-            ret[normalized] = symbol\n-            _exchange_info[exchange]['tick_size'][normalized] = data['priceIncrement']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation(exchange, why, {endpoint: r})\n-\n-\n-def ftx_symbols() -> Dict[str, str]:\n-    return _ftx_helper('https://ftx.com/api/markets', FTX)\n-\n-\n-def ftx_us_symbols() -> Dict[str, str]:\n-    return _ftx_helper('https://ftx.us/api/markets', FTX_US)\n-\n-\n-def coinbase_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.pro.coinbase.com/products')\n-        ret = {}\n-        for data in r.json():\n-            normalized = data['id'].replace(\"-\", SYMBOL_SEP)\n-            ret[normalized] = data['id']\n-            _exchange_info[COINBASE]['tick_size'][normalized] = data['quote_increment']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('COINBASE', why, {\"\": r})\n-\n-\n-def gemini_symbols(*args) -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.gemini.com/v1/symbols')\n-        ret = {}\n-        for symbol in r.json():\n-            std = f\"{symbol[:-3]}{SYMBOL_SEP}{symbol[-3:]}\"\n-            std = std.upper()\n-            ret[std] = symbol.upper()\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('GEMINI', why, {\"\": r})\n-\n-\n-def hitbtc_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        ret = {}\n-        r = requests.get('https://api.hitbtc.com/api/2/public/symbol')\n-        for symbol in r.json():\n-            split = len(symbol['baseCurrency'])\n-            normalized = symbol['id'][:split] + SYMBOL_SEP + symbol['id'][split:]\n-            ret[normalized] = symbol['id']\n-            _exchange_info[HITBTC]['tick_size'][normalized] = symbol['tickSize']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('HITBTC', why, {\"\": r})\n-\n-\n-def poloniex_id_symbol_mapping():\n-    r = None\n-    try:\n-        r = requests.get('https://poloniex.com/public?command=returnTicker')\n-        symbols = r.json()\n-        ret = {}\n-        for symbol in symbols:\n-            ret[symbols[symbol]['id']] = symbol\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('POLONIEX', why, {\"\": r})\n-\n-\n-def poloniex_symbols() -> Dict[str, str]:\n-    ret = {}\n-    for _, value in poloniex_id_symbol_mapping().items():\n-        std = value.replace(\"STR\", \"XLM\")\n-        quote, base = std.split(\"_\")\n-        ret[quote + SYMBOL_SEP + base] = value\n-    return ret\n-\n-\n-def bitstamp_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://www.bitstamp.net/api/v2/trading-pairs-info/')\n-        ret = {}\n-        for data in r.json():\n-            normalized = data['name'].replace(\"/\", SYMBOL_SEP)\n-            symbol = data['url_symbol']\n-            ret[normalized] = symbol\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('BITSTAMP', why, {\"\": r})\n-\n-\n-def kraken_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.kraken.com/0/public/AssetPairs')\n-        data = r.json()\n-        ret = {}\n-        for symbol in data['result']:\n-            if 'wsname' not in data['result'][symbol] or '.d' in symbol:\n-                # https://blog.kraken.com/post/259/introducing-the-kraken-dark-pool/\n-                # .d is for dark pool symbols\n-                continue\n-\n-            base, quote = data['result'][symbol]['wsname'].split(\"/\")\n-\n-            normalized = f\"{base}{SYMBOL_SEP}{quote}\"\n-            exch = data['result'][symbol]['wsname']\n-            normalized = normalized.replace('XBT', 'BTC')\n-            normalized = normalized.replace('XDG', 'DOG')\n-            ret[normalized] = exch\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('KRAKEN', why, {\"\": r})\n-\n-\n-def kraken_rest_symbols() -> Dict[str, str]:\n-    return {normalized: exchange.replace(\"/\", \"\") for normalized, exchange in kraken_symbols().items()}\n-\n-\n-def exx_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.exx.com/data/v1/tickers')\n-        exchange = [key.upper() for key in r.json().keys()]\n-        symbols = [key.replace(\"_\", SYMBOL_SEP) for key in exchange]\n-        return dict(zip(symbols, exchange))\n-    except Exception as why:\n-        raise_failure_explanation('EXX', why, {\"\": r})\n-\n-\n-def huobi_common_symbols(url: str):\n-    r = None\n-    try:\n-        r = requests.get(url)\n-        ret = {}\n-        for e in r.json()['data']:\n-            if e['state'] == 'offline':\n-                continue\n-            normalized = f\"{e['base-currency'].upper()}{SYMBOL_SEP}{e['quote-currency'].upper()}\"\n-            symbol = f\"{e['base-currency']}{e['quote-currency']}\"\n-            ret[normalized] = symbol\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('HUOBI', why, {url: r})\n-\n-\n-def huobi_symbols() -> Dict[str, str]:\n-    return huobi_common_symbols('https://api.huobi.pro/v1/common/symbols')\n-\n-\n-def huobi_us_symbols() -> Dict[str, str]:\n-    return huobi_common_symbols('https://api.huobi.com/v1/common/symbols')\n-\n-\n-def huobi_dm_symbols() -> Dict[str, str]:\n-    \"\"\"\n-    Mapping is, for instance: {\"BTC_CW\":\"BTC190816\"}\n-    See comments in exchange/huobi_dm.py\n-    \"\"\"\n-    mapping = {\n-        \"this_week\": \"CW\",\n-        \"next_week\": \"NW\",\n-        \"quarter\": \"CQ\",\n-        \"next_quarter\": \"NQ\"\n-    }\n-    r = None\n-    try:\n-        r = requests.get('https://www.hbdm.com/api/v1/contract_contract_info')\n-        symbols = {}\n-        for e in r.json()['data']:\n-            symbols[f\"{e['symbol']}_{mapping[e['contract_type']]}\"] = e['contract_code']\n-            _exchange_info[HUOBI_DM]['tick_size'][e['contract_code']] = e['price_tick']\n-            _exchange_info[HUOBI_DM]['short_code_mappings'][f\"{e['symbol']}_{mapping[e['contract_type']]}\"] = e['contract_code']\n-        return symbols\n-    except Exception as why:\n-        raise_failure_explanation('HUOBI_DM', why, {\"\": r})\n-\n-\n-def huobi_swap_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.hbdm.com/swap-api/v1/swap_contract_info')\n-        symbols = {}\n-        for e in r.json()['data']:\n-            symbols[e['contract_code']] = e['contract_code']\n-            _exchange_info[HUOBI_SWAP]['tick_size'][e['contract_code']] = e['price_tick']\n-        return symbols\n-    except Exception as why:\n-        raise_failure_explanation('HUOBI_SWAP', why, {\"\": r})\n-\n-\n-def okcoin_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://www.okcoin.com/api/spot/v3/instruments')\n-        ret = {}\n-        for e in r.json():\n-            ret[e['instrument_id']] = e['instrument_id']\n-            _exchange_info[OKCOIN]['tick_size'][e['instrument_id']] = e['tick_size']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('OKCOIN', why, {\"\": r})\n-\n-\n-def okex_symbols(*args) -> Dict[str, str]:\n-    urls = ['https://www.okex.com/api/spot/v3/instruments',\n-            'https://www.okex.com/api/swap/v3/instruments',\n-            'https://www.okex.com/api/futures/v3/instruments']\n-    urls = urls + okex_compute_option_urls_from_underlyings()\n-\n-    symbols: Dict[str, str] = {}\n-    for u in urls:\n-        time.sleep(0.2)\n-        symbols.update(okex_symbols_from_one_url(u))\n-\n-    for symbol in symbols:\n-        instrument_type = 'futures'\n-        dash_count = symbol.count(get_symbol_separator())\n-        if dash_count == 1:  # BTC-USDT\n-            instrument_type = 'spot'\n-        if dash_count == 4:  # BTC-USD-201225-35000-P\n-            instrument_type = 'option'\n-        if symbol[-4:] == \"SWAP\":  # BTC-USDT-SWAP\n-            instrument_type = 'swap'\n-\n-        _exchange_info[OKEX]['instrument_type'][symbol] = instrument_type\n-\n-    return symbols\n-\n-\n-def okex_compute_option_urls_from_underlyings() -> List[str]:\n-    url = 'https://www.okex.com/api/option/v3/underlying'\n-    r = None\n-    try:\n-        r = requests.get(url)\n-        return [f'https://www.okex.com/api/option/v3/instruments/{underlying}' for underlying in r.json()]\n-    except Exception as why:\n-        raise_failure_explanation('OKEX', why, {url: r})\n-\n-\n-def okex_symbols_from_one_url(url: str) -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get(url)\n-        ret = {}\n-        for e in r.json():\n-            ret[e['instrument_id']] = e['instrument_id']\n-            _exchange_info[OKEX]['tick_size'][e['instrument_id']] = e['tick_size']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('OKEX', why, {url: r})\n-\n-\n-def bittrex_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.bittrex.com/api/v1.1/public/getmarkets')\n-        r = r.json()['result']\n-        return {f\"{e['MarketCurrency']}{SYMBOL_SEP}{e['BaseCurrency']}\": e['MarketName'] for e in r if e['IsActive']}\n-    except Exception as why:\n-        raise_failure_explanation('BITTREX', why, {\"\": r})\n-\n-\n-def bitcoincom_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.exchange.bitcoin.com/api/2/public/symbol')\n-        return {f\"{data['baseCurrency']}{SYMBOL_SEP}{data['quoteCurrency'].replace('USD', 'USDT')}\": data['id'] for data in r.json()}\n-    except Exception as why:\n-        raise_failure_explanation('BITCOINCOM', why, {\"\": r})\n-\n-\n-def bitmax_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://bitmax.io/api/pro/v1/products')\n-        ret = {}\n-        for entry in r.json()['data']:\n-            # Only \"Normal\" status symbols are tradeable\n-            if entry['status'] == 'Normal':\n-                normalized = f\"{entry['baseAsset']}{SYMBOL_SEP}{entry['quoteAsset']}\"\n-                ret[normalized] = entry['symbol']\n-                _exchange_info[BITMAX]['tick_size'][normalized] = entry['tickSize']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('BITMAX', why, {\"\": r})\n-\n-\n-def upbit_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.upbit.com/v1/market/all')\n-        return {f\"{data['market'].split('-')[1]}{SYMBOL_SEP}{data['market'].split('-')[0]}\": data['market'] for data in r.json()}\n-    except Exception as why:\n-        raise_failure_explanation('UPBIT', why, {\"\": r})\n-\n-\n-def blockchain_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get(\"https://api.blockchain.com/mercury-gateway/v1/instruments\")\n-        return {data[\"symbol\"].replace(\"-\", SYMBOL_SEP): data[\"symbol\"] for data in r.json()}\n-    except Exception as why:\n-        raise_failure_explanation('BLOCKCHAIN', why, {\"\": r})\n-\n-\n-def gateio_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get(\"https://api.gateio.ws/api/v4/spot/currency_pairs\")\n-        return {data[\"id\"].replace(\"_\", SYMBOL_SEP): data['id'] for data in r.json()}\n-    except Exception as why:\n-        raise_failure_explanation('GATEIO', why, {\"\": r})\n-\n-\n-def bitmex_symbols() -> Dict[str, str]:\n-    r = None\n-    ret = {}\n-    try:\n-        r = requests.get(\"https://www.bitmex.com/api/v1/instrument/active\")\n-        for entry in r.json():\n-            components = []\n-            components.append(entry['rootSymbol'])\n-            components.append(entry['quoteCurrency'])\n-\n-            if entry['expiry']:\n-                components.append(entry['symbol'][-3:])\n-\n-            normalized = SYMBOL_SEP.join(components)\n-            normalized = normalized.replace(\"XBT\", \"BTC\")\n-            ret[normalized] = entry['symbol']\n-            _exchange_info[BITMEX]['tick_size'][normalized] = entry['tickSize']\n-\n-            if entry['expiry']:\n-                _exchange_info[BITMEX]['expiry'][normalized] = entry['expiry']\n-\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('BITMEX', why, {\"\": r})\n-\n-\n-def deribit_symbols() -> Dict[str, str]:\n-    url = r = None\n-    ret = {}\n-    try:\n-        # TODO: get currencies from https://www.deribit.com/api/v2/public/get_currencies\n-        currencies = ['BTC', 'ETH']\n-        for c in currencies:\n-            url = f\"https://www.deribit.com/api/v2/public/get_instruments?currency={c}&expired=false\"\n-            r = requests.get(url)\n-            for entry in r.json()['result']:\n-                split = entry['instrument_name'].split(\"-\")\n-                normalized = split[0] + SYMBOL_SEP + entry['quote_currency'] + \"-\" + '-'.join(split[1:])\n-                ret[normalized] = entry['instrument_name']\n-                _exchange_info[DERIBIT]['tick_size'][normalized] = entry['tick_size']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('DERIBIT', why, {url: r})\n-\n-\n-def kraken_future_symbols() -> Dict[str, str]:\n-    r = None\n-    ret = {}\n-    try:\n-        r = requests.get('https://futures.kraken.com/derivatives/api/v3/instruments')\n-        data = r.json()['instruments']\n-        for entry in data:\n-            if not entry['tradeable']:\n-                continue\n-            normalized = entry['symbol'].upper().replace(\"_\", \"-\")\n-            symbol = normalized[3:6] + SYMBOL_SEP + normalized[6:9]\n-            normalized = normalized.replace(normalized[3:9], symbol)\n-            normalized = normalized.replace('XBT', 'BTC')\n-\n-            _exchange_info[KRAKEN_FUTURES]['tick_size'][normalized] = entry['tickSize']\n-            _exchange_info[KRAKEN_FUTURES]['contract_size'][normalized] = entry['contractSize']\n-            _exchange_info[KRAKEN_FUTURES]['underlying'][normalized] = entry['underlying']\n-            _exchange_info[KRAKEN_FUTURES]['product_type'][normalized] = _kraken_futures_product_type[normalized[:2]]\n-            ret[normalized] = entry['symbol']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('KRAKEN_FUTURES', why, {\"\": r})\n-\n-\n-def probit_symbols() -> Dict[str, str]:\n-    # doc: https://docs-en.probit.com/reference-link/market\n-    r = None\n-    try:\n-        r = requests.get('https://api.probit.com/api/exchange/v1/market')\n-        return {entry['id']: entry['id'] for entry in r.json()['data']}\n-    except Exception as why:\n-        raise_failure_explanation('PROBIT', why, {\"\": r})\n-\n-\n-def coingecko_normalize_symbol(symbol: str) -> str:\n-    # keep digits, letters and dots, replace others by space\n-    symbol = ''.join(c if c.isalnum() or c in ('.', '+') else ' ' for c in symbol)\n-    return coingecko_normalize(symbol.upper())\n-\n-\n-def coingecko_normalize_name(name: str) -> str:\n-    # keep digits and letters, replace others by space (except when only composed by upper case letters, digits and dots)\n-    if not all(c.isupper() or c.isdigit() or c == '.' for c in name):\n-        name = ''.join(c if c.isalnum() else ' ' for c in name)\n-    return coingecko_normalize(name)\n-\n-\n-def coingecko_normalize(sym: str) -> str:\n-    sym = sym.strip()\n-    # do not concatenate numbers => separate them with a dot\n-    sym = list(sym)\n-    if len(sym) > 4:\n-        for i in range(2, len(sym) - 1):\n-            if sym[i] == ' ' and sym[i - 1].isdigit() and sym[i + 1].isdigit():\n-                sym[i] = '.'\n-    sym = ''.join(sym)\n-    # concatenate space-separated words => use CamelCase to distinguish the words\n-    if ' ' in sym:\n-        if sum(c.islower() for c in sym):  # if there is at least one lower case letter\n-            sym = ' '.join(word[0].upper() + word[1:] for word in sym.split())  # Just capitalize initial letter of each word\n-        else:  # CoinGecko may provide full upper-case as for \"THE STONE COIN\"\n-            sym = string.capwords(sym)  # capwords converts \"THE STONE COIN\" to \"The Stone Coin\"\n-        sym = sym.replace(' ', '')  # concatenate words\n-    return sym\n-\n-\n-def is_name_short(coin: dict) -> bool:\n-    \"\"\"return True if the coin name is enough short compared to the coin symbol.\"\"\"\n-    return len(coin['name']) <= max(5, len(coin['symbol']) + 1)\n-\n-\n-def has_many_caps(name: str) -> bool:\n-    \"\"\"return True if the symbol contains enough upper case letters, False if empty.\"\"\"\n-    return str and sum(c.islower() for c in name) < (len(name) / 2)\n-\n-\n-def coingecko_normalize_all(coin: dict):\n-    SYMBOL_TO_NORMALIZED = {'miota': 'IOTA'}\n-    normalized = SYMBOL_TO_NORMALIZED.get(coin['symbol'])\n-    if normalized:\n-        coin['ns'] = coin['nn'] = normalized\n-        return normalized\n-\n-    # ns = normalized symbol, nn = normalized name\n-    coin['ns'] = coingecko_normalize_symbol(coin['symbol'])\n-\n-    ID_SUFFIX = '-bitcoin-token'\n-    if coin['id'][-len(ID_SUFFIX):] == ID_SUFFIX:\n-        coin['nn'] = 'BTC' + coin['ns']\n-        return coin['nn']\n-\n-    name = coin['name']\n-\n-    prefixes = ('The ', 'the ')\n-    for p in prefixes:\n-        if name[:len(p)] == p:\n-            coin['reduced-name'] = True\n-            name = name[len(p):]\n-            break\n-\n-    suffixes = ('coin', 'coins', 'money', 'finance', 'protocol', 'reward', 'rewards', 'token')\n-    for s in suffixes:\n-        if len(name) > len(s) and name[-len(s):].lower() == s:\n-            # but keep suffix when lower-case concatenated\n-            if name[-len(s)].islower() and name[-len(s) - 1] != ' ':\n-                continue\n-            # also keep suffix to avoid confusing nam: \"Bitcoin Token\" -> \"Bitcoin\"\n-            if name[:-len(s)].strip().lower() == 'bitcoin':\n-                continue\n-            coin['reduced-name'] = True\n-            name = name[:-len(s)]\n-            break\n-\n-    coin['nn'] = coingecko_normalize_name(name)\n-\n-    if len(coin['nn']) < len(coin['ns']):\n-        if 'reduced-name' in coin:\n-            coin['reduced-name'] = False\n-            name = coin['name']\n-            coin['nn'] = coingecko_normalize_name(name)\n-        elif not has_many_caps(name):\n-            return coin['ns']\n-\n-    if not coin['ns']:  # coin['symbol'] may be an emoji that is striped when normalized\n-        return coin['nn']\n-\n-    if coin.get('reduced-name') and coin['ns'].upper() != coin['nn'].upper():\n-        return coin['ns']\n-\n-    i = coin['nn'].find('.')  # if there is a dot in normalized name => prefer the normalized symbol\n-    if i >= 0:\n-        if i > 1 and coin['nn'][i - 1].isdigit() and coin['nn'][i + 1].isdigit():\n-            pass  # except when the dot separates digits\n-        else:\n-            return coin['ns']\n-\n-    if is_name_short(coin) and has_many_caps(name):\n-        return coin['nn']\n-\n-    if 1.5 * len(coin['ns']) > len(coin['nn']) and any(c.islower() for c in coin['ns']):\n-        return coin['nn']\n-\n-    return coin['ns']\n-\n-\n-def coingecko_symbols() -> Dict[str, str]:\n-    r = None\n-    intermediate = defaultdict(list)\n-    try:\n-        r = requests.get('https://api.coingecko.com/api/v3/coins/list')\n-        all_coins = r.json()\n-        # First pass: generate & compare normalized symbol/name, and then select the most pertinent\n-        for coin in all_coins:\n-            normalized = coingecko_normalize_all(coin)\n-            intermediate[normalized].append(coin)\n-            # Above line keeps together the coins having the same normalized symbol.\n-            # To reduce collision, the coin['name'] is sometimes used in lieu of the coin['symbol'].\n-            # The coin['name'] is not capitalized because lower case letters may be meaningful: cETH, yUSD, DATx, zLOT\n-    except Exception as why:\n-        raise_failure_explanation('COINGECKO', why, {\"\": r})\n-\n-    final = coingecko_second_pass(intermediate)\n-    return coingecko_third_pass(final)\n-\n-\n-def coingecko_second_pass(intermediate: Dict[str, List[dict]]) -> Dict[str, List[dict]]:\n-    # Second pass: fixes most of the symbol collisions\n-    final = defaultdict(list)\n-    for normalized, coins in intermediate.items():\n-        if len(coins) == 1:\n-            final[normalized].append(coins[0])\n-            continue\n-        set_normalized = False\n-        for i in range(len(coins)):\n-            if normalized == coins[i]['nn']:\n-                coin = coins.pop(i)\n-                final[normalized].append(coin)\n-                set_normalized = True\n-                break\n-        rest: List[dict] = []\n-        for coin in coins:\n-            if '%' in coin['name']:\n-                if len(coins) == 1:\n-                    n = coin['ns']\n-                else:\n-                    n = coingecko_normalize_name(coin['id'])\n-                final[n].append(coin)\n-            else:\n-                rest.append(coin)\n-        if not rest:\n-            continue\n-        if not set_normalized:\n-            rest.sort(key=lambda coin: len(coin['nn']), reverse=True)  # sort by the length of the normalized name\n-            coin = rest.pop(0)\n-            final[normalized].append(coin)\n-        for coin in rest:\n-            if coin['nn'] not in intermediate:\n-                n = coin['nn']\n-            elif coin.get('reduced-name'):\n-                n = coingecko_normalize_name(coin['name'])\n-            else:\n-                n = coingecko_normalize_name(coin['id'])\n-            final[n].append(coin)\n-    return final\n-\n-\n-def coingecko_third_pass(final: Dict[str, List[dict]]) -> Dict[str, str]:\n-    # Third pass: fixes some remaining collisions and fills the result\n-    symbols = {}\n-    for normalized, coins in final.items():\n-        if len(coins) == 1:\n-            symbols[normalized] = coins[0]['id']\n-            continue\n-        set_normalized = False\n-        for i in range(len(coins)):\n-            if normalized == coins[i]['nn']:\n-                coin = coins.pop(i)\n-                symbols[normalized] = coin['id']\n-                set_normalized = True\n-                break\n-        rest: List[dict] = []\n-        for coin in coins:\n-            if '%' in coin['name']:\n-                if len(coins) == 1:\n-                    n = coin['ns']\n-                else:\n-                    n = coingecko_normalize_name(coin['id'])\n-                symbols[n] = coin['id']\n-            else:\n-                rest.append(coin)\n-        if not rest:\n-            continue\n-        if not set_normalized:\n-            rest.sort(key=lambda coin: len(coin['nn']), reverse=True)  # sort by the length of the normalized name\n-            coin = rest.pop(0)\n-            symbols[normalized] = coin['id']\n-        for coin in rest:\n-            if coin['nn'] not in final:\n-                n = coin['nn']\n-            elif coin.get('reduced-name'):\n-                n = coingecko_normalize_name(coin['name'])\n-            else:\n-                n = coingecko_normalize_name(coin['id'])\n-            symbols[n] = coin['id']\n-    return symbols\n-\n-\n-def whale_alert_coins(key_id: str) -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get(f'https://api.whale-alert.io/v1/status?api_key={key_id}')\n-        # Same symbols, but on different blockchains (for instance USDT), are naturally overwritten.\n-        return {s.upper(): s for b in r.json()['blockchains'] for s in b['symbols'] if s}\n-    except Exception as why:\n-        raise_failure_explanation('WHALES_ALERT', why, {\"\": r})\n-\n-\n-_exchange_function_map = {\n-    BITFINEX: bitfinex_symbols,\n-    BITFLYER: bitflyer_symbols,\n-    COINBASE: coinbase_symbols,\n-    GEMINI: gemini_symbols,\n-    HITBTC: hitbtc_symbols,\n-    POLONIEX: poloniex_symbols,\n-    PROBIT: probit_symbols,\n-    BITSTAMP: bitstamp_symbols,\n-    KRAKEN: kraken_symbols,\n-    KRAKEN + 'REST': kraken_rest_symbols,\n-    BINANCE: binance_symbols,\n-    BINANCE_US: binance_us_symbols,\n-    BINANCE_FUTURES: binance_futures_symbols,\n-    BINANCE_DELIVERY: binance_delivery_symbols,\n-    BLOCKCHAIN: blockchain_symbols,\n-    EXX: exx_symbols,\n-    HUOBI: huobi_symbols,\n-    HUOBI_DM: huobi_dm_symbols,\n-    HUOBI_SWAP: huobi_swap_symbols,\n-    OKCOIN: okcoin_symbols,\n-    OKEX: okex_symbols,\n-    BYBIT: bybit_symbols,\n-    FTX: ftx_symbols,\n-    FTX_US: ftx_us_symbols,\n-    BITTREX: bittrex_symbols,\n-    BITCOINCOM: bitcoincom_symbols,\n-    BITMAX: bitmax_symbols,\n-    UPBIT: upbit_symbols,\n-    GATEIO: gateio_symbols,\n-    BITMEX: bitmex_symbols,\n-    DERIBIT: deribit_symbols,\n-    KRAKEN_FUTURES: kraken_future_symbols,\n-    COINGECKO: coingecko_symbols,\n-    WHALE_ALERT: whale_alert_coins\n-}\n+Symbols = _Symbols()\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\n\nimport logging\nimport string\nimport time\nfrom collections import defaultdict\nfrom typing import Dict, List, Optional, Tuple\n\nimport requests\nfrom requests import Response\n\nfrom cryptofeed.defines import *\n\n\nLOG = logging.getLogger('feedhandler')\n\nSYMBOL_SEP = '-'\n\n_symbols_retrieval_cache: Dict[str, Dict[str, str]] = {}\n_exchange_info = defaultdict(lambda: defaultdict(dict))\n\n\n_kraken_futures_product_type = {\n    'FI': 'Inverse Futures',\n    'FV': 'Vanilla Futures',\n    'PI': 'Perpetual Inverse Futures',\n    'PV': 'Perpetual Vanilla Futures',\n    'IN': 'Real Time Index',\n    'RR': 'Reference Rate',\n}\n\n\ndef raise_failure_explanation(feed_id: str, exception: BaseException, responses: Dict[str, Optional[Response]]):\n    <IND>LOG.critical('%s: encountered %r while processing response from exchange API', feed_id, exception)\n    if len(responses) > 1:\n        <IND>LOG.critical('%s: content of one of the %s responses was unexpected', feed_id, len(responses))\n    <DED>for url, r in responses.items():\n        <IND>if url:\n            <IND>LOG.critical('%s: requested URL: %s', feed_id, url)\n        <DED>if r:\n            <IND>LOG.critical('%s: unexpected response: %s', feed_id, r.text)\n    <DED><DED>raise ValueError(f'Cryptofeed stopped because of an unexpected response from {feed_id}') from exception\n\n\n<DED>def set_symbol_separator(separator: str):\n    <IND>global SYMBOL_SEP\n    SYMBOL_SEP = separator\n\n\n<DED>def get_symbol_separator() -> str:\n    <IND>global SYMBOL_SEP\n    return SYMBOL_SEP\n\n\n<DED>def gen_symbols(exchange: str, key_id=None) -> Dict[str, str]:\n    <IND>if exchange not in _symbols_retrieval_cache:\n        <IND>LOG.info(\"%s: Getting list of symbols\", exchange)\n        symbols = _exchange_function_map[exchange](key_id) if key_id else _exchange_function_map[exchange]()\n        LOG.info(\"%s: %s symbols\", exchange, len(symbols))\n\n        # log all retrieved symbols using debug level\n        for normalized, exch_sym in sorted(symbols.items()):\n            <IND>LOG.debug('%s: id-from-exch -> normalized: %-35s-> %s', exchange, exch_sym, normalized)\n\n        <DED>_symbols_retrieval_cache[exchange] = symbols\n    <DED>return _symbols_retrieval_cache[exchange]\n\n\n<DED>def _binance_symbols(endpoint: str, exchange: str):\n    <IND>r = None\n    try:\n        <IND>ret = {}\n        r = requests.get(endpoint)\n        for symbol in r.json()['symbols']:\n            <IND>if symbol.get('status', 'TRADING') != \"TRADING\":\n                <IND>continue\n            <DED>if symbol.get('contractStatus', 'TRADING') != \"TRADING\":\n                <IND>continue\n            <DED>split = len(symbol['baseAsset'])\n            normalized = symbol['symbol'][:split] + SYMBOL_SEP + symbol['symbol'][split:]\n            ret[normalized] = symbol['symbol']\n            _exchange_info[exchange]['tick_size'][normalized] = symbol['filters'][0]['tickSize']\n            if \"contractType\" in symbol:\n                <IND>_exchange_info[exchange]['contract_type'][normalized] = symbol['contractType']\n        <DED><DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation(exchange, why, {endpoint: r})\n\n\n<DED><DED>def binance_symbols() -> Dict[str, str]:\n    <IND>return _binance_symbols('https://api.binance.com/api/v3/exchangeInfo', BINANCE)\n\n\n<DED>def binance_us_symbols() -> Dict[str, str]:\n    <IND>return _binance_symbols('https://api.binance.us/api/v3/exchangeInfo', BINANCE_US)\n\n\n<DED>def binance_futures_symbols() -> Dict[str, str]:\n    <IND>base = _binance_symbols('https://fapi.binance.com/fapi/v1/exchangeInfo', BINANCE_FUTURES)\n    add = {}\n    for symbol, orig in base.items():\n        <IND>if \"_\" in orig:\n            <IND>continue\n        <DED>add[f\"{symbol}-PINDEX\"] = f\"p{orig}\"\n    <DED>base.update(add)\n    return base\n\n\n<DED>def binance_delivery_symbols() -> Dict[str, str]:\n    <IND>return _binance_symbols('https://dapi.binance.com/dapi/v1/exchangeInfo', BINANCE_DELIVERY)\n\n\n<DED>def bitfinex_symbols() -> Dict[str, str]:\n    # doc: https://docs.bitfinex.com/docs/ws-general#supported-pairs\n    <IND>r1 = r2 = None\n    try:\n        <IND>r1 = requests.get('https://api.bitfinex.com/v2/tickers?symbols=ALL')\n        r2 = requests.get('https://api-pub.bitfinex.com/v2/conf/pub:map:currency:sym')\n        tickers: List[List[str]] = r1.json()\n        norm: List[Tuple[str, str]] = r2.json()[0]\n        norm: Dict[str, str] = dict(norm)\n        for k, v in dict(norm).items():\n            <IND>if k[-2:] == 'F0' or '-' in v:  # Do not convert BTCF0 -> BTC or PBTCETH -> PBTC-ETH\n                <IND>del norm[k]\n        <DED><DED>norm['BCHN'] = 'BCH'  # Bitfinex uses BCHN, other exchanges use BCH\n\n        ret = {}\n        for symbol in [t[0] for t in tickers]:\n            <IND>if symbol[0] == 'f':\n                <IND>normalized = norm.get(symbol[1:], symbol[1:])\n            <DED>else:\n                <IND>if len(symbol) == 7:\n                    <IND>base, quote = symbol[1:4], symbol[4:]\n                <DED>else:\n                    <IND>base, quote = symbol[1:].split(':')\n                    assert ':' in symbol\n                <DED>normalized = norm.get(base, base) + SYMBOL_SEP + norm.get(quote, quote)\n            <DED>ret[normalized.upper()] = symbol\n        <DED>return ret\n    <DED>except ValueError as why:\n        <IND>raise_failure_explanation('BITFINEX', why, {\"tickers?symbols=ALL\": r1, \"pub:map:currency:sym\": r2})\n\n\n<DED><DED>def bitflyer_symbols() -> Dict[str, str]:\n    <IND>endpoint = r = None\n    try:\n        <IND>ret = {}\n        endpoints = ['https://api.bitflyer.com/v1/getmarkets/eu', 'https://api.bitflyer.com/v1/getmarkets/usa', 'https://api.bitflyer.com/v1/getmarkets']\n        for endpoint in endpoints:\n            <IND>r = requests.get(endpoint)\n            for entry in r.json():\n                <IND>normalized = entry['product_code'].replace(\"_\", SYMBOL_SEP)\n                ret[normalized] = entry['product_code']\n        <DED><DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BITFLYER', why, {endpoint: r})\n\n\n<DED><DED>def bybit_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.bybit.com/v2/public/symbols')\n        ret = {}\n        for symbol in r.json()['result']:\n            <IND>quote = symbol['quote_currency']\n            if not symbol['name'].endswith(quote):\n                <IND>base, contract = symbol['name'].split(quote)\n                normalized = f\"{base}{SYMBOL_SEP}{quote}-{contract}\"\n            <DED>else:\n                <IND>normalized = f\"{symbol['base_currency']}{SYMBOL_SEP}{quote}\"\n            <DED>ret[normalized] = symbol['name']\n            _exchange_info[BYBIT]['tick_size'][normalized] = symbol['price_filter']['tick_size']\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BYBIT', why, {\"\": r})\n\n\n<DED><DED>def _ftx_helper(endpoint: str, exchange: str):\n    <IND>r = None\n    try:\n        <IND>r = requests.get(endpoint)\n        ret = {}\n        for data in r.json()['result']:\n            <IND>normalized = data['name'].replace(\"/\", SYMBOL_SEP)\n            symbol = data['name']\n            ret[normalized] = symbol\n            _exchange_info[exchange]['tick_size'][normalized] = data['priceIncrement']\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation(exchange, why, {endpoint: r})\n\n\n<DED><DED>def ftx_symbols() -> Dict[str, str]:\n    <IND>return _ftx_helper('https://ftx.com/api/markets', FTX)\n\n\n<DED>def ftx_us_symbols() -> Dict[str, str]:\n    <IND>return _ftx_helper('https://ftx.us/api/markets', FTX_US)\n\n\n<DED>def coinbase_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.pro.coinbase.com/products')\n        ret = {}\n        for data in r.json():\n            <IND>normalized = data['id'].replace(\"-\", SYMBOL_SEP)\n            ret[normalized] = data['id']\n            _exchange_info[COINBASE]['tick_size'][normalized] = data['quote_increment']\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('COINBASE', why, {\"\": r})\n\n\n<DED><DED>def gemini_symbols(*args) -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.gemini.com/v1/symbols')\n        ret = {}\n        for symbol in r.json():\n            <IND>std = f\"{symbol[:-3]}{SYMBOL_SEP}{symbol[-3:]}\"\n            std = std.upper()\n            ret[std] = symbol.upper()\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('GEMINI', why, {\"\": r})\n\n\n<DED><DED>def hitbtc_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>ret = {}\n        r = requests.get('https://api.hitbtc.com/api/2/public/symbol')\n        for symbol in r.json():\n            <IND>split = len(symbol['baseCurrency'])\n            normalized = symbol['id'][:split] + SYMBOL_SEP + symbol['id'][split:]\n            ret[normalized] = symbol['id']\n            _exchange_info[HITBTC]['tick_size'][normalized] = symbol['tickSize']\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('HITBTC', why, {\"\": r})\n\n\n<DED><DED>def poloniex_id_symbol_mapping():\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://poloniex.com/public?command=returnTicker')\n        symbols = r.json()\n        ret = {}\n        for symbol in symbols:\n            <IND>ret[symbols[symbol]['id']] = symbol\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('POLONIEX', why, {\"\": r})\n\n\n<DED><DED>def poloniex_symbols() -> Dict[str, str]:\n    <IND>ret = {}\n    for _, value in poloniex_id_symbol_mapping().items():\n        <IND>std = value.replace(\"STR\", \"XLM\")\n        quote, base = std.split(\"_\")\n        ret[quote + SYMBOL_SEP + base] = value\n    <DED>return ret\n\n\n<DED>def bitstamp_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://www.bitstamp.net/api/v2/trading-pairs-info/')\n        ret = {}\n        for data in r.json():\n            <IND>normalized = data['name'].replace(\"/\", SYMBOL_SEP)\n            symbol = data['url_symbol']\n            ret[normalized] = symbol\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BITSTAMP', why, {\"\": r})\n\n\n<DED><DED>def kraken_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.kraken.com/0/public/AssetPairs')\n        data = r.json()\n        ret = {}\n        for symbol in data['result']:\n            <IND>if 'wsname' not in data['result'][symbol] or '.d' in symbol:\n                # https://blog.kraken.com/post/259/introducing-the-kraken-dark-pool/\n                # .d is for dark pool symbols\n                <IND>continue\n\n            <DED>base, quote = data['result'][symbol]['wsname'].split(\"/\")\n\n            normalized = f\"{base}{SYMBOL_SEP}{quote}\"\n            exch = data['result'][symbol]['wsname']\n            normalized = normalized.replace('XBT', 'BTC')\n            normalized = normalized.replace('XDG', 'DOG')\n            ret[normalized] = exch\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('KRAKEN', why, {\"\": r})\n\n\n<DED><DED>def kraken_rest_symbols() -> Dict[str, str]:\n    <IND>return {normalized: exchange.replace(\"/\", \"\") for normalized, exchange in kraken_symbols().items()}\n\n\n<DED>def exx_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.exx.com/data/v1/tickers')\n        exchange = [key.upper() for key in r.json().keys()]\n        symbols = [key.replace(\"_\", SYMBOL_SEP) for key in exchange]\n        return dict(zip(symbols, exchange))\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('EXX', why, {\"\": r})\n\n\n<DED><DED>def huobi_common_symbols(url: str):\n    <IND>r = None\n    try:\n        <IND>r = requests.get(url)\n        ret = {}\n        for e in r.json()['data']:\n            <IND>if e['state'] == 'offline':\n                <IND>continue\n            <DED>normalized = f\"{e['base-currency'].upper()}{SYMBOL_SEP}{e['quote-currency'].upper()}\"\n            symbol = f\"{e['base-currency']}{e['quote-currency']}\"\n            ret[normalized] = symbol\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('HUOBI', why, {url: r})\n\n\n<DED><DED>def huobi_symbols() -> Dict[str, str]:\n    <IND>return huobi_common_symbols('https://api.huobi.pro/v1/common/symbols')\n\n\n<DED>def huobi_us_symbols() -> Dict[str, str]:\n    <IND>return huobi_common_symbols('https://api.huobi.com/v1/common/symbols')\n\n\n<DED>def huobi_dm_symbols() -> Dict[str, str]:\n    <IND>\"\"\"\n    Mapping is, for instance: {\"BTC_CW\":\"BTC190816\"}\n    See comments in exchange/huobi_dm.py\n    \"\"\"\n    mapping = {\n        \"this_week\": \"CW\",\n        \"next_week\": \"NW\",\n        \"quarter\": \"CQ\",\n        \"next_quarter\": \"NQ\"\n    }\n    r = None\n    try:\n        <IND>r = requests.get('https://www.hbdm.com/api/v1/contract_contract_info')\n        symbols = {}\n        for e in r.json()['data']:\n            <IND>symbols[f\"{e['symbol']}_{mapping[e['contract_type']]}\"] = e['contract_code']\n            _exchange_info[HUOBI_DM]['tick_size'][e['contract_code']] = e['price_tick']\n            _exchange_info[HUOBI_DM]['short_code_mappings'][f\"{e['symbol']}_{mapping[e['contract_type']]}\"] = e['contract_code']\n        <DED>return symbols\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('HUOBI_DM', why, {\"\": r})\n\n\n<DED><DED>def huobi_swap_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.hbdm.com/swap-api/v1/swap_contract_info')\n        symbols = {}\n        for e in r.json()['data']:\n            <IND>symbols[e['contract_code']] = e['contract_code']\n            _exchange_info[HUOBI_SWAP]['tick_size'][e['contract_code']] = e['price_tick']\n        <DED>return symbols\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('HUOBI_SWAP', why, {\"\": r})\n\n\n<DED><DED>def okcoin_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://www.okcoin.com/api/spot/v3/instruments')\n        ret = {}\n        for e in r.json():\n            <IND>ret[e['instrument_id']] = e['instrument_id']\n            _exchange_info[OKCOIN]['tick_size'][e['instrument_id']] = e['tick_size']\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('OKCOIN', why, {\"\": r})\n\n\n<DED><DED>def okex_symbols(*args) -> Dict[str, str]:\n    <IND>urls = ['https://www.okex.com/api/spot/v3/instruments',\n            'https://www.okex.com/api/swap/v3/instruments',\n            'https://www.okex.com/api/futures/v3/instruments']\n    urls = urls + okex_compute_option_urls_from_underlyings()\n\n    symbols: Dict[str, str] = {}\n    for u in urls:\n        <IND>time.sleep(0.2)\n        symbols.update(okex_symbols_from_one_url(u))\n\n    <DED>for symbol in symbols:\n        <IND>instrument_type = 'futures'\n        dash_count = symbol.count(get_symbol_separator())\n        if dash_count == 1:  # BTC-USDT\n            <IND>instrument_type = 'spot'\n        <DED>if dash_count == 4:  # BTC-USD-201225-35000-P\n            <IND>instrument_type = 'option'\n        <DED>if symbol[-4:] == \"SWAP\":  # BTC-USDT-SWAP\n            <IND>instrument_type = 'swap'\n\n        <DED>_exchange_info[OKEX]['instrument_type'][symbol] = instrument_type\n\n    <DED>return symbols\n\n\n<DED>def okex_compute_option_urls_from_underlyings() -> List[str]:\n    <IND>url = 'https://www.okex.com/api/option/v3/underlying'\n    r = None\n    try:\n        <IND>r = requests.get(url)\n        return [f'https://www.okex.com/api/option/v3/instruments/{underlying}' for underlying in r.json()]\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('OKEX', why, {url: r})\n\n\n<DED><DED>def okex_symbols_from_one_url(url: str) -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get(url)\n        ret = {}\n        for e in r.json():\n            <IND>ret[e['instrument_id']] = e['instrument_id']\n            _exchange_info[OKEX]['tick_size'][e['instrument_id']] = e['tick_size']\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('OKEX', why, {url: r})\n\n\n<DED><DED>def bittrex_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.bittrex.com/api/v1.1/public/getmarkets')\n        r = r.json()['result']\n        return {f\"{e['MarketCurrency']}{SYMBOL_SEP}{e['BaseCurrency']}\": e['MarketName'] for e in r if e['IsActive']}\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BITTREX', why, {\"\": r})\n\n\n<DED><DED>def bitcoincom_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.exchange.bitcoin.com/api/2/public/symbol')\n        return {f\"{data['baseCurrency']}{SYMBOL_SEP}{data['quoteCurrency'].replace('USD', 'USDT')}\": data['id'] for data in r.json()}\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BITCOINCOM', why, {\"\": r})\n\n\n<DED><DED>def bitmax_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://bitmax.io/api/pro/v1/products')\n        ret = {}\n        for entry in r.json()['data']:\n            # Only \"Normal\" status symbols are tradeable\n            <IND>if entry['status'] == 'Normal':\n                <IND>normalized = f\"{entry['baseAsset']}{SYMBOL_SEP}{entry['quoteAsset']}\"\n                ret[normalized] = entry['symbol']\n                _exchange_info[BITMAX]['tick_size'][normalized] = entry['tickSize']\n        <DED><DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BITMAX', why, {\"\": r})\n\n\n<DED><DED>def upbit_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.upbit.com/v1/market/all')\n        return {f\"{data['market'].split('-')[1]}{SYMBOL_SEP}{data['market'].split('-')[0]}\": data['market'] for data in r.json()}\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('UPBIT', why, {\"\": r})\n\n\n<DED><DED>def blockchain_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get(\"https://api.blockchain.com/mercury-gateway/v1/instruments\")\n        return {data[\"symbol\"].replace(\"-\", SYMBOL_SEP): data[\"symbol\"] for data in r.json()}\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BLOCKCHAIN', why, {\"\": r})\n\n\n<DED><DED>def gateio_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get(\"https://api.gateio.ws/api/v4/spot/currency_pairs\")\n        return {data[\"id\"].replace(\"_\", SYMBOL_SEP): data['id'] for data in r.json()}\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('GATEIO', why, {\"\": r})\n\n\n<DED><DED>def bitmex_symbols() -> Dict[str, str]:\n    <IND>r = None\n    ret = {}\n    try:\n        <IND>r = requests.get(\"https://www.bitmex.com/api/v1/instrument/active\")\n        for entry in r.json():\n            <IND>components = []\n            components.append(entry['rootSymbol'])\n            components.append(entry['quoteCurrency'])\n\n            if entry['expiry']:\n                <IND>components.append(entry['symbol'][-3:])\n\n            <DED>normalized = SYMBOL_SEP.join(components)\n            normalized = normalized.replace(\"XBT\", \"BTC\")\n            ret[normalized] = entry['symbol']\n            _exchange_info[BITMEX]['tick_size'][normalized] = entry['tickSize']\n\n            if entry['expiry']:\n                <IND>_exchange_info[BITMEX]['expiry'][normalized] = entry['expiry']\n\n        <DED><DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BITMEX', why, {\"\": r})\n\n\n<DED><DED>def deribit_symbols() -> Dict[str, str]:\n    <IND>url = r = None\n    ret = {}\n    try:\n        # TODO: get currencies from https://www.deribit.com/api/v2/public/get_currencies\n        <IND>currencies = ['BTC', 'ETH']\n        for c in currencies:\n            <IND>url = f\"https://www.deribit.com/api/v2/public/get_instruments?currency={c}&expired=false\"\n            r = requests.get(url)\n            for entry in r.json()['result']:\n                <IND>split = entry['instrument_name'].split(\"-\")\n                normalized = split[0] + SYMBOL_SEP + entry['quote_currency'] + \"-\" + '-'.join(split[1:])\n                ret[normalized] = entry['instrument_name']\n                _exchange_info[DERIBIT]['tick_size'][normalized] = entry['tick_size']\n        <DED><DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('DERIBIT', why, {url: r})\n\n\n<DED><DED>def kraken_future_symbols() -> Dict[str, str]:\n    <IND>r = None\n    ret = {}\n    try:\n        <IND>r = requests.get('https://futures.kraken.com/derivatives/api/v3/instruments')\n        data = r.json()['instruments']\n        for entry in data:\n            <IND>if not entry['tradeable']:\n                <IND>continue\n            <DED>normalized = entry['symbol'].upper().replace(\"_\", \"-\")\n            symbol = normalized[3:6] + SYMBOL_SEP + normalized[6:9]\n            normalized = normalized.replace(normalized[3:9], symbol)\n            normalized = normalized.replace('XBT', 'BTC')\n\n            _exchange_info[KRAKEN_FUTURES]['tick_size'][normalized] = entry['tickSize']\n            _exchange_info[KRAKEN_FUTURES]['contract_size'][normalized] = entry['contractSize']\n            _exchange_info[KRAKEN_FUTURES]['underlying'][normalized] = entry['underlying']\n            _exchange_info[KRAKEN_FUTURES]['product_type'][normalized] = _kraken_futures_product_type[normalized[:2]]\n            ret[normalized] = entry['symbol']\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('KRAKEN_FUTURES', why, {\"\": r})\n\n\n<DED><DED>def probit_symbols() -> Dict[str, str]:\n    # doc: https://docs-en.probit.com/reference-link/market\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.probit.com/api/exchange/v1/market')\n        return {entry['id']: entry['id'] for entry in r.json()['data']}\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('PROBIT', why, {\"\": r})\n\n\n<DED><DED>def coingecko_normalize_symbol(symbol: str) -> str:\n    # keep digits, letters and dots, replace others by space\n    <IND>symbol = ''.join(c if c.isalnum() or c in ('.', '+') else ' ' for c in symbol)\n    return coingecko_normalize(symbol.upper())\n\n\n<DED>def coingecko_normalize_name(name: str) -> str:\n    # keep digits and letters, replace others by space (except when only composed by upper case letters, digits and dots)\n    <IND>if not all(c.isupper() or c.isdigit() or c == '.' for c in name):\n        <IND>name = ''.join(c if c.isalnum() else ' ' for c in name)\n    <DED>return coingecko_normalize(name)\n\n\n<DED>def coingecko_normalize(sym: str) -> str:\n    <IND>sym = sym.strip()\n    # do not concatenate numbers => separate them with a dot\n    sym = list(sym)\n    if len(sym) > 4:\n        <IND>for i in range(2, len(sym) - 1):\n            <IND>if sym[i] == ' ' and sym[i - 1].isdigit() and sym[i + 1].isdigit():\n                <IND>sym[i] = '.'\n    <DED><DED><DED>sym = ''.join(sym)\n    # concatenate space-separated words => use CamelCase to distinguish the words\n    if ' ' in sym:\n        <IND>if sum(c.islower() for c in sym):  # if there is at least one lower case letter\n            <IND>sym = ' '.join(word[0].upper() + word[1:] for word in sym.split())  # Just capitalize initial letter of each word\n        <DED>else:  # CoinGecko may provide full upper-case as for \"THE STONE COIN\"\n            <IND>sym = string.capwords(sym)  # capwords converts \"THE STONE COIN\" to \"The Stone Coin\"\n        <DED>sym = sym.replace(' ', '')  # concatenate words\n    <DED>return sym\n\n\n<DED>def is_name_short(coin: dict) -> bool:\n    <IND>\"\"\"return True if the coin name is enough short compared to the coin symbol.\"\"\"\n    return len(coin['name']) <= max(5, len(coin['symbol']) + 1)\n\n\n<DED>def has_many_caps(name: str) -> bool:\n    <IND>\"\"\"return True if the symbol contains enough upper case letters, False if empty.\"\"\"\n    return str and sum(c.islower() for c in name) < (len(name) / 2)\n\n\n<DED>def coingecko_normalize_all(coin: dict):\n    <IND>SYMBOL_TO_NORMALIZED = {'miota': 'IOTA'}\n    normalized = SYMBOL_TO_NORMALIZED.get(coin['symbol'])\n    if normalized:\n        <IND>coin['ns'] = coin['nn'] = normalized\n        return normalized\n\n    # ns = normalized symbol, nn = normalized name\n    <DED>coin['ns'] = coingecko_normalize_symbol(coin['symbol'])\n\n    ID_SUFFIX = '-bitcoin-token'\n    if coin['id'][-len(ID_SUFFIX):] == ID_SUFFIX:\n        <IND>coin['nn'] = 'BTC' + coin['ns']\n        return coin['nn']\n\n    <DED>name = coin['name']\n\n    prefixes = ('The ', 'the ')\n    for p in prefixes:\n        <IND>if name[:len(p)] == p:\n            <IND>coin['reduced-name'] = True\n            name = name[len(p):]\n            break\n\n    <DED><DED>suffixes = ('coin', 'coins', 'money', 'finance', 'protocol', 'reward', 'rewards', 'token')\n    for s in suffixes:\n        <IND>if len(name) > len(s) and name[-len(s):].lower() == s:\n            # but keep suffix when lower-case concatenated\n            <IND>if name[-len(s)].islower() and name[-len(s) - 1] != ' ':\n                <IND>continue\n            # also keep suffix to avoid confusing nam: \"Bitcoin Token\" -> \"Bitcoin\"\n            <DED>if name[:-len(s)].strip().lower() == 'bitcoin':\n                <IND>continue\n            <DED>coin['reduced-name'] = True\n            name = name[:-len(s)]\n            break\n\n    <DED><DED>coin['nn'] = coingecko_normalize_name(name)\n\n    if len(coin['nn']) < len(coin['ns']):\n        <IND>if 'reduced-name' in coin:\n            <IND>coin['reduced-name'] = False\n            name = coin['name']\n            coin['nn'] = coingecko_normalize_name(name)\n        <DED>elif not has_many_caps(name):\n            <IND>return coin['ns']\n\n    <DED><DED>if not coin['ns']:  # coin['symbol'] may be an emoji that is striped when normalized\n        <IND>return coin['nn']\n\n    <DED>if coin.get('reduced-name') and coin['ns'].upper() != coin['nn'].upper():\n        <IND>return coin['ns']\n\n    <DED>i = coin['nn'].find('.')  # if there is a dot in normalized name => prefer the normalized symbol\n    if i >= 0:\n        <IND>if i > 1 and coin['nn'][i - 1].isdigit() and coin['nn'][i + 1].isdigit():\n            <IND>pass  # except when the dot separates digits\n        <DED>else:\n            <IND>return coin['ns']\n\n    <DED><DED>if is_name_short(coin) and has_many_caps(name):\n        <IND>return coin['nn']\n\n    <DED>if 1.5 * len(coin['ns']) > len(coin['nn']) and any(c.islower() for c in coin['ns']):\n        <IND>return coin['nn']\n\n    <DED>return coin['ns']\n\n\n<DED>def coingecko_symbols() -> Dict[str, str]:\n    <IND>r = None\n    intermediate = defaultdict(list)\n    try:\n        <IND>r = requests.get('https://api.coingecko.com/api/v3/coins/list')\n        all_coins = r.json()\n        # First pass: generate & compare normalized symbol/name, and then select the most pertinent\n        for coin in all_coins:\n            <IND>normalized = coingecko_normalize_all(coin)\n            intermediate[normalized].append(coin)\n            # Above line keeps together the coins having the same normalized symbol.\n            # To reduce collision, the coin['name'] is sometimes used in lieu of the coin['symbol'].\n            # The coin['name'] is not capitalized because lower case letters may be meaningful: cETH, yUSD, DATx, zLOT\n    <DED><DED>except Exception as why:\n        <IND>raise_failure_explanation('COINGECKO', why, {\"\": r})\n\n    <DED>final = coingecko_second_pass(intermediate)\n    return coingecko_third_pass(final)\n\n\n<DED>def coingecko_second_pass(intermediate: Dict[str, List[dict]]) -> Dict[str, List[dict]]:\n    # Second pass: fixes most of the symbol collisions\n    <IND>final = defaultdict(list)\n    for normalized, coins in intermediate.items():\n        <IND>if len(coins) == 1:\n            <IND>final[normalized].append(coins[0])\n            continue\n        <DED>set_normalized = False\n        for i in range(len(coins)):\n            <IND>if normalized == coins[i]['nn']:\n                <IND>coin = coins.pop(i)\n                final[normalized].append(coin)\n                set_normalized = True\n                break\n        <DED><DED>rest: List[dict] = []\n        for coin in coins:\n            <IND>if '%' in coin['name']:\n                <IND>if len(coins) == 1:\n                    <IND>n = coin['ns']\n                <DED>else:\n                    <IND>n = coingecko_normalize_name(coin['id'])\n                <DED>final[n].append(coin)\n            <DED>else:\n                <IND>rest.append(coin)\n        <DED><DED>if not rest:\n            <IND>continue\n        <DED>if not set_normalized:\n            <IND>rest.sort(key=lambda coin: len(coin['nn']), reverse=True)  # sort by the length of the normalized name\n            coin = rest.pop(0)\n            final[normalized].append(coin)\n        <DED>for coin in rest:\n            <IND>if coin['nn'] not in intermediate:\n                <IND>n = coin['nn']\n            <DED>elif coin.get('reduced-name'):\n                <IND>n = coingecko_normalize_name(coin['name'])\n            <DED>else:\n                <IND>n = coingecko_normalize_name(coin['id'])\n            <DED>final[n].append(coin)\n    <DED><DED>return final\n\n\n<DED>def coingecko_third_pass(final: Dict[str, List[dict]]) -> Dict[str, str]:\n    # Third pass: fixes some remaining collisions and fills the result\n    <IND>symbols = {}\n    for normalized, coins in final.items():\n        <IND>if len(coins) == 1:\n            <IND>symbols[normalized] = coins[0]['id']\n            continue\n        <DED>set_normalized = False\n        for i in range(len(coins)):\n            <IND>if normalized == coins[i]['nn']:\n                <IND>coin = coins.pop(i)\n                symbols[normalized] = coin['id']\n                set_normalized = True\n                break\n        <DED><DED>rest: List[dict] = []\n        for coin in coins:\n            <IND>if '%' in coin['name']:\n                <IND>if len(coins) == 1:\n                    <IND>n = coin['ns']\n                <DED>else:\n                    <IND>n = coingecko_normalize_name(coin['id'])\n                <DED>symbols[n] = coin['id']\n            <DED>else:\n                <IND>rest.append(coin)\n        <DED><DED>if not rest:\n            <IND>continue\n        <DED>if not set_normalized:\n            <IND>rest.sort(key=lambda coin: len(coin['nn']), reverse=True)  # sort by the length of the normalized name\n            coin = rest.pop(0)\n            symbols[normalized] = coin['id']\n        <DED>for coin in rest:\n            <IND>if coin['nn'] not in final:\n                <IND>n = coin['nn']\n            <DED>elif coin.get('reduced-name'):\n                <IND>n = coingecko_normalize_name(coin['name'])\n            <DED>else:\n                <IND>n = coingecko_normalize_name(coin['id'])\n            <DED>symbols[n] = coin['id']\n    <DED><DED>return symbols\n\n\n<DED>def whale_alert_coins(key_id: str) -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get(f'https://api.whale-alert.io/v1/status?api_key={key_id}')\n        # Same symbols, but on different blockchains (for instance USDT), are naturally overwritten.\n        return {s.upper(): s for b in r.json()['blockchains'] for s in b['symbols'] if s}\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('WHALES_ALERT', why, {\"\": r})\n\n\n<DED><DED>_exchange_function_map = {\n    BITFINEX: bitfinex_symbols,\n    BITFLYER: bitflyer_symbols,\n    COINBASE: coinbase_symbols,\n    GEMINI: gemini_symbols,\n    HITBTC: hitbtc_symbols,\n    POLONIEX: poloniex_symbols,\n    PROBIT: probit_symbols,\n    BITSTAMP: bitstamp_symbols,\n    KRAKEN: kraken_symbols,\n    KRAKEN + 'REST': kraken_rest_symbols,\n    BINANCE: binance_symbols,\n    BINANCE_US: binance_us_symbols,\n    BINANCE_FUTURES: binance_futures_symbols,\n    BINANCE_DELIVERY: binance_delivery_symbols,\n    BLOCKCHAIN: blockchain_symbols,\n    EXX: exx_symbols,\n    HUOBI: huobi_symbols,\n    HUOBI_DM: huobi_dm_symbols,\n    HUOBI_SWAP: huobi_swap_symbols,\n    OKCOIN: okcoin_symbols,\n    OKEX: okex_symbols,\n    BYBIT: bybit_symbols,\n    FTX: ftx_symbols,\n    FTX_US: ftx_us_symbols,\n    BITTREX: bittrex_symbols,\n    BITCOINCOM: bitcoincom_symbols,\n    BITMAX: bitmax_symbols,\n    UPBIT: upbit_symbols,\n    GATEIO: gateio_symbols,\n    BITMEX: bitmex_symbols,\n    DERIBIT: deribit_symbols,\n    KRAKEN_FUTURES: kraken_future_symbols,\n    COINGECKO: coingecko_symbols,\n    WHALE_ALERT: whale_alert_coins\n}\n",
        "target_code_with_indent": "\nfrom typing import Dict, Tuple\n\n\nclass _Symbols:\n    <IND>def __init__(self):\n        <IND>self.data = {}\n\n    <DED>def set(self, exchange: str, normalized: dict, exchange_info: dict):\n        <IND>self.data[exchange] = {}\n        self.data[exchange]['normalized'] = normalized\n        self.data[exchange]['info'] = exchange_info\n\n    <DED>def get(self, exchange: str) -> Tuple[Dict, Dict]:\n        <IND>return self.data[exchange]['normalized'], self.data[exchange]['info']\n\n    <DED>def populated(self, exchange: str) -> bool:\n        <IND>return exchange in self.data\n\n\n<DED><DED>Symbols = _Symbols()\n"
      }
    ]
  },
  {
    "project": "bmoscon/cryptofeed",
    "commit": "3525dc8ce4d7836a9abaaa5662e58e5e27969a77",
    "filename": "cryptofeed/symbols.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/bmoscon-cryptofeed/cryptofeed/symbols.py",
    "file_hunks_size": 1,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "cryptofeed/symbols.py:285:8 Incompatible return type [7]: Expected `Dict[str, str]` but got implicit return value of `None`.",
    "message": " Expected `Dict[str, str]` but got implicit return value of `None`.",
    "rule_id": "Incompatible return type [7]",
    "warning_line_no": 285,
    "warning_line": "        raise_failure_explanation('BITSTAMP', why, {\"\": r})",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "associated with this software.\n\n\nSymbol generation code for exchanges\n'''\n\nimport logging\nimport string\nimport time\nfrom collections import defaultdict\nfrom typing import Dict, List, Optional, Tuple\n\nimport requests\nfrom requests import Response\n\nfrom cryptofeed.defines import *\n\n\nLOG = logging.getLogger('feedhandler')\n\nSYMBOL_SEP = '-'\n\n_symbols_retrieval_cache: Dict[str, Dict[str, str]] = {}\n_exchange_info = defaultdict(lambda: defaultdict(dict))\n\n\n_kraken_futures_product_type = {\n    'FI': 'Inverse Futures',\n    'FV': 'Vanilla Futures',\n    'PI': 'Perpetual Inverse Futures',\n    'PV': 'Perpetual Vanilla Futures',\n    'IN': 'Real Time Index',\n    'RR': 'Reference Rate',\n}\n\n\ndef raise_failure_explanation(feed_id: str, exception: BaseException, responses: Dict[str, Optional[Response]]):\n    LOG.critical('%s: encountered %r while processing response from exchange API', feed_id, exception)\n    if len(responses) > 1:\n        LOG.critical('%s: content of one of the %s responses was unexpected', feed_id, len(responses))\n    for url, r in responses.items():\n        if url:\n            LOG.critical('%s: requested URL: %s', feed_id, url)\n        if r:\n            LOG.critical('%s: unexpected response: %s', feed_id, r.text)\n    raise ValueError(f'Cryptofeed stopped because of an unexpected response from {feed_id}') from exception\n\n\ndef set_symbol_separator(separator: str):\n    global SYMBOL_SEP\n    SYMBOL_SEP = separator\n\n\ndef get_symbol_separator() -> str:\n    global SYMBOL_SEP\n    return SYMBOL_SEP\n\n\ndef gen_symbols(exchange: str, key_id=None) -> Dict[str, str]:\n    if exchange not in _symbols_retrieval_cache:\n        LOG.info(\"%s: Getting list of symbols\", exchange)\n        symbols = _exchange_function_map[exchange](key_id) if key_id else _exchange_function_map[exchange]()\n        LOG.info(\"%s: %s symbols\", exchange, len(symbols))\n\n        # log all retrieved symbols using debug level\n        for normalized, exch_sym in sorted(symbols.items()):\n            LOG.debug('%s: id-from-exch -> normalized: %-35s-> %s', exchange, exch_sym, normalized)\n\n        _symbols_retrieval_cache[exchange] = symbols\n    return _symbols_retrieval_cache[exchange]\n\n\ndef _binance_symbols(endpoint: str, exchange: str):\n    r = None\n    try:\n        ret = {}\n        r = requests.get(endpoint)\n        for symbol in r.json()['symbols']:\n            if symbol.get('status', 'TRADING') != \"TRADING\":\n                continue\n            if symbol.get('contractStatus', 'TRADING') != \"TRADING\":\n                continue\n            split = len(symbol['baseAsset'])\n            normalized = symbol['symbol'][:split] + SYMBOL_SEP + symbol['symbol'][split:]\n            ret[normalized] = symbol['symbol']\n            _exchange_info[exchange]['tick_size'][normalized] = symbol['filters'][0]['tickSize']\n            if \"contractType\" in symbol:\n                _exchange_info[exchange]['contract_type'][normalized] = symbol['contractType']\n        return ret\n    except Exception as why:\n        raise_failure_explanation(exchange, why, {endpoint: r})\n\n\ndef binance_symbols() -> Dict[str, str]:\n    return _binance_symbols('https://api.binance.com/api/v3/exchangeInfo', BINANCE)\n\n\ndef binance_us_symbols() -> Dict[str, str]:\n    return _binance_symbols('https://api.binance.us/api/v3/exchangeInfo', BINANCE_US)\n\n\ndef binance_futures_symbols() -> Dict[str, str]:\n    base = _binance_symbols('https://fapi.binance.com/fapi/v1/exchangeInfo', BINANCE_FUTURES)\n    add = {}\n    for symbol, orig in base.items():\n        if \"_\" in orig:\n            continue\n        add[f\"{symbol}-PINDEX\"] = f\"p{orig}\"\n    base.update(add)\n    return base\n\n\ndef binance_delivery_symbols() -> Dict[str, str]:\n    return _binance_symbols('https://dapi.binance.com/dapi/v1/exchangeInfo', BINANCE_DELIVERY)\n\n\ndef bitfinex_symbols() -> Dict[str, str]:\n    # doc: https://docs.bitfinex.com/docs/ws-general#supported-pairs\n    r1 = r2 = None\n    try:\n        r1 = requests.get('https://api.bitfinex.com/v2/tickers?symbols=ALL')\n        r2 = requests.get('https://api-pub.bitfinex.com/v2/conf/pub:map:currency:sym')\n        tickers: List[List[str]] = r1.json()\n        norm: List[Tuple[str, str]] = r2.json()[0]\n        norm: Dict[str, str] = dict(norm)\n        for k, v in dict(norm).items():\n            if k[-2:] == 'F0' or '-' in v:  # Do not convert BTCF0 -> BTC or PBTCETH -> PBTC-ETH\n                del norm[k]\n        norm['BCHN'] = 'BCH'  # Bitfinex uses BCHN, other exchanges use BCH\n\n        ret = {}\n        for symbol in [t[0] for t in tickers]:\n            if symbol[0] == 'f':\n                normalized = norm.get(symbol[1:], symbol[1:])\n            else:\n                if len(symbol) == 7:\n                    base, quote = symbol[1:4], symbol[4:]\n                else:\n                    base, quote = symbol[1:].split(':')\n                    assert ':' in symbol\n                normalized = norm.get(base, base) + SYMBOL_SEP + norm.get(quote, quote)\n            ret[normalized.upper()] = symbol\n        return ret\n    except ValueError as why:\n        raise_failure_explanation('BITFINEX', why, {\"tickers?symbols=ALL\": r1, \"pub:map:currency:sym\": r2})\n\n\ndef bitflyer_symbols() -> Dict[str, str]:\n    endpoint = r = None\n    try:\n        ret = {}\n        endpoints = ['https://api.bitflyer.com/v1/getmarkets/eu', 'https://api.bitflyer.com/v1/getmarkets/usa', 'https://api.bitflyer.com/v1/getmarkets']\n        for endpoint in endpoints:\n            r = requests.get(endpoint)\n            for entry in r.json():\n                normalized = entry['product_code'].replace(\"_\", SYMBOL_SEP)\n                ret[normalized] = entry['product_code']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('BITFLYER', why, {endpoint: r})\n\n\ndef bybit_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.bybit.com/v2/public/symbols')\n        ret = {}\n        for symbol in r.json()['result']:\n            quote = symbol['quote_currency']\n            if not symbol['name'].endswith(quote):\n                base, contract = symbol['name'].split(quote)\n                normalized = f\"{base}{SYMBOL_SEP}{quote}-{contract}\"\n            else:\n                normalized = f\"{symbol['base_currency']}{SYMBOL_SEP}{quote}\"\n            ret[normalized] = symbol['name']\n            _exchange_info[BYBIT]['tick_size'][normalized] = symbol['price_filter']['tick_size']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('BYBIT', why, {\"\": r})\n\n\ndef _ftx_helper(endpoint: str, exchange: str):\n    r = None\n    try:\n        r = requests.get(endpoint)\n        ret = {}\n        for data in r.json()['result']:\n            normalized = data['name'].replace(\"/\", SYMBOL_SEP)\n            symbol = data['name']\n            ret[normalized] = symbol\n            _exchange_info[exchange]['tick_size'][normalized] = data['priceIncrement']\n        return ret\n    except Exception as why:\n        raise_failure_explanation(exchange, why, {endpoint: r})\n\n\ndef ftx_symbols() -> Dict[str, str]:\n    return _ftx_helper('https://ftx.com/api/markets', FTX)\n\n\ndef ftx_us_symbols() -> Dict[str, str]:\n    return _ftx_helper('https://ftx.us/api/markets', FTX_US)\n\n\ndef coinbase_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.pro.coinbase.com/products')\n        ret = {}\n        for data in r.json():\n            normalized = data['id'].replace(\"-\", SYMBOL_SEP)\n            ret[normalized] = data['id']\n            _exchange_info[COINBASE]['tick_size'][normalized] = data['quote_increment']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('COINBASE', why, {\"\": r})\n\n\ndef gemini_symbols(*args) -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.gemini.com/v1/symbols')\n        ret = {}\n        for symbol in r.json():\n            std = f\"{symbol[:-3]}{SYMBOL_SEP}{symbol[-3:]}\"\n            std = std.upper()\n            ret[std] = symbol.upper()\n        return ret\n    except Exception as why:\n        raise_failure_explanation('GEMINI', why, {\"\": r})\n\n\ndef hitbtc_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        ret = {}\n        r = requests.get('https://api.hitbtc.com/api/2/public/symbol')\n        for symbol in r.json():\n            split = len(symbol['baseCurrency'])\n            normalized = symbol['id'][:split] + SYMBOL_SEP + symbol['id'][split:]\n            ret[normalized] = symbol['id']\n            _exchange_info[HITBTC]['tick_size'][normalized] = symbol['tickSize']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('HITBTC', why, {\"\": r})\n\n\ndef poloniex_id_symbol_mapping():\n    r = None\n    try:\n        r = requests.get('https://poloniex.com/public?command=returnTicker')\n        symbols = r.json()\n        ret = {}\n        for symbol in symbols:\n            ret[symbols[symbol]['id']] = symbol\n        return ret\n    except Exception as why:\n        raise_failure_explanation('POLONIEX', why, {\"\": r})\n\n\ndef poloniex_symbols() -> Dict[str, str]:\n    ret = {}\n    for _, value in poloniex_id_symbol_mapping().items():\n        std = value.replace(\"STR\", \"XLM\")\n        quote, base = std.split(\"_\")\n        ret[quote + SYMBOL_SEP + base] = value\n    return ret\n\n\ndef bitstamp_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://www.bitstamp.net/api/v2/trading-pairs-info/')\n        ret = {}\n        for data in r.json():\n            normalized = data['name'].replace(\"/\", SYMBOL_SEP)\n            symbol = data['url_symbol']\n            ret[normalized] = symbol\n        return ret\n    except Exception as why:\n        raise_failure_explanation('BITSTAMP', why, {\"\": r})\n\n\ndef kraken_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.kraken.com/0/public/AssetPairs')\n        data = r.json()\n        ret = {}\n        for symbol in data['result']:\n            if 'wsname' not in data['result'][symbol] or '.d' in symbol:\n                # https://blog.kraken.com/post/259/introducing-the-kraken-dark-pool/\n                # .d is for dark pool symbols\n                continue\n\n            base, quote = data['result'][symbol]['wsname'].split(\"/\")\n\n            normalized = f\"{base}{SYMBOL_SEP}{quote}\"\n            exch = data['result'][symbol]['wsname']\n            normalized = normalized.replace('XBT', 'BTC')\n            normalized = normalized.replace('XDG', 'DOG')\n            ret[normalized] = exch\n        return ret\n    except Exception as why:\n        raise_failure_explanation('KRAKEN', why, {\"\": r})\n\n\ndef kraken_rest_symbols() -> Dict[str, str]:\n    return {normalized: exchange.replace(\"/\", \"\") for normalized, exchange in kraken_symbols().items()}\n\n\ndef exx_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.exx.com/data/v1/tickers')\n        exchange = [key.upper() for key in r.json().keys()]\n        symbols = [key.replace(\"_\", SYMBOL_SEP) for key in exchange]\n        return dict(zip(symbols, exchange))\n    except Exception as why:\n        raise_failure_explanation('EXX', why, {\"\": r})\n\n\ndef huobi_common_symbols(url: str):\n    r = None\n    try:\n        r = requests.get(url)\n        ret = {}\n        for e in r.json()['data']:\n            if e['state'] == 'offline':\n                continue\n            normalized = f\"{e['base-currency'].upper()}{SYMBOL_SEP}{e['quote-currency'].upper()}\"\n            symbol = f\"{e['base-currency']}{e['quote-currency']}\"\n            ret[normalized] = symbol\n        return ret\n    except Exception as why:\n        raise_failure_explanation('HUOBI', why, {url: r})\n\n\ndef huobi_symbols() -> Dict[str, str]:\n    return huobi_common_symbols('https://api.huobi.pro/v1/common/symbols')\n\n\ndef huobi_us_symbols() -> Dict[str, str]:\n    return huobi_common_symbols('https://api.huobi.com/v1/common/symbols')\n\n\ndef huobi_dm_symbols() -> Dict[str, str]:\n    \"\"\"\n    Mapping is, for instance: {\"BTC_CW\":\"BTC190816\"}\n    See comments in exchange/huobi_dm.py\n    \"\"\"\n    mapping = {\n        \"this_week\": \"CW\",\n        \"next_week\": \"NW\",\n        \"quarter\": \"CQ\",\n        \"next_quarter\": \"NQ\"\n    }\n    r = None\n    try:\n        r = requests.get('https://www.hbdm.com/api/v1/contract_contract_info')\n        symbols = {}\n        for e in r.json()['data']:\n            symbols[f\"{e['symbol']}_{mapping[e['contract_type']]}\"] = e['contract_code']\n            _exchange_info[HUOBI_DM]['tick_size'][e['contract_code']] = e['price_tick']\n            _exchange_info[HUOBI_DM]['short_code_mappings'][f\"{e['symbol']}_{mapping[e['contract_type']]}\"] = e['contract_code']\n        return symbols\n    except Exception as why:\n        raise_failure_explanation('HUOBI_DM', why, {\"\": r})\n\n\ndef huobi_swap_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.hbdm.com/swap-api/v1/swap_contract_info')\n        symbols = {}\n        for e in r.json()['data']:\n            symbols[e['contract_code']] = e['contract_code']\n            _exchange_info[HUOBI_SWAP]['tick_size'][e['contract_code']] = e['price_tick']\n        return symbols\n    except Exception as why:\n        raise_failure_explanation('HUOBI_SWAP', why, {\"\": r})\n\n\ndef okcoin_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://www.okcoin.com/api/spot/v3/instruments')\n        ret = {}\n        for e in r.json():\n            ret[e['instrument_id']] = e['instrument_id']\n            _exchange_info[OKCOIN]['tick_size'][e['instrument_id']] = e['tick_size']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('OKCOIN', why, {\"\": r})\n\n\ndef okex_symbols(*args) -> Dict[str, str]:\n    urls = ['https://www.okex.com/api/spot/v3/instruments',\n            'https://www.okex.com/api/swap/v3/instruments',\n            'https://www.okex.com/api/futures/v3/instruments']\n    urls = urls + okex_compute_option_urls_from_underlyings()\n\n    symbols: Dict[str, str] = {}\n    for u in urls:\n        time.sleep(0.2)\n        symbols.update(okex_symbols_from_one_url(u))\n\n    for symbol in symbols:\n        instrument_type = 'futures'\n        dash_count = symbol.count(get_symbol_separator())\n        if dash_count == 1:  # BTC-USDT\n            instrument_type = 'spot'\n        if dash_count == 4:  # BTC-USD-201225-35000-P\n            instrument_type = 'option'\n        if symbol[-4:] == \"SWAP\":  # BTC-USDT-SWAP\n            instrument_type = 'swap'\n\n        _exchange_info[OKEX]['instrument_type'][symbol] = instrument_type\n\n    return symbols\n\n\ndef okex_compute_option_urls_from_underlyings() -> List[str]:\n    url = 'https://www.okex.com/api/option/v3/underlying'\n    r = None\n    try:\n        r = requests.get(url)\n        return [f'https://www.okex.com/api/option/v3/instruments/{underlying}' for underlying in r.json()]\n    except Exception as why:\n        raise_failure_explanation('OKEX', why, {url: r})\n\n\ndef okex_symbols_from_one_url(url: str) -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get(url)\n        ret = {}\n        for e in r.json():\n            ret[e['instrument_id']] = e['instrument_id']\n            _exchange_info[OKEX]['tick_size'][e['instrument_id']] = e['tick_size']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('OKEX', why, {url: r})\n\n\ndef bittrex_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.bittrex.com/api/v1.1/public/getmarkets')\n        r = r.json()['result']\n        return {f\"{e['MarketCurrency']}{SYMBOL_SEP}{e['BaseCurrency']}\": e['MarketName'] for e in r if e['IsActive']}\n    except Exception as why:\n        raise_failure_explanation('BITTREX', why, {\"\": r})\n\n\ndef bitcoincom_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.exchange.bitcoin.com/api/2/public/symbol')\n        return {f\"{data['baseCurrency']}{SYMBOL_SEP}{data['quoteCurrency'].replace('USD', 'USDT')}\": data['id'] for data in r.json()}\n    except Exception as why:\n        raise_failure_explanation('BITCOINCOM', why, {\"\": r})\n\n\ndef bitmax_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://bitmax.io/api/pro/v1/products')\n        ret = {}\n        for entry in r.json()['data']:\n            # Only \"Normal\" status symbols are tradeable\n            if entry['status'] == 'Normal':\n                normalized = f\"{entry['baseAsset']}{SYMBOL_SEP}{entry['quoteAsset']}\"\n                ret[normalized] = entry['symbol']\n                _exchange_info[BITMAX]['tick_size'][normalized] = entry['tickSize']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('BITMAX', why, {\"\": r})\n\n\ndef upbit_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.upbit.com/v1/market/all')\n        return {f\"{data['market'].split('-')[1]}{SYMBOL_SEP}{data['market'].split('-')[0]}\": data['market'] for data in r.json()}\n    except Exception as why:\n        raise_failure_explanation('UPBIT', why, {\"\": r})\n\n\ndef blockchain_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get(\"https://api.blockchain.com/mercury-gateway/v1/instruments\")\n        return {data[\"symbol\"].replace(\"-\", SYMBOL_SEP): data[\"symbol\"] for data in r.json()}\n    except Exception as why:\n        raise_failure_explanation('BLOCKCHAIN', why, {\"\": r})\n\n\ndef gateio_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get(\"https://api.gateio.ws/api/v4/spot/currency_pairs\")\n        return {data[\"id\"].replace(\"_\", SYMBOL_SEP): data['id'] for data in r.json()}\n    except Exception as why:\n        raise_failure_explanation('GATEIO', why, {\"\": r})\n\n\ndef bitmex_symbols() -> Dict[str, str]:\n    r = None\n    ret = {}\n    try:\n        r = requests.get(\"https://www.bitmex.com/api/v1/instrument/active\")\n        for entry in r.json():\n            components = []\n            components.append(entry['rootSymbol'])\n            components.append(entry['quoteCurrency'])\n\n            if entry['expiry']:\n                components.append(entry['symbol'][-3:])\n\n            normalized = SYMBOL_SEP.join(components)\n            normalized = normalized.replace(\"XBT\", \"BTC\")\n            ret[normalized] = entry['symbol']\n            _exchange_info[BITMEX]['tick_size'][normalized] = entry['tickSize']\n\n            if entry['expiry']:\n                _exchange_info[BITMEX]['expiry'][normalized] = entry['expiry']\n\n        return ret\n    except Exception as why:\n        raise_failure_explanation('BITMEX', why, {\"\": r})\n\n\ndef deribit_symbols() -> Dict[str, str]:\n    url = r = None\n    ret = {}\n    try:\n        # TODO: get currencies from https://www.deribit.com/api/v2/public/get_currencies\n        currencies = ['BTC', 'ETH']\n        for c in currencies:\n            url = f\"https://www.deribit.com/api/v2/public/get_instruments?currency={c}&expired=false\"\n            r = requests.get(url)\n            for entry in r.json()['result']:\n                split = entry['instrument_name'].split(\"-\")\n                normalized = split[0] + SYMBOL_SEP + entry['quote_currency'] + \"-\" + '-'.join(split[1:])\n                ret[normalized] = entry['instrument_name']\n                _exchange_info[DERIBIT]['tick_size'][normalized] = entry['tick_size']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('DERIBIT', why, {url: r})\n\n\ndef kraken_future_symbols() -> Dict[str, str]:\n    r = None\n    ret = {}\n    try:\n        r = requests.get('https://futures.kraken.com/derivatives/api/v3/instruments')\n        data = r.json()['instruments']\n        for entry in data:\n            if not entry['tradeable']:\n                continue\n            normalized = entry['symbol'].upper().replace(\"_\", \"-\")\n            symbol = normalized[3:6] + SYMBOL_SEP + normalized[6:9]\n            normalized = normalized.replace(normalized[3:9], symbol)\n            normalized = normalized.replace('XBT', 'BTC')\n\n            _exchange_info[KRAKEN_FUTURES]['tick_size'][normalized] = entry['tickSize']\n            _exchange_info[KRAKEN_FUTURES]['contract_size'][normalized] = entry['contractSize']\n            _exchange_info[KRAKEN_FUTURES]['underlying'][normalized] = entry['underlying']\n            _exchange_info[KRAKEN_FUTURES]['product_type'][normalized] = _kraken_futures_product_type[normalized[:2]]\n            ret[normalized] = entry['symbol']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('KRAKEN_FUTURES', why, {\"\": r})\n\n\ndef probit_symbols() -> Dict[str, str]:\n    # doc: https://docs-en.probit.com/reference-link/market\n    r = None\n    try:\n        r = requests.get('https://api.probit.com/api/exchange/v1/market')\n        return {entry['id']: entry['id'] for entry in r.json()['data']}\n    except Exception as why:\n        raise_failure_explanation('PROBIT', why, {\"\": r})\n\n\ndef coingecko_normalize_symbol(symbol: str) -> str:\n    # keep digits, letters and dots, replace others by space\n    symbol = ''.join(c if c.isalnum() or c in ('.', '+') else ' ' for c in symbol)\n    return coingecko_normalize(symbol.upper())\n\n\ndef coingecko_normalize_name(name: str) -> str:\n    # keep digits and letters, replace others by space (except when only composed by upper case letters, digits and dots)\n    if not all(c.isupper() or c.isdigit() or c == '.' for c in name):\n        name = ''.join(c if c.isalnum() else ' ' for c in name)\n    return coingecko_normalize(name)\n\n\ndef coingecko_normalize(sym: str) -> str:\n    sym = sym.strip()\n    # do not concatenate numbers => separate them with a dot\n    sym = list(sym)\n    if len(sym) > 4:\n        for i in range(2, len(sym) - 1):\n            if sym[i] == ' ' and sym[i - 1].isdigit() and sym[i + 1].isdigit():\n                sym[i] = '.'\n    sym = ''.join(sym)\n    # concatenate space-separated words => use CamelCase to distinguish the words\n    if ' ' in sym:\n        if sum(c.islower() for c in sym):  # if there is at least one lower case letter\n            sym = ' '.join(word[0].upper() + word[1:] for word in sym.split())  # Just capitalize initial letter of each word\n        else:  # CoinGecko may provide full upper-case as for \"THE STONE COIN\"\n            sym = string.capwords(sym)  # capwords converts \"THE STONE COIN\" to \"The Stone Coin\"\n        sym = sym.replace(' ', '')  # concatenate words\n    return sym\n\n\ndef is_name_short(coin: dict) -> bool:\n    \"\"\"return True if the coin name is enough short compared to the coin symbol.\"\"\"\n    return len(coin['name']) <= max(5, len(coin['symbol']) + 1)\n\n\ndef has_many_caps(name: str) -> bool:\n    \"\"\"return True if the symbol contains enough upper case letters, False if empty.\"\"\"\n    return str and sum(c.islower() for c in name) < (len(name) / 2)\n\n\ndef coingecko_normalize_all(coin: dict):\n    SYMBOL_TO_NORMALIZED = {'miota': 'IOTA'}\n    normalized = SYMBOL_TO_NORMALIZED.get(coin['symbol'])\n    if normalized:\n        coin['ns'] = coin['nn'] = normalized\n        return normalized\n\n    # ns = normalized symbol, nn = normalized name\n    coin['ns'] = coingecko_normalize_symbol(coin['symbol'])\n\n    ID_SUFFIX = '-bitcoin-token'\n    if coin['id'][-len(ID_SUFFIX):] == ID_SUFFIX:\n        coin['nn'] = 'BTC' + coin['ns']\n        return coin['nn']\n\n    name = coin['name']\n\n    prefixes = ('The ', 'the ')\n    for p in prefixes:\n        if name[:len(p)] == p:\n            coin['reduced-name'] = True\n            name = name[len(p):]\n            break\n\n    suffixes = ('coin', 'coins', 'money', 'finance', 'protocol', 'reward', 'rewards', 'token')\n    for s in suffixes:\n        if len(name) > len(s) and name[-len(s):].lower() == s:\n            # but keep suffix when lower-case concatenated\n            if name[-len(s)].islower() and name[-len(s) - 1] != ' ':\n                continue\n            # also keep suffix to avoid confusing nam: \"Bitcoin Token\" -> \"Bitcoin\"\n            if name[:-len(s)].strip().lower() == 'bitcoin':\n                continue\n            coin['reduced-name'] = True\n            name = name[:-len(s)]\n            break\n\n    coin['nn'] = coingecko_normalize_name(name)\n\n    if len(coin['nn']) < len(coin['ns']):\n        if 'reduced-name' in coin:\n            coin['reduced-name'] = False\n            name = coin['name']\n            coin['nn'] = coingecko_normalize_name(name)\n        elif not has_many_caps(name):\n            return coin['ns']\n\n    if not coin['ns']:  # coin['symbol'] may be an emoji that is striped when normalized\n        return coin['nn']\n\n    if coin.get('reduced-name') and coin['ns'].upper() != coin['nn'].upper():\n        return coin['ns']\n\n    i = coin['nn'].find('.')  # if there is a dot in normalized name => prefer the normalized symbol\n    if i >= 0:\n        if i > 1 and coin['nn'][i - 1].isdigit() and coin['nn'][i + 1].isdigit():\n            pass  # except when the dot separates digits\n        else:\n            return coin['ns']\n\n    if is_name_short(coin) and has_many_caps(name):\n        return coin['nn']\n\n    if 1.5 * len(coin['ns']) > len(coin['nn']) and any(c.islower() for c in coin['ns']):\n        return coin['nn']\n\n    return coin['ns']\n\n\ndef coingecko_symbols() -> Dict[str, str]:\n    r = None\n    intermediate = defaultdict(list)\n    try:\n        r = requests.get('https://api.coingecko.com/api/v3/coins/list')\n        all_coins = r.json()\n        # First pass: generate & compare normalized symbol/name, and then select the most pertinent\n        for coin in all_coins:\n            normalized = coingecko_normalize_all(coin)\n            intermediate[normalized].append(coin)\n            # Above line keeps together the coins having the same normalized symbol.\n            # To reduce collision, the coin['name'] is sometimes used in lieu of the coin['symbol'].\n            # The coin['name'] is not capitalized because lower case letters may be meaningful: cETH, yUSD, DATx, zLOT\n    except Exception as why:\n        raise_failure_explanation('COINGECKO', why, {\"\": r})\n\n    final = coingecko_second_pass(intermediate)\n    return coingecko_third_pass(final)\n\n\ndef coingecko_second_pass(intermediate: Dict[str, List[dict]]) -> Dict[str, List[dict]]:\n    # Second pass: fixes most of the symbol collisions\n    final = defaultdict(list)\n    for normalized, coins in intermediate.items():\n        if len(coins) == 1:\n            final[normalized].append(coins[0])\n            continue\n        set_normalized = False\n        for i in range(len(coins)):\n            if normalized == coins[i]['nn']:\n                coin = coins.pop(i)\n                final[normalized].append(coin)\n                set_normalized = True\n                break\n        rest: List[dict] = []\n        for coin in coins:\n            if '%' in coin['name']:\n                if len(coins) == 1:\n                    n = coin['ns']\n                else:\n                    n = coingecko_normalize_name(coin['id'])\n                final[n].append(coin)\n            else:\n                rest.append(coin)\n        if not rest:\n            continue\n        if not set_normalized:\n            rest.sort(key=lambda coin: len(coin['nn']), reverse=True)  # sort by the length of the normalized name\n            coin = rest.pop(0)\n            final[normalized].append(coin)\n        for coin in rest:\n            if coin['nn'] not in intermediate:\n                n = coin['nn']\n            elif coin.get('reduced-name'):\n                n = coingecko_normalize_name(coin['name'])\n            else:\n                n = coingecko_normalize_name(coin['id'])\n            final[n].append(coin)\n    return final\n\n\ndef coingecko_third_pass(final: Dict[str, List[dict]]) -> Dict[str, str]:\n    # Third pass: fixes some remaining collisions and fills the result\n    symbols = {}\n    for normalized, coins in final.items():\n        if len(coins) == 1:\n            symbols[normalized] = coins[0]['id']\n            continue\n        set_normalized = False\n        for i in range(len(coins)):\n            if normalized == coins[i]['nn']:\n                coin = coins.pop(i)\n                symbols[normalized] = coin['id']\n                set_normalized = True\n                break\n        rest: List[dict] = []\n        for coin in coins:\n            if '%' in coin['name']:\n                if len(coins) == 1:\n                    n = coin['ns']\n                else:\n                    n = coingecko_normalize_name(coin['id'])\n                symbols[n] = coin['id']\n            else:\n                rest.append(coin)\n        if not rest:\n            continue\n        if not set_normalized:\n            rest.sort(key=lambda coin: len(coin['nn']), reverse=True)  # sort by the length of the normalized name\n            coin = rest.pop(0)\n            symbols[normalized] = coin['id']\n        for coin in rest:\n            if coin['nn'] not in final:\n                n = coin['nn']\n            elif coin.get('reduced-name'):\n                n = coingecko_normalize_name(coin['name'])\n            else:\n                n = coingecko_normalize_name(coin['id'])\n            symbols[n] = coin['id']\n    return symbols\n\n\ndef whale_alert_coins(key_id: str) -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get(f'https://api.whale-alert.io/v1/status?api_key={key_id}')\n        # Same symbols, but on different blockchains (for instance USDT), are naturally overwritten.\n        return {s.upper(): s for b in r.json()['blockchains'] for s in b['symbols'] if s}\n    except Exception as why:\n        raise_failure_explanation('WHALES_ALERT', why, {\"\": r})\n\n\n_exchange_function_map = {\n    BITFINEX: bitfinex_symbols,\n    BITFLYER: bitflyer_symbols,\n    COINBASE: coinbase_symbols,\n    GEMINI: gemini_symbols,\n    HITBTC: hitbtc_symbols,\n    POLONIEX: poloniex_symbols,\n    PROBIT: probit_symbols,\n    BITSTAMP: bitstamp_symbols,\n    KRAKEN: kraken_symbols,\n    KRAKEN + 'REST': kraken_rest_symbols,\n    BINANCE: binance_symbols,\n    BINANCE_US: binance_us_symbols,\n    BINANCE_FUTURES: binance_futures_symbols,\n    BINANCE_DELIVERY: binance_delivery_symbols,\n    BLOCKCHAIN: blockchain_symbols,\n    EXX: exx_symbols,\n    HUOBI: huobi_symbols,\n    HUOBI_DM: huobi_dm_symbols,\n    HUOBI_SWAP: huobi_swap_symbols,\n    OKCOIN: okcoin_symbols,\n    OKEX: okex_symbols,\n    BYBIT: bybit_symbols,\n    FTX: ftx_symbols,\n    FTX_US: ftx_us_symbols,\n    BITTREX: bittrex_symbols,\n    BITCOINCOM: bitcoincom_symbols,\n    BITMAX: bitmax_symbols,\n    UPBIT: upbit_symbols,\n    GATEIO: gateio_symbols,\n    BITMEX: bitmex_symbols,\n    DERIBIT: deribit_symbols,\n    KRAKEN_FUTURES: kraken_future_symbols,\n    COINGECKO: coingecko_symbols,\n    WHALE_ALERT: whale_alert_coins\n}\n",
        "source_code_len": 30534,
        "target_code": "associated with this software.\n'''\nfrom typing import Dict, Tuple\n\n\nclass _Symbols:\n    def __init__(self):\n        self.data = {}\n\n    def set(self, exchange: str, normalized: dict, exchange_info: dict):\n        self.data[exchange] = {}\n        self.data[exchange]['normalized'] = normalized\n        self.data[exchange]['info'] = exchange_info\n\n    def get(self, exchange: str) -> Tuple[Dict, Dict]:\n        return self.data[exchange]['normalized'], self.data[exchange]['info']\n\n    def populated(self, exchange: str) -> bool:\n        return exchange in self.data\n\n\nSymbols = _Symbols()\n",
        "target_code_len": 588,
        "diff_format": "@@ -5,845 +5,22 @@\n associated with this software.\n+'''\n+from typing import Dict, Tuple\n \n \n-Symbol generation code for exchanges\n-'''\n+class _Symbols:\n+    def __init__(self):\n+        self.data = {}\n \n-import logging\n-import string\n-import time\n-from collections import defaultdict\n-from typing import Dict, List, Optional, Tuple\n+    def set(self, exchange: str, normalized: dict, exchange_info: dict):\n+        self.data[exchange] = {}\n+        self.data[exchange]['normalized'] = normalized\n+        self.data[exchange]['info'] = exchange_info\n \n-import requests\n-from requests import Response\n+    def get(self, exchange: str) -> Tuple[Dict, Dict]:\n+        return self.data[exchange]['normalized'], self.data[exchange]['info']\n \n-from cryptofeed.defines import *\n+    def populated(self, exchange: str) -> bool:\n+        return exchange in self.data\n \n \n-LOG = logging.getLogger('feedhandler')\n-\n-SYMBOL_SEP = '-'\n-\n-_symbols_retrieval_cache: Dict[str, Dict[str, str]] = {}\n-_exchange_info = defaultdict(lambda: defaultdict(dict))\n-\n-\n-_kraken_futures_product_type = {\n-    'FI': 'Inverse Futures',\n-    'FV': 'Vanilla Futures',\n-    'PI': 'Perpetual Inverse Futures',\n-    'PV': 'Perpetual Vanilla Futures',\n-    'IN': 'Real Time Index',\n-    'RR': 'Reference Rate',\n-}\n-\n-\n-def raise_failure_explanation(feed_id: str, exception: BaseException, responses: Dict[str, Optional[Response]]):\n-    LOG.critical('%s: encountered %r while processing response from exchange API', feed_id, exception)\n-    if len(responses) > 1:\n-        LOG.critical('%s: content of one of the %s responses was unexpected', feed_id, len(responses))\n-    for url, r in responses.items():\n-        if url:\n-            LOG.critical('%s: requested URL: %s', feed_id, url)\n-        if r:\n-            LOG.critical('%s: unexpected response: %s', feed_id, r.text)\n-    raise ValueError(f'Cryptofeed stopped because of an unexpected response from {feed_id}') from exception\n-\n-\n-def set_symbol_separator(separator: str):\n-    global SYMBOL_SEP\n-    SYMBOL_SEP = separator\n-\n-\n-def get_symbol_separator() -> str:\n-    global SYMBOL_SEP\n-    return SYMBOL_SEP\n-\n-\n-def gen_symbols(exchange: str, key_id=None) -> Dict[str, str]:\n-    if exchange not in _symbols_retrieval_cache:\n-        LOG.info(\"%s: Getting list of symbols\", exchange)\n-        symbols = _exchange_function_map[exchange](key_id) if key_id else _exchange_function_map[exchange]()\n-        LOG.info(\"%s: %s symbols\", exchange, len(symbols))\n-\n-        # log all retrieved symbols using debug level\n-        for normalized, exch_sym in sorted(symbols.items()):\n-            LOG.debug('%s: id-from-exch -> normalized: %-35s-> %s', exchange, exch_sym, normalized)\n-\n-        _symbols_retrieval_cache[exchange] = symbols\n-    return _symbols_retrieval_cache[exchange]\n-\n-\n-def _binance_symbols(endpoint: str, exchange: str):\n-    r = None\n-    try:\n-        ret = {}\n-        r = requests.get(endpoint)\n-        for symbol in r.json()['symbols']:\n-            if symbol.get('status', 'TRADING') != \"TRADING\":\n-                continue\n-            if symbol.get('contractStatus', 'TRADING') != \"TRADING\":\n-                continue\n-            split = len(symbol['baseAsset'])\n-            normalized = symbol['symbol'][:split] + SYMBOL_SEP + symbol['symbol'][split:]\n-            ret[normalized] = symbol['symbol']\n-            _exchange_info[exchange]['tick_size'][normalized] = symbol['filters'][0]['tickSize']\n-            if \"contractType\" in symbol:\n-                _exchange_info[exchange]['contract_type'][normalized] = symbol['contractType']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation(exchange, why, {endpoint: r})\n-\n-\n-def binance_symbols() -> Dict[str, str]:\n-    return _binance_symbols('https://api.binance.com/api/v3/exchangeInfo', BINANCE)\n-\n-\n-def binance_us_symbols() -> Dict[str, str]:\n-    return _binance_symbols('https://api.binance.us/api/v3/exchangeInfo', BINANCE_US)\n-\n-\n-def binance_futures_symbols() -> Dict[str, str]:\n-    base = _binance_symbols('https://fapi.binance.com/fapi/v1/exchangeInfo', BINANCE_FUTURES)\n-    add = {}\n-    for symbol, orig in base.items():\n-        if \"_\" in orig:\n-            continue\n-        add[f\"{symbol}-PINDEX\"] = f\"p{orig}\"\n-    base.update(add)\n-    return base\n-\n-\n-def binance_delivery_symbols() -> Dict[str, str]:\n-    return _binance_symbols('https://dapi.binance.com/dapi/v1/exchangeInfo', BINANCE_DELIVERY)\n-\n-\n-def bitfinex_symbols() -> Dict[str, str]:\n-    # doc: https://docs.bitfinex.com/docs/ws-general#supported-pairs\n-    r1 = r2 = None\n-    try:\n-        r1 = requests.get('https://api.bitfinex.com/v2/tickers?symbols=ALL')\n-        r2 = requests.get('https://api-pub.bitfinex.com/v2/conf/pub:map:currency:sym')\n-        tickers: List[List[str]] = r1.json()\n-        norm: List[Tuple[str, str]] = r2.json()[0]\n-        norm: Dict[str, str] = dict(norm)\n-        for k, v in dict(norm).items():\n-            if k[-2:] == 'F0' or '-' in v:  # Do not convert BTCF0 -> BTC or PBTCETH -> PBTC-ETH\n-                del norm[k]\n-        norm['BCHN'] = 'BCH'  # Bitfinex uses BCHN, other exchanges use BCH\n-\n-        ret = {}\n-        for symbol in [t[0] for t in tickers]:\n-            if symbol[0] == 'f':\n-                normalized = norm.get(symbol[1:], symbol[1:])\n-            else:\n-                if len(symbol) == 7:\n-                    base, quote = symbol[1:4], symbol[4:]\n-                else:\n-                    base, quote = symbol[1:].split(':')\n-                    assert ':' in symbol\n-                normalized = norm.get(base, base) + SYMBOL_SEP + norm.get(quote, quote)\n-            ret[normalized.upper()] = symbol\n-        return ret\n-    except ValueError as why:\n-        raise_failure_explanation('BITFINEX', why, {\"tickers?symbols=ALL\": r1, \"pub:map:currency:sym\": r2})\n-\n-\n-def bitflyer_symbols() -> Dict[str, str]:\n-    endpoint = r = None\n-    try:\n-        ret = {}\n-        endpoints = ['https://api.bitflyer.com/v1/getmarkets/eu', 'https://api.bitflyer.com/v1/getmarkets/usa', 'https://api.bitflyer.com/v1/getmarkets']\n-        for endpoint in endpoints:\n-            r = requests.get(endpoint)\n-            for entry in r.json():\n-                normalized = entry['product_code'].replace(\"_\", SYMBOL_SEP)\n-                ret[normalized] = entry['product_code']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('BITFLYER', why, {endpoint: r})\n-\n-\n-def bybit_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.bybit.com/v2/public/symbols')\n-        ret = {}\n-        for symbol in r.json()['result']:\n-            quote = symbol['quote_currency']\n-            if not symbol['name'].endswith(quote):\n-                base, contract = symbol['name'].split(quote)\n-                normalized = f\"{base}{SYMBOL_SEP}{quote}-{contract}\"\n-            else:\n-                normalized = f\"{symbol['base_currency']}{SYMBOL_SEP}{quote}\"\n-            ret[normalized] = symbol['name']\n-            _exchange_info[BYBIT]['tick_size'][normalized] = symbol['price_filter']['tick_size']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('BYBIT', why, {\"\": r})\n-\n-\n-def _ftx_helper(endpoint: str, exchange: str):\n-    r = None\n-    try:\n-        r = requests.get(endpoint)\n-        ret = {}\n-        for data in r.json()['result']:\n-            normalized = data['name'].replace(\"/\", SYMBOL_SEP)\n-            symbol = data['name']\n-            ret[normalized] = symbol\n-            _exchange_info[exchange]['tick_size'][normalized] = data['priceIncrement']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation(exchange, why, {endpoint: r})\n-\n-\n-def ftx_symbols() -> Dict[str, str]:\n-    return _ftx_helper('https://ftx.com/api/markets', FTX)\n-\n-\n-def ftx_us_symbols() -> Dict[str, str]:\n-    return _ftx_helper('https://ftx.us/api/markets', FTX_US)\n-\n-\n-def coinbase_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.pro.coinbase.com/products')\n-        ret = {}\n-        for data in r.json():\n-            normalized = data['id'].replace(\"-\", SYMBOL_SEP)\n-            ret[normalized] = data['id']\n-            _exchange_info[COINBASE]['tick_size'][normalized] = data['quote_increment']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('COINBASE', why, {\"\": r})\n-\n-\n-def gemini_symbols(*args) -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.gemini.com/v1/symbols')\n-        ret = {}\n-        for symbol in r.json():\n-            std = f\"{symbol[:-3]}{SYMBOL_SEP}{symbol[-3:]}\"\n-            std = std.upper()\n-            ret[std] = symbol.upper()\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('GEMINI', why, {\"\": r})\n-\n-\n-def hitbtc_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        ret = {}\n-        r = requests.get('https://api.hitbtc.com/api/2/public/symbol')\n-        for symbol in r.json():\n-            split = len(symbol['baseCurrency'])\n-            normalized = symbol['id'][:split] + SYMBOL_SEP + symbol['id'][split:]\n-            ret[normalized] = symbol['id']\n-            _exchange_info[HITBTC]['tick_size'][normalized] = symbol['tickSize']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('HITBTC', why, {\"\": r})\n-\n-\n-def poloniex_id_symbol_mapping():\n-    r = None\n-    try:\n-        r = requests.get('https://poloniex.com/public?command=returnTicker')\n-        symbols = r.json()\n-        ret = {}\n-        for symbol in symbols:\n-            ret[symbols[symbol]['id']] = symbol\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('POLONIEX', why, {\"\": r})\n-\n-\n-def poloniex_symbols() -> Dict[str, str]:\n-    ret = {}\n-    for _, value in poloniex_id_symbol_mapping().items():\n-        std = value.replace(\"STR\", \"XLM\")\n-        quote, base = std.split(\"_\")\n-        ret[quote + SYMBOL_SEP + base] = value\n-    return ret\n-\n-\n-def bitstamp_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://www.bitstamp.net/api/v2/trading-pairs-info/')\n-        ret = {}\n-        for data in r.json():\n-            normalized = data['name'].replace(\"/\", SYMBOL_SEP)\n-            symbol = data['url_symbol']\n-            ret[normalized] = symbol\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('BITSTAMP', why, {\"\": r})\n-\n-\n-def kraken_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.kraken.com/0/public/AssetPairs')\n-        data = r.json()\n-        ret = {}\n-        for symbol in data['result']:\n-            if 'wsname' not in data['result'][symbol] or '.d' in symbol:\n-                # https://blog.kraken.com/post/259/introducing-the-kraken-dark-pool/\n-                # .d is for dark pool symbols\n-                continue\n-\n-            base, quote = data['result'][symbol]['wsname'].split(\"/\")\n-\n-            normalized = f\"{base}{SYMBOL_SEP}{quote}\"\n-            exch = data['result'][symbol]['wsname']\n-            normalized = normalized.replace('XBT', 'BTC')\n-            normalized = normalized.replace('XDG', 'DOG')\n-            ret[normalized] = exch\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('KRAKEN', why, {\"\": r})\n-\n-\n-def kraken_rest_symbols() -> Dict[str, str]:\n-    return {normalized: exchange.replace(\"/\", \"\") for normalized, exchange in kraken_symbols().items()}\n-\n-\n-def exx_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.exx.com/data/v1/tickers')\n-        exchange = [key.upper() for key in r.json().keys()]\n-        symbols = [key.replace(\"_\", SYMBOL_SEP) for key in exchange]\n-        return dict(zip(symbols, exchange))\n-    except Exception as why:\n-        raise_failure_explanation('EXX', why, {\"\": r})\n-\n-\n-def huobi_common_symbols(url: str):\n-    r = None\n-    try:\n-        r = requests.get(url)\n-        ret = {}\n-        for e in r.json()['data']:\n-            if e['state'] == 'offline':\n-                continue\n-            normalized = f\"{e['base-currency'].upper()}{SYMBOL_SEP}{e['quote-currency'].upper()}\"\n-            symbol = f\"{e['base-currency']}{e['quote-currency']}\"\n-            ret[normalized] = symbol\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('HUOBI', why, {url: r})\n-\n-\n-def huobi_symbols() -> Dict[str, str]:\n-    return huobi_common_symbols('https://api.huobi.pro/v1/common/symbols')\n-\n-\n-def huobi_us_symbols() -> Dict[str, str]:\n-    return huobi_common_symbols('https://api.huobi.com/v1/common/symbols')\n-\n-\n-def huobi_dm_symbols() -> Dict[str, str]:\n-    \"\"\"\n-    Mapping is, for instance: {\"BTC_CW\":\"BTC190816\"}\n-    See comments in exchange/huobi_dm.py\n-    \"\"\"\n-    mapping = {\n-        \"this_week\": \"CW\",\n-        \"next_week\": \"NW\",\n-        \"quarter\": \"CQ\",\n-        \"next_quarter\": \"NQ\"\n-    }\n-    r = None\n-    try:\n-        r = requests.get('https://www.hbdm.com/api/v1/contract_contract_info')\n-        symbols = {}\n-        for e in r.json()['data']:\n-            symbols[f\"{e['symbol']}_{mapping[e['contract_type']]}\"] = e['contract_code']\n-            _exchange_info[HUOBI_DM]['tick_size'][e['contract_code']] = e['price_tick']\n-            _exchange_info[HUOBI_DM]['short_code_mappings'][f\"{e['symbol']}_{mapping[e['contract_type']]}\"] = e['contract_code']\n-        return symbols\n-    except Exception as why:\n-        raise_failure_explanation('HUOBI_DM', why, {\"\": r})\n-\n-\n-def huobi_swap_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.hbdm.com/swap-api/v1/swap_contract_info')\n-        symbols = {}\n-        for e in r.json()['data']:\n-            symbols[e['contract_code']] = e['contract_code']\n-            _exchange_info[HUOBI_SWAP]['tick_size'][e['contract_code']] = e['price_tick']\n-        return symbols\n-    except Exception as why:\n-        raise_failure_explanation('HUOBI_SWAP', why, {\"\": r})\n-\n-\n-def okcoin_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://www.okcoin.com/api/spot/v3/instruments')\n-        ret = {}\n-        for e in r.json():\n-            ret[e['instrument_id']] = e['instrument_id']\n-            _exchange_info[OKCOIN]['tick_size'][e['instrument_id']] = e['tick_size']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('OKCOIN', why, {\"\": r})\n-\n-\n-def okex_symbols(*args) -> Dict[str, str]:\n-    urls = ['https://www.okex.com/api/spot/v3/instruments',\n-            'https://www.okex.com/api/swap/v3/instruments',\n-            'https://www.okex.com/api/futures/v3/instruments']\n-    urls = urls + okex_compute_option_urls_from_underlyings()\n-\n-    symbols: Dict[str, str] = {}\n-    for u in urls:\n-        time.sleep(0.2)\n-        symbols.update(okex_symbols_from_one_url(u))\n-\n-    for symbol in symbols:\n-        instrument_type = 'futures'\n-        dash_count = symbol.count(get_symbol_separator())\n-        if dash_count == 1:  # BTC-USDT\n-            instrument_type = 'spot'\n-        if dash_count == 4:  # BTC-USD-201225-35000-P\n-            instrument_type = 'option'\n-        if symbol[-4:] == \"SWAP\":  # BTC-USDT-SWAP\n-            instrument_type = 'swap'\n-\n-        _exchange_info[OKEX]['instrument_type'][symbol] = instrument_type\n-\n-    return symbols\n-\n-\n-def okex_compute_option_urls_from_underlyings() -> List[str]:\n-    url = 'https://www.okex.com/api/option/v3/underlying'\n-    r = None\n-    try:\n-        r = requests.get(url)\n-        return [f'https://www.okex.com/api/option/v3/instruments/{underlying}' for underlying in r.json()]\n-    except Exception as why:\n-        raise_failure_explanation('OKEX', why, {url: r})\n-\n-\n-def okex_symbols_from_one_url(url: str) -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get(url)\n-        ret = {}\n-        for e in r.json():\n-            ret[e['instrument_id']] = e['instrument_id']\n-            _exchange_info[OKEX]['tick_size'][e['instrument_id']] = e['tick_size']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('OKEX', why, {url: r})\n-\n-\n-def bittrex_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.bittrex.com/api/v1.1/public/getmarkets')\n-        r = r.json()['result']\n-        return {f\"{e['MarketCurrency']}{SYMBOL_SEP}{e['BaseCurrency']}\": e['MarketName'] for e in r if e['IsActive']}\n-    except Exception as why:\n-        raise_failure_explanation('BITTREX', why, {\"\": r})\n-\n-\n-def bitcoincom_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.exchange.bitcoin.com/api/2/public/symbol')\n-        return {f\"{data['baseCurrency']}{SYMBOL_SEP}{data['quoteCurrency'].replace('USD', 'USDT')}\": data['id'] for data in r.json()}\n-    except Exception as why:\n-        raise_failure_explanation('BITCOINCOM', why, {\"\": r})\n-\n-\n-def bitmax_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://bitmax.io/api/pro/v1/products')\n-        ret = {}\n-        for entry in r.json()['data']:\n-            # Only \"Normal\" status symbols are tradeable\n-            if entry['status'] == 'Normal':\n-                normalized = f\"{entry['baseAsset']}{SYMBOL_SEP}{entry['quoteAsset']}\"\n-                ret[normalized] = entry['symbol']\n-                _exchange_info[BITMAX]['tick_size'][normalized] = entry['tickSize']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('BITMAX', why, {\"\": r})\n-\n-\n-def upbit_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.upbit.com/v1/market/all')\n-        return {f\"{data['market'].split('-')[1]}{SYMBOL_SEP}{data['market'].split('-')[0]}\": data['market'] for data in r.json()}\n-    except Exception as why:\n-        raise_failure_explanation('UPBIT', why, {\"\": r})\n-\n-\n-def blockchain_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get(\"https://api.blockchain.com/mercury-gateway/v1/instruments\")\n-        return {data[\"symbol\"].replace(\"-\", SYMBOL_SEP): data[\"symbol\"] for data in r.json()}\n-    except Exception as why:\n-        raise_failure_explanation('BLOCKCHAIN', why, {\"\": r})\n-\n-\n-def gateio_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get(\"https://api.gateio.ws/api/v4/spot/currency_pairs\")\n-        return {data[\"id\"].replace(\"_\", SYMBOL_SEP): data['id'] for data in r.json()}\n-    except Exception as why:\n-        raise_failure_explanation('GATEIO', why, {\"\": r})\n-\n-\n-def bitmex_symbols() -> Dict[str, str]:\n-    r = None\n-    ret = {}\n-    try:\n-        r = requests.get(\"https://www.bitmex.com/api/v1/instrument/active\")\n-        for entry in r.json():\n-            components = []\n-            components.append(entry['rootSymbol'])\n-            components.append(entry['quoteCurrency'])\n-\n-            if entry['expiry']:\n-                components.append(entry['symbol'][-3:])\n-\n-            normalized = SYMBOL_SEP.join(components)\n-            normalized = normalized.replace(\"XBT\", \"BTC\")\n-            ret[normalized] = entry['symbol']\n-            _exchange_info[BITMEX]['tick_size'][normalized] = entry['tickSize']\n-\n-            if entry['expiry']:\n-                _exchange_info[BITMEX]['expiry'][normalized] = entry['expiry']\n-\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('BITMEX', why, {\"\": r})\n-\n-\n-def deribit_symbols() -> Dict[str, str]:\n-    url = r = None\n-    ret = {}\n-    try:\n-        # TODO: get currencies from https://www.deribit.com/api/v2/public/get_currencies\n-        currencies = ['BTC', 'ETH']\n-        for c in currencies:\n-            url = f\"https://www.deribit.com/api/v2/public/get_instruments?currency={c}&expired=false\"\n-            r = requests.get(url)\n-            for entry in r.json()['result']:\n-                split = entry['instrument_name'].split(\"-\")\n-                normalized = split[0] + SYMBOL_SEP + entry['quote_currency'] + \"-\" + '-'.join(split[1:])\n-                ret[normalized] = entry['instrument_name']\n-                _exchange_info[DERIBIT]['tick_size'][normalized] = entry['tick_size']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('DERIBIT', why, {url: r})\n-\n-\n-def kraken_future_symbols() -> Dict[str, str]:\n-    r = None\n-    ret = {}\n-    try:\n-        r = requests.get('https://futures.kraken.com/derivatives/api/v3/instruments')\n-        data = r.json()['instruments']\n-        for entry in data:\n-            if not entry['tradeable']:\n-                continue\n-            normalized = entry['symbol'].upper().replace(\"_\", \"-\")\n-            symbol = normalized[3:6] + SYMBOL_SEP + normalized[6:9]\n-            normalized = normalized.replace(normalized[3:9], symbol)\n-            normalized = normalized.replace('XBT', 'BTC')\n-\n-            _exchange_info[KRAKEN_FUTURES]['tick_size'][normalized] = entry['tickSize']\n-            _exchange_info[KRAKEN_FUTURES]['contract_size'][normalized] = entry['contractSize']\n-            _exchange_info[KRAKEN_FUTURES]['underlying'][normalized] = entry['underlying']\n-            _exchange_info[KRAKEN_FUTURES]['product_type'][normalized] = _kraken_futures_product_type[normalized[:2]]\n-            ret[normalized] = entry['symbol']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('KRAKEN_FUTURES', why, {\"\": r})\n-\n-\n-def probit_symbols() -> Dict[str, str]:\n-    # doc: https://docs-en.probit.com/reference-link/market\n-    r = None\n-    try:\n-        r = requests.get('https://api.probit.com/api/exchange/v1/market')\n-        return {entry['id']: entry['id'] for entry in r.json()['data']}\n-    except Exception as why:\n-        raise_failure_explanation('PROBIT', why, {\"\": r})\n-\n-\n-def coingecko_normalize_symbol(symbol: str) -> str:\n-    # keep digits, letters and dots, replace others by space\n-    symbol = ''.join(c if c.isalnum() or c in ('.', '+') else ' ' for c in symbol)\n-    return coingecko_normalize(symbol.upper())\n-\n-\n-def coingecko_normalize_name(name: str) -> str:\n-    # keep digits and letters, replace others by space (except when only composed by upper case letters, digits and dots)\n-    if not all(c.isupper() or c.isdigit() or c == '.' for c in name):\n-        name = ''.join(c if c.isalnum() else ' ' for c in name)\n-    return coingecko_normalize(name)\n-\n-\n-def coingecko_normalize(sym: str) -> str:\n-    sym = sym.strip()\n-    # do not concatenate numbers => separate them with a dot\n-    sym = list(sym)\n-    if len(sym) > 4:\n-        for i in range(2, len(sym) - 1):\n-            if sym[i] == ' ' and sym[i - 1].isdigit() and sym[i + 1].isdigit():\n-                sym[i] = '.'\n-    sym = ''.join(sym)\n-    # concatenate space-separated words => use CamelCase to distinguish the words\n-    if ' ' in sym:\n-        if sum(c.islower() for c in sym):  # if there is at least one lower case letter\n-            sym = ' '.join(word[0].upper() + word[1:] for word in sym.split())  # Just capitalize initial letter of each word\n-        else:  # CoinGecko may provide full upper-case as for \"THE STONE COIN\"\n-            sym = string.capwords(sym)  # capwords converts \"THE STONE COIN\" to \"The Stone Coin\"\n-        sym = sym.replace(' ', '')  # concatenate words\n-    return sym\n-\n-\n-def is_name_short(coin: dict) -> bool:\n-    \"\"\"return True if the coin name is enough short compared to the coin symbol.\"\"\"\n-    return len(coin['name']) <= max(5, len(coin['symbol']) + 1)\n-\n-\n-def has_many_caps(name: str) -> bool:\n-    \"\"\"return True if the symbol contains enough upper case letters, False if empty.\"\"\"\n-    return str and sum(c.islower() for c in name) < (len(name) / 2)\n-\n-\n-def coingecko_normalize_all(coin: dict):\n-    SYMBOL_TO_NORMALIZED = {'miota': 'IOTA'}\n-    normalized = SYMBOL_TO_NORMALIZED.get(coin['symbol'])\n-    if normalized:\n-        coin['ns'] = coin['nn'] = normalized\n-        return normalized\n-\n-    # ns = normalized symbol, nn = normalized name\n-    coin['ns'] = coingecko_normalize_symbol(coin['symbol'])\n-\n-    ID_SUFFIX = '-bitcoin-token'\n-    if coin['id'][-len(ID_SUFFIX):] == ID_SUFFIX:\n-        coin['nn'] = 'BTC' + coin['ns']\n-        return coin['nn']\n-\n-    name = coin['name']\n-\n-    prefixes = ('The ', 'the ')\n-    for p in prefixes:\n-        if name[:len(p)] == p:\n-            coin['reduced-name'] = True\n-            name = name[len(p):]\n-            break\n-\n-    suffixes = ('coin', 'coins', 'money', 'finance', 'protocol', 'reward', 'rewards', 'token')\n-    for s in suffixes:\n-        if len(name) > len(s) and name[-len(s):].lower() == s:\n-            # but keep suffix when lower-case concatenated\n-            if name[-len(s)].islower() and name[-len(s) - 1] != ' ':\n-                continue\n-            # also keep suffix to avoid confusing nam: \"Bitcoin Token\" -> \"Bitcoin\"\n-            if name[:-len(s)].strip().lower() == 'bitcoin':\n-                continue\n-            coin['reduced-name'] = True\n-            name = name[:-len(s)]\n-            break\n-\n-    coin['nn'] = coingecko_normalize_name(name)\n-\n-    if len(coin['nn']) < len(coin['ns']):\n-        if 'reduced-name' in coin:\n-            coin['reduced-name'] = False\n-            name = coin['name']\n-            coin['nn'] = coingecko_normalize_name(name)\n-        elif not has_many_caps(name):\n-            return coin['ns']\n-\n-    if not coin['ns']:  # coin['symbol'] may be an emoji that is striped when normalized\n-        return coin['nn']\n-\n-    if coin.get('reduced-name') and coin['ns'].upper() != coin['nn'].upper():\n-        return coin['ns']\n-\n-    i = coin['nn'].find('.')  # if there is a dot in normalized name => prefer the normalized symbol\n-    if i >= 0:\n-        if i > 1 and coin['nn'][i - 1].isdigit() and coin['nn'][i + 1].isdigit():\n-            pass  # except when the dot separates digits\n-        else:\n-            return coin['ns']\n-\n-    if is_name_short(coin) and has_many_caps(name):\n-        return coin['nn']\n-\n-    if 1.5 * len(coin['ns']) > len(coin['nn']) and any(c.islower() for c in coin['ns']):\n-        return coin['nn']\n-\n-    return coin['ns']\n-\n-\n-def coingecko_symbols() -> Dict[str, str]:\n-    r = None\n-    intermediate = defaultdict(list)\n-    try:\n-        r = requests.get('https://api.coingecko.com/api/v3/coins/list')\n-        all_coins = r.json()\n-        # First pass: generate & compare normalized symbol/name, and then select the most pertinent\n-        for coin in all_coins:\n-            normalized = coingecko_normalize_all(coin)\n-            intermediate[normalized].append(coin)\n-            # Above line keeps together the coins having the same normalized symbol.\n-            # To reduce collision, the coin['name'] is sometimes used in lieu of the coin['symbol'].\n-            # The coin['name'] is not capitalized because lower case letters may be meaningful: cETH, yUSD, DATx, zLOT\n-    except Exception as why:\n-        raise_failure_explanation('COINGECKO', why, {\"\": r})\n-\n-    final = coingecko_second_pass(intermediate)\n-    return coingecko_third_pass(final)\n-\n-\n-def coingecko_second_pass(intermediate: Dict[str, List[dict]]) -> Dict[str, List[dict]]:\n-    # Second pass: fixes most of the symbol collisions\n-    final = defaultdict(list)\n-    for normalized, coins in intermediate.items():\n-        if len(coins) == 1:\n-            final[normalized].append(coins[0])\n-            continue\n-        set_normalized = False\n-        for i in range(len(coins)):\n-            if normalized == coins[i]['nn']:\n-                coin = coins.pop(i)\n-                final[normalized].append(coin)\n-                set_normalized = True\n-                break\n-        rest: List[dict] = []\n-        for coin in coins:\n-            if '%' in coin['name']:\n-                if len(coins) == 1:\n-                    n = coin['ns']\n-                else:\n-                    n = coingecko_normalize_name(coin['id'])\n-                final[n].append(coin)\n-            else:\n-                rest.append(coin)\n-        if not rest:\n-            continue\n-        if not set_normalized:\n-            rest.sort(key=lambda coin: len(coin['nn']), reverse=True)  # sort by the length of the normalized name\n-            coin = rest.pop(0)\n-            final[normalized].append(coin)\n-        for coin in rest:\n-            if coin['nn'] not in intermediate:\n-                n = coin['nn']\n-            elif coin.get('reduced-name'):\n-                n = coingecko_normalize_name(coin['name'])\n-            else:\n-                n = coingecko_normalize_name(coin['id'])\n-            final[n].append(coin)\n-    return final\n-\n-\n-def coingecko_third_pass(final: Dict[str, List[dict]]) -> Dict[str, str]:\n-    # Third pass: fixes some remaining collisions and fills the result\n-    symbols = {}\n-    for normalized, coins in final.items():\n-        if len(coins) == 1:\n-            symbols[normalized] = coins[0]['id']\n-            continue\n-        set_normalized = False\n-        for i in range(len(coins)):\n-            if normalized == coins[i]['nn']:\n-                coin = coins.pop(i)\n-                symbols[normalized] = coin['id']\n-                set_normalized = True\n-                break\n-        rest: List[dict] = []\n-        for coin in coins:\n-            if '%' in coin['name']:\n-                if len(coins) == 1:\n-                    n = coin['ns']\n-                else:\n-                    n = coingecko_normalize_name(coin['id'])\n-                symbols[n] = coin['id']\n-            else:\n-                rest.append(coin)\n-        if not rest:\n-            continue\n-        if not set_normalized:\n-            rest.sort(key=lambda coin: len(coin['nn']), reverse=True)  # sort by the length of the normalized name\n-            coin = rest.pop(0)\n-            symbols[normalized] = coin['id']\n-        for coin in rest:\n-            if coin['nn'] not in final:\n-                n = coin['nn']\n-            elif coin.get('reduced-name'):\n-                n = coingecko_normalize_name(coin['name'])\n-            else:\n-                n = coingecko_normalize_name(coin['id'])\n-            symbols[n] = coin['id']\n-    return symbols\n-\n-\n-def whale_alert_coins(key_id: str) -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get(f'https://api.whale-alert.io/v1/status?api_key={key_id}')\n-        # Same symbols, but on different blockchains (for instance USDT), are naturally overwritten.\n-        return {s.upper(): s for b in r.json()['blockchains'] for s in b['symbols'] if s}\n-    except Exception as why:\n-        raise_failure_explanation('WHALES_ALERT', why, {\"\": r})\n-\n-\n-_exchange_function_map = {\n-    BITFINEX: bitfinex_symbols,\n-    BITFLYER: bitflyer_symbols,\n-    COINBASE: coinbase_symbols,\n-    GEMINI: gemini_symbols,\n-    HITBTC: hitbtc_symbols,\n-    POLONIEX: poloniex_symbols,\n-    PROBIT: probit_symbols,\n-    BITSTAMP: bitstamp_symbols,\n-    KRAKEN: kraken_symbols,\n-    KRAKEN + 'REST': kraken_rest_symbols,\n-    BINANCE: binance_symbols,\n-    BINANCE_US: binance_us_symbols,\n-    BINANCE_FUTURES: binance_futures_symbols,\n-    BINANCE_DELIVERY: binance_delivery_symbols,\n-    BLOCKCHAIN: blockchain_symbols,\n-    EXX: exx_symbols,\n-    HUOBI: huobi_symbols,\n-    HUOBI_DM: huobi_dm_symbols,\n-    HUOBI_SWAP: huobi_swap_symbols,\n-    OKCOIN: okcoin_symbols,\n-    OKEX: okex_symbols,\n-    BYBIT: bybit_symbols,\n-    FTX: ftx_symbols,\n-    FTX_US: ftx_us_symbols,\n-    BITTREX: bittrex_symbols,\n-    BITCOINCOM: bitcoincom_symbols,\n-    BITMAX: bitmax_symbols,\n-    UPBIT: upbit_symbols,\n-    GATEIO: gateio_symbols,\n-    BITMEX: bitmex_symbols,\n-    DERIBIT: deribit_symbols,\n-    KRAKEN_FUTURES: kraken_future_symbols,\n-    COINGECKO: coingecko_symbols,\n-    WHALE_ALERT: whale_alert_coins\n-}\n+Symbols = _Symbols()\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\n\nimport logging\nimport string\nimport time\nfrom collections import defaultdict\nfrom typing import Dict, List, Optional, Tuple\n\nimport requests\nfrom requests import Response\n\nfrom cryptofeed.defines import *\n\n\nLOG = logging.getLogger('feedhandler')\n\nSYMBOL_SEP = '-'\n\n_symbols_retrieval_cache: Dict[str, Dict[str, str]] = {}\n_exchange_info = defaultdict(lambda: defaultdict(dict))\n\n\n_kraken_futures_product_type = {\n    'FI': 'Inverse Futures',\n    'FV': 'Vanilla Futures',\n    'PI': 'Perpetual Inverse Futures',\n    'PV': 'Perpetual Vanilla Futures',\n    'IN': 'Real Time Index',\n    'RR': 'Reference Rate',\n}\n\n\ndef raise_failure_explanation(feed_id: str, exception: BaseException, responses: Dict[str, Optional[Response]]):\n    <IND>LOG.critical('%s: encountered %r while processing response from exchange API', feed_id, exception)\n    if len(responses) > 1:\n        <IND>LOG.critical('%s: content of one of the %s responses was unexpected', feed_id, len(responses))\n    <DED>for url, r in responses.items():\n        <IND>if url:\n            <IND>LOG.critical('%s: requested URL: %s', feed_id, url)\n        <DED>if r:\n            <IND>LOG.critical('%s: unexpected response: %s', feed_id, r.text)\n    <DED><DED>raise ValueError(f'Cryptofeed stopped because of an unexpected response from {feed_id}') from exception\n\n\n<DED>def set_symbol_separator(separator: str):\n    <IND>global SYMBOL_SEP\n    SYMBOL_SEP = separator\n\n\n<DED>def get_symbol_separator() -> str:\n    <IND>global SYMBOL_SEP\n    return SYMBOL_SEP\n\n\n<DED>def gen_symbols(exchange: str, key_id=None) -> Dict[str, str]:\n    <IND>if exchange not in _symbols_retrieval_cache:\n        <IND>LOG.info(\"%s: Getting list of symbols\", exchange)\n        symbols = _exchange_function_map[exchange](key_id) if key_id else _exchange_function_map[exchange]()\n        LOG.info(\"%s: %s symbols\", exchange, len(symbols))\n\n        # log all retrieved symbols using debug level\n        for normalized, exch_sym in sorted(symbols.items()):\n            <IND>LOG.debug('%s: id-from-exch -> normalized: %-35s-> %s', exchange, exch_sym, normalized)\n\n        <DED>_symbols_retrieval_cache[exchange] = symbols\n    <DED>return _symbols_retrieval_cache[exchange]\n\n\n<DED>def _binance_symbols(endpoint: str, exchange: str):\n    <IND>r = None\n    try:\n        <IND>ret = {}\n        r = requests.get(endpoint)\n        for symbol in r.json()['symbols']:\n            <IND>if symbol.get('status', 'TRADING') != \"TRADING\":\n                <IND>continue\n            <DED>if symbol.get('contractStatus', 'TRADING') != \"TRADING\":\n                <IND>continue\n            <DED>split = len(symbol['baseAsset'])\n            normalized = symbol['symbol'][:split] + SYMBOL_SEP + symbol['symbol'][split:]\n            ret[normalized] = symbol['symbol']\n            _exchange_info[exchange]['tick_size'][normalized] = symbol['filters'][0]['tickSize']\n            if \"contractType\" in symbol:\n                <IND>_exchange_info[exchange]['contract_type'][normalized] = symbol['contractType']\n        <DED><DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation(exchange, why, {endpoint: r})\n\n\n<DED><DED>def binance_symbols() -> Dict[str, str]:\n    <IND>return _binance_symbols('https://api.binance.com/api/v3/exchangeInfo', BINANCE)\n\n\n<DED>def binance_us_symbols() -> Dict[str, str]:\n    <IND>return _binance_symbols('https://api.binance.us/api/v3/exchangeInfo', BINANCE_US)\n\n\n<DED>def binance_futures_symbols() -> Dict[str, str]:\n    <IND>base = _binance_symbols('https://fapi.binance.com/fapi/v1/exchangeInfo', BINANCE_FUTURES)\n    add = {}\n    for symbol, orig in base.items():\n        <IND>if \"_\" in orig:\n            <IND>continue\n        <DED>add[f\"{symbol}-PINDEX\"] = f\"p{orig}\"\n    <DED>base.update(add)\n    return base\n\n\n<DED>def binance_delivery_symbols() -> Dict[str, str]:\n    <IND>return _binance_symbols('https://dapi.binance.com/dapi/v1/exchangeInfo', BINANCE_DELIVERY)\n\n\n<DED>def bitfinex_symbols() -> Dict[str, str]:\n    # doc: https://docs.bitfinex.com/docs/ws-general#supported-pairs\n    <IND>r1 = r2 = None\n    try:\n        <IND>r1 = requests.get('https://api.bitfinex.com/v2/tickers?symbols=ALL')\n        r2 = requests.get('https://api-pub.bitfinex.com/v2/conf/pub:map:currency:sym')\n        tickers: List[List[str]] = r1.json()\n        norm: List[Tuple[str, str]] = r2.json()[0]\n        norm: Dict[str, str] = dict(norm)\n        for k, v in dict(norm).items():\n            <IND>if k[-2:] == 'F0' or '-' in v:  # Do not convert BTCF0 -> BTC or PBTCETH -> PBTC-ETH\n                <IND>del norm[k]\n        <DED><DED>norm['BCHN'] = 'BCH'  # Bitfinex uses BCHN, other exchanges use BCH\n\n        ret = {}\n        for symbol in [t[0] for t in tickers]:\n            <IND>if symbol[0] == 'f':\n                <IND>normalized = norm.get(symbol[1:], symbol[1:])\n            <DED>else:\n                <IND>if len(symbol) == 7:\n                    <IND>base, quote = symbol[1:4], symbol[4:]\n                <DED>else:\n                    <IND>base, quote = symbol[1:].split(':')\n                    assert ':' in symbol\n                <DED>normalized = norm.get(base, base) + SYMBOL_SEP + norm.get(quote, quote)\n            <DED>ret[normalized.upper()] = symbol\n        <DED>return ret\n    <DED>except ValueError as why:\n        <IND>raise_failure_explanation('BITFINEX', why, {\"tickers?symbols=ALL\": r1, \"pub:map:currency:sym\": r2})\n\n\n<DED><DED>def bitflyer_symbols() -> Dict[str, str]:\n    <IND>endpoint = r = None\n    try:\n        <IND>ret = {}\n        endpoints = ['https://api.bitflyer.com/v1/getmarkets/eu', 'https://api.bitflyer.com/v1/getmarkets/usa', 'https://api.bitflyer.com/v1/getmarkets']\n        for endpoint in endpoints:\n            <IND>r = requests.get(endpoint)\n            for entry in r.json():\n                <IND>normalized = entry['product_code'].replace(\"_\", SYMBOL_SEP)\n                ret[normalized] = entry['product_code']\n        <DED><DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BITFLYER', why, {endpoint: r})\n\n\n<DED><DED>def bybit_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.bybit.com/v2/public/symbols')\n        ret = {}\n        for symbol in r.json()['result']:\n            <IND>quote = symbol['quote_currency']\n            if not symbol['name'].endswith(quote):\n                <IND>base, contract = symbol['name'].split(quote)\n                normalized = f\"{base}{SYMBOL_SEP}{quote}-{contract}\"\n            <DED>else:\n                <IND>normalized = f\"{symbol['base_currency']}{SYMBOL_SEP}{quote}\"\n            <DED>ret[normalized] = symbol['name']\n            _exchange_info[BYBIT]['tick_size'][normalized] = symbol['price_filter']['tick_size']\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BYBIT', why, {\"\": r})\n\n\n<DED><DED>def _ftx_helper(endpoint: str, exchange: str):\n    <IND>r = None\n    try:\n        <IND>r = requests.get(endpoint)\n        ret = {}\n        for data in r.json()['result']:\n            <IND>normalized = data['name'].replace(\"/\", SYMBOL_SEP)\n            symbol = data['name']\n            ret[normalized] = symbol\n            _exchange_info[exchange]['tick_size'][normalized] = data['priceIncrement']\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation(exchange, why, {endpoint: r})\n\n\n<DED><DED>def ftx_symbols() -> Dict[str, str]:\n    <IND>return _ftx_helper('https://ftx.com/api/markets', FTX)\n\n\n<DED>def ftx_us_symbols() -> Dict[str, str]:\n    <IND>return _ftx_helper('https://ftx.us/api/markets', FTX_US)\n\n\n<DED>def coinbase_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.pro.coinbase.com/products')\n        ret = {}\n        for data in r.json():\n            <IND>normalized = data['id'].replace(\"-\", SYMBOL_SEP)\n            ret[normalized] = data['id']\n            _exchange_info[COINBASE]['tick_size'][normalized] = data['quote_increment']\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('COINBASE', why, {\"\": r})\n\n\n<DED><DED>def gemini_symbols(*args) -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.gemini.com/v1/symbols')\n        ret = {}\n        for symbol in r.json():\n            <IND>std = f\"{symbol[:-3]}{SYMBOL_SEP}{symbol[-3:]}\"\n            std = std.upper()\n            ret[std] = symbol.upper()\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('GEMINI', why, {\"\": r})\n\n\n<DED><DED>def hitbtc_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>ret = {}\n        r = requests.get('https://api.hitbtc.com/api/2/public/symbol')\n        for symbol in r.json():\n            <IND>split = len(symbol['baseCurrency'])\n            normalized = symbol['id'][:split] + SYMBOL_SEP + symbol['id'][split:]\n            ret[normalized] = symbol['id']\n            _exchange_info[HITBTC]['tick_size'][normalized] = symbol['tickSize']\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('HITBTC', why, {\"\": r})\n\n\n<DED><DED>def poloniex_id_symbol_mapping():\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://poloniex.com/public?command=returnTicker')\n        symbols = r.json()\n        ret = {}\n        for symbol in symbols:\n            <IND>ret[symbols[symbol]['id']] = symbol\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('POLONIEX', why, {\"\": r})\n\n\n<DED><DED>def poloniex_symbols() -> Dict[str, str]:\n    <IND>ret = {}\n    for _, value in poloniex_id_symbol_mapping().items():\n        <IND>std = value.replace(\"STR\", \"XLM\")\n        quote, base = std.split(\"_\")\n        ret[quote + SYMBOL_SEP + base] = value\n    <DED>return ret\n\n\n<DED>def bitstamp_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://www.bitstamp.net/api/v2/trading-pairs-info/')\n        ret = {}\n        for data in r.json():\n            <IND>normalized = data['name'].replace(\"/\", SYMBOL_SEP)\n            symbol = data['url_symbol']\n            ret[normalized] = symbol\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BITSTAMP', why, {\"\": r})\n\n\n<DED><DED>def kraken_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.kraken.com/0/public/AssetPairs')\n        data = r.json()\n        ret = {}\n        for symbol in data['result']:\n            <IND>if 'wsname' not in data['result'][symbol] or '.d' in symbol:\n                # https://blog.kraken.com/post/259/introducing-the-kraken-dark-pool/\n                # .d is for dark pool symbols\n                <IND>continue\n\n            <DED>base, quote = data['result'][symbol]['wsname'].split(\"/\")\n\n            normalized = f\"{base}{SYMBOL_SEP}{quote}\"\n            exch = data['result'][symbol]['wsname']\n            normalized = normalized.replace('XBT', 'BTC')\n            normalized = normalized.replace('XDG', 'DOG')\n            ret[normalized] = exch\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('KRAKEN', why, {\"\": r})\n\n\n<DED><DED>def kraken_rest_symbols() -> Dict[str, str]:\n    <IND>return {normalized: exchange.replace(\"/\", \"\") for normalized, exchange in kraken_symbols().items()}\n\n\n<DED>def exx_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.exx.com/data/v1/tickers')\n        exchange = [key.upper() for key in r.json().keys()]\n        symbols = [key.replace(\"_\", SYMBOL_SEP) for key in exchange]\n        return dict(zip(symbols, exchange))\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('EXX', why, {\"\": r})\n\n\n<DED><DED>def huobi_common_symbols(url: str):\n    <IND>r = None\n    try:\n        <IND>r = requests.get(url)\n        ret = {}\n        for e in r.json()['data']:\n            <IND>if e['state'] == 'offline':\n                <IND>continue\n            <DED>normalized = f\"{e['base-currency'].upper()}{SYMBOL_SEP}{e['quote-currency'].upper()}\"\n            symbol = f\"{e['base-currency']}{e['quote-currency']}\"\n            ret[normalized] = symbol\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('HUOBI', why, {url: r})\n\n\n<DED><DED>def huobi_symbols() -> Dict[str, str]:\n    <IND>return huobi_common_symbols('https://api.huobi.pro/v1/common/symbols')\n\n\n<DED>def huobi_us_symbols() -> Dict[str, str]:\n    <IND>return huobi_common_symbols('https://api.huobi.com/v1/common/symbols')\n\n\n<DED>def huobi_dm_symbols() -> Dict[str, str]:\n    <IND>\"\"\"\n    Mapping is, for instance: {\"BTC_CW\":\"BTC190816\"}\n    See comments in exchange/huobi_dm.py\n    \"\"\"\n    mapping = {\n        \"this_week\": \"CW\",\n        \"next_week\": \"NW\",\n        \"quarter\": \"CQ\",\n        \"next_quarter\": \"NQ\"\n    }\n    r = None\n    try:\n        <IND>r = requests.get('https://www.hbdm.com/api/v1/contract_contract_info')\n        symbols = {}\n        for e in r.json()['data']:\n            <IND>symbols[f\"{e['symbol']}_{mapping[e['contract_type']]}\"] = e['contract_code']\n            _exchange_info[HUOBI_DM]['tick_size'][e['contract_code']] = e['price_tick']\n            _exchange_info[HUOBI_DM]['short_code_mappings'][f\"{e['symbol']}_{mapping[e['contract_type']]}\"] = e['contract_code']\n        <DED>return symbols\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('HUOBI_DM', why, {\"\": r})\n\n\n<DED><DED>def huobi_swap_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.hbdm.com/swap-api/v1/swap_contract_info')\n        symbols = {}\n        for e in r.json()['data']:\n            <IND>symbols[e['contract_code']] = e['contract_code']\n            _exchange_info[HUOBI_SWAP]['tick_size'][e['contract_code']] = e['price_tick']\n        <DED>return symbols\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('HUOBI_SWAP', why, {\"\": r})\n\n\n<DED><DED>def okcoin_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://www.okcoin.com/api/spot/v3/instruments')\n        ret = {}\n        for e in r.json():\n            <IND>ret[e['instrument_id']] = e['instrument_id']\n            _exchange_info[OKCOIN]['tick_size'][e['instrument_id']] = e['tick_size']\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('OKCOIN', why, {\"\": r})\n\n\n<DED><DED>def okex_symbols(*args) -> Dict[str, str]:\n    <IND>urls = ['https://www.okex.com/api/spot/v3/instruments',\n            'https://www.okex.com/api/swap/v3/instruments',\n            'https://www.okex.com/api/futures/v3/instruments']\n    urls = urls + okex_compute_option_urls_from_underlyings()\n\n    symbols: Dict[str, str] = {}\n    for u in urls:\n        <IND>time.sleep(0.2)\n        symbols.update(okex_symbols_from_one_url(u))\n\n    <DED>for symbol in symbols:\n        <IND>instrument_type = 'futures'\n        dash_count = symbol.count(get_symbol_separator())\n        if dash_count == 1:  # BTC-USDT\n            <IND>instrument_type = 'spot'\n        <DED>if dash_count == 4:  # BTC-USD-201225-35000-P\n            <IND>instrument_type = 'option'\n        <DED>if symbol[-4:] == \"SWAP\":  # BTC-USDT-SWAP\n            <IND>instrument_type = 'swap'\n\n        <DED>_exchange_info[OKEX]['instrument_type'][symbol] = instrument_type\n\n    <DED>return symbols\n\n\n<DED>def okex_compute_option_urls_from_underlyings() -> List[str]:\n    <IND>url = 'https://www.okex.com/api/option/v3/underlying'\n    r = None\n    try:\n        <IND>r = requests.get(url)\n        return [f'https://www.okex.com/api/option/v3/instruments/{underlying}' for underlying in r.json()]\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('OKEX', why, {url: r})\n\n\n<DED><DED>def okex_symbols_from_one_url(url: str) -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get(url)\n        ret = {}\n        for e in r.json():\n            <IND>ret[e['instrument_id']] = e['instrument_id']\n            _exchange_info[OKEX]['tick_size'][e['instrument_id']] = e['tick_size']\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('OKEX', why, {url: r})\n\n\n<DED><DED>def bittrex_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.bittrex.com/api/v1.1/public/getmarkets')\n        r = r.json()['result']\n        return {f\"{e['MarketCurrency']}{SYMBOL_SEP}{e['BaseCurrency']}\": e['MarketName'] for e in r if e['IsActive']}\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BITTREX', why, {\"\": r})\n\n\n<DED><DED>def bitcoincom_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.exchange.bitcoin.com/api/2/public/symbol')\n        return {f\"{data['baseCurrency']}{SYMBOL_SEP}{data['quoteCurrency'].replace('USD', 'USDT')}\": data['id'] for data in r.json()}\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BITCOINCOM', why, {\"\": r})\n\n\n<DED><DED>def bitmax_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://bitmax.io/api/pro/v1/products')\n        ret = {}\n        for entry in r.json()['data']:\n            # Only \"Normal\" status symbols are tradeable\n            <IND>if entry['status'] == 'Normal':\n                <IND>normalized = f\"{entry['baseAsset']}{SYMBOL_SEP}{entry['quoteAsset']}\"\n                ret[normalized] = entry['symbol']\n                _exchange_info[BITMAX]['tick_size'][normalized] = entry['tickSize']\n        <DED><DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BITMAX', why, {\"\": r})\n\n\n<DED><DED>def upbit_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.upbit.com/v1/market/all')\n        return {f\"{data['market'].split('-')[1]}{SYMBOL_SEP}{data['market'].split('-')[0]}\": data['market'] for data in r.json()}\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('UPBIT', why, {\"\": r})\n\n\n<DED><DED>def blockchain_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get(\"https://api.blockchain.com/mercury-gateway/v1/instruments\")\n        return {data[\"symbol\"].replace(\"-\", SYMBOL_SEP): data[\"symbol\"] for data in r.json()}\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BLOCKCHAIN', why, {\"\": r})\n\n\n<DED><DED>def gateio_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get(\"https://api.gateio.ws/api/v4/spot/currency_pairs\")\n        return {data[\"id\"].replace(\"_\", SYMBOL_SEP): data['id'] for data in r.json()}\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('GATEIO', why, {\"\": r})\n\n\n<DED><DED>def bitmex_symbols() -> Dict[str, str]:\n    <IND>r = None\n    ret = {}\n    try:\n        <IND>r = requests.get(\"https://www.bitmex.com/api/v1/instrument/active\")\n        for entry in r.json():\n            <IND>components = []\n            components.append(entry['rootSymbol'])\n            components.append(entry['quoteCurrency'])\n\n            if entry['expiry']:\n                <IND>components.append(entry['symbol'][-3:])\n\n            <DED>normalized = SYMBOL_SEP.join(components)\n            normalized = normalized.replace(\"XBT\", \"BTC\")\n            ret[normalized] = entry['symbol']\n            _exchange_info[BITMEX]['tick_size'][normalized] = entry['tickSize']\n\n            if entry['expiry']:\n                <IND>_exchange_info[BITMEX]['expiry'][normalized] = entry['expiry']\n\n        <DED><DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BITMEX', why, {\"\": r})\n\n\n<DED><DED>def deribit_symbols() -> Dict[str, str]:\n    <IND>url = r = None\n    ret = {}\n    try:\n        # TODO: get currencies from https://www.deribit.com/api/v2/public/get_currencies\n        <IND>currencies = ['BTC', 'ETH']\n        for c in currencies:\n            <IND>url = f\"https://www.deribit.com/api/v2/public/get_instruments?currency={c}&expired=false\"\n            r = requests.get(url)\n            for entry in r.json()['result']:\n                <IND>split = entry['instrument_name'].split(\"-\")\n                normalized = split[0] + SYMBOL_SEP + entry['quote_currency'] + \"-\" + '-'.join(split[1:])\n                ret[normalized] = entry['instrument_name']\n                _exchange_info[DERIBIT]['tick_size'][normalized] = entry['tick_size']\n        <DED><DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('DERIBIT', why, {url: r})\n\n\n<DED><DED>def kraken_future_symbols() -> Dict[str, str]:\n    <IND>r = None\n    ret = {}\n    try:\n        <IND>r = requests.get('https://futures.kraken.com/derivatives/api/v3/instruments')\n        data = r.json()['instruments']\n        for entry in data:\n            <IND>if not entry['tradeable']:\n                <IND>continue\n            <DED>normalized = entry['symbol'].upper().replace(\"_\", \"-\")\n            symbol = normalized[3:6] + SYMBOL_SEP + normalized[6:9]\n            normalized = normalized.replace(normalized[3:9], symbol)\n            normalized = normalized.replace('XBT', 'BTC')\n\n            _exchange_info[KRAKEN_FUTURES]['tick_size'][normalized] = entry['tickSize']\n            _exchange_info[KRAKEN_FUTURES]['contract_size'][normalized] = entry['contractSize']\n            _exchange_info[KRAKEN_FUTURES]['underlying'][normalized] = entry['underlying']\n            _exchange_info[KRAKEN_FUTURES]['product_type'][normalized] = _kraken_futures_product_type[normalized[:2]]\n            ret[normalized] = entry['symbol']\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('KRAKEN_FUTURES', why, {\"\": r})\n\n\n<DED><DED>def probit_symbols() -> Dict[str, str]:\n    # doc: https://docs-en.probit.com/reference-link/market\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.probit.com/api/exchange/v1/market')\n        return {entry['id']: entry['id'] for entry in r.json()['data']}\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('PROBIT', why, {\"\": r})\n\n\n<DED><DED>def coingecko_normalize_symbol(symbol: str) -> str:\n    # keep digits, letters and dots, replace others by space\n    <IND>symbol = ''.join(c if c.isalnum() or c in ('.', '+') else ' ' for c in symbol)\n    return coingecko_normalize(symbol.upper())\n\n\n<DED>def coingecko_normalize_name(name: str) -> str:\n    # keep digits and letters, replace others by space (except when only composed by upper case letters, digits and dots)\n    <IND>if not all(c.isupper() or c.isdigit() or c == '.' for c in name):\n        <IND>name = ''.join(c if c.isalnum() else ' ' for c in name)\n    <DED>return coingecko_normalize(name)\n\n\n<DED>def coingecko_normalize(sym: str) -> str:\n    <IND>sym = sym.strip()\n    # do not concatenate numbers => separate them with a dot\n    sym = list(sym)\n    if len(sym) > 4:\n        <IND>for i in range(2, len(sym) - 1):\n            <IND>if sym[i] == ' ' and sym[i - 1].isdigit() and sym[i + 1].isdigit():\n                <IND>sym[i] = '.'\n    <DED><DED><DED>sym = ''.join(sym)\n    # concatenate space-separated words => use CamelCase to distinguish the words\n    if ' ' in sym:\n        <IND>if sum(c.islower() for c in sym):  # if there is at least one lower case letter\n            <IND>sym = ' '.join(word[0].upper() + word[1:] for word in sym.split())  # Just capitalize initial letter of each word\n        <DED>else:  # CoinGecko may provide full upper-case as for \"THE STONE COIN\"\n            <IND>sym = string.capwords(sym)  # capwords converts \"THE STONE COIN\" to \"The Stone Coin\"\n        <DED>sym = sym.replace(' ', '')  # concatenate words\n    <DED>return sym\n\n\n<DED>def is_name_short(coin: dict) -> bool:\n    <IND>\"\"\"return True if the coin name is enough short compared to the coin symbol.\"\"\"\n    return len(coin['name']) <= max(5, len(coin['symbol']) + 1)\n\n\n<DED>def has_many_caps(name: str) -> bool:\n    <IND>\"\"\"return True if the symbol contains enough upper case letters, False if empty.\"\"\"\n    return str and sum(c.islower() for c in name) < (len(name) / 2)\n\n\n<DED>def coingecko_normalize_all(coin: dict):\n    <IND>SYMBOL_TO_NORMALIZED = {'miota': 'IOTA'}\n    normalized = SYMBOL_TO_NORMALIZED.get(coin['symbol'])\n    if normalized:\n        <IND>coin['ns'] = coin['nn'] = normalized\n        return normalized\n\n    # ns = normalized symbol, nn = normalized name\n    <DED>coin['ns'] = coingecko_normalize_symbol(coin['symbol'])\n\n    ID_SUFFIX = '-bitcoin-token'\n    if coin['id'][-len(ID_SUFFIX):] == ID_SUFFIX:\n        <IND>coin['nn'] = 'BTC' + coin['ns']\n        return coin['nn']\n\n    <DED>name = coin['name']\n\n    prefixes = ('The ', 'the ')\n    for p in prefixes:\n        <IND>if name[:len(p)] == p:\n            <IND>coin['reduced-name'] = True\n            name = name[len(p):]\n            break\n\n    <DED><DED>suffixes = ('coin', 'coins', 'money', 'finance', 'protocol', 'reward', 'rewards', 'token')\n    for s in suffixes:\n        <IND>if len(name) > len(s) and name[-len(s):].lower() == s:\n            # but keep suffix when lower-case concatenated\n            <IND>if name[-len(s)].islower() and name[-len(s) - 1] != ' ':\n                <IND>continue\n            # also keep suffix to avoid confusing nam: \"Bitcoin Token\" -> \"Bitcoin\"\n            <DED>if name[:-len(s)].strip().lower() == 'bitcoin':\n                <IND>continue\n            <DED>coin['reduced-name'] = True\n            name = name[:-len(s)]\n            break\n\n    <DED><DED>coin['nn'] = coingecko_normalize_name(name)\n\n    if len(coin['nn']) < len(coin['ns']):\n        <IND>if 'reduced-name' in coin:\n            <IND>coin['reduced-name'] = False\n            name = coin['name']\n            coin['nn'] = coingecko_normalize_name(name)\n        <DED>elif not has_many_caps(name):\n            <IND>return coin['ns']\n\n    <DED><DED>if not coin['ns']:  # coin['symbol'] may be an emoji that is striped when normalized\n        <IND>return coin['nn']\n\n    <DED>if coin.get('reduced-name') and coin['ns'].upper() != coin['nn'].upper():\n        <IND>return coin['ns']\n\n    <DED>i = coin['nn'].find('.')  # if there is a dot in normalized name => prefer the normalized symbol\n    if i >= 0:\n        <IND>if i > 1 and coin['nn'][i - 1].isdigit() and coin['nn'][i + 1].isdigit():\n            <IND>pass  # except when the dot separates digits\n        <DED>else:\n            <IND>return coin['ns']\n\n    <DED><DED>if is_name_short(coin) and has_many_caps(name):\n        <IND>return coin['nn']\n\n    <DED>if 1.5 * len(coin['ns']) > len(coin['nn']) and any(c.islower() for c in coin['ns']):\n        <IND>return coin['nn']\n\n    <DED>return coin['ns']\n\n\n<DED>def coingecko_symbols() -> Dict[str, str]:\n    <IND>r = None\n    intermediate = defaultdict(list)\n    try:\n        <IND>r = requests.get('https://api.coingecko.com/api/v3/coins/list')\n        all_coins = r.json()\n        # First pass: generate & compare normalized symbol/name, and then select the most pertinent\n        for coin in all_coins:\n            <IND>normalized = coingecko_normalize_all(coin)\n            intermediate[normalized].append(coin)\n            # Above line keeps together the coins having the same normalized symbol.\n            # To reduce collision, the coin['name'] is sometimes used in lieu of the coin['symbol'].\n            # The coin['name'] is not capitalized because lower case letters may be meaningful: cETH, yUSD, DATx, zLOT\n    <DED><DED>except Exception as why:\n        <IND>raise_failure_explanation('COINGECKO', why, {\"\": r})\n\n    <DED>final = coingecko_second_pass(intermediate)\n    return coingecko_third_pass(final)\n\n\n<DED>def coingecko_second_pass(intermediate: Dict[str, List[dict]]) -> Dict[str, List[dict]]:\n    # Second pass: fixes most of the symbol collisions\n    <IND>final = defaultdict(list)\n    for normalized, coins in intermediate.items():\n        <IND>if len(coins) == 1:\n            <IND>final[normalized].append(coins[0])\n            continue\n        <DED>set_normalized = False\n        for i in range(len(coins)):\n            <IND>if normalized == coins[i]['nn']:\n                <IND>coin = coins.pop(i)\n                final[normalized].append(coin)\n                set_normalized = True\n                break\n        <DED><DED>rest: List[dict] = []\n        for coin in coins:\n            <IND>if '%' in coin['name']:\n                <IND>if len(coins) == 1:\n                    <IND>n = coin['ns']\n                <DED>else:\n                    <IND>n = coingecko_normalize_name(coin['id'])\n                <DED>final[n].append(coin)\n            <DED>else:\n                <IND>rest.append(coin)\n        <DED><DED>if not rest:\n            <IND>continue\n        <DED>if not set_normalized:\n            <IND>rest.sort(key=lambda coin: len(coin['nn']), reverse=True)  # sort by the length of the normalized name\n            coin = rest.pop(0)\n            final[normalized].append(coin)\n        <DED>for coin in rest:\n            <IND>if coin['nn'] not in intermediate:\n                <IND>n = coin['nn']\n            <DED>elif coin.get('reduced-name'):\n                <IND>n = coingecko_normalize_name(coin['name'])\n            <DED>else:\n                <IND>n = coingecko_normalize_name(coin['id'])\n            <DED>final[n].append(coin)\n    <DED><DED>return final\n\n\n<DED>def coingecko_third_pass(final: Dict[str, List[dict]]) -> Dict[str, str]:\n    # Third pass: fixes some remaining collisions and fills the result\n    <IND>symbols = {}\n    for normalized, coins in final.items():\n        <IND>if len(coins) == 1:\n            <IND>symbols[normalized] = coins[0]['id']\n            continue\n        <DED>set_normalized = False\n        for i in range(len(coins)):\n            <IND>if normalized == coins[i]['nn']:\n                <IND>coin = coins.pop(i)\n                symbols[normalized] = coin['id']\n                set_normalized = True\n                break\n        <DED><DED>rest: List[dict] = []\n        for coin in coins:\n            <IND>if '%' in coin['name']:\n                <IND>if len(coins) == 1:\n                    <IND>n = coin['ns']\n                <DED>else:\n                    <IND>n = coingecko_normalize_name(coin['id'])\n                <DED>symbols[n] = coin['id']\n            <DED>else:\n                <IND>rest.append(coin)\n        <DED><DED>if not rest:\n            <IND>continue\n        <DED>if not set_normalized:\n            <IND>rest.sort(key=lambda coin: len(coin['nn']), reverse=True)  # sort by the length of the normalized name\n            coin = rest.pop(0)\n            symbols[normalized] = coin['id']\n        <DED>for coin in rest:\n            <IND>if coin['nn'] not in final:\n                <IND>n = coin['nn']\n            <DED>elif coin.get('reduced-name'):\n                <IND>n = coingecko_normalize_name(coin['name'])\n            <DED>else:\n                <IND>n = coingecko_normalize_name(coin['id'])\n            <DED>symbols[n] = coin['id']\n    <DED><DED>return symbols\n\n\n<DED>def whale_alert_coins(key_id: str) -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get(f'https://api.whale-alert.io/v1/status?api_key={key_id}')\n        # Same symbols, but on different blockchains (for instance USDT), are naturally overwritten.\n        return {s.upper(): s for b in r.json()['blockchains'] for s in b['symbols'] if s}\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('WHALES_ALERT', why, {\"\": r})\n\n\n<DED><DED>_exchange_function_map = {\n    BITFINEX: bitfinex_symbols,\n    BITFLYER: bitflyer_symbols,\n    COINBASE: coinbase_symbols,\n    GEMINI: gemini_symbols,\n    HITBTC: hitbtc_symbols,\n    POLONIEX: poloniex_symbols,\n    PROBIT: probit_symbols,\n    BITSTAMP: bitstamp_symbols,\n    KRAKEN: kraken_symbols,\n    KRAKEN + 'REST': kraken_rest_symbols,\n    BINANCE: binance_symbols,\n    BINANCE_US: binance_us_symbols,\n    BINANCE_FUTURES: binance_futures_symbols,\n    BINANCE_DELIVERY: binance_delivery_symbols,\n    BLOCKCHAIN: blockchain_symbols,\n    EXX: exx_symbols,\n    HUOBI: huobi_symbols,\n    HUOBI_DM: huobi_dm_symbols,\n    HUOBI_SWAP: huobi_swap_symbols,\n    OKCOIN: okcoin_symbols,\n    OKEX: okex_symbols,\n    BYBIT: bybit_symbols,\n    FTX: ftx_symbols,\n    FTX_US: ftx_us_symbols,\n    BITTREX: bittrex_symbols,\n    BITCOINCOM: bitcoincom_symbols,\n    BITMAX: bitmax_symbols,\n    UPBIT: upbit_symbols,\n    GATEIO: gateio_symbols,\n    BITMEX: bitmex_symbols,\n    DERIBIT: deribit_symbols,\n    KRAKEN_FUTURES: kraken_future_symbols,\n    COINGECKO: coingecko_symbols,\n    WHALE_ALERT: whale_alert_coins\n}\n",
        "target_code_with_indent": "\nfrom typing import Dict, Tuple\n\n\nclass _Symbols:\n    <IND>def __init__(self):\n        <IND>self.data = {}\n\n    <DED>def set(self, exchange: str, normalized: dict, exchange_info: dict):\n        <IND>self.data[exchange] = {}\n        self.data[exchange]['normalized'] = normalized\n        self.data[exchange]['info'] = exchange_info\n\n    <DED>def get(self, exchange: str) -> Tuple[Dict, Dict]:\n        <IND>return self.data[exchange]['normalized'], self.data[exchange]['info']\n\n    <DED>def populated(self, exchange: str) -> bool:\n        <IND>return exchange in self.data\n\n\n<DED><DED>Symbols = _Symbols()\n"
      }
    ]
  },
  {
    "project": "bmoscon/cryptofeed",
    "commit": "3525dc8ce4d7836a9abaaa5662e58e5e27969a77",
    "filename": "cryptofeed/symbols.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/bmoscon-cryptofeed/cryptofeed/symbols.py",
    "file_hunks_size": 1,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "cryptofeed/symbols.py:309:8 Incompatible return type [7]: Expected `Dict[str, str]` but got implicit return value of `None`.",
    "message": " Expected `Dict[str, str]` but got implicit return value of `None`.",
    "rule_id": "Incompatible return type [7]",
    "warning_line_no": 309,
    "warning_line": "        raise_failure_explanation('KRAKEN', why, {\"\": r})",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "associated with this software.\n\n\nSymbol generation code for exchanges\n'''\n\nimport logging\nimport string\nimport time\nfrom collections import defaultdict\nfrom typing import Dict, List, Optional, Tuple\n\nimport requests\nfrom requests import Response\n\nfrom cryptofeed.defines import *\n\n\nLOG = logging.getLogger('feedhandler')\n\nSYMBOL_SEP = '-'\n\n_symbols_retrieval_cache: Dict[str, Dict[str, str]] = {}\n_exchange_info = defaultdict(lambda: defaultdict(dict))\n\n\n_kraken_futures_product_type = {\n    'FI': 'Inverse Futures',\n    'FV': 'Vanilla Futures',\n    'PI': 'Perpetual Inverse Futures',\n    'PV': 'Perpetual Vanilla Futures',\n    'IN': 'Real Time Index',\n    'RR': 'Reference Rate',\n}\n\n\ndef raise_failure_explanation(feed_id: str, exception: BaseException, responses: Dict[str, Optional[Response]]):\n    LOG.critical('%s: encountered %r while processing response from exchange API', feed_id, exception)\n    if len(responses) > 1:\n        LOG.critical('%s: content of one of the %s responses was unexpected', feed_id, len(responses))\n    for url, r in responses.items():\n        if url:\n            LOG.critical('%s: requested URL: %s', feed_id, url)\n        if r:\n            LOG.critical('%s: unexpected response: %s', feed_id, r.text)\n    raise ValueError(f'Cryptofeed stopped because of an unexpected response from {feed_id}') from exception\n\n\ndef set_symbol_separator(separator: str):\n    global SYMBOL_SEP\n    SYMBOL_SEP = separator\n\n\ndef get_symbol_separator() -> str:\n    global SYMBOL_SEP\n    return SYMBOL_SEP\n\n\ndef gen_symbols(exchange: str, key_id=None) -> Dict[str, str]:\n    if exchange not in _symbols_retrieval_cache:\n        LOG.info(\"%s: Getting list of symbols\", exchange)\n        symbols = _exchange_function_map[exchange](key_id) if key_id else _exchange_function_map[exchange]()\n        LOG.info(\"%s: %s symbols\", exchange, len(symbols))\n\n        # log all retrieved symbols using debug level\n        for normalized, exch_sym in sorted(symbols.items()):\n            LOG.debug('%s: id-from-exch -> normalized: %-35s-> %s', exchange, exch_sym, normalized)\n\n        _symbols_retrieval_cache[exchange] = symbols\n    return _symbols_retrieval_cache[exchange]\n\n\ndef _binance_symbols(endpoint: str, exchange: str):\n    r = None\n    try:\n        ret = {}\n        r = requests.get(endpoint)\n        for symbol in r.json()['symbols']:\n            if symbol.get('status', 'TRADING') != \"TRADING\":\n                continue\n            if symbol.get('contractStatus', 'TRADING') != \"TRADING\":\n                continue\n            split = len(symbol['baseAsset'])\n            normalized = symbol['symbol'][:split] + SYMBOL_SEP + symbol['symbol'][split:]\n            ret[normalized] = symbol['symbol']\n            _exchange_info[exchange]['tick_size'][normalized] = symbol['filters'][0]['tickSize']\n            if \"contractType\" in symbol:\n                _exchange_info[exchange]['contract_type'][normalized] = symbol['contractType']\n        return ret\n    except Exception as why:\n        raise_failure_explanation(exchange, why, {endpoint: r})\n\n\ndef binance_symbols() -> Dict[str, str]:\n    return _binance_symbols('https://api.binance.com/api/v3/exchangeInfo', BINANCE)\n\n\ndef binance_us_symbols() -> Dict[str, str]:\n    return _binance_symbols('https://api.binance.us/api/v3/exchangeInfo', BINANCE_US)\n\n\ndef binance_futures_symbols() -> Dict[str, str]:\n    base = _binance_symbols('https://fapi.binance.com/fapi/v1/exchangeInfo', BINANCE_FUTURES)\n    add = {}\n    for symbol, orig in base.items():\n        if \"_\" in orig:\n            continue\n        add[f\"{symbol}-PINDEX\"] = f\"p{orig}\"\n    base.update(add)\n    return base\n\n\ndef binance_delivery_symbols() -> Dict[str, str]:\n    return _binance_symbols('https://dapi.binance.com/dapi/v1/exchangeInfo', BINANCE_DELIVERY)\n\n\ndef bitfinex_symbols() -> Dict[str, str]:\n    # doc: https://docs.bitfinex.com/docs/ws-general#supported-pairs\n    r1 = r2 = None\n    try:\n        r1 = requests.get('https://api.bitfinex.com/v2/tickers?symbols=ALL')\n        r2 = requests.get('https://api-pub.bitfinex.com/v2/conf/pub:map:currency:sym')\n        tickers: List[List[str]] = r1.json()\n        norm: List[Tuple[str, str]] = r2.json()[0]\n        norm: Dict[str, str] = dict(norm)\n        for k, v in dict(norm).items():\n            if k[-2:] == 'F0' or '-' in v:  # Do not convert BTCF0 -> BTC or PBTCETH -> PBTC-ETH\n                del norm[k]\n        norm['BCHN'] = 'BCH'  # Bitfinex uses BCHN, other exchanges use BCH\n\n        ret = {}\n        for symbol in [t[0] for t in tickers]:\n            if symbol[0] == 'f':\n                normalized = norm.get(symbol[1:], symbol[1:])\n            else:\n                if len(symbol) == 7:\n                    base, quote = symbol[1:4], symbol[4:]\n                else:\n                    base, quote = symbol[1:].split(':')\n                    assert ':' in symbol\n                normalized = norm.get(base, base) + SYMBOL_SEP + norm.get(quote, quote)\n            ret[normalized.upper()] = symbol\n        return ret\n    except ValueError as why:\n        raise_failure_explanation('BITFINEX', why, {\"tickers?symbols=ALL\": r1, \"pub:map:currency:sym\": r2})\n\n\ndef bitflyer_symbols() -> Dict[str, str]:\n    endpoint = r = None\n    try:\n        ret = {}\n        endpoints = ['https://api.bitflyer.com/v1/getmarkets/eu', 'https://api.bitflyer.com/v1/getmarkets/usa', 'https://api.bitflyer.com/v1/getmarkets']\n        for endpoint in endpoints:\n            r = requests.get(endpoint)\n            for entry in r.json():\n                normalized = entry['product_code'].replace(\"_\", SYMBOL_SEP)\n                ret[normalized] = entry['product_code']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('BITFLYER', why, {endpoint: r})\n\n\ndef bybit_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.bybit.com/v2/public/symbols')\n        ret = {}\n        for symbol in r.json()['result']:\n            quote = symbol['quote_currency']\n            if not symbol['name'].endswith(quote):\n                base, contract = symbol['name'].split(quote)\n                normalized = f\"{base}{SYMBOL_SEP}{quote}-{contract}\"\n            else:\n                normalized = f\"{symbol['base_currency']}{SYMBOL_SEP}{quote}\"\n            ret[normalized] = symbol['name']\n            _exchange_info[BYBIT]['tick_size'][normalized] = symbol['price_filter']['tick_size']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('BYBIT', why, {\"\": r})\n\n\ndef _ftx_helper(endpoint: str, exchange: str):\n    r = None\n    try:\n        r = requests.get(endpoint)\n        ret = {}\n        for data in r.json()['result']:\n            normalized = data['name'].replace(\"/\", SYMBOL_SEP)\n            symbol = data['name']\n            ret[normalized] = symbol\n            _exchange_info[exchange]['tick_size'][normalized] = data['priceIncrement']\n        return ret\n    except Exception as why:\n        raise_failure_explanation(exchange, why, {endpoint: r})\n\n\ndef ftx_symbols() -> Dict[str, str]:\n    return _ftx_helper('https://ftx.com/api/markets', FTX)\n\n\ndef ftx_us_symbols() -> Dict[str, str]:\n    return _ftx_helper('https://ftx.us/api/markets', FTX_US)\n\n\ndef coinbase_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.pro.coinbase.com/products')\n        ret = {}\n        for data in r.json():\n            normalized = data['id'].replace(\"-\", SYMBOL_SEP)\n            ret[normalized] = data['id']\n            _exchange_info[COINBASE]['tick_size'][normalized] = data['quote_increment']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('COINBASE', why, {\"\": r})\n\n\ndef gemini_symbols(*args) -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.gemini.com/v1/symbols')\n        ret = {}\n        for symbol in r.json():\n            std = f\"{symbol[:-3]}{SYMBOL_SEP}{symbol[-3:]}\"\n            std = std.upper()\n            ret[std] = symbol.upper()\n        return ret\n    except Exception as why:\n        raise_failure_explanation('GEMINI', why, {\"\": r})\n\n\ndef hitbtc_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        ret = {}\n        r = requests.get('https://api.hitbtc.com/api/2/public/symbol')\n        for symbol in r.json():\n            split = len(symbol['baseCurrency'])\n            normalized = symbol['id'][:split] + SYMBOL_SEP + symbol['id'][split:]\n            ret[normalized] = symbol['id']\n            _exchange_info[HITBTC]['tick_size'][normalized] = symbol['tickSize']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('HITBTC', why, {\"\": r})\n\n\ndef poloniex_id_symbol_mapping():\n    r = None\n    try:\n        r = requests.get('https://poloniex.com/public?command=returnTicker')\n        symbols = r.json()\n        ret = {}\n        for symbol in symbols:\n            ret[symbols[symbol]['id']] = symbol\n        return ret\n    except Exception as why:\n        raise_failure_explanation('POLONIEX', why, {\"\": r})\n\n\ndef poloniex_symbols() -> Dict[str, str]:\n    ret = {}\n    for _, value in poloniex_id_symbol_mapping().items():\n        std = value.replace(\"STR\", \"XLM\")\n        quote, base = std.split(\"_\")\n        ret[quote + SYMBOL_SEP + base] = value\n    return ret\n\n\ndef bitstamp_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://www.bitstamp.net/api/v2/trading-pairs-info/')\n        ret = {}\n        for data in r.json():\n            normalized = data['name'].replace(\"/\", SYMBOL_SEP)\n            symbol = data['url_symbol']\n            ret[normalized] = symbol\n        return ret\n    except Exception as why:\n        raise_failure_explanation('BITSTAMP', why, {\"\": r})\n\n\ndef kraken_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.kraken.com/0/public/AssetPairs')\n        data = r.json()\n        ret = {}\n        for symbol in data['result']:\n            if 'wsname' not in data['result'][symbol] or '.d' in symbol:\n                # https://blog.kraken.com/post/259/introducing-the-kraken-dark-pool/\n                # .d is for dark pool symbols\n                continue\n\n            base, quote = data['result'][symbol]['wsname'].split(\"/\")\n\n            normalized = f\"{base}{SYMBOL_SEP}{quote}\"\n            exch = data['result'][symbol]['wsname']\n            normalized = normalized.replace('XBT', 'BTC')\n            normalized = normalized.replace('XDG', 'DOG')\n            ret[normalized] = exch\n        return ret\n    except Exception as why:\n        raise_failure_explanation('KRAKEN', why, {\"\": r})\n\n\ndef kraken_rest_symbols() -> Dict[str, str]:\n    return {normalized: exchange.replace(\"/\", \"\") for normalized, exchange in kraken_symbols().items()}\n\n\ndef exx_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.exx.com/data/v1/tickers')\n        exchange = [key.upper() for key in r.json().keys()]\n        symbols = [key.replace(\"_\", SYMBOL_SEP) for key in exchange]\n        return dict(zip(symbols, exchange))\n    except Exception as why:\n        raise_failure_explanation('EXX', why, {\"\": r})\n\n\ndef huobi_common_symbols(url: str):\n    r = None\n    try:\n        r = requests.get(url)\n        ret = {}\n        for e in r.json()['data']:\n            if e['state'] == 'offline':\n                continue\n            normalized = f\"{e['base-currency'].upper()}{SYMBOL_SEP}{e['quote-currency'].upper()}\"\n            symbol = f\"{e['base-currency']}{e['quote-currency']}\"\n            ret[normalized] = symbol\n        return ret\n    except Exception as why:\n        raise_failure_explanation('HUOBI', why, {url: r})\n\n\ndef huobi_symbols() -> Dict[str, str]:\n    return huobi_common_symbols('https://api.huobi.pro/v1/common/symbols')\n\n\ndef huobi_us_symbols() -> Dict[str, str]:\n    return huobi_common_symbols('https://api.huobi.com/v1/common/symbols')\n\n\ndef huobi_dm_symbols() -> Dict[str, str]:\n    \"\"\"\n    Mapping is, for instance: {\"BTC_CW\":\"BTC190816\"}\n    See comments in exchange/huobi_dm.py\n    \"\"\"\n    mapping = {\n        \"this_week\": \"CW\",\n        \"next_week\": \"NW\",\n        \"quarter\": \"CQ\",\n        \"next_quarter\": \"NQ\"\n    }\n    r = None\n    try:\n        r = requests.get('https://www.hbdm.com/api/v1/contract_contract_info')\n        symbols = {}\n        for e in r.json()['data']:\n            symbols[f\"{e['symbol']}_{mapping[e['contract_type']]}\"] = e['contract_code']\n            _exchange_info[HUOBI_DM]['tick_size'][e['contract_code']] = e['price_tick']\n            _exchange_info[HUOBI_DM]['short_code_mappings'][f\"{e['symbol']}_{mapping[e['contract_type']]}\"] = e['contract_code']\n        return symbols\n    except Exception as why:\n        raise_failure_explanation('HUOBI_DM', why, {\"\": r})\n\n\ndef huobi_swap_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.hbdm.com/swap-api/v1/swap_contract_info')\n        symbols = {}\n        for e in r.json()['data']:\n            symbols[e['contract_code']] = e['contract_code']\n            _exchange_info[HUOBI_SWAP]['tick_size'][e['contract_code']] = e['price_tick']\n        return symbols\n    except Exception as why:\n        raise_failure_explanation('HUOBI_SWAP', why, {\"\": r})\n\n\ndef okcoin_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://www.okcoin.com/api/spot/v3/instruments')\n        ret = {}\n        for e in r.json():\n            ret[e['instrument_id']] = e['instrument_id']\n            _exchange_info[OKCOIN]['tick_size'][e['instrument_id']] = e['tick_size']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('OKCOIN', why, {\"\": r})\n\n\ndef okex_symbols(*args) -> Dict[str, str]:\n    urls = ['https://www.okex.com/api/spot/v3/instruments',\n            'https://www.okex.com/api/swap/v3/instruments',\n            'https://www.okex.com/api/futures/v3/instruments']\n    urls = urls + okex_compute_option_urls_from_underlyings()\n\n    symbols: Dict[str, str] = {}\n    for u in urls:\n        time.sleep(0.2)\n        symbols.update(okex_symbols_from_one_url(u))\n\n    for symbol in symbols:\n        instrument_type = 'futures'\n        dash_count = symbol.count(get_symbol_separator())\n        if dash_count == 1:  # BTC-USDT\n            instrument_type = 'spot'\n        if dash_count == 4:  # BTC-USD-201225-35000-P\n            instrument_type = 'option'\n        if symbol[-4:] == \"SWAP\":  # BTC-USDT-SWAP\n            instrument_type = 'swap'\n\n        _exchange_info[OKEX]['instrument_type'][symbol] = instrument_type\n\n    return symbols\n\n\ndef okex_compute_option_urls_from_underlyings() -> List[str]:\n    url = 'https://www.okex.com/api/option/v3/underlying'\n    r = None\n    try:\n        r = requests.get(url)\n        return [f'https://www.okex.com/api/option/v3/instruments/{underlying}' for underlying in r.json()]\n    except Exception as why:\n        raise_failure_explanation('OKEX', why, {url: r})\n\n\ndef okex_symbols_from_one_url(url: str) -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get(url)\n        ret = {}\n        for e in r.json():\n            ret[e['instrument_id']] = e['instrument_id']\n            _exchange_info[OKEX]['tick_size'][e['instrument_id']] = e['tick_size']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('OKEX', why, {url: r})\n\n\ndef bittrex_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.bittrex.com/api/v1.1/public/getmarkets')\n        r = r.json()['result']\n        return {f\"{e['MarketCurrency']}{SYMBOL_SEP}{e['BaseCurrency']}\": e['MarketName'] for e in r if e['IsActive']}\n    except Exception as why:\n        raise_failure_explanation('BITTREX', why, {\"\": r})\n\n\ndef bitcoincom_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.exchange.bitcoin.com/api/2/public/symbol')\n        return {f\"{data['baseCurrency']}{SYMBOL_SEP}{data['quoteCurrency'].replace('USD', 'USDT')}\": data['id'] for data in r.json()}\n    except Exception as why:\n        raise_failure_explanation('BITCOINCOM', why, {\"\": r})\n\n\ndef bitmax_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://bitmax.io/api/pro/v1/products')\n        ret = {}\n        for entry in r.json()['data']:\n            # Only \"Normal\" status symbols are tradeable\n            if entry['status'] == 'Normal':\n                normalized = f\"{entry['baseAsset']}{SYMBOL_SEP}{entry['quoteAsset']}\"\n                ret[normalized] = entry['symbol']\n                _exchange_info[BITMAX]['tick_size'][normalized] = entry['tickSize']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('BITMAX', why, {\"\": r})\n\n\ndef upbit_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.upbit.com/v1/market/all')\n        return {f\"{data['market'].split('-')[1]}{SYMBOL_SEP}{data['market'].split('-')[0]}\": data['market'] for data in r.json()}\n    except Exception as why:\n        raise_failure_explanation('UPBIT', why, {\"\": r})\n\n\ndef blockchain_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get(\"https://api.blockchain.com/mercury-gateway/v1/instruments\")\n        return {data[\"symbol\"].replace(\"-\", SYMBOL_SEP): data[\"symbol\"] for data in r.json()}\n    except Exception as why:\n        raise_failure_explanation('BLOCKCHAIN', why, {\"\": r})\n\n\ndef gateio_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get(\"https://api.gateio.ws/api/v4/spot/currency_pairs\")\n        return {data[\"id\"].replace(\"_\", SYMBOL_SEP): data['id'] for data in r.json()}\n    except Exception as why:\n        raise_failure_explanation('GATEIO', why, {\"\": r})\n\n\ndef bitmex_symbols() -> Dict[str, str]:\n    r = None\n    ret = {}\n    try:\n        r = requests.get(\"https://www.bitmex.com/api/v1/instrument/active\")\n        for entry in r.json():\n            components = []\n            components.append(entry['rootSymbol'])\n            components.append(entry['quoteCurrency'])\n\n            if entry['expiry']:\n                components.append(entry['symbol'][-3:])\n\n            normalized = SYMBOL_SEP.join(components)\n            normalized = normalized.replace(\"XBT\", \"BTC\")\n            ret[normalized] = entry['symbol']\n            _exchange_info[BITMEX]['tick_size'][normalized] = entry['tickSize']\n\n            if entry['expiry']:\n                _exchange_info[BITMEX]['expiry'][normalized] = entry['expiry']\n\n        return ret\n    except Exception as why:\n        raise_failure_explanation('BITMEX', why, {\"\": r})\n\n\ndef deribit_symbols() -> Dict[str, str]:\n    url = r = None\n    ret = {}\n    try:\n        # TODO: get currencies from https://www.deribit.com/api/v2/public/get_currencies\n        currencies = ['BTC', 'ETH']\n        for c in currencies:\n            url = f\"https://www.deribit.com/api/v2/public/get_instruments?currency={c}&expired=false\"\n            r = requests.get(url)\n            for entry in r.json()['result']:\n                split = entry['instrument_name'].split(\"-\")\n                normalized = split[0] + SYMBOL_SEP + entry['quote_currency'] + \"-\" + '-'.join(split[1:])\n                ret[normalized] = entry['instrument_name']\n                _exchange_info[DERIBIT]['tick_size'][normalized] = entry['tick_size']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('DERIBIT', why, {url: r})\n\n\ndef kraken_future_symbols() -> Dict[str, str]:\n    r = None\n    ret = {}\n    try:\n        r = requests.get('https://futures.kraken.com/derivatives/api/v3/instruments')\n        data = r.json()['instruments']\n        for entry in data:\n            if not entry['tradeable']:\n                continue\n            normalized = entry['symbol'].upper().replace(\"_\", \"-\")\n            symbol = normalized[3:6] + SYMBOL_SEP + normalized[6:9]\n            normalized = normalized.replace(normalized[3:9], symbol)\n            normalized = normalized.replace('XBT', 'BTC')\n\n            _exchange_info[KRAKEN_FUTURES]['tick_size'][normalized] = entry['tickSize']\n            _exchange_info[KRAKEN_FUTURES]['contract_size'][normalized] = entry['contractSize']\n            _exchange_info[KRAKEN_FUTURES]['underlying'][normalized] = entry['underlying']\n            _exchange_info[KRAKEN_FUTURES]['product_type'][normalized] = _kraken_futures_product_type[normalized[:2]]\n            ret[normalized] = entry['symbol']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('KRAKEN_FUTURES', why, {\"\": r})\n\n\ndef probit_symbols() -> Dict[str, str]:\n    # doc: https://docs-en.probit.com/reference-link/market\n    r = None\n    try:\n        r = requests.get('https://api.probit.com/api/exchange/v1/market')\n        return {entry['id']: entry['id'] for entry in r.json()['data']}\n    except Exception as why:\n        raise_failure_explanation('PROBIT', why, {\"\": r})\n\n\ndef coingecko_normalize_symbol(symbol: str) -> str:\n    # keep digits, letters and dots, replace others by space\n    symbol = ''.join(c if c.isalnum() or c in ('.', '+') else ' ' for c in symbol)\n    return coingecko_normalize(symbol.upper())\n\n\ndef coingecko_normalize_name(name: str) -> str:\n    # keep digits and letters, replace others by space (except when only composed by upper case letters, digits and dots)\n    if not all(c.isupper() or c.isdigit() or c == '.' for c in name):\n        name = ''.join(c if c.isalnum() else ' ' for c in name)\n    return coingecko_normalize(name)\n\n\ndef coingecko_normalize(sym: str) -> str:\n    sym = sym.strip()\n    # do not concatenate numbers => separate them with a dot\n    sym = list(sym)\n    if len(sym) > 4:\n        for i in range(2, len(sym) - 1):\n            if sym[i] == ' ' and sym[i - 1].isdigit() and sym[i + 1].isdigit():\n                sym[i] = '.'\n    sym = ''.join(sym)\n    # concatenate space-separated words => use CamelCase to distinguish the words\n    if ' ' in sym:\n        if sum(c.islower() for c in sym):  # if there is at least one lower case letter\n            sym = ' '.join(word[0].upper() + word[1:] for word in sym.split())  # Just capitalize initial letter of each word\n        else:  # CoinGecko may provide full upper-case as for \"THE STONE COIN\"\n            sym = string.capwords(sym)  # capwords converts \"THE STONE COIN\" to \"The Stone Coin\"\n        sym = sym.replace(' ', '')  # concatenate words\n    return sym\n\n\ndef is_name_short(coin: dict) -> bool:\n    \"\"\"return True if the coin name is enough short compared to the coin symbol.\"\"\"\n    return len(coin['name']) <= max(5, len(coin['symbol']) + 1)\n\n\ndef has_many_caps(name: str) -> bool:\n    \"\"\"return True if the symbol contains enough upper case letters, False if empty.\"\"\"\n    return str and sum(c.islower() for c in name) < (len(name) / 2)\n\n\ndef coingecko_normalize_all(coin: dict):\n    SYMBOL_TO_NORMALIZED = {'miota': 'IOTA'}\n    normalized = SYMBOL_TO_NORMALIZED.get(coin['symbol'])\n    if normalized:\n        coin['ns'] = coin['nn'] = normalized\n        return normalized\n\n    # ns = normalized symbol, nn = normalized name\n    coin['ns'] = coingecko_normalize_symbol(coin['symbol'])\n\n    ID_SUFFIX = '-bitcoin-token'\n    if coin['id'][-len(ID_SUFFIX):] == ID_SUFFIX:\n        coin['nn'] = 'BTC' + coin['ns']\n        return coin['nn']\n\n    name = coin['name']\n\n    prefixes = ('The ', 'the ')\n    for p in prefixes:\n        if name[:len(p)] == p:\n            coin['reduced-name'] = True\n            name = name[len(p):]\n            break\n\n    suffixes = ('coin', 'coins', 'money', 'finance', 'protocol', 'reward', 'rewards', 'token')\n    for s in suffixes:\n        if len(name) > len(s) and name[-len(s):].lower() == s:\n            # but keep suffix when lower-case concatenated\n            if name[-len(s)].islower() and name[-len(s) - 1] != ' ':\n                continue\n            # also keep suffix to avoid confusing nam: \"Bitcoin Token\" -> \"Bitcoin\"\n            if name[:-len(s)].strip().lower() == 'bitcoin':\n                continue\n            coin['reduced-name'] = True\n            name = name[:-len(s)]\n            break\n\n    coin['nn'] = coingecko_normalize_name(name)\n\n    if len(coin['nn']) < len(coin['ns']):\n        if 'reduced-name' in coin:\n            coin['reduced-name'] = False\n            name = coin['name']\n            coin['nn'] = coingecko_normalize_name(name)\n        elif not has_many_caps(name):\n            return coin['ns']\n\n    if not coin['ns']:  # coin['symbol'] may be an emoji that is striped when normalized\n        return coin['nn']\n\n    if coin.get('reduced-name') and coin['ns'].upper() != coin['nn'].upper():\n        return coin['ns']\n\n    i = coin['nn'].find('.')  # if there is a dot in normalized name => prefer the normalized symbol\n    if i >= 0:\n        if i > 1 and coin['nn'][i - 1].isdigit() and coin['nn'][i + 1].isdigit():\n            pass  # except when the dot separates digits\n        else:\n            return coin['ns']\n\n    if is_name_short(coin) and has_many_caps(name):\n        return coin['nn']\n\n    if 1.5 * len(coin['ns']) > len(coin['nn']) and any(c.islower() for c in coin['ns']):\n        return coin['nn']\n\n    return coin['ns']\n\n\ndef coingecko_symbols() -> Dict[str, str]:\n    r = None\n    intermediate = defaultdict(list)\n    try:\n        r = requests.get('https://api.coingecko.com/api/v3/coins/list')\n        all_coins = r.json()\n        # First pass: generate & compare normalized symbol/name, and then select the most pertinent\n        for coin in all_coins:\n            normalized = coingecko_normalize_all(coin)\n            intermediate[normalized].append(coin)\n            # Above line keeps together the coins having the same normalized symbol.\n            # To reduce collision, the coin['name'] is sometimes used in lieu of the coin['symbol'].\n            # The coin['name'] is not capitalized because lower case letters may be meaningful: cETH, yUSD, DATx, zLOT\n    except Exception as why:\n        raise_failure_explanation('COINGECKO', why, {\"\": r})\n\n    final = coingecko_second_pass(intermediate)\n    return coingecko_third_pass(final)\n\n\ndef coingecko_second_pass(intermediate: Dict[str, List[dict]]) -> Dict[str, List[dict]]:\n    # Second pass: fixes most of the symbol collisions\n    final = defaultdict(list)\n    for normalized, coins in intermediate.items():\n        if len(coins) == 1:\n            final[normalized].append(coins[0])\n            continue\n        set_normalized = False\n        for i in range(len(coins)):\n            if normalized == coins[i]['nn']:\n                coin = coins.pop(i)\n                final[normalized].append(coin)\n                set_normalized = True\n                break\n        rest: List[dict] = []\n        for coin in coins:\n            if '%' in coin['name']:\n                if len(coins) == 1:\n                    n = coin['ns']\n                else:\n                    n = coingecko_normalize_name(coin['id'])\n                final[n].append(coin)\n            else:\n                rest.append(coin)\n        if not rest:\n            continue\n        if not set_normalized:\n            rest.sort(key=lambda coin: len(coin['nn']), reverse=True)  # sort by the length of the normalized name\n            coin = rest.pop(0)\n            final[normalized].append(coin)\n        for coin in rest:\n            if coin['nn'] not in intermediate:\n                n = coin['nn']\n            elif coin.get('reduced-name'):\n                n = coingecko_normalize_name(coin['name'])\n            else:\n                n = coingecko_normalize_name(coin['id'])\n            final[n].append(coin)\n    return final\n\n\ndef coingecko_third_pass(final: Dict[str, List[dict]]) -> Dict[str, str]:\n    # Third pass: fixes some remaining collisions and fills the result\n    symbols = {}\n    for normalized, coins in final.items():\n        if len(coins) == 1:\n            symbols[normalized] = coins[0]['id']\n            continue\n        set_normalized = False\n        for i in range(len(coins)):\n            if normalized == coins[i]['nn']:\n                coin = coins.pop(i)\n                symbols[normalized] = coin['id']\n                set_normalized = True\n                break\n        rest: List[dict] = []\n        for coin in coins:\n            if '%' in coin['name']:\n                if len(coins) == 1:\n                    n = coin['ns']\n                else:\n                    n = coingecko_normalize_name(coin['id'])\n                symbols[n] = coin['id']\n            else:\n                rest.append(coin)\n        if not rest:\n            continue\n        if not set_normalized:\n            rest.sort(key=lambda coin: len(coin['nn']), reverse=True)  # sort by the length of the normalized name\n            coin = rest.pop(0)\n            symbols[normalized] = coin['id']\n        for coin in rest:\n            if coin['nn'] not in final:\n                n = coin['nn']\n            elif coin.get('reduced-name'):\n                n = coingecko_normalize_name(coin['name'])\n            else:\n                n = coingecko_normalize_name(coin['id'])\n            symbols[n] = coin['id']\n    return symbols\n\n\ndef whale_alert_coins(key_id: str) -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get(f'https://api.whale-alert.io/v1/status?api_key={key_id}')\n        # Same symbols, but on different blockchains (for instance USDT), are naturally overwritten.\n        return {s.upper(): s for b in r.json()['blockchains'] for s in b['symbols'] if s}\n    except Exception as why:\n        raise_failure_explanation('WHALES_ALERT', why, {\"\": r})\n\n\n_exchange_function_map = {\n    BITFINEX: bitfinex_symbols,\n    BITFLYER: bitflyer_symbols,\n    COINBASE: coinbase_symbols,\n    GEMINI: gemini_symbols,\n    HITBTC: hitbtc_symbols,\n    POLONIEX: poloniex_symbols,\n    PROBIT: probit_symbols,\n    BITSTAMP: bitstamp_symbols,\n    KRAKEN: kraken_symbols,\n    KRAKEN + 'REST': kraken_rest_symbols,\n    BINANCE: binance_symbols,\n    BINANCE_US: binance_us_symbols,\n    BINANCE_FUTURES: binance_futures_symbols,\n    BINANCE_DELIVERY: binance_delivery_symbols,\n    BLOCKCHAIN: blockchain_symbols,\n    EXX: exx_symbols,\n    HUOBI: huobi_symbols,\n    HUOBI_DM: huobi_dm_symbols,\n    HUOBI_SWAP: huobi_swap_symbols,\n    OKCOIN: okcoin_symbols,\n    OKEX: okex_symbols,\n    BYBIT: bybit_symbols,\n    FTX: ftx_symbols,\n    FTX_US: ftx_us_symbols,\n    BITTREX: bittrex_symbols,\n    BITCOINCOM: bitcoincom_symbols,\n    BITMAX: bitmax_symbols,\n    UPBIT: upbit_symbols,\n    GATEIO: gateio_symbols,\n    BITMEX: bitmex_symbols,\n    DERIBIT: deribit_symbols,\n    KRAKEN_FUTURES: kraken_future_symbols,\n    COINGECKO: coingecko_symbols,\n    WHALE_ALERT: whale_alert_coins\n}\n",
        "source_code_len": 30534,
        "target_code": "associated with this software.\n'''\nfrom typing import Dict, Tuple\n\n\nclass _Symbols:\n    def __init__(self):\n        self.data = {}\n\n    def set(self, exchange: str, normalized: dict, exchange_info: dict):\n        self.data[exchange] = {}\n        self.data[exchange]['normalized'] = normalized\n        self.data[exchange]['info'] = exchange_info\n\n    def get(self, exchange: str) -> Tuple[Dict, Dict]:\n        return self.data[exchange]['normalized'], self.data[exchange]['info']\n\n    def populated(self, exchange: str) -> bool:\n        return exchange in self.data\n\n\nSymbols = _Symbols()\n",
        "target_code_len": 588,
        "diff_format": "@@ -5,845 +5,22 @@\n associated with this software.\n+'''\n+from typing import Dict, Tuple\n \n \n-Symbol generation code for exchanges\n-'''\n+class _Symbols:\n+    def __init__(self):\n+        self.data = {}\n \n-import logging\n-import string\n-import time\n-from collections import defaultdict\n-from typing import Dict, List, Optional, Tuple\n+    def set(self, exchange: str, normalized: dict, exchange_info: dict):\n+        self.data[exchange] = {}\n+        self.data[exchange]['normalized'] = normalized\n+        self.data[exchange]['info'] = exchange_info\n \n-import requests\n-from requests import Response\n+    def get(self, exchange: str) -> Tuple[Dict, Dict]:\n+        return self.data[exchange]['normalized'], self.data[exchange]['info']\n \n-from cryptofeed.defines import *\n+    def populated(self, exchange: str) -> bool:\n+        return exchange in self.data\n \n \n-LOG = logging.getLogger('feedhandler')\n-\n-SYMBOL_SEP = '-'\n-\n-_symbols_retrieval_cache: Dict[str, Dict[str, str]] = {}\n-_exchange_info = defaultdict(lambda: defaultdict(dict))\n-\n-\n-_kraken_futures_product_type = {\n-    'FI': 'Inverse Futures',\n-    'FV': 'Vanilla Futures',\n-    'PI': 'Perpetual Inverse Futures',\n-    'PV': 'Perpetual Vanilla Futures',\n-    'IN': 'Real Time Index',\n-    'RR': 'Reference Rate',\n-}\n-\n-\n-def raise_failure_explanation(feed_id: str, exception: BaseException, responses: Dict[str, Optional[Response]]):\n-    LOG.critical('%s: encountered %r while processing response from exchange API', feed_id, exception)\n-    if len(responses) > 1:\n-        LOG.critical('%s: content of one of the %s responses was unexpected', feed_id, len(responses))\n-    for url, r in responses.items():\n-        if url:\n-            LOG.critical('%s: requested URL: %s', feed_id, url)\n-        if r:\n-            LOG.critical('%s: unexpected response: %s', feed_id, r.text)\n-    raise ValueError(f'Cryptofeed stopped because of an unexpected response from {feed_id}') from exception\n-\n-\n-def set_symbol_separator(separator: str):\n-    global SYMBOL_SEP\n-    SYMBOL_SEP = separator\n-\n-\n-def get_symbol_separator() -> str:\n-    global SYMBOL_SEP\n-    return SYMBOL_SEP\n-\n-\n-def gen_symbols(exchange: str, key_id=None) -> Dict[str, str]:\n-    if exchange not in _symbols_retrieval_cache:\n-        LOG.info(\"%s: Getting list of symbols\", exchange)\n-        symbols = _exchange_function_map[exchange](key_id) if key_id else _exchange_function_map[exchange]()\n-        LOG.info(\"%s: %s symbols\", exchange, len(symbols))\n-\n-        # log all retrieved symbols using debug level\n-        for normalized, exch_sym in sorted(symbols.items()):\n-            LOG.debug('%s: id-from-exch -> normalized: %-35s-> %s', exchange, exch_sym, normalized)\n-\n-        _symbols_retrieval_cache[exchange] = symbols\n-    return _symbols_retrieval_cache[exchange]\n-\n-\n-def _binance_symbols(endpoint: str, exchange: str):\n-    r = None\n-    try:\n-        ret = {}\n-        r = requests.get(endpoint)\n-        for symbol in r.json()['symbols']:\n-            if symbol.get('status', 'TRADING') != \"TRADING\":\n-                continue\n-            if symbol.get('contractStatus', 'TRADING') != \"TRADING\":\n-                continue\n-            split = len(symbol['baseAsset'])\n-            normalized = symbol['symbol'][:split] + SYMBOL_SEP + symbol['symbol'][split:]\n-            ret[normalized] = symbol['symbol']\n-            _exchange_info[exchange]['tick_size'][normalized] = symbol['filters'][0]['tickSize']\n-            if \"contractType\" in symbol:\n-                _exchange_info[exchange]['contract_type'][normalized] = symbol['contractType']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation(exchange, why, {endpoint: r})\n-\n-\n-def binance_symbols() -> Dict[str, str]:\n-    return _binance_symbols('https://api.binance.com/api/v3/exchangeInfo', BINANCE)\n-\n-\n-def binance_us_symbols() -> Dict[str, str]:\n-    return _binance_symbols('https://api.binance.us/api/v3/exchangeInfo', BINANCE_US)\n-\n-\n-def binance_futures_symbols() -> Dict[str, str]:\n-    base = _binance_symbols('https://fapi.binance.com/fapi/v1/exchangeInfo', BINANCE_FUTURES)\n-    add = {}\n-    for symbol, orig in base.items():\n-        if \"_\" in orig:\n-            continue\n-        add[f\"{symbol}-PINDEX\"] = f\"p{orig}\"\n-    base.update(add)\n-    return base\n-\n-\n-def binance_delivery_symbols() -> Dict[str, str]:\n-    return _binance_symbols('https://dapi.binance.com/dapi/v1/exchangeInfo', BINANCE_DELIVERY)\n-\n-\n-def bitfinex_symbols() -> Dict[str, str]:\n-    # doc: https://docs.bitfinex.com/docs/ws-general#supported-pairs\n-    r1 = r2 = None\n-    try:\n-        r1 = requests.get('https://api.bitfinex.com/v2/tickers?symbols=ALL')\n-        r2 = requests.get('https://api-pub.bitfinex.com/v2/conf/pub:map:currency:sym')\n-        tickers: List[List[str]] = r1.json()\n-        norm: List[Tuple[str, str]] = r2.json()[0]\n-        norm: Dict[str, str] = dict(norm)\n-        for k, v in dict(norm).items():\n-            if k[-2:] == 'F0' or '-' in v:  # Do not convert BTCF0 -> BTC or PBTCETH -> PBTC-ETH\n-                del norm[k]\n-        norm['BCHN'] = 'BCH'  # Bitfinex uses BCHN, other exchanges use BCH\n-\n-        ret = {}\n-        for symbol in [t[0] for t in tickers]:\n-            if symbol[0] == 'f':\n-                normalized = norm.get(symbol[1:], symbol[1:])\n-            else:\n-                if len(symbol) == 7:\n-                    base, quote = symbol[1:4], symbol[4:]\n-                else:\n-                    base, quote = symbol[1:].split(':')\n-                    assert ':' in symbol\n-                normalized = norm.get(base, base) + SYMBOL_SEP + norm.get(quote, quote)\n-            ret[normalized.upper()] = symbol\n-        return ret\n-    except ValueError as why:\n-        raise_failure_explanation('BITFINEX', why, {\"tickers?symbols=ALL\": r1, \"pub:map:currency:sym\": r2})\n-\n-\n-def bitflyer_symbols() -> Dict[str, str]:\n-    endpoint = r = None\n-    try:\n-        ret = {}\n-        endpoints = ['https://api.bitflyer.com/v1/getmarkets/eu', 'https://api.bitflyer.com/v1/getmarkets/usa', 'https://api.bitflyer.com/v1/getmarkets']\n-        for endpoint in endpoints:\n-            r = requests.get(endpoint)\n-            for entry in r.json():\n-                normalized = entry['product_code'].replace(\"_\", SYMBOL_SEP)\n-                ret[normalized] = entry['product_code']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('BITFLYER', why, {endpoint: r})\n-\n-\n-def bybit_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.bybit.com/v2/public/symbols')\n-        ret = {}\n-        for symbol in r.json()['result']:\n-            quote = symbol['quote_currency']\n-            if not symbol['name'].endswith(quote):\n-                base, contract = symbol['name'].split(quote)\n-                normalized = f\"{base}{SYMBOL_SEP}{quote}-{contract}\"\n-            else:\n-                normalized = f\"{symbol['base_currency']}{SYMBOL_SEP}{quote}\"\n-            ret[normalized] = symbol['name']\n-            _exchange_info[BYBIT]['tick_size'][normalized] = symbol['price_filter']['tick_size']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('BYBIT', why, {\"\": r})\n-\n-\n-def _ftx_helper(endpoint: str, exchange: str):\n-    r = None\n-    try:\n-        r = requests.get(endpoint)\n-        ret = {}\n-        for data in r.json()['result']:\n-            normalized = data['name'].replace(\"/\", SYMBOL_SEP)\n-            symbol = data['name']\n-            ret[normalized] = symbol\n-            _exchange_info[exchange]['tick_size'][normalized] = data['priceIncrement']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation(exchange, why, {endpoint: r})\n-\n-\n-def ftx_symbols() -> Dict[str, str]:\n-    return _ftx_helper('https://ftx.com/api/markets', FTX)\n-\n-\n-def ftx_us_symbols() -> Dict[str, str]:\n-    return _ftx_helper('https://ftx.us/api/markets', FTX_US)\n-\n-\n-def coinbase_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.pro.coinbase.com/products')\n-        ret = {}\n-        for data in r.json():\n-            normalized = data['id'].replace(\"-\", SYMBOL_SEP)\n-            ret[normalized] = data['id']\n-            _exchange_info[COINBASE]['tick_size'][normalized] = data['quote_increment']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('COINBASE', why, {\"\": r})\n-\n-\n-def gemini_symbols(*args) -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.gemini.com/v1/symbols')\n-        ret = {}\n-        for symbol in r.json():\n-            std = f\"{symbol[:-3]}{SYMBOL_SEP}{symbol[-3:]}\"\n-            std = std.upper()\n-            ret[std] = symbol.upper()\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('GEMINI', why, {\"\": r})\n-\n-\n-def hitbtc_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        ret = {}\n-        r = requests.get('https://api.hitbtc.com/api/2/public/symbol')\n-        for symbol in r.json():\n-            split = len(symbol['baseCurrency'])\n-            normalized = symbol['id'][:split] + SYMBOL_SEP + symbol['id'][split:]\n-            ret[normalized] = symbol['id']\n-            _exchange_info[HITBTC]['tick_size'][normalized] = symbol['tickSize']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('HITBTC', why, {\"\": r})\n-\n-\n-def poloniex_id_symbol_mapping():\n-    r = None\n-    try:\n-        r = requests.get('https://poloniex.com/public?command=returnTicker')\n-        symbols = r.json()\n-        ret = {}\n-        for symbol in symbols:\n-            ret[symbols[symbol]['id']] = symbol\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('POLONIEX', why, {\"\": r})\n-\n-\n-def poloniex_symbols() -> Dict[str, str]:\n-    ret = {}\n-    for _, value in poloniex_id_symbol_mapping().items():\n-        std = value.replace(\"STR\", \"XLM\")\n-        quote, base = std.split(\"_\")\n-        ret[quote + SYMBOL_SEP + base] = value\n-    return ret\n-\n-\n-def bitstamp_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://www.bitstamp.net/api/v2/trading-pairs-info/')\n-        ret = {}\n-        for data in r.json():\n-            normalized = data['name'].replace(\"/\", SYMBOL_SEP)\n-            symbol = data['url_symbol']\n-            ret[normalized] = symbol\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('BITSTAMP', why, {\"\": r})\n-\n-\n-def kraken_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.kraken.com/0/public/AssetPairs')\n-        data = r.json()\n-        ret = {}\n-        for symbol in data['result']:\n-            if 'wsname' not in data['result'][symbol] or '.d' in symbol:\n-                # https://blog.kraken.com/post/259/introducing-the-kraken-dark-pool/\n-                # .d is for dark pool symbols\n-                continue\n-\n-            base, quote = data['result'][symbol]['wsname'].split(\"/\")\n-\n-            normalized = f\"{base}{SYMBOL_SEP}{quote}\"\n-            exch = data['result'][symbol]['wsname']\n-            normalized = normalized.replace('XBT', 'BTC')\n-            normalized = normalized.replace('XDG', 'DOG')\n-            ret[normalized] = exch\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('KRAKEN', why, {\"\": r})\n-\n-\n-def kraken_rest_symbols() -> Dict[str, str]:\n-    return {normalized: exchange.replace(\"/\", \"\") for normalized, exchange in kraken_symbols().items()}\n-\n-\n-def exx_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.exx.com/data/v1/tickers')\n-        exchange = [key.upper() for key in r.json().keys()]\n-        symbols = [key.replace(\"_\", SYMBOL_SEP) for key in exchange]\n-        return dict(zip(symbols, exchange))\n-    except Exception as why:\n-        raise_failure_explanation('EXX', why, {\"\": r})\n-\n-\n-def huobi_common_symbols(url: str):\n-    r = None\n-    try:\n-        r = requests.get(url)\n-        ret = {}\n-        for e in r.json()['data']:\n-            if e['state'] == 'offline':\n-                continue\n-            normalized = f\"{e['base-currency'].upper()}{SYMBOL_SEP}{e['quote-currency'].upper()}\"\n-            symbol = f\"{e['base-currency']}{e['quote-currency']}\"\n-            ret[normalized] = symbol\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('HUOBI', why, {url: r})\n-\n-\n-def huobi_symbols() -> Dict[str, str]:\n-    return huobi_common_symbols('https://api.huobi.pro/v1/common/symbols')\n-\n-\n-def huobi_us_symbols() -> Dict[str, str]:\n-    return huobi_common_symbols('https://api.huobi.com/v1/common/symbols')\n-\n-\n-def huobi_dm_symbols() -> Dict[str, str]:\n-    \"\"\"\n-    Mapping is, for instance: {\"BTC_CW\":\"BTC190816\"}\n-    See comments in exchange/huobi_dm.py\n-    \"\"\"\n-    mapping = {\n-        \"this_week\": \"CW\",\n-        \"next_week\": \"NW\",\n-        \"quarter\": \"CQ\",\n-        \"next_quarter\": \"NQ\"\n-    }\n-    r = None\n-    try:\n-        r = requests.get('https://www.hbdm.com/api/v1/contract_contract_info')\n-        symbols = {}\n-        for e in r.json()['data']:\n-            symbols[f\"{e['symbol']}_{mapping[e['contract_type']]}\"] = e['contract_code']\n-            _exchange_info[HUOBI_DM]['tick_size'][e['contract_code']] = e['price_tick']\n-            _exchange_info[HUOBI_DM]['short_code_mappings'][f\"{e['symbol']}_{mapping[e['contract_type']]}\"] = e['contract_code']\n-        return symbols\n-    except Exception as why:\n-        raise_failure_explanation('HUOBI_DM', why, {\"\": r})\n-\n-\n-def huobi_swap_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.hbdm.com/swap-api/v1/swap_contract_info')\n-        symbols = {}\n-        for e in r.json()['data']:\n-            symbols[e['contract_code']] = e['contract_code']\n-            _exchange_info[HUOBI_SWAP]['tick_size'][e['contract_code']] = e['price_tick']\n-        return symbols\n-    except Exception as why:\n-        raise_failure_explanation('HUOBI_SWAP', why, {\"\": r})\n-\n-\n-def okcoin_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://www.okcoin.com/api/spot/v3/instruments')\n-        ret = {}\n-        for e in r.json():\n-            ret[e['instrument_id']] = e['instrument_id']\n-            _exchange_info[OKCOIN]['tick_size'][e['instrument_id']] = e['tick_size']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('OKCOIN', why, {\"\": r})\n-\n-\n-def okex_symbols(*args) -> Dict[str, str]:\n-    urls = ['https://www.okex.com/api/spot/v3/instruments',\n-            'https://www.okex.com/api/swap/v3/instruments',\n-            'https://www.okex.com/api/futures/v3/instruments']\n-    urls = urls + okex_compute_option_urls_from_underlyings()\n-\n-    symbols: Dict[str, str] = {}\n-    for u in urls:\n-        time.sleep(0.2)\n-        symbols.update(okex_symbols_from_one_url(u))\n-\n-    for symbol in symbols:\n-        instrument_type = 'futures'\n-        dash_count = symbol.count(get_symbol_separator())\n-        if dash_count == 1:  # BTC-USDT\n-            instrument_type = 'spot'\n-        if dash_count == 4:  # BTC-USD-201225-35000-P\n-            instrument_type = 'option'\n-        if symbol[-4:] == \"SWAP\":  # BTC-USDT-SWAP\n-            instrument_type = 'swap'\n-\n-        _exchange_info[OKEX]['instrument_type'][symbol] = instrument_type\n-\n-    return symbols\n-\n-\n-def okex_compute_option_urls_from_underlyings() -> List[str]:\n-    url = 'https://www.okex.com/api/option/v3/underlying'\n-    r = None\n-    try:\n-        r = requests.get(url)\n-        return [f'https://www.okex.com/api/option/v3/instruments/{underlying}' for underlying in r.json()]\n-    except Exception as why:\n-        raise_failure_explanation('OKEX', why, {url: r})\n-\n-\n-def okex_symbols_from_one_url(url: str) -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get(url)\n-        ret = {}\n-        for e in r.json():\n-            ret[e['instrument_id']] = e['instrument_id']\n-            _exchange_info[OKEX]['tick_size'][e['instrument_id']] = e['tick_size']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('OKEX', why, {url: r})\n-\n-\n-def bittrex_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.bittrex.com/api/v1.1/public/getmarkets')\n-        r = r.json()['result']\n-        return {f\"{e['MarketCurrency']}{SYMBOL_SEP}{e['BaseCurrency']}\": e['MarketName'] for e in r if e['IsActive']}\n-    except Exception as why:\n-        raise_failure_explanation('BITTREX', why, {\"\": r})\n-\n-\n-def bitcoincom_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.exchange.bitcoin.com/api/2/public/symbol')\n-        return {f\"{data['baseCurrency']}{SYMBOL_SEP}{data['quoteCurrency'].replace('USD', 'USDT')}\": data['id'] for data in r.json()}\n-    except Exception as why:\n-        raise_failure_explanation('BITCOINCOM', why, {\"\": r})\n-\n-\n-def bitmax_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://bitmax.io/api/pro/v1/products')\n-        ret = {}\n-        for entry in r.json()['data']:\n-            # Only \"Normal\" status symbols are tradeable\n-            if entry['status'] == 'Normal':\n-                normalized = f\"{entry['baseAsset']}{SYMBOL_SEP}{entry['quoteAsset']}\"\n-                ret[normalized] = entry['symbol']\n-                _exchange_info[BITMAX]['tick_size'][normalized] = entry['tickSize']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('BITMAX', why, {\"\": r})\n-\n-\n-def upbit_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.upbit.com/v1/market/all')\n-        return {f\"{data['market'].split('-')[1]}{SYMBOL_SEP}{data['market'].split('-')[0]}\": data['market'] for data in r.json()}\n-    except Exception as why:\n-        raise_failure_explanation('UPBIT', why, {\"\": r})\n-\n-\n-def blockchain_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get(\"https://api.blockchain.com/mercury-gateway/v1/instruments\")\n-        return {data[\"symbol\"].replace(\"-\", SYMBOL_SEP): data[\"symbol\"] for data in r.json()}\n-    except Exception as why:\n-        raise_failure_explanation('BLOCKCHAIN', why, {\"\": r})\n-\n-\n-def gateio_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get(\"https://api.gateio.ws/api/v4/spot/currency_pairs\")\n-        return {data[\"id\"].replace(\"_\", SYMBOL_SEP): data['id'] for data in r.json()}\n-    except Exception as why:\n-        raise_failure_explanation('GATEIO', why, {\"\": r})\n-\n-\n-def bitmex_symbols() -> Dict[str, str]:\n-    r = None\n-    ret = {}\n-    try:\n-        r = requests.get(\"https://www.bitmex.com/api/v1/instrument/active\")\n-        for entry in r.json():\n-            components = []\n-            components.append(entry['rootSymbol'])\n-            components.append(entry['quoteCurrency'])\n-\n-            if entry['expiry']:\n-                components.append(entry['symbol'][-3:])\n-\n-            normalized = SYMBOL_SEP.join(components)\n-            normalized = normalized.replace(\"XBT\", \"BTC\")\n-            ret[normalized] = entry['symbol']\n-            _exchange_info[BITMEX]['tick_size'][normalized] = entry['tickSize']\n-\n-            if entry['expiry']:\n-                _exchange_info[BITMEX]['expiry'][normalized] = entry['expiry']\n-\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('BITMEX', why, {\"\": r})\n-\n-\n-def deribit_symbols() -> Dict[str, str]:\n-    url = r = None\n-    ret = {}\n-    try:\n-        # TODO: get currencies from https://www.deribit.com/api/v2/public/get_currencies\n-        currencies = ['BTC', 'ETH']\n-        for c in currencies:\n-            url = f\"https://www.deribit.com/api/v2/public/get_instruments?currency={c}&expired=false\"\n-            r = requests.get(url)\n-            for entry in r.json()['result']:\n-                split = entry['instrument_name'].split(\"-\")\n-                normalized = split[0] + SYMBOL_SEP + entry['quote_currency'] + \"-\" + '-'.join(split[1:])\n-                ret[normalized] = entry['instrument_name']\n-                _exchange_info[DERIBIT]['tick_size'][normalized] = entry['tick_size']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('DERIBIT', why, {url: r})\n-\n-\n-def kraken_future_symbols() -> Dict[str, str]:\n-    r = None\n-    ret = {}\n-    try:\n-        r = requests.get('https://futures.kraken.com/derivatives/api/v3/instruments')\n-        data = r.json()['instruments']\n-        for entry in data:\n-            if not entry['tradeable']:\n-                continue\n-            normalized = entry['symbol'].upper().replace(\"_\", \"-\")\n-            symbol = normalized[3:6] + SYMBOL_SEP + normalized[6:9]\n-            normalized = normalized.replace(normalized[3:9], symbol)\n-            normalized = normalized.replace('XBT', 'BTC')\n-\n-            _exchange_info[KRAKEN_FUTURES]['tick_size'][normalized] = entry['tickSize']\n-            _exchange_info[KRAKEN_FUTURES]['contract_size'][normalized] = entry['contractSize']\n-            _exchange_info[KRAKEN_FUTURES]['underlying'][normalized] = entry['underlying']\n-            _exchange_info[KRAKEN_FUTURES]['product_type'][normalized] = _kraken_futures_product_type[normalized[:2]]\n-            ret[normalized] = entry['symbol']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('KRAKEN_FUTURES', why, {\"\": r})\n-\n-\n-def probit_symbols() -> Dict[str, str]:\n-    # doc: https://docs-en.probit.com/reference-link/market\n-    r = None\n-    try:\n-        r = requests.get('https://api.probit.com/api/exchange/v1/market')\n-        return {entry['id']: entry['id'] for entry in r.json()['data']}\n-    except Exception as why:\n-        raise_failure_explanation('PROBIT', why, {\"\": r})\n-\n-\n-def coingecko_normalize_symbol(symbol: str) -> str:\n-    # keep digits, letters and dots, replace others by space\n-    symbol = ''.join(c if c.isalnum() or c in ('.', '+') else ' ' for c in symbol)\n-    return coingecko_normalize(symbol.upper())\n-\n-\n-def coingecko_normalize_name(name: str) -> str:\n-    # keep digits and letters, replace others by space (except when only composed by upper case letters, digits and dots)\n-    if not all(c.isupper() or c.isdigit() or c == '.' for c in name):\n-        name = ''.join(c if c.isalnum() else ' ' for c in name)\n-    return coingecko_normalize(name)\n-\n-\n-def coingecko_normalize(sym: str) -> str:\n-    sym = sym.strip()\n-    # do not concatenate numbers => separate them with a dot\n-    sym = list(sym)\n-    if len(sym) > 4:\n-        for i in range(2, len(sym) - 1):\n-            if sym[i] == ' ' and sym[i - 1].isdigit() and sym[i + 1].isdigit():\n-                sym[i] = '.'\n-    sym = ''.join(sym)\n-    # concatenate space-separated words => use CamelCase to distinguish the words\n-    if ' ' in sym:\n-        if sum(c.islower() for c in sym):  # if there is at least one lower case letter\n-            sym = ' '.join(word[0].upper() + word[1:] for word in sym.split())  # Just capitalize initial letter of each word\n-        else:  # CoinGecko may provide full upper-case as for \"THE STONE COIN\"\n-            sym = string.capwords(sym)  # capwords converts \"THE STONE COIN\" to \"The Stone Coin\"\n-        sym = sym.replace(' ', '')  # concatenate words\n-    return sym\n-\n-\n-def is_name_short(coin: dict) -> bool:\n-    \"\"\"return True if the coin name is enough short compared to the coin symbol.\"\"\"\n-    return len(coin['name']) <= max(5, len(coin['symbol']) + 1)\n-\n-\n-def has_many_caps(name: str) -> bool:\n-    \"\"\"return True if the symbol contains enough upper case letters, False if empty.\"\"\"\n-    return str and sum(c.islower() for c in name) < (len(name) / 2)\n-\n-\n-def coingecko_normalize_all(coin: dict):\n-    SYMBOL_TO_NORMALIZED = {'miota': 'IOTA'}\n-    normalized = SYMBOL_TO_NORMALIZED.get(coin['symbol'])\n-    if normalized:\n-        coin['ns'] = coin['nn'] = normalized\n-        return normalized\n-\n-    # ns = normalized symbol, nn = normalized name\n-    coin['ns'] = coingecko_normalize_symbol(coin['symbol'])\n-\n-    ID_SUFFIX = '-bitcoin-token'\n-    if coin['id'][-len(ID_SUFFIX):] == ID_SUFFIX:\n-        coin['nn'] = 'BTC' + coin['ns']\n-        return coin['nn']\n-\n-    name = coin['name']\n-\n-    prefixes = ('The ', 'the ')\n-    for p in prefixes:\n-        if name[:len(p)] == p:\n-            coin['reduced-name'] = True\n-            name = name[len(p):]\n-            break\n-\n-    suffixes = ('coin', 'coins', 'money', 'finance', 'protocol', 'reward', 'rewards', 'token')\n-    for s in suffixes:\n-        if len(name) > len(s) and name[-len(s):].lower() == s:\n-            # but keep suffix when lower-case concatenated\n-            if name[-len(s)].islower() and name[-len(s) - 1] != ' ':\n-                continue\n-            # also keep suffix to avoid confusing nam: \"Bitcoin Token\" -> \"Bitcoin\"\n-            if name[:-len(s)].strip().lower() == 'bitcoin':\n-                continue\n-            coin['reduced-name'] = True\n-            name = name[:-len(s)]\n-            break\n-\n-    coin['nn'] = coingecko_normalize_name(name)\n-\n-    if len(coin['nn']) < len(coin['ns']):\n-        if 'reduced-name' in coin:\n-            coin['reduced-name'] = False\n-            name = coin['name']\n-            coin['nn'] = coingecko_normalize_name(name)\n-        elif not has_many_caps(name):\n-            return coin['ns']\n-\n-    if not coin['ns']:  # coin['symbol'] may be an emoji that is striped when normalized\n-        return coin['nn']\n-\n-    if coin.get('reduced-name') and coin['ns'].upper() != coin['nn'].upper():\n-        return coin['ns']\n-\n-    i = coin['nn'].find('.')  # if there is a dot in normalized name => prefer the normalized symbol\n-    if i >= 0:\n-        if i > 1 and coin['nn'][i - 1].isdigit() and coin['nn'][i + 1].isdigit():\n-            pass  # except when the dot separates digits\n-        else:\n-            return coin['ns']\n-\n-    if is_name_short(coin) and has_many_caps(name):\n-        return coin['nn']\n-\n-    if 1.5 * len(coin['ns']) > len(coin['nn']) and any(c.islower() for c in coin['ns']):\n-        return coin['nn']\n-\n-    return coin['ns']\n-\n-\n-def coingecko_symbols() -> Dict[str, str]:\n-    r = None\n-    intermediate = defaultdict(list)\n-    try:\n-        r = requests.get('https://api.coingecko.com/api/v3/coins/list')\n-        all_coins = r.json()\n-        # First pass: generate & compare normalized symbol/name, and then select the most pertinent\n-        for coin in all_coins:\n-            normalized = coingecko_normalize_all(coin)\n-            intermediate[normalized].append(coin)\n-            # Above line keeps together the coins having the same normalized symbol.\n-            # To reduce collision, the coin['name'] is sometimes used in lieu of the coin['symbol'].\n-            # The coin['name'] is not capitalized because lower case letters may be meaningful: cETH, yUSD, DATx, zLOT\n-    except Exception as why:\n-        raise_failure_explanation('COINGECKO', why, {\"\": r})\n-\n-    final = coingecko_second_pass(intermediate)\n-    return coingecko_third_pass(final)\n-\n-\n-def coingecko_second_pass(intermediate: Dict[str, List[dict]]) -> Dict[str, List[dict]]:\n-    # Second pass: fixes most of the symbol collisions\n-    final = defaultdict(list)\n-    for normalized, coins in intermediate.items():\n-        if len(coins) == 1:\n-            final[normalized].append(coins[0])\n-            continue\n-        set_normalized = False\n-        for i in range(len(coins)):\n-            if normalized == coins[i]['nn']:\n-                coin = coins.pop(i)\n-                final[normalized].append(coin)\n-                set_normalized = True\n-                break\n-        rest: List[dict] = []\n-        for coin in coins:\n-            if '%' in coin['name']:\n-                if len(coins) == 1:\n-                    n = coin['ns']\n-                else:\n-                    n = coingecko_normalize_name(coin['id'])\n-                final[n].append(coin)\n-            else:\n-                rest.append(coin)\n-        if not rest:\n-            continue\n-        if not set_normalized:\n-            rest.sort(key=lambda coin: len(coin['nn']), reverse=True)  # sort by the length of the normalized name\n-            coin = rest.pop(0)\n-            final[normalized].append(coin)\n-        for coin in rest:\n-            if coin['nn'] not in intermediate:\n-                n = coin['nn']\n-            elif coin.get('reduced-name'):\n-                n = coingecko_normalize_name(coin['name'])\n-            else:\n-                n = coingecko_normalize_name(coin['id'])\n-            final[n].append(coin)\n-    return final\n-\n-\n-def coingecko_third_pass(final: Dict[str, List[dict]]) -> Dict[str, str]:\n-    # Third pass: fixes some remaining collisions and fills the result\n-    symbols = {}\n-    for normalized, coins in final.items():\n-        if len(coins) == 1:\n-            symbols[normalized] = coins[0]['id']\n-            continue\n-        set_normalized = False\n-        for i in range(len(coins)):\n-            if normalized == coins[i]['nn']:\n-                coin = coins.pop(i)\n-                symbols[normalized] = coin['id']\n-                set_normalized = True\n-                break\n-        rest: List[dict] = []\n-        for coin in coins:\n-            if '%' in coin['name']:\n-                if len(coins) == 1:\n-                    n = coin['ns']\n-                else:\n-                    n = coingecko_normalize_name(coin['id'])\n-                symbols[n] = coin['id']\n-            else:\n-                rest.append(coin)\n-        if not rest:\n-            continue\n-        if not set_normalized:\n-            rest.sort(key=lambda coin: len(coin['nn']), reverse=True)  # sort by the length of the normalized name\n-            coin = rest.pop(0)\n-            symbols[normalized] = coin['id']\n-        for coin in rest:\n-            if coin['nn'] not in final:\n-                n = coin['nn']\n-            elif coin.get('reduced-name'):\n-                n = coingecko_normalize_name(coin['name'])\n-            else:\n-                n = coingecko_normalize_name(coin['id'])\n-            symbols[n] = coin['id']\n-    return symbols\n-\n-\n-def whale_alert_coins(key_id: str) -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get(f'https://api.whale-alert.io/v1/status?api_key={key_id}')\n-        # Same symbols, but on different blockchains (for instance USDT), are naturally overwritten.\n-        return {s.upper(): s for b in r.json()['blockchains'] for s in b['symbols'] if s}\n-    except Exception as why:\n-        raise_failure_explanation('WHALES_ALERT', why, {\"\": r})\n-\n-\n-_exchange_function_map = {\n-    BITFINEX: bitfinex_symbols,\n-    BITFLYER: bitflyer_symbols,\n-    COINBASE: coinbase_symbols,\n-    GEMINI: gemini_symbols,\n-    HITBTC: hitbtc_symbols,\n-    POLONIEX: poloniex_symbols,\n-    PROBIT: probit_symbols,\n-    BITSTAMP: bitstamp_symbols,\n-    KRAKEN: kraken_symbols,\n-    KRAKEN + 'REST': kraken_rest_symbols,\n-    BINANCE: binance_symbols,\n-    BINANCE_US: binance_us_symbols,\n-    BINANCE_FUTURES: binance_futures_symbols,\n-    BINANCE_DELIVERY: binance_delivery_symbols,\n-    BLOCKCHAIN: blockchain_symbols,\n-    EXX: exx_symbols,\n-    HUOBI: huobi_symbols,\n-    HUOBI_DM: huobi_dm_symbols,\n-    HUOBI_SWAP: huobi_swap_symbols,\n-    OKCOIN: okcoin_symbols,\n-    OKEX: okex_symbols,\n-    BYBIT: bybit_symbols,\n-    FTX: ftx_symbols,\n-    FTX_US: ftx_us_symbols,\n-    BITTREX: bittrex_symbols,\n-    BITCOINCOM: bitcoincom_symbols,\n-    BITMAX: bitmax_symbols,\n-    UPBIT: upbit_symbols,\n-    GATEIO: gateio_symbols,\n-    BITMEX: bitmex_symbols,\n-    DERIBIT: deribit_symbols,\n-    KRAKEN_FUTURES: kraken_future_symbols,\n-    COINGECKO: coingecko_symbols,\n-    WHALE_ALERT: whale_alert_coins\n-}\n+Symbols = _Symbols()\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\n\nimport logging\nimport string\nimport time\nfrom collections import defaultdict\nfrom typing import Dict, List, Optional, Tuple\n\nimport requests\nfrom requests import Response\n\nfrom cryptofeed.defines import *\n\n\nLOG = logging.getLogger('feedhandler')\n\nSYMBOL_SEP = '-'\n\n_symbols_retrieval_cache: Dict[str, Dict[str, str]] = {}\n_exchange_info = defaultdict(lambda: defaultdict(dict))\n\n\n_kraken_futures_product_type = {\n    'FI': 'Inverse Futures',\n    'FV': 'Vanilla Futures',\n    'PI': 'Perpetual Inverse Futures',\n    'PV': 'Perpetual Vanilla Futures',\n    'IN': 'Real Time Index',\n    'RR': 'Reference Rate',\n}\n\n\ndef raise_failure_explanation(feed_id: str, exception: BaseException, responses: Dict[str, Optional[Response]]):\n    <IND>LOG.critical('%s: encountered %r while processing response from exchange API', feed_id, exception)\n    if len(responses) > 1:\n        <IND>LOG.critical('%s: content of one of the %s responses was unexpected', feed_id, len(responses))\n    <DED>for url, r in responses.items():\n        <IND>if url:\n            <IND>LOG.critical('%s: requested URL: %s', feed_id, url)\n        <DED>if r:\n            <IND>LOG.critical('%s: unexpected response: %s', feed_id, r.text)\n    <DED><DED>raise ValueError(f'Cryptofeed stopped because of an unexpected response from {feed_id}') from exception\n\n\n<DED>def set_symbol_separator(separator: str):\n    <IND>global SYMBOL_SEP\n    SYMBOL_SEP = separator\n\n\n<DED>def get_symbol_separator() -> str:\n    <IND>global SYMBOL_SEP\n    return SYMBOL_SEP\n\n\n<DED>def gen_symbols(exchange: str, key_id=None) -> Dict[str, str]:\n    <IND>if exchange not in _symbols_retrieval_cache:\n        <IND>LOG.info(\"%s: Getting list of symbols\", exchange)\n        symbols = _exchange_function_map[exchange](key_id) if key_id else _exchange_function_map[exchange]()\n        LOG.info(\"%s: %s symbols\", exchange, len(symbols))\n\n        # log all retrieved symbols using debug level\n        for normalized, exch_sym in sorted(symbols.items()):\n            <IND>LOG.debug('%s: id-from-exch -> normalized: %-35s-> %s', exchange, exch_sym, normalized)\n\n        <DED>_symbols_retrieval_cache[exchange] = symbols\n    <DED>return _symbols_retrieval_cache[exchange]\n\n\n<DED>def _binance_symbols(endpoint: str, exchange: str):\n    <IND>r = None\n    try:\n        <IND>ret = {}\n        r = requests.get(endpoint)\n        for symbol in r.json()['symbols']:\n            <IND>if symbol.get('status', 'TRADING') != \"TRADING\":\n                <IND>continue\n            <DED>if symbol.get('contractStatus', 'TRADING') != \"TRADING\":\n                <IND>continue\n            <DED>split = len(symbol['baseAsset'])\n            normalized = symbol['symbol'][:split] + SYMBOL_SEP + symbol['symbol'][split:]\n            ret[normalized] = symbol['symbol']\n            _exchange_info[exchange]['tick_size'][normalized] = symbol['filters'][0]['tickSize']\n            if \"contractType\" in symbol:\n                <IND>_exchange_info[exchange]['contract_type'][normalized] = symbol['contractType']\n        <DED><DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation(exchange, why, {endpoint: r})\n\n\n<DED><DED>def binance_symbols() -> Dict[str, str]:\n    <IND>return _binance_symbols('https://api.binance.com/api/v3/exchangeInfo', BINANCE)\n\n\n<DED>def binance_us_symbols() -> Dict[str, str]:\n    <IND>return _binance_symbols('https://api.binance.us/api/v3/exchangeInfo', BINANCE_US)\n\n\n<DED>def binance_futures_symbols() -> Dict[str, str]:\n    <IND>base = _binance_symbols('https://fapi.binance.com/fapi/v1/exchangeInfo', BINANCE_FUTURES)\n    add = {}\n    for symbol, orig in base.items():\n        <IND>if \"_\" in orig:\n            <IND>continue\n        <DED>add[f\"{symbol}-PINDEX\"] = f\"p{orig}\"\n    <DED>base.update(add)\n    return base\n\n\n<DED>def binance_delivery_symbols() -> Dict[str, str]:\n    <IND>return _binance_symbols('https://dapi.binance.com/dapi/v1/exchangeInfo', BINANCE_DELIVERY)\n\n\n<DED>def bitfinex_symbols() -> Dict[str, str]:\n    # doc: https://docs.bitfinex.com/docs/ws-general#supported-pairs\n    <IND>r1 = r2 = None\n    try:\n        <IND>r1 = requests.get('https://api.bitfinex.com/v2/tickers?symbols=ALL')\n        r2 = requests.get('https://api-pub.bitfinex.com/v2/conf/pub:map:currency:sym')\n        tickers: List[List[str]] = r1.json()\n        norm: List[Tuple[str, str]] = r2.json()[0]\n        norm: Dict[str, str] = dict(norm)\n        for k, v in dict(norm).items():\n            <IND>if k[-2:] == 'F0' or '-' in v:  # Do not convert BTCF0 -> BTC or PBTCETH -> PBTC-ETH\n                <IND>del norm[k]\n        <DED><DED>norm['BCHN'] = 'BCH'  # Bitfinex uses BCHN, other exchanges use BCH\n\n        ret = {}\n        for symbol in [t[0] for t in tickers]:\n            <IND>if symbol[0] == 'f':\n                <IND>normalized = norm.get(symbol[1:], symbol[1:])\n            <DED>else:\n                <IND>if len(symbol) == 7:\n                    <IND>base, quote = symbol[1:4], symbol[4:]\n                <DED>else:\n                    <IND>base, quote = symbol[1:].split(':')\n                    assert ':' in symbol\n                <DED>normalized = norm.get(base, base) + SYMBOL_SEP + norm.get(quote, quote)\n            <DED>ret[normalized.upper()] = symbol\n        <DED>return ret\n    <DED>except ValueError as why:\n        <IND>raise_failure_explanation('BITFINEX', why, {\"tickers?symbols=ALL\": r1, \"pub:map:currency:sym\": r2})\n\n\n<DED><DED>def bitflyer_symbols() -> Dict[str, str]:\n    <IND>endpoint = r = None\n    try:\n        <IND>ret = {}\n        endpoints = ['https://api.bitflyer.com/v1/getmarkets/eu', 'https://api.bitflyer.com/v1/getmarkets/usa', 'https://api.bitflyer.com/v1/getmarkets']\n        for endpoint in endpoints:\n            <IND>r = requests.get(endpoint)\n            for entry in r.json():\n                <IND>normalized = entry['product_code'].replace(\"_\", SYMBOL_SEP)\n                ret[normalized] = entry['product_code']\n        <DED><DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BITFLYER', why, {endpoint: r})\n\n\n<DED><DED>def bybit_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.bybit.com/v2/public/symbols')\n        ret = {}\n        for symbol in r.json()['result']:\n            <IND>quote = symbol['quote_currency']\n            if not symbol['name'].endswith(quote):\n                <IND>base, contract = symbol['name'].split(quote)\n                normalized = f\"{base}{SYMBOL_SEP}{quote}-{contract}\"\n            <DED>else:\n                <IND>normalized = f\"{symbol['base_currency']}{SYMBOL_SEP}{quote}\"\n            <DED>ret[normalized] = symbol['name']\n            _exchange_info[BYBIT]['tick_size'][normalized] = symbol['price_filter']['tick_size']\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BYBIT', why, {\"\": r})\n\n\n<DED><DED>def _ftx_helper(endpoint: str, exchange: str):\n    <IND>r = None\n    try:\n        <IND>r = requests.get(endpoint)\n        ret = {}\n        for data in r.json()['result']:\n            <IND>normalized = data['name'].replace(\"/\", SYMBOL_SEP)\n            symbol = data['name']\n            ret[normalized] = symbol\n            _exchange_info[exchange]['tick_size'][normalized] = data['priceIncrement']\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation(exchange, why, {endpoint: r})\n\n\n<DED><DED>def ftx_symbols() -> Dict[str, str]:\n    <IND>return _ftx_helper('https://ftx.com/api/markets', FTX)\n\n\n<DED>def ftx_us_symbols() -> Dict[str, str]:\n    <IND>return _ftx_helper('https://ftx.us/api/markets', FTX_US)\n\n\n<DED>def coinbase_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.pro.coinbase.com/products')\n        ret = {}\n        for data in r.json():\n            <IND>normalized = data['id'].replace(\"-\", SYMBOL_SEP)\n            ret[normalized] = data['id']\n            _exchange_info[COINBASE]['tick_size'][normalized] = data['quote_increment']\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('COINBASE', why, {\"\": r})\n\n\n<DED><DED>def gemini_symbols(*args) -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.gemini.com/v1/symbols')\n        ret = {}\n        for symbol in r.json():\n            <IND>std = f\"{symbol[:-3]}{SYMBOL_SEP}{symbol[-3:]}\"\n            std = std.upper()\n            ret[std] = symbol.upper()\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('GEMINI', why, {\"\": r})\n\n\n<DED><DED>def hitbtc_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>ret = {}\n        r = requests.get('https://api.hitbtc.com/api/2/public/symbol')\n        for symbol in r.json():\n            <IND>split = len(symbol['baseCurrency'])\n            normalized = symbol['id'][:split] + SYMBOL_SEP + symbol['id'][split:]\n            ret[normalized] = symbol['id']\n            _exchange_info[HITBTC]['tick_size'][normalized] = symbol['tickSize']\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('HITBTC', why, {\"\": r})\n\n\n<DED><DED>def poloniex_id_symbol_mapping():\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://poloniex.com/public?command=returnTicker')\n        symbols = r.json()\n        ret = {}\n        for symbol in symbols:\n            <IND>ret[symbols[symbol]['id']] = symbol\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('POLONIEX', why, {\"\": r})\n\n\n<DED><DED>def poloniex_symbols() -> Dict[str, str]:\n    <IND>ret = {}\n    for _, value in poloniex_id_symbol_mapping().items():\n        <IND>std = value.replace(\"STR\", \"XLM\")\n        quote, base = std.split(\"_\")\n        ret[quote + SYMBOL_SEP + base] = value\n    <DED>return ret\n\n\n<DED>def bitstamp_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://www.bitstamp.net/api/v2/trading-pairs-info/')\n        ret = {}\n        for data in r.json():\n            <IND>normalized = data['name'].replace(\"/\", SYMBOL_SEP)\n            symbol = data['url_symbol']\n            ret[normalized] = symbol\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BITSTAMP', why, {\"\": r})\n\n\n<DED><DED>def kraken_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.kraken.com/0/public/AssetPairs')\n        data = r.json()\n        ret = {}\n        for symbol in data['result']:\n            <IND>if 'wsname' not in data['result'][symbol] or '.d' in symbol:\n                # https://blog.kraken.com/post/259/introducing-the-kraken-dark-pool/\n                # .d is for dark pool symbols\n                <IND>continue\n\n            <DED>base, quote = data['result'][symbol]['wsname'].split(\"/\")\n\n            normalized = f\"{base}{SYMBOL_SEP}{quote}\"\n            exch = data['result'][symbol]['wsname']\n            normalized = normalized.replace('XBT', 'BTC')\n            normalized = normalized.replace('XDG', 'DOG')\n            ret[normalized] = exch\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('KRAKEN', why, {\"\": r})\n\n\n<DED><DED>def kraken_rest_symbols() -> Dict[str, str]:\n    <IND>return {normalized: exchange.replace(\"/\", \"\") for normalized, exchange in kraken_symbols().items()}\n\n\n<DED>def exx_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.exx.com/data/v1/tickers')\n        exchange = [key.upper() for key in r.json().keys()]\n        symbols = [key.replace(\"_\", SYMBOL_SEP) for key in exchange]\n        return dict(zip(symbols, exchange))\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('EXX', why, {\"\": r})\n\n\n<DED><DED>def huobi_common_symbols(url: str):\n    <IND>r = None\n    try:\n        <IND>r = requests.get(url)\n        ret = {}\n        for e in r.json()['data']:\n            <IND>if e['state'] == 'offline':\n                <IND>continue\n            <DED>normalized = f\"{e['base-currency'].upper()}{SYMBOL_SEP}{e['quote-currency'].upper()}\"\n            symbol = f\"{e['base-currency']}{e['quote-currency']}\"\n            ret[normalized] = symbol\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('HUOBI', why, {url: r})\n\n\n<DED><DED>def huobi_symbols() -> Dict[str, str]:\n    <IND>return huobi_common_symbols('https://api.huobi.pro/v1/common/symbols')\n\n\n<DED>def huobi_us_symbols() -> Dict[str, str]:\n    <IND>return huobi_common_symbols('https://api.huobi.com/v1/common/symbols')\n\n\n<DED>def huobi_dm_symbols() -> Dict[str, str]:\n    <IND>\"\"\"\n    Mapping is, for instance: {\"BTC_CW\":\"BTC190816\"}\n    See comments in exchange/huobi_dm.py\n    \"\"\"\n    mapping = {\n        \"this_week\": \"CW\",\n        \"next_week\": \"NW\",\n        \"quarter\": \"CQ\",\n        \"next_quarter\": \"NQ\"\n    }\n    r = None\n    try:\n        <IND>r = requests.get('https://www.hbdm.com/api/v1/contract_contract_info')\n        symbols = {}\n        for e in r.json()['data']:\n            <IND>symbols[f\"{e['symbol']}_{mapping[e['contract_type']]}\"] = e['contract_code']\n            _exchange_info[HUOBI_DM]['tick_size'][e['contract_code']] = e['price_tick']\n            _exchange_info[HUOBI_DM]['short_code_mappings'][f\"{e['symbol']}_{mapping[e['contract_type']]}\"] = e['contract_code']\n        <DED>return symbols\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('HUOBI_DM', why, {\"\": r})\n\n\n<DED><DED>def huobi_swap_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.hbdm.com/swap-api/v1/swap_contract_info')\n        symbols = {}\n        for e in r.json()['data']:\n            <IND>symbols[e['contract_code']] = e['contract_code']\n            _exchange_info[HUOBI_SWAP]['tick_size'][e['contract_code']] = e['price_tick']\n        <DED>return symbols\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('HUOBI_SWAP', why, {\"\": r})\n\n\n<DED><DED>def okcoin_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://www.okcoin.com/api/spot/v3/instruments')\n        ret = {}\n        for e in r.json():\n            <IND>ret[e['instrument_id']] = e['instrument_id']\n            _exchange_info[OKCOIN]['tick_size'][e['instrument_id']] = e['tick_size']\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('OKCOIN', why, {\"\": r})\n\n\n<DED><DED>def okex_symbols(*args) -> Dict[str, str]:\n    <IND>urls = ['https://www.okex.com/api/spot/v3/instruments',\n            'https://www.okex.com/api/swap/v3/instruments',\n            'https://www.okex.com/api/futures/v3/instruments']\n    urls = urls + okex_compute_option_urls_from_underlyings()\n\n    symbols: Dict[str, str] = {}\n    for u in urls:\n        <IND>time.sleep(0.2)\n        symbols.update(okex_symbols_from_one_url(u))\n\n    <DED>for symbol in symbols:\n        <IND>instrument_type = 'futures'\n        dash_count = symbol.count(get_symbol_separator())\n        if dash_count == 1:  # BTC-USDT\n            <IND>instrument_type = 'spot'\n        <DED>if dash_count == 4:  # BTC-USD-201225-35000-P\n            <IND>instrument_type = 'option'\n        <DED>if symbol[-4:] == \"SWAP\":  # BTC-USDT-SWAP\n            <IND>instrument_type = 'swap'\n\n        <DED>_exchange_info[OKEX]['instrument_type'][symbol] = instrument_type\n\n    <DED>return symbols\n\n\n<DED>def okex_compute_option_urls_from_underlyings() -> List[str]:\n    <IND>url = 'https://www.okex.com/api/option/v3/underlying'\n    r = None\n    try:\n        <IND>r = requests.get(url)\n        return [f'https://www.okex.com/api/option/v3/instruments/{underlying}' for underlying in r.json()]\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('OKEX', why, {url: r})\n\n\n<DED><DED>def okex_symbols_from_one_url(url: str) -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get(url)\n        ret = {}\n        for e in r.json():\n            <IND>ret[e['instrument_id']] = e['instrument_id']\n            _exchange_info[OKEX]['tick_size'][e['instrument_id']] = e['tick_size']\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('OKEX', why, {url: r})\n\n\n<DED><DED>def bittrex_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.bittrex.com/api/v1.1/public/getmarkets')\n        r = r.json()['result']\n        return {f\"{e['MarketCurrency']}{SYMBOL_SEP}{e['BaseCurrency']}\": e['MarketName'] for e in r if e['IsActive']}\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BITTREX', why, {\"\": r})\n\n\n<DED><DED>def bitcoincom_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.exchange.bitcoin.com/api/2/public/symbol')\n        return {f\"{data['baseCurrency']}{SYMBOL_SEP}{data['quoteCurrency'].replace('USD', 'USDT')}\": data['id'] for data in r.json()}\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BITCOINCOM', why, {\"\": r})\n\n\n<DED><DED>def bitmax_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://bitmax.io/api/pro/v1/products')\n        ret = {}\n        for entry in r.json()['data']:\n            # Only \"Normal\" status symbols are tradeable\n            <IND>if entry['status'] == 'Normal':\n                <IND>normalized = f\"{entry['baseAsset']}{SYMBOL_SEP}{entry['quoteAsset']}\"\n                ret[normalized] = entry['symbol']\n                _exchange_info[BITMAX]['tick_size'][normalized] = entry['tickSize']\n        <DED><DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BITMAX', why, {\"\": r})\n\n\n<DED><DED>def upbit_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.upbit.com/v1/market/all')\n        return {f\"{data['market'].split('-')[1]}{SYMBOL_SEP}{data['market'].split('-')[0]}\": data['market'] for data in r.json()}\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('UPBIT', why, {\"\": r})\n\n\n<DED><DED>def blockchain_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get(\"https://api.blockchain.com/mercury-gateway/v1/instruments\")\n        return {data[\"symbol\"].replace(\"-\", SYMBOL_SEP): data[\"symbol\"] for data in r.json()}\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BLOCKCHAIN', why, {\"\": r})\n\n\n<DED><DED>def gateio_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get(\"https://api.gateio.ws/api/v4/spot/currency_pairs\")\n        return {data[\"id\"].replace(\"_\", SYMBOL_SEP): data['id'] for data in r.json()}\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('GATEIO', why, {\"\": r})\n\n\n<DED><DED>def bitmex_symbols() -> Dict[str, str]:\n    <IND>r = None\n    ret = {}\n    try:\n        <IND>r = requests.get(\"https://www.bitmex.com/api/v1/instrument/active\")\n        for entry in r.json():\n            <IND>components = []\n            components.append(entry['rootSymbol'])\n            components.append(entry['quoteCurrency'])\n\n            if entry['expiry']:\n                <IND>components.append(entry['symbol'][-3:])\n\n            <DED>normalized = SYMBOL_SEP.join(components)\n            normalized = normalized.replace(\"XBT\", \"BTC\")\n            ret[normalized] = entry['symbol']\n            _exchange_info[BITMEX]['tick_size'][normalized] = entry['tickSize']\n\n            if entry['expiry']:\n                <IND>_exchange_info[BITMEX]['expiry'][normalized] = entry['expiry']\n\n        <DED><DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BITMEX', why, {\"\": r})\n\n\n<DED><DED>def deribit_symbols() -> Dict[str, str]:\n    <IND>url = r = None\n    ret = {}\n    try:\n        # TODO: get currencies from https://www.deribit.com/api/v2/public/get_currencies\n        <IND>currencies = ['BTC', 'ETH']\n        for c in currencies:\n            <IND>url = f\"https://www.deribit.com/api/v2/public/get_instruments?currency={c}&expired=false\"\n            r = requests.get(url)\n            for entry in r.json()['result']:\n                <IND>split = entry['instrument_name'].split(\"-\")\n                normalized = split[0] + SYMBOL_SEP + entry['quote_currency'] + \"-\" + '-'.join(split[1:])\n                ret[normalized] = entry['instrument_name']\n                _exchange_info[DERIBIT]['tick_size'][normalized] = entry['tick_size']\n        <DED><DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('DERIBIT', why, {url: r})\n\n\n<DED><DED>def kraken_future_symbols() -> Dict[str, str]:\n    <IND>r = None\n    ret = {}\n    try:\n        <IND>r = requests.get('https://futures.kraken.com/derivatives/api/v3/instruments')\n        data = r.json()['instruments']\n        for entry in data:\n            <IND>if not entry['tradeable']:\n                <IND>continue\n            <DED>normalized = entry['symbol'].upper().replace(\"_\", \"-\")\n            symbol = normalized[3:6] + SYMBOL_SEP + normalized[6:9]\n            normalized = normalized.replace(normalized[3:9], symbol)\n            normalized = normalized.replace('XBT', 'BTC')\n\n            _exchange_info[KRAKEN_FUTURES]['tick_size'][normalized] = entry['tickSize']\n            _exchange_info[KRAKEN_FUTURES]['contract_size'][normalized] = entry['contractSize']\n            _exchange_info[KRAKEN_FUTURES]['underlying'][normalized] = entry['underlying']\n            _exchange_info[KRAKEN_FUTURES]['product_type'][normalized] = _kraken_futures_product_type[normalized[:2]]\n            ret[normalized] = entry['symbol']\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('KRAKEN_FUTURES', why, {\"\": r})\n\n\n<DED><DED>def probit_symbols() -> Dict[str, str]:\n    # doc: https://docs-en.probit.com/reference-link/market\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.probit.com/api/exchange/v1/market')\n        return {entry['id']: entry['id'] for entry in r.json()['data']}\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('PROBIT', why, {\"\": r})\n\n\n<DED><DED>def coingecko_normalize_symbol(symbol: str) -> str:\n    # keep digits, letters and dots, replace others by space\n    <IND>symbol = ''.join(c if c.isalnum() or c in ('.', '+') else ' ' for c in symbol)\n    return coingecko_normalize(symbol.upper())\n\n\n<DED>def coingecko_normalize_name(name: str) -> str:\n    # keep digits and letters, replace others by space (except when only composed by upper case letters, digits and dots)\n    <IND>if not all(c.isupper() or c.isdigit() or c == '.' for c in name):\n        <IND>name = ''.join(c if c.isalnum() else ' ' for c in name)\n    <DED>return coingecko_normalize(name)\n\n\n<DED>def coingecko_normalize(sym: str) -> str:\n    <IND>sym = sym.strip()\n    # do not concatenate numbers => separate them with a dot\n    sym = list(sym)\n    if len(sym) > 4:\n        <IND>for i in range(2, len(sym) - 1):\n            <IND>if sym[i] == ' ' and sym[i - 1].isdigit() and sym[i + 1].isdigit():\n                <IND>sym[i] = '.'\n    <DED><DED><DED>sym = ''.join(sym)\n    # concatenate space-separated words => use CamelCase to distinguish the words\n    if ' ' in sym:\n        <IND>if sum(c.islower() for c in sym):  # if there is at least one lower case letter\n            <IND>sym = ' '.join(word[0].upper() + word[1:] for word in sym.split())  # Just capitalize initial letter of each word\n        <DED>else:  # CoinGecko may provide full upper-case as for \"THE STONE COIN\"\n            <IND>sym = string.capwords(sym)  # capwords converts \"THE STONE COIN\" to \"The Stone Coin\"\n        <DED>sym = sym.replace(' ', '')  # concatenate words\n    <DED>return sym\n\n\n<DED>def is_name_short(coin: dict) -> bool:\n    <IND>\"\"\"return True if the coin name is enough short compared to the coin symbol.\"\"\"\n    return len(coin['name']) <= max(5, len(coin['symbol']) + 1)\n\n\n<DED>def has_many_caps(name: str) -> bool:\n    <IND>\"\"\"return True if the symbol contains enough upper case letters, False if empty.\"\"\"\n    return str and sum(c.islower() for c in name) < (len(name) / 2)\n\n\n<DED>def coingecko_normalize_all(coin: dict):\n    <IND>SYMBOL_TO_NORMALIZED = {'miota': 'IOTA'}\n    normalized = SYMBOL_TO_NORMALIZED.get(coin['symbol'])\n    if normalized:\n        <IND>coin['ns'] = coin['nn'] = normalized\n        return normalized\n\n    # ns = normalized symbol, nn = normalized name\n    <DED>coin['ns'] = coingecko_normalize_symbol(coin['symbol'])\n\n    ID_SUFFIX = '-bitcoin-token'\n    if coin['id'][-len(ID_SUFFIX):] == ID_SUFFIX:\n        <IND>coin['nn'] = 'BTC' + coin['ns']\n        return coin['nn']\n\n    <DED>name = coin['name']\n\n    prefixes = ('The ', 'the ')\n    for p in prefixes:\n        <IND>if name[:len(p)] == p:\n            <IND>coin['reduced-name'] = True\n            name = name[len(p):]\n            break\n\n    <DED><DED>suffixes = ('coin', 'coins', 'money', 'finance', 'protocol', 'reward', 'rewards', 'token')\n    for s in suffixes:\n        <IND>if len(name) > len(s) and name[-len(s):].lower() == s:\n            # but keep suffix when lower-case concatenated\n            <IND>if name[-len(s)].islower() and name[-len(s) - 1] != ' ':\n                <IND>continue\n            # also keep suffix to avoid confusing nam: \"Bitcoin Token\" -> \"Bitcoin\"\n            <DED>if name[:-len(s)].strip().lower() == 'bitcoin':\n                <IND>continue\n            <DED>coin['reduced-name'] = True\n            name = name[:-len(s)]\n            break\n\n    <DED><DED>coin['nn'] = coingecko_normalize_name(name)\n\n    if len(coin['nn']) < len(coin['ns']):\n        <IND>if 'reduced-name' in coin:\n            <IND>coin['reduced-name'] = False\n            name = coin['name']\n            coin['nn'] = coingecko_normalize_name(name)\n        <DED>elif not has_many_caps(name):\n            <IND>return coin['ns']\n\n    <DED><DED>if not coin['ns']:  # coin['symbol'] may be an emoji that is striped when normalized\n        <IND>return coin['nn']\n\n    <DED>if coin.get('reduced-name') and coin['ns'].upper() != coin['nn'].upper():\n        <IND>return coin['ns']\n\n    <DED>i = coin['nn'].find('.')  # if there is a dot in normalized name => prefer the normalized symbol\n    if i >= 0:\n        <IND>if i > 1 and coin['nn'][i - 1].isdigit() and coin['nn'][i + 1].isdigit():\n            <IND>pass  # except when the dot separates digits\n        <DED>else:\n            <IND>return coin['ns']\n\n    <DED><DED>if is_name_short(coin) and has_many_caps(name):\n        <IND>return coin['nn']\n\n    <DED>if 1.5 * len(coin['ns']) > len(coin['nn']) and any(c.islower() for c in coin['ns']):\n        <IND>return coin['nn']\n\n    <DED>return coin['ns']\n\n\n<DED>def coingecko_symbols() -> Dict[str, str]:\n    <IND>r = None\n    intermediate = defaultdict(list)\n    try:\n        <IND>r = requests.get('https://api.coingecko.com/api/v3/coins/list')\n        all_coins = r.json()\n        # First pass: generate & compare normalized symbol/name, and then select the most pertinent\n        for coin in all_coins:\n            <IND>normalized = coingecko_normalize_all(coin)\n            intermediate[normalized].append(coin)\n            # Above line keeps together the coins having the same normalized symbol.\n            # To reduce collision, the coin['name'] is sometimes used in lieu of the coin['symbol'].\n            # The coin['name'] is not capitalized because lower case letters may be meaningful: cETH, yUSD, DATx, zLOT\n    <DED><DED>except Exception as why:\n        <IND>raise_failure_explanation('COINGECKO', why, {\"\": r})\n\n    <DED>final = coingecko_second_pass(intermediate)\n    return coingecko_third_pass(final)\n\n\n<DED>def coingecko_second_pass(intermediate: Dict[str, List[dict]]) -> Dict[str, List[dict]]:\n    # Second pass: fixes most of the symbol collisions\n    <IND>final = defaultdict(list)\n    for normalized, coins in intermediate.items():\n        <IND>if len(coins) == 1:\n            <IND>final[normalized].append(coins[0])\n            continue\n        <DED>set_normalized = False\n        for i in range(len(coins)):\n            <IND>if normalized == coins[i]['nn']:\n                <IND>coin = coins.pop(i)\n                final[normalized].append(coin)\n                set_normalized = True\n                break\n        <DED><DED>rest: List[dict] = []\n        for coin in coins:\n            <IND>if '%' in coin['name']:\n                <IND>if len(coins) == 1:\n                    <IND>n = coin['ns']\n                <DED>else:\n                    <IND>n = coingecko_normalize_name(coin['id'])\n                <DED>final[n].append(coin)\n            <DED>else:\n                <IND>rest.append(coin)\n        <DED><DED>if not rest:\n            <IND>continue\n        <DED>if not set_normalized:\n            <IND>rest.sort(key=lambda coin: len(coin['nn']), reverse=True)  # sort by the length of the normalized name\n            coin = rest.pop(0)\n            final[normalized].append(coin)\n        <DED>for coin in rest:\n            <IND>if coin['nn'] not in intermediate:\n                <IND>n = coin['nn']\n            <DED>elif coin.get('reduced-name'):\n                <IND>n = coingecko_normalize_name(coin['name'])\n            <DED>else:\n                <IND>n = coingecko_normalize_name(coin['id'])\n            <DED>final[n].append(coin)\n    <DED><DED>return final\n\n\n<DED>def coingecko_third_pass(final: Dict[str, List[dict]]) -> Dict[str, str]:\n    # Third pass: fixes some remaining collisions and fills the result\n    <IND>symbols = {}\n    for normalized, coins in final.items():\n        <IND>if len(coins) == 1:\n            <IND>symbols[normalized] = coins[0]['id']\n            continue\n        <DED>set_normalized = False\n        for i in range(len(coins)):\n            <IND>if normalized == coins[i]['nn']:\n                <IND>coin = coins.pop(i)\n                symbols[normalized] = coin['id']\n                set_normalized = True\n                break\n        <DED><DED>rest: List[dict] = []\n        for coin in coins:\n            <IND>if '%' in coin['name']:\n                <IND>if len(coins) == 1:\n                    <IND>n = coin['ns']\n                <DED>else:\n                    <IND>n = coingecko_normalize_name(coin['id'])\n                <DED>symbols[n] = coin['id']\n            <DED>else:\n                <IND>rest.append(coin)\n        <DED><DED>if not rest:\n            <IND>continue\n        <DED>if not set_normalized:\n            <IND>rest.sort(key=lambda coin: len(coin['nn']), reverse=True)  # sort by the length of the normalized name\n            coin = rest.pop(0)\n            symbols[normalized] = coin['id']\n        <DED>for coin in rest:\n            <IND>if coin['nn'] not in final:\n                <IND>n = coin['nn']\n            <DED>elif coin.get('reduced-name'):\n                <IND>n = coingecko_normalize_name(coin['name'])\n            <DED>else:\n                <IND>n = coingecko_normalize_name(coin['id'])\n            <DED>symbols[n] = coin['id']\n    <DED><DED>return symbols\n\n\n<DED>def whale_alert_coins(key_id: str) -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get(f'https://api.whale-alert.io/v1/status?api_key={key_id}')\n        # Same symbols, but on different blockchains (for instance USDT), are naturally overwritten.\n        return {s.upper(): s for b in r.json()['blockchains'] for s in b['symbols'] if s}\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('WHALES_ALERT', why, {\"\": r})\n\n\n<DED><DED>_exchange_function_map = {\n    BITFINEX: bitfinex_symbols,\n    BITFLYER: bitflyer_symbols,\n    COINBASE: coinbase_symbols,\n    GEMINI: gemini_symbols,\n    HITBTC: hitbtc_symbols,\n    POLONIEX: poloniex_symbols,\n    PROBIT: probit_symbols,\n    BITSTAMP: bitstamp_symbols,\n    KRAKEN: kraken_symbols,\n    KRAKEN + 'REST': kraken_rest_symbols,\n    BINANCE: binance_symbols,\n    BINANCE_US: binance_us_symbols,\n    BINANCE_FUTURES: binance_futures_symbols,\n    BINANCE_DELIVERY: binance_delivery_symbols,\n    BLOCKCHAIN: blockchain_symbols,\n    EXX: exx_symbols,\n    HUOBI: huobi_symbols,\n    HUOBI_DM: huobi_dm_symbols,\n    HUOBI_SWAP: huobi_swap_symbols,\n    OKCOIN: okcoin_symbols,\n    OKEX: okex_symbols,\n    BYBIT: bybit_symbols,\n    FTX: ftx_symbols,\n    FTX_US: ftx_us_symbols,\n    BITTREX: bittrex_symbols,\n    BITCOINCOM: bitcoincom_symbols,\n    BITMAX: bitmax_symbols,\n    UPBIT: upbit_symbols,\n    GATEIO: gateio_symbols,\n    BITMEX: bitmex_symbols,\n    DERIBIT: deribit_symbols,\n    KRAKEN_FUTURES: kraken_future_symbols,\n    COINGECKO: coingecko_symbols,\n    WHALE_ALERT: whale_alert_coins\n}\n",
        "target_code_with_indent": "\nfrom typing import Dict, Tuple\n\n\nclass _Symbols:\n    <IND>def __init__(self):\n        <IND>self.data = {}\n\n    <DED>def set(self, exchange: str, normalized: dict, exchange_info: dict):\n        <IND>self.data[exchange] = {}\n        self.data[exchange]['normalized'] = normalized\n        self.data[exchange]['info'] = exchange_info\n\n    <DED>def get(self, exchange: str) -> Tuple[Dict, Dict]:\n        <IND>return self.data[exchange]['normalized'], self.data[exchange]['info']\n\n    <DED>def populated(self, exchange: str) -> bool:\n        <IND>return exchange in self.data\n\n\n<DED><DED>Symbols = _Symbols()\n"
      }
    ]
  },
  {
    "project": "bmoscon/cryptofeed",
    "commit": "3525dc8ce4d7836a9abaaa5662e58e5e27969a77",
    "filename": "cryptofeed/symbols.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/bmoscon-cryptofeed/cryptofeed/symbols.py",
    "file_hunks_size": 1,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "cryptofeed/symbols.py:324:8 Incompatible return type [7]: Expected `Dict[str, str]` but got implicit return value of `None`.",
    "message": " Expected `Dict[str, str]` but got implicit return value of `None`.",
    "rule_id": "Incompatible return type [7]",
    "warning_line_no": 324,
    "warning_line": "        raise_failure_explanation('EXX', why, {\"\": r})",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "associated with this software.\n\n\nSymbol generation code for exchanges\n'''\n\nimport logging\nimport string\nimport time\nfrom collections import defaultdict\nfrom typing import Dict, List, Optional, Tuple\n\nimport requests\nfrom requests import Response\n\nfrom cryptofeed.defines import *\n\n\nLOG = logging.getLogger('feedhandler')\n\nSYMBOL_SEP = '-'\n\n_symbols_retrieval_cache: Dict[str, Dict[str, str]] = {}\n_exchange_info = defaultdict(lambda: defaultdict(dict))\n\n\n_kraken_futures_product_type = {\n    'FI': 'Inverse Futures',\n    'FV': 'Vanilla Futures',\n    'PI': 'Perpetual Inverse Futures',\n    'PV': 'Perpetual Vanilla Futures',\n    'IN': 'Real Time Index',\n    'RR': 'Reference Rate',\n}\n\n\ndef raise_failure_explanation(feed_id: str, exception: BaseException, responses: Dict[str, Optional[Response]]):\n    LOG.critical('%s: encountered %r while processing response from exchange API', feed_id, exception)\n    if len(responses) > 1:\n        LOG.critical('%s: content of one of the %s responses was unexpected', feed_id, len(responses))\n    for url, r in responses.items():\n        if url:\n            LOG.critical('%s: requested URL: %s', feed_id, url)\n        if r:\n            LOG.critical('%s: unexpected response: %s', feed_id, r.text)\n    raise ValueError(f'Cryptofeed stopped because of an unexpected response from {feed_id}') from exception\n\n\ndef set_symbol_separator(separator: str):\n    global SYMBOL_SEP\n    SYMBOL_SEP = separator\n\n\ndef get_symbol_separator() -> str:\n    global SYMBOL_SEP\n    return SYMBOL_SEP\n\n\ndef gen_symbols(exchange: str, key_id=None) -> Dict[str, str]:\n    if exchange not in _symbols_retrieval_cache:\n        LOG.info(\"%s: Getting list of symbols\", exchange)\n        symbols = _exchange_function_map[exchange](key_id) if key_id else _exchange_function_map[exchange]()\n        LOG.info(\"%s: %s symbols\", exchange, len(symbols))\n\n        # log all retrieved symbols using debug level\n        for normalized, exch_sym in sorted(symbols.items()):\n            LOG.debug('%s: id-from-exch -> normalized: %-35s-> %s', exchange, exch_sym, normalized)\n\n        _symbols_retrieval_cache[exchange] = symbols\n    return _symbols_retrieval_cache[exchange]\n\n\ndef _binance_symbols(endpoint: str, exchange: str):\n    r = None\n    try:\n        ret = {}\n        r = requests.get(endpoint)\n        for symbol in r.json()['symbols']:\n            if symbol.get('status', 'TRADING') != \"TRADING\":\n                continue\n            if symbol.get('contractStatus', 'TRADING') != \"TRADING\":\n                continue\n            split = len(symbol['baseAsset'])\n            normalized = symbol['symbol'][:split] + SYMBOL_SEP + symbol['symbol'][split:]\n            ret[normalized] = symbol['symbol']\n            _exchange_info[exchange]['tick_size'][normalized] = symbol['filters'][0]['tickSize']\n            if \"contractType\" in symbol:\n                _exchange_info[exchange]['contract_type'][normalized] = symbol['contractType']\n        return ret\n    except Exception as why:\n        raise_failure_explanation(exchange, why, {endpoint: r})\n\n\ndef binance_symbols() -> Dict[str, str]:\n    return _binance_symbols('https://api.binance.com/api/v3/exchangeInfo', BINANCE)\n\n\ndef binance_us_symbols() -> Dict[str, str]:\n    return _binance_symbols('https://api.binance.us/api/v3/exchangeInfo', BINANCE_US)\n\n\ndef binance_futures_symbols() -> Dict[str, str]:\n    base = _binance_symbols('https://fapi.binance.com/fapi/v1/exchangeInfo', BINANCE_FUTURES)\n    add = {}\n    for symbol, orig in base.items():\n        if \"_\" in orig:\n            continue\n        add[f\"{symbol}-PINDEX\"] = f\"p{orig}\"\n    base.update(add)\n    return base\n\n\ndef binance_delivery_symbols() -> Dict[str, str]:\n    return _binance_symbols('https://dapi.binance.com/dapi/v1/exchangeInfo', BINANCE_DELIVERY)\n\n\ndef bitfinex_symbols() -> Dict[str, str]:\n    # doc: https://docs.bitfinex.com/docs/ws-general#supported-pairs\n    r1 = r2 = None\n    try:\n        r1 = requests.get('https://api.bitfinex.com/v2/tickers?symbols=ALL')\n        r2 = requests.get('https://api-pub.bitfinex.com/v2/conf/pub:map:currency:sym')\n        tickers: List[List[str]] = r1.json()\n        norm: List[Tuple[str, str]] = r2.json()[0]\n        norm: Dict[str, str] = dict(norm)\n        for k, v in dict(norm).items():\n            if k[-2:] == 'F0' or '-' in v:  # Do not convert BTCF0 -> BTC or PBTCETH -> PBTC-ETH\n                del norm[k]\n        norm['BCHN'] = 'BCH'  # Bitfinex uses BCHN, other exchanges use BCH\n\n        ret = {}\n        for symbol in [t[0] for t in tickers]:\n            if symbol[0] == 'f':\n                normalized = norm.get(symbol[1:], symbol[1:])\n            else:\n                if len(symbol) == 7:\n                    base, quote = symbol[1:4], symbol[4:]\n                else:\n                    base, quote = symbol[1:].split(':')\n                    assert ':' in symbol\n                normalized = norm.get(base, base) + SYMBOL_SEP + norm.get(quote, quote)\n            ret[normalized.upper()] = symbol\n        return ret\n    except ValueError as why:\n        raise_failure_explanation('BITFINEX', why, {\"tickers?symbols=ALL\": r1, \"pub:map:currency:sym\": r2})\n\n\ndef bitflyer_symbols() -> Dict[str, str]:\n    endpoint = r = None\n    try:\n        ret = {}\n        endpoints = ['https://api.bitflyer.com/v1/getmarkets/eu', 'https://api.bitflyer.com/v1/getmarkets/usa', 'https://api.bitflyer.com/v1/getmarkets']\n        for endpoint in endpoints:\n            r = requests.get(endpoint)\n            for entry in r.json():\n                normalized = entry['product_code'].replace(\"_\", SYMBOL_SEP)\n                ret[normalized] = entry['product_code']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('BITFLYER', why, {endpoint: r})\n\n\ndef bybit_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.bybit.com/v2/public/symbols')\n        ret = {}\n        for symbol in r.json()['result']:\n            quote = symbol['quote_currency']\n            if not symbol['name'].endswith(quote):\n                base, contract = symbol['name'].split(quote)\n                normalized = f\"{base}{SYMBOL_SEP}{quote}-{contract}\"\n            else:\n                normalized = f\"{symbol['base_currency']}{SYMBOL_SEP}{quote}\"\n            ret[normalized] = symbol['name']\n            _exchange_info[BYBIT]['tick_size'][normalized] = symbol['price_filter']['tick_size']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('BYBIT', why, {\"\": r})\n\n\ndef _ftx_helper(endpoint: str, exchange: str):\n    r = None\n    try:\n        r = requests.get(endpoint)\n        ret = {}\n        for data in r.json()['result']:\n            normalized = data['name'].replace(\"/\", SYMBOL_SEP)\n            symbol = data['name']\n            ret[normalized] = symbol\n            _exchange_info[exchange]['tick_size'][normalized] = data['priceIncrement']\n        return ret\n    except Exception as why:\n        raise_failure_explanation(exchange, why, {endpoint: r})\n\n\ndef ftx_symbols() -> Dict[str, str]:\n    return _ftx_helper('https://ftx.com/api/markets', FTX)\n\n\ndef ftx_us_symbols() -> Dict[str, str]:\n    return _ftx_helper('https://ftx.us/api/markets', FTX_US)\n\n\ndef coinbase_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.pro.coinbase.com/products')\n        ret = {}\n        for data in r.json():\n            normalized = data['id'].replace(\"-\", SYMBOL_SEP)\n            ret[normalized] = data['id']\n            _exchange_info[COINBASE]['tick_size'][normalized] = data['quote_increment']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('COINBASE', why, {\"\": r})\n\n\ndef gemini_symbols(*args) -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.gemini.com/v1/symbols')\n        ret = {}\n        for symbol in r.json():\n            std = f\"{symbol[:-3]}{SYMBOL_SEP}{symbol[-3:]}\"\n            std = std.upper()\n            ret[std] = symbol.upper()\n        return ret\n    except Exception as why:\n        raise_failure_explanation('GEMINI', why, {\"\": r})\n\n\ndef hitbtc_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        ret = {}\n        r = requests.get('https://api.hitbtc.com/api/2/public/symbol')\n        for symbol in r.json():\n            split = len(symbol['baseCurrency'])\n            normalized = symbol['id'][:split] + SYMBOL_SEP + symbol['id'][split:]\n            ret[normalized] = symbol['id']\n            _exchange_info[HITBTC]['tick_size'][normalized] = symbol['tickSize']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('HITBTC', why, {\"\": r})\n\n\ndef poloniex_id_symbol_mapping():\n    r = None\n    try:\n        r = requests.get('https://poloniex.com/public?command=returnTicker')\n        symbols = r.json()\n        ret = {}\n        for symbol in symbols:\n            ret[symbols[symbol]['id']] = symbol\n        return ret\n    except Exception as why:\n        raise_failure_explanation('POLONIEX', why, {\"\": r})\n\n\ndef poloniex_symbols() -> Dict[str, str]:\n    ret = {}\n    for _, value in poloniex_id_symbol_mapping().items():\n        std = value.replace(\"STR\", \"XLM\")\n        quote, base = std.split(\"_\")\n        ret[quote + SYMBOL_SEP + base] = value\n    return ret\n\n\ndef bitstamp_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://www.bitstamp.net/api/v2/trading-pairs-info/')\n        ret = {}\n        for data in r.json():\n            normalized = data['name'].replace(\"/\", SYMBOL_SEP)\n            symbol = data['url_symbol']\n            ret[normalized] = symbol\n        return ret\n    except Exception as why:\n        raise_failure_explanation('BITSTAMP', why, {\"\": r})\n\n\ndef kraken_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.kraken.com/0/public/AssetPairs')\n        data = r.json()\n        ret = {}\n        for symbol in data['result']:\n            if 'wsname' not in data['result'][symbol] or '.d' in symbol:\n                # https://blog.kraken.com/post/259/introducing-the-kraken-dark-pool/\n                # .d is for dark pool symbols\n                continue\n\n            base, quote = data['result'][symbol]['wsname'].split(\"/\")\n\n            normalized = f\"{base}{SYMBOL_SEP}{quote}\"\n            exch = data['result'][symbol]['wsname']\n            normalized = normalized.replace('XBT', 'BTC')\n            normalized = normalized.replace('XDG', 'DOG')\n            ret[normalized] = exch\n        return ret\n    except Exception as why:\n        raise_failure_explanation('KRAKEN', why, {\"\": r})\n\n\ndef kraken_rest_symbols() -> Dict[str, str]:\n    return {normalized: exchange.replace(\"/\", \"\") for normalized, exchange in kraken_symbols().items()}\n\n\ndef exx_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.exx.com/data/v1/tickers')\n        exchange = [key.upper() for key in r.json().keys()]\n        symbols = [key.replace(\"_\", SYMBOL_SEP) for key in exchange]\n        return dict(zip(symbols, exchange))\n    except Exception as why:\n        raise_failure_explanation('EXX', why, {\"\": r})\n\n\ndef huobi_common_symbols(url: str):\n    r = None\n    try:\n        r = requests.get(url)\n        ret = {}\n        for e in r.json()['data']:\n            if e['state'] == 'offline':\n                continue\n            normalized = f\"{e['base-currency'].upper()}{SYMBOL_SEP}{e['quote-currency'].upper()}\"\n            symbol = f\"{e['base-currency']}{e['quote-currency']}\"\n            ret[normalized] = symbol\n        return ret\n    except Exception as why:\n        raise_failure_explanation('HUOBI', why, {url: r})\n\n\ndef huobi_symbols() -> Dict[str, str]:\n    return huobi_common_symbols('https://api.huobi.pro/v1/common/symbols')\n\n\ndef huobi_us_symbols() -> Dict[str, str]:\n    return huobi_common_symbols('https://api.huobi.com/v1/common/symbols')\n\n\ndef huobi_dm_symbols() -> Dict[str, str]:\n    \"\"\"\n    Mapping is, for instance: {\"BTC_CW\":\"BTC190816\"}\n    See comments in exchange/huobi_dm.py\n    \"\"\"\n    mapping = {\n        \"this_week\": \"CW\",\n        \"next_week\": \"NW\",\n        \"quarter\": \"CQ\",\n        \"next_quarter\": \"NQ\"\n    }\n    r = None\n    try:\n        r = requests.get('https://www.hbdm.com/api/v1/contract_contract_info')\n        symbols = {}\n        for e in r.json()['data']:\n            symbols[f\"{e['symbol']}_{mapping[e['contract_type']]}\"] = e['contract_code']\n            _exchange_info[HUOBI_DM]['tick_size'][e['contract_code']] = e['price_tick']\n            _exchange_info[HUOBI_DM]['short_code_mappings'][f\"{e['symbol']}_{mapping[e['contract_type']]}\"] = e['contract_code']\n        return symbols\n    except Exception as why:\n        raise_failure_explanation('HUOBI_DM', why, {\"\": r})\n\n\ndef huobi_swap_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.hbdm.com/swap-api/v1/swap_contract_info')\n        symbols = {}\n        for e in r.json()['data']:\n            symbols[e['contract_code']] = e['contract_code']\n            _exchange_info[HUOBI_SWAP]['tick_size'][e['contract_code']] = e['price_tick']\n        return symbols\n    except Exception as why:\n        raise_failure_explanation('HUOBI_SWAP', why, {\"\": r})\n\n\ndef okcoin_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://www.okcoin.com/api/spot/v3/instruments')\n        ret = {}\n        for e in r.json():\n            ret[e['instrument_id']] = e['instrument_id']\n            _exchange_info[OKCOIN]['tick_size'][e['instrument_id']] = e['tick_size']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('OKCOIN', why, {\"\": r})\n\n\ndef okex_symbols(*args) -> Dict[str, str]:\n    urls = ['https://www.okex.com/api/spot/v3/instruments',\n            'https://www.okex.com/api/swap/v3/instruments',\n            'https://www.okex.com/api/futures/v3/instruments']\n    urls = urls + okex_compute_option_urls_from_underlyings()\n\n    symbols: Dict[str, str] = {}\n    for u in urls:\n        time.sleep(0.2)\n        symbols.update(okex_symbols_from_one_url(u))\n\n    for symbol in symbols:\n        instrument_type = 'futures'\n        dash_count = symbol.count(get_symbol_separator())\n        if dash_count == 1:  # BTC-USDT\n            instrument_type = 'spot'\n        if dash_count == 4:  # BTC-USD-201225-35000-P\n            instrument_type = 'option'\n        if symbol[-4:] == \"SWAP\":  # BTC-USDT-SWAP\n            instrument_type = 'swap'\n\n        _exchange_info[OKEX]['instrument_type'][symbol] = instrument_type\n\n    return symbols\n\n\ndef okex_compute_option_urls_from_underlyings() -> List[str]:\n    url = 'https://www.okex.com/api/option/v3/underlying'\n    r = None\n    try:\n        r = requests.get(url)\n        return [f'https://www.okex.com/api/option/v3/instruments/{underlying}' for underlying in r.json()]\n    except Exception as why:\n        raise_failure_explanation('OKEX', why, {url: r})\n\n\ndef okex_symbols_from_one_url(url: str) -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get(url)\n        ret = {}\n        for e in r.json():\n            ret[e['instrument_id']] = e['instrument_id']\n            _exchange_info[OKEX]['tick_size'][e['instrument_id']] = e['tick_size']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('OKEX', why, {url: r})\n\n\ndef bittrex_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.bittrex.com/api/v1.1/public/getmarkets')\n        r = r.json()['result']\n        return {f\"{e['MarketCurrency']}{SYMBOL_SEP}{e['BaseCurrency']}\": e['MarketName'] for e in r if e['IsActive']}\n    except Exception as why:\n        raise_failure_explanation('BITTREX', why, {\"\": r})\n\n\ndef bitcoincom_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.exchange.bitcoin.com/api/2/public/symbol')\n        return {f\"{data['baseCurrency']}{SYMBOL_SEP}{data['quoteCurrency'].replace('USD', 'USDT')}\": data['id'] for data in r.json()}\n    except Exception as why:\n        raise_failure_explanation('BITCOINCOM', why, {\"\": r})\n\n\ndef bitmax_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://bitmax.io/api/pro/v1/products')\n        ret = {}\n        for entry in r.json()['data']:\n            # Only \"Normal\" status symbols are tradeable\n            if entry['status'] == 'Normal':\n                normalized = f\"{entry['baseAsset']}{SYMBOL_SEP}{entry['quoteAsset']}\"\n                ret[normalized] = entry['symbol']\n                _exchange_info[BITMAX]['tick_size'][normalized] = entry['tickSize']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('BITMAX', why, {\"\": r})\n\n\ndef upbit_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.upbit.com/v1/market/all')\n        return {f\"{data['market'].split('-')[1]}{SYMBOL_SEP}{data['market'].split('-')[0]}\": data['market'] for data in r.json()}\n    except Exception as why:\n        raise_failure_explanation('UPBIT', why, {\"\": r})\n\n\ndef blockchain_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get(\"https://api.blockchain.com/mercury-gateway/v1/instruments\")\n        return {data[\"symbol\"].replace(\"-\", SYMBOL_SEP): data[\"symbol\"] for data in r.json()}\n    except Exception as why:\n        raise_failure_explanation('BLOCKCHAIN', why, {\"\": r})\n\n\ndef gateio_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get(\"https://api.gateio.ws/api/v4/spot/currency_pairs\")\n        return {data[\"id\"].replace(\"_\", SYMBOL_SEP): data['id'] for data in r.json()}\n    except Exception as why:\n        raise_failure_explanation('GATEIO', why, {\"\": r})\n\n\ndef bitmex_symbols() -> Dict[str, str]:\n    r = None\n    ret = {}\n    try:\n        r = requests.get(\"https://www.bitmex.com/api/v1/instrument/active\")\n        for entry in r.json():\n            components = []\n            components.append(entry['rootSymbol'])\n            components.append(entry['quoteCurrency'])\n\n            if entry['expiry']:\n                components.append(entry['symbol'][-3:])\n\n            normalized = SYMBOL_SEP.join(components)\n            normalized = normalized.replace(\"XBT\", \"BTC\")\n            ret[normalized] = entry['symbol']\n            _exchange_info[BITMEX]['tick_size'][normalized] = entry['tickSize']\n\n            if entry['expiry']:\n                _exchange_info[BITMEX]['expiry'][normalized] = entry['expiry']\n\n        return ret\n    except Exception as why:\n        raise_failure_explanation('BITMEX', why, {\"\": r})\n\n\ndef deribit_symbols() -> Dict[str, str]:\n    url = r = None\n    ret = {}\n    try:\n        # TODO: get currencies from https://www.deribit.com/api/v2/public/get_currencies\n        currencies = ['BTC', 'ETH']\n        for c in currencies:\n            url = f\"https://www.deribit.com/api/v2/public/get_instruments?currency={c}&expired=false\"\n            r = requests.get(url)\n            for entry in r.json()['result']:\n                split = entry['instrument_name'].split(\"-\")\n                normalized = split[0] + SYMBOL_SEP + entry['quote_currency'] + \"-\" + '-'.join(split[1:])\n                ret[normalized] = entry['instrument_name']\n                _exchange_info[DERIBIT]['tick_size'][normalized] = entry['tick_size']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('DERIBIT', why, {url: r})\n\n\ndef kraken_future_symbols() -> Dict[str, str]:\n    r = None\n    ret = {}\n    try:\n        r = requests.get('https://futures.kraken.com/derivatives/api/v3/instruments')\n        data = r.json()['instruments']\n        for entry in data:\n            if not entry['tradeable']:\n                continue\n            normalized = entry['symbol'].upper().replace(\"_\", \"-\")\n            symbol = normalized[3:6] + SYMBOL_SEP + normalized[6:9]\n            normalized = normalized.replace(normalized[3:9], symbol)\n            normalized = normalized.replace('XBT', 'BTC')\n\n            _exchange_info[KRAKEN_FUTURES]['tick_size'][normalized] = entry['tickSize']\n            _exchange_info[KRAKEN_FUTURES]['contract_size'][normalized] = entry['contractSize']\n            _exchange_info[KRAKEN_FUTURES]['underlying'][normalized] = entry['underlying']\n            _exchange_info[KRAKEN_FUTURES]['product_type'][normalized] = _kraken_futures_product_type[normalized[:2]]\n            ret[normalized] = entry['symbol']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('KRAKEN_FUTURES', why, {\"\": r})\n\n\ndef probit_symbols() -> Dict[str, str]:\n    # doc: https://docs-en.probit.com/reference-link/market\n    r = None\n    try:\n        r = requests.get('https://api.probit.com/api/exchange/v1/market')\n        return {entry['id']: entry['id'] for entry in r.json()['data']}\n    except Exception as why:\n        raise_failure_explanation('PROBIT', why, {\"\": r})\n\n\ndef coingecko_normalize_symbol(symbol: str) -> str:\n    # keep digits, letters and dots, replace others by space\n    symbol = ''.join(c if c.isalnum() or c in ('.', '+') else ' ' for c in symbol)\n    return coingecko_normalize(symbol.upper())\n\n\ndef coingecko_normalize_name(name: str) -> str:\n    # keep digits and letters, replace others by space (except when only composed by upper case letters, digits and dots)\n    if not all(c.isupper() or c.isdigit() or c == '.' for c in name):\n        name = ''.join(c if c.isalnum() else ' ' for c in name)\n    return coingecko_normalize(name)\n\n\ndef coingecko_normalize(sym: str) -> str:\n    sym = sym.strip()\n    # do not concatenate numbers => separate them with a dot\n    sym = list(sym)\n    if len(sym) > 4:\n        for i in range(2, len(sym) - 1):\n            if sym[i] == ' ' and sym[i - 1].isdigit() and sym[i + 1].isdigit():\n                sym[i] = '.'\n    sym = ''.join(sym)\n    # concatenate space-separated words => use CamelCase to distinguish the words\n    if ' ' in sym:\n        if sum(c.islower() for c in sym):  # if there is at least one lower case letter\n            sym = ' '.join(word[0].upper() + word[1:] for word in sym.split())  # Just capitalize initial letter of each word\n        else:  # CoinGecko may provide full upper-case as for \"THE STONE COIN\"\n            sym = string.capwords(sym)  # capwords converts \"THE STONE COIN\" to \"The Stone Coin\"\n        sym = sym.replace(' ', '')  # concatenate words\n    return sym\n\n\ndef is_name_short(coin: dict) -> bool:\n    \"\"\"return True if the coin name is enough short compared to the coin symbol.\"\"\"\n    return len(coin['name']) <= max(5, len(coin['symbol']) + 1)\n\n\ndef has_many_caps(name: str) -> bool:\n    \"\"\"return True if the symbol contains enough upper case letters, False if empty.\"\"\"\n    return str and sum(c.islower() for c in name) < (len(name) / 2)\n\n\ndef coingecko_normalize_all(coin: dict):\n    SYMBOL_TO_NORMALIZED = {'miota': 'IOTA'}\n    normalized = SYMBOL_TO_NORMALIZED.get(coin['symbol'])\n    if normalized:\n        coin['ns'] = coin['nn'] = normalized\n        return normalized\n\n    # ns = normalized symbol, nn = normalized name\n    coin['ns'] = coingecko_normalize_symbol(coin['symbol'])\n\n    ID_SUFFIX = '-bitcoin-token'\n    if coin['id'][-len(ID_SUFFIX):] == ID_SUFFIX:\n        coin['nn'] = 'BTC' + coin['ns']\n        return coin['nn']\n\n    name = coin['name']\n\n    prefixes = ('The ', 'the ')\n    for p in prefixes:\n        if name[:len(p)] == p:\n            coin['reduced-name'] = True\n            name = name[len(p):]\n            break\n\n    suffixes = ('coin', 'coins', 'money', 'finance', 'protocol', 'reward', 'rewards', 'token')\n    for s in suffixes:\n        if len(name) > len(s) and name[-len(s):].lower() == s:\n            # but keep suffix when lower-case concatenated\n            if name[-len(s)].islower() and name[-len(s) - 1] != ' ':\n                continue\n            # also keep suffix to avoid confusing nam: \"Bitcoin Token\" -> \"Bitcoin\"\n            if name[:-len(s)].strip().lower() == 'bitcoin':\n                continue\n            coin['reduced-name'] = True\n            name = name[:-len(s)]\n            break\n\n    coin['nn'] = coingecko_normalize_name(name)\n\n    if len(coin['nn']) < len(coin['ns']):\n        if 'reduced-name' in coin:\n            coin['reduced-name'] = False\n            name = coin['name']\n            coin['nn'] = coingecko_normalize_name(name)\n        elif not has_many_caps(name):\n            return coin['ns']\n\n    if not coin['ns']:  # coin['symbol'] may be an emoji that is striped when normalized\n        return coin['nn']\n\n    if coin.get('reduced-name') and coin['ns'].upper() != coin['nn'].upper():\n        return coin['ns']\n\n    i = coin['nn'].find('.')  # if there is a dot in normalized name => prefer the normalized symbol\n    if i >= 0:\n        if i > 1 and coin['nn'][i - 1].isdigit() and coin['nn'][i + 1].isdigit():\n            pass  # except when the dot separates digits\n        else:\n            return coin['ns']\n\n    if is_name_short(coin) and has_many_caps(name):\n        return coin['nn']\n\n    if 1.5 * len(coin['ns']) > len(coin['nn']) and any(c.islower() for c in coin['ns']):\n        return coin['nn']\n\n    return coin['ns']\n\n\ndef coingecko_symbols() -> Dict[str, str]:\n    r = None\n    intermediate = defaultdict(list)\n    try:\n        r = requests.get('https://api.coingecko.com/api/v3/coins/list')\n        all_coins = r.json()\n        # First pass: generate & compare normalized symbol/name, and then select the most pertinent\n        for coin in all_coins:\n            normalized = coingecko_normalize_all(coin)\n            intermediate[normalized].append(coin)\n            # Above line keeps together the coins having the same normalized symbol.\n            # To reduce collision, the coin['name'] is sometimes used in lieu of the coin['symbol'].\n            # The coin['name'] is not capitalized because lower case letters may be meaningful: cETH, yUSD, DATx, zLOT\n    except Exception as why:\n        raise_failure_explanation('COINGECKO', why, {\"\": r})\n\n    final = coingecko_second_pass(intermediate)\n    return coingecko_third_pass(final)\n\n\ndef coingecko_second_pass(intermediate: Dict[str, List[dict]]) -> Dict[str, List[dict]]:\n    # Second pass: fixes most of the symbol collisions\n    final = defaultdict(list)\n    for normalized, coins in intermediate.items():\n        if len(coins) == 1:\n            final[normalized].append(coins[0])\n            continue\n        set_normalized = False\n        for i in range(len(coins)):\n            if normalized == coins[i]['nn']:\n                coin = coins.pop(i)\n                final[normalized].append(coin)\n                set_normalized = True\n                break\n        rest: List[dict] = []\n        for coin in coins:\n            if '%' in coin['name']:\n                if len(coins) == 1:\n                    n = coin['ns']\n                else:\n                    n = coingecko_normalize_name(coin['id'])\n                final[n].append(coin)\n            else:\n                rest.append(coin)\n        if not rest:\n            continue\n        if not set_normalized:\n            rest.sort(key=lambda coin: len(coin['nn']), reverse=True)  # sort by the length of the normalized name\n            coin = rest.pop(0)\n            final[normalized].append(coin)\n        for coin in rest:\n            if coin['nn'] not in intermediate:\n                n = coin['nn']\n            elif coin.get('reduced-name'):\n                n = coingecko_normalize_name(coin['name'])\n            else:\n                n = coingecko_normalize_name(coin['id'])\n            final[n].append(coin)\n    return final\n\n\ndef coingecko_third_pass(final: Dict[str, List[dict]]) -> Dict[str, str]:\n    # Third pass: fixes some remaining collisions and fills the result\n    symbols = {}\n    for normalized, coins in final.items():\n        if len(coins) == 1:\n            symbols[normalized] = coins[0]['id']\n            continue\n        set_normalized = False\n        for i in range(len(coins)):\n            if normalized == coins[i]['nn']:\n                coin = coins.pop(i)\n                symbols[normalized] = coin['id']\n                set_normalized = True\n                break\n        rest: List[dict] = []\n        for coin in coins:\n            if '%' in coin['name']:\n                if len(coins) == 1:\n                    n = coin['ns']\n                else:\n                    n = coingecko_normalize_name(coin['id'])\n                symbols[n] = coin['id']\n            else:\n                rest.append(coin)\n        if not rest:\n            continue\n        if not set_normalized:\n            rest.sort(key=lambda coin: len(coin['nn']), reverse=True)  # sort by the length of the normalized name\n            coin = rest.pop(0)\n            symbols[normalized] = coin['id']\n        for coin in rest:\n            if coin['nn'] not in final:\n                n = coin['nn']\n            elif coin.get('reduced-name'):\n                n = coingecko_normalize_name(coin['name'])\n            else:\n                n = coingecko_normalize_name(coin['id'])\n            symbols[n] = coin['id']\n    return symbols\n\n\ndef whale_alert_coins(key_id: str) -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get(f'https://api.whale-alert.io/v1/status?api_key={key_id}')\n        # Same symbols, but on different blockchains (for instance USDT), are naturally overwritten.\n        return {s.upper(): s for b in r.json()['blockchains'] for s in b['symbols'] if s}\n    except Exception as why:\n        raise_failure_explanation('WHALES_ALERT', why, {\"\": r})\n\n\n_exchange_function_map = {\n    BITFINEX: bitfinex_symbols,\n    BITFLYER: bitflyer_symbols,\n    COINBASE: coinbase_symbols,\n    GEMINI: gemini_symbols,\n    HITBTC: hitbtc_symbols,\n    POLONIEX: poloniex_symbols,\n    PROBIT: probit_symbols,\n    BITSTAMP: bitstamp_symbols,\n    KRAKEN: kraken_symbols,\n    KRAKEN + 'REST': kraken_rest_symbols,\n    BINANCE: binance_symbols,\n    BINANCE_US: binance_us_symbols,\n    BINANCE_FUTURES: binance_futures_symbols,\n    BINANCE_DELIVERY: binance_delivery_symbols,\n    BLOCKCHAIN: blockchain_symbols,\n    EXX: exx_symbols,\n    HUOBI: huobi_symbols,\n    HUOBI_DM: huobi_dm_symbols,\n    HUOBI_SWAP: huobi_swap_symbols,\n    OKCOIN: okcoin_symbols,\n    OKEX: okex_symbols,\n    BYBIT: bybit_symbols,\n    FTX: ftx_symbols,\n    FTX_US: ftx_us_symbols,\n    BITTREX: bittrex_symbols,\n    BITCOINCOM: bitcoincom_symbols,\n    BITMAX: bitmax_symbols,\n    UPBIT: upbit_symbols,\n    GATEIO: gateio_symbols,\n    BITMEX: bitmex_symbols,\n    DERIBIT: deribit_symbols,\n    KRAKEN_FUTURES: kraken_future_symbols,\n    COINGECKO: coingecko_symbols,\n    WHALE_ALERT: whale_alert_coins\n}\n",
        "source_code_len": 30534,
        "target_code": "associated with this software.\n'''\nfrom typing import Dict, Tuple\n\n\nclass _Symbols:\n    def __init__(self):\n        self.data = {}\n\n    def set(self, exchange: str, normalized: dict, exchange_info: dict):\n        self.data[exchange] = {}\n        self.data[exchange]['normalized'] = normalized\n        self.data[exchange]['info'] = exchange_info\n\n    def get(self, exchange: str) -> Tuple[Dict, Dict]:\n        return self.data[exchange]['normalized'], self.data[exchange]['info']\n\n    def populated(self, exchange: str) -> bool:\n        return exchange in self.data\n\n\nSymbols = _Symbols()\n",
        "target_code_len": 588,
        "diff_format": "@@ -5,845 +5,22 @@\n associated with this software.\n+'''\n+from typing import Dict, Tuple\n \n \n-Symbol generation code for exchanges\n-'''\n+class _Symbols:\n+    def __init__(self):\n+        self.data = {}\n \n-import logging\n-import string\n-import time\n-from collections import defaultdict\n-from typing import Dict, List, Optional, Tuple\n+    def set(self, exchange: str, normalized: dict, exchange_info: dict):\n+        self.data[exchange] = {}\n+        self.data[exchange]['normalized'] = normalized\n+        self.data[exchange]['info'] = exchange_info\n \n-import requests\n-from requests import Response\n+    def get(self, exchange: str) -> Tuple[Dict, Dict]:\n+        return self.data[exchange]['normalized'], self.data[exchange]['info']\n \n-from cryptofeed.defines import *\n+    def populated(self, exchange: str) -> bool:\n+        return exchange in self.data\n \n \n-LOG = logging.getLogger('feedhandler')\n-\n-SYMBOL_SEP = '-'\n-\n-_symbols_retrieval_cache: Dict[str, Dict[str, str]] = {}\n-_exchange_info = defaultdict(lambda: defaultdict(dict))\n-\n-\n-_kraken_futures_product_type = {\n-    'FI': 'Inverse Futures',\n-    'FV': 'Vanilla Futures',\n-    'PI': 'Perpetual Inverse Futures',\n-    'PV': 'Perpetual Vanilla Futures',\n-    'IN': 'Real Time Index',\n-    'RR': 'Reference Rate',\n-}\n-\n-\n-def raise_failure_explanation(feed_id: str, exception: BaseException, responses: Dict[str, Optional[Response]]):\n-    LOG.critical('%s: encountered %r while processing response from exchange API', feed_id, exception)\n-    if len(responses) > 1:\n-        LOG.critical('%s: content of one of the %s responses was unexpected', feed_id, len(responses))\n-    for url, r in responses.items():\n-        if url:\n-            LOG.critical('%s: requested URL: %s', feed_id, url)\n-        if r:\n-            LOG.critical('%s: unexpected response: %s', feed_id, r.text)\n-    raise ValueError(f'Cryptofeed stopped because of an unexpected response from {feed_id}') from exception\n-\n-\n-def set_symbol_separator(separator: str):\n-    global SYMBOL_SEP\n-    SYMBOL_SEP = separator\n-\n-\n-def get_symbol_separator() -> str:\n-    global SYMBOL_SEP\n-    return SYMBOL_SEP\n-\n-\n-def gen_symbols(exchange: str, key_id=None) -> Dict[str, str]:\n-    if exchange not in _symbols_retrieval_cache:\n-        LOG.info(\"%s: Getting list of symbols\", exchange)\n-        symbols = _exchange_function_map[exchange](key_id) if key_id else _exchange_function_map[exchange]()\n-        LOG.info(\"%s: %s symbols\", exchange, len(symbols))\n-\n-        # log all retrieved symbols using debug level\n-        for normalized, exch_sym in sorted(symbols.items()):\n-            LOG.debug('%s: id-from-exch -> normalized: %-35s-> %s', exchange, exch_sym, normalized)\n-\n-        _symbols_retrieval_cache[exchange] = symbols\n-    return _symbols_retrieval_cache[exchange]\n-\n-\n-def _binance_symbols(endpoint: str, exchange: str):\n-    r = None\n-    try:\n-        ret = {}\n-        r = requests.get(endpoint)\n-        for symbol in r.json()['symbols']:\n-            if symbol.get('status', 'TRADING') != \"TRADING\":\n-                continue\n-            if symbol.get('contractStatus', 'TRADING') != \"TRADING\":\n-                continue\n-            split = len(symbol['baseAsset'])\n-            normalized = symbol['symbol'][:split] + SYMBOL_SEP + symbol['symbol'][split:]\n-            ret[normalized] = symbol['symbol']\n-            _exchange_info[exchange]['tick_size'][normalized] = symbol['filters'][0]['tickSize']\n-            if \"contractType\" in symbol:\n-                _exchange_info[exchange]['contract_type'][normalized] = symbol['contractType']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation(exchange, why, {endpoint: r})\n-\n-\n-def binance_symbols() -> Dict[str, str]:\n-    return _binance_symbols('https://api.binance.com/api/v3/exchangeInfo', BINANCE)\n-\n-\n-def binance_us_symbols() -> Dict[str, str]:\n-    return _binance_symbols('https://api.binance.us/api/v3/exchangeInfo', BINANCE_US)\n-\n-\n-def binance_futures_symbols() -> Dict[str, str]:\n-    base = _binance_symbols('https://fapi.binance.com/fapi/v1/exchangeInfo', BINANCE_FUTURES)\n-    add = {}\n-    for symbol, orig in base.items():\n-        if \"_\" in orig:\n-            continue\n-        add[f\"{symbol}-PINDEX\"] = f\"p{orig}\"\n-    base.update(add)\n-    return base\n-\n-\n-def binance_delivery_symbols() -> Dict[str, str]:\n-    return _binance_symbols('https://dapi.binance.com/dapi/v1/exchangeInfo', BINANCE_DELIVERY)\n-\n-\n-def bitfinex_symbols() -> Dict[str, str]:\n-    # doc: https://docs.bitfinex.com/docs/ws-general#supported-pairs\n-    r1 = r2 = None\n-    try:\n-        r1 = requests.get('https://api.bitfinex.com/v2/tickers?symbols=ALL')\n-        r2 = requests.get('https://api-pub.bitfinex.com/v2/conf/pub:map:currency:sym')\n-        tickers: List[List[str]] = r1.json()\n-        norm: List[Tuple[str, str]] = r2.json()[0]\n-        norm: Dict[str, str] = dict(norm)\n-        for k, v in dict(norm).items():\n-            if k[-2:] == 'F0' or '-' in v:  # Do not convert BTCF0 -> BTC or PBTCETH -> PBTC-ETH\n-                del norm[k]\n-        norm['BCHN'] = 'BCH'  # Bitfinex uses BCHN, other exchanges use BCH\n-\n-        ret = {}\n-        for symbol in [t[0] for t in tickers]:\n-            if symbol[0] == 'f':\n-                normalized = norm.get(symbol[1:], symbol[1:])\n-            else:\n-                if len(symbol) == 7:\n-                    base, quote = symbol[1:4], symbol[4:]\n-                else:\n-                    base, quote = symbol[1:].split(':')\n-                    assert ':' in symbol\n-                normalized = norm.get(base, base) + SYMBOL_SEP + norm.get(quote, quote)\n-            ret[normalized.upper()] = symbol\n-        return ret\n-    except ValueError as why:\n-        raise_failure_explanation('BITFINEX', why, {\"tickers?symbols=ALL\": r1, \"pub:map:currency:sym\": r2})\n-\n-\n-def bitflyer_symbols() -> Dict[str, str]:\n-    endpoint = r = None\n-    try:\n-        ret = {}\n-        endpoints = ['https://api.bitflyer.com/v1/getmarkets/eu', 'https://api.bitflyer.com/v1/getmarkets/usa', 'https://api.bitflyer.com/v1/getmarkets']\n-        for endpoint in endpoints:\n-            r = requests.get(endpoint)\n-            for entry in r.json():\n-                normalized = entry['product_code'].replace(\"_\", SYMBOL_SEP)\n-                ret[normalized] = entry['product_code']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('BITFLYER', why, {endpoint: r})\n-\n-\n-def bybit_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.bybit.com/v2/public/symbols')\n-        ret = {}\n-        for symbol in r.json()['result']:\n-            quote = symbol['quote_currency']\n-            if not symbol['name'].endswith(quote):\n-                base, contract = symbol['name'].split(quote)\n-                normalized = f\"{base}{SYMBOL_SEP}{quote}-{contract}\"\n-            else:\n-                normalized = f\"{symbol['base_currency']}{SYMBOL_SEP}{quote}\"\n-            ret[normalized] = symbol['name']\n-            _exchange_info[BYBIT]['tick_size'][normalized] = symbol['price_filter']['tick_size']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('BYBIT', why, {\"\": r})\n-\n-\n-def _ftx_helper(endpoint: str, exchange: str):\n-    r = None\n-    try:\n-        r = requests.get(endpoint)\n-        ret = {}\n-        for data in r.json()['result']:\n-            normalized = data['name'].replace(\"/\", SYMBOL_SEP)\n-            symbol = data['name']\n-            ret[normalized] = symbol\n-            _exchange_info[exchange]['tick_size'][normalized] = data['priceIncrement']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation(exchange, why, {endpoint: r})\n-\n-\n-def ftx_symbols() -> Dict[str, str]:\n-    return _ftx_helper('https://ftx.com/api/markets', FTX)\n-\n-\n-def ftx_us_symbols() -> Dict[str, str]:\n-    return _ftx_helper('https://ftx.us/api/markets', FTX_US)\n-\n-\n-def coinbase_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.pro.coinbase.com/products')\n-        ret = {}\n-        for data in r.json():\n-            normalized = data['id'].replace(\"-\", SYMBOL_SEP)\n-            ret[normalized] = data['id']\n-            _exchange_info[COINBASE]['tick_size'][normalized] = data['quote_increment']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('COINBASE', why, {\"\": r})\n-\n-\n-def gemini_symbols(*args) -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.gemini.com/v1/symbols')\n-        ret = {}\n-        for symbol in r.json():\n-            std = f\"{symbol[:-3]}{SYMBOL_SEP}{symbol[-3:]}\"\n-            std = std.upper()\n-            ret[std] = symbol.upper()\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('GEMINI', why, {\"\": r})\n-\n-\n-def hitbtc_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        ret = {}\n-        r = requests.get('https://api.hitbtc.com/api/2/public/symbol')\n-        for symbol in r.json():\n-            split = len(symbol['baseCurrency'])\n-            normalized = symbol['id'][:split] + SYMBOL_SEP + symbol['id'][split:]\n-            ret[normalized] = symbol['id']\n-            _exchange_info[HITBTC]['tick_size'][normalized] = symbol['tickSize']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('HITBTC', why, {\"\": r})\n-\n-\n-def poloniex_id_symbol_mapping():\n-    r = None\n-    try:\n-        r = requests.get('https://poloniex.com/public?command=returnTicker')\n-        symbols = r.json()\n-        ret = {}\n-        for symbol in symbols:\n-            ret[symbols[symbol]['id']] = symbol\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('POLONIEX', why, {\"\": r})\n-\n-\n-def poloniex_symbols() -> Dict[str, str]:\n-    ret = {}\n-    for _, value in poloniex_id_symbol_mapping().items():\n-        std = value.replace(\"STR\", \"XLM\")\n-        quote, base = std.split(\"_\")\n-        ret[quote + SYMBOL_SEP + base] = value\n-    return ret\n-\n-\n-def bitstamp_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://www.bitstamp.net/api/v2/trading-pairs-info/')\n-        ret = {}\n-        for data in r.json():\n-            normalized = data['name'].replace(\"/\", SYMBOL_SEP)\n-            symbol = data['url_symbol']\n-            ret[normalized] = symbol\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('BITSTAMP', why, {\"\": r})\n-\n-\n-def kraken_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.kraken.com/0/public/AssetPairs')\n-        data = r.json()\n-        ret = {}\n-        for symbol in data['result']:\n-            if 'wsname' not in data['result'][symbol] or '.d' in symbol:\n-                # https://blog.kraken.com/post/259/introducing-the-kraken-dark-pool/\n-                # .d is for dark pool symbols\n-                continue\n-\n-            base, quote = data['result'][symbol]['wsname'].split(\"/\")\n-\n-            normalized = f\"{base}{SYMBOL_SEP}{quote}\"\n-            exch = data['result'][symbol]['wsname']\n-            normalized = normalized.replace('XBT', 'BTC')\n-            normalized = normalized.replace('XDG', 'DOG')\n-            ret[normalized] = exch\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('KRAKEN', why, {\"\": r})\n-\n-\n-def kraken_rest_symbols() -> Dict[str, str]:\n-    return {normalized: exchange.replace(\"/\", \"\") for normalized, exchange in kraken_symbols().items()}\n-\n-\n-def exx_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.exx.com/data/v1/tickers')\n-        exchange = [key.upper() for key in r.json().keys()]\n-        symbols = [key.replace(\"_\", SYMBOL_SEP) for key in exchange]\n-        return dict(zip(symbols, exchange))\n-    except Exception as why:\n-        raise_failure_explanation('EXX', why, {\"\": r})\n-\n-\n-def huobi_common_symbols(url: str):\n-    r = None\n-    try:\n-        r = requests.get(url)\n-        ret = {}\n-        for e in r.json()['data']:\n-            if e['state'] == 'offline':\n-                continue\n-            normalized = f\"{e['base-currency'].upper()}{SYMBOL_SEP}{e['quote-currency'].upper()}\"\n-            symbol = f\"{e['base-currency']}{e['quote-currency']}\"\n-            ret[normalized] = symbol\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('HUOBI', why, {url: r})\n-\n-\n-def huobi_symbols() -> Dict[str, str]:\n-    return huobi_common_symbols('https://api.huobi.pro/v1/common/symbols')\n-\n-\n-def huobi_us_symbols() -> Dict[str, str]:\n-    return huobi_common_symbols('https://api.huobi.com/v1/common/symbols')\n-\n-\n-def huobi_dm_symbols() -> Dict[str, str]:\n-    \"\"\"\n-    Mapping is, for instance: {\"BTC_CW\":\"BTC190816\"}\n-    See comments in exchange/huobi_dm.py\n-    \"\"\"\n-    mapping = {\n-        \"this_week\": \"CW\",\n-        \"next_week\": \"NW\",\n-        \"quarter\": \"CQ\",\n-        \"next_quarter\": \"NQ\"\n-    }\n-    r = None\n-    try:\n-        r = requests.get('https://www.hbdm.com/api/v1/contract_contract_info')\n-        symbols = {}\n-        for e in r.json()['data']:\n-            symbols[f\"{e['symbol']}_{mapping[e['contract_type']]}\"] = e['contract_code']\n-            _exchange_info[HUOBI_DM]['tick_size'][e['contract_code']] = e['price_tick']\n-            _exchange_info[HUOBI_DM]['short_code_mappings'][f\"{e['symbol']}_{mapping[e['contract_type']]}\"] = e['contract_code']\n-        return symbols\n-    except Exception as why:\n-        raise_failure_explanation('HUOBI_DM', why, {\"\": r})\n-\n-\n-def huobi_swap_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.hbdm.com/swap-api/v1/swap_contract_info')\n-        symbols = {}\n-        for e in r.json()['data']:\n-            symbols[e['contract_code']] = e['contract_code']\n-            _exchange_info[HUOBI_SWAP]['tick_size'][e['contract_code']] = e['price_tick']\n-        return symbols\n-    except Exception as why:\n-        raise_failure_explanation('HUOBI_SWAP', why, {\"\": r})\n-\n-\n-def okcoin_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://www.okcoin.com/api/spot/v3/instruments')\n-        ret = {}\n-        for e in r.json():\n-            ret[e['instrument_id']] = e['instrument_id']\n-            _exchange_info[OKCOIN]['tick_size'][e['instrument_id']] = e['tick_size']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('OKCOIN', why, {\"\": r})\n-\n-\n-def okex_symbols(*args) -> Dict[str, str]:\n-    urls = ['https://www.okex.com/api/spot/v3/instruments',\n-            'https://www.okex.com/api/swap/v3/instruments',\n-            'https://www.okex.com/api/futures/v3/instruments']\n-    urls = urls + okex_compute_option_urls_from_underlyings()\n-\n-    symbols: Dict[str, str] = {}\n-    for u in urls:\n-        time.sleep(0.2)\n-        symbols.update(okex_symbols_from_one_url(u))\n-\n-    for symbol in symbols:\n-        instrument_type = 'futures'\n-        dash_count = symbol.count(get_symbol_separator())\n-        if dash_count == 1:  # BTC-USDT\n-            instrument_type = 'spot'\n-        if dash_count == 4:  # BTC-USD-201225-35000-P\n-            instrument_type = 'option'\n-        if symbol[-4:] == \"SWAP\":  # BTC-USDT-SWAP\n-            instrument_type = 'swap'\n-\n-        _exchange_info[OKEX]['instrument_type'][symbol] = instrument_type\n-\n-    return symbols\n-\n-\n-def okex_compute_option_urls_from_underlyings() -> List[str]:\n-    url = 'https://www.okex.com/api/option/v3/underlying'\n-    r = None\n-    try:\n-        r = requests.get(url)\n-        return [f'https://www.okex.com/api/option/v3/instruments/{underlying}' for underlying in r.json()]\n-    except Exception as why:\n-        raise_failure_explanation('OKEX', why, {url: r})\n-\n-\n-def okex_symbols_from_one_url(url: str) -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get(url)\n-        ret = {}\n-        for e in r.json():\n-            ret[e['instrument_id']] = e['instrument_id']\n-            _exchange_info[OKEX]['tick_size'][e['instrument_id']] = e['tick_size']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('OKEX', why, {url: r})\n-\n-\n-def bittrex_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.bittrex.com/api/v1.1/public/getmarkets')\n-        r = r.json()['result']\n-        return {f\"{e['MarketCurrency']}{SYMBOL_SEP}{e['BaseCurrency']}\": e['MarketName'] for e in r if e['IsActive']}\n-    except Exception as why:\n-        raise_failure_explanation('BITTREX', why, {\"\": r})\n-\n-\n-def bitcoincom_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.exchange.bitcoin.com/api/2/public/symbol')\n-        return {f\"{data['baseCurrency']}{SYMBOL_SEP}{data['quoteCurrency'].replace('USD', 'USDT')}\": data['id'] for data in r.json()}\n-    except Exception as why:\n-        raise_failure_explanation('BITCOINCOM', why, {\"\": r})\n-\n-\n-def bitmax_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://bitmax.io/api/pro/v1/products')\n-        ret = {}\n-        for entry in r.json()['data']:\n-            # Only \"Normal\" status symbols are tradeable\n-            if entry['status'] == 'Normal':\n-                normalized = f\"{entry['baseAsset']}{SYMBOL_SEP}{entry['quoteAsset']}\"\n-                ret[normalized] = entry['symbol']\n-                _exchange_info[BITMAX]['tick_size'][normalized] = entry['tickSize']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('BITMAX', why, {\"\": r})\n-\n-\n-def upbit_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.upbit.com/v1/market/all')\n-        return {f\"{data['market'].split('-')[1]}{SYMBOL_SEP}{data['market'].split('-')[0]}\": data['market'] for data in r.json()}\n-    except Exception as why:\n-        raise_failure_explanation('UPBIT', why, {\"\": r})\n-\n-\n-def blockchain_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get(\"https://api.blockchain.com/mercury-gateway/v1/instruments\")\n-        return {data[\"symbol\"].replace(\"-\", SYMBOL_SEP): data[\"symbol\"] for data in r.json()}\n-    except Exception as why:\n-        raise_failure_explanation('BLOCKCHAIN', why, {\"\": r})\n-\n-\n-def gateio_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get(\"https://api.gateio.ws/api/v4/spot/currency_pairs\")\n-        return {data[\"id\"].replace(\"_\", SYMBOL_SEP): data['id'] for data in r.json()}\n-    except Exception as why:\n-        raise_failure_explanation('GATEIO', why, {\"\": r})\n-\n-\n-def bitmex_symbols() -> Dict[str, str]:\n-    r = None\n-    ret = {}\n-    try:\n-        r = requests.get(\"https://www.bitmex.com/api/v1/instrument/active\")\n-        for entry in r.json():\n-            components = []\n-            components.append(entry['rootSymbol'])\n-            components.append(entry['quoteCurrency'])\n-\n-            if entry['expiry']:\n-                components.append(entry['symbol'][-3:])\n-\n-            normalized = SYMBOL_SEP.join(components)\n-            normalized = normalized.replace(\"XBT\", \"BTC\")\n-            ret[normalized] = entry['symbol']\n-            _exchange_info[BITMEX]['tick_size'][normalized] = entry['tickSize']\n-\n-            if entry['expiry']:\n-                _exchange_info[BITMEX]['expiry'][normalized] = entry['expiry']\n-\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('BITMEX', why, {\"\": r})\n-\n-\n-def deribit_symbols() -> Dict[str, str]:\n-    url = r = None\n-    ret = {}\n-    try:\n-        # TODO: get currencies from https://www.deribit.com/api/v2/public/get_currencies\n-        currencies = ['BTC', 'ETH']\n-        for c in currencies:\n-            url = f\"https://www.deribit.com/api/v2/public/get_instruments?currency={c}&expired=false\"\n-            r = requests.get(url)\n-            for entry in r.json()['result']:\n-                split = entry['instrument_name'].split(\"-\")\n-                normalized = split[0] + SYMBOL_SEP + entry['quote_currency'] + \"-\" + '-'.join(split[1:])\n-                ret[normalized] = entry['instrument_name']\n-                _exchange_info[DERIBIT]['tick_size'][normalized] = entry['tick_size']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('DERIBIT', why, {url: r})\n-\n-\n-def kraken_future_symbols() -> Dict[str, str]:\n-    r = None\n-    ret = {}\n-    try:\n-        r = requests.get('https://futures.kraken.com/derivatives/api/v3/instruments')\n-        data = r.json()['instruments']\n-        for entry in data:\n-            if not entry['tradeable']:\n-                continue\n-            normalized = entry['symbol'].upper().replace(\"_\", \"-\")\n-            symbol = normalized[3:6] + SYMBOL_SEP + normalized[6:9]\n-            normalized = normalized.replace(normalized[3:9], symbol)\n-            normalized = normalized.replace('XBT', 'BTC')\n-\n-            _exchange_info[KRAKEN_FUTURES]['tick_size'][normalized] = entry['tickSize']\n-            _exchange_info[KRAKEN_FUTURES]['contract_size'][normalized] = entry['contractSize']\n-            _exchange_info[KRAKEN_FUTURES]['underlying'][normalized] = entry['underlying']\n-            _exchange_info[KRAKEN_FUTURES]['product_type'][normalized] = _kraken_futures_product_type[normalized[:2]]\n-            ret[normalized] = entry['symbol']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('KRAKEN_FUTURES', why, {\"\": r})\n-\n-\n-def probit_symbols() -> Dict[str, str]:\n-    # doc: https://docs-en.probit.com/reference-link/market\n-    r = None\n-    try:\n-        r = requests.get('https://api.probit.com/api/exchange/v1/market')\n-        return {entry['id']: entry['id'] for entry in r.json()['data']}\n-    except Exception as why:\n-        raise_failure_explanation('PROBIT', why, {\"\": r})\n-\n-\n-def coingecko_normalize_symbol(symbol: str) -> str:\n-    # keep digits, letters and dots, replace others by space\n-    symbol = ''.join(c if c.isalnum() or c in ('.', '+') else ' ' for c in symbol)\n-    return coingecko_normalize(symbol.upper())\n-\n-\n-def coingecko_normalize_name(name: str) -> str:\n-    # keep digits and letters, replace others by space (except when only composed by upper case letters, digits and dots)\n-    if not all(c.isupper() or c.isdigit() or c == '.' for c in name):\n-        name = ''.join(c if c.isalnum() else ' ' for c in name)\n-    return coingecko_normalize(name)\n-\n-\n-def coingecko_normalize(sym: str) -> str:\n-    sym = sym.strip()\n-    # do not concatenate numbers => separate them with a dot\n-    sym = list(sym)\n-    if len(sym) > 4:\n-        for i in range(2, len(sym) - 1):\n-            if sym[i] == ' ' and sym[i - 1].isdigit() and sym[i + 1].isdigit():\n-                sym[i] = '.'\n-    sym = ''.join(sym)\n-    # concatenate space-separated words => use CamelCase to distinguish the words\n-    if ' ' in sym:\n-        if sum(c.islower() for c in sym):  # if there is at least one lower case letter\n-            sym = ' '.join(word[0].upper() + word[1:] for word in sym.split())  # Just capitalize initial letter of each word\n-        else:  # CoinGecko may provide full upper-case as for \"THE STONE COIN\"\n-            sym = string.capwords(sym)  # capwords converts \"THE STONE COIN\" to \"The Stone Coin\"\n-        sym = sym.replace(' ', '')  # concatenate words\n-    return sym\n-\n-\n-def is_name_short(coin: dict) -> bool:\n-    \"\"\"return True if the coin name is enough short compared to the coin symbol.\"\"\"\n-    return len(coin['name']) <= max(5, len(coin['symbol']) + 1)\n-\n-\n-def has_many_caps(name: str) -> bool:\n-    \"\"\"return True if the symbol contains enough upper case letters, False if empty.\"\"\"\n-    return str and sum(c.islower() for c in name) < (len(name) / 2)\n-\n-\n-def coingecko_normalize_all(coin: dict):\n-    SYMBOL_TO_NORMALIZED = {'miota': 'IOTA'}\n-    normalized = SYMBOL_TO_NORMALIZED.get(coin['symbol'])\n-    if normalized:\n-        coin['ns'] = coin['nn'] = normalized\n-        return normalized\n-\n-    # ns = normalized symbol, nn = normalized name\n-    coin['ns'] = coingecko_normalize_symbol(coin['symbol'])\n-\n-    ID_SUFFIX = '-bitcoin-token'\n-    if coin['id'][-len(ID_SUFFIX):] == ID_SUFFIX:\n-        coin['nn'] = 'BTC' + coin['ns']\n-        return coin['nn']\n-\n-    name = coin['name']\n-\n-    prefixes = ('The ', 'the ')\n-    for p in prefixes:\n-        if name[:len(p)] == p:\n-            coin['reduced-name'] = True\n-            name = name[len(p):]\n-            break\n-\n-    suffixes = ('coin', 'coins', 'money', 'finance', 'protocol', 'reward', 'rewards', 'token')\n-    for s in suffixes:\n-        if len(name) > len(s) and name[-len(s):].lower() == s:\n-            # but keep suffix when lower-case concatenated\n-            if name[-len(s)].islower() and name[-len(s) - 1] != ' ':\n-                continue\n-            # also keep suffix to avoid confusing nam: \"Bitcoin Token\" -> \"Bitcoin\"\n-            if name[:-len(s)].strip().lower() == 'bitcoin':\n-                continue\n-            coin['reduced-name'] = True\n-            name = name[:-len(s)]\n-            break\n-\n-    coin['nn'] = coingecko_normalize_name(name)\n-\n-    if len(coin['nn']) < len(coin['ns']):\n-        if 'reduced-name' in coin:\n-            coin['reduced-name'] = False\n-            name = coin['name']\n-            coin['nn'] = coingecko_normalize_name(name)\n-        elif not has_many_caps(name):\n-            return coin['ns']\n-\n-    if not coin['ns']:  # coin['symbol'] may be an emoji that is striped when normalized\n-        return coin['nn']\n-\n-    if coin.get('reduced-name') and coin['ns'].upper() != coin['nn'].upper():\n-        return coin['ns']\n-\n-    i = coin['nn'].find('.')  # if there is a dot in normalized name => prefer the normalized symbol\n-    if i >= 0:\n-        if i > 1 and coin['nn'][i - 1].isdigit() and coin['nn'][i + 1].isdigit():\n-            pass  # except when the dot separates digits\n-        else:\n-            return coin['ns']\n-\n-    if is_name_short(coin) and has_many_caps(name):\n-        return coin['nn']\n-\n-    if 1.5 * len(coin['ns']) > len(coin['nn']) and any(c.islower() for c in coin['ns']):\n-        return coin['nn']\n-\n-    return coin['ns']\n-\n-\n-def coingecko_symbols() -> Dict[str, str]:\n-    r = None\n-    intermediate = defaultdict(list)\n-    try:\n-        r = requests.get('https://api.coingecko.com/api/v3/coins/list')\n-        all_coins = r.json()\n-        # First pass: generate & compare normalized symbol/name, and then select the most pertinent\n-        for coin in all_coins:\n-            normalized = coingecko_normalize_all(coin)\n-            intermediate[normalized].append(coin)\n-            # Above line keeps together the coins having the same normalized symbol.\n-            # To reduce collision, the coin['name'] is sometimes used in lieu of the coin['symbol'].\n-            # The coin['name'] is not capitalized because lower case letters may be meaningful: cETH, yUSD, DATx, zLOT\n-    except Exception as why:\n-        raise_failure_explanation('COINGECKO', why, {\"\": r})\n-\n-    final = coingecko_second_pass(intermediate)\n-    return coingecko_third_pass(final)\n-\n-\n-def coingecko_second_pass(intermediate: Dict[str, List[dict]]) -> Dict[str, List[dict]]:\n-    # Second pass: fixes most of the symbol collisions\n-    final = defaultdict(list)\n-    for normalized, coins in intermediate.items():\n-        if len(coins) == 1:\n-            final[normalized].append(coins[0])\n-            continue\n-        set_normalized = False\n-        for i in range(len(coins)):\n-            if normalized == coins[i]['nn']:\n-                coin = coins.pop(i)\n-                final[normalized].append(coin)\n-                set_normalized = True\n-                break\n-        rest: List[dict] = []\n-        for coin in coins:\n-            if '%' in coin['name']:\n-                if len(coins) == 1:\n-                    n = coin['ns']\n-                else:\n-                    n = coingecko_normalize_name(coin['id'])\n-                final[n].append(coin)\n-            else:\n-                rest.append(coin)\n-        if not rest:\n-            continue\n-        if not set_normalized:\n-            rest.sort(key=lambda coin: len(coin['nn']), reverse=True)  # sort by the length of the normalized name\n-            coin = rest.pop(0)\n-            final[normalized].append(coin)\n-        for coin in rest:\n-            if coin['nn'] not in intermediate:\n-                n = coin['nn']\n-            elif coin.get('reduced-name'):\n-                n = coingecko_normalize_name(coin['name'])\n-            else:\n-                n = coingecko_normalize_name(coin['id'])\n-            final[n].append(coin)\n-    return final\n-\n-\n-def coingecko_third_pass(final: Dict[str, List[dict]]) -> Dict[str, str]:\n-    # Third pass: fixes some remaining collisions and fills the result\n-    symbols = {}\n-    for normalized, coins in final.items():\n-        if len(coins) == 1:\n-            symbols[normalized] = coins[0]['id']\n-            continue\n-        set_normalized = False\n-        for i in range(len(coins)):\n-            if normalized == coins[i]['nn']:\n-                coin = coins.pop(i)\n-                symbols[normalized] = coin['id']\n-                set_normalized = True\n-                break\n-        rest: List[dict] = []\n-        for coin in coins:\n-            if '%' in coin['name']:\n-                if len(coins) == 1:\n-                    n = coin['ns']\n-                else:\n-                    n = coingecko_normalize_name(coin['id'])\n-                symbols[n] = coin['id']\n-            else:\n-                rest.append(coin)\n-        if not rest:\n-            continue\n-        if not set_normalized:\n-            rest.sort(key=lambda coin: len(coin['nn']), reverse=True)  # sort by the length of the normalized name\n-            coin = rest.pop(0)\n-            symbols[normalized] = coin['id']\n-        for coin in rest:\n-            if coin['nn'] not in final:\n-                n = coin['nn']\n-            elif coin.get('reduced-name'):\n-                n = coingecko_normalize_name(coin['name'])\n-            else:\n-                n = coingecko_normalize_name(coin['id'])\n-            symbols[n] = coin['id']\n-    return symbols\n-\n-\n-def whale_alert_coins(key_id: str) -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get(f'https://api.whale-alert.io/v1/status?api_key={key_id}')\n-        # Same symbols, but on different blockchains (for instance USDT), are naturally overwritten.\n-        return {s.upper(): s for b in r.json()['blockchains'] for s in b['symbols'] if s}\n-    except Exception as why:\n-        raise_failure_explanation('WHALES_ALERT', why, {\"\": r})\n-\n-\n-_exchange_function_map = {\n-    BITFINEX: bitfinex_symbols,\n-    BITFLYER: bitflyer_symbols,\n-    COINBASE: coinbase_symbols,\n-    GEMINI: gemini_symbols,\n-    HITBTC: hitbtc_symbols,\n-    POLONIEX: poloniex_symbols,\n-    PROBIT: probit_symbols,\n-    BITSTAMP: bitstamp_symbols,\n-    KRAKEN: kraken_symbols,\n-    KRAKEN + 'REST': kraken_rest_symbols,\n-    BINANCE: binance_symbols,\n-    BINANCE_US: binance_us_symbols,\n-    BINANCE_FUTURES: binance_futures_symbols,\n-    BINANCE_DELIVERY: binance_delivery_symbols,\n-    BLOCKCHAIN: blockchain_symbols,\n-    EXX: exx_symbols,\n-    HUOBI: huobi_symbols,\n-    HUOBI_DM: huobi_dm_symbols,\n-    HUOBI_SWAP: huobi_swap_symbols,\n-    OKCOIN: okcoin_symbols,\n-    OKEX: okex_symbols,\n-    BYBIT: bybit_symbols,\n-    FTX: ftx_symbols,\n-    FTX_US: ftx_us_symbols,\n-    BITTREX: bittrex_symbols,\n-    BITCOINCOM: bitcoincom_symbols,\n-    BITMAX: bitmax_symbols,\n-    UPBIT: upbit_symbols,\n-    GATEIO: gateio_symbols,\n-    BITMEX: bitmex_symbols,\n-    DERIBIT: deribit_symbols,\n-    KRAKEN_FUTURES: kraken_future_symbols,\n-    COINGECKO: coingecko_symbols,\n-    WHALE_ALERT: whale_alert_coins\n-}\n+Symbols = _Symbols()\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\n\nimport logging\nimport string\nimport time\nfrom collections import defaultdict\nfrom typing import Dict, List, Optional, Tuple\n\nimport requests\nfrom requests import Response\n\nfrom cryptofeed.defines import *\n\n\nLOG = logging.getLogger('feedhandler')\n\nSYMBOL_SEP = '-'\n\n_symbols_retrieval_cache: Dict[str, Dict[str, str]] = {}\n_exchange_info = defaultdict(lambda: defaultdict(dict))\n\n\n_kraken_futures_product_type = {\n    'FI': 'Inverse Futures',\n    'FV': 'Vanilla Futures',\n    'PI': 'Perpetual Inverse Futures',\n    'PV': 'Perpetual Vanilla Futures',\n    'IN': 'Real Time Index',\n    'RR': 'Reference Rate',\n}\n\n\ndef raise_failure_explanation(feed_id: str, exception: BaseException, responses: Dict[str, Optional[Response]]):\n    <IND>LOG.critical('%s: encountered %r while processing response from exchange API', feed_id, exception)\n    if len(responses) > 1:\n        <IND>LOG.critical('%s: content of one of the %s responses was unexpected', feed_id, len(responses))\n    <DED>for url, r in responses.items():\n        <IND>if url:\n            <IND>LOG.critical('%s: requested URL: %s', feed_id, url)\n        <DED>if r:\n            <IND>LOG.critical('%s: unexpected response: %s', feed_id, r.text)\n    <DED><DED>raise ValueError(f'Cryptofeed stopped because of an unexpected response from {feed_id}') from exception\n\n\n<DED>def set_symbol_separator(separator: str):\n    <IND>global SYMBOL_SEP\n    SYMBOL_SEP = separator\n\n\n<DED>def get_symbol_separator() -> str:\n    <IND>global SYMBOL_SEP\n    return SYMBOL_SEP\n\n\n<DED>def gen_symbols(exchange: str, key_id=None) -> Dict[str, str]:\n    <IND>if exchange not in _symbols_retrieval_cache:\n        <IND>LOG.info(\"%s: Getting list of symbols\", exchange)\n        symbols = _exchange_function_map[exchange](key_id) if key_id else _exchange_function_map[exchange]()\n        LOG.info(\"%s: %s symbols\", exchange, len(symbols))\n\n        # log all retrieved symbols using debug level\n        for normalized, exch_sym in sorted(symbols.items()):\n            <IND>LOG.debug('%s: id-from-exch -> normalized: %-35s-> %s', exchange, exch_sym, normalized)\n\n        <DED>_symbols_retrieval_cache[exchange] = symbols\n    <DED>return _symbols_retrieval_cache[exchange]\n\n\n<DED>def _binance_symbols(endpoint: str, exchange: str):\n    <IND>r = None\n    try:\n        <IND>ret = {}\n        r = requests.get(endpoint)\n        for symbol in r.json()['symbols']:\n            <IND>if symbol.get('status', 'TRADING') != \"TRADING\":\n                <IND>continue\n            <DED>if symbol.get('contractStatus', 'TRADING') != \"TRADING\":\n                <IND>continue\n            <DED>split = len(symbol['baseAsset'])\n            normalized = symbol['symbol'][:split] + SYMBOL_SEP + symbol['symbol'][split:]\n            ret[normalized] = symbol['symbol']\n            _exchange_info[exchange]['tick_size'][normalized] = symbol['filters'][0]['tickSize']\n            if \"contractType\" in symbol:\n                <IND>_exchange_info[exchange]['contract_type'][normalized] = symbol['contractType']\n        <DED><DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation(exchange, why, {endpoint: r})\n\n\n<DED><DED>def binance_symbols() -> Dict[str, str]:\n    <IND>return _binance_symbols('https://api.binance.com/api/v3/exchangeInfo', BINANCE)\n\n\n<DED>def binance_us_symbols() -> Dict[str, str]:\n    <IND>return _binance_symbols('https://api.binance.us/api/v3/exchangeInfo', BINANCE_US)\n\n\n<DED>def binance_futures_symbols() -> Dict[str, str]:\n    <IND>base = _binance_symbols('https://fapi.binance.com/fapi/v1/exchangeInfo', BINANCE_FUTURES)\n    add = {}\n    for symbol, orig in base.items():\n        <IND>if \"_\" in orig:\n            <IND>continue\n        <DED>add[f\"{symbol}-PINDEX\"] = f\"p{orig}\"\n    <DED>base.update(add)\n    return base\n\n\n<DED>def binance_delivery_symbols() -> Dict[str, str]:\n    <IND>return _binance_symbols('https://dapi.binance.com/dapi/v1/exchangeInfo', BINANCE_DELIVERY)\n\n\n<DED>def bitfinex_symbols() -> Dict[str, str]:\n    # doc: https://docs.bitfinex.com/docs/ws-general#supported-pairs\n    <IND>r1 = r2 = None\n    try:\n        <IND>r1 = requests.get('https://api.bitfinex.com/v2/tickers?symbols=ALL')\n        r2 = requests.get('https://api-pub.bitfinex.com/v2/conf/pub:map:currency:sym')\n        tickers: List[List[str]] = r1.json()\n        norm: List[Tuple[str, str]] = r2.json()[0]\n        norm: Dict[str, str] = dict(norm)\n        for k, v in dict(norm).items():\n            <IND>if k[-2:] == 'F0' or '-' in v:  # Do not convert BTCF0 -> BTC or PBTCETH -> PBTC-ETH\n                <IND>del norm[k]\n        <DED><DED>norm['BCHN'] = 'BCH'  # Bitfinex uses BCHN, other exchanges use BCH\n\n        ret = {}\n        for symbol in [t[0] for t in tickers]:\n            <IND>if symbol[0] == 'f':\n                <IND>normalized = norm.get(symbol[1:], symbol[1:])\n            <DED>else:\n                <IND>if len(symbol) == 7:\n                    <IND>base, quote = symbol[1:4], symbol[4:]\n                <DED>else:\n                    <IND>base, quote = symbol[1:].split(':')\n                    assert ':' in symbol\n                <DED>normalized = norm.get(base, base) + SYMBOL_SEP + norm.get(quote, quote)\n            <DED>ret[normalized.upper()] = symbol\n        <DED>return ret\n    <DED>except ValueError as why:\n        <IND>raise_failure_explanation('BITFINEX', why, {\"tickers?symbols=ALL\": r1, \"pub:map:currency:sym\": r2})\n\n\n<DED><DED>def bitflyer_symbols() -> Dict[str, str]:\n    <IND>endpoint = r = None\n    try:\n        <IND>ret = {}\n        endpoints = ['https://api.bitflyer.com/v1/getmarkets/eu', 'https://api.bitflyer.com/v1/getmarkets/usa', 'https://api.bitflyer.com/v1/getmarkets']\n        for endpoint in endpoints:\n            <IND>r = requests.get(endpoint)\n            for entry in r.json():\n                <IND>normalized = entry['product_code'].replace(\"_\", SYMBOL_SEP)\n                ret[normalized] = entry['product_code']\n        <DED><DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BITFLYER', why, {endpoint: r})\n\n\n<DED><DED>def bybit_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.bybit.com/v2/public/symbols')\n        ret = {}\n        for symbol in r.json()['result']:\n            <IND>quote = symbol['quote_currency']\n            if not symbol['name'].endswith(quote):\n                <IND>base, contract = symbol['name'].split(quote)\n                normalized = f\"{base}{SYMBOL_SEP}{quote}-{contract}\"\n            <DED>else:\n                <IND>normalized = f\"{symbol['base_currency']}{SYMBOL_SEP}{quote}\"\n            <DED>ret[normalized] = symbol['name']\n            _exchange_info[BYBIT]['tick_size'][normalized] = symbol['price_filter']['tick_size']\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BYBIT', why, {\"\": r})\n\n\n<DED><DED>def _ftx_helper(endpoint: str, exchange: str):\n    <IND>r = None\n    try:\n        <IND>r = requests.get(endpoint)\n        ret = {}\n        for data in r.json()['result']:\n            <IND>normalized = data['name'].replace(\"/\", SYMBOL_SEP)\n            symbol = data['name']\n            ret[normalized] = symbol\n            _exchange_info[exchange]['tick_size'][normalized] = data['priceIncrement']\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation(exchange, why, {endpoint: r})\n\n\n<DED><DED>def ftx_symbols() -> Dict[str, str]:\n    <IND>return _ftx_helper('https://ftx.com/api/markets', FTX)\n\n\n<DED>def ftx_us_symbols() -> Dict[str, str]:\n    <IND>return _ftx_helper('https://ftx.us/api/markets', FTX_US)\n\n\n<DED>def coinbase_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.pro.coinbase.com/products')\n        ret = {}\n        for data in r.json():\n            <IND>normalized = data['id'].replace(\"-\", SYMBOL_SEP)\n            ret[normalized] = data['id']\n            _exchange_info[COINBASE]['tick_size'][normalized] = data['quote_increment']\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('COINBASE', why, {\"\": r})\n\n\n<DED><DED>def gemini_symbols(*args) -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.gemini.com/v1/symbols')\n        ret = {}\n        for symbol in r.json():\n            <IND>std = f\"{symbol[:-3]}{SYMBOL_SEP}{symbol[-3:]}\"\n            std = std.upper()\n            ret[std] = symbol.upper()\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('GEMINI', why, {\"\": r})\n\n\n<DED><DED>def hitbtc_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>ret = {}\n        r = requests.get('https://api.hitbtc.com/api/2/public/symbol')\n        for symbol in r.json():\n            <IND>split = len(symbol['baseCurrency'])\n            normalized = symbol['id'][:split] + SYMBOL_SEP + symbol['id'][split:]\n            ret[normalized] = symbol['id']\n            _exchange_info[HITBTC]['tick_size'][normalized] = symbol['tickSize']\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('HITBTC', why, {\"\": r})\n\n\n<DED><DED>def poloniex_id_symbol_mapping():\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://poloniex.com/public?command=returnTicker')\n        symbols = r.json()\n        ret = {}\n        for symbol in symbols:\n            <IND>ret[symbols[symbol]['id']] = symbol\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('POLONIEX', why, {\"\": r})\n\n\n<DED><DED>def poloniex_symbols() -> Dict[str, str]:\n    <IND>ret = {}\n    for _, value in poloniex_id_symbol_mapping().items():\n        <IND>std = value.replace(\"STR\", \"XLM\")\n        quote, base = std.split(\"_\")\n        ret[quote + SYMBOL_SEP + base] = value\n    <DED>return ret\n\n\n<DED>def bitstamp_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://www.bitstamp.net/api/v2/trading-pairs-info/')\n        ret = {}\n        for data in r.json():\n            <IND>normalized = data['name'].replace(\"/\", SYMBOL_SEP)\n            symbol = data['url_symbol']\n            ret[normalized] = symbol\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BITSTAMP', why, {\"\": r})\n\n\n<DED><DED>def kraken_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.kraken.com/0/public/AssetPairs')\n        data = r.json()\n        ret = {}\n        for symbol in data['result']:\n            <IND>if 'wsname' not in data['result'][symbol] or '.d' in symbol:\n                # https://blog.kraken.com/post/259/introducing-the-kraken-dark-pool/\n                # .d is for dark pool symbols\n                <IND>continue\n\n            <DED>base, quote = data['result'][symbol]['wsname'].split(\"/\")\n\n            normalized = f\"{base}{SYMBOL_SEP}{quote}\"\n            exch = data['result'][symbol]['wsname']\n            normalized = normalized.replace('XBT', 'BTC')\n            normalized = normalized.replace('XDG', 'DOG')\n            ret[normalized] = exch\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('KRAKEN', why, {\"\": r})\n\n\n<DED><DED>def kraken_rest_symbols() -> Dict[str, str]:\n    <IND>return {normalized: exchange.replace(\"/\", \"\") for normalized, exchange in kraken_symbols().items()}\n\n\n<DED>def exx_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.exx.com/data/v1/tickers')\n        exchange = [key.upper() for key in r.json().keys()]\n        symbols = [key.replace(\"_\", SYMBOL_SEP) for key in exchange]\n        return dict(zip(symbols, exchange))\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('EXX', why, {\"\": r})\n\n\n<DED><DED>def huobi_common_symbols(url: str):\n    <IND>r = None\n    try:\n        <IND>r = requests.get(url)\n        ret = {}\n        for e in r.json()['data']:\n            <IND>if e['state'] == 'offline':\n                <IND>continue\n            <DED>normalized = f\"{e['base-currency'].upper()}{SYMBOL_SEP}{e['quote-currency'].upper()}\"\n            symbol = f\"{e['base-currency']}{e['quote-currency']}\"\n            ret[normalized] = symbol\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('HUOBI', why, {url: r})\n\n\n<DED><DED>def huobi_symbols() -> Dict[str, str]:\n    <IND>return huobi_common_symbols('https://api.huobi.pro/v1/common/symbols')\n\n\n<DED>def huobi_us_symbols() -> Dict[str, str]:\n    <IND>return huobi_common_symbols('https://api.huobi.com/v1/common/symbols')\n\n\n<DED>def huobi_dm_symbols() -> Dict[str, str]:\n    <IND>\"\"\"\n    Mapping is, for instance: {\"BTC_CW\":\"BTC190816\"}\n    See comments in exchange/huobi_dm.py\n    \"\"\"\n    mapping = {\n        \"this_week\": \"CW\",\n        \"next_week\": \"NW\",\n        \"quarter\": \"CQ\",\n        \"next_quarter\": \"NQ\"\n    }\n    r = None\n    try:\n        <IND>r = requests.get('https://www.hbdm.com/api/v1/contract_contract_info')\n        symbols = {}\n        for e in r.json()['data']:\n            <IND>symbols[f\"{e['symbol']}_{mapping[e['contract_type']]}\"] = e['contract_code']\n            _exchange_info[HUOBI_DM]['tick_size'][e['contract_code']] = e['price_tick']\n            _exchange_info[HUOBI_DM]['short_code_mappings'][f\"{e['symbol']}_{mapping[e['contract_type']]}\"] = e['contract_code']\n        <DED>return symbols\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('HUOBI_DM', why, {\"\": r})\n\n\n<DED><DED>def huobi_swap_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.hbdm.com/swap-api/v1/swap_contract_info')\n        symbols = {}\n        for e in r.json()['data']:\n            <IND>symbols[e['contract_code']] = e['contract_code']\n            _exchange_info[HUOBI_SWAP]['tick_size'][e['contract_code']] = e['price_tick']\n        <DED>return symbols\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('HUOBI_SWAP', why, {\"\": r})\n\n\n<DED><DED>def okcoin_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://www.okcoin.com/api/spot/v3/instruments')\n        ret = {}\n        for e in r.json():\n            <IND>ret[e['instrument_id']] = e['instrument_id']\n            _exchange_info[OKCOIN]['tick_size'][e['instrument_id']] = e['tick_size']\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('OKCOIN', why, {\"\": r})\n\n\n<DED><DED>def okex_symbols(*args) -> Dict[str, str]:\n    <IND>urls = ['https://www.okex.com/api/spot/v3/instruments',\n            'https://www.okex.com/api/swap/v3/instruments',\n            'https://www.okex.com/api/futures/v3/instruments']\n    urls = urls + okex_compute_option_urls_from_underlyings()\n\n    symbols: Dict[str, str] = {}\n    for u in urls:\n        <IND>time.sleep(0.2)\n        symbols.update(okex_symbols_from_one_url(u))\n\n    <DED>for symbol in symbols:\n        <IND>instrument_type = 'futures'\n        dash_count = symbol.count(get_symbol_separator())\n        if dash_count == 1:  # BTC-USDT\n            <IND>instrument_type = 'spot'\n        <DED>if dash_count == 4:  # BTC-USD-201225-35000-P\n            <IND>instrument_type = 'option'\n        <DED>if symbol[-4:] == \"SWAP\":  # BTC-USDT-SWAP\n            <IND>instrument_type = 'swap'\n\n        <DED>_exchange_info[OKEX]['instrument_type'][symbol] = instrument_type\n\n    <DED>return symbols\n\n\n<DED>def okex_compute_option_urls_from_underlyings() -> List[str]:\n    <IND>url = 'https://www.okex.com/api/option/v3/underlying'\n    r = None\n    try:\n        <IND>r = requests.get(url)\n        return [f'https://www.okex.com/api/option/v3/instruments/{underlying}' for underlying in r.json()]\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('OKEX', why, {url: r})\n\n\n<DED><DED>def okex_symbols_from_one_url(url: str) -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get(url)\n        ret = {}\n        for e in r.json():\n            <IND>ret[e['instrument_id']] = e['instrument_id']\n            _exchange_info[OKEX]['tick_size'][e['instrument_id']] = e['tick_size']\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('OKEX', why, {url: r})\n\n\n<DED><DED>def bittrex_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.bittrex.com/api/v1.1/public/getmarkets')\n        r = r.json()['result']\n        return {f\"{e['MarketCurrency']}{SYMBOL_SEP}{e['BaseCurrency']}\": e['MarketName'] for e in r if e['IsActive']}\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BITTREX', why, {\"\": r})\n\n\n<DED><DED>def bitcoincom_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.exchange.bitcoin.com/api/2/public/symbol')\n        return {f\"{data['baseCurrency']}{SYMBOL_SEP}{data['quoteCurrency'].replace('USD', 'USDT')}\": data['id'] for data in r.json()}\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BITCOINCOM', why, {\"\": r})\n\n\n<DED><DED>def bitmax_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://bitmax.io/api/pro/v1/products')\n        ret = {}\n        for entry in r.json()['data']:\n            # Only \"Normal\" status symbols are tradeable\n            <IND>if entry['status'] == 'Normal':\n                <IND>normalized = f\"{entry['baseAsset']}{SYMBOL_SEP}{entry['quoteAsset']}\"\n                ret[normalized] = entry['symbol']\n                _exchange_info[BITMAX]['tick_size'][normalized] = entry['tickSize']\n        <DED><DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BITMAX', why, {\"\": r})\n\n\n<DED><DED>def upbit_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.upbit.com/v1/market/all')\n        return {f\"{data['market'].split('-')[1]}{SYMBOL_SEP}{data['market'].split('-')[0]}\": data['market'] for data in r.json()}\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('UPBIT', why, {\"\": r})\n\n\n<DED><DED>def blockchain_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get(\"https://api.blockchain.com/mercury-gateway/v1/instruments\")\n        return {data[\"symbol\"].replace(\"-\", SYMBOL_SEP): data[\"symbol\"] for data in r.json()}\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BLOCKCHAIN', why, {\"\": r})\n\n\n<DED><DED>def gateio_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get(\"https://api.gateio.ws/api/v4/spot/currency_pairs\")\n        return {data[\"id\"].replace(\"_\", SYMBOL_SEP): data['id'] for data in r.json()}\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('GATEIO', why, {\"\": r})\n\n\n<DED><DED>def bitmex_symbols() -> Dict[str, str]:\n    <IND>r = None\n    ret = {}\n    try:\n        <IND>r = requests.get(\"https://www.bitmex.com/api/v1/instrument/active\")\n        for entry in r.json():\n            <IND>components = []\n            components.append(entry['rootSymbol'])\n            components.append(entry['quoteCurrency'])\n\n            if entry['expiry']:\n                <IND>components.append(entry['symbol'][-3:])\n\n            <DED>normalized = SYMBOL_SEP.join(components)\n            normalized = normalized.replace(\"XBT\", \"BTC\")\n            ret[normalized] = entry['symbol']\n            _exchange_info[BITMEX]['tick_size'][normalized] = entry['tickSize']\n\n            if entry['expiry']:\n                <IND>_exchange_info[BITMEX]['expiry'][normalized] = entry['expiry']\n\n        <DED><DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BITMEX', why, {\"\": r})\n\n\n<DED><DED>def deribit_symbols() -> Dict[str, str]:\n    <IND>url = r = None\n    ret = {}\n    try:\n        # TODO: get currencies from https://www.deribit.com/api/v2/public/get_currencies\n        <IND>currencies = ['BTC', 'ETH']\n        for c in currencies:\n            <IND>url = f\"https://www.deribit.com/api/v2/public/get_instruments?currency={c}&expired=false\"\n            r = requests.get(url)\n            for entry in r.json()['result']:\n                <IND>split = entry['instrument_name'].split(\"-\")\n                normalized = split[0] + SYMBOL_SEP + entry['quote_currency'] + \"-\" + '-'.join(split[1:])\n                ret[normalized] = entry['instrument_name']\n                _exchange_info[DERIBIT]['tick_size'][normalized] = entry['tick_size']\n        <DED><DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('DERIBIT', why, {url: r})\n\n\n<DED><DED>def kraken_future_symbols() -> Dict[str, str]:\n    <IND>r = None\n    ret = {}\n    try:\n        <IND>r = requests.get('https://futures.kraken.com/derivatives/api/v3/instruments')\n        data = r.json()['instruments']\n        for entry in data:\n            <IND>if not entry['tradeable']:\n                <IND>continue\n            <DED>normalized = entry['symbol'].upper().replace(\"_\", \"-\")\n            symbol = normalized[3:6] + SYMBOL_SEP + normalized[6:9]\n            normalized = normalized.replace(normalized[3:9], symbol)\n            normalized = normalized.replace('XBT', 'BTC')\n\n            _exchange_info[KRAKEN_FUTURES]['tick_size'][normalized] = entry['tickSize']\n            _exchange_info[KRAKEN_FUTURES]['contract_size'][normalized] = entry['contractSize']\n            _exchange_info[KRAKEN_FUTURES]['underlying'][normalized] = entry['underlying']\n            _exchange_info[KRAKEN_FUTURES]['product_type'][normalized] = _kraken_futures_product_type[normalized[:2]]\n            ret[normalized] = entry['symbol']\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('KRAKEN_FUTURES', why, {\"\": r})\n\n\n<DED><DED>def probit_symbols() -> Dict[str, str]:\n    # doc: https://docs-en.probit.com/reference-link/market\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.probit.com/api/exchange/v1/market')\n        return {entry['id']: entry['id'] for entry in r.json()['data']}\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('PROBIT', why, {\"\": r})\n\n\n<DED><DED>def coingecko_normalize_symbol(symbol: str) -> str:\n    # keep digits, letters and dots, replace others by space\n    <IND>symbol = ''.join(c if c.isalnum() or c in ('.', '+') else ' ' for c in symbol)\n    return coingecko_normalize(symbol.upper())\n\n\n<DED>def coingecko_normalize_name(name: str) -> str:\n    # keep digits and letters, replace others by space (except when only composed by upper case letters, digits and dots)\n    <IND>if not all(c.isupper() or c.isdigit() or c == '.' for c in name):\n        <IND>name = ''.join(c if c.isalnum() else ' ' for c in name)\n    <DED>return coingecko_normalize(name)\n\n\n<DED>def coingecko_normalize(sym: str) -> str:\n    <IND>sym = sym.strip()\n    # do not concatenate numbers => separate them with a dot\n    sym = list(sym)\n    if len(sym) > 4:\n        <IND>for i in range(2, len(sym) - 1):\n            <IND>if sym[i] == ' ' and sym[i - 1].isdigit() and sym[i + 1].isdigit():\n                <IND>sym[i] = '.'\n    <DED><DED><DED>sym = ''.join(sym)\n    # concatenate space-separated words => use CamelCase to distinguish the words\n    if ' ' in sym:\n        <IND>if sum(c.islower() for c in sym):  # if there is at least one lower case letter\n            <IND>sym = ' '.join(word[0].upper() + word[1:] for word in sym.split())  # Just capitalize initial letter of each word\n        <DED>else:  # CoinGecko may provide full upper-case as for \"THE STONE COIN\"\n            <IND>sym = string.capwords(sym)  # capwords converts \"THE STONE COIN\" to \"The Stone Coin\"\n        <DED>sym = sym.replace(' ', '')  # concatenate words\n    <DED>return sym\n\n\n<DED>def is_name_short(coin: dict) -> bool:\n    <IND>\"\"\"return True if the coin name is enough short compared to the coin symbol.\"\"\"\n    return len(coin['name']) <= max(5, len(coin['symbol']) + 1)\n\n\n<DED>def has_many_caps(name: str) -> bool:\n    <IND>\"\"\"return True if the symbol contains enough upper case letters, False if empty.\"\"\"\n    return str and sum(c.islower() for c in name) < (len(name) / 2)\n\n\n<DED>def coingecko_normalize_all(coin: dict):\n    <IND>SYMBOL_TO_NORMALIZED = {'miota': 'IOTA'}\n    normalized = SYMBOL_TO_NORMALIZED.get(coin['symbol'])\n    if normalized:\n        <IND>coin['ns'] = coin['nn'] = normalized\n        return normalized\n\n    # ns = normalized symbol, nn = normalized name\n    <DED>coin['ns'] = coingecko_normalize_symbol(coin['symbol'])\n\n    ID_SUFFIX = '-bitcoin-token'\n    if coin['id'][-len(ID_SUFFIX):] == ID_SUFFIX:\n        <IND>coin['nn'] = 'BTC' + coin['ns']\n        return coin['nn']\n\n    <DED>name = coin['name']\n\n    prefixes = ('The ', 'the ')\n    for p in prefixes:\n        <IND>if name[:len(p)] == p:\n            <IND>coin['reduced-name'] = True\n            name = name[len(p):]\n            break\n\n    <DED><DED>suffixes = ('coin', 'coins', 'money', 'finance', 'protocol', 'reward', 'rewards', 'token')\n    for s in suffixes:\n        <IND>if len(name) > len(s) and name[-len(s):].lower() == s:\n            # but keep suffix when lower-case concatenated\n            <IND>if name[-len(s)].islower() and name[-len(s) - 1] != ' ':\n                <IND>continue\n            # also keep suffix to avoid confusing nam: \"Bitcoin Token\" -> \"Bitcoin\"\n            <DED>if name[:-len(s)].strip().lower() == 'bitcoin':\n                <IND>continue\n            <DED>coin['reduced-name'] = True\n            name = name[:-len(s)]\n            break\n\n    <DED><DED>coin['nn'] = coingecko_normalize_name(name)\n\n    if len(coin['nn']) < len(coin['ns']):\n        <IND>if 'reduced-name' in coin:\n            <IND>coin['reduced-name'] = False\n            name = coin['name']\n            coin['nn'] = coingecko_normalize_name(name)\n        <DED>elif not has_many_caps(name):\n            <IND>return coin['ns']\n\n    <DED><DED>if not coin['ns']:  # coin['symbol'] may be an emoji that is striped when normalized\n        <IND>return coin['nn']\n\n    <DED>if coin.get('reduced-name') and coin['ns'].upper() != coin['nn'].upper():\n        <IND>return coin['ns']\n\n    <DED>i = coin['nn'].find('.')  # if there is a dot in normalized name => prefer the normalized symbol\n    if i >= 0:\n        <IND>if i > 1 and coin['nn'][i - 1].isdigit() and coin['nn'][i + 1].isdigit():\n            <IND>pass  # except when the dot separates digits\n        <DED>else:\n            <IND>return coin['ns']\n\n    <DED><DED>if is_name_short(coin) and has_many_caps(name):\n        <IND>return coin['nn']\n\n    <DED>if 1.5 * len(coin['ns']) > len(coin['nn']) and any(c.islower() for c in coin['ns']):\n        <IND>return coin['nn']\n\n    <DED>return coin['ns']\n\n\n<DED>def coingecko_symbols() -> Dict[str, str]:\n    <IND>r = None\n    intermediate = defaultdict(list)\n    try:\n        <IND>r = requests.get('https://api.coingecko.com/api/v3/coins/list')\n        all_coins = r.json()\n        # First pass: generate & compare normalized symbol/name, and then select the most pertinent\n        for coin in all_coins:\n            <IND>normalized = coingecko_normalize_all(coin)\n            intermediate[normalized].append(coin)\n            # Above line keeps together the coins having the same normalized symbol.\n            # To reduce collision, the coin['name'] is sometimes used in lieu of the coin['symbol'].\n            # The coin['name'] is not capitalized because lower case letters may be meaningful: cETH, yUSD, DATx, zLOT\n    <DED><DED>except Exception as why:\n        <IND>raise_failure_explanation('COINGECKO', why, {\"\": r})\n\n    <DED>final = coingecko_second_pass(intermediate)\n    return coingecko_third_pass(final)\n\n\n<DED>def coingecko_second_pass(intermediate: Dict[str, List[dict]]) -> Dict[str, List[dict]]:\n    # Second pass: fixes most of the symbol collisions\n    <IND>final = defaultdict(list)\n    for normalized, coins in intermediate.items():\n        <IND>if len(coins) == 1:\n            <IND>final[normalized].append(coins[0])\n            continue\n        <DED>set_normalized = False\n        for i in range(len(coins)):\n            <IND>if normalized == coins[i]['nn']:\n                <IND>coin = coins.pop(i)\n                final[normalized].append(coin)\n                set_normalized = True\n                break\n        <DED><DED>rest: List[dict] = []\n        for coin in coins:\n            <IND>if '%' in coin['name']:\n                <IND>if len(coins) == 1:\n                    <IND>n = coin['ns']\n                <DED>else:\n                    <IND>n = coingecko_normalize_name(coin['id'])\n                <DED>final[n].append(coin)\n            <DED>else:\n                <IND>rest.append(coin)\n        <DED><DED>if not rest:\n            <IND>continue\n        <DED>if not set_normalized:\n            <IND>rest.sort(key=lambda coin: len(coin['nn']), reverse=True)  # sort by the length of the normalized name\n            coin = rest.pop(0)\n            final[normalized].append(coin)\n        <DED>for coin in rest:\n            <IND>if coin['nn'] not in intermediate:\n                <IND>n = coin['nn']\n            <DED>elif coin.get('reduced-name'):\n                <IND>n = coingecko_normalize_name(coin['name'])\n            <DED>else:\n                <IND>n = coingecko_normalize_name(coin['id'])\n            <DED>final[n].append(coin)\n    <DED><DED>return final\n\n\n<DED>def coingecko_third_pass(final: Dict[str, List[dict]]) -> Dict[str, str]:\n    # Third pass: fixes some remaining collisions and fills the result\n    <IND>symbols = {}\n    for normalized, coins in final.items():\n        <IND>if len(coins) == 1:\n            <IND>symbols[normalized] = coins[0]['id']\n            continue\n        <DED>set_normalized = False\n        for i in range(len(coins)):\n            <IND>if normalized == coins[i]['nn']:\n                <IND>coin = coins.pop(i)\n                symbols[normalized] = coin['id']\n                set_normalized = True\n                break\n        <DED><DED>rest: List[dict] = []\n        for coin in coins:\n            <IND>if '%' in coin['name']:\n                <IND>if len(coins) == 1:\n                    <IND>n = coin['ns']\n                <DED>else:\n                    <IND>n = coingecko_normalize_name(coin['id'])\n                <DED>symbols[n] = coin['id']\n            <DED>else:\n                <IND>rest.append(coin)\n        <DED><DED>if not rest:\n            <IND>continue\n        <DED>if not set_normalized:\n            <IND>rest.sort(key=lambda coin: len(coin['nn']), reverse=True)  # sort by the length of the normalized name\n            coin = rest.pop(0)\n            symbols[normalized] = coin['id']\n        <DED>for coin in rest:\n            <IND>if coin['nn'] not in final:\n                <IND>n = coin['nn']\n            <DED>elif coin.get('reduced-name'):\n                <IND>n = coingecko_normalize_name(coin['name'])\n            <DED>else:\n                <IND>n = coingecko_normalize_name(coin['id'])\n            <DED>symbols[n] = coin['id']\n    <DED><DED>return symbols\n\n\n<DED>def whale_alert_coins(key_id: str) -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get(f'https://api.whale-alert.io/v1/status?api_key={key_id}')\n        # Same symbols, but on different blockchains (for instance USDT), are naturally overwritten.\n        return {s.upper(): s for b in r.json()['blockchains'] for s in b['symbols'] if s}\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('WHALES_ALERT', why, {\"\": r})\n\n\n<DED><DED>_exchange_function_map = {\n    BITFINEX: bitfinex_symbols,\n    BITFLYER: bitflyer_symbols,\n    COINBASE: coinbase_symbols,\n    GEMINI: gemini_symbols,\n    HITBTC: hitbtc_symbols,\n    POLONIEX: poloniex_symbols,\n    PROBIT: probit_symbols,\n    BITSTAMP: bitstamp_symbols,\n    KRAKEN: kraken_symbols,\n    KRAKEN + 'REST': kraken_rest_symbols,\n    BINANCE: binance_symbols,\n    BINANCE_US: binance_us_symbols,\n    BINANCE_FUTURES: binance_futures_symbols,\n    BINANCE_DELIVERY: binance_delivery_symbols,\n    BLOCKCHAIN: blockchain_symbols,\n    EXX: exx_symbols,\n    HUOBI: huobi_symbols,\n    HUOBI_DM: huobi_dm_symbols,\n    HUOBI_SWAP: huobi_swap_symbols,\n    OKCOIN: okcoin_symbols,\n    OKEX: okex_symbols,\n    BYBIT: bybit_symbols,\n    FTX: ftx_symbols,\n    FTX_US: ftx_us_symbols,\n    BITTREX: bittrex_symbols,\n    BITCOINCOM: bitcoincom_symbols,\n    BITMAX: bitmax_symbols,\n    UPBIT: upbit_symbols,\n    GATEIO: gateio_symbols,\n    BITMEX: bitmex_symbols,\n    DERIBIT: deribit_symbols,\n    KRAKEN_FUTURES: kraken_future_symbols,\n    COINGECKO: coingecko_symbols,\n    WHALE_ALERT: whale_alert_coins\n}\n",
        "target_code_with_indent": "\nfrom typing import Dict, Tuple\n\n\nclass _Symbols:\n    <IND>def __init__(self):\n        <IND>self.data = {}\n\n    <DED>def set(self, exchange: str, normalized: dict, exchange_info: dict):\n        <IND>self.data[exchange] = {}\n        self.data[exchange]['normalized'] = normalized\n        self.data[exchange]['info'] = exchange_info\n\n    <DED>def get(self, exchange: str) -> Tuple[Dict, Dict]:\n        <IND>return self.data[exchange]['normalized'], self.data[exchange]['info']\n\n    <DED>def populated(self, exchange: str) -> bool:\n        <IND>return exchange in self.data\n\n\n<DED><DED>Symbols = _Symbols()\n"
      }
    ]
  },
  {
    "project": "bmoscon/cryptofeed",
    "commit": "3525dc8ce4d7836a9abaaa5662e58e5e27969a77",
    "filename": "cryptofeed/symbols.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/bmoscon-cryptofeed/cryptofeed/symbols.py",
    "file_hunks_size": 1,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "cryptofeed/symbols.py:372:8 Incompatible return type [7]: Expected `Dict[str, str]` but got implicit return value of `None`.",
    "message": " Expected `Dict[str, str]` but got implicit return value of `None`.",
    "rule_id": "Incompatible return type [7]",
    "warning_line_no": 372,
    "warning_line": "        raise_failure_explanation('HUOBI_DM', why, {\"\": r})",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "associated with this software.\n\n\nSymbol generation code for exchanges\n'''\n\nimport logging\nimport string\nimport time\nfrom collections import defaultdict\nfrom typing import Dict, List, Optional, Tuple\n\nimport requests\nfrom requests import Response\n\nfrom cryptofeed.defines import *\n\n\nLOG = logging.getLogger('feedhandler')\n\nSYMBOL_SEP = '-'\n\n_symbols_retrieval_cache: Dict[str, Dict[str, str]] = {}\n_exchange_info = defaultdict(lambda: defaultdict(dict))\n\n\n_kraken_futures_product_type = {\n    'FI': 'Inverse Futures',\n    'FV': 'Vanilla Futures',\n    'PI': 'Perpetual Inverse Futures',\n    'PV': 'Perpetual Vanilla Futures',\n    'IN': 'Real Time Index',\n    'RR': 'Reference Rate',\n}\n\n\ndef raise_failure_explanation(feed_id: str, exception: BaseException, responses: Dict[str, Optional[Response]]):\n    LOG.critical('%s: encountered %r while processing response from exchange API', feed_id, exception)\n    if len(responses) > 1:\n        LOG.critical('%s: content of one of the %s responses was unexpected', feed_id, len(responses))\n    for url, r in responses.items():\n        if url:\n            LOG.critical('%s: requested URL: %s', feed_id, url)\n        if r:\n            LOG.critical('%s: unexpected response: %s', feed_id, r.text)\n    raise ValueError(f'Cryptofeed stopped because of an unexpected response from {feed_id}') from exception\n\n\ndef set_symbol_separator(separator: str):\n    global SYMBOL_SEP\n    SYMBOL_SEP = separator\n\n\ndef get_symbol_separator() -> str:\n    global SYMBOL_SEP\n    return SYMBOL_SEP\n\n\ndef gen_symbols(exchange: str, key_id=None) -> Dict[str, str]:\n    if exchange not in _symbols_retrieval_cache:\n        LOG.info(\"%s: Getting list of symbols\", exchange)\n        symbols = _exchange_function_map[exchange](key_id) if key_id else _exchange_function_map[exchange]()\n        LOG.info(\"%s: %s symbols\", exchange, len(symbols))\n\n        # log all retrieved symbols using debug level\n        for normalized, exch_sym in sorted(symbols.items()):\n            LOG.debug('%s: id-from-exch -> normalized: %-35s-> %s', exchange, exch_sym, normalized)\n\n        _symbols_retrieval_cache[exchange] = symbols\n    return _symbols_retrieval_cache[exchange]\n\n\ndef _binance_symbols(endpoint: str, exchange: str):\n    r = None\n    try:\n        ret = {}\n        r = requests.get(endpoint)\n        for symbol in r.json()['symbols']:\n            if symbol.get('status', 'TRADING') != \"TRADING\":\n                continue\n            if symbol.get('contractStatus', 'TRADING') != \"TRADING\":\n                continue\n            split = len(symbol['baseAsset'])\n            normalized = symbol['symbol'][:split] + SYMBOL_SEP + symbol['symbol'][split:]\n            ret[normalized] = symbol['symbol']\n            _exchange_info[exchange]['tick_size'][normalized] = symbol['filters'][0]['tickSize']\n            if \"contractType\" in symbol:\n                _exchange_info[exchange]['contract_type'][normalized] = symbol['contractType']\n        return ret\n    except Exception as why:\n        raise_failure_explanation(exchange, why, {endpoint: r})\n\n\ndef binance_symbols() -> Dict[str, str]:\n    return _binance_symbols('https://api.binance.com/api/v3/exchangeInfo', BINANCE)\n\n\ndef binance_us_symbols() -> Dict[str, str]:\n    return _binance_symbols('https://api.binance.us/api/v3/exchangeInfo', BINANCE_US)\n\n\ndef binance_futures_symbols() -> Dict[str, str]:\n    base = _binance_symbols('https://fapi.binance.com/fapi/v1/exchangeInfo', BINANCE_FUTURES)\n    add = {}\n    for symbol, orig in base.items():\n        if \"_\" in orig:\n            continue\n        add[f\"{symbol}-PINDEX\"] = f\"p{orig}\"\n    base.update(add)\n    return base\n\n\ndef binance_delivery_symbols() -> Dict[str, str]:\n    return _binance_symbols('https://dapi.binance.com/dapi/v1/exchangeInfo', BINANCE_DELIVERY)\n\n\ndef bitfinex_symbols() -> Dict[str, str]:\n    # doc: https://docs.bitfinex.com/docs/ws-general#supported-pairs\n    r1 = r2 = None\n    try:\n        r1 = requests.get('https://api.bitfinex.com/v2/tickers?symbols=ALL')\n        r2 = requests.get('https://api-pub.bitfinex.com/v2/conf/pub:map:currency:sym')\n        tickers: List[List[str]] = r1.json()\n        norm: List[Tuple[str, str]] = r2.json()[0]\n        norm: Dict[str, str] = dict(norm)\n        for k, v in dict(norm).items():\n            if k[-2:] == 'F0' or '-' in v:  # Do not convert BTCF0 -> BTC or PBTCETH -> PBTC-ETH\n                del norm[k]\n        norm['BCHN'] = 'BCH'  # Bitfinex uses BCHN, other exchanges use BCH\n\n        ret = {}\n        for symbol in [t[0] for t in tickers]:\n            if symbol[0] == 'f':\n                normalized = norm.get(symbol[1:], symbol[1:])\n            else:\n                if len(symbol) == 7:\n                    base, quote = symbol[1:4], symbol[4:]\n                else:\n                    base, quote = symbol[1:].split(':')\n                    assert ':' in symbol\n                normalized = norm.get(base, base) + SYMBOL_SEP + norm.get(quote, quote)\n            ret[normalized.upper()] = symbol\n        return ret\n    except ValueError as why:\n        raise_failure_explanation('BITFINEX', why, {\"tickers?symbols=ALL\": r1, \"pub:map:currency:sym\": r2})\n\n\ndef bitflyer_symbols() -> Dict[str, str]:\n    endpoint = r = None\n    try:\n        ret = {}\n        endpoints = ['https://api.bitflyer.com/v1/getmarkets/eu', 'https://api.bitflyer.com/v1/getmarkets/usa', 'https://api.bitflyer.com/v1/getmarkets']\n        for endpoint in endpoints:\n            r = requests.get(endpoint)\n            for entry in r.json():\n                normalized = entry['product_code'].replace(\"_\", SYMBOL_SEP)\n                ret[normalized] = entry['product_code']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('BITFLYER', why, {endpoint: r})\n\n\ndef bybit_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.bybit.com/v2/public/symbols')\n        ret = {}\n        for symbol in r.json()['result']:\n            quote = symbol['quote_currency']\n            if not symbol['name'].endswith(quote):\n                base, contract = symbol['name'].split(quote)\n                normalized = f\"{base}{SYMBOL_SEP}{quote}-{contract}\"\n            else:\n                normalized = f\"{symbol['base_currency']}{SYMBOL_SEP}{quote}\"\n            ret[normalized] = symbol['name']\n            _exchange_info[BYBIT]['tick_size'][normalized] = symbol['price_filter']['tick_size']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('BYBIT', why, {\"\": r})\n\n\ndef _ftx_helper(endpoint: str, exchange: str):\n    r = None\n    try:\n        r = requests.get(endpoint)\n        ret = {}\n        for data in r.json()['result']:\n            normalized = data['name'].replace(\"/\", SYMBOL_SEP)\n            symbol = data['name']\n            ret[normalized] = symbol\n            _exchange_info[exchange]['tick_size'][normalized] = data['priceIncrement']\n        return ret\n    except Exception as why:\n        raise_failure_explanation(exchange, why, {endpoint: r})\n\n\ndef ftx_symbols() -> Dict[str, str]:\n    return _ftx_helper('https://ftx.com/api/markets', FTX)\n\n\ndef ftx_us_symbols() -> Dict[str, str]:\n    return _ftx_helper('https://ftx.us/api/markets', FTX_US)\n\n\ndef coinbase_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.pro.coinbase.com/products')\n        ret = {}\n        for data in r.json():\n            normalized = data['id'].replace(\"-\", SYMBOL_SEP)\n            ret[normalized] = data['id']\n            _exchange_info[COINBASE]['tick_size'][normalized] = data['quote_increment']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('COINBASE', why, {\"\": r})\n\n\ndef gemini_symbols(*args) -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.gemini.com/v1/symbols')\n        ret = {}\n        for symbol in r.json():\n            std = f\"{symbol[:-3]}{SYMBOL_SEP}{symbol[-3:]}\"\n            std = std.upper()\n            ret[std] = symbol.upper()\n        return ret\n    except Exception as why:\n        raise_failure_explanation('GEMINI', why, {\"\": r})\n\n\ndef hitbtc_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        ret = {}\n        r = requests.get('https://api.hitbtc.com/api/2/public/symbol')\n        for symbol in r.json():\n            split = len(symbol['baseCurrency'])\n            normalized = symbol['id'][:split] + SYMBOL_SEP + symbol['id'][split:]\n            ret[normalized] = symbol['id']\n            _exchange_info[HITBTC]['tick_size'][normalized] = symbol['tickSize']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('HITBTC', why, {\"\": r})\n\n\ndef poloniex_id_symbol_mapping():\n    r = None\n    try:\n        r = requests.get('https://poloniex.com/public?command=returnTicker')\n        symbols = r.json()\n        ret = {}\n        for symbol in symbols:\n            ret[symbols[symbol]['id']] = symbol\n        return ret\n    except Exception as why:\n        raise_failure_explanation('POLONIEX', why, {\"\": r})\n\n\ndef poloniex_symbols() -> Dict[str, str]:\n    ret = {}\n    for _, value in poloniex_id_symbol_mapping().items():\n        std = value.replace(\"STR\", \"XLM\")\n        quote, base = std.split(\"_\")\n        ret[quote + SYMBOL_SEP + base] = value\n    return ret\n\n\ndef bitstamp_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://www.bitstamp.net/api/v2/trading-pairs-info/')\n        ret = {}\n        for data in r.json():\n            normalized = data['name'].replace(\"/\", SYMBOL_SEP)\n            symbol = data['url_symbol']\n            ret[normalized] = symbol\n        return ret\n    except Exception as why:\n        raise_failure_explanation('BITSTAMP', why, {\"\": r})\n\n\ndef kraken_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.kraken.com/0/public/AssetPairs')\n        data = r.json()\n        ret = {}\n        for symbol in data['result']:\n            if 'wsname' not in data['result'][symbol] or '.d' in symbol:\n                # https://blog.kraken.com/post/259/introducing-the-kraken-dark-pool/\n                # .d is for dark pool symbols\n                continue\n\n            base, quote = data['result'][symbol]['wsname'].split(\"/\")\n\n            normalized = f\"{base}{SYMBOL_SEP}{quote}\"\n            exch = data['result'][symbol]['wsname']\n            normalized = normalized.replace('XBT', 'BTC')\n            normalized = normalized.replace('XDG', 'DOG')\n            ret[normalized] = exch\n        return ret\n    except Exception as why:\n        raise_failure_explanation('KRAKEN', why, {\"\": r})\n\n\ndef kraken_rest_symbols() -> Dict[str, str]:\n    return {normalized: exchange.replace(\"/\", \"\") for normalized, exchange in kraken_symbols().items()}\n\n\ndef exx_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.exx.com/data/v1/tickers')\n        exchange = [key.upper() for key in r.json().keys()]\n        symbols = [key.replace(\"_\", SYMBOL_SEP) for key in exchange]\n        return dict(zip(symbols, exchange))\n    except Exception as why:\n        raise_failure_explanation('EXX', why, {\"\": r})\n\n\ndef huobi_common_symbols(url: str):\n    r = None\n    try:\n        r = requests.get(url)\n        ret = {}\n        for e in r.json()['data']:\n            if e['state'] == 'offline':\n                continue\n            normalized = f\"{e['base-currency'].upper()}{SYMBOL_SEP}{e['quote-currency'].upper()}\"\n            symbol = f\"{e['base-currency']}{e['quote-currency']}\"\n            ret[normalized] = symbol\n        return ret\n    except Exception as why:\n        raise_failure_explanation('HUOBI', why, {url: r})\n\n\ndef huobi_symbols() -> Dict[str, str]:\n    return huobi_common_symbols('https://api.huobi.pro/v1/common/symbols')\n\n\ndef huobi_us_symbols() -> Dict[str, str]:\n    return huobi_common_symbols('https://api.huobi.com/v1/common/symbols')\n\n\ndef huobi_dm_symbols() -> Dict[str, str]:\n    \"\"\"\n    Mapping is, for instance: {\"BTC_CW\":\"BTC190816\"}\n    See comments in exchange/huobi_dm.py\n    \"\"\"\n    mapping = {\n        \"this_week\": \"CW\",\n        \"next_week\": \"NW\",\n        \"quarter\": \"CQ\",\n        \"next_quarter\": \"NQ\"\n    }\n    r = None\n    try:\n        r = requests.get('https://www.hbdm.com/api/v1/contract_contract_info')\n        symbols = {}\n        for e in r.json()['data']:\n            symbols[f\"{e['symbol']}_{mapping[e['contract_type']]}\"] = e['contract_code']\n            _exchange_info[HUOBI_DM]['tick_size'][e['contract_code']] = e['price_tick']\n            _exchange_info[HUOBI_DM]['short_code_mappings'][f\"{e['symbol']}_{mapping[e['contract_type']]}\"] = e['contract_code']\n        return symbols\n    except Exception as why:\n        raise_failure_explanation('HUOBI_DM', why, {\"\": r})\n\n\ndef huobi_swap_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.hbdm.com/swap-api/v1/swap_contract_info')\n        symbols = {}\n        for e in r.json()['data']:\n            symbols[e['contract_code']] = e['contract_code']\n            _exchange_info[HUOBI_SWAP]['tick_size'][e['contract_code']] = e['price_tick']\n        return symbols\n    except Exception as why:\n        raise_failure_explanation('HUOBI_SWAP', why, {\"\": r})\n\n\ndef okcoin_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://www.okcoin.com/api/spot/v3/instruments')\n        ret = {}\n        for e in r.json():\n            ret[e['instrument_id']] = e['instrument_id']\n            _exchange_info[OKCOIN]['tick_size'][e['instrument_id']] = e['tick_size']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('OKCOIN', why, {\"\": r})\n\n\ndef okex_symbols(*args) -> Dict[str, str]:\n    urls = ['https://www.okex.com/api/spot/v3/instruments',\n            'https://www.okex.com/api/swap/v3/instruments',\n            'https://www.okex.com/api/futures/v3/instruments']\n    urls = urls + okex_compute_option_urls_from_underlyings()\n\n    symbols: Dict[str, str] = {}\n    for u in urls:\n        time.sleep(0.2)\n        symbols.update(okex_symbols_from_one_url(u))\n\n    for symbol in symbols:\n        instrument_type = 'futures'\n        dash_count = symbol.count(get_symbol_separator())\n        if dash_count == 1:  # BTC-USDT\n            instrument_type = 'spot'\n        if dash_count == 4:  # BTC-USD-201225-35000-P\n            instrument_type = 'option'\n        if symbol[-4:] == \"SWAP\":  # BTC-USDT-SWAP\n            instrument_type = 'swap'\n\n        _exchange_info[OKEX]['instrument_type'][symbol] = instrument_type\n\n    return symbols\n\n\ndef okex_compute_option_urls_from_underlyings() -> List[str]:\n    url = 'https://www.okex.com/api/option/v3/underlying'\n    r = None\n    try:\n        r = requests.get(url)\n        return [f'https://www.okex.com/api/option/v3/instruments/{underlying}' for underlying in r.json()]\n    except Exception as why:\n        raise_failure_explanation('OKEX', why, {url: r})\n\n\ndef okex_symbols_from_one_url(url: str) -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get(url)\n        ret = {}\n        for e in r.json():\n            ret[e['instrument_id']] = e['instrument_id']\n            _exchange_info[OKEX]['tick_size'][e['instrument_id']] = e['tick_size']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('OKEX', why, {url: r})\n\n\ndef bittrex_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.bittrex.com/api/v1.1/public/getmarkets')\n        r = r.json()['result']\n        return {f\"{e['MarketCurrency']}{SYMBOL_SEP}{e['BaseCurrency']}\": e['MarketName'] for e in r if e['IsActive']}\n    except Exception as why:\n        raise_failure_explanation('BITTREX', why, {\"\": r})\n\n\ndef bitcoincom_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.exchange.bitcoin.com/api/2/public/symbol')\n        return {f\"{data['baseCurrency']}{SYMBOL_SEP}{data['quoteCurrency'].replace('USD', 'USDT')}\": data['id'] for data in r.json()}\n    except Exception as why:\n        raise_failure_explanation('BITCOINCOM', why, {\"\": r})\n\n\ndef bitmax_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://bitmax.io/api/pro/v1/products')\n        ret = {}\n        for entry in r.json()['data']:\n            # Only \"Normal\" status symbols are tradeable\n            if entry['status'] == 'Normal':\n                normalized = f\"{entry['baseAsset']}{SYMBOL_SEP}{entry['quoteAsset']}\"\n                ret[normalized] = entry['symbol']\n                _exchange_info[BITMAX]['tick_size'][normalized] = entry['tickSize']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('BITMAX', why, {\"\": r})\n\n\ndef upbit_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.upbit.com/v1/market/all')\n        return {f\"{data['market'].split('-')[1]}{SYMBOL_SEP}{data['market'].split('-')[0]}\": data['market'] for data in r.json()}\n    except Exception as why:\n        raise_failure_explanation('UPBIT', why, {\"\": r})\n\n\ndef blockchain_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get(\"https://api.blockchain.com/mercury-gateway/v1/instruments\")\n        return {data[\"symbol\"].replace(\"-\", SYMBOL_SEP): data[\"symbol\"] for data in r.json()}\n    except Exception as why:\n        raise_failure_explanation('BLOCKCHAIN', why, {\"\": r})\n\n\ndef gateio_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get(\"https://api.gateio.ws/api/v4/spot/currency_pairs\")\n        return {data[\"id\"].replace(\"_\", SYMBOL_SEP): data['id'] for data in r.json()}\n    except Exception as why:\n        raise_failure_explanation('GATEIO', why, {\"\": r})\n\n\ndef bitmex_symbols() -> Dict[str, str]:\n    r = None\n    ret = {}\n    try:\n        r = requests.get(\"https://www.bitmex.com/api/v1/instrument/active\")\n        for entry in r.json():\n            components = []\n            components.append(entry['rootSymbol'])\n            components.append(entry['quoteCurrency'])\n\n            if entry['expiry']:\n                components.append(entry['symbol'][-3:])\n\n            normalized = SYMBOL_SEP.join(components)\n            normalized = normalized.replace(\"XBT\", \"BTC\")\n            ret[normalized] = entry['symbol']\n            _exchange_info[BITMEX]['tick_size'][normalized] = entry['tickSize']\n\n            if entry['expiry']:\n                _exchange_info[BITMEX]['expiry'][normalized] = entry['expiry']\n\n        return ret\n    except Exception as why:\n        raise_failure_explanation('BITMEX', why, {\"\": r})\n\n\ndef deribit_symbols() -> Dict[str, str]:\n    url = r = None\n    ret = {}\n    try:\n        # TODO: get currencies from https://www.deribit.com/api/v2/public/get_currencies\n        currencies = ['BTC', 'ETH']\n        for c in currencies:\n            url = f\"https://www.deribit.com/api/v2/public/get_instruments?currency={c}&expired=false\"\n            r = requests.get(url)\n            for entry in r.json()['result']:\n                split = entry['instrument_name'].split(\"-\")\n                normalized = split[0] + SYMBOL_SEP + entry['quote_currency'] + \"-\" + '-'.join(split[1:])\n                ret[normalized] = entry['instrument_name']\n                _exchange_info[DERIBIT]['tick_size'][normalized] = entry['tick_size']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('DERIBIT', why, {url: r})\n\n\ndef kraken_future_symbols() -> Dict[str, str]:\n    r = None\n    ret = {}\n    try:\n        r = requests.get('https://futures.kraken.com/derivatives/api/v3/instruments')\n        data = r.json()['instruments']\n        for entry in data:\n            if not entry['tradeable']:\n                continue\n            normalized = entry['symbol'].upper().replace(\"_\", \"-\")\n            symbol = normalized[3:6] + SYMBOL_SEP + normalized[6:9]\n            normalized = normalized.replace(normalized[3:9], symbol)\n            normalized = normalized.replace('XBT', 'BTC')\n\n            _exchange_info[KRAKEN_FUTURES]['tick_size'][normalized] = entry['tickSize']\n            _exchange_info[KRAKEN_FUTURES]['contract_size'][normalized] = entry['contractSize']\n            _exchange_info[KRAKEN_FUTURES]['underlying'][normalized] = entry['underlying']\n            _exchange_info[KRAKEN_FUTURES]['product_type'][normalized] = _kraken_futures_product_type[normalized[:2]]\n            ret[normalized] = entry['symbol']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('KRAKEN_FUTURES', why, {\"\": r})\n\n\ndef probit_symbols() -> Dict[str, str]:\n    # doc: https://docs-en.probit.com/reference-link/market\n    r = None\n    try:\n        r = requests.get('https://api.probit.com/api/exchange/v1/market')\n        return {entry['id']: entry['id'] for entry in r.json()['data']}\n    except Exception as why:\n        raise_failure_explanation('PROBIT', why, {\"\": r})\n\n\ndef coingecko_normalize_symbol(symbol: str) -> str:\n    # keep digits, letters and dots, replace others by space\n    symbol = ''.join(c if c.isalnum() or c in ('.', '+') else ' ' for c in symbol)\n    return coingecko_normalize(symbol.upper())\n\n\ndef coingecko_normalize_name(name: str) -> str:\n    # keep digits and letters, replace others by space (except when only composed by upper case letters, digits and dots)\n    if not all(c.isupper() or c.isdigit() or c == '.' for c in name):\n        name = ''.join(c if c.isalnum() else ' ' for c in name)\n    return coingecko_normalize(name)\n\n\ndef coingecko_normalize(sym: str) -> str:\n    sym = sym.strip()\n    # do not concatenate numbers => separate them with a dot\n    sym = list(sym)\n    if len(sym) > 4:\n        for i in range(2, len(sym) - 1):\n            if sym[i] == ' ' and sym[i - 1].isdigit() and sym[i + 1].isdigit():\n                sym[i] = '.'\n    sym = ''.join(sym)\n    # concatenate space-separated words => use CamelCase to distinguish the words\n    if ' ' in sym:\n        if sum(c.islower() for c in sym):  # if there is at least one lower case letter\n            sym = ' '.join(word[0].upper() + word[1:] for word in sym.split())  # Just capitalize initial letter of each word\n        else:  # CoinGecko may provide full upper-case as for \"THE STONE COIN\"\n            sym = string.capwords(sym)  # capwords converts \"THE STONE COIN\" to \"The Stone Coin\"\n        sym = sym.replace(' ', '')  # concatenate words\n    return sym\n\n\ndef is_name_short(coin: dict) -> bool:\n    \"\"\"return True if the coin name is enough short compared to the coin symbol.\"\"\"\n    return len(coin['name']) <= max(5, len(coin['symbol']) + 1)\n\n\ndef has_many_caps(name: str) -> bool:\n    \"\"\"return True if the symbol contains enough upper case letters, False if empty.\"\"\"\n    return str and sum(c.islower() for c in name) < (len(name) / 2)\n\n\ndef coingecko_normalize_all(coin: dict):\n    SYMBOL_TO_NORMALIZED = {'miota': 'IOTA'}\n    normalized = SYMBOL_TO_NORMALIZED.get(coin['symbol'])\n    if normalized:\n        coin['ns'] = coin['nn'] = normalized\n        return normalized\n\n    # ns = normalized symbol, nn = normalized name\n    coin['ns'] = coingecko_normalize_symbol(coin['symbol'])\n\n    ID_SUFFIX = '-bitcoin-token'\n    if coin['id'][-len(ID_SUFFIX):] == ID_SUFFIX:\n        coin['nn'] = 'BTC' + coin['ns']\n        return coin['nn']\n\n    name = coin['name']\n\n    prefixes = ('The ', 'the ')\n    for p in prefixes:\n        if name[:len(p)] == p:\n            coin['reduced-name'] = True\n            name = name[len(p):]\n            break\n\n    suffixes = ('coin', 'coins', 'money', 'finance', 'protocol', 'reward', 'rewards', 'token')\n    for s in suffixes:\n        if len(name) > len(s) and name[-len(s):].lower() == s:\n            # but keep suffix when lower-case concatenated\n            if name[-len(s)].islower() and name[-len(s) - 1] != ' ':\n                continue\n            # also keep suffix to avoid confusing nam: \"Bitcoin Token\" -> \"Bitcoin\"\n            if name[:-len(s)].strip().lower() == 'bitcoin':\n                continue\n            coin['reduced-name'] = True\n            name = name[:-len(s)]\n            break\n\n    coin['nn'] = coingecko_normalize_name(name)\n\n    if len(coin['nn']) < len(coin['ns']):\n        if 'reduced-name' in coin:\n            coin['reduced-name'] = False\n            name = coin['name']\n            coin['nn'] = coingecko_normalize_name(name)\n        elif not has_many_caps(name):\n            return coin['ns']\n\n    if not coin['ns']:  # coin['symbol'] may be an emoji that is striped when normalized\n        return coin['nn']\n\n    if coin.get('reduced-name') and coin['ns'].upper() != coin['nn'].upper():\n        return coin['ns']\n\n    i = coin['nn'].find('.')  # if there is a dot in normalized name => prefer the normalized symbol\n    if i >= 0:\n        if i > 1 and coin['nn'][i - 1].isdigit() and coin['nn'][i + 1].isdigit():\n            pass  # except when the dot separates digits\n        else:\n            return coin['ns']\n\n    if is_name_short(coin) and has_many_caps(name):\n        return coin['nn']\n\n    if 1.5 * len(coin['ns']) > len(coin['nn']) and any(c.islower() for c in coin['ns']):\n        return coin['nn']\n\n    return coin['ns']\n\n\ndef coingecko_symbols() -> Dict[str, str]:\n    r = None\n    intermediate = defaultdict(list)\n    try:\n        r = requests.get('https://api.coingecko.com/api/v3/coins/list')\n        all_coins = r.json()\n        # First pass: generate & compare normalized symbol/name, and then select the most pertinent\n        for coin in all_coins:\n            normalized = coingecko_normalize_all(coin)\n            intermediate[normalized].append(coin)\n            # Above line keeps together the coins having the same normalized symbol.\n            # To reduce collision, the coin['name'] is sometimes used in lieu of the coin['symbol'].\n            # The coin['name'] is not capitalized because lower case letters may be meaningful: cETH, yUSD, DATx, zLOT\n    except Exception as why:\n        raise_failure_explanation('COINGECKO', why, {\"\": r})\n\n    final = coingecko_second_pass(intermediate)\n    return coingecko_third_pass(final)\n\n\ndef coingecko_second_pass(intermediate: Dict[str, List[dict]]) -> Dict[str, List[dict]]:\n    # Second pass: fixes most of the symbol collisions\n    final = defaultdict(list)\n    for normalized, coins in intermediate.items():\n        if len(coins) == 1:\n            final[normalized].append(coins[0])\n            continue\n        set_normalized = False\n        for i in range(len(coins)):\n            if normalized == coins[i]['nn']:\n                coin = coins.pop(i)\n                final[normalized].append(coin)\n                set_normalized = True\n                break\n        rest: List[dict] = []\n        for coin in coins:\n            if '%' in coin['name']:\n                if len(coins) == 1:\n                    n = coin['ns']\n                else:\n                    n = coingecko_normalize_name(coin['id'])\n                final[n].append(coin)\n            else:\n                rest.append(coin)\n        if not rest:\n            continue\n        if not set_normalized:\n            rest.sort(key=lambda coin: len(coin['nn']), reverse=True)  # sort by the length of the normalized name\n            coin = rest.pop(0)\n            final[normalized].append(coin)\n        for coin in rest:\n            if coin['nn'] not in intermediate:\n                n = coin['nn']\n            elif coin.get('reduced-name'):\n                n = coingecko_normalize_name(coin['name'])\n            else:\n                n = coingecko_normalize_name(coin['id'])\n            final[n].append(coin)\n    return final\n\n\ndef coingecko_third_pass(final: Dict[str, List[dict]]) -> Dict[str, str]:\n    # Third pass: fixes some remaining collisions and fills the result\n    symbols = {}\n    for normalized, coins in final.items():\n        if len(coins) == 1:\n            symbols[normalized] = coins[0]['id']\n            continue\n        set_normalized = False\n        for i in range(len(coins)):\n            if normalized == coins[i]['nn']:\n                coin = coins.pop(i)\n                symbols[normalized] = coin['id']\n                set_normalized = True\n                break\n        rest: List[dict] = []\n        for coin in coins:\n            if '%' in coin['name']:\n                if len(coins) == 1:\n                    n = coin['ns']\n                else:\n                    n = coingecko_normalize_name(coin['id'])\n                symbols[n] = coin['id']\n            else:\n                rest.append(coin)\n        if not rest:\n            continue\n        if not set_normalized:\n            rest.sort(key=lambda coin: len(coin['nn']), reverse=True)  # sort by the length of the normalized name\n            coin = rest.pop(0)\n            symbols[normalized] = coin['id']\n        for coin in rest:\n            if coin['nn'] not in final:\n                n = coin['nn']\n            elif coin.get('reduced-name'):\n                n = coingecko_normalize_name(coin['name'])\n            else:\n                n = coingecko_normalize_name(coin['id'])\n            symbols[n] = coin['id']\n    return symbols\n\n\ndef whale_alert_coins(key_id: str) -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get(f'https://api.whale-alert.io/v1/status?api_key={key_id}')\n        # Same symbols, but on different blockchains (for instance USDT), are naturally overwritten.\n        return {s.upper(): s for b in r.json()['blockchains'] for s in b['symbols'] if s}\n    except Exception as why:\n        raise_failure_explanation('WHALES_ALERT', why, {\"\": r})\n\n\n_exchange_function_map = {\n    BITFINEX: bitfinex_symbols,\n    BITFLYER: bitflyer_symbols,\n    COINBASE: coinbase_symbols,\n    GEMINI: gemini_symbols,\n    HITBTC: hitbtc_symbols,\n    POLONIEX: poloniex_symbols,\n    PROBIT: probit_symbols,\n    BITSTAMP: bitstamp_symbols,\n    KRAKEN: kraken_symbols,\n    KRAKEN + 'REST': kraken_rest_symbols,\n    BINANCE: binance_symbols,\n    BINANCE_US: binance_us_symbols,\n    BINANCE_FUTURES: binance_futures_symbols,\n    BINANCE_DELIVERY: binance_delivery_symbols,\n    BLOCKCHAIN: blockchain_symbols,\n    EXX: exx_symbols,\n    HUOBI: huobi_symbols,\n    HUOBI_DM: huobi_dm_symbols,\n    HUOBI_SWAP: huobi_swap_symbols,\n    OKCOIN: okcoin_symbols,\n    OKEX: okex_symbols,\n    BYBIT: bybit_symbols,\n    FTX: ftx_symbols,\n    FTX_US: ftx_us_symbols,\n    BITTREX: bittrex_symbols,\n    BITCOINCOM: bitcoincom_symbols,\n    BITMAX: bitmax_symbols,\n    UPBIT: upbit_symbols,\n    GATEIO: gateio_symbols,\n    BITMEX: bitmex_symbols,\n    DERIBIT: deribit_symbols,\n    KRAKEN_FUTURES: kraken_future_symbols,\n    COINGECKO: coingecko_symbols,\n    WHALE_ALERT: whale_alert_coins\n}\n",
        "source_code_len": 30534,
        "target_code": "associated with this software.\n'''\nfrom typing import Dict, Tuple\n\n\nclass _Symbols:\n    def __init__(self):\n        self.data = {}\n\n    def set(self, exchange: str, normalized: dict, exchange_info: dict):\n        self.data[exchange] = {}\n        self.data[exchange]['normalized'] = normalized\n        self.data[exchange]['info'] = exchange_info\n\n    def get(self, exchange: str) -> Tuple[Dict, Dict]:\n        return self.data[exchange]['normalized'], self.data[exchange]['info']\n\n    def populated(self, exchange: str) -> bool:\n        return exchange in self.data\n\n\nSymbols = _Symbols()\n",
        "target_code_len": 588,
        "diff_format": "@@ -5,845 +5,22 @@\n associated with this software.\n+'''\n+from typing import Dict, Tuple\n \n \n-Symbol generation code for exchanges\n-'''\n+class _Symbols:\n+    def __init__(self):\n+        self.data = {}\n \n-import logging\n-import string\n-import time\n-from collections import defaultdict\n-from typing import Dict, List, Optional, Tuple\n+    def set(self, exchange: str, normalized: dict, exchange_info: dict):\n+        self.data[exchange] = {}\n+        self.data[exchange]['normalized'] = normalized\n+        self.data[exchange]['info'] = exchange_info\n \n-import requests\n-from requests import Response\n+    def get(self, exchange: str) -> Tuple[Dict, Dict]:\n+        return self.data[exchange]['normalized'], self.data[exchange]['info']\n \n-from cryptofeed.defines import *\n+    def populated(self, exchange: str) -> bool:\n+        return exchange in self.data\n \n \n-LOG = logging.getLogger('feedhandler')\n-\n-SYMBOL_SEP = '-'\n-\n-_symbols_retrieval_cache: Dict[str, Dict[str, str]] = {}\n-_exchange_info = defaultdict(lambda: defaultdict(dict))\n-\n-\n-_kraken_futures_product_type = {\n-    'FI': 'Inverse Futures',\n-    'FV': 'Vanilla Futures',\n-    'PI': 'Perpetual Inverse Futures',\n-    'PV': 'Perpetual Vanilla Futures',\n-    'IN': 'Real Time Index',\n-    'RR': 'Reference Rate',\n-}\n-\n-\n-def raise_failure_explanation(feed_id: str, exception: BaseException, responses: Dict[str, Optional[Response]]):\n-    LOG.critical('%s: encountered %r while processing response from exchange API', feed_id, exception)\n-    if len(responses) > 1:\n-        LOG.critical('%s: content of one of the %s responses was unexpected', feed_id, len(responses))\n-    for url, r in responses.items():\n-        if url:\n-            LOG.critical('%s: requested URL: %s', feed_id, url)\n-        if r:\n-            LOG.critical('%s: unexpected response: %s', feed_id, r.text)\n-    raise ValueError(f'Cryptofeed stopped because of an unexpected response from {feed_id}') from exception\n-\n-\n-def set_symbol_separator(separator: str):\n-    global SYMBOL_SEP\n-    SYMBOL_SEP = separator\n-\n-\n-def get_symbol_separator() -> str:\n-    global SYMBOL_SEP\n-    return SYMBOL_SEP\n-\n-\n-def gen_symbols(exchange: str, key_id=None) -> Dict[str, str]:\n-    if exchange not in _symbols_retrieval_cache:\n-        LOG.info(\"%s: Getting list of symbols\", exchange)\n-        symbols = _exchange_function_map[exchange](key_id) if key_id else _exchange_function_map[exchange]()\n-        LOG.info(\"%s: %s symbols\", exchange, len(symbols))\n-\n-        # log all retrieved symbols using debug level\n-        for normalized, exch_sym in sorted(symbols.items()):\n-            LOG.debug('%s: id-from-exch -> normalized: %-35s-> %s', exchange, exch_sym, normalized)\n-\n-        _symbols_retrieval_cache[exchange] = symbols\n-    return _symbols_retrieval_cache[exchange]\n-\n-\n-def _binance_symbols(endpoint: str, exchange: str):\n-    r = None\n-    try:\n-        ret = {}\n-        r = requests.get(endpoint)\n-        for symbol in r.json()['symbols']:\n-            if symbol.get('status', 'TRADING') != \"TRADING\":\n-                continue\n-            if symbol.get('contractStatus', 'TRADING') != \"TRADING\":\n-                continue\n-            split = len(symbol['baseAsset'])\n-            normalized = symbol['symbol'][:split] + SYMBOL_SEP + symbol['symbol'][split:]\n-            ret[normalized] = symbol['symbol']\n-            _exchange_info[exchange]['tick_size'][normalized] = symbol['filters'][0]['tickSize']\n-            if \"contractType\" in symbol:\n-                _exchange_info[exchange]['contract_type'][normalized] = symbol['contractType']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation(exchange, why, {endpoint: r})\n-\n-\n-def binance_symbols() -> Dict[str, str]:\n-    return _binance_symbols('https://api.binance.com/api/v3/exchangeInfo', BINANCE)\n-\n-\n-def binance_us_symbols() -> Dict[str, str]:\n-    return _binance_symbols('https://api.binance.us/api/v3/exchangeInfo', BINANCE_US)\n-\n-\n-def binance_futures_symbols() -> Dict[str, str]:\n-    base = _binance_symbols('https://fapi.binance.com/fapi/v1/exchangeInfo', BINANCE_FUTURES)\n-    add = {}\n-    for symbol, orig in base.items():\n-        if \"_\" in orig:\n-            continue\n-        add[f\"{symbol}-PINDEX\"] = f\"p{orig}\"\n-    base.update(add)\n-    return base\n-\n-\n-def binance_delivery_symbols() -> Dict[str, str]:\n-    return _binance_symbols('https://dapi.binance.com/dapi/v1/exchangeInfo', BINANCE_DELIVERY)\n-\n-\n-def bitfinex_symbols() -> Dict[str, str]:\n-    # doc: https://docs.bitfinex.com/docs/ws-general#supported-pairs\n-    r1 = r2 = None\n-    try:\n-        r1 = requests.get('https://api.bitfinex.com/v2/tickers?symbols=ALL')\n-        r2 = requests.get('https://api-pub.bitfinex.com/v2/conf/pub:map:currency:sym')\n-        tickers: List[List[str]] = r1.json()\n-        norm: List[Tuple[str, str]] = r2.json()[0]\n-        norm: Dict[str, str] = dict(norm)\n-        for k, v in dict(norm).items():\n-            if k[-2:] == 'F0' or '-' in v:  # Do not convert BTCF0 -> BTC or PBTCETH -> PBTC-ETH\n-                del norm[k]\n-        norm['BCHN'] = 'BCH'  # Bitfinex uses BCHN, other exchanges use BCH\n-\n-        ret = {}\n-        for symbol in [t[0] for t in tickers]:\n-            if symbol[0] == 'f':\n-                normalized = norm.get(symbol[1:], symbol[1:])\n-            else:\n-                if len(symbol) == 7:\n-                    base, quote = symbol[1:4], symbol[4:]\n-                else:\n-                    base, quote = symbol[1:].split(':')\n-                    assert ':' in symbol\n-                normalized = norm.get(base, base) + SYMBOL_SEP + norm.get(quote, quote)\n-            ret[normalized.upper()] = symbol\n-        return ret\n-    except ValueError as why:\n-        raise_failure_explanation('BITFINEX', why, {\"tickers?symbols=ALL\": r1, \"pub:map:currency:sym\": r2})\n-\n-\n-def bitflyer_symbols() -> Dict[str, str]:\n-    endpoint = r = None\n-    try:\n-        ret = {}\n-        endpoints = ['https://api.bitflyer.com/v1/getmarkets/eu', 'https://api.bitflyer.com/v1/getmarkets/usa', 'https://api.bitflyer.com/v1/getmarkets']\n-        for endpoint in endpoints:\n-            r = requests.get(endpoint)\n-            for entry in r.json():\n-                normalized = entry['product_code'].replace(\"_\", SYMBOL_SEP)\n-                ret[normalized] = entry['product_code']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('BITFLYER', why, {endpoint: r})\n-\n-\n-def bybit_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.bybit.com/v2/public/symbols')\n-        ret = {}\n-        for symbol in r.json()['result']:\n-            quote = symbol['quote_currency']\n-            if not symbol['name'].endswith(quote):\n-                base, contract = symbol['name'].split(quote)\n-                normalized = f\"{base}{SYMBOL_SEP}{quote}-{contract}\"\n-            else:\n-                normalized = f\"{symbol['base_currency']}{SYMBOL_SEP}{quote}\"\n-            ret[normalized] = symbol['name']\n-            _exchange_info[BYBIT]['tick_size'][normalized] = symbol['price_filter']['tick_size']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('BYBIT', why, {\"\": r})\n-\n-\n-def _ftx_helper(endpoint: str, exchange: str):\n-    r = None\n-    try:\n-        r = requests.get(endpoint)\n-        ret = {}\n-        for data in r.json()['result']:\n-            normalized = data['name'].replace(\"/\", SYMBOL_SEP)\n-            symbol = data['name']\n-            ret[normalized] = symbol\n-            _exchange_info[exchange]['tick_size'][normalized] = data['priceIncrement']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation(exchange, why, {endpoint: r})\n-\n-\n-def ftx_symbols() -> Dict[str, str]:\n-    return _ftx_helper('https://ftx.com/api/markets', FTX)\n-\n-\n-def ftx_us_symbols() -> Dict[str, str]:\n-    return _ftx_helper('https://ftx.us/api/markets', FTX_US)\n-\n-\n-def coinbase_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.pro.coinbase.com/products')\n-        ret = {}\n-        for data in r.json():\n-            normalized = data['id'].replace(\"-\", SYMBOL_SEP)\n-            ret[normalized] = data['id']\n-            _exchange_info[COINBASE]['tick_size'][normalized] = data['quote_increment']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('COINBASE', why, {\"\": r})\n-\n-\n-def gemini_symbols(*args) -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.gemini.com/v1/symbols')\n-        ret = {}\n-        for symbol in r.json():\n-            std = f\"{symbol[:-3]}{SYMBOL_SEP}{symbol[-3:]}\"\n-            std = std.upper()\n-            ret[std] = symbol.upper()\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('GEMINI', why, {\"\": r})\n-\n-\n-def hitbtc_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        ret = {}\n-        r = requests.get('https://api.hitbtc.com/api/2/public/symbol')\n-        for symbol in r.json():\n-            split = len(symbol['baseCurrency'])\n-            normalized = symbol['id'][:split] + SYMBOL_SEP + symbol['id'][split:]\n-            ret[normalized] = symbol['id']\n-            _exchange_info[HITBTC]['tick_size'][normalized] = symbol['tickSize']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('HITBTC', why, {\"\": r})\n-\n-\n-def poloniex_id_symbol_mapping():\n-    r = None\n-    try:\n-        r = requests.get('https://poloniex.com/public?command=returnTicker')\n-        symbols = r.json()\n-        ret = {}\n-        for symbol in symbols:\n-            ret[symbols[symbol]['id']] = symbol\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('POLONIEX', why, {\"\": r})\n-\n-\n-def poloniex_symbols() -> Dict[str, str]:\n-    ret = {}\n-    for _, value in poloniex_id_symbol_mapping().items():\n-        std = value.replace(\"STR\", \"XLM\")\n-        quote, base = std.split(\"_\")\n-        ret[quote + SYMBOL_SEP + base] = value\n-    return ret\n-\n-\n-def bitstamp_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://www.bitstamp.net/api/v2/trading-pairs-info/')\n-        ret = {}\n-        for data in r.json():\n-            normalized = data['name'].replace(\"/\", SYMBOL_SEP)\n-            symbol = data['url_symbol']\n-            ret[normalized] = symbol\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('BITSTAMP', why, {\"\": r})\n-\n-\n-def kraken_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.kraken.com/0/public/AssetPairs')\n-        data = r.json()\n-        ret = {}\n-        for symbol in data['result']:\n-            if 'wsname' not in data['result'][symbol] or '.d' in symbol:\n-                # https://blog.kraken.com/post/259/introducing-the-kraken-dark-pool/\n-                # .d is for dark pool symbols\n-                continue\n-\n-            base, quote = data['result'][symbol]['wsname'].split(\"/\")\n-\n-            normalized = f\"{base}{SYMBOL_SEP}{quote}\"\n-            exch = data['result'][symbol]['wsname']\n-            normalized = normalized.replace('XBT', 'BTC')\n-            normalized = normalized.replace('XDG', 'DOG')\n-            ret[normalized] = exch\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('KRAKEN', why, {\"\": r})\n-\n-\n-def kraken_rest_symbols() -> Dict[str, str]:\n-    return {normalized: exchange.replace(\"/\", \"\") for normalized, exchange in kraken_symbols().items()}\n-\n-\n-def exx_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.exx.com/data/v1/tickers')\n-        exchange = [key.upper() for key in r.json().keys()]\n-        symbols = [key.replace(\"_\", SYMBOL_SEP) for key in exchange]\n-        return dict(zip(symbols, exchange))\n-    except Exception as why:\n-        raise_failure_explanation('EXX', why, {\"\": r})\n-\n-\n-def huobi_common_symbols(url: str):\n-    r = None\n-    try:\n-        r = requests.get(url)\n-        ret = {}\n-        for e in r.json()['data']:\n-            if e['state'] == 'offline':\n-                continue\n-            normalized = f\"{e['base-currency'].upper()}{SYMBOL_SEP}{e['quote-currency'].upper()}\"\n-            symbol = f\"{e['base-currency']}{e['quote-currency']}\"\n-            ret[normalized] = symbol\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('HUOBI', why, {url: r})\n-\n-\n-def huobi_symbols() -> Dict[str, str]:\n-    return huobi_common_symbols('https://api.huobi.pro/v1/common/symbols')\n-\n-\n-def huobi_us_symbols() -> Dict[str, str]:\n-    return huobi_common_symbols('https://api.huobi.com/v1/common/symbols')\n-\n-\n-def huobi_dm_symbols() -> Dict[str, str]:\n-    \"\"\"\n-    Mapping is, for instance: {\"BTC_CW\":\"BTC190816\"}\n-    See comments in exchange/huobi_dm.py\n-    \"\"\"\n-    mapping = {\n-        \"this_week\": \"CW\",\n-        \"next_week\": \"NW\",\n-        \"quarter\": \"CQ\",\n-        \"next_quarter\": \"NQ\"\n-    }\n-    r = None\n-    try:\n-        r = requests.get('https://www.hbdm.com/api/v1/contract_contract_info')\n-        symbols = {}\n-        for e in r.json()['data']:\n-            symbols[f\"{e['symbol']}_{mapping[e['contract_type']]}\"] = e['contract_code']\n-            _exchange_info[HUOBI_DM]['tick_size'][e['contract_code']] = e['price_tick']\n-            _exchange_info[HUOBI_DM]['short_code_mappings'][f\"{e['symbol']}_{mapping[e['contract_type']]}\"] = e['contract_code']\n-        return symbols\n-    except Exception as why:\n-        raise_failure_explanation('HUOBI_DM', why, {\"\": r})\n-\n-\n-def huobi_swap_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.hbdm.com/swap-api/v1/swap_contract_info')\n-        symbols = {}\n-        for e in r.json()['data']:\n-            symbols[e['contract_code']] = e['contract_code']\n-            _exchange_info[HUOBI_SWAP]['tick_size'][e['contract_code']] = e['price_tick']\n-        return symbols\n-    except Exception as why:\n-        raise_failure_explanation('HUOBI_SWAP', why, {\"\": r})\n-\n-\n-def okcoin_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://www.okcoin.com/api/spot/v3/instruments')\n-        ret = {}\n-        for e in r.json():\n-            ret[e['instrument_id']] = e['instrument_id']\n-            _exchange_info[OKCOIN]['tick_size'][e['instrument_id']] = e['tick_size']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('OKCOIN', why, {\"\": r})\n-\n-\n-def okex_symbols(*args) -> Dict[str, str]:\n-    urls = ['https://www.okex.com/api/spot/v3/instruments',\n-            'https://www.okex.com/api/swap/v3/instruments',\n-            'https://www.okex.com/api/futures/v3/instruments']\n-    urls = urls + okex_compute_option_urls_from_underlyings()\n-\n-    symbols: Dict[str, str] = {}\n-    for u in urls:\n-        time.sleep(0.2)\n-        symbols.update(okex_symbols_from_one_url(u))\n-\n-    for symbol in symbols:\n-        instrument_type = 'futures'\n-        dash_count = symbol.count(get_symbol_separator())\n-        if dash_count == 1:  # BTC-USDT\n-            instrument_type = 'spot'\n-        if dash_count == 4:  # BTC-USD-201225-35000-P\n-            instrument_type = 'option'\n-        if symbol[-4:] == \"SWAP\":  # BTC-USDT-SWAP\n-            instrument_type = 'swap'\n-\n-        _exchange_info[OKEX]['instrument_type'][symbol] = instrument_type\n-\n-    return symbols\n-\n-\n-def okex_compute_option_urls_from_underlyings() -> List[str]:\n-    url = 'https://www.okex.com/api/option/v3/underlying'\n-    r = None\n-    try:\n-        r = requests.get(url)\n-        return [f'https://www.okex.com/api/option/v3/instruments/{underlying}' for underlying in r.json()]\n-    except Exception as why:\n-        raise_failure_explanation('OKEX', why, {url: r})\n-\n-\n-def okex_symbols_from_one_url(url: str) -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get(url)\n-        ret = {}\n-        for e in r.json():\n-            ret[e['instrument_id']] = e['instrument_id']\n-            _exchange_info[OKEX]['tick_size'][e['instrument_id']] = e['tick_size']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('OKEX', why, {url: r})\n-\n-\n-def bittrex_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.bittrex.com/api/v1.1/public/getmarkets')\n-        r = r.json()['result']\n-        return {f\"{e['MarketCurrency']}{SYMBOL_SEP}{e['BaseCurrency']}\": e['MarketName'] for e in r if e['IsActive']}\n-    except Exception as why:\n-        raise_failure_explanation('BITTREX', why, {\"\": r})\n-\n-\n-def bitcoincom_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.exchange.bitcoin.com/api/2/public/symbol')\n-        return {f\"{data['baseCurrency']}{SYMBOL_SEP}{data['quoteCurrency'].replace('USD', 'USDT')}\": data['id'] for data in r.json()}\n-    except Exception as why:\n-        raise_failure_explanation('BITCOINCOM', why, {\"\": r})\n-\n-\n-def bitmax_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://bitmax.io/api/pro/v1/products')\n-        ret = {}\n-        for entry in r.json()['data']:\n-            # Only \"Normal\" status symbols are tradeable\n-            if entry['status'] == 'Normal':\n-                normalized = f\"{entry['baseAsset']}{SYMBOL_SEP}{entry['quoteAsset']}\"\n-                ret[normalized] = entry['symbol']\n-                _exchange_info[BITMAX]['tick_size'][normalized] = entry['tickSize']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('BITMAX', why, {\"\": r})\n-\n-\n-def upbit_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.upbit.com/v1/market/all')\n-        return {f\"{data['market'].split('-')[1]}{SYMBOL_SEP}{data['market'].split('-')[0]}\": data['market'] for data in r.json()}\n-    except Exception as why:\n-        raise_failure_explanation('UPBIT', why, {\"\": r})\n-\n-\n-def blockchain_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get(\"https://api.blockchain.com/mercury-gateway/v1/instruments\")\n-        return {data[\"symbol\"].replace(\"-\", SYMBOL_SEP): data[\"symbol\"] for data in r.json()}\n-    except Exception as why:\n-        raise_failure_explanation('BLOCKCHAIN', why, {\"\": r})\n-\n-\n-def gateio_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get(\"https://api.gateio.ws/api/v4/spot/currency_pairs\")\n-        return {data[\"id\"].replace(\"_\", SYMBOL_SEP): data['id'] for data in r.json()}\n-    except Exception as why:\n-        raise_failure_explanation('GATEIO', why, {\"\": r})\n-\n-\n-def bitmex_symbols() -> Dict[str, str]:\n-    r = None\n-    ret = {}\n-    try:\n-        r = requests.get(\"https://www.bitmex.com/api/v1/instrument/active\")\n-        for entry in r.json():\n-            components = []\n-            components.append(entry['rootSymbol'])\n-            components.append(entry['quoteCurrency'])\n-\n-            if entry['expiry']:\n-                components.append(entry['symbol'][-3:])\n-\n-            normalized = SYMBOL_SEP.join(components)\n-            normalized = normalized.replace(\"XBT\", \"BTC\")\n-            ret[normalized] = entry['symbol']\n-            _exchange_info[BITMEX]['tick_size'][normalized] = entry['tickSize']\n-\n-            if entry['expiry']:\n-                _exchange_info[BITMEX]['expiry'][normalized] = entry['expiry']\n-\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('BITMEX', why, {\"\": r})\n-\n-\n-def deribit_symbols() -> Dict[str, str]:\n-    url = r = None\n-    ret = {}\n-    try:\n-        # TODO: get currencies from https://www.deribit.com/api/v2/public/get_currencies\n-        currencies = ['BTC', 'ETH']\n-        for c in currencies:\n-            url = f\"https://www.deribit.com/api/v2/public/get_instruments?currency={c}&expired=false\"\n-            r = requests.get(url)\n-            for entry in r.json()['result']:\n-                split = entry['instrument_name'].split(\"-\")\n-                normalized = split[0] + SYMBOL_SEP + entry['quote_currency'] + \"-\" + '-'.join(split[1:])\n-                ret[normalized] = entry['instrument_name']\n-                _exchange_info[DERIBIT]['tick_size'][normalized] = entry['tick_size']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('DERIBIT', why, {url: r})\n-\n-\n-def kraken_future_symbols() -> Dict[str, str]:\n-    r = None\n-    ret = {}\n-    try:\n-        r = requests.get('https://futures.kraken.com/derivatives/api/v3/instruments')\n-        data = r.json()['instruments']\n-        for entry in data:\n-            if not entry['tradeable']:\n-                continue\n-            normalized = entry['symbol'].upper().replace(\"_\", \"-\")\n-            symbol = normalized[3:6] + SYMBOL_SEP + normalized[6:9]\n-            normalized = normalized.replace(normalized[3:9], symbol)\n-            normalized = normalized.replace('XBT', 'BTC')\n-\n-            _exchange_info[KRAKEN_FUTURES]['tick_size'][normalized] = entry['tickSize']\n-            _exchange_info[KRAKEN_FUTURES]['contract_size'][normalized] = entry['contractSize']\n-            _exchange_info[KRAKEN_FUTURES]['underlying'][normalized] = entry['underlying']\n-            _exchange_info[KRAKEN_FUTURES]['product_type'][normalized] = _kraken_futures_product_type[normalized[:2]]\n-            ret[normalized] = entry['symbol']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('KRAKEN_FUTURES', why, {\"\": r})\n-\n-\n-def probit_symbols() -> Dict[str, str]:\n-    # doc: https://docs-en.probit.com/reference-link/market\n-    r = None\n-    try:\n-        r = requests.get('https://api.probit.com/api/exchange/v1/market')\n-        return {entry['id']: entry['id'] for entry in r.json()['data']}\n-    except Exception as why:\n-        raise_failure_explanation('PROBIT', why, {\"\": r})\n-\n-\n-def coingecko_normalize_symbol(symbol: str) -> str:\n-    # keep digits, letters and dots, replace others by space\n-    symbol = ''.join(c if c.isalnum() or c in ('.', '+') else ' ' for c in symbol)\n-    return coingecko_normalize(symbol.upper())\n-\n-\n-def coingecko_normalize_name(name: str) -> str:\n-    # keep digits and letters, replace others by space (except when only composed by upper case letters, digits and dots)\n-    if not all(c.isupper() or c.isdigit() or c == '.' for c in name):\n-        name = ''.join(c if c.isalnum() else ' ' for c in name)\n-    return coingecko_normalize(name)\n-\n-\n-def coingecko_normalize(sym: str) -> str:\n-    sym = sym.strip()\n-    # do not concatenate numbers => separate them with a dot\n-    sym = list(sym)\n-    if len(sym) > 4:\n-        for i in range(2, len(sym) - 1):\n-            if sym[i] == ' ' and sym[i - 1].isdigit() and sym[i + 1].isdigit():\n-                sym[i] = '.'\n-    sym = ''.join(sym)\n-    # concatenate space-separated words => use CamelCase to distinguish the words\n-    if ' ' in sym:\n-        if sum(c.islower() for c in sym):  # if there is at least one lower case letter\n-            sym = ' '.join(word[0].upper() + word[1:] for word in sym.split())  # Just capitalize initial letter of each word\n-        else:  # CoinGecko may provide full upper-case as for \"THE STONE COIN\"\n-            sym = string.capwords(sym)  # capwords converts \"THE STONE COIN\" to \"The Stone Coin\"\n-        sym = sym.replace(' ', '')  # concatenate words\n-    return sym\n-\n-\n-def is_name_short(coin: dict) -> bool:\n-    \"\"\"return True if the coin name is enough short compared to the coin symbol.\"\"\"\n-    return len(coin['name']) <= max(5, len(coin['symbol']) + 1)\n-\n-\n-def has_many_caps(name: str) -> bool:\n-    \"\"\"return True if the symbol contains enough upper case letters, False if empty.\"\"\"\n-    return str and sum(c.islower() for c in name) < (len(name) / 2)\n-\n-\n-def coingecko_normalize_all(coin: dict):\n-    SYMBOL_TO_NORMALIZED = {'miota': 'IOTA'}\n-    normalized = SYMBOL_TO_NORMALIZED.get(coin['symbol'])\n-    if normalized:\n-        coin['ns'] = coin['nn'] = normalized\n-        return normalized\n-\n-    # ns = normalized symbol, nn = normalized name\n-    coin['ns'] = coingecko_normalize_symbol(coin['symbol'])\n-\n-    ID_SUFFIX = '-bitcoin-token'\n-    if coin['id'][-len(ID_SUFFIX):] == ID_SUFFIX:\n-        coin['nn'] = 'BTC' + coin['ns']\n-        return coin['nn']\n-\n-    name = coin['name']\n-\n-    prefixes = ('The ', 'the ')\n-    for p in prefixes:\n-        if name[:len(p)] == p:\n-            coin['reduced-name'] = True\n-            name = name[len(p):]\n-            break\n-\n-    suffixes = ('coin', 'coins', 'money', 'finance', 'protocol', 'reward', 'rewards', 'token')\n-    for s in suffixes:\n-        if len(name) > len(s) and name[-len(s):].lower() == s:\n-            # but keep suffix when lower-case concatenated\n-            if name[-len(s)].islower() and name[-len(s) - 1] != ' ':\n-                continue\n-            # also keep suffix to avoid confusing nam: \"Bitcoin Token\" -> \"Bitcoin\"\n-            if name[:-len(s)].strip().lower() == 'bitcoin':\n-                continue\n-            coin['reduced-name'] = True\n-            name = name[:-len(s)]\n-            break\n-\n-    coin['nn'] = coingecko_normalize_name(name)\n-\n-    if len(coin['nn']) < len(coin['ns']):\n-        if 'reduced-name' in coin:\n-            coin['reduced-name'] = False\n-            name = coin['name']\n-            coin['nn'] = coingecko_normalize_name(name)\n-        elif not has_many_caps(name):\n-            return coin['ns']\n-\n-    if not coin['ns']:  # coin['symbol'] may be an emoji that is striped when normalized\n-        return coin['nn']\n-\n-    if coin.get('reduced-name') and coin['ns'].upper() != coin['nn'].upper():\n-        return coin['ns']\n-\n-    i = coin['nn'].find('.')  # if there is a dot in normalized name => prefer the normalized symbol\n-    if i >= 0:\n-        if i > 1 and coin['nn'][i - 1].isdigit() and coin['nn'][i + 1].isdigit():\n-            pass  # except when the dot separates digits\n-        else:\n-            return coin['ns']\n-\n-    if is_name_short(coin) and has_many_caps(name):\n-        return coin['nn']\n-\n-    if 1.5 * len(coin['ns']) > len(coin['nn']) and any(c.islower() for c in coin['ns']):\n-        return coin['nn']\n-\n-    return coin['ns']\n-\n-\n-def coingecko_symbols() -> Dict[str, str]:\n-    r = None\n-    intermediate = defaultdict(list)\n-    try:\n-        r = requests.get('https://api.coingecko.com/api/v3/coins/list')\n-        all_coins = r.json()\n-        # First pass: generate & compare normalized symbol/name, and then select the most pertinent\n-        for coin in all_coins:\n-            normalized = coingecko_normalize_all(coin)\n-            intermediate[normalized].append(coin)\n-            # Above line keeps together the coins having the same normalized symbol.\n-            # To reduce collision, the coin['name'] is sometimes used in lieu of the coin['symbol'].\n-            # The coin['name'] is not capitalized because lower case letters may be meaningful: cETH, yUSD, DATx, zLOT\n-    except Exception as why:\n-        raise_failure_explanation('COINGECKO', why, {\"\": r})\n-\n-    final = coingecko_second_pass(intermediate)\n-    return coingecko_third_pass(final)\n-\n-\n-def coingecko_second_pass(intermediate: Dict[str, List[dict]]) -> Dict[str, List[dict]]:\n-    # Second pass: fixes most of the symbol collisions\n-    final = defaultdict(list)\n-    for normalized, coins in intermediate.items():\n-        if len(coins) == 1:\n-            final[normalized].append(coins[0])\n-            continue\n-        set_normalized = False\n-        for i in range(len(coins)):\n-            if normalized == coins[i]['nn']:\n-                coin = coins.pop(i)\n-                final[normalized].append(coin)\n-                set_normalized = True\n-                break\n-        rest: List[dict] = []\n-        for coin in coins:\n-            if '%' in coin['name']:\n-                if len(coins) == 1:\n-                    n = coin['ns']\n-                else:\n-                    n = coingecko_normalize_name(coin['id'])\n-                final[n].append(coin)\n-            else:\n-                rest.append(coin)\n-        if not rest:\n-            continue\n-        if not set_normalized:\n-            rest.sort(key=lambda coin: len(coin['nn']), reverse=True)  # sort by the length of the normalized name\n-            coin = rest.pop(0)\n-            final[normalized].append(coin)\n-        for coin in rest:\n-            if coin['nn'] not in intermediate:\n-                n = coin['nn']\n-            elif coin.get('reduced-name'):\n-                n = coingecko_normalize_name(coin['name'])\n-            else:\n-                n = coingecko_normalize_name(coin['id'])\n-            final[n].append(coin)\n-    return final\n-\n-\n-def coingecko_third_pass(final: Dict[str, List[dict]]) -> Dict[str, str]:\n-    # Third pass: fixes some remaining collisions and fills the result\n-    symbols = {}\n-    for normalized, coins in final.items():\n-        if len(coins) == 1:\n-            symbols[normalized] = coins[0]['id']\n-            continue\n-        set_normalized = False\n-        for i in range(len(coins)):\n-            if normalized == coins[i]['nn']:\n-                coin = coins.pop(i)\n-                symbols[normalized] = coin['id']\n-                set_normalized = True\n-                break\n-        rest: List[dict] = []\n-        for coin in coins:\n-            if '%' in coin['name']:\n-                if len(coins) == 1:\n-                    n = coin['ns']\n-                else:\n-                    n = coingecko_normalize_name(coin['id'])\n-                symbols[n] = coin['id']\n-            else:\n-                rest.append(coin)\n-        if not rest:\n-            continue\n-        if not set_normalized:\n-            rest.sort(key=lambda coin: len(coin['nn']), reverse=True)  # sort by the length of the normalized name\n-            coin = rest.pop(0)\n-            symbols[normalized] = coin['id']\n-        for coin in rest:\n-            if coin['nn'] not in final:\n-                n = coin['nn']\n-            elif coin.get('reduced-name'):\n-                n = coingecko_normalize_name(coin['name'])\n-            else:\n-                n = coingecko_normalize_name(coin['id'])\n-            symbols[n] = coin['id']\n-    return symbols\n-\n-\n-def whale_alert_coins(key_id: str) -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get(f'https://api.whale-alert.io/v1/status?api_key={key_id}')\n-        # Same symbols, but on different blockchains (for instance USDT), are naturally overwritten.\n-        return {s.upper(): s for b in r.json()['blockchains'] for s in b['symbols'] if s}\n-    except Exception as why:\n-        raise_failure_explanation('WHALES_ALERT', why, {\"\": r})\n-\n-\n-_exchange_function_map = {\n-    BITFINEX: bitfinex_symbols,\n-    BITFLYER: bitflyer_symbols,\n-    COINBASE: coinbase_symbols,\n-    GEMINI: gemini_symbols,\n-    HITBTC: hitbtc_symbols,\n-    POLONIEX: poloniex_symbols,\n-    PROBIT: probit_symbols,\n-    BITSTAMP: bitstamp_symbols,\n-    KRAKEN: kraken_symbols,\n-    KRAKEN + 'REST': kraken_rest_symbols,\n-    BINANCE: binance_symbols,\n-    BINANCE_US: binance_us_symbols,\n-    BINANCE_FUTURES: binance_futures_symbols,\n-    BINANCE_DELIVERY: binance_delivery_symbols,\n-    BLOCKCHAIN: blockchain_symbols,\n-    EXX: exx_symbols,\n-    HUOBI: huobi_symbols,\n-    HUOBI_DM: huobi_dm_symbols,\n-    HUOBI_SWAP: huobi_swap_symbols,\n-    OKCOIN: okcoin_symbols,\n-    OKEX: okex_symbols,\n-    BYBIT: bybit_symbols,\n-    FTX: ftx_symbols,\n-    FTX_US: ftx_us_symbols,\n-    BITTREX: bittrex_symbols,\n-    BITCOINCOM: bitcoincom_symbols,\n-    BITMAX: bitmax_symbols,\n-    UPBIT: upbit_symbols,\n-    GATEIO: gateio_symbols,\n-    BITMEX: bitmex_symbols,\n-    DERIBIT: deribit_symbols,\n-    KRAKEN_FUTURES: kraken_future_symbols,\n-    COINGECKO: coingecko_symbols,\n-    WHALE_ALERT: whale_alert_coins\n-}\n+Symbols = _Symbols()\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\n\nimport logging\nimport string\nimport time\nfrom collections import defaultdict\nfrom typing import Dict, List, Optional, Tuple\n\nimport requests\nfrom requests import Response\n\nfrom cryptofeed.defines import *\n\n\nLOG = logging.getLogger('feedhandler')\n\nSYMBOL_SEP = '-'\n\n_symbols_retrieval_cache: Dict[str, Dict[str, str]] = {}\n_exchange_info = defaultdict(lambda: defaultdict(dict))\n\n\n_kraken_futures_product_type = {\n    'FI': 'Inverse Futures',\n    'FV': 'Vanilla Futures',\n    'PI': 'Perpetual Inverse Futures',\n    'PV': 'Perpetual Vanilla Futures',\n    'IN': 'Real Time Index',\n    'RR': 'Reference Rate',\n}\n\n\ndef raise_failure_explanation(feed_id: str, exception: BaseException, responses: Dict[str, Optional[Response]]):\n    <IND>LOG.critical('%s: encountered %r while processing response from exchange API', feed_id, exception)\n    if len(responses) > 1:\n        <IND>LOG.critical('%s: content of one of the %s responses was unexpected', feed_id, len(responses))\n    <DED>for url, r in responses.items():\n        <IND>if url:\n            <IND>LOG.critical('%s: requested URL: %s', feed_id, url)\n        <DED>if r:\n            <IND>LOG.critical('%s: unexpected response: %s', feed_id, r.text)\n    <DED><DED>raise ValueError(f'Cryptofeed stopped because of an unexpected response from {feed_id}') from exception\n\n\n<DED>def set_symbol_separator(separator: str):\n    <IND>global SYMBOL_SEP\n    SYMBOL_SEP = separator\n\n\n<DED>def get_symbol_separator() -> str:\n    <IND>global SYMBOL_SEP\n    return SYMBOL_SEP\n\n\n<DED>def gen_symbols(exchange: str, key_id=None) -> Dict[str, str]:\n    <IND>if exchange not in _symbols_retrieval_cache:\n        <IND>LOG.info(\"%s: Getting list of symbols\", exchange)\n        symbols = _exchange_function_map[exchange](key_id) if key_id else _exchange_function_map[exchange]()\n        LOG.info(\"%s: %s symbols\", exchange, len(symbols))\n\n        # log all retrieved symbols using debug level\n        for normalized, exch_sym in sorted(symbols.items()):\n            <IND>LOG.debug('%s: id-from-exch -> normalized: %-35s-> %s', exchange, exch_sym, normalized)\n\n        <DED>_symbols_retrieval_cache[exchange] = symbols\n    <DED>return _symbols_retrieval_cache[exchange]\n\n\n<DED>def _binance_symbols(endpoint: str, exchange: str):\n    <IND>r = None\n    try:\n        <IND>ret = {}\n        r = requests.get(endpoint)\n        for symbol in r.json()['symbols']:\n            <IND>if symbol.get('status', 'TRADING') != \"TRADING\":\n                <IND>continue\n            <DED>if symbol.get('contractStatus', 'TRADING') != \"TRADING\":\n                <IND>continue\n            <DED>split = len(symbol['baseAsset'])\n            normalized = symbol['symbol'][:split] + SYMBOL_SEP + symbol['symbol'][split:]\n            ret[normalized] = symbol['symbol']\n            _exchange_info[exchange]['tick_size'][normalized] = symbol['filters'][0]['tickSize']\n            if \"contractType\" in symbol:\n                <IND>_exchange_info[exchange]['contract_type'][normalized] = symbol['contractType']\n        <DED><DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation(exchange, why, {endpoint: r})\n\n\n<DED><DED>def binance_symbols() -> Dict[str, str]:\n    <IND>return _binance_symbols('https://api.binance.com/api/v3/exchangeInfo', BINANCE)\n\n\n<DED>def binance_us_symbols() -> Dict[str, str]:\n    <IND>return _binance_symbols('https://api.binance.us/api/v3/exchangeInfo', BINANCE_US)\n\n\n<DED>def binance_futures_symbols() -> Dict[str, str]:\n    <IND>base = _binance_symbols('https://fapi.binance.com/fapi/v1/exchangeInfo', BINANCE_FUTURES)\n    add = {}\n    for symbol, orig in base.items():\n        <IND>if \"_\" in orig:\n            <IND>continue\n        <DED>add[f\"{symbol}-PINDEX\"] = f\"p{orig}\"\n    <DED>base.update(add)\n    return base\n\n\n<DED>def binance_delivery_symbols() -> Dict[str, str]:\n    <IND>return _binance_symbols('https://dapi.binance.com/dapi/v1/exchangeInfo', BINANCE_DELIVERY)\n\n\n<DED>def bitfinex_symbols() -> Dict[str, str]:\n    # doc: https://docs.bitfinex.com/docs/ws-general#supported-pairs\n    <IND>r1 = r2 = None\n    try:\n        <IND>r1 = requests.get('https://api.bitfinex.com/v2/tickers?symbols=ALL')\n        r2 = requests.get('https://api-pub.bitfinex.com/v2/conf/pub:map:currency:sym')\n        tickers: List[List[str]] = r1.json()\n        norm: List[Tuple[str, str]] = r2.json()[0]\n        norm: Dict[str, str] = dict(norm)\n        for k, v in dict(norm).items():\n            <IND>if k[-2:] == 'F0' or '-' in v:  # Do not convert BTCF0 -> BTC or PBTCETH -> PBTC-ETH\n                <IND>del norm[k]\n        <DED><DED>norm['BCHN'] = 'BCH'  # Bitfinex uses BCHN, other exchanges use BCH\n\n        ret = {}\n        for symbol in [t[0] for t in tickers]:\n            <IND>if symbol[0] == 'f':\n                <IND>normalized = norm.get(symbol[1:], symbol[1:])\n            <DED>else:\n                <IND>if len(symbol) == 7:\n                    <IND>base, quote = symbol[1:4], symbol[4:]\n                <DED>else:\n                    <IND>base, quote = symbol[1:].split(':')\n                    assert ':' in symbol\n                <DED>normalized = norm.get(base, base) + SYMBOL_SEP + norm.get(quote, quote)\n            <DED>ret[normalized.upper()] = symbol\n        <DED>return ret\n    <DED>except ValueError as why:\n        <IND>raise_failure_explanation('BITFINEX', why, {\"tickers?symbols=ALL\": r1, \"pub:map:currency:sym\": r2})\n\n\n<DED><DED>def bitflyer_symbols() -> Dict[str, str]:\n    <IND>endpoint = r = None\n    try:\n        <IND>ret = {}\n        endpoints = ['https://api.bitflyer.com/v1/getmarkets/eu', 'https://api.bitflyer.com/v1/getmarkets/usa', 'https://api.bitflyer.com/v1/getmarkets']\n        for endpoint in endpoints:\n            <IND>r = requests.get(endpoint)\n            for entry in r.json():\n                <IND>normalized = entry['product_code'].replace(\"_\", SYMBOL_SEP)\n                ret[normalized] = entry['product_code']\n        <DED><DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BITFLYER', why, {endpoint: r})\n\n\n<DED><DED>def bybit_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.bybit.com/v2/public/symbols')\n        ret = {}\n        for symbol in r.json()['result']:\n            <IND>quote = symbol['quote_currency']\n            if not symbol['name'].endswith(quote):\n                <IND>base, contract = symbol['name'].split(quote)\n                normalized = f\"{base}{SYMBOL_SEP}{quote}-{contract}\"\n            <DED>else:\n                <IND>normalized = f\"{symbol['base_currency']}{SYMBOL_SEP}{quote}\"\n            <DED>ret[normalized] = symbol['name']\n            _exchange_info[BYBIT]['tick_size'][normalized] = symbol['price_filter']['tick_size']\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BYBIT', why, {\"\": r})\n\n\n<DED><DED>def _ftx_helper(endpoint: str, exchange: str):\n    <IND>r = None\n    try:\n        <IND>r = requests.get(endpoint)\n        ret = {}\n        for data in r.json()['result']:\n            <IND>normalized = data['name'].replace(\"/\", SYMBOL_SEP)\n            symbol = data['name']\n            ret[normalized] = symbol\n            _exchange_info[exchange]['tick_size'][normalized] = data['priceIncrement']\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation(exchange, why, {endpoint: r})\n\n\n<DED><DED>def ftx_symbols() -> Dict[str, str]:\n    <IND>return _ftx_helper('https://ftx.com/api/markets', FTX)\n\n\n<DED>def ftx_us_symbols() -> Dict[str, str]:\n    <IND>return _ftx_helper('https://ftx.us/api/markets', FTX_US)\n\n\n<DED>def coinbase_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.pro.coinbase.com/products')\n        ret = {}\n        for data in r.json():\n            <IND>normalized = data['id'].replace(\"-\", SYMBOL_SEP)\n            ret[normalized] = data['id']\n            _exchange_info[COINBASE]['tick_size'][normalized] = data['quote_increment']\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('COINBASE', why, {\"\": r})\n\n\n<DED><DED>def gemini_symbols(*args) -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.gemini.com/v1/symbols')\n        ret = {}\n        for symbol in r.json():\n            <IND>std = f\"{symbol[:-3]}{SYMBOL_SEP}{symbol[-3:]}\"\n            std = std.upper()\n            ret[std] = symbol.upper()\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('GEMINI', why, {\"\": r})\n\n\n<DED><DED>def hitbtc_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>ret = {}\n        r = requests.get('https://api.hitbtc.com/api/2/public/symbol')\n        for symbol in r.json():\n            <IND>split = len(symbol['baseCurrency'])\n            normalized = symbol['id'][:split] + SYMBOL_SEP + symbol['id'][split:]\n            ret[normalized] = symbol['id']\n            _exchange_info[HITBTC]['tick_size'][normalized] = symbol['tickSize']\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('HITBTC', why, {\"\": r})\n\n\n<DED><DED>def poloniex_id_symbol_mapping():\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://poloniex.com/public?command=returnTicker')\n        symbols = r.json()\n        ret = {}\n        for symbol in symbols:\n            <IND>ret[symbols[symbol]['id']] = symbol\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('POLONIEX', why, {\"\": r})\n\n\n<DED><DED>def poloniex_symbols() -> Dict[str, str]:\n    <IND>ret = {}\n    for _, value in poloniex_id_symbol_mapping().items():\n        <IND>std = value.replace(\"STR\", \"XLM\")\n        quote, base = std.split(\"_\")\n        ret[quote + SYMBOL_SEP + base] = value\n    <DED>return ret\n\n\n<DED>def bitstamp_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://www.bitstamp.net/api/v2/trading-pairs-info/')\n        ret = {}\n        for data in r.json():\n            <IND>normalized = data['name'].replace(\"/\", SYMBOL_SEP)\n            symbol = data['url_symbol']\n            ret[normalized] = symbol\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BITSTAMP', why, {\"\": r})\n\n\n<DED><DED>def kraken_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.kraken.com/0/public/AssetPairs')\n        data = r.json()\n        ret = {}\n        for symbol in data['result']:\n            <IND>if 'wsname' not in data['result'][symbol] or '.d' in symbol:\n                # https://blog.kraken.com/post/259/introducing-the-kraken-dark-pool/\n                # .d is for dark pool symbols\n                <IND>continue\n\n            <DED>base, quote = data['result'][symbol]['wsname'].split(\"/\")\n\n            normalized = f\"{base}{SYMBOL_SEP}{quote}\"\n            exch = data['result'][symbol]['wsname']\n            normalized = normalized.replace('XBT', 'BTC')\n            normalized = normalized.replace('XDG', 'DOG')\n            ret[normalized] = exch\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('KRAKEN', why, {\"\": r})\n\n\n<DED><DED>def kraken_rest_symbols() -> Dict[str, str]:\n    <IND>return {normalized: exchange.replace(\"/\", \"\") for normalized, exchange in kraken_symbols().items()}\n\n\n<DED>def exx_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.exx.com/data/v1/tickers')\n        exchange = [key.upper() for key in r.json().keys()]\n        symbols = [key.replace(\"_\", SYMBOL_SEP) for key in exchange]\n        return dict(zip(symbols, exchange))\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('EXX', why, {\"\": r})\n\n\n<DED><DED>def huobi_common_symbols(url: str):\n    <IND>r = None\n    try:\n        <IND>r = requests.get(url)\n        ret = {}\n        for e in r.json()['data']:\n            <IND>if e['state'] == 'offline':\n                <IND>continue\n            <DED>normalized = f\"{e['base-currency'].upper()}{SYMBOL_SEP}{e['quote-currency'].upper()}\"\n            symbol = f\"{e['base-currency']}{e['quote-currency']}\"\n            ret[normalized] = symbol\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('HUOBI', why, {url: r})\n\n\n<DED><DED>def huobi_symbols() -> Dict[str, str]:\n    <IND>return huobi_common_symbols('https://api.huobi.pro/v1/common/symbols')\n\n\n<DED>def huobi_us_symbols() -> Dict[str, str]:\n    <IND>return huobi_common_symbols('https://api.huobi.com/v1/common/symbols')\n\n\n<DED>def huobi_dm_symbols() -> Dict[str, str]:\n    <IND>\"\"\"\n    Mapping is, for instance: {\"BTC_CW\":\"BTC190816\"}\n    See comments in exchange/huobi_dm.py\n    \"\"\"\n    mapping = {\n        \"this_week\": \"CW\",\n        \"next_week\": \"NW\",\n        \"quarter\": \"CQ\",\n        \"next_quarter\": \"NQ\"\n    }\n    r = None\n    try:\n        <IND>r = requests.get('https://www.hbdm.com/api/v1/contract_contract_info')\n        symbols = {}\n        for e in r.json()['data']:\n            <IND>symbols[f\"{e['symbol']}_{mapping[e['contract_type']]}\"] = e['contract_code']\n            _exchange_info[HUOBI_DM]['tick_size'][e['contract_code']] = e['price_tick']\n            _exchange_info[HUOBI_DM]['short_code_mappings'][f\"{e['symbol']}_{mapping[e['contract_type']]}\"] = e['contract_code']\n        <DED>return symbols\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('HUOBI_DM', why, {\"\": r})\n\n\n<DED><DED>def huobi_swap_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.hbdm.com/swap-api/v1/swap_contract_info')\n        symbols = {}\n        for e in r.json()['data']:\n            <IND>symbols[e['contract_code']] = e['contract_code']\n            _exchange_info[HUOBI_SWAP]['tick_size'][e['contract_code']] = e['price_tick']\n        <DED>return symbols\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('HUOBI_SWAP', why, {\"\": r})\n\n\n<DED><DED>def okcoin_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://www.okcoin.com/api/spot/v3/instruments')\n        ret = {}\n        for e in r.json():\n            <IND>ret[e['instrument_id']] = e['instrument_id']\n            _exchange_info[OKCOIN]['tick_size'][e['instrument_id']] = e['tick_size']\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('OKCOIN', why, {\"\": r})\n\n\n<DED><DED>def okex_symbols(*args) -> Dict[str, str]:\n    <IND>urls = ['https://www.okex.com/api/spot/v3/instruments',\n            'https://www.okex.com/api/swap/v3/instruments',\n            'https://www.okex.com/api/futures/v3/instruments']\n    urls = urls + okex_compute_option_urls_from_underlyings()\n\n    symbols: Dict[str, str] = {}\n    for u in urls:\n        <IND>time.sleep(0.2)\n        symbols.update(okex_symbols_from_one_url(u))\n\n    <DED>for symbol in symbols:\n        <IND>instrument_type = 'futures'\n        dash_count = symbol.count(get_symbol_separator())\n        if dash_count == 1:  # BTC-USDT\n            <IND>instrument_type = 'spot'\n        <DED>if dash_count == 4:  # BTC-USD-201225-35000-P\n            <IND>instrument_type = 'option'\n        <DED>if symbol[-4:] == \"SWAP\":  # BTC-USDT-SWAP\n            <IND>instrument_type = 'swap'\n\n        <DED>_exchange_info[OKEX]['instrument_type'][symbol] = instrument_type\n\n    <DED>return symbols\n\n\n<DED>def okex_compute_option_urls_from_underlyings() -> List[str]:\n    <IND>url = 'https://www.okex.com/api/option/v3/underlying'\n    r = None\n    try:\n        <IND>r = requests.get(url)\n        return [f'https://www.okex.com/api/option/v3/instruments/{underlying}' for underlying in r.json()]\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('OKEX', why, {url: r})\n\n\n<DED><DED>def okex_symbols_from_one_url(url: str) -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get(url)\n        ret = {}\n        for e in r.json():\n            <IND>ret[e['instrument_id']] = e['instrument_id']\n            _exchange_info[OKEX]['tick_size'][e['instrument_id']] = e['tick_size']\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('OKEX', why, {url: r})\n\n\n<DED><DED>def bittrex_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.bittrex.com/api/v1.1/public/getmarkets')\n        r = r.json()['result']\n        return {f\"{e['MarketCurrency']}{SYMBOL_SEP}{e['BaseCurrency']}\": e['MarketName'] for e in r if e['IsActive']}\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BITTREX', why, {\"\": r})\n\n\n<DED><DED>def bitcoincom_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.exchange.bitcoin.com/api/2/public/symbol')\n        return {f\"{data['baseCurrency']}{SYMBOL_SEP}{data['quoteCurrency'].replace('USD', 'USDT')}\": data['id'] for data in r.json()}\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BITCOINCOM', why, {\"\": r})\n\n\n<DED><DED>def bitmax_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://bitmax.io/api/pro/v1/products')\n        ret = {}\n        for entry in r.json()['data']:\n            # Only \"Normal\" status symbols are tradeable\n            <IND>if entry['status'] == 'Normal':\n                <IND>normalized = f\"{entry['baseAsset']}{SYMBOL_SEP}{entry['quoteAsset']}\"\n                ret[normalized] = entry['symbol']\n                _exchange_info[BITMAX]['tick_size'][normalized] = entry['tickSize']\n        <DED><DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BITMAX', why, {\"\": r})\n\n\n<DED><DED>def upbit_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.upbit.com/v1/market/all')\n        return {f\"{data['market'].split('-')[1]}{SYMBOL_SEP}{data['market'].split('-')[0]}\": data['market'] for data in r.json()}\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('UPBIT', why, {\"\": r})\n\n\n<DED><DED>def blockchain_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get(\"https://api.blockchain.com/mercury-gateway/v1/instruments\")\n        return {data[\"symbol\"].replace(\"-\", SYMBOL_SEP): data[\"symbol\"] for data in r.json()}\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BLOCKCHAIN', why, {\"\": r})\n\n\n<DED><DED>def gateio_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get(\"https://api.gateio.ws/api/v4/spot/currency_pairs\")\n        return {data[\"id\"].replace(\"_\", SYMBOL_SEP): data['id'] for data in r.json()}\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('GATEIO', why, {\"\": r})\n\n\n<DED><DED>def bitmex_symbols() -> Dict[str, str]:\n    <IND>r = None\n    ret = {}\n    try:\n        <IND>r = requests.get(\"https://www.bitmex.com/api/v1/instrument/active\")\n        for entry in r.json():\n            <IND>components = []\n            components.append(entry['rootSymbol'])\n            components.append(entry['quoteCurrency'])\n\n            if entry['expiry']:\n                <IND>components.append(entry['symbol'][-3:])\n\n            <DED>normalized = SYMBOL_SEP.join(components)\n            normalized = normalized.replace(\"XBT\", \"BTC\")\n            ret[normalized] = entry['symbol']\n            _exchange_info[BITMEX]['tick_size'][normalized] = entry['tickSize']\n\n            if entry['expiry']:\n                <IND>_exchange_info[BITMEX]['expiry'][normalized] = entry['expiry']\n\n        <DED><DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BITMEX', why, {\"\": r})\n\n\n<DED><DED>def deribit_symbols() -> Dict[str, str]:\n    <IND>url = r = None\n    ret = {}\n    try:\n        # TODO: get currencies from https://www.deribit.com/api/v2/public/get_currencies\n        <IND>currencies = ['BTC', 'ETH']\n        for c in currencies:\n            <IND>url = f\"https://www.deribit.com/api/v2/public/get_instruments?currency={c}&expired=false\"\n            r = requests.get(url)\n            for entry in r.json()['result']:\n                <IND>split = entry['instrument_name'].split(\"-\")\n                normalized = split[0] + SYMBOL_SEP + entry['quote_currency'] + \"-\" + '-'.join(split[1:])\n                ret[normalized] = entry['instrument_name']\n                _exchange_info[DERIBIT]['tick_size'][normalized] = entry['tick_size']\n        <DED><DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('DERIBIT', why, {url: r})\n\n\n<DED><DED>def kraken_future_symbols() -> Dict[str, str]:\n    <IND>r = None\n    ret = {}\n    try:\n        <IND>r = requests.get('https://futures.kraken.com/derivatives/api/v3/instruments')\n        data = r.json()['instruments']\n        for entry in data:\n            <IND>if not entry['tradeable']:\n                <IND>continue\n            <DED>normalized = entry['symbol'].upper().replace(\"_\", \"-\")\n            symbol = normalized[3:6] + SYMBOL_SEP + normalized[6:9]\n            normalized = normalized.replace(normalized[3:9], symbol)\n            normalized = normalized.replace('XBT', 'BTC')\n\n            _exchange_info[KRAKEN_FUTURES]['tick_size'][normalized] = entry['tickSize']\n            _exchange_info[KRAKEN_FUTURES]['contract_size'][normalized] = entry['contractSize']\n            _exchange_info[KRAKEN_FUTURES]['underlying'][normalized] = entry['underlying']\n            _exchange_info[KRAKEN_FUTURES]['product_type'][normalized] = _kraken_futures_product_type[normalized[:2]]\n            ret[normalized] = entry['symbol']\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('KRAKEN_FUTURES', why, {\"\": r})\n\n\n<DED><DED>def probit_symbols() -> Dict[str, str]:\n    # doc: https://docs-en.probit.com/reference-link/market\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.probit.com/api/exchange/v1/market')\n        return {entry['id']: entry['id'] for entry in r.json()['data']}\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('PROBIT', why, {\"\": r})\n\n\n<DED><DED>def coingecko_normalize_symbol(symbol: str) -> str:\n    # keep digits, letters and dots, replace others by space\n    <IND>symbol = ''.join(c if c.isalnum() or c in ('.', '+') else ' ' for c in symbol)\n    return coingecko_normalize(symbol.upper())\n\n\n<DED>def coingecko_normalize_name(name: str) -> str:\n    # keep digits and letters, replace others by space (except when only composed by upper case letters, digits and dots)\n    <IND>if not all(c.isupper() or c.isdigit() or c == '.' for c in name):\n        <IND>name = ''.join(c if c.isalnum() else ' ' for c in name)\n    <DED>return coingecko_normalize(name)\n\n\n<DED>def coingecko_normalize(sym: str) -> str:\n    <IND>sym = sym.strip()\n    # do not concatenate numbers => separate them with a dot\n    sym = list(sym)\n    if len(sym) > 4:\n        <IND>for i in range(2, len(sym) - 1):\n            <IND>if sym[i] == ' ' and sym[i - 1].isdigit() and sym[i + 1].isdigit():\n                <IND>sym[i] = '.'\n    <DED><DED><DED>sym = ''.join(sym)\n    # concatenate space-separated words => use CamelCase to distinguish the words\n    if ' ' in sym:\n        <IND>if sum(c.islower() for c in sym):  # if there is at least one lower case letter\n            <IND>sym = ' '.join(word[0].upper() + word[1:] for word in sym.split())  # Just capitalize initial letter of each word\n        <DED>else:  # CoinGecko may provide full upper-case as for \"THE STONE COIN\"\n            <IND>sym = string.capwords(sym)  # capwords converts \"THE STONE COIN\" to \"The Stone Coin\"\n        <DED>sym = sym.replace(' ', '')  # concatenate words\n    <DED>return sym\n\n\n<DED>def is_name_short(coin: dict) -> bool:\n    <IND>\"\"\"return True if the coin name is enough short compared to the coin symbol.\"\"\"\n    return len(coin['name']) <= max(5, len(coin['symbol']) + 1)\n\n\n<DED>def has_many_caps(name: str) -> bool:\n    <IND>\"\"\"return True if the symbol contains enough upper case letters, False if empty.\"\"\"\n    return str and sum(c.islower() for c in name) < (len(name) / 2)\n\n\n<DED>def coingecko_normalize_all(coin: dict):\n    <IND>SYMBOL_TO_NORMALIZED = {'miota': 'IOTA'}\n    normalized = SYMBOL_TO_NORMALIZED.get(coin['symbol'])\n    if normalized:\n        <IND>coin['ns'] = coin['nn'] = normalized\n        return normalized\n\n    # ns = normalized symbol, nn = normalized name\n    <DED>coin['ns'] = coingecko_normalize_symbol(coin['symbol'])\n\n    ID_SUFFIX = '-bitcoin-token'\n    if coin['id'][-len(ID_SUFFIX):] == ID_SUFFIX:\n        <IND>coin['nn'] = 'BTC' + coin['ns']\n        return coin['nn']\n\n    <DED>name = coin['name']\n\n    prefixes = ('The ', 'the ')\n    for p in prefixes:\n        <IND>if name[:len(p)] == p:\n            <IND>coin['reduced-name'] = True\n            name = name[len(p):]\n            break\n\n    <DED><DED>suffixes = ('coin', 'coins', 'money', 'finance', 'protocol', 'reward', 'rewards', 'token')\n    for s in suffixes:\n        <IND>if len(name) > len(s) and name[-len(s):].lower() == s:\n            # but keep suffix when lower-case concatenated\n            <IND>if name[-len(s)].islower() and name[-len(s) - 1] != ' ':\n                <IND>continue\n            # also keep suffix to avoid confusing nam: \"Bitcoin Token\" -> \"Bitcoin\"\n            <DED>if name[:-len(s)].strip().lower() == 'bitcoin':\n                <IND>continue\n            <DED>coin['reduced-name'] = True\n            name = name[:-len(s)]\n            break\n\n    <DED><DED>coin['nn'] = coingecko_normalize_name(name)\n\n    if len(coin['nn']) < len(coin['ns']):\n        <IND>if 'reduced-name' in coin:\n            <IND>coin['reduced-name'] = False\n            name = coin['name']\n            coin['nn'] = coingecko_normalize_name(name)\n        <DED>elif not has_many_caps(name):\n            <IND>return coin['ns']\n\n    <DED><DED>if not coin['ns']:  # coin['symbol'] may be an emoji that is striped when normalized\n        <IND>return coin['nn']\n\n    <DED>if coin.get('reduced-name') and coin['ns'].upper() != coin['nn'].upper():\n        <IND>return coin['ns']\n\n    <DED>i = coin['nn'].find('.')  # if there is a dot in normalized name => prefer the normalized symbol\n    if i >= 0:\n        <IND>if i > 1 and coin['nn'][i - 1].isdigit() and coin['nn'][i + 1].isdigit():\n            <IND>pass  # except when the dot separates digits\n        <DED>else:\n            <IND>return coin['ns']\n\n    <DED><DED>if is_name_short(coin) and has_many_caps(name):\n        <IND>return coin['nn']\n\n    <DED>if 1.5 * len(coin['ns']) > len(coin['nn']) and any(c.islower() for c in coin['ns']):\n        <IND>return coin['nn']\n\n    <DED>return coin['ns']\n\n\n<DED>def coingecko_symbols() -> Dict[str, str]:\n    <IND>r = None\n    intermediate = defaultdict(list)\n    try:\n        <IND>r = requests.get('https://api.coingecko.com/api/v3/coins/list')\n        all_coins = r.json()\n        # First pass: generate & compare normalized symbol/name, and then select the most pertinent\n        for coin in all_coins:\n            <IND>normalized = coingecko_normalize_all(coin)\n            intermediate[normalized].append(coin)\n            # Above line keeps together the coins having the same normalized symbol.\n            # To reduce collision, the coin['name'] is sometimes used in lieu of the coin['symbol'].\n            # The coin['name'] is not capitalized because lower case letters may be meaningful: cETH, yUSD, DATx, zLOT\n    <DED><DED>except Exception as why:\n        <IND>raise_failure_explanation('COINGECKO', why, {\"\": r})\n\n    <DED>final = coingecko_second_pass(intermediate)\n    return coingecko_third_pass(final)\n\n\n<DED>def coingecko_second_pass(intermediate: Dict[str, List[dict]]) -> Dict[str, List[dict]]:\n    # Second pass: fixes most of the symbol collisions\n    <IND>final = defaultdict(list)\n    for normalized, coins in intermediate.items():\n        <IND>if len(coins) == 1:\n            <IND>final[normalized].append(coins[0])\n            continue\n        <DED>set_normalized = False\n        for i in range(len(coins)):\n            <IND>if normalized == coins[i]['nn']:\n                <IND>coin = coins.pop(i)\n                final[normalized].append(coin)\n                set_normalized = True\n                break\n        <DED><DED>rest: List[dict] = []\n        for coin in coins:\n            <IND>if '%' in coin['name']:\n                <IND>if len(coins) == 1:\n                    <IND>n = coin['ns']\n                <DED>else:\n                    <IND>n = coingecko_normalize_name(coin['id'])\n                <DED>final[n].append(coin)\n            <DED>else:\n                <IND>rest.append(coin)\n        <DED><DED>if not rest:\n            <IND>continue\n        <DED>if not set_normalized:\n            <IND>rest.sort(key=lambda coin: len(coin['nn']), reverse=True)  # sort by the length of the normalized name\n            coin = rest.pop(0)\n            final[normalized].append(coin)\n        <DED>for coin in rest:\n            <IND>if coin['nn'] not in intermediate:\n                <IND>n = coin['nn']\n            <DED>elif coin.get('reduced-name'):\n                <IND>n = coingecko_normalize_name(coin['name'])\n            <DED>else:\n                <IND>n = coingecko_normalize_name(coin['id'])\n            <DED>final[n].append(coin)\n    <DED><DED>return final\n\n\n<DED>def coingecko_third_pass(final: Dict[str, List[dict]]) -> Dict[str, str]:\n    # Third pass: fixes some remaining collisions and fills the result\n    <IND>symbols = {}\n    for normalized, coins in final.items():\n        <IND>if len(coins) == 1:\n            <IND>symbols[normalized] = coins[0]['id']\n            continue\n        <DED>set_normalized = False\n        for i in range(len(coins)):\n            <IND>if normalized == coins[i]['nn']:\n                <IND>coin = coins.pop(i)\n                symbols[normalized] = coin['id']\n                set_normalized = True\n                break\n        <DED><DED>rest: List[dict] = []\n        for coin in coins:\n            <IND>if '%' in coin['name']:\n                <IND>if len(coins) == 1:\n                    <IND>n = coin['ns']\n                <DED>else:\n                    <IND>n = coingecko_normalize_name(coin['id'])\n                <DED>symbols[n] = coin['id']\n            <DED>else:\n                <IND>rest.append(coin)\n        <DED><DED>if not rest:\n            <IND>continue\n        <DED>if not set_normalized:\n            <IND>rest.sort(key=lambda coin: len(coin['nn']), reverse=True)  # sort by the length of the normalized name\n            coin = rest.pop(0)\n            symbols[normalized] = coin['id']\n        <DED>for coin in rest:\n            <IND>if coin['nn'] not in final:\n                <IND>n = coin['nn']\n            <DED>elif coin.get('reduced-name'):\n                <IND>n = coingecko_normalize_name(coin['name'])\n            <DED>else:\n                <IND>n = coingecko_normalize_name(coin['id'])\n            <DED>symbols[n] = coin['id']\n    <DED><DED>return symbols\n\n\n<DED>def whale_alert_coins(key_id: str) -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get(f'https://api.whale-alert.io/v1/status?api_key={key_id}')\n        # Same symbols, but on different blockchains (for instance USDT), are naturally overwritten.\n        return {s.upper(): s for b in r.json()['blockchains'] for s in b['symbols'] if s}\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('WHALES_ALERT', why, {\"\": r})\n\n\n<DED><DED>_exchange_function_map = {\n    BITFINEX: bitfinex_symbols,\n    BITFLYER: bitflyer_symbols,\n    COINBASE: coinbase_symbols,\n    GEMINI: gemini_symbols,\n    HITBTC: hitbtc_symbols,\n    POLONIEX: poloniex_symbols,\n    PROBIT: probit_symbols,\n    BITSTAMP: bitstamp_symbols,\n    KRAKEN: kraken_symbols,\n    KRAKEN + 'REST': kraken_rest_symbols,\n    BINANCE: binance_symbols,\n    BINANCE_US: binance_us_symbols,\n    BINANCE_FUTURES: binance_futures_symbols,\n    BINANCE_DELIVERY: binance_delivery_symbols,\n    BLOCKCHAIN: blockchain_symbols,\n    EXX: exx_symbols,\n    HUOBI: huobi_symbols,\n    HUOBI_DM: huobi_dm_symbols,\n    HUOBI_SWAP: huobi_swap_symbols,\n    OKCOIN: okcoin_symbols,\n    OKEX: okex_symbols,\n    BYBIT: bybit_symbols,\n    FTX: ftx_symbols,\n    FTX_US: ftx_us_symbols,\n    BITTREX: bittrex_symbols,\n    BITCOINCOM: bitcoincom_symbols,\n    BITMAX: bitmax_symbols,\n    UPBIT: upbit_symbols,\n    GATEIO: gateio_symbols,\n    BITMEX: bitmex_symbols,\n    DERIBIT: deribit_symbols,\n    KRAKEN_FUTURES: kraken_future_symbols,\n    COINGECKO: coingecko_symbols,\n    WHALE_ALERT: whale_alert_coins\n}\n",
        "target_code_with_indent": "\nfrom typing import Dict, Tuple\n\n\nclass _Symbols:\n    <IND>def __init__(self):\n        <IND>self.data = {}\n\n    <DED>def set(self, exchange: str, normalized: dict, exchange_info: dict):\n        <IND>self.data[exchange] = {}\n        self.data[exchange]['normalized'] = normalized\n        self.data[exchange]['info'] = exchange_info\n\n    <DED>def get(self, exchange: str) -> Tuple[Dict, Dict]:\n        <IND>return self.data[exchange]['normalized'], self.data[exchange]['info']\n\n    <DED>def populated(self, exchange: str) -> bool:\n        <IND>return exchange in self.data\n\n\n<DED><DED>Symbols = _Symbols()\n"
      }
    ]
  },
  {
    "project": "bmoscon/cryptofeed",
    "commit": "3525dc8ce4d7836a9abaaa5662e58e5e27969a77",
    "filename": "cryptofeed/symbols.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/bmoscon-cryptofeed/cryptofeed/symbols.py",
    "file_hunks_size": 1,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "cryptofeed/symbols.py:385:8 Incompatible return type [7]: Expected `Dict[str, str]` but got implicit return value of `None`.",
    "message": " Expected `Dict[str, str]` but got implicit return value of `None`.",
    "rule_id": "Incompatible return type [7]",
    "warning_line_no": 385,
    "warning_line": "        raise_failure_explanation('HUOBI_SWAP', why, {\"\": r})",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "associated with this software.\n\n\nSymbol generation code for exchanges\n'''\n\nimport logging\nimport string\nimport time\nfrom collections import defaultdict\nfrom typing import Dict, List, Optional, Tuple\n\nimport requests\nfrom requests import Response\n\nfrom cryptofeed.defines import *\n\n\nLOG = logging.getLogger('feedhandler')\n\nSYMBOL_SEP = '-'\n\n_symbols_retrieval_cache: Dict[str, Dict[str, str]] = {}\n_exchange_info = defaultdict(lambda: defaultdict(dict))\n\n\n_kraken_futures_product_type = {\n    'FI': 'Inverse Futures',\n    'FV': 'Vanilla Futures',\n    'PI': 'Perpetual Inverse Futures',\n    'PV': 'Perpetual Vanilla Futures',\n    'IN': 'Real Time Index',\n    'RR': 'Reference Rate',\n}\n\n\ndef raise_failure_explanation(feed_id: str, exception: BaseException, responses: Dict[str, Optional[Response]]):\n    LOG.critical('%s: encountered %r while processing response from exchange API', feed_id, exception)\n    if len(responses) > 1:\n        LOG.critical('%s: content of one of the %s responses was unexpected', feed_id, len(responses))\n    for url, r in responses.items():\n        if url:\n            LOG.critical('%s: requested URL: %s', feed_id, url)\n        if r:\n            LOG.critical('%s: unexpected response: %s', feed_id, r.text)\n    raise ValueError(f'Cryptofeed stopped because of an unexpected response from {feed_id}') from exception\n\n\ndef set_symbol_separator(separator: str):\n    global SYMBOL_SEP\n    SYMBOL_SEP = separator\n\n\ndef get_symbol_separator() -> str:\n    global SYMBOL_SEP\n    return SYMBOL_SEP\n\n\ndef gen_symbols(exchange: str, key_id=None) -> Dict[str, str]:\n    if exchange not in _symbols_retrieval_cache:\n        LOG.info(\"%s: Getting list of symbols\", exchange)\n        symbols = _exchange_function_map[exchange](key_id) if key_id else _exchange_function_map[exchange]()\n        LOG.info(\"%s: %s symbols\", exchange, len(symbols))\n\n        # log all retrieved symbols using debug level\n        for normalized, exch_sym in sorted(symbols.items()):\n            LOG.debug('%s: id-from-exch -> normalized: %-35s-> %s', exchange, exch_sym, normalized)\n\n        _symbols_retrieval_cache[exchange] = symbols\n    return _symbols_retrieval_cache[exchange]\n\n\ndef _binance_symbols(endpoint: str, exchange: str):\n    r = None\n    try:\n        ret = {}\n        r = requests.get(endpoint)\n        for symbol in r.json()['symbols']:\n            if symbol.get('status', 'TRADING') != \"TRADING\":\n                continue\n            if symbol.get('contractStatus', 'TRADING') != \"TRADING\":\n                continue\n            split = len(symbol['baseAsset'])\n            normalized = symbol['symbol'][:split] + SYMBOL_SEP + symbol['symbol'][split:]\n            ret[normalized] = symbol['symbol']\n            _exchange_info[exchange]['tick_size'][normalized] = symbol['filters'][0]['tickSize']\n            if \"contractType\" in symbol:\n                _exchange_info[exchange]['contract_type'][normalized] = symbol['contractType']\n        return ret\n    except Exception as why:\n        raise_failure_explanation(exchange, why, {endpoint: r})\n\n\ndef binance_symbols() -> Dict[str, str]:\n    return _binance_symbols('https://api.binance.com/api/v3/exchangeInfo', BINANCE)\n\n\ndef binance_us_symbols() -> Dict[str, str]:\n    return _binance_symbols('https://api.binance.us/api/v3/exchangeInfo', BINANCE_US)\n\n\ndef binance_futures_symbols() -> Dict[str, str]:\n    base = _binance_symbols('https://fapi.binance.com/fapi/v1/exchangeInfo', BINANCE_FUTURES)\n    add = {}\n    for symbol, orig in base.items():\n        if \"_\" in orig:\n            continue\n        add[f\"{symbol}-PINDEX\"] = f\"p{orig}\"\n    base.update(add)\n    return base\n\n\ndef binance_delivery_symbols() -> Dict[str, str]:\n    return _binance_symbols('https://dapi.binance.com/dapi/v1/exchangeInfo', BINANCE_DELIVERY)\n\n\ndef bitfinex_symbols() -> Dict[str, str]:\n    # doc: https://docs.bitfinex.com/docs/ws-general#supported-pairs\n    r1 = r2 = None\n    try:\n        r1 = requests.get('https://api.bitfinex.com/v2/tickers?symbols=ALL')\n        r2 = requests.get('https://api-pub.bitfinex.com/v2/conf/pub:map:currency:sym')\n        tickers: List[List[str]] = r1.json()\n        norm: List[Tuple[str, str]] = r2.json()[0]\n        norm: Dict[str, str] = dict(norm)\n        for k, v in dict(norm).items():\n            if k[-2:] == 'F0' or '-' in v:  # Do not convert BTCF0 -> BTC or PBTCETH -> PBTC-ETH\n                del norm[k]\n        norm['BCHN'] = 'BCH'  # Bitfinex uses BCHN, other exchanges use BCH\n\n        ret = {}\n        for symbol in [t[0] for t in tickers]:\n            if symbol[0] == 'f':\n                normalized = norm.get(symbol[1:], symbol[1:])\n            else:\n                if len(symbol) == 7:\n                    base, quote = symbol[1:4], symbol[4:]\n                else:\n                    base, quote = symbol[1:].split(':')\n                    assert ':' in symbol\n                normalized = norm.get(base, base) + SYMBOL_SEP + norm.get(quote, quote)\n            ret[normalized.upper()] = symbol\n        return ret\n    except ValueError as why:\n        raise_failure_explanation('BITFINEX', why, {\"tickers?symbols=ALL\": r1, \"pub:map:currency:sym\": r2})\n\n\ndef bitflyer_symbols() -> Dict[str, str]:\n    endpoint = r = None\n    try:\n        ret = {}\n        endpoints = ['https://api.bitflyer.com/v1/getmarkets/eu', 'https://api.bitflyer.com/v1/getmarkets/usa', 'https://api.bitflyer.com/v1/getmarkets']\n        for endpoint in endpoints:\n            r = requests.get(endpoint)\n            for entry in r.json():\n                normalized = entry['product_code'].replace(\"_\", SYMBOL_SEP)\n                ret[normalized] = entry['product_code']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('BITFLYER', why, {endpoint: r})\n\n\ndef bybit_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.bybit.com/v2/public/symbols')\n        ret = {}\n        for symbol in r.json()['result']:\n            quote = symbol['quote_currency']\n            if not symbol['name'].endswith(quote):\n                base, contract = symbol['name'].split(quote)\n                normalized = f\"{base}{SYMBOL_SEP}{quote}-{contract}\"\n            else:\n                normalized = f\"{symbol['base_currency']}{SYMBOL_SEP}{quote}\"\n            ret[normalized] = symbol['name']\n            _exchange_info[BYBIT]['tick_size'][normalized] = symbol['price_filter']['tick_size']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('BYBIT', why, {\"\": r})\n\n\ndef _ftx_helper(endpoint: str, exchange: str):\n    r = None\n    try:\n        r = requests.get(endpoint)\n        ret = {}\n        for data in r.json()['result']:\n            normalized = data['name'].replace(\"/\", SYMBOL_SEP)\n            symbol = data['name']\n            ret[normalized] = symbol\n            _exchange_info[exchange]['tick_size'][normalized] = data['priceIncrement']\n        return ret\n    except Exception as why:\n        raise_failure_explanation(exchange, why, {endpoint: r})\n\n\ndef ftx_symbols() -> Dict[str, str]:\n    return _ftx_helper('https://ftx.com/api/markets', FTX)\n\n\ndef ftx_us_symbols() -> Dict[str, str]:\n    return _ftx_helper('https://ftx.us/api/markets', FTX_US)\n\n\ndef coinbase_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.pro.coinbase.com/products')\n        ret = {}\n        for data in r.json():\n            normalized = data['id'].replace(\"-\", SYMBOL_SEP)\n            ret[normalized] = data['id']\n            _exchange_info[COINBASE]['tick_size'][normalized] = data['quote_increment']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('COINBASE', why, {\"\": r})\n\n\ndef gemini_symbols(*args) -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.gemini.com/v1/symbols')\n        ret = {}\n        for symbol in r.json():\n            std = f\"{symbol[:-3]}{SYMBOL_SEP}{symbol[-3:]}\"\n            std = std.upper()\n            ret[std] = symbol.upper()\n        return ret\n    except Exception as why:\n        raise_failure_explanation('GEMINI', why, {\"\": r})\n\n\ndef hitbtc_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        ret = {}\n        r = requests.get('https://api.hitbtc.com/api/2/public/symbol')\n        for symbol in r.json():\n            split = len(symbol['baseCurrency'])\n            normalized = symbol['id'][:split] + SYMBOL_SEP + symbol['id'][split:]\n            ret[normalized] = symbol['id']\n            _exchange_info[HITBTC]['tick_size'][normalized] = symbol['tickSize']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('HITBTC', why, {\"\": r})\n\n\ndef poloniex_id_symbol_mapping():\n    r = None\n    try:\n        r = requests.get('https://poloniex.com/public?command=returnTicker')\n        symbols = r.json()\n        ret = {}\n        for symbol in symbols:\n            ret[symbols[symbol]['id']] = symbol\n        return ret\n    except Exception as why:\n        raise_failure_explanation('POLONIEX', why, {\"\": r})\n\n\ndef poloniex_symbols() -> Dict[str, str]:\n    ret = {}\n    for _, value in poloniex_id_symbol_mapping().items():\n        std = value.replace(\"STR\", \"XLM\")\n        quote, base = std.split(\"_\")\n        ret[quote + SYMBOL_SEP + base] = value\n    return ret\n\n\ndef bitstamp_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://www.bitstamp.net/api/v2/trading-pairs-info/')\n        ret = {}\n        for data in r.json():\n            normalized = data['name'].replace(\"/\", SYMBOL_SEP)\n            symbol = data['url_symbol']\n            ret[normalized] = symbol\n        return ret\n    except Exception as why:\n        raise_failure_explanation('BITSTAMP', why, {\"\": r})\n\n\ndef kraken_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.kraken.com/0/public/AssetPairs')\n        data = r.json()\n        ret = {}\n        for symbol in data['result']:\n            if 'wsname' not in data['result'][symbol] or '.d' in symbol:\n                # https://blog.kraken.com/post/259/introducing-the-kraken-dark-pool/\n                # .d is for dark pool symbols\n                continue\n\n            base, quote = data['result'][symbol]['wsname'].split(\"/\")\n\n            normalized = f\"{base}{SYMBOL_SEP}{quote}\"\n            exch = data['result'][symbol]['wsname']\n            normalized = normalized.replace('XBT', 'BTC')\n            normalized = normalized.replace('XDG', 'DOG')\n            ret[normalized] = exch\n        return ret\n    except Exception as why:\n        raise_failure_explanation('KRAKEN', why, {\"\": r})\n\n\ndef kraken_rest_symbols() -> Dict[str, str]:\n    return {normalized: exchange.replace(\"/\", \"\") for normalized, exchange in kraken_symbols().items()}\n\n\ndef exx_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.exx.com/data/v1/tickers')\n        exchange = [key.upper() for key in r.json().keys()]\n        symbols = [key.replace(\"_\", SYMBOL_SEP) for key in exchange]\n        return dict(zip(symbols, exchange))\n    except Exception as why:\n        raise_failure_explanation('EXX', why, {\"\": r})\n\n\ndef huobi_common_symbols(url: str):\n    r = None\n    try:\n        r = requests.get(url)\n        ret = {}\n        for e in r.json()['data']:\n            if e['state'] == 'offline':\n                continue\n            normalized = f\"{e['base-currency'].upper()}{SYMBOL_SEP}{e['quote-currency'].upper()}\"\n            symbol = f\"{e['base-currency']}{e['quote-currency']}\"\n            ret[normalized] = symbol\n        return ret\n    except Exception as why:\n        raise_failure_explanation('HUOBI', why, {url: r})\n\n\ndef huobi_symbols() -> Dict[str, str]:\n    return huobi_common_symbols('https://api.huobi.pro/v1/common/symbols')\n\n\ndef huobi_us_symbols() -> Dict[str, str]:\n    return huobi_common_symbols('https://api.huobi.com/v1/common/symbols')\n\n\ndef huobi_dm_symbols() -> Dict[str, str]:\n    \"\"\"\n    Mapping is, for instance: {\"BTC_CW\":\"BTC190816\"}\n    See comments in exchange/huobi_dm.py\n    \"\"\"\n    mapping = {\n        \"this_week\": \"CW\",\n        \"next_week\": \"NW\",\n        \"quarter\": \"CQ\",\n        \"next_quarter\": \"NQ\"\n    }\n    r = None\n    try:\n        r = requests.get('https://www.hbdm.com/api/v1/contract_contract_info')\n        symbols = {}\n        for e in r.json()['data']:\n            symbols[f\"{e['symbol']}_{mapping[e['contract_type']]}\"] = e['contract_code']\n            _exchange_info[HUOBI_DM]['tick_size'][e['contract_code']] = e['price_tick']\n            _exchange_info[HUOBI_DM]['short_code_mappings'][f\"{e['symbol']}_{mapping[e['contract_type']]}\"] = e['contract_code']\n        return symbols\n    except Exception as why:\n        raise_failure_explanation('HUOBI_DM', why, {\"\": r})\n\n\ndef huobi_swap_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.hbdm.com/swap-api/v1/swap_contract_info')\n        symbols = {}\n        for e in r.json()['data']:\n            symbols[e['contract_code']] = e['contract_code']\n            _exchange_info[HUOBI_SWAP]['tick_size'][e['contract_code']] = e['price_tick']\n        return symbols\n    except Exception as why:\n        raise_failure_explanation('HUOBI_SWAP', why, {\"\": r})\n\n\ndef okcoin_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://www.okcoin.com/api/spot/v3/instruments')\n        ret = {}\n        for e in r.json():\n            ret[e['instrument_id']] = e['instrument_id']\n            _exchange_info[OKCOIN]['tick_size'][e['instrument_id']] = e['tick_size']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('OKCOIN', why, {\"\": r})\n\n\ndef okex_symbols(*args) -> Dict[str, str]:\n    urls = ['https://www.okex.com/api/spot/v3/instruments',\n            'https://www.okex.com/api/swap/v3/instruments',\n            'https://www.okex.com/api/futures/v3/instruments']\n    urls = urls + okex_compute_option_urls_from_underlyings()\n\n    symbols: Dict[str, str] = {}\n    for u in urls:\n        time.sleep(0.2)\n        symbols.update(okex_symbols_from_one_url(u))\n\n    for symbol in symbols:\n        instrument_type = 'futures'\n        dash_count = symbol.count(get_symbol_separator())\n        if dash_count == 1:  # BTC-USDT\n            instrument_type = 'spot'\n        if dash_count == 4:  # BTC-USD-201225-35000-P\n            instrument_type = 'option'\n        if symbol[-4:] == \"SWAP\":  # BTC-USDT-SWAP\n            instrument_type = 'swap'\n\n        _exchange_info[OKEX]['instrument_type'][symbol] = instrument_type\n\n    return symbols\n\n\ndef okex_compute_option_urls_from_underlyings() -> List[str]:\n    url = 'https://www.okex.com/api/option/v3/underlying'\n    r = None\n    try:\n        r = requests.get(url)\n        return [f'https://www.okex.com/api/option/v3/instruments/{underlying}' for underlying in r.json()]\n    except Exception as why:\n        raise_failure_explanation('OKEX', why, {url: r})\n\n\ndef okex_symbols_from_one_url(url: str) -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get(url)\n        ret = {}\n        for e in r.json():\n            ret[e['instrument_id']] = e['instrument_id']\n            _exchange_info[OKEX]['tick_size'][e['instrument_id']] = e['tick_size']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('OKEX', why, {url: r})\n\n\ndef bittrex_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.bittrex.com/api/v1.1/public/getmarkets')\n        r = r.json()['result']\n        return {f\"{e['MarketCurrency']}{SYMBOL_SEP}{e['BaseCurrency']}\": e['MarketName'] for e in r if e['IsActive']}\n    except Exception as why:\n        raise_failure_explanation('BITTREX', why, {\"\": r})\n\n\ndef bitcoincom_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.exchange.bitcoin.com/api/2/public/symbol')\n        return {f\"{data['baseCurrency']}{SYMBOL_SEP}{data['quoteCurrency'].replace('USD', 'USDT')}\": data['id'] for data in r.json()}\n    except Exception as why:\n        raise_failure_explanation('BITCOINCOM', why, {\"\": r})\n\n\ndef bitmax_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://bitmax.io/api/pro/v1/products')\n        ret = {}\n        for entry in r.json()['data']:\n            # Only \"Normal\" status symbols are tradeable\n            if entry['status'] == 'Normal':\n                normalized = f\"{entry['baseAsset']}{SYMBOL_SEP}{entry['quoteAsset']}\"\n                ret[normalized] = entry['symbol']\n                _exchange_info[BITMAX]['tick_size'][normalized] = entry['tickSize']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('BITMAX', why, {\"\": r})\n\n\ndef upbit_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.upbit.com/v1/market/all')\n        return {f\"{data['market'].split('-')[1]}{SYMBOL_SEP}{data['market'].split('-')[0]}\": data['market'] for data in r.json()}\n    except Exception as why:\n        raise_failure_explanation('UPBIT', why, {\"\": r})\n\n\ndef blockchain_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get(\"https://api.blockchain.com/mercury-gateway/v1/instruments\")\n        return {data[\"symbol\"].replace(\"-\", SYMBOL_SEP): data[\"symbol\"] for data in r.json()}\n    except Exception as why:\n        raise_failure_explanation('BLOCKCHAIN', why, {\"\": r})\n\n\ndef gateio_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get(\"https://api.gateio.ws/api/v4/spot/currency_pairs\")\n        return {data[\"id\"].replace(\"_\", SYMBOL_SEP): data['id'] for data in r.json()}\n    except Exception as why:\n        raise_failure_explanation('GATEIO', why, {\"\": r})\n\n\ndef bitmex_symbols() -> Dict[str, str]:\n    r = None\n    ret = {}\n    try:\n        r = requests.get(\"https://www.bitmex.com/api/v1/instrument/active\")\n        for entry in r.json():\n            components = []\n            components.append(entry['rootSymbol'])\n            components.append(entry['quoteCurrency'])\n\n            if entry['expiry']:\n                components.append(entry['symbol'][-3:])\n\n            normalized = SYMBOL_SEP.join(components)\n            normalized = normalized.replace(\"XBT\", \"BTC\")\n            ret[normalized] = entry['symbol']\n            _exchange_info[BITMEX]['tick_size'][normalized] = entry['tickSize']\n\n            if entry['expiry']:\n                _exchange_info[BITMEX]['expiry'][normalized] = entry['expiry']\n\n        return ret\n    except Exception as why:\n        raise_failure_explanation('BITMEX', why, {\"\": r})\n\n\ndef deribit_symbols() -> Dict[str, str]:\n    url = r = None\n    ret = {}\n    try:\n        # TODO: get currencies from https://www.deribit.com/api/v2/public/get_currencies\n        currencies = ['BTC', 'ETH']\n        for c in currencies:\n            url = f\"https://www.deribit.com/api/v2/public/get_instruments?currency={c}&expired=false\"\n            r = requests.get(url)\n            for entry in r.json()['result']:\n                split = entry['instrument_name'].split(\"-\")\n                normalized = split[0] + SYMBOL_SEP + entry['quote_currency'] + \"-\" + '-'.join(split[1:])\n                ret[normalized] = entry['instrument_name']\n                _exchange_info[DERIBIT]['tick_size'][normalized] = entry['tick_size']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('DERIBIT', why, {url: r})\n\n\ndef kraken_future_symbols() -> Dict[str, str]:\n    r = None\n    ret = {}\n    try:\n        r = requests.get('https://futures.kraken.com/derivatives/api/v3/instruments')\n        data = r.json()['instruments']\n        for entry in data:\n            if not entry['tradeable']:\n                continue\n            normalized = entry['symbol'].upper().replace(\"_\", \"-\")\n            symbol = normalized[3:6] + SYMBOL_SEP + normalized[6:9]\n            normalized = normalized.replace(normalized[3:9], symbol)\n            normalized = normalized.replace('XBT', 'BTC')\n\n            _exchange_info[KRAKEN_FUTURES]['tick_size'][normalized] = entry['tickSize']\n            _exchange_info[KRAKEN_FUTURES]['contract_size'][normalized] = entry['contractSize']\n            _exchange_info[KRAKEN_FUTURES]['underlying'][normalized] = entry['underlying']\n            _exchange_info[KRAKEN_FUTURES]['product_type'][normalized] = _kraken_futures_product_type[normalized[:2]]\n            ret[normalized] = entry['symbol']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('KRAKEN_FUTURES', why, {\"\": r})\n\n\ndef probit_symbols() -> Dict[str, str]:\n    # doc: https://docs-en.probit.com/reference-link/market\n    r = None\n    try:\n        r = requests.get('https://api.probit.com/api/exchange/v1/market')\n        return {entry['id']: entry['id'] for entry in r.json()['data']}\n    except Exception as why:\n        raise_failure_explanation('PROBIT', why, {\"\": r})\n\n\ndef coingecko_normalize_symbol(symbol: str) -> str:\n    # keep digits, letters and dots, replace others by space\n    symbol = ''.join(c if c.isalnum() or c in ('.', '+') else ' ' for c in symbol)\n    return coingecko_normalize(symbol.upper())\n\n\ndef coingecko_normalize_name(name: str) -> str:\n    # keep digits and letters, replace others by space (except when only composed by upper case letters, digits and dots)\n    if not all(c.isupper() or c.isdigit() or c == '.' for c in name):\n        name = ''.join(c if c.isalnum() else ' ' for c in name)\n    return coingecko_normalize(name)\n\n\ndef coingecko_normalize(sym: str) -> str:\n    sym = sym.strip()\n    # do not concatenate numbers => separate them with a dot\n    sym = list(sym)\n    if len(sym) > 4:\n        for i in range(2, len(sym) - 1):\n            if sym[i] == ' ' and sym[i - 1].isdigit() and sym[i + 1].isdigit():\n                sym[i] = '.'\n    sym = ''.join(sym)\n    # concatenate space-separated words => use CamelCase to distinguish the words\n    if ' ' in sym:\n        if sum(c.islower() for c in sym):  # if there is at least one lower case letter\n            sym = ' '.join(word[0].upper() + word[1:] for word in sym.split())  # Just capitalize initial letter of each word\n        else:  # CoinGecko may provide full upper-case as for \"THE STONE COIN\"\n            sym = string.capwords(sym)  # capwords converts \"THE STONE COIN\" to \"The Stone Coin\"\n        sym = sym.replace(' ', '')  # concatenate words\n    return sym\n\n\ndef is_name_short(coin: dict) -> bool:\n    \"\"\"return True if the coin name is enough short compared to the coin symbol.\"\"\"\n    return len(coin['name']) <= max(5, len(coin['symbol']) + 1)\n\n\ndef has_many_caps(name: str) -> bool:\n    \"\"\"return True if the symbol contains enough upper case letters, False if empty.\"\"\"\n    return str and sum(c.islower() for c in name) < (len(name) / 2)\n\n\ndef coingecko_normalize_all(coin: dict):\n    SYMBOL_TO_NORMALIZED = {'miota': 'IOTA'}\n    normalized = SYMBOL_TO_NORMALIZED.get(coin['symbol'])\n    if normalized:\n        coin['ns'] = coin['nn'] = normalized\n        return normalized\n\n    # ns = normalized symbol, nn = normalized name\n    coin['ns'] = coingecko_normalize_symbol(coin['symbol'])\n\n    ID_SUFFIX = '-bitcoin-token'\n    if coin['id'][-len(ID_SUFFIX):] == ID_SUFFIX:\n        coin['nn'] = 'BTC' + coin['ns']\n        return coin['nn']\n\n    name = coin['name']\n\n    prefixes = ('The ', 'the ')\n    for p in prefixes:\n        if name[:len(p)] == p:\n            coin['reduced-name'] = True\n            name = name[len(p):]\n            break\n\n    suffixes = ('coin', 'coins', 'money', 'finance', 'protocol', 'reward', 'rewards', 'token')\n    for s in suffixes:\n        if len(name) > len(s) and name[-len(s):].lower() == s:\n            # but keep suffix when lower-case concatenated\n            if name[-len(s)].islower() and name[-len(s) - 1] != ' ':\n                continue\n            # also keep suffix to avoid confusing nam: \"Bitcoin Token\" -> \"Bitcoin\"\n            if name[:-len(s)].strip().lower() == 'bitcoin':\n                continue\n            coin['reduced-name'] = True\n            name = name[:-len(s)]\n            break\n\n    coin['nn'] = coingecko_normalize_name(name)\n\n    if len(coin['nn']) < len(coin['ns']):\n        if 'reduced-name' in coin:\n            coin['reduced-name'] = False\n            name = coin['name']\n            coin['nn'] = coingecko_normalize_name(name)\n        elif not has_many_caps(name):\n            return coin['ns']\n\n    if not coin['ns']:  # coin['symbol'] may be an emoji that is striped when normalized\n        return coin['nn']\n\n    if coin.get('reduced-name') and coin['ns'].upper() != coin['nn'].upper():\n        return coin['ns']\n\n    i = coin['nn'].find('.')  # if there is a dot in normalized name => prefer the normalized symbol\n    if i >= 0:\n        if i > 1 and coin['nn'][i - 1].isdigit() and coin['nn'][i + 1].isdigit():\n            pass  # except when the dot separates digits\n        else:\n            return coin['ns']\n\n    if is_name_short(coin) and has_many_caps(name):\n        return coin['nn']\n\n    if 1.5 * len(coin['ns']) > len(coin['nn']) and any(c.islower() for c in coin['ns']):\n        return coin['nn']\n\n    return coin['ns']\n\n\ndef coingecko_symbols() -> Dict[str, str]:\n    r = None\n    intermediate = defaultdict(list)\n    try:\n        r = requests.get('https://api.coingecko.com/api/v3/coins/list')\n        all_coins = r.json()\n        # First pass: generate & compare normalized symbol/name, and then select the most pertinent\n        for coin in all_coins:\n            normalized = coingecko_normalize_all(coin)\n            intermediate[normalized].append(coin)\n            # Above line keeps together the coins having the same normalized symbol.\n            # To reduce collision, the coin['name'] is sometimes used in lieu of the coin['symbol'].\n            # The coin['name'] is not capitalized because lower case letters may be meaningful: cETH, yUSD, DATx, zLOT\n    except Exception as why:\n        raise_failure_explanation('COINGECKO', why, {\"\": r})\n\n    final = coingecko_second_pass(intermediate)\n    return coingecko_third_pass(final)\n\n\ndef coingecko_second_pass(intermediate: Dict[str, List[dict]]) -> Dict[str, List[dict]]:\n    # Second pass: fixes most of the symbol collisions\n    final = defaultdict(list)\n    for normalized, coins in intermediate.items():\n        if len(coins) == 1:\n            final[normalized].append(coins[0])\n            continue\n        set_normalized = False\n        for i in range(len(coins)):\n            if normalized == coins[i]['nn']:\n                coin = coins.pop(i)\n                final[normalized].append(coin)\n                set_normalized = True\n                break\n        rest: List[dict] = []\n        for coin in coins:\n            if '%' in coin['name']:\n                if len(coins) == 1:\n                    n = coin['ns']\n                else:\n                    n = coingecko_normalize_name(coin['id'])\n                final[n].append(coin)\n            else:\n                rest.append(coin)\n        if not rest:\n            continue\n        if not set_normalized:\n            rest.sort(key=lambda coin: len(coin['nn']), reverse=True)  # sort by the length of the normalized name\n            coin = rest.pop(0)\n            final[normalized].append(coin)\n        for coin in rest:\n            if coin['nn'] not in intermediate:\n                n = coin['nn']\n            elif coin.get('reduced-name'):\n                n = coingecko_normalize_name(coin['name'])\n            else:\n                n = coingecko_normalize_name(coin['id'])\n            final[n].append(coin)\n    return final\n\n\ndef coingecko_third_pass(final: Dict[str, List[dict]]) -> Dict[str, str]:\n    # Third pass: fixes some remaining collisions and fills the result\n    symbols = {}\n    for normalized, coins in final.items():\n        if len(coins) == 1:\n            symbols[normalized] = coins[0]['id']\n            continue\n        set_normalized = False\n        for i in range(len(coins)):\n            if normalized == coins[i]['nn']:\n                coin = coins.pop(i)\n                symbols[normalized] = coin['id']\n                set_normalized = True\n                break\n        rest: List[dict] = []\n        for coin in coins:\n            if '%' in coin['name']:\n                if len(coins) == 1:\n                    n = coin['ns']\n                else:\n                    n = coingecko_normalize_name(coin['id'])\n                symbols[n] = coin['id']\n            else:\n                rest.append(coin)\n        if not rest:\n            continue\n        if not set_normalized:\n            rest.sort(key=lambda coin: len(coin['nn']), reverse=True)  # sort by the length of the normalized name\n            coin = rest.pop(0)\n            symbols[normalized] = coin['id']\n        for coin in rest:\n            if coin['nn'] not in final:\n                n = coin['nn']\n            elif coin.get('reduced-name'):\n                n = coingecko_normalize_name(coin['name'])\n            else:\n                n = coingecko_normalize_name(coin['id'])\n            symbols[n] = coin['id']\n    return symbols\n\n\ndef whale_alert_coins(key_id: str) -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get(f'https://api.whale-alert.io/v1/status?api_key={key_id}')\n        # Same symbols, but on different blockchains (for instance USDT), are naturally overwritten.\n        return {s.upper(): s for b in r.json()['blockchains'] for s in b['symbols'] if s}\n    except Exception as why:\n        raise_failure_explanation('WHALES_ALERT', why, {\"\": r})\n\n\n_exchange_function_map = {\n    BITFINEX: bitfinex_symbols,\n    BITFLYER: bitflyer_symbols,\n    COINBASE: coinbase_symbols,\n    GEMINI: gemini_symbols,\n    HITBTC: hitbtc_symbols,\n    POLONIEX: poloniex_symbols,\n    PROBIT: probit_symbols,\n    BITSTAMP: bitstamp_symbols,\n    KRAKEN: kraken_symbols,\n    KRAKEN + 'REST': kraken_rest_symbols,\n    BINANCE: binance_symbols,\n    BINANCE_US: binance_us_symbols,\n    BINANCE_FUTURES: binance_futures_symbols,\n    BINANCE_DELIVERY: binance_delivery_symbols,\n    BLOCKCHAIN: blockchain_symbols,\n    EXX: exx_symbols,\n    HUOBI: huobi_symbols,\n    HUOBI_DM: huobi_dm_symbols,\n    HUOBI_SWAP: huobi_swap_symbols,\n    OKCOIN: okcoin_symbols,\n    OKEX: okex_symbols,\n    BYBIT: bybit_symbols,\n    FTX: ftx_symbols,\n    FTX_US: ftx_us_symbols,\n    BITTREX: bittrex_symbols,\n    BITCOINCOM: bitcoincom_symbols,\n    BITMAX: bitmax_symbols,\n    UPBIT: upbit_symbols,\n    GATEIO: gateio_symbols,\n    BITMEX: bitmex_symbols,\n    DERIBIT: deribit_symbols,\n    KRAKEN_FUTURES: kraken_future_symbols,\n    COINGECKO: coingecko_symbols,\n    WHALE_ALERT: whale_alert_coins\n}\n",
        "source_code_len": 30534,
        "target_code": "associated with this software.\n'''\nfrom typing import Dict, Tuple\n\n\nclass _Symbols:\n    def __init__(self):\n        self.data = {}\n\n    def set(self, exchange: str, normalized: dict, exchange_info: dict):\n        self.data[exchange] = {}\n        self.data[exchange]['normalized'] = normalized\n        self.data[exchange]['info'] = exchange_info\n\n    def get(self, exchange: str) -> Tuple[Dict, Dict]:\n        return self.data[exchange]['normalized'], self.data[exchange]['info']\n\n    def populated(self, exchange: str) -> bool:\n        return exchange in self.data\n\n\nSymbols = _Symbols()\n",
        "target_code_len": 588,
        "diff_format": "@@ -5,845 +5,22 @@\n associated with this software.\n+'''\n+from typing import Dict, Tuple\n \n \n-Symbol generation code for exchanges\n-'''\n+class _Symbols:\n+    def __init__(self):\n+        self.data = {}\n \n-import logging\n-import string\n-import time\n-from collections import defaultdict\n-from typing import Dict, List, Optional, Tuple\n+    def set(self, exchange: str, normalized: dict, exchange_info: dict):\n+        self.data[exchange] = {}\n+        self.data[exchange]['normalized'] = normalized\n+        self.data[exchange]['info'] = exchange_info\n \n-import requests\n-from requests import Response\n+    def get(self, exchange: str) -> Tuple[Dict, Dict]:\n+        return self.data[exchange]['normalized'], self.data[exchange]['info']\n \n-from cryptofeed.defines import *\n+    def populated(self, exchange: str) -> bool:\n+        return exchange in self.data\n \n \n-LOG = logging.getLogger('feedhandler')\n-\n-SYMBOL_SEP = '-'\n-\n-_symbols_retrieval_cache: Dict[str, Dict[str, str]] = {}\n-_exchange_info = defaultdict(lambda: defaultdict(dict))\n-\n-\n-_kraken_futures_product_type = {\n-    'FI': 'Inverse Futures',\n-    'FV': 'Vanilla Futures',\n-    'PI': 'Perpetual Inverse Futures',\n-    'PV': 'Perpetual Vanilla Futures',\n-    'IN': 'Real Time Index',\n-    'RR': 'Reference Rate',\n-}\n-\n-\n-def raise_failure_explanation(feed_id: str, exception: BaseException, responses: Dict[str, Optional[Response]]):\n-    LOG.critical('%s: encountered %r while processing response from exchange API', feed_id, exception)\n-    if len(responses) > 1:\n-        LOG.critical('%s: content of one of the %s responses was unexpected', feed_id, len(responses))\n-    for url, r in responses.items():\n-        if url:\n-            LOG.critical('%s: requested URL: %s', feed_id, url)\n-        if r:\n-            LOG.critical('%s: unexpected response: %s', feed_id, r.text)\n-    raise ValueError(f'Cryptofeed stopped because of an unexpected response from {feed_id}') from exception\n-\n-\n-def set_symbol_separator(separator: str):\n-    global SYMBOL_SEP\n-    SYMBOL_SEP = separator\n-\n-\n-def get_symbol_separator() -> str:\n-    global SYMBOL_SEP\n-    return SYMBOL_SEP\n-\n-\n-def gen_symbols(exchange: str, key_id=None) -> Dict[str, str]:\n-    if exchange not in _symbols_retrieval_cache:\n-        LOG.info(\"%s: Getting list of symbols\", exchange)\n-        symbols = _exchange_function_map[exchange](key_id) if key_id else _exchange_function_map[exchange]()\n-        LOG.info(\"%s: %s symbols\", exchange, len(symbols))\n-\n-        # log all retrieved symbols using debug level\n-        for normalized, exch_sym in sorted(symbols.items()):\n-            LOG.debug('%s: id-from-exch -> normalized: %-35s-> %s', exchange, exch_sym, normalized)\n-\n-        _symbols_retrieval_cache[exchange] = symbols\n-    return _symbols_retrieval_cache[exchange]\n-\n-\n-def _binance_symbols(endpoint: str, exchange: str):\n-    r = None\n-    try:\n-        ret = {}\n-        r = requests.get(endpoint)\n-        for symbol in r.json()['symbols']:\n-            if symbol.get('status', 'TRADING') != \"TRADING\":\n-                continue\n-            if symbol.get('contractStatus', 'TRADING') != \"TRADING\":\n-                continue\n-            split = len(symbol['baseAsset'])\n-            normalized = symbol['symbol'][:split] + SYMBOL_SEP + symbol['symbol'][split:]\n-            ret[normalized] = symbol['symbol']\n-            _exchange_info[exchange]['tick_size'][normalized] = symbol['filters'][0]['tickSize']\n-            if \"contractType\" in symbol:\n-                _exchange_info[exchange]['contract_type'][normalized] = symbol['contractType']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation(exchange, why, {endpoint: r})\n-\n-\n-def binance_symbols() -> Dict[str, str]:\n-    return _binance_symbols('https://api.binance.com/api/v3/exchangeInfo', BINANCE)\n-\n-\n-def binance_us_symbols() -> Dict[str, str]:\n-    return _binance_symbols('https://api.binance.us/api/v3/exchangeInfo', BINANCE_US)\n-\n-\n-def binance_futures_symbols() -> Dict[str, str]:\n-    base = _binance_symbols('https://fapi.binance.com/fapi/v1/exchangeInfo', BINANCE_FUTURES)\n-    add = {}\n-    for symbol, orig in base.items():\n-        if \"_\" in orig:\n-            continue\n-        add[f\"{symbol}-PINDEX\"] = f\"p{orig}\"\n-    base.update(add)\n-    return base\n-\n-\n-def binance_delivery_symbols() -> Dict[str, str]:\n-    return _binance_symbols('https://dapi.binance.com/dapi/v1/exchangeInfo', BINANCE_DELIVERY)\n-\n-\n-def bitfinex_symbols() -> Dict[str, str]:\n-    # doc: https://docs.bitfinex.com/docs/ws-general#supported-pairs\n-    r1 = r2 = None\n-    try:\n-        r1 = requests.get('https://api.bitfinex.com/v2/tickers?symbols=ALL')\n-        r2 = requests.get('https://api-pub.bitfinex.com/v2/conf/pub:map:currency:sym')\n-        tickers: List[List[str]] = r1.json()\n-        norm: List[Tuple[str, str]] = r2.json()[0]\n-        norm: Dict[str, str] = dict(norm)\n-        for k, v in dict(norm).items():\n-            if k[-2:] == 'F0' or '-' in v:  # Do not convert BTCF0 -> BTC or PBTCETH -> PBTC-ETH\n-                del norm[k]\n-        norm['BCHN'] = 'BCH'  # Bitfinex uses BCHN, other exchanges use BCH\n-\n-        ret = {}\n-        for symbol in [t[0] for t in tickers]:\n-            if symbol[0] == 'f':\n-                normalized = norm.get(symbol[1:], symbol[1:])\n-            else:\n-                if len(symbol) == 7:\n-                    base, quote = symbol[1:4], symbol[4:]\n-                else:\n-                    base, quote = symbol[1:].split(':')\n-                    assert ':' in symbol\n-                normalized = norm.get(base, base) + SYMBOL_SEP + norm.get(quote, quote)\n-            ret[normalized.upper()] = symbol\n-        return ret\n-    except ValueError as why:\n-        raise_failure_explanation('BITFINEX', why, {\"tickers?symbols=ALL\": r1, \"pub:map:currency:sym\": r2})\n-\n-\n-def bitflyer_symbols() -> Dict[str, str]:\n-    endpoint = r = None\n-    try:\n-        ret = {}\n-        endpoints = ['https://api.bitflyer.com/v1/getmarkets/eu', 'https://api.bitflyer.com/v1/getmarkets/usa', 'https://api.bitflyer.com/v1/getmarkets']\n-        for endpoint in endpoints:\n-            r = requests.get(endpoint)\n-            for entry in r.json():\n-                normalized = entry['product_code'].replace(\"_\", SYMBOL_SEP)\n-                ret[normalized] = entry['product_code']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('BITFLYER', why, {endpoint: r})\n-\n-\n-def bybit_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.bybit.com/v2/public/symbols')\n-        ret = {}\n-        for symbol in r.json()['result']:\n-            quote = symbol['quote_currency']\n-            if not symbol['name'].endswith(quote):\n-                base, contract = symbol['name'].split(quote)\n-                normalized = f\"{base}{SYMBOL_SEP}{quote}-{contract}\"\n-            else:\n-                normalized = f\"{symbol['base_currency']}{SYMBOL_SEP}{quote}\"\n-            ret[normalized] = symbol['name']\n-            _exchange_info[BYBIT]['tick_size'][normalized] = symbol['price_filter']['tick_size']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('BYBIT', why, {\"\": r})\n-\n-\n-def _ftx_helper(endpoint: str, exchange: str):\n-    r = None\n-    try:\n-        r = requests.get(endpoint)\n-        ret = {}\n-        for data in r.json()['result']:\n-            normalized = data['name'].replace(\"/\", SYMBOL_SEP)\n-            symbol = data['name']\n-            ret[normalized] = symbol\n-            _exchange_info[exchange]['tick_size'][normalized] = data['priceIncrement']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation(exchange, why, {endpoint: r})\n-\n-\n-def ftx_symbols() -> Dict[str, str]:\n-    return _ftx_helper('https://ftx.com/api/markets', FTX)\n-\n-\n-def ftx_us_symbols() -> Dict[str, str]:\n-    return _ftx_helper('https://ftx.us/api/markets', FTX_US)\n-\n-\n-def coinbase_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.pro.coinbase.com/products')\n-        ret = {}\n-        for data in r.json():\n-            normalized = data['id'].replace(\"-\", SYMBOL_SEP)\n-            ret[normalized] = data['id']\n-            _exchange_info[COINBASE]['tick_size'][normalized] = data['quote_increment']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('COINBASE', why, {\"\": r})\n-\n-\n-def gemini_symbols(*args) -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.gemini.com/v1/symbols')\n-        ret = {}\n-        for symbol in r.json():\n-            std = f\"{symbol[:-3]}{SYMBOL_SEP}{symbol[-3:]}\"\n-            std = std.upper()\n-            ret[std] = symbol.upper()\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('GEMINI', why, {\"\": r})\n-\n-\n-def hitbtc_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        ret = {}\n-        r = requests.get('https://api.hitbtc.com/api/2/public/symbol')\n-        for symbol in r.json():\n-            split = len(symbol['baseCurrency'])\n-            normalized = symbol['id'][:split] + SYMBOL_SEP + symbol['id'][split:]\n-            ret[normalized] = symbol['id']\n-            _exchange_info[HITBTC]['tick_size'][normalized] = symbol['tickSize']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('HITBTC', why, {\"\": r})\n-\n-\n-def poloniex_id_symbol_mapping():\n-    r = None\n-    try:\n-        r = requests.get('https://poloniex.com/public?command=returnTicker')\n-        symbols = r.json()\n-        ret = {}\n-        for symbol in symbols:\n-            ret[symbols[symbol]['id']] = symbol\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('POLONIEX', why, {\"\": r})\n-\n-\n-def poloniex_symbols() -> Dict[str, str]:\n-    ret = {}\n-    for _, value in poloniex_id_symbol_mapping().items():\n-        std = value.replace(\"STR\", \"XLM\")\n-        quote, base = std.split(\"_\")\n-        ret[quote + SYMBOL_SEP + base] = value\n-    return ret\n-\n-\n-def bitstamp_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://www.bitstamp.net/api/v2/trading-pairs-info/')\n-        ret = {}\n-        for data in r.json():\n-            normalized = data['name'].replace(\"/\", SYMBOL_SEP)\n-            symbol = data['url_symbol']\n-            ret[normalized] = symbol\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('BITSTAMP', why, {\"\": r})\n-\n-\n-def kraken_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.kraken.com/0/public/AssetPairs')\n-        data = r.json()\n-        ret = {}\n-        for symbol in data['result']:\n-            if 'wsname' not in data['result'][symbol] or '.d' in symbol:\n-                # https://blog.kraken.com/post/259/introducing-the-kraken-dark-pool/\n-                # .d is for dark pool symbols\n-                continue\n-\n-            base, quote = data['result'][symbol]['wsname'].split(\"/\")\n-\n-            normalized = f\"{base}{SYMBOL_SEP}{quote}\"\n-            exch = data['result'][symbol]['wsname']\n-            normalized = normalized.replace('XBT', 'BTC')\n-            normalized = normalized.replace('XDG', 'DOG')\n-            ret[normalized] = exch\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('KRAKEN', why, {\"\": r})\n-\n-\n-def kraken_rest_symbols() -> Dict[str, str]:\n-    return {normalized: exchange.replace(\"/\", \"\") for normalized, exchange in kraken_symbols().items()}\n-\n-\n-def exx_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.exx.com/data/v1/tickers')\n-        exchange = [key.upper() for key in r.json().keys()]\n-        symbols = [key.replace(\"_\", SYMBOL_SEP) for key in exchange]\n-        return dict(zip(symbols, exchange))\n-    except Exception as why:\n-        raise_failure_explanation('EXX', why, {\"\": r})\n-\n-\n-def huobi_common_symbols(url: str):\n-    r = None\n-    try:\n-        r = requests.get(url)\n-        ret = {}\n-        for e in r.json()['data']:\n-            if e['state'] == 'offline':\n-                continue\n-            normalized = f\"{e['base-currency'].upper()}{SYMBOL_SEP}{e['quote-currency'].upper()}\"\n-            symbol = f\"{e['base-currency']}{e['quote-currency']}\"\n-            ret[normalized] = symbol\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('HUOBI', why, {url: r})\n-\n-\n-def huobi_symbols() -> Dict[str, str]:\n-    return huobi_common_symbols('https://api.huobi.pro/v1/common/symbols')\n-\n-\n-def huobi_us_symbols() -> Dict[str, str]:\n-    return huobi_common_symbols('https://api.huobi.com/v1/common/symbols')\n-\n-\n-def huobi_dm_symbols() -> Dict[str, str]:\n-    \"\"\"\n-    Mapping is, for instance: {\"BTC_CW\":\"BTC190816\"}\n-    See comments in exchange/huobi_dm.py\n-    \"\"\"\n-    mapping = {\n-        \"this_week\": \"CW\",\n-        \"next_week\": \"NW\",\n-        \"quarter\": \"CQ\",\n-        \"next_quarter\": \"NQ\"\n-    }\n-    r = None\n-    try:\n-        r = requests.get('https://www.hbdm.com/api/v1/contract_contract_info')\n-        symbols = {}\n-        for e in r.json()['data']:\n-            symbols[f\"{e['symbol']}_{mapping[e['contract_type']]}\"] = e['contract_code']\n-            _exchange_info[HUOBI_DM]['tick_size'][e['contract_code']] = e['price_tick']\n-            _exchange_info[HUOBI_DM]['short_code_mappings'][f\"{e['symbol']}_{mapping[e['contract_type']]}\"] = e['contract_code']\n-        return symbols\n-    except Exception as why:\n-        raise_failure_explanation('HUOBI_DM', why, {\"\": r})\n-\n-\n-def huobi_swap_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.hbdm.com/swap-api/v1/swap_contract_info')\n-        symbols = {}\n-        for e in r.json()['data']:\n-            symbols[e['contract_code']] = e['contract_code']\n-            _exchange_info[HUOBI_SWAP]['tick_size'][e['contract_code']] = e['price_tick']\n-        return symbols\n-    except Exception as why:\n-        raise_failure_explanation('HUOBI_SWAP', why, {\"\": r})\n-\n-\n-def okcoin_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://www.okcoin.com/api/spot/v3/instruments')\n-        ret = {}\n-        for e in r.json():\n-            ret[e['instrument_id']] = e['instrument_id']\n-            _exchange_info[OKCOIN]['tick_size'][e['instrument_id']] = e['tick_size']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('OKCOIN', why, {\"\": r})\n-\n-\n-def okex_symbols(*args) -> Dict[str, str]:\n-    urls = ['https://www.okex.com/api/spot/v3/instruments',\n-            'https://www.okex.com/api/swap/v3/instruments',\n-            'https://www.okex.com/api/futures/v3/instruments']\n-    urls = urls + okex_compute_option_urls_from_underlyings()\n-\n-    symbols: Dict[str, str] = {}\n-    for u in urls:\n-        time.sleep(0.2)\n-        symbols.update(okex_symbols_from_one_url(u))\n-\n-    for symbol in symbols:\n-        instrument_type = 'futures'\n-        dash_count = symbol.count(get_symbol_separator())\n-        if dash_count == 1:  # BTC-USDT\n-            instrument_type = 'spot'\n-        if dash_count == 4:  # BTC-USD-201225-35000-P\n-            instrument_type = 'option'\n-        if symbol[-4:] == \"SWAP\":  # BTC-USDT-SWAP\n-            instrument_type = 'swap'\n-\n-        _exchange_info[OKEX]['instrument_type'][symbol] = instrument_type\n-\n-    return symbols\n-\n-\n-def okex_compute_option_urls_from_underlyings() -> List[str]:\n-    url = 'https://www.okex.com/api/option/v3/underlying'\n-    r = None\n-    try:\n-        r = requests.get(url)\n-        return [f'https://www.okex.com/api/option/v3/instruments/{underlying}' for underlying in r.json()]\n-    except Exception as why:\n-        raise_failure_explanation('OKEX', why, {url: r})\n-\n-\n-def okex_symbols_from_one_url(url: str) -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get(url)\n-        ret = {}\n-        for e in r.json():\n-            ret[e['instrument_id']] = e['instrument_id']\n-            _exchange_info[OKEX]['tick_size'][e['instrument_id']] = e['tick_size']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('OKEX', why, {url: r})\n-\n-\n-def bittrex_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.bittrex.com/api/v1.1/public/getmarkets')\n-        r = r.json()['result']\n-        return {f\"{e['MarketCurrency']}{SYMBOL_SEP}{e['BaseCurrency']}\": e['MarketName'] for e in r if e['IsActive']}\n-    except Exception as why:\n-        raise_failure_explanation('BITTREX', why, {\"\": r})\n-\n-\n-def bitcoincom_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.exchange.bitcoin.com/api/2/public/symbol')\n-        return {f\"{data['baseCurrency']}{SYMBOL_SEP}{data['quoteCurrency'].replace('USD', 'USDT')}\": data['id'] for data in r.json()}\n-    except Exception as why:\n-        raise_failure_explanation('BITCOINCOM', why, {\"\": r})\n-\n-\n-def bitmax_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://bitmax.io/api/pro/v1/products')\n-        ret = {}\n-        for entry in r.json()['data']:\n-            # Only \"Normal\" status symbols are tradeable\n-            if entry['status'] == 'Normal':\n-                normalized = f\"{entry['baseAsset']}{SYMBOL_SEP}{entry['quoteAsset']}\"\n-                ret[normalized] = entry['symbol']\n-                _exchange_info[BITMAX]['tick_size'][normalized] = entry['tickSize']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('BITMAX', why, {\"\": r})\n-\n-\n-def upbit_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.upbit.com/v1/market/all')\n-        return {f\"{data['market'].split('-')[1]}{SYMBOL_SEP}{data['market'].split('-')[0]}\": data['market'] for data in r.json()}\n-    except Exception as why:\n-        raise_failure_explanation('UPBIT', why, {\"\": r})\n-\n-\n-def blockchain_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get(\"https://api.blockchain.com/mercury-gateway/v1/instruments\")\n-        return {data[\"symbol\"].replace(\"-\", SYMBOL_SEP): data[\"symbol\"] for data in r.json()}\n-    except Exception as why:\n-        raise_failure_explanation('BLOCKCHAIN', why, {\"\": r})\n-\n-\n-def gateio_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get(\"https://api.gateio.ws/api/v4/spot/currency_pairs\")\n-        return {data[\"id\"].replace(\"_\", SYMBOL_SEP): data['id'] for data in r.json()}\n-    except Exception as why:\n-        raise_failure_explanation('GATEIO', why, {\"\": r})\n-\n-\n-def bitmex_symbols() -> Dict[str, str]:\n-    r = None\n-    ret = {}\n-    try:\n-        r = requests.get(\"https://www.bitmex.com/api/v1/instrument/active\")\n-        for entry in r.json():\n-            components = []\n-            components.append(entry['rootSymbol'])\n-            components.append(entry['quoteCurrency'])\n-\n-            if entry['expiry']:\n-                components.append(entry['symbol'][-3:])\n-\n-            normalized = SYMBOL_SEP.join(components)\n-            normalized = normalized.replace(\"XBT\", \"BTC\")\n-            ret[normalized] = entry['symbol']\n-            _exchange_info[BITMEX]['tick_size'][normalized] = entry['tickSize']\n-\n-            if entry['expiry']:\n-                _exchange_info[BITMEX]['expiry'][normalized] = entry['expiry']\n-\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('BITMEX', why, {\"\": r})\n-\n-\n-def deribit_symbols() -> Dict[str, str]:\n-    url = r = None\n-    ret = {}\n-    try:\n-        # TODO: get currencies from https://www.deribit.com/api/v2/public/get_currencies\n-        currencies = ['BTC', 'ETH']\n-        for c in currencies:\n-            url = f\"https://www.deribit.com/api/v2/public/get_instruments?currency={c}&expired=false\"\n-            r = requests.get(url)\n-            for entry in r.json()['result']:\n-                split = entry['instrument_name'].split(\"-\")\n-                normalized = split[0] + SYMBOL_SEP + entry['quote_currency'] + \"-\" + '-'.join(split[1:])\n-                ret[normalized] = entry['instrument_name']\n-                _exchange_info[DERIBIT]['tick_size'][normalized] = entry['tick_size']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('DERIBIT', why, {url: r})\n-\n-\n-def kraken_future_symbols() -> Dict[str, str]:\n-    r = None\n-    ret = {}\n-    try:\n-        r = requests.get('https://futures.kraken.com/derivatives/api/v3/instruments')\n-        data = r.json()['instruments']\n-        for entry in data:\n-            if not entry['tradeable']:\n-                continue\n-            normalized = entry['symbol'].upper().replace(\"_\", \"-\")\n-            symbol = normalized[3:6] + SYMBOL_SEP + normalized[6:9]\n-            normalized = normalized.replace(normalized[3:9], symbol)\n-            normalized = normalized.replace('XBT', 'BTC')\n-\n-            _exchange_info[KRAKEN_FUTURES]['tick_size'][normalized] = entry['tickSize']\n-            _exchange_info[KRAKEN_FUTURES]['contract_size'][normalized] = entry['contractSize']\n-            _exchange_info[KRAKEN_FUTURES]['underlying'][normalized] = entry['underlying']\n-            _exchange_info[KRAKEN_FUTURES]['product_type'][normalized] = _kraken_futures_product_type[normalized[:2]]\n-            ret[normalized] = entry['symbol']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('KRAKEN_FUTURES', why, {\"\": r})\n-\n-\n-def probit_symbols() -> Dict[str, str]:\n-    # doc: https://docs-en.probit.com/reference-link/market\n-    r = None\n-    try:\n-        r = requests.get('https://api.probit.com/api/exchange/v1/market')\n-        return {entry['id']: entry['id'] for entry in r.json()['data']}\n-    except Exception as why:\n-        raise_failure_explanation('PROBIT', why, {\"\": r})\n-\n-\n-def coingecko_normalize_symbol(symbol: str) -> str:\n-    # keep digits, letters and dots, replace others by space\n-    symbol = ''.join(c if c.isalnum() or c in ('.', '+') else ' ' for c in symbol)\n-    return coingecko_normalize(symbol.upper())\n-\n-\n-def coingecko_normalize_name(name: str) -> str:\n-    # keep digits and letters, replace others by space (except when only composed by upper case letters, digits and dots)\n-    if not all(c.isupper() or c.isdigit() or c == '.' for c in name):\n-        name = ''.join(c if c.isalnum() else ' ' for c in name)\n-    return coingecko_normalize(name)\n-\n-\n-def coingecko_normalize(sym: str) -> str:\n-    sym = sym.strip()\n-    # do not concatenate numbers => separate them with a dot\n-    sym = list(sym)\n-    if len(sym) > 4:\n-        for i in range(2, len(sym) - 1):\n-            if sym[i] == ' ' and sym[i - 1].isdigit() and sym[i + 1].isdigit():\n-                sym[i] = '.'\n-    sym = ''.join(sym)\n-    # concatenate space-separated words => use CamelCase to distinguish the words\n-    if ' ' in sym:\n-        if sum(c.islower() for c in sym):  # if there is at least one lower case letter\n-            sym = ' '.join(word[0].upper() + word[1:] for word in sym.split())  # Just capitalize initial letter of each word\n-        else:  # CoinGecko may provide full upper-case as for \"THE STONE COIN\"\n-            sym = string.capwords(sym)  # capwords converts \"THE STONE COIN\" to \"The Stone Coin\"\n-        sym = sym.replace(' ', '')  # concatenate words\n-    return sym\n-\n-\n-def is_name_short(coin: dict) -> bool:\n-    \"\"\"return True if the coin name is enough short compared to the coin symbol.\"\"\"\n-    return len(coin['name']) <= max(5, len(coin['symbol']) + 1)\n-\n-\n-def has_many_caps(name: str) -> bool:\n-    \"\"\"return True if the symbol contains enough upper case letters, False if empty.\"\"\"\n-    return str and sum(c.islower() for c in name) < (len(name) / 2)\n-\n-\n-def coingecko_normalize_all(coin: dict):\n-    SYMBOL_TO_NORMALIZED = {'miota': 'IOTA'}\n-    normalized = SYMBOL_TO_NORMALIZED.get(coin['symbol'])\n-    if normalized:\n-        coin['ns'] = coin['nn'] = normalized\n-        return normalized\n-\n-    # ns = normalized symbol, nn = normalized name\n-    coin['ns'] = coingecko_normalize_symbol(coin['symbol'])\n-\n-    ID_SUFFIX = '-bitcoin-token'\n-    if coin['id'][-len(ID_SUFFIX):] == ID_SUFFIX:\n-        coin['nn'] = 'BTC' + coin['ns']\n-        return coin['nn']\n-\n-    name = coin['name']\n-\n-    prefixes = ('The ', 'the ')\n-    for p in prefixes:\n-        if name[:len(p)] == p:\n-            coin['reduced-name'] = True\n-            name = name[len(p):]\n-            break\n-\n-    suffixes = ('coin', 'coins', 'money', 'finance', 'protocol', 'reward', 'rewards', 'token')\n-    for s in suffixes:\n-        if len(name) > len(s) and name[-len(s):].lower() == s:\n-            # but keep suffix when lower-case concatenated\n-            if name[-len(s)].islower() and name[-len(s) - 1] != ' ':\n-                continue\n-            # also keep suffix to avoid confusing nam: \"Bitcoin Token\" -> \"Bitcoin\"\n-            if name[:-len(s)].strip().lower() == 'bitcoin':\n-                continue\n-            coin['reduced-name'] = True\n-            name = name[:-len(s)]\n-            break\n-\n-    coin['nn'] = coingecko_normalize_name(name)\n-\n-    if len(coin['nn']) < len(coin['ns']):\n-        if 'reduced-name' in coin:\n-            coin['reduced-name'] = False\n-            name = coin['name']\n-            coin['nn'] = coingecko_normalize_name(name)\n-        elif not has_many_caps(name):\n-            return coin['ns']\n-\n-    if not coin['ns']:  # coin['symbol'] may be an emoji that is striped when normalized\n-        return coin['nn']\n-\n-    if coin.get('reduced-name') and coin['ns'].upper() != coin['nn'].upper():\n-        return coin['ns']\n-\n-    i = coin['nn'].find('.')  # if there is a dot in normalized name => prefer the normalized symbol\n-    if i >= 0:\n-        if i > 1 and coin['nn'][i - 1].isdigit() and coin['nn'][i + 1].isdigit():\n-            pass  # except when the dot separates digits\n-        else:\n-            return coin['ns']\n-\n-    if is_name_short(coin) and has_many_caps(name):\n-        return coin['nn']\n-\n-    if 1.5 * len(coin['ns']) > len(coin['nn']) and any(c.islower() for c in coin['ns']):\n-        return coin['nn']\n-\n-    return coin['ns']\n-\n-\n-def coingecko_symbols() -> Dict[str, str]:\n-    r = None\n-    intermediate = defaultdict(list)\n-    try:\n-        r = requests.get('https://api.coingecko.com/api/v3/coins/list')\n-        all_coins = r.json()\n-        # First pass: generate & compare normalized symbol/name, and then select the most pertinent\n-        for coin in all_coins:\n-            normalized = coingecko_normalize_all(coin)\n-            intermediate[normalized].append(coin)\n-            # Above line keeps together the coins having the same normalized symbol.\n-            # To reduce collision, the coin['name'] is sometimes used in lieu of the coin['symbol'].\n-            # The coin['name'] is not capitalized because lower case letters may be meaningful: cETH, yUSD, DATx, zLOT\n-    except Exception as why:\n-        raise_failure_explanation('COINGECKO', why, {\"\": r})\n-\n-    final = coingecko_second_pass(intermediate)\n-    return coingecko_third_pass(final)\n-\n-\n-def coingecko_second_pass(intermediate: Dict[str, List[dict]]) -> Dict[str, List[dict]]:\n-    # Second pass: fixes most of the symbol collisions\n-    final = defaultdict(list)\n-    for normalized, coins in intermediate.items():\n-        if len(coins) == 1:\n-            final[normalized].append(coins[0])\n-            continue\n-        set_normalized = False\n-        for i in range(len(coins)):\n-            if normalized == coins[i]['nn']:\n-                coin = coins.pop(i)\n-                final[normalized].append(coin)\n-                set_normalized = True\n-                break\n-        rest: List[dict] = []\n-        for coin in coins:\n-            if '%' in coin['name']:\n-                if len(coins) == 1:\n-                    n = coin['ns']\n-                else:\n-                    n = coingecko_normalize_name(coin['id'])\n-                final[n].append(coin)\n-            else:\n-                rest.append(coin)\n-        if not rest:\n-            continue\n-        if not set_normalized:\n-            rest.sort(key=lambda coin: len(coin['nn']), reverse=True)  # sort by the length of the normalized name\n-            coin = rest.pop(0)\n-            final[normalized].append(coin)\n-        for coin in rest:\n-            if coin['nn'] not in intermediate:\n-                n = coin['nn']\n-            elif coin.get('reduced-name'):\n-                n = coingecko_normalize_name(coin['name'])\n-            else:\n-                n = coingecko_normalize_name(coin['id'])\n-            final[n].append(coin)\n-    return final\n-\n-\n-def coingecko_third_pass(final: Dict[str, List[dict]]) -> Dict[str, str]:\n-    # Third pass: fixes some remaining collisions and fills the result\n-    symbols = {}\n-    for normalized, coins in final.items():\n-        if len(coins) == 1:\n-            symbols[normalized] = coins[0]['id']\n-            continue\n-        set_normalized = False\n-        for i in range(len(coins)):\n-            if normalized == coins[i]['nn']:\n-                coin = coins.pop(i)\n-                symbols[normalized] = coin['id']\n-                set_normalized = True\n-                break\n-        rest: List[dict] = []\n-        for coin in coins:\n-            if '%' in coin['name']:\n-                if len(coins) == 1:\n-                    n = coin['ns']\n-                else:\n-                    n = coingecko_normalize_name(coin['id'])\n-                symbols[n] = coin['id']\n-            else:\n-                rest.append(coin)\n-        if not rest:\n-            continue\n-        if not set_normalized:\n-            rest.sort(key=lambda coin: len(coin['nn']), reverse=True)  # sort by the length of the normalized name\n-            coin = rest.pop(0)\n-            symbols[normalized] = coin['id']\n-        for coin in rest:\n-            if coin['nn'] not in final:\n-                n = coin['nn']\n-            elif coin.get('reduced-name'):\n-                n = coingecko_normalize_name(coin['name'])\n-            else:\n-                n = coingecko_normalize_name(coin['id'])\n-            symbols[n] = coin['id']\n-    return symbols\n-\n-\n-def whale_alert_coins(key_id: str) -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get(f'https://api.whale-alert.io/v1/status?api_key={key_id}')\n-        # Same symbols, but on different blockchains (for instance USDT), are naturally overwritten.\n-        return {s.upper(): s for b in r.json()['blockchains'] for s in b['symbols'] if s}\n-    except Exception as why:\n-        raise_failure_explanation('WHALES_ALERT', why, {\"\": r})\n-\n-\n-_exchange_function_map = {\n-    BITFINEX: bitfinex_symbols,\n-    BITFLYER: bitflyer_symbols,\n-    COINBASE: coinbase_symbols,\n-    GEMINI: gemini_symbols,\n-    HITBTC: hitbtc_symbols,\n-    POLONIEX: poloniex_symbols,\n-    PROBIT: probit_symbols,\n-    BITSTAMP: bitstamp_symbols,\n-    KRAKEN: kraken_symbols,\n-    KRAKEN + 'REST': kraken_rest_symbols,\n-    BINANCE: binance_symbols,\n-    BINANCE_US: binance_us_symbols,\n-    BINANCE_FUTURES: binance_futures_symbols,\n-    BINANCE_DELIVERY: binance_delivery_symbols,\n-    BLOCKCHAIN: blockchain_symbols,\n-    EXX: exx_symbols,\n-    HUOBI: huobi_symbols,\n-    HUOBI_DM: huobi_dm_symbols,\n-    HUOBI_SWAP: huobi_swap_symbols,\n-    OKCOIN: okcoin_symbols,\n-    OKEX: okex_symbols,\n-    BYBIT: bybit_symbols,\n-    FTX: ftx_symbols,\n-    FTX_US: ftx_us_symbols,\n-    BITTREX: bittrex_symbols,\n-    BITCOINCOM: bitcoincom_symbols,\n-    BITMAX: bitmax_symbols,\n-    UPBIT: upbit_symbols,\n-    GATEIO: gateio_symbols,\n-    BITMEX: bitmex_symbols,\n-    DERIBIT: deribit_symbols,\n-    KRAKEN_FUTURES: kraken_future_symbols,\n-    COINGECKO: coingecko_symbols,\n-    WHALE_ALERT: whale_alert_coins\n-}\n+Symbols = _Symbols()\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\n\nimport logging\nimport string\nimport time\nfrom collections import defaultdict\nfrom typing import Dict, List, Optional, Tuple\n\nimport requests\nfrom requests import Response\n\nfrom cryptofeed.defines import *\n\n\nLOG = logging.getLogger('feedhandler')\n\nSYMBOL_SEP = '-'\n\n_symbols_retrieval_cache: Dict[str, Dict[str, str]] = {}\n_exchange_info = defaultdict(lambda: defaultdict(dict))\n\n\n_kraken_futures_product_type = {\n    'FI': 'Inverse Futures',\n    'FV': 'Vanilla Futures',\n    'PI': 'Perpetual Inverse Futures',\n    'PV': 'Perpetual Vanilla Futures',\n    'IN': 'Real Time Index',\n    'RR': 'Reference Rate',\n}\n\n\ndef raise_failure_explanation(feed_id: str, exception: BaseException, responses: Dict[str, Optional[Response]]):\n    <IND>LOG.critical('%s: encountered %r while processing response from exchange API', feed_id, exception)\n    if len(responses) > 1:\n        <IND>LOG.critical('%s: content of one of the %s responses was unexpected', feed_id, len(responses))\n    <DED>for url, r in responses.items():\n        <IND>if url:\n            <IND>LOG.critical('%s: requested URL: %s', feed_id, url)\n        <DED>if r:\n            <IND>LOG.critical('%s: unexpected response: %s', feed_id, r.text)\n    <DED><DED>raise ValueError(f'Cryptofeed stopped because of an unexpected response from {feed_id}') from exception\n\n\n<DED>def set_symbol_separator(separator: str):\n    <IND>global SYMBOL_SEP\n    SYMBOL_SEP = separator\n\n\n<DED>def get_symbol_separator() -> str:\n    <IND>global SYMBOL_SEP\n    return SYMBOL_SEP\n\n\n<DED>def gen_symbols(exchange: str, key_id=None) -> Dict[str, str]:\n    <IND>if exchange not in _symbols_retrieval_cache:\n        <IND>LOG.info(\"%s: Getting list of symbols\", exchange)\n        symbols = _exchange_function_map[exchange](key_id) if key_id else _exchange_function_map[exchange]()\n        LOG.info(\"%s: %s symbols\", exchange, len(symbols))\n\n        # log all retrieved symbols using debug level\n        for normalized, exch_sym in sorted(symbols.items()):\n            <IND>LOG.debug('%s: id-from-exch -> normalized: %-35s-> %s', exchange, exch_sym, normalized)\n\n        <DED>_symbols_retrieval_cache[exchange] = symbols\n    <DED>return _symbols_retrieval_cache[exchange]\n\n\n<DED>def _binance_symbols(endpoint: str, exchange: str):\n    <IND>r = None\n    try:\n        <IND>ret = {}\n        r = requests.get(endpoint)\n        for symbol in r.json()['symbols']:\n            <IND>if symbol.get('status', 'TRADING') != \"TRADING\":\n                <IND>continue\n            <DED>if symbol.get('contractStatus', 'TRADING') != \"TRADING\":\n                <IND>continue\n            <DED>split = len(symbol['baseAsset'])\n            normalized = symbol['symbol'][:split] + SYMBOL_SEP + symbol['symbol'][split:]\n            ret[normalized] = symbol['symbol']\n            _exchange_info[exchange]['tick_size'][normalized] = symbol['filters'][0]['tickSize']\n            if \"contractType\" in symbol:\n                <IND>_exchange_info[exchange]['contract_type'][normalized] = symbol['contractType']\n        <DED><DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation(exchange, why, {endpoint: r})\n\n\n<DED><DED>def binance_symbols() -> Dict[str, str]:\n    <IND>return _binance_symbols('https://api.binance.com/api/v3/exchangeInfo', BINANCE)\n\n\n<DED>def binance_us_symbols() -> Dict[str, str]:\n    <IND>return _binance_symbols('https://api.binance.us/api/v3/exchangeInfo', BINANCE_US)\n\n\n<DED>def binance_futures_symbols() -> Dict[str, str]:\n    <IND>base = _binance_symbols('https://fapi.binance.com/fapi/v1/exchangeInfo', BINANCE_FUTURES)\n    add = {}\n    for symbol, orig in base.items():\n        <IND>if \"_\" in orig:\n            <IND>continue\n        <DED>add[f\"{symbol}-PINDEX\"] = f\"p{orig}\"\n    <DED>base.update(add)\n    return base\n\n\n<DED>def binance_delivery_symbols() -> Dict[str, str]:\n    <IND>return _binance_symbols('https://dapi.binance.com/dapi/v1/exchangeInfo', BINANCE_DELIVERY)\n\n\n<DED>def bitfinex_symbols() -> Dict[str, str]:\n    # doc: https://docs.bitfinex.com/docs/ws-general#supported-pairs\n    <IND>r1 = r2 = None\n    try:\n        <IND>r1 = requests.get('https://api.bitfinex.com/v2/tickers?symbols=ALL')\n        r2 = requests.get('https://api-pub.bitfinex.com/v2/conf/pub:map:currency:sym')\n        tickers: List[List[str]] = r1.json()\n        norm: List[Tuple[str, str]] = r2.json()[0]\n        norm: Dict[str, str] = dict(norm)\n        for k, v in dict(norm).items():\n            <IND>if k[-2:] == 'F0' or '-' in v:  # Do not convert BTCF0 -> BTC or PBTCETH -> PBTC-ETH\n                <IND>del norm[k]\n        <DED><DED>norm['BCHN'] = 'BCH'  # Bitfinex uses BCHN, other exchanges use BCH\n\n        ret = {}\n        for symbol in [t[0] for t in tickers]:\n            <IND>if symbol[0] == 'f':\n                <IND>normalized = norm.get(symbol[1:], symbol[1:])\n            <DED>else:\n                <IND>if len(symbol) == 7:\n                    <IND>base, quote = symbol[1:4], symbol[4:]\n                <DED>else:\n                    <IND>base, quote = symbol[1:].split(':')\n                    assert ':' in symbol\n                <DED>normalized = norm.get(base, base) + SYMBOL_SEP + norm.get(quote, quote)\n            <DED>ret[normalized.upper()] = symbol\n        <DED>return ret\n    <DED>except ValueError as why:\n        <IND>raise_failure_explanation('BITFINEX', why, {\"tickers?symbols=ALL\": r1, \"pub:map:currency:sym\": r2})\n\n\n<DED><DED>def bitflyer_symbols() -> Dict[str, str]:\n    <IND>endpoint = r = None\n    try:\n        <IND>ret = {}\n        endpoints = ['https://api.bitflyer.com/v1/getmarkets/eu', 'https://api.bitflyer.com/v1/getmarkets/usa', 'https://api.bitflyer.com/v1/getmarkets']\n        for endpoint in endpoints:\n            <IND>r = requests.get(endpoint)\n            for entry in r.json():\n                <IND>normalized = entry['product_code'].replace(\"_\", SYMBOL_SEP)\n                ret[normalized] = entry['product_code']\n        <DED><DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BITFLYER', why, {endpoint: r})\n\n\n<DED><DED>def bybit_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.bybit.com/v2/public/symbols')\n        ret = {}\n        for symbol in r.json()['result']:\n            <IND>quote = symbol['quote_currency']\n            if not symbol['name'].endswith(quote):\n                <IND>base, contract = symbol['name'].split(quote)\n                normalized = f\"{base}{SYMBOL_SEP}{quote}-{contract}\"\n            <DED>else:\n                <IND>normalized = f\"{symbol['base_currency']}{SYMBOL_SEP}{quote}\"\n            <DED>ret[normalized] = symbol['name']\n            _exchange_info[BYBIT]['tick_size'][normalized] = symbol['price_filter']['tick_size']\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BYBIT', why, {\"\": r})\n\n\n<DED><DED>def _ftx_helper(endpoint: str, exchange: str):\n    <IND>r = None\n    try:\n        <IND>r = requests.get(endpoint)\n        ret = {}\n        for data in r.json()['result']:\n            <IND>normalized = data['name'].replace(\"/\", SYMBOL_SEP)\n            symbol = data['name']\n            ret[normalized] = symbol\n            _exchange_info[exchange]['tick_size'][normalized] = data['priceIncrement']\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation(exchange, why, {endpoint: r})\n\n\n<DED><DED>def ftx_symbols() -> Dict[str, str]:\n    <IND>return _ftx_helper('https://ftx.com/api/markets', FTX)\n\n\n<DED>def ftx_us_symbols() -> Dict[str, str]:\n    <IND>return _ftx_helper('https://ftx.us/api/markets', FTX_US)\n\n\n<DED>def coinbase_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.pro.coinbase.com/products')\n        ret = {}\n        for data in r.json():\n            <IND>normalized = data['id'].replace(\"-\", SYMBOL_SEP)\n            ret[normalized] = data['id']\n            _exchange_info[COINBASE]['tick_size'][normalized] = data['quote_increment']\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('COINBASE', why, {\"\": r})\n\n\n<DED><DED>def gemini_symbols(*args) -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.gemini.com/v1/symbols')\n        ret = {}\n        for symbol in r.json():\n            <IND>std = f\"{symbol[:-3]}{SYMBOL_SEP}{symbol[-3:]}\"\n            std = std.upper()\n            ret[std] = symbol.upper()\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('GEMINI', why, {\"\": r})\n\n\n<DED><DED>def hitbtc_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>ret = {}\n        r = requests.get('https://api.hitbtc.com/api/2/public/symbol')\n        for symbol in r.json():\n            <IND>split = len(symbol['baseCurrency'])\n            normalized = symbol['id'][:split] + SYMBOL_SEP + symbol['id'][split:]\n            ret[normalized] = symbol['id']\n            _exchange_info[HITBTC]['tick_size'][normalized] = symbol['tickSize']\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('HITBTC', why, {\"\": r})\n\n\n<DED><DED>def poloniex_id_symbol_mapping():\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://poloniex.com/public?command=returnTicker')\n        symbols = r.json()\n        ret = {}\n        for symbol in symbols:\n            <IND>ret[symbols[symbol]['id']] = symbol\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('POLONIEX', why, {\"\": r})\n\n\n<DED><DED>def poloniex_symbols() -> Dict[str, str]:\n    <IND>ret = {}\n    for _, value in poloniex_id_symbol_mapping().items():\n        <IND>std = value.replace(\"STR\", \"XLM\")\n        quote, base = std.split(\"_\")\n        ret[quote + SYMBOL_SEP + base] = value\n    <DED>return ret\n\n\n<DED>def bitstamp_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://www.bitstamp.net/api/v2/trading-pairs-info/')\n        ret = {}\n        for data in r.json():\n            <IND>normalized = data['name'].replace(\"/\", SYMBOL_SEP)\n            symbol = data['url_symbol']\n            ret[normalized] = symbol\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BITSTAMP', why, {\"\": r})\n\n\n<DED><DED>def kraken_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.kraken.com/0/public/AssetPairs')\n        data = r.json()\n        ret = {}\n        for symbol in data['result']:\n            <IND>if 'wsname' not in data['result'][symbol] or '.d' in symbol:\n                # https://blog.kraken.com/post/259/introducing-the-kraken-dark-pool/\n                # .d is for dark pool symbols\n                <IND>continue\n\n            <DED>base, quote = data['result'][symbol]['wsname'].split(\"/\")\n\n            normalized = f\"{base}{SYMBOL_SEP}{quote}\"\n            exch = data['result'][symbol]['wsname']\n            normalized = normalized.replace('XBT', 'BTC')\n            normalized = normalized.replace('XDG', 'DOG')\n            ret[normalized] = exch\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('KRAKEN', why, {\"\": r})\n\n\n<DED><DED>def kraken_rest_symbols() -> Dict[str, str]:\n    <IND>return {normalized: exchange.replace(\"/\", \"\") for normalized, exchange in kraken_symbols().items()}\n\n\n<DED>def exx_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.exx.com/data/v1/tickers')\n        exchange = [key.upper() for key in r.json().keys()]\n        symbols = [key.replace(\"_\", SYMBOL_SEP) for key in exchange]\n        return dict(zip(symbols, exchange))\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('EXX', why, {\"\": r})\n\n\n<DED><DED>def huobi_common_symbols(url: str):\n    <IND>r = None\n    try:\n        <IND>r = requests.get(url)\n        ret = {}\n        for e in r.json()['data']:\n            <IND>if e['state'] == 'offline':\n                <IND>continue\n            <DED>normalized = f\"{e['base-currency'].upper()}{SYMBOL_SEP}{e['quote-currency'].upper()}\"\n            symbol = f\"{e['base-currency']}{e['quote-currency']}\"\n            ret[normalized] = symbol\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('HUOBI', why, {url: r})\n\n\n<DED><DED>def huobi_symbols() -> Dict[str, str]:\n    <IND>return huobi_common_symbols('https://api.huobi.pro/v1/common/symbols')\n\n\n<DED>def huobi_us_symbols() -> Dict[str, str]:\n    <IND>return huobi_common_symbols('https://api.huobi.com/v1/common/symbols')\n\n\n<DED>def huobi_dm_symbols() -> Dict[str, str]:\n    <IND>\"\"\"\n    Mapping is, for instance: {\"BTC_CW\":\"BTC190816\"}\n    See comments in exchange/huobi_dm.py\n    \"\"\"\n    mapping = {\n        \"this_week\": \"CW\",\n        \"next_week\": \"NW\",\n        \"quarter\": \"CQ\",\n        \"next_quarter\": \"NQ\"\n    }\n    r = None\n    try:\n        <IND>r = requests.get('https://www.hbdm.com/api/v1/contract_contract_info')\n        symbols = {}\n        for e in r.json()['data']:\n            <IND>symbols[f\"{e['symbol']}_{mapping[e['contract_type']]}\"] = e['contract_code']\n            _exchange_info[HUOBI_DM]['tick_size'][e['contract_code']] = e['price_tick']\n            _exchange_info[HUOBI_DM]['short_code_mappings'][f\"{e['symbol']}_{mapping[e['contract_type']]}\"] = e['contract_code']\n        <DED>return symbols\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('HUOBI_DM', why, {\"\": r})\n\n\n<DED><DED>def huobi_swap_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.hbdm.com/swap-api/v1/swap_contract_info')\n        symbols = {}\n        for e in r.json()['data']:\n            <IND>symbols[e['contract_code']] = e['contract_code']\n            _exchange_info[HUOBI_SWAP]['tick_size'][e['contract_code']] = e['price_tick']\n        <DED>return symbols\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('HUOBI_SWAP', why, {\"\": r})\n\n\n<DED><DED>def okcoin_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://www.okcoin.com/api/spot/v3/instruments')\n        ret = {}\n        for e in r.json():\n            <IND>ret[e['instrument_id']] = e['instrument_id']\n            _exchange_info[OKCOIN]['tick_size'][e['instrument_id']] = e['tick_size']\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('OKCOIN', why, {\"\": r})\n\n\n<DED><DED>def okex_symbols(*args) -> Dict[str, str]:\n    <IND>urls = ['https://www.okex.com/api/spot/v3/instruments',\n            'https://www.okex.com/api/swap/v3/instruments',\n            'https://www.okex.com/api/futures/v3/instruments']\n    urls = urls + okex_compute_option_urls_from_underlyings()\n\n    symbols: Dict[str, str] = {}\n    for u in urls:\n        <IND>time.sleep(0.2)\n        symbols.update(okex_symbols_from_one_url(u))\n\n    <DED>for symbol in symbols:\n        <IND>instrument_type = 'futures'\n        dash_count = symbol.count(get_symbol_separator())\n        if dash_count == 1:  # BTC-USDT\n            <IND>instrument_type = 'spot'\n        <DED>if dash_count == 4:  # BTC-USD-201225-35000-P\n            <IND>instrument_type = 'option'\n        <DED>if symbol[-4:] == \"SWAP\":  # BTC-USDT-SWAP\n            <IND>instrument_type = 'swap'\n\n        <DED>_exchange_info[OKEX]['instrument_type'][symbol] = instrument_type\n\n    <DED>return symbols\n\n\n<DED>def okex_compute_option_urls_from_underlyings() -> List[str]:\n    <IND>url = 'https://www.okex.com/api/option/v3/underlying'\n    r = None\n    try:\n        <IND>r = requests.get(url)\n        return [f'https://www.okex.com/api/option/v3/instruments/{underlying}' for underlying in r.json()]\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('OKEX', why, {url: r})\n\n\n<DED><DED>def okex_symbols_from_one_url(url: str) -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get(url)\n        ret = {}\n        for e in r.json():\n            <IND>ret[e['instrument_id']] = e['instrument_id']\n            _exchange_info[OKEX]['tick_size'][e['instrument_id']] = e['tick_size']\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('OKEX', why, {url: r})\n\n\n<DED><DED>def bittrex_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.bittrex.com/api/v1.1/public/getmarkets')\n        r = r.json()['result']\n        return {f\"{e['MarketCurrency']}{SYMBOL_SEP}{e['BaseCurrency']}\": e['MarketName'] for e in r if e['IsActive']}\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BITTREX', why, {\"\": r})\n\n\n<DED><DED>def bitcoincom_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.exchange.bitcoin.com/api/2/public/symbol')\n        return {f\"{data['baseCurrency']}{SYMBOL_SEP}{data['quoteCurrency'].replace('USD', 'USDT')}\": data['id'] for data in r.json()}\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BITCOINCOM', why, {\"\": r})\n\n\n<DED><DED>def bitmax_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://bitmax.io/api/pro/v1/products')\n        ret = {}\n        for entry in r.json()['data']:\n            # Only \"Normal\" status symbols are tradeable\n            <IND>if entry['status'] == 'Normal':\n                <IND>normalized = f\"{entry['baseAsset']}{SYMBOL_SEP}{entry['quoteAsset']}\"\n                ret[normalized] = entry['symbol']\n                _exchange_info[BITMAX]['tick_size'][normalized] = entry['tickSize']\n        <DED><DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BITMAX', why, {\"\": r})\n\n\n<DED><DED>def upbit_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.upbit.com/v1/market/all')\n        return {f\"{data['market'].split('-')[1]}{SYMBOL_SEP}{data['market'].split('-')[0]}\": data['market'] for data in r.json()}\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('UPBIT', why, {\"\": r})\n\n\n<DED><DED>def blockchain_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get(\"https://api.blockchain.com/mercury-gateway/v1/instruments\")\n        return {data[\"symbol\"].replace(\"-\", SYMBOL_SEP): data[\"symbol\"] for data in r.json()}\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BLOCKCHAIN', why, {\"\": r})\n\n\n<DED><DED>def gateio_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get(\"https://api.gateio.ws/api/v4/spot/currency_pairs\")\n        return {data[\"id\"].replace(\"_\", SYMBOL_SEP): data['id'] for data in r.json()}\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('GATEIO', why, {\"\": r})\n\n\n<DED><DED>def bitmex_symbols() -> Dict[str, str]:\n    <IND>r = None\n    ret = {}\n    try:\n        <IND>r = requests.get(\"https://www.bitmex.com/api/v1/instrument/active\")\n        for entry in r.json():\n            <IND>components = []\n            components.append(entry['rootSymbol'])\n            components.append(entry['quoteCurrency'])\n\n            if entry['expiry']:\n                <IND>components.append(entry['symbol'][-3:])\n\n            <DED>normalized = SYMBOL_SEP.join(components)\n            normalized = normalized.replace(\"XBT\", \"BTC\")\n            ret[normalized] = entry['symbol']\n            _exchange_info[BITMEX]['tick_size'][normalized] = entry['tickSize']\n\n            if entry['expiry']:\n                <IND>_exchange_info[BITMEX]['expiry'][normalized] = entry['expiry']\n\n        <DED><DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BITMEX', why, {\"\": r})\n\n\n<DED><DED>def deribit_symbols() -> Dict[str, str]:\n    <IND>url = r = None\n    ret = {}\n    try:\n        # TODO: get currencies from https://www.deribit.com/api/v2/public/get_currencies\n        <IND>currencies = ['BTC', 'ETH']\n        for c in currencies:\n            <IND>url = f\"https://www.deribit.com/api/v2/public/get_instruments?currency={c}&expired=false\"\n            r = requests.get(url)\n            for entry in r.json()['result']:\n                <IND>split = entry['instrument_name'].split(\"-\")\n                normalized = split[0] + SYMBOL_SEP + entry['quote_currency'] + \"-\" + '-'.join(split[1:])\n                ret[normalized] = entry['instrument_name']\n                _exchange_info[DERIBIT]['tick_size'][normalized] = entry['tick_size']\n        <DED><DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('DERIBIT', why, {url: r})\n\n\n<DED><DED>def kraken_future_symbols() -> Dict[str, str]:\n    <IND>r = None\n    ret = {}\n    try:\n        <IND>r = requests.get('https://futures.kraken.com/derivatives/api/v3/instruments')\n        data = r.json()['instruments']\n        for entry in data:\n            <IND>if not entry['tradeable']:\n                <IND>continue\n            <DED>normalized = entry['symbol'].upper().replace(\"_\", \"-\")\n            symbol = normalized[3:6] + SYMBOL_SEP + normalized[6:9]\n            normalized = normalized.replace(normalized[3:9], symbol)\n            normalized = normalized.replace('XBT', 'BTC')\n\n            _exchange_info[KRAKEN_FUTURES]['tick_size'][normalized] = entry['tickSize']\n            _exchange_info[KRAKEN_FUTURES]['contract_size'][normalized] = entry['contractSize']\n            _exchange_info[KRAKEN_FUTURES]['underlying'][normalized] = entry['underlying']\n            _exchange_info[KRAKEN_FUTURES]['product_type'][normalized] = _kraken_futures_product_type[normalized[:2]]\n            ret[normalized] = entry['symbol']\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('KRAKEN_FUTURES', why, {\"\": r})\n\n\n<DED><DED>def probit_symbols() -> Dict[str, str]:\n    # doc: https://docs-en.probit.com/reference-link/market\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.probit.com/api/exchange/v1/market')\n        return {entry['id']: entry['id'] for entry in r.json()['data']}\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('PROBIT', why, {\"\": r})\n\n\n<DED><DED>def coingecko_normalize_symbol(symbol: str) -> str:\n    # keep digits, letters and dots, replace others by space\n    <IND>symbol = ''.join(c if c.isalnum() or c in ('.', '+') else ' ' for c in symbol)\n    return coingecko_normalize(symbol.upper())\n\n\n<DED>def coingecko_normalize_name(name: str) -> str:\n    # keep digits and letters, replace others by space (except when only composed by upper case letters, digits and dots)\n    <IND>if not all(c.isupper() or c.isdigit() or c == '.' for c in name):\n        <IND>name = ''.join(c if c.isalnum() else ' ' for c in name)\n    <DED>return coingecko_normalize(name)\n\n\n<DED>def coingecko_normalize(sym: str) -> str:\n    <IND>sym = sym.strip()\n    # do not concatenate numbers => separate them with a dot\n    sym = list(sym)\n    if len(sym) > 4:\n        <IND>for i in range(2, len(sym) - 1):\n            <IND>if sym[i] == ' ' and sym[i - 1].isdigit() and sym[i + 1].isdigit():\n                <IND>sym[i] = '.'\n    <DED><DED><DED>sym = ''.join(sym)\n    # concatenate space-separated words => use CamelCase to distinguish the words\n    if ' ' in sym:\n        <IND>if sum(c.islower() for c in sym):  # if there is at least one lower case letter\n            <IND>sym = ' '.join(word[0].upper() + word[1:] for word in sym.split())  # Just capitalize initial letter of each word\n        <DED>else:  # CoinGecko may provide full upper-case as for \"THE STONE COIN\"\n            <IND>sym = string.capwords(sym)  # capwords converts \"THE STONE COIN\" to \"The Stone Coin\"\n        <DED>sym = sym.replace(' ', '')  # concatenate words\n    <DED>return sym\n\n\n<DED>def is_name_short(coin: dict) -> bool:\n    <IND>\"\"\"return True if the coin name is enough short compared to the coin symbol.\"\"\"\n    return len(coin['name']) <= max(5, len(coin['symbol']) + 1)\n\n\n<DED>def has_many_caps(name: str) -> bool:\n    <IND>\"\"\"return True if the symbol contains enough upper case letters, False if empty.\"\"\"\n    return str and sum(c.islower() for c in name) < (len(name) / 2)\n\n\n<DED>def coingecko_normalize_all(coin: dict):\n    <IND>SYMBOL_TO_NORMALIZED = {'miota': 'IOTA'}\n    normalized = SYMBOL_TO_NORMALIZED.get(coin['symbol'])\n    if normalized:\n        <IND>coin['ns'] = coin['nn'] = normalized\n        return normalized\n\n    # ns = normalized symbol, nn = normalized name\n    <DED>coin['ns'] = coingecko_normalize_symbol(coin['symbol'])\n\n    ID_SUFFIX = '-bitcoin-token'\n    if coin['id'][-len(ID_SUFFIX):] == ID_SUFFIX:\n        <IND>coin['nn'] = 'BTC' + coin['ns']\n        return coin['nn']\n\n    <DED>name = coin['name']\n\n    prefixes = ('The ', 'the ')\n    for p in prefixes:\n        <IND>if name[:len(p)] == p:\n            <IND>coin['reduced-name'] = True\n            name = name[len(p):]\n            break\n\n    <DED><DED>suffixes = ('coin', 'coins', 'money', 'finance', 'protocol', 'reward', 'rewards', 'token')\n    for s in suffixes:\n        <IND>if len(name) > len(s) and name[-len(s):].lower() == s:\n            # but keep suffix when lower-case concatenated\n            <IND>if name[-len(s)].islower() and name[-len(s) - 1] != ' ':\n                <IND>continue\n            # also keep suffix to avoid confusing nam: \"Bitcoin Token\" -> \"Bitcoin\"\n            <DED>if name[:-len(s)].strip().lower() == 'bitcoin':\n                <IND>continue\n            <DED>coin['reduced-name'] = True\n            name = name[:-len(s)]\n            break\n\n    <DED><DED>coin['nn'] = coingecko_normalize_name(name)\n\n    if len(coin['nn']) < len(coin['ns']):\n        <IND>if 'reduced-name' in coin:\n            <IND>coin['reduced-name'] = False\n            name = coin['name']\n            coin['nn'] = coingecko_normalize_name(name)\n        <DED>elif not has_many_caps(name):\n            <IND>return coin['ns']\n\n    <DED><DED>if not coin['ns']:  # coin['symbol'] may be an emoji that is striped when normalized\n        <IND>return coin['nn']\n\n    <DED>if coin.get('reduced-name') and coin['ns'].upper() != coin['nn'].upper():\n        <IND>return coin['ns']\n\n    <DED>i = coin['nn'].find('.')  # if there is a dot in normalized name => prefer the normalized symbol\n    if i >= 0:\n        <IND>if i > 1 and coin['nn'][i - 1].isdigit() and coin['nn'][i + 1].isdigit():\n            <IND>pass  # except when the dot separates digits\n        <DED>else:\n            <IND>return coin['ns']\n\n    <DED><DED>if is_name_short(coin) and has_many_caps(name):\n        <IND>return coin['nn']\n\n    <DED>if 1.5 * len(coin['ns']) > len(coin['nn']) and any(c.islower() for c in coin['ns']):\n        <IND>return coin['nn']\n\n    <DED>return coin['ns']\n\n\n<DED>def coingecko_symbols() -> Dict[str, str]:\n    <IND>r = None\n    intermediate = defaultdict(list)\n    try:\n        <IND>r = requests.get('https://api.coingecko.com/api/v3/coins/list')\n        all_coins = r.json()\n        # First pass: generate & compare normalized symbol/name, and then select the most pertinent\n        for coin in all_coins:\n            <IND>normalized = coingecko_normalize_all(coin)\n            intermediate[normalized].append(coin)\n            # Above line keeps together the coins having the same normalized symbol.\n            # To reduce collision, the coin['name'] is sometimes used in lieu of the coin['symbol'].\n            # The coin['name'] is not capitalized because lower case letters may be meaningful: cETH, yUSD, DATx, zLOT\n    <DED><DED>except Exception as why:\n        <IND>raise_failure_explanation('COINGECKO', why, {\"\": r})\n\n    <DED>final = coingecko_second_pass(intermediate)\n    return coingecko_third_pass(final)\n\n\n<DED>def coingecko_second_pass(intermediate: Dict[str, List[dict]]) -> Dict[str, List[dict]]:\n    # Second pass: fixes most of the symbol collisions\n    <IND>final = defaultdict(list)\n    for normalized, coins in intermediate.items():\n        <IND>if len(coins) == 1:\n            <IND>final[normalized].append(coins[0])\n            continue\n        <DED>set_normalized = False\n        for i in range(len(coins)):\n            <IND>if normalized == coins[i]['nn']:\n                <IND>coin = coins.pop(i)\n                final[normalized].append(coin)\n                set_normalized = True\n                break\n        <DED><DED>rest: List[dict] = []\n        for coin in coins:\n            <IND>if '%' in coin['name']:\n                <IND>if len(coins) == 1:\n                    <IND>n = coin['ns']\n                <DED>else:\n                    <IND>n = coingecko_normalize_name(coin['id'])\n                <DED>final[n].append(coin)\n            <DED>else:\n                <IND>rest.append(coin)\n        <DED><DED>if not rest:\n            <IND>continue\n        <DED>if not set_normalized:\n            <IND>rest.sort(key=lambda coin: len(coin['nn']), reverse=True)  # sort by the length of the normalized name\n            coin = rest.pop(0)\n            final[normalized].append(coin)\n        <DED>for coin in rest:\n            <IND>if coin['nn'] not in intermediate:\n                <IND>n = coin['nn']\n            <DED>elif coin.get('reduced-name'):\n                <IND>n = coingecko_normalize_name(coin['name'])\n            <DED>else:\n                <IND>n = coingecko_normalize_name(coin['id'])\n            <DED>final[n].append(coin)\n    <DED><DED>return final\n\n\n<DED>def coingecko_third_pass(final: Dict[str, List[dict]]) -> Dict[str, str]:\n    # Third pass: fixes some remaining collisions and fills the result\n    <IND>symbols = {}\n    for normalized, coins in final.items():\n        <IND>if len(coins) == 1:\n            <IND>symbols[normalized] = coins[0]['id']\n            continue\n        <DED>set_normalized = False\n        for i in range(len(coins)):\n            <IND>if normalized == coins[i]['nn']:\n                <IND>coin = coins.pop(i)\n                symbols[normalized] = coin['id']\n                set_normalized = True\n                break\n        <DED><DED>rest: List[dict] = []\n        for coin in coins:\n            <IND>if '%' in coin['name']:\n                <IND>if len(coins) == 1:\n                    <IND>n = coin['ns']\n                <DED>else:\n                    <IND>n = coingecko_normalize_name(coin['id'])\n                <DED>symbols[n] = coin['id']\n            <DED>else:\n                <IND>rest.append(coin)\n        <DED><DED>if not rest:\n            <IND>continue\n        <DED>if not set_normalized:\n            <IND>rest.sort(key=lambda coin: len(coin['nn']), reverse=True)  # sort by the length of the normalized name\n            coin = rest.pop(0)\n            symbols[normalized] = coin['id']\n        <DED>for coin in rest:\n            <IND>if coin['nn'] not in final:\n                <IND>n = coin['nn']\n            <DED>elif coin.get('reduced-name'):\n                <IND>n = coingecko_normalize_name(coin['name'])\n            <DED>else:\n                <IND>n = coingecko_normalize_name(coin['id'])\n            <DED>symbols[n] = coin['id']\n    <DED><DED>return symbols\n\n\n<DED>def whale_alert_coins(key_id: str) -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get(f'https://api.whale-alert.io/v1/status?api_key={key_id}')\n        # Same symbols, but on different blockchains (for instance USDT), are naturally overwritten.\n        return {s.upper(): s for b in r.json()['blockchains'] for s in b['symbols'] if s}\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('WHALES_ALERT', why, {\"\": r})\n\n\n<DED><DED>_exchange_function_map = {\n    BITFINEX: bitfinex_symbols,\n    BITFLYER: bitflyer_symbols,\n    COINBASE: coinbase_symbols,\n    GEMINI: gemini_symbols,\n    HITBTC: hitbtc_symbols,\n    POLONIEX: poloniex_symbols,\n    PROBIT: probit_symbols,\n    BITSTAMP: bitstamp_symbols,\n    KRAKEN: kraken_symbols,\n    KRAKEN + 'REST': kraken_rest_symbols,\n    BINANCE: binance_symbols,\n    BINANCE_US: binance_us_symbols,\n    BINANCE_FUTURES: binance_futures_symbols,\n    BINANCE_DELIVERY: binance_delivery_symbols,\n    BLOCKCHAIN: blockchain_symbols,\n    EXX: exx_symbols,\n    HUOBI: huobi_symbols,\n    HUOBI_DM: huobi_dm_symbols,\n    HUOBI_SWAP: huobi_swap_symbols,\n    OKCOIN: okcoin_symbols,\n    OKEX: okex_symbols,\n    BYBIT: bybit_symbols,\n    FTX: ftx_symbols,\n    FTX_US: ftx_us_symbols,\n    BITTREX: bittrex_symbols,\n    BITCOINCOM: bitcoincom_symbols,\n    BITMAX: bitmax_symbols,\n    UPBIT: upbit_symbols,\n    GATEIO: gateio_symbols,\n    BITMEX: bitmex_symbols,\n    DERIBIT: deribit_symbols,\n    KRAKEN_FUTURES: kraken_future_symbols,\n    COINGECKO: coingecko_symbols,\n    WHALE_ALERT: whale_alert_coins\n}\n",
        "target_code_with_indent": "\nfrom typing import Dict, Tuple\n\n\nclass _Symbols:\n    <IND>def __init__(self):\n        <IND>self.data = {}\n\n    <DED>def set(self, exchange: str, normalized: dict, exchange_info: dict):\n        <IND>self.data[exchange] = {}\n        self.data[exchange]['normalized'] = normalized\n        self.data[exchange]['info'] = exchange_info\n\n    <DED>def get(self, exchange: str) -> Tuple[Dict, Dict]:\n        <IND>return self.data[exchange]['normalized'], self.data[exchange]['info']\n\n    <DED>def populated(self, exchange: str) -> bool:\n        <IND>return exchange in self.data\n\n\n<DED><DED>Symbols = _Symbols()\n"
      }
    ]
  },
  {
    "project": "bmoscon/cryptofeed",
    "commit": "3525dc8ce4d7836a9abaaa5662e58e5e27969a77",
    "filename": "cryptofeed/symbols.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/bmoscon-cryptofeed/cryptofeed/symbols.py",
    "file_hunks_size": 1,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "cryptofeed/symbols.py:398:8 Incompatible return type [7]: Expected `Dict[str, str]` but got implicit return value of `None`.",
    "message": " Expected `Dict[str, str]` but got implicit return value of `None`.",
    "rule_id": "Incompatible return type [7]",
    "warning_line_no": 398,
    "warning_line": "        raise_failure_explanation('OKCOIN', why, {\"\": r})",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "associated with this software.\n\n\nSymbol generation code for exchanges\n'''\n\nimport logging\nimport string\nimport time\nfrom collections import defaultdict\nfrom typing import Dict, List, Optional, Tuple\n\nimport requests\nfrom requests import Response\n\nfrom cryptofeed.defines import *\n\n\nLOG = logging.getLogger('feedhandler')\n\nSYMBOL_SEP = '-'\n\n_symbols_retrieval_cache: Dict[str, Dict[str, str]] = {}\n_exchange_info = defaultdict(lambda: defaultdict(dict))\n\n\n_kraken_futures_product_type = {\n    'FI': 'Inverse Futures',\n    'FV': 'Vanilla Futures',\n    'PI': 'Perpetual Inverse Futures',\n    'PV': 'Perpetual Vanilla Futures',\n    'IN': 'Real Time Index',\n    'RR': 'Reference Rate',\n}\n\n\ndef raise_failure_explanation(feed_id: str, exception: BaseException, responses: Dict[str, Optional[Response]]):\n    LOG.critical('%s: encountered %r while processing response from exchange API', feed_id, exception)\n    if len(responses) > 1:\n        LOG.critical('%s: content of one of the %s responses was unexpected', feed_id, len(responses))\n    for url, r in responses.items():\n        if url:\n            LOG.critical('%s: requested URL: %s', feed_id, url)\n        if r:\n            LOG.critical('%s: unexpected response: %s', feed_id, r.text)\n    raise ValueError(f'Cryptofeed stopped because of an unexpected response from {feed_id}') from exception\n\n\ndef set_symbol_separator(separator: str):\n    global SYMBOL_SEP\n    SYMBOL_SEP = separator\n\n\ndef get_symbol_separator() -> str:\n    global SYMBOL_SEP\n    return SYMBOL_SEP\n\n\ndef gen_symbols(exchange: str, key_id=None) -> Dict[str, str]:\n    if exchange not in _symbols_retrieval_cache:\n        LOG.info(\"%s: Getting list of symbols\", exchange)\n        symbols = _exchange_function_map[exchange](key_id) if key_id else _exchange_function_map[exchange]()\n        LOG.info(\"%s: %s symbols\", exchange, len(symbols))\n\n        # log all retrieved symbols using debug level\n        for normalized, exch_sym in sorted(symbols.items()):\n            LOG.debug('%s: id-from-exch -> normalized: %-35s-> %s', exchange, exch_sym, normalized)\n\n        _symbols_retrieval_cache[exchange] = symbols\n    return _symbols_retrieval_cache[exchange]\n\n\ndef _binance_symbols(endpoint: str, exchange: str):\n    r = None\n    try:\n        ret = {}\n        r = requests.get(endpoint)\n        for symbol in r.json()['symbols']:\n            if symbol.get('status', 'TRADING') != \"TRADING\":\n                continue\n            if symbol.get('contractStatus', 'TRADING') != \"TRADING\":\n                continue\n            split = len(symbol['baseAsset'])\n            normalized = symbol['symbol'][:split] + SYMBOL_SEP + symbol['symbol'][split:]\n            ret[normalized] = symbol['symbol']\n            _exchange_info[exchange]['tick_size'][normalized] = symbol['filters'][0]['tickSize']\n            if \"contractType\" in symbol:\n                _exchange_info[exchange]['contract_type'][normalized] = symbol['contractType']\n        return ret\n    except Exception as why:\n        raise_failure_explanation(exchange, why, {endpoint: r})\n\n\ndef binance_symbols() -> Dict[str, str]:\n    return _binance_symbols('https://api.binance.com/api/v3/exchangeInfo', BINANCE)\n\n\ndef binance_us_symbols() -> Dict[str, str]:\n    return _binance_symbols('https://api.binance.us/api/v3/exchangeInfo', BINANCE_US)\n\n\ndef binance_futures_symbols() -> Dict[str, str]:\n    base = _binance_symbols('https://fapi.binance.com/fapi/v1/exchangeInfo', BINANCE_FUTURES)\n    add = {}\n    for symbol, orig in base.items():\n        if \"_\" in orig:\n            continue\n        add[f\"{symbol}-PINDEX\"] = f\"p{orig}\"\n    base.update(add)\n    return base\n\n\ndef binance_delivery_symbols() -> Dict[str, str]:\n    return _binance_symbols('https://dapi.binance.com/dapi/v1/exchangeInfo', BINANCE_DELIVERY)\n\n\ndef bitfinex_symbols() -> Dict[str, str]:\n    # doc: https://docs.bitfinex.com/docs/ws-general#supported-pairs\n    r1 = r2 = None\n    try:\n        r1 = requests.get('https://api.bitfinex.com/v2/tickers?symbols=ALL')\n        r2 = requests.get('https://api-pub.bitfinex.com/v2/conf/pub:map:currency:sym')\n        tickers: List[List[str]] = r1.json()\n        norm: List[Tuple[str, str]] = r2.json()[0]\n        norm: Dict[str, str] = dict(norm)\n        for k, v in dict(norm).items():\n            if k[-2:] == 'F0' or '-' in v:  # Do not convert BTCF0 -> BTC or PBTCETH -> PBTC-ETH\n                del norm[k]\n        norm['BCHN'] = 'BCH'  # Bitfinex uses BCHN, other exchanges use BCH\n\n        ret = {}\n        for symbol in [t[0] for t in tickers]:\n            if symbol[0] == 'f':\n                normalized = norm.get(symbol[1:], symbol[1:])\n            else:\n                if len(symbol) == 7:\n                    base, quote = symbol[1:4], symbol[4:]\n                else:\n                    base, quote = symbol[1:].split(':')\n                    assert ':' in symbol\n                normalized = norm.get(base, base) + SYMBOL_SEP + norm.get(quote, quote)\n            ret[normalized.upper()] = symbol\n        return ret\n    except ValueError as why:\n        raise_failure_explanation('BITFINEX', why, {\"tickers?symbols=ALL\": r1, \"pub:map:currency:sym\": r2})\n\n\ndef bitflyer_symbols() -> Dict[str, str]:\n    endpoint = r = None\n    try:\n        ret = {}\n        endpoints = ['https://api.bitflyer.com/v1/getmarkets/eu', 'https://api.bitflyer.com/v1/getmarkets/usa', 'https://api.bitflyer.com/v1/getmarkets']\n        for endpoint in endpoints:\n            r = requests.get(endpoint)\n            for entry in r.json():\n                normalized = entry['product_code'].replace(\"_\", SYMBOL_SEP)\n                ret[normalized] = entry['product_code']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('BITFLYER', why, {endpoint: r})\n\n\ndef bybit_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.bybit.com/v2/public/symbols')\n        ret = {}\n        for symbol in r.json()['result']:\n            quote = symbol['quote_currency']\n            if not symbol['name'].endswith(quote):\n                base, contract = symbol['name'].split(quote)\n                normalized = f\"{base}{SYMBOL_SEP}{quote}-{contract}\"\n            else:\n                normalized = f\"{symbol['base_currency']}{SYMBOL_SEP}{quote}\"\n            ret[normalized] = symbol['name']\n            _exchange_info[BYBIT]['tick_size'][normalized] = symbol['price_filter']['tick_size']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('BYBIT', why, {\"\": r})\n\n\ndef _ftx_helper(endpoint: str, exchange: str):\n    r = None\n    try:\n        r = requests.get(endpoint)\n        ret = {}\n        for data in r.json()['result']:\n            normalized = data['name'].replace(\"/\", SYMBOL_SEP)\n            symbol = data['name']\n            ret[normalized] = symbol\n            _exchange_info[exchange]['tick_size'][normalized] = data['priceIncrement']\n        return ret\n    except Exception as why:\n        raise_failure_explanation(exchange, why, {endpoint: r})\n\n\ndef ftx_symbols() -> Dict[str, str]:\n    return _ftx_helper('https://ftx.com/api/markets', FTX)\n\n\ndef ftx_us_symbols() -> Dict[str, str]:\n    return _ftx_helper('https://ftx.us/api/markets', FTX_US)\n\n\ndef coinbase_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.pro.coinbase.com/products')\n        ret = {}\n        for data in r.json():\n            normalized = data['id'].replace(\"-\", SYMBOL_SEP)\n            ret[normalized] = data['id']\n            _exchange_info[COINBASE]['tick_size'][normalized] = data['quote_increment']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('COINBASE', why, {\"\": r})\n\n\ndef gemini_symbols(*args) -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.gemini.com/v1/symbols')\n        ret = {}\n        for symbol in r.json():\n            std = f\"{symbol[:-3]}{SYMBOL_SEP}{symbol[-3:]}\"\n            std = std.upper()\n            ret[std] = symbol.upper()\n        return ret\n    except Exception as why:\n        raise_failure_explanation('GEMINI', why, {\"\": r})\n\n\ndef hitbtc_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        ret = {}\n        r = requests.get('https://api.hitbtc.com/api/2/public/symbol')\n        for symbol in r.json():\n            split = len(symbol['baseCurrency'])\n            normalized = symbol['id'][:split] + SYMBOL_SEP + symbol['id'][split:]\n            ret[normalized] = symbol['id']\n            _exchange_info[HITBTC]['tick_size'][normalized] = symbol['tickSize']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('HITBTC', why, {\"\": r})\n\n\ndef poloniex_id_symbol_mapping():\n    r = None\n    try:\n        r = requests.get('https://poloniex.com/public?command=returnTicker')\n        symbols = r.json()\n        ret = {}\n        for symbol in symbols:\n            ret[symbols[symbol]['id']] = symbol\n        return ret\n    except Exception as why:\n        raise_failure_explanation('POLONIEX', why, {\"\": r})\n\n\ndef poloniex_symbols() -> Dict[str, str]:\n    ret = {}\n    for _, value in poloniex_id_symbol_mapping().items():\n        std = value.replace(\"STR\", \"XLM\")\n        quote, base = std.split(\"_\")\n        ret[quote + SYMBOL_SEP + base] = value\n    return ret\n\n\ndef bitstamp_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://www.bitstamp.net/api/v2/trading-pairs-info/')\n        ret = {}\n        for data in r.json():\n            normalized = data['name'].replace(\"/\", SYMBOL_SEP)\n            symbol = data['url_symbol']\n            ret[normalized] = symbol\n        return ret\n    except Exception as why:\n        raise_failure_explanation('BITSTAMP', why, {\"\": r})\n\n\ndef kraken_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.kraken.com/0/public/AssetPairs')\n        data = r.json()\n        ret = {}\n        for symbol in data['result']:\n            if 'wsname' not in data['result'][symbol] or '.d' in symbol:\n                # https://blog.kraken.com/post/259/introducing-the-kraken-dark-pool/\n                # .d is for dark pool symbols\n                continue\n\n            base, quote = data['result'][symbol]['wsname'].split(\"/\")\n\n            normalized = f\"{base}{SYMBOL_SEP}{quote}\"\n            exch = data['result'][symbol]['wsname']\n            normalized = normalized.replace('XBT', 'BTC')\n            normalized = normalized.replace('XDG', 'DOG')\n            ret[normalized] = exch\n        return ret\n    except Exception as why:\n        raise_failure_explanation('KRAKEN', why, {\"\": r})\n\n\ndef kraken_rest_symbols() -> Dict[str, str]:\n    return {normalized: exchange.replace(\"/\", \"\") for normalized, exchange in kraken_symbols().items()}\n\n\ndef exx_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.exx.com/data/v1/tickers')\n        exchange = [key.upper() for key in r.json().keys()]\n        symbols = [key.replace(\"_\", SYMBOL_SEP) for key in exchange]\n        return dict(zip(symbols, exchange))\n    except Exception as why:\n        raise_failure_explanation('EXX', why, {\"\": r})\n\n\ndef huobi_common_symbols(url: str):\n    r = None\n    try:\n        r = requests.get(url)\n        ret = {}\n        for e in r.json()['data']:\n            if e['state'] == 'offline':\n                continue\n            normalized = f\"{e['base-currency'].upper()}{SYMBOL_SEP}{e['quote-currency'].upper()}\"\n            symbol = f\"{e['base-currency']}{e['quote-currency']}\"\n            ret[normalized] = symbol\n        return ret\n    except Exception as why:\n        raise_failure_explanation('HUOBI', why, {url: r})\n\n\ndef huobi_symbols() -> Dict[str, str]:\n    return huobi_common_symbols('https://api.huobi.pro/v1/common/symbols')\n\n\ndef huobi_us_symbols() -> Dict[str, str]:\n    return huobi_common_symbols('https://api.huobi.com/v1/common/symbols')\n\n\ndef huobi_dm_symbols() -> Dict[str, str]:\n    \"\"\"\n    Mapping is, for instance: {\"BTC_CW\":\"BTC190816\"}\n    See comments in exchange/huobi_dm.py\n    \"\"\"\n    mapping = {\n        \"this_week\": \"CW\",\n        \"next_week\": \"NW\",\n        \"quarter\": \"CQ\",\n        \"next_quarter\": \"NQ\"\n    }\n    r = None\n    try:\n        r = requests.get('https://www.hbdm.com/api/v1/contract_contract_info')\n        symbols = {}\n        for e in r.json()['data']:\n            symbols[f\"{e['symbol']}_{mapping[e['contract_type']]}\"] = e['contract_code']\n            _exchange_info[HUOBI_DM]['tick_size'][e['contract_code']] = e['price_tick']\n            _exchange_info[HUOBI_DM]['short_code_mappings'][f\"{e['symbol']}_{mapping[e['contract_type']]}\"] = e['contract_code']\n        return symbols\n    except Exception as why:\n        raise_failure_explanation('HUOBI_DM', why, {\"\": r})\n\n\ndef huobi_swap_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.hbdm.com/swap-api/v1/swap_contract_info')\n        symbols = {}\n        for e in r.json()['data']:\n            symbols[e['contract_code']] = e['contract_code']\n            _exchange_info[HUOBI_SWAP]['tick_size'][e['contract_code']] = e['price_tick']\n        return symbols\n    except Exception as why:\n        raise_failure_explanation('HUOBI_SWAP', why, {\"\": r})\n\n\ndef okcoin_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://www.okcoin.com/api/spot/v3/instruments')\n        ret = {}\n        for e in r.json():\n            ret[e['instrument_id']] = e['instrument_id']\n            _exchange_info[OKCOIN]['tick_size'][e['instrument_id']] = e['tick_size']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('OKCOIN', why, {\"\": r})\n\n\ndef okex_symbols(*args) -> Dict[str, str]:\n    urls = ['https://www.okex.com/api/spot/v3/instruments',\n            'https://www.okex.com/api/swap/v3/instruments',\n            'https://www.okex.com/api/futures/v3/instruments']\n    urls = urls + okex_compute_option_urls_from_underlyings()\n\n    symbols: Dict[str, str] = {}\n    for u in urls:\n        time.sleep(0.2)\n        symbols.update(okex_symbols_from_one_url(u))\n\n    for symbol in symbols:\n        instrument_type = 'futures'\n        dash_count = symbol.count(get_symbol_separator())\n        if dash_count == 1:  # BTC-USDT\n            instrument_type = 'spot'\n        if dash_count == 4:  # BTC-USD-201225-35000-P\n            instrument_type = 'option'\n        if symbol[-4:] == \"SWAP\":  # BTC-USDT-SWAP\n            instrument_type = 'swap'\n\n        _exchange_info[OKEX]['instrument_type'][symbol] = instrument_type\n\n    return symbols\n\n\ndef okex_compute_option_urls_from_underlyings() -> List[str]:\n    url = 'https://www.okex.com/api/option/v3/underlying'\n    r = None\n    try:\n        r = requests.get(url)\n        return [f'https://www.okex.com/api/option/v3/instruments/{underlying}' for underlying in r.json()]\n    except Exception as why:\n        raise_failure_explanation('OKEX', why, {url: r})\n\n\ndef okex_symbols_from_one_url(url: str) -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get(url)\n        ret = {}\n        for e in r.json():\n            ret[e['instrument_id']] = e['instrument_id']\n            _exchange_info[OKEX]['tick_size'][e['instrument_id']] = e['tick_size']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('OKEX', why, {url: r})\n\n\ndef bittrex_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.bittrex.com/api/v1.1/public/getmarkets')\n        r = r.json()['result']\n        return {f\"{e['MarketCurrency']}{SYMBOL_SEP}{e['BaseCurrency']}\": e['MarketName'] for e in r if e['IsActive']}\n    except Exception as why:\n        raise_failure_explanation('BITTREX', why, {\"\": r})\n\n\ndef bitcoincom_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.exchange.bitcoin.com/api/2/public/symbol')\n        return {f\"{data['baseCurrency']}{SYMBOL_SEP}{data['quoteCurrency'].replace('USD', 'USDT')}\": data['id'] for data in r.json()}\n    except Exception as why:\n        raise_failure_explanation('BITCOINCOM', why, {\"\": r})\n\n\ndef bitmax_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://bitmax.io/api/pro/v1/products')\n        ret = {}\n        for entry in r.json()['data']:\n            # Only \"Normal\" status symbols are tradeable\n            if entry['status'] == 'Normal':\n                normalized = f\"{entry['baseAsset']}{SYMBOL_SEP}{entry['quoteAsset']}\"\n                ret[normalized] = entry['symbol']\n                _exchange_info[BITMAX]['tick_size'][normalized] = entry['tickSize']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('BITMAX', why, {\"\": r})\n\n\ndef upbit_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.upbit.com/v1/market/all')\n        return {f\"{data['market'].split('-')[1]}{SYMBOL_SEP}{data['market'].split('-')[0]}\": data['market'] for data in r.json()}\n    except Exception as why:\n        raise_failure_explanation('UPBIT', why, {\"\": r})\n\n\ndef blockchain_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get(\"https://api.blockchain.com/mercury-gateway/v1/instruments\")\n        return {data[\"symbol\"].replace(\"-\", SYMBOL_SEP): data[\"symbol\"] for data in r.json()}\n    except Exception as why:\n        raise_failure_explanation('BLOCKCHAIN', why, {\"\": r})\n\n\ndef gateio_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get(\"https://api.gateio.ws/api/v4/spot/currency_pairs\")\n        return {data[\"id\"].replace(\"_\", SYMBOL_SEP): data['id'] for data in r.json()}\n    except Exception as why:\n        raise_failure_explanation('GATEIO', why, {\"\": r})\n\n\ndef bitmex_symbols() -> Dict[str, str]:\n    r = None\n    ret = {}\n    try:\n        r = requests.get(\"https://www.bitmex.com/api/v1/instrument/active\")\n        for entry in r.json():\n            components = []\n            components.append(entry['rootSymbol'])\n            components.append(entry['quoteCurrency'])\n\n            if entry['expiry']:\n                components.append(entry['symbol'][-3:])\n\n            normalized = SYMBOL_SEP.join(components)\n            normalized = normalized.replace(\"XBT\", \"BTC\")\n            ret[normalized] = entry['symbol']\n            _exchange_info[BITMEX]['tick_size'][normalized] = entry['tickSize']\n\n            if entry['expiry']:\n                _exchange_info[BITMEX]['expiry'][normalized] = entry['expiry']\n\n        return ret\n    except Exception as why:\n        raise_failure_explanation('BITMEX', why, {\"\": r})\n\n\ndef deribit_symbols() -> Dict[str, str]:\n    url = r = None\n    ret = {}\n    try:\n        # TODO: get currencies from https://www.deribit.com/api/v2/public/get_currencies\n        currencies = ['BTC', 'ETH']\n        for c in currencies:\n            url = f\"https://www.deribit.com/api/v2/public/get_instruments?currency={c}&expired=false\"\n            r = requests.get(url)\n            for entry in r.json()['result']:\n                split = entry['instrument_name'].split(\"-\")\n                normalized = split[0] + SYMBOL_SEP + entry['quote_currency'] + \"-\" + '-'.join(split[1:])\n                ret[normalized] = entry['instrument_name']\n                _exchange_info[DERIBIT]['tick_size'][normalized] = entry['tick_size']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('DERIBIT', why, {url: r})\n\n\ndef kraken_future_symbols() -> Dict[str, str]:\n    r = None\n    ret = {}\n    try:\n        r = requests.get('https://futures.kraken.com/derivatives/api/v3/instruments')\n        data = r.json()['instruments']\n        for entry in data:\n            if not entry['tradeable']:\n                continue\n            normalized = entry['symbol'].upper().replace(\"_\", \"-\")\n            symbol = normalized[3:6] + SYMBOL_SEP + normalized[6:9]\n            normalized = normalized.replace(normalized[3:9], symbol)\n            normalized = normalized.replace('XBT', 'BTC')\n\n            _exchange_info[KRAKEN_FUTURES]['tick_size'][normalized] = entry['tickSize']\n            _exchange_info[KRAKEN_FUTURES]['contract_size'][normalized] = entry['contractSize']\n            _exchange_info[KRAKEN_FUTURES]['underlying'][normalized] = entry['underlying']\n            _exchange_info[KRAKEN_FUTURES]['product_type'][normalized] = _kraken_futures_product_type[normalized[:2]]\n            ret[normalized] = entry['symbol']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('KRAKEN_FUTURES', why, {\"\": r})\n\n\ndef probit_symbols() -> Dict[str, str]:\n    # doc: https://docs-en.probit.com/reference-link/market\n    r = None\n    try:\n        r = requests.get('https://api.probit.com/api/exchange/v1/market')\n        return {entry['id']: entry['id'] for entry in r.json()['data']}\n    except Exception as why:\n        raise_failure_explanation('PROBIT', why, {\"\": r})\n\n\ndef coingecko_normalize_symbol(symbol: str) -> str:\n    # keep digits, letters and dots, replace others by space\n    symbol = ''.join(c if c.isalnum() or c in ('.', '+') else ' ' for c in symbol)\n    return coingecko_normalize(symbol.upper())\n\n\ndef coingecko_normalize_name(name: str) -> str:\n    # keep digits and letters, replace others by space (except when only composed by upper case letters, digits and dots)\n    if not all(c.isupper() or c.isdigit() or c == '.' for c in name):\n        name = ''.join(c if c.isalnum() else ' ' for c in name)\n    return coingecko_normalize(name)\n\n\ndef coingecko_normalize(sym: str) -> str:\n    sym = sym.strip()\n    # do not concatenate numbers => separate them with a dot\n    sym = list(sym)\n    if len(sym) > 4:\n        for i in range(2, len(sym) - 1):\n            if sym[i] == ' ' and sym[i - 1].isdigit() and sym[i + 1].isdigit():\n                sym[i] = '.'\n    sym = ''.join(sym)\n    # concatenate space-separated words => use CamelCase to distinguish the words\n    if ' ' in sym:\n        if sum(c.islower() for c in sym):  # if there is at least one lower case letter\n            sym = ' '.join(word[0].upper() + word[1:] for word in sym.split())  # Just capitalize initial letter of each word\n        else:  # CoinGecko may provide full upper-case as for \"THE STONE COIN\"\n            sym = string.capwords(sym)  # capwords converts \"THE STONE COIN\" to \"The Stone Coin\"\n        sym = sym.replace(' ', '')  # concatenate words\n    return sym\n\n\ndef is_name_short(coin: dict) -> bool:\n    \"\"\"return True if the coin name is enough short compared to the coin symbol.\"\"\"\n    return len(coin['name']) <= max(5, len(coin['symbol']) + 1)\n\n\ndef has_many_caps(name: str) -> bool:\n    \"\"\"return True if the symbol contains enough upper case letters, False if empty.\"\"\"\n    return str and sum(c.islower() for c in name) < (len(name) / 2)\n\n\ndef coingecko_normalize_all(coin: dict):\n    SYMBOL_TO_NORMALIZED = {'miota': 'IOTA'}\n    normalized = SYMBOL_TO_NORMALIZED.get(coin['symbol'])\n    if normalized:\n        coin['ns'] = coin['nn'] = normalized\n        return normalized\n\n    # ns = normalized symbol, nn = normalized name\n    coin['ns'] = coingecko_normalize_symbol(coin['symbol'])\n\n    ID_SUFFIX = '-bitcoin-token'\n    if coin['id'][-len(ID_SUFFIX):] == ID_SUFFIX:\n        coin['nn'] = 'BTC' + coin['ns']\n        return coin['nn']\n\n    name = coin['name']\n\n    prefixes = ('The ', 'the ')\n    for p in prefixes:\n        if name[:len(p)] == p:\n            coin['reduced-name'] = True\n            name = name[len(p):]\n            break\n\n    suffixes = ('coin', 'coins', 'money', 'finance', 'protocol', 'reward', 'rewards', 'token')\n    for s in suffixes:\n        if len(name) > len(s) and name[-len(s):].lower() == s:\n            # but keep suffix when lower-case concatenated\n            if name[-len(s)].islower() and name[-len(s) - 1] != ' ':\n                continue\n            # also keep suffix to avoid confusing nam: \"Bitcoin Token\" -> \"Bitcoin\"\n            if name[:-len(s)].strip().lower() == 'bitcoin':\n                continue\n            coin['reduced-name'] = True\n            name = name[:-len(s)]\n            break\n\n    coin['nn'] = coingecko_normalize_name(name)\n\n    if len(coin['nn']) < len(coin['ns']):\n        if 'reduced-name' in coin:\n            coin['reduced-name'] = False\n            name = coin['name']\n            coin['nn'] = coingecko_normalize_name(name)\n        elif not has_many_caps(name):\n            return coin['ns']\n\n    if not coin['ns']:  # coin['symbol'] may be an emoji that is striped when normalized\n        return coin['nn']\n\n    if coin.get('reduced-name') and coin['ns'].upper() != coin['nn'].upper():\n        return coin['ns']\n\n    i = coin['nn'].find('.')  # if there is a dot in normalized name => prefer the normalized symbol\n    if i >= 0:\n        if i > 1 and coin['nn'][i - 1].isdigit() and coin['nn'][i + 1].isdigit():\n            pass  # except when the dot separates digits\n        else:\n            return coin['ns']\n\n    if is_name_short(coin) and has_many_caps(name):\n        return coin['nn']\n\n    if 1.5 * len(coin['ns']) > len(coin['nn']) and any(c.islower() for c in coin['ns']):\n        return coin['nn']\n\n    return coin['ns']\n\n\ndef coingecko_symbols() -> Dict[str, str]:\n    r = None\n    intermediate = defaultdict(list)\n    try:\n        r = requests.get('https://api.coingecko.com/api/v3/coins/list')\n        all_coins = r.json()\n        # First pass: generate & compare normalized symbol/name, and then select the most pertinent\n        for coin in all_coins:\n            normalized = coingecko_normalize_all(coin)\n            intermediate[normalized].append(coin)\n            # Above line keeps together the coins having the same normalized symbol.\n            # To reduce collision, the coin['name'] is sometimes used in lieu of the coin['symbol'].\n            # The coin['name'] is not capitalized because lower case letters may be meaningful: cETH, yUSD, DATx, zLOT\n    except Exception as why:\n        raise_failure_explanation('COINGECKO', why, {\"\": r})\n\n    final = coingecko_second_pass(intermediate)\n    return coingecko_third_pass(final)\n\n\ndef coingecko_second_pass(intermediate: Dict[str, List[dict]]) -> Dict[str, List[dict]]:\n    # Second pass: fixes most of the symbol collisions\n    final = defaultdict(list)\n    for normalized, coins in intermediate.items():\n        if len(coins) == 1:\n            final[normalized].append(coins[0])\n            continue\n        set_normalized = False\n        for i in range(len(coins)):\n            if normalized == coins[i]['nn']:\n                coin = coins.pop(i)\n                final[normalized].append(coin)\n                set_normalized = True\n                break\n        rest: List[dict] = []\n        for coin in coins:\n            if '%' in coin['name']:\n                if len(coins) == 1:\n                    n = coin['ns']\n                else:\n                    n = coingecko_normalize_name(coin['id'])\n                final[n].append(coin)\n            else:\n                rest.append(coin)\n        if not rest:\n            continue\n        if not set_normalized:\n            rest.sort(key=lambda coin: len(coin['nn']), reverse=True)  # sort by the length of the normalized name\n            coin = rest.pop(0)\n            final[normalized].append(coin)\n        for coin in rest:\n            if coin['nn'] not in intermediate:\n                n = coin['nn']\n            elif coin.get('reduced-name'):\n                n = coingecko_normalize_name(coin['name'])\n            else:\n                n = coingecko_normalize_name(coin['id'])\n            final[n].append(coin)\n    return final\n\n\ndef coingecko_third_pass(final: Dict[str, List[dict]]) -> Dict[str, str]:\n    # Third pass: fixes some remaining collisions and fills the result\n    symbols = {}\n    for normalized, coins in final.items():\n        if len(coins) == 1:\n            symbols[normalized] = coins[0]['id']\n            continue\n        set_normalized = False\n        for i in range(len(coins)):\n            if normalized == coins[i]['nn']:\n                coin = coins.pop(i)\n                symbols[normalized] = coin['id']\n                set_normalized = True\n                break\n        rest: List[dict] = []\n        for coin in coins:\n            if '%' in coin['name']:\n                if len(coins) == 1:\n                    n = coin['ns']\n                else:\n                    n = coingecko_normalize_name(coin['id'])\n                symbols[n] = coin['id']\n            else:\n                rest.append(coin)\n        if not rest:\n            continue\n        if not set_normalized:\n            rest.sort(key=lambda coin: len(coin['nn']), reverse=True)  # sort by the length of the normalized name\n            coin = rest.pop(0)\n            symbols[normalized] = coin['id']\n        for coin in rest:\n            if coin['nn'] not in final:\n                n = coin['nn']\n            elif coin.get('reduced-name'):\n                n = coingecko_normalize_name(coin['name'])\n            else:\n                n = coingecko_normalize_name(coin['id'])\n            symbols[n] = coin['id']\n    return symbols\n\n\ndef whale_alert_coins(key_id: str) -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get(f'https://api.whale-alert.io/v1/status?api_key={key_id}')\n        # Same symbols, but on different blockchains (for instance USDT), are naturally overwritten.\n        return {s.upper(): s for b in r.json()['blockchains'] for s in b['symbols'] if s}\n    except Exception as why:\n        raise_failure_explanation('WHALES_ALERT', why, {\"\": r})\n\n\n_exchange_function_map = {\n    BITFINEX: bitfinex_symbols,\n    BITFLYER: bitflyer_symbols,\n    COINBASE: coinbase_symbols,\n    GEMINI: gemini_symbols,\n    HITBTC: hitbtc_symbols,\n    POLONIEX: poloniex_symbols,\n    PROBIT: probit_symbols,\n    BITSTAMP: bitstamp_symbols,\n    KRAKEN: kraken_symbols,\n    KRAKEN + 'REST': kraken_rest_symbols,\n    BINANCE: binance_symbols,\n    BINANCE_US: binance_us_symbols,\n    BINANCE_FUTURES: binance_futures_symbols,\n    BINANCE_DELIVERY: binance_delivery_symbols,\n    BLOCKCHAIN: blockchain_symbols,\n    EXX: exx_symbols,\n    HUOBI: huobi_symbols,\n    HUOBI_DM: huobi_dm_symbols,\n    HUOBI_SWAP: huobi_swap_symbols,\n    OKCOIN: okcoin_symbols,\n    OKEX: okex_symbols,\n    BYBIT: bybit_symbols,\n    FTX: ftx_symbols,\n    FTX_US: ftx_us_symbols,\n    BITTREX: bittrex_symbols,\n    BITCOINCOM: bitcoincom_symbols,\n    BITMAX: bitmax_symbols,\n    UPBIT: upbit_symbols,\n    GATEIO: gateio_symbols,\n    BITMEX: bitmex_symbols,\n    DERIBIT: deribit_symbols,\n    KRAKEN_FUTURES: kraken_future_symbols,\n    COINGECKO: coingecko_symbols,\n    WHALE_ALERT: whale_alert_coins\n}\n",
        "source_code_len": 30534,
        "target_code": "associated with this software.\n'''\nfrom typing import Dict, Tuple\n\n\nclass _Symbols:\n    def __init__(self):\n        self.data = {}\n\n    def set(self, exchange: str, normalized: dict, exchange_info: dict):\n        self.data[exchange] = {}\n        self.data[exchange]['normalized'] = normalized\n        self.data[exchange]['info'] = exchange_info\n\n    def get(self, exchange: str) -> Tuple[Dict, Dict]:\n        return self.data[exchange]['normalized'], self.data[exchange]['info']\n\n    def populated(self, exchange: str) -> bool:\n        return exchange in self.data\n\n\nSymbols = _Symbols()\n",
        "target_code_len": 588,
        "diff_format": "@@ -5,845 +5,22 @@\n associated with this software.\n+'''\n+from typing import Dict, Tuple\n \n \n-Symbol generation code for exchanges\n-'''\n+class _Symbols:\n+    def __init__(self):\n+        self.data = {}\n \n-import logging\n-import string\n-import time\n-from collections import defaultdict\n-from typing import Dict, List, Optional, Tuple\n+    def set(self, exchange: str, normalized: dict, exchange_info: dict):\n+        self.data[exchange] = {}\n+        self.data[exchange]['normalized'] = normalized\n+        self.data[exchange]['info'] = exchange_info\n \n-import requests\n-from requests import Response\n+    def get(self, exchange: str) -> Tuple[Dict, Dict]:\n+        return self.data[exchange]['normalized'], self.data[exchange]['info']\n \n-from cryptofeed.defines import *\n+    def populated(self, exchange: str) -> bool:\n+        return exchange in self.data\n \n \n-LOG = logging.getLogger('feedhandler')\n-\n-SYMBOL_SEP = '-'\n-\n-_symbols_retrieval_cache: Dict[str, Dict[str, str]] = {}\n-_exchange_info = defaultdict(lambda: defaultdict(dict))\n-\n-\n-_kraken_futures_product_type = {\n-    'FI': 'Inverse Futures',\n-    'FV': 'Vanilla Futures',\n-    'PI': 'Perpetual Inverse Futures',\n-    'PV': 'Perpetual Vanilla Futures',\n-    'IN': 'Real Time Index',\n-    'RR': 'Reference Rate',\n-}\n-\n-\n-def raise_failure_explanation(feed_id: str, exception: BaseException, responses: Dict[str, Optional[Response]]):\n-    LOG.critical('%s: encountered %r while processing response from exchange API', feed_id, exception)\n-    if len(responses) > 1:\n-        LOG.critical('%s: content of one of the %s responses was unexpected', feed_id, len(responses))\n-    for url, r in responses.items():\n-        if url:\n-            LOG.critical('%s: requested URL: %s', feed_id, url)\n-        if r:\n-            LOG.critical('%s: unexpected response: %s', feed_id, r.text)\n-    raise ValueError(f'Cryptofeed stopped because of an unexpected response from {feed_id}') from exception\n-\n-\n-def set_symbol_separator(separator: str):\n-    global SYMBOL_SEP\n-    SYMBOL_SEP = separator\n-\n-\n-def get_symbol_separator() -> str:\n-    global SYMBOL_SEP\n-    return SYMBOL_SEP\n-\n-\n-def gen_symbols(exchange: str, key_id=None) -> Dict[str, str]:\n-    if exchange not in _symbols_retrieval_cache:\n-        LOG.info(\"%s: Getting list of symbols\", exchange)\n-        symbols = _exchange_function_map[exchange](key_id) if key_id else _exchange_function_map[exchange]()\n-        LOG.info(\"%s: %s symbols\", exchange, len(symbols))\n-\n-        # log all retrieved symbols using debug level\n-        for normalized, exch_sym in sorted(symbols.items()):\n-            LOG.debug('%s: id-from-exch -> normalized: %-35s-> %s', exchange, exch_sym, normalized)\n-\n-        _symbols_retrieval_cache[exchange] = symbols\n-    return _symbols_retrieval_cache[exchange]\n-\n-\n-def _binance_symbols(endpoint: str, exchange: str):\n-    r = None\n-    try:\n-        ret = {}\n-        r = requests.get(endpoint)\n-        for symbol in r.json()['symbols']:\n-            if symbol.get('status', 'TRADING') != \"TRADING\":\n-                continue\n-            if symbol.get('contractStatus', 'TRADING') != \"TRADING\":\n-                continue\n-            split = len(symbol['baseAsset'])\n-            normalized = symbol['symbol'][:split] + SYMBOL_SEP + symbol['symbol'][split:]\n-            ret[normalized] = symbol['symbol']\n-            _exchange_info[exchange]['tick_size'][normalized] = symbol['filters'][0]['tickSize']\n-            if \"contractType\" in symbol:\n-                _exchange_info[exchange]['contract_type'][normalized] = symbol['contractType']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation(exchange, why, {endpoint: r})\n-\n-\n-def binance_symbols() -> Dict[str, str]:\n-    return _binance_symbols('https://api.binance.com/api/v3/exchangeInfo', BINANCE)\n-\n-\n-def binance_us_symbols() -> Dict[str, str]:\n-    return _binance_symbols('https://api.binance.us/api/v3/exchangeInfo', BINANCE_US)\n-\n-\n-def binance_futures_symbols() -> Dict[str, str]:\n-    base = _binance_symbols('https://fapi.binance.com/fapi/v1/exchangeInfo', BINANCE_FUTURES)\n-    add = {}\n-    for symbol, orig in base.items():\n-        if \"_\" in orig:\n-            continue\n-        add[f\"{symbol}-PINDEX\"] = f\"p{orig}\"\n-    base.update(add)\n-    return base\n-\n-\n-def binance_delivery_symbols() -> Dict[str, str]:\n-    return _binance_symbols('https://dapi.binance.com/dapi/v1/exchangeInfo', BINANCE_DELIVERY)\n-\n-\n-def bitfinex_symbols() -> Dict[str, str]:\n-    # doc: https://docs.bitfinex.com/docs/ws-general#supported-pairs\n-    r1 = r2 = None\n-    try:\n-        r1 = requests.get('https://api.bitfinex.com/v2/tickers?symbols=ALL')\n-        r2 = requests.get('https://api-pub.bitfinex.com/v2/conf/pub:map:currency:sym')\n-        tickers: List[List[str]] = r1.json()\n-        norm: List[Tuple[str, str]] = r2.json()[0]\n-        norm: Dict[str, str] = dict(norm)\n-        for k, v in dict(norm).items():\n-            if k[-2:] == 'F0' or '-' in v:  # Do not convert BTCF0 -> BTC or PBTCETH -> PBTC-ETH\n-                del norm[k]\n-        norm['BCHN'] = 'BCH'  # Bitfinex uses BCHN, other exchanges use BCH\n-\n-        ret = {}\n-        for symbol in [t[0] for t in tickers]:\n-            if symbol[0] == 'f':\n-                normalized = norm.get(symbol[1:], symbol[1:])\n-            else:\n-                if len(symbol) == 7:\n-                    base, quote = symbol[1:4], symbol[4:]\n-                else:\n-                    base, quote = symbol[1:].split(':')\n-                    assert ':' in symbol\n-                normalized = norm.get(base, base) + SYMBOL_SEP + norm.get(quote, quote)\n-            ret[normalized.upper()] = symbol\n-        return ret\n-    except ValueError as why:\n-        raise_failure_explanation('BITFINEX', why, {\"tickers?symbols=ALL\": r1, \"pub:map:currency:sym\": r2})\n-\n-\n-def bitflyer_symbols() -> Dict[str, str]:\n-    endpoint = r = None\n-    try:\n-        ret = {}\n-        endpoints = ['https://api.bitflyer.com/v1/getmarkets/eu', 'https://api.bitflyer.com/v1/getmarkets/usa', 'https://api.bitflyer.com/v1/getmarkets']\n-        for endpoint in endpoints:\n-            r = requests.get(endpoint)\n-            for entry in r.json():\n-                normalized = entry['product_code'].replace(\"_\", SYMBOL_SEP)\n-                ret[normalized] = entry['product_code']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('BITFLYER', why, {endpoint: r})\n-\n-\n-def bybit_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.bybit.com/v2/public/symbols')\n-        ret = {}\n-        for symbol in r.json()['result']:\n-            quote = symbol['quote_currency']\n-            if not symbol['name'].endswith(quote):\n-                base, contract = symbol['name'].split(quote)\n-                normalized = f\"{base}{SYMBOL_SEP}{quote}-{contract}\"\n-            else:\n-                normalized = f\"{symbol['base_currency']}{SYMBOL_SEP}{quote}\"\n-            ret[normalized] = symbol['name']\n-            _exchange_info[BYBIT]['tick_size'][normalized] = symbol['price_filter']['tick_size']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('BYBIT', why, {\"\": r})\n-\n-\n-def _ftx_helper(endpoint: str, exchange: str):\n-    r = None\n-    try:\n-        r = requests.get(endpoint)\n-        ret = {}\n-        for data in r.json()['result']:\n-            normalized = data['name'].replace(\"/\", SYMBOL_SEP)\n-            symbol = data['name']\n-            ret[normalized] = symbol\n-            _exchange_info[exchange]['tick_size'][normalized] = data['priceIncrement']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation(exchange, why, {endpoint: r})\n-\n-\n-def ftx_symbols() -> Dict[str, str]:\n-    return _ftx_helper('https://ftx.com/api/markets', FTX)\n-\n-\n-def ftx_us_symbols() -> Dict[str, str]:\n-    return _ftx_helper('https://ftx.us/api/markets', FTX_US)\n-\n-\n-def coinbase_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.pro.coinbase.com/products')\n-        ret = {}\n-        for data in r.json():\n-            normalized = data['id'].replace(\"-\", SYMBOL_SEP)\n-            ret[normalized] = data['id']\n-            _exchange_info[COINBASE]['tick_size'][normalized] = data['quote_increment']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('COINBASE', why, {\"\": r})\n-\n-\n-def gemini_symbols(*args) -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.gemini.com/v1/symbols')\n-        ret = {}\n-        for symbol in r.json():\n-            std = f\"{symbol[:-3]}{SYMBOL_SEP}{symbol[-3:]}\"\n-            std = std.upper()\n-            ret[std] = symbol.upper()\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('GEMINI', why, {\"\": r})\n-\n-\n-def hitbtc_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        ret = {}\n-        r = requests.get('https://api.hitbtc.com/api/2/public/symbol')\n-        for symbol in r.json():\n-            split = len(symbol['baseCurrency'])\n-            normalized = symbol['id'][:split] + SYMBOL_SEP + symbol['id'][split:]\n-            ret[normalized] = symbol['id']\n-            _exchange_info[HITBTC]['tick_size'][normalized] = symbol['tickSize']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('HITBTC', why, {\"\": r})\n-\n-\n-def poloniex_id_symbol_mapping():\n-    r = None\n-    try:\n-        r = requests.get('https://poloniex.com/public?command=returnTicker')\n-        symbols = r.json()\n-        ret = {}\n-        for symbol in symbols:\n-            ret[symbols[symbol]['id']] = symbol\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('POLONIEX', why, {\"\": r})\n-\n-\n-def poloniex_symbols() -> Dict[str, str]:\n-    ret = {}\n-    for _, value in poloniex_id_symbol_mapping().items():\n-        std = value.replace(\"STR\", \"XLM\")\n-        quote, base = std.split(\"_\")\n-        ret[quote + SYMBOL_SEP + base] = value\n-    return ret\n-\n-\n-def bitstamp_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://www.bitstamp.net/api/v2/trading-pairs-info/')\n-        ret = {}\n-        for data in r.json():\n-            normalized = data['name'].replace(\"/\", SYMBOL_SEP)\n-            symbol = data['url_symbol']\n-            ret[normalized] = symbol\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('BITSTAMP', why, {\"\": r})\n-\n-\n-def kraken_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.kraken.com/0/public/AssetPairs')\n-        data = r.json()\n-        ret = {}\n-        for symbol in data['result']:\n-            if 'wsname' not in data['result'][symbol] or '.d' in symbol:\n-                # https://blog.kraken.com/post/259/introducing-the-kraken-dark-pool/\n-                # .d is for dark pool symbols\n-                continue\n-\n-            base, quote = data['result'][symbol]['wsname'].split(\"/\")\n-\n-            normalized = f\"{base}{SYMBOL_SEP}{quote}\"\n-            exch = data['result'][symbol]['wsname']\n-            normalized = normalized.replace('XBT', 'BTC')\n-            normalized = normalized.replace('XDG', 'DOG')\n-            ret[normalized] = exch\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('KRAKEN', why, {\"\": r})\n-\n-\n-def kraken_rest_symbols() -> Dict[str, str]:\n-    return {normalized: exchange.replace(\"/\", \"\") for normalized, exchange in kraken_symbols().items()}\n-\n-\n-def exx_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.exx.com/data/v1/tickers')\n-        exchange = [key.upper() for key in r.json().keys()]\n-        symbols = [key.replace(\"_\", SYMBOL_SEP) for key in exchange]\n-        return dict(zip(symbols, exchange))\n-    except Exception as why:\n-        raise_failure_explanation('EXX', why, {\"\": r})\n-\n-\n-def huobi_common_symbols(url: str):\n-    r = None\n-    try:\n-        r = requests.get(url)\n-        ret = {}\n-        for e in r.json()['data']:\n-            if e['state'] == 'offline':\n-                continue\n-            normalized = f\"{e['base-currency'].upper()}{SYMBOL_SEP}{e['quote-currency'].upper()}\"\n-            symbol = f\"{e['base-currency']}{e['quote-currency']}\"\n-            ret[normalized] = symbol\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('HUOBI', why, {url: r})\n-\n-\n-def huobi_symbols() -> Dict[str, str]:\n-    return huobi_common_symbols('https://api.huobi.pro/v1/common/symbols')\n-\n-\n-def huobi_us_symbols() -> Dict[str, str]:\n-    return huobi_common_symbols('https://api.huobi.com/v1/common/symbols')\n-\n-\n-def huobi_dm_symbols() -> Dict[str, str]:\n-    \"\"\"\n-    Mapping is, for instance: {\"BTC_CW\":\"BTC190816\"}\n-    See comments in exchange/huobi_dm.py\n-    \"\"\"\n-    mapping = {\n-        \"this_week\": \"CW\",\n-        \"next_week\": \"NW\",\n-        \"quarter\": \"CQ\",\n-        \"next_quarter\": \"NQ\"\n-    }\n-    r = None\n-    try:\n-        r = requests.get('https://www.hbdm.com/api/v1/contract_contract_info')\n-        symbols = {}\n-        for e in r.json()['data']:\n-            symbols[f\"{e['symbol']}_{mapping[e['contract_type']]}\"] = e['contract_code']\n-            _exchange_info[HUOBI_DM]['tick_size'][e['contract_code']] = e['price_tick']\n-            _exchange_info[HUOBI_DM]['short_code_mappings'][f\"{e['symbol']}_{mapping[e['contract_type']]}\"] = e['contract_code']\n-        return symbols\n-    except Exception as why:\n-        raise_failure_explanation('HUOBI_DM', why, {\"\": r})\n-\n-\n-def huobi_swap_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.hbdm.com/swap-api/v1/swap_contract_info')\n-        symbols = {}\n-        for e in r.json()['data']:\n-            symbols[e['contract_code']] = e['contract_code']\n-            _exchange_info[HUOBI_SWAP]['tick_size'][e['contract_code']] = e['price_tick']\n-        return symbols\n-    except Exception as why:\n-        raise_failure_explanation('HUOBI_SWAP', why, {\"\": r})\n-\n-\n-def okcoin_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://www.okcoin.com/api/spot/v3/instruments')\n-        ret = {}\n-        for e in r.json():\n-            ret[e['instrument_id']] = e['instrument_id']\n-            _exchange_info[OKCOIN]['tick_size'][e['instrument_id']] = e['tick_size']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('OKCOIN', why, {\"\": r})\n-\n-\n-def okex_symbols(*args) -> Dict[str, str]:\n-    urls = ['https://www.okex.com/api/spot/v3/instruments',\n-            'https://www.okex.com/api/swap/v3/instruments',\n-            'https://www.okex.com/api/futures/v3/instruments']\n-    urls = urls + okex_compute_option_urls_from_underlyings()\n-\n-    symbols: Dict[str, str] = {}\n-    for u in urls:\n-        time.sleep(0.2)\n-        symbols.update(okex_symbols_from_one_url(u))\n-\n-    for symbol in symbols:\n-        instrument_type = 'futures'\n-        dash_count = symbol.count(get_symbol_separator())\n-        if dash_count == 1:  # BTC-USDT\n-            instrument_type = 'spot'\n-        if dash_count == 4:  # BTC-USD-201225-35000-P\n-            instrument_type = 'option'\n-        if symbol[-4:] == \"SWAP\":  # BTC-USDT-SWAP\n-            instrument_type = 'swap'\n-\n-        _exchange_info[OKEX]['instrument_type'][symbol] = instrument_type\n-\n-    return symbols\n-\n-\n-def okex_compute_option_urls_from_underlyings() -> List[str]:\n-    url = 'https://www.okex.com/api/option/v3/underlying'\n-    r = None\n-    try:\n-        r = requests.get(url)\n-        return [f'https://www.okex.com/api/option/v3/instruments/{underlying}' for underlying in r.json()]\n-    except Exception as why:\n-        raise_failure_explanation('OKEX', why, {url: r})\n-\n-\n-def okex_symbols_from_one_url(url: str) -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get(url)\n-        ret = {}\n-        for e in r.json():\n-            ret[e['instrument_id']] = e['instrument_id']\n-            _exchange_info[OKEX]['tick_size'][e['instrument_id']] = e['tick_size']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('OKEX', why, {url: r})\n-\n-\n-def bittrex_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.bittrex.com/api/v1.1/public/getmarkets')\n-        r = r.json()['result']\n-        return {f\"{e['MarketCurrency']}{SYMBOL_SEP}{e['BaseCurrency']}\": e['MarketName'] for e in r if e['IsActive']}\n-    except Exception as why:\n-        raise_failure_explanation('BITTREX', why, {\"\": r})\n-\n-\n-def bitcoincom_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.exchange.bitcoin.com/api/2/public/symbol')\n-        return {f\"{data['baseCurrency']}{SYMBOL_SEP}{data['quoteCurrency'].replace('USD', 'USDT')}\": data['id'] for data in r.json()}\n-    except Exception as why:\n-        raise_failure_explanation('BITCOINCOM', why, {\"\": r})\n-\n-\n-def bitmax_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://bitmax.io/api/pro/v1/products')\n-        ret = {}\n-        for entry in r.json()['data']:\n-            # Only \"Normal\" status symbols are tradeable\n-            if entry['status'] == 'Normal':\n-                normalized = f\"{entry['baseAsset']}{SYMBOL_SEP}{entry['quoteAsset']}\"\n-                ret[normalized] = entry['symbol']\n-                _exchange_info[BITMAX]['tick_size'][normalized] = entry['tickSize']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('BITMAX', why, {\"\": r})\n-\n-\n-def upbit_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.upbit.com/v1/market/all')\n-        return {f\"{data['market'].split('-')[1]}{SYMBOL_SEP}{data['market'].split('-')[0]}\": data['market'] for data in r.json()}\n-    except Exception as why:\n-        raise_failure_explanation('UPBIT', why, {\"\": r})\n-\n-\n-def blockchain_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get(\"https://api.blockchain.com/mercury-gateway/v1/instruments\")\n-        return {data[\"symbol\"].replace(\"-\", SYMBOL_SEP): data[\"symbol\"] for data in r.json()}\n-    except Exception as why:\n-        raise_failure_explanation('BLOCKCHAIN', why, {\"\": r})\n-\n-\n-def gateio_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get(\"https://api.gateio.ws/api/v4/spot/currency_pairs\")\n-        return {data[\"id\"].replace(\"_\", SYMBOL_SEP): data['id'] for data in r.json()}\n-    except Exception as why:\n-        raise_failure_explanation('GATEIO', why, {\"\": r})\n-\n-\n-def bitmex_symbols() -> Dict[str, str]:\n-    r = None\n-    ret = {}\n-    try:\n-        r = requests.get(\"https://www.bitmex.com/api/v1/instrument/active\")\n-        for entry in r.json():\n-            components = []\n-            components.append(entry['rootSymbol'])\n-            components.append(entry['quoteCurrency'])\n-\n-            if entry['expiry']:\n-                components.append(entry['symbol'][-3:])\n-\n-            normalized = SYMBOL_SEP.join(components)\n-            normalized = normalized.replace(\"XBT\", \"BTC\")\n-            ret[normalized] = entry['symbol']\n-            _exchange_info[BITMEX]['tick_size'][normalized] = entry['tickSize']\n-\n-            if entry['expiry']:\n-                _exchange_info[BITMEX]['expiry'][normalized] = entry['expiry']\n-\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('BITMEX', why, {\"\": r})\n-\n-\n-def deribit_symbols() -> Dict[str, str]:\n-    url = r = None\n-    ret = {}\n-    try:\n-        # TODO: get currencies from https://www.deribit.com/api/v2/public/get_currencies\n-        currencies = ['BTC', 'ETH']\n-        for c in currencies:\n-            url = f\"https://www.deribit.com/api/v2/public/get_instruments?currency={c}&expired=false\"\n-            r = requests.get(url)\n-            for entry in r.json()['result']:\n-                split = entry['instrument_name'].split(\"-\")\n-                normalized = split[0] + SYMBOL_SEP + entry['quote_currency'] + \"-\" + '-'.join(split[1:])\n-                ret[normalized] = entry['instrument_name']\n-                _exchange_info[DERIBIT]['tick_size'][normalized] = entry['tick_size']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('DERIBIT', why, {url: r})\n-\n-\n-def kraken_future_symbols() -> Dict[str, str]:\n-    r = None\n-    ret = {}\n-    try:\n-        r = requests.get('https://futures.kraken.com/derivatives/api/v3/instruments')\n-        data = r.json()['instruments']\n-        for entry in data:\n-            if not entry['tradeable']:\n-                continue\n-            normalized = entry['symbol'].upper().replace(\"_\", \"-\")\n-            symbol = normalized[3:6] + SYMBOL_SEP + normalized[6:9]\n-            normalized = normalized.replace(normalized[3:9], symbol)\n-            normalized = normalized.replace('XBT', 'BTC')\n-\n-            _exchange_info[KRAKEN_FUTURES]['tick_size'][normalized] = entry['tickSize']\n-            _exchange_info[KRAKEN_FUTURES]['contract_size'][normalized] = entry['contractSize']\n-            _exchange_info[KRAKEN_FUTURES]['underlying'][normalized] = entry['underlying']\n-            _exchange_info[KRAKEN_FUTURES]['product_type'][normalized] = _kraken_futures_product_type[normalized[:2]]\n-            ret[normalized] = entry['symbol']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('KRAKEN_FUTURES', why, {\"\": r})\n-\n-\n-def probit_symbols() -> Dict[str, str]:\n-    # doc: https://docs-en.probit.com/reference-link/market\n-    r = None\n-    try:\n-        r = requests.get('https://api.probit.com/api/exchange/v1/market')\n-        return {entry['id']: entry['id'] for entry in r.json()['data']}\n-    except Exception as why:\n-        raise_failure_explanation('PROBIT', why, {\"\": r})\n-\n-\n-def coingecko_normalize_symbol(symbol: str) -> str:\n-    # keep digits, letters and dots, replace others by space\n-    symbol = ''.join(c if c.isalnum() or c in ('.', '+') else ' ' for c in symbol)\n-    return coingecko_normalize(symbol.upper())\n-\n-\n-def coingecko_normalize_name(name: str) -> str:\n-    # keep digits and letters, replace others by space (except when only composed by upper case letters, digits and dots)\n-    if not all(c.isupper() or c.isdigit() or c == '.' for c in name):\n-        name = ''.join(c if c.isalnum() else ' ' for c in name)\n-    return coingecko_normalize(name)\n-\n-\n-def coingecko_normalize(sym: str) -> str:\n-    sym = sym.strip()\n-    # do not concatenate numbers => separate them with a dot\n-    sym = list(sym)\n-    if len(sym) > 4:\n-        for i in range(2, len(sym) - 1):\n-            if sym[i] == ' ' and sym[i - 1].isdigit() and sym[i + 1].isdigit():\n-                sym[i] = '.'\n-    sym = ''.join(sym)\n-    # concatenate space-separated words => use CamelCase to distinguish the words\n-    if ' ' in sym:\n-        if sum(c.islower() for c in sym):  # if there is at least one lower case letter\n-            sym = ' '.join(word[0].upper() + word[1:] for word in sym.split())  # Just capitalize initial letter of each word\n-        else:  # CoinGecko may provide full upper-case as for \"THE STONE COIN\"\n-            sym = string.capwords(sym)  # capwords converts \"THE STONE COIN\" to \"The Stone Coin\"\n-        sym = sym.replace(' ', '')  # concatenate words\n-    return sym\n-\n-\n-def is_name_short(coin: dict) -> bool:\n-    \"\"\"return True if the coin name is enough short compared to the coin symbol.\"\"\"\n-    return len(coin['name']) <= max(5, len(coin['symbol']) + 1)\n-\n-\n-def has_many_caps(name: str) -> bool:\n-    \"\"\"return True if the symbol contains enough upper case letters, False if empty.\"\"\"\n-    return str and sum(c.islower() for c in name) < (len(name) / 2)\n-\n-\n-def coingecko_normalize_all(coin: dict):\n-    SYMBOL_TO_NORMALIZED = {'miota': 'IOTA'}\n-    normalized = SYMBOL_TO_NORMALIZED.get(coin['symbol'])\n-    if normalized:\n-        coin['ns'] = coin['nn'] = normalized\n-        return normalized\n-\n-    # ns = normalized symbol, nn = normalized name\n-    coin['ns'] = coingecko_normalize_symbol(coin['symbol'])\n-\n-    ID_SUFFIX = '-bitcoin-token'\n-    if coin['id'][-len(ID_SUFFIX):] == ID_SUFFIX:\n-        coin['nn'] = 'BTC' + coin['ns']\n-        return coin['nn']\n-\n-    name = coin['name']\n-\n-    prefixes = ('The ', 'the ')\n-    for p in prefixes:\n-        if name[:len(p)] == p:\n-            coin['reduced-name'] = True\n-            name = name[len(p):]\n-            break\n-\n-    suffixes = ('coin', 'coins', 'money', 'finance', 'protocol', 'reward', 'rewards', 'token')\n-    for s in suffixes:\n-        if len(name) > len(s) and name[-len(s):].lower() == s:\n-            # but keep suffix when lower-case concatenated\n-            if name[-len(s)].islower() and name[-len(s) - 1] != ' ':\n-                continue\n-            # also keep suffix to avoid confusing nam: \"Bitcoin Token\" -> \"Bitcoin\"\n-            if name[:-len(s)].strip().lower() == 'bitcoin':\n-                continue\n-            coin['reduced-name'] = True\n-            name = name[:-len(s)]\n-            break\n-\n-    coin['nn'] = coingecko_normalize_name(name)\n-\n-    if len(coin['nn']) < len(coin['ns']):\n-        if 'reduced-name' in coin:\n-            coin['reduced-name'] = False\n-            name = coin['name']\n-            coin['nn'] = coingecko_normalize_name(name)\n-        elif not has_many_caps(name):\n-            return coin['ns']\n-\n-    if not coin['ns']:  # coin['symbol'] may be an emoji that is striped when normalized\n-        return coin['nn']\n-\n-    if coin.get('reduced-name') and coin['ns'].upper() != coin['nn'].upper():\n-        return coin['ns']\n-\n-    i = coin['nn'].find('.')  # if there is a dot in normalized name => prefer the normalized symbol\n-    if i >= 0:\n-        if i > 1 and coin['nn'][i - 1].isdigit() and coin['nn'][i + 1].isdigit():\n-            pass  # except when the dot separates digits\n-        else:\n-            return coin['ns']\n-\n-    if is_name_short(coin) and has_many_caps(name):\n-        return coin['nn']\n-\n-    if 1.5 * len(coin['ns']) > len(coin['nn']) and any(c.islower() for c in coin['ns']):\n-        return coin['nn']\n-\n-    return coin['ns']\n-\n-\n-def coingecko_symbols() -> Dict[str, str]:\n-    r = None\n-    intermediate = defaultdict(list)\n-    try:\n-        r = requests.get('https://api.coingecko.com/api/v3/coins/list')\n-        all_coins = r.json()\n-        # First pass: generate & compare normalized symbol/name, and then select the most pertinent\n-        for coin in all_coins:\n-            normalized = coingecko_normalize_all(coin)\n-            intermediate[normalized].append(coin)\n-            # Above line keeps together the coins having the same normalized symbol.\n-            # To reduce collision, the coin['name'] is sometimes used in lieu of the coin['symbol'].\n-            # The coin['name'] is not capitalized because lower case letters may be meaningful: cETH, yUSD, DATx, zLOT\n-    except Exception as why:\n-        raise_failure_explanation('COINGECKO', why, {\"\": r})\n-\n-    final = coingecko_second_pass(intermediate)\n-    return coingecko_third_pass(final)\n-\n-\n-def coingecko_second_pass(intermediate: Dict[str, List[dict]]) -> Dict[str, List[dict]]:\n-    # Second pass: fixes most of the symbol collisions\n-    final = defaultdict(list)\n-    for normalized, coins in intermediate.items():\n-        if len(coins) == 1:\n-            final[normalized].append(coins[0])\n-            continue\n-        set_normalized = False\n-        for i in range(len(coins)):\n-            if normalized == coins[i]['nn']:\n-                coin = coins.pop(i)\n-                final[normalized].append(coin)\n-                set_normalized = True\n-                break\n-        rest: List[dict] = []\n-        for coin in coins:\n-            if '%' in coin['name']:\n-                if len(coins) == 1:\n-                    n = coin['ns']\n-                else:\n-                    n = coingecko_normalize_name(coin['id'])\n-                final[n].append(coin)\n-            else:\n-                rest.append(coin)\n-        if not rest:\n-            continue\n-        if not set_normalized:\n-            rest.sort(key=lambda coin: len(coin['nn']), reverse=True)  # sort by the length of the normalized name\n-            coin = rest.pop(0)\n-            final[normalized].append(coin)\n-        for coin in rest:\n-            if coin['nn'] not in intermediate:\n-                n = coin['nn']\n-            elif coin.get('reduced-name'):\n-                n = coingecko_normalize_name(coin['name'])\n-            else:\n-                n = coingecko_normalize_name(coin['id'])\n-            final[n].append(coin)\n-    return final\n-\n-\n-def coingecko_third_pass(final: Dict[str, List[dict]]) -> Dict[str, str]:\n-    # Third pass: fixes some remaining collisions and fills the result\n-    symbols = {}\n-    for normalized, coins in final.items():\n-        if len(coins) == 1:\n-            symbols[normalized] = coins[0]['id']\n-            continue\n-        set_normalized = False\n-        for i in range(len(coins)):\n-            if normalized == coins[i]['nn']:\n-                coin = coins.pop(i)\n-                symbols[normalized] = coin['id']\n-                set_normalized = True\n-                break\n-        rest: List[dict] = []\n-        for coin in coins:\n-            if '%' in coin['name']:\n-                if len(coins) == 1:\n-                    n = coin['ns']\n-                else:\n-                    n = coingecko_normalize_name(coin['id'])\n-                symbols[n] = coin['id']\n-            else:\n-                rest.append(coin)\n-        if not rest:\n-            continue\n-        if not set_normalized:\n-            rest.sort(key=lambda coin: len(coin['nn']), reverse=True)  # sort by the length of the normalized name\n-            coin = rest.pop(0)\n-            symbols[normalized] = coin['id']\n-        for coin in rest:\n-            if coin['nn'] not in final:\n-                n = coin['nn']\n-            elif coin.get('reduced-name'):\n-                n = coingecko_normalize_name(coin['name'])\n-            else:\n-                n = coingecko_normalize_name(coin['id'])\n-            symbols[n] = coin['id']\n-    return symbols\n-\n-\n-def whale_alert_coins(key_id: str) -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get(f'https://api.whale-alert.io/v1/status?api_key={key_id}')\n-        # Same symbols, but on different blockchains (for instance USDT), are naturally overwritten.\n-        return {s.upper(): s for b in r.json()['blockchains'] for s in b['symbols'] if s}\n-    except Exception as why:\n-        raise_failure_explanation('WHALES_ALERT', why, {\"\": r})\n-\n-\n-_exchange_function_map = {\n-    BITFINEX: bitfinex_symbols,\n-    BITFLYER: bitflyer_symbols,\n-    COINBASE: coinbase_symbols,\n-    GEMINI: gemini_symbols,\n-    HITBTC: hitbtc_symbols,\n-    POLONIEX: poloniex_symbols,\n-    PROBIT: probit_symbols,\n-    BITSTAMP: bitstamp_symbols,\n-    KRAKEN: kraken_symbols,\n-    KRAKEN + 'REST': kraken_rest_symbols,\n-    BINANCE: binance_symbols,\n-    BINANCE_US: binance_us_symbols,\n-    BINANCE_FUTURES: binance_futures_symbols,\n-    BINANCE_DELIVERY: binance_delivery_symbols,\n-    BLOCKCHAIN: blockchain_symbols,\n-    EXX: exx_symbols,\n-    HUOBI: huobi_symbols,\n-    HUOBI_DM: huobi_dm_symbols,\n-    HUOBI_SWAP: huobi_swap_symbols,\n-    OKCOIN: okcoin_symbols,\n-    OKEX: okex_symbols,\n-    BYBIT: bybit_symbols,\n-    FTX: ftx_symbols,\n-    FTX_US: ftx_us_symbols,\n-    BITTREX: bittrex_symbols,\n-    BITCOINCOM: bitcoincom_symbols,\n-    BITMAX: bitmax_symbols,\n-    UPBIT: upbit_symbols,\n-    GATEIO: gateio_symbols,\n-    BITMEX: bitmex_symbols,\n-    DERIBIT: deribit_symbols,\n-    KRAKEN_FUTURES: kraken_future_symbols,\n-    COINGECKO: coingecko_symbols,\n-    WHALE_ALERT: whale_alert_coins\n-}\n+Symbols = _Symbols()\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\n\nimport logging\nimport string\nimport time\nfrom collections import defaultdict\nfrom typing import Dict, List, Optional, Tuple\n\nimport requests\nfrom requests import Response\n\nfrom cryptofeed.defines import *\n\n\nLOG = logging.getLogger('feedhandler')\n\nSYMBOL_SEP = '-'\n\n_symbols_retrieval_cache: Dict[str, Dict[str, str]] = {}\n_exchange_info = defaultdict(lambda: defaultdict(dict))\n\n\n_kraken_futures_product_type = {\n    'FI': 'Inverse Futures',\n    'FV': 'Vanilla Futures',\n    'PI': 'Perpetual Inverse Futures',\n    'PV': 'Perpetual Vanilla Futures',\n    'IN': 'Real Time Index',\n    'RR': 'Reference Rate',\n}\n\n\ndef raise_failure_explanation(feed_id: str, exception: BaseException, responses: Dict[str, Optional[Response]]):\n    <IND>LOG.critical('%s: encountered %r while processing response from exchange API', feed_id, exception)\n    if len(responses) > 1:\n        <IND>LOG.critical('%s: content of one of the %s responses was unexpected', feed_id, len(responses))\n    <DED>for url, r in responses.items():\n        <IND>if url:\n            <IND>LOG.critical('%s: requested URL: %s', feed_id, url)\n        <DED>if r:\n            <IND>LOG.critical('%s: unexpected response: %s', feed_id, r.text)\n    <DED><DED>raise ValueError(f'Cryptofeed stopped because of an unexpected response from {feed_id}') from exception\n\n\n<DED>def set_symbol_separator(separator: str):\n    <IND>global SYMBOL_SEP\n    SYMBOL_SEP = separator\n\n\n<DED>def get_symbol_separator() -> str:\n    <IND>global SYMBOL_SEP\n    return SYMBOL_SEP\n\n\n<DED>def gen_symbols(exchange: str, key_id=None) -> Dict[str, str]:\n    <IND>if exchange not in _symbols_retrieval_cache:\n        <IND>LOG.info(\"%s: Getting list of symbols\", exchange)\n        symbols = _exchange_function_map[exchange](key_id) if key_id else _exchange_function_map[exchange]()\n        LOG.info(\"%s: %s symbols\", exchange, len(symbols))\n\n        # log all retrieved symbols using debug level\n        for normalized, exch_sym in sorted(symbols.items()):\n            <IND>LOG.debug('%s: id-from-exch -> normalized: %-35s-> %s', exchange, exch_sym, normalized)\n\n        <DED>_symbols_retrieval_cache[exchange] = symbols\n    <DED>return _symbols_retrieval_cache[exchange]\n\n\n<DED>def _binance_symbols(endpoint: str, exchange: str):\n    <IND>r = None\n    try:\n        <IND>ret = {}\n        r = requests.get(endpoint)\n        for symbol in r.json()['symbols']:\n            <IND>if symbol.get('status', 'TRADING') != \"TRADING\":\n                <IND>continue\n            <DED>if symbol.get('contractStatus', 'TRADING') != \"TRADING\":\n                <IND>continue\n            <DED>split = len(symbol['baseAsset'])\n            normalized = symbol['symbol'][:split] + SYMBOL_SEP + symbol['symbol'][split:]\n            ret[normalized] = symbol['symbol']\n            _exchange_info[exchange]['tick_size'][normalized] = symbol['filters'][0]['tickSize']\n            if \"contractType\" in symbol:\n                <IND>_exchange_info[exchange]['contract_type'][normalized] = symbol['contractType']\n        <DED><DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation(exchange, why, {endpoint: r})\n\n\n<DED><DED>def binance_symbols() -> Dict[str, str]:\n    <IND>return _binance_symbols('https://api.binance.com/api/v3/exchangeInfo', BINANCE)\n\n\n<DED>def binance_us_symbols() -> Dict[str, str]:\n    <IND>return _binance_symbols('https://api.binance.us/api/v3/exchangeInfo', BINANCE_US)\n\n\n<DED>def binance_futures_symbols() -> Dict[str, str]:\n    <IND>base = _binance_symbols('https://fapi.binance.com/fapi/v1/exchangeInfo', BINANCE_FUTURES)\n    add = {}\n    for symbol, orig in base.items():\n        <IND>if \"_\" in orig:\n            <IND>continue\n        <DED>add[f\"{symbol}-PINDEX\"] = f\"p{orig}\"\n    <DED>base.update(add)\n    return base\n\n\n<DED>def binance_delivery_symbols() -> Dict[str, str]:\n    <IND>return _binance_symbols('https://dapi.binance.com/dapi/v1/exchangeInfo', BINANCE_DELIVERY)\n\n\n<DED>def bitfinex_symbols() -> Dict[str, str]:\n    # doc: https://docs.bitfinex.com/docs/ws-general#supported-pairs\n    <IND>r1 = r2 = None\n    try:\n        <IND>r1 = requests.get('https://api.bitfinex.com/v2/tickers?symbols=ALL')\n        r2 = requests.get('https://api-pub.bitfinex.com/v2/conf/pub:map:currency:sym')\n        tickers: List[List[str]] = r1.json()\n        norm: List[Tuple[str, str]] = r2.json()[0]\n        norm: Dict[str, str] = dict(norm)\n        for k, v in dict(norm).items():\n            <IND>if k[-2:] == 'F0' or '-' in v:  # Do not convert BTCF0 -> BTC or PBTCETH -> PBTC-ETH\n                <IND>del norm[k]\n        <DED><DED>norm['BCHN'] = 'BCH'  # Bitfinex uses BCHN, other exchanges use BCH\n\n        ret = {}\n        for symbol in [t[0] for t in tickers]:\n            <IND>if symbol[0] == 'f':\n                <IND>normalized = norm.get(symbol[1:], symbol[1:])\n            <DED>else:\n                <IND>if len(symbol) == 7:\n                    <IND>base, quote = symbol[1:4], symbol[4:]\n                <DED>else:\n                    <IND>base, quote = symbol[1:].split(':')\n                    assert ':' in symbol\n                <DED>normalized = norm.get(base, base) + SYMBOL_SEP + norm.get(quote, quote)\n            <DED>ret[normalized.upper()] = symbol\n        <DED>return ret\n    <DED>except ValueError as why:\n        <IND>raise_failure_explanation('BITFINEX', why, {\"tickers?symbols=ALL\": r1, \"pub:map:currency:sym\": r2})\n\n\n<DED><DED>def bitflyer_symbols() -> Dict[str, str]:\n    <IND>endpoint = r = None\n    try:\n        <IND>ret = {}\n        endpoints = ['https://api.bitflyer.com/v1/getmarkets/eu', 'https://api.bitflyer.com/v1/getmarkets/usa', 'https://api.bitflyer.com/v1/getmarkets']\n        for endpoint in endpoints:\n            <IND>r = requests.get(endpoint)\n            for entry in r.json():\n                <IND>normalized = entry['product_code'].replace(\"_\", SYMBOL_SEP)\n                ret[normalized] = entry['product_code']\n        <DED><DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BITFLYER', why, {endpoint: r})\n\n\n<DED><DED>def bybit_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.bybit.com/v2/public/symbols')\n        ret = {}\n        for symbol in r.json()['result']:\n            <IND>quote = symbol['quote_currency']\n            if not symbol['name'].endswith(quote):\n                <IND>base, contract = symbol['name'].split(quote)\n                normalized = f\"{base}{SYMBOL_SEP}{quote}-{contract}\"\n            <DED>else:\n                <IND>normalized = f\"{symbol['base_currency']}{SYMBOL_SEP}{quote}\"\n            <DED>ret[normalized] = symbol['name']\n            _exchange_info[BYBIT]['tick_size'][normalized] = symbol['price_filter']['tick_size']\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BYBIT', why, {\"\": r})\n\n\n<DED><DED>def _ftx_helper(endpoint: str, exchange: str):\n    <IND>r = None\n    try:\n        <IND>r = requests.get(endpoint)\n        ret = {}\n        for data in r.json()['result']:\n            <IND>normalized = data['name'].replace(\"/\", SYMBOL_SEP)\n            symbol = data['name']\n            ret[normalized] = symbol\n            _exchange_info[exchange]['tick_size'][normalized] = data['priceIncrement']\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation(exchange, why, {endpoint: r})\n\n\n<DED><DED>def ftx_symbols() -> Dict[str, str]:\n    <IND>return _ftx_helper('https://ftx.com/api/markets', FTX)\n\n\n<DED>def ftx_us_symbols() -> Dict[str, str]:\n    <IND>return _ftx_helper('https://ftx.us/api/markets', FTX_US)\n\n\n<DED>def coinbase_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.pro.coinbase.com/products')\n        ret = {}\n        for data in r.json():\n            <IND>normalized = data['id'].replace(\"-\", SYMBOL_SEP)\n            ret[normalized] = data['id']\n            _exchange_info[COINBASE]['tick_size'][normalized] = data['quote_increment']\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('COINBASE', why, {\"\": r})\n\n\n<DED><DED>def gemini_symbols(*args) -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.gemini.com/v1/symbols')\n        ret = {}\n        for symbol in r.json():\n            <IND>std = f\"{symbol[:-3]}{SYMBOL_SEP}{symbol[-3:]}\"\n            std = std.upper()\n            ret[std] = symbol.upper()\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('GEMINI', why, {\"\": r})\n\n\n<DED><DED>def hitbtc_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>ret = {}\n        r = requests.get('https://api.hitbtc.com/api/2/public/symbol')\n        for symbol in r.json():\n            <IND>split = len(symbol['baseCurrency'])\n            normalized = symbol['id'][:split] + SYMBOL_SEP + symbol['id'][split:]\n            ret[normalized] = symbol['id']\n            _exchange_info[HITBTC]['tick_size'][normalized] = symbol['tickSize']\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('HITBTC', why, {\"\": r})\n\n\n<DED><DED>def poloniex_id_symbol_mapping():\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://poloniex.com/public?command=returnTicker')\n        symbols = r.json()\n        ret = {}\n        for symbol in symbols:\n            <IND>ret[symbols[symbol]['id']] = symbol\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('POLONIEX', why, {\"\": r})\n\n\n<DED><DED>def poloniex_symbols() -> Dict[str, str]:\n    <IND>ret = {}\n    for _, value in poloniex_id_symbol_mapping().items():\n        <IND>std = value.replace(\"STR\", \"XLM\")\n        quote, base = std.split(\"_\")\n        ret[quote + SYMBOL_SEP + base] = value\n    <DED>return ret\n\n\n<DED>def bitstamp_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://www.bitstamp.net/api/v2/trading-pairs-info/')\n        ret = {}\n        for data in r.json():\n            <IND>normalized = data['name'].replace(\"/\", SYMBOL_SEP)\n            symbol = data['url_symbol']\n            ret[normalized] = symbol\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BITSTAMP', why, {\"\": r})\n\n\n<DED><DED>def kraken_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.kraken.com/0/public/AssetPairs')\n        data = r.json()\n        ret = {}\n        for symbol in data['result']:\n            <IND>if 'wsname' not in data['result'][symbol] or '.d' in symbol:\n                # https://blog.kraken.com/post/259/introducing-the-kraken-dark-pool/\n                # .d is for dark pool symbols\n                <IND>continue\n\n            <DED>base, quote = data['result'][symbol]['wsname'].split(\"/\")\n\n            normalized = f\"{base}{SYMBOL_SEP}{quote}\"\n            exch = data['result'][symbol]['wsname']\n            normalized = normalized.replace('XBT', 'BTC')\n            normalized = normalized.replace('XDG', 'DOG')\n            ret[normalized] = exch\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('KRAKEN', why, {\"\": r})\n\n\n<DED><DED>def kraken_rest_symbols() -> Dict[str, str]:\n    <IND>return {normalized: exchange.replace(\"/\", \"\") for normalized, exchange in kraken_symbols().items()}\n\n\n<DED>def exx_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.exx.com/data/v1/tickers')\n        exchange = [key.upper() for key in r.json().keys()]\n        symbols = [key.replace(\"_\", SYMBOL_SEP) for key in exchange]\n        return dict(zip(symbols, exchange))\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('EXX', why, {\"\": r})\n\n\n<DED><DED>def huobi_common_symbols(url: str):\n    <IND>r = None\n    try:\n        <IND>r = requests.get(url)\n        ret = {}\n        for e in r.json()['data']:\n            <IND>if e['state'] == 'offline':\n                <IND>continue\n            <DED>normalized = f\"{e['base-currency'].upper()}{SYMBOL_SEP}{e['quote-currency'].upper()}\"\n            symbol = f\"{e['base-currency']}{e['quote-currency']}\"\n            ret[normalized] = symbol\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('HUOBI', why, {url: r})\n\n\n<DED><DED>def huobi_symbols() -> Dict[str, str]:\n    <IND>return huobi_common_symbols('https://api.huobi.pro/v1/common/symbols')\n\n\n<DED>def huobi_us_symbols() -> Dict[str, str]:\n    <IND>return huobi_common_symbols('https://api.huobi.com/v1/common/symbols')\n\n\n<DED>def huobi_dm_symbols() -> Dict[str, str]:\n    <IND>\"\"\"\n    Mapping is, for instance: {\"BTC_CW\":\"BTC190816\"}\n    See comments in exchange/huobi_dm.py\n    \"\"\"\n    mapping = {\n        \"this_week\": \"CW\",\n        \"next_week\": \"NW\",\n        \"quarter\": \"CQ\",\n        \"next_quarter\": \"NQ\"\n    }\n    r = None\n    try:\n        <IND>r = requests.get('https://www.hbdm.com/api/v1/contract_contract_info')\n        symbols = {}\n        for e in r.json()['data']:\n            <IND>symbols[f\"{e['symbol']}_{mapping[e['contract_type']]}\"] = e['contract_code']\n            _exchange_info[HUOBI_DM]['tick_size'][e['contract_code']] = e['price_tick']\n            _exchange_info[HUOBI_DM]['short_code_mappings'][f\"{e['symbol']}_{mapping[e['contract_type']]}\"] = e['contract_code']\n        <DED>return symbols\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('HUOBI_DM', why, {\"\": r})\n\n\n<DED><DED>def huobi_swap_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.hbdm.com/swap-api/v1/swap_contract_info')\n        symbols = {}\n        for e in r.json()['data']:\n            <IND>symbols[e['contract_code']] = e['contract_code']\n            _exchange_info[HUOBI_SWAP]['tick_size'][e['contract_code']] = e['price_tick']\n        <DED>return symbols\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('HUOBI_SWAP', why, {\"\": r})\n\n\n<DED><DED>def okcoin_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://www.okcoin.com/api/spot/v3/instruments')\n        ret = {}\n        for e in r.json():\n            <IND>ret[e['instrument_id']] = e['instrument_id']\n            _exchange_info[OKCOIN]['tick_size'][e['instrument_id']] = e['tick_size']\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('OKCOIN', why, {\"\": r})\n\n\n<DED><DED>def okex_symbols(*args) -> Dict[str, str]:\n    <IND>urls = ['https://www.okex.com/api/spot/v3/instruments',\n            'https://www.okex.com/api/swap/v3/instruments',\n            'https://www.okex.com/api/futures/v3/instruments']\n    urls = urls + okex_compute_option_urls_from_underlyings()\n\n    symbols: Dict[str, str] = {}\n    for u in urls:\n        <IND>time.sleep(0.2)\n        symbols.update(okex_symbols_from_one_url(u))\n\n    <DED>for symbol in symbols:\n        <IND>instrument_type = 'futures'\n        dash_count = symbol.count(get_symbol_separator())\n        if dash_count == 1:  # BTC-USDT\n            <IND>instrument_type = 'spot'\n        <DED>if dash_count == 4:  # BTC-USD-201225-35000-P\n            <IND>instrument_type = 'option'\n        <DED>if symbol[-4:] == \"SWAP\":  # BTC-USDT-SWAP\n            <IND>instrument_type = 'swap'\n\n        <DED>_exchange_info[OKEX]['instrument_type'][symbol] = instrument_type\n\n    <DED>return symbols\n\n\n<DED>def okex_compute_option_urls_from_underlyings() -> List[str]:\n    <IND>url = 'https://www.okex.com/api/option/v3/underlying'\n    r = None\n    try:\n        <IND>r = requests.get(url)\n        return [f'https://www.okex.com/api/option/v3/instruments/{underlying}' for underlying in r.json()]\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('OKEX', why, {url: r})\n\n\n<DED><DED>def okex_symbols_from_one_url(url: str) -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get(url)\n        ret = {}\n        for e in r.json():\n            <IND>ret[e['instrument_id']] = e['instrument_id']\n            _exchange_info[OKEX]['tick_size'][e['instrument_id']] = e['tick_size']\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('OKEX', why, {url: r})\n\n\n<DED><DED>def bittrex_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.bittrex.com/api/v1.1/public/getmarkets')\n        r = r.json()['result']\n        return {f\"{e['MarketCurrency']}{SYMBOL_SEP}{e['BaseCurrency']}\": e['MarketName'] for e in r if e['IsActive']}\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BITTREX', why, {\"\": r})\n\n\n<DED><DED>def bitcoincom_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.exchange.bitcoin.com/api/2/public/symbol')\n        return {f\"{data['baseCurrency']}{SYMBOL_SEP}{data['quoteCurrency'].replace('USD', 'USDT')}\": data['id'] for data in r.json()}\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BITCOINCOM', why, {\"\": r})\n\n\n<DED><DED>def bitmax_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://bitmax.io/api/pro/v1/products')\n        ret = {}\n        for entry in r.json()['data']:\n            # Only \"Normal\" status symbols are tradeable\n            <IND>if entry['status'] == 'Normal':\n                <IND>normalized = f\"{entry['baseAsset']}{SYMBOL_SEP}{entry['quoteAsset']}\"\n                ret[normalized] = entry['symbol']\n                _exchange_info[BITMAX]['tick_size'][normalized] = entry['tickSize']\n        <DED><DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BITMAX', why, {\"\": r})\n\n\n<DED><DED>def upbit_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.upbit.com/v1/market/all')\n        return {f\"{data['market'].split('-')[1]}{SYMBOL_SEP}{data['market'].split('-')[0]}\": data['market'] for data in r.json()}\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('UPBIT', why, {\"\": r})\n\n\n<DED><DED>def blockchain_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get(\"https://api.blockchain.com/mercury-gateway/v1/instruments\")\n        return {data[\"symbol\"].replace(\"-\", SYMBOL_SEP): data[\"symbol\"] for data in r.json()}\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BLOCKCHAIN', why, {\"\": r})\n\n\n<DED><DED>def gateio_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get(\"https://api.gateio.ws/api/v4/spot/currency_pairs\")\n        return {data[\"id\"].replace(\"_\", SYMBOL_SEP): data['id'] for data in r.json()}\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('GATEIO', why, {\"\": r})\n\n\n<DED><DED>def bitmex_symbols() -> Dict[str, str]:\n    <IND>r = None\n    ret = {}\n    try:\n        <IND>r = requests.get(\"https://www.bitmex.com/api/v1/instrument/active\")\n        for entry in r.json():\n            <IND>components = []\n            components.append(entry['rootSymbol'])\n            components.append(entry['quoteCurrency'])\n\n            if entry['expiry']:\n                <IND>components.append(entry['symbol'][-3:])\n\n            <DED>normalized = SYMBOL_SEP.join(components)\n            normalized = normalized.replace(\"XBT\", \"BTC\")\n            ret[normalized] = entry['symbol']\n            _exchange_info[BITMEX]['tick_size'][normalized] = entry['tickSize']\n\n            if entry['expiry']:\n                <IND>_exchange_info[BITMEX]['expiry'][normalized] = entry['expiry']\n\n        <DED><DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BITMEX', why, {\"\": r})\n\n\n<DED><DED>def deribit_symbols() -> Dict[str, str]:\n    <IND>url = r = None\n    ret = {}\n    try:\n        # TODO: get currencies from https://www.deribit.com/api/v2/public/get_currencies\n        <IND>currencies = ['BTC', 'ETH']\n        for c in currencies:\n            <IND>url = f\"https://www.deribit.com/api/v2/public/get_instruments?currency={c}&expired=false\"\n            r = requests.get(url)\n            for entry in r.json()['result']:\n                <IND>split = entry['instrument_name'].split(\"-\")\n                normalized = split[0] + SYMBOL_SEP + entry['quote_currency'] + \"-\" + '-'.join(split[1:])\n                ret[normalized] = entry['instrument_name']\n                _exchange_info[DERIBIT]['tick_size'][normalized] = entry['tick_size']\n        <DED><DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('DERIBIT', why, {url: r})\n\n\n<DED><DED>def kraken_future_symbols() -> Dict[str, str]:\n    <IND>r = None\n    ret = {}\n    try:\n        <IND>r = requests.get('https://futures.kraken.com/derivatives/api/v3/instruments')\n        data = r.json()['instruments']\n        for entry in data:\n            <IND>if not entry['tradeable']:\n                <IND>continue\n            <DED>normalized = entry['symbol'].upper().replace(\"_\", \"-\")\n            symbol = normalized[3:6] + SYMBOL_SEP + normalized[6:9]\n            normalized = normalized.replace(normalized[3:9], symbol)\n            normalized = normalized.replace('XBT', 'BTC')\n\n            _exchange_info[KRAKEN_FUTURES]['tick_size'][normalized] = entry['tickSize']\n            _exchange_info[KRAKEN_FUTURES]['contract_size'][normalized] = entry['contractSize']\n            _exchange_info[KRAKEN_FUTURES]['underlying'][normalized] = entry['underlying']\n            _exchange_info[KRAKEN_FUTURES]['product_type'][normalized] = _kraken_futures_product_type[normalized[:2]]\n            ret[normalized] = entry['symbol']\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('KRAKEN_FUTURES', why, {\"\": r})\n\n\n<DED><DED>def probit_symbols() -> Dict[str, str]:\n    # doc: https://docs-en.probit.com/reference-link/market\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.probit.com/api/exchange/v1/market')\n        return {entry['id']: entry['id'] for entry in r.json()['data']}\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('PROBIT', why, {\"\": r})\n\n\n<DED><DED>def coingecko_normalize_symbol(symbol: str) -> str:\n    # keep digits, letters and dots, replace others by space\n    <IND>symbol = ''.join(c if c.isalnum() or c in ('.', '+') else ' ' for c in symbol)\n    return coingecko_normalize(symbol.upper())\n\n\n<DED>def coingecko_normalize_name(name: str) -> str:\n    # keep digits and letters, replace others by space (except when only composed by upper case letters, digits and dots)\n    <IND>if not all(c.isupper() or c.isdigit() or c == '.' for c in name):\n        <IND>name = ''.join(c if c.isalnum() else ' ' for c in name)\n    <DED>return coingecko_normalize(name)\n\n\n<DED>def coingecko_normalize(sym: str) -> str:\n    <IND>sym = sym.strip()\n    # do not concatenate numbers => separate them with a dot\n    sym = list(sym)\n    if len(sym) > 4:\n        <IND>for i in range(2, len(sym) - 1):\n            <IND>if sym[i] == ' ' and sym[i - 1].isdigit() and sym[i + 1].isdigit():\n                <IND>sym[i] = '.'\n    <DED><DED><DED>sym = ''.join(sym)\n    # concatenate space-separated words => use CamelCase to distinguish the words\n    if ' ' in sym:\n        <IND>if sum(c.islower() for c in sym):  # if there is at least one lower case letter\n            <IND>sym = ' '.join(word[0].upper() + word[1:] for word in sym.split())  # Just capitalize initial letter of each word\n        <DED>else:  # CoinGecko may provide full upper-case as for \"THE STONE COIN\"\n            <IND>sym = string.capwords(sym)  # capwords converts \"THE STONE COIN\" to \"The Stone Coin\"\n        <DED>sym = sym.replace(' ', '')  # concatenate words\n    <DED>return sym\n\n\n<DED>def is_name_short(coin: dict) -> bool:\n    <IND>\"\"\"return True if the coin name is enough short compared to the coin symbol.\"\"\"\n    return len(coin['name']) <= max(5, len(coin['symbol']) + 1)\n\n\n<DED>def has_many_caps(name: str) -> bool:\n    <IND>\"\"\"return True if the symbol contains enough upper case letters, False if empty.\"\"\"\n    return str and sum(c.islower() for c in name) < (len(name) / 2)\n\n\n<DED>def coingecko_normalize_all(coin: dict):\n    <IND>SYMBOL_TO_NORMALIZED = {'miota': 'IOTA'}\n    normalized = SYMBOL_TO_NORMALIZED.get(coin['symbol'])\n    if normalized:\n        <IND>coin['ns'] = coin['nn'] = normalized\n        return normalized\n\n    # ns = normalized symbol, nn = normalized name\n    <DED>coin['ns'] = coingecko_normalize_symbol(coin['symbol'])\n\n    ID_SUFFIX = '-bitcoin-token'\n    if coin['id'][-len(ID_SUFFIX):] == ID_SUFFIX:\n        <IND>coin['nn'] = 'BTC' + coin['ns']\n        return coin['nn']\n\n    <DED>name = coin['name']\n\n    prefixes = ('The ', 'the ')\n    for p in prefixes:\n        <IND>if name[:len(p)] == p:\n            <IND>coin['reduced-name'] = True\n            name = name[len(p):]\n            break\n\n    <DED><DED>suffixes = ('coin', 'coins', 'money', 'finance', 'protocol', 'reward', 'rewards', 'token')\n    for s in suffixes:\n        <IND>if len(name) > len(s) and name[-len(s):].lower() == s:\n            # but keep suffix when lower-case concatenated\n            <IND>if name[-len(s)].islower() and name[-len(s) - 1] != ' ':\n                <IND>continue\n            # also keep suffix to avoid confusing nam: \"Bitcoin Token\" -> \"Bitcoin\"\n            <DED>if name[:-len(s)].strip().lower() == 'bitcoin':\n                <IND>continue\n            <DED>coin['reduced-name'] = True\n            name = name[:-len(s)]\n            break\n\n    <DED><DED>coin['nn'] = coingecko_normalize_name(name)\n\n    if len(coin['nn']) < len(coin['ns']):\n        <IND>if 'reduced-name' in coin:\n            <IND>coin['reduced-name'] = False\n            name = coin['name']\n            coin['nn'] = coingecko_normalize_name(name)\n        <DED>elif not has_many_caps(name):\n            <IND>return coin['ns']\n\n    <DED><DED>if not coin['ns']:  # coin['symbol'] may be an emoji that is striped when normalized\n        <IND>return coin['nn']\n\n    <DED>if coin.get('reduced-name') and coin['ns'].upper() != coin['nn'].upper():\n        <IND>return coin['ns']\n\n    <DED>i = coin['nn'].find('.')  # if there is a dot in normalized name => prefer the normalized symbol\n    if i >= 0:\n        <IND>if i > 1 and coin['nn'][i - 1].isdigit() and coin['nn'][i + 1].isdigit():\n            <IND>pass  # except when the dot separates digits\n        <DED>else:\n            <IND>return coin['ns']\n\n    <DED><DED>if is_name_short(coin) and has_many_caps(name):\n        <IND>return coin['nn']\n\n    <DED>if 1.5 * len(coin['ns']) > len(coin['nn']) and any(c.islower() for c in coin['ns']):\n        <IND>return coin['nn']\n\n    <DED>return coin['ns']\n\n\n<DED>def coingecko_symbols() -> Dict[str, str]:\n    <IND>r = None\n    intermediate = defaultdict(list)\n    try:\n        <IND>r = requests.get('https://api.coingecko.com/api/v3/coins/list')\n        all_coins = r.json()\n        # First pass: generate & compare normalized symbol/name, and then select the most pertinent\n        for coin in all_coins:\n            <IND>normalized = coingecko_normalize_all(coin)\n            intermediate[normalized].append(coin)\n            # Above line keeps together the coins having the same normalized symbol.\n            # To reduce collision, the coin['name'] is sometimes used in lieu of the coin['symbol'].\n            # The coin['name'] is not capitalized because lower case letters may be meaningful: cETH, yUSD, DATx, zLOT\n    <DED><DED>except Exception as why:\n        <IND>raise_failure_explanation('COINGECKO', why, {\"\": r})\n\n    <DED>final = coingecko_second_pass(intermediate)\n    return coingecko_third_pass(final)\n\n\n<DED>def coingecko_second_pass(intermediate: Dict[str, List[dict]]) -> Dict[str, List[dict]]:\n    # Second pass: fixes most of the symbol collisions\n    <IND>final = defaultdict(list)\n    for normalized, coins in intermediate.items():\n        <IND>if len(coins) == 1:\n            <IND>final[normalized].append(coins[0])\n            continue\n        <DED>set_normalized = False\n        for i in range(len(coins)):\n            <IND>if normalized == coins[i]['nn']:\n                <IND>coin = coins.pop(i)\n                final[normalized].append(coin)\n                set_normalized = True\n                break\n        <DED><DED>rest: List[dict] = []\n        for coin in coins:\n            <IND>if '%' in coin['name']:\n                <IND>if len(coins) == 1:\n                    <IND>n = coin['ns']\n                <DED>else:\n                    <IND>n = coingecko_normalize_name(coin['id'])\n                <DED>final[n].append(coin)\n            <DED>else:\n                <IND>rest.append(coin)\n        <DED><DED>if not rest:\n            <IND>continue\n        <DED>if not set_normalized:\n            <IND>rest.sort(key=lambda coin: len(coin['nn']), reverse=True)  # sort by the length of the normalized name\n            coin = rest.pop(0)\n            final[normalized].append(coin)\n        <DED>for coin in rest:\n            <IND>if coin['nn'] not in intermediate:\n                <IND>n = coin['nn']\n            <DED>elif coin.get('reduced-name'):\n                <IND>n = coingecko_normalize_name(coin['name'])\n            <DED>else:\n                <IND>n = coingecko_normalize_name(coin['id'])\n            <DED>final[n].append(coin)\n    <DED><DED>return final\n\n\n<DED>def coingecko_third_pass(final: Dict[str, List[dict]]) -> Dict[str, str]:\n    # Third pass: fixes some remaining collisions and fills the result\n    <IND>symbols = {}\n    for normalized, coins in final.items():\n        <IND>if len(coins) == 1:\n            <IND>symbols[normalized] = coins[0]['id']\n            continue\n        <DED>set_normalized = False\n        for i in range(len(coins)):\n            <IND>if normalized == coins[i]['nn']:\n                <IND>coin = coins.pop(i)\n                symbols[normalized] = coin['id']\n                set_normalized = True\n                break\n        <DED><DED>rest: List[dict] = []\n        for coin in coins:\n            <IND>if '%' in coin['name']:\n                <IND>if len(coins) == 1:\n                    <IND>n = coin['ns']\n                <DED>else:\n                    <IND>n = coingecko_normalize_name(coin['id'])\n                <DED>symbols[n] = coin['id']\n            <DED>else:\n                <IND>rest.append(coin)\n        <DED><DED>if not rest:\n            <IND>continue\n        <DED>if not set_normalized:\n            <IND>rest.sort(key=lambda coin: len(coin['nn']), reverse=True)  # sort by the length of the normalized name\n            coin = rest.pop(0)\n            symbols[normalized] = coin['id']\n        <DED>for coin in rest:\n            <IND>if coin['nn'] not in final:\n                <IND>n = coin['nn']\n            <DED>elif coin.get('reduced-name'):\n                <IND>n = coingecko_normalize_name(coin['name'])\n            <DED>else:\n                <IND>n = coingecko_normalize_name(coin['id'])\n            <DED>symbols[n] = coin['id']\n    <DED><DED>return symbols\n\n\n<DED>def whale_alert_coins(key_id: str) -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get(f'https://api.whale-alert.io/v1/status?api_key={key_id}')\n        # Same symbols, but on different blockchains (for instance USDT), are naturally overwritten.\n        return {s.upper(): s for b in r.json()['blockchains'] for s in b['symbols'] if s}\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('WHALES_ALERT', why, {\"\": r})\n\n\n<DED><DED>_exchange_function_map = {\n    BITFINEX: bitfinex_symbols,\n    BITFLYER: bitflyer_symbols,\n    COINBASE: coinbase_symbols,\n    GEMINI: gemini_symbols,\n    HITBTC: hitbtc_symbols,\n    POLONIEX: poloniex_symbols,\n    PROBIT: probit_symbols,\n    BITSTAMP: bitstamp_symbols,\n    KRAKEN: kraken_symbols,\n    KRAKEN + 'REST': kraken_rest_symbols,\n    BINANCE: binance_symbols,\n    BINANCE_US: binance_us_symbols,\n    BINANCE_FUTURES: binance_futures_symbols,\n    BINANCE_DELIVERY: binance_delivery_symbols,\n    BLOCKCHAIN: blockchain_symbols,\n    EXX: exx_symbols,\n    HUOBI: huobi_symbols,\n    HUOBI_DM: huobi_dm_symbols,\n    HUOBI_SWAP: huobi_swap_symbols,\n    OKCOIN: okcoin_symbols,\n    OKEX: okex_symbols,\n    BYBIT: bybit_symbols,\n    FTX: ftx_symbols,\n    FTX_US: ftx_us_symbols,\n    BITTREX: bittrex_symbols,\n    BITCOINCOM: bitcoincom_symbols,\n    BITMAX: bitmax_symbols,\n    UPBIT: upbit_symbols,\n    GATEIO: gateio_symbols,\n    BITMEX: bitmex_symbols,\n    DERIBIT: deribit_symbols,\n    KRAKEN_FUTURES: kraken_future_symbols,\n    COINGECKO: coingecko_symbols,\n    WHALE_ALERT: whale_alert_coins\n}\n",
        "target_code_with_indent": "\nfrom typing import Dict, Tuple\n\n\nclass _Symbols:\n    <IND>def __init__(self):\n        <IND>self.data = {}\n\n    <DED>def set(self, exchange: str, normalized: dict, exchange_info: dict):\n        <IND>self.data[exchange] = {}\n        self.data[exchange]['normalized'] = normalized\n        self.data[exchange]['info'] = exchange_info\n\n    <DED>def get(self, exchange: str) -> Tuple[Dict, Dict]:\n        <IND>return self.data[exchange]['normalized'], self.data[exchange]['info']\n\n    <DED>def populated(self, exchange: str) -> bool:\n        <IND>return exchange in self.data\n\n\n<DED><DED>Symbols = _Symbols()\n"
      }
    ]
  },
  {
    "project": "bmoscon/cryptofeed",
    "commit": "3525dc8ce4d7836a9abaaa5662e58e5e27969a77",
    "filename": "cryptofeed/symbols.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/bmoscon-cryptofeed/cryptofeed/symbols.py",
    "file_hunks_size": 1,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "cryptofeed/symbols.py:434:8 Incompatible return type [7]: Expected `List[str]` but got implicit return value of `None`.",
    "message": " Expected `List[str]` but got implicit return value of `None`.",
    "rule_id": "Incompatible return type [7]",
    "warning_line_no": 434,
    "warning_line": "        raise_failure_explanation('OKEX', why, {url: r})",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "associated with this software.\n\n\nSymbol generation code for exchanges\n'''\n\nimport logging\nimport string\nimport time\nfrom collections import defaultdict\nfrom typing import Dict, List, Optional, Tuple\n\nimport requests\nfrom requests import Response\n\nfrom cryptofeed.defines import *\n\n\nLOG = logging.getLogger('feedhandler')\n\nSYMBOL_SEP = '-'\n\n_symbols_retrieval_cache: Dict[str, Dict[str, str]] = {}\n_exchange_info = defaultdict(lambda: defaultdict(dict))\n\n\n_kraken_futures_product_type = {\n    'FI': 'Inverse Futures',\n    'FV': 'Vanilla Futures',\n    'PI': 'Perpetual Inverse Futures',\n    'PV': 'Perpetual Vanilla Futures',\n    'IN': 'Real Time Index',\n    'RR': 'Reference Rate',\n}\n\n\ndef raise_failure_explanation(feed_id: str, exception: BaseException, responses: Dict[str, Optional[Response]]):\n    LOG.critical('%s: encountered %r while processing response from exchange API', feed_id, exception)\n    if len(responses) > 1:\n        LOG.critical('%s: content of one of the %s responses was unexpected', feed_id, len(responses))\n    for url, r in responses.items():\n        if url:\n            LOG.critical('%s: requested URL: %s', feed_id, url)\n        if r:\n            LOG.critical('%s: unexpected response: %s', feed_id, r.text)\n    raise ValueError(f'Cryptofeed stopped because of an unexpected response from {feed_id}') from exception\n\n\ndef set_symbol_separator(separator: str):\n    global SYMBOL_SEP\n    SYMBOL_SEP = separator\n\n\ndef get_symbol_separator() -> str:\n    global SYMBOL_SEP\n    return SYMBOL_SEP\n\n\ndef gen_symbols(exchange: str, key_id=None) -> Dict[str, str]:\n    if exchange not in _symbols_retrieval_cache:\n        LOG.info(\"%s: Getting list of symbols\", exchange)\n        symbols = _exchange_function_map[exchange](key_id) if key_id else _exchange_function_map[exchange]()\n        LOG.info(\"%s: %s symbols\", exchange, len(symbols))\n\n        # log all retrieved symbols using debug level\n        for normalized, exch_sym in sorted(symbols.items()):\n            LOG.debug('%s: id-from-exch -> normalized: %-35s-> %s', exchange, exch_sym, normalized)\n\n        _symbols_retrieval_cache[exchange] = symbols\n    return _symbols_retrieval_cache[exchange]\n\n\ndef _binance_symbols(endpoint: str, exchange: str):\n    r = None\n    try:\n        ret = {}\n        r = requests.get(endpoint)\n        for symbol in r.json()['symbols']:\n            if symbol.get('status', 'TRADING') != \"TRADING\":\n                continue\n            if symbol.get('contractStatus', 'TRADING') != \"TRADING\":\n                continue\n            split = len(symbol['baseAsset'])\n            normalized = symbol['symbol'][:split] + SYMBOL_SEP + symbol['symbol'][split:]\n            ret[normalized] = symbol['symbol']\n            _exchange_info[exchange]['tick_size'][normalized] = symbol['filters'][0]['tickSize']\n            if \"contractType\" in symbol:\n                _exchange_info[exchange]['contract_type'][normalized] = symbol['contractType']\n        return ret\n    except Exception as why:\n        raise_failure_explanation(exchange, why, {endpoint: r})\n\n\ndef binance_symbols() -> Dict[str, str]:\n    return _binance_symbols('https://api.binance.com/api/v3/exchangeInfo', BINANCE)\n\n\ndef binance_us_symbols() -> Dict[str, str]:\n    return _binance_symbols('https://api.binance.us/api/v3/exchangeInfo', BINANCE_US)\n\n\ndef binance_futures_symbols() -> Dict[str, str]:\n    base = _binance_symbols('https://fapi.binance.com/fapi/v1/exchangeInfo', BINANCE_FUTURES)\n    add = {}\n    for symbol, orig in base.items():\n        if \"_\" in orig:\n            continue\n        add[f\"{symbol}-PINDEX\"] = f\"p{orig}\"\n    base.update(add)\n    return base\n\n\ndef binance_delivery_symbols() -> Dict[str, str]:\n    return _binance_symbols('https://dapi.binance.com/dapi/v1/exchangeInfo', BINANCE_DELIVERY)\n\n\ndef bitfinex_symbols() -> Dict[str, str]:\n    # doc: https://docs.bitfinex.com/docs/ws-general#supported-pairs\n    r1 = r2 = None\n    try:\n        r1 = requests.get('https://api.bitfinex.com/v2/tickers?symbols=ALL')\n        r2 = requests.get('https://api-pub.bitfinex.com/v2/conf/pub:map:currency:sym')\n        tickers: List[List[str]] = r1.json()\n        norm: List[Tuple[str, str]] = r2.json()[0]\n        norm: Dict[str, str] = dict(norm)\n        for k, v in dict(norm).items():\n            if k[-2:] == 'F0' or '-' in v:  # Do not convert BTCF0 -> BTC or PBTCETH -> PBTC-ETH\n                del norm[k]\n        norm['BCHN'] = 'BCH'  # Bitfinex uses BCHN, other exchanges use BCH\n\n        ret = {}\n        for symbol in [t[0] for t in tickers]:\n            if symbol[0] == 'f':\n                normalized = norm.get(symbol[1:], symbol[1:])\n            else:\n                if len(symbol) == 7:\n                    base, quote = symbol[1:4], symbol[4:]\n                else:\n                    base, quote = symbol[1:].split(':')\n                    assert ':' in symbol\n                normalized = norm.get(base, base) + SYMBOL_SEP + norm.get(quote, quote)\n            ret[normalized.upper()] = symbol\n        return ret\n    except ValueError as why:\n        raise_failure_explanation('BITFINEX', why, {\"tickers?symbols=ALL\": r1, \"pub:map:currency:sym\": r2})\n\n\ndef bitflyer_symbols() -> Dict[str, str]:\n    endpoint = r = None\n    try:\n        ret = {}\n        endpoints = ['https://api.bitflyer.com/v1/getmarkets/eu', 'https://api.bitflyer.com/v1/getmarkets/usa', 'https://api.bitflyer.com/v1/getmarkets']\n        for endpoint in endpoints:\n            r = requests.get(endpoint)\n            for entry in r.json():\n                normalized = entry['product_code'].replace(\"_\", SYMBOL_SEP)\n                ret[normalized] = entry['product_code']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('BITFLYER', why, {endpoint: r})\n\n\ndef bybit_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.bybit.com/v2/public/symbols')\n        ret = {}\n        for symbol in r.json()['result']:\n            quote = symbol['quote_currency']\n            if not symbol['name'].endswith(quote):\n                base, contract = symbol['name'].split(quote)\n                normalized = f\"{base}{SYMBOL_SEP}{quote}-{contract}\"\n            else:\n                normalized = f\"{symbol['base_currency']}{SYMBOL_SEP}{quote}\"\n            ret[normalized] = symbol['name']\n            _exchange_info[BYBIT]['tick_size'][normalized] = symbol['price_filter']['tick_size']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('BYBIT', why, {\"\": r})\n\n\ndef _ftx_helper(endpoint: str, exchange: str):\n    r = None\n    try:\n        r = requests.get(endpoint)\n        ret = {}\n        for data in r.json()['result']:\n            normalized = data['name'].replace(\"/\", SYMBOL_SEP)\n            symbol = data['name']\n            ret[normalized] = symbol\n            _exchange_info[exchange]['tick_size'][normalized] = data['priceIncrement']\n        return ret\n    except Exception as why:\n        raise_failure_explanation(exchange, why, {endpoint: r})\n\n\ndef ftx_symbols() -> Dict[str, str]:\n    return _ftx_helper('https://ftx.com/api/markets', FTX)\n\n\ndef ftx_us_symbols() -> Dict[str, str]:\n    return _ftx_helper('https://ftx.us/api/markets', FTX_US)\n\n\ndef coinbase_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.pro.coinbase.com/products')\n        ret = {}\n        for data in r.json():\n            normalized = data['id'].replace(\"-\", SYMBOL_SEP)\n            ret[normalized] = data['id']\n            _exchange_info[COINBASE]['tick_size'][normalized] = data['quote_increment']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('COINBASE', why, {\"\": r})\n\n\ndef gemini_symbols(*args) -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.gemini.com/v1/symbols')\n        ret = {}\n        for symbol in r.json():\n            std = f\"{symbol[:-3]}{SYMBOL_SEP}{symbol[-3:]}\"\n            std = std.upper()\n            ret[std] = symbol.upper()\n        return ret\n    except Exception as why:\n        raise_failure_explanation('GEMINI', why, {\"\": r})\n\n\ndef hitbtc_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        ret = {}\n        r = requests.get('https://api.hitbtc.com/api/2/public/symbol')\n        for symbol in r.json():\n            split = len(symbol['baseCurrency'])\n            normalized = symbol['id'][:split] + SYMBOL_SEP + symbol['id'][split:]\n            ret[normalized] = symbol['id']\n            _exchange_info[HITBTC]['tick_size'][normalized] = symbol['tickSize']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('HITBTC', why, {\"\": r})\n\n\ndef poloniex_id_symbol_mapping():\n    r = None\n    try:\n        r = requests.get('https://poloniex.com/public?command=returnTicker')\n        symbols = r.json()\n        ret = {}\n        for symbol in symbols:\n            ret[symbols[symbol]['id']] = symbol\n        return ret\n    except Exception as why:\n        raise_failure_explanation('POLONIEX', why, {\"\": r})\n\n\ndef poloniex_symbols() -> Dict[str, str]:\n    ret = {}\n    for _, value in poloniex_id_symbol_mapping().items():\n        std = value.replace(\"STR\", \"XLM\")\n        quote, base = std.split(\"_\")\n        ret[quote + SYMBOL_SEP + base] = value\n    return ret\n\n\ndef bitstamp_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://www.bitstamp.net/api/v2/trading-pairs-info/')\n        ret = {}\n        for data in r.json():\n            normalized = data['name'].replace(\"/\", SYMBOL_SEP)\n            symbol = data['url_symbol']\n            ret[normalized] = symbol\n        return ret\n    except Exception as why:\n        raise_failure_explanation('BITSTAMP', why, {\"\": r})\n\n\ndef kraken_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.kraken.com/0/public/AssetPairs')\n        data = r.json()\n        ret = {}\n        for symbol in data['result']:\n            if 'wsname' not in data['result'][symbol] or '.d' in symbol:\n                # https://blog.kraken.com/post/259/introducing-the-kraken-dark-pool/\n                # .d is for dark pool symbols\n                continue\n\n            base, quote = data['result'][symbol]['wsname'].split(\"/\")\n\n            normalized = f\"{base}{SYMBOL_SEP}{quote}\"\n            exch = data['result'][symbol]['wsname']\n            normalized = normalized.replace('XBT', 'BTC')\n            normalized = normalized.replace('XDG', 'DOG')\n            ret[normalized] = exch\n        return ret\n    except Exception as why:\n        raise_failure_explanation('KRAKEN', why, {\"\": r})\n\n\ndef kraken_rest_symbols() -> Dict[str, str]:\n    return {normalized: exchange.replace(\"/\", \"\") for normalized, exchange in kraken_symbols().items()}\n\n\ndef exx_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.exx.com/data/v1/tickers')\n        exchange = [key.upper() for key in r.json().keys()]\n        symbols = [key.replace(\"_\", SYMBOL_SEP) for key in exchange]\n        return dict(zip(symbols, exchange))\n    except Exception as why:\n        raise_failure_explanation('EXX', why, {\"\": r})\n\n\ndef huobi_common_symbols(url: str):\n    r = None\n    try:\n        r = requests.get(url)\n        ret = {}\n        for e in r.json()['data']:\n            if e['state'] == 'offline':\n                continue\n            normalized = f\"{e['base-currency'].upper()}{SYMBOL_SEP}{e['quote-currency'].upper()}\"\n            symbol = f\"{e['base-currency']}{e['quote-currency']}\"\n            ret[normalized] = symbol\n        return ret\n    except Exception as why:\n        raise_failure_explanation('HUOBI', why, {url: r})\n\n\ndef huobi_symbols() -> Dict[str, str]:\n    return huobi_common_symbols('https://api.huobi.pro/v1/common/symbols')\n\n\ndef huobi_us_symbols() -> Dict[str, str]:\n    return huobi_common_symbols('https://api.huobi.com/v1/common/symbols')\n\n\ndef huobi_dm_symbols() -> Dict[str, str]:\n    \"\"\"\n    Mapping is, for instance: {\"BTC_CW\":\"BTC190816\"}\n    See comments in exchange/huobi_dm.py\n    \"\"\"\n    mapping = {\n        \"this_week\": \"CW\",\n        \"next_week\": \"NW\",\n        \"quarter\": \"CQ\",\n        \"next_quarter\": \"NQ\"\n    }\n    r = None\n    try:\n        r = requests.get('https://www.hbdm.com/api/v1/contract_contract_info')\n        symbols = {}\n        for e in r.json()['data']:\n            symbols[f\"{e['symbol']}_{mapping[e['contract_type']]}\"] = e['contract_code']\n            _exchange_info[HUOBI_DM]['tick_size'][e['contract_code']] = e['price_tick']\n            _exchange_info[HUOBI_DM]['short_code_mappings'][f\"{e['symbol']}_{mapping[e['contract_type']]}\"] = e['contract_code']\n        return symbols\n    except Exception as why:\n        raise_failure_explanation('HUOBI_DM', why, {\"\": r})\n\n\ndef huobi_swap_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.hbdm.com/swap-api/v1/swap_contract_info')\n        symbols = {}\n        for e in r.json()['data']:\n            symbols[e['contract_code']] = e['contract_code']\n            _exchange_info[HUOBI_SWAP]['tick_size'][e['contract_code']] = e['price_tick']\n        return symbols\n    except Exception as why:\n        raise_failure_explanation('HUOBI_SWAP', why, {\"\": r})\n\n\ndef okcoin_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://www.okcoin.com/api/spot/v3/instruments')\n        ret = {}\n        for e in r.json():\n            ret[e['instrument_id']] = e['instrument_id']\n            _exchange_info[OKCOIN]['tick_size'][e['instrument_id']] = e['tick_size']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('OKCOIN', why, {\"\": r})\n\n\ndef okex_symbols(*args) -> Dict[str, str]:\n    urls = ['https://www.okex.com/api/spot/v3/instruments',\n            'https://www.okex.com/api/swap/v3/instruments',\n            'https://www.okex.com/api/futures/v3/instruments']\n    urls = urls + okex_compute_option_urls_from_underlyings()\n\n    symbols: Dict[str, str] = {}\n    for u in urls:\n        time.sleep(0.2)\n        symbols.update(okex_symbols_from_one_url(u))\n\n    for symbol in symbols:\n        instrument_type = 'futures'\n        dash_count = symbol.count(get_symbol_separator())\n        if dash_count == 1:  # BTC-USDT\n            instrument_type = 'spot'\n        if dash_count == 4:  # BTC-USD-201225-35000-P\n            instrument_type = 'option'\n        if symbol[-4:] == \"SWAP\":  # BTC-USDT-SWAP\n            instrument_type = 'swap'\n\n        _exchange_info[OKEX]['instrument_type'][symbol] = instrument_type\n\n    return symbols\n\n\ndef okex_compute_option_urls_from_underlyings() -> List[str]:\n    url = 'https://www.okex.com/api/option/v3/underlying'\n    r = None\n    try:\n        r = requests.get(url)\n        return [f'https://www.okex.com/api/option/v3/instruments/{underlying}' for underlying in r.json()]\n    except Exception as why:\n        raise_failure_explanation('OKEX', why, {url: r})\n\n\ndef okex_symbols_from_one_url(url: str) -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get(url)\n        ret = {}\n        for e in r.json():\n            ret[e['instrument_id']] = e['instrument_id']\n            _exchange_info[OKEX]['tick_size'][e['instrument_id']] = e['tick_size']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('OKEX', why, {url: r})\n\n\ndef bittrex_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.bittrex.com/api/v1.1/public/getmarkets')\n        r = r.json()['result']\n        return {f\"{e['MarketCurrency']}{SYMBOL_SEP}{e['BaseCurrency']}\": e['MarketName'] for e in r if e['IsActive']}\n    except Exception as why:\n        raise_failure_explanation('BITTREX', why, {\"\": r})\n\n\ndef bitcoincom_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.exchange.bitcoin.com/api/2/public/symbol')\n        return {f\"{data['baseCurrency']}{SYMBOL_SEP}{data['quoteCurrency'].replace('USD', 'USDT')}\": data['id'] for data in r.json()}\n    except Exception as why:\n        raise_failure_explanation('BITCOINCOM', why, {\"\": r})\n\n\ndef bitmax_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://bitmax.io/api/pro/v1/products')\n        ret = {}\n        for entry in r.json()['data']:\n            # Only \"Normal\" status symbols are tradeable\n            if entry['status'] == 'Normal':\n                normalized = f\"{entry['baseAsset']}{SYMBOL_SEP}{entry['quoteAsset']}\"\n                ret[normalized] = entry['symbol']\n                _exchange_info[BITMAX]['tick_size'][normalized] = entry['tickSize']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('BITMAX', why, {\"\": r})\n\n\ndef upbit_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.upbit.com/v1/market/all')\n        return {f\"{data['market'].split('-')[1]}{SYMBOL_SEP}{data['market'].split('-')[0]}\": data['market'] for data in r.json()}\n    except Exception as why:\n        raise_failure_explanation('UPBIT', why, {\"\": r})\n\n\ndef blockchain_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get(\"https://api.blockchain.com/mercury-gateway/v1/instruments\")\n        return {data[\"symbol\"].replace(\"-\", SYMBOL_SEP): data[\"symbol\"] for data in r.json()}\n    except Exception as why:\n        raise_failure_explanation('BLOCKCHAIN', why, {\"\": r})\n\n\ndef gateio_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get(\"https://api.gateio.ws/api/v4/spot/currency_pairs\")\n        return {data[\"id\"].replace(\"_\", SYMBOL_SEP): data['id'] for data in r.json()}\n    except Exception as why:\n        raise_failure_explanation('GATEIO', why, {\"\": r})\n\n\ndef bitmex_symbols() -> Dict[str, str]:\n    r = None\n    ret = {}\n    try:\n        r = requests.get(\"https://www.bitmex.com/api/v1/instrument/active\")\n        for entry in r.json():\n            components = []\n            components.append(entry['rootSymbol'])\n            components.append(entry['quoteCurrency'])\n\n            if entry['expiry']:\n                components.append(entry['symbol'][-3:])\n\n            normalized = SYMBOL_SEP.join(components)\n            normalized = normalized.replace(\"XBT\", \"BTC\")\n            ret[normalized] = entry['symbol']\n            _exchange_info[BITMEX]['tick_size'][normalized] = entry['tickSize']\n\n            if entry['expiry']:\n                _exchange_info[BITMEX]['expiry'][normalized] = entry['expiry']\n\n        return ret\n    except Exception as why:\n        raise_failure_explanation('BITMEX', why, {\"\": r})\n\n\ndef deribit_symbols() -> Dict[str, str]:\n    url = r = None\n    ret = {}\n    try:\n        # TODO: get currencies from https://www.deribit.com/api/v2/public/get_currencies\n        currencies = ['BTC', 'ETH']\n        for c in currencies:\n            url = f\"https://www.deribit.com/api/v2/public/get_instruments?currency={c}&expired=false\"\n            r = requests.get(url)\n            for entry in r.json()['result']:\n                split = entry['instrument_name'].split(\"-\")\n                normalized = split[0] + SYMBOL_SEP + entry['quote_currency'] + \"-\" + '-'.join(split[1:])\n                ret[normalized] = entry['instrument_name']\n                _exchange_info[DERIBIT]['tick_size'][normalized] = entry['tick_size']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('DERIBIT', why, {url: r})\n\n\ndef kraken_future_symbols() -> Dict[str, str]:\n    r = None\n    ret = {}\n    try:\n        r = requests.get('https://futures.kraken.com/derivatives/api/v3/instruments')\n        data = r.json()['instruments']\n        for entry in data:\n            if not entry['tradeable']:\n                continue\n            normalized = entry['symbol'].upper().replace(\"_\", \"-\")\n            symbol = normalized[3:6] + SYMBOL_SEP + normalized[6:9]\n            normalized = normalized.replace(normalized[3:9], symbol)\n            normalized = normalized.replace('XBT', 'BTC')\n\n            _exchange_info[KRAKEN_FUTURES]['tick_size'][normalized] = entry['tickSize']\n            _exchange_info[KRAKEN_FUTURES]['contract_size'][normalized] = entry['contractSize']\n            _exchange_info[KRAKEN_FUTURES]['underlying'][normalized] = entry['underlying']\n            _exchange_info[KRAKEN_FUTURES]['product_type'][normalized] = _kraken_futures_product_type[normalized[:2]]\n            ret[normalized] = entry['symbol']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('KRAKEN_FUTURES', why, {\"\": r})\n\n\ndef probit_symbols() -> Dict[str, str]:\n    # doc: https://docs-en.probit.com/reference-link/market\n    r = None\n    try:\n        r = requests.get('https://api.probit.com/api/exchange/v1/market')\n        return {entry['id']: entry['id'] for entry in r.json()['data']}\n    except Exception as why:\n        raise_failure_explanation('PROBIT', why, {\"\": r})\n\n\ndef coingecko_normalize_symbol(symbol: str) -> str:\n    # keep digits, letters and dots, replace others by space\n    symbol = ''.join(c if c.isalnum() or c in ('.', '+') else ' ' for c in symbol)\n    return coingecko_normalize(symbol.upper())\n\n\ndef coingecko_normalize_name(name: str) -> str:\n    # keep digits and letters, replace others by space (except when only composed by upper case letters, digits and dots)\n    if not all(c.isupper() or c.isdigit() or c == '.' for c in name):\n        name = ''.join(c if c.isalnum() else ' ' for c in name)\n    return coingecko_normalize(name)\n\n\ndef coingecko_normalize(sym: str) -> str:\n    sym = sym.strip()\n    # do not concatenate numbers => separate them with a dot\n    sym = list(sym)\n    if len(sym) > 4:\n        for i in range(2, len(sym) - 1):\n            if sym[i] == ' ' and sym[i - 1].isdigit() and sym[i + 1].isdigit():\n                sym[i] = '.'\n    sym = ''.join(sym)\n    # concatenate space-separated words => use CamelCase to distinguish the words\n    if ' ' in sym:\n        if sum(c.islower() for c in sym):  # if there is at least one lower case letter\n            sym = ' '.join(word[0].upper() + word[1:] for word in sym.split())  # Just capitalize initial letter of each word\n        else:  # CoinGecko may provide full upper-case as for \"THE STONE COIN\"\n            sym = string.capwords(sym)  # capwords converts \"THE STONE COIN\" to \"The Stone Coin\"\n        sym = sym.replace(' ', '')  # concatenate words\n    return sym\n\n\ndef is_name_short(coin: dict) -> bool:\n    \"\"\"return True if the coin name is enough short compared to the coin symbol.\"\"\"\n    return len(coin['name']) <= max(5, len(coin['symbol']) + 1)\n\n\ndef has_many_caps(name: str) -> bool:\n    \"\"\"return True if the symbol contains enough upper case letters, False if empty.\"\"\"\n    return str and sum(c.islower() for c in name) < (len(name) / 2)\n\n\ndef coingecko_normalize_all(coin: dict):\n    SYMBOL_TO_NORMALIZED = {'miota': 'IOTA'}\n    normalized = SYMBOL_TO_NORMALIZED.get(coin['symbol'])\n    if normalized:\n        coin['ns'] = coin['nn'] = normalized\n        return normalized\n\n    # ns = normalized symbol, nn = normalized name\n    coin['ns'] = coingecko_normalize_symbol(coin['symbol'])\n\n    ID_SUFFIX = '-bitcoin-token'\n    if coin['id'][-len(ID_SUFFIX):] == ID_SUFFIX:\n        coin['nn'] = 'BTC' + coin['ns']\n        return coin['nn']\n\n    name = coin['name']\n\n    prefixes = ('The ', 'the ')\n    for p in prefixes:\n        if name[:len(p)] == p:\n            coin['reduced-name'] = True\n            name = name[len(p):]\n            break\n\n    suffixes = ('coin', 'coins', 'money', 'finance', 'protocol', 'reward', 'rewards', 'token')\n    for s in suffixes:\n        if len(name) > len(s) and name[-len(s):].lower() == s:\n            # but keep suffix when lower-case concatenated\n            if name[-len(s)].islower() and name[-len(s) - 1] != ' ':\n                continue\n            # also keep suffix to avoid confusing nam: \"Bitcoin Token\" -> \"Bitcoin\"\n            if name[:-len(s)].strip().lower() == 'bitcoin':\n                continue\n            coin['reduced-name'] = True\n            name = name[:-len(s)]\n            break\n\n    coin['nn'] = coingecko_normalize_name(name)\n\n    if len(coin['nn']) < len(coin['ns']):\n        if 'reduced-name' in coin:\n            coin['reduced-name'] = False\n            name = coin['name']\n            coin['nn'] = coingecko_normalize_name(name)\n        elif not has_many_caps(name):\n            return coin['ns']\n\n    if not coin['ns']:  # coin['symbol'] may be an emoji that is striped when normalized\n        return coin['nn']\n\n    if coin.get('reduced-name') and coin['ns'].upper() != coin['nn'].upper():\n        return coin['ns']\n\n    i = coin['nn'].find('.')  # if there is a dot in normalized name => prefer the normalized symbol\n    if i >= 0:\n        if i > 1 and coin['nn'][i - 1].isdigit() and coin['nn'][i + 1].isdigit():\n            pass  # except when the dot separates digits\n        else:\n            return coin['ns']\n\n    if is_name_short(coin) and has_many_caps(name):\n        return coin['nn']\n\n    if 1.5 * len(coin['ns']) > len(coin['nn']) and any(c.islower() for c in coin['ns']):\n        return coin['nn']\n\n    return coin['ns']\n\n\ndef coingecko_symbols() -> Dict[str, str]:\n    r = None\n    intermediate = defaultdict(list)\n    try:\n        r = requests.get('https://api.coingecko.com/api/v3/coins/list')\n        all_coins = r.json()\n        # First pass: generate & compare normalized symbol/name, and then select the most pertinent\n        for coin in all_coins:\n            normalized = coingecko_normalize_all(coin)\n            intermediate[normalized].append(coin)\n            # Above line keeps together the coins having the same normalized symbol.\n            # To reduce collision, the coin['name'] is sometimes used in lieu of the coin['symbol'].\n            # The coin['name'] is not capitalized because lower case letters may be meaningful: cETH, yUSD, DATx, zLOT\n    except Exception as why:\n        raise_failure_explanation('COINGECKO', why, {\"\": r})\n\n    final = coingecko_second_pass(intermediate)\n    return coingecko_third_pass(final)\n\n\ndef coingecko_second_pass(intermediate: Dict[str, List[dict]]) -> Dict[str, List[dict]]:\n    # Second pass: fixes most of the symbol collisions\n    final = defaultdict(list)\n    for normalized, coins in intermediate.items():\n        if len(coins) == 1:\n            final[normalized].append(coins[0])\n            continue\n        set_normalized = False\n        for i in range(len(coins)):\n            if normalized == coins[i]['nn']:\n                coin = coins.pop(i)\n                final[normalized].append(coin)\n                set_normalized = True\n                break\n        rest: List[dict] = []\n        for coin in coins:\n            if '%' in coin['name']:\n                if len(coins) == 1:\n                    n = coin['ns']\n                else:\n                    n = coingecko_normalize_name(coin['id'])\n                final[n].append(coin)\n            else:\n                rest.append(coin)\n        if not rest:\n            continue\n        if not set_normalized:\n            rest.sort(key=lambda coin: len(coin['nn']), reverse=True)  # sort by the length of the normalized name\n            coin = rest.pop(0)\n            final[normalized].append(coin)\n        for coin in rest:\n            if coin['nn'] not in intermediate:\n                n = coin['nn']\n            elif coin.get('reduced-name'):\n                n = coingecko_normalize_name(coin['name'])\n            else:\n                n = coingecko_normalize_name(coin['id'])\n            final[n].append(coin)\n    return final\n\n\ndef coingecko_third_pass(final: Dict[str, List[dict]]) -> Dict[str, str]:\n    # Third pass: fixes some remaining collisions and fills the result\n    symbols = {}\n    for normalized, coins in final.items():\n        if len(coins) == 1:\n            symbols[normalized] = coins[0]['id']\n            continue\n        set_normalized = False\n        for i in range(len(coins)):\n            if normalized == coins[i]['nn']:\n                coin = coins.pop(i)\n                symbols[normalized] = coin['id']\n                set_normalized = True\n                break\n        rest: List[dict] = []\n        for coin in coins:\n            if '%' in coin['name']:\n                if len(coins) == 1:\n                    n = coin['ns']\n                else:\n                    n = coingecko_normalize_name(coin['id'])\n                symbols[n] = coin['id']\n            else:\n                rest.append(coin)\n        if not rest:\n            continue\n        if not set_normalized:\n            rest.sort(key=lambda coin: len(coin['nn']), reverse=True)  # sort by the length of the normalized name\n            coin = rest.pop(0)\n            symbols[normalized] = coin['id']\n        for coin in rest:\n            if coin['nn'] not in final:\n                n = coin['nn']\n            elif coin.get('reduced-name'):\n                n = coingecko_normalize_name(coin['name'])\n            else:\n                n = coingecko_normalize_name(coin['id'])\n            symbols[n] = coin['id']\n    return symbols\n\n\ndef whale_alert_coins(key_id: str) -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get(f'https://api.whale-alert.io/v1/status?api_key={key_id}')\n        # Same symbols, but on different blockchains (for instance USDT), are naturally overwritten.\n        return {s.upper(): s for b in r.json()['blockchains'] for s in b['symbols'] if s}\n    except Exception as why:\n        raise_failure_explanation('WHALES_ALERT', why, {\"\": r})\n\n\n_exchange_function_map = {\n    BITFINEX: bitfinex_symbols,\n    BITFLYER: bitflyer_symbols,\n    COINBASE: coinbase_symbols,\n    GEMINI: gemini_symbols,\n    HITBTC: hitbtc_symbols,\n    POLONIEX: poloniex_symbols,\n    PROBIT: probit_symbols,\n    BITSTAMP: bitstamp_symbols,\n    KRAKEN: kraken_symbols,\n    KRAKEN + 'REST': kraken_rest_symbols,\n    BINANCE: binance_symbols,\n    BINANCE_US: binance_us_symbols,\n    BINANCE_FUTURES: binance_futures_symbols,\n    BINANCE_DELIVERY: binance_delivery_symbols,\n    BLOCKCHAIN: blockchain_symbols,\n    EXX: exx_symbols,\n    HUOBI: huobi_symbols,\n    HUOBI_DM: huobi_dm_symbols,\n    HUOBI_SWAP: huobi_swap_symbols,\n    OKCOIN: okcoin_symbols,\n    OKEX: okex_symbols,\n    BYBIT: bybit_symbols,\n    FTX: ftx_symbols,\n    FTX_US: ftx_us_symbols,\n    BITTREX: bittrex_symbols,\n    BITCOINCOM: bitcoincom_symbols,\n    BITMAX: bitmax_symbols,\n    UPBIT: upbit_symbols,\n    GATEIO: gateio_symbols,\n    BITMEX: bitmex_symbols,\n    DERIBIT: deribit_symbols,\n    KRAKEN_FUTURES: kraken_future_symbols,\n    COINGECKO: coingecko_symbols,\n    WHALE_ALERT: whale_alert_coins\n}\n",
        "source_code_len": 30534,
        "target_code": "associated with this software.\n'''\nfrom typing import Dict, Tuple\n\n\nclass _Symbols:\n    def __init__(self):\n        self.data = {}\n\n    def set(self, exchange: str, normalized: dict, exchange_info: dict):\n        self.data[exchange] = {}\n        self.data[exchange]['normalized'] = normalized\n        self.data[exchange]['info'] = exchange_info\n\n    def get(self, exchange: str) -> Tuple[Dict, Dict]:\n        return self.data[exchange]['normalized'], self.data[exchange]['info']\n\n    def populated(self, exchange: str) -> bool:\n        return exchange in self.data\n\n\nSymbols = _Symbols()\n",
        "target_code_len": 588,
        "diff_format": "@@ -5,845 +5,22 @@\n associated with this software.\n+'''\n+from typing import Dict, Tuple\n \n \n-Symbol generation code for exchanges\n-'''\n+class _Symbols:\n+    def __init__(self):\n+        self.data = {}\n \n-import logging\n-import string\n-import time\n-from collections import defaultdict\n-from typing import Dict, List, Optional, Tuple\n+    def set(self, exchange: str, normalized: dict, exchange_info: dict):\n+        self.data[exchange] = {}\n+        self.data[exchange]['normalized'] = normalized\n+        self.data[exchange]['info'] = exchange_info\n \n-import requests\n-from requests import Response\n+    def get(self, exchange: str) -> Tuple[Dict, Dict]:\n+        return self.data[exchange]['normalized'], self.data[exchange]['info']\n \n-from cryptofeed.defines import *\n+    def populated(self, exchange: str) -> bool:\n+        return exchange in self.data\n \n \n-LOG = logging.getLogger('feedhandler')\n-\n-SYMBOL_SEP = '-'\n-\n-_symbols_retrieval_cache: Dict[str, Dict[str, str]] = {}\n-_exchange_info = defaultdict(lambda: defaultdict(dict))\n-\n-\n-_kraken_futures_product_type = {\n-    'FI': 'Inverse Futures',\n-    'FV': 'Vanilla Futures',\n-    'PI': 'Perpetual Inverse Futures',\n-    'PV': 'Perpetual Vanilla Futures',\n-    'IN': 'Real Time Index',\n-    'RR': 'Reference Rate',\n-}\n-\n-\n-def raise_failure_explanation(feed_id: str, exception: BaseException, responses: Dict[str, Optional[Response]]):\n-    LOG.critical('%s: encountered %r while processing response from exchange API', feed_id, exception)\n-    if len(responses) > 1:\n-        LOG.critical('%s: content of one of the %s responses was unexpected', feed_id, len(responses))\n-    for url, r in responses.items():\n-        if url:\n-            LOG.critical('%s: requested URL: %s', feed_id, url)\n-        if r:\n-            LOG.critical('%s: unexpected response: %s', feed_id, r.text)\n-    raise ValueError(f'Cryptofeed stopped because of an unexpected response from {feed_id}') from exception\n-\n-\n-def set_symbol_separator(separator: str):\n-    global SYMBOL_SEP\n-    SYMBOL_SEP = separator\n-\n-\n-def get_symbol_separator() -> str:\n-    global SYMBOL_SEP\n-    return SYMBOL_SEP\n-\n-\n-def gen_symbols(exchange: str, key_id=None) -> Dict[str, str]:\n-    if exchange not in _symbols_retrieval_cache:\n-        LOG.info(\"%s: Getting list of symbols\", exchange)\n-        symbols = _exchange_function_map[exchange](key_id) if key_id else _exchange_function_map[exchange]()\n-        LOG.info(\"%s: %s symbols\", exchange, len(symbols))\n-\n-        # log all retrieved symbols using debug level\n-        for normalized, exch_sym in sorted(symbols.items()):\n-            LOG.debug('%s: id-from-exch -> normalized: %-35s-> %s', exchange, exch_sym, normalized)\n-\n-        _symbols_retrieval_cache[exchange] = symbols\n-    return _symbols_retrieval_cache[exchange]\n-\n-\n-def _binance_symbols(endpoint: str, exchange: str):\n-    r = None\n-    try:\n-        ret = {}\n-        r = requests.get(endpoint)\n-        for symbol in r.json()['symbols']:\n-            if symbol.get('status', 'TRADING') != \"TRADING\":\n-                continue\n-            if symbol.get('contractStatus', 'TRADING') != \"TRADING\":\n-                continue\n-            split = len(symbol['baseAsset'])\n-            normalized = symbol['symbol'][:split] + SYMBOL_SEP + symbol['symbol'][split:]\n-            ret[normalized] = symbol['symbol']\n-            _exchange_info[exchange]['tick_size'][normalized] = symbol['filters'][0]['tickSize']\n-            if \"contractType\" in symbol:\n-                _exchange_info[exchange]['contract_type'][normalized] = symbol['contractType']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation(exchange, why, {endpoint: r})\n-\n-\n-def binance_symbols() -> Dict[str, str]:\n-    return _binance_symbols('https://api.binance.com/api/v3/exchangeInfo', BINANCE)\n-\n-\n-def binance_us_symbols() -> Dict[str, str]:\n-    return _binance_symbols('https://api.binance.us/api/v3/exchangeInfo', BINANCE_US)\n-\n-\n-def binance_futures_symbols() -> Dict[str, str]:\n-    base = _binance_symbols('https://fapi.binance.com/fapi/v1/exchangeInfo', BINANCE_FUTURES)\n-    add = {}\n-    for symbol, orig in base.items():\n-        if \"_\" in orig:\n-            continue\n-        add[f\"{symbol}-PINDEX\"] = f\"p{orig}\"\n-    base.update(add)\n-    return base\n-\n-\n-def binance_delivery_symbols() -> Dict[str, str]:\n-    return _binance_symbols('https://dapi.binance.com/dapi/v1/exchangeInfo', BINANCE_DELIVERY)\n-\n-\n-def bitfinex_symbols() -> Dict[str, str]:\n-    # doc: https://docs.bitfinex.com/docs/ws-general#supported-pairs\n-    r1 = r2 = None\n-    try:\n-        r1 = requests.get('https://api.bitfinex.com/v2/tickers?symbols=ALL')\n-        r2 = requests.get('https://api-pub.bitfinex.com/v2/conf/pub:map:currency:sym')\n-        tickers: List[List[str]] = r1.json()\n-        norm: List[Tuple[str, str]] = r2.json()[0]\n-        norm: Dict[str, str] = dict(norm)\n-        for k, v in dict(norm).items():\n-            if k[-2:] == 'F0' or '-' in v:  # Do not convert BTCF0 -> BTC or PBTCETH -> PBTC-ETH\n-                del norm[k]\n-        norm['BCHN'] = 'BCH'  # Bitfinex uses BCHN, other exchanges use BCH\n-\n-        ret = {}\n-        for symbol in [t[0] for t in tickers]:\n-            if symbol[0] == 'f':\n-                normalized = norm.get(symbol[1:], symbol[1:])\n-            else:\n-                if len(symbol) == 7:\n-                    base, quote = symbol[1:4], symbol[4:]\n-                else:\n-                    base, quote = symbol[1:].split(':')\n-                    assert ':' in symbol\n-                normalized = norm.get(base, base) + SYMBOL_SEP + norm.get(quote, quote)\n-            ret[normalized.upper()] = symbol\n-        return ret\n-    except ValueError as why:\n-        raise_failure_explanation('BITFINEX', why, {\"tickers?symbols=ALL\": r1, \"pub:map:currency:sym\": r2})\n-\n-\n-def bitflyer_symbols() -> Dict[str, str]:\n-    endpoint = r = None\n-    try:\n-        ret = {}\n-        endpoints = ['https://api.bitflyer.com/v1/getmarkets/eu', 'https://api.bitflyer.com/v1/getmarkets/usa', 'https://api.bitflyer.com/v1/getmarkets']\n-        for endpoint in endpoints:\n-            r = requests.get(endpoint)\n-            for entry in r.json():\n-                normalized = entry['product_code'].replace(\"_\", SYMBOL_SEP)\n-                ret[normalized] = entry['product_code']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('BITFLYER', why, {endpoint: r})\n-\n-\n-def bybit_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.bybit.com/v2/public/symbols')\n-        ret = {}\n-        for symbol in r.json()['result']:\n-            quote = symbol['quote_currency']\n-            if not symbol['name'].endswith(quote):\n-                base, contract = symbol['name'].split(quote)\n-                normalized = f\"{base}{SYMBOL_SEP}{quote}-{contract}\"\n-            else:\n-                normalized = f\"{symbol['base_currency']}{SYMBOL_SEP}{quote}\"\n-            ret[normalized] = symbol['name']\n-            _exchange_info[BYBIT]['tick_size'][normalized] = symbol['price_filter']['tick_size']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('BYBIT', why, {\"\": r})\n-\n-\n-def _ftx_helper(endpoint: str, exchange: str):\n-    r = None\n-    try:\n-        r = requests.get(endpoint)\n-        ret = {}\n-        for data in r.json()['result']:\n-            normalized = data['name'].replace(\"/\", SYMBOL_SEP)\n-            symbol = data['name']\n-            ret[normalized] = symbol\n-            _exchange_info[exchange]['tick_size'][normalized] = data['priceIncrement']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation(exchange, why, {endpoint: r})\n-\n-\n-def ftx_symbols() -> Dict[str, str]:\n-    return _ftx_helper('https://ftx.com/api/markets', FTX)\n-\n-\n-def ftx_us_symbols() -> Dict[str, str]:\n-    return _ftx_helper('https://ftx.us/api/markets', FTX_US)\n-\n-\n-def coinbase_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.pro.coinbase.com/products')\n-        ret = {}\n-        for data in r.json():\n-            normalized = data['id'].replace(\"-\", SYMBOL_SEP)\n-            ret[normalized] = data['id']\n-            _exchange_info[COINBASE]['tick_size'][normalized] = data['quote_increment']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('COINBASE', why, {\"\": r})\n-\n-\n-def gemini_symbols(*args) -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.gemini.com/v1/symbols')\n-        ret = {}\n-        for symbol in r.json():\n-            std = f\"{symbol[:-3]}{SYMBOL_SEP}{symbol[-3:]}\"\n-            std = std.upper()\n-            ret[std] = symbol.upper()\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('GEMINI', why, {\"\": r})\n-\n-\n-def hitbtc_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        ret = {}\n-        r = requests.get('https://api.hitbtc.com/api/2/public/symbol')\n-        for symbol in r.json():\n-            split = len(symbol['baseCurrency'])\n-            normalized = symbol['id'][:split] + SYMBOL_SEP + symbol['id'][split:]\n-            ret[normalized] = symbol['id']\n-            _exchange_info[HITBTC]['tick_size'][normalized] = symbol['tickSize']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('HITBTC', why, {\"\": r})\n-\n-\n-def poloniex_id_symbol_mapping():\n-    r = None\n-    try:\n-        r = requests.get('https://poloniex.com/public?command=returnTicker')\n-        symbols = r.json()\n-        ret = {}\n-        for symbol in symbols:\n-            ret[symbols[symbol]['id']] = symbol\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('POLONIEX', why, {\"\": r})\n-\n-\n-def poloniex_symbols() -> Dict[str, str]:\n-    ret = {}\n-    for _, value in poloniex_id_symbol_mapping().items():\n-        std = value.replace(\"STR\", \"XLM\")\n-        quote, base = std.split(\"_\")\n-        ret[quote + SYMBOL_SEP + base] = value\n-    return ret\n-\n-\n-def bitstamp_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://www.bitstamp.net/api/v2/trading-pairs-info/')\n-        ret = {}\n-        for data in r.json():\n-            normalized = data['name'].replace(\"/\", SYMBOL_SEP)\n-            symbol = data['url_symbol']\n-            ret[normalized] = symbol\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('BITSTAMP', why, {\"\": r})\n-\n-\n-def kraken_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.kraken.com/0/public/AssetPairs')\n-        data = r.json()\n-        ret = {}\n-        for symbol in data['result']:\n-            if 'wsname' not in data['result'][symbol] or '.d' in symbol:\n-                # https://blog.kraken.com/post/259/introducing-the-kraken-dark-pool/\n-                # .d is for dark pool symbols\n-                continue\n-\n-            base, quote = data['result'][symbol]['wsname'].split(\"/\")\n-\n-            normalized = f\"{base}{SYMBOL_SEP}{quote}\"\n-            exch = data['result'][symbol]['wsname']\n-            normalized = normalized.replace('XBT', 'BTC')\n-            normalized = normalized.replace('XDG', 'DOG')\n-            ret[normalized] = exch\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('KRAKEN', why, {\"\": r})\n-\n-\n-def kraken_rest_symbols() -> Dict[str, str]:\n-    return {normalized: exchange.replace(\"/\", \"\") for normalized, exchange in kraken_symbols().items()}\n-\n-\n-def exx_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.exx.com/data/v1/tickers')\n-        exchange = [key.upper() for key in r.json().keys()]\n-        symbols = [key.replace(\"_\", SYMBOL_SEP) for key in exchange]\n-        return dict(zip(symbols, exchange))\n-    except Exception as why:\n-        raise_failure_explanation('EXX', why, {\"\": r})\n-\n-\n-def huobi_common_symbols(url: str):\n-    r = None\n-    try:\n-        r = requests.get(url)\n-        ret = {}\n-        for e in r.json()['data']:\n-            if e['state'] == 'offline':\n-                continue\n-            normalized = f\"{e['base-currency'].upper()}{SYMBOL_SEP}{e['quote-currency'].upper()}\"\n-            symbol = f\"{e['base-currency']}{e['quote-currency']}\"\n-            ret[normalized] = symbol\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('HUOBI', why, {url: r})\n-\n-\n-def huobi_symbols() -> Dict[str, str]:\n-    return huobi_common_symbols('https://api.huobi.pro/v1/common/symbols')\n-\n-\n-def huobi_us_symbols() -> Dict[str, str]:\n-    return huobi_common_symbols('https://api.huobi.com/v1/common/symbols')\n-\n-\n-def huobi_dm_symbols() -> Dict[str, str]:\n-    \"\"\"\n-    Mapping is, for instance: {\"BTC_CW\":\"BTC190816\"}\n-    See comments in exchange/huobi_dm.py\n-    \"\"\"\n-    mapping = {\n-        \"this_week\": \"CW\",\n-        \"next_week\": \"NW\",\n-        \"quarter\": \"CQ\",\n-        \"next_quarter\": \"NQ\"\n-    }\n-    r = None\n-    try:\n-        r = requests.get('https://www.hbdm.com/api/v1/contract_contract_info')\n-        symbols = {}\n-        for e in r.json()['data']:\n-            symbols[f\"{e['symbol']}_{mapping[e['contract_type']]}\"] = e['contract_code']\n-            _exchange_info[HUOBI_DM]['tick_size'][e['contract_code']] = e['price_tick']\n-            _exchange_info[HUOBI_DM]['short_code_mappings'][f\"{e['symbol']}_{mapping[e['contract_type']]}\"] = e['contract_code']\n-        return symbols\n-    except Exception as why:\n-        raise_failure_explanation('HUOBI_DM', why, {\"\": r})\n-\n-\n-def huobi_swap_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.hbdm.com/swap-api/v1/swap_contract_info')\n-        symbols = {}\n-        for e in r.json()['data']:\n-            symbols[e['contract_code']] = e['contract_code']\n-            _exchange_info[HUOBI_SWAP]['tick_size'][e['contract_code']] = e['price_tick']\n-        return symbols\n-    except Exception as why:\n-        raise_failure_explanation('HUOBI_SWAP', why, {\"\": r})\n-\n-\n-def okcoin_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://www.okcoin.com/api/spot/v3/instruments')\n-        ret = {}\n-        for e in r.json():\n-            ret[e['instrument_id']] = e['instrument_id']\n-            _exchange_info[OKCOIN]['tick_size'][e['instrument_id']] = e['tick_size']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('OKCOIN', why, {\"\": r})\n-\n-\n-def okex_symbols(*args) -> Dict[str, str]:\n-    urls = ['https://www.okex.com/api/spot/v3/instruments',\n-            'https://www.okex.com/api/swap/v3/instruments',\n-            'https://www.okex.com/api/futures/v3/instruments']\n-    urls = urls + okex_compute_option_urls_from_underlyings()\n-\n-    symbols: Dict[str, str] = {}\n-    for u in urls:\n-        time.sleep(0.2)\n-        symbols.update(okex_symbols_from_one_url(u))\n-\n-    for symbol in symbols:\n-        instrument_type = 'futures'\n-        dash_count = symbol.count(get_symbol_separator())\n-        if dash_count == 1:  # BTC-USDT\n-            instrument_type = 'spot'\n-        if dash_count == 4:  # BTC-USD-201225-35000-P\n-            instrument_type = 'option'\n-        if symbol[-4:] == \"SWAP\":  # BTC-USDT-SWAP\n-            instrument_type = 'swap'\n-\n-        _exchange_info[OKEX]['instrument_type'][symbol] = instrument_type\n-\n-    return symbols\n-\n-\n-def okex_compute_option_urls_from_underlyings() -> List[str]:\n-    url = 'https://www.okex.com/api/option/v3/underlying'\n-    r = None\n-    try:\n-        r = requests.get(url)\n-        return [f'https://www.okex.com/api/option/v3/instruments/{underlying}' for underlying in r.json()]\n-    except Exception as why:\n-        raise_failure_explanation('OKEX', why, {url: r})\n-\n-\n-def okex_symbols_from_one_url(url: str) -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get(url)\n-        ret = {}\n-        for e in r.json():\n-            ret[e['instrument_id']] = e['instrument_id']\n-            _exchange_info[OKEX]['tick_size'][e['instrument_id']] = e['tick_size']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('OKEX', why, {url: r})\n-\n-\n-def bittrex_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.bittrex.com/api/v1.1/public/getmarkets')\n-        r = r.json()['result']\n-        return {f\"{e['MarketCurrency']}{SYMBOL_SEP}{e['BaseCurrency']}\": e['MarketName'] for e in r if e['IsActive']}\n-    except Exception as why:\n-        raise_failure_explanation('BITTREX', why, {\"\": r})\n-\n-\n-def bitcoincom_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.exchange.bitcoin.com/api/2/public/symbol')\n-        return {f\"{data['baseCurrency']}{SYMBOL_SEP}{data['quoteCurrency'].replace('USD', 'USDT')}\": data['id'] for data in r.json()}\n-    except Exception as why:\n-        raise_failure_explanation('BITCOINCOM', why, {\"\": r})\n-\n-\n-def bitmax_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://bitmax.io/api/pro/v1/products')\n-        ret = {}\n-        for entry in r.json()['data']:\n-            # Only \"Normal\" status symbols are tradeable\n-            if entry['status'] == 'Normal':\n-                normalized = f\"{entry['baseAsset']}{SYMBOL_SEP}{entry['quoteAsset']}\"\n-                ret[normalized] = entry['symbol']\n-                _exchange_info[BITMAX]['tick_size'][normalized] = entry['tickSize']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('BITMAX', why, {\"\": r})\n-\n-\n-def upbit_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.upbit.com/v1/market/all')\n-        return {f\"{data['market'].split('-')[1]}{SYMBOL_SEP}{data['market'].split('-')[0]}\": data['market'] for data in r.json()}\n-    except Exception as why:\n-        raise_failure_explanation('UPBIT', why, {\"\": r})\n-\n-\n-def blockchain_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get(\"https://api.blockchain.com/mercury-gateway/v1/instruments\")\n-        return {data[\"symbol\"].replace(\"-\", SYMBOL_SEP): data[\"symbol\"] for data in r.json()}\n-    except Exception as why:\n-        raise_failure_explanation('BLOCKCHAIN', why, {\"\": r})\n-\n-\n-def gateio_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get(\"https://api.gateio.ws/api/v4/spot/currency_pairs\")\n-        return {data[\"id\"].replace(\"_\", SYMBOL_SEP): data['id'] for data in r.json()}\n-    except Exception as why:\n-        raise_failure_explanation('GATEIO', why, {\"\": r})\n-\n-\n-def bitmex_symbols() -> Dict[str, str]:\n-    r = None\n-    ret = {}\n-    try:\n-        r = requests.get(\"https://www.bitmex.com/api/v1/instrument/active\")\n-        for entry in r.json():\n-            components = []\n-            components.append(entry['rootSymbol'])\n-            components.append(entry['quoteCurrency'])\n-\n-            if entry['expiry']:\n-                components.append(entry['symbol'][-3:])\n-\n-            normalized = SYMBOL_SEP.join(components)\n-            normalized = normalized.replace(\"XBT\", \"BTC\")\n-            ret[normalized] = entry['symbol']\n-            _exchange_info[BITMEX]['tick_size'][normalized] = entry['tickSize']\n-\n-            if entry['expiry']:\n-                _exchange_info[BITMEX]['expiry'][normalized] = entry['expiry']\n-\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('BITMEX', why, {\"\": r})\n-\n-\n-def deribit_symbols() -> Dict[str, str]:\n-    url = r = None\n-    ret = {}\n-    try:\n-        # TODO: get currencies from https://www.deribit.com/api/v2/public/get_currencies\n-        currencies = ['BTC', 'ETH']\n-        for c in currencies:\n-            url = f\"https://www.deribit.com/api/v2/public/get_instruments?currency={c}&expired=false\"\n-            r = requests.get(url)\n-            for entry in r.json()['result']:\n-                split = entry['instrument_name'].split(\"-\")\n-                normalized = split[0] + SYMBOL_SEP + entry['quote_currency'] + \"-\" + '-'.join(split[1:])\n-                ret[normalized] = entry['instrument_name']\n-                _exchange_info[DERIBIT]['tick_size'][normalized] = entry['tick_size']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('DERIBIT', why, {url: r})\n-\n-\n-def kraken_future_symbols() -> Dict[str, str]:\n-    r = None\n-    ret = {}\n-    try:\n-        r = requests.get('https://futures.kraken.com/derivatives/api/v3/instruments')\n-        data = r.json()['instruments']\n-        for entry in data:\n-            if not entry['tradeable']:\n-                continue\n-            normalized = entry['symbol'].upper().replace(\"_\", \"-\")\n-            symbol = normalized[3:6] + SYMBOL_SEP + normalized[6:9]\n-            normalized = normalized.replace(normalized[3:9], symbol)\n-            normalized = normalized.replace('XBT', 'BTC')\n-\n-            _exchange_info[KRAKEN_FUTURES]['tick_size'][normalized] = entry['tickSize']\n-            _exchange_info[KRAKEN_FUTURES]['contract_size'][normalized] = entry['contractSize']\n-            _exchange_info[KRAKEN_FUTURES]['underlying'][normalized] = entry['underlying']\n-            _exchange_info[KRAKEN_FUTURES]['product_type'][normalized] = _kraken_futures_product_type[normalized[:2]]\n-            ret[normalized] = entry['symbol']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('KRAKEN_FUTURES', why, {\"\": r})\n-\n-\n-def probit_symbols() -> Dict[str, str]:\n-    # doc: https://docs-en.probit.com/reference-link/market\n-    r = None\n-    try:\n-        r = requests.get('https://api.probit.com/api/exchange/v1/market')\n-        return {entry['id']: entry['id'] for entry in r.json()['data']}\n-    except Exception as why:\n-        raise_failure_explanation('PROBIT', why, {\"\": r})\n-\n-\n-def coingecko_normalize_symbol(symbol: str) -> str:\n-    # keep digits, letters and dots, replace others by space\n-    symbol = ''.join(c if c.isalnum() or c in ('.', '+') else ' ' for c in symbol)\n-    return coingecko_normalize(symbol.upper())\n-\n-\n-def coingecko_normalize_name(name: str) -> str:\n-    # keep digits and letters, replace others by space (except when only composed by upper case letters, digits and dots)\n-    if not all(c.isupper() or c.isdigit() or c == '.' for c in name):\n-        name = ''.join(c if c.isalnum() else ' ' for c in name)\n-    return coingecko_normalize(name)\n-\n-\n-def coingecko_normalize(sym: str) -> str:\n-    sym = sym.strip()\n-    # do not concatenate numbers => separate them with a dot\n-    sym = list(sym)\n-    if len(sym) > 4:\n-        for i in range(2, len(sym) - 1):\n-            if sym[i] == ' ' and sym[i - 1].isdigit() and sym[i + 1].isdigit():\n-                sym[i] = '.'\n-    sym = ''.join(sym)\n-    # concatenate space-separated words => use CamelCase to distinguish the words\n-    if ' ' in sym:\n-        if sum(c.islower() for c in sym):  # if there is at least one lower case letter\n-            sym = ' '.join(word[0].upper() + word[1:] for word in sym.split())  # Just capitalize initial letter of each word\n-        else:  # CoinGecko may provide full upper-case as for \"THE STONE COIN\"\n-            sym = string.capwords(sym)  # capwords converts \"THE STONE COIN\" to \"The Stone Coin\"\n-        sym = sym.replace(' ', '')  # concatenate words\n-    return sym\n-\n-\n-def is_name_short(coin: dict) -> bool:\n-    \"\"\"return True if the coin name is enough short compared to the coin symbol.\"\"\"\n-    return len(coin['name']) <= max(5, len(coin['symbol']) + 1)\n-\n-\n-def has_many_caps(name: str) -> bool:\n-    \"\"\"return True if the symbol contains enough upper case letters, False if empty.\"\"\"\n-    return str and sum(c.islower() for c in name) < (len(name) / 2)\n-\n-\n-def coingecko_normalize_all(coin: dict):\n-    SYMBOL_TO_NORMALIZED = {'miota': 'IOTA'}\n-    normalized = SYMBOL_TO_NORMALIZED.get(coin['symbol'])\n-    if normalized:\n-        coin['ns'] = coin['nn'] = normalized\n-        return normalized\n-\n-    # ns = normalized symbol, nn = normalized name\n-    coin['ns'] = coingecko_normalize_symbol(coin['symbol'])\n-\n-    ID_SUFFIX = '-bitcoin-token'\n-    if coin['id'][-len(ID_SUFFIX):] == ID_SUFFIX:\n-        coin['nn'] = 'BTC' + coin['ns']\n-        return coin['nn']\n-\n-    name = coin['name']\n-\n-    prefixes = ('The ', 'the ')\n-    for p in prefixes:\n-        if name[:len(p)] == p:\n-            coin['reduced-name'] = True\n-            name = name[len(p):]\n-            break\n-\n-    suffixes = ('coin', 'coins', 'money', 'finance', 'protocol', 'reward', 'rewards', 'token')\n-    for s in suffixes:\n-        if len(name) > len(s) and name[-len(s):].lower() == s:\n-            # but keep suffix when lower-case concatenated\n-            if name[-len(s)].islower() and name[-len(s) - 1] != ' ':\n-                continue\n-            # also keep suffix to avoid confusing nam: \"Bitcoin Token\" -> \"Bitcoin\"\n-            if name[:-len(s)].strip().lower() == 'bitcoin':\n-                continue\n-            coin['reduced-name'] = True\n-            name = name[:-len(s)]\n-            break\n-\n-    coin['nn'] = coingecko_normalize_name(name)\n-\n-    if len(coin['nn']) < len(coin['ns']):\n-        if 'reduced-name' in coin:\n-            coin['reduced-name'] = False\n-            name = coin['name']\n-            coin['nn'] = coingecko_normalize_name(name)\n-        elif not has_many_caps(name):\n-            return coin['ns']\n-\n-    if not coin['ns']:  # coin['symbol'] may be an emoji that is striped when normalized\n-        return coin['nn']\n-\n-    if coin.get('reduced-name') and coin['ns'].upper() != coin['nn'].upper():\n-        return coin['ns']\n-\n-    i = coin['nn'].find('.')  # if there is a dot in normalized name => prefer the normalized symbol\n-    if i >= 0:\n-        if i > 1 and coin['nn'][i - 1].isdigit() and coin['nn'][i + 1].isdigit():\n-            pass  # except when the dot separates digits\n-        else:\n-            return coin['ns']\n-\n-    if is_name_short(coin) and has_many_caps(name):\n-        return coin['nn']\n-\n-    if 1.5 * len(coin['ns']) > len(coin['nn']) and any(c.islower() for c in coin['ns']):\n-        return coin['nn']\n-\n-    return coin['ns']\n-\n-\n-def coingecko_symbols() -> Dict[str, str]:\n-    r = None\n-    intermediate = defaultdict(list)\n-    try:\n-        r = requests.get('https://api.coingecko.com/api/v3/coins/list')\n-        all_coins = r.json()\n-        # First pass: generate & compare normalized symbol/name, and then select the most pertinent\n-        for coin in all_coins:\n-            normalized = coingecko_normalize_all(coin)\n-            intermediate[normalized].append(coin)\n-            # Above line keeps together the coins having the same normalized symbol.\n-            # To reduce collision, the coin['name'] is sometimes used in lieu of the coin['symbol'].\n-            # The coin['name'] is not capitalized because lower case letters may be meaningful: cETH, yUSD, DATx, zLOT\n-    except Exception as why:\n-        raise_failure_explanation('COINGECKO', why, {\"\": r})\n-\n-    final = coingecko_second_pass(intermediate)\n-    return coingecko_third_pass(final)\n-\n-\n-def coingecko_second_pass(intermediate: Dict[str, List[dict]]) -> Dict[str, List[dict]]:\n-    # Second pass: fixes most of the symbol collisions\n-    final = defaultdict(list)\n-    for normalized, coins in intermediate.items():\n-        if len(coins) == 1:\n-            final[normalized].append(coins[0])\n-            continue\n-        set_normalized = False\n-        for i in range(len(coins)):\n-            if normalized == coins[i]['nn']:\n-                coin = coins.pop(i)\n-                final[normalized].append(coin)\n-                set_normalized = True\n-                break\n-        rest: List[dict] = []\n-        for coin in coins:\n-            if '%' in coin['name']:\n-                if len(coins) == 1:\n-                    n = coin['ns']\n-                else:\n-                    n = coingecko_normalize_name(coin['id'])\n-                final[n].append(coin)\n-            else:\n-                rest.append(coin)\n-        if not rest:\n-            continue\n-        if not set_normalized:\n-            rest.sort(key=lambda coin: len(coin['nn']), reverse=True)  # sort by the length of the normalized name\n-            coin = rest.pop(0)\n-            final[normalized].append(coin)\n-        for coin in rest:\n-            if coin['nn'] not in intermediate:\n-                n = coin['nn']\n-            elif coin.get('reduced-name'):\n-                n = coingecko_normalize_name(coin['name'])\n-            else:\n-                n = coingecko_normalize_name(coin['id'])\n-            final[n].append(coin)\n-    return final\n-\n-\n-def coingecko_third_pass(final: Dict[str, List[dict]]) -> Dict[str, str]:\n-    # Third pass: fixes some remaining collisions and fills the result\n-    symbols = {}\n-    for normalized, coins in final.items():\n-        if len(coins) == 1:\n-            symbols[normalized] = coins[0]['id']\n-            continue\n-        set_normalized = False\n-        for i in range(len(coins)):\n-            if normalized == coins[i]['nn']:\n-                coin = coins.pop(i)\n-                symbols[normalized] = coin['id']\n-                set_normalized = True\n-                break\n-        rest: List[dict] = []\n-        for coin in coins:\n-            if '%' in coin['name']:\n-                if len(coins) == 1:\n-                    n = coin['ns']\n-                else:\n-                    n = coingecko_normalize_name(coin['id'])\n-                symbols[n] = coin['id']\n-            else:\n-                rest.append(coin)\n-        if not rest:\n-            continue\n-        if not set_normalized:\n-            rest.sort(key=lambda coin: len(coin['nn']), reverse=True)  # sort by the length of the normalized name\n-            coin = rest.pop(0)\n-            symbols[normalized] = coin['id']\n-        for coin in rest:\n-            if coin['nn'] not in final:\n-                n = coin['nn']\n-            elif coin.get('reduced-name'):\n-                n = coingecko_normalize_name(coin['name'])\n-            else:\n-                n = coingecko_normalize_name(coin['id'])\n-            symbols[n] = coin['id']\n-    return symbols\n-\n-\n-def whale_alert_coins(key_id: str) -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get(f'https://api.whale-alert.io/v1/status?api_key={key_id}')\n-        # Same symbols, but on different blockchains (for instance USDT), are naturally overwritten.\n-        return {s.upper(): s for b in r.json()['blockchains'] for s in b['symbols'] if s}\n-    except Exception as why:\n-        raise_failure_explanation('WHALES_ALERT', why, {\"\": r})\n-\n-\n-_exchange_function_map = {\n-    BITFINEX: bitfinex_symbols,\n-    BITFLYER: bitflyer_symbols,\n-    COINBASE: coinbase_symbols,\n-    GEMINI: gemini_symbols,\n-    HITBTC: hitbtc_symbols,\n-    POLONIEX: poloniex_symbols,\n-    PROBIT: probit_symbols,\n-    BITSTAMP: bitstamp_symbols,\n-    KRAKEN: kraken_symbols,\n-    KRAKEN + 'REST': kraken_rest_symbols,\n-    BINANCE: binance_symbols,\n-    BINANCE_US: binance_us_symbols,\n-    BINANCE_FUTURES: binance_futures_symbols,\n-    BINANCE_DELIVERY: binance_delivery_symbols,\n-    BLOCKCHAIN: blockchain_symbols,\n-    EXX: exx_symbols,\n-    HUOBI: huobi_symbols,\n-    HUOBI_DM: huobi_dm_symbols,\n-    HUOBI_SWAP: huobi_swap_symbols,\n-    OKCOIN: okcoin_symbols,\n-    OKEX: okex_symbols,\n-    BYBIT: bybit_symbols,\n-    FTX: ftx_symbols,\n-    FTX_US: ftx_us_symbols,\n-    BITTREX: bittrex_symbols,\n-    BITCOINCOM: bitcoincom_symbols,\n-    BITMAX: bitmax_symbols,\n-    UPBIT: upbit_symbols,\n-    GATEIO: gateio_symbols,\n-    BITMEX: bitmex_symbols,\n-    DERIBIT: deribit_symbols,\n-    KRAKEN_FUTURES: kraken_future_symbols,\n-    COINGECKO: coingecko_symbols,\n-    WHALE_ALERT: whale_alert_coins\n-}\n+Symbols = _Symbols()\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\n\nimport logging\nimport string\nimport time\nfrom collections import defaultdict\nfrom typing import Dict, List, Optional, Tuple\n\nimport requests\nfrom requests import Response\n\nfrom cryptofeed.defines import *\n\n\nLOG = logging.getLogger('feedhandler')\n\nSYMBOL_SEP = '-'\n\n_symbols_retrieval_cache: Dict[str, Dict[str, str]] = {}\n_exchange_info = defaultdict(lambda: defaultdict(dict))\n\n\n_kraken_futures_product_type = {\n    'FI': 'Inverse Futures',\n    'FV': 'Vanilla Futures',\n    'PI': 'Perpetual Inverse Futures',\n    'PV': 'Perpetual Vanilla Futures',\n    'IN': 'Real Time Index',\n    'RR': 'Reference Rate',\n}\n\n\ndef raise_failure_explanation(feed_id: str, exception: BaseException, responses: Dict[str, Optional[Response]]):\n    <IND>LOG.critical('%s: encountered %r while processing response from exchange API', feed_id, exception)\n    if len(responses) > 1:\n        <IND>LOG.critical('%s: content of one of the %s responses was unexpected', feed_id, len(responses))\n    <DED>for url, r in responses.items():\n        <IND>if url:\n            <IND>LOG.critical('%s: requested URL: %s', feed_id, url)\n        <DED>if r:\n            <IND>LOG.critical('%s: unexpected response: %s', feed_id, r.text)\n    <DED><DED>raise ValueError(f'Cryptofeed stopped because of an unexpected response from {feed_id}') from exception\n\n\n<DED>def set_symbol_separator(separator: str):\n    <IND>global SYMBOL_SEP\n    SYMBOL_SEP = separator\n\n\n<DED>def get_symbol_separator() -> str:\n    <IND>global SYMBOL_SEP\n    return SYMBOL_SEP\n\n\n<DED>def gen_symbols(exchange: str, key_id=None) -> Dict[str, str]:\n    <IND>if exchange not in _symbols_retrieval_cache:\n        <IND>LOG.info(\"%s: Getting list of symbols\", exchange)\n        symbols = _exchange_function_map[exchange](key_id) if key_id else _exchange_function_map[exchange]()\n        LOG.info(\"%s: %s symbols\", exchange, len(symbols))\n\n        # log all retrieved symbols using debug level\n        for normalized, exch_sym in sorted(symbols.items()):\n            <IND>LOG.debug('%s: id-from-exch -> normalized: %-35s-> %s', exchange, exch_sym, normalized)\n\n        <DED>_symbols_retrieval_cache[exchange] = symbols\n    <DED>return _symbols_retrieval_cache[exchange]\n\n\n<DED>def _binance_symbols(endpoint: str, exchange: str):\n    <IND>r = None\n    try:\n        <IND>ret = {}\n        r = requests.get(endpoint)\n        for symbol in r.json()['symbols']:\n            <IND>if symbol.get('status', 'TRADING') != \"TRADING\":\n                <IND>continue\n            <DED>if symbol.get('contractStatus', 'TRADING') != \"TRADING\":\n                <IND>continue\n            <DED>split = len(symbol['baseAsset'])\n            normalized = symbol['symbol'][:split] + SYMBOL_SEP + symbol['symbol'][split:]\n            ret[normalized] = symbol['symbol']\n            _exchange_info[exchange]['tick_size'][normalized] = symbol['filters'][0]['tickSize']\n            if \"contractType\" in symbol:\n                <IND>_exchange_info[exchange]['contract_type'][normalized] = symbol['contractType']\n        <DED><DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation(exchange, why, {endpoint: r})\n\n\n<DED><DED>def binance_symbols() -> Dict[str, str]:\n    <IND>return _binance_symbols('https://api.binance.com/api/v3/exchangeInfo', BINANCE)\n\n\n<DED>def binance_us_symbols() -> Dict[str, str]:\n    <IND>return _binance_symbols('https://api.binance.us/api/v3/exchangeInfo', BINANCE_US)\n\n\n<DED>def binance_futures_symbols() -> Dict[str, str]:\n    <IND>base = _binance_symbols('https://fapi.binance.com/fapi/v1/exchangeInfo', BINANCE_FUTURES)\n    add = {}\n    for symbol, orig in base.items():\n        <IND>if \"_\" in orig:\n            <IND>continue\n        <DED>add[f\"{symbol}-PINDEX\"] = f\"p{orig}\"\n    <DED>base.update(add)\n    return base\n\n\n<DED>def binance_delivery_symbols() -> Dict[str, str]:\n    <IND>return _binance_symbols('https://dapi.binance.com/dapi/v1/exchangeInfo', BINANCE_DELIVERY)\n\n\n<DED>def bitfinex_symbols() -> Dict[str, str]:\n    # doc: https://docs.bitfinex.com/docs/ws-general#supported-pairs\n    <IND>r1 = r2 = None\n    try:\n        <IND>r1 = requests.get('https://api.bitfinex.com/v2/tickers?symbols=ALL')\n        r2 = requests.get('https://api-pub.bitfinex.com/v2/conf/pub:map:currency:sym')\n        tickers: List[List[str]] = r1.json()\n        norm: List[Tuple[str, str]] = r2.json()[0]\n        norm: Dict[str, str] = dict(norm)\n        for k, v in dict(norm).items():\n            <IND>if k[-2:] == 'F0' or '-' in v:  # Do not convert BTCF0 -> BTC or PBTCETH -> PBTC-ETH\n                <IND>del norm[k]\n        <DED><DED>norm['BCHN'] = 'BCH'  # Bitfinex uses BCHN, other exchanges use BCH\n\n        ret = {}\n        for symbol in [t[0] for t in tickers]:\n            <IND>if symbol[0] == 'f':\n                <IND>normalized = norm.get(symbol[1:], symbol[1:])\n            <DED>else:\n                <IND>if len(symbol) == 7:\n                    <IND>base, quote = symbol[1:4], symbol[4:]\n                <DED>else:\n                    <IND>base, quote = symbol[1:].split(':')\n                    assert ':' in symbol\n                <DED>normalized = norm.get(base, base) + SYMBOL_SEP + norm.get(quote, quote)\n            <DED>ret[normalized.upper()] = symbol\n        <DED>return ret\n    <DED>except ValueError as why:\n        <IND>raise_failure_explanation('BITFINEX', why, {\"tickers?symbols=ALL\": r1, \"pub:map:currency:sym\": r2})\n\n\n<DED><DED>def bitflyer_symbols() -> Dict[str, str]:\n    <IND>endpoint = r = None\n    try:\n        <IND>ret = {}\n        endpoints = ['https://api.bitflyer.com/v1/getmarkets/eu', 'https://api.bitflyer.com/v1/getmarkets/usa', 'https://api.bitflyer.com/v1/getmarkets']\n        for endpoint in endpoints:\n            <IND>r = requests.get(endpoint)\n            for entry in r.json():\n                <IND>normalized = entry['product_code'].replace(\"_\", SYMBOL_SEP)\n                ret[normalized] = entry['product_code']\n        <DED><DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BITFLYER', why, {endpoint: r})\n\n\n<DED><DED>def bybit_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.bybit.com/v2/public/symbols')\n        ret = {}\n        for symbol in r.json()['result']:\n            <IND>quote = symbol['quote_currency']\n            if not symbol['name'].endswith(quote):\n                <IND>base, contract = symbol['name'].split(quote)\n                normalized = f\"{base}{SYMBOL_SEP}{quote}-{contract}\"\n            <DED>else:\n                <IND>normalized = f\"{symbol['base_currency']}{SYMBOL_SEP}{quote}\"\n            <DED>ret[normalized] = symbol['name']\n            _exchange_info[BYBIT]['tick_size'][normalized] = symbol['price_filter']['tick_size']\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BYBIT', why, {\"\": r})\n\n\n<DED><DED>def _ftx_helper(endpoint: str, exchange: str):\n    <IND>r = None\n    try:\n        <IND>r = requests.get(endpoint)\n        ret = {}\n        for data in r.json()['result']:\n            <IND>normalized = data['name'].replace(\"/\", SYMBOL_SEP)\n            symbol = data['name']\n            ret[normalized] = symbol\n            _exchange_info[exchange]['tick_size'][normalized] = data['priceIncrement']\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation(exchange, why, {endpoint: r})\n\n\n<DED><DED>def ftx_symbols() -> Dict[str, str]:\n    <IND>return _ftx_helper('https://ftx.com/api/markets', FTX)\n\n\n<DED>def ftx_us_symbols() -> Dict[str, str]:\n    <IND>return _ftx_helper('https://ftx.us/api/markets', FTX_US)\n\n\n<DED>def coinbase_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.pro.coinbase.com/products')\n        ret = {}\n        for data in r.json():\n            <IND>normalized = data['id'].replace(\"-\", SYMBOL_SEP)\n            ret[normalized] = data['id']\n            _exchange_info[COINBASE]['tick_size'][normalized] = data['quote_increment']\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('COINBASE', why, {\"\": r})\n\n\n<DED><DED>def gemini_symbols(*args) -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.gemini.com/v1/symbols')\n        ret = {}\n        for symbol in r.json():\n            <IND>std = f\"{symbol[:-3]}{SYMBOL_SEP}{symbol[-3:]}\"\n            std = std.upper()\n            ret[std] = symbol.upper()\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('GEMINI', why, {\"\": r})\n\n\n<DED><DED>def hitbtc_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>ret = {}\n        r = requests.get('https://api.hitbtc.com/api/2/public/symbol')\n        for symbol in r.json():\n            <IND>split = len(symbol['baseCurrency'])\n            normalized = symbol['id'][:split] + SYMBOL_SEP + symbol['id'][split:]\n            ret[normalized] = symbol['id']\n            _exchange_info[HITBTC]['tick_size'][normalized] = symbol['tickSize']\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('HITBTC', why, {\"\": r})\n\n\n<DED><DED>def poloniex_id_symbol_mapping():\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://poloniex.com/public?command=returnTicker')\n        symbols = r.json()\n        ret = {}\n        for symbol in symbols:\n            <IND>ret[symbols[symbol]['id']] = symbol\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('POLONIEX', why, {\"\": r})\n\n\n<DED><DED>def poloniex_symbols() -> Dict[str, str]:\n    <IND>ret = {}\n    for _, value in poloniex_id_symbol_mapping().items():\n        <IND>std = value.replace(\"STR\", \"XLM\")\n        quote, base = std.split(\"_\")\n        ret[quote + SYMBOL_SEP + base] = value\n    <DED>return ret\n\n\n<DED>def bitstamp_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://www.bitstamp.net/api/v2/trading-pairs-info/')\n        ret = {}\n        for data in r.json():\n            <IND>normalized = data['name'].replace(\"/\", SYMBOL_SEP)\n            symbol = data['url_symbol']\n            ret[normalized] = symbol\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BITSTAMP', why, {\"\": r})\n\n\n<DED><DED>def kraken_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.kraken.com/0/public/AssetPairs')\n        data = r.json()\n        ret = {}\n        for symbol in data['result']:\n            <IND>if 'wsname' not in data['result'][symbol] or '.d' in symbol:\n                # https://blog.kraken.com/post/259/introducing-the-kraken-dark-pool/\n                # .d is for dark pool symbols\n                <IND>continue\n\n            <DED>base, quote = data['result'][symbol]['wsname'].split(\"/\")\n\n            normalized = f\"{base}{SYMBOL_SEP}{quote}\"\n            exch = data['result'][symbol]['wsname']\n            normalized = normalized.replace('XBT', 'BTC')\n            normalized = normalized.replace('XDG', 'DOG')\n            ret[normalized] = exch\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('KRAKEN', why, {\"\": r})\n\n\n<DED><DED>def kraken_rest_symbols() -> Dict[str, str]:\n    <IND>return {normalized: exchange.replace(\"/\", \"\") for normalized, exchange in kraken_symbols().items()}\n\n\n<DED>def exx_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.exx.com/data/v1/tickers')\n        exchange = [key.upper() for key in r.json().keys()]\n        symbols = [key.replace(\"_\", SYMBOL_SEP) for key in exchange]\n        return dict(zip(symbols, exchange))\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('EXX', why, {\"\": r})\n\n\n<DED><DED>def huobi_common_symbols(url: str):\n    <IND>r = None\n    try:\n        <IND>r = requests.get(url)\n        ret = {}\n        for e in r.json()['data']:\n            <IND>if e['state'] == 'offline':\n                <IND>continue\n            <DED>normalized = f\"{e['base-currency'].upper()}{SYMBOL_SEP}{e['quote-currency'].upper()}\"\n            symbol = f\"{e['base-currency']}{e['quote-currency']}\"\n            ret[normalized] = symbol\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('HUOBI', why, {url: r})\n\n\n<DED><DED>def huobi_symbols() -> Dict[str, str]:\n    <IND>return huobi_common_symbols('https://api.huobi.pro/v1/common/symbols')\n\n\n<DED>def huobi_us_symbols() -> Dict[str, str]:\n    <IND>return huobi_common_symbols('https://api.huobi.com/v1/common/symbols')\n\n\n<DED>def huobi_dm_symbols() -> Dict[str, str]:\n    <IND>\"\"\"\n    Mapping is, for instance: {\"BTC_CW\":\"BTC190816\"}\n    See comments in exchange/huobi_dm.py\n    \"\"\"\n    mapping = {\n        \"this_week\": \"CW\",\n        \"next_week\": \"NW\",\n        \"quarter\": \"CQ\",\n        \"next_quarter\": \"NQ\"\n    }\n    r = None\n    try:\n        <IND>r = requests.get('https://www.hbdm.com/api/v1/contract_contract_info')\n        symbols = {}\n        for e in r.json()['data']:\n            <IND>symbols[f\"{e['symbol']}_{mapping[e['contract_type']]}\"] = e['contract_code']\n            _exchange_info[HUOBI_DM]['tick_size'][e['contract_code']] = e['price_tick']\n            _exchange_info[HUOBI_DM]['short_code_mappings'][f\"{e['symbol']}_{mapping[e['contract_type']]}\"] = e['contract_code']\n        <DED>return symbols\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('HUOBI_DM', why, {\"\": r})\n\n\n<DED><DED>def huobi_swap_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.hbdm.com/swap-api/v1/swap_contract_info')\n        symbols = {}\n        for e in r.json()['data']:\n            <IND>symbols[e['contract_code']] = e['contract_code']\n            _exchange_info[HUOBI_SWAP]['tick_size'][e['contract_code']] = e['price_tick']\n        <DED>return symbols\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('HUOBI_SWAP', why, {\"\": r})\n\n\n<DED><DED>def okcoin_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://www.okcoin.com/api/spot/v3/instruments')\n        ret = {}\n        for e in r.json():\n            <IND>ret[e['instrument_id']] = e['instrument_id']\n            _exchange_info[OKCOIN]['tick_size'][e['instrument_id']] = e['tick_size']\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('OKCOIN', why, {\"\": r})\n\n\n<DED><DED>def okex_symbols(*args) -> Dict[str, str]:\n    <IND>urls = ['https://www.okex.com/api/spot/v3/instruments',\n            'https://www.okex.com/api/swap/v3/instruments',\n            'https://www.okex.com/api/futures/v3/instruments']\n    urls = urls + okex_compute_option_urls_from_underlyings()\n\n    symbols: Dict[str, str] = {}\n    for u in urls:\n        <IND>time.sleep(0.2)\n        symbols.update(okex_symbols_from_one_url(u))\n\n    <DED>for symbol in symbols:\n        <IND>instrument_type = 'futures'\n        dash_count = symbol.count(get_symbol_separator())\n        if dash_count == 1:  # BTC-USDT\n            <IND>instrument_type = 'spot'\n        <DED>if dash_count == 4:  # BTC-USD-201225-35000-P\n            <IND>instrument_type = 'option'\n        <DED>if symbol[-4:] == \"SWAP\":  # BTC-USDT-SWAP\n            <IND>instrument_type = 'swap'\n\n        <DED>_exchange_info[OKEX]['instrument_type'][symbol] = instrument_type\n\n    <DED>return symbols\n\n\n<DED>def okex_compute_option_urls_from_underlyings() -> List[str]:\n    <IND>url = 'https://www.okex.com/api/option/v3/underlying'\n    r = None\n    try:\n        <IND>r = requests.get(url)\n        return [f'https://www.okex.com/api/option/v3/instruments/{underlying}' for underlying in r.json()]\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('OKEX', why, {url: r})\n\n\n<DED><DED>def okex_symbols_from_one_url(url: str) -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get(url)\n        ret = {}\n        for e in r.json():\n            <IND>ret[e['instrument_id']] = e['instrument_id']\n            _exchange_info[OKEX]['tick_size'][e['instrument_id']] = e['tick_size']\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('OKEX', why, {url: r})\n\n\n<DED><DED>def bittrex_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.bittrex.com/api/v1.1/public/getmarkets')\n        r = r.json()['result']\n        return {f\"{e['MarketCurrency']}{SYMBOL_SEP}{e['BaseCurrency']}\": e['MarketName'] for e in r if e['IsActive']}\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BITTREX', why, {\"\": r})\n\n\n<DED><DED>def bitcoincom_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.exchange.bitcoin.com/api/2/public/symbol')\n        return {f\"{data['baseCurrency']}{SYMBOL_SEP}{data['quoteCurrency'].replace('USD', 'USDT')}\": data['id'] for data in r.json()}\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BITCOINCOM', why, {\"\": r})\n\n\n<DED><DED>def bitmax_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://bitmax.io/api/pro/v1/products')\n        ret = {}\n        for entry in r.json()['data']:\n            # Only \"Normal\" status symbols are tradeable\n            <IND>if entry['status'] == 'Normal':\n                <IND>normalized = f\"{entry['baseAsset']}{SYMBOL_SEP}{entry['quoteAsset']}\"\n                ret[normalized] = entry['symbol']\n                _exchange_info[BITMAX]['tick_size'][normalized] = entry['tickSize']\n        <DED><DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BITMAX', why, {\"\": r})\n\n\n<DED><DED>def upbit_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.upbit.com/v1/market/all')\n        return {f\"{data['market'].split('-')[1]}{SYMBOL_SEP}{data['market'].split('-')[0]}\": data['market'] for data in r.json()}\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('UPBIT', why, {\"\": r})\n\n\n<DED><DED>def blockchain_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get(\"https://api.blockchain.com/mercury-gateway/v1/instruments\")\n        return {data[\"symbol\"].replace(\"-\", SYMBOL_SEP): data[\"symbol\"] for data in r.json()}\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BLOCKCHAIN', why, {\"\": r})\n\n\n<DED><DED>def gateio_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get(\"https://api.gateio.ws/api/v4/spot/currency_pairs\")\n        return {data[\"id\"].replace(\"_\", SYMBOL_SEP): data['id'] for data in r.json()}\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('GATEIO', why, {\"\": r})\n\n\n<DED><DED>def bitmex_symbols() -> Dict[str, str]:\n    <IND>r = None\n    ret = {}\n    try:\n        <IND>r = requests.get(\"https://www.bitmex.com/api/v1/instrument/active\")\n        for entry in r.json():\n            <IND>components = []\n            components.append(entry['rootSymbol'])\n            components.append(entry['quoteCurrency'])\n\n            if entry['expiry']:\n                <IND>components.append(entry['symbol'][-3:])\n\n            <DED>normalized = SYMBOL_SEP.join(components)\n            normalized = normalized.replace(\"XBT\", \"BTC\")\n            ret[normalized] = entry['symbol']\n            _exchange_info[BITMEX]['tick_size'][normalized] = entry['tickSize']\n\n            if entry['expiry']:\n                <IND>_exchange_info[BITMEX]['expiry'][normalized] = entry['expiry']\n\n        <DED><DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BITMEX', why, {\"\": r})\n\n\n<DED><DED>def deribit_symbols() -> Dict[str, str]:\n    <IND>url = r = None\n    ret = {}\n    try:\n        # TODO: get currencies from https://www.deribit.com/api/v2/public/get_currencies\n        <IND>currencies = ['BTC', 'ETH']\n        for c in currencies:\n            <IND>url = f\"https://www.deribit.com/api/v2/public/get_instruments?currency={c}&expired=false\"\n            r = requests.get(url)\n            for entry in r.json()['result']:\n                <IND>split = entry['instrument_name'].split(\"-\")\n                normalized = split[0] + SYMBOL_SEP + entry['quote_currency'] + \"-\" + '-'.join(split[1:])\n                ret[normalized] = entry['instrument_name']\n                _exchange_info[DERIBIT]['tick_size'][normalized] = entry['tick_size']\n        <DED><DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('DERIBIT', why, {url: r})\n\n\n<DED><DED>def kraken_future_symbols() -> Dict[str, str]:\n    <IND>r = None\n    ret = {}\n    try:\n        <IND>r = requests.get('https://futures.kraken.com/derivatives/api/v3/instruments')\n        data = r.json()['instruments']\n        for entry in data:\n            <IND>if not entry['tradeable']:\n                <IND>continue\n            <DED>normalized = entry['symbol'].upper().replace(\"_\", \"-\")\n            symbol = normalized[3:6] + SYMBOL_SEP + normalized[6:9]\n            normalized = normalized.replace(normalized[3:9], symbol)\n            normalized = normalized.replace('XBT', 'BTC')\n\n            _exchange_info[KRAKEN_FUTURES]['tick_size'][normalized] = entry['tickSize']\n            _exchange_info[KRAKEN_FUTURES]['contract_size'][normalized] = entry['contractSize']\n            _exchange_info[KRAKEN_FUTURES]['underlying'][normalized] = entry['underlying']\n            _exchange_info[KRAKEN_FUTURES]['product_type'][normalized] = _kraken_futures_product_type[normalized[:2]]\n            ret[normalized] = entry['symbol']\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('KRAKEN_FUTURES', why, {\"\": r})\n\n\n<DED><DED>def probit_symbols() -> Dict[str, str]:\n    # doc: https://docs-en.probit.com/reference-link/market\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.probit.com/api/exchange/v1/market')\n        return {entry['id']: entry['id'] for entry in r.json()['data']}\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('PROBIT', why, {\"\": r})\n\n\n<DED><DED>def coingecko_normalize_symbol(symbol: str) -> str:\n    # keep digits, letters and dots, replace others by space\n    <IND>symbol = ''.join(c if c.isalnum() or c in ('.', '+') else ' ' for c in symbol)\n    return coingecko_normalize(symbol.upper())\n\n\n<DED>def coingecko_normalize_name(name: str) -> str:\n    # keep digits and letters, replace others by space (except when only composed by upper case letters, digits and dots)\n    <IND>if not all(c.isupper() or c.isdigit() or c == '.' for c in name):\n        <IND>name = ''.join(c if c.isalnum() else ' ' for c in name)\n    <DED>return coingecko_normalize(name)\n\n\n<DED>def coingecko_normalize(sym: str) -> str:\n    <IND>sym = sym.strip()\n    # do not concatenate numbers => separate them with a dot\n    sym = list(sym)\n    if len(sym) > 4:\n        <IND>for i in range(2, len(sym) - 1):\n            <IND>if sym[i] == ' ' and sym[i - 1].isdigit() and sym[i + 1].isdigit():\n                <IND>sym[i] = '.'\n    <DED><DED><DED>sym = ''.join(sym)\n    # concatenate space-separated words => use CamelCase to distinguish the words\n    if ' ' in sym:\n        <IND>if sum(c.islower() for c in sym):  # if there is at least one lower case letter\n            <IND>sym = ' '.join(word[0].upper() + word[1:] for word in sym.split())  # Just capitalize initial letter of each word\n        <DED>else:  # CoinGecko may provide full upper-case as for \"THE STONE COIN\"\n            <IND>sym = string.capwords(sym)  # capwords converts \"THE STONE COIN\" to \"The Stone Coin\"\n        <DED>sym = sym.replace(' ', '')  # concatenate words\n    <DED>return sym\n\n\n<DED>def is_name_short(coin: dict) -> bool:\n    <IND>\"\"\"return True if the coin name is enough short compared to the coin symbol.\"\"\"\n    return len(coin['name']) <= max(5, len(coin['symbol']) + 1)\n\n\n<DED>def has_many_caps(name: str) -> bool:\n    <IND>\"\"\"return True if the symbol contains enough upper case letters, False if empty.\"\"\"\n    return str and sum(c.islower() for c in name) < (len(name) / 2)\n\n\n<DED>def coingecko_normalize_all(coin: dict):\n    <IND>SYMBOL_TO_NORMALIZED = {'miota': 'IOTA'}\n    normalized = SYMBOL_TO_NORMALIZED.get(coin['symbol'])\n    if normalized:\n        <IND>coin['ns'] = coin['nn'] = normalized\n        return normalized\n\n    # ns = normalized symbol, nn = normalized name\n    <DED>coin['ns'] = coingecko_normalize_symbol(coin['symbol'])\n\n    ID_SUFFIX = '-bitcoin-token'\n    if coin['id'][-len(ID_SUFFIX):] == ID_SUFFIX:\n        <IND>coin['nn'] = 'BTC' + coin['ns']\n        return coin['nn']\n\n    <DED>name = coin['name']\n\n    prefixes = ('The ', 'the ')\n    for p in prefixes:\n        <IND>if name[:len(p)] == p:\n            <IND>coin['reduced-name'] = True\n            name = name[len(p):]\n            break\n\n    <DED><DED>suffixes = ('coin', 'coins', 'money', 'finance', 'protocol', 'reward', 'rewards', 'token')\n    for s in suffixes:\n        <IND>if len(name) > len(s) and name[-len(s):].lower() == s:\n            # but keep suffix when lower-case concatenated\n            <IND>if name[-len(s)].islower() and name[-len(s) - 1] != ' ':\n                <IND>continue\n            # also keep suffix to avoid confusing nam: \"Bitcoin Token\" -> \"Bitcoin\"\n            <DED>if name[:-len(s)].strip().lower() == 'bitcoin':\n                <IND>continue\n            <DED>coin['reduced-name'] = True\n            name = name[:-len(s)]\n            break\n\n    <DED><DED>coin['nn'] = coingecko_normalize_name(name)\n\n    if len(coin['nn']) < len(coin['ns']):\n        <IND>if 'reduced-name' in coin:\n            <IND>coin['reduced-name'] = False\n            name = coin['name']\n            coin['nn'] = coingecko_normalize_name(name)\n        <DED>elif not has_many_caps(name):\n            <IND>return coin['ns']\n\n    <DED><DED>if not coin['ns']:  # coin['symbol'] may be an emoji that is striped when normalized\n        <IND>return coin['nn']\n\n    <DED>if coin.get('reduced-name') and coin['ns'].upper() != coin['nn'].upper():\n        <IND>return coin['ns']\n\n    <DED>i = coin['nn'].find('.')  # if there is a dot in normalized name => prefer the normalized symbol\n    if i >= 0:\n        <IND>if i > 1 and coin['nn'][i - 1].isdigit() and coin['nn'][i + 1].isdigit():\n            <IND>pass  # except when the dot separates digits\n        <DED>else:\n            <IND>return coin['ns']\n\n    <DED><DED>if is_name_short(coin) and has_many_caps(name):\n        <IND>return coin['nn']\n\n    <DED>if 1.5 * len(coin['ns']) > len(coin['nn']) and any(c.islower() for c in coin['ns']):\n        <IND>return coin['nn']\n\n    <DED>return coin['ns']\n\n\n<DED>def coingecko_symbols() -> Dict[str, str]:\n    <IND>r = None\n    intermediate = defaultdict(list)\n    try:\n        <IND>r = requests.get('https://api.coingecko.com/api/v3/coins/list')\n        all_coins = r.json()\n        # First pass: generate & compare normalized symbol/name, and then select the most pertinent\n        for coin in all_coins:\n            <IND>normalized = coingecko_normalize_all(coin)\n            intermediate[normalized].append(coin)\n            # Above line keeps together the coins having the same normalized symbol.\n            # To reduce collision, the coin['name'] is sometimes used in lieu of the coin['symbol'].\n            # The coin['name'] is not capitalized because lower case letters may be meaningful: cETH, yUSD, DATx, zLOT\n    <DED><DED>except Exception as why:\n        <IND>raise_failure_explanation('COINGECKO', why, {\"\": r})\n\n    <DED>final = coingecko_second_pass(intermediate)\n    return coingecko_third_pass(final)\n\n\n<DED>def coingecko_second_pass(intermediate: Dict[str, List[dict]]) -> Dict[str, List[dict]]:\n    # Second pass: fixes most of the symbol collisions\n    <IND>final = defaultdict(list)\n    for normalized, coins in intermediate.items():\n        <IND>if len(coins) == 1:\n            <IND>final[normalized].append(coins[0])\n            continue\n        <DED>set_normalized = False\n        for i in range(len(coins)):\n            <IND>if normalized == coins[i]['nn']:\n                <IND>coin = coins.pop(i)\n                final[normalized].append(coin)\n                set_normalized = True\n                break\n        <DED><DED>rest: List[dict] = []\n        for coin in coins:\n            <IND>if '%' in coin['name']:\n                <IND>if len(coins) == 1:\n                    <IND>n = coin['ns']\n                <DED>else:\n                    <IND>n = coingecko_normalize_name(coin['id'])\n                <DED>final[n].append(coin)\n            <DED>else:\n                <IND>rest.append(coin)\n        <DED><DED>if not rest:\n            <IND>continue\n        <DED>if not set_normalized:\n            <IND>rest.sort(key=lambda coin: len(coin['nn']), reverse=True)  # sort by the length of the normalized name\n            coin = rest.pop(0)\n            final[normalized].append(coin)\n        <DED>for coin in rest:\n            <IND>if coin['nn'] not in intermediate:\n                <IND>n = coin['nn']\n            <DED>elif coin.get('reduced-name'):\n                <IND>n = coingecko_normalize_name(coin['name'])\n            <DED>else:\n                <IND>n = coingecko_normalize_name(coin['id'])\n            <DED>final[n].append(coin)\n    <DED><DED>return final\n\n\n<DED>def coingecko_third_pass(final: Dict[str, List[dict]]) -> Dict[str, str]:\n    # Third pass: fixes some remaining collisions and fills the result\n    <IND>symbols = {}\n    for normalized, coins in final.items():\n        <IND>if len(coins) == 1:\n            <IND>symbols[normalized] = coins[0]['id']\n            continue\n        <DED>set_normalized = False\n        for i in range(len(coins)):\n            <IND>if normalized == coins[i]['nn']:\n                <IND>coin = coins.pop(i)\n                symbols[normalized] = coin['id']\n                set_normalized = True\n                break\n        <DED><DED>rest: List[dict] = []\n        for coin in coins:\n            <IND>if '%' in coin['name']:\n                <IND>if len(coins) == 1:\n                    <IND>n = coin['ns']\n                <DED>else:\n                    <IND>n = coingecko_normalize_name(coin['id'])\n                <DED>symbols[n] = coin['id']\n            <DED>else:\n                <IND>rest.append(coin)\n        <DED><DED>if not rest:\n            <IND>continue\n        <DED>if not set_normalized:\n            <IND>rest.sort(key=lambda coin: len(coin['nn']), reverse=True)  # sort by the length of the normalized name\n            coin = rest.pop(0)\n            symbols[normalized] = coin['id']\n        <DED>for coin in rest:\n            <IND>if coin['nn'] not in final:\n                <IND>n = coin['nn']\n            <DED>elif coin.get('reduced-name'):\n                <IND>n = coingecko_normalize_name(coin['name'])\n            <DED>else:\n                <IND>n = coingecko_normalize_name(coin['id'])\n            <DED>symbols[n] = coin['id']\n    <DED><DED>return symbols\n\n\n<DED>def whale_alert_coins(key_id: str) -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get(f'https://api.whale-alert.io/v1/status?api_key={key_id}')\n        # Same symbols, but on different blockchains (for instance USDT), are naturally overwritten.\n        return {s.upper(): s for b in r.json()['blockchains'] for s in b['symbols'] if s}\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('WHALES_ALERT', why, {\"\": r})\n\n\n<DED><DED>_exchange_function_map = {\n    BITFINEX: bitfinex_symbols,\n    BITFLYER: bitflyer_symbols,\n    COINBASE: coinbase_symbols,\n    GEMINI: gemini_symbols,\n    HITBTC: hitbtc_symbols,\n    POLONIEX: poloniex_symbols,\n    PROBIT: probit_symbols,\n    BITSTAMP: bitstamp_symbols,\n    KRAKEN: kraken_symbols,\n    KRAKEN + 'REST': kraken_rest_symbols,\n    BINANCE: binance_symbols,\n    BINANCE_US: binance_us_symbols,\n    BINANCE_FUTURES: binance_futures_symbols,\n    BINANCE_DELIVERY: binance_delivery_symbols,\n    BLOCKCHAIN: blockchain_symbols,\n    EXX: exx_symbols,\n    HUOBI: huobi_symbols,\n    HUOBI_DM: huobi_dm_symbols,\n    HUOBI_SWAP: huobi_swap_symbols,\n    OKCOIN: okcoin_symbols,\n    OKEX: okex_symbols,\n    BYBIT: bybit_symbols,\n    FTX: ftx_symbols,\n    FTX_US: ftx_us_symbols,\n    BITTREX: bittrex_symbols,\n    BITCOINCOM: bitcoincom_symbols,\n    BITMAX: bitmax_symbols,\n    UPBIT: upbit_symbols,\n    GATEIO: gateio_symbols,\n    BITMEX: bitmex_symbols,\n    DERIBIT: deribit_symbols,\n    KRAKEN_FUTURES: kraken_future_symbols,\n    COINGECKO: coingecko_symbols,\n    WHALE_ALERT: whale_alert_coins\n}\n",
        "target_code_with_indent": "\nfrom typing import Dict, Tuple\n\n\nclass _Symbols:\n    <IND>def __init__(self):\n        <IND>self.data = {}\n\n    <DED>def set(self, exchange: str, normalized: dict, exchange_info: dict):\n        <IND>self.data[exchange] = {}\n        self.data[exchange]['normalized'] = normalized\n        self.data[exchange]['info'] = exchange_info\n\n    <DED>def get(self, exchange: str) -> Tuple[Dict, Dict]:\n        <IND>return self.data[exchange]['normalized'], self.data[exchange]['info']\n\n    <DED>def populated(self, exchange: str) -> bool:\n        <IND>return exchange in self.data\n\n\n<DED><DED>Symbols = _Symbols()\n"
      }
    ]
  },
  {
    "project": "bmoscon/cryptofeed",
    "commit": "3525dc8ce4d7836a9abaaa5662e58e5e27969a77",
    "filename": "cryptofeed/symbols.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/bmoscon-cryptofeed/cryptofeed/symbols.py",
    "file_hunks_size": 1,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "cryptofeed/symbols.py:447:8 Incompatible return type [7]: Expected `Dict[str, str]` but got implicit return value of `None`.",
    "message": " Expected `Dict[str, str]` but got implicit return value of `None`.",
    "rule_id": "Incompatible return type [7]",
    "warning_line_no": 447,
    "warning_line": "        raise_failure_explanation('OKEX', why, {url: r})",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "associated with this software.\n\n\nSymbol generation code for exchanges\n'''\n\nimport logging\nimport string\nimport time\nfrom collections import defaultdict\nfrom typing import Dict, List, Optional, Tuple\n\nimport requests\nfrom requests import Response\n\nfrom cryptofeed.defines import *\n\n\nLOG = logging.getLogger('feedhandler')\n\nSYMBOL_SEP = '-'\n\n_symbols_retrieval_cache: Dict[str, Dict[str, str]] = {}\n_exchange_info = defaultdict(lambda: defaultdict(dict))\n\n\n_kraken_futures_product_type = {\n    'FI': 'Inverse Futures',\n    'FV': 'Vanilla Futures',\n    'PI': 'Perpetual Inverse Futures',\n    'PV': 'Perpetual Vanilla Futures',\n    'IN': 'Real Time Index',\n    'RR': 'Reference Rate',\n}\n\n\ndef raise_failure_explanation(feed_id: str, exception: BaseException, responses: Dict[str, Optional[Response]]):\n    LOG.critical('%s: encountered %r while processing response from exchange API', feed_id, exception)\n    if len(responses) > 1:\n        LOG.critical('%s: content of one of the %s responses was unexpected', feed_id, len(responses))\n    for url, r in responses.items():\n        if url:\n            LOG.critical('%s: requested URL: %s', feed_id, url)\n        if r:\n            LOG.critical('%s: unexpected response: %s', feed_id, r.text)\n    raise ValueError(f'Cryptofeed stopped because of an unexpected response from {feed_id}') from exception\n\n\ndef set_symbol_separator(separator: str):\n    global SYMBOL_SEP\n    SYMBOL_SEP = separator\n\n\ndef get_symbol_separator() -> str:\n    global SYMBOL_SEP\n    return SYMBOL_SEP\n\n\ndef gen_symbols(exchange: str, key_id=None) -> Dict[str, str]:\n    if exchange not in _symbols_retrieval_cache:\n        LOG.info(\"%s: Getting list of symbols\", exchange)\n        symbols = _exchange_function_map[exchange](key_id) if key_id else _exchange_function_map[exchange]()\n        LOG.info(\"%s: %s symbols\", exchange, len(symbols))\n\n        # log all retrieved symbols using debug level\n        for normalized, exch_sym in sorted(symbols.items()):\n            LOG.debug('%s: id-from-exch -> normalized: %-35s-> %s', exchange, exch_sym, normalized)\n\n        _symbols_retrieval_cache[exchange] = symbols\n    return _symbols_retrieval_cache[exchange]\n\n\ndef _binance_symbols(endpoint: str, exchange: str):\n    r = None\n    try:\n        ret = {}\n        r = requests.get(endpoint)\n        for symbol in r.json()['symbols']:\n            if symbol.get('status', 'TRADING') != \"TRADING\":\n                continue\n            if symbol.get('contractStatus', 'TRADING') != \"TRADING\":\n                continue\n            split = len(symbol['baseAsset'])\n            normalized = symbol['symbol'][:split] + SYMBOL_SEP + symbol['symbol'][split:]\n            ret[normalized] = symbol['symbol']\n            _exchange_info[exchange]['tick_size'][normalized] = symbol['filters'][0]['tickSize']\n            if \"contractType\" in symbol:\n                _exchange_info[exchange]['contract_type'][normalized] = symbol['contractType']\n        return ret\n    except Exception as why:\n        raise_failure_explanation(exchange, why, {endpoint: r})\n\n\ndef binance_symbols() -> Dict[str, str]:\n    return _binance_symbols('https://api.binance.com/api/v3/exchangeInfo', BINANCE)\n\n\ndef binance_us_symbols() -> Dict[str, str]:\n    return _binance_symbols('https://api.binance.us/api/v3/exchangeInfo', BINANCE_US)\n\n\ndef binance_futures_symbols() -> Dict[str, str]:\n    base = _binance_symbols('https://fapi.binance.com/fapi/v1/exchangeInfo', BINANCE_FUTURES)\n    add = {}\n    for symbol, orig in base.items():\n        if \"_\" in orig:\n            continue\n        add[f\"{symbol}-PINDEX\"] = f\"p{orig}\"\n    base.update(add)\n    return base\n\n\ndef binance_delivery_symbols() -> Dict[str, str]:\n    return _binance_symbols('https://dapi.binance.com/dapi/v1/exchangeInfo', BINANCE_DELIVERY)\n\n\ndef bitfinex_symbols() -> Dict[str, str]:\n    # doc: https://docs.bitfinex.com/docs/ws-general#supported-pairs\n    r1 = r2 = None\n    try:\n        r1 = requests.get('https://api.bitfinex.com/v2/tickers?symbols=ALL')\n        r2 = requests.get('https://api-pub.bitfinex.com/v2/conf/pub:map:currency:sym')\n        tickers: List[List[str]] = r1.json()\n        norm: List[Tuple[str, str]] = r2.json()[0]\n        norm: Dict[str, str] = dict(norm)\n        for k, v in dict(norm).items():\n            if k[-2:] == 'F0' or '-' in v:  # Do not convert BTCF0 -> BTC or PBTCETH -> PBTC-ETH\n                del norm[k]\n        norm['BCHN'] = 'BCH'  # Bitfinex uses BCHN, other exchanges use BCH\n\n        ret = {}\n        for symbol in [t[0] for t in tickers]:\n            if symbol[0] == 'f':\n                normalized = norm.get(symbol[1:], symbol[1:])\n            else:\n                if len(symbol) == 7:\n                    base, quote = symbol[1:4], symbol[4:]\n                else:\n                    base, quote = symbol[1:].split(':')\n                    assert ':' in symbol\n                normalized = norm.get(base, base) + SYMBOL_SEP + norm.get(quote, quote)\n            ret[normalized.upper()] = symbol\n        return ret\n    except ValueError as why:\n        raise_failure_explanation('BITFINEX', why, {\"tickers?symbols=ALL\": r1, \"pub:map:currency:sym\": r2})\n\n\ndef bitflyer_symbols() -> Dict[str, str]:\n    endpoint = r = None\n    try:\n        ret = {}\n        endpoints = ['https://api.bitflyer.com/v1/getmarkets/eu', 'https://api.bitflyer.com/v1/getmarkets/usa', 'https://api.bitflyer.com/v1/getmarkets']\n        for endpoint in endpoints:\n            r = requests.get(endpoint)\n            for entry in r.json():\n                normalized = entry['product_code'].replace(\"_\", SYMBOL_SEP)\n                ret[normalized] = entry['product_code']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('BITFLYER', why, {endpoint: r})\n\n\ndef bybit_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.bybit.com/v2/public/symbols')\n        ret = {}\n        for symbol in r.json()['result']:\n            quote = symbol['quote_currency']\n            if not symbol['name'].endswith(quote):\n                base, contract = symbol['name'].split(quote)\n                normalized = f\"{base}{SYMBOL_SEP}{quote}-{contract}\"\n            else:\n                normalized = f\"{symbol['base_currency']}{SYMBOL_SEP}{quote}\"\n            ret[normalized] = symbol['name']\n            _exchange_info[BYBIT]['tick_size'][normalized] = symbol['price_filter']['tick_size']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('BYBIT', why, {\"\": r})\n\n\ndef _ftx_helper(endpoint: str, exchange: str):\n    r = None\n    try:\n        r = requests.get(endpoint)\n        ret = {}\n        for data in r.json()['result']:\n            normalized = data['name'].replace(\"/\", SYMBOL_SEP)\n            symbol = data['name']\n            ret[normalized] = symbol\n            _exchange_info[exchange]['tick_size'][normalized] = data['priceIncrement']\n        return ret\n    except Exception as why:\n        raise_failure_explanation(exchange, why, {endpoint: r})\n\n\ndef ftx_symbols() -> Dict[str, str]:\n    return _ftx_helper('https://ftx.com/api/markets', FTX)\n\n\ndef ftx_us_symbols() -> Dict[str, str]:\n    return _ftx_helper('https://ftx.us/api/markets', FTX_US)\n\n\ndef coinbase_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.pro.coinbase.com/products')\n        ret = {}\n        for data in r.json():\n            normalized = data['id'].replace(\"-\", SYMBOL_SEP)\n            ret[normalized] = data['id']\n            _exchange_info[COINBASE]['tick_size'][normalized] = data['quote_increment']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('COINBASE', why, {\"\": r})\n\n\ndef gemini_symbols(*args) -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.gemini.com/v1/symbols')\n        ret = {}\n        for symbol in r.json():\n            std = f\"{symbol[:-3]}{SYMBOL_SEP}{symbol[-3:]}\"\n            std = std.upper()\n            ret[std] = symbol.upper()\n        return ret\n    except Exception as why:\n        raise_failure_explanation('GEMINI', why, {\"\": r})\n\n\ndef hitbtc_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        ret = {}\n        r = requests.get('https://api.hitbtc.com/api/2/public/symbol')\n        for symbol in r.json():\n            split = len(symbol['baseCurrency'])\n            normalized = symbol['id'][:split] + SYMBOL_SEP + symbol['id'][split:]\n            ret[normalized] = symbol['id']\n            _exchange_info[HITBTC]['tick_size'][normalized] = symbol['tickSize']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('HITBTC', why, {\"\": r})\n\n\ndef poloniex_id_symbol_mapping():\n    r = None\n    try:\n        r = requests.get('https://poloniex.com/public?command=returnTicker')\n        symbols = r.json()\n        ret = {}\n        for symbol in symbols:\n            ret[symbols[symbol]['id']] = symbol\n        return ret\n    except Exception as why:\n        raise_failure_explanation('POLONIEX', why, {\"\": r})\n\n\ndef poloniex_symbols() -> Dict[str, str]:\n    ret = {}\n    for _, value in poloniex_id_symbol_mapping().items():\n        std = value.replace(\"STR\", \"XLM\")\n        quote, base = std.split(\"_\")\n        ret[quote + SYMBOL_SEP + base] = value\n    return ret\n\n\ndef bitstamp_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://www.bitstamp.net/api/v2/trading-pairs-info/')\n        ret = {}\n        for data in r.json():\n            normalized = data['name'].replace(\"/\", SYMBOL_SEP)\n            symbol = data['url_symbol']\n            ret[normalized] = symbol\n        return ret\n    except Exception as why:\n        raise_failure_explanation('BITSTAMP', why, {\"\": r})\n\n\ndef kraken_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.kraken.com/0/public/AssetPairs')\n        data = r.json()\n        ret = {}\n        for symbol in data['result']:\n            if 'wsname' not in data['result'][symbol] or '.d' in symbol:\n                # https://blog.kraken.com/post/259/introducing-the-kraken-dark-pool/\n                # .d is for dark pool symbols\n                continue\n\n            base, quote = data['result'][symbol]['wsname'].split(\"/\")\n\n            normalized = f\"{base}{SYMBOL_SEP}{quote}\"\n            exch = data['result'][symbol]['wsname']\n            normalized = normalized.replace('XBT', 'BTC')\n            normalized = normalized.replace('XDG', 'DOG')\n            ret[normalized] = exch\n        return ret\n    except Exception as why:\n        raise_failure_explanation('KRAKEN', why, {\"\": r})\n\n\ndef kraken_rest_symbols() -> Dict[str, str]:\n    return {normalized: exchange.replace(\"/\", \"\") for normalized, exchange in kraken_symbols().items()}\n\n\ndef exx_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.exx.com/data/v1/tickers')\n        exchange = [key.upper() for key in r.json().keys()]\n        symbols = [key.replace(\"_\", SYMBOL_SEP) for key in exchange]\n        return dict(zip(symbols, exchange))\n    except Exception as why:\n        raise_failure_explanation('EXX', why, {\"\": r})\n\n\ndef huobi_common_symbols(url: str):\n    r = None\n    try:\n        r = requests.get(url)\n        ret = {}\n        for e in r.json()['data']:\n            if e['state'] == 'offline':\n                continue\n            normalized = f\"{e['base-currency'].upper()}{SYMBOL_SEP}{e['quote-currency'].upper()}\"\n            symbol = f\"{e['base-currency']}{e['quote-currency']}\"\n            ret[normalized] = symbol\n        return ret\n    except Exception as why:\n        raise_failure_explanation('HUOBI', why, {url: r})\n\n\ndef huobi_symbols() -> Dict[str, str]:\n    return huobi_common_symbols('https://api.huobi.pro/v1/common/symbols')\n\n\ndef huobi_us_symbols() -> Dict[str, str]:\n    return huobi_common_symbols('https://api.huobi.com/v1/common/symbols')\n\n\ndef huobi_dm_symbols() -> Dict[str, str]:\n    \"\"\"\n    Mapping is, for instance: {\"BTC_CW\":\"BTC190816\"}\n    See comments in exchange/huobi_dm.py\n    \"\"\"\n    mapping = {\n        \"this_week\": \"CW\",\n        \"next_week\": \"NW\",\n        \"quarter\": \"CQ\",\n        \"next_quarter\": \"NQ\"\n    }\n    r = None\n    try:\n        r = requests.get('https://www.hbdm.com/api/v1/contract_contract_info')\n        symbols = {}\n        for e in r.json()['data']:\n            symbols[f\"{e['symbol']}_{mapping[e['contract_type']]}\"] = e['contract_code']\n            _exchange_info[HUOBI_DM]['tick_size'][e['contract_code']] = e['price_tick']\n            _exchange_info[HUOBI_DM]['short_code_mappings'][f\"{e['symbol']}_{mapping[e['contract_type']]}\"] = e['contract_code']\n        return symbols\n    except Exception as why:\n        raise_failure_explanation('HUOBI_DM', why, {\"\": r})\n\n\ndef huobi_swap_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.hbdm.com/swap-api/v1/swap_contract_info')\n        symbols = {}\n        for e in r.json()['data']:\n            symbols[e['contract_code']] = e['contract_code']\n            _exchange_info[HUOBI_SWAP]['tick_size'][e['contract_code']] = e['price_tick']\n        return symbols\n    except Exception as why:\n        raise_failure_explanation('HUOBI_SWAP', why, {\"\": r})\n\n\ndef okcoin_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://www.okcoin.com/api/spot/v3/instruments')\n        ret = {}\n        for e in r.json():\n            ret[e['instrument_id']] = e['instrument_id']\n            _exchange_info[OKCOIN]['tick_size'][e['instrument_id']] = e['tick_size']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('OKCOIN', why, {\"\": r})\n\n\ndef okex_symbols(*args) -> Dict[str, str]:\n    urls = ['https://www.okex.com/api/spot/v3/instruments',\n            'https://www.okex.com/api/swap/v3/instruments',\n            'https://www.okex.com/api/futures/v3/instruments']\n    urls = urls + okex_compute_option_urls_from_underlyings()\n\n    symbols: Dict[str, str] = {}\n    for u in urls:\n        time.sleep(0.2)\n        symbols.update(okex_symbols_from_one_url(u))\n\n    for symbol in symbols:\n        instrument_type = 'futures'\n        dash_count = symbol.count(get_symbol_separator())\n        if dash_count == 1:  # BTC-USDT\n            instrument_type = 'spot'\n        if dash_count == 4:  # BTC-USD-201225-35000-P\n            instrument_type = 'option'\n        if symbol[-4:] == \"SWAP\":  # BTC-USDT-SWAP\n            instrument_type = 'swap'\n\n        _exchange_info[OKEX]['instrument_type'][symbol] = instrument_type\n\n    return symbols\n\n\ndef okex_compute_option_urls_from_underlyings() -> List[str]:\n    url = 'https://www.okex.com/api/option/v3/underlying'\n    r = None\n    try:\n        r = requests.get(url)\n        return [f'https://www.okex.com/api/option/v3/instruments/{underlying}' for underlying in r.json()]\n    except Exception as why:\n        raise_failure_explanation('OKEX', why, {url: r})\n\n\ndef okex_symbols_from_one_url(url: str) -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get(url)\n        ret = {}\n        for e in r.json():\n            ret[e['instrument_id']] = e['instrument_id']\n            _exchange_info[OKEX]['tick_size'][e['instrument_id']] = e['tick_size']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('OKEX', why, {url: r})\n\n\ndef bittrex_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.bittrex.com/api/v1.1/public/getmarkets')\n        r = r.json()['result']\n        return {f\"{e['MarketCurrency']}{SYMBOL_SEP}{e['BaseCurrency']}\": e['MarketName'] for e in r if e['IsActive']}\n    except Exception as why:\n        raise_failure_explanation('BITTREX', why, {\"\": r})\n\n\ndef bitcoincom_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.exchange.bitcoin.com/api/2/public/symbol')\n        return {f\"{data['baseCurrency']}{SYMBOL_SEP}{data['quoteCurrency'].replace('USD', 'USDT')}\": data['id'] for data in r.json()}\n    except Exception as why:\n        raise_failure_explanation('BITCOINCOM', why, {\"\": r})\n\n\ndef bitmax_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://bitmax.io/api/pro/v1/products')\n        ret = {}\n        for entry in r.json()['data']:\n            # Only \"Normal\" status symbols are tradeable\n            if entry['status'] == 'Normal':\n                normalized = f\"{entry['baseAsset']}{SYMBOL_SEP}{entry['quoteAsset']}\"\n                ret[normalized] = entry['symbol']\n                _exchange_info[BITMAX]['tick_size'][normalized] = entry['tickSize']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('BITMAX', why, {\"\": r})\n\n\ndef upbit_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.upbit.com/v1/market/all')\n        return {f\"{data['market'].split('-')[1]}{SYMBOL_SEP}{data['market'].split('-')[0]}\": data['market'] for data in r.json()}\n    except Exception as why:\n        raise_failure_explanation('UPBIT', why, {\"\": r})\n\n\ndef blockchain_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get(\"https://api.blockchain.com/mercury-gateway/v1/instruments\")\n        return {data[\"symbol\"].replace(\"-\", SYMBOL_SEP): data[\"symbol\"] for data in r.json()}\n    except Exception as why:\n        raise_failure_explanation('BLOCKCHAIN', why, {\"\": r})\n\n\ndef gateio_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get(\"https://api.gateio.ws/api/v4/spot/currency_pairs\")\n        return {data[\"id\"].replace(\"_\", SYMBOL_SEP): data['id'] for data in r.json()}\n    except Exception as why:\n        raise_failure_explanation('GATEIO', why, {\"\": r})\n\n\ndef bitmex_symbols() -> Dict[str, str]:\n    r = None\n    ret = {}\n    try:\n        r = requests.get(\"https://www.bitmex.com/api/v1/instrument/active\")\n        for entry in r.json():\n            components = []\n            components.append(entry['rootSymbol'])\n            components.append(entry['quoteCurrency'])\n\n            if entry['expiry']:\n                components.append(entry['symbol'][-3:])\n\n            normalized = SYMBOL_SEP.join(components)\n            normalized = normalized.replace(\"XBT\", \"BTC\")\n            ret[normalized] = entry['symbol']\n            _exchange_info[BITMEX]['tick_size'][normalized] = entry['tickSize']\n\n            if entry['expiry']:\n                _exchange_info[BITMEX]['expiry'][normalized] = entry['expiry']\n\n        return ret\n    except Exception as why:\n        raise_failure_explanation('BITMEX', why, {\"\": r})\n\n\ndef deribit_symbols() -> Dict[str, str]:\n    url = r = None\n    ret = {}\n    try:\n        # TODO: get currencies from https://www.deribit.com/api/v2/public/get_currencies\n        currencies = ['BTC', 'ETH']\n        for c in currencies:\n            url = f\"https://www.deribit.com/api/v2/public/get_instruments?currency={c}&expired=false\"\n            r = requests.get(url)\n            for entry in r.json()['result']:\n                split = entry['instrument_name'].split(\"-\")\n                normalized = split[0] + SYMBOL_SEP + entry['quote_currency'] + \"-\" + '-'.join(split[1:])\n                ret[normalized] = entry['instrument_name']\n                _exchange_info[DERIBIT]['tick_size'][normalized] = entry['tick_size']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('DERIBIT', why, {url: r})\n\n\ndef kraken_future_symbols() -> Dict[str, str]:\n    r = None\n    ret = {}\n    try:\n        r = requests.get('https://futures.kraken.com/derivatives/api/v3/instruments')\n        data = r.json()['instruments']\n        for entry in data:\n            if not entry['tradeable']:\n                continue\n            normalized = entry['symbol'].upper().replace(\"_\", \"-\")\n            symbol = normalized[3:6] + SYMBOL_SEP + normalized[6:9]\n            normalized = normalized.replace(normalized[3:9], symbol)\n            normalized = normalized.replace('XBT', 'BTC')\n\n            _exchange_info[KRAKEN_FUTURES]['tick_size'][normalized] = entry['tickSize']\n            _exchange_info[KRAKEN_FUTURES]['contract_size'][normalized] = entry['contractSize']\n            _exchange_info[KRAKEN_FUTURES]['underlying'][normalized] = entry['underlying']\n            _exchange_info[KRAKEN_FUTURES]['product_type'][normalized] = _kraken_futures_product_type[normalized[:2]]\n            ret[normalized] = entry['symbol']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('KRAKEN_FUTURES', why, {\"\": r})\n\n\ndef probit_symbols() -> Dict[str, str]:\n    # doc: https://docs-en.probit.com/reference-link/market\n    r = None\n    try:\n        r = requests.get('https://api.probit.com/api/exchange/v1/market')\n        return {entry['id']: entry['id'] for entry in r.json()['data']}\n    except Exception as why:\n        raise_failure_explanation('PROBIT', why, {\"\": r})\n\n\ndef coingecko_normalize_symbol(symbol: str) -> str:\n    # keep digits, letters and dots, replace others by space\n    symbol = ''.join(c if c.isalnum() or c in ('.', '+') else ' ' for c in symbol)\n    return coingecko_normalize(symbol.upper())\n\n\ndef coingecko_normalize_name(name: str) -> str:\n    # keep digits and letters, replace others by space (except when only composed by upper case letters, digits and dots)\n    if not all(c.isupper() or c.isdigit() or c == '.' for c in name):\n        name = ''.join(c if c.isalnum() else ' ' for c in name)\n    return coingecko_normalize(name)\n\n\ndef coingecko_normalize(sym: str) -> str:\n    sym = sym.strip()\n    # do not concatenate numbers => separate them with a dot\n    sym = list(sym)\n    if len(sym) > 4:\n        for i in range(2, len(sym) - 1):\n            if sym[i] == ' ' and sym[i - 1].isdigit() and sym[i + 1].isdigit():\n                sym[i] = '.'\n    sym = ''.join(sym)\n    # concatenate space-separated words => use CamelCase to distinguish the words\n    if ' ' in sym:\n        if sum(c.islower() for c in sym):  # if there is at least one lower case letter\n            sym = ' '.join(word[0].upper() + word[1:] for word in sym.split())  # Just capitalize initial letter of each word\n        else:  # CoinGecko may provide full upper-case as for \"THE STONE COIN\"\n            sym = string.capwords(sym)  # capwords converts \"THE STONE COIN\" to \"The Stone Coin\"\n        sym = sym.replace(' ', '')  # concatenate words\n    return sym\n\n\ndef is_name_short(coin: dict) -> bool:\n    \"\"\"return True if the coin name is enough short compared to the coin symbol.\"\"\"\n    return len(coin['name']) <= max(5, len(coin['symbol']) + 1)\n\n\ndef has_many_caps(name: str) -> bool:\n    \"\"\"return True if the symbol contains enough upper case letters, False if empty.\"\"\"\n    return str and sum(c.islower() for c in name) < (len(name) / 2)\n\n\ndef coingecko_normalize_all(coin: dict):\n    SYMBOL_TO_NORMALIZED = {'miota': 'IOTA'}\n    normalized = SYMBOL_TO_NORMALIZED.get(coin['symbol'])\n    if normalized:\n        coin['ns'] = coin['nn'] = normalized\n        return normalized\n\n    # ns = normalized symbol, nn = normalized name\n    coin['ns'] = coingecko_normalize_symbol(coin['symbol'])\n\n    ID_SUFFIX = '-bitcoin-token'\n    if coin['id'][-len(ID_SUFFIX):] == ID_SUFFIX:\n        coin['nn'] = 'BTC' + coin['ns']\n        return coin['nn']\n\n    name = coin['name']\n\n    prefixes = ('The ', 'the ')\n    for p in prefixes:\n        if name[:len(p)] == p:\n            coin['reduced-name'] = True\n            name = name[len(p):]\n            break\n\n    suffixes = ('coin', 'coins', 'money', 'finance', 'protocol', 'reward', 'rewards', 'token')\n    for s in suffixes:\n        if len(name) > len(s) and name[-len(s):].lower() == s:\n            # but keep suffix when lower-case concatenated\n            if name[-len(s)].islower() and name[-len(s) - 1] != ' ':\n                continue\n            # also keep suffix to avoid confusing nam: \"Bitcoin Token\" -> \"Bitcoin\"\n            if name[:-len(s)].strip().lower() == 'bitcoin':\n                continue\n            coin['reduced-name'] = True\n            name = name[:-len(s)]\n            break\n\n    coin['nn'] = coingecko_normalize_name(name)\n\n    if len(coin['nn']) < len(coin['ns']):\n        if 'reduced-name' in coin:\n            coin['reduced-name'] = False\n            name = coin['name']\n            coin['nn'] = coingecko_normalize_name(name)\n        elif not has_many_caps(name):\n            return coin['ns']\n\n    if not coin['ns']:  # coin['symbol'] may be an emoji that is striped when normalized\n        return coin['nn']\n\n    if coin.get('reduced-name') and coin['ns'].upper() != coin['nn'].upper():\n        return coin['ns']\n\n    i = coin['nn'].find('.')  # if there is a dot in normalized name => prefer the normalized symbol\n    if i >= 0:\n        if i > 1 and coin['nn'][i - 1].isdigit() and coin['nn'][i + 1].isdigit():\n            pass  # except when the dot separates digits\n        else:\n            return coin['ns']\n\n    if is_name_short(coin) and has_many_caps(name):\n        return coin['nn']\n\n    if 1.5 * len(coin['ns']) > len(coin['nn']) and any(c.islower() for c in coin['ns']):\n        return coin['nn']\n\n    return coin['ns']\n\n\ndef coingecko_symbols() -> Dict[str, str]:\n    r = None\n    intermediate = defaultdict(list)\n    try:\n        r = requests.get('https://api.coingecko.com/api/v3/coins/list')\n        all_coins = r.json()\n        # First pass: generate & compare normalized symbol/name, and then select the most pertinent\n        for coin in all_coins:\n            normalized = coingecko_normalize_all(coin)\n            intermediate[normalized].append(coin)\n            # Above line keeps together the coins having the same normalized symbol.\n            # To reduce collision, the coin['name'] is sometimes used in lieu of the coin['symbol'].\n            # The coin['name'] is not capitalized because lower case letters may be meaningful: cETH, yUSD, DATx, zLOT\n    except Exception as why:\n        raise_failure_explanation('COINGECKO', why, {\"\": r})\n\n    final = coingecko_second_pass(intermediate)\n    return coingecko_third_pass(final)\n\n\ndef coingecko_second_pass(intermediate: Dict[str, List[dict]]) -> Dict[str, List[dict]]:\n    # Second pass: fixes most of the symbol collisions\n    final = defaultdict(list)\n    for normalized, coins in intermediate.items():\n        if len(coins) == 1:\n            final[normalized].append(coins[0])\n            continue\n        set_normalized = False\n        for i in range(len(coins)):\n            if normalized == coins[i]['nn']:\n                coin = coins.pop(i)\n                final[normalized].append(coin)\n                set_normalized = True\n                break\n        rest: List[dict] = []\n        for coin in coins:\n            if '%' in coin['name']:\n                if len(coins) == 1:\n                    n = coin['ns']\n                else:\n                    n = coingecko_normalize_name(coin['id'])\n                final[n].append(coin)\n            else:\n                rest.append(coin)\n        if not rest:\n            continue\n        if not set_normalized:\n            rest.sort(key=lambda coin: len(coin['nn']), reverse=True)  # sort by the length of the normalized name\n            coin = rest.pop(0)\n            final[normalized].append(coin)\n        for coin in rest:\n            if coin['nn'] not in intermediate:\n                n = coin['nn']\n            elif coin.get('reduced-name'):\n                n = coingecko_normalize_name(coin['name'])\n            else:\n                n = coingecko_normalize_name(coin['id'])\n            final[n].append(coin)\n    return final\n\n\ndef coingecko_third_pass(final: Dict[str, List[dict]]) -> Dict[str, str]:\n    # Third pass: fixes some remaining collisions and fills the result\n    symbols = {}\n    for normalized, coins in final.items():\n        if len(coins) == 1:\n            symbols[normalized] = coins[0]['id']\n            continue\n        set_normalized = False\n        for i in range(len(coins)):\n            if normalized == coins[i]['nn']:\n                coin = coins.pop(i)\n                symbols[normalized] = coin['id']\n                set_normalized = True\n                break\n        rest: List[dict] = []\n        for coin in coins:\n            if '%' in coin['name']:\n                if len(coins) == 1:\n                    n = coin['ns']\n                else:\n                    n = coingecko_normalize_name(coin['id'])\n                symbols[n] = coin['id']\n            else:\n                rest.append(coin)\n        if not rest:\n            continue\n        if not set_normalized:\n            rest.sort(key=lambda coin: len(coin['nn']), reverse=True)  # sort by the length of the normalized name\n            coin = rest.pop(0)\n            symbols[normalized] = coin['id']\n        for coin in rest:\n            if coin['nn'] not in final:\n                n = coin['nn']\n            elif coin.get('reduced-name'):\n                n = coingecko_normalize_name(coin['name'])\n            else:\n                n = coingecko_normalize_name(coin['id'])\n            symbols[n] = coin['id']\n    return symbols\n\n\ndef whale_alert_coins(key_id: str) -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get(f'https://api.whale-alert.io/v1/status?api_key={key_id}')\n        # Same symbols, but on different blockchains (for instance USDT), are naturally overwritten.\n        return {s.upper(): s for b in r.json()['blockchains'] for s in b['symbols'] if s}\n    except Exception as why:\n        raise_failure_explanation('WHALES_ALERT', why, {\"\": r})\n\n\n_exchange_function_map = {\n    BITFINEX: bitfinex_symbols,\n    BITFLYER: bitflyer_symbols,\n    COINBASE: coinbase_symbols,\n    GEMINI: gemini_symbols,\n    HITBTC: hitbtc_symbols,\n    POLONIEX: poloniex_symbols,\n    PROBIT: probit_symbols,\n    BITSTAMP: bitstamp_symbols,\n    KRAKEN: kraken_symbols,\n    KRAKEN + 'REST': kraken_rest_symbols,\n    BINANCE: binance_symbols,\n    BINANCE_US: binance_us_symbols,\n    BINANCE_FUTURES: binance_futures_symbols,\n    BINANCE_DELIVERY: binance_delivery_symbols,\n    BLOCKCHAIN: blockchain_symbols,\n    EXX: exx_symbols,\n    HUOBI: huobi_symbols,\n    HUOBI_DM: huobi_dm_symbols,\n    HUOBI_SWAP: huobi_swap_symbols,\n    OKCOIN: okcoin_symbols,\n    OKEX: okex_symbols,\n    BYBIT: bybit_symbols,\n    FTX: ftx_symbols,\n    FTX_US: ftx_us_symbols,\n    BITTREX: bittrex_symbols,\n    BITCOINCOM: bitcoincom_symbols,\n    BITMAX: bitmax_symbols,\n    UPBIT: upbit_symbols,\n    GATEIO: gateio_symbols,\n    BITMEX: bitmex_symbols,\n    DERIBIT: deribit_symbols,\n    KRAKEN_FUTURES: kraken_future_symbols,\n    COINGECKO: coingecko_symbols,\n    WHALE_ALERT: whale_alert_coins\n}\n",
        "source_code_len": 30534,
        "target_code": "associated with this software.\n'''\nfrom typing import Dict, Tuple\n\n\nclass _Symbols:\n    def __init__(self):\n        self.data = {}\n\n    def set(self, exchange: str, normalized: dict, exchange_info: dict):\n        self.data[exchange] = {}\n        self.data[exchange]['normalized'] = normalized\n        self.data[exchange]['info'] = exchange_info\n\n    def get(self, exchange: str) -> Tuple[Dict, Dict]:\n        return self.data[exchange]['normalized'], self.data[exchange]['info']\n\n    def populated(self, exchange: str) -> bool:\n        return exchange in self.data\n\n\nSymbols = _Symbols()\n",
        "target_code_len": 588,
        "diff_format": "@@ -5,845 +5,22 @@\n associated with this software.\n+'''\n+from typing import Dict, Tuple\n \n \n-Symbol generation code for exchanges\n-'''\n+class _Symbols:\n+    def __init__(self):\n+        self.data = {}\n \n-import logging\n-import string\n-import time\n-from collections import defaultdict\n-from typing import Dict, List, Optional, Tuple\n+    def set(self, exchange: str, normalized: dict, exchange_info: dict):\n+        self.data[exchange] = {}\n+        self.data[exchange]['normalized'] = normalized\n+        self.data[exchange]['info'] = exchange_info\n \n-import requests\n-from requests import Response\n+    def get(self, exchange: str) -> Tuple[Dict, Dict]:\n+        return self.data[exchange]['normalized'], self.data[exchange]['info']\n \n-from cryptofeed.defines import *\n+    def populated(self, exchange: str) -> bool:\n+        return exchange in self.data\n \n \n-LOG = logging.getLogger('feedhandler')\n-\n-SYMBOL_SEP = '-'\n-\n-_symbols_retrieval_cache: Dict[str, Dict[str, str]] = {}\n-_exchange_info = defaultdict(lambda: defaultdict(dict))\n-\n-\n-_kraken_futures_product_type = {\n-    'FI': 'Inverse Futures',\n-    'FV': 'Vanilla Futures',\n-    'PI': 'Perpetual Inverse Futures',\n-    'PV': 'Perpetual Vanilla Futures',\n-    'IN': 'Real Time Index',\n-    'RR': 'Reference Rate',\n-}\n-\n-\n-def raise_failure_explanation(feed_id: str, exception: BaseException, responses: Dict[str, Optional[Response]]):\n-    LOG.critical('%s: encountered %r while processing response from exchange API', feed_id, exception)\n-    if len(responses) > 1:\n-        LOG.critical('%s: content of one of the %s responses was unexpected', feed_id, len(responses))\n-    for url, r in responses.items():\n-        if url:\n-            LOG.critical('%s: requested URL: %s', feed_id, url)\n-        if r:\n-            LOG.critical('%s: unexpected response: %s', feed_id, r.text)\n-    raise ValueError(f'Cryptofeed stopped because of an unexpected response from {feed_id}') from exception\n-\n-\n-def set_symbol_separator(separator: str):\n-    global SYMBOL_SEP\n-    SYMBOL_SEP = separator\n-\n-\n-def get_symbol_separator() -> str:\n-    global SYMBOL_SEP\n-    return SYMBOL_SEP\n-\n-\n-def gen_symbols(exchange: str, key_id=None) -> Dict[str, str]:\n-    if exchange not in _symbols_retrieval_cache:\n-        LOG.info(\"%s: Getting list of symbols\", exchange)\n-        symbols = _exchange_function_map[exchange](key_id) if key_id else _exchange_function_map[exchange]()\n-        LOG.info(\"%s: %s symbols\", exchange, len(symbols))\n-\n-        # log all retrieved symbols using debug level\n-        for normalized, exch_sym in sorted(symbols.items()):\n-            LOG.debug('%s: id-from-exch -> normalized: %-35s-> %s', exchange, exch_sym, normalized)\n-\n-        _symbols_retrieval_cache[exchange] = symbols\n-    return _symbols_retrieval_cache[exchange]\n-\n-\n-def _binance_symbols(endpoint: str, exchange: str):\n-    r = None\n-    try:\n-        ret = {}\n-        r = requests.get(endpoint)\n-        for symbol in r.json()['symbols']:\n-            if symbol.get('status', 'TRADING') != \"TRADING\":\n-                continue\n-            if symbol.get('contractStatus', 'TRADING') != \"TRADING\":\n-                continue\n-            split = len(symbol['baseAsset'])\n-            normalized = symbol['symbol'][:split] + SYMBOL_SEP + symbol['symbol'][split:]\n-            ret[normalized] = symbol['symbol']\n-            _exchange_info[exchange]['tick_size'][normalized] = symbol['filters'][0]['tickSize']\n-            if \"contractType\" in symbol:\n-                _exchange_info[exchange]['contract_type'][normalized] = symbol['contractType']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation(exchange, why, {endpoint: r})\n-\n-\n-def binance_symbols() -> Dict[str, str]:\n-    return _binance_symbols('https://api.binance.com/api/v3/exchangeInfo', BINANCE)\n-\n-\n-def binance_us_symbols() -> Dict[str, str]:\n-    return _binance_symbols('https://api.binance.us/api/v3/exchangeInfo', BINANCE_US)\n-\n-\n-def binance_futures_symbols() -> Dict[str, str]:\n-    base = _binance_symbols('https://fapi.binance.com/fapi/v1/exchangeInfo', BINANCE_FUTURES)\n-    add = {}\n-    for symbol, orig in base.items():\n-        if \"_\" in orig:\n-            continue\n-        add[f\"{symbol}-PINDEX\"] = f\"p{orig}\"\n-    base.update(add)\n-    return base\n-\n-\n-def binance_delivery_symbols() -> Dict[str, str]:\n-    return _binance_symbols('https://dapi.binance.com/dapi/v1/exchangeInfo', BINANCE_DELIVERY)\n-\n-\n-def bitfinex_symbols() -> Dict[str, str]:\n-    # doc: https://docs.bitfinex.com/docs/ws-general#supported-pairs\n-    r1 = r2 = None\n-    try:\n-        r1 = requests.get('https://api.bitfinex.com/v2/tickers?symbols=ALL')\n-        r2 = requests.get('https://api-pub.bitfinex.com/v2/conf/pub:map:currency:sym')\n-        tickers: List[List[str]] = r1.json()\n-        norm: List[Tuple[str, str]] = r2.json()[0]\n-        norm: Dict[str, str] = dict(norm)\n-        for k, v in dict(norm).items():\n-            if k[-2:] == 'F0' or '-' in v:  # Do not convert BTCF0 -> BTC or PBTCETH -> PBTC-ETH\n-                del norm[k]\n-        norm['BCHN'] = 'BCH'  # Bitfinex uses BCHN, other exchanges use BCH\n-\n-        ret = {}\n-        for symbol in [t[0] for t in tickers]:\n-            if symbol[0] == 'f':\n-                normalized = norm.get(symbol[1:], symbol[1:])\n-            else:\n-                if len(symbol) == 7:\n-                    base, quote = symbol[1:4], symbol[4:]\n-                else:\n-                    base, quote = symbol[1:].split(':')\n-                    assert ':' in symbol\n-                normalized = norm.get(base, base) + SYMBOL_SEP + norm.get(quote, quote)\n-            ret[normalized.upper()] = symbol\n-        return ret\n-    except ValueError as why:\n-        raise_failure_explanation('BITFINEX', why, {\"tickers?symbols=ALL\": r1, \"pub:map:currency:sym\": r2})\n-\n-\n-def bitflyer_symbols() -> Dict[str, str]:\n-    endpoint = r = None\n-    try:\n-        ret = {}\n-        endpoints = ['https://api.bitflyer.com/v1/getmarkets/eu', 'https://api.bitflyer.com/v1/getmarkets/usa', 'https://api.bitflyer.com/v1/getmarkets']\n-        for endpoint in endpoints:\n-            r = requests.get(endpoint)\n-            for entry in r.json():\n-                normalized = entry['product_code'].replace(\"_\", SYMBOL_SEP)\n-                ret[normalized] = entry['product_code']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('BITFLYER', why, {endpoint: r})\n-\n-\n-def bybit_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.bybit.com/v2/public/symbols')\n-        ret = {}\n-        for symbol in r.json()['result']:\n-            quote = symbol['quote_currency']\n-            if not symbol['name'].endswith(quote):\n-                base, contract = symbol['name'].split(quote)\n-                normalized = f\"{base}{SYMBOL_SEP}{quote}-{contract}\"\n-            else:\n-                normalized = f\"{symbol['base_currency']}{SYMBOL_SEP}{quote}\"\n-            ret[normalized] = symbol['name']\n-            _exchange_info[BYBIT]['tick_size'][normalized] = symbol['price_filter']['tick_size']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('BYBIT', why, {\"\": r})\n-\n-\n-def _ftx_helper(endpoint: str, exchange: str):\n-    r = None\n-    try:\n-        r = requests.get(endpoint)\n-        ret = {}\n-        for data in r.json()['result']:\n-            normalized = data['name'].replace(\"/\", SYMBOL_SEP)\n-            symbol = data['name']\n-            ret[normalized] = symbol\n-            _exchange_info[exchange]['tick_size'][normalized] = data['priceIncrement']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation(exchange, why, {endpoint: r})\n-\n-\n-def ftx_symbols() -> Dict[str, str]:\n-    return _ftx_helper('https://ftx.com/api/markets', FTX)\n-\n-\n-def ftx_us_symbols() -> Dict[str, str]:\n-    return _ftx_helper('https://ftx.us/api/markets', FTX_US)\n-\n-\n-def coinbase_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.pro.coinbase.com/products')\n-        ret = {}\n-        for data in r.json():\n-            normalized = data['id'].replace(\"-\", SYMBOL_SEP)\n-            ret[normalized] = data['id']\n-            _exchange_info[COINBASE]['tick_size'][normalized] = data['quote_increment']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('COINBASE', why, {\"\": r})\n-\n-\n-def gemini_symbols(*args) -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.gemini.com/v1/symbols')\n-        ret = {}\n-        for symbol in r.json():\n-            std = f\"{symbol[:-3]}{SYMBOL_SEP}{symbol[-3:]}\"\n-            std = std.upper()\n-            ret[std] = symbol.upper()\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('GEMINI', why, {\"\": r})\n-\n-\n-def hitbtc_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        ret = {}\n-        r = requests.get('https://api.hitbtc.com/api/2/public/symbol')\n-        for symbol in r.json():\n-            split = len(symbol['baseCurrency'])\n-            normalized = symbol['id'][:split] + SYMBOL_SEP + symbol['id'][split:]\n-            ret[normalized] = symbol['id']\n-            _exchange_info[HITBTC]['tick_size'][normalized] = symbol['tickSize']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('HITBTC', why, {\"\": r})\n-\n-\n-def poloniex_id_symbol_mapping():\n-    r = None\n-    try:\n-        r = requests.get('https://poloniex.com/public?command=returnTicker')\n-        symbols = r.json()\n-        ret = {}\n-        for symbol in symbols:\n-            ret[symbols[symbol]['id']] = symbol\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('POLONIEX', why, {\"\": r})\n-\n-\n-def poloniex_symbols() -> Dict[str, str]:\n-    ret = {}\n-    for _, value in poloniex_id_symbol_mapping().items():\n-        std = value.replace(\"STR\", \"XLM\")\n-        quote, base = std.split(\"_\")\n-        ret[quote + SYMBOL_SEP + base] = value\n-    return ret\n-\n-\n-def bitstamp_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://www.bitstamp.net/api/v2/trading-pairs-info/')\n-        ret = {}\n-        for data in r.json():\n-            normalized = data['name'].replace(\"/\", SYMBOL_SEP)\n-            symbol = data['url_symbol']\n-            ret[normalized] = symbol\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('BITSTAMP', why, {\"\": r})\n-\n-\n-def kraken_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.kraken.com/0/public/AssetPairs')\n-        data = r.json()\n-        ret = {}\n-        for symbol in data['result']:\n-            if 'wsname' not in data['result'][symbol] or '.d' in symbol:\n-                # https://blog.kraken.com/post/259/introducing-the-kraken-dark-pool/\n-                # .d is for dark pool symbols\n-                continue\n-\n-            base, quote = data['result'][symbol]['wsname'].split(\"/\")\n-\n-            normalized = f\"{base}{SYMBOL_SEP}{quote}\"\n-            exch = data['result'][symbol]['wsname']\n-            normalized = normalized.replace('XBT', 'BTC')\n-            normalized = normalized.replace('XDG', 'DOG')\n-            ret[normalized] = exch\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('KRAKEN', why, {\"\": r})\n-\n-\n-def kraken_rest_symbols() -> Dict[str, str]:\n-    return {normalized: exchange.replace(\"/\", \"\") for normalized, exchange in kraken_symbols().items()}\n-\n-\n-def exx_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.exx.com/data/v1/tickers')\n-        exchange = [key.upper() for key in r.json().keys()]\n-        symbols = [key.replace(\"_\", SYMBOL_SEP) for key in exchange]\n-        return dict(zip(symbols, exchange))\n-    except Exception as why:\n-        raise_failure_explanation('EXX', why, {\"\": r})\n-\n-\n-def huobi_common_symbols(url: str):\n-    r = None\n-    try:\n-        r = requests.get(url)\n-        ret = {}\n-        for e in r.json()['data']:\n-            if e['state'] == 'offline':\n-                continue\n-            normalized = f\"{e['base-currency'].upper()}{SYMBOL_SEP}{e['quote-currency'].upper()}\"\n-            symbol = f\"{e['base-currency']}{e['quote-currency']}\"\n-            ret[normalized] = symbol\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('HUOBI', why, {url: r})\n-\n-\n-def huobi_symbols() -> Dict[str, str]:\n-    return huobi_common_symbols('https://api.huobi.pro/v1/common/symbols')\n-\n-\n-def huobi_us_symbols() -> Dict[str, str]:\n-    return huobi_common_symbols('https://api.huobi.com/v1/common/symbols')\n-\n-\n-def huobi_dm_symbols() -> Dict[str, str]:\n-    \"\"\"\n-    Mapping is, for instance: {\"BTC_CW\":\"BTC190816\"}\n-    See comments in exchange/huobi_dm.py\n-    \"\"\"\n-    mapping = {\n-        \"this_week\": \"CW\",\n-        \"next_week\": \"NW\",\n-        \"quarter\": \"CQ\",\n-        \"next_quarter\": \"NQ\"\n-    }\n-    r = None\n-    try:\n-        r = requests.get('https://www.hbdm.com/api/v1/contract_contract_info')\n-        symbols = {}\n-        for e in r.json()['data']:\n-            symbols[f\"{e['symbol']}_{mapping[e['contract_type']]}\"] = e['contract_code']\n-            _exchange_info[HUOBI_DM]['tick_size'][e['contract_code']] = e['price_tick']\n-            _exchange_info[HUOBI_DM]['short_code_mappings'][f\"{e['symbol']}_{mapping[e['contract_type']]}\"] = e['contract_code']\n-        return symbols\n-    except Exception as why:\n-        raise_failure_explanation('HUOBI_DM', why, {\"\": r})\n-\n-\n-def huobi_swap_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.hbdm.com/swap-api/v1/swap_contract_info')\n-        symbols = {}\n-        for e in r.json()['data']:\n-            symbols[e['contract_code']] = e['contract_code']\n-            _exchange_info[HUOBI_SWAP]['tick_size'][e['contract_code']] = e['price_tick']\n-        return symbols\n-    except Exception as why:\n-        raise_failure_explanation('HUOBI_SWAP', why, {\"\": r})\n-\n-\n-def okcoin_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://www.okcoin.com/api/spot/v3/instruments')\n-        ret = {}\n-        for e in r.json():\n-            ret[e['instrument_id']] = e['instrument_id']\n-            _exchange_info[OKCOIN]['tick_size'][e['instrument_id']] = e['tick_size']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('OKCOIN', why, {\"\": r})\n-\n-\n-def okex_symbols(*args) -> Dict[str, str]:\n-    urls = ['https://www.okex.com/api/spot/v3/instruments',\n-            'https://www.okex.com/api/swap/v3/instruments',\n-            'https://www.okex.com/api/futures/v3/instruments']\n-    urls = urls + okex_compute_option_urls_from_underlyings()\n-\n-    symbols: Dict[str, str] = {}\n-    for u in urls:\n-        time.sleep(0.2)\n-        symbols.update(okex_symbols_from_one_url(u))\n-\n-    for symbol in symbols:\n-        instrument_type = 'futures'\n-        dash_count = symbol.count(get_symbol_separator())\n-        if dash_count == 1:  # BTC-USDT\n-            instrument_type = 'spot'\n-        if dash_count == 4:  # BTC-USD-201225-35000-P\n-            instrument_type = 'option'\n-        if symbol[-4:] == \"SWAP\":  # BTC-USDT-SWAP\n-            instrument_type = 'swap'\n-\n-        _exchange_info[OKEX]['instrument_type'][symbol] = instrument_type\n-\n-    return symbols\n-\n-\n-def okex_compute_option_urls_from_underlyings() -> List[str]:\n-    url = 'https://www.okex.com/api/option/v3/underlying'\n-    r = None\n-    try:\n-        r = requests.get(url)\n-        return [f'https://www.okex.com/api/option/v3/instruments/{underlying}' for underlying in r.json()]\n-    except Exception as why:\n-        raise_failure_explanation('OKEX', why, {url: r})\n-\n-\n-def okex_symbols_from_one_url(url: str) -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get(url)\n-        ret = {}\n-        for e in r.json():\n-            ret[e['instrument_id']] = e['instrument_id']\n-            _exchange_info[OKEX]['tick_size'][e['instrument_id']] = e['tick_size']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('OKEX', why, {url: r})\n-\n-\n-def bittrex_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.bittrex.com/api/v1.1/public/getmarkets')\n-        r = r.json()['result']\n-        return {f\"{e['MarketCurrency']}{SYMBOL_SEP}{e['BaseCurrency']}\": e['MarketName'] for e in r if e['IsActive']}\n-    except Exception as why:\n-        raise_failure_explanation('BITTREX', why, {\"\": r})\n-\n-\n-def bitcoincom_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.exchange.bitcoin.com/api/2/public/symbol')\n-        return {f\"{data['baseCurrency']}{SYMBOL_SEP}{data['quoteCurrency'].replace('USD', 'USDT')}\": data['id'] for data in r.json()}\n-    except Exception as why:\n-        raise_failure_explanation('BITCOINCOM', why, {\"\": r})\n-\n-\n-def bitmax_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://bitmax.io/api/pro/v1/products')\n-        ret = {}\n-        for entry in r.json()['data']:\n-            # Only \"Normal\" status symbols are tradeable\n-            if entry['status'] == 'Normal':\n-                normalized = f\"{entry['baseAsset']}{SYMBOL_SEP}{entry['quoteAsset']}\"\n-                ret[normalized] = entry['symbol']\n-                _exchange_info[BITMAX]['tick_size'][normalized] = entry['tickSize']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('BITMAX', why, {\"\": r})\n-\n-\n-def upbit_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.upbit.com/v1/market/all')\n-        return {f\"{data['market'].split('-')[1]}{SYMBOL_SEP}{data['market'].split('-')[0]}\": data['market'] for data in r.json()}\n-    except Exception as why:\n-        raise_failure_explanation('UPBIT', why, {\"\": r})\n-\n-\n-def blockchain_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get(\"https://api.blockchain.com/mercury-gateway/v1/instruments\")\n-        return {data[\"symbol\"].replace(\"-\", SYMBOL_SEP): data[\"symbol\"] for data in r.json()}\n-    except Exception as why:\n-        raise_failure_explanation('BLOCKCHAIN', why, {\"\": r})\n-\n-\n-def gateio_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get(\"https://api.gateio.ws/api/v4/spot/currency_pairs\")\n-        return {data[\"id\"].replace(\"_\", SYMBOL_SEP): data['id'] for data in r.json()}\n-    except Exception as why:\n-        raise_failure_explanation('GATEIO', why, {\"\": r})\n-\n-\n-def bitmex_symbols() -> Dict[str, str]:\n-    r = None\n-    ret = {}\n-    try:\n-        r = requests.get(\"https://www.bitmex.com/api/v1/instrument/active\")\n-        for entry in r.json():\n-            components = []\n-            components.append(entry['rootSymbol'])\n-            components.append(entry['quoteCurrency'])\n-\n-            if entry['expiry']:\n-                components.append(entry['symbol'][-3:])\n-\n-            normalized = SYMBOL_SEP.join(components)\n-            normalized = normalized.replace(\"XBT\", \"BTC\")\n-            ret[normalized] = entry['symbol']\n-            _exchange_info[BITMEX]['tick_size'][normalized] = entry['tickSize']\n-\n-            if entry['expiry']:\n-                _exchange_info[BITMEX]['expiry'][normalized] = entry['expiry']\n-\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('BITMEX', why, {\"\": r})\n-\n-\n-def deribit_symbols() -> Dict[str, str]:\n-    url = r = None\n-    ret = {}\n-    try:\n-        # TODO: get currencies from https://www.deribit.com/api/v2/public/get_currencies\n-        currencies = ['BTC', 'ETH']\n-        for c in currencies:\n-            url = f\"https://www.deribit.com/api/v2/public/get_instruments?currency={c}&expired=false\"\n-            r = requests.get(url)\n-            for entry in r.json()['result']:\n-                split = entry['instrument_name'].split(\"-\")\n-                normalized = split[0] + SYMBOL_SEP + entry['quote_currency'] + \"-\" + '-'.join(split[1:])\n-                ret[normalized] = entry['instrument_name']\n-                _exchange_info[DERIBIT]['tick_size'][normalized] = entry['tick_size']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('DERIBIT', why, {url: r})\n-\n-\n-def kraken_future_symbols() -> Dict[str, str]:\n-    r = None\n-    ret = {}\n-    try:\n-        r = requests.get('https://futures.kraken.com/derivatives/api/v3/instruments')\n-        data = r.json()['instruments']\n-        for entry in data:\n-            if not entry['tradeable']:\n-                continue\n-            normalized = entry['symbol'].upper().replace(\"_\", \"-\")\n-            symbol = normalized[3:6] + SYMBOL_SEP + normalized[6:9]\n-            normalized = normalized.replace(normalized[3:9], symbol)\n-            normalized = normalized.replace('XBT', 'BTC')\n-\n-            _exchange_info[KRAKEN_FUTURES]['tick_size'][normalized] = entry['tickSize']\n-            _exchange_info[KRAKEN_FUTURES]['contract_size'][normalized] = entry['contractSize']\n-            _exchange_info[KRAKEN_FUTURES]['underlying'][normalized] = entry['underlying']\n-            _exchange_info[KRAKEN_FUTURES]['product_type'][normalized] = _kraken_futures_product_type[normalized[:2]]\n-            ret[normalized] = entry['symbol']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('KRAKEN_FUTURES', why, {\"\": r})\n-\n-\n-def probit_symbols() -> Dict[str, str]:\n-    # doc: https://docs-en.probit.com/reference-link/market\n-    r = None\n-    try:\n-        r = requests.get('https://api.probit.com/api/exchange/v1/market')\n-        return {entry['id']: entry['id'] for entry in r.json()['data']}\n-    except Exception as why:\n-        raise_failure_explanation('PROBIT', why, {\"\": r})\n-\n-\n-def coingecko_normalize_symbol(symbol: str) -> str:\n-    # keep digits, letters and dots, replace others by space\n-    symbol = ''.join(c if c.isalnum() or c in ('.', '+') else ' ' for c in symbol)\n-    return coingecko_normalize(symbol.upper())\n-\n-\n-def coingecko_normalize_name(name: str) -> str:\n-    # keep digits and letters, replace others by space (except when only composed by upper case letters, digits and dots)\n-    if not all(c.isupper() or c.isdigit() or c == '.' for c in name):\n-        name = ''.join(c if c.isalnum() else ' ' for c in name)\n-    return coingecko_normalize(name)\n-\n-\n-def coingecko_normalize(sym: str) -> str:\n-    sym = sym.strip()\n-    # do not concatenate numbers => separate them with a dot\n-    sym = list(sym)\n-    if len(sym) > 4:\n-        for i in range(2, len(sym) - 1):\n-            if sym[i] == ' ' and sym[i - 1].isdigit() and sym[i + 1].isdigit():\n-                sym[i] = '.'\n-    sym = ''.join(sym)\n-    # concatenate space-separated words => use CamelCase to distinguish the words\n-    if ' ' in sym:\n-        if sum(c.islower() for c in sym):  # if there is at least one lower case letter\n-            sym = ' '.join(word[0].upper() + word[1:] for word in sym.split())  # Just capitalize initial letter of each word\n-        else:  # CoinGecko may provide full upper-case as for \"THE STONE COIN\"\n-            sym = string.capwords(sym)  # capwords converts \"THE STONE COIN\" to \"The Stone Coin\"\n-        sym = sym.replace(' ', '')  # concatenate words\n-    return sym\n-\n-\n-def is_name_short(coin: dict) -> bool:\n-    \"\"\"return True if the coin name is enough short compared to the coin symbol.\"\"\"\n-    return len(coin['name']) <= max(5, len(coin['symbol']) + 1)\n-\n-\n-def has_many_caps(name: str) -> bool:\n-    \"\"\"return True if the symbol contains enough upper case letters, False if empty.\"\"\"\n-    return str and sum(c.islower() for c in name) < (len(name) / 2)\n-\n-\n-def coingecko_normalize_all(coin: dict):\n-    SYMBOL_TO_NORMALIZED = {'miota': 'IOTA'}\n-    normalized = SYMBOL_TO_NORMALIZED.get(coin['symbol'])\n-    if normalized:\n-        coin['ns'] = coin['nn'] = normalized\n-        return normalized\n-\n-    # ns = normalized symbol, nn = normalized name\n-    coin['ns'] = coingecko_normalize_symbol(coin['symbol'])\n-\n-    ID_SUFFIX = '-bitcoin-token'\n-    if coin['id'][-len(ID_SUFFIX):] == ID_SUFFIX:\n-        coin['nn'] = 'BTC' + coin['ns']\n-        return coin['nn']\n-\n-    name = coin['name']\n-\n-    prefixes = ('The ', 'the ')\n-    for p in prefixes:\n-        if name[:len(p)] == p:\n-            coin['reduced-name'] = True\n-            name = name[len(p):]\n-            break\n-\n-    suffixes = ('coin', 'coins', 'money', 'finance', 'protocol', 'reward', 'rewards', 'token')\n-    for s in suffixes:\n-        if len(name) > len(s) and name[-len(s):].lower() == s:\n-            # but keep suffix when lower-case concatenated\n-            if name[-len(s)].islower() and name[-len(s) - 1] != ' ':\n-                continue\n-            # also keep suffix to avoid confusing nam: \"Bitcoin Token\" -> \"Bitcoin\"\n-            if name[:-len(s)].strip().lower() == 'bitcoin':\n-                continue\n-            coin['reduced-name'] = True\n-            name = name[:-len(s)]\n-            break\n-\n-    coin['nn'] = coingecko_normalize_name(name)\n-\n-    if len(coin['nn']) < len(coin['ns']):\n-        if 'reduced-name' in coin:\n-            coin['reduced-name'] = False\n-            name = coin['name']\n-            coin['nn'] = coingecko_normalize_name(name)\n-        elif not has_many_caps(name):\n-            return coin['ns']\n-\n-    if not coin['ns']:  # coin['symbol'] may be an emoji that is striped when normalized\n-        return coin['nn']\n-\n-    if coin.get('reduced-name') and coin['ns'].upper() != coin['nn'].upper():\n-        return coin['ns']\n-\n-    i = coin['nn'].find('.')  # if there is a dot in normalized name => prefer the normalized symbol\n-    if i >= 0:\n-        if i > 1 and coin['nn'][i - 1].isdigit() and coin['nn'][i + 1].isdigit():\n-            pass  # except when the dot separates digits\n-        else:\n-            return coin['ns']\n-\n-    if is_name_short(coin) and has_many_caps(name):\n-        return coin['nn']\n-\n-    if 1.5 * len(coin['ns']) > len(coin['nn']) and any(c.islower() for c in coin['ns']):\n-        return coin['nn']\n-\n-    return coin['ns']\n-\n-\n-def coingecko_symbols() -> Dict[str, str]:\n-    r = None\n-    intermediate = defaultdict(list)\n-    try:\n-        r = requests.get('https://api.coingecko.com/api/v3/coins/list')\n-        all_coins = r.json()\n-        # First pass: generate & compare normalized symbol/name, and then select the most pertinent\n-        for coin in all_coins:\n-            normalized = coingecko_normalize_all(coin)\n-            intermediate[normalized].append(coin)\n-            # Above line keeps together the coins having the same normalized symbol.\n-            # To reduce collision, the coin['name'] is sometimes used in lieu of the coin['symbol'].\n-            # The coin['name'] is not capitalized because lower case letters may be meaningful: cETH, yUSD, DATx, zLOT\n-    except Exception as why:\n-        raise_failure_explanation('COINGECKO', why, {\"\": r})\n-\n-    final = coingecko_second_pass(intermediate)\n-    return coingecko_third_pass(final)\n-\n-\n-def coingecko_second_pass(intermediate: Dict[str, List[dict]]) -> Dict[str, List[dict]]:\n-    # Second pass: fixes most of the symbol collisions\n-    final = defaultdict(list)\n-    for normalized, coins in intermediate.items():\n-        if len(coins) == 1:\n-            final[normalized].append(coins[0])\n-            continue\n-        set_normalized = False\n-        for i in range(len(coins)):\n-            if normalized == coins[i]['nn']:\n-                coin = coins.pop(i)\n-                final[normalized].append(coin)\n-                set_normalized = True\n-                break\n-        rest: List[dict] = []\n-        for coin in coins:\n-            if '%' in coin['name']:\n-                if len(coins) == 1:\n-                    n = coin['ns']\n-                else:\n-                    n = coingecko_normalize_name(coin['id'])\n-                final[n].append(coin)\n-            else:\n-                rest.append(coin)\n-        if not rest:\n-            continue\n-        if not set_normalized:\n-            rest.sort(key=lambda coin: len(coin['nn']), reverse=True)  # sort by the length of the normalized name\n-            coin = rest.pop(0)\n-            final[normalized].append(coin)\n-        for coin in rest:\n-            if coin['nn'] not in intermediate:\n-                n = coin['nn']\n-            elif coin.get('reduced-name'):\n-                n = coingecko_normalize_name(coin['name'])\n-            else:\n-                n = coingecko_normalize_name(coin['id'])\n-            final[n].append(coin)\n-    return final\n-\n-\n-def coingecko_third_pass(final: Dict[str, List[dict]]) -> Dict[str, str]:\n-    # Third pass: fixes some remaining collisions and fills the result\n-    symbols = {}\n-    for normalized, coins in final.items():\n-        if len(coins) == 1:\n-            symbols[normalized] = coins[0]['id']\n-            continue\n-        set_normalized = False\n-        for i in range(len(coins)):\n-            if normalized == coins[i]['nn']:\n-                coin = coins.pop(i)\n-                symbols[normalized] = coin['id']\n-                set_normalized = True\n-                break\n-        rest: List[dict] = []\n-        for coin in coins:\n-            if '%' in coin['name']:\n-                if len(coins) == 1:\n-                    n = coin['ns']\n-                else:\n-                    n = coingecko_normalize_name(coin['id'])\n-                symbols[n] = coin['id']\n-            else:\n-                rest.append(coin)\n-        if not rest:\n-            continue\n-        if not set_normalized:\n-            rest.sort(key=lambda coin: len(coin['nn']), reverse=True)  # sort by the length of the normalized name\n-            coin = rest.pop(0)\n-            symbols[normalized] = coin['id']\n-        for coin in rest:\n-            if coin['nn'] not in final:\n-                n = coin['nn']\n-            elif coin.get('reduced-name'):\n-                n = coingecko_normalize_name(coin['name'])\n-            else:\n-                n = coingecko_normalize_name(coin['id'])\n-            symbols[n] = coin['id']\n-    return symbols\n-\n-\n-def whale_alert_coins(key_id: str) -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get(f'https://api.whale-alert.io/v1/status?api_key={key_id}')\n-        # Same symbols, but on different blockchains (for instance USDT), are naturally overwritten.\n-        return {s.upper(): s for b in r.json()['blockchains'] for s in b['symbols'] if s}\n-    except Exception as why:\n-        raise_failure_explanation('WHALES_ALERT', why, {\"\": r})\n-\n-\n-_exchange_function_map = {\n-    BITFINEX: bitfinex_symbols,\n-    BITFLYER: bitflyer_symbols,\n-    COINBASE: coinbase_symbols,\n-    GEMINI: gemini_symbols,\n-    HITBTC: hitbtc_symbols,\n-    POLONIEX: poloniex_symbols,\n-    PROBIT: probit_symbols,\n-    BITSTAMP: bitstamp_symbols,\n-    KRAKEN: kraken_symbols,\n-    KRAKEN + 'REST': kraken_rest_symbols,\n-    BINANCE: binance_symbols,\n-    BINANCE_US: binance_us_symbols,\n-    BINANCE_FUTURES: binance_futures_symbols,\n-    BINANCE_DELIVERY: binance_delivery_symbols,\n-    BLOCKCHAIN: blockchain_symbols,\n-    EXX: exx_symbols,\n-    HUOBI: huobi_symbols,\n-    HUOBI_DM: huobi_dm_symbols,\n-    HUOBI_SWAP: huobi_swap_symbols,\n-    OKCOIN: okcoin_symbols,\n-    OKEX: okex_symbols,\n-    BYBIT: bybit_symbols,\n-    FTX: ftx_symbols,\n-    FTX_US: ftx_us_symbols,\n-    BITTREX: bittrex_symbols,\n-    BITCOINCOM: bitcoincom_symbols,\n-    BITMAX: bitmax_symbols,\n-    UPBIT: upbit_symbols,\n-    GATEIO: gateio_symbols,\n-    BITMEX: bitmex_symbols,\n-    DERIBIT: deribit_symbols,\n-    KRAKEN_FUTURES: kraken_future_symbols,\n-    COINGECKO: coingecko_symbols,\n-    WHALE_ALERT: whale_alert_coins\n-}\n+Symbols = _Symbols()\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\n\nimport logging\nimport string\nimport time\nfrom collections import defaultdict\nfrom typing import Dict, List, Optional, Tuple\n\nimport requests\nfrom requests import Response\n\nfrom cryptofeed.defines import *\n\n\nLOG = logging.getLogger('feedhandler')\n\nSYMBOL_SEP = '-'\n\n_symbols_retrieval_cache: Dict[str, Dict[str, str]] = {}\n_exchange_info = defaultdict(lambda: defaultdict(dict))\n\n\n_kraken_futures_product_type = {\n    'FI': 'Inverse Futures',\n    'FV': 'Vanilla Futures',\n    'PI': 'Perpetual Inverse Futures',\n    'PV': 'Perpetual Vanilla Futures',\n    'IN': 'Real Time Index',\n    'RR': 'Reference Rate',\n}\n\n\ndef raise_failure_explanation(feed_id: str, exception: BaseException, responses: Dict[str, Optional[Response]]):\n    <IND>LOG.critical('%s: encountered %r while processing response from exchange API', feed_id, exception)\n    if len(responses) > 1:\n        <IND>LOG.critical('%s: content of one of the %s responses was unexpected', feed_id, len(responses))\n    <DED>for url, r in responses.items():\n        <IND>if url:\n            <IND>LOG.critical('%s: requested URL: %s', feed_id, url)\n        <DED>if r:\n            <IND>LOG.critical('%s: unexpected response: %s', feed_id, r.text)\n    <DED><DED>raise ValueError(f'Cryptofeed stopped because of an unexpected response from {feed_id}') from exception\n\n\n<DED>def set_symbol_separator(separator: str):\n    <IND>global SYMBOL_SEP\n    SYMBOL_SEP = separator\n\n\n<DED>def get_symbol_separator() -> str:\n    <IND>global SYMBOL_SEP\n    return SYMBOL_SEP\n\n\n<DED>def gen_symbols(exchange: str, key_id=None) -> Dict[str, str]:\n    <IND>if exchange not in _symbols_retrieval_cache:\n        <IND>LOG.info(\"%s: Getting list of symbols\", exchange)\n        symbols = _exchange_function_map[exchange](key_id) if key_id else _exchange_function_map[exchange]()\n        LOG.info(\"%s: %s symbols\", exchange, len(symbols))\n\n        # log all retrieved symbols using debug level\n        for normalized, exch_sym in sorted(symbols.items()):\n            <IND>LOG.debug('%s: id-from-exch -> normalized: %-35s-> %s', exchange, exch_sym, normalized)\n\n        <DED>_symbols_retrieval_cache[exchange] = symbols\n    <DED>return _symbols_retrieval_cache[exchange]\n\n\n<DED>def _binance_symbols(endpoint: str, exchange: str):\n    <IND>r = None\n    try:\n        <IND>ret = {}\n        r = requests.get(endpoint)\n        for symbol in r.json()['symbols']:\n            <IND>if symbol.get('status', 'TRADING') != \"TRADING\":\n                <IND>continue\n            <DED>if symbol.get('contractStatus', 'TRADING') != \"TRADING\":\n                <IND>continue\n            <DED>split = len(symbol['baseAsset'])\n            normalized = symbol['symbol'][:split] + SYMBOL_SEP + symbol['symbol'][split:]\n            ret[normalized] = symbol['symbol']\n            _exchange_info[exchange]['tick_size'][normalized] = symbol['filters'][0]['tickSize']\n            if \"contractType\" in symbol:\n                <IND>_exchange_info[exchange]['contract_type'][normalized] = symbol['contractType']\n        <DED><DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation(exchange, why, {endpoint: r})\n\n\n<DED><DED>def binance_symbols() -> Dict[str, str]:\n    <IND>return _binance_symbols('https://api.binance.com/api/v3/exchangeInfo', BINANCE)\n\n\n<DED>def binance_us_symbols() -> Dict[str, str]:\n    <IND>return _binance_symbols('https://api.binance.us/api/v3/exchangeInfo', BINANCE_US)\n\n\n<DED>def binance_futures_symbols() -> Dict[str, str]:\n    <IND>base = _binance_symbols('https://fapi.binance.com/fapi/v1/exchangeInfo', BINANCE_FUTURES)\n    add = {}\n    for symbol, orig in base.items():\n        <IND>if \"_\" in orig:\n            <IND>continue\n        <DED>add[f\"{symbol}-PINDEX\"] = f\"p{orig}\"\n    <DED>base.update(add)\n    return base\n\n\n<DED>def binance_delivery_symbols() -> Dict[str, str]:\n    <IND>return _binance_symbols('https://dapi.binance.com/dapi/v1/exchangeInfo', BINANCE_DELIVERY)\n\n\n<DED>def bitfinex_symbols() -> Dict[str, str]:\n    # doc: https://docs.bitfinex.com/docs/ws-general#supported-pairs\n    <IND>r1 = r2 = None\n    try:\n        <IND>r1 = requests.get('https://api.bitfinex.com/v2/tickers?symbols=ALL')\n        r2 = requests.get('https://api-pub.bitfinex.com/v2/conf/pub:map:currency:sym')\n        tickers: List[List[str]] = r1.json()\n        norm: List[Tuple[str, str]] = r2.json()[0]\n        norm: Dict[str, str] = dict(norm)\n        for k, v in dict(norm).items():\n            <IND>if k[-2:] == 'F0' or '-' in v:  # Do not convert BTCF0 -> BTC or PBTCETH -> PBTC-ETH\n                <IND>del norm[k]\n        <DED><DED>norm['BCHN'] = 'BCH'  # Bitfinex uses BCHN, other exchanges use BCH\n\n        ret = {}\n        for symbol in [t[0] for t in tickers]:\n            <IND>if symbol[0] == 'f':\n                <IND>normalized = norm.get(symbol[1:], symbol[1:])\n            <DED>else:\n                <IND>if len(symbol) == 7:\n                    <IND>base, quote = symbol[1:4], symbol[4:]\n                <DED>else:\n                    <IND>base, quote = symbol[1:].split(':')\n                    assert ':' in symbol\n                <DED>normalized = norm.get(base, base) + SYMBOL_SEP + norm.get(quote, quote)\n            <DED>ret[normalized.upper()] = symbol\n        <DED>return ret\n    <DED>except ValueError as why:\n        <IND>raise_failure_explanation('BITFINEX', why, {\"tickers?symbols=ALL\": r1, \"pub:map:currency:sym\": r2})\n\n\n<DED><DED>def bitflyer_symbols() -> Dict[str, str]:\n    <IND>endpoint = r = None\n    try:\n        <IND>ret = {}\n        endpoints = ['https://api.bitflyer.com/v1/getmarkets/eu', 'https://api.bitflyer.com/v1/getmarkets/usa', 'https://api.bitflyer.com/v1/getmarkets']\n        for endpoint in endpoints:\n            <IND>r = requests.get(endpoint)\n            for entry in r.json():\n                <IND>normalized = entry['product_code'].replace(\"_\", SYMBOL_SEP)\n                ret[normalized] = entry['product_code']\n        <DED><DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BITFLYER', why, {endpoint: r})\n\n\n<DED><DED>def bybit_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.bybit.com/v2/public/symbols')\n        ret = {}\n        for symbol in r.json()['result']:\n            <IND>quote = symbol['quote_currency']\n            if not symbol['name'].endswith(quote):\n                <IND>base, contract = symbol['name'].split(quote)\n                normalized = f\"{base}{SYMBOL_SEP}{quote}-{contract}\"\n            <DED>else:\n                <IND>normalized = f\"{symbol['base_currency']}{SYMBOL_SEP}{quote}\"\n            <DED>ret[normalized] = symbol['name']\n            _exchange_info[BYBIT]['tick_size'][normalized] = symbol['price_filter']['tick_size']\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BYBIT', why, {\"\": r})\n\n\n<DED><DED>def _ftx_helper(endpoint: str, exchange: str):\n    <IND>r = None\n    try:\n        <IND>r = requests.get(endpoint)\n        ret = {}\n        for data in r.json()['result']:\n            <IND>normalized = data['name'].replace(\"/\", SYMBOL_SEP)\n            symbol = data['name']\n            ret[normalized] = symbol\n            _exchange_info[exchange]['tick_size'][normalized] = data['priceIncrement']\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation(exchange, why, {endpoint: r})\n\n\n<DED><DED>def ftx_symbols() -> Dict[str, str]:\n    <IND>return _ftx_helper('https://ftx.com/api/markets', FTX)\n\n\n<DED>def ftx_us_symbols() -> Dict[str, str]:\n    <IND>return _ftx_helper('https://ftx.us/api/markets', FTX_US)\n\n\n<DED>def coinbase_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.pro.coinbase.com/products')\n        ret = {}\n        for data in r.json():\n            <IND>normalized = data['id'].replace(\"-\", SYMBOL_SEP)\n            ret[normalized] = data['id']\n            _exchange_info[COINBASE]['tick_size'][normalized] = data['quote_increment']\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('COINBASE', why, {\"\": r})\n\n\n<DED><DED>def gemini_symbols(*args) -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.gemini.com/v1/symbols')\n        ret = {}\n        for symbol in r.json():\n            <IND>std = f\"{symbol[:-3]}{SYMBOL_SEP}{symbol[-3:]}\"\n            std = std.upper()\n            ret[std] = symbol.upper()\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('GEMINI', why, {\"\": r})\n\n\n<DED><DED>def hitbtc_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>ret = {}\n        r = requests.get('https://api.hitbtc.com/api/2/public/symbol')\n        for symbol in r.json():\n            <IND>split = len(symbol['baseCurrency'])\n            normalized = symbol['id'][:split] + SYMBOL_SEP + symbol['id'][split:]\n            ret[normalized] = symbol['id']\n            _exchange_info[HITBTC]['tick_size'][normalized] = symbol['tickSize']\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('HITBTC', why, {\"\": r})\n\n\n<DED><DED>def poloniex_id_symbol_mapping():\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://poloniex.com/public?command=returnTicker')\n        symbols = r.json()\n        ret = {}\n        for symbol in symbols:\n            <IND>ret[symbols[symbol]['id']] = symbol\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('POLONIEX', why, {\"\": r})\n\n\n<DED><DED>def poloniex_symbols() -> Dict[str, str]:\n    <IND>ret = {}\n    for _, value in poloniex_id_symbol_mapping().items():\n        <IND>std = value.replace(\"STR\", \"XLM\")\n        quote, base = std.split(\"_\")\n        ret[quote + SYMBOL_SEP + base] = value\n    <DED>return ret\n\n\n<DED>def bitstamp_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://www.bitstamp.net/api/v2/trading-pairs-info/')\n        ret = {}\n        for data in r.json():\n            <IND>normalized = data['name'].replace(\"/\", SYMBOL_SEP)\n            symbol = data['url_symbol']\n            ret[normalized] = symbol\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BITSTAMP', why, {\"\": r})\n\n\n<DED><DED>def kraken_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.kraken.com/0/public/AssetPairs')\n        data = r.json()\n        ret = {}\n        for symbol in data['result']:\n            <IND>if 'wsname' not in data['result'][symbol] or '.d' in symbol:\n                # https://blog.kraken.com/post/259/introducing-the-kraken-dark-pool/\n                # .d is for dark pool symbols\n                <IND>continue\n\n            <DED>base, quote = data['result'][symbol]['wsname'].split(\"/\")\n\n            normalized = f\"{base}{SYMBOL_SEP}{quote}\"\n            exch = data['result'][symbol]['wsname']\n            normalized = normalized.replace('XBT', 'BTC')\n            normalized = normalized.replace('XDG', 'DOG')\n            ret[normalized] = exch\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('KRAKEN', why, {\"\": r})\n\n\n<DED><DED>def kraken_rest_symbols() -> Dict[str, str]:\n    <IND>return {normalized: exchange.replace(\"/\", \"\") for normalized, exchange in kraken_symbols().items()}\n\n\n<DED>def exx_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.exx.com/data/v1/tickers')\n        exchange = [key.upper() for key in r.json().keys()]\n        symbols = [key.replace(\"_\", SYMBOL_SEP) for key in exchange]\n        return dict(zip(symbols, exchange))\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('EXX', why, {\"\": r})\n\n\n<DED><DED>def huobi_common_symbols(url: str):\n    <IND>r = None\n    try:\n        <IND>r = requests.get(url)\n        ret = {}\n        for e in r.json()['data']:\n            <IND>if e['state'] == 'offline':\n                <IND>continue\n            <DED>normalized = f\"{e['base-currency'].upper()}{SYMBOL_SEP}{e['quote-currency'].upper()}\"\n            symbol = f\"{e['base-currency']}{e['quote-currency']}\"\n            ret[normalized] = symbol\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('HUOBI', why, {url: r})\n\n\n<DED><DED>def huobi_symbols() -> Dict[str, str]:\n    <IND>return huobi_common_symbols('https://api.huobi.pro/v1/common/symbols')\n\n\n<DED>def huobi_us_symbols() -> Dict[str, str]:\n    <IND>return huobi_common_symbols('https://api.huobi.com/v1/common/symbols')\n\n\n<DED>def huobi_dm_symbols() -> Dict[str, str]:\n    <IND>\"\"\"\n    Mapping is, for instance: {\"BTC_CW\":\"BTC190816\"}\n    See comments in exchange/huobi_dm.py\n    \"\"\"\n    mapping = {\n        \"this_week\": \"CW\",\n        \"next_week\": \"NW\",\n        \"quarter\": \"CQ\",\n        \"next_quarter\": \"NQ\"\n    }\n    r = None\n    try:\n        <IND>r = requests.get('https://www.hbdm.com/api/v1/contract_contract_info')\n        symbols = {}\n        for e in r.json()['data']:\n            <IND>symbols[f\"{e['symbol']}_{mapping[e['contract_type']]}\"] = e['contract_code']\n            _exchange_info[HUOBI_DM]['tick_size'][e['contract_code']] = e['price_tick']\n            _exchange_info[HUOBI_DM]['short_code_mappings'][f\"{e['symbol']}_{mapping[e['contract_type']]}\"] = e['contract_code']\n        <DED>return symbols\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('HUOBI_DM', why, {\"\": r})\n\n\n<DED><DED>def huobi_swap_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.hbdm.com/swap-api/v1/swap_contract_info')\n        symbols = {}\n        for e in r.json()['data']:\n            <IND>symbols[e['contract_code']] = e['contract_code']\n            _exchange_info[HUOBI_SWAP]['tick_size'][e['contract_code']] = e['price_tick']\n        <DED>return symbols\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('HUOBI_SWAP', why, {\"\": r})\n\n\n<DED><DED>def okcoin_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://www.okcoin.com/api/spot/v3/instruments')\n        ret = {}\n        for e in r.json():\n            <IND>ret[e['instrument_id']] = e['instrument_id']\n            _exchange_info[OKCOIN]['tick_size'][e['instrument_id']] = e['tick_size']\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('OKCOIN', why, {\"\": r})\n\n\n<DED><DED>def okex_symbols(*args) -> Dict[str, str]:\n    <IND>urls = ['https://www.okex.com/api/spot/v3/instruments',\n            'https://www.okex.com/api/swap/v3/instruments',\n            'https://www.okex.com/api/futures/v3/instruments']\n    urls = urls + okex_compute_option_urls_from_underlyings()\n\n    symbols: Dict[str, str] = {}\n    for u in urls:\n        <IND>time.sleep(0.2)\n        symbols.update(okex_symbols_from_one_url(u))\n\n    <DED>for symbol in symbols:\n        <IND>instrument_type = 'futures'\n        dash_count = symbol.count(get_symbol_separator())\n        if dash_count == 1:  # BTC-USDT\n            <IND>instrument_type = 'spot'\n        <DED>if dash_count == 4:  # BTC-USD-201225-35000-P\n            <IND>instrument_type = 'option'\n        <DED>if symbol[-4:] == \"SWAP\":  # BTC-USDT-SWAP\n            <IND>instrument_type = 'swap'\n\n        <DED>_exchange_info[OKEX]['instrument_type'][symbol] = instrument_type\n\n    <DED>return symbols\n\n\n<DED>def okex_compute_option_urls_from_underlyings() -> List[str]:\n    <IND>url = 'https://www.okex.com/api/option/v3/underlying'\n    r = None\n    try:\n        <IND>r = requests.get(url)\n        return [f'https://www.okex.com/api/option/v3/instruments/{underlying}' for underlying in r.json()]\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('OKEX', why, {url: r})\n\n\n<DED><DED>def okex_symbols_from_one_url(url: str) -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get(url)\n        ret = {}\n        for e in r.json():\n            <IND>ret[e['instrument_id']] = e['instrument_id']\n            _exchange_info[OKEX]['tick_size'][e['instrument_id']] = e['tick_size']\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('OKEX', why, {url: r})\n\n\n<DED><DED>def bittrex_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.bittrex.com/api/v1.1/public/getmarkets')\n        r = r.json()['result']\n        return {f\"{e['MarketCurrency']}{SYMBOL_SEP}{e['BaseCurrency']}\": e['MarketName'] for e in r if e['IsActive']}\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BITTREX', why, {\"\": r})\n\n\n<DED><DED>def bitcoincom_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.exchange.bitcoin.com/api/2/public/symbol')\n        return {f\"{data['baseCurrency']}{SYMBOL_SEP}{data['quoteCurrency'].replace('USD', 'USDT')}\": data['id'] for data in r.json()}\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BITCOINCOM', why, {\"\": r})\n\n\n<DED><DED>def bitmax_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://bitmax.io/api/pro/v1/products')\n        ret = {}\n        for entry in r.json()['data']:\n            # Only \"Normal\" status symbols are tradeable\n            <IND>if entry['status'] == 'Normal':\n                <IND>normalized = f\"{entry['baseAsset']}{SYMBOL_SEP}{entry['quoteAsset']}\"\n                ret[normalized] = entry['symbol']\n                _exchange_info[BITMAX]['tick_size'][normalized] = entry['tickSize']\n        <DED><DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BITMAX', why, {\"\": r})\n\n\n<DED><DED>def upbit_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.upbit.com/v1/market/all')\n        return {f\"{data['market'].split('-')[1]}{SYMBOL_SEP}{data['market'].split('-')[0]}\": data['market'] for data in r.json()}\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('UPBIT', why, {\"\": r})\n\n\n<DED><DED>def blockchain_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get(\"https://api.blockchain.com/mercury-gateway/v1/instruments\")\n        return {data[\"symbol\"].replace(\"-\", SYMBOL_SEP): data[\"symbol\"] for data in r.json()}\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BLOCKCHAIN', why, {\"\": r})\n\n\n<DED><DED>def gateio_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get(\"https://api.gateio.ws/api/v4/spot/currency_pairs\")\n        return {data[\"id\"].replace(\"_\", SYMBOL_SEP): data['id'] for data in r.json()}\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('GATEIO', why, {\"\": r})\n\n\n<DED><DED>def bitmex_symbols() -> Dict[str, str]:\n    <IND>r = None\n    ret = {}\n    try:\n        <IND>r = requests.get(\"https://www.bitmex.com/api/v1/instrument/active\")\n        for entry in r.json():\n            <IND>components = []\n            components.append(entry['rootSymbol'])\n            components.append(entry['quoteCurrency'])\n\n            if entry['expiry']:\n                <IND>components.append(entry['symbol'][-3:])\n\n            <DED>normalized = SYMBOL_SEP.join(components)\n            normalized = normalized.replace(\"XBT\", \"BTC\")\n            ret[normalized] = entry['symbol']\n            _exchange_info[BITMEX]['tick_size'][normalized] = entry['tickSize']\n\n            if entry['expiry']:\n                <IND>_exchange_info[BITMEX]['expiry'][normalized] = entry['expiry']\n\n        <DED><DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BITMEX', why, {\"\": r})\n\n\n<DED><DED>def deribit_symbols() -> Dict[str, str]:\n    <IND>url = r = None\n    ret = {}\n    try:\n        # TODO: get currencies from https://www.deribit.com/api/v2/public/get_currencies\n        <IND>currencies = ['BTC', 'ETH']\n        for c in currencies:\n            <IND>url = f\"https://www.deribit.com/api/v2/public/get_instruments?currency={c}&expired=false\"\n            r = requests.get(url)\n            for entry in r.json()['result']:\n                <IND>split = entry['instrument_name'].split(\"-\")\n                normalized = split[0] + SYMBOL_SEP + entry['quote_currency'] + \"-\" + '-'.join(split[1:])\n                ret[normalized] = entry['instrument_name']\n                _exchange_info[DERIBIT]['tick_size'][normalized] = entry['tick_size']\n        <DED><DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('DERIBIT', why, {url: r})\n\n\n<DED><DED>def kraken_future_symbols() -> Dict[str, str]:\n    <IND>r = None\n    ret = {}\n    try:\n        <IND>r = requests.get('https://futures.kraken.com/derivatives/api/v3/instruments')\n        data = r.json()['instruments']\n        for entry in data:\n            <IND>if not entry['tradeable']:\n                <IND>continue\n            <DED>normalized = entry['symbol'].upper().replace(\"_\", \"-\")\n            symbol = normalized[3:6] + SYMBOL_SEP + normalized[6:9]\n            normalized = normalized.replace(normalized[3:9], symbol)\n            normalized = normalized.replace('XBT', 'BTC')\n\n            _exchange_info[KRAKEN_FUTURES]['tick_size'][normalized] = entry['tickSize']\n            _exchange_info[KRAKEN_FUTURES]['contract_size'][normalized] = entry['contractSize']\n            _exchange_info[KRAKEN_FUTURES]['underlying'][normalized] = entry['underlying']\n            _exchange_info[KRAKEN_FUTURES]['product_type'][normalized] = _kraken_futures_product_type[normalized[:2]]\n            ret[normalized] = entry['symbol']\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('KRAKEN_FUTURES', why, {\"\": r})\n\n\n<DED><DED>def probit_symbols() -> Dict[str, str]:\n    # doc: https://docs-en.probit.com/reference-link/market\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.probit.com/api/exchange/v1/market')\n        return {entry['id']: entry['id'] for entry in r.json()['data']}\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('PROBIT', why, {\"\": r})\n\n\n<DED><DED>def coingecko_normalize_symbol(symbol: str) -> str:\n    # keep digits, letters and dots, replace others by space\n    <IND>symbol = ''.join(c if c.isalnum() or c in ('.', '+') else ' ' for c in symbol)\n    return coingecko_normalize(symbol.upper())\n\n\n<DED>def coingecko_normalize_name(name: str) -> str:\n    # keep digits and letters, replace others by space (except when only composed by upper case letters, digits and dots)\n    <IND>if not all(c.isupper() or c.isdigit() or c == '.' for c in name):\n        <IND>name = ''.join(c if c.isalnum() else ' ' for c in name)\n    <DED>return coingecko_normalize(name)\n\n\n<DED>def coingecko_normalize(sym: str) -> str:\n    <IND>sym = sym.strip()\n    # do not concatenate numbers => separate them with a dot\n    sym = list(sym)\n    if len(sym) > 4:\n        <IND>for i in range(2, len(sym) - 1):\n            <IND>if sym[i] == ' ' and sym[i - 1].isdigit() and sym[i + 1].isdigit():\n                <IND>sym[i] = '.'\n    <DED><DED><DED>sym = ''.join(sym)\n    # concatenate space-separated words => use CamelCase to distinguish the words\n    if ' ' in sym:\n        <IND>if sum(c.islower() for c in sym):  # if there is at least one lower case letter\n            <IND>sym = ' '.join(word[0].upper() + word[1:] for word in sym.split())  # Just capitalize initial letter of each word\n        <DED>else:  # CoinGecko may provide full upper-case as for \"THE STONE COIN\"\n            <IND>sym = string.capwords(sym)  # capwords converts \"THE STONE COIN\" to \"The Stone Coin\"\n        <DED>sym = sym.replace(' ', '')  # concatenate words\n    <DED>return sym\n\n\n<DED>def is_name_short(coin: dict) -> bool:\n    <IND>\"\"\"return True if the coin name is enough short compared to the coin symbol.\"\"\"\n    return len(coin['name']) <= max(5, len(coin['symbol']) + 1)\n\n\n<DED>def has_many_caps(name: str) -> bool:\n    <IND>\"\"\"return True if the symbol contains enough upper case letters, False if empty.\"\"\"\n    return str and sum(c.islower() for c in name) < (len(name) / 2)\n\n\n<DED>def coingecko_normalize_all(coin: dict):\n    <IND>SYMBOL_TO_NORMALIZED = {'miota': 'IOTA'}\n    normalized = SYMBOL_TO_NORMALIZED.get(coin['symbol'])\n    if normalized:\n        <IND>coin['ns'] = coin['nn'] = normalized\n        return normalized\n\n    # ns = normalized symbol, nn = normalized name\n    <DED>coin['ns'] = coingecko_normalize_symbol(coin['symbol'])\n\n    ID_SUFFIX = '-bitcoin-token'\n    if coin['id'][-len(ID_SUFFIX):] == ID_SUFFIX:\n        <IND>coin['nn'] = 'BTC' + coin['ns']\n        return coin['nn']\n\n    <DED>name = coin['name']\n\n    prefixes = ('The ', 'the ')\n    for p in prefixes:\n        <IND>if name[:len(p)] == p:\n            <IND>coin['reduced-name'] = True\n            name = name[len(p):]\n            break\n\n    <DED><DED>suffixes = ('coin', 'coins', 'money', 'finance', 'protocol', 'reward', 'rewards', 'token')\n    for s in suffixes:\n        <IND>if len(name) > len(s) and name[-len(s):].lower() == s:\n            # but keep suffix when lower-case concatenated\n            <IND>if name[-len(s)].islower() and name[-len(s) - 1] != ' ':\n                <IND>continue\n            # also keep suffix to avoid confusing nam: \"Bitcoin Token\" -> \"Bitcoin\"\n            <DED>if name[:-len(s)].strip().lower() == 'bitcoin':\n                <IND>continue\n            <DED>coin['reduced-name'] = True\n            name = name[:-len(s)]\n            break\n\n    <DED><DED>coin['nn'] = coingecko_normalize_name(name)\n\n    if len(coin['nn']) < len(coin['ns']):\n        <IND>if 'reduced-name' in coin:\n            <IND>coin['reduced-name'] = False\n            name = coin['name']\n            coin['nn'] = coingecko_normalize_name(name)\n        <DED>elif not has_many_caps(name):\n            <IND>return coin['ns']\n\n    <DED><DED>if not coin['ns']:  # coin['symbol'] may be an emoji that is striped when normalized\n        <IND>return coin['nn']\n\n    <DED>if coin.get('reduced-name') and coin['ns'].upper() != coin['nn'].upper():\n        <IND>return coin['ns']\n\n    <DED>i = coin['nn'].find('.')  # if there is a dot in normalized name => prefer the normalized symbol\n    if i >= 0:\n        <IND>if i > 1 and coin['nn'][i - 1].isdigit() and coin['nn'][i + 1].isdigit():\n            <IND>pass  # except when the dot separates digits\n        <DED>else:\n            <IND>return coin['ns']\n\n    <DED><DED>if is_name_short(coin) and has_many_caps(name):\n        <IND>return coin['nn']\n\n    <DED>if 1.5 * len(coin['ns']) > len(coin['nn']) and any(c.islower() for c in coin['ns']):\n        <IND>return coin['nn']\n\n    <DED>return coin['ns']\n\n\n<DED>def coingecko_symbols() -> Dict[str, str]:\n    <IND>r = None\n    intermediate = defaultdict(list)\n    try:\n        <IND>r = requests.get('https://api.coingecko.com/api/v3/coins/list')\n        all_coins = r.json()\n        # First pass: generate & compare normalized symbol/name, and then select the most pertinent\n        for coin in all_coins:\n            <IND>normalized = coingecko_normalize_all(coin)\n            intermediate[normalized].append(coin)\n            # Above line keeps together the coins having the same normalized symbol.\n            # To reduce collision, the coin['name'] is sometimes used in lieu of the coin['symbol'].\n            # The coin['name'] is not capitalized because lower case letters may be meaningful: cETH, yUSD, DATx, zLOT\n    <DED><DED>except Exception as why:\n        <IND>raise_failure_explanation('COINGECKO', why, {\"\": r})\n\n    <DED>final = coingecko_second_pass(intermediate)\n    return coingecko_third_pass(final)\n\n\n<DED>def coingecko_second_pass(intermediate: Dict[str, List[dict]]) -> Dict[str, List[dict]]:\n    # Second pass: fixes most of the symbol collisions\n    <IND>final = defaultdict(list)\n    for normalized, coins in intermediate.items():\n        <IND>if len(coins) == 1:\n            <IND>final[normalized].append(coins[0])\n            continue\n        <DED>set_normalized = False\n        for i in range(len(coins)):\n            <IND>if normalized == coins[i]['nn']:\n                <IND>coin = coins.pop(i)\n                final[normalized].append(coin)\n                set_normalized = True\n                break\n        <DED><DED>rest: List[dict] = []\n        for coin in coins:\n            <IND>if '%' in coin['name']:\n                <IND>if len(coins) == 1:\n                    <IND>n = coin['ns']\n                <DED>else:\n                    <IND>n = coingecko_normalize_name(coin['id'])\n                <DED>final[n].append(coin)\n            <DED>else:\n                <IND>rest.append(coin)\n        <DED><DED>if not rest:\n            <IND>continue\n        <DED>if not set_normalized:\n            <IND>rest.sort(key=lambda coin: len(coin['nn']), reverse=True)  # sort by the length of the normalized name\n            coin = rest.pop(0)\n            final[normalized].append(coin)\n        <DED>for coin in rest:\n            <IND>if coin['nn'] not in intermediate:\n                <IND>n = coin['nn']\n            <DED>elif coin.get('reduced-name'):\n                <IND>n = coingecko_normalize_name(coin['name'])\n            <DED>else:\n                <IND>n = coingecko_normalize_name(coin['id'])\n            <DED>final[n].append(coin)\n    <DED><DED>return final\n\n\n<DED>def coingecko_third_pass(final: Dict[str, List[dict]]) -> Dict[str, str]:\n    # Third pass: fixes some remaining collisions and fills the result\n    <IND>symbols = {}\n    for normalized, coins in final.items():\n        <IND>if len(coins) == 1:\n            <IND>symbols[normalized] = coins[0]['id']\n            continue\n        <DED>set_normalized = False\n        for i in range(len(coins)):\n            <IND>if normalized == coins[i]['nn']:\n                <IND>coin = coins.pop(i)\n                symbols[normalized] = coin['id']\n                set_normalized = True\n                break\n        <DED><DED>rest: List[dict] = []\n        for coin in coins:\n            <IND>if '%' in coin['name']:\n                <IND>if len(coins) == 1:\n                    <IND>n = coin['ns']\n                <DED>else:\n                    <IND>n = coingecko_normalize_name(coin['id'])\n                <DED>symbols[n] = coin['id']\n            <DED>else:\n                <IND>rest.append(coin)\n        <DED><DED>if not rest:\n            <IND>continue\n        <DED>if not set_normalized:\n            <IND>rest.sort(key=lambda coin: len(coin['nn']), reverse=True)  # sort by the length of the normalized name\n            coin = rest.pop(0)\n            symbols[normalized] = coin['id']\n        <DED>for coin in rest:\n            <IND>if coin['nn'] not in final:\n                <IND>n = coin['nn']\n            <DED>elif coin.get('reduced-name'):\n                <IND>n = coingecko_normalize_name(coin['name'])\n            <DED>else:\n                <IND>n = coingecko_normalize_name(coin['id'])\n            <DED>symbols[n] = coin['id']\n    <DED><DED>return symbols\n\n\n<DED>def whale_alert_coins(key_id: str) -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get(f'https://api.whale-alert.io/v1/status?api_key={key_id}')\n        # Same symbols, but on different blockchains (for instance USDT), are naturally overwritten.\n        return {s.upper(): s for b in r.json()['blockchains'] for s in b['symbols'] if s}\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('WHALES_ALERT', why, {\"\": r})\n\n\n<DED><DED>_exchange_function_map = {\n    BITFINEX: bitfinex_symbols,\n    BITFLYER: bitflyer_symbols,\n    COINBASE: coinbase_symbols,\n    GEMINI: gemini_symbols,\n    HITBTC: hitbtc_symbols,\n    POLONIEX: poloniex_symbols,\n    PROBIT: probit_symbols,\n    BITSTAMP: bitstamp_symbols,\n    KRAKEN: kraken_symbols,\n    KRAKEN + 'REST': kraken_rest_symbols,\n    BINANCE: binance_symbols,\n    BINANCE_US: binance_us_symbols,\n    BINANCE_FUTURES: binance_futures_symbols,\n    BINANCE_DELIVERY: binance_delivery_symbols,\n    BLOCKCHAIN: blockchain_symbols,\n    EXX: exx_symbols,\n    HUOBI: huobi_symbols,\n    HUOBI_DM: huobi_dm_symbols,\n    HUOBI_SWAP: huobi_swap_symbols,\n    OKCOIN: okcoin_symbols,\n    OKEX: okex_symbols,\n    BYBIT: bybit_symbols,\n    FTX: ftx_symbols,\n    FTX_US: ftx_us_symbols,\n    BITTREX: bittrex_symbols,\n    BITCOINCOM: bitcoincom_symbols,\n    BITMAX: bitmax_symbols,\n    UPBIT: upbit_symbols,\n    GATEIO: gateio_symbols,\n    BITMEX: bitmex_symbols,\n    DERIBIT: deribit_symbols,\n    KRAKEN_FUTURES: kraken_future_symbols,\n    COINGECKO: coingecko_symbols,\n    WHALE_ALERT: whale_alert_coins\n}\n",
        "target_code_with_indent": "\nfrom typing import Dict, Tuple\n\n\nclass _Symbols:\n    <IND>def __init__(self):\n        <IND>self.data = {}\n\n    <DED>def set(self, exchange: str, normalized: dict, exchange_info: dict):\n        <IND>self.data[exchange] = {}\n        self.data[exchange]['normalized'] = normalized\n        self.data[exchange]['info'] = exchange_info\n\n    <DED>def get(self, exchange: str) -> Tuple[Dict, Dict]:\n        <IND>return self.data[exchange]['normalized'], self.data[exchange]['info']\n\n    <DED>def populated(self, exchange: str) -> bool:\n        <IND>return exchange in self.data\n\n\n<DED><DED>Symbols = _Symbols()\n"
      }
    ]
  },
  {
    "project": "bmoscon/cryptofeed",
    "commit": "3525dc8ce4d7836a9abaaa5662e58e5e27969a77",
    "filename": "cryptofeed/symbols.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/bmoscon-cryptofeed/cryptofeed/symbols.py",
    "file_hunks_size": 1,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "cryptofeed/symbols.py:457:8 Incompatible return type [7]: Expected `Dict[str, str]` but got implicit return value of `None`.",
    "message": " Expected `Dict[str, str]` but got implicit return value of `None`.",
    "rule_id": "Incompatible return type [7]",
    "warning_line_no": 457,
    "warning_line": "        raise_failure_explanation('BITTREX', why, {\"\": r})",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "associated with this software.\n\n\nSymbol generation code for exchanges\n'''\n\nimport logging\nimport string\nimport time\nfrom collections import defaultdict\nfrom typing import Dict, List, Optional, Tuple\n\nimport requests\nfrom requests import Response\n\nfrom cryptofeed.defines import *\n\n\nLOG = logging.getLogger('feedhandler')\n\nSYMBOL_SEP = '-'\n\n_symbols_retrieval_cache: Dict[str, Dict[str, str]] = {}\n_exchange_info = defaultdict(lambda: defaultdict(dict))\n\n\n_kraken_futures_product_type = {\n    'FI': 'Inverse Futures',\n    'FV': 'Vanilla Futures',\n    'PI': 'Perpetual Inverse Futures',\n    'PV': 'Perpetual Vanilla Futures',\n    'IN': 'Real Time Index',\n    'RR': 'Reference Rate',\n}\n\n\ndef raise_failure_explanation(feed_id: str, exception: BaseException, responses: Dict[str, Optional[Response]]):\n    LOG.critical('%s: encountered %r while processing response from exchange API', feed_id, exception)\n    if len(responses) > 1:\n        LOG.critical('%s: content of one of the %s responses was unexpected', feed_id, len(responses))\n    for url, r in responses.items():\n        if url:\n            LOG.critical('%s: requested URL: %s', feed_id, url)\n        if r:\n            LOG.critical('%s: unexpected response: %s', feed_id, r.text)\n    raise ValueError(f'Cryptofeed stopped because of an unexpected response from {feed_id}') from exception\n\n\ndef set_symbol_separator(separator: str):\n    global SYMBOL_SEP\n    SYMBOL_SEP = separator\n\n\ndef get_symbol_separator() -> str:\n    global SYMBOL_SEP\n    return SYMBOL_SEP\n\n\ndef gen_symbols(exchange: str, key_id=None) -> Dict[str, str]:\n    if exchange not in _symbols_retrieval_cache:\n        LOG.info(\"%s: Getting list of symbols\", exchange)\n        symbols = _exchange_function_map[exchange](key_id) if key_id else _exchange_function_map[exchange]()\n        LOG.info(\"%s: %s symbols\", exchange, len(symbols))\n\n        # log all retrieved symbols using debug level\n        for normalized, exch_sym in sorted(symbols.items()):\n            LOG.debug('%s: id-from-exch -> normalized: %-35s-> %s', exchange, exch_sym, normalized)\n\n        _symbols_retrieval_cache[exchange] = symbols\n    return _symbols_retrieval_cache[exchange]\n\n\ndef _binance_symbols(endpoint: str, exchange: str):\n    r = None\n    try:\n        ret = {}\n        r = requests.get(endpoint)\n        for symbol in r.json()['symbols']:\n            if symbol.get('status', 'TRADING') != \"TRADING\":\n                continue\n            if symbol.get('contractStatus', 'TRADING') != \"TRADING\":\n                continue\n            split = len(symbol['baseAsset'])\n            normalized = symbol['symbol'][:split] + SYMBOL_SEP + symbol['symbol'][split:]\n            ret[normalized] = symbol['symbol']\n            _exchange_info[exchange]['tick_size'][normalized] = symbol['filters'][0]['tickSize']\n            if \"contractType\" in symbol:\n                _exchange_info[exchange]['contract_type'][normalized] = symbol['contractType']\n        return ret\n    except Exception as why:\n        raise_failure_explanation(exchange, why, {endpoint: r})\n\n\ndef binance_symbols() -> Dict[str, str]:\n    return _binance_symbols('https://api.binance.com/api/v3/exchangeInfo', BINANCE)\n\n\ndef binance_us_symbols() -> Dict[str, str]:\n    return _binance_symbols('https://api.binance.us/api/v3/exchangeInfo', BINANCE_US)\n\n\ndef binance_futures_symbols() -> Dict[str, str]:\n    base = _binance_symbols('https://fapi.binance.com/fapi/v1/exchangeInfo', BINANCE_FUTURES)\n    add = {}\n    for symbol, orig in base.items():\n        if \"_\" in orig:\n            continue\n        add[f\"{symbol}-PINDEX\"] = f\"p{orig}\"\n    base.update(add)\n    return base\n\n\ndef binance_delivery_symbols() -> Dict[str, str]:\n    return _binance_symbols('https://dapi.binance.com/dapi/v1/exchangeInfo', BINANCE_DELIVERY)\n\n\ndef bitfinex_symbols() -> Dict[str, str]:\n    # doc: https://docs.bitfinex.com/docs/ws-general#supported-pairs\n    r1 = r2 = None\n    try:\n        r1 = requests.get('https://api.bitfinex.com/v2/tickers?symbols=ALL')\n        r2 = requests.get('https://api-pub.bitfinex.com/v2/conf/pub:map:currency:sym')\n        tickers: List[List[str]] = r1.json()\n        norm: List[Tuple[str, str]] = r2.json()[0]\n        norm: Dict[str, str] = dict(norm)\n        for k, v in dict(norm).items():\n            if k[-2:] == 'F0' or '-' in v:  # Do not convert BTCF0 -> BTC or PBTCETH -> PBTC-ETH\n                del norm[k]\n        norm['BCHN'] = 'BCH'  # Bitfinex uses BCHN, other exchanges use BCH\n\n        ret = {}\n        for symbol in [t[0] for t in tickers]:\n            if symbol[0] == 'f':\n                normalized = norm.get(symbol[1:], symbol[1:])\n            else:\n                if len(symbol) == 7:\n                    base, quote = symbol[1:4], symbol[4:]\n                else:\n                    base, quote = symbol[1:].split(':')\n                    assert ':' in symbol\n                normalized = norm.get(base, base) + SYMBOL_SEP + norm.get(quote, quote)\n            ret[normalized.upper()] = symbol\n        return ret\n    except ValueError as why:\n        raise_failure_explanation('BITFINEX', why, {\"tickers?symbols=ALL\": r1, \"pub:map:currency:sym\": r2})\n\n\ndef bitflyer_symbols() -> Dict[str, str]:\n    endpoint = r = None\n    try:\n        ret = {}\n        endpoints = ['https://api.bitflyer.com/v1/getmarkets/eu', 'https://api.bitflyer.com/v1/getmarkets/usa', 'https://api.bitflyer.com/v1/getmarkets']\n        for endpoint in endpoints:\n            r = requests.get(endpoint)\n            for entry in r.json():\n                normalized = entry['product_code'].replace(\"_\", SYMBOL_SEP)\n                ret[normalized] = entry['product_code']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('BITFLYER', why, {endpoint: r})\n\n\ndef bybit_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.bybit.com/v2/public/symbols')\n        ret = {}\n        for symbol in r.json()['result']:\n            quote = symbol['quote_currency']\n            if not symbol['name'].endswith(quote):\n                base, contract = symbol['name'].split(quote)\n                normalized = f\"{base}{SYMBOL_SEP}{quote}-{contract}\"\n            else:\n                normalized = f\"{symbol['base_currency']}{SYMBOL_SEP}{quote}\"\n            ret[normalized] = symbol['name']\n            _exchange_info[BYBIT]['tick_size'][normalized] = symbol['price_filter']['tick_size']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('BYBIT', why, {\"\": r})\n\n\ndef _ftx_helper(endpoint: str, exchange: str):\n    r = None\n    try:\n        r = requests.get(endpoint)\n        ret = {}\n        for data in r.json()['result']:\n            normalized = data['name'].replace(\"/\", SYMBOL_SEP)\n            symbol = data['name']\n            ret[normalized] = symbol\n            _exchange_info[exchange]['tick_size'][normalized] = data['priceIncrement']\n        return ret\n    except Exception as why:\n        raise_failure_explanation(exchange, why, {endpoint: r})\n\n\ndef ftx_symbols() -> Dict[str, str]:\n    return _ftx_helper('https://ftx.com/api/markets', FTX)\n\n\ndef ftx_us_symbols() -> Dict[str, str]:\n    return _ftx_helper('https://ftx.us/api/markets', FTX_US)\n\n\ndef coinbase_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.pro.coinbase.com/products')\n        ret = {}\n        for data in r.json():\n            normalized = data['id'].replace(\"-\", SYMBOL_SEP)\n            ret[normalized] = data['id']\n            _exchange_info[COINBASE]['tick_size'][normalized] = data['quote_increment']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('COINBASE', why, {\"\": r})\n\n\ndef gemini_symbols(*args) -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.gemini.com/v1/symbols')\n        ret = {}\n        for symbol in r.json():\n            std = f\"{symbol[:-3]}{SYMBOL_SEP}{symbol[-3:]}\"\n            std = std.upper()\n            ret[std] = symbol.upper()\n        return ret\n    except Exception as why:\n        raise_failure_explanation('GEMINI', why, {\"\": r})\n\n\ndef hitbtc_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        ret = {}\n        r = requests.get('https://api.hitbtc.com/api/2/public/symbol')\n        for symbol in r.json():\n            split = len(symbol['baseCurrency'])\n            normalized = symbol['id'][:split] + SYMBOL_SEP + symbol['id'][split:]\n            ret[normalized] = symbol['id']\n            _exchange_info[HITBTC]['tick_size'][normalized] = symbol['tickSize']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('HITBTC', why, {\"\": r})\n\n\ndef poloniex_id_symbol_mapping():\n    r = None\n    try:\n        r = requests.get('https://poloniex.com/public?command=returnTicker')\n        symbols = r.json()\n        ret = {}\n        for symbol in symbols:\n            ret[symbols[symbol]['id']] = symbol\n        return ret\n    except Exception as why:\n        raise_failure_explanation('POLONIEX', why, {\"\": r})\n\n\ndef poloniex_symbols() -> Dict[str, str]:\n    ret = {}\n    for _, value in poloniex_id_symbol_mapping().items():\n        std = value.replace(\"STR\", \"XLM\")\n        quote, base = std.split(\"_\")\n        ret[quote + SYMBOL_SEP + base] = value\n    return ret\n\n\ndef bitstamp_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://www.bitstamp.net/api/v2/trading-pairs-info/')\n        ret = {}\n        for data in r.json():\n            normalized = data['name'].replace(\"/\", SYMBOL_SEP)\n            symbol = data['url_symbol']\n            ret[normalized] = symbol\n        return ret\n    except Exception as why:\n        raise_failure_explanation('BITSTAMP', why, {\"\": r})\n\n\ndef kraken_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.kraken.com/0/public/AssetPairs')\n        data = r.json()\n        ret = {}\n        for symbol in data['result']:\n            if 'wsname' not in data['result'][symbol] or '.d' in symbol:\n                # https://blog.kraken.com/post/259/introducing-the-kraken-dark-pool/\n                # .d is for dark pool symbols\n                continue\n\n            base, quote = data['result'][symbol]['wsname'].split(\"/\")\n\n            normalized = f\"{base}{SYMBOL_SEP}{quote}\"\n            exch = data['result'][symbol]['wsname']\n            normalized = normalized.replace('XBT', 'BTC')\n            normalized = normalized.replace('XDG', 'DOG')\n            ret[normalized] = exch\n        return ret\n    except Exception as why:\n        raise_failure_explanation('KRAKEN', why, {\"\": r})\n\n\ndef kraken_rest_symbols() -> Dict[str, str]:\n    return {normalized: exchange.replace(\"/\", \"\") for normalized, exchange in kraken_symbols().items()}\n\n\ndef exx_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.exx.com/data/v1/tickers')\n        exchange = [key.upper() for key in r.json().keys()]\n        symbols = [key.replace(\"_\", SYMBOL_SEP) for key in exchange]\n        return dict(zip(symbols, exchange))\n    except Exception as why:\n        raise_failure_explanation('EXX', why, {\"\": r})\n\n\ndef huobi_common_symbols(url: str):\n    r = None\n    try:\n        r = requests.get(url)\n        ret = {}\n        for e in r.json()['data']:\n            if e['state'] == 'offline':\n                continue\n            normalized = f\"{e['base-currency'].upper()}{SYMBOL_SEP}{e['quote-currency'].upper()}\"\n            symbol = f\"{e['base-currency']}{e['quote-currency']}\"\n            ret[normalized] = symbol\n        return ret\n    except Exception as why:\n        raise_failure_explanation('HUOBI', why, {url: r})\n\n\ndef huobi_symbols() -> Dict[str, str]:\n    return huobi_common_symbols('https://api.huobi.pro/v1/common/symbols')\n\n\ndef huobi_us_symbols() -> Dict[str, str]:\n    return huobi_common_symbols('https://api.huobi.com/v1/common/symbols')\n\n\ndef huobi_dm_symbols() -> Dict[str, str]:\n    \"\"\"\n    Mapping is, for instance: {\"BTC_CW\":\"BTC190816\"}\n    See comments in exchange/huobi_dm.py\n    \"\"\"\n    mapping = {\n        \"this_week\": \"CW\",\n        \"next_week\": \"NW\",\n        \"quarter\": \"CQ\",\n        \"next_quarter\": \"NQ\"\n    }\n    r = None\n    try:\n        r = requests.get('https://www.hbdm.com/api/v1/contract_contract_info')\n        symbols = {}\n        for e in r.json()['data']:\n            symbols[f\"{e['symbol']}_{mapping[e['contract_type']]}\"] = e['contract_code']\n            _exchange_info[HUOBI_DM]['tick_size'][e['contract_code']] = e['price_tick']\n            _exchange_info[HUOBI_DM]['short_code_mappings'][f\"{e['symbol']}_{mapping[e['contract_type']]}\"] = e['contract_code']\n        return symbols\n    except Exception as why:\n        raise_failure_explanation('HUOBI_DM', why, {\"\": r})\n\n\ndef huobi_swap_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.hbdm.com/swap-api/v1/swap_contract_info')\n        symbols = {}\n        for e in r.json()['data']:\n            symbols[e['contract_code']] = e['contract_code']\n            _exchange_info[HUOBI_SWAP]['tick_size'][e['contract_code']] = e['price_tick']\n        return symbols\n    except Exception as why:\n        raise_failure_explanation('HUOBI_SWAP', why, {\"\": r})\n\n\ndef okcoin_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://www.okcoin.com/api/spot/v3/instruments')\n        ret = {}\n        for e in r.json():\n            ret[e['instrument_id']] = e['instrument_id']\n            _exchange_info[OKCOIN]['tick_size'][e['instrument_id']] = e['tick_size']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('OKCOIN', why, {\"\": r})\n\n\ndef okex_symbols(*args) -> Dict[str, str]:\n    urls = ['https://www.okex.com/api/spot/v3/instruments',\n            'https://www.okex.com/api/swap/v3/instruments',\n            'https://www.okex.com/api/futures/v3/instruments']\n    urls = urls + okex_compute_option_urls_from_underlyings()\n\n    symbols: Dict[str, str] = {}\n    for u in urls:\n        time.sleep(0.2)\n        symbols.update(okex_symbols_from_one_url(u))\n\n    for symbol in symbols:\n        instrument_type = 'futures'\n        dash_count = symbol.count(get_symbol_separator())\n        if dash_count == 1:  # BTC-USDT\n            instrument_type = 'spot'\n        if dash_count == 4:  # BTC-USD-201225-35000-P\n            instrument_type = 'option'\n        if symbol[-4:] == \"SWAP\":  # BTC-USDT-SWAP\n            instrument_type = 'swap'\n\n        _exchange_info[OKEX]['instrument_type'][symbol] = instrument_type\n\n    return symbols\n\n\ndef okex_compute_option_urls_from_underlyings() -> List[str]:\n    url = 'https://www.okex.com/api/option/v3/underlying'\n    r = None\n    try:\n        r = requests.get(url)\n        return [f'https://www.okex.com/api/option/v3/instruments/{underlying}' for underlying in r.json()]\n    except Exception as why:\n        raise_failure_explanation('OKEX', why, {url: r})\n\n\ndef okex_symbols_from_one_url(url: str) -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get(url)\n        ret = {}\n        for e in r.json():\n            ret[e['instrument_id']] = e['instrument_id']\n            _exchange_info[OKEX]['tick_size'][e['instrument_id']] = e['tick_size']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('OKEX', why, {url: r})\n\n\ndef bittrex_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.bittrex.com/api/v1.1/public/getmarkets')\n        r = r.json()['result']\n        return {f\"{e['MarketCurrency']}{SYMBOL_SEP}{e['BaseCurrency']}\": e['MarketName'] for e in r if e['IsActive']}\n    except Exception as why:\n        raise_failure_explanation('BITTREX', why, {\"\": r})\n\n\ndef bitcoincom_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.exchange.bitcoin.com/api/2/public/symbol')\n        return {f\"{data['baseCurrency']}{SYMBOL_SEP}{data['quoteCurrency'].replace('USD', 'USDT')}\": data['id'] for data in r.json()}\n    except Exception as why:\n        raise_failure_explanation('BITCOINCOM', why, {\"\": r})\n\n\ndef bitmax_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://bitmax.io/api/pro/v1/products')\n        ret = {}\n        for entry in r.json()['data']:\n            # Only \"Normal\" status symbols are tradeable\n            if entry['status'] == 'Normal':\n                normalized = f\"{entry['baseAsset']}{SYMBOL_SEP}{entry['quoteAsset']}\"\n                ret[normalized] = entry['symbol']\n                _exchange_info[BITMAX]['tick_size'][normalized] = entry['tickSize']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('BITMAX', why, {\"\": r})\n\n\ndef upbit_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.upbit.com/v1/market/all')\n        return {f\"{data['market'].split('-')[1]}{SYMBOL_SEP}{data['market'].split('-')[0]}\": data['market'] for data in r.json()}\n    except Exception as why:\n        raise_failure_explanation('UPBIT', why, {\"\": r})\n\n\ndef blockchain_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get(\"https://api.blockchain.com/mercury-gateway/v1/instruments\")\n        return {data[\"symbol\"].replace(\"-\", SYMBOL_SEP): data[\"symbol\"] for data in r.json()}\n    except Exception as why:\n        raise_failure_explanation('BLOCKCHAIN', why, {\"\": r})\n\n\ndef gateio_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get(\"https://api.gateio.ws/api/v4/spot/currency_pairs\")\n        return {data[\"id\"].replace(\"_\", SYMBOL_SEP): data['id'] for data in r.json()}\n    except Exception as why:\n        raise_failure_explanation('GATEIO', why, {\"\": r})\n\n\ndef bitmex_symbols() -> Dict[str, str]:\n    r = None\n    ret = {}\n    try:\n        r = requests.get(\"https://www.bitmex.com/api/v1/instrument/active\")\n        for entry in r.json():\n            components = []\n            components.append(entry['rootSymbol'])\n            components.append(entry['quoteCurrency'])\n\n            if entry['expiry']:\n                components.append(entry['symbol'][-3:])\n\n            normalized = SYMBOL_SEP.join(components)\n            normalized = normalized.replace(\"XBT\", \"BTC\")\n            ret[normalized] = entry['symbol']\n            _exchange_info[BITMEX]['tick_size'][normalized] = entry['tickSize']\n\n            if entry['expiry']:\n                _exchange_info[BITMEX]['expiry'][normalized] = entry['expiry']\n\n        return ret\n    except Exception as why:\n        raise_failure_explanation('BITMEX', why, {\"\": r})\n\n\ndef deribit_symbols() -> Dict[str, str]:\n    url = r = None\n    ret = {}\n    try:\n        # TODO: get currencies from https://www.deribit.com/api/v2/public/get_currencies\n        currencies = ['BTC', 'ETH']\n        for c in currencies:\n            url = f\"https://www.deribit.com/api/v2/public/get_instruments?currency={c}&expired=false\"\n            r = requests.get(url)\n            for entry in r.json()['result']:\n                split = entry['instrument_name'].split(\"-\")\n                normalized = split[0] + SYMBOL_SEP + entry['quote_currency'] + \"-\" + '-'.join(split[1:])\n                ret[normalized] = entry['instrument_name']\n                _exchange_info[DERIBIT]['tick_size'][normalized] = entry['tick_size']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('DERIBIT', why, {url: r})\n\n\ndef kraken_future_symbols() -> Dict[str, str]:\n    r = None\n    ret = {}\n    try:\n        r = requests.get('https://futures.kraken.com/derivatives/api/v3/instruments')\n        data = r.json()['instruments']\n        for entry in data:\n            if not entry['tradeable']:\n                continue\n            normalized = entry['symbol'].upper().replace(\"_\", \"-\")\n            symbol = normalized[3:6] + SYMBOL_SEP + normalized[6:9]\n            normalized = normalized.replace(normalized[3:9], symbol)\n            normalized = normalized.replace('XBT', 'BTC')\n\n            _exchange_info[KRAKEN_FUTURES]['tick_size'][normalized] = entry['tickSize']\n            _exchange_info[KRAKEN_FUTURES]['contract_size'][normalized] = entry['contractSize']\n            _exchange_info[KRAKEN_FUTURES]['underlying'][normalized] = entry['underlying']\n            _exchange_info[KRAKEN_FUTURES]['product_type'][normalized] = _kraken_futures_product_type[normalized[:2]]\n            ret[normalized] = entry['symbol']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('KRAKEN_FUTURES', why, {\"\": r})\n\n\ndef probit_symbols() -> Dict[str, str]:\n    # doc: https://docs-en.probit.com/reference-link/market\n    r = None\n    try:\n        r = requests.get('https://api.probit.com/api/exchange/v1/market')\n        return {entry['id']: entry['id'] for entry in r.json()['data']}\n    except Exception as why:\n        raise_failure_explanation('PROBIT', why, {\"\": r})\n\n\ndef coingecko_normalize_symbol(symbol: str) -> str:\n    # keep digits, letters and dots, replace others by space\n    symbol = ''.join(c if c.isalnum() or c in ('.', '+') else ' ' for c in symbol)\n    return coingecko_normalize(symbol.upper())\n\n\ndef coingecko_normalize_name(name: str) -> str:\n    # keep digits and letters, replace others by space (except when only composed by upper case letters, digits and dots)\n    if not all(c.isupper() or c.isdigit() or c == '.' for c in name):\n        name = ''.join(c if c.isalnum() else ' ' for c in name)\n    return coingecko_normalize(name)\n\n\ndef coingecko_normalize(sym: str) -> str:\n    sym = sym.strip()\n    # do not concatenate numbers => separate them with a dot\n    sym = list(sym)\n    if len(sym) > 4:\n        for i in range(2, len(sym) - 1):\n            if sym[i] == ' ' and sym[i - 1].isdigit() and sym[i + 1].isdigit():\n                sym[i] = '.'\n    sym = ''.join(sym)\n    # concatenate space-separated words => use CamelCase to distinguish the words\n    if ' ' in sym:\n        if sum(c.islower() for c in sym):  # if there is at least one lower case letter\n            sym = ' '.join(word[0].upper() + word[1:] for word in sym.split())  # Just capitalize initial letter of each word\n        else:  # CoinGecko may provide full upper-case as for \"THE STONE COIN\"\n            sym = string.capwords(sym)  # capwords converts \"THE STONE COIN\" to \"The Stone Coin\"\n        sym = sym.replace(' ', '')  # concatenate words\n    return sym\n\n\ndef is_name_short(coin: dict) -> bool:\n    \"\"\"return True if the coin name is enough short compared to the coin symbol.\"\"\"\n    return len(coin['name']) <= max(5, len(coin['symbol']) + 1)\n\n\ndef has_many_caps(name: str) -> bool:\n    \"\"\"return True if the symbol contains enough upper case letters, False if empty.\"\"\"\n    return str and sum(c.islower() for c in name) < (len(name) / 2)\n\n\ndef coingecko_normalize_all(coin: dict):\n    SYMBOL_TO_NORMALIZED = {'miota': 'IOTA'}\n    normalized = SYMBOL_TO_NORMALIZED.get(coin['symbol'])\n    if normalized:\n        coin['ns'] = coin['nn'] = normalized\n        return normalized\n\n    # ns = normalized symbol, nn = normalized name\n    coin['ns'] = coingecko_normalize_symbol(coin['symbol'])\n\n    ID_SUFFIX = '-bitcoin-token'\n    if coin['id'][-len(ID_SUFFIX):] == ID_SUFFIX:\n        coin['nn'] = 'BTC' + coin['ns']\n        return coin['nn']\n\n    name = coin['name']\n\n    prefixes = ('The ', 'the ')\n    for p in prefixes:\n        if name[:len(p)] == p:\n            coin['reduced-name'] = True\n            name = name[len(p):]\n            break\n\n    suffixes = ('coin', 'coins', 'money', 'finance', 'protocol', 'reward', 'rewards', 'token')\n    for s in suffixes:\n        if len(name) > len(s) and name[-len(s):].lower() == s:\n            # but keep suffix when lower-case concatenated\n            if name[-len(s)].islower() and name[-len(s) - 1] != ' ':\n                continue\n            # also keep suffix to avoid confusing nam: \"Bitcoin Token\" -> \"Bitcoin\"\n            if name[:-len(s)].strip().lower() == 'bitcoin':\n                continue\n            coin['reduced-name'] = True\n            name = name[:-len(s)]\n            break\n\n    coin['nn'] = coingecko_normalize_name(name)\n\n    if len(coin['nn']) < len(coin['ns']):\n        if 'reduced-name' in coin:\n            coin['reduced-name'] = False\n            name = coin['name']\n            coin['nn'] = coingecko_normalize_name(name)\n        elif not has_many_caps(name):\n            return coin['ns']\n\n    if not coin['ns']:  # coin['symbol'] may be an emoji that is striped when normalized\n        return coin['nn']\n\n    if coin.get('reduced-name') and coin['ns'].upper() != coin['nn'].upper():\n        return coin['ns']\n\n    i = coin['nn'].find('.')  # if there is a dot in normalized name => prefer the normalized symbol\n    if i >= 0:\n        if i > 1 and coin['nn'][i - 1].isdigit() and coin['nn'][i + 1].isdigit():\n            pass  # except when the dot separates digits\n        else:\n            return coin['ns']\n\n    if is_name_short(coin) and has_many_caps(name):\n        return coin['nn']\n\n    if 1.5 * len(coin['ns']) > len(coin['nn']) and any(c.islower() for c in coin['ns']):\n        return coin['nn']\n\n    return coin['ns']\n\n\ndef coingecko_symbols() -> Dict[str, str]:\n    r = None\n    intermediate = defaultdict(list)\n    try:\n        r = requests.get('https://api.coingecko.com/api/v3/coins/list')\n        all_coins = r.json()\n        # First pass: generate & compare normalized symbol/name, and then select the most pertinent\n        for coin in all_coins:\n            normalized = coingecko_normalize_all(coin)\n            intermediate[normalized].append(coin)\n            # Above line keeps together the coins having the same normalized symbol.\n            # To reduce collision, the coin['name'] is sometimes used in lieu of the coin['symbol'].\n            # The coin['name'] is not capitalized because lower case letters may be meaningful: cETH, yUSD, DATx, zLOT\n    except Exception as why:\n        raise_failure_explanation('COINGECKO', why, {\"\": r})\n\n    final = coingecko_second_pass(intermediate)\n    return coingecko_third_pass(final)\n\n\ndef coingecko_second_pass(intermediate: Dict[str, List[dict]]) -> Dict[str, List[dict]]:\n    # Second pass: fixes most of the symbol collisions\n    final = defaultdict(list)\n    for normalized, coins in intermediate.items():\n        if len(coins) == 1:\n            final[normalized].append(coins[0])\n            continue\n        set_normalized = False\n        for i in range(len(coins)):\n            if normalized == coins[i]['nn']:\n                coin = coins.pop(i)\n                final[normalized].append(coin)\n                set_normalized = True\n                break\n        rest: List[dict] = []\n        for coin in coins:\n            if '%' in coin['name']:\n                if len(coins) == 1:\n                    n = coin['ns']\n                else:\n                    n = coingecko_normalize_name(coin['id'])\n                final[n].append(coin)\n            else:\n                rest.append(coin)\n        if not rest:\n            continue\n        if not set_normalized:\n            rest.sort(key=lambda coin: len(coin['nn']), reverse=True)  # sort by the length of the normalized name\n            coin = rest.pop(0)\n            final[normalized].append(coin)\n        for coin in rest:\n            if coin['nn'] not in intermediate:\n                n = coin['nn']\n            elif coin.get('reduced-name'):\n                n = coingecko_normalize_name(coin['name'])\n            else:\n                n = coingecko_normalize_name(coin['id'])\n            final[n].append(coin)\n    return final\n\n\ndef coingecko_third_pass(final: Dict[str, List[dict]]) -> Dict[str, str]:\n    # Third pass: fixes some remaining collisions and fills the result\n    symbols = {}\n    for normalized, coins in final.items():\n        if len(coins) == 1:\n            symbols[normalized] = coins[0]['id']\n            continue\n        set_normalized = False\n        for i in range(len(coins)):\n            if normalized == coins[i]['nn']:\n                coin = coins.pop(i)\n                symbols[normalized] = coin['id']\n                set_normalized = True\n                break\n        rest: List[dict] = []\n        for coin in coins:\n            if '%' in coin['name']:\n                if len(coins) == 1:\n                    n = coin['ns']\n                else:\n                    n = coingecko_normalize_name(coin['id'])\n                symbols[n] = coin['id']\n            else:\n                rest.append(coin)\n        if not rest:\n            continue\n        if not set_normalized:\n            rest.sort(key=lambda coin: len(coin['nn']), reverse=True)  # sort by the length of the normalized name\n            coin = rest.pop(0)\n            symbols[normalized] = coin['id']\n        for coin in rest:\n            if coin['nn'] not in final:\n                n = coin['nn']\n            elif coin.get('reduced-name'):\n                n = coingecko_normalize_name(coin['name'])\n            else:\n                n = coingecko_normalize_name(coin['id'])\n            symbols[n] = coin['id']\n    return symbols\n\n\ndef whale_alert_coins(key_id: str) -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get(f'https://api.whale-alert.io/v1/status?api_key={key_id}')\n        # Same symbols, but on different blockchains (for instance USDT), are naturally overwritten.\n        return {s.upper(): s for b in r.json()['blockchains'] for s in b['symbols'] if s}\n    except Exception as why:\n        raise_failure_explanation('WHALES_ALERT', why, {\"\": r})\n\n\n_exchange_function_map = {\n    BITFINEX: bitfinex_symbols,\n    BITFLYER: bitflyer_symbols,\n    COINBASE: coinbase_symbols,\n    GEMINI: gemini_symbols,\n    HITBTC: hitbtc_symbols,\n    POLONIEX: poloniex_symbols,\n    PROBIT: probit_symbols,\n    BITSTAMP: bitstamp_symbols,\n    KRAKEN: kraken_symbols,\n    KRAKEN + 'REST': kraken_rest_symbols,\n    BINANCE: binance_symbols,\n    BINANCE_US: binance_us_symbols,\n    BINANCE_FUTURES: binance_futures_symbols,\n    BINANCE_DELIVERY: binance_delivery_symbols,\n    BLOCKCHAIN: blockchain_symbols,\n    EXX: exx_symbols,\n    HUOBI: huobi_symbols,\n    HUOBI_DM: huobi_dm_symbols,\n    HUOBI_SWAP: huobi_swap_symbols,\n    OKCOIN: okcoin_symbols,\n    OKEX: okex_symbols,\n    BYBIT: bybit_symbols,\n    FTX: ftx_symbols,\n    FTX_US: ftx_us_symbols,\n    BITTREX: bittrex_symbols,\n    BITCOINCOM: bitcoincom_symbols,\n    BITMAX: bitmax_symbols,\n    UPBIT: upbit_symbols,\n    GATEIO: gateio_symbols,\n    BITMEX: bitmex_symbols,\n    DERIBIT: deribit_symbols,\n    KRAKEN_FUTURES: kraken_future_symbols,\n    COINGECKO: coingecko_symbols,\n    WHALE_ALERT: whale_alert_coins\n}\n",
        "source_code_len": 30534,
        "target_code": "associated with this software.\n'''\nfrom typing import Dict, Tuple\n\n\nclass _Symbols:\n    def __init__(self):\n        self.data = {}\n\n    def set(self, exchange: str, normalized: dict, exchange_info: dict):\n        self.data[exchange] = {}\n        self.data[exchange]['normalized'] = normalized\n        self.data[exchange]['info'] = exchange_info\n\n    def get(self, exchange: str) -> Tuple[Dict, Dict]:\n        return self.data[exchange]['normalized'], self.data[exchange]['info']\n\n    def populated(self, exchange: str) -> bool:\n        return exchange in self.data\n\n\nSymbols = _Symbols()\n",
        "target_code_len": 588,
        "diff_format": "@@ -5,845 +5,22 @@\n associated with this software.\n+'''\n+from typing import Dict, Tuple\n \n \n-Symbol generation code for exchanges\n-'''\n+class _Symbols:\n+    def __init__(self):\n+        self.data = {}\n \n-import logging\n-import string\n-import time\n-from collections import defaultdict\n-from typing import Dict, List, Optional, Tuple\n+    def set(self, exchange: str, normalized: dict, exchange_info: dict):\n+        self.data[exchange] = {}\n+        self.data[exchange]['normalized'] = normalized\n+        self.data[exchange]['info'] = exchange_info\n \n-import requests\n-from requests import Response\n+    def get(self, exchange: str) -> Tuple[Dict, Dict]:\n+        return self.data[exchange]['normalized'], self.data[exchange]['info']\n \n-from cryptofeed.defines import *\n+    def populated(self, exchange: str) -> bool:\n+        return exchange in self.data\n \n \n-LOG = logging.getLogger('feedhandler')\n-\n-SYMBOL_SEP = '-'\n-\n-_symbols_retrieval_cache: Dict[str, Dict[str, str]] = {}\n-_exchange_info = defaultdict(lambda: defaultdict(dict))\n-\n-\n-_kraken_futures_product_type = {\n-    'FI': 'Inverse Futures',\n-    'FV': 'Vanilla Futures',\n-    'PI': 'Perpetual Inverse Futures',\n-    'PV': 'Perpetual Vanilla Futures',\n-    'IN': 'Real Time Index',\n-    'RR': 'Reference Rate',\n-}\n-\n-\n-def raise_failure_explanation(feed_id: str, exception: BaseException, responses: Dict[str, Optional[Response]]):\n-    LOG.critical('%s: encountered %r while processing response from exchange API', feed_id, exception)\n-    if len(responses) > 1:\n-        LOG.critical('%s: content of one of the %s responses was unexpected', feed_id, len(responses))\n-    for url, r in responses.items():\n-        if url:\n-            LOG.critical('%s: requested URL: %s', feed_id, url)\n-        if r:\n-            LOG.critical('%s: unexpected response: %s', feed_id, r.text)\n-    raise ValueError(f'Cryptofeed stopped because of an unexpected response from {feed_id}') from exception\n-\n-\n-def set_symbol_separator(separator: str):\n-    global SYMBOL_SEP\n-    SYMBOL_SEP = separator\n-\n-\n-def get_symbol_separator() -> str:\n-    global SYMBOL_SEP\n-    return SYMBOL_SEP\n-\n-\n-def gen_symbols(exchange: str, key_id=None) -> Dict[str, str]:\n-    if exchange not in _symbols_retrieval_cache:\n-        LOG.info(\"%s: Getting list of symbols\", exchange)\n-        symbols = _exchange_function_map[exchange](key_id) if key_id else _exchange_function_map[exchange]()\n-        LOG.info(\"%s: %s symbols\", exchange, len(symbols))\n-\n-        # log all retrieved symbols using debug level\n-        for normalized, exch_sym in sorted(symbols.items()):\n-            LOG.debug('%s: id-from-exch -> normalized: %-35s-> %s', exchange, exch_sym, normalized)\n-\n-        _symbols_retrieval_cache[exchange] = symbols\n-    return _symbols_retrieval_cache[exchange]\n-\n-\n-def _binance_symbols(endpoint: str, exchange: str):\n-    r = None\n-    try:\n-        ret = {}\n-        r = requests.get(endpoint)\n-        for symbol in r.json()['symbols']:\n-            if symbol.get('status', 'TRADING') != \"TRADING\":\n-                continue\n-            if symbol.get('contractStatus', 'TRADING') != \"TRADING\":\n-                continue\n-            split = len(symbol['baseAsset'])\n-            normalized = symbol['symbol'][:split] + SYMBOL_SEP + symbol['symbol'][split:]\n-            ret[normalized] = symbol['symbol']\n-            _exchange_info[exchange]['tick_size'][normalized] = symbol['filters'][0]['tickSize']\n-            if \"contractType\" in symbol:\n-                _exchange_info[exchange]['contract_type'][normalized] = symbol['contractType']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation(exchange, why, {endpoint: r})\n-\n-\n-def binance_symbols() -> Dict[str, str]:\n-    return _binance_symbols('https://api.binance.com/api/v3/exchangeInfo', BINANCE)\n-\n-\n-def binance_us_symbols() -> Dict[str, str]:\n-    return _binance_symbols('https://api.binance.us/api/v3/exchangeInfo', BINANCE_US)\n-\n-\n-def binance_futures_symbols() -> Dict[str, str]:\n-    base = _binance_symbols('https://fapi.binance.com/fapi/v1/exchangeInfo', BINANCE_FUTURES)\n-    add = {}\n-    for symbol, orig in base.items():\n-        if \"_\" in orig:\n-            continue\n-        add[f\"{symbol}-PINDEX\"] = f\"p{orig}\"\n-    base.update(add)\n-    return base\n-\n-\n-def binance_delivery_symbols() -> Dict[str, str]:\n-    return _binance_symbols('https://dapi.binance.com/dapi/v1/exchangeInfo', BINANCE_DELIVERY)\n-\n-\n-def bitfinex_symbols() -> Dict[str, str]:\n-    # doc: https://docs.bitfinex.com/docs/ws-general#supported-pairs\n-    r1 = r2 = None\n-    try:\n-        r1 = requests.get('https://api.bitfinex.com/v2/tickers?symbols=ALL')\n-        r2 = requests.get('https://api-pub.bitfinex.com/v2/conf/pub:map:currency:sym')\n-        tickers: List[List[str]] = r1.json()\n-        norm: List[Tuple[str, str]] = r2.json()[0]\n-        norm: Dict[str, str] = dict(norm)\n-        for k, v in dict(norm).items():\n-            if k[-2:] == 'F0' or '-' in v:  # Do not convert BTCF0 -> BTC or PBTCETH -> PBTC-ETH\n-                del norm[k]\n-        norm['BCHN'] = 'BCH'  # Bitfinex uses BCHN, other exchanges use BCH\n-\n-        ret = {}\n-        for symbol in [t[0] for t in tickers]:\n-            if symbol[0] == 'f':\n-                normalized = norm.get(symbol[1:], symbol[1:])\n-            else:\n-                if len(symbol) == 7:\n-                    base, quote = symbol[1:4], symbol[4:]\n-                else:\n-                    base, quote = symbol[1:].split(':')\n-                    assert ':' in symbol\n-                normalized = norm.get(base, base) + SYMBOL_SEP + norm.get(quote, quote)\n-            ret[normalized.upper()] = symbol\n-        return ret\n-    except ValueError as why:\n-        raise_failure_explanation('BITFINEX', why, {\"tickers?symbols=ALL\": r1, \"pub:map:currency:sym\": r2})\n-\n-\n-def bitflyer_symbols() -> Dict[str, str]:\n-    endpoint = r = None\n-    try:\n-        ret = {}\n-        endpoints = ['https://api.bitflyer.com/v1/getmarkets/eu', 'https://api.bitflyer.com/v1/getmarkets/usa', 'https://api.bitflyer.com/v1/getmarkets']\n-        for endpoint in endpoints:\n-            r = requests.get(endpoint)\n-            for entry in r.json():\n-                normalized = entry['product_code'].replace(\"_\", SYMBOL_SEP)\n-                ret[normalized] = entry['product_code']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('BITFLYER', why, {endpoint: r})\n-\n-\n-def bybit_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.bybit.com/v2/public/symbols')\n-        ret = {}\n-        for symbol in r.json()['result']:\n-            quote = symbol['quote_currency']\n-            if not symbol['name'].endswith(quote):\n-                base, contract = symbol['name'].split(quote)\n-                normalized = f\"{base}{SYMBOL_SEP}{quote}-{contract}\"\n-            else:\n-                normalized = f\"{symbol['base_currency']}{SYMBOL_SEP}{quote}\"\n-            ret[normalized] = symbol['name']\n-            _exchange_info[BYBIT]['tick_size'][normalized] = symbol['price_filter']['tick_size']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('BYBIT', why, {\"\": r})\n-\n-\n-def _ftx_helper(endpoint: str, exchange: str):\n-    r = None\n-    try:\n-        r = requests.get(endpoint)\n-        ret = {}\n-        for data in r.json()['result']:\n-            normalized = data['name'].replace(\"/\", SYMBOL_SEP)\n-            symbol = data['name']\n-            ret[normalized] = symbol\n-            _exchange_info[exchange]['tick_size'][normalized] = data['priceIncrement']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation(exchange, why, {endpoint: r})\n-\n-\n-def ftx_symbols() -> Dict[str, str]:\n-    return _ftx_helper('https://ftx.com/api/markets', FTX)\n-\n-\n-def ftx_us_symbols() -> Dict[str, str]:\n-    return _ftx_helper('https://ftx.us/api/markets', FTX_US)\n-\n-\n-def coinbase_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.pro.coinbase.com/products')\n-        ret = {}\n-        for data in r.json():\n-            normalized = data['id'].replace(\"-\", SYMBOL_SEP)\n-            ret[normalized] = data['id']\n-            _exchange_info[COINBASE]['tick_size'][normalized] = data['quote_increment']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('COINBASE', why, {\"\": r})\n-\n-\n-def gemini_symbols(*args) -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.gemini.com/v1/symbols')\n-        ret = {}\n-        for symbol in r.json():\n-            std = f\"{symbol[:-3]}{SYMBOL_SEP}{symbol[-3:]}\"\n-            std = std.upper()\n-            ret[std] = symbol.upper()\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('GEMINI', why, {\"\": r})\n-\n-\n-def hitbtc_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        ret = {}\n-        r = requests.get('https://api.hitbtc.com/api/2/public/symbol')\n-        for symbol in r.json():\n-            split = len(symbol['baseCurrency'])\n-            normalized = symbol['id'][:split] + SYMBOL_SEP + symbol['id'][split:]\n-            ret[normalized] = symbol['id']\n-            _exchange_info[HITBTC]['tick_size'][normalized] = symbol['tickSize']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('HITBTC', why, {\"\": r})\n-\n-\n-def poloniex_id_symbol_mapping():\n-    r = None\n-    try:\n-        r = requests.get('https://poloniex.com/public?command=returnTicker')\n-        symbols = r.json()\n-        ret = {}\n-        for symbol in symbols:\n-            ret[symbols[symbol]['id']] = symbol\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('POLONIEX', why, {\"\": r})\n-\n-\n-def poloniex_symbols() -> Dict[str, str]:\n-    ret = {}\n-    for _, value in poloniex_id_symbol_mapping().items():\n-        std = value.replace(\"STR\", \"XLM\")\n-        quote, base = std.split(\"_\")\n-        ret[quote + SYMBOL_SEP + base] = value\n-    return ret\n-\n-\n-def bitstamp_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://www.bitstamp.net/api/v2/trading-pairs-info/')\n-        ret = {}\n-        for data in r.json():\n-            normalized = data['name'].replace(\"/\", SYMBOL_SEP)\n-            symbol = data['url_symbol']\n-            ret[normalized] = symbol\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('BITSTAMP', why, {\"\": r})\n-\n-\n-def kraken_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.kraken.com/0/public/AssetPairs')\n-        data = r.json()\n-        ret = {}\n-        for symbol in data['result']:\n-            if 'wsname' not in data['result'][symbol] or '.d' in symbol:\n-                # https://blog.kraken.com/post/259/introducing-the-kraken-dark-pool/\n-                # .d is for dark pool symbols\n-                continue\n-\n-            base, quote = data['result'][symbol]['wsname'].split(\"/\")\n-\n-            normalized = f\"{base}{SYMBOL_SEP}{quote}\"\n-            exch = data['result'][symbol]['wsname']\n-            normalized = normalized.replace('XBT', 'BTC')\n-            normalized = normalized.replace('XDG', 'DOG')\n-            ret[normalized] = exch\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('KRAKEN', why, {\"\": r})\n-\n-\n-def kraken_rest_symbols() -> Dict[str, str]:\n-    return {normalized: exchange.replace(\"/\", \"\") for normalized, exchange in kraken_symbols().items()}\n-\n-\n-def exx_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.exx.com/data/v1/tickers')\n-        exchange = [key.upper() for key in r.json().keys()]\n-        symbols = [key.replace(\"_\", SYMBOL_SEP) for key in exchange]\n-        return dict(zip(symbols, exchange))\n-    except Exception as why:\n-        raise_failure_explanation('EXX', why, {\"\": r})\n-\n-\n-def huobi_common_symbols(url: str):\n-    r = None\n-    try:\n-        r = requests.get(url)\n-        ret = {}\n-        for e in r.json()['data']:\n-            if e['state'] == 'offline':\n-                continue\n-            normalized = f\"{e['base-currency'].upper()}{SYMBOL_SEP}{e['quote-currency'].upper()}\"\n-            symbol = f\"{e['base-currency']}{e['quote-currency']}\"\n-            ret[normalized] = symbol\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('HUOBI', why, {url: r})\n-\n-\n-def huobi_symbols() -> Dict[str, str]:\n-    return huobi_common_symbols('https://api.huobi.pro/v1/common/symbols')\n-\n-\n-def huobi_us_symbols() -> Dict[str, str]:\n-    return huobi_common_symbols('https://api.huobi.com/v1/common/symbols')\n-\n-\n-def huobi_dm_symbols() -> Dict[str, str]:\n-    \"\"\"\n-    Mapping is, for instance: {\"BTC_CW\":\"BTC190816\"}\n-    See comments in exchange/huobi_dm.py\n-    \"\"\"\n-    mapping = {\n-        \"this_week\": \"CW\",\n-        \"next_week\": \"NW\",\n-        \"quarter\": \"CQ\",\n-        \"next_quarter\": \"NQ\"\n-    }\n-    r = None\n-    try:\n-        r = requests.get('https://www.hbdm.com/api/v1/contract_contract_info')\n-        symbols = {}\n-        for e in r.json()['data']:\n-            symbols[f\"{e['symbol']}_{mapping[e['contract_type']]}\"] = e['contract_code']\n-            _exchange_info[HUOBI_DM]['tick_size'][e['contract_code']] = e['price_tick']\n-            _exchange_info[HUOBI_DM]['short_code_mappings'][f\"{e['symbol']}_{mapping[e['contract_type']]}\"] = e['contract_code']\n-        return symbols\n-    except Exception as why:\n-        raise_failure_explanation('HUOBI_DM', why, {\"\": r})\n-\n-\n-def huobi_swap_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.hbdm.com/swap-api/v1/swap_contract_info')\n-        symbols = {}\n-        for e in r.json()['data']:\n-            symbols[e['contract_code']] = e['contract_code']\n-            _exchange_info[HUOBI_SWAP]['tick_size'][e['contract_code']] = e['price_tick']\n-        return symbols\n-    except Exception as why:\n-        raise_failure_explanation('HUOBI_SWAP', why, {\"\": r})\n-\n-\n-def okcoin_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://www.okcoin.com/api/spot/v3/instruments')\n-        ret = {}\n-        for e in r.json():\n-            ret[e['instrument_id']] = e['instrument_id']\n-            _exchange_info[OKCOIN]['tick_size'][e['instrument_id']] = e['tick_size']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('OKCOIN', why, {\"\": r})\n-\n-\n-def okex_symbols(*args) -> Dict[str, str]:\n-    urls = ['https://www.okex.com/api/spot/v3/instruments',\n-            'https://www.okex.com/api/swap/v3/instruments',\n-            'https://www.okex.com/api/futures/v3/instruments']\n-    urls = urls + okex_compute_option_urls_from_underlyings()\n-\n-    symbols: Dict[str, str] = {}\n-    for u in urls:\n-        time.sleep(0.2)\n-        symbols.update(okex_symbols_from_one_url(u))\n-\n-    for symbol in symbols:\n-        instrument_type = 'futures'\n-        dash_count = symbol.count(get_symbol_separator())\n-        if dash_count == 1:  # BTC-USDT\n-            instrument_type = 'spot'\n-        if dash_count == 4:  # BTC-USD-201225-35000-P\n-            instrument_type = 'option'\n-        if symbol[-4:] == \"SWAP\":  # BTC-USDT-SWAP\n-            instrument_type = 'swap'\n-\n-        _exchange_info[OKEX]['instrument_type'][symbol] = instrument_type\n-\n-    return symbols\n-\n-\n-def okex_compute_option_urls_from_underlyings() -> List[str]:\n-    url = 'https://www.okex.com/api/option/v3/underlying'\n-    r = None\n-    try:\n-        r = requests.get(url)\n-        return [f'https://www.okex.com/api/option/v3/instruments/{underlying}' for underlying in r.json()]\n-    except Exception as why:\n-        raise_failure_explanation('OKEX', why, {url: r})\n-\n-\n-def okex_symbols_from_one_url(url: str) -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get(url)\n-        ret = {}\n-        for e in r.json():\n-            ret[e['instrument_id']] = e['instrument_id']\n-            _exchange_info[OKEX]['tick_size'][e['instrument_id']] = e['tick_size']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('OKEX', why, {url: r})\n-\n-\n-def bittrex_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.bittrex.com/api/v1.1/public/getmarkets')\n-        r = r.json()['result']\n-        return {f\"{e['MarketCurrency']}{SYMBOL_SEP}{e['BaseCurrency']}\": e['MarketName'] for e in r if e['IsActive']}\n-    except Exception as why:\n-        raise_failure_explanation('BITTREX', why, {\"\": r})\n-\n-\n-def bitcoincom_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.exchange.bitcoin.com/api/2/public/symbol')\n-        return {f\"{data['baseCurrency']}{SYMBOL_SEP}{data['quoteCurrency'].replace('USD', 'USDT')}\": data['id'] for data in r.json()}\n-    except Exception as why:\n-        raise_failure_explanation('BITCOINCOM', why, {\"\": r})\n-\n-\n-def bitmax_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://bitmax.io/api/pro/v1/products')\n-        ret = {}\n-        for entry in r.json()['data']:\n-            # Only \"Normal\" status symbols are tradeable\n-            if entry['status'] == 'Normal':\n-                normalized = f\"{entry['baseAsset']}{SYMBOL_SEP}{entry['quoteAsset']}\"\n-                ret[normalized] = entry['symbol']\n-                _exchange_info[BITMAX]['tick_size'][normalized] = entry['tickSize']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('BITMAX', why, {\"\": r})\n-\n-\n-def upbit_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.upbit.com/v1/market/all')\n-        return {f\"{data['market'].split('-')[1]}{SYMBOL_SEP}{data['market'].split('-')[0]}\": data['market'] for data in r.json()}\n-    except Exception as why:\n-        raise_failure_explanation('UPBIT', why, {\"\": r})\n-\n-\n-def blockchain_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get(\"https://api.blockchain.com/mercury-gateway/v1/instruments\")\n-        return {data[\"symbol\"].replace(\"-\", SYMBOL_SEP): data[\"symbol\"] for data in r.json()}\n-    except Exception as why:\n-        raise_failure_explanation('BLOCKCHAIN', why, {\"\": r})\n-\n-\n-def gateio_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get(\"https://api.gateio.ws/api/v4/spot/currency_pairs\")\n-        return {data[\"id\"].replace(\"_\", SYMBOL_SEP): data['id'] for data in r.json()}\n-    except Exception as why:\n-        raise_failure_explanation('GATEIO', why, {\"\": r})\n-\n-\n-def bitmex_symbols() -> Dict[str, str]:\n-    r = None\n-    ret = {}\n-    try:\n-        r = requests.get(\"https://www.bitmex.com/api/v1/instrument/active\")\n-        for entry in r.json():\n-            components = []\n-            components.append(entry['rootSymbol'])\n-            components.append(entry['quoteCurrency'])\n-\n-            if entry['expiry']:\n-                components.append(entry['symbol'][-3:])\n-\n-            normalized = SYMBOL_SEP.join(components)\n-            normalized = normalized.replace(\"XBT\", \"BTC\")\n-            ret[normalized] = entry['symbol']\n-            _exchange_info[BITMEX]['tick_size'][normalized] = entry['tickSize']\n-\n-            if entry['expiry']:\n-                _exchange_info[BITMEX]['expiry'][normalized] = entry['expiry']\n-\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('BITMEX', why, {\"\": r})\n-\n-\n-def deribit_symbols() -> Dict[str, str]:\n-    url = r = None\n-    ret = {}\n-    try:\n-        # TODO: get currencies from https://www.deribit.com/api/v2/public/get_currencies\n-        currencies = ['BTC', 'ETH']\n-        for c in currencies:\n-            url = f\"https://www.deribit.com/api/v2/public/get_instruments?currency={c}&expired=false\"\n-            r = requests.get(url)\n-            for entry in r.json()['result']:\n-                split = entry['instrument_name'].split(\"-\")\n-                normalized = split[0] + SYMBOL_SEP + entry['quote_currency'] + \"-\" + '-'.join(split[1:])\n-                ret[normalized] = entry['instrument_name']\n-                _exchange_info[DERIBIT]['tick_size'][normalized] = entry['tick_size']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('DERIBIT', why, {url: r})\n-\n-\n-def kraken_future_symbols() -> Dict[str, str]:\n-    r = None\n-    ret = {}\n-    try:\n-        r = requests.get('https://futures.kraken.com/derivatives/api/v3/instruments')\n-        data = r.json()['instruments']\n-        for entry in data:\n-            if not entry['tradeable']:\n-                continue\n-            normalized = entry['symbol'].upper().replace(\"_\", \"-\")\n-            symbol = normalized[3:6] + SYMBOL_SEP + normalized[6:9]\n-            normalized = normalized.replace(normalized[3:9], symbol)\n-            normalized = normalized.replace('XBT', 'BTC')\n-\n-            _exchange_info[KRAKEN_FUTURES]['tick_size'][normalized] = entry['tickSize']\n-            _exchange_info[KRAKEN_FUTURES]['contract_size'][normalized] = entry['contractSize']\n-            _exchange_info[KRAKEN_FUTURES]['underlying'][normalized] = entry['underlying']\n-            _exchange_info[KRAKEN_FUTURES]['product_type'][normalized] = _kraken_futures_product_type[normalized[:2]]\n-            ret[normalized] = entry['symbol']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('KRAKEN_FUTURES', why, {\"\": r})\n-\n-\n-def probit_symbols() -> Dict[str, str]:\n-    # doc: https://docs-en.probit.com/reference-link/market\n-    r = None\n-    try:\n-        r = requests.get('https://api.probit.com/api/exchange/v1/market')\n-        return {entry['id']: entry['id'] for entry in r.json()['data']}\n-    except Exception as why:\n-        raise_failure_explanation('PROBIT', why, {\"\": r})\n-\n-\n-def coingecko_normalize_symbol(symbol: str) -> str:\n-    # keep digits, letters and dots, replace others by space\n-    symbol = ''.join(c if c.isalnum() or c in ('.', '+') else ' ' for c in symbol)\n-    return coingecko_normalize(symbol.upper())\n-\n-\n-def coingecko_normalize_name(name: str) -> str:\n-    # keep digits and letters, replace others by space (except when only composed by upper case letters, digits and dots)\n-    if not all(c.isupper() or c.isdigit() or c == '.' for c in name):\n-        name = ''.join(c if c.isalnum() else ' ' for c in name)\n-    return coingecko_normalize(name)\n-\n-\n-def coingecko_normalize(sym: str) -> str:\n-    sym = sym.strip()\n-    # do not concatenate numbers => separate them with a dot\n-    sym = list(sym)\n-    if len(sym) > 4:\n-        for i in range(2, len(sym) - 1):\n-            if sym[i] == ' ' and sym[i - 1].isdigit() and sym[i + 1].isdigit():\n-                sym[i] = '.'\n-    sym = ''.join(sym)\n-    # concatenate space-separated words => use CamelCase to distinguish the words\n-    if ' ' in sym:\n-        if sum(c.islower() for c in sym):  # if there is at least one lower case letter\n-            sym = ' '.join(word[0].upper() + word[1:] for word in sym.split())  # Just capitalize initial letter of each word\n-        else:  # CoinGecko may provide full upper-case as for \"THE STONE COIN\"\n-            sym = string.capwords(sym)  # capwords converts \"THE STONE COIN\" to \"The Stone Coin\"\n-        sym = sym.replace(' ', '')  # concatenate words\n-    return sym\n-\n-\n-def is_name_short(coin: dict) -> bool:\n-    \"\"\"return True if the coin name is enough short compared to the coin symbol.\"\"\"\n-    return len(coin['name']) <= max(5, len(coin['symbol']) + 1)\n-\n-\n-def has_many_caps(name: str) -> bool:\n-    \"\"\"return True if the symbol contains enough upper case letters, False if empty.\"\"\"\n-    return str and sum(c.islower() for c in name) < (len(name) / 2)\n-\n-\n-def coingecko_normalize_all(coin: dict):\n-    SYMBOL_TO_NORMALIZED = {'miota': 'IOTA'}\n-    normalized = SYMBOL_TO_NORMALIZED.get(coin['symbol'])\n-    if normalized:\n-        coin['ns'] = coin['nn'] = normalized\n-        return normalized\n-\n-    # ns = normalized symbol, nn = normalized name\n-    coin['ns'] = coingecko_normalize_symbol(coin['symbol'])\n-\n-    ID_SUFFIX = '-bitcoin-token'\n-    if coin['id'][-len(ID_SUFFIX):] == ID_SUFFIX:\n-        coin['nn'] = 'BTC' + coin['ns']\n-        return coin['nn']\n-\n-    name = coin['name']\n-\n-    prefixes = ('The ', 'the ')\n-    for p in prefixes:\n-        if name[:len(p)] == p:\n-            coin['reduced-name'] = True\n-            name = name[len(p):]\n-            break\n-\n-    suffixes = ('coin', 'coins', 'money', 'finance', 'protocol', 'reward', 'rewards', 'token')\n-    for s in suffixes:\n-        if len(name) > len(s) and name[-len(s):].lower() == s:\n-            # but keep suffix when lower-case concatenated\n-            if name[-len(s)].islower() and name[-len(s) - 1] != ' ':\n-                continue\n-            # also keep suffix to avoid confusing nam: \"Bitcoin Token\" -> \"Bitcoin\"\n-            if name[:-len(s)].strip().lower() == 'bitcoin':\n-                continue\n-            coin['reduced-name'] = True\n-            name = name[:-len(s)]\n-            break\n-\n-    coin['nn'] = coingecko_normalize_name(name)\n-\n-    if len(coin['nn']) < len(coin['ns']):\n-        if 'reduced-name' in coin:\n-            coin['reduced-name'] = False\n-            name = coin['name']\n-            coin['nn'] = coingecko_normalize_name(name)\n-        elif not has_many_caps(name):\n-            return coin['ns']\n-\n-    if not coin['ns']:  # coin['symbol'] may be an emoji that is striped when normalized\n-        return coin['nn']\n-\n-    if coin.get('reduced-name') and coin['ns'].upper() != coin['nn'].upper():\n-        return coin['ns']\n-\n-    i = coin['nn'].find('.')  # if there is a dot in normalized name => prefer the normalized symbol\n-    if i >= 0:\n-        if i > 1 and coin['nn'][i - 1].isdigit() and coin['nn'][i + 1].isdigit():\n-            pass  # except when the dot separates digits\n-        else:\n-            return coin['ns']\n-\n-    if is_name_short(coin) and has_many_caps(name):\n-        return coin['nn']\n-\n-    if 1.5 * len(coin['ns']) > len(coin['nn']) and any(c.islower() for c in coin['ns']):\n-        return coin['nn']\n-\n-    return coin['ns']\n-\n-\n-def coingecko_symbols() -> Dict[str, str]:\n-    r = None\n-    intermediate = defaultdict(list)\n-    try:\n-        r = requests.get('https://api.coingecko.com/api/v3/coins/list')\n-        all_coins = r.json()\n-        # First pass: generate & compare normalized symbol/name, and then select the most pertinent\n-        for coin in all_coins:\n-            normalized = coingecko_normalize_all(coin)\n-            intermediate[normalized].append(coin)\n-            # Above line keeps together the coins having the same normalized symbol.\n-            # To reduce collision, the coin['name'] is sometimes used in lieu of the coin['symbol'].\n-            # The coin['name'] is not capitalized because lower case letters may be meaningful: cETH, yUSD, DATx, zLOT\n-    except Exception as why:\n-        raise_failure_explanation('COINGECKO', why, {\"\": r})\n-\n-    final = coingecko_second_pass(intermediate)\n-    return coingecko_third_pass(final)\n-\n-\n-def coingecko_second_pass(intermediate: Dict[str, List[dict]]) -> Dict[str, List[dict]]:\n-    # Second pass: fixes most of the symbol collisions\n-    final = defaultdict(list)\n-    for normalized, coins in intermediate.items():\n-        if len(coins) == 1:\n-            final[normalized].append(coins[0])\n-            continue\n-        set_normalized = False\n-        for i in range(len(coins)):\n-            if normalized == coins[i]['nn']:\n-                coin = coins.pop(i)\n-                final[normalized].append(coin)\n-                set_normalized = True\n-                break\n-        rest: List[dict] = []\n-        for coin in coins:\n-            if '%' in coin['name']:\n-                if len(coins) == 1:\n-                    n = coin['ns']\n-                else:\n-                    n = coingecko_normalize_name(coin['id'])\n-                final[n].append(coin)\n-            else:\n-                rest.append(coin)\n-        if not rest:\n-            continue\n-        if not set_normalized:\n-            rest.sort(key=lambda coin: len(coin['nn']), reverse=True)  # sort by the length of the normalized name\n-            coin = rest.pop(0)\n-            final[normalized].append(coin)\n-        for coin in rest:\n-            if coin['nn'] not in intermediate:\n-                n = coin['nn']\n-            elif coin.get('reduced-name'):\n-                n = coingecko_normalize_name(coin['name'])\n-            else:\n-                n = coingecko_normalize_name(coin['id'])\n-            final[n].append(coin)\n-    return final\n-\n-\n-def coingecko_third_pass(final: Dict[str, List[dict]]) -> Dict[str, str]:\n-    # Third pass: fixes some remaining collisions and fills the result\n-    symbols = {}\n-    for normalized, coins in final.items():\n-        if len(coins) == 1:\n-            symbols[normalized] = coins[0]['id']\n-            continue\n-        set_normalized = False\n-        for i in range(len(coins)):\n-            if normalized == coins[i]['nn']:\n-                coin = coins.pop(i)\n-                symbols[normalized] = coin['id']\n-                set_normalized = True\n-                break\n-        rest: List[dict] = []\n-        for coin in coins:\n-            if '%' in coin['name']:\n-                if len(coins) == 1:\n-                    n = coin['ns']\n-                else:\n-                    n = coingecko_normalize_name(coin['id'])\n-                symbols[n] = coin['id']\n-            else:\n-                rest.append(coin)\n-        if not rest:\n-            continue\n-        if not set_normalized:\n-            rest.sort(key=lambda coin: len(coin['nn']), reverse=True)  # sort by the length of the normalized name\n-            coin = rest.pop(0)\n-            symbols[normalized] = coin['id']\n-        for coin in rest:\n-            if coin['nn'] not in final:\n-                n = coin['nn']\n-            elif coin.get('reduced-name'):\n-                n = coingecko_normalize_name(coin['name'])\n-            else:\n-                n = coingecko_normalize_name(coin['id'])\n-            symbols[n] = coin['id']\n-    return symbols\n-\n-\n-def whale_alert_coins(key_id: str) -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get(f'https://api.whale-alert.io/v1/status?api_key={key_id}')\n-        # Same symbols, but on different blockchains (for instance USDT), are naturally overwritten.\n-        return {s.upper(): s for b in r.json()['blockchains'] for s in b['symbols'] if s}\n-    except Exception as why:\n-        raise_failure_explanation('WHALES_ALERT', why, {\"\": r})\n-\n-\n-_exchange_function_map = {\n-    BITFINEX: bitfinex_symbols,\n-    BITFLYER: bitflyer_symbols,\n-    COINBASE: coinbase_symbols,\n-    GEMINI: gemini_symbols,\n-    HITBTC: hitbtc_symbols,\n-    POLONIEX: poloniex_symbols,\n-    PROBIT: probit_symbols,\n-    BITSTAMP: bitstamp_symbols,\n-    KRAKEN: kraken_symbols,\n-    KRAKEN + 'REST': kraken_rest_symbols,\n-    BINANCE: binance_symbols,\n-    BINANCE_US: binance_us_symbols,\n-    BINANCE_FUTURES: binance_futures_symbols,\n-    BINANCE_DELIVERY: binance_delivery_symbols,\n-    BLOCKCHAIN: blockchain_symbols,\n-    EXX: exx_symbols,\n-    HUOBI: huobi_symbols,\n-    HUOBI_DM: huobi_dm_symbols,\n-    HUOBI_SWAP: huobi_swap_symbols,\n-    OKCOIN: okcoin_symbols,\n-    OKEX: okex_symbols,\n-    BYBIT: bybit_symbols,\n-    FTX: ftx_symbols,\n-    FTX_US: ftx_us_symbols,\n-    BITTREX: bittrex_symbols,\n-    BITCOINCOM: bitcoincom_symbols,\n-    BITMAX: bitmax_symbols,\n-    UPBIT: upbit_symbols,\n-    GATEIO: gateio_symbols,\n-    BITMEX: bitmex_symbols,\n-    DERIBIT: deribit_symbols,\n-    KRAKEN_FUTURES: kraken_future_symbols,\n-    COINGECKO: coingecko_symbols,\n-    WHALE_ALERT: whale_alert_coins\n-}\n+Symbols = _Symbols()\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\n\nimport logging\nimport string\nimport time\nfrom collections import defaultdict\nfrom typing import Dict, List, Optional, Tuple\n\nimport requests\nfrom requests import Response\n\nfrom cryptofeed.defines import *\n\n\nLOG = logging.getLogger('feedhandler')\n\nSYMBOL_SEP = '-'\n\n_symbols_retrieval_cache: Dict[str, Dict[str, str]] = {}\n_exchange_info = defaultdict(lambda: defaultdict(dict))\n\n\n_kraken_futures_product_type = {\n    'FI': 'Inverse Futures',\n    'FV': 'Vanilla Futures',\n    'PI': 'Perpetual Inverse Futures',\n    'PV': 'Perpetual Vanilla Futures',\n    'IN': 'Real Time Index',\n    'RR': 'Reference Rate',\n}\n\n\ndef raise_failure_explanation(feed_id: str, exception: BaseException, responses: Dict[str, Optional[Response]]):\n    <IND>LOG.critical('%s: encountered %r while processing response from exchange API', feed_id, exception)\n    if len(responses) > 1:\n        <IND>LOG.critical('%s: content of one of the %s responses was unexpected', feed_id, len(responses))\n    <DED>for url, r in responses.items():\n        <IND>if url:\n            <IND>LOG.critical('%s: requested URL: %s', feed_id, url)\n        <DED>if r:\n            <IND>LOG.critical('%s: unexpected response: %s', feed_id, r.text)\n    <DED><DED>raise ValueError(f'Cryptofeed stopped because of an unexpected response from {feed_id}') from exception\n\n\n<DED>def set_symbol_separator(separator: str):\n    <IND>global SYMBOL_SEP\n    SYMBOL_SEP = separator\n\n\n<DED>def get_symbol_separator() -> str:\n    <IND>global SYMBOL_SEP\n    return SYMBOL_SEP\n\n\n<DED>def gen_symbols(exchange: str, key_id=None) -> Dict[str, str]:\n    <IND>if exchange not in _symbols_retrieval_cache:\n        <IND>LOG.info(\"%s: Getting list of symbols\", exchange)\n        symbols = _exchange_function_map[exchange](key_id) if key_id else _exchange_function_map[exchange]()\n        LOG.info(\"%s: %s symbols\", exchange, len(symbols))\n\n        # log all retrieved symbols using debug level\n        for normalized, exch_sym in sorted(symbols.items()):\n            <IND>LOG.debug('%s: id-from-exch -> normalized: %-35s-> %s', exchange, exch_sym, normalized)\n\n        <DED>_symbols_retrieval_cache[exchange] = symbols\n    <DED>return _symbols_retrieval_cache[exchange]\n\n\n<DED>def _binance_symbols(endpoint: str, exchange: str):\n    <IND>r = None\n    try:\n        <IND>ret = {}\n        r = requests.get(endpoint)\n        for symbol in r.json()['symbols']:\n            <IND>if symbol.get('status', 'TRADING') != \"TRADING\":\n                <IND>continue\n            <DED>if symbol.get('contractStatus', 'TRADING') != \"TRADING\":\n                <IND>continue\n            <DED>split = len(symbol['baseAsset'])\n            normalized = symbol['symbol'][:split] + SYMBOL_SEP + symbol['symbol'][split:]\n            ret[normalized] = symbol['symbol']\n            _exchange_info[exchange]['tick_size'][normalized] = symbol['filters'][0]['tickSize']\n            if \"contractType\" in symbol:\n                <IND>_exchange_info[exchange]['contract_type'][normalized] = symbol['contractType']\n        <DED><DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation(exchange, why, {endpoint: r})\n\n\n<DED><DED>def binance_symbols() -> Dict[str, str]:\n    <IND>return _binance_symbols('https://api.binance.com/api/v3/exchangeInfo', BINANCE)\n\n\n<DED>def binance_us_symbols() -> Dict[str, str]:\n    <IND>return _binance_symbols('https://api.binance.us/api/v3/exchangeInfo', BINANCE_US)\n\n\n<DED>def binance_futures_symbols() -> Dict[str, str]:\n    <IND>base = _binance_symbols('https://fapi.binance.com/fapi/v1/exchangeInfo', BINANCE_FUTURES)\n    add = {}\n    for symbol, orig in base.items():\n        <IND>if \"_\" in orig:\n            <IND>continue\n        <DED>add[f\"{symbol}-PINDEX\"] = f\"p{orig}\"\n    <DED>base.update(add)\n    return base\n\n\n<DED>def binance_delivery_symbols() -> Dict[str, str]:\n    <IND>return _binance_symbols('https://dapi.binance.com/dapi/v1/exchangeInfo', BINANCE_DELIVERY)\n\n\n<DED>def bitfinex_symbols() -> Dict[str, str]:\n    # doc: https://docs.bitfinex.com/docs/ws-general#supported-pairs\n    <IND>r1 = r2 = None\n    try:\n        <IND>r1 = requests.get('https://api.bitfinex.com/v2/tickers?symbols=ALL')\n        r2 = requests.get('https://api-pub.bitfinex.com/v2/conf/pub:map:currency:sym')\n        tickers: List[List[str]] = r1.json()\n        norm: List[Tuple[str, str]] = r2.json()[0]\n        norm: Dict[str, str] = dict(norm)\n        for k, v in dict(norm).items():\n            <IND>if k[-2:] == 'F0' or '-' in v:  # Do not convert BTCF0 -> BTC or PBTCETH -> PBTC-ETH\n                <IND>del norm[k]\n        <DED><DED>norm['BCHN'] = 'BCH'  # Bitfinex uses BCHN, other exchanges use BCH\n\n        ret = {}\n        for symbol in [t[0] for t in tickers]:\n            <IND>if symbol[0] == 'f':\n                <IND>normalized = norm.get(symbol[1:], symbol[1:])\n            <DED>else:\n                <IND>if len(symbol) == 7:\n                    <IND>base, quote = symbol[1:4], symbol[4:]\n                <DED>else:\n                    <IND>base, quote = symbol[1:].split(':')\n                    assert ':' in symbol\n                <DED>normalized = norm.get(base, base) + SYMBOL_SEP + norm.get(quote, quote)\n            <DED>ret[normalized.upper()] = symbol\n        <DED>return ret\n    <DED>except ValueError as why:\n        <IND>raise_failure_explanation('BITFINEX', why, {\"tickers?symbols=ALL\": r1, \"pub:map:currency:sym\": r2})\n\n\n<DED><DED>def bitflyer_symbols() -> Dict[str, str]:\n    <IND>endpoint = r = None\n    try:\n        <IND>ret = {}\n        endpoints = ['https://api.bitflyer.com/v1/getmarkets/eu', 'https://api.bitflyer.com/v1/getmarkets/usa', 'https://api.bitflyer.com/v1/getmarkets']\n        for endpoint in endpoints:\n            <IND>r = requests.get(endpoint)\n            for entry in r.json():\n                <IND>normalized = entry['product_code'].replace(\"_\", SYMBOL_SEP)\n                ret[normalized] = entry['product_code']\n        <DED><DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BITFLYER', why, {endpoint: r})\n\n\n<DED><DED>def bybit_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.bybit.com/v2/public/symbols')\n        ret = {}\n        for symbol in r.json()['result']:\n            <IND>quote = symbol['quote_currency']\n            if not symbol['name'].endswith(quote):\n                <IND>base, contract = symbol['name'].split(quote)\n                normalized = f\"{base}{SYMBOL_SEP}{quote}-{contract}\"\n            <DED>else:\n                <IND>normalized = f\"{symbol['base_currency']}{SYMBOL_SEP}{quote}\"\n            <DED>ret[normalized] = symbol['name']\n            _exchange_info[BYBIT]['tick_size'][normalized] = symbol['price_filter']['tick_size']\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BYBIT', why, {\"\": r})\n\n\n<DED><DED>def _ftx_helper(endpoint: str, exchange: str):\n    <IND>r = None\n    try:\n        <IND>r = requests.get(endpoint)\n        ret = {}\n        for data in r.json()['result']:\n            <IND>normalized = data['name'].replace(\"/\", SYMBOL_SEP)\n            symbol = data['name']\n            ret[normalized] = symbol\n            _exchange_info[exchange]['tick_size'][normalized] = data['priceIncrement']\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation(exchange, why, {endpoint: r})\n\n\n<DED><DED>def ftx_symbols() -> Dict[str, str]:\n    <IND>return _ftx_helper('https://ftx.com/api/markets', FTX)\n\n\n<DED>def ftx_us_symbols() -> Dict[str, str]:\n    <IND>return _ftx_helper('https://ftx.us/api/markets', FTX_US)\n\n\n<DED>def coinbase_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.pro.coinbase.com/products')\n        ret = {}\n        for data in r.json():\n            <IND>normalized = data['id'].replace(\"-\", SYMBOL_SEP)\n            ret[normalized] = data['id']\n            _exchange_info[COINBASE]['tick_size'][normalized] = data['quote_increment']\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('COINBASE', why, {\"\": r})\n\n\n<DED><DED>def gemini_symbols(*args) -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.gemini.com/v1/symbols')\n        ret = {}\n        for symbol in r.json():\n            <IND>std = f\"{symbol[:-3]}{SYMBOL_SEP}{symbol[-3:]}\"\n            std = std.upper()\n            ret[std] = symbol.upper()\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('GEMINI', why, {\"\": r})\n\n\n<DED><DED>def hitbtc_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>ret = {}\n        r = requests.get('https://api.hitbtc.com/api/2/public/symbol')\n        for symbol in r.json():\n            <IND>split = len(symbol['baseCurrency'])\n            normalized = symbol['id'][:split] + SYMBOL_SEP + symbol['id'][split:]\n            ret[normalized] = symbol['id']\n            _exchange_info[HITBTC]['tick_size'][normalized] = symbol['tickSize']\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('HITBTC', why, {\"\": r})\n\n\n<DED><DED>def poloniex_id_symbol_mapping():\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://poloniex.com/public?command=returnTicker')\n        symbols = r.json()\n        ret = {}\n        for symbol in symbols:\n            <IND>ret[symbols[symbol]['id']] = symbol\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('POLONIEX', why, {\"\": r})\n\n\n<DED><DED>def poloniex_symbols() -> Dict[str, str]:\n    <IND>ret = {}\n    for _, value in poloniex_id_symbol_mapping().items():\n        <IND>std = value.replace(\"STR\", \"XLM\")\n        quote, base = std.split(\"_\")\n        ret[quote + SYMBOL_SEP + base] = value\n    <DED>return ret\n\n\n<DED>def bitstamp_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://www.bitstamp.net/api/v2/trading-pairs-info/')\n        ret = {}\n        for data in r.json():\n            <IND>normalized = data['name'].replace(\"/\", SYMBOL_SEP)\n            symbol = data['url_symbol']\n            ret[normalized] = symbol\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BITSTAMP', why, {\"\": r})\n\n\n<DED><DED>def kraken_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.kraken.com/0/public/AssetPairs')\n        data = r.json()\n        ret = {}\n        for symbol in data['result']:\n            <IND>if 'wsname' not in data['result'][symbol] or '.d' in symbol:\n                # https://blog.kraken.com/post/259/introducing-the-kraken-dark-pool/\n                # .d is for dark pool symbols\n                <IND>continue\n\n            <DED>base, quote = data['result'][symbol]['wsname'].split(\"/\")\n\n            normalized = f\"{base}{SYMBOL_SEP}{quote}\"\n            exch = data['result'][symbol]['wsname']\n            normalized = normalized.replace('XBT', 'BTC')\n            normalized = normalized.replace('XDG', 'DOG')\n            ret[normalized] = exch\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('KRAKEN', why, {\"\": r})\n\n\n<DED><DED>def kraken_rest_symbols() -> Dict[str, str]:\n    <IND>return {normalized: exchange.replace(\"/\", \"\") for normalized, exchange in kraken_symbols().items()}\n\n\n<DED>def exx_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.exx.com/data/v1/tickers')\n        exchange = [key.upper() for key in r.json().keys()]\n        symbols = [key.replace(\"_\", SYMBOL_SEP) for key in exchange]\n        return dict(zip(symbols, exchange))\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('EXX', why, {\"\": r})\n\n\n<DED><DED>def huobi_common_symbols(url: str):\n    <IND>r = None\n    try:\n        <IND>r = requests.get(url)\n        ret = {}\n        for e in r.json()['data']:\n            <IND>if e['state'] == 'offline':\n                <IND>continue\n            <DED>normalized = f\"{e['base-currency'].upper()}{SYMBOL_SEP}{e['quote-currency'].upper()}\"\n            symbol = f\"{e['base-currency']}{e['quote-currency']}\"\n            ret[normalized] = symbol\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('HUOBI', why, {url: r})\n\n\n<DED><DED>def huobi_symbols() -> Dict[str, str]:\n    <IND>return huobi_common_symbols('https://api.huobi.pro/v1/common/symbols')\n\n\n<DED>def huobi_us_symbols() -> Dict[str, str]:\n    <IND>return huobi_common_symbols('https://api.huobi.com/v1/common/symbols')\n\n\n<DED>def huobi_dm_symbols() -> Dict[str, str]:\n    <IND>\"\"\"\n    Mapping is, for instance: {\"BTC_CW\":\"BTC190816\"}\n    See comments in exchange/huobi_dm.py\n    \"\"\"\n    mapping = {\n        \"this_week\": \"CW\",\n        \"next_week\": \"NW\",\n        \"quarter\": \"CQ\",\n        \"next_quarter\": \"NQ\"\n    }\n    r = None\n    try:\n        <IND>r = requests.get('https://www.hbdm.com/api/v1/contract_contract_info')\n        symbols = {}\n        for e in r.json()['data']:\n            <IND>symbols[f\"{e['symbol']}_{mapping[e['contract_type']]}\"] = e['contract_code']\n            _exchange_info[HUOBI_DM]['tick_size'][e['contract_code']] = e['price_tick']\n            _exchange_info[HUOBI_DM]['short_code_mappings'][f\"{e['symbol']}_{mapping[e['contract_type']]}\"] = e['contract_code']\n        <DED>return symbols\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('HUOBI_DM', why, {\"\": r})\n\n\n<DED><DED>def huobi_swap_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.hbdm.com/swap-api/v1/swap_contract_info')\n        symbols = {}\n        for e in r.json()['data']:\n            <IND>symbols[e['contract_code']] = e['contract_code']\n            _exchange_info[HUOBI_SWAP]['tick_size'][e['contract_code']] = e['price_tick']\n        <DED>return symbols\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('HUOBI_SWAP', why, {\"\": r})\n\n\n<DED><DED>def okcoin_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://www.okcoin.com/api/spot/v3/instruments')\n        ret = {}\n        for e in r.json():\n            <IND>ret[e['instrument_id']] = e['instrument_id']\n            _exchange_info[OKCOIN]['tick_size'][e['instrument_id']] = e['tick_size']\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('OKCOIN', why, {\"\": r})\n\n\n<DED><DED>def okex_symbols(*args) -> Dict[str, str]:\n    <IND>urls = ['https://www.okex.com/api/spot/v3/instruments',\n            'https://www.okex.com/api/swap/v3/instruments',\n            'https://www.okex.com/api/futures/v3/instruments']\n    urls = urls + okex_compute_option_urls_from_underlyings()\n\n    symbols: Dict[str, str] = {}\n    for u in urls:\n        <IND>time.sleep(0.2)\n        symbols.update(okex_symbols_from_one_url(u))\n\n    <DED>for symbol in symbols:\n        <IND>instrument_type = 'futures'\n        dash_count = symbol.count(get_symbol_separator())\n        if dash_count == 1:  # BTC-USDT\n            <IND>instrument_type = 'spot'\n        <DED>if dash_count == 4:  # BTC-USD-201225-35000-P\n            <IND>instrument_type = 'option'\n        <DED>if symbol[-4:] == \"SWAP\":  # BTC-USDT-SWAP\n            <IND>instrument_type = 'swap'\n\n        <DED>_exchange_info[OKEX]['instrument_type'][symbol] = instrument_type\n\n    <DED>return symbols\n\n\n<DED>def okex_compute_option_urls_from_underlyings() -> List[str]:\n    <IND>url = 'https://www.okex.com/api/option/v3/underlying'\n    r = None\n    try:\n        <IND>r = requests.get(url)\n        return [f'https://www.okex.com/api/option/v3/instruments/{underlying}' for underlying in r.json()]\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('OKEX', why, {url: r})\n\n\n<DED><DED>def okex_symbols_from_one_url(url: str) -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get(url)\n        ret = {}\n        for e in r.json():\n            <IND>ret[e['instrument_id']] = e['instrument_id']\n            _exchange_info[OKEX]['tick_size'][e['instrument_id']] = e['tick_size']\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('OKEX', why, {url: r})\n\n\n<DED><DED>def bittrex_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.bittrex.com/api/v1.1/public/getmarkets')\n        r = r.json()['result']\n        return {f\"{e['MarketCurrency']}{SYMBOL_SEP}{e['BaseCurrency']}\": e['MarketName'] for e in r if e['IsActive']}\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BITTREX', why, {\"\": r})\n\n\n<DED><DED>def bitcoincom_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.exchange.bitcoin.com/api/2/public/symbol')\n        return {f\"{data['baseCurrency']}{SYMBOL_SEP}{data['quoteCurrency'].replace('USD', 'USDT')}\": data['id'] for data in r.json()}\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BITCOINCOM', why, {\"\": r})\n\n\n<DED><DED>def bitmax_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://bitmax.io/api/pro/v1/products')\n        ret = {}\n        for entry in r.json()['data']:\n            # Only \"Normal\" status symbols are tradeable\n            <IND>if entry['status'] == 'Normal':\n                <IND>normalized = f\"{entry['baseAsset']}{SYMBOL_SEP}{entry['quoteAsset']}\"\n                ret[normalized] = entry['symbol']\n                _exchange_info[BITMAX]['tick_size'][normalized] = entry['tickSize']\n        <DED><DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BITMAX', why, {\"\": r})\n\n\n<DED><DED>def upbit_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.upbit.com/v1/market/all')\n        return {f\"{data['market'].split('-')[1]}{SYMBOL_SEP}{data['market'].split('-')[0]}\": data['market'] for data in r.json()}\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('UPBIT', why, {\"\": r})\n\n\n<DED><DED>def blockchain_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get(\"https://api.blockchain.com/mercury-gateway/v1/instruments\")\n        return {data[\"symbol\"].replace(\"-\", SYMBOL_SEP): data[\"symbol\"] for data in r.json()}\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BLOCKCHAIN', why, {\"\": r})\n\n\n<DED><DED>def gateio_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get(\"https://api.gateio.ws/api/v4/spot/currency_pairs\")\n        return {data[\"id\"].replace(\"_\", SYMBOL_SEP): data['id'] for data in r.json()}\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('GATEIO', why, {\"\": r})\n\n\n<DED><DED>def bitmex_symbols() -> Dict[str, str]:\n    <IND>r = None\n    ret = {}\n    try:\n        <IND>r = requests.get(\"https://www.bitmex.com/api/v1/instrument/active\")\n        for entry in r.json():\n            <IND>components = []\n            components.append(entry['rootSymbol'])\n            components.append(entry['quoteCurrency'])\n\n            if entry['expiry']:\n                <IND>components.append(entry['symbol'][-3:])\n\n            <DED>normalized = SYMBOL_SEP.join(components)\n            normalized = normalized.replace(\"XBT\", \"BTC\")\n            ret[normalized] = entry['symbol']\n            _exchange_info[BITMEX]['tick_size'][normalized] = entry['tickSize']\n\n            if entry['expiry']:\n                <IND>_exchange_info[BITMEX]['expiry'][normalized] = entry['expiry']\n\n        <DED><DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BITMEX', why, {\"\": r})\n\n\n<DED><DED>def deribit_symbols() -> Dict[str, str]:\n    <IND>url = r = None\n    ret = {}\n    try:\n        # TODO: get currencies from https://www.deribit.com/api/v2/public/get_currencies\n        <IND>currencies = ['BTC', 'ETH']\n        for c in currencies:\n            <IND>url = f\"https://www.deribit.com/api/v2/public/get_instruments?currency={c}&expired=false\"\n            r = requests.get(url)\n            for entry in r.json()['result']:\n                <IND>split = entry['instrument_name'].split(\"-\")\n                normalized = split[0] + SYMBOL_SEP + entry['quote_currency'] + \"-\" + '-'.join(split[1:])\n                ret[normalized] = entry['instrument_name']\n                _exchange_info[DERIBIT]['tick_size'][normalized] = entry['tick_size']\n        <DED><DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('DERIBIT', why, {url: r})\n\n\n<DED><DED>def kraken_future_symbols() -> Dict[str, str]:\n    <IND>r = None\n    ret = {}\n    try:\n        <IND>r = requests.get('https://futures.kraken.com/derivatives/api/v3/instruments')\n        data = r.json()['instruments']\n        for entry in data:\n            <IND>if not entry['tradeable']:\n                <IND>continue\n            <DED>normalized = entry['symbol'].upper().replace(\"_\", \"-\")\n            symbol = normalized[3:6] + SYMBOL_SEP + normalized[6:9]\n            normalized = normalized.replace(normalized[3:9], symbol)\n            normalized = normalized.replace('XBT', 'BTC')\n\n            _exchange_info[KRAKEN_FUTURES]['tick_size'][normalized] = entry['tickSize']\n            _exchange_info[KRAKEN_FUTURES]['contract_size'][normalized] = entry['contractSize']\n            _exchange_info[KRAKEN_FUTURES]['underlying'][normalized] = entry['underlying']\n            _exchange_info[KRAKEN_FUTURES]['product_type'][normalized] = _kraken_futures_product_type[normalized[:2]]\n            ret[normalized] = entry['symbol']\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('KRAKEN_FUTURES', why, {\"\": r})\n\n\n<DED><DED>def probit_symbols() -> Dict[str, str]:\n    # doc: https://docs-en.probit.com/reference-link/market\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.probit.com/api/exchange/v1/market')\n        return {entry['id']: entry['id'] for entry in r.json()['data']}\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('PROBIT', why, {\"\": r})\n\n\n<DED><DED>def coingecko_normalize_symbol(symbol: str) -> str:\n    # keep digits, letters and dots, replace others by space\n    <IND>symbol = ''.join(c if c.isalnum() or c in ('.', '+') else ' ' for c in symbol)\n    return coingecko_normalize(symbol.upper())\n\n\n<DED>def coingecko_normalize_name(name: str) -> str:\n    # keep digits and letters, replace others by space (except when only composed by upper case letters, digits and dots)\n    <IND>if not all(c.isupper() or c.isdigit() or c == '.' for c in name):\n        <IND>name = ''.join(c if c.isalnum() else ' ' for c in name)\n    <DED>return coingecko_normalize(name)\n\n\n<DED>def coingecko_normalize(sym: str) -> str:\n    <IND>sym = sym.strip()\n    # do not concatenate numbers => separate them with a dot\n    sym = list(sym)\n    if len(sym) > 4:\n        <IND>for i in range(2, len(sym) - 1):\n            <IND>if sym[i] == ' ' and sym[i - 1].isdigit() and sym[i + 1].isdigit():\n                <IND>sym[i] = '.'\n    <DED><DED><DED>sym = ''.join(sym)\n    # concatenate space-separated words => use CamelCase to distinguish the words\n    if ' ' in sym:\n        <IND>if sum(c.islower() for c in sym):  # if there is at least one lower case letter\n            <IND>sym = ' '.join(word[0].upper() + word[1:] for word in sym.split())  # Just capitalize initial letter of each word\n        <DED>else:  # CoinGecko may provide full upper-case as for \"THE STONE COIN\"\n            <IND>sym = string.capwords(sym)  # capwords converts \"THE STONE COIN\" to \"The Stone Coin\"\n        <DED>sym = sym.replace(' ', '')  # concatenate words\n    <DED>return sym\n\n\n<DED>def is_name_short(coin: dict) -> bool:\n    <IND>\"\"\"return True if the coin name is enough short compared to the coin symbol.\"\"\"\n    return len(coin['name']) <= max(5, len(coin['symbol']) + 1)\n\n\n<DED>def has_many_caps(name: str) -> bool:\n    <IND>\"\"\"return True if the symbol contains enough upper case letters, False if empty.\"\"\"\n    return str and sum(c.islower() for c in name) < (len(name) / 2)\n\n\n<DED>def coingecko_normalize_all(coin: dict):\n    <IND>SYMBOL_TO_NORMALIZED = {'miota': 'IOTA'}\n    normalized = SYMBOL_TO_NORMALIZED.get(coin['symbol'])\n    if normalized:\n        <IND>coin['ns'] = coin['nn'] = normalized\n        return normalized\n\n    # ns = normalized symbol, nn = normalized name\n    <DED>coin['ns'] = coingecko_normalize_symbol(coin['symbol'])\n\n    ID_SUFFIX = '-bitcoin-token'\n    if coin['id'][-len(ID_SUFFIX):] == ID_SUFFIX:\n        <IND>coin['nn'] = 'BTC' + coin['ns']\n        return coin['nn']\n\n    <DED>name = coin['name']\n\n    prefixes = ('The ', 'the ')\n    for p in prefixes:\n        <IND>if name[:len(p)] == p:\n            <IND>coin['reduced-name'] = True\n            name = name[len(p):]\n            break\n\n    <DED><DED>suffixes = ('coin', 'coins', 'money', 'finance', 'protocol', 'reward', 'rewards', 'token')\n    for s in suffixes:\n        <IND>if len(name) > len(s) and name[-len(s):].lower() == s:\n            # but keep suffix when lower-case concatenated\n            <IND>if name[-len(s)].islower() and name[-len(s) - 1] != ' ':\n                <IND>continue\n            # also keep suffix to avoid confusing nam: \"Bitcoin Token\" -> \"Bitcoin\"\n            <DED>if name[:-len(s)].strip().lower() == 'bitcoin':\n                <IND>continue\n            <DED>coin['reduced-name'] = True\n            name = name[:-len(s)]\n            break\n\n    <DED><DED>coin['nn'] = coingecko_normalize_name(name)\n\n    if len(coin['nn']) < len(coin['ns']):\n        <IND>if 'reduced-name' in coin:\n            <IND>coin['reduced-name'] = False\n            name = coin['name']\n            coin['nn'] = coingecko_normalize_name(name)\n        <DED>elif not has_many_caps(name):\n            <IND>return coin['ns']\n\n    <DED><DED>if not coin['ns']:  # coin['symbol'] may be an emoji that is striped when normalized\n        <IND>return coin['nn']\n\n    <DED>if coin.get('reduced-name') and coin['ns'].upper() != coin['nn'].upper():\n        <IND>return coin['ns']\n\n    <DED>i = coin['nn'].find('.')  # if there is a dot in normalized name => prefer the normalized symbol\n    if i >= 0:\n        <IND>if i > 1 and coin['nn'][i - 1].isdigit() and coin['nn'][i + 1].isdigit():\n            <IND>pass  # except when the dot separates digits\n        <DED>else:\n            <IND>return coin['ns']\n\n    <DED><DED>if is_name_short(coin) and has_many_caps(name):\n        <IND>return coin['nn']\n\n    <DED>if 1.5 * len(coin['ns']) > len(coin['nn']) and any(c.islower() for c in coin['ns']):\n        <IND>return coin['nn']\n\n    <DED>return coin['ns']\n\n\n<DED>def coingecko_symbols() -> Dict[str, str]:\n    <IND>r = None\n    intermediate = defaultdict(list)\n    try:\n        <IND>r = requests.get('https://api.coingecko.com/api/v3/coins/list')\n        all_coins = r.json()\n        # First pass: generate & compare normalized symbol/name, and then select the most pertinent\n        for coin in all_coins:\n            <IND>normalized = coingecko_normalize_all(coin)\n            intermediate[normalized].append(coin)\n            # Above line keeps together the coins having the same normalized symbol.\n            # To reduce collision, the coin['name'] is sometimes used in lieu of the coin['symbol'].\n            # The coin['name'] is not capitalized because lower case letters may be meaningful: cETH, yUSD, DATx, zLOT\n    <DED><DED>except Exception as why:\n        <IND>raise_failure_explanation('COINGECKO', why, {\"\": r})\n\n    <DED>final = coingecko_second_pass(intermediate)\n    return coingecko_third_pass(final)\n\n\n<DED>def coingecko_second_pass(intermediate: Dict[str, List[dict]]) -> Dict[str, List[dict]]:\n    # Second pass: fixes most of the symbol collisions\n    <IND>final = defaultdict(list)\n    for normalized, coins in intermediate.items():\n        <IND>if len(coins) == 1:\n            <IND>final[normalized].append(coins[0])\n            continue\n        <DED>set_normalized = False\n        for i in range(len(coins)):\n            <IND>if normalized == coins[i]['nn']:\n                <IND>coin = coins.pop(i)\n                final[normalized].append(coin)\n                set_normalized = True\n                break\n        <DED><DED>rest: List[dict] = []\n        for coin in coins:\n            <IND>if '%' in coin['name']:\n                <IND>if len(coins) == 1:\n                    <IND>n = coin['ns']\n                <DED>else:\n                    <IND>n = coingecko_normalize_name(coin['id'])\n                <DED>final[n].append(coin)\n            <DED>else:\n                <IND>rest.append(coin)\n        <DED><DED>if not rest:\n            <IND>continue\n        <DED>if not set_normalized:\n            <IND>rest.sort(key=lambda coin: len(coin['nn']), reverse=True)  # sort by the length of the normalized name\n            coin = rest.pop(0)\n            final[normalized].append(coin)\n        <DED>for coin in rest:\n            <IND>if coin['nn'] not in intermediate:\n                <IND>n = coin['nn']\n            <DED>elif coin.get('reduced-name'):\n                <IND>n = coingecko_normalize_name(coin['name'])\n            <DED>else:\n                <IND>n = coingecko_normalize_name(coin['id'])\n            <DED>final[n].append(coin)\n    <DED><DED>return final\n\n\n<DED>def coingecko_third_pass(final: Dict[str, List[dict]]) -> Dict[str, str]:\n    # Third pass: fixes some remaining collisions and fills the result\n    <IND>symbols = {}\n    for normalized, coins in final.items():\n        <IND>if len(coins) == 1:\n            <IND>symbols[normalized] = coins[0]['id']\n            continue\n        <DED>set_normalized = False\n        for i in range(len(coins)):\n            <IND>if normalized == coins[i]['nn']:\n                <IND>coin = coins.pop(i)\n                symbols[normalized] = coin['id']\n                set_normalized = True\n                break\n        <DED><DED>rest: List[dict] = []\n        for coin in coins:\n            <IND>if '%' in coin['name']:\n                <IND>if len(coins) == 1:\n                    <IND>n = coin['ns']\n                <DED>else:\n                    <IND>n = coingecko_normalize_name(coin['id'])\n                <DED>symbols[n] = coin['id']\n            <DED>else:\n                <IND>rest.append(coin)\n        <DED><DED>if not rest:\n            <IND>continue\n        <DED>if not set_normalized:\n            <IND>rest.sort(key=lambda coin: len(coin['nn']), reverse=True)  # sort by the length of the normalized name\n            coin = rest.pop(0)\n            symbols[normalized] = coin['id']\n        <DED>for coin in rest:\n            <IND>if coin['nn'] not in final:\n                <IND>n = coin['nn']\n            <DED>elif coin.get('reduced-name'):\n                <IND>n = coingecko_normalize_name(coin['name'])\n            <DED>else:\n                <IND>n = coingecko_normalize_name(coin['id'])\n            <DED>symbols[n] = coin['id']\n    <DED><DED>return symbols\n\n\n<DED>def whale_alert_coins(key_id: str) -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get(f'https://api.whale-alert.io/v1/status?api_key={key_id}')\n        # Same symbols, but on different blockchains (for instance USDT), are naturally overwritten.\n        return {s.upper(): s for b in r.json()['blockchains'] for s in b['symbols'] if s}\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('WHALES_ALERT', why, {\"\": r})\n\n\n<DED><DED>_exchange_function_map = {\n    BITFINEX: bitfinex_symbols,\n    BITFLYER: bitflyer_symbols,\n    COINBASE: coinbase_symbols,\n    GEMINI: gemini_symbols,\n    HITBTC: hitbtc_symbols,\n    POLONIEX: poloniex_symbols,\n    PROBIT: probit_symbols,\n    BITSTAMP: bitstamp_symbols,\n    KRAKEN: kraken_symbols,\n    KRAKEN + 'REST': kraken_rest_symbols,\n    BINANCE: binance_symbols,\n    BINANCE_US: binance_us_symbols,\n    BINANCE_FUTURES: binance_futures_symbols,\n    BINANCE_DELIVERY: binance_delivery_symbols,\n    BLOCKCHAIN: blockchain_symbols,\n    EXX: exx_symbols,\n    HUOBI: huobi_symbols,\n    HUOBI_DM: huobi_dm_symbols,\n    HUOBI_SWAP: huobi_swap_symbols,\n    OKCOIN: okcoin_symbols,\n    OKEX: okex_symbols,\n    BYBIT: bybit_symbols,\n    FTX: ftx_symbols,\n    FTX_US: ftx_us_symbols,\n    BITTREX: bittrex_symbols,\n    BITCOINCOM: bitcoincom_symbols,\n    BITMAX: bitmax_symbols,\n    UPBIT: upbit_symbols,\n    GATEIO: gateio_symbols,\n    BITMEX: bitmex_symbols,\n    DERIBIT: deribit_symbols,\n    KRAKEN_FUTURES: kraken_future_symbols,\n    COINGECKO: coingecko_symbols,\n    WHALE_ALERT: whale_alert_coins\n}\n",
        "target_code_with_indent": "\nfrom typing import Dict, Tuple\n\n\nclass _Symbols:\n    <IND>def __init__(self):\n        <IND>self.data = {}\n\n    <DED>def set(self, exchange: str, normalized: dict, exchange_info: dict):\n        <IND>self.data[exchange] = {}\n        self.data[exchange]['normalized'] = normalized\n        self.data[exchange]['info'] = exchange_info\n\n    <DED>def get(self, exchange: str) -> Tuple[Dict, Dict]:\n        <IND>return self.data[exchange]['normalized'], self.data[exchange]['info']\n\n    <DED>def populated(self, exchange: str) -> bool:\n        <IND>return exchange in self.data\n\n\n<DED><DED>Symbols = _Symbols()\n"
      }
    ]
  },
  {
    "project": "bmoscon/cryptofeed",
    "commit": "3525dc8ce4d7836a9abaaa5662e58e5e27969a77",
    "filename": "cryptofeed/symbols.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/bmoscon-cryptofeed/cryptofeed/symbols.py",
    "file_hunks_size": 1,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "cryptofeed/symbols.py:466:8 Incompatible return type [7]: Expected `Dict[str, str]` but got implicit return value of `None`.",
    "message": " Expected `Dict[str, str]` but got implicit return value of `None`.",
    "rule_id": "Incompatible return type [7]",
    "warning_line_no": 466,
    "warning_line": "        raise_failure_explanation('BITCOINCOM', why, {\"\": r})",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "associated with this software.\n\n\nSymbol generation code for exchanges\n'''\n\nimport logging\nimport string\nimport time\nfrom collections import defaultdict\nfrom typing import Dict, List, Optional, Tuple\n\nimport requests\nfrom requests import Response\n\nfrom cryptofeed.defines import *\n\n\nLOG = logging.getLogger('feedhandler')\n\nSYMBOL_SEP = '-'\n\n_symbols_retrieval_cache: Dict[str, Dict[str, str]] = {}\n_exchange_info = defaultdict(lambda: defaultdict(dict))\n\n\n_kraken_futures_product_type = {\n    'FI': 'Inverse Futures',\n    'FV': 'Vanilla Futures',\n    'PI': 'Perpetual Inverse Futures',\n    'PV': 'Perpetual Vanilla Futures',\n    'IN': 'Real Time Index',\n    'RR': 'Reference Rate',\n}\n\n\ndef raise_failure_explanation(feed_id: str, exception: BaseException, responses: Dict[str, Optional[Response]]):\n    LOG.critical('%s: encountered %r while processing response from exchange API', feed_id, exception)\n    if len(responses) > 1:\n        LOG.critical('%s: content of one of the %s responses was unexpected', feed_id, len(responses))\n    for url, r in responses.items():\n        if url:\n            LOG.critical('%s: requested URL: %s', feed_id, url)\n        if r:\n            LOG.critical('%s: unexpected response: %s', feed_id, r.text)\n    raise ValueError(f'Cryptofeed stopped because of an unexpected response from {feed_id}') from exception\n\n\ndef set_symbol_separator(separator: str):\n    global SYMBOL_SEP\n    SYMBOL_SEP = separator\n\n\ndef get_symbol_separator() -> str:\n    global SYMBOL_SEP\n    return SYMBOL_SEP\n\n\ndef gen_symbols(exchange: str, key_id=None) -> Dict[str, str]:\n    if exchange not in _symbols_retrieval_cache:\n        LOG.info(\"%s: Getting list of symbols\", exchange)\n        symbols = _exchange_function_map[exchange](key_id) if key_id else _exchange_function_map[exchange]()\n        LOG.info(\"%s: %s symbols\", exchange, len(symbols))\n\n        # log all retrieved symbols using debug level\n        for normalized, exch_sym in sorted(symbols.items()):\n            LOG.debug('%s: id-from-exch -> normalized: %-35s-> %s', exchange, exch_sym, normalized)\n\n        _symbols_retrieval_cache[exchange] = symbols\n    return _symbols_retrieval_cache[exchange]\n\n\ndef _binance_symbols(endpoint: str, exchange: str):\n    r = None\n    try:\n        ret = {}\n        r = requests.get(endpoint)\n        for symbol in r.json()['symbols']:\n            if symbol.get('status', 'TRADING') != \"TRADING\":\n                continue\n            if symbol.get('contractStatus', 'TRADING') != \"TRADING\":\n                continue\n            split = len(symbol['baseAsset'])\n            normalized = symbol['symbol'][:split] + SYMBOL_SEP + symbol['symbol'][split:]\n            ret[normalized] = symbol['symbol']\n            _exchange_info[exchange]['tick_size'][normalized] = symbol['filters'][0]['tickSize']\n            if \"contractType\" in symbol:\n                _exchange_info[exchange]['contract_type'][normalized] = symbol['contractType']\n        return ret\n    except Exception as why:\n        raise_failure_explanation(exchange, why, {endpoint: r})\n\n\ndef binance_symbols() -> Dict[str, str]:\n    return _binance_symbols('https://api.binance.com/api/v3/exchangeInfo', BINANCE)\n\n\ndef binance_us_symbols() -> Dict[str, str]:\n    return _binance_symbols('https://api.binance.us/api/v3/exchangeInfo', BINANCE_US)\n\n\ndef binance_futures_symbols() -> Dict[str, str]:\n    base = _binance_symbols('https://fapi.binance.com/fapi/v1/exchangeInfo', BINANCE_FUTURES)\n    add = {}\n    for symbol, orig in base.items():\n        if \"_\" in orig:\n            continue\n        add[f\"{symbol}-PINDEX\"] = f\"p{orig}\"\n    base.update(add)\n    return base\n\n\ndef binance_delivery_symbols() -> Dict[str, str]:\n    return _binance_symbols('https://dapi.binance.com/dapi/v1/exchangeInfo', BINANCE_DELIVERY)\n\n\ndef bitfinex_symbols() -> Dict[str, str]:\n    # doc: https://docs.bitfinex.com/docs/ws-general#supported-pairs\n    r1 = r2 = None\n    try:\n        r1 = requests.get('https://api.bitfinex.com/v2/tickers?symbols=ALL')\n        r2 = requests.get('https://api-pub.bitfinex.com/v2/conf/pub:map:currency:sym')\n        tickers: List[List[str]] = r1.json()\n        norm: List[Tuple[str, str]] = r2.json()[0]\n        norm: Dict[str, str] = dict(norm)\n        for k, v in dict(norm).items():\n            if k[-2:] == 'F0' or '-' in v:  # Do not convert BTCF0 -> BTC or PBTCETH -> PBTC-ETH\n                del norm[k]\n        norm['BCHN'] = 'BCH'  # Bitfinex uses BCHN, other exchanges use BCH\n\n        ret = {}\n        for symbol in [t[0] for t in tickers]:\n            if symbol[0] == 'f':\n                normalized = norm.get(symbol[1:], symbol[1:])\n            else:\n                if len(symbol) == 7:\n                    base, quote = symbol[1:4], symbol[4:]\n                else:\n                    base, quote = symbol[1:].split(':')\n                    assert ':' in symbol\n                normalized = norm.get(base, base) + SYMBOL_SEP + norm.get(quote, quote)\n            ret[normalized.upper()] = symbol\n        return ret\n    except ValueError as why:\n        raise_failure_explanation('BITFINEX', why, {\"tickers?symbols=ALL\": r1, \"pub:map:currency:sym\": r2})\n\n\ndef bitflyer_symbols() -> Dict[str, str]:\n    endpoint = r = None\n    try:\n        ret = {}\n        endpoints = ['https://api.bitflyer.com/v1/getmarkets/eu', 'https://api.bitflyer.com/v1/getmarkets/usa', 'https://api.bitflyer.com/v1/getmarkets']\n        for endpoint in endpoints:\n            r = requests.get(endpoint)\n            for entry in r.json():\n                normalized = entry['product_code'].replace(\"_\", SYMBOL_SEP)\n                ret[normalized] = entry['product_code']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('BITFLYER', why, {endpoint: r})\n\n\ndef bybit_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.bybit.com/v2/public/symbols')\n        ret = {}\n        for symbol in r.json()['result']:\n            quote = symbol['quote_currency']\n            if not symbol['name'].endswith(quote):\n                base, contract = symbol['name'].split(quote)\n                normalized = f\"{base}{SYMBOL_SEP}{quote}-{contract}\"\n            else:\n                normalized = f\"{symbol['base_currency']}{SYMBOL_SEP}{quote}\"\n            ret[normalized] = symbol['name']\n            _exchange_info[BYBIT]['tick_size'][normalized] = symbol['price_filter']['tick_size']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('BYBIT', why, {\"\": r})\n\n\ndef _ftx_helper(endpoint: str, exchange: str):\n    r = None\n    try:\n        r = requests.get(endpoint)\n        ret = {}\n        for data in r.json()['result']:\n            normalized = data['name'].replace(\"/\", SYMBOL_SEP)\n            symbol = data['name']\n            ret[normalized] = symbol\n            _exchange_info[exchange]['tick_size'][normalized] = data['priceIncrement']\n        return ret\n    except Exception as why:\n        raise_failure_explanation(exchange, why, {endpoint: r})\n\n\ndef ftx_symbols() -> Dict[str, str]:\n    return _ftx_helper('https://ftx.com/api/markets', FTX)\n\n\ndef ftx_us_symbols() -> Dict[str, str]:\n    return _ftx_helper('https://ftx.us/api/markets', FTX_US)\n\n\ndef coinbase_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.pro.coinbase.com/products')\n        ret = {}\n        for data in r.json():\n            normalized = data['id'].replace(\"-\", SYMBOL_SEP)\n            ret[normalized] = data['id']\n            _exchange_info[COINBASE]['tick_size'][normalized] = data['quote_increment']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('COINBASE', why, {\"\": r})\n\n\ndef gemini_symbols(*args) -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.gemini.com/v1/symbols')\n        ret = {}\n        for symbol in r.json():\n            std = f\"{symbol[:-3]}{SYMBOL_SEP}{symbol[-3:]}\"\n            std = std.upper()\n            ret[std] = symbol.upper()\n        return ret\n    except Exception as why:\n        raise_failure_explanation('GEMINI', why, {\"\": r})\n\n\ndef hitbtc_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        ret = {}\n        r = requests.get('https://api.hitbtc.com/api/2/public/symbol')\n        for symbol in r.json():\n            split = len(symbol['baseCurrency'])\n            normalized = symbol['id'][:split] + SYMBOL_SEP + symbol['id'][split:]\n            ret[normalized] = symbol['id']\n            _exchange_info[HITBTC]['tick_size'][normalized] = symbol['tickSize']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('HITBTC', why, {\"\": r})\n\n\ndef poloniex_id_symbol_mapping():\n    r = None\n    try:\n        r = requests.get('https://poloniex.com/public?command=returnTicker')\n        symbols = r.json()\n        ret = {}\n        for symbol in symbols:\n            ret[symbols[symbol]['id']] = symbol\n        return ret\n    except Exception as why:\n        raise_failure_explanation('POLONIEX', why, {\"\": r})\n\n\ndef poloniex_symbols() -> Dict[str, str]:\n    ret = {}\n    for _, value in poloniex_id_symbol_mapping().items():\n        std = value.replace(\"STR\", \"XLM\")\n        quote, base = std.split(\"_\")\n        ret[quote + SYMBOL_SEP + base] = value\n    return ret\n\n\ndef bitstamp_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://www.bitstamp.net/api/v2/trading-pairs-info/')\n        ret = {}\n        for data in r.json():\n            normalized = data['name'].replace(\"/\", SYMBOL_SEP)\n            symbol = data['url_symbol']\n            ret[normalized] = symbol\n        return ret\n    except Exception as why:\n        raise_failure_explanation('BITSTAMP', why, {\"\": r})\n\n\ndef kraken_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.kraken.com/0/public/AssetPairs')\n        data = r.json()\n        ret = {}\n        for symbol in data['result']:\n            if 'wsname' not in data['result'][symbol] or '.d' in symbol:\n                # https://blog.kraken.com/post/259/introducing-the-kraken-dark-pool/\n                # .d is for dark pool symbols\n                continue\n\n            base, quote = data['result'][symbol]['wsname'].split(\"/\")\n\n            normalized = f\"{base}{SYMBOL_SEP}{quote}\"\n            exch = data['result'][symbol]['wsname']\n            normalized = normalized.replace('XBT', 'BTC')\n            normalized = normalized.replace('XDG', 'DOG')\n            ret[normalized] = exch\n        return ret\n    except Exception as why:\n        raise_failure_explanation('KRAKEN', why, {\"\": r})\n\n\ndef kraken_rest_symbols() -> Dict[str, str]:\n    return {normalized: exchange.replace(\"/\", \"\") for normalized, exchange in kraken_symbols().items()}\n\n\ndef exx_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.exx.com/data/v1/tickers')\n        exchange = [key.upper() for key in r.json().keys()]\n        symbols = [key.replace(\"_\", SYMBOL_SEP) for key in exchange]\n        return dict(zip(symbols, exchange))\n    except Exception as why:\n        raise_failure_explanation('EXX', why, {\"\": r})\n\n\ndef huobi_common_symbols(url: str):\n    r = None\n    try:\n        r = requests.get(url)\n        ret = {}\n        for e in r.json()['data']:\n            if e['state'] == 'offline':\n                continue\n            normalized = f\"{e['base-currency'].upper()}{SYMBOL_SEP}{e['quote-currency'].upper()}\"\n            symbol = f\"{e['base-currency']}{e['quote-currency']}\"\n            ret[normalized] = symbol\n        return ret\n    except Exception as why:\n        raise_failure_explanation('HUOBI', why, {url: r})\n\n\ndef huobi_symbols() -> Dict[str, str]:\n    return huobi_common_symbols('https://api.huobi.pro/v1/common/symbols')\n\n\ndef huobi_us_symbols() -> Dict[str, str]:\n    return huobi_common_symbols('https://api.huobi.com/v1/common/symbols')\n\n\ndef huobi_dm_symbols() -> Dict[str, str]:\n    \"\"\"\n    Mapping is, for instance: {\"BTC_CW\":\"BTC190816\"}\n    See comments in exchange/huobi_dm.py\n    \"\"\"\n    mapping = {\n        \"this_week\": \"CW\",\n        \"next_week\": \"NW\",\n        \"quarter\": \"CQ\",\n        \"next_quarter\": \"NQ\"\n    }\n    r = None\n    try:\n        r = requests.get('https://www.hbdm.com/api/v1/contract_contract_info')\n        symbols = {}\n        for e in r.json()['data']:\n            symbols[f\"{e['symbol']}_{mapping[e['contract_type']]}\"] = e['contract_code']\n            _exchange_info[HUOBI_DM]['tick_size'][e['contract_code']] = e['price_tick']\n            _exchange_info[HUOBI_DM]['short_code_mappings'][f\"{e['symbol']}_{mapping[e['contract_type']]}\"] = e['contract_code']\n        return symbols\n    except Exception as why:\n        raise_failure_explanation('HUOBI_DM', why, {\"\": r})\n\n\ndef huobi_swap_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.hbdm.com/swap-api/v1/swap_contract_info')\n        symbols = {}\n        for e in r.json()['data']:\n            symbols[e['contract_code']] = e['contract_code']\n            _exchange_info[HUOBI_SWAP]['tick_size'][e['contract_code']] = e['price_tick']\n        return symbols\n    except Exception as why:\n        raise_failure_explanation('HUOBI_SWAP', why, {\"\": r})\n\n\ndef okcoin_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://www.okcoin.com/api/spot/v3/instruments')\n        ret = {}\n        for e in r.json():\n            ret[e['instrument_id']] = e['instrument_id']\n            _exchange_info[OKCOIN]['tick_size'][e['instrument_id']] = e['tick_size']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('OKCOIN', why, {\"\": r})\n\n\ndef okex_symbols(*args) -> Dict[str, str]:\n    urls = ['https://www.okex.com/api/spot/v3/instruments',\n            'https://www.okex.com/api/swap/v3/instruments',\n            'https://www.okex.com/api/futures/v3/instruments']\n    urls = urls + okex_compute_option_urls_from_underlyings()\n\n    symbols: Dict[str, str] = {}\n    for u in urls:\n        time.sleep(0.2)\n        symbols.update(okex_symbols_from_one_url(u))\n\n    for symbol in symbols:\n        instrument_type = 'futures'\n        dash_count = symbol.count(get_symbol_separator())\n        if dash_count == 1:  # BTC-USDT\n            instrument_type = 'spot'\n        if dash_count == 4:  # BTC-USD-201225-35000-P\n            instrument_type = 'option'\n        if symbol[-4:] == \"SWAP\":  # BTC-USDT-SWAP\n            instrument_type = 'swap'\n\n        _exchange_info[OKEX]['instrument_type'][symbol] = instrument_type\n\n    return symbols\n\n\ndef okex_compute_option_urls_from_underlyings() -> List[str]:\n    url = 'https://www.okex.com/api/option/v3/underlying'\n    r = None\n    try:\n        r = requests.get(url)\n        return [f'https://www.okex.com/api/option/v3/instruments/{underlying}' for underlying in r.json()]\n    except Exception as why:\n        raise_failure_explanation('OKEX', why, {url: r})\n\n\ndef okex_symbols_from_one_url(url: str) -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get(url)\n        ret = {}\n        for e in r.json():\n            ret[e['instrument_id']] = e['instrument_id']\n            _exchange_info[OKEX]['tick_size'][e['instrument_id']] = e['tick_size']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('OKEX', why, {url: r})\n\n\ndef bittrex_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.bittrex.com/api/v1.1/public/getmarkets')\n        r = r.json()['result']\n        return {f\"{e['MarketCurrency']}{SYMBOL_SEP}{e['BaseCurrency']}\": e['MarketName'] for e in r if e['IsActive']}\n    except Exception as why:\n        raise_failure_explanation('BITTREX', why, {\"\": r})\n\n\ndef bitcoincom_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.exchange.bitcoin.com/api/2/public/symbol')\n        return {f\"{data['baseCurrency']}{SYMBOL_SEP}{data['quoteCurrency'].replace('USD', 'USDT')}\": data['id'] for data in r.json()}\n    except Exception as why:\n        raise_failure_explanation('BITCOINCOM', why, {\"\": r})\n\n\ndef bitmax_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://bitmax.io/api/pro/v1/products')\n        ret = {}\n        for entry in r.json()['data']:\n            # Only \"Normal\" status symbols are tradeable\n            if entry['status'] == 'Normal':\n                normalized = f\"{entry['baseAsset']}{SYMBOL_SEP}{entry['quoteAsset']}\"\n                ret[normalized] = entry['symbol']\n                _exchange_info[BITMAX]['tick_size'][normalized] = entry['tickSize']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('BITMAX', why, {\"\": r})\n\n\ndef upbit_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.upbit.com/v1/market/all')\n        return {f\"{data['market'].split('-')[1]}{SYMBOL_SEP}{data['market'].split('-')[0]}\": data['market'] for data in r.json()}\n    except Exception as why:\n        raise_failure_explanation('UPBIT', why, {\"\": r})\n\n\ndef blockchain_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get(\"https://api.blockchain.com/mercury-gateway/v1/instruments\")\n        return {data[\"symbol\"].replace(\"-\", SYMBOL_SEP): data[\"symbol\"] for data in r.json()}\n    except Exception as why:\n        raise_failure_explanation('BLOCKCHAIN', why, {\"\": r})\n\n\ndef gateio_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get(\"https://api.gateio.ws/api/v4/spot/currency_pairs\")\n        return {data[\"id\"].replace(\"_\", SYMBOL_SEP): data['id'] for data in r.json()}\n    except Exception as why:\n        raise_failure_explanation('GATEIO', why, {\"\": r})\n\n\ndef bitmex_symbols() -> Dict[str, str]:\n    r = None\n    ret = {}\n    try:\n        r = requests.get(\"https://www.bitmex.com/api/v1/instrument/active\")\n        for entry in r.json():\n            components = []\n            components.append(entry['rootSymbol'])\n            components.append(entry['quoteCurrency'])\n\n            if entry['expiry']:\n                components.append(entry['symbol'][-3:])\n\n            normalized = SYMBOL_SEP.join(components)\n            normalized = normalized.replace(\"XBT\", \"BTC\")\n            ret[normalized] = entry['symbol']\n            _exchange_info[BITMEX]['tick_size'][normalized] = entry['tickSize']\n\n            if entry['expiry']:\n                _exchange_info[BITMEX]['expiry'][normalized] = entry['expiry']\n\n        return ret\n    except Exception as why:\n        raise_failure_explanation('BITMEX', why, {\"\": r})\n\n\ndef deribit_symbols() -> Dict[str, str]:\n    url = r = None\n    ret = {}\n    try:\n        # TODO: get currencies from https://www.deribit.com/api/v2/public/get_currencies\n        currencies = ['BTC', 'ETH']\n        for c in currencies:\n            url = f\"https://www.deribit.com/api/v2/public/get_instruments?currency={c}&expired=false\"\n            r = requests.get(url)\n            for entry in r.json()['result']:\n                split = entry['instrument_name'].split(\"-\")\n                normalized = split[0] + SYMBOL_SEP + entry['quote_currency'] + \"-\" + '-'.join(split[1:])\n                ret[normalized] = entry['instrument_name']\n                _exchange_info[DERIBIT]['tick_size'][normalized] = entry['tick_size']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('DERIBIT', why, {url: r})\n\n\ndef kraken_future_symbols() -> Dict[str, str]:\n    r = None\n    ret = {}\n    try:\n        r = requests.get('https://futures.kraken.com/derivatives/api/v3/instruments')\n        data = r.json()['instruments']\n        for entry in data:\n            if not entry['tradeable']:\n                continue\n            normalized = entry['symbol'].upper().replace(\"_\", \"-\")\n            symbol = normalized[3:6] + SYMBOL_SEP + normalized[6:9]\n            normalized = normalized.replace(normalized[3:9], symbol)\n            normalized = normalized.replace('XBT', 'BTC')\n\n            _exchange_info[KRAKEN_FUTURES]['tick_size'][normalized] = entry['tickSize']\n            _exchange_info[KRAKEN_FUTURES]['contract_size'][normalized] = entry['contractSize']\n            _exchange_info[KRAKEN_FUTURES]['underlying'][normalized] = entry['underlying']\n            _exchange_info[KRAKEN_FUTURES]['product_type'][normalized] = _kraken_futures_product_type[normalized[:2]]\n            ret[normalized] = entry['symbol']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('KRAKEN_FUTURES', why, {\"\": r})\n\n\ndef probit_symbols() -> Dict[str, str]:\n    # doc: https://docs-en.probit.com/reference-link/market\n    r = None\n    try:\n        r = requests.get('https://api.probit.com/api/exchange/v1/market')\n        return {entry['id']: entry['id'] for entry in r.json()['data']}\n    except Exception as why:\n        raise_failure_explanation('PROBIT', why, {\"\": r})\n\n\ndef coingecko_normalize_symbol(symbol: str) -> str:\n    # keep digits, letters and dots, replace others by space\n    symbol = ''.join(c if c.isalnum() or c in ('.', '+') else ' ' for c in symbol)\n    return coingecko_normalize(symbol.upper())\n\n\ndef coingecko_normalize_name(name: str) -> str:\n    # keep digits and letters, replace others by space (except when only composed by upper case letters, digits and dots)\n    if not all(c.isupper() or c.isdigit() or c == '.' for c in name):\n        name = ''.join(c if c.isalnum() else ' ' for c in name)\n    return coingecko_normalize(name)\n\n\ndef coingecko_normalize(sym: str) -> str:\n    sym = sym.strip()\n    # do not concatenate numbers => separate them with a dot\n    sym = list(sym)\n    if len(sym) > 4:\n        for i in range(2, len(sym) - 1):\n            if sym[i] == ' ' and sym[i - 1].isdigit() and sym[i + 1].isdigit():\n                sym[i] = '.'\n    sym = ''.join(sym)\n    # concatenate space-separated words => use CamelCase to distinguish the words\n    if ' ' in sym:\n        if sum(c.islower() for c in sym):  # if there is at least one lower case letter\n            sym = ' '.join(word[0].upper() + word[1:] for word in sym.split())  # Just capitalize initial letter of each word\n        else:  # CoinGecko may provide full upper-case as for \"THE STONE COIN\"\n            sym = string.capwords(sym)  # capwords converts \"THE STONE COIN\" to \"The Stone Coin\"\n        sym = sym.replace(' ', '')  # concatenate words\n    return sym\n\n\ndef is_name_short(coin: dict) -> bool:\n    \"\"\"return True if the coin name is enough short compared to the coin symbol.\"\"\"\n    return len(coin['name']) <= max(5, len(coin['symbol']) + 1)\n\n\ndef has_many_caps(name: str) -> bool:\n    \"\"\"return True if the symbol contains enough upper case letters, False if empty.\"\"\"\n    return str and sum(c.islower() for c in name) < (len(name) / 2)\n\n\ndef coingecko_normalize_all(coin: dict):\n    SYMBOL_TO_NORMALIZED = {'miota': 'IOTA'}\n    normalized = SYMBOL_TO_NORMALIZED.get(coin['symbol'])\n    if normalized:\n        coin['ns'] = coin['nn'] = normalized\n        return normalized\n\n    # ns = normalized symbol, nn = normalized name\n    coin['ns'] = coingecko_normalize_symbol(coin['symbol'])\n\n    ID_SUFFIX = '-bitcoin-token'\n    if coin['id'][-len(ID_SUFFIX):] == ID_SUFFIX:\n        coin['nn'] = 'BTC' + coin['ns']\n        return coin['nn']\n\n    name = coin['name']\n\n    prefixes = ('The ', 'the ')\n    for p in prefixes:\n        if name[:len(p)] == p:\n            coin['reduced-name'] = True\n            name = name[len(p):]\n            break\n\n    suffixes = ('coin', 'coins', 'money', 'finance', 'protocol', 'reward', 'rewards', 'token')\n    for s in suffixes:\n        if len(name) > len(s) and name[-len(s):].lower() == s:\n            # but keep suffix when lower-case concatenated\n            if name[-len(s)].islower() and name[-len(s) - 1] != ' ':\n                continue\n            # also keep suffix to avoid confusing nam: \"Bitcoin Token\" -> \"Bitcoin\"\n            if name[:-len(s)].strip().lower() == 'bitcoin':\n                continue\n            coin['reduced-name'] = True\n            name = name[:-len(s)]\n            break\n\n    coin['nn'] = coingecko_normalize_name(name)\n\n    if len(coin['nn']) < len(coin['ns']):\n        if 'reduced-name' in coin:\n            coin['reduced-name'] = False\n            name = coin['name']\n            coin['nn'] = coingecko_normalize_name(name)\n        elif not has_many_caps(name):\n            return coin['ns']\n\n    if not coin['ns']:  # coin['symbol'] may be an emoji that is striped when normalized\n        return coin['nn']\n\n    if coin.get('reduced-name') and coin['ns'].upper() != coin['nn'].upper():\n        return coin['ns']\n\n    i = coin['nn'].find('.')  # if there is a dot in normalized name => prefer the normalized symbol\n    if i >= 0:\n        if i > 1 and coin['nn'][i - 1].isdigit() and coin['nn'][i + 1].isdigit():\n            pass  # except when the dot separates digits\n        else:\n            return coin['ns']\n\n    if is_name_short(coin) and has_many_caps(name):\n        return coin['nn']\n\n    if 1.5 * len(coin['ns']) > len(coin['nn']) and any(c.islower() for c in coin['ns']):\n        return coin['nn']\n\n    return coin['ns']\n\n\ndef coingecko_symbols() -> Dict[str, str]:\n    r = None\n    intermediate = defaultdict(list)\n    try:\n        r = requests.get('https://api.coingecko.com/api/v3/coins/list')\n        all_coins = r.json()\n        # First pass: generate & compare normalized symbol/name, and then select the most pertinent\n        for coin in all_coins:\n            normalized = coingecko_normalize_all(coin)\n            intermediate[normalized].append(coin)\n            # Above line keeps together the coins having the same normalized symbol.\n            # To reduce collision, the coin['name'] is sometimes used in lieu of the coin['symbol'].\n            # The coin['name'] is not capitalized because lower case letters may be meaningful: cETH, yUSD, DATx, zLOT\n    except Exception as why:\n        raise_failure_explanation('COINGECKO', why, {\"\": r})\n\n    final = coingecko_second_pass(intermediate)\n    return coingecko_third_pass(final)\n\n\ndef coingecko_second_pass(intermediate: Dict[str, List[dict]]) -> Dict[str, List[dict]]:\n    # Second pass: fixes most of the symbol collisions\n    final = defaultdict(list)\n    for normalized, coins in intermediate.items():\n        if len(coins) == 1:\n            final[normalized].append(coins[0])\n            continue\n        set_normalized = False\n        for i in range(len(coins)):\n            if normalized == coins[i]['nn']:\n                coin = coins.pop(i)\n                final[normalized].append(coin)\n                set_normalized = True\n                break\n        rest: List[dict] = []\n        for coin in coins:\n            if '%' in coin['name']:\n                if len(coins) == 1:\n                    n = coin['ns']\n                else:\n                    n = coingecko_normalize_name(coin['id'])\n                final[n].append(coin)\n            else:\n                rest.append(coin)\n        if not rest:\n            continue\n        if not set_normalized:\n            rest.sort(key=lambda coin: len(coin['nn']), reverse=True)  # sort by the length of the normalized name\n            coin = rest.pop(0)\n            final[normalized].append(coin)\n        for coin in rest:\n            if coin['nn'] not in intermediate:\n                n = coin['nn']\n            elif coin.get('reduced-name'):\n                n = coingecko_normalize_name(coin['name'])\n            else:\n                n = coingecko_normalize_name(coin['id'])\n            final[n].append(coin)\n    return final\n\n\ndef coingecko_third_pass(final: Dict[str, List[dict]]) -> Dict[str, str]:\n    # Third pass: fixes some remaining collisions and fills the result\n    symbols = {}\n    for normalized, coins in final.items():\n        if len(coins) == 1:\n            symbols[normalized] = coins[0]['id']\n            continue\n        set_normalized = False\n        for i in range(len(coins)):\n            if normalized == coins[i]['nn']:\n                coin = coins.pop(i)\n                symbols[normalized] = coin['id']\n                set_normalized = True\n                break\n        rest: List[dict] = []\n        for coin in coins:\n            if '%' in coin['name']:\n                if len(coins) == 1:\n                    n = coin['ns']\n                else:\n                    n = coingecko_normalize_name(coin['id'])\n                symbols[n] = coin['id']\n            else:\n                rest.append(coin)\n        if not rest:\n            continue\n        if not set_normalized:\n            rest.sort(key=lambda coin: len(coin['nn']), reverse=True)  # sort by the length of the normalized name\n            coin = rest.pop(0)\n            symbols[normalized] = coin['id']\n        for coin in rest:\n            if coin['nn'] not in final:\n                n = coin['nn']\n            elif coin.get('reduced-name'):\n                n = coingecko_normalize_name(coin['name'])\n            else:\n                n = coingecko_normalize_name(coin['id'])\n            symbols[n] = coin['id']\n    return symbols\n\n\ndef whale_alert_coins(key_id: str) -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get(f'https://api.whale-alert.io/v1/status?api_key={key_id}')\n        # Same symbols, but on different blockchains (for instance USDT), are naturally overwritten.\n        return {s.upper(): s for b in r.json()['blockchains'] for s in b['symbols'] if s}\n    except Exception as why:\n        raise_failure_explanation('WHALES_ALERT', why, {\"\": r})\n\n\n_exchange_function_map = {\n    BITFINEX: bitfinex_symbols,\n    BITFLYER: bitflyer_symbols,\n    COINBASE: coinbase_symbols,\n    GEMINI: gemini_symbols,\n    HITBTC: hitbtc_symbols,\n    POLONIEX: poloniex_symbols,\n    PROBIT: probit_symbols,\n    BITSTAMP: bitstamp_symbols,\n    KRAKEN: kraken_symbols,\n    KRAKEN + 'REST': kraken_rest_symbols,\n    BINANCE: binance_symbols,\n    BINANCE_US: binance_us_symbols,\n    BINANCE_FUTURES: binance_futures_symbols,\n    BINANCE_DELIVERY: binance_delivery_symbols,\n    BLOCKCHAIN: blockchain_symbols,\n    EXX: exx_symbols,\n    HUOBI: huobi_symbols,\n    HUOBI_DM: huobi_dm_symbols,\n    HUOBI_SWAP: huobi_swap_symbols,\n    OKCOIN: okcoin_symbols,\n    OKEX: okex_symbols,\n    BYBIT: bybit_symbols,\n    FTX: ftx_symbols,\n    FTX_US: ftx_us_symbols,\n    BITTREX: bittrex_symbols,\n    BITCOINCOM: bitcoincom_symbols,\n    BITMAX: bitmax_symbols,\n    UPBIT: upbit_symbols,\n    GATEIO: gateio_symbols,\n    BITMEX: bitmex_symbols,\n    DERIBIT: deribit_symbols,\n    KRAKEN_FUTURES: kraken_future_symbols,\n    COINGECKO: coingecko_symbols,\n    WHALE_ALERT: whale_alert_coins\n}\n",
        "source_code_len": 30534,
        "target_code": "associated with this software.\n'''\nfrom typing import Dict, Tuple\n\n\nclass _Symbols:\n    def __init__(self):\n        self.data = {}\n\n    def set(self, exchange: str, normalized: dict, exchange_info: dict):\n        self.data[exchange] = {}\n        self.data[exchange]['normalized'] = normalized\n        self.data[exchange]['info'] = exchange_info\n\n    def get(self, exchange: str) -> Tuple[Dict, Dict]:\n        return self.data[exchange]['normalized'], self.data[exchange]['info']\n\n    def populated(self, exchange: str) -> bool:\n        return exchange in self.data\n\n\nSymbols = _Symbols()\n",
        "target_code_len": 588,
        "diff_format": "@@ -5,845 +5,22 @@\n associated with this software.\n+'''\n+from typing import Dict, Tuple\n \n \n-Symbol generation code for exchanges\n-'''\n+class _Symbols:\n+    def __init__(self):\n+        self.data = {}\n \n-import logging\n-import string\n-import time\n-from collections import defaultdict\n-from typing import Dict, List, Optional, Tuple\n+    def set(self, exchange: str, normalized: dict, exchange_info: dict):\n+        self.data[exchange] = {}\n+        self.data[exchange]['normalized'] = normalized\n+        self.data[exchange]['info'] = exchange_info\n \n-import requests\n-from requests import Response\n+    def get(self, exchange: str) -> Tuple[Dict, Dict]:\n+        return self.data[exchange]['normalized'], self.data[exchange]['info']\n \n-from cryptofeed.defines import *\n+    def populated(self, exchange: str) -> bool:\n+        return exchange in self.data\n \n \n-LOG = logging.getLogger('feedhandler')\n-\n-SYMBOL_SEP = '-'\n-\n-_symbols_retrieval_cache: Dict[str, Dict[str, str]] = {}\n-_exchange_info = defaultdict(lambda: defaultdict(dict))\n-\n-\n-_kraken_futures_product_type = {\n-    'FI': 'Inverse Futures',\n-    'FV': 'Vanilla Futures',\n-    'PI': 'Perpetual Inverse Futures',\n-    'PV': 'Perpetual Vanilla Futures',\n-    'IN': 'Real Time Index',\n-    'RR': 'Reference Rate',\n-}\n-\n-\n-def raise_failure_explanation(feed_id: str, exception: BaseException, responses: Dict[str, Optional[Response]]):\n-    LOG.critical('%s: encountered %r while processing response from exchange API', feed_id, exception)\n-    if len(responses) > 1:\n-        LOG.critical('%s: content of one of the %s responses was unexpected', feed_id, len(responses))\n-    for url, r in responses.items():\n-        if url:\n-            LOG.critical('%s: requested URL: %s', feed_id, url)\n-        if r:\n-            LOG.critical('%s: unexpected response: %s', feed_id, r.text)\n-    raise ValueError(f'Cryptofeed stopped because of an unexpected response from {feed_id}') from exception\n-\n-\n-def set_symbol_separator(separator: str):\n-    global SYMBOL_SEP\n-    SYMBOL_SEP = separator\n-\n-\n-def get_symbol_separator() -> str:\n-    global SYMBOL_SEP\n-    return SYMBOL_SEP\n-\n-\n-def gen_symbols(exchange: str, key_id=None) -> Dict[str, str]:\n-    if exchange not in _symbols_retrieval_cache:\n-        LOG.info(\"%s: Getting list of symbols\", exchange)\n-        symbols = _exchange_function_map[exchange](key_id) if key_id else _exchange_function_map[exchange]()\n-        LOG.info(\"%s: %s symbols\", exchange, len(symbols))\n-\n-        # log all retrieved symbols using debug level\n-        for normalized, exch_sym in sorted(symbols.items()):\n-            LOG.debug('%s: id-from-exch -> normalized: %-35s-> %s', exchange, exch_sym, normalized)\n-\n-        _symbols_retrieval_cache[exchange] = symbols\n-    return _symbols_retrieval_cache[exchange]\n-\n-\n-def _binance_symbols(endpoint: str, exchange: str):\n-    r = None\n-    try:\n-        ret = {}\n-        r = requests.get(endpoint)\n-        for symbol in r.json()['symbols']:\n-            if symbol.get('status', 'TRADING') != \"TRADING\":\n-                continue\n-            if symbol.get('contractStatus', 'TRADING') != \"TRADING\":\n-                continue\n-            split = len(symbol['baseAsset'])\n-            normalized = symbol['symbol'][:split] + SYMBOL_SEP + symbol['symbol'][split:]\n-            ret[normalized] = symbol['symbol']\n-            _exchange_info[exchange]['tick_size'][normalized] = symbol['filters'][0]['tickSize']\n-            if \"contractType\" in symbol:\n-                _exchange_info[exchange]['contract_type'][normalized] = symbol['contractType']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation(exchange, why, {endpoint: r})\n-\n-\n-def binance_symbols() -> Dict[str, str]:\n-    return _binance_symbols('https://api.binance.com/api/v3/exchangeInfo', BINANCE)\n-\n-\n-def binance_us_symbols() -> Dict[str, str]:\n-    return _binance_symbols('https://api.binance.us/api/v3/exchangeInfo', BINANCE_US)\n-\n-\n-def binance_futures_symbols() -> Dict[str, str]:\n-    base = _binance_symbols('https://fapi.binance.com/fapi/v1/exchangeInfo', BINANCE_FUTURES)\n-    add = {}\n-    for symbol, orig in base.items():\n-        if \"_\" in orig:\n-            continue\n-        add[f\"{symbol}-PINDEX\"] = f\"p{orig}\"\n-    base.update(add)\n-    return base\n-\n-\n-def binance_delivery_symbols() -> Dict[str, str]:\n-    return _binance_symbols('https://dapi.binance.com/dapi/v1/exchangeInfo', BINANCE_DELIVERY)\n-\n-\n-def bitfinex_symbols() -> Dict[str, str]:\n-    # doc: https://docs.bitfinex.com/docs/ws-general#supported-pairs\n-    r1 = r2 = None\n-    try:\n-        r1 = requests.get('https://api.bitfinex.com/v2/tickers?symbols=ALL')\n-        r2 = requests.get('https://api-pub.bitfinex.com/v2/conf/pub:map:currency:sym')\n-        tickers: List[List[str]] = r1.json()\n-        norm: List[Tuple[str, str]] = r2.json()[0]\n-        norm: Dict[str, str] = dict(norm)\n-        for k, v in dict(norm).items():\n-            if k[-2:] == 'F0' or '-' in v:  # Do not convert BTCF0 -> BTC or PBTCETH -> PBTC-ETH\n-                del norm[k]\n-        norm['BCHN'] = 'BCH'  # Bitfinex uses BCHN, other exchanges use BCH\n-\n-        ret = {}\n-        for symbol in [t[0] for t in tickers]:\n-            if symbol[0] == 'f':\n-                normalized = norm.get(symbol[1:], symbol[1:])\n-            else:\n-                if len(symbol) == 7:\n-                    base, quote = symbol[1:4], symbol[4:]\n-                else:\n-                    base, quote = symbol[1:].split(':')\n-                    assert ':' in symbol\n-                normalized = norm.get(base, base) + SYMBOL_SEP + norm.get(quote, quote)\n-            ret[normalized.upper()] = symbol\n-        return ret\n-    except ValueError as why:\n-        raise_failure_explanation('BITFINEX', why, {\"tickers?symbols=ALL\": r1, \"pub:map:currency:sym\": r2})\n-\n-\n-def bitflyer_symbols() -> Dict[str, str]:\n-    endpoint = r = None\n-    try:\n-        ret = {}\n-        endpoints = ['https://api.bitflyer.com/v1/getmarkets/eu', 'https://api.bitflyer.com/v1/getmarkets/usa', 'https://api.bitflyer.com/v1/getmarkets']\n-        for endpoint in endpoints:\n-            r = requests.get(endpoint)\n-            for entry in r.json():\n-                normalized = entry['product_code'].replace(\"_\", SYMBOL_SEP)\n-                ret[normalized] = entry['product_code']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('BITFLYER', why, {endpoint: r})\n-\n-\n-def bybit_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.bybit.com/v2/public/symbols')\n-        ret = {}\n-        for symbol in r.json()['result']:\n-            quote = symbol['quote_currency']\n-            if not symbol['name'].endswith(quote):\n-                base, contract = symbol['name'].split(quote)\n-                normalized = f\"{base}{SYMBOL_SEP}{quote}-{contract}\"\n-            else:\n-                normalized = f\"{symbol['base_currency']}{SYMBOL_SEP}{quote}\"\n-            ret[normalized] = symbol['name']\n-            _exchange_info[BYBIT]['tick_size'][normalized] = symbol['price_filter']['tick_size']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('BYBIT', why, {\"\": r})\n-\n-\n-def _ftx_helper(endpoint: str, exchange: str):\n-    r = None\n-    try:\n-        r = requests.get(endpoint)\n-        ret = {}\n-        for data in r.json()['result']:\n-            normalized = data['name'].replace(\"/\", SYMBOL_SEP)\n-            symbol = data['name']\n-            ret[normalized] = symbol\n-            _exchange_info[exchange]['tick_size'][normalized] = data['priceIncrement']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation(exchange, why, {endpoint: r})\n-\n-\n-def ftx_symbols() -> Dict[str, str]:\n-    return _ftx_helper('https://ftx.com/api/markets', FTX)\n-\n-\n-def ftx_us_symbols() -> Dict[str, str]:\n-    return _ftx_helper('https://ftx.us/api/markets', FTX_US)\n-\n-\n-def coinbase_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.pro.coinbase.com/products')\n-        ret = {}\n-        for data in r.json():\n-            normalized = data['id'].replace(\"-\", SYMBOL_SEP)\n-            ret[normalized] = data['id']\n-            _exchange_info[COINBASE]['tick_size'][normalized] = data['quote_increment']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('COINBASE', why, {\"\": r})\n-\n-\n-def gemini_symbols(*args) -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.gemini.com/v1/symbols')\n-        ret = {}\n-        for symbol in r.json():\n-            std = f\"{symbol[:-3]}{SYMBOL_SEP}{symbol[-3:]}\"\n-            std = std.upper()\n-            ret[std] = symbol.upper()\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('GEMINI', why, {\"\": r})\n-\n-\n-def hitbtc_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        ret = {}\n-        r = requests.get('https://api.hitbtc.com/api/2/public/symbol')\n-        for symbol in r.json():\n-            split = len(symbol['baseCurrency'])\n-            normalized = symbol['id'][:split] + SYMBOL_SEP + symbol['id'][split:]\n-            ret[normalized] = symbol['id']\n-            _exchange_info[HITBTC]['tick_size'][normalized] = symbol['tickSize']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('HITBTC', why, {\"\": r})\n-\n-\n-def poloniex_id_symbol_mapping():\n-    r = None\n-    try:\n-        r = requests.get('https://poloniex.com/public?command=returnTicker')\n-        symbols = r.json()\n-        ret = {}\n-        for symbol in symbols:\n-            ret[symbols[symbol]['id']] = symbol\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('POLONIEX', why, {\"\": r})\n-\n-\n-def poloniex_symbols() -> Dict[str, str]:\n-    ret = {}\n-    for _, value in poloniex_id_symbol_mapping().items():\n-        std = value.replace(\"STR\", \"XLM\")\n-        quote, base = std.split(\"_\")\n-        ret[quote + SYMBOL_SEP + base] = value\n-    return ret\n-\n-\n-def bitstamp_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://www.bitstamp.net/api/v2/trading-pairs-info/')\n-        ret = {}\n-        for data in r.json():\n-            normalized = data['name'].replace(\"/\", SYMBOL_SEP)\n-            symbol = data['url_symbol']\n-            ret[normalized] = symbol\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('BITSTAMP', why, {\"\": r})\n-\n-\n-def kraken_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.kraken.com/0/public/AssetPairs')\n-        data = r.json()\n-        ret = {}\n-        for symbol in data['result']:\n-            if 'wsname' not in data['result'][symbol] or '.d' in symbol:\n-                # https://blog.kraken.com/post/259/introducing-the-kraken-dark-pool/\n-                # .d is for dark pool symbols\n-                continue\n-\n-            base, quote = data['result'][symbol]['wsname'].split(\"/\")\n-\n-            normalized = f\"{base}{SYMBOL_SEP}{quote}\"\n-            exch = data['result'][symbol]['wsname']\n-            normalized = normalized.replace('XBT', 'BTC')\n-            normalized = normalized.replace('XDG', 'DOG')\n-            ret[normalized] = exch\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('KRAKEN', why, {\"\": r})\n-\n-\n-def kraken_rest_symbols() -> Dict[str, str]:\n-    return {normalized: exchange.replace(\"/\", \"\") for normalized, exchange in kraken_symbols().items()}\n-\n-\n-def exx_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.exx.com/data/v1/tickers')\n-        exchange = [key.upper() for key in r.json().keys()]\n-        symbols = [key.replace(\"_\", SYMBOL_SEP) for key in exchange]\n-        return dict(zip(symbols, exchange))\n-    except Exception as why:\n-        raise_failure_explanation('EXX', why, {\"\": r})\n-\n-\n-def huobi_common_symbols(url: str):\n-    r = None\n-    try:\n-        r = requests.get(url)\n-        ret = {}\n-        for e in r.json()['data']:\n-            if e['state'] == 'offline':\n-                continue\n-            normalized = f\"{e['base-currency'].upper()}{SYMBOL_SEP}{e['quote-currency'].upper()}\"\n-            symbol = f\"{e['base-currency']}{e['quote-currency']}\"\n-            ret[normalized] = symbol\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('HUOBI', why, {url: r})\n-\n-\n-def huobi_symbols() -> Dict[str, str]:\n-    return huobi_common_symbols('https://api.huobi.pro/v1/common/symbols')\n-\n-\n-def huobi_us_symbols() -> Dict[str, str]:\n-    return huobi_common_symbols('https://api.huobi.com/v1/common/symbols')\n-\n-\n-def huobi_dm_symbols() -> Dict[str, str]:\n-    \"\"\"\n-    Mapping is, for instance: {\"BTC_CW\":\"BTC190816\"}\n-    See comments in exchange/huobi_dm.py\n-    \"\"\"\n-    mapping = {\n-        \"this_week\": \"CW\",\n-        \"next_week\": \"NW\",\n-        \"quarter\": \"CQ\",\n-        \"next_quarter\": \"NQ\"\n-    }\n-    r = None\n-    try:\n-        r = requests.get('https://www.hbdm.com/api/v1/contract_contract_info')\n-        symbols = {}\n-        for e in r.json()['data']:\n-            symbols[f\"{e['symbol']}_{mapping[e['contract_type']]}\"] = e['contract_code']\n-            _exchange_info[HUOBI_DM]['tick_size'][e['contract_code']] = e['price_tick']\n-            _exchange_info[HUOBI_DM]['short_code_mappings'][f\"{e['symbol']}_{mapping[e['contract_type']]}\"] = e['contract_code']\n-        return symbols\n-    except Exception as why:\n-        raise_failure_explanation('HUOBI_DM', why, {\"\": r})\n-\n-\n-def huobi_swap_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.hbdm.com/swap-api/v1/swap_contract_info')\n-        symbols = {}\n-        for e in r.json()['data']:\n-            symbols[e['contract_code']] = e['contract_code']\n-            _exchange_info[HUOBI_SWAP]['tick_size'][e['contract_code']] = e['price_tick']\n-        return symbols\n-    except Exception as why:\n-        raise_failure_explanation('HUOBI_SWAP', why, {\"\": r})\n-\n-\n-def okcoin_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://www.okcoin.com/api/spot/v3/instruments')\n-        ret = {}\n-        for e in r.json():\n-            ret[e['instrument_id']] = e['instrument_id']\n-            _exchange_info[OKCOIN]['tick_size'][e['instrument_id']] = e['tick_size']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('OKCOIN', why, {\"\": r})\n-\n-\n-def okex_symbols(*args) -> Dict[str, str]:\n-    urls = ['https://www.okex.com/api/spot/v3/instruments',\n-            'https://www.okex.com/api/swap/v3/instruments',\n-            'https://www.okex.com/api/futures/v3/instruments']\n-    urls = urls + okex_compute_option_urls_from_underlyings()\n-\n-    symbols: Dict[str, str] = {}\n-    for u in urls:\n-        time.sleep(0.2)\n-        symbols.update(okex_symbols_from_one_url(u))\n-\n-    for symbol in symbols:\n-        instrument_type = 'futures'\n-        dash_count = symbol.count(get_symbol_separator())\n-        if dash_count == 1:  # BTC-USDT\n-            instrument_type = 'spot'\n-        if dash_count == 4:  # BTC-USD-201225-35000-P\n-            instrument_type = 'option'\n-        if symbol[-4:] == \"SWAP\":  # BTC-USDT-SWAP\n-            instrument_type = 'swap'\n-\n-        _exchange_info[OKEX]['instrument_type'][symbol] = instrument_type\n-\n-    return symbols\n-\n-\n-def okex_compute_option_urls_from_underlyings() -> List[str]:\n-    url = 'https://www.okex.com/api/option/v3/underlying'\n-    r = None\n-    try:\n-        r = requests.get(url)\n-        return [f'https://www.okex.com/api/option/v3/instruments/{underlying}' for underlying in r.json()]\n-    except Exception as why:\n-        raise_failure_explanation('OKEX', why, {url: r})\n-\n-\n-def okex_symbols_from_one_url(url: str) -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get(url)\n-        ret = {}\n-        for e in r.json():\n-            ret[e['instrument_id']] = e['instrument_id']\n-            _exchange_info[OKEX]['tick_size'][e['instrument_id']] = e['tick_size']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('OKEX', why, {url: r})\n-\n-\n-def bittrex_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.bittrex.com/api/v1.1/public/getmarkets')\n-        r = r.json()['result']\n-        return {f\"{e['MarketCurrency']}{SYMBOL_SEP}{e['BaseCurrency']}\": e['MarketName'] for e in r if e['IsActive']}\n-    except Exception as why:\n-        raise_failure_explanation('BITTREX', why, {\"\": r})\n-\n-\n-def bitcoincom_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.exchange.bitcoin.com/api/2/public/symbol')\n-        return {f\"{data['baseCurrency']}{SYMBOL_SEP}{data['quoteCurrency'].replace('USD', 'USDT')}\": data['id'] for data in r.json()}\n-    except Exception as why:\n-        raise_failure_explanation('BITCOINCOM', why, {\"\": r})\n-\n-\n-def bitmax_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://bitmax.io/api/pro/v1/products')\n-        ret = {}\n-        for entry in r.json()['data']:\n-            # Only \"Normal\" status symbols are tradeable\n-            if entry['status'] == 'Normal':\n-                normalized = f\"{entry['baseAsset']}{SYMBOL_SEP}{entry['quoteAsset']}\"\n-                ret[normalized] = entry['symbol']\n-                _exchange_info[BITMAX]['tick_size'][normalized] = entry['tickSize']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('BITMAX', why, {\"\": r})\n-\n-\n-def upbit_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.upbit.com/v1/market/all')\n-        return {f\"{data['market'].split('-')[1]}{SYMBOL_SEP}{data['market'].split('-')[0]}\": data['market'] for data in r.json()}\n-    except Exception as why:\n-        raise_failure_explanation('UPBIT', why, {\"\": r})\n-\n-\n-def blockchain_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get(\"https://api.blockchain.com/mercury-gateway/v1/instruments\")\n-        return {data[\"symbol\"].replace(\"-\", SYMBOL_SEP): data[\"symbol\"] for data in r.json()}\n-    except Exception as why:\n-        raise_failure_explanation('BLOCKCHAIN', why, {\"\": r})\n-\n-\n-def gateio_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get(\"https://api.gateio.ws/api/v4/spot/currency_pairs\")\n-        return {data[\"id\"].replace(\"_\", SYMBOL_SEP): data['id'] for data in r.json()}\n-    except Exception as why:\n-        raise_failure_explanation('GATEIO', why, {\"\": r})\n-\n-\n-def bitmex_symbols() -> Dict[str, str]:\n-    r = None\n-    ret = {}\n-    try:\n-        r = requests.get(\"https://www.bitmex.com/api/v1/instrument/active\")\n-        for entry in r.json():\n-            components = []\n-            components.append(entry['rootSymbol'])\n-            components.append(entry['quoteCurrency'])\n-\n-            if entry['expiry']:\n-                components.append(entry['symbol'][-3:])\n-\n-            normalized = SYMBOL_SEP.join(components)\n-            normalized = normalized.replace(\"XBT\", \"BTC\")\n-            ret[normalized] = entry['symbol']\n-            _exchange_info[BITMEX]['tick_size'][normalized] = entry['tickSize']\n-\n-            if entry['expiry']:\n-                _exchange_info[BITMEX]['expiry'][normalized] = entry['expiry']\n-\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('BITMEX', why, {\"\": r})\n-\n-\n-def deribit_symbols() -> Dict[str, str]:\n-    url = r = None\n-    ret = {}\n-    try:\n-        # TODO: get currencies from https://www.deribit.com/api/v2/public/get_currencies\n-        currencies = ['BTC', 'ETH']\n-        for c in currencies:\n-            url = f\"https://www.deribit.com/api/v2/public/get_instruments?currency={c}&expired=false\"\n-            r = requests.get(url)\n-            for entry in r.json()['result']:\n-                split = entry['instrument_name'].split(\"-\")\n-                normalized = split[0] + SYMBOL_SEP + entry['quote_currency'] + \"-\" + '-'.join(split[1:])\n-                ret[normalized] = entry['instrument_name']\n-                _exchange_info[DERIBIT]['tick_size'][normalized] = entry['tick_size']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('DERIBIT', why, {url: r})\n-\n-\n-def kraken_future_symbols() -> Dict[str, str]:\n-    r = None\n-    ret = {}\n-    try:\n-        r = requests.get('https://futures.kraken.com/derivatives/api/v3/instruments')\n-        data = r.json()['instruments']\n-        for entry in data:\n-            if not entry['tradeable']:\n-                continue\n-            normalized = entry['symbol'].upper().replace(\"_\", \"-\")\n-            symbol = normalized[3:6] + SYMBOL_SEP + normalized[6:9]\n-            normalized = normalized.replace(normalized[3:9], symbol)\n-            normalized = normalized.replace('XBT', 'BTC')\n-\n-            _exchange_info[KRAKEN_FUTURES]['tick_size'][normalized] = entry['tickSize']\n-            _exchange_info[KRAKEN_FUTURES]['contract_size'][normalized] = entry['contractSize']\n-            _exchange_info[KRAKEN_FUTURES]['underlying'][normalized] = entry['underlying']\n-            _exchange_info[KRAKEN_FUTURES]['product_type'][normalized] = _kraken_futures_product_type[normalized[:2]]\n-            ret[normalized] = entry['symbol']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('KRAKEN_FUTURES', why, {\"\": r})\n-\n-\n-def probit_symbols() -> Dict[str, str]:\n-    # doc: https://docs-en.probit.com/reference-link/market\n-    r = None\n-    try:\n-        r = requests.get('https://api.probit.com/api/exchange/v1/market')\n-        return {entry['id']: entry['id'] for entry in r.json()['data']}\n-    except Exception as why:\n-        raise_failure_explanation('PROBIT', why, {\"\": r})\n-\n-\n-def coingecko_normalize_symbol(symbol: str) -> str:\n-    # keep digits, letters and dots, replace others by space\n-    symbol = ''.join(c if c.isalnum() or c in ('.', '+') else ' ' for c in symbol)\n-    return coingecko_normalize(symbol.upper())\n-\n-\n-def coingecko_normalize_name(name: str) -> str:\n-    # keep digits and letters, replace others by space (except when only composed by upper case letters, digits and dots)\n-    if not all(c.isupper() or c.isdigit() or c == '.' for c in name):\n-        name = ''.join(c if c.isalnum() else ' ' for c in name)\n-    return coingecko_normalize(name)\n-\n-\n-def coingecko_normalize(sym: str) -> str:\n-    sym = sym.strip()\n-    # do not concatenate numbers => separate them with a dot\n-    sym = list(sym)\n-    if len(sym) > 4:\n-        for i in range(2, len(sym) - 1):\n-            if sym[i] == ' ' and sym[i - 1].isdigit() and sym[i + 1].isdigit():\n-                sym[i] = '.'\n-    sym = ''.join(sym)\n-    # concatenate space-separated words => use CamelCase to distinguish the words\n-    if ' ' in sym:\n-        if sum(c.islower() for c in sym):  # if there is at least one lower case letter\n-            sym = ' '.join(word[0].upper() + word[1:] for word in sym.split())  # Just capitalize initial letter of each word\n-        else:  # CoinGecko may provide full upper-case as for \"THE STONE COIN\"\n-            sym = string.capwords(sym)  # capwords converts \"THE STONE COIN\" to \"The Stone Coin\"\n-        sym = sym.replace(' ', '')  # concatenate words\n-    return sym\n-\n-\n-def is_name_short(coin: dict) -> bool:\n-    \"\"\"return True if the coin name is enough short compared to the coin symbol.\"\"\"\n-    return len(coin['name']) <= max(5, len(coin['symbol']) + 1)\n-\n-\n-def has_many_caps(name: str) -> bool:\n-    \"\"\"return True if the symbol contains enough upper case letters, False if empty.\"\"\"\n-    return str and sum(c.islower() for c in name) < (len(name) / 2)\n-\n-\n-def coingecko_normalize_all(coin: dict):\n-    SYMBOL_TO_NORMALIZED = {'miota': 'IOTA'}\n-    normalized = SYMBOL_TO_NORMALIZED.get(coin['symbol'])\n-    if normalized:\n-        coin['ns'] = coin['nn'] = normalized\n-        return normalized\n-\n-    # ns = normalized symbol, nn = normalized name\n-    coin['ns'] = coingecko_normalize_symbol(coin['symbol'])\n-\n-    ID_SUFFIX = '-bitcoin-token'\n-    if coin['id'][-len(ID_SUFFIX):] == ID_SUFFIX:\n-        coin['nn'] = 'BTC' + coin['ns']\n-        return coin['nn']\n-\n-    name = coin['name']\n-\n-    prefixes = ('The ', 'the ')\n-    for p in prefixes:\n-        if name[:len(p)] == p:\n-            coin['reduced-name'] = True\n-            name = name[len(p):]\n-            break\n-\n-    suffixes = ('coin', 'coins', 'money', 'finance', 'protocol', 'reward', 'rewards', 'token')\n-    for s in suffixes:\n-        if len(name) > len(s) and name[-len(s):].lower() == s:\n-            # but keep suffix when lower-case concatenated\n-            if name[-len(s)].islower() and name[-len(s) - 1] != ' ':\n-                continue\n-            # also keep suffix to avoid confusing nam: \"Bitcoin Token\" -> \"Bitcoin\"\n-            if name[:-len(s)].strip().lower() == 'bitcoin':\n-                continue\n-            coin['reduced-name'] = True\n-            name = name[:-len(s)]\n-            break\n-\n-    coin['nn'] = coingecko_normalize_name(name)\n-\n-    if len(coin['nn']) < len(coin['ns']):\n-        if 'reduced-name' in coin:\n-            coin['reduced-name'] = False\n-            name = coin['name']\n-            coin['nn'] = coingecko_normalize_name(name)\n-        elif not has_many_caps(name):\n-            return coin['ns']\n-\n-    if not coin['ns']:  # coin['symbol'] may be an emoji that is striped when normalized\n-        return coin['nn']\n-\n-    if coin.get('reduced-name') and coin['ns'].upper() != coin['nn'].upper():\n-        return coin['ns']\n-\n-    i = coin['nn'].find('.')  # if there is a dot in normalized name => prefer the normalized symbol\n-    if i >= 0:\n-        if i > 1 and coin['nn'][i - 1].isdigit() and coin['nn'][i + 1].isdigit():\n-            pass  # except when the dot separates digits\n-        else:\n-            return coin['ns']\n-\n-    if is_name_short(coin) and has_many_caps(name):\n-        return coin['nn']\n-\n-    if 1.5 * len(coin['ns']) > len(coin['nn']) and any(c.islower() for c in coin['ns']):\n-        return coin['nn']\n-\n-    return coin['ns']\n-\n-\n-def coingecko_symbols() -> Dict[str, str]:\n-    r = None\n-    intermediate = defaultdict(list)\n-    try:\n-        r = requests.get('https://api.coingecko.com/api/v3/coins/list')\n-        all_coins = r.json()\n-        # First pass: generate & compare normalized symbol/name, and then select the most pertinent\n-        for coin in all_coins:\n-            normalized = coingecko_normalize_all(coin)\n-            intermediate[normalized].append(coin)\n-            # Above line keeps together the coins having the same normalized symbol.\n-            # To reduce collision, the coin['name'] is sometimes used in lieu of the coin['symbol'].\n-            # The coin['name'] is not capitalized because lower case letters may be meaningful: cETH, yUSD, DATx, zLOT\n-    except Exception as why:\n-        raise_failure_explanation('COINGECKO', why, {\"\": r})\n-\n-    final = coingecko_second_pass(intermediate)\n-    return coingecko_third_pass(final)\n-\n-\n-def coingecko_second_pass(intermediate: Dict[str, List[dict]]) -> Dict[str, List[dict]]:\n-    # Second pass: fixes most of the symbol collisions\n-    final = defaultdict(list)\n-    for normalized, coins in intermediate.items():\n-        if len(coins) == 1:\n-            final[normalized].append(coins[0])\n-            continue\n-        set_normalized = False\n-        for i in range(len(coins)):\n-            if normalized == coins[i]['nn']:\n-                coin = coins.pop(i)\n-                final[normalized].append(coin)\n-                set_normalized = True\n-                break\n-        rest: List[dict] = []\n-        for coin in coins:\n-            if '%' in coin['name']:\n-                if len(coins) == 1:\n-                    n = coin['ns']\n-                else:\n-                    n = coingecko_normalize_name(coin['id'])\n-                final[n].append(coin)\n-            else:\n-                rest.append(coin)\n-        if not rest:\n-            continue\n-        if not set_normalized:\n-            rest.sort(key=lambda coin: len(coin['nn']), reverse=True)  # sort by the length of the normalized name\n-            coin = rest.pop(0)\n-            final[normalized].append(coin)\n-        for coin in rest:\n-            if coin['nn'] not in intermediate:\n-                n = coin['nn']\n-            elif coin.get('reduced-name'):\n-                n = coingecko_normalize_name(coin['name'])\n-            else:\n-                n = coingecko_normalize_name(coin['id'])\n-            final[n].append(coin)\n-    return final\n-\n-\n-def coingecko_third_pass(final: Dict[str, List[dict]]) -> Dict[str, str]:\n-    # Third pass: fixes some remaining collisions and fills the result\n-    symbols = {}\n-    for normalized, coins in final.items():\n-        if len(coins) == 1:\n-            symbols[normalized] = coins[0]['id']\n-            continue\n-        set_normalized = False\n-        for i in range(len(coins)):\n-            if normalized == coins[i]['nn']:\n-                coin = coins.pop(i)\n-                symbols[normalized] = coin['id']\n-                set_normalized = True\n-                break\n-        rest: List[dict] = []\n-        for coin in coins:\n-            if '%' in coin['name']:\n-                if len(coins) == 1:\n-                    n = coin['ns']\n-                else:\n-                    n = coingecko_normalize_name(coin['id'])\n-                symbols[n] = coin['id']\n-            else:\n-                rest.append(coin)\n-        if not rest:\n-            continue\n-        if not set_normalized:\n-            rest.sort(key=lambda coin: len(coin['nn']), reverse=True)  # sort by the length of the normalized name\n-            coin = rest.pop(0)\n-            symbols[normalized] = coin['id']\n-        for coin in rest:\n-            if coin['nn'] not in final:\n-                n = coin['nn']\n-            elif coin.get('reduced-name'):\n-                n = coingecko_normalize_name(coin['name'])\n-            else:\n-                n = coingecko_normalize_name(coin['id'])\n-            symbols[n] = coin['id']\n-    return symbols\n-\n-\n-def whale_alert_coins(key_id: str) -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get(f'https://api.whale-alert.io/v1/status?api_key={key_id}')\n-        # Same symbols, but on different blockchains (for instance USDT), are naturally overwritten.\n-        return {s.upper(): s for b in r.json()['blockchains'] for s in b['symbols'] if s}\n-    except Exception as why:\n-        raise_failure_explanation('WHALES_ALERT', why, {\"\": r})\n-\n-\n-_exchange_function_map = {\n-    BITFINEX: bitfinex_symbols,\n-    BITFLYER: bitflyer_symbols,\n-    COINBASE: coinbase_symbols,\n-    GEMINI: gemini_symbols,\n-    HITBTC: hitbtc_symbols,\n-    POLONIEX: poloniex_symbols,\n-    PROBIT: probit_symbols,\n-    BITSTAMP: bitstamp_symbols,\n-    KRAKEN: kraken_symbols,\n-    KRAKEN + 'REST': kraken_rest_symbols,\n-    BINANCE: binance_symbols,\n-    BINANCE_US: binance_us_symbols,\n-    BINANCE_FUTURES: binance_futures_symbols,\n-    BINANCE_DELIVERY: binance_delivery_symbols,\n-    BLOCKCHAIN: blockchain_symbols,\n-    EXX: exx_symbols,\n-    HUOBI: huobi_symbols,\n-    HUOBI_DM: huobi_dm_symbols,\n-    HUOBI_SWAP: huobi_swap_symbols,\n-    OKCOIN: okcoin_symbols,\n-    OKEX: okex_symbols,\n-    BYBIT: bybit_symbols,\n-    FTX: ftx_symbols,\n-    FTX_US: ftx_us_symbols,\n-    BITTREX: bittrex_symbols,\n-    BITCOINCOM: bitcoincom_symbols,\n-    BITMAX: bitmax_symbols,\n-    UPBIT: upbit_symbols,\n-    GATEIO: gateio_symbols,\n-    BITMEX: bitmex_symbols,\n-    DERIBIT: deribit_symbols,\n-    KRAKEN_FUTURES: kraken_future_symbols,\n-    COINGECKO: coingecko_symbols,\n-    WHALE_ALERT: whale_alert_coins\n-}\n+Symbols = _Symbols()\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\n\nimport logging\nimport string\nimport time\nfrom collections import defaultdict\nfrom typing import Dict, List, Optional, Tuple\n\nimport requests\nfrom requests import Response\n\nfrom cryptofeed.defines import *\n\n\nLOG = logging.getLogger('feedhandler')\n\nSYMBOL_SEP = '-'\n\n_symbols_retrieval_cache: Dict[str, Dict[str, str]] = {}\n_exchange_info = defaultdict(lambda: defaultdict(dict))\n\n\n_kraken_futures_product_type = {\n    'FI': 'Inverse Futures',\n    'FV': 'Vanilla Futures',\n    'PI': 'Perpetual Inverse Futures',\n    'PV': 'Perpetual Vanilla Futures',\n    'IN': 'Real Time Index',\n    'RR': 'Reference Rate',\n}\n\n\ndef raise_failure_explanation(feed_id: str, exception: BaseException, responses: Dict[str, Optional[Response]]):\n    <IND>LOG.critical('%s: encountered %r while processing response from exchange API', feed_id, exception)\n    if len(responses) > 1:\n        <IND>LOG.critical('%s: content of one of the %s responses was unexpected', feed_id, len(responses))\n    <DED>for url, r in responses.items():\n        <IND>if url:\n            <IND>LOG.critical('%s: requested URL: %s', feed_id, url)\n        <DED>if r:\n            <IND>LOG.critical('%s: unexpected response: %s', feed_id, r.text)\n    <DED><DED>raise ValueError(f'Cryptofeed stopped because of an unexpected response from {feed_id}') from exception\n\n\n<DED>def set_symbol_separator(separator: str):\n    <IND>global SYMBOL_SEP\n    SYMBOL_SEP = separator\n\n\n<DED>def get_symbol_separator() -> str:\n    <IND>global SYMBOL_SEP\n    return SYMBOL_SEP\n\n\n<DED>def gen_symbols(exchange: str, key_id=None) -> Dict[str, str]:\n    <IND>if exchange not in _symbols_retrieval_cache:\n        <IND>LOG.info(\"%s: Getting list of symbols\", exchange)\n        symbols = _exchange_function_map[exchange](key_id) if key_id else _exchange_function_map[exchange]()\n        LOG.info(\"%s: %s symbols\", exchange, len(symbols))\n\n        # log all retrieved symbols using debug level\n        for normalized, exch_sym in sorted(symbols.items()):\n            <IND>LOG.debug('%s: id-from-exch -> normalized: %-35s-> %s', exchange, exch_sym, normalized)\n\n        <DED>_symbols_retrieval_cache[exchange] = symbols\n    <DED>return _symbols_retrieval_cache[exchange]\n\n\n<DED>def _binance_symbols(endpoint: str, exchange: str):\n    <IND>r = None\n    try:\n        <IND>ret = {}\n        r = requests.get(endpoint)\n        for symbol in r.json()['symbols']:\n            <IND>if symbol.get('status', 'TRADING') != \"TRADING\":\n                <IND>continue\n            <DED>if symbol.get('contractStatus', 'TRADING') != \"TRADING\":\n                <IND>continue\n            <DED>split = len(symbol['baseAsset'])\n            normalized = symbol['symbol'][:split] + SYMBOL_SEP + symbol['symbol'][split:]\n            ret[normalized] = symbol['symbol']\n            _exchange_info[exchange]['tick_size'][normalized] = symbol['filters'][0]['tickSize']\n            if \"contractType\" in symbol:\n                <IND>_exchange_info[exchange]['contract_type'][normalized] = symbol['contractType']\n        <DED><DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation(exchange, why, {endpoint: r})\n\n\n<DED><DED>def binance_symbols() -> Dict[str, str]:\n    <IND>return _binance_symbols('https://api.binance.com/api/v3/exchangeInfo', BINANCE)\n\n\n<DED>def binance_us_symbols() -> Dict[str, str]:\n    <IND>return _binance_symbols('https://api.binance.us/api/v3/exchangeInfo', BINANCE_US)\n\n\n<DED>def binance_futures_symbols() -> Dict[str, str]:\n    <IND>base = _binance_symbols('https://fapi.binance.com/fapi/v1/exchangeInfo', BINANCE_FUTURES)\n    add = {}\n    for symbol, orig in base.items():\n        <IND>if \"_\" in orig:\n            <IND>continue\n        <DED>add[f\"{symbol}-PINDEX\"] = f\"p{orig}\"\n    <DED>base.update(add)\n    return base\n\n\n<DED>def binance_delivery_symbols() -> Dict[str, str]:\n    <IND>return _binance_symbols('https://dapi.binance.com/dapi/v1/exchangeInfo', BINANCE_DELIVERY)\n\n\n<DED>def bitfinex_symbols() -> Dict[str, str]:\n    # doc: https://docs.bitfinex.com/docs/ws-general#supported-pairs\n    <IND>r1 = r2 = None\n    try:\n        <IND>r1 = requests.get('https://api.bitfinex.com/v2/tickers?symbols=ALL')\n        r2 = requests.get('https://api-pub.bitfinex.com/v2/conf/pub:map:currency:sym')\n        tickers: List[List[str]] = r1.json()\n        norm: List[Tuple[str, str]] = r2.json()[0]\n        norm: Dict[str, str] = dict(norm)\n        for k, v in dict(norm).items():\n            <IND>if k[-2:] == 'F0' or '-' in v:  # Do not convert BTCF0 -> BTC or PBTCETH -> PBTC-ETH\n                <IND>del norm[k]\n        <DED><DED>norm['BCHN'] = 'BCH'  # Bitfinex uses BCHN, other exchanges use BCH\n\n        ret = {}\n        for symbol in [t[0] for t in tickers]:\n            <IND>if symbol[0] == 'f':\n                <IND>normalized = norm.get(symbol[1:], symbol[1:])\n            <DED>else:\n                <IND>if len(symbol) == 7:\n                    <IND>base, quote = symbol[1:4], symbol[4:]\n                <DED>else:\n                    <IND>base, quote = symbol[1:].split(':')\n                    assert ':' in symbol\n                <DED>normalized = norm.get(base, base) + SYMBOL_SEP + norm.get(quote, quote)\n            <DED>ret[normalized.upper()] = symbol\n        <DED>return ret\n    <DED>except ValueError as why:\n        <IND>raise_failure_explanation('BITFINEX', why, {\"tickers?symbols=ALL\": r1, \"pub:map:currency:sym\": r2})\n\n\n<DED><DED>def bitflyer_symbols() -> Dict[str, str]:\n    <IND>endpoint = r = None\n    try:\n        <IND>ret = {}\n        endpoints = ['https://api.bitflyer.com/v1/getmarkets/eu', 'https://api.bitflyer.com/v1/getmarkets/usa', 'https://api.bitflyer.com/v1/getmarkets']\n        for endpoint in endpoints:\n            <IND>r = requests.get(endpoint)\n            for entry in r.json():\n                <IND>normalized = entry['product_code'].replace(\"_\", SYMBOL_SEP)\n                ret[normalized] = entry['product_code']\n        <DED><DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BITFLYER', why, {endpoint: r})\n\n\n<DED><DED>def bybit_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.bybit.com/v2/public/symbols')\n        ret = {}\n        for symbol in r.json()['result']:\n            <IND>quote = symbol['quote_currency']\n            if not symbol['name'].endswith(quote):\n                <IND>base, contract = symbol['name'].split(quote)\n                normalized = f\"{base}{SYMBOL_SEP}{quote}-{contract}\"\n            <DED>else:\n                <IND>normalized = f\"{symbol['base_currency']}{SYMBOL_SEP}{quote}\"\n            <DED>ret[normalized] = symbol['name']\n            _exchange_info[BYBIT]['tick_size'][normalized] = symbol['price_filter']['tick_size']\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BYBIT', why, {\"\": r})\n\n\n<DED><DED>def _ftx_helper(endpoint: str, exchange: str):\n    <IND>r = None\n    try:\n        <IND>r = requests.get(endpoint)\n        ret = {}\n        for data in r.json()['result']:\n            <IND>normalized = data['name'].replace(\"/\", SYMBOL_SEP)\n            symbol = data['name']\n            ret[normalized] = symbol\n            _exchange_info[exchange]['tick_size'][normalized] = data['priceIncrement']\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation(exchange, why, {endpoint: r})\n\n\n<DED><DED>def ftx_symbols() -> Dict[str, str]:\n    <IND>return _ftx_helper('https://ftx.com/api/markets', FTX)\n\n\n<DED>def ftx_us_symbols() -> Dict[str, str]:\n    <IND>return _ftx_helper('https://ftx.us/api/markets', FTX_US)\n\n\n<DED>def coinbase_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.pro.coinbase.com/products')\n        ret = {}\n        for data in r.json():\n            <IND>normalized = data['id'].replace(\"-\", SYMBOL_SEP)\n            ret[normalized] = data['id']\n            _exchange_info[COINBASE]['tick_size'][normalized] = data['quote_increment']\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('COINBASE', why, {\"\": r})\n\n\n<DED><DED>def gemini_symbols(*args) -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.gemini.com/v1/symbols')\n        ret = {}\n        for symbol in r.json():\n            <IND>std = f\"{symbol[:-3]}{SYMBOL_SEP}{symbol[-3:]}\"\n            std = std.upper()\n            ret[std] = symbol.upper()\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('GEMINI', why, {\"\": r})\n\n\n<DED><DED>def hitbtc_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>ret = {}\n        r = requests.get('https://api.hitbtc.com/api/2/public/symbol')\n        for symbol in r.json():\n            <IND>split = len(symbol['baseCurrency'])\n            normalized = symbol['id'][:split] + SYMBOL_SEP + symbol['id'][split:]\n            ret[normalized] = symbol['id']\n            _exchange_info[HITBTC]['tick_size'][normalized] = symbol['tickSize']\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('HITBTC', why, {\"\": r})\n\n\n<DED><DED>def poloniex_id_symbol_mapping():\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://poloniex.com/public?command=returnTicker')\n        symbols = r.json()\n        ret = {}\n        for symbol in symbols:\n            <IND>ret[symbols[symbol]['id']] = symbol\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('POLONIEX', why, {\"\": r})\n\n\n<DED><DED>def poloniex_symbols() -> Dict[str, str]:\n    <IND>ret = {}\n    for _, value in poloniex_id_symbol_mapping().items():\n        <IND>std = value.replace(\"STR\", \"XLM\")\n        quote, base = std.split(\"_\")\n        ret[quote + SYMBOL_SEP + base] = value\n    <DED>return ret\n\n\n<DED>def bitstamp_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://www.bitstamp.net/api/v2/trading-pairs-info/')\n        ret = {}\n        for data in r.json():\n            <IND>normalized = data['name'].replace(\"/\", SYMBOL_SEP)\n            symbol = data['url_symbol']\n            ret[normalized] = symbol\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BITSTAMP', why, {\"\": r})\n\n\n<DED><DED>def kraken_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.kraken.com/0/public/AssetPairs')\n        data = r.json()\n        ret = {}\n        for symbol in data['result']:\n            <IND>if 'wsname' not in data['result'][symbol] or '.d' in symbol:\n                # https://blog.kraken.com/post/259/introducing-the-kraken-dark-pool/\n                # .d is for dark pool symbols\n                <IND>continue\n\n            <DED>base, quote = data['result'][symbol]['wsname'].split(\"/\")\n\n            normalized = f\"{base}{SYMBOL_SEP}{quote}\"\n            exch = data['result'][symbol]['wsname']\n            normalized = normalized.replace('XBT', 'BTC')\n            normalized = normalized.replace('XDG', 'DOG')\n            ret[normalized] = exch\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('KRAKEN', why, {\"\": r})\n\n\n<DED><DED>def kraken_rest_symbols() -> Dict[str, str]:\n    <IND>return {normalized: exchange.replace(\"/\", \"\") for normalized, exchange in kraken_symbols().items()}\n\n\n<DED>def exx_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.exx.com/data/v1/tickers')\n        exchange = [key.upper() for key in r.json().keys()]\n        symbols = [key.replace(\"_\", SYMBOL_SEP) for key in exchange]\n        return dict(zip(symbols, exchange))\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('EXX', why, {\"\": r})\n\n\n<DED><DED>def huobi_common_symbols(url: str):\n    <IND>r = None\n    try:\n        <IND>r = requests.get(url)\n        ret = {}\n        for e in r.json()['data']:\n            <IND>if e['state'] == 'offline':\n                <IND>continue\n            <DED>normalized = f\"{e['base-currency'].upper()}{SYMBOL_SEP}{e['quote-currency'].upper()}\"\n            symbol = f\"{e['base-currency']}{e['quote-currency']}\"\n            ret[normalized] = symbol\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('HUOBI', why, {url: r})\n\n\n<DED><DED>def huobi_symbols() -> Dict[str, str]:\n    <IND>return huobi_common_symbols('https://api.huobi.pro/v1/common/symbols')\n\n\n<DED>def huobi_us_symbols() -> Dict[str, str]:\n    <IND>return huobi_common_symbols('https://api.huobi.com/v1/common/symbols')\n\n\n<DED>def huobi_dm_symbols() -> Dict[str, str]:\n    <IND>\"\"\"\n    Mapping is, for instance: {\"BTC_CW\":\"BTC190816\"}\n    See comments in exchange/huobi_dm.py\n    \"\"\"\n    mapping = {\n        \"this_week\": \"CW\",\n        \"next_week\": \"NW\",\n        \"quarter\": \"CQ\",\n        \"next_quarter\": \"NQ\"\n    }\n    r = None\n    try:\n        <IND>r = requests.get('https://www.hbdm.com/api/v1/contract_contract_info')\n        symbols = {}\n        for e in r.json()['data']:\n            <IND>symbols[f\"{e['symbol']}_{mapping[e['contract_type']]}\"] = e['contract_code']\n            _exchange_info[HUOBI_DM]['tick_size'][e['contract_code']] = e['price_tick']\n            _exchange_info[HUOBI_DM]['short_code_mappings'][f\"{e['symbol']}_{mapping[e['contract_type']]}\"] = e['contract_code']\n        <DED>return symbols\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('HUOBI_DM', why, {\"\": r})\n\n\n<DED><DED>def huobi_swap_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.hbdm.com/swap-api/v1/swap_contract_info')\n        symbols = {}\n        for e in r.json()['data']:\n            <IND>symbols[e['contract_code']] = e['contract_code']\n            _exchange_info[HUOBI_SWAP]['tick_size'][e['contract_code']] = e['price_tick']\n        <DED>return symbols\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('HUOBI_SWAP', why, {\"\": r})\n\n\n<DED><DED>def okcoin_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://www.okcoin.com/api/spot/v3/instruments')\n        ret = {}\n        for e in r.json():\n            <IND>ret[e['instrument_id']] = e['instrument_id']\n            _exchange_info[OKCOIN]['tick_size'][e['instrument_id']] = e['tick_size']\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('OKCOIN', why, {\"\": r})\n\n\n<DED><DED>def okex_symbols(*args) -> Dict[str, str]:\n    <IND>urls = ['https://www.okex.com/api/spot/v3/instruments',\n            'https://www.okex.com/api/swap/v3/instruments',\n            'https://www.okex.com/api/futures/v3/instruments']\n    urls = urls + okex_compute_option_urls_from_underlyings()\n\n    symbols: Dict[str, str] = {}\n    for u in urls:\n        <IND>time.sleep(0.2)\n        symbols.update(okex_symbols_from_one_url(u))\n\n    <DED>for symbol in symbols:\n        <IND>instrument_type = 'futures'\n        dash_count = symbol.count(get_symbol_separator())\n        if dash_count == 1:  # BTC-USDT\n            <IND>instrument_type = 'spot'\n        <DED>if dash_count == 4:  # BTC-USD-201225-35000-P\n            <IND>instrument_type = 'option'\n        <DED>if symbol[-4:] == \"SWAP\":  # BTC-USDT-SWAP\n            <IND>instrument_type = 'swap'\n\n        <DED>_exchange_info[OKEX]['instrument_type'][symbol] = instrument_type\n\n    <DED>return symbols\n\n\n<DED>def okex_compute_option_urls_from_underlyings() -> List[str]:\n    <IND>url = 'https://www.okex.com/api/option/v3/underlying'\n    r = None\n    try:\n        <IND>r = requests.get(url)\n        return [f'https://www.okex.com/api/option/v3/instruments/{underlying}' for underlying in r.json()]\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('OKEX', why, {url: r})\n\n\n<DED><DED>def okex_symbols_from_one_url(url: str) -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get(url)\n        ret = {}\n        for e in r.json():\n            <IND>ret[e['instrument_id']] = e['instrument_id']\n            _exchange_info[OKEX]['tick_size'][e['instrument_id']] = e['tick_size']\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('OKEX', why, {url: r})\n\n\n<DED><DED>def bittrex_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.bittrex.com/api/v1.1/public/getmarkets')\n        r = r.json()['result']\n        return {f\"{e['MarketCurrency']}{SYMBOL_SEP}{e['BaseCurrency']}\": e['MarketName'] for e in r if e['IsActive']}\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BITTREX', why, {\"\": r})\n\n\n<DED><DED>def bitcoincom_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.exchange.bitcoin.com/api/2/public/symbol')\n        return {f\"{data['baseCurrency']}{SYMBOL_SEP}{data['quoteCurrency'].replace('USD', 'USDT')}\": data['id'] for data in r.json()}\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BITCOINCOM', why, {\"\": r})\n\n\n<DED><DED>def bitmax_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://bitmax.io/api/pro/v1/products')\n        ret = {}\n        for entry in r.json()['data']:\n            # Only \"Normal\" status symbols are tradeable\n            <IND>if entry['status'] == 'Normal':\n                <IND>normalized = f\"{entry['baseAsset']}{SYMBOL_SEP}{entry['quoteAsset']}\"\n                ret[normalized] = entry['symbol']\n                _exchange_info[BITMAX]['tick_size'][normalized] = entry['tickSize']\n        <DED><DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BITMAX', why, {\"\": r})\n\n\n<DED><DED>def upbit_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.upbit.com/v1/market/all')\n        return {f\"{data['market'].split('-')[1]}{SYMBOL_SEP}{data['market'].split('-')[0]}\": data['market'] for data in r.json()}\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('UPBIT', why, {\"\": r})\n\n\n<DED><DED>def blockchain_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get(\"https://api.blockchain.com/mercury-gateway/v1/instruments\")\n        return {data[\"symbol\"].replace(\"-\", SYMBOL_SEP): data[\"symbol\"] for data in r.json()}\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BLOCKCHAIN', why, {\"\": r})\n\n\n<DED><DED>def gateio_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get(\"https://api.gateio.ws/api/v4/spot/currency_pairs\")\n        return {data[\"id\"].replace(\"_\", SYMBOL_SEP): data['id'] for data in r.json()}\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('GATEIO', why, {\"\": r})\n\n\n<DED><DED>def bitmex_symbols() -> Dict[str, str]:\n    <IND>r = None\n    ret = {}\n    try:\n        <IND>r = requests.get(\"https://www.bitmex.com/api/v1/instrument/active\")\n        for entry in r.json():\n            <IND>components = []\n            components.append(entry['rootSymbol'])\n            components.append(entry['quoteCurrency'])\n\n            if entry['expiry']:\n                <IND>components.append(entry['symbol'][-3:])\n\n            <DED>normalized = SYMBOL_SEP.join(components)\n            normalized = normalized.replace(\"XBT\", \"BTC\")\n            ret[normalized] = entry['symbol']\n            _exchange_info[BITMEX]['tick_size'][normalized] = entry['tickSize']\n\n            if entry['expiry']:\n                <IND>_exchange_info[BITMEX]['expiry'][normalized] = entry['expiry']\n\n        <DED><DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BITMEX', why, {\"\": r})\n\n\n<DED><DED>def deribit_symbols() -> Dict[str, str]:\n    <IND>url = r = None\n    ret = {}\n    try:\n        # TODO: get currencies from https://www.deribit.com/api/v2/public/get_currencies\n        <IND>currencies = ['BTC', 'ETH']\n        for c in currencies:\n            <IND>url = f\"https://www.deribit.com/api/v2/public/get_instruments?currency={c}&expired=false\"\n            r = requests.get(url)\n            for entry in r.json()['result']:\n                <IND>split = entry['instrument_name'].split(\"-\")\n                normalized = split[0] + SYMBOL_SEP + entry['quote_currency'] + \"-\" + '-'.join(split[1:])\n                ret[normalized] = entry['instrument_name']\n                _exchange_info[DERIBIT]['tick_size'][normalized] = entry['tick_size']\n        <DED><DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('DERIBIT', why, {url: r})\n\n\n<DED><DED>def kraken_future_symbols() -> Dict[str, str]:\n    <IND>r = None\n    ret = {}\n    try:\n        <IND>r = requests.get('https://futures.kraken.com/derivatives/api/v3/instruments')\n        data = r.json()['instruments']\n        for entry in data:\n            <IND>if not entry['tradeable']:\n                <IND>continue\n            <DED>normalized = entry['symbol'].upper().replace(\"_\", \"-\")\n            symbol = normalized[3:6] + SYMBOL_SEP + normalized[6:9]\n            normalized = normalized.replace(normalized[3:9], symbol)\n            normalized = normalized.replace('XBT', 'BTC')\n\n            _exchange_info[KRAKEN_FUTURES]['tick_size'][normalized] = entry['tickSize']\n            _exchange_info[KRAKEN_FUTURES]['contract_size'][normalized] = entry['contractSize']\n            _exchange_info[KRAKEN_FUTURES]['underlying'][normalized] = entry['underlying']\n            _exchange_info[KRAKEN_FUTURES]['product_type'][normalized] = _kraken_futures_product_type[normalized[:2]]\n            ret[normalized] = entry['symbol']\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('KRAKEN_FUTURES', why, {\"\": r})\n\n\n<DED><DED>def probit_symbols() -> Dict[str, str]:\n    # doc: https://docs-en.probit.com/reference-link/market\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.probit.com/api/exchange/v1/market')\n        return {entry['id']: entry['id'] for entry in r.json()['data']}\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('PROBIT', why, {\"\": r})\n\n\n<DED><DED>def coingecko_normalize_symbol(symbol: str) -> str:\n    # keep digits, letters and dots, replace others by space\n    <IND>symbol = ''.join(c if c.isalnum() or c in ('.', '+') else ' ' for c in symbol)\n    return coingecko_normalize(symbol.upper())\n\n\n<DED>def coingecko_normalize_name(name: str) -> str:\n    # keep digits and letters, replace others by space (except when only composed by upper case letters, digits and dots)\n    <IND>if not all(c.isupper() or c.isdigit() or c == '.' for c in name):\n        <IND>name = ''.join(c if c.isalnum() else ' ' for c in name)\n    <DED>return coingecko_normalize(name)\n\n\n<DED>def coingecko_normalize(sym: str) -> str:\n    <IND>sym = sym.strip()\n    # do not concatenate numbers => separate them with a dot\n    sym = list(sym)\n    if len(sym) > 4:\n        <IND>for i in range(2, len(sym) - 1):\n            <IND>if sym[i] == ' ' and sym[i - 1].isdigit() and sym[i + 1].isdigit():\n                <IND>sym[i] = '.'\n    <DED><DED><DED>sym = ''.join(sym)\n    # concatenate space-separated words => use CamelCase to distinguish the words\n    if ' ' in sym:\n        <IND>if sum(c.islower() for c in sym):  # if there is at least one lower case letter\n            <IND>sym = ' '.join(word[0].upper() + word[1:] for word in sym.split())  # Just capitalize initial letter of each word\n        <DED>else:  # CoinGecko may provide full upper-case as for \"THE STONE COIN\"\n            <IND>sym = string.capwords(sym)  # capwords converts \"THE STONE COIN\" to \"The Stone Coin\"\n        <DED>sym = sym.replace(' ', '')  # concatenate words\n    <DED>return sym\n\n\n<DED>def is_name_short(coin: dict) -> bool:\n    <IND>\"\"\"return True if the coin name is enough short compared to the coin symbol.\"\"\"\n    return len(coin['name']) <= max(5, len(coin['symbol']) + 1)\n\n\n<DED>def has_many_caps(name: str) -> bool:\n    <IND>\"\"\"return True if the symbol contains enough upper case letters, False if empty.\"\"\"\n    return str and sum(c.islower() for c in name) < (len(name) / 2)\n\n\n<DED>def coingecko_normalize_all(coin: dict):\n    <IND>SYMBOL_TO_NORMALIZED = {'miota': 'IOTA'}\n    normalized = SYMBOL_TO_NORMALIZED.get(coin['symbol'])\n    if normalized:\n        <IND>coin['ns'] = coin['nn'] = normalized\n        return normalized\n\n    # ns = normalized symbol, nn = normalized name\n    <DED>coin['ns'] = coingecko_normalize_symbol(coin['symbol'])\n\n    ID_SUFFIX = '-bitcoin-token'\n    if coin['id'][-len(ID_SUFFIX):] == ID_SUFFIX:\n        <IND>coin['nn'] = 'BTC' + coin['ns']\n        return coin['nn']\n\n    <DED>name = coin['name']\n\n    prefixes = ('The ', 'the ')\n    for p in prefixes:\n        <IND>if name[:len(p)] == p:\n            <IND>coin['reduced-name'] = True\n            name = name[len(p):]\n            break\n\n    <DED><DED>suffixes = ('coin', 'coins', 'money', 'finance', 'protocol', 'reward', 'rewards', 'token')\n    for s in suffixes:\n        <IND>if len(name) > len(s) and name[-len(s):].lower() == s:\n            # but keep suffix when lower-case concatenated\n            <IND>if name[-len(s)].islower() and name[-len(s) - 1] != ' ':\n                <IND>continue\n            # also keep suffix to avoid confusing nam: \"Bitcoin Token\" -> \"Bitcoin\"\n            <DED>if name[:-len(s)].strip().lower() == 'bitcoin':\n                <IND>continue\n            <DED>coin['reduced-name'] = True\n            name = name[:-len(s)]\n            break\n\n    <DED><DED>coin['nn'] = coingecko_normalize_name(name)\n\n    if len(coin['nn']) < len(coin['ns']):\n        <IND>if 'reduced-name' in coin:\n            <IND>coin['reduced-name'] = False\n            name = coin['name']\n            coin['nn'] = coingecko_normalize_name(name)\n        <DED>elif not has_many_caps(name):\n            <IND>return coin['ns']\n\n    <DED><DED>if not coin['ns']:  # coin['symbol'] may be an emoji that is striped when normalized\n        <IND>return coin['nn']\n\n    <DED>if coin.get('reduced-name') and coin['ns'].upper() != coin['nn'].upper():\n        <IND>return coin['ns']\n\n    <DED>i = coin['nn'].find('.')  # if there is a dot in normalized name => prefer the normalized symbol\n    if i >= 0:\n        <IND>if i > 1 and coin['nn'][i - 1].isdigit() and coin['nn'][i + 1].isdigit():\n            <IND>pass  # except when the dot separates digits\n        <DED>else:\n            <IND>return coin['ns']\n\n    <DED><DED>if is_name_short(coin) and has_many_caps(name):\n        <IND>return coin['nn']\n\n    <DED>if 1.5 * len(coin['ns']) > len(coin['nn']) and any(c.islower() for c in coin['ns']):\n        <IND>return coin['nn']\n\n    <DED>return coin['ns']\n\n\n<DED>def coingecko_symbols() -> Dict[str, str]:\n    <IND>r = None\n    intermediate = defaultdict(list)\n    try:\n        <IND>r = requests.get('https://api.coingecko.com/api/v3/coins/list')\n        all_coins = r.json()\n        # First pass: generate & compare normalized symbol/name, and then select the most pertinent\n        for coin in all_coins:\n            <IND>normalized = coingecko_normalize_all(coin)\n            intermediate[normalized].append(coin)\n            # Above line keeps together the coins having the same normalized symbol.\n            # To reduce collision, the coin['name'] is sometimes used in lieu of the coin['symbol'].\n            # The coin['name'] is not capitalized because lower case letters may be meaningful: cETH, yUSD, DATx, zLOT\n    <DED><DED>except Exception as why:\n        <IND>raise_failure_explanation('COINGECKO', why, {\"\": r})\n\n    <DED>final = coingecko_second_pass(intermediate)\n    return coingecko_third_pass(final)\n\n\n<DED>def coingecko_second_pass(intermediate: Dict[str, List[dict]]) -> Dict[str, List[dict]]:\n    # Second pass: fixes most of the symbol collisions\n    <IND>final = defaultdict(list)\n    for normalized, coins in intermediate.items():\n        <IND>if len(coins) == 1:\n            <IND>final[normalized].append(coins[0])\n            continue\n        <DED>set_normalized = False\n        for i in range(len(coins)):\n            <IND>if normalized == coins[i]['nn']:\n                <IND>coin = coins.pop(i)\n                final[normalized].append(coin)\n                set_normalized = True\n                break\n        <DED><DED>rest: List[dict] = []\n        for coin in coins:\n            <IND>if '%' in coin['name']:\n                <IND>if len(coins) == 1:\n                    <IND>n = coin['ns']\n                <DED>else:\n                    <IND>n = coingecko_normalize_name(coin['id'])\n                <DED>final[n].append(coin)\n            <DED>else:\n                <IND>rest.append(coin)\n        <DED><DED>if not rest:\n            <IND>continue\n        <DED>if not set_normalized:\n            <IND>rest.sort(key=lambda coin: len(coin['nn']), reverse=True)  # sort by the length of the normalized name\n            coin = rest.pop(0)\n            final[normalized].append(coin)\n        <DED>for coin in rest:\n            <IND>if coin['nn'] not in intermediate:\n                <IND>n = coin['nn']\n            <DED>elif coin.get('reduced-name'):\n                <IND>n = coingecko_normalize_name(coin['name'])\n            <DED>else:\n                <IND>n = coingecko_normalize_name(coin['id'])\n            <DED>final[n].append(coin)\n    <DED><DED>return final\n\n\n<DED>def coingecko_third_pass(final: Dict[str, List[dict]]) -> Dict[str, str]:\n    # Third pass: fixes some remaining collisions and fills the result\n    <IND>symbols = {}\n    for normalized, coins in final.items():\n        <IND>if len(coins) == 1:\n            <IND>symbols[normalized] = coins[0]['id']\n            continue\n        <DED>set_normalized = False\n        for i in range(len(coins)):\n            <IND>if normalized == coins[i]['nn']:\n                <IND>coin = coins.pop(i)\n                symbols[normalized] = coin['id']\n                set_normalized = True\n                break\n        <DED><DED>rest: List[dict] = []\n        for coin in coins:\n            <IND>if '%' in coin['name']:\n                <IND>if len(coins) == 1:\n                    <IND>n = coin['ns']\n                <DED>else:\n                    <IND>n = coingecko_normalize_name(coin['id'])\n                <DED>symbols[n] = coin['id']\n            <DED>else:\n                <IND>rest.append(coin)\n        <DED><DED>if not rest:\n            <IND>continue\n        <DED>if not set_normalized:\n            <IND>rest.sort(key=lambda coin: len(coin['nn']), reverse=True)  # sort by the length of the normalized name\n            coin = rest.pop(0)\n            symbols[normalized] = coin['id']\n        <DED>for coin in rest:\n            <IND>if coin['nn'] not in final:\n                <IND>n = coin['nn']\n            <DED>elif coin.get('reduced-name'):\n                <IND>n = coingecko_normalize_name(coin['name'])\n            <DED>else:\n                <IND>n = coingecko_normalize_name(coin['id'])\n            <DED>symbols[n] = coin['id']\n    <DED><DED>return symbols\n\n\n<DED>def whale_alert_coins(key_id: str) -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get(f'https://api.whale-alert.io/v1/status?api_key={key_id}')\n        # Same symbols, but on different blockchains (for instance USDT), are naturally overwritten.\n        return {s.upper(): s for b in r.json()['blockchains'] for s in b['symbols'] if s}\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('WHALES_ALERT', why, {\"\": r})\n\n\n<DED><DED>_exchange_function_map = {\n    BITFINEX: bitfinex_symbols,\n    BITFLYER: bitflyer_symbols,\n    COINBASE: coinbase_symbols,\n    GEMINI: gemini_symbols,\n    HITBTC: hitbtc_symbols,\n    POLONIEX: poloniex_symbols,\n    PROBIT: probit_symbols,\n    BITSTAMP: bitstamp_symbols,\n    KRAKEN: kraken_symbols,\n    KRAKEN + 'REST': kraken_rest_symbols,\n    BINANCE: binance_symbols,\n    BINANCE_US: binance_us_symbols,\n    BINANCE_FUTURES: binance_futures_symbols,\n    BINANCE_DELIVERY: binance_delivery_symbols,\n    BLOCKCHAIN: blockchain_symbols,\n    EXX: exx_symbols,\n    HUOBI: huobi_symbols,\n    HUOBI_DM: huobi_dm_symbols,\n    HUOBI_SWAP: huobi_swap_symbols,\n    OKCOIN: okcoin_symbols,\n    OKEX: okex_symbols,\n    BYBIT: bybit_symbols,\n    FTX: ftx_symbols,\n    FTX_US: ftx_us_symbols,\n    BITTREX: bittrex_symbols,\n    BITCOINCOM: bitcoincom_symbols,\n    BITMAX: bitmax_symbols,\n    UPBIT: upbit_symbols,\n    GATEIO: gateio_symbols,\n    BITMEX: bitmex_symbols,\n    DERIBIT: deribit_symbols,\n    KRAKEN_FUTURES: kraken_future_symbols,\n    COINGECKO: coingecko_symbols,\n    WHALE_ALERT: whale_alert_coins\n}\n",
        "target_code_with_indent": "\nfrom typing import Dict, Tuple\n\n\nclass _Symbols:\n    <IND>def __init__(self):\n        <IND>self.data = {}\n\n    <DED>def set(self, exchange: str, normalized: dict, exchange_info: dict):\n        <IND>self.data[exchange] = {}\n        self.data[exchange]['normalized'] = normalized\n        self.data[exchange]['info'] = exchange_info\n\n    <DED>def get(self, exchange: str) -> Tuple[Dict, Dict]:\n        <IND>return self.data[exchange]['normalized'], self.data[exchange]['info']\n\n    <DED>def populated(self, exchange: str) -> bool:\n        <IND>return exchange in self.data\n\n\n<DED><DED>Symbols = _Symbols()\n"
      }
    ]
  },
  {
    "project": "bmoscon/cryptofeed",
    "commit": "3525dc8ce4d7836a9abaaa5662e58e5e27969a77",
    "filename": "cryptofeed/symbols.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/bmoscon-cryptofeed/cryptofeed/symbols.py",
    "file_hunks_size": 1,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "cryptofeed/symbols.py:482:8 Incompatible return type [7]: Expected `Dict[str, str]` but got implicit return value of `None`.",
    "message": " Expected `Dict[str, str]` but got implicit return value of `None`.",
    "rule_id": "Incompatible return type [7]",
    "warning_line_no": 482,
    "warning_line": "        raise_failure_explanation('BITMAX', why, {\"\": r})",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "associated with this software.\n\n\nSymbol generation code for exchanges\n'''\n\nimport logging\nimport string\nimport time\nfrom collections import defaultdict\nfrom typing import Dict, List, Optional, Tuple\n\nimport requests\nfrom requests import Response\n\nfrom cryptofeed.defines import *\n\n\nLOG = logging.getLogger('feedhandler')\n\nSYMBOL_SEP = '-'\n\n_symbols_retrieval_cache: Dict[str, Dict[str, str]] = {}\n_exchange_info = defaultdict(lambda: defaultdict(dict))\n\n\n_kraken_futures_product_type = {\n    'FI': 'Inverse Futures',\n    'FV': 'Vanilla Futures',\n    'PI': 'Perpetual Inverse Futures',\n    'PV': 'Perpetual Vanilla Futures',\n    'IN': 'Real Time Index',\n    'RR': 'Reference Rate',\n}\n\n\ndef raise_failure_explanation(feed_id: str, exception: BaseException, responses: Dict[str, Optional[Response]]):\n    LOG.critical('%s: encountered %r while processing response from exchange API', feed_id, exception)\n    if len(responses) > 1:\n        LOG.critical('%s: content of one of the %s responses was unexpected', feed_id, len(responses))\n    for url, r in responses.items():\n        if url:\n            LOG.critical('%s: requested URL: %s', feed_id, url)\n        if r:\n            LOG.critical('%s: unexpected response: %s', feed_id, r.text)\n    raise ValueError(f'Cryptofeed stopped because of an unexpected response from {feed_id}') from exception\n\n\ndef set_symbol_separator(separator: str):\n    global SYMBOL_SEP\n    SYMBOL_SEP = separator\n\n\ndef get_symbol_separator() -> str:\n    global SYMBOL_SEP\n    return SYMBOL_SEP\n\n\ndef gen_symbols(exchange: str, key_id=None) -> Dict[str, str]:\n    if exchange not in _symbols_retrieval_cache:\n        LOG.info(\"%s: Getting list of symbols\", exchange)\n        symbols = _exchange_function_map[exchange](key_id) if key_id else _exchange_function_map[exchange]()\n        LOG.info(\"%s: %s symbols\", exchange, len(symbols))\n\n        # log all retrieved symbols using debug level\n        for normalized, exch_sym in sorted(symbols.items()):\n            LOG.debug('%s: id-from-exch -> normalized: %-35s-> %s', exchange, exch_sym, normalized)\n\n        _symbols_retrieval_cache[exchange] = symbols\n    return _symbols_retrieval_cache[exchange]\n\n\ndef _binance_symbols(endpoint: str, exchange: str):\n    r = None\n    try:\n        ret = {}\n        r = requests.get(endpoint)\n        for symbol in r.json()['symbols']:\n            if symbol.get('status', 'TRADING') != \"TRADING\":\n                continue\n            if symbol.get('contractStatus', 'TRADING') != \"TRADING\":\n                continue\n            split = len(symbol['baseAsset'])\n            normalized = symbol['symbol'][:split] + SYMBOL_SEP + symbol['symbol'][split:]\n            ret[normalized] = symbol['symbol']\n            _exchange_info[exchange]['tick_size'][normalized] = symbol['filters'][0]['tickSize']\n            if \"contractType\" in symbol:\n                _exchange_info[exchange]['contract_type'][normalized] = symbol['contractType']\n        return ret\n    except Exception as why:\n        raise_failure_explanation(exchange, why, {endpoint: r})\n\n\ndef binance_symbols() -> Dict[str, str]:\n    return _binance_symbols('https://api.binance.com/api/v3/exchangeInfo', BINANCE)\n\n\ndef binance_us_symbols() -> Dict[str, str]:\n    return _binance_symbols('https://api.binance.us/api/v3/exchangeInfo', BINANCE_US)\n\n\ndef binance_futures_symbols() -> Dict[str, str]:\n    base = _binance_symbols('https://fapi.binance.com/fapi/v1/exchangeInfo', BINANCE_FUTURES)\n    add = {}\n    for symbol, orig in base.items():\n        if \"_\" in orig:\n            continue\n        add[f\"{symbol}-PINDEX\"] = f\"p{orig}\"\n    base.update(add)\n    return base\n\n\ndef binance_delivery_symbols() -> Dict[str, str]:\n    return _binance_symbols('https://dapi.binance.com/dapi/v1/exchangeInfo', BINANCE_DELIVERY)\n\n\ndef bitfinex_symbols() -> Dict[str, str]:\n    # doc: https://docs.bitfinex.com/docs/ws-general#supported-pairs\n    r1 = r2 = None\n    try:\n        r1 = requests.get('https://api.bitfinex.com/v2/tickers?symbols=ALL')\n        r2 = requests.get('https://api-pub.bitfinex.com/v2/conf/pub:map:currency:sym')\n        tickers: List[List[str]] = r1.json()\n        norm: List[Tuple[str, str]] = r2.json()[0]\n        norm: Dict[str, str] = dict(norm)\n        for k, v in dict(norm).items():\n            if k[-2:] == 'F0' or '-' in v:  # Do not convert BTCF0 -> BTC or PBTCETH -> PBTC-ETH\n                del norm[k]\n        norm['BCHN'] = 'BCH'  # Bitfinex uses BCHN, other exchanges use BCH\n\n        ret = {}\n        for symbol in [t[0] for t in tickers]:\n            if symbol[0] == 'f':\n                normalized = norm.get(symbol[1:], symbol[1:])\n            else:\n                if len(symbol) == 7:\n                    base, quote = symbol[1:4], symbol[4:]\n                else:\n                    base, quote = symbol[1:].split(':')\n                    assert ':' in symbol\n                normalized = norm.get(base, base) + SYMBOL_SEP + norm.get(quote, quote)\n            ret[normalized.upper()] = symbol\n        return ret\n    except ValueError as why:\n        raise_failure_explanation('BITFINEX', why, {\"tickers?symbols=ALL\": r1, \"pub:map:currency:sym\": r2})\n\n\ndef bitflyer_symbols() -> Dict[str, str]:\n    endpoint = r = None\n    try:\n        ret = {}\n        endpoints = ['https://api.bitflyer.com/v1/getmarkets/eu', 'https://api.bitflyer.com/v1/getmarkets/usa', 'https://api.bitflyer.com/v1/getmarkets']\n        for endpoint in endpoints:\n            r = requests.get(endpoint)\n            for entry in r.json():\n                normalized = entry['product_code'].replace(\"_\", SYMBOL_SEP)\n                ret[normalized] = entry['product_code']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('BITFLYER', why, {endpoint: r})\n\n\ndef bybit_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.bybit.com/v2/public/symbols')\n        ret = {}\n        for symbol in r.json()['result']:\n            quote = symbol['quote_currency']\n            if not symbol['name'].endswith(quote):\n                base, contract = symbol['name'].split(quote)\n                normalized = f\"{base}{SYMBOL_SEP}{quote}-{contract}\"\n            else:\n                normalized = f\"{symbol['base_currency']}{SYMBOL_SEP}{quote}\"\n            ret[normalized] = symbol['name']\n            _exchange_info[BYBIT]['tick_size'][normalized] = symbol['price_filter']['tick_size']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('BYBIT', why, {\"\": r})\n\n\ndef _ftx_helper(endpoint: str, exchange: str):\n    r = None\n    try:\n        r = requests.get(endpoint)\n        ret = {}\n        for data in r.json()['result']:\n            normalized = data['name'].replace(\"/\", SYMBOL_SEP)\n            symbol = data['name']\n            ret[normalized] = symbol\n            _exchange_info[exchange]['tick_size'][normalized] = data['priceIncrement']\n        return ret\n    except Exception as why:\n        raise_failure_explanation(exchange, why, {endpoint: r})\n\n\ndef ftx_symbols() -> Dict[str, str]:\n    return _ftx_helper('https://ftx.com/api/markets', FTX)\n\n\ndef ftx_us_symbols() -> Dict[str, str]:\n    return _ftx_helper('https://ftx.us/api/markets', FTX_US)\n\n\ndef coinbase_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.pro.coinbase.com/products')\n        ret = {}\n        for data in r.json():\n            normalized = data['id'].replace(\"-\", SYMBOL_SEP)\n            ret[normalized] = data['id']\n            _exchange_info[COINBASE]['tick_size'][normalized] = data['quote_increment']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('COINBASE', why, {\"\": r})\n\n\ndef gemini_symbols(*args) -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.gemini.com/v1/symbols')\n        ret = {}\n        for symbol in r.json():\n            std = f\"{symbol[:-3]}{SYMBOL_SEP}{symbol[-3:]}\"\n            std = std.upper()\n            ret[std] = symbol.upper()\n        return ret\n    except Exception as why:\n        raise_failure_explanation('GEMINI', why, {\"\": r})\n\n\ndef hitbtc_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        ret = {}\n        r = requests.get('https://api.hitbtc.com/api/2/public/symbol')\n        for symbol in r.json():\n            split = len(symbol['baseCurrency'])\n            normalized = symbol['id'][:split] + SYMBOL_SEP + symbol['id'][split:]\n            ret[normalized] = symbol['id']\n            _exchange_info[HITBTC]['tick_size'][normalized] = symbol['tickSize']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('HITBTC', why, {\"\": r})\n\n\ndef poloniex_id_symbol_mapping():\n    r = None\n    try:\n        r = requests.get('https://poloniex.com/public?command=returnTicker')\n        symbols = r.json()\n        ret = {}\n        for symbol in symbols:\n            ret[symbols[symbol]['id']] = symbol\n        return ret\n    except Exception as why:\n        raise_failure_explanation('POLONIEX', why, {\"\": r})\n\n\ndef poloniex_symbols() -> Dict[str, str]:\n    ret = {}\n    for _, value in poloniex_id_symbol_mapping().items():\n        std = value.replace(\"STR\", \"XLM\")\n        quote, base = std.split(\"_\")\n        ret[quote + SYMBOL_SEP + base] = value\n    return ret\n\n\ndef bitstamp_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://www.bitstamp.net/api/v2/trading-pairs-info/')\n        ret = {}\n        for data in r.json():\n            normalized = data['name'].replace(\"/\", SYMBOL_SEP)\n            symbol = data['url_symbol']\n            ret[normalized] = symbol\n        return ret\n    except Exception as why:\n        raise_failure_explanation('BITSTAMP', why, {\"\": r})\n\n\ndef kraken_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.kraken.com/0/public/AssetPairs')\n        data = r.json()\n        ret = {}\n        for symbol in data['result']:\n            if 'wsname' not in data['result'][symbol] or '.d' in symbol:\n                # https://blog.kraken.com/post/259/introducing-the-kraken-dark-pool/\n                # .d is for dark pool symbols\n                continue\n\n            base, quote = data['result'][symbol]['wsname'].split(\"/\")\n\n            normalized = f\"{base}{SYMBOL_SEP}{quote}\"\n            exch = data['result'][symbol]['wsname']\n            normalized = normalized.replace('XBT', 'BTC')\n            normalized = normalized.replace('XDG', 'DOG')\n            ret[normalized] = exch\n        return ret\n    except Exception as why:\n        raise_failure_explanation('KRAKEN', why, {\"\": r})\n\n\ndef kraken_rest_symbols() -> Dict[str, str]:\n    return {normalized: exchange.replace(\"/\", \"\") for normalized, exchange in kraken_symbols().items()}\n\n\ndef exx_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.exx.com/data/v1/tickers')\n        exchange = [key.upper() for key in r.json().keys()]\n        symbols = [key.replace(\"_\", SYMBOL_SEP) for key in exchange]\n        return dict(zip(symbols, exchange))\n    except Exception as why:\n        raise_failure_explanation('EXX', why, {\"\": r})\n\n\ndef huobi_common_symbols(url: str):\n    r = None\n    try:\n        r = requests.get(url)\n        ret = {}\n        for e in r.json()['data']:\n            if e['state'] == 'offline':\n                continue\n            normalized = f\"{e['base-currency'].upper()}{SYMBOL_SEP}{e['quote-currency'].upper()}\"\n            symbol = f\"{e['base-currency']}{e['quote-currency']}\"\n            ret[normalized] = symbol\n        return ret\n    except Exception as why:\n        raise_failure_explanation('HUOBI', why, {url: r})\n\n\ndef huobi_symbols() -> Dict[str, str]:\n    return huobi_common_symbols('https://api.huobi.pro/v1/common/symbols')\n\n\ndef huobi_us_symbols() -> Dict[str, str]:\n    return huobi_common_symbols('https://api.huobi.com/v1/common/symbols')\n\n\ndef huobi_dm_symbols() -> Dict[str, str]:\n    \"\"\"\n    Mapping is, for instance: {\"BTC_CW\":\"BTC190816\"}\n    See comments in exchange/huobi_dm.py\n    \"\"\"\n    mapping = {\n        \"this_week\": \"CW\",\n        \"next_week\": \"NW\",\n        \"quarter\": \"CQ\",\n        \"next_quarter\": \"NQ\"\n    }\n    r = None\n    try:\n        r = requests.get('https://www.hbdm.com/api/v1/contract_contract_info')\n        symbols = {}\n        for e in r.json()['data']:\n            symbols[f\"{e['symbol']}_{mapping[e['contract_type']]}\"] = e['contract_code']\n            _exchange_info[HUOBI_DM]['tick_size'][e['contract_code']] = e['price_tick']\n            _exchange_info[HUOBI_DM]['short_code_mappings'][f\"{e['symbol']}_{mapping[e['contract_type']]}\"] = e['contract_code']\n        return symbols\n    except Exception as why:\n        raise_failure_explanation('HUOBI_DM', why, {\"\": r})\n\n\ndef huobi_swap_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.hbdm.com/swap-api/v1/swap_contract_info')\n        symbols = {}\n        for e in r.json()['data']:\n            symbols[e['contract_code']] = e['contract_code']\n            _exchange_info[HUOBI_SWAP]['tick_size'][e['contract_code']] = e['price_tick']\n        return symbols\n    except Exception as why:\n        raise_failure_explanation('HUOBI_SWAP', why, {\"\": r})\n\n\ndef okcoin_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://www.okcoin.com/api/spot/v3/instruments')\n        ret = {}\n        for e in r.json():\n            ret[e['instrument_id']] = e['instrument_id']\n            _exchange_info[OKCOIN]['tick_size'][e['instrument_id']] = e['tick_size']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('OKCOIN', why, {\"\": r})\n\n\ndef okex_symbols(*args) -> Dict[str, str]:\n    urls = ['https://www.okex.com/api/spot/v3/instruments',\n            'https://www.okex.com/api/swap/v3/instruments',\n            'https://www.okex.com/api/futures/v3/instruments']\n    urls = urls + okex_compute_option_urls_from_underlyings()\n\n    symbols: Dict[str, str] = {}\n    for u in urls:\n        time.sleep(0.2)\n        symbols.update(okex_symbols_from_one_url(u))\n\n    for symbol in symbols:\n        instrument_type = 'futures'\n        dash_count = symbol.count(get_symbol_separator())\n        if dash_count == 1:  # BTC-USDT\n            instrument_type = 'spot'\n        if dash_count == 4:  # BTC-USD-201225-35000-P\n            instrument_type = 'option'\n        if symbol[-4:] == \"SWAP\":  # BTC-USDT-SWAP\n            instrument_type = 'swap'\n\n        _exchange_info[OKEX]['instrument_type'][symbol] = instrument_type\n\n    return symbols\n\n\ndef okex_compute_option_urls_from_underlyings() -> List[str]:\n    url = 'https://www.okex.com/api/option/v3/underlying'\n    r = None\n    try:\n        r = requests.get(url)\n        return [f'https://www.okex.com/api/option/v3/instruments/{underlying}' for underlying in r.json()]\n    except Exception as why:\n        raise_failure_explanation('OKEX', why, {url: r})\n\n\ndef okex_symbols_from_one_url(url: str) -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get(url)\n        ret = {}\n        for e in r.json():\n            ret[e['instrument_id']] = e['instrument_id']\n            _exchange_info[OKEX]['tick_size'][e['instrument_id']] = e['tick_size']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('OKEX', why, {url: r})\n\n\ndef bittrex_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.bittrex.com/api/v1.1/public/getmarkets')\n        r = r.json()['result']\n        return {f\"{e['MarketCurrency']}{SYMBOL_SEP}{e['BaseCurrency']}\": e['MarketName'] for e in r if e['IsActive']}\n    except Exception as why:\n        raise_failure_explanation('BITTREX', why, {\"\": r})\n\n\ndef bitcoincom_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.exchange.bitcoin.com/api/2/public/symbol')\n        return {f\"{data['baseCurrency']}{SYMBOL_SEP}{data['quoteCurrency'].replace('USD', 'USDT')}\": data['id'] for data in r.json()}\n    except Exception as why:\n        raise_failure_explanation('BITCOINCOM', why, {\"\": r})\n\n\ndef bitmax_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://bitmax.io/api/pro/v1/products')\n        ret = {}\n        for entry in r.json()['data']:\n            # Only \"Normal\" status symbols are tradeable\n            if entry['status'] == 'Normal':\n                normalized = f\"{entry['baseAsset']}{SYMBOL_SEP}{entry['quoteAsset']}\"\n                ret[normalized] = entry['symbol']\n                _exchange_info[BITMAX]['tick_size'][normalized] = entry['tickSize']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('BITMAX', why, {\"\": r})\n\n\ndef upbit_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.upbit.com/v1/market/all')\n        return {f\"{data['market'].split('-')[1]}{SYMBOL_SEP}{data['market'].split('-')[0]}\": data['market'] for data in r.json()}\n    except Exception as why:\n        raise_failure_explanation('UPBIT', why, {\"\": r})\n\n\ndef blockchain_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get(\"https://api.blockchain.com/mercury-gateway/v1/instruments\")\n        return {data[\"symbol\"].replace(\"-\", SYMBOL_SEP): data[\"symbol\"] for data in r.json()}\n    except Exception as why:\n        raise_failure_explanation('BLOCKCHAIN', why, {\"\": r})\n\n\ndef gateio_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get(\"https://api.gateio.ws/api/v4/spot/currency_pairs\")\n        return {data[\"id\"].replace(\"_\", SYMBOL_SEP): data['id'] for data in r.json()}\n    except Exception as why:\n        raise_failure_explanation('GATEIO', why, {\"\": r})\n\n\ndef bitmex_symbols() -> Dict[str, str]:\n    r = None\n    ret = {}\n    try:\n        r = requests.get(\"https://www.bitmex.com/api/v1/instrument/active\")\n        for entry in r.json():\n            components = []\n            components.append(entry['rootSymbol'])\n            components.append(entry['quoteCurrency'])\n\n            if entry['expiry']:\n                components.append(entry['symbol'][-3:])\n\n            normalized = SYMBOL_SEP.join(components)\n            normalized = normalized.replace(\"XBT\", \"BTC\")\n            ret[normalized] = entry['symbol']\n            _exchange_info[BITMEX]['tick_size'][normalized] = entry['tickSize']\n\n            if entry['expiry']:\n                _exchange_info[BITMEX]['expiry'][normalized] = entry['expiry']\n\n        return ret\n    except Exception as why:\n        raise_failure_explanation('BITMEX', why, {\"\": r})\n\n\ndef deribit_symbols() -> Dict[str, str]:\n    url = r = None\n    ret = {}\n    try:\n        # TODO: get currencies from https://www.deribit.com/api/v2/public/get_currencies\n        currencies = ['BTC', 'ETH']\n        for c in currencies:\n            url = f\"https://www.deribit.com/api/v2/public/get_instruments?currency={c}&expired=false\"\n            r = requests.get(url)\n            for entry in r.json()['result']:\n                split = entry['instrument_name'].split(\"-\")\n                normalized = split[0] + SYMBOL_SEP + entry['quote_currency'] + \"-\" + '-'.join(split[1:])\n                ret[normalized] = entry['instrument_name']\n                _exchange_info[DERIBIT]['tick_size'][normalized] = entry['tick_size']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('DERIBIT', why, {url: r})\n\n\ndef kraken_future_symbols() -> Dict[str, str]:\n    r = None\n    ret = {}\n    try:\n        r = requests.get('https://futures.kraken.com/derivatives/api/v3/instruments')\n        data = r.json()['instruments']\n        for entry in data:\n            if not entry['tradeable']:\n                continue\n            normalized = entry['symbol'].upper().replace(\"_\", \"-\")\n            symbol = normalized[3:6] + SYMBOL_SEP + normalized[6:9]\n            normalized = normalized.replace(normalized[3:9], symbol)\n            normalized = normalized.replace('XBT', 'BTC')\n\n            _exchange_info[KRAKEN_FUTURES]['tick_size'][normalized] = entry['tickSize']\n            _exchange_info[KRAKEN_FUTURES]['contract_size'][normalized] = entry['contractSize']\n            _exchange_info[KRAKEN_FUTURES]['underlying'][normalized] = entry['underlying']\n            _exchange_info[KRAKEN_FUTURES]['product_type'][normalized] = _kraken_futures_product_type[normalized[:2]]\n            ret[normalized] = entry['symbol']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('KRAKEN_FUTURES', why, {\"\": r})\n\n\ndef probit_symbols() -> Dict[str, str]:\n    # doc: https://docs-en.probit.com/reference-link/market\n    r = None\n    try:\n        r = requests.get('https://api.probit.com/api/exchange/v1/market')\n        return {entry['id']: entry['id'] for entry in r.json()['data']}\n    except Exception as why:\n        raise_failure_explanation('PROBIT', why, {\"\": r})\n\n\ndef coingecko_normalize_symbol(symbol: str) -> str:\n    # keep digits, letters and dots, replace others by space\n    symbol = ''.join(c if c.isalnum() or c in ('.', '+') else ' ' for c in symbol)\n    return coingecko_normalize(symbol.upper())\n\n\ndef coingecko_normalize_name(name: str) -> str:\n    # keep digits and letters, replace others by space (except when only composed by upper case letters, digits and dots)\n    if not all(c.isupper() or c.isdigit() or c == '.' for c in name):\n        name = ''.join(c if c.isalnum() else ' ' for c in name)\n    return coingecko_normalize(name)\n\n\ndef coingecko_normalize(sym: str) -> str:\n    sym = sym.strip()\n    # do not concatenate numbers => separate them with a dot\n    sym = list(sym)\n    if len(sym) > 4:\n        for i in range(2, len(sym) - 1):\n            if sym[i] == ' ' and sym[i - 1].isdigit() and sym[i + 1].isdigit():\n                sym[i] = '.'\n    sym = ''.join(sym)\n    # concatenate space-separated words => use CamelCase to distinguish the words\n    if ' ' in sym:\n        if sum(c.islower() for c in sym):  # if there is at least one lower case letter\n            sym = ' '.join(word[0].upper() + word[1:] for word in sym.split())  # Just capitalize initial letter of each word\n        else:  # CoinGecko may provide full upper-case as for \"THE STONE COIN\"\n            sym = string.capwords(sym)  # capwords converts \"THE STONE COIN\" to \"The Stone Coin\"\n        sym = sym.replace(' ', '')  # concatenate words\n    return sym\n\n\ndef is_name_short(coin: dict) -> bool:\n    \"\"\"return True if the coin name is enough short compared to the coin symbol.\"\"\"\n    return len(coin['name']) <= max(5, len(coin['symbol']) + 1)\n\n\ndef has_many_caps(name: str) -> bool:\n    \"\"\"return True if the symbol contains enough upper case letters, False if empty.\"\"\"\n    return str and sum(c.islower() for c in name) < (len(name) / 2)\n\n\ndef coingecko_normalize_all(coin: dict):\n    SYMBOL_TO_NORMALIZED = {'miota': 'IOTA'}\n    normalized = SYMBOL_TO_NORMALIZED.get(coin['symbol'])\n    if normalized:\n        coin['ns'] = coin['nn'] = normalized\n        return normalized\n\n    # ns = normalized symbol, nn = normalized name\n    coin['ns'] = coingecko_normalize_symbol(coin['symbol'])\n\n    ID_SUFFIX = '-bitcoin-token'\n    if coin['id'][-len(ID_SUFFIX):] == ID_SUFFIX:\n        coin['nn'] = 'BTC' + coin['ns']\n        return coin['nn']\n\n    name = coin['name']\n\n    prefixes = ('The ', 'the ')\n    for p in prefixes:\n        if name[:len(p)] == p:\n            coin['reduced-name'] = True\n            name = name[len(p):]\n            break\n\n    suffixes = ('coin', 'coins', 'money', 'finance', 'protocol', 'reward', 'rewards', 'token')\n    for s in suffixes:\n        if len(name) > len(s) and name[-len(s):].lower() == s:\n            # but keep suffix when lower-case concatenated\n            if name[-len(s)].islower() and name[-len(s) - 1] != ' ':\n                continue\n            # also keep suffix to avoid confusing nam: \"Bitcoin Token\" -> \"Bitcoin\"\n            if name[:-len(s)].strip().lower() == 'bitcoin':\n                continue\n            coin['reduced-name'] = True\n            name = name[:-len(s)]\n            break\n\n    coin['nn'] = coingecko_normalize_name(name)\n\n    if len(coin['nn']) < len(coin['ns']):\n        if 'reduced-name' in coin:\n            coin['reduced-name'] = False\n            name = coin['name']\n            coin['nn'] = coingecko_normalize_name(name)\n        elif not has_many_caps(name):\n            return coin['ns']\n\n    if not coin['ns']:  # coin['symbol'] may be an emoji that is striped when normalized\n        return coin['nn']\n\n    if coin.get('reduced-name') and coin['ns'].upper() != coin['nn'].upper():\n        return coin['ns']\n\n    i = coin['nn'].find('.')  # if there is a dot in normalized name => prefer the normalized symbol\n    if i >= 0:\n        if i > 1 and coin['nn'][i - 1].isdigit() and coin['nn'][i + 1].isdigit():\n            pass  # except when the dot separates digits\n        else:\n            return coin['ns']\n\n    if is_name_short(coin) and has_many_caps(name):\n        return coin['nn']\n\n    if 1.5 * len(coin['ns']) > len(coin['nn']) and any(c.islower() for c in coin['ns']):\n        return coin['nn']\n\n    return coin['ns']\n\n\ndef coingecko_symbols() -> Dict[str, str]:\n    r = None\n    intermediate = defaultdict(list)\n    try:\n        r = requests.get('https://api.coingecko.com/api/v3/coins/list')\n        all_coins = r.json()\n        # First pass: generate & compare normalized symbol/name, and then select the most pertinent\n        for coin in all_coins:\n            normalized = coingecko_normalize_all(coin)\n            intermediate[normalized].append(coin)\n            # Above line keeps together the coins having the same normalized symbol.\n            # To reduce collision, the coin['name'] is sometimes used in lieu of the coin['symbol'].\n            # The coin['name'] is not capitalized because lower case letters may be meaningful: cETH, yUSD, DATx, zLOT\n    except Exception as why:\n        raise_failure_explanation('COINGECKO', why, {\"\": r})\n\n    final = coingecko_second_pass(intermediate)\n    return coingecko_third_pass(final)\n\n\ndef coingecko_second_pass(intermediate: Dict[str, List[dict]]) -> Dict[str, List[dict]]:\n    # Second pass: fixes most of the symbol collisions\n    final = defaultdict(list)\n    for normalized, coins in intermediate.items():\n        if len(coins) == 1:\n            final[normalized].append(coins[0])\n            continue\n        set_normalized = False\n        for i in range(len(coins)):\n            if normalized == coins[i]['nn']:\n                coin = coins.pop(i)\n                final[normalized].append(coin)\n                set_normalized = True\n                break\n        rest: List[dict] = []\n        for coin in coins:\n            if '%' in coin['name']:\n                if len(coins) == 1:\n                    n = coin['ns']\n                else:\n                    n = coingecko_normalize_name(coin['id'])\n                final[n].append(coin)\n            else:\n                rest.append(coin)\n        if not rest:\n            continue\n        if not set_normalized:\n            rest.sort(key=lambda coin: len(coin['nn']), reverse=True)  # sort by the length of the normalized name\n            coin = rest.pop(0)\n            final[normalized].append(coin)\n        for coin in rest:\n            if coin['nn'] not in intermediate:\n                n = coin['nn']\n            elif coin.get('reduced-name'):\n                n = coingecko_normalize_name(coin['name'])\n            else:\n                n = coingecko_normalize_name(coin['id'])\n            final[n].append(coin)\n    return final\n\n\ndef coingecko_third_pass(final: Dict[str, List[dict]]) -> Dict[str, str]:\n    # Third pass: fixes some remaining collisions and fills the result\n    symbols = {}\n    for normalized, coins in final.items():\n        if len(coins) == 1:\n            symbols[normalized] = coins[0]['id']\n            continue\n        set_normalized = False\n        for i in range(len(coins)):\n            if normalized == coins[i]['nn']:\n                coin = coins.pop(i)\n                symbols[normalized] = coin['id']\n                set_normalized = True\n                break\n        rest: List[dict] = []\n        for coin in coins:\n            if '%' in coin['name']:\n                if len(coins) == 1:\n                    n = coin['ns']\n                else:\n                    n = coingecko_normalize_name(coin['id'])\n                symbols[n] = coin['id']\n            else:\n                rest.append(coin)\n        if not rest:\n            continue\n        if not set_normalized:\n            rest.sort(key=lambda coin: len(coin['nn']), reverse=True)  # sort by the length of the normalized name\n            coin = rest.pop(0)\n            symbols[normalized] = coin['id']\n        for coin in rest:\n            if coin['nn'] not in final:\n                n = coin['nn']\n            elif coin.get('reduced-name'):\n                n = coingecko_normalize_name(coin['name'])\n            else:\n                n = coingecko_normalize_name(coin['id'])\n            symbols[n] = coin['id']\n    return symbols\n\n\ndef whale_alert_coins(key_id: str) -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get(f'https://api.whale-alert.io/v1/status?api_key={key_id}')\n        # Same symbols, but on different blockchains (for instance USDT), are naturally overwritten.\n        return {s.upper(): s for b in r.json()['blockchains'] for s in b['symbols'] if s}\n    except Exception as why:\n        raise_failure_explanation('WHALES_ALERT', why, {\"\": r})\n\n\n_exchange_function_map = {\n    BITFINEX: bitfinex_symbols,\n    BITFLYER: bitflyer_symbols,\n    COINBASE: coinbase_symbols,\n    GEMINI: gemini_symbols,\n    HITBTC: hitbtc_symbols,\n    POLONIEX: poloniex_symbols,\n    PROBIT: probit_symbols,\n    BITSTAMP: bitstamp_symbols,\n    KRAKEN: kraken_symbols,\n    KRAKEN + 'REST': kraken_rest_symbols,\n    BINANCE: binance_symbols,\n    BINANCE_US: binance_us_symbols,\n    BINANCE_FUTURES: binance_futures_symbols,\n    BINANCE_DELIVERY: binance_delivery_symbols,\n    BLOCKCHAIN: blockchain_symbols,\n    EXX: exx_symbols,\n    HUOBI: huobi_symbols,\n    HUOBI_DM: huobi_dm_symbols,\n    HUOBI_SWAP: huobi_swap_symbols,\n    OKCOIN: okcoin_symbols,\n    OKEX: okex_symbols,\n    BYBIT: bybit_symbols,\n    FTX: ftx_symbols,\n    FTX_US: ftx_us_symbols,\n    BITTREX: bittrex_symbols,\n    BITCOINCOM: bitcoincom_symbols,\n    BITMAX: bitmax_symbols,\n    UPBIT: upbit_symbols,\n    GATEIO: gateio_symbols,\n    BITMEX: bitmex_symbols,\n    DERIBIT: deribit_symbols,\n    KRAKEN_FUTURES: kraken_future_symbols,\n    COINGECKO: coingecko_symbols,\n    WHALE_ALERT: whale_alert_coins\n}\n",
        "source_code_len": 30534,
        "target_code": "associated with this software.\n'''\nfrom typing import Dict, Tuple\n\n\nclass _Symbols:\n    def __init__(self):\n        self.data = {}\n\n    def set(self, exchange: str, normalized: dict, exchange_info: dict):\n        self.data[exchange] = {}\n        self.data[exchange]['normalized'] = normalized\n        self.data[exchange]['info'] = exchange_info\n\n    def get(self, exchange: str) -> Tuple[Dict, Dict]:\n        return self.data[exchange]['normalized'], self.data[exchange]['info']\n\n    def populated(self, exchange: str) -> bool:\n        return exchange in self.data\n\n\nSymbols = _Symbols()\n",
        "target_code_len": 588,
        "diff_format": "@@ -5,845 +5,22 @@\n associated with this software.\n+'''\n+from typing import Dict, Tuple\n \n \n-Symbol generation code for exchanges\n-'''\n+class _Symbols:\n+    def __init__(self):\n+        self.data = {}\n \n-import logging\n-import string\n-import time\n-from collections import defaultdict\n-from typing import Dict, List, Optional, Tuple\n+    def set(self, exchange: str, normalized: dict, exchange_info: dict):\n+        self.data[exchange] = {}\n+        self.data[exchange]['normalized'] = normalized\n+        self.data[exchange]['info'] = exchange_info\n \n-import requests\n-from requests import Response\n+    def get(self, exchange: str) -> Tuple[Dict, Dict]:\n+        return self.data[exchange]['normalized'], self.data[exchange]['info']\n \n-from cryptofeed.defines import *\n+    def populated(self, exchange: str) -> bool:\n+        return exchange in self.data\n \n \n-LOG = logging.getLogger('feedhandler')\n-\n-SYMBOL_SEP = '-'\n-\n-_symbols_retrieval_cache: Dict[str, Dict[str, str]] = {}\n-_exchange_info = defaultdict(lambda: defaultdict(dict))\n-\n-\n-_kraken_futures_product_type = {\n-    'FI': 'Inverse Futures',\n-    'FV': 'Vanilla Futures',\n-    'PI': 'Perpetual Inverse Futures',\n-    'PV': 'Perpetual Vanilla Futures',\n-    'IN': 'Real Time Index',\n-    'RR': 'Reference Rate',\n-}\n-\n-\n-def raise_failure_explanation(feed_id: str, exception: BaseException, responses: Dict[str, Optional[Response]]):\n-    LOG.critical('%s: encountered %r while processing response from exchange API', feed_id, exception)\n-    if len(responses) > 1:\n-        LOG.critical('%s: content of one of the %s responses was unexpected', feed_id, len(responses))\n-    for url, r in responses.items():\n-        if url:\n-            LOG.critical('%s: requested URL: %s', feed_id, url)\n-        if r:\n-            LOG.critical('%s: unexpected response: %s', feed_id, r.text)\n-    raise ValueError(f'Cryptofeed stopped because of an unexpected response from {feed_id}') from exception\n-\n-\n-def set_symbol_separator(separator: str):\n-    global SYMBOL_SEP\n-    SYMBOL_SEP = separator\n-\n-\n-def get_symbol_separator() -> str:\n-    global SYMBOL_SEP\n-    return SYMBOL_SEP\n-\n-\n-def gen_symbols(exchange: str, key_id=None) -> Dict[str, str]:\n-    if exchange not in _symbols_retrieval_cache:\n-        LOG.info(\"%s: Getting list of symbols\", exchange)\n-        symbols = _exchange_function_map[exchange](key_id) if key_id else _exchange_function_map[exchange]()\n-        LOG.info(\"%s: %s symbols\", exchange, len(symbols))\n-\n-        # log all retrieved symbols using debug level\n-        for normalized, exch_sym in sorted(symbols.items()):\n-            LOG.debug('%s: id-from-exch -> normalized: %-35s-> %s', exchange, exch_sym, normalized)\n-\n-        _symbols_retrieval_cache[exchange] = symbols\n-    return _symbols_retrieval_cache[exchange]\n-\n-\n-def _binance_symbols(endpoint: str, exchange: str):\n-    r = None\n-    try:\n-        ret = {}\n-        r = requests.get(endpoint)\n-        for symbol in r.json()['symbols']:\n-            if symbol.get('status', 'TRADING') != \"TRADING\":\n-                continue\n-            if symbol.get('contractStatus', 'TRADING') != \"TRADING\":\n-                continue\n-            split = len(symbol['baseAsset'])\n-            normalized = symbol['symbol'][:split] + SYMBOL_SEP + symbol['symbol'][split:]\n-            ret[normalized] = symbol['symbol']\n-            _exchange_info[exchange]['tick_size'][normalized] = symbol['filters'][0]['tickSize']\n-            if \"contractType\" in symbol:\n-                _exchange_info[exchange]['contract_type'][normalized] = symbol['contractType']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation(exchange, why, {endpoint: r})\n-\n-\n-def binance_symbols() -> Dict[str, str]:\n-    return _binance_symbols('https://api.binance.com/api/v3/exchangeInfo', BINANCE)\n-\n-\n-def binance_us_symbols() -> Dict[str, str]:\n-    return _binance_symbols('https://api.binance.us/api/v3/exchangeInfo', BINANCE_US)\n-\n-\n-def binance_futures_symbols() -> Dict[str, str]:\n-    base = _binance_symbols('https://fapi.binance.com/fapi/v1/exchangeInfo', BINANCE_FUTURES)\n-    add = {}\n-    for symbol, orig in base.items():\n-        if \"_\" in orig:\n-            continue\n-        add[f\"{symbol}-PINDEX\"] = f\"p{orig}\"\n-    base.update(add)\n-    return base\n-\n-\n-def binance_delivery_symbols() -> Dict[str, str]:\n-    return _binance_symbols('https://dapi.binance.com/dapi/v1/exchangeInfo', BINANCE_DELIVERY)\n-\n-\n-def bitfinex_symbols() -> Dict[str, str]:\n-    # doc: https://docs.bitfinex.com/docs/ws-general#supported-pairs\n-    r1 = r2 = None\n-    try:\n-        r1 = requests.get('https://api.bitfinex.com/v2/tickers?symbols=ALL')\n-        r2 = requests.get('https://api-pub.bitfinex.com/v2/conf/pub:map:currency:sym')\n-        tickers: List[List[str]] = r1.json()\n-        norm: List[Tuple[str, str]] = r2.json()[0]\n-        norm: Dict[str, str] = dict(norm)\n-        for k, v in dict(norm).items():\n-            if k[-2:] == 'F0' or '-' in v:  # Do not convert BTCF0 -> BTC or PBTCETH -> PBTC-ETH\n-                del norm[k]\n-        norm['BCHN'] = 'BCH'  # Bitfinex uses BCHN, other exchanges use BCH\n-\n-        ret = {}\n-        for symbol in [t[0] for t in tickers]:\n-            if symbol[0] == 'f':\n-                normalized = norm.get(symbol[1:], symbol[1:])\n-            else:\n-                if len(symbol) == 7:\n-                    base, quote = symbol[1:4], symbol[4:]\n-                else:\n-                    base, quote = symbol[1:].split(':')\n-                    assert ':' in symbol\n-                normalized = norm.get(base, base) + SYMBOL_SEP + norm.get(quote, quote)\n-            ret[normalized.upper()] = symbol\n-        return ret\n-    except ValueError as why:\n-        raise_failure_explanation('BITFINEX', why, {\"tickers?symbols=ALL\": r1, \"pub:map:currency:sym\": r2})\n-\n-\n-def bitflyer_symbols() -> Dict[str, str]:\n-    endpoint = r = None\n-    try:\n-        ret = {}\n-        endpoints = ['https://api.bitflyer.com/v1/getmarkets/eu', 'https://api.bitflyer.com/v1/getmarkets/usa', 'https://api.bitflyer.com/v1/getmarkets']\n-        for endpoint in endpoints:\n-            r = requests.get(endpoint)\n-            for entry in r.json():\n-                normalized = entry['product_code'].replace(\"_\", SYMBOL_SEP)\n-                ret[normalized] = entry['product_code']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('BITFLYER', why, {endpoint: r})\n-\n-\n-def bybit_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.bybit.com/v2/public/symbols')\n-        ret = {}\n-        for symbol in r.json()['result']:\n-            quote = symbol['quote_currency']\n-            if not symbol['name'].endswith(quote):\n-                base, contract = symbol['name'].split(quote)\n-                normalized = f\"{base}{SYMBOL_SEP}{quote}-{contract}\"\n-            else:\n-                normalized = f\"{symbol['base_currency']}{SYMBOL_SEP}{quote}\"\n-            ret[normalized] = symbol['name']\n-            _exchange_info[BYBIT]['tick_size'][normalized] = symbol['price_filter']['tick_size']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('BYBIT', why, {\"\": r})\n-\n-\n-def _ftx_helper(endpoint: str, exchange: str):\n-    r = None\n-    try:\n-        r = requests.get(endpoint)\n-        ret = {}\n-        for data in r.json()['result']:\n-            normalized = data['name'].replace(\"/\", SYMBOL_SEP)\n-            symbol = data['name']\n-            ret[normalized] = symbol\n-            _exchange_info[exchange]['tick_size'][normalized] = data['priceIncrement']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation(exchange, why, {endpoint: r})\n-\n-\n-def ftx_symbols() -> Dict[str, str]:\n-    return _ftx_helper('https://ftx.com/api/markets', FTX)\n-\n-\n-def ftx_us_symbols() -> Dict[str, str]:\n-    return _ftx_helper('https://ftx.us/api/markets', FTX_US)\n-\n-\n-def coinbase_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.pro.coinbase.com/products')\n-        ret = {}\n-        for data in r.json():\n-            normalized = data['id'].replace(\"-\", SYMBOL_SEP)\n-            ret[normalized] = data['id']\n-            _exchange_info[COINBASE]['tick_size'][normalized] = data['quote_increment']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('COINBASE', why, {\"\": r})\n-\n-\n-def gemini_symbols(*args) -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.gemini.com/v1/symbols')\n-        ret = {}\n-        for symbol in r.json():\n-            std = f\"{symbol[:-3]}{SYMBOL_SEP}{symbol[-3:]}\"\n-            std = std.upper()\n-            ret[std] = symbol.upper()\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('GEMINI', why, {\"\": r})\n-\n-\n-def hitbtc_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        ret = {}\n-        r = requests.get('https://api.hitbtc.com/api/2/public/symbol')\n-        for symbol in r.json():\n-            split = len(symbol['baseCurrency'])\n-            normalized = symbol['id'][:split] + SYMBOL_SEP + symbol['id'][split:]\n-            ret[normalized] = symbol['id']\n-            _exchange_info[HITBTC]['tick_size'][normalized] = symbol['tickSize']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('HITBTC', why, {\"\": r})\n-\n-\n-def poloniex_id_symbol_mapping():\n-    r = None\n-    try:\n-        r = requests.get('https://poloniex.com/public?command=returnTicker')\n-        symbols = r.json()\n-        ret = {}\n-        for symbol in symbols:\n-            ret[symbols[symbol]['id']] = symbol\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('POLONIEX', why, {\"\": r})\n-\n-\n-def poloniex_symbols() -> Dict[str, str]:\n-    ret = {}\n-    for _, value in poloniex_id_symbol_mapping().items():\n-        std = value.replace(\"STR\", \"XLM\")\n-        quote, base = std.split(\"_\")\n-        ret[quote + SYMBOL_SEP + base] = value\n-    return ret\n-\n-\n-def bitstamp_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://www.bitstamp.net/api/v2/trading-pairs-info/')\n-        ret = {}\n-        for data in r.json():\n-            normalized = data['name'].replace(\"/\", SYMBOL_SEP)\n-            symbol = data['url_symbol']\n-            ret[normalized] = symbol\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('BITSTAMP', why, {\"\": r})\n-\n-\n-def kraken_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.kraken.com/0/public/AssetPairs')\n-        data = r.json()\n-        ret = {}\n-        for symbol in data['result']:\n-            if 'wsname' not in data['result'][symbol] or '.d' in symbol:\n-                # https://blog.kraken.com/post/259/introducing-the-kraken-dark-pool/\n-                # .d is for dark pool symbols\n-                continue\n-\n-            base, quote = data['result'][symbol]['wsname'].split(\"/\")\n-\n-            normalized = f\"{base}{SYMBOL_SEP}{quote}\"\n-            exch = data['result'][symbol]['wsname']\n-            normalized = normalized.replace('XBT', 'BTC')\n-            normalized = normalized.replace('XDG', 'DOG')\n-            ret[normalized] = exch\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('KRAKEN', why, {\"\": r})\n-\n-\n-def kraken_rest_symbols() -> Dict[str, str]:\n-    return {normalized: exchange.replace(\"/\", \"\") for normalized, exchange in kraken_symbols().items()}\n-\n-\n-def exx_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.exx.com/data/v1/tickers')\n-        exchange = [key.upper() for key in r.json().keys()]\n-        symbols = [key.replace(\"_\", SYMBOL_SEP) for key in exchange]\n-        return dict(zip(symbols, exchange))\n-    except Exception as why:\n-        raise_failure_explanation('EXX', why, {\"\": r})\n-\n-\n-def huobi_common_symbols(url: str):\n-    r = None\n-    try:\n-        r = requests.get(url)\n-        ret = {}\n-        for e in r.json()['data']:\n-            if e['state'] == 'offline':\n-                continue\n-            normalized = f\"{e['base-currency'].upper()}{SYMBOL_SEP}{e['quote-currency'].upper()}\"\n-            symbol = f\"{e['base-currency']}{e['quote-currency']}\"\n-            ret[normalized] = symbol\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('HUOBI', why, {url: r})\n-\n-\n-def huobi_symbols() -> Dict[str, str]:\n-    return huobi_common_symbols('https://api.huobi.pro/v1/common/symbols')\n-\n-\n-def huobi_us_symbols() -> Dict[str, str]:\n-    return huobi_common_symbols('https://api.huobi.com/v1/common/symbols')\n-\n-\n-def huobi_dm_symbols() -> Dict[str, str]:\n-    \"\"\"\n-    Mapping is, for instance: {\"BTC_CW\":\"BTC190816\"}\n-    See comments in exchange/huobi_dm.py\n-    \"\"\"\n-    mapping = {\n-        \"this_week\": \"CW\",\n-        \"next_week\": \"NW\",\n-        \"quarter\": \"CQ\",\n-        \"next_quarter\": \"NQ\"\n-    }\n-    r = None\n-    try:\n-        r = requests.get('https://www.hbdm.com/api/v1/contract_contract_info')\n-        symbols = {}\n-        for e in r.json()['data']:\n-            symbols[f\"{e['symbol']}_{mapping[e['contract_type']]}\"] = e['contract_code']\n-            _exchange_info[HUOBI_DM]['tick_size'][e['contract_code']] = e['price_tick']\n-            _exchange_info[HUOBI_DM]['short_code_mappings'][f\"{e['symbol']}_{mapping[e['contract_type']]}\"] = e['contract_code']\n-        return symbols\n-    except Exception as why:\n-        raise_failure_explanation('HUOBI_DM', why, {\"\": r})\n-\n-\n-def huobi_swap_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.hbdm.com/swap-api/v1/swap_contract_info')\n-        symbols = {}\n-        for e in r.json()['data']:\n-            symbols[e['contract_code']] = e['contract_code']\n-            _exchange_info[HUOBI_SWAP]['tick_size'][e['contract_code']] = e['price_tick']\n-        return symbols\n-    except Exception as why:\n-        raise_failure_explanation('HUOBI_SWAP', why, {\"\": r})\n-\n-\n-def okcoin_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://www.okcoin.com/api/spot/v3/instruments')\n-        ret = {}\n-        for e in r.json():\n-            ret[e['instrument_id']] = e['instrument_id']\n-            _exchange_info[OKCOIN]['tick_size'][e['instrument_id']] = e['tick_size']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('OKCOIN', why, {\"\": r})\n-\n-\n-def okex_symbols(*args) -> Dict[str, str]:\n-    urls = ['https://www.okex.com/api/spot/v3/instruments',\n-            'https://www.okex.com/api/swap/v3/instruments',\n-            'https://www.okex.com/api/futures/v3/instruments']\n-    urls = urls + okex_compute_option_urls_from_underlyings()\n-\n-    symbols: Dict[str, str] = {}\n-    for u in urls:\n-        time.sleep(0.2)\n-        symbols.update(okex_symbols_from_one_url(u))\n-\n-    for symbol in symbols:\n-        instrument_type = 'futures'\n-        dash_count = symbol.count(get_symbol_separator())\n-        if dash_count == 1:  # BTC-USDT\n-            instrument_type = 'spot'\n-        if dash_count == 4:  # BTC-USD-201225-35000-P\n-            instrument_type = 'option'\n-        if symbol[-4:] == \"SWAP\":  # BTC-USDT-SWAP\n-            instrument_type = 'swap'\n-\n-        _exchange_info[OKEX]['instrument_type'][symbol] = instrument_type\n-\n-    return symbols\n-\n-\n-def okex_compute_option_urls_from_underlyings() -> List[str]:\n-    url = 'https://www.okex.com/api/option/v3/underlying'\n-    r = None\n-    try:\n-        r = requests.get(url)\n-        return [f'https://www.okex.com/api/option/v3/instruments/{underlying}' for underlying in r.json()]\n-    except Exception as why:\n-        raise_failure_explanation('OKEX', why, {url: r})\n-\n-\n-def okex_symbols_from_one_url(url: str) -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get(url)\n-        ret = {}\n-        for e in r.json():\n-            ret[e['instrument_id']] = e['instrument_id']\n-            _exchange_info[OKEX]['tick_size'][e['instrument_id']] = e['tick_size']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('OKEX', why, {url: r})\n-\n-\n-def bittrex_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.bittrex.com/api/v1.1/public/getmarkets')\n-        r = r.json()['result']\n-        return {f\"{e['MarketCurrency']}{SYMBOL_SEP}{e['BaseCurrency']}\": e['MarketName'] for e in r if e['IsActive']}\n-    except Exception as why:\n-        raise_failure_explanation('BITTREX', why, {\"\": r})\n-\n-\n-def bitcoincom_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.exchange.bitcoin.com/api/2/public/symbol')\n-        return {f\"{data['baseCurrency']}{SYMBOL_SEP}{data['quoteCurrency'].replace('USD', 'USDT')}\": data['id'] for data in r.json()}\n-    except Exception as why:\n-        raise_failure_explanation('BITCOINCOM', why, {\"\": r})\n-\n-\n-def bitmax_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://bitmax.io/api/pro/v1/products')\n-        ret = {}\n-        for entry in r.json()['data']:\n-            # Only \"Normal\" status symbols are tradeable\n-            if entry['status'] == 'Normal':\n-                normalized = f\"{entry['baseAsset']}{SYMBOL_SEP}{entry['quoteAsset']}\"\n-                ret[normalized] = entry['symbol']\n-                _exchange_info[BITMAX]['tick_size'][normalized] = entry['tickSize']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('BITMAX', why, {\"\": r})\n-\n-\n-def upbit_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.upbit.com/v1/market/all')\n-        return {f\"{data['market'].split('-')[1]}{SYMBOL_SEP}{data['market'].split('-')[0]}\": data['market'] for data in r.json()}\n-    except Exception as why:\n-        raise_failure_explanation('UPBIT', why, {\"\": r})\n-\n-\n-def blockchain_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get(\"https://api.blockchain.com/mercury-gateway/v1/instruments\")\n-        return {data[\"symbol\"].replace(\"-\", SYMBOL_SEP): data[\"symbol\"] for data in r.json()}\n-    except Exception as why:\n-        raise_failure_explanation('BLOCKCHAIN', why, {\"\": r})\n-\n-\n-def gateio_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get(\"https://api.gateio.ws/api/v4/spot/currency_pairs\")\n-        return {data[\"id\"].replace(\"_\", SYMBOL_SEP): data['id'] for data in r.json()}\n-    except Exception as why:\n-        raise_failure_explanation('GATEIO', why, {\"\": r})\n-\n-\n-def bitmex_symbols() -> Dict[str, str]:\n-    r = None\n-    ret = {}\n-    try:\n-        r = requests.get(\"https://www.bitmex.com/api/v1/instrument/active\")\n-        for entry in r.json():\n-            components = []\n-            components.append(entry['rootSymbol'])\n-            components.append(entry['quoteCurrency'])\n-\n-            if entry['expiry']:\n-                components.append(entry['symbol'][-3:])\n-\n-            normalized = SYMBOL_SEP.join(components)\n-            normalized = normalized.replace(\"XBT\", \"BTC\")\n-            ret[normalized] = entry['symbol']\n-            _exchange_info[BITMEX]['tick_size'][normalized] = entry['tickSize']\n-\n-            if entry['expiry']:\n-                _exchange_info[BITMEX]['expiry'][normalized] = entry['expiry']\n-\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('BITMEX', why, {\"\": r})\n-\n-\n-def deribit_symbols() -> Dict[str, str]:\n-    url = r = None\n-    ret = {}\n-    try:\n-        # TODO: get currencies from https://www.deribit.com/api/v2/public/get_currencies\n-        currencies = ['BTC', 'ETH']\n-        for c in currencies:\n-            url = f\"https://www.deribit.com/api/v2/public/get_instruments?currency={c}&expired=false\"\n-            r = requests.get(url)\n-            for entry in r.json()['result']:\n-                split = entry['instrument_name'].split(\"-\")\n-                normalized = split[0] + SYMBOL_SEP + entry['quote_currency'] + \"-\" + '-'.join(split[1:])\n-                ret[normalized] = entry['instrument_name']\n-                _exchange_info[DERIBIT]['tick_size'][normalized] = entry['tick_size']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('DERIBIT', why, {url: r})\n-\n-\n-def kraken_future_symbols() -> Dict[str, str]:\n-    r = None\n-    ret = {}\n-    try:\n-        r = requests.get('https://futures.kraken.com/derivatives/api/v3/instruments')\n-        data = r.json()['instruments']\n-        for entry in data:\n-            if not entry['tradeable']:\n-                continue\n-            normalized = entry['symbol'].upper().replace(\"_\", \"-\")\n-            symbol = normalized[3:6] + SYMBOL_SEP + normalized[6:9]\n-            normalized = normalized.replace(normalized[3:9], symbol)\n-            normalized = normalized.replace('XBT', 'BTC')\n-\n-            _exchange_info[KRAKEN_FUTURES]['tick_size'][normalized] = entry['tickSize']\n-            _exchange_info[KRAKEN_FUTURES]['contract_size'][normalized] = entry['contractSize']\n-            _exchange_info[KRAKEN_FUTURES]['underlying'][normalized] = entry['underlying']\n-            _exchange_info[KRAKEN_FUTURES]['product_type'][normalized] = _kraken_futures_product_type[normalized[:2]]\n-            ret[normalized] = entry['symbol']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('KRAKEN_FUTURES', why, {\"\": r})\n-\n-\n-def probit_symbols() -> Dict[str, str]:\n-    # doc: https://docs-en.probit.com/reference-link/market\n-    r = None\n-    try:\n-        r = requests.get('https://api.probit.com/api/exchange/v1/market')\n-        return {entry['id']: entry['id'] for entry in r.json()['data']}\n-    except Exception as why:\n-        raise_failure_explanation('PROBIT', why, {\"\": r})\n-\n-\n-def coingecko_normalize_symbol(symbol: str) -> str:\n-    # keep digits, letters and dots, replace others by space\n-    symbol = ''.join(c if c.isalnum() or c in ('.', '+') else ' ' for c in symbol)\n-    return coingecko_normalize(symbol.upper())\n-\n-\n-def coingecko_normalize_name(name: str) -> str:\n-    # keep digits and letters, replace others by space (except when only composed by upper case letters, digits and dots)\n-    if not all(c.isupper() or c.isdigit() or c == '.' for c in name):\n-        name = ''.join(c if c.isalnum() else ' ' for c in name)\n-    return coingecko_normalize(name)\n-\n-\n-def coingecko_normalize(sym: str) -> str:\n-    sym = sym.strip()\n-    # do not concatenate numbers => separate them with a dot\n-    sym = list(sym)\n-    if len(sym) > 4:\n-        for i in range(2, len(sym) - 1):\n-            if sym[i] == ' ' and sym[i - 1].isdigit() and sym[i + 1].isdigit():\n-                sym[i] = '.'\n-    sym = ''.join(sym)\n-    # concatenate space-separated words => use CamelCase to distinguish the words\n-    if ' ' in sym:\n-        if sum(c.islower() for c in sym):  # if there is at least one lower case letter\n-            sym = ' '.join(word[0].upper() + word[1:] for word in sym.split())  # Just capitalize initial letter of each word\n-        else:  # CoinGecko may provide full upper-case as for \"THE STONE COIN\"\n-            sym = string.capwords(sym)  # capwords converts \"THE STONE COIN\" to \"The Stone Coin\"\n-        sym = sym.replace(' ', '')  # concatenate words\n-    return sym\n-\n-\n-def is_name_short(coin: dict) -> bool:\n-    \"\"\"return True if the coin name is enough short compared to the coin symbol.\"\"\"\n-    return len(coin['name']) <= max(5, len(coin['symbol']) + 1)\n-\n-\n-def has_many_caps(name: str) -> bool:\n-    \"\"\"return True if the symbol contains enough upper case letters, False if empty.\"\"\"\n-    return str and sum(c.islower() for c in name) < (len(name) / 2)\n-\n-\n-def coingecko_normalize_all(coin: dict):\n-    SYMBOL_TO_NORMALIZED = {'miota': 'IOTA'}\n-    normalized = SYMBOL_TO_NORMALIZED.get(coin['symbol'])\n-    if normalized:\n-        coin['ns'] = coin['nn'] = normalized\n-        return normalized\n-\n-    # ns = normalized symbol, nn = normalized name\n-    coin['ns'] = coingecko_normalize_symbol(coin['symbol'])\n-\n-    ID_SUFFIX = '-bitcoin-token'\n-    if coin['id'][-len(ID_SUFFIX):] == ID_SUFFIX:\n-        coin['nn'] = 'BTC' + coin['ns']\n-        return coin['nn']\n-\n-    name = coin['name']\n-\n-    prefixes = ('The ', 'the ')\n-    for p in prefixes:\n-        if name[:len(p)] == p:\n-            coin['reduced-name'] = True\n-            name = name[len(p):]\n-            break\n-\n-    suffixes = ('coin', 'coins', 'money', 'finance', 'protocol', 'reward', 'rewards', 'token')\n-    for s in suffixes:\n-        if len(name) > len(s) and name[-len(s):].lower() == s:\n-            # but keep suffix when lower-case concatenated\n-            if name[-len(s)].islower() and name[-len(s) - 1] != ' ':\n-                continue\n-            # also keep suffix to avoid confusing nam: \"Bitcoin Token\" -> \"Bitcoin\"\n-            if name[:-len(s)].strip().lower() == 'bitcoin':\n-                continue\n-            coin['reduced-name'] = True\n-            name = name[:-len(s)]\n-            break\n-\n-    coin['nn'] = coingecko_normalize_name(name)\n-\n-    if len(coin['nn']) < len(coin['ns']):\n-        if 'reduced-name' in coin:\n-            coin['reduced-name'] = False\n-            name = coin['name']\n-            coin['nn'] = coingecko_normalize_name(name)\n-        elif not has_many_caps(name):\n-            return coin['ns']\n-\n-    if not coin['ns']:  # coin['symbol'] may be an emoji that is striped when normalized\n-        return coin['nn']\n-\n-    if coin.get('reduced-name') and coin['ns'].upper() != coin['nn'].upper():\n-        return coin['ns']\n-\n-    i = coin['nn'].find('.')  # if there is a dot in normalized name => prefer the normalized symbol\n-    if i >= 0:\n-        if i > 1 and coin['nn'][i - 1].isdigit() and coin['nn'][i + 1].isdigit():\n-            pass  # except when the dot separates digits\n-        else:\n-            return coin['ns']\n-\n-    if is_name_short(coin) and has_many_caps(name):\n-        return coin['nn']\n-\n-    if 1.5 * len(coin['ns']) > len(coin['nn']) and any(c.islower() for c in coin['ns']):\n-        return coin['nn']\n-\n-    return coin['ns']\n-\n-\n-def coingecko_symbols() -> Dict[str, str]:\n-    r = None\n-    intermediate = defaultdict(list)\n-    try:\n-        r = requests.get('https://api.coingecko.com/api/v3/coins/list')\n-        all_coins = r.json()\n-        # First pass: generate & compare normalized symbol/name, and then select the most pertinent\n-        for coin in all_coins:\n-            normalized = coingecko_normalize_all(coin)\n-            intermediate[normalized].append(coin)\n-            # Above line keeps together the coins having the same normalized symbol.\n-            # To reduce collision, the coin['name'] is sometimes used in lieu of the coin['symbol'].\n-            # The coin['name'] is not capitalized because lower case letters may be meaningful: cETH, yUSD, DATx, zLOT\n-    except Exception as why:\n-        raise_failure_explanation('COINGECKO', why, {\"\": r})\n-\n-    final = coingecko_second_pass(intermediate)\n-    return coingecko_third_pass(final)\n-\n-\n-def coingecko_second_pass(intermediate: Dict[str, List[dict]]) -> Dict[str, List[dict]]:\n-    # Second pass: fixes most of the symbol collisions\n-    final = defaultdict(list)\n-    for normalized, coins in intermediate.items():\n-        if len(coins) == 1:\n-            final[normalized].append(coins[0])\n-            continue\n-        set_normalized = False\n-        for i in range(len(coins)):\n-            if normalized == coins[i]['nn']:\n-                coin = coins.pop(i)\n-                final[normalized].append(coin)\n-                set_normalized = True\n-                break\n-        rest: List[dict] = []\n-        for coin in coins:\n-            if '%' in coin['name']:\n-                if len(coins) == 1:\n-                    n = coin['ns']\n-                else:\n-                    n = coingecko_normalize_name(coin['id'])\n-                final[n].append(coin)\n-            else:\n-                rest.append(coin)\n-        if not rest:\n-            continue\n-        if not set_normalized:\n-            rest.sort(key=lambda coin: len(coin['nn']), reverse=True)  # sort by the length of the normalized name\n-            coin = rest.pop(0)\n-            final[normalized].append(coin)\n-        for coin in rest:\n-            if coin['nn'] not in intermediate:\n-                n = coin['nn']\n-            elif coin.get('reduced-name'):\n-                n = coingecko_normalize_name(coin['name'])\n-            else:\n-                n = coingecko_normalize_name(coin['id'])\n-            final[n].append(coin)\n-    return final\n-\n-\n-def coingecko_third_pass(final: Dict[str, List[dict]]) -> Dict[str, str]:\n-    # Third pass: fixes some remaining collisions and fills the result\n-    symbols = {}\n-    for normalized, coins in final.items():\n-        if len(coins) == 1:\n-            symbols[normalized] = coins[0]['id']\n-            continue\n-        set_normalized = False\n-        for i in range(len(coins)):\n-            if normalized == coins[i]['nn']:\n-                coin = coins.pop(i)\n-                symbols[normalized] = coin['id']\n-                set_normalized = True\n-                break\n-        rest: List[dict] = []\n-        for coin in coins:\n-            if '%' in coin['name']:\n-                if len(coins) == 1:\n-                    n = coin['ns']\n-                else:\n-                    n = coingecko_normalize_name(coin['id'])\n-                symbols[n] = coin['id']\n-            else:\n-                rest.append(coin)\n-        if not rest:\n-            continue\n-        if not set_normalized:\n-            rest.sort(key=lambda coin: len(coin['nn']), reverse=True)  # sort by the length of the normalized name\n-            coin = rest.pop(0)\n-            symbols[normalized] = coin['id']\n-        for coin in rest:\n-            if coin['nn'] not in final:\n-                n = coin['nn']\n-            elif coin.get('reduced-name'):\n-                n = coingecko_normalize_name(coin['name'])\n-            else:\n-                n = coingecko_normalize_name(coin['id'])\n-            symbols[n] = coin['id']\n-    return symbols\n-\n-\n-def whale_alert_coins(key_id: str) -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get(f'https://api.whale-alert.io/v1/status?api_key={key_id}')\n-        # Same symbols, but on different blockchains (for instance USDT), are naturally overwritten.\n-        return {s.upper(): s for b in r.json()['blockchains'] for s in b['symbols'] if s}\n-    except Exception as why:\n-        raise_failure_explanation('WHALES_ALERT', why, {\"\": r})\n-\n-\n-_exchange_function_map = {\n-    BITFINEX: bitfinex_symbols,\n-    BITFLYER: bitflyer_symbols,\n-    COINBASE: coinbase_symbols,\n-    GEMINI: gemini_symbols,\n-    HITBTC: hitbtc_symbols,\n-    POLONIEX: poloniex_symbols,\n-    PROBIT: probit_symbols,\n-    BITSTAMP: bitstamp_symbols,\n-    KRAKEN: kraken_symbols,\n-    KRAKEN + 'REST': kraken_rest_symbols,\n-    BINANCE: binance_symbols,\n-    BINANCE_US: binance_us_symbols,\n-    BINANCE_FUTURES: binance_futures_symbols,\n-    BINANCE_DELIVERY: binance_delivery_symbols,\n-    BLOCKCHAIN: blockchain_symbols,\n-    EXX: exx_symbols,\n-    HUOBI: huobi_symbols,\n-    HUOBI_DM: huobi_dm_symbols,\n-    HUOBI_SWAP: huobi_swap_symbols,\n-    OKCOIN: okcoin_symbols,\n-    OKEX: okex_symbols,\n-    BYBIT: bybit_symbols,\n-    FTX: ftx_symbols,\n-    FTX_US: ftx_us_symbols,\n-    BITTREX: bittrex_symbols,\n-    BITCOINCOM: bitcoincom_symbols,\n-    BITMAX: bitmax_symbols,\n-    UPBIT: upbit_symbols,\n-    GATEIO: gateio_symbols,\n-    BITMEX: bitmex_symbols,\n-    DERIBIT: deribit_symbols,\n-    KRAKEN_FUTURES: kraken_future_symbols,\n-    COINGECKO: coingecko_symbols,\n-    WHALE_ALERT: whale_alert_coins\n-}\n+Symbols = _Symbols()\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\n\nimport logging\nimport string\nimport time\nfrom collections import defaultdict\nfrom typing import Dict, List, Optional, Tuple\n\nimport requests\nfrom requests import Response\n\nfrom cryptofeed.defines import *\n\n\nLOG = logging.getLogger('feedhandler')\n\nSYMBOL_SEP = '-'\n\n_symbols_retrieval_cache: Dict[str, Dict[str, str]] = {}\n_exchange_info = defaultdict(lambda: defaultdict(dict))\n\n\n_kraken_futures_product_type = {\n    'FI': 'Inverse Futures',\n    'FV': 'Vanilla Futures',\n    'PI': 'Perpetual Inverse Futures',\n    'PV': 'Perpetual Vanilla Futures',\n    'IN': 'Real Time Index',\n    'RR': 'Reference Rate',\n}\n\n\ndef raise_failure_explanation(feed_id: str, exception: BaseException, responses: Dict[str, Optional[Response]]):\n    <IND>LOG.critical('%s: encountered %r while processing response from exchange API', feed_id, exception)\n    if len(responses) > 1:\n        <IND>LOG.critical('%s: content of one of the %s responses was unexpected', feed_id, len(responses))\n    <DED>for url, r in responses.items():\n        <IND>if url:\n            <IND>LOG.critical('%s: requested URL: %s', feed_id, url)\n        <DED>if r:\n            <IND>LOG.critical('%s: unexpected response: %s', feed_id, r.text)\n    <DED><DED>raise ValueError(f'Cryptofeed stopped because of an unexpected response from {feed_id}') from exception\n\n\n<DED>def set_symbol_separator(separator: str):\n    <IND>global SYMBOL_SEP\n    SYMBOL_SEP = separator\n\n\n<DED>def get_symbol_separator() -> str:\n    <IND>global SYMBOL_SEP\n    return SYMBOL_SEP\n\n\n<DED>def gen_symbols(exchange: str, key_id=None) -> Dict[str, str]:\n    <IND>if exchange not in _symbols_retrieval_cache:\n        <IND>LOG.info(\"%s: Getting list of symbols\", exchange)\n        symbols = _exchange_function_map[exchange](key_id) if key_id else _exchange_function_map[exchange]()\n        LOG.info(\"%s: %s symbols\", exchange, len(symbols))\n\n        # log all retrieved symbols using debug level\n        for normalized, exch_sym in sorted(symbols.items()):\n            <IND>LOG.debug('%s: id-from-exch -> normalized: %-35s-> %s', exchange, exch_sym, normalized)\n\n        <DED>_symbols_retrieval_cache[exchange] = symbols\n    <DED>return _symbols_retrieval_cache[exchange]\n\n\n<DED>def _binance_symbols(endpoint: str, exchange: str):\n    <IND>r = None\n    try:\n        <IND>ret = {}\n        r = requests.get(endpoint)\n        for symbol in r.json()['symbols']:\n            <IND>if symbol.get('status', 'TRADING') != \"TRADING\":\n                <IND>continue\n            <DED>if symbol.get('contractStatus', 'TRADING') != \"TRADING\":\n                <IND>continue\n            <DED>split = len(symbol['baseAsset'])\n            normalized = symbol['symbol'][:split] + SYMBOL_SEP + symbol['symbol'][split:]\n            ret[normalized] = symbol['symbol']\n            _exchange_info[exchange]['tick_size'][normalized] = symbol['filters'][0]['tickSize']\n            if \"contractType\" in symbol:\n                <IND>_exchange_info[exchange]['contract_type'][normalized] = symbol['contractType']\n        <DED><DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation(exchange, why, {endpoint: r})\n\n\n<DED><DED>def binance_symbols() -> Dict[str, str]:\n    <IND>return _binance_symbols('https://api.binance.com/api/v3/exchangeInfo', BINANCE)\n\n\n<DED>def binance_us_symbols() -> Dict[str, str]:\n    <IND>return _binance_symbols('https://api.binance.us/api/v3/exchangeInfo', BINANCE_US)\n\n\n<DED>def binance_futures_symbols() -> Dict[str, str]:\n    <IND>base = _binance_symbols('https://fapi.binance.com/fapi/v1/exchangeInfo', BINANCE_FUTURES)\n    add = {}\n    for symbol, orig in base.items():\n        <IND>if \"_\" in orig:\n            <IND>continue\n        <DED>add[f\"{symbol}-PINDEX\"] = f\"p{orig}\"\n    <DED>base.update(add)\n    return base\n\n\n<DED>def binance_delivery_symbols() -> Dict[str, str]:\n    <IND>return _binance_symbols('https://dapi.binance.com/dapi/v1/exchangeInfo', BINANCE_DELIVERY)\n\n\n<DED>def bitfinex_symbols() -> Dict[str, str]:\n    # doc: https://docs.bitfinex.com/docs/ws-general#supported-pairs\n    <IND>r1 = r2 = None\n    try:\n        <IND>r1 = requests.get('https://api.bitfinex.com/v2/tickers?symbols=ALL')\n        r2 = requests.get('https://api-pub.bitfinex.com/v2/conf/pub:map:currency:sym')\n        tickers: List[List[str]] = r1.json()\n        norm: List[Tuple[str, str]] = r2.json()[0]\n        norm: Dict[str, str] = dict(norm)\n        for k, v in dict(norm).items():\n            <IND>if k[-2:] == 'F0' or '-' in v:  # Do not convert BTCF0 -> BTC or PBTCETH -> PBTC-ETH\n                <IND>del norm[k]\n        <DED><DED>norm['BCHN'] = 'BCH'  # Bitfinex uses BCHN, other exchanges use BCH\n\n        ret = {}\n        for symbol in [t[0] for t in tickers]:\n            <IND>if symbol[0] == 'f':\n                <IND>normalized = norm.get(symbol[1:], symbol[1:])\n            <DED>else:\n                <IND>if len(symbol) == 7:\n                    <IND>base, quote = symbol[1:4], symbol[4:]\n                <DED>else:\n                    <IND>base, quote = symbol[1:].split(':')\n                    assert ':' in symbol\n                <DED>normalized = norm.get(base, base) + SYMBOL_SEP + norm.get(quote, quote)\n            <DED>ret[normalized.upper()] = symbol\n        <DED>return ret\n    <DED>except ValueError as why:\n        <IND>raise_failure_explanation('BITFINEX', why, {\"tickers?symbols=ALL\": r1, \"pub:map:currency:sym\": r2})\n\n\n<DED><DED>def bitflyer_symbols() -> Dict[str, str]:\n    <IND>endpoint = r = None\n    try:\n        <IND>ret = {}\n        endpoints = ['https://api.bitflyer.com/v1/getmarkets/eu', 'https://api.bitflyer.com/v1/getmarkets/usa', 'https://api.bitflyer.com/v1/getmarkets']\n        for endpoint in endpoints:\n            <IND>r = requests.get(endpoint)\n            for entry in r.json():\n                <IND>normalized = entry['product_code'].replace(\"_\", SYMBOL_SEP)\n                ret[normalized] = entry['product_code']\n        <DED><DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BITFLYER', why, {endpoint: r})\n\n\n<DED><DED>def bybit_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.bybit.com/v2/public/symbols')\n        ret = {}\n        for symbol in r.json()['result']:\n            <IND>quote = symbol['quote_currency']\n            if not symbol['name'].endswith(quote):\n                <IND>base, contract = symbol['name'].split(quote)\n                normalized = f\"{base}{SYMBOL_SEP}{quote}-{contract}\"\n            <DED>else:\n                <IND>normalized = f\"{symbol['base_currency']}{SYMBOL_SEP}{quote}\"\n            <DED>ret[normalized] = symbol['name']\n            _exchange_info[BYBIT]['tick_size'][normalized] = symbol['price_filter']['tick_size']\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BYBIT', why, {\"\": r})\n\n\n<DED><DED>def _ftx_helper(endpoint: str, exchange: str):\n    <IND>r = None\n    try:\n        <IND>r = requests.get(endpoint)\n        ret = {}\n        for data in r.json()['result']:\n            <IND>normalized = data['name'].replace(\"/\", SYMBOL_SEP)\n            symbol = data['name']\n            ret[normalized] = symbol\n            _exchange_info[exchange]['tick_size'][normalized] = data['priceIncrement']\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation(exchange, why, {endpoint: r})\n\n\n<DED><DED>def ftx_symbols() -> Dict[str, str]:\n    <IND>return _ftx_helper('https://ftx.com/api/markets', FTX)\n\n\n<DED>def ftx_us_symbols() -> Dict[str, str]:\n    <IND>return _ftx_helper('https://ftx.us/api/markets', FTX_US)\n\n\n<DED>def coinbase_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.pro.coinbase.com/products')\n        ret = {}\n        for data in r.json():\n            <IND>normalized = data['id'].replace(\"-\", SYMBOL_SEP)\n            ret[normalized] = data['id']\n            _exchange_info[COINBASE]['tick_size'][normalized] = data['quote_increment']\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('COINBASE', why, {\"\": r})\n\n\n<DED><DED>def gemini_symbols(*args) -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.gemini.com/v1/symbols')\n        ret = {}\n        for symbol in r.json():\n            <IND>std = f\"{symbol[:-3]}{SYMBOL_SEP}{symbol[-3:]}\"\n            std = std.upper()\n            ret[std] = symbol.upper()\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('GEMINI', why, {\"\": r})\n\n\n<DED><DED>def hitbtc_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>ret = {}\n        r = requests.get('https://api.hitbtc.com/api/2/public/symbol')\n        for symbol in r.json():\n            <IND>split = len(symbol['baseCurrency'])\n            normalized = symbol['id'][:split] + SYMBOL_SEP + symbol['id'][split:]\n            ret[normalized] = symbol['id']\n            _exchange_info[HITBTC]['tick_size'][normalized] = symbol['tickSize']\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('HITBTC', why, {\"\": r})\n\n\n<DED><DED>def poloniex_id_symbol_mapping():\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://poloniex.com/public?command=returnTicker')\n        symbols = r.json()\n        ret = {}\n        for symbol in symbols:\n            <IND>ret[symbols[symbol]['id']] = symbol\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('POLONIEX', why, {\"\": r})\n\n\n<DED><DED>def poloniex_symbols() -> Dict[str, str]:\n    <IND>ret = {}\n    for _, value in poloniex_id_symbol_mapping().items():\n        <IND>std = value.replace(\"STR\", \"XLM\")\n        quote, base = std.split(\"_\")\n        ret[quote + SYMBOL_SEP + base] = value\n    <DED>return ret\n\n\n<DED>def bitstamp_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://www.bitstamp.net/api/v2/trading-pairs-info/')\n        ret = {}\n        for data in r.json():\n            <IND>normalized = data['name'].replace(\"/\", SYMBOL_SEP)\n            symbol = data['url_symbol']\n            ret[normalized] = symbol\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BITSTAMP', why, {\"\": r})\n\n\n<DED><DED>def kraken_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.kraken.com/0/public/AssetPairs')\n        data = r.json()\n        ret = {}\n        for symbol in data['result']:\n            <IND>if 'wsname' not in data['result'][symbol] or '.d' in symbol:\n                # https://blog.kraken.com/post/259/introducing-the-kraken-dark-pool/\n                # .d is for dark pool symbols\n                <IND>continue\n\n            <DED>base, quote = data['result'][symbol]['wsname'].split(\"/\")\n\n            normalized = f\"{base}{SYMBOL_SEP}{quote}\"\n            exch = data['result'][symbol]['wsname']\n            normalized = normalized.replace('XBT', 'BTC')\n            normalized = normalized.replace('XDG', 'DOG')\n            ret[normalized] = exch\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('KRAKEN', why, {\"\": r})\n\n\n<DED><DED>def kraken_rest_symbols() -> Dict[str, str]:\n    <IND>return {normalized: exchange.replace(\"/\", \"\") for normalized, exchange in kraken_symbols().items()}\n\n\n<DED>def exx_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.exx.com/data/v1/tickers')\n        exchange = [key.upper() for key in r.json().keys()]\n        symbols = [key.replace(\"_\", SYMBOL_SEP) for key in exchange]\n        return dict(zip(symbols, exchange))\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('EXX', why, {\"\": r})\n\n\n<DED><DED>def huobi_common_symbols(url: str):\n    <IND>r = None\n    try:\n        <IND>r = requests.get(url)\n        ret = {}\n        for e in r.json()['data']:\n            <IND>if e['state'] == 'offline':\n                <IND>continue\n            <DED>normalized = f\"{e['base-currency'].upper()}{SYMBOL_SEP}{e['quote-currency'].upper()}\"\n            symbol = f\"{e['base-currency']}{e['quote-currency']}\"\n            ret[normalized] = symbol\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('HUOBI', why, {url: r})\n\n\n<DED><DED>def huobi_symbols() -> Dict[str, str]:\n    <IND>return huobi_common_symbols('https://api.huobi.pro/v1/common/symbols')\n\n\n<DED>def huobi_us_symbols() -> Dict[str, str]:\n    <IND>return huobi_common_symbols('https://api.huobi.com/v1/common/symbols')\n\n\n<DED>def huobi_dm_symbols() -> Dict[str, str]:\n    <IND>\"\"\"\n    Mapping is, for instance: {\"BTC_CW\":\"BTC190816\"}\n    See comments in exchange/huobi_dm.py\n    \"\"\"\n    mapping = {\n        \"this_week\": \"CW\",\n        \"next_week\": \"NW\",\n        \"quarter\": \"CQ\",\n        \"next_quarter\": \"NQ\"\n    }\n    r = None\n    try:\n        <IND>r = requests.get('https://www.hbdm.com/api/v1/contract_contract_info')\n        symbols = {}\n        for e in r.json()['data']:\n            <IND>symbols[f\"{e['symbol']}_{mapping[e['contract_type']]}\"] = e['contract_code']\n            _exchange_info[HUOBI_DM]['tick_size'][e['contract_code']] = e['price_tick']\n            _exchange_info[HUOBI_DM]['short_code_mappings'][f\"{e['symbol']}_{mapping[e['contract_type']]}\"] = e['contract_code']\n        <DED>return symbols\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('HUOBI_DM', why, {\"\": r})\n\n\n<DED><DED>def huobi_swap_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.hbdm.com/swap-api/v1/swap_contract_info')\n        symbols = {}\n        for e in r.json()['data']:\n            <IND>symbols[e['contract_code']] = e['contract_code']\n            _exchange_info[HUOBI_SWAP]['tick_size'][e['contract_code']] = e['price_tick']\n        <DED>return symbols\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('HUOBI_SWAP', why, {\"\": r})\n\n\n<DED><DED>def okcoin_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://www.okcoin.com/api/spot/v3/instruments')\n        ret = {}\n        for e in r.json():\n            <IND>ret[e['instrument_id']] = e['instrument_id']\n            _exchange_info[OKCOIN]['tick_size'][e['instrument_id']] = e['tick_size']\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('OKCOIN', why, {\"\": r})\n\n\n<DED><DED>def okex_symbols(*args) -> Dict[str, str]:\n    <IND>urls = ['https://www.okex.com/api/spot/v3/instruments',\n            'https://www.okex.com/api/swap/v3/instruments',\n            'https://www.okex.com/api/futures/v3/instruments']\n    urls = urls + okex_compute_option_urls_from_underlyings()\n\n    symbols: Dict[str, str] = {}\n    for u in urls:\n        <IND>time.sleep(0.2)\n        symbols.update(okex_symbols_from_one_url(u))\n\n    <DED>for symbol in symbols:\n        <IND>instrument_type = 'futures'\n        dash_count = symbol.count(get_symbol_separator())\n        if dash_count == 1:  # BTC-USDT\n            <IND>instrument_type = 'spot'\n        <DED>if dash_count == 4:  # BTC-USD-201225-35000-P\n            <IND>instrument_type = 'option'\n        <DED>if symbol[-4:] == \"SWAP\":  # BTC-USDT-SWAP\n            <IND>instrument_type = 'swap'\n\n        <DED>_exchange_info[OKEX]['instrument_type'][symbol] = instrument_type\n\n    <DED>return symbols\n\n\n<DED>def okex_compute_option_urls_from_underlyings() -> List[str]:\n    <IND>url = 'https://www.okex.com/api/option/v3/underlying'\n    r = None\n    try:\n        <IND>r = requests.get(url)\n        return [f'https://www.okex.com/api/option/v3/instruments/{underlying}' for underlying in r.json()]\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('OKEX', why, {url: r})\n\n\n<DED><DED>def okex_symbols_from_one_url(url: str) -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get(url)\n        ret = {}\n        for e in r.json():\n            <IND>ret[e['instrument_id']] = e['instrument_id']\n            _exchange_info[OKEX]['tick_size'][e['instrument_id']] = e['tick_size']\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('OKEX', why, {url: r})\n\n\n<DED><DED>def bittrex_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.bittrex.com/api/v1.1/public/getmarkets')\n        r = r.json()['result']\n        return {f\"{e['MarketCurrency']}{SYMBOL_SEP}{e['BaseCurrency']}\": e['MarketName'] for e in r if e['IsActive']}\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BITTREX', why, {\"\": r})\n\n\n<DED><DED>def bitcoincom_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.exchange.bitcoin.com/api/2/public/symbol')\n        return {f\"{data['baseCurrency']}{SYMBOL_SEP}{data['quoteCurrency'].replace('USD', 'USDT')}\": data['id'] for data in r.json()}\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BITCOINCOM', why, {\"\": r})\n\n\n<DED><DED>def bitmax_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://bitmax.io/api/pro/v1/products')\n        ret = {}\n        for entry in r.json()['data']:\n            # Only \"Normal\" status symbols are tradeable\n            <IND>if entry['status'] == 'Normal':\n                <IND>normalized = f\"{entry['baseAsset']}{SYMBOL_SEP}{entry['quoteAsset']}\"\n                ret[normalized] = entry['symbol']\n                _exchange_info[BITMAX]['tick_size'][normalized] = entry['tickSize']\n        <DED><DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BITMAX', why, {\"\": r})\n\n\n<DED><DED>def upbit_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.upbit.com/v1/market/all')\n        return {f\"{data['market'].split('-')[1]}{SYMBOL_SEP}{data['market'].split('-')[0]}\": data['market'] for data in r.json()}\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('UPBIT', why, {\"\": r})\n\n\n<DED><DED>def blockchain_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get(\"https://api.blockchain.com/mercury-gateway/v1/instruments\")\n        return {data[\"symbol\"].replace(\"-\", SYMBOL_SEP): data[\"symbol\"] for data in r.json()}\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BLOCKCHAIN', why, {\"\": r})\n\n\n<DED><DED>def gateio_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get(\"https://api.gateio.ws/api/v4/spot/currency_pairs\")\n        return {data[\"id\"].replace(\"_\", SYMBOL_SEP): data['id'] for data in r.json()}\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('GATEIO', why, {\"\": r})\n\n\n<DED><DED>def bitmex_symbols() -> Dict[str, str]:\n    <IND>r = None\n    ret = {}\n    try:\n        <IND>r = requests.get(\"https://www.bitmex.com/api/v1/instrument/active\")\n        for entry in r.json():\n            <IND>components = []\n            components.append(entry['rootSymbol'])\n            components.append(entry['quoteCurrency'])\n\n            if entry['expiry']:\n                <IND>components.append(entry['symbol'][-3:])\n\n            <DED>normalized = SYMBOL_SEP.join(components)\n            normalized = normalized.replace(\"XBT\", \"BTC\")\n            ret[normalized] = entry['symbol']\n            _exchange_info[BITMEX]['tick_size'][normalized] = entry['tickSize']\n\n            if entry['expiry']:\n                <IND>_exchange_info[BITMEX]['expiry'][normalized] = entry['expiry']\n\n        <DED><DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BITMEX', why, {\"\": r})\n\n\n<DED><DED>def deribit_symbols() -> Dict[str, str]:\n    <IND>url = r = None\n    ret = {}\n    try:\n        # TODO: get currencies from https://www.deribit.com/api/v2/public/get_currencies\n        <IND>currencies = ['BTC', 'ETH']\n        for c in currencies:\n            <IND>url = f\"https://www.deribit.com/api/v2/public/get_instruments?currency={c}&expired=false\"\n            r = requests.get(url)\n            for entry in r.json()['result']:\n                <IND>split = entry['instrument_name'].split(\"-\")\n                normalized = split[0] + SYMBOL_SEP + entry['quote_currency'] + \"-\" + '-'.join(split[1:])\n                ret[normalized] = entry['instrument_name']\n                _exchange_info[DERIBIT]['tick_size'][normalized] = entry['tick_size']\n        <DED><DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('DERIBIT', why, {url: r})\n\n\n<DED><DED>def kraken_future_symbols() -> Dict[str, str]:\n    <IND>r = None\n    ret = {}\n    try:\n        <IND>r = requests.get('https://futures.kraken.com/derivatives/api/v3/instruments')\n        data = r.json()['instruments']\n        for entry in data:\n            <IND>if not entry['tradeable']:\n                <IND>continue\n            <DED>normalized = entry['symbol'].upper().replace(\"_\", \"-\")\n            symbol = normalized[3:6] + SYMBOL_SEP + normalized[6:9]\n            normalized = normalized.replace(normalized[3:9], symbol)\n            normalized = normalized.replace('XBT', 'BTC')\n\n            _exchange_info[KRAKEN_FUTURES]['tick_size'][normalized] = entry['tickSize']\n            _exchange_info[KRAKEN_FUTURES]['contract_size'][normalized] = entry['contractSize']\n            _exchange_info[KRAKEN_FUTURES]['underlying'][normalized] = entry['underlying']\n            _exchange_info[KRAKEN_FUTURES]['product_type'][normalized] = _kraken_futures_product_type[normalized[:2]]\n            ret[normalized] = entry['symbol']\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('KRAKEN_FUTURES', why, {\"\": r})\n\n\n<DED><DED>def probit_symbols() -> Dict[str, str]:\n    # doc: https://docs-en.probit.com/reference-link/market\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.probit.com/api/exchange/v1/market')\n        return {entry['id']: entry['id'] for entry in r.json()['data']}\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('PROBIT', why, {\"\": r})\n\n\n<DED><DED>def coingecko_normalize_symbol(symbol: str) -> str:\n    # keep digits, letters and dots, replace others by space\n    <IND>symbol = ''.join(c if c.isalnum() or c in ('.', '+') else ' ' for c in symbol)\n    return coingecko_normalize(symbol.upper())\n\n\n<DED>def coingecko_normalize_name(name: str) -> str:\n    # keep digits and letters, replace others by space (except when only composed by upper case letters, digits and dots)\n    <IND>if not all(c.isupper() or c.isdigit() or c == '.' for c in name):\n        <IND>name = ''.join(c if c.isalnum() else ' ' for c in name)\n    <DED>return coingecko_normalize(name)\n\n\n<DED>def coingecko_normalize(sym: str) -> str:\n    <IND>sym = sym.strip()\n    # do not concatenate numbers => separate them with a dot\n    sym = list(sym)\n    if len(sym) > 4:\n        <IND>for i in range(2, len(sym) - 1):\n            <IND>if sym[i] == ' ' and sym[i - 1].isdigit() and sym[i + 1].isdigit():\n                <IND>sym[i] = '.'\n    <DED><DED><DED>sym = ''.join(sym)\n    # concatenate space-separated words => use CamelCase to distinguish the words\n    if ' ' in sym:\n        <IND>if sum(c.islower() for c in sym):  # if there is at least one lower case letter\n            <IND>sym = ' '.join(word[0].upper() + word[1:] for word in sym.split())  # Just capitalize initial letter of each word\n        <DED>else:  # CoinGecko may provide full upper-case as for \"THE STONE COIN\"\n            <IND>sym = string.capwords(sym)  # capwords converts \"THE STONE COIN\" to \"The Stone Coin\"\n        <DED>sym = sym.replace(' ', '')  # concatenate words\n    <DED>return sym\n\n\n<DED>def is_name_short(coin: dict) -> bool:\n    <IND>\"\"\"return True if the coin name is enough short compared to the coin symbol.\"\"\"\n    return len(coin['name']) <= max(5, len(coin['symbol']) + 1)\n\n\n<DED>def has_many_caps(name: str) -> bool:\n    <IND>\"\"\"return True if the symbol contains enough upper case letters, False if empty.\"\"\"\n    return str and sum(c.islower() for c in name) < (len(name) / 2)\n\n\n<DED>def coingecko_normalize_all(coin: dict):\n    <IND>SYMBOL_TO_NORMALIZED = {'miota': 'IOTA'}\n    normalized = SYMBOL_TO_NORMALIZED.get(coin['symbol'])\n    if normalized:\n        <IND>coin['ns'] = coin['nn'] = normalized\n        return normalized\n\n    # ns = normalized symbol, nn = normalized name\n    <DED>coin['ns'] = coingecko_normalize_symbol(coin['symbol'])\n\n    ID_SUFFIX = '-bitcoin-token'\n    if coin['id'][-len(ID_SUFFIX):] == ID_SUFFIX:\n        <IND>coin['nn'] = 'BTC' + coin['ns']\n        return coin['nn']\n\n    <DED>name = coin['name']\n\n    prefixes = ('The ', 'the ')\n    for p in prefixes:\n        <IND>if name[:len(p)] == p:\n            <IND>coin['reduced-name'] = True\n            name = name[len(p):]\n            break\n\n    <DED><DED>suffixes = ('coin', 'coins', 'money', 'finance', 'protocol', 'reward', 'rewards', 'token')\n    for s in suffixes:\n        <IND>if len(name) > len(s) and name[-len(s):].lower() == s:\n            # but keep suffix when lower-case concatenated\n            <IND>if name[-len(s)].islower() and name[-len(s) - 1] != ' ':\n                <IND>continue\n            # also keep suffix to avoid confusing nam: \"Bitcoin Token\" -> \"Bitcoin\"\n            <DED>if name[:-len(s)].strip().lower() == 'bitcoin':\n                <IND>continue\n            <DED>coin['reduced-name'] = True\n            name = name[:-len(s)]\n            break\n\n    <DED><DED>coin['nn'] = coingecko_normalize_name(name)\n\n    if len(coin['nn']) < len(coin['ns']):\n        <IND>if 'reduced-name' in coin:\n            <IND>coin['reduced-name'] = False\n            name = coin['name']\n            coin['nn'] = coingecko_normalize_name(name)\n        <DED>elif not has_many_caps(name):\n            <IND>return coin['ns']\n\n    <DED><DED>if not coin['ns']:  # coin['symbol'] may be an emoji that is striped when normalized\n        <IND>return coin['nn']\n\n    <DED>if coin.get('reduced-name') and coin['ns'].upper() != coin['nn'].upper():\n        <IND>return coin['ns']\n\n    <DED>i = coin['nn'].find('.')  # if there is a dot in normalized name => prefer the normalized symbol\n    if i >= 0:\n        <IND>if i > 1 and coin['nn'][i - 1].isdigit() and coin['nn'][i + 1].isdigit():\n            <IND>pass  # except when the dot separates digits\n        <DED>else:\n            <IND>return coin['ns']\n\n    <DED><DED>if is_name_short(coin) and has_many_caps(name):\n        <IND>return coin['nn']\n\n    <DED>if 1.5 * len(coin['ns']) > len(coin['nn']) and any(c.islower() for c in coin['ns']):\n        <IND>return coin['nn']\n\n    <DED>return coin['ns']\n\n\n<DED>def coingecko_symbols() -> Dict[str, str]:\n    <IND>r = None\n    intermediate = defaultdict(list)\n    try:\n        <IND>r = requests.get('https://api.coingecko.com/api/v3/coins/list')\n        all_coins = r.json()\n        # First pass: generate & compare normalized symbol/name, and then select the most pertinent\n        for coin in all_coins:\n            <IND>normalized = coingecko_normalize_all(coin)\n            intermediate[normalized].append(coin)\n            # Above line keeps together the coins having the same normalized symbol.\n            # To reduce collision, the coin['name'] is sometimes used in lieu of the coin['symbol'].\n            # The coin['name'] is not capitalized because lower case letters may be meaningful: cETH, yUSD, DATx, zLOT\n    <DED><DED>except Exception as why:\n        <IND>raise_failure_explanation('COINGECKO', why, {\"\": r})\n\n    <DED>final = coingecko_second_pass(intermediate)\n    return coingecko_third_pass(final)\n\n\n<DED>def coingecko_second_pass(intermediate: Dict[str, List[dict]]) -> Dict[str, List[dict]]:\n    # Second pass: fixes most of the symbol collisions\n    <IND>final = defaultdict(list)\n    for normalized, coins in intermediate.items():\n        <IND>if len(coins) == 1:\n            <IND>final[normalized].append(coins[0])\n            continue\n        <DED>set_normalized = False\n        for i in range(len(coins)):\n            <IND>if normalized == coins[i]['nn']:\n                <IND>coin = coins.pop(i)\n                final[normalized].append(coin)\n                set_normalized = True\n                break\n        <DED><DED>rest: List[dict] = []\n        for coin in coins:\n            <IND>if '%' in coin['name']:\n                <IND>if len(coins) == 1:\n                    <IND>n = coin['ns']\n                <DED>else:\n                    <IND>n = coingecko_normalize_name(coin['id'])\n                <DED>final[n].append(coin)\n            <DED>else:\n                <IND>rest.append(coin)\n        <DED><DED>if not rest:\n            <IND>continue\n        <DED>if not set_normalized:\n            <IND>rest.sort(key=lambda coin: len(coin['nn']), reverse=True)  # sort by the length of the normalized name\n            coin = rest.pop(0)\n            final[normalized].append(coin)\n        <DED>for coin in rest:\n            <IND>if coin['nn'] not in intermediate:\n                <IND>n = coin['nn']\n            <DED>elif coin.get('reduced-name'):\n                <IND>n = coingecko_normalize_name(coin['name'])\n            <DED>else:\n                <IND>n = coingecko_normalize_name(coin['id'])\n            <DED>final[n].append(coin)\n    <DED><DED>return final\n\n\n<DED>def coingecko_third_pass(final: Dict[str, List[dict]]) -> Dict[str, str]:\n    # Third pass: fixes some remaining collisions and fills the result\n    <IND>symbols = {}\n    for normalized, coins in final.items():\n        <IND>if len(coins) == 1:\n            <IND>symbols[normalized] = coins[0]['id']\n            continue\n        <DED>set_normalized = False\n        for i in range(len(coins)):\n            <IND>if normalized == coins[i]['nn']:\n                <IND>coin = coins.pop(i)\n                symbols[normalized] = coin['id']\n                set_normalized = True\n                break\n        <DED><DED>rest: List[dict] = []\n        for coin in coins:\n            <IND>if '%' in coin['name']:\n                <IND>if len(coins) == 1:\n                    <IND>n = coin['ns']\n                <DED>else:\n                    <IND>n = coingecko_normalize_name(coin['id'])\n                <DED>symbols[n] = coin['id']\n            <DED>else:\n                <IND>rest.append(coin)\n        <DED><DED>if not rest:\n            <IND>continue\n        <DED>if not set_normalized:\n            <IND>rest.sort(key=lambda coin: len(coin['nn']), reverse=True)  # sort by the length of the normalized name\n            coin = rest.pop(0)\n            symbols[normalized] = coin['id']\n        <DED>for coin in rest:\n            <IND>if coin['nn'] not in final:\n                <IND>n = coin['nn']\n            <DED>elif coin.get('reduced-name'):\n                <IND>n = coingecko_normalize_name(coin['name'])\n            <DED>else:\n                <IND>n = coingecko_normalize_name(coin['id'])\n            <DED>symbols[n] = coin['id']\n    <DED><DED>return symbols\n\n\n<DED>def whale_alert_coins(key_id: str) -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get(f'https://api.whale-alert.io/v1/status?api_key={key_id}')\n        # Same symbols, but on different blockchains (for instance USDT), are naturally overwritten.\n        return {s.upper(): s for b in r.json()['blockchains'] for s in b['symbols'] if s}\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('WHALES_ALERT', why, {\"\": r})\n\n\n<DED><DED>_exchange_function_map = {\n    BITFINEX: bitfinex_symbols,\n    BITFLYER: bitflyer_symbols,\n    COINBASE: coinbase_symbols,\n    GEMINI: gemini_symbols,\n    HITBTC: hitbtc_symbols,\n    POLONIEX: poloniex_symbols,\n    PROBIT: probit_symbols,\n    BITSTAMP: bitstamp_symbols,\n    KRAKEN: kraken_symbols,\n    KRAKEN + 'REST': kraken_rest_symbols,\n    BINANCE: binance_symbols,\n    BINANCE_US: binance_us_symbols,\n    BINANCE_FUTURES: binance_futures_symbols,\n    BINANCE_DELIVERY: binance_delivery_symbols,\n    BLOCKCHAIN: blockchain_symbols,\n    EXX: exx_symbols,\n    HUOBI: huobi_symbols,\n    HUOBI_DM: huobi_dm_symbols,\n    HUOBI_SWAP: huobi_swap_symbols,\n    OKCOIN: okcoin_symbols,\n    OKEX: okex_symbols,\n    BYBIT: bybit_symbols,\n    FTX: ftx_symbols,\n    FTX_US: ftx_us_symbols,\n    BITTREX: bittrex_symbols,\n    BITCOINCOM: bitcoincom_symbols,\n    BITMAX: bitmax_symbols,\n    UPBIT: upbit_symbols,\n    GATEIO: gateio_symbols,\n    BITMEX: bitmex_symbols,\n    DERIBIT: deribit_symbols,\n    KRAKEN_FUTURES: kraken_future_symbols,\n    COINGECKO: coingecko_symbols,\n    WHALE_ALERT: whale_alert_coins\n}\n",
        "target_code_with_indent": "\nfrom typing import Dict, Tuple\n\n\nclass _Symbols:\n    <IND>def __init__(self):\n        <IND>self.data = {}\n\n    <DED>def set(self, exchange: str, normalized: dict, exchange_info: dict):\n        <IND>self.data[exchange] = {}\n        self.data[exchange]['normalized'] = normalized\n        self.data[exchange]['info'] = exchange_info\n\n    <DED>def get(self, exchange: str) -> Tuple[Dict, Dict]:\n        <IND>return self.data[exchange]['normalized'], self.data[exchange]['info']\n\n    <DED>def populated(self, exchange: str) -> bool:\n        <IND>return exchange in self.data\n\n\n<DED><DED>Symbols = _Symbols()\n"
      }
    ]
  },
  {
    "project": "bmoscon/cryptofeed",
    "commit": "3525dc8ce4d7836a9abaaa5662e58e5e27969a77",
    "filename": "cryptofeed/symbols.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/bmoscon-cryptofeed/cryptofeed/symbols.py",
    "file_hunks_size": 1,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "cryptofeed/symbols.py:491:8 Incompatible return type [7]: Expected `Dict[str, str]` but got implicit return value of `None`.",
    "message": " Expected `Dict[str, str]` but got implicit return value of `None`.",
    "rule_id": "Incompatible return type [7]",
    "warning_line_no": 491,
    "warning_line": "        raise_failure_explanation('UPBIT', why, {\"\": r})",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "associated with this software.\n\n\nSymbol generation code for exchanges\n'''\n\nimport logging\nimport string\nimport time\nfrom collections import defaultdict\nfrom typing import Dict, List, Optional, Tuple\n\nimport requests\nfrom requests import Response\n\nfrom cryptofeed.defines import *\n\n\nLOG = logging.getLogger('feedhandler')\n\nSYMBOL_SEP = '-'\n\n_symbols_retrieval_cache: Dict[str, Dict[str, str]] = {}\n_exchange_info = defaultdict(lambda: defaultdict(dict))\n\n\n_kraken_futures_product_type = {\n    'FI': 'Inverse Futures',\n    'FV': 'Vanilla Futures',\n    'PI': 'Perpetual Inverse Futures',\n    'PV': 'Perpetual Vanilla Futures',\n    'IN': 'Real Time Index',\n    'RR': 'Reference Rate',\n}\n\n\ndef raise_failure_explanation(feed_id: str, exception: BaseException, responses: Dict[str, Optional[Response]]):\n    LOG.critical('%s: encountered %r while processing response from exchange API', feed_id, exception)\n    if len(responses) > 1:\n        LOG.critical('%s: content of one of the %s responses was unexpected', feed_id, len(responses))\n    for url, r in responses.items():\n        if url:\n            LOG.critical('%s: requested URL: %s', feed_id, url)\n        if r:\n            LOG.critical('%s: unexpected response: %s', feed_id, r.text)\n    raise ValueError(f'Cryptofeed stopped because of an unexpected response from {feed_id}') from exception\n\n\ndef set_symbol_separator(separator: str):\n    global SYMBOL_SEP\n    SYMBOL_SEP = separator\n\n\ndef get_symbol_separator() -> str:\n    global SYMBOL_SEP\n    return SYMBOL_SEP\n\n\ndef gen_symbols(exchange: str, key_id=None) -> Dict[str, str]:\n    if exchange not in _symbols_retrieval_cache:\n        LOG.info(\"%s: Getting list of symbols\", exchange)\n        symbols = _exchange_function_map[exchange](key_id) if key_id else _exchange_function_map[exchange]()\n        LOG.info(\"%s: %s symbols\", exchange, len(symbols))\n\n        # log all retrieved symbols using debug level\n        for normalized, exch_sym in sorted(symbols.items()):\n            LOG.debug('%s: id-from-exch -> normalized: %-35s-> %s', exchange, exch_sym, normalized)\n\n        _symbols_retrieval_cache[exchange] = symbols\n    return _symbols_retrieval_cache[exchange]\n\n\ndef _binance_symbols(endpoint: str, exchange: str):\n    r = None\n    try:\n        ret = {}\n        r = requests.get(endpoint)\n        for symbol in r.json()['symbols']:\n            if symbol.get('status', 'TRADING') != \"TRADING\":\n                continue\n            if symbol.get('contractStatus', 'TRADING') != \"TRADING\":\n                continue\n            split = len(symbol['baseAsset'])\n            normalized = symbol['symbol'][:split] + SYMBOL_SEP + symbol['symbol'][split:]\n            ret[normalized] = symbol['symbol']\n            _exchange_info[exchange]['tick_size'][normalized] = symbol['filters'][0]['tickSize']\n            if \"contractType\" in symbol:\n                _exchange_info[exchange]['contract_type'][normalized] = symbol['contractType']\n        return ret\n    except Exception as why:\n        raise_failure_explanation(exchange, why, {endpoint: r})\n\n\ndef binance_symbols() -> Dict[str, str]:\n    return _binance_symbols('https://api.binance.com/api/v3/exchangeInfo', BINANCE)\n\n\ndef binance_us_symbols() -> Dict[str, str]:\n    return _binance_symbols('https://api.binance.us/api/v3/exchangeInfo', BINANCE_US)\n\n\ndef binance_futures_symbols() -> Dict[str, str]:\n    base = _binance_symbols('https://fapi.binance.com/fapi/v1/exchangeInfo', BINANCE_FUTURES)\n    add = {}\n    for symbol, orig in base.items():\n        if \"_\" in orig:\n            continue\n        add[f\"{symbol}-PINDEX\"] = f\"p{orig}\"\n    base.update(add)\n    return base\n\n\ndef binance_delivery_symbols() -> Dict[str, str]:\n    return _binance_symbols('https://dapi.binance.com/dapi/v1/exchangeInfo', BINANCE_DELIVERY)\n\n\ndef bitfinex_symbols() -> Dict[str, str]:\n    # doc: https://docs.bitfinex.com/docs/ws-general#supported-pairs\n    r1 = r2 = None\n    try:\n        r1 = requests.get('https://api.bitfinex.com/v2/tickers?symbols=ALL')\n        r2 = requests.get('https://api-pub.bitfinex.com/v2/conf/pub:map:currency:sym')\n        tickers: List[List[str]] = r1.json()\n        norm: List[Tuple[str, str]] = r2.json()[0]\n        norm: Dict[str, str] = dict(norm)\n        for k, v in dict(norm).items():\n            if k[-2:] == 'F0' or '-' in v:  # Do not convert BTCF0 -> BTC or PBTCETH -> PBTC-ETH\n                del norm[k]\n        norm['BCHN'] = 'BCH'  # Bitfinex uses BCHN, other exchanges use BCH\n\n        ret = {}\n        for symbol in [t[0] for t in tickers]:\n            if symbol[0] == 'f':\n                normalized = norm.get(symbol[1:], symbol[1:])\n            else:\n                if len(symbol) == 7:\n                    base, quote = symbol[1:4], symbol[4:]\n                else:\n                    base, quote = symbol[1:].split(':')\n                    assert ':' in symbol\n                normalized = norm.get(base, base) + SYMBOL_SEP + norm.get(quote, quote)\n            ret[normalized.upper()] = symbol\n        return ret\n    except ValueError as why:\n        raise_failure_explanation('BITFINEX', why, {\"tickers?symbols=ALL\": r1, \"pub:map:currency:sym\": r2})\n\n\ndef bitflyer_symbols() -> Dict[str, str]:\n    endpoint = r = None\n    try:\n        ret = {}\n        endpoints = ['https://api.bitflyer.com/v1/getmarkets/eu', 'https://api.bitflyer.com/v1/getmarkets/usa', 'https://api.bitflyer.com/v1/getmarkets']\n        for endpoint in endpoints:\n            r = requests.get(endpoint)\n            for entry in r.json():\n                normalized = entry['product_code'].replace(\"_\", SYMBOL_SEP)\n                ret[normalized] = entry['product_code']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('BITFLYER', why, {endpoint: r})\n\n\ndef bybit_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.bybit.com/v2/public/symbols')\n        ret = {}\n        for symbol in r.json()['result']:\n            quote = symbol['quote_currency']\n            if not symbol['name'].endswith(quote):\n                base, contract = symbol['name'].split(quote)\n                normalized = f\"{base}{SYMBOL_SEP}{quote}-{contract}\"\n            else:\n                normalized = f\"{symbol['base_currency']}{SYMBOL_SEP}{quote}\"\n            ret[normalized] = symbol['name']\n            _exchange_info[BYBIT]['tick_size'][normalized] = symbol['price_filter']['tick_size']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('BYBIT', why, {\"\": r})\n\n\ndef _ftx_helper(endpoint: str, exchange: str):\n    r = None\n    try:\n        r = requests.get(endpoint)\n        ret = {}\n        for data in r.json()['result']:\n            normalized = data['name'].replace(\"/\", SYMBOL_SEP)\n            symbol = data['name']\n            ret[normalized] = symbol\n            _exchange_info[exchange]['tick_size'][normalized] = data['priceIncrement']\n        return ret\n    except Exception as why:\n        raise_failure_explanation(exchange, why, {endpoint: r})\n\n\ndef ftx_symbols() -> Dict[str, str]:\n    return _ftx_helper('https://ftx.com/api/markets', FTX)\n\n\ndef ftx_us_symbols() -> Dict[str, str]:\n    return _ftx_helper('https://ftx.us/api/markets', FTX_US)\n\n\ndef coinbase_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.pro.coinbase.com/products')\n        ret = {}\n        for data in r.json():\n            normalized = data['id'].replace(\"-\", SYMBOL_SEP)\n            ret[normalized] = data['id']\n            _exchange_info[COINBASE]['tick_size'][normalized] = data['quote_increment']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('COINBASE', why, {\"\": r})\n\n\ndef gemini_symbols(*args) -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.gemini.com/v1/symbols')\n        ret = {}\n        for symbol in r.json():\n            std = f\"{symbol[:-3]}{SYMBOL_SEP}{symbol[-3:]}\"\n            std = std.upper()\n            ret[std] = symbol.upper()\n        return ret\n    except Exception as why:\n        raise_failure_explanation('GEMINI', why, {\"\": r})\n\n\ndef hitbtc_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        ret = {}\n        r = requests.get('https://api.hitbtc.com/api/2/public/symbol')\n        for symbol in r.json():\n            split = len(symbol['baseCurrency'])\n            normalized = symbol['id'][:split] + SYMBOL_SEP + symbol['id'][split:]\n            ret[normalized] = symbol['id']\n            _exchange_info[HITBTC]['tick_size'][normalized] = symbol['tickSize']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('HITBTC', why, {\"\": r})\n\n\ndef poloniex_id_symbol_mapping():\n    r = None\n    try:\n        r = requests.get('https://poloniex.com/public?command=returnTicker')\n        symbols = r.json()\n        ret = {}\n        for symbol in symbols:\n            ret[symbols[symbol]['id']] = symbol\n        return ret\n    except Exception as why:\n        raise_failure_explanation('POLONIEX', why, {\"\": r})\n\n\ndef poloniex_symbols() -> Dict[str, str]:\n    ret = {}\n    for _, value in poloniex_id_symbol_mapping().items():\n        std = value.replace(\"STR\", \"XLM\")\n        quote, base = std.split(\"_\")\n        ret[quote + SYMBOL_SEP + base] = value\n    return ret\n\n\ndef bitstamp_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://www.bitstamp.net/api/v2/trading-pairs-info/')\n        ret = {}\n        for data in r.json():\n            normalized = data['name'].replace(\"/\", SYMBOL_SEP)\n            symbol = data['url_symbol']\n            ret[normalized] = symbol\n        return ret\n    except Exception as why:\n        raise_failure_explanation('BITSTAMP', why, {\"\": r})\n\n\ndef kraken_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.kraken.com/0/public/AssetPairs')\n        data = r.json()\n        ret = {}\n        for symbol in data['result']:\n            if 'wsname' not in data['result'][symbol] or '.d' in symbol:\n                # https://blog.kraken.com/post/259/introducing-the-kraken-dark-pool/\n                # .d is for dark pool symbols\n                continue\n\n            base, quote = data['result'][symbol]['wsname'].split(\"/\")\n\n            normalized = f\"{base}{SYMBOL_SEP}{quote}\"\n            exch = data['result'][symbol]['wsname']\n            normalized = normalized.replace('XBT', 'BTC')\n            normalized = normalized.replace('XDG', 'DOG')\n            ret[normalized] = exch\n        return ret\n    except Exception as why:\n        raise_failure_explanation('KRAKEN', why, {\"\": r})\n\n\ndef kraken_rest_symbols() -> Dict[str, str]:\n    return {normalized: exchange.replace(\"/\", \"\") for normalized, exchange in kraken_symbols().items()}\n\n\ndef exx_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.exx.com/data/v1/tickers')\n        exchange = [key.upper() for key in r.json().keys()]\n        symbols = [key.replace(\"_\", SYMBOL_SEP) for key in exchange]\n        return dict(zip(symbols, exchange))\n    except Exception as why:\n        raise_failure_explanation('EXX', why, {\"\": r})\n\n\ndef huobi_common_symbols(url: str):\n    r = None\n    try:\n        r = requests.get(url)\n        ret = {}\n        for e in r.json()['data']:\n            if e['state'] == 'offline':\n                continue\n            normalized = f\"{e['base-currency'].upper()}{SYMBOL_SEP}{e['quote-currency'].upper()}\"\n            symbol = f\"{e['base-currency']}{e['quote-currency']}\"\n            ret[normalized] = symbol\n        return ret\n    except Exception as why:\n        raise_failure_explanation('HUOBI', why, {url: r})\n\n\ndef huobi_symbols() -> Dict[str, str]:\n    return huobi_common_symbols('https://api.huobi.pro/v1/common/symbols')\n\n\ndef huobi_us_symbols() -> Dict[str, str]:\n    return huobi_common_symbols('https://api.huobi.com/v1/common/symbols')\n\n\ndef huobi_dm_symbols() -> Dict[str, str]:\n    \"\"\"\n    Mapping is, for instance: {\"BTC_CW\":\"BTC190816\"}\n    See comments in exchange/huobi_dm.py\n    \"\"\"\n    mapping = {\n        \"this_week\": \"CW\",\n        \"next_week\": \"NW\",\n        \"quarter\": \"CQ\",\n        \"next_quarter\": \"NQ\"\n    }\n    r = None\n    try:\n        r = requests.get('https://www.hbdm.com/api/v1/contract_contract_info')\n        symbols = {}\n        for e in r.json()['data']:\n            symbols[f\"{e['symbol']}_{mapping[e['contract_type']]}\"] = e['contract_code']\n            _exchange_info[HUOBI_DM]['tick_size'][e['contract_code']] = e['price_tick']\n            _exchange_info[HUOBI_DM]['short_code_mappings'][f\"{e['symbol']}_{mapping[e['contract_type']]}\"] = e['contract_code']\n        return symbols\n    except Exception as why:\n        raise_failure_explanation('HUOBI_DM', why, {\"\": r})\n\n\ndef huobi_swap_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.hbdm.com/swap-api/v1/swap_contract_info')\n        symbols = {}\n        for e in r.json()['data']:\n            symbols[e['contract_code']] = e['contract_code']\n            _exchange_info[HUOBI_SWAP]['tick_size'][e['contract_code']] = e['price_tick']\n        return symbols\n    except Exception as why:\n        raise_failure_explanation('HUOBI_SWAP', why, {\"\": r})\n\n\ndef okcoin_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://www.okcoin.com/api/spot/v3/instruments')\n        ret = {}\n        for e in r.json():\n            ret[e['instrument_id']] = e['instrument_id']\n            _exchange_info[OKCOIN]['tick_size'][e['instrument_id']] = e['tick_size']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('OKCOIN', why, {\"\": r})\n\n\ndef okex_symbols(*args) -> Dict[str, str]:\n    urls = ['https://www.okex.com/api/spot/v3/instruments',\n            'https://www.okex.com/api/swap/v3/instruments',\n            'https://www.okex.com/api/futures/v3/instruments']\n    urls = urls + okex_compute_option_urls_from_underlyings()\n\n    symbols: Dict[str, str] = {}\n    for u in urls:\n        time.sleep(0.2)\n        symbols.update(okex_symbols_from_one_url(u))\n\n    for symbol in symbols:\n        instrument_type = 'futures'\n        dash_count = symbol.count(get_symbol_separator())\n        if dash_count == 1:  # BTC-USDT\n            instrument_type = 'spot'\n        if dash_count == 4:  # BTC-USD-201225-35000-P\n            instrument_type = 'option'\n        if symbol[-4:] == \"SWAP\":  # BTC-USDT-SWAP\n            instrument_type = 'swap'\n\n        _exchange_info[OKEX]['instrument_type'][symbol] = instrument_type\n\n    return symbols\n\n\ndef okex_compute_option_urls_from_underlyings() -> List[str]:\n    url = 'https://www.okex.com/api/option/v3/underlying'\n    r = None\n    try:\n        r = requests.get(url)\n        return [f'https://www.okex.com/api/option/v3/instruments/{underlying}' for underlying in r.json()]\n    except Exception as why:\n        raise_failure_explanation('OKEX', why, {url: r})\n\n\ndef okex_symbols_from_one_url(url: str) -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get(url)\n        ret = {}\n        for e in r.json():\n            ret[e['instrument_id']] = e['instrument_id']\n            _exchange_info[OKEX]['tick_size'][e['instrument_id']] = e['tick_size']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('OKEX', why, {url: r})\n\n\ndef bittrex_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.bittrex.com/api/v1.1/public/getmarkets')\n        r = r.json()['result']\n        return {f\"{e['MarketCurrency']}{SYMBOL_SEP}{e['BaseCurrency']}\": e['MarketName'] for e in r if e['IsActive']}\n    except Exception as why:\n        raise_failure_explanation('BITTREX', why, {\"\": r})\n\n\ndef bitcoincom_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.exchange.bitcoin.com/api/2/public/symbol')\n        return {f\"{data['baseCurrency']}{SYMBOL_SEP}{data['quoteCurrency'].replace('USD', 'USDT')}\": data['id'] for data in r.json()}\n    except Exception as why:\n        raise_failure_explanation('BITCOINCOM', why, {\"\": r})\n\n\ndef bitmax_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://bitmax.io/api/pro/v1/products')\n        ret = {}\n        for entry in r.json()['data']:\n            # Only \"Normal\" status symbols are tradeable\n            if entry['status'] == 'Normal':\n                normalized = f\"{entry['baseAsset']}{SYMBOL_SEP}{entry['quoteAsset']}\"\n                ret[normalized] = entry['symbol']\n                _exchange_info[BITMAX]['tick_size'][normalized] = entry['tickSize']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('BITMAX', why, {\"\": r})\n\n\ndef upbit_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.upbit.com/v1/market/all')\n        return {f\"{data['market'].split('-')[1]}{SYMBOL_SEP}{data['market'].split('-')[0]}\": data['market'] for data in r.json()}\n    except Exception as why:\n        raise_failure_explanation('UPBIT', why, {\"\": r})\n\n\ndef blockchain_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get(\"https://api.blockchain.com/mercury-gateway/v1/instruments\")\n        return {data[\"symbol\"].replace(\"-\", SYMBOL_SEP): data[\"symbol\"] for data in r.json()}\n    except Exception as why:\n        raise_failure_explanation('BLOCKCHAIN', why, {\"\": r})\n\n\ndef gateio_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get(\"https://api.gateio.ws/api/v4/spot/currency_pairs\")\n        return {data[\"id\"].replace(\"_\", SYMBOL_SEP): data['id'] for data in r.json()}\n    except Exception as why:\n        raise_failure_explanation('GATEIO', why, {\"\": r})\n\n\ndef bitmex_symbols() -> Dict[str, str]:\n    r = None\n    ret = {}\n    try:\n        r = requests.get(\"https://www.bitmex.com/api/v1/instrument/active\")\n        for entry in r.json():\n            components = []\n            components.append(entry['rootSymbol'])\n            components.append(entry['quoteCurrency'])\n\n            if entry['expiry']:\n                components.append(entry['symbol'][-3:])\n\n            normalized = SYMBOL_SEP.join(components)\n            normalized = normalized.replace(\"XBT\", \"BTC\")\n            ret[normalized] = entry['symbol']\n            _exchange_info[BITMEX]['tick_size'][normalized] = entry['tickSize']\n\n            if entry['expiry']:\n                _exchange_info[BITMEX]['expiry'][normalized] = entry['expiry']\n\n        return ret\n    except Exception as why:\n        raise_failure_explanation('BITMEX', why, {\"\": r})\n\n\ndef deribit_symbols() -> Dict[str, str]:\n    url = r = None\n    ret = {}\n    try:\n        # TODO: get currencies from https://www.deribit.com/api/v2/public/get_currencies\n        currencies = ['BTC', 'ETH']\n        for c in currencies:\n            url = f\"https://www.deribit.com/api/v2/public/get_instruments?currency={c}&expired=false\"\n            r = requests.get(url)\n            for entry in r.json()['result']:\n                split = entry['instrument_name'].split(\"-\")\n                normalized = split[0] + SYMBOL_SEP + entry['quote_currency'] + \"-\" + '-'.join(split[1:])\n                ret[normalized] = entry['instrument_name']\n                _exchange_info[DERIBIT]['tick_size'][normalized] = entry['tick_size']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('DERIBIT', why, {url: r})\n\n\ndef kraken_future_symbols() -> Dict[str, str]:\n    r = None\n    ret = {}\n    try:\n        r = requests.get('https://futures.kraken.com/derivatives/api/v3/instruments')\n        data = r.json()['instruments']\n        for entry in data:\n            if not entry['tradeable']:\n                continue\n            normalized = entry['symbol'].upper().replace(\"_\", \"-\")\n            symbol = normalized[3:6] + SYMBOL_SEP + normalized[6:9]\n            normalized = normalized.replace(normalized[3:9], symbol)\n            normalized = normalized.replace('XBT', 'BTC')\n\n            _exchange_info[KRAKEN_FUTURES]['tick_size'][normalized] = entry['tickSize']\n            _exchange_info[KRAKEN_FUTURES]['contract_size'][normalized] = entry['contractSize']\n            _exchange_info[KRAKEN_FUTURES]['underlying'][normalized] = entry['underlying']\n            _exchange_info[KRAKEN_FUTURES]['product_type'][normalized] = _kraken_futures_product_type[normalized[:2]]\n            ret[normalized] = entry['symbol']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('KRAKEN_FUTURES', why, {\"\": r})\n\n\ndef probit_symbols() -> Dict[str, str]:\n    # doc: https://docs-en.probit.com/reference-link/market\n    r = None\n    try:\n        r = requests.get('https://api.probit.com/api/exchange/v1/market')\n        return {entry['id']: entry['id'] for entry in r.json()['data']}\n    except Exception as why:\n        raise_failure_explanation('PROBIT', why, {\"\": r})\n\n\ndef coingecko_normalize_symbol(symbol: str) -> str:\n    # keep digits, letters and dots, replace others by space\n    symbol = ''.join(c if c.isalnum() or c in ('.', '+') else ' ' for c in symbol)\n    return coingecko_normalize(symbol.upper())\n\n\ndef coingecko_normalize_name(name: str) -> str:\n    # keep digits and letters, replace others by space (except when only composed by upper case letters, digits and dots)\n    if not all(c.isupper() or c.isdigit() or c == '.' for c in name):\n        name = ''.join(c if c.isalnum() else ' ' for c in name)\n    return coingecko_normalize(name)\n\n\ndef coingecko_normalize(sym: str) -> str:\n    sym = sym.strip()\n    # do not concatenate numbers => separate them with a dot\n    sym = list(sym)\n    if len(sym) > 4:\n        for i in range(2, len(sym) - 1):\n            if sym[i] == ' ' and sym[i - 1].isdigit() and sym[i + 1].isdigit():\n                sym[i] = '.'\n    sym = ''.join(sym)\n    # concatenate space-separated words => use CamelCase to distinguish the words\n    if ' ' in sym:\n        if sum(c.islower() for c in sym):  # if there is at least one lower case letter\n            sym = ' '.join(word[0].upper() + word[1:] for word in sym.split())  # Just capitalize initial letter of each word\n        else:  # CoinGecko may provide full upper-case as for \"THE STONE COIN\"\n            sym = string.capwords(sym)  # capwords converts \"THE STONE COIN\" to \"The Stone Coin\"\n        sym = sym.replace(' ', '')  # concatenate words\n    return sym\n\n\ndef is_name_short(coin: dict) -> bool:\n    \"\"\"return True if the coin name is enough short compared to the coin symbol.\"\"\"\n    return len(coin['name']) <= max(5, len(coin['symbol']) + 1)\n\n\ndef has_many_caps(name: str) -> bool:\n    \"\"\"return True if the symbol contains enough upper case letters, False if empty.\"\"\"\n    return str and sum(c.islower() for c in name) < (len(name) / 2)\n\n\ndef coingecko_normalize_all(coin: dict):\n    SYMBOL_TO_NORMALIZED = {'miota': 'IOTA'}\n    normalized = SYMBOL_TO_NORMALIZED.get(coin['symbol'])\n    if normalized:\n        coin['ns'] = coin['nn'] = normalized\n        return normalized\n\n    # ns = normalized symbol, nn = normalized name\n    coin['ns'] = coingecko_normalize_symbol(coin['symbol'])\n\n    ID_SUFFIX = '-bitcoin-token'\n    if coin['id'][-len(ID_SUFFIX):] == ID_SUFFIX:\n        coin['nn'] = 'BTC' + coin['ns']\n        return coin['nn']\n\n    name = coin['name']\n\n    prefixes = ('The ', 'the ')\n    for p in prefixes:\n        if name[:len(p)] == p:\n            coin['reduced-name'] = True\n            name = name[len(p):]\n            break\n\n    suffixes = ('coin', 'coins', 'money', 'finance', 'protocol', 'reward', 'rewards', 'token')\n    for s in suffixes:\n        if len(name) > len(s) and name[-len(s):].lower() == s:\n            # but keep suffix when lower-case concatenated\n            if name[-len(s)].islower() and name[-len(s) - 1] != ' ':\n                continue\n            # also keep suffix to avoid confusing nam: \"Bitcoin Token\" -> \"Bitcoin\"\n            if name[:-len(s)].strip().lower() == 'bitcoin':\n                continue\n            coin['reduced-name'] = True\n            name = name[:-len(s)]\n            break\n\n    coin['nn'] = coingecko_normalize_name(name)\n\n    if len(coin['nn']) < len(coin['ns']):\n        if 'reduced-name' in coin:\n            coin['reduced-name'] = False\n            name = coin['name']\n            coin['nn'] = coingecko_normalize_name(name)\n        elif not has_many_caps(name):\n            return coin['ns']\n\n    if not coin['ns']:  # coin['symbol'] may be an emoji that is striped when normalized\n        return coin['nn']\n\n    if coin.get('reduced-name') and coin['ns'].upper() != coin['nn'].upper():\n        return coin['ns']\n\n    i = coin['nn'].find('.')  # if there is a dot in normalized name => prefer the normalized symbol\n    if i >= 0:\n        if i > 1 and coin['nn'][i - 1].isdigit() and coin['nn'][i + 1].isdigit():\n            pass  # except when the dot separates digits\n        else:\n            return coin['ns']\n\n    if is_name_short(coin) and has_many_caps(name):\n        return coin['nn']\n\n    if 1.5 * len(coin['ns']) > len(coin['nn']) and any(c.islower() for c in coin['ns']):\n        return coin['nn']\n\n    return coin['ns']\n\n\ndef coingecko_symbols() -> Dict[str, str]:\n    r = None\n    intermediate = defaultdict(list)\n    try:\n        r = requests.get('https://api.coingecko.com/api/v3/coins/list')\n        all_coins = r.json()\n        # First pass: generate & compare normalized symbol/name, and then select the most pertinent\n        for coin in all_coins:\n            normalized = coingecko_normalize_all(coin)\n            intermediate[normalized].append(coin)\n            # Above line keeps together the coins having the same normalized symbol.\n            # To reduce collision, the coin['name'] is sometimes used in lieu of the coin['symbol'].\n            # The coin['name'] is not capitalized because lower case letters may be meaningful: cETH, yUSD, DATx, zLOT\n    except Exception as why:\n        raise_failure_explanation('COINGECKO', why, {\"\": r})\n\n    final = coingecko_second_pass(intermediate)\n    return coingecko_third_pass(final)\n\n\ndef coingecko_second_pass(intermediate: Dict[str, List[dict]]) -> Dict[str, List[dict]]:\n    # Second pass: fixes most of the symbol collisions\n    final = defaultdict(list)\n    for normalized, coins in intermediate.items():\n        if len(coins) == 1:\n            final[normalized].append(coins[0])\n            continue\n        set_normalized = False\n        for i in range(len(coins)):\n            if normalized == coins[i]['nn']:\n                coin = coins.pop(i)\n                final[normalized].append(coin)\n                set_normalized = True\n                break\n        rest: List[dict] = []\n        for coin in coins:\n            if '%' in coin['name']:\n                if len(coins) == 1:\n                    n = coin['ns']\n                else:\n                    n = coingecko_normalize_name(coin['id'])\n                final[n].append(coin)\n            else:\n                rest.append(coin)\n        if not rest:\n            continue\n        if not set_normalized:\n            rest.sort(key=lambda coin: len(coin['nn']), reverse=True)  # sort by the length of the normalized name\n            coin = rest.pop(0)\n            final[normalized].append(coin)\n        for coin in rest:\n            if coin['nn'] not in intermediate:\n                n = coin['nn']\n            elif coin.get('reduced-name'):\n                n = coingecko_normalize_name(coin['name'])\n            else:\n                n = coingecko_normalize_name(coin['id'])\n            final[n].append(coin)\n    return final\n\n\ndef coingecko_third_pass(final: Dict[str, List[dict]]) -> Dict[str, str]:\n    # Third pass: fixes some remaining collisions and fills the result\n    symbols = {}\n    for normalized, coins in final.items():\n        if len(coins) == 1:\n            symbols[normalized] = coins[0]['id']\n            continue\n        set_normalized = False\n        for i in range(len(coins)):\n            if normalized == coins[i]['nn']:\n                coin = coins.pop(i)\n                symbols[normalized] = coin['id']\n                set_normalized = True\n                break\n        rest: List[dict] = []\n        for coin in coins:\n            if '%' in coin['name']:\n                if len(coins) == 1:\n                    n = coin['ns']\n                else:\n                    n = coingecko_normalize_name(coin['id'])\n                symbols[n] = coin['id']\n            else:\n                rest.append(coin)\n        if not rest:\n            continue\n        if not set_normalized:\n            rest.sort(key=lambda coin: len(coin['nn']), reverse=True)  # sort by the length of the normalized name\n            coin = rest.pop(0)\n            symbols[normalized] = coin['id']\n        for coin in rest:\n            if coin['nn'] not in final:\n                n = coin['nn']\n            elif coin.get('reduced-name'):\n                n = coingecko_normalize_name(coin['name'])\n            else:\n                n = coingecko_normalize_name(coin['id'])\n            symbols[n] = coin['id']\n    return symbols\n\n\ndef whale_alert_coins(key_id: str) -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get(f'https://api.whale-alert.io/v1/status?api_key={key_id}')\n        # Same symbols, but on different blockchains (for instance USDT), are naturally overwritten.\n        return {s.upper(): s for b in r.json()['blockchains'] for s in b['symbols'] if s}\n    except Exception as why:\n        raise_failure_explanation('WHALES_ALERT', why, {\"\": r})\n\n\n_exchange_function_map = {\n    BITFINEX: bitfinex_symbols,\n    BITFLYER: bitflyer_symbols,\n    COINBASE: coinbase_symbols,\n    GEMINI: gemini_symbols,\n    HITBTC: hitbtc_symbols,\n    POLONIEX: poloniex_symbols,\n    PROBIT: probit_symbols,\n    BITSTAMP: bitstamp_symbols,\n    KRAKEN: kraken_symbols,\n    KRAKEN + 'REST': kraken_rest_symbols,\n    BINANCE: binance_symbols,\n    BINANCE_US: binance_us_symbols,\n    BINANCE_FUTURES: binance_futures_symbols,\n    BINANCE_DELIVERY: binance_delivery_symbols,\n    BLOCKCHAIN: blockchain_symbols,\n    EXX: exx_symbols,\n    HUOBI: huobi_symbols,\n    HUOBI_DM: huobi_dm_symbols,\n    HUOBI_SWAP: huobi_swap_symbols,\n    OKCOIN: okcoin_symbols,\n    OKEX: okex_symbols,\n    BYBIT: bybit_symbols,\n    FTX: ftx_symbols,\n    FTX_US: ftx_us_symbols,\n    BITTREX: bittrex_symbols,\n    BITCOINCOM: bitcoincom_symbols,\n    BITMAX: bitmax_symbols,\n    UPBIT: upbit_symbols,\n    GATEIO: gateio_symbols,\n    BITMEX: bitmex_symbols,\n    DERIBIT: deribit_symbols,\n    KRAKEN_FUTURES: kraken_future_symbols,\n    COINGECKO: coingecko_symbols,\n    WHALE_ALERT: whale_alert_coins\n}\n",
        "source_code_len": 30534,
        "target_code": "associated with this software.\n'''\nfrom typing import Dict, Tuple\n\n\nclass _Symbols:\n    def __init__(self):\n        self.data = {}\n\n    def set(self, exchange: str, normalized: dict, exchange_info: dict):\n        self.data[exchange] = {}\n        self.data[exchange]['normalized'] = normalized\n        self.data[exchange]['info'] = exchange_info\n\n    def get(self, exchange: str) -> Tuple[Dict, Dict]:\n        return self.data[exchange]['normalized'], self.data[exchange]['info']\n\n    def populated(self, exchange: str) -> bool:\n        return exchange in self.data\n\n\nSymbols = _Symbols()\n",
        "target_code_len": 588,
        "diff_format": "@@ -5,845 +5,22 @@\n associated with this software.\n+'''\n+from typing import Dict, Tuple\n \n \n-Symbol generation code for exchanges\n-'''\n+class _Symbols:\n+    def __init__(self):\n+        self.data = {}\n \n-import logging\n-import string\n-import time\n-from collections import defaultdict\n-from typing import Dict, List, Optional, Tuple\n+    def set(self, exchange: str, normalized: dict, exchange_info: dict):\n+        self.data[exchange] = {}\n+        self.data[exchange]['normalized'] = normalized\n+        self.data[exchange]['info'] = exchange_info\n \n-import requests\n-from requests import Response\n+    def get(self, exchange: str) -> Tuple[Dict, Dict]:\n+        return self.data[exchange]['normalized'], self.data[exchange]['info']\n \n-from cryptofeed.defines import *\n+    def populated(self, exchange: str) -> bool:\n+        return exchange in self.data\n \n \n-LOG = logging.getLogger('feedhandler')\n-\n-SYMBOL_SEP = '-'\n-\n-_symbols_retrieval_cache: Dict[str, Dict[str, str]] = {}\n-_exchange_info = defaultdict(lambda: defaultdict(dict))\n-\n-\n-_kraken_futures_product_type = {\n-    'FI': 'Inverse Futures',\n-    'FV': 'Vanilla Futures',\n-    'PI': 'Perpetual Inverse Futures',\n-    'PV': 'Perpetual Vanilla Futures',\n-    'IN': 'Real Time Index',\n-    'RR': 'Reference Rate',\n-}\n-\n-\n-def raise_failure_explanation(feed_id: str, exception: BaseException, responses: Dict[str, Optional[Response]]):\n-    LOG.critical('%s: encountered %r while processing response from exchange API', feed_id, exception)\n-    if len(responses) > 1:\n-        LOG.critical('%s: content of one of the %s responses was unexpected', feed_id, len(responses))\n-    for url, r in responses.items():\n-        if url:\n-            LOG.critical('%s: requested URL: %s', feed_id, url)\n-        if r:\n-            LOG.critical('%s: unexpected response: %s', feed_id, r.text)\n-    raise ValueError(f'Cryptofeed stopped because of an unexpected response from {feed_id}') from exception\n-\n-\n-def set_symbol_separator(separator: str):\n-    global SYMBOL_SEP\n-    SYMBOL_SEP = separator\n-\n-\n-def get_symbol_separator() -> str:\n-    global SYMBOL_SEP\n-    return SYMBOL_SEP\n-\n-\n-def gen_symbols(exchange: str, key_id=None) -> Dict[str, str]:\n-    if exchange not in _symbols_retrieval_cache:\n-        LOG.info(\"%s: Getting list of symbols\", exchange)\n-        symbols = _exchange_function_map[exchange](key_id) if key_id else _exchange_function_map[exchange]()\n-        LOG.info(\"%s: %s symbols\", exchange, len(symbols))\n-\n-        # log all retrieved symbols using debug level\n-        for normalized, exch_sym in sorted(symbols.items()):\n-            LOG.debug('%s: id-from-exch -> normalized: %-35s-> %s', exchange, exch_sym, normalized)\n-\n-        _symbols_retrieval_cache[exchange] = symbols\n-    return _symbols_retrieval_cache[exchange]\n-\n-\n-def _binance_symbols(endpoint: str, exchange: str):\n-    r = None\n-    try:\n-        ret = {}\n-        r = requests.get(endpoint)\n-        for symbol in r.json()['symbols']:\n-            if symbol.get('status', 'TRADING') != \"TRADING\":\n-                continue\n-            if symbol.get('contractStatus', 'TRADING') != \"TRADING\":\n-                continue\n-            split = len(symbol['baseAsset'])\n-            normalized = symbol['symbol'][:split] + SYMBOL_SEP + symbol['symbol'][split:]\n-            ret[normalized] = symbol['symbol']\n-            _exchange_info[exchange]['tick_size'][normalized] = symbol['filters'][0]['tickSize']\n-            if \"contractType\" in symbol:\n-                _exchange_info[exchange]['contract_type'][normalized] = symbol['contractType']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation(exchange, why, {endpoint: r})\n-\n-\n-def binance_symbols() -> Dict[str, str]:\n-    return _binance_symbols('https://api.binance.com/api/v3/exchangeInfo', BINANCE)\n-\n-\n-def binance_us_symbols() -> Dict[str, str]:\n-    return _binance_symbols('https://api.binance.us/api/v3/exchangeInfo', BINANCE_US)\n-\n-\n-def binance_futures_symbols() -> Dict[str, str]:\n-    base = _binance_symbols('https://fapi.binance.com/fapi/v1/exchangeInfo', BINANCE_FUTURES)\n-    add = {}\n-    for symbol, orig in base.items():\n-        if \"_\" in orig:\n-            continue\n-        add[f\"{symbol}-PINDEX\"] = f\"p{orig}\"\n-    base.update(add)\n-    return base\n-\n-\n-def binance_delivery_symbols() -> Dict[str, str]:\n-    return _binance_symbols('https://dapi.binance.com/dapi/v1/exchangeInfo', BINANCE_DELIVERY)\n-\n-\n-def bitfinex_symbols() -> Dict[str, str]:\n-    # doc: https://docs.bitfinex.com/docs/ws-general#supported-pairs\n-    r1 = r2 = None\n-    try:\n-        r1 = requests.get('https://api.bitfinex.com/v2/tickers?symbols=ALL')\n-        r2 = requests.get('https://api-pub.bitfinex.com/v2/conf/pub:map:currency:sym')\n-        tickers: List[List[str]] = r1.json()\n-        norm: List[Tuple[str, str]] = r2.json()[0]\n-        norm: Dict[str, str] = dict(norm)\n-        for k, v in dict(norm).items():\n-            if k[-2:] == 'F0' or '-' in v:  # Do not convert BTCF0 -> BTC or PBTCETH -> PBTC-ETH\n-                del norm[k]\n-        norm['BCHN'] = 'BCH'  # Bitfinex uses BCHN, other exchanges use BCH\n-\n-        ret = {}\n-        for symbol in [t[0] for t in tickers]:\n-            if symbol[0] == 'f':\n-                normalized = norm.get(symbol[1:], symbol[1:])\n-            else:\n-                if len(symbol) == 7:\n-                    base, quote = symbol[1:4], symbol[4:]\n-                else:\n-                    base, quote = symbol[1:].split(':')\n-                    assert ':' in symbol\n-                normalized = norm.get(base, base) + SYMBOL_SEP + norm.get(quote, quote)\n-            ret[normalized.upper()] = symbol\n-        return ret\n-    except ValueError as why:\n-        raise_failure_explanation('BITFINEX', why, {\"tickers?symbols=ALL\": r1, \"pub:map:currency:sym\": r2})\n-\n-\n-def bitflyer_symbols() -> Dict[str, str]:\n-    endpoint = r = None\n-    try:\n-        ret = {}\n-        endpoints = ['https://api.bitflyer.com/v1/getmarkets/eu', 'https://api.bitflyer.com/v1/getmarkets/usa', 'https://api.bitflyer.com/v1/getmarkets']\n-        for endpoint in endpoints:\n-            r = requests.get(endpoint)\n-            for entry in r.json():\n-                normalized = entry['product_code'].replace(\"_\", SYMBOL_SEP)\n-                ret[normalized] = entry['product_code']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('BITFLYER', why, {endpoint: r})\n-\n-\n-def bybit_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.bybit.com/v2/public/symbols')\n-        ret = {}\n-        for symbol in r.json()['result']:\n-            quote = symbol['quote_currency']\n-            if not symbol['name'].endswith(quote):\n-                base, contract = symbol['name'].split(quote)\n-                normalized = f\"{base}{SYMBOL_SEP}{quote}-{contract}\"\n-            else:\n-                normalized = f\"{symbol['base_currency']}{SYMBOL_SEP}{quote}\"\n-            ret[normalized] = symbol['name']\n-            _exchange_info[BYBIT]['tick_size'][normalized] = symbol['price_filter']['tick_size']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('BYBIT', why, {\"\": r})\n-\n-\n-def _ftx_helper(endpoint: str, exchange: str):\n-    r = None\n-    try:\n-        r = requests.get(endpoint)\n-        ret = {}\n-        for data in r.json()['result']:\n-            normalized = data['name'].replace(\"/\", SYMBOL_SEP)\n-            symbol = data['name']\n-            ret[normalized] = symbol\n-            _exchange_info[exchange]['tick_size'][normalized] = data['priceIncrement']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation(exchange, why, {endpoint: r})\n-\n-\n-def ftx_symbols() -> Dict[str, str]:\n-    return _ftx_helper('https://ftx.com/api/markets', FTX)\n-\n-\n-def ftx_us_symbols() -> Dict[str, str]:\n-    return _ftx_helper('https://ftx.us/api/markets', FTX_US)\n-\n-\n-def coinbase_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.pro.coinbase.com/products')\n-        ret = {}\n-        for data in r.json():\n-            normalized = data['id'].replace(\"-\", SYMBOL_SEP)\n-            ret[normalized] = data['id']\n-            _exchange_info[COINBASE]['tick_size'][normalized] = data['quote_increment']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('COINBASE', why, {\"\": r})\n-\n-\n-def gemini_symbols(*args) -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.gemini.com/v1/symbols')\n-        ret = {}\n-        for symbol in r.json():\n-            std = f\"{symbol[:-3]}{SYMBOL_SEP}{symbol[-3:]}\"\n-            std = std.upper()\n-            ret[std] = symbol.upper()\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('GEMINI', why, {\"\": r})\n-\n-\n-def hitbtc_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        ret = {}\n-        r = requests.get('https://api.hitbtc.com/api/2/public/symbol')\n-        for symbol in r.json():\n-            split = len(symbol['baseCurrency'])\n-            normalized = symbol['id'][:split] + SYMBOL_SEP + symbol['id'][split:]\n-            ret[normalized] = symbol['id']\n-            _exchange_info[HITBTC]['tick_size'][normalized] = symbol['tickSize']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('HITBTC', why, {\"\": r})\n-\n-\n-def poloniex_id_symbol_mapping():\n-    r = None\n-    try:\n-        r = requests.get('https://poloniex.com/public?command=returnTicker')\n-        symbols = r.json()\n-        ret = {}\n-        for symbol in symbols:\n-            ret[symbols[symbol]['id']] = symbol\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('POLONIEX', why, {\"\": r})\n-\n-\n-def poloniex_symbols() -> Dict[str, str]:\n-    ret = {}\n-    for _, value in poloniex_id_symbol_mapping().items():\n-        std = value.replace(\"STR\", \"XLM\")\n-        quote, base = std.split(\"_\")\n-        ret[quote + SYMBOL_SEP + base] = value\n-    return ret\n-\n-\n-def bitstamp_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://www.bitstamp.net/api/v2/trading-pairs-info/')\n-        ret = {}\n-        for data in r.json():\n-            normalized = data['name'].replace(\"/\", SYMBOL_SEP)\n-            symbol = data['url_symbol']\n-            ret[normalized] = symbol\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('BITSTAMP', why, {\"\": r})\n-\n-\n-def kraken_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.kraken.com/0/public/AssetPairs')\n-        data = r.json()\n-        ret = {}\n-        for symbol in data['result']:\n-            if 'wsname' not in data['result'][symbol] or '.d' in symbol:\n-                # https://blog.kraken.com/post/259/introducing-the-kraken-dark-pool/\n-                # .d is for dark pool symbols\n-                continue\n-\n-            base, quote = data['result'][symbol]['wsname'].split(\"/\")\n-\n-            normalized = f\"{base}{SYMBOL_SEP}{quote}\"\n-            exch = data['result'][symbol]['wsname']\n-            normalized = normalized.replace('XBT', 'BTC')\n-            normalized = normalized.replace('XDG', 'DOG')\n-            ret[normalized] = exch\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('KRAKEN', why, {\"\": r})\n-\n-\n-def kraken_rest_symbols() -> Dict[str, str]:\n-    return {normalized: exchange.replace(\"/\", \"\") for normalized, exchange in kraken_symbols().items()}\n-\n-\n-def exx_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.exx.com/data/v1/tickers')\n-        exchange = [key.upper() for key in r.json().keys()]\n-        symbols = [key.replace(\"_\", SYMBOL_SEP) for key in exchange]\n-        return dict(zip(symbols, exchange))\n-    except Exception as why:\n-        raise_failure_explanation('EXX', why, {\"\": r})\n-\n-\n-def huobi_common_symbols(url: str):\n-    r = None\n-    try:\n-        r = requests.get(url)\n-        ret = {}\n-        for e in r.json()['data']:\n-            if e['state'] == 'offline':\n-                continue\n-            normalized = f\"{e['base-currency'].upper()}{SYMBOL_SEP}{e['quote-currency'].upper()}\"\n-            symbol = f\"{e['base-currency']}{e['quote-currency']}\"\n-            ret[normalized] = symbol\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('HUOBI', why, {url: r})\n-\n-\n-def huobi_symbols() -> Dict[str, str]:\n-    return huobi_common_symbols('https://api.huobi.pro/v1/common/symbols')\n-\n-\n-def huobi_us_symbols() -> Dict[str, str]:\n-    return huobi_common_symbols('https://api.huobi.com/v1/common/symbols')\n-\n-\n-def huobi_dm_symbols() -> Dict[str, str]:\n-    \"\"\"\n-    Mapping is, for instance: {\"BTC_CW\":\"BTC190816\"}\n-    See comments in exchange/huobi_dm.py\n-    \"\"\"\n-    mapping = {\n-        \"this_week\": \"CW\",\n-        \"next_week\": \"NW\",\n-        \"quarter\": \"CQ\",\n-        \"next_quarter\": \"NQ\"\n-    }\n-    r = None\n-    try:\n-        r = requests.get('https://www.hbdm.com/api/v1/contract_contract_info')\n-        symbols = {}\n-        for e in r.json()['data']:\n-            symbols[f\"{e['symbol']}_{mapping[e['contract_type']]}\"] = e['contract_code']\n-            _exchange_info[HUOBI_DM]['tick_size'][e['contract_code']] = e['price_tick']\n-            _exchange_info[HUOBI_DM]['short_code_mappings'][f\"{e['symbol']}_{mapping[e['contract_type']]}\"] = e['contract_code']\n-        return symbols\n-    except Exception as why:\n-        raise_failure_explanation('HUOBI_DM', why, {\"\": r})\n-\n-\n-def huobi_swap_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.hbdm.com/swap-api/v1/swap_contract_info')\n-        symbols = {}\n-        for e in r.json()['data']:\n-            symbols[e['contract_code']] = e['contract_code']\n-            _exchange_info[HUOBI_SWAP]['tick_size'][e['contract_code']] = e['price_tick']\n-        return symbols\n-    except Exception as why:\n-        raise_failure_explanation('HUOBI_SWAP', why, {\"\": r})\n-\n-\n-def okcoin_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://www.okcoin.com/api/spot/v3/instruments')\n-        ret = {}\n-        for e in r.json():\n-            ret[e['instrument_id']] = e['instrument_id']\n-            _exchange_info[OKCOIN]['tick_size'][e['instrument_id']] = e['tick_size']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('OKCOIN', why, {\"\": r})\n-\n-\n-def okex_symbols(*args) -> Dict[str, str]:\n-    urls = ['https://www.okex.com/api/spot/v3/instruments',\n-            'https://www.okex.com/api/swap/v3/instruments',\n-            'https://www.okex.com/api/futures/v3/instruments']\n-    urls = urls + okex_compute_option_urls_from_underlyings()\n-\n-    symbols: Dict[str, str] = {}\n-    for u in urls:\n-        time.sleep(0.2)\n-        symbols.update(okex_symbols_from_one_url(u))\n-\n-    for symbol in symbols:\n-        instrument_type = 'futures'\n-        dash_count = symbol.count(get_symbol_separator())\n-        if dash_count == 1:  # BTC-USDT\n-            instrument_type = 'spot'\n-        if dash_count == 4:  # BTC-USD-201225-35000-P\n-            instrument_type = 'option'\n-        if symbol[-4:] == \"SWAP\":  # BTC-USDT-SWAP\n-            instrument_type = 'swap'\n-\n-        _exchange_info[OKEX]['instrument_type'][symbol] = instrument_type\n-\n-    return symbols\n-\n-\n-def okex_compute_option_urls_from_underlyings() -> List[str]:\n-    url = 'https://www.okex.com/api/option/v3/underlying'\n-    r = None\n-    try:\n-        r = requests.get(url)\n-        return [f'https://www.okex.com/api/option/v3/instruments/{underlying}' for underlying in r.json()]\n-    except Exception as why:\n-        raise_failure_explanation('OKEX', why, {url: r})\n-\n-\n-def okex_symbols_from_one_url(url: str) -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get(url)\n-        ret = {}\n-        for e in r.json():\n-            ret[e['instrument_id']] = e['instrument_id']\n-            _exchange_info[OKEX]['tick_size'][e['instrument_id']] = e['tick_size']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('OKEX', why, {url: r})\n-\n-\n-def bittrex_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.bittrex.com/api/v1.1/public/getmarkets')\n-        r = r.json()['result']\n-        return {f\"{e['MarketCurrency']}{SYMBOL_SEP}{e['BaseCurrency']}\": e['MarketName'] for e in r if e['IsActive']}\n-    except Exception as why:\n-        raise_failure_explanation('BITTREX', why, {\"\": r})\n-\n-\n-def bitcoincom_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.exchange.bitcoin.com/api/2/public/symbol')\n-        return {f\"{data['baseCurrency']}{SYMBOL_SEP}{data['quoteCurrency'].replace('USD', 'USDT')}\": data['id'] for data in r.json()}\n-    except Exception as why:\n-        raise_failure_explanation('BITCOINCOM', why, {\"\": r})\n-\n-\n-def bitmax_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://bitmax.io/api/pro/v1/products')\n-        ret = {}\n-        for entry in r.json()['data']:\n-            # Only \"Normal\" status symbols are tradeable\n-            if entry['status'] == 'Normal':\n-                normalized = f\"{entry['baseAsset']}{SYMBOL_SEP}{entry['quoteAsset']}\"\n-                ret[normalized] = entry['symbol']\n-                _exchange_info[BITMAX]['tick_size'][normalized] = entry['tickSize']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('BITMAX', why, {\"\": r})\n-\n-\n-def upbit_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.upbit.com/v1/market/all')\n-        return {f\"{data['market'].split('-')[1]}{SYMBOL_SEP}{data['market'].split('-')[0]}\": data['market'] for data in r.json()}\n-    except Exception as why:\n-        raise_failure_explanation('UPBIT', why, {\"\": r})\n-\n-\n-def blockchain_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get(\"https://api.blockchain.com/mercury-gateway/v1/instruments\")\n-        return {data[\"symbol\"].replace(\"-\", SYMBOL_SEP): data[\"symbol\"] for data in r.json()}\n-    except Exception as why:\n-        raise_failure_explanation('BLOCKCHAIN', why, {\"\": r})\n-\n-\n-def gateio_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get(\"https://api.gateio.ws/api/v4/spot/currency_pairs\")\n-        return {data[\"id\"].replace(\"_\", SYMBOL_SEP): data['id'] for data in r.json()}\n-    except Exception as why:\n-        raise_failure_explanation('GATEIO', why, {\"\": r})\n-\n-\n-def bitmex_symbols() -> Dict[str, str]:\n-    r = None\n-    ret = {}\n-    try:\n-        r = requests.get(\"https://www.bitmex.com/api/v1/instrument/active\")\n-        for entry in r.json():\n-            components = []\n-            components.append(entry['rootSymbol'])\n-            components.append(entry['quoteCurrency'])\n-\n-            if entry['expiry']:\n-                components.append(entry['symbol'][-3:])\n-\n-            normalized = SYMBOL_SEP.join(components)\n-            normalized = normalized.replace(\"XBT\", \"BTC\")\n-            ret[normalized] = entry['symbol']\n-            _exchange_info[BITMEX]['tick_size'][normalized] = entry['tickSize']\n-\n-            if entry['expiry']:\n-                _exchange_info[BITMEX]['expiry'][normalized] = entry['expiry']\n-\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('BITMEX', why, {\"\": r})\n-\n-\n-def deribit_symbols() -> Dict[str, str]:\n-    url = r = None\n-    ret = {}\n-    try:\n-        # TODO: get currencies from https://www.deribit.com/api/v2/public/get_currencies\n-        currencies = ['BTC', 'ETH']\n-        for c in currencies:\n-            url = f\"https://www.deribit.com/api/v2/public/get_instruments?currency={c}&expired=false\"\n-            r = requests.get(url)\n-            for entry in r.json()['result']:\n-                split = entry['instrument_name'].split(\"-\")\n-                normalized = split[0] + SYMBOL_SEP + entry['quote_currency'] + \"-\" + '-'.join(split[1:])\n-                ret[normalized] = entry['instrument_name']\n-                _exchange_info[DERIBIT]['tick_size'][normalized] = entry['tick_size']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('DERIBIT', why, {url: r})\n-\n-\n-def kraken_future_symbols() -> Dict[str, str]:\n-    r = None\n-    ret = {}\n-    try:\n-        r = requests.get('https://futures.kraken.com/derivatives/api/v3/instruments')\n-        data = r.json()['instruments']\n-        for entry in data:\n-            if not entry['tradeable']:\n-                continue\n-            normalized = entry['symbol'].upper().replace(\"_\", \"-\")\n-            symbol = normalized[3:6] + SYMBOL_SEP + normalized[6:9]\n-            normalized = normalized.replace(normalized[3:9], symbol)\n-            normalized = normalized.replace('XBT', 'BTC')\n-\n-            _exchange_info[KRAKEN_FUTURES]['tick_size'][normalized] = entry['tickSize']\n-            _exchange_info[KRAKEN_FUTURES]['contract_size'][normalized] = entry['contractSize']\n-            _exchange_info[KRAKEN_FUTURES]['underlying'][normalized] = entry['underlying']\n-            _exchange_info[KRAKEN_FUTURES]['product_type'][normalized] = _kraken_futures_product_type[normalized[:2]]\n-            ret[normalized] = entry['symbol']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('KRAKEN_FUTURES', why, {\"\": r})\n-\n-\n-def probit_symbols() -> Dict[str, str]:\n-    # doc: https://docs-en.probit.com/reference-link/market\n-    r = None\n-    try:\n-        r = requests.get('https://api.probit.com/api/exchange/v1/market')\n-        return {entry['id']: entry['id'] for entry in r.json()['data']}\n-    except Exception as why:\n-        raise_failure_explanation('PROBIT', why, {\"\": r})\n-\n-\n-def coingecko_normalize_symbol(symbol: str) -> str:\n-    # keep digits, letters and dots, replace others by space\n-    symbol = ''.join(c if c.isalnum() or c in ('.', '+') else ' ' for c in symbol)\n-    return coingecko_normalize(symbol.upper())\n-\n-\n-def coingecko_normalize_name(name: str) -> str:\n-    # keep digits and letters, replace others by space (except when only composed by upper case letters, digits and dots)\n-    if not all(c.isupper() or c.isdigit() or c == '.' for c in name):\n-        name = ''.join(c if c.isalnum() else ' ' for c in name)\n-    return coingecko_normalize(name)\n-\n-\n-def coingecko_normalize(sym: str) -> str:\n-    sym = sym.strip()\n-    # do not concatenate numbers => separate them with a dot\n-    sym = list(sym)\n-    if len(sym) > 4:\n-        for i in range(2, len(sym) - 1):\n-            if sym[i] == ' ' and sym[i - 1].isdigit() and sym[i + 1].isdigit():\n-                sym[i] = '.'\n-    sym = ''.join(sym)\n-    # concatenate space-separated words => use CamelCase to distinguish the words\n-    if ' ' in sym:\n-        if sum(c.islower() for c in sym):  # if there is at least one lower case letter\n-            sym = ' '.join(word[0].upper() + word[1:] for word in sym.split())  # Just capitalize initial letter of each word\n-        else:  # CoinGecko may provide full upper-case as for \"THE STONE COIN\"\n-            sym = string.capwords(sym)  # capwords converts \"THE STONE COIN\" to \"The Stone Coin\"\n-        sym = sym.replace(' ', '')  # concatenate words\n-    return sym\n-\n-\n-def is_name_short(coin: dict) -> bool:\n-    \"\"\"return True if the coin name is enough short compared to the coin symbol.\"\"\"\n-    return len(coin['name']) <= max(5, len(coin['symbol']) + 1)\n-\n-\n-def has_many_caps(name: str) -> bool:\n-    \"\"\"return True if the symbol contains enough upper case letters, False if empty.\"\"\"\n-    return str and sum(c.islower() for c in name) < (len(name) / 2)\n-\n-\n-def coingecko_normalize_all(coin: dict):\n-    SYMBOL_TO_NORMALIZED = {'miota': 'IOTA'}\n-    normalized = SYMBOL_TO_NORMALIZED.get(coin['symbol'])\n-    if normalized:\n-        coin['ns'] = coin['nn'] = normalized\n-        return normalized\n-\n-    # ns = normalized symbol, nn = normalized name\n-    coin['ns'] = coingecko_normalize_symbol(coin['symbol'])\n-\n-    ID_SUFFIX = '-bitcoin-token'\n-    if coin['id'][-len(ID_SUFFIX):] == ID_SUFFIX:\n-        coin['nn'] = 'BTC' + coin['ns']\n-        return coin['nn']\n-\n-    name = coin['name']\n-\n-    prefixes = ('The ', 'the ')\n-    for p in prefixes:\n-        if name[:len(p)] == p:\n-            coin['reduced-name'] = True\n-            name = name[len(p):]\n-            break\n-\n-    suffixes = ('coin', 'coins', 'money', 'finance', 'protocol', 'reward', 'rewards', 'token')\n-    for s in suffixes:\n-        if len(name) > len(s) and name[-len(s):].lower() == s:\n-            # but keep suffix when lower-case concatenated\n-            if name[-len(s)].islower() and name[-len(s) - 1] != ' ':\n-                continue\n-            # also keep suffix to avoid confusing nam: \"Bitcoin Token\" -> \"Bitcoin\"\n-            if name[:-len(s)].strip().lower() == 'bitcoin':\n-                continue\n-            coin['reduced-name'] = True\n-            name = name[:-len(s)]\n-            break\n-\n-    coin['nn'] = coingecko_normalize_name(name)\n-\n-    if len(coin['nn']) < len(coin['ns']):\n-        if 'reduced-name' in coin:\n-            coin['reduced-name'] = False\n-            name = coin['name']\n-            coin['nn'] = coingecko_normalize_name(name)\n-        elif not has_many_caps(name):\n-            return coin['ns']\n-\n-    if not coin['ns']:  # coin['symbol'] may be an emoji that is striped when normalized\n-        return coin['nn']\n-\n-    if coin.get('reduced-name') and coin['ns'].upper() != coin['nn'].upper():\n-        return coin['ns']\n-\n-    i = coin['nn'].find('.')  # if there is a dot in normalized name => prefer the normalized symbol\n-    if i >= 0:\n-        if i > 1 and coin['nn'][i - 1].isdigit() and coin['nn'][i + 1].isdigit():\n-            pass  # except when the dot separates digits\n-        else:\n-            return coin['ns']\n-\n-    if is_name_short(coin) and has_many_caps(name):\n-        return coin['nn']\n-\n-    if 1.5 * len(coin['ns']) > len(coin['nn']) and any(c.islower() for c in coin['ns']):\n-        return coin['nn']\n-\n-    return coin['ns']\n-\n-\n-def coingecko_symbols() -> Dict[str, str]:\n-    r = None\n-    intermediate = defaultdict(list)\n-    try:\n-        r = requests.get('https://api.coingecko.com/api/v3/coins/list')\n-        all_coins = r.json()\n-        # First pass: generate & compare normalized symbol/name, and then select the most pertinent\n-        for coin in all_coins:\n-            normalized = coingecko_normalize_all(coin)\n-            intermediate[normalized].append(coin)\n-            # Above line keeps together the coins having the same normalized symbol.\n-            # To reduce collision, the coin['name'] is sometimes used in lieu of the coin['symbol'].\n-            # The coin['name'] is not capitalized because lower case letters may be meaningful: cETH, yUSD, DATx, zLOT\n-    except Exception as why:\n-        raise_failure_explanation('COINGECKO', why, {\"\": r})\n-\n-    final = coingecko_second_pass(intermediate)\n-    return coingecko_third_pass(final)\n-\n-\n-def coingecko_second_pass(intermediate: Dict[str, List[dict]]) -> Dict[str, List[dict]]:\n-    # Second pass: fixes most of the symbol collisions\n-    final = defaultdict(list)\n-    for normalized, coins in intermediate.items():\n-        if len(coins) == 1:\n-            final[normalized].append(coins[0])\n-            continue\n-        set_normalized = False\n-        for i in range(len(coins)):\n-            if normalized == coins[i]['nn']:\n-                coin = coins.pop(i)\n-                final[normalized].append(coin)\n-                set_normalized = True\n-                break\n-        rest: List[dict] = []\n-        for coin in coins:\n-            if '%' in coin['name']:\n-                if len(coins) == 1:\n-                    n = coin['ns']\n-                else:\n-                    n = coingecko_normalize_name(coin['id'])\n-                final[n].append(coin)\n-            else:\n-                rest.append(coin)\n-        if not rest:\n-            continue\n-        if not set_normalized:\n-            rest.sort(key=lambda coin: len(coin['nn']), reverse=True)  # sort by the length of the normalized name\n-            coin = rest.pop(0)\n-            final[normalized].append(coin)\n-        for coin in rest:\n-            if coin['nn'] not in intermediate:\n-                n = coin['nn']\n-            elif coin.get('reduced-name'):\n-                n = coingecko_normalize_name(coin['name'])\n-            else:\n-                n = coingecko_normalize_name(coin['id'])\n-            final[n].append(coin)\n-    return final\n-\n-\n-def coingecko_third_pass(final: Dict[str, List[dict]]) -> Dict[str, str]:\n-    # Third pass: fixes some remaining collisions and fills the result\n-    symbols = {}\n-    for normalized, coins in final.items():\n-        if len(coins) == 1:\n-            symbols[normalized] = coins[0]['id']\n-            continue\n-        set_normalized = False\n-        for i in range(len(coins)):\n-            if normalized == coins[i]['nn']:\n-                coin = coins.pop(i)\n-                symbols[normalized] = coin['id']\n-                set_normalized = True\n-                break\n-        rest: List[dict] = []\n-        for coin in coins:\n-            if '%' in coin['name']:\n-                if len(coins) == 1:\n-                    n = coin['ns']\n-                else:\n-                    n = coingecko_normalize_name(coin['id'])\n-                symbols[n] = coin['id']\n-            else:\n-                rest.append(coin)\n-        if not rest:\n-            continue\n-        if not set_normalized:\n-            rest.sort(key=lambda coin: len(coin['nn']), reverse=True)  # sort by the length of the normalized name\n-            coin = rest.pop(0)\n-            symbols[normalized] = coin['id']\n-        for coin in rest:\n-            if coin['nn'] not in final:\n-                n = coin['nn']\n-            elif coin.get('reduced-name'):\n-                n = coingecko_normalize_name(coin['name'])\n-            else:\n-                n = coingecko_normalize_name(coin['id'])\n-            symbols[n] = coin['id']\n-    return symbols\n-\n-\n-def whale_alert_coins(key_id: str) -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get(f'https://api.whale-alert.io/v1/status?api_key={key_id}')\n-        # Same symbols, but on different blockchains (for instance USDT), are naturally overwritten.\n-        return {s.upper(): s for b in r.json()['blockchains'] for s in b['symbols'] if s}\n-    except Exception as why:\n-        raise_failure_explanation('WHALES_ALERT', why, {\"\": r})\n-\n-\n-_exchange_function_map = {\n-    BITFINEX: bitfinex_symbols,\n-    BITFLYER: bitflyer_symbols,\n-    COINBASE: coinbase_symbols,\n-    GEMINI: gemini_symbols,\n-    HITBTC: hitbtc_symbols,\n-    POLONIEX: poloniex_symbols,\n-    PROBIT: probit_symbols,\n-    BITSTAMP: bitstamp_symbols,\n-    KRAKEN: kraken_symbols,\n-    KRAKEN + 'REST': kraken_rest_symbols,\n-    BINANCE: binance_symbols,\n-    BINANCE_US: binance_us_symbols,\n-    BINANCE_FUTURES: binance_futures_symbols,\n-    BINANCE_DELIVERY: binance_delivery_symbols,\n-    BLOCKCHAIN: blockchain_symbols,\n-    EXX: exx_symbols,\n-    HUOBI: huobi_symbols,\n-    HUOBI_DM: huobi_dm_symbols,\n-    HUOBI_SWAP: huobi_swap_symbols,\n-    OKCOIN: okcoin_symbols,\n-    OKEX: okex_symbols,\n-    BYBIT: bybit_symbols,\n-    FTX: ftx_symbols,\n-    FTX_US: ftx_us_symbols,\n-    BITTREX: bittrex_symbols,\n-    BITCOINCOM: bitcoincom_symbols,\n-    BITMAX: bitmax_symbols,\n-    UPBIT: upbit_symbols,\n-    GATEIO: gateio_symbols,\n-    BITMEX: bitmex_symbols,\n-    DERIBIT: deribit_symbols,\n-    KRAKEN_FUTURES: kraken_future_symbols,\n-    COINGECKO: coingecko_symbols,\n-    WHALE_ALERT: whale_alert_coins\n-}\n+Symbols = _Symbols()\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\n\nimport logging\nimport string\nimport time\nfrom collections import defaultdict\nfrom typing import Dict, List, Optional, Tuple\n\nimport requests\nfrom requests import Response\n\nfrom cryptofeed.defines import *\n\n\nLOG = logging.getLogger('feedhandler')\n\nSYMBOL_SEP = '-'\n\n_symbols_retrieval_cache: Dict[str, Dict[str, str]] = {}\n_exchange_info = defaultdict(lambda: defaultdict(dict))\n\n\n_kraken_futures_product_type = {\n    'FI': 'Inverse Futures',\n    'FV': 'Vanilla Futures',\n    'PI': 'Perpetual Inverse Futures',\n    'PV': 'Perpetual Vanilla Futures',\n    'IN': 'Real Time Index',\n    'RR': 'Reference Rate',\n}\n\n\ndef raise_failure_explanation(feed_id: str, exception: BaseException, responses: Dict[str, Optional[Response]]):\n    <IND>LOG.critical('%s: encountered %r while processing response from exchange API', feed_id, exception)\n    if len(responses) > 1:\n        <IND>LOG.critical('%s: content of one of the %s responses was unexpected', feed_id, len(responses))\n    <DED>for url, r in responses.items():\n        <IND>if url:\n            <IND>LOG.critical('%s: requested URL: %s', feed_id, url)\n        <DED>if r:\n            <IND>LOG.critical('%s: unexpected response: %s', feed_id, r.text)\n    <DED><DED>raise ValueError(f'Cryptofeed stopped because of an unexpected response from {feed_id}') from exception\n\n\n<DED>def set_symbol_separator(separator: str):\n    <IND>global SYMBOL_SEP\n    SYMBOL_SEP = separator\n\n\n<DED>def get_symbol_separator() -> str:\n    <IND>global SYMBOL_SEP\n    return SYMBOL_SEP\n\n\n<DED>def gen_symbols(exchange: str, key_id=None) -> Dict[str, str]:\n    <IND>if exchange not in _symbols_retrieval_cache:\n        <IND>LOG.info(\"%s: Getting list of symbols\", exchange)\n        symbols = _exchange_function_map[exchange](key_id) if key_id else _exchange_function_map[exchange]()\n        LOG.info(\"%s: %s symbols\", exchange, len(symbols))\n\n        # log all retrieved symbols using debug level\n        for normalized, exch_sym in sorted(symbols.items()):\n            <IND>LOG.debug('%s: id-from-exch -> normalized: %-35s-> %s', exchange, exch_sym, normalized)\n\n        <DED>_symbols_retrieval_cache[exchange] = symbols\n    <DED>return _symbols_retrieval_cache[exchange]\n\n\n<DED>def _binance_symbols(endpoint: str, exchange: str):\n    <IND>r = None\n    try:\n        <IND>ret = {}\n        r = requests.get(endpoint)\n        for symbol in r.json()['symbols']:\n            <IND>if symbol.get('status', 'TRADING') != \"TRADING\":\n                <IND>continue\n            <DED>if symbol.get('contractStatus', 'TRADING') != \"TRADING\":\n                <IND>continue\n            <DED>split = len(symbol['baseAsset'])\n            normalized = symbol['symbol'][:split] + SYMBOL_SEP + symbol['symbol'][split:]\n            ret[normalized] = symbol['symbol']\n            _exchange_info[exchange]['tick_size'][normalized] = symbol['filters'][0]['tickSize']\n            if \"contractType\" in symbol:\n                <IND>_exchange_info[exchange]['contract_type'][normalized] = symbol['contractType']\n        <DED><DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation(exchange, why, {endpoint: r})\n\n\n<DED><DED>def binance_symbols() -> Dict[str, str]:\n    <IND>return _binance_symbols('https://api.binance.com/api/v3/exchangeInfo', BINANCE)\n\n\n<DED>def binance_us_symbols() -> Dict[str, str]:\n    <IND>return _binance_symbols('https://api.binance.us/api/v3/exchangeInfo', BINANCE_US)\n\n\n<DED>def binance_futures_symbols() -> Dict[str, str]:\n    <IND>base = _binance_symbols('https://fapi.binance.com/fapi/v1/exchangeInfo', BINANCE_FUTURES)\n    add = {}\n    for symbol, orig in base.items():\n        <IND>if \"_\" in orig:\n            <IND>continue\n        <DED>add[f\"{symbol}-PINDEX\"] = f\"p{orig}\"\n    <DED>base.update(add)\n    return base\n\n\n<DED>def binance_delivery_symbols() -> Dict[str, str]:\n    <IND>return _binance_symbols('https://dapi.binance.com/dapi/v1/exchangeInfo', BINANCE_DELIVERY)\n\n\n<DED>def bitfinex_symbols() -> Dict[str, str]:\n    # doc: https://docs.bitfinex.com/docs/ws-general#supported-pairs\n    <IND>r1 = r2 = None\n    try:\n        <IND>r1 = requests.get('https://api.bitfinex.com/v2/tickers?symbols=ALL')\n        r2 = requests.get('https://api-pub.bitfinex.com/v2/conf/pub:map:currency:sym')\n        tickers: List[List[str]] = r1.json()\n        norm: List[Tuple[str, str]] = r2.json()[0]\n        norm: Dict[str, str] = dict(norm)\n        for k, v in dict(norm).items():\n            <IND>if k[-2:] == 'F0' or '-' in v:  # Do not convert BTCF0 -> BTC or PBTCETH -> PBTC-ETH\n                <IND>del norm[k]\n        <DED><DED>norm['BCHN'] = 'BCH'  # Bitfinex uses BCHN, other exchanges use BCH\n\n        ret = {}\n        for symbol in [t[0] for t in tickers]:\n            <IND>if symbol[0] == 'f':\n                <IND>normalized = norm.get(symbol[1:], symbol[1:])\n            <DED>else:\n                <IND>if len(symbol) == 7:\n                    <IND>base, quote = symbol[1:4], symbol[4:]\n                <DED>else:\n                    <IND>base, quote = symbol[1:].split(':')\n                    assert ':' in symbol\n                <DED>normalized = norm.get(base, base) + SYMBOL_SEP + norm.get(quote, quote)\n            <DED>ret[normalized.upper()] = symbol\n        <DED>return ret\n    <DED>except ValueError as why:\n        <IND>raise_failure_explanation('BITFINEX', why, {\"tickers?symbols=ALL\": r1, \"pub:map:currency:sym\": r2})\n\n\n<DED><DED>def bitflyer_symbols() -> Dict[str, str]:\n    <IND>endpoint = r = None\n    try:\n        <IND>ret = {}\n        endpoints = ['https://api.bitflyer.com/v1/getmarkets/eu', 'https://api.bitflyer.com/v1/getmarkets/usa', 'https://api.bitflyer.com/v1/getmarkets']\n        for endpoint in endpoints:\n            <IND>r = requests.get(endpoint)\n            for entry in r.json():\n                <IND>normalized = entry['product_code'].replace(\"_\", SYMBOL_SEP)\n                ret[normalized] = entry['product_code']\n        <DED><DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BITFLYER', why, {endpoint: r})\n\n\n<DED><DED>def bybit_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.bybit.com/v2/public/symbols')\n        ret = {}\n        for symbol in r.json()['result']:\n            <IND>quote = symbol['quote_currency']\n            if not symbol['name'].endswith(quote):\n                <IND>base, contract = symbol['name'].split(quote)\n                normalized = f\"{base}{SYMBOL_SEP}{quote}-{contract}\"\n            <DED>else:\n                <IND>normalized = f\"{symbol['base_currency']}{SYMBOL_SEP}{quote}\"\n            <DED>ret[normalized] = symbol['name']\n            _exchange_info[BYBIT]['tick_size'][normalized] = symbol['price_filter']['tick_size']\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BYBIT', why, {\"\": r})\n\n\n<DED><DED>def _ftx_helper(endpoint: str, exchange: str):\n    <IND>r = None\n    try:\n        <IND>r = requests.get(endpoint)\n        ret = {}\n        for data in r.json()['result']:\n            <IND>normalized = data['name'].replace(\"/\", SYMBOL_SEP)\n            symbol = data['name']\n            ret[normalized] = symbol\n            _exchange_info[exchange]['tick_size'][normalized] = data['priceIncrement']\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation(exchange, why, {endpoint: r})\n\n\n<DED><DED>def ftx_symbols() -> Dict[str, str]:\n    <IND>return _ftx_helper('https://ftx.com/api/markets', FTX)\n\n\n<DED>def ftx_us_symbols() -> Dict[str, str]:\n    <IND>return _ftx_helper('https://ftx.us/api/markets', FTX_US)\n\n\n<DED>def coinbase_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.pro.coinbase.com/products')\n        ret = {}\n        for data in r.json():\n            <IND>normalized = data['id'].replace(\"-\", SYMBOL_SEP)\n            ret[normalized] = data['id']\n            _exchange_info[COINBASE]['tick_size'][normalized] = data['quote_increment']\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('COINBASE', why, {\"\": r})\n\n\n<DED><DED>def gemini_symbols(*args) -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.gemini.com/v1/symbols')\n        ret = {}\n        for symbol in r.json():\n            <IND>std = f\"{symbol[:-3]}{SYMBOL_SEP}{symbol[-3:]}\"\n            std = std.upper()\n            ret[std] = symbol.upper()\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('GEMINI', why, {\"\": r})\n\n\n<DED><DED>def hitbtc_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>ret = {}\n        r = requests.get('https://api.hitbtc.com/api/2/public/symbol')\n        for symbol in r.json():\n            <IND>split = len(symbol['baseCurrency'])\n            normalized = symbol['id'][:split] + SYMBOL_SEP + symbol['id'][split:]\n            ret[normalized] = symbol['id']\n            _exchange_info[HITBTC]['tick_size'][normalized] = symbol['tickSize']\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('HITBTC', why, {\"\": r})\n\n\n<DED><DED>def poloniex_id_symbol_mapping():\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://poloniex.com/public?command=returnTicker')\n        symbols = r.json()\n        ret = {}\n        for symbol in symbols:\n            <IND>ret[symbols[symbol]['id']] = symbol\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('POLONIEX', why, {\"\": r})\n\n\n<DED><DED>def poloniex_symbols() -> Dict[str, str]:\n    <IND>ret = {}\n    for _, value in poloniex_id_symbol_mapping().items():\n        <IND>std = value.replace(\"STR\", \"XLM\")\n        quote, base = std.split(\"_\")\n        ret[quote + SYMBOL_SEP + base] = value\n    <DED>return ret\n\n\n<DED>def bitstamp_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://www.bitstamp.net/api/v2/trading-pairs-info/')\n        ret = {}\n        for data in r.json():\n            <IND>normalized = data['name'].replace(\"/\", SYMBOL_SEP)\n            symbol = data['url_symbol']\n            ret[normalized] = symbol\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BITSTAMP', why, {\"\": r})\n\n\n<DED><DED>def kraken_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.kraken.com/0/public/AssetPairs')\n        data = r.json()\n        ret = {}\n        for symbol in data['result']:\n            <IND>if 'wsname' not in data['result'][symbol] or '.d' in symbol:\n                # https://blog.kraken.com/post/259/introducing-the-kraken-dark-pool/\n                # .d is for dark pool symbols\n                <IND>continue\n\n            <DED>base, quote = data['result'][symbol]['wsname'].split(\"/\")\n\n            normalized = f\"{base}{SYMBOL_SEP}{quote}\"\n            exch = data['result'][symbol]['wsname']\n            normalized = normalized.replace('XBT', 'BTC')\n            normalized = normalized.replace('XDG', 'DOG')\n            ret[normalized] = exch\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('KRAKEN', why, {\"\": r})\n\n\n<DED><DED>def kraken_rest_symbols() -> Dict[str, str]:\n    <IND>return {normalized: exchange.replace(\"/\", \"\") for normalized, exchange in kraken_symbols().items()}\n\n\n<DED>def exx_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.exx.com/data/v1/tickers')\n        exchange = [key.upper() for key in r.json().keys()]\n        symbols = [key.replace(\"_\", SYMBOL_SEP) for key in exchange]\n        return dict(zip(symbols, exchange))\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('EXX', why, {\"\": r})\n\n\n<DED><DED>def huobi_common_symbols(url: str):\n    <IND>r = None\n    try:\n        <IND>r = requests.get(url)\n        ret = {}\n        for e in r.json()['data']:\n            <IND>if e['state'] == 'offline':\n                <IND>continue\n            <DED>normalized = f\"{e['base-currency'].upper()}{SYMBOL_SEP}{e['quote-currency'].upper()}\"\n            symbol = f\"{e['base-currency']}{e['quote-currency']}\"\n            ret[normalized] = symbol\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('HUOBI', why, {url: r})\n\n\n<DED><DED>def huobi_symbols() -> Dict[str, str]:\n    <IND>return huobi_common_symbols('https://api.huobi.pro/v1/common/symbols')\n\n\n<DED>def huobi_us_symbols() -> Dict[str, str]:\n    <IND>return huobi_common_symbols('https://api.huobi.com/v1/common/symbols')\n\n\n<DED>def huobi_dm_symbols() -> Dict[str, str]:\n    <IND>\"\"\"\n    Mapping is, for instance: {\"BTC_CW\":\"BTC190816\"}\n    See comments in exchange/huobi_dm.py\n    \"\"\"\n    mapping = {\n        \"this_week\": \"CW\",\n        \"next_week\": \"NW\",\n        \"quarter\": \"CQ\",\n        \"next_quarter\": \"NQ\"\n    }\n    r = None\n    try:\n        <IND>r = requests.get('https://www.hbdm.com/api/v1/contract_contract_info')\n        symbols = {}\n        for e in r.json()['data']:\n            <IND>symbols[f\"{e['symbol']}_{mapping[e['contract_type']]}\"] = e['contract_code']\n            _exchange_info[HUOBI_DM]['tick_size'][e['contract_code']] = e['price_tick']\n            _exchange_info[HUOBI_DM]['short_code_mappings'][f\"{e['symbol']}_{mapping[e['contract_type']]}\"] = e['contract_code']\n        <DED>return symbols\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('HUOBI_DM', why, {\"\": r})\n\n\n<DED><DED>def huobi_swap_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.hbdm.com/swap-api/v1/swap_contract_info')\n        symbols = {}\n        for e in r.json()['data']:\n            <IND>symbols[e['contract_code']] = e['contract_code']\n            _exchange_info[HUOBI_SWAP]['tick_size'][e['contract_code']] = e['price_tick']\n        <DED>return symbols\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('HUOBI_SWAP', why, {\"\": r})\n\n\n<DED><DED>def okcoin_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://www.okcoin.com/api/spot/v3/instruments')\n        ret = {}\n        for e in r.json():\n            <IND>ret[e['instrument_id']] = e['instrument_id']\n            _exchange_info[OKCOIN]['tick_size'][e['instrument_id']] = e['tick_size']\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('OKCOIN', why, {\"\": r})\n\n\n<DED><DED>def okex_symbols(*args) -> Dict[str, str]:\n    <IND>urls = ['https://www.okex.com/api/spot/v3/instruments',\n            'https://www.okex.com/api/swap/v3/instruments',\n            'https://www.okex.com/api/futures/v3/instruments']\n    urls = urls + okex_compute_option_urls_from_underlyings()\n\n    symbols: Dict[str, str] = {}\n    for u in urls:\n        <IND>time.sleep(0.2)\n        symbols.update(okex_symbols_from_one_url(u))\n\n    <DED>for symbol in symbols:\n        <IND>instrument_type = 'futures'\n        dash_count = symbol.count(get_symbol_separator())\n        if dash_count == 1:  # BTC-USDT\n            <IND>instrument_type = 'spot'\n        <DED>if dash_count == 4:  # BTC-USD-201225-35000-P\n            <IND>instrument_type = 'option'\n        <DED>if symbol[-4:] == \"SWAP\":  # BTC-USDT-SWAP\n            <IND>instrument_type = 'swap'\n\n        <DED>_exchange_info[OKEX]['instrument_type'][symbol] = instrument_type\n\n    <DED>return symbols\n\n\n<DED>def okex_compute_option_urls_from_underlyings() -> List[str]:\n    <IND>url = 'https://www.okex.com/api/option/v3/underlying'\n    r = None\n    try:\n        <IND>r = requests.get(url)\n        return [f'https://www.okex.com/api/option/v3/instruments/{underlying}' for underlying in r.json()]\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('OKEX', why, {url: r})\n\n\n<DED><DED>def okex_symbols_from_one_url(url: str) -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get(url)\n        ret = {}\n        for e in r.json():\n            <IND>ret[e['instrument_id']] = e['instrument_id']\n            _exchange_info[OKEX]['tick_size'][e['instrument_id']] = e['tick_size']\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('OKEX', why, {url: r})\n\n\n<DED><DED>def bittrex_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.bittrex.com/api/v1.1/public/getmarkets')\n        r = r.json()['result']\n        return {f\"{e['MarketCurrency']}{SYMBOL_SEP}{e['BaseCurrency']}\": e['MarketName'] for e in r if e['IsActive']}\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BITTREX', why, {\"\": r})\n\n\n<DED><DED>def bitcoincom_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.exchange.bitcoin.com/api/2/public/symbol')\n        return {f\"{data['baseCurrency']}{SYMBOL_SEP}{data['quoteCurrency'].replace('USD', 'USDT')}\": data['id'] for data in r.json()}\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BITCOINCOM', why, {\"\": r})\n\n\n<DED><DED>def bitmax_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://bitmax.io/api/pro/v1/products')\n        ret = {}\n        for entry in r.json()['data']:\n            # Only \"Normal\" status symbols are tradeable\n            <IND>if entry['status'] == 'Normal':\n                <IND>normalized = f\"{entry['baseAsset']}{SYMBOL_SEP}{entry['quoteAsset']}\"\n                ret[normalized] = entry['symbol']\n                _exchange_info[BITMAX]['tick_size'][normalized] = entry['tickSize']\n        <DED><DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BITMAX', why, {\"\": r})\n\n\n<DED><DED>def upbit_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.upbit.com/v1/market/all')\n        return {f\"{data['market'].split('-')[1]}{SYMBOL_SEP}{data['market'].split('-')[0]}\": data['market'] for data in r.json()}\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('UPBIT', why, {\"\": r})\n\n\n<DED><DED>def blockchain_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get(\"https://api.blockchain.com/mercury-gateway/v1/instruments\")\n        return {data[\"symbol\"].replace(\"-\", SYMBOL_SEP): data[\"symbol\"] for data in r.json()}\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BLOCKCHAIN', why, {\"\": r})\n\n\n<DED><DED>def gateio_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get(\"https://api.gateio.ws/api/v4/spot/currency_pairs\")\n        return {data[\"id\"].replace(\"_\", SYMBOL_SEP): data['id'] for data in r.json()}\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('GATEIO', why, {\"\": r})\n\n\n<DED><DED>def bitmex_symbols() -> Dict[str, str]:\n    <IND>r = None\n    ret = {}\n    try:\n        <IND>r = requests.get(\"https://www.bitmex.com/api/v1/instrument/active\")\n        for entry in r.json():\n            <IND>components = []\n            components.append(entry['rootSymbol'])\n            components.append(entry['quoteCurrency'])\n\n            if entry['expiry']:\n                <IND>components.append(entry['symbol'][-3:])\n\n            <DED>normalized = SYMBOL_SEP.join(components)\n            normalized = normalized.replace(\"XBT\", \"BTC\")\n            ret[normalized] = entry['symbol']\n            _exchange_info[BITMEX]['tick_size'][normalized] = entry['tickSize']\n\n            if entry['expiry']:\n                <IND>_exchange_info[BITMEX]['expiry'][normalized] = entry['expiry']\n\n        <DED><DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BITMEX', why, {\"\": r})\n\n\n<DED><DED>def deribit_symbols() -> Dict[str, str]:\n    <IND>url = r = None\n    ret = {}\n    try:\n        # TODO: get currencies from https://www.deribit.com/api/v2/public/get_currencies\n        <IND>currencies = ['BTC', 'ETH']\n        for c in currencies:\n            <IND>url = f\"https://www.deribit.com/api/v2/public/get_instruments?currency={c}&expired=false\"\n            r = requests.get(url)\n            for entry in r.json()['result']:\n                <IND>split = entry['instrument_name'].split(\"-\")\n                normalized = split[0] + SYMBOL_SEP + entry['quote_currency'] + \"-\" + '-'.join(split[1:])\n                ret[normalized] = entry['instrument_name']\n                _exchange_info[DERIBIT]['tick_size'][normalized] = entry['tick_size']\n        <DED><DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('DERIBIT', why, {url: r})\n\n\n<DED><DED>def kraken_future_symbols() -> Dict[str, str]:\n    <IND>r = None\n    ret = {}\n    try:\n        <IND>r = requests.get('https://futures.kraken.com/derivatives/api/v3/instruments')\n        data = r.json()['instruments']\n        for entry in data:\n            <IND>if not entry['tradeable']:\n                <IND>continue\n            <DED>normalized = entry['symbol'].upper().replace(\"_\", \"-\")\n            symbol = normalized[3:6] + SYMBOL_SEP + normalized[6:9]\n            normalized = normalized.replace(normalized[3:9], symbol)\n            normalized = normalized.replace('XBT', 'BTC')\n\n            _exchange_info[KRAKEN_FUTURES]['tick_size'][normalized] = entry['tickSize']\n            _exchange_info[KRAKEN_FUTURES]['contract_size'][normalized] = entry['contractSize']\n            _exchange_info[KRAKEN_FUTURES]['underlying'][normalized] = entry['underlying']\n            _exchange_info[KRAKEN_FUTURES]['product_type'][normalized] = _kraken_futures_product_type[normalized[:2]]\n            ret[normalized] = entry['symbol']\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('KRAKEN_FUTURES', why, {\"\": r})\n\n\n<DED><DED>def probit_symbols() -> Dict[str, str]:\n    # doc: https://docs-en.probit.com/reference-link/market\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.probit.com/api/exchange/v1/market')\n        return {entry['id']: entry['id'] for entry in r.json()['data']}\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('PROBIT', why, {\"\": r})\n\n\n<DED><DED>def coingecko_normalize_symbol(symbol: str) -> str:\n    # keep digits, letters and dots, replace others by space\n    <IND>symbol = ''.join(c if c.isalnum() or c in ('.', '+') else ' ' for c in symbol)\n    return coingecko_normalize(symbol.upper())\n\n\n<DED>def coingecko_normalize_name(name: str) -> str:\n    # keep digits and letters, replace others by space (except when only composed by upper case letters, digits and dots)\n    <IND>if not all(c.isupper() or c.isdigit() or c == '.' for c in name):\n        <IND>name = ''.join(c if c.isalnum() else ' ' for c in name)\n    <DED>return coingecko_normalize(name)\n\n\n<DED>def coingecko_normalize(sym: str) -> str:\n    <IND>sym = sym.strip()\n    # do not concatenate numbers => separate them with a dot\n    sym = list(sym)\n    if len(sym) > 4:\n        <IND>for i in range(2, len(sym) - 1):\n            <IND>if sym[i] == ' ' and sym[i - 1].isdigit() and sym[i + 1].isdigit():\n                <IND>sym[i] = '.'\n    <DED><DED><DED>sym = ''.join(sym)\n    # concatenate space-separated words => use CamelCase to distinguish the words\n    if ' ' in sym:\n        <IND>if sum(c.islower() for c in sym):  # if there is at least one lower case letter\n            <IND>sym = ' '.join(word[0].upper() + word[1:] for word in sym.split())  # Just capitalize initial letter of each word\n        <DED>else:  # CoinGecko may provide full upper-case as for \"THE STONE COIN\"\n            <IND>sym = string.capwords(sym)  # capwords converts \"THE STONE COIN\" to \"The Stone Coin\"\n        <DED>sym = sym.replace(' ', '')  # concatenate words\n    <DED>return sym\n\n\n<DED>def is_name_short(coin: dict) -> bool:\n    <IND>\"\"\"return True if the coin name is enough short compared to the coin symbol.\"\"\"\n    return len(coin['name']) <= max(5, len(coin['symbol']) + 1)\n\n\n<DED>def has_many_caps(name: str) -> bool:\n    <IND>\"\"\"return True if the symbol contains enough upper case letters, False if empty.\"\"\"\n    return str and sum(c.islower() for c in name) < (len(name) / 2)\n\n\n<DED>def coingecko_normalize_all(coin: dict):\n    <IND>SYMBOL_TO_NORMALIZED = {'miota': 'IOTA'}\n    normalized = SYMBOL_TO_NORMALIZED.get(coin['symbol'])\n    if normalized:\n        <IND>coin['ns'] = coin['nn'] = normalized\n        return normalized\n\n    # ns = normalized symbol, nn = normalized name\n    <DED>coin['ns'] = coingecko_normalize_symbol(coin['symbol'])\n\n    ID_SUFFIX = '-bitcoin-token'\n    if coin['id'][-len(ID_SUFFIX):] == ID_SUFFIX:\n        <IND>coin['nn'] = 'BTC' + coin['ns']\n        return coin['nn']\n\n    <DED>name = coin['name']\n\n    prefixes = ('The ', 'the ')\n    for p in prefixes:\n        <IND>if name[:len(p)] == p:\n            <IND>coin['reduced-name'] = True\n            name = name[len(p):]\n            break\n\n    <DED><DED>suffixes = ('coin', 'coins', 'money', 'finance', 'protocol', 'reward', 'rewards', 'token')\n    for s in suffixes:\n        <IND>if len(name) > len(s) and name[-len(s):].lower() == s:\n            # but keep suffix when lower-case concatenated\n            <IND>if name[-len(s)].islower() and name[-len(s) - 1] != ' ':\n                <IND>continue\n            # also keep suffix to avoid confusing nam: \"Bitcoin Token\" -> \"Bitcoin\"\n            <DED>if name[:-len(s)].strip().lower() == 'bitcoin':\n                <IND>continue\n            <DED>coin['reduced-name'] = True\n            name = name[:-len(s)]\n            break\n\n    <DED><DED>coin['nn'] = coingecko_normalize_name(name)\n\n    if len(coin['nn']) < len(coin['ns']):\n        <IND>if 'reduced-name' in coin:\n            <IND>coin['reduced-name'] = False\n            name = coin['name']\n            coin['nn'] = coingecko_normalize_name(name)\n        <DED>elif not has_many_caps(name):\n            <IND>return coin['ns']\n\n    <DED><DED>if not coin['ns']:  # coin['symbol'] may be an emoji that is striped when normalized\n        <IND>return coin['nn']\n\n    <DED>if coin.get('reduced-name') and coin['ns'].upper() != coin['nn'].upper():\n        <IND>return coin['ns']\n\n    <DED>i = coin['nn'].find('.')  # if there is a dot in normalized name => prefer the normalized symbol\n    if i >= 0:\n        <IND>if i > 1 and coin['nn'][i - 1].isdigit() and coin['nn'][i + 1].isdigit():\n            <IND>pass  # except when the dot separates digits\n        <DED>else:\n            <IND>return coin['ns']\n\n    <DED><DED>if is_name_short(coin) and has_many_caps(name):\n        <IND>return coin['nn']\n\n    <DED>if 1.5 * len(coin['ns']) > len(coin['nn']) and any(c.islower() for c in coin['ns']):\n        <IND>return coin['nn']\n\n    <DED>return coin['ns']\n\n\n<DED>def coingecko_symbols() -> Dict[str, str]:\n    <IND>r = None\n    intermediate = defaultdict(list)\n    try:\n        <IND>r = requests.get('https://api.coingecko.com/api/v3/coins/list')\n        all_coins = r.json()\n        # First pass: generate & compare normalized symbol/name, and then select the most pertinent\n        for coin in all_coins:\n            <IND>normalized = coingecko_normalize_all(coin)\n            intermediate[normalized].append(coin)\n            # Above line keeps together the coins having the same normalized symbol.\n            # To reduce collision, the coin['name'] is sometimes used in lieu of the coin['symbol'].\n            # The coin['name'] is not capitalized because lower case letters may be meaningful: cETH, yUSD, DATx, zLOT\n    <DED><DED>except Exception as why:\n        <IND>raise_failure_explanation('COINGECKO', why, {\"\": r})\n\n    <DED>final = coingecko_second_pass(intermediate)\n    return coingecko_third_pass(final)\n\n\n<DED>def coingecko_second_pass(intermediate: Dict[str, List[dict]]) -> Dict[str, List[dict]]:\n    # Second pass: fixes most of the symbol collisions\n    <IND>final = defaultdict(list)\n    for normalized, coins in intermediate.items():\n        <IND>if len(coins) == 1:\n            <IND>final[normalized].append(coins[0])\n            continue\n        <DED>set_normalized = False\n        for i in range(len(coins)):\n            <IND>if normalized == coins[i]['nn']:\n                <IND>coin = coins.pop(i)\n                final[normalized].append(coin)\n                set_normalized = True\n                break\n        <DED><DED>rest: List[dict] = []\n        for coin in coins:\n            <IND>if '%' in coin['name']:\n                <IND>if len(coins) == 1:\n                    <IND>n = coin['ns']\n                <DED>else:\n                    <IND>n = coingecko_normalize_name(coin['id'])\n                <DED>final[n].append(coin)\n            <DED>else:\n                <IND>rest.append(coin)\n        <DED><DED>if not rest:\n            <IND>continue\n        <DED>if not set_normalized:\n            <IND>rest.sort(key=lambda coin: len(coin['nn']), reverse=True)  # sort by the length of the normalized name\n            coin = rest.pop(0)\n            final[normalized].append(coin)\n        <DED>for coin in rest:\n            <IND>if coin['nn'] not in intermediate:\n                <IND>n = coin['nn']\n            <DED>elif coin.get('reduced-name'):\n                <IND>n = coingecko_normalize_name(coin['name'])\n            <DED>else:\n                <IND>n = coingecko_normalize_name(coin['id'])\n            <DED>final[n].append(coin)\n    <DED><DED>return final\n\n\n<DED>def coingecko_third_pass(final: Dict[str, List[dict]]) -> Dict[str, str]:\n    # Third pass: fixes some remaining collisions and fills the result\n    <IND>symbols = {}\n    for normalized, coins in final.items():\n        <IND>if len(coins) == 1:\n            <IND>symbols[normalized] = coins[0]['id']\n            continue\n        <DED>set_normalized = False\n        for i in range(len(coins)):\n            <IND>if normalized == coins[i]['nn']:\n                <IND>coin = coins.pop(i)\n                symbols[normalized] = coin['id']\n                set_normalized = True\n                break\n        <DED><DED>rest: List[dict] = []\n        for coin in coins:\n            <IND>if '%' in coin['name']:\n                <IND>if len(coins) == 1:\n                    <IND>n = coin['ns']\n                <DED>else:\n                    <IND>n = coingecko_normalize_name(coin['id'])\n                <DED>symbols[n] = coin['id']\n            <DED>else:\n                <IND>rest.append(coin)\n        <DED><DED>if not rest:\n            <IND>continue\n        <DED>if not set_normalized:\n            <IND>rest.sort(key=lambda coin: len(coin['nn']), reverse=True)  # sort by the length of the normalized name\n            coin = rest.pop(0)\n            symbols[normalized] = coin['id']\n        <DED>for coin in rest:\n            <IND>if coin['nn'] not in final:\n                <IND>n = coin['nn']\n            <DED>elif coin.get('reduced-name'):\n                <IND>n = coingecko_normalize_name(coin['name'])\n            <DED>else:\n                <IND>n = coingecko_normalize_name(coin['id'])\n            <DED>symbols[n] = coin['id']\n    <DED><DED>return symbols\n\n\n<DED>def whale_alert_coins(key_id: str) -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get(f'https://api.whale-alert.io/v1/status?api_key={key_id}')\n        # Same symbols, but on different blockchains (for instance USDT), are naturally overwritten.\n        return {s.upper(): s for b in r.json()['blockchains'] for s in b['symbols'] if s}\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('WHALES_ALERT', why, {\"\": r})\n\n\n<DED><DED>_exchange_function_map = {\n    BITFINEX: bitfinex_symbols,\n    BITFLYER: bitflyer_symbols,\n    COINBASE: coinbase_symbols,\n    GEMINI: gemini_symbols,\n    HITBTC: hitbtc_symbols,\n    POLONIEX: poloniex_symbols,\n    PROBIT: probit_symbols,\n    BITSTAMP: bitstamp_symbols,\n    KRAKEN: kraken_symbols,\n    KRAKEN + 'REST': kraken_rest_symbols,\n    BINANCE: binance_symbols,\n    BINANCE_US: binance_us_symbols,\n    BINANCE_FUTURES: binance_futures_symbols,\n    BINANCE_DELIVERY: binance_delivery_symbols,\n    BLOCKCHAIN: blockchain_symbols,\n    EXX: exx_symbols,\n    HUOBI: huobi_symbols,\n    HUOBI_DM: huobi_dm_symbols,\n    HUOBI_SWAP: huobi_swap_symbols,\n    OKCOIN: okcoin_symbols,\n    OKEX: okex_symbols,\n    BYBIT: bybit_symbols,\n    FTX: ftx_symbols,\n    FTX_US: ftx_us_symbols,\n    BITTREX: bittrex_symbols,\n    BITCOINCOM: bitcoincom_symbols,\n    BITMAX: bitmax_symbols,\n    UPBIT: upbit_symbols,\n    GATEIO: gateio_symbols,\n    BITMEX: bitmex_symbols,\n    DERIBIT: deribit_symbols,\n    KRAKEN_FUTURES: kraken_future_symbols,\n    COINGECKO: coingecko_symbols,\n    WHALE_ALERT: whale_alert_coins\n}\n",
        "target_code_with_indent": "\nfrom typing import Dict, Tuple\n\n\nclass _Symbols:\n    <IND>def __init__(self):\n        <IND>self.data = {}\n\n    <DED>def set(self, exchange: str, normalized: dict, exchange_info: dict):\n        <IND>self.data[exchange] = {}\n        self.data[exchange]['normalized'] = normalized\n        self.data[exchange]['info'] = exchange_info\n\n    <DED>def get(self, exchange: str) -> Tuple[Dict, Dict]:\n        <IND>return self.data[exchange]['normalized'], self.data[exchange]['info']\n\n    <DED>def populated(self, exchange: str) -> bool:\n        <IND>return exchange in self.data\n\n\n<DED><DED>Symbols = _Symbols()\n"
      }
    ]
  },
  {
    "project": "bmoscon/cryptofeed",
    "commit": "3525dc8ce4d7836a9abaaa5662e58e5e27969a77",
    "filename": "cryptofeed/symbols.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/bmoscon-cryptofeed/cryptofeed/symbols.py",
    "file_hunks_size": 1,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "cryptofeed/symbols.py:500:8 Incompatible return type [7]: Expected `Dict[str, str]` but got implicit return value of `None`.",
    "message": " Expected `Dict[str, str]` but got implicit return value of `None`.",
    "rule_id": "Incompatible return type [7]",
    "warning_line_no": 500,
    "warning_line": "        raise_failure_explanation('BLOCKCHAIN', why, {\"\": r})",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "associated with this software.\n\n\nSymbol generation code for exchanges\n'''\n\nimport logging\nimport string\nimport time\nfrom collections import defaultdict\nfrom typing import Dict, List, Optional, Tuple\n\nimport requests\nfrom requests import Response\n\nfrom cryptofeed.defines import *\n\n\nLOG = logging.getLogger('feedhandler')\n\nSYMBOL_SEP = '-'\n\n_symbols_retrieval_cache: Dict[str, Dict[str, str]] = {}\n_exchange_info = defaultdict(lambda: defaultdict(dict))\n\n\n_kraken_futures_product_type = {\n    'FI': 'Inverse Futures',\n    'FV': 'Vanilla Futures',\n    'PI': 'Perpetual Inverse Futures',\n    'PV': 'Perpetual Vanilla Futures',\n    'IN': 'Real Time Index',\n    'RR': 'Reference Rate',\n}\n\n\ndef raise_failure_explanation(feed_id: str, exception: BaseException, responses: Dict[str, Optional[Response]]):\n    LOG.critical('%s: encountered %r while processing response from exchange API', feed_id, exception)\n    if len(responses) > 1:\n        LOG.critical('%s: content of one of the %s responses was unexpected', feed_id, len(responses))\n    for url, r in responses.items():\n        if url:\n            LOG.critical('%s: requested URL: %s', feed_id, url)\n        if r:\n            LOG.critical('%s: unexpected response: %s', feed_id, r.text)\n    raise ValueError(f'Cryptofeed stopped because of an unexpected response from {feed_id}') from exception\n\n\ndef set_symbol_separator(separator: str):\n    global SYMBOL_SEP\n    SYMBOL_SEP = separator\n\n\ndef get_symbol_separator() -> str:\n    global SYMBOL_SEP\n    return SYMBOL_SEP\n\n\ndef gen_symbols(exchange: str, key_id=None) -> Dict[str, str]:\n    if exchange not in _symbols_retrieval_cache:\n        LOG.info(\"%s: Getting list of symbols\", exchange)\n        symbols = _exchange_function_map[exchange](key_id) if key_id else _exchange_function_map[exchange]()\n        LOG.info(\"%s: %s symbols\", exchange, len(symbols))\n\n        # log all retrieved symbols using debug level\n        for normalized, exch_sym in sorted(symbols.items()):\n            LOG.debug('%s: id-from-exch -> normalized: %-35s-> %s', exchange, exch_sym, normalized)\n\n        _symbols_retrieval_cache[exchange] = symbols\n    return _symbols_retrieval_cache[exchange]\n\n\ndef _binance_symbols(endpoint: str, exchange: str):\n    r = None\n    try:\n        ret = {}\n        r = requests.get(endpoint)\n        for symbol in r.json()['symbols']:\n            if symbol.get('status', 'TRADING') != \"TRADING\":\n                continue\n            if symbol.get('contractStatus', 'TRADING') != \"TRADING\":\n                continue\n            split = len(symbol['baseAsset'])\n            normalized = symbol['symbol'][:split] + SYMBOL_SEP + symbol['symbol'][split:]\n            ret[normalized] = symbol['symbol']\n            _exchange_info[exchange]['tick_size'][normalized] = symbol['filters'][0]['tickSize']\n            if \"contractType\" in symbol:\n                _exchange_info[exchange]['contract_type'][normalized] = symbol['contractType']\n        return ret\n    except Exception as why:\n        raise_failure_explanation(exchange, why, {endpoint: r})\n\n\ndef binance_symbols() -> Dict[str, str]:\n    return _binance_symbols('https://api.binance.com/api/v3/exchangeInfo', BINANCE)\n\n\ndef binance_us_symbols() -> Dict[str, str]:\n    return _binance_symbols('https://api.binance.us/api/v3/exchangeInfo', BINANCE_US)\n\n\ndef binance_futures_symbols() -> Dict[str, str]:\n    base = _binance_symbols('https://fapi.binance.com/fapi/v1/exchangeInfo', BINANCE_FUTURES)\n    add = {}\n    for symbol, orig in base.items():\n        if \"_\" in orig:\n            continue\n        add[f\"{symbol}-PINDEX\"] = f\"p{orig}\"\n    base.update(add)\n    return base\n\n\ndef binance_delivery_symbols() -> Dict[str, str]:\n    return _binance_symbols('https://dapi.binance.com/dapi/v1/exchangeInfo', BINANCE_DELIVERY)\n\n\ndef bitfinex_symbols() -> Dict[str, str]:\n    # doc: https://docs.bitfinex.com/docs/ws-general#supported-pairs\n    r1 = r2 = None\n    try:\n        r1 = requests.get('https://api.bitfinex.com/v2/tickers?symbols=ALL')\n        r2 = requests.get('https://api-pub.bitfinex.com/v2/conf/pub:map:currency:sym')\n        tickers: List[List[str]] = r1.json()\n        norm: List[Tuple[str, str]] = r2.json()[0]\n        norm: Dict[str, str] = dict(norm)\n        for k, v in dict(norm).items():\n            if k[-2:] == 'F0' or '-' in v:  # Do not convert BTCF0 -> BTC or PBTCETH -> PBTC-ETH\n                del norm[k]\n        norm['BCHN'] = 'BCH'  # Bitfinex uses BCHN, other exchanges use BCH\n\n        ret = {}\n        for symbol in [t[0] for t in tickers]:\n            if symbol[0] == 'f':\n                normalized = norm.get(symbol[1:], symbol[1:])\n            else:\n                if len(symbol) == 7:\n                    base, quote = symbol[1:4], symbol[4:]\n                else:\n                    base, quote = symbol[1:].split(':')\n                    assert ':' in symbol\n                normalized = norm.get(base, base) + SYMBOL_SEP + norm.get(quote, quote)\n            ret[normalized.upper()] = symbol\n        return ret\n    except ValueError as why:\n        raise_failure_explanation('BITFINEX', why, {\"tickers?symbols=ALL\": r1, \"pub:map:currency:sym\": r2})\n\n\ndef bitflyer_symbols() -> Dict[str, str]:\n    endpoint = r = None\n    try:\n        ret = {}\n        endpoints = ['https://api.bitflyer.com/v1/getmarkets/eu', 'https://api.bitflyer.com/v1/getmarkets/usa', 'https://api.bitflyer.com/v1/getmarkets']\n        for endpoint in endpoints:\n            r = requests.get(endpoint)\n            for entry in r.json():\n                normalized = entry['product_code'].replace(\"_\", SYMBOL_SEP)\n                ret[normalized] = entry['product_code']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('BITFLYER', why, {endpoint: r})\n\n\ndef bybit_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.bybit.com/v2/public/symbols')\n        ret = {}\n        for symbol in r.json()['result']:\n            quote = symbol['quote_currency']\n            if not symbol['name'].endswith(quote):\n                base, contract = symbol['name'].split(quote)\n                normalized = f\"{base}{SYMBOL_SEP}{quote}-{contract}\"\n            else:\n                normalized = f\"{symbol['base_currency']}{SYMBOL_SEP}{quote}\"\n            ret[normalized] = symbol['name']\n            _exchange_info[BYBIT]['tick_size'][normalized] = symbol['price_filter']['tick_size']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('BYBIT', why, {\"\": r})\n\n\ndef _ftx_helper(endpoint: str, exchange: str):\n    r = None\n    try:\n        r = requests.get(endpoint)\n        ret = {}\n        for data in r.json()['result']:\n            normalized = data['name'].replace(\"/\", SYMBOL_SEP)\n            symbol = data['name']\n            ret[normalized] = symbol\n            _exchange_info[exchange]['tick_size'][normalized] = data['priceIncrement']\n        return ret\n    except Exception as why:\n        raise_failure_explanation(exchange, why, {endpoint: r})\n\n\ndef ftx_symbols() -> Dict[str, str]:\n    return _ftx_helper('https://ftx.com/api/markets', FTX)\n\n\ndef ftx_us_symbols() -> Dict[str, str]:\n    return _ftx_helper('https://ftx.us/api/markets', FTX_US)\n\n\ndef coinbase_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.pro.coinbase.com/products')\n        ret = {}\n        for data in r.json():\n            normalized = data['id'].replace(\"-\", SYMBOL_SEP)\n            ret[normalized] = data['id']\n            _exchange_info[COINBASE]['tick_size'][normalized] = data['quote_increment']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('COINBASE', why, {\"\": r})\n\n\ndef gemini_symbols(*args) -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.gemini.com/v1/symbols')\n        ret = {}\n        for symbol in r.json():\n            std = f\"{symbol[:-3]}{SYMBOL_SEP}{symbol[-3:]}\"\n            std = std.upper()\n            ret[std] = symbol.upper()\n        return ret\n    except Exception as why:\n        raise_failure_explanation('GEMINI', why, {\"\": r})\n\n\ndef hitbtc_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        ret = {}\n        r = requests.get('https://api.hitbtc.com/api/2/public/symbol')\n        for symbol in r.json():\n            split = len(symbol['baseCurrency'])\n            normalized = symbol['id'][:split] + SYMBOL_SEP + symbol['id'][split:]\n            ret[normalized] = symbol['id']\n            _exchange_info[HITBTC]['tick_size'][normalized] = symbol['tickSize']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('HITBTC', why, {\"\": r})\n\n\ndef poloniex_id_symbol_mapping():\n    r = None\n    try:\n        r = requests.get('https://poloniex.com/public?command=returnTicker')\n        symbols = r.json()\n        ret = {}\n        for symbol in symbols:\n            ret[symbols[symbol]['id']] = symbol\n        return ret\n    except Exception as why:\n        raise_failure_explanation('POLONIEX', why, {\"\": r})\n\n\ndef poloniex_symbols() -> Dict[str, str]:\n    ret = {}\n    for _, value in poloniex_id_symbol_mapping().items():\n        std = value.replace(\"STR\", \"XLM\")\n        quote, base = std.split(\"_\")\n        ret[quote + SYMBOL_SEP + base] = value\n    return ret\n\n\ndef bitstamp_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://www.bitstamp.net/api/v2/trading-pairs-info/')\n        ret = {}\n        for data in r.json():\n            normalized = data['name'].replace(\"/\", SYMBOL_SEP)\n            symbol = data['url_symbol']\n            ret[normalized] = symbol\n        return ret\n    except Exception as why:\n        raise_failure_explanation('BITSTAMP', why, {\"\": r})\n\n\ndef kraken_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.kraken.com/0/public/AssetPairs')\n        data = r.json()\n        ret = {}\n        for symbol in data['result']:\n            if 'wsname' not in data['result'][symbol] or '.d' in symbol:\n                # https://blog.kraken.com/post/259/introducing-the-kraken-dark-pool/\n                # .d is for dark pool symbols\n                continue\n\n            base, quote = data['result'][symbol]['wsname'].split(\"/\")\n\n            normalized = f\"{base}{SYMBOL_SEP}{quote}\"\n            exch = data['result'][symbol]['wsname']\n            normalized = normalized.replace('XBT', 'BTC')\n            normalized = normalized.replace('XDG', 'DOG')\n            ret[normalized] = exch\n        return ret\n    except Exception as why:\n        raise_failure_explanation('KRAKEN', why, {\"\": r})\n\n\ndef kraken_rest_symbols() -> Dict[str, str]:\n    return {normalized: exchange.replace(\"/\", \"\") for normalized, exchange in kraken_symbols().items()}\n\n\ndef exx_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.exx.com/data/v1/tickers')\n        exchange = [key.upper() for key in r.json().keys()]\n        symbols = [key.replace(\"_\", SYMBOL_SEP) for key in exchange]\n        return dict(zip(symbols, exchange))\n    except Exception as why:\n        raise_failure_explanation('EXX', why, {\"\": r})\n\n\ndef huobi_common_symbols(url: str):\n    r = None\n    try:\n        r = requests.get(url)\n        ret = {}\n        for e in r.json()['data']:\n            if e['state'] == 'offline':\n                continue\n            normalized = f\"{e['base-currency'].upper()}{SYMBOL_SEP}{e['quote-currency'].upper()}\"\n            symbol = f\"{e['base-currency']}{e['quote-currency']}\"\n            ret[normalized] = symbol\n        return ret\n    except Exception as why:\n        raise_failure_explanation('HUOBI', why, {url: r})\n\n\ndef huobi_symbols() -> Dict[str, str]:\n    return huobi_common_symbols('https://api.huobi.pro/v1/common/symbols')\n\n\ndef huobi_us_symbols() -> Dict[str, str]:\n    return huobi_common_symbols('https://api.huobi.com/v1/common/symbols')\n\n\ndef huobi_dm_symbols() -> Dict[str, str]:\n    \"\"\"\n    Mapping is, for instance: {\"BTC_CW\":\"BTC190816\"}\n    See comments in exchange/huobi_dm.py\n    \"\"\"\n    mapping = {\n        \"this_week\": \"CW\",\n        \"next_week\": \"NW\",\n        \"quarter\": \"CQ\",\n        \"next_quarter\": \"NQ\"\n    }\n    r = None\n    try:\n        r = requests.get('https://www.hbdm.com/api/v1/contract_contract_info')\n        symbols = {}\n        for e in r.json()['data']:\n            symbols[f\"{e['symbol']}_{mapping[e['contract_type']]}\"] = e['contract_code']\n            _exchange_info[HUOBI_DM]['tick_size'][e['contract_code']] = e['price_tick']\n            _exchange_info[HUOBI_DM]['short_code_mappings'][f\"{e['symbol']}_{mapping[e['contract_type']]}\"] = e['contract_code']\n        return symbols\n    except Exception as why:\n        raise_failure_explanation('HUOBI_DM', why, {\"\": r})\n\n\ndef huobi_swap_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.hbdm.com/swap-api/v1/swap_contract_info')\n        symbols = {}\n        for e in r.json()['data']:\n            symbols[e['contract_code']] = e['contract_code']\n            _exchange_info[HUOBI_SWAP]['tick_size'][e['contract_code']] = e['price_tick']\n        return symbols\n    except Exception as why:\n        raise_failure_explanation('HUOBI_SWAP', why, {\"\": r})\n\n\ndef okcoin_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://www.okcoin.com/api/spot/v3/instruments')\n        ret = {}\n        for e in r.json():\n            ret[e['instrument_id']] = e['instrument_id']\n            _exchange_info[OKCOIN]['tick_size'][e['instrument_id']] = e['tick_size']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('OKCOIN', why, {\"\": r})\n\n\ndef okex_symbols(*args) -> Dict[str, str]:\n    urls = ['https://www.okex.com/api/spot/v3/instruments',\n            'https://www.okex.com/api/swap/v3/instruments',\n            'https://www.okex.com/api/futures/v3/instruments']\n    urls = urls + okex_compute_option_urls_from_underlyings()\n\n    symbols: Dict[str, str] = {}\n    for u in urls:\n        time.sleep(0.2)\n        symbols.update(okex_symbols_from_one_url(u))\n\n    for symbol in symbols:\n        instrument_type = 'futures'\n        dash_count = symbol.count(get_symbol_separator())\n        if dash_count == 1:  # BTC-USDT\n            instrument_type = 'spot'\n        if dash_count == 4:  # BTC-USD-201225-35000-P\n            instrument_type = 'option'\n        if symbol[-4:] == \"SWAP\":  # BTC-USDT-SWAP\n            instrument_type = 'swap'\n\n        _exchange_info[OKEX]['instrument_type'][symbol] = instrument_type\n\n    return symbols\n\n\ndef okex_compute_option_urls_from_underlyings() -> List[str]:\n    url = 'https://www.okex.com/api/option/v3/underlying'\n    r = None\n    try:\n        r = requests.get(url)\n        return [f'https://www.okex.com/api/option/v3/instruments/{underlying}' for underlying in r.json()]\n    except Exception as why:\n        raise_failure_explanation('OKEX', why, {url: r})\n\n\ndef okex_symbols_from_one_url(url: str) -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get(url)\n        ret = {}\n        for e in r.json():\n            ret[e['instrument_id']] = e['instrument_id']\n            _exchange_info[OKEX]['tick_size'][e['instrument_id']] = e['tick_size']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('OKEX', why, {url: r})\n\n\ndef bittrex_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.bittrex.com/api/v1.1/public/getmarkets')\n        r = r.json()['result']\n        return {f\"{e['MarketCurrency']}{SYMBOL_SEP}{e['BaseCurrency']}\": e['MarketName'] for e in r if e['IsActive']}\n    except Exception as why:\n        raise_failure_explanation('BITTREX', why, {\"\": r})\n\n\ndef bitcoincom_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.exchange.bitcoin.com/api/2/public/symbol')\n        return {f\"{data['baseCurrency']}{SYMBOL_SEP}{data['quoteCurrency'].replace('USD', 'USDT')}\": data['id'] for data in r.json()}\n    except Exception as why:\n        raise_failure_explanation('BITCOINCOM', why, {\"\": r})\n\n\ndef bitmax_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://bitmax.io/api/pro/v1/products')\n        ret = {}\n        for entry in r.json()['data']:\n            # Only \"Normal\" status symbols are tradeable\n            if entry['status'] == 'Normal':\n                normalized = f\"{entry['baseAsset']}{SYMBOL_SEP}{entry['quoteAsset']}\"\n                ret[normalized] = entry['symbol']\n                _exchange_info[BITMAX]['tick_size'][normalized] = entry['tickSize']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('BITMAX', why, {\"\": r})\n\n\ndef upbit_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.upbit.com/v1/market/all')\n        return {f\"{data['market'].split('-')[1]}{SYMBOL_SEP}{data['market'].split('-')[0]}\": data['market'] for data in r.json()}\n    except Exception as why:\n        raise_failure_explanation('UPBIT', why, {\"\": r})\n\n\ndef blockchain_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get(\"https://api.blockchain.com/mercury-gateway/v1/instruments\")\n        return {data[\"symbol\"].replace(\"-\", SYMBOL_SEP): data[\"symbol\"] for data in r.json()}\n    except Exception as why:\n        raise_failure_explanation('BLOCKCHAIN', why, {\"\": r})\n\n\ndef gateio_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get(\"https://api.gateio.ws/api/v4/spot/currency_pairs\")\n        return {data[\"id\"].replace(\"_\", SYMBOL_SEP): data['id'] for data in r.json()}\n    except Exception as why:\n        raise_failure_explanation('GATEIO', why, {\"\": r})\n\n\ndef bitmex_symbols() -> Dict[str, str]:\n    r = None\n    ret = {}\n    try:\n        r = requests.get(\"https://www.bitmex.com/api/v1/instrument/active\")\n        for entry in r.json():\n            components = []\n            components.append(entry['rootSymbol'])\n            components.append(entry['quoteCurrency'])\n\n            if entry['expiry']:\n                components.append(entry['symbol'][-3:])\n\n            normalized = SYMBOL_SEP.join(components)\n            normalized = normalized.replace(\"XBT\", \"BTC\")\n            ret[normalized] = entry['symbol']\n            _exchange_info[BITMEX]['tick_size'][normalized] = entry['tickSize']\n\n            if entry['expiry']:\n                _exchange_info[BITMEX]['expiry'][normalized] = entry['expiry']\n\n        return ret\n    except Exception as why:\n        raise_failure_explanation('BITMEX', why, {\"\": r})\n\n\ndef deribit_symbols() -> Dict[str, str]:\n    url = r = None\n    ret = {}\n    try:\n        # TODO: get currencies from https://www.deribit.com/api/v2/public/get_currencies\n        currencies = ['BTC', 'ETH']\n        for c in currencies:\n            url = f\"https://www.deribit.com/api/v2/public/get_instruments?currency={c}&expired=false\"\n            r = requests.get(url)\n            for entry in r.json()['result']:\n                split = entry['instrument_name'].split(\"-\")\n                normalized = split[0] + SYMBOL_SEP + entry['quote_currency'] + \"-\" + '-'.join(split[1:])\n                ret[normalized] = entry['instrument_name']\n                _exchange_info[DERIBIT]['tick_size'][normalized] = entry['tick_size']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('DERIBIT', why, {url: r})\n\n\ndef kraken_future_symbols() -> Dict[str, str]:\n    r = None\n    ret = {}\n    try:\n        r = requests.get('https://futures.kraken.com/derivatives/api/v3/instruments')\n        data = r.json()['instruments']\n        for entry in data:\n            if not entry['tradeable']:\n                continue\n            normalized = entry['symbol'].upper().replace(\"_\", \"-\")\n            symbol = normalized[3:6] + SYMBOL_SEP + normalized[6:9]\n            normalized = normalized.replace(normalized[3:9], symbol)\n            normalized = normalized.replace('XBT', 'BTC')\n\n            _exchange_info[KRAKEN_FUTURES]['tick_size'][normalized] = entry['tickSize']\n            _exchange_info[KRAKEN_FUTURES]['contract_size'][normalized] = entry['contractSize']\n            _exchange_info[KRAKEN_FUTURES]['underlying'][normalized] = entry['underlying']\n            _exchange_info[KRAKEN_FUTURES]['product_type'][normalized] = _kraken_futures_product_type[normalized[:2]]\n            ret[normalized] = entry['symbol']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('KRAKEN_FUTURES', why, {\"\": r})\n\n\ndef probit_symbols() -> Dict[str, str]:\n    # doc: https://docs-en.probit.com/reference-link/market\n    r = None\n    try:\n        r = requests.get('https://api.probit.com/api/exchange/v1/market')\n        return {entry['id']: entry['id'] for entry in r.json()['data']}\n    except Exception as why:\n        raise_failure_explanation('PROBIT', why, {\"\": r})\n\n\ndef coingecko_normalize_symbol(symbol: str) -> str:\n    # keep digits, letters and dots, replace others by space\n    symbol = ''.join(c if c.isalnum() or c in ('.', '+') else ' ' for c in symbol)\n    return coingecko_normalize(symbol.upper())\n\n\ndef coingecko_normalize_name(name: str) -> str:\n    # keep digits and letters, replace others by space (except when only composed by upper case letters, digits and dots)\n    if not all(c.isupper() or c.isdigit() or c == '.' for c in name):\n        name = ''.join(c if c.isalnum() else ' ' for c in name)\n    return coingecko_normalize(name)\n\n\ndef coingecko_normalize(sym: str) -> str:\n    sym = sym.strip()\n    # do not concatenate numbers => separate them with a dot\n    sym = list(sym)\n    if len(sym) > 4:\n        for i in range(2, len(sym) - 1):\n            if sym[i] == ' ' and sym[i - 1].isdigit() and sym[i + 1].isdigit():\n                sym[i] = '.'\n    sym = ''.join(sym)\n    # concatenate space-separated words => use CamelCase to distinguish the words\n    if ' ' in sym:\n        if sum(c.islower() for c in sym):  # if there is at least one lower case letter\n            sym = ' '.join(word[0].upper() + word[1:] for word in sym.split())  # Just capitalize initial letter of each word\n        else:  # CoinGecko may provide full upper-case as for \"THE STONE COIN\"\n            sym = string.capwords(sym)  # capwords converts \"THE STONE COIN\" to \"The Stone Coin\"\n        sym = sym.replace(' ', '')  # concatenate words\n    return sym\n\n\ndef is_name_short(coin: dict) -> bool:\n    \"\"\"return True if the coin name is enough short compared to the coin symbol.\"\"\"\n    return len(coin['name']) <= max(5, len(coin['symbol']) + 1)\n\n\ndef has_many_caps(name: str) -> bool:\n    \"\"\"return True if the symbol contains enough upper case letters, False if empty.\"\"\"\n    return str and sum(c.islower() for c in name) < (len(name) / 2)\n\n\ndef coingecko_normalize_all(coin: dict):\n    SYMBOL_TO_NORMALIZED = {'miota': 'IOTA'}\n    normalized = SYMBOL_TO_NORMALIZED.get(coin['symbol'])\n    if normalized:\n        coin['ns'] = coin['nn'] = normalized\n        return normalized\n\n    # ns = normalized symbol, nn = normalized name\n    coin['ns'] = coingecko_normalize_symbol(coin['symbol'])\n\n    ID_SUFFIX = '-bitcoin-token'\n    if coin['id'][-len(ID_SUFFIX):] == ID_SUFFIX:\n        coin['nn'] = 'BTC' + coin['ns']\n        return coin['nn']\n\n    name = coin['name']\n\n    prefixes = ('The ', 'the ')\n    for p in prefixes:\n        if name[:len(p)] == p:\n            coin['reduced-name'] = True\n            name = name[len(p):]\n            break\n\n    suffixes = ('coin', 'coins', 'money', 'finance', 'protocol', 'reward', 'rewards', 'token')\n    for s in suffixes:\n        if len(name) > len(s) and name[-len(s):].lower() == s:\n            # but keep suffix when lower-case concatenated\n            if name[-len(s)].islower() and name[-len(s) - 1] != ' ':\n                continue\n            # also keep suffix to avoid confusing nam: \"Bitcoin Token\" -> \"Bitcoin\"\n            if name[:-len(s)].strip().lower() == 'bitcoin':\n                continue\n            coin['reduced-name'] = True\n            name = name[:-len(s)]\n            break\n\n    coin['nn'] = coingecko_normalize_name(name)\n\n    if len(coin['nn']) < len(coin['ns']):\n        if 'reduced-name' in coin:\n            coin['reduced-name'] = False\n            name = coin['name']\n            coin['nn'] = coingecko_normalize_name(name)\n        elif not has_many_caps(name):\n            return coin['ns']\n\n    if not coin['ns']:  # coin['symbol'] may be an emoji that is striped when normalized\n        return coin['nn']\n\n    if coin.get('reduced-name') and coin['ns'].upper() != coin['nn'].upper():\n        return coin['ns']\n\n    i = coin['nn'].find('.')  # if there is a dot in normalized name => prefer the normalized symbol\n    if i >= 0:\n        if i > 1 and coin['nn'][i - 1].isdigit() and coin['nn'][i + 1].isdigit():\n            pass  # except when the dot separates digits\n        else:\n            return coin['ns']\n\n    if is_name_short(coin) and has_many_caps(name):\n        return coin['nn']\n\n    if 1.5 * len(coin['ns']) > len(coin['nn']) and any(c.islower() for c in coin['ns']):\n        return coin['nn']\n\n    return coin['ns']\n\n\ndef coingecko_symbols() -> Dict[str, str]:\n    r = None\n    intermediate = defaultdict(list)\n    try:\n        r = requests.get('https://api.coingecko.com/api/v3/coins/list')\n        all_coins = r.json()\n        # First pass: generate & compare normalized symbol/name, and then select the most pertinent\n        for coin in all_coins:\n            normalized = coingecko_normalize_all(coin)\n            intermediate[normalized].append(coin)\n            # Above line keeps together the coins having the same normalized symbol.\n            # To reduce collision, the coin['name'] is sometimes used in lieu of the coin['symbol'].\n            # The coin['name'] is not capitalized because lower case letters may be meaningful: cETH, yUSD, DATx, zLOT\n    except Exception as why:\n        raise_failure_explanation('COINGECKO', why, {\"\": r})\n\n    final = coingecko_second_pass(intermediate)\n    return coingecko_third_pass(final)\n\n\ndef coingecko_second_pass(intermediate: Dict[str, List[dict]]) -> Dict[str, List[dict]]:\n    # Second pass: fixes most of the symbol collisions\n    final = defaultdict(list)\n    for normalized, coins in intermediate.items():\n        if len(coins) == 1:\n            final[normalized].append(coins[0])\n            continue\n        set_normalized = False\n        for i in range(len(coins)):\n            if normalized == coins[i]['nn']:\n                coin = coins.pop(i)\n                final[normalized].append(coin)\n                set_normalized = True\n                break\n        rest: List[dict] = []\n        for coin in coins:\n            if '%' in coin['name']:\n                if len(coins) == 1:\n                    n = coin['ns']\n                else:\n                    n = coingecko_normalize_name(coin['id'])\n                final[n].append(coin)\n            else:\n                rest.append(coin)\n        if not rest:\n            continue\n        if not set_normalized:\n            rest.sort(key=lambda coin: len(coin['nn']), reverse=True)  # sort by the length of the normalized name\n            coin = rest.pop(0)\n            final[normalized].append(coin)\n        for coin in rest:\n            if coin['nn'] not in intermediate:\n                n = coin['nn']\n            elif coin.get('reduced-name'):\n                n = coingecko_normalize_name(coin['name'])\n            else:\n                n = coingecko_normalize_name(coin['id'])\n            final[n].append(coin)\n    return final\n\n\ndef coingecko_third_pass(final: Dict[str, List[dict]]) -> Dict[str, str]:\n    # Third pass: fixes some remaining collisions and fills the result\n    symbols = {}\n    for normalized, coins in final.items():\n        if len(coins) == 1:\n            symbols[normalized] = coins[0]['id']\n            continue\n        set_normalized = False\n        for i in range(len(coins)):\n            if normalized == coins[i]['nn']:\n                coin = coins.pop(i)\n                symbols[normalized] = coin['id']\n                set_normalized = True\n                break\n        rest: List[dict] = []\n        for coin in coins:\n            if '%' in coin['name']:\n                if len(coins) == 1:\n                    n = coin['ns']\n                else:\n                    n = coingecko_normalize_name(coin['id'])\n                symbols[n] = coin['id']\n            else:\n                rest.append(coin)\n        if not rest:\n            continue\n        if not set_normalized:\n            rest.sort(key=lambda coin: len(coin['nn']), reverse=True)  # sort by the length of the normalized name\n            coin = rest.pop(0)\n            symbols[normalized] = coin['id']\n        for coin in rest:\n            if coin['nn'] not in final:\n                n = coin['nn']\n            elif coin.get('reduced-name'):\n                n = coingecko_normalize_name(coin['name'])\n            else:\n                n = coingecko_normalize_name(coin['id'])\n            symbols[n] = coin['id']\n    return symbols\n\n\ndef whale_alert_coins(key_id: str) -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get(f'https://api.whale-alert.io/v1/status?api_key={key_id}')\n        # Same symbols, but on different blockchains (for instance USDT), are naturally overwritten.\n        return {s.upper(): s for b in r.json()['blockchains'] for s in b['symbols'] if s}\n    except Exception as why:\n        raise_failure_explanation('WHALES_ALERT', why, {\"\": r})\n\n\n_exchange_function_map = {\n    BITFINEX: bitfinex_symbols,\n    BITFLYER: bitflyer_symbols,\n    COINBASE: coinbase_symbols,\n    GEMINI: gemini_symbols,\n    HITBTC: hitbtc_symbols,\n    POLONIEX: poloniex_symbols,\n    PROBIT: probit_symbols,\n    BITSTAMP: bitstamp_symbols,\n    KRAKEN: kraken_symbols,\n    KRAKEN + 'REST': kraken_rest_symbols,\n    BINANCE: binance_symbols,\n    BINANCE_US: binance_us_symbols,\n    BINANCE_FUTURES: binance_futures_symbols,\n    BINANCE_DELIVERY: binance_delivery_symbols,\n    BLOCKCHAIN: blockchain_symbols,\n    EXX: exx_symbols,\n    HUOBI: huobi_symbols,\n    HUOBI_DM: huobi_dm_symbols,\n    HUOBI_SWAP: huobi_swap_symbols,\n    OKCOIN: okcoin_symbols,\n    OKEX: okex_symbols,\n    BYBIT: bybit_symbols,\n    FTX: ftx_symbols,\n    FTX_US: ftx_us_symbols,\n    BITTREX: bittrex_symbols,\n    BITCOINCOM: bitcoincom_symbols,\n    BITMAX: bitmax_symbols,\n    UPBIT: upbit_symbols,\n    GATEIO: gateio_symbols,\n    BITMEX: bitmex_symbols,\n    DERIBIT: deribit_symbols,\n    KRAKEN_FUTURES: kraken_future_symbols,\n    COINGECKO: coingecko_symbols,\n    WHALE_ALERT: whale_alert_coins\n}\n",
        "source_code_len": 30534,
        "target_code": "associated with this software.\n'''\nfrom typing import Dict, Tuple\n\n\nclass _Symbols:\n    def __init__(self):\n        self.data = {}\n\n    def set(self, exchange: str, normalized: dict, exchange_info: dict):\n        self.data[exchange] = {}\n        self.data[exchange]['normalized'] = normalized\n        self.data[exchange]['info'] = exchange_info\n\n    def get(self, exchange: str) -> Tuple[Dict, Dict]:\n        return self.data[exchange]['normalized'], self.data[exchange]['info']\n\n    def populated(self, exchange: str) -> bool:\n        return exchange in self.data\n\n\nSymbols = _Symbols()\n",
        "target_code_len": 588,
        "diff_format": "@@ -5,845 +5,22 @@\n associated with this software.\n+'''\n+from typing import Dict, Tuple\n \n \n-Symbol generation code for exchanges\n-'''\n+class _Symbols:\n+    def __init__(self):\n+        self.data = {}\n \n-import logging\n-import string\n-import time\n-from collections import defaultdict\n-from typing import Dict, List, Optional, Tuple\n+    def set(self, exchange: str, normalized: dict, exchange_info: dict):\n+        self.data[exchange] = {}\n+        self.data[exchange]['normalized'] = normalized\n+        self.data[exchange]['info'] = exchange_info\n \n-import requests\n-from requests import Response\n+    def get(self, exchange: str) -> Tuple[Dict, Dict]:\n+        return self.data[exchange]['normalized'], self.data[exchange]['info']\n \n-from cryptofeed.defines import *\n+    def populated(self, exchange: str) -> bool:\n+        return exchange in self.data\n \n \n-LOG = logging.getLogger('feedhandler')\n-\n-SYMBOL_SEP = '-'\n-\n-_symbols_retrieval_cache: Dict[str, Dict[str, str]] = {}\n-_exchange_info = defaultdict(lambda: defaultdict(dict))\n-\n-\n-_kraken_futures_product_type = {\n-    'FI': 'Inverse Futures',\n-    'FV': 'Vanilla Futures',\n-    'PI': 'Perpetual Inverse Futures',\n-    'PV': 'Perpetual Vanilla Futures',\n-    'IN': 'Real Time Index',\n-    'RR': 'Reference Rate',\n-}\n-\n-\n-def raise_failure_explanation(feed_id: str, exception: BaseException, responses: Dict[str, Optional[Response]]):\n-    LOG.critical('%s: encountered %r while processing response from exchange API', feed_id, exception)\n-    if len(responses) > 1:\n-        LOG.critical('%s: content of one of the %s responses was unexpected', feed_id, len(responses))\n-    for url, r in responses.items():\n-        if url:\n-            LOG.critical('%s: requested URL: %s', feed_id, url)\n-        if r:\n-            LOG.critical('%s: unexpected response: %s', feed_id, r.text)\n-    raise ValueError(f'Cryptofeed stopped because of an unexpected response from {feed_id}') from exception\n-\n-\n-def set_symbol_separator(separator: str):\n-    global SYMBOL_SEP\n-    SYMBOL_SEP = separator\n-\n-\n-def get_symbol_separator() -> str:\n-    global SYMBOL_SEP\n-    return SYMBOL_SEP\n-\n-\n-def gen_symbols(exchange: str, key_id=None) -> Dict[str, str]:\n-    if exchange not in _symbols_retrieval_cache:\n-        LOG.info(\"%s: Getting list of symbols\", exchange)\n-        symbols = _exchange_function_map[exchange](key_id) if key_id else _exchange_function_map[exchange]()\n-        LOG.info(\"%s: %s symbols\", exchange, len(symbols))\n-\n-        # log all retrieved symbols using debug level\n-        for normalized, exch_sym in sorted(symbols.items()):\n-            LOG.debug('%s: id-from-exch -> normalized: %-35s-> %s', exchange, exch_sym, normalized)\n-\n-        _symbols_retrieval_cache[exchange] = symbols\n-    return _symbols_retrieval_cache[exchange]\n-\n-\n-def _binance_symbols(endpoint: str, exchange: str):\n-    r = None\n-    try:\n-        ret = {}\n-        r = requests.get(endpoint)\n-        for symbol in r.json()['symbols']:\n-            if symbol.get('status', 'TRADING') != \"TRADING\":\n-                continue\n-            if symbol.get('contractStatus', 'TRADING') != \"TRADING\":\n-                continue\n-            split = len(symbol['baseAsset'])\n-            normalized = symbol['symbol'][:split] + SYMBOL_SEP + symbol['symbol'][split:]\n-            ret[normalized] = symbol['symbol']\n-            _exchange_info[exchange]['tick_size'][normalized] = symbol['filters'][0]['tickSize']\n-            if \"contractType\" in symbol:\n-                _exchange_info[exchange]['contract_type'][normalized] = symbol['contractType']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation(exchange, why, {endpoint: r})\n-\n-\n-def binance_symbols() -> Dict[str, str]:\n-    return _binance_symbols('https://api.binance.com/api/v3/exchangeInfo', BINANCE)\n-\n-\n-def binance_us_symbols() -> Dict[str, str]:\n-    return _binance_symbols('https://api.binance.us/api/v3/exchangeInfo', BINANCE_US)\n-\n-\n-def binance_futures_symbols() -> Dict[str, str]:\n-    base = _binance_symbols('https://fapi.binance.com/fapi/v1/exchangeInfo', BINANCE_FUTURES)\n-    add = {}\n-    for symbol, orig in base.items():\n-        if \"_\" in orig:\n-            continue\n-        add[f\"{symbol}-PINDEX\"] = f\"p{orig}\"\n-    base.update(add)\n-    return base\n-\n-\n-def binance_delivery_symbols() -> Dict[str, str]:\n-    return _binance_symbols('https://dapi.binance.com/dapi/v1/exchangeInfo', BINANCE_DELIVERY)\n-\n-\n-def bitfinex_symbols() -> Dict[str, str]:\n-    # doc: https://docs.bitfinex.com/docs/ws-general#supported-pairs\n-    r1 = r2 = None\n-    try:\n-        r1 = requests.get('https://api.bitfinex.com/v2/tickers?symbols=ALL')\n-        r2 = requests.get('https://api-pub.bitfinex.com/v2/conf/pub:map:currency:sym')\n-        tickers: List[List[str]] = r1.json()\n-        norm: List[Tuple[str, str]] = r2.json()[0]\n-        norm: Dict[str, str] = dict(norm)\n-        for k, v in dict(norm).items():\n-            if k[-2:] == 'F0' or '-' in v:  # Do not convert BTCF0 -> BTC or PBTCETH -> PBTC-ETH\n-                del norm[k]\n-        norm['BCHN'] = 'BCH'  # Bitfinex uses BCHN, other exchanges use BCH\n-\n-        ret = {}\n-        for symbol in [t[0] for t in tickers]:\n-            if symbol[0] == 'f':\n-                normalized = norm.get(symbol[1:], symbol[1:])\n-            else:\n-                if len(symbol) == 7:\n-                    base, quote = symbol[1:4], symbol[4:]\n-                else:\n-                    base, quote = symbol[1:].split(':')\n-                    assert ':' in symbol\n-                normalized = norm.get(base, base) + SYMBOL_SEP + norm.get(quote, quote)\n-            ret[normalized.upper()] = symbol\n-        return ret\n-    except ValueError as why:\n-        raise_failure_explanation('BITFINEX', why, {\"tickers?symbols=ALL\": r1, \"pub:map:currency:sym\": r2})\n-\n-\n-def bitflyer_symbols() -> Dict[str, str]:\n-    endpoint = r = None\n-    try:\n-        ret = {}\n-        endpoints = ['https://api.bitflyer.com/v1/getmarkets/eu', 'https://api.bitflyer.com/v1/getmarkets/usa', 'https://api.bitflyer.com/v1/getmarkets']\n-        for endpoint in endpoints:\n-            r = requests.get(endpoint)\n-            for entry in r.json():\n-                normalized = entry['product_code'].replace(\"_\", SYMBOL_SEP)\n-                ret[normalized] = entry['product_code']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('BITFLYER', why, {endpoint: r})\n-\n-\n-def bybit_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.bybit.com/v2/public/symbols')\n-        ret = {}\n-        for symbol in r.json()['result']:\n-            quote = symbol['quote_currency']\n-            if not symbol['name'].endswith(quote):\n-                base, contract = symbol['name'].split(quote)\n-                normalized = f\"{base}{SYMBOL_SEP}{quote}-{contract}\"\n-            else:\n-                normalized = f\"{symbol['base_currency']}{SYMBOL_SEP}{quote}\"\n-            ret[normalized] = symbol['name']\n-            _exchange_info[BYBIT]['tick_size'][normalized] = symbol['price_filter']['tick_size']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('BYBIT', why, {\"\": r})\n-\n-\n-def _ftx_helper(endpoint: str, exchange: str):\n-    r = None\n-    try:\n-        r = requests.get(endpoint)\n-        ret = {}\n-        for data in r.json()['result']:\n-            normalized = data['name'].replace(\"/\", SYMBOL_SEP)\n-            symbol = data['name']\n-            ret[normalized] = symbol\n-            _exchange_info[exchange]['tick_size'][normalized] = data['priceIncrement']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation(exchange, why, {endpoint: r})\n-\n-\n-def ftx_symbols() -> Dict[str, str]:\n-    return _ftx_helper('https://ftx.com/api/markets', FTX)\n-\n-\n-def ftx_us_symbols() -> Dict[str, str]:\n-    return _ftx_helper('https://ftx.us/api/markets', FTX_US)\n-\n-\n-def coinbase_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.pro.coinbase.com/products')\n-        ret = {}\n-        for data in r.json():\n-            normalized = data['id'].replace(\"-\", SYMBOL_SEP)\n-            ret[normalized] = data['id']\n-            _exchange_info[COINBASE]['tick_size'][normalized] = data['quote_increment']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('COINBASE', why, {\"\": r})\n-\n-\n-def gemini_symbols(*args) -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.gemini.com/v1/symbols')\n-        ret = {}\n-        for symbol in r.json():\n-            std = f\"{symbol[:-3]}{SYMBOL_SEP}{symbol[-3:]}\"\n-            std = std.upper()\n-            ret[std] = symbol.upper()\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('GEMINI', why, {\"\": r})\n-\n-\n-def hitbtc_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        ret = {}\n-        r = requests.get('https://api.hitbtc.com/api/2/public/symbol')\n-        for symbol in r.json():\n-            split = len(symbol['baseCurrency'])\n-            normalized = symbol['id'][:split] + SYMBOL_SEP + symbol['id'][split:]\n-            ret[normalized] = symbol['id']\n-            _exchange_info[HITBTC]['tick_size'][normalized] = symbol['tickSize']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('HITBTC', why, {\"\": r})\n-\n-\n-def poloniex_id_symbol_mapping():\n-    r = None\n-    try:\n-        r = requests.get('https://poloniex.com/public?command=returnTicker')\n-        symbols = r.json()\n-        ret = {}\n-        for symbol in symbols:\n-            ret[symbols[symbol]['id']] = symbol\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('POLONIEX', why, {\"\": r})\n-\n-\n-def poloniex_symbols() -> Dict[str, str]:\n-    ret = {}\n-    for _, value in poloniex_id_symbol_mapping().items():\n-        std = value.replace(\"STR\", \"XLM\")\n-        quote, base = std.split(\"_\")\n-        ret[quote + SYMBOL_SEP + base] = value\n-    return ret\n-\n-\n-def bitstamp_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://www.bitstamp.net/api/v2/trading-pairs-info/')\n-        ret = {}\n-        for data in r.json():\n-            normalized = data['name'].replace(\"/\", SYMBOL_SEP)\n-            symbol = data['url_symbol']\n-            ret[normalized] = symbol\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('BITSTAMP', why, {\"\": r})\n-\n-\n-def kraken_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.kraken.com/0/public/AssetPairs')\n-        data = r.json()\n-        ret = {}\n-        for symbol in data['result']:\n-            if 'wsname' not in data['result'][symbol] or '.d' in symbol:\n-                # https://blog.kraken.com/post/259/introducing-the-kraken-dark-pool/\n-                # .d is for dark pool symbols\n-                continue\n-\n-            base, quote = data['result'][symbol]['wsname'].split(\"/\")\n-\n-            normalized = f\"{base}{SYMBOL_SEP}{quote}\"\n-            exch = data['result'][symbol]['wsname']\n-            normalized = normalized.replace('XBT', 'BTC')\n-            normalized = normalized.replace('XDG', 'DOG')\n-            ret[normalized] = exch\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('KRAKEN', why, {\"\": r})\n-\n-\n-def kraken_rest_symbols() -> Dict[str, str]:\n-    return {normalized: exchange.replace(\"/\", \"\") for normalized, exchange in kraken_symbols().items()}\n-\n-\n-def exx_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.exx.com/data/v1/tickers')\n-        exchange = [key.upper() for key in r.json().keys()]\n-        symbols = [key.replace(\"_\", SYMBOL_SEP) for key in exchange]\n-        return dict(zip(symbols, exchange))\n-    except Exception as why:\n-        raise_failure_explanation('EXX', why, {\"\": r})\n-\n-\n-def huobi_common_symbols(url: str):\n-    r = None\n-    try:\n-        r = requests.get(url)\n-        ret = {}\n-        for e in r.json()['data']:\n-            if e['state'] == 'offline':\n-                continue\n-            normalized = f\"{e['base-currency'].upper()}{SYMBOL_SEP}{e['quote-currency'].upper()}\"\n-            symbol = f\"{e['base-currency']}{e['quote-currency']}\"\n-            ret[normalized] = symbol\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('HUOBI', why, {url: r})\n-\n-\n-def huobi_symbols() -> Dict[str, str]:\n-    return huobi_common_symbols('https://api.huobi.pro/v1/common/symbols')\n-\n-\n-def huobi_us_symbols() -> Dict[str, str]:\n-    return huobi_common_symbols('https://api.huobi.com/v1/common/symbols')\n-\n-\n-def huobi_dm_symbols() -> Dict[str, str]:\n-    \"\"\"\n-    Mapping is, for instance: {\"BTC_CW\":\"BTC190816\"}\n-    See comments in exchange/huobi_dm.py\n-    \"\"\"\n-    mapping = {\n-        \"this_week\": \"CW\",\n-        \"next_week\": \"NW\",\n-        \"quarter\": \"CQ\",\n-        \"next_quarter\": \"NQ\"\n-    }\n-    r = None\n-    try:\n-        r = requests.get('https://www.hbdm.com/api/v1/contract_contract_info')\n-        symbols = {}\n-        for e in r.json()['data']:\n-            symbols[f\"{e['symbol']}_{mapping[e['contract_type']]}\"] = e['contract_code']\n-            _exchange_info[HUOBI_DM]['tick_size'][e['contract_code']] = e['price_tick']\n-            _exchange_info[HUOBI_DM]['short_code_mappings'][f\"{e['symbol']}_{mapping[e['contract_type']]}\"] = e['contract_code']\n-        return symbols\n-    except Exception as why:\n-        raise_failure_explanation('HUOBI_DM', why, {\"\": r})\n-\n-\n-def huobi_swap_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.hbdm.com/swap-api/v1/swap_contract_info')\n-        symbols = {}\n-        for e in r.json()['data']:\n-            symbols[e['contract_code']] = e['contract_code']\n-            _exchange_info[HUOBI_SWAP]['tick_size'][e['contract_code']] = e['price_tick']\n-        return symbols\n-    except Exception as why:\n-        raise_failure_explanation('HUOBI_SWAP', why, {\"\": r})\n-\n-\n-def okcoin_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://www.okcoin.com/api/spot/v3/instruments')\n-        ret = {}\n-        for e in r.json():\n-            ret[e['instrument_id']] = e['instrument_id']\n-            _exchange_info[OKCOIN]['tick_size'][e['instrument_id']] = e['tick_size']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('OKCOIN', why, {\"\": r})\n-\n-\n-def okex_symbols(*args) -> Dict[str, str]:\n-    urls = ['https://www.okex.com/api/spot/v3/instruments',\n-            'https://www.okex.com/api/swap/v3/instruments',\n-            'https://www.okex.com/api/futures/v3/instruments']\n-    urls = urls + okex_compute_option_urls_from_underlyings()\n-\n-    symbols: Dict[str, str] = {}\n-    for u in urls:\n-        time.sleep(0.2)\n-        symbols.update(okex_symbols_from_one_url(u))\n-\n-    for symbol in symbols:\n-        instrument_type = 'futures'\n-        dash_count = symbol.count(get_symbol_separator())\n-        if dash_count == 1:  # BTC-USDT\n-            instrument_type = 'spot'\n-        if dash_count == 4:  # BTC-USD-201225-35000-P\n-            instrument_type = 'option'\n-        if symbol[-4:] == \"SWAP\":  # BTC-USDT-SWAP\n-            instrument_type = 'swap'\n-\n-        _exchange_info[OKEX]['instrument_type'][symbol] = instrument_type\n-\n-    return symbols\n-\n-\n-def okex_compute_option_urls_from_underlyings() -> List[str]:\n-    url = 'https://www.okex.com/api/option/v3/underlying'\n-    r = None\n-    try:\n-        r = requests.get(url)\n-        return [f'https://www.okex.com/api/option/v3/instruments/{underlying}' for underlying in r.json()]\n-    except Exception as why:\n-        raise_failure_explanation('OKEX', why, {url: r})\n-\n-\n-def okex_symbols_from_one_url(url: str) -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get(url)\n-        ret = {}\n-        for e in r.json():\n-            ret[e['instrument_id']] = e['instrument_id']\n-            _exchange_info[OKEX]['tick_size'][e['instrument_id']] = e['tick_size']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('OKEX', why, {url: r})\n-\n-\n-def bittrex_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.bittrex.com/api/v1.1/public/getmarkets')\n-        r = r.json()['result']\n-        return {f\"{e['MarketCurrency']}{SYMBOL_SEP}{e['BaseCurrency']}\": e['MarketName'] for e in r if e['IsActive']}\n-    except Exception as why:\n-        raise_failure_explanation('BITTREX', why, {\"\": r})\n-\n-\n-def bitcoincom_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.exchange.bitcoin.com/api/2/public/symbol')\n-        return {f\"{data['baseCurrency']}{SYMBOL_SEP}{data['quoteCurrency'].replace('USD', 'USDT')}\": data['id'] for data in r.json()}\n-    except Exception as why:\n-        raise_failure_explanation('BITCOINCOM', why, {\"\": r})\n-\n-\n-def bitmax_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://bitmax.io/api/pro/v1/products')\n-        ret = {}\n-        for entry in r.json()['data']:\n-            # Only \"Normal\" status symbols are tradeable\n-            if entry['status'] == 'Normal':\n-                normalized = f\"{entry['baseAsset']}{SYMBOL_SEP}{entry['quoteAsset']}\"\n-                ret[normalized] = entry['symbol']\n-                _exchange_info[BITMAX]['tick_size'][normalized] = entry['tickSize']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('BITMAX', why, {\"\": r})\n-\n-\n-def upbit_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.upbit.com/v1/market/all')\n-        return {f\"{data['market'].split('-')[1]}{SYMBOL_SEP}{data['market'].split('-')[0]}\": data['market'] for data in r.json()}\n-    except Exception as why:\n-        raise_failure_explanation('UPBIT', why, {\"\": r})\n-\n-\n-def blockchain_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get(\"https://api.blockchain.com/mercury-gateway/v1/instruments\")\n-        return {data[\"symbol\"].replace(\"-\", SYMBOL_SEP): data[\"symbol\"] for data in r.json()}\n-    except Exception as why:\n-        raise_failure_explanation('BLOCKCHAIN', why, {\"\": r})\n-\n-\n-def gateio_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get(\"https://api.gateio.ws/api/v4/spot/currency_pairs\")\n-        return {data[\"id\"].replace(\"_\", SYMBOL_SEP): data['id'] for data in r.json()}\n-    except Exception as why:\n-        raise_failure_explanation('GATEIO', why, {\"\": r})\n-\n-\n-def bitmex_symbols() -> Dict[str, str]:\n-    r = None\n-    ret = {}\n-    try:\n-        r = requests.get(\"https://www.bitmex.com/api/v1/instrument/active\")\n-        for entry in r.json():\n-            components = []\n-            components.append(entry['rootSymbol'])\n-            components.append(entry['quoteCurrency'])\n-\n-            if entry['expiry']:\n-                components.append(entry['symbol'][-3:])\n-\n-            normalized = SYMBOL_SEP.join(components)\n-            normalized = normalized.replace(\"XBT\", \"BTC\")\n-            ret[normalized] = entry['symbol']\n-            _exchange_info[BITMEX]['tick_size'][normalized] = entry['tickSize']\n-\n-            if entry['expiry']:\n-                _exchange_info[BITMEX]['expiry'][normalized] = entry['expiry']\n-\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('BITMEX', why, {\"\": r})\n-\n-\n-def deribit_symbols() -> Dict[str, str]:\n-    url = r = None\n-    ret = {}\n-    try:\n-        # TODO: get currencies from https://www.deribit.com/api/v2/public/get_currencies\n-        currencies = ['BTC', 'ETH']\n-        for c in currencies:\n-            url = f\"https://www.deribit.com/api/v2/public/get_instruments?currency={c}&expired=false\"\n-            r = requests.get(url)\n-            for entry in r.json()['result']:\n-                split = entry['instrument_name'].split(\"-\")\n-                normalized = split[0] + SYMBOL_SEP + entry['quote_currency'] + \"-\" + '-'.join(split[1:])\n-                ret[normalized] = entry['instrument_name']\n-                _exchange_info[DERIBIT]['tick_size'][normalized] = entry['tick_size']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('DERIBIT', why, {url: r})\n-\n-\n-def kraken_future_symbols() -> Dict[str, str]:\n-    r = None\n-    ret = {}\n-    try:\n-        r = requests.get('https://futures.kraken.com/derivatives/api/v3/instruments')\n-        data = r.json()['instruments']\n-        for entry in data:\n-            if not entry['tradeable']:\n-                continue\n-            normalized = entry['symbol'].upper().replace(\"_\", \"-\")\n-            symbol = normalized[3:6] + SYMBOL_SEP + normalized[6:9]\n-            normalized = normalized.replace(normalized[3:9], symbol)\n-            normalized = normalized.replace('XBT', 'BTC')\n-\n-            _exchange_info[KRAKEN_FUTURES]['tick_size'][normalized] = entry['tickSize']\n-            _exchange_info[KRAKEN_FUTURES]['contract_size'][normalized] = entry['contractSize']\n-            _exchange_info[KRAKEN_FUTURES]['underlying'][normalized] = entry['underlying']\n-            _exchange_info[KRAKEN_FUTURES]['product_type'][normalized] = _kraken_futures_product_type[normalized[:2]]\n-            ret[normalized] = entry['symbol']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('KRAKEN_FUTURES', why, {\"\": r})\n-\n-\n-def probit_symbols() -> Dict[str, str]:\n-    # doc: https://docs-en.probit.com/reference-link/market\n-    r = None\n-    try:\n-        r = requests.get('https://api.probit.com/api/exchange/v1/market')\n-        return {entry['id']: entry['id'] for entry in r.json()['data']}\n-    except Exception as why:\n-        raise_failure_explanation('PROBIT', why, {\"\": r})\n-\n-\n-def coingecko_normalize_symbol(symbol: str) -> str:\n-    # keep digits, letters and dots, replace others by space\n-    symbol = ''.join(c if c.isalnum() or c in ('.', '+') else ' ' for c in symbol)\n-    return coingecko_normalize(symbol.upper())\n-\n-\n-def coingecko_normalize_name(name: str) -> str:\n-    # keep digits and letters, replace others by space (except when only composed by upper case letters, digits and dots)\n-    if not all(c.isupper() or c.isdigit() or c == '.' for c in name):\n-        name = ''.join(c if c.isalnum() else ' ' for c in name)\n-    return coingecko_normalize(name)\n-\n-\n-def coingecko_normalize(sym: str) -> str:\n-    sym = sym.strip()\n-    # do not concatenate numbers => separate them with a dot\n-    sym = list(sym)\n-    if len(sym) > 4:\n-        for i in range(2, len(sym) - 1):\n-            if sym[i] == ' ' and sym[i - 1].isdigit() and sym[i + 1].isdigit():\n-                sym[i] = '.'\n-    sym = ''.join(sym)\n-    # concatenate space-separated words => use CamelCase to distinguish the words\n-    if ' ' in sym:\n-        if sum(c.islower() for c in sym):  # if there is at least one lower case letter\n-            sym = ' '.join(word[0].upper() + word[1:] for word in sym.split())  # Just capitalize initial letter of each word\n-        else:  # CoinGecko may provide full upper-case as for \"THE STONE COIN\"\n-            sym = string.capwords(sym)  # capwords converts \"THE STONE COIN\" to \"The Stone Coin\"\n-        sym = sym.replace(' ', '')  # concatenate words\n-    return sym\n-\n-\n-def is_name_short(coin: dict) -> bool:\n-    \"\"\"return True if the coin name is enough short compared to the coin symbol.\"\"\"\n-    return len(coin['name']) <= max(5, len(coin['symbol']) + 1)\n-\n-\n-def has_many_caps(name: str) -> bool:\n-    \"\"\"return True if the symbol contains enough upper case letters, False if empty.\"\"\"\n-    return str and sum(c.islower() for c in name) < (len(name) / 2)\n-\n-\n-def coingecko_normalize_all(coin: dict):\n-    SYMBOL_TO_NORMALIZED = {'miota': 'IOTA'}\n-    normalized = SYMBOL_TO_NORMALIZED.get(coin['symbol'])\n-    if normalized:\n-        coin['ns'] = coin['nn'] = normalized\n-        return normalized\n-\n-    # ns = normalized symbol, nn = normalized name\n-    coin['ns'] = coingecko_normalize_symbol(coin['symbol'])\n-\n-    ID_SUFFIX = '-bitcoin-token'\n-    if coin['id'][-len(ID_SUFFIX):] == ID_SUFFIX:\n-        coin['nn'] = 'BTC' + coin['ns']\n-        return coin['nn']\n-\n-    name = coin['name']\n-\n-    prefixes = ('The ', 'the ')\n-    for p in prefixes:\n-        if name[:len(p)] == p:\n-            coin['reduced-name'] = True\n-            name = name[len(p):]\n-            break\n-\n-    suffixes = ('coin', 'coins', 'money', 'finance', 'protocol', 'reward', 'rewards', 'token')\n-    for s in suffixes:\n-        if len(name) > len(s) and name[-len(s):].lower() == s:\n-            # but keep suffix when lower-case concatenated\n-            if name[-len(s)].islower() and name[-len(s) - 1] != ' ':\n-                continue\n-            # also keep suffix to avoid confusing nam: \"Bitcoin Token\" -> \"Bitcoin\"\n-            if name[:-len(s)].strip().lower() == 'bitcoin':\n-                continue\n-            coin['reduced-name'] = True\n-            name = name[:-len(s)]\n-            break\n-\n-    coin['nn'] = coingecko_normalize_name(name)\n-\n-    if len(coin['nn']) < len(coin['ns']):\n-        if 'reduced-name' in coin:\n-            coin['reduced-name'] = False\n-            name = coin['name']\n-            coin['nn'] = coingecko_normalize_name(name)\n-        elif not has_many_caps(name):\n-            return coin['ns']\n-\n-    if not coin['ns']:  # coin['symbol'] may be an emoji that is striped when normalized\n-        return coin['nn']\n-\n-    if coin.get('reduced-name') and coin['ns'].upper() != coin['nn'].upper():\n-        return coin['ns']\n-\n-    i = coin['nn'].find('.')  # if there is a dot in normalized name => prefer the normalized symbol\n-    if i >= 0:\n-        if i > 1 and coin['nn'][i - 1].isdigit() and coin['nn'][i + 1].isdigit():\n-            pass  # except when the dot separates digits\n-        else:\n-            return coin['ns']\n-\n-    if is_name_short(coin) and has_many_caps(name):\n-        return coin['nn']\n-\n-    if 1.5 * len(coin['ns']) > len(coin['nn']) and any(c.islower() for c in coin['ns']):\n-        return coin['nn']\n-\n-    return coin['ns']\n-\n-\n-def coingecko_symbols() -> Dict[str, str]:\n-    r = None\n-    intermediate = defaultdict(list)\n-    try:\n-        r = requests.get('https://api.coingecko.com/api/v3/coins/list')\n-        all_coins = r.json()\n-        # First pass: generate & compare normalized symbol/name, and then select the most pertinent\n-        for coin in all_coins:\n-            normalized = coingecko_normalize_all(coin)\n-            intermediate[normalized].append(coin)\n-            # Above line keeps together the coins having the same normalized symbol.\n-            # To reduce collision, the coin['name'] is sometimes used in lieu of the coin['symbol'].\n-            # The coin['name'] is not capitalized because lower case letters may be meaningful: cETH, yUSD, DATx, zLOT\n-    except Exception as why:\n-        raise_failure_explanation('COINGECKO', why, {\"\": r})\n-\n-    final = coingecko_second_pass(intermediate)\n-    return coingecko_third_pass(final)\n-\n-\n-def coingecko_second_pass(intermediate: Dict[str, List[dict]]) -> Dict[str, List[dict]]:\n-    # Second pass: fixes most of the symbol collisions\n-    final = defaultdict(list)\n-    for normalized, coins in intermediate.items():\n-        if len(coins) == 1:\n-            final[normalized].append(coins[0])\n-            continue\n-        set_normalized = False\n-        for i in range(len(coins)):\n-            if normalized == coins[i]['nn']:\n-                coin = coins.pop(i)\n-                final[normalized].append(coin)\n-                set_normalized = True\n-                break\n-        rest: List[dict] = []\n-        for coin in coins:\n-            if '%' in coin['name']:\n-                if len(coins) == 1:\n-                    n = coin['ns']\n-                else:\n-                    n = coingecko_normalize_name(coin['id'])\n-                final[n].append(coin)\n-            else:\n-                rest.append(coin)\n-        if not rest:\n-            continue\n-        if not set_normalized:\n-            rest.sort(key=lambda coin: len(coin['nn']), reverse=True)  # sort by the length of the normalized name\n-            coin = rest.pop(0)\n-            final[normalized].append(coin)\n-        for coin in rest:\n-            if coin['nn'] not in intermediate:\n-                n = coin['nn']\n-            elif coin.get('reduced-name'):\n-                n = coingecko_normalize_name(coin['name'])\n-            else:\n-                n = coingecko_normalize_name(coin['id'])\n-            final[n].append(coin)\n-    return final\n-\n-\n-def coingecko_third_pass(final: Dict[str, List[dict]]) -> Dict[str, str]:\n-    # Third pass: fixes some remaining collisions and fills the result\n-    symbols = {}\n-    for normalized, coins in final.items():\n-        if len(coins) == 1:\n-            symbols[normalized] = coins[0]['id']\n-            continue\n-        set_normalized = False\n-        for i in range(len(coins)):\n-            if normalized == coins[i]['nn']:\n-                coin = coins.pop(i)\n-                symbols[normalized] = coin['id']\n-                set_normalized = True\n-                break\n-        rest: List[dict] = []\n-        for coin in coins:\n-            if '%' in coin['name']:\n-                if len(coins) == 1:\n-                    n = coin['ns']\n-                else:\n-                    n = coingecko_normalize_name(coin['id'])\n-                symbols[n] = coin['id']\n-            else:\n-                rest.append(coin)\n-        if not rest:\n-            continue\n-        if not set_normalized:\n-            rest.sort(key=lambda coin: len(coin['nn']), reverse=True)  # sort by the length of the normalized name\n-            coin = rest.pop(0)\n-            symbols[normalized] = coin['id']\n-        for coin in rest:\n-            if coin['nn'] not in final:\n-                n = coin['nn']\n-            elif coin.get('reduced-name'):\n-                n = coingecko_normalize_name(coin['name'])\n-            else:\n-                n = coingecko_normalize_name(coin['id'])\n-            symbols[n] = coin['id']\n-    return symbols\n-\n-\n-def whale_alert_coins(key_id: str) -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get(f'https://api.whale-alert.io/v1/status?api_key={key_id}')\n-        # Same symbols, but on different blockchains (for instance USDT), are naturally overwritten.\n-        return {s.upper(): s for b in r.json()['blockchains'] for s in b['symbols'] if s}\n-    except Exception as why:\n-        raise_failure_explanation('WHALES_ALERT', why, {\"\": r})\n-\n-\n-_exchange_function_map = {\n-    BITFINEX: bitfinex_symbols,\n-    BITFLYER: bitflyer_symbols,\n-    COINBASE: coinbase_symbols,\n-    GEMINI: gemini_symbols,\n-    HITBTC: hitbtc_symbols,\n-    POLONIEX: poloniex_symbols,\n-    PROBIT: probit_symbols,\n-    BITSTAMP: bitstamp_symbols,\n-    KRAKEN: kraken_symbols,\n-    KRAKEN + 'REST': kraken_rest_symbols,\n-    BINANCE: binance_symbols,\n-    BINANCE_US: binance_us_symbols,\n-    BINANCE_FUTURES: binance_futures_symbols,\n-    BINANCE_DELIVERY: binance_delivery_symbols,\n-    BLOCKCHAIN: blockchain_symbols,\n-    EXX: exx_symbols,\n-    HUOBI: huobi_symbols,\n-    HUOBI_DM: huobi_dm_symbols,\n-    HUOBI_SWAP: huobi_swap_symbols,\n-    OKCOIN: okcoin_symbols,\n-    OKEX: okex_symbols,\n-    BYBIT: bybit_symbols,\n-    FTX: ftx_symbols,\n-    FTX_US: ftx_us_symbols,\n-    BITTREX: bittrex_symbols,\n-    BITCOINCOM: bitcoincom_symbols,\n-    BITMAX: bitmax_symbols,\n-    UPBIT: upbit_symbols,\n-    GATEIO: gateio_symbols,\n-    BITMEX: bitmex_symbols,\n-    DERIBIT: deribit_symbols,\n-    KRAKEN_FUTURES: kraken_future_symbols,\n-    COINGECKO: coingecko_symbols,\n-    WHALE_ALERT: whale_alert_coins\n-}\n+Symbols = _Symbols()\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\n\nimport logging\nimport string\nimport time\nfrom collections import defaultdict\nfrom typing import Dict, List, Optional, Tuple\n\nimport requests\nfrom requests import Response\n\nfrom cryptofeed.defines import *\n\n\nLOG = logging.getLogger('feedhandler')\n\nSYMBOL_SEP = '-'\n\n_symbols_retrieval_cache: Dict[str, Dict[str, str]] = {}\n_exchange_info = defaultdict(lambda: defaultdict(dict))\n\n\n_kraken_futures_product_type = {\n    'FI': 'Inverse Futures',\n    'FV': 'Vanilla Futures',\n    'PI': 'Perpetual Inverse Futures',\n    'PV': 'Perpetual Vanilla Futures',\n    'IN': 'Real Time Index',\n    'RR': 'Reference Rate',\n}\n\n\ndef raise_failure_explanation(feed_id: str, exception: BaseException, responses: Dict[str, Optional[Response]]):\n    <IND>LOG.critical('%s: encountered %r while processing response from exchange API', feed_id, exception)\n    if len(responses) > 1:\n        <IND>LOG.critical('%s: content of one of the %s responses was unexpected', feed_id, len(responses))\n    <DED>for url, r in responses.items():\n        <IND>if url:\n            <IND>LOG.critical('%s: requested URL: %s', feed_id, url)\n        <DED>if r:\n            <IND>LOG.critical('%s: unexpected response: %s', feed_id, r.text)\n    <DED><DED>raise ValueError(f'Cryptofeed stopped because of an unexpected response from {feed_id}') from exception\n\n\n<DED>def set_symbol_separator(separator: str):\n    <IND>global SYMBOL_SEP\n    SYMBOL_SEP = separator\n\n\n<DED>def get_symbol_separator() -> str:\n    <IND>global SYMBOL_SEP\n    return SYMBOL_SEP\n\n\n<DED>def gen_symbols(exchange: str, key_id=None) -> Dict[str, str]:\n    <IND>if exchange not in _symbols_retrieval_cache:\n        <IND>LOG.info(\"%s: Getting list of symbols\", exchange)\n        symbols = _exchange_function_map[exchange](key_id) if key_id else _exchange_function_map[exchange]()\n        LOG.info(\"%s: %s symbols\", exchange, len(symbols))\n\n        # log all retrieved symbols using debug level\n        for normalized, exch_sym in sorted(symbols.items()):\n            <IND>LOG.debug('%s: id-from-exch -> normalized: %-35s-> %s', exchange, exch_sym, normalized)\n\n        <DED>_symbols_retrieval_cache[exchange] = symbols\n    <DED>return _symbols_retrieval_cache[exchange]\n\n\n<DED>def _binance_symbols(endpoint: str, exchange: str):\n    <IND>r = None\n    try:\n        <IND>ret = {}\n        r = requests.get(endpoint)\n        for symbol in r.json()['symbols']:\n            <IND>if symbol.get('status', 'TRADING') != \"TRADING\":\n                <IND>continue\n            <DED>if symbol.get('contractStatus', 'TRADING') != \"TRADING\":\n                <IND>continue\n            <DED>split = len(symbol['baseAsset'])\n            normalized = symbol['symbol'][:split] + SYMBOL_SEP + symbol['symbol'][split:]\n            ret[normalized] = symbol['symbol']\n            _exchange_info[exchange]['tick_size'][normalized] = symbol['filters'][0]['tickSize']\n            if \"contractType\" in symbol:\n                <IND>_exchange_info[exchange]['contract_type'][normalized] = symbol['contractType']\n        <DED><DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation(exchange, why, {endpoint: r})\n\n\n<DED><DED>def binance_symbols() -> Dict[str, str]:\n    <IND>return _binance_symbols('https://api.binance.com/api/v3/exchangeInfo', BINANCE)\n\n\n<DED>def binance_us_symbols() -> Dict[str, str]:\n    <IND>return _binance_symbols('https://api.binance.us/api/v3/exchangeInfo', BINANCE_US)\n\n\n<DED>def binance_futures_symbols() -> Dict[str, str]:\n    <IND>base = _binance_symbols('https://fapi.binance.com/fapi/v1/exchangeInfo', BINANCE_FUTURES)\n    add = {}\n    for symbol, orig in base.items():\n        <IND>if \"_\" in orig:\n            <IND>continue\n        <DED>add[f\"{symbol}-PINDEX\"] = f\"p{orig}\"\n    <DED>base.update(add)\n    return base\n\n\n<DED>def binance_delivery_symbols() -> Dict[str, str]:\n    <IND>return _binance_symbols('https://dapi.binance.com/dapi/v1/exchangeInfo', BINANCE_DELIVERY)\n\n\n<DED>def bitfinex_symbols() -> Dict[str, str]:\n    # doc: https://docs.bitfinex.com/docs/ws-general#supported-pairs\n    <IND>r1 = r2 = None\n    try:\n        <IND>r1 = requests.get('https://api.bitfinex.com/v2/tickers?symbols=ALL')\n        r2 = requests.get('https://api-pub.bitfinex.com/v2/conf/pub:map:currency:sym')\n        tickers: List[List[str]] = r1.json()\n        norm: List[Tuple[str, str]] = r2.json()[0]\n        norm: Dict[str, str] = dict(norm)\n        for k, v in dict(norm).items():\n            <IND>if k[-2:] == 'F0' or '-' in v:  # Do not convert BTCF0 -> BTC or PBTCETH -> PBTC-ETH\n                <IND>del norm[k]\n        <DED><DED>norm['BCHN'] = 'BCH'  # Bitfinex uses BCHN, other exchanges use BCH\n\n        ret = {}\n        for symbol in [t[0] for t in tickers]:\n            <IND>if symbol[0] == 'f':\n                <IND>normalized = norm.get(symbol[1:], symbol[1:])\n            <DED>else:\n                <IND>if len(symbol) == 7:\n                    <IND>base, quote = symbol[1:4], symbol[4:]\n                <DED>else:\n                    <IND>base, quote = symbol[1:].split(':')\n                    assert ':' in symbol\n                <DED>normalized = norm.get(base, base) + SYMBOL_SEP + norm.get(quote, quote)\n            <DED>ret[normalized.upper()] = symbol\n        <DED>return ret\n    <DED>except ValueError as why:\n        <IND>raise_failure_explanation('BITFINEX', why, {\"tickers?symbols=ALL\": r1, \"pub:map:currency:sym\": r2})\n\n\n<DED><DED>def bitflyer_symbols() -> Dict[str, str]:\n    <IND>endpoint = r = None\n    try:\n        <IND>ret = {}\n        endpoints = ['https://api.bitflyer.com/v1/getmarkets/eu', 'https://api.bitflyer.com/v1/getmarkets/usa', 'https://api.bitflyer.com/v1/getmarkets']\n        for endpoint in endpoints:\n            <IND>r = requests.get(endpoint)\n            for entry in r.json():\n                <IND>normalized = entry['product_code'].replace(\"_\", SYMBOL_SEP)\n                ret[normalized] = entry['product_code']\n        <DED><DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BITFLYER', why, {endpoint: r})\n\n\n<DED><DED>def bybit_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.bybit.com/v2/public/symbols')\n        ret = {}\n        for symbol in r.json()['result']:\n            <IND>quote = symbol['quote_currency']\n            if not symbol['name'].endswith(quote):\n                <IND>base, contract = symbol['name'].split(quote)\n                normalized = f\"{base}{SYMBOL_SEP}{quote}-{contract}\"\n            <DED>else:\n                <IND>normalized = f\"{symbol['base_currency']}{SYMBOL_SEP}{quote}\"\n            <DED>ret[normalized] = symbol['name']\n            _exchange_info[BYBIT]['tick_size'][normalized] = symbol['price_filter']['tick_size']\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BYBIT', why, {\"\": r})\n\n\n<DED><DED>def _ftx_helper(endpoint: str, exchange: str):\n    <IND>r = None\n    try:\n        <IND>r = requests.get(endpoint)\n        ret = {}\n        for data in r.json()['result']:\n            <IND>normalized = data['name'].replace(\"/\", SYMBOL_SEP)\n            symbol = data['name']\n            ret[normalized] = symbol\n            _exchange_info[exchange]['tick_size'][normalized] = data['priceIncrement']\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation(exchange, why, {endpoint: r})\n\n\n<DED><DED>def ftx_symbols() -> Dict[str, str]:\n    <IND>return _ftx_helper('https://ftx.com/api/markets', FTX)\n\n\n<DED>def ftx_us_symbols() -> Dict[str, str]:\n    <IND>return _ftx_helper('https://ftx.us/api/markets', FTX_US)\n\n\n<DED>def coinbase_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.pro.coinbase.com/products')\n        ret = {}\n        for data in r.json():\n            <IND>normalized = data['id'].replace(\"-\", SYMBOL_SEP)\n            ret[normalized] = data['id']\n            _exchange_info[COINBASE]['tick_size'][normalized] = data['quote_increment']\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('COINBASE', why, {\"\": r})\n\n\n<DED><DED>def gemini_symbols(*args) -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.gemini.com/v1/symbols')\n        ret = {}\n        for symbol in r.json():\n            <IND>std = f\"{symbol[:-3]}{SYMBOL_SEP}{symbol[-3:]}\"\n            std = std.upper()\n            ret[std] = symbol.upper()\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('GEMINI', why, {\"\": r})\n\n\n<DED><DED>def hitbtc_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>ret = {}\n        r = requests.get('https://api.hitbtc.com/api/2/public/symbol')\n        for symbol in r.json():\n            <IND>split = len(symbol['baseCurrency'])\n            normalized = symbol['id'][:split] + SYMBOL_SEP + symbol['id'][split:]\n            ret[normalized] = symbol['id']\n            _exchange_info[HITBTC]['tick_size'][normalized] = symbol['tickSize']\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('HITBTC', why, {\"\": r})\n\n\n<DED><DED>def poloniex_id_symbol_mapping():\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://poloniex.com/public?command=returnTicker')\n        symbols = r.json()\n        ret = {}\n        for symbol in symbols:\n            <IND>ret[symbols[symbol]['id']] = symbol\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('POLONIEX', why, {\"\": r})\n\n\n<DED><DED>def poloniex_symbols() -> Dict[str, str]:\n    <IND>ret = {}\n    for _, value in poloniex_id_symbol_mapping().items():\n        <IND>std = value.replace(\"STR\", \"XLM\")\n        quote, base = std.split(\"_\")\n        ret[quote + SYMBOL_SEP + base] = value\n    <DED>return ret\n\n\n<DED>def bitstamp_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://www.bitstamp.net/api/v2/trading-pairs-info/')\n        ret = {}\n        for data in r.json():\n            <IND>normalized = data['name'].replace(\"/\", SYMBOL_SEP)\n            symbol = data['url_symbol']\n            ret[normalized] = symbol\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BITSTAMP', why, {\"\": r})\n\n\n<DED><DED>def kraken_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.kraken.com/0/public/AssetPairs')\n        data = r.json()\n        ret = {}\n        for symbol in data['result']:\n            <IND>if 'wsname' not in data['result'][symbol] or '.d' in symbol:\n                # https://blog.kraken.com/post/259/introducing-the-kraken-dark-pool/\n                # .d is for dark pool symbols\n                <IND>continue\n\n            <DED>base, quote = data['result'][symbol]['wsname'].split(\"/\")\n\n            normalized = f\"{base}{SYMBOL_SEP}{quote}\"\n            exch = data['result'][symbol]['wsname']\n            normalized = normalized.replace('XBT', 'BTC')\n            normalized = normalized.replace('XDG', 'DOG')\n            ret[normalized] = exch\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('KRAKEN', why, {\"\": r})\n\n\n<DED><DED>def kraken_rest_symbols() -> Dict[str, str]:\n    <IND>return {normalized: exchange.replace(\"/\", \"\") for normalized, exchange in kraken_symbols().items()}\n\n\n<DED>def exx_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.exx.com/data/v1/tickers')\n        exchange = [key.upper() for key in r.json().keys()]\n        symbols = [key.replace(\"_\", SYMBOL_SEP) for key in exchange]\n        return dict(zip(symbols, exchange))\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('EXX', why, {\"\": r})\n\n\n<DED><DED>def huobi_common_symbols(url: str):\n    <IND>r = None\n    try:\n        <IND>r = requests.get(url)\n        ret = {}\n        for e in r.json()['data']:\n            <IND>if e['state'] == 'offline':\n                <IND>continue\n            <DED>normalized = f\"{e['base-currency'].upper()}{SYMBOL_SEP}{e['quote-currency'].upper()}\"\n            symbol = f\"{e['base-currency']}{e['quote-currency']}\"\n            ret[normalized] = symbol\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('HUOBI', why, {url: r})\n\n\n<DED><DED>def huobi_symbols() -> Dict[str, str]:\n    <IND>return huobi_common_symbols('https://api.huobi.pro/v1/common/symbols')\n\n\n<DED>def huobi_us_symbols() -> Dict[str, str]:\n    <IND>return huobi_common_symbols('https://api.huobi.com/v1/common/symbols')\n\n\n<DED>def huobi_dm_symbols() -> Dict[str, str]:\n    <IND>\"\"\"\n    Mapping is, for instance: {\"BTC_CW\":\"BTC190816\"}\n    See comments in exchange/huobi_dm.py\n    \"\"\"\n    mapping = {\n        \"this_week\": \"CW\",\n        \"next_week\": \"NW\",\n        \"quarter\": \"CQ\",\n        \"next_quarter\": \"NQ\"\n    }\n    r = None\n    try:\n        <IND>r = requests.get('https://www.hbdm.com/api/v1/contract_contract_info')\n        symbols = {}\n        for e in r.json()['data']:\n            <IND>symbols[f\"{e['symbol']}_{mapping[e['contract_type']]}\"] = e['contract_code']\n            _exchange_info[HUOBI_DM]['tick_size'][e['contract_code']] = e['price_tick']\n            _exchange_info[HUOBI_DM]['short_code_mappings'][f\"{e['symbol']}_{mapping[e['contract_type']]}\"] = e['contract_code']\n        <DED>return symbols\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('HUOBI_DM', why, {\"\": r})\n\n\n<DED><DED>def huobi_swap_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.hbdm.com/swap-api/v1/swap_contract_info')\n        symbols = {}\n        for e in r.json()['data']:\n            <IND>symbols[e['contract_code']] = e['contract_code']\n            _exchange_info[HUOBI_SWAP]['tick_size'][e['contract_code']] = e['price_tick']\n        <DED>return symbols\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('HUOBI_SWAP', why, {\"\": r})\n\n\n<DED><DED>def okcoin_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://www.okcoin.com/api/spot/v3/instruments')\n        ret = {}\n        for e in r.json():\n            <IND>ret[e['instrument_id']] = e['instrument_id']\n            _exchange_info[OKCOIN]['tick_size'][e['instrument_id']] = e['tick_size']\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('OKCOIN', why, {\"\": r})\n\n\n<DED><DED>def okex_symbols(*args) -> Dict[str, str]:\n    <IND>urls = ['https://www.okex.com/api/spot/v3/instruments',\n            'https://www.okex.com/api/swap/v3/instruments',\n            'https://www.okex.com/api/futures/v3/instruments']\n    urls = urls + okex_compute_option_urls_from_underlyings()\n\n    symbols: Dict[str, str] = {}\n    for u in urls:\n        <IND>time.sleep(0.2)\n        symbols.update(okex_symbols_from_one_url(u))\n\n    <DED>for symbol in symbols:\n        <IND>instrument_type = 'futures'\n        dash_count = symbol.count(get_symbol_separator())\n        if dash_count == 1:  # BTC-USDT\n            <IND>instrument_type = 'spot'\n        <DED>if dash_count == 4:  # BTC-USD-201225-35000-P\n            <IND>instrument_type = 'option'\n        <DED>if symbol[-4:] == \"SWAP\":  # BTC-USDT-SWAP\n            <IND>instrument_type = 'swap'\n\n        <DED>_exchange_info[OKEX]['instrument_type'][symbol] = instrument_type\n\n    <DED>return symbols\n\n\n<DED>def okex_compute_option_urls_from_underlyings() -> List[str]:\n    <IND>url = 'https://www.okex.com/api/option/v3/underlying'\n    r = None\n    try:\n        <IND>r = requests.get(url)\n        return [f'https://www.okex.com/api/option/v3/instruments/{underlying}' for underlying in r.json()]\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('OKEX', why, {url: r})\n\n\n<DED><DED>def okex_symbols_from_one_url(url: str) -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get(url)\n        ret = {}\n        for e in r.json():\n            <IND>ret[e['instrument_id']] = e['instrument_id']\n            _exchange_info[OKEX]['tick_size'][e['instrument_id']] = e['tick_size']\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('OKEX', why, {url: r})\n\n\n<DED><DED>def bittrex_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.bittrex.com/api/v1.1/public/getmarkets')\n        r = r.json()['result']\n        return {f\"{e['MarketCurrency']}{SYMBOL_SEP}{e['BaseCurrency']}\": e['MarketName'] for e in r if e['IsActive']}\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BITTREX', why, {\"\": r})\n\n\n<DED><DED>def bitcoincom_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.exchange.bitcoin.com/api/2/public/symbol')\n        return {f\"{data['baseCurrency']}{SYMBOL_SEP}{data['quoteCurrency'].replace('USD', 'USDT')}\": data['id'] for data in r.json()}\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BITCOINCOM', why, {\"\": r})\n\n\n<DED><DED>def bitmax_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://bitmax.io/api/pro/v1/products')\n        ret = {}\n        for entry in r.json()['data']:\n            # Only \"Normal\" status symbols are tradeable\n            <IND>if entry['status'] == 'Normal':\n                <IND>normalized = f\"{entry['baseAsset']}{SYMBOL_SEP}{entry['quoteAsset']}\"\n                ret[normalized] = entry['symbol']\n                _exchange_info[BITMAX]['tick_size'][normalized] = entry['tickSize']\n        <DED><DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BITMAX', why, {\"\": r})\n\n\n<DED><DED>def upbit_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.upbit.com/v1/market/all')\n        return {f\"{data['market'].split('-')[1]}{SYMBOL_SEP}{data['market'].split('-')[0]}\": data['market'] for data in r.json()}\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('UPBIT', why, {\"\": r})\n\n\n<DED><DED>def blockchain_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get(\"https://api.blockchain.com/mercury-gateway/v1/instruments\")\n        return {data[\"symbol\"].replace(\"-\", SYMBOL_SEP): data[\"symbol\"] for data in r.json()}\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BLOCKCHAIN', why, {\"\": r})\n\n\n<DED><DED>def gateio_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get(\"https://api.gateio.ws/api/v4/spot/currency_pairs\")\n        return {data[\"id\"].replace(\"_\", SYMBOL_SEP): data['id'] for data in r.json()}\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('GATEIO', why, {\"\": r})\n\n\n<DED><DED>def bitmex_symbols() -> Dict[str, str]:\n    <IND>r = None\n    ret = {}\n    try:\n        <IND>r = requests.get(\"https://www.bitmex.com/api/v1/instrument/active\")\n        for entry in r.json():\n            <IND>components = []\n            components.append(entry['rootSymbol'])\n            components.append(entry['quoteCurrency'])\n\n            if entry['expiry']:\n                <IND>components.append(entry['symbol'][-3:])\n\n            <DED>normalized = SYMBOL_SEP.join(components)\n            normalized = normalized.replace(\"XBT\", \"BTC\")\n            ret[normalized] = entry['symbol']\n            _exchange_info[BITMEX]['tick_size'][normalized] = entry['tickSize']\n\n            if entry['expiry']:\n                <IND>_exchange_info[BITMEX]['expiry'][normalized] = entry['expiry']\n\n        <DED><DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BITMEX', why, {\"\": r})\n\n\n<DED><DED>def deribit_symbols() -> Dict[str, str]:\n    <IND>url = r = None\n    ret = {}\n    try:\n        # TODO: get currencies from https://www.deribit.com/api/v2/public/get_currencies\n        <IND>currencies = ['BTC', 'ETH']\n        for c in currencies:\n            <IND>url = f\"https://www.deribit.com/api/v2/public/get_instruments?currency={c}&expired=false\"\n            r = requests.get(url)\n            for entry in r.json()['result']:\n                <IND>split = entry['instrument_name'].split(\"-\")\n                normalized = split[0] + SYMBOL_SEP + entry['quote_currency'] + \"-\" + '-'.join(split[1:])\n                ret[normalized] = entry['instrument_name']\n                _exchange_info[DERIBIT]['tick_size'][normalized] = entry['tick_size']\n        <DED><DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('DERIBIT', why, {url: r})\n\n\n<DED><DED>def kraken_future_symbols() -> Dict[str, str]:\n    <IND>r = None\n    ret = {}\n    try:\n        <IND>r = requests.get('https://futures.kraken.com/derivatives/api/v3/instruments')\n        data = r.json()['instruments']\n        for entry in data:\n            <IND>if not entry['tradeable']:\n                <IND>continue\n            <DED>normalized = entry['symbol'].upper().replace(\"_\", \"-\")\n            symbol = normalized[3:6] + SYMBOL_SEP + normalized[6:9]\n            normalized = normalized.replace(normalized[3:9], symbol)\n            normalized = normalized.replace('XBT', 'BTC')\n\n            _exchange_info[KRAKEN_FUTURES]['tick_size'][normalized] = entry['tickSize']\n            _exchange_info[KRAKEN_FUTURES]['contract_size'][normalized] = entry['contractSize']\n            _exchange_info[KRAKEN_FUTURES]['underlying'][normalized] = entry['underlying']\n            _exchange_info[KRAKEN_FUTURES]['product_type'][normalized] = _kraken_futures_product_type[normalized[:2]]\n            ret[normalized] = entry['symbol']\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('KRAKEN_FUTURES', why, {\"\": r})\n\n\n<DED><DED>def probit_symbols() -> Dict[str, str]:\n    # doc: https://docs-en.probit.com/reference-link/market\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.probit.com/api/exchange/v1/market')\n        return {entry['id']: entry['id'] for entry in r.json()['data']}\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('PROBIT', why, {\"\": r})\n\n\n<DED><DED>def coingecko_normalize_symbol(symbol: str) -> str:\n    # keep digits, letters and dots, replace others by space\n    <IND>symbol = ''.join(c if c.isalnum() or c in ('.', '+') else ' ' for c in symbol)\n    return coingecko_normalize(symbol.upper())\n\n\n<DED>def coingecko_normalize_name(name: str) -> str:\n    # keep digits and letters, replace others by space (except when only composed by upper case letters, digits and dots)\n    <IND>if not all(c.isupper() or c.isdigit() or c == '.' for c in name):\n        <IND>name = ''.join(c if c.isalnum() else ' ' for c in name)\n    <DED>return coingecko_normalize(name)\n\n\n<DED>def coingecko_normalize(sym: str) -> str:\n    <IND>sym = sym.strip()\n    # do not concatenate numbers => separate them with a dot\n    sym = list(sym)\n    if len(sym) > 4:\n        <IND>for i in range(2, len(sym) - 1):\n            <IND>if sym[i] == ' ' and sym[i - 1].isdigit() and sym[i + 1].isdigit():\n                <IND>sym[i] = '.'\n    <DED><DED><DED>sym = ''.join(sym)\n    # concatenate space-separated words => use CamelCase to distinguish the words\n    if ' ' in sym:\n        <IND>if sum(c.islower() for c in sym):  # if there is at least one lower case letter\n            <IND>sym = ' '.join(word[0].upper() + word[1:] for word in sym.split())  # Just capitalize initial letter of each word\n        <DED>else:  # CoinGecko may provide full upper-case as for \"THE STONE COIN\"\n            <IND>sym = string.capwords(sym)  # capwords converts \"THE STONE COIN\" to \"The Stone Coin\"\n        <DED>sym = sym.replace(' ', '')  # concatenate words\n    <DED>return sym\n\n\n<DED>def is_name_short(coin: dict) -> bool:\n    <IND>\"\"\"return True if the coin name is enough short compared to the coin symbol.\"\"\"\n    return len(coin['name']) <= max(5, len(coin['symbol']) + 1)\n\n\n<DED>def has_many_caps(name: str) -> bool:\n    <IND>\"\"\"return True if the symbol contains enough upper case letters, False if empty.\"\"\"\n    return str and sum(c.islower() for c in name) < (len(name) / 2)\n\n\n<DED>def coingecko_normalize_all(coin: dict):\n    <IND>SYMBOL_TO_NORMALIZED = {'miota': 'IOTA'}\n    normalized = SYMBOL_TO_NORMALIZED.get(coin['symbol'])\n    if normalized:\n        <IND>coin['ns'] = coin['nn'] = normalized\n        return normalized\n\n    # ns = normalized symbol, nn = normalized name\n    <DED>coin['ns'] = coingecko_normalize_symbol(coin['symbol'])\n\n    ID_SUFFIX = '-bitcoin-token'\n    if coin['id'][-len(ID_SUFFIX):] == ID_SUFFIX:\n        <IND>coin['nn'] = 'BTC' + coin['ns']\n        return coin['nn']\n\n    <DED>name = coin['name']\n\n    prefixes = ('The ', 'the ')\n    for p in prefixes:\n        <IND>if name[:len(p)] == p:\n            <IND>coin['reduced-name'] = True\n            name = name[len(p):]\n            break\n\n    <DED><DED>suffixes = ('coin', 'coins', 'money', 'finance', 'protocol', 'reward', 'rewards', 'token')\n    for s in suffixes:\n        <IND>if len(name) > len(s) and name[-len(s):].lower() == s:\n            # but keep suffix when lower-case concatenated\n            <IND>if name[-len(s)].islower() and name[-len(s) - 1] != ' ':\n                <IND>continue\n            # also keep suffix to avoid confusing nam: \"Bitcoin Token\" -> \"Bitcoin\"\n            <DED>if name[:-len(s)].strip().lower() == 'bitcoin':\n                <IND>continue\n            <DED>coin['reduced-name'] = True\n            name = name[:-len(s)]\n            break\n\n    <DED><DED>coin['nn'] = coingecko_normalize_name(name)\n\n    if len(coin['nn']) < len(coin['ns']):\n        <IND>if 'reduced-name' in coin:\n            <IND>coin['reduced-name'] = False\n            name = coin['name']\n            coin['nn'] = coingecko_normalize_name(name)\n        <DED>elif not has_many_caps(name):\n            <IND>return coin['ns']\n\n    <DED><DED>if not coin['ns']:  # coin['symbol'] may be an emoji that is striped when normalized\n        <IND>return coin['nn']\n\n    <DED>if coin.get('reduced-name') and coin['ns'].upper() != coin['nn'].upper():\n        <IND>return coin['ns']\n\n    <DED>i = coin['nn'].find('.')  # if there is a dot in normalized name => prefer the normalized symbol\n    if i >= 0:\n        <IND>if i > 1 and coin['nn'][i - 1].isdigit() and coin['nn'][i + 1].isdigit():\n            <IND>pass  # except when the dot separates digits\n        <DED>else:\n            <IND>return coin['ns']\n\n    <DED><DED>if is_name_short(coin) and has_many_caps(name):\n        <IND>return coin['nn']\n\n    <DED>if 1.5 * len(coin['ns']) > len(coin['nn']) and any(c.islower() for c in coin['ns']):\n        <IND>return coin['nn']\n\n    <DED>return coin['ns']\n\n\n<DED>def coingecko_symbols() -> Dict[str, str]:\n    <IND>r = None\n    intermediate = defaultdict(list)\n    try:\n        <IND>r = requests.get('https://api.coingecko.com/api/v3/coins/list')\n        all_coins = r.json()\n        # First pass: generate & compare normalized symbol/name, and then select the most pertinent\n        for coin in all_coins:\n            <IND>normalized = coingecko_normalize_all(coin)\n            intermediate[normalized].append(coin)\n            # Above line keeps together the coins having the same normalized symbol.\n            # To reduce collision, the coin['name'] is sometimes used in lieu of the coin['symbol'].\n            # The coin['name'] is not capitalized because lower case letters may be meaningful: cETH, yUSD, DATx, zLOT\n    <DED><DED>except Exception as why:\n        <IND>raise_failure_explanation('COINGECKO', why, {\"\": r})\n\n    <DED>final = coingecko_second_pass(intermediate)\n    return coingecko_third_pass(final)\n\n\n<DED>def coingecko_second_pass(intermediate: Dict[str, List[dict]]) -> Dict[str, List[dict]]:\n    # Second pass: fixes most of the symbol collisions\n    <IND>final = defaultdict(list)\n    for normalized, coins in intermediate.items():\n        <IND>if len(coins) == 1:\n            <IND>final[normalized].append(coins[0])\n            continue\n        <DED>set_normalized = False\n        for i in range(len(coins)):\n            <IND>if normalized == coins[i]['nn']:\n                <IND>coin = coins.pop(i)\n                final[normalized].append(coin)\n                set_normalized = True\n                break\n        <DED><DED>rest: List[dict] = []\n        for coin in coins:\n            <IND>if '%' in coin['name']:\n                <IND>if len(coins) == 1:\n                    <IND>n = coin['ns']\n                <DED>else:\n                    <IND>n = coingecko_normalize_name(coin['id'])\n                <DED>final[n].append(coin)\n            <DED>else:\n                <IND>rest.append(coin)\n        <DED><DED>if not rest:\n            <IND>continue\n        <DED>if not set_normalized:\n            <IND>rest.sort(key=lambda coin: len(coin['nn']), reverse=True)  # sort by the length of the normalized name\n            coin = rest.pop(0)\n            final[normalized].append(coin)\n        <DED>for coin in rest:\n            <IND>if coin['nn'] not in intermediate:\n                <IND>n = coin['nn']\n            <DED>elif coin.get('reduced-name'):\n                <IND>n = coingecko_normalize_name(coin['name'])\n            <DED>else:\n                <IND>n = coingecko_normalize_name(coin['id'])\n            <DED>final[n].append(coin)\n    <DED><DED>return final\n\n\n<DED>def coingecko_third_pass(final: Dict[str, List[dict]]) -> Dict[str, str]:\n    # Third pass: fixes some remaining collisions and fills the result\n    <IND>symbols = {}\n    for normalized, coins in final.items():\n        <IND>if len(coins) == 1:\n            <IND>symbols[normalized] = coins[0]['id']\n            continue\n        <DED>set_normalized = False\n        for i in range(len(coins)):\n            <IND>if normalized == coins[i]['nn']:\n                <IND>coin = coins.pop(i)\n                symbols[normalized] = coin['id']\n                set_normalized = True\n                break\n        <DED><DED>rest: List[dict] = []\n        for coin in coins:\n            <IND>if '%' in coin['name']:\n                <IND>if len(coins) == 1:\n                    <IND>n = coin['ns']\n                <DED>else:\n                    <IND>n = coingecko_normalize_name(coin['id'])\n                <DED>symbols[n] = coin['id']\n            <DED>else:\n                <IND>rest.append(coin)\n        <DED><DED>if not rest:\n            <IND>continue\n        <DED>if not set_normalized:\n            <IND>rest.sort(key=lambda coin: len(coin['nn']), reverse=True)  # sort by the length of the normalized name\n            coin = rest.pop(0)\n            symbols[normalized] = coin['id']\n        <DED>for coin in rest:\n            <IND>if coin['nn'] not in final:\n                <IND>n = coin['nn']\n            <DED>elif coin.get('reduced-name'):\n                <IND>n = coingecko_normalize_name(coin['name'])\n            <DED>else:\n                <IND>n = coingecko_normalize_name(coin['id'])\n            <DED>symbols[n] = coin['id']\n    <DED><DED>return symbols\n\n\n<DED>def whale_alert_coins(key_id: str) -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get(f'https://api.whale-alert.io/v1/status?api_key={key_id}')\n        # Same symbols, but on different blockchains (for instance USDT), are naturally overwritten.\n        return {s.upper(): s for b in r.json()['blockchains'] for s in b['symbols'] if s}\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('WHALES_ALERT', why, {\"\": r})\n\n\n<DED><DED>_exchange_function_map = {\n    BITFINEX: bitfinex_symbols,\n    BITFLYER: bitflyer_symbols,\n    COINBASE: coinbase_symbols,\n    GEMINI: gemini_symbols,\n    HITBTC: hitbtc_symbols,\n    POLONIEX: poloniex_symbols,\n    PROBIT: probit_symbols,\n    BITSTAMP: bitstamp_symbols,\n    KRAKEN: kraken_symbols,\n    KRAKEN + 'REST': kraken_rest_symbols,\n    BINANCE: binance_symbols,\n    BINANCE_US: binance_us_symbols,\n    BINANCE_FUTURES: binance_futures_symbols,\n    BINANCE_DELIVERY: binance_delivery_symbols,\n    BLOCKCHAIN: blockchain_symbols,\n    EXX: exx_symbols,\n    HUOBI: huobi_symbols,\n    HUOBI_DM: huobi_dm_symbols,\n    HUOBI_SWAP: huobi_swap_symbols,\n    OKCOIN: okcoin_symbols,\n    OKEX: okex_symbols,\n    BYBIT: bybit_symbols,\n    FTX: ftx_symbols,\n    FTX_US: ftx_us_symbols,\n    BITTREX: bittrex_symbols,\n    BITCOINCOM: bitcoincom_symbols,\n    BITMAX: bitmax_symbols,\n    UPBIT: upbit_symbols,\n    GATEIO: gateio_symbols,\n    BITMEX: bitmex_symbols,\n    DERIBIT: deribit_symbols,\n    KRAKEN_FUTURES: kraken_future_symbols,\n    COINGECKO: coingecko_symbols,\n    WHALE_ALERT: whale_alert_coins\n}\n",
        "target_code_with_indent": "\nfrom typing import Dict, Tuple\n\n\nclass _Symbols:\n    <IND>def __init__(self):\n        <IND>self.data = {}\n\n    <DED>def set(self, exchange: str, normalized: dict, exchange_info: dict):\n        <IND>self.data[exchange] = {}\n        self.data[exchange]['normalized'] = normalized\n        self.data[exchange]['info'] = exchange_info\n\n    <DED>def get(self, exchange: str) -> Tuple[Dict, Dict]:\n        <IND>return self.data[exchange]['normalized'], self.data[exchange]['info']\n\n    <DED>def populated(self, exchange: str) -> bool:\n        <IND>return exchange in self.data\n\n\n<DED><DED>Symbols = _Symbols()\n"
      }
    ]
  },
  {
    "project": "bmoscon/cryptofeed",
    "commit": "3525dc8ce4d7836a9abaaa5662e58e5e27969a77",
    "filename": "cryptofeed/symbols.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/bmoscon-cryptofeed/cryptofeed/symbols.py",
    "file_hunks_size": 1,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "cryptofeed/symbols.py:509:8 Incompatible return type [7]: Expected `Dict[str, str]` but got implicit return value of `None`.",
    "message": " Expected `Dict[str, str]` but got implicit return value of `None`.",
    "rule_id": "Incompatible return type [7]",
    "warning_line_no": 509,
    "warning_line": "        raise_failure_explanation('GATEIO', why, {\"\": r})",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "associated with this software.\n\n\nSymbol generation code for exchanges\n'''\n\nimport logging\nimport string\nimport time\nfrom collections import defaultdict\nfrom typing import Dict, List, Optional, Tuple\n\nimport requests\nfrom requests import Response\n\nfrom cryptofeed.defines import *\n\n\nLOG = logging.getLogger('feedhandler')\n\nSYMBOL_SEP = '-'\n\n_symbols_retrieval_cache: Dict[str, Dict[str, str]] = {}\n_exchange_info = defaultdict(lambda: defaultdict(dict))\n\n\n_kraken_futures_product_type = {\n    'FI': 'Inverse Futures',\n    'FV': 'Vanilla Futures',\n    'PI': 'Perpetual Inverse Futures',\n    'PV': 'Perpetual Vanilla Futures',\n    'IN': 'Real Time Index',\n    'RR': 'Reference Rate',\n}\n\n\ndef raise_failure_explanation(feed_id: str, exception: BaseException, responses: Dict[str, Optional[Response]]):\n    LOG.critical('%s: encountered %r while processing response from exchange API', feed_id, exception)\n    if len(responses) > 1:\n        LOG.critical('%s: content of one of the %s responses was unexpected', feed_id, len(responses))\n    for url, r in responses.items():\n        if url:\n            LOG.critical('%s: requested URL: %s', feed_id, url)\n        if r:\n            LOG.critical('%s: unexpected response: %s', feed_id, r.text)\n    raise ValueError(f'Cryptofeed stopped because of an unexpected response from {feed_id}') from exception\n\n\ndef set_symbol_separator(separator: str):\n    global SYMBOL_SEP\n    SYMBOL_SEP = separator\n\n\ndef get_symbol_separator() -> str:\n    global SYMBOL_SEP\n    return SYMBOL_SEP\n\n\ndef gen_symbols(exchange: str, key_id=None) -> Dict[str, str]:\n    if exchange not in _symbols_retrieval_cache:\n        LOG.info(\"%s: Getting list of symbols\", exchange)\n        symbols = _exchange_function_map[exchange](key_id) if key_id else _exchange_function_map[exchange]()\n        LOG.info(\"%s: %s symbols\", exchange, len(symbols))\n\n        # log all retrieved symbols using debug level\n        for normalized, exch_sym in sorted(symbols.items()):\n            LOG.debug('%s: id-from-exch -> normalized: %-35s-> %s', exchange, exch_sym, normalized)\n\n        _symbols_retrieval_cache[exchange] = symbols\n    return _symbols_retrieval_cache[exchange]\n\n\ndef _binance_symbols(endpoint: str, exchange: str):\n    r = None\n    try:\n        ret = {}\n        r = requests.get(endpoint)\n        for symbol in r.json()['symbols']:\n            if symbol.get('status', 'TRADING') != \"TRADING\":\n                continue\n            if symbol.get('contractStatus', 'TRADING') != \"TRADING\":\n                continue\n            split = len(symbol['baseAsset'])\n            normalized = symbol['symbol'][:split] + SYMBOL_SEP + symbol['symbol'][split:]\n            ret[normalized] = symbol['symbol']\n            _exchange_info[exchange]['tick_size'][normalized] = symbol['filters'][0]['tickSize']\n            if \"contractType\" in symbol:\n                _exchange_info[exchange]['contract_type'][normalized] = symbol['contractType']\n        return ret\n    except Exception as why:\n        raise_failure_explanation(exchange, why, {endpoint: r})\n\n\ndef binance_symbols() -> Dict[str, str]:\n    return _binance_symbols('https://api.binance.com/api/v3/exchangeInfo', BINANCE)\n\n\ndef binance_us_symbols() -> Dict[str, str]:\n    return _binance_symbols('https://api.binance.us/api/v3/exchangeInfo', BINANCE_US)\n\n\ndef binance_futures_symbols() -> Dict[str, str]:\n    base = _binance_symbols('https://fapi.binance.com/fapi/v1/exchangeInfo', BINANCE_FUTURES)\n    add = {}\n    for symbol, orig in base.items():\n        if \"_\" in orig:\n            continue\n        add[f\"{symbol}-PINDEX\"] = f\"p{orig}\"\n    base.update(add)\n    return base\n\n\ndef binance_delivery_symbols() -> Dict[str, str]:\n    return _binance_symbols('https://dapi.binance.com/dapi/v1/exchangeInfo', BINANCE_DELIVERY)\n\n\ndef bitfinex_symbols() -> Dict[str, str]:\n    # doc: https://docs.bitfinex.com/docs/ws-general#supported-pairs\n    r1 = r2 = None\n    try:\n        r1 = requests.get('https://api.bitfinex.com/v2/tickers?symbols=ALL')\n        r2 = requests.get('https://api-pub.bitfinex.com/v2/conf/pub:map:currency:sym')\n        tickers: List[List[str]] = r1.json()\n        norm: List[Tuple[str, str]] = r2.json()[0]\n        norm: Dict[str, str] = dict(norm)\n        for k, v in dict(norm).items():\n            if k[-2:] == 'F0' or '-' in v:  # Do not convert BTCF0 -> BTC or PBTCETH -> PBTC-ETH\n                del norm[k]\n        norm['BCHN'] = 'BCH'  # Bitfinex uses BCHN, other exchanges use BCH\n\n        ret = {}\n        for symbol in [t[0] for t in tickers]:\n            if symbol[0] == 'f':\n                normalized = norm.get(symbol[1:], symbol[1:])\n            else:\n                if len(symbol) == 7:\n                    base, quote = symbol[1:4], symbol[4:]\n                else:\n                    base, quote = symbol[1:].split(':')\n                    assert ':' in symbol\n                normalized = norm.get(base, base) + SYMBOL_SEP + norm.get(quote, quote)\n            ret[normalized.upper()] = symbol\n        return ret\n    except ValueError as why:\n        raise_failure_explanation('BITFINEX', why, {\"tickers?symbols=ALL\": r1, \"pub:map:currency:sym\": r2})\n\n\ndef bitflyer_symbols() -> Dict[str, str]:\n    endpoint = r = None\n    try:\n        ret = {}\n        endpoints = ['https://api.bitflyer.com/v1/getmarkets/eu', 'https://api.bitflyer.com/v1/getmarkets/usa', 'https://api.bitflyer.com/v1/getmarkets']\n        for endpoint in endpoints:\n            r = requests.get(endpoint)\n            for entry in r.json():\n                normalized = entry['product_code'].replace(\"_\", SYMBOL_SEP)\n                ret[normalized] = entry['product_code']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('BITFLYER', why, {endpoint: r})\n\n\ndef bybit_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.bybit.com/v2/public/symbols')\n        ret = {}\n        for symbol in r.json()['result']:\n            quote = symbol['quote_currency']\n            if not symbol['name'].endswith(quote):\n                base, contract = symbol['name'].split(quote)\n                normalized = f\"{base}{SYMBOL_SEP}{quote}-{contract}\"\n            else:\n                normalized = f\"{symbol['base_currency']}{SYMBOL_SEP}{quote}\"\n            ret[normalized] = symbol['name']\n            _exchange_info[BYBIT]['tick_size'][normalized] = symbol['price_filter']['tick_size']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('BYBIT', why, {\"\": r})\n\n\ndef _ftx_helper(endpoint: str, exchange: str):\n    r = None\n    try:\n        r = requests.get(endpoint)\n        ret = {}\n        for data in r.json()['result']:\n            normalized = data['name'].replace(\"/\", SYMBOL_SEP)\n            symbol = data['name']\n            ret[normalized] = symbol\n            _exchange_info[exchange]['tick_size'][normalized] = data['priceIncrement']\n        return ret\n    except Exception as why:\n        raise_failure_explanation(exchange, why, {endpoint: r})\n\n\ndef ftx_symbols() -> Dict[str, str]:\n    return _ftx_helper('https://ftx.com/api/markets', FTX)\n\n\ndef ftx_us_symbols() -> Dict[str, str]:\n    return _ftx_helper('https://ftx.us/api/markets', FTX_US)\n\n\ndef coinbase_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.pro.coinbase.com/products')\n        ret = {}\n        for data in r.json():\n            normalized = data['id'].replace(\"-\", SYMBOL_SEP)\n            ret[normalized] = data['id']\n            _exchange_info[COINBASE]['tick_size'][normalized] = data['quote_increment']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('COINBASE', why, {\"\": r})\n\n\ndef gemini_symbols(*args) -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.gemini.com/v1/symbols')\n        ret = {}\n        for symbol in r.json():\n            std = f\"{symbol[:-3]}{SYMBOL_SEP}{symbol[-3:]}\"\n            std = std.upper()\n            ret[std] = symbol.upper()\n        return ret\n    except Exception as why:\n        raise_failure_explanation('GEMINI', why, {\"\": r})\n\n\ndef hitbtc_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        ret = {}\n        r = requests.get('https://api.hitbtc.com/api/2/public/symbol')\n        for symbol in r.json():\n            split = len(symbol['baseCurrency'])\n            normalized = symbol['id'][:split] + SYMBOL_SEP + symbol['id'][split:]\n            ret[normalized] = symbol['id']\n            _exchange_info[HITBTC]['tick_size'][normalized] = symbol['tickSize']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('HITBTC', why, {\"\": r})\n\n\ndef poloniex_id_symbol_mapping():\n    r = None\n    try:\n        r = requests.get('https://poloniex.com/public?command=returnTicker')\n        symbols = r.json()\n        ret = {}\n        for symbol in symbols:\n            ret[symbols[symbol]['id']] = symbol\n        return ret\n    except Exception as why:\n        raise_failure_explanation('POLONIEX', why, {\"\": r})\n\n\ndef poloniex_symbols() -> Dict[str, str]:\n    ret = {}\n    for _, value in poloniex_id_symbol_mapping().items():\n        std = value.replace(\"STR\", \"XLM\")\n        quote, base = std.split(\"_\")\n        ret[quote + SYMBOL_SEP + base] = value\n    return ret\n\n\ndef bitstamp_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://www.bitstamp.net/api/v2/trading-pairs-info/')\n        ret = {}\n        for data in r.json():\n            normalized = data['name'].replace(\"/\", SYMBOL_SEP)\n            symbol = data['url_symbol']\n            ret[normalized] = symbol\n        return ret\n    except Exception as why:\n        raise_failure_explanation('BITSTAMP', why, {\"\": r})\n\n\ndef kraken_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.kraken.com/0/public/AssetPairs')\n        data = r.json()\n        ret = {}\n        for symbol in data['result']:\n            if 'wsname' not in data['result'][symbol] or '.d' in symbol:\n                # https://blog.kraken.com/post/259/introducing-the-kraken-dark-pool/\n                # .d is for dark pool symbols\n                continue\n\n            base, quote = data['result'][symbol]['wsname'].split(\"/\")\n\n            normalized = f\"{base}{SYMBOL_SEP}{quote}\"\n            exch = data['result'][symbol]['wsname']\n            normalized = normalized.replace('XBT', 'BTC')\n            normalized = normalized.replace('XDG', 'DOG')\n            ret[normalized] = exch\n        return ret\n    except Exception as why:\n        raise_failure_explanation('KRAKEN', why, {\"\": r})\n\n\ndef kraken_rest_symbols() -> Dict[str, str]:\n    return {normalized: exchange.replace(\"/\", \"\") for normalized, exchange in kraken_symbols().items()}\n\n\ndef exx_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.exx.com/data/v1/tickers')\n        exchange = [key.upper() for key in r.json().keys()]\n        symbols = [key.replace(\"_\", SYMBOL_SEP) for key in exchange]\n        return dict(zip(symbols, exchange))\n    except Exception as why:\n        raise_failure_explanation('EXX', why, {\"\": r})\n\n\ndef huobi_common_symbols(url: str):\n    r = None\n    try:\n        r = requests.get(url)\n        ret = {}\n        for e in r.json()['data']:\n            if e['state'] == 'offline':\n                continue\n            normalized = f\"{e['base-currency'].upper()}{SYMBOL_SEP}{e['quote-currency'].upper()}\"\n            symbol = f\"{e['base-currency']}{e['quote-currency']}\"\n            ret[normalized] = symbol\n        return ret\n    except Exception as why:\n        raise_failure_explanation('HUOBI', why, {url: r})\n\n\ndef huobi_symbols() -> Dict[str, str]:\n    return huobi_common_symbols('https://api.huobi.pro/v1/common/symbols')\n\n\ndef huobi_us_symbols() -> Dict[str, str]:\n    return huobi_common_symbols('https://api.huobi.com/v1/common/symbols')\n\n\ndef huobi_dm_symbols() -> Dict[str, str]:\n    \"\"\"\n    Mapping is, for instance: {\"BTC_CW\":\"BTC190816\"}\n    See comments in exchange/huobi_dm.py\n    \"\"\"\n    mapping = {\n        \"this_week\": \"CW\",\n        \"next_week\": \"NW\",\n        \"quarter\": \"CQ\",\n        \"next_quarter\": \"NQ\"\n    }\n    r = None\n    try:\n        r = requests.get('https://www.hbdm.com/api/v1/contract_contract_info')\n        symbols = {}\n        for e in r.json()['data']:\n            symbols[f\"{e['symbol']}_{mapping[e['contract_type']]}\"] = e['contract_code']\n            _exchange_info[HUOBI_DM]['tick_size'][e['contract_code']] = e['price_tick']\n            _exchange_info[HUOBI_DM]['short_code_mappings'][f\"{e['symbol']}_{mapping[e['contract_type']]}\"] = e['contract_code']\n        return symbols\n    except Exception as why:\n        raise_failure_explanation('HUOBI_DM', why, {\"\": r})\n\n\ndef huobi_swap_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.hbdm.com/swap-api/v1/swap_contract_info')\n        symbols = {}\n        for e in r.json()['data']:\n            symbols[e['contract_code']] = e['contract_code']\n            _exchange_info[HUOBI_SWAP]['tick_size'][e['contract_code']] = e['price_tick']\n        return symbols\n    except Exception as why:\n        raise_failure_explanation('HUOBI_SWAP', why, {\"\": r})\n\n\ndef okcoin_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://www.okcoin.com/api/spot/v3/instruments')\n        ret = {}\n        for e in r.json():\n            ret[e['instrument_id']] = e['instrument_id']\n            _exchange_info[OKCOIN]['tick_size'][e['instrument_id']] = e['tick_size']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('OKCOIN', why, {\"\": r})\n\n\ndef okex_symbols(*args) -> Dict[str, str]:\n    urls = ['https://www.okex.com/api/spot/v3/instruments',\n            'https://www.okex.com/api/swap/v3/instruments',\n            'https://www.okex.com/api/futures/v3/instruments']\n    urls = urls + okex_compute_option_urls_from_underlyings()\n\n    symbols: Dict[str, str] = {}\n    for u in urls:\n        time.sleep(0.2)\n        symbols.update(okex_symbols_from_one_url(u))\n\n    for symbol in symbols:\n        instrument_type = 'futures'\n        dash_count = symbol.count(get_symbol_separator())\n        if dash_count == 1:  # BTC-USDT\n            instrument_type = 'spot'\n        if dash_count == 4:  # BTC-USD-201225-35000-P\n            instrument_type = 'option'\n        if symbol[-4:] == \"SWAP\":  # BTC-USDT-SWAP\n            instrument_type = 'swap'\n\n        _exchange_info[OKEX]['instrument_type'][symbol] = instrument_type\n\n    return symbols\n\n\ndef okex_compute_option_urls_from_underlyings() -> List[str]:\n    url = 'https://www.okex.com/api/option/v3/underlying'\n    r = None\n    try:\n        r = requests.get(url)\n        return [f'https://www.okex.com/api/option/v3/instruments/{underlying}' for underlying in r.json()]\n    except Exception as why:\n        raise_failure_explanation('OKEX', why, {url: r})\n\n\ndef okex_symbols_from_one_url(url: str) -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get(url)\n        ret = {}\n        for e in r.json():\n            ret[e['instrument_id']] = e['instrument_id']\n            _exchange_info[OKEX]['tick_size'][e['instrument_id']] = e['tick_size']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('OKEX', why, {url: r})\n\n\ndef bittrex_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.bittrex.com/api/v1.1/public/getmarkets')\n        r = r.json()['result']\n        return {f\"{e['MarketCurrency']}{SYMBOL_SEP}{e['BaseCurrency']}\": e['MarketName'] for e in r if e['IsActive']}\n    except Exception as why:\n        raise_failure_explanation('BITTREX', why, {\"\": r})\n\n\ndef bitcoincom_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.exchange.bitcoin.com/api/2/public/symbol')\n        return {f\"{data['baseCurrency']}{SYMBOL_SEP}{data['quoteCurrency'].replace('USD', 'USDT')}\": data['id'] for data in r.json()}\n    except Exception as why:\n        raise_failure_explanation('BITCOINCOM', why, {\"\": r})\n\n\ndef bitmax_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://bitmax.io/api/pro/v1/products')\n        ret = {}\n        for entry in r.json()['data']:\n            # Only \"Normal\" status symbols are tradeable\n            if entry['status'] == 'Normal':\n                normalized = f\"{entry['baseAsset']}{SYMBOL_SEP}{entry['quoteAsset']}\"\n                ret[normalized] = entry['symbol']\n                _exchange_info[BITMAX]['tick_size'][normalized] = entry['tickSize']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('BITMAX', why, {\"\": r})\n\n\ndef upbit_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.upbit.com/v1/market/all')\n        return {f\"{data['market'].split('-')[1]}{SYMBOL_SEP}{data['market'].split('-')[0]}\": data['market'] for data in r.json()}\n    except Exception as why:\n        raise_failure_explanation('UPBIT', why, {\"\": r})\n\n\ndef blockchain_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get(\"https://api.blockchain.com/mercury-gateway/v1/instruments\")\n        return {data[\"symbol\"].replace(\"-\", SYMBOL_SEP): data[\"symbol\"] for data in r.json()}\n    except Exception as why:\n        raise_failure_explanation('BLOCKCHAIN', why, {\"\": r})\n\n\ndef gateio_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get(\"https://api.gateio.ws/api/v4/spot/currency_pairs\")\n        return {data[\"id\"].replace(\"_\", SYMBOL_SEP): data['id'] for data in r.json()}\n    except Exception as why:\n        raise_failure_explanation('GATEIO', why, {\"\": r})\n\n\ndef bitmex_symbols() -> Dict[str, str]:\n    r = None\n    ret = {}\n    try:\n        r = requests.get(\"https://www.bitmex.com/api/v1/instrument/active\")\n        for entry in r.json():\n            components = []\n            components.append(entry['rootSymbol'])\n            components.append(entry['quoteCurrency'])\n\n            if entry['expiry']:\n                components.append(entry['symbol'][-3:])\n\n            normalized = SYMBOL_SEP.join(components)\n            normalized = normalized.replace(\"XBT\", \"BTC\")\n            ret[normalized] = entry['symbol']\n            _exchange_info[BITMEX]['tick_size'][normalized] = entry['tickSize']\n\n            if entry['expiry']:\n                _exchange_info[BITMEX]['expiry'][normalized] = entry['expiry']\n\n        return ret\n    except Exception as why:\n        raise_failure_explanation('BITMEX', why, {\"\": r})\n\n\ndef deribit_symbols() -> Dict[str, str]:\n    url = r = None\n    ret = {}\n    try:\n        # TODO: get currencies from https://www.deribit.com/api/v2/public/get_currencies\n        currencies = ['BTC', 'ETH']\n        for c in currencies:\n            url = f\"https://www.deribit.com/api/v2/public/get_instruments?currency={c}&expired=false\"\n            r = requests.get(url)\n            for entry in r.json()['result']:\n                split = entry['instrument_name'].split(\"-\")\n                normalized = split[0] + SYMBOL_SEP + entry['quote_currency'] + \"-\" + '-'.join(split[1:])\n                ret[normalized] = entry['instrument_name']\n                _exchange_info[DERIBIT]['tick_size'][normalized] = entry['tick_size']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('DERIBIT', why, {url: r})\n\n\ndef kraken_future_symbols() -> Dict[str, str]:\n    r = None\n    ret = {}\n    try:\n        r = requests.get('https://futures.kraken.com/derivatives/api/v3/instruments')\n        data = r.json()['instruments']\n        for entry in data:\n            if not entry['tradeable']:\n                continue\n            normalized = entry['symbol'].upper().replace(\"_\", \"-\")\n            symbol = normalized[3:6] + SYMBOL_SEP + normalized[6:9]\n            normalized = normalized.replace(normalized[3:9], symbol)\n            normalized = normalized.replace('XBT', 'BTC')\n\n            _exchange_info[KRAKEN_FUTURES]['tick_size'][normalized] = entry['tickSize']\n            _exchange_info[KRAKEN_FUTURES]['contract_size'][normalized] = entry['contractSize']\n            _exchange_info[KRAKEN_FUTURES]['underlying'][normalized] = entry['underlying']\n            _exchange_info[KRAKEN_FUTURES]['product_type'][normalized] = _kraken_futures_product_type[normalized[:2]]\n            ret[normalized] = entry['symbol']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('KRAKEN_FUTURES', why, {\"\": r})\n\n\ndef probit_symbols() -> Dict[str, str]:\n    # doc: https://docs-en.probit.com/reference-link/market\n    r = None\n    try:\n        r = requests.get('https://api.probit.com/api/exchange/v1/market')\n        return {entry['id']: entry['id'] for entry in r.json()['data']}\n    except Exception as why:\n        raise_failure_explanation('PROBIT', why, {\"\": r})\n\n\ndef coingecko_normalize_symbol(symbol: str) -> str:\n    # keep digits, letters and dots, replace others by space\n    symbol = ''.join(c if c.isalnum() or c in ('.', '+') else ' ' for c in symbol)\n    return coingecko_normalize(symbol.upper())\n\n\ndef coingecko_normalize_name(name: str) -> str:\n    # keep digits and letters, replace others by space (except when only composed by upper case letters, digits and dots)\n    if not all(c.isupper() or c.isdigit() or c == '.' for c in name):\n        name = ''.join(c if c.isalnum() else ' ' for c in name)\n    return coingecko_normalize(name)\n\n\ndef coingecko_normalize(sym: str) -> str:\n    sym = sym.strip()\n    # do not concatenate numbers => separate them with a dot\n    sym = list(sym)\n    if len(sym) > 4:\n        for i in range(2, len(sym) - 1):\n            if sym[i] == ' ' and sym[i - 1].isdigit() and sym[i + 1].isdigit():\n                sym[i] = '.'\n    sym = ''.join(sym)\n    # concatenate space-separated words => use CamelCase to distinguish the words\n    if ' ' in sym:\n        if sum(c.islower() for c in sym):  # if there is at least one lower case letter\n            sym = ' '.join(word[0].upper() + word[1:] for word in sym.split())  # Just capitalize initial letter of each word\n        else:  # CoinGecko may provide full upper-case as for \"THE STONE COIN\"\n            sym = string.capwords(sym)  # capwords converts \"THE STONE COIN\" to \"The Stone Coin\"\n        sym = sym.replace(' ', '')  # concatenate words\n    return sym\n\n\ndef is_name_short(coin: dict) -> bool:\n    \"\"\"return True if the coin name is enough short compared to the coin symbol.\"\"\"\n    return len(coin['name']) <= max(5, len(coin['symbol']) + 1)\n\n\ndef has_many_caps(name: str) -> bool:\n    \"\"\"return True if the symbol contains enough upper case letters, False if empty.\"\"\"\n    return str and sum(c.islower() for c in name) < (len(name) / 2)\n\n\ndef coingecko_normalize_all(coin: dict):\n    SYMBOL_TO_NORMALIZED = {'miota': 'IOTA'}\n    normalized = SYMBOL_TO_NORMALIZED.get(coin['symbol'])\n    if normalized:\n        coin['ns'] = coin['nn'] = normalized\n        return normalized\n\n    # ns = normalized symbol, nn = normalized name\n    coin['ns'] = coingecko_normalize_symbol(coin['symbol'])\n\n    ID_SUFFIX = '-bitcoin-token'\n    if coin['id'][-len(ID_SUFFIX):] == ID_SUFFIX:\n        coin['nn'] = 'BTC' + coin['ns']\n        return coin['nn']\n\n    name = coin['name']\n\n    prefixes = ('The ', 'the ')\n    for p in prefixes:\n        if name[:len(p)] == p:\n            coin['reduced-name'] = True\n            name = name[len(p):]\n            break\n\n    suffixes = ('coin', 'coins', 'money', 'finance', 'protocol', 'reward', 'rewards', 'token')\n    for s in suffixes:\n        if len(name) > len(s) and name[-len(s):].lower() == s:\n            # but keep suffix when lower-case concatenated\n            if name[-len(s)].islower() and name[-len(s) - 1] != ' ':\n                continue\n            # also keep suffix to avoid confusing nam: \"Bitcoin Token\" -> \"Bitcoin\"\n            if name[:-len(s)].strip().lower() == 'bitcoin':\n                continue\n            coin['reduced-name'] = True\n            name = name[:-len(s)]\n            break\n\n    coin['nn'] = coingecko_normalize_name(name)\n\n    if len(coin['nn']) < len(coin['ns']):\n        if 'reduced-name' in coin:\n            coin['reduced-name'] = False\n            name = coin['name']\n            coin['nn'] = coingecko_normalize_name(name)\n        elif not has_many_caps(name):\n            return coin['ns']\n\n    if not coin['ns']:  # coin['symbol'] may be an emoji that is striped when normalized\n        return coin['nn']\n\n    if coin.get('reduced-name') and coin['ns'].upper() != coin['nn'].upper():\n        return coin['ns']\n\n    i = coin['nn'].find('.')  # if there is a dot in normalized name => prefer the normalized symbol\n    if i >= 0:\n        if i > 1 and coin['nn'][i - 1].isdigit() and coin['nn'][i + 1].isdigit():\n            pass  # except when the dot separates digits\n        else:\n            return coin['ns']\n\n    if is_name_short(coin) and has_many_caps(name):\n        return coin['nn']\n\n    if 1.5 * len(coin['ns']) > len(coin['nn']) and any(c.islower() for c in coin['ns']):\n        return coin['nn']\n\n    return coin['ns']\n\n\ndef coingecko_symbols() -> Dict[str, str]:\n    r = None\n    intermediate = defaultdict(list)\n    try:\n        r = requests.get('https://api.coingecko.com/api/v3/coins/list')\n        all_coins = r.json()\n        # First pass: generate & compare normalized symbol/name, and then select the most pertinent\n        for coin in all_coins:\n            normalized = coingecko_normalize_all(coin)\n            intermediate[normalized].append(coin)\n            # Above line keeps together the coins having the same normalized symbol.\n            # To reduce collision, the coin['name'] is sometimes used in lieu of the coin['symbol'].\n            # The coin['name'] is not capitalized because lower case letters may be meaningful: cETH, yUSD, DATx, zLOT\n    except Exception as why:\n        raise_failure_explanation('COINGECKO', why, {\"\": r})\n\n    final = coingecko_second_pass(intermediate)\n    return coingecko_third_pass(final)\n\n\ndef coingecko_second_pass(intermediate: Dict[str, List[dict]]) -> Dict[str, List[dict]]:\n    # Second pass: fixes most of the symbol collisions\n    final = defaultdict(list)\n    for normalized, coins in intermediate.items():\n        if len(coins) == 1:\n            final[normalized].append(coins[0])\n            continue\n        set_normalized = False\n        for i in range(len(coins)):\n            if normalized == coins[i]['nn']:\n                coin = coins.pop(i)\n                final[normalized].append(coin)\n                set_normalized = True\n                break\n        rest: List[dict] = []\n        for coin in coins:\n            if '%' in coin['name']:\n                if len(coins) == 1:\n                    n = coin['ns']\n                else:\n                    n = coingecko_normalize_name(coin['id'])\n                final[n].append(coin)\n            else:\n                rest.append(coin)\n        if not rest:\n            continue\n        if not set_normalized:\n            rest.sort(key=lambda coin: len(coin['nn']), reverse=True)  # sort by the length of the normalized name\n            coin = rest.pop(0)\n            final[normalized].append(coin)\n        for coin in rest:\n            if coin['nn'] not in intermediate:\n                n = coin['nn']\n            elif coin.get('reduced-name'):\n                n = coingecko_normalize_name(coin['name'])\n            else:\n                n = coingecko_normalize_name(coin['id'])\n            final[n].append(coin)\n    return final\n\n\ndef coingecko_third_pass(final: Dict[str, List[dict]]) -> Dict[str, str]:\n    # Third pass: fixes some remaining collisions and fills the result\n    symbols = {}\n    for normalized, coins in final.items():\n        if len(coins) == 1:\n            symbols[normalized] = coins[0]['id']\n            continue\n        set_normalized = False\n        for i in range(len(coins)):\n            if normalized == coins[i]['nn']:\n                coin = coins.pop(i)\n                symbols[normalized] = coin['id']\n                set_normalized = True\n                break\n        rest: List[dict] = []\n        for coin in coins:\n            if '%' in coin['name']:\n                if len(coins) == 1:\n                    n = coin['ns']\n                else:\n                    n = coingecko_normalize_name(coin['id'])\n                symbols[n] = coin['id']\n            else:\n                rest.append(coin)\n        if not rest:\n            continue\n        if not set_normalized:\n            rest.sort(key=lambda coin: len(coin['nn']), reverse=True)  # sort by the length of the normalized name\n            coin = rest.pop(0)\n            symbols[normalized] = coin['id']\n        for coin in rest:\n            if coin['nn'] not in final:\n                n = coin['nn']\n            elif coin.get('reduced-name'):\n                n = coingecko_normalize_name(coin['name'])\n            else:\n                n = coingecko_normalize_name(coin['id'])\n            symbols[n] = coin['id']\n    return symbols\n\n\ndef whale_alert_coins(key_id: str) -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get(f'https://api.whale-alert.io/v1/status?api_key={key_id}')\n        # Same symbols, but on different blockchains (for instance USDT), are naturally overwritten.\n        return {s.upper(): s for b in r.json()['blockchains'] for s in b['symbols'] if s}\n    except Exception as why:\n        raise_failure_explanation('WHALES_ALERT', why, {\"\": r})\n\n\n_exchange_function_map = {\n    BITFINEX: bitfinex_symbols,\n    BITFLYER: bitflyer_symbols,\n    COINBASE: coinbase_symbols,\n    GEMINI: gemini_symbols,\n    HITBTC: hitbtc_symbols,\n    POLONIEX: poloniex_symbols,\n    PROBIT: probit_symbols,\n    BITSTAMP: bitstamp_symbols,\n    KRAKEN: kraken_symbols,\n    KRAKEN + 'REST': kraken_rest_symbols,\n    BINANCE: binance_symbols,\n    BINANCE_US: binance_us_symbols,\n    BINANCE_FUTURES: binance_futures_symbols,\n    BINANCE_DELIVERY: binance_delivery_symbols,\n    BLOCKCHAIN: blockchain_symbols,\n    EXX: exx_symbols,\n    HUOBI: huobi_symbols,\n    HUOBI_DM: huobi_dm_symbols,\n    HUOBI_SWAP: huobi_swap_symbols,\n    OKCOIN: okcoin_symbols,\n    OKEX: okex_symbols,\n    BYBIT: bybit_symbols,\n    FTX: ftx_symbols,\n    FTX_US: ftx_us_symbols,\n    BITTREX: bittrex_symbols,\n    BITCOINCOM: bitcoincom_symbols,\n    BITMAX: bitmax_symbols,\n    UPBIT: upbit_symbols,\n    GATEIO: gateio_symbols,\n    BITMEX: bitmex_symbols,\n    DERIBIT: deribit_symbols,\n    KRAKEN_FUTURES: kraken_future_symbols,\n    COINGECKO: coingecko_symbols,\n    WHALE_ALERT: whale_alert_coins\n}\n",
        "source_code_len": 30534,
        "target_code": "associated with this software.\n'''\nfrom typing import Dict, Tuple\n\n\nclass _Symbols:\n    def __init__(self):\n        self.data = {}\n\n    def set(self, exchange: str, normalized: dict, exchange_info: dict):\n        self.data[exchange] = {}\n        self.data[exchange]['normalized'] = normalized\n        self.data[exchange]['info'] = exchange_info\n\n    def get(self, exchange: str) -> Tuple[Dict, Dict]:\n        return self.data[exchange]['normalized'], self.data[exchange]['info']\n\n    def populated(self, exchange: str) -> bool:\n        return exchange in self.data\n\n\nSymbols = _Symbols()\n",
        "target_code_len": 588,
        "diff_format": "@@ -5,845 +5,22 @@\n associated with this software.\n+'''\n+from typing import Dict, Tuple\n \n \n-Symbol generation code for exchanges\n-'''\n+class _Symbols:\n+    def __init__(self):\n+        self.data = {}\n \n-import logging\n-import string\n-import time\n-from collections import defaultdict\n-from typing import Dict, List, Optional, Tuple\n+    def set(self, exchange: str, normalized: dict, exchange_info: dict):\n+        self.data[exchange] = {}\n+        self.data[exchange]['normalized'] = normalized\n+        self.data[exchange]['info'] = exchange_info\n \n-import requests\n-from requests import Response\n+    def get(self, exchange: str) -> Tuple[Dict, Dict]:\n+        return self.data[exchange]['normalized'], self.data[exchange]['info']\n \n-from cryptofeed.defines import *\n+    def populated(self, exchange: str) -> bool:\n+        return exchange in self.data\n \n \n-LOG = logging.getLogger('feedhandler')\n-\n-SYMBOL_SEP = '-'\n-\n-_symbols_retrieval_cache: Dict[str, Dict[str, str]] = {}\n-_exchange_info = defaultdict(lambda: defaultdict(dict))\n-\n-\n-_kraken_futures_product_type = {\n-    'FI': 'Inverse Futures',\n-    'FV': 'Vanilla Futures',\n-    'PI': 'Perpetual Inverse Futures',\n-    'PV': 'Perpetual Vanilla Futures',\n-    'IN': 'Real Time Index',\n-    'RR': 'Reference Rate',\n-}\n-\n-\n-def raise_failure_explanation(feed_id: str, exception: BaseException, responses: Dict[str, Optional[Response]]):\n-    LOG.critical('%s: encountered %r while processing response from exchange API', feed_id, exception)\n-    if len(responses) > 1:\n-        LOG.critical('%s: content of one of the %s responses was unexpected', feed_id, len(responses))\n-    for url, r in responses.items():\n-        if url:\n-            LOG.critical('%s: requested URL: %s', feed_id, url)\n-        if r:\n-            LOG.critical('%s: unexpected response: %s', feed_id, r.text)\n-    raise ValueError(f'Cryptofeed stopped because of an unexpected response from {feed_id}') from exception\n-\n-\n-def set_symbol_separator(separator: str):\n-    global SYMBOL_SEP\n-    SYMBOL_SEP = separator\n-\n-\n-def get_symbol_separator() -> str:\n-    global SYMBOL_SEP\n-    return SYMBOL_SEP\n-\n-\n-def gen_symbols(exchange: str, key_id=None) -> Dict[str, str]:\n-    if exchange not in _symbols_retrieval_cache:\n-        LOG.info(\"%s: Getting list of symbols\", exchange)\n-        symbols = _exchange_function_map[exchange](key_id) if key_id else _exchange_function_map[exchange]()\n-        LOG.info(\"%s: %s symbols\", exchange, len(symbols))\n-\n-        # log all retrieved symbols using debug level\n-        for normalized, exch_sym in sorted(symbols.items()):\n-            LOG.debug('%s: id-from-exch -> normalized: %-35s-> %s', exchange, exch_sym, normalized)\n-\n-        _symbols_retrieval_cache[exchange] = symbols\n-    return _symbols_retrieval_cache[exchange]\n-\n-\n-def _binance_symbols(endpoint: str, exchange: str):\n-    r = None\n-    try:\n-        ret = {}\n-        r = requests.get(endpoint)\n-        for symbol in r.json()['symbols']:\n-            if symbol.get('status', 'TRADING') != \"TRADING\":\n-                continue\n-            if symbol.get('contractStatus', 'TRADING') != \"TRADING\":\n-                continue\n-            split = len(symbol['baseAsset'])\n-            normalized = symbol['symbol'][:split] + SYMBOL_SEP + symbol['symbol'][split:]\n-            ret[normalized] = symbol['symbol']\n-            _exchange_info[exchange]['tick_size'][normalized] = symbol['filters'][0]['tickSize']\n-            if \"contractType\" in symbol:\n-                _exchange_info[exchange]['contract_type'][normalized] = symbol['contractType']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation(exchange, why, {endpoint: r})\n-\n-\n-def binance_symbols() -> Dict[str, str]:\n-    return _binance_symbols('https://api.binance.com/api/v3/exchangeInfo', BINANCE)\n-\n-\n-def binance_us_symbols() -> Dict[str, str]:\n-    return _binance_symbols('https://api.binance.us/api/v3/exchangeInfo', BINANCE_US)\n-\n-\n-def binance_futures_symbols() -> Dict[str, str]:\n-    base = _binance_symbols('https://fapi.binance.com/fapi/v1/exchangeInfo', BINANCE_FUTURES)\n-    add = {}\n-    for symbol, orig in base.items():\n-        if \"_\" in orig:\n-            continue\n-        add[f\"{symbol}-PINDEX\"] = f\"p{orig}\"\n-    base.update(add)\n-    return base\n-\n-\n-def binance_delivery_symbols() -> Dict[str, str]:\n-    return _binance_symbols('https://dapi.binance.com/dapi/v1/exchangeInfo', BINANCE_DELIVERY)\n-\n-\n-def bitfinex_symbols() -> Dict[str, str]:\n-    # doc: https://docs.bitfinex.com/docs/ws-general#supported-pairs\n-    r1 = r2 = None\n-    try:\n-        r1 = requests.get('https://api.bitfinex.com/v2/tickers?symbols=ALL')\n-        r2 = requests.get('https://api-pub.bitfinex.com/v2/conf/pub:map:currency:sym')\n-        tickers: List[List[str]] = r1.json()\n-        norm: List[Tuple[str, str]] = r2.json()[0]\n-        norm: Dict[str, str] = dict(norm)\n-        for k, v in dict(norm).items():\n-            if k[-2:] == 'F0' or '-' in v:  # Do not convert BTCF0 -> BTC or PBTCETH -> PBTC-ETH\n-                del norm[k]\n-        norm['BCHN'] = 'BCH'  # Bitfinex uses BCHN, other exchanges use BCH\n-\n-        ret = {}\n-        for symbol in [t[0] for t in tickers]:\n-            if symbol[0] == 'f':\n-                normalized = norm.get(symbol[1:], symbol[1:])\n-            else:\n-                if len(symbol) == 7:\n-                    base, quote = symbol[1:4], symbol[4:]\n-                else:\n-                    base, quote = symbol[1:].split(':')\n-                    assert ':' in symbol\n-                normalized = norm.get(base, base) + SYMBOL_SEP + norm.get(quote, quote)\n-            ret[normalized.upper()] = symbol\n-        return ret\n-    except ValueError as why:\n-        raise_failure_explanation('BITFINEX', why, {\"tickers?symbols=ALL\": r1, \"pub:map:currency:sym\": r2})\n-\n-\n-def bitflyer_symbols() -> Dict[str, str]:\n-    endpoint = r = None\n-    try:\n-        ret = {}\n-        endpoints = ['https://api.bitflyer.com/v1/getmarkets/eu', 'https://api.bitflyer.com/v1/getmarkets/usa', 'https://api.bitflyer.com/v1/getmarkets']\n-        for endpoint in endpoints:\n-            r = requests.get(endpoint)\n-            for entry in r.json():\n-                normalized = entry['product_code'].replace(\"_\", SYMBOL_SEP)\n-                ret[normalized] = entry['product_code']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('BITFLYER', why, {endpoint: r})\n-\n-\n-def bybit_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.bybit.com/v2/public/symbols')\n-        ret = {}\n-        for symbol in r.json()['result']:\n-            quote = symbol['quote_currency']\n-            if not symbol['name'].endswith(quote):\n-                base, contract = symbol['name'].split(quote)\n-                normalized = f\"{base}{SYMBOL_SEP}{quote}-{contract}\"\n-            else:\n-                normalized = f\"{symbol['base_currency']}{SYMBOL_SEP}{quote}\"\n-            ret[normalized] = symbol['name']\n-            _exchange_info[BYBIT]['tick_size'][normalized] = symbol['price_filter']['tick_size']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('BYBIT', why, {\"\": r})\n-\n-\n-def _ftx_helper(endpoint: str, exchange: str):\n-    r = None\n-    try:\n-        r = requests.get(endpoint)\n-        ret = {}\n-        for data in r.json()['result']:\n-            normalized = data['name'].replace(\"/\", SYMBOL_SEP)\n-            symbol = data['name']\n-            ret[normalized] = symbol\n-            _exchange_info[exchange]['tick_size'][normalized] = data['priceIncrement']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation(exchange, why, {endpoint: r})\n-\n-\n-def ftx_symbols() -> Dict[str, str]:\n-    return _ftx_helper('https://ftx.com/api/markets', FTX)\n-\n-\n-def ftx_us_symbols() -> Dict[str, str]:\n-    return _ftx_helper('https://ftx.us/api/markets', FTX_US)\n-\n-\n-def coinbase_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.pro.coinbase.com/products')\n-        ret = {}\n-        for data in r.json():\n-            normalized = data['id'].replace(\"-\", SYMBOL_SEP)\n-            ret[normalized] = data['id']\n-            _exchange_info[COINBASE]['tick_size'][normalized] = data['quote_increment']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('COINBASE', why, {\"\": r})\n-\n-\n-def gemini_symbols(*args) -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.gemini.com/v1/symbols')\n-        ret = {}\n-        for symbol in r.json():\n-            std = f\"{symbol[:-3]}{SYMBOL_SEP}{symbol[-3:]}\"\n-            std = std.upper()\n-            ret[std] = symbol.upper()\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('GEMINI', why, {\"\": r})\n-\n-\n-def hitbtc_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        ret = {}\n-        r = requests.get('https://api.hitbtc.com/api/2/public/symbol')\n-        for symbol in r.json():\n-            split = len(symbol['baseCurrency'])\n-            normalized = symbol['id'][:split] + SYMBOL_SEP + symbol['id'][split:]\n-            ret[normalized] = symbol['id']\n-            _exchange_info[HITBTC]['tick_size'][normalized] = symbol['tickSize']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('HITBTC', why, {\"\": r})\n-\n-\n-def poloniex_id_symbol_mapping():\n-    r = None\n-    try:\n-        r = requests.get('https://poloniex.com/public?command=returnTicker')\n-        symbols = r.json()\n-        ret = {}\n-        for symbol in symbols:\n-            ret[symbols[symbol]['id']] = symbol\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('POLONIEX', why, {\"\": r})\n-\n-\n-def poloniex_symbols() -> Dict[str, str]:\n-    ret = {}\n-    for _, value in poloniex_id_symbol_mapping().items():\n-        std = value.replace(\"STR\", \"XLM\")\n-        quote, base = std.split(\"_\")\n-        ret[quote + SYMBOL_SEP + base] = value\n-    return ret\n-\n-\n-def bitstamp_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://www.bitstamp.net/api/v2/trading-pairs-info/')\n-        ret = {}\n-        for data in r.json():\n-            normalized = data['name'].replace(\"/\", SYMBOL_SEP)\n-            symbol = data['url_symbol']\n-            ret[normalized] = symbol\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('BITSTAMP', why, {\"\": r})\n-\n-\n-def kraken_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.kraken.com/0/public/AssetPairs')\n-        data = r.json()\n-        ret = {}\n-        for symbol in data['result']:\n-            if 'wsname' not in data['result'][symbol] or '.d' in symbol:\n-                # https://blog.kraken.com/post/259/introducing-the-kraken-dark-pool/\n-                # .d is for dark pool symbols\n-                continue\n-\n-            base, quote = data['result'][symbol]['wsname'].split(\"/\")\n-\n-            normalized = f\"{base}{SYMBOL_SEP}{quote}\"\n-            exch = data['result'][symbol]['wsname']\n-            normalized = normalized.replace('XBT', 'BTC')\n-            normalized = normalized.replace('XDG', 'DOG')\n-            ret[normalized] = exch\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('KRAKEN', why, {\"\": r})\n-\n-\n-def kraken_rest_symbols() -> Dict[str, str]:\n-    return {normalized: exchange.replace(\"/\", \"\") for normalized, exchange in kraken_symbols().items()}\n-\n-\n-def exx_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.exx.com/data/v1/tickers')\n-        exchange = [key.upper() for key in r.json().keys()]\n-        symbols = [key.replace(\"_\", SYMBOL_SEP) for key in exchange]\n-        return dict(zip(symbols, exchange))\n-    except Exception as why:\n-        raise_failure_explanation('EXX', why, {\"\": r})\n-\n-\n-def huobi_common_symbols(url: str):\n-    r = None\n-    try:\n-        r = requests.get(url)\n-        ret = {}\n-        for e in r.json()['data']:\n-            if e['state'] == 'offline':\n-                continue\n-            normalized = f\"{e['base-currency'].upper()}{SYMBOL_SEP}{e['quote-currency'].upper()}\"\n-            symbol = f\"{e['base-currency']}{e['quote-currency']}\"\n-            ret[normalized] = symbol\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('HUOBI', why, {url: r})\n-\n-\n-def huobi_symbols() -> Dict[str, str]:\n-    return huobi_common_symbols('https://api.huobi.pro/v1/common/symbols')\n-\n-\n-def huobi_us_symbols() -> Dict[str, str]:\n-    return huobi_common_symbols('https://api.huobi.com/v1/common/symbols')\n-\n-\n-def huobi_dm_symbols() -> Dict[str, str]:\n-    \"\"\"\n-    Mapping is, for instance: {\"BTC_CW\":\"BTC190816\"}\n-    See comments in exchange/huobi_dm.py\n-    \"\"\"\n-    mapping = {\n-        \"this_week\": \"CW\",\n-        \"next_week\": \"NW\",\n-        \"quarter\": \"CQ\",\n-        \"next_quarter\": \"NQ\"\n-    }\n-    r = None\n-    try:\n-        r = requests.get('https://www.hbdm.com/api/v1/contract_contract_info')\n-        symbols = {}\n-        for e in r.json()['data']:\n-            symbols[f\"{e['symbol']}_{mapping[e['contract_type']]}\"] = e['contract_code']\n-            _exchange_info[HUOBI_DM]['tick_size'][e['contract_code']] = e['price_tick']\n-            _exchange_info[HUOBI_DM]['short_code_mappings'][f\"{e['symbol']}_{mapping[e['contract_type']]}\"] = e['contract_code']\n-        return symbols\n-    except Exception as why:\n-        raise_failure_explanation('HUOBI_DM', why, {\"\": r})\n-\n-\n-def huobi_swap_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.hbdm.com/swap-api/v1/swap_contract_info')\n-        symbols = {}\n-        for e in r.json()['data']:\n-            symbols[e['contract_code']] = e['contract_code']\n-            _exchange_info[HUOBI_SWAP]['tick_size'][e['contract_code']] = e['price_tick']\n-        return symbols\n-    except Exception as why:\n-        raise_failure_explanation('HUOBI_SWAP', why, {\"\": r})\n-\n-\n-def okcoin_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://www.okcoin.com/api/spot/v3/instruments')\n-        ret = {}\n-        for e in r.json():\n-            ret[e['instrument_id']] = e['instrument_id']\n-            _exchange_info[OKCOIN]['tick_size'][e['instrument_id']] = e['tick_size']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('OKCOIN', why, {\"\": r})\n-\n-\n-def okex_symbols(*args) -> Dict[str, str]:\n-    urls = ['https://www.okex.com/api/spot/v3/instruments',\n-            'https://www.okex.com/api/swap/v3/instruments',\n-            'https://www.okex.com/api/futures/v3/instruments']\n-    urls = urls + okex_compute_option_urls_from_underlyings()\n-\n-    symbols: Dict[str, str] = {}\n-    for u in urls:\n-        time.sleep(0.2)\n-        symbols.update(okex_symbols_from_one_url(u))\n-\n-    for symbol in symbols:\n-        instrument_type = 'futures'\n-        dash_count = symbol.count(get_symbol_separator())\n-        if dash_count == 1:  # BTC-USDT\n-            instrument_type = 'spot'\n-        if dash_count == 4:  # BTC-USD-201225-35000-P\n-            instrument_type = 'option'\n-        if symbol[-4:] == \"SWAP\":  # BTC-USDT-SWAP\n-            instrument_type = 'swap'\n-\n-        _exchange_info[OKEX]['instrument_type'][symbol] = instrument_type\n-\n-    return symbols\n-\n-\n-def okex_compute_option_urls_from_underlyings() -> List[str]:\n-    url = 'https://www.okex.com/api/option/v3/underlying'\n-    r = None\n-    try:\n-        r = requests.get(url)\n-        return [f'https://www.okex.com/api/option/v3/instruments/{underlying}' for underlying in r.json()]\n-    except Exception as why:\n-        raise_failure_explanation('OKEX', why, {url: r})\n-\n-\n-def okex_symbols_from_one_url(url: str) -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get(url)\n-        ret = {}\n-        for e in r.json():\n-            ret[e['instrument_id']] = e['instrument_id']\n-            _exchange_info[OKEX]['tick_size'][e['instrument_id']] = e['tick_size']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('OKEX', why, {url: r})\n-\n-\n-def bittrex_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.bittrex.com/api/v1.1/public/getmarkets')\n-        r = r.json()['result']\n-        return {f\"{e['MarketCurrency']}{SYMBOL_SEP}{e['BaseCurrency']}\": e['MarketName'] for e in r if e['IsActive']}\n-    except Exception as why:\n-        raise_failure_explanation('BITTREX', why, {\"\": r})\n-\n-\n-def bitcoincom_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.exchange.bitcoin.com/api/2/public/symbol')\n-        return {f\"{data['baseCurrency']}{SYMBOL_SEP}{data['quoteCurrency'].replace('USD', 'USDT')}\": data['id'] for data in r.json()}\n-    except Exception as why:\n-        raise_failure_explanation('BITCOINCOM', why, {\"\": r})\n-\n-\n-def bitmax_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://bitmax.io/api/pro/v1/products')\n-        ret = {}\n-        for entry in r.json()['data']:\n-            # Only \"Normal\" status symbols are tradeable\n-            if entry['status'] == 'Normal':\n-                normalized = f\"{entry['baseAsset']}{SYMBOL_SEP}{entry['quoteAsset']}\"\n-                ret[normalized] = entry['symbol']\n-                _exchange_info[BITMAX]['tick_size'][normalized] = entry['tickSize']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('BITMAX', why, {\"\": r})\n-\n-\n-def upbit_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.upbit.com/v1/market/all')\n-        return {f\"{data['market'].split('-')[1]}{SYMBOL_SEP}{data['market'].split('-')[0]}\": data['market'] for data in r.json()}\n-    except Exception as why:\n-        raise_failure_explanation('UPBIT', why, {\"\": r})\n-\n-\n-def blockchain_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get(\"https://api.blockchain.com/mercury-gateway/v1/instruments\")\n-        return {data[\"symbol\"].replace(\"-\", SYMBOL_SEP): data[\"symbol\"] for data in r.json()}\n-    except Exception as why:\n-        raise_failure_explanation('BLOCKCHAIN', why, {\"\": r})\n-\n-\n-def gateio_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get(\"https://api.gateio.ws/api/v4/spot/currency_pairs\")\n-        return {data[\"id\"].replace(\"_\", SYMBOL_SEP): data['id'] for data in r.json()}\n-    except Exception as why:\n-        raise_failure_explanation('GATEIO', why, {\"\": r})\n-\n-\n-def bitmex_symbols() -> Dict[str, str]:\n-    r = None\n-    ret = {}\n-    try:\n-        r = requests.get(\"https://www.bitmex.com/api/v1/instrument/active\")\n-        for entry in r.json():\n-            components = []\n-            components.append(entry['rootSymbol'])\n-            components.append(entry['quoteCurrency'])\n-\n-            if entry['expiry']:\n-                components.append(entry['symbol'][-3:])\n-\n-            normalized = SYMBOL_SEP.join(components)\n-            normalized = normalized.replace(\"XBT\", \"BTC\")\n-            ret[normalized] = entry['symbol']\n-            _exchange_info[BITMEX]['tick_size'][normalized] = entry['tickSize']\n-\n-            if entry['expiry']:\n-                _exchange_info[BITMEX]['expiry'][normalized] = entry['expiry']\n-\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('BITMEX', why, {\"\": r})\n-\n-\n-def deribit_symbols() -> Dict[str, str]:\n-    url = r = None\n-    ret = {}\n-    try:\n-        # TODO: get currencies from https://www.deribit.com/api/v2/public/get_currencies\n-        currencies = ['BTC', 'ETH']\n-        for c in currencies:\n-            url = f\"https://www.deribit.com/api/v2/public/get_instruments?currency={c}&expired=false\"\n-            r = requests.get(url)\n-            for entry in r.json()['result']:\n-                split = entry['instrument_name'].split(\"-\")\n-                normalized = split[0] + SYMBOL_SEP + entry['quote_currency'] + \"-\" + '-'.join(split[1:])\n-                ret[normalized] = entry['instrument_name']\n-                _exchange_info[DERIBIT]['tick_size'][normalized] = entry['tick_size']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('DERIBIT', why, {url: r})\n-\n-\n-def kraken_future_symbols() -> Dict[str, str]:\n-    r = None\n-    ret = {}\n-    try:\n-        r = requests.get('https://futures.kraken.com/derivatives/api/v3/instruments')\n-        data = r.json()['instruments']\n-        for entry in data:\n-            if not entry['tradeable']:\n-                continue\n-            normalized = entry['symbol'].upper().replace(\"_\", \"-\")\n-            symbol = normalized[3:6] + SYMBOL_SEP + normalized[6:9]\n-            normalized = normalized.replace(normalized[3:9], symbol)\n-            normalized = normalized.replace('XBT', 'BTC')\n-\n-            _exchange_info[KRAKEN_FUTURES]['tick_size'][normalized] = entry['tickSize']\n-            _exchange_info[KRAKEN_FUTURES]['contract_size'][normalized] = entry['contractSize']\n-            _exchange_info[KRAKEN_FUTURES]['underlying'][normalized] = entry['underlying']\n-            _exchange_info[KRAKEN_FUTURES]['product_type'][normalized] = _kraken_futures_product_type[normalized[:2]]\n-            ret[normalized] = entry['symbol']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('KRAKEN_FUTURES', why, {\"\": r})\n-\n-\n-def probit_symbols() -> Dict[str, str]:\n-    # doc: https://docs-en.probit.com/reference-link/market\n-    r = None\n-    try:\n-        r = requests.get('https://api.probit.com/api/exchange/v1/market')\n-        return {entry['id']: entry['id'] for entry in r.json()['data']}\n-    except Exception as why:\n-        raise_failure_explanation('PROBIT', why, {\"\": r})\n-\n-\n-def coingecko_normalize_symbol(symbol: str) -> str:\n-    # keep digits, letters and dots, replace others by space\n-    symbol = ''.join(c if c.isalnum() or c in ('.', '+') else ' ' for c in symbol)\n-    return coingecko_normalize(symbol.upper())\n-\n-\n-def coingecko_normalize_name(name: str) -> str:\n-    # keep digits and letters, replace others by space (except when only composed by upper case letters, digits and dots)\n-    if not all(c.isupper() or c.isdigit() or c == '.' for c in name):\n-        name = ''.join(c if c.isalnum() else ' ' for c in name)\n-    return coingecko_normalize(name)\n-\n-\n-def coingecko_normalize(sym: str) -> str:\n-    sym = sym.strip()\n-    # do not concatenate numbers => separate them with a dot\n-    sym = list(sym)\n-    if len(sym) > 4:\n-        for i in range(2, len(sym) - 1):\n-            if sym[i] == ' ' and sym[i - 1].isdigit() and sym[i + 1].isdigit():\n-                sym[i] = '.'\n-    sym = ''.join(sym)\n-    # concatenate space-separated words => use CamelCase to distinguish the words\n-    if ' ' in sym:\n-        if sum(c.islower() for c in sym):  # if there is at least one lower case letter\n-            sym = ' '.join(word[0].upper() + word[1:] for word in sym.split())  # Just capitalize initial letter of each word\n-        else:  # CoinGecko may provide full upper-case as for \"THE STONE COIN\"\n-            sym = string.capwords(sym)  # capwords converts \"THE STONE COIN\" to \"The Stone Coin\"\n-        sym = sym.replace(' ', '')  # concatenate words\n-    return sym\n-\n-\n-def is_name_short(coin: dict) -> bool:\n-    \"\"\"return True if the coin name is enough short compared to the coin symbol.\"\"\"\n-    return len(coin['name']) <= max(5, len(coin['symbol']) + 1)\n-\n-\n-def has_many_caps(name: str) -> bool:\n-    \"\"\"return True if the symbol contains enough upper case letters, False if empty.\"\"\"\n-    return str and sum(c.islower() for c in name) < (len(name) / 2)\n-\n-\n-def coingecko_normalize_all(coin: dict):\n-    SYMBOL_TO_NORMALIZED = {'miota': 'IOTA'}\n-    normalized = SYMBOL_TO_NORMALIZED.get(coin['symbol'])\n-    if normalized:\n-        coin['ns'] = coin['nn'] = normalized\n-        return normalized\n-\n-    # ns = normalized symbol, nn = normalized name\n-    coin['ns'] = coingecko_normalize_symbol(coin['symbol'])\n-\n-    ID_SUFFIX = '-bitcoin-token'\n-    if coin['id'][-len(ID_SUFFIX):] == ID_SUFFIX:\n-        coin['nn'] = 'BTC' + coin['ns']\n-        return coin['nn']\n-\n-    name = coin['name']\n-\n-    prefixes = ('The ', 'the ')\n-    for p in prefixes:\n-        if name[:len(p)] == p:\n-            coin['reduced-name'] = True\n-            name = name[len(p):]\n-            break\n-\n-    suffixes = ('coin', 'coins', 'money', 'finance', 'protocol', 'reward', 'rewards', 'token')\n-    for s in suffixes:\n-        if len(name) > len(s) and name[-len(s):].lower() == s:\n-            # but keep suffix when lower-case concatenated\n-            if name[-len(s)].islower() and name[-len(s) - 1] != ' ':\n-                continue\n-            # also keep suffix to avoid confusing nam: \"Bitcoin Token\" -> \"Bitcoin\"\n-            if name[:-len(s)].strip().lower() == 'bitcoin':\n-                continue\n-            coin['reduced-name'] = True\n-            name = name[:-len(s)]\n-            break\n-\n-    coin['nn'] = coingecko_normalize_name(name)\n-\n-    if len(coin['nn']) < len(coin['ns']):\n-        if 'reduced-name' in coin:\n-            coin['reduced-name'] = False\n-            name = coin['name']\n-            coin['nn'] = coingecko_normalize_name(name)\n-        elif not has_many_caps(name):\n-            return coin['ns']\n-\n-    if not coin['ns']:  # coin['symbol'] may be an emoji that is striped when normalized\n-        return coin['nn']\n-\n-    if coin.get('reduced-name') and coin['ns'].upper() != coin['nn'].upper():\n-        return coin['ns']\n-\n-    i = coin['nn'].find('.')  # if there is a dot in normalized name => prefer the normalized symbol\n-    if i >= 0:\n-        if i > 1 and coin['nn'][i - 1].isdigit() and coin['nn'][i + 1].isdigit():\n-            pass  # except when the dot separates digits\n-        else:\n-            return coin['ns']\n-\n-    if is_name_short(coin) and has_many_caps(name):\n-        return coin['nn']\n-\n-    if 1.5 * len(coin['ns']) > len(coin['nn']) and any(c.islower() for c in coin['ns']):\n-        return coin['nn']\n-\n-    return coin['ns']\n-\n-\n-def coingecko_symbols() -> Dict[str, str]:\n-    r = None\n-    intermediate = defaultdict(list)\n-    try:\n-        r = requests.get('https://api.coingecko.com/api/v3/coins/list')\n-        all_coins = r.json()\n-        # First pass: generate & compare normalized symbol/name, and then select the most pertinent\n-        for coin in all_coins:\n-            normalized = coingecko_normalize_all(coin)\n-            intermediate[normalized].append(coin)\n-            # Above line keeps together the coins having the same normalized symbol.\n-            # To reduce collision, the coin['name'] is sometimes used in lieu of the coin['symbol'].\n-            # The coin['name'] is not capitalized because lower case letters may be meaningful: cETH, yUSD, DATx, zLOT\n-    except Exception as why:\n-        raise_failure_explanation('COINGECKO', why, {\"\": r})\n-\n-    final = coingecko_second_pass(intermediate)\n-    return coingecko_third_pass(final)\n-\n-\n-def coingecko_second_pass(intermediate: Dict[str, List[dict]]) -> Dict[str, List[dict]]:\n-    # Second pass: fixes most of the symbol collisions\n-    final = defaultdict(list)\n-    for normalized, coins in intermediate.items():\n-        if len(coins) == 1:\n-            final[normalized].append(coins[0])\n-            continue\n-        set_normalized = False\n-        for i in range(len(coins)):\n-            if normalized == coins[i]['nn']:\n-                coin = coins.pop(i)\n-                final[normalized].append(coin)\n-                set_normalized = True\n-                break\n-        rest: List[dict] = []\n-        for coin in coins:\n-            if '%' in coin['name']:\n-                if len(coins) == 1:\n-                    n = coin['ns']\n-                else:\n-                    n = coingecko_normalize_name(coin['id'])\n-                final[n].append(coin)\n-            else:\n-                rest.append(coin)\n-        if not rest:\n-            continue\n-        if not set_normalized:\n-            rest.sort(key=lambda coin: len(coin['nn']), reverse=True)  # sort by the length of the normalized name\n-            coin = rest.pop(0)\n-            final[normalized].append(coin)\n-        for coin in rest:\n-            if coin['nn'] not in intermediate:\n-                n = coin['nn']\n-            elif coin.get('reduced-name'):\n-                n = coingecko_normalize_name(coin['name'])\n-            else:\n-                n = coingecko_normalize_name(coin['id'])\n-            final[n].append(coin)\n-    return final\n-\n-\n-def coingecko_third_pass(final: Dict[str, List[dict]]) -> Dict[str, str]:\n-    # Third pass: fixes some remaining collisions and fills the result\n-    symbols = {}\n-    for normalized, coins in final.items():\n-        if len(coins) == 1:\n-            symbols[normalized] = coins[0]['id']\n-            continue\n-        set_normalized = False\n-        for i in range(len(coins)):\n-            if normalized == coins[i]['nn']:\n-                coin = coins.pop(i)\n-                symbols[normalized] = coin['id']\n-                set_normalized = True\n-                break\n-        rest: List[dict] = []\n-        for coin in coins:\n-            if '%' in coin['name']:\n-                if len(coins) == 1:\n-                    n = coin['ns']\n-                else:\n-                    n = coingecko_normalize_name(coin['id'])\n-                symbols[n] = coin['id']\n-            else:\n-                rest.append(coin)\n-        if not rest:\n-            continue\n-        if not set_normalized:\n-            rest.sort(key=lambda coin: len(coin['nn']), reverse=True)  # sort by the length of the normalized name\n-            coin = rest.pop(0)\n-            symbols[normalized] = coin['id']\n-        for coin in rest:\n-            if coin['nn'] not in final:\n-                n = coin['nn']\n-            elif coin.get('reduced-name'):\n-                n = coingecko_normalize_name(coin['name'])\n-            else:\n-                n = coingecko_normalize_name(coin['id'])\n-            symbols[n] = coin['id']\n-    return symbols\n-\n-\n-def whale_alert_coins(key_id: str) -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get(f'https://api.whale-alert.io/v1/status?api_key={key_id}')\n-        # Same symbols, but on different blockchains (for instance USDT), are naturally overwritten.\n-        return {s.upper(): s for b in r.json()['blockchains'] for s in b['symbols'] if s}\n-    except Exception as why:\n-        raise_failure_explanation('WHALES_ALERT', why, {\"\": r})\n-\n-\n-_exchange_function_map = {\n-    BITFINEX: bitfinex_symbols,\n-    BITFLYER: bitflyer_symbols,\n-    COINBASE: coinbase_symbols,\n-    GEMINI: gemini_symbols,\n-    HITBTC: hitbtc_symbols,\n-    POLONIEX: poloniex_symbols,\n-    PROBIT: probit_symbols,\n-    BITSTAMP: bitstamp_symbols,\n-    KRAKEN: kraken_symbols,\n-    KRAKEN + 'REST': kraken_rest_symbols,\n-    BINANCE: binance_symbols,\n-    BINANCE_US: binance_us_symbols,\n-    BINANCE_FUTURES: binance_futures_symbols,\n-    BINANCE_DELIVERY: binance_delivery_symbols,\n-    BLOCKCHAIN: blockchain_symbols,\n-    EXX: exx_symbols,\n-    HUOBI: huobi_symbols,\n-    HUOBI_DM: huobi_dm_symbols,\n-    HUOBI_SWAP: huobi_swap_symbols,\n-    OKCOIN: okcoin_symbols,\n-    OKEX: okex_symbols,\n-    BYBIT: bybit_symbols,\n-    FTX: ftx_symbols,\n-    FTX_US: ftx_us_symbols,\n-    BITTREX: bittrex_symbols,\n-    BITCOINCOM: bitcoincom_symbols,\n-    BITMAX: bitmax_symbols,\n-    UPBIT: upbit_symbols,\n-    GATEIO: gateio_symbols,\n-    BITMEX: bitmex_symbols,\n-    DERIBIT: deribit_symbols,\n-    KRAKEN_FUTURES: kraken_future_symbols,\n-    COINGECKO: coingecko_symbols,\n-    WHALE_ALERT: whale_alert_coins\n-}\n+Symbols = _Symbols()\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\n\nimport logging\nimport string\nimport time\nfrom collections import defaultdict\nfrom typing import Dict, List, Optional, Tuple\n\nimport requests\nfrom requests import Response\n\nfrom cryptofeed.defines import *\n\n\nLOG = logging.getLogger('feedhandler')\n\nSYMBOL_SEP = '-'\n\n_symbols_retrieval_cache: Dict[str, Dict[str, str]] = {}\n_exchange_info = defaultdict(lambda: defaultdict(dict))\n\n\n_kraken_futures_product_type = {\n    'FI': 'Inverse Futures',\n    'FV': 'Vanilla Futures',\n    'PI': 'Perpetual Inverse Futures',\n    'PV': 'Perpetual Vanilla Futures',\n    'IN': 'Real Time Index',\n    'RR': 'Reference Rate',\n}\n\n\ndef raise_failure_explanation(feed_id: str, exception: BaseException, responses: Dict[str, Optional[Response]]):\n    <IND>LOG.critical('%s: encountered %r while processing response from exchange API', feed_id, exception)\n    if len(responses) > 1:\n        <IND>LOG.critical('%s: content of one of the %s responses was unexpected', feed_id, len(responses))\n    <DED>for url, r in responses.items():\n        <IND>if url:\n            <IND>LOG.critical('%s: requested URL: %s', feed_id, url)\n        <DED>if r:\n            <IND>LOG.critical('%s: unexpected response: %s', feed_id, r.text)\n    <DED><DED>raise ValueError(f'Cryptofeed stopped because of an unexpected response from {feed_id}') from exception\n\n\n<DED>def set_symbol_separator(separator: str):\n    <IND>global SYMBOL_SEP\n    SYMBOL_SEP = separator\n\n\n<DED>def get_symbol_separator() -> str:\n    <IND>global SYMBOL_SEP\n    return SYMBOL_SEP\n\n\n<DED>def gen_symbols(exchange: str, key_id=None) -> Dict[str, str]:\n    <IND>if exchange not in _symbols_retrieval_cache:\n        <IND>LOG.info(\"%s: Getting list of symbols\", exchange)\n        symbols = _exchange_function_map[exchange](key_id) if key_id else _exchange_function_map[exchange]()\n        LOG.info(\"%s: %s symbols\", exchange, len(symbols))\n\n        # log all retrieved symbols using debug level\n        for normalized, exch_sym in sorted(symbols.items()):\n            <IND>LOG.debug('%s: id-from-exch -> normalized: %-35s-> %s', exchange, exch_sym, normalized)\n\n        <DED>_symbols_retrieval_cache[exchange] = symbols\n    <DED>return _symbols_retrieval_cache[exchange]\n\n\n<DED>def _binance_symbols(endpoint: str, exchange: str):\n    <IND>r = None\n    try:\n        <IND>ret = {}\n        r = requests.get(endpoint)\n        for symbol in r.json()['symbols']:\n            <IND>if symbol.get('status', 'TRADING') != \"TRADING\":\n                <IND>continue\n            <DED>if symbol.get('contractStatus', 'TRADING') != \"TRADING\":\n                <IND>continue\n            <DED>split = len(symbol['baseAsset'])\n            normalized = symbol['symbol'][:split] + SYMBOL_SEP + symbol['symbol'][split:]\n            ret[normalized] = symbol['symbol']\n            _exchange_info[exchange]['tick_size'][normalized] = symbol['filters'][0]['tickSize']\n            if \"contractType\" in symbol:\n                <IND>_exchange_info[exchange]['contract_type'][normalized] = symbol['contractType']\n        <DED><DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation(exchange, why, {endpoint: r})\n\n\n<DED><DED>def binance_symbols() -> Dict[str, str]:\n    <IND>return _binance_symbols('https://api.binance.com/api/v3/exchangeInfo', BINANCE)\n\n\n<DED>def binance_us_symbols() -> Dict[str, str]:\n    <IND>return _binance_symbols('https://api.binance.us/api/v3/exchangeInfo', BINANCE_US)\n\n\n<DED>def binance_futures_symbols() -> Dict[str, str]:\n    <IND>base = _binance_symbols('https://fapi.binance.com/fapi/v1/exchangeInfo', BINANCE_FUTURES)\n    add = {}\n    for symbol, orig in base.items():\n        <IND>if \"_\" in orig:\n            <IND>continue\n        <DED>add[f\"{symbol}-PINDEX\"] = f\"p{orig}\"\n    <DED>base.update(add)\n    return base\n\n\n<DED>def binance_delivery_symbols() -> Dict[str, str]:\n    <IND>return _binance_symbols('https://dapi.binance.com/dapi/v1/exchangeInfo', BINANCE_DELIVERY)\n\n\n<DED>def bitfinex_symbols() -> Dict[str, str]:\n    # doc: https://docs.bitfinex.com/docs/ws-general#supported-pairs\n    <IND>r1 = r2 = None\n    try:\n        <IND>r1 = requests.get('https://api.bitfinex.com/v2/tickers?symbols=ALL')\n        r2 = requests.get('https://api-pub.bitfinex.com/v2/conf/pub:map:currency:sym')\n        tickers: List[List[str]] = r1.json()\n        norm: List[Tuple[str, str]] = r2.json()[0]\n        norm: Dict[str, str] = dict(norm)\n        for k, v in dict(norm).items():\n            <IND>if k[-2:] == 'F0' or '-' in v:  # Do not convert BTCF0 -> BTC or PBTCETH -> PBTC-ETH\n                <IND>del norm[k]\n        <DED><DED>norm['BCHN'] = 'BCH'  # Bitfinex uses BCHN, other exchanges use BCH\n\n        ret = {}\n        for symbol in [t[0] for t in tickers]:\n            <IND>if symbol[0] == 'f':\n                <IND>normalized = norm.get(symbol[1:], symbol[1:])\n            <DED>else:\n                <IND>if len(symbol) == 7:\n                    <IND>base, quote = symbol[1:4], symbol[4:]\n                <DED>else:\n                    <IND>base, quote = symbol[1:].split(':')\n                    assert ':' in symbol\n                <DED>normalized = norm.get(base, base) + SYMBOL_SEP + norm.get(quote, quote)\n            <DED>ret[normalized.upper()] = symbol\n        <DED>return ret\n    <DED>except ValueError as why:\n        <IND>raise_failure_explanation('BITFINEX', why, {\"tickers?symbols=ALL\": r1, \"pub:map:currency:sym\": r2})\n\n\n<DED><DED>def bitflyer_symbols() -> Dict[str, str]:\n    <IND>endpoint = r = None\n    try:\n        <IND>ret = {}\n        endpoints = ['https://api.bitflyer.com/v1/getmarkets/eu', 'https://api.bitflyer.com/v1/getmarkets/usa', 'https://api.bitflyer.com/v1/getmarkets']\n        for endpoint in endpoints:\n            <IND>r = requests.get(endpoint)\n            for entry in r.json():\n                <IND>normalized = entry['product_code'].replace(\"_\", SYMBOL_SEP)\n                ret[normalized] = entry['product_code']\n        <DED><DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BITFLYER', why, {endpoint: r})\n\n\n<DED><DED>def bybit_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.bybit.com/v2/public/symbols')\n        ret = {}\n        for symbol in r.json()['result']:\n            <IND>quote = symbol['quote_currency']\n            if not symbol['name'].endswith(quote):\n                <IND>base, contract = symbol['name'].split(quote)\n                normalized = f\"{base}{SYMBOL_SEP}{quote}-{contract}\"\n            <DED>else:\n                <IND>normalized = f\"{symbol['base_currency']}{SYMBOL_SEP}{quote}\"\n            <DED>ret[normalized] = symbol['name']\n            _exchange_info[BYBIT]['tick_size'][normalized] = symbol['price_filter']['tick_size']\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BYBIT', why, {\"\": r})\n\n\n<DED><DED>def _ftx_helper(endpoint: str, exchange: str):\n    <IND>r = None\n    try:\n        <IND>r = requests.get(endpoint)\n        ret = {}\n        for data in r.json()['result']:\n            <IND>normalized = data['name'].replace(\"/\", SYMBOL_SEP)\n            symbol = data['name']\n            ret[normalized] = symbol\n            _exchange_info[exchange]['tick_size'][normalized] = data['priceIncrement']\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation(exchange, why, {endpoint: r})\n\n\n<DED><DED>def ftx_symbols() -> Dict[str, str]:\n    <IND>return _ftx_helper('https://ftx.com/api/markets', FTX)\n\n\n<DED>def ftx_us_symbols() -> Dict[str, str]:\n    <IND>return _ftx_helper('https://ftx.us/api/markets', FTX_US)\n\n\n<DED>def coinbase_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.pro.coinbase.com/products')\n        ret = {}\n        for data in r.json():\n            <IND>normalized = data['id'].replace(\"-\", SYMBOL_SEP)\n            ret[normalized] = data['id']\n            _exchange_info[COINBASE]['tick_size'][normalized] = data['quote_increment']\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('COINBASE', why, {\"\": r})\n\n\n<DED><DED>def gemini_symbols(*args) -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.gemini.com/v1/symbols')\n        ret = {}\n        for symbol in r.json():\n            <IND>std = f\"{symbol[:-3]}{SYMBOL_SEP}{symbol[-3:]}\"\n            std = std.upper()\n            ret[std] = symbol.upper()\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('GEMINI', why, {\"\": r})\n\n\n<DED><DED>def hitbtc_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>ret = {}\n        r = requests.get('https://api.hitbtc.com/api/2/public/symbol')\n        for symbol in r.json():\n            <IND>split = len(symbol['baseCurrency'])\n            normalized = symbol['id'][:split] + SYMBOL_SEP + symbol['id'][split:]\n            ret[normalized] = symbol['id']\n            _exchange_info[HITBTC]['tick_size'][normalized] = symbol['tickSize']\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('HITBTC', why, {\"\": r})\n\n\n<DED><DED>def poloniex_id_symbol_mapping():\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://poloniex.com/public?command=returnTicker')\n        symbols = r.json()\n        ret = {}\n        for symbol in symbols:\n            <IND>ret[symbols[symbol]['id']] = symbol\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('POLONIEX', why, {\"\": r})\n\n\n<DED><DED>def poloniex_symbols() -> Dict[str, str]:\n    <IND>ret = {}\n    for _, value in poloniex_id_symbol_mapping().items():\n        <IND>std = value.replace(\"STR\", \"XLM\")\n        quote, base = std.split(\"_\")\n        ret[quote + SYMBOL_SEP + base] = value\n    <DED>return ret\n\n\n<DED>def bitstamp_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://www.bitstamp.net/api/v2/trading-pairs-info/')\n        ret = {}\n        for data in r.json():\n            <IND>normalized = data['name'].replace(\"/\", SYMBOL_SEP)\n            symbol = data['url_symbol']\n            ret[normalized] = symbol\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BITSTAMP', why, {\"\": r})\n\n\n<DED><DED>def kraken_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.kraken.com/0/public/AssetPairs')\n        data = r.json()\n        ret = {}\n        for symbol in data['result']:\n            <IND>if 'wsname' not in data['result'][symbol] or '.d' in symbol:\n                # https://blog.kraken.com/post/259/introducing-the-kraken-dark-pool/\n                # .d is for dark pool symbols\n                <IND>continue\n\n            <DED>base, quote = data['result'][symbol]['wsname'].split(\"/\")\n\n            normalized = f\"{base}{SYMBOL_SEP}{quote}\"\n            exch = data['result'][symbol]['wsname']\n            normalized = normalized.replace('XBT', 'BTC')\n            normalized = normalized.replace('XDG', 'DOG')\n            ret[normalized] = exch\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('KRAKEN', why, {\"\": r})\n\n\n<DED><DED>def kraken_rest_symbols() -> Dict[str, str]:\n    <IND>return {normalized: exchange.replace(\"/\", \"\") for normalized, exchange in kraken_symbols().items()}\n\n\n<DED>def exx_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.exx.com/data/v1/tickers')\n        exchange = [key.upper() for key in r.json().keys()]\n        symbols = [key.replace(\"_\", SYMBOL_SEP) for key in exchange]\n        return dict(zip(symbols, exchange))\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('EXX', why, {\"\": r})\n\n\n<DED><DED>def huobi_common_symbols(url: str):\n    <IND>r = None\n    try:\n        <IND>r = requests.get(url)\n        ret = {}\n        for e in r.json()['data']:\n            <IND>if e['state'] == 'offline':\n                <IND>continue\n            <DED>normalized = f\"{e['base-currency'].upper()}{SYMBOL_SEP}{e['quote-currency'].upper()}\"\n            symbol = f\"{e['base-currency']}{e['quote-currency']}\"\n            ret[normalized] = symbol\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('HUOBI', why, {url: r})\n\n\n<DED><DED>def huobi_symbols() -> Dict[str, str]:\n    <IND>return huobi_common_symbols('https://api.huobi.pro/v1/common/symbols')\n\n\n<DED>def huobi_us_symbols() -> Dict[str, str]:\n    <IND>return huobi_common_symbols('https://api.huobi.com/v1/common/symbols')\n\n\n<DED>def huobi_dm_symbols() -> Dict[str, str]:\n    <IND>\"\"\"\n    Mapping is, for instance: {\"BTC_CW\":\"BTC190816\"}\n    See comments in exchange/huobi_dm.py\n    \"\"\"\n    mapping = {\n        \"this_week\": \"CW\",\n        \"next_week\": \"NW\",\n        \"quarter\": \"CQ\",\n        \"next_quarter\": \"NQ\"\n    }\n    r = None\n    try:\n        <IND>r = requests.get('https://www.hbdm.com/api/v1/contract_contract_info')\n        symbols = {}\n        for e in r.json()['data']:\n            <IND>symbols[f\"{e['symbol']}_{mapping[e['contract_type']]}\"] = e['contract_code']\n            _exchange_info[HUOBI_DM]['tick_size'][e['contract_code']] = e['price_tick']\n            _exchange_info[HUOBI_DM]['short_code_mappings'][f\"{e['symbol']}_{mapping[e['contract_type']]}\"] = e['contract_code']\n        <DED>return symbols\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('HUOBI_DM', why, {\"\": r})\n\n\n<DED><DED>def huobi_swap_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.hbdm.com/swap-api/v1/swap_contract_info')\n        symbols = {}\n        for e in r.json()['data']:\n            <IND>symbols[e['contract_code']] = e['contract_code']\n            _exchange_info[HUOBI_SWAP]['tick_size'][e['contract_code']] = e['price_tick']\n        <DED>return symbols\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('HUOBI_SWAP', why, {\"\": r})\n\n\n<DED><DED>def okcoin_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://www.okcoin.com/api/spot/v3/instruments')\n        ret = {}\n        for e in r.json():\n            <IND>ret[e['instrument_id']] = e['instrument_id']\n            _exchange_info[OKCOIN]['tick_size'][e['instrument_id']] = e['tick_size']\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('OKCOIN', why, {\"\": r})\n\n\n<DED><DED>def okex_symbols(*args) -> Dict[str, str]:\n    <IND>urls = ['https://www.okex.com/api/spot/v3/instruments',\n            'https://www.okex.com/api/swap/v3/instruments',\n            'https://www.okex.com/api/futures/v3/instruments']\n    urls = urls + okex_compute_option_urls_from_underlyings()\n\n    symbols: Dict[str, str] = {}\n    for u in urls:\n        <IND>time.sleep(0.2)\n        symbols.update(okex_symbols_from_one_url(u))\n\n    <DED>for symbol in symbols:\n        <IND>instrument_type = 'futures'\n        dash_count = symbol.count(get_symbol_separator())\n        if dash_count == 1:  # BTC-USDT\n            <IND>instrument_type = 'spot'\n        <DED>if dash_count == 4:  # BTC-USD-201225-35000-P\n            <IND>instrument_type = 'option'\n        <DED>if symbol[-4:] == \"SWAP\":  # BTC-USDT-SWAP\n            <IND>instrument_type = 'swap'\n\n        <DED>_exchange_info[OKEX]['instrument_type'][symbol] = instrument_type\n\n    <DED>return symbols\n\n\n<DED>def okex_compute_option_urls_from_underlyings() -> List[str]:\n    <IND>url = 'https://www.okex.com/api/option/v3/underlying'\n    r = None\n    try:\n        <IND>r = requests.get(url)\n        return [f'https://www.okex.com/api/option/v3/instruments/{underlying}' for underlying in r.json()]\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('OKEX', why, {url: r})\n\n\n<DED><DED>def okex_symbols_from_one_url(url: str) -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get(url)\n        ret = {}\n        for e in r.json():\n            <IND>ret[e['instrument_id']] = e['instrument_id']\n            _exchange_info[OKEX]['tick_size'][e['instrument_id']] = e['tick_size']\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('OKEX', why, {url: r})\n\n\n<DED><DED>def bittrex_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.bittrex.com/api/v1.1/public/getmarkets')\n        r = r.json()['result']\n        return {f\"{e['MarketCurrency']}{SYMBOL_SEP}{e['BaseCurrency']}\": e['MarketName'] for e in r if e['IsActive']}\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BITTREX', why, {\"\": r})\n\n\n<DED><DED>def bitcoincom_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.exchange.bitcoin.com/api/2/public/symbol')\n        return {f\"{data['baseCurrency']}{SYMBOL_SEP}{data['quoteCurrency'].replace('USD', 'USDT')}\": data['id'] for data in r.json()}\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BITCOINCOM', why, {\"\": r})\n\n\n<DED><DED>def bitmax_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://bitmax.io/api/pro/v1/products')\n        ret = {}\n        for entry in r.json()['data']:\n            # Only \"Normal\" status symbols are tradeable\n            <IND>if entry['status'] == 'Normal':\n                <IND>normalized = f\"{entry['baseAsset']}{SYMBOL_SEP}{entry['quoteAsset']}\"\n                ret[normalized] = entry['symbol']\n                _exchange_info[BITMAX]['tick_size'][normalized] = entry['tickSize']\n        <DED><DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BITMAX', why, {\"\": r})\n\n\n<DED><DED>def upbit_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.upbit.com/v1/market/all')\n        return {f\"{data['market'].split('-')[1]}{SYMBOL_SEP}{data['market'].split('-')[0]}\": data['market'] for data in r.json()}\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('UPBIT', why, {\"\": r})\n\n\n<DED><DED>def blockchain_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get(\"https://api.blockchain.com/mercury-gateway/v1/instruments\")\n        return {data[\"symbol\"].replace(\"-\", SYMBOL_SEP): data[\"symbol\"] for data in r.json()}\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BLOCKCHAIN', why, {\"\": r})\n\n\n<DED><DED>def gateio_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get(\"https://api.gateio.ws/api/v4/spot/currency_pairs\")\n        return {data[\"id\"].replace(\"_\", SYMBOL_SEP): data['id'] for data in r.json()}\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('GATEIO', why, {\"\": r})\n\n\n<DED><DED>def bitmex_symbols() -> Dict[str, str]:\n    <IND>r = None\n    ret = {}\n    try:\n        <IND>r = requests.get(\"https://www.bitmex.com/api/v1/instrument/active\")\n        for entry in r.json():\n            <IND>components = []\n            components.append(entry['rootSymbol'])\n            components.append(entry['quoteCurrency'])\n\n            if entry['expiry']:\n                <IND>components.append(entry['symbol'][-3:])\n\n            <DED>normalized = SYMBOL_SEP.join(components)\n            normalized = normalized.replace(\"XBT\", \"BTC\")\n            ret[normalized] = entry['symbol']\n            _exchange_info[BITMEX]['tick_size'][normalized] = entry['tickSize']\n\n            if entry['expiry']:\n                <IND>_exchange_info[BITMEX]['expiry'][normalized] = entry['expiry']\n\n        <DED><DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BITMEX', why, {\"\": r})\n\n\n<DED><DED>def deribit_symbols() -> Dict[str, str]:\n    <IND>url = r = None\n    ret = {}\n    try:\n        # TODO: get currencies from https://www.deribit.com/api/v2/public/get_currencies\n        <IND>currencies = ['BTC', 'ETH']\n        for c in currencies:\n            <IND>url = f\"https://www.deribit.com/api/v2/public/get_instruments?currency={c}&expired=false\"\n            r = requests.get(url)\n            for entry in r.json()['result']:\n                <IND>split = entry['instrument_name'].split(\"-\")\n                normalized = split[0] + SYMBOL_SEP + entry['quote_currency'] + \"-\" + '-'.join(split[1:])\n                ret[normalized] = entry['instrument_name']\n                _exchange_info[DERIBIT]['tick_size'][normalized] = entry['tick_size']\n        <DED><DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('DERIBIT', why, {url: r})\n\n\n<DED><DED>def kraken_future_symbols() -> Dict[str, str]:\n    <IND>r = None\n    ret = {}\n    try:\n        <IND>r = requests.get('https://futures.kraken.com/derivatives/api/v3/instruments')\n        data = r.json()['instruments']\n        for entry in data:\n            <IND>if not entry['tradeable']:\n                <IND>continue\n            <DED>normalized = entry['symbol'].upper().replace(\"_\", \"-\")\n            symbol = normalized[3:6] + SYMBOL_SEP + normalized[6:9]\n            normalized = normalized.replace(normalized[3:9], symbol)\n            normalized = normalized.replace('XBT', 'BTC')\n\n            _exchange_info[KRAKEN_FUTURES]['tick_size'][normalized] = entry['tickSize']\n            _exchange_info[KRAKEN_FUTURES]['contract_size'][normalized] = entry['contractSize']\n            _exchange_info[KRAKEN_FUTURES]['underlying'][normalized] = entry['underlying']\n            _exchange_info[KRAKEN_FUTURES]['product_type'][normalized] = _kraken_futures_product_type[normalized[:2]]\n            ret[normalized] = entry['symbol']\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('KRAKEN_FUTURES', why, {\"\": r})\n\n\n<DED><DED>def probit_symbols() -> Dict[str, str]:\n    # doc: https://docs-en.probit.com/reference-link/market\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.probit.com/api/exchange/v1/market')\n        return {entry['id']: entry['id'] for entry in r.json()['data']}\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('PROBIT', why, {\"\": r})\n\n\n<DED><DED>def coingecko_normalize_symbol(symbol: str) -> str:\n    # keep digits, letters and dots, replace others by space\n    <IND>symbol = ''.join(c if c.isalnum() or c in ('.', '+') else ' ' for c in symbol)\n    return coingecko_normalize(symbol.upper())\n\n\n<DED>def coingecko_normalize_name(name: str) -> str:\n    # keep digits and letters, replace others by space (except when only composed by upper case letters, digits and dots)\n    <IND>if not all(c.isupper() or c.isdigit() or c == '.' for c in name):\n        <IND>name = ''.join(c if c.isalnum() else ' ' for c in name)\n    <DED>return coingecko_normalize(name)\n\n\n<DED>def coingecko_normalize(sym: str) -> str:\n    <IND>sym = sym.strip()\n    # do not concatenate numbers => separate them with a dot\n    sym = list(sym)\n    if len(sym) > 4:\n        <IND>for i in range(2, len(sym) - 1):\n            <IND>if sym[i] == ' ' and sym[i - 1].isdigit() and sym[i + 1].isdigit():\n                <IND>sym[i] = '.'\n    <DED><DED><DED>sym = ''.join(sym)\n    # concatenate space-separated words => use CamelCase to distinguish the words\n    if ' ' in sym:\n        <IND>if sum(c.islower() for c in sym):  # if there is at least one lower case letter\n            <IND>sym = ' '.join(word[0].upper() + word[1:] for word in sym.split())  # Just capitalize initial letter of each word\n        <DED>else:  # CoinGecko may provide full upper-case as for \"THE STONE COIN\"\n            <IND>sym = string.capwords(sym)  # capwords converts \"THE STONE COIN\" to \"The Stone Coin\"\n        <DED>sym = sym.replace(' ', '')  # concatenate words\n    <DED>return sym\n\n\n<DED>def is_name_short(coin: dict) -> bool:\n    <IND>\"\"\"return True if the coin name is enough short compared to the coin symbol.\"\"\"\n    return len(coin['name']) <= max(5, len(coin['symbol']) + 1)\n\n\n<DED>def has_many_caps(name: str) -> bool:\n    <IND>\"\"\"return True if the symbol contains enough upper case letters, False if empty.\"\"\"\n    return str and sum(c.islower() for c in name) < (len(name) / 2)\n\n\n<DED>def coingecko_normalize_all(coin: dict):\n    <IND>SYMBOL_TO_NORMALIZED = {'miota': 'IOTA'}\n    normalized = SYMBOL_TO_NORMALIZED.get(coin['symbol'])\n    if normalized:\n        <IND>coin['ns'] = coin['nn'] = normalized\n        return normalized\n\n    # ns = normalized symbol, nn = normalized name\n    <DED>coin['ns'] = coingecko_normalize_symbol(coin['symbol'])\n\n    ID_SUFFIX = '-bitcoin-token'\n    if coin['id'][-len(ID_SUFFIX):] == ID_SUFFIX:\n        <IND>coin['nn'] = 'BTC' + coin['ns']\n        return coin['nn']\n\n    <DED>name = coin['name']\n\n    prefixes = ('The ', 'the ')\n    for p in prefixes:\n        <IND>if name[:len(p)] == p:\n            <IND>coin['reduced-name'] = True\n            name = name[len(p):]\n            break\n\n    <DED><DED>suffixes = ('coin', 'coins', 'money', 'finance', 'protocol', 'reward', 'rewards', 'token')\n    for s in suffixes:\n        <IND>if len(name) > len(s) and name[-len(s):].lower() == s:\n            # but keep suffix when lower-case concatenated\n            <IND>if name[-len(s)].islower() and name[-len(s) - 1] != ' ':\n                <IND>continue\n            # also keep suffix to avoid confusing nam: \"Bitcoin Token\" -> \"Bitcoin\"\n            <DED>if name[:-len(s)].strip().lower() == 'bitcoin':\n                <IND>continue\n            <DED>coin['reduced-name'] = True\n            name = name[:-len(s)]\n            break\n\n    <DED><DED>coin['nn'] = coingecko_normalize_name(name)\n\n    if len(coin['nn']) < len(coin['ns']):\n        <IND>if 'reduced-name' in coin:\n            <IND>coin['reduced-name'] = False\n            name = coin['name']\n            coin['nn'] = coingecko_normalize_name(name)\n        <DED>elif not has_many_caps(name):\n            <IND>return coin['ns']\n\n    <DED><DED>if not coin['ns']:  # coin['symbol'] may be an emoji that is striped when normalized\n        <IND>return coin['nn']\n\n    <DED>if coin.get('reduced-name') and coin['ns'].upper() != coin['nn'].upper():\n        <IND>return coin['ns']\n\n    <DED>i = coin['nn'].find('.')  # if there is a dot in normalized name => prefer the normalized symbol\n    if i >= 0:\n        <IND>if i > 1 and coin['nn'][i - 1].isdigit() and coin['nn'][i + 1].isdigit():\n            <IND>pass  # except when the dot separates digits\n        <DED>else:\n            <IND>return coin['ns']\n\n    <DED><DED>if is_name_short(coin) and has_many_caps(name):\n        <IND>return coin['nn']\n\n    <DED>if 1.5 * len(coin['ns']) > len(coin['nn']) and any(c.islower() for c in coin['ns']):\n        <IND>return coin['nn']\n\n    <DED>return coin['ns']\n\n\n<DED>def coingecko_symbols() -> Dict[str, str]:\n    <IND>r = None\n    intermediate = defaultdict(list)\n    try:\n        <IND>r = requests.get('https://api.coingecko.com/api/v3/coins/list')\n        all_coins = r.json()\n        # First pass: generate & compare normalized symbol/name, and then select the most pertinent\n        for coin in all_coins:\n            <IND>normalized = coingecko_normalize_all(coin)\n            intermediate[normalized].append(coin)\n            # Above line keeps together the coins having the same normalized symbol.\n            # To reduce collision, the coin['name'] is sometimes used in lieu of the coin['symbol'].\n            # The coin['name'] is not capitalized because lower case letters may be meaningful: cETH, yUSD, DATx, zLOT\n    <DED><DED>except Exception as why:\n        <IND>raise_failure_explanation('COINGECKO', why, {\"\": r})\n\n    <DED>final = coingecko_second_pass(intermediate)\n    return coingecko_third_pass(final)\n\n\n<DED>def coingecko_second_pass(intermediate: Dict[str, List[dict]]) -> Dict[str, List[dict]]:\n    # Second pass: fixes most of the symbol collisions\n    <IND>final = defaultdict(list)\n    for normalized, coins in intermediate.items():\n        <IND>if len(coins) == 1:\n            <IND>final[normalized].append(coins[0])\n            continue\n        <DED>set_normalized = False\n        for i in range(len(coins)):\n            <IND>if normalized == coins[i]['nn']:\n                <IND>coin = coins.pop(i)\n                final[normalized].append(coin)\n                set_normalized = True\n                break\n        <DED><DED>rest: List[dict] = []\n        for coin in coins:\n            <IND>if '%' in coin['name']:\n                <IND>if len(coins) == 1:\n                    <IND>n = coin['ns']\n                <DED>else:\n                    <IND>n = coingecko_normalize_name(coin['id'])\n                <DED>final[n].append(coin)\n            <DED>else:\n                <IND>rest.append(coin)\n        <DED><DED>if not rest:\n            <IND>continue\n        <DED>if not set_normalized:\n            <IND>rest.sort(key=lambda coin: len(coin['nn']), reverse=True)  # sort by the length of the normalized name\n            coin = rest.pop(0)\n            final[normalized].append(coin)\n        <DED>for coin in rest:\n            <IND>if coin['nn'] not in intermediate:\n                <IND>n = coin['nn']\n            <DED>elif coin.get('reduced-name'):\n                <IND>n = coingecko_normalize_name(coin['name'])\n            <DED>else:\n                <IND>n = coingecko_normalize_name(coin['id'])\n            <DED>final[n].append(coin)\n    <DED><DED>return final\n\n\n<DED>def coingecko_third_pass(final: Dict[str, List[dict]]) -> Dict[str, str]:\n    # Third pass: fixes some remaining collisions and fills the result\n    <IND>symbols = {}\n    for normalized, coins in final.items():\n        <IND>if len(coins) == 1:\n            <IND>symbols[normalized] = coins[0]['id']\n            continue\n        <DED>set_normalized = False\n        for i in range(len(coins)):\n            <IND>if normalized == coins[i]['nn']:\n                <IND>coin = coins.pop(i)\n                symbols[normalized] = coin['id']\n                set_normalized = True\n                break\n        <DED><DED>rest: List[dict] = []\n        for coin in coins:\n            <IND>if '%' in coin['name']:\n                <IND>if len(coins) == 1:\n                    <IND>n = coin['ns']\n                <DED>else:\n                    <IND>n = coingecko_normalize_name(coin['id'])\n                <DED>symbols[n] = coin['id']\n            <DED>else:\n                <IND>rest.append(coin)\n        <DED><DED>if not rest:\n            <IND>continue\n        <DED>if not set_normalized:\n            <IND>rest.sort(key=lambda coin: len(coin['nn']), reverse=True)  # sort by the length of the normalized name\n            coin = rest.pop(0)\n            symbols[normalized] = coin['id']\n        <DED>for coin in rest:\n            <IND>if coin['nn'] not in final:\n                <IND>n = coin['nn']\n            <DED>elif coin.get('reduced-name'):\n                <IND>n = coingecko_normalize_name(coin['name'])\n            <DED>else:\n                <IND>n = coingecko_normalize_name(coin['id'])\n            <DED>symbols[n] = coin['id']\n    <DED><DED>return symbols\n\n\n<DED>def whale_alert_coins(key_id: str) -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get(f'https://api.whale-alert.io/v1/status?api_key={key_id}')\n        # Same symbols, but on different blockchains (for instance USDT), are naturally overwritten.\n        return {s.upper(): s for b in r.json()['blockchains'] for s in b['symbols'] if s}\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('WHALES_ALERT', why, {\"\": r})\n\n\n<DED><DED>_exchange_function_map = {\n    BITFINEX: bitfinex_symbols,\n    BITFLYER: bitflyer_symbols,\n    COINBASE: coinbase_symbols,\n    GEMINI: gemini_symbols,\n    HITBTC: hitbtc_symbols,\n    POLONIEX: poloniex_symbols,\n    PROBIT: probit_symbols,\n    BITSTAMP: bitstamp_symbols,\n    KRAKEN: kraken_symbols,\n    KRAKEN + 'REST': kraken_rest_symbols,\n    BINANCE: binance_symbols,\n    BINANCE_US: binance_us_symbols,\n    BINANCE_FUTURES: binance_futures_symbols,\n    BINANCE_DELIVERY: binance_delivery_symbols,\n    BLOCKCHAIN: blockchain_symbols,\n    EXX: exx_symbols,\n    HUOBI: huobi_symbols,\n    HUOBI_DM: huobi_dm_symbols,\n    HUOBI_SWAP: huobi_swap_symbols,\n    OKCOIN: okcoin_symbols,\n    OKEX: okex_symbols,\n    BYBIT: bybit_symbols,\n    FTX: ftx_symbols,\n    FTX_US: ftx_us_symbols,\n    BITTREX: bittrex_symbols,\n    BITCOINCOM: bitcoincom_symbols,\n    BITMAX: bitmax_symbols,\n    UPBIT: upbit_symbols,\n    GATEIO: gateio_symbols,\n    BITMEX: bitmex_symbols,\n    DERIBIT: deribit_symbols,\n    KRAKEN_FUTURES: kraken_future_symbols,\n    COINGECKO: coingecko_symbols,\n    WHALE_ALERT: whale_alert_coins\n}\n",
        "target_code_with_indent": "\nfrom typing import Dict, Tuple\n\n\nclass _Symbols:\n    <IND>def __init__(self):\n        <IND>self.data = {}\n\n    <DED>def set(self, exchange: str, normalized: dict, exchange_info: dict):\n        <IND>self.data[exchange] = {}\n        self.data[exchange]['normalized'] = normalized\n        self.data[exchange]['info'] = exchange_info\n\n    <DED>def get(self, exchange: str) -> Tuple[Dict, Dict]:\n        <IND>return self.data[exchange]['normalized'], self.data[exchange]['info']\n\n    <DED>def populated(self, exchange: str) -> bool:\n        <IND>return exchange in self.data\n\n\n<DED><DED>Symbols = _Symbols()\n"
      }
    ]
  },
  {
    "project": "bmoscon/cryptofeed",
    "commit": "3525dc8ce4d7836a9abaaa5662e58e5e27969a77",
    "filename": "cryptofeed/symbols.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/bmoscon-cryptofeed/cryptofeed/symbols.py",
    "file_hunks_size": 1,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "cryptofeed/symbols.py:535:8 Incompatible return type [7]: Expected `Dict[str, str]` but got implicit return value of `None`.",
    "message": " Expected `Dict[str, str]` but got implicit return value of `None`.",
    "rule_id": "Incompatible return type [7]",
    "warning_line_no": 535,
    "warning_line": "        raise_failure_explanation('BITMEX', why, {\"\": r})",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "associated with this software.\n\n\nSymbol generation code for exchanges\n'''\n\nimport logging\nimport string\nimport time\nfrom collections import defaultdict\nfrom typing import Dict, List, Optional, Tuple\n\nimport requests\nfrom requests import Response\n\nfrom cryptofeed.defines import *\n\n\nLOG = logging.getLogger('feedhandler')\n\nSYMBOL_SEP = '-'\n\n_symbols_retrieval_cache: Dict[str, Dict[str, str]] = {}\n_exchange_info = defaultdict(lambda: defaultdict(dict))\n\n\n_kraken_futures_product_type = {\n    'FI': 'Inverse Futures',\n    'FV': 'Vanilla Futures',\n    'PI': 'Perpetual Inverse Futures',\n    'PV': 'Perpetual Vanilla Futures',\n    'IN': 'Real Time Index',\n    'RR': 'Reference Rate',\n}\n\n\ndef raise_failure_explanation(feed_id: str, exception: BaseException, responses: Dict[str, Optional[Response]]):\n    LOG.critical('%s: encountered %r while processing response from exchange API', feed_id, exception)\n    if len(responses) > 1:\n        LOG.critical('%s: content of one of the %s responses was unexpected', feed_id, len(responses))\n    for url, r in responses.items():\n        if url:\n            LOG.critical('%s: requested URL: %s', feed_id, url)\n        if r:\n            LOG.critical('%s: unexpected response: %s', feed_id, r.text)\n    raise ValueError(f'Cryptofeed stopped because of an unexpected response from {feed_id}') from exception\n\n\ndef set_symbol_separator(separator: str):\n    global SYMBOL_SEP\n    SYMBOL_SEP = separator\n\n\ndef get_symbol_separator() -> str:\n    global SYMBOL_SEP\n    return SYMBOL_SEP\n\n\ndef gen_symbols(exchange: str, key_id=None) -> Dict[str, str]:\n    if exchange not in _symbols_retrieval_cache:\n        LOG.info(\"%s: Getting list of symbols\", exchange)\n        symbols = _exchange_function_map[exchange](key_id) if key_id else _exchange_function_map[exchange]()\n        LOG.info(\"%s: %s symbols\", exchange, len(symbols))\n\n        # log all retrieved symbols using debug level\n        for normalized, exch_sym in sorted(symbols.items()):\n            LOG.debug('%s: id-from-exch -> normalized: %-35s-> %s', exchange, exch_sym, normalized)\n\n        _symbols_retrieval_cache[exchange] = symbols\n    return _symbols_retrieval_cache[exchange]\n\n\ndef _binance_symbols(endpoint: str, exchange: str):\n    r = None\n    try:\n        ret = {}\n        r = requests.get(endpoint)\n        for symbol in r.json()['symbols']:\n            if symbol.get('status', 'TRADING') != \"TRADING\":\n                continue\n            if symbol.get('contractStatus', 'TRADING') != \"TRADING\":\n                continue\n            split = len(symbol['baseAsset'])\n            normalized = symbol['symbol'][:split] + SYMBOL_SEP + symbol['symbol'][split:]\n            ret[normalized] = symbol['symbol']\n            _exchange_info[exchange]['tick_size'][normalized] = symbol['filters'][0]['tickSize']\n            if \"contractType\" in symbol:\n                _exchange_info[exchange]['contract_type'][normalized] = symbol['contractType']\n        return ret\n    except Exception as why:\n        raise_failure_explanation(exchange, why, {endpoint: r})\n\n\ndef binance_symbols() -> Dict[str, str]:\n    return _binance_symbols('https://api.binance.com/api/v3/exchangeInfo', BINANCE)\n\n\ndef binance_us_symbols() -> Dict[str, str]:\n    return _binance_symbols('https://api.binance.us/api/v3/exchangeInfo', BINANCE_US)\n\n\ndef binance_futures_symbols() -> Dict[str, str]:\n    base = _binance_symbols('https://fapi.binance.com/fapi/v1/exchangeInfo', BINANCE_FUTURES)\n    add = {}\n    for symbol, orig in base.items():\n        if \"_\" in orig:\n            continue\n        add[f\"{symbol}-PINDEX\"] = f\"p{orig}\"\n    base.update(add)\n    return base\n\n\ndef binance_delivery_symbols() -> Dict[str, str]:\n    return _binance_symbols('https://dapi.binance.com/dapi/v1/exchangeInfo', BINANCE_DELIVERY)\n\n\ndef bitfinex_symbols() -> Dict[str, str]:\n    # doc: https://docs.bitfinex.com/docs/ws-general#supported-pairs\n    r1 = r2 = None\n    try:\n        r1 = requests.get('https://api.bitfinex.com/v2/tickers?symbols=ALL')\n        r2 = requests.get('https://api-pub.bitfinex.com/v2/conf/pub:map:currency:sym')\n        tickers: List[List[str]] = r1.json()\n        norm: List[Tuple[str, str]] = r2.json()[0]\n        norm: Dict[str, str] = dict(norm)\n        for k, v in dict(norm).items():\n            if k[-2:] == 'F0' or '-' in v:  # Do not convert BTCF0 -> BTC or PBTCETH -> PBTC-ETH\n                del norm[k]\n        norm['BCHN'] = 'BCH'  # Bitfinex uses BCHN, other exchanges use BCH\n\n        ret = {}\n        for symbol in [t[0] for t in tickers]:\n            if symbol[0] == 'f':\n                normalized = norm.get(symbol[1:], symbol[1:])\n            else:\n                if len(symbol) == 7:\n                    base, quote = symbol[1:4], symbol[4:]\n                else:\n                    base, quote = symbol[1:].split(':')\n                    assert ':' in symbol\n                normalized = norm.get(base, base) + SYMBOL_SEP + norm.get(quote, quote)\n            ret[normalized.upper()] = symbol\n        return ret\n    except ValueError as why:\n        raise_failure_explanation('BITFINEX', why, {\"tickers?symbols=ALL\": r1, \"pub:map:currency:sym\": r2})\n\n\ndef bitflyer_symbols() -> Dict[str, str]:\n    endpoint = r = None\n    try:\n        ret = {}\n        endpoints = ['https://api.bitflyer.com/v1/getmarkets/eu', 'https://api.bitflyer.com/v1/getmarkets/usa', 'https://api.bitflyer.com/v1/getmarkets']\n        for endpoint in endpoints:\n            r = requests.get(endpoint)\n            for entry in r.json():\n                normalized = entry['product_code'].replace(\"_\", SYMBOL_SEP)\n                ret[normalized] = entry['product_code']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('BITFLYER', why, {endpoint: r})\n\n\ndef bybit_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.bybit.com/v2/public/symbols')\n        ret = {}\n        for symbol in r.json()['result']:\n            quote = symbol['quote_currency']\n            if not symbol['name'].endswith(quote):\n                base, contract = symbol['name'].split(quote)\n                normalized = f\"{base}{SYMBOL_SEP}{quote}-{contract}\"\n            else:\n                normalized = f\"{symbol['base_currency']}{SYMBOL_SEP}{quote}\"\n            ret[normalized] = symbol['name']\n            _exchange_info[BYBIT]['tick_size'][normalized] = symbol['price_filter']['tick_size']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('BYBIT', why, {\"\": r})\n\n\ndef _ftx_helper(endpoint: str, exchange: str):\n    r = None\n    try:\n        r = requests.get(endpoint)\n        ret = {}\n        for data in r.json()['result']:\n            normalized = data['name'].replace(\"/\", SYMBOL_SEP)\n            symbol = data['name']\n            ret[normalized] = symbol\n            _exchange_info[exchange]['tick_size'][normalized] = data['priceIncrement']\n        return ret\n    except Exception as why:\n        raise_failure_explanation(exchange, why, {endpoint: r})\n\n\ndef ftx_symbols() -> Dict[str, str]:\n    return _ftx_helper('https://ftx.com/api/markets', FTX)\n\n\ndef ftx_us_symbols() -> Dict[str, str]:\n    return _ftx_helper('https://ftx.us/api/markets', FTX_US)\n\n\ndef coinbase_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.pro.coinbase.com/products')\n        ret = {}\n        for data in r.json():\n            normalized = data['id'].replace(\"-\", SYMBOL_SEP)\n            ret[normalized] = data['id']\n            _exchange_info[COINBASE]['tick_size'][normalized] = data['quote_increment']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('COINBASE', why, {\"\": r})\n\n\ndef gemini_symbols(*args) -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.gemini.com/v1/symbols')\n        ret = {}\n        for symbol in r.json():\n            std = f\"{symbol[:-3]}{SYMBOL_SEP}{symbol[-3:]}\"\n            std = std.upper()\n            ret[std] = symbol.upper()\n        return ret\n    except Exception as why:\n        raise_failure_explanation('GEMINI', why, {\"\": r})\n\n\ndef hitbtc_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        ret = {}\n        r = requests.get('https://api.hitbtc.com/api/2/public/symbol')\n        for symbol in r.json():\n            split = len(symbol['baseCurrency'])\n            normalized = symbol['id'][:split] + SYMBOL_SEP + symbol['id'][split:]\n            ret[normalized] = symbol['id']\n            _exchange_info[HITBTC]['tick_size'][normalized] = symbol['tickSize']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('HITBTC', why, {\"\": r})\n\n\ndef poloniex_id_symbol_mapping():\n    r = None\n    try:\n        r = requests.get('https://poloniex.com/public?command=returnTicker')\n        symbols = r.json()\n        ret = {}\n        for symbol in symbols:\n            ret[symbols[symbol]['id']] = symbol\n        return ret\n    except Exception as why:\n        raise_failure_explanation('POLONIEX', why, {\"\": r})\n\n\ndef poloniex_symbols() -> Dict[str, str]:\n    ret = {}\n    for _, value in poloniex_id_symbol_mapping().items():\n        std = value.replace(\"STR\", \"XLM\")\n        quote, base = std.split(\"_\")\n        ret[quote + SYMBOL_SEP + base] = value\n    return ret\n\n\ndef bitstamp_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://www.bitstamp.net/api/v2/trading-pairs-info/')\n        ret = {}\n        for data in r.json():\n            normalized = data['name'].replace(\"/\", SYMBOL_SEP)\n            symbol = data['url_symbol']\n            ret[normalized] = symbol\n        return ret\n    except Exception as why:\n        raise_failure_explanation('BITSTAMP', why, {\"\": r})\n\n\ndef kraken_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.kraken.com/0/public/AssetPairs')\n        data = r.json()\n        ret = {}\n        for symbol in data['result']:\n            if 'wsname' not in data['result'][symbol] or '.d' in symbol:\n                # https://blog.kraken.com/post/259/introducing-the-kraken-dark-pool/\n                # .d is for dark pool symbols\n                continue\n\n            base, quote = data['result'][symbol]['wsname'].split(\"/\")\n\n            normalized = f\"{base}{SYMBOL_SEP}{quote}\"\n            exch = data['result'][symbol]['wsname']\n            normalized = normalized.replace('XBT', 'BTC')\n            normalized = normalized.replace('XDG', 'DOG')\n            ret[normalized] = exch\n        return ret\n    except Exception as why:\n        raise_failure_explanation('KRAKEN', why, {\"\": r})\n\n\ndef kraken_rest_symbols() -> Dict[str, str]:\n    return {normalized: exchange.replace(\"/\", \"\") for normalized, exchange in kraken_symbols().items()}\n\n\ndef exx_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.exx.com/data/v1/tickers')\n        exchange = [key.upper() for key in r.json().keys()]\n        symbols = [key.replace(\"_\", SYMBOL_SEP) for key in exchange]\n        return dict(zip(symbols, exchange))\n    except Exception as why:\n        raise_failure_explanation('EXX', why, {\"\": r})\n\n\ndef huobi_common_symbols(url: str):\n    r = None\n    try:\n        r = requests.get(url)\n        ret = {}\n        for e in r.json()['data']:\n            if e['state'] == 'offline':\n                continue\n            normalized = f\"{e['base-currency'].upper()}{SYMBOL_SEP}{e['quote-currency'].upper()}\"\n            symbol = f\"{e['base-currency']}{e['quote-currency']}\"\n            ret[normalized] = symbol\n        return ret\n    except Exception as why:\n        raise_failure_explanation('HUOBI', why, {url: r})\n\n\ndef huobi_symbols() -> Dict[str, str]:\n    return huobi_common_symbols('https://api.huobi.pro/v1/common/symbols')\n\n\ndef huobi_us_symbols() -> Dict[str, str]:\n    return huobi_common_symbols('https://api.huobi.com/v1/common/symbols')\n\n\ndef huobi_dm_symbols() -> Dict[str, str]:\n    \"\"\"\n    Mapping is, for instance: {\"BTC_CW\":\"BTC190816\"}\n    See comments in exchange/huobi_dm.py\n    \"\"\"\n    mapping = {\n        \"this_week\": \"CW\",\n        \"next_week\": \"NW\",\n        \"quarter\": \"CQ\",\n        \"next_quarter\": \"NQ\"\n    }\n    r = None\n    try:\n        r = requests.get('https://www.hbdm.com/api/v1/contract_contract_info')\n        symbols = {}\n        for e in r.json()['data']:\n            symbols[f\"{e['symbol']}_{mapping[e['contract_type']]}\"] = e['contract_code']\n            _exchange_info[HUOBI_DM]['tick_size'][e['contract_code']] = e['price_tick']\n            _exchange_info[HUOBI_DM]['short_code_mappings'][f\"{e['symbol']}_{mapping[e['contract_type']]}\"] = e['contract_code']\n        return symbols\n    except Exception as why:\n        raise_failure_explanation('HUOBI_DM', why, {\"\": r})\n\n\ndef huobi_swap_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.hbdm.com/swap-api/v1/swap_contract_info')\n        symbols = {}\n        for e in r.json()['data']:\n            symbols[e['contract_code']] = e['contract_code']\n            _exchange_info[HUOBI_SWAP]['tick_size'][e['contract_code']] = e['price_tick']\n        return symbols\n    except Exception as why:\n        raise_failure_explanation('HUOBI_SWAP', why, {\"\": r})\n\n\ndef okcoin_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://www.okcoin.com/api/spot/v3/instruments')\n        ret = {}\n        for e in r.json():\n            ret[e['instrument_id']] = e['instrument_id']\n            _exchange_info[OKCOIN]['tick_size'][e['instrument_id']] = e['tick_size']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('OKCOIN', why, {\"\": r})\n\n\ndef okex_symbols(*args) -> Dict[str, str]:\n    urls = ['https://www.okex.com/api/spot/v3/instruments',\n            'https://www.okex.com/api/swap/v3/instruments',\n            'https://www.okex.com/api/futures/v3/instruments']\n    urls = urls + okex_compute_option_urls_from_underlyings()\n\n    symbols: Dict[str, str] = {}\n    for u in urls:\n        time.sleep(0.2)\n        symbols.update(okex_symbols_from_one_url(u))\n\n    for symbol in symbols:\n        instrument_type = 'futures'\n        dash_count = symbol.count(get_symbol_separator())\n        if dash_count == 1:  # BTC-USDT\n            instrument_type = 'spot'\n        if dash_count == 4:  # BTC-USD-201225-35000-P\n            instrument_type = 'option'\n        if symbol[-4:] == \"SWAP\":  # BTC-USDT-SWAP\n            instrument_type = 'swap'\n\n        _exchange_info[OKEX]['instrument_type'][symbol] = instrument_type\n\n    return symbols\n\n\ndef okex_compute_option_urls_from_underlyings() -> List[str]:\n    url = 'https://www.okex.com/api/option/v3/underlying'\n    r = None\n    try:\n        r = requests.get(url)\n        return [f'https://www.okex.com/api/option/v3/instruments/{underlying}' for underlying in r.json()]\n    except Exception as why:\n        raise_failure_explanation('OKEX', why, {url: r})\n\n\ndef okex_symbols_from_one_url(url: str) -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get(url)\n        ret = {}\n        for e in r.json():\n            ret[e['instrument_id']] = e['instrument_id']\n            _exchange_info[OKEX]['tick_size'][e['instrument_id']] = e['tick_size']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('OKEX', why, {url: r})\n\n\ndef bittrex_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.bittrex.com/api/v1.1/public/getmarkets')\n        r = r.json()['result']\n        return {f\"{e['MarketCurrency']}{SYMBOL_SEP}{e['BaseCurrency']}\": e['MarketName'] for e in r if e['IsActive']}\n    except Exception as why:\n        raise_failure_explanation('BITTREX', why, {\"\": r})\n\n\ndef bitcoincom_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.exchange.bitcoin.com/api/2/public/symbol')\n        return {f\"{data['baseCurrency']}{SYMBOL_SEP}{data['quoteCurrency'].replace('USD', 'USDT')}\": data['id'] for data in r.json()}\n    except Exception as why:\n        raise_failure_explanation('BITCOINCOM', why, {\"\": r})\n\n\ndef bitmax_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://bitmax.io/api/pro/v1/products')\n        ret = {}\n        for entry in r.json()['data']:\n            # Only \"Normal\" status symbols are tradeable\n            if entry['status'] == 'Normal':\n                normalized = f\"{entry['baseAsset']}{SYMBOL_SEP}{entry['quoteAsset']}\"\n                ret[normalized] = entry['symbol']\n                _exchange_info[BITMAX]['tick_size'][normalized] = entry['tickSize']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('BITMAX', why, {\"\": r})\n\n\ndef upbit_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.upbit.com/v1/market/all')\n        return {f\"{data['market'].split('-')[1]}{SYMBOL_SEP}{data['market'].split('-')[0]}\": data['market'] for data in r.json()}\n    except Exception as why:\n        raise_failure_explanation('UPBIT', why, {\"\": r})\n\n\ndef blockchain_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get(\"https://api.blockchain.com/mercury-gateway/v1/instruments\")\n        return {data[\"symbol\"].replace(\"-\", SYMBOL_SEP): data[\"symbol\"] for data in r.json()}\n    except Exception as why:\n        raise_failure_explanation('BLOCKCHAIN', why, {\"\": r})\n\n\ndef gateio_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get(\"https://api.gateio.ws/api/v4/spot/currency_pairs\")\n        return {data[\"id\"].replace(\"_\", SYMBOL_SEP): data['id'] for data in r.json()}\n    except Exception as why:\n        raise_failure_explanation('GATEIO', why, {\"\": r})\n\n\ndef bitmex_symbols() -> Dict[str, str]:\n    r = None\n    ret = {}\n    try:\n        r = requests.get(\"https://www.bitmex.com/api/v1/instrument/active\")\n        for entry in r.json():\n            components = []\n            components.append(entry['rootSymbol'])\n            components.append(entry['quoteCurrency'])\n\n            if entry['expiry']:\n                components.append(entry['symbol'][-3:])\n\n            normalized = SYMBOL_SEP.join(components)\n            normalized = normalized.replace(\"XBT\", \"BTC\")\n            ret[normalized] = entry['symbol']\n            _exchange_info[BITMEX]['tick_size'][normalized] = entry['tickSize']\n\n            if entry['expiry']:\n                _exchange_info[BITMEX]['expiry'][normalized] = entry['expiry']\n\n        return ret\n    except Exception as why:\n        raise_failure_explanation('BITMEX', why, {\"\": r})\n\n\ndef deribit_symbols() -> Dict[str, str]:\n    url = r = None\n    ret = {}\n    try:\n        # TODO: get currencies from https://www.deribit.com/api/v2/public/get_currencies\n        currencies = ['BTC', 'ETH']\n        for c in currencies:\n            url = f\"https://www.deribit.com/api/v2/public/get_instruments?currency={c}&expired=false\"\n            r = requests.get(url)\n            for entry in r.json()['result']:\n                split = entry['instrument_name'].split(\"-\")\n                normalized = split[0] + SYMBOL_SEP + entry['quote_currency'] + \"-\" + '-'.join(split[1:])\n                ret[normalized] = entry['instrument_name']\n                _exchange_info[DERIBIT]['tick_size'][normalized] = entry['tick_size']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('DERIBIT', why, {url: r})\n\n\ndef kraken_future_symbols() -> Dict[str, str]:\n    r = None\n    ret = {}\n    try:\n        r = requests.get('https://futures.kraken.com/derivatives/api/v3/instruments')\n        data = r.json()['instruments']\n        for entry in data:\n            if not entry['tradeable']:\n                continue\n            normalized = entry['symbol'].upper().replace(\"_\", \"-\")\n            symbol = normalized[3:6] + SYMBOL_SEP + normalized[6:9]\n            normalized = normalized.replace(normalized[3:9], symbol)\n            normalized = normalized.replace('XBT', 'BTC')\n\n            _exchange_info[KRAKEN_FUTURES]['tick_size'][normalized] = entry['tickSize']\n            _exchange_info[KRAKEN_FUTURES]['contract_size'][normalized] = entry['contractSize']\n            _exchange_info[KRAKEN_FUTURES]['underlying'][normalized] = entry['underlying']\n            _exchange_info[KRAKEN_FUTURES]['product_type'][normalized] = _kraken_futures_product_type[normalized[:2]]\n            ret[normalized] = entry['symbol']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('KRAKEN_FUTURES', why, {\"\": r})\n\n\ndef probit_symbols() -> Dict[str, str]:\n    # doc: https://docs-en.probit.com/reference-link/market\n    r = None\n    try:\n        r = requests.get('https://api.probit.com/api/exchange/v1/market')\n        return {entry['id']: entry['id'] for entry in r.json()['data']}\n    except Exception as why:\n        raise_failure_explanation('PROBIT', why, {\"\": r})\n\n\ndef coingecko_normalize_symbol(symbol: str) -> str:\n    # keep digits, letters and dots, replace others by space\n    symbol = ''.join(c if c.isalnum() or c in ('.', '+') else ' ' for c in symbol)\n    return coingecko_normalize(symbol.upper())\n\n\ndef coingecko_normalize_name(name: str) -> str:\n    # keep digits and letters, replace others by space (except when only composed by upper case letters, digits and dots)\n    if not all(c.isupper() or c.isdigit() or c == '.' for c in name):\n        name = ''.join(c if c.isalnum() else ' ' for c in name)\n    return coingecko_normalize(name)\n\n\ndef coingecko_normalize(sym: str) -> str:\n    sym = sym.strip()\n    # do not concatenate numbers => separate them with a dot\n    sym = list(sym)\n    if len(sym) > 4:\n        for i in range(2, len(sym) - 1):\n            if sym[i] == ' ' and sym[i - 1].isdigit() and sym[i + 1].isdigit():\n                sym[i] = '.'\n    sym = ''.join(sym)\n    # concatenate space-separated words => use CamelCase to distinguish the words\n    if ' ' in sym:\n        if sum(c.islower() for c in sym):  # if there is at least one lower case letter\n            sym = ' '.join(word[0].upper() + word[1:] for word in sym.split())  # Just capitalize initial letter of each word\n        else:  # CoinGecko may provide full upper-case as for \"THE STONE COIN\"\n            sym = string.capwords(sym)  # capwords converts \"THE STONE COIN\" to \"The Stone Coin\"\n        sym = sym.replace(' ', '')  # concatenate words\n    return sym\n\n\ndef is_name_short(coin: dict) -> bool:\n    \"\"\"return True if the coin name is enough short compared to the coin symbol.\"\"\"\n    return len(coin['name']) <= max(5, len(coin['symbol']) + 1)\n\n\ndef has_many_caps(name: str) -> bool:\n    \"\"\"return True if the symbol contains enough upper case letters, False if empty.\"\"\"\n    return str and sum(c.islower() for c in name) < (len(name) / 2)\n\n\ndef coingecko_normalize_all(coin: dict):\n    SYMBOL_TO_NORMALIZED = {'miota': 'IOTA'}\n    normalized = SYMBOL_TO_NORMALIZED.get(coin['symbol'])\n    if normalized:\n        coin['ns'] = coin['nn'] = normalized\n        return normalized\n\n    # ns = normalized symbol, nn = normalized name\n    coin['ns'] = coingecko_normalize_symbol(coin['symbol'])\n\n    ID_SUFFIX = '-bitcoin-token'\n    if coin['id'][-len(ID_SUFFIX):] == ID_SUFFIX:\n        coin['nn'] = 'BTC' + coin['ns']\n        return coin['nn']\n\n    name = coin['name']\n\n    prefixes = ('The ', 'the ')\n    for p in prefixes:\n        if name[:len(p)] == p:\n            coin['reduced-name'] = True\n            name = name[len(p):]\n            break\n\n    suffixes = ('coin', 'coins', 'money', 'finance', 'protocol', 'reward', 'rewards', 'token')\n    for s in suffixes:\n        if len(name) > len(s) and name[-len(s):].lower() == s:\n            # but keep suffix when lower-case concatenated\n            if name[-len(s)].islower() and name[-len(s) - 1] != ' ':\n                continue\n            # also keep suffix to avoid confusing nam: \"Bitcoin Token\" -> \"Bitcoin\"\n            if name[:-len(s)].strip().lower() == 'bitcoin':\n                continue\n            coin['reduced-name'] = True\n            name = name[:-len(s)]\n            break\n\n    coin['nn'] = coingecko_normalize_name(name)\n\n    if len(coin['nn']) < len(coin['ns']):\n        if 'reduced-name' in coin:\n            coin['reduced-name'] = False\n            name = coin['name']\n            coin['nn'] = coingecko_normalize_name(name)\n        elif not has_many_caps(name):\n            return coin['ns']\n\n    if not coin['ns']:  # coin['symbol'] may be an emoji that is striped when normalized\n        return coin['nn']\n\n    if coin.get('reduced-name') and coin['ns'].upper() != coin['nn'].upper():\n        return coin['ns']\n\n    i = coin['nn'].find('.')  # if there is a dot in normalized name => prefer the normalized symbol\n    if i >= 0:\n        if i > 1 and coin['nn'][i - 1].isdigit() and coin['nn'][i + 1].isdigit():\n            pass  # except when the dot separates digits\n        else:\n            return coin['ns']\n\n    if is_name_short(coin) and has_many_caps(name):\n        return coin['nn']\n\n    if 1.5 * len(coin['ns']) > len(coin['nn']) and any(c.islower() for c in coin['ns']):\n        return coin['nn']\n\n    return coin['ns']\n\n\ndef coingecko_symbols() -> Dict[str, str]:\n    r = None\n    intermediate = defaultdict(list)\n    try:\n        r = requests.get('https://api.coingecko.com/api/v3/coins/list')\n        all_coins = r.json()\n        # First pass: generate & compare normalized symbol/name, and then select the most pertinent\n        for coin in all_coins:\n            normalized = coingecko_normalize_all(coin)\n            intermediate[normalized].append(coin)\n            # Above line keeps together the coins having the same normalized symbol.\n            # To reduce collision, the coin['name'] is sometimes used in lieu of the coin['symbol'].\n            # The coin['name'] is not capitalized because lower case letters may be meaningful: cETH, yUSD, DATx, zLOT\n    except Exception as why:\n        raise_failure_explanation('COINGECKO', why, {\"\": r})\n\n    final = coingecko_second_pass(intermediate)\n    return coingecko_third_pass(final)\n\n\ndef coingecko_second_pass(intermediate: Dict[str, List[dict]]) -> Dict[str, List[dict]]:\n    # Second pass: fixes most of the symbol collisions\n    final = defaultdict(list)\n    for normalized, coins in intermediate.items():\n        if len(coins) == 1:\n            final[normalized].append(coins[0])\n            continue\n        set_normalized = False\n        for i in range(len(coins)):\n            if normalized == coins[i]['nn']:\n                coin = coins.pop(i)\n                final[normalized].append(coin)\n                set_normalized = True\n                break\n        rest: List[dict] = []\n        for coin in coins:\n            if '%' in coin['name']:\n                if len(coins) == 1:\n                    n = coin['ns']\n                else:\n                    n = coingecko_normalize_name(coin['id'])\n                final[n].append(coin)\n            else:\n                rest.append(coin)\n        if not rest:\n            continue\n        if not set_normalized:\n            rest.sort(key=lambda coin: len(coin['nn']), reverse=True)  # sort by the length of the normalized name\n            coin = rest.pop(0)\n            final[normalized].append(coin)\n        for coin in rest:\n            if coin['nn'] not in intermediate:\n                n = coin['nn']\n            elif coin.get('reduced-name'):\n                n = coingecko_normalize_name(coin['name'])\n            else:\n                n = coingecko_normalize_name(coin['id'])\n            final[n].append(coin)\n    return final\n\n\ndef coingecko_third_pass(final: Dict[str, List[dict]]) -> Dict[str, str]:\n    # Third pass: fixes some remaining collisions and fills the result\n    symbols = {}\n    for normalized, coins in final.items():\n        if len(coins) == 1:\n            symbols[normalized] = coins[0]['id']\n            continue\n        set_normalized = False\n        for i in range(len(coins)):\n            if normalized == coins[i]['nn']:\n                coin = coins.pop(i)\n                symbols[normalized] = coin['id']\n                set_normalized = True\n                break\n        rest: List[dict] = []\n        for coin in coins:\n            if '%' in coin['name']:\n                if len(coins) == 1:\n                    n = coin['ns']\n                else:\n                    n = coingecko_normalize_name(coin['id'])\n                symbols[n] = coin['id']\n            else:\n                rest.append(coin)\n        if not rest:\n            continue\n        if not set_normalized:\n            rest.sort(key=lambda coin: len(coin['nn']), reverse=True)  # sort by the length of the normalized name\n            coin = rest.pop(0)\n            symbols[normalized] = coin['id']\n        for coin in rest:\n            if coin['nn'] not in final:\n                n = coin['nn']\n            elif coin.get('reduced-name'):\n                n = coingecko_normalize_name(coin['name'])\n            else:\n                n = coingecko_normalize_name(coin['id'])\n            symbols[n] = coin['id']\n    return symbols\n\n\ndef whale_alert_coins(key_id: str) -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get(f'https://api.whale-alert.io/v1/status?api_key={key_id}')\n        # Same symbols, but on different blockchains (for instance USDT), are naturally overwritten.\n        return {s.upper(): s for b in r.json()['blockchains'] for s in b['symbols'] if s}\n    except Exception as why:\n        raise_failure_explanation('WHALES_ALERT', why, {\"\": r})\n\n\n_exchange_function_map = {\n    BITFINEX: bitfinex_symbols,\n    BITFLYER: bitflyer_symbols,\n    COINBASE: coinbase_symbols,\n    GEMINI: gemini_symbols,\n    HITBTC: hitbtc_symbols,\n    POLONIEX: poloniex_symbols,\n    PROBIT: probit_symbols,\n    BITSTAMP: bitstamp_symbols,\n    KRAKEN: kraken_symbols,\n    KRAKEN + 'REST': kraken_rest_symbols,\n    BINANCE: binance_symbols,\n    BINANCE_US: binance_us_symbols,\n    BINANCE_FUTURES: binance_futures_symbols,\n    BINANCE_DELIVERY: binance_delivery_symbols,\n    BLOCKCHAIN: blockchain_symbols,\n    EXX: exx_symbols,\n    HUOBI: huobi_symbols,\n    HUOBI_DM: huobi_dm_symbols,\n    HUOBI_SWAP: huobi_swap_symbols,\n    OKCOIN: okcoin_symbols,\n    OKEX: okex_symbols,\n    BYBIT: bybit_symbols,\n    FTX: ftx_symbols,\n    FTX_US: ftx_us_symbols,\n    BITTREX: bittrex_symbols,\n    BITCOINCOM: bitcoincom_symbols,\n    BITMAX: bitmax_symbols,\n    UPBIT: upbit_symbols,\n    GATEIO: gateio_symbols,\n    BITMEX: bitmex_symbols,\n    DERIBIT: deribit_symbols,\n    KRAKEN_FUTURES: kraken_future_symbols,\n    COINGECKO: coingecko_symbols,\n    WHALE_ALERT: whale_alert_coins\n}\n",
        "source_code_len": 30534,
        "target_code": "associated with this software.\n'''\nfrom typing import Dict, Tuple\n\n\nclass _Symbols:\n    def __init__(self):\n        self.data = {}\n\n    def set(self, exchange: str, normalized: dict, exchange_info: dict):\n        self.data[exchange] = {}\n        self.data[exchange]['normalized'] = normalized\n        self.data[exchange]['info'] = exchange_info\n\n    def get(self, exchange: str) -> Tuple[Dict, Dict]:\n        return self.data[exchange]['normalized'], self.data[exchange]['info']\n\n    def populated(self, exchange: str) -> bool:\n        return exchange in self.data\n\n\nSymbols = _Symbols()\n",
        "target_code_len": 588,
        "diff_format": "@@ -5,845 +5,22 @@\n associated with this software.\n+'''\n+from typing import Dict, Tuple\n \n \n-Symbol generation code for exchanges\n-'''\n+class _Symbols:\n+    def __init__(self):\n+        self.data = {}\n \n-import logging\n-import string\n-import time\n-from collections import defaultdict\n-from typing import Dict, List, Optional, Tuple\n+    def set(self, exchange: str, normalized: dict, exchange_info: dict):\n+        self.data[exchange] = {}\n+        self.data[exchange]['normalized'] = normalized\n+        self.data[exchange]['info'] = exchange_info\n \n-import requests\n-from requests import Response\n+    def get(self, exchange: str) -> Tuple[Dict, Dict]:\n+        return self.data[exchange]['normalized'], self.data[exchange]['info']\n \n-from cryptofeed.defines import *\n+    def populated(self, exchange: str) -> bool:\n+        return exchange in self.data\n \n \n-LOG = logging.getLogger('feedhandler')\n-\n-SYMBOL_SEP = '-'\n-\n-_symbols_retrieval_cache: Dict[str, Dict[str, str]] = {}\n-_exchange_info = defaultdict(lambda: defaultdict(dict))\n-\n-\n-_kraken_futures_product_type = {\n-    'FI': 'Inverse Futures',\n-    'FV': 'Vanilla Futures',\n-    'PI': 'Perpetual Inverse Futures',\n-    'PV': 'Perpetual Vanilla Futures',\n-    'IN': 'Real Time Index',\n-    'RR': 'Reference Rate',\n-}\n-\n-\n-def raise_failure_explanation(feed_id: str, exception: BaseException, responses: Dict[str, Optional[Response]]):\n-    LOG.critical('%s: encountered %r while processing response from exchange API', feed_id, exception)\n-    if len(responses) > 1:\n-        LOG.critical('%s: content of one of the %s responses was unexpected', feed_id, len(responses))\n-    for url, r in responses.items():\n-        if url:\n-            LOG.critical('%s: requested URL: %s', feed_id, url)\n-        if r:\n-            LOG.critical('%s: unexpected response: %s', feed_id, r.text)\n-    raise ValueError(f'Cryptofeed stopped because of an unexpected response from {feed_id}') from exception\n-\n-\n-def set_symbol_separator(separator: str):\n-    global SYMBOL_SEP\n-    SYMBOL_SEP = separator\n-\n-\n-def get_symbol_separator() -> str:\n-    global SYMBOL_SEP\n-    return SYMBOL_SEP\n-\n-\n-def gen_symbols(exchange: str, key_id=None) -> Dict[str, str]:\n-    if exchange not in _symbols_retrieval_cache:\n-        LOG.info(\"%s: Getting list of symbols\", exchange)\n-        symbols = _exchange_function_map[exchange](key_id) if key_id else _exchange_function_map[exchange]()\n-        LOG.info(\"%s: %s symbols\", exchange, len(symbols))\n-\n-        # log all retrieved symbols using debug level\n-        for normalized, exch_sym in sorted(symbols.items()):\n-            LOG.debug('%s: id-from-exch -> normalized: %-35s-> %s', exchange, exch_sym, normalized)\n-\n-        _symbols_retrieval_cache[exchange] = symbols\n-    return _symbols_retrieval_cache[exchange]\n-\n-\n-def _binance_symbols(endpoint: str, exchange: str):\n-    r = None\n-    try:\n-        ret = {}\n-        r = requests.get(endpoint)\n-        for symbol in r.json()['symbols']:\n-            if symbol.get('status', 'TRADING') != \"TRADING\":\n-                continue\n-            if symbol.get('contractStatus', 'TRADING') != \"TRADING\":\n-                continue\n-            split = len(symbol['baseAsset'])\n-            normalized = symbol['symbol'][:split] + SYMBOL_SEP + symbol['symbol'][split:]\n-            ret[normalized] = symbol['symbol']\n-            _exchange_info[exchange]['tick_size'][normalized] = symbol['filters'][0]['tickSize']\n-            if \"contractType\" in symbol:\n-                _exchange_info[exchange]['contract_type'][normalized] = symbol['contractType']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation(exchange, why, {endpoint: r})\n-\n-\n-def binance_symbols() -> Dict[str, str]:\n-    return _binance_symbols('https://api.binance.com/api/v3/exchangeInfo', BINANCE)\n-\n-\n-def binance_us_symbols() -> Dict[str, str]:\n-    return _binance_symbols('https://api.binance.us/api/v3/exchangeInfo', BINANCE_US)\n-\n-\n-def binance_futures_symbols() -> Dict[str, str]:\n-    base = _binance_symbols('https://fapi.binance.com/fapi/v1/exchangeInfo', BINANCE_FUTURES)\n-    add = {}\n-    for symbol, orig in base.items():\n-        if \"_\" in orig:\n-            continue\n-        add[f\"{symbol}-PINDEX\"] = f\"p{orig}\"\n-    base.update(add)\n-    return base\n-\n-\n-def binance_delivery_symbols() -> Dict[str, str]:\n-    return _binance_symbols('https://dapi.binance.com/dapi/v1/exchangeInfo', BINANCE_DELIVERY)\n-\n-\n-def bitfinex_symbols() -> Dict[str, str]:\n-    # doc: https://docs.bitfinex.com/docs/ws-general#supported-pairs\n-    r1 = r2 = None\n-    try:\n-        r1 = requests.get('https://api.bitfinex.com/v2/tickers?symbols=ALL')\n-        r2 = requests.get('https://api-pub.bitfinex.com/v2/conf/pub:map:currency:sym')\n-        tickers: List[List[str]] = r1.json()\n-        norm: List[Tuple[str, str]] = r2.json()[0]\n-        norm: Dict[str, str] = dict(norm)\n-        for k, v in dict(norm).items():\n-            if k[-2:] == 'F0' or '-' in v:  # Do not convert BTCF0 -> BTC or PBTCETH -> PBTC-ETH\n-                del norm[k]\n-        norm['BCHN'] = 'BCH'  # Bitfinex uses BCHN, other exchanges use BCH\n-\n-        ret = {}\n-        for symbol in [t[0] for t in tickers]:\n-            if symbol[0] == 'f':\n-                normalized = norm.get(symbol[1:], symbol[1:])\n-            else:\n-                if len(symbol) == 7:\n-                    base, quote = symbol[1:4], symbol[4:]\n-                else:\n-                    base, quote = symbol[1:].split(':')\n-                    assert ':' in symbol\n-                normalized = norm.get(base, base) + SYMBOL_SEP + norm.get(quote, quote)\n-            ret[normalized.upper()] = symbol\n-        return ret\n-    except ValueError as why:\n-        raise_failure_explanation('BITFINEX', why, {\"tickers?symbols=ALL\": r1, \"pub:map:currency:sym\": r2})\n-\n-\n-def bitflyer_symbols() -> Dict[str, str]:\n-    endpoint = r = None\n-    try:\n-        ret = {}\n-        endpoints = ['https://api.bitflyer.com/v1/getmarkets/eu', 'https://api.bitflyer.com/v1/getmarkets/usa', 'https://api.bitflyer.com/v1/getmarkets']\n-        for endpoint in endpoints:\n-            r = requests.get(endpoint)\n-            for entry in r.json():\n-                normalized = entry['product_code'].replace(\"_\", SYMBOL_SEP)\n-                ret[normalized] = entry['product_code']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('BITFLYER', why, {endpoint: r})\n-\n-\n-def bybit_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.bybit.com/v2/public/symbols')\n-        ret = {}\n-        for symbol in r.json()['result']:\n-            quote = symbol['quote_currency']\n-            if not symbol['name'].endswith(quote):\n-                base, contract = symbol['name'].split(quote)\n-                normalized = f\"{base}{SYMBOL_SEP}{quote}-{contract}\"\n-            else:\n-                normalized = f\"{symbol['base_currency']}{SYMBOL_SEP}{quote}\"\n-            ret[normalized] = symbol['name']\n-            _exchange_info[BYBIT]['tick_size'][normalized] = symbol['price_filter']['tick_size']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('BYBIT', why, {\"\": r})\n-\n-\n-def _ftx_helper(endpoint: str, exchange: str):\n-    r = None\n-    try:\n-        r = requests.get(endpoint)\n-        ret = {}\n-        for data in r.json()['result']:\n-            normalized = data['name'].replace(\"/\", SYMBOL_SEP)\n-            symbol = data['name']\n-            ret[normalized] = symbol\n-            _exchange_info[exchange]['tick_size'][normalized] = data['priceIncrement']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation(exchange, why, {endpoint: r})\n-\n-\n-def ftx_symbols() -> Dict[str, str]:\n-    return _ftx_helper('https://ftx.com/api/markets', FTX)\n-\n-\n-def ftx_us_symbols() -> Dict[str, str]:\n-    return _ftx_helper('https://ftx.us/api/markets', FTX_US)\n-\n-\n-def coinbase_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.pro.coinbase.com/products')\n-        ret = {}\n-        for data in r.json():\n-            normalized = data['id'].replace(\"-\", SYMBOL_SEP)\n-            ret[normalized] = data['id']\n-            _exchange_info[COINBASE]['tick_size'][normalized] = data['quote_increment']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('COINBASE', why, {\"\": r})\n-\n-\n-def gemini_symbols(*args) -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.gemini.com/v1/symbols')\n-        ret = {}\n-        for symbol in r.json():\n-            std = f\"{symbol[:-3]}{SYMBOL_SEP}{symbol[-3:]}\"\n-            std = std.upper()\n-            ret[std] = symbol.upper()\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('GEMINI', why, {\"\": r})\n-\n-\n-def hitbtc_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        ret = {}\n-        r = requests.get('https://api.hitbtc.com/api/2/public/symbol')\n-        for symbol in r.json():\n-            split = len(symbol['baseCurrency'])\n-            normalized = symbol['id'][:split] + SYMBOL_SEP + symbol['id'][split:]\n-            ret[normalized] = symbol['id']\n-            _exchange_info[HITBTC]['tick_size'][normalized] = symbol['tickSize']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('HITBTC', why, {\"\": r})\n-\n-\n-def poloniex_id_symbol_mapping():\n-    r = None\n-    try:\n-        r = requests.get('https://poloniex.com/public?command=returnTicker')\n-        symbols = r.json()\n-        ret = {}\n-        for symbol in symbols:\n-            ret[symbols[symbol]['id']] = symbol\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('POLONIEX', why, {\"\": r})\n-\n-\n-def poloniex_symbols() -> Dict[str, str]:\n-    ret = {}\n-    for _, value in poloniex_id_symbol_mapping().items():\n-        std = value.replace(\"STR\", \"XLM\")\n-        quote, base = std.split(\"_\")\n-        ret[quote + SYMBOL_SEP + base] = value\n-    return ret\n-\n-\n-def bitstamp_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://www.bitstamp.net/api/v2/trading-pairs-info/')\n-        ret = {}\n-        for data in r.json():\n-            normalized = data['name'].replace(\"/\", SYMBOL_SEP)\n-            symbol = data['url_symbol']\n-            ret[normalized] = symbol\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('BITSTAMP', why, {\"\": r})\n-\n-\n-def kraken_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.kraken.com/0/public/AssetPairs')\n-        data = r.json()\n-        ret = {}\n-        for symbol in data['result']:\n-            if 'wsname' not in data['result'][symbol] or '.d' in symbol:\n-                # https://blog.kraken.com/post/259/introducing-the-kraken-dark-pool/\n-                # .d is for dark pool symbols\n-                continue\n-\n-            base, quote = data['result'][symbol]['wsname'].split(\"/\")\n-\n-            normalized = f\"{base}{SYMBOL_SEP}{quote}\"\n-            exch = data['result'][symbol]['wsname']\n-            normalized = normalized.replace('XBT', 'BTC')\n-            normalized = normalized.replace('XDG', 'DOG')\n-            ret[normalized] = exch\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('KRAKEN', why, {\"\": r})\n-\n-\n-def kraken_rest_symbols() -> Dict[str, str]:\n-    return {normalized: exchange.replace(\"/\", \"\") for normalized, exchange in kraken_symbols().items()}\n-\n-\n-def exx_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.exx.com/data/v1/tickers')\n-        exchange = [key.upper() for key in r.json().keys()]\n-        symbols = [key.replace(\"_\", SYMBOL_SEP) for key in exchange]\n-        return dict(zip(symbols, exchange))\n-    except Exception as why:\n-        raise_failure_explanation('EXX', why, {\"\": r})\n-\n-\n-def huobi_common_symbols(url: str):\n-    r = None\n-    try:\n-        r = requests.get(url)\n-        ret = {}\n-        for e in r.json()['data']:\n-            if e['state'] == 'offline':\n-                continue\n-            normalized = f\"{e['base-currency'].upper()}{SYMBOL_SEP}{e['quote-currency'].upper()}\"\n-            symbol = f\"{e['base-currency']}{e['quote-currency']}\"\n-            ret[normalized] = symbol\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('HUOBI', why, {url: r})\n-\n-\n-def huobi_symbols() -> Dict[str, str]:\n-    return huobi_common_symbols('https://api.huobi.pro/v1/common/symbols')\n-\n-\n-def huobi_us_symbols() -> Dict[str, str]:\n-    return huobi_common_symbols('https://api.huobi.com/v1/common/symbols')\n-\n-\n-def huobi_dm_symbols() -> Dict[str, str]:\n-    \"\"\"\n-    Mapping is, for instance: {\"BTC_CW\":\"BTC190816\"}\n-    See comments in exchange/huobi_dm.py\n-    \"\"\"\n-    mapping = {\n-        \"this_week\": \"CW\",\n-        \"next_week\": \"NW\",\n-        \"quarter\": \"CQ\",\n-        \"next_quarter\": \"NQ\"\n-    }\n-    r = None\n-    try:\n-        r = requests.get('https://www.hbdm.com/api/v1/contract_contract_info')\n-        symbols = {}\n-        for e in r.json()['data']:\n-            symbols[f\"{e['symbol']}_{mapping[e['contract_type']]}\"] = e['contract_code']\n-            _exchange_info[HUOBI_DM]['tick_size'][e['contract_code']] = e['price_tick']\n-            _exchange_info[HUOBI_DM]['short_code_mappings'][f\"{e['symbol']}_{mapping[e['contract_type']]}\"] = e['contract_code']\n-        return symbols\n-    except Exception as why:\n-        raise_failure_explanation('HUOBI_DM', why, {\"\": r})\n-\n-\n-def huobi_swap_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.hbdm.com/swap-api/v1/swap_contract_info')\n-        symbols = {}\n-        for e in r.json()['data']:\n-            symbols[e['contract_code']] = e['contract_code']\n-            _exchange_info[HUOBI_SWAP]['tick_size'][e['contract_code']] = e['price_tick']\n-        return symbols\n-    except Exception as why:\n-        raise_failure_explanation('HUOBI_SWAP', why, {\"\": r})\n-\n-\n-def okcoin_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://www.okcoin.com/api/spot/v3/instruments')\n-        ret = {}\n-        for e in r.json():\n-            ret[e['instrument_id']] = e['instrument_id']\n-            _exchange_info[OKCOIN]['tick_size'][e['instrument_id']] = e['tick_size']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('OKCOIN', why, {\"\": r})\n-\n-\n-def okex_symbols(*args) -> Dict[str, str]:\n-    urls = ['https://www.okex.com/api/spot/v3/instruments',\n-            'https://www.okex.com/api/swap/v3/instruments',\n-            'https://www.okex.com/api/futures/v3/instruments']\n-    urls = urls + okex_compute_option_urls_from_underlyings()\n-\n-    symbols: Dict[str, str] = {}\n-    for u in urls:\n-        time.sleep(0.2)\n-        symbols.update(okex_symbols_from_one_url(u))\n-\n-    for symbol in symbols:\n-        instrument_type = 'futures'\n-        dash_count = symbol.count(get_symbol_separator())\n-        if dash_count == 1:  # BTC-USDT\n-            instrument_type = 'spot'\n-        if dash_count == 4:  # BTC-USD-201225-35000-P\n-            instrument_type = 'option'\n-        if symbol[-4:] == \"SWAP\":  # BTC-USDT-SWAP\n-            instrument_type = 'swap'\n-\n-        _exchange_info[OKEX]['instrument_type'][symbol] = instrument_type\n-\n-    return symbols\n-\n-\n-def okex_compute_option_urls_from_underlyings() -> List[str]:\n-    url = 'https://www.okex.com/api/option/v3/underlying'\n-    r = None\n-    try:\n-        r = requests.get(url)\n-        return [f'https://www.okex.com/api/option/v3/instruments/{underlying}' for underlying in r.json()]\n-    except Exception as why:\n-        raise_failure_explanation('OKEX', why, {url: r})\n-\n-\n-def okex_symbols_from_one_url(url: str) -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get(url)\n-        ret = {}\n-        for e in r.json():\n-            ret[e['instrument_id']] = e['instrument_id']\n-            _exchange_info[OKEX]['tick_size'][e['instrument_id']] = e['tick_size']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('OKEX', why, {url: r})\n-\n-\n-def bittrex_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.bittrex.com/api/v1.1/public/getmarkets')\n-        r = r.json()['result']\n-        return {f\"{e['MarketCurrency']}{SYMBOL_SEP}{e['BaseCurrency']}\": e['MarketName'] for e in r if e['IsActive']}\n-    except Exception as why:\n-        raise_failure_explanation('BITTREX', why, {\"\": r})\n-\n-\n-def bitcoincom_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.exchange.bitcoin.com/api/2/public/symbol')\n-        return {f\"{data['baseCurrency']}{SYMBOL_SEP}{data['quoteCurrency'].replace('USD', 'USDT')}\": data['id'] for data in r.json()}\n-    except Exception as why:\n-        raise_failure_explanation('BITCOINCOM', why, {\"\": r})\n-\n-\n-def bitmax_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://bitmax.io/api/pro/v1/products')\n-        ret = {}\n-        for entry in r.json()['data']:\n-            # Only \"Normal\" status symbols are tradeable\n-            if entry['status'] == 'Normal':\n-                normalized = f\"{entry['baseAsset']}{SYMBOL_SEP}{entry['quoteAsset']}\"\n-                ret[normalized] = entry['symbol']\n-                _exchange_info[BITMAX]['tick_size'][normalized] = entry['tickSize']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('BITMAX', why, {\"\": r})\n-\n-\n-def upbit_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.upbit.com/v1/market/all')\n-        return {f\"{data['market'].split('-')[1]}{SYMBOL_SEP}{data['market'].split('-')[0]}\": data['market'] for data in r.json()}\n-    except Exception as why:\n-        raise_failure_explanation('UPBIT', why, {\"\": r})\n-\n-\n-def blockchain_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get(\"https://api.blockchain.com/mercury-gateway/v1/instruments\")\n-        return {data[\"symbol\"].replace(\"-\", SYMBOL_SEP): data[\"symbol\"] for data in r.json()}\n-    except Exception as why:\n-        raise_failure_explanation('BLOCKCHAIN', why, {\"\": r})\n-\n-\n-def gateio_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get(\"https://api.gateio.ws/api/v4/spot/currency_pairs\")\n-        return {data[\"id\"].replace(\"_\", SYMBOL_SEP): data['id'] for data in r.json()}\n-    except Exception as why:\n-        raise_failure_explanation('GATEIO', why, {\"\": r})\n-\n-\n-def bitmex_symbols() -> Dict[str, str]:\n-    r = None\n-    ret = {}\n-    try:\n-        r = requests.get(\"https://www.bitmex.com/api/v1/instrument/active\")\n-        for entry in r.json():\n-            components = []\n-            components.append(entry['rootSymbol'])\n-            components.append(entry['quoteCurrency'])\n-\n-            if entry['expiry']:\n-                components.append(entry['symbol'][-3:])\n-\n-            normalized = SYMBOL_SEP.join(components)\n-            normalized = normalized.replace(\"XBT\", \"BTC\")\n-            ret[normalized] = entry['symbol']\n-            _exchange_info[BITMEX]['tick_size'][normalized] = entry['tickSize']\n-\n-            if entry['expiry']:\n-                _exchange_info[BITMEX]['expiry'][normalized] = entry['expiry']\n-\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('BITMEX', why, {\"\": r})\n-\n-\n-def deribit_symbols() -> Dict[str, str]:\n-    url = r = None\n-    ret = {}\n-    try:\n-        # TODO: get currencies from https://www.deribit.com/api/v2/public/get_currencies\n-        currencies = ['BTC', 'ETH']\n-        for c in currencies:\n-            url = f\"https://www.deribit.com/api/v2/public/get_instruments?currency={c}&expired=false\"\n-            r = requests.get(url)\n-            for entry in r.json()['result']:\n-                split = entry['instrument_name'].split(\"-\")\n-                normalized = split[0] + SYMBOL_SEP + entry['quote_currency'] + \"-\" + '-'.join(split[1:])\n-                ret[normalized] = entry['instrument_name']\n-                _exchange_info[DERIBIT]['tick_size'][normalized] = entry['tick_size']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('DERIBIT', why, {url: r})\n-\n-\n-def kraken_future_symbols() -> Dict[str, str]:\n-    r = None\n-    ret = {}\n-    try:\n-        r = requests.get('https://futures.kraken.com/derivatives/api/v3/instruments')\n-        data = r.json()['instruments']\n-        for entry in data:\n-            if not entry['tradeable']:\n-                continue\n-            normalized = entry['symbol'].upper().replace(\"_\", \"-\")\n-            symbol = normalized[3:6] + SYMBOL_SEP + normalized[6:9]\n-            normalized = normalized.replace(normalized[3:9], symbol)\n-            normalized = normalized.replace('XBT', 'BTC')\n-\n-            _exchange_info[KRAKEN_FUTURES]['tick_size'][normalized] = entry['tickSize']\n-            _exchange_info[KRAKEN_FUTURES]['contract_size'][normalized] = entry['contractSize']\n-            _exchange_info[KRAKEN_FUTURES]['underlying'][normalized] = entry['underlying']\n-            _exchange_info[KRAKEN_FUTURES]['product_type'][normalized] = _kraken_futures_product_type[normalized[:2]]\n-            ret[normalized] = entry['symbol']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('KRAKEN_FUTURES', why, {\"\": r})\n-\n-\n-def probit_symbols() -> Dict[str, str]:\n-    # doc: https://docs-en.probit.com/reference-link/market\n-    r = None\n-    try:\n-        r = requests.get('https://api.probit.com/api/exchange/v1/market')\n-        return {entry['id']: entry['id'] for entry in r.json()['data']}\n-    except Exception as why:\n-        raise_failure_explanation('PROBIT', why, {\"\": r})\n-\n-\n-def coingecko_normalize_symbol(symbol: str) -> str:\n-    # keep digits, letters and dots, replace others by space\n-    symbol = ''.join(c if c.isalnum() or c in ('.', '+') else ' ' for c in symbol)\n-    return coingecko_normalize(symbol.upper())\n-\n-\n-def coingecko_normalize_name(name: str) -> str:\n-    # keep digits and letters, replace others by space (except when only composed by upper case letters, digits and dots)\n-    if not all(c.isupper() or c.isdigit() or c == '.' for c in name):\n-        name = ''.join(c if c.isalnum() else ' ' for c in name)\n-    return coingecko_normalize(name)\n-\n-\n-def coingecko_normalize(sym: str) -> str:\n-    sym = sym.strip()\n-    # do not concatenate numbers => separate them with a dot\n-    sym = list(sym)\n-    if len(sym) > 4:\n-        for i in range(2, len(sym) - 1):\n-            if sym[i] == ' ' and sym[i - 1].isdigit() and sym[i + 1].isdigit():\n-                sym[i] = '.'\n-    sym = ''.join(sym)\n-    # concatenate space-separated words => use CamelCase to distinguish the words\n-    if ' ' in sym:\n-        if sum(c.islower() for c in sym):  # if there is at least one lower case letter\n-            sym = ' '.join(word[0].upper() + word[1:] for word in sym.split())  # Just capitalize initial letter of each word\n-        else:  # CoinGecko may provide full upper-case as for \"THE STONE COIN\"\n-            sym = string.capwords(sym)  # capwords converts \"THE STONE COIN\" to \"The Stone Coin\"\n-        sym = sym.replace(' ', '')  # concatenate words\n-    return sym\n-\n-\n-def is_name_short(coin: dict) -> bool:\n-    \"\"\"return True if the coin name is enough short compared to the coin symbol.\"\"\"\n-    return len(coin['name']) <= max(5, len(coin['symbol']) + 1)\n-\n-\n-def has_many_caps(name: str) -> bool:\n-    \"\"\"return True if the symbol contains enough upper case letters, False if empty.\"\"\"\n-    return str and sum(c.islower() for c in name) < (len(name) / 2)\n-\n-\n-def coingecko_normalize_all(coin: dict):\n-    SYMBOL_TO_NORMALIZED = {'miota': 'IOTA'}\n-    normalized = SYMBOL_TO_NORMALIZED.get(coin['symbol'])\n-    if normalized:\n-        coin['ns'] = coin['nn'] = normalized\n-        return normalized\n-\n-    # ns = normalized symbol, nn = normalized name\n-    coin['ns'] = coingecko_normalize_symbol(coin['symbol'])\n-\n-    ID_SUFFIX = '-bitcoin-token'\n-    if coin['id'][-len(ID_SUFFIX):] == ID_SUFFIX:\n-        coin['nn'] = 'BTC' + coin['ns']\n-        return coin['nn']\n-\n-    name = coin['name']\n-\n-    prefixes = ('The ', 'the ')\n-    for p in prefixes:\n-        if name[:len(p)] == p:\n-            coin['reduced-name'] = True\n-            name = name[len(p):]\n-            break\n-\n-    suffixes = ('coin', 'coins', 'money', 'finance', 'protocol', 'reward', 'rewards', 'token')\n-    for s in suffixes:\n-        if len(name) > len(s) and name[-len(s):].lower() == s:\n-            # but keep suffix when lower-case concatenated\n-            if name[-len(s)].islower() and name[-len(s) - 1] != ' ':\n-                continue\n-            # also keep suffix to avoid confusing nam: \"Bitcoin Token\" -> \"Bitcoin\"\n-            if name[:-len(s)].strip().lower() == 'bitcoin':\n-                continue\n-            coin['reduced-name'] = True\n-            name = name[:-len(s)]\n-            break\n-\n-    coin['nn'] = coingecko_normalize_name(name)\n-\n-    if len(coin['nn']) < len(coin['ns']):\n-        if 'reduced-name' in coin:\n-            coin['reduced-name'] = False\n-            name = coin['name']\n-            coin['nn'] = coingecko_normalize_name(name)\n-        elif not has_many_caps(name):\n-            return coin['ns']\n-\n-    if not coin['ns']:  # coin['symbol'] may be an emoji that is striped when normalized\n-        return coin['nn']\n-\n-    if coin.get('reduced-name') and coin['ns'].upper() != coin['nn'].upper():\n-        return coin['ns']\n-\n-    i = coin['nn'].find('.')  # if there is a dot in normalized name => prefer the normalized symbol\n-    if i >= 0:\n-        if i > 1 and coin['nn'][i - 1].isdigit() and coin['nn'][i + 1].isdigit():\n-            pass  # except when the dot separates digits\n-        else:\n-            return coin['ns']\n-\n-    if is_name_short(coin) and has_many_caps(name):\n-        return coin['nn']\n-\n-    if 1.5 * len(coin['ns']) > len(coin['nn']) and any(c.islower() for c in coin['ns']):\n-        return coin['nn']\n-\n-    return coin['ns']\n-\n-\n-def coingecko_symbols() -> Dict[str, str]:\n-    r = None\n-    intermediate = defaultdict(list)\n-    try:\n-        r = requests.get('https://api.coingecko.com/api/v3/coins/list')\n-        all_coins = r.json()\n-        # First pass: generate & compare normalized symbol/name, and then select the most pertinent\n-        for coin in all_coins:\n-            normalized = coingecko_normalize_all(coin)\n-            intermediate[normalized].append(coin)\n-            # Above line keeps together the coins having the same normalized symbol.\n-            # To reduce collision, the coin['name'] is sometimes used in lieu of the coin['symbol'].\n-            # The coin['name'] is not capitalized because lower case letters may be meaningful: cETH, yUSD, DATx, zLOT\n-    except Exception as why:\n-        raise_failure_explanation('COINGECKO', why, {\"\": r})\n-\n-    final = coingecko_second_pass(intermediate)\n-    return coingecko_third_pass(final)\n-\n-\n-def coingecko_second_pass(intermediate: Dict[str, List[dict]]) -> Dict[str, List[dict]]:\n-    # Second pass: fixes most of the symbol collisions\n-    final = defaultdict(list)\n-    for normalized, coins in intermediate.items():\n-        if len(coins) == 1:\n-            final[normalized].append(coins[0])\n-            continue\n-        set_normalized = False\n-        for i in range(len(coins)):\n-            if normalized == coins[i]['nn']:\n-                coin = coins.pop(i)\n-                final[normalized].append(coin)\n-                set_normalized = True\n-                break\n-        rest: List[dict] = []\n-        for coin in coins:\n-            if '%' in coin['name']:\n-                if len(coins) == 1:\n-                    n = coin['ns']\n-                else:\n-                    n = coingecko_normalize_name(coin['id'])\n-                final[n].append(coin)\n-            else:\n-                rest.append(coin)\n-        if not rest:\n-            continue\n-        if not set_normalized:\n-            rest.sort(key=lambda coin: len(coin['nn']), reverse=True)  # sort by the length of the normalized name\n-            coin = rest.pop(0)\n-            final[normalized].append(coin)\n-        for coin in rest:\n-            if coin['nn'] not in intermediate:\n-                n = coin['nn']\n-            elif coin.get('reduced-name'):\n-                n = coingecko_normalize_name(coin['name'])\n-            else:\n-                n = coingecko_normalize_name(coin['id'])\n-            final[n].append(coin)\n-    return final\n-\n-\n-def coingecko_third_pass(final: Dict[str, List[dict]]) -> Dict[str, str]:\n-    # Third pass: fixes some remaining collisions and fills the result\n-    symbols = {}\n-    for normalized, coins in final.items():\n-        if len(coins) == 1:\n-            symbols[normalized] = coins[0]['id']\n-            continue\n-        set_normalized = False\n-        for i in range(len(coins)):\n-            if normalized == coins[i]['nn']:\n-                coin = coins.pop(i)\n-                symbols[normalized] = coin['id']\n-                set_normalized = True\n-                break\n-        rest: List[dict] = []\n-        for coin in coins:\n-            if '%' in coin['name']:\n-                if len(coins) == 1:\n-                    n = coin['ns']\n-                else:\n-                    n = coingecko_normalize_name(coin['id'])\n-                symbols[n] = coin['id']\n-            else:\n-                rest.append(coin)\n-        if not rest:\n-            continue\n-        if not set_normalized:\n-            rest.sort(key=lambda coin: len(coin['nn']), reverse=True)  # sort by the length of the normalized name\n-            coin = rest.pop(0)\n-            symbols[normalized] = coin['id']\n-        for coin in rest:\n-            if coin['nn'] not in final:\n-                n = coin['nn']\n-            elif coin.get('reduced-name'):\n-                n = coingecko_normalize_name(coin['name'])\n-            else:\n-                n = coingecko_normalize_name(coin['id'])\n-            symbols[n] = coin['id']\n-    return symbols\n-\n-\n-def whale_alert_coins(key_id: str) -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get(f'https://api.whale-alert.io/v1/status?api_key={key_id}')\n-        # Same symbols, but on different blockchains (for instance USDT), are naturally overwritten.\n-        return {s.upper(): s for b in r.json()['blockchains'] for s in b['symbols'] if s}\n-    except Exception as why:\n-        raise_failure_explanation('WHALES_ALERT', why, {\"\": r})\n-\n-\n-_exchange_function_map = {\n-    BITFINEX: bitfinex_symbols,\n-    BITFLYER: bitflyer_symbols,\n-    COINBASE: coinbase_symbols,\n-    GEMINI: gemini_symbols,\n-    HITBTC: hitbtc_symbols,\n-    POLONIEX: poloniex_symbols,\n-    PROBIT: probit_symbols,\n-    BITSTAMP: bitstamp_symbols,\n-    KRAKEN: kraken_symbols,\n-    KRAKEN + 'REST': kraken_rest_symbols,\n-    BINANCE: binance_symbols,\n-    BINANCE_US: binance_us_symbols,\n-    BINANCE_FUTURES: binance_futures_symbols,\n-    BINANCE_DELIVERY: binance_delivery_symbols,\n-    BLOCKCHAIN: blockchain_symbols,\n-    EXX: exx_symbols,\n-    HUOBI: huobi_symbols,\n-    HUOBI_DM: huobi_dm_symbols,\n-    HUOBI_SWAP: huobi_swap_symbols,\n-    OKCOIN: okcoin_symbols,\n-    OKEX: okex_symbols,\n-    BYBIT: bybit_symbols,\n-    FTX: ftx_symbols,\n-    FTX_US: ftx_us_symbols,\n-    BITTREX: bittrex_symbols,\n-    BITCOINCOM: bitcoincom_symbols,\n-    BITMAX: bitmax_symbols,\n-    UPBIT: upbit_symbols,\n-    GATEIO: gateio_symbols,\n-    BITMEX: bitmex_symbols,\n-    DERIBIT: deribit_symbols,\n-    KRAKEN_FUTURES: kraken_future_symbols,\n-    COINGECKO: coingecko_symbols,\n-    WHALE_ALERT: whale_alert_coins\n-}\n+Symbols = _Symbols()\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\n\nimport logging\nimport string\nimport time\nfrom collections import defaultdict\nfrom typing import Dict, List, Optional, Tuple\n\nimport requests\nfrom requests import Response\n\nfrom cryptofeed.defines import *\n\n\nLOG = logging.getLogger('feedhandler')\n\nSYMBOL_SEP = '-'\n\n_symbols_retrieval_cache: Dict[str, Dict[str, str]] = {}\n_exchange_info = defaultdict(lambda: defaultdict(dict))\n\n\n_kraken_futures_product_type = {\n    'FI': 'Inverse Futures',\n    'FV': 'Vanilla Futures',\n    'PI': 'Perpetual Inverse Futures',\n    'PV': 'Perpetual Vanilla Futures',\n    'IN': 'Real Time Index',\n    'RR': 'Reference Rate',\n}\n\n\ndef raise_failure_explanation(feed_id: str, exception: BaseException, responses: Dict[str, Optional[Response]]):\n    <IND>LOG.critical('%s: encountered %r while processing response from exchange API', feed_id, exception)\n    if len(responses) > 1:\n        <IND>LOG.critical('%s: content of one of the %s responses was unexpected', feed_id, len(responses))\n    <DED>for url, r in responses.items():\n        <IND>if url:\n            <IND>LOG.critical('%s: requested URL: %s', feed_id, url)\n        <DED>if r:\n            <IND>LOG.critical('%s: unexpected response: %s', feed_id, r.text)\n    <DED><DED>raise ValueError(f'Cryptofeed stopped because of an unexpected response from {feed_id}') from exception\n\n\n<DED>def set_symbol_separator(separator: str):\n    <IND>global SYMBOL_SEP\n    SYMBOL_SEP = separator\n\n\n<DED>def get_symbol_separator() -> str:\n    <IND>global SYMBOL_SEP\n    return SYMBOL_SEP\n\n\n<DED>def gen_symbols(exchange: str, key_id=None) -> Dict[str, str]:\n    <IND>if exchange not in _symbols_retrieval_cache:\n        <IND>LOG.info(\"%s: Getting list of symbols\", exchange)\n        symbols = _exchange_function_map[exchange](key_id) if key_id else _exchange_function_map[exchange]()\n        LOG.info(\"%s: %s symbols\", exchange, len(symbols))\n\n        # log all retrieved symbols using debug level\n        for normalized, exch_sym in sorted(symbols.items()):\n            <IND>LOG.debug('%s: id-from-exch -> normalized: %-35s-> %s', exchange, exch_sym, normalized)\n\n        <DED>_symbols_retrieval_cache[exchange] = symbols\n    <DED>return _symbols_retrieval_cache[exchange]\n\n\n<DED>def _binance_symbols(endpoint: str, exchange: str):\n    <IND>r = None\n    try:\n        <IND>ret = {}\n        r = requests.get(endpoint)\n        for symbol in r.json()['symbols']:\n            <IND>if symbol.get('status', 'TRADING') != \"TRADING\":\n                <IND>continue\n            <DED>if symbol.get('contractStatus', 'TRADING') != \"TRADING\":\n                <IND>continue\n            <DED>split = len(symbol['baseAsset'])\n            normalized = symbol['symbol'][:split] + SYMBOL_SEP + symbol['symbol'][split:]\n            ret[normalized] = symbol['symbol']\n            _exchange_info[exchange]['tick_size'][normalized] = symbol['filters'][0]['tickSize']\n            if \"contractType\" in symbol:\n                <IND>_exchange_info[exchange]['contract_type'][normalized] = symbol['contractType']\n        <DED><DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation(exchange, why, {endpoint: r})\n\n\n<DED><DED>def binance_symbols() -> Dict[str, str]:\n    <IND>return _binance_symbols('https://api.binance.com/api/v3/exchangeInfo', BINANCE)\n\n\n<DED>def binance_us_symbols() -> Dict[str, str]:\n    <IND>return _binance_symbols('https://api.binance.us/api/v3/exchangeInfo', BINANCE_US)\n\n\n<DED>def binance_futures_symbols() -> Dict[str, str]:\n    <IND>base = _binance_symbols('https://fapi.binance.com/fapi/v1/exchangeInfo', BINANCE_FUTURES)\n    add = {}\n    for symbol, orig in base.items():\n        <IND>if \"_\" in orig:\n            <IND>continue\n        <DED>add[f\"{symbol}-PINDEX\"] = f\"p{orig}\"\n    <DED>base.update(add)\n    return base\n\n\n<DED>def binance_delivery_symbols() -> Dict[str, str]:\n    <IND>return _binance_symbols('https://dapi.binance.com/dapi/v1/exchangeInfo', BINANCE_DELIVERY)\n\n\n<DED>def bitfinex_symbols() -> Dict[str, str]:\n    # doc: https://docs.bitfinex.com/docs/ws-general#supported-pairs\n    <IND>r1 = r2 = None\n    try:\n        <IND>r1 = requests.get('https://api.bitfinex.com/v2/tickers?symbols=ALL')\n        r2 = requests.get('https://api-pub.bitfinex.com/v2/conf/pub:map:currency:sym')\n        tickers: List[List[str]] = r1.json()\n        norm: List[Tuple[str, str]] = r2.json()[0]\n        norm: Dict[str, str] = dict(norm)\n        for k, v in dict(norm).items():\n            <IND>if k[-2:] == 'F0' or '-' in v:  # Do not convert BTCF0 -> BTC or PBTCETH -> PBTC-ETH\n                <IND>del norm[k]\n        <DED><DED>norm['BCHN'] = 'BCH'  # Bitfinex uses BCHN, other exchanges use BCH\n\n        ret = {}\n        for symbol in [t[0] for t in tickers]:\n            <IND>if symbol[0] == 'f':\n                <IND>normalized = norm.get(symbol[1:], symbol[1:])\n            <DED>else:\n                <IND>if len(symbol) == 7:\n                    <IND>base, quote = symbol[1:4], symbol[4:]\n                <DED>else:\n                    <IND>base, quote = symbol[1:].split(':')\n                    assert ':' in symbol\n                <DED>normalized = norm.get(base, base) + SYMBOL_SEP + norm.get(quote, quote)\n            <DED>ret[normalized.upper()] = symbol\n        <DED>return ret\n    <DED>except ValueError as why:\n        <IND>raise_failure_explanation('BITFINEX', why, {\"tickers?symbols=ALL\": r1, \"pub:map:currency:sym\": r2})\n\n\n<DED><DED>def bitflyer_symbols() -> Dict[str, str]:\n    <IND>endpoint = r = None\n    try:\n        <IND>ret = {}\n        endpoints = ['https://api.bitflyer.com/v1/getmarkets/eu', 'https://api.bitflyer.com/v1/getmarkets/usa', 'https://api.bitflyer.com/v1/getmarkets']\n        for endpoint in endpoints:\n            <IND>r = requests.get(endpoint)\n            for entry in r.json():\n                <IND>normalized = entry['product_code'].replace(\"_\", SYMBOL_SEP)\n                ret[normalized] = entry['product_code']\n        <DED><DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BITFLYER', why, {endpoint: r})\n\n\n<DED><DED>def bybit_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.bybit.com/v2/public/symbols')\n        ret = {}\n        for symbol in r.json()['result']:\n            <IND>quote = symbol['quote_currency']\n            if not symbol['name'].endswith(quote):\n                <IND>base, contract = symbol['name'].split(quote)\n                normalized = f\"{base}{SYMBOL_SEP}{quote}-{contract}\"\n            <DED>else:\n                <IND>normalized = f\"{symbol['base_currency']}{SYMBOL_SEP}{quote}\"\n            <DED>ret[normalized] = symbol['name']\n            _exchange_info[BYBIT]['tick_size'][normalized] = symbol['price_filter']['tick_size']\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BYBIT', why, {\"\": r})\n\n\n<DED><DED>def _ftx_helper(endpoint: str, exchange: str):\n    <IND>r = None\n    try:\n        <IND>r = requests.get(endpoint)\n        ret = {}\n        for data in r.json()['result']:\n            <IND>normalized = data['name'].replace(\"/\", SYMBOL_SEP)\n            symbol = data['name']\n            ret[normalized] = symbol\n            _exchange_info[exchange]['tick_size'][normalized] = data['priceIncrement']\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation(exchange, why, {endpoint: r})\n\n\n<DED><DED>def ftx_symbols() -> Dict[str, str]:\n    <IND>return _ftx_helper('https://ftx.com/api/markets', FTX)\n\n\n<DED>def ftx_us_symbols() -> Dict[str, str]:\n    <IND>return _ftx_helper('https://ftx.us/api/markets', FTX_US)\n\n\n<DED>def coinbase_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.pro.coinbase.com/products')\n        ret = {}\n        for data in r.json():\n            <IND>normalized = data['id'].replace(\"-\", SYMBOL_SEP)\n            ret[normalized] = data['id']\n            _exchange_info[COINBASE]['tick_size'][normalized] = data['quote_increment']\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('COINBASE', why, {\"\": r})\n\n\n<DED><DED>def gemini_symbols(*args) -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.gemini.com/v1/symbols')\n        ret = {}\n        for symbol in r.json():\n            <IND>std = f\"{symbol[:-3]}{SYMBOL_SEP}{symbol[-3:]}\"\n            std = std.upper()\n            ret[std] = symbol.upper()\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('GEMINI', why, {\"\": r})\n\n\n<DED><DED>def hitbtc_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>ret = {}\n        r = requests.get('https://api.hitbtc.com/api/2/public/symbol')\n        for symbol in r.json():\n            <IND>split = len(symbol['baseCurrency'])\n            normalized = symbol['id'][:split] + SYMBOL_SEP + symbol['id'][split:]\n            ret[normalized] = symbol['id']\n            _exchange_info[HITBTC]['tick_size'][normalized] = symbol['tickSize']\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('HITBTC', why, {\"\": r})\n\n\n<DED><DED>def poloniex_id_symbol_mapping():\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://poloniex.com/public?command=returnTicker')\n        symbols = r.json()\n        ret = {}\n        for symbol in symbols:\n            <IND>ret[symbols[symbol]['id']] = symbol\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('POLONIEX', why, {\"\": r})\n\n\n<DED><DED>def poloniex_symbols() -> Dict[str, str]:\n    <IND>ret = {}\n    for _, value in poloniex_id_symbol_mapping().items():\n        <IND>std = value.replace(\"STR\", \"XLM\")\n        quote, base = std.split(\"_\")\n        ret[quote + SYMBOL_SEP + base] = value\n    <DED>return ret\n\n\n<DED>def bitstamp_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://www.bitstamp.net/api/v2/trading-pairs-info/')\n        ret = {}\n        for data in r.json():\n            <IND>normalized = data['name'].replace(\"/\", SYMBOL_SEP)\n            symbol = data['url_symbol']\n            ret[normalized] = symbol\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BITSTAMP', why, {\"\": r})\n\n\n<DED><DED>def kraken_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.kraken.com/0/public/AssetPairs')\n        data = r.json()\n        ret = {}\n        for symbol in data['result']:\n            <IND>if 'wsname' not in data['result'][symbol] or '.d' in symbol:\n                # https://blog.kraken.com/post/259/introducing-the-kraken-dark-pool/\n                # .d is for dark pool symbols\n                <IND>continue\n\n            <DED>base, quote = data['result'][symbol]['wsname'].split(\"/\")\n\n            normalized = f\"{base}{SYMBOL_SEP}{quote}\"\n            exch = data['result'][symbol]['wsname']\n            normalized = normalized.replace('XBT', 'BTC')\n            normalized = normalized.replace('XDG', 'DOG')\n            ret[normalized] = exch\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('KRAKEN', why, {\"\": r})\n\n\n<DED><DED>def kraken_rest_symbols() -> Dict[str, str]:\n    <IND>return {normalized: exchange.replace(\"/\", \"\") for normalized, exchange in kraken_symbols().items()}\n\n\n<DED>def exx_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.exx.com/data/v1/tickers')\n        exchange = [key.upper() for key in r.json().keys()]\n        symbols = [key.replace(\"_\", SYMBOL_SEP) for key in exchange]\n        return dict(zip(symbols, exchange))\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('EXX', why, {\"\": r})\n\n\n<DED><DED>def huobi_common_symbols(url: str):\n    <IND>r = None\n    try:\n        <IND>r = requests.get(url)\n        ret = {}\n        for e in r.json()['data']:\n            <IND>if e['state'] == 'offline':\n                <IND>continue\n            <DED>normalized = f\"{e['base-currency'].upper()}{SYMBOL_SEP}{e['quote-currency'].upper()}\"\n            symbol = f\"{e['base-currency']}{e['quote-currency']}\"\n            ret[normalized] = symbol\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('HUOBI', why, {url: r})\n\n\n<DED><DED>def huobi_symbols() -> Dict[str, str]:\n    <IND>return huobi_common_symbols('https://api.huobi.pro/v1/common/symbols')\n\n\n<DED>def huobi_us_symbols() -> Dict[str, str]:\n    <IND>return huobi_common_symbols('https://api.huobi.com/v1/common/symbols')\n\n\n<DED>def huobi_dm_symbols() -> Dict[str, str]:\n    <IND>\"\"\"\n    Mapping is, for instance: {\"BTC_CW\":\"BTC190816\"}\n    See comments in exchange/huobi_dm.py\n    \"\"\"\n    mapping = {\n        \"this_week\": \"CW\",\n        \"next_week\": \"NW\",\n        \"quarter\": \"CQ\",\n        \"next_quarter\": \"NQ\"\n    }\n    r = None\n    try:\n        <IND>r = requests.get('https://www.hbdm.com/api/v1/contract_contract_info')\n        symbols = {}\n        for e in r.json()['data']:\n            <IND>symbols[f\"{e['symbol']}_{mapping[e['contract_type']]}\"] = e['contract_code']\n            _exchange_info[HUOBI_DM]['tick_size'][e['contract_code']] = e['price_tick']\n            _exchange_info[HUOBI_DM]['short_code_mappings'][f\"{e['symbol']}_{mapping[e['contract_type']]}\"] = e['contract_code']\n        <DED>return symbols\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('HUOBI_DM', why, {\"\": r})\n\n\n<DED><DED>def huobi_swap_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.hbdm.com/swap-api/v1/swap_contract_info')\n        symbols = {}\n        for e in r.json()['data']:\n            <IND>symbols[e['contract_code']] = e['contract_code']\n            _exchange_info[HUOBI_SWAP]['tick_size'][e['contract_code']] = e['price_tick']\n        <DED>return symbols\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('HUOBI_SWAP', why, {\"\": r})\n\n\n<DED><DED>def okcoin_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://www.okcoin.com/api/spot/v3/instruments')\n        ret = {}\n        for e in r.json():\n            <IND>ret[e['instrument_id']] = e['instrument_id']\n            _exchange_info[OKCOIN]['tick_size'][e['instrument_id']] = e['tick_size']\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('OKCOIN', why, {\"\": r})\n\n\n<DED><DED>def okex_symbols(*args) -> Dict[str, str]:\n    <IND>urls = ['https://www.okex.com/api/spot/v3/instruments',\n            'https://www.okex.com/api/swap/v3/instruments',\n            'https://www.okex.com/api/futures/v3/instruments']\n    urls = urls + okex_compute_option_urls_from_underlyings()\n\n    symbols: Dict[str, str] = {}\n    for u in urls:\n        <IND>time.sleep(0.2)\n        symbols.update(okex_symbols_from_one_url(u))\n\n    <DED>for symbol in symbols:\n        <IND>instrument_type = 'futures'\n        dash_count = symbol.count(get_symbol_separator())\n        if dash_count == 1:  # BTC-USDT\n            <IND>instrument_type = 'spot'\n        <DED>if dash_count == 4:  # BTC-USD-201225-35000-P\n            <IND>instrument_type = 'option'\n        <DED>if symbol[-4:] == \"SWAP\":  # BTC-USDT-SWAP\n            <IND>instrument_type = 'swap'\n\n        <DED>_exchange_info[OKEX]['instrument_type'][symbol] = instrument_type\n\n    <DED>return symbols\n\n\n<DED>def okex_compute_option_urls_from_underlyings() -> List[str]:\n    <IND>url = 'https://www.okex.com/api/option/v3/underlying'\n    r = None\n    try:\n        <IND>r = requests.get(url)\n        return [f'https://www.okex.com/api/option/v3/instruments/{underlying}' for underlying in r.json()]\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('OKEX', why, {url: r})\n\n\n<DED><DED>def okex_symbols_from_one_url(url: str) -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get(url)\n        ret = {}\n        for e in r.json():\n            <IND>ret[e['instrument_id']] = e['instrument_id']\n            _exchange_info[OKEX]['tick_size'][e['instrument_id']] = e['tick_size']\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('OKEX', why, {url: r})\n\n\n<DED><DED>def bittrex_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.bittrex.com/api/v1.1/public/getmarkets')\n        r = r.json()['result']\n        return {f\"{e['MarketCurrency']}{SYMBOL_SEP}{e['BaseCurrency']}\": e['MarketName'] for e in r if e['IsActive']}\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BITTREX', why, {\"\": r})\n\n\n<DED><DED>def bitcoincom_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.exchange.bitcoin.com/api/2/public/symbol')\n        return {f\"{data['baseCurrency']}{SYMBOL_SEP}{data['quoteCurrency'].replace('USD', 'USDT')}\": data['id'] for data in r.json()}\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BITCOINCOM', why, {\"\": r})\n\n\n<DED><DED>def bitmax_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://bitmax.io/api/pro/v1/products')\n        ret = {}\n        for entry in r.json()['data']:\n            # Only \"Normal\" status symbols are tradeable\n            <IND>if entry['status'] == 'Normal':\n                <IND>normalized = f\"{entry['baseAsset']}{SYMBOL_SEP}{entry['quoteAsset']}\"\n                ret[normalized] = entry['symbol']\n                _exchange_info[BITMAX]['tick_size'][normalized] = entry['tickSize']\n        <DED><DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BITMAX', why, {\"\": r})\n\n\n<DED><DED>def upbit_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.upbit.com/v1/market/all')\n        return {f\"{data['market'].split('-')[1]}{SYMBOL_SEP}{data['market'].split('-')[0]}\": data['market'] for data in r.json()}\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('UPBIT', why, {\"\": r})\n\n\n<DED><DED>def blockchain_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get(\"https://api.blockchain.com/mercury-gateway/v1/instruments\")\n        return {data[\"symbol\"].replace(\"-\", SYMBOL_SEP): data[\"symbol\"] for data in r.json()}\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BLOCKCHAIN', why, {\"\": r})\n\n\n<DED><DED>def gateio_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get(\"https://api.gateio.ws/api/v4/spot/currency_pairs\")\n        return {data[\"id\"].replace(\"_\", SYMBOL_SEP): data['id'] for data in r.json()}\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('GATEIO', why, {\"\": r})\n\n\n<DED><DED>def bitmex_symbols() -> Dict[str, str]:\n    <IND>r = None\n    ret = {}\n    try:\n        <IND>r = requests.get(\"https://www.bitmex.com/api/v1/instrument/active\")\n        for entry in r.json():\n            <IND>components = []\n            components.append(entry['rootSymbol'])\n            components.append(entry['quoteCurrency'])\n\n            if entry['expiry']:\n                <IND>components.append(entry['symbol'][-3:])\n\n            <DED>normalized = SYMBOL_SEP.join(components)\n            normalized = normalized.replace(\"XBT\", \"BTC\")\n            ret[normalized] = entry['symbol']\n            _exchange_info[BITMEX]['tick_size'][normalized] = entry['tickSize']\n\n            if entry['expiry']:\n                <IND>_exchange_info[BITMEX]['expiry'][normalized] = entry['expiry']\n\n        <DED><DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BITMEX', why, {\"\": r})\n\n\n<DED><DED>def deribit_symbols() -> Dict[str, str]:\n    <IND>url = r = None\n    ret = {}\n    try:\n        # TODO: get currencies from https://www.deribit.com/api/v2/public/get_currencies\n        <IND>currencies = ['BTC', 'ETH']\n        for c in currencies:\n            <IND>url = f\"https://www.deribit.com/api/v2/public/get_instruments?currency={c}&expired=false\"\n            r = requests.get(url)\n            for entry in r.json()['result']:\n                <IND>split = entry['instrument_name'].split(\"-\")\n                normalized = split[0] + SYMBOL_SEP + entry['quote_currency'] + \"-\" + '-'.join(split[1:])\n                ret[normalized] = entry['instrument_name']\n                _exchange_info[DERIBIT]['tick_size'][normalized] = entry['tick_size']\n        <DED><DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('DERIBIT', why, {url: r})\n\n\n<DED><DED>def kraken_future_symbols() -> Dict[str, str]:\n    <IND>r = None\n    ret = {}\n    try:\n        <IND>r = requests.get('https://futures.kraken.com/derivatives/api/v3/instruments')\n        data = r.json()['instruments']\n        for entry in data:\n            <IND>if not entry['tradeable']:\n                <IND>continue\n            <DED>normalized = entry['symbol'].upper().replace(\"_\", \"-\")\n            symbol = normalized[3:6] + SYMBOL_SEP + normalized[6:9]\n            normalized = normalized.replace(normalized[3:9], symbol)\n            normalized = normalized.replace('XBT', 'BTC')\n\n            _exchange_info[KRAKEN_FUTURES]['tick_size'][normalized] = entry['tickSize']\n            _exchange_info[KRAKEN_FUTURES]['contract_size'][normalized] = entry['contractSize']\n            _exchange_info[KRAKEN_FUTURES]['underlying'][normalized] = entry['underlying']\n            _exchange_info[KRAKEN_FUTURES]['product_type'][normalized] = _kraken_futures_product_type[normalized[:2]]\n            ret[normalized] = entry['symbol']\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('KRAKEN_FUTURES', why, {\"\": r})\n\n\n<DED><DED>def probit_symbols() -> Dict[str, str]:\n    # doc: https://docs-en.probit.com/reference-link/market\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.probit.com/api/exchange/v1/market')\n        return {entry['id']: entry['id'] for entry in r.json()['data']}\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('PROBIT', why, {\"\": r})\n\n\n<DED><DED>def coingecko_normalize_symbol(symbol: str) -> str:\n    # keep digits, letters and dots, replace others by space\n    <IND>symbol = ''.join(c if c.isalnum() or c in ('.', '+') else ' ' for c in symbol)\n    return coingecko_normalize(symbol.upper())\n\n\n<DED>def coingecko_normalize_name(name: str) -> str:\n    # keep digits and letters, replace others by space (except when only composed by upper case letters, digits and dots)\n    <IND>if not all(c.isupper() or c.isdigit() or c == '.' for c in name):\n        <IND>name = ''.join(c if c.isalnum() else ' ' for c in name)\n    <DED>return coingecko_normalize(name)\n\n\n<DED>def coingecko_normalize(sym: str) -> str:\n    <IND>sym = sym.strip()\n    # do not concatenate numbers => separate them with a dot\n    sym = list(sym)\n    if len(sym) > 4:\n        <IND>for i in range(2, len(sym) - 1):\n            <IND>if sym[i] == ' ' and sym[i - 1].isdigit() and sym[i + 1].isdigit():\n                <IND>sym[i] = '.'\n    <DED><DED><DED>sym = ''.join(sym)\n    # concatenate space-separated words => use CamelCase to distinguish the words\n    if ' ' in sym:\n        <IND>if sum(c.islower() for c in sym):  # if there is at least one lower case letter\n            <IND>sym = ' '.join(word[0].upper() + word[1:] for word in sym.split())  # Just capitalize initial letter of each word\n        <DED>else:  # CoinGecko may provide full upper-case as for \"THE STONE COIN\"\n            <IND>sym = string.capwords(sym)  # capwords converts \"THE STONE COIN\" to \"The Stone Coin\"\n        <DED>sym = sym.replace(' ', '')  # concatenate words\n    <DED>return sym\n\n\n<DED>def is_name_short(coin: dict) -> bool:\n    <IND>\"\"\"return True if the coin name is enough short compared to the coin symbol.\"\"\"\n    return len(coin['name']) <= max(5, len(coin['symbol']) + 1)\n\n\n<DED>def has_many_caps(name: str) -> bool:\n    <IND>\"\"\"return True if the symbol contains enough upper case letters, False if empty.\"\"\"\n    return str and sum(c.islower() for c in name) < (len(name) / 2)\n\n\n<DED>def coingecko_normalize_all(coin: dict):\n    <IND>SYMBOL_TO_NORMALIZED = {'miota': 'IOTA'}\n    normalized = SYMBOL_TO_NORMALIZED.get(coin['symbol'])\n    if normalized:\n        <IND>coin['ns'] = coin['nn'] = normalized\n        return normalized\n\n    # ns = normalized symbol, nn = normalized name\n    <DED>coin['ns'] = coingecko_normalize_symbol(coin['symbol'])\n\n    ID_SUFFIX = '-bitcoin-token'\n    if coin['id'][-len(ID_SUFFIX):] == ID_SUFFIX:\n        <IND>coin['nn'] = 'BTC' + coin['ns']\n        return coin['nn']\n\n    <DED>name = coin['name']\n\n    prefixes = ('The ', 'the ')\n    for p in prefixes:\n        <IND>if name[:len(p)] == p:\n            <IND>coin['reduced-name'] = True\n            name = name[len(p):]\n            break\n\n    <DED><DED>suffixes = ('coin', 'coins', 'money', 'finance', 'protocol', 'reward', 'rewards', 'token')\n    for s in suffixes:\n        <IND>if len(name) > len(s) and name[-len(s):].lower() == s:\n            # but keep suffix when lower-case concatenated\n            <IND>if name[-len(s)].islower() and name[-len(s) - 1] != ' ':\n                <IND>continue\n            # also keep suffix to avoid confusing nam: \"Bitcoin Token\" -> \"Bitcoin\"\n            <DED>if name[:-len(s)].strip().lower() == 'bitcoin':\n                <IND>continue\n            <DED>coin['reduced-name'] = True\n            name = name[:-len(s)]\n            break\n\n    <DED><DED>coin['nn'] = coingecko_normalize_name(name)\n\n    if len(coin['nn']) < len(coin['ns']):\n        <IND>if 'reduced-name' in coin:\n            <IND>coin['reduced-name'] = False\n            name = coin['name']\n            coin['nn'] = coingecko_normalize_name(name)\n        <DED>elif not has_many_caps(name):\n            <IND>return coin['ns']\n\n    <DED><DED>if not coin['ns']:  # coin['symbol'] may be an emoji that is striped when normalized\n        <IND>return coin['nn']\n\n    <DED>if coin.get('reduced-name') and coin['ns'].upper() != coin['nn'].upper():\n        <IND>return coin['ns']\n\n    <DED>i = coin['nn'].find('.')  # if there is a dot in normalized name => prefer the normalized symbol\n    if i >= 0:\n        <IND>if i > 1 and coin['nn'][i - 1].isdigit() and coin['nn'][i + 1].isdigit():\n            <IND>pass  # except when the dot separates digits\n        <DED>else:\n            <IND>return coin['ns']\n\n    <DED><DED>if is_name_short(coin) and has_many_caps(name):\n        <IND>return coin['nn']\n\n    <DED>if 1.5 * len(coin['ns']) > len(coin['nn']) and any(c.islower() for c in coin['ns']):\n        <IND>return coin['nn']\n\n    <DED>return coin['ns']\n\n\n<DED>def coingecko_symbols() -> Dict[str, str]:\n    <IND>r = None\n    intermediate = defaultdict(list)\n    try:\n        <IND>r = requests.get('https://api.coingecko.com/api/v3/coins/list')\n        all_coins = r.json()\n        # First pass: generate & compare normalized symbol/name, and then select the most pertinent\n        for coin in all_coins:\n            <IND>normalized = coingecko_normalize_all(coin)\n            intermediate[normalized].append(coin)\n            # Above line keeps together the coins having the same normalized symbol.\n            # To reduce collision, the coin['name'] is sometimes used in lieu of the coin['symbol'].\n            # The coin['name'] is not capitalized because lower case letters may be meaningful: cETH, yUSD, DATx, zLOT\n    <DED><DED>except Exception as why:\n        <IND>raise_failure_explanation('COINGECKO', why, {\"\": r})\n\n    <DED>final = coingecko_second_pass(intermediate)\n    return coingecko_third_pass(final)\n\n\n<DED>def coingecko_second_pass(intermediate: Dict[str, List[dict]]) -> Dict[str, List[dict]]:\n    # Second pass: fixes most of the symbol collisions\n    <IND>final = defaultdict(list)\n    for normalized, coins in intermediate.items():\n        <IND>if len(coins) == 1:\n            <IND>final[normalized].append(coins[0])\n            continue\n        <DED>set_normalized = False\n        for i in range(len(coins)):\n            <IND>if normalized == coins[i]['nn']:\n                <IND>coin = coins.pop(i)\n                final[normalized].append(coin)\n                set_normalized = True\n                break\n        <DED><DED>rest: List[dict] = []\n        for coin in coins:\n            <IND>if '%' in coin['name']:\n                <IND>if len(coins) == 1:\n                    <IND>n = coin['ns']\n                <DED>else:\n                    <IND>n = coingecko_normalize_name(coin['id'])\n                <DED>final[n].append(coin)\n            <DED>else:\n                <IND>rest.append(coin)\n        <DED><DED>if not rest:\n            <IND>continue\n        <DED>if not set_normalized:\n            <IND>rest.sort(key=lambda coin: len(coin['nn']), reverse=True)  # sort by the length of the normalized name\n            coin = rest.pop(0)\n            final[normalized].append(coin)\n        <DED>for coin in rest:\n            <IND>if coin['nn'] not in intermediate:\n                <IND>n = coin['nn']\n            <DED>elif coin.get('reduced-name'):\n                <IND>n = coingecko_normalize_name(coin['name'])\n            <DED>else:\n                <IND>n = coingecko_normalize_name(coin['id'])\n            <DED>final[n].append(coin)\n    <DED><DED>return final\n\n\n<DED>def coingecko_third_pass(final: Dict[str, List[dict]]) -> Dict[str, str]:\n    # Third pass: fixes some remaining collisions and fills the result\n    <IND>symbols = {}\n    for normalized, coins in final.items():\n        <IND>if len(coins) == 1:\n            <IND>symbols[normalized] = coins[0]['id']\n            continue\n        <DED>set_normalized = False\n        for i in range(len(coins)):\n            <IND>if normalized == coins[i]['nn']:\n                <IND>coin = coins.pop(i)\n                symbols[normalized] = coin['id']\n                set_normalized = True\n                break\n        <DED><DED>rest: List[dict] = []\n        for coin in coins:\n            <IND>if '%' in coin['name']:\n                <IND>if len(coins) == 1:\n                    <IND>n = coin['ns']\n                <DED>else:\n                    <IND>n = coingecko_normalize_name(coin['id'])\n                <DED>symbols[n] = coin['id']\n            <DED>else:\n                <IND>rest.append(coin)\n        <DED><DED>if not rest:\n            <IND>continue\n        <DED>if not set_normalized:\n            <IND>rest.sort(key=lambda coin: len(coin['nn']), reverse=True)  # sort by the length of the normalized name\n            coin = rest.pop(0)\n            symbols[normalized] = coin['id']\n        <DED>for coin in rest:\n            <IND>if coin['nn'] not in final:\n                <IND>n = coin['nn']\n            <DED>elif coin.get('reduced-name'):\n                <IND>n = coingecko_normalize_name(coin['name'])\n            <DED>else:\n                <IND>n = coingecko_normalize_name(coin['id'])\n            <DED>symbols[n] = coin['id']\n    <DED><DED>return symbols\n\n\n<DED>def whale_alert_coins(key_id: str) -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get(f'https://api.whale-alert.io/v1/status?api_key={key_id}')\n        # Same symbols, but on different blockchains (for instance USDT), are naturally overwritten.\n        return {s.upper(): s for b in r.json()['blockchains'] for s in b['symbols'] if s}\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('WHALES_ALERT', why, {\"\": r})\n\n\n<DED><DED>_exchange_function_map = {\n    BITFINEX: bitfinex_symbols,\n    BITFLYER: bitflyer_symbols,\n    COINBASE: coinbase_symbols,\n    GEMINI: gemini_symbols,\n    HITBTC: hitbtc_symbols,\n    POLONIEX: poloniex_symbols,\n    PROBIT: probit_symbols,\n    BITSTAMP: bitstamp_symbols,\n    KRAKEN: kraken_symbols,\n    KRAKEN + 'REST': kraken_rest_symbols,\n    BINANCE: binance_symbols,\n    BINANCE_US: binance_us_symbols,\n    BINANCE_FUTURES: binance_futures_symbols,\n    BINANCE_DELIVERY: binance_delivery_symbols,\n    BLOCKCHAIN: blockchain_symbols,\n    EXX: exx_symbols,\n    HUOBI: huobi_symbols,\n    HUOBI_DM: huobi_dm_symbols,\n    HUOBI_SWAP: huobi_swap_symbols,\n    OKCOIN: okcoin_symbols,\n    OKEX: okex_symbols,\n    BYBIT: bybit_symbols,\n    FTX: ftx_symbols,\n    FTX_US: ftx_us_symbols,\n    BITTREX: bittrex_symbols,\n    BITCOINCOM: bitcoincom_symbols,\n    BITMAX: bitmax_symbols,\n    UPBIT: upbit_symbols,\n    GATEIO: gateio_symbols,\n    BITMEX: bitmex_symbols,\n    DERIBIT: deribit_symbols,\n    KRAKEN_FUTURES: kraken_future_symbols,\n    COINGECKO: coingecko_symbols,\n    WHALE_ALERT: whale_alert_coins\n}\n",
        "target_code_with_indent": "\nfrom typing import Dict, Tuple\n\n\nclass _Symbols:\n    <IND>def __init__(self):\n        <IND>self.data = {}\n\n    <DED>def set(self, exchange: str, normalized: dict, exchange_info: dict):\n        <IND>self.data[exchange] = {}\n        self.data[exchange]['normalized'] = normalized\n        self.data[exchange]['info'] = exchange_info\n\n    <DED>def get(self, exchange: str) -> Tuple[Dict, Dict]:\n        <IND>return self.data[exchange]['normalized'], self.data[exchange]['info']\n\n    <DED>def populated(self, exchange: str) -> bool:\n        <IND>return exchange in self.data\n\n\n<DED><DED>Symbols = _Symbols()\n"
      }
    ]
  },
  {
    "project": "bmoscon/cryptofeed",
    "commit": "3525dc8ce4d7836a9abaaa5662e58e5e27969a77",
    "filename": "cryptofeed/symbols.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/bmoscon-cryptofeed/cryptofeed/symbols.py",
    "file_hunks_size": 1,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "cryptofeed/symbols.py:554:8 Incompatible return type [7]: Expected `Dict[str, str]` but got implicit return value of `None`.",
    "message": " Expected `Dict[str, str]` but got implicit return value of `None`.",
    "rule_id": "Incompatible return type [7]",
    "warning_line_no": 554,
    "warning_line": "        raise_failure_explanation('DERIBIT', why, {url: r})",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "associated with this software.\n\n\nSymbol generation code for exchanges\n'''\n\nimport logging\nimport string\nimport time\nfrom collections import defaultdict\nfrom typing import Dict, List, Optional, Tuple\n\nimport requests\nfrom requests import Response\n\nfrom cryptofeed.defines import *\n\n\nLOG = logging.getLogger('feedhandler')\n\nSYMBOL_SEP = '-'\n\n_symbols_retrieval_cache: Dict[str, Dict[str, str]] = {}\n_exchange_info = defaultdict(lambda: defaultdict(dict))\n\n\n_kraken_futures_product_type = {\n    'FI': 'Inverse Futures',\n    'FV': 'Vanilla Futures',\n    'PI': 'Perpetual Inverse Futures',\n    'PV': 'Perpetual Vanilla Futures',\n    'IN': 'Real Time Index',\n    'RR': 'Reference Rate',\n}\n\n\ndef raise_failure_explanation(feed_id: str, exception: BaseException, responses: Dict[str, Optional[Response]]):\n    LOG.critical('%s: encountered %r while processing response from exchange API', feed_id, exception)\n    if len(responses) > 1:\n        LOG.critical('%s: content of one of the %s responses was unexpected', feed_id, len(responses))\n    for url, r in responses.items():\n        if url:\n            LOG.critical('%s: requested URL: %s', feed_id, url)\n        if r:\n            LOG.critical('%s: unexpected response: %s', feed_id, r.text)\n    raise ValueError(f'Cryptofeed stopped because of an unexpected response from {feed_id}') from exception\n\n\ndef set_symbol_separator(separator: str):\n    global SYMBOL_SEP\n    SYMBOL_SEP = separator\n\n\ndef get_symbol_separator() -> str:\n    global SYMBOL_SEP\n    return SYMBOL_SEP\n\n\ndef gen_symbols(exchange: str, key_id=None) -> Dict[str, str]:\n    if exchange not in _symbols_retrieval_cache:\n        LOG.info(\"%s: Getting list of symbols\", exchange)\n        symbols = _exchange_function_map[exchange](key_id) if key_id else _exchange_function_map[exchange]()\n        LOG.info(\"%s: %s symbols\", exchange, len(symbols))\n\n        # log all retrieved symbols using debug level\n        for normalized, exch_sym in sorted(symbols.items()):\n            LOG.debug('%s: id-from-exch -> normalized: %-35s-> %s', exchange, exch_sym, normalized)\n\n        _symbols_retrieval_cache[exchange] = symbols\n    return _symbols_retrieval_cache[exchange]\n\n\ndef _binance_symbols(endpoint: str, exchange: str):\n    r = None\n    try:\n        ret = {}\n        r = requests.get(endpoint)\n        for symbol in r.json()['symbols']:\n            if symbol.get('status', 'TRADING') != \"TRADING\":\n                continue\n            if symbol.get('contractStatus', 'TRADING') != \"TRADING\":\n                continue\n            split = len(symbol['baseAsset'])\n            normalized = symbol['symbol'][:split] + SYMBOL_SEP + symbol['symbol'][split:]\n            ret[normalized] = symbol['symbol']\n            _exchange_info[exchange]['tick_size'][normalized] = symbol['filters'][0]['tickSize']\n            if \"contractType\" in symbol:\n                _exchange_info[exchange]['contract_type'][normalized] = symbol['contractType']\n        return ret\n    except Exception as why:\n        raise_failure_explanation(exchange, why, {endpoint: r})\n\n\ndef binance_symbols() -> Dict[str, str]:\n    return _binance_symbols('https://api.binance.com/api/v3/exchangeInfo', BINANCE)\n\n\ndef binance_us_symbols() -> Dict[str, str]:\n    return _binance_symbols('https://api.binance.us/api/v3/exchangeInfo', BINANCE_US)\n\n\ndef binance_futures_symbols() -> Dict[str, str]:\n    base = _binance_symbols('https://fapi.binance.com/fapi/v1/exchangeInfo', BINANCE_FUTURES)\n    add = {}\n    for symbol, orig in base.items():\n        if \"_\" in orig:\n            continue\n        add[f\"{symbol}-PINDEX\"] = f\"p{orig}\"\n    base.update(add)\n    return base\n\n\ndef binance_delivery_symbols() -> Dict[str, str]:\n    return _binance_symbols('https://dapi.binance.com/dapi/v1/exchangeInfo', BINANCE_DELIVERY)\n\n\ndef bitfinex_symbols() -> Dict[str, str]:\n    # doc: https://docs.bitfinex.com/docs/ws-general#supported-pairs\n    r1 = r2 = None\n    try:\n        r1 = requests.get('https://api.bitfinex.com/v2/tickers?symbols=ALL')\n        r2 = requests.get('https://api-pub.bitfinex.com/v2/conf/pub:map:currency:sym')\n        tickers: List[List[str]] = r1.json()\n        norm: List[Tuple[str, str]] = r2.json()[0]\n        norm: Dict[str, str] = dict(norm)\n        for k, v in dict(norm).items():\n            if k[-2:] == 'F0' or '-' in v:  # Do not convert BTCF0 -> BTC or PBTCETH -> PBTC-ETH\n                del norm[k]\n        norm['BCHN'] = 'BCH'  # Bitfinex uses BCHN, other exchanges use BCH\n\n        ret = {}\n        for symbol in [t[0] for t in tickers]:\n            if symbol[0] == 'f':\n                normalized = norm.get(symbol[1:], symbol[1:])\n            else:\n                if len(symbol) == 7:\n                    base, quote = symbol[1:4], symbol[4:]\n                else:\n                    base, quote = symbol[1:].split(':')\n                    assert ':' in symbol\n                normalized = norm.get(base, base) + SYMBOL_SEP + norm.get(quote, quote)\n            ret[normalized.upper()] = symbol\n        return ret\n    except ValueError as why:\n        raise_failure_explanation('BITFINEX', why, {\"tickers?symbols=ALL\": r1, \"pub:map:currency:sym\": r2})\n\n\ndef bitflyer_symbols() -> Dict[str, str]:\n    endpoint = r = None\n    try:\n        ret = {}\n        endpoints = ['https://api.bitflyer.com/v1/getmarkets/eu', 'https://api.bitflyer.com/v1/getmarkets/usa', 'https://api.bitflyer.com/v1/getmarkets']\n        for endpoint in endpoints:\n            r = requests.get(endpoint)\n            for entry in r.json():\n                normalized = entry['product_code'].replace(\"_\", SYMBOL_SEP)\n                ret[normalized] = entry['product_code']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('BITFLYER', why, {endpoint: r})\n\n\ndef bybit_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.bybit.com/v2/public/symbols')\n        ret = {}\n        for symbol in r.json()['result']:\n            quote = symbol['quote_currency']\n            if not symbol['name'].endswith(quote):\n                base, contract = symbol['name'].split(quote)\n                normalized = f\"{base}{SYMBOL_SEP}{quote}-{contract}\"\n            else:\n                normalized = f\"{symbol['base_currency']}{SYMBOL_SEP}{quote}\"\n            ret[normalized] = symbol['name']\n            _exchange_info[BYBIT]['tick_size'][normalized] = symbol['price_filter']['tick_size']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('BYBIT', why, {\"\": r})\n\n\ndef _ftx_helper(endpoint: str, exchange: str):\n    r = None\n    try:\n        r = requests.get(endpoint)\n        ret = {}\n        for data in r.json()['result']:\n            normalized = data['name'].replace(\"/\", SYMBOL_SEP)\n            symbol = data['name']\n            ret[normalized] = symbol\n            _exchange_info[exchange]['tick_size'][normalized] = data['priceIncrement']\n        return ret\n    except Exception as why:\n        raise_failure_explanation(exchange, why, {endpoint: r})\n\n\ndef ftx_symbols() -> Dict[str, str]:\n    return _ftx_helper('https://ftx.com/api/markets', FTX)\n\n\ndef ftx_us_symbols() -> Dict[str, str]:\n    return _ftx_helper('https://ftx.us/api/markets', FTX_US)\n\n\ndef coinbase_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.pro.coinbase.com/products')\n        ret = {}\n        for data in r.json():\n            normalized = data['id'].replace(\"-\", SYMBOL_SEP)\n            ret[normalized] = data['id']\n            _exchange_info[COINBASE]['tick_size'][normalized] = data['quote_increment']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('COINBASE', why, {\"\": r})\n\n\ndef gemini_symbols(*args) -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.gemini.com/v1/symbols')\n        ret = {}\n        for symbol in r.json():\n            std = f\"{symbol[:-3]}{SYMBOL_SEP}{symbol[-3:]}\"\n            std = std.upper()\n            ret[std] = symbol.upper()\n        return ret\n    except Exception as why:\n        raise_failure_explanation('GEMINI', why, {\"\": r})\n\n\ndef hitbtc_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        ret = {}\n        r = requests.get('https://api.hitbtc.com/api/2/public/symbol')\n        for symbol in r.json():\n            split = len(symbol['baseCurrency'])\n            normalized = symbol['id'][:split] + SYMBOL_SEP + symbol['id'][split:]\n            ret[normalized] = symbol['id']\n            _exchange_info[HITBTC]['tick_size'][normalized] = symbol['tickSize']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('HITBTC', why, {\"\": r})\n\n\ndef poloniex_id_symbol_mapping():\n    r = None\n    try:\n        r = requests.get('https://poloniex.com/public?command=returnTicker')\n        symbols = r.json()\n        ret = {}\n        for symbol in symbols:\n            ret[symbols[symbol]['id']] = symbol\n        return ret\n    except Exception as why:\n        raise_failure_explanation('POLONIEX', why, {\"\": r})\n\n\ndef poloniex_symbols() -> Dict[str, str]:\n    ret = {}\n    for _, value in poloniex_id_symbol_mapping().items():\n        std = value.replace(\"STR\", \"XLM\")\n        quote, base = std.split(\"_\")\n        ret[quote + SYMBOL_SEP + base] = value\n    return ret\n\n\ndef bitstamp_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://www.bitstamp.net/api/v2/trading-pairs-info/')\n        ret = {}\n        for data in r.json():\n            normalized = data['name'].replace(\"/\", SYMBOL_SEP)\n            symbol = data['url_symbol']\n            ret[normalized] = symbol\n        return ret\n    except Exception as why:\n        raise_failure_explanation('BITSTAMP', why, {\"\": r})\n\n\ndef kraken_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.kraken.com/0/public/AssetPairs')\n        data = r.json()\n        ret = {}\n        for symbol in data['result']:\n            if 'wsname' not in data['result'][symbol] or '.d' in symbol:\n                # https://blog.kraken.com/post/259/introducing-the-kraken-dark-pool/\n                # .d is for dark pool symbols\n                continue\n\n            base, quote = data['result'][symbol]['wsname'].split(\"/\")\n\n            normalized = f\"{base}{SYMBOL_SEP}{quote}\"\n            exch = data['result'][symbol]['wsname']\n            normalized = normalized.replace('XBT', 'BTC')\n            normalized = normalized.replace('XDG', 'DOG')\n            ret[normalized] = exch\n        return ret\n    except Exception as why:\n        raise_failure_explanation('KRAKEN', why, {\"\": r})\n\n\ndef kraken_rest_symbols() -> Dict[str, str]:\n    return {normalized: exchange.replace(\"/\", \"\") for normalized, exchange in kraken_symbols().items()}\n\n\ndef exx_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.exx.com/data/v1/tickers')\n        exchange = [key.upper() for key in r.json().keys()]\n        symbols = [key.replace(\"_\", SYMBOL_SEP) for key in exchange]\n        return dict(zip(symbols, exchange))\n    except Exception as why:\n        raise_failure_explanation('EXX', why, {\"\": r})\n\n\ndef huobi_common_symbols(url: str):\n    r = None\n    try:\n        r = requests.get(url)\n        ret = {}\n        for e in r.json()['data']:\n            if e['state'] == 'offline':\n                continue\n            normalized = f\"{e['base-currency'].upper()}{SYMBOL_SEP}{e['quote-currency'].upper()}\"\n            symbol = f\"{e['base-currency']}{e['quote-currency']}\"\n            ret[normalized] = symbol\n        return ret\n    except Exception as why:\n        raise_failure_explanation('HUOBI', why, {url: r})\n\n\ndef huobi_symbols() -> Dict[str, str]:\n    return huobi_common_symbols('https://api.huobi.pro/v1/common/symbols')\n\n\ndef huobi_us_symbols() -> Dict[str, str]:\n    return huobi_common_symbols('https://api.huobi.com/v1/common/symbols')\n\n\ndef huobi_dm_symbols() -> Dict[str, str]:\n    \"\"\"\n    Mapping is, for instance: {\"BTC_CW\":\"BTC190816\"}\n    See comments in exchange/huobi_dm.py\n    \"\"\"\n    mapping = {\n        \"this_week\": \"CW\",\n        \"next_week\": \"NW\",\n        \"quarter\": \"CQ\",\n        \"next_quarter\": \"NQ\"\n    }\n    r = None\n    try:\n        r = requests.get('https://www.hbdm.com/api/v1/contract_contract_info')\n        symbols = {}\n        for e in r.json()['data']:\n            symbols[f\"{e['symbol']}_{mapping[e['contract_type']]}\"] = e['contract_code']\n            _exchange_info[HUOBI_DM]['tick_size'][e['contract_code']] = e['price_tick']\n            _exchange_info[HUOBI_DM]['short_code_mappings'][f\"{e['symbol']}_{mapping[e['contract_type']]}\"] = e['contract_code']\n        return symbols\n    except Exception as why:\n        raise_failure_explanation('HUOBI_DM', why, {\"\": r})\n\n\ndef huobi_swap_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.hbdm.com/swap-api/v1/swap_contract_info')\n        symbols = {}\n        for e in r.json()['data']:\n            symbols[e['contract_code']] = e['contract_code']\n            _exchange_info[HUOBI_SWAP]['tick_size'][e['contract_code']] = e['price_tick']\n        return symbols\n    except Exception as why:\n        raise_failure_explanation('HUOBI_SWAP', why, {\"\": r})\n\n\ndef okcoin_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://www.okcoin.com/api/spot/v3/instruments')\n        ret = {}\n        for e in r.json():\n            ret[e['instrument_id']] = e['instrument_id']\n            _exchange_info[OKCOIN]['tick_size'][e['instrument_id']] = e['tick_size']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('OKCOIN', why, {\"\": r})\n\n\ndef okex_symbols(*args) -> Dict[str, str]:\n    urls = ['https://www.okex.com/api/spot/v3/instruments',\n            'https://www.okex.com/api/swap/v3/instruments',\n            'https://www.okex.com/api/futures/v3/instruments']\n    urls = urls + okex_compute_option_urls_from_underlyings()\n\n    symbols: Dict[str, str] = {}\n    for u in urls:\n        time.sleep(0.2)\n        symbols.update(okex_symbols_from_one_url(u))\n\n    for symbol in symbols:\n        instrument_type = 'futures'\n        dash_count = symbol.count(get_symbol_separator())\n        if dash_count == 1:  # BTC-USDT\n            instrument_type = 'spot'\n        if dash_count == 4:  # BTC-USD-201225-35000-P\n            instrument_type = 'option'\n        if symbol[-4:] == \"SWAP\":  # BTC-USDT-SWAP\n            instrument_type = 'swap'\n\n        _exchange_info[OKEX]['instrument_type'][symbol] = instrument_type\n\n    return symbols\n\n\ndef okex_compute_option_urls_from_underlyings() -> List[str]:\n    url = 'https://www.okex.com/api/option/v3/underlying'\n    r = None\n    try:\n        r = requests.get(url)\n        return [f'https://www.okex.com/api/option/v3/instruments/{underlying}' for underlying in r.json()]\n    except Exception as why:\n        raise_failure_explanation('OKEX', why, {url: r})\n\n\ndef okex_symbols_from_one_url(url: str) -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get(url)\n        ret = {}\n        for e in r.json():\n            ret[e['instrument_id']] = e['instrument_id']\n            _exchange_info[OKEX]['tick_size'][e['instrument_id']] = e['tick_size']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('OKEX', why, {url: r})\n\n\ndef bittrex_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.bittrex.com/api/v1.1/public/getmarkets')\n        r = r.json()['result']\n        return {f\"{e['MarketCurrency']}{SYMBOL_SEP}{e['BaseCurrency']}\": e['MarketName'] for e in r if e['IsActive']}\n    except Exception as why:\n        raise_failure_explanation('BITTREX', why, {\"\": r})\n\n\ndef bitcoincom_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.exchange.bitcoin.com/api/2/public/symbol')\n        return {f\"{data['baseCurrency']}{SYMBOL_SEP}{data['quoteCurrency'].replace('USD', 'USDT')}\": data['id'] for data in r.json()}\n    except Exception as why:\n        raise_failure_explanation('BITCOINCOM', why, {\"\": r})\n\n\ndef bitmax_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://bitmax.io/api/pro/v1/products')\n        ret = {}\n        for entry in r.json()['data']:\n            # Only \"Normal\" status symbols are tradeable\n            if entry['status'] == 'Normal':\n                normalized = f\"{entry['baseAsset']}{SYMBOL_SEP}{entry['quoteAsset']}\"\n                ret[normalized] = entry['symbol']\n                _exchange_info[BITMAX]['tick_size'][normalized] = entry['tickSize']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('BITMAX', why, {\"\": r})\n\n\ndef upbit_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.upbit.com/v1/market/all')\n        return {f\"{data['market'].split('-')[1]}{SYMBOL_SEP}{data['market'].split('-')[0]}\": data['market'] for data in r.json()}\n    except Exception as why:\n        raise_failure_explanation('UPBIT', why, {\"\": r})\n\n\ndef blockchain_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get(\"https://api.blockchain.com/mercury-gateway/v1/instruments\")\n        return {data[\"symbol\"].replace(\"-\", SYMBOL_SEP): data[\"symbol\"] for data in r.json()}\n    except Exception as why:\n        raise_failure_explanation('BLOCKCHAIN', why, {\"\": r})\n\n\ndef gateio_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get(\"https://api.gateio.ws/api/v4/spot/currency_pairs\")\n        return {data[\"id\"].replace(\"_\", SYMBOL_SEP): data['id'] for data in r.json()}\n    except Exception as why:\n        raise_failure_explanation('GATEIO', why, {\"\": r})\n\n\ndef bitmex_symbols() -> Dict[str, str]:\n    r = None\n    ret = {}\n    try:\n        r = requests.get(\"https://www.bitmex.com/api/v1/instrument/active\")\n        for entry in r.json():\n            components = []\n            components.append(entry['rootSymbol'])\n            components.append(entry['quoteCurrency'])\n\n            if entry['expiry']:\n                components.append(entry['symbol'][-3:])\n\n            normalized = SYMBOL_SEP.join(components)\n            normalized = normalized.replace(\"XBT\", \"BTC\")\n            ret[normalized] = entry['symbol']\n            _exchange_info[BITMEX]['tick_size'][normalized] = entry['tickSize']\n\n            if entry['expiry']:\n                _exchange_info[BITMEX]['expiry'][normalized] = entry['expiry']\n\n        return ret\n    except Exception as why:\n        raise_failure_explanation('BITMEX', why, {\"\": r})\n\n\ndef deribit_symbols() -> Dict[str, str]:\n    url = r = None\n    ret = {}\n    try:\n        # TODO: get currencies from https://www.deribit.com/api/v2/public/get_currencies\n        currencies = ['BTC', 'ETH']\n        for c in currencies:\n            url = f\"https://www.deribit.com/api/v2/public/get_instruments?currency={c}&expired=false\"\n            r = requests.get(url)\n            for entry in r.json()['result']:\n                split = entry['instrument_name'].split(\"-\")\n                normalized = split[0] + SYMBOL_SEP + entry['quote_currency'] + \"-\" + '-'.join(split[1:])\n                ret[normalized] = entry['instrument_name']\n                _exchange_info[DERIBIT]['tick_size'][normalized] = entry['tick_size']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('DERIBIT', why, {url: r})\n\n\ndef kraken_future_symbols() -> Dict[str, str]:\n    r = None\n    ret = {}\n    try:\n        r = requests.get('https://futures.kraken.com/derivatives/api/v3/instruments')\n        data = r.json()['instruments']\n        for entry in data:\n            if not entry['tradeable']:\n                continue\n            normalized = entry['symbol'].upper().replace(\"_\", \"-\")\n            symbol = normalized[3:6] + SYMBOL_SEP + normalized[6:9]\n            normalized = normalized.replace(normalized[3:9], symbol)\n            normalized = normalized.replace('XBT', 'BTC')\n\n            _exchange_info[KRAKEN_FUTURES]['tick_size'][normalized] = entry['tickSize']\n            _exchange_info[KRAKEN_FUTURES]['contract_size'][normalized] = entry['contractSize']\n            _exchange_info[KRAKEN_FUTURES]['underlying'][normalized] = entry['underlying']\n            _exchange_info[KRAKEN_FUTURES]['product_type'][normalized] = _kraken_futures_product_type[normalized[:2]]\n            ret[normalized] = entry['symbol']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('KRAKEN_FUTURES', why, {\"\": r})\n\n\ndef probit_symbols() -> Dict[str, str]:\n    # doc: https://docs-en.probit.com/reference-link/market\n    r = None\n    try:\n        r = requests.get('https://api.probit.com/api/exchange/v1/market')\n        return {entry['id']: entry['id'] for entry in r.json()['data']}\n    except Exception as why:\n        raise_failure_explanation('PROBIT', why, {\"\": r})\n\n\ndef coingecko_normalize_symbol(symbol: str) -> str:\n    # keep digits, letters and dots, replace others by space\n    symbol = ''.join(c if c.isalnum() or c in ('.', '+') else ' ' for c in symbol)\n    return coingecko_normalize(symbol.upper())\n\n\ndef coingecko_normalize_name(name: str) -> str:\n    # keep digits and letters, replace others by space (except when only composed by upper case letters, digits and dots)\n    if not all(c.isupper() or c.isdigit() or c == '.' for c in name):\n        name = ''.join(c if c.isalnum() else ' ' for c in name)\n    return coingecko_normalize(name)\n\n\ndef coingecko_normalize(sym: str) -> str:\n    sym = sym.strip()\n    # do not concatenate numbers => separate them with a dot\n    sym = list(sym)\n    if len(sym) > 4:\n        for i in range(2, len(sym) - 1):\n            if sym[i] == ' ' and sym[i - 1].isdigit() and sym[i + 1].isdigit():\n                sym[i] = '.'\n    sym = ''.join(sym)\n    # concatenate space-separated words => use CamelCase to distinguish the words\n    if ' ' in sym:\n        if sum(c.islower() for c in sym):  # if there is at least one lower case letter\n            sym = ' '.join(word[0].upper() + word[1:] for word in sym.split())  # Just capitalize initial letter of each word\n        else:  # CoinGecko may provide full upper-case as for \"THE STONE COIN\"\n            sym = string.capwords(sym)  # capwords converts \"THE STONE COIN\" to \"The Stone Coin\"\n        sym = sym.replace(' ', '')  # concatenate words\n    return sym\n\n\ndef is_name_short(coin: dict) -> bool:\n    \"\"\"return True if the coin name is enough short compared to the coin symbol.\"\"\"\n    return len(coin['name']) <= max(5, len(coin['symbol']) + 1)\n\n\ndef has_many_caps(name: str) -> bool:\n    \"\"\"return True if the symbol contains enough upper case letters, False if empty.\"\"\"\n    return str and sum(c.islower() for c in name) < (len(name) / 2)\n\n\ndef coingecko_normalize_all(coin: dict):\n    SYMBOL_TO_NORMALIZED = {'miota': 'IOTA'}\n    normalized = SYMBOL_TO_NORMALIZED.get(coin['symbol'])\n    if normalized:\n        coin['ns'] = coin['nn'] = normalized\n        return normalized\n\n    # ns = normalized symbol, nn = normalized name\n    coin['ns'] = coingecko_normalize_symbol(coin['symbol'])\n\n    ID_SUFFIX = '-bitcoin-token'\n    if coin['id'][-len(ID_SUFFIX):] == ID_SUFFIX:\n        coin['nn'] = 'BTC' + coin['ns']\n        return coin['nn']\n\n    name = coin['name']\n\n    prefixes = ('The ', 'the ')\n    for p in prefixes:\n        if name[:len(p)] == p:\n            coin['reduced-name'] = True\n            name = name[len(p):]\n            break\n\n    suffixes = ('coin', 'coins', 'money', 'finance', 'protocol', 'reward', 'rewards', 'token')\n    for s in suffixes:\n        if len(name) > len(s) and name[-len(s):].lower() == s:\n            # but keep suffix when lower-case concatenated\n            if name[-len(s)].islower() and name[-len(s) - 1] != ' ':\n                continue\n            # also keep suffix to avoid confusing nam: \"Bitcoin Token\" -> \"Bitcoin\"\n            if name[:-len(s)].strip().lower() == 'bitcoin':\n                continue\n            coin['reduced-name'] = True\n            name = name[:-len(s)]\n            break\n\n    coin['nn'] = coingecko_normalize_name(name)\n\n    if len(coin['nn']) < len(coin['ns']):\n        if 'reduced-name' in coin:\n            coin['reduced-name'] = False\n            name = coin['name']\n            coin['nn'] = coingecko_normalize_name(name)\n        elif not has_many_caps(name):\n            return coin['ns']\n\n    if not coin['ns']:  # coin['symbol'] may be an emoji that is striped when normalized\n        return coin['nn']\n\n    if coin.get('reduced-name') and coin['ns'].upper() != coin['nn'].upper():\n        return coin['ns']\n\n    i = coin['nn'].find('.')  # if there is a dot in normalized name => prefer the normalized symbol\n    if i >= 0:\n        if i > 1 and coin['nn'][i - 1].isdigit() and coin['nn'][i + 1].isdigit():\n            pass  # except when the dot separates digits\n        else:\n            return coin['ns']\n\n    if is_name_short(coin) and has_many_caps(name):\n        return coin['nn']\n\n    if 1.5 * len(coin['ns']) > len(coin['nn']) and any(c.islower() for c in coin['ns']):\n        return coin['nn']\n\n    return coin['ns']\n\n\ndef coingecko_symbols() -> Dict[str, str]:\n    r = None\n    intermediate = defaultdict(list)\n    try:\n        r = requests.get('https://api.coingecko.com/api/v3/coins/list')\n        all_coins = r.json()\n        # First pass: generate & compare normalized symbol/name, and then select the most pertinent\n        for coin in all_coins:\n            normalized = coingecko_normalize_all(coin)\n            intermediate[normalized].append(coin)\n            # Above line keeps together the coins having the same normalized symbol.\n            # To reduce collision, the coin['name'] is sometimes used in lieu of the coin['symbol'].\n            # The coin['name'] is not capitalized because lower case letters may be meaningful: cETH, yUSD, DATx, zLOT\n    except Exception as why:\n        raise_failure_explanation('COINGECKO', why, {\"\": r})\n\n    final = coingecko_second_pass(intermediate)\n    return coingecko_third_pass(final)\n\n\ndef coingecko_second_pass(intermediate: Dict[str, List[dict]]) -> Dict[str, List[dict]]:\n    # Second pass: fixes most of the symbol collisions\n    final = defaultdict(list)\n    for normalized, coins in intermediate.items():\n        if len(coins) == 1:\n            final[normalized].append(coins[0])\n            continue\n        set_normalized = False\n        for i in range(len(coins)):\n            if normalized == coins[i]['nn']:\n                coin = coins.pop(i)\n                final[normalized].append(coin)\n                set_normalized = True\n                break\n        rest: List[dict] = []\n        for coin in coins:\n            if '%' in coin['name']:\n                if len(coins) == 1:\n                    n = coin['ns']\n                else:\n                    n = coingecko_normalize_name(coin['id'])\n                final[n].append(coin)\n            else:\n                rest.append(coin)\n        if not rest:\n            continue\n        if not set_normalized:\n            rest.sort(key=lambda coin: len(coin['nn']), reverse=True)  # sort by the length of the normalized name\n            coin = rest.pop(0)\n            final[normalized].append(coin)\n        for coin in rest:\n            if coin['nn'] not in intermediate:\n                n = coin['nn']\n            elif coin.get('reduced-name'):\n                n = coingecko_normalize_name(coin['name'])\n            else:\n                n = coingecko_normalize_name(coin['id'])\n            final[n].append(coin)\n    return final\n\n\ndef coingecko_third_pass(final: Dict[str, List[dict]]) -> Dict[str, str]:\n    # Third pass: fixes some remaining collisions and fills the result\n    symbols = {}\n    for normalized, coins in final.items():\n        if len(coins) == 1:\n            symbols[normalized] = coins[0]['id']\n            continue\n        set_normalized = False\n        for i in range(len(coins)):\n            if normalized == coins[i]['nn']:\n                coin = coins.pop(i)\n                symbols[normalized] = coin['id']\n                set_normalized = True\n                break\n        rest: List[dict] = []\n        for coin in coins:\n            if '%' in coin['name']:\n                if len(coins) == 1:\n                    n = coin['ns']\n                else:\n                    n = coingecko_normalize_name(coin['id'])\n                symbols[n] = coin['id']\n            else:\n                rest.append(coin)\n        if not rest:\n            continue\n        if not set_normalized:\n            rest.sort(key=lambda coin: len(coin['nn']), reverse=True)  # sort by the length of the normalized name\n            coin = rest.pop(0)\n            symbols[normalized] = coin['id']\n        for coin in rest:\n            if coin['nn'] not in final:\n                n = coin['nn']\n            elif coin.get('reduced-name'):\n                n = coingecko_normalize_name(coin['name'])\n            else:\n                n = coingecko_normalize_name(coin['id'])\n            symbols[n] = coin['id']\n    return symbols\n\n\ndef whale_alert_coins(key_id: str) -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get(f'https://api.whale-alert.io/v1/status?api_key={key_id}')\n        # Same symbols, but on different blockchains (for instance USDT), are naturally overwritten.\n        return {s.upper(): s for b in r.json()['blockchains'] for s in b['symbols'] if s}\n    except Exception as why:\n        raise_failure_explanation('WHALES_ALERT', why, {\"\": r})\n\n\n_exchange_function_map = {\n    BITFINEX: bitfinex_symbols,\n    BITFLYER: bitflyer_symbols,\n    COINBASE: coinbase_symbols,\n    GEMINI: gemini_symbols,\n    HITBTC: hitbtc_symbols,\n    POLONIEX: poloniex_symbols,\n    PROBIT: probit_symbols,\n    BITSTAMP: bitstamp_symbols,\n    KRAKEN: kraken_symbols,\n    KRAKEN + 'REST': kraken_rest_symbols,\n    BINANCE: binance_symbols,\n    BINANCE_US: binance_us_symbols,\n    BINANCE_FUTURES: binance_futures_symbols,\n    BINANCE_DELIVERY: binance_delivery_symbols,\n    BLOCKCHAIN: blockchain_symbols,\n    EXX: exx_symbols,\n    HUOBI: huobi_symbols,\n    HUOBI_DM: huobi_dm_symbols,\n    HUOBI_SWAP: huobi_swap_symbols,\n    OKCOIN: okcoin_symbols,\n    OKEX: okex_symbols,\n    BYBIT: bybit_symbols,\n    FTX: ftx_symbols,\n    FTX_US: ftx_us_symbols,\n    BITTREX: bittrex_symbols,\n    BITCOINCOM: bitcoincom_symbols,\n    BITMAX: bitmax_symbols,\n    UPBIT: upbit_symbols,\n    GATEIO: gateio_symbols,\n    BITMEX: bitmex_symbols,\n    DERIBIT: deribit_symbols,\n    KRAKEN_FUTURES: kraken_future_symbols,\n    COINGECKO: coingecko_symbols,\n    WHALE_ALERT: whale_alert_coins\n}\n",
        "source_code_len": 30534,
        "target_code": "associated with this software.\n'''\nfrom typing import Dict, Tuple\n\n\nclass _Symbols:\n    def __init__(self):\n        self.data = {}\n\n    def set(self, exchange: str, normalized: dict, exchange_info: dict):\n        self.data[exchange] = {}\n        self.data[exchange]['normalized'] = normalized\n        self.data[exchange]['info'] = exchange_info\n\n    def get(self, exchange: str) -> Tuple[Dict, Dict]:\n        return self.data[exchange]['normalized'], self.data[exchange]['info']\n\n    def populated(self, exchange: str) -> bool:\n        return exchange in self.data\n\n\nSymbols = _Symbols()\n",
        "target_code_len": 588,
        "diff_format": "@@ -5,845 +5,22 @@\n associated with this software.\n+'''\n+from typing import Dict, Tuple\n \n \n-Symbol generation code for exchanges\n-'''\n+class _Symbols:\n+    def __init__(self):\n+        self.data = {}\n \n-import logging\n-import string\n-import time\n-from collections import defaultdict\n-from typing import Dict, List, Optional, Tuple\n+    def set(self, exchange: str, normalized: dict, exchange_info: dict):\n+        self.data[exchange] = {}\n+        self.data[exchange]['normalized'] = normalized\n+        self.data[exchange]['info'] = exchange_info\n \n-import requests\n-from requests import Response\n+    def get(self, exchange: str) -> Tuple[Dict, Dict]:\n+        return self.data[exchange]['normalized'], self.data[exchange]['info']\n \n-from cryptofeed.defines import *\n+    def populated(self, exchange: str) -> bool:\n+        return exchange in self.data\n \n \n-LOG = logging.getLogger('feedhandler')\n-\n-SYMBOL_SEP = '-'\n-\n-_symbols_retrieval_cache: Dict[str, Dict[str, str]] = {}\n-_exchange_info = defaultdict(lambda: defaultdict(dict))\n-\n-\n-_kraken_futures_product_type = {\n-    'FI': 'Inverse Futures',\n-    'FV': 'Vanilla Futures',\n-    'PI': 'Perpetual Inverse Futures',\n-    'PV': 'Perpetual Vanilla Futures',\n-    'IN': 'Real Time Index',\n-    'RR': 'Reference Rate',\n-}\n-\n-\n-def raise_failure_explanation(feed_id: str, exception: BaseException, responses: Dict[str, Optional[Response]]):\n-    LOG.critical('%s: encountered %r while processing response from exchange API', feed_id, exception)\n-    if len(responses) > 1:\n-        LOG.critical('%s: content of one of the %s responses was unexpected', feed_id, len(responses))\n-    for url, r in responses.items():\n-        if url:\n-            LOG.critical('%s: requested URL: %s', feed_id, url)\n-        if r:\n-            LOG.critical('%s: unexpected response: %s', feed_id, r.text)\n-    raise ValueError(f'Cryptofeed stopped because of an unexpected response from {feed_id}') from exception\n-\n-\n-def set_symbol_separator(separator: str):\n-    global SYMBOL_SEP\n-    SYMBOL_SEP = separator\n-\n-\n-def get_symbol_separator() -> str:\n-    global SYMBOL_SEP\n-    return SYMBOL_SEP\n-\n-\n-def gen_symbols(exchange: str, key_id=None) -> Dict[str, str]:\n-    if exchange not in _symbols_retrieval_cache:\n-        LOG.info(\"%s: Getting list of symbols\", exchange)\n-        symbols = _exchange_function_map[exchange](key_id) if key_id else _exchange_function_map[exchange]()\n-        LOG.info(\"%s: %s symbols\", exchange, len(symbols))\n-\n-        # log all retrieved symbols using debug level\n-        for normalized, exch_sym in sorted(symbols.items()):\n-            LOG.debug('%s: id-from-exch -> normalized: %-35s-> %s', exchange, exch_sym, normalized)\n-\n-        _symbols_retrieval_cache[exchange] = symbols\n-    return _symbols_retrieval_cache[exchange]\n-\n-\n-def _binance_symbols(endpoint: str, exchange: str):\n-    r = None\n-    try:\n-        ret = {}\n-        r = requests.get(endpoint)\n-        for symbol in r.json()['symbols']:\n-            if symbol.get('status', 'TRADING') != \"TRADING\":\n-                continue\n-            if symbol.get('contractStatus', 'TRADING') != \"TRADING\":\n-                continue\n-            split = len(symbol['baseAsset'])\n-            normalized = symbol['symbol'][:split] + SYMBOL_SEP + symbol['symbol'][split:]\n-            ret[normalized] = symbol['symbol']\n-            _exchange_info[exchange]['tick_size'][normalized] = symbol['filters'][0]['tickSize']\n-            if \"contractType\" in symbol:\n-                _exchange_info[exchange]['contract_type'][normalized] = symbol['contractType']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation(exchange, why, {endpoint: r})\n-\n-\n-def binance_symbols() -> Dict[str, str]:\n-    return _binance_symbols('https://api.binance.com/api/v3/exchangeInfo', BINANCE)\n-\n-\n-def binance_us_symbols() -> Dict[str, str]:\n-    return _binance_symbols('https://api.binance.us/api/v3/exchangeInfo', BINANCE_US)\n-\n-\n-def binance_futures_symbols() -> Dict[str, str]:\n-    base = _binance_symbols('https://fapi.binance.com/fapi/v1/exchangeInfo', BINANCE_FUTURES)\n-    add = {}\n-    for symbol, orig in base.items():\n-        if \"_\" in orig:\n-            continue\n-        add[f\"{symbol}-PINDEX\"] = f\"p{orig}\"\n-    base.update(add)\n-    return base\n-\n-\n-def binance_delivery_symbols() -> Dict[str, str]:\n-    return _binance_symbols('https://dapi.binance.com/dapi/v1/exchangeInfo', BINANCE_DELIVERY)\n-\n-\n-def bitfinex_symbols() -> Dict[str, str]:\n-    # doc: https://docs.bitfinex.com/docs/ws-general#supported-pairs\n-    r1 = r2 = None\n-    try:\n-        r1 = requests.get('https://api.bitfinex.com/v2/tickers?symbols=ALL')\n-        r2 = requests.get('https://api-pub.bitfinex.com/v2/conf/pub:map:currency:sym')\n-        tickers: List[List[str]] = r1.json()\n-        norm: List[Tuple[str, str]] = r2.json()[0]\n-        norm: Dict[str, str] = dict(norm)\n-        for k, v in dict(norm).items():\n-            if k[-2:] == 'F0' or '-' in v:  # Do not convert BTCF0 -> BTC or PBTCETH -> PBTC-ETH\n-                del norm[k]\n-        norm['BCHN'] = 'BCH'  # Bitfinex uses BCHN, other exchanges use BCH\n-\n-        ret = {}\n-        for symbol in [t[0] for t in tickers]:\n-            if symbol[0] == 'f':\n-                normalized = norm.get(symbol[1:], symbol[1:])\n-            else:\n-                if len(symbol) == 7:\n-                    base, quote = symbol[1:4], symbol[4:]\n-                else:\n-                    base, quote = symbol[1:].split(':')\n-                    assert ':' in symbol\n-                normalized = norm.get(base, base) + SYMBOL_SEP + norm.get(quote, quote)\n-            ret[normalized.upper()] = symbol\n-        return ret\n-    except ValueError as why:\n-        raise_failure_explanation('BITFINEX', why, {\"tickers?symbols=ALL\": r1, \"pub:map:currency:sym\": r2})\n-\n-\n-def bitflyer_symbols() -> Dict[str, str]:\n-    endpoint = r = None\n-    try:\n-        ret = {}\n-        endpoints = ['https://api.bitflyer.com/v1/getmarkets/eu', 'https://api.bitflyer.com/v1/getmarkets/usa', 'https://api.bitflyer.com/v1/getmarkets']\n-        for endpoint in endpoints:\n-            r = requests.get(endpoint)\n-            for entry in r.json():\n-                normalized = entry['product_code'].replace(\"_\", SYMBOL_SEP)\n-                ret[normalized] = entry['product_code']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('BITFLYER', why, {endpoint: r})\n-\n-\n-def bybit_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.bybit.com/v2/public/symbols')\n-        ret = {}\n-        for symbol in r.json()['result']:\n-            quote = symbol['quote_currency']\n-            if not symbol['name'].endswith(quote):\n-                base, contract = symbol['name'].split(quote)\n-                normalized = f\"{base}{SYMBOL_SEP}{quote}-{contract}\"\n-            else:\n-                normalized = f\"{symbol['base_currency']}{SYMBOL_SEP}{quote}\"\n-            ret[normalized] = symbol['name']\n-            _exchange_info[BYBIT]['tick_size'][normalized] = symbol['price_filter']['tick_size']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('BYBIT', why, {\"\": r})\n-\n-\n-def _ftx_helper(endpoint: str, exchange: str):\n-    r = None\n-    try:\n-        r = requests.get(endpoint)\n-        ret = {}\n-        for data in r.json()['result']:\n-            normalized = data['name'].replace(\"/\", SYMBOL_SEP)\n-            symbol = data['name']\n-            ret[normalized] = symbol\n-            _exchange_info[exchange]['tick_size'][normalized] = data['priceIncrement']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation(exchange, why, {endpoint: r})\n-\n-\n-def ftx_symbols() -> Dict[str, str]:\n-    return _ftx_helper('https://ftx.com/api/markets', FTX)\n-\n-\n-def ftx_us_symbols() -> Dict[str, str]:\n-    return _ftx_helper('https://ftx.us/api/markets', FTX_US)\n-\n-\n-def coinbase_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.pro.coinbase.com/products')\n-        ret = {}\n-        for data in r.json():\n-            normalized = data['id'].replace(\"-\", SYMBOL_SEP)\n-            ret[normalized] = data['id']\n-            _exchange_info[COINBASE]['tick_size'][normalized] = data['quote_increment']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('COINBASE', why, {\"\": r})\n-\n-\n-def gemini_symbols(*args) -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.gemini.com/v1/symbols')\n-        ret = {}\n-        for symbol in r.json():\n-            std = f\"{symbol[:-3]}{SYMBOL_SEP}{symbol[-3:]}\"\n-            std = std.upper()\n-            ret[std] = symbol.upper()\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('GEMINI', why, {\"\": r})\n-\n-\n-def hitbtc_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        ret = {}\n-        r = requests.get('https://api.hitbtc.com/api/2/public/symbol')\n-        for symbol in r.json():\n-            split = len(symbol['baseCurrency'])\n-            normalized = symbol['id'][:split] + SYMBOL_SEP + symbol['id'][split:]\n-            ret[normalized] = symbol['id']\n-            _exchange_info[HITBTC]['tick_size'][normalized] = symbol['tickSize']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('HITBTC', why, {\"\": r})\n-\n-\n-def poloniex_id_symbol_mapping():\n-    r = None\n-    try:\n-        r = requests.get('https://poloniex.com/public?command=returnTicker')\n-        symbols = r.json()\n-        ret = {}\n-        for symbol in symbols:\n-            ret[symbols[symbol]['id']] = symbol\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('POLONIEX', why, {\"\": r})\n-\n-\n-def poloniex_symbols() -> Dict[str, str]:\n-    ret = {}\n-    for _, value in poloniex_id_symbol_mapping().items():\n-        std = value.replace(\"STR\", \"XLM\")\n-        quote, base = std.split(\"_\")\n-        ret[quote + SYMBOL_SEP + base] = value\n-    return ret\n-\n-\n-def bitstamp_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://www.bitstamp.net/api/v2/trading-pairs-info/')\n-        ret = {}\n-        for data in r.json():\n-            normalized = data['name'].replace(\"/\", SYMBOL_SEP)\n-            symbol = data['url_symbol']\n-            ret[normalized] = symbol\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('BITSTAMP', why, {\"\": r})\n-\n-\n-def kraken_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.kraken.com/0/public/AssetPairs')\n-        data = r.json()\n-        ret = {}\n-        for symbol in data['result']:\n-            if 'wsname' not in data['result'][symbol] or '.d' in symbol:\n-                # https://blog.kraken.com/post/259/introducing-the-kraken-dark-pool/\n-                # .d is for dark pool symbols\n-                continue\n-\n-            base, quote = data['result'][symbol]['wsname'].split(\"/\")\n-\n-            normalized = f\"{base}{SYMBOL_SEP}{quote}\"\n-            exch = data['result'][symbol]['wsname']\n-            normalized = normalized.replace('XBT', 'BTC')\n-            normalized = normalized.replace('XDG', 'DOG')\n-            ret[normalized] = exch\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('KRAKEN', why, {\"\": r})\n-\n-\n-def kraken_rest_symbols() -> Dict[str, str]:\n-    return {normalized: exchange.replace(\"/\", \"\") for normalized, exchange in kraken_symbols().items()}\n-\n-\n-def exx_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.exx.com/data/v1/tickers')\n-        exchange = [key.upper() for key in r.json().keys()]\n-        symbols = [key.replace(\"_\", SYMBOL_SEP) for key in exchange]\n-        return dict(zip(symbols, exchange))\n-    except Exception as why:\n-        raise_failure_explanation('EXX', why, {\"\": r})\n-\n-\n-def huobi_common_symbols(url: str):\n-    r = None\n-    try:\n-        r = requests.get(url)\n-        ret = {}\n-        for e in r.json()['data']:\n-            if e['state'] == 'offline':\n-                continue\n-            normalized = f\"{e['base-currency'].upper()}{SYMBOL_SEP}{e['quote-currency'].upper()}\"\n-            symbol = f\"{e['base-currency']}{e['quote-currency']}\"\n-            ret[normalized] = symbol\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('HUOBI', why, {url: r})\n-\n-\n-def huobi_symbols() -> Dict[str, str]:\n-    return huobi_common_symbols('https://api.huobi.pro/v1/common/symbols')\n-\n-\n-def huobi_us_symbols() -> Dict[str, str]:\n-    return huobi_common_symbols('https://api.huobi.com/v1/common/symbols')\n-\n-\n-def huobi_dm_symbols() -> Dict[str, str]:\n-    \"\"\"\n-    Mapping is, for instance: {\"BTC_CW\":\"BTC190816\"}\n-    See comments in exchange/huobi_dm.py\n-    \"\"\"\n-    mapping = {\n-        \"this_week\": \"CW\",\n-        \"next_week\": \"NW\",\n-        \"quarter\": \"CQ\",\n-        \"next_quarter\": \"NQ\"\n-    }\n-    r = None\n-    try:\n-        r = requests.get('https://www.hbdm.com/api/v1/contract_contract_info')\n-        symbols = {}\n-        for e in r.json()['data']:\n-            symbols[f\"{e['symbol']}_{mapping[e['contract_type']]}\"] = e['contract_code']\n-            _exchange_info[HUOBI_DM]['tick_size'][e['contract_code']] = e['price_tick']\n-            _exchange_info[HUOBI_DM]['short_code_mappings'][f\"{e['symbol']}_{mapping[e['contract_type']]}\"] = e['contract_code']\n-        return symbols\n-    except Exception as why:\n-        raise_failure_explanation('HUOBI_DM', why, {\"\": r})\n-\n-\n-def huobi_swap_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.hbdm.com/swap-api/v1/swap_contract_info')\n-        symbols = {}\n-        for e in r.json()['data']:\n-            symbols[e['contract_code']] = e['contract_code']\n-            _exchange_info[HUOBI_SWAP]['tick_size'][e['contract_code']] = e['price_tick']\n-        return symbols\n-    except Exception as why:\n-        raise_failure_explanation('HUOBI_SWAP', why, {\"\": r})\n-\n-\n-def okcoin_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://www.okcoin.com/api/spot/v3/instruments')\n-        ret = {}\n-        for e in r.json():\n-            ret[e['instrument_id']] = e['instrument_id']\n-            _exchange_info[OKCOIN]['tick_size'][e['instrument_id']] = e['tick_size']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('OKCOIN', why, {\"\": r})\n-\n-\n-def okex_symbols(*args) -> Dict[str, str]:\n-    urls = ['https://www.okex.com/api/spot/v3/instruments',\n-            'https://www.okex.com/api/swap/v3/instruments',\n-            'https://www.okex.com/api/futures/v3/instruments']\n-    urls = urls + okex_compute_option_urls_from_underlyings()\n-\n-    symbols: Dict[str, str] = {}\n-    for u in urls:\n-        time.sleep(0.2)\n-        symbols.update(okex_symbols_from_one_url(u))\n-\n-    for symbol in symbols:\n-        instrument_type = 'futures'\n-        dash_count = symbol.count(get_symbol_separator())\n-        if dash_count == 1:  # BTC-USDT\n-            instrument_type = 'spot'\n-        if dash_count == 4:  # BTC-USD-201225-35000-P\n-            instrument_type = 'option'\n-        if symbol[-4:] == \"SWAP\":  # BTC-USDT-SWAP\n-            instrument_type = 'swap'\n-\n-        _exchange_info[OKEX]['instrument_type'][symbol] = instrument_type\n-\n-    return symbols\n-\n-\n-def okex_compute_option_urls_from_underlyings() -> List[str]:\n-    url = 'https://www.okex.com/api/option/v3/underlying'\n-    r = None\n-    try:\n-        r = requests.get(url)\n-        return [f'https://www.okex.com/api/option/v3/instruments/{underlying}' for underlying in r.json()]\n-    except Exception as why:\n-        raise_failure_explanation('OKEX', why, {url: r})\n-\n-\n-def okex_symbols_from_one_url(url: str) -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get(url)\n-        ret = {}\n-        for e in r.json():\n-            ret[e['instrument_id']] = e['instrument_id']\n-            _exchange_info[OKEX]['tick_size'][e['instrument_id']] = e['tick_size']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('OKEX', why, {url: r})\n-\n-\n-def bittrex_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.bittrex.com/api/v1.1/public/getmarkets')\n-        r = r.json()['result']\n-        return {f\"{e['MarketCurrency']}{SYMBOL_SEP}{e['BaseCurrency']}\": e['MarketName'] for e in r if e['IsActive']}\n-    except Exception as why:\n-        raise_failure_explanation('BITTREX', why, {\"\": r})\n-\n-\n-def bitcoincom_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.exchange.bitcoin.com/api/2/public/symbol')\n-        return {f\"{data['baseCurrency']}{SYMBOL_SEP}{data['quoteCurrency'].replace('USD', 'USDT')}\": data['id'] for data in r.json()}\n-    except Exception as why:\n-        raise_failure_explanation('BITCOINCOM', why, {\"\": r})\n-\n-\n-def bitmax_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://bitmax.io/api/pro/v1/products')\n-        ret = {}\n-        for entry in r.json()['data']:\n-            # Only \"Normal\" status symbols are tradeable\n-            if entry['status'] == 'Normal':\n-                normalized = f\"{entry['baseAsset']}{SYMBOL_SEP}{entry['quoteAsset']}\"\n-                ret[normalized] = entry['symbol']\n-                _exchange_info[BITMAX]['tick_size'][normalized] = entry['tickSize']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('BITMAX', why, {\"\": r})\n-\n-\n-def upbit_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.upbit.com/v1/market/all')\n-        return {f\"{data['market'].split('-')[1]}{SYMBOL_SEP}{data['market'].split('-')[0]}\": data['market'] for data in r.json()}\n-    except Exception as why:\n-        raise_failure_explanation('UPBIT', why, {\"\": r})\n-\n-\n-def blockchain_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get(\"https://api.blockchain.com/mercury-gateway/v1/instruments\")\n-        return {data[\"symbol\"].replace(\"-\", SYMBOL_SEP): data[\"symbol\"] for data in r.json()}\n-    except Exception as why:\n-        raise_failure_explanation('BLOCKCHAIN', why, {\"\": r})\n-\n-\n-def gateio_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get(\"https://api.gateio.ws/api/v4/spot/currency_pairs\")\n-        return {data[\"id\"].replace(\"_\", SYMBOL_SEP): data['id'] for data in r.json()}\n-    except Exception as why:\n-        raise_failure_explanation('GATEIO', why, {\"\": r})\n-\n-\n-def bitmex_symbols() -> Dict[str, str]:\n-    r = None\n-    ret = {}\n-    try:\n-        r = requests.get(\"https://www.bitmex.com/api/v1/instrument/active\")\n-        for entry in r.json():\n-            components = []\n-            components.append(entry['rootSymbol'])\n-            components.append(entry['quoteCurrency'])\n-\n-            if entry['expiry']:\n-                components.append(entry['symbol'][-3:])\n-\n-            normalized = SYMBOL_SEP.join(components)\n-            normalized = normalized.replace(\"XBT\", \"BTC\")\n-            ret[normalized] = entry['symbol']\n-            _exchange_info[BITMEX]['tick_size'][normalized] = entry['tickSize']\n-\n-            if entry['expiry']:\n-                _exchange_info[BITMEX]['expiry'][normalized] = entry['expiry']\n-\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('BITMEX', why, {\"\": r})\n-\n-\n-def deribit_symbols() -> Dict[str, str]:\n-    url = r = None\n-    ret = {}\n-    try:\n-        # TODO: get currencies from https://www.deribit.com/api/v2/public/get_currencies\n-        currencies = ['BTC', 'ETH']\n-        for c in currencies:\n-            url = f\"https://www.deribit.com/api/v2/public/get_instruments?currency={c}&expired=false\"\n-            r = requests.get(url)\n-            for entry in r.json()['result']:\n-                split = entry['instrument_name'].split(\"-\")\n-                normalized = split[0] + SYMBOL_SEP + entry['quote_currency'] + \"-\" + '-'.join(split[1:])\n-                ret[normalized] = entry['instrument_name']\n-                _exchange_info[DERIBIT]['tick_size'][normalized] = entry['tick_size']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('DERIBIT', why, {url: r})\n-\n-\n-def kraken_future_symbols() -> Dict[str, str]:\n-    r = None\n-    ret = {}\n-    try:\n-        r = requests.get('https://futures.kraken.com/derivatives/api/v3/instruments')\n-        data = r.json()['instruments']\n-        for entry in data:\n-            if not entry['tradeable']:\n-                continue\n-            normalized = entry['symbol'].upper().replace(\"_\", \"-\")\n-            symbol = normalized[3:6] + SYMBOL_SEP + normalized[6:9]\n-            normalized = normalized.replace(normalized[3:9], symbol)\n-            normalized = normalized.replace('XBT', 'BTC')\n-\n-            _exchange_info[KRAKEN_FUTURES]['tick_size'][normalized] = entry['tickSize']\n-            _exchange_info[KRAKEN_FUTURES]['contract_size'][normalized] = entry['contractSize']\n-            _exchange_info[KRAKEN_FUTURES]['underlying'][normalized] = entry['underlying']\n-            _exchange_info[KRAKEN_FUTURES]['product_type'][normalized] = _kraken_futures_product_type[normalized[:2]]\n-            ret[normalized] = entry['symbol']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('KRAKEN_FUTURES', why, {\"\": r})\n-\n-\n-def probit_symbols() -> Dict[str, str]:\n-    # doc: https://docs-en.probit.com/reference-link/market\n-    r = None\n-    try:\n-        r = requests.get('https://api.probit.com/api/exchange/v1/market')\n-        return {entry['id']: entry['id'] for entry in r.json()['data']}\n-    except Exception as why:\n-        raise_failure_explanation('PROBIT', why, {\"\": r})\n-\n-\n-def coingecko_normalize_symbol(symbol: str) -> str:\n-    # keep digits, letters and dots, replace others by space\n-    symbol = ''.join(c if c.isalnum() or c in ('.', '+') else ' ' for c in symbol)\n-    return coingecko_normalize(symbol.upper())\n-\n-\n-def coingecko_normalize_name(name: str) -> str:\n-    # keep digits and letters, replace others by space (except when only composed by upper case letters, digits and dots)\n-    if not all(c.isupper() or c.isdigit() or c == '.' for c in name):\n-        name = ''.join(c if c.isalnum() else ' ' for c in name)\n-    return coingecko_normalize(name)\n-\n-\n-def coingecko_normalize(sym: str) -> str:\n-    sym = sym.strip()\n-    # do not concatenate numbers => separate them with a dot\n-    sym = list(sym)\n-    if len(sym) > 4:\n-        for i in range(2, len(sym) - 1):\n-            if sym[i] == ' ' and sym[i - 1].isdigit() and sym[i + 1].isdigit():\n-                sym[i] = '.'\n-    sym = ''.join(sym)\n-    # concatenate space-separated words => use CamelCase to distinguish the words\n-    if ' ' in sym:\n-        if sum(c.islower() for c in sym):  # if there is at least one lower case letter\n-            sym = ' '.join(word[0].upper() + word[1:] for word in sym.split())  # Just capitalize initial letter of each word\n-        else:  # CoinGecko may provide full upper-case as for \"THE STONE COIN\"\n-            sym = string.capwords(sym)  # capwords converts \"THE STONE COIN\" to \"The Stone Coin\"\n-        sym = sym.replace(' ', '')  # concatenate words\n-    return sym\n-\n-\n-def is_name_short(coin: dict) -> bool:\n-    \"\"\"return True if the coin name is enough short compared to the coin symbol.\"\"\"\n-    return len(coin['name']) <= max(5, len(coin['symbol']) + 1)\n-\n-\n-def has_many_caps(name: str) -> bool:\n-    \"\"\"return True if the symbol contains enough upper case letters, False if empty.\"\"\"\n-    return str and sum(c.islower() for c in name) < (len(name) / 2)\n-\n-\n-def coingecko_normalize_all(coin: dict):\n-    SYMBOL_TO_NORMALIZED = {'miota': 'IOTA'}\n-    normalized = SYMBOL_TO_NORMALIZED.get(coin['symbol'])\n-    if normalized:\n-        coin['ns'] = coin['nn'] = normalized\n-        return normalized\n-\n-    # ns = normalized symbol, nn = normalized name\n-    coin['ns'] = coingecko_normalize_symbol(coin['symbol'])\n-\n-    ID_SUFFIX = '-bitcoin-token'\n-    if coin['id'][-len(ID_SUFFIX):] == ID_SUFFIX:\n-        coin['nn'] = 'BTC' + coin['ns']\n-        return coin['nn']\n-\n-    name = coin['name']\n-\n-    prefixes = ('The ', 'the ')\n-    for p in prefixes:\n-        if name[:len(p)] == p:\n-            coin['reduced-name'] = True\n-            name = name[len(p):]\n-            break\n-\n-    suffixes = ('coin', 'coins', 'money', 'finance', 'protocol', 'reward', 'rewards', 'token')\n-    for s in suffixes:\n-        if len(name) > len(s) and name[-len(s):].lower() == s:\n-            # but keep suffix when lower-case concatenated\n-            if name[-len(s)].islower() and name[-len(s) - 1] != ' ':\n-                continue\n-            # also keep suffix to avoid confusing nam: \"Bitcoin Token\" -> \"Bitcoin\"\n-            if name[:-len(s)].strip().lower() == 'bitcoin':\n-                continue\n-            coin['reduced-name'] = True\n-            name = name[:-len(s)]\n-            break\n-\n-    coin['nn'] = coingecko_normalize_name(name)\n-\n-    if len(coin['nn']) < len(coin['ns']):\n-        if 'reduced-name' in coin:\n-            coin['reduced-name'] = False\n-            name = coin['name']\n-            coin['nn'] = coingecko_normalize_name(name)\n-        elif not has_many_caps(name):\n-            return coin['ns']\n-\n-    if not coin['ns']:  # coin['symbol'] may be an emoji that is striped when normalized\n-        return coin['nn']\n-\n-    if coin.get('reduced-name') and coin['ns'].upper() != coin['nn'].upper():\n-        return coin['ns']\n-\n-    i = coin['nn'].find('.')  # if there is a dot in normalized name => prefer the normalized symbol\n-    if i >= 0:\n-        if i > 1 and coin['nn'][i - 1].isdigit() and coin['nn'][i + 1].isdigit():\n-            pass  # except when the dot separates digits\n-        else:\n-            return coin['ns']\n-\n-    if is_name_short(coin) and has_many_caps(name):\n-        return coin['nn']\n-\n-    if 1.5 * len(coin['ns']) > len(coin['nn']) and any(c.islower() for c in coin['ns']):\n-        return coin['nn']\n-\n-    return coin['ns']\n-\n-\n-def coingecko_symbols() -> Dict[str, str]:\n-    r = None\n-    intermediate = defaultdict(list)\n-    try:\n-        r = requests.get('https://api.coingecko.com/api/v3/coins/list')\n-        all_coins = r.json()\n-        # First pass: generate & compare normalized symbol/name, and then select the most pertinent\n-        for coin in all_coins:\n-            normalized = coingecko_normalize_all(coin)\n-            intermediate[normalized].append(coin)\n-            # Above line keeps together the coins having the same normalized symbol.\n-            # To reduce collision, the coin['name'] is sometimes used in lieu of the coin['symbol'].\n-            # The coin['name'] is not capitalized because lower case letters may be meaningful: cETH, yUSD, DATx, zLOT\n-    except Exception as why:\n-        raise_failure_explanation('COINGECKO', why, {\"\": r})\n-\n-    final = coingecko_second_pass(intermediate)\n-    return coingecko_third_pass(final)\n-\n-\n-def coingecko_second_pass(intermediate: Dict[str, List[dict]]) -> Dict[str, List[dict]]:\n-    # Second pass: fixes most of the symbol collisions\n-    final = defaultdict(list)\n-    for normalized, coins in intermediate.items():\n-        if len(coins) == 1:\n-            final[normalized].append(coins[0])\n-            continue\n-        set_normalized = False\n-        for i in range(len(coins)):\n-            if normalized == coins[i]['nn']:\n-                coin = coins.pop(i)\n-                final[normalized].append(coin)\n-                set_normalized = True\n-                break\n-        rest: List[dict] = []\n-        for coin in coins:\n-            if '%' in coin['name']:\n-                if len(coins) == 1:\n-                    n = coin['ns']\n-                else:\n-                    n = coingecko_normalize_name(coin['id'])\n-                final[n].append(coin)\n-            else:\n-                rest.append(coin)\n-        if not rest:\n-            continue\n-        if not set_normalized:\n-            rest.sort(key=lambda coin: len(coin['nn']), reverse=True)  # sort by the length of the normalized name\n-            coin = rest.pop(0)\n-            final[normalized].append(coin)\n-        for coin in rest:\n-            if coin['nn'] not in intermediate:\n-                n = coin['nn']\n-            elif coin.get('reduced-name'):\n-                n = coingecko_normalize_name(coin['name'])\n-            else:\n-                n = coingecko_normalize_name(coin['id'])\n-            final[n].append(coin)\n-    return final\n-\n-\n-def coingecko_third_pass(final: Dict[str, List[dict]]) -> Dict[str, str]:\n-    # Third pass: fixes some remaining collisions and fills the result\n-    symbols = {}\n-    for normalized, coins in final.items():\n-        if len(coins) == 1:\n-            symbols[normalized] = coins[0]['id']\n-            continue\n-        set_normalized = False\n-        for i in range(len(coins)):\n-            if normalized == coins[i]['nn']:\n-                coin = coins.pop(i)\n-                symbols[normalized] = coin['id']\n-                set_normalized = True\n-                break\n-        rest: List[dict] = []\n-        for coin in coins:\n-            if '%' in coin['name']:\n-                if len(coins) == 1:\n-                    n = coin['ns']\n-                else:\n-                    n = coingecko_normalize_name(coin['id'])\n-                symbols[n] = coin['id']\n-            else:\n-                rest.append(coin)\n-        if not rest:\n-            continue\n-        if not set_normalized:\n-            rest.sort(key=lambda coin: len(coin['nn']), reverse=True)  # sort by the length of the normalized name\n-            coin = rest.pop(0)\n-            symbols[normalized] = coin['id']\n-        for coin in rest:\n-            if coin['nn'] not in final:\n-                n = coin['nn']\n-            elif coin.get('reduced-name'):\n-                n = coingecko_normalize_name(coin['name'])\n-            else:\n-                n = coingecko_normalize_name(coin['id'])\n-            symbols[n] = coin['id']\n-    return symbols\n-\n-\n-def whale_alert_coins(key_id: str) -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get(f'https://api.whale-alert.io/v1/status?api_key={key_id}')\n-        # Same symbols, but on different blockchains (for instance USDT), are naturally overwritten.\n-        return {s.upper(): s for b in r.json()['blockchains'] for s in b['symbols'] if s}\n-    except Exception as why:\n-        raise_failure_explanation('WHALES_ALERT', why, {\"\": r})\n-\n-\n-_exchange_function_map = {\n-    BITFINEX: bitfinex_symbols,\n-    BITFLYER: bitflyer_symbols,\n-    COINBASE: coinbase_symbols,\n-    GEMINI: gemini_symbols,\n-    HITBTC: hitbtc_symbols,\n-    POLONIEX: poloniex_symbols,\n-    PROBIT: probit_symbols,\n-    BITSTAMP: bitstamp_symbols,\n-    KRAKEN: kraken_symbols,\n-    KRAKEN + 'REST': kraken_rest_symbols,\n-    BINANCE: binance_symbols,\n-    BINANCE_US: binance_us_symbols,\n-    BINANCE_FUTURES: binance_futures_symbols,\n-    BINANCE_DELIVERY: binance_delivery_symbols,\n-    BLOCKCHAIN: blockchain_symbols,\n-    EXX: exx_symbols,\n-    HUOBI: huobi_symbols,\n-    HUOBI_DM: huobi_dm_symbols,\n-    HUOBI_SWAP: huobi_swap_symbols,\n-    OKCOIN: okcoin_symbols,\n-    OKEX: okex_symbols,\n-    BYBIT: bybit_symbols,\n-    FTX: ftx_symbols,\n-    FTX_US: ftx_us_symbols,\n-    BITTREX: bittrex_symbols,\n-    BITCOINCOM: bitcoincom_symbols,\n-    BITMAX: bitmax_symbols,\n-    UPBIT: upbit_symbols,\n-    GATEIO: gateio_symbols,\n-    BITMEX: bitmex_symbols,\n-    DERIBIT: deribit_symbols,\n-    KRAKEN_FUTURES: kraken_future_symbols,\n-    COINGECKO: coingecko_symbols,\n-    WHALE_ALERT: whale_alert_coins\n-}\n+Symbols = _Symbols()\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\n\nimport logging\nimport string\nimport time\nfrom collections import defaultdict\nfrom typing import Dict, List, Optional, Tuple\n\nimport requests\nfrom requests import Response\n\nfrom cryptofeed.defines import *\n\n\nLOG = logging.getLogger('feedhandler')\n\nSYMBOL_SEP = '-'\n\n_symbols_retrieval_cache: Dict[str, Dict[str, str]] = {}\n_exchange_info = defaultdict(lambda: defaultdict(dict))\n\n\n_kraken_futures_product_type = {\n    'FI': 'Inverse Futures',\n    'FV': 'Vanilla Futures',\n    'PI': 'Perpetual Inverse Futures',\n    'PV': 'Perpetual Vanilla Futures',\n    'IN': 'Real Time Index',\n    'RR': 'Reference Rate',\n}\n\n\ndef raise_failure_explanation(feed_id: str, exception: BaseException, responses: Dict[str, Optional[Response]]):\n    <IND>LOG.critical('%s: encountered %r while processing response from exchange API', feed_id, exception)\n    if len(responses) > 1:\n        <IND>LOG.critical('%s: content of one of the %s responses was unexpected', feed_id, len(responses))\n    <DED>for url, r in responses.items():\n        <IND>if url:\n            <IND>LOG.critical('%s: requested URL: %s', feed_id, url)\n        <DED>if r:\n            <IND>LOG.critical('%s: unexpected response: %s', feed_id, r.text)\n    <DED><DED>raise ValueError(f'Cryptofeed stopped because of an unexpected response from {feed_id}') from exception\n\n\n<DED>def set_symbol_separator(separator: str):\n    <IND>global SYMBOL_SEP\n    SYMBOL_SEP = separator\n\n\n<DED>def get_symbol_separator() -> str:\n    <IND>global SYMBOL_SEP\n    return SYMBOL_SEP\n\n\n<DED>def gen_symbols(exchange: str, key_id=None) -> Dict[str, str]:\n    <IND>if exchange not in _symbols_retrieval_cache:\n        <IND>LOG.info(\"%s: Getting list of symbols\", exchange)\n        symbols = _exchange_function_map[exchange](key_id) if key_id else _exchange_function_map[exchange]()\n        LOG.info(\"%s: %s symbols\", exchange, len(symbols))\n\n        # log all retrieved symbols using debug level\n        for normalized, exch_sym in sorted(symbols.items()):\n            <IND>LOG.debug('%s: id-from-exch -> normalized: %-35s-> %s', exchange, exch_sym, normalized)\n\n        <DED>_symbols_retrieval_cache[exchange] = symbols\n    <DED>return _symbols_retrieval_cache[exchange]\n\n\n<DED>def _binance_symbols(endpoint: str, exchange: str):\n    <IND>r = None\n    try:\n        <IND>ret = {}\n        r = requests.get(endpoint)\n        for symbol in r.json()['symbols']:\n            <IND>if symbol.get('status', 'TRADING') != \"TRADING\":\n                <IND>continue\n            <DED>if symbol.get('contractStatus', 'TRADING') != \"TRADING\":\n                <IND>continue\n            <DED>split = len(symbol['baseAsset'])\n            normalized = symbol['symbol'][:split] + SYMBOL_SEP + symbol['symbol'][split:]\n            ret[normalized] = symbol['symbol']\n            _exchange_info[exchange]['tick_size'][normalized] = symbol['filters'][0]['tickSize']\n            if \"contractType\" in symbol:\n                <IND>_exchange_info[exchange]['contract_type'][normalized] = symbol['contractType']\n        <DED><DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation(exchange, why, {endpoint: r})\n\n\n<DED><DED>def binance_symbols() -> Dict[str, str]:\n    <IND>return _binance_symbols('https://api.binance.com/api/v3/exchangeInfo', BINANCE)\n\n\n<DED>def binance_us_symbols() -> Dict[str, str]:\n    <IND>return _binance_symbols('https://api.binance.us/api/v3/exchangeInfo', BINANCE_US)\n\n\n<DED>def binance_futures_symbols() -> Dict[str, str]:\n    <IND>base = _binance_symbols('https://fapi.binance.com/fapi/v1/exchangeInfo', BINANCE_FUTURES)\n    add = {}\n    for symbol, orig in base.items():\n        <IND>if \"_\" in orig:\n            <IND>continue\n        <DED>add[f\"{symbol}-PINDEX\"] = f\"p{orig}\"\n    <DED>base.update(add)\n    return base\n\n\n<DED>def binance_delivery_symbols() -> Dict[str, str]:\n    <IND>return _binance_symbols('https://dapi.binance.com/dapi/v1/exchangeInfo', BINANCE_DELIVERY)\n\n\n<DED>def bitfinex_symbols() -> Dict[str, str]:\n    # doc: https://docs.bitfinex.com/docs/ws-general#supported-pairs\n    <IND>r1 = r2 = None\n    try:\n        <IND>r1 = requests.get('https://api.bitfinex.com/v2/tickers?symbols=ALL')\n        r2 = requests.get('https://api-pub.bitfinex.com/v2/conf/pub:map:currency:sym')\n        tickers: List[List[str]] = r1.json()\n        norm: List[Tuple[str, str]] = r2.json()[0]\n        norm: Dict[str, str] = dict(norm)\n        for k, v in dict(norm).items():\n            <IND>if k[-2:] == 'F0' or '-' in v:  # Do not convert BTCF0 -> BTC or PBTCETH -> PBTC-ETH\n                <IND>del norm[k]\n        <DED><DED>norm['BCHN'] = 'BCH'  # Bitfinex uses BCHN, other exchanges use BCH\n\n        ret = {}\n        for symbol in [t[0] for t in tickers]:\n            <IND>if symbol[0] == 'f':\n                <IND>normalized = norm.get(symbol[1:], symbol[1:])\n            <DED>else:\n                <IND>if len(symbol) == 7:\n                    <IND>base, quote = symbol[1:4], symbol[4:]\n                <DED>else:\n                    <IND>base, quote = symbol[1:].split(':')\n                    assert ':' in symbol\n                <DED>normalized = norm.get(base, base) + SYMBOL_SEP + norm.get(quote, quote)\n            <DED>ret[normalized.upper()] = symbol\n        <DED>return ret\n    <DED>except ValueError as why:\n        <IND>raise_failure_explanation('BITFINEX', why, {\"tickers?symbols=ALL\": r1, \"pub:map:currency:sym\": r2})\n\n\n<DED><DED>def bitflyer_symbols() -> Dict[str, str]:\n    <IND>endpoint = r = None\n    try:\n        <IND>ret = {}\n        endpoints = ['https://api.bitflyer.com/v1/getmarkets/eu', 'https://api.bitflyer.com/v1/getmarkets/usa', 'https://api.bitflyer.com/v1/getmarkets']\n        for endpoint in endpoints:\n            <IND>r = requests.get(endpoint)\n            for entry in r.json():\n                <IND>normalized = entry['product_code'].replace(\"_\", SYMBOL_SEP)\n                ret[normalized] = entry['product_code']\n        <DED><DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BITFLYER', why, {endpoint: r})\n\n\n<DED><DED>def bybit_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.bybit.com/v2/public/symbols')\n        ret = {}\n        for symbol in r.json()['result']:\n            <IND>quote = symbol['quote_currency']\n            if not symbol['name'].endswith(quote):\n                <IND>base, contract = symbol['name'].split(quote)\n                normalized = f\"{base}{SYMBOL_SEP}{quote}-{contract}\"\n            <DED>else:\n                <IND>normalized = f\"{symbol['base_currency']}{SYMBOL_SEP}{quote}\"\n            <DED>ret[normalized] = symbol['name']\n            _exchange_info[BYBIT]['tick_size'][normalized] = symbol['price_filter']['tick_size']\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BYBIT', why, {\"\": r})\n\n\n<DED><DED>def _ftx_helper(endpoint: str, exchange: str):\n    <IND>r = None\n    try:\n        <IND>r = requests.get(endpoint)\n        ret = {}\n        for data in r.json()['result']:\n            <IND>normalized = data['name'].replace(\"/\", SYMBOL_SEP)\n            symbol = data['name']\n            ret[normalized] = symbol\n            _exchange_info[exchange]['tick_size'][normalized] = data['priceIncrement']\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation(exchange, why, {endpoint: r})\n\n\n<DED><DED>def ftx_symbols() -> Dict[str, str]:\n    <IND>return _ftx_helper('https://ftx.com/api/markets', FTX)\n\n\n<DED>def ftx_us_symbols() -> Dict[str, str]:\n    <IND>return _ftx_helper('https://ftx.us/api/markets', FTX_US)\n\n\n<DED>def coinbase_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.pro.coinbase.com/products')\n        ret = {}\n        for data in r.json():\n            <IND>normalized = data['id'].replace(\"-\", SYMBOL_SEP)\n            ret[normalized] = data['id']\n            _exchange_info[COINBASE]['tick_size'][normalized] = data['quote_increment']\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('COINBASE', why, {\"\": r})\n\n\n<DED><DED>def gemini_symbols(*args) -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.gemini.com/v1/symbols')\n        ret = {}\n        for symbol in r.json():\n            <IND>std = f\"{symbol[:-3]}{SYMBOL_SEP}{symbol[-3:]}\"\n            std = std.upper()\n            ret[std] = symbol.upper()\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('GEMINI', why, {\"\": r})\n\n\n<DED><DED>def hitbtc_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>ret = {}\n        r = requests.get('https://api.hitbtc.com/api/2/public/symbol')\n        for symbol in r.json():\n            <IND>split = len(symbol['baseCurrency'])\n            normalized = symbol['id'][:split] + SYMBOL_SEP + symbol['id'][split:]\n            ret[normalized] = symbol['id']\n            _exchange_info[HITBTC]['tick_size'][normalized] = symbol['tickSize']\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('HITBTC', why, {\"\": r})\n\n\n<DED><DED>def poloniex_id_symbol_mapping():\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://poloniex.com/public?command=returnTicker')\n        symbols = r.json()\n        ret = {}\n        for symbol in symbols:\n            <IND>ret[symbols[symbol]['id']] = symbol\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('POLONIEX', why, {\"\": r})\n\n\n<DED><DED>def poloniex_symbols() -> Dict[str, str]:\n    <IND>ret = {}\n    for _, value in poloniex_id_symbol_mapping().items():\n        <IND>std = value.replace(\"STR\", \"XLM\")\n        quote, base = std.split(\"_\")\n        ret[quote + SYMBOL_SEP + base] = value\n    <DED>return ret\n\n\n<DED>def bitstamp_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://www.bitstamp.net/api/v2/trading-pairs-info/')\n        ret = {}\n        for data in r.json():\n            <IND>normalized = data['name'].replace(\"/\", SYMBOL_SEP)\n            symbol = data['url_symbol']\n            ret[normalized] = symbol\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BITSTAMP', why, {\"\": r})\n\n\n<DED><DED>def kraken_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.kraken.com/0/public/AssetPairs')\n        data = r.json()\n        ret = {}\n        for symbol in data['result']:\n            <IND>if 'wsname' not in data['result'][symbol] or '.d' in symbol:\n                # https://blog.kraken.com/post/259/introducing-the-kraken-dark-pool/\n                # .d is for dark pool symbols\n                <IND>continue\n\n            <DED>base, quote = data['result'][symbol]['wsname'].split(\"/\")\n\n            normalized = f\"{base}{SYMBOL_SEP}{quote}\"\n            exch = data['result'][symbol]['wsname']\n            normalized = normalized.replace('XBT', 'BTC')\n            normalized = normalized.replace('XDG', 'DOG')\n            ret[normalized] = exch\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('KRAKEN', why, {\"\": r})\n\n\n<DED><DED>def kraken_rest_symbols() -> Dict[str, str]:\n    <IND>return {normalized: exchange.replace(\"/\", \"\") for normalized, exchange in kraken_symbols().items()}\n\n\n<DED>def exx_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.exx.com/data/v1/tickers')\n        exchange = [key.upper() for key in r.json().keys()]\n        symbols = [key.replace(\"_\", SYMBOL_SEP) for key in exchange]\n        return dict(zip(symbols, exchange))\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('EXX', why, {\"\": r})\n\n\n<DED><DED>def huobi_common_symbols(url: str):\n    <IND>r = None\n    try:\n        <IND>r = requests.get(url)\n        ret = {}\n        for e in r.json()['data']:\n            <IND>if e['state'] == 'offline':\n                <IND>continue\n            <DED>normalized = f\"{e['base-currency'].upper()}{SYMBOL_SEP}{e['quote-currency'].upper()}\"\n            symbol = f\"{e['base-currency']}{e['quote-currency']}\"\n            ret[normalized] = symbol\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('HUOBI', why, {url: r})\n\n\n<DED><DED>def huobi_symbols() -> Dict[str, str]:\n    <IND>return huobi_common_symbols('https://api.huobi.pro/v1/common/symbols')\n\n\n<DED>def huobi_us_symbols() -> Dict[str, str]:\n    <IND>return huobi_common_symbols('https://api.huobi.com/v1/common/symbols')\n\n\n<DED>def huobi_dm_symbols() -> Dict[str, str]:\n    <IND>\"\"\"\n    Mapping is, for instance: {\"BTC_CW\":\"BTC190816\"}\n    See comments in exchange/huobi_dm.py\n    \"\"\"\n    mapping = {\n        \"this_week\": \"CW\",\n        \"next_week\": \"NW\",\n        \"quarter\": \"CQ\",\n        \"next_quarter\": \"NQ\"\n    }\n    r = None\n    try:\n        <IND>r = requests.get('https://www.hbdm.com/api/v1/contract_contract_info')\n        symbols = {}\n        for e in r.json()['data']:\n            <IND>symbols[f\"{e['symbol']}_{mapping[e['contract_type']]}\"] = e['contract_code']\n            _exchange_info[HUOBI_DM]['tick_size'][e['contract_code']] = e['price_tick']\n            _exchange_info[HUOBI_DM]['short_code_mappings'][f\"{e['symbol']}_{mapping[e['contract_type']]}\"] = e['contract_code']\n        <DED>return symbols\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('HUOBI_DM', why, {\"\": r})\n\n\n<DED><DED>def huobi_swap_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.hbdm.com/swap-api/v1/swap_contract_info')\n        symbols = {}\n        for e in r.json()['data']:\n            <IND>symbols[e['contract_code']] = e['contract_code']\n            _exchange_info[HUOBI_SWAP]['tick_size'][e['contract_code']] = e['price_tick']\n        <DED>return symbols\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('HUOBI_SWAP', why, {\"\": r})\n\n\n<DED><DED>def okcoin_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://www.okcoin.com/api/spot/v3/instruments')\n        ret = {}\n        for e in r.json():\n            <IND>ret[e['instrument_id']] = e['instrument_id']\n            _exchange_info[OKCOIN]['tick_size'][e['instrument_id']] = e['tick_size']\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('OKCOIN', why, {\"\": r})\n\n\n<DED><DED>def okex_symbols(*args) -> Dict[str, str]:\n    <IND>urls = ['https://www.okex.com/api/spot/v3/instruments',\n            'https://www.okex.com/api/swap/v3/instruments',\n            'https://www.okex.com/api/futures/v3/instruments']\n    urls = urls + okex_compute_option_urls_from_underlyings()\n\n    symbols: Dict[str, str] = {}\n    for u in urls:\n        <IND>time.sleep(0.2)\n        symbols.update(okex_symbols_from_one_url(u))\n\n    <DED>for symbol in symbols:\n        <IND>instrument_type = 'futures'\n        dash_count = symbol.count(get_symbol_separator())\n        if dash_count == 1:  # BTC-USDT\n            <IND>instrument_type = 'spot'\n        <DED>if dash_count == 4:  # BTC-USD-201225-35000-P\n            <IND>instrument_type = 'option'\n        <DED>if symbol[-4:] == \"SWAP\":  # BTC-USDT-SWAP\n            <IND>instrument_type = 'swap'\n\n        <DED>_exchange_info[OKEX]['instrument_type'][symbol] = instrument_type\n\n    <DED>return symbols\n\n\n<DED>def okex_compute_option_urls_from_underlyings() -> List[str]:\n    <IND>url = 'https://www.okex.com/api/option/v3/underlying'\n    r = None\n    try:\n        <IND>r = requests.get(url)\n        return [f'https://www.okex.com/api/option/v3/instruments/{underlying}' for underlying in r.json()]\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('OKEX', why, {url: r})\n\n\n<DED><DED>def okex_symbols_from_one_url(url: str) -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get(url)\n        ret = {}\n        for e in r.json():\n            <IND>ret[e['instrument_id']] = e['instrument_id']\n            _exchange_info[OKEX]['tick_size'][e['instrument_id']] = e['tick_size']\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('OKEX', why, {url: r})\n\n\n<DED><DED>def bittrex_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.bittrex.com/api/v1.1/public/getmarkets')\n        r = r.json()['result']\n        return {f\"{e['MarketCurrency']}{SYMBOL_SEP}{e['BaseCurrency']}\": e['MarketName'] for e in r if e['IsActive']}\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BITTREX', why, {\"\": r})\n\n\n<DED><DED>def bitcoincom_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.exchange.bitcoin.com/api/2/public/symbol')\n        return {f\"{data['baseCurrency']}{SYMBOL_SEP}{data['quoteCurrency'].replace('USD', 'USDT')}\": data['id'] for data in r.json()}\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BITCOINCOM', why, {\"\": r})\n\n\n<DED><DED>def bitmax_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://bitmax.io/api/pro/v1/products')\n        ret = {}\n        for entry in r.json()['data']:\n            # Only \"Normal\" status symbols are tradeable\n            <IND>if entry['status'] == 'Normal':\n                <IND>normalized = f\"{entry['baseAsset']}{SYMBOL_SEP}{entry['quoteAsset']}\"\n                ret[normalized] = entry['symbol']\n                _exchange_info[BITMAX]['tick_size'][normalized] = entry['tickSize']\n        <DED><DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BITMAX', why, {\"\": r})\n\n\n<DED><DED>def upbit_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.upbit.com/v1/market/all')\n        return {f\"{data['market'].split('-')[1]}{SYMBOL_SEP}{data['market'].split('-')[0]}\": data['market'] for data in r.json()}\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('UPBIT', why, {\"\": r})\n\n\n<DED><DED>def blockchain_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get(\"https://api.blockchain.com/mercury-gateway/v1/instruments\")\n        return {data[\"symbol\"].replace(\"-\", SYMBOL_SEP): data[\"symbol\"] for data in r.json()}\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BLOCKCHAIN', why, {\"\": r})\n\n\n<DED><DED>def gateio_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get(\"https://api.gateio.ws/api/v4/spot/currency_pairs\")\n        return {data[\"id\"].replace(\"_\", SYMBOL_SEP): data['id'] for data in r.json()}\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('GATEIO', why, {\"\": r})\n\n\n<DED><DED>def bitmex_symbols() -> Dict[str, str]:\n    <IND>r = None\n    ret = {}\n    try:\n        <IND>r = requests.get(\"https://www.bitmex.com/api/v1/instrument/active\")\n        for entry in r.json():\n            <IND>components = []\n            components.append(entry['rootSymbol'])\n            components.append(entry['quoteCurrency'])\n\n            if entry['expiry']:\n                <IND>components.append(entry['symbol'][-3:])\n\n            <DED>normalized = SYMBOL_SEP.join(components)\n            normalized = normalized.replace(\"XBT\", \"BTC\")\n            ret[normalized] = entry['symbol']\n            _exchange_info[BITMEX]['tick_size'][normalized] = entry['tickSize']\n\n            if entry['expiry']:\n                <IND>_exchange_info[BITMEX]['expiry'][normalized] = entry['expiry']\n\n        <DED><DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BITMEX', why, {\"\": r})\n\n\n<DED><DED>def deribit_symbols() -> Dict[str, str]:\n    <IND>url = r = None\n    ret = {}\n    try:\n        # TODO: get currencies from https://www.deribit.com/api/v2/public/get_currencies\n        <IND>currencies = ['BTC', 'ETH']\n        for c in currencies:\n            <IND>url = f\"https://www.deribit.com/api/v2/public/get_instruments?currency={c}&expired=false\"\n            r = requests.get(url)\n            for entry in r.json()['result']:\n                <IND>split = entry['instrument_name'].split(\"-\")\n                normalized = split[0] + SYMBOL_SEP + entry['quote_currency'] + \"-\" + '-'.join(split[1:])\n                ret[normalized] = entry['instrument_name']\n                _exchange_info[DERIBIT]['tick_size'][normalized] = entry['tick_size']\n        <DED><DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('DERIBIT', why, {url: r})\n\n\n<DED><DED>def kraken_future_symbols() -> Dict[str, str]:\n    <IND>r = None\n    ret = {}\n    try:\n        <IND>r = requests.get('https://futures.kraken.com/derivatives/api/v3/instruments')\n        data = r.json()['instruments']\n        for entry in data:\n            <IND>if not entry['tradeable']:\n                <IND>continue\n            <DED>normalized = entry['symbol'].upper().replace(\"_\", \"-\")\n            symbol = normalized[3:6] + SYMBOL_SEP + normalized[6:9]\n            normalized = normalized.replace(normalized[3:9], symbol)\n            normalized = normalized.replace('XBT', 'BTC')\n\n            _exchange_info[KRAKEN_FUTURES]['tick_size'][normalized] = entry['tickSize']\n            _exchange_info[KRAKEN_FUTURES]['contract_size'][normalized] = entry['contractSize']\n            _exchange_info[KRAKEN_FUTURES]['underlying'][normalized] = entry['underlying']\n            _exchange_info[KRAKEN_FUTURES]['product_type'][normalized] = _kraken_futures_product_type[normalized[:2]]\n            ret[normalized] = entry['symbol']\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('KRAKEN_FUTURES', why, {\"\": r})\n\n\n<DED><DED>def probit_symbols() -> Dict[str, str]:\n    # doc: https://docs-en.probit.com/reference-link/market\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.probit.com/api/exchange/v1/market')\n        return {entry['id']: entry['id'] for entry in r.json()['data']}\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('PROBIT', why, {\"\": r})\n\n\n<DED><DED>def coingecko_normalize_symbol(symbol: str) -> str:\n    # keep digits, letters and dots, replace others by space\n    <IND>symbol = ''.join(c if c.isalnum() or c in ('.', '+') else ' ' for c in symbol)\n    return coingecko_normalize(symbol.upper())\n\n\n<DED>def coingecko_normalize_name(name: str) -> str:\n    # keep digits and letters, replace others by space (except when only composed by upper case letters, digits and dots)\n    <IND>if not all(c.isupper() or c.isdigit() or c == '.' for c in name):\n        <IND>name = ''.join(c if c.isalnum() else ' ' for c in name)\n    <DED>return coingecko_normalize(name)\n\n\n<DED>def coingecko_normalize(sym: str) -> str:\n    <IND>sym = sym.strip()\n    # do not concatenate numbers => separate them with a dot\n    sym = list(sym)\n    if len(sym) > 4:\n        <IND>for i in range(2, len(sym) - 1):\n            <IND>if sym[i] == ' ' and sym[i - 1].isdigit() and sym[i + 1].isdigit():\n                <IND>sym[i] = '.'\n    <DED><DED><DED>sym = ''.join(sym)\n    # concatenate space-separated words => use CamelCase to distinguish the words\n    if ' ' in sym:\n        <IND>if sum(c.islower() for c in sym):  # if there is at least one lower case letter\n            <IND>sym = ' '.join(word[0].upper() + word[1:] for word in sym.split())  # Just capitalize initial letter of each word\n        <DED>else:  # CoinGecko may provide full upper-case as for \"THE STONE COIN\"\n            <IND>sym = string.capwords(sym)  # capwords converts \"THE STONE COIN\" to \"The Stone Coin\"\n        <DED>sym = sym.replace(' ', '')  # concatenate words\n    <DED>return sym\n\n\n<DED>def is_name_short(coin: dict) -> bool:\n    <IND>\"\"\"return True if the coin name is enough short compared to the coin symbol.\"\"\"\n    return len(coin['name']) <= max(5, len(coin['symbol']) + 1)\n\n\n<DED>def has_many_caps(name: str) -> bool:\n    <IND>\"\"\"return True if the symbol contains enough upper case letters, False if empty.\"\"\"\n    return str and sum(c.islower() for c in name) < (len(name) / 2)\n\n\n<DED>def coingecko_normalize_all(coin: dict):\n    <IND>SYMBOL_TO_NORMALIZED = {'miota': 'IOTA'}\n    normalized = SYMBOL_TO_NORMALIZED.get(coin['symbol'])\n    if normalized:\n        <IND>coin['ns'] = coin['nn'] = normalized\n        return normalized\n\n    # ns = normalized symbol, nn = normalized name\n    <DED>coin['ns'] = coingecko_normalize_symbol(coin['symbol'])\n\n    ID_SUFFIX = '-bitcoin-token'\n    if coin['id'][-len(ID_SUFFIX):] == ID_SUFFIX:\n        <IND>coin['nn'] = 'BTC' + coin['ns']\n        return coin['nn']\n\n    <DED>name = coin['name']\n\n    prefixes = ('The ', 'the ')\n    for p in prefixes:\n        <IND>if name[:len(p)] == p:\n            <IND>coin['reduced-name'] = True\n            name = name[len(p):]\n            break\n\n    <DED><DED>suffixes = ('coin', 'coins', 'money', 'finance', 'protocol', 'reward', 'rewards', 'token')\n    for s in suffixes:\n        <IND>if len(name) > len(s) and name[-len(s):].lower() == s:\n            # but keep suffix when lower-case concatenated\n            <IND>if name[-len(s)].islower() and name[-len(s) - 1] != ' ':\n                <IND>continue\n            # also keep suffix to avoid confusing nam: \"Bitcoin Token\" -> \"Bitcoin\"\n            <DED>if name[:-len(s)].strip().lower() == 'bitcoin':\n                <IND>continue\n            <DED>coin['reduced-name'] = True\n            name = name[:-len(s)]\n            break\n\n    <DED><DED>coin['nn'] = coingecko_normalize_name(name)\n\n    if len(coin['nn']) < len(coin['ns']):\n        <IND>if 'reduced-name' in coin:\n            <IND>coin['reduced-name'] = False\n            name = coin['name']\n            coin['nn'] = coingecko_normalize_name(name)\n        <DED>elif not has_many_caps(name):\n            <IND>return coin['ns']\n\n    <DED><DED>if not coin['ns']:  # coin['symbol'] may be an emoji that is striped when normalized\n        <IND>return coin['nn']\n\n    <DED>if coin.get('reduced-name') and coin['ns'].upper() != coin['nn'].upper():\n        <IND>return coin['ns']\n\n    <DED>i = coin['nn'].find('.')  # if there is a dot in normalized name => prefer the normalized symbol\n    if i >= 0:\n        <IND>if i > 1 and coin['nn'][i - 1].isdigit() and coin['nn'][i + 1].isdigit():\n            <IND>pass  # except when the dot separates digits\n        <DED>else:\n            <IND>return coin['ns']\n\n    <DED><DED>if is_name_short(coin) and has_many_caps(name):\n        <IND>return coin['nn']\n\n    <DED>if 1.5 * len(coin['ns']) > len(coin['nn']) and any(c.islower() for c in coin['ns']):\n        <IND>return coin['nn']\n\n    <DED>return coin['ns']\n\n\n<DED>def coingecko_symbols() -> Dict[str, str]:\n    <IND>r = None\n    intermediate = defaultdict(list)\n    try:\n        <IND>r = requests.get('https://api.coingecko.com/api/v3/coins/list')\n        all_coins = r.json()\n        # First pass: generate & compare normalized symbol/name, and then select the most pertinent\n        for coin in all_coins:\n            <IND>normalized = coingecko_normalize_all(coin)\n            intermediate[normalized].append(coin)\n            # Above line keeps together the coins having the same normalized symbol.\n            # To reduce collision, the coin['name'] is sometimes used in lieu of the coin['symbol'].\n            # The coin['name'] is not capitalized because lower case letters may be meaningful: cETH, yUSD, DATx, zLOT\n    <DED><DED>except Exception as why:\n        <IND>raise_failure_explanation('COINGECKO', why, {\"\": r})\n\n    <DED>final = coingecko_second_pass(intermediate)\n    return coingecko_third_pass(final)\n\n\n<DED>def coingecko_second_pass(intermediate: Dict[str, List[dict]]) -> Dict[str, List[dict]]:\n    # Second pass: fixes most of the symbol collisions\n    <IND>final = defaultdict(list)\n    for normalized, coins in intermediate.items():\n        <IND>if len(coins) == 1:\n            <IND>final[normalized].append(coins[0])\n            continue\n        <DED>set_normalized = False\n        for i in range(len(coins)):\n            <IND>if normalized == coins[i]['nn']:\n                <IND>coin = coins.pop(i)\n                final[normalized].append(coin)\n                set_normalized = True\n                break\n        <DED><DED>rest: List[dict] = []\n        for coin in coins:\n            <IND>if '%' in coin['name']:\n                <IND>if len(coins) == 1:\n                    <IND>n = coin['ns']\n                <DED>else:\n                    <IND>n = coingecko_normalize_name(coin['id'])\n                <DED>final[n].append(coin)\n            <DED>else:\n                <IND>rest.append(coin)\n        <DED><DED>if not rest:\n            <IND>continue\n        <DED>if not set_normalized:\n            <IND>rest.sort(key=lambda coin: len(coin['nn']), reverse=True)  # sort by the length of the normalized name\n            coin = rest.pop(0)\n            final[normalized].append(coin)\n        <DED>for coin in rest:\n            <IND>if coin['nn'] not in intermediate:\n                <IND>n = coin['nn']\n            <DED>elif coin.get('reduced-name'):\n                <IND>n = coingecko_normalize_name(coin['name'])\n            <DED>else:\n                <IND>n = coingecko_normalize_name(coin['id'])\n            <DED>final[n].append(coin)\n    <DED><DED>return final\n\n\n<DED>def coingecko_third_pass(final: Dict[str, List[dict]]) -> Dict[str, str]:\n    # Third pass: fixes some remaining collisions and fills the result\n    <IND>symbols = {}\n    for normalized, coins in final.items():\n        <IND>if len(coins) == 1:\n            <IND>symbols[normalized] = coins[0]['id']\n            continue\n        <DED>set_normalized = False\n        for i in range(len(coins)):\n            <IND>if normalized == coins[i]['nn']:\n                <IND>coin = coins.pop(i)\n                symbols[normalized] = coin['id']\n                set_normalized = True\n                break\n        <DED><DED>rest: List[dict] = []\n        for coin in coins:\n            <IND>if '%' in coin['name']:\n                <IND>if len(coins) == 1:\n                    <IND>n = coin['ns']\n                <DED>else:\n                    <IND>n = coingecko_normalize_name(coin['id'])\n                <DED>symbols[n] = coin['id']\n            <DED>else:\n                <IND>rest.append(coin)\n        <DED><DED>if not rest:\n            <IND>continue\n        <DED>if not set_normalized:\n            <IND>rest.sort(key=lambda coin: len(coin['nn']), reverse=True)  # sort by the length of the normalized name\n            coin = rest.pop(0)\n            symbols[normalized] = coin['id']\n        <DED>for coin in rest:\n            <IND>if coin['nn'] not in final:\n                <IND>n = coin['nn']\n            <DED>elif coin.get('reduced-name'):\n                <IND>n = coingecko_normalize_name(coin['name'])\n            <DED>else:\n                <IND>n = coingecko_normalize_name(coin['id'])\n            <DED>symbols[n] = coin['id']\n    <DED><DED>return symbols\n\n\n<DED>def whale_alert_coins(key_id: str) -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get(f'https://api.whale-alert.io/v1/status?api_key={key_id}')\n        # Same symbols, but on different blockchains (for instance USDT), are naturally overwritten.\n        return {s.upper(): s for b in r.json()['blockchains'] for s in b['symbols'] if s}\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('WHALES_ALERT', why, {\"\": r})\n\n\n<DED><DED>_exchange_function_map = {\n    BITFINEX: bitfinex_symbols,\n    BITFLYER: bitflyer_symbols,\n    COINBASE: coinbase_symbols,\n    GEMINI: gemini_symbols,\n    HITBTC: hitbtc_symbols,\n    POLONIEX: poloniex_symbols,\n    PROBIT: probit_symbols,\n    BITSTAMP: bitstamp_symbols,\n    KRAKEN: kraken_symbols,\n    KRAKEN + 'REST': kraken_rest_symbols,\n    BINANCE: binance_symbols,\n    BINANCE_US: binance_us_symbols,\n    BINANCE_FUTURES: binance_futures_symbols,\n    BINANCE_DELIVERY: binance_delivery_symbols,\n    BLOCKCHAIN: blockchain_symbols,\n    EXX: exx_symbols,\n    HUOBI: huobi_symbols,\n    HUOBI_DM: huobi_dm_symbols,\n    HUOBI_SWAP: huobi_swap_symbols,\n    OKCOIN: okcoin_symbols,\n    OKEX: okex_symbols,\n    BYBIT: bybit_symbols,\n    FTX: ftx_symbols,\n    FTX_US: ftx_us_symbols,\n    BITTREX: bittrex_symbols,\n    BITCOINCOM: bitcoincom_symbols,\n    BITMAX: bitmax_symbols,\n    UPBIT: upbit_symbols,\n    GATEIO: gateio_symbols,\n    BITMEX: bitmex_symbols,\n    DERIBIT: deribit_symbols,\n    KRAKEN_FUTURES: kraken_future_symbols,\n    COINGECKO: coingecko_symbols,\n    WHALE_ALERT: whale_alert_coins\n}\n",
        "target_code_with_indent": "\nfrom typing import Dict, Tuple\n\n\nclass _Symbols:\n    <IND>def __init__(self):\n        <IND>self.data = {}\n\n    <DED>def set(self, exchange: str, normalized: dict, exchange_info: dict):\n        <IND>self.data[exchange] = {}\n        self.data[exchange]['normalized'] = normalized\n        self.data[exchange]['info'] = exchange_info\n\n    <DED>def get(self, exchange: str) -> Tuple[Dict, Dict]:\n        <IND>return self.data[exchange]['normalized'], self.data[exchange]['info']\n\n    <DED>def populated(self, exchange: str) -> bool:\n        <IND>return exchange in self.data\n\n\n<DED><DED>Symbols = _Symbols()\n"
      }
    ]
  },
  {
    "project": "bmoscon/cryptofeed",
    "commit": "3525dc8ce4d7836a9abaaa5662e58e5e27969a77",
    "filename": "cryptofeed/symbols.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/bmoscon-cryptofeed/cryptofeed/symbols.py",
    "file_hunks_size": 1,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "cryptofeed/symbols.py:554:50 Incompatible parameter type [6]: Expected `Dict[str, Optional[requests.models.Response]]` for 3rd positional only parameter to call `raise_failure_explanation` but got `Dict[None, Optional[requests.models.Response]]`.",
    "message": " Expected `Dict[str, Optional[requests.models.Response]]` for 3rd positional only parameter to call `raise_failure_explanation` but got `Dict[None, Optional[requests.models.Response]]`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 554,
    "warning_line": "        raise_failure_explanation('DERIBIT', why, {url: r})",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "associated with this software.\n\n\nSymbol generation code for exchanges\n'''\n\nimport logging\nimport string\nimport time\nfrom collections import defaultdict\nfrom typing import Dict, List, Optional, Tuple\n\nimport requests\nfrom requests import Response\n\nfrom cryptofeed.defines import *\n\n\nLOG = logging.getLogger('feedhandler')\n\nSYMBOL_SEP = '-'\n\n_symbols_retrieval_cache: Dict[str, Dict[str, str]] = {}\n_exchange_info = defaultdict(lambda: defaultdict(dict))\n\n\n_kraken_futures_product_type = {\n    'FI': 'Inverse Futures',\n    'FV': 'Vanilla Futures',\n    'PI': 'Perpetual Inverse Futures',\n    'PV': 'Perpetual Vanilla Futures',\n    'IN': 'Real Time Index',\n    'RR': 'Reference Rate',\n}\n\n\ndef raise_failure_explanation(feed_id: str, exception: BaseException, responses: Dict[str, Optional[Response]]):\n    LOG.critical('%s: encountered %r while processing response from exchange API', feed_id, exception)\n    if len(responses) > 1:\n        LOG.critical('%s: content of one of the %s responses was unexpected', feed_id, len(responses))\n    for url, r in responses.items():\n        if url:\n            LOG.critical('%s: requested URL: %s', feed_id, url)\n        if r:\n            LOG.critical('%s: unexpected response: %s', feed_id, r.text)\n    raise ValueError(f'Cryptofeed stopped because of an unexpected response from {feed_id}') from exception\n\n\ndef set_symbol_separator(separator: str):\n    global SYMBOL_SEP\n    SYMBOL_SEP = separator\n\n\ndef get_symbol_separator() -> str:\n    global SYMBOL_SEP\n    return SYMBOL_SEP\n\n\ndef gen_symbols(exchange: str, key_id=None) -> Dict[str, str]:\n    if exchange not in _symbols_retrieval_cache:\n        LOG.info(\"%s: Getting list of symbols\", exchange)\n        symbols = _exchange_function_map[exchange](key_id) if key_id else _exchange_function_map[exchange]()\n        LOG.info(\"%s: %s symbols\", exchange, len(symbols))\n\n        # log all retrieved symbols using debug level\n        for normalized, exch_sym in sorted(symbols.items()):\n            LOG.debug('%s: id-from-exch -> normalized: %-35s-> %s', exchange, exch_sym, normalized)\n\n        _symbols_retrieval_cache[exchange] = symbols\n    return _symbols_retrieval_cache[exchange]\n\n\ndef _binance_symbols(endpoint: str, exchange: str):\n    r = None\n    try:\n        ret = {}\n        r = requests.get(endpoint)\n        for symbol in r.json()['symbols']:\n            if symbol.get('status', 'TRADING') != \"TRADING\":\n                continue\n            if symbol.get('contractStatus', 'TRADING') != \"TRADING\":\n                continue\n            split = len(symbol['baseAsset'])\n            normalized = symbol['symbol'][:split] + SYMBOL_SEP + symbol['symbol'][split:]\n            ret[normalized] = symbol['symbol']\n            _exchange_info[exchange]['tick_size'][normalized] = symbol['filters'][0]['tickSize']\n            if \"contractType\" in symbol:\n                _exchange_info[exchange]['contract_type'][normalized] = symbol['contractType']\n        return ret\n    except Exception as why:\n        raise_failure_explanation(exchange, why, {endpoint: r})\n\n\ndef binance_symbols() -> Dict[str, str]:\n    return _binance_symbols('https://api.binance.com/api/v3/exchangeInfo', BINANCE)\n\n\ndef binance_us_symbols() -> Dict[str, str]:\n    return _binance_symbols('https://api.binance.us/api/v3/exchangeInfo', BINANCE_US)\n\n\ndef binance_futures_symbols() -> Dict[str, str]:\n    base = _binance_symbols('https://fapi.binance.com/fapi/v1/exchangeInfo', BINANCE_FUTURES)\n    add = {}\n    for symbol, orig in base.items():\n        if \"_\" in orig:\n            continue\n        add[f\"{symbol}-PINDEX\"] = f\"p{orig}\"\n    base.update(add)\n    return base\n\n\ndef binance_delivery_symbols() -> Dict[str, str]:\n    return _binance_symbols('https://dapi.binance.com/dapi/v1/exchangeInfo', BINANCE_DELIVERY)\n\n\ndef bitfinex_symbols() -> Dict[str, str]:\n    # doc: https://docs.bitfinex.com/docs/ws-general#supported-pairs\n    r1 = r2 = None\n    try:\n        r1 = requests.get('https://api.bitfinex.com/v2/tickers?symbols=ALL')\n        r2 = requests.get('https://api-pub.bitfinex.com/v2/conf/pub:map:currency:sym')\n        tickers: List[List[str]] = r1.json()\n        norm: List[Tuple[str, str]] = r2.json()[0]\n        norm: Dict[str, str] = dict(norm)\n        for k, v in dict(norm).items():\n            if k[-2:] == 'F0' or '-' in v:  # Do not convert BTCF0 -> BTC or PBTCETH -> PBTC-ETH\n                del norm[k]\n        norm['BCHN'] = 'BCH'  # Bitfinex uses BCHN, other exchanges use BCH\n\n        ret = {}\n        for symbol in [t[0] for t in tickers]:\n            if symbol[0] == 'f':\n                normalized = norm.get(symbol[1:], symbol[1:])\n            else:\n                if len(symbol) == 7:\n                    base, quote = symbol[1:4], symbol[4:]\n                else:\n                    base, quote = symbol[1:].split(':')\n                    assert ':' in symbol\n                normalized = norm.get(base, base) + SYMBOL_SEP + norm.get(quote, quote)\n            ret[normalized.upper()] = symbol\n        return ret\n    except ValueError as why:\n        raise_failure_explanation('BITFINEX', why, {\"tickers?symbols=ALL\": r1, \"pub:map:currency:sym\": r2})\n\n\ndef bitflyer_symbols() -> Dict[str, str]:\n    endpoint = r = None\n    try:\n        ret = {}\n        endpoints = ['https://api.bitflyer.com/v1/getmarkets/eu', 'https://api.bitflyer.com/v1/getmarkets/usa', 'https://api.bitflyer.com/v1/getmarkets']\n        for endpoint in endpoints:\n            r = requests.get(endpoint)\n            for entry in r.json():\n                normalized = entry['product_code'].replace(\"_\", SYMBOL_SEP)\n                ret[normalized] = entry['product_code']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('BITFLYER', why, {endpoint: r})\n\n\ndef bybit_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.bybit.com/v2/public/symbols')\n        ret = {}\n        for symbol in r.json()['result']:\n            quote = symbol['quote_currency']\n            if not symbol['name'].endswith(quote):\n                base, contract = symbol['name'].split(quote)\n                normalized = f\"{base}{SYMBOL_SEP}{quote}-{contract}\"\n            else:\n                normalized = f\"{symbol['base_currency']}{SYMBOL_SEP}{quote}\"\n            ret[normalized] = symbol['name']\n            _exchange_info[BYBIT]['tick_size'][normalized] = symbol['price_filter']['tick_size']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('BYBIT', why, {\"\": r})\n\n\ndef _ftx_helper(endpoint: str, exchange: str):\n    r = None\n    try:\n        r = requests.get(endpoint)\n        ret = {}\n        for data in r.json()['result']:\n            normalized = data['name'].replace(\"/\", SYMBOL_SEP)\n            symbol = data['name']\n            ret[normalized] = symbol\n            _exchange_info[exchange]['tick_size'][normalized] = data['priceIncrement']\n        return ret\n    except Exception as why:\n        raise_failure_explanation(exchange, why, {endpoint: r})\n\n\ndef ftx_symbols() -> Dict[str, str]:\n    return _ftx_helper('https://ftx.com/api/markets', FTX)\n\n\ndef ftx_us_symbols() -> Dict[str, str]:\n    return _ftx_helper('https://ftx.us/api/markets', FTX_US)\n\n\ndef coinbase_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.pro.coinbase.com/products')\n        ret = {}\n        for data in r.json():\n            normalized = data['id'].replace(\"-\", SYMBOL_SEP)\n            ret[normalized] = data['id']\n            _exchange_info[COINBASE]['tick_size'][normalized] = data['quote_increment']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('COINBASE', why, {\"\": r})\n\n\ndef gemini_symbols(*args) -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.gemini.com/v1/symbols')\n        ret = {}\n        for symbol in r.json():\n            std = f\"{symbol[:-3]}{SYMBOL_SEP}{symbol[-3:]}\"\n            std = std.upper()\n            ret[std] = symbol.upper()\n        return ret\n    except Exception as why:\n        raise_failure_explanation('GEMINI', why, {\"\": r})\n\n\ndef hitbtc_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        ret = {}\n        r = requests.get('https://api.hitbtc.com/api/2/public/symbol')\n        for symbol in r.json():\n            split = len(symbol['baseCurrency'])\n            normalized = symbol['id'][:split] + SYMBOL_SEP + symbol['id'][split:]\n            ret[normalized] = symbol['id']\n            _exchange_info[HITBTC]['tick_size'][normalized] = symbol['tickSize']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('HITBTC', why, {\"\": r})\n\n\ndef poloniex_id_symbol_mapping():\n    r = None\n    try:\n        r = requests.get('https://poloniex.com/public?command=returnTicker')\n        symbols = r.json()\n        ret = {}\n        for symbol in symbols:\n            ret[symbols[symbol]['id']] = symbol\n        return ret\n    except Exception as why:\n        raise_failure_explanation('POLONIEX', why, {\"\": r})\n\n\ndef poloniex_symbols() -> Dict[str, str]:\n    ret = {}\n    for _, value in poloniex_id_symbol_mapping().items():\n        std = value.replace(\"STR\", \"XLM\")\n        quote, base = std.split(\"_\")\n        ret[quote + SYMBOL_SEP + base] = value\n    return ret\n\n\ndef bitstamp_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://www.bitstamp.net/api/v2/trading-pairs-info/')\n        ret = {}\n        for data in r.json():\n            normalized = data['name'].replace(\"/\", SYMBOL_SEP)\n            symbol = data['url_symbol']\n            ret[normalized] = symbol\n        return ret\n    except Exception as why:\n        raise_failure_explanation('BITSTAMP', why, {\"\": r})\n\n\ndef kraken_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.kraken.com/0/public/AssetPairs')\n        data = r.json()\n        ret = {}\n        for symbol in data['result']:\n            if 'wsname' not in data['result'][symbol] or '.d' in symbol:\n                # https://blog.kraken.com/post/259/introducing-the-kraken-dark-pool/\n                # .d is for dark pool symbols\n                continue\n\n            base, quote = data['result'][symbol]['wsname'].split(\"/\")\n\n            normalized = f\"{base}{SYMBOL_SEP}{quote}\"\n            exch = data['result'][symbol]['wsname']\n            normalized = normalized.replace('XBT', 'BTC')\n            normalized = normalized.replace('XDG', 'DOG')\n            ret[normalized] = exch\n        return ret\n    except Exception as why:\n        raise_failure_explanation('KRAKEN', why, {\"\": r})\n\n\ndef kraken_rest_symbols() -> Dict[str, str]:\n    return {normalized: exchange.replace(\"/\", \"\") for normalized, exchange in kraken_symbols().items()}\n\n\ndef exx_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.exx.com/data/v1/tickers')\n        exchange = [key.upper() for key in r.json().keys()]\n        symbols = [key.replace(\"_\", SYMBOL_SEP) for key in exchange]\n        return dict(zip(symbols, exchange))\n    except Exception as why:\n        raise_failure_explanation('EXX', why, {\"\": r})\n\n\ndef huobi_common_symbols(url: str):\n    r = None\n    try:\n        r = requests.get(url)\n        ret = {}\n        for e in r.json()['data']:\n            if e['state'] == 'offline':\n                continue\n            normalized = f\"{e['base-currency'].upper()}{SYMBOL_SEP}{e['quote-currency'].upper()}\"\n            symbol = f\"{e['base-currency']}{e['quote-currency']}\"\n            ret[normalized] = symbol\n        return ret\n    except Exception as why:\n        raise_failure_explanation('HUOBI', why, {url: r})\n\n\ndef huobi_symbols() -> Dict[str, str]:\n    return huobi_common_symbols('https://api.huobi.pro/v1/common/symbols')\n\n\ndef huobi_us_symbols() -> Dict[str, str]:\n    return huobi_common_symbols('https://api.huobi.com/v1/common/symbols')\n\n\ndef huobi_dm_symbols() -> Dict[str, str]:\n    \"\"\"\n    Mapping is, for instance: {\"BTC_CW\":\"BTC190816\"}\n    See comments in exchange/huobi_dm.py\n    \"\"\"\n    mapping = {\n        \"this_week\": \"CW\",\n        \"next_week\": \"NW\",\n        \"quarter\": \"CQ\",\n        \"next_quarter\": \"NQ\"\n    }\n    r = None\n    try:\n        r = requests.get('https://www.hbdm.com/api/v1/contract_contract_info')\n        symbols = {}\n        for e in r.json()['data']:\n            symbols[f\"{e['symbol']}_{mapping[e['contract_type']]}\"] = e['contract_code']\n            _exchange_info[HUOBI_DM]['tick_size'][e['contract_code']] = e['price_tick']\n            _exchange_info[HUOBI_DM]['short_code_mappings'][f\"{e['symbol']}_{mapping[e['contract_type']]}\"] = e['contract_code']\n        return symbols\n    except Exception as why:\n        raise_failure_explanation('HUOBI_DM', why, {\"\": r})\n\n\ndef huobi_swap_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.hbdm.com/swap-api/v1/swap_contract_info')\n        symbols = {}\n        for e in r.json()['data']:\n            symbols[e['contract_code']] = e['contract_code']\n            _exchange_info[HUOBI_SWAP]['tick_size'][e['contract_code']] = e['price_tick']\n        return symbols\n    except Exception as why:\n        raise_failure_explanation('HUOBI_SWAP', why, {\"\": r})\n\n\ndef okcoin_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://www.okcoin.com/api/spot/v3/instruments')\n        ret = {}\n        for e in r.json():\n            ret[e['instrument_id']] = e['instrument_id']\n            _exchange_info[OKCOIN]['tick_size'][e['instrument_id']] = e['tick_size']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('OKCOIN', why, {\"\": r})\n\n\ndef okex_symbols(*args) -> Dict[str, str]:\n    urls = ['https://www.okex.com/api/spot/v3/instruments',\n            'https://www.okex.com/api/swap/v3/instruments',\n            'https://www.okex.com/api/futures/v3/instruments']\n    urls = urls + okex_compute_option_urls_from_underlyings()\n\n    symbols: Dict[str, str] = {}\n    for u in urls:\n        time.sleep(0.2)\n        symbols.update(okex_symbols_from_one_url(u))\n\n    for symbol in symbols:\n        instrument_type = 'futures'\n        dash_count = symbol.count(get_symbol_separator())\n        if dash_count == 1:  # BTC-USDT\n            instrument_type = 'spot'\n        if dash_count == 4:  # BTC-USD-201225-35000-P\n            instrument_type = 'option'\n        if symbol[-4:] == \"SWAP\":  # BTC-USDT-SWAP\n            instrument_type = 'swap'\n\n        _exchange_info[OKEX]['instrument_type'][symbol] = instrument_type\n\n    return symbols\n\n\ndef okex_compute_option_urls_from_underlyings() -> List[str]:\n    url = 'https://www.okex.com/api/option/v3/underlying'\n    r = None\n    try:\n        r = requests.get(url)\n        return [f'https://www.okex.com/api/option/v3/instruments/{underlying}' for underlying in r.json()]\n    except Exception as why:\n        raise_failure_explanation('OKEX', why, {url: r})\n\n\ndef okex_symbols_from_one_url(url: str) -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get(url)\n        ret = {}\n        for e in r.json():\n            ret[e['instrument_id']] = e['instrument_id']\n            _exchange_info[OKEX]['tick_size'][e['instrument_id']] = e['tick_size']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('OKEX', why, {url: r})\n\n\ndef bittrex_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.bittrex.com/api/v1.1/public/getmarkets')\n        r = r.json()['result']\n        return {f\"{e['MarketCurrency']}{SYMBOL_SEP}{e['BaseCurrency']}\": e['MarketName'] for e in r if e['IsActive']}\n    except Exception as why:\n        raise_failure_explanation('BITTREX', why, {\"\": r})\n\n\ndef bitcoincom_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.exchange.bitcoin.com/api/2/public/symbol')\n        return {f\"{data['baseCurrency']}{SYMBOL_SEP}{data['quoteCurrency'].replace('USD', 'USDT')}\": data['id'] for data in r.json()}\n    except Exception as why:\n        raise_failure_explanation('BITCOINCOM', why, {\"\": r})\n\n\ndef bitmax_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://bitmax.io/api/pro/v1/products')\n        ret = {}\n        for entry in r.json()['data']:\n            # Only \"Normal\" status symbols are tradeable\n            if entry['status'] == 'Normal':\n                normalized = f\"{entry['baseAsset']}{SYMBOL_SEP}{entry['quoteAsset']}\"\n                ret[normalized] = entry['symbol']\n                _exchange_info[BITMAX]['tick_size'][normalized] = entry['tickSize']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('BITMAX', why, {\"\": r})\n\n\ndef upbit_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.upbit.com/v1/market/all')\n        return {f\"{data['market'].split('-')[1]}{SYMBOL_SEP}{data['market'].split('-')[0]}\": data['market'] for data in r.json()}\n    except Exception as why:\n        raise_failure_explanation('UPBIT', why, {\"\": r})\n\n\ndef blockchain_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get(\"https://api.blockchain.com/mercury-gateway/v1/instruments\")\n        return {data[\"symbol\"].replace(\"-\", SYMBOL_SEP): data[\"symbol\"] for data in r.json()}\n    except Exception as why:\n        raise_failure_explanation('BLOCKCHAIN', why, {\"\": r})\n\n\ndef gateio_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get(\"https://api.gateio.ws/api/v4/spot/currency_pairs\")\n        return {data[\"id\"].replace(\"_\", SYMBOL_SEP): data['id'] for data in r.json()}\n    except Exception as why:\n        raise_failure_explanation('GATEIO', why, {\"\": r})\n\n\ndef bitmex_symbols() -> Dict[str, str]:\n    r = None\n    ret = {}\n    try:\n        r = requests.get(\"https://www.bitmex.com/api/v1/instrument/active\")\n        for entry in r.json():\n            components = []\n            components.append(entry['rootSymbol'])\n            components.append(entry['quoteCurrency'])\n\n            if entry['expiry']:\n                components.append(entry['symbol'][-3:])\n\n            normalized = SYMBOL_SEP.join(components)\n            normalized = normalized.replace(\"XBT\", \"BTC\")\n            ret[normalized] = entry['symbol']\n            _exchange_info[BITMEX]['tick_size'][normalized] = entry['tickSize']\n\n            if entry['expiry']:\n                _exchange_info[BITMEX]['expiry'][normalized] = entry['expiry']\n\n        return ret\n    except Exception as why:\n        raise_failure_explanation('BITMEX', why, {\"\": r})\n\n\ndef deribit_symbols() -> Dict[str, str]:\n    url = r = None\n    ret = {}\n    try:\n        # TODO: get currencies from https://www.deribit.com/api/v2/public/get_currencies\n        currencies = ['BTC', 'ETH']\n        for c in currencies:\n            url = f\"https://www.deribit.com/api/v2/public/get_instruments?currency={c}&expired=false\"\n            r = requests.get(url)\n            for entry in r.json()['result']:\n                split = entry['instrument_name'].split(\"-\")\n                normalized = split[0] + SYMBOL_SEP + entry['quote_currency'] + \"-\" + '-'.join(split[1:])\n                ret[normalized] = entry['instrument_name']\n                _exchange_info[DERIBIT]['tick_size'][normalized] = entry['tick_size']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('DERIBIT', why, {url: r})\n\n\ndef kraken_future_symbols() -> Dict[str, str]:\n    r = None\n    ret = {}\n    try:\n        r = requests.get('https://futures.kraken.com/derivatives/api/v3/instruments')\n        data = r.json()['instruments']\n        for entry in data:\n            if not entry['tradeable']:\n                continue\n            normalized = entry['symbol'].upper().replace(\"_\", \"-\")\n            symbol = normalized[3:6] + SYMBOL_SEP + normalized[6:9]\n            normalized = normalized.replace(normalized[3:9], symbol)\n            normalized = normalized.replace('XBT', 'BTC')\n\n            _exchange_info[KRAKEN_FUTURES]['tick_size'][normalized] = entry['tickSize']\n            _exchange_info[KRAKEN_FUTURES]['contract_size'][normalized] = entry['contractSize']\n            _exchange_info[KRAKEN_FUTURES]['underlying'][normalized] = entry['underlying']\n            _exchange_info[KRAKEN_FUTURES]['product_type'][normalized] = _kraken_futures_product_type[normalized[:2]]\n            ret[normalized] = entry['symbol']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('KRAKEN_FUTURES', why, {\"\": r})\n\n\ndef probit_symbols() -> Dict[str, str]:\n    # doc: https://docs-en.probit.com/reference-link/market\n    r = None\n    try:\n        r = requests.get('https://api.probit.com/api/exchange/v1/market')\n        return {entry['id']: entry['id'] for entry in r.json()['data']}\n    except Exception as why:\n        raise_failure_explanation('PROBIT', why, {\"\": r})\n\n\ndef coingecko_normalize_symbol(symbol: str) -> str:\n    # keep digits, letters and dots, replace others by space\n    symbol = ''.join(c if c.isalnum() or c in ('.', '+') else ' ' for c in symbol)\n    return coingecko_normalize(symbol.upper())\n\n\ndef coingecko_normalize_name(name: str) -> str:\n    # keep digits and letters, replace others by space (except when only composed by upper case letters, digits and dots)\n    if not all(c.isupper() or c.isdigit() or c == '.' for c in name):\n        name = ''.join(c if c.isalnum() else ' ' for c in name)\n    return coingecko_normalize(name)\n\n\ndef coingecko_normalize(sym: str) -> str:\n    sym = sym.strip()\n    # do not concatenate numbers => separate them with a dot\n    sym = list(sym)\n    if len(sym) > 4:\n        for i in range(2, len(sym) - 1):\n            if sym[i] == ' ' and sym[i - 1].isdigit() and sym[i + 1].isdigit():\n                sym[i] = '.'\n    sym = ''.join(sym)\n    # concatenate space-separated words => use CamelCase to distinguish the words\n    if ' ' in sym:\n        if sum(c.islower() for c in sym):  # if there is at least one lower case letter\n            sym = ' '.join(word[0].upper() + word[1:] for word in sym.split())  # Just capitalize initial letter of each word\n        else:  # CoinGecko may provide full upper-case as for \"THE STONE COIN\"\n            sym = string.capwords(sym)  # capwords converts \"THE STONE COIN\" to \"The Stone Coin\"\n        sym = sym.replace(' ', '')  # concatenate words\n    return sym\n\n\ndef is_name_short(coin: dict) -> bool:\n    \"\"\"return True if the coin name is enough short compared to the coin symbol.\"\"\"\n    return len(coin['name']) <= max(5, len(coin['symbol']) + 1)\n\n\ndef has_many_caps(name: str) -> bool:\n    \"\"\"return True if the symbol contains enough upper case letters, False if empty.\"\"\"\n    return str and sum(c.islower() for c in name) < (len(name) / 2)\n\n\ndef coingecko_normalize_all(coin: dict):\n    SYMBOL_TO_NORMALIZED = {'miota': 'IOTA'}\n    normalized = SYMBOL_TO_NORMALIZED.get(coin['symbol'])\n    if normalized:\n        coin['ns'] = coin['nn'] = normalized\n        return normalized\n\n    # ns = normalized symbol, nn = normalized name\n    coin['ns'] = coingecko_normalize_symbol(coin['symbol'])\n\n    ID_SUFFIX = '-bitcoin-token'\n    if coin['id'][-len(ID_SUFFIX):] == ID_SUFFIX:\n        coin['nn'] = 'BTC' + coin['ns']\n        return coin['nn']\n\n    name = coin['name']\n\n    prefixes = ('The ', 'the ')\n    for p in prefixes:\n        if name[:len(p)] == p:\n            coin['reduced-name'] = True\n            name = name[len(p):]\n            break\n\n    suffixes = ('coin', 'coins', 'money', 'finance', 'protocol', 'reward', 'rewards', 'token')\n    for s in suffixes:\n        if len(name) > len(s) and name[-len(s):].lower() == s:\n            # but keep suffix when lower-case concatenated\n            if name[-len(s)].islower() and name[-len(s) - 1] != ' ':\n                continue\n            # also keep suffix to avoid confusing nam: \"Bitcoin Token\" -> \"Bitcoin\"\n            if name[:-len(s)].strip().lower() == 'bitcoin':\n                continue\n            coin['reduced-name'] = True\n            name = name[:-len(s)]\n            break\n\n    coin['nn'] = coingecko_normalize_name(name)\n\n    if len(coin['nn']) < len(coin['ns']):\n        if 'reduced-name' in coin:\n            coin['reduced-name'] = False\n            name = coin['name']\n            coin['nn'] = coingecko_normalize_name(name)\n        elif not has_many_caps(name):\n            return coin['ns']\n\n    if not coin['ns']:  # coin['symbol'] may be an emoji that is striped when normalized\n        return coin['nn']\n\n    if coin.get('reduced-name') and coin['ns'].upper() != coin['nn'].upper():\n        return coin['ns']\n\n    i = coin['nn'].find('.')  # if there is a dot in normalized name => prefer the normalized symbol\n    if i >= 0:\n        if i > 1 and coin['nn'][i - 1].isdigit() and coin['nn'][i + 1].isdigit():\n            pass  # except when the dot separates digits\n        else:\n            return coin['ns']\n\n    if is_name_short(coin) and has_many_caps(name):\n        return coin['nn']\n\n    if 1.5 * len(coin['ns']) > len(coin['nn']) and any(c.islower() for c in coin['ns']):\n        return coin['nn']\n\n    return coin['ns']\n\n\ndef coingecko_symbols() -> Dict[str, str]:\n    r = None\n    intermediate = defaultdict(list)\n    try:\n        r = requests.get('https://api.coingecko.com/api/v3/coins/list')\n        all_coins = r.json()\n        # First pass: generate & compare normalized symbol/name, and then select the most pertinent\n        for coin in all_coins:\n            normalized = coingecko_normalize_all(coin)\n            intermediate[normalized].append(coin)\n            # Above line keeps together the coins having the same normalized symbol.\n            # To reduce collision, the coin['name'] is sometimes used in lieu of the coin['symbol'].\n            # The coin['name'] is not capitalized because lower case letters may be meaningful: cETH, yUSD, DATx, zLOT\n    except Exception as why:\n        raise_failure_explanation('COINGECKO', why, {\"\": r})\n\n    final = coingecko_second_pass(intermediate)\n    return coingecko_third_pass(final)\n\n\ndef coingecko_second_pass(intermediate: Dict[str, List[dict]]) -> Dict[str, List[dict]]:\n    # Second pass: fixes most of the symbol collisions\n    final = defaultdict(list)\n    for normalized, coins in intermediate.items():\n        if len(coins) == 1:\n            final[normalized].append(coins[0])\n            continue\n        set_normalized = False\n        for i in range(len(coins)):\n            if normalized == coins[i]['nn']:\n                coin = coins.pop(i)\n                final[normalized].append(coin)\n                set_normalized = True\n                break\n        rest: List[dict] = []\n        for coin in coins:\n            if '%' in coin['name']:\n                if len(coins) == 1:\n                    n = coin['ns']\n                else:\n                    n = coingecko_normalize_name(coin['id'])\n                final[n].append(coin)\n            else:\n                rest.append(coin)\n        if not rest:\n            continue\n        if not set_normalized:\n            rest.sort(key=lambda coin: len(coin['nn']), reverse=True)  # sort by the length of the normalized name\n            coin = rest.pop(0)\n            final[normalized].append(coin)\n        for coin in rest:\n            if coin['nn'] not in intermediate:\n                n = coin['nn']\n            elif coin.get('reduced-name'):\n                n = coingecko_normalize_name(coin['name'])\n            else:\n                n = coingecko_normalize_name(coin['id'])\n            final[n].append(coin)\n    return final\n\n\ndef coingecko_third_pass(final: Dict[str, List[dict]]) -> Dict[str, str]:\n    # Third pass: fixes some remaining collisions and fills the result\n    symbols = {}\n    for normalized, coins in final.items():\n        if len(coins) == 1:\n            symbols[normalized] = coins[0]['id']\n            continue\n        set_normalized = False\n        for i in range(len(coins)):\n            if normalized == coins[i]['nn']:\n                coin = coins.pop(i)\n                symbols[normalized] = coin['id']\n                set_normalized = True\n                break\n        rest: List[dict] = []\n        for coin in coins:\n            if '%' in coin['name']:\n                if len(coins) == 1:\n                    n = coin['ns']\n                else:\n                    n = coingecko_normalize_name(coin['id'])\n                symbols[n] = coin['id']\n            else:\n                rest.append(coin)\n        if not rest:\n            continue\n        if not set_normalized:\n            rest.sort(key=lambda coin: len(coin['nn']), reverse=True)  # sort by the length of the normalized name\n            coin = rest.pop(0)\n            symbols[normalized] = coin['id']\n        for coin in rest:\n            if coin['nn'] not in final:\n                n = coin['nn']\n            elif coin.get('reduced-name'):\n                n = coingecko_normalize_name(coin['name'])\n            else:\n                n = coingecko_normalize_name(coin['id'])\n            symbols[n] = coin['id']\n    return symbols\n\n\ndef whale_alert_coins(key_id: str) -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get(f'https://api.whale-alert.io/v1/status?api_key={key_id}')\n        # Same symbols, but on different blockchains (for instance USDT), are naturally overwritten.\n        return {s.upper(): s for b in r.json()['blockchains'] for s in b['symbols'] if s}\n    except Exception as why:\n        raise_failure_explanation('WHALES_ALERT', why, {\"\": r})\n\n\n_exchange_function_map = {\n    BITFINEX: bitfinex_symbols,\n    BITFLYER: bitflyer_symbols,\n    COINBASE: coinbase_symbols,\n    GEMINI: gemini_symbols,\n    HITBTC: hitbtc_symbols,\n    POLONIEX: poloniex_symbols,\n    PROBIT: probit_symbols,\n    BITSTAMP: bitstamp_symbols,\n    KRAKEN: kraken_symbols,\n    KRAKEN + 'REST': kraken_rest_symbols,\n    BINANCE: binance_symbols,\n    BINANCE_US: binance_us_symbols,\n    BINANCE_FUTURES: binance_futures_symbols,\n    BINANCE_DELIVERY: binance_delivery_symbols,\n    BLOCKCHAIN: blockchain_symbols,\n    EXX: exx_symbols,\n    HUOBI: huobi_symbols,\n    HUOBI_DM: huobi_dm_symbols,\n    HUOBI_SWAP: huobi_swap_symbols,\n    OKCOIN: okcoin_symbols,\n    OKEX: okex_symbols,\n    BYBIT: bybit_symbols,\n    FTX: ftx_symbols,\n    FTX_US: ftx_us_symbols,\n    BITTREX: bittrex_symbols,\n    BITCOINCOM: bitcoincom_symbols,\n    BITMAX: bitmax_symbols,\n    UPBIT: upbit_symbols,\n    GATEIO: gateio_symbols,\n    BITMEX: bitmex_symbols,\n    DERIBIT: deribit_symbols,\n    KRAKEN_FUTURES: kraken_future_symbols,\n    COINGECKO: coingecko_symbols,\n    WHALE_ALERT: whale_alert_coins\n}\n",
        "source_code_len": 30534,
        "target_code": "associated with this software.\n'''\nfrom typing import Dict, Tuple\n\n\nclass _Symbols:\n    def __init__(self):\n        self.data = {}\n\n    def set(self, exchange: str, normalized: dict, exchange_info: dict):\n        self.data[exchange] = {}\n        self.data[exchange]['normalized'] = normalized\n        self.data[exchange]['info'] = exchange_info\n\n    def get(self, exchange: str) -> Tuple[Dict, Dict]:\n        return self.data[exchange]['normalized'], self.data[exchange]['info']\n\n    def populated(self, exchange: str) -> bool:\n        return exchange in self.data\n\n\nSymbols = _Symbols()\n",
        "target_code_len": 588,
        "diff_format": "@@ -5,845 +5,22 @@\n associated with this software.\n+'''\n+from typing import Dict, Tuple\n \n \n-Symbol generation code for exchanges\n-'''\n+class _Symbols:\n+    def __init__(self):\n+        self.data = {}\n \n-import logging\n-import string\n-import time\n-from collections import defaultdict\n-from typing import Dict, List, Optional, Tuple\n+    def set(self, exchange: str, normalized: dict, exchange_info: dict):\n+        self.data[exchange] = {}\n+        self.data[exchange]['normalized'] = normalized\n+        self.data[exchange]['info'] = exchange_info\n \n-import requests\n-from requests import Response\n+    def get(self, exchange: str) -> Tuple[Dict, Dict]:\n+        return self.data[exchange]['normalized'], self.data[exchange]['info']\n \n-from cryptofeed.defines import *\n+    def populated(self, exchange: str) -> bool:\n+        return exchange in self.data\n \n \n-LOG = logging.getLogger('feedhandler')\n-\n-SYMBOL_SEP = '-'\n-\n-_symbols_retrieval_cache: Dict[str, Dict[str, str]] = {}\n-_exchange_info = defaultdict(lambda: defaultdict(dict))\n-\n-\n-_kraken_futures_product_type = {\n-    'FI': 'Inverse Futures',\n-    'FV': 'Vanilla Futures',\n-    'PI': 'Perpetual Inverse Futures',\n-    'PV': 'Perpetual Vanilla Futures',\n-    'IN': 'Real Time Index',\n-    'RR': 'Reference Rate',\n-}\n-\n-\n-def raise_failure_explanation(feed_id: str, exception: BaseException, responses: Dict[str, Optional[Response]]):\n-    LOG.critical('%s: encountered %r while processing response from exchange API', feed_id, exception)\n-    if len(responses) > 1:\n-        LOG.critical('%s: content of one of the %s responses was unexpected', feed_id, len(responses))\n-    for url, r in responses.items():\n-        if url:\n-            LOG.critical('%s: requested URL: %s', feed_id, url)\n-        if r:\n-            LOG.critical('%s: unexpected response: %s', feed_id, r.text)\n-    raise ValueError(f'Cryptofeed stopped because of an unexpected response from {feed_id}') from exception\n-\n-\n-def set_symbol_separator(separator: str):\n-    global SYMBOL_SEP\n-    SYMBOL_SEP = separator\n-\n-\n-def get_symbol_separator() -> str:\n-    global SYMBOL_SEP\n-    return SYMBOL_SEP\n-\n-\n-def gen_symbols(exchange: str, key_id=None) -> Dict[str, str]:\n-    if exchange not in _symbols_retrieval_cache:\n-        LOG.info(\"%s: Getting list of symbols\", exchange)\n-        symbols = _exchange_function_map[exchange](key_id) if key_id else _exchange_function_map[exchange]()\n-        LOG.info(\"%s: %s symbols\", exchange, len(symbols))\n-\n-        # log all retrieved symbols using debug level\n-        for normalized, exch_sym in sorted(symbols.items()):\n-            LOG.debug('%s: id-from-exch -> normalized: %-35s-> %s', exchange, exch_sym, normalized)\n-\n-        _symbols_retrieval_cache[exchange] = symbols\n-    return _symbols_retrieval_cache[exchange]\n-\n-\n-def _binance_symbols(endpoint: str, exchange: str):\n-    r = None\n-    try:\n-        ret = {}\n-        r = requests.get(endpoint)\n-        for symbol in r.json()['symbols']:\n-            if symbol.get('status', 'TRADING') != \"TRADING\":\n-                continue\n-            if symbol.get('contractStatus', 'TRADING') != \"TRADING\":\n-                continue\n-            split = len(symbol['baseAsset'])\n-            normalized = symbol['symbol'][:split] + SYMBOL_SEP + symbol['symbol'][split:]\n-            ret[normalized] = symbol['symbol']\n-            _exchange_info[exchange]['tick_size'][normalized] = symbol['filters'][0]['tickSize']\n-            if \"contractType\" in symbol:\n-                _exchange_info[exchange]['contract_type'][normalized] = symbol['contractType']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation(exchange, why, {endpoint: r})\n-\n-\n-def binance_symbols() -> Dict[str, str]:\n-    return _binance_symbols('https://api.binance.com/api/v3/exchangeInfo', BINANCE)\n-\n-\n-def binance_us_symbols() -> Dict[str, str]:\n-    return _binance_symbols('https://api.binance.us/api/v3/exchangeInfo', BINANCE_US)\n-\n-\n-def binance_futures_symbols() -> Dict[str, str]:\n-    base = _binance_symbols('https://fapi.binance.com/fapi/v1/exchangeInfo', BINANCE_FUTURES)\n-    add = {}\n-    for symbol, orig in base.items():\n-        if \"_\" in orig:\n-            continue\n-        add[f\"{symbol}-PINDEX\"] = f\"p{orig}\"\n-    base.update(add)\n-    return base\n-\n-\n-def binance_delivery_symbols() -> Dict[str, str]:\n-    return _binance_symbols('https://dapi.binance.com/dapi/v1/exchangeInfo', BINANCE_DELIVERY)\n-\n-\n-def bitfinex_symbols() -> Dict[str, str]:\n-    # doc: https://docs.bitfinex.com/docs/ws-general#supported-pairs\n-    r1 = r2 = None\n-    try:\n-        r1 = requests.get('https://api.bitfinex.com/v2/tickers?symbols=ALL')\n-        r2 = requests.get('https://api-pub.bitfinex.com/v2/conf/pub:map:currency:sym')\n-        tickers: List[List[str]] = r1.json()\n-        norm: List[Tuple[str, str]] = r2.json()[0]\n-        norm: Dict[str, str] = dict(norm)\n-        for k, v in dict(norm).items():\n-            if k[-2:] == 'F0' or '-' in v:  # Do not convert BTCF0 -> BTC or PBTCETH -> PBTC-ETH\n-                del norm[k]\n-        norm['BCHN'] = 'BCH'  # Bitfinex uses BCHN, other exchanges use BCH\n-\n-        ret = {}\n-        for symbol in [t[0] for t in tickers]:\n-            if symbol[0] == 'f':\n-                normalized = norm.get(symbol[1:], symbol[1:])\n-            else:\n-                if len(symbol) == 7:\n-                    base, quote = symbol[1:4], symbol[4:]\n-                else:\n-                    base, quote = symbol[1:].split(':')\n-                    assert ':' in symbol\n-                normalized = norm.get(base, base) + SYMBOL_SEP + norm.get(quote, quote)\n-            ret[normalized.upper()] = symbol\n-        return ret\n-    except ValueError as why:\n-        raise_failure_explanation('BITFINEX', why, {\"tickers?symbols=ALL\": r1, \"pub:map:currency:sym\": r2})\n-\n-\n-def bitflyer_symbols() -> Dict[str, str]:\n-    endpoint = r = None\n-    try:\n-        ret = {}\n-        endpoints = ['https://api.bitflyer.com/v1/getmarkets/eu', 'https://api.bitflyer.com/v1/getmarkets/usa', 'https://api.bitflyer.com/v1/getmarkets']\n-        for endpoint in endpoints:\n-            r = requests.get(endpoint)\n-            for entry in r.json():\n-                normalized = entry['product_code'].replace(\"_\", SYMBOL_SEP)\n-                ret[normalized] = entry['product_code']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('BITFLYER', why, {endpoint: r})\n-\n-\n-def bybit_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.bybit.com/v2/public/symbols')\n-        ret = {}\n-        for symbol in r.json()['result']:\n-            quote = symbol['quote_currency']\n-            if not symbol['name'].endswith(quote):\n-                base, contract = symbol['name'].split(quote)\n-                normalized = f\"{base}{SYMBOL_SEP}{quote}-{contract}\"\n-            else:\n-                normalized = f\"{symbol['base_currency']}{SYMBOL_SEP}{quote}\"\n-            ret[normalized] = symbol['name']\n-            _exchange_info[BYBIT]['tick_size'][normalized] = symbol['price_filter']['tick_size']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('BYBIT', why, {\"\": r})\n-\n-\n-def _ftx_helper(endpoint: str, exchange: str):\n-    r = None\n-    try:\n-        r = requests.get(endpoint)\n-        ret = {}\n-        for data in r.json()['result']:\n-            normalized = data['name'].replace(\"/\", SYMBOL_SEP)\n-            symbol = data['name']\n-            ret[normalized] = symbol\n-            _exchange_info[exchange]['tick_size'][normalized] = data['priceIncrement']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation(exchange, why, {endpoint: r})\n-\n-\n-def ftx_symbols() -> Dict[str, str]:\n-    return _ftx_helper('https://ftx.com/api/markets', FTX)\n-\n-\n-def ftx_us_symbols() -> Dict[str, str]:\n-    return _ftx_helper('https://ftx.us/api/markets', FTX_US)\n-\n-\n-def coinbase_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.pro.coinbase.com/products')\n-        ret = {}\n-        for data in r.json():\n-            normalized = data['id'].replace(\"-\", SYMBOL_SEP)\n-            ret[normalized] = data['id']\n-            _exchange_info[COINBASE]['tick_size'][normalized] = data['quote_increment']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('COINBASE', why, {\"\": r})\n-\n-\n-def gemini_symbols(*args) -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.gemini.com/v1/symbols')\n-        ret = {}\n-        for symbol in r.json():\n-            std = f\"{symbol[:-3]}{SYMBOL_SEP}{symbol[-3:]}\"\n-            std = std.upper()\n-            ret[std] = symbol.upper()\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('GEMINI', why, {\"\": r})\n-\n-\n-def hitbtc_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        ret = {}\n-        r = requests.get('https://api.hitbtc.com/api/2/public/symbol')\n-        for symbol in r.json():\n-            split = len(symbol['baseCurrency'])\n-            normalized = symbol['id'][:split] + SYMBOL_SEP + symbol['id'][split:]\n-            ret[normalized] = symbol['id']\n-            _exchange_info[HITBTC]['tick_size'][normalized] = symbol['tickSize']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('HITBTC', why, {\"\": r})\n-\n-\n-def poloniex_id_symbol_mapping():\n-    r = None\n-    try:\n-        r = requests.get('https://poloniex.com/public?command=returnTicker')\n-        symbols = r.json()\n-        ret = {}\n-        for symbol in symbols:\n-            ret[symbols[symbol]['id']] = symbol\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('POLONIEX', why, {\"\": r})\n-\n-\n-def poloniex_symbols() -> Dict[str, str]:\n-    ret = {}\n-    for _, value in poloniex_id_symbol_mapping().items():\n-        std = value.replace(\"STR\", \"XLM\")\n-        quote, base = std.split(\"_\")\n-        ret[quote + SYMBOL_SEP + base] = value\n-    return ret\n-\n-\n-def bitstamp_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://www.bitstamp.net/api/v2/trading-pairs-info/')\n-        ret = {}\n-        for data in r.json():\n-            normalized = data['name'].replace(\"/\", SYMBOL_SEP)\n-            symbol = data['url_symbol']\n-            ret[normalized] = symbol\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('BITSTAMP', why, {\"\": r})\n-\n-\n-def kraken_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.kraken.com/0/public/AssetPairs')\n-        data = r.json()\n-        ret = {}\n-        for symbol in data['result']:\n-            if 'wsname' not in data['result'][symbol] or '.d' in symbol:\n-                # https://blog.kraken.com/post/259/introducing-the-kraken-dark-pool/\n-                # .d is for dark pool symbols\n-                continue\n-\n-            base, quote = data['result'][symbol]['wsname'].split(\"/\")\n-\n-            normalized = f\"{base}{SYMBOL_SEP}{quote}\"\n-            exch = data['result'][symbol]['wsname']\n-            normalized = normalized.replace('XBT', 'BTC')\n-            normalized = normalized.replace('XDG', 'DOG')\n-            ret[normalized] = exch\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('KRAKEN', why, {\"\": r})\n-\n-\n-def kraken_rest_symbols() -> Dict[str, str]:\n-    return {normalized: exchange.replace(\"/\", \"\") for normalized, exchange in kraken_symbols().items()}\n-\n-\n-def exx_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.exx.com/data/v1/tickers')\n-        exchange = [key.upper() for key in r.json().keys()]\n-        symbols = [key.replace(\"_\", SYMBOL_SEP) for key in exchange]\n-        return dict(zip(symbols, exchange))\n-    except Exception as why:\n-        raise_failure_explanation('EXX', why, {\"\": r})\n-\n-\n-def huobi_common_symbols(url: str):\n-    r = None\n-    try:\n-        r = requests.get(url)\n-        ret = {}\n-        for e in r.json()['data']:\n-            if e['state'] == 'offline':\n-                continue\n-            normalized = f\"{e['base-currency'].upper()}{SYMBOL_SEP}{e['quote-currency'].upper()}\"\n-            symbol = f\"{e['base-currency']}{e['quote-currency']}\"\n-            ret[normalized] = symbol\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('HUOBI', why, {url: r})\n-\n-\n-def huobi_symbols() -> Dict[str, str]:\n-    return huobi_common_symbols('https://api.huobi.pro/v1/common/symbols')\n-\n-\n-def huobi_us_symbols() -> Dict[str, str]:\n-    return huobi_common_symbols('https://api.huobi.com/v1/common/symbols')\n-\n-\n-def huobi_dm_symbols() -> Dict[str, str]:\n-    \"\"\"\n-    Mapping is, for instance: {\"BTC_CW\":\"BTC190816\"}\n-    See comments in exchange/huobi_dm.py\n-    \"\"\"\n-    mapping = {\n-        \"this_week\": \"CW\",\n-        \"next_week\": \"NW\",\n-        \"quarter\": \"CQ\",\n-        \"next_quarter\": \"NQ\"\n-    }\n-    r = None\n-    try:\n-        r = requests.get('https://www.hbdm.com/api/v1/contract_contract_info')\n-        symbols = {}\n-        for e in r.json()['data']:\n-            symbols[f\"{e['symbol']}_{mapping[e['contract_type']]}\"] = e['contract_code']\n-            _exchange_info[HUOBI_DM]['tick_size'][e['contract_code']] = e['price_tick']\n-            _exchange_info[HUOBI_DM]['short_code_mappings'][f\"{e['symbol']}_{mapping[e['contract_type']]}\"] = e['contract_code']\n-        return symbols\n-    except Exception as why:\n-        raise_failure_explanation('HUOBI_DM', why, {\"\": r})\n-\n-\n-def huobi_swap_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.hbdm.com/swap-api/v1/swap_contract_info')\n-        symbols = {}\n-        for e in r.json()['data']:\n-            symbols[e['contract_code']] = e['contract_code']\n-            _exchange_info[HUOBI_SWAP]['tick_size'][e['contract_code']] = e['price_tick']\n-        return symbols\n-    except Exception as why:\n-        raise_failure_explanation('HUOBI_SWAP', why, {\"\": r})\n-\n-\n-def okcoin_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://www.okcoin.com/api/spot/v3/instruments')\n-        ret = {}\n-        for e in r.json():\n-            ret[e['instrument_id']] = e['instrument_id']\n-            _exchange_info[OKCOIN]['tick_size'][e['instrument_id']] = e['tick_size']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('OKCOIN', why, {\"\": r})\n-\n-\n-def okex_symbols(*args) -> Dict[str, str]:\n-    urls = ['https://www.okex.com/api/spot/v3/instruments',\n-            'https://www.okex.com/api/swap/v3/instruments',\n-            'https://www.okex.com/api/futures/v3/instruments']\n-    urls = urls + okex_compute_option_urls_from_underlyings()\n-\n-    symbols: Dict[str, str] = {}\n-    for u in urls:\n-        time.sleep(0.2)\n-        symbols.update(okex_symbols_from_one_url(u))\n-\n-    for symbol in symbols:\n-        instrument_type = 'futures'\n-        dash_count = symbol.count(get_symbol_separator())\n-        if dash_count == 1:  # BTC-USDT\n-            instrument_type = 'spot'\n-        if dash_count == 4:  # BTC-USD-201225-35000-P\n-            instrument_type = 'option'\n-        if symbol[-4:] == \"SWAP\":  # BTC-USDT-SWAP\n-            instrument_type = 'swap'\n-\n-        _exchange_info[OKEX]['instrument_type'][symbol] = instrument_type\n-\n-    return symbols\n-\n-\n-def okex_compute_option_urls_from_underlyings() -> List[str]:\n-    url = 'https://www.okex.com/api/option/v3/underlying'\n-    r = None\n-    try:\n-        r = requests.get(url)\n-        return [f'https://www.okex.com/api/option/v3/instruments/{underlying}' for underlying in r.json()]\n-    except Exception as why:\n-        raise_failure_explanation('OKEX', why, {url: r})\n-\n-\n-def okex_symbols_from_one_url(url: str) -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get(url)\n-        ret = {}\n-        for e in r.json():\n-            ret[e['instrument_id']] = e['instrument_id']\n-            _exchange_info[OKEX]['tick_size'][e['instrument_id']] = e['tick_size']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('OKEX', why, {url: r})\n-\n-\n-def bittrex_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.bittrex.com/api/v1.1/public/getmarkets')\n-        r = r.json()['result']\n-        return {f\"{e['MarketCurrency']}{SYMBOL_SEP}{e['BaseCurrency']}\": e['MarketName'] for e in r if e['IsActive']}\n-    except Exception as why:\n-        raise_failure_explanation('BITTREX', why, {\"\": r})\n-\n-\n-def bitcoincom_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.exchange.bitcoin.com/api/2/public/symbol')\n-        return {f\"{data['baseCurrency']}{SYMBOL_SEP}{data['quoteCurrency'].replace('USD', 'USDT')}\": data['id'] for data in r.json()}\n-    except Exception as why:\n-        raise_failure_explanation('BITCOINCOM', why, {\"\": r})\n-\n-\n-def bitmax_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://bitmax.io/api/pro/v1/products')\n-        ret = {}\n-        for entry in r.json()['data']:\n-            # Only \"Normal\" status symbols are tradeable\n-            if entry['status'] == 'Normal':\n-                normalized = f\"{entry['baseAsset']}{SYMBOL_SEP}{entry['quoteAsset']}\"\n-                ret[normalized] = entry['symbol']\n-                _exchange_info[BITMAX]['tick_size'][normalized] = entry['tickSize']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('BITMAX', why, {\"\": r})\n-\n-\n-def upbit_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.upbit.com/v1/market/all')\n-        return {f\"{data['market'].split('-')[1]}{SYMBOL_SEP}{data['market'].split('-')[0]}\": data['market'] for data in r.json()}\n-    except Exception as why:\n-        raise_failure_explanation('UPBIT', why, {\"\": r})\n-\n-\n-def blockchain_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get(\"https://api.blockchain.com/mercury-gateway/v1/instruments\")\n-        return {data[\"symbol\"].replace(\"-\", SYMBOL_SEP): data[\"symbol\"] for data in r.json()}\n-    except Exception as why:\n-        raise_failure_explanation('BLOCKCHAIN', why, {\"\": r})\n-\n-\n-def gateio_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get(\"https://api.gateio.ws/api/v4/spot/currency_pairs\")\n-        return {data[\"id\"].replace(\"_\", SYMBOL_SEP): data['id'] for data in r.json()}\n-    except Exception as why:\n-        raise_failure_explanation('GATEIO', why, {\"\": r})\n-\n-\n-def bitmex_symbols() -> Dict[str, str]:\n-    r = None\n-    ret = {}\n-    try:\n-        r = requests.get(\"https://www.bitmex.com/api/v1/instrument/active\")\n-        for entry in r.json():\n-            components = []\n-            components.append(entry['rootSymbol'])\n-            components.append(entry['quoteCurrency'])\n-\n-            if entry['expiry']:\n-                components.append(entry['symbol'][-3:])\n-\n-            normalized = SYMBOL_SEP.join(components)\n-            normalized = normalized.replace(\"XBT\", \"BTC\")\n-            ret[normalized] = entry['symbol']\n-            _exchange_info[BITMEX]['tick_size'][normalized] = entry['tickSize']\n-\n-            if entry['expiry']:\n-                _exchange_info[BITMEX]['expiry'][normalized] = entry['expiry']\n-\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('BITMEX', why, {\"\": r})\n-\n-\n-def deribit_symbols() -> Dict[str, str]:\n-    url = r = None\n-    ret = {}\n-    try:\n-        # TODO: get currencies from https://www.deribit.com/api/v2/public/get_currencies\n-        currencies = ['BTC', 'ETH']\n-        for c in currencies:\n-            url = f\"https://www.deribit.com/api/v2/public/get_instruments?currency={c}&expired=false\"\n-            r = requests.get(url)\n-            for entry in r.json()['result']:\n-                split = entry['instrument_name'].split(\"-\")\n-                normalized = split[0] + SYMBOL_SEP + entry['quote_currency'] + \"-\" + '-'.join(split[1:])\n-                ret[normalized] = entry['instrument_name']\n-                _exchange_info[DERIBIT]['tick_size'][normalized] = entry['tick_size']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('DERIBIT', why, {url: r})\n-\n-\n-def kraken_future_symbols() -> Dict[str, str]:\n-    r = None\n-    ret = {}\n-    try:\n-        r = requests.get('https://futures.kraken.com/derivatives/api/v3/instruments')\n-        data = r.json()['instruments']\n-        for entry in data:\n-            if not entry['tradeable']:\n-                continue\n-            normalized = entry['symbol'].upper().replace(\"_\", \"-\")\n-            symbol = normalized[3:6] + SYMBOL_SEP + normalized[6:9]\n-            normalized = normalized.replace(normalized[3:9], symbol)\n-            normalized = normalized.replace('XBT', 'BTC')\n-\n-            _exchange_info[KRAKEN_FUTURES]['tick_size'][normalized] = entry['tickSize']\n-            _exchange_info[KRAKEN_FUTURES]['contract_size'][normalized] = entry['contractSize']\n-            _exchange_info[KRAKEN_FUTURES]['underlying'][normalized] = entry['underlying']\n-            _exchange_info[KRAKEN_FUTURES]['product_type'][normalized] = _kraken_futures_product_type[normalized[:2]]\n-            ret[normalized] = entry['symbol']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('KRAKEN_FUTURES', why, {\"\": r})\n-\n-\n-def probit_symbols() -> Dict[str, str]:\n-    # doc: https://docs-en.probit.com/reference-link/market\n-    r = None\n-    try:\n-        r = requests.get('https://api.probit.com/api/exchange/v1/market')\n-        return {entry['id']: entry['id'] for entry in r.json()['data']}\n-    except Exception as why:\n-        raise_failure_explanation('PROBIT', why, {\"\": r})\n-\n-\n-def coingecko_normalize_symbol(symbol: str) -> str:\n-    # keep digits, letters and dots, replace others by space\n-    symbol = ''.join(c if c.isalnum() or c in ('.', '+') else ' ' for c in symbol)\n-    return coingecko_normalize(symbol.upper())\n-\n-\n-def coingecko_normalize_name(name: str) -> str:\n-    # keep digits and letters, replace others by space (except when only composed by upper case letters, digits and dots)\n-    if not all(c.isupper() or c.isdigit() or c == '.' for c in name):\n-        name = ''.join(c if c.isalnum() else ' ' for c in name)\n-    return coingecko_normalize(name)\n-\n-\n-def coingecko_normalize(sym: str) -> str:\n-    sym = sym.strip()\n-    # do not concatenate numbers => separate them with a dot\n-    sym = list(sym)\n-    if len(sym) > 4:\n-        for i in range(2, len(sym) - 1):\n-            if sym[i] == ' ' and sym[i - 1].isdigit() and sym[i + 1].isdigit():\n-                sym[i] = '.'\n-    sym = ''.join(sym)\n-    # concatenate space-separated words => use CamelCase to distinguish the words\n-    if ' ' in sym:\n-        if sum(c.islower() for c in sym):  # if there is at least one lower case letter\n-            sym = ' '.join(word[0].upper() + word[1:] for word in sym.split())  # Just capitalize initial letter of each word\n-        else:  # CoinGecko may provide full upper-case as for \"THE STONE COIN\"\n-            sym = string.capwords(sym)  # capwords converts \"THE STONE COIN\" to \"The Stone Coin\"\n-        sym = sym.replace(' ', '')  # concatenate words\n-    return sym\n-\n-\n-def is_name_short(coin: dict) -> bool:\n-    \"\"\"return True if the coin name is enough short compared to the coin symbol.\"\"\"\n-    return len(coin['name']) <= max(5, len(coin['symbol']) + 1)\n-\n-\n-def has_many_caps(name: str) -> bool:\n-    \"\"\"return True if the symbol contains enough upper case letters, False if empty.\"\"\"\n-    return str and sum(c.islower() for c in name) < (len(name) / 2)\n-\n-\n-def coingecko_normalize_all(coin: dict):\n-    SYMBOL_TO_NORMALIZED = {'miota': 'IOTA'}\n-    normalized = SYMBOL_TO_NORMALIZED.get(coin['symbol'])\n-    if normalized:\n-        coin['ns'] = coin['nn'] = normalized\n-        return normalized\n-\n-    # ns = normalized symbol, nn = normalized name\n-    coin['ns'] = coingecko_normalize_symbol(coin['symbol'])\n-\n-    ID_SUFFIX = '-bitcoin-token'\n-    if coin['id'][-len(ID_SUFFIX):] == ID_SUFFIX:\n-        coin['nn'] = 'BTC' + coin['ns']\n-        return coin['nn']\n-\n-    name = coin['name']\n-\n-    prefixes = ('The ', 'the ')\n-    for p in prefixes:\n-        if name[:len(p)] == p:\n-            coin['reduced-name'] = True\n-            name = name[len(p):]\n-            break\n-\n-    suffixes = ('coin', 'coins', 'money', 'finance', 'protocol', 'reward', 'rewards', 'token')\n-    for s in suffixes:\n-        if len(name) > len(s) and name[-len(s):].lower() == s:\n-            # but keep suffix when lower-case concatenated\n-            if name[-len(s)].islower() and name[-len(s) - 1] != ' ':\n-                continue\n-            # also keep suffix to avoid confusing nam: \"Bitcoin Token\" -> \"Bitcoin\"\n-            if name[:-len(s)].strip().lower() == 'bitcoin':\n-                continue\n-            coin['reduced-name'] = True\n-            name = name[:-len(s)]\n-            break\n-\n-    coin['nn'] = coingecko_normalize_name(name)\n-\n-    if len(coin['nn']) < len(coin['ns']):\n-        if 'reduced-name' in coin:\n-            coin['reduced-name'] = False\n-            name = coin['name']\n-            coin['nn'] = coingecko_normalize_name(name)\n-        elif not has_many_caps(name):\n-            return coin['ns']\n-\n-    if not coin['ns']:  # coin['symbol'] may be an emoji that is striped when normalized\n-        return coin['nn']\n-\n-    if coin.get('reduced-name') and coin['ns'].upper() != coin['nn'].upper():\n-        return coin['ns']\n-\n-    i = coin['nn'].find('.')  # if there is a dot in normalized name => prefer the normalized symbol\n-    if i >= 0:\n-        if i > 1 and coin['nn'][i - 1].isdigit() and coin['nn'][i + 1].isdigit():\n-            pass  # except when the dot separates digits\n-        else:\n-            return coin['ns']\n-\n-    if is_name_short(coin) and has_many_caps(name):\n-        return coin['nn']\n-\n-    if 1.5 * len(coin['ns']) > len(coin['nn']) and any(c.islower() for c in coin['ns']):\n-        return coin['nn']\n-\n-    return coin['ns']\n-\n-\n-def coingecko_symbols() -> Dict[str, str]:\n-    r = None\n-    intermediate = defaultdict(list)\n-    try:\n-        r = requests.get('https://api.coingecko.com/api/v3/coins/list')\n-        all_coins = r.json()\n-        # First pass: generate & compare normalized symbol/name, and then select the most pertinent\n-        for coin in all_coins:\n-            normalized = coingecko_normalize_all(coin)\n-            intermediate[normalized].append(coin)\n-            # Above line keeps together the coins having the same normalized symbol.\n-            # To reduce collision, the coin['name'] is sometimes used in lieu of the coin['symbol'].\n-            # The coin['name'] is not capitalized because lower case letters may be meaningful: cETH, yUSD, DATx, zLOT\n-    except Exception as why:\n-        raise_failure_explanation('COINGECKO', why, {\"\": r})\n-\n-    final = coingecko_second_pass(intermediate)\n-    return coingecko_third_pass(final)\n-\n-\n-def coingecko_second_pass(intermediate: Dict[str, List[dict]]) -> Dict[str, List[dict]]:\n-    # Second pass: fixes most of the symbol collisions\n-    final = defaultdict(list)\n-    for normalized, coins in intermediate.items():\n-        if len(coins) == 1:\n-            final[normalized].append(coins[0])\n-            continue\n-        set_normalized = False\n-        for i in range(len(coins)):\n-            if normalized == coins[i]['nn']:\n-                coin = coins.pop(i)\n-                final[normalized].append(coin)\n-                set_normalized = True\n-                break\n-        rest: List[dict] = []\n-        for coin in coins:\n-            if '%' in coin['name']:\n-                if len(coins) == 1:\n-                    n = coin['ns']\n-                else:\n-                    n = coingecko_normalize_name(coin['id'])\n-                final[n].append(coin)\n-            else:\n-                rest.append(coin)\n-        if not rest:\n-            continue\n-        if not set_normalized:\n-            rest.sort(key=lambda coin: len(coin['nn']), reverse=True)  # sort by the length of the normalized name\n-            coin = rest.pop(0)\n-            final[normalized].append(coin)\n-        for coin in rest:\n-            if coin['nn'] not in intermediate:\n-                n = coin['nn']\n-            elif coin.get('reduced-name'):\n-                n = coingecko_normalize_name(coin['name'])\n-            else:\n-                n = coingecko_normalize_name(coin['id'])\n-            final[n].append(coin)\n-    return final\n-\n-\n-def coingecko_third_pass(final: Dict[str, List[dict]]) -> Dict[str, str]:\n-    # Third pass: fixes some remaining collisions and fills the result\n-    symbols = {}\n-    for normalized, coins in final.items():\n-        if len(coins) == 1:\n-            symbols[normalized] = coins[0]['id']\n-            continue\n-        set_normalized = False\n-        for i in range(len(coins)):\n-            if normalized == coins[i]['nn']:\n-                coin = coins.pop(i)\n-                symbols[normalized] = coin['id']\n-                set_normalized = True\n-                break\n-        rest: List[dict] = []\n-        for coin in coins:\n-            if '%' in coin['name']:\n-                if len(coins) == 1:\n-                    n = coin['ns']\n-                else:\n-                    n = coingecko_normalize_name(coin['id'])\n-                symbols[n] = coin['id']\n-            else:\n-                rest.append(coin)\n-        if not rest:\n-            continue\n-        if not set_normalized:\n-            rest.sort(key=lambda coin: len(coin['nn']), reverse=True)  # sort by the length of the normalized name\n-            coin = rest.pop(0)\n-            symbols[normalized] = coin['id']\n-        for coin in rest:\n-            if coin['nn'] not in final:\n-                n = coin['nn']\n-            elif coin.get('reduced-name'):\n-                n = coingecko_normalize_name(coin['name'])\n-            else:\n-                n = coingecko_normalize_name(coin['id'])\n-            symbols[n] = coin['id']\n-    return symbols\n-\n-\n-def whale_alert_coins(key_id: str) -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get(f'https://api.whale-alert.io/v1/status?api_key={key_id}')\n-        # Same symbols, but on different blockchains (for instance USDT), are naturally overwritten.\n-        return {s.upper(): s for b in r.json()['blockchains'] for s in b['symbols'] if s}\n-    except Exception as why:\n-        raise_failure_explanation('WHALES_ALERT', why, {\"\": r})\n-\n-\n-_exchange_function_map = {\n-    BITFINEX: bitfinex_symbols,\n-    BITFLYER: bitflyer_symbols,\n-    COINBASE: coinbase_symbols,\n-    GEMINI: gemini_symbols,\n-    HITBTC: hitbtc_symbols,\n-    POLONIEX: poloniex_symbols,\n-    PROBIT: probit_symbols,\n-    BITSTAMP: bitstamp_symbols,\n-    KRAKEN: kraken_symbols,\n-    KRAKEN + 'REST': kraken_rest_symbols,\n-    BINANCE: binance_symbols,\n-    BINANCE_US: binance_us_symbols,\n-    BINANCE_FUTURES: binance_futures_symbols,\n-    BINANCE_DELIVERY: binance_delivery_symbols,\n-    BLOCKCHAIN: blockchain_symbols,\n-    EXX: exx_symbols,\n-    HUOBI: huobi_symbols,\n-    HUOBI_DM: huobi_dm_symbols,\n-    HUOBI_SWAP: huobi_swap_symbols,\n-    OKCOIN: okcoin_symbols,\n-    OKEX: okex_symbols,\n-    BYBIT: bybit_symbols,\n-    FTX: ftx_symbols,\n-    FTX_US: ftx_us_symbols,\n-    BITTREX: bittrex_symbols,\n-    BITCOINCOM: bitcoincom_symbols,\n-    BITMAX: bitmax_symbols,\n-    UPBIT: upbit_symbols,\n-    GATEIO: gateio_symbols,\n-    BITMEX: bitmex_symbols,\n-    DERIBIT: deribit_symbols,\n-    KRAKEN_FUTURES: kraken_future_symbols,\n-    COINGECKO: coingecko_symbols,\n-    WHALE_ALERT: whale_alert_coins\n-}\n+Symbols = _Symbols()\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\n\nimport logging\nimport string\nimport time\nfrom collections import defaultdict\nfrom typing import Dict, List, Optional, Tuple\n\nimport requests\nfrom requests import Response\n\nfrom cryptofeed.defines import *\n\n\nLOG = logging.getLogger('feedhandler')\n\nSYMBOL_SEP = '-'\n\n_symbols_retrieval_cache: Dict[str, Dict[str, str]] = {}\n_exchange_info = defaultdict(lambda: defaultdict(dict))\n\n\n_kraken_futures_product_type = {\n    'FI': 'Inverse Futures',\n    'FV': 'Vanilla Futures',\n    'PI': 'Perpetual Inverse Futures',\n    'PV': 'Perpetual Vanilla Futures',\n    'IN': 'Real Time Index',\n    'RR': 'Reference Rate',\n}\n\n\ndef raise_failure_explanation(feed_id: str, exception: BaseException, responses: Dict[str, Optional[Response]]):\n    <IND>LOG.critical('%s: encountered %r while processing response from exchange API', feed_id, exception)\n    if len(responses) > 1:\n        <IND>LOG.critical('%s: content of one of the %s responses was unexpected', feed_id, len(responses))\n    <DED>for url, r in responses.items():\n        <IND>if url:\n            <IND>LOG.critical('%s: requested URL: %s', feed_id, url)\n        <DED>if r:\n            <IND>LOG.critical('%s: unexpected response: %s', feed_id, r.text)\n    <DED><DED>raise ValueError(f'Cryptofeed stopped because of an unexpected response from {feed_id}') from exception\n\n\n<DED>def set_symbol_separator(separator: str):\n    <IND>global SYMBOL_SEP\n    SYMBOL_SEP = separator\n\n\n<DED>def get_symbol_separator() -> str:\n    <IND>global SYMBOL_SEP\n    return SYMBOL_SEP\n\n\n<DED>def gen_symbols(exchange: str, key_id=None) -> Dict[str, str]:\n    <IND>if exchange not in _symbols_retrieval_cache:\n        <IND>LOG.info(\"%s: Getting list of symbols\", exchange)\n        symbols = _exchange_function_map[exchange](key_id) if key_id else _exchange_function_map[exchange]()\n        LOG.info(\"%s: %s symbols\", exchange, len(symbols))\n\n        # log all retrieved symbols using debug level\n        for normalized, exch_sym in sorted(symbols.items()):\n            <IND>LOG.debug('%s: id-from-exch -> normalized: %-35s-> %s', exchange, exch_sym, normalized)\n\n        <DED>_symbols_retrieval_cache[exchange] = symbols\n    <DED>return _symbols_retrieval_cache[exchange]\n\n\n<DED>def _binance_symbols(endpoint: str, exchange: str):\n    <IND>r = None\n    try:\n        <IND>ret = {}\n        r = requests.get(endpoint)\n        for symbol in r.json()['symbols']:\n            <IND>if symbol.get('status', 'TRADING') != \"TRADING\":\n                <IND>continue\n            <DED>if symbol.get('contractStatus', 'TRADING') != \"TRADING\":\n                <IND>continue\n            <DED>split = len(symbol['baseAsset'])\n            normalized = symbol['symbol'][:split] + SYMBOL_SEP + symbol['symbol'][split:]\n            ret[normalized] = symbol['symbol']\n            _exchange_info[exchange]['tick_size'][normalized] = symbol['filters'][0]['tickSize']\n            if \"contractType\" in symbol:\n                <IND>_exchange_info[exchange]['contract_type'][normalized] = symbol['contractType']\n        <DED><DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation(exchange, why, {endpoint: r})\n\n\n<DED><DED>def binance_symbols() -> Dict[str, str]:\n    <IND>return _binance_symbols('https://api.binance.com/api/v3/exchangeInfo', BINANCE)\n\n\n<DED>def binance_us_symbols() -> Dict[str, str]:\n    <IND>return _binance_symbols('https://api.binance.us/api/v3/exchangeInfo', BINANCE_US)\n\n\n<DED>def binance_futures_symbols() -> Dict[str, str]:\n    <IND>base = _binance_symbols('https://fapi.binance.com/fapi/v1/exchangeInfo', BINANCE_FUTURES)\n    add = {}\n    for symbol, orig in base.items():\n        <IND>if \"_\" in orig:\n            <IND>continue\n        <DED>add[f\"{symbol}-PINDEX\"] = f\"p{orig}\"\n    <DED>base.update(add)\n    return base\n\n\n<DED>def binance_delivery_symbols() -> Dict[str, str]:\n    <IND>return _binance_symbols('https://dapi.binance.com/dapi/v1/exchangeInfo', BINANCE_DELIVERY)\n\n\n<DED>def bitfinex_symbols() -> Dict[str, str]:\n    # doc: https://docs.bitfinex.com/docs/ws-general#supported-pairs\n    <IND>r1 = r2 = None\n    try:\n        <IND>r1 = requests.get('https://api.bitfinex.com/v2/tickers?symbols=ALL')\n        r2 = requests.get('https://api-pub.bitfinex.com/v2/conf/pub:map:currency:sym')\n        tickers: List[List[str]] = r1.json()\n        norm: List[Tuple[str, str]] = r2.json()[0]\n        norm: Dict[str, str] = dict(norm)\n        for k, v in dict(norm).items():\n            <IND>if k[-2:] == 'F0' or '-' in v:  # Do not convert BTCF0 -> BTC or PBTCETH -> PBTC-ETH\n                <IND>del norm[k]\n        <DED><DED>norm['BCHN'] = 'BCH'  # Bitfinex uses BCHN, other exchanges use BCH\n\n        ret = {}\n        for symbol in [t[0] for t in tickers]:\n            <IND>if symbol[0] == 'f':\n                <IND>normalized = norm.get(symbol[1:], symbol[1:])\n            <DED>else:\n                <IND>if len(symbol) == 7:\n                    <IND>base, quote = symbol[1:4], symbol[4:]\n                <DED>else:\n                    <IND>base, quote = symbol[1:].split(':')\n                    assert ':' in symbol\n                <DED>normalized = norm.get(base, base) + SYMBOL_SEP + norm.get(quote, quote)\n            <DED>ret[normalized.upper()] = symbol\n        <DED>return ret\n    <DED>except ValueError as why:\n        <IND>raise_failure_explanation('BITFINEX', why, {\"tickers?symbols=ALL\": r1, \"pub:map:currency:sym\": r2})\n\n\n<DED><DED>def bitflyer_symbols() -> Dict[str, str]:\n    <IND>endpoint = r = None\n    try:\n        <IND>ret = {}\n        endpoints = ['https://api.bitflyer.com/v1/getmarkets/eu', 'https://api.bitflyer.com/v1/getmarkets/usa', 'https://api.bitflyer.com/v1/getmarkets']\n        for endpoint in endpoints:\n            <IND>r = requests.get(endpoint)\n            for entry in r.json():\n                <IND>normalized = entry['product_code'].replace(\"_\", SYMBOL_SEP)\n                ret[normalized] = entry['product_code']\n        <DED><DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BITFLYER', why, {endpoint: r})\n\n\n<DED><DED>def bybit_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.bybit.com/v2/public/symbols')\n        ret = {}\n        for symbol in r.json()['result']:\n            <IND>quote = symbol['quote_currency']\n            if not symbol['name'].endswith(quote):\n                <IND>base, contract = symbol['name'].split(quote)\n                normalized = f\"{base}{SYMBOL_SEP}{quote}-{contract}\"\n            <DED>else:\n                <IND>normalized = f\"{symbol['base_currency']}{SYMBOL_SEP}{quote}\"\n            <DED>ret[normalized] = symbol['name']\n            _exchange_info[BYBIT]['tick_size'][normalized] = symbol['price_filter']['tick_size']\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BYBIT', why, {\"\": r})\n\n\n<DED><DED>def _ftx_helper(endpoint: str, exchange: str):\n    <IND>r = None\n    try:\n        <IND>r = requests.get(endpoint)\n        ret = {}\n        for data in r.json()['result']:\n            <IND>normalized = data['name'].replace(\"/\", SYMBOL_SEP)\n            symbol = data['name']\n            ret[normalized] = symbol\n            _exchange_info[exchange]['tick_size'][normalized] = data['priceIncrement']\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation(exchange, why, {endpoint: r})\n\n\n<DED><DED>def ftx_symbols() -> Dict[str, str]:\n    <IND>return _ftx_helper('https://ftx.com/api/markets', FTX)\n\n\n<DED>def ftx_us_symbols() -> Dict[str, str]:\n    <IND>return _ftx_helper('https://ftx.us/api/markets', FTX_US)\n\n\n<DED>def coinbase_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.pro.coinbase.com/products')\n        ret = {}\n        for data in r.json():\n            <IND>normalized = data['id'].replace(\"-\", SYMBOL_SEP)\n            ret[normalized] = data['id']\n            _exchange_info[COINBASE]['tick_size'][normalized] = data['quote_increment']\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('COINBASE', why, {\"\": r})\n\n\n<DED><DED>def gemini_symbols(*args) -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.gemini.com/v1/symbols')\n        ret = {}\n        for symbol in r.json():\n            <IND>std = f\"{symbol[:-3]}{SYMBOL_SEP}{symbol[-3:]}\"\n            std = std.upper()\n            ret[std] = symbol.upper()\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('GEMINI', why, {\"\": r})\n\n\n<DED><DED>def hitbtc_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>ret = {}\n        r = requests.get('https://api.hitbtc.com/api/2/public/symbol')\n        for symbol in r.json():\n            <IND>split = len(symbol['baseCurrency'])\n            normalized = symbol['id'][:split] + SYMBOL_SEP + symbol['id'][split:]\n            ret[normalized] = symbol['id']\n            _exchange_info[HITBTC]['tick_size'][normalized] = symbol['tickSize']\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('HITBTC', why, {\"\": r})\n\n\n<DED><DED>def poloniex_id_symbol_mapping():\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://poloniex.com/public?command=returnTicker')\n        symbols = r.json()\n        ret = {}\n        for symbol in symbols:\n            <IND>ret[symbols[symbol]['id']] = symbol\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('POLONIEX', why, {\"\": r})\n\n\n<DED><DED>def poloniex_symbols() -> Dict[str, str]:\n    <IND>ret = {}\n    for _, value in poloniex_id_symbol_mapping().items():\n        <IND>std = value.replace(\"STR\", \"XLM\")\n        quote, base = std.split(\"_\")\n        ret[quote + SYMBOL_SEP + base] = value\n    <DED>return ret\n\n\n<DED>def bitstamp_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://www.bitstamp.net/api/v2/trading-pairs-info/')\n        ret = {}\n        for data in r.json():\n            <IND>normalized = data['name'].replace(\"/\", SYMBOL_SEP)\n            symbol = data['url_symbol']\n            ret[normalized] = symbol\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BITSTAMP', why, {\"\": r})\n\n\n<DED><DED>def kraken_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.kraken.com/0/public/AssetPairs')\n        data = r.json()\n        ret = {}\n        for symbol in data['result']:\n            <IND>if 'wsname' not in data['result'][symbol] or '.d' in symbol:\n                # https://blog.kraken.com/post/259/introducing-the-kraken-dark-pool/\n                # .d is for dark pool symbols\n                <IND>continue\n\n            <DED>base, quote = data['result'][symbol]['wsname'].split(\"/\")\n\n            normalized = f\"{base}{SYMBOL_SEP}{quote}\"\n            exch = data['result'][symbol]['wsname']\n            normalized = normalized.replace('XBT', 'BTC')\n            normalized = normalized.replace('XDG', 'DOG')\n            ret[normalized] = exch\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('KRAKEN', why, {\"\": r})\n\n\n<DED><DED>def kraken_rest_symbols() -> Dict[str, str]:\n    <IND>return {normalized: exchange.replace(\"/\", \"\") for normalized, exchange in kraken_symbols().items()}\n\n\n<DED>def exx_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.exx.com/data/v1/tickers')\n        exchange = [key.upper() for key in r.json().keys()]\n        symbols = [key.replace(\"_\", SYMBOL_SEP) for key in exchange]\n        return dict(zip(symbols, exchange))\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('EXX', why, {\"\": r})\n\n\n<DED><DED>def huobi_common_symbols(url: str):\n    <IND>r = None\n    try:\n        <IND>r = requests.get(url)\n        ret = {}\n        for e in r.json()['data']:\n            <IND>if e['state'] == 'offline':\n                <IND>continue\n            <DED>normalized = f\"{e['base-currency'].upper()}{SYMBOL_SEP}{e['quote-currency'].upper()}\"\n            symbol = f\"{e['base-currency']}{e['quote-currency']}\"\n            ret[normalized] = symbol\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('HUOBI', why, {url: r})\n\n\n<DED><DED>def huobi_symbols() -> Dict[str, str]:\n    <IND>return huobi_common_symbols('https://api.huobi.pro/v1/common/symbols')\n\n\n<DED>def huobi_us_symbols() -> Dict[str, str]:\n    <IND>return huobi_common_symbols('https://api.huobi.com/v1/common/symbols')\n\n\n<DED>def huobi_dm_symbols() -> Dict[str, str]:\n    <IND>\"\"\"\n    Mapping is, for instance: {\"BTC_CW\":\"BTC190816\"}\n    See comments in exchange/huobi_dm.py\n    \"\"\"\n    mapping = {\n        \"this_week\": \"CW\",\n        \"next_week\": \"NW\",\n        \"quarter\": \"CQ\",\n        \"next_quarter\": \"NQ\"\n    }\n    r = None\n    try:\n        <IND>r = requests.get('https://www.hbdm.com/api/v1/contract_contract_info')\n        symbols = {}\n        for e in r.json()['data']:\n            <IND>symbols[f\"{e['symbol']}_{mapping[e['contract_type']]}\"] = e['contract_code']\n            _exchange_info[HUOBI_DM]['tick_size'][e['contract_code']] = e['price_tick']\n            _exchange_info[HUOBI_DM]['short_code_mappings'][f\"{e['symbol']}_{mapping[e['contract_type']]}\"] = e['contract_code']\n        <DED>return symbols\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('HUOBI_DM', why, {\"\": r})\n\n\n<DED><DED>def huobi_swap_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.hbdm.com/swap-api/v1/swap_contract_info')\n        symbols = {}\n        for e in r.json()['data']:\n            <IND>symbols[e['contract_code']] = e['contract_code']\n            _exchange_info[HUOBI_SWAP]['tick_size'][e['contract_code']] = e['price_tick']\n        <DED>return symbols\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('HUOBI_SWAP', why, {\"\": r})\n\n\n<DED><DED>def okcoin_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://www.okcoin.com/api/spot/v3/instruments')\n        ret = {}\n        for e in r.json():\n            <IND>ret[e['instrument_id']] = e['instrument_id']\n            _exchange_info[OKCOIN]['tick_size'][e['instrument_id']] = e['tick_size']\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('OKCOIN', why, {\"\": r})\n\n\n<DED><DED>def okex_symbols(*args) -> Dict[str, str]:\n    <IND>urls = ['https://www.okex.com/api/spot/v3/instruments',\n            'https://www.okex.com/api/swap/v3/instruments',\n            'https://www.okex.com/api/futures/v3/instruments']\n    urls = urls + okex_compute_option_urls_from_underlyings()\n\n    symbols: Dict[str, str] = {}\n    for u in urls:\n        <IND>time.sleep(0.2)\n        symbols.update(okex_symbols_from_one_url(u))\n\n    <DED>for symbol in symbols:\n        <IND>instrument_type = 'futures'\n        dash_count = symbol.count(get_symbol_separator())\n        if dash_count == 1:  # BTC-USDT\n            <IND>instrument_type = 'spot'\n        <DED>if dash_count == 4:  # BTC-USD-201225-35000-P\n            <IND>instrument_type = 'option'\n        <DED>if symbol[-4:] == \"SWAP\":  # BTC-USDT-SWAP\n            <IND>instrument_type = 'swap'\n\n        <DED>_exchange_info[OKEX]['instrument_type'][symbol] = instrument_type\n\n    <DED>return symbols\n\n\n<DED>def okex_compute_option_urls_from_underlyings() -> List[str]:\n    <IND>url = 'https://www.okex.com/api/option/v3/underlying'\n    r = None\n    try:\n        <IND>r = requests.get(url)\n        return [f'https://www.okex.com/api/option/v3/instruments/{underlying}' for underlying in r.json()]\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('OKEX', why, {url: r})\n\n\n<DED><DED>def okex_symbols_from_one_url(url: str) -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get(url)\n        ret = {}\n        for e in r.json():\n            <IND>ret[e['instrument_id']] = e['instrument_id']\n            _exchange_info[OKEX]['tick_size'][e['instrument_id']] = e['tick_size']\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('OKEX', why, {url: r})\n\n\n<DED><DED>def bittrex_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.bittrex.com/api/v1.1/public/getmarkets')\n        r = r.json()['result']\n        return {f\"{e['MarketCurrency']}{SYMBOL_SEP}{e['BaseCurrency']}\": e['MarketName'] for e in r if e['IsActive']}\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BITTREX', why, {\"\": r})\n\n\n<DED><DED>def bitcoincom_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.exchange.bitcoin.com/api/2/public/symbol')\n        return {f\"{data['baseCurrency']}{SYMBOL_SEP}{data['quoteCurrency'].replace('USD', 'USDT')}\": data['id'] for data in r.json()}\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BITCOINCOM', why, {\"\": r})\n\n\n<DED><DED>def bitmax_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://bitmax.io/api/pro/v1/products')\n        ret = {}\n        for entry in r.json()['data']:\n            # Only \"Normal\" status symbols are tradeable\n            <IND>if entry['status'] == 'Normal':\n                <IND>normalized = f\"{entry['baseAsset']}{SYMBOL_SEP}{entry['quoteAsset']}\"\n                ret[normalized] = entry['symbol']\n                _exchange_info[BITMAX]['tick_size'][normalized] = entry['tickSize']\n        <DED><DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BITMAX', why, {\"\": r})\n\n\n<DED><DED>def upbit_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.upbit.com/v1/market/all')\n        return {f\"{data['market'].split('-')[1]}{SYMBOL_SEP}{data['market'].split('-')[0]}\": data['market'] for data in r.json()}\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('UPBIT', why, {\"\": r})\n\n\n<DED><DED>def blockchain_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get(\"https://api.blockchain.com/mercury-gateway/v1/instruments\")\n        return {data[\"symbol\"].replace(\"-\", SYMBOL_SEP): data[\"symbol\"] for data in r.json()}\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BLOCKCHAIN', why, {\"\": r})\n\n\n<DED><DED>def gateio_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get(\"https://api.gateio.ws/api/v4/spot/currency_pairs\")\n        return {data[\"id\"].replace(\"_\", SYMBOL_SEP): data['id'] for data in r.json()}\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('GATEIO', why, {\"\": r})\n\n\n<DED><DED>def bitmex_symbols() -> Dict[str, str]:\n    <IND>r = None\n    ret = {}\n    try:\n        <IND>r = requests.get(\"https://www.bitmex.com/api/v1/instrument/active\")\n        for entry in r.json():\n            <IND>components = []\n            components.append(entry['rootSymbol'])\n            components.append(entry['quoteCurrency'])\n\n            if entry['expiry']:\n                <IND>components.append(entry['symbol'][-3:])\n\n            <DED>normalized = SYMBOL_SEP.join(components)\n            normalized = normalized.replace(\"XBT\", \"BTC\")\n            ret[normalized] = entry['symbol']\n            _exchange_info[BITMEX]['tick_size'][normalized] = entry['tickSize']\n\n            if entry['expiry']:\n                <IND>_exchange_info[BITMEX]['expiry'][normalized] = entry['expiry']\n\n        <DED><DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BITMEX', why, {\"\": r})\n\n\n<DED><DED>def deribit_symbols() -> Dict[str, str]:\n    <IND>url = r = None\n    ret = {}\n    try:\n        # TODO: get currencies from https://www.deribit.com/api/v2/public/get_currencies\n        <IND>currencies = ['BTC', 'ETH']\n        for c in currencies:\n            <IND>url = f\"https://www.deribit.com/api/v2/public/get_instruments?currency={c}&expired=false\"\n            r = requests.get(url)\n            for entry in r.json()['result']:\n                <IND>split = entry['instrument_name'].split(\"-\")\n                normalized = split[0] + SYMBOL_SEP + entry['quote_currency'] + \"-\" + '-'.join(split[1:])\n                ret[normalized] = entry['instrument_name']\n                _exchange_info[DERIBIT]['tick_size'][normalized] = entry['tick_size']\n        <DED><DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('DERIBIT', why, {url: r})\n\n\n<DED><DED>def kraken_future_symbols() -> Dict[str, str]:\n    <IND>r = None\n    ret = {}\n    try:\n        <IND>r = requests.get('https://futures.kraken.com/derivatives/api/v3/instruments')\n        data = r.json()['instruments']\n        for entry in data:\n            <IND>if not entry['tradeable']:\n                <IND>continue\n            <DED>normalized = entry['symbol'].upper().replace(\"_\", \"-\")\n            symbol = normalized[3:6] + SYMBOL_SEP + normalized[6:9]\n            normalized = normalized.replace(normalized[3:9], symbol)\n            normalized = normalized.replace('XBT', 'BTC')\n\n            _exchange_info[KRAKEN_FUTURES]['tick_size'][normalized] = entry['tickSize']\n            _exchange_info[KRAKEN_FUTURES]['contract_size'][normalized] = entry['contractSize']\n            _exchange_info[KRAKEN_FUTURES]['underlying'][normalized] = entry['underlying']\n            _exchange_info[KRAKEN_FUTURES]['product_type'][normalized] = _kraken_futures_product_type[normalized[:2]]\n            ret[normalized] = entry['symbol']\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('KRAKEN_FUTURES', why, {\"\": r})\n\n\n<DED><DED>def probit_symbols() -> Dict[str, str]:\n    # doc: https://docs-en.probit.com/reference-link/market\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.probit.com/api/exchange/v1/market')\n        return {entry['id']: entry['id'] for entry in r.json()['data']}\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('PROBIT', why, {\"\": r})\n\n\n<DED><DED>def coingecko_normalize_symbol(symbol: str) -> str:\n    # keep digits, letters and dots, replace others by space\n    <IND>symbol = ''.join(c if c.isalnum() or c in ('.', '+') else ' ' for c in symbol)\n    return coingecko_normalize(symbol.upper())\n\n\n<DED>def coingecko_normalize_name(name: str) -> str:\n    # keep digits and letters, replace others by space (except when only composed by upper case letters, digits and dots)\n    <IND>if not all(c.isupper() or c.isdigit() or c == '.' for c in name):\n        <IND>name = ''.join(c if c.isalnum() else ' ' for c in name)\n    <DED>return coingecko_normalize(name)\n\n\n<DED>def coingecko_normalize(sym: str) -> str:\n    <IND>sym = sym.strip()\n    # do not concatenate numbers => separate them with a dot\n    sym = list(sym)\n    if len(sym) > 4:\n        <IND>for i in range(2, len(sym) - 1):\n            <IND>if sym[i] == ' ' and sym[i - 1].isdigit() and sym[i + 1].isdigit():\n                <IND>sym[i] = '.'\n    <DED><DED><DED>sym = ''.join(sym)\n    # concatenate space-separated words => use CamelCase to distinguish the words\n    if ' ' in sym:\n        <IND>if sum(c.islower() for c in sym):  # if there is at least one lower case letter\n            <IND>sym = ' '.join(word[0].upper() + word[1:] for word in sym.split())  # Just capitalize initial letter of each word\n        <DED>else:  # CoinGecko may provide full upper-case as for \"THE STONE COIN\"\n            <IND>sym = string.capwords(sym)  # capwords converts \"THE STONE COIN\" to \"The Stone Coin\"\n        <DED>sym = sym.replace(' ', '')  # concatenate words\n    <DED>return sym\n\n\n<DED>def is_name_short(coin: dict) -> bool:\n    <IND>\"\"\"return True if the coin name is enough short compared to the coin symbol.\"\"\"\n    return len(coin['name']) <= max(5, len(coin['symbol']) + 1)\n\n\n<DED>def has_many_caps(name: str) -> bool:\n    <IND>\"\"\"return True if the symbol contains enough upper case letters, False if empty.\"\"\"\n    return str and sum(c.islower() for c in name) < (len(name) / 2)\n\n\n<DED>def coingecko_normalize_all(coin: dict):\n    <IND>SYMBOL_TO_NORMALIZED = {'miota': 'IOTA'}\n    normalized = SYMBOL_TO_NORMALIZED.get(coin['symbol'])\n    if normalized:\n        <IND>coin['ns'] = coin['nn'] = normalized\n        return normalized\n\n    # ns = normalized symbol, nn = normalized name\n    <DED>coin['ns'] = coingecko_normalize_symbol(coin['symbol'])\n\n    ID_SUFFIX = '-bitcoin-token'\n    if coin['id'][-len(ID_SUFFIX):] == ID_SUFFIX:\n        <IND>coin['nn'] = 'BTC' + coin['ns']\n        return coin['nn']\n\n    <DED>name = coin['name']\n\n    prefixes = ('The ', 'the ')\n    for p in prefixes:\n        <IND>if name[:len(p)] == p:\n            <IND>coin['reduced-name'] = True\n            name = name[len(p):]\n            break\n\n    <DED><DED>suffixes = ('coin', 'coins', 'money', 'finance', 'protocol', 'reward', 'rewards', 'token')\n    for s in suffixes:\n        <IND>if len(name) > len(s) and name[-len(s):].lower() == s:\n            # but keep suffix when lower-case concatenated\n            <IND>if name[-len(s)].islower() and name[-len(s) - 1] != ' ':\n                <IND>continue\n            # also keep suffix to avoid confusing nam: \"Bitcoin Token\" -> \"Bitcoin\"\n            <DED>if name[:-len(s)].strip().lower() == 'bitcoin':\n                <IND>continue\n            <DED>coin['reduced-name'] = True\n            name = name[:-len(s)]\n            break\n\n    <DED><DED>coin['nn'] = coingecko_normalize_name(name)\n\n    if len(coin['nn']) < len(coin['ns']):\n        <IND>if 'reduced-name' in coin:\n            <IND>coin['reduced-name'] = False\n            name = coin['name']\n            coin['nn'] = coingecko_normalize_name(name)\n        <DED>elif not has_many_caps(name):\n            <IND>return coin['ns']\n\n    <DED><DED>if not coin['ns']:  # coin['symbol'] may be an emoji that is striped when normalized\n        <IND>return coin['nn']\n\n    <DED>if coin.get('reduced-name') and coin['ns'].upper() != coin['nn'].upper():\n        <IND>return coin['ns']\n\n    <DED>i = coin['nn'].find('.')  # if there is a dot in normalized name => prefer the normalized symbol\n    if i >= 0:\n        <IND>if i > 1 and coin['nn'][i - 1].isdigit() and coin['nn'][i + 1].isdigit():\n            <IND>pass  # except when the dot separates digits\n        <DED>else:\n            <IND>return coin['ns']\n\n    <DED><DED>if is_name_short(coin) and has_many_caps(name):\n        <IND>return coin['nn']\n\n    <DED>if 1.5 * len(coin['ns']) > len(coin['nn']) and any(c.islower() for c in coin['ns']):\n        <IND>return coin['nn']\n\n    <DED>return coin['ns']\n\n\n<DED>def coingecko_symbols() -> Dict[str, str]:\n    <IND>r = None\n    intermediate = defaultdict(list)\n    try:\n        <IND>r = requests.get('https://api.coingecko.com/api/v3/coins/list')\n        all_coins = r.json()\n        # First pass: generate & compare normalized symbol/name, and then select the most pertinent\n        for coin in all_coins:\n            <IND>normalized = coingecko_normalize_all(coin)\n            intermediate[normalized].append(coin)\n            # Above line keeps together the coins having the same normalized symbol.\n            # To reduce collision, the coin['name'] is sometimes used in lieu of the coin['symbol'].\n            # The coin['name'] is not capitalized because lower case letters may be meaningful: cETH, yUSD, DATx, zLOT\n    <DED><DED>except Exception as why:\n        <IND>raise_failure_explanation('COINGECKO', why, {\"\": r})\n\n    <DED>final = coingecko_second_pass(intermediate)\n    return coingecko_third_pass(final)\n\n\n<DED>def coingecko_second_pass(intermediate: Dict[str, List[dict]]) -> Dict[str, List[dict]]:\n    # Second pass: fixes most of the symbol collisions\n    <IND>final = defaultdict(list)\n    for normalized, coins in intermediate.items():\n        <IND>if len(coins) == 1:\n            <IND>final[normalized].append(coins[0])\n            continue\n        <DED>set_normalized = False\n        for i in range(len(coins)):\n            <IND>if normalized == coins[i]['nn']:\n                <IND>coin = coins.pop(i)\n                final[normalized].append(coin)\n                set_normalized = True\n                break\n        <DED><DED>rest: List[dict] = []\n        for coin in coins:\n            <IND>if '%' in coin['name']:\n                <IND>if len(coins) == 1:\n                    <IND>n = coin['ns']\n                <DED>else:\n                    <IND>n = coingecko_normalize_name(coin['id'])\n                <DED>final[n].append(coin)\n            <DED>else:\n                <IND>rest.append(coin)\n        <DED><DED>if not rest:\n            <IND>continue\n        <DED>if not set_normalized:\n            <IND>rest.sort(key=lambda coin: len(coin['nn']), reverse=True)  # sort by the length of the normalized name\n            coin = rest.pop(0)\n            final[normalized].append(coin)\n        <DED>for coin in rest:\n            <IND>if coin['nn'] not in intermediate:\n                <IND>n = coin['nn']\n            <DED>elif coin.get('reduced-name'):\n                <IND>n = coingecko_normalize_name(coin['name'])\n            <DED>else:\n                <IND>n = coingecko_normalize_name(coin['id'])\n            <DED>final[n].append(coin)\n    <DED><DED>return final\n\n\n<DED>def coingecko_third_pass(final: Dict[str, List[dict]]) -> Dict[str, str]:\n    # Third pass: fixes some remaining collisions and fills the result\n    <IND>symbols = {}\n    for normalized, coins in final.items():\n        <IND>if len(coins) == 1:\n            <IND>symbols[normalized] = coins[0]['id']\n            continue\n        <DED>set_normalized = False\n        for i in range(len(coins)):\n            <IND>if normalized == coins[i]['nn']:\n                <IND>coin = coins.pop(i)\n                symbols[normalized] = coin['id']\n                set_normalized = True\n                break\n        <DED><DED>rest: List[dict] = []\n        for coin in coins:\n            <IND>if '%' in coin['name']:\n                <IND>if len(coins) == 1:\n                    <IND>n = coin['ns']\n                <DED>else:\n                    <IND>n = coingecko_normalize_name(coin['id'])\n                <DED>symbols[n] = coin['id']\n            <DED>else:\n                <IND>rest.append(coin)\n        <DED><DED>if not rest:\n            <IND>continue\n        <DED>if not set_normalized:\n            <IND>rest.sort(key=lambda coin: len(coin['nn']), reverse=True)  # sort by the length of the normalized name\n            coin = rest.pop(0)\n            symbols[normalized] = coin['id']\n        <DED>for coin in rest:\n            <IND>if coin['nn'] not in final:\n                <IND>n = coin['nn']\n            <DED>elif coin.get('reduced-name'):\n                <IND>n = coingecko_normalize_name(coin['name'])\n            <DED>else:\n                <IND>n = coingecko_normalize_name(coin['id'])\n            <DED>symbols[n] = coin['id']\n    <DED><DED>return symbols\n\n\n<DED>def whale_alert_coins(key_id: str) -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get(f'https://api.whale-alert.io/v1/status?api_key={key_id}')\n        # Same symbols, but on different blockchains (for instance USDT), are naturally overwritten.\n        return {s.upper(): s for b in r.json()['blockchains'] for s in b['symbols'] if s}\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('WHALES_ALERT', why, {\"\": r})\n\n\n<DED><DED>_exchange_function_map = {\n    BITFINEX: bitfinex_symbols,\n    BITFLYER: bitflyer_symbols,\n    COINBASE: coinbase_symbols,\n    GEMINI: gemini_symbols,\n    HITBTC: hitbtc_symbols,\n    POLONIEX: poloniex_symbols,\n    PROBIT: probit_symbols,\n    BITSTAMP: bitstamp_symbols,\n    KRAKEN: kraken_symbols,\n    KRAKEN + 'REST': kraken_rest_symbols,\n    BINANCE: binance_symbols,\n    BINANCE_US: binance_us_symbols,\n    BINANCE_FUTURES: binance_futures_symbols,\n    BINANCE_DELIVERY: binance_delivery_symbols,\n    BLOCKCHAIN: blockchain_symbols,\n    EXX: exx_symbols,\n    HUOBI: huobi_symbols,\n    HUOBI_DM: huobi_dm_symbols,\n    HUOBI_SWAP: huobi_swap_symbols,\n    OKCOIN: okcoin_symbols,\n    OKEX: okex_symbols,\n    BYBIT: bybit_symbols,\n    FTX: ftx_symbols,\n    FTX_US: ftx_us_symbols,\n    BITTREX: bittrex_symbols,\n    BITCOINCOM: bitcoincom_symbols,\n    BITMAX: bitmax_symbols,\n    UPBIT: upbit_symbols,\n    GATEIO: gateio_symbols,\n    BITMEX: bitmex_symbols,\n    DERIBIT: deribit_symbols,\n    KRAKEN_FUTURES: kraken_future_symbols,\n    COINGECKO: coingecko_symbols,\n    WHALE_ALERT: whale_alert_coins\n}\n",
        "target_code_with_indent": "\nfrom typing import Dict, Tuple\n\n\nclass _Symbols:\n    <IND>def __init__(self):\n        <IND>self.data = {}\n\n    <DED>def set(self, exchange: str, normalized: dict, exchange_info: dict):\n        <IND>self.data[exchange] = {}\n        self.data[exchange]['normalized'] = normalized\n        self.data[exchange]['info'] = exchange_info\n\n    <DED>def get(self, exchange: str) -> Tuple[Dict, Dict]:\n        <IND>return self.data[exchange]['normalized'], self.data[exchange]['info']\n\n    <DED>def populated(self, exchange: str) -> bool:\n        <IND>return exchange in self.data\n\n\n<DED><DED>Symbols = _Symbols()\n"
      }
    ]
  },
  {
    "project": "bmoscon/cryptofeed",
    "commit": "3525dc8ce4d7836a9abaaa5662e58e5e27969a77",
    "filename": "cryptofeed/symbols.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/bmoscon-cryptofeed/cryptofeed/symbols.py",
    "file_hunks_size": 1,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "cryptofeed/symbols.py:578:8 Incompatible return type [7]: Expected `Dict[str, str]` but got implicit return value of `None`.",
    "message": " Expected `Dict[str, str]` but got implicit return value of `None`.",
    "rule_id": "Incompatible return type [7]",
    "warning_line_no": 578,
    "warning_line": "        raise_failure_explanation('KRAKEN_FUTURES', why, {\"\": r})",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "associated with this software.\n\n\nSymbol generation code for exchanges\n'''\n\nimport logging\nimport string\nimport time\nfrom collections import defaultdict\nfrom typing import Dict, List, Optional, Tuple\n\nimport requests\nfrom requests import Response\n\nfrom cryptofeed.defines import *\n\n\nLOG = logging.getLogger('feedhandler')\n\nSYMBOL_SEP = '-'\n\n_symbols_retrieval_cache: Dict[str, Dict[str, str]] = {}\n_exchange_info = defaultdict(lambda: defaultdict(dict))\n\n\n_kraken_futures_product_type = {\n    'FI': 'Inverse Futures',\n    'FV': 'Vanilla Futures',\n    'PI': 'Perpetual Inverse Futures',\n    'PV': 'Perpetual Vanilla Futures',\n    'IN': 'Real Time Index',\n    'RR': 'Reference Rate',\n}\n\n\ndef raise_failure_explanation(feed_id: str, exception: BaseException, responses: Dict[str, Optional[Response]]):\n    LOG.critical('%s: encountered %r while processing response from exchange API', feed_id, exception)\n    if len(responses) > 1:\n        LOG.critical('%s: content of one of the %s responses was unexpected', feed_id, len(responses))\n    for url, r in responses.items():\n        if url:\n            LOG.critical('%s: requested URL: %s', feed_id, url)\n        if r:\n            LOG.critical('%s: unexpected response: %s', feed_id, r.text)\n    raise ValueError(f'Cryptofeed stopped because of an unexpected response from {feed_id}') from exception\n\n\ndef set_symbol_separator(separator: str):\n    global SYMBOL_SEP\n    SYMBOL_SEP = separator\n\n\ndef get_symbol_separator() -> str:\n    global SYMBOL_SEP\n    return SYMBOL_SEP\n\n\ndef gen_symbols(exchange: str, key_id=None) -> Dict[str, str]:\n    if exchange not in _symbols_retrieval_cache:\n        LOG.info(\"%s: Getting list of symbols\", exchange)\n        symbols = _exchange_function_map[exchange](key_id) if key_id else _exchange_function_map[exchange]()\n        LOG.info(\"%s: %s symbols\", exchange, len(symbols))\n\n        # log all retrieved symbols using debug level\n        for normalized, exch_sym in sorted(symbols.items()):\n            LOG.debug('%s: id-from-exch -> normalized: %-35s-> %s', exchange, exch_sym, normalized)\n\n        _symbols_retrieval_cache[exchange] = symbols\n    return _symbols_retrieval_cache[exchange]\n\n\ndef _binance_symbols(endpoint: str, exchange: str):\n    r = None\n    try:\n        ret = {}\n        r = requests.get(endpoint)\n        for symbol in r.json()['symbols']:\n            if symbol.get('status', 'TRADING') != \"TRADING\":\n                continue\n            if symbol.get('contractStatus', 'TRADING') != \"TRADING\":\n                continue\n            split = len(symbol['baseAsset'])\n            normalized = symbol['symbol'][:split] + SYMBOL_SEP + symbol['symbol'][split:]\n            ret[normalized] = symbol['symbol']\n            _exchange_info[exchange]['tick_size'][normalized] = symbol['filters'][0]['tickSize']\n            if \"contractType\" in symbol:\n                _exchange_info[exchange]['contract_type'][normalized] = symbol['contractType']\n        return ret\n    except Exception as why:\n        raise_failure_explanation(exchange, why, {endpoint: r})\n\n\ndef binance_symbols() -> Dict[str, str]:\n    return _binance_symbols('https://api.binance.com/api/v3/exchangeInfo', BINANCE)\n\n\ndef binance_us_symbols() -> Dict[str, str]:\n    return _binance_symbols('https://api.binance.us/api/v3/exchangeInfo', BINANCE_US)\n\n\ndef binance_futures_symbols() -> Dict[str, str]:\n    base = _binance_symbols('https://fapi.binance.com/fapi/v1/exchangeInfo', BINANCE_FUTURES)\n    add = {}\n    for symbol, orig in base.items():\n        if \"_\" in orig:\n            continue\n        add[f\"{symbol}-PINDEX\"] = f\"p{orig}\"\n    base.update(add)\n    return base\n\n\ndef binance_delivery_symbols() -> Dict[str, str]:\n    return _binance_symbols('https://dapi.binance.com/dapi/v1/exchangeInfo', BINANCE_DELIVERY)\n\n\ndef bitfinex_symbols() -> Dict[str, str]:\n    # doc: https://docs.bitfinex.com/docs/ws-general#supported-pairs\n    r1 = r2 = None\n    try:\n        r1 = requests.get('https://api.bitfinex.com/v2/tickers?symbols=ALL')\n        r2 = requests.get('https://api-pub.bitfinex.com/v2/conf/pub:map:currency:sym')\n        tickers: List[List[str]] = r1.json()\n        norm: List[Tuple[str, str]] = r2.json()[0]\n        norm: Dict[str, str] = dict(norm)\n        for k, v in dict(norm).items():\n            if k[-2:] == 'F0' or '-' in v:  # Do not convert BTCF0 -> BTC or PBTCETH -> PBTC-ETH\n                del norm[k]\n        norm['BCHN'] = 'BCH'  # Bitfinex uses BCHN, other exchanges use BCH\n\n        ret = {}\n        for symbol in [t[0] for t in tickers]:\n            if symbol[0] == 'f':\n                normalized = norm.get(symbol[1:], symbol[1:])\n            else:\n                if len(symbol) == 7:\n                    base, quote = symbol[1:4], symbol[4:]\n                else:\n                    base, quote = symbol[1:].split(':')\n                    assert ':' in symbol\n                normalized = norm.get(base, base) + SYMBOL_SEP + norm.get(quote, quote)\n            ret[normalized.upper()] = symbol\n        return ret\n    except ValueError as why:\n        raise_failure_explanation('BITFINEX', why, {\"tickers?symbols=ALL\": r1, \"pub:map:currency:sym\": r2})\n\n\ndef bitflyer_symbols() -> Dict[str, str]:\n    endpoint = r = None\n    try:\n        ret = {}\n        endpoints = ['https://api.bitflyer.com/v1/getmarkets/eu', 'https://api.bitflyer.com/v1/getmarkets/usa', 'https://api.bitflyer.com/v1/getmarkets']\n        for endpoint in endpoints:\n            r = requests.get(endpoint)\n            for entry in r.json():\n                normalized = entry['product_code'].replace(\"_\", SYMBOL_SEP)\n                ret[normalized] = entry['product_code']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('BITFLYER', why, {endpoint: r})\n\n\ndef bybit_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.bybit.com/v2/public/symbols')\n        ret = {}\n        for symbol in r.json()['result']:\n            quote = symbol['quote_currency']\n            if not symbol['name'].endswith(quote):\n                base, contract = symbol['name'].split(quote)\n                normalized = f\"{base}{SYMBOL_SEP}{quote}-{contract}\"\n            else:\n                normalized = f\"{symbol['base_currency']}{SYMBOL_SEP}{quote}\"\n            ret[normalized] = symbol['name']\n            _exchange_info[BYBIT]['tick_size'][normalized] = symbol['price_filter']['tick_size']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('BYBIT', why, {\"\": r})\n\n\ndef _ftx_helper(endpoint: str, exchange: str):\n    r = None\n    try:\n        r = requests.get(endpoint)\n        ret = {}\n        for data in r.json()['result']:\n            normalized = data['name'].replace(\"/\", SYMBOL_SEP)\n            symbol = data['name']\n            ret[normalized] = symbol\n            _exchange_info[exchange]['tick_size'][normalized] = data['priceIncrement']\n        return ret\n    except Exception as why:\n        raise_failure_explanation(exchange, why, {endpoint: r})\n\n\ndef ftx_symbols() -> Dict[str, str]:\n    return _ftx_helper('https://ftx.com/api/markets', FTX)\n\n\ndef ftx_us_symbols() -> Dict[str, str]:\n    return _ftx_helper('https://ftx.us/api/markets', FTX_US)\n\n\ndef coinbase_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.pro.coinbase.com/products')\n        ret = {}\n        for data in r.json():\n            normalized = data['id'].replace(\"-\", SYMBOL_SEP)\n            ret[normalized] = data['id']\n            _exchange_info[COINBASE]['tick_size'][normalized] = data['quote_increment']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('COINBASE', why, {\"\": r})\n\n\ndef gemini_symbols(*args) -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.gemini.com/v1/symbols')\n        ret = {}\n        for symbol in r.json():\n            std = f\"{symbol[:-3]}{SYMBOL_SEP}{symbol[-3:]}\"\n            std = std.upper()\n            ret[std] = symbol.upper()\n        return ret\n    except Exception as why:\n        raise_failure_explanation('GEMINI', why, {\"\": r})\n\n\ndef hitbtc_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        ret = {}\n        r = requests.get('https://api.hitbtc.com/api/2/public/symbol')\n        for symbol in r.json():\n            split = len(symbol['baseCurrency'])\n            normalized = symbol['id'][:split] + SYMBOL_SEP + symbol['id'][split:]\n            ret[normalized] = symbol['id']\n            _exchange_info[HITBTC]['tick_size'][normalized] = symbol['tickSize']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('HITBTC', why, {\"\": r})\n\n\ndef poloniex_id_symbol_mapping():\n    r = None\n    try:\n        r = requests.get('https://poloniex.com/public?command=returnTicker')\n        symbols = r.json()\n        ret = {}\n        for symbol in symbols:\n            ret[symbols[symbol]['id']] = symbol\n        return ret\n    except Exception as why:\n        raise_failure_explanation('POLONIEX', why, {\"\": r})\n\n\ndef poloniex_symbols() -> Dict[str, str]:\n    ret = {}\n    for _, value in poloniex_id_symbol_mapping().items():\n        std = value.replace(\"STR\", \"XLM\")\n        quote, base = std.split(\"_\")\n        ret[quote + SYMBOL_SEP + base] = value\n    return ret\n\n\ndef bitstamp_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://www.bitstamp.net/api/v2/trading-pairs-info/')\n        ret = {}\n        for data in r.json():\n            normalized = data['name'].replace(\"/\", SYMBOL_SEP)\n            symbol = data['url_symbol']\n            ret[normalized] = symbol\n        return ret\n    except Exception as why:\n        raise_failure_explanation('BITSTAMP', why, {\"\": r})\n\n\ndef kraken_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.kraken.com/0/public/AssetPairs')\n        data = r.json()\n        ret = {}\n        for symbol in data['result']:\n            if 'wsname' not in data['result'][symbol] or '.d' in symbol:\n                # https://blog.kraken.com/post/259/introducing-the-kraken-dark-pool/\n                # .d is for dark pool symbols\n                continue\n\n            base, quote = data['result'][symbol]['wsname'].split(\"/\")\n\n            normalized = f\"{base}{SYMBOL_SEP}{quote}\"\n            exch = data['result'][symbol]['wsname']\n            normalized = normalized.replace('XBT', 'BTC')\n            normalized = normalized.replace('XDG', 'DOG')\n            ret[normalized] = exch\n        return ret\n    except Exception as why:\n        raise_failure_explanation('KRAKEN', why, {\"\": r})\n\n\ndef kraken_rest_symbols() -> Dict[str, str]:\n    return {normalized: exchange.replace(\"/\", \"\") for normalized, exchange in kraken_symbols().items()}\n\n\ndef exx_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.exx.com/data/v1/tickers')\n        exchange = [key.upper() for key in r.json().keys()]\n        symbols = [key.replace(\"_\", SYMBOL_SEP) for key in exchange]\n        return dict(zip(symbols, exchange))\n    except Exception as why:\n        raise_failure_explanation('EXX', why, {\"\": r})\n\n\ndef huobi_common_symbols(url: str):\n    r = None\n    try:\n        r = requests.get(url)\n        ret = {}\n        for e in r.json()['data']:\n            if e['state'] == 'offline':\n                continue\n            normalized = f\"{e['base-currency'].upper()}{SYMBOL_SEP}{e['quote-currency'].upper()}\"\n            symbol = f\"{e['base-currency']}{e['quote-currency']}\"\n            ret[normalized] = symbol\n        return ret\n    except Exception as why:\n        raise_failure_explanation('HUOBI', why, {url: r})\n\n\ndef huobi_symbols() -> Dict[str, str]:\n    return huobi_common_symbols('https://api.huobi.pro/v1/common/symbols')\n\n\ndef huobi_us_symbols() -> Dict[str, str]:\n    return huobi_common_symbols('https://api.huobi.com/v1/common/symbols')\n\n\ndef huobi_dm_symbols() -> Dict[str, str]:\n    \"\"\"\n    Mapping is, for instance: {\"BTC_CW\":\"BTC190816\"}\n    See comments in exchange/huobi_dm.py\n    \"\"\"\n    mapping = {\n        \"this_week\": \"CW\",\n        \"next_week\": \"NW\",\n        \"quarter\": \"CQ\",\n        \"next_quarter\": \"NQ\"\n    }\n    r = None\n    try:\n        r = requests.get('https://www.hbdm.com/api/v1/contract_contract_info')\n        symbols = {}\n        for e in r.json()['data']:\n            symbols[f\"{e['symbol']}_{mapping[e['contract_type']]}\"] = e['contract_code']\n            _exchange_info[HUOBI_DM]['tick_size'][e['contract_code']] = e['price_tick']\n            _exchange_info[HUOBI_DM]['short_code_mappings'][f\"{e['symbol']}_{mapping[e['contract_type']]}\"] = e['contract_code']\n        return symbols\n    except Exception as why:\n        raise_failure_explanation('HUOBI_DM', why, {\"\": r})\n\n\ndef huobi_swap_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.hbdm.com/swap-api/v1/swap_contract_info')\n        symbols = {}\n        for e in r.json()['data']:\n            symbols[e['contract_code']] = e['contract_code']\n            _exchange_info[HUOBI_SWAP]['tick_size'][e['contract_code']] = e['price_tick']\n        return symbols\n    except Exception as why:\n        raise_failure_explanation('HUOBI_SWAP', why, {\"\": r})\n\n\ndef okcoin_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://www.okcoin.com/api/spot/v3/instruments')\n        ret = {}\n        for e in r.json():\n            ret[e['instrument_id']] = e['instrument_id']\n            _exchange_info[OKCOIN]['tick_size'][e['instrument_id']] = e['tick_size']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('OKCOIN', why, {\"\": r})\n\n\ndef okex_symbols(*args) -> Dict[str, str]:\n    urls = ['https://www.okex.com/api/spot/v3/instruments',\n            'https://www.okex.com/api/swap/v3/instruments',\n            'https://www.okex.com/api/futures/v3/instruments']\n    urls = urls + okex_compute_option_urls_from_underlyings()\n\n    symbols: Dict[str, str] = {}\n    for u in urls:\n        time.sleep(0.2)\n        symbols.update(okex_symbols_from_one_url(u))\n\n    for symbol in symbols:\n        instrument_type = 'futures'\n        dash_count = symbol.count(get_symbol_separator())\n        if dash_count == 1:  # BTC-USDT\n            instrument_type = 'spot'\n        if dash_count == 4:  # BTC-USD-201225-35000-P\n            instrument_type = 'option'\n        if symbol[-4:] == \"SWAP\":  # BTC-USDT-SWAP\n            instrument_type = 'swap'\n\n        _exchange_info[OKEX]['instrument_type'][symbol] = instrument_type\n\n    return symbols\n\n\ndef okex_compute_option_urls_from_underlyings() -> List[str]:\n    url = 'https://www.okex.com/api/option/v3/underlying'\n    r = None\n    try:\n        r = requests.get(url)\n        return [f'https://www.okex.com/api/option/v3/instruments/{underlying}' for underlying in r.json()]\n    except Exception as why:\n        raise_failure_explanation('OKEX', why, {url: r})\n\n\ndef okex_symbols_from_one_url(url: str) -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get(url)\n        ret = {}\n        for e in r.json():\n            ret[e['instrument_id']] = e['instrument_id']\n            _exchange_info[OKEX]['tick_size'][e['instrument_id']] = e['tick_size']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('OKEX', why, {url: r})\n\n\ndef bittrex_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.bittrex.com/api/v1.1/public/getmarkets')\n        r = r.json()['result']\n        return {f\"{e['MarketCurrency']}{SYMBOL_SEP}{e['BaseCurrency']}\": e['MarketName'] for e in r if e['IsActive']}\n    except Exception as why:\n        raise_failure_explanation('BITTREX', why, {\"\": r})\n\n\ndef bitcoincom_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.exchange.bitcoin.com/api/2/public/symbol')\n        return {f\"{data['baseCurrency']}{SYMBOL_SEP}{data['quoteCurrency'].replace('USD', 'USDT')}\": data['id'] for data in r.json()}\n    except Exception as why:\n        raise_failure_explanation('BITCOINCOM', why, {\"\": r})\n\n\ndef bitmax_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://bitmax.io/api/pro/v1/products')\n        ret = {}\n        for entry in r.json()['data']:\n            # Only \"Normal\" status symbols are tradeable\n            if entry['status'] == 'Normal':\n                normalized = f\"{entry['baseAsset']}{SYMBOL_SEP}{entry['quoteAsset']}\"\n                ret[normalized] = entry['symbol']\n                _exchange_info[BITMAX]['tick_size'][normalized] = entry['tickSize']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('BITMAX', why, {\"\": r})\n\n\ndef upbit_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.upbit.com/v1/market/all')\n        return {f\"{data['market'].split('-')[1]}{SYMBOL_SEP}{data['market'].split('-')[0]}\": data['market'] for data in r.json()}\n    except Exception as why:\n        raise_failure_explanation('UPBIT', why, {\"\": r})\n\n\ndef blockchain_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get(\"https://api.blockchain.com/mercury-gateway/v1/instruments\")\n        return {data[\"symbol\"].replace(\"-\", SYMBOL_SEP): data[\"symbol\"] for data in r.json()}\n    except Exception as why:\n        raise_failure_explanation('BLOCKCHAIN', why, {\"\": r})\n\n\ndef gateio_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get(\"https://api.gateio.ws/api/v4/spot/currency_pairs\")\n        return {data[\"id\"].replace(\"_\", SYMBOL_SEP): data['id'] for data in r.json()}\n    except Exception as why:\n        raise_failure_explanation('GATEIO', why, {\"\": r})\n\n\ndef bitmex_symbols() -> Dict[str, str]:\n    r = None\n    ret = {}\n    try:\n        r = requests.get(\"https://www.bitmex.com/api/v1/instrument/active\")\n        for entry in r.json():\n            components = []\n            components.append(entry['rootSymbol'])\n            components.append(entry['quoteCurrency'])\n\n            if entry['expiry']:\n                components.append(entry['symbol'][-3:])\n\n            normalized = SYMBOL_SEP.join(components)\n            normalized = normalized.replace(\"XBT\", \"BTC\")\n            ret[normalized] = entry['symbol']\n            _exchange_info[BITMEX]['tick_size'][normalized] = entry['tickSize']\n\n            if entry['expiry']:\n                _exchange_info[BITMEX]['expiry'][normalized] = entry['expiry']\n\n        return ret\n    except Exception as why:\n        raise_failure_explanation('BITMEX', why, {\"\": r})\n\n\ndef deribit_symbols() -> Dict[str, str]:\n    url = r = None\n    ret = {}\n    try:\n        # TODO: get currencies from https://www.deribit.com/api/v2/public/get_currencies\n        currencies = ['BTC', 'ETH']\n        for c in currencies:\n            url = f\"https://www.deribit.com/api/v2/public/get_instruments?currency={c}&expired=false\"\n            r = requests.get(url)\n            for entry in r.json()['result']:\n                split = entry['instrument_name'].split(\"-\")\n                normalized = split[0] + SYMBOL_SEP + entry['quote_currency'] + \"-\" + '-'.join(split[1:])\n                ret[normalized] = entry['instrument_name']\n                _exchange_info[DERIBIT]['tick_size'][normalized] = entry['tick_size']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('DERIBIT', why, {url: r})\n\n\ndef kraken_future_symbols() -> Dict[str, str]:\n    r = None\n    ret = {}\n    try:\n        r = requests.get('https://futures.kraken.com/derivatives/api/v3/instruments')\n        data = r.json()['instruments']\n        for entry in data:\n            if not entry['tradeable']:\n                continue\n            normalized = entry['symbol'].upper().replace(\"_\", \"-\")\n            symbol = normalized[3:6] + SYMBOL_SEP + normalized[6:9]\n            normalized = normalized.replace(normalized[3:9], symbol)\n            normalized = normalized.replace('XBT', 'BTC')\n\n            _exchange_info[KRAKEN_FUTURES]['tick_size'][normalized] = entry['tickSize']\n            _exchange_info[KRAKEN_FUTURES]['contract_size'][normalized] = entry['contractSize']\n            _exchange_info[KRAKEN_FUTURES]['underlying'][normalized] = entry['underlying']\n            _exchange_info[KRAKEN_FUTURES]['product_type'][normalized] = _kraken_futures_product_type[normalized[:2]]\n            ret[normalized] = entry['symbol']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('KRAKEN_FUTURES', why, {\"\": r})\n\n\ndef probit_symbols() -> Dict[str, str]:\n    # doc: https://docs-en.probit.com/reference-link/market\n    r = None\n    try:\n        r = requests.get('https://api.probit.com/api/exchange/v1/market')\n        return {entry['id']: entry['id'] for entry in r.json()['data']}\n    except Exception as why:\n        raise_failure_explanation('PROBIT', why, {\"\": r})\n\n\ndef coingecko_normalize_symbol(symbol: str) -> str:\n    # keep digits, letters and dots, replace others by space\n    symbol = ''.join(c if c.isalnum() or c in ('.', '+') else ' ' for c in symbol)\n    return coingecko_normalize(symbol.upper())\n\n\ndef coingecko_normalize_name(name: str) -> str:\n    # keep digits and letters, replace others by space (except when only composed by upper case letters, digits and dots)\n    if not all(c.isupper() or c.isdigit() or c == '.' for c in name):\n        name = ''.join(c if c.isalnum() else ' ' for c in name)\n    return coingecko_normalize(name)\n\n\ndef coingecko_normalize(sym: str) -> str:\n    sym = sym.strip()\n    # do not concatenate numbers => separate them with a dot\n    sym = list(sym)\n    if len(sym) > 4:\n        for i in range(2, len(sym) - 1):\n            if sym[i] == ' ' and sym[i - 1].isdigit() and sym[i + 1].isdigit():\n                sym[i] = '.'\n    sym = ''.join(sym)\n    # concatenate space-separated words => use CamelCase to distinguish the words\n    if ' ' in sym:\n        if sum(c.islower() for c in sym):  # if there is at least one lower case letter\n            sym = ' '.join(word[0].upper() + word[1:] for word in sym.split())  # Just capitalize initial letter of each word\n        else:  # CoinGecko may provide full upper-case as for \"THE STONE COIN\"\n            sym = string.capwords(sym)  # capwords converts \"THE STONE COIN\" to \"The Stone Coin\"\n        sym = sym.replace(' ', '')  # concatenate words\n    return sym\n\n\ndef is_name_short(coin: dict) -> bool:\n    \"\"\"return True if the coin name is enough short compared to the coin symbol.\"\"\"\n    return len(coin['name']) <= max(5, len(coin['symbol']) + 1)\n\n\ndef has_many_caps(name: str) -> bool:\n    \"\"\"return True if the symbol contains enough upper case letters, False if empty.\"\"\"\n    return str and sum(c.islower() for c in name) < (len(name) / 2)\n\n\ndef coingecko_normalize_all(coin: dict):\n    SYMBOL_TO_NORMALIZED = {'miota': 'IOTA'}\n    normalized = SYMBOL_TO_NORMALIZED.get(coin['symbol'])\n    if normalized:\n        coin['ns'] = coin['nn'] = normalized\n        return normalized\n\n    # ns = normalized symbol, nn = normalized name\n    coin['ns'] = coingecko_normalize_symbol(coin['symbol'])\n\n    ID_SUFFIX = '-bitcoin-token'\n    if coin['id'][-len(ID_SUFFIX):] == ID_SUFFIX:\n        coin['nn'] = 'BTC' + coin['ns']\n        return coin['nn']\n\n    name = coin['name']\n\n    prefixes = ('The ', 'the ')\n    for p in prefixes:\n        if name[:len(p)] == p:\n            coin['reduced-name'] = True\n            name = name[len(p):]\n            break\n\n    suffixes = ('coin', 'coins', 'money', 'finance', 'protocol', 'reward', 'rewards', 'token')\n    for s in suffixes:\n        if len(name) > len(s) and name[-len(s):].lower() == s:\n            # but keep suffix when lower-case concatenated\n            if name[-len(s)].islower() and name[-len(s) - 1] != ' ':\n                continue\n            # also keep suffix to avoid confusing nam: \"Bitcoin Token\" -> \"Bitcoin\"\n            if name[:-len(s)].strip().lower() == 'bitcoin':\n                continue\n            coin['reduced-name'] = True\n            name = name[:-len(s)]\n            break\n\n    coin['nn'] = coingecko_normalize_name(name)\n\n    if len(coin['nn']) < len(coin['ns']):\n        if 'reduced-name' in coin:\n            coin['reduced-name'] = False\n            name = coin['name']\n            coin['nn'] = coingecko_normalize_name(name)\n        elif not has_many_caps(name):\n            return coin['ns']\n\n    if not coin['ns']:  # coin['symbol'] may be an emoji that is striped when normalized\n        return coin['nn']\n\n    if coin.get('reduced-name') and coin['ns'].upper() != coin['nn'].upper():\n        return coin['ns']\n\n    i = coin['nn'].find('.')  # if there is a dot in normalized name => prefer the normalized symbol\n    if i >= 0:\n        if i > 1 and coin['nn'][i - 1].isdigit() and coin['nn'][i + 1].isdigit():\n            pass  # except when the dot separates digits\n        else:\n            return coin['ns']\n\n    if is_name_short(coin) and has_many_caps(name):\n        return coin['nn']\n\n    if 1.5 * len(coin['ns']) > len(coin['nn']) and any(c.islower() for c in coin['ns']):\n        return coin['nn']\n\n    return coin['ns']\n\n\ndef coingecko_symbols() -> Dict[str, str]:\n    r = None\n    intermediate = defaultdict(list)\n    try:\n        r = requests.get('https://api.coingecko.com/api/v3/coins/list')\n        all_coins = r.json()\n        # First pass: generate & compare normalized symbol/name, and then select the most pertinent\n        for coin in all_coins:\n            normalized = coingecko_normalize_all(coin)\n            intermediate[normalized].append(coin)\n            # Above line keeps together the coins having the same normalized symbol.\n            # To reduce collision, the coin['name'] is sometimes used in lieu of the coin['symbol'].\n            # The coin['name'] is not capitalized because lower case letters may be meaningful: cETH, yUSD, DATx, zLOT\n    except Exception as why:\n        raise_failure_explanation('COINGECKO', why, {\"\": r})\n\n    final = coingecko_second_pass(intermediate)\n    return coingecko_third_pass(final)\n\n\ndef coingecko_second_pass(intermediate: Dict[str, List[dict]]) -> Dict[str, List[dict]]:\n    # Second pass: fixes most of the symbol collisions\n    final = defaultdict(list)\n    for normalized, coins in intermediate.items():\n        if len(coins) == 1:\n            final[normalized].append(coins[0])\n            continue\n        set_normalized = False\n        for i in range(len(coins)):\n            if normalized == coins[i]['nn']:\n                coin = coins.pop(i)\n                final[normalized].append(coin)\n                set_normalized = True\n                break\n        rest: List[dict] = []\n        for coin in coins:\n            if '%' in coin['name']:\n                if len(coins) == 1:\n                    n = coin['ns']\n                else:\n                    n = coingecko_normalize_name(coin['id'])\n                final[n].append(coin)\n            else:\n                rest.append(coin)\n        if not rest:\n            continue\n        if not set_normalized:\n            rest.sort(key=lambda coin: len(coin['nn']), reverse=True)  # sort by the length of the normalized name\n            coin = rest.pop(0)\n            final[normalized].append(coin)\n        for coin in rest:\n            if coin['nn'] not in intermediate:\n                n = coin['nn']\n            elif coin.get('reduced-name'):\n                n = coingecko_normalize_name(coin['name'])\n            else:\n                n = coingecko_normalize_name(coin['id'])\n            final[n].append(coin)\n    return final\n\n\ndef coingecko_third_pass(final: Dict[str, List[dict]]) -> Dict[str, str]:\n    # Third pass: fixes some remaining collisions and fills the result\n    symbols = {}\n    for normalized, coins in final.items():\n        if len(coins) == 1:\n            symbols[normalized] = coins[0]['id']\n            continue\n        set_normalized = False\n        for i in range(len(coins)):\n            if normalized == coins[i]['nn']:\n                coin = coins.pop(i)\n                symbols[normalized] = coin['id']\n                set_normalized = True\n                break\n        rest: List[dict] = []\n        for coin in coins:\n            if '%' in coin['name']:\n                if len(coins) == 1:\n                    n = coin['ns']\n                else:\n                    n = coingecko_normalize_name(coin['id'])\n                symbols[n] = coin['id']\n            else:\n                rest.append(coin)\n        if not rest:\n            continue\n        if not set_normalized:\n            rest.sort(key=lambda coin: len(coin['nn']), reverse=True)  # sort by the length of the normalized name\n            coin = rest.pop(0)\n            symbols[normalized] = coin['id']\n        for coin in rest:\n            if coin['nn'] not in final:\n                n = coin['nn']\n            elif coin.get('reduced-name'):\n                n = coingecko_normalize_name(coin['name'])\n            else:\n                n = coingecko_normalize_name(coin['id'])\n            symbols[n] = coin['id']\n    return symbols\n\n\ndef whale_alert_coins(key_id: str) -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get(f'https://api.whale-alert.io/v1/status?api_key={key_id}')\n        # Same symbols, but on different blockchains (for instance USDT), are naturally overwritten.\n        return {s.upper(): s for b in r.json()['blockchains'] for s in b['symbols'] if s}\n    except Exception as why:\n        raise_failure_explanation('WHALES_ALERT', why, {\"\": r})\n\n\n_exchange_function_map = {\n    BITFINEX: bitfinex_symbols,\n    BITFLYER: bitflyer_symbols,\n    COINBASE: coinbase_symbols,\n    GEMINI: gemini_symbols,\n    HITBTC: hitbtc_symbols,\n    POLONIEX: poloniex_symbols,\n    PROBIT: probit_symbols,\n    BITSTAMP: bitstamp_symbols,\n    KRAKEN: kraken_symbols,\n    KRAKEN + 'REST': kraken_rest_symbols,\n    BINANCE: binance_symbols,\n    BINANCE_US: binance_us_symbols,\n    BINANCE_FUTURES: binance_futures_symbols,\n    BINANCE_DELIVERY: binance_delivery_symbols,\n    BLOCKCHAIN: blockchain_symbols,\n    EXX: exx_symbols,\n    HUOBI: huobi_symbols,\n    HUOBI_DM: huobi_dm_symbols,\n    HUOBI_SWAP: huobi_swap_symbols,\n    OKCOIN: okcoin_symbols,\n    OKEX: okex_symbols,\n    BYBIT: bybit_symbols,\n    FTX: ftx_symbols,\n    FTX_US: ftx_us_symbols,\n    BITTREX: bittrex_symbols,\n    BITCOINCOM: bitcoincom_symbols,\n    BITMAX: bitmax_symbols,\n    UPBIT: upbit_symbols,\n    GATEIO: gateio_symbols,\n    BITMEX: bitmex_symbols,\n    DERIBIT: deribit_symbols,\n    KRAKEN_FUTURES: kraken_future_symbols,\n    COINGECKO: coingecko_symbols,\n    WHALE_ALERT: whale_alert_coins\n}\n",
        "source_code_len": 30534,
        "target_code": "associated with this software.\n'''\nfrom typing import Dict, Tuple\n\n\nclass _Symbols:\n    def __init__(self):\n        self.data = {}\n\n    def set(self, exchange: str, normalized: dict, exchange_info: dict):\n        self.data[exchange] = {}\n        self.data[exchange]['normalized'] = normalized\n        self.data[exchange]['info'] = exchange_info\n\n    def get(self, exchange: str) -> Tuple[Dict, Dict]:\n        return self.data[exchange]['normalized'], self.data[exchange]['info']\n\n    def populated(self, exchange: str) -> bool:\n        return exchange in self.data\n\n\nSymbols = _Symbols()\n",
        "target_code_len": 588,
        "diff_format": "@@ -5,845 +5,22 @@\n associated with this software.\n+'''\n+from typing import Dict, Tuple\n \n \n-Symbol generation code for exchanges\n-'''\n+class _Symbols:\n+    def __init__(self):\n+        self.data = {}\n \n-import logging\n-import string\n-import time\n-from collections import defaultdict\n-from typing import Dict, List, Optional, Tuple\n+    def set(self, exchange: str, normalized: dict, exchange_info: dict):\n+        self.data[exchange] = {}\n+        self.data[exchange]['normalized'] = normalized\n+        self.data[exchange]['info'] = exchange_info\n \n-import requests\n-from requests import Response\n+    def get(self, exchange: str) -> Tuple[Dict, Dict]:\n+        return self.data[exchange]['normalized'], self.data[exchange]['info']\n \n-from cryptofeed.defines import *\n+    def populated(self, exchange: str) -> bool:\n+        return exchange in self.data\n \n \n-LOG = logging.getLogger('feedhandler')\n-\n-SYMBOL_SEP = '-'\n-\n-_symbols_retrieval_cache: Dict[str, Dict[str, str]] = {}\n-_exchange_info = defaultdict(lambda: defaultdict(dict))\n-\n-\n-_kraken_futures_product_type = {\n-    'FI': 'Inverse Futures',\n-    'FV': 'Vanilla Futures',\n-    'PI': 'Perpetual Inverse Futures',\n-    'PV': 'Perpetual Vanilla Futures',\n-    'IN': 'Real Time Index',\n-    'RR': 'Reference Rate',\n-}\n-\n-\n-def raise_failure_explanation(feed_id: str, exception: BaseException, responses: Dict[str, Optional[Response]]):\n-    LOG.critical('%s: encountered %r while processing response from exchange API', feed_id, exception)\n-    if len(responses) > 1:\n-        LOG.critical('%s: content of one of the %s responses was unexpected', feed_id, len(responses))\n-    for url, r in responses.items():\n-        if url:\n-            LOG.critical('%s: requested URL: %s', feed_id, url)\n-        if r:\n-            LOG.critical('%s: unexpected response: %s', feed_id, r.text)\n-    raise ValueError(f'Cryptofeed stopped because of an unexpected response from {feed_id}') from exception\n-\n-\n-def set_symbol_separator(separator: str):\n-    global SYMBOL_SEP\n-    SYMBOL_SEP = separator\n-\n-\n-def get_symbol_separator() -> str:\n-    global SYMBOL_SEP\n-    return SYMBOL_SEP\n-\n-\n-def gen_symbols(exchange: str, key_id=None) -> Dict[str, str]:\n-    if exchange not in _symbols_retrieval_cache:\n-        LOG.info(\"%s: Getting list of symbols\", exchange)\n-        symbols = _exchange_function_map[exchange](key_id) if key_id else _exchange_function_map[exchange]()\n-        LOG.info(\"%s: %s symbols\", exchange, len(symbols))\n-\n-        # log all retrieved symbols using debug level\n-        for normalized, exch_sym in sorted(symbols.items()):\n-            LOG.debug('%s: id-from-exch -> normalized: %-35s-> %s', exchange, exch_sym, normalized)\n-\n-        _symbols_retrieval_cache[exchange] = symbols\n-    return _symbols_retrieval_cache[exchange]\n-\n-\n-def _binance_symbols(endpoint: str, exchange: str):\n-    r = None\n-    try:\n-        ret = {}\n-        r = requests.get(endpoint)\n-        for symbol in r.json()['symbols']:\n-            if symbol.get('status', 'TRADING') != \"TRADING\":\n-                continue\n-            if symbol.get('contractStatus', 'TRADING') != \"TRADING\":\n-                continue\n-            split = len(symbol['baseAsset'])\n-            normalized = symbol['symbol'][:split] + SYMBOL_SEP + symbol['symbol'][split:]\n-            ret[normalized] = symbol['symbol']\n-            _exchange_info[exchange]['tick_size'][normalized] = symbol['filters'][0]['tickSize']\n-            if \"contractType\" in symbol:\n-                _exchange_info[exchange]['contract_type'][normalized] = symbol['contractType']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation(exchange, why, {endpoint: r})\n-\n-\n-def binance_symbols() -> Dict[str, str]:\n-    return _binance_symbols('https://api.binance.com/api/v3/exchangeInfo', BINANCE)\n-\n-\n-def binance_us_symbols() -> Dict[str, str]:\n-    return _binance_symbols('https://api.binance.us/api/v3/exchangeInfo', BINANCE_US)\n-\n-\n-def binance_futures_symbols() -> Dict[str, str]:\n-    base = _binance_symbols('https://fapi.binance.com/fapi/v1/exchangeInfo', BINANCE_FUTURES)\n-    add = {}\n-    for symbol, orig in base.items():\n-        if \"_\" in orig:\n-            continue\n-        add[f\"{symbol}-PINDEX\"] = f\"p{orig}\"\n-    base.update(add)\n-    return base\n-\n-\n-def binance_delivery_symbols() -> Dict[str, str]:\n-    return _binance_symbols('https://dapi.binance.com/dapi/v1/exchangeInfo', BINANCE_DELIVERY)\n-\n-\n-def bitfinex_symbols() -> Dict[str, str]:\n-    # doc: https://docs.bitfinex.com/docs/ws-general#supported-pairs\n-    r1 = r2 = None\n-    try:\n-        r1 = requests.get('https://api.bitfinex.com/v2/tickers?symbols=ALL')\n-        r2 = requests.get('https://api-pub.bitfinex.com/v2/conf/pub:map:currency:sym')\n-        tickers: List[List[str]] = r1.json()\n-        norm: List[Tuple[str, str]] = r2.json()[0]\n-        norm: Dict[str, str] = dict(norm)\n-        for k, v in dict(norm).items():\n-            if k[-2:] == 'F0' or '-' in v:  # Do not convert BTCF0 -> BTC or PBTCETH -> PBTC-ETH\n-                del norm[k]\n-        norm['BCHN'] = 'BCH'  # Bitfinex uses BCHN, other exchanges use BCH\n-\n-        ret = {}\n-        for symbol in [t[0] for t in tickers]:\n-            if symbol[0] == 'f':\n-                normalized = norm.get(symbol[1:], symbol[1:])\n-            else:\n-                if len(symbol) == 7:\n-                    base, quote = symbol[1:4], symbol[4:]\n-                else:\n-                    base, quote = symbol[1:].split(':')\n-                    assert ':' in symbol\n-                normalized = norm.get(base, base) + SYMBOL_SEP + norm.get(quote, quote)\n-            ret[normalized.upper()] = symbol\n-        return ret\n-    except ValueError as why:\n-        raise_failure_explanation('BITFINEX', why, {\"tickers?symbols=ALL\": r1, \"pub:map:currency:sym\": r2})\n-\n-\n-def bitflyer_symbols() -> Dict[str, str]:\n-    endpoint = r = None\n-    try:\n-        ret = {}\n-        endpoints = ['https://api.bitflyer.com/v1/getmarkets/eu', 'https://api.bitflyer.com/v1/getmarkets/usa', 'https://api.bitflyer.com/v1/getmarkets']\n-        for endpoint in endpoints:\n-            r = requests.get(endpoint)\n-            for entry in r.json():\n-                normalized = entry['product_code'].replace(\"_\", SYMBOL_SEP)\n-                ret[normalized] = entry['product_code']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('BITFLYER', why, {endpoint: r})\n-\n-\n-def bybit_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.bybit.com/v2/public/symbols')\n-        ret = {}\n-        for symbol in r.json()['result']:\n-            quote = symbol['quote_currency']\n-            if not symbol['name'].endswith(quote):\n-                base, contract = symbol['name'].split(quote)\n-                normalized = f\"{base}{SYMBOL_SEP}{quote}-{contract}\"\n-            else:\n-                normalized = f\"{symbol['base_currency']}{SYMBOL_SEP}{quote}\"\n-            ret[normalized] = symbol['name']\n-            _exchange_info[BYBIT]['tick_size'][normalized] = symbol['price_filter']['tick_size']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('BYBIT', why, {\"\": r})\n-\n-\n-def _ftx_helper(endpoint: str, exchange: str):\n-    r = None\n-    try:\n-        r = requests.get(endpoint)\n-        ret = {}\n-        for data in r.json()['result']:\n-            normalized = data['name'].replace(\"/\", SYMBOL_SEP)\n-            symbol = data['name']\n-            ret[normalized] = symbol\n-            _exchange_info[exchange]['tick_size'][normalized] = data['priceIncrement']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation(exchange, why, {endpoint: r})\n-\n-\n-def ftx_symbols() -> Dict[str, str]:\n-    return _ftx_helper('https://ftx.com/api/markets', FTX)\n-\n-\n-def ftx_us_symbols() -> Dict[str, str]:\n-    return _ftx_helper('https://ftx.us/api/markets', FTX_US)\n-\n-\n-def coinbase_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.pro.coinbase.com/products')\n-        ret = {}\n-        for data in r.json():\n-            normalized = data['id'].replace(\"-\", SYMBOL_SEP)\n-            ret[normalized] = data['id']\n-            _exchange_info[COINBASE]['tick_size'][normalized] = data['quote_increment']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('COINBASE', why, {\"\": r})\n-\n-\n-def gemini_symbols(*args) -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.gemini.com/v1/symbols')\n-        ret = {}\n-        for symbol in r.json():\n-            std = f\"{symbol[:-3]}{SYMBOL_SEP}{symbol[-3:]}\"\n-            std = std.upper()\n-            ret[std] = symbol.upper()\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('GEMINI', why, {\"\": r})\n-\n-\n-def hitbtc_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        ret = {}\n-        r = requests.get('https://api.hitbtc.com/api/2/public/symbol')\n-        for symbol in r.json():\n-            split = len(symbol['baseCurrency'])\n-            normalized = symbol['id'][:split] + SYMBOL_SEP + symbol['id'][split:]\n-            ret[normalized] = symbol['id']\n-            _exchange_info[HITBTC]['tick_size'][normalized] = symbol['tickSize']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('HITBTC', why, {\"\": r})\n-\n-\n-def poloniex_id_symbol_mapping():\n-    r = None\n-    try:\n-        r = requests.get('https://poloniex.com/public?command=returnTicker')\n-        symbols = r.json()\n-        ret = {}\n-        for symbol in symbols:\n-            ret[symbols[symbol]['id']] = symbol\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('POLONIEX', why, {\"\": r})\n-\n-\n-def poloniex_symbols() -> Dict[str, str]:\n-    ret = {}\n-    for _, value in poloniex_id_symbol_mapping().items():\n-        std = value.replace(\"STR\", \"XLM\")\n-        quote, base = std.split(\"_\")\n-        ret[quote + SYMBOL_SEP + base] = value\n-    return ret\n-\n-\n-def bitstamp_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://www.bitstamp.net/api/v2/trading-pairs-info/')\n-        ret = {}\n-        for data in r.json():\n-            normalized = data['name'].replace(\"/\", SYMBOL_SEP)\n-            symbol = data['url_symbol']\n-            ret[normalized] = symbol\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('BITSTAMP', why, {\"\": r})\n-\n-\n-def kraken_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.kraken.com/0/public/AssetPairs')\n-        data = r.json()\n-        ret = {}\n-        for symbol in data['result']:\n-            if 'wsname' not in data['result'][symbol] or '.d' in symbol:\n-                # https://blog.kraken.com/post/259/introducing-the-kraken-dark-pool/\n-                # .d is for dark pool symbols\n-                continue\n-\n-            base, quote = data['result'][symbol]['wsname'].split(\"/\")\n-\n-            normalized = f\"{base}{SYMBOL_SEP}{quote}\"\n-            exch = data['result'][symbol]['wsname']\n-            normalized = normalized.replace('XBT', 'BTC')\n-            normalized = normalized.replace('XDG', 'DOG')\n-            ret[normalized] = exch\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('KRAKEN', why, {\"\": r})\n-\n-\n-def kraken_rest_symbols() -> Dict[str, str]:\n-    return {normalized: exchange.replace(\"/\", \"\") for normalized, exchange in kraken_symbols().items()}\n-\n-\n-def exx_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.exx.com/data/v1/tickers')\n-        exchange = [key.upper() for key in r.json().keys()]\n-        symbols = [key.replace(\"_\", SYMBOL_SEP) for key in exchange]\n-        return dict(zip(symbols, exchange))\n-    except Exception as why:\n-        raise_failure_explanation('EXX', why, {\"\": r})\n-\n-\n-def huobi_common_symbols(url: str):\n-    r = None\n-    try:\n-        r = requests.get(url)\n-        ret = {}\n-        for e in r.json()['data']:\n-            if e['state'] == 'offline':\n-                continue\n-            normalized = f\"{e['base-currency'].upper()}{SYMBOL_SEP}{e['quote-currency'].upper()}\"\n-            symbol = f\"{e['base-currency']}{e['quote-currency']}\"\n-            ret[normalized] = symbol\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('HUOBI', why, {url: r})\n-\n-\n-def huobi_symbols() -> Dict[str, str]:\n-    return huobi_common_symbols('https://api.huobi.pro/v1/common/symbols')\n-\n-\n-def huobi_us_symbols() -> Dict[str, str]:\n-    return huobi_common_symbols('https://api.huobi.com/v1/common/symbols')\n-\n-\n-def huobi_dm_symbols() -> Dict[str, str]:\n-    \"\"\"\n-    Mapping is, for instance: {\"BTC_CW\":\"BTC190816\"}\n-    See comments in exchange/huobi_dm.py\n-    \"\"\"\n-    mapping = {\n-        \"this_week\": \"CW\",\n-        \"next_week\": \"NW\",\n-        \"quarter\": \"CQ\",\n-        \"next_quarter\": \"NQ\"\n-    }\n-    r = None\n-    try:\n-        r = requests.get('https://www.hbdm.com/api/v1/contract_contract_info')\n-        symbols = {}\n-        for e in r.json()['data']:\n-            symbols[f\"{e['symbol']}_{mapping[e['contract_type']]}\"] = e['contract_code']\n-            _exchange_info[HUOBI_DM]['tick_size'][e['contract_code']] = e['price_tick']\n-            _exchange_info[HUOBI_DM]['short_code_mappings'][f\"{e['symbol']}_{mapping[e['contract_type']]}\"] = e['contract_code']\n-        return symbols\n-    except Exception as why:\n-        raise_failure_explanation('HUOBI_DM', why, {\"\": r})\n-\n-\n-def huobi_swap_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.hbdm.com/swap-api/v1/swap_contract_info')\n-        symbols = {}\n-        for e in r.json()['data']:\n-            symbols[e['contract_code']] = e['contract_code']\n-            _exchange_info[HUOBI_SWAP]['tick_size'][e['contract_code']] = e['price_tick']\n-        return symbols\n-    except Exception as why:\n-        raise_failure_explanation('HUOBI_SWAP', why, {\"\": r})\n-\n-\n-def okcoin_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://www.okcoin.com/api/spot/v3/instruments')\n-        ret = {}\n-        for e in r.json():\n-            ret[e['instrument_id']] = e['instrument_id']\n-            _exchange_info[OKCOIN]['tick_size'][e['instrument_id']] = e['tick_size']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('OKCOIN', why, {\"\": r})\n-\n-\n-def okex_symbols(*args) -> Dict[str, str]:\n-    urls = ['https://www.okex.com/api/spot/v3/instruments',\n-            'https://www.okex.com/api/swap/v3/instruments',\n-            'https://www.okex.com/api/futures/v3/instruments']\n-    urls = urls + okex_compute_option_urls_from_underlyings()\n-\n-    symbols: Dict[str, str] = {}\n-    for u in urls:\n-        time.sleep(0.2)\n-        symbols.update(okex_symbols_from_one_url(u))\n-\n-    for symbol in symbols:\n-        instrument_type = 'futures'\n-        dash_count = symbol.count(get_symbol_separator())\n-        if dash_count == 1:  # BTC-USDT\n-            instrument_type = 'spot'\n-        if dash_count == 4:  # BTC-USD-201225-35000-P\n-            instrument_type = 'option'\n-        if symbol[-4:] == \"SWAP\":  # BTC-USDT-SWAP\n-            instrument_type = 'swap'\n-\n-        _exchange_info[OKEX]['instrument_type'][symbol] = instrument_type\n-\n-    return symbols\n-\n-\n-def okex_compute_option_urls_from_underlyings() -> List[str]:\n-    url = 'https://www.okex.com/api/option/v3/underlying'\n-    r = None\n-    try:\n-        r = requests.get(url)\n-        return [f'https://www.okex.com/api/option/v3/instruments/{underlying}' for underlying in r.json()]\n-    except Exception as why:\n-        raise_failure_explanation('OKEX', why, {url: r})\n-\n-\n-def okex_symbols_from_one_url(url: str) -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get(url)\n-        ret = {}\n-        for e in r.json():\n-            ret[e['instrument_id']] = e['instrument_id']\n-            _exchange_info[OKEX]['tick_size'][e['instrument_id']] = e['tick_size']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('OKEX', why, {url: r})\n-\n-\n-def bittrex_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.bittrex.com/api/v1.1/public/getmarkets')\n-        r = r.json()['result']\n-        return {f\"{e['MarketCurrency']}{SYMBOL_SEP}{e['BaseCurrency']}\": e['MarketName'] for e in r if e['IsActive']}\n-    except Exception as why:\n-        raise_failure_explanation('BITTREX', why, {\"\": r})\n-\n-\n-def bitcoincom_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.exchange.bitcoin.com/api/2/public/symbol')\n-        return {f\"{data['baseCurrency']}{SYMBOL_SEP}{data['quoteCurrency'].replace('USD', 'USDT')}\": data['id'] for data in r.json()}\n-    except Exception as why:\n-        raise_failure_explanation('BITCOINCOM', why, {\"\": r})\n-\n-\n-def bitmax_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://bitmax.io/api/pro/v1/products')\n-        ret = {}\n-        for entry in r.json()['data']:\n-            # Only \"Normal\" status symbols are tradeable\n-            if entry['status'] == 'Normal':\n-                normalized = f\"{entry['baseAsset']}{SYMBOL_SEP}{entry['quoteAsset']}\"\n-                ret[normalized] = entry['symbol']\n-                _exchange_info[BITMAX]['tick_size'][normalized] = entry['tickSize']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('BITMAX', why, {\"\": r})\n-\n-\n-def upbit_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.upbit.com/v1/market/all')\n-        return {f\"{data['market'].split('-')[1]}{SYMBOL_SEP}{data['market'].split('-')[0]}\": data['market'] for data in r.json()}\n-    except Exception as why:\n-        raise_failure_explanation('UPBIT', why, {\"\": r})\n-\n-\n-def blockchain_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get(\"https://api.blockchain.com/mercury-gateway/v1/instruments\")\n-        return {data[\"symbol\"].replace(\"-\", SYMBOL_SEP): data[\"symbol\"] for data in r.json()}\n-    except Exception as why:\n-        raise_failure_explanation('BLOCKCHAIN', why, {\"\": r})\n-\n-\n-def gateio_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get(\"https://api.gateio.ws/api/v4/spot/currency_pairs\")\n-        return {data[\"id\"].replace(\"_\", SYMBOL_SEP): data['id'] for data in r.json()}\n-    except Exception as why:\n-        raise_failure_explanation('GATEIO', why, {\"\": r})\n-\n-\n-def bitmex_symbols() -> Dict[str, str]:\n-    r = None\n-    ret = {}\n-    try:\n-        r = requests.get(\"https://www.bitmex.com/api/v1/instrument/active\")\n-        for entry in r.json():\n-            components = []\n-            components.append(entry['rootSymbol'])\n-            components.append(entry['quoteCurrency'])\n-\n-            if entry['expiry']:\n-                components.append(entry['symbol'][-3:])\n-\n-            normalized = SYMBOL_SEP.join(components)\n-            normalized = normalized.replace(\"XBT\", \"BTC\")\n-            ret[normalized] = entry['symbol']\n-            _exchange_info[BITMEX]['tick_size'][normalized] = entry['tickSize']\n-\n-            if entry['expiry']:\n-                _exchange_info[BITMEX]['expiry'][normalized] = entry['expiry']\n-\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('BITMEX', why, {\"\": r})\n-\n-\n-def deribit_symbols() -> Dict[str, str]:\n-    url = r = None\n-    ret = {}\n-    try:\n-        # TODO: get currencies from https://www.deribit.com/api/v2/public/get_currencies\n-        currencies = ['BTC', 'ETH']\n-        for c in currencies:\n-            url = f\"https://www.deribit.com/api/v2/public/get_instruments?currency={c}&expired=false\"\n-            r = requests.get(url)\n-            for entry in r.json()['result']:\n-                split = entry['instrument_name'].split(\"-\")\n-                normalized = split[0] + SYMBOL_SEP + entry['quote_currency'] + \"-\" + '-'.join(split[1:])\n-                ret[normalized] = entry['instrument_name']\n-                _exchange_info[DERIBIT]['tick_size'][normalized] = entry['tick_size']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('DERIBIT', why, {url: r})\n-\n-\n-def kraken_future_symbols() -> Dict[str, str]:\n-    r = None\n-    ret = {}\n-    try:\n-        r = requests.get('https://futures.kraken.com/derivatives/api/v3/instruments')\n-        data = r.json()['instruments']\n-        for entry in data:\n-            if not entry['tradeable']:\n-                continue\n-            normalized = entry['symbol'].upper().replace(\"_\", \"-\")\n-            symbol = normalized[3:6] + SYMBOL_SEP + normalized[6:9]\n-            normalized = normalized.replace(normalized[3:9], symbol)\n-            normalized = normalized.replace('XBT', 'BTC')\n-\n-            _exchange_info[KRAKEN_FUTURES]['tick_size'][normalized] = entry['tickSize']\n-            _exchange_info[KRAKEN_FUTURES]['contract_size'][normalized] = entry['contractSize']\n-            _exchange_info[KRAKEN_FUTURES]['underlying'][normalized] = entry['underlying']\n-            _exchange_info[KRAKEN_FUTURES]['product_type'][normalized] = _kraken_futures_product_type[normalized[:2]]\n-            ret[normalized] = entry['symbol']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('KRAKEN_FUTURES', why, {\"\": r})\n-\n-\n-def probit_symbols() -> Dict[str, str]:\n-    # doc: https://docs-en.probit.com/reference-link/market\n-    r = None\n-    try:\n-        r = requests.get('https://api.probit.com/api/exchange/v1/market')\n-        return {entry['id']: entry['id'] for entry in r.json()['data']}\n-    except Exception as why:\n-        raise_failure_explanation('PROBIT', why, {\"\": r})\n-\n-\n-def coingecko_normalize_symbol(symbol: str) -> str:\n-    # keep digits, letters and dots, replace others by space\n-    symbol = ''.join(c if c.isalnum() or c in ('.', '+') else ' ' for c in symbol)\n-    return coingecko_normalize(symbol.upper())\n-\n-\n-def coingecko_normalize_name(name: str) -> str:\n-    # keep digits and letters, replace others by space (except when only composed by upper case letters, digits and dots)\n-    if not all(c.isupper() or c.isdigit() or c == '.' for c in name):\n-        name = ''.join(c if c.isalnum() else ' ' for c in name)\n-    return coingecko_normalize(name)\n-\n-\n-def coingecko_normalize(sym: str) -> str:\n-    sym = sym.strip()\n-    # do not concatenate numbers => separate them with a dot\n-    sym = list(sym)\n-    if len(sym) > 4:\n-        for i in range(2, len(sym) - 1):\n-            if sym[i] == ' ' and sym[i - 1].isdigit() and sym[i + 1].isdigit():\n-                sym[i] = '.'\n-    sym = ''.join(sym)\n-    # concatenate space-separated words => use CamelCase to distinguish the words\n-    if ' ' in sym:\n-        if sum(c.islower() for c in sym):  # if there is at least one lower case letter\n-            sym = ' '.join(word[0].upper() + word[1:] for word in sym.split())  # Just capitalize initial letter of each word\n-        else:  # CoinGecko may provide full upper-case as for \"THE STONE COIN\"\n-            sym = string.capwords(sym)  # capwords converts \"THE STONE COIN\" to \"The Stone Coin\"\n-        sym = sym.replace(' ', '')  # concatenate words\n-    return sym\n-\n-\n-def is_name_short(coin: dict) -> bool:\n-    \"\"\"return True if the coin name is enough short compared to the coin symbol.\"\"\"\n-    return len(coin['name']) <= max(5, len(coin['symbol']) + 1)\n-\n-\n-def has_many_caps(name: str) -> bool:\n-    \"\"\"return True if the symbol contains enough upper case letters, False if empty.\"\"\"\n-    return str and sum(c.islower() for c in name) < (len(name) / 2)\n-\n-\n-def coingecko_normalize_all(coin: dict):\n-    SYMBOL_TO_NORMALIZED = {'miota': 'IOTA'}\n-    normalized = SYMBOL_TO_NORMALIZED.get(coin['symbol'])\n-    if normalized:\n-        coin['ns'] = coin['nn'] = normalized\n-        return normalized\n-\n-    # ns = normalized symbol, nn = normalized name\n-    coin['ns'] = coingecko_normalize_symbol(coin['symbol'])\n-\n-    ID_SUFFIX = '-bitcoin-token'\n-    if coin['id'][-len(ID_SUFFIX):] == ID_SUFFIX:\n-        coin['nn'] = 'BTC' + coin['ns']\n-        return coin['nn']\n-\n-    name = coin['name']\n-\n-    prefixes = ('The ', 'the ')\n-    for p in prefixes:\n-        if name[:len(p)] == p:\n-            coin['reduced-name'] = True\n-            name = name[len(p):]\n-            break\n-\n-    suffixes = ('coin', 'coins', 'money', 'finance', 'protocol', 'reward', 'rewards', 'token')\n-    for s in suffixes:\n-        if len(name) > len(s) and name[-len(s):].lower() == s:\n-            # but keep suffix when lower-case concatenated\n-            if name[-len(s)].islower() and name[-len(s) - 1] != ' ':\n-                continue\n-            # also keep suffix to avoid confusing nam: \"Bitcoin Token\" -> \"Bitcoin\"\n-            if name[:-len(s)].strip().lower() == 'bitcoin':\n-                continue\n-            coin['reduced-name'] = True\n-            name = name[:-len(s)]\n-            break\n-\n-    coin['nn'] = coingecko_normalize_name(name)\n-\n-    if len(coin['nn']) < len(coin['ns']):\n-        if 'reduced-name' in coin:\n-            coin['reduced-name'] = False\n-            name = coin['name']\n-            coin['nn'] = coingecko_normalize_name(name)\n-        elif not has_many_caps(name):\n-            return coin['ns']\n-\n-    if not coin['ns']:  # coin['symbol'] may be an emoji that is striped when normalized\n-        return coin['nn']\n-\n-    if coin.get('reduced-name') and coin['ns'].upper() != coin['nn'].upper():\n-        return coin['ns']\n-\n-    i = coin['nn'].find('.')  # if there is a dot in normalized name => prefer the normalized symbol\n-    if i >= 0:\n-        if i > 1 and coin['nn'][i - 1].isdigit() and coin['nn'][i + 1].isdigit():\n-            pass  # except when the dot separates digits\n-        else:\n-            return coin['ns']\n-\n-    if is_name_short(coin) and has_many_caps(name):\n-        return coin['nn']\n-\n-    if 1.5 * len(coin['ns']) > len(coin['nn']) and any(c.islower() for c in coin['ns']):\n-        return coin['nn']\n-\n-    return coin['ns']\n-\n-\n-def coingecko_symbols() -> Dict[str, str]:\n-    r = None\n-    intermediate = defaultdict(list)\n-    try:\n-        r = requests.get('https://api.coingecko.com/api/v3/coins/list')\n-        all_coins = r.json()\n-        # First pass: generate & compare normalized symbol/name, and then select the most pertinent\n-        for coin in all_coins:\n-            normalized = coingecko_normalize_all(coin)\n-            intermediate[normalized].append(coin)\n-            # Above line keeps together the coins having the same normalized symbol.\n-            # To reduce collision, the coin['name'] is sometimes used in lieu of the coin['symbol'].\n-            # The coin['name'] is not capitalized because lower case letters may be meaningful: cETH, yUSD, DATx, zLOT\n-    except Exception as why:\n-        raise_failure_explanation('COINGECKO', why, {\"\": r})\n-\n-    final = coingecko_second_pass(intermediate)\n-    return coingecko_third_pass(final)\n-\n-\n-def coingecko_second_pass(intermediate: Dict[str, List[dict]]) -> Dict[str, List[dict]]:\n-    # Second pass: fixes most of the symbol collisions\n-    final = defaultdict(list)\n-    for normalized, coins in intermediate.items():\n-        if len(coins) == 1:\n-            final[normalized].append(coins[0])\n-            continue\n-        set_normalized = False\n-        for i in range(len(coins)):\n-            if normalized == coins[i]['nn']:\n-                coin = coins.pop(i)\n-                final[normalized].append(coin)\n-                set_normalized = True\n-                break\n-        rest: List[dict] = []\n-        for coin in coins:\n-            if '%' in coin['name']:\n-                if len(coins) == 1:\n-                    n = coin['ns']\n-                else:\n-                    n = coingecko_normalize_name(coin['id'])\n-                final[n].append(coin)\n-            else:\n-                rest.append(coin)\n-        if not rest:\n-            continue\n-        if not set_normalized:\n-            rest.sort(key=lambda coin: len(coin['nn']), reverse=True)  # sort by the length of the normalized name\n-            coin = rest.pop(0)\n-            final[normalized].append(coin)\n-        for coin in rest:\n-            if coin['nn'] not in intermediate:\n-                n = coin['nn']\n-            elif coin.get('reduced-name'):\n-                n = coingecko_normalize_name(coin['name'])\n-            else:\n-                n = coingecko_normalize_name(coin['id'])\n-            final[n].append(coin)\n-    return final\n-\n-\n-def coingecko_third_pass(final: Dict[str, List[dict]]) -> Dict[str, str]:\n-    # Third pass: fixes some remaining collisions and fills the result\n-    symbols = {}\n-    for normalized, coins in final.items():\n-        if len(coins) == 1:\n-            symbols[normalized] = coins[0]['id']\n-            continue\n-        set_normalized = False\n-        for i in range(len(coins)):\n-            if normalized == coins[i]['nn']:\n-                coin = coins.pop(i)\n-                symbols[normalized] = coin['id']\n-                set_normalized = True\n-                break\n-        rest: List[dict] = []\n-        for coin in coins:\n-            if '%' in coin['name']:\n-                if len(coins) == 1:\n-                    n = coin['ns']\n-                else:\n-                    n = coingecko_normalize_name(coin['id'])\n-                symbols[n] = coin['id']\n-            else:\n-                rest.append(coin)\n-        if not rest:\n-            continue\n-        if not set_normalized:\n-            rest.sort(key=lambda coin: len(coin['nn']), reverse=True)  # sort by the length of the normalized name\n-            coin = rest.pop(0)\n-            symbols[normalized] = coin['id']\n-        for coin in rest:\n-            if coin['nn'] not in final:\n-                n = coin['nn']\n-            elif coin.get('reduced-name'):\n-                n = coingecko_normalize_name(coin['name'])\n-            else:\n-                n = coingecko_normalize_name(coin['id'])\n-            symbols[n] = coin['id']\n-    return symbols\n-\n-\n-def whale_alert_coins(key_id: str) -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get(f'https://api.whale-alert.io/v1/status?api_key={key_id}')\n-        # Same symbols, but on different blockchains (for instance USDT), are naturally overwritten.\n-        return {s.upper(): s for b in r.json()['blockchains'] for s in b['symbols'] if s}\n-    except Exception as why:\n-        raise_failure_explanation('WHALES_ALERT', why, {\"\": r})\n-\n-\n-_exchange_function_map = {\n-    BITFINEX: bitfinex_symbols,\n-    BITFLYER: bitflyer_symbols,\n-    COINBASE: coinbase_symbols,\n-    GEMINI: gemini_symbols,\n-    HITBTC: hitbtc_symbols,\n-    POLONIEX: poloniex_symbols,\n-    PROBIT: probit_symbols,\n-    BITSTAMP: bitstamp_symbols,\n-    KRAKEN: kraken_symbols,\n-    KRAKEN + 'REST': kraken_rest_symbols,\n-    BINANCE: binance_symbols,\n-    BINANCE_US: binance_us_symbols,\n-    BINANCE_FUTURES: binance_futures_symbols,\n-    BINANCE_DELIVERY: binance_delivery_symbols,\n-    BLOCKCHAIN: blockchain_symbols,\n-    EXX: exx_symbols,\n-    HUOBI: huobi_symbols,\n-    HUOBI_DM: huobi_dm_symbols,\n-    HUOBI_SWAP: huobi_swap_symbols,\n-    OKCOIN: okcoin_symbols,\n-    OKEX: okex_symbols,\n-    BYBIT: bybit_symbols,\n-    FTX: ftx_symbols,\n-    FTX_US: ftx_us_symbols,\n-    BITTREX: bittrex_symbols,\n-    BITCOINCOM: bitcoincom_symbols,\n-    BITMAX: bitmax_symbols,\n-    UPBIT: upbit_symbols,\n-    GATEIO: gateio_symbols,\n-    BITMEX: bitmex_symbols,\n-    DERIBIT: deribit_symbols,\n-    KRAKEN_FUTURES: kraken_future_symbols,\n-    COINGECKO: coingecko_symbols,\n-    WHALE_ALERT: whale_alert_coins\n-}\n+Symbols = _Symbols()\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\n\nimport logging\nimport string\nimport time\nfrom collections import defaultdict\nfrom typing import Dict, List, Optional, Tuple\n\nimport requests\nfrom requests import Response\n\nfrom cryptofeed.defines import *\n\n\nLOG = logging.getLogger('feedhandler')\n\nSYMBOL_SEP = '-'\n\n_symbols_retrieval_cache: Dict[str, Dict[str, str]] = {}\n_exchange_info = defaultdict(lambda: defaultdict(dict))\n\n\n_kraken_futures_product_type = {\n    'FI': 'Inverse Futures',\n    'FV': 'Vanilla Futures',\n    'PI': 'Perpetual Inverse Futures',\n    'PV': 'Perpetual Vanilla Futures',\n    'IN': 'Real Time Index',\n    'RR': 'Reference Rate',\n}\n\n\ndef raise_failure_explanation(feed_id: str, exception: BaseException, responses: Dict[str, Optional[Response]]):\n    <IND>LOG.critical('%s: encountered %r while processing response from exchange API', feed_id, exception)\n    if len(responses) > 1:\n        <IND>LOG.critical('%s: content of one of the %s responses was unexpected', feed_id, len(responses))\n    <DED>for url, r in responses.items():\n        <IND>if url:\n            <IND>LOG.critical('%s: requested URL: %s', feed_id, url)\n        <DED>if r:\n            <IND>LOG.critical('%s: unexpected response: %s', feed_id, r.text)\n    <DED><DED>raise ValueError(f'Cryptofeed stopped because of an unexpected response from {feed_id}') from exception\n\n\n<DED>def set_symbol_separator(separator: str):\n    <IND>global SYMBOL_SEP\n    SYMBOL_SEP = separator\n\n\n<DED>def get_symbol_separator() -> str:\n    <IND>global SYMBOL_SEP\n    return SYMBOL_SEP\n\n\n<DED>def gen_symbols(exchange: str, key_id=None) -> Dict[str, str]:\n    <IND>if exchange not in _symbols_retrieval_cache:\n        <IND>LOG.info(\"%s: Getting list of symbols\", exchange)\n        symbols = _exchange_function_map[exchange](key_id) if key_id else _exchange_function_map[exchange]()\n        LOG.info(\"%s: %s symbols\", exchange, len(symbols))\n\n        # log all retrieved symbols using debug level\n        for normalized, exch_sym in sorted(symbols.items()):\n            <IND>LOG.debug('%s: id-from-exch -> normalized: %-35s-> %s', exchange, exch_sym, normalized)\n\n        <DED>_symbols_retrieval_cache[exchange] = symbols\n    <DED>return _symbols_retrieval_cache[exchange]\n\n\n<DED>def _binance_symbols(endpoint: str, exchange: str):\n    <IND>r = None\n    try:\n        <IND>ret = {}\n        r = requests.get(endpoint)\n        for symbol in r.json()['symbols']:\n            <IND>if symbol.get('status', 'TRADING') != \"TRADING\":\n                <IND>continue\n            <DED>if symbol.get('contractStatus', 'TRADING') != \"TRADING\":\n                <IND>continue\n            <DED>split = len(symbol['baseAsset'])\n            normalized = symbol['symbol'][:split] + SYMBOL_SEP + symbol['symbol'][split:]\n            ret[normalized] = symbol['symbol']\n            _exchange_info[exchange]['tick_size'][normalized] = symbol['filters'][0]['tickSize']\n            if \"contractType\" in symbol:\n                <IND>_exchange_info[exchange]['contract_type'][normalized] = symbol['contractType']\n        <DED><DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation(exchange, why, {endpoint: r})\n\n\n<DED><DED>def binance_symbols() -> Dict[str, str]:\n    <IND>return _binance_symbols('https://api.binance.com/api/v3/exchangeInfo', BINANCE)\n\n\n<DED>def binance_us_symbols() -> Dict[str, str]:\n    <IND>return _binance_symbols('https://api.binance.us/api/v3/exchangeInfo', BINANCE_US)\n\n\n<DED>def binance_futures_symbols() -> Dict[str, str]:\n    <IND>base = _binance_symbols('https://fapi.binance.com/fapi/v1/exchangeInfo', BINANCE_FUTURES)\n    add = {}\n    for symbol, orig in base.items():\n        <IND>if \"_\" in orig:\n            <IND>continue\n        <DED>add[f\"{symbol}-PINDEX\"] = f\"p{orig}\"\n    <DED>base.update(add)\n    return base\n\n\n<DED>def binance_delivery_symbols() -> Dict[str, str]:\n    <IND>return _binance_symbols('https://dapi.binance.com/dapi/v1/exchangeInfo', BINANCE_DELIVERY)\n\n\n<DED>def bitfinex_symbols() -> Dict[str, str]:\n    # doc: https://docs.bitfinex.com/docs/ws-general#supported-pairs\n    <IND>r1 = r2 = None\n    try:\n        <IND>r1 = requests.get('https://api.bitfinex.com/v2/tickers?symbols=ALL')\n        r2 = requests.get('https://api-pub.bitfinex.com/v2/conf/pub:map:currency:sym')\n        tickers: List[List[str]] = r1.json()\n        norm: List[Tuple[str, str]] = r2.json()[0]\n        norm: Dict[str, str] = dict(norm)\n        for k, v in dict(norm).items():\n            <IND>if k[-2:] == 'F0' or '-' in v:  # Do not convert BTCF0 -> BTC or PBTCETH -> PBTC-ETH\n                <IND>del norm[k]\n        <DED><DED>norm['BCHN'] = 'BCH'  # Bitfinex uses BCHN, other exchanges use BCH\n\n        ret = {}\n        for symbol in [t[0] for t in tickers]:\n            <IND>if symbol[0] == 'f':\n                <IND>normalized = norm.get(symbol[1:], symbol[1:])\n            <DED>else:\n                <IND>if len(symbol) == 7:\n                    <IND>base, quote = symbol[1:4], symbol[4:]\n                <DED>else:\n                    <IND>base, quote = symbol[1:].split(':')\n                    assert ':' in symbol\n                <DED>normalized = norm.get(base, base) + SYMBOL_SEP + norm.get(quote, quote)\n            <DED>ret[normalized.upper()] = symbol\n        <DED>return ret\n    <DED>except ValueError as why:\n        <IND>raise_failure_explanation('BITFINEX', why, {\"tickers?symbols=ALL\": r1, \"pub:map:currency:sym\": r2})\n\n\n<DED><DED>def bitflyer_symbols() -> Dict[str, str]:\n    <IND>endpoint = r = None\n    try:\n        <IND>ret = {}\n        endpoints = ['https://api.bitflyer.com/v1/getmarkets/eu', 'https://api.bitflyer.com/v1/getmarkets/usa', 'https://api.bitflyer.com/v1/getmarkets']\n        for endpoint in endpoints:\n            <IND>r = requests.get(endpoint)\n            for entry in r.json():\n                <IND>normalized = entry['product_code'].replace(\"_\", SYMBOL_SEP)\n                ret[normalized] = entry['product_code']\n        <DED><DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BITFLYER', why, {endpoint: r})\n\n\n<DED><DED>def bybit_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.bybit.com/v2/public/symbols')\n        ret = {}\n        for symbol in r.json()['result']:\n            <IND>quote = symbol['quote_currency']\n            if not symbol['name'].endswith(quote):\n                <IND>base, contract = symbol['name'].split(quote)\n                normalized = f\"{base}{SYMBOL_SEP}{quote}-{contract}\"\n            <DED>else:\n                <IND>normalized = f\"{symbol['base_currency']}{SYMBOL_SEP}{quote}\"\n            <DED>ret[normalized] = symbol['name']\n            _exchange_info[BYBIT]['tick_size'][normalized] = symbol['price_filter']['tick_size']\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BYBIT', why, {\"\": r})\n\n\n<DED><DED>def _ftx_helper(endpoint: str, exchange: str):\n    <IND>r = None\n    try:\n        <IND>r = requests.get(endpoint)\n        ret = {}\n        for data in r.json()['result']:\n            <IND>normalized = data['name'].replace(\"/\", SYMBOL_SEP)\n            symbol = data['name']\n            ret[normalized] = symbol\n            _exchange_info[exchange]['tick_size'][normalized] = data['priceIncrement']\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation(exchange, why, {endpoint: r})\n\n\n<DED><DED>def ftx_symbols() -> Dict[str, str]:\n    <IND>return _ftx_helper('https://ftx.com/api/markets', FTX)\n\n\n<DED>def ftx_us_symbols() -> Dict[str, str]:\n    <IND>return _ftx_helper('https://ftx.us/api/markets', FTX_US)\n\n\n<DED>def coinbase_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.pro.coinbase.com/products')\n        ret = {}\n        for data in r.json():\n            <IND>normalized = data['id'].replace(\"-\", SYMBOL_SEP)\n            ret[normalized] = data['id']\n            _exchange_info[COINBASE]['tick_size'][normalized] = data['quote_increment']\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('COINBASE', why, {\"\": r})\n\n\n<DED><DED>def gemini_symbols(*args) -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.gemini.com/v1/symbols')\n        ret = {}\n        for symbol in r.json():\n            <IND>std = f\"{symbol[:-3]}{SYMBOL_SEP}{symbol[-3:]}\"\n            std = std.upper()\n            ret[std] = symbol.upper()\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('GEMINI', why, {\"\": r})\n\n\n<DED><DED>def hitbtc_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>ret = {}\n        r = requests.get('https://api.hitbtc.com/api/2/public/symbol')\n        for symbol in r.json():\n            <IND>split = len(symbol['baseCurrency'])\n            normalized = symbol['id'][:split] + SYMBOL_SEP + symbol['id'][split:]\n            ret[normalized] = symbol['id']\n            _exchange_info[HITBTC]['tick_size'][normalized] = symbol['tickSize']\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('HITBTC', why, {\"\": r})\n\n\n<DED><DED>def poloniex_id_symbol_mapping():\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://poloniex.com/public?command=returnTicker')\n        symbols = r.json()\n        ret = {}\n        for symbol in symbols:\n            <IND>ret[symbols[symbol]['id']] = symbol\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('POLONIEX', why, {\"\": r})\n\n\n<DED><DED>def poloniex_symbols() -> Dict[str, str]:\n    <IND>ret = {}\n    for _, value in poloniex_id_symbol_mapping().items():\n        <IND>std = value.replace(\"STR\", \"XLM\")\n        quote, base = std.split(\"_\")\n        ret[quote + SYMBOL_SEP + base] = value\n    <DED>return ret\n\n\n<DED>def bitstamp_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://www.bitstamp.net/api/v2/trading-pairs-info/')\n        ret = {}\n        for data in r.json():\n            <IND>normalized = data['name'].replace(\"/\", SYMBOL_SEP)\n            symbol = data['url_symbol']\n            ret[normalized] = symbol\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BITSTAMP', why, {\"\": r})\n\n\n<DED><DED>def kraken_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.kraken.com/0/public/AssetPairs')\n        data = r.json()\n        ret = {}\n        for symbol in data['result']:\n            <IND>if 'wsname' not in data['result'][symbol] or '.d' in symbol:\n                # https://blog.kraken.com/post/259/introducing-the-kraken-dark-pool/\n                # .d is for dark pool symbols\n                <IND>continue\n\n            <DED>base, quote = data['result'][symbol]['wsname'].split(\"/\")\n\n            normalized = f\"{base}{SYMBOL_SEP}{quote}\"\n            exch = data['result'][symbol]['wsname']\n            normalized = normalized.replace('XBT', 'BTC')\n            normalized = normalized.replace('XDG', 'DOG')\n            ret[normalized] = exch\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('KRAKEN', why, {\"\": r})\n\n\n<DED><DED>def kraken_rest_symbols() -> Dict[str, str]:\n    <IND>return {normalized: exchange.replace(\"/\", \"\") for normalized, exchange in kraken_symbols().items()}\n\n\n<DED>def exx_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.exx.com/data/v1/tickers')\n        exchange = [key.upper() for key in r.json().keys()]\n        symbols = [key.replace(\"_\", SYMBOL_SEP) for key in exchange]\n        return dict(zip(symbols, exchange))\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('EXX', why, {\"\": r})\n\n\n<DED><DED>def huobi_common_symbols(url: str):\n    <IND>r = None\n    try:\n        <IND>r = requests.get(url)\n        ret = {}\n        for e in r.json()['data']:\n            <IND>if e['state'] == 'offline':\n                <IND>continue\n            <DED>normalized = f\"{e['base-currency'].upper()}{SYMBOL_SEP}{e['quote-currency'].upper()}\"\n            symbol = f\"{e['base-currency']}{e['quote-currency']}\"\n            ret[normalized] = symbol\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('HUOBI', why, {url: r})\n\n\n<DED><DED>def huobi_symbols() -> Dict[str, str]:\n    <IND>return huobi_common_symbols('https://api.huobi.pro/v1/common/symbols')\n\n\n<DED>def huobi_us_symbols() -> Dict[str, str]:\n    <IND>return huobi_common_symbols('https://api.huobi.com/v1/common/symbols')\n\n\n<DED>def huobi_dm_symbols() -> Dict[str, str]:\n    <IND>\"\"\"\n    Mapping is, for instance: {\"BTC_CW\":\"BTC190816\"}\n    See comments in exchange/huobi_dm.py\n    \"\"\"\n    mapping = {\n        \"this_week\": \"CW\",\n        \"next_week\": \"NW\",\n        \"quarter\": \"CQ\",\n        \"next_quarter\": \"NQ\"\n    }\n    r = None\n    try:\n        <IND>r = requests.get('https://www.hbdm.com/api/v1/contract_contract_info')\n        symbols = {}\n        for e in r.json()['data']:\n            <IND>symbols[f\"{e['symbol']}_{mapping[e['contract_type']]}\"] = e['contract_code']\n            _exchange_info[HUOBI_DM]['tick_size'][e['contract_code']] = e['price_tick']\n            _exchange_info[HUOBI_DM]['short_code_mappings'][f\"{e['symbol']}_{mapping[e['contract_type']]}\"] = e['contract_code']\n        <DED>return symbols\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('HUOBI_DM', why, {\"\": r})\n\n\n<DED><DED>def huobi_swap_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.hbdm.com/swap-api/v1/swap_contract_info')\n        symbols = {}\n        for e in r.json()['data']:\n            <IND>symbols[e['contract_code']] = e['contract_code']\n            _exchange_info[HUOBI_SWAP]['tick_size'][e['contract_code']] = e['price_tick']\n        <DED>return symbols\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('HUOBI_SWAP', why, {\"\": r})\n\n\n<DED><DED>def okcoin_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://www.okcoin.com/api/spot/v3/instruments')\n        ret = {}\n        for e in r.json():\n            <IND>ret[e['instrument_id']] = e['instrument_id']\n            _exchange_info[OKCOIN]['tick_size'][e['instrument_id']] = e['tick_size']\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('OKCOIN', why, {\"\": r})\n\n\n<DED><DED>def okex_symbols(*args) -> Dict[str, str]:\n    <IND>urls = ['https://www.okex.com/api/spot/v3/instruments',\n            'https://www.okex.com/api/swap/v3/instruments',\n            'https://www.okex.com/api/futures/v3/instruments']\n    urls = urls + okex_compute_option_urls_from_underlyings()\n\n    symbols: Dict[str, str] = {}\n    for u in urls:\n        <IND>time.sleep(0.2)\n        symbols.update(okex_symbols_from_one_url(u))\n\n    <DED>for symbol in symbols:\n        <IND>instrument_type = 'futures'\n        dash_count = symbol.count(get_symbol_separator())\n        if dash_count == 1:  # BTC-USDT\n            <IND>instrument_type = 'spot'\n        <DED>if dash_count == 4:  # BTC-USD-201225-35000-P\n            <IND>instrument_type = 'option'\n        <DED>if symbol[-4:] == \"SWAP\":  # BTC-USDT-SWAP\n            <IND>instrument_type = 'swap'\n\n        <DED>_exchange_info[OKEX]['instrument_type'][symbol] = instrument_type\n\n    <DED>return symbols\n\n\n<DED>def okex_compute_option_urls_from_underlyings() -> List[str]:\n    <IND>url = 'https://www.okex.com/api/option/v3/underlying'\n    r = None\n    try:\n        <IND>r = requests.get(url)\n        return [f'https://www.okex.com/api/option/v3/instruments/{underlying}' for underlying in r.json()]\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('OKEX', why, {url: r})\n\n\n<DED><DED>def okex_symbols_from_one_url(url: str) -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get(url)\n        ret = {}\n        for e in r.json():\n            <IND>ret[e['instrument_id']] = e['instrument_id']\n            _exchange_info[OKEX]['tick_size'][e['instrument_id']] = e['tick_size']\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('OKEX', why, {url: r})\n\n\n<DED><DED>def bittrex_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.bittrex.com/api/v1.1/public/getmarkets')\n        r = r.json()['result']\n        return {f\"{e['MarketCurrency']}{SYMBOL_SEP}{e['BaseCurrency']}\": e['MarketName'] for e in r if e['IsActive']}\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BITTREX', why, {\"\": r})\n\n\n<DED><DED>def bitcoincom_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.exchange.bitcoin.com/api/2/public/symbol')\n        return {f\"{data['baseCurrency']}{SYMBOL_SEP}{data['quoteCurrency'].replace('USD', 'USDT')}\": data['id'] for data in r.json()}\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BITCOINCOM', why, {\"\": r})\n\n\n<DED><DED>def bitmax_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://bitmax.io/api/pro/v1/products')\n        ret = {}\n        for entry in r.json()['data']:\n            # Only \"Normal\" status symbols are tradeable\n            <IND>if entry['status'] == 'Normal':\n                <IND>normalized = f\"{entry['baseAsset']}{SYMBOL_SEP}{entry['quoteAsset']}\"\n                ret[normalized] = entry['symbol']\n                _exchange_info[BITMAX]['tick_size'][normalized] = entry['tickSize']\n        <DED><DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BITMAX', why, {\"\": r})\n\n\n<DED><DED>def upbit_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.upbit.com/v1/market/all')\n        return {f\"{data['market'].split('-')[1]}{SYMBOL_SEP}{data['market'].split('-')[0]}\": data['market'] for data in r.json()}\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('UPBIT', why, {\"\": r})\n\n\n<DED><DED>def blockchain_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get(\"https://api.blockchain.com/mercury-gateway/v1/instruments\")\n        return {data[\"symbol\"].replace(\"-\", SYMBOL_SEP): data[\"symbol\"] for data in r.json()}\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BLOCKCHAIN', why, {\"\": r})\n\n\n<DED><DED>def gateio_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get(\"https://api.gateio.ws/api/v4/spot/currency_pairs\")\n        return {data[\"id\"].replace(\"_\", SYMBOL_SEP): data['id'] for data in r.json()}\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('GATEIO', why, {\"\": r})\n\n\n<DED><DED>def bitmex_symbols() -> Dict[str, str]:\n    <IND>r = None\n    ret = {}\n    try:\n        <IND>r = requests.get(\"https://www.bitmex.com/api/v1/instrument/active\")\n        for entry in r.json():\n            <IND>components = []\n            components.append(entry['rootSymbol'])\n            components.append(entry['quoteCurrency'])\n\n            if entry['expiry']:\n                <IND>components.append(entry['symbol'][-3:])\n\n            <DED>normalized = SYMBOL_SEP.join(components)\n            normalized = normalized.replace(\"XBT\", \"BTC\")\n            ret[normalized] = entry['symbol']\n            _exchange_info[BITMEX]['tick_size'][normalized] = entry['tickSize']\n\n            if entry['expiry']:\n                <IND>_exchange_info[BITMEX]['expiry'][normalized] = entry['expiry']\n\n        <DED><DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BITMEX', why, {\"\": r})\n\n\n<DED><DED>def deribit_symbols() -> Dict[str, str]:\n    <IND>url = r = None\n    ret = {}\n    try:\n        # TODO: get currencies from https://www.deribit.com/api/v2/public/get_currencies\n        <IND>currencies = ['BTC', 'ETH']\n        for c in currencies:\n            <IND>url = f\"https://www.deribit.com/api/v2/public/get_instruments?currency={c}&expired=false\"\n            r = requests.get(url)\n            for entry in r.json()['result']:\n                <IND>split = entry['instrument_name'].split(\"-\")\n                normalized = split[0] + SYMBOL_SEP + entry['quote_currency'] + \"-\" + '-'.join(split[1:])\n                ret[normalized] = entry['instrument_name']\n                _exchange_info[DERIBIT]['tick_size'][normalized] = entry['tick_size']\n        <DED><DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('DERIBIT', why, {url: r})\n\n\n<DED><DED>def kraken_future_symbols() -> Dict[str, str]:\n    <IND>r = None\n    ret = {}\n    try:\n        <IND>r = requests.get('https://futures.kraken.com/derivatives/api/v3/instruments')\n        data = r.json()['instruments']\n        for entry in data:\n            <IND>if not entry['tradeable']:\n                <IND>continue\n            <DED>normalized = entry['symbol'].upper().replace(\"_\", \"-\")\n            symbol = normalized[3:6] + SYMBOL_SEP + normalized[6:9]\n            normalized = normalized.replace(normalized[3:9], symbol)\n            normalized = normalized.replace('XBT', 'BTC')\n\n            _exchange_info[KRAKEN_FUTURES]['tick_size'][normalized] = entry['tickSize']\n            _exchange_info[KRAKEN_FUTURES]['contract_size'][normalized] = entry['contractSize']\n            _exchange_info[KRAKEN_FUTURES]['underlying'][normalized] = entry['underlying']\n            _exchange_info[KRAKEN_FUTURES]['product_type'][normalized] = _kraken_futures_product_type[normalized[:2]]\n            ret[normalized] = entry['symbol']\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('KRAKEN_FUTURES', why, {\"\": r})\n\n\n<DED><DED>def probit_symbols() -> Dict[str, str]:\n    # doc: https://docs-en.probit.com/reference-link/market\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.probit.com/api/exchange/v1/market')\n        return {entry['id']: entry['id'] for entry in r.json()['data']}\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('PROBIT', why, {\"\": r})\n\n\n<DED><DED>def coingecko_normalize_symbol(symbol: str) -> str:\n    # keep digits, letters and dots, replace others by space\n    <IND>symbol = ''.join(c if c.isalnum() or c in ('.', '+') else ' ' for c in symbol)\n    return coingecko_normalize(symbol.upper())\n\n\n<DED>def coingecko_normalize_name(name: str) -> str:\n    # keep digits and letters, replace others by space (except when only composed by upper case letters, digits and dots)\n    <IND>if not all(c.isupper() or c.isdigit() or c == '.' for c in name):\n        <IND>name = ''.join(c if c.isalnum() else ' ' for c in name)\n    <DED>return coingecko_normalize(name)\n\n\n<DED>def coingecko_normalize(sym: str) -> str:\n    <IND>sym = sym.strip()\n    # do not concatenate numbers => separate them with a dot\n    sym = list(sym)\n    if len(sym) > 4:\n        <IND>for i in range(2, len(sym) - 1):\n            <IND>if sym[i] == ' ' and sym[i - 1].isdigit() and sym[i + 1].isdigit():\n                <IND>sym[i] = '.'\n    <DED><DED><DED>sym = ''.join(sym)\n    # concatenate space-separated words => use CamelCase to distinguish the words\n    if ' ' in sym:\n        <IND>if sum(c.islower() for c in sym):  # if there is at least one lower case letter\n            <IND>sym = ' '.join(word[0].upper() + word[1:] for word in sym.split())  # Just capitalize initial letter of each word\n        <DED>else:  # CoinGecko may provide full upper-case as for \"THE STONE COIN\"\n            <IND>sym = string.capwords(sym)  # capwords converts \"THE STONE COIN\" to \"The Stone Coin\"\n        <DED>sym = sym.replace(' ', '')  # concatenate words\n    <DED>return sym\n\n\n<DED>def is_name_short(coin: dict) -> bool:\n    <IND>\"\"\"return True if the coin name is enough short compared to the coin symbol.\"\"\"\n    return len(coin['name']) <= max(5, len(coin['symbol']) + 1)\n\n\n<DED>def has_many_caps(name: str) -> bool:\n    <IND>\"\"\"return True if the symbol contains enough upper case letters, False if empty.\"\"\"\n    return str and sum(c.islower() for c in name) < (len(name) / 2)\n\n\n<DED>def coingecko_normalize_all(coin: dict):\n    <IND>SYMBOL_TO_NORMALIZED = {'miota': 'IOTA'}\n    normalized = SYMBOL_TO_NORMALIZED.get(coin['symbol'])\n    if normalized:\n        <IND>coin['ns'] = coin['nn'] = normalized\n        return normalized\n\n    # ns = normalized symbol, nn = normalized name\n    <DED>coin['ns'] = coingecko_normalize_symbol(coin['symbol'])\n\n    ID_SUFFIX = '-bitcoin-token'\n    if coin['id'][-len(ID_SUFFIX):] == ID_SUFFIX:\n        <IND>coin['nn'] = 'BTC' + coin['ns']\n        return coin['nn']\n\n    <DED>name = coin['name']\n\n    prefixes = ('The ', 'the ')\n    for p in prefixes:\n        <IND>if name[:len(p)] == p:\n            <IND>coin['reduced-name'] = True\n            name = name[len(p):]\n            break\n\n    <DED><DED>suffixes = ('coin', 'coins', 'money', 'finance', 'protocol', 'reward', 'rewards', 'token')\n    for s in suffixes:\n        <IND>if len(name) > len(s) and name[-len(s):].lower() == s:\n            # but keep suffix when lower-case concatenated\n            <IND>if name[-len(s)].islower() and name[-len(s) - 1] != ' ':\n                <IND>continue\n            # also keep suffix to avoid confusing nam: \"Bitcoin Token\" -> \"Bitcoin\"\n            <DED>if name[:-len(s)].strip().lower() == 'bitcoin':\n                <IND>continue\n            <DED>coin['reduced-name'] = True\n            name = name[:-len(s)]\n            break\n\n    <DED><DED>coin['nn'] = coingecko_normalize_name(name)\n\n    if len(coin['nn']) < len(coin['ns']):\n        <IND>if 'reduced-name' in coin:\n            <IND>coin['reduced-name'] = False\n            name = coin['name']\n            coin['nn'] = coingecko_normalize_name(name)\n        <DED>elif not has_many_caps(name):\n            <IND>return coin['ns']\n\n    <DED><DED>if not coin['ns']:  # coin['symbol'] may be an emoji that is striped when normalized\n        <IND>return coin['nn']\n\n    <DED>if coin.get('reduced-name') and coin['ns'].upper() != coin['nn'].upper():\n        <IND>return coin['ns']\n\n    <DED>i = coin['nn'].find('.')  # if there is a dot in normalized name => prefer the normalized symbol\n    if i >= 0:\n        <IND>if i > 1 and coin['nn'][i - 1].isdigit() and coin['nn'][i + 1].isdigit():\n            <IND>pass  # except when the dot separates digits\n        <DED>else:\n            <IND>return coin['ns']\n\n    <DED><DED>if is_name_short(coin) and has_many_caps(name):\n        <IND>return coin['nn']\n\n    <DED>if 1.5 * len(coin['ns']) > len(coin['nn']) and any(c.islower() for c in coin['ns']):\n        <IND>return coin['nn']\n\n    <DED>return coin['ns']\n\n\n<DED>def coingecko_symbols() -> Dict[str, str]:\n    <IND>r = None\n    intermediate = defaultdict(list)\n    try:\n        <IND>r = requests.get('https://api.coingecko.com/api/v3/coins/list')\n        all_coins = r.json()\n        # First pass: generate & compare normalized symbol/name, and then select the most pertinent\n        for coin in all_coins:\n            <IND>normalized = coingecko_normalize_all(coin)\n            intermediate[normalized].append(coin)\n            # Above line keeps together the coins having the same normalized symbol.\n            # To reduce collision, the coin['name'] is sometimes used in lieu of the coin['symbol'].\n            # The coin['name'] is not capitalized because lower case letters may be meaningful: cETH, yUSD, DATx, zLOT\n    <DED><DED>except Exception as why:\n        <IND>raise_failure_explanation('COINGECKO', why, {\"\": r})\n\n    <DED>final = coingecko_second_pass(intermediate)\n    return coingecko_third_pass(final)\n\n\n<DED>def coingecko_second_pass(intermediate: Dict[str, List[dict]]) -> Dict[str, List[dict]]:\n    # Second pass: fixes most of the symbol collisions\n    <IND>final = defaultdict(list)\n    for normalized, coins in intermediate.items():\n        <IND>if len(coins) == 1:\n            <IND>final[normalized].append(coins[0])\n            continue\n        <DED>set_normalized = False\n        for i in range(len(coins)):\n            <IND>if normalized == coins[i]['nn']:\n                <IND>coin = coins.pop(i)\n                final[normalized].append(coin)\n                set_normalized = True\n                break\n        <DED><DED>rest: List[dict] = []\n        for coin in coins:\n            <IND>if '%' in coin['name']:\n                <IND>if len(coins) == 1:\n                    <IND>n = coin['ns']\n                <DED>else:\n                    <IND>n = coingecko_normalize_name(coin['id'])\n                <DED>final[n].append(coin)\n            <DED>else:\n                <IND>rest.append(coin)\n        <DED><DED>if not rest:\n            <IND>continue\n        <DED>if not set_normalized:\n            <IND>rest.sort(key=lambda coin: len(coin['nn']), reverse=True)  # sort by the length of the normalized name\n            coin = rest.pop(0)\n            final[normalized].append(coin)\n        <DED>for coin in rest:\n            <IND>if coin['nn'] not in intermediate:\n                <IND>n = coin['nn']\n            <DED>elif coin.get('reduced-name'):\n                <IND>n = coingecko_normalize_name(coin['name'])\n            <DED>else:\n                <IND>n = coingecko_normalize_name(coin['id'])\n            <DED>final[n].append(coin)\n    <DED><DED>return final\n\n\n<DED>def coingecko_third_pass(final: Dict[str, List[dict]]) -> Dict[str, str]:\n    # Third pass: fixes some remaining collisions and fills the result\n    <IND>symbols = {}\n    for normalized, coins in final.items():\n        <IND>if len(coins) == 1:\n            <IND>symbols[normalized] = coins[0]['id']\n            continue\n        <DED>set_normalized = False\n        for i in range(len(coins)):\n            <IND>if normalized == coins[i]['nn']:\n                <IND>coin = coins.pop(i)\n                symbols[normalized] = coin['id']\n                set_normalized = True\n                break\n        <DED><DED>rest: List[dict] = []\n        for coin in coins:\n            <IND>if '%' in coin['name']:\n                <IND>if len(coins) == 1:\n                    <IND>n = coin['ns']\n                <DED>else:\n                    <IND>n = coingecko_normalize_name(coin['id'])\n                <DED>symbols[n] = coin['id']\n            <DED>else:\n                <IND>rest.append(coin)\n        <DED><DED>if not rest:\n            <IND>continue\n        <DED>if not set_normalized:\n            <IND>rest.sort(key=lambda coin: len(coin['nn']), reverse=True)  # sort by the length of the normalized name\n            coin = rest.pop(0)\n            symbols[normalized] = coin['id']\n        <DED>for coin in rest:\n            <IND>if coin['nn'] not in final:\n                <IND>n = coin['nn']\n            <DED>elif coin.get('reduced-name'):\n                <IND>n = coingecko_normalize_name(coin['name'])\n            <DED>else:\n                <IND>n = coingecko_normalize_name(coin['id'])\n            <DED>symbols[n] = coin['id']\n    <DED><DED>return symbols\n\n\n<DED>def whale_alert_coins(key_id: str) -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get(f'https://api.whale-alert.io/v1/status?api_key={key_id}')\n        # Same symbols, but on different blockchains (for instance USDT), are naturally overwritten.\n        return {s.upper(): s for b in r.json()['blockchains'] for s in b['symbols'] if s}\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('WHALES_ALERT', why, {\"\": r})\n\n\n<DED><DED>_exchange_function_map = {\n    BITFINEX: bitfinex_symbols,\n    BITFLYER: bitflyer_symbols,\n    COINBASE: coinbase_symbols,\n    GEMINI: gemini_symbols,\n    HITBTC: hitbtc_symbols,\n    POLONIEX: poloniex_symbols,\n    PROBIT: probit_symbols,\n    BITSTAMP: bitstamp_symbols,\n    KRAKEN: kraken_symbols,\n    KRAKEN + 'REST': kraken_rest_symbols,\n    BINANCE: binance_symbols,\n    BINANCE_US: binance_us_symbols,\n    BINANCE_FUTURES: binance_futures_symbols,\n    BINANCE_DELIVERY: binance_delivery_symbols,\n    BLOCKCHAIN: blockchain_symbols,\n    EXX: exx_symbols,\n    HUOBI: huobi_symbols,\n    HUOBI_DM: huobi_dm_symbols,\n    HUOBI_SWAP: huobi_swap_symbols,\n    OKCOIN: okcoin_symbols,\n    OKEX: okex_symbols,\n    BYBIT: bybit_symbols,\n    FTX: ftx_symbols,\n    FTX_US: ftx_us_symbols,\n    BITTREX: bittrex_symbols,\n    BITCOINCOM: bitcoincom_symbols,\n    BITMAX: bitmax_symbols,\n    UPBIT: upbit_symbols,\n    GATEIO: gateio_symbols,\n    BITMEX: bitmex_symbols,\n    DERIBIT: deribit_symbols,\n    KRAKEN_FUTURES: kraken_future_symbols,\n    COINGECKO: coingecko_symbols,\n    WHALE_ALERT: whale_alert_coins\n}\n",
        "target_code_with_indent": "\nfrom typing import Dict, Tuple\n\n\nclass _Symbols:\n    <IND>def __init__(self):\n        <IND>self.data = {}\n\n    <DED>def set(self, exchange: str, normalized: dict, exchange_info: dict):\n        <IND>self.data[exchange] = {}\n        self.data[exchange]['normalized'] = normalized\n        self.data[exchange]['info'] = exchange_info\n\n    <DED>def get(self, exchange: str) -> Tuple[Dict, Dict]:\n        <IND>return self.data[exchange]['normalized'], self.data[exchange]['info']\n\n    <DED>def populated(self, exchange: str) -> bool:\n        <IND>return exchange in self.data\n\n\n<DED><DED>Symbols = _Symbols()\n"
      }
    ]
  },
  {
    "project": "bmoscon/cryptofeed",
    "commit": "3525dc8ce4d7836a9abaaa5662e58e5e27969a77",
    "filename": "cryptofeed/symbols.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/bmoscon-cryptofeed/cryptofeed/symbols.py",
    "file_hunks_size": 1,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "cryptofeed/symbols.py:588:8 Incompatible return type [7]: Expected `Dict[str, str]` but got implicit return value of `None`.",
    "message": " Expected `Dict[str, str]` but got implicit return value of `None`.",
    "rule_id": "Incompatible return type [7]",
    "warning_line_no": 588,
    "warning_line": "        raise_failure_explanation('PROBIT', why, {\"\": r})",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "associated with this software.\n\n\nSymbol generation code for exchanges\n'''\n\nimport logging\nimport string\nimport time\nfrom collections import defaultdict\nfrom typing import Dict, List, Optional, Tuple\n\nimport requests\nfrom requests import Response\n\nfrom cryptofeed.defines import *\n\n\nLOG = logging.getLogger('feedhandler')\n\nSYMBOL_SEP = '-'\n\n_symbols_retrieval_cache: Dict[str, Dict[str, str]] = {}\n_exchange_info = defaultdict(lambda: defaultdict(dict))\n\n\n_kraken_futures_product_type = {\n    'FI': 'Inverse Futures',\n    'FV': 'Vanilla Futures',\n    'PI': 'Perpetual Inverse Futures',\n    'PV': 'Perpetual Vanilla Futures',\n    'IN': 'Real Time Index',\n    'RR': 'Reference Rate',\n}\n\n\ndef raise_failure_explanation(feed_id: str, exception: BaseException, responses: Dict[str, Optional[Response]]):\n    LOG.critical('%s: encountered %r while processing response from exchange API', feed_id, exception)\n    if len(responses) > 1:\n        LOG.critical('%s: content of one of the %s responses was unexpected', feed_id, len(responses))\n    for url, r in responses.items():\n        if url:\n            LOG.critical('%s: requested URL: %s', feed_id, url)\n        if r:\n            LOG.critical('%s: unexpected response: %s', feed_id, r.text)\n    raise ValueError(f'Cryptofeed stopped because of an unexpected response from {feed_id}') from exception\n\n\ndef set_symbol_separator(separator: str):\n    global SYMBOL_SEP\n    SYMBOL_SEP = separator\n\n\ndef get_symbol_separator() -> str:\n    global SYMBOL_SEP\n    return SYMBOL_SEP\n\n\ndef gen_symbols(exchange: str, key_id=None) -> Dict[str, str]:\n    if exchange not in _symbols_retrieval_cache:\n        LOG.info(\"%s: Getting list of symbols\", exchange)\n        symbols = _exchange_function_map[exchange](key_id) if key_id else _exchange_function_map[exchange]()\n        LOG.info(\"%s: %s symbols\", exchange, len(symbols))\n\n        # log all retrieved symbols using debug level\n        for normalized, exch_sym in sorted(symbols.items()):\n            LOG.debug('%s: id-from-exch -> normalized: %-35s-> %s', exchange, exch_sym, normalized)\n\n        _symbols_retrieval_cache[exchange] = symbols\n    return _symbols_retrieval_cache[exchange]\n\n\ndef _binance_symbols(endpoint: str, exchange: str):\n    r = None\n    try:\n        ret = {}\n        r = requests.get(endpoint)\n        for symbol in r.json()['symbols']:\n            if symbol.get('status', 'TRADING') != \"TRADING\":\n                continue\n            if symbol.get('contractStatus', 'TRADING') != \"TRADING\":\n                continue\n            split = len(symbol['baseAsset'])\n            normalized = symbol['symbol'][:split] + SYMBOL_SEP + symbol['symbol'][split:]\n            ret[normalized] = symbol['symbol']\n            _exchange_info[exchange]['tick_size'][normalized] = symbol['filters'][0]['tickSize']\n            if \"contractType\" in symbol:\n                _exchange_info[exchange]['contract_type'][normalized] = symbol['contractType']\n        return ret\n    except Exception as why:\n        raise_failure_explanation(exchange, why, {endpoint: r})\n\n\ndef binance_symbols() -> Dict[str, str]:\n    return _binance_symbols('https://api.binance.com/api/v3/exchangeInfo', BINANCE)\n\n\ndef binance_us_symbols() -> Dict[str, str]:\n    return _binance_symbols('https://api.binance.us/api/v3/exchangeInfo', BINANCE_US)\n\n\ndef binance_futures_symbols() -> Dict[str, str]:\n    base = _binance_symbols('https://fapi.binance.com/fapi/v1/exchangeInfo', BINANCE_FUTURES)\n    add = {}\n    for symbol, orig in base.items():\n        if \"_\" in orig:\n            continue\n        add[f\"{symbol}-PINDEX\"] = f\"p{orig}\"\n    base.update(add)\n    return base\n\n\ndef binance_delivery_symbols() -> Dict[str, str]:\n    return _binance_symbols('https://dapi.binance.com/dapi/v1/exchangeInfo', BINANCE_DELIVERY)\n\n\ndef bitfinex_symbols() -> Dict[str, str]:\n    # doc: https://docs.bitfinex.com/docs/ws-general#supported-pairs\n    r1 = r2 = None\n    try:\n        r1 = requests.get('https://api.bitfinex.com/v2/tickers?symbols=ALL')\n        r2 = requests.get('https://api-pub.bitfinex.com/v2/conf/pub:map:currency:sym')\n        tickers: List[List[str]] = r1.json()\n        norm: List[Tuple[str, str]] = r2.json()[0]\n        norm: Dict[str, str] = dict(norm)\n        for k, v in dict(norm).items():\n            if k[-2:] == 'F0' or '-' in v:  # Do not convert BTCF0 -> BTC or PBTCETH -> PBTC-ETH\n                del norm[k]\n        norm['BCHN'] = 'BCH'  # Bitfinex uses BCHN, other exchanges use BCH\n\n        ret = {}\n        for symbol in [t[0] for t in tickers]:\n            if symbol[0] == 'f':\n                normalized = norm.get(symbol[1:], symbol[1:])\n            else:\n                if len(symbol) == 7:\n                    base, quote = symbol[1:4], symbol[4:]\n                else:\n                    base, quote = symbol[1:].split(':')\n                    assert ':' in symbol\n                normalized = norm.get(base, base) + SYMBOL_SEP + norm.get(quote, quote)\n            ret[normalized.upper()] = symbol\n        return ret\n    except ValueError as why:\n        raise_failure_explanation('BITFINEX', why, {\"tickers?symbols=ALL\": r1, \"pub:map:currency:sym\": r2})\n\n\ndef bitflyer_symbols() -> Dict[str, str]:\n    endpoint = r = None\n    try:\n        ret = {}\n        endpoints = ['https://api.bitflyer.com/v1/getmarkets/eu', 'https://api.bitflyer.com/v1/getmarkets/usa', 'https://api.bitflyer.com/v1/getmarkets']\n        for endpoint in endpoints:\n            r = requests.get(endpoint)\n            for entry in r.json():\n                normalized = entry['product_code'].replace(\"_\", SYMBOL_SEP)\n                ret[normalized] = entry['product_code']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('BITFLYER', why, {endpoint: r})\n\n\ndef bybit_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.bybit.com/v2/public/symbols')\n        ret = {}\n        for symbol in r.json()['result']:\n            quote = symbol['quote_currency']\n            if not symbol['name'].endswith(quote):\n                base, contract = symbol['name'].split(quote)\n                normalized = f\"{base}{SYMBOL_SEP}{quote}-{contract}\"\n            else:\n                normalized = f\"{symbol['base_currency']}{SYMBOL_SEP}{quote}\"\n            ret[normalized] = symbol['name']\n            _exchange_info[BYBIT]['tick_size'][normalized] = symbol['price_filter']['tick_size']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('BYBIT', why, {\"\": r})\n\n\ndef _ftx_helper(endpoint: str, exchange: str):\n    r = None\n    try:\n        r = requests.get(endpoint)\n        ret = {}\n        for data in r.json()['result']:\n            normalized = data['name'].replace(\"/\", SYMBOL_SEP)\n            symbol = data['name']\n            ret[normalized] = symbol\n            _exchange_info[exchange]['tick_size'][normalized] = data['priceIncrement']\n        return ret\n    except Exception as why:\n        raise_failure_explanation(exchange, why, {endpoint: r})\n\n\ndef ftx_symbols() -> Dict[str, str]:\n    return _ftx_helper('https://ftx.com/api/markets', FTX)\n\n\ndef ftx_us_symbols() -> Dict[str, str]:\n    return _ftx_helper('https://ftx.us/api/markets', FTX_US)\n\n\ndef coinbase_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.pro.coinbase.com/products')\n        ret = {}\n        for data in r.json():\n            normalized = data['id'].replace(\"-\", SYMBOL_SEP)\n            ret[normalized] = data['id']\n            _exchange_info[COINBASE]['tick_size'][normalized] = data['quote_increment']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('COINBASE', why, {\"\": r})\n\n\ndef gemini_symbols(*args) -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.gemini.com/v1/symbols')\n        ret = {}\n        for symbol in r.json():\n            std = f\"{symbol[:-3]}{SYMBOL_SEP}{symbol[-3:]}\"\n            std = std.upper()\n            ret[std] = symbol.upper()\n        return ret\n    except Exception as why:\n        raise_failure_explanation('GEMINI', why, {\"\": r})\n\n\ndef hitbtc_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        ret = {}\n        r = requests.get('https://api.hitbtc.com/api/2/public/symbol')\n        for symbol in r.json():\n            split = len(symbol['baseCurrency'])\n            normalized = symbol['id'][:split] + SYMBOL_SEP + symbol['id'][split:]\n            ret[normalized] = symbol['id']\n            _exchange_info[HITBTC]['tick_size'][normalized] = symbol['tickSize']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('HITBTC', why, {\"\": r})\n\n\ndef poloniex_id_symbol_mapping():\n    r = None\n    try:\n        r = requests.get('https://poloniex.com/public?command=returnTicker')\n        symbols = r.json()\n        ret = {}\n        for symbol in symbols:\n            ret[symbols[symbol]['id']] = symbol\n        return ret\n    except Exception as why:\n        raise_failure_explanation('POLONIEX', why, {\"\": r})\n\n\ndef poloniex_symbols() -> Dict[str, str]:\n    ret = {}\n    for _, value in poloniex_id_symbol_mapping().items():\n        std = value.replace(\"STR\", \"XLM\")\n        quote, base = std.split(\"_\")\n        ret[quote + SYMBOL_SEP + base] = value\n    return ret\n\n\ndef bitstamp_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://www.bitstamp.net/api/v2/trading-pairs-info/')\n        ret = {}\n        for data in r.json():\n            normalized = data['name'].replace(\"/\", SYMBOL_SEP)\n            symbol = data['url_symbol']\n            ret[normalized] = symbol\n        return ret\n    except Exception as why:\n        raise_failure_explanation('BITSTAMP', why, {\"\": r})\n\n\ndef kraken_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.kraken.com/0/public/AssetPairs')\n        data = r.json()\n        ret = {}\n        for symbol in data['result']:\n            if 'wsname' not in data['result'][symbol] or '.d' in symbol:\n                # https://blog.kraken.com/post/259/introducing-the-kraken-dark-pool/\n                # .d is for dark pool symbols\n                continue\n\n            base, quote = data['result'][symbol]['wsname'].split(\"/\")\n\n            normalized = f\"{base}{SYMBOL_SEP}{quote}\"\n            exch = data['result'][symbol]['wsname']\n            normalized = normalized.replace('XBT', 'BTC')\n            normalized = normalized.replace('XDG', 'DOG')\n            ret[normalized] = exch\n        return ret\n    except Exception as why:\n        raise_failure_explanation('KRAKEN', why, {\"\": r})\n\n\ndef kraken_rest_symbols() -> Dict[str, str]:\n    return {normalized: exchange.replace(\"/\", \"\") for normalized, exchange in kraken_symbols().items()}\n\n\ndef exx_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.exx.com/data/v1/tickers')\n        exchange = [key.upper() for key in r.json().keys()]\n        symbols = [key.replace(\"_\", SYMBOL_SEP) for key in exchange]\n        return dict(zip(symbols, exchange))\n    except Exception as why:\n        raise_failure_explanation('EXX', why, {\"\": r})\n\n\ndef huobi_common_symbols(url: str):\n    r = None\n    try:\n        r = requests.get(url)\n        ret = {}\n        for e in r.json()['data']:\n            if e['state'] == 'offline':\n                continue\n            normalized = f\"{e['base-currency'].upper()}{SYMBOL_SEP}{e['quote-currency'].upper()}\"\n            symbol = f\"{e['base-currency']}{e['quote-currency']}\"\n            ret[normalized] = symbol\n        return ret\n    except Exception as why:\n        raise_failure_explanation('HUOBI', why, {url: r})\n\n\ndef huobi_symbols() -> Dict[str, str]:\n    return huobi_common_symbols('https://api.huobi.pro/v1/common/symbols')\n\n\ndef huobi_us_symbols() -> Dict[str, str]:\n    return huobi_common_symbols('https://api.huobi.com/v1/common/symbols')\n\n\ndef huobi_dm_symbols() -> Dict[str, str]:\n    \"\"\"\n    Mapping is, for instance: {\"BTC_CW\":\"BTC190816\"}\n    See comments in exchange/huobi_dm.py\n    \"\"\"\n    mapping = {\n        \"this_week\": \"CW\",\n        \"next_week\": \"NW\",\n        \"quarter\": \"CQ\",\n        \"next_quarter\": \"NQ\"\n    }\n    r = None\n    try:\n        r = requests.get('https://www.hbdm.com/api/v1/contract_contract_info')\n        symbols = {}\n        for e in r.json()['data']:\n            symbols[f\"{e['symbol']}_{mapping[e['contract_type']]}\"] = e['contract_code']\n            _exchange_info[HUOBI_DM]['tick_size'][e['contract_code']] = e['price_tick']\n            _exchange_info[HUOBI_DM]['short_code_mappings'][f\"{e['symbol']}_{mapping[e['contract_type']]}\"] = e['contract_code']\n        return symbols\n    except Exception as why:\n        raise_failure_explanation('HUOBI_DM', why, {\"\": r})\n\n\ndef huobi_swap_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.hbdm.com/swap-api/v1/swap_contract_info')\n        symbols = {}\n        for e in r.json()['data']:\n            symbols[e['contract_code']] = e['contract_code']\n            _exchange_info[HUOBI_SWAP]['tick_size'][e['contract_code']] = e['price_tick']\n        return symbols\n    except Exception as why:\n        raise_failure_explanation('HUOBI_SWAP', why, {\"\": r})\n\n\ndef okcoin_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://www.okcoin.com/api/spot/v3/instruments')\n        ret = {}\n        for e in r.json():\n            ret[e['instrument_id']] = e['instrument_id']\n            _exchange_info[OKCOIN]['tick_size'][e['instrument_id']] = e['tick_size']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('OKCOIN', why, {\"\": r})\n\n\ndef okex_symbols(*args) -> Dict[str, str]:\n    urls = ['https://www.okex.com/api/spot/v3/instruments',\n            'https://www.okex.com/api/swap/v3/instruments',\n            'https://www.okex.com/api/futures/v3/instruments']\n    urls = urls + okex_compute_option_urls_from_underlyings()\n\n    symbols: Dict[str, str] = {}\n    for u in urls:\n        time.sleep(0.2)\n        symbols.update(okex_symbols_from_one_url(u))\n\n    for symbol in symbols:\n        instrument_type = 'futures'\n        dash_count = symbol.count(get_symbol_separator())\n        if dash_count == 1:  # BTC-USDT\n            instrument_type = 'spot'\n        if dash_count == 4:  # BTC-USD-201225-35000-P\n            instrument_type = 'option'\n        if symbol[-4:] == \"SWAP\":  # BTC-USDT-SWAP\n            instrument_type = 'swap'\n\n        _exchange_info[OKEX]['instrument_type'][symbol] = instrument_type\n\n    return symbols\n\n\ndef okex_compute_option_urls_from_underlyings() -> List[str]:\n    url = 'https://www.okex.com/api/option/v3/underlying'\n    r = None\n    try:\n        r = requests.get(url)\n        return [f'https://www.okex.com/api/option/v3/instruments/{underlying}' for underlying in r.json()]\n    except Exception as why:\n        raise_failure_explanation('OKEX', why, {url: r})\n\n\ndef okex_symbols_from_one_url(url: str) -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get(url)\n        ret = {}\n        for e in r.json():\n            ret[e['instrument_id']] = e['instrument_id']\n            _exchange_info[OKEX]['tick_size'][e['instrument_id']] = e['tick_size']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('OKEX', why, {url: r})\n\n\ndef bittrex_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.bittrex.com/api/v1.1/public/getmarkets')\n        r = r.json()['result']\n        return {f\"{e['MarketCurrency']}{SYMBOL_SEP}{e['BaseCurrency']}\": e['MarketName'] for e in r if e['IsActive']}\n    except Exception as why:\n        raise_failure_explanation('BITTREX', why, {\"\": r})\n\n\ndef bitcoincom_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.exchange.bitcoin.com/api/2/public/symbol')\n        return {f\"{data['baseCurrency']}{SYMBOL_SEP}{data['quoteCurrency'].replace('USD', 'USDT')}\": data['id'] for data in r.json()}\n    except Exception as why:\n        raise_failure_explanation('BITCOINCOM', why, {\"\": r})\n\n\ndef bitmax_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://bitmax.io/api/pro/v1/products')\n        ret = {}\n        for entry in r.json()['data']:\n            # Only \"Normal\" status symbols are tradeable\n            if entry['status'] == 'Normal':\n                normalized = f\"{entry['baseAsset']}{SYMBOL_SEP}{entry['quoteAsset']}\"\n                ret[normalized] = entry['symbol']\n                _exchange_info[BITMAX]['tick_size'][normalized] = entry['tickSize']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('BITMAX', why, {\"\": r})\n\n\ndef upbit_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.upbit.com/v1/market/all')\n        return {f\"{data['market'].split('-')[1]}{SYMBOL_SEP}{data['market'].split('-')[0]}\": data['market'] for data in r.json()}\n    except Exception as why:\n        raise_failure_explanation('UPBIT', why, {\"\": r})\n\n\ndef blockchain_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get(\"https://api.blockchain.com/mercury-gateway/v1/instruments\")\n        return {data[\"symbol\"].replace(\"-\", SYMBOL_SEP): data[\"symbol\"] for data in r.json()}\n    except Exception as why:\n        raise_failure_explanation('BLOCKCHAIN', why, {\"\": r})\n\n\ndef gateio_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get(\"https://api.gateio.ws/api/v4/spot/currency_pairs\")\n        return {data[\"id\"].replace(\"_\", SYMBOL_SEP): data['id'] for data in r.json()}\n    except Exception as why:\n        raise_failure_explanation('GATEIO', why, {\"\": r})\n\n\ndef bitmex_symbols() -> Dict[str, str]:\n    r = None\n    ret = {}\n    try:\n        r = requests.get(\"https://www.bitmex.com/api/v1/instrument/active\")\n        for entry in r.json():\n            components = []\n            components.append(entry['rootSymbol'])\n            components.append(entry['quoteCurrency'])\n\n            if entry['expiry']:\n                components.append(entry['symbol'][-3:])\n\n            normalized = SYMBOL_SEP.join(components)\n            normalized = normalized.replace(\"XBT\", \"BTC\")\n            ret[normalized] = entry['symbol']\n            _exchange_info[BITMEX]['tick_size'][normalized] = entry['tickSize']\n\n            if entry['expiry']:\n                _exchange_info[BITMEX]['expiry'][normalized] = entry['expiry']\n\n        return ret\n    except Exception as why:\n        raise_failure_explanation('BITMEX', why, {\"\": r})\n\n\ndef deribit_symbols() -> Dict[str, str]:\n    url = r = None\n    ret = {}\n    try:\n        # TODO: get currencies from https://www.deribit.com/api/v2/public/get_currencies\n        currencies = ['BTC', 'ETH']\n        for c in currencies:\n            url = f\"https://www.deribit.com/api/v2/public/get_instruments?currency={c}&expired=false\"\n            r = requests.get(url)\n            for entry in r.json()['result']:\n                split = entry['instrument_name'].split(\"-\")\n                normalized = split[0] + SYMBOL_SEP + entry['quote_currency'] + \"-\" + '-'.join(split[1:])\n                ret[normalized] = entry['instrument_name']\n                _exchange_info[DERIBIT]['tick_size'][normalized] = entry['tick_size']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('DERIBIT', why, {url: r})\n\n\ndef kraken_future_symbols() -> Dict[str, str]:\n    r = None\n    ret = {}\n    try:\n        r = requests.get('https://futures.kraken.com/derivatives/api/v3/instruments')\n        data = r.json()['instruments']\n        for entry in data:\n            if not entry['tradeable']:\n                continue\n            normalized = entry['symbol'].upper().replace(\"_\", \"-\")\n            symbol = normalized[3:6] + SYMBOL_SEP + normalized[6:9]\n            normalized = normalized.replace(normalized[3:9], symbol)\n            normalized = normalized.replace('XBT', 'BTC')\n\n            _exchange_info[KRAKEN_FUTURES]['tick_size'][normalized] = entry['tickSize']\n            _exchange_info[KRAKEN_FUTURES]['contract_size'][normalized] = entry['contractSize']\n            _exchange_info[KRAKEN_FUTURES]['underlying'][normalized] = entry['underlying']\n            _exchange_info[KRAKEN_FUTURES]['product_type'][normalized] = _kraken_futures_product_type[normalized[:2]]\n            ret[normalized] = entry['symbol']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('KRAKEN_FUTURES', why, {\"\": r})\n\n\ndef probit_symbols() -> Dict[str, str]:\n    # doc: https://docs-en.probit.com/reference-link/market\n    r = None\n    try:\n        r = requests.get('https://api.probit.com/api/exchange/v1/market')\n        return {entry['id']: entry['id'] for entry in r.json()['data']}\n    except Exception as why:\n        raise_failure_explanation('PROBIT', why, {\"\": r})\n\n\ndef coingecko_normalize_symbol(symbol: str) -> str:\n    # keep digits, letters and dots, replace others by space\n    symbol = ''.join(c if c.isalnum() or c in ('.', '+') else ' ' for c in symbol)\n    return coingecko_normalize(symbol.upper())\n\n\ndef coingecko_normalize_name(name: str) -> str:\n    # keep digits and letters, replace others by space (except when only composed by upper case letters, digits and dots)\n    if not all(c.isupper() or c.isdigit() or c == '.' for c in name):\n        name = ''.join(c if c.isalnum() else ' ' for c in name)\n    return coingecko_normalize(name)\n\n\ndef coingecko_normalize(sym: str) -> str:\n    sym = sym.strip()\n    # do not concatenate numbers => separate them with a dot\n    sym = list(sym)\n    if len(sym) > 4:\n        for i in range(2, len(sym) - 1):\n            if sym[i] == ' ' and sym[i - 1].isdigit() and sym[i + 1].isdigit():\n                sym[i] = '.'\n    sym = ''.join(sym)\n    # concatenate space-separated words => use CamelCase to distinguish the words\n    if ' ' in sym:\n        if sum(c.islower() for c in sym):  # if there is at least one lower case letter\n            sym = ' '.join(word[0].upper() + word[1:] for word in sym.split())  # Just capitalize initial letter of each word\n        else:  # CoinGecko may provide full upper-case as for \"THE STONE COIN\"\n            sym = string.capwords(sym)  # capwords converts \"THE STONE COIN\" to \"The Stone Coin\"\n        sym = sym.replace(' ', '')  # concatenate words\n    return sym\n\n\ndef is_name_short(coin: dict) -> bool:\n    \"\"\"return True if the coin name is enough short compared to the coin symbol.\"\"\"\n    return len(coin['name']) <= max(5, len(coin['symbol']) + 1)\n\n\ndef has_many_caps(name: str) -> bool:\n    \"\"\"return True if the symbol contains enough upper case letters, False if empty.\"\"\"\n    return str and sum(c.islower() for c in name) < (len(name) / 2)\n\n\ndef coingecko_normalize_all(coin: dict):\n    SYMBOL_TO_NORMALIZED = {'miota': 'IOTA'}\n    normalized = SYMBOL_TO_NORMALIZED.get(coin['symbol'])\n    if normalized:\n        coin['ns'] = coin['nn'] = normalized\n        return normalized\n\n    # ns = normalized symbol, nn = normalized name\n    coin['ns'] = coingecko_normalize_symbol(coin['symbol'])\n\n    ID_SUFFIX = '-bitcoin-token'\n    if coin['id'][-len(ID_SUFFIX):] == ID_SUFFIX:\n        coin['nn'] = 'BTC' + coin['ns']\n        return coin['nn']\n\n    name = coin['name']\n\n    prefixes = ('The ', 'the ')\n    for p in prefixes:\n        if name[:len(p)] == p:\n            coin['reduced-name'] = True\n            name = name[len(p):]\n            break\n\n    suffixes = ('coin', 'coins', 'money', 'finance', 'protocol', 'reward', 'rewards', 'token')\n    for s in suffixes:\n        if len(name) > len(s) and name[-len(s):].lower() == s:\n            # but keep suffix when lower-case concatenated\n            if name[-len(s)].islower() and name[-len(s) - 1] != ' ':\n                continue\n            # also keep suffix to avoid confusing nam: \"Bitcoin Token\" -> \"Bitcoin\"\n            if name[:-len(s)].strip().lower() == 'bitcoin':\n                continue\n            coin['reduced-name'] = True\n            name = name[:-len(s)]\n            break\n\n    coin['nn'] = coingecko_normalize_name(name)\n\n    if len(coin['nn']) < len(coin['ns']):\n        if 'reduced-name' in coin:\n            coin['reduced-name'] = False\n            name = coin['name']\n            coin['nn'] = coingecko_normalize_name(name)\n        elif not has_many_caps(name):\n            return coin['ns']\n\n    if not coin['ns']:  # coin['symbol'] may be an emoji that is striped when normalized\n        return coin['nn']\n\n    if coin.get('reduced-name') and coin['ns'].upper() != coin['nn'].upper():\n        return coin['ns']\n\n    i = coin['nn'].find('.')  # if there is a dot in normalized name => prefer the normalized symbol\n    if i >= 0:\n        if i > 1 and coin['nn'][i - 1].isdigit() and coin['nn'][i + 1].isdigit():\n            pass  # except when the dot separates digits\n        else:\n            return coin['ns']\n\n    if is_name_short(coin) and has_many_caps(name):\n        return coin['nn']\n\n    if 1.5 * len(coin['ns']) > len(coin['nn']) and any(c.islower() for c in coin['ns']):\n        return coin['nn']\n\n    return coin['ns']\n\n\ndef coingecko_symbols() -> Dict[str, str]:\n    r = None\n    intermediate = defaultdict(list)\n    try:\n        r = requests.get('https://api.coingecko.com/api/v3/coins/list')\n        all_coins = r.json()\n        # First pass: generate & compare normalized symbol/name, and then select the most pertinent\n        for coin in all_coins:\n            normalized = coingecko_normalize_all(coin)\n            intermediate[normalized].append(coin)\n            # Above line keeps together the coins having the same normalized symbol.\n            # To reduce collision, the coin['name'] is sometimes used in lieu of the coin['symbol'].\n            # The coin['name'] is not capitalized because lower case letters may be meaningful: cETH, yUSD, DATx, zLOT\n    except Exception as why:\n        raise_failure_explanation('COINGECKO', why, {\"\": r})\n\n    final = coingecko_second_pass(intermediate)\n    return coingecko_third_pass(final)\n\n\ndef coingecko_second_pass(intermediate: Dict[str, List[dict]]) -> Dict[str, List[dict]]:\n    # Second pass: fixes most of the symbol collisions\n    final = defaultdict(list)\n    for normalized, coins in intermediate.items():\n        if len(coins) == 1:\n            final[normalized].append(coins[0])\n            continue\n        set_normalized = False\n        for i in range(len(coins)):\n            if normalized == coins[i]['nn']:\n                coin = coins.pop(i)\n                final[normalized].append(coin)\n                set_normalized = True\n                break\n        rest: List[dict] = []\n        for coin in coins:\n            if '%' in coin['name']:\n                if len(coins) == 1:\n                    n = coin['ns']\n                else:\n                    n = coingecko_normalize_name(coin['id'])\n                final[n].append(coin)\n            else:\n                rest.append(coin)\n        if not rest:\n            continue\n        if not set_normalized:\n            rest.sort(key=lambda coin: len(coin['nn']), reverse=True)  # sort by the length of the normalized name\n            coin = rest.pop(0)\n            final[normalized].append(coin)\n        for coin in rest:\n            if coin['nn'] not in intermediate:\n                n = coin['nn']\n            elif coin.get('reduced-name'):\n                n = coingecko_normalize_name(coin['name'])\n            else:\n                n = coingecko_normalize_name(coin['id'])\n            final[n].append(coin)\n    return final\n\n\ndef coingecko_third_pass(final: Dict[str, List[dict]]) -> Dict[str, str]:\n    # Third pass: fixes some remaining collisions and fills the result\n    symbols = {}\n    for normalized, coins in final.items():\n        if len(coins) == 1:\n            symbols[normalized] = coins[0]['id']\n            continue\n        set_normalized = False\n        for i in range(len(coins)):\n            if normalized == coins[i]['nn']:\n                coin = coins.pop(i)\n                symbols[normalized] = coin['id']\n                set_normalized = True\n                break\n        rest: List[dict] = []\n        for coin in coins:\n            if '%' in coin['name']:\n                if len(coins) == 1:\n                    n = coin['ns']\n                else:\n                    n = coingecko_normalize_name(coin['id'])\n                symbols[n] = coin['id']\n            else:\n                rest.append(coin)\n        if not rest:\n            continue\n        if not set_normalized:\n            rest.sort(key=lambda coin: len(coin['nn']), reverse=True)  # sort by the length of the normalized name\n            coin = rest.pop(0)\n            symbols[normalized] = coin['id']\n        for coin in rest:\n            if coin['nn'] not in final:\n                n = coin['nn']\n            elif coin.get('reduced-name'):\n                n = coingecko_normalize_name(coin['name'])\n            else:\n                n = coingecko_normalize_name(coin['id'])\n            symbols[n] = coin['id']\n    return symbols\n\n\ndef whale_alert_coins(key_id: str) -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get(f'https://api.whale-alert.io/v1/status?api_key={key_id}')\n        # Same symbols, but on different blockchains (for instance USDT), are naturally overwritten.\n        return {s.upper(): s for b in r.json()['blockchains'] for s in b['symbols'] if s}\n    except Exception as why:\n        raise_failure_explanation('WHALES_ALERT', why, {\"\": r})\n\n\n_exchange_function_map = {\n    BITFINEX: bitfinex_symbols,\n    BITFLYER: bitflyer_symbols,\n    COINBASE: coinbase_symbols,\n    GEMINI: gemini_symbols,\n    HITBTC: hitbtc_symbols,\n    POLONIEX: poloniex_symbols,\n    PROBIT: probit_symbols,\n    BITSTAMP: bitstamp_symbols,\n    KRAKEN: kraken_symbols,\n    KRAKEN + 'REST': kraken_rest_symbols,\n    BINANCE: binance_symbols,\n    BINANCE_US: binance_us_symbols,\n    BINANCE_FUTURES: binance_futures_symbols,\n    BINANCE_DELIVERY: binance_delivery_symbols,\n    BLOCKCHAIN: blockchain_symbols,\n    EXX: exx_symbols,\n    HUOBI: huobi_symbols,\n    HUOBI_DM: huobi_dm_symbols,\n    HUOBI_SWAP: huobi_swap_symbols,\n    OKCOIN: okcoin_symbols,\n    OKEX: okex_symbols,\n    BYBIT: bybit_symbols,\n    FTX: ftx_symbols,\n    FTX_US: ftx_us_symbols,\n    BITTREX: bittrex_symbols,\n    BITCOINCOM: bitcoincom_symbols,\n    BITMAX: bitmax_symbols,\n    UPBIT: upbit_symbols,\n    GATEIO: gateio_symbols,\n    BITMEX: bitmex_symbols,\n    DERIBIT: deribit_symbols,\n    KRAKEN_FUTURES: kraken_future_symbols,\n    COINGECKO: coingecko_symbols,\n    WHALE_ALERT: whale_alert_coins\n}\n",
        "source_code_len": 30534,
        "target_code": "associated with this software.\n'''\nfrom typing import Dict, Tuple\n\n\nclass _Symbols:\n    def __init__(self):\n        self.data = {}\n\n    def set(self, exchange: str, normalized: dict, exchange_info: dict):\n        self.data[exchange] = {}\n        self.data[exchange]['normalized'] = normalized\n        self.data[exchange]['info'] = exchange_info\n\n    def get(self, exchange: str) -> Tuple[Dict, Dict]:\n        return self.data[exchange]['normalized'], self.data[exchange]['info']\n\n    def populated(self, exchange: str) -> bool:\n        return exchange in self.data\n\n\nSymbols = _Symbols()\n",
        "target_code_len": 588,
        "diff_format": "@@ -5,845 +5,22 @@\n associated with this software.\n+'''\n+from typing import Dict, Tuple\n \n \n-Symbol generation code for exchanges\n-'''\n+class _Symbols:\n+    def __init__(self):\n+        self.data = {}\n \n-import logging\n-import string\n-import time\n-from collections import defaultdict\n-from typing import Dict, List, Optional, Tuple\n+    def set(self, exchange: str, normalized: dict, exchange_info: dict):\n+        self.data[exchange] = {}\n+        self.data[exchange]['normalized'] = normalized\n+        self.data[exchange]['info'] = exchange_info\n \n-import requests\n-from requests import Response\n+    def get(self, exchange: str) -> Tuple[Dict, Dict]:\n+        return self.data[exchange]['normalized'], self.data[exchange]['info']\n \n-from cryptofeed.defines import *\n+    def populated(self, exchange: str) -> bool:\n+        return exchange in self.data\n \n \n-LOG = logging.getLogger('feedhandler')\n-\n-SYMBOL_SEP = '-'\n-\n-_symbols_retrieval_cache: Dict[str, Dict[str, str]] = {}\n-_exchange_info = defaultdict(lambda: defaultdict(dict))\n-\n-\n-_kraken_futures_product_type = {\n-    'FI': 'Inverse Futures',\n-    'FV': 'Vanilla Futures',\n-    'PI': 'Perpetual Inverse Futures',\n-    'PV': 'Perpetual Vanilla Futures',\n-    'IN': 'Real Time Index',\n-    'RR': 'Reference Rate',\n-}\n-\n-\n-def raise_failure_explanation(feed_id: str, exception: BaseException, responses: Dict[str, Optional[Response]]):\n-    LOG.critical('%s: encountered %r while processing response from exchange API', feed_id, exception)\n-    if len(responses) > 1:\n-        LOG.critical('%s: content of one of the %s responses was unexpected', feed_id, len(responses))\n-    for url, r in responses.items():\n-        if url:\n-            LOG.critical('%s: requested URL: %s', feed_id, url)\n-        if r:\n-            LOG.critical('%s: unexpected response: %s', feed_id, r.text)\n-    raise ValueError(f'Cryptofeed stopped because of an unexpected response from {feed_id}') from exception\n-\n-\n-def set_symbol_separator(separator: str):\n-    global SYMBOL_SEP\n-    SYMBOL_SEP = separator\n-\n-\n-def get_symbol_separator() -> str:\n-    global SYMBOL_SEP\n-    return SYMBOL_SEP\n-\n-\n-def gen_symbols(exchange: str, key_id=None) -> Dict[str, str]:\n-    if exchange not in _symbols_retrieval_cache:\n-        LOG.info(\"%s: Getting list of symbols\", exchange)\n-        symbols = _exchange_function_map[exchange](key_id) if key_id else _exchange_function_map[exchange]()\n-        LOG.info(\"%s: %s symbols\", exchange, len(symbols))\n-\n-        # log all retrieved symbols using debug level\n-        for normalized, exch_sym in sorted(symbols.items()):\n-            LOG.debug('%s: id-from-exch -> normalized: %-35s-> %s', exchange, exch_sym, normalized)\n-\n-        _symbols_retrieval_cache[exchange] = symbols\n-    return _symbols_retrieval_cache[exchange]\n-\n-\n-def _binance_symbols(endpoint: str, exchange: str):\n-    r = None\n-    try:\n-        ret = {}\n-        r = requests.get(endpoint)\n-        for symbol in r.json()['symbols']:\n-            if symbol.get('status', 'TRADING') != \"TRADING\":\n-                continue\n-            if symbol.get('contractStatus', 'TRADING') != \"TRADING\":\n-                continue\n-            split = len(symbol['baseAsset'])\n-            normalized = symbol['symbol'][:split] + SYMBOL_SEP + symbol['symbol'][split:]\n-            ret[normalized] = symbol['symbol']\n-            _exchange_info[exchange]['tick_size'][normalized] = symbol['filters'][0]['tickSize']\n-            if \"contractType\" in symbol:\n-                _exchange_info[exchange]['contract_type'][normalized] = symbol['contractType']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation(exchange, why, {endpoint: r})\n-\n-\n-def binance_symbols() -> Dict[str, str]:\n-    return _binance_symbols('https://api.binance.com/api/v3/exchangeInfo', BINANCE)\n-\n-\n-def binance_us_symbols() -> Dict[str, str]:\n-    return _binance_symbols('https://api.binance.us/api/v3/exchangeInfo', BINANCE_US)\n-\n-\n-def binance_futures_symbols() -> Dict[str, str]:\n-    base = _binance_symbols('https://fapi.binance.com/fapi/v1/exchangeInfo', BINANCE_FUTURES)\n-    add = {}\n-    for symbol, orig in base.items():\n-        if \"_\" in orig:\n-            continue\n-        add[f\"{symbol}-PINDEX\"] = f\"p{orig}\"\n-    base.update(add)\n-    return base\n-\n-\n-def binance_delivery_symbols() -> Dict[str, str]:\n-    return _binance_symbols('https://dapi.binance.com/dapi/v1/exchangeInfo', BINANCE_DELIVERY)\n-\n-\n-def bitfinex_symbols() -> Dict[str, str]:\n-    # doc: https://docs.bitfinex.com/docs/ws-general#supported-pairs\n-    r1 = r2 = None\n-    try:\n-        r1 = requests.get('https://api.bitfinex.com/v2/tickers?symbols=ALL')\n-        r2 = requests.get('https://api-pub.bitfinex.com/v2/conf/pub:map:currency:sym')\n-        tickers: List[List[str]] = r1.json()\n-        norm: List[Tuple[str, str]] = r2.json()[0]\n-        norm: Dict[str, str] = dict(norm)\n-        for k, v in dict(norm).items():\n-            if k[-2:] == 'F0' or '-' in v:  # Do not convert BTCF0 -> BTC or PBTCETH -> PBTC-ETH\n-                del norm[k]\n-        norm['BCHN'] = 'BCH'  # Bitfinex uses BCHN, other exchanges use BCH\n-\n-        ret = {}\n-        for symbol in [t[0] for t in tickers]:\n-            if symbol[0] == 'f':\n-                normalized = norm.get(symbol[1:], symbol[1:])\n-            else:\n-                if len(symbol) == 7:\n-                    base, quote = symbol[1:4], symbol[4:]\n-                else:\n-                    base, quote = symbol[1:].split(':')\n-                    assert ':' in symbol\n-                normalized = norm.get(base, base) + SYMBOL_SEP + norm.get(quote, quote)\n-            ret[normalized.upper()] = symbol\n-        return ret\n-    except ValueError as why:\n-        raise_failure_explanation('BITFINEX', why, {\"tickers?symbols=ALL\": r1, \"pub:map:currency:sym\": r2})\n-\n-\n-def bitflyer_symbols() -> Dict[str, str]:\n-    endpoint = r = None\n-    try:\n-        ret = {}\n-        endpoints = ['https://api.bitflyer.com/v1/getmarkets/eu', 'https://api.bitflyer.com/v1/getmarkets/usa', 'https://api.bitflyer.com/v1/getmarkets']\n-        for endpoint in endpoints:\n-            r = requests.get(endpoint)\n-            for entry in r.json():\n-                normalized = entry['product_code'].replace(\"_\", SYMBOL_SEP)\n-                ret[normalized] = entry['product_code']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('BITFLYER', why, {endpoint: r})\n-\n-\n-def bybit_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.bybit.com/v2/public/symbols')\n-        ret = {}\n-        for symbol in r.json()['result']:\n-            quote = symbol['quote_currency']\n-            if not symbol['name'].endswith(quote):\n-                base, contract = symbol['name'].split(quote)\n-                normalized = f\"{base}{SYMBOL_SEP}{quote}-{contract}\"\n-            else:\n-                normalized = f\"{symbol['base_currency']}{SYMBOL_SEP}{quote}\"\n-            ret[normalized] = symbol['name']\n-            _exchange_info[BYBIT]['tick_size'][normalized] = symbol['price_filter']['tick_size']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('BYBIT', why, {\"\": r})\n-\n-\n-def _ftx_helper(endpoint: str, exchange: str):\n-    r = None\n-    try:\n-        r = requests.get(endpoint)\n-        ret = {}\n-        for data in r.json()['result']:\n-            normalized = data['name'].replace(\"/\", SYMBOL_SEP)\n-            symbol = data['name']\n-            ret[normalized] = symbol\n-            _exchange_info[exchange]['tick_size'][normalized] = data['priceIncrement']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation(exchange, why, {endpoint: r})\n-\n-\n-def ftx_symbols() -> Dict[str, str]:\n-    return _ftx_helper('https://ftx.com/api/markets', FTX)\n-\n-\n-def ftx_us_symbols() -> Dict[str, str]:\n-    return _ftx_helper('https://ftx.us/api/markets', FTX_US)\n-\n-\n-def coinbase_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.pro.coinbase.com/products')\n-        ret = {}\n-        for data in r.json():\n-            normalized = data['id'].replace(\"-\", SYMBOL_SEP)\n-            ret[normalized] = data['id']\n-            _exchange_info[COINBASE]['tick_size'][normalized] = data['quote_increment']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('COINBASE', why, {\"\": r})\n-\n-\n-def gemini_symbols(*args) -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.gemini.com/v1/symbols')\n-        ret = {}\n-        for symbol in r.json():\n-            std = f\"{symbol[:-3]}{SYMBOL_SEP}{symbol[-3:]}\"\n-            std = std.upper()\n-            ret[std] = symbol.upper()\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('GEMINI', why, {\"\": r})\n-\n-\n-def hitbtc_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        ret = {}\n-        r = requests.get('https://api.hitbtc.com/api/2/public/symbol')\n-        for symbol in r.json():\n-            split = len(symbol['baseCurrency'])\n-            normalized = symbol['id'][:split] + SYMBOL_SEP + symbol['id'][split:]\n-            ret[normalized] = symbol['id']\n-            _exchange_info[HITBTC]['tick_size'][normalized] = symbol['tickSize']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('HITBTC', why, {\"\": r})\n-\n-\n-def poloniex_id_symbol_mapping():\n-    r = None\n-    try:\n-        r = requests.get('https://poloniex.com/public?command=returnTicker')\n-        symbols = r.json()\n-        ret = {}\n-        for symbol in symbols:\n-            ret[symbols[symbol]['id']] = symbol\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('POLONIEX', why, {\"\": r})\n-\n-\n-def poloniex_symbols() -> Dict[str, str]:\n-    ret = {}\n-    for _, value in poloniex_id_symbol_mapping().items():\n-        std = value.replace(\"STR\", \"XLM\")\n-        quote, base = std.split(\"_\")\n-        ret[quote + SYMBOL_SEP + base] = value\n-    return ret\n-\n-\n-def bitstamp_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://www.bitstamp.net/api/v2/trading-pairs-info/')\n-        ret = {}\n-        for data in r.json():\n-            normalized = data['name'].replace(\"/\", SYMBOL_SEP)\n-            symbol = data['url_symbol']\n-            ret[normalized] = symbol\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('BITSTAMP', why, {\"\": r})\n-\n-\n-def kraken_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.kraken.com/0/public/AssetPairs')\n-        data = r.json()\n-        ret = {}\n-        for symbol in data['result']:\n-            if 'wsname' not in data['result'][symbol] or '.d' in symbol:\n-                # https://blog.kraken.com/post/259/introducing-the-kraken-dark-pool/\n-                # .d is for dark pool symbols\n-                continue\n-\n-            base, quote = data['result'][symbol]['wsname'].split(\"/\")\n-\n-            normalized = f\"{base}{SYMBOL_SEP}{quote}\"\n-            exch = data['result'][symbol]['wsname']\n-            normalized = normalized.replace('XBT', 'BTC')\n-            normalized = normalized.replace('XDG', 'DOG')\n-            ret[normalized] = exch\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('KRAKEN', why, {\"\": r})\n-\n-\n-def kraken_rest_symbols() -> Dict[str, str]:\n-    return {normalized: exchange.replace(\"/\", \"\") for normalized, exchange in kraken_symbols().items()}\n-\n-\n-def exx_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.exx.com/data/v1/tickers')\n-        exchange = [key.upper() for key in r.json().keys()]\n-        symbols = [key.replace(\"_\", SYMBOL_SEP) for key in exchange]\n-        return dict(zip(symbols, exchange))\n-    except Exception as why:\n-        raise_failure_explanation('EXX', why, {\"\": r})\n-\n-\n-def huobi_common_symbols(url: str):\n-    r = None\n-    try:\n-        r = requests.get(url)\n-        ret = {}\n-        for e in r.json()['data']:\n-            if e['state'] == 'offline':\n-                continue\n-            normalized = f\"{e['base-currency'].upper()}{SYMBOL_SEP}{e['quote-currency'].upper()}\"\n-            symbol = f\"{e['base-currency']}{e['quote-currency']}\"\n-            ret[normalized] = symbol\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('HUOBI', why, {url: r})\n-\n-\n-def huobi_symbols() -> Dict[str, str]:\n-    return huobi_common_symbols('https://api.huobi.pro/v1/common/symbols')\n-\n-\n-def huobi_us_symbols() -> Dict[str, str]:\n-    return huobi_common_symbols('https://api.huobi.com/v1/common/symbols')\n-\n-\n-def huobi_dm_symbols() -> Dict[str, str]:\n-    \"\"\"\n-    Mapping is, for instance: {\"BTC_CW\":\"BTC190816\"}\n-    See comments in exchange/huobi_dm.py\n-    \"\"\"\n-    mapping = {\n-        \"this_week\": \"CW\",\n-        \"next_week\": \"NW\",\n-        \"quarter\": \"CQ\",\n-        \"next_quarter\": \"NQ\"\n-    }\n-    r = None\n-    try:\n-        r = requests.get('https://www.hbdm.com/api/v1/contract_contract_info')\n-        symbols = {}\n-        for e in r.json()['data']:\n-            symbols[f\"{e['symbol']}_{mapping[e['contract_type']]}\"] = e['contract_code']\n-            _exchange_info[HUOBI_DM]['tick_size'][e['contract_code']] = e['price_tick']\n-            _exchange_info[HUOBI_DM]['short_code_mappings'][f\"{e['symbol']}_{mapping[e['contract_type']]}\"] = e['contract_code']\n-        return symbols\n-    except Exception as why:\n-        raise_failure_explanation('HUOBI_DM', why, {\"\": r})\n-\n-\n-def huobi_swap_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.hbdm.com/swap-api/v1/swap_contract_info')\n-        symbols = {}\n-        for e in r.json()['data']:\n-            symbols[e['contract_code']] = e['contract_code']\n-            _exchange_info[HUOBI_SWAP]['tick_size'][e['contract_code']] = e['price_tick']\n-        return symbols\n-    except Exception as why:\n-        raise_failure_explanation('HUOBI_SWAP', why, {\"\": r})\n-\n-\n-def okcoin_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://www.okcoin.com/api/spot/v3/instruments')\n-        ret = {}\n-        for e in r.json():\n-            ret[e['instrument_id']] = e['instrument_id']\n-            _exchange_info[OKCOIN]['tick_size'][e['instrument_id']] = e['tick_size']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('OKCOIN', why, {\"\": r})\n-\n-\n-def okex_symbols(*args) -> Dict[str, str]:\n-    urls = ['https://www.okex.com/api/spot/v3/instruments',\n-            'https://www.okex.com/api/swap/v3/instruments',\n-            'https://www.okex.com/api/futures/v3/instruments']\n-    urls = urls + okex_compute_option_urls_from_underlyings()\n-\n-    symbols: Dict[str, str] = {}\n-    for u in urls:\n-        time.sleep(0.2)\n-        symbols.update(okex_symbols_from_one_url(u))\n-\n-    for symbol in symbols:\n-        instrument_type = 'futures'\n-        dash_count = symbol.count(get_symbol_separator())\n-        if dash_count == 1:  # BTC-USDT\n-            instrument_type = 'spot'\n-        if dash_count == 4:  # BTC-USD-201225-35000-P\n-            instrument_type = 'option'\n-        if symbol[-4:] == \"SWAP\":  # BTC-USDT-SWAP\n-            instrument_type = 'swap'\n-\n-        _exchange_info[OKEX]['instrument_type'][symbol] = instrument_type\n-\n-    return symbols\n-\n-\n-def okex_compute_option_urls_from_underlyings() -> List[str]:\n-    url = 'https://www.okex.com/api/option/v3/underlying'\n-    r = None\n-    try:\n-        r = requests.get(url)\n-        return [f'https://www.okex.com/api/option/v3/instruments/{underlying}' for underlying in r.json()]\n-    except Exception as why:\n-        raise_failure_explanation('OKEX', why, {url: r})\n-\n-\n-def okex_symbols_from_one_url(url: str) -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get(url)\n-        ret = {}\n-        for e in r.json():\n-            ret[e['instrument_id']] = e['instrument_id']\n-            _exchange_info[OKEX]['tick_size'][e['instrument_id']] = e['tick_size']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('OKEX', why, {url: r})\n-\n-\n-def bittrex_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.bittrex.com/api/v1.1/public/getmarkets')\n-        r = r.json()['result']\n-        return {f\"{e['MarketCurrency']}{SYMBOL_SEP}{e['BaseCurrency']}\": e['MarketName'] for e in r if e['IsActive']}\n-    except Exception as why:\n-        raise_failure_explanation('BITTREX', why, {\"\": r})\n-\n-\n-def bitcoincom_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.exchange.bitcoin.com/api/2/public/symbol')\n-        return {f\"{data['baseCurrency']}{SYMBOL_SEP}{data['quoteCurrency'].replace('USD', 'USDT')}\": data['id'] for data in r.json()}\n-    except Exception as why:\n-        raise_failure_explanation('BITCOINCOM', why, {\"\": r})\n-\n-\n-def bitmax_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://bitmax.io/api/pro/v1/products')\n-        ret = {}\n-        for entry in r.json()['data']:\n-            # Only \"Normal\" status symbols are tradeable\n-            if entry['status'] == 'Normal':\n-                normalized = f\"{entry['baseAsset']}{SYMBOL_SEP}{entry['quoteAsset']}\"\n-                ret[normalized] = entry['symbol']\n-                _exchange_info[BITMAX]['tick_size'][normalized] = entry['tickSize']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('BITMAX', why, {\"\": r})\n-\n-\n-def upbit_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.upbit.com/v1/market/all')\n-        return {f\"{data['market'].split('-')[1]}{SYMBOL_SEP}{data['market'].split('-')[0]}\": data['market'] for data in r.json()}\n-    except Exception as why:\n-        raise_failure_explanation('UPBIT', why, {\"\": r})\n-\n-\n-def blockchain_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get(\"https://api.blockchain.com/mercury-gateway/v1/instruments\")\n-        return {data[\"symbol\"].replace(\"-\", SYMBOL_SEP): data[\"symbol\"] for data in r.json()}\n-    except Exception as why:\n-        raise_failure_explanation('BLOCKCHAIN', why, {\"\": r})\n-\n-\n-def gateio_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get(\"https://api.gateio.ws/api/v4/spot/currency_pairs\")\n-        return {data[\"id\"].replace(\"_\", SYMBOL_SEP): data['id'] for data in r.json()}\n-    except Exception as why:\n-        raise_failure_explanation('GATEIO', why, {\"\": r})\n-\n-\n-def bitmex_symbols() -> Dict[str, str]:\n-    r = None\n-    ret = {}\n-    try:\n-        r = requests.get(\"https://www.bitmex.com/api/v1/instrument/active\")\n-        for entry in r.json():\n-            components = []\n-            components.append(entry['rootSymbol'])\n-            components.append(entry['quoteCurrency'])\n-\n-            if entry['expiry']:\n-                components.append(entry['symbol'][-3:])\n-\n-            normalized = SYMBOL_SEP.join(components)\n-            normalized = normalized.replace(\"XBT\", \"BTC\")\n-            ret[normalized] = entry['symbol']\n-            _exchange_info[BITMEX]['tick_size'][normalized] = entry['tickSize']\n-\n-            if entry['expiry']:\n-                _exchange_info[BITMEX]['expiry'][normalized] = entry['expiry']\n-\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('BITMEX', why, {\"\": r})\n-\n-\n-def deribit_symbols() -> Dict[str, str]:\n-    url = r = None\n-    ret = {}\n-    try:\n-        # TODO: get currencies from https://www.deribit.com/api/v2/public/get_currencies\n-        currencies = ['BTC', 'ETH']\n-        for c in currencies:\n-            url = f\"https://www.deribit.com/api/v2/public/get_instruments?currency={c}&expired=false\"\n-            r = requests.get(url)\n-            for entry in r.json()['result']:\n-                split = entry['instrument_name'].split(\"-\")\n-                normalized = split[0] + SYMBOL_SEP + entry['quote_currency'] + \"-\" + '-'.join(split[1:])\n-                ret[normalized] = entry['instrument_name']\n-                _exchange_info[DERIBIT]['tick_size'][normalized] = entry['tick_size']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('DERIBIT', why, {url: r})\n-\n-\n-def kraken_future_symbols() -> Dict[str, str]:\n-    r = None\n-    ret = {}\n-    try:\n-        r = requests.get('https://futures.kraken.com/derivatives/api/v3/instruments')\n-        data = r.json()['instruments']\n-        for entry in data:\n-            if not entry['tradeable']:\n-                continue\n-            normalized = entry['symbol'].upper().replace(\"_\", \"-\")\n-            symbol = normalized[3:6] + SYMBOL_SEP + normalized[6:9]\n-            normalized = normalized.replace(normalized[3:9], symbol)\n-            normalized = normalized.replace('XBT', 'BTC')\n-\n-            _exchange_info[KRAKEN_FUTURES]['tick_size'][normalized] = entry['tickSize']\n-            _exchange_info[KRAKEN_FUTURES]['contract_size'][normalized] = entry['contractSize']\n-            _exchange_info[KRAKEN_FUTURES]['underlying'][normalized] = entry['underlying']\n-            _exchange_info[KRAKEN_FUTURES]['product_type'][normalized] = _kraken_futures_product_type[normalized[:2]]\n-            ret[normalized] = entry['symbol']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('KRAKEN_FUTURES', why, {\"\": r})\n-\n-\n-def probit_symbols() -> Dict[str, str]:\n-    # doc: https://docs-en.probit.com/reference-link/market\n-    r = None\n-    try:\n-        r = requests.get('https://api.probit.com/api/exchange/v1/market')\n-        return {entry['id']: entry['id'] for entry in r.json()['data']}\n-    except Exception as why:\n-        raise_failure_explanation('PROBIT', why, {\"\": r})\n-\n-\n-def coingecko_normalize_symbol(symbol: str) -> str:\n-    # keep digits, letters and dots, replace others by space\n-    symbol = ''.join(c if c.isalnum() or c in ('.', '+') else ' ' for c in symbol)\n-    return coingecko_normalize(symbol.upper())\n-\n-\n-def coingecko_normalize_name(name: str) -> str:\n-    # keep digits and letters, replace others by space (except when only composed by upper case letters, digits and dots)\n-    if not all(c.isupper() or c.isdigit() or c == '.' for c in name):\n-        name = ''.join(c if c.isalnum() else ' ' for c in name)\n-    return coingecko_normalize(name)\n-\n-\n-def coingecko_normalize(sym: str) -> str:\n-    sym = sym.strip()\n-    # do not concatenate numbers => separate them with a dot\n-    sym = list(sym)\n-    if len(sym) > 4:\n-        for i in range(2, len(sym) - 1):\n-            if sym[i] == ' ' and sym[i - 1].isdigit() and sym[i + 1].isdigit():\n-                sym[i] = '.'\n-    sym = ''.join(sym)\n-    # concatenate space-separated words => use CamelCase to distinguish the words\n-    if ' ' in sym:\n-        if sum(c.islower() for c in sym):  # if there is at least one lower case letter\n-            sym = ' '.join(word[0].upper() + word[1:] for word in sym.split())  # Just capitalize initial letter of each word\n-        else:  # CoinGecko may provide full upper-case as for \"THE STONE COIN\"\n-            sym = string.capwords(sym)  # capwords converts \"THE STONE COIN\" to \"The Stone Coin\"\n-        sym = sym.replace(' ', '')  # concatenate words\n-    return sym\n-\n-\n-def is_name_short(coin: dict) -> bool:\n-    \"\"\"return True if the coin name is enough short compared to the coin symbol.\"\"\"\n-    return len(coin['name']) <= max(5, len(coin['symbol']) + 1)\n-\n-\n-def has_many_caps(name: str) -> bool:\n-    \"\"\"return True if the symbol contains enough upper case letters, False if empty.\"\"\"\n-    return str and sum(c.islower() for c in name) < (len(name) / 2)\n-\n-\n-def coingecko_normalize_all(coin: dict):\n-    SYMBOL_TO_NORMALIZED = {'miota': 'IOTA'}\n-    normalized = SYMBOL_TO_NORMALIZED.get(coin['symbol'])\n-    if normalized:\n-        coin['ns'] = coin['nn'] = normalized\n-        return normalized\n-\n-    # ns = normalized symbol, nn = normalized name\n-    coin['ns'] = coingecko_normalize_symbol(coin['symbol'])\n-\n-    ID_SUFFIX = '-bitcoin-token'\n-    if coin['id'][-len(ID_SUFFIX):] == ID_SUFFIX:\n-        coin['nn'] = 'BTC' + coin['ns']\n-        return coin['nn']\n-\n-    name = coin['name']\n-\n-    prefixes = ('The ', 'the ')\n-    for p in prefixes:\n-        if name[:len(p)] == p:\n-            coin['reduced-name'] = True\n-            name = name[len(p):]\n-            break\n-\n-    suffixes = ('coin', 'coins', 'money', 'finance', 'protocol', 'reward', 'rewards', 'token')\n-    for s in suffixes:\n-        if len(name) > len(s) and name[-len(s):].lower() == s:\n-            # but keep suffix when lower-case concatenated\n-            if name[-len(s)].islower() and name[-len(s) - 1] != ' ':\n-                continue\n-            # also keep suffix to avoid confusing nam: \"Bitcoin Token\" -> \"Bitcoin\"\n-            if name[:-len(s)].strip().lower() == 'bitcoin':\n-                continue\n-            coin['reduced-name'] = True\n-            name = name[:-len(s)]\n-            break\n-\n-    coin['nn'] = coingecko_normalize_name(name)\n-\n-    if len(coin['nn']) < len(coin['ns']):\n-        if 'reduced-name' in coin:\n-            coin['reduced-name'] = False\n-            name = coin['name']\n-            coin['nn'] = coingecko_normalize_name(name)\n-        elif not has_many_caps(name):\n-            return coin['ns']\n-\n-    if not coin['ns']:  # coin['symbol'] may be an emoji that is striped when normalized\n-        return coin['nn']\n-\n-    if coin.get('reduced-name') and coin['ns'].upper() != coin['nn'].upper():\n-        return coin['ns']\n-\n-    i = coin['nn'].find('.')  # if there is a dot in normalized name => prefer the normalized symbol\n-    if i >= 0:\n-        if i > 1 and coin['nn'][i - 1].isdigit() and coin['nn'][i + 1].isdigit():\n-            pass  # except when the dot separates digits\n-        else:\n-            return coin['ns']\n-\n-    if is_name_short(coin) and has_many_caps(name):\n-        return coin['nn']\n-\n-    if 1.5 * len(coin['ns']) > len(coin['nn']) and any(c.islower() for c in coin['ns']):\n-        return coin['nn']\n-\n-    return coin['ns']\n-\n-\n-def coingecko_symbols() -> Dict[str, str]:\n-    r = None\n-    intermediate = defaultdict(list)\n-    try:\n-        r = requests.get('https://api.coingecko.com/api/v3/coins/list')\n-        all_coins = r.json()\n-        # First pass: generate & compare normalized symbol/name, and then select the most pertinent\n-        for coin in all_coins:\n-            normalized = coingecko_normalize_all(coin)\n-            intermediate[normalized].append(coin)\n-            # Above line keeps together the coins having the same normalized symbol.\n-            # To reduce collision, the coin['name'] is sometimes used in lieu of the coin['symbol'].\n-            # The coin['name'] is not capitalized because lower case letters may be meaningful: cETH, yUSD, DATx, zLOT\n-    except Exception as why:\n-        raise_failure_explanation('COINGECKO', why, {\"\": r})\n-\n-    final = coingecko_second_pass(intermediate)\n-    return coingecko_third_pass(final)\n-\n-\n-def coingecko_second_pass(intermediate: Dict[str, List[dict]]) -> Dict[str, List[dict]]:\n-    # Second pass: fixes most of the symbol collisions\n-    final = defaultdict(list)\n-    for normalized, coins in intermediate.items():\n-        if len(coins) == 1:\n-            final[normalized].append(coins[0])\n-            continue\n-        set_normalized = False\n-        for i in range(len(coins)):\n-            if normalized == coins[i]['nn']:\n-                coin = coins.pop(i)\n-                final[normalized].append(coin)\n-                set_normalized = True\n-                break\n-        rest: List[dict] = []\n-        for coin in coins:\n-            if '%' in coin['name']:\n-                if len(coins) == 1:\n-                    n = coin['ns']\n-                else:\n-                    n = coingecko_normalize_name(coin['id'])\n-                final[n].append(coin)\n-            else:\n-                rest.append(coin)\n-        if not rest:\n-            continue\n-        if not set_normalized:\n-            rest.sort(key=lambda coin: len(coin['nn']), reverse=True)  # sort by the length of the normalized name\n-            coin = rest.pop(0)\n-            final[normalized].append(coin)\n-        for coin in rest:\n-            if coin['nn'] not in intermediate:\n-                n = coin['nn']\n-            elif coin.get('reduced-name'):\n-                n = coingecko_normalize_name(coin['name'])\n-            else:\n-                n = coingecko_normalize_name(coin['id'])\n-            final[n].append(coin)\n-    return final\n-\n-\n-def coingecko_third_pass(final: Dict[str, List[dict]]) -> Dict[str, str]:\n-    # Third pass: fixes some remaining collisions and fills the result\n-    symbols = {}\n-    for normalized, coins in final.items():\n-        if len(coins) == 1:\n-            symbols[normalized] = coins[0]['id']\n-            continue\n-        set_normalized = False\n-        for i in range(len(coins)):\n-            if normalized == coins[i]['nn']:\n-                coin = coins.pop(i)\n-                symbols[normalized] = coin['id']\n-                set_normalized = True\n-                break\n-        rest: List[dict] = []\n-        for coin in coins:\n-            if '%' in coin['name']:\n-                if len(coins) == 1:\n-                    n = coin['ns']\n-                else:\n-                    n = coingecko_normalize_name(coin['id'])\n-                symbols[n] = coin['id']\n-            else:\n-                rest.append(coin)\n-        if not rest:\n-            continue\n-        if not set_normalized:\n-            rest.sort(key=lambda coin: len(coin['nn']), reverse=True)  # sort by the length of the normalized name\n-            coin = rest.pop(0)\n-            symbols[normalized] = coin['id']\n-        for coin in rest:\n-            if coin['nn'] not in final:\n-                n = coin['nn']\n-            elif coin.get('reduced-name'):\n-                n = coingecko_normalize_name(coin['name'])\n-            else:\n-                n = coingecko_normalize_name(coin['id'])\n-            symbols[n] = coin['id']\n-    return symbols\n-\n-\n-def whale_alert_coins(key_id: str) -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get(f'https://api.whale-alert.io/v1/status?api_key={key_id}')\n-        # Same symbols, but on different blockchains (for instance USDT), are naturally overwritten.\n-        return {s.upper(): s for b in r.json()['blockchains'] for s in b['symbols'] if s}\n-    except Exception as why:\n-        raise_failure_explanation('WHALES_ALERT', why, {\"\": r})\n-\n-\n-_exchange_function_map = {\n-    BITFINEX: bitfinex_symbols,\n-    BITFLYER: bitflyer_symbols,\n-    COINBASE: coinbase_symbols,\n-    GEMINI: gemini_symbols,\n-    HITBTC: hitbtc_symbols,\n-    POLONIEX: poloniex_symbols,\n-    PROBIT: probit_symbols,\n-    BITSTAMP: bitstamp_symbols,\n-    KRAKEN: kraken_symbols,\n-    KRAKEN + 'REST': kraken_rest_symbols,\n-    BINANCE: binance_symbols,\n-    BINANCE_US: binance_us_symbols,\n-    BINANCE_FUTURES: binance_futures_symbols,\n-    BINANCE_DELIVERY: binance_delivery_symbols,\n-    BLOCKCHAIN: blockchain_symbols,\n-    EXX: exx_symbols,\n-    HUOBI: huobi_symbols,\n-    HUOBI_DM: huobi_dm_symbols,\n-    HUOBI_SWAP: huobi_swap_symbols,\n-    OKCOIN: okcoin_symbols,\n-    OKEX: okex_symbols,\n-    BYBIT: bybit_symbols,\n-    FTX: ftx_symbols,\n-    FTX_US: ftx_us_symbols,\n-    BITTREX: bittrex_symbols,\n-    BITCOINCOM: bitcoincom_symbols,\n-    BITMAX: bitmax_symbols,\n-    UPBIT: upbit_symbols,\n-    GATEIO: gateio_symbols,\n-    BITMEX: bitmex_symbols,\n-    DERIBIT: deribit_symbols,\n-    KRAKEN_FUTURES: kraken_future_symbols,\n-    COINGECKO: coingecko_symbols,\n-    WHALE_ALERT: whale_alert_coins\n-}\n+Symbols = _Symbols()\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\n\nimport logging\nimport string\nimport time\nfrom collections import defaultdict\nfrom typing import Dict, List, Optional, Tuple\n\nimport requests\nfrom requests import Response\n\nfrom cryptofeed.defines import *\n\n\nLOG = logging.getLogger('feedhandler')\n\nSYMBOL_SEP = '-'\n\n_symbols_retrieval_cache: Dict[str, Dict[str, str]] = {}\n_exchange_info = defaultdict(lambda: defaultdict(dict))\n\n\n_kraken_futures_product_type = {\n    'FI': 'Inverse Futures',\n    'FV': 'Vanilla Futures',\n    'PI': 'Perpetual Inverse Futures',\n    'PV': 'Perpetual Vanilla Futures',\n    'IN': 'Real Time Index',\n    'RR': 'Reference Rate',\n}\n\n\ndef raise_failure_explanation(feed_id: str, exception: BaseException, responses: Dict[str, Optional[Response]]):\n    <IND>LOG.critical('%s: encountered %r while processing response from exchange API', feed_id, exception)\n    if len(responses) > 1:\n        <IND>LOG.critical('%s: content of one of the %s responses was unexpected', feed_id, len(responses))\n    <DED>for url, r in responses.items():\n        <IND>if url:\n            <IND>LOG.critical('%s: requested URL: %s', feed_id, url)\n        <DED>if r:\n            <IND>LOG.critical('%s: unexpected response: %s', feed_id, r.text)\n    <DED><DED>raise ValueError(f'Cryptofeed stopped because of an unexpected response from {feed_id}') from exception\n\n\n<DED>def set_symbol_separator(separator: str):\n    <IND>global SYMBOL_SEP\n    SYMBOL_SEP = separator\n\n\n<DED>def get_symbol_separator() -> str:\n    <IND>global SYMBOL_SEP\n    return SYMBOL_SEP\n\n\n<DED>def gen_symbols(exchange: str, key_id=None) -> Dict[str, str]:\n    <IND>if exchange not in _symbols_retrieval_cache:\n        <IND>LOG.info(\"%s: Getting list of symbols\", exchange)\n        symbols = _exchange_function_map[exchange](key_id) if key_id else _exchange_function_map[exchange]()\n        LOG.info(\"%s: %s symbols\", exchange, len(symbols))\n\n        # log all retrieved symbols using debug level\n        for normalized, exch_sym in sorted(symbols.items()):\n            <IND>LOG.debug('%s: id-from-exch -> normalized: %-35s-> %s', exchange, exch_sym, normalized)\n\n        <DED>_symbols_retrieval_cache[exchange] = symbols\n    <DED>return _symbols_retrieval_cache[exchange]\n\n\n<DED>def _binance_symbols(endpoint: str, exchange: str):\n    <IND>r = None\n    try:\n        <IND>ret = {}\n        r = requests.get(endpoint)\n        for symbol in r.json()['symbols']:\n            <IND>if symbol.get('status', 'TRADING') != \"TRADING\":\n                <IND>continue\n            <DED>if symbol.get('contractStatus', 'TRADING') != \"TRADING\":\n                <IND>continue\n            <DED>split = len(symbol['baseAsset'])\n            normalized = symbol['symbol'][:split] + SYMBOL_SEP + symbol['symbol'][split:]\n            ret[normalized] = symbol['symbol']\n            _exchange_info[exchange]['tick_size'][normalized] = symbol['filters'][0]['tickSize']\n            if \"contractType\" in symbol:\n                <IND>_exchange_info[exchange]['contract_type'][normalized] = symbol['contractType']\n        <DED><DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation(exchange, why, {endpoint: r})\n\n\n<DED><DED>def binance_symbols() -> Dict[str, str]:\n    <IND>return _binance_symbols('https://api.binance.com/api/v3/exchangeInfo', BINANCE)\n\n\n<DED>def binance_us_symbols() -> Dict[str, str]:\n    <IND>return _binance_symbols('https://api.binance.us/api/v3/exchangeInfo', BINANCE_US)\n\n\n<DED>def binance_futures_symbols() -> Dict[str, str]:\n    <IND>base = _binance_symbols('https://fapi.binance.com/fapi/v1/exchangeInfo', BINANCE_FUTURES)\n    add = {}\n    for symbol, orig in base.items():\n        <IND>if \"_\" in orig:\n            <IND>continue\n        <DED>add[f\"{symbol}-PINDEX\"] = f\"p{orig}\"\n    <DED>base.update(add)\n    return base\n\n\n<DED>def binance_delivery_symbols() -> Dict[str, str]:\n    <IND>return _binance_symbols('https://dapi.binance.com/dapi/v1/exchangeInfo', BINANCE_DELIVERY)\n\n\n<DED>def bitfinex_symbols() -> Dict[str, str]:\n    # doc: https://docs.bitfinex.com/docs/ws-general#supported-pairs\n    <IND>r1 = r2 = None\n    try:\n        <IND>r1 = requests.get('https://api.bitfinex.com/v2/tickers?symbols=ALL')\n        r2 = requests.get('https://api-pub.bitfinex.com/v2/conf/pub:map:currency:sym')\n        tickers: List[List[str]] = r1.json()\n        norm: List[Tuple[str, str]] = r2.json()[0]\n        norm: Dict[str, str] = dict(norm)\n        for k, v in dict(norm).items():\n            <IND>if k[-2:] == 'F0' or '-' in v:  # Do not convert BTCF0 -> BTC or PBTCETH -> PBTC-ETH\n                <IND>del norm[k]\n        <DED><DED>norm['BCHN'] = 'BCH'  # Bitfinex uses BCHN, other exchanges use BCH\n\n        ret = {}\n        for symbol in [t[0] for t in tickers]:\n            <IND>if symbol[0] == 'f':\n                <IND>normalized = norm.get(symbol[1:], symbol[1:])\n            <DED>else:\n                <IND>if len(symbol) == 7:\n                    <IND>base, quote = symbol[1:4], symbol[4:]\n                <DED>else:\n                    <IND>base, quote = symbol[1:].split(':')\n                    assert ':' in symbol\n                <DED>normalized = norm.get(base, base) + SYMBOL_SEP + norm.get(quote, quote)\n            <DED>ret[normalized.upper()] = symbol\n        <DED>return ret\n    <DED>except ValueError as why:\n        <IND>raise_failure_explanation('BITFINEX', why, {\"tickers?symbols=ALL\": r1, \"pub:map:currency:sym\": r2})\n\n\n<DED><DED>def bitflyer_symbols() -> Dict[str, str]:\n    <IND>endpoint = r = None\n    try:\n        <IND>ret = {}\n        endpoints = ['https://api.bitflyer.com/v1/getmarkets/eu', 'https://api.bitflyer.com/v1/getmarkets/usa', 'https://api.bitflyer.com/v1/getmarkets']\n        for endpoint in endpoints:\n            <IND>r = requests.get(endpoint)\n            for entry in r.json():\n                <IND>normalized = entry['product_code'].replace(\"_\", SYMBOL_SEP)\n                ret[normalized] = entry['product_code']\n        <DED><DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BITFLYER', why, {endpoint: r})\n\n\n<DED><DED>def bybit_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.bybit.com/v2/public/symbols')\n        ret = {}\n        for symbol in r.json()['result']:\n            <IND>quote = symbol['quote_currency']\n            if not symbol['name'].endswith(quote):\n                <IND>base, contract = symbol['name'].split(quote)\n                normalized = f\"{base}{SYMBOL_SEP}{quote}-{contract}\"\n            <DED>else:\n                <IND>normalized = f\"{symbol['base_currency']}{SYMBOL_SEP}{quote}\"\n            <DED>ret[normalized] = symbol['name']\n            _exchange_info[BYBIT]['tick_size'][normalized] = symbol['price_filter']['tick_size']\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BYBIT', why, {\"\": r})\n\n\n<DED><DED>def _ftx_helper(endpoint: str, exchange: str):\n    <IND>r = None\n    try:\n        <IND>r = requests.get(endpoint)\n        ret = {}\n        for data in r.json()['result']:\n            <IND>normalized = data['name'].replace(\"/\", SYMBOL_SEP)\n            symbol = data['name']\n            ret[normalized] = symbol\n            _exchange_info[exchange]['tick_size'][normalized] = data['priceIncrement']\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation(exchange, why, {endpoint: r})\n\n\n<DED><DED>def ftx_symbols() -> Dict[str, str]:\n    <IND>return _ftx_helper('https://ftx.com/api/markets', FTX)\n\n\n<DED>def ftx_us_symbols() -> Dict[str, str]:\n    <IND>return _ftx_helper('https://ftx.us/api/markets', FTX_US)\n\n\n<DED>def coinbase_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.pro.coinbase.com/products')\n        ret = {}\n        for data in r.json():\n            <IND>normalized = data['id'].replace(\"-\", SYMBOL_SEP)\n            ret[normalized] = data['id']\n            _exchange_info[COINBASE]['tick_size'][normalized] = data['quote_increment']\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('COINBASE', why, {\"\": r})\n\n\n<DED><DED>def gemini_symbols(*args) -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.gemini.com/v1/symbols')\n        ret = {}\n        for symbol in r.json():\n            <IND>std = f\"{symbol[:-3]}{SYMBOL_SEP}{symbol[-3:]}\"\n            std = std.upper()\n            ret[std] = symbol.upper()\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('GEMINI', why, {\"\": r})\n\n\n<DED><DED>def hitbtc_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>ret = {}\n        r = requests.get('https://api.hitbtc.com/api/2/public/symbol')\n        for symbol in r.json():\n            <IND>split = len(symbol['baseCurrency'])\n            normalized = symbol['id'][:split] + SYMBOL_SEP + symbol['id'][split:]\n            ret[normalized] = symbol['id']\n            _exchange_info[HITBTC]['tick_size'][normalized] = symbol['tickSize']\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('HITBTC', why, {\"\": r})\n\n\n<DED><DED>def poloniex_id_symbol_mapping():\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://poloniex.com/public?command=returnTicker')\n        symbols = r.json()\n        ret = {}\n        for symbol in symbols:\n            <IND>ret[symbols[symbol]['id']] = symbol\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('POLONIEX', why, {\"\": r})\n\n\n<DED><DED>def poloniex_symbols() -> Dict[str, str]:\n    <IND>ret = {}\n    for _, value in poloniex_id_symbol_mapping().items():\n        <IND>std = value.replace(\"STR\", \"XLM\")\n        quote, base = std.split(\"_\")\n        ret[quote + SYMBOL_SEP + base] = value\n    <DED>return ret\n\n\n<DED>def bitstamp_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://www.bitstamp.net/api/v2/trading-pairs-info/')\n        ret = {}\n        for data in r.json():\n            <IND>normalized = data['name'].replace(\"/\", SYMBOL_SEP)\n            symbol = data['url_symbol']\n            ret[normalized] = symbol\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BITSTAMP', why, {\"\": r})\n\n\n<DED><DED>def kraken_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.kraken.com/0/public/AssetPairs')\n        data = r.json()\n        ret = {}\n        for symbol in data['result']:\n            <IND>if 'wsname' not in data['result'][symbol] or '.d' in symbol:\n                # https://blog.kraken.com/post/259/introducing-the-kraken-dark-pool/\n                # .d is for dark pool symbols\n                <IND>continue\n\n            <DED>base, quote = data['result'][symbol]['wsname'].split(\"/\")\n\n            normalized = f\"{base}{SYMBOL_SEP}{quote}\"\n            exch = data['result'][symbol]['wsname']\n            normalized = normalized.replace('XBT', 'BTC')\n            normalized = normalized.replace('XDG', 'DOG')\n            ret[normalized] = exch\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('KRAKEN', why, {\"\": r})\n\n\n<DED><DED>def kraken_rest_symbols() -> Dict[str, str]:\n    <IND>return {normalized: exchange.replace(\"/\", \"\") for normalized, exchange in kraken_symbols().items()}\n\n\n<DED>def exx_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.exx.com/data/v1/tickers')\n        exchange = [key.upper() for key in r.json().keys()]\n        symbols = [key.replace(\"_\", SYMBOL_SEP) for key in exchange]\n        return dict(zip(symbols, exchange))\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('EXX', why, {\"\": r})\n\n\n<DED><DED>def huobi_common_symbols(url: str):\n    <IND>r = None\n    try:\n        <IND>r = requests.get(url)\n        ret = {}\n        for e in r.json()['data']:\n            <IND>if e['state'] == 'offline':\n                <IND>continue\n            <DED>normalized = f\"{e['base-currency'].upper()}{SYMBOL_SEP}{e['quote-currency'].upper()}\"\n            symbol = f\"{e['base-currency']}{e['quote-currency']}\"\n            ret[normalized] = symbol\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('HUOBI', why, {url: r})\n\n\n<DED><DED>def huobi_symbols() -> Dict[str, str]:\n    <IND>return huobi_common_symbols('https://api.huobi.pro/v1/common/symbols')\n\n\n<DED>def huobi_us_symbols() -> Dict[str, str]:\n    <IND>return huobi_common_symbols('https://api.huobi.com/v1/common/symbols')\n\n\n<DED>def huobi_dm_symbols() -> Dict[str, str]:\n    <IND>\"\"\"\n    Mapping is, for instance: {\"BTC_CW\":\"BTC190816\"}\n    See comments in exchange/huobi_dm.py\n    \"\"\"\n    mapping = {\n        \"this_week\": \"CW\",\n        \"next_week\": \"NW\",\n        \"quarter\": \"CQ\",\n        \"next_quarter\": \"NQ\"\n    }\n    r = None\n    try:\n        <IND>r = requests.get('https://www.hbdm.com/api/v1/contract_contract_info')\n        symbols = {}\n        for e in r.json()['data']:\n            <IND>symbols[f\"{e['symbol']}_{mapping[e['contract_type']]}\"] = e['contract_code']\n            _exchange_info[HUOBI_DM]['tick_size'][e['contract_code']] = e['price_tick']\n            _exchange_info[HUOBI_DM]['short_code_mappings'][f\"{e['symbol']}_{mapping[e['contract_type']]}\"] = e['contract_code']\n        <DED>return symbols\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('HUOBI_DM', why, {\"\": r})\n\n\n<DED><DED>def huobi_swap_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.hbdm.com/swap-api/v1/swap_contract_info')\n        symbols = {}\n        for e in r.json()['data']:\n            <IND>symbols[e['contract_code']] = e['contract_code']\n            _exchange_info[HUOBI_SWAP]['tick_size'][e['contract_code']] = e['price_tick']\n        <DED>return symbols\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('HUOBI_SWAP', why, {\"\": r})\n\n\n<DED><DED>def okcoin_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://www.okcoin.com/api/spot/v3/instruments')\n        ret = {}\n        for e in r.json():\n            <IND>ret[e['instrument_id']] = e['instrument_id']\n            _exchange_info[OKCOIN]['tick_size'][e['instrument_id']] = e['tick_size']\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('OKCOIN', why, {\"\": r})\n\n\n<DED><DED>def okex_symbols(*args) -> Dict[str, str]:\n    <IND>urls = ['https://www.okex.com/api/spot/v3/instruments',\n            'https://www.okex.com/api/swap/v3/instruments',\n            'https://www.okex.com/api/futures/v3/instruments']\n    urls = urls + okex_compute_option_urls_from_underlyings()\n\n    symbols: Dict[str, str] = {}\n    for u in urls:\n        <IND>time.sleep(0.2)\n        symbols.update(okex_symbols_from_one_url(u))\n\n    <DED>for symbol in symbols:\n        <IND>instrument_type = 'futures'\n        dash_count = symbol.count(get_symbol_separator())\n        if dash_count == 1:  # BTC-USDT\n            <IND>instrument_type = 'spot'\n        <DED>if dash_count == 4:  # BTC-USD-201225-35000-P\n            <IND>instrument_type = 'option'\n        <DED>if symbol[-4:] == \"SWAP\":  # BTC-USDT-SWAP\n            <IND>instrument_type = 'swap'\n\n        <DED>_exchange_info[OKEX]['instrument_type'][symbol] = instrument_type\n\n    <DED>return symbols\n\n\n<DED>def okex_compute_option_urls_from_underlyings() -> List[str]:\n    <IND>url = 'https://www.okex.com/api/option/v3/underlying'\n    r = None\n    try:\n        <IND>r = requests.get(url)\n        return [f'https://www.okex.com/api/option/v3/instruments/{underlying}' for underlying in r.json()]\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('OKEX', why, {url: r})\n\n\n<DED><DED>def okex_symbols_from_one_url(url: str) -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get(url)\n        ret = {}\n        for e in r.json():\n            <IND>ret[e['instrument_id']] = e['instrument_id']\n            _exchange_info[OKEX]['tick_size'][e['instrument_id']] = e['tick_size']\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('OKEX', why, {url: r})\n\n\n<DED><DED>def bittrex_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.bittrex.com/api/v1.1/public/getmarkets')\n        r = r.json()['result']\n        return {f\"{e['MarketCurrency']}{SYMBOL_SEP}{e['BaseCurrency']}\": e['MarketName'] for e in r if e['IsActive']}\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BITTREX', why, {\"\": r})\n\n\n<DED><DED>def bitcoincom_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.exchange.bitcoin.com/api/2/public/symbol')\n        return {f\"{data['baseCurrency']}{SYMBOL_SEP}{data['quoteCurrency'].replace('USD', 'USDT')}\": data['id'] for data in r.json()}\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BITCOINCOM', why, {\"\": r})\n\n\n<DED><DED>def bitmax_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://bitmax.io/api/pro/v1/products')\n        ret = {}\n        for entry in r.json()['data']:\n            # Only \"Normal\" status symbols are tradeable\n            <IND>if entry['status'] == 'Normal':\n                <IND>normalized = f\"{entry['baseAsset']}{SYMBOL_SEP}{entry['quoteAsset']}\"\n                ret[normalized] = entry['symbol']\n                _exchange_info[BITMAX]['tick_size'][normalized] = entry['tickSize']\n        <DED><DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BITMAX', why, {\"\": r})\n\n\n<DED><DED>def upbit_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.upbit.com/v1/market/all')\n        return {f\"{data['market'].split('-')[1]}{SYMBOL_SEP}{data['market'].split('-')[0]}\": data['market'] for data in r.json()}\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('UPBIT', why, {\"\": r})\n\n\n<DED><DED>def blockchain_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get(\"https://api.blockchain.com/mercury-gateway/v1/instruments\")\n        return {data[\"symbol\"].replace(\"-\", SYMBOL_SEP): data[\"symbol\"] for data in r.json()}\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BLOCKCHAIN', why, {\"\": r})\n\n\n<DED><DED>def gateio_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get(\"https://api.gateio.ws/api/v4/spot/currency_pairs\")\n        return {data[\"id\"].replace(\"_\", SYMBOL_SEP): data['id'] for data in r.json()}\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('GATEIO', why, {\"\": r})\n\n\n<DED><DED>def bitmex_symbols() -> Dict[str, str]:\n    <IND>r = None\n    ret = {}\n    try:\n        <IND>r = requests.get(\"https://www.bitmex.com/api/v1/instrument/active\")\n        for entry in r.json():\n            <IND>components = []\n            components.append(entry['rootSymbol'])\n            components.append(entry['quoteCurrency'])\n\n            if entry['expiry']:\n                <IND>components.append(entry['symbol'][-3:])\n\n            <DED>normalized = SYMBOL_SEP.join(components)\n            normalized = normalized.replace(\"XBT\", \"BTC\")\n            ret[normalized] = entry['symbol']\n            _exchange_info[BITMEX]['tick_size'][normalized] = entry['tickSize']\n\n            if entry['expiry']:\n                <IND>_exchange_info[BITMEX]['expiry'][normalized] = entry['expiry']\n\n        <DED><DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BITMEX', why, {\"\": r})\n\n\n<DED><DED>def deribit_symbols() -> Dict[str, str]:\n    <IND>url = r = None\n    ret = {}\n    try:\n        # TODO: get currencies from https://www.deribit.com/api/v2/public/get_currencies\n        <IND>currencies = ['BTC', 'ETH']\n        for c in currencies:\n            <IND>url = f\"https://www.deribit.com/api/v2/public/get_instruments?currency={c}&expired=false\"\n            r = requests.get(url)\n            for entry in r.json()['result']:\n                <IND>split = entry['instrument_name'].split(\"-\")\n                normalized = split[0] + SYMBOL_SEP + entry['quote_currency'] + \"-\" + '-'.join(split[1:])\n                ret[normalized] = entry['instrument_name']\n                _exchange_info[DERIBIT]['tick_size'][normalized] = entry['tick_size']\n        <DED><DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('DERIBIT', why, {url: r})\n\n\n<DED><DED>def kraken_future_symbols() -> Dict[str, str]:\n    <IND>r = None\n    ret = {}\n    try:\n        <IND>r = requests.get('https://futures.kraken.com/derivatives/api/v3/instruments')\n        data = r.json()['instruments']\n        for entry in data:\n            <IND>if not entry['tradeable']:\n                <IND>continue\n            <DED>normalized = entry['symbol'].upper().replace(\"_\", \"-\")\n            symbol = normalized[3:6] + SYMBOL_SEP + normalized[6:9]\n            normalized = normalized.replace(normalized[3:9], symbol)\n            normalized = normalized.replace('XBT', 'BTC')\n\n            _exchange_info[KRAKEN_FUTURES]['tick_size'][normalized] = entry['tickSize']\n            _exchange_info[KRAKEN_FUTURES]['contract_size'][normalized] = entry['contractSize']\n            _exchange_info[KRAKEN_FUTURES]['underlying'][normalized] = entry['underlying']\n            _exchange_info[KRAKEN_FUTURES]['product_type'][normalized] = _kraken_futures_product_type[normalized[:2]]\n            ret[normalized] = entry['symbol']\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('KRAKEN_FUTURES', why, {\"\": r})\n\n\n<DED><DED>def probit_symbols() -> Dict[str, str]:\n    # doc: https://docs-en.probit.com/reference-link/market\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.probit.com/api/exchange/v1/market')\n        return {entry['id']: entry['id'] for entry in r.json()['data']}\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('PROBIT', why, {\"\": r})\n\n\n<DED><DED>def coingecko_normalize_symbol(symbol: str) -> str:\n    # keep digits, letters and dots, replace others by space\n    <IND>symbol = ''.join(c if c.isalnum() or c in ('.', '+') else ' ' for c in symbol)\n    return coingecko_normalize(symbol.upper())\n\n\n<DED>def coingecko_normalize_name(name: str) -> str:\n    # keep digits and letters, replace others by space (except when only composed by upper case letters, digits and dots)\n    <IND>if not all(c.isupper() or c.isdigit() or c == '.' for c in name):\n        <IND>name = ''.join(c if c.isalnum() else ' ' for c in name)\n    <DED>return coingecko_normalize(name)\n\n\n<DED>def coingecko_normalize(sym: str) -> str:\n    <IND>sym = sym.strip()\n    # do not concatenate numbers => separate them with a dot\n    sym = list(sym)\n    if len(sym) > 4:\n        <IND>for i in range(2, len(sym) - 1):\n            <IND>if sym[i] == ' ' and sym[i - 1].isdigit() and sym[i + 1].isdigit():\n                <IND>sym[i] = '.'\n    <DED><DED><DED>sym = ''.join(sym)\n    # concatenate space-separated words => use CamelCase to distinguish the words\n    if ' ' in sym:\n        <IND>if sum(c.islower() for c in sym):  # if there is at least one lower case letter\n            <IND>sym = ' '.join(word[0].upper() + word[1:] for word in sym.split())  # Just capitalize initial letter of each word\n        <DED>else:  # CoinGecko may provide full upper-case as for \"THE STONE COIN\"\n            <IND>sym = string.capwords(sym)  # capwords converts \"THE STONE COIN\" to \"The Stone Coin\"\n        <DED>sym = sym.replace(' ', '')  # concatenate words\n    <DED>return sym\n\n\n<DED>def is_name_short(coin: dict) -> bool:\n    <IND>\"\"\"return True if the coin name is enough short compared to the coin symbol.\"\"\"\n    return len(coin['name']) <= max(5, len(coin['symbol']) + 1)\n\n\n<DED>def has_many_caps(name: str) -> bool:\n    <IND>\"\"\"return True if the symbol contains enough upper case letters, False if empty.\"\"\"\n    return str and sum(c.islower() for c in name) < (len(name) / 2)\n\n\n<DED>def coingecko_normalize_all(coin: dict):\n    <IND>SYMBOL_TO_NORMALIZED = {'miota': 'IOTA'}\n    normalized = SYMBOL_TO_NORMALIZED.get(coin['symbol'])\n    if normalized:\n        <IND>coin['ns'] = coin['nn'] = normalized\n        return normalized\n\n    # ns = normalized symbol, nn = normalized name\n    <DED>coin['ns'] = coingecko_normalize_symbol(coin['symbol'])\n\n    ID_SUFFIX = '-bitcoin-token'\n    if coin['id'][-len(ID_SUFFIX):] == ID_SUFFIX:\n        <IND>coin['nn'] = 'BTC' + coin['ns']\n        return coin['nn']\n\n    <DED>name = coin['name']\n\n    prefixes = ('The ', 'the ')\n    for p in prefixes:\n        <IND>if name[:len(p)] == p:\n            <IND>coin['reduced-name'] = True\n            name = name[len(p):]\n            break\n\n    <DED><DED>suffixes = ('coin', 'coins', 'money', 'finance', 'protocol', 'reward', 'rewards', 'token')\n    for s in suffixes:\n        <IND>if len(name) > len(s) and name[-len(s):].lower() == s:\n            # but keep suffix when lower-case concatenated\n            <IND>if name[-len(s)].islower() and name[-len(s) - 1] != ' ':\n                <IND>continue\n            # also keep suffix to avoid confusing nam: \"Bitcoin Token\" -> \"Bitcoin\"\n            <DED>if name[:-len(s)].strip().lower() == 'bitcoin':\n                <IND>continue\n            <DED>coin['reduced-name'] = True\n            name = name[:-len(s)]\n            break\n\n    <DED><DED>coin['nn'] = coingecko_normalize_name(name)\n\n    if len(coin['nn']) < len(coin['ns']):\n        <IND>if 'reduced-name' in coin:\n            <IND>coin['reduced-name'] = False\n            name = coin['name']\n            coin['nn'] = coingecko_normalize_name(name)\n        <DED>elif not has_many_caps(name):\n            <IND>return coin['ns']\n\n    <DED><DED>if not coin['ns']:  # coin['symbol'] may be an emoji that is striped when normalized\n        <IND>return coin['nn']\n\n    <DED>if coin.get('reduced-name') and coin['ns'].upper() != coin['nn'].upper():\n        <IND>return coin['ns']\n\n    <DED>i = coin['nn'].find('.')  # if there is a dot in normalized name => prefer the normalized symbol\n    if i >= 0:\n        <IND>if i > 1 and coin['nn'][i - 1].isdigit() and coin['nn'][i + 1].isdigit():\n            <IND>pass  # except when the dot separates digits\n        <DED>else:\n            <IND>return coin['ns']\n\n    <DED><DED>if is_name_short(coin) and has_many_caps(name):\n        <IND>return coin['nn']\n\n    <DED>if 1.5 * len(coin['ns']) > len(coin['nn']) and any(c.islower() for c in coin['ns']):\n        <IND>return coin['nn']\n\n    <DED>return coin['ns']\n\n\n<DED>def coingecko_symbols() -> Dict[str, str]:\n    <IND>r = None\n    intermediate = defaultdict(list)\n    try:\n        <IND>r = requests.get('https://api.coingecko.com/api/v3/coins/list')\n        all_coins = r.json()\n        # First pass: generate & compare normalized symbol/name, and then select the most pertinent\n        for coin in all_coins:\n            <IND>normalized = coingecko_normalize_all(coin)\n            intermediate[normalized].append(coin)\n            # Above line keeps together the coins having the same normalized symbol.\n            # To reduce collision, the coin['name'] is sometimes used in lieu of the coin['symbol'].\n            # The coin['name'] is not capitalized because lower case letters may be meaningful: cETH, yUSD, DATx, zLOT\n    <DED><DED>except Exception as why:\n        <IND>raise_failure_explanation('COINGECKO', why, {\"\": r})\n\n    <DED>final = coingecko_second_pass(intermediate)\n    return coingecko_third_pass(final)\n\n\n<DED>def coingecko_second_pass(intermediate: Dict[str, List[dict]]) -> Dict[str, List[dict]]:\n    # Second pass: fixes most of the symbol collisions\n    <IND>final = defaultdict(list)\n    for normalized, coins in intermediate.items():\n        <IND>if len(coins) == 1:\n            <IND>final[normalized].append(coins[0])\n            continue\n        <DED>set_normalized = False\n        for i in range(len(coins)):\n            <IND>if normalized == coins[i]['nn']:\n                <IND>coin = coins.pop(i)\n                final[normalized].append(coin)\n                set_normalized = True\n                break\n        <DED><DED>rest: List[dict] = []\n        for coin in coins:\n            <IND>if '%' in coin['name']:\n                <IND>if len(coins) == 1:\n                    <IND>n = coin['ns']\n                <DED>else:\n                    <IND>n = coingecko_normalize_name(coin['id'])\n                <DED>final[n].append(coin)\n            <DED>else:\n                <IND>rest.append(coin)\n        <DED><DED>if not rest:\n            <IND>continue\n        <DED>if not set_normalized:\n            <IND>rest.sort(key=lambda coin: len(coin['nn']), reverse=True)  # sort by the length of the normalized name\n            coin = rest.pop(0)\n            final[normalized].append(coin)\n        <DED>for coin in rest:\n            <IND>if coin['nn'] not in intermediate:\n                <IND>n = coin['nn']\n            <DED>elif coin.get('reduced-name'):\n                <IND>n = coingecko_normalize_name(coin['name'])\n            <DED>else:\n                <IND>n = coingecko_normalize_name(coin['id'])\n            <DED>final[n].append(coin)\n    <DED><DED>return final\n\n\n<DED>def coingecko_third_pass(final: Dict[str, List[dict]]) -> Dict[str, str]:\n    # Third pass: fixes some remaining collisions and fills the result\n    <IND>symbols = {}\n    for normalized, coins in final.items():\n        <IND>if len(coins) == 1:\n            <IND>symbols[normalized] = coins[0]['id']\n            continue\n        <DED>set_normalized = False\n        for i in range(len(coins)):\n            <IND>if normalized == coins[i]['nn']:\n                <IND>coin = coins.pop(i)\n                symbols[normalized] = coin['id']\n                set_normalized = True\n                break\n        <DED><DED>rest: List[dict] = []\n        for coin in coins:\n            <IND>if '%' in coin['name']:\n                <IND>if len(coins) == 1:\n                    <IND>n = coin['ns']\n                <DED>else:\n                    <IND>n = coingecko_normalize_name(coin['id'])\n                <DED>symbols[n] = coin['id']\n            <DED>else:\n                <IND>rest.append(coin)\n        <DED><DED>if not rest:\n            <IND>continue\n        <DED>if not set_normalized:\n            <IND>rest.sort(key=lambda coin: len(coin['nn']), reverse=True)  # sort by the length of the normalized name\n            coin = rest.pop(0)\n            symbols[normalized] = coin['id']\n        <DED>for coin in rest:\n            <IND>if coin['nn'] not in final:\n                <IND>n = coin['nn']\n            <DED>elif coin.get('reduced-name'):\n                <IND>n = coingecko_normalize_name(coin['name'])\n            <DED>else:\n                <IND>n = coingecko_normalize_name(coin['id'])\n            <DED>symbols[n] = coin['id']\n    <DED><DED>return symbols\n\n\n<DED>def whale_alert_coins(key_id: str) -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get(f'https://api.whale-alert.io/v1/status?api_key={key_id}')\n        # Same symbols, but on different blockchains (for instance USDT), are naturally overwritten.\n        return {s.upper(): s for b in r.json()['blockchains'] for s in b['symbols'] if s}\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('WHALES_ALERT', why, {\"\": r})\n\n\n<DED><DED>_exchange_function_map = {\n    BITFINEX: bitfinex_symbols,\n    BITFLYER: bitflyer_symbols,\n    COINBASE: coinbase_symbols,\n    GEMINI: gemini_symbols,\n    HITBTC: hitbtc_symbols,\n    POLONIEX: poloniex_symbols,\n    PROBIT: probit_symbols,\n    BITSTAMP: bitstamp_symbols,\n    KRAKEN: kraken_symbols,\n    KRAKEN + 'REST': kraken_rest_symbols,\n    BINANCE: binance_symbols,\n    BINANCE_US: binance_us_symbols,\n    BINANCE_FUTURES: binance_futures_symbols,\n    BINANCE_DELIVERY: binance_delivery_symbols,\n    BLOCKCHAIN: blockchain_symbols,\n    EXX: exx_symbols,\n    HUOBI: huobi_symbols,\n    HUOBI_DM: huobi_dm_symbols,\n    HUOBI_SWAP: huobi_swap_symbols,\n    OKCOIN: okcoin_symbols,\n    OKEX: okex_symbols,\n    BYBIT: bybit_symbols,\n    FTX: ftx_symbols,\n    FTX_US: ftx_us_symbols,\n    BITTREX: bittrex_symbols,\n    BITCOINCOM: bitcoincom_symbols,\n    BITMAX: bitmax_symbols,\n    UPBIT: upbit_symbols,\n    GATEIO: gateio_symbols,\n    BITMEX: bitmex_symbols,\n    DERIBIT: deribit_symbols,\n    KRAKEN_FUTURES: kraken_future_symbols,\n    COINGECKO: coingecko_symbols,\n    WHALE_ALERT: whale_alert_coins\n}\n",
        "target_code_with_indent": "\nfrom typing import Dict, Tuple\n\n\nclass _Symbols:\n    <IND>def __init__(self):\n        <IND>self.data = {}\n\n    <DED>def set(self, exchange: str, normalized: dict, exchange_info: dict):\n        <IND>self.data[exchange] = {}\n        self.data[exchange]['normalized'] = normalized\n        self.data[exchange]['info'] = exchange_info\n\n    <DED>def get(self, exchange: str) -> Tuple[Dict, Dict]:\n        <IND>return self.data[exchange]['normalized'], self.data[exchange]['info']\n\n    <DED>def populated(self, exchange: str) -> bool:\n        <IND>return exchange in self.data\n\n\n<DED><DED>Symbols = _Symbols()\n"
      }
    ]
  },
  {
    "project": "bmoscon/cryptofeed",
    "commit": "3525dc8ce4d7836a9abaaa5662e58e5e27969a77",
    "filename": "cryptofeed/symbols.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/bmoscon-cryptofeed/cryptofeed/symbols.py",
    "file_hunks_size": 1,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "cryptofeed/symbols.py:607:4 Incompatible variable type [9]: sym is declared to have type `str` but is used as type `List[str]`.",
    "message": " sym is declared to have type `str` but is used as type `List[str]`.",
    "rule_id": "Incompatible variable type [9]",
    "warning_line_no": 607,
    "warning_line": "    sym = list(sym)",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "associated with this software.\n\n\nSymbol generation code for exchanges\n'''\n\nimport logging\nimport string\nimport time\nfrom collections import defaultdict\nfrom typing import Dict, List, Optional, Tuple\n\nimport requests\nfrom requests import Response\n\nfrom cryptofeed.defines import *\n\n\nLOG = logging.getLogger('feedhandler')\n\nSYMBOL_SEP = '-'\n\n_symbols_retrieval_cache: Dict[str, Dict[str, str]] = {}\n_exchange_info = defaultdict(lambda: defaultdict(dict))\n\n\n_kraken_futures_product_type = {\n    'FI': 'Inverse Futures',\n    'FV': 'Vanilla Futures',\n    'PI': 'Perpetual Inverse Futures',\n    'PV': 'Perpetual Vanilla Futures',\n    'IN': 'Real Time Index',\n    'RR': 'Reference Rate',\n}\n\n\ndef raise_failure_explanation(feed_id: str, exception: BaseException, responses: Dict[str, Optional[Response]]):\n    LOG.critical('%s: encountered %r while processing response from exchange API', feed_id, exception)\n    if len(responses) > 1:\n        LOG.critical('%s: content of one of the %s responses was unexpected', feed_id, len(responses))\n    for url, r in responses.items():\n        if url:\n            LOG.critical('%s: requested URL: %s', feed_id, url)\n        if r:\n            LOG.critical('%s: unexpected response: %s', feed_id, r.text)\n    raise ValueError(f'Cryptofeed stopped because of an unexpected response from {feed_id}') from exception\n\n\ndef set_symbol_separator(separator: str):\n    global SYMBOL_SEP\n    SYMBOL_SEP = separator\n\n\ndef get_symbol_separator() -> str:\n    global SYMBOL_SEP\n    return SYMBOL_SEP\n\n\ndef gen_symbols(exchange: str, key_id=None) -> Dict[str, str]:\n    if exchange not in _symbols_retrieval_cache:\n        LOG.info(\"%s: Getting list of symbols\", exchange)\n        symbols = _exchange_function_map[exchange](key_id) if key_id else _exchange_function_map[exchange]()\n        LOG.info(\"%s: %s symbols\", exchange, len(symbols))\n\n        # log all retrieved symbols using debug level\n        for normalized, exch_sym in sorted(symbols.items()):\n            LOG.debug('%s: id-from-exch -> normalized: %-35s-> %s', exchange, exch_sym, normalized)\n\n        _symbols_retrieval_cache[exchange] = symbols\n    return _symbols_retrieval_cache[exchange]\n\n\ndef _binance_symbols(endpoint: str, exchange: str):\n    r = None\n    try:\n        ret = {}\n        r = requests.get(endpoint)\n        for symbol in r.json()['symbols']:\n            if symbol.get('status', 'TRADING') != \"TRADING\":\n                continue\n            if symbol.get('contractStatus', 'TRADING') != \"TRADING\":\n                continue\n            split = len(symbol['baseAsset'])\n            normalized = symbol['symbol'][:split] + SYMBOL_SEP + symbol['symbol'][split:]\n            ret[normalized] = symbol['symbol']\n            _exchange_info[exchange]['tick_size'][normalized] = symbol['filters'][0]['tickSize']\n            if \"contractType\" in symbol:\n                _exchange_info[exchange]['contract_type'][normalized] = symbol['contractType']\n        return ret\n    except Exception as why:\n        raise_failure_explanation(exchange, why, {endpoint: r})\n\n\ndef binance_symbols() -> Dict[str, str]:\n    return _binance_symbols('https://api.binance.com/api/v3/exchangeInfo', BINANCE)\n\n\ndef binance_us_symbols() -> Dict[str, str]:\n    return _binance_symbols('https://api.binance.us/api/v3/exchangeInfo', BINANCE_US)\n\n\ndef binance_futures_symbols() -> Dict[str, str]:\n    base = _binance_symbols('https://fapi.binance.com/fapi/v1/exchangeInfo', BINANCE_FUTURES)\n    add = {}\n    for symbol, orig in base.items():\n        if \"_\" in orig:\n            continue\n        add[f\"{symbol}-PINDEX\"] = f\"p{orig}\"\n    base.update(add)\n    return base\n\n\ndef binance_delivery_symbols() -> Dict[str, str]:\n    return _binance_symbols('https://dapi.binance.com/dapi/v1/exchangeInfo', BINANCE_DELIVERY)\n\n\ndef bitfinex_symbols() -> Dict[str, str]:\n    # doc: https://docs.bitfinex.com/docs/ws-general#supported-pairs\n    r1 = r2 = None\n    try:\n        r1 = requests.get('https://api.bitfinex.com/v2/tickers?symbols=ALL')\n        r2 = requests.get('https://api-pub.bitfinex.com/v2/conf/pub:map:currency:sym')\n        tickers: List[List[str]] = r1.json()\n        norm: List[Tuple[str, str]] = r2.json()[0]\n        norm: Dict[str, str] = dict(norm)\n        for k, v in dict(norm).items():\n            if k[-2:] == 'F0' or '-' in v:  # Do not convert BTCF0 -> BTC or PBTCETH -> PBTC-ETH\n                del norm[k]\n        norm['BCHN'] = 'BCH'  # Bitfinex uses BCHN, other exchanges use BCH\n\n        ret = {}\n        for symbol in [t[0] for t in tickers]:\n            if symbol[0] == 'f':\n                normalized = norm.get(symbol[1:], symbol[1:])\n            else:\n                if len(symbol) == 7:\n                    base, quote = symbol[1:4], symbol[4:]\n                else:\n                    base, quote = symbol[1:].split(':')\n                    assert ':' in symbol\n                normalized = norm.get(base, base) + SYMBOL_SEP + norm.get(quote, quote)\n            ret[normalized.upper()] = symbol\n        return ret\n    except ValueError as why:\n        raise_failure_explanation('BITFINEX', why, {\"tickers?symbols=ALL\": r1, \"pub:map:currency:sym\": r2})\n\n\ndef bitflyer_symbols() -> Dict[str, str]:\n    endpoint = r = None\n    try:\n        ret = {}\n        endpoints = ['https://api.bitflyer.com/v1/getmarkets/eu', 'https://api.bitflyer.com/v1/getmarkets/usa', 'https://api.bitflyer.com/v1/getmarkets']\n        for endpoint in endpoints:\n            r = requests.get(endpoint)\n            for entry in r.json():\n                normalized = entry['product_code'].replace(\"_\", SYMBOL_SEP)\n                ret[normalized] = entry['product_code']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('BITFLYER', why, {endpoint: r})\n\n\ndef bybit_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.bybit.com/v2/public/symbols')\n        ret = {}\n        for symbol in r.json()['result']:\n            quote = symbol['quote_currency']\n            if not symbol['name'].endswith(quote):\n                base, contract = symbol['name'].split(quote)\n                normalized = f\"{base}{SYMBOL_SEP}{quote}-{contract}\"\n            else:\n                normalized = f\"{symbol['base_currency']}{SYMBOL_SEP}{quote}\"\n            ret[normalized] = symbol['name']\n            _exchange_info[BYBIT]['tick_size'][normalized] = symbol['price_filter']['tick_size']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('BYBIT', why, {\"\": r})\n\n\ndef _ftx_helper(endpoint: str, exchange: str):\n    r = None\n    try:\n        r = requests.get(endpoint)\n        ret = {}\n        for data in r.json()['result']:\n            normalized = data['name'].replace(\"/\", SYMBOL_SEP)\n            symbol = data['name']\n            ret[normalized] = symbol\n            _exchange_info[exchange]['tick_size'][normalized] = data['priceIncrement']\n        return ret\n    except Exception as why:\n        raise_failure_explanation(exchange, why, {endpoint: r})\n\n\ndef ftx_symbols() -> Dict[str, str]:\n    return _ftx_helper('https://ftx.com/api/markets', FTX)\n\n\ndef ftx_us_symbols() -> Dict[str, str]:\n    return _ftx_helper('https://ftx.us/api/markets', FTX_US)\n\n\ndef coinbase_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.pro.coinbase.com/products')\n        ret = {}\n        for data in r.json():\n            normalized = data['id'].replace(\"-\", SYMBOL_SEP)\n            ret[normalized] = data['id']\n            _exchange_info[COINBASE]['tick_size'][normalized] = data['quote_increment']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('COINBASE', why, {\"\": r})\n\n\ndef gemini_symbols(*args) -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.gemini.com/v1/symbols')\n        ret = {}\n        for symbol in r.json():\n            std = f\"{symbol[:-3]}{SYMBOL_SEP}{symbol[-3:]}\"\n            std = std.upper()\n            ret[std] = symbol.upper()\n        return ret\n    except Exception as why:\n        raise_failure_explanation('GEMINI', why, {\"\": r})\n\n\ndef hitbtc_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        ret = {}\n        r = requests.get('https://api.hitbtc.com/api/2/public/symbol')\n        for symbol in r.json():\n            split = len(symbol['baseCurrency'])\n            normalized = symbol['id'][:split] + SYMBOL_SEP + symbol['id'][split:]\n            ret[normalized] = symbol['id']\n            _exchange_info[HITBTC]['tick_size'][normalized] = symbol['tickSize']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('HITBTC', why, {\"\": r})\n\n\ndef poloniex_id_symbol_mapping():\n    r = None\n    try:\n        r = requests.get('https://poloniex.com/public?command=returnTicker')\n        symbols = r.json()\n        ret = {}\n        for symbol in symbols:\n            ret[symbols[symbol]['id']] = symbol\n        return ret\n    except Exception as why:\n        raise_failure_explanation('POLONIEX', why, {\"\": r})\n\n\ndef poloniex_symbols() -> Dict[str, str]:\n    ret = {}\n    for _, value in poloniex_id_symbol_mapping().items():\n        std = value.replace(\"STR\", \"XLM\")\n        quote, base = std.split(\"_\")\n        ret[quote + SYMBOL_SEP + base] = value\n    return ret\n\n\ndef bitstamp_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://www.bitstamp.net/api/v2/trading-pairs-info/')\n        ret = {}\n        for data in r.json():\n            normalized = data['name'].replace(\"/\", SYMBOL_SEP)\n            symbol = data['url_symbol']\n            ret[normalized] = symbol\n        return ret\n    except Exception as why:\n        raise_failure_explanation('BITSTAMP', why, {\"\": r})\n\n\ndef kraken_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.kraken.com/0/public/AssetPairs')\n        data = r.json()\n        ret = {}\n        for symbol in data['result']:\n            if 'wsname' not in data['result'][symbol] or '.d' in symbol:\n                # https://blog.kraken.com/post/259/introducing-the-kraken-dark-pool/\n                # .d is for dark pool symbols\n                continue\n\n            base, quote = data['result'][symbol]['wsname'].split(\"/\")\n\n            normalized = f\"{base}{SYMBOL_SEP}{quote}\"\n            exch = data['result'][symbol]['wsname']\n            normalized = normalized.replace('XBT', 'BTC')\n            normalized = normalized.replace('XDG', 'DOG')\n            ret[normalized] = exch\n        return ret\n    except Exception as why:\n        raise_failure_explanation('KRAKEN', why, {\"\": r})\n\n\ndef kraken_rest_symbols() -> Dict[str, str]:\n    return {normalized: exchange.replace(\"/\", \"\") for normalized, exchange in kraken_symbols().items()}\n\n\ndef exx_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.exx.com/data/v1/tickers')\n        exchange = [key.upper() for key in r.json().keys()]\n        symbols = [key.replace(\"_\", SYMBOL_SEP) for key in exchange]\n        return dict(zip(symbols, exchange))\n    except Exception as why:\n        raise_failure_explanation('EXX', why, {\"\": r})\n\n\ndef huobi_common_symbols(url: str):\n    r = None\n    try:\n        r = requests.get(url)\n        ret = {}\n        for e in r.json()['data']:\n            if e['state'] == 'offline':\n                continue\n            normalized = f\"{e['base-currency'].upper()}{SYMBOL_SEP}{e['quote-currency'].upper()}\"\n            symbol = f\"{e['base-currency']}{e['quote-currency']}\"\n            ret[normalized] = symbol\n        return ret\n    except Exception as why:\n        raise_failure_explanation('HUOBI', why, {url: r})\n\n\ndef huobi_symbols() -> Dict[str, str]:\n    return huobi_common_symbols('https://api.huobi.pro/v1/common/symbols')\n\n\ndef huobi_us_symbols() -> Dict[str, str]:\n    return huobi_common_symbols('https://api.huobi.com/v1/common/symbols')\n\n\ndef huobi_dm_symbols() -> Dict[str, str]:\n    \"\"\"\n    Mapping is, for instance: {\"BTC_CW\":\"BTC190816\"}\n    See comments in exchange/huobi_dm.py\n    \"\"\"\n    mapping = {\n        \"this_week\": \"CW\",\n        \"next_week\": \"NW\",\n        \"quarter\": \"CQ\",\n        \"next_quarter\": \"NQ\"\n    }\n    r = None\n    try:\n        r = requests.get('https://www.hbdm.com/api/v1/contract_contract_info')\n        symbols = {}\n        for e in r.json()['data']:\n            symbols[f\"{e['symbol']}_{mapping[e['contract_type']]}\"] = e['contract_code']\n            _exchange_info[HUOBI_DM]['tick_size'][e['contract_code']] = e['price_tick']\n            _exchange_info[HUOBI_DM]['short_code_mappings'][f\"{e['symbol']}_{mapping[e['contract_type']]}\"] = e['contract_code']\n        return symbols\n    except Exception as why:\n        raise_failure_explanation('HUOBI_DM', why, {\"\": r})\n\n\ndef huobi_swap_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.hbdm.com/swap-api/v1/swap_contract_info')\n        symbols = {}\n        for e in r.json()['data']:\n            symbols[e['contract_code']] = e['contract_code']\n            _exchange_info[HUOBI_SWAP]['tick_size'][e['contract_code']] = e['price_tick']\n        return symbols\n    except Exception as why:\n        raise_failure_explanation('HUOBI_SWAP', why, {\"\": r})\n\n\ndef okcoin_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://www.okcoin.com/api/spot/v3/instruments')\n        ret = {}\n        for e in r.json():\n            ret[e['instrument_id']] = e['instrument_id']\n            _exchange_info[OKCOIN]['tick_size'][e['instrument_id']] = e['tick_size']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('OKCOIN', why, {\"\": r})\n\n\ndef okex_symbols(*args) -> Dict[str, str]:\n    urls = ['https://www.okex.com/api/spot/v3/instruments',\n            'https://www.okex.com/api/swap/v3/instruments',\n            'https://www.okex.com/api/futures/v3/instruments']\n    urls = urls + okex_compute_option_urls_from_underlyings()\n\n    symbols: Dict[str, str] = {}\n    for u in urls:\n        time.sleep(0.2)\n        symbols.update(okex_symbols_from_one_url(u))\n\n    for symbol in symbols:\n        instrument_type = 'futures'\n        dash_count = symbol.count(get_symbol_separator())\n        if dash_count == 1:  # BTC-USDT\n            instrument_type = 'spot'\n        if dash_count == 4:  # BTC-USD-201225-35000-P\n            instrument_type = 'option'\n        if symbol[-4:] == \"SWAP\":  # BTC-USDT-SWAP\n            instrument_type = 'swap'\n\n        _exchange_info[OKEX]['instrument_type'][symbol] = instrument_type\n\n    return symbols\n\n\ndef okex_compute_option_urls_from_underlyings() -> List[str]:\n    url = 'https://www.okex.com/api/option/v3/underlying'\n    r = None\n    try:\n        r = requests.get(url)\n        return [f'https://www.okex.com/api/option/v3/instruments/{underlying}' for underlying in r.json()]\n    except Exception as why:\n        raise_failure_explanation('OKEX', why, {url: r})\n\n\ndef okex_symbols_from_one_url(url: str) -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get(url)\n        ret = {}\n        for e in r.json():\n            ret[e['instrument_id']] = e['instrument_id']\n            _exchange_info[OKEX]['tick_size'][e['instrument_id']] = e['tick_size']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('OKEX', why, {url: r})\n\n\ndef bittrex_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.bittrex.com/api/v1.1/public/getmarkets')\n        r = r.json()['result']\n        return {f\"{e['MarketCurrency']}{SYMBOL_SEP}{e['BaseCurrency']}\": e['MarketName'] for e in r if e['IsActive']}\n    except Exception as why:\n        raise_failure_explanation('BITTREX', why, {\"\": r})\n\n\ndef bitcoincom_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.exchange.bitcoin.com/api/2/public/symbol')\n        return {f\"{data['baseCurrency']}{SYMBOL_SEP}{data['quoteCurrency'].replace('USD', 'USDT')}\": data['id'] for data in r.json()}\n    except Exception as why:\n        raise_failure_explanation('BITCOINCOM', why, {\"\": r})\n\n\ndef bitmax_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://bitmax.io/api/pro/v1/products')\n        ret = {}\n        for entry in r.json()['data']:\n            # Only \"Normal\" status symbols are tradeable\n            if entry['status'] == 'Normal':\n                normalized = f\"{entry['baseAsset']}{SYMBOL_SEP}{entry['quoteAsset']}\"\n                ret[normalized] = entry['symbol']\n                _exchange_info[BITMAX]['tick_size'][normalized] = entry['tickSize']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('BITMAX', why, {\"\": r})\n\n\ndef upbit_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.upbit.com/v1/market/all')\n        return {f\"{data['market'].split('-')[1]}{SYMBOL_SEP}{data['market'].split('-')[0]}\": data['market'] for data in r.json()}\n    except Exception as why:\n        raise_failure_explanation('UPBIT', why, {\"\": r})\n\n\ndef blockchain_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get(\"https://api.blockchain.com/mercury-gateway/v1/instruments\")\n        return {data[\"symbol\"].replace(\"-\", SYMBOL_SEP): data[\"symbol\"] for data in r.json()}\n    except Exception as why:\n        raise_failure_explanation('BLOCKCHAIN', why, {\"\": r})\n\n\ndef gateio_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get(\"https://api.gateio.ws/api/v4/spot/currency_pairs\")\n        return {data[\"id\"].replace(\"_\", SYMBOL_SEP): data['id'] for data in r.json()}\n    except Exception as why:\n        raise_failure_explanation('GATEIO', why, {\"\": r})\n\n\ndef bitmex_symbols() -> Dict[str, str]:\n    r = None\n    ret = {}\n    try:\n        r = requests.get(\"https://www.bitmex.com/api/v1/instrument/active\")\n        for entry in r.json():\n            components = []\n            components.append(entry['rootSymbol'])\n            components.append(entry['quoteCurrency'])\n\n            if entry['expiry']:\n                components.append(entry['symbol'][-3:])\n\n            normalized = SYMBOL_SEP.join(components)\n            normalized = normalized.replace(\"XBT\", \"BTC\")\n            ret[normalized] = entry['symbol']\n            _exchange_info[BITMEX]['tick_size'][normalized] = entry['tickSize']\n\n            if entry['expiry']:\n                _exchange_info[BITMEX]['expiry'][normalized] = entry['expiry']\n\n        return ret\n    except Exception as why:\n        raise_failure_explanation('BITMEX', why, {\"\": r})\n\n\ndef deribit_symbols() -> Dict[str, str]:\n    url = r = None\n    ret = {}\n    try:\n        # TODO: get currencies from https://www.deribit.com/api/v2/public/get_currencies\n        currencies = ['BTC', 'ETH']\n        for c in currencies:\n            url = f\"https://www.deribit.com/api/v2/public/get_instruments?currency={c}&expired=false\"\n            r = requests.get(url)\n            for entry in r.json()['result']:\n                split = entry['instrument_name'].split(\"-\")\n                normalized = split[0] + SYMBOL_SEP + entry['quote_currency'] + \"-\" + '-'.join(split[1:])\n                ret[normalized] = entry['instrument_name']\n                _exchange_info[DERIBIT]['tick_size'][normalized] = entry['tick_size']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('DERIBIT', why, {url: r})\n\n\ndef kraken_future_symbols() -> Dict[str, str]:\n    r = None\n    ret = {}\n    try:\n        r = requests.get('https://futures.kraken.com/derivatives/api/v3/instruments')\n        data = r.json()['instruments']\n        for entry in data:\n            if not entry['tradeable']:\n                continue\n            normalized = entry['symbol'].upper().replace(\"_\", \"-\")\n            symbol = normalized[3:6] + SYMBOL_SEP + normalized[6:9]\n            normalized = normalized.replace(normalized[3:9], symbol)\n            normalized = normalized.replace('XBT', 'BTC')\n\n            _exchange_info[KRAKEN_FUTURES]['tick_size'][normalized] = entry['tickSize']\n            _exchange_info[KRAKEN_FUTURES]['contract_size'][normalized] = entry['contractSize']\n            _exchange_info[KRAKEN_FUTURES]['underlying'][normalized] = entry['underlying']\n            _exchange_info[KRAKEN_FUTURES]['product_type'][normalized] = _kraken_futures_product_type[normalized[:2]]\n            ret[normalized] = entry['symbol']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('KRAKEN_FUTURES', why, {\"\": r})\n\n\ndef probit_symbols() -> Dict[str, str]:\n    # doc: https://docs-en.probit.com/reference-link/market\n    r = None\n    try:\n        r = requests.get('https://api.probit.com/api/exchange/v1/market')\n        return {entry['id']: entry['id'] for entry in r.json()['data']}\n    except Exception as why:\n        raise_failure_explanation('PROBIT', why, {\"\": r})\n\n\ndef coingecko_normalize_symbol(symbol: str) -> str:\n    # keep digits, letters and dots, replace others by space\n    symbol = ''.join(c if c.isalnum() or c in ('.', '+') else ' ' for c in symbol)\n    return coingecko_normalize(symbol.upper())\n\n\ndef coingecko_normalize_name(name: str) -> str:\n    # keep digits and letters, replace others by space (except when only composed by upper case letters, digits and dots)\n    if not all(c.isupper() or c.isdigit() or c == '.' for c in name):\n        name = ''.join(c if c.isalnum() else ' ' for c in name)\n    return coingecko_normalize(name)\n\n\ndef coingecko_normalize(sym: str) -> str:\n    sym = sym.strip()\n    # do not concatenate numbers => separate them with a dot\n    sym = list(sym)\n    if len(sym) > 4:\n        for i in range(2, len(sym) - 1):\n            if sym[i] == ' ' and sym[i - 1].isdigit() and sym[i + 1].isdigit():\n                sym[i] = '.'\n    sym = ''.join(sym)\n    # concatenate space-separated words => use CamelCase to distinguish the words\n    if ' ' in sym:\n        if sum(c.islower() for c in sym):  # if there is at least one lower case letter\n            sym = ' '.join(word[0].upper() + word[1:] for word in sym.split())  # Just capitalize initial letter of each word\n        else:  # CoinGecko may provide full upper-case as for \"THE STONE COIN\"\n            sym = string.capwords(sym)  # capwords converts \"THE STONE COIN\" to \"The Stone Coin\"\n        sym = sym.replace(' ', '')  # concatenate words\n    return sym\n\n\ndef is_name_short(coin: dict) -> bool:\n    \"\"\"return True if the coin name is enough short compared to the coin symbol.\"\"\"\n    return len(coin['name']) <= max(5, len(coin['symbol']) + 1)\n\n\ndef has_many_caps(name: str) -> bool:\n    \"\"\"return True if the symbol contains enough upper case letters, False if empty.\"\"\"\n    return str and sum(c.islower() for c in name) < (len(name) / 2)\n\n\ndef coingecko_normalize_all(coin: dict):\n    SYMBOL_TO_NORMALIZED = {'miota': 'IOTA'}\n    normalized = SYMBOL_TO_NORMALIZED.get(coin['symbol'])\n    if normalized:\n        coin['ns'] = coin['nn'] = normalized\n        return normalized\n\n    # ns = normalized symbol, nn = normalized name\n    coin['ns'] = coingecko_normalize_symbol(coin['symbol'])\n\n    ID_SUFFIX = '-bitcoin-token'\n    if coin['id'][-len(ID_SUFFIX):] == ID_SUFFIX:\n        coin['nn'] = 'BTC' + coin['ns']\n        return coin['nn']\n\n    name = coin['name']\n\n    prefixes = ('The ', 'the ')\n    for p in prefixes:\n        if name[:len(p)] == p:\n            coin['reduced-name'] = True\n            name = name[len(p):]\n            break\n\n    suffixes = ('coin', 'coins', 'money', 'finance', 'protocol', 'reward', 'rewards', 'token')\n    for s in suffixes:\n        if len(name) > len(s) and name[-len(s):].lower() == s:\n            # but keep suffix when lower-case concatenated\n            if name[-len(s)].islower() and name[-len(s) - 1] != ' ':\n                continue\n            # also keep suffix to avoid confusing nam: \"Bitcoin Token\" -> \"Bitcoin\"\n            if name[:-len(s)].strip().lower() == 'bitcoin':\n                continue\n            coin['reduced-name'] = True\n            name = name[:-len(s)]\n            break\n\n    coin['nn'] = coingecko_normalize_name(name)\n\n    if len(coin['nn']) < len(coin['ns']):\n        if 'reduced-name' in coin:\n            coin['reduced-name'] = False\n            name = coin['name']\n            coin['nn'] = coingecko_normalize_name(name)\n        elif not has_many_caps(name):\n            return coin['ns']\n\n    if not coin['ns']:  # coin['symbol'] may be an emoji that is striped when normalized\n        return coin['nn']\n\n    if coin.get('reduced-name') and coin['ns'].upper() != coin['nn'].upper():\n        return coin['ns']\n\n    i = coin['nn'].find('.')  # if there is a dot in normalized name => prefer the normalized symbol\n    if i >= 0:\n        if i > 1 and coin['nn'][i - 1].isdigit() and coin['nn'][i + 1].isdigit():\n            pass  # except when the dot separates digits\n        else:\n            return coin['ns']\n\n    if is_name_short(coin) and has_many_caps(name):\n        return coin['nn']\n\n    if 1.5 * len(coin['ns']) > len(coin['nn']) and any(c.islower() for c in coin['ns']):\n        return coin['nn']\n\n    return coin['ns']\n\n\ndef coingecko_symbols() -> Dict[str, str]:\n    r = None\n    intermediate = defaultdict(list)\n    try:\n        r = requests.get('https://api.coingecko.com/api/v3/coins/list')\n        all_coins = r.json()\n        # First pass: generate & compare normalized symbol/name, and then select the most pertinent\n        for coin in all_coins:\n            normalized = coingecko_normalize_all(coin)\n            intermediate[normalized].append(coin)\n            # Above line keeps together the coins having the same normalized symbol.\n            # To reduce collision, the coin['name'] is sometimes used in lieu of the coin['symbol'].\n            # The coin['name'] is not capitalized because lower case letters may be meaningful: cETH, yUSD, DATx, zLOT\n    except Exception as why:\n        raise_failure_explanation('COINGECKO', why, {\"\": r})\n\n    final = coingecko_second_pass(intermediate)\n    return coingecko_third_pass(final)\n\n\ndef coingecko_second_pass(intermediate: Dict[str, List[dict]]) -> Dict[str, List[dict]]:\n    # Second pass: fixes most of the symbol collisions\n    final = defaultdict(list)\n    for normalized, coins in intermediate.items():\n        if len(coins) == 1:\n            final[normalized].append(coins[0])\n            continue\n        set_normalized = False\n        for i in range(len(coins)):\n            if normalized == coins[i]['nn']:\n                coin = coins.pop(i)\n                final[normalized].append(coin)\n                set_normalized = True\n                break\n        rest: List[dict] = []\n        for coin in coins:\n            if '%' in coin['name']:\n                if len(coins) == 1:\n                    n = coin['ns']\n                else:\n                    n = coingecko_normalize_name(coin['id'])\n                final[n].append(coin)\n            else:\n                rest.append(coin)\n        if not rest:\n            continue\n        if not set_normalized:\n            rest.sort(key=lambda coin: len(coin['nn']), reverse=True)  # sort by the length of the normalized name\n            coin = rest.pop(0)\n            final[normalized].append(coin)\n        for coin in rest:\n            if coin['nn'] not in intermediate:\n                n = coin['nn']\n            elif coin.get('reduced-name'):\n                n = coingecko_normalize_name(coin['name'])\n            else:\n                n = coingecko_normalize_name(coin['id'])\n            final[n].append(coin)\n    return final\n\n\ndef coingecko_third_pass(final: Dict[str, List[dict]]) -> Dict[str, str]:\n    # Third pass: fixes some remaining collisions and fills the result\n    symbols = {}\n    for normalized, coins in final.items():\n        if len(coins) == 1:\n            symbols[normalized] = coins[0]['id']\n            continue\n        set_normalized = False\n        for i in range(len(coins)):\n            if normalized == coins[i]['nn']:\n                coin = coins.pop(i)\n                symbols[normalized] = coin['id']\n                set_normalized = True\n                break\n        rest: List[dict] = []\n        for coin in coins:\n            if '%' in coin['name']:\n                if len(coins) == 1:\n                    n = coin['ns']\n                else:\n                    n = coingecko_normalize_name(coin['id'])\n                symbols[n] = coin['id']\n            else:\n                rest.append(coin)\n        if not rest:\n            continue\n        if not set_normalized:\n            rest.sort(key=lambda coin: len(coin['nn']), reverse=True)  # sort by the length of the normalized name\n            coin = rest.pop(0)\n            symbols[normalized] = coin['id']\n        for coin in rest:\n            if coin['nn'] not in final:\n                n = coin['nn']\n            elif coin.get('reduced-name'):\n                n = coingecko_normalize_name(coin['name'])\n            else:\n                n = coingecko_normalize_name(coin['id'])\n            symbols[n] = coin['id']\n    return symbols\n\n\ndef whale_alert_coins(key_id: str) -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get(f'https://api.whale-alert.io/v1/status?api_key={key_id}')\n        # Same symbols, but on different blockchains (for instance USDT), are naturally overwritten.\n        return {s.upper(): s for b in r.json()['blockchains'] for s in b['symbols'] if s}\n    except Exception as why:\n        raise_failure_explanation('WHALES_ALERT', why, {\"\": r})\n\n\n_exchange_function_map = {\n    BITFINEX: bitfinex_symbols,\n    BITFLYER: bitflyer_symbols,\n    COINBASE: coinbase_symbols,\n    GEMINI: gemini_symbols,\n    HITBTC: hitbtc_symbols,\n    POLONIEX: poloniex_symbols,\n    PROBIT: probit_symbols,\n    BITSTAMP: bitstamp_symbols,\n    KRAKEN: kraken_symbols,\n    KRAKEN + 'REST': kraken_rest_symbols,\n    BINANCE: binance_symbols,\n    BINANCE_US: binance_us_symbols,\n    BINANCE_FUTURES: binance_futures_symbols,\n    BINANCE_DELIVERY: binance_delivery_symbols,\n    BLOCKCHAIN: blockchain_symbols,\n    EXX: exx_symbols,\n    HUOBI: huobi_symbols,\n    HUOBI_DM: huobi_dm_symbols,\n    HUOBI_SWAP: huobi_swap_symbols,\n    OKCOIN: okcoin_symbols,\n    OKEX: okex_symbols,\n    BYBIT: bybit_symbols,\n    FTX: ftx_symbols,\n    FTX_US: ftx_us_symbols,\n    BITTREX: bittrex_symbols,\n    BITCOINCOM: bitcoincom_symbols,\n    BITMAX: bitmax_symbols,\n    UPBIT: upbit_symbols,\n    GATEIO: gateio_symbols,\n    BITMEX: bitmex_symbols,\n    DERIBIT: deribit_symbols,\n    KRAKEN_FUTURES: kraken_future_symbols,\n    COINGECKO: coingecko_symbols,\n    WHALE_ALERT: whale_alert_coins\n}\n",
        "source_code_len": 30534,
        "target_code": "associated with this software.\n'''\nfrom typing import Dict, Tuple\n\n\nclass _Symbols:\n    def __init__(self):\n        self.data = {}\n\n    def set(self, exchange: str, normalized: dict, exchange_info: dict):\n        self.data[exchange] = {}\n        self.data[exchange]['normalized'] = normalized\n        self.data[exchange]['info'] = exchange_info\n\n    def get(self, exchange: str) -> Tuple[Dict, Dict]:\n        return self.data[exchange]['normalized'], self.data[exchange]['info']\n\n    def populated(self, exchange: str) -> bool:\n        return exchange in self.data\n\n\nSymbols = _Symbols()\n",
        "target_code_len": 588,
        "diff_format": "@@ -5,845 +5,22 @@\n associated with this software.\n+'''\n+from typing import Dict, Tuple\n \n \n-Symbol generation code for exchanges\n-'''\n+class _Symbols:\n+    def __init__(self):\n+        self.data = {}\n \n-import logging\n-import string\n-import time\n-from collections import defaultdict\n-from typing import Dict, List, Optional, Tuple\n+    def set(self, exchange: str, normalized: dict, exchange_info: dict):\n+        self.data[exchange] = {}\n+        self.data[exchange]['normalized'] = normalized\n+        self.data[exchange]['info'] = exchange_info\n \n-import requests\n-from requests import Response\n+    def get(self, exchange: str) -> Tuple[Dict, Dict]:\n+        return self.data[exchange]['normalized'], self.data[exchange]['info']\n \n-from cryptofeed.defines import *\n+    def populated(self, exchange: str) -> bool:\n+        return exchange in self.data\n \n \n-LOG = logging.getLogger('feedhandler')\n-\n-SYMBOL_SEP = '-'\n-\n-_symbols_retrieval_cache: Dict[str, Dict[str, str]] = {}\n-_exchange_info = defaultdict(lambda: defaultdict(dict))\n-\n-\n-_kraken_futures_product_type = {\n-    'FI': 'Inverse Futures',\n-    'FV': 'Vanilla Futures',\n-    'PI': 'Perpetual Inverse Futures',\n-    'PV': 'Perpetual Vanilla Futures',\n-    'IN': 'Real Time Index',\n-    'RR': 'Reference Rate',\n-}\n-\n-\n-def raise_failure_explanation(feed_id: str, exception: BaseException, responses: Dict[str, Optional[Response]]):\n-    LOG.critical('%s: encountered %r while processing response from exchange API', feed_id, exception)\n-    if len(responses) > 1:\n-        LOG.critical('%s: content of one of the %s responses was unexpected', feed_id, len(responses))\n-    for url, r in responses.items():\n-        if url:\n-            LOG.critical('%s: requested URL: %s', feed_id, url)\n-        if r:\n-            LOG.critical('%s: unexpected response: %s', feed_id, r.text)\n-    raise ValueError(f'Cryptofeed stopped because of an unexpected response from {feed_id}') from exception\n-\n-\n-def set_symbol_separator(separator: str):\n-    global SYMBOL_SEP\n-    SYMBOL_SEP = separator\n-\n-\n-def get_symbol_separator() -> str:\n-    global SYMBOL_SEP\n-    return SYMBOL_SEP\n-\n-\n-def gen_symbols(exchange: str, key_id=None) -> Dict[str, str]:\n-    if exchange not in _symbols_retrieval_cache:\n-        LOG.info(\"%s: Getting list of symbols\", exchange)\n-        symbols = _exchange_function_map[exchange](key_id) if key_id else _exchange_function_map[exchange]()\n-        LOG.info(\"%s: %s symbols\", exchange, len(symbols))\n-\n-        # log all retrieved symbols using debug level\n-        for normalized, exch_sym in sorted(symbols.items()):\n-            LOG.debug('%s: id-from-exch -> normalized: %-35s-> %s', exchange, exch_sym, normalized)\n-\n-        _symbols_retrieval_cache[exchange] = symbols\n-    return _symbols_retrieval_cache[exchange]\n-\n-\n-def _binance_symbols(endpoint: str, exchange: str):\n-    r = None\n-    try:\n-        ret = {}\n-        r = requests.get(endpoint)\n-        for symbol in r.json()['symbols']:\n-            if symbol.get('status', 'TRADING') != \"TRADING\":\n-                continue\n-            if symbol.get('contractStatus', 'TRADING') != \"TRADING\":\n-                continue\n-            split = len(symbol['baseAsset'])\n-            normalized = symbol['symbol'][:split] + SYMBOL_SEP + symbol['symbol'][split:]\n-            ret[normalized] = symbol['symbol']\n-            _exchange_info[exchange]['tick_size'][normalized] = symbol['filters'][0]['tickSize']\n-            if \"contractType\" in symbol:\n-                _exchange_info[exchange]['contract_type'][normalized] = symbol['contractType']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation(exchange, why, {endpoint: r})\n-\n-\n-def binance_symbols() -> Dict[str, str]:\n-    return _binance_symbols('https://api.binance.com/api/v3/exchangeInfo', BINANCE)\n-\n-\n-def binance_us_symbols() -> Dict[str, str]:\n-    return _binance_symbols('https://api.binance.us/api/v3/exchangeInfo', BINANCE_US)\n-\n-\n-def binance_futures_symbols() -> Dict[str, str]:\n-    base = _binance_symbols('https://fapi.binance.com/fapi/v1/exchangeInfo', BINANCE_FUTURES)\n-    add = {}\n-    for symbol, orig in base.items():\n-        if \"_\" in orig:\n-            continue\n-        add[f\"{symbol}-PINDEX\"] = f\"p{orig}\"\n-    base.update(add)\n-    return base\n-\n-\n-def binance_delivery_symbols() -> Dict[str, str]:\n-    return _binance_symbols('https://dapi.binance.com/dapi/v1/exchangeInfo', BINANCE_DELIVERY)\n-\n-\n-def bitfinex_symbols() -> Dict[str, str]:\n-    # doc: https://docs.bitfinex.com/docs/ws-general#supported-pairs\n-    r1 = r2 = None\n-    try:\n-        r1 = requests.get('https://api.bitfinex.com/v2/tickers?symbols=ALL')\n-        r2 = requests.get('https://api-pub.bitfinex.com/v2/conf/pub:map:currency:sym')\n-        tickers: List[List[str]] = r1.json()\n-        norm: List[Tuple[str, str]] = r2.json()[0]\n-        norm: Dict[str, str] = dict(norm)\n-        for k, v in dict(norm).items():\n-            if k[-2:] == 'F0' or '-' in v:  # Do not convert BTCF0 -> BTC or PBTCETH -> PBTC-ETH\n-                del norm[k]\n-        norm['BCHN'] = 'BCH'  # Bitfinex uses BCHN, other exchanges use BCH\n-\n-        ret = {}\n-        for symbol in [t[0] for t in tickers]:\n-            if symbol[0] == 'f':\n-                normalized = norm.get(symbol[1:], symbol[1:])\n-            else:\n-                if len(symbol) == 7:\n-                    base, quote = symbol[1:4], symbol[4:]\n-                else:\n-                    base, quote = symbol[1:].split(':')\n-                    assert ':' in symbol\n-                normalized = norm.get(base, base) + SYMBOL_SEP + norm.get(quote, quote)\n-            ret[normalized.upper()] = symbol\n-        return ret\n-    except ValueError as why:\n-        raise_failure_explanation('BITFINEX', why, {\"tickers?symbols=ALL\": r1, \"pub:map:currency:sym\": r2})\n-\n-\n-def bitflyer_symbols() -> Dict[str, str]:\n-    endpoint = r = None\n-    try:\n-        ret = {}\n-        endpoints = ['https://api.bitflyer.com/v1/getmarkets/eu', 'https://api.bitflyer.com/v1/getmarkets/usa', 'https://api.bitflyer.com/v1/getmarkets']\n-        for endpoint in endpoints:\n-            r = requests.get(endpoint)\n-            for entry in r.json():\n-                normalized = entry['product_code'].replace(\"_\", SYMBOL_SEP)\n-                ret[normalized] = entry['product_code']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('BITFLYER', why, {endpoint: r})\n-\n-\n-def bybit_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.bybit.com/v2/public/symbols')\n-        ret = {}\n-        for symbol in r.json()['result']:\n-            quote = symbol['quote_currency']\n-            if not symbol['name'].endswith(quote):\n-                base, contract = symbol['name'].split(quote)\n-                normalized = f\"{base}{SYMBOL_SEP}{quote}-{contract}\"\n-            else:\n-                normalized = f\"{symbol['base_currency']}{SYMBOL_SEP}{quote}\"\n-            ret[normalized] = symbol['name']\n-            _exchange_info[BYBIT]['tick_size'][normalized] = symbol['price_filter']['tick_size']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('BYBIT', why, {\"\": r})\n-\n-\n-def _ftx_helper(endpoint: str, exchange: str):\n-    r = None\n-    try:\n-        r = requests.get(endpoint)\n-        ret = {}\n-        for data in r.json()['result']:\n-            normalized = data['name'].replace(\"/\", SYMBOL_SEP)\n-            symbol = data['name']\n-            ret[normalized] = symbol\n-            _exchange_info[exchange]['tick_size'][normalized] = data['priceIncrement']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation(exchange, why, {endpoint: r})\n-\n-\n-def ftx_symbols() -> Dict[str, str]:\n-    return _ftx_helper('https://ftx.com/api/markets', FTX)\n-\n-\n-def ftx_us_symbols() -> Dict[str, str]:\n-    return _ftx_helper('https://ftx.us/api/markets', FTX_US)\n-\n-\n-def coinbase_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.pro.coinbase.com/products')\n-        ret = {}\n-        for data in r.json():\n-            normalized = data['id'].replace(\"-\", SYMBOL_SEP)\n-            ret[normalized] = data['id']\n-            _exchange_info[COINBASE]['tick_size'][normalized] = data['quote_increment']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('COINBASE', why, {\"\": r})\n-\n-\n-def gemini_symbols(*args) -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.gemini.com/v1/symbols')\n-        ret = {}\n-        for symbol in r.json():\n-            std = f\"{symbol[:-3]}{SYMBOL_SEP}{symbol[-3:]}\"\n-            std = std.upper()\n-            ret[std] = symbol.upper()\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('GEMINI', why, {\"\": r})\n-\n-\n-def hitbtc_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        ret = {}\n-        r = requests.get('https://api.hitbtc.com/api/2/public/symbol')\n-        for symbol in r.json():\n-            split = len(symbol['baseCurrency'])\n-            normalized = symbol['id'][:split] + SYMBOL_SEP + symbol['id'][split:]\n-            ret[normalized] = symbol['id']\n-            _exchange_info[HITBTC]['tick_size'][normalized] = symbol['tickSize']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('HITBTC', why, {\"\": r})\n-\n-\n-def poloniex_id_symbol_mapping():\n-    r = None\n-    try:\n-        r = requests.get('https://poloniex.com/public?command=returnTicker')\n-        symbols = r.json()\n-        ret = {}\n-        for symbol in symbols:\n-            ret[symbols[symbol]['id']] = symbol\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('POLONIEX', why, {\"\": r})\n-\n-\n-def poloniex_symbols() -> Dict[str, str]:\n-    ret = {}\n-    for _, value in poloniex_id_symbol_mapping().items():\n-        std = value.replace(\"STR\", \"XLM\")\n-        quote, base = std.split(\"_\")\n-        ret[quote + SYMBOL_SEP + base] = value\n-    return ret\n-\n-\n-def bitstamp_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://www.bitstamp.net/api/v2/trading-pairs-info/')\n-        ret = {}\n-        for data in r.json():\n-            normalized = data['name'].replace(\"/\", SYMBOL_SEP)\n-            symbol = data['url_symbol']\n-            ret[normalized] = symbol\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('BITSTAMP', why, {\"\": r})\n-\n-\n-def kraken_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.kraken.com/0/public/AssetPairs')\n-        data = r.json()\n-        ret = {}\n-        for symbol in data['result']:\n-            if 'wsname' not in data['result'][symbol] or '.d' in symbol:\n-                # https://blog.kraken.com/post/259/introducing-the-kraken-dark-pool/\n-                # .d is for dark pool symbols\n-                continue\n-\n-            base, quote = data['result'][symbol]['wsname'].split(\"/\")\n-\n-            normalized = f\"{base}{SYMBOL_SEP}{quote}\"\n-            exch = data['result'][symbol]['wsname']\n-            normalized = normalized.replace('XBT', 'BTC')\n-            normalized = normalized.replace('XDG', 'DOG')\n-            ret[normalized] = exch\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('KRAKEN', why, {\"\": r})\n-\n-\n-def kraken_rest_symbols() -> Dict[str, str]:\n-    return {normalized: exchange.replace(\"/\", \"\") for normalized, exchange in kraken_symbols().items()}\n-\n-\n-def exx_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.exx.com/data/v1/tickers')\n-        exchange = [key.upper() for key in r.json().keys()]\n-        symbols = [key.replace(\"_\", SYMBOL_SEP) for key in exchange]\n-        return dict(zip(symbols, exchange))\n-    except Exception as why:\n-        raise_failure_explanation('EXX', why, {\"\": r})\n-\n-\n-def huobi_common_symbols(url: str):\n-    r = None\n-    try:\n-        r = requests.get(url)\n-        ret = {}\n-        for e in r.json()['data']:\n-            if e['state'] == 'offline':\n-                continue\n-            normalized = f\"{e['base-currency'].upper()}{SYMBOL_SEP}{e['quote-currency'].upper()}\"\n-            symbol = f\"{e['base-currency']}{e['quote-currency']}\"\n-            ret[normalized] = symbol\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('HUOBI', why, {url: r})\n-\n-\n-def huobi_symbols() -> Dict[str, str]:\n-    return huobi_common_symbols('https://api.huobi.pro/v1/common/symbols')\n-\n-\n-def huobi_us_symbols() -> Dict[str, str]:\n-    return huobi_common_symbols('https://api.huobi.com/v1/common/symbols')\n-\n-\n-def huobi_dm_symbols() -> Dict[str, str]:\n-    \"\"\"\n-    Mapping is, for instance: {\"BTC_CW\":\"BTC190816\"}\n-    See comments in exchange/huobi_dm.py\n-    \"\"\"\n-    mapping = {\n-        \"this_week\": \"CW\",\n-        \"next_week\": \"NW\",\n-        \"quarter\": \"CQ\",\n-        \"next_quarter\": \"NQ\"\n-    }\n-    r = None\n-    try:\n-        r = requests.get('https://www.hbdm.com/api/v1/contract_contract_info')\n-        symbols = {}\n-        for e in r.json()['data']:\n-            symbols[f\"{e['symbol']}_{mapping[e['contract_type']]}\"] = e['contract_code']\n-            _exchange_info[HUOBI_DM]['tick_size'][e['contract_code']] = e['price_tick']\n-            _exchange_info[HUOBI_DM]['short_code_mappings'][f\"{e['symbol']}_{mapping[e['contract_type']]}\"] = e['contract_code']\n-        return symbols\n-    except Exception as why:\n-        raise_failure_explanation('HUOBI_DM', why, {\"\": r})\n-\n-\n-def huobi_swap_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.hbdm.com/swap-api/v1/swap_contract_info')\n-        symbols = {}\n-        for e in r.json()['data']:\n-            symbols[e['contract_code']] = e['contract_code']\n-            _exchange_info[HUOBI_SWAP]['tick_size'][e['contract_code']] = e['price_tick']\n-        return symbols\n-    except Exception as why:\n-        raise_failure_explanation('HUOBI_SWAP', why, {\"\": r})\n-\n-\n-def okcoin_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://www.okcoin.com/api/spot/v3/instruments')\n-        ret = {}\n-        for e in r.json():\n-            ret[e['instrument_id']] = e['instrument_id']\n-            _exchange_info[OKCOIN]['tick_size'][e['instrument_id']] = e['tick_size']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('OKCOIN', why, {\"\": r})\n-\n-\n-def okex_symbols(*args) -> Dict[str, str]:\n-    urls = ['https://www.okex.com/api/spot/v3/instruments',\n-            'https://www.okex.com/api/swap/v3/instruments',\n-            'https://www.okex.com/api/futures/v3/instruments']\n-    urls = urls + okex_compute_option_urls_from_underlyings()\n-\n-    symbols: Dict[str, str] = {}\n-    for u in urls:\n-        time.sleep(0.2)\n-        symbols.update(okex_symbols_from_one_url(u))\n-\n-    for symbol in symbols:\n-        instrument_type = 'futures'\n-        dash_count = symbol.count(get_symbol_separator())\n-        if dash_count == 1:  # BTC-USDT\n-            instrument_type = 'spot'\n-        if dash_count == 4:  # BTC-USD-201225-35000-P\n-            instrument_type = 'option'\n-        if symbol[-4:] == \"SWAP\":  # BTC-USDT-SWAP\n-            instrument_type = 'swap'\n-\n-        _exchange_info[OKEX]['instrument_type'][symbol] = instrument_type\n-\n-    return symbols\n-\n-\n-def okex_compute_option_urls_from_underlyings() -> List[str]:\n-    url = 'https://www.okex.com/api/option/v3/underlying'\n-    r = None\n-    try:\n-        r = requests.get(url)\n-        return [f'https://www.okex.com/api/option/v3/instruments/{underlying}' for underlying in r.json()]\n-    except Exception as why:\n-        raise_failure_explanation('OKEX', why, {url: r})\n-\n-\n-def okex_symbols_from_one_url(url: str) -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get(url)\n-        ret = {}\n-        for e in r.json():\n-            ret[e['instrument_id']] = e['instrument_id']\n-            _exchange_info[OKEX]['tick_size'][e['instrument_id']] = e['tick_size']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('OKEX', why, {url: r})\n-\n-\n-def bittrex_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.bittrex.com/api/v1.1/public/getmarkets')\n-        r = r.json()['result']\n-        return {f\"{e['MarketCurrency']}{SYMBOL_SEP}{e['BaseCurrency']}\": e['MarketName'] for e in r if e['IsActive']}\n-    except Exception as why:\n-        raise_failure_explanation('BITTREX', why, {\"\": r})\n-\n-\n-def bitcoincom_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.exchange.bitcoin.com/api/2/public/symbol')\n-        return {f\"{data['baseCurrency']}{SYMBOL_SEP}{data['quoteCurrency'].replace('USD', 'USDT')}\": data['id'] for data in r.json()}\n-    except Exception as why:\n-        raise_failure_explanation('BITCOINCOM', why, {\"\": r})\n-\n-\n-def bitmax_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://bitmax.io/api/pro/v1/products')\n-        ret = {}\n-        for entry in r.json()['data']:\n-            # Only \"Normal\" status symbols are tradeable\n-            if entry['status'] == 'Normal':\n-                normalized = f\"{entry['baseAsset']}{SYMBOL_SEP}{entry['quoteAsset']}\"\n-                ret[normalized] = entry['symbol']\n-                _exchange_info[BITMAX]['tick_size'][normalized] = entry['tickSize']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('BITMAX', why, {\"\": r})\n-\n-\n-def upbit_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.upbit.com/v1/market/all')\n-        return {f\"{data['market'].split('-')[1]}{SYMBOL_SEP}{data['market'].split('-')[0]}\": data['market'] for data in r.json()}\n-    except Exception as why:\n-        raise_failure_explanation('UPBIT', why, {\"\": r})\n-\n-\n-def blockchain_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get(\"https://api.blockchain.com/mercury-gateway/v1/instruments\")\n-        return {data[\"symbol\"].replace(\"-\", SYMBOL_SEP): data[\"symbol\"] for data in r.json()}\n-    except Exception as why:\n-        raise_failure_explanation('BLOCKCHAIN', why, {\"\": r})\n-\n-\n-def gateio_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get(\"https://api.gateio.ws/api/v4/spot/currency_pairs\")\n-        return {data[\"id\"].replace(\"_\", SYMBOL_SEP): data['id'] for data in r.json()}\n-    except Exception as why:\n-        raise_failure_explanation('GATEIO', why, {\"\": r})\n-\n-\n-def bitmex_symbols() -> Dict[str, str]:\n-    r = None\n-    ret = {}\n-    try:\n-        r = requests.get(\"https://www.bitmex.com/api/v1/instrument/active\")\n-        for entry in r.json():\n-            components = []\n-            components.append(entry['rootSymbol'])\n-            components.append(entry['quoteCurrency'])\n-\n-            if entry['expiry']:\n-                components.append(entry['symbol'][-3:])\n-\n-            normalized = SYMBOL_SEP.join(components)\n-            normalized = normalized.replace(\"XBT\", \"BTC\")\n-            ret[normalized] = entry['symbol']\n-            _exchange_info[BITMEX]['tick_size'][normalized] = entry['tickSize']\n-\n-            if entry['expiry']:\n-                _exchange_info[BITMEX]['expiry'][normalized] = entry['expiry']\n-\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('BITMEX', why, {\"\": r})\n-\n-\n-def deribit_symbols() -> Dict[str, str]:\n-    url = r = None\n-    ret = {}\n-    try:\n-        # TODO: get currencies from https://www.deribit.com/api/v2/public/get_currencies\n-        currencies = ['BTC', 'ETH']\n-        for c in currencies:\n-            url = f\"https://www.deribit.com/api/v2/public/get_instruments?currency={c}&expired=false\"\n-            r = requests.get(url)\n-            for entry in r.json()['result']:\n-                split = entry['instrument_name'].split(\"-\")\n-                normalized = split[0] + SYMBOL_SEP + entry['quote_currency'] + \"-\" + '-'.join(split[1:])\n-                ret[normalized] = entry['instrument_name']\n-                _exchange_info[DERIBIT]['tick_size'][normalized] = entry['tick_size']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('DERIBIT', why, {url: r})\n-\n-\n-def kraken_future_symbols() -> Dict[str, str]:\n-    r = None\n-    ret = {}\n-    try:\n-        r = requests.get('https://futures.kraken.com/derivatives/api/v3/instruments')\n-        data = r.json()['instruments']\n-        for entry in data:\n-            if not entry['tradeable']:\n-                continue\n-            normalized = entry['symbol'].upper().replace(\"_\", \"-\")\n-            symbol = normalized[3:6] + SYMBOL_SEP + normalized[6:9]\n-            normalized = normalized.replace(normalized[3:9], symbol)\n-            normalized = normalized.replace('XBT', 'BTC')\n-\n-            _exchange_info[KRAKEN_FUTURES]['tick_size'][normalized] = entry['tickSize']\n-            _exchange_info[KRAKEN_FUTURES]['contract_size'][normalized] = entry['contractSize']\n-            _exchange_info[KRAKEN_FUTURES]['underlying'][normalized] = entry['underlying']\n-            _exchange_info[KRAKEN_FUTURES]['product_type'][normalized] = _kraken_futures_product_type[normalized[:2]]\n-            ret[normalized] = entry['symbol']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('KRAKEN_FUTURES', why, {\"\": r})\n-\n-\n-def probit_symbols() -> Dict[str, str]:\n-    # doc: https://docs-en.probit.com/reference-link/market\n-    r = None\n-    try:\n-        r = requests.get('https://api.probit.com/api/exchange/v1/market')\n-        return {entry['id']: entry['id'] for entry in r.json()['data']}\n-    except Exception as why:\n-        raise_failure_explanation('PROBIT', why, {\"\": r})\n-\n-\n-def coingecko_normalize_symbol(symbol: str) -> str:\n-    # keep digits, letters and dots, replace others by space\n-    symbol = ''.join(c if c.isalnum() or c in ('.', '+') else ' ' for c in symbol)\n-    return coingecko_normalize(symbol.upper())\n-\n-\n-def coingecko_normalize_name(name: str) -> str:\n-    # keep digits and letters, replace others by space (except when only composed by upper case letters, digits and dots)\n-    if not all(c.isupper() or c.isdigit() or c == '.' for c in name):\n-        name = ''.join(c if c.isalnum() else ' ' for c in name)\n-    return coingecko_normalize(name)\n-\n-\n-def coingecko_normalize(sym: str) -> str:\n-    sym = sym.strip()\n-    # do not concatenate numbers => separate them with a dot\n-    sym = list(sym)\n-    if len(sym) > 4:\n-        for i in range(2, len(sym) - 1):\n-            if sym[i] == ' ' and sym[i - 1].isdigit() and sym[i + 1].isdigit():\n-                sym[i] = '.'\n-    sym = ''.join(sym)\n-    # concatenate space-separated words => use CamelCase to distinguish the words\n-    if ' ' in sym:\n-        if sum(c.islower() for c in sym):  # if there is at least one lower case letter\n-            sym = ' '.join(word[0].upper() + word[1:] for word in sym.split())  # Just capitalize initial letter of each word\n-        else:  # CoinGecko may provide full upper-case as for \"THE STONE COIN\"\n-            sym = string.capwords(sym)  # capwords converts \"THE STONE COIN\" to \"The Stone Coin\"\n-        sym = sym.replace(' ', '')  # concatenate words\n-    return sym\n-\n-\n-def is_name_short(coin: dict) -> bool:\n-    \"\"\"return True if the coin name is enough short compared to the coin symbol.\"\"\"\n-    return len(coin['name']) <= max(5, len(coin['symbol']) + 1)\n-\n-\n-def has_many_caps(name: str) -> bool:\n-    \"\"\"return True if the symbol contains enough upper case letters, False if empty.\"\"\"\n-    return str and sum(c.islower() for c in name) < (len(name) / 2)\n-\n-\n-def coingecko_normalize_all(coin: dict):\n-    SYMBOL_TO_NORMALIZED = {'miota': 'IOTA'}\n-    normalized = SYMBOL_TO_NORMALIZED.get(coin['symbol'])\n-    if normalized:\n-        coin['ns'] = coin['nn'] = normalized\n-        return normalized\n-\n-    # ns = normalized symbol, nn = normalized name\n-    coin['ns'] = coingecko_normalize_symbol(coin['symbol'])\n-\n-    ID_SUFFIX = '-bitcoin-token'\n-    if coin['id'][-len(ID_SUFFIX):] == ID_SUFFIX:\n-        coin['nn'] = 'BTC' + coin['ns']\n-        return coin['nn']\n-\n-    name = coin['name']\n-\n-    prefixes = ('The ', 'the ')\n-    for p in prefixes:\n-        if name[:len(p)] == p:\n-            coin['reduced-name'] = True\n-            name = name[len(p):]\n-            break\n-\n-    suffixes = ('coin', 'coins', 'money', 'finance', 'protocol', 'reward', 'rewards', 'token')\n-    for s in suffixes:\n-        if len(name) > len(s) and name[-len(s):].lower() == s:\n-            # but keep suffix when lower-case concatenated\n-            if name[-len(s)].islower() and name[-len(s) - 1] != ' ':\n-                continue\n-            # also keep suffix to avoid confusing nam: \"Bitcoin Token\" -> \"Bitcoin\"\n-            if name[:-len(s)].strip().lower() == 'bitcoin':\n-                continue\n-            coin['reduced-name'] = True\n-            name = name[:-len(s)]\n-            break\n-\n-    coin['nn'] = coingecko_normalize_name(name)\n-\n-    if len(coin['nn']) < len(coin['ns']):\n-        if 'reduced-name' in coin:\n-            coin['reduced-name'] = False\n-            name = coin['name']\n-            coin['nn'] = coingecko_normalize_name(name)\n-        elif not has_many_caps(name):\n-            return coin['ns']\n-\n-    if not coin['ns']:  # coin['symbol'] may be an emoji that is striped when normalized\n-        return coin['nn']\n-\n-    if coin.get('reduced-name') and coin['ns'].upper() != coin['nn'].upper():\n-        return coin['ns']\n-\n-    i = coin['nn'].find('.')  # if there is a dot in normalized name => prefer the normalized symbol\n-    if i >= 0:\n-        if i > 1 and coin['nn'][i - 1].isdigit() and coin['nn'][i + 1].isdigit():\n-            pass  # except when the dot separates digits\n-        else:\n-            return coin['ns']\n-\n-    if is_name_short(coin) and has_many_caps(name):\n-        return coin['nn']\n-\n-    if 1.5 * len(coin['ns']) > len(coin['nn']) and any(c.islower() for c in coin['ns']):\n-        return coin['nn']\n-\n-    return coin['ns']\n-\n-\n-def coingecko_symbols() -> Dict[str, str]:\n-    r = None\n-    intermediate = defaultdict(list)\n-    try:\n-        r = requests.get('https://api.coingecko.com/api/v3/coins/list')\n-        all_coins = r.json()\n-        # First pass: generate & compare normalized symbol/name, and then select the most pertinent\n-        for coin in all_coins:\n-            normalized = coingecko_normalize_all(coin)\n-            intermediate[normalized].append(coin)\n-            # Above line keeps together the coins having the same normalized symbol.\n-            # To reduce collision, the coin['name'] is sometimes used in lieu of the coin['symbol'].\n-            # The coin['name'] is not capitalized because lower case letters may be meaningful: cETH, yUSD, DATx, zLOT\n-    except Exception as why:\n-        raise_failure_explanation('COINGECKO', why, {\"\": r})\n-\n-    final = coingecko_second_pass(intermediate)\n-    return coingecko_third_pass(final)\n-\n-\n-def coingecko_second_pass(intermediate: Dict[str, List[dict]]) -> Dict[str, List[dict]]:\n-    # Second pass: fixes most of the symbol collisions\n-    final = defaultdict(list)\n-    for normalized, coins in intermediate.items():\n-        if len(coins) == 1:\n-            final[normalized].append(coins[0])\n-            continue\n-        set_normalized = False\n-        for i in range(len(coins)):\n-            if normalized == coins[i]['nn']:\n-                coin = coins.pop(i)\n-                final[normalized].append(coin)\n-                set_normalized = True\n-                break\n-        rest: List[dict] = []\n-        for coin in coins:\n-            if '%' in coin['name']:\n-                if len(coins) == 1:\n-                    n = coin['ns']\n-                else:\n-                    n = coingecko_normalize_name(coin['id'])\n-                final[n].append(coin)\n-            else:\n-                rest.append(coin)\n-        if not rest:\n-            continue\n-        if not set_normalized:\n-            rest.sort(key=lambda coin: len(coin['nn']), reverse=True)  # sort by the length of the normalized name\n-            coin = rest.pop(0)\n-            final[normalized].append(coin)\n-        for coin in rest:\n-            if coin['nn'] not in intermediate:\n-                n = coin['nn']\n-            elif coin.get('reduced-name'):\n-                n = coingecko_normalize_name(coin['name'])\n-            else:\n-                n = coingecko_normalize_name(coin['id'])\n-            final[n].append(coin)\n-    return final\n-\n-\n-def coingecko_third_pass(final: Dict[str, List[dict]]) -> Dict[str, str]:\n-    # Third pass: fixes some remaining collisions and fills the result\n-    symbols = {}\n-    for normalized, coins in final.items():\n-        if len(coins) == 1:\n-            symbols[normalized] = coins[0]['id']\n-            continue\n-        set_normalized = False\n-        for i in range(len(coins)):\n-            if normalized == coins[i]['nn']:\n-                coin = coins.pop(i)\n-                symbols[normalized] = coin['id']\n-                set_normalized = True\n-                break\n-        rest: List[dict] = []\n-        for coin in coins:\n-            if '%' in coin['name']:\n-                if len(coins) == 1:\n-                    n = coin['ns']\n-                else:\n-                    n = coingecko_normalize_name(coin['id'])\n-                symbols[n] = coin['id']\n-            else:\n-                rest.append(coin)\n-        if not rest:\n-            continue\n-        if not set_normalized:\n-            rest.sort(key=lambda coin: len(coin['nn']), reverse=True)  # sort by the length of the normalized name\n-            coin = rest.pop(0)\n-            symbols[normalized] = coin['id']\n-        for coin in rest:\n-            if coin['nn'] not in final:\n-                n = coin['nn']\n-            elif coin.get('reduced-name'):\n-                n = coingecko_normalize_name(coin['name'])\n-            else:\n-                n = coingecko_normalize_name(coin['id'])\n-            symbols[n] = coin['id']\n-    return symbols\n-\n-\n-def whale_alert_coins(key_id: str) -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get(f'https://api.whale-alert.io/v1/status?api_key={key_id}')\n-        # Same symbols, but on different blockchains (for instance USDT), are naturally overwritten.\n-        return {s.upper(): s for b in r.json()['blockchains'] for s in b['symbols'] if s}\n-    except Exception as why:\n-        raise_failure_explanation('WHALES_ALERT', why, {\"\": r})\n-\n-\n-_exchange_function_map = {\n-    BITFINEX: bitfinex_symbols,\n-    BITFLYER: bitflyer_symbols,\n-    COINBASE: coinbase_symbols,\n-    GEMINI: gemini_symbols,\n-    HITBTC: hitbtc_symbols,\n-    POLONIEX: poloniex_symbols,\n-    PROBIT: probit_symbols,\n-    BITSTAMP: bitstamp_symbols,\n-    KRAKEN: kraken_symbols,\n-    KRAKEN + 'REST': kraken_rest_symbols,\n-    BINANCE: binance_symbols,\n-    BINANCE_US: binance_us_symbols,\n-    BINANCE_FUTURES: binance_futures_symbols,\n-    BINANCE_DELIVERY: binance_delivery_symbols,\n-    BLOCKCHAIN: blockchain_symbols,\n-    EXX: exx_symbols,\n-    HUOBI: huobi_symbols,\n-    HUOBI_DM: huobi_dm_symbols,\n-    HUOBI_SWAP: huobi_swap_symbols,\n-    OKCOIN: okcoin_symbols,\n-    OKEX: okex_symbols,\n-    BYBIT: bybit_symbols,\n-    FTX: ftx_symbols,\n-    FTX_US: ftx_us_symbols,\n-    BITTREX: bittrex_symbols,\n-    BITCOINCOM: bitcoincom_symbols,\n-    BITMAX: bitmax_symbols,\n-    UPBIT: upbit_symbols,\n-    GATEIO: gateio_symbols,\n-    BITMEX: bitmex_symbols,\n-    DERIBIT: deribit_symbols,\n-    KRAKEN_FUTURES: kraken_future_symbols,\n-    COINGECKO: coingecko_symbols,\n-    WHALE_ALERT: whale_alert_coins\n-}\n+Symbols = _Symbols()\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\n\nimport logging\nimport string\nimport time\nfrom collections import defaultdict\nfrom typing import Dict, List, Optional, Tuple\n\nimport requests\nfrom requests import Response\n\nfrom cryptofeed.defines import *\n\n\nLOG = logging.getLogger('feedhandler')\n\nSYMBOL_SEP = '-'\n\n_symbols_retrieval_cache: Dict[str, Dict[str, str]] = {}\n_exchange_info = defaultdict(lambda: defaultdict(dict))\n\n\n_kraken_futures_product_type = {\n    'FI': 'Inverse Futures',\n    'FV': 'Vanilla Futures',\n    'PI': 'Perpetual Inverse Futures',\n    'PV': 'Perpetual Vanilla Futures',\n    'IN': 'Real Time Index',\n    'RR': 'Reference Rate',\n}\n\n\ndef raise_failure_explanation(feed_id: str, exception: BaseException, responses: Dict[str, Optional[Response]]):\n    <IND>LOG.critical('%s: encountered %r while processing response from exchange API', feed_id, exception)\n    if len(responses) > 1:\n        <IND>LOG.critical('%s: content of one of the %s responses was unexpected', feed_id, len(responses))\n    <DED>for url, r in responses.items():\n        <IND>if url:\n            <IND>LOG.critical('%s: requested URL: %s', feed_id, url)\n        <DED>if r:\n            <IND>LOG.critical('%s: unexpected response: %s', feed_id, r.text)\n    <DED><DED>raise ValueError(f'Cryptofeed stopped because of an unexpected response from {feed_id}') from exception\n\n\n<DED>def set_symbol_separator(separator: str):\n    <IND>global SYMBOL_SEP\n    SYMBOL_SEP = separator\n\n\n<DED>def get_symbol_separator() -> str:\n    <IND>global SYMBOL_SEP\n    return SYMBOL_SEP\n\n\n<DED>def gen_symbols(exchange: str, key_id=None) -> Dict[str, str]:\n    <IND>if exchange not in _symbols_retrieval_cache:\n        <IND>LOG.info(\"%s: Getting list of symbols\", exchange)\n        symbols = _exchange_function_map[exchange](key_id) if key_id else _exchange_function_map[exchange]()\n        LOG.info(\"%s: %s symbols\", exchange, len(symbols))\n\n        # log all retrieved symbols using debug level\n        for normalized, exch_sym in sorted(symbols.items()):\n            <IND>LOG.debug('%s: id-from-exch -> normalized: %-35s-> %s', exchange, exch_sym, normalized)\n\n        <DED>_symbols_retrieval_cache[exchange] = symbols\n    <DED>return _symbols_retrieval_cache[exchange]\n\n\n<DED>def _binance_symbols(endpoint: str, exchange: str):\n    <IND>r = None\n    try:\n        <IND>ret = {}\n        r = requests.get(endpoint)\n        for symbol in r.json()['symbols']:\n            <IND>if symbol.get('status', 'TRADING') != \"TRADING\":\n                <IND>continue\n            <DED>if symbol.get('contractStatus', 'TRADING') != \"TRADING\":\n                <IND>continue\n            <DED>split = len(symbol['baseAsset'])\n            normalized = symbol['symbol'][:split] + SYMBOL_SEP + symbol['symbol'][split:]\n            ret[normalized] = symbol['symbol']\n            _exchange_info[exchange]['tick_size'][normalized] = symbol['filters'][0]['tickSize']\n            if \"contractType\" in symbol:\n                <IND>_exchange_info[exchange]['contract_type'][normalized] = symbol['contractType']\n        <DED><DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation(exchange, why, {endpoint: r})\n\n\n<DED><DED>def binance_symbols() -> Dict[str, str]:\n    <IND>return _binance_symbols('https://api.binance.com/api/v3/exchangeInfo', BINANCE)\n\n\n<DED>def binance_us_symbols() -> Dict[str, str]:\n    <IND>return _binance_symbols('https://api.binance.us/api/v3/exchangeInfo', BINANCE_US)\n\n\n<DED>def binance_futures_symbols() -> Dict[str, str]:\n    <IND>base = _binance_symbols('https://fapi.binance.com/fapi/v1/exchangeInfo', BINANCE_FUTURES)\n    add = {}\n    for symbol, orig in base.items():\n        <IND>if \"_\" in orig:\n            <IND>continue\n        <DED>add[f\"{symbol}-PINDEX\"] = f\"p{orig}\"\n    <DED>base.update(add)\n    return base\n\n\n<DED>def binance_delivery_symbols() -> Dict[str, str]:\n    <IND>return _binance_symbols('https://dapi.binance.com/dapi/v1/exchangeInfo', BINANCE_DELIVERY)\n\n\n<DED>def bitfinex_symbols() -> Dict[str, str]:\n    # doc: https://docs.bitfinex.com/docs/ws-general#supported-pairs\n    <IND>r1 = r2 = None\n    try:\n        <IND>r1 = requests.get('https://api.bitfinex.com/v2/tickers?symbols=ALL')\n        r2 = requests.get('https://api-pub.bitfinex.com/v2/conf/pub:map:currency:sym')\n        tickers: List[List[str]] = r1.json()\n        norm: List[Tuple[str, str]] = r2.json()[0]\n        norm: Dict[str, str] = dict(norm)\n        for k, v in dict(norm).items():\n            <IND>if k[-2:] == 'F0' or '-' in v:  # Do not convert BTCF0 -> BTC or PBTCETH -> PBTC-ETH\n                <IND>del norm[k]\n        <DED><DED>norm['BCHN'] = 'BCH'  # Bitfinex uses BCHN, other exchanges use BCH\n\n        ret = {}\n        for symbol in [t[0] for t in tickers]:\n            <IND>if symbol[0] == 'f':\n                <IND>normalized = norm.get(symbol[1:], symbol[1:])\n            <DED>else:\n                <IND>if len(symbol) == 7:\n                    <IND>base, quote = symbol[1:4], symbol[4:]\n                <DED>else:\n                    <IND>base, quote = symbol[1:].split(':')\n                    assert ':' in symbol\n                <DED>normalized = norm.get(base, base) + SYMBOL_SEP + norm.get(quote, quote)\n            <DED>ret[normalized.upper()] = symbol\n        <DED>return ret\n    <DED>except ValueError as why:\n        <IND>raise_failure_explanation('BITFINEX', why, {\"tickers?symbols=ALL\": r1, \"pub:map:currency:sym\": r2})\n\n\n<DED><DED>def bitflyer_symbols() -> Dict[str, str]:\n    <IND>endpoint = r = None\n    try:\n        <IND>ret = {}\n        endpoints = ['https://api.bitflyer.com/v1/getmarkets/eu', 'https://api.bitflyer.com/v1/getmarkets/usa', 'https://api.bitflyer.com/v1/getmarkets']\n        for endpoint in endpoints:\n            <IND>r = requests.get(endpoint)\n            for entry in r.json():\n                <IND>normalized = entry['product_code'].replace(\"_\", SYMBOL_SEP)\n                ret[normalized] = entry['product_code']\n        <DED><DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BITFLYER', why, {endpoint: r})\n\n\n<DED><DED>def bybit_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.bybit.com/v2/public/symbols')\n        ret = {}\n        for symbol in r.json()['result']:\n            <IND>quote = symbol['quote_currency']\n            if not symbol['name'].endswith(quote):\n                <IND>base, contract = symbol['name'].split(quote)\n                normalized = f\"{base}{SYMBOL_SEP}{quote}-{contract}\"\n            <DED>else:\n                <IND>normalized = f\"{symbol['base_currency']}{SYMBOL_SEP}{quote}\"\n            <DED>ret[normalized] = symbol['name']\n            _exchange_info[BYBIT]['tick_size'][normalized] = symbol['price_filter']['tick_size']\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BYBIT', why, {\"\": r})\n\n\n<DED><DED>def _ftx_helper(endpoint: str, exchange: str):\n    <IND>r = None\n    try:\n        <IND>r = requests.get(endpoint)\n        ret = {}\n        for data in r.json()['result']:\n            <IND>normalized = data['name'].replace(\"/\", SYMBOL_SEP)\n            symbol = data['name']\n            ret[normalized] = symbol\n            _exchange_info[exchange]['tick_size'][normalized] = data['priceIncrement']\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation(exchange, why, {endpoint: r})\n\n\n<DED><DED>def ftx_symbols() -> Dict[str, str]:\n    <IND>return _ftx_helper('https://ftx.com/api/markets', FTX)\n\n\n<DED>def ftx_us_symbols() -> Dict[str, str]:\n    <IND>return _ftx_helper('https://ftx.us/api/markets', FTX_US)\n\n\n<DED>def coinbase_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.pro.coinbase.com/products')\n        ret = {}\n        for data in r.json():\n            <IND>normalized = data['id'].replace(\"-\", SYMBOL_SEP)\n            ret[normalized] = data['id']\n            _exchange_info[COINBASE]['tick_size'][normalized] = data['quote_increment']\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('COINBASE', why, {\"\": r})\n\n\n<DED><DED>def gemini_symbols(*args) -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.gemini.com/v1/symbols')\n        ret = {}\n        for symbol in r.json():\n            <IND>std = f\"{symbol[:-3]}{SYMBOL_SEP}{symbol[-3:]}\"\n            std = std.upper()\n            ret[std] = symbol.upper()\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('GEMINI', why, {\"\": r})\n\n\n<DED><DED>def hitbtc_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>ret = {}\n        r = requests.get('https://api.hitbtc.com/api/2/public/symbol')\n        for symbol in r.json():\n            <IND>split = len(symbol['baseCurrency'])\n            normalized = symbol['id'][:split] + SYMBOL_SEP + symbol['id'][split:]\n            ret[normalized] = symbol['id']\n            _exchange_info[HITBTC]['tick_size'][normalized] = symbol['tickSize']\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('HITBTC', why, {\"\": r})\n\n\n<DED><DED>def poloniex_id_symbol_mapping():\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://poloniex.com/public?command=returnTicker')\n        symbols = r.json()\n        ret = {}\n        for symbol in symbols:\n            <IND>ret[symbols[symbol]['id']] = symbol\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('POLONIEX', why, {\"\": r})\n\n\n<DED><DED>def poloniex_symbols() -> Dict[str, str]:\n    <IND>ret = {}\n    for _, value in poloniex_id_symbol_mapping().items():\n        <IND>std = value.replace(\"STR\", \"XLM\")\n        quote, base = std.split(\"_\")\n        ret[quote + SYMBOL_SEP + base] = value\n    <DED>return ret\n\n\n<DED>def bitstamp_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://www.bitstamp.net/api/v2/trading-pairs-info/')\n        ret = {}\n        for data in r.json():\n            <IND>normalized = data['name'].replace(\"/\", SYMBOL_SEP)\n            symbol = data['url_symbol']\n            ret[normalized] = symbol\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BITSTAMP', why, {\"\": r})\n\n\n<DED><DED>def kraken_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.kraken.com/0/public/AssetPairs')\n        data = r.json()\n        ret = {}\n        for symbol in data['result']:\n            <IND>if 'wsname' not in data['result'][symbol] or '.d' in symbol:\n                # https://blog.kraken.com/post/259/introducing-the-kraken-dark-pool/\n                # .d is for dark pool symbols\n                <IND>continue\n\n            <DED>base, quote = data['result'][symbol]['wsname'].split(\"/\")\n\n            normalized = f\"{base}{SYMBOL_SEP}{quote}\"\n            exch = data['result'][symbol]['wsname']\n            normalized = normalized.replace('XBT', 'BTC')\n            normalized = normalized.replace('XDG', 'DOG')\n            ret[normalized] = exch\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('KRAKEN', why, {\"\": r})\n\n\n<DED><DED>def kraken_rest_symbols() -> Dict[str, str]:\n    <IND>return {normalized: exchange.replace(\"/\", \"\") for normalized, exchange in kraken_symbols().items()}\n\n\n<DED>def exx_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.exx.com/data/v1/tickers')\n        exchange = [key.upper() for key in r.json().keys()]\n        symbols = [key.replace(\"_\", SYMBOL_SEP) for key in exchange]\n        return dict(zip(symbols, exchange))\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('EXX', why, {\"\": r})\n\n\n<DED><DED>def huobi_common_symbols(url: str):\n    <IND>r = None\n    try:\n        <IND>r = requests.get(url)\n        ret = {}\n        for e in r.json()['data']:\n            <IND>if e['state'] == 'offline':\n                <IND>continue\n            <DED>normalized = f\"{e['base-currency'].upper()}{SYMBOL_SEP}{e['quote-currency'].upper()}\"\n            symbol = f\"{e['base-currency']}{e['quote-currency']}\"\n            ret[normalized] = symbol\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('HUOBI', why, {url: r})\n\n\n<DED><DED>def huobi_symbols() -> Dict[str, str]:\n    <IND>return huobi_common_symbols('https://api.huobi.pro/v1/common/symbols')\n\n\n<DED>def huobi_us_symbols() -> Dict[str, str]:\n    <IND>return huobi_common_symbols('https://api.huobi.com/v1/common/symbols')\n\n\n<DED>def huobi_dm_symbols() -> Dict[str, str]:\n    <IND>\"\"\"\n    Mapping is, for instance: {\"BTC_CW\":\"BTC190816\"}\n    See comments in exchange/huobi_dm.py\n    \"\"\"\n    mapping = {\n        \"this_week\": \"CW\",\n        \"next_week\": \"NW\",\n        \"quarter\": \"CQ\",\n        \"next_quarter\": \"NQ\"\n    }\n    r = None\n    try:\n        <IND>r = requests.get('https://www.hbdm.com/api/v1/contract_contract_info')\n        symbols = {}\n        for e in r.json()['data']:\n            <IND>symbols[f\"{e['symbol']}_{mapping[e['contract_type']]}\"] = e['contract_code']\n            _exchange_info[HUOBI_DM]['tick_size'][e['contract_code']] = e['price_tick']\n            _exchange_info[HUOBI_DM]['short_code_mappings'][f\"{e['symbol']}_{mapping[e['contract_type']]}\"] = e['contract_code']\n        <DED>return symbols\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('HUOBI_DM', why, {\"\": r})\n\n\n<DED><DED>def huobi_swap_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.hbdm.com/swap-api/v1/swap_contract_info')\n        symbols = {}\n        for e in r.json()['data']:\n            <IND>symbols[e['contract_code']] = e['contract_code']\n            _exchange_info[HUOBI_SWAP]['tick_size'][e['contract_code']] = e['price_tick']\n        <DED>return symbols\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('HUOBI_SWAP', why, {\"\": r})\n\n\n<DED><DED>def okcoin_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://www.okcoin.com/api/spot/v3/instruments')\n        ret = {}\n        for e in r.json():\n            <IND>ret[e['instrument_id']] = e['instrument_id']\n            _exchange_info[OKCOIN]['tick_size'][e['instrument_id']] = e['tick_size']\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('OKCOIN', why, {\"\": r})\n\n\n<DED><DED>def okex_symbols(*args) -> Dict[str, str]:\n    <IND>urls = ['https://www.okex.com/api/spot/v3/instruments',\n            'https://www.okex.com/api/swap/v3/instruments',\n            'https://www.okex.com/api/futures/v3/instruments']\n    urls = urls + okex_compute_option_urls_from_underlyings()\n\n    symbols: Dict[str, str] = {}\n    for u in urls:\n        <IND>time.sleep(0.2)\n        symbols.update(okex_symbols_from_one_url(u))\n\n    <DED>for symbol in symbols:\n        <IND>instrument_type = 'futures'\n        dash_count = symbol.count(get_symbol_separator())\n        if dash_count == 1:  # BTC-USDT\n            <IND>instrument_type = 'spot'\n        <DED>if dash_count == 4:  # BTC-USD-201225-35000-P\n            <IND>instrument_type = 'option'\n        <DED>if symbol[-4:] == \"SWAP\":  # BTC-USDT-SWAP\n            <IND>instrument_type = 'swap'\n\n        <DED>_exchange_info[OKEX]['instrument_type'][symbol] = instrument_type\n\n    <DED>return symbols\n\n\n<DED>def okex_compute_option_urls_from_underlyings() -> List[str]:\n    <IND>url = 'https://www.okex.com/api/option/v3/underlying'\n    r = None\n    try:\n        <IND>r = requests.get(url)\n        return [f'https://www.okex.com/api/option/v3/instruments/{underlying}' for underlying in r.json()]\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('OKEX', why, {url: r})\n\n\n<DED><DED>def okex_symbols_from_one_url(url: str) -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get(url)\n        ret = {}\n        for e in r.json():\n            <IND>ret[e['instrument_id']] = e['instrument_id']\n            _exchange_info[OKEX]['tick_size'][e['instrument_id']] = e['tick_size']\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('OKEX', why, {url: r})\n\n\n<DED><DED>def bittrex_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.bittrex.com/api/v1.1/public/getmarkets')\n        r = r.json()['result']\n        return {f\"{e['MarketCurrency']}{SYMBOL_SEP}{e['BaseCurrency']}\": e['MarketName'] for e in r if e['IsActive']}\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BITTREX', why, {\"\": r})\n\n\n<DED><DED>def bitcoincom_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.exchange.bitcoin.com/api/2/public/symbol')\n        return {f\"{data['baseCurrency']}{SYMBOL_SEP}{data['quoteCurrency'].replace('USD', 'USDT')}\": data['id'] for data in r.json()}\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BITCOINCOM', why, {\"\": r})\n\n\n<DED><DED>def bitmax_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://bitmax.io/api/pro/v1/products')\n        ret = {}\n        for entry in r.json()['data']:\n            # Only \"Normal\" status symbols are tradeable\n            <IND>if entry['status'] == 'Normal':\n                <IND>normalized = f\"{entry['baseAsset']}{SYMBOL_SEP}{entry['quoteAsset']}\"\n                ret[normalized] = entry['symbol']\n                _exchange_info[BITMAX]['tick_size'][normalized] = entry['tickSize']\n        <DED><DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BITMAX', why, {\"\": r})\n\n\n<DED><DED>def upbit_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.upbit.com/v1/market/all')\n        return {f\"{data['market'].split('-')[1]}{SYMBOL_SEP}{data['market'].split('-')[0]}\": data['market'] for data in r.json()}\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('UPBIT', why, {\"\": r})\n\n\n<DED><DED>def blockchain_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get(\"https://api.blockchain.com/mercury-gateway/v1/instruments\")\n        return {data[\"symbol\"].replace(\"-\", SYMBOL_SEP): data[\"symbol\"] for data in r.json()}\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BLOCKCHAIN', why, {\"\": r})\n\n\n<DED><DED>def gateio_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get(\"https://api.gateio.ws/api/v4/spot/currency_pairs\")\n        return {data[\"id\"].replace(\"_\", SYMBOL_SEP): data['id'] for data in r.json()}\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('GATEIO', why, {\"\": r})\n\n\n<DED><DED>def bitmex_symbols() -> Dict[str, str]:\n    <IND>r = None\n    ret = {}\n    try:\n        <IND>r = requests.get(\"https://www.bitmex.com/api/v1/instrument/active\")\n        for entry in r.json():\n            <IND>components = []\n            components.append(entry['rootSymbol'])\n            components.append(entry['quoteCurrency'])\n\n            if entry['expiry']:\n                <IND>components.append(entry['symbol'][-3:])\n\n            <DED>normalized = SYMBOL_SEP.join(components)\n            normalized = normalized.replace(\"XBT\", \"BTC\")\n            ret[normalized] = entry['symbol']\n            _exchange_info[BITMEX]['tick_size'][normalized] = entry['tickSize']\n\n            if entry['expiry']:\n                <IND>_exchange_info[BITMEX]['expiry'][normalized] = entry['expiry']\n\n        <DED><DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BITMEX', why, {\"\": r})\n\n\n<DED><DED>def deribit_symbols() -> Dict[str, str]:\n    <IND>url = r = None\n    ret = {}\n    try:\n        # TODO: get currencies from https://www.deribit.com/api/v2/public/get_currencies\n        <IND>currencies = ['BTC', 'ETH']\n        for c in currencies:\n            <IND>url = f\"https://www.deribit.com/api/v2/public/get_instruments?currency={c}&expired=false\"\n            r = requests.get(url)\n            for entry in r.json()['result']:\n                <IND>split = entry['instrument_name'].split(\"-\")\n                normalized = split[0] + SYMBOL_SEP + entry['quote_currency'] + \"-\" + '-'.join(split[1:])\n                ret[normalized] = entry['instrument_name']\n                _exchange_info[DERIBIT]['tick_size'][normalized] = entry['tick_size']\n        <DED><DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('DERIBIT', why, {url: r})\n\n\n<DED><DED>def kraken_future_symbols() -> Dict[str, str]:\n    <IND>r = None\n    ret = {}\n    try:\n        <IND>r = requests.get('https://futures.kraken.com/derivatives/api/v3/instruments')\n        data = r.json()['instruments']\n        for entry in data:\n            <IND>if not entry['tradeable']:\n                <IND>continue\n            <DED>normalized = entry['symbol'].upper().replace(\"_\", \"-\")\n            symbol = normalized[3:6] + SYMBOL_SEP + normalized[6:9]\n            normalized = normalized.replace(normalized[3:9], symbol)\n            normalized = normalized.replace('XBT', 'BTC')\n\n            _exchange_info[KRAKEN_FUTURES]['tick_size'][normalized] = entry['tickSize']\n            _exchange_info[KRAKEN_FUTURES]['contract_size'][normalized] = entry['contractSize']\n            _exchange_info[KRAKEN_FUTURES]['underlying'][normalized] = entry['underlying']\n            _exchange_info[KRAKEN_FUTURES]['product_type'][normalized] = _kraken_futures_product_type[normalized[:2]]\n            ret[normalized] = entry['symbol']\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('KRAKEN_FUTURES', why, {\"\": r})\n\n\n<DED><DED>def probit_symbols() -> Dict[str, str]:\n    # doc: https://docs-en.probit.com/reference-link/market\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.probit.com/api/exchange/v1/market')\n        return {entry['id']: entry['id'] for entry in r.json()['data']}\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('PROBIT', why, {\"\": r})\n\n\n<DED><DED>def coingecko_normalize_symbol(symbol: str) -> str:\n    # keep digits, letters and dots, replace others by space\n    <IND>symbol = ''.join(c if c.isalnum() or c in ('.', '+') else ' ' for c in symbol)\n    return coingecko_normalize(symbol.upper())\n\n\n<DED>def coingecko_normalize_name(name: str) -> str:\n    # keep digits and letters, replace others by space (except when only composed by upper case letters, digits and dots)\n    <IND>if not all(c.isupper() or c.isdigit() or c == '.' for c in name):\n        <IND>name = ''.join(c if c.isalnum() else ' ' for c in name)\n    <DED>return coingecko_normalize(name)\n\n\n<DED>def coingecko_normalize(sym: str) -> str:\n    <IND>sym = sym.strip()\n    # do not concatenate numbers => separate them with a dot\n    sym = list(sym)\n    if len(sym) > 4:\n        <IND>for i in range(2, len(sym) - 1):\n            <IND>if sym[i] == ' ' and sym[i - 1].isdigit() and sym[i + 1].isdigit():\n                <IND>sym[i] = '.'\n    <DED><DED><DED>sym = ''.join(sym)\n    # concatenate space-separated words => use CamelCase to distinguish the words\n    if ' ' in sym:\n        <IND>if sum(c.islower() for c in sym):  # if there is at least one lower case letter\n            <IND>sym = ' '.join(word[0].upper() + word[1:] for word in sym.split())  # Just capitalize initial letter of each word\n        <DED>else:  # CoinGecko may provide full upper-case as for \"THE STONE COIN\"\n            <IND>sym = string.capwords(sym)  # capwords converts \"THE STONE COIN\" to \"The Stone Coin\"\n        <DED>sym = sym.replace(' ', '')  # concatenate words\n    <DED>return sym\n\n\n<DED>def is_name_short(coin: dict) -> bool:\n    <IND>\"\"\"return True if the coin name is enough short compared to the coin symbol.\"\"\"\n    return len(coin['name']) <= max(5, len(coin['symbol']) + 1)\n\n\n<DED>def has_many_caps(name: str) -> bool:\n    <IND>\"\"\"return True if the symbol contains enough upper case letters, False if empty.\"\"\"\n    return str and sum(c.islower() for c in name) < (len(name) / 2)\n\n\n<DED>def coingecko_normalize_all(coin: dict):\n    <IND>SYMBOL_TO_NORMALIZED = {'miota': 'IOTA'}\n    normalized = SYMBOL_TO_NORMALIZED.get(coin['symbol'])\n    if normalized:\n        <IND>coin['ns'] = coin['nn'] = normalized\n        return normalized\n\n    # ns = normalized symbol, nn = normalized name\n    <DED>coin['ns'] = coingecko_normalize_symbol(coin['symbol'])\n\n    ID_SUFFIX = '-bitcoin-token'\n    if coin['id'][-len(ID_SUFFIX):] == ID_SUFFIX:\n        <IND>coin['nn'] = 'BTC' + coin['ns']\n        return coin['nn']\n\n    <DED>name = coin['name']\n\n    prefixes = ('The ', 'the ')\n    for p in prefixes:\n        <IND>if name[:len(p)] == p:\n            <IND>coin['reduced-name'] = True\n            name = name[len(p):]\n            break\n\n    <DED><DED>suffixes = ('coin', 'coins', 'money', 'finance', 'protocol', 'reward', 'rewards', 'token')\n    for s in suffixes:\n        <IND>if len(name) > len(s) and name[-len(s):].lower() == s:\n            # but keep suffix when lower-case concatenated\n            <IND>if name[-len(s)].islower() and name[-len(s) - 1] != ' ':\n                <IND>continue\n            # also keep suffix to avoid confusing nam: \"Bitcoin Token\" -> \"Bitcoin\"\n            <DED>if name[:-len(s)].strip().lower() == 'bitcoin':\n                <IND>continue\n            <DED>coin['reduced-name'] = True\n            name = name[:-len(s)]\n            break\n\n    <DED><DED>coin['nn'] = coingecko_normalize_name(name)\n\n    if len(coin['nn']) < len(coin['ns']):\n        <IND>if 'reduced-name' in coin:\n            <IND>coin['reduced-name'] = False\n            name = coin['name']\n            coin['nn'] = coingecko_normalize_name(name)\n        <DED>elif not has_many_caps(name):\n            <IND>return coin['ns']\n\n    <DED><DED>if not coin['ns']:  # coin['symbol'] may be an emoji that is striped when normalized\n        <IND>return coin['nn']\n\n    <DED>if coin.get('reduced-name') and coin['ns'].upper() != coin['nn'].upper():\n        <IND>return coin['ns']\n\n    <DED>i = coin['nn'].find('.')  # if there is a dot in normalized name => prefer the normalized symbol\n    if i >= 0:\n        <IND>if i > 1 and coin['nn'][i - 1].isdigit() and coin['nn'][i + 1].isdigit():\n            <IND>pass  # except when the dot separates digits\n        <DED>else:\n            <IND>return coin['ns']\n\n    <DED><DED>if is_name_short(coin) and has_many_caps(name):\n        <IND>return coin['nn']\n\n    <DED>if 1.5 * len(coin['ns']) > len(coin['nn']) and any(c.islower() for c in coin['ns']):\n        <IND>return coin['nn']\n\n    <DED>return coin['ns']\n\n\n<DED>def coingecko_symbols() -> Dict[str, str]:\n    <IND>r = None\n    intermediate = defaultdict(list)\n    try:\n        <IND>r = requests.get('https://api.coingecko.com/api/v3/coins/list')\n        all_coins = r.json()\n        # First pass: generate & compare normalized symbol/name, and then select the most pertinent\n        for coin in all_coins:\n            <IND>normalized = coingecko_normalize_all(coin)\n            intermediate[normalized].append(coin)\n            # Above line keeps together the coins having the same normalized symbol.\n            # To reduce collision, the coin['name'] is sometimes used in lieu of the coin['symbol'].\n            # The coin['name'] is not capitalized because lower case letters may be meaningful: cETH, yUSD, DATx, zLOT\n    <DED><DED>except Exception as why:\n        <IND>raise_failure_explanation('COINGECKO', why, {\"\": r})\n\n    <DED>final = coingecko_second_pass(intermediate)\n    return coingecko_third_pass(final)\n\n\n<DED>def coingecko_second_pass(intermediate: Dict[str, List[dict]]) -> Dict[str, List[dict]]:\n    # Second pass: fixes most of the symbol collisions\n    <IND>final = defaultdict(list)\n    for normalized, coins in intermediate.items():\n        <IND>if len(coins) == 1:\n            <IND>final[normalized].append(coins[0])\n            continue\n        <DED>set_normalized = False\n        for i in range(len(coins)):\n            <IND>if normalized == coins[i]['nn']:\n                <IND>coin = coins.pop(i)\n                final[normalized].append(coin)\n                set_normalized = True\n                break\n        <DED><DED>rest: List[dict] = []\n        for coin in coins:\n            <IND>if '%' in coin['name']:\n                <IND>if len(coins) == 1:\n                    <IND>n = coin['ns']\n                <DED>else:\n                    <IND>n = coingecko_normalize_name(coin['id'])\n                <DED>final[n].append(coin)\n            <DED>else:\n                <IND>rest.append(coin)\n        <DED><DED>if not rest:\n            <IND>continue\n        <DED>if not set_normalized:\n            <IND>rest.sort(key=lambda coin: len(coin['nn']), reverse=True)  # sort by the length of the normalized name\n            coin = rest.pop(0)\n            final[normalized].append(coin)\n        <DED>for coin in rest:\n            <IND>if coin['nn'] not in intermediate:\n                <IND>n = coin['nn']\n            <DED>elif coin.get('reduced-name'):\n                <IND>n = coingecko_normalize_name(coin['name'])\n            <DED>else:\n                <IND>n = coingecko_normalize_name(coin['id'])\n            <DED>final[n].append(coin)\n    <DED><DED>return final\n\n\n<DED>def coingecko_third_pass(final: Dict[str, List[dict]]) -> Dict[str, str]:\n    # Third pass: fixes some remaining collisions and fills the result\n    <IND>symbols = {}\n    for normalized, coins in final.items():\n        <IND>if len(coins) == 1:\n            <IND>symbols[normalized] = coins[0]['id']\n            continue\n        <DED>set_normalized = False\n        for i in range(len(coins)):\n            <IND>if normalized == coins[i]['nn']:\n                <IND>coin = coins.pop(i)\n                symbols[normalized] = coin['id']\n                set_normalized = True\n                break\n        <DED><DED>rest: List[dict] = []\n        for coin in coins:\n            <IND>if '%' in coin['name']:\n                <IND>if len(coins) == 1:\n                    <IND>n = coin['ns']\n                <DED>else:\n                    <IND>n = coingecko_normalize_name(coin['id'])\n                <DED>symbols[n] = coin['id']\n            <DED>else:\n                <IND>rest.append(coin)\n        <DED><DED>if not rest:\n            <IND>continue\n        <DED>if not set_normalized:\n            <IND>rest.sort(key=lambda coin: len(coin['nn']), reverse=True)  # sort by the length of the normalized name\n            coin = rest.pop(0)\n            symbols[normalized] = coin['id']\n        <DED>for coin in rest:\n            <IND>if coin['nn'] not in final:\n                <IND>n = coin['nn']\n            <DED>elif coin.get('reduced-name'):\n                <IND>n = coingecko_normalize_name(coin['name'])\n            <DED>else:\n                <IND>n = coingecko_normalize_name(coin['id'])\n            <DED>symbols[n] = coin['id']\n    <DED><DED>return symbols\n\n\n<DED>def whale_alert_coins(key_id: str) -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get(f'https://api.whale-alert.io/v1/status?api_key={key_id}')\n        # Same symbols, but on different blockchains (for instance USDT), are naturally overwritten.\n        return {s.upper(): s for b in r.json()['blockchains'] for s in b['symbols'] if s}\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('WHALES_ALERT', why, {\"\": r})\n\n\n<DED><DED>_exchange_function_map = {\n    BITFINEX: bitfinex_symbols,\n    BITFLYER: bitflyer_symbols,\n    COINBASE: coinbase_symbols,\n    GEMINI: gemini_symbols,\n    HITBTC: hitbtc_symbols,\n    POLONIEX: poloniex_symbols,\n    PROBIT: probit_symbols,\n    BITSTAMP: bitstamp_symbols,\n    KRAKEN: kraken_symbols,\n    KRAKEN + 'REST': kraken_rest_symbols,\n    BINANCE: binance_symbols,\n    BINANCE_US: binance_us_symbols,\n    BINANCE_FUTURES: binance_futures_symbols,\n    BINANCE_DELIVERY: binance_delivery_symbols,\n    BLOCKCHAIN: blockchain_symbols,\n    EXX: exx_symbols,\n    HUOBI: huobi_symbols,\n    HUOBI_DM: huobi_dm_symbols,\n    HUOBI_SWAP: huobi_swap_symbols,\n    OKCOIN: okcoin_symbols,\n    OKEX: okex_symbols,\n    BYBIT: bybit_symbols,\n    FTX: ftx_symbols,\n    FTX_US: ftx_us_symbols,\n    BITTREX: bittrex_symbols,\n    BITCOINCOM: bitcoincom_symbols,\n    BITMAX: bitmax_symbols,\n    UPBIT: upbit_symbols,\n    GATEIO: gateio_symbols,\n    BITMEX: bitmex_symbols,\n    DERIBIT: deribit_symbols,\n    KRAKEN_FUTURES: kraken_future_symbols,\n    COINGECKO: coingecko_symbols,\n    WHALE_ALERT: whale_alert_coins\n}\n",
        "target_code_with_indent": "\nfrom typing import Dict, Tuple\n\n\nclass _Symbols:\n    <IND>def __init__(self):\n        <IND>self.data = {}\n\n    <DED>def set(self, exchange: str, normalized: dict, exchange_info: dict):\n        <IND>self.data[exchange] = {}\n        self.data[exchange]['normalized'] = normalized\n        self.data[exchange]['info'] = exchange_info\n\n    <DED>def get(self, exchange: str) -> Tuple[Dict, Dict]:\n        <IND>return self.data[exchange]['normalized'], self.data[exchange]['info']\n\n    <DED>def populated(self, exchange: str) -> bool:\n        <IND>return exchange in self.data\n\n\n<DED><DED>Symbols = _Symbols()\n"
      }
    ]
  },
  {
    "project": "bmoscon/cryptofeed",
    "commit": "3525dc8ce4d7836a9abaaa5662e58e5e27969a77",
    "filename": "cryptofeed/symbols.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/bmoscon-cryptofeed/cryptofeed/symbols.py",
    "file_hunks_size": 1,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "cryptofeed/symbols.py:630:4 Incompatible return type [7]: Expected `bool` but got `typing.Union[typing.Type[str], bool]`.",
    "message": " Expected `bool` but got `typing.Union[typing.Type[str], bool]`.",
    "rule_id": "Incompatible return type [7]",
    "warning_line_no": 630,
    "warning_line": "    return str and sum(c.islower() for c in name) < (len(name) / 2)",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "associated with this software.\n\n\nSymbol generation code for exchanges\n'''\n\nimport logging\nimport string\nimport time\nfrom collections import defaultdict\nfrom typing import Dict, List, Optional, Tuple\n\nimport requests\nfrom requests import Response\n\nfrom cryptofeed.defines import *\n\n\nLOG = logging.getLogger('feedhandler')\n\nSYMBOL_SEP = '-'\n\n_symbols_retrieval_cache: Dict[str, Dict[str, str]] = {}\n_exchange_info = defaultdict(lambda: defaultdict(dict))\n\n\n_kraken_futures_product_type = {\n    'FI': 'Inverse Futures',\n    'FV': 'Vanilla Futures',\n    'PI': 'Perpetual Inverse Futures',\n    'PV': 'Perpetual Vanilla Futures',\n    'IN': 'Real Time Index',\n    'RR': 'Reference Rate',\n}\n\n\ndef raise_failure_explanation(feed_id: str, exception: BaseException, responses: Dict[str, Optional[Response]]):\n    LOG.critical('%s: encountered %r while processing response from exchange API', feed_id, exception)\n    if len(responses) > 1:\n        LOG.critical('%s: content of one of the %s responses was unexpected', feed_id, len(responses))\n    for url, r in responses.items():\n        if url:\n            LOG.critical('%s: requested URL: %s', feed_id, url)\n        if r:\n            LOG.critical('%s: unexpected response: %s', feed_id, r.text)\n    raise ValueError(f'Cryptofeed stopped because of an unexpected response from {feed_id}') from exception\n\n\ndef set_symbol_separator(separator: str):\n    global SYMBOL_SEP\n    SYMBOL_SEP = separator\n\n\ndef get_symbol_separator() -> str:\n    global SYMBOL_SEP\n    return SYMBOL_SEP\n\n\ndef gen_symbols(exchange: str, key_id=None) -> Dict[str, str]:\n    if exchange not in _symbols_retrieval_cache:\n        LOG.info(\"%s: Getting list of symbols\", exchange)\n        symbols = _exchange_function_map[exchange](key_id) if key_id else _exchange_function_map[exchange]()\n        LOG.info(\"%s: %s symbols\", exchange, len(symbols))\n\n        # log all retrieved symbols using debug level\n        for normalized, exch_sym in sorted(symbols.items()):\n            LOG.debug('%s: id-from-exch -> normalized: %-35s-> %s', exchange, exch_sym, normalized)\n\n        _symbols_retrieval_cache[exchange] = symbols\n    return _symbols_retrieval_cache[exchange]\n\n\ndef _binance_symbols(endpoint: str, exchange: str):\n    r = None\n    try:\n        ret = {}\n        r = requests.get(endpoint)\n        for symbol in r.json()['symbols']:\n            if symbol.get('status', 'TRADING') != \"TRADING\":\n                continue\n            if symbol.get('contractStatus', 'TRADING') != \"TRADING\":\n                continue\n            split = len(symbol['baseAsset'])\n            normalized = symbol['symbol'][:split] + SYMBOL_SEP + symbol['symbol'][split:]\n            ret[normalized] = symbol['symbol']\n            _exchange_info[exchange]['tick_size'][normalized] = symbol['filters'][0]['tickSize']\n            if \"contractType\" in symbol:\n                _exchange_info[exchange]['contract_type'][normalized] = symbol['contractType']\n        return ret\n    except Exception as why:\n        raise_failure_explanation(exchange, why, {endpoint: r})\n\n\ndef binance_symbols() -> Dict[str, str]:\n    return _binance_symbols('https://api.binance.com/api/v3/exchangeInfo', BINANCE)\n\n\ndef binance_us_symbols() -> Dict[str, str]:\n    return _binance_symbols('https://api.binance.us/api/v3/exchangeInfo', BINANCE_US)\n\n\ndef binance_futures_symbols() -> Dict[str, str]:\n    base = _binance_symbols('https://fapi.binance.com/fapi/v1/exchangeInfo', BINANCE_FUTURES)\n    add = {}\n    for symbol, orig in base.items():\n        if \"_\" in orig:\n            continue\n        add[f\"{symbol}-PINDEX\"] = f\"p{orig}\"\n    base.update(add)\n    return base\n\n\ndef binance_delivery_symbols() -> Dict[str, str]:\n    return _binance_symbols('https://dapi.binance.com/dapi/v1/exchangeInfo', BINANCE_DELIVERY)\n\n\ndef bitfinex_symbols() -> Dict[str, str]:\n    # doc: https://docs.bitfinex.com/docs/ws-general#supported-pairs\n    r1 = r2 = None\n    try:\n        r1 = requests.get('https://api.bitfinex.com/v2/tickers?symbols=ALL')\n        r2 = requests.get('https://api-pub.bitfinex.com/v2/conf/pub:map:currency:sym')\n        tickers: List[List[str]] = r1.json()\n        norm: List[Tuple[str, str]] = r2.json()[0]\n        norm: Dict[str, str] = dict(norm)\n        for k, v in dict(norm).items():\n            if k[-2:] == 'F0' or '-' in v:  # Do not convert BTCF0 -> BTC or PBTCETH -> PBTC-ETH\n                del norm[k]\n        norm['BCHN'] = 'BCH'  # Bitfinex uses BCHN, other exchanges use BCH\n\n        ret = {}\n        for symbol in [t[0] for t in tickers]:\n            if symbol[0] == 'f':\n                normalized = norm.get(symbol[1:], symbol[1:])\n            else:\n                if len(symbol) == 7:\n                    base, quote = symbol[1:4], symbol[4:]\n                else:\n                    base, quote = symbol[1:].split(':')\n                    assert ':' in symbol\n                normalized = norm.get(base, base) + SYMBOL_SEP + norm.get(quote, quote)\n            ret[normalized.upper()] = symbol\n        return ret\n    except ValueError as why:\n        raise_failure_explanation('BITFINEX', why, {\"tickers?symbols=ALL\": r1, \"pub:map:currency:sym\": r2})\n\n\ndef bitflyer_symbols() -> Dict[str, str]:\n    endpoint = r = None\n    try:\n        ret = {}\n        endpoints = ['https://api.bitflyer.com/v1/getmarkets/eu', 'https://api.bitflyer.com/v1/getmarkets/usa', 'https://api.bitflyer.com/v1/getmarkets']\n        for endpoint in endpoints:\n            r = requests.get(endpoint)\n            for entry in r.json():\n                normalized = entry['product_code'].replace(\"_\", SYMBOL_SEP)\n                ret[normalized] = entry['product_code']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('BITFLYER', why, {endpoint: r})\n\n\ndef bybit_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.bybit.com/v2/public/symbols')\n        ret = {}\n        for symbol in r.json()['result']:\n            quote = symbol['quote_currency']\n            if not symbol['name'].endswith(quote):\n                base, contract = symbol['name'].split(quote)\n                normalized = f\"{base}{SYMBOL_SEP}{quote}-{contract}\"\n            else:\n                normalized = f\"{symbol['base_currency']}{SYMBOL_SEP}{quote}\"\n            ret[normalized] = symbol['name']\n            _exchange_info[BYBIT]['tick_size'][normalized] = symbol['price_filter']['tick_size']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('BYBIT', why, {\"\": r})\n\n\ndef _ftx_helper(endpoint: str, exchange: str):\n    r = None\n    try:\n        r = requests.get(endpoint)\n        ret = {}\n        for data in r.json()['result']:\n            normalized = data['name'].replace(\"/\", SYMBOL_SEP)\n            symbol = data['name']\n            ret[normalized] = symbol\n            _exchange_info[exchange]['tick_size'][normalized] = data['priceIncrement']\n        return ret\n    except Exception as why:\n        raise_failure_explanation(exchange, why, {endpoint: r})\n\n\ndef ftx_symbols() -> Dict[str, str]:\n    return _ftx_helper('https://ftx.com/api/markets', FTX)\n\n\ndef ftx_us_symbols() -> Dict[str, str]:\n    return _ftx_helper('https://ftx.us/api/markets', FTX_US)\n\n\ndef coinbase_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.pro.coinbase.com/products')\n        ret = {}\n        for data in r.json():\n            normalized = data['id'].replace(\"-\", SYMBOL_SEP)\n            ret[normalized] = data['id']\n            _exchange_info[COINBASE]['tick_size'][normalized] = data['quote_increment']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('COINBASE', why, {\"\": r})\n\n\ndef gemini_symbols(*args) -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.gemini.com/v1/symbols')\n        ret = {}\n        for symbol in r.json():\n            std = f\"{symbol[:-3]}{SYMBOL_SEP}{symbol[-3:]}\"\n            std = std.upper()\n            ret[std] = symbol.upper()\n        return ret\n    except Exception as why:\n        raise_failure_explanation('GEMINI', why, {\"\": r})\n\n\ndef hitbtc_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        ret = {}\n        r = requests.get('https://api.hitbtc.com/api/2/public/symbol')\n        for symbol in r.json():\n            split = len(symbol['baseCurrency'])\n            normalized = symbol['id'][:split] + SYMBOL_SEP + symbol['id'][split:]\n            ret[normalized] = symbol['id']\n            _exchange_info[HITBTC]['tick_size'][normalized] = symbol['tickSize']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('HITBTC', why, {\"\": r})\n\n\ndef poloniex_id_symbol_mapping():\n    r = None\n    try:\n        r = requests.get('https://poloniex.com/public?command=returnTicker')\n        symbols = r.json()\n        ret = {}\n        for symbol in symbols:\n            ret[symbols[symbol]['id']] = symbol\n        return ret\n    except Exception as why:\n        raise_failure_explanation('POLONIEX', why, {\"\": r})\n\n\ndef poloniex_symbols() -> Dict[str, str]:\n    ret = {}\n    for _, value in poloniex_id_symbol_mapping().items():\n        std = value.replace(\"STR\", \"XLM\")\n        quote, base = std.split(\"_\")\n        ret[quote + SYMBOL_SEP + base] = value\n    return ret\n\n\ndef bitstamp_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://www.bitstamp.net/api/v2/trading-pairs-info/')\n        ret = {}\n        for data in r.json():\n            normalized = data['name'].replace(\"/\", SYMBOL_SEP)\n            symbol = data['url_symbol']\n            ret[normalized] = symbol\n        return ret\n    except Exception as why:\n        raise_failure_explanation('BITSTAMP', why, {\"\": r})\n\n\ndef kraken_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.kraken.com/0/public/AssetPairs')\n        data = r.json()\n        ret = {}\n        for symbol in data['result']:\n            if 'wsname' not in data['result'][symbol] or '.d' in symbol:\n                # https://blog.kraken.com/post/259/introducing-the-kraken-dark-pool/\n                # .d is for dark pool symbols\n                continue\n\n            base, quote = data['result'][symbol]['wsname'].split(\"/\")\n\n            normalized = f\"{base}{SYMBOL_SEP}{quote}\"\n            exch = data['result'][symbol]['wsname']\n            normalized = normalized.replace('XBT', 'BTC')\n            normalized = normalized.replace('XDG', 'DOG')\n            ret[normalized] = exch\n        return ret\n    except Exception as why:\n        raise_failure_explanation('KRAKEN', why, {\"\": r})\n\n\ndef kraken_rest_symbols() -> Dict[str, str]:\n    return {normalized: exchange.replace(\"/\", \"\") for normalized, exchange in kraken_symbols().items()}\n\n\ndef exx_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.exx.com/data/v1/tickers')\n        exchange = [key.upper() for key in r.json().keys()]\n        symbols = [key.replace(\"_\", SYMBOL_SEP) for key in exchange]\n        return dict(zip(symbols, exchange))\n    except Exception as why:\n        raise_failure_explanation('EXX', why, {\"\": r})\n\n\ndef huobi_common_symbols(url: str):\n    r = None\n    try:\n        r = requests.get(url)\n        ret = {}\n        for e in r.json()['data']:\n            if e['state'] == 'offline':\n                continue\n            normalized = f\"{e['base-currency'].upper()}{SYMBOL_SEP}{e['quote-currency'].upper()}\"\n            symbol = f\"{e['base-currency']}{e['quote-currency']}\"\n            ret[normalized] = symbol\n        return ret\n    except Exception as why:\n        raise_failure_explanation('HUOBI', why, {url: r})\n\n\ndef huobi_symbols() -> Dict[str, str]:\n    return huobi_common_symbols('https://api.huobi.pro/v1/common/symbols')\n\n\ndef huobi_us_symbols() -> Dict[str, str]:\n    return huobi_common_symbols('https://api.huobi.com/v1/common/symbols')\n\n\ndef huobi_dm_symbols() -> Dict[str, str]:\n    \"\"\"\n    Mapping is, for instance: {\"BTC_CW\":\"BTC190816\"}\n    See comments in exchange/huobi_dm.py\n    \"\"\"\n    mapping = {\n        \"this_week\": \"CW\",\n        \"next_week\": \"NW\",\n        \"quarter\": \"CQ\",\n        \"next_quarter\": \"NQ\"\n    }\n    r = None\n    try:\n        r = requests.get('https://www.hbdm.com/api/v1/contract_contract_info')\n        symbols = {}\n        for e in r.json()['data']:\n            symbols[f\"{e['symbol']}_{mapping[e['contract_type']]}\"] = e['contract_code']\n            _exchange_info[HUOBI_DM]['tick_size'][e['contract_code']] = e['price_tick']\n            _exchange_info[HUOBI_DM]['short_code_mappings'][f\"{e['symbol']}_{mapping[e['contract_type']]}\"] = e['contract_code']\n        return symbols\n    except Exception as why:\n        raise_failure_explanation('HUOBI_DM', why, {\"\": r})\n\n\ndef huobi_swap_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.hbdm.com/swap-api/v1/swap_contract_info')\n        symbols = {}\n        for e in r.json()['data']:\n            symbols[e['contract_code']] = e['contract_code']\n            _exchange_info[HUOBI_SWAP]['tick_size'][e['contract_code']] = e['price_tick']\n        return symbols\n    except Exception as why:\n        raise_failure_explanation('HUOBI_SWAP', why, {\"\": r})\n\n\ndef okcoin_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://www.okcoin.com/api/spot/v3/instruments')\n        ret = {}\n        for e in r.json():\n            ret[e['instrument_id']] = e['instrument_id']\n            _exchange_info[OKCOIN]['tick_size'][e['instrument_id']] = e['tick_size']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('OKCOIN', why, {\"\": r})\n\n\ndef okex_symbols(*args) -> Dict[str, str]:\n    urls = ['https://www.okex.com/api/spot/v3/instruments',\n            'https://www.okex.com/api/swap/v3/instruments',\n            'https://www.okex.com/api/futures/v3/instruments']\n    urls = urls + okex_compute_option_urls_from_underlyings()\n\n    symbols: Dict[str, str] = {}\n    for u in urls:\n        time.sleep(0.2)\n        symbols.update(okex_symbols_from_one_url(u))\n\n    for symbol in symbols:\n        instrument_type = 'futures'\n        dash_count = symbol.count(get_symbol_separator())\n        if dash_count == 1:  # BTC-USDT\n            instrument_type = 'spot'\n        if dash_count == 4:  # BTC-USD-201225-35000-P\n            instrument_type = 'option'\n        if symbol[-4:] == \"SWAP\":  # BTC-USDT-SWAP\n            instrument_type = 'swap'\n\n        _exchange_info[OKEX]['instrument_type'][symbol] = instrument_type\n\n    return symbols\n\n\ndef okex_compute_option_urls_from_underlyings() -> List[str]:\n    url = 'https://www.okex.com/api/option/v3/underlying'\n    r = None\n    try:\n        r = requests.get(url)\n        return [f'https://www.okex.com/api/option/v3/instruments/{underlying}' for underlying in r.json()]\n    except Exception as why:\n        raise_failure_explanation('OKEX', why, {url: r})\n\n\ndef okex_symbols_from_one_url(url: str) -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get(url)\n        ret = {}\n        for e in r.json():\n            ret[e['instrument_id']] = e['instrument_id']\n            _exchange_info[OKEX]['tick_size'][e['instrument_id']] = e['tick_size']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('OKEX', why, {url: r})\n\n\ndef bittrex_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.bittrex.com/api/v1.1/public/getmarkets')\n        r = r.json()['result']\n        return {f\"{e['MarketCurrency']}{SYMBOL_SEP}{e['BaseCurrency']}\": e['MarketName'] for e in r if e['IsActive']}\n    except Exception as why:\n        raise_failure_explanation('BITTREX', why, {\"\": r})\n\n\ndef bitcoincom_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.exchange.bitcoin.com/api/2/public/symbol')\n        return {f\"{data['baseCurrency']}{SYMBOL_SEP}{data['quoteCurrency'].replace('USD', 'USDT')}\": data['id'] for data in r.json()}\n    except Exception as why:\n        raise_failure_explanation('BITCOINCOM', why, {\"\": r})\n\n\ndef bitmax_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://bitmax.io/api/pro/v1/products')\n        ret = {}\n        for entry in r.json()['data']:\n            # Only \"Normal\" status symbols are tradeable\n            if entry['status'] == 'Normal':\n                normalized = f\"{entry['baseAsset']}{SYMBOL_SEP}{entry['quoteAsset']}\"\n                ret[normalized] = entry['symbol']\n                _exchange_info[BITMAX]['tick_size'][normalized] = entry['tickSize']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('BITMAX', why, {\"\": r})\n\n\ndef upbit_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.upbit.com/v1/market/all')\n        return {f\"{data['market'].split('-')[1]}{SYMBOL_SEP}{data['market'].split('-')[0]}\": data['market'] for data in r.json()}\n    except Exception as why:\n        raise_failure_explanation('UPBIT', why, {\"\": r})\n\n\ndef blockchain_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get(\"https://api.blockchain.com/mercury-gateway/v1/instruments\")\n        return {data[\"symbol\"].replace(\"-\", SYMBOL_SEP): data[\"symbol\"] for data in r.json()}\n    except Exception as why:\n        raise_failure_explanation('BLOCKCHAIN', why, {\"\": r})\n\n\ndef gateio_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get(\"https://api.gateio.ws/api/v4/spot/currency_pairs\")\n        return {data[\"id\"].replace(\"_\", SYMBOL_SEP): data['id'] for data in r.json()}\n    except Exception as why:\n        raise_failure_explanation('GATEIO', why, {\"\": r})\n\n\ndef bitmex_symbols() -> Dict[str, str]:\n    r = None\n    ret = {}\n    try:\n        r = requests.get(\"https://www.bitmex.com/api/v1/instrument/active\")\n        for entry in r.json():\n            components = []\n            components.append(entry['rootSymbol'])\n            components.append(entry['quoteCurrency'])\n\n            if entry['expiry']:\n                components.append(entry['symbol'][-3:])\n\n            normalized = SYMBOL_SEP.join(components)\n            normalized = normalized.replace(\"XBT\", \"BTC\")\n            ret[normalized] = entry['symbol']\n            _exchange_info[BITMEX]['tick_size'][normalized] = entry['tickSize']\n\n            if entry['expiry']:\n                _exchange_info[BITMEX]['expiry'][normalized] = entry['expiry']\n\n        return ret\n    except Exception as why:\n        raise_failure_explanation('BITMEX', why, {\"\": r})\n\n\ndef deribit_symbols() -> Dict[str, str]:\n    url = r = None\n    ret = {}\n    try:\n        # TODO: get currencies from https://www.deribit.com/api/v2/public/get_currencies\n        currencies = ['BTC', 'ETH']\n        for c in currencies:\n            url = f\"https://www.deribit.com/api/v2/public/get_instruments?currency={c}&expired=false\"\n            r = requests.get(url)\n            for entry in r.json()['result']:\n                split = entry['instrument_name'].split(\"-\")\n                normalized = split[0] + SYMBOL_SEP + entry['quote_currency'] + \"-\" + '-'.join(split[1:])\n                ret[normalized] = entry['instrument_name']\n                _exchange_info[DERIBIT]['tick_size'][normalized] = entry['tick_size']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('DERIBIT', why, {url: r})\n\n\ndef kraken_future_symbols() -> Dict[str, str]:\n    r = None\n    ret = {}\n    try:\n        r = requests.get('https://futures.kraken.com/derivatives/api/v3/instruments')\n        data = r.json()['instruments']\n        for entry in data:\n            if not entry['tradeable']:\n                continue\n            normalized = entry['symbol'].upper().replace(\"_\", \"-\")\n            symbol = normalized[3:6] + SYMBOL_SEP + normalized[6:9]\n            normalized = normalized.replace(normalized[3:9], symbol)\n            normalized = normalized.replace('XBT', 'BTC')\n\n            _exchange_info[KRAKEN_FUTURES]['tick_size'][normalized] = entry['tickSize']\n            _exchange_info[KRAKEN_FUTURES]['contract_size'][normalized] = entry['contractSize']\n            _exchange_info[KRAKEN_FUTURES]['underlying'][normalized] = entry['underlying']\n            _exchange_info[KRAKEN_FUTURES]['product_type'][normalized] = _kraken_futures_product_type[normalized[:2]]\n            ret[normalized] = entry['symbol']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('KRAKEN_FUTURES', why, {\"\": r})\n\n\ndef probit_symbols() -> Dict[str, str]:\n    # doc: https://docs-en.probit.com/reference-link/market\n    r = None\n    try:\n        r = requests.get('https://api.probit.com/api/exchange/v1/market')\n        return {entry['id']: entry['id'] for entry in r.json()['data']}\n    except Exception as why:\n        raise_failure_explanation('PROBIT', why, {\"\": r})\n\n\ndef coingecko_normalize_symbol(symbol: str) -> str:\n    # keep digits, letters and dots, replace others by space\n    symbol = ''.join(c if c.isalnum() or c in ('.', '+') else ' ' for c in symbol)\n    return coingecko_normalize(symbol.upper())\n\n\ndef coingecko_normalize_name(name: str) -> str:\n    # keep digits and letters, replace others by space (except when only composed by upper case letters, digits and dots)\n    if not all(c.isupper() or c.isdigit() or c == '.' for c in name):\n        name = ''.join(c if c.isalnum() else ' ' for c in name)\n    return coingecko_normalize(name)\n\n\ndef coingecko_normalize(sym: str) -> str:\n    sym = sym.strip()\n    # do not concatenate numbers => separate them with a dot\n    sym = list(sym)\n    if len(sym) > 4:\n        for i in range(2, len(sym) - 1):\n            if sym[i] == ' ' and sym[i - 1].isdigit() and sym[i + 1].isdigit():\n                sym[i] = '.'\n    sym = ''.join(sym)\n    # concatenate space-separated words => use CamelCase to distinguish the words\n    if ' ' in sym:\n        if sum(c.islower() for c in sym):  # if there is at least one lower case letter\n            sym = ' '.join(word[0].upper() + word[1:] for word in sym.split())  # Just capitalize initial letter of each word\n        else:  # CoinGecko may provide full upper-case as for \"THE STONE COIN\"\n            sym = string.capwords(sym)  # capwords converts \"THE STONE COIN\" to \"The Stone Coin\"\n        sym = sym.replace(' ', '')  # concatenate words\n    return sym\n\n\ndef is_name_short(coin: dict) -> bool:\n    \"\"\"return True if the coin name is enough short compared to the coin symbol.\"\"\"\n    return len(coin['name']) <= max(5, len(coin['symbol']) + 1)\n\n\ndef has_many_caps(name: str) -> bool:\n    \"\"\"return True if the symbol contains enough upper case letters, False if empty.\"\"\"\n    return str and sum(c.islower() for c in name) < (len(name) / 2)\n\n\ndef coingecko_normalize_all(coin: dict):\n    SYMBOL_TO_NORMALIZED = {'miota': 'IOTA'}\n    normalized = SYMBOL_TO_NORMALIZED.get(coin['symbol'])\n    if normalized:\n        coin['ns'] = coin['nn'] = normalized\n        return normalized\n\n    # ns = normalized symbol, nn = normalized name\n    coin['ns'] = coingecko_normalize_symbol(coin['symbol'])\n\n    ID_SUFFIX = '-bitcoin-token'\n    if coin['id'][-len(ID_SUFFIX):] == ID_SUFFIX:\n        coin['nn'] = 'BTC' + coin['ns']\n        return coin['nn']\n\n    name = coin['name']\n\n    prefixes = ('The ', 'the ')\n    for p in prefixes:\n        if name[:len(p)] == p:\n            coin['reduced-name'] = True\n            name = name[len(p):]\n            break\n\n    suffixes = ('coin', 'coins', 'money', 'finance', 'protocol', 'reward', 'rewards', 'token')\n    for s in suffixes:\n        if len(name) > len(s) and name[-len(s):].lower() == s:\n            # but keep suffix when lower-case concatenated\n            if name[-len(s)].islower() and name[-len(s) - 1] != ' ':\n                continue\n            # also keep suffix to avoid confusing nam: \"Bitcoin Token\" -> \"Bitcoin\"\n            if name[:-len(s)].strip().lower() == 'bitcoin':\n                continue\n            coin['reduced-name'] = True\n            name = name[:-len(s)]\n            break\n\n    coin['nn'] = coingecko_normalize_name(name)\n\n    if len(coin['nn']) < len(coin['ns']):\n        if 'reduced-name' in coin:\n            coin['reduced-name'] = False\n            name = coin['name']\n            coin['nn'] = coingecko_normalize_name(name)\n        elif not has_many_caps(name):\n            return coin['ns']\n\n    if not coin['ns']:  # coin['symbol'] may be an emoji that is striped when normalized\n        return coin['nn']\n\n    if coin.get('reduced-name') and coin['ns'].upper() != coin['nn'].upper():\n        return coin['ns']\n\n    i = coin['nn'].find('.')  # if there is a dot in normalized name => prefer the normalized symbol\n    if i >= 0:\n        if i > 1 and coin['nn'][i - 1].isdigit() and coin['nn'][i + 1].isdigit():\n            pass  # except when the dot separates digits\n        else:\n            return coin['ns']\n\n    if is_name_short(coin) and has_many_caps(name):\n        return coin['nn']\n\n    if 1.5 * len(coin['ns']) > len(coin['nn']) and any(c.islower() for c in coin['ns']):\n        return coin['nn']\n\n    return coin['ns']\n\n\ndef coingecko_symbols() -> Dict[str, str]:\n    r = None\n    intermediate = defaultdict(list)\n    try:\n        r = requests.get('https://api.coingecko.com/api/v3/coins/list')\n        all_coins = r.json()\n        # First pass: generate & compare normalized symbol/name, and then select the most pertinent\n        for coin in all_coins:\n            normalized = coingecko_normalize_all(coin)\n            intermediate[normalized].append(coin)\n            # Above line keeps together the coins having the same normalized symbol.\n            # To reduce collision, the coin['name'] is sometimes used in lieu of the coin['symbol'].\n            # The coin['name'] is not capitalized because lower case letters may be meaningful: cETH, yUSD, DATx, zLOT\n    except Exception as why:\n        raise_failure_explanation('COINGECKO', why, {\"\": r})\n\n    final = coingecko_second_pass(intermediate)\n    return coingecko_third_pass(final)\n\n\ndef coingecko_second_pass(intermediate: Dict[str, List[dict]]) -> Dict[str, List[dict]]:\n    # Second pass: fixes most of the symbol collisions\n    final = defaultdict(list)\n    for normalized, coins in intermediate.items():\n        if len(coins) == 1:\n            final[normalized].append(coins[0])\n            continue\n        set_normalized = False\n        for i in range(len(coins)):\n            if normalized == coins[i]['nn']:\n                coin = coins.pop(i)\n                final[normalized].append(coin)\n                set_normalized = True\n                break\n        rest: List[dict] = []\n        for coin in coins:\n            if '%' in coin['name']:\n                if len(coins) == 1:\n                    n = coin['ns']\n                else:\n                    n = coingecko_normalize_name(coin['id'])\n                final[n].append(coin)\n            else:\n                rest.append(coin)\n        if not rest:\n            continue\n        if not set_normalized:\n            rest.sort(key=lambda coin: len(coin['nn']), reverse=True)  # sort by the length of the normalized name\n            coin = rest.pop(0)\n            final[normalized].append(coin)\n        for coin in rest:\n            if coin['nn'] not in intermediate:\n                n = coin['nn']\n            elif coin.get('reduced-name'):\n                n = coingecko_normalize_name(coin['name'])\n            else:\n                n = coingecko_normalize_name(coin['id'])\n            final[n].append(coin)\n    return final\n\n\ndef coingecko_third_pass(final: Dict[str, List[dict]]) -> Dict[str, str]:\n    # Third pass: fixes some remaining collisions and fills the result\n    symbols = {}\n    for normalized, coins in final.items():\n        if len(coins) == 1:\n            symbols[normalized] = coins[0]['id']\n            continue\n        set_normalized = False\n        for i in range(len(coins)):\n            if normalized == coins[i]['nn']:\n                coin = coins.pop(i)\n                symbols[normalized] = coin['id']\n                set_normalized = True\n                break\n        rest: List[dict] = []\n        for coin in coins:\n            if '%' in coin['name']:\n                if len(coins) == 1:\n                    n = coin['ns']\n                else:\n                    n = coingecko_normalize_name(coin['id'])\n                symbols[n] = coin['id']\n            else:\n                rest.append(coin)\n        if not rest:\n            continue\n        if not set_normalized:\n            rest.sort(key=lambda coin: len(coin['nn']), reverse=True)  # sort by the length of the normalized name\n            coin = rest.pop(0)\n            symbols[normalized] = coin['id']\n        for coin in rest:\n            if coin['nn'] not in final:\n                n = coin['nn']\n            elif coin.get('reduced-name'):\n                n = coingecko_normalize_name(coin['name'])\n            else:\n                n = coingecko_normalize_name(coin['id'])\n            symbols[n] = coin['id']\n    return symbols\n\n\ndef whale_alert_coins(key_id: str) -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get(f'https://api.whale-alert.io/v1/status?api_key={key_id}')\n        # Same symbols, but on different blockchains (for instance USDT), are naturally overwritten.\n        return {s.upper(): s for b in r.json()['blockchains'] for s in b['symbols'] if s}\n    except Exception as why:\n        raise_failure_explanation('WHALES_ALERT', why, {\"\": r})\n\n\n_exchange_function_map = {\n    BITFINEX: bitfinex_symbols,\n    BITFLYER: bitflyer_symbols,\n    COINBASE: coinbase_symbols,\n    GEMINI: gemini_symbols,\n    HITBTC: hitbtc_symbols,\n    POLONIEX: poloniex_symbols,\n    PROBIT: probit_symbols,\n    BITSTAMP: bitstamp_symbols,\n    KRAKEN: kraken_symbols,\n    KRAKEN + 'REST': kraken_rest_symbols,\n    BINANCE: binance_symbols,\n    BINANCE_US: binance_us_symbols,\n    BINANCE_FUTURES: binance_futures_symbols,\n    BINANCE_DELIVERY: binance_delivery_symbols,\n    BLOCKCHAIN: blockchain_symbols,\n    EXX: exx_symbols,\n    HUOBI: huobi_symbols,\n    HUOBI_DM: huobi_dm_symbols,\n    HUOBI_SWAP: huobi_swap_symbols,\n    OKCOIN: okcoin_symbols,\n    OKEX: okex_symbols,\n    BYBIT: bybit_symbols,\n    FTX: ftx_symbols,\n    FTX_US: ftx_us_symbols,\n    BITTREX: bittrex_symbols,\n    BITCOINCOM: bitcoincom_symbols,\n    BITMAX: bitmax_symbols,\n    UPBIT: upbit_symbols,\n    GATEIO: gateio_symbols,\n    BITMEX: bitmex_symbols,\n    DERIBIT: deribit_symbols,\n    KRAKEN_FUTURES: kraken_future_symbols,\n    COINGECKO: coingecko_symbols,\n    WHALE_ALERT: whale_alert_coins\n}\n",
        "source_code_len": 30534,
        "target_code": "associated with this software.\n'''\nfrom typing import Dict, Tuple\n\n\nclass _Symbols:\n    def __init__(self):\n        self.data = {}\n\n    def set(self, exchange: str, normalized: dict, exchange_info: dict):\n        self.data[exchange] = {}\n        self.data[exchange]['normalized'] = normalized\n        self.data[exchange]['info'] = exchange_info\n\n    def get(self, exchange: str) -> Tuple[Dict, Dict]:\n        return self.data[exchange]['normalized'], self.data[exchange]['info']\n\n    def populated(self, exchange: str) -> bool:\n        return exchange in self.data\n\n\nSymbols = _Symbols()\n",
        "target_code_len": 588,
        "diff_format": "@@ -5,845 +5,22 @@\n associated with this software.\n+'''\n+from typing import Dict, Tuple\n \n \n-Symbol generation code for exchanges\n-'''\n+class _Symbols:\n+    def __init__(self):\n+        self.data = {}\n \n-import logging\n-import string\n-import time\n-from collections import defaultdict\n-from typing import Dict, List, Optional, Tuple\n+    def set(self, exchange: str, normalized: dict, exchange_info: dict):\n+        self.data[exchange] = {}\n+        self.data[exchange]['normalized'] = normalized\n+        self.data[exchange]['info'] = exchange_info\n \n-import requests\n-from requests import Response\n+    def get(self, exchange: str) -> Tuple[Dict, Dict]:\n+        return self.data[exchange]['normalized'], self.data[exchange]['info']\n \n-from cryptofeed.defines import *\n+    def populated(self, exchange: str) -> bool:\n+        return exchange in self.data\n \n \n-LOG = logging.getLogger('feedhandler')\n-\n-SYMBOL_SEP = '-'\n-\n-_symbols_retrieval_cache: Dict[str, Dict[str, str]] = {}\n-_exchange_info = defaultdict(lambda: defaultdict(dict))\n-\n-\n-_kraken_futures_product_type = {\n-    'FI': 'Inverse Futures',\n-    'FV': 'Vanilla Futures',\n-    'PI': 'Perpetual Inverse Futures',\n-    'PV': 'Perpetual Vanilla Futures',\n-    'IN': 'Real Time Index',\n-    'RR': 'Reference Rate',\n-}\n-\n-\n-def raise_failure_explanation(feed_id: str, exception: BaseException, responses: Dict[str, Optional[Response]]):\n-    LOG.critical('%s: encountered %r while processing response from exchange API', feed_id, exception)\n-    if len(responses) > 1:\n-        LOG.critical('%s: content of one of the %s responses was unexpected', feed_id, len(responses))\n-    for url, r in responses.items():\n-        if url:\n-            LOG.critical('%s: requested URL: %s', feed_id, url)\n-        if r:\n-            LOG.critical('%s: unexpected response: %s', feed_id, r.text)\n-    raise ValueError(f'Cryptofeed stopped because of an unexpected response from {feed_id}') from exception\n-\n-\n-def set_symbol_separator(separator: str):\n-    global SYMBOL_SEP\n-    SYMBOL_SEP = separator\n-\n-\n-def get_symbol_separator() -> str:\n-    global SYMBOL_SEP\n-    return SYMBOL_SEP\n-\n-\n-def gen_symbols(exchange: str, key_id=None) -> Dict[str, str]:\n-    if exchange not in _symbols_retrieval_cache:\n-        LOG.info(\"%s: Getting list of symbols\", exchange)\n-        symbols = _exchange_function_map[exchange](key_id) if key_id else _exchange_function_map[exchange]()\n-        LOG.info(\"%s: %s symbols\", exchange, len(symbols))\n-\n-        # log all retrieved symbols using debug level\n-        for normalized, exch_sym in sorted(symbols.items()):\n-            LOG.debug('%s: id-from-exch -> normalized: %-35s-> %s', exchange, exch_sym, normalized)\n-\n-        _symbols_retrieval_cache[exchange] = symbols\n-    return _symbols_retrieval_cache[exchange]\n-\n-\n-def _binance_symbols(endpoint: str, exchange: str):\n-    r = None\n-    try:\n-        ret = {}\n-        r = requests.get(endpoint)\n-        for symbol in r.json()['symbols']:\n-            if symbol.get('status', 'TRADING') != \"TRADING\":\n-                continue\n-            if symbol.get('contractStatus', 'TRADING') != \"TRADING\":\n-                continue\n-            split = len(symbol['baseAsset'])\n-            normalized = symbol['symbol'][:split] + SYMBOL_SEP + symbol['symbol'][split:]\n-            ret[normalized] = symbol['symbol']\n-            _exchange_info[exchange]['tick_size'][normalized] = symbol['filters'][0]['tickSize']\n-            if \"contractType\" in symbol:\n-                _exchange_info[exchange]['contract_type'][normalized] = symbol['contractType']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation(exchange, why, {endpoint: r})\n-\n-\n-def binance_symbols() -> Dict[str, str]:\n-    return _binance_symbols('https://api.binance.com/api/v3/exchangeInfo', BINANCE)\n-\n-\n-def binance_us_symbols() -> Dict[str, str]:\n-    return _binance_symbols('https://api.binance.us/api/v3/exchangeInfo', BINANCE_US)\n-\n-\n-def binance_futures_symbols() -> Dict[str, str]:\n-    base = _binance_symbols('https://fapi.binance.com/fapi/v1/exchangeInfo', BINANCE_FUTURES)\n-    add = {}\n-    for symbol, orig in base.items():\n-        if \"_\" in orig:\n-            continue\n-        add[f\"{symbol}-PINDEX\"] = f\"p{orig}\"\n-    base.update(add)\n-    return base\n-\n-\n-def binance_delivery_symbols() -> Dict[str, str]:\n-    return _binance_symbols('https://dapi.binance.com/dapi/v1/exchangeInfo', BINANCE_DELIVERY)\n-\n-\n-def bitfinex_symbols() -> Dict[str, str]:\n-    # doc: https://docs.bitfinex.com/docs/ws-general#supported-pairs\n-    r1 = r2 = None\n-    try:\n-        r1 = requests.get('https://api.bitfinex.com/v2/tickers?symbols=ALL')\n-        r2 = requests.get('https://api-pub.bitfinex.com/v2/conf/pub:map:currency:sym')\n-        tickers: List[List[str]] = r1.json()\n-        norm: List[Tuple[str, str]] = r2.json()[0]\n-        norm: Dict[str, str] = dict(norm)\n-        for k, v in dict(norm).items():\n-            if k[-2:] == 'F0' or '-' in v:  # Do not convert BTCF0 -> BTC or PBTCETH -> PBTC-ETH\n-                del norm[k]\n-        norm['BCHN'] = 'BCH'  # Bitfinex uses BCHN, other exchanges use BCH\n-\n-        ret = {}\n-        for symbol in [t[0] for t in tickers]:\n-            if symbol[0] == 'f':\n-                normalized = norm.get(symbol[1:], symbol[1:])\n-            else:\n-                if len(symbol) == 7:\n-                    base, quote = symbol[1:4], symbol[4:]\n-                else:\n-                    base, quote = symbol[1:].split(':')\n-                    assert ':' in symbol\n-                normalized = norm.get(base, base) + SYMBOL_SEP + norm.get(quote, quote)\n-            ret[normalized.upper()] = symbol\n-        return ret\n-    except ValueError as why:\n-        raise_failure_explanation('BITFINEX', why, {\"tickers?symbols=ALL\": r1, \"pub:map:currency:sym\": r2})\n-\n-\n-def bitflyer_symbols() -> Dict[str, str]:\n-    endpoint = r = None\n-    try:\n-        ret = {}\n-        endpoints = ['https://api.bitflyer.com/v1/getmarkets/eu', 'https://api.bitflyer.com/v1/getmarkets/usa', 'https://api.bitflyer.com/v1/getmarkets']\n-        for endpoint in endpoints:\n-            r = requests.get(endpoint)\n-            for entry in r.json():\n-                normalized = entry['product_code'].replace(\"_\", SYMBOL_SEP)\n-                ret[normalized] = entry['product_code']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('BITFLYER', why, {endpoint: r})\n-\n-\n-def bybit_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.bybit.com/v2/public/symbols')\n-        ret = {}\n-        for symbol in r.json()['result']:\n-            quote = symbol['quote_currency']\n-            if not symbol['name'].endswith(quote):\n-                base, contract = symbol['name'].split(quote)\n-                normalized = f\"{base}{SYMBOL_SEP}{quote}-{contract}\"\n-            else:\n-                normalized = f\"{symbol['base_currency']}{SYMBOL_SEP}{quote}\"\n-            ret[normalized] = symbol['name']\n-            _exchange_info[BYBIT]['tick_size'][normalized] = symbol['price_filter']['tick_size']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('BYBIT', why, {\"\": r})\n-\n-\n-def _ftx_helper(endpoint: str, exchange: str):\n-    r = None\n-    try:\n-        r = requests.get(endpoint)\n-        ret = {}\n-        for data in r.json()['result']:\n-            normalized = data['name'].replace(\"/\", SYMBOL_SEP)\n-            symbol = data['name']\n-            ret[normalized] = symbol\n-            _exchange_info[exchange]['tick_size'][normalized] = data['priceIncrement']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation(exchange, why, {endpoint: r})\n-\n-\n-def ftx_symbols() -> Dict[str, str]:\n-    return _ftx_helper('https://ftx.com/api/markets', FTX)\n-\n-\n-def ftx_us_symbols() -> Dict[str, str]:\n-    return _ftx_helper('https://ftx.us/api/markets', FTX_US)\n-\n-\n-def coinbase_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.pro.coinbase.com/products')\n-        ret = {}\n-        for data in r.json():\n-            normalized = data['id'].replace(\"-\", SYMBOL_SEP)\n-            ret[normalized] = data['id']\n-            _exchange_info[COINBASE]['tick_size'][normalized] = data['quote_increment']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('COINBASE', why, {\"\": r})\n-\n-\n-def gemini_symbols(*args) -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.gemini.com/v1/symbols')\n-        ret = {}\n-        for symbol in r.json():\n-            std = f\"{symbol[:-3]}{SYMBOL_SEP}{symbol[-3:]}\"\n-            std = std.upper()\n-            ret[std] = symbol.upper()\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('GEMINI', why, {\"\": r})\n-\n-\n-def hitbtc_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        ret = {}\n-        r = requests.get('https://api.hitbtc.com/api/2/public/symbol')\n-        for symbol in r.json():\n-            split = len(symbol['baseCurrency'])\n-            normalized = symbol['id'][:split] + SYMBOL_SEP + symbol['id'][split:]\n-            ret[normalized] = symbol['id']\n-            _exchange_info[HITBTC]['tick_size'][normalized] = symbol['tickSize']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('HITBTC', why, {\"\": r})\n-\n-\n-def poloniex_id_symbol_mapping():\n-    r = None\n-    try:\n-        r = requests.get('https://poloniex.com/public?command=returnTicker')\n-        symbols = r.json()\n-        ret = {}\n-        for symbol in symbols:\n-            ret[symbols[symbol]['id']] = symbol\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('POLONIEX', why, {\"\": r})\n-\n-\n-def poloniex_symbols() -> Dict[str, str]:\n-    ret = {}\n-    for _, value in poloniex_id_symbol_mapping().items():\n-        std = value.replace(\"STR\", \"XLM\")\n-        quote, base = std.split(\"_\")\n-        ret[quote + SYMBOL_SEP + base] = value\n-    return ret\n-\n-\n-def bitstamp_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://www.bitstamp.net/api/v2/trading-pairs-info/')\n-        ret = {}\n-        for data in r.json():\n-            normalized = data['name'].replace(\"/\", SYMBOL_SEP)\n-            symbol = data['url_symbol']\n-            ret[normalized] = symbol\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('BITSTAMP', why, {\"\": r})\n-\n-\n-def kraken_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.kraken.com/0/public/AssetPairs')\n-        data = r.json()\n-        ret = {}\n-        for symbol in data['result']:\n-            if 'wsname' not in data['result'][symbol] or '.d' in symbol:\n-                # https://blog.kraken.com/post/259/introducing-the-kraken-dark-pool/\n-                # .d is for dark pool symbols\n-                continue\n-\n-            base, quote = data['result'][symbol]['wsname'].split(\"/\")\n-\n-            normalized = f\"{base}{SYMBOL_SEP}{quote}\"\n-            exch = data['result'][symbol]['wsname']\n-            normalized = normalized.replace('XBT', 'BTC')\n-            normalized = normalized.replace('XDG', 'DOG')\n-            ret[normalized] = exch\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('KRAKEN', why, {\"\": r})\n-\n-\n-def kraken_rest_symbols() -> Dict[str, str]:\n-    return {normalized: exchange.replace(\"/\", \"\") for normalized, exchange in kraken_symbols().items()}\n-\n-\n-def exx_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.exx.com/data/v1/tickers')\n-        exchange = [key.upper() for key in r.json().keys()]\n-        symbols = [key.replace(\"_\", SYMBOL_SEP) for key in exchange]\n-        return dict(zip(symbols, exchange))\n-    except Exception as why:\n-        raise_failure_explanation('EXX', why, {\"\": r})\n-\n-\n-def huobi_common_symbols(url: str):\n-    r = None\n-    try:\n-        r = requests.get(url)\n-        ret = {}\n-        for e in r.json()['data']:\n-            if e['state'] == 'offline':\n-                continue\n-            normalized = f\"{e['base-currency'].upper()}{SYMBOL_SEP}{e['quote-currency'].upper()}\"\n-            symbol = f\"{e['base-currency']}{e['quote-currency']}\"\n-            ret[normalized] = symbol\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('HUOBI', why, {url: r})\n-\n-\n-def huobi_symbols() -> Dict[str, str]:\n-    return huobi_common_symbols('https://api.huobi.pro/v1/common/symbols')\n-\n-\n-def huobi_us_symbols() -> Dict[str, str]:\n-    return huobi_common_symbols('https://api.huobi.com/v1/common/symbols')\n-\n-\n-def huobi_dm_symbols() -> Dict[str, str]:\n-    \"\"\"\n-    Mapping is, for instance: {\"BTC_CW\":\"BTC190816\"}\n-    See comments in exchange/huobi_dm.py\n-    \"\"\"\n-    mapping = {\n-        \"this_week\": \"CW\",\n-        \"next_week\": \"NW\",\n-        \"quarter\": \"CQ\",\n-        \"next_quarter\": \"NQ\"\n-    }\n-    r = None\n-    try:\n-        r = requests.get('https://www.hbdm.com/api/v1/contract_contract_info')\n-        symbols = {}\n-        for e in r.json()['data']:\n-            symbols[f\"{e['symbol']}_{mapping[e['contract_type']]}\"] = e['contract_code']\n-            _exchange_info[HUOBI_DM]['tick_size'][e['contract_code']] = e['price_tick']\n-            _exchange_info[HUOBI_DM]['short_code_mappings'][f\"{e['symbol']}_{mapping[e['contract_type']]}\"] = e['contract_code']\n-        return symbols\n-    except Exception as why:\n-        raise_failure_explanation('HUOBI_DM', why, {\"\": r})\n-\n-\n-def huobi_swap_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.hbdm.com/swap-api/v1/swap_contract_info')\n-        symbols = {}\n-        for e in r.json()['data']:\n-            symbols[e['contract_code']] = e['contract_code']\n-            _exchange_info[HUOBI_SWAP]['tick_size'][e['contract_code']] = e['price_tick']\n-        return symbols\n-    except Exception as why:\n-        raise_failure_explanation('HUOBI_SWAP', why, {\"\": r})\n-\n-\n-def okcoin_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://www.okcoin.com/api/spot/v3/instruments')\n-        ret = {}\n-        for e in r.json():\n-            ret[e['instrument_id']] = e['instrument_id']\n-            _exchange_info[OKCOIN]['tick_size'][e['instrument_id']] = e['tick_size']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('OKCOIN', why, {\"\": r})\n-\n-\n-def okex_symbols(*args) -> Dict[str, str]:\n-    urls = ['https://www.okex.com/api/spot/v3/instruments',\n-            'https://www.okex.com/api/swap/v3/instruments',\n-            'https://www.okex.com/api/futures/v3/instruments']\n-    urls = urls + okex_compute_option_urls_from_underlyings()\n-\n-    symbols: Dict[str, str] = {}\n-    for u in urls:\n-        time.sleep(0.2)\n-        symbols.update(okex_symbols_from_one_url(u))\n-\n-    for symbol in symbols:\n-        instrument_type = 'futures'\n-        dash_count = symbol.count(get_symbol_separator())\n-        if dash_count == 1:  # BTC-USDT\n-            instrument_type = 'spot'\n-        if dash_count == 4:  # BTC-USD-201225-35000-P\n-            instrument_type = 'option'\n-        if symbol[-4:] == \"SWAP\":  # BTC-USDT-SWAP\n-            instrument_type = 'swap'\n-\n-        _exchange_info[OKEX]['instrument_type'][symbol] = instrument_type\n-\n-    return symbols\n-\n-\n-def okex_compute_option_urls_from_underlyings() -> List[str]:\n-    url = 'https://www.okex.com/api/option/v3/underlying'\n-    r = None\n-    try:\n-        r = requests.get(url)\n-        return [f'https://www.okex.com/api/option/v3/instruments/{underlying}' for underlying in r.json()]\n-    except Exception as why:\n-        raise_failure_explanation('OKEX', why, {url: r})\n-\n-\n-def okex_symbols_from_one_url(url: str) -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get(url)\n-        ret = {}\n-        for e in r.json():\n-            ret[e['instrument_id']] = e['instrument_id']\n-            _exchange_info[OKEX]['tick_size'][e['instrument_id']] = e['tick_size']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('OKEX', why, {url: r})\n-\n-\n-def bittrex_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.bittrex.com/api/v1.1/public/getmarkets')\n-        r = r.json()['result']\n-        return {f\"{e['MarketCurrency']}{SYMBOL_SEP}{e['BaseCurrency']}\": e['MarketName'] for e in r if e['IsActive']}\n-    except Exception as why:\n-        raise_failure_explanation('BITTREX', why, {\"\": r})\n-\n-\n-def bitcoincom_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.exchange.bitcoin.com/api/2/public/symbol')\n-        return {f\"{data['baseCurrency']}{SYMBOL_SEP}{data['quoteCurrency'].replace('USD', 'USDT')}\": data['id'] for data in r.json()}\n-    except Exception as why:\n-        raise_failure_explanation('BITCOINCOM', why, {\"\": r})\n-\n-\n-def bitmax_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://bitmax.io/api/pro/v1/products')\n-        ret = {}\n-        for entry in r.json()['data']:\n-            # Only \"Normal\" status symbols are tradeable\n-            if entry['status'] == 'Normal':\n-                normalized = f\"{entry['baseAsset']}{SYMBOL_SEP}{entry['quoteAsset']}\"\n-                ret[normalized] = entry['symbol']\n-                _exchange_info[BITMAX]['tick_size'][normalized] = entry['tickSize']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('BITMAX', why, {\"\": r})\n-\n-\n-def upbit_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.upbit.com/v1/market/all')\n-        return {f\"{data['market'].split('-')[1]}{SYMBOL_SEP}{data['market'].split('-')[0]}\": data['market'] for data in r.json()}\n-    except Exception as why:\n-        raise_failure_explanation('UPBIT', why, {\"\": r})\n-\n-\n-def blockchain_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get(\"https://api.blockchain.com/mercury-gateway/v1/instruments\")\n-        return {data[\"symbol\"].replace(\"-\", SYMBOL_SEP): data[\"symbol\"] for data in r.json()}\n-    except Exception as why:\n-        raise_failure_explanation('BLOCKCHAIN', why, {\"\": r})\n-\n-\n-def gateio_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get(\"https://api.gateio.ws/api/v4/spot/currency_pairs\")\n-        return {data[\"id\"].replace(\"_\", SYMBOL_SEP): data['id'] for data in r.json()}\n-    except Exception as why:\n-        raise_failure_explanation('GATEIO', why, {\"\": r})\n-\n-\n-def bitmex_symbols() -> Dict[str, str]:\n-    r = None\n-    ret = {}\n-    try:\n-        r = requests.get(\"https://www.bitmex.com/api/v1/instrument/active\")\n-        for entry in r.json():\n-            components = []\n-            components.append(entry['rootSymbol'])\n-            components.append(entry['quoteCurrency'])\n-\n-            if entry['expiry']:\n-                components.append(entry['symbol'][-3:])\n-\n-            normalized = SYMBOL_SEP.join(components)\n-            normalized = normalized.replace(\"XBT\", \"BTC\")\n-            ret[normalized] = entry['symbol']\n-            _exchange_info[BITMEX]['tick_size'][normalized] = entry['tickSize']\n-\n-            if entry['expiry']:\n-                _exchange_info[BITMEX]['expiry'][normalized] = entry['expiry']\n-\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('BITMEX', why, {\"\": r})\n-\n-\n-def deribit_symbols() -> Dict[str, str]:\n-    url = r = None\n-    ret = {}\n-    try:\n-        # TODO: get currencies from https://www.deribit.com/api/v2/public/get_currencies\n-        currencies = ['BTC', 'ETH']\n-        for c in currencies:\n-            url = f\"https://www.deribit.com/api/v2/public/get_instruments?currency={c}&expired=false\"\n-            r = requests.get(url)\n-            for entry in r.json()['result']:\n-                split = entry['instrument_name'].split(\"-\")\n-                normalized = split[0] + SYMBOL_SEP + entry['quote_currency'] + \"-\" + '-'.join(split[1:])\n-                ret[normalized] = entry['instrument_name']\n-                _exchange_info[DERIBIT]['tick_size'][normalized] = entry['tick_size']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('DERIBIT', why, {url: r})\n-\n-\n-def kraken_future_symbols() -> Dict[str, str]:\n-    r = None\n-    ret = {}\n-    try:\n-        r = requests.get('https://futures.kraken.com/derivatives/api/v3/instruments')\n-        data = r.json()['instruments']\n-        for entry in data:\n-            if not entry['tradeable']:\n-                continue\n-            normalized = entry['symbol'].upper().replace(\"_\", \"-\")\n-            symbol = normalized[3:6] + SYMBOL_SEP + normalized[6:9]\n-            normalized = normalized.replace(normalized[3:9], symbol)\n-            normalized = normalized.replace('XBT', 'BTC')\n-\n-            _exchange_info[KRAKEN_FUTURES]['tick_size'][normalized] = entry['tickSize']\n-            _exchange_info[KRAKEN_FUTURES]['contract_size'][normalized] = entry['contractSize']\n-            _exchange_info[KRAKEN_FUTURES]['underlying'][normalized] = entry['underlying']\n-            _exchange_info[KRAKEN_FUTURES]['product_type'][normalized] = _kraken_futures_product_type[normalized[:2]]\n-            ret[normalized] = entry['symbol']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('KRAKEN_FUTURES', why, {\"\": r})\n-\n-\n-def probit_symbols() -> Dict[str, str]:\n-    # doc: https://docs-en.probit.com/reference-link/market\n-    r = None\n-    try:\n-        r = requests.get('https://api.probit.com/api/exchange/v1/market')\n-        return {entry['id']: entry['id'] for entry in r.json()['data']}\n-    except Exception as why:\n-        raise_failure_explanation('PROBIT', why, {\"\": r})\n-\n-\n-def coingecko_normalize_symbol(symbol: str) -> str:\n-    # keep digits, letters and dots, replace others by space\n-    symbol = ''.join(c if c.isalnum() or c in ('.', '+') else ' ' for c in symbol)\n-    return coingecko_normalize(symbol.upper())\n-\n-\n-def coingecko_normalize_name(name: str) -> str:\n-    # keep digits and letters, replace others by space (except when only composed by upper case letters, digits and dots)\n-    if not all(c.isupper() or c.isdigit() or c == '.' for c in name):\n-        name = ''.join(c if c.isalnum() else ' ' for c in name)\n-    return coingecko_normalize(name)\n-\n-\n-def coingecko_normalize(sym: str) -> str:\n-    sym = sym.strip()\n-    # do not concatenate numbers => separate them with a dot\n-    sym = list(sym)\n-    if len(sym) > 4:\n-        for i in range(2, len(sym) - 1):\n-            if sym[i] == ' ' and sym[i - 1].isdigit() and sym[i + 1].isdigit():\n-                sym[i] = '.'\n-    sym = ''.join(sym)\n-    # concatenate space-separated words => use CamelCase to distinguish the words\n-    if ' ' in sym:\n-        if sum(c.islower() for c in sym):  # if there is at least one lower case letter\n-            sym = ' '.join(word[0].upper() + word[1:] for word in sym.split())  # Just capitalize initial letter of each word\n-        else:  # CoinGecko may provide full upper-case as for \"THE STONE COIN\"\n-            sym = string.capwords(sym)  # capwords converts \"THE STONE COIN\" to \"The Stone Coin\"\n-        sym = sym.replace(' ', '')  # concatenate words\n-    return sym\n-\n-\n-def is_name_short(coin: dict) -> bool:\n-    \"\"\"return True if the coin name is enough short compared to the coin symbol.\"\"\"\n-    return len(coin['name']) <= max(5, len(coin['symbol']) + 1)\n-\n-\n-def has_many_caps(name: str) -> bool:\n-    \"\"\"return True if the symbol contains enough upper case letters, False if empty.\"\"\"\n-    return str and sum(c.islower() for c in name) < (len(name) / 2)\n-\n-\n-def coingecko_normalize_all(coin: dict):\n-    SYMBOL_TO_NORMALIZED = {'miota': 'IOTA'}\n-    normalized = SYMBOL_TO_NORMALIZED.get(coin['symbol'])\n-    if normalized:\n-        coin['ns'] = coin['nn'] = normalized\n-        return normalized\n-\n-    # ns = normalized symbol, nn = normalized name\n-    coin['ns'] = coingecko_normalize_symbol(coin['symbol'])\n-\n-    ID_SUFFIX = '-bitcoin-token'\n-    if coin['id'][-len(ID_SUFFIX):] == ID_SUFFIX:\n-        coin['nn'] = 'BTC' + coin['ns']\n-        return coin['nn']\n-\n-    name = coin['name']\n-\n-    prefixes = ('The ', 'the ')\n-    for p in prefixes:\n-        if name[:len(p)] == p:\n-            coin['reduced-name'] = True\n-            name = name[len(p):]\n-            break\n-\n-    suffixes = ('coin', 'coins', 'money', 'finance', 'protocol', 'reward', 'rewards', 'token')\n-    for s in suffixes:\n-        if len(name) > len(s) and name[-len(s):].lower() == s:\n-            # but keep suffix when lower-case concatenated\n-            if name[-len(s)].islower() and name[-len(s) - 1] != ' ':\n-                continue\n-            # also keep suffix to avoid confusing nam: \"Bitcoin Token\" -> \"Bitcoin\"\n-            if name[:-len(s)].strip().lower() == 'bitcoin':\n-                continue\n-            coin['reduced-name'] = True\n-            name = name[:-len(s)]\n-            break\n-\n-    coin['nn'] = coingecko_normalize_name(name)\n-\n-    if len(coin['nn']) < len(coin['ns']):\n-        if 'reduced-name' in coin:\n-            coin['reduced-name'] = False\n-            name = coin['name']\n-            coin['nn'] = coingecko_normalize_name(name)\n-        elif not has_many_caps(name):\n-            return coin['ns']\n-\n-    if not coin['ns']:  # coin['symbol'] may be an emoji that is striped when normalized\n-        return coin['nn']\n-\n-    if coin.get('reduced-name') and coin['ns'].upper() != coin['nn'].upper():\n-        return coin['ns']\n-\n-    i = coin['nn'].find('.')  # if there is a dot in normalized name => prefer the normalized symbol\n-    if i >= 0:\n-        if i > 1 and coin['nn'][i - 1].isdigit() and coin['nn'][i + 1].isdigit():\n-            pass  # except when the dot separates digits\n-        else:\n-            return coin['ns']\n-\n-    if is_name_short(coin) and has_many_caps(name):\n-        return coin['nn']\n-\n-    if 1.5 * len(coin['ns']) > len(coin['nn']) and any(c.islower() for c in coin['ns']):\n-        return coin['nn']\n-\n-    return coin['ns']\n-\n-\n-def coingecko_symbols() -> Dict[str, str]:\n-    r = None\n-    intermediate = defaultdict(list)\n-    try:\n-        r = requests.get('https://api.coingecko.com/api/v3/coins/list')\n-        all_coins = r.json()\n-        # First pass: generate & compare normalized symbol/name, and then select the most pertinent\n-        for coin in all_coins:\n-            normalized = coingecko_normalize_all(coin)\n-            intermediate[normalized].append(coin)\n-            # Above line keeps together the coins having the same normalized symbol.\n-            # To reduce collision, the coin['name'] is sometimes used in lieu of the coin['symbol'].\n-            # The coin['name'] is not capitalized because lower case letters may be meaningful: cETH, yUSD, DATx, zLOT\n-    except Exception as why:\n-        raise_failure_explanation('COINGECKO', why, {\"\": r})\n-\n-    final = coingecko_second_pass(intermediate)\n-    return coingecko_third_pass(final)\n-\n-\n-def coingecko_second_pass(intermediate: Dict[str, List[dict]]) -> Dict[str, List[dict]]:\n-    # Second pass: fixes most of the symbol collisions\n-    final = defaultdict(list)\n-    for normalized, coins in intermediate.items():\n-        if len(coins) == 1:\n-            final[normalized].append(coins[0])\n-            continue\n-        set_normalized = False\n-        for i in range(len(coins)):\n-            if normalized == coins[i]['nn']:\n-                coin = coins.pop(i)\n-                final[normalized].append(coin)\n-                set_normalized = True\n-                break\n-        rest: List[dict] = []\n-        for coin in coins:\n-            if '%' in coin['name']:\n-                if len(coins) == 1:\n-                    n = coin['ns']\n-                else:\n-                    n = coingecko_normalize_name(coin['id'])\n-                final[n].append(coin)\n-            else:\n-                rest.append(coin)\n-        if not rest:\n-            continue\n-        if not set_normalized:\n-            rest.sort(key=lambda coin: len(coin['nn']), reverse=True)  # sort by the length of the normalized name\n-            coin = rest.pop(0)\n-            final[normalized].append(coin)\n-        for coin in rest:\n-            if coin['nn'] not in intermediate:\n-                n = coin['nn']\n-            elif coin.get('reduced-name'):\n-                n = coingecko_normalize_name(coin['name'])\n-            else:\n-                n = coingecko_normalize_name(coin['id'])\n-            final[n].append(coin)\n-    return final\n-\n-\n-def coingecko_third_pass(final: Dict[str, List[dict]]) -> Dict[str, str]:\n-    # Third pass: fixes some remaining collisions and fills the result\n-    symbols = {}\n-    for normalized, coins in final.items():\n-        if len(coins) == 1:\n-            symbols[normalized] = coins[0]['id']\n-            continue\n-        set_normalized = False\n-        for i in range(len(coins)):\n-            if normalized == coins[i]['nn']:\n-                coin = coins.pop(i)\n-                symbols[normalized] = coin['id']\n-                set_normalized = True\n-                break\n-        rest: List[dict] = []\n-        for coin in coins:\n-            if '%' in coin['name']:\n-                if len(coins) == 1:\n-                    n = coin['ns']\n-                else:\n-                    n = coingecko_normalize_name(coin['id'])\n-                symbols[n] = coin['id']\n-            else:\n-                rest.append(coin)\n-        if not rest:\n-            continue\n-        if not set_normalized:\n-            rest.sort(key=lambda coin: len(coin['nn']), reverse=True)  # sort by the length of the normalized name\n-            coin = rest.pop(0)\n-            symbols[normalized] = coin['id']\n-        for coin in rest:\n-            if coin['nn'] not in final:\n-                n = coin['nn']\n-            elif coin.get('reduced-name'):\n-                n = coingecko_normalize_name(coin['name'])\n-            else:\n-                n = coingecko_normalize_name(coin['id'])\n-            symbols[n] = coin['id']\n-    return symbols\n-\n-\n-def whale_alert_coins(key_id: str) -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get(f'https://api.whale-alert.io/v1/status?api_key={key_id}')\n-        # Same symbols, but on different blockchains (for instance USDT), are naturally overwritten.\n-        return {s.upper(): s for b in r.json()['blockchains'] for s in b['symbols'] if s}\n-    except Exception as why:\n-        raise_failure_explanation('WHALES_ALERT', why, {\"\": r})\n-\n-\n-_exchange_function_map = {\n-    BITFINEX: bitfinex_symbols,\n-    BITFLYER: bitflyer_symbols,\n-    COINBASE: coinbase_symbols,\n-    GEMINI: gemini_symbols,\n-    HITBTC: hitbtc_symbols,\n-    POLONIEX: poloniex_symbols,\n-    PROBIT: probit_symbols,\n-    BITSTAMP: bitstamp_symbols,\n-    KRAKEN: kraken_symbols,\n-    KRAKEN + 'REST': kraken_rest_symbols,\n-    BINANCE: binance_symbols,\n-    BINANCE_US: binance_us_symbols,\n-    BINANCE_FUTURES: binance_futures_symbols,\n-    BINANCE_DELIVERY: binance_delivery_symbols,\n-    BLOCKCHAIN: blockchain_symbols,\n-    EXX: exx_symbols,\n-    HUOBI: huobi_symbols,\n-    HUOBI_DM: huobi_dm_symbols,\n-    HUOBI_SWAP: huobi_swap_symbols,\n-    OKCOIN: okcoin_symbols,\n-    OKEX: okex_symbols,\n-    BYBIT: bybit_symbols,\n-    FTX: ftx_symbols,\n-    FTX_US: ftx_us_symbols,\n-    BITTREX: bittrex_symbols,\n-    BITCOINCOM: bitcoincom_symbols,\n-    BITMAX: bitmax_symbols,\n-    UPBIT: upbit_symbols,\n-    GATEIO: gateio_symbols,\n-    BITMEX: bitmex_symbols,\n-    DERIBIT: deribit_symbols,\n-    KRAKEN_FUTURES: kraken_future_symbols,\n-    COINGECKO: coingecko_symbols,\n-    WHALE_ALERT: whale_alert_coins\n-}\n+Symbols = _Symbols()\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\n\nimport logging\nimport string\nimport time\nfrom collections import defaultdict\nfrom typing import Dict, List, Optional, Tuple\n\nimport requests\nfrom requests import Response\n\nfrom cryptofeed.defines import *\n\n\nLOG = logging.getLogger('feedhandler')\n\nSYMBOL_SEP = '-'\n\n_symbols_retrieval_cache: Dict[str, Dict[str, str]] = {}\n_exchange_info = defaultdict(lambda: defaultdict(dict))\n\n\n_kraken_futures_product_type = {\n    'FI': 'Inverse Futures',\n    'FV': 'Vanilla Futures',\n    'PI': 'Perpetual Inverse Futures',\n    'PV': 'Perpetual Vanilla Futures',\n    'IN': 'Real Time Index',\n    'RR': 'Reference Rate',\n}\n\n\ndef raise_failure_explanation(feed_id: str, exception: BaseException, responses: Dict[str, Optional[Response]]):\n    <IND>LOG.critical('%s: encountered %r while processing response from exchange API', feed_id, exception)\n    if len(responses) > 1:\n        <IND>LOG.critical('%s: content of one of the %s responses was unexpected', feed_id, len(responses))\n    <DED>for url, r in responses.items():\n        <IND>if url:\n            <IND>LOG.critical('%s: requested URL: %s', feed_id, url)\n        <DED>if r:\n            <IND>LOG.critical('%s: unexpected response: %s', feed_id, r.text)\n    <DED><DED>raise ValueError(f'Cryptofeed stopped because of an unexpected response from {feed_id}') from exception\n\n\n<DED>def set_symbol_separator(separator: str):\n    <IND>global SYMBOL_SEP\n    SYMBOL_SEP = separator\n\n\n<DED>def get_symbol_separator() -> str:\n    <IND>global SYMBOL_SEP\n    return SYMBOL_SEP\n\n\n<DED>def gen_symbols(exchange: str, key_id=None) -> Dict[str, str]:\n    <IND>if exchange not in _symbols_retrieval_cache:\n        <IND>LOG.info(\"%s: Getting list of symbols\", exchange)\n        symbols = _exchange_function_map[exchange](key_id) if key_id else _exchange_function_map[exchange]()\n        LOG.info(\"%s: %s symbols\", exchange, len(symbols))\n\n        # log all retrieved symbols using debug level\n        for normalized, exch_sym in sorted(symbols.items()):\n            <IND>LOG.debug('%s: id-from-exch -> normalized: %-35s-> %s', exchange, exch_sym, normalized)\n\n        <DED>_symbols_retrieval_cache[exchange] = symbols\n    <DED>return _symbols_retrieval_cache[exchange]\n\n\n<DED>def _binance_symbols(endpoint: str, exchange: str):\n    <IND>r = None\n    try:\n        <IND>ret = {}\n        r = requests.get(endpoint)\n        for symbol in r.json()['symbols']:\n            <IND>if symbol.get('status', 'TRADING') != \"TRADING\":\n                <IND>continue\n            <DED>if symbol.get('contractStatus', 'TRADING') != \"TRADING\":\n                <IND>continue\n            <DED>split = len(symbol['baseAsset'])\n            normalized = symbol['symbol'][:split] + SYMBOL_SEP + symbol['symbol'][split:]\n            ret[normalized] = symbol['symbol']\n            _exchange_info[exchange]['tick_size'][normalized] = symbol['filters'][0]['tickSize']\n            if \"contractType\" in symbol:\n                <IND>_exchange_info[exchange]['contract_type'][normalized] = symbol['contractType']\n        <DED><DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation(exchange, why, {endpoint: r})\n\n\n<DED><DED>def binance_symbols() -> Dict[str, str]:\n    <IND>return _binance_symbols('https://api.binance.com/api/v3/exchangeInfo', BINANCE)\n\n\n<DED>def binance_us_symbols() -> Dict[str, str]:\n    <IND>return _binance_symbols('https://api.binance.us/api/v3/exchangeInfo', BINANCE_US)\n\n\n<DED>def binance_futures_symbols() -> Dict[str, str]:\n    <IND>base = _binance_symbols('https://fapi.binance.com/fapi/v1/exchangeInfo', BINANCE_FUTURES)\n    add = {}\n    for symbol, orig in base.items():\n        <IND>if \"_\" in orig:\n            <IND>continue\n        <DED>add[f\"{symbol}-PINDEX\"] = f\"p{orig}\"\n    <DED>base.update(add)\n    return base\n\n\n<DED>def binance_delivery_symbols() -> Dict[str, str]:\n    <IND>return _binance_symbols('https://dapi.binance.com/dapi/v1/exchangeInfo', BINANCE_DELIVERY)\n\n\n<DED>def bitfinex_symbols() -> Dict[str, str]:\n    # doc: https://docs.bitfinex.com/docs/ws-general#supported-pairs\n    <IND>r1 = r2 = None\n    try:\n        <IND>r1 = requests.get('https://api.bitfinex.com/v2/tickers?symbols=ALL')\n        r2 = requests.get('https://api-pub.bitfinex.com/v2/conf/pub:map:currency:sym')\n        tickers: List[List[str]] = r1.json()\n        norm: List[Tuple[str, str]] = r2.json()[0]\n        norm: Dict[str, str] = dict(norm)\n        for k, v in dict(norm).items():\n            <IND>if k[-2:] == 'F0' or '-' in v:  # Do not convert BTCF0 -> BTC or PBTCETH -> PBTC-ETH\n                <IND>del norm[k]\n        <DED><DED>norm['BCHN'] = 'BCH'  # Bitfinex uses BCHN, other exchanges use BCH\n\n        ret = {}\n        for symbol in [t[0] for t in tickers]:\n            <IND>if symbol[0] == 'f':\n                <IND>normalized = norm.get(symbol[1:], symbol[1:])\n            <DED>else:\n                <IND>if len(symbol) == 7:\n                    <IND>base, quote = symbol[1:4], symbol[4:]\n                <DED>else:\n                    <IND>base, quote = symbol[1:].split(':')\n                    assert ':' in symbol\n                <DED>normalized = norm.get(base, base) + SYMBOL_SEP + norm.get(quote, quote)\n            <DED>ret[normalized.upper()] = symbol\n        <DED>return ret\n    <DED>except ValueError as why:\n        <IND>raise_failure_explanation('BITFINEX', why, {\"tickers?symbols=ALL\": r1, \"pub:map:currency:sym\": r2})\n\n\n<DED><DED>def bitflyer_symbols() -> Dict[str, str]:\n    <IND>endpoint = r = None\n    try:\n        <IND>ret = {}\n        endpoints = ['https://api.bitflyer.com/v1/getmarkets/eu', 'https://api.bitflyer.com/v1/getmarkets/usa', 'https://api.bitflyer.com/v1/getmarkets']\n        for endpoint in endpoints:\n            <IND>r = requests.get(endpoint)\n            for entry in r.json():\n                <IND>normalized = entry['product_code'].replace(\"_\", SYMBOL_SEP)\n                ret[normalized] = entry['product_code']\n        <DED><DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BITFLYER', why, {endpoint: r})\n\n\n<DED><DED>def bybit_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.bybit.com/v2/public/symbols')\n        ret = {}\n        for symbol in r.json()['result']:\n            <IND>quote = symbol['quote_currency']\n            if not symbol['name'].endswith(quote):\n                <IND>base, contract = symbol['name'].split(quote)\n                normalized = f\"{base}{SYMBOL_SEP}{quote}-{contract}\"\n            <DED>else:\n                <IND>normalized = f\"{symbol['base_currency']}{SYMBOL_SEP}{quote}\"\n            <DED>ret[normalized] = symbol['name']\n            _exchange_info[BYBIT]['tick_size'][normalized] = symbol['price_filter']['tick_size']\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BYBIT', why, {\"\": r})\n\n\n<DED><DED>def _ftx_helper(endpoint: str, exchange: str):\n    <IND>r = None\n    try:\n        <IND>r = requests.get(endpoint)\n        ret = {}\n        for data in r.json()['result']:\n            <IND>normalized = data['name'].replace(\"/\", SYMBOL_SEP)\n            symbol = data['name']\n            ret[normalized] = symbol\n            _exchange_info[exchange]['tick_size'][normalized] = data['priceIncrement']\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation(exchange, why, {endpoint: r})\n\n\n<DED><DED>def ftx_symbols() -> Dict[str, str]:\n    <IND>return _ftx_helper('https://ftx.com/api/markets', FTX)\n\n\n<DED>def ftx_us_symbols() -> Dict[str, str]:\n    <IND>return _ftx_helper('https://ftx.us/api/markets', FTX_US)\n\n\n<DED>def coinbase_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.pro.coinbase.com/products')\n        ret = {}\n        for data in r.json():\n            <IND>normalized = data['id'].replace(\"-\", SYMBOL_SEP)\n            ret[normalized] = data['id']\n            _exchange_info[COINBASE]['tick_size'][normalized] = data['quote_increment']\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('COINBASE', why, {\"\": r})\n\n\n<DED><DED>def gemini_symbols(*args) -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.gemini.com/v1/symbols')\n        ret = {}\n        for symbol in r.json():\n            <IND>std = f\"{symbol[:-3]}{SYMBOL_SEP}{symbol[-3:]}\"\n            std = std.upper()\n            ret[std] = symbol.upper()\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('GEMINI', why, {\"\": r})\n\n\n<DED><DED>def hitbtc_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>ret = {}\n        r = requests.get('https://api.hitbtc.com/api/2/public/symbol')\n        for symbol in r.json():\n            <IND>split = len(symbol['baseCurrency'])\n            normalized = symbol['id'][:split] + SYMBOL_SEP + symbol['id'][split:]\n            ret[normalized] = symbol['id']\n            _exchange_info[HITBTC]['tick_size'][normalized] = symbol['tickSize']\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('HITBTC', why, {\"\": r})\n\n\n<DED><DED>def poloniex_id_symbol_mapping():\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://poloniex.com/public?command=returnTicker')\n        symbols = r.json()\n        ret = {}\n        for symbol in symbols:\n            <IND>ret[symbols[symbol]['id']] = symbol\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('POLONIEX', why, {\"\": r})\n\n\n<DED><DED>def poloniex_symbols() -> Dict[str, str]:\n    <IND>ret = {}\n    for _, value in poloniex_id_symbol_mapping().items():\n        <IND>std = value.replace(\"STR\", \"XLM\")\n        quote, base = std.split(\"_\")\n        ret[quote + SYMBOL_SEP + base] = value\n    <DED>return ret\n\n\n<DED>def bitstamp_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://www.bitstamp.net/api/v2/trading-pairs-info/')\n        ret = {}\n        for data in r.json():\n            <IND>normalized = data['name'].replace(\"/\", SYMBOL_SEP)\n            symbol = data['url_symbol']\n            ret[normalized] = symbol\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BITSTAMP', why, {\"\": r})\n\n\n<DED><DED>def kraken_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.kraken.com/0/public/AssetPairs')\n        data = r.json()\n        ret = {}\n        for symbol in data['result']:\n            <IND>if 'wsname' not in data['result'][symbol] or '.d' in symbol:\n                # https://blog.kraken.com/post/259/introducing-the-kraken-dark-pool/\n                # .d is for dark pool symbols\n                <IND>continue\n\n            <DED>base, quote = data['result'][symbol]['wsname'].split(\"/\")\n\n            normalized = f\"{base}{SYMBOL_SEP}{quote}\"\n            exch = data['result'][symbol]['wsname']\n            normalized = normalized.replace('XBT', 'BTC')\n            normalized = normalized.replace('XDG', 'DOG')\n            ret[normalized] = exch\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('KRAKEN', why, {\"\": r})\n\n\n<DED><DED>def kraken_rest_symbols() -> Dict[str, str]:\n    <IND>return {normalized: exchange.replace(\"/\", \"\") for normalized, exchange in kraken_symbols().items()}\n\n\n<DED>def exx_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.exx.com/data/v1/tickers')\n        exchange = [key.upper() for key in r.json().keys()]\n        symbols = [key.replace(\"_\", SYMBOL_SEP) for key in exchange]\n        return dict(zip(symbols, exchange))\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('EXX', why, {\"\": r})\n\n\n<DED><DED>def huobi_common_symbols(url: str):\n    <IND>r = None\n    try:\n        <IND>r = requests.get(url)\n        ret = {}\n        for e in r.json()['data']:\n            <IND>if e['state'] == 'offline':\n                <IND>continue\n            <DED>normalized = f\"{e['base-currency'].upper()}{SYMBOL_SEP}{e['quote-currency'].upper()}\"\n            symbol = f\"{e['base-currency']}{e['quote-currency']}\"\n            ret[normalized] = symbol\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('HUOBI', why, {url: r})\n\n\n<DED><DED>def huobi_symbols() -> Dict[str, str]:\n    <IND>return huobi_common_symbols('https://api.huobi.pro/v1/common/symbols')\n\n\n<DED>def huobi_us_symbols() -> Dict[str, str]:\n    <IND>return huobi_common_symbols('https://api.huobi.com/v1/common/symbols')\n\n\n<DED>def huobi_dm_symbols() -> Dict[str, str]:\n    <IND>\"\"\"\n    Mapping is, for instance: {\"BTC_CW\":\"BTC190816\"}\n    See comments in exchange/huobi_dm.py\n    \"\"\"\n    mapping = {\n        \"this_week\": \"CW\",\n        \"next_week\": \"NW\",\n        \"quarter\": \"CQ\",\n        \"next_quarter\": \"NQ\"\n    }\n    r = None\n    try:\n        <IND>r = requests.get('https://www.hbdm.com/api/v1/contract_contract_info')\n        symbols = {}\n        for e in r.json()['data']:\n            <IND>symbols[f\"{e['symbol']}_{mapping[e['contract_type']]}\"] = e['contract_code']\n            _exchange_info[HUOBI_DM]['tick_size'][e['contract_code']] = e['price_tick']\n            _exchange_info[HUOBI_DM]['short_code_mappings'][f\"{e['symbol']}_{mapping[e['contract_type']]}\"] = e['contract_code']\n        <DED>return symbols\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('HUOBI_DM', why, {\"\": r})\n\n\n<DED><DED>def huobi_swap_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.hbdm.com/swap-api/v1/swap_contract_info')\n        symbols = {}\n        for e in r.json()['data']:\n            <IND>symbols[e['contract_code']] = e['contract_code']\n            _exchange_info[HUOBI_SWAP]['tick_size'][e['contract_code']] = e['price_tick']\n        <DED>return symbols\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('HUOBI_SWAP', why, {\"\": r})\n\n\n<DED><DED>def okcoin_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://www.okcoin.com/api/spot/v3/instruments')\n        ret = {}\n        for e in r.json():\n            <IND>ret[e['instrument_id']] = e['instrument_id']\n            _exchange_info[OKCOIN]['tick_size'][e['instrument_id']] = e['tick_size']\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('OKCOIN', why, {\"\": r})\n\n\n<DED><DED>def okex_symbols(*args) -> Dict[str, str]:\n    <IND>urls = ['https://www.okex.com/api/spot/v3/instruments',\n            'https://www.okex.com/api/swap/v3/instruments',\n            'https://www.okex.com/api/futures/v3/instruments']\n    urls = urls + okex_compute_option_urls_from_underlyings()\n\n    symbols: Dict[str, str] = {}\n    for u in urls:\n        <IND>time.sleep(0.2)\n        symbols.update(okex_symbols_from_one_url(u))\n\n    <DED>for symbol in symbols:\n        <IND>instrument_type = 'futures'\n        dash_count = symbol.count(get_symbol_separator())\n        if dash_count == 1:  # BTC-USDT\n            <IND>instrument_type = 'spot'\n        <DED>if dash_count == 4:  # BTC-USD-201225-35000-P\n            <IND>instrument_type = 'option'\n        <DED>if symbol[-4:] == \"SWAP\":  # BTC-USDT-SWAP\n            <IND>instrument_type = 'swap'\n\n        <DED>_exchange_info[OKEX]['instrument_type'][symbol] = instrument_type\n\n    <DED>return symbols\n\n\n<DED>def okex_compute_option_urls_from_underlyings() -> List[str]:\n    <IND>url = 'https://www.okex.com/api/option/v3/underlying'\n    r = None\n    try:\n        <IND>r = requests.get(url)\n        return [f'https://www.okex.com/api/option/v3/instruments/{underlying}' for underlying in r.json()]\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('OKEX', why, {url: r})\n\n\n<DED><DED>def okex_symbols_from_one_url(url: str) -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get(url)\n        ret = {}\n        for e in r.json():\n            <IND>ret[e['instrument_id']] = e['instrument_id']\n            _exchange_info[OKEX]['tick_size'][e['instrument_id']] = e['tick_size']\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('OKEX', why, {url: r})\n\n\n<DED><DED>def bittrex_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.bittrex.com/api/v1.1/public/getmarkets')\n        r = r.json()['result']\n        return {f\"{e['MarketCurrency']}{SYMBOL_SEP}{e['BaseCurrency']}\": e['MarketName'] for e in r if e['IsActive']}\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BITTREX', why, {\"\": r})\n\n\n<DED><DED>def bitcoincom_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.exchange.bitcoin.com/api/2/public/symbol')\n        return {f\"{data['baseCurrency']}{SYMBOL_SEP}{data['quoteCurrency'].replace('USD', 'USDT')}\": data['id'] for data in r.json()}\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BITCOINCOM', why, {\"\": r})\n\n\n<DED><DED>def bitmax_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://bitmax.io/api/pro/v1/products')\n        ret = {}\n        for entry in r.json()['data']:\n            # Only \"Normal\" status symbols are tradeable\n            <IND>if entry['status'] == 'Normal':\n                <IND>normalized = f\"{entry['baseAsset']}{SYMBOL_SEP}{entry['quoteAsset']}\"\n                ret[normalized] = entry['symbol']\n                _exchange_info[BITMAX]['tick_size'][normalized] = entry['tickSize']\n        <DED><DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BITMAX', why, {\"\": r})\n\n\n<DED><DED>def upbit_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.upbit.com/v1/market/all')\n        return {f\"{data['market'].split('-')[1]}{SYMBOL_SEP}{data['market'].split('-')[0]}\": data['market'] for data in r.json()}\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('UPBIT', why, {\"\": r})\n\n\n<DED><DED>def blockchain_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get(\"https://api.blockchain.com/mercury-gateway/v1/instruments\")\n        return {data[\"symbol\"].replace(\"-\", SYMBOL_SEP): data[\"symbol\"] for data in r.json()}\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BLOCKCHAIN', why, {\"\": r})\n\n\n<DED><DED>def gateio_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get(\"https://api.gateio.ws/api/v4/spot/currency_pairs\")\n        return {data[\"id\"].replace(\"_\", SYMBOL_SEP): data['id'] for data in r.json()}\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('GATEIO', why, {\"\": r})\n\n\n<DED><DED>def bitmex_symbols() -> Dict[str, str]:\n    <IND>r = None\n    ret = {}\n    try:\n        <IND>r = requests.get(\"https://www.bitmex.com/api/v1/instrument/active\")\n        for entry in r.json():\n            <IND>components = []\n            components.append(entry['rootSymbol'])\n            components.append(entry['quoteCurrency'])\n\n            if entry['expiry']:\n                <IND>components.append(entry['symbol'][-3:])\n\n            <DED>normalized = SYMBOL_SEP.join(components)\n            normalized = normalized.replace(\"XBT\", \"BTC\")\n            ret[normalized] = entry['symbol']\n            _exchange_info[BITMEX]['tick_size'][normalized] = entry['tickSize']\n\n            if entry['expiry']:\n                <IND>_exchange_info[BITMEX]['expiry'][normalized] = entry['expiry']\n\n        <DED><DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BITMEX', why, {\"\": r})\n\n\n<DED><DED>def deribit_symbols() -> Dict[str, str]:\n    <IND>url = r = None\n    ret = {}\n    try:\n        # TODO: get currencies from https://www.deribit.com/api/v2/public/get_currencies\n        <IND>currencies = ['BTC', 'ETH']\n        for c in currencies:\n            <IND>url = f\"https://www.deribit.com/api/v2/public/get_instruments?currency={c}&expired=false\"\n            r = requests.get(url)\n            for entry in r.json()['result']:\n                <IND>split = entry['instrument_name'].split(\"-\")\n                normalized = split[0] + SYMBOL_SEP + entry['quote_currency'] + \"-\" + '-'.join(split[1:])\n                ret[normalized] = entry['instrument_name']\n                _exchange_info[DERIBIT]['tick_size'][normalized] = entry['tick_size']\n        <DED><DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('DERIBIT', why, {url: r})\n\n\n<DED><DED>def kraken_future_symbols() -> Dict[str, str]:\n    <IND>r = None\n    ret = {}\n    try:\n        <IND>r = requests.get('https://futures.kraken.com/derivatives/api/v3/instruments')\n        data = r.json()['instruments']\n        for entry in data:\n            <IND>if not entry['tradeable']:\n                <IND>continue\n            <DED>normalized = entry['symbol'].upper().replace(\"_\", \"-\")\n            symbol = normalized[3:6] + SYMBOL_SEP + normalized[6:9]\n            normalized = normalized.replace(normalized[3:9], symbol)\n            normalized = normalized.replace('XBT', 'BTC')\n\n            _exchange_info[KRAKEN_FUTURES]['tick_size'][normalized] = entry['tickSize']\n            _exchange_info[KRAKEN_FUTURES]['contract_size'][normalized] = entry['contractSize']\n            _exchange_info[KRAKEN_FUTURES]['underlying'][normalized] = entry['underlying']\n            _exchange_info[KRAKEN_FUTURES]['product_type'][normalized] = _kraken_futures_product_type[normalized[:2]]\n            ret[normalized] = entry['symbol']\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('KRAKEN_FUTURES', why, {\"\": r})\n\n\n<DED><DED>def probit_symbols() -> Dict[str, str]:\n    # doc: https://docs-en.probit.com/reference-link/market\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.probit.com/api/exchange/v1/market')\n        return {entry['id']: entry['id'] for entry in r.json()['data']}\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('PROBIT', why, {\"\": r})\n\n\n<DED><DED>def coingecko_normalize_symbol(symbol: str) -> str:\n    # keep digits, letters and dots, replace others by space\n    <IND>symbol = ''.join(c if c.isalnum() or c in ('.', '+') else ' ' for c in symbol)\n    return coingecko_normalize(symbol.upper())\n\n\n<DED>def coingecko_normalize_name(name: str) -> str:\n    # keep digits and letters, replace others by space (except when only composed by upper case letters, digits and dots)\n    <IND>if not all(c.isupper() or c.isdigit() or c == '.' for c in name):\n        <IND>name = ''.join(c if c.isalnum() else ' ' for c in name)\n    <DED>return coingecko_normalize(name)\n\n\n<DED>def coingecko_normalize(sym: str) -> str:\n    <IND>sym = sym.strip()\n    # do not concatenate numbers => separate them with a dot\n    sym = list(sym)\n    if len(sym) > 4:\n        <IND>for i in range(2, len(sym) - 1):\n            <IND>if sym[i] == ' ' and sym[i - 1].isdigit() and sym[i + 1].isdigit():\n                <IND>sym[i] = '.'\n    <DED><DED><DED>sym = ''.join(sym)\n    # concatenate space-separated words => use CamelCase to distinguish the words\n    if ' ' in sym:\n        <IND>if sum(c.islower() for c in sym):  # if there is at least one lower case letter\n            <IND>sym = ' '.join(word[0].upper() + word[1:] for word in sym.split())  # Just capitalize initial letter of each word\n        <DED>else:  # CoinGecko may provide full upper-case as for \"THE STONE COIN\"\n            <IND>sym = string.capwords(sym)  # capwords converts \"THE STONE COIN\" to \"The Stone Coin\"\n        <DED>sym = sym.replace(' ', '')  # concatenate words\n    <DED>return sym\n\n\n<DED>def is_name_short(coin: dict) -> bool:\n    <IND>\"\"\"return True if the coin name is enough short compared to the coin symbol.\"\"\"\n    return len(coin['name']) <= max(5, len(coin['symbol']) + 1)\n\n\n<DED>def has_many_caps(name: str) -> bool:\n    <IND>\"\"\"return True if the symbol contains enough upper case letters, False if empty.\"\"\"\n    return str and sum(c.islower() for c in name) < (len(name) / 2)\n\n\n<DED>def coingecko_normalize_all(coin: dict):\n    <IND>SYMBOL_TO_NORMALIZED = {'miota': 'IOTA'}\n    normalized = SYMBOL_TO_NORMALIZED.get(coin['symbol'])\n    if normalized:\n        <IND>coin['ns'] = coin['nn'] = normalized\n        return normalized\n\n    # ns = normalized symbol, nn = normalized name\n    <DED>coin['ns'] = coingecko_normalize_symbol(coin['symbol'])\n\n    ID_SUFFIX = '-bitcoin-token'\n    if coin['id'][-len(ID_SUFFIX):] == ID_SUFFIX:\n        <IND>coin['nn'] = 'BTC' + coin['ns']\n        return coin['nn']\n\n    <DED>name = coin['name']\n\n    prefixes = ('The ', 'the ')\n    for p in prefixes:\n        <IND>if name[:len(p)] == p:\n            <IND>coin['reduced-name'] = True\n            name = name[len(p):]\n            break\n\n    <DED><DED>suffixes = ('coin', 'coins', 'money', 'finance', 'protocol', 'reward', 'rewards', 'token')\n    for s in suffixes:\n        <IND>if len(name) > len(s) and name[-len(s):].lower() == s:\n            # but keep suffix when lower-case concatenated\n            <IND>if name[-len(s)].islower() and name[-len(s) - 1] != ' ':\n                <IND>continue\n            # also keep suffix to avoid confusing nam: \"Bitcoin Token\" -> \"Bitcoin\"\n            <DED>if name[:-len(s)].strip().lower() == 'bitcoin':\n                <IND>continue\n            <DED>coin['reduced-name'] = True\n            name = name[:-len(s)]\n            break\n\n    <DED><DED>coin['nn'] = coingecko_normalize_name(name)\n\n    if len(coin['nn']) < len(coin['ns']):\n        <IND>if 'reduced-name' in coin:\n            <IND>coin['reduced-name'] = False\n            name = coin['name']\n            coin['nn'] = coingecko_normalize_name(name)\n        <DED>elif not has_many_caps(name):\n            <IND>return coin['ns']\n\n    <DED><DED>if not coin['ns']:  # coin['symbol'] may be an emoji that is striped when normalized\n        <IND>return coin['nn']\n\n    <DED>if coin.get('reduced-name') and coin['ns'].upper() != coin['nn'].upper():\n        <IND>return coin['ns']\n\n    <DED>i = coin['nn'].find('.')  # if there is a dot in normalized name => prefer the normalized symbol\n    if i >= 0:\n        <IND>if i > 1 and coin['nn'][i - 1].isdigit() and coin['nn'][i + 1].isdigit():\n            <IND>pass  # except when the dot separates digits\n        <DED>else:\n            <IND>return coin['ns']\n\n    <DED><DED>if is_name_short(coin) and has_many_caps(name):\n        <IND>return coin['nn']\n\n    <DED>if 1.5 * len(coin['ns']) > len(coin['nn']) and any(c.islower() for c in coin['ns']):\n        <IND>return coin['nn']\n\n    <DED>return coin['ns']\n\n\n<DED>def coingecko_symbols() -> Dict[str, str]:\n    <IND>r = None\n    intermediate = defaultdict(list)\n    try:\n        <IND>r = requests.get('https://api.coingecko.com/api/v3/coins/list')\n        all_coins = r.json()\n        # First pass: generate & compare normalized symbol/name, and then select the most pertinent\n        for coin in all_coins:\n            <IND>normalized = coingecko_normalize_all(coin)\n            intermediate[normalized].append(coin)\n            # Above line keeps together the coins having the same normalized symbol.\n            # To reduce collision, the coin['name'] is sometimes used in lieu of the coin['symbol'].\n            # The coin['name'] is not capitalized because lower case letters may be meaningful: cETH, yUSD, DATx, zLOT\n    <DED><DED>except Exception as why:\n        <IND>raise_failure_explanation('COINGECKO', why, {\"\": r})\n\n    <DED>final = coingecko_second_pass(intermediate)\n    return coingecko_third_pass(final)\n\n\n<DED>def coingecko_second_pass(intermediate: Dict[str, List[dict]]) -> Dict[str, List[dict]]:\n    # Second pass: fixes most of the symbol collisions\n    <IND>final = defaultdict(list)\n    for normalized, coins in intermediate.items():\n        <IND>if len(coins) == 1:\n            <IND>final[normalized].append(coins[0])\n            continue\n        <DED>set_normalized = False\n        for i in range(len(coins)):\n            <IND>if normalized == coins[i]['nn']:\n                <IND>coin = coins.pop(i)\n                final[normalized].append(coin)\n                set_normalized = True\n                break\n        <DED><DED>rest: List[dict] = []\n        for coin in coins:\n            <IND>if '%' in coin['name']:\n                <IND>if len(coins) == 1:\n                    <IND>n = coin['ns']\n                <DED>else:\n                    <IND>n = coingecko_normalize_name(coin['id'])\n                <DED>final[n].append(coin)\n            <DED>else:\n                <IND>rest.append(coin)\n        <DED><DED>if not rest:\n            <IND>continue\n        <DED>if not set_normalized:\n            <IND>rest.sort(key=lambda coin: len(coin['nn']), reverse=True)  # sort by the length of the normalized name\n            coin = rest.pop(0)\n            final[normalized].append(coin)\n        <DED>for coin in rest:\n            <IND>if coin['nn'] not in intermediate:\n                <IND>n = coin['nn']\n            <DED>elif coin.get('reduced-name'):\n                <IND>n = coingecko_normalize_name(coin['name'])\n            <DED>else:\n                <IND>n = coingecko_normalize_name(coin['id'])\n            <DED>final[n].append(coin)\n    <DED><DED>return final\n\n\n<DED>def coingecko_third_pass(final: Dict[str, List[dict]]) -> Dict[str, str]:\n    # Third pass: fixes some remaining collisions and fills the result\n    <IND>symbols = {}\n    for normalized, coins in final.items():\n        <IND>if len(coins) == 1:\n            <IND>symbols[normalized] = coins[0]['id']\n            continue\n        <DED>set_normalized = False\n        for i in range(len(coins)):\n            <IND>if normalized == coins[i]['nn']:\n                <IND>coin = coins.pop(i)\n                symbols[normalized] = coin['id']\n                set_normalized = True\n                break\n        <DED><DED>rest: List[dict] = []\n        for coin in coins:\n            <IND>if '%' in coin['name']:\n                <IND>if len(coins) == 1:\n                    <IND>n = coin['ns']\n                <DED>else:\n                    <IND>n = coingecko_normalize_name(coin['id'])\n                <DED>symbols[n] = coin['id']\n            <DED>else:\n                <IND>rest.append(coin)\n        <DED><DED>if not rest:\n            <IND>continue\n        <DED>if not set_normalized:\n            <IND>rest.sort(key=lambda coin: len(coin['nn']), reverse=True)  # sort by the length of the normalized name\n            coin = rest.pop(0)\n            symbols[normalized] = coin['id']\n        <DED>for coin in rest:\n            <IND>if coin['nn'] not in final:\n                <IND>n = coin['nn']\n            <DED>elif coin.get('reduced-name'):\n                <IND>n = coingecko_normalize_name(coin['name'])\n            <DED>else:\n                <IND>n = coingecko_normalize_name(coin['id'])\n            <DED>symbols[n] = coin['id']\n    <DED><DED>return symbols\n\n\n<DED>def whale_alert_coins(key_id: str) -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get(f'https://api.whale-alert.io/v1/status?api_key={key_id}')\n        # Same symbols, but on different blockchains (for instance USDT), are naturally overwritten.\n        return {s.upper(): s for b in r.json()['blockchains'] for s in b['symbols'] if s}\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('WHALES_ALERT', why, {\"\": r})\n\n\n<DED><DED>_exchange_function_map = {\n    BITFINEX: bitfinex_symbols,\n    BITFLYER: bitflyer_symbols,\n    COINBASE: coinbase_symbols,\n    GEMINI: gemini_symbols,\n    HITBTC: hitbtc_symbols,\n    POLONIEX: poloniex_symbols,\n    PROBIT: probit_symbols,\n    BITSTAMP: bitstamp_symbols,\n    KRAKEN: kraken_symbols,\n    KRAKEN + 'REST': kraken_rest_symbols,\n    BINANCE: binance_symbols,\n    BINANCE_US: binance_us_symbols,\n    BINANCE_FUTURES: binance_futures_symbols,\n    BINANCE_DELIVERY: binance_delivery_symbols,\n    BLOCKCHAIN: blockchain_symbols,\n    EXX: exx_symbols,\n    HUOBI: huobi_symbols,\n    HUOBI_DM: huobi_dm_symbols,\n    HUOBI_SWAP: huobi_swap_symbols,\n    OKCOIN: okcoin_symbols,\n    OKEX: okex_symbols,\n    BYBIT: bybit_symbols,\n    FTX: ftx_symbols,\n    FTX_US: ftx_us_symbols,\n    BITTREX: bittrex_symbols,\n    BITCOINCOM: bitcoincom_symbols,\n    BITMAX: bitmax_symbols,\n    UPBIT: upbit_symbols,\n    GATEIO: gateio_symbols,\n    BITMEX: bitmex_symbols,\n    DERIBIT: deribit_symbols,\n    KRAKEN_FUTURES: kraken_future_symbols,\n    COINGECKO: coingecko_symbols,\n    WHALE_ALERT: whale_alert_coins\n}\n",
        "target_code_with_indent": "\nfrom typing import Dict, Tuple\n\n\nclass _Symbols:\n    <IND>def __init__(self):\n        <IND>self.data = {}\n\n    <DED>def set(self, exchange: str, normalized: dict, exchange_info: dict):\n        <IND>self.data[exchange] = {}\n        self.data[exchange]['normalized'] = normalized\n        self.data[exchange]['info'] = exchange_info\n\n    <DED>def get(self, exchange: str) -> Tuple[Dict, Dict]:\n        <IND>return self.data[exchange]['normalized'], self.data[exchange]['info']\n\n    <DED>def populated(self, exchange: str) -> bool:\n        <IND>return exchange in self.data\n\n\n<DED><DED>Symbols = _Symbols()\n"
      }
    ]
  },
  {
    "project": "bmoscon/cryptofeed",
    "commit": "3525dc8ce4d7836a9abaaa5662e58e5e27969a77",
    "filename": "cryptofeed/symbols.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/bmoscon-cryptofeed/cryptofeed/symbols.py",
    "file_hunks_size": 1,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "cryptofeed/symbols.py:811:8 Incompatible return type [7]: Expected `Dict[str, str]` but got implicit return value of `None`.",
    "message": " Expected `Dict[str, str]` but got implicit return value of `None`.",
    "rule_id": "Incompatible return type [7]",
    "warning_line_no": 811,
    "warning_line": "        raise_failure_explanation('WHALES_ALERT', why, {\"\": r})",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "associated with this software.\n\n\nSymbol generation code for exchanges\n'''\n\nimport logging\nimport string\nimport time\nfrom collections import defaultdict\nfrom typing import Dict, List, Optional, Tuple\n\nimport requests\nfrom requests import Response\n\nfrom cryptofeed.defines import *\n\n\nLOG = logging.getLogger('feedhandler')\n\nSYMBOL_SEP = '-'\n\n_symbols_retrieval_cache: Dict[str, Dict[str, str]] = {}\n_exchange_info = defaultdict(lambda: defaultdict(dict))\n\n\n_kraken_futures_product_type = {\n    'FI': 'Inverse Futures',\n    'FV': 'Vanilla Futures',\n    'PI': 'Perpetual Inverse Futures',\n    'PV': 'Perpetual Vanilla Futures',\n    'IN': 'Real Time Index',\n    'RR': 'Reference Rate',\n}\n\n\ndef raise_failure_explanation(feed_id: str, exception: BaseException, responses: Dict[str, Optional[Response]]):\n    LOG.critical('%s: encountered %r while processing response from exchange API', feed_id, exception)\n    if len(responses) > 1:\n        LOG.critical('%s: content of one of the %s responses was unexpected', feed_id, len(responses))\n    for url, r in responses.items():\n        if url:\n            LOG.critical('%s: requested URL: %s', feed_id, url)\n        if r:\n            LOG.critical('%s: unexpected response: %s', feed_id, r.text)\n    raise ValueError(f'Cryptofeed stopped because of an unexpected response from {feed_id}') from exception\n\n\ndef set_symbol_separator(separator: str):\n    global SYMBOL_SEP\n    SYMBOL_SEP = separator\n\n\ndef get_symbol_separator() -> str:\n    global SYMBOL_SEP\n    return SYMBOL_SEP\n\n\ndef gen_symbols(exchange: str, key_id=None) -> Dict[str, str]:\n    if exchange not in _symbols_retrieval_cache:\n        LOG.info(\"%s: Getting list of symbols\", exchange)\n        symbols = _exchange_function_map[exchange](key_id) if key_id else _exchange_function_map[exchange]()\n        LOG.info(\"%s: %s symbols\", exchange, len(symbols))\n\n        # log all retrieved symbols using debug level\n        for normalized, exch_sym in sorted(symbols.items()):\n            LOG.debug('%s: id-from-exch -> normalized: %-35s-> %s', exchange, exch_sym, normalized)\n\n        _symbols_retrieval_cache[exchange] = symbols\n    return _symbols_retrieval_cache[exchange]\n\n\ndef _binance_symbols(endpoint: str, exchange: str):\n    r = None\n    try:\n        ret = {}\n        r = requests.get(endpoint)\n        for symbol in r.json()['symbols']:\n            if symbol.get('status', 'TRADING') != \"TRADING\":\n                continue\n            if symbol.get('contractStatus', 'TRADING') != \"TRADING\":\n                continue\n            split = len(symbol['baseAsset'])\n            normalized = symbol['symbol'][:split] + SYMBOL_SEP + symbol['symbol'][split:]\n            ret[normalized] = symbol['symbol']\n            _exchange_info[exchange]['tick_size'][normalized] = symbol['filters'][0]['tickSize']\n            if \"contractType\" in symbol:\n                _exchange_info[exchange]['contract_type'][normalized] = symbol['contractType']\n        return ret\n    except Exception as why:\n        raise_failure_explanation(exchange, why, {endpoint: r})\n\n\ndef binance_symbols() -> Dict[str, str]:\n    return _binance_symbols('https://api.binance.com/api/v3/exchangeInfo', BINANCE)\n\n\ndef binance_us_symbols() -> Dict[str, str]:\n    return _binance_symbols('https://api.binance.us/api/v3/exchangeInfo', BINANCE_US)\n\n\ndef binance_futures_symbols() -> Dict[str, str]:\n    base = _binance_symbols('https://fapi.binance.com/fapi/v1/exchangeInfo', BINANCE_FUTURES)\n    add = {}\n    for symbol, orig in base.items():\n        if \"_\" in orig:\n            continue\n        add[f\"{symbol}-PINDEX\"] = f\"p{orig}\"\n    base.update(add)\n    return base\n\n\ndef binance_delivery_symbols() -> Dict[str, str]:\n    return _binance_symbols('https://dapi.binance.com/dapi/v1/exchangeInfo', BINANCE_DELIVERY)\n\n\ndef bitfinex_symbols() -> Dict[str, str]:\n    # doc: https://docs.bitfinex.com/docs/ws-general#supported-pairs\n    r1 = r2 = None\n    try:\n        r1 = requests.get('https://api.bitfinex.com/v2/tickers?symbols=ALL')\n        r2 = requests.get('https://api-pub.bitfinex.com/v2/conf/pub:map:currency:sym')\n        tickers: List[List[str]] = r1.json()\n        norm: List[Tuple[str, str]] = r2.json()[0]\n        norm: Dict[str, str] = dict(norm)\n        for k, v in dict(norm).items():\n            if k[-2:] == 'F0' or '-' in v:  # Do not convert BTCF0 -> BTC or PBTCETH -> PBTC-ETH\n                del norm[k]\n        norm['BCHN'] = 'BCH'  # Bitfinex uses BCHN, other exchanges use BCH\n\n        ret = {}\n        for symbol in [t[0] for t in tickers]:\n            if symbol[0] == 'f':\n                normalized = norm.get(symbol[1:], symbol[1:])\n            else:\n                if len(symbol) == 7:\n                    base, quote = symbol[1:4], symbol[4:]\n                else:\n                    base, quote = symbol[1:].split(':')\n                    assert ':' in symbol\n                normalized = norm.get(base, base) + SYMBOL_SEP + norm.get(quote, quote)\n            ret[normalized.upper()] = symbol\n        return ret\n    except ValueError as why:\n        raise_failure_explanation('BITFINEX', why, {\"tickers?symbols=ALL\": r1, \"pub:map:currency:sym\": r2})\n\n\ndef bitflyer_symbols() -> Dict[str, str]:\n    endpoint = r = None\n    try:\n        ret = {}\n        endpoints = ['https://api.bitflyer.com/v1/getmarkets/eu', 'https://api.bitflyer.com/v1/getmarkets/usa', 'https://api.bitflyer.com/v1/getmarkets']\n        for endpoint in endpoints:\n            r = requests.get(endpoint)\n            for entry in r.json():\n                normalized = entry['product_code'].replace(\"_\", SYMBOL_SEP)\n                ret[normalized] = entry['product_code']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('BITFLYER', why, {endpoint: r})\n\n\ndef bybit_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.bybit.com/v2/public/symbols')\n        ret = {}\n        for symbol in r.json()['result']:\n            quote = symbol['quote_currency']\n            if not symbol['name'].endswith(quote):\n                base, contract = symbol['name'].split(quote)\n                normalized = f\"{base}{SYMBOL_SEP}{quote}-{contract}\"\n            else:\n                normalized = f\"{symbol['base_currency']}{SYMBOL_SEP}{quote}\"\n            ret[normalized] = symbol['name']\n            _exchange_info[BYBIT]['tick_size'][normalized] = symbol['price_filter']['tick_size']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('BYBIT', why, {\"\": r})\n\n\ndef _ftx_helper(endpoint: str, exchange: str):\n    r = None\n    try:\n        r = requests.get(endpoint)\n        ret = {}\n        for data in r.json()['result']:\n            normalized = data['name'].replace(\"/\", SYMBOL_SEP)\n            symbol = data['name']\n            ret[normalized] = symbol\n            _exchange_info[exchange]['tick_size'][normalized] = data['priceIncrement']\n        return ret\n    except Exception as why:\n        raise_failure_explanation(exchange, why, {endpoint: r})\n\n\ndef ftx_symbols() -> Dict[str, str]:\n    return _ftx_helper('https://ftx.com/api/markets', FTX)\n\n\ndef ftx_us_symbols() -> Dict[str, str]:\n    return _ftx_helper('https://ftx.us/api/markets', FTX_US)\n\n\ndef coinbase_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.pro.coinbase.com/products')\n        ret = {}\n        for data in r.json():\n            normalized = data['id'].replace(\"-\", SYMBOL_SEP)\n            ret[normalized] = data['id']\n            _exchange_info[COINBASE]['tick_size'][normalized] = data['quote_increment']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('COINBASE', why, {\"\": r})\n\n\ndef gemini_symbols(*args) -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.gemini.com/v1/symbols')\n        ret = {}\n        for symbol in r.json():\n            std = f\"{symbol[:-3]}{SYMBOL_SEP}{symbol[-3:]}\"\n            std = std.upper()\n            ret[std] = symbol.upper()\n        return ret\n    except Exception as why:\n        raise_failure_explanation('GEMINI', why, {\"\": r})\n\n\ndef hitbtc_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        ret = {}\n        r = requests.get('https://api.hitbtc.com/api/2/public/symbol')\n        for symbol in r.json():\n            split = len(symbol['baseCurrency'])\n            normalized = symbol['id'][:split] + SYMBOL_SEP + symbol['id'][split:]\n            ret[normalized] = symbol['id']\n            _exchange_info[HITBTC]['tick_size'][normalized] = symbol['tickSize']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('HITBTC', why, {\"\": r})\n\n\ndef poloniex_id_symbol_mapping():\n    r = None\n    try:\n        r = requests.get('https://poloniex.com/public?command=returnTicker')\n        symbols = r.json()\n        ret = {}\n        for symbol in symbols:\n            ret[symbols[symbol]['id']] = symbol\n        return ret\n    except Exception as why:\n        raise_failure_explanation('POLONIEX', why, {\"\": r})\n\n\ndef poloniex_symbols() -> Dict[str, str]:\n    ret = {}\n    for _, value in poloniex_id_symbol_mapping().items():\n        std = value.replace(\"STR\", \"XLM\")\n        quote, base = std.split(\"_\")\n        ret[quote + SYMBOL_SEP + base] = value\n    return ret\n\n\ndef bitstamp_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://www.bitstamp.net/api/v2/trading-pairs-info/')\n        ret = {}\n        for data in r.json():\n            normalized = data['name'].replace(\"/\", SYMBOL_SEP)\n            symbol = data['url_symbol']\n            ret[normalized] = symbol\n        return ret\n    except Exception as why:\n        raise_failure_explanation('BITSTAMP', why, {\"\": r})\n\n\ndef kraken_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.kraken.com/0/public/AssetPairs')\n        data = r.json()\n        ret = {}\n        for symbol in data['result']:\n            if 'wsname' not in data['result'][symbol] or '.d' in symbol:\n                # https://blog.kraken.com/post/259/introducing-the-kraken-dark-pool/\n                # .d is for dark pool symbols\n                continue\n\n            base, quote = data['result'][symbol]['wsname'].split(\"/\")\n\n            normalized = f\"{base}{SYMBOL_SEP}{quote}\"\n            exch = data['result'][symbol]['wsname']\n            normalized = normalized.replace('XBT', 'BTC')\n            normalized = normalized.replace('XDG', 'DOG')\n            ret[normalized] = exch\n        return ret\n    except Exception as why:\n        raise_failure_explanation('KRAKEN', why, {\"\": r})\n\n\ndef kraken_rest_symbols() -> Dict[str, str]:\n    return {normalized: exchange.replace(\"/\", \"\") for normalized, exchange in kraken_symbols().items()}\n\n\ndef exx_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.exx.com/data/v1/tickers')\n        exchange = [key.upper() for key in r.json().keys()]\n        symbols = [key.replace(\"_\", SYMBOL_SEP) for key in exchange]\n        return dict(zip(symbols, exchange))\n    except Exception as why:\n        raise_failure_explanation('EXX', why, {\"\": r})\n\n\ndef huobi_common_symbols(url: str):\n    r = None\n    try:\n        r = requests.get(url)\n        ret = {}\n        for e in r.json()['data']:\n            if e['state'] == 'offline':\n                continue\n            normalized = f\"{e['base-currency'].upper()}{SYMBOL_SEP}{e['quote-currency'].upper()}\"\n            symbol = f\"{e['base-currency']}{e['quote-currency']}\"\n            ret[normalized] = symbol\n        return ret\n    except Exception as why:\n        raise_failure_explanation('HUOBI', why, {url: r})\n\n\ndef huobi_symbols() -> Dict[str, str]:\n    return huobi_common_symbols('https://api.huobi.pro/v1/common/symbols')\n\n\ndef huobi_us_symbols() -> Dict[str, str]:\n    return huobi_common_symbols('https://api.huobi.com/v1/common/symbols')\n\n\ndef huobi_dm_symbols() -> Dict[str, str]:\n    \"\"\"\n    Mapping is, for instance: {\"BTC_CW\":\"BTC190816\"}\n    See comments in exchange/huobi_dm.py\n    \"\"\"\n    mapping = {\n        \"this_week\": \"CW\",\n        \"next_week\": \"NW\",\n        \"quarter\": \"CQ\",\n        \"next_quarter\": \"NQ\"\n    }\n    r = None\n    try:\n        r = requests.get('https://www.hbdm.com/api/v1/contract_contract_info')\n        symbols = {}\n        for e in r.json()['data']:\n            symbols[f\"{e['symbol']}_{mapping[e['contract_type']]}\"] = e['contract_code']\n            _exchange_info[HUOBI_DM]['tick_size'][e['contract_code']] = e['price_tick']\n            _exchange_info[HUOBI_DM]['short_code_mappings'][f\"{e['symbol']}_{mapping[e['contract_type']]}\"] = e['contract_code']\n        return symbols\n    except Exception as why:\n        raise_failure_explanation('HUOBI_DM', why, {\"\": r})\n\n\ndef huobi_swap_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.hbdm.com/swap-api/v1/swap_contract_info')\n        symbols = {}\n        for e in r.json()['data']:\n            symbols[e['contract_code']] = e['contract_code']\n            _exchange_info[HUOBI_SWAP]['tick_size'][e['contract_code']] = e['price_tick']\n        return symbols\n    except Exception as why:\n        raise_failure_explanation('HUOBI_SWAP', why, {\"\": r})\n\n\ndef okcoin_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://www.okcoin.com/api/spot/v3/instruments')\n        ret = {}\n        for e in r.json():\n            ret[e['instrument_id']] = e['instrument_id']\n            _exchange_info[OKCOIN]['tick_size'][e['instrument_id']] = e['tick_size']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('OKCOIN', why, {\"\": r})\n\n\ndef okex_symbols(*args) -> Dict[str, str]:\n    urls = ['https://www.okex.com/api/spot/v3/instruments',\n            'https://www.okex.com/api/swap/v3/instruments',\n            'https://www.okex.com/api/futures/v3/instruments']\n    urls = urls + okex_compute_option_urls_from_underlyings()\n\n    symbols: Dict[str, str] = {}\n    for u in urls:\n        time.sleep(0.2)\n        symbols.update(okex_symbols_from_one_url(u))\n\n    for symbol in symbols:\n        instrument_type = 'futures'\n        dash_count = symbol.count(get_symbol_separator())\n        if dash_count == 1:  # BTC-USDT\n            instrument_type = 'spot'\n        if dash_count == 4:  # BTC-USD-201225-35000-P\n            instrument_type = 'option'\n        if symbol[-4:] == \"SWAP\":  # BTC-USDT-SWAP\n            instrument_type = 'swap'\n\n        _exchange_info[OKEX]['instrument_type'][symbol] = instrument_type\n\n    return symbols\n\n\ndef okex_compute_option_urls_from_underlyings() -> List[str]:\n    url = 'https://www.okex.com/api/option/v3/underlying'\n    r = None\n    try:\n        r = requests.get(url)\n        return [f'https://www.okex.com/api/option/v3/instruments/{underlying}' for underlying in r.json()]\n    except Exception as why:\n        raise_failure_explanation('OKEX', why, {url: r})\n\n\ndef okex_symbols_from_one_url(url: str) -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get(url)\n        ret = {}\n        for e in r.json():\n            ret[e['instrument_id']] = e['instrument_id']\n            _exchange_info[OKEX]['tick_size'][e['instrument_id']] = e['tick_size']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('OKEX', why, {url: r})\n\n\ndef bittrex_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.bittrex.com/api/v1.1/public/getmarkets')\n        r = r.json()['result']\n        return {f\"{e['MarketCurrency']}{SYMBOL_SEP}{e['BaseCurrency']}\": e['MarketName'] for e in r if e['IsActive']}\n    except Exception as why:\n        raise_failure_explanation('BITTREX', why, {\"\": r})\n\n\ndef bitcoincom_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.exchange.bitcoin.com/api/2/public/symbol')\n        return {f\"{data['baseCurrency']}{SYMBOL_SEP}{data['quoteCurrency'].replace('USD', 'USDT')}\": data['id'] for data in r.json()}\n    except Exception as why:\n        raise_failure_explanation('BITCOINCOM', why, {\"\": r})\n\n\ndef bitmax_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://bitmax.io/api/pro/v1/products')\n        ret = {}\n        for entry in r.json()['data']:\n            # Only \"Normal\" status symbols are tradeable\n            if entry['status'] == 'Normal':\n                normalized = f\"{entry['baseAsset']}{SYMBOL_SEP}{entry['quoteAsset']}\"\n                ret[normalized] = entry['symbol']\n                _exchange_info[BITMAX]['tick_size'][normalized] = entry['tickSize']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('BITMAX', why, {\"\": r})\n\n\ndef upbit_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get('https://api.upbit.com/v1/market/all')\n        return {f\"{data['market'].split('-')[1]}{SYMBOL_SEP}{data['market'].split('-')[0]}\": data['market'] for data in r.json()}\n    except Exception as why:\n        raise_failure_explanation('UPBIT', why, {\"\": r})\n\n\ndef blockchain_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get(\"https://api.blockchain.com/mercury-gateway/v1/instruments\")\n        return {data[\"symbol\"].replace(\"-\", SYMBOL_SEP): data[\"symbol\"] for data in r.json()}\n    except Exception as why:\n        raise_failure_explanation('BLOCKCHAIN', why, {\"\": r})\n\n\ndef gateio_symbols() -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get(\"https://api.gateio.ws/api/v4/spot/currency_pairs\")\n        return {data[\"id\"].replace(\"_\", SYMBOL_SEP): data['id'] for data in r.json()}\n    except Exception as why:\n        raise_failure_explanation('GATEIO', why, {\"\": r})\n\n\ndef bitmex_symbols() -> Dict[str, str]:\n    r = None\n    ret = {}\n    try:\n        r = requests.get(\"https://www.bitmex.com/api/v1/instrument/active\")\n        for entry in r.json():\n            components = []\n            components.append(entry['rootSymbol'])\n            components.append(entry['quoteCurrency'])\n\n            if entry['expiry']:\n                components.append(entry['symbol'][-3:])\n\n            normalized = SYMBOL_SEP.join(components)\n            normalized = normalized.replace(\"XBT\", \"BTC\")\n            ret[normalized] = entry['symbol']\n            _exchange_info[BITMEX]['tick_size'][normalized] = entry['tickSize']\n\n            if entry['expiry']:\n                _exchange_info[BITMEX]['expiry'][normalized] = entry['expiry']\n\n        return ret\n    except Exception as why:\n        raise_failure_explanation('BITMEX', why, {\"\": r})\n\n\ndef deribit_symbols() -> Dict[str, str]:\n    url = r = None\n    ret = {}\n    try:\n        # TODO: get currencies from https://www.deribit.com/api/v2/public/get_currencies\n        currencies = ['BTC', 'ETH']\n        for c in currencies:\n            url = f\"https://www.deribit.com/api/v2/public/get_instruments?currency={c}&expired=false\"\n            r = requests.get(url)\n            for entry in r.json()['result']:\n                split = entry['instrument_name'].split(\"-\")\n                normalized = split[0] + SYMBOL_SEP + entry['quote_currency'] + \"-\" + '-'.join(split[1:])\n                ret[normalized] = entry['instrument_name']\n                _exchange_info[DERIBIT]['tick_size'][normalized] = entry['tick_size']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('DERIBIT', why, {url: r})\n\n\ndef kraken_future_symbols() -> Dict[str, str]:\n    r = None\n    ret = {}\n    try:\n        r = requests.get('https://futures.kraken.com/derivatives/api/v3/instruments')\n        data = r.json()['instruments']\n        for entry in data:\n            if not entry['tradeable']:\n                continue\n            normalized = entry['symbol'].upper().replace(\"_\", \"-\")\n            symbol = normalized[3:6] + SYMBOL_SEP + normalized[6:9]\n            normalized = normalized.replace(normalized[3:9], symbol)\n            normalized = normalized.replace('XBT', 'BTC')\n\n            _exchange_info[KRAKEN_FUTURES]['tick_size'][normalized] = entry['tickSize']\n            _exchange_info[KRAKEN_FUTURES]['contract_size'][normalized] = entry['contractSize']\n            _exchange_info[KRAKEN_FUTURES]['underlying'][normalized] = entry['underlying']\n            _exchange_info[KRAKEN_FUTURES]['product_type'][normalized] = _kraken_futures_product_type[normalized[:2]]\n            ret[normalized] = entry['symbol']\n        return ret\n    except Exception as why:\n        raise_failure_explanation('KRAKEN_FUTURES', why, {\"\": r})\n\n\ndef probit_symbols() -> Dict[str, str]:\n    # doc: https://docs-en.probit.com/reference-link/market\n    r = None\n    try:\n        r = requests.get('https://api.probit.com/api/exchange/v1/market')\n        return {entry['id']: entry['id'] for entry in r.json()['data']}\n    except Exception as why:\n        raise_failure_explanation('PROBIT', why, {\"\": r})\n\n\ndef coingecko_normalize_symbol(symbol: str) -> str:\n    # keep digits, letters and dots, replace others by space\n    symbol = ''.join(c if c.isalnum() or c in ('.', '+') else ' ' for c in symbol)\n    return coingecko_normalize(symbol.upper())\n\n\ndef coingecko_normalize_name(name: str) -> str:\n    # keep digits and letters, replace others by space (except when only composed by upper case letters, digits and dots)\n    if not all(c.isupper() or c.isdigit() or c == '.' for c in name):\n        name = ''.join(c if c.isalnum() else ' ' for c in name)\n    return coingecko_normalize(name)\n\n\ndef coingecko_normalize(sym: str) -> str:\n    sym = sym.strip()\n    # do not concatenate numbers => separate them with a dot\n    sym = list(sym)\n    if len(sym) > 4:\n        for i in range(2, len(sym) - 1):\n            if sym[i] == ' ' and sym[i - 1].isdigit() and sym[i + 1].isdigit():\n                sym[i] = '.'\n    sym = ''.join(sym)\n    # concatenate space-separated words => use CamelCase to distinguish the words\n    if ' ' in sym:\n        if sum(c.islower() for c in sym):  # if there is at least one lower case letter\n            sym = ' '.join(word[0].upper() + word[1:] for word in sym.split())  # Just capitalize initial letter of each word\n        else:  # CoinGecko may provide full upper-case as for \"THE STONE COIN\"\n            sym = string.capwords(sym)  # capwords converts \"THE STONE COIN\" to \"The Stone Coin\"\n        sym = sym.replace(' ', '')  # concatenate words\n    return sym\n\n\ndef is_name_short(coin: dict) -> bool:\n    \"\"\"return True if the coin name is enough short compared to the coin symbol.\"\"\"\n    return len(coin['name']) <= max(5, len(coin['symbol']) + 1)\n\n\ndef has_many_caps(name: str) -> bool:\n    \"\"\"return True if the symbol contains enough upper case letters, False if empty.\"\"\"\n    return str and sum(c.islower() for c in name) < (len(name) / 2)\n\n\ndef coingecko_normalize_all(coin: dict):\n    SYMBOL_TO_NORMALIZED = {'miota': 'IOTA'}\n    normalized = SYMBOL_TO_NORMALIZED.get(coin['symbol'])\n    if normalized:\n        coin['ns'] = coin['nn'] = normalized\n        return normalized\n\n    # ns = normalized symbol, nn = normalized name\n    coin['ns'] = coingecko_normalize_symbol(coin['symbol'])\n\n    ID_SUFFIX = '-bitcoin-token'\n    if coin['id'][-len(ID_SUFFIX):] == ID_SUFFIX:\n        coin['nn'] = 'BTC' + coin['ns']\n        return coin['nn']\n\n    name = coin['name']\n\n    prefixes = ('The ', 'the ')\n    for p in prefixes:\n        if name[:len(p)] == p:\n            coin['reduced-name'] = True\n            name = name[len(p):]\n            break\n\n    suffixes = ('coin', 'coins', 'money', 'finance', 'protocol', 'reward', 'rewards', 'token')\n    for s in suffixes:\n        if len(name) > len(s) and name[-len(s):].lower() == s:\n            # but keep suffix when lower-case concatenated\n            if name[-len(s)].islower() and name[-len(s) - 1] != ' ':\n                continue\n            # also keep suffix to avoid confusing nam: \"Bitcoin Token\" -> \"Bitcoin\"\n            if name[:-len(s)].strip().lower() == 'bitcoin':\n                continue\n            coin['reduced-name'] = True\n            name = name[:-len(s)]\n            break\n\n    coin['nn'] = coingecko_normalize_name(name)\n\n    if len(coin['nn']) < len(coin['ns']):\n        if 'reduced-name' in coin:\n            coin['reduced-name'] = False\n            name = coin['name']\n            coin['nn'] = coingecko_normalize_name(name)\n        elif not has_many_caps(name):\n            return coin['ns']\n\n    if not coin['ns']:  # coin['symbol'] may be an emoji that is striped when normalized\n        return coin['nn']\n\n    if coin.get('reduced-name') and coin['ns'].upper() != coin['nn'].upper():\n        return coin['ns']\n\n    i = coin['nn'].find('.')  # if there is a dot in normalized name => prefer the normalized symbol\n    if i >= 0:\n        if i > 1 and coin['nn'][i - 1].isdigit() and coin['nn'][i + 1].isdigit():\n            pass  # except when the dot separates digits\n        else:\n            return coin['ns']\n\n    if is_name_short(coin) and has_many_caps(name):\n        return coin['nn']\n\n    if 1.5 * len(coin['ns']) > len(coin['nn']) and any(c.islower() for c in coin['ns']):\n        return coin['nn']\n\n    return coin['ns']\n\n\ndef coingecko_symbols() -> Dict[str, str]:\n    r = None\n    intermediate = defaultdict(list)\n    try:\n        r = requests.get('https://api.coingecko.com/api/v3/coins/list')\n        all_coins = r.json()\n        # First pass: generate & compare normalized symbol/name, and then select the most pertinent\n        for coin in all_coins:\n            normalized = coingecko_normalize_all(coin)\n            intermediate[normalized].append(coin)\n            # Above line keeps together the coins having the same normalized symbol.\n            # To reduce collision, the coin['name'] is sometimes used in lieu of the coin['symbol'].\n            # The coin['name'] is not capitalized because lower case letters may be meaningful: cETH, yUSD, DATx, zLOT\n    except Exception as why:\n        raise_failure_explanation('COINGECKO', why, {\"\": r})\n\n    final = coingecko_second_pass(intermediate)\n    return coingecko_third_pass(final)\n\n\ndef coingecko_second_pass(intermediate: Dict[str, List[dict]]) -> Dict[str, List[dict]]:\n    # Second pass: fixes most of the symbol collisions\n    final = defaultdict(list)\n    for normalized, coins in intermediate.items():\n        if len(coins) == 1:\n            final[normalized].append(coins[0])\n            continue\n        set_normalized = False\n        for i in range(len(coins)):\n            if normalized == coins[i]['nn']:\n                coin = coins.pop(i)\n                final[normalized].append(coin)\n                set_normalized = True\n                break\n        rest: List[dict] = []\n        for coin in coins:\n            if '%' in coin['name']:\n                if len(coins) == 1:\n                    n = coin['ns']\n                else:\n                    n = coingecko_normalize_name(coin['id'])\n                final[n].append(coin)\n            else:\n                rest.append(coin)\n        if not rest:\n            continue\n        if not set_normalized:\n            rest.sort(key=lambda coin: len(coin['nn']), reverse=True)  # sort by the length of the normalized name\n            coin = rest.pop(0)\n            final[normalized].append(coin)\n        for coin in rest:\n            if coin['nn'] not in intermediate:\n                n = coin['nn']\n            elif coin.get('reduced-name'):\n                n = coingecko_normalize_name(coin['name'])\n            else:\n                n = coingecko_normalize_name(coin['id'])\n            final[n].append(coin)\n    return final\n\n\ndef coingecko_third_pass(final: Dict[str, List[dict]]) -> Dict[str, str]:\n    # Third pass: fixes some remaining collisions and fills the result\n    symbols = {}\n    for normalized, coins in final.items():\n        if len(coins) == 1:\n            symbols[normalized] = coins[0]['id']\n            continue\n        set_normalized = False\n        for i in range(len(coins)):\n            if normalized == coins[i]['nn']:\n                coin = coins.pop(i)\n                symbols[normalized] = coin['id']\n                set_normalized = True\n                break\n        rest: List[dict] = []\n        for coin in coins:\n            if '%' in coin['name']:\n                if len(coins) == 1:\n                    n = coin['ns']\n                else:\n                    n = coingecko_normalize_name(coin['id'])\n                symbols[n] = coin['id']\n            else:\n                rest.append(coin)\n        if not rest:\n            continue\n        if not set_normalized:\n            rest.sort(key=lambda coin: len(coin['nn']), reverse=True)  # sort by the length of the normalized name\n            coin = rest.pop(0)\n            symbols[normalized] = coin['id']\n        for coin in rest:\n            if coin['nn'] not in final:\n                n = coin['nn']\n            elif coin.get('reduced-name'):\n                n = coingecko_normalize_name(coin['name'])\n            else:\n                n = coingecko_normalize_name(coin['id'])\n            symbols[n] = coin['id']\n    return symbols\n\n\ndef whale_alert_coins(key_id: str) -> Dict[str, str]:\n    r = None\n    try:\n        r = requests.get(f'https://api.whale-alert.io/v1/status?api_key={key_id}')\n        # Same symbols, but on different blockchains (for instance USDT), are naturally overwritten.\n        return {s.upper(): s for b in r.json()['blockchains'] for s in b['symbols'] if s}\n    except Exception as why:\n        raise_failure_explanation('WHALES_ALERT', why, {\"\": r})\n\n\n_exchange_function_map = {\n    BITFINEX: bitfinex_symbols,\n    BITFLYER: bitflyer_symbols,\n    COINBASE: coinbase_symbols,\n    GEMINI: gemini_symbols,\n    HITBTC: hitbtc_symbols,\n    POLONIEX: poloniex_symbols,\n    PROBIT: probit_symbols,\n    BITSTAMP: bitstamp_symbols,\n    KRAKEN: kraken_symbols,\n    KRAKEN + 'REST': kraken_rest_symbols,\n    BINANCE: binance_symbols,\n    BINANCE_US: binance_us_symbols,\n    BINANCE_FUTURES: binance_futures_symbols,\n    BINANCE_DELIVERY: binance_delivery_symbols,\n    BLOCKCHAIN: blockchain_symbols,\n    EXX: exx_symbols,\n    HUOBI: huobi_symbols,\n    HUOBI_DM: huobi_dm_symbols,\n    HUOBI_SWAP: huobi_swap_symbols,\n    OKCOIN: okcoin_symbols,\n    OKEX: okex_symbols,\n    BYBIT: bybit_symbols,\n    FTX: ftx_symbols,\n    FTX_US: ftx_us_symbols,\n    BITTREX: bittrex_symbols,\n    BITCOINCOM: bitcoincom_symbols,\n    BITMAX: bitmax_symbols,\n    UPBIT: upbit_symbols,\n    GATEIO: gateio_symbols,\n    BITMEX: bitmex_symbols,\n    DERIBIT: deribit_symbols,\n    KRAKEN_FUTURES: kraken_future_symbols,\n    COINGECKO: coingecko_symbols,\n    WHALE_ALERT: whale_alert_coins\n}\n",
        "source_code_len": 30534,
        "target_code": "associated with this software.\n'''\nfrom typing import Dict, Tuple\n\n\nclass _Symbols:\n    def __init__(self):\n        self.data = {}\n\n    def set(self, exchange: str, normalized: dict, exchange_info: dict):\n        self.data[exchange] = {}\n        self.data[exchange]['normalized'] = normalized\n        self.data[exchange]['info'] = exchange_info\n\n    def get(self, exchange: str) -> Tuple[Dict, Dict]:\n        return self.data[exchange]['normalized'], self.data[exchange]['info']\n\n    def populated(self, exchange: str) -> bool:\n        return exchange in self.data\n\n\nSymbols = _Symbols()\n",
        "target_code_len": 588,
        "diff_format": "@@ -5,845 +5,22 @@\n associated with this software.\n+'''\n+from typing import Dict, Tuple\n \n \n-Symbol generation code for exchanges\n-'''\n+class _Symbols:\n+    def __init__(self):\n+        self.data = {}\n \n-import logging\n-import string\n-import time\n-from collections import defaultdict\n-from typing import Dict, List, Optional, Tuple\n+    def set(self, exchange: str, normalized: dict, exchange_info: dict):\n+        self.data[exchange] = {}\n+        self.data[exchange]['normalized'] = normalized\n+        self.data[exchange]['info'] = exchange_info\n \n-import requests\n-from requests import Response\n+    def get(self, exchange: str) -> Tuple[Dict, Dict]:\n+        return self.data[exchange]['normalized'], self.data[exchange]['info']\n \n-from cryptofeed.defines import *\n+    def populated(self, exchange: str) -> bool:\n+        return exchange in self.data\n \n \n-LOG = logging.getLogger('feedhandler')\n-\n-SYMBOL_SEP = '-'\n-\n-_symbols_retrieval_cache: Dict[str, Dict[str, str]] = {}\n-_exchange_info = defaultdict(lambda: defaultdict(dict))\n-\n-\n-_kraken_futures_product_type = {\n-    'FI': 'Inverse Futures',\n-    'FV': 'Vanilla Futures',\n-    'PI': 'Perpetual Inverse Futures',\n-    'PV': 'Perpetual Vanilla Futures',\n-    'IN': 'Real Time Index',\n-    'RR': 'Reference Rate',\n-}\n-\n-\n-def raise_failure_explanation(feed_id: str, exception: BaseException, responses: Dict[str, Optional[Response]]):\n-    LOG.critical('%s: encountered %r while processing response from exchange API', feed_id, exception)\n-    if len(responses) > 1:\n-        LOG.critical('%s: content of one of the %s responses was unexpected', feed_id, len(responses))\n-    for url, r in responses.items():\n-        if url:\n-            LOG.critical('%s: requested URL: %s', feed_id, url)\n-        if r:\n-            LOG.critical('%s: unexpected response: %s', feed_id, r.text)\n-    raise ValueError(f'Cryptofeed stopped because of an unexpected response from {feed_id}') from exception\n-\n-\n-def set_symbol_separator(separator: str):\n-    global SYMBOL_SEP\n-    SYMBOL_SEP = separator\n-\n-\n-def get_symbol_separator() -> str:\n-    global SYMBOL_SEP\n-    return SYMBOL_SEP\n-\n-\n-def gen_symbols(exchange: str, key_id=None) -> Dict[str, str]:\n-    if exchange not in _symbols_retrieval_cache:\n-        LOG.info(\"%s: Getting list of symbols\", exchange)\n-        symbols = _exchange_function_map[exchange](key_id) if key_id else _exchange_function_map[exchange]()\n-        LOG.info(\"%s: %s symbols\", exchange, len(symbols))\n-\n-        # log all retrieved symbols using debug level\n-        for normalized, exch_sym in sorted(symbols.items()):\n-            LOG.debug('%s: id-from-exch -> normalized: %-35s-> %s', exchange, exch_sym, normalized)\n-\n-        _symbols_retrieval_cache[exchange] = symbols\n-    return _symbols_retrieval_cache[exchange]\n-\n-\n-def _binance_symbols(endpoint: str, exchange: str):\n-    r = None\n-    try:\n-        ret = {}\n-        r = requests.get(endpoint)\n-        for symbol in r.json()['symbols']:\n-            if symbol.get('status', 'TRADING') != \"TRADING\":\n-                continue\n-            if symbol.get('contractStatus', 'TRADING') != \"TRADING\":\n-                continue\n-            split = len(symbol['baseAsset'])\n-            normalized = symbol['symbol'][:split] + SYMBOL_SEP + symbol['symbol'][split:]\n-            ret[normalized] = symbol['symbol']\n-            _exchange_info[exchange]['tick_size'][normalized] = symbol['filters'][0]['tickSize']\n-            if \"contractType\" in symbol:\n-                _exchange_info[exchange]['contract_type'][normalized] = symbol['contractType']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation(exchange, why, {endpoint: r})\n-\n-\n-def binance_symbols() -> Dict[str, str]:\n-    return _binance_symbols('https://api.binance.com/api/v3/exchangeInfo', BINANCE)\n-\n-\n-def binance_us_symbols() -> Dict[str, str]:\n-    return _binance_symbols('https://api.binance.us/api/v3/exchangeInfo', BINANCE_US)\n-\n-\n-def binance_futures_symbols() -> Dict[str, str]:\n-    base = _binance_symbols('https://fapi.binance.com/fapi/v1/exchangeInfo', BINANCE_FUTURES)\n-    add = {}\n-    for symbol, orig in base.items():\n-        if \"_\" in orig:\n-            continue\n-        add[f\"{symbol}-PINDEX\"] = f\"p{orig}\"\n-    base.update(add)\n-    return base\n-\n-\n-def binance_delivery_symbols() -> Dict[str, str]:\n-    return _binance_symbols('https://dapi.binance.com/dapi/v1/exchangeInfo', BINANCE_DELIVERY)\n-\n-\n-def bitfinex_symbols() -> Dict[str, str]:\n-    # doc: https://docs.bitfinex.com/docs/ws-general#supported-pairs\n-    r1 = r2 = None\n-    try:\n-        r1 = requests.get('https://api.bitfinex.com/v2/tickers?symbols=ALL')\n-        r2 = requests.get('https://api-pub.bitfinex.com/v2/conf/pub:map:currency:sym')\n-        tickers: List[List[str]] = r1.json()\n-        norm: List[Tuple[str, str]] = r2.json()[0]\n-        norm: Dict[str, str] = dict(norm)\n-        for k, v in dict(norm).items():\n-            if k[-2:] == 'F0' or '-' in v:  # Do not convert BTCF0 -> BTC or PBTCETH -> PBTC-ETH\n-                del norm[k]\n-        norm['BCHN'] = 'BCH'  # Bitfinex uses BCHN, other exchanges use BCH\n-\n-        ret = {}\n-        for symbol in [t[0] for t in tickers]:\n-            if symbol[0] == 'f':\n-                normalized = norm.get(symbol[1:], symbol[1:])\n-            else:\n-                if len(symbol) == 7:\n-                    base, quote = symbol[1:4], symbol[4:]\n-                else:\n-                    base, quote = symbol[1:].split(':')\n-                    assert ':' in symbol\n-                normalized = norm.get(base, base) + SYMBOL_SEP + norm.get(quote, quote)\n-            ret[normalized.upper()] = symbol\n-        return ret\n-    except ValueError as why:\n-        raise_failure_explanation('BITFINEX', why, {\"tickers?symbols=ALL\": r1, \"pub:map:currency:sym\": r2})\n-\n-\n-def bitflyer_symbols() -> Dict[str, str]:\n-    endpoint = r = None\n-    try:\n-        ret = {}\n-        endpoints = ['https://api.bitflyer.com/v1/getmarkets/eu', 'https://api.bitflyer.com/v1/getmarkets/usa', 'https://api.bitflyer.com/v1/getmarkets']\n-        for endpoint in endpoints:\n-            r = requests.get(endpoint)\n-            for entry in r.json():\n-                normalized = entry['product_code'].replace(\"_\", SYMBOL_SEP)\n-                ret[normalized] = entry['product_code']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('BITFLYER', why, {endpoint: r})\n-\n-\n-def bybit_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.bybit.com/v2/public/symbols')\n-        ret = {}\n-        for symbol in r.json()['result']:\n-            quote = symbol['quote_currency']\n-            if not symbol['name'].endswith(quote):\n-                base, contract = symbol['name'].split(quote)\n-                normalized = f\"{base}{SYMBOL_SEP}{quote}-{contract}\"\n-            else:\n-                normalized = f\"{symbol['base_currency']}{SYMBOL_SEP}{quote}\"\n-            ret[normalized] = symbol['name']\n-            _exchange_info[BYBIT]['tick_size'][normalized] = symbol['price_filter']['tick_size']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('BYBIT', why, {\"\": r})\n-\n-\n-def _ftx_helper(endpoint: str, exchange: str):\n-    r = None\n-    try:\n-        r = requests.get(endpoint)\n-        ret = {}\n-        for data in r.json()['result']:\n-            normalized = data['name'].replace(\"/\", SYMBOL_SEP)\n-            symbol = data['name']\n-            ret[normalized] = symbol\n-            _exchange_info[exchange]['tick_size'][normalized] = data['priceIncrement']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation(exchange, why, {endpoint: r})\n-\n-\n-def ftx_symbols() -> Dict[str, str]:\n-    return _ftx_helper('https://ftx.com/api/markets', FTX)\n-\n-\n-def ftx_us_symbols() -> Dict[str, str]:\n-    return _ftx_helper('https://ftx.us/api/markets', FTX_US)\n-\n-\n-def coinbase_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.pro.coinbase.com/products')\n-        ret = {}\n-        for data in r.json():\n-            normalized = data['id'].replace(\"-\", SYMBOL_SEP)\n-            ret[normalized] = data['id']\n-            _exchange_info[COINBASE]['tick_size'][normalized] = data['quote_increment']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('COINBASE', why, {\"\": r})\n-\n-\n-def gemini_symbols(*args) -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.gemini.com/v1/symbols')\n-        ret = {}\n-        for symbol in r.json():\n-            std = f\"{symbol[:-3]}{SYMBOL_SEP}{symbol[-3:]}\"\n-            std = std.upper()\n-            ret[std] = symbol.upper()\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('GEMINI', why, {\"\": r})\n-\n-\n-def hitbtc_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        ret = {}\n-        r = requests.get('https://api.hitbtc.com/api/2/public/symbol')\n-        for symbol in r.json():\n-            split = len(symbol['baseCurrency'])\n-            normalized = symbol['id'][:split] + SYMBOL_SEP + symbol['id'][split:]\n-            ret[normalized] = symbol['id']\n-            _exchange_info[HITBTC]['tick_size'][normalized] = symbol['tickSize']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('HITBTC', why, {\"\": r})\n-\n-\n-def poloniex_id_symbol_mapping():\n-    r = None\n-    try:\n-        r = requests.get('https://poloniex.com/public?command=returnTicker')\n-        symbols = r.json()\n-        ret = {}\n-        for symbol in symbols:\n-            ret[symbols[symbol]['id']] = symbol\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('POLONIEX', why, {\"\": r})\n-\n-\n-def poloniex_symbols() -> Dict[str, str]:\n-    ret = {}\n-    for _, value in poloniex_id_symbol_mapping().items():\n-        std = value.replace(\"STR\", \"XLM\")\n-        quote, base = std.split(\"_\")\n-        ret[quote + SYMBOL_SEP + base] = value\n-    return ret\n-\n-\n-def bitstamp_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://www.bitstamp.net/api/v2/trading-pairs-info/')\n-        ret = {}\n-        for data in r.json():\n-            normalized = data['name'].replace(\"/\", SYMBOL_SEP)\n-            symbol = data['url_symbol']\n-            ret[normalized] = symbol\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('BITSTAMP', why, {\"\": r})\n-\n-\n-def kraken_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.kraken.com/0/public/AssetPairs')\n-        data = r.json()\n-        ret = {}\n-        for symbol in data['result']:\n-            if 'wsname' not in data['result'][symbol] or '.d' in symbol:\n-                # https://blog.kraken.com/post/259/introducing-the-kraken-dark-pool/\n-                # .d is for dark pool symbols\n-                continue\n-\n-            base, quote = data['result'][symbol]['wsname'].split(\"/\")\n-\n-            normalized = f\"{base}{SYMBOL_SEP}{quote}\"\n-            exch = data['result'][symbol]['wsname']\n-            normalized = normalized.replace('XBT', 'BTC')\n-            normalized = normalized.replace('XDG', 'DOG')\n-            ret[normalized] = exch\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('KRAKEN', why, {\"\": r})\n-\n-\n-def kraken_rest_symbols() -> Dict[str, str]:\n-    return {normalized: exchange.replace(\"/\", \"\") for normalized, exchange in kraken_symbols().items()}\n-\n-\n-def exx_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.exx.com/data/v1/tickers')\n-        exchange = [key.upper() for key in r.json().keys()]\n-        symbols = [key.replace(\"_\", SYMBOL_SEP) for key in exchange]\n-        return dict(zip(symbols, exchange))\n-    except Exception as why:\n-        raise_failure_explanation('EXX', why, {\"\": r})\n-\n-\n-def huobi_common_symbols(url: str):\n-    r = None\n-    try:\n-        r = requests.get(url)\n-        ret = {}\n-        for e in r.json()['data']:\n-            if e['state'] == 'offline':\n-                continue\n-            normalized = f\"{e['base-currency'].upper()}{SYMBOL_SEP}{e['quote-currency'].upper()}\"\n-            symbol = f\"{e['base-currency']}{e['quote-currency']}\"\n-            ret[normalized] = symbol\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('HUOBI', why, {url: r})\n-\n-\n-def huobi_symbols() -> Dict[str, str]:\n-    return huobi_common_symbols('https://api.huobi.pro/v1/common/symbols')\n-\n-\n-def huobi_us_symbols() -> Dict[str, str]:\n-    return huobi_common_symbols('https://api.huobi.com/v1/common/symbols')\n-\n-\n-def huobi_dm_symbols() -> Dict[str, str]:\n-    \"\"\"\n-    Mapping is, for instance: {\"BTC_CW\":\"BTC190816\"}\n-    See comments in exchange/huobi_dm.py\n-    \"\"\"\n-    mapping = {\n-        \"this_week\": \"CW\",\n-        \"next_week\": \"NW\",\n-        \"quarter\": \"CQ\",\n-        \"next_quarter\": \"NQ\"\n-    }\n-    r = None\n-    try:\n-        r = requests.get('https://www.hbdm.com/api/v1/contract_contract_info')\n-        symbols = {}\n-        for e in r.json()['data']:\n-            symbols[f\"{e['symbol']}_{mapping[e['contract_type']]}\"] = e['contract_code']\n-            _exchange_info[HUOBI_DM]['tick_size'][e['contract_code']] = e['price_tick']\n-            _exchange_info[HUOBI_DM]['short_code_mappings'][f\"{e['symbol']}_{mapping[e['contract_type']]}\"] = e['contract_code']\n-        return symbols\n-    except Exception as why:\n-        raise_failure_explanation('HUOBI_DM', why, {\"\": r})\n-\n-\n-def huobi_swap_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.hbdm.com/swap-api/v1/swap_contract_info')\n-        symbols = {}\n-        for e in r.json()['data']:\n-            symbols[e['contract_code']] = e['contract_code']\n-            _exchange_info[HUOBI_SWAP]['tick_size'][e['contract_code']] = e['price_tick']\n-        return symbols\n-    except Exception as why:\n-        raise_failure_explanation('HUOBI_SWAP', why, {\"\": r})\n-\n-\n-def okcoin_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://www.okcoin.com/api/spot/v3/instruments')\n-        ret = {}\n-        for e in r.json():\n-            ret[e['instrument_id']] = e['instrument_id']\n-            _exchange_info[OKCOIN]['tick_size'][e['instrument_id']] = e['tick_size']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('OKCOIN', why, {\"\": r})\n-\n-\n-def okex_symbols(*args) -> Dict[str, str]:\n-    urls = ['https://www.okex.com/api/spot/v3/instruments',\n-            'https://www.okex.com/api/swap/v3/instruments',\n-            'https://www.okex.com/api/futures/v3/instruments']\n-    urls = urls + okex_compute_option_urls_from_underlyings()\n-\n-    symbols: Dict[str, str] = {}\n-    for u in urls:\n-        time.sleep(0.2)\n-        symbols.update(okex_symbols_from_one_url(u))\n-\n-    for symbol in symbols:\n-        instrument_type = 'futures'\n-        dash_count = symbol.count(get_symbol_separator())\n-        if dash_count == 1:  # BTC-USDT\n-            instrument_type = 'spot'\n-        if dash_count == 4:  # BTC-USD-201225-35000-P\n-            instrument_type = 'option'\n-        if symbol[-4:] == \"SWAP\":  # BTC-USDT-SWAP\n-            instrument_type = 'swap'\n-\n-        _exchange_info[OKEX]['instrument_type'][symbol] = instrument_type\n-\n-    return symbols\n-\n-\n-def okex_compute_option_urls_from_underlyings() -> List[str]:\n-    url = 'https://www.okex.com/api/option/v3/underlying'\n-    r = None\n-    try:\n-        r = requests.get(url)\n-        return [f'https://www.okex.com/api/option/v3/instruments/{underlying}' for underlying in r.json()]\n-    except Exception as why:\n-        raise_failure_explanation('OKEX', why, {url: r})\n-\n-\n-def okex_symbols_from_one_url(url: str) -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get(url)\n-        ret = {}\n-        for e in r.json():\n-            ret[e['instrument_id']] = e['instrument_id']\n-            _exchange_info[OKEX]['tick_size'][e['instrument_id']] = e['tick_size']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('OKEX', why, {url: r})\n-\n-\n-def bittrex_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.bittrex.com/api/v1.1/public/getmarkets')\n-        r = r.json()['result']\n-        return {f\"{e['MarketCurrency']}{SYMBOL_SEP}{e['BaseCurrency']}\": e['MarketName'] for e in r if e['IsActive']}\n-    except Exception as why:\n-        raise_failure_explanation('BITTREX', why, {\"\": r})\n-\n-\n-def bitcoincom_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.exchange.bitcoin.com/api/2/public/symbol')\n-        return {f\"{data['baseCurrency']}{SYMBOL_SEP}{data['quoteCurrency'].replace('USD', 'USDT')}\": data['id'] for data in r.json()}\n-    except Exception as why:\n-        raise_failure_explanation('BITCOINCOM', why, {\"\": r})\n-\n-\n-def bitmax_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://bitmax.io/api/pro/v1/products')\n-        ret = {}\n-        for entry in r.json()['data']:\n-            # Only \"Normal\" status symbols are tradeable\n-            if entry['status'] == 'Normal':\n-                normalized = f\"{entry['baseAsset']}{SYMBOL_SEP}{entry['quoteAsset']}\"\n-                ret[normalized] = entry['symbol']\n-                _exchange_info[BITMAX]['tick_size'][normalized] = entry['tickSize']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('BITMAX', why, {\"\": r})\n-\n-\n-def upbit_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get('https://api.upbit.com/v1/market/all')\n-        return {f\"{data['market'].split('-')[1]}{SYMBOL_SEP}{data['market'].split('-')[0]}\": data['market'] for data in r.json()}\n-    except Exception as why:\n-        raise_failure_explanation('UPBIT', why, {\"\": r})\n-\n-\n-def blockchain_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get(\"https://api.blockchain.com/mercury-gateway/v1/instruments\")\n-        return {data[\"symbol\"].replace(\"-\", SYMBOL_SEP): data[\"symbol\"] for data in r.json()}\n-    except Exception as why:\n-        raise_failure_explanation('BLOCKCHAIN', why, {\"\": r})\n-\n-\n-def gateio_symbols() -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get(\"https://api.gateio.ws/api/v4/spot/currency_pairs\")\n-        return {data[\"id\"].replace(\"_\", SYMBOL_SEP): data['id'] for data in r.json()}\n-    except Exception as why:\n-        raise_failure_explanation('GATEIO', why, {\"\": r})\n-\n-\n-def bitmex_symbols() -> Dict[str, str]:\n-    r = None\n-    ret = {}\n-    try:\n-        r = requests.get(\"https://www.bitmex.com/api/v1/instrument/active\")\n-        for entry in r.json():\n-            components = []\n-            components.append(entry['rootSymbol'])\n-            components.append(entry['quoteCurrency'])\n-\n-            if entry['expiry']:\n-                components.append(entry['symbol'][-3:])\n-\n-            normalized = SYMBOL_SEP.join(components)\n-            normalized = normalized.replace(\"XBT\", \"BTC\")\n-            ret[normalized] = entry['symbol']\n-            _exchange_info[BITMEX]['tick_size'][normalized] = entry['tickSize']\n-\n-            if entry['expiry']:\n-                _exchange_info[BITMEX]['expiry'][normalized] = entry['expiry']\n-\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('BITMEX', why, {\"\": r})\n-\n-\n-def deribit_symbols() -> Dict[str, str]:\n-    url = r = None\n-    ret = {}\n-    try:\n-        # TODO: get currencies from https://www.deribit.com/api/v2/public/get_currencies\n-        currencies = ['BTC', 'ETH']\n-        for c in currencies:\n-            url = f\"https://www.deribit.com/api/v2/public/get_instruments?currency={c}&expired=false\"\n-            r = requests.get(url)\n-            for entry in r.json()['result']:\n-                split = entry['instrument_name'].split(\"-\")\n-                normalized = split[0] + SYMBOL_SEP + entry['quote_currency'] + \"-\" + '-'.join(split[1:])\n-                ret[normalized] = entry['instrument_name']\n-                _exchange_info[DERIBIT]['tick_size'][normalized] = entry['tick_size']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('DERIBIT', why, {url: r})\n-\n-\n-def kraken_future_symbols() -> Dict[str, str]:\n-    r = None\n-    ret = {}\n-    try:\n-        r = requests.get('https://futures.kraken.com/derivatives/api/v3/instruments')\n-        data = r.json()['instruments']\n-        for entry in data:\n-            if not entry['tradeable']:\n-                continue\n-            normalized = entry['symbol'].upper().replace(\"_\", \"-\")\n-            symbol = normalized[3:6] + SYMBOL_SEP + normalized[6:9]\n-            normalized = normalized.replace(normalized[3:9], symbol)\n-            normalized = normalized.replace('XBT', 'BTC')\n-\n-            _exchange_info[KRAKEN_FUTURES]['tick_size'][normalized] = entry['tickSize']\n-            _exchange_info[KRAKEN_FUTURES]['contract_size'][normalized] = entry['contractSize']\n-            _exchange_info[KRAKEN_FUTURES]['underlying'][normalized] = entry['underlying']\n-            _exchange_info[KRAKEN_FUTURES]['product_type'][normalized] = _kraken_futures_product_type[normalized[:2]]\n-            ret[normalized] = entry['symbol']\n-        return ret\n-    except Exception as why:\n-        raise_failure_explanation('KRAKEN_FUTURES', why, {\"\": r})\n-\n-\n-def probit_symbols() -> Dict[str, str]:\n-    # doc: https://docs-en.probit.com/reference-link/market\n-    r = None\n-    try:\n-        r = requests.get('https://api.probit.com/api/exchange/v1/market')\n-        return {entry['id']: entry['id'] for entry in r.json()['data']}\n-    except Exception as why:\n-        raise_failure_explanation('PROBIT', why, {\"\": r})\n-\n-\n-def coingecko_normalize_symbol(symbol: str) -> str:\n-    # keep digits, letters and dots, replace others by space\n-    symbol = ''.join(c if c.isalnum() or c in ('.', '+') else ' ' for c in symbol)\n-    return coingecko_normalize(symbol.upper())\n-\n-\n-def coingecko_normalize_name(name: str) -> str:\n-    # keep digits and letters, replace others by space (except when only composed by upper case letters, digits and dots)\n-    if not all(c.isupper() or c.isdigit() or c == '.' for c in name):\n-        name = ''.join(c if c.isalnum() else ' ' for c in name)\n-    return coingecko_normalize(name)\n-\n-\n-def coingecko_normalize(sym: str) -> str:\n-    sym = sym.strip()\n-    # do not concatenate numbers => separate them with a dot\n-    sym = list(sym)\n-    if len(sym) > 4:\n-        for i in range(2, len(sym) - 1):\n-            if sym[i] == ' ' and sym[i - 1].isdigit() and sym[i + 1].isdigit():\n-                sym[i] = '.'\n-    sym = ''.join(sym)\n-    # concatenate space-separated words => use CamelCase to distinguish the words\n-    if ' ' in sym:\n-        if sum(c.islower() for c in sym):  # if there is at least one lower case letter\n-            sym = ' '.join(word[0].upper() + word[1:] for word in sym.split())  # Just capitalize initial letter of each word\n-        else:  # CoinGecko may provide full upper-case as for \"THE STONE COIN\"\n-            sym = string.capwords(sym)  # capwords converts \"THE STONE COIN\" to \"The Stone Coin\"\n-        sym = sym.replace(' ', '')  # concatenate words\n-    return sym\n-\n-\n-def is_name_short(coin: dict) -> bool:\n-    \"\"\"return True if the coin name is enough short compared to the coin symbol.\"\"\"\n-    return len(coin['name']) <= max(5, len(coin['symbol']) + 1)\n-\n-\n-def has_many_caps(name: str) -> bool:\n-    \"\"\"return True if the symbol contains enough upper case letters, False if empty.\"\"\"\n-    return str and sum(c.islower() for c in name) < (len(name) / 2)\n-\n-\n-def coingecko_normalize_all(coin: dict):\n-    SYMBOL_TO_NORMALIZED = {'miota': 'IOTA'}\n-    normalized = SYMBOL_TO_NORMALIZED.get(coin['symbol'])\n-    if normalized:\n-        coin['ns'] = coin['nn'] = normalized\n-        return normalized\n-\n-    # ns = normalized symbol, nn = normalized name\n-    coin['ns'] = coingecko_normalize_symbol(coin['symbol'])\n-\n-    ID_SUFFIX = '-bitcoin-token'\n-    if coin['id'][-len(ID_SUFFIX):] == ID_SUFFIX:\n-        coin['nn'] = 'BTC' + coin['ns']\n-        return coin['nn']\n-\n-    name = coin['name']\n-\n-    prefixes = ('The ', 'the ')\n-    for p in prefixes:\n-        if name[:len(p)] == p:\n-            coin['reduced-name'] = True\n-            name = name[len(p):]\n-            break\n-\n-    suffixes = ('coin', 'coins', 'money', 'finance', 'protocol', 'reward', 'rewards', 'token')\n-    for s in suffixes:\n-        if len(name) > len(s) and name[-len(s):].lower() == s:\n-            # but keep suffix when lower-case concatenated\n-            if name[-len(s)].islower() and name[-len(s) - 1] != ' ':\n-                continue\n-            # also keep suffix to avoid confusing nam: \"Bitcoin Token\" -> \"Bitcoin\"\n-            if name[:-len(s)].strip().lower() == 'bitcoin':\n-                continue\n-            coin['reduced-name'] = True\n-            name = name[:-len(s)]\n-            break\n-\n-    coin['nn'] = coingecko_normalize_name(name)\n-\n-    if len(coin['nn']) < len(coin['ns']):\n-        if 'reduced-name' in coin:\n-            coin['reduced-name'] = False\n-            name = coin['name']\n-            coin['nn'] = coingecko_normalize_name(name)\n-        elif not has_many_caps(name):\n-            return coin['ns']\n-\n-    if not coin['ns']:  # coin['symbol'] may be an emoji that is striped when normalized\n-        return coin['nn']\n-\n-    if coin.get('reduced-name') and coin['ns'].upper() != coin['nn'].upper():\n-        return coin['ns']\n-\n-    i = coin['nn'].find('.')  # if there is a dot in normalized name => prefer the normalized symbol\n-    if i >= 0:\n-        if i > 1 and coin['nn'][i - 1].isdigit() and coin['nn'][i + 1].isdigit():\n-            pass  # except when the dot separates digits\n-        else:\n-            return coin['ns']\n-\n-    if is_name_short(coin) and has_many_caps(name):\n-        return coin['nn']\n-\n-    if 1.5 * len(coin['ns']) > len(coin['nn']) and any(c.islower() for c in coin['ns']):\n-        return coin['nn']\n-\n-    return coin['ns']\n-\n-\n-def coingecko_symbols() -> Dict[str, str]:\n-    r = None\n-    intermediate = defaultdict(list)\n-    try:\n-        r = requests.get('https://api.coingecko.com/api/v3/coins/list')\n-        all_coins = r.json()\n-        # First pass: generate & compare normalized symbol/name, and then select the most pertinent\n-        for coin in all_coins:\n-            normalized = coingecko_normalize_all(coin)\n-            intermediate[normalized].append(coin)\n-            # Above line keeps together the coins having the same normalized symbol.\n-            # To reduce collision, the coin['name'] is sometimes used in lieu of the coin['symbol'].\n-            # The coin['name'] is not capitalized because lower case letters may be meaningful: cETH, yUSD, DATx, zLOT\n-    except Exception as why:\n-        raise_failure_explanation('COINGECKO', why, {\"\": r})\n-\n-    final = coingecko_second_pass(intermediate)\n-    return coingecko_third_pass(final)\n-\n-\n-def coingecko_second_pass(intermediate: Dict[str, List[dict]]) -> Dict[str, List[dict]]:\n-    # Second pass: fixes most of the symbol collisions\n-    final = defaultdict(list)\n-    for normalized, coins in intermediate.items():\n-        if len(coins) == 1:\n-            final[normalized].append(coins[0])\n-            continue\n-        set_normalized = False\n-        for i in range(len(coins)):\n-            if normalized == coins[i]['nn']:\n-                coin = coins.pop(i)\n-                final[normalized].append(coin)\n-                set_normalized = True\n-                break\n-        rest: List[dict] = []\n-        for coin in coins:\n-            if '%' in coin['name']:\n-                if len(coins) == 1:\n-                    n = coin['ns']\n-                else:\n-                    n = coingecko_normalize_name(coin['id'])\n-                final[n].append(coin)\n-            else:\n-                rest.append(coin)\n-        if not rest:\n-            continue\n-        if not set_normalized:\n-            rest.sort(key=lambda coin: len(coin['nn']), reverse=True)  # sort by the length of the normalized name\n-            coin = rest.pop(0)\n-            final[normalized].append(coin)\n-        for coin in rest:\n-            if coin['nn'] not in intermediate:\n-                n = coin['nn']\n-            elif coin.get('reduced-name'):\n-                n = coingecko_normalize_name(coin['name'])\n-            else:\n-                n = coingecko_normalize_name(coin['id'])\n-            final[n].append(coin)\n-    return final\n-\n-\n-def coingecko_third_pass(final: Dict[str, List[dict]]) -> Dict[str, str]:\n-    # Third pass: fixes some remaining collisions and fills the result\n-    symbols = {}\n-    for normalized, coins in final.items():\n-        if len(coins) == 1:\n-            symbols[normalized] = coins[0]['id']\n-            continue\n-        set_normalized = False\n-        for i in range(len(coins)):\n-            if normalized == coins[i]['nn']:\n-                coin = coins.pop(i)\n-                symbols[normalized] = coin['id']\n-                set_normalized = True\n-                break\n-        rest: List[dict] = []\n-        for coin in coins:\n-            if '%' in coin['name']:\n-                if len(coins) == 1:\n-                    n = coin['ns']\n-                else:\n-                    n = coingecko_normalize_name(coin['id'])\n-                symbols[n] = coin['id']\n-            else:\n-                rest.append(coin)\n-        if not rest:\n-            continue\n-        if not set_normalized:\n-            rest.sort(key=lambda coin: len(coin['nn']), reverse=True)  # sort by the length of the normalized name\n-            coin = rest.pop(0)\n-            symbols[normalized] = coin['id']\n-        for coin in rest:\n-            if coin['nn'] not in final:\n-                n = coin['nn']\n-            elif coin.get('reduced-name'):\n-                n = coingecko_normalize_name(coin['name'])\n-            else:\n-                n = coingecko_normalize_name(coin['id'])\n-            symbols[n] = coin['id']\n-    return symbols\n-\n-\n-def whale_alert_coins(key_id: str) -> Dict[str, str]:\n-    r = None\n-    try:\n-        r = requests.get(f'https://api.whale-alert.io/v1/status?api_key={key_id}')\n-        # Same symbols, but on different blockchains (for instance USDT), are naturally overwritten.\n-        return {s.upper(): s for b in r.json()['blockchains'] for s in b['symbols'] if s}\n-    except Exception as why:\n-        raise_failure_explanation('WHALES_ALERT', why, {\"\": r})\n-\n-\n-_exchange_function_map = {\n-    BITFINEX: bitfinex_symbols,\n-    BITFLYER: bitflyer_symbols,\n-    COINBASE: coinbase_symbols,\n-    GEMINI: gemini_symbols,\n-    HITBTC: hitbtc_symbols,\n-    POLONIEX: poloniex_symbols,\n-    PROBIT: probit_symbols,\n-    BITSTAMP: bitstamp_symbols,\n-    KRAKEN: kraken_symbols,\n-    KRAKEN + 'REST': kraken_rest_symbols,\n-    BINANCE: binance_symbols,\n-    BINANCE_US: binance_us_symbols,\n-    BINANCE_FUTURES: binance_futures_symbols,\n-    BINANCE_DELIVERY: binance_delivery_symbols,\n-    BLOCKCHAIN: blockchain_symbols,\n-    EXX: exx_symbols,\n-    HUOBI: huobi_symbols,\n-    HUOBI_DM: huobi_dm_symbols,\n-    HUOBI_SWAP: huobi_swap_symbols,\n-    OKCOIN: okcoin_symbols,\n-    OKEX: okex_symbols,\n-    BYBIT: bybit_symbols,\n-    FTX: ftx_symbols,\n-    FTX_US: ftx_us_symbols,\n-    BITTREX: bittrex_symbols,\n-    BITCOINCOM: bitcoincom_symbols,\n-    BITMAX: bitmax_symbols,\n-    UPBIT: upbit_symbols,\n-    GATEIO: gateio_symbols,\n-    BITMEX: bitmex_symbols,\n-    DERIBIT: deribit_symbols,\n-    KRAKEN_FUTURES: kraken_future_symbols,\n-    COINGECKO: coingecko_symbols,\n-    WHALE_ALERT: whale_alert_coins\n-}\n+Symbols = _Symbols()\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\n\nimport logging\nimport string\nimport time\nfrom collections import defaultdict\nfrom typing import Dict, List, Optional, Tuple\n\nimport requests\nfrom requests import Response\n\nfrom cryptofeed.defines import *\n\n\nLOG = logging.getLogger('feedhandler')\n\nSYMBOL_SEP = '-'\n\n_symbols_retrieval_cache: Dict[str, Dict[str, str]] = {}\n_exchange_info = defaultdict(lambda: defaultdict(dict))\n\n\n_kraken_futures_product_type = {\n    'FI': 'Inverse Futures',\n    'FV': 'Vanilla Futures',\n    'PI': 'Perpetual Inverse Futures',\n    'PV': 'Perpetual Vanilla Futures',\n    'IN': 'Real Time Index',\n    'RR': 'Reference Rate',\n}\n\n\ndef raise_failure_explanation(feed_id: str, exception: BaseException, responses: Dict[str, Optional[Response]]):\n    <IND>LOG.critical('%s: encountered %r while processing response from exchange API', feed_id, exception)\n    if len(responses) > 1:\n        <IND>LOG.critical('%s: content of one of the %s responses was unexpected', feed_id, len(responses))\n    <DED>for url, r in responses.items():\n        <IND>if url:\n            <IND>LOG.critical('%s: requested URL: %s', feed_id, url)\n        <DED>if r:\n            <IND>LOG.critical('%s: unexpected response: %s', feed_id, r.text)\n    <DED><DED>raise ValueError(f'Cryptofeed stopped because of an unexpected response from {feed_id}') from exception\n\n\n<DED>def set_symbol_separator(separator: str):\n    <IND>global SYMBOL_SEP\n    SYMBOL_SEP = separator\n\n\n<DED>def get_symbol_separator() -> str:\n    <IND>global SYMBOL_SEP\n    return SYMBOL_SEP\n\n\n<DED>def gen_symbols(exchange: str, key_id=None) -> Dict[str, str]:\n    <IND>if exchange not in _symbols_retrieval_cache:\n        <IND>LOG.info(\"%s: Getting list of symbols\", exchange)\n        symbols = _exchange_function_map[exchange](key_id) if key_id else _exchange_function_map[exchange]()\n        LOG.info(\"%s: %s symbols\", exchange, len(symbols))\n\n        # log all retrieved symbols using debug level\n        for normalized, exch_sym in sorted(symbols.items()):\n            <IND>LOG.debug('%s: id-from-exch -> normalized: %-35s-> %s', exchange, exch_sym, normalized)\n\n        <DED>_symbols_retrieval_cache[exchange] = symbols\n    <DED>return _symbols_retrieval_cache[exchange]\n\n\n<DED>def _binance_symbols(endpoint: str, exchange: str):\n    <IND>r = None\n    try:\n        <IND>ret = {}\n        r = requests.get(endpoint)\n        for symbol in r.json()['symbols']:\n            <IND>if symbol.get('status', 'TRADING') != \"TRADING\":\n                <IND>continue\n            <DED>if symbol.get('contractStatus', 'TRADING') != \"TRADING\":\n                <IND>continue\n            <DED>split = len(symbol['baseAsset'])\n            normalized = symbol['symbol'][:split] + SYMBOL_SEP + symbol['symbol'][split:]\n            ret[normalized] = symbol['symbol']\n            _exchange_info[exchange]['tick_size'][normalized] = symbol['filters'][0]['tickSize']\n            if \"contractType\" in symbol:\n                <IND>_exchange_info[exchange]['contract_type'][normalized] = symbol['contractType']\n        <DED><DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation(exchange, why, {endpoint: r})\n\n\n<DED><DED>def binance_symbols() -> Dict[str, str]:\n    <IND>return _binance_symbols('https://api.binance.com/api/v3/exchangeInfo', BINANCE)\n\n\n<DED>def binance_us_symbols() -> Dict[str, str]:\n    <IND>return _binance_symbols('https://api.binance.us/api/v3/exchangeInfo', BINANCE_US)\n\n\n<DED>def binance_futures_symbols() -> Dict[str, str]:\n    <IND>base = _binance_symbols('https://fapi.binance.com/fapi/v1/exchangeInfo', BINANCE_FUTURES)\n    add = {}\n    for symbol, orig in base.items():\n        <IND>if \"_\" in orig:\n            <IND>continue\n        <DED>add[f\"{symbol}-PINDEX\"] = f\"p{orig}\"\n    <DED>base.update(add)\n    return base\n\n\n<DED>def binance_delivery_symbols() -> Dict[str, str]:\n    <IND>return _binance_symbols('https://dapi.binance.com/dapi/v1/exchangeInfo', BINANCE_DELIVERY)\n\n\n<DED>def bitfinex_symbols() -> Dict[str, str]:\n    # doc: https://docs.bitfinex.com/docs/ws-general#supported-pairs\n    <IND>r1 = r2 = None\n    try:\n        <IND>r1 = requests.get('https://api.bitfinex.com/v2/tickers?symbols=ALL')\n        r2 = requests.get('https://api-pub.bitfinex.com/v2/conf/pub:map:currency:sym')\n        tickers: List[List[str]] = r1.json()\n        norm: List[Tuple[str, str]] = r2.json()[0]\n        norm: Dict[str, str] = dict(norm)\n        for k, v in dict(norm).items():\n            <IND>if k[-2:] == 'F0' or '-' in v:  # Do not convert BTCF0 -> BTC or PBTCETH -> PBTC-ETH\n                <IND>del norm[k]\n        <DED><DED>norm['BCHN'] = 'BCH'  # Bitfinex uses BCHN, other exchanges use BCH\n\n        ret = {}\n        for symbol in [t[0] for t in tickers]:\n            <IND>if symbol[0] == 'f':\n                <IND>normalized = norm.get(symbol[1:], symbol[1:])\n            <DED>else:\n                <IND>if len(symbol) == 7:\n                    <IND>base, quote = symbol[1:4], symbol[4:]\n                <DED>else:\n                    <IND>base, quote = symbol[1:].split(':')\n                    assert ':' in symbol\n                <DED>normalized = norm.get(base, base) + SYMBOL_SEP + norm.get(quote, quote)\n            <DED>ret[normalized.upper()] = symbol\n        <DED>return ret\n    <DED>except ValueError as why:\n        <IND>raise_failure_explanation('BITFINEX', why, {\"tickers?symbols=ALL\": r1, \"pub:map:currency:sym\": r2})\n\n\n<DED><DED>def bitflyer_symbols() -> Dict[str, str]:\n    <IND>endpoint = r = None\n    try:\n        <IND>ret = {}\n        endpoints = ['https://api.bitflyer.com/v1/getmarkets/eu', 'https://api.bitflyer.com/v1/getmarkets/usa', 'https://api.bitflyer.com/v1/getmarkets']\n        for endpoint in endpoints:\n            <IND>r = requests.get(endpoint)\n            for entry in r.json():\n                <IND>normalized = entry['product_code'].replace(\"_\", SYMBOL_SEP)\n                ret[normalized] = entry['product_code']\n        <DED><DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BITFLYER', why, {endpoint: r})\n\n\n<DED><DED>def bybit_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.bybit.com/v2/public/symbols')\n        ret = {}\n        for symbol in r.json()['result']:\n            <IND>quote = symbol['quote_currency']\n            if not symbol['name'].endswith(quote):\n                <IND>base, contract = symbol['name'].split(quote)\n                normalized = f\"{base}{SYMBOL_SEP}{quote}-{contract}\"\n            <DED>else:\n                <IND>normalized = f\"{symbol['base_currency']}{SYMBOL_SEP}{quote}\"\n            <DED>ret[normalized] = symbol['name']\n            _exchange_info[BYBIT]['tick_size'][normalized] = symbol['price_filter']['tick_size']\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BYBIT', why, {\"\": r})\n\n\n<DED><DED>def _ftx_helper(endpoint: str, exchange: str):\n    <IND>r = None\n    try:\n        <IND>r = requests.get(endpoint)\n        ret = {}\n        for data in r.json()['result']:\n            <IND>normalized = data['name'].replace(\"/\", SYMBOL_SEP)\n            symbol = data['name']\n            ret[normalized] = symbol\n            _exchange_info[exchange]['tick_size'][normalized] = data['priceIncrement']\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation(exchange, why, {endpoint: r})\n\n\n<DED><DED>def ftx_symbols() -> Dict[str, str]:\n    <IND>return _ftx_helper('https://ftx.com/api/markets', FTX)\n\n\n<DED>def ftx_us_symbols() -> Dict[str, str]:\n    <IND>return _ftx_helper('https://ftx.us/api/markets', FTX_US)\n\n\n<DED>def coinbase_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.pro.coinbase.com/products')\n        ret = {}\n        for data in r.json():\n            <IND>normalized = data['id'].replace(\"-\", SYMBOL_SEP)\n            ret[normalized] = data['id']\n            _exchange_info[COINBASE]['tick_size'][normalized] = data['quote_increment']\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('COINBASE', why, {\"\": r})\n\n\n<DED><DED>def gemini_symbols(*args) -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.gemini.com/v1/symbols')\n        ret = {}\n        for symbol in r.json():\n            <IND>std = f\"{symbol[:-3]}{SYMBOL_SEP}{symbol[-3:]}\"\n            std = std.upper()\n            ret[std] = symbol.upper()\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('GEMINI', why, {\"\": r})\n\n\n<DED><DED>def hitbtc_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>ret = {}\n        r = requests.get('https://api.hitbtc.com/api/2/public/symbol')\n        for symbol in r.json():\n            <IND>split = len(symbol['baseCurrency'])\n            normalized = symbol['id'][:split] + SYMBOL_SEP + symbol['id'][split:]\n            ret[normalized] = symbol['id']\n            _exchange_info[HITBTC]['tick_size'][normalized] = symbol['tickSize']\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('HITBTC', why, {\"\": r})\n\n\n<DED><DED>def poloniex_id_symbol_mapping():\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://poloniex.com/public?command=returnTicker')\n        symbols = r.json()\n        ret = {}\n        for symbol in symbols:\n            <IND>ret[symbols[symbol]['id']] = symbol\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('POLONIEX', why, {\"\": r})\n\n\n<DED><DED>def poloniex_symbols() -> Dict[str, str]:\n    <IND>ret = {}\n    for _, value in poloniex_id_symbol_mapping().items():\n        <IND>std = value.replace(\"STR\", \"XLM\")\n        quote, base = std.split(\"_\")\n        ret[quote + SYMBOL_SEP + base] = value\n    <DED>return ret\n\n\n<DED>def bitstamp_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://www.bitstamp.net/api/v2/trading-pairs-info/')\n        ret = {}\n        for data in r.json():\n            <IND>normalized = data['name'].replace(\"/\", SYMBOL_SEP)\n            symbol = data['url_symbol']\n            ret[normalized] = symbol\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BITSTAMP', why, {\"\": r})\n\n\n<DED><DED>def kraken_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.kraken.com/0/public/AssetPairs')\n        data = r.json()\n        ret = {}\n        for symbol in data['result']:\n            <IND>if 'wsname' not in data['result'][symbol] or '.d' in symbol:\n                # https://blog.kraken.com/post/259/introducing-the-kraken-dark-pool/\n                # .d is for dark pool symbols\n                <IND>continue\n\n            <DED>base, quote = data['result'][symbol]['wsname'].split(\"/\")\n\n            normalized = f\"{base}{SYMBOL_SEP}{quote}\"\n            exch = data['result'][symbol]['wsname']\n            normalized = normalized.replace('XBT', 'BTC')\n            normalized = normalized.replace('XDG', 'DOG')\n            ret[normalized] = exch\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('KRAKEN', why, {\"\": r})\n\n\n<DED><DED>def kraken_rest_symbols() -> Dict[str, str]:\n    <IND>return {normalized: exchange.replace(\"/\", \"\") for normalized, exchange in kraken_symbols().items()}\n\n\n<DED>def exx_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.exx.com/data/v1/tickers')\n        exchange = [key.upper() for key in r.json().keys()]\n        symbols = [key.replace(\"_\", SYMBOL_SEP) for key in exchange]\n        return dict(zip(symbols, exchange))\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('EXX', why, {\"\": r})\n\n\n<DED><DED>def huobi_common_symbols(url: str):\n    <IND>r = None\n    try:\n        <IND>r = requests.get(url)\n        ret = {}\n        for e in r.json()['data']:\n            <IND>if e['state'] == 'offline':\n                <IND>continue\n            <DED>normalized = f\"{e['base-currency'].upper()}{SYMBOL_SEP}{e['quote-currency'].upper()}\"\n            symbol = f\"{e['base-currency']}{e['quote-currency']}\"\n            ret[normalized] = symbol\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('HUOBI', why, {url: r})\n\n\n<DED><DED>def huobi_symbols() -> Dict[str, str]:\n    <IND>return huobi_common_symbols('https://api.huobi.pro/v1/common/symbols')\n\n\n<DED>def huobi_us_symbols() -> Dict[str, str]:\n    <IND>return huobi_common_symbols('https://api.huobi.com/v1/common/symbols')\n\n\n<DED>def huobi_dm_symbols() -> Dict[str, str]:\n    <IND>\"\"\"\n    Mapping is, for instance: {\"BTC_CW\":\"BTC190816\"}\n    See comments in exchange/huobi_dm.py\n    \"\"\"\n    mapping = {\n        \"this_week\": \"CW\",\n        \"next_week\": \"NW\",\n        \"quarter\": \"CQ\",\n        \"next_quarter\": \"NQ\"\n    }\n    r = None\n    try:\n        <IND>r = requests.get('https://www.hbdm.com/api/v1/contract_contract_info')\n        symbols = {}\n        for e in r.json()['data']:\n            <IND>symbols[f\"{e['symbol']}_{mapping[e['contract_type']]}\"] = e['contract_code']\n            _exchange_info[HUOBI_DM]['tick_size'][e['contract_code']] = e['price_tick']\n            _exchange_info[HUOBI_DM]['short_code_mappings'][f\"{e['symbol']}_{mapping[e['contract_type']]}\"] = e['contract_code']\n        <DED>return symbols\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('HUOBI_DM', why, {\"\": r})\n\n\n<DED><DED>def huobi_swap_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.hbdm.com/swap-api/v1/swap_contract_info')\n        symbols = {}\n        for e in r.json()['data']:\n            <IND>symbols[e['contract_code']] = e['contract_code']\n            _exchange_info[HUOBI_SWAP]['tick_size'][e['contract_code']] = e['price_tick']\n        <DED>return symbols\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('HUOBI_SWAP', why, {\"\": r})\n\n\n<DED><DED>def okcoin_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://www.okcoin.com/api/spot/v3/instruments')\n        ret = {}\n        for e in r.json():\n            <IND>ret[e['instrument_id']] = e['instrument_id']\n            _exchange_info[OKCOIN]['tick_size'][e['instrument_id']] = e['tick_size']\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('OKCOIN', why, {\"\": r})\n\n\n<DED><DED>def okex_symbols(*args) -> Dict[str, str]:\n    <IND>urls = ['https://www.okex.com/api/spot/v3/instruments',\n            'https://www.okex.com/api/swap/v3/instruments',\n            'https://www.okex.com/api/futures/v3/instruments']\n    urls = urls + okex_compute_option_urls_from_underlyings()\n\n    symbols: Dict[str, str] = {}\n    for u in urls:\n        <IND>time.sleep(0.2)\n        symbols.update(okex_symbols_from_one_url(u))\n\n    <DED>for symbol in symbols:\n        <IND>instrument_type = 'futures'\n        dash_count = symbol.count(get_symbol_separator())\n        if dash_count == 1:  # BTC-USDT\n            <IND>instrument_type = 'spot'\n        <DED>if dash_count == 4:  # BTC-USD-201225-35000-P\n            <IND>instrument_type = 'option'\n        <DED>if symbol[-4:] == \"SWAP\":  # BTC-USDT-SWAP\n            <IND>instrument_type = 'swap'\n\n        <DED>_exchange_info[OKEX]['instrument_type'][symbol] = instrument_type\n\n    <DED>return symbols\n\n\n<DED>def okex_compute_option_urls_from_underlyings() -> List[str]:\n    <IND>url = 'https://www.okex.com/api/option/v3/underlying'\n    r = None\n    try:\n        <IND>r = requests.get(url)\n        return [f'https://www.okex.com/api/option/v3/instruments/{underlying}' for underlying in r.json()]\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('OKEX', why, {url: r})\n\n\n<DED><DED>def okex_symbols_from_one_url(url: str) -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get(url)\n        ret = {}\n        for e in r.json():\n            <IND>ret[e['instrument_id']] = e['instrument_id']\n            _exchange_info[OKEX]['tick_size'][e['instrument_id']] = e['tick_size']\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('OKEX', why, {url: r})\n\n\n<DED><DED>def bittrex_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.bittrex.com/api/v1.1/public/getmarkets')\n        r = r.json()['result']\n        return {f\"{e['MarketCurrency']}{SYMBOL_SEP}{e['BaseCurrency']}\": e['MarketName'] for e in r if e['IsActive']}\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BITTREX', why, {\"\": r})\n\n\n<DED><DED>def bitcoincom_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.exchange.bitcoin.com/api/2/public/symbol')\n        return {f\"{data['baseCurrency']}{SYMBOL_SEP}{data['quoteCurrency'].replace('USD', 'USDT')}\": data['id'] for data in r.json()}\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BITCOINCOM', why, {\"\": r})\n\n\n<DED><DED>def bitmax_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://bitmax.io/api/pro/v1/products')\n        ret = {}\n        for entry in r.json()['data']:\n            # Only \"Normal\" status symbols are tradeable\n            <IND>if entry['status'] == 'Normal':\n                <IND>normalized = f\"{entry['baseAsset']}{SYMBOL_SEP}{entry['quoteAsset']}\"\n                ret[normalized] = entry['symbol']\n                _exchange_info[BITMAX]['tick_size'][normalized] = entry['tickSize']\n        <DED><DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BITMAX', why, {\"\": r})\n\n\n<DED><DED>def upbit_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.upbit.com/v1/market/all')\n        return {f\"{data['market'].split('-')[1]}{SYMBOL_SEP}{data['market'].split('-')[0]}\": data['market'] for data in r.json()}\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('UPBIT', why, {\"\": r})\n\n\n<DED><DED>def blockchain_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get(\"https://api.blockchain.com/mercury-gateway/v1/instruments\")\n        return {data[\"symbol\"].replace(\"-\", SYMBOL_SEP): data[\"symbol\"] for data in r.json()}\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BLOCKCHAIN', why, {\"\": r})\n\n\n<DED><DED>def gateio_symbols() -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get(\"https://api.gateio.ws/api/v4/spot/currency_pairs\")\n        return {data[\"id\"].replace(\"_\", SYMBOL_SEP): data['id'] for data in r.json()}\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('GATEIO', why, {\"\": r})\n\n\n<DED><DED>def bitmex_symbols() -> Dict[str, str]:\n    <IND>r = None\n    ret = {}\n    try:\n        <IND>r = requests.get(\"https://www.bitmex.com/api/v1/instrument/active\")\n        for entry in r.json():\n            <IND>components = []\n            components.append(entry['rootSymbol'])\n            components.append(entry['quoteCurrency'])\n\n            if entry['expiry']:\n                <IND>components.append(entry['symbol'][-3:])\n\n            <DED>normalized = SYMBOL_SEP.join(components)\n            normalized = normalized.replace(\"XBT\", \"BTC\")\n            ret[normalized] = entry['symbol']\n            _exchange_info[BITMEX]['tick_size'][normalized] = entry['tickSize']\n\n            if entry['expiry']:\n                <IND>_exchange_info[BITMEX]['expiry'][normalized] = entry['expiry']\n\n        <DED><DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('BITMEX', why, {\"\": r})\n\n\n<DED><DED>def deribit_symbols() -> Dict[str, str]:\n    <IND>url = r = None\n    ret = {}\n    try:\n        # TODO: get currencies from https://www.deribit.com/api/v2/public/get_currencies\n        <IND>currencies = ['BTC', 'ETH']\n        for c in currencies:\n            <IND>url = f\"https://www.deribit.com/api/v2/public/get_instruments?currency={c}&expired=false\"\n            r = requests.get(url)\n            for entry in r.json()['result']:\n                <IND>split = entry['instrument_name'].split(\"-\")\n                normalized = split[0] + SYMBOL_SEP + entry['quote_currency'] + \"-\" + '-'.join(split[1:])\n                ret[normalized] = entry['instrument_name']\n                _exchange_info[DERIBIT]['tick_size'][normalized] = entry['tick_size']\n        <DED><DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('DERIBIT', why, {url: r})\n\n\n<DED><DED>def kraken_future_symbols() -> Dict[str, str]:\n    <IND>r = None\n    ret = {}\n    try:\n        <IND>r = requests.get('https://futures.kraken.com/derivatives/api/v3/instruments')\n        data = r.json()['instruments']\n        for entry in data:\n            <IND>if not entry['tradeable']:\n                <IND>continue\n            <DED>normalized = entry['symbol'].upper().replace(\"_\", \"-\")\n            symbol = normalized[3:6] + SYMBOL_SEP + normalized[6:9]\n            normalized = normalized.replace(normalized[3:9], symbol)\n            normalized = normalized.replace('XBT', 'BTC')\n\n            _exchange_info[KRAKEN_FUTURES]['tick_size'][normalized] = entry['tickSize']\n            _exchange_info[KRAKEN_FUTURES]['contract_size'][normalized] = entry['contractSize']\n            _exchange_info[KRAKEN_FUTURES]['underlying'][normalized] = entry['underlying']\n            _exchange_info[KRAKEN_FUTURES]['product_type'][normalized] = _kraken_futures_product_type[normalized[:2]]\n            ret[normalized] = entry['symbol']\n        <DED>return ret\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('KRAKEN_FUTURES', why, {\"\": r})\n\n\n<DED><DED>def probit_symbols() -> Dict[str, str]:\n    # doc: https://docs-en.probit.com/reference-link/market\n    <IND>r = None\n    try:\n        <IND>r = requests.get('https://api.probit.com/api/exchange/v1/market')\n        return {entry['id']: entry['id'] for entry in r.json()['data']}\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('PROBIT', why, {\"\": r})\n\n\n<DED><DED>def coingecko_normalize_symbol(symbol: str) -> str:\n    # keep digits, letters and dots, replace others by space\n    <IND>symbol = ''.join(c if c.isalnum() or c in ('.', '+') else ' ' for c in symbol)\n    return coingecko_normalize(symbol.upper())\n\n\n<DED>def coingecko_normalize_name(name: str) -> str:\n    # keep digits and letters, replace others by space (except when only composed by upper case letters, digits and dots)\n    <IND>if not all(c.isupper() or c.isdigit() or c == '.' for c in name):\n        <IND>name = ''.join(c if c.isalnum() else ' ' for c in name)\n    <DED>return coingecko_normalize(name)\n\n\n<DED>def coingecko_normalize(sym: str) -> str:\n    <IND>sym = sym.strip()\n    # do not concatenate numbers => separate them with a dot\n    sym = list(sym)\n    if len(sym) > 4:\n        <IND>for i in range(2, len(sym) - 1):\n            <IND>if sym[i] == ' ' and sym[i - 1].isdigit() and sym[i + 1].isdigit():\n                <IND>sym[i] = '.'\n    <DED><DED><DED>sym = ''.join(sym)\n    # concatenate space-separated words => use CamelCase to distinguish the words\n    if ' ' in sym:\n        <IND>if sum(c.islower() for c in sym):  # if there is at least one lower case letter\n            <IND>sym = ' '.join(word[0].upper() + word[1:] for word in sym.split())  # Just capitalize initial letter of each word\n        <DED>else:  # CoinGecko may provide full upper-case as for \"THE STONE COIN\"\n            <IND>sym = string.capwords(sym)  # capwords converts \"THE STONE COIN\" to \"The Stone Coin\"\n        <DED>sym = sym.replace(' ', '')  # concatenate words\n    <DED>return sym\n\n\n<DED>def is_name_short(coin: dict) -> bool:\n    <IND>\"\"\"return True if the coin name is enough short compared to the coin symbol.\"\"\"\n    return len(coin['name']) <= max(5, len(coin['symbol']) + 1)\n\n\n<DED>def has_many_caps(name: str) -> bool:\n    <IND>\"\"\"return True if the symbol contains enough upper case letters, False if empty.\"\"\"\n    return str and sum(c.islower() for c in name) < (len(name) / 2)\n\n\n<DED>def coingecko_normalize_all(coin: dict):\n    <IND>SYMBOL_TO_NORMALIZED = {'miota': 'IOTA'}\n    normalized = SYMBOL_TO_NORMALIZED.get(coin['symbol'])\n    if normalized:\n        <IND>coin['ns'] = coin['nn'] = normalized\n        return normalized\n\n    # ns = normalized symbol, nn = normalized name\n    <DED>coin['ns'] = coingecko_normalize_symbol(coin['symbol'])\n\n    ID_SUFFIX = '-bitcoin-token'\n    if coin['id'][-len(ID_SUFFIX):] == ID_SUFFIX:\n        <IND>coin['nn'] = 'BTC' + coin['ns']\n        return coin['nn']\n\n    <DED>name = coin['name']\n\n    prefixes = ('The ', 'the ')\n    for p in prefixes:\n        <IND>if name[:len(p)] == p:\n            <IND>coin['reduced-name'] = True\n            name = name[len(p):]\n            break\n\n    <DED><DED>suffixes = ('coin', 'coins', 'money', 'finance', 'protocol', 'reward', 'rewards', 'token')\n    for s in suffixes:\n        <IND>if len(name) > len(s) and name[-len(s):].lower() == s:\n            # but keep suffix when lower-case concatenated\n            <IND>if name[-len(s)].islower() and name[-len(s) - 1] != ' ':\n                <IND>continue\n            # also keep suffix to avoid confusing nam: \"Bitcoin Token\" -> \"Bitcoin\"\n            <DED>if name[:-len(s)].strip().lower() == 'bitcoin':\n                <IND>continue\n            <DED>coin['reduced-name'] = True\n            name = name[:-len(s)]\n            break\n\n    <DED><DED>coin['nn'] = coingecko_normalize_name(name)\n\n    if len(coin['nn']) < len(coin['ns']):\n        <IND>if 'reduced-name' in coin:\n            <IND>coin['reduced-name'] = False\n            name = coin['name']\n            coin['nn'] = coingecko_normalize_name(name)\n        <DED>elif not has_many_caps(name):\n            <IND>return coin['ns']\n\n    <DED><DED>if not coin['ns']:  # coin['symbol'] may be an emoji that is striped when normalized\n        <IND>return coin['nn']\n\n    <DED>if coin.get('reduced-name') and coin['ns'].upper() != coin['nn'].upper():\n        <IND>return coin['ns']\n\n    <DED>i = coin['nn'].find('.')  # if there is a dot in normalized name => prefer the normalized symbol\n    if i >= 0:\n        <IND>if i > 1 and coin['nn'][i - 1].isdigit() and coin['nn'][i + 1].isdigit():\n            <IND>pass  # except when the dot separates digits\n        <DED>else:\n            <IND>return coin['ns']\n\n    <DED><DED>if is_name_short(coin) and has_many_caps(name):\n        <IND>return coin['nn']\n\n    <DED>if 1.5 * len(coin['ns']) > len(coin['nn']) and any(c.islower() for c in coin['ns']):\n        <IND>return coin['nn']\n\n    <DED>return coin['ns']\n\n\n<DED>def coingecko_symbols() -> Dict[str, str]:\n    <IND>r = None\n    intermediate = defaultdict(list)\n    try:\n        <IND>r = requests.get('https://api.coingecko.com/api/v3/coins/list')\n        all_coins = r.json()\n        # First pass: generate & compare normalized symbol/name, and then select the most pertinent\n        for coin in all_coins:\n            <IND>normalized = coingecko_normalize_all(coin)\n            intermediate[normalized].append(coin)\n            # Above line keeps together the coins having the same normalized symbol.\n            # To reduce collision, the coin['name'] is sometimes used in lieu of the coin['symbol'].\n            # The coin['name'] is not capitalized because lower case letters may be meaningful: cETH, yUSD, DATx, zLOT\n    <DED><DED>except Exception as why:\n        <IND>raise_failure_explanation('COINGECKO', why, {\"\": r})\n\n    <DED>final = coingecko_second_pass(intermediate)\n    return coingecko_third_pass(final)\n\n\n<DED>def coingecko_second_pass(intermediate: Dict[str, List[dict]]) -> Dict[str, List[dict]]:\n    # Second pass: fixes most of the symbol collisions\n    <IND>final = defaultdict(list)\n    for normalized, coins in intermediate.items():\n        <IND>if len(coins) == 1:\n            <IND>final[normalized].append(coins[0])\n            continue\n        <DED>set_normalized = False\n        for i in range(len(coins)):\n            <IND>if normalized == coins[i]['nn']:\n                <IND>coin = coins.pop(i)\n                final[normalized].append(coin)\n                set_normalized = True\n                break\n        <DED><DED>rest: List[dict] = []\n        for coin in coins:\n            <IND>if '%' in coin['name']:\n                <IND>if len(coins) == 1:\n                    <IND>n = coin['ns']\n                <DED>else:\n                    <IND>n = coingecko_normalize_name(coin['id'])\n                <DED>final[n].append(coin)\n            <DED>else:\n                <IND>rest.append(coin)\n        <DED><DED>if not rest:\n            <IND>continue\n        <DED>if not set_normalized:\n            <IND>rest.sort(key=lambda coin: len(coin['nn']), reverse=True)  # sort by the length of the normalized name\n            coin = rest.pop(0)\n            final[normalized].append(coin)\n        <DED>for coin in rest:\n            <IND>if coin['nn'] not in intermediate:\n                <IND>n = coin['nn']\n            <DED>elif coin.get('reduced-name'):\n                <IND>n = coingecko_normalize_name(coin['name'])\n            <DED>else:\n                <IND>n = coingecko_normalize_name(coin['id'])\n            <DED>final[n].append(coin)\n    <DED><DED>return final\n\n\n<DED>def coingecko_third_pass(final: Dict[str, List[dict]]) -> Dict[str, str]:\n    # Third pass: fixes some remaining collisions and fills the result\n    <IND>symbols = {}\n    for normalized, coins in final.items():\n        <IND>if len(coins) == 1:\n            <IND>symbols[normalized] = coins[0]['id']\n            continue\n        <DED>set_normalized = False\n        for i in range(len(coins)):\n            <IND>if normalized == coins[i]['nn']:\n                <IND>coin = coins.pop(i)\n                symbols[normalized] = coin['id']\n                set_normalized = True\n                break\n        <DED><DED>rest: List[dict] = []\n        for coin in coins:\n            <IND>if '%' in coin['name']:\n                <IND>if len(coins) == 1:\n                    <IND>n = coin['ns']\n                <DED>else:\n                    <IND>n = coingecko_normalize_name(coin['id'])\n                <DED>symbols[n] = coin['id']\n            <DED>else:\n                <IND>rest.append(coin)\n        <DED><DED>if not rest:\n            <IND>continue\n        <DED>if not set_normalized:\n            <IND>rest.sort(key=lambda coin: len(coin['nn']), reverse=True)  # sort by the length of the normalized name\n            coin = rest.pop(0)\n            symbols[normalized] = coin['id']\n        <DED>for coin in rest:\n            <IND>if coin['nn'] not in final:\n                <IND>n = coin['nn']\n            <DED>elif coin.get('reduced-name'):\n                <IND>n = coingecko_normalize_name(coin['name'])\n            <DED>else:\n                <IND>n = coingecko_normalize_name(coin['id'])\n            <DED>symbols[n] = coin['id']\n    <DED><DED>return symbols\n\n\n<DED>def whale_alert_coins(key_id: str) -> Dict[str, str]:\n    <IND>r = None\n    try:\n        <IND>r = requests.get(f'https://api.whale-alert.io/v1/status?api_key={key_id}')\n        # Same symbols, but on different blockchains (for instance USDT), are naturally overwritten.\n        return {s.upper(): s for b in r.json()['blockchains'] for s in b['symbols'] if s}\n    <DED>except Exception as why:\n        <IND>raise_failure_explanation('WHALES_ALERT', why, {\"\": r})\n\n\n<DED><DED>_exchange_function_map = {\n    BITFINEX: bitfinex_symbols,\n    BITFLYER: bitflyer_symbols,\n    COINBASE: coinbase_symbols,\n    GEMINI: gemini_symbols,\n    HITBTC: hitbtc_symbols,\n    POLONIEX: poloniex_symbols,\n    PROBIT: probit_symbols,\n    BITSTAMP: bitstamp_symbols,\n    KRAKEN: kraken_symbols,\n    KRAKEN + 'REST': kraken_rest_symbols,\n    BINANCE: binance_symbols,\n    BINANCE_US: binance_us_symbols,\n    BINANCE_FUTURES: binance_futures_symbols,\n    BINANCE_DELIVERY: binance_delivery_symbols,\n    BLOCKCHAIN: blockchain_symbols,\n    EXX: exx_symbols,\n    HUOBI: huobi_symbols,\n    HUOBI_DM: huobi_dm_symbols,\n    HUOBI_SWAP: huobi_swap_symbols,\n    OKCOIN: okcoin_symbols,\n    OKEX: okex_symbols,\n    BYBIT: bybit_symbols,\n    FTX: ftx_symbols,\n    FTX_US: ftx_us_symbols,\n    BITTREX: bittrex_symbols,\n    BITCOINCOM: bitcoincom_symbols,\n    BITMAX: bitmax_symbols,\n    UPBIT: upbit_symbols,\n    GATEIO: gateio_symbols,\n    BITMEX: bitmex_symbols,\n    DERIBIT: deribit_symbols,\n    KRAKEN_FUTURES: kraken_future_symbols,\n    COINGECKO: coingecko_symbols,\n    WHALE_ALERT: whale_alert_coins\n}\n",
        "target_code_with_indent": "\nfrom typing import Dict, Tuple\n\n\nclass _Symbols:\n    <IND>def __init__(self):\n        <IND>self.data = {}\n\n    <DED>def set(self, exchange: str, normalized: dict, exchange_info: dict):\n        <IND>self.data[exchange] = {}\n        self.data[exchange]['normalized'] = normalized\n        self.data[exchange]['info'] = exchange_info\n\n    <DED>def get(self, exchange: str) -> Tuple[Dict, Dict]:\n        <IND>return self.data[exchange]['normalized'], self.data[exchange]['info']\n\n    <DED>def populated(self, exchange: str) -> bool:\n        <IND>return exchange in self.data\n\n\n<DED><DED>Symbols = _Symbols()\n"
      }
    ]
  },
  {
    "project": "bmoscon/cryptofeed",
    "commit": "3525dc8ce4d7836a9abaaa5662e58e5e27969a77",
    "filename": "cryptofeed/util/async_file.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/bmoscon-cryptofeed/cryptofeed/raw_data_collection.py",
    "file_hunks_size": 8,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "cryptofeed/util/async_file.py:134:69 Incompatible variable type [9]: endpoint is declared to have type `str` but is used as type `None`.",
    "message": " endpoint is declared to have type `str` but is used as type `None`.",
    "rule_id": "Incompatible variable type [9]",
    "warning_line_no": 134,
    "warning_line": "    async def __call__(self, data: str, timestamp: float, uuid: str, endpoint: str = None, send: str = None, connect: str = None):"
  },
  {
    "project": "bmoscon/cryptofeed",
    "commit": "3525dc8ce4d7836a9abaaa5662e58e5e27969a77",
    "filename": "cryptofeed/util/async_file.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/bmoscon-cryptofeed/cryptofeed/raw_data_collection.py",
    "file_hunks_size": 8,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "cryptofeed/util/async_file.py:134:91 Incompatible variable type [9]: send is declared to have type `str` but is used as type `None`.",
    "message": " send is declared to have type `str` but is used as type `None`.",
    "rule_id": "Incompatible variable type [9]",
    "warning_line_no": 134,
    "warning_line": "    async def __call__(self, data: str, timestamp: float, uuid: str, endpoint: str = None, send: str = None, connect: str = None):"
  },
  {
    "project": "bmoscon/cryptofeed",
    "commit": "3525dc8ce4d7836a9abaaa5662e58e5e27969a77",
    "filename": "cryptofeed/util/async_file.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/bmoscon-cryptofeed/cryptofeed/raw_data_collection.py",
    "file_hunks_size": 8,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "cryptofeed/util/async_file.py:134:109 Incompatible variable type [9]: connect is declared to have type `str` but is used as type `None`.",
    "message": " connect is declared to have type `str` but is used as type `None`.",
    "rule_id": "Incompatible variable type [9]",
    "warning_line_no": 134,
    "warning_line": "    async def __call__(self, data: str, timestamp: float, uuid: str, endpoint: str = None, send: str = None, connect: str = None):"
  }
]