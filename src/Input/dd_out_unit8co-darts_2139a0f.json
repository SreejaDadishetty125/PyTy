[
  {
    "project": "unit8co/darts",
    "commit": "2139a0f40d032b936c76158b01f6f48656567a0c",
    "filename": "u8timeseries/models/RNN_model.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/unit8co-darts/u8timeseries/models/rnn_model.py",
    "file_hunks_size": 15,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": true,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "u8timeseries/models/RNN_model.py:114:17 Incompatible variable type [9]: hidden_fc_size is declared to have type `List[typing.Any]` but is used as type `None`.",
    "message": " hidden_fc_size is declared to have type `List[typing.Any]` but is used as type `None`.",
    "rule_id": "Incompatible variable type [9]",
    "warning_line_no": 114,
    "warning_line": "                 hidden_fc_size: List = None,",
    "min_patch": [
      {
        "hunk_fit_TFix": true,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "                 n_rnn_layers: int = 1,\n                 hidden_fc_size: List = None,\n                 dropout: float = 0.,\n                 batch_size: int = None,\n                 n_epochs: int = 800,\n",
        "source_code_len": 203,
        "target_code": "                 n_rnn_layers: int = 1,\n                 hidden_fc_sizes: Optional[List] = None,\n                 dropout: float = 0.,\n                 batch_size: int = 32,\n                 n_epochs: int = 800,\n",
        "target_code_len": 212,
        "diff_format": "@@ -113,5 +179,5 @@\n                  n_rnn_layers: int = 1,\n-                 hidden_fc_size: List = None,\n+                 hidden_fc_sizes: Optional[List] = None,\n                  dropout: float = 0.,\n-                 batch_size: int = None,\n+                 batch_size: int = 32,\n                  n_epochs: int = 800,\n",
        "source_code_with_indent": "                 n_rnn_layers: int = 1,\n                 hidden_fc_size: List = None,\n                 dropout: float = 0.,\n                 batch_size: int = None,\n                 n_epochs: int = 800,\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "                 n_rnn_layers: int = 1,\n                 hidden_fc_sizes: Optional[List] = None,\n                 dropout: float = 0.,\n                 batch_size: int = 32,\n                 n_epochs: int = 800,\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "unit8co/darts",
    "commit": "2139a0f40d032b936c76158b01f6f48656567a0c",
    "filename": "u8timeseries/models/RNN_model.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/unit8co-darts/u8timeseries/models/rnn_model.py",
    "file_hunks_size": 15,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": true,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "u8timeseries/models/RNN_model.py:116:17 Incompatible variable type [9]: batch_size is declared to have type `int` but is used as type `None`.",
    "message": " batch_size is declared to have type `int` but is used as type `None`.",
    "rule_id": "Incompatible variable type [9]",
    "warning_line_no": 116,
    "warning_line": "                 batch_size: int = None,",
    "min_patch": [
      {
        "hunk_fit_TFix": true,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "                 n_rnn_layers: int = 1,\n                 hidden_fc_size: List = None,\n                 dropout: float = 0.,\n                 batch_size: int = None,\n                 n_epochs: int = 800,\n",
        "source_code_len": 203,
        "target_code": "                 n_rnn_layers: int = 1,\n                 hidden_fc_sizes: Optional[List] = None,\n                 dropout: float = 0.,\n                 batch_size: int = 32,\n                 n_epochs: int = 800,\n",
        "target_code_len": 212,
        "diff_format": "@@ -113,5 +179,5 @@\n                  n_rnn_layers: int = 1,\n-                 hidden_fc_size: List = None,\n+                 hidden_fc_sizes: Optional[List] = None,\n                  dropout: float = 0.,\n-                 batch_size: int = None,\n+                 batch_size: int = 32,\n                  n_epochs: int = 800,\n",
        "source_code_with_indent": "                 n_rnn_layers: int = 1,\n                 hidden_fc_size: List = None,\n                 dropout: float = 0.,\n                 batch_size: int = None,\n                 n_epochs: int = 800,\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "                 n_rnn_layers: int = 1,\n                 hidden_fc_sizes: Optional[List] = None,\n                 dropout: float = 0.,\n                 batch_size: int = 32,\n                 n_epochs: int = 800,\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "unit8co/darts",
    "commit": "2139a0f40d032b936c76158b01f6f48656567a0c",
    "filename": "u8timeseries/models/RNN_model.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/unit8co-darts/u8timeseries/models/rnn_model.py",
    "file_hunks_size": 15,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "u8timeseries/models/RNN_model.py:119:17 Incompatible variable type [9]: optimizer_kwargs is declared to have type `Dict[typing.Any, typing.Any]` but is used as type `None`.",
    "message": " optimizer_kwargs is declared to have type `Dict[typing.Any, typing.Any]` but is used as type `None`.",
    "rule_id": "Incompatible variable type [9]",
    "warning_line_no": 119,
    "warning_line": "                 optimizer_kwargs: Dict = None,"
  },
  {
    "project": "unit8co/darts",
    "commit": "2139a0f40d032b936c76158b01f6f48656567a0c",
    "filename": "u8timeseries/models/RNN_model.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/unit8co-darts/u8timeseries/models/rnn_model.py",
    "file_hunks_size": 15,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "u8timeseries/models/RNN_model.py:427:29 Incompatible variable type [9]: filename is declared to have type `str` but is used as type `None`.",
    "message": " filename is declared to have type `str` but is used as type `None`.",
    "rule_id": "Incompatible variable type [9]",
    "warning_line_no": 427,
    "warning_line": "                             filename: str = None,"
  },
  {
    "project": "unit8co/darts",
    "commit": "2139a0f40d032b936c76158b01f6f48656567a0c",
    "filename": "u8timeseries/models/prophet.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/unit8co-darts/u8timeseries/models/prophet.py",
    "file_hunks_size": 6,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "u8timeseries/models/prophet.py:37:23 Incompatible variable type [9]: frequency is declared to have type `int` but is used as type `None`.",
    "message": " frequency is declared to have type `int` but is used as type `None`.",
    "rule_id": "Incompatible variable type [9]",
    "warning_line_no": 37,
    "warning_line": "    def __init__(self, frequency: int = None, yearly_seasonality=False, weekly_seasonality=False,"
  },
  {
    "project": "unit8co/darts",
    "commit": "2139a0f40d032b936c76158b01f6f48656567a0c",
    "filename": "u8timeseries/models/prophet.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/unit8co-darts/u8timeseries/models/prophet.py",
    "file_hunks_size": 6,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "u8timeseries/models/prophet.py:38:42 Incompatible variable type [9]: country_holidays is declared to have type `str` but is used as type `None`.",
    "message": " country_holidays is declared to have type `str` but is used as type `None`.",
    "rule_id": "Incompatible variable type [9]",
    "warning_line_no": 38,
    "warning_line": "                 daily_seasonality=False, country_holidays: str = None, mode: str = \"additive\"):"
  },
  {
    "project": "unit8co/darts",
    "commit": "2139a0f40d032b936c76158b01f6f48656567a0c",
    "filename": "u8timeseries/models/statistics.py",
    "min_patch_found": false,
    "full_warning_msg": "u8timeseries/models/statistics.py:21:40 Incompatible variable type [9]: m is declared to have type `int` but is used as type `None`.",
    "exception": "[Errno 2] No such file or directory: '/home/chowyi/TypeAnnotation_Study/GitHub/unit8co-darts/u8timeseries/models/statistics.py'",
    "dd_fail": true
  },
  {
    "project": "unit8co/darts",
    "commit": "2139a0f40d032b936c76158b01f6f48656567a0c",
    "filename": "u8timeseries/models/statistics.py",
    "min_patch_found": false,
    "full_warning_msg": "u8timeseries/models/statistics.py:108:52 Incompatible variable type [9]: freq is declared to have type `int` but is used as type `None`.",
    "exception": "[Errno 2] No such file or directory: '/home/chowyi/TypeAnnotation_Study/GitHub/unit8co-darts/u8timeseries/models/statistics.py'",
    "dd_fail": true
  },
  {
    "project": "unit8co/darts",
    "commit": "2139a0f40d032b936c76158b01f6f48656567a0c",
    "filename": "u8timeseries/models/statistics.py",
    "min_patch_found": false,
    "full_warning_msg": "u8timeseries/models/statistics.py:148:41 Incompatible variable type [9]: freq is declared to have type `int` but is used as type `None`.",
    "exception": "[Errno 2] No such file or directory: '/home/chowyi/TypeAnnotation_Study/GitHub/unit8co-darts/u8timeseries/models/statistics.py'",
    "dd_fail": true
  },
  {
    "project": "unit8co/darts",
    "commit": "2139a0f40d032b936c76158b01f6f48656567a0c",
    "filename": "u8timeseries/models/statistics.py",
    "min_patch_found": false,
    "full_warning_msg": "u8timeseries/models/statistics.py:183:31 Incompatible variable type [9]: m is declared to have type `int` but is used as type `None`.",
    "exception": "[Errno 2] No such file or directory: '/home/chowyi/TypeAnnotation_Study/GitHub/unit8co-darts/u8timeseries/models/statistics.py'",
    "dd_fail": true
  },
  {
    "project": "unit8co/darts",
    "commit": "2139a0f40d032b936c76158b01f6f48656567a0c",
    "filename": "u8timeseries/timeseries.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/unit8co-darts/u8timeseries/timeseries.py",
    "file_hunks_size": 59,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": true,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "u8timeseries/timeseries.py:548:12 Incompatible return type [7]: Expected `TimeSeries` but got `None`.",
    "message": " Expected `TimeSeries` but got `None`.",
    "rule_id": "Incompatible return type [7]",
    "warning_line_no": 548,
    "warning_line": "            return None",
    "min_patch": [
      {
        "hunk_fit_TFix": true,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "                self._confidence_hi.update(conf_hi)\n            return None\n        else:\n",
        "source_code_len": 90,
        "target_code": "                self._confidence_hi.update(conf_hi)\n            return self\n        else:\n",
        "target_code_len": 90,
        "diff_format": "@@ -547,3 +721,3 @@\n                 self._confidence_hi.update(conf_hi)\n-            return None\n+            return self\n         else:\n",
        "source_code_with_indent": "                <IND>self._confidence_hi.update(conf_hi)\n            <DED>return None\n        <DED>else:\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "                <IND>self._confidence_hi.update(conf_hi)\n            <DED>return self\n        <DED>else:\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "unit8co/darts",
    "commit": "2139a0f40d032b936c76158b01f6f48656567a0c",
    "filename": "u8timeseries/utils/missing_values.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/unit8co-darts/u8timeseries/utils/missing_values.py",
    "file_hunks_size": 4,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "u8timeseries/utils/missing_values.py:66:34 Incompatible variable type [9]: first is declared to have type `float` but is used as type `None`.",
    "message": " first is declared to have type `float` but is used as type `None`.",
    "rule_id": "Incompatible variable type [9]",
    "warning_line_no": 66,
    "warning_line": "def auto_fillna(ts: 'TimeSeries', first: float = None, last: float = None,",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\ndef nan_structure_visual(ts: 'TimeSeries', plot: bool = True) -> np.ndarray:\n    \"\"\"\n    Plots the indicator function of missing values of `ts`.\n\n    Missing values have value 1 and non-missing values are 0.\n\n    :param ts: The TimeSeries to check.\n    :param plot: Boolean to choose to plot the result or not.\n    :return: An numpy array containing the indices where the missing values are.\n    \"\"\"\n\n    nans = np.isnan(ts.values())\n\n    if plot:  # TODO: find a better way to visualize NaN data\n        plt.scatter(np.arange(len(nans)), nans)\n        plt.yticks([0, 1], [\"Non-missing\", \"NaN\"])\n        plt.show()\n\n    return np.where(nans)[0]\n\n\ndef change_of_state(ts: 'TimeSeries') -> Tuple[int, List]:\n    \"\"\"\n    Determines the indices where `ts` changes from missing values to non-missing and vice-versa.\n\n    :param ts: The TimeSeries to analyze.\n    :return: A tuple (a, l), where a is the number of change of states and l is the list of indices where \\\n    changes of states occur.\n    \"\"\"\n\n    a = np.where(np.diff(ts.pd_series().isna()))\n\n    return len(a[0]), list(a[0])\n\n\ndef auto_fillna(ts: 'TimeSeries', first: float = None, last: float = None,\n                interpolate: str = 'linear', **kwargs) -> 'TimeSeries':\n    \"\"\"\n    This function automatically fills the missing value in the TimeSeries `ts`, assuming they are represented by np.nan.\n\n    The rules for completion are given below.\n\n    Missing values at the beginning are filled with constant value `first`. Defaults to backwards-fill.\n    Missing values at the end are filled with constant value `last`. Defaults to forward-fill.\n    Missing values between to numeric values are set using the interpolation wrapper of pandas with `method`.\n    Defaults to linear interpolation.\n\n    Add the option `fill_value` to 'extrapolate' to fill the missing values at the beginning and the end with\n    the regression function computed. Must set `first` and `last` to None\n\n    .. todo: be more flexible on the filling methods.\n\n    :param ts: A TimeSeries `ts`.\n    :param first: The value to use for filling the beginning of the TimeSeries. Defaults to first known value in `ts`.\n    :param last: The value to use for filling the ending of the TimeSeries. Defaults to last known value in `ts`.\n    :param interpolate: The function used for filling the middle of the TimeSeries. Defaults to linear interpolation.\n    :return: A new TimeSeries with all missing values filled according to the rules above.\n    \"\"\"\n\n    # We compute the number of times entries of the TimeSeries go from missing to numeric and vice-versa\n    arr = change_of_state(ts)[1]\n\n    if len(arr) == 0:\n        return ts\n\n",
        "source_code_len": 2663,
        "target_code": "\ndef auto_fillna(ts: TimeSeries,\n                **interpolate_kwargs) -> TimeSeries:\n    \"\"\"\n    This function fills the missing value in the TimeSeries `ts`,\n    using the `pandas.Series.interpolate()` method.\n\n    Parameters\n    ----------\n    ts\n        The time series\n    interpolate_kwargs\n        Keyword arguments  `pandas.Series.interpolate()`.\n        See `the documentation\n        <https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.interpolate.html>`_\n        for the list of supported parameters.\n    Returns\n    -------\n    TimeSeries\n        A new TimeSeries with all missing values filled according to the rules above.\n    \"\"\"\n\n",
        "target_code_len": 668,
        "diff_format": "@@ -30,66 +40,22 @@\n \n-def nan_structure_visual(ts: 'TimeSeries', plot: bool = True) -> np.ndarray:\n+def auto_fillna(ts: TimeSeries,\n+                **interpolate_kwargs) -> TimeSeries:\n     \"\"\"\n-    Plots the indicator function of missing values of `ts`.\n+    This function fills the missing value in the TimeSeries `ts`,\n+    using the `pandas.Series.interpolate()` method.\n \n-    Missing values have value 1 and non-missing values are 0.\n-\n-    :param ts: The TimeSeries to check.\n-    :param plot: Boolean to choose to plot the result or not.\n-    :return: An numpy array containing the indices where the missing values are.\n+    Parameters\n+    ----------\n+    ts\n+        The time series\n+    interpolate_kwargs\n+        Keyword arguments  `pandas.Series.interpolate()`.\n+        See `the documentation\n+        <https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.interpolate.html>`_\n+        for the list of supported parameters.\n+    Returns\n+    -------\n+    TimeSeries\n+        A new TimeSeries with all missing values filled according to the rules above.\n     \"\"\"\n-\n-    nans = np.isnan(ts.values())\n-\n-    if plot:  # TODO: find a better way to visualize NaN data\n-        plt.scatter(np.arange(len(nans)), nans)\n-        plt.yticks([0, 1], [\"Non-missing\", \"NaN\"])\n-        plt.show()\n-\n-    return np.where(nans)[0]\n-\n-\n-def change_of_state(ts: 'TimeSeries') -> Tuple[int, List]:\n-    \"\"\"\n-    Determines the indices where `ts` changes from missing values to non-missing and vice-versa.\n-\n-    :param ts: The TimeSeries to analyze.\n-    :return: A tuple (a, l), where a is the number of change of states and l is the list of indices where \\\n-    changes of states occur.\n-    \"\"\"\n-\n-    a = np.where(np.diff(ts.pd_series().isna()))\n-\n-    return len(a[0]), list(a[0])\n-\n-\n-def auto_fillna(ts: 'TimeSeries', first: float = None, last: float = None,\n-                interpolate: str = 'linear', **kwargs) -> 'TimeSeries':\n-    \"\"\"\n-    This function automatically fills the missing value in the TimeSeries `ts`, assuming they are represented by np.nan.\n-\n-    The rules for completion are given below.\n-\n-    Missing values at the beginning are filled with constant value `first`. Defaults to backwards-fill.\n-    Missing values at the end are filled with constant value `last`. Defaults to forward-fill.\n-    Missing values between to numeric values are set using the interpolation wrapper of pandas with `method`.\n-    Defaults to linear interpolation.\n-\n-    Add the option `fill_value` to 'extrapolate' to fill the missing values at the beginning and the end with\n-    the regression function computed. Must set `first` and `last` to None\n-\n-    .. todo: be more flexible on the filling methods.\n-\n-    :param ts: A TimeSeries `ts`.\n-    :param first: The value to use for filling the beginning of the TimeSeries. Defaults to first known value in `ts`.\n-    :param last: The value to use for filling the ending of the TimeSeries. Defaults to last known value in `ts`.\n-    :param interpolate: The function used for filling the middle of the TimeSeries. Defaults to linear interpolation.\n-    :return: A new TimeSeries with all missing values filled according to the rules above.\n-    \"\"\"\n-\n-    # We compute the number of times entries of the TimeSeries go from missing to numeric and vice-versa\n-    arr = change_of_state(ts)[1]\n-\n-    if len(arr) == 0:\n-        return ts\n \n",
        "source_code_with_indent": "\n<DED>def nan_structure_visual(ts: 'TimeSeries', plot: bool = True) -> np.ndarray:\n    <IND>\"\"\"\n    Plots the indicator function of missing values of `ts`.\n\n    Missing values have value 1 and non-missing values are 0.\n\n    :param ts: The TimeSeries to check.\n    :param plot: Boolean to choose to plot the result or not.\n    :return: An numpy array containing the indices where the missing values are.\n    \"\"\"\n\n    nans = np.isnan(ts.values())\n\n    if plot:  # TODO: find a better way to visualize NaN data\n        <IND>plt.scatter(np.arange(len(nans)), nans)\n        plt.yticks([0, 1], [\"Non-missing\", \"NaN\"])\n        plt.show()\n\n    <DED>return np.where(nans)[0]\n\n\n<DED>def change_of_state(ts: 'TimeSeries') -> Tuple[int, List]:\n    <IND>\"\"\"\n    Determines the indices where `ts` changes from missing values to non-missing and vice-versa.\n\n    :param ts: The TimeSeries to analyze.\n    :return: A tuple (a, l), where a is the number of change of states and l is the list of indices where \\\n    changes of states occur.\n    \"\"\"\n\n    a = np.where(np.diff(ts.pd_series().isna()))\n\n    return len(a[0]), list(a[0])\n\n\n<DED>def auto_fillna(ts: 'TimeSeries', first: float = None, last: float = None,\n                interpolate: str = 'linear', **kwargs) -> 'TimeSeries':\n    <IND>\"\"\"\n    This function automatically fills the missing value in the TimeSeries `ts`, assuming they are represented by np.nan.\n\n    The rules for completion are given below.\n\n    Missing values at the beginning are filled with constant value `first`. Defaults to backwards-fill.\n    Missing values at the end are filled with constant value `last`. Defaults to forward-fill.\n    Missing values between to numeric values are set using the interpolation wrapper of pandas with `method`.\n    Defaults to linear interpolation.\n\n    Add the option `fill_value` to 'extrapolate' to fill the missing values at the beginning and the end with\n    the regression function computed. Must set `first` and `last` to None\n\n    .. todo: be more flexible on the filling methods.\n\n    :param ts: A TimeSeries `ts`.\n    :param first: The value to use for filling the beginning of the TimeSeries. Defaults to first known value in `ts`.\n    :param last: The value to use for filling the ending of the TimeSeries. Defaults to last known value in `ts`.\n    :param interpolate: The function used for filling the middle of the TimeSeries. Defaults to linear interpolation.\n    :return: A new TimeSeries with all missing values filled according to the rules above.\n    \"\"\"\n\n    # We compute the number of times entries of the TimeSeries go from missing to numeric and vice-versa\n    arr = change_of_state(ts)[1]\n\n    if len(arr) == 0:\n        <IND>return ts\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n<DED>def auto_fillna(ts: TimeSeries,\n                **interpolate_kwargs) -> TimeSeries:\n    <IND>\"\"\"\n    This function fills the missing value in the TimeSeries `ts`,\n    using the `pandas.Series.interpolate()` method.\n\n    Parameters\n    ----------\n    ts\n        The time series\n    interpolate_kwargs\n        Keyword arguments  `pandas.Series.interpolate()`.\n        See `the documentation\n        <https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.interpolate.html>`_\n        for the list of supported parameters.\n    Returns\n    -------\n    TimeSeries\n        A new TimeSeries with all missing values filled according to the rules above.\n    \"\"\"\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n    # if first value is missing and `first` is specified, fill values\n    if np.isnan(ts.values()[0]) and first is not None:\n        ts_temp[:arr[0] + 1] = first\n\n    # if last value is missing and `last` is specified, fill values\n    if np.isnan(ts.values()[-1]) and last is not None:\n        ts_temp[arr[-1] + 1:] = last\n\n    # pandas interpolate wrapper, with chosen `method`\n    ts_temp.interpolate(method=interpolate, inplace=True, limit_direction='both', limit=len(ts_temp), **kwargs)\n\n",
        "source_code_len": 493,
        "target_code": "\n    # pandas interpolate wrapper, with chosen `method`\n    if 'limit_direction' not in interpolate_kwargs:\n        interpolate_kwargs['limit_direction'] = 'both'\n    interpolate_kwargs['inplace'] = True\n    ts_temp.interpolate(**interpolate_kwargs)\n\n",
        "target_code_len": 251,
        "diff_format": "@@ -97,12 +63,7 @@\n \n-    # if first value is missing and `first` is specified, fill values\n-    if np.isnan(ts.values()[0]) and first is not None:\n-        ts_temp[:arr[0] + 1] = first\n-\n-    # if last value is missing and `last` is specified, fill values\n-    if np.isnan(ts.values()[-1]) and last is not None:\n-        ts_temp[arr[-1] + 1:] = last\n-\n     # pandas interpolate wrapper, with chosen `method`\n-    ts_temp.interpolate(method=interpolate, inplace=True, limit_direction='both', limit=len(ts_temp), **kwargs)\n+    if 'limit_direction' not in interpolate_kwargs:\n+        interpolate_kwargs['limit_direction'] = 'both'\n+    interpolate_kwargs['inplace'] = True\n+    ts_temp.interpolate(**interpolate_kwargs)\n \n",
        "source_code_with_indent": "\n    # if first value is missing and `first` is specified, fill values\n    if np.isnan(ts.values()[0]) and first is not None:\n        <IND>ts_temp[:arr[0] + 1] = first\n\n    # if last value is missing and `last` is specified, fill values\n    <DED>if np.isnan(ts.values()[-1]) and last is not None:\n        <IND>ts_temp[arr[-1] + 1:] = last\n\n    # pandas interpolate wrapper, with chosen `method`\n    <DED>ts_temp.interpolate(method=interpolate, inplace=True, limit_direction='both', limit=len(ts_temp), **kwargs)\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n    # pandas interpolate wrapper, with chosen `method`\n    if 'limit_direction' not in interpolate_kwargs:\n        <IND>interpolate_kwargs['limit_direction'] = 'both'\n    <DED>interpolate_kwargs['inplace'] = True\n    ts_temp.interpolate(**interpolate_kwargs)\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "unit8co/darts",
    "commit": "2139a0f40d032b936c76158b01f6f48656567a0c",
    "filename": "u8timeseries/utils/missing_values.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/unit8co-darts/u8timeseries/utils/missing_values.py",
    "file_hunks_size": 4,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "u8timeseries/utils/missing_values.py:66:55 Incompatible variable type [9]: last is declared to have type `float` but is used as type `None`.",
    "message": " last is declared to have type `float` but is used as type `None`.",
    "rule_id": "Incompatible variable type [9]",
    "warning_line_no": 66,
    "warning_line": "def auto_fillna(ts: 'TimeSeries', first: float = None, last: float = None,",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\ndef nan_structure_visual(ts: 'TimeSeries', plot: bool = True) -> np.ndarray:\n    \"\"\"\n    Plots the indicator function of missing values of `ts`.\n\n    Missing values have value 1 and non-missing values are 0.\n\n    :param ts: The TimeSeries to check.\n    :param plot: Boolean to choose to plot the result or not.\n    :return: An numpy array containing the indices where the missing values are.\n    \"\"\"\n\n    nans = np.isnan(ts.values())\n\n    if plot:  # TODO: find a better way to visualize NaN data\n        plt.scatter(np.arange(len(nans)), nans)\n        plt.yticks([0, 1], [\"Non-missing\", \"NaN\"])\n        plt.show()\n\n    return np.where(nans)[0]\n\n\ndef change_of_state(ts: 'TimeSeries') -> Tuple[int, List]:\n    \"\"\"\n    Determines the indices where `ts` changes from missing values to non-missing and vice-versa.\n\n    :param ts: The TimeSeries to analyze.\n    :return: A tuple (a, l), where a is the number of change of states and l is the list of indices where \\\n    changes of states occur.\n    \"\"\"\n\n    a = np.where(np.diff(ts.pd_series().isna()))\n\n    return len(a[0]), list(a[0])\n\n\ndef auto_fillna(ts: 'TimeSeries', first: float = None, last: float = None,\n                interpolate: str = 'linear', **kwargs) -> 'TimeSeries':\n    \"\"\"\n    This function automatically fills the missing value in the TimeSeries `ts`, assuming they are represented by np.nan.\n\n    The rules for completion are given below.\n\n    Missing values at the beginning are filled with constant value `first`. Defaults to backwards-fill.\n    Missing values at the end are filled with constant value `last`. Defaults to forward-fill.\n    Missing values between to numeric values are set using the interpolation wrapper of pandas with `method`.\n    Defaults to linear interpolation.\n\n    Add the option `fill_value` to 'extrapolate' to fill the missing values at the beginning and the end with\n    the regression function computed. Must set `first` and `last` to None\n\n    .. todo: be more flexible on the filling methods.\n\n    :param ts: A TimeSeries `ts`.\n    :param first: The value to use for filling the beginning of the TimeSeries. Defaults to first known value in `ts`.\n    :param last: The value to use for filling the ending of the TimeSeries. Defaults to last known value in `ts`.\n    :param interpolate: The function used for filling the middle of the TimeSeries. Defaults to linear interpolation.\n    :return: A new TimeSeries with all missing values filled according to the rules above.\n    \"\"\"\n\n    # We compute the number of times entries of the TimeSeries go from missing to numeric and vice-versa\n    arr = change_of_state(ts)[1]\n\n    if len(arr) == 0:\n        return ts\n\n",
        "source_code_len": 2663,
        "target_code": "\ndef auto_fillna(ts: TimeSeries,\n                **interpolate_kwargs) -> TimeSeries:\n    \"\"\"\n    This function fills the missing value in the TimeSeries `ts`,\n    using the `pandas.Series.interpolate()` method.\n\n    Parameters\n    ----------\n    ts\n        The time series\n    interpolate_kwargs\n        Keyword arguments  `pandas.Series.interpolate()`.\n        See `the documentation\n        <https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.interpolate.html>`_\n        for the list of supported parameters.\n    Returns\n    -------\n    TimeSeries\n        A new TimeSeries with all missing values filled according to the rules above.\n    \"\"\"\n\n",
        "target_code_len": 668,
        "diff_format": "@@ -30,66 +40,22 @@\n \n-def nan_structure_visual(ts: 'TimeSeries', plot: bool = True) -> np.ndarray:\n+def auto_fillna(ts: TimeSeries,\n+                **interpolate_kwargs) -> TimeSeries:\n     \"\"\"\n-    Plots the indicator function of missing values of `ts`.\n+    This function fills the missing value in the TimeSeries `ts`,\n+    using the `pandas.Series.interpolate()` method.\n \n-    Missing values have value 1 and non-missing values are 0.\n-\n-    :param ts: The TimeSeries to check.\n-    :param plot: Boolean to choose to plot the result or not.\n-    :return: An numpy array containing the indices where the missing values are.\n+    Parameters\n+    ----------\n+    ts\n+        The time series\n+    interpolate_kwargs\n+        Keyword arguments  `pandas.Series.interpolate()`.\n+        See `the documentation\n+        <https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.interpolate.html>`_\n+        for the list of supported parameters.\n+    Returns\n+    -------\n+    TimeSeries\n+        A new TimeSeries with all missing values filled according to the rules above.\n     \"\"\"\n-\n-    nans = np.isnan(ts.values())\n-\n-    if plot:  # TODO: find a better way to visualize NaN data\n-        plt.scatter(np.arange(len(nans)), nans)\n-        plt.yticks([0, 1], [\"Non-missing\", \"NaN\"])\n-        plt.show()\n-\n-    return np.where(nans)[0]\n-\n-\n-def change_of_state(ts: 'TimeSeries') -> Tuple[int, List]:\n-    \"\"\"\n-    Determines the indices where `ts` changes from missing values to non-missing and vice-versa.\n-\n-    :param ts: The TimeSeries to analyze.\n-    :return: A tuple (a, l), where a is the number of change of states and l is the list of indices where \\\n-    changes of states occur.\n-    \"\"\"\n-\n-    a = np.where(np.diff(ts.pd_series().isna()))\n-\n-    return len(a[0]), list(a[0])\n-\n-\n-def auto_fillna(ts: 'TimeSeries', first: float = None, last: float = None,\n-                interpolate: str = 'linear', **kwargs) -> 'TimeSeries':\n-    \"\"\"\n-    This function automatically fills the missing value in the TimeSeries `ts`, assuming they are represented by np.nan.\n-\n-    The rules for completion are given below.\n-\n-    Missing values at the beginning are filled with constant value `first`. Defaults to backwards-fill.\n-    Missing values at the end are filled with constant value `last`. Defaults to forward-fill.\n-    Missing values between to numeric values are set using the interpolation wrapper of pandas with `method`.\n-    Defaults to linear interpolation.\n-\n-    Add the option `fill_value` to 'extrapolate' to fill the missing values at the beginning and the end with\n-    the regression function computed. Must set `first` and `last` to None\n-\n-    .. todo: be more flexible on the filling methods.\n-\n-    :param ts: A TimeSeries `ts`.\n-    :param first: The value to use for filling the beginning of the TimeSeries. Defaults to first known value in `ts`.\n-    :param last: The value to use for filling the ending of the TimeSeries. Defaults to last known value in `ts`.\n-    :param interpolate: The function used for filling the middle of the TimeSeries. Defaults to linear interpolation.\n-    :return: A new TimeSeries with all missing values filled according to the rules above.\n-    \"\"\"\n-\n-    # We compute the number of times entries of the TimeSeries go from missing to numeric and vice-versa\n-    arr = change_of_state(ts)[1]\n-\n-    if len(arr) == 0:\n-        return ts\n \n",
        "source_code_with_indent": "\n<DED>def nan_structure_visual(ts: 'TimeSeries', plot: bool = True) -> np.ndarray:\n    <IND>\"\"\"\n    Plots the indicator function of missing values of `ts`.\n\n    Missing values have value 1 and non-missing values are 0.\n\n    :param ts: The TimeSeries to check.\n    :param plot: Boolean to choose to plot the result or not.\n    :return: An numpy array containing the indices where the missing values are.\n    \"\"\"\n\n    nans = np.isnan(ts.values())\n\n    if plot:  # TODO: find a better way to visualize NaN data\n        <IND>plt.scatter(np.arange(len(nans)), nans)\n        plt.yticks([0, 1], [\"Non-missing\", \"NaN\"])\n        plt.show()\n\n    <DED>return np.where(nans)[0]\n\n\n<DED>def change_of_state(ts: 'TimeSeries') -> Tuple[int, List]:\n    <IND>\"\"\"\n    Determines the indices where `ts` changes from missing values to non-missing and vice-versa.\n\n    :param ts: The TimeSeries to analyze.\n    :return: A tuple (a, l), where a is the number of change of states and l is the list of indices where \\\n    changes of states occur.\n    \"\"\"\n\n    a = np.where(np.diff(ts.pd_series().isna()))\n\n    return len(a[0]), list(a[0])\n\n\n<DED>def auto_fillna(ts: 'TimeSeries', first: float = None, last: float = None,\n                interpolate: str = 'linear', **kwargs) -> 'TimeSeries':\n    <IND>\"\"\"\n    This function automatically fills the missing value in the TimeSeries `ts`, assuming they are represented by np.nan.\n\n    The rules for completion are given below.\n\n    Missing values at the beginning are filled with constant value `first`. Defaults to backwards-fill.\n    Missing values at the end are filled with constant value `last`. Defaults to forward-fill.\n    Missing values between to numeric values are set using the interpolation wrapper of pandas with `method`.\n    Defaults to linear interpolation.\n\n    Add the option `fill_value` to 'extrapolate' to fill the missing values at the beginning and the end with\n    the regression function computed. Must set `first` and `last` to None\n\n    .. todo: be more flexible on the filling methods.\n\n    :param ts: A TimeSeries `ts`.\n    :param first: The value to use for filling the beginning of the TimeSeries. Defaults to first known value in `ts`.\n    :param last: The value to use for filling the ending of the TimeSeries. Defaults to last known value in `ts`.\n    :param interpolate: The function used for filling the middle of the TimeSeries. Defaults to linear interpolation.\n    :return: A new TimeSeries with all missing values filled according to the rules above.\n    \"\"\"\n\n    # We compute the number of times entries of the TimeSeries go from missing to numeric and vice-versa\n    arr = change_of_state(ts)[1]\n\n    if len(arr) == 0:\n        <IND>return ts\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n<DED>def auto_fillna(ts: TimeSeries,\n                **interpolate_kwargs) -> TimeSeries:\n    <IND>\"\"\"\n    This function fills the missing value in the TimeSeries `ts`,\n    using the `pandas.Series.interpolate()` method.\n\n    Parameters\n    ----------\n    ts\n        The time series\n    interpolate_kwargs\n        Keyword arguments  `pandas.Series.interpolate()`.\n        See `the documentation\n        <https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.interpolate.html>`_\n        for the list of supported parameters.\n    Returns\n    -------\n    TimeSeries\n        A new TimeSeries with all missing values filled according to the rules above.\n    \"\"\"\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n    # if first value is missing and `first` is specified, fill values\n    if np.isnan(ts.values()[0]) and first is not None:\n        ts_temp[:arr[0] + 1] = first\n\n    # if last value is missing and `last` is specified, fill values\n    if np.isnan(ts.values()[-1]) and last is not None:\n        ts_temp[arr[-1] + 1:] = last\n\n    # pandas interpolate wrapper, with chosen `method`\n    ts_temp.interpolate(method=interpolate, inplace=True, limit_direction='both', limit=len(ts_temp), **kwargs)\n\n",
        "source_code_len": 493,
        "target_code": "\n    # pandas interpolate wrapper, with chosen `method`\n    if 'limit_direction' not in interpolate_kwargs:\n        interpolate_kwargs['limit_direction'] = 'both'\n    interpolate_kwargs['inplace'] = True\n    ts_temp.interpolate(**interpolate_kwargs)\n\n",
        "target_code_len": 251,
        "diff_format": "@@ -97,12 +63,7 @@\n \n-    # if first value is missing and `first` is specified, fill values\n-    if np.isnan(ts.values()[0]) and first is not None:\n-        ts_temp[:arr[0] + 1] = first\n-\n-    # if last value is missing and `last` is specified, fill values\n-    if np.isnan(ts.values()[-1]) and last is not None:\n-        ts_temp[arr[-1] + 1:] = last\n-\n     # pandas interpolate wrapper, with chosen `method`\n-    ts_temp.interpolate(method=interpolate, inplace=True, limit_direction='both', limit=len(ts_temp), **kwargs)\n+    if 'limit_direction' not in interpolate_kwargs:\n+        interpolate_kwargs['limit_direction'] = 'both'\n+    interpolate_kwargs['inplace'] = True\n+    ts_temp.interpolate(**interpolate_kwargs)\n \n",
        "source_code_with_indent": "\n    # if first value is missing and `first` is specified, fill values\n    if np.isnan(ts.values()[0]) and first is not None:\n        <IND>ts_temp[:arr[0] + 1] = first\n\n    # if last value is missing and `last` is specified, fill values\n    <DED>if np.isnan(ts.values()[-1]) and last is not None:\n        <IND>ts_temp[arr[-1] + 1:] = last\n\n    # pandas interpolate wrapper, with chosen `method`\n    <DED>ts_temp.interpolate(method=interpolate, inplace=True, limit_direction='both', limit=len(ts_temp), **kwargs)\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n    # pandas interpolate wrapper, with chosen `method`\n    if 'limit_direction' not in interpolate_kwargs:\n        <IND>interpolate_kwargs['limit_direction'] = 'both'\n    <DED>interpolate_kwargs['inplace'] = True\n    ts_temp.interpolate(**interpolate_kwargs)\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  }
]