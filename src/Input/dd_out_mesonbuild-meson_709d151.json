[
  {
    "project": "mesonbuild/meson",
    "commit": "709d151eb944d764b35008ca3275b02bd16a765d",
    "filename": "mesonbuild/interpreterbase/decorators.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/mesonbuild-meson/mesonbuild/interpreterbase/decorators.py",
    "file_hunks_size": 8,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "mesonbuild/interpreterbase/decorators.py:474:49 Incompatible parameter type [6]: Expected `T.Union[T.Type[typing.Any], typing.Tuple[T.Type[typing.Any], ...]]` for 2nd positional only parameter to call `isinstance` but got `T.Union[T.Type[typing.Any], ContainerTypeInfo, typing.Tuple[T.Type[typing.Any], ...]]`.",
    "message": " Expected `T.Union[T.Type[typing.Any], typing.Tuple[T.Type[typing.Any], ...]]` for 2nd positional only parameter to call `isinstance` but got `T.Union[T.Type[typing.Any], ContainerTypeInfo, typing.Tuple[T.Type[typing.Any], ...]]`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 474,
    "warning_line": "                        if not isinstance(value, info.types):",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n    def check(self, value: T.Any) -> T.Optional[str]:\n        \"\"\"Check that a value is valid.\n",
        "source_code_len": 95,
        "target_code": "\n    def check(self, value: T.Any) -> bool:\n        \"\"\"Check that a value is valid.\n",
        "target_code_len": 84,
        "diff_format": "@@ -304,3 +305,3 @@\n \n-    def check(self, value: T.Any) -> T.Optional[str]:\n+    def check(self, value: T.Any) -> bool:\n         \"\"\"Check that a value is valid.\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\n    <DED>def check(self, value: T.Any) -> T.Optional[str]:\n        <IND>",
        "target_code_with_indent": "\n    <DED>def check(self, value: T.Any) -> bool:\n        <IND>"
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "        :param value: A value to check\n        :return: If there is an error then a string message, otherwise None\n        \"\"\"\n        if not isinstance(value, self.container):\n            return f'container type was \"{type(value).__name__}\", but should have been \"{self.container.__name__}\"'\n        iter_ = iter(value.values()) if isinstance(value, dict) else iter(value)\n",
        "source_code_len": 374,
        "target_code": "        :param value: A value to check\n        :return: True if it is valid, False otherwise\n        \"\"\"\n        if not isinstance(value, self.container):\n            return False\n        iter_ = iter(value.values()) if isinstance(value, dict) else iter(value)\n",
        "target_code_len": 261,
        "diff_format": "@@ -308,6 +309,6 @@\n         :param value: A value to check\n-        :return: If there is an error then a string message, otherwise None\n+        :return: True if it is valid, False otherwise\n         \"\"\"\n         if not isinstance(value, self.container):\n-            return f'container type was \"{type(value).__name__}\", but should have been \"{self.container.__name__}\"'\n+            return False\n         iter_ = iter(value.values()) if isinstance(value, dict) else iter(value)\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\n        if not isinstance(value, self.container):\n            <IND>return f'container type was \"{type(value).__name__}\", but should have been \"{self.container.__name__}\"'\n        <DED>iter_ = iter(value.values()) if isinstance(value, dict) else iter(value)\n",
        "target_code_with_indent": "\n        if not isinstance(value, self.container):\n            <IND>return False\n        <DED>iter_ = iter(value.values()) if isinstance(value, dict) else iter(value)\n"
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "            if not isinstance(each, self.contains):\n                if isinstance(self.contains, tuple):\n                    shouldbe = 'one of: {}'.format(\", \".join(f'\"{t.__name__}\"' for t in self.contains))\n                else:\n                    shouldbe = f'\"{self.contains.__name__}\"'\n                return f'contained a value of type \"{type(each).__name__}\" but should have been {shouldbe}'\n        if self.pairs and len(value) % 2 != 0:\n            return 'container should be of even length, but is not'\n        if not value and not self.allow_empty:\n            return 'container is empty, but not allowed to be'\n        return None\n\n\n",
        "source_code_len": 647,
        "target_code": "            if not isinstance(each, self.contains):\n                return False\n        if self.pairs and len(value) % 2 != 0:\n            return False\n        if not value and not self.allow_empty:\n            return False\n        return True\n\n    def description(self) -> str:\n        \"\"\"Human readable description of this container type.\n\n        :return: string to be printed\n        \"\"\"\n        container = 'dict' if self.container is dict else 'list'\n        if isinstance(self.contains, tuple):\n            contains = ','.join([t.__name__ for t in self.contains])\n        else:\n            contains = self.contains.__name__\n        s = f'{container}[{contains}]'\n        if self.pairs:\n            s += ' that has even size'\n        if not self.allow_empty:\n            s += ' that cannot be empty'\n        return s\n\n",
        "target_code_len": 825,
        "diff_format": "@@ -315,13 +316,25 @@\n             if not isinstance(each, self.contains):\n-                if isinstance(self.contains, tuple):\n-                    shouldbe = 'one of: {}'.format(\", \".join(f'\"{t.__name__}\"' for t in self.contains))\n-                else:\n-                    shouldbe = f'\"{self.contains.__name__}\"'\n-                return f'contained a value of type \"{type(each).__name__}\" but should have been {shouldbe}'\n+                return False\n         if self.pairs and len(value) % 2 != 0:\n-            return 'container should be of even length, but is not'\n+            return False\n         if not value and not self.allow_empty:\n-            return 'container is empty, but not allowed to be'\n-        return None\n-\n+            return False\n+        return True\n+\n+    def description(self) -> str:\n+        \"\"\"Human readable description of this container type.\n+\n+        :return: string to be printed\n+        \"\"\"\n+        container = 'dict' if self.container is dict else 'list'\n+        if isinstance(self.contains, tuple):\n+            contains = ','.join([t.__name__ for t in self.contains])\n+        else:\n+            contains = self.contains.__name__\n+        s = f'{container}[{contains}]'\n+        if self.pairs:\n+            s += ' that has even size'\n+        if not self.allow_empty:\n+            s += ' that cannot be empty'\n+        return s\n \n",
        "source_code_with_indent": "            <IND>if not isinstance(each, self.contains):\n                <IND>if isinstance(self.contains, tuple):\n                    <IND>shouldbe = 'one of: {}'.format(\", \".join(f'\"{t.__name__}\"' for t in self.contains))\n                <DED>else:\n                    <IND>shouldbe = f'\"{self.contains.__name__}\"'\n                <DED>return f'contained a value of type \"{type(each).__name__}\" but should have been {shouldbe}'\n        <DED><DED>if self.pairs and len(value) % 2 != 0:\n            <IND>return 'container should be of even length, but is not'\n        <DED>if not value and not self.allow_empty:\n            <IND>return 'container is empty, but not allowed to be'\n        <DED>return None\n\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "            <IND>if not isinstance(each, self.contains):\n                <IND>return False\n        <DED><DED>if self.pairs and len(value) % 2 != 0:\n            <IND>return False\n        <DED>if not value and not self.allow_empty:\n            <IND>return False\n        <DED>return True\n\n    <DED>def description(self) -> str:\n        <IND>\"\"\"Human readable description of this container type.\n\n        :return: string to be printed\n        \"\"\"\n        container = 'dict' if self.container is dict else 'list'\n        if isinstance(self.contains, tuple):\n            <IND>contains = ','.join([t.__name__ for t in self.contains])\n        <DED>else:\n            <IND>contains = self.contains.__name__\n        <DED>s = f'{container}[{contains}]'\n        if self.pairs:\n            <IND>s += ' that has even size'\n        <DED>if not self.allow_empty:\n            <IND>s += ' that cannot be empty'\n        <DED>return s\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "            for info in types:\n                value = kwargs.get(info.name)\n",
        "source_code_len": 77,
        "target_code": "            for info in types:\n                types_tuple = info.types if isinstance(info.types, tuple) else (info.types,)\n                def check_value_type(value: T.Any) -> bool:\n                    for t in types_tuple:\n                        if isinstance(t, ContainerTypeInfo):\n                            if t.check(value):\n                                return True\n                        elif isinstance(value, t):\n                            return True\n                    return False\n                def types_description() -> str:\n                    candidates = []\n                    for t in types_tuple:\n                        if isinstance(t, ContainerTypeInfo):\n                            candidates.append(t.description())\n                        else:\n                            candidates.append(t.__name__)\n                    shouldbe = 'one of: ' if len(candidates) > 1 else ''\n                    shouldbe += ', '.join(candidates)\n                    return shouldbe\n                value = kwargs.get(info.name)\n",
        "target_code_len": 1049,
        "diff_format": "@@ -458,2 +471,21 @@\n             for info in types:\n+                types_tuple = info.types if isinstance(info.types, tuple) else (info.types,)\n+                def check_value_type(value: T.Any) -> bool:\n+                    for t in types_tuple:\n+                        if isinstance(t, ContainerTypeInfo):\n+                            if t.check(value):\n+                                return True\n+                        elif isinstance(value, t):\n+                            return True\n+                    return False\n+                def types_description() -> str:\n+                    candidates = []\n+                    for t in types_tuple:\n+                        if isinstance(t, ContainerTypeInfo):\n+                            candidates.append(t.description())\n+                        else:\n+                            candidates.append(t.__name__)\n+                    shouldbe = 'one of: ' if len(candidates) > 1 else ''\n+                    shouldbe += ', '.join(candidates)\n+                    return shouldbe\n                 value = kwargs.get(info.name)\n",
        "source_code_with_indent": "            <DED>for info in types:\n                <IND>value = kwargs.get(info.name)\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "            <DED>for info in types:\n                <IND>types_tuple = info.types if isinstance(info.types, tuple) else (info.types,)\n                def check_value_type(value: T.Any) -> bool:\n                    <IND>for t in types_tuple:\n                        <IND>if isinstance(t, ContainerTypeInfo):\n                            <IND>if t.check(value):\n                                <IND>return True\n                        <DED><DED>elif isinstance(value, t):\n                            <IND>return True\n                    <DED><DED>return False\n                <DED>def types_description() -> str:\n                    <IND>candidates = []\n                    for t in types_tuple:\n                        <IND>if isinstance(t, ContainerTypeInfo):\n                            <IND>candidates.append(t.description())\n                        <DED>else:\n                            <IND>candidates.append(t.__name__)\n                    <DED><DED>shouldbe = 'one of: ' if len(candidates) > 1 else ''\n                    shouldbe += ', '.join(candidates)\n                    return shouldbe\n                <DED>value = kwargs.get(info.name)\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "                        kwargs[info.name] = value = mesonlib.listify(value)\n                    if isinstance(info.types, ContainerTypeInfo):\n                        msg = info.types.check(value)\n                        if msg is not None:\n                            raise InvalidArguments(f'{name} keyword argument \"{info.name}\" {msg}')\n                    else:\n                        if not isinstance(value, info.types):\n                            if isinstance(info.types, tuple):\n                                shouldbe = 'one of: {}'.format(\", \".join(f'\"{t.__name__}\"' for t in info.types))\n                            else:\n                                shouldbe = f'\"{info.types.__name__}\"'\n                            raise InvalidArguments(f'{name} keyword argument \"{info.name}\"\" was of type \"{type(value).__name__}\" but should have been {shouldbe}')\n\n",
        "source_code_len": 870,
        "target_code": "                        kwargs[info.name] = value = mesonlib.listify(value)\n                    if not check_value_type(value):\n                        shouldbe = types_description()\n                        raise InvalidArguments(f'{name} keyword argument {info.name!r} was of type {type(value).__name__!r} but should have been {shouldbe}')\n\n",
        "target_code_len": 342,
        "diff_format": "@@ -468,13 +500,5 @@\n                         kwargs[info.name] = value = mesonlib.listify(value)\n-                    if isinstance(info.types, ContainerTypeInfo):\n-                        msg = info.types.check(value)\n-                        if msg is not None:\n-                            raise InvalidArguments(f'{name} keyword argument \"{info.name}\" {msg}')\n-                    else:\n-                        if not isinstance(value, info.types):\n-                            if isinstance(info.types, tuple):\n-                                shouldbe = 'one of: {}'.format(\", \".join(f'\"{t.__name__}\"' for t in info.types))\n-                            else:\n-                                shouldbe = f'\"{info.types.__name__}\"'\n-                            raise InvalidArguments(f'{name} keyword argument \"{info.name}\"\" was of type \"{type(value).__name__}\" but should have been {shouldbe}')\n+                    if not check_value_type(value):\n+                        shouldbe = types_description()\n+                        raise InvalidArguments(f'{name} keyword argument {info.name!r} was of type {type(value).__name__!r} but should have been {shouldbe}')\n \n",
        "source_code_with_indent": "                        <IND>kwargs[info.name] = value = mesonlib.listify(value)\n                    <DED>if isinstance(info.types, ContainerTypeInfo):\n                        <IND>msg = info.types.check(value)\n                        if msg is not None:\n                            <IND>raise InvalidArguments(f'{name} keyword argument \"{info.name}\" {msg}')\n                    <DED><DED>else:\n                        <IND>if not isinstance(value, info.types):\n                            <IND>if isinstance(info.types, tuple):\n                                <IND>shouldbe = 'one of: {}'.format(\", \".join(f'\"{t.__name__}\"' for t in info.types))\n                            <DED>else:\n                                <IND>shouldbe = f'\"{info.types.__name__}\"'\n                            <DED>raise InvalidArguments(f'{name} keyword argument \"{info.name}\"\" was of type \"{type(value).__name__}\" but should have been {shouldbe}')\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "                        <IND>kwargs[info.name] = value = mesonlib.listify(value)\n                    <DED>if not check_value_type(value):\n                        <IND>shouldbe = types_description()\n                        raise InvalidArguments(f'{name} keyword argument {info.name!r} was of type {type(value).__name__!r} but should have been {shouldbe}')\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "mesonbuild/meson",
    "commit": "709d151eb944d764b35008ca3275b02bd16a765d",
    "filename": "mesonbuild/interpreterbase/decorators.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/mesonbuild-meson/mesonbuild/interpreterbase/decorators.py",
    "file_hunks_size": 8,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "mesonbuild/interpreterbase/decorators.py:521:56 Incompatible parameter type [6]: Expected `T.Union[T.Type[typing.Any], typing.Tuple[T.Type[typing.Any], ...]]` for 2nd positional only parameter to call `isinstance` but got `T.Union[T.Type[typing.Any], ContainerTypeInfo, typing.Tuple[T.Type[typing.Any], ...]]`.",
    "message": " Expected `T.Union[T.Type[typing.Any], typing.Tuple[T.Type[typing.Any], ...]]` for 2nd positional only parameter to call `isinstance` but got `T.Union[T.Type[typing.Any], ContainerTypeInfo, typing.Tuple[T.Type[typing.Any], ...]]`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 521,
    "warning_line": "                        assert isinstance(info.default, info.types), f'In funcion {name} default value of {info.name} is not a valid type, got {type(info.default)} expected {info.types}'",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "import itertools\nimport typing as T\n",
        "source_code_len": 36,
        "target_code": "import itertools\nimport copy\nimport typing as T\n",
        "target_code_len": 48,
        "diff_format": "@@ -24,2 +24,3 @@\n import itertools\n+import copy\n import typing as T\n",
        "source_code_with_indent": "import itertools\nimport typing as T\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "import itertools\nimport copy\nimport typing as T\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n    def check(self, value: T.Any) -> T.Optional[str]:\n        \"\"\"Check that a value is valid.\n",
        "source_code_len": 95,
        "target_code": "\n    def check(self, value: T.Any) -> bool:\n        \"\"\"Check that a value is valid.\n",
        "target_code_len": 84,
        "diff_format": "@@ -304,3 +305,3 @@\n \n-    def check(self, value: T.Any) -> T.Optional[str]:\n+    def check(self, value: T.Any) -> bool:\n         \"\"\"Check that a value is valid.\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\n    <DED>def check(self, value: T.Any) -> T.Optional[str]:\n        <IND>",
        "target_code_with_indent": "\n    <DED>def check(self, value: T.Any) -> bool:\n        <IND>"
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "        :param value: A value to check\n        :return: If there is an error then a string message, otherwise None\n        \"\"\"\n        if not isinstance(value, self.container):\n            return f'container type was \"{type(value).__name__}\", but should have been \"{self.container.__name__}\"'\n        iter_ = iter(value.values()) if isinstance(value, dict) else iter(value)\n",
        "source_code_len": 374,
        "target_code": "        :param value: A value to check\n        :return: True if it is valid, False otherwise\n        \"\"\"\n        if not isinstance(value, self.container):\n            return False\n        iter_ = iter(value.values()) if isinstance(value, dict) else iter(value)\n",
        "target_code_len": 261,
        "diff_format": "@@ -308,6 +309,6 @@\n         :param value: A value to check\n-        :return: If there is an error then a string message, otherwise None\n+        :return: True if it is valid, False otherwise\n         \"\"\"\n         if not isinstance(value, self.container):\n-            return f'container type was \"{type(value).__name__}\", but should have been \"{self.container.__name__}\"'\n+            return False\n         iter_ = iter(value.values()) if isinstance(value, dict) else iter(value)\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\n        if not isinstance(value, self.container):\n            <IND>return f'container type was \"{type(value).__name__}\", but should have been \"{self.container.__name__}\"'\n        <DED>iter_ = iter(value.values()) if isinstance(value, dict) else iter(value)\n",
        "target_code_with_indent": "\n        if not isinstance(value, self.container):\n            <IND>return False\n        <DED>iter_ = iter(value.values()) if isinstance(value, dict) else iter(value)\n"
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "            if not isinstance(each, self.contains):\n                if isinstance(self.contains, tuple):\n                    shouldbe = 'one of: {}'.format(\", \".join(f'\"{t.__name__}\"' for t in self.contains))\n                else:\n                    shouldbe = f'\"{self.contains.__name__}\"'\n                return f'contained a value of type \"{type(each).__name__}\" but should have been {shouldbe}'\n        if self.pairs and len(value) % 2 != 0:\n            return 'container should be of even length, but is not'\n        if not value and not self.allow_empty:\n            return 'container is empty, but not allowed to be'\n        return None\n\n\n",
        "source_code_len": 647,
        "target_code": "            if not isinstance(each, self.contains):\n                return False\n        if self.pairs and len(value) % 2 != 0:\n            return False\n        if not value and not self.allow_empty:\n            return False\n        return True\n\n    def description(self) -> str:\n        \"\"\"Human readable description of this container type.\n\n        :return: string to be printed\n        \"\"\"\n        container = 'dict' if self.container is dict else 'list'\n        if isinstance(self.contains, tuple):\n            contains = ','.join([t.__name__ for t in self.contains])\n        else:\n            contains = self.contains.__name__\n        s = f'{container}[{contains}]'\n        if self.pairs:\n            s += ' that has even size'\n        if not self.allow_empty:\n            s += ' that cannot be empty'\n        return s\n\n",
        "target_code_len": 825,
        "diff_format": "@@ -315,13 +316,25 @@\n             if not isinstance(each, self.contains):\n-                if isinstance(self.contains, tuple):\n-                    shouldbe = 'one of: {}'.format(\", \".join(f'\"{t.__name__}\"' for t in self.contains))\n-                else:\n-                    shouldbe = f'\"{self.contains.__name__}\"'\n-                return f'contained a value of type \"{type(each).__name__}\" but should have been {shouldbe}'\n+                return False\n         if self.pairs and len(value) % 2 != 0:\n-            return 'container should be of even length, but is not'\n+            return False\n         if not value and not self.allow_empty:\n-            return 'container is empty, but not allowed to be'\n-        return None\n-\n+            return False\n+        return True\n+\n+    def description(self) -> str:\n+        \"\"\"Human readable description of this container type.\n+\n+        :return: string to be printed\n+        \"\"\"\n+        container = 'dict' if self.container is dict else 'list'\n+        if isinstance(self.contains, tuple):\n+            contains = ','.join([t.__name__ for t in self.contains])\n+        else:\n+            contains = self.contains.__name__\n+        s = f'{container}[{contains}]'\n+        if self.pairs:\n+            s += ' that has even size'\n+        if not self.allow_empty:\n+            s += ' that cannot be empty'\n+        return s\n \n",
        "source_code_with_indent": "            <IND>if not isinstance(each, self.contains):\n                <IND>if isinstance(self.contains, tuple):\n                    <IND>shouldbe = 'one of: {}'.format(\", \".join(f'\"{t.__name__}\"' for t in self.contains))\n                <DED>else:\n                    <IND>shouldbe = f'\"{self.contains.__name__}\"'\n                <DED>return f'contained a value of type \"{type(each).__name__}\" but should have been {shouldbe}'\n        <DED><DED>if self.pairs and len(value) % 2 != 0:\n            <IND>return 'container should be of even length, but is not'\n        <DED>if not value and not self.allow_empty:\n            <IND>return 'container is empty, but not allowed to be'\n        <DED>return None\n\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "            <IND>if not isinstance(each, self.contains):\n                <IND>return False\n        <DED><DED>if self.pairs and len(value) % 2 != 0:\n            <IND>return False\n        <DED>if not value and not self.allow_empty:\n            <IND>return False\n        <DED>return True\n\n    <DED>def description(self) -> str:\n        <IND>\"\"\"Human readable description of this container type.\n\n        :return: string to be printed\n        \"\"\"\n        container = 'dict' if self.container is dict else 'list'\n        if isinstance(self.contains, tuple):\n            <IND>contains = ','.join([t.__name__ for t in self.contains])\n        <DED>else:\n            <IND>contains = self.contains.__name__\n        <DED>s = f'{container}[{contains}]'\n        if self.pairs:\n            <IND>s += ' that has even size'\n        <DED>if not self.allow_empty:\n            <IND>s += ' that cannot be empty'\n        <DED>return s\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "            for info in types:\n                value = kwargs.get(info.name)\n",
        "source_code_len": 77,
        "target_code": "            for info in types:\n                types_tuple = info.types if isinstance(info.types, tuple) else (info.types,)\n                def check_value_type(value: T.Any) -> bool:\n                    for t in types_tuple:\n                        if isinstance(t, ContainerTypeInfo):\n                            if t.check(value):\n                                return True\n                        elif isinstance(value, t):\n                            return True\n                    return False\n                def types_description() -> str:\n                    candidates = []\n                    for t in types_tuple:\n                        if isinstance(t, ContainerTypeInfo):\n                            candidates.append(t.description())\n                        else:\n                            candidates.append(t.__name__)\n                    shouldbe = 'one of: ' if len(candidates) > 1 else ''\n                    shouldbe += ', '.join(candidates)\n                    return shouldbe\n                value = kwargs.get(info.name)\n",
        "target_code_len": 1049,
        "diff_format": "@@ -458,2 +471,21 @@\n             for info in types:\n+                types_tuple = info.types if isinstance(info.types, tuple) else (info.types,)\n+                def check_value_type(value: T.Any) -> bool:\n+                    for t in types_tuple:\n+                        if isinstance(t, ContainerTypeInfo):\n+                            if t.check(value):\n+                                return True\n+                        elif isinstance(value, t):\n+                            return True\n+                    return False\n+                def types_description() -> str:\n+                    candidates = []\n+                    for t in types_tuple:\n+                        if isinstance(t, ContainerTypeInfo):\n+                            candidates.append(t.description())\n+                        else:\n+                            candidates.append(t.__name__)\n+                    shouldbe = 'one of: ' if len(candidates) > 1 else ''\n+                    shouldbe += ', '.join(candidates)\n+                    return shouldbe\n                 value = kwargs.get(info.name)\n",
        "source_code_with_indent": "            <DED>for info in types:\n                <IND>value = kwargs.get(info.name)\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "            <DED>for info in types:\n                <IND>types_tuple = info.types if isinstance(info.types, tuple) else (info.types,)\n                def check_value_type(value: T.Any) -> bool:\n                    <IND>for t in types_tuple:\n                        <IND>if isinstance(t, ContainerTypeInfo):\n                            <IND>if t.check(value):\n                                <IND>return True\n                        <DED><DED>elif isinstance(value, t):\n                            <IND>return True\n                    <DED><DED>return False\n                <DED>def types_description() -> str:\n                    <IND>candidates = []\n                    for t in types_tuple:\n                        <IND>if isinstance(t, ContainerTypeInfo):\n                            <IND>candidates.append(t.description())\n                        <DED>else:\n                            <IND>candidates.append(t.__name__)\n                    <DED><DED>shouldbe = 'one of: ' if len(candidates) > 1 else ''\n                    shouldbe += ', '.join(candidates)\n                    return shouldbe\n                <DED>value = kwargs.get(info.name)\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "                    # This both simplifies the typing checking and the usage\n                    # Create a shallow copy of the container (and do a type\n                    # conversion if necessary). This allows mutable types to\n                    # be used safely as default values\n                    if isinstance(info.types, ContainerTypeInfo):\n                        assert isinstance(info.default, info.types.container), f'In function {name} default value of {info.name} is not a valid type, got {type(info.default)}, expected {info.types.container}[{info.types.contains}]'\n                        for item in info.default:\n                            assert isinstance(item, info.types.contains), f'In function {name} default value of {info.name}, container has invalid value of {item}, which is of type {type(item)}, but should be {info.types.contains}'\n                        kwargs[info.name] = info.types.container(info.default)\n                    else:\n                        assert isinstance(info.default, info.types), f'In funcion {name} default value of {info.name} is not a valid type, got {type(info.default)} expected {info.types}'\n                        kwargs[info.name] = info.default\n                    if info.not_set_warning:\n",
        "source_code_len": 1259,
        "target_code": "                    # This both simplifies the typing checking and the usage\n                    assert check_value_type(info.default), f'In funcion {name} default value of {info.name} is not a valid type, got {type(info.default)} expected {types_description()}'\n                    # Create a shallow copy of the container. This allows mutable\n                    # types to be used safely as default values\n                    kwargs[info.name] = copy.copy(info.default)\n                    if info.not_set_warning:\n",
        "target_code_len": 518,
        "diff_format": "@@ -511,13 +535,6 @@\n                     # This both simplifies the typing checking and the usage\n-                    # Create a shallow copy of the container (and do a type\n-                    # conversion if necessary). This allows mutable types to\n-                    # be used safely as default values\n-                    if isinstance(info.types, ContainerTypeInfo):\n-                        assert isinstance(info.default, info.types.container), f'In function {name} default value of {info.name} is not a valid type, got {type(info.default)}, expected {info.types.container}[{info.types.contains}]'\n-                        for item in info.default:\n-                            assert isinstance(item, info.types.contains), f'In function {name} default value of {info.name}, container has invalid value of {item}, which is of type {type(item)}, but should be {info.types.contains}'\n-                        kwargs[info.name] = info.types.container(info.default)\n-                    else:\n-                        assert isinstance(info.default, info.types), f'In funcion {name} default value of {info.name} is not a valid type, got {type(info.default)} expected {info.types}'\n-                        kwargs[info.name] = info.default\n+                    assert check_value_type(info.default), f'In funcion {name} default value of {info.name} is not a valid type, got {type(info.default)} expected {types_description()}'\n+                    # Create a shallow copy of the container. This allows mutable\n+                    # types to be used safely as default values\n+                    kwargs[info.name] = copy.copy(info.default)\n                     if info.not_set_warning:\n",
        "source_code_with_indent": "                    # This both simplifies the typing checking and the usage\n                    # Create a shallow copy of the container (and do a type\n                    # conversion if necessary). This allows mutable types to\n                    # be used safely as default values\n                    <IND>if isinstance(info.types, ContainerTypeInfo):\n                        <IND>assert isinstance(info.default, info.types.container), f'In function {name} default value of {info.name} is not a valid type, got {type(info.default)}, expected {info.types.container}[{info.types.contains}]'\n                        for item in info.default:\n                            <IND>assert isinstance(item, info.types.contains), f'In function {name} default value of {info.name}, container has invalid value of {item}, which is of type {type(item)}, but should be {info.types.contains}'\n                        <DED>kwargs[info.name] = info.types.container(info.default)\n                    <DED>else:\n                        <IND>assert isinstance(info.default, info.types), f'In funcion {name} default value of {info.name} is not a valid type, got {type(info.default)} expected {info.types}'\n                        kwargs[info.name] = info.default\n                    <DED>if info.not_set_warning:\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "                    # This both simplifies the typing checking and the usage\n                    <IND>assert check_value_type(info.default), f'In funcion {name} default value of {info.name} is not a valid type, got {type(info.default)} expected {types_description()}'\n                    # Create a shallow copy of the container. This allows mutable\n                    # types to be used safely as default values\n                    kwargs[info.name] = copy.copy(info.default)\n                    if info.not_set_warning:\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  }
]