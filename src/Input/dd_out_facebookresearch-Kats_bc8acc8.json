[
  {
    "project": "facebookresearch/Kats",
    "commit": "bc8acc8ef02f4c44f66d4513aef46471b56db3ec",
    "filename": "kats/tests/test_detectors.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/facebookresearch-Kats/kats/tests/test_detectors.py",
    "file_hunks_size": 9,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "kats/tests/test_detectors.py:1938:12 Incompatible parameter type [6]: Expected `typing.Iterable[Variable[_T2]]` for 2nd positional only parameter to call `zip.__new__` but got `float`.",
    "message": " Expected `typing.Iterable[Variable[_T2]]` for 2nd positional only parameter to call `zip.__new__` but got `float`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 1938,
    "warning_line": "            perc_change_2.p_value,",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "from collections import Counter\nfrom datetime import datetime, timedelta\n",
        "source_code_len": 73,
        "target_code": "from collections import Counter\nfrom collections.abc import Iterable\nfrom datetime import datetime, timedelta\n",
        "target_code_len": 110,
        "diff_format": "@@ -12,2 +12,3 @@\n from collections import Counter\n+from collections.abc import Iterable\n from datetime import datetime, timedelta\n",
        "source_code_with_indent": "from collections import Counter\nfrom datetime import datetime, timedelta\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "from collections import Counter\nfrom collections.abc import Iterable\nfrom datetime import datetime, timedelta\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "        ratio_val = current_mean / previous_mean\n        # pyre-fixme[16]: `float` has no attribute `tolist`.\n        self.assertEqual(perc_change_1.ratio_estimate.tolist(), ratio_val.tolist())\n\n        # pyre-fixme[16]: `float` has no attribute `__iter__`.\n        for r in perc_change_1.ratio_estimate:\n            self.assertAlmostEqual(r, 10.0, 0)\n\n        self.assertEqual(\n            perc_change_1.perc_change.tolist(), ((ratio_val - 1) * 100).tolist()\n        )\n        # pyre-fixme[16]: str has no attribute tolist.\n        self.assertEqual(perc_change_1.direction.tolist(), [\"up\"] * num_seq)\n        # pyre-fixme[16]: bool has no attribute tolist.\n        self.assertEqual(perc_change_1.stat_sig.tolist(), [True] * num_seq)\n\n        # pyre-fixme[6]: Expected `Iterable[Variable[_T1]]` for 1st param but got\n        #  `float`.\n        for p_value, score in zip(perc_change_1.p_value, perc_change_1.score):\n            self.assertLess(p_value, 0.05)\n",
        "source_code_len": 959,
        "target_code": "        ratio_val = current_mean / previous_mean\n        ratio_estimate = perc_change_1.ratio_estimate\n        assert isinstance(ratio_estimate, np.ndarray)\n        self.assertEqual(ratio_estimate.tolist(), ratio_val.tolist())\n\n        for r in ratio_estimate:\n            self.assertAlmostEqual(r, 10.0, 0)\n\n        perc_change = perc_change_1.perc_change\n        assert isinstance(perc_change, np.ndarray)\n        self.assertEqual(\n            perc_change.tolist(), ((ratio_val - 1) * 100).tolist()\n        )\n\n        direction = perc_change_1.direction\n        assert isinstance(direction, np.ndarray)\n        self.assertEqual(direction.tolist(), [\"up\"] * num_seq)\n\n        stat_sig = perc_change_1.stat_sig\n        assert isinstance(stat_sig, np.ndarray)\n        self.assertEqual(stat_sig.tolist(), [True] * num_seq)\n\n        p_value_list, score_list = perc_change_1.p_value, perc_change_1.score\n        assert isinstance(p_value_list, Iterable)\n        assert isinstance(score_list, Iterable)\n        for p_value, score in zip(p_value_list, score_list):\n            self.assertLess(p_value, 0.05)\n",
        "target_code_len": 1102,
        "diff_format": "@@ -1894,20 +1893,27 @@\n         ratio_val = current_mean / previous_mean\n-        # pyre-fixme[16]: `float` has no attribute `tolist`.\n-        self.assertEqual(perc_change_1.ratio_estimate.tolist(), ratio_val.tolist())\n-\n-        # pyre-fixme[16]: `float` has no attribute `__iter__`.\n-        for r in perc_change_1.ratio_estimate:\n+        ratio_estimate = perc_change_1.ratio_estimate\n+        assert isinstance(ratio_estimate, np.ndarray)\n+        self.assertEqual(ratio_estimate.tolist(), ratio_val.tolist())\n+\n+        for r in ratio_estimate:\n             self.assertAlmostEqual(r, 10.0, 0)\n \n+        perc_change = perc_change_1.perc_change\n+        assert isinstance(perc_change, np.ndarray)\n         self.assertEqual(\n-            perc_change_1.perc_change.tolist(), ((ratio_val - 1) * 100).tolist()\n-        )\n-        # pyre-fixme[16]: str has no attribute tolist.\n-        self.assertEqual(perc_change_1.direction.tolist(), [\"up\"] * num_seq)\n-        # pyre-fixme[16]: bool has no attribute tolist.\n-        self.assertEqual(perc_change_1.stat_sig.tolist(), [True] * num_seq)\n-\n-        # pyre-fixme[6]: Expected `Iterable[Variable[_T1]]` for 1st param but got\n-        #  `float`.\n-        for p_value, score in zip(perc_change_1.p_value, perc_change_1.score):\n+            perc_change.tolist(), ((ratio_val - 1) * 100).tolist()\n+        )\n+\n+        direction = perc_change_1.direction\n+        assert isinstance(direction, np.ndarray)\n+        self.assertEqual(direction.tolist(), [\"up\"] * num_seq)\n+\n+        stat_sig = perc_change_1.stat_sig\n+        assert isinstance(stat_sig, np.ndarray)\n+        self.assertEqual(stat_sig.tolist(), [True] * num_seq)\n+\n+        p_value_list, score_list = perc_change_1.p_value, perc_change_1.score\n+        assert isinstance(p_value_list, Iterable)\n+        assert isinstance(score_list, Iterable)\n+        for p_value, score in zip(p_value_list, score_list):\n             self.assertLess(p_value, 0.05)\n",
        "source_code_with_indent": "        ratio_val = current_mean / previous_mean\n        # pyre-fixme[16]: `float` has no attribute `tolist`.\n        self.assertEqual(perc_change_1.ratio_estimate.tolist(), ratio_val.tolist())\n\n        # pyre-fixme[16]: `float` has no attribute `__iter__`.\n        for r in perc_change_1.ratio_estimate:\n            <IND>self.assertAlmostEqual(r, 10.0, 0)\n\n        <DED>self.assertEqual(\n            perc_change_1.perc_change.tolist(), ((ratio_val - 1) * 100).tolist()\n        )\n        # pyre-fixme[16]: str has no attribute tolist.\n        self.assertEqual(perc_change_1.direction.tolist(), [\"up\"] * num_seq)\n        # pyre-fixme[16]: bool has no attribute tolist.\n        self.assertEqual(perc_change_1.stat_sig.tolist(), [True] * num_seq)\n\n        # pyre-fixme[6]: Expected `Iterable[Variable[_T1]]` for 1st param but got\n        #  `float`.\n        for p_value, score in zip(perc_change_1.p_value, perc_change_1.score):\n            <IND>self.assertLess(p_value, 0.05)\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "        ratio_val = current_mean / previous_mean\n        ratio_estimate = perc_change_1.ratio_estimate\n        assert isinstance(ratio_estimate, np.ndarray)\n        self.assertEqual(ratio_estimate.tolist(), ratio_val.tolist())\n\n        for r in ratio_estimate:\n            <IND>self.assertAlmostEqual(r, 10.0, 0)\n\n        <DED>perc_change = perc_change_1.perc_change\n        assert isinstance(perc_change, np.ndarray)\n        self.assertEqual(\n            perc_change.tolist(), ((ratio_val - 1) * 100).tolist()\n        )\n\n        direction = perc_change_1.direction\n        assert isinstance(direction, np.ndarray)\n        self.assertEqual(direction.tolist(), [\"up\"] * num_seq)\n\n        stat_sig = perc_change_1.stat_sig\n        assert isinstance(stat_sig, np.ndarray)\n        self.assertEqual(stat_sig.tolist(), [True] * num_seq)\n\n        p_value_list, score_list = perc_change_1.p_value, perc_change_1.score\n        assert isinstance(p_value_list, Iterable)\n        assert isinstance(score_list, Iterable)\n        for p_value, score in zip(p_value_list, score_list):\n            <IND>self.assertLess(p_value, 0.05)\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "facebookresearch/Kats",
    "commit": "bc8acc8ef02f4c44f66d4513aef46471b56db3ec",
    "filename": "kats/tests/test_detectors.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/facebookresearch-Kats/kats/tests/test_detectors.py",
    "file_hunks_size": 9,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "kats/tests/test_detectors.py:1939:12 Incompatible parameter type [6]: Expected `typing.Iterable[Variable[_T3]]` for 3rd positional only parameter to call `zip.__new__` but got `float`.",
    "message": " Expected `typing.Iterable[Variable[_T3]]` for 3rd positional only parameter to call `zip.__new__` but got `float`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 1939,
    "warning_line": "            perc_change_2.score,",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "from collections import Counter\nfrom datetime import datetime, timedelta\n",
        "source_code_len": 73,
        "target_code": "from collections import Counter\nfrom collections.abc import Iterable\nfrom datetime import datetime, timedelta\n",
        "target_code_len": 110,
        "diff_format": "@@ -12,2 +12,3 @@\n from collections import Counter\n+from collections.abc import Iterable\n from datetime import datetime, timedelta\n",
        "source_code_with_indent": "from collections import Counter\nfrom datetime import datetime, timedelta\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "from collections import Counter\nfrom collections.abc import Iterable\nfrom datetime import datetime, timedelta\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "        ratio_val = current_mean / previous_mean\n        # pyre-fixme[16]: `float` has no attribute `tolist`.\n        self.assertEqual(perc_change_1.ratio_estimate.tolist(), ratio_val.tolist())\n\n        # pyre-fixme[16]: `float` has no attribute `__iter__`.\n        for r in perc_change_1.ratio_estimate:\n            self.assertAlmostEqual(r, 10.0, 0)\n\n        self.assertEqual(\n            perc_change_1.perc_change.tolist(), ((ratio_val - 1) * 100).tolist()\n        )\n        # pyre-fixme[16]: str has no attribute tolist.\n        self.assertEqual(perc_change_1.direction.tolist(), [\"up\"] * num_seq)\n        # pyre-fixme[16]: bool has no attribute tolist.\n        self.assertEqual(perc_change_1.stat_sig.tolist(), [True] * num_seq)\n\n        # pyre-fixme[6]: Expected `Iterable[Variable[_T1]]` for 1st param but got\n        #  `float`.\n        for p_value, score in zip(perc_change_1.p_value, perc_change_1.score):\n            self.assertLess(p_value, 0.05)\n",
        "source_code_len": 959,
        "target_code": "        ratio_val = current_mean / previous_mean\n        ratio_estimate = perc_change_1.ratio_estimate\n        assert isinstance(ratio_estimate, np.ndarray)\n        self.assertEqual(ratio_estimate.tolist(), ratio_val.tolist())\n\n        for r in ratio_estimate:\n            self.assertAlmostEqual(r, 10.0, 0)\n\n        perc_change = perc_change_1.perc_change\n        assert isinstance(perc_change, np.ndarray)\n        self.assertEqual(\n            perc_change.tolist(), ((ratio_val - 1) * 100).tolist()\n        )\n\n        direction = perc_change_1.direction\n        assert isinstance(direction, np.ndarray)\n        self.assertEqual(direction.tolist(), [\"up\"] * num_seq)\n\n        stat_sig = perc_change_1.stat_sig\n        assert isinstance(stat_sig, np.ndarray)\n        self.assertEqual(stat_sig.tolist(), [True] * num_seq)\n\n        p_value_list, score_list = perc_change_1.p_value, perc_change_1.score\n        assert isinstance(p_value_list, Iterable)\n        assert isinstance(score_list, Iterable)\n        for p_value, score in zip(p_value_list, score_list):\n            self.assertLess(p_value, 0.05)\n",
        "target_code_len": 1102,
        "diff_format": "@@ -1894,20 +1893,27 @@\n         ratio_val = current_mean / previous_mean\n-        # pyre-fixme[16]: `float` has no attribute `tolist`.\n-        self.assertEqual(perc_change_1.ratio_estimate.tolist(), ratio_val.tolist())\n-\n-        # pyre-fixme[16]: `float` has no attribute `__iter__`.\n-        for r in perc_change_1.ratio_estimate:\n+        ratio_estimate = perc_change_1.ratio_estimate\n+        assert isinstance(ratio_estimate, np.ndarray)\n+        self.assertEqual(ratio_estimate.tolist(), ratio_val.tolist())\n+\n+        for r in ratio_estimate:\n             self.assertAlmostEqual(r, 10.0, 0)\n \n+        perc_change = perc_change_1.perc_change\n+        assert isinstance(perc_change, np.ndarray)\n         self.assertEqual(\n-            perc_change_1.perc_change.tolist(), ((ratio_val - 1) * 100).tolist()\n-        )\n-        # pyre-fixme[16]: str has no attribute tolist.\n-        self.assertEqual(perc_change_1.direction.tolist(), [\"up\"] * num_seq)\n-        # pyre-fixme[16]: bool has no attribute tolist.\n-        self.assertEqual(perc_change_1.stat_sig.tolist(), [True] * num_seq)\n-\n-        # pyre-fixme[6]: Expected `Iterable[Variable[_T1]]` for 1st param but got\n-        #  `float`.\n-        for p_value, score in zip(perc_change_1.p_value, perc_change_1.score):\n+            perc_change.tolist(), ((ratio_val - 1) * 100).tolist()\n+        )\n+\n+        direction = perc_change_1.direction\n+        assert isinstance(direction, np.ndarray)\n+        self.assertEqual(direction.tolist(), [\"up\"] * num_seq)\n+\n+        stat_sig = perc_change_1.stat_sig\n+        assert isinstance(stat_sig, np.ndarray)\n+        self.assertEqual(stat_sig.tolist(), [True] * num_seq)\n+\n+        p_value_list, score_list = perc_change_1.p_value, perc_change_1.score\n+        assert isinstance(p_value_list, Iterable)\n+        assert isinstance(score_list, Iterable)\n+        for p_value, score in zip(p_value_list, score_list):\n             self.assertLess(p_value, 0.05)\n",
        "source_code_with_indent": "        ratio_val = current_mean / previous_mean\n        # pyre-fixme[16]: `float` has no attribute `tolist`.\n        self.assertEqual(perc_change_1.ratio_estimate.tolist(), ratio_val.tolist())\n\n        # pyre-fixme[16]: `float` has no attribute `__iter__`.\n        for r in perc_change_1.ratio_estimate:\n            <IND>self.assertAlmostEqual(r, 10.0, 0)\n\n        <DED>self.assertEqual(\n            perc_change_1.perc_change.tolist(), ((ratio_val - 1) * 100).tolist()\n        )\n        # pyre-fixme[16]: str has no attribute tolist.\n        self.assertEqual(perc_change_1.direction.tolist(), [\"up\"] * num_seq)\n        # pyre-fixme[16]: bool has no attribute tolist.\n        self.assertEqual(perc_change_1.stat_sig.tolist(), [True] * num_seq)\n\n        # pyre-fixme[6]: Expected `Iterable[Variable[_T1]]` for 1st param but got\n        #  `float`.\n        for p_value, score in zip(perc_change_1.p_value, perc_change_1.score):\n            <IND>self.assertLess(p_value, 0.05)\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "        ratio_val = current_mean / previous_mean\n        ratio_estimate = perc_change_1.ratio_estimate\n        assert isinstance(ratio_estimate, np.ndarray)\n        self.assertEqual(ratio_estimate.tolist(), ratio_val.tolist())\n\n        for r in ratio_estimate:\n            <IND>self.assertAlmostEqual(r, 10.0, 0)\n\n        <DED>perc_change = perc_change_1.perc_change\n        assert isinstance(perc_change, np.ndarray)\n        self.assertEqual(\n            perc_change.tolist(), ((ratio_val - 1) * 100).tolist()\n        )\n\n        direction = perc_change_1.direction\n        assert isinstance(direction, np.ndarray)\n        self.assertEqual(direction.tolist(), [\"up\"] * num_seq)\n\n        stat_sig = perc_change_1.stat_sig\n        assert isinstance(stat_sig, np.ndarray)\n        self.assertEqual(stat_sig.tolist(), [True] * num_seq)\n\n        p_value_list, score_list = perc_change_1.p_value, perc_change_1.score\n        assert isinstance(p_value_list, Iterable)\n        assert isinstance(score_list, Iterable)\n        for p_value, score in zip(p_value_list, score_list):\n            <IND>self.assertLess(p_value, 0.05)\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "facebookresearch/Kats",
    "commit": "bc8acc8ef02f4c44f66d4513aef46471b56db3ec",
    "filename": "kats/tests/test_detectors.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/facebookresearch-Kats/kats/tests/test_detectors.py",
    "file_hunks_size": 9,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "kats/tests/test_detectors.py:1986:12 Incompatible parameter type [6]: Expected `typing.Iterable[Variable[_T2]]` for 2nd positional only parameter to call `zip.__new__` but got `float`.",
    "message": " Expected `typing.Iterable[Variable[_T2]]` for 2nd positional only parameter to call `zip.__new__` but got `float`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 1986,
    "warning_line": "            perc_change_single_point.score,",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "from collections import Counter\nfrom datetime import datetime, timedelta\n",
        "source_code_len": 73,
        "target_code": "from collections import Counter\nfrom collections.abc import Iterable\nfrom datetime import datetime, timedelta\n",
        "target_code_len": 110,
        "diff_format": "@@ -12,2 +12,3 @@\n from collections import Counter\n+from collections.abc import Iterable\n from datetime import datetime, timedelta\n",
        "source_code_with_indent": "from collections import Counter\nfrom datetime import datetime, timedelta\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "from collections import Counter\nfrom collections.abc import Iterable\nfrom datetime import datetime, timedelta\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "        ratio_val = current_mean / previous_mean\n        # pyre-fixme[16]: `float` has no attribute `tolist`.\n        self.assertEqual(perc_change_1.ratio_estimate.tolist(), ratio_val.tolist())\n\n        # pyre-fixme[16]: `float` has no attribute `__iter__`.\n        for r in perc_change_1.ratio_estimate:\n            self.assertAlmostEqual(r, 10.0, 0)\n\n        self.assertEqual(\n            perc_change_1.perc_change.tolist(), ((ratio_val - 1) * 100).tolist()\n        )\n        # pyre-fixme[16]: str has no attribute tolist.\n        self.assertEqual(perc_change_1.direction.tolist(), [\"up\"] * num_seq)\n        # pyre-fixme[16]: bool has no attribute tolist.\n        self.assertEqual(perc_change_1.stat_sig.tolist(), [True] * num_seq)\n\n        # pyre-fixme[6]: Expected `Iterable[Variable[_T1]]` for 1st param but got\n        #  `float`.\n        for p_value, score in zip(perc_change_1.p_value, perc_change_1.score):\n            self.assertLess(p_value, 0.05)\n",
        "source_code_len": 959,
        "target_code": "        ratio_val = current_mean / previous_mean\n        ratio_estimate = perc_change_1.ratio_estimate\n        assert isinstance(ratio_estimate, np.ndarray)\n        self.assertEqual(ratio_estimate.tolist(), ratio_val.tolist())\n\n        for r in ratio_estimate:\n            self.assertAlmostEqual(r, 10.0, 0)\n\n        perc_change = perc_change_1.perc_change\n        assert isinstance(perc_change, np.ndarray)\n        self.assertEqual(\n            perc_change.tolist(), ((ratio_val - 1) * 100).tolist()\n        )\n\n        direction = perc_change_1.direction\n        assert isinstance(direction, np.ndarray)\n        self.assertEqual(direction.tolist(), [\"up\"] * num_seq)\n\n        stat_sig = perc_change_1.stat_sig\n        assert isinstance(stat_sig, np.ndarray)\n        self.assertEqual(stat_sig.tolist(), [True] * num_seq)\n\n        p_value_list, score_list = perc_change_1.p_value, perc_change_1.score\n        assert isinstance(p_value_list, Iterable)\n        assert isinstance(score_list, Iterable)\n        for p_value, score in zip(p_value_list, score_list):\n            self.assertLess(p_value, 0.05)\n",
        "target_code_len": 1102,
        "diff_format": "@@ -1894,20 +1893,27 @@\n         ratio_val = current_mean / previous_mean\n-        # pyre-fixme[16]: `float` has no attribute `tolist`.\n-        self.assertEqual(perc_change_1.ratio_estimate.tolist(), ratio_val.tolist())\n-\n-        # pyre-fixme[16]: `float` has no attribute `__iter__`.\n-        for r in perc_change_1.ratio_estimate:\n+        ratio_estimate = perc_change_1.ratio_estimate\n+        assert isinstance(ratio_estimate, np.ndarray)\n+        self.assertEqual(ratio_estimate.tolist(), ratio_val.tolist())\n+\n+        for r in ratio_estimate:\n             self.assertAlmostEqual(r, 10.0, 0)\n \n+        perc_change = perc_change_1.perc_change\n+        assert isinstance(perc_change, np.ndarray)\n         self.assertEqual(\n-            perc_change_1.perc_change.tolist(), ((ratio_val - 1) * 100).tolist()\n-        )\n-        # pyre-fixme[16]: str has no attribute tolist.\n-        self.assertEqual(perc_change_1.direction.tolist(), [\"up\"] * num_seq)\n-        # pyre-fixme[16]: bool has no attribute tolist.\n-        self.assertEqual(perc_change_1.stat_sig.tolist(), [True] * num_seq)\n-\n-        # pyre-fixme[6]: Expected `Iterable[Variable[_T1]]` for 1st param but got\n-        #  `float`.\n-        for p_value, score in zip(perc_change_1.p_value, perc_change_1.score):\n+            perc_change.tolist(), ((ratio_val - 1) * 100).tolist()\n+        )\n+\n+        direction = perc_change_1.direction\n+        assert isinstance(direction, np.ndarray)\n+        self.assertEqual(direction.tolist(), [\"up\"] * num_seq)\n+\n+        stat_sig = perc_change_1.stat_sig\n+        assert isinstance(stat_sig, np.ndarray)\n+        self.assertEqual(stat_sig.tolist(), [True] * num_seq)\n+\n+        p_value_list, score_list = perc_change_1.p_value, perc_change_1.score\n+        assert isinstance(p_value_list, Iterable)\n+        assert isinstance(score_list, Iterable)\n+        for p_value, score in zip(p_value_list, score_list):\n             self.assertLess(p_value, 0.05)\n",
        "source_code_with_indent": "        ratio_val = current_mean / previous_mean\n        # pyre-fixme[16]: `float` has no attribute `tolist`.\n        self.assertEqual(perc_change_1.ratio_estimate.tolist(), ratio_val.tolist())\n\n        # pyre-fixme[16]: `float` has no attribute `__iter__`.\n        for r in perc_change_1.ratio_estimate:\n            <IND>self.assertAlmostEqual(r, 10.0, 0)\n\n        <DED>self.assertEqual(\n            perc_change_1.perc_change.tolist(), ((ratio_val - 1) * 100).tolist()\n        )\n        # pyre-fixme[16]: str has no attribute tolist.\n        self.assertEqual(perc_change_1.direction.tolist(), [\"up\"] * num_seq)\n        # pyre-fixme[16]: bool has no attribute tolist.\n        self.assertEqual(perc_change_1.stat_sig.tolist(), [True] * num_seq)\n\n        # pyre-fixme[6]: Expected `Iterable[Variable[_T1]]` for 1st param but got\n        #  `float`.\n        for p_value, score in zip(perc_change_1.p_value, perc_change_1.score):\n            <IND>self.assertLess(p_value, 0.05)\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "        ratio_val = current_mean / previous_mean\n        ratio_estimate = perc_change_1.ratio_estimate\n        assert isinstance(ratio_estimate, np.ndarray)\n        self.assertEqual(ratio_estimate.tolist(), ratio_val.tolist())\n\n        for r in ratio_estimate:\n            <IND>self.assertAlmostEqual(r, 10.0, 0)\n\n        <DED>perc_change = perc_change_1.perc_change\n        assert isinstance(perc_change, np.ndarray)\n        self.assertEqual(\n            perc_change.tolist(), ((ratio_val - 1) * 100).tolist()\n        )\n\n        direction = perc_change_1.direction\n        assert isinstance(direction, np.ndarray)\n        self.assertEqual(direction.tolist(), [\"up\"] * num_seq)\n\n        stat_sig = perc_change_1.stat_sig\n        assert isinstance(stat_sig, np.ndarray)\n        self.assertEqual(stat_sig.tolist(), [True] * num_seq)\n\n        p_value_list, score_list = perc_change_1.p_value, perc_change_1.score\n        assert isinstance(p_value_list, Iterable)\n        assert isinstance(score_list, Iterable)\n        for p_value, score in zip(p_value_list, score_list):\n            <IND>self.assertLess(p_value, 0.05)\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  }
]