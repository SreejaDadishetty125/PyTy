[
  {
    "project": "mandiant/flare-floss",
    "commit": "e86fe0db137a76a47a83034759c0ad7f0213f05f",
    "filename": "floss/logging.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/mandiant-flare-floss/floss/logging.py",
    "file_hunks_size": 2,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": true,
    "full_warning_msg": "floss/logging.py:41:22 Invalid type [31]: Expression `logging.getLoggerClass()` is not a valid type.",
    "message": " Expression `logging.getLoggerClass()` is not a valid type.",
    "rule_id": "Invalid type [31]",
    "warning_line_no": 41,
    "warning_line": "class LoggerWithTrace(logging.getLoggerClass()):",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": true,
        "source_code": "\nlogging.TRACE = logging.DEBUG - 1\nlogging.addLevelName(logging.TRACE, \"TRACE\")\n\n\nclass LoggerWithTrace(logging.getLoggerClass()):\n    def trace(self, msg, *args, **kwargs):\n        self.log(logging.TRACE, msg, *args, **kwargs)\n\n",
        "source_code_len": 229,
        "target_code": "\nTRACE = logging.DEBUG - 1\nsetattr(logging, \"TRACE\", TRACE)\nlogging.addLevelName(TRACE, \"TRACE\")\n\n\nclass LoggerWithTrace(logging.getLoggerClass()):  # type: ignore\n    def trace(self, msg, *args, **kwargs):\n        self.log(TRACE, msg, *args, **kwargs)\n\n",
        "target_code_len": 254,
        "diff_format": "@@ -36,9 +36,10 @@\n \n-logging.TRACE = logging.DEBUG - 1\n-logging.addLevelName(logging.TRACE, \"TRACE\")\n+TRACE = logging.DEBUG - 1\n+setattr(logging, \"TRACE\", TRACE)\n+logging.addLevelName(TRACE, \"TRACE\")\n \n \n-class LoggerWithTrace(logging.getLoggerClass()):\n+class LoggerWithTrace(logging.getLoggerClass()):  # type: ignore\n     def trace(self, msg, *args, **kwargs):\n-        self.log(logging.TRACE, msg, *args, **kwargs)\n+        self.log(TRACE, msg, *args, **kwargs)\n \n",
        "source_code_with_indent": "\n<DED><DED>logging.TRACE = logging.DEBUG - 1\nlogging.addLevelName(logging.TRACE, \"TRACE\")\n\n\nclass LoggerWithTrace(logging.getLoggerClass()):\n    <IND>def trace(self, msg, *args, **kwargs):\n        <IND>self.log(logging.TRACE, msg, *args, **kwargs)\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n<DED><DED>TRACE = logging.DEBUG - 1\nsetattr(logging, \"TRACE\", TRACE)\nlogging.addLevelName(TRACE, \"TRACE\")\n\n\nclass LoggerWithTrace(logging.getLoggerClass()):  # type: ignore\n    <IND>def trace(self, msg, *args, **kwargs):\n        <IND>self.log(TRACE, msg, *args, **kwargs)\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "mandiant/flare-floss",
    "commit": "e86fe0db137a76a47a83034759c0ad7f0213f05f",
    "filename": "floss/logging.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/mandiant-flare-floss/floss/logging.py",
    "file_hunks_size": 2,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": true,
    "full_warning_msg": "floss/logging.py:56:4 Incompatible return type [7]: Expected `LoggerWithTrace` but got `logging.Logger`.",
    "message": " Expected `LoggerWithTrace` but got `logging.Logger`.",
    "rule_id": "Incompatible return type [7]",
    "warning_line_no": 56,
    "warning_line": "    return logging.getLogger(name)",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": true,
        "source_code": "\n    note: this code must come after the registration of the TRACE level.\n    \"\"\"\n    return logging.getLogger(name)\n",
        "source_code_len": 117,
        "target_code": "\n    because we patch stdlib logging upon import of this module (side-effect),\n    and we can't be sure how callers order their imports,\n    then we want to provide a way to ensure that callers can access TRACE consistently.\n    if callers use `floss.logging.getLogger()` intead of `logging.getLogger()`,\n    then they'll be guaranteed to have access to TRACE.\n    \"\"\"\n    return logging.getLogger(name)  # type: ignore\n",
        "target_code_len": 420,
        "diff_format": "@@ -53,4 +54,8 @@\n \n-    note: this code must come after the registration of the TRACE level.\n+    because we patch stdlib logging upon import of this module (side-effect),\n+    and we can't be sure how callers order their imports,\n+    then we want to provide a way to ensure that callers can access TRACE consistently.\n+    if callers use `floss.logging.getLogger()` intead of `logging.getLogger()`,\n+    then they'll be guaranteed to have access to TRACE.\n     \"\"\"\n-    return logging.getLogger(name)\n+    return logging.getLogger(name)  # type: ignore\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\n    return logging.getLogger(name)\n",
        "target_code_with_indent": "\n    return logging.getLogger(name)  # type: ignore\n"
      }
    ]
  },
  {
    "project": "mandiant/flare-floss",
    "commit": "e86fe0db137a76a47a83034759c0ad7f0213f05f",
    "filename": "floss/main.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/mandiant-flare-floss/floss/main.py",
    "file_hunks_size": 5,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "floss/main.py:61:73 Incompatible parameter type [6]: Expected `string_decoder.DeltaBytes` for 1st positional only parameter to call `string_decoder.extract_strings` but got `DecodedString`.",
    "message": " Expected `string_decoder.DeltaBytes` for 1st positional only parameter to call `string_decoder.extract_strings` but got `DecodedString`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 61,
    "warning_line": "                    for decoded_string in string_decoder.extract_strings(delta_bytes, min_length, no_filter):"
  },
  {
    "project": "mandiant/flare-floss",
    "commit": "e86fe0db137a76a47a83034759c0ad7f0213f05f",
    "filename": "floss/main.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/mandiant-flare-floss/floss/main.py",
    "file_hunks_size": 5,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": true,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "floss/main.py:74:8 Incompatible return type [7]: Expected `str` but got `typing.Generator[str, None, None]`.",
    "message": " Expected `str` but got `typing.Generator[str, None, None]`.",
    "rule_id": "Incompatible return type [7]",
    "warning_line_no": 74,
    "warning_line": "        yield sanitize_string_for_printing(s)",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": true,
        "has_suppression": false,
        "source_code": "\ndef sanitize_strings_iterator(str_coll: Iterator[DecodedString]) -> str:\n    \"\"\"\n    Iterate a collection and yield sanitized strings (uses sanitize_string_for_printing)\n    :param str_coll: collection of strings to be sanitized\n    :return: a sanitized string\n    \"\"\"\n    for s_obj in str_coll:\n        s = getattr(s_obj, \"s\", s_obj)  # Use .s attribute from each namedtuple if possible\n        yield sanitize_string_for_printing(s)\n\n\ndef sanitize_string_for_printing(s: str) -> str:\n",
        "source_code_len": 486,
        "target_code": "\ndef sanitize_string_for_printing(s: str) -> str:\n",
        "target_code_len": 50,
        "diff_format": "@@ -65,13 +65,2 @@\n \n-def sanitize_strings_iterator(str_coll: Iterator[DecodedString]) -> str:\n-    \"\"\"\n-    Iterate a collection and yield sanitized strings (uses sanitize_string_for_printing)\n-    :param str_coll: collection of strings to be sanitized\n-    :return: a sanitized string\n-    \"\"\"\n-    for s_obj in str_coll:\n-        s = getattr(s_obj, \"s\", s_obj)  # Use .s attribute from each namedtuple if possible\n-        yield sanitize_string_for_printing(s)\n-\n-\n def sanitize_string_for_printing(s: str) -> str:\n",
        "source_code_with_indent": "\n<DED>def sanitize_strings_iterator(str_coll: Iterator[DecodedString]) -> str:\n    <IND>\"\"\"\n    Iterate a collection and yield sanitized strings (uses sanitize_string_for_printing)\n    :param str_coll: collection of strings to be sanitized\n    :return: a sanitized string\n    \"\"\"\n    for s_obj in str_coll:\n        <IND>s = getattr(s_obj, \"s\", s_obj)  # Use .s attribute from each namedtuple if possible\n        yield sanitize_string_for_printing(s)\n\n\n<DED><DED>def sanitize_string_for_printing(s: str) -> str:\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n<DED>def sanitize_string_for_printing(s: str) -> str:\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "mandiant/flare-floss",
    "commit": "e86fe0db137a76a47a83034759c0ad7f0213f05f",
    "filename": "floss/string_decoder.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/mandiant-flare-floss/floss/string_decoder.py",
    "file_hunks_size": 2,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": true,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "floss/string_decoder.py:199:28 Unsupported operand [58]: `+` is not supported for operand types `bytes` and `str`.",
    "message": " `+` is not supported for operand types `bytes` and `str`.",
    "rule_id": "Unsupported operand [58]",
    "warning_line_no": 199,
    "warning_line": "            bytes_before += \"\\x00\" * (after_len - before_len)",
    "min_patch": [
      {
        "hunk_fit_TFix": true,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "        elif after_len > before_len:\n            bytes_before += \"\\x00\" * (after_len - before_len)\n\n",
        "source_code_len": 100,
        "target_code": "        elif after_len > before_len:\n            bytes_before += b\"\\x00\" * (after_len - before_len)\n\n",
        "target_code_len": 101,
        "diff_format": "@@ -198,3 +198,3 @@\n         elif after_len > before_len:\n-            bytes_before += \"\\x00\" * (after_len - before_len)\n+            bytes_before += b\"\\x00\" * (after_len - before_len)\n \n",
        "source_code_with_indent": "        <DED>elif after_len > before_len:\n            <IND>bytes_before += \"\\x00\" * (after_len - before_len)\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "        <DED>elif after_len > before_len:\n            <IND>bytes_before += b\"\\x00\" * (after_len - before_len)\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "mandiant/flare-floss",
    "commit": "e86fe0db137a76a47a83034759c0ad7f0213f05f",
    "filename": "floss/strings.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/mandiant-flare-floss/floss/strings.py",
    "file_hunks_size": 3,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "floss/strings.py:48:8 Incompatible return type [7]: Expected `List[StaticString]` but got `typing.Generator[StaticString, None, None]`.",
    "message": " Expected `List[StaticString]` but got `typing.Generator[StaticString, None, None]`.",
    "rule_id": "Incompatible return type [7]",
    "warning_line_no": 48,
    "warning_line": "        yield StaticString(match.group().decode(\"ascii\"), offset=match.start(), encoding=StringEncoding.ASCII)",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "import re\nfrom typing import List\n\n",
        "source_code_len": 35,
        "target_code": "import re\nfrom typing import List, Iterable\n\n",
        "target_code_len": 45,
        "diff_format": "@@ -3,3 +3,3 @@\n import re\n-from typing import List\n+from typing import List, Iterable\n \n",
        "source_code_with_indent": "import re\nfrom typing import List\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "import re\nfrom typing import List, Iterable\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\ndef extract_ascii_strings(buf, n=4) -> List[StaticString]:\n    \"\"\"\n",
        "source_code_len": 68,
        "target_code": "\ndef extract_ascii_strings(buf, n=4) -> Iterable[StaticString]:\n    \"\"\"\n",
        "target_code_len": 72,
        "diff_format": "@@ -23,3 +23,3 @@\n \n-def extract_ascii_strings(buf, n=4) -> List[StaticString]:\n+def extract_ascii_strings(buf, n=4) -> Iterable[StaticString]:\n     \"\"\"\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\n<DED>def extract_ascii_strings(buf, n=4) -> List[StaticString]:\n    <IND>",
        "target_code_with_indent": "\n<DED>def extract_ascii_strings(buf, n=4) -> Iterable[StaticString]:\n    <IND>"
      }
    ]
  },
  {
    "project": "mandiant/flare-floss",
    "commit": "e86fe0db137a76a47a83034759c0ad7f0213f05f",
    "filename": "floss/strings.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/mandiant-flare-floss/floss/strings.py",
    "file_hunks_size": 3,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "floss/strings.py:75:12 Incompatible return type [7]: Expected `List[StaticString]` but got `typing.Generator[StaticString, None, None]`.",
    "message": " Expected `List[StaticString]` but got `typing.Generator[StaticString, None, None]`.",
    "rule_id": "Incompatible return type [7]",
    "warning_line_no": 75,
    "warning_line": "            yield StaticString(match.group().decode(\"utf-16\"), offset=match.start(), encoding=StringEncoding.UTF16LE)",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "import re\nfrom typing import List\n\n",
        "source_code_len": 35,
        "target_code": "import re\nfrom typing import List, Iterable\n\n",
        "target_code_len": 45,
        "diff_format": "@@ -3,3 +3,3 @@\n import re\n-from typing import List\n+from typing import List, Iterable\n \n",
        "source_code_with_indent": "import re\nfrom typing import List\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "import re\nfrom typing import List, Iterable\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\ndef extract_unicode_strings(buf, n=4) -> List[StaticString]:\n    \"\"\"\n",
        "source_code_len": 70,
        "target_code": "\ndef extract_unicode_strings(buf, n=4) -> Iterable[StaticString]:\n    \"\"\"\n",
        "target_code_len": 74,
        "diff_format": "@@ -50,3 +50,3 @@\n \n-def extract_unicode_strings(buf, n=4) -> List[StaticString]:\n+def extract_unicode_strings(buf, n=4) -> Iterable[StaticString]:\n     \"\"\"\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\n<DED><DED>def extract_unicode_strings(buf, n=4) -> List[StaticString]:\n    <IND>",
        "target_code_with_indent": "\n<DED><DED>def extract_unicode_strings(buf, n=4) -> Iterable[StaticString]:\n    <IND>"
      }
    ]
  }
]