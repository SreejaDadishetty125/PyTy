[
  {
    "project": "scherroman/mugen",
    "commit": "b2a38a94a7f90ca0cf95decf243523ae4e69d305",
    "filename": "src/mugen/utility.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/scherroman-mugen/src/mugen/utility.py",
    "file_hunks_size": 8,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "src/mugen/utility.py:232:40 Unsupported operand [58]: `-` is not supported for operand types `float` and `Opt[float]`.",
    "message": " `-` is not supported for operand types `float` and `Opt[float]`.",
    "rule_id": "Unsupported operand [58]",
    "warning_line_no": 232,
    "warning_line": "            intervals.append(location - previous_location)",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\ndef convert_to_fraction(*varnames: str):\n    \"\"\"\n    Decorator to convert varnames from floats to fractions\n    \"\"\"\n    return preprocess_args(float_to_fraction, *varnames)\n\n\ndef convert_time_to_seconds(*varnames: str):\n    \"\"\"\n    Decorator to convert varnames from TIME_FORMAT to seconds\n    \"\"\"\n    return preprocess_args(time_to_seconds, *varnames)\n\n\ndef convert_time_list_to_seconds(*varnames: str):\n    \"\"\"\n    Decorator to convert varnames from TIME_FORMAT to seconds\n    \"\"\"\n    return preprocess_args(time_list_to_seconds, *varnames)\n\n\n\"\"\" LOCATIONS & INTERVALS \"\"\"\n\ndef offset_locations(locations: List[float], offset: float) -> List[float]:\n    return [location + offset for location in locations]\n\n\ndef intervals_from_locations(locations: List[float]) -> List[float]:\n    intervals = []\n\n    previous_location = None\n    for index, location in enumerate(locations):\n        if index == 0:\n            intervals.append(location)\n        else:\n            intervals.append(location - previous_location)\n        previous_location = location\n\n    return intervals\n\n\ndef locations_from_intervals(intervals: List[float]) -> List[float]:\n    locations = []\n    running_duration = 0\n    for index, interval in enumerate(intervals):\n        if index < len(intervals):\n            running_duration += interval\n            locations.append(running_duration)\n\n    return locations\n\n\ndef split_locations(locations: List[float], pieces_per_split: int) -> List[float]:\n    \"\"\"\n    Splits locations up to form shorter intervals\n\n    Args:\n        locations\n        pieces_per_split: Number of pieces to split each location into\n\n    Returns: Split locations\n    \"\"\"\n    splintered_locations = []\n\n    for index, location in enumerate(locations):\n        splintered_locations.append(location)\n\n        if index == len(locations) - 1:\n            continue\n\n        next_location = locations[index + 1]\n        interval = next_location - location\n        interval_piece = interval / pieces_per_split\n\n        for _ in range(pieces_per_split - 1):\n            location += interval_piece\n            splintered_locations.append(location)\n\n    return splintered_locations\n\n\ndef merge_locations(locations: List[float], pieces_per_merge: int, offset: Opt[int] = None) -> List[float]:\n    \"\"\"\n        Merges adjacent locations to form longer intervals\n    \n        Args:\n            locations\n            pieces_per_merge: Number of adjacent locations to merge at a time\n            offset: Offset for the merging of locations\n    \n        Returns: Merged locations\n    \"\"\"\n    if offset is None:\n        offset = 0\n\n    combined_locations = []\n\n    for index, location in enumerate(locations):\n        if (index - offset) % pieces_per_merge == 0:\n            combined_locations.append(location)\n\n    return combined_locations\n\n\n@convert_to_fraction('speed_multiplier')\ndef locations_after_speed_multiplier(locations: Union[List[float], np.ndarray],\n                                     speed_multiplier: Union[float, Fraction],\n                                     speed_multiplier_offset: Opt[int] = None) -> List[float]:\n    if speed_multiplier > 1:\n        locations = split_locations(locations, speed_multiplier.numerator)\n    elif speed_multiplier < 1:\n        locations = merge_locations(locations, speed_multiplier.denominator,\n                                    speed_multiplier_offset)\n\n    return locations\n\n\ndef start_end_locations_from_intervals(intervals: List[float]):\n    start_locations = []\n    end_locations = []\n\n    running_duration = 0\n    for index, duration in enumerate(intervals):\n        start_time = running_duration\n        end_time = start_time + duration\n\n        start_locations.append(start_time)\n        end_locations.append(end_time)\n\n        running_duration += duration\n\n    return start_locations, end_locations\n\n\n\n\n\n\n\n\n\n\n\n",
        "source_code_len": 3850,
        "target_code": "\ndef validate_speed_multiplier(func):\n    \"\"\"\n    Decorator validates speed multiplier and speed_multiplier_offset values\n    \"\"\"\n\n    @wraps(func)\n    def _validate_speed_multiplier(*args, **kwargs):\n        speed_multiplier = kwargs.get('speed_multiplier')\n        speed_multiplier_offset = kwargs.get('speed_multiplier_offset')\n\n        if speed_multiplier:\n            speed_multiplier = Fraction(speed_multiplier).limit_denominator()\n            if speed_multiplier == 0 or (speed_multiplier.numerator != 1 and speed_multiplier.denominator != 1):\n                raise ValueError(f\"\"\"Improper speed multiplier {speed_multiplier}. \n                                     Speed multipliers must be of the form x or 1/x, where x is a natural number.\"\"\")\n\n        if speed_multiplier_offset:\n            if speed_multiplier >= 1:\n                raise ValueError(f\"\"\"Improper speed multiplier offset {speed_multiplier_offset} for speed multiplier\n                                     {speed_multiplier}. Speed multiplier offsets may only be used with slowdown speed\n                                     multipliers.\"\"\")\n            elif speed_multiplier_offset > speed_multiplier.denominator - 1:\n                raise ValueError(f\"\"\"Improper speed multiplier offset {speed_multiplier_offset} for speed multiplier\n                                     {speed_multiplier}. Speed multiplier offset may not be greater than x - 1 for a \n                                     slowdown of 1/x.\"\"\")\n\n        return func(*args, **kwargs)\n\n    return _validate_speed_multiplier\n",
        "target_code_len": 1566,
        "diff_format": "@@ -196,144 +236,30 @@\n \n-def convert_to_fraction(*varnames: str):\n-    \"\"\"\n-    Decorator to convert varnames from floats to fractions\n-    \"\"\"\n-    return preprocess_args(float_to_fraction, *varnames)\n-\n-\n-def convert_time_to_seconds(*varnames: str):\n-    \"\"\"\n-    Decorator to convert varnames from TIME_FORMAT to seconds\n-    \"\"\"\n-    return preprocess_args(time_to_seconds, *varnames)\n-\n-\n-def convert_time_list_to_seconds(*varnames: str):\n-    \"\"\"\n-    Decorator to convert varnames from TIME_FORMAT to seconds\n-    \"\"\"\n-    return preprocess_args(time_list_to_seconds, *varnames)\n-\n-\n-\"\"\" LOCATIONS & INTERVALS \"\"\"\n-\n-def offset_locations(locations: List[float], offset: float) -> List[float]:\n-    return [location + offset for location in locations]\n-\n-\n-def intervals_from_locations(locations: List[float]) -> List[float]:\n-    intervals = []\n-\n-    previous_location = None\n-    for index, location in enumerate(locations):\n-        if index == 0:\n-            intervals.append(location)\n-        else:\n-            intervals.append(location - previous_location)\n-        previous_location = location\n-\n-    return intervals\n-\n-\n-def locations_from_intervals(intervals: List[float]) -> List[float]:\n-    locations = []\n-    running_duration = 0\n-    for index, interval in enumerate(intervals):\n-        if index < len(intervals):\n-            running_duration += interval\n-            locations.append(running_duration)\n-\n-    return locations\n-\n-\n-def split_locations(locations: List[float], pieces_per_split: int) -> List[float]:\n-    \"\"\"\n-    Splits locations up to form shorter intervals\n-\n-    Args:\n-        locations\n-        pieces_per_split: Number of pieces to split each location into\n-\n-    Returns: Split locations\n-    \"\"\"\n-    splintered_locations = []\n-\n-    for index, location in enumerate(locations):\n-        splintered_locations.append(location)\n-\n-        if index == len(locations) - 1:\n-            continue\n-\n-        next_location = locations[index + 1]\n-        interval = next_location - location\n-        interval_piece = interval / pieces_per_split\n-\n-        for _ in range(pieces_per_split - 1):\n-            location += interval_piece\n-            splintered_locations.append(location)\n-\n-    return splintered_locations\n-\n-\n-def merge_locations(locations: List[float], pieces_per_merge: int, offset: Opt[int] = None) -> List[float]:\n-    \"\"\"\n-        Merges adjacent locations to form longer intervals\n-    \n-        Args:\n-            locations\n-            pieces_per_merge: Number of adjacent locations to merge at a time\n-            offset: Offset for the merging of locations\n-    \n-        Returns: Merged locations\n-    \"\"\"\n-    if offset is None:\n-        offset = 0\n-\n-    combined_locations = []\n-\n-    for index, location in enumerate(locations):\n-        if (index - offset) % pieces_per_merge == 0:\n-            combined_locations.append(location)\n-\n-    return combined_locations\n-\n-\n-@convert_to_fraction('speed_multiplier')\n-def locations_after_speed_multiplier(locations: Union[List[float], np.ndarray],\n-                                     speed_multiplier: Union[float, Fraction],\n-                                     speed_multiplier_offset: Opt[int] = None) -> List[float]:\n-    if speed_multiplier > 1:\n-        locations = split_locations(locations, speed_multiplier.numerator)\n-    elif speed_multiplier < 1:\n-        locations = merge_locations(locations, speed_multiplier.denominator,\n-                                    speed_multiplier_offset)\n-\n-    return locations\n-\n-\n-def start_end_locations_from_intervals(intervals: List[float]):\n-    start_locations = []\n-    end_locations = []\n-\n-    running_duration = 0\n-    for index, duration in enumerate(intervals):\n-        start_time = running_duration\n-        end_time = start_time + duration\n-\n-        start_locations.append(start_time)\n-        end_locations.append(end_time)\n-\n-        running_duration += duration\n-\n-    return start_locations, end_locations\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n+def validate_speed_multiplier(func):\n+    \"\"\"\n+    Decorator validates speed multiplier and speed_multiplier_offset values\n+    \"\"\"\n+\n+    @wraps(func)\n+    def _validate_speed_multiplier(*args, **kwargs):\n+        speed_multiplier = kwargs.get('speed_multiplier')\n+        speed_multiplier_offset = kwargs.get('speed_multiplier_offset')\n+\n+        if speed_multiplier:\n+            speed_multiplier = Fraction(speed_multiplier).limit_denominator()\n+            if speed_multiplier == 0 or (speed_multiplier.numerator != 1 and speed_multiplier.denominator != 1):\n+                raise ValueError(f\"\"\"Improper speed multiplier {speed_multiplier}. \n+                                     Speed multipliers must be of the form x or 1/x, where x is a natural number.\"\"\")\n+\n+        if speed_multiplier_offset:\n+            if speed_multiplier >= 1:\n+                raise ValueError(f\"\"\"Improper speed multiplier offset {speed_multiplier_offset} for speed multiplier\n+                                     {speed_multiplier}. Speed multiplier offsets may only be used with slowdown speed\n+                                     multipliers.\"\"\")\n+            elif speed_multiplier_offset > speed_multiplier.denominator - 1:\n+                raise ValueError(f\"\"\"Improper speed multiplier offset {speed_multiplier_offset} for speed multiplier\n+                                     {speed_multiplier}. Speed multiplier offset may not be greater than x - 1 for a \n+                                     slowdown of 1/x.\"\"\")\n+\n+        return func(*args, **kwargs)\n+\n+    return _validate_speed_multiplier\n",
        "source_code_with_indent": "\n<DED>def convert_to_fraction(*varnames: str):\n    <IND>\"\"\"\n    Decorator to convert varnames from floats to fractions\n    \"\"\"\n    return preprocess_args(float_to_fraction, *varnames)\n\n\n<DED>def convert_time_to_seconds(*varnames: str):\n    <IND>\"\"\"\n    Decorator to convert varnames from TIME_FORMAT to seconds\n    \"\"\"\n    return preprocess_args(time_to_seconds, *varnames)\n\n\n<DED>def convert_time_list_to_seconds(*varnames: str):\n    <IND>\"\"\"\n    Decorator to convert varnames from TIME_FORMAT to seconds\n    \"\"\"\n    return preprocess_args(time_list_to_seconds, *varnames)\n\n\n<DED>\"\"\" LOCATIONS & INTERVALS \"\"\"\n\ndef offset_locations(locations: List[float], offset: float) -> List[float]:\n    <IND>return [location + offset for location in locations]\n\n\n<DED>def intervals_from_locations(locations: List[float]) -> List[float]:\n    <IND>intervals = []\n\n    previous_location = None\n    for index, location in enumerate(locations):\n        <IND>if index == 0:\n            <IND>intervals.append(location)\n        <DED>else:\n            <IND>intervals.append(location - previous_location)\n        <DED>previous_location = location\n\n    <DED>return intervals\n\n\n<DED>def locations_from_intervals(intervals: List[float]) -> List[float]:\n    <IND>locations = []\n    running_duration = 0\n    for index, interval in enumerate(intervals):\n        <IND>if index < len(intervals):\n            <IND>running_duration += interval\n            locations.append(running_duration)\n\n    <DED><DED>return locations\n\n\n<DED>def split_locations(locations: List[float], pieces_per_split: int) -> List[float]:\n    <IND>\"\"\"\n    Splits locations up to form shorter intervals\n\n    Args:\n        locations\n        pieces_per_split: Number of pieces to split each location into\n\n    Returns: Split locations\n    \"\"\"\n    splintered_locations = []\n\n    for index, location in enumerate(locations):\n        <IND>splintered_locations.append(location)\n\n        if index == len(locations) - 1:\n            <IND>continue\n\n        <DED>next_location = locations[index + 1]\n        interval = next_location - location\n        interval_piece = interval / pieces_per_split\n\n        for _ in range(pieces_per_split - 1):\n            <IND>location += interval_piece\n            splintered_locations.append(location)\n\n    <DED><DED>return splintered_locations\n\n\n<DED>def merge_locations(locations: List[float], pieces_per_merge: int, offset: Opt[int] = None) -> List[float]:\n    <IND>\"\"\"\n        Merges adjacent locations to form longer intervals\n    \n        Args:\n            locations\n            pieces_per_merge: Number of adjacent locations to merge at a time\n            offset: Offset for the merging of locations\n    \n        Returns: Merged locations\n    \"\"\"\n    if offset is None:\n        <IND>offset = 0\n\n    <DED>combined_locations = []\n\n    for index, location in enumerate(locations):\n        <IND>if (index - offset) % pieces_per_merge == 0:\n            <IND>combined_locations.append(location)\n\n    <DED><DED>return combined_locations\n\n\n<DED>@convert_to_fraction('speed_multiplier')\ndef locations_after_speed_multiplier(locations: Union[List[float], np.ndarray],\n                                     speed_multiplier: Union[float, Fraction],\n                                     speed_multiplier_offset: Opt[int] = None) -> List[float]:\n    <IND>if speed_multiplier > 1:\n        <IND>locations = split_locations(locations, speed_multiplier.numerator)\n    <DED>elif speed_multiplier < 1:\n        <IND>locations = merge_locations(locations, speed_multiplier.denominator,\n                                    speed_multiplier_offset)\n\n    <DED>return locations\n\n\n<DED>def start_end_locations_from_intervals(intervals: List[float]):\n    <IND>start_locations = []\n    end_locations = []\n\n    running_duration = 0\n    for index, duration in enumerate(intervals):\n        <IND>start_time = running_duration\n        end_time = start_time + duration\n\n        start_locations.append(start_time)\n        end_locations.append(end_time)\n\n        running_duration += duration\n\n    <DED>return start_locations, end_locations\n\n\n\n\n\n\n\n\n\n\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n<DED>def validate_speed_multiplier(func):\n    <IND>\"\"\"\n    Decorator validates speed multiplier and speed_multiplier_offset values\n    \"\"\"\n\n    @wraps(func)\n    def _validate_speed_multiplier(*args, **kwargs):\n        <IND>speed_multiplier = kwargs.get('speed_multiplier')\n        speed_multiplier_offset = kwargs.get('speed_multiplier_offset')\n\n        if speed_multiplier:\n            <IND>speed_multiplier = Fraction(speed_multiplier).limit_denominator()\n            if speed_multiplier == 0 or (speed_multiplier.numerator != 1 and speed_multiplier.denominator != 1):\n                <IND>raise ValueError(f\"\"\"Improper speed multiplier {speed_multiplier}. \n                                     Speed multipliers must be of the form x or 1/x, where x is a natural number.\"\"\")\n\n        <DED><DED>if speed_multiplier_offset:\n            <IND>if speed_multiplier >= 1:\n                <IND>raise ValueError(f\"\"\"Improper speed multiplier offset {speed_multiplier_offset} for speed multiplier\n                                     {speed_multiplier}. Speed multiplier offsets may only be used with slowdown speed\n                                     multipliers.\"\"\")\n            <DED>elif speed_multiplier_offset > speed_multiplier.denominator - 1:\n                <IND>raise ValueError(f\"\"\"Improper speed multiplier offset {speed_multiplier_offset} for speed multiplier\n                                     {speed_multiplier}. Speed multiplier offset may not be greater than x - 1 for a \n                                     slowdown of 1/x.\"\"\")\n\n        <DED><DED>return func(*args, **kwargs)\n\n    <DED>return _validate_speed_multiplier\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  }
]