[
  {
    "project": "kubeflow/pipelines",
    "commit": "b46f1b86f18a7539985ed15c0bb727281eb4d353",
    "filename": "sdk/python/kfp/dsl/io_types.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/kubeflow-pipelines/sdk/python/kfp/dsl/io_types.py",
    "file_hunks_size": 4,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "sdk/python/kfp/dsl/io_types.py:383:4 Incompatible return type [7]: Expected `Variable[T (bound to Artifact)]` but got `Optional[Variable[T (bound to Artifact)]]`.",
    "message": " Expected `Variable[T (bound to Artifact)]` but got `Optional[Variable[T (bound to Artifact)]]`.",
    "rule_id": "Incompatible return type [7]",
    "warning_line_no": 383,
    "warning_line": "    return self._artifact",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\nT = TypeVar('T', bound=Artifact)\n\n_GCS_LOCAL_MOUNT_PREFIX = '/gcs/'\n\n\nclass _IOArtifact():\n  \"\"\"Internal wrapper class for representing Input/Output Artifacts.\"\"\"\n\n  def __init__(self, artifact_type: Type[T], artifact: Optional[T] = None):\n    self.type = artifact_type\n    self._artifact = artifact\n\n  def get(self) -> T:\n    return self._artifact\n\n  @property\n  def uri(self):\n    return self._artifact.uri\n\n  @uri.setter\n  def uri(self, uri):\n    self._artifact.uri = uri\n\n  @property\n  def path(self):\n    return self._get_path()\n\n  @path.setter\n  def path(self, path):\n    self._set_path(path)\n\n  def _get_path(self) -> str:\n    if self._artifact.uri.startswith('gs://'):\n      return _GCS_LOCAL_MOUNT_PREFIX + self._artifact.uri[len('gs://'):]\n\n  def _set_path(self, path):\n    if path.startswith(_GCS_LOCAL_MOUNT_PREFIX):\n      path = 'gs://' + path[len(_GCS_LOCAL_MOUNT_PREFIX):]\n    self._artifact.uri = path\n\n\nclass InputArtifact(_IOArtifact):\n\n  def __init__(self, artifact_type: Type[T], artifact: Optional[T] = None):\n    super().__init__(artifact_type=artifact_type, artifact=artifact)\n\n\nclass OutputArtifact(_IOArtifact):\n\n  def __init__(self, artifact_type: Type[T], artifact: Optional[T] = None):\n    super().__init__(artifact_type=artifact_type, artifact=artifact)\n    if artifact is not None:\n      os.makedirs(self.path, exist_ok=True)\n      self.path = os.path.join(self.path, 'data')\n\n",
        "source_code_len": 1408,
        "target_code": "\nT = TypeVar('T')\n\n\nclass InputAnnotation():\n  \"\"\"Marker type for input artifacts.\"\"\"\n  pass\n\n\n\nclass OutputAnnotation():\n  \"\"\"Marker type for output artifacts.\"\"\"\n  pass\n\n\n# TODO: Use typing.Annotated instead of this hack.\n# With typing.Annotated (Python 3.9+ or typing_extensions package), the\n# following would look like:\n# Input = typing.Annotated[T, InputAnnotation]\n# Output = typing.Annotated[T, OutputAnnotation]\n\n\n# Input represents an Input artifact of type T.\nInput = Union[T, InputAnnotation]\n\n# Output represents an Output artifact of type T.\nOutput = Union[T, OutputAnnotation]\n\n\ndef is_artifact_annotation(typ) -> bool:\n  if hasattr(typ, '_subs_tree'):  # Python 3.6\n    subs_tree = typ._subs_tree()\n    return len(subs_tree) == 3 and subs_tree[0] == Union and subs_tree[2] in [InputAnnotation, OutputAnnotation]\n\n  if not hasattr(typ, '__origin__'):\n    return False\n\n\n  if typ.__origin__ != Union and type(typ.__origin__) != type(Union):\n    return False\n\n\n  if not hasattr(typ, '__args__') or len(typ.__args__) != 2:\n    return False\n\n  return True\n\ndef is_input_artifact(typ) -> bool:\n  \"\"\"Returns True if typ is of type Input[T].\"\"\"\n  if not is_artifact_annotation(typ):\n    return False\n\n  if hasattr(typ, '_subs_tree'):  # Python 3.6\n    subs_tree = typ._subs_tree()\n    return len(subs_tree) == 3 and subs_tree[2]  == InputAnnotation\n\n  return typ.__args__[1] == InputAnnotation\n\ndef is_output_artifact(typ) -> bool:\n  \"\"\"Returns True if typ is of type Output[T].\"\"\"\n  if not is_artifact_annotation(typ):\n    return False\n\n  if hasattr(typ, '_subs_tree'):  # Python 3.6\n    subs_tree = typ._subs_tree()\n    return len(subs_tree) == 3 and subs_tree[2]  == OutputAnnotation\n\n  return typ.__args__[1] == OutputAnnotation\n\ndef get_io_artifact_class(typ):\n  if not is_artifact_annotation(typ):\n    return None\n  if typ == Input or typ == Output:\n    return None\n\n  if hasattr(typ, '_subs_tree'):  # Python 3.6\n    subs_tree = typ._subs_tree()\n    if len(subs_tree) != 3:\n      return None\n    return subs_tree[1]\n\n  return typ.__args__[0]\n\ndef get_io_artifact_annotation(typ):\n  if not is_artifact_annotation(typ):\n    return None\n\n  if hasattr(typ, '_subs_tree'):  # Python 3.6\n    subs_tree = typ._subs_tree()\n    if len(subs_tree) != 3:\n      return None\n    return subs_tree[2]\n\n  return typ.__args__[1]\n\n\n",
        "target_code_len": 2328,
        "diff_format": "@@ -369,56 +390,96 @@\n \n-T = TypeVar('T', bound=Artifact)\n-\n-_GCS_LOCAL_MOUNT_PREFIX = '/gcs/'\n-\n-\n-class _IOArtifact():\n-  \"\"\"Internal wrapper class for representing Input/Output Artifacts.\"\"\"\n-\n-  def __init__(self, artifact_type: Type[T], artifact: Optional[T] = None):\n-    self.type = artifact_type\n-    self._artifact = artifact\n-\n-  def get(self) -> T:\n-    return self._artifact\n-\n-  @property\n-  def uri(self):\n-    return self._artifact.uri\n-\n-  @uri.setter\n-  def uri(self, uri):\n-    self._artifact.uri = uri\n-\n-  @property\n-  def path(self):\n-    return self._get_path()\n-\n-  @path.setter\n-  def path(self, path):\n-    self._set_path(path)\n-\n-  def _get_path(self) -> str:\n-    if self._artifact.uri.startswith('gs://'):\n-      return _GCS_LOCAL_MOUNT_PREFIX + self._artifact.uri[len('gs://'):]\n-\n-  def _set_path(self, path):\n-    if path.startswith(_GCS_LOCAL_MOUNT_PREFIX):\n-      path = 'gs://' + path[len(_GCS_LOCAL_MOUNT_PREFIX):]\n-    self._artifact.uri = path\n-\n-\n-class InputArtifact(_IOArtifact):\n-\n-  def __init__(self, artifact_type: Type[T], artifact: Optional[T] = None):\n-    super().__init__(artifact_type=artifact_type, artifact=artifact)\n-\n-\n-class OutputArtifact(_IOArtifact):\n-\n-  def __init__(self, artifact_type: Type[T], artifact: Optional[T] = None):\n-    super().__init__(artifact_type=artifact_type, artifact=artifact)\n-    if artifact is not None:\n-      os.makedirs(self.path, exist_ok=True)\n-      self.path = os.path.join(self.path, 'data')\n+T = TypeVar('T')\n+\n+\n+class InputAnnotation():\n+  \"\"\"Marker type for input artifacts.\"\"\"\n+  pass\n+\n+\n+\n+class OutputAnnotation():\n+  \"\"\"Marker type for output artifacts.\"\"\"\n+  pass\n+\n+\n+# TODO: Use typing.Annotated instead of this hack.\n+# With typing.Annotated (Python 3.9+ or typing_extensions package), the\n+# following would look like:\n+# Input = typing.Annotated[T, InputAnnotation]\n+# Output = typing.Annotated[T, OutputAnnotation]\n+\n+\n+# Input represents an Input artifact of type T.\n+Input = Union[T, InputAnnotation]\n+\n+# Output represents an Output artifact of type T.\n+Output = Union[T, OutputAnnotation]\n+\n+\n+def is_artifact_annotation(typ) -> bool:\n+  if hasattr(typ, '_subs_tree'):  # Python 3.6\n+    subs_tree = typ._subs_tree()\n+    return len(subs_tree) == 3 and subs_tree[0] == Union and subs_tree[2] in [InputAnnotation, OutputAnnotation]\n+\n+  if not hasattr(typ, '__origin__'):\n+    return False\n+\n+\n+  if typ.__origin__ != Union and type(typ.__origin__) != type(Union):\n+    return False\n+\n+\n+  if not hasattr(typ, '__args__') or len(typ.__args__) != 2:\n+    return False\n+\n+  return True\n+\n+def is_input_artifact(typ) -> bool:\n+  \"\"\"Returns True if typ is of type Input[T].\"\"\"\n+  if not is_artifact_annotation(typ):\n+    return False\n+\n+  if hasattr(typ, '_subs_tree'):  # Python 3.6\n+    subs_tree = typ._subs_tree()\n+    return len(subs_tree) == 3 and subs_tree[2]  == InputAnnotation\n+\n+  return typ.__args__[1] == InputAnnotation\n+\n+def is_output_artifact(typ) -> bool:\n+  \"\"\"Returns True if typ is of type Output[T].\"\"\"\n+  if not is_artifact_annotation(typ):\n+    return False\n+\n+  if hasattr(typ, '_subs_tree'):  # Python 3.6\n+    subs_tree = typ._subs_tree()\n+    return len(subs_tree) == 3 and subs_tree[2]  == OutputAnnotation\n+\n+  return typ.__args__[1] == OutputAnnotation\n+\n+def get_io_artifact_class(typ):\n+  if not is_artifact_annotation(typ):\n+    return None\n+  if typ == Input or typ == Output:\n+    return None\n+\n+  if hasattr(typ, '_subs_tree'):  # Python 3.6\n+    subs_tree = typ._subs_tree()\n+    if len(subs_tree) != 3:\n+      return None\n+    return subs_tree[1]\n+\n+  return typ.__args__[0]\n+\n+def get_io_artifact_annotation(typ):\n+  if not is_artifact_annotation(typ):\n+    return None\n+\n+  if hasattr(typ, '_subs_tree'):  # Python 3.6\n+    subs_tree = typ._subs_tree()\n+    if len(subs_tree) != 3:\n+      return None\n+    return subs_tree[2]\n+\n+  return typ.__args__[1]\n+\n \n",
        "source_code_with_indent": "\n<DED><DED>T = TypeVar('T', bound=Artifact)\n\n_GCS_LOCAL_MOUNT_PREFIX = '/gcs/'\n\n\nclass _IOArtifact():\n  <IND>\"\"\"Internal wrapper class for representing Input/Output Artifacts.\"\"\"\n\n  def __init__(self, artifact_type: Type[T], artifact: Optional[T] = None):\n    <IND>self.type = artifact_type\n    self._artifact = artifact\n\n  <DED>def get(self) -> T:\n    <IND>return self._artifact\n\n  <DED>@property\n  def uri(self):\n    <IND>return self._artifact.uri\n\n  <DED>@uri.setter\n  def uri(self, uri):\n    <IND>self._artifact.uri = uri\n\n  <DED>@property\n  def path(self):\n    <IND>return self._get_path()\n\n  <DED>@path.setter\n  def path(self, path):\n    <IND>self._set_path(path)\n\n  <DED>def _get_path(self) -> str:\n    <IND>if self._artifact.uri.startswith('gs://'):\n      <IND>return _GCS_LOCAL_MOUNT_PREFIX + self._artifact.uri[len('gs://'):]\n\n  <DED><DED>def _set_path(self, path):\n    <IND>if path.startswith(_GCS_LOCAL_MOUNT_PREFIX):\n      <IND>path = 'gs://' + path[len(_GCS_LOCAL_MOUNT_PREFIX):]\n    <DED>self._artifact.uri = path\n\n\n<DED><DED>class InputArtifact(_IOArtifact):\n\n  <IND>def __init__(self, artifact_type: Type[T], artifact: Optional[T] = None):\n    <IND>super().__init__(artifact_type=artifact_type, artifact=artifact)\n\n\n<DED><DED>class OutputArtifact(_IOArtifact):\n\n  <IND>def __init__(self, artifact_type: Type[T], artifact: Optional[T] = None):\n    <IND>super().__init__(artifact_type=artifact_type, artifact=artifact)\n    if artifact is not None:\n      <IND>os.makedirs(self.path, exist_ok=True)\n      self.path = os.path.join(self.path, 'data')\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n<DED><DED>T = TypeVar('T')\n\n\nclass InputAnnotation():\n  <IND>\"\"\"Marker type for input artifacts.\"\"\"\n  pass\n\n\n\n<DED>class OutputAnnotation():\n  <IND>\"\"\"Marker type for output artifacts.\"\"\"\n  pass\n\n\n# TODO: Use typing.Annotated instead of this hack.\n# With typing.Annotated (Python 3.9+ or typing_extensions package), the\n# following would look like:\n# Input = typing.Annotated[T, InputAnnotation]\n# Output = typing.Annotated[T, OutputAnnotation]\n\n\n# Input represents an Input artifact of type T.\n<DED>Input = Union[T, InputAnnotation]\n\n# Output represents an Output artifact of type T.\nOutput = Union[T, OutputAnnotation]\n\n\ndef is_artifact_annotation(typ) -> bool:\n  <IND>if hasattr(typ, '_subs_tree'):  # Python 3.6\n    <IND>subs_tree = typ._subs_tree()\n    return len(subs_tree) == 3 and subs_tree[0] == Union and subs_tree[2] in [InputAnnotation, OutputAnnotation]\n\n  <DED>if not hasattr(typ, '__origin__'):\n    <IND>return False\n\n\n  <DED>if typ.__origin__ != Union and type(typ.__origin__) != type(Union):\n    <IND>return False\n\n\n  <DED>if not hasattr(typ, '__args__') or len(typ.__args__) != 2:\n    <IND>return False\n\n  <DED>return True\n\n<DED>def is_input_artifact(typ) -> bool:\n  <IND>\"\"\"Returns True if typ is of type Input[T].\"\"\"\n  if not is_artifact_annotation(typ):\n    <IND>return False\n\n  <DED>if hasattr(typ, '_subs_tree'):  # Python 3.6\n    <IND>subs_tree = typ._subs_tree()\n    return len(subs_tree) == 3 and subs_tree[2]  == InputAnnotation\n\n  <DED>return typ.__args__[1] == InputAnnotation\n\n<DED>def is_output_artifact(typ) -> bool:\n  <IND>\"\"\"Returns True if typ is of type Output[T].\"\"\"\n  if not is_artifact_annotation(typ):\n    <IND>return False\n\n  <DED>if hasattr(typ, '_subs_tree'):  # Python 3.6\n    <IND>subs_tree = typ._subs_tree()\n    return len(subs_tree) == 3 and subs_tree[2]  == OutputAnnotation\n\n  <DED>return typ.__args__[1] == OutputAnnotation\n\n<DED>def get_io_artifact_class(typ):\n  <IND>if not is_artifact_annotation(typ):\n    <IND>return None\n  <DED>if typ == Input or typ == Output:\n    <IND>return None\n\n  <DED>if hasattr(typ, '_subs_tree'):  # Python 3.6\n    <IND>subs_tree = typ._subs_tree()\n    if len(subs_tree) != 3:\n      <IND>return None\n    <DED>return subs_tree[1]\n\n  <DED>return typ.__args__[0]\n\n<DED>def get_io_artifact_annotation(typ):\n  <IND>if not is_artifact_annotation(typ):\n    <IND>return None\n\n  <DED>if hasattr(typ, '_subs_tree'):  # Python 3.6\n    <IND>subs_tree = typ._subs_tree()\n    if len(subs_tree) != 3:\n      <IND>return None\n    <DED>return subs_tree[2]\n\n  <DED>return typ.__args__[1]\n\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  }
]