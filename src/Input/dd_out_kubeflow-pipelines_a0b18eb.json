[
  {
    "project": "kubeflow/pipelines",
    "commit": "a0b18eb9e8da25c7b81b0b75cf0f39297c809d20",
    "filename": "sdk/python/kfp/components/_data_passing.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/kubeflow-pipelines/sdk/python/kfp/components/_data_passing.py",
    "file_hunks_size": 5,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "sdk/python/kfp/components/_data_passing.py:116:14 Incompatible parameter type [6]: Expected `Sequence[str]` for 1st positional only parameter to call `Converter.__init__` but got `Sequence[typing.Type[str]]`.",
    "message": " Expected `Sequence[str]` for 1st positional only parameter to call `Converter.__init__` but got `Sequence[typing.Type[str]]`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 116,
    "warning_line": "    Converter([str], ['String', 'str'], _serialize_str, 'str', None),",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "import inspect\nfrom typing import Any, Callable, NamedTuple, Sequence\nimport warnings\n",
        "source_code_len": 86,
        "target_code": "import inspect\nfrom typing import Any, Callable, NamedTuple, Optional, Sequence, Type\nimport warnings\n",
        "target_code_len": 102,
        "diff_format": "@@ -23,3 +22,3 @@\n import inspect\n-from typing import Any, Callable, NamedTuple, Sequence\n+from typing import Any, Callable, NamedTuple, Optional, Sequence, Type\n import warnings\n",
        "source_code_with_indent": "import inspect\nfrom typing import Any, Callable, NamedTuple, Sequence\nimport warnings\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "import inspect\nfrom typing import Any, Callable, NamedTuple, Optional, Sequence, Type\nimport warnings\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "Converter = NamedTuple('Converter', [\n    ('types', Sequence[str]),\n    ('type_names', Sequence[str]),\n",
        "source_code_len": 103,
        "target_code": "Converter = NamedTuple('Converter', [\n    ('types', Sequence[Type]),\n    ('type_names', Sequence[str]),\n",
        "target_code_len": 104,
        "diff_format": "@@ -29,3 +28,3 @@\n Converter = NamedTuple('Converter', [\n-    ('types', Sequence[str]),\n+    ('types', Sequence[Type]),\n     ('type_names', Sequence[str]),\n",
        "source_code_with_indent": "Converter = NamedTuple('Converter', [\n    ('types', Sequence[str]),\n    ('type_names', Sequence[str]),\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "Converter = NamedTuple('Converter', [\n    ('types', Sequence[Type]),\n    ('type_names', Sequence[str]),\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "kubeflow/pipelines",
    "commit": "a0b18eb9e8da25c7b81b0b75cf0f39297c809d20",
    "filename": "sdk/python/kfp/components/_data_passing.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/kubeflow-pipelines/sdk/python/kfp/components/_data_passing.py",
    "file_hunks_size": 5,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "sdk/python/kfp/components/_data_passing.py:117:14 Incompatible parameter type [6]: Expected `Sequence[str]` for 1st positional only parameter to call `Converter.__init__` but got `Sequence[typing.Type[int]]`.",
    "message": " Expected `Sequence[str]` for 1st positional only parameter to call `Converter.__init__` but got `Sequence[typing.Type[int]]`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 117,
    "warning_line": "    Converter([int], ['Integer', 'int'], _serialize_int, 'int', None),",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "import inspect\nfrom typing import Any, Callable, NamedTuple, Sequence\nimport warnings\n",
        "source_code_len": 86,
        "target_code": "import inspect\nfrom typing import Any, Callable, NamedTuple, Optional, Sequence, Type\nimport warnings\n",
        "target_code_len": 102,
        "diff_format": "@@ -23,3 +22,3 @@\n import inspect\n-from typing import Any, Callable, NamedTuple, Sequence\n+from typing import Any, Callable, NamedTuple, Optional, Sequence, Type\n import warnings\n",
        "source_code_with_indent": "import inspect\nfrom typing import Any, Callable, NamedTuple, Sequence\nimport warnings\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "import inspect\nfrom typing import Any, Callable, NamedTuple, Optional, Sequence, Type\nimport warnings\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "Converter = NamedTuple('Converter', [\n    ('types', Sequence[str]),\n    ('type_names', Sequence[str]),\n",
        "source_code_len": 103,
        "target_code": "Converter = NamedTuple('Converter', [\n    ('types', Sequence[Type]),\n    ('type_names', Sequence[str]),\n",
        "target_code_len": 104,
        "diff_format": "@@ -29,3 +28,3 @@\n Converter = NamedTuple('Converter', [\n-    ('types', Sequence[str]),\n+    ('types', Sequence[Type]),\n     ('type_names', Sequence[str]),\n",
        "source_code_with_indent": "Converter = NamedTuple('Converter', [\n    ('types', Sequence[str]),\n    ('type_names', Sequence[str]),\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "Converter = NamedTuple('Converter', [\n    ('types', Sequence[Type]),\n    ('type_names', Sequence[str]),\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "kubeflow/pipelines",
    "commit": "a0b18eb9e8da25c7b81b0b75cf0f39297c809d20",
    "filename": "sdk/python/kfp/components/_data_passing.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/kubeflow-pipelines/sdk/python/kfp/components/_data_passing.py",
    "file_hunks_size": 5,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "sdk/python/kfp/components/_data_passing.py:118:14 Incompatible parameter type [6]: Expected `Sequence[str]` for 1st positional only parameter to call `Converter.__init__` but got `Sequence[typing.Type[float]]`.",
    "message": " Expected `Sequence[str]` for 1st positional only parameter to call `Converter.__init__` but got `Sequence[typing.Type[float]]`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 118,
    "warning_line": "    Converter([float], ['Float', 'float'], _serialize_float, 'float', None),",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "import inspect\nfrom typing import Any, Callable, NamedTuple, Sequence\nimport warnings\n",
        "source_code_len": 86,
        "target_code": "import inspect\nfrom typing import Any, Callable, NamedTuple, Optional, Sequence, Type\nimport warnings\n",
        "target_code_len": 102,
        "diff_format": "@@ -23,3 +22,3 @@\n import inspect\n-from typing import Any, Callable, NamedTuple, Sequence\n+from typing import Any, Callable, NamedTuple, Optional, Sequence, Type\n import warnings\n",
        "source_code_with_indent": "import inspect\nfrom typing import Any, Callable, NamedTuple, Sequence\nimport warnings\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "import inspect\nfrom typing import Any, Callable, NamedTuple, Optional, Sequence, Type\nimport warnings\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "Converter = NamedTuple('Converter', [\n    ('types', Sequence[str]),\n    ('type_names', Sequence[str]),\n",
        "source_code_len": 103,
        "target_code": "Converter = NamedTuple('Converter', [\n    ('types', Sequence[Type]),\n    ('type_names', Sequence[str]),\n",
        "target_code_len": 104,
        "diff_format": "@@ -29,3 +28,3 @@\n Converter = NamedTuple('Converter', [\n-    ('types', Sequence[str]),\n+    ('types', Sequence[Type]),\n     ('type_names', Sequence[str]),\n",
        "source_code_with_indent": "Converter = NamedTuple('Converter', [\n    ('types', Sequence[str]),\n    ('type_names', Sequence[str]),\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "Converter = NamedTuple('Converter', [\n    ('types', Sequence[Type]),\n    ('type_names', Sequence[str]),\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "kubeflow/pipelines",
    "commit": "a0b18eb9e8da25c7b81b0b75cf0f39297c809d20",
    "filename": "sdk/python/kfp/components/_data_passing.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/kubeflow-pipelines/sdk/python/kfp/components/_data_passing.py",
    "file_hunks_size": 5,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "sdk/python/kfp/components/_data_passing.py:119:14 Incompatible parameter type [6]: Expected `Sequence[str]` for 1st positional only parameter to call `Converter.__init__` but got `Sequence[typing.Type[bool]]`.",
    "message": " Expected `Sequence[str]` for 1st positional only parameter to call `Converter.__init__` but got `Sequence[typing.Type[bool]]`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 119,
    "warning_line": "    Converter([bool], ['Boolean', 'Bool', 'bool'], _serialize_bool,",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "import inspect\nfrom typing import Any, Callable, NamedTuple, Sequence\nimport warnings\n",
        "source_code_len": 86,
        "target_code": "import inspect\nfrom typing import Any, Callable, NamedTuple, Optional, Sequence, Type\nimport warnings\n",
        "target_code_len": 102,
        "diff_format": "@@ -23,3 +22,3 @@\n import inspect\n-from typing import Any, Callable, NamedTuple, Sequence\n+from typing import Any, Callable, NamedTuple, Optional, Sequence, Type\n import warnings\n",
        "source_code_with_indent": "import inspect\nfrom typing import Any, Callable, NamedTuple, Sequence\nimport warnings\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "import inspect\nfrom typing import Any, Callable, NamedTuple, Optional, Sequence, Type\nimport warnings\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "Converter = NamedTuple('Converter', [\n    ('types', Sequence[str]),\n    ('type_names', Sequence[str]),\n",
        "source_code_len": 103,
        "target_code": "Converter = NamedTuple('Converter', [\n    ('types', Sequence[Type]),\n    ('type_names', Sequence[str]),\n",
        "target_code_len": 104,
        "diff_format": "@@ -29,3 +28,3 @@\n Converter = NamedTuple('Converter', [\n-    ('types', Sequence[str]),\n+    ('types', Sequence[Type]),\n     ('type_names', Sequence[str]),\n",
        "source_code_with_indent": "Converter = NamedTuple('Converter', [\n    ('types', Sequence[str]),\n    ('type_names', Sequence[str]),\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "Converter = NamedTuple('Converter', [\n    ('types', Sequence[Type]),\n    ('type_names', Sequence[str]),\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "kubeflow/pipelines",
    "commit": "a0b18eb9e8da25c7b81b0b75cf0f39297c809d20",
    "filename": "sdk/python/kfp/components/_data_passing.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/kubeflow-pipelines/sdk/python/kfp/components/_data_passing.py",
    "file_hunks_size": 5,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "sdk/python/kfp/components/_data_passing.py:122:8 Incompatible parameter type [6]: Expected `Sequence[str]` for 1st positional only parameter to call `Converter.__init__` but got `Sequence[typing.Type[list]]`.",
    "message": " Expected `Sequence[str]` for 1st positional only parameter to call `Converter.__init__` but got `Sequence[typing.Type[list]]`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 122,
    "warning_line": "        [list], ['JsonArray', 'List', 'list'], _serialize_json, 'json.loads',",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "import inspect\nfrom typing import Any, Callable, NamedTuple, Sequence\nimport warnings\n",
        "source_code_len": 86,
        "target_code": "import inspect\nfrom typing import Any, Callable, NamedTuple, Optional, Sequence, Type\nimport warnings\n",
        "target_code_len": 102,
        "diff_format": "@@ -23,3 +22,3 @@\n import inspect\n-from typing import Any, Callable, NamedTuple, Sequence\n+from typing import Any, Callable, NamedTuple, Optional, Sequence, Type\n import warnings\n",
        "source_code_with_indent": "import inspect\nfrom typing import Any, Callable, NamedTuple, Sequence\nimport warnings\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "import inspect\nfrom typing import Any, Callable, NamedTuple, Optional, Sequence, Type\nimport warnings\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "Converter = NamedTuple('Converter', [\n    ('types', Sequence[str]),\n    ('type_names', Sequence[str]),\n",
        "source_code_len": 103,
        "target_code": "Converter = NamedTuple('Converter', [\n    ('types', Sequence[Type]),\n    ('type_names', Sequence[str]),\n",
        "target_code_len": 104,
        "diff_format": "@@ -29,3 +28,3 @@\n Converter = NamedTuple('Converter', [\n-    ('types', Sequence[str]),\n+    ('types', Sequence[Type]),\n     ('type_names', Sequence[str]),\n",
        "source_code_with_indent": "Converter = NamedTuple('Converter', [\n    ('types', Sequence[str]),\n    ('type_names', Sequence[str]),\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "Converter = NamedTuple('Converter', [\n    ('types', Sequence[Type]),\n    ('type_names', Sequence[str]),\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "kubeflow/pipelines",
    "commit": "a0b18eb9e8da25c7b81b0b75cf0f39297c809d20",
    "filename": "sdk/python/kfp/components/_data_passing.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/kubeflow-pipelines/sdk/python/kfp/components/_data_passing.py",
    "file_hunks_size": 5,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "sdk/python/kfp/components/_data_passing.py:126:8 Incompatible parameter type [6]: Expected `Sequence[str]` for 1st positional only parameter to call `Converter.__init__` but got `Sequence[typing.Type[dict]]`.",
    "message": " Expected `Sequence[str]` for 1st positional only parameter to call `Converter.__init__` but got `Sequence[typing.Type[dict]]`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 126,
    "warning_line": "        [dict], ['JsonObject', 'Dictionary', 'Dict', 'dict'], _serialize_json,",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "import inspect\nfrom typing import Any, Callable, NamedTuple, Sequence\nimport warnings\n",
        "source_code_len": 86,
        "target_code": "import inspect\nfrom typing import Any, Callable, NamedTuple, Optional, Sequence, Type\nimport warnings\n",
        "target_code_len": 102,
        "diff_format": "@@ -23,3 +22,3 @@\n import inspect\n-from typing import Any, Callable, NamedTuple, Sequence\n+from typing import Any, Callable, NamedTuple, Optional, Sequence, Type\n import warnings\n",
        "source_code_with_indent": "import inspect\nfrom typing import Any, Callable, NamedTuple, Sequence\nimport warnings\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "import inspect\nfrom typing import Any, Callable, NamedTuple, Optional, Sequence, Type\nimport warnings\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "Converter = NamedTuple('Converter', [\n    ('types', Sequence[str]),\n    ('type_names', Sequence[str]),\n",
        "source_code_len": 103,
        "target_code": "Converter = NamedTuple('Converter', [\n    ('types', Sequence[Type]),\n    ('type_names', Sequence[str]),\n",
        "target_code_len": 104,
        "diff_format": "@@ -29,3 +28,3 @@\n Converter = NamedTuple('Converter', [\n-    ('types', Sequence[str]),\n+    ('types', Sequence[Type]),\n     ('type_names', Sequence[str]),\n",
        "source_code_with_indent": "Converter = NamedTuple('Converter', [\n    ('types', Sequence[str]),\n    ('type_names', Sequence[str]),\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "Converter = NamedTuple('Converter', [\n    ('types', Sequence[Type]),\n    ('type_names', Sequence[str]),\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "kubeflow/pipelines",
    "commit": "a0b18eb9e8da25c7b81b0b75cf0f39297c809d20",
    "filename": "sdk/python/kfp/components/_data_passing.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/kubeflow-pipelines/sdk/python/kfp/components/_data_passing.py",
    "file_hunks_size": 5,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "sdk/python/kfp/components/_data_passing.py:169:8 Incompatible return type [7]: Expected `str` but got `None`.",
    "message": " Expected `str` but got `None`.",
    "rule_id": "Incompatible return type [7]",
    "warning_line_no": 169,
    "warning_line": "        return None",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "import inspect\nfrom typing import Any, Callable, NamedTuple, Sequence\nimport warnings\n",
        "source_code_len": 86,
        "target_code": "import inspect\nfrom typing import Any, Callable, NamedTuple, Optional, Sequence, Type\nimport warnings\n",
        "target_code_len": 102,
        "diff_format": "@@ -23,3 +22,3 @@\n import inspect\n-from typing import Any, Callable, NamedTuple, Sequence\n+from typing import Any, Callable, NamedTuple, Optional, Sequence, Type\n import warnings\n",
        "source_code_with_indent": "import inspect\nfrom typing import Any, Callable, NamedTuple, Sequence\nimport warnings\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "import inspect\nfrom typing import Any, Callable, NamedTuple, Optional, Sequence, Type\nimport warnings\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "Converter = NamedTuple('Converter', [\n    ('types', Sequence[str]),\n    ('type_names', Sequence[str]),\n",
        "source_code_len": 103,
        "target_code": "Converter = NamedTuple('Converter', [\n    ('types', Sequence[Type]),\n    ('type_names', Sequence[str]),\n",
        "target_code_len": 104,
        "diff_format": "@@ -29,3 +28,3 @@\n Converter = NamedTuple('Converter', [\n-    ('types', Sequence[str]),\n+    ('types', Sequence[Type]),\n     ('type_names', Sequence[str]),\n",
        "source_code_with_indent": "Converter = NamedTuple('Converter', [\n    ('types', Sequence[str]),\n    ('type_names', Sequence[str]),\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "Converter = NamedTuple('Converter', [\n    ('types', Sequence[Type]),\n    ('type_names', Sequence[str]),\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\ndef get_canonical_type_for_type_struct(type_struct) -> str:\n    try:\n        return type_name_to_type.get(type_struct, None)\n    except:\n        return None\n\n\ndef get_deserializer_code_for_type(typ) -> str:\n    try:\n        return type_name_to_deserializer.get(\n            get_canonical_type_struct_for_type[typ], None)\n    except:\n        return None\n\n\ndef get_deserializer_code_for_type_struct(type_struct) -> str:\n    try:\n        return type_name_to_deserializer.get(type_struct, None)\n    except:\n        return None\n\n\ndef get_serializer_func_for_type_struct(type_struct) -> str:\n    try:\n        return type_name_to_serializer.get(type_struct, None)\n    except:\n",
        "source_code_len": 670,
        "target_code": "\ndef get_canonical_type_for_type_name(type_name: str) -> Optional[Type]:\n    \"\"\"Find the canonical type for a given type name.\n\n    Args:\n        type_name: The type name to search for.\n\n    Returns:\n        The canonical type found.\n    \"\"\"\n    try:\n        return type_name_to_type.get(type_name, None)\n    except:\n        return None\n\n\ndef get_deserializer_code_for_type_name(type_name: str) -> Optional[str]:\n    \"\"\"Find the deserializer code for the given type name.\n\n    Args:\n        type_name: The type name to search for.\n\n    Returns:\n        The deserializer code needed to deserialize the type.\n    \"\"\"\n    try:\n        return type_name_to_deserializer.get(\n            type_annotation_utils.get_short_type_name(type_name), None)\n    except:\n        return None\n\n\ndef get_serializer_func_for_type_name(type_name: str) -> Optional[Callable]:\n    \"\"\"Find the serializer code for the given type name.\n\n    Args:\n        type_name: The type name to search for.\n\n    Returns:\n        The serializer func needed to serialize the type.\n    \"\"\"\n    try:\n        return type_name_to_serializer.get(\n            type_annotation_utils.get_short_type_name(type_name), None)\n    except:\n",
        "target_code_len": 1186,
        "diff_format": "@@ -164,27 +171,45 @@\n \n-def get_canonical_type_for_type_struct(type_struct) -> str:\n-    try:\n-        return type_name_to_type.get(type_struct, None)\n-    except:\n-        return None\n-\n-\n-def get_deserializer_code_for_type(typ) -> str:\n+def get_canonical_type_for_type_name(type_name: str) -> Optional[Type]:\n+    \"\"\"Find the canonical type for a given type name.\n+\n+    Args:\n+        type_name: The type name to search for.\n+\n+    Returns:\n+        The canonical type found.\n+    \"\"\"\n+    try:\n+        return type_name_to_type.get(type_name, None)\n+    except:\n+        return None\n+\n+\n+def get_deserializer_code_for_type_name(type_name: str) -> Optional[str]:\n+    \"\"\"Find the deserializer code for the given type name.\n+\n+    Args:\n+        type_name: The type name to search for.\n+\n+    Returns:\n+        The deserializer code needed to deserialize the type.\n+    \"\"\"\n     try:\n         return type_name_to_deserializer.get(\n-            get_canonical_type_struct_for_type[typ], None)\n-    except:\n-        return None\n-\n-\n-def get_deserializer_code_for_type_struct(type_struct) -> str:\n-    try:\n-        return type_name_to_deserializer.get(type_struct, None)\n-    except:\n-        return None\n-\n-\n-def get_serializer_func_for_type_struct(type_struct) -> str:\n-    try:\n-        return type_name_to_serializer.get(type_struct, None)\n+            type_annotation_utils.get_short_type_name(type_name), None)\n+    except:\n+        return None\n+\n+\n+def get_serializer_func_for_type_name(type_name: str) -> Optional[Callable]:\n+    \"\"\"Find the serializer code for the given type name.\n+\n+    Args:\n+        type_name: The type name to search for.\n+\n+    Returns:\n+        The serializer func needed to serialize the type.\n+    \"\"\"\n+    try:\n+        return type_name_to_serializer.get(\n+            type_annotation_utils.get_short_type_name(type_name), None)\n     except:\n",
        "source_code_with_indent": "\n<DED><DED>def get_canonical_type_for_type_struct(type_struct) -> str:\n    <IND>try:\n        <IND>return type_name_to_type.get(type_struct, None)\n    <DED>except:\n        <IND>return None\n\n\n<DED><DED>def get_deserializer_code_for_type(typ) -> str:\n    <IND>try:\n        <IND>return type_name_to_deserializer.get(\n            get_canonical_type_struct_for_type[typ], None)\n    <DED>except:\n        <IND>return None\n\n\n<DED><DED>def get_deserializer_code_for_type_struct(type_struct) -> str:\n    <IND>try:\n        <IND>return type_name_to_deserializer.get(type_struct, None)\n    <DED>except:\n        <IND>return None\n\n\n<DED><DED>def get_serializer_func_for_type_struct(type_struct) -> str:\n    <IND>try:\n        <IND>return type_name_to_serializer.get(type_struct, None)\n    <DED>except:\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n<DED><DED>def get_canonical_type_for_type_name(type_name: str) -> Optional[Type]:\n    <IND>\"\"\"Find the canonical type for a given type name.\n\n    Args:\n        type_name: The type name to search for.\n\n    Returns:\n        The canonical type found.\n    \"\"\"\n    try:\n        <IND>return type_name_to_type.get(type_name, None)\n    <DED>except:\n        <IND>return None\n\n\n<DED><DED>def get_deserializer_code_for_type_name(type_name: str) -> Optional[str]:\n    <IND>\"\"\"Find the deserializer code for the given type name.\n\n    Args:\n        type_name: The type name to search for.\n\n    Returns:\n        The deserializer code needed to deserialize the type.\n    \"\"\"\n    try:\n        <IND>return type_name_to_deserializer.get(\n            type_annotation_utils.get_short_type_name(type_name), None)\n    <DED>except:\n        <IND>return None\n\n\n<DED><DED>def get_serializer_func_for_type_name(type_name: str) -> Optional[Callable]:\n    <IND>\"\"\"Find the serializer code for the given type name.\n\n    Args:\n        type_name: The type name to search for.\n\n    Returns:\n        The serializer func needed to serialize the type.\n    \"\"\"\n    try:\n        <IND>return type_name_to_serializer.get(\n            type_annotation_utils.get_short_type_name(type_name), None)\n    <DED>except:\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "kubeflow/pipelines",
    "commit": "a0b18eb9e8da25c7b81b0b75cf0f39297c809d20",
    "filename": "sdk/python/kfp/components/_data_passing.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/kubeflow-pipelines/sdk/python/kfp/components/_data_passing.py",
    "file_hunks_size": 5,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "sdk/python/kfp/components/_data_passing.py:177:8 Incompatible return type [7]: Expected `str` but got `None`.",
    "message": " Expected `str` but got `None`.",
    "rule_id": "Incompatible return type [7]",
    "warning_line_no": 177,
    "warning_line": "        return None",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "import inspect\nfrom typing import Any, Callable, NamedTuple, Sequence\nimport warnings\n",
        "source_code_len": 86,
        "target_code": "import inspect\nfrom typing import Any, Callable, NamedTuple, Optional, Sequence, Type\nimport warnings\n",
        "target_code_len": 102,
        "diff_format": "@@ -23,3 +22,3 @@\n import inspect\n-from typing import Any, Callable, NamedTuple, Sequence\n+from typing import Any, Callable, NamedTuple, Optional, Sequence, Type\n import warnings\n",
        "source_code_with_indent": "import inspect\nfrom typing import Any, Callable, NamedTuple, Sequence\nimport warnings\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "import inspect\nfrom typing import Any, Callable, NamedTuple, Optional, Sequence, Type\nimport warnings\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "Converter = NamedTuple('Converter', [\n    ('types', Sequence[str]),\n    ('type_names', Sequence[str]),\n",
        "source_code_len": 103,
        "target_code": "Converter = NamedTuple('Converter', [\n    ('types', Sequence[Type]),\n    ('type_names', Sequence[str]),\n",
        "target_code_len": 104,
        "diff_format": "@@ -29,3 +28,3 @@\n Converter = NamedTuple('Converter', [\n-    ('types', Sequence[str]),\n+    ('types', Sequence[Type]),\n     ('type_names', Sequence[str]),\n",
        "source_code_with_indent": "Converter = NamedTuple('Converter', [\n    ('types', Sequence[str]),\n    ('type_names', Sequence[str]),\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "Converter = NamedTuple('Converter', [\n    ('types', Sequence[Type]),\n    ('type_names', Sequence[str]),\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\ndef get_canonical_type_for_type_struct(type_struct) -> str:\n    try:\n        return type_name_to_type.get(type_struct, None)\n    except:\n        return None\n\n\ndef get_deserializer_code_for_type(typ) -> str:\n    try:\n        return type_name_to_deserializer.get(\n            get_canonical_type_struct_for_type[typ], None)\n    except:\n        return None\n\n\ndef get_deserializer_code_for_type_struct(type_struct) -> str:\n    try:\n        return type_name_to_deserializer.get(type_struct, None)\n    except:\n        return None\n\n\ndef get_serializer_func_for_type_struct(type_struct) -> str:\n    try:\n        return type_name_to_serializer.get(type_struct, None)\n    except:\n",
        "source_code_len": 670,
        "target_code": "\ndef get_canonical_type_for_type_name(type_name: str) -> Optional[Type]:\n    \"\"\"Find the canonical type for a given type name.\n\n    Args:\n        type_name: The type name to search for.\n\n    Returns:\n        The canonical type found.\n    \"\"\"\n    try:\n        return type_name_to_type.get(type_name, None)\n    except:\n        return None\n\n\ndef get_deserializer_code_for_type_name(type_name: str) -> Optional[str]:\n    \"\"\"Find the deserializer code for the given type name.\n\n    Args:\n        type_name: The type name to search for.\n\n    Returns:\n        The deserializer code needed to deserialize the type.\n    \"\"\"\n    try:\n        return type_name_to_deserializer.get(\n            type_annotation_utils.get_short_type_name(type_name), None)\n    except:\n        return None\n\n\ndef get_serializer_func_for_type_name(type_name: str) -> Optional[Callable]:\n    \"\"\"Find the serializer code for the given type name.\n\n    Args:\n        type_name: The type name to search for.\n\n    Returns:\n        The serializer func needed to serialize the type.\n    \"\"\"\n    try:\n        return type_name_to_serializer.get(\n            type_annotation_utils.get_short_type_name(type_name), None)\n    except:\n",
        "target_code_len": 1186,
        "diff_format": "@@ -164,27 +171,45 @@\n \n-def get_canonical_type_for_type_struct(type_struct) -> str:\n-    try:\n-        return type_name_to_type.get(type_struct, None)\n-    except:\n-        return None\n-\n-\n-def get_deserializer_code_for_type(typ) -> str:\n+def get_canonical_type_for_type_name(type_name: str) -> Optional[Type]:\n+    \"\"\"Find the canonical type for a given type name.\n+\n+    Args:\n+        type_name: The type name to search for.\n+\n+    Returns:\n+        The canonical type found.\n+    \"\"\"\n+    try:\n+        return type_name_to_type.get(type_name, None)\n+    except:\n+        return None\n+\n+\n+def get_deserializer_code_for_type_name(type_name: str) -> Optional[str]:\n+    \"\"\"Find the deserializer code for the given type name.\n+\n+    Args:\n+        type_name: The type name to search for.\n+\n+    Returns:\n+        The deserializer code needed to deserialize the type.\n+    \"\"\"\n     try:\n         return type_name_to_deserializer.get(\n-            get_canonical_type_struct_for_type[typ], None)\n-    except:\n-        return None\n-\n-\n-def get_deserializer_code_for_type_struct(type_struct) -> str:\n-    try:\n-        return type_name_to_deserializer.get(type_struct, None)\n-    except:\n-        return None\n-\n-\n-def get_serializer_func_for_type_struct(type_struct) -> str:\n-    try:\n-        return type_name_to_serializer.get(type_struct, None)\n+            type_annotation_utils.get_short_type_name(type_name), None)\n+    except:\n+        return None\n+\n+\n+def get_serializer_func_for_type_name(type_name: str) -> Optional[Callable]:\n+    \"\"\"Find the serializer code for the given type name.\n+\n+    Args:\n+        type_name: The type name to search for.\n+\n+    Returns:\n+        The serializer func needed to serialize the type.\n+    \"\"\"\n+    try:\n+        return type_name_to_serializer.get(\n+            type_annotation_utils.get_short_type_name(type_name), None)\n     except:\n",
        "source_code_with_indent": "\n<DED><DED>def get_canonical_type_for_type_struct(type_struct) -> str:\n    <IND>try:\n        <IND>return type_name_to_type.get(type_struct, None)\n    <DED>except:\n        <IND>return None\n\n\n<DED><DED>def get_deserializer_code_for_type(typ) -> str:\n    <IND>try:\n        <IND>return type_name_to_deserializer.get(\n            get_canonical_type_struct_for_type[typ], None)\n    <DED>except:\n        <IND>return None\n\n\n<DED><DED>def get_deserializer_code_for_type_struct(type_struct) -> str:\n    <IND>try:\n        <IND>return type_name_to_deserializer.get(type_struct, None)\n    <DED>except:\n        <IND>return None\n\n\n<DED><DED>def get_serializer_func_for_type_struct(type_struct) -> str:\n    <IND>try:\n        <IND>return type_name_to_serializer.get(type_struct, None)\n    <DED>except:\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n<DED><DED>def get_canonical_type_for_type_name(type_name: str) -> Optional[Type]:\n    <IND>\"\"\"Find the canonical type for a given type name.\n\n    Args:\n        type_name: The type name to search for.\n\n    Returns:\n        The canonical type found.\n    \"\"\"\n    try:\n        <IND>return type_name_to_type.get(type_name, None)\n    <DED>except:\n        <IND>return None\n\n\n<DED><DED>def get_deserializer_code_for_type_name(type_name: str) -> Optional[str]:\n    <IND>\"\"\"Find the deserializer code for the given type name.\n\n    Args:\n        type_name: The type name to search for.\n\n    Returns:\n        The deserializer code needed to deserialize the type.\n    \"\"\"\n    try:\n        <IND>return type_name_to_deserializer.get(\n            type_annotation_utils.get_short_type_name(type_name), None)\n    <DED>except:\n        <IND>return None\n\n\n<DED><DED>def get_serializer_func_for_type_name(type_name: str) -> Optional[Callable]:\n    <IND>\"\"\"Find the serializer code for the given type name.\n\n    Args:\n        type_name: The type name to search for.\n\n    Returns:\n        The serializer func needed to serialize the type.\n    \"\"\"\n    try:\n        <IND>return type_name_to_serializer.get(\n            type_annotation_utils.get_short_type_name(type_name), None)\n    <DED>except:\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "kubeflow/pipelines",
    "commit": "a0b18eb9e8da25c7b81b0b75cf0f39297c809d20",
    "filename": "sdk/python/kfp/components/_data_passing.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/kubeflow-pipelines/sdk/python/kfp/components/_data_passing.py",
    "file_hunks_size": 5,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "sdk/python/kfp/components/_data_passing.py:184:8 Incompatible return type [7]: Expected `str` but got `None`.",
    "message": " Expected `str` but got `None`.",
    "rule_id": "Incompatible return type [7]",
    "warning_line_no": 184,
    "warning_line": "        return None",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "import inspect\nfrom typing import Any, Callable, NamedTuple, Sequence\nimport warnings\n",
        "source_code_len": 86,
        "target_code": "import inspect\nfrom typing import Any, Callable, NamedTuple, Optional, Sequence, Type\nimport warnings\n",
        "target_code_len": 102,
        "diff_format": "@@ -23,3 +22,3 @@\n import inspect\n-from typing import Any, Callable, NamedTuple, Sequence\n+from typing import Any, Callable, NamedTuple, Optional, Sequence, Type\n import warnings\n",
        "source_code_with_indent": "import inspect\nfrom typing import Any, Callable, NamedTuple, Sequence\nimport warnings\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "import inspect\nfrom typing import Any, Callable, NamedTuple, Optional, Sequence, Type\nimport warnings\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "Converter = NamedTuple('Converter', [\n    ('types', Sequence[str]),\n    ('type_names', Sequence[str]),\n",
        "source_code_len": 103,
        "target_code": "Converter = NamedTuple('Converter', [\n    ('types', Sequence[Type]),\n    ('type_names', Sequence[str]),\n",
        "target_code_len": 104,
        "diff_format": "@@ -29,3 +28,3 @@\n Converter = NamedTuple('Converter', [\n-    ('types', Sequence[str]),\n+    ('types', Sequence[Type]),\n     ('type_names', Sequence[str]),\n",
        "source_code_with_indent": "Converter = NamedTuple('Converter', [\n    ('types', Sequence[str]),\n    ('type_names', Sequence[str]),\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "Converter = NamedTuple('Converter', [\n    ('types', Sequence[Type]),\n    ('type_names', Sequence[str]),\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\ndef get_canonical_type_for_type_struct(type_struct) -> str:\n    try:\n        return type_name_to_type.get(type_struct, None)\n    except:\n        return None\n\n\ndef get_deserializer_code_for_type(typ) -> str:\n    try:\n        return type_name_to_deserializer.get(\n            get_canonical_type_struct_for_type[typ], None)\n    except:\n        return None\n\n\ndef get_deserializer_code_for_type_struct(type_struct) -> str:\n    try:\n        return type_name_to_deserializer.get(type_struct, None)\n    except:\n        return None\n\n\ndef get_serializer_func_for_type_struct(type_struct) -> str:\n    try:\n        return type_name_to_serializer.get(type_struct, None)\n    except:\n",
        "source_code_len": 670,
        "target_code": "\ndef get_canonical_type_for_type_name(type_name: str) -> Optional[Type]:\n    \"\"\"Find the canonical type for a given type name.\n\n    Args:\n        type_name: The type name to search for.\n\n    Returns:\n        The canonical type found.\n    \"\"\"\n    try:\n        return type_name_to_type.get(type_name, None)\n    except:\n        return None\n\n\ndef get_deserializer_code_for_type_name(type_name: str) -> Optional[str]:\n    \"\"\"Find the deserializer code for the given type name.\n\n    Args:\n        type_name: The type name to search for.\n\n    Returns:\n        The deserializer code needed to deserialize the type.\n    \"\"\"\n    try:\n        return type_name_to_deserializer.get(\n            type_annotation_utils.get_short_type_name(type_name), None)\n    except:\n        return None\n\n\ndef get_serializer_func_for_type_name(type_name: str) -> Optional[Callable]:\n    \"\"\"Find the serializer code for the given type name.\n\n    Args:\n        type_name: The type name to search for.\n\n    Returns:\n        The serializer func needed to serialize the type.\n    \"\"\"\n    try:\n        return type_name_to_serializer.get(\n            type_annotation_utils.get_short_type_name(type_name), None)\n    except:\n",
        "target_code_len": 1186,
        "diff_format": "@@ -164,27 +171,45 @@\n \n-def get_canonical_type_for_type_struct(type_struct) -> str:\n-    try:\n-        return type_name_to_type.get(type_struct, None)\n-    except:\n-        return None\n-\n-\n-def get_deserializer_code_for_type(typ) -> str:\n+def get_canonical_type_for_type_name(type_name: str) -> Optional[Type]:\n+    \"\"\"Find the canonical type for a given type name.\n+\n+    Args:\n+        type_name: The type name to search for.\n+\n+    Returns:\n+        The canonical type found.\n+    \"\"\"\n+    try:\n+        return type_name_to_type.get(type_name, None)\n+    except:\n+        return None\n+\n+\n+def get_deserializer_code_for_type_name(type_name: str) -> Optional[str]:\n+    \"\"\"Find the deserializer code for the given type name.\n+\n+    Args:\n+        type_name: The type name to search for.\n+\n+    Returns:\n+        The deserializer code needed to deserialize the type.\n+    \"\"\"\n     try:\n         return type_name_to_deserializer.get(\n-            get_canonical_type_struct_for_type[typ], None)\n-    except:\n-        return None\n-\n-\n-def get_deserializer_code_for_type_struct(type_struct) -> str:\n-    try:\n-        return type_name_to_deserializer.get(type_struct, None)\n-    except:\n-        return None\n-\n-\n-def get_serializer_func_for_type_struct(type_struct) -> str:\n-    try:\n-        return type_name_to_serializer.get(type_struct, None)\n+            type_annotation_utils.get_short_type_name(type_name), None)\n+    except:\n+        return None\n+\n+\n+def get_serializer_func_for_type_name(type_name: str) -> Optional[Callable]:\n+    \"\"\"Find the serializer code for the given type name.\n+\n+    Args:\n+        type_name: The type name to search for.\n+\n+    Returns:\n+        The serializer func needed to serialize the type.\n+    \"\"\"\n+    try:\n+        return type_name_to_serializer.get(\n+            type_annotation_utils.get_short_type_name(type_name), None)\n     except:\n",
        "source_code_with_indent": "\n<DED><DED>def get_canonical_type_for_type_struct(type_struct) -> str:\n    <IND>try:\n        <IND>return type_name_to_type.get(type_struct, None)\n    <DED>except:\n        <IND>return None\n\n\n<DED><DED>def get_deserializer_code_for_type(typ) -> str:\n    <IND>try:\n        <IND>return type_name_to_deserializer.get(\n            get_canonical_type_struct_for_type[typ], None)\n    <DED>except:\n        <IND>return None\n\n\n<DED><DED>def get_deserializer_code_for_type_struct(type_struct) -> str:\n    <IND>try:\n        <IND>return type_name_to_deserializer.get(type_struct, None)\n    <DED>except:\n        <IND>return None\n\n\n<DED><DED>def get_serializer_func_for_type_struct(type_struct) -> str:\n    <IND>try:\n        <IND>return type_name_to_serializer.get(type_struct, None)\n    <DED>except:\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n<DED><DED>def get_canonical_type_for_type_name(type_name: str) -> Optional[Type]:\n    <IND>\"\"\"Find the canonical type for a given type name.\n\n    Args:\n        type_name: The type name to search for.\n\n    Returns:\n        The canonical type found.\n    \"\"\"\n    try:\n        <IND>return type_name_to_type.get(type_name, None)\n    <DED>except:\n        <IND>return None\n\n\n<DED><DED>def get_deserializer_code_for_type_name(type_name: str) -> Optional[str]:\n    <IND>\"\"\"Find the deserializer code for the given type name.\n\n    Args:\n        type_name: The type name to search for.\n\n    Returns:\n        The deserializer code needed to deserialize the type.\n    \"\"\"\n    try:\n        <IND>return type_name_to_deserializer.get(\n            type_annotation_utils.get_short_type_name(type_name), None)\n    <DED>except:\n        <IND>return None\n\n\n<DED><DED>def get_serializer_func_for_type_name(type_name: str) -> Optional[Callable]:\n    <IND>\"\"\"Find the serializer code for the given type name.\n\n    Args:\n        type_name: The type name to search for.\n\n    Returns:\n        The serializer func needed to serialize the type.\n    \"\"\"\n    try:\n        <IND>return type_name_to_serializer.get(\n            type_annotation_utils.get_short_type_name(type_name), None)\n    <DED>except:\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "kubeflow/pipelines",
    "commit": "a0b18eb9e8da25c7b81b0b75cf0f39297c809d20",
    "filename": "sdk/python/kfp/components/_data_passing.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/kubeflow-pipelines/sdk/python/kfp/components/_data_passing.py",
    "file_hunks_size": 5,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "sdk/python/kfp/components/_data_passing.py:191:8 Incompatible return type [7]: Expected `str` but got `None`.",
    "message": " Expected `str` but got `None`.",
    "rule_id": "Incompatible return type [7]",
    "warning_line_no": 191,
    "warning_line": "        return None",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "import inspect\nfrom typing import Any, Callable, NamedTuple, Sequence\nimport warnings\n",
        "source_code_len": 86,
        "target_code": "import inspect\nfrom typing import Any, Callable, NamedTuple, Optional, Sequence, Type\nimport warnings\n",
        "target_code_len": 102,
        "diff_format": "@@ -23,3 +22,3 @@\n import inspect\n-from typing import Any, Callable, NamedTuple, Sequence\n+from typing import Any, Callable, NamedTuple, Optional, Sequence, Type\n import warnings\n",
        "source_code_with_indent": "import inspect\nfrom typing import Any, Callable, NamedTuple, Sequence\nimport warnings\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "import inspect\nfrom typing import Any, Callable, NamedTuple, Optional, Sequence, Type\nimport warnings\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "Converter = NamedTuple('Converter', [\n    ('types', Sequence[str]),\n    ('type_names', Sequence[str]),\n",
        "source_code_len": 103,
        "target_code": "Converter = NamedTuple('Converter', [\n    ('types', Sequence[Type]),\n    ('type_names', Sequence[str]),\n",
        "target_code_len": 104,
        "diff_format": "@@ -29,3 +28,3 @@\n Converter = NamedTuple('Converter', [\n-    ('types', Sequence[str]),\n+    ('types', Sequence[Type]),\n     ('type_names', Sequence[str]),\n",
        "source_code_with_indent": "Converter = NamedTuple('Converter', [\n    ('types', Sequence[str]),\n    ('type_names', Sequence[str]),\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "Converter = NamedTuple('Converter', [\n    ('types', Sequence[Type]),\n    ('type_names', Sequence[str]),\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\ndef get_canonical_type_for_type_struct(type_struct) -> str:\n    try:\n        return type_name_to_type.get(type_struct, None)\n    except:\n        return None\n\n\ndef get_deserializer_code_for_type(typ) -> str:\n    try:\n        return type_name_to_deserializer.get(\n            get_canonical_type_struct_for_type[typ], None)\n    except:\n        return None\n\n\ndef get_deserializer_code_for_type_struct(type_struct) -> str:\n    try:\n        return type_name_to_deserializer.get(type_struct, None)\n    except:\n        return None\n\n\ndef get_serializer_func_for_type_struct(type_struct) -> str:\n    try:\n        return type_name_to_serializer.get(type_struct, None)\n    except:\n",
        "source_code_len": 670,
        "target_code": "\ndef get_canonical_type_for_type_name(type_name: str) -> Optional[Type]:\n    \"\"\"Find the canonical type for a given type name.\n\n    Args:\n        type_name: The type name to search for.\n\n    Returns:\n        The canonical type found.\n    \"\"\"\n    try:\n        return type_name_to_type.get(type_name, None)\n    except:\n        return None\n\n\ndef get_deserializer_code_for_type_name(type_name: str) -> Optional[str]:\n    \"\"\"Find the deserializer code for the given type name.\n\n    Args:\n        type_name: The type name to search for.\n\n    Returns:\n        The deserializer code needed to deserialize the type.\n    \"\"\"\n    try:\n        return type_name_to_deserializer.get(\n            type_annotation_utils.get_short_type_name(type_name), None)\n    except:\n        return None\n\n\ndef get_serializer_func_for_type_name(type_name: str) -> Optional[Callable]:\n    \"\"\"Find the serializer code for the given type name.\n\n    Args:\n        type_name: The type name to search for.\n\n    Returns:\n        The serializer func needed to serialize the type.\n    \"\"\"\n    try:\n        return type_name_to_serializer.get(\n            type_annotation_utils.get_short_type_name(type_name), None)\n    except:\n",
        "target_code_len": 1186,
        "diff_format": "@@ -164,27 +171,45 @@\n \n-def get_canonical_type_for_type_struct(type_struct) -> str:\n-    try:\n-        return type_name_to_type.get(type_struct, None)\n-    except:\n-        return None\n-\n-\n-def get_deserializer_code_for_type(typ) -> str:\n+def get_canonical_type_for_type_name(type_name: str) -> Optional[Type]:\n+    \"\"\"Find the canonical type for a given type name.\n+\n+    Args:\n+        type_name: The type name to search for.\n+\n+    Returns:\n+        The canonical type found.\n+    \"\"\"\n+    try:\n+        return type_name_to_type.get(type_name, None)\n+    except:\n+        return None\n+\n+\n+def get_deserializer_code_for_type_name(type_name: str) -> Optional[str]:\n+    \"\"\"Find the deserializer code for the given type name.\n+\n+    Args:\n+        type_name: The type name to search for.\n+\n+    Returns:\n+        The deserializer code needed to deserialize the type.\n+    \"\"\"\n     try:\n         return type_name_to_deserializer.get(\n-            get_canonical_type_struct_for_type[typ], None)\n-    except:\n-        return None\n-\n-\n-def get_deserializer_code_for_type_struct(type_struct) -> str:\n-    try:\n-        return type_name_to_deserializer.get(type_struct, None)\n-    except:\n-        return None\n-\n-\n-def get_serializer_func_for_type_struct(type_struct) -> str:\n-    try:\n-        return type_name_to_serializer.get(type_struct, None)\n+            type_annotation_utils.get_short_type_name(type_name), None)\n+    except:\n+        return None\n+\n+\n+def get_serializer_func_for_type_name(type_name: str) -> Optional[Callable]:\n+    \"\"\"Find the serializer code for the given type name.\n+\n+    Args:\n+        type_name: The type name to search for.\n+\n+    Returns:\n+        The serializer func needed to serialize the type.\n+    \"\"\"\n+    try:\n+        return type_name_to_serializer.get(\n+            type_annotation_utils.get_short_type_name(type_name), None)\n     except:\n",
        "source_code_with_indent": "\n<DED><DED>def get_canonical_type_for_type_struct(type_struct) -> str:\n    <IND>try:\n        <IND>return type_name_to_type.get(type_struct, None)\n    <DED>except:\n        <IND>return None\n\n\n<DED><DED>def get_deserializer_code_for_type(typ) -> str:\n    <IND>try:\n        <IND>return type_name_to_deserializer.get(\n            get_canonical_type_struct_for_type[typ], None)\n    <DED>except:\n        <IND>return None\n\n\n<DED><DED>def get_deserializer_code_for_type_struct(type_struct) -> str:\n    <IND>try:\n        <IND>return type_name_to_deserializer.get(type_struct, None)\n    <DED>except:\n        <IND>return None\n\n\n<DED><DED>def get_serializer_func_for_type_struct(type_struct) -> str:\n    <IND>try:\n        <IND>return type_name_to_serializer.get(type_struct, None)\n    <DED>except:\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n<DED><DED>def get_canonical_type_for_type_name(type_name: str) -> Optional[Type]:\n    <IND>\"\"\"Find the canonical type for a given type name.\n\n    Args:\n        type_name: The type name to search for.\n\n    Returns:\n        The canonical type found.\n    \"\"\"\n    try:\n        <IND>return type_name_to_type.get(type_name, None)\n    <DED>except:\n        <IND>return None\n\n\n<DED><DED>def get_deserializer_code_for_type_name(type_name: str) -> Optional[str]:\n    <IND>\"\"\"Find the deserializer code for the given type name.\n\n    Args:\n        type_name: The type name to search for.\n\n    Returns:\n        The deserializer code needed to deserialize the type.\n    \"\"\"\n    try:\n        <IND>return type_name_to_deserializer.get(\n            type_annotation_utils.get_short_type_name(type_name), None)\n    <DED>except:\n        <IND>return None\n\n\n<DED><DED>def get_serializer_func_for_type_name(type_name: str) -> Optional[Callable]:\n    <IND>\"\"\"Find the serializer code for the given type name.\n\n    Args:\n        type_name: The type name to search for.\n\n    Returns:\n        The serializer func needed to serialize the type.\n    \"\"\"\n    try:\n        <IND>return type_name_to_serializer.get(\n            type_annotation_utils.get_short_type_name(type_name), None)\n    <DED>except:\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  }
]