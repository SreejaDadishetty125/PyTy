[
  {
    "project": "vaaaaanquish/cloudia",
    "commit": "795b15cc64c7687cb2c221ee0e40e2121e4baf8a",
    "filename": "cloudia/word_data.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/vaaaaanquish-cloudia/cloudia/word_data.py",
    "file_hunks_size": 6,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "cloudia/word_data.py:15:42 Incompatible parameter type [6]: Expected `Counter[typing.Any]` for 1st positional only parameter to call `WordData.convert_weight` but got `List[str]`.",
    "message": " Expected `Counter[typing.Any]` for 1st positional only parameter to call `WordData.convert_weight` but got `List[str]`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 15,
    "warning_line": "        self.words = [self.convert_weight(x) for x in self.counter_list]",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "from typing import Any, List, Tuple, Dict\nfrom itertools import repeat, chain, zip_longest\n",
        "source_code_len": 91,
        "target_code": "from typing import Any, List, Tuple, Dict, Callable, Union\nfrom itertools import repeat, chain, zip_longest\n",
        "target_code_len": 108,
        "diff_format": "@@ -1,2 +1,2 @@\n-from typing import Any, List, Tuple, Dict\n+from typing import Any, List, Tuple, Dict, Callable, Union\n from itertools import repeat, chain, zip_longest\n",
        "source_code_with_indent": "from typing import Any, List, Tuple, Dict\nfrom itertools import repeat, chain, zip_longest\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "from typing import Any, List, Tuple, Dict, Callable, Union\nfrom itertools import repeat, chain, zip_longest\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n    def parse(self, words, parse_func: Any, multiprocess: bool, **args) -> List[List[str]]:\n        if isinstance(words[0], list):\n",
        "source_code_len": 132,
        "target_code": "\n    def parse(self, words, parse_func: Callable[..., List[str]], multiprocess: bool, **args) -> List[Counter]:\n        if isinstance(words[0], list):\n",
        "target_code_len": 151,
        "diff_format": "@@ -16,3 +16,3 @@\n \n-    def parse(self, words, parse_func: Any, multiprocess: bool, **args) -> List[List[str]]:\n+    def parse(self, words, parse_func: Callable[..., List[str]], multiprocess: bool, **args) -> List[Counter]:\n         if isinstance(words[0], list):\n",
        "source_code_with_indent": "\n    <DED>def parse(self, words, parse_func: Any, multiprocess: bool, **args) -> List[List[str]]:\n        <IND>if isinstance(words[0], list):\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n    <DED>def parse(self, words, parse_func: Callable[..., List[str]], multiprocess: bool, **args) -> List[Counter]:\n        <IND>if isinstance(words[0], list):\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "vaaaaanquish/cloudia",
    "commit": "795b15cc64c7687cb2c221ee0e40e2121e4baf8a",
    "filename": "cloudia/word_data.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/vaaaaanquish-cloudia/cloudia/word_data.py",
    "file_hunks_size": 6,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": true,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "cloudia/word_data.py:29:8 Incompatible variable type [9]: c is declared to have type `Counter[typing.Any]` but is used as type `List[Tuple[typing.Any, int]]`.",
    "message": " c is declared to have type `Counter[typing.Any]` but is used as type `List[Tuple[typing.Any, int]]`.",
    "rule_id": "Incompatible variable type [9]",
    "warning_line_no": 29,
    "warning_line": "        c = c.most_common()",
    "min_patch": [
      {
        "hunk_fit_TFix": true,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    def convert_weight(self, c: Counter) -> Dict[str, float]:\n        c = c.most_common()\n        _max_count = c[0][1]\n        weight = {k: v / _max_count for k, v in c}\n        weight = {k: weight[k] for k in list(weight.keys())}\n",
        "source_code_len": 231,
        "target_code": "    def convert_weight(self, c: Counter) -> Dict[str, float]:\n        most_common = c.most_common()\n        _max_count = most_common[0][1]\n        weight = {k: v / _max_count for k, v in most_common}\n        weight = {k: weight[k] for k in list(weight.keys())}\n",
        "target_code_len": 261,
        "diff_format": "@@ -28,5 +28,5 @@\n     def convert_weight(self, c: Counter) -> Dict[str, float]:\n-        c = c.most_common()\n-        _max_count = c[0][1]\n-        weight = {k: v / _max_count for k, v in c}\n+        most_common = c.most_common()\n+        _max_count = most_common[0][1]\n+        weight = {k: v / _max_count for k, v in most_common}\n         weight = {k: weight[k] for k in list(weight.keys())}\n",
        "source_code_with_indent": "    <DED>def convert_weight(self, c: Counter) -> Dict[str, float]:\n        <IND>c = c.most_common()\n        _max_count = c[0][1]\n        weight = {k: v / _max_count for k, v in c}\n        weight = {k: weight[k] for k in list(weight.keys())}\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    <DED>def convert_weight(self, c: Counter) -> Dict[str, float]:\n        <IND>most_common = c.most_common()\n        _max_count = most_common[0][1]\n        weight = {k: v / _max_count for k, v in most_common}\n        weight = {k: weight[k] for k in list(weight.keys())}\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "vaaaaanquish/cloudia",
    "commit": "795b15cc64c7687cb2c221ee0e40e2121e4baf8a",
    "filename": "cloudia/word_data.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/vaaaaanquish-cloudia/cloudia/word_data.py",
    "file_hunks_size": 6,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "cloudia/word_data.py:41:8 Incompatible return type [7]: Expected `List[str]` but got `List[Counter[Variable[collections._T]]]`.",
    "message": " Expected `List[str]` but got `List[Counter[Variable[collections._T]]]`.",
    "rule_id": "Incompatible return type [7]",
    "warning_line_no": 41,
    "warning_line": "        return [Counter(parse_func(x, **args)) for x in words]",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "from typing import Any, List, Tuple, Dict\nfrom itertools import repeat, chain, zip_longest\n",
        "source_code_len": 91,
        "target_code": "from typing import Any, List, Tuple, Dict, Callable, Union\nfrom itertools import repeat, chain, zip_longest\n",
        "target_code_len": 108,
        "diff_format": "@@ -1,2 +1,2 @@\n-from typing import Any, List, Tuple, Dict\n+from typing import Any, List, Tuple, Dict, Callable, Union\n from itertools import repeat, chain, zip_longest\n",
        "source_code_with_indent": "from typing import Any, List, Tuple, Dict\nfrom itertools import repeat, chain, zip_longest\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "from typing import Any, List, Tuple, Dict, Callable, Union\nfrom itertools import repeat, chain, zip_longest\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n    def _parse(self, words: List[str], parse_func: Any, multiprocess: bool, **args) -> List[str]:\n        if multiprocess:\n",
        "source_code_len": 124,
        "target_code": "\n    def _parse(self, words: List[str], parse_func: Callable[..., List[str]], multiprocess: bool, **args) -> Union[List[Counter], List[List[Counter]]]:\n        if multiprocess:\n",
        "target_code_len": 177,
        "diff_format": "@@ -34,3 +34,3 @@\n \n-    def _parse(self, words: List[str], parse_func: Any, multiprocess: bool, **args) -> List[str]:\n+    def _parse(self, words: List[str], parse_func: Callable[..., List[str]], multiprocess: bool, **args) -> Union[List[Counter], List[List[Counter]]]:\n         if multiprocess:\n",
        "source_code_with_indent": "\n    <DED>def _parse(self, words: List[str], parse_func: Any, multiprocess: bool, **args) -> List[str]:\n        <IND>if multiprocess:\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n    <DED>def _parse(self, words: List[str], parse_func: Callable[..., List[str]], multiprocess: bool, **args) -> Union[List[Counter], List[List[Counter]]]:\n        <IND>if multiprocess:\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n    def _single_thread_parse(self, words: List[str], parse_func: Any, **args) -> List[str]:\n        return [Counter(parse_func(x, **args)) for x in words]\n\n    def _parallel_parse(self, words: List[str], parse_func: Any, **args) -> List[str]:\n        words = Parallel(n_jobs=-1)([delayed(parse_func)(w, **dict(**a, **{'_index': i})) for i, (w, a) in enumerate(zip(words, repeat(args)))])\n        words.sort(key=lambda x: x[1])\n        words = [t[0] for t in words]\n        return words\n\n",
        "source_code_len": 488,
        "target_code": "\n    def _single_thread_parse(self, words: List[str], parse_func: Callable[..., List[str]], **args) -> List[Counter]:\n        return [Counter(parse_func(x, **args)) for x in words]\n\n    def _parallel_parse(self, words: List[str], parse_func: Callable, **args) -> List[List[Counter]]:\n        parsed_words = Parallel(n_jobs=-1)([delayed(parse_func)(w, **dict(**a, **{'_index': i})) for i, (w, a) in enumerate(zip(words, repeat(args)))])\n        parsed_words.sort(key=lambda x: x[1])\n        parsed_words = [t[0] for t in parsed_words]\n        return parsed_words\n\n",
        "target_code_len": 563,
        "diff_format": "@@ -39,10 +39,10 @@\n \n-    def _single_thread_parse(self, words: List[str], parse_func: Any, **args) -> List[str]:\n+    def _single_thread_parse(self, words: List[str], parse_func: Callable[..., List[str]], **args) -> List[Counter]:\n         return [Counter(parse_func(x, **args)) for x in words]\n \n-    def _parallel_parse(self, words: List[str], parse_func: Any, **args) -> List[str]:\n-        words = Parallel(n_jobs=-1)([delayed(parse_func)(w, **dict(**a, **{'_index': i})) for i, (w, a) in enumerate(zip(words, repeat(args)))])\n-        words.sort(key=lambda x: x[1])\n-        words = [t[0] for t in words]\n-        return words\n+    def _parallel_parse(self, words: List[str], parse_func: Callable, **args) -> List[List[Counter]]:\n+        parsed_words = Parallel(n_jobs=-1)([delayed(parse_func)(w, **dict(**a, **{'_index': i})) for i, (w, a) in enumerate(zip(words, repeat(args)))])\n+        parsed_words.sort(key=lambda x: x[1])\n+        parsed_words = [t[0] for t in parsed_words]\n+        return parsed_words\n \n",
        "source_code_with_indent": "\n    <DED>def _single_thread_parse(self, words: List[str], parse_func: Any, **args) -> List[str]:\n        <IND>return [Counter(parse_func(x, **args)) for x in words]\n\n    <DED>def _parallel_parse(self, words: List[str], parse_func: Any, **args) -> List[str]:\n        <IND>words = Parallel(n_jobs=-1)([delayed(parse_func)(w, **dict(**a, **{'_index': i})) for i, (w, a) in enumerate(zip(words, repeat(args)))])\n        words.sort(key=lambda x: x[1])\n        words = [t[0] for t in words]\n        return words\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n    <DED>def _single_thread_parse(self, words: List[str], parse_func: Callable[..., List[str]], **args) -> List[Counter]:\n        <IND>return [Counter(parse_func(x, **args)) for x in words]\n\n    <DED>def _parallel_parse(self, words: List[str], parse_func: Callable, **args) -> List[List[Counter]]:\n        <IND>parsed_words = Parallel(n_jobs=-1)([delayed(parse_func)(w, **dict(**a, **{'_index': i})) for i, (w, a) in enumerate(zip(words, repeat(args)))])\n        parsed_words.sort(key=lambda x: x[1])\n        parsed_words = [t[0] for t in parsed_words]\n        return parsed_words\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  }
]