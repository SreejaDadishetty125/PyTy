[
  {
    "project": "google/jax",
    "commit": "cc8fbb7669c1b863f8e067dbb56e07c9a39a9619",
    "filename": "jax/lax/lax.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/google-jax/jax/lax/lax.py",
    "file_hunks_size": 15,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "jax/lax/lax.py:1601:44 Incompatible parameter type [6]: Expected `Sequence[int]` for 2nd positional only parameter to call `slice` but got `int`.",
    "message": " Expected `Sequence[int]` for 2nd positional only parameter to call `slice` but got `int`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 1601,
    "warning_line": "    update = reshape(update, operand.shape[:ax] + (1,) + operand.shape[ax+1:])",
    "min_patch": [
      {
        "hunk_fit_TFix": true,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    assert _ndim(update) + 1 == _ndim(operand)\n    ax = axis % _ndim(operand)\n    update = reshape(update, operand.shape[:ax] + (1,) + operand.shape[ax+1:])\n  return dynamic_update_slice_in_dim(operand, update, index, axis)\n",
        "source_code_len": 224,
        "target_code": "    assert _ndim(update) + 1 == _ndim(operand)\n    update = expand_dims(update, (axis,))\n  return dynamic_update_slice_in_dim(operand, update, index, axis)\n",
        "target_code_len": 156,
        "diff_format": "@@ -1599,4 +1604,3 @@\n     assert _ndim(update) + 1 == _ndim(operand)\n-    ax = axis % _ndim(operand)\n-    update = reshape(update, operand.shape[:ax] + (1,) + operand.shape[ax+1:])\n+    update = expand_dims(update, (axis,))\n   return dynamic_update_slice_in_dim(operand, update, index, axis)\n",
        "source_code_with_indent": "    <IND>assert _ndim(update) + 1 == _ndim(operand)\n    ax = axis % _ndim(operand)\n    update = reshape(update, operand.shape[:ax] + (1,) + operand.shape[ax+1:])\n  <DED>return dynamic_update_slice_in_dim(operand, update, index, axis)\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    <IND>assert _ndim(update) + 1 == _ndim(operand)\n    update = expand_dims(update, (axis,))\n  <DED>return dynamic_update_slice_in_dim(operand, update, index, axis)\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n# We have a nonstandard reshape impl so that we can be lazy about data movement.\n",
        "source_code_len": 82,
        "target_code": "\n# The squeeze primitive exists for the benefit of masking and other\n# transformations that need to keep track of axis identity.\n# For example, consider reshaping a 2D array with shape (1, N) into a 1D array\n# with shape (N,). This results in the following JAXpr:\n#   reshape[ dimension=None new_sizes=(N,) ]\n# For N > 1, we can match up the output array axis with the second axis of the\n# input. But for N = 1, it is not clear how axes match up: all we know from the\n# JAXpr is that we are reshaping from (1, 1) to (1,).\n# In constrast, squeeze[ dimensions=(0,) ] is unambiguous.\n\ndef squeeze(array: Array, dimensions: Tuple[int, ...]) -> Array:\n  \"\"\"Squeeze any number of size 1 dimensions from an array.\"\"\"\n  ndim = onp.ndim(array)\n  dimensions = tuple(sorted(_canonicalize_axis(i, ndim) for i in dimensions))\n  if not dimensions:\n    return array\n  return squeeze_p.bind(array, dimensions=dimensions)\n\ndef _squeeze_dtype_rule(operand, *, dimensions):\n  return operand.dtype\n\ndef _squeeze_shape_rule(operand, *, dimensions):\n  return _compute_squeeze_shape(onp.shape(operand), dimensions)\n\ndef _compute_squeeze_shape(shape, dimensions):\n  dims_set = set(dimensions)\n  if len(dims_set) != len(dimensions):\n    raise ValueError(f\"dimensions are not unique: {dimensions}\")\n  if not all(0 <= d < len(shape) for d in dims_set):\n    raise ValueError(f\"dimensions outside range [0, ndim): {dimensions}\")\n  if any(shape[d] != 1 for d in dimensions):\n    raise ValueError(\n        \"cannot select an axis to squeeze out which has size not equal to \"\n        f\"one, got shape={shape} and dimensions={dimensions}\")\n  return tuple(s for i, s in enumerate(shape) if i not in dims_set)\n\ndef _squeeze_translation_rule(c, arg, *, dimensions):\n  new_shape = _compute_squeeze_shape(c.get_shape(arg).dimensions(), dimensions)\n  return xops.Reshape(arg, new_shape)\n\ndef _squeeze_transpose_rule(t, operand, *, dimensions):\n  assert ad.is_undefined_primal(operand)\n  return [expand_dims(t, dimensions)]\n\ndef _squeeze_batch_rule(batched_args, batch_dims, *, dimensions):\n  operand, = batched_args\n  bdim, = batch_dims\n  operand = batching.moveaxis(operand, bdim, 0)\n  dimensions = tuple(onp.add(1, dimensions))\n  return squeeze(operand, dimensions=dimensions), 0\n\nsqueeze_p = standard_primitive(_squeeze_shape_rule, _squeeze_dtype_rule,\n                               'squeeze', _squeeze_translation_rule)\nad.deflinear2(squeeze_p, _squeeze_transpose_rule)\nbatching.primitive_batchers[squeeze_p] = _squeeze_batch_rule\n\n\ndef expand_dims(array: Array, dimensions: Tuple[int, ...]) -> Array:\n  \"\"\"Insert any number of size 1 dimensions into an array.\"\"\"\n  ndim_out = onp.ndim(array) + len(dimensions)\n  dims_set = frozenset(_canonicalize_axis(i, ndim_out) for i in dimensions)\n  result_shape = list(onp.shape(array))\n  for i in sorted(dims_set):\n    result_shape.insert(i, 1)\n  broadcast_dims = [i for i in range(ndim_out) if i not in dims_set]\n  return broadcast_in_dim(array, result_shape, broadcast_dims)\n\n\n# We have a nonstandard reshape impl so that we can be lazy about data movement.\n",
        "target_code_len": 3066,
        "diff_format": "@@ -2928,2 +2932,70 @@\n \n+# The squeeze primitive exists for the benefit of masking and other\n+# transformations that need to keep track of axis identity.\n+# For example, consider reshaping a 2D array with shape (1, N) into a 1D array\n+# with shape (N,). This results in the following JAXpr:\n+#   reshape[ dimension=None new_sizes=(N,) ]\n+# For N > 1, we can match up the output array axis with the second axis of the\n+# input. But for N = 1, it is not clear how axes match up: all we know from the\n+# JAXpr is that we are reshaping from (1, 1) to (1,).\n+# In constrast, squeeze[ dimensions=(0,) ] is unambiguous.\n+\n+def squeeze(array: Array, dimensions: Tuple[int, ...]) -> Array:\n+  \"\"\"Squeeze any number of size 1 dimensions from an array.\"\"\"\n+  ndim = onp.ndim(array)\n+  dimensions = tuple(sorted(_canonicalize_axis(i, ndim) for i in dimensions))\n+  if not dimensions:\n+    return array\n+  return squeeze_p.bind(array, dimensions=dimensions)\n+\n+def _squeeze_dtype_rule(operand, *, dimensions):\n+  return operand.dtype\n+\n+def _squeeze_shape_rule(operand, *, dimensions):\n+  return _compute_squeeze_shape(onp.shape(operand), dimensions)\n+\n+def _compute_squeeze_shape(shape, dimensions):\n+  dims_set = set(dimensions)\n+  if len(dims_set) != len(dimensions):\n+    raise ValueError(f\"dimensions are not unique: {dimensions}\")\n+  if not all(0 <= d < len(shape) for d in dims_set):\n+    raise ValueError(f\"dimensions outside range [0, ndim): {dimensions}\")\n+  if any(shape[d] != 1 for d in dimensions):\n+    raise ValueError(\n+        \"cannot select an axis to squeeze out which has size not equal to \"\n+        f\"one, got shape={shape} and dimensions={dimensions}\")\n+  return tuple(s for i, s in enumerate(shape) if i not in dims_set)\n+\n+def _squeeze_translation_rule(c, arg, *, dimensions):\n+  new_shape = _compute_squeeze_shape(c.get_shape(arg).dimensions(), dimensions)\n+  return xops.Reshape(arg, new_shape)\n+\n+def _squeeze_transpose_rule(t, operand, *, dimensions):\n+  assert ad.is_undefined_primal(operand)\n+  return [expand_dims(t, dimensions)]\n+\n+def _squeeze_batch_rule(batched_args, batch_dims, *, dimensions):\n+  operand, = batched_args\n+  bdim, = batch_dims\n+  operand = batching.moveaxis(operand, bdim, 0)\n+  dimensions = tuple(onp.add(1, dimensions))\n+  return squeeze(operand, dimensions=dimensions), 0\n+\n+squeeze_p = standard_primitive(_squeeze_shape_rule, _squeeze_dtype_rule,\n+                               'squeeze', _squeeze_translation_rule)\n+ad.deflinear2(squeeze_p, _squeeze_transpose_rule)\n+batching.primitive_batchers[squeeze_p] = _squeeze_batch_rule\n+\n+\n+def expand_dims(array: Array, dimensions: Tuple[int, ...]) -> Array:\n+  \"\"\"Insert any number of size 1 dimensions into an array.\"\"\"\n+  ndim_out = onp.ndim(array) + len(dimensions)\n+  dims_set = frozenset(_canonicalize_axis(i, ndim_out) for i in dimensions)\n+  result_shape = list(onp.shape(array))\n+  for i in sorted(dims_set):\n+    result_shape.insert(i, 1)\n+  broadcast_dims = [i for i in range(ndim_out) if i not in dims_set]\n+  return broadcast_in_dim(array, result_shape, broadcast_dims)\n+\n+\n # We have a nonstandard reshape impl so that we can be lazy about data movement.\n",
        "source_code_with_indent": "\n# We have a nonstandard reshape impl so that we can be lazy about data movement.\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n# The squeeze primitive exists for the benefit of masking and other\n# transformations that need to keep track of axis identity.\n# For example, consider reshaping a 2D array with shape (1, N) into a 1D array\n# with shape (N,). This results in the following JAXpr:\n#   reshape[ dimension=None new_sizes=(N,) ]\n# For N > 1, we can match up the output array axis with the second axis of the\n# input. But for N = 1, it is not clear how axes match up: all we know from the\n# JAXpr is that we are reshaping from (1, 1) to (1,).\n# In constrast, squeeze[ dimensions=(0,) ] is unambiguous.\n\ndef squeeze(array: Array, dimensions: Tuple[int, ...]) -> Array:\n  <IND>\"\"\"Squeeze any number of size 1 dimensions from an array.\"\"\"\n  ndim = onp.ndim(array)\n  dimensions = tuple(sorted(_canonicalize_axis(i, ndim) for i in dimensions))\n  if not dimensions:\n    <IND>return array\n  <DED>return squeeze_p.bind(array, dimensions=dimensions)\n\n<DED>def _squeeze_dtype_rule(operand, *, dimensions):\n  <IND>return operand.dtype\n\n<DED>def _squeeze_shape_rule(operand, *, dimensions):\n  <IND>return _compute_squeeze_shape(onp.shape(operand), dimensions)\n\n<DED>def _compute_squeeze_shape(shape, dimensions):\n  <IND>dims_set = set(dimensions)\n  if len(dims_set) != len(dimensions):\n    <IND>raise ValueError(f\"dimensions are not unique: {dimensions}\")\n  <DED>if not all(0 <= d < len(shape) for d in dims_set):\n    <IND>raise ValueError(f\"dimensions outside range [0, ndim): {dimensions}\")\n  <DED>if any(shape[d] != 1 for d in dimensions):\n    <IND>raise ValueError(\n        \"cannot select an axis to squeeze out which has size not equal to \"\n        f\"one, got shape={shape} and dimensions={dimensions}\")\n  <DED>return tuple(s for i, s in enumerate(shape) if i not in dims_set)\n\n<DED>def _squeeze_translation_rule(c, arg, *, dimensions):\n  <IND>new_shape = _compute_squeeze_shape(c.get_shape(arg).dimensions(), dimensions)\n  return xops.Reshape(arg, new_shape)\n\n<DED>def _squeeze_transpose_rule(t, operand, *, dimensions):\n  <IND>assert ad.is_undefined_primal(operand)\n  return [expand_dims(t, dimensions)]\n\n<DED>def _squeeze_batch_rule(batched_args, batch_dims, *, dimensions):\n  <IND>operand, = batched_args\n  bdim, = batch_dims\n  operand = batching.moveaxis(operand, bdim, 0)\n  dimensions = tuple(onp.add(1, dimensions))\n  return squeeze(operand, dimensions=dimensions), 0\n\n<DED>squeeze_p = standard_primitive(_squeeze_shape_rule, _squeeze_dtype_rule,\n                               'squeeze', _squeeze_translation_rule)\nad.deflinear2(squeeze_p, _squeeze_transpose_rule)\nbatching.primitive_batchers[squeeze_p] = _squeeze_batch_rule\n\n\ndef expand_dims(array: Array, dimensions: Tuple[int, ...]) -> Array:\n  <IND>\"\"\"Insert any number of size 1 dimensions into an array.\"\"\"\n  ndim_out = onp.ndim(array) + len(dimensions)\n  dims_set = frozenset(_canonicalize_axis(i, ndim_out) for i in dimensions)\n  result_shape = list(onp.shape(array))\n  for i in sorted(dims_set):\n    <IND>result_shape.insert(i, 1)\n  <DED>broadcast_dims = [i for i in range(ndim_out) if i not in dims_set]\n  return broadcast_in_dim(array, result_shape, broadcast_dims)\n\n\n# We have a nonstandard reshape impl so that we can be lazy about data movement.\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "google/jax",
    "commit": "cc8fbb7669c1b863f8e067dbb56e07c9a39a9619",
    "filename": "jax/lax/lax.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/google-jax/jax/lax/lax.py",
    "file_hunks_size": 15,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "jax/lax/lax.py:2336:64 Incompatible parameter type [6]: Expected `Sequence[int]` for 3rd positional only parameter to call `slice` but got `None`.",
    "message": " Expected `Sequence[int]` for 3rd positional only parameter to call `slice` but got `None`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 2336,
    "warning_line": "_conv_spec_transpose = lambda spec: (spec[1], spec[0]) + spec[2:]"
  },
  {
    "project": "google/jax",
    "commit": "cc8fbb7669c1b863f8e067dbb56e07c9a39a9619",
    "filename": "jax/lax/lax.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/google-jax/jax/lax/lax.py",
    "file_hunks_size": 15,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "jax/lax/lax.py:2337:34 Incompatible parameter type [6]: Expected `Sequence[int]` for 2nd positional only parameter to call `slice` but got `None`.",
    "message": " Expected `Sequence[int]` for 2nd positional only parameter to call `slice` but got `None`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 2337,
    "warning_line": "_conv_sdims = lambda spec: spec[2:]"
  },
  {
    "project": "google/jax",
    "commit": "cc8fbb7669c1b863f8e067dbb56e07c9a39a9619",
    "filename": "jax/lax/lax.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/google-jax/jax/lax/lax.py",
    "file_hunks_size": 15,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "jax/lax/lax.py:2337:34 Incompatible parameter type [6]: Expected `Sequence[int]` for 3rd positional only parameter to call `slice` but got `None`.",
    "message": " Expected `Sequence[int]` for 3rd positional only parameter to call `slice` but got `None`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 2337,
    "warning_line": "_conv_sdims = lambda spec: spec[2:]"
  }
]