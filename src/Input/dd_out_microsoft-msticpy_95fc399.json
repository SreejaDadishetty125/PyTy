[
  {
    "project": "microsoft/msticpy",
    "commit": "95fc39978f2cda28ce4597d023b6119968d8be85",
    "filename": "msticpy/data/query_store.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/microsoft-msticpy/msticpy/data/query_store.py",
    "file_hunks_size": 6,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "msticpy/data/query_store.py:206:34 Incompatible parameter type [6]: Expected `str` for 1st positional only parameter to call `dict.__getitem__` but got `Union[DataFamily, str]`.",
    "message": " Expected `str` for 1st positional only parameter to call `dict.__getitem__` but got `Union[DataFamily, str]`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 206,
    "warning_line": "        return self.data_families[data_family][query_name]",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "from os import path\nfrom typing import Any, Dict, Iterable, Set, Union\n\n",
        "source_code_len": 72,
        "target_code": "from os import path\nfrom typing import Any, Dict, Iterable, Set, Union, Optional\n\n",
        "target_code_len": 82,
        "diff_format": "@@ -8,3 +8,3 @@\n from os import path\n-from typing import Any, Dict, Iterable, Set, Union\n+from typing import Any, Dict, Iterable, Set, Union, Optional\n \n",
        "source_code_with_indent": "from os import path\nfrom typing import Any, Dict, Iterable, Set, Union\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "from os import path\nfrom typing import Any, Dict, Iterable, Set, Union, Optional\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "        \"\"\"\n        if isinstance(data_family, str) and \".\" not in data_family:\n            parsed_data_family = DataFamily.parse(data_family)\n        if parsed_data_family != DataFamily.Unknown:\n            data_family = parsed_data_family.name\n        return self.data_families[data_family][query_name]\n\n    def find_query(self, query_name: str) -> Set[QuerySource]:\n        \"\"\"\n",
        "source_code_len": 381,
        "target_code": "        \"\"\"\n        if isinstance(query_name, str) and \".\" in query_name:\n            data_family, query_name = query_name.split(\".\", maxsplit=1)\n        if not data_family:\n            raise LookupError(\"No data family specified.\")\n        if isinstance(data_family, DataFamily):\n            data_family = data_family.name\n        return self.data_families[data_family][query_name]\n\n    def find_query(self, query_name: str) -> Set[Optional[QuerySource]]:\n        \"\"\"\n",
        "target_code_len": 469,
        "diff_format": "@@ -201,9 +205,11 @@\n         \"\"\"\n-        if isinstance(data_family, str) and \".\" not in data_family:\n-            parsed_data_family = DataFamily.parse(data_family)\n-        if parsed_data_family != DataFamily.Unknown:\n-            data_family = parsed_data_family.name\n+        if isinstance(query_name, str) and \".\" in query_name:\n+            data_family, query_name = query_name.split(\".\", maxsplit=1)\n+        if not data_family:\n+            raise LookupError(\"No data family specified.\")\n+        if isinstance(data_family, DataFamily):\n+            data_family = data_family.name\n         return self.data_families[data_family][query_name]\n \n-    def find_query(self, query_name: str) -> Set[QuerySource]:\n+    def find_query(self, query_name: str) -> Set[Optional[QuerySource]]:\n         \"\"\"\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\n        if isinstance(data_family, str) and \".\" not in data_family:\n            <IND>parsed_data_family = DataFamily.parse(data_family)\n        <DED>if parsed_data_family != DataFamily.Unknown:\n            <IND>data_family = parsed_data_family.name\n        <DED>return self.data_families[data_family][query_name]\n\n    <DED>def find_query(self, query_name: str) -> Set[QuerySource]:\n        <IND>",
        "target_code_with_indent": "\n        if isinstance(query_name, str) and \".\" in query_name:\n            <IND>data_family, query_name = query_name.split(\".\", maxsplit=1)\n        <DED>if not data_family:\n            <IND>raise LookupError(\"No data family specified.\")\n        <DED>if isinstance(data_family, DataFamily):\n            <IND>data_family = data_family.name\n        <DED>return self.data_families[data_family][query_name]\n\n    <DED>def find_query(self, query_name: str) -> Set[Optional[QuerySource]]:\n        <IND>"
      }
    ]
  },
  {
    "project": "microsoft/msticpy",
    "commit": "95fc39978f2cda28ce4597d023b6119968d8be85",
    "filename": "msticpy/data/query_store.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/microsoft-msticpy/msticpy/data/query_store.py",
    "file_hunks_size": 6,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "msticpy/data/query_store.py:223:8 Incompatible return type [7]: Expected `Set[QuerySource]` but got `Set[typing.Optional[QuerySource]]`.",
    "message": " Expected `Set[QuerySource]` but got `Set[typing.Optional[QuerySource]]`.",
    "rule_id": "Incompatible return type [7]",
    "warning_line_no": 223,
    "warning_line": "        return {",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "from os import path\nfrom typing import Any, Dict, Iterable, Set, Union\n\n",
        "source_code_len": 72,
        "target_code": "from os import path\nfrom typing import Any, Dict, Iterable, Set, Union, Optional\n\n",
        "target_code_len": 82,
        "diff_format": "@@ -8,3 +8,3 @@\n from os import path\n-from typing import Any, Dict, Iterable, Set, Union\n+from typing import Any, Dict, Iterable, Set, Union, Optional\n \n",
        "source_code_with_indent": "from os import path\nfrom typing import Any, Dict, Iterable, Set, Union\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "from os import path\nfrom typing import Any, Dict, Iterable, Set, Union, Optional\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "        \"\"\"\n        if isinstance(data_family, str) and \".\" not in data_family:\n            parsed_data_family = DataFamily.parse(data_family)\n        if parsed_data_family != DataFamily.Unknown:\n            data_family = parsed_data_family.name\n        return self.data_families[data_family][query_name]\n\n    def find_query(self, query_name: str) -> Set[QuerySource]:\n        \"\"\"\n",
        "source_code_len": 381,
        "target_code": "        \"\"\"\n        if isinstance(query_name, str) and \".\" in query_name:\n            data_family, query_name = query_name.split(\".\", maxsplit=1)\n        if not data_family:\n            raise LookupError(\"No data family specified.\")\n        if isinstance(data_family, DataFamily):\n            data_family = data_family.name\n        return self.data_families[data_family][query_name]\n\n    def find_query(self, query_name: str) -> Set[Optional[QuerySource]]:\n        \"\"\"\n",
        "target_code_len": 469,
        "diff_format": "@@ -201,9 +205,11 @@\n         \"\"\"\n-        if isinstance(data_family, str) and \".\" not in data_family:\n-            parsed_data_family = DataFamily.parse(data_family)\n-        if parsed_data_family != DataFamily.Unknown:\n-            data_family = parsed_data_family.name\n+        if isinstance(query_name, str) and \".\" in query_name:\n+            data_family, query_name = query_name.split(\".\", maxsplit=1)\n+        if not data_family:\n+            raise LookupError(\"No data family specified.\")\n+        if isinstance(data_family, DataFamily):\n+            data_family = data_family.name\n         return self.data_families[data_family][query_name]\n \n-    def find_query(self, query_name: str) -> Set[QuerySource]:\n+    def find_query(self, query_name: str) -> Set[Optional[QuerySource]]:\n         \"\"\"\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\n        if isinstance(data_family, str) and \".\" not in data_family:\n            <IND>parsed_data_family = DataFamily.parse(data_family)\n        <DED>if parsed_data_family != DataFamily.Unknown:\n            <IND>data_family = parsed_data_family.name\n        <DED>return self.data_families[data_family][query_name]\n\n    <DED>def find_query(self, query_name: str) -> Set[QuerySource]:\n        <IND>",
        "target_code_with_indent": "\n        if isinstance(query_name, str) and \".\" in query_name:\n            <IND>data_family, query_name = query_name.split(\".\", maxsplit=1)\n        <DED>if not data_family:\n            <IND>raise LookupError(\"No data family specified.\")\n        <DED>if isinstance(data_family, DataFamily):\n            <IND>data_family = data_family.name\n        <DED>return self.data_families[data_family][query_name]\n\n    <DED>def find_query(self, query_name: str) -> Set[Optional[QuerySource]]:\n        <IND>"
      }
    ]
  },
  {
    "project": "microsoft/msticpy",
    "commit": "95fc39978f2cda28ce4597d023b6119968d8be85",
    "filename": "msticpy/sectools/tiproviders/alienvault_otx.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/microsoft-msticpy/msticpy/sectools/tiproviders/alienvault_otx.py",
    "file_hunks_size": 1,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "msticpy/sectools/tiproviders/alienvault_otx.py:87:11 Unsupported operand [58]: `in` is not supported for right operand type `typing.Optional[str]`.",
    "message": " `in` is not supported for right operand type `typing.Optional[str]`.",
    "rule_id": "Unsupported operand [58]",
    "warning_line_no": 87,
    "warning_line": "        if \"pulse_info\" in response.raw_result:",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "        \"\"\"\n        if self._failed_response(response):\n            return False, \"Not found.\"\n",
        "source_code_len": 95,
        "target_code": "        \"\"\"\n        if self._failed_response(response) or not isinstance(response.raw_result, dict):\n            return False, \"Not found.\"\n",
        "target_code_len": 140,
        "diff_format": "@@ -84,3 +84,3 @@\n         \"\"\"\n-        if self._failed_response(response):\n+        if self._failed_response(response) or not isinstance(response.raw_result, dict):\n             return False, \"Not found.\"\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\n        if self._failed_response(response):\n            <IND>return False, \"Not found.\"\n",
        "target_code_with_indent": "\n        if self._failed_response(response) or not isinstance(response.raw_result, dict):\n            <IND>return False, \"Not found.\"\n"
      }
    ]
  },
  {
    "project": "microsoft/msticpy",
    "commit": "95fc39978f2cda28ce4597d023b6119968d8be85",
    "filename": "msticpy/sectools/tiproviders/ti_provider_settings.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/microsoft-msticpy/msticpy/sectools/tiproviders/ti_provider_settings.py",
    "file_hunks_size": 1,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": true,
    "full_warning_msg": "msticpy/sectools/tiproviders/ti_provider_settings.py:94:8 Incompatible return type [7]: Expected `str` but got `Optional[str]`.",
    "message": " Expected `str` but got `Optional[str]`.",
    "rule_id": "Incompatible return type [7]",
    "warning_line_no": 94,
    "warning_line": "        return env_value",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": true,
        "source_code": "    \"\"\"Extract the provider args from the settings.\"\"\"\n    arg_dict = {}\n    if \"ApiID\" in prov_args:\n        if isinstance(prov_args[\"ApiID\"], str):\n            arg_dict[\"api_id\"] = prov_args[\"ApiID\"]\n        else:\n            arg_dict[\"api_id\"] = _fetch_setting(prov_args[\"ApiID\"])\n\n    if \"AuthKey\" in prov_args:\n        if isinstance(prov_args[\"AuthKey\"], str):\n            arg_dict[\"auth_key\"] = prov_args[\"AuthKey\"]\n        else:\n            arg_dict[\"auth_key\"] = _fetch_setting(prov_args[\"AuthKey\"])\n    return prov_args\n\n\ndef _fetch_setting(config_setting: Dict[str, Any]) -> str:\n    \"\"\"Return required value for indirect settings (e.g. getting env var).\"\"\"\n",
        "source_code_len": 668,
        "target_code": "    \"\"\"Extract the provider args from the settings.\"\"\"\n    arg_dict: Dict[str, Any] = prov_args.copy()\n    name_map = {\n        \"ApiID\": \"api_id\",\n        \"AuthKey\": \"auth_key\",\n        \"WorkspaceID\": \"workspace_id\",\n        \"TenantID\": \"tenant_id\",\n    }\n    for arg_name, arg_value in prov_args.items():\n        target_name = name_map.get(arg_name, arg_name)\n        if isinstance(arg_value, str):\n            arg_dict[target_name] = arg_value\n        elif isinstance(arg_value, dict):\n            arg_dict[target_name] = _fetch_setting(arg_value)  # type: ignore\n    return arg_dict\n\n\ndef _fetch_setting(config_setting: Dict[str, Any]) -> Optional[str]:\n    \"\"\"Return required value for indirect settings (e.g. getting env var).\"\"\"\n",
        "target_code_len": 735,
        "diff_format": "@@ -68,18 +68,19 @@\n     \"\"\"Extract the provider args from the settings.\"\"\"\n-    arg_dict = {}\n-    if \"ApiID\" in prov_args:\n-        if isinstance(prov_args[\"ApiID\"], str):\n-            arg_dict[\"api_id\"] = prov_args[\"ApiID\"]\n-        else:\n-            arg_dict[\"api_id\"] = _fetch_setting(prov_args[\"ApiID\"])\n-\n-    if \"AuthKey\" in prov_args:\n-        if isinstance(prov_args[\"AuthKey\"], str):\n-            arg_dict[\"auth_key\"] = prov_args[\"AuthKey\"]\n-        else:\n-            arg_dict[\"auth_key\"] = _fetch_setting(prov_args[\"AuthKey\"])\n-    return prov_args\n+    arg_dict: Dict[str, Any] = prov_args.copy()\n+    name_map = {\n+        \"ApiID\": \"api_id\",\n+        \"AuthKey\": \"auth_key\",\n+        \"WorkspaceID\": \"workspace_id\",\n+        \"TenantID\": \"tenant_id\",\n+    }\n+    for arg_name, arg_value in prov_args.items():\n+        target_name = name_map.get(arg_name, arg_name)\n+        if isinstance(arg_value, str):\n+            arg_dict[target_name] = arg_value\n+        elif isinstance(arg_value, dict):\n+            arg_dict[target_name] = _fetch_setting(arg_value)  # type: ignore\n+    return arg_dict\n \n \n-def _fetch_setting(config_setting: Dict[str, Any]) -> str:\n+def _fetch_setting(config_setting: Dict[str, Any]) -> Optional[str]:\n     \"\"\"Return required value for indirect settings (e.g. getting env var).\"\"\"\n",
        "source_code_with_indent": "    <IND>\"\"\"Extract the provider args from the settings.\"\"\"\n    arg_dict = {}\n    if \"ApiID\" in prov_args:\n        <IND>if isinstance(prov_args[\"ApiID\"], str):\n            <IND>arg_dict[\"api_id\"] = prov_args[\"ApiID\"]\n        <DED>else:\n            <IND>arg_dict[\"api_id\"] = _fetch_setting(prov_args[\"ApiID\"])\n\n    <DED><DED>if \"AuthKey\" in prov_args:\n        <IND>if isinstance(prov_args[\"AuthKey\"], str):\n            <IND>arg_dict[\"auth_key\"] = prov_args[\"AuthKey\"]\n        <DED>else:\n            <IND>arg_dict[\"auth_key\"] = _fetch_setting(prov_args[\"AuthKey\"])\n    <DED><DED>return prov_args\n\n\n<DED>def _fetch_setting(config_setting: Dict[str, Any]) -> str:\n    <IND>\"\"\"Return required value for indirect settings (e.g. getting env var).\"\"\"\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    <IND>\"\"\"Extract the provider args from the settings.\"\"\"\n    arg_dict: Dict[str, Any] = prov_args.copy()\n    name_map = {\n        \"ApiID\": \"api_id\",\n        \"AuthKey\": \"auth_key\",\n        \"WorkspaceID\": \"workspace_id\",\n        \"TenantID\": \"tenant_id\",\n    }\n    for arg_name, arg_value in prov_args.items():\n        <IND>target_name = name_map.get(arg_name, arg_name)\n        if isinstance(arg_value, str):\n            <IND>arg_dict[target_name] = arg_value\n        <DED>elif isinstance(arg_value, dict):\n            <IND>arg_dict[target_name] = _fetch_setting(arg_value)  # type: ignore\n    <DED><DED>return arg_dict\n\n\n<DED>def _fetch_setting(config_setting: Dict[str, Any]) -> Optional[str]:\n    <IND>\"\"\"Return required value for indirect settings (e.g. getting env var).\"\"\"\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "microsoft/msticpy",
    "commit": "95fc39978f2cda28ce4597d023b6119968d8be85",
    "filename": "msticpy/sectools/tiproviders/ti_provider_settings.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/microsoft-msticpy/msticpy/sectools/tiproviders/ti_provider_settings.py",
    "file_hunks_size": 1,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": true,
    "full_warning_msg": "msticpy/sectools/tiproviders/ti_provider_settings.py:97:4 Incompatible return type [7]: Expected `str` but got `None`.",
    "message": " Expected `str` but got `None`.",
    "rule_id": "Incompatible return type [7]",
    "warning_line_no": 97,
    "warning_line": "    return None",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": true,
        "source_code": "    \"\"\"Extract the provider args from the settings.\"\"\"\n    arg_dict = {}\n    if \"ApiID\" in prov_args:\n        if isinstance(prov_args[\"ApiID\"], str):\n            arg_dict[\"api_id\"] = prov_args[\"ApiID\"]\n        else:\n            arg_dict[\"api_id\"] = _fetch_setting(prov_args[\"ApiID\"])\n\n    if \"AuthKey\" in prov_args:\n        if isinstance(prov_args[\"AuthKey\"], str):\n            arg_dict[\"auth_key\"] = prov_args[\"AuthKey\"]\n        else:\n            arg_dict[\"auth_key\"] = _fetch_setting(prov_args[\"AuthKey\"])\n    return prov_args\n\n\ndef _fetch_setting(config_setting: Dict[str, Any]) -> str:\n    \"\"\"Return required value for indirect settings (e.g. getting env var).\"\"\"\n",
        "source_code_len": 668,
        "target_code": "    \"\"\"Extract the provider args from the settings.\"\"\"\n    arg_dict: Dict[str, Any] = prov_args.copy()\n    name_map = {\n        \"ApiID\": \"api_id\",\n        \"AuthKey\": \"auth_key\",\n        \"WorkspaceID\": \"workspace_id\",\n        \"TenantID\": \"tenant_id\",\n    }\n    for arg_name, arg_value in prov_args.items():\n        target_name = name_map.get(arg_name, arg_name)\n        if isinstance(arg_value, str):\n            arg_dict[target_name] = arg_value\n        elif isinstance(arg_value, dict):\n            arg_dict[target_name] = _fetch_setting(arg_value)  # type: ignore\n    return arg_dict\n\n\ndef _fetch_setting(config_setting: Dict[str, Any]) -> Optional[str]:\n    \"\"\"Return required value for indirect settings (e.g. getting env var).\"\"\"\n",
        "target_code_len": 735,
        "diff_format": "@@ -68,18 +68,19 @@\n     \"\"\"Extract the provider args from the settings.\"\"\"\n-    arg_dict = {}\n-    if \"ApiID\" in prov_args:\n-        if isinstance(prov_args[\"ApiID\"], str):\n-            arg_dict[\"api_id\"] = prov_args[\"ApiID\"]\n-        else:\n-            arg_dict[\"api_id\"] = _fetch_setting(prov_args[\"ApiID\"])\n-\n-    if \"AuthKey\" in prov_args:\n-        if isinstance(prov_args[\"AuthKey\"], str):\n-            arg_dict[\"auth_key\"] = prov_args[\"AuthKey\"]\n-        else:\n-            arg_dict[\"auth_key\"] = _fetch_setting(prov_args[\"AuthKey\"])\n-    return prov_args\n+    arg_dict: Dict[str, Any] = prov_args.copy()\n+    name_map = {\n+        \"ApiID\": \"api_id\",\n+        \"AuthKey\": \"auth_key\",\n+        \"WorkspaceID\": \"workspace_id\",\n+        \"TenantID\": \"tenant_id\",\n+    }\n+    for arg_name, arg_value in prov_args.items():\n+        target_name = name_map.get(arg_name, arg_name)\n+        if isinstance(arg_value, str):\n+            arg_dict[target_name] = arg_value\n+        elif isinstance(arg_value, dict):\n+            arg_dict[target_name] = _fetch_setting(arg_value)  # type: ignore\n+    return arg_dict\n \n \n-def _fetch_setting(config_setting: Dict[str, Any]) -> str:\n+def _fetch_setting(config_setting: Dict[str, Any]) -> Optional[str]:\n     \"\"\"Return required value for indirect settings (e.g. getting env var).\"\"\"\n",
        "source_code_with_indent": "    <IND>\"\"\"Extract the provider args from the settings.\"\"\"\n    arg_dict = {}\n    if \"ApiID\" in prov_args:\n        <IND>if isinstance(prov_args[\"ApiID\"], str):\n            <IND>arg_dict[\"api_id\"] = prov_args[\"ApiID\"]\n        <DED>else:\n            <IND>arg_dict[\"api_id\"] = _fetch_setting(prov_args[\"ApiID\"])\n\n    <DED><DED>if \"AuthKey\" in prov_args:\n        <IND>if isinstance(prov_args[\"AuthKey\"], str):\n            <IND>arg_dict[\"auth_key\"] = prov_args[\"AuthKey\"]\n        <DED>else:\n            <IND>arg_dict[\"auth_key\"] = _fetch_setting(prov_args[\"AuthKey\"])\n    <DED><DED>return prov_args\n\n\n<DED>def _fetch_setting(config_setting: Dict[str, Any]) -> str:\n    <IND>\"\"\"Return required value for indirect settings (e.g. getting env var).\"\"\"\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    <IND>\"\"\"Extract the provider args from the settings.\"\"\"\n    arg_dict: Dict[str, Any] = prov_args.copy()\n    name_map = {\n        \"ApiID\": \"api_id\",\n        \"AuthKey\": \"auth_key\",\n        \"WorkspaceID\": \"workspace_id\",\n        \"TenantID\": \"tenant_id\",\n    }\n    for arg_name, arg_value in prov_args.items():\n        <IND>target_name = name_map.get(arg_name, arg_name)\n        if isinstance(arg_value, str):\n            <IND>arg_dict[target_name] = arg_value\n        <DED>elif isinstance(arg_value, dict):\n            <IND>arg_dict[target_name] = _fetch_setting(arg_value)  # type: ignore\n    <DED><DED>return arg_dict\n\n\n<DED>def _fetch_setting(config_setting: Dict[str, Any]) -> Optional[str]:\n    <IND>\"\"\"Return required value for indirect settings (e.g. getting env var).\"\"\"\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  }
]