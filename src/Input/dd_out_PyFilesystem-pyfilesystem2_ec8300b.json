[
  {
    "project": "PyFilesystem/pyfilesystem2",
    "commit": "ec8300b3dac2bfa68d59b3b290e40c3fb608976b",
    "filename": "fs/iotools.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/PyFilesystem-pyfilesystem2/fs/iotools.py",
    "file_hunks_size": 4,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "fs/iotools.py:90:4 Inconsistent override [14]: `fs.iotools.RawWrapper.write` overrides method defined in `RawIOBase` inconsistently. Parameter of type `bytes` is not a supertype of the overridden parameter `Union[array.array[typing.Any], bytearray, bytes, memoryview, mmap.mmap]`.",
    "message": " `fs.iotools.RawWrapper.write` overrides method defined in `RawIOBase` inconsistently. Parameter of type `bytes` is not a supertype of the overridden parameter `Union[array.array[typing.Any], bytearray, bytes, memoryview, mmap.mmap]`.",
    "rule_id": "Inconsistent override [14]",
    "warning_line_no": 90,
    "warning_line": "    def write(self, data):",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\nimport io\n",
        "source_code_len": 11,
        "target_code": "\nimport array\nimport io\n",
        "target_code_len": 24,
        "diff_format": "@@ -6,2 +6,3 @@\n \n+import array\n import io\n",
        "source_code_with_indent": "\nimport io\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\nimport array\nimport io\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": true,
        "source_code": "    def write(self, data):\n        # type: (bytes) -> int\n        count = self._f.write(data)\n        return len(data) if count is None else count\n",
        "source_code_len": 147,
        "target_code": "    def write(self, data):\n        # type: (Union[bytes, bytearray, memoryview, array.array[Any], mmap.mmap]) -> int\n        if isinstance(data, array.array):\n            count = self._f.write(data.tobytes())\n        else:\n            count = self._f.write(data)  # type: ignore\n        return len(data) if count is None else count\n",
        "target_code_len": 332,
        "diff_format": "@@ -90,4 +92,7 @@\n     def write(self, data):\n-        # type: (bytes) -> int\n-        count = self._f.write(data)\n+        # type: (Union[bytes, bytearray, memoryview, array.array[Any], mmap.mmap]) -> int\n+        if isinstance(data, array.array):\n+            count = self._f.write(data.tobytes())\n+        else:\n+            count = self._f.write(data)  # type: ignore\n         return len(data) if count is None else count\n",
        "source_code_with_indent": "    <DED>def write(self, data):\n        # type: (bytes) -> int\n        <IND>count = self._f.write(data)\n        return len(data) if count is None else count\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    <DED>def write(self, data):\n        # type: (Union[bytes, bytearray, memoryview, array.array[Any], mmap.mmap]) -> int\n        <IND>if isinstance(data, array.array):\n            <IND>count = self._f.write(data.tobytes())\n        <DED>else:\n            <IND>count = self._f.write(data)  # type: ignore\n        <DED>return len(data) if count is None else count\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "PyFilesystem/pyfilesystem2",
    "commit": "ec8300b3dac2bfa68d59b3b290e40c3fb608976b",
    "filename": "fs/iotools.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/PyFilesystem-pyfilesystem2/fs/iotools.py",
    "file_hunks_size": 4,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "fs/iotools.py:133:4 Inconsistent override [14]: `fs.iotools.RawWrapper.readline` overrides method defined in `io.IOBase` inconsistently. Parameter of type `int` is not a supertype of the overridden parameter `Optional[int]`.",
    "message": " `fs.iotools.RawWrapper.readline` overrides method defined in `io.IOBase` inconsistently. Parameter of type `int` is not a supertype of the overridden parameter `Optional[int]`.",
    "rule_id": "Inconsistent override [14]",
    "warning_line_no": 133,
    "warning_line": "    def readline(self, limit=-1):",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\nimport io\n",
        "source_code_len": 11,
        "target_code": "\nimport array\nimport io\n",
        "target_code_len": 24,
        "diff_format": "@@ -6,2 +6,3 @@\n \n+import array\n import io\n",
        "source_code_with_indent": "\nimport io\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\nimport array\nimport io\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n    def readline(self, limit=-1):\n        # type: (int) -> bytes\n        return self._f.readline(limit)\n\n    def readlines(self, hint=-1):\n        # type: (int) -> List[bytes]\n        return self._f.readlines(hint)\n\n    def writelines(self, sequence):\n        # type: (Iterable[Union[bytes, bytearray]]) -> None\n        return self._f.writelines(sequence)\n\n",
        "source_code_len": 358,
        "target_code": "\n    def readline(self, limit=None):\n        # type: (Optional[int]) -> bytes\n        return self._f.readline(-1 if limit is None else limit)\n\n    def readlines(self, hint=None):\n        # type: (Optional[int]) -> List[bytes]\n        return self._f.readlines(-1 if hint is None else hint)\n\n    def writelines(self, lines):\n        # type: (Iterable[Union[bytes, bytearray, memoryview, array.array[Any], mmap.mmap]]) -> None\n        _lines = (\n            line.tobytes() if isinstance(line, array.array) else line for line in lines\n        )\n        return self._f.writelines(typing.cast(\"Iterable[bytes]\", _lines))\n\n",
        "target_code_len": 616,
        "diff_format": "@@ -132,13 +137,16 @@\n \n-    def readline(self, limit=-1):\n-        # type: (int) -> bytes\n-        return self._f.readline(limit)\n-\n-    def readlines(self, hint=-1):\n-        # type: (int) -> List[bytes]\n-        return self._f.readlines(hint)\n-\n-    def writelines(self, sequence):\n-        # type: (Iterable[Union[bytes, bytearray]]) -> None\n-        return self._f.writelines(sequence)\n+    def readline(self, limit=None):\n+        # type: (Optional[int]) -> bytes\n+        return self._f.readline(-1 if limit is None else limit)\n+\n+    def readlines(self, hint=None):\n+        # type: (Optional[int]) -> List[bytes]\n+        return self._f.readlines(-1 if hint is None else hint)\n+\n+    def writelines(self, lines):\n+        # type: (Iterable[Union[bytes, bytearray, memoryview, array.array[Any], mmap.mmap]]) -> None\n+        _lines = (\n+            line.tobytes() if isinstance(line, array.array) else line for line in lines\n+        )\n+        return self._f.writelines(typing.cast(\"Iterable[bytes]\", _lines))\n \n",
        "source_code_with_indent": "\n    <DED><DED>def readline(self, limit=-1):\n        # type: (int) -> bytes\n        <IND>return self._f.readline(limit)\n\n    <DED>def readlines(self, hint=-1):\n        # type: (int) -> List[bytes]\n        <IND>return self._f.readlines(hint)\n\n    <DED>def writelines(self, sequence):\n        # type: (Iterable[Union[bytes, bytearray]]) -> None\n        <IND>return self._f.writelines(sequence)\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n    <DED><DED>def readline(self, limit=None):\n        # type: (Optional[int]) -> bytes\n        <IND>return self._f.readline(-1 if limit is None else limit)\n\n    <DED>def readlines(self, hint=None):\n        # type: (Optional[int]) -> List[bytes]\n        <IND>return self._f.readlines(-1 if hint is None else hint)\n\n    <DED>def writelines(self, lines):\n        # type: (Iterable[Union[bytes, bytearray, memoryview, array.array[Any], mmap.mmap]]) -> None\n        <IND>_lines = (\n            line.tobytes() if isinstance(line, array.array) else line for line in lines\n        )\n        return self._f.writelines(typing.cast(\"Iterable[bytes]\", _lines))\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "PyFilesystem/pyfilesystem2",
    "commit": "ec8300b3dac2bfa68d59b3b290e40c3fb608976b",
    "filename": "fs/iotools.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/PyFilesystem-pyfilesystem2/fs/iotools.py",
    "file_hunks_size": 4,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "fs/iotools.py:141:4 Inconsistent override [14]: `fs.iotools.RawWrapper.writelines` overrides method defined in `io.IOBase` inconsistently. Parameter of type `Iterable[Union[bytearray, bytes]]` is not a supertype of the overridden parameter `Iterable[Union[array.array[typing.Any], bytearray, bytes, memoryview, mmap.mmap]]`.",
    "message": " `fs.iotools.RawWrapper.writelines` overrides method defined in `io.IOBase` inconsistently. Parameter of type `Iterable[Union[bytearray, bytes]]` is not a supertype of the overridden parameter `Iterable[Union[array.array[typing.Any], bytearray, bytes, memoryview, mmap.mmap]]`.",
    "rule_id": "Inconsistent override [14]",
    "warning_line_no": 141,
    "warning_line": "    def writelines(self, sequence):",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\nimport io\n",
        "source_code_len": 11,
        "target_code": "\nimport array\nimport io\n",
        "target_code_len": 24,
        "diff_format": "@@ -6,2 +6,3 @@\n \n+import array\n import io\n",
        "source_code_with_indent": "\nimport io\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\nimport array\nimport io\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n    def readline(self, limit=-1):\n        # type: (int) -> bytes\n        return self._f.readline(limit)\n\n    def readlines(self, hint=-1):\n        # type: (int) -> List[bytes]\n        return self._f.readlines(hint)\n\n    def writelines(self, sequence):\n        # type: (Iterable[Union[bytes, bytearray]]) -> None\n        return self._f.writelines(sequence)\n\n",
        "source_code_len": 358,
        "target_code": "\n    def readline(self, limit=None):\n        # type: (Optional[int]) -> bytes\n        return self._f.readline(-1 if limit is None else limit)\n\n    def readlines(self, hint=None):\n        # type: (Optional[int]) -> List[bytes]\n        return self._f.readlines(-1 if hint is None else hint)\n\n    def writelines(self, lines):\n        # type: (Iterable[Union[bytes, bytearray, memoryview, array.array[Any], mmap.mmap]]) -> None\n        _lines = (\n            line.tobytes() if isinstance(line, array.array) else line for line in lines\n        )\n        return self._f.writelines(typing.cast(\"Iterable[bytes]\", _lines))\n\n",
        "target_code_len": 616,
        "diff_format": "@@ -132,13 +137,16 @@\n \n-    def readline(self, limit=-1):\n-        # type: (int) -> bytes\n-        return self._f.readline(limit)\n-\n-    def readlines(self, hint=-1):\n-        # type: (int) -> List[bytes]\n-        return self._f.readlines(hint)\n-\n-    def writelines(self, sequence):\n-        # type: (Iterable[Union[bytes, bytearray]]) -> None\n-        return self._f.writelines(sequence)\n+    def readline(self, limit=None):\n+        # type: (Optional[int]) -> bytes\n+        return self._f.readline(-1 if limit is None else limit)\n+\n+    def readlines(self, hint=None):\n+        # type: (Optional[int]) -> List[bytes]\n+        return self._f.readlines(-1 if hint is None else hint)\n+\n+    def writelines(self, lines):\n+        # type: (Iterable[Union[bytes, bytearray, memoryview, array.array[Any], mmap.mmap]]) -> None\n+        _lines = (\n+            line.tobytes() if isinstance(line, array.array) else line for line in lines\n+        )\n+        return self._f.writelines(typing.cast(\"Iterable[bytes]\", _lines))\n \n",
        "source_code_with_indent": "\n    <DED><DED>def readline(self, limit=-1):\n        # type: (int) -> bytes\n        <IND>return self._f.readline(limit)\n\n    <DED>def readlines(self, hint=-1):\n        # type: (int) -> List[bytes]\n        <IND>return self._f.readlines(hint)\n\n    <DED>def writelines(self, sequence):\n        # type: (Iterable[Union[bytes, bytearray]]) -> None\n        <IND>return self._f.writelines(sequence)\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n    <DED><DED>def readline(self, limit=None):\n        # type: (Optional[int]) -> bytes\n        <IND>return self._f.readline(-1 if limit is None else limit)\n\n    <DED>def readlines(self, hint=None):\n        # type: (Optional[int]) -> List[bytes]\n        <IND>return self._f.readlines(-1 if hint is None else hint)\n\n    <DED>def writelines(self, lines):\n        # type: (Iterable[Union[bytes, bytearray, memoryview, array.array[Any], mmap.mmap]]) -> None\n        <IND>_lines = (\n            line.tobytes() if isinstance(line, array.array) else line for line in lines\n        )\n        return self._f.writelines(typing.cast(\"Iterable[bytes]\", _lines))\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "PyFilesystem/pyfilesystem2",
    "commit": "ec8300b3dac2bfa68d59b3b290e40c3fb608976b",
    "filename": "fs/iotools.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/PyFilesystem-pyfilesystem2/fs/iotools.py",
    "file_hunks_size": 4,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "fs/iotools.py:143:34 Incompatible parameter type [6]: Expected `Iterable[bytes]` for 1st positional only parameter to call `IO.writelines` but got `Iterable[Union[bytearray, bytes]]`.",
    "message": " Expected `Iterable[bytes]` for 1st positional only parameter to call `IO.writelines` but got `Iterable[Union[bytearray, bytes]]`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 143,
    "warning_line": "        return self._f.writelines(sequence)",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\nimport io\n",
        "source_code_len": 11,
        "target_code": "\nimport array\nimport io\n",
        "target_code_len": 24,
        "diff_format": "@@ -6,2 +6,3 @@\n \n+import array\n import io\n",
        "source_code_with_indent": "\nimport io\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\nimport array\nimport io\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n    def readline(self, limit=-1):\n        # type: (int) -> bytes\n        return self._f.readline(limit)\n\n    def readlines(self, hint=-1):\n        # type: (int) -> List[bytes]\n        return self._f.readlines(hint)\n\n    def writelines(self, sequence):\n        # type: (Iterable[Union[bytes, bytearray]]) -> None\n        return self._f.writelines(sequence)\n\n",
        "source_code_len": 358,
        "target_code": "\n    def readline(self, limit=None):\n        # type: (Optional[int]) -> bytes\n        return self._f.readline(-1 if limit is None else limit)\n\n    def readlines(self, hint=None):\n        # type: (Optional[int]) -> List[bytes]\n        return self._f.readlines(-1 if hint is None else hint)\n\n    def writelines(self, lines):\n        # type: (Iterable[Union[bytes, bytearray, memoryview, array.array[Any], mmap.mmap]]) -> None\n        _lines = (\n            line.tobytes() if isinstance(line, array.array) else line for line in lines\n        )\n        return self._f.writelines(typing.cast(\"Iterable[bytes]\", _lines))\n\n",
        "target_code_len": 616,
        "diff_format": "@@ -132,13 +137,16 @@\n \n-    def readline(self, limit=-1):\n-        # type: (int) -> bytes\n-        return self._f.readline(limit)\n-\n-    def readlines(self, hint=-1):\n-        # type: (int) -> List[bytes]\n-        return self._f.readlines(hint)\n-\n-    def writelines(self, sequence):\n-        # type: (Iterable[Union[bytes, bytearray]]) -> None\n-        return self._f.writelines(sequence)\n+    def readline(self, limit=None):\n+        # type: (Optional[int]) -> bytes\n+        return self._f.readline(-1 if limit is None else limit)\n+\n+    def readlines(self, hint=None):\n+        # type: (Optional[int]) -> List[bytes]\n+        return self._f.readlines(-1 if hint is None else hint)\n+\n+    def writelines(self, lines):\n+        # type: (Iterable[Union[bytes, bytearray, memoryview, array.array[Any], mmap.mmap]]) -> None\n+        _lines = (\n+            line.tobytes() if isinstance(line, array.array) else line for line in lines\n+        )\n+        return self._f.writelines(typing.cast(\"Iterable[bytes]\", _lines))\n \n",
        "source_code_with_indent": "\n    <DED><DED>def readline(self, limit=-1):\n        # type: (int) -> bytes\n        <IND>return self._f.readline(limit)\n\n    <DED>def readlines(self, hint=-1):\n        # type: (int) -> List[bytes]\n        <IND>return self._f.readlines(hint)\n\n    <DED>def writelines(self, sequence):\n        # type: (Iterable[Union[bytes, bytearray]]) -> None\n        <IND>return self._f.writelines(sequence)\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n    <DED><DED>def readline(self, limit=None):\n        # type: (Optional[int]) -> bytes\n        <IND>return self._f.readline(-1 if limit is None else limit)\n\n    <DED>def readlines(self, hint=None):\n        # type: (Optional[int]) -> List[bytes]\n        <IND>return self._f.readlines(-1 if hint is None else hint)\n\n    <DED>def writelines(self, lines):\n        # type: (Iterable[Union[bytes, bytearray, memoryview, array.array[Any], mmap.mmap]]) -> None\n        <IND>_lines = (\n            line.tobytes() if isinstance(line, array.array) else line for line in lines\n        )\n        return self._f.writelines(typing.cast(\"Iterable[bytes]\", _lines))\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "PyFilesystem/pyfilesystem2",
    "commit": "ec8300b3dac2bfa68d59b3b290e40c3fb608976b",
    "filename": "fs/memoryfs.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/PyFilesystem-pyfilesystem2/fs/memoryfs.py",
    "file_hunks_size": 6,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": true,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "fs/memoryfs.py:119:4 Inconsistent override [14]: `fs.memoryfs._MemoryFile.readline` overrides method defined in `io.IOBase` inconsistently. Parameter of type `int` is not a supertype of the overridden parameter `Optional[int]`.",
    "message": " `fs.memoryfs._MemoryFile.readline` overrides method defined in `io.IOBase` inconsistently. Parameter of type `int` is not a supertype of the overridden parameter `Optional[int]`.",
    "rule_id": "Inconsistent override [14]",
    "warning_line_no": 119,
    "warning_line": "    def readline(self, size=-1):",
    "min_patch": [
      {
        "hunk_fit_TFix": true,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n    def readline(self, size=-1):\n        # type: (int) -> bytes\n        if not self._mode.reading:\n",
        "source_code_len": 100,
        "target_code": "\n    def readline(self, size=None):\n        # type: (Optional[int]) -> bytes\n        if not self._mode.reading:\n",
        "target_code_len": 112,
        "diff_format": "@@ -118,4 +121,4 @@\n \n-    def readline(self, size=-1):\n-        # type: (int) -> bytes\n+    def readline(self, size=None):\n+        # type: (Optional[int]) -> bytes\n         if not self._mode.reading:\n",
        "source_code_with_indent": "\n    def readline(self, size=-1):\n        # type: (int) -> bytes\n        <IND>if not self._mode.reading:\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n    def readline(self, size=None):\n        # type: (Optional[int]) -> bytes\n        <IND>if not self._mode.reading:\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "PyFilesystem/pyfilesystem2",
    "commit": "ec8300b3dac2bfa68d59b3b290e40c3fb608976b",
    "filename": "fs/memoryfs.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/PyFilesystem-pyfilesystem2/fs/memoryfs.py",
    "file_hunks_size": 6,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": true,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "fs/memoryfs.py:192:4 Inconsistent override [14]: `fs.memoryfs._MemoryFile.write` overrides method defined in `io.RawIOBase` inconsistently. Parameter of type `bytes` is not a supertype of the overridden parameter `Union[array.array[typing.Any], bytearray, bytes, memoryview, mmap.mmap]`.",
    "message": " `fs.memoryfs._MemoryFile.write` overrides method defined in `io.RawIOBase` inconsistently. Parameter of type `bytes` is not a supertype of the overridden parameter `Union[array.array[typing.Any], bytearray, bytes, memoryview, mmap.mmap]`.",
    "rule_id": "Inconsistent override [14]",
    "warning_line_no": 192,
    "warning_line": "    def write(self, data):",
    "min_patch": [
      {
        "hunk_fit_TFix": true,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    def write(self, data):\n        # type: (bytes) -> int\n        if not self._mode.writing:\n",
        "source_code_len": 93,
        "target_code": "    def write(self, data):\n        # type: (Union[bytes, bytearray, memoryview, array.array[Any], mmap.mmap]) -> int\n        if not self._mode.writing:\n",
        "target_code_len": 152,
        "diff_format": "@@ -192,3 +195,3 @@\n     def write(self, data):\n-        # type: (bytes) -> int\n+        # type: (Union[bytes, bytearray, memoryview, array.array[Any], mmap.mmap]) -> int\n         if not self._mode.writing:\n",
        "source_code_with_indent": "    <DED>def write(self, data):\n        # type: (bytes) -> int\n        <IND>if not self._mode.writing:\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    <DED>def write(self, data):\n        # type: (Union[bytes, bytearray, memoryview, array.array[Any], mmap.mmap]) -> int\n        <IND>if not self._mode.writing:\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  }
]