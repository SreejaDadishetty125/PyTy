[
  {
    "project": "bokeh/bokeh",
    "commit": "03cc08c313378265d32b046897540b3bb34b08e4",
    "filename": "bokeh/document/document.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/bokeh-bokeh/bokeh/document/document.py",
    "file_hunks_size": 37,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "bokeh/document/document.py:391:37 Incompatible parameter type [6]: Expected `bokeh.events.ModelEvent` for 1st positional only parameter to call `bokeh.util.callback_manager.EventCallbackManager._trigger_event` but got `Event`.",
    "message": " Expected `bokeh.events.ModelEvent` for 1st positional only parameter to call `bokeh.util.callback_manager.EventCallbackManager._trigger_event` but got `Event`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 391,
    "warning_line": "                model._trigger_event(event)"
  },
  {
    "project": "bokeh/bokeh",
    "commit": "03cc08c313378265d32b046897540b3bb34b08e4",
    "filename": "bokeh/document/document.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/bokeh-bokeh/bokeh/document/document.py",
    "file_hunks_size": 37,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "bokeh/document/document.py:625:50 Incompatible parameter type [6]: Expected `str` for 1st positional only parameter to call `dict.__getitem__` but got `typing.Union[Type[Event], str]`.",
    "message": " Expected `str` for 1st positional only parameter to call `dict.__getitem__` but got `typing.Union[Type[Event], str]`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 625,
    "warning_line": "        if not issubclass(_CONCRETE_EVENT_CLASSES[event], DocumentEvent):"
  },
  {
    "project": "bokeh/bokeh",
    "commit": "03cc08c313378265d32b046897540b3bb34b08e4",
    "filename": "bokeh/document/document.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/bokeh-bokeh/bokeh/document/document.py",
    "file_hunks_size": 37,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "bokeh/document/document.py:634:34 Incompatible parameter type [6]: Expected `str` for 1st positional only parameter to call `dict.__setitem__` but got `typing.Union[Type[Event], str]`.",
    "message": " Expected `str` for 1st positional only parameter to call `dict.__setitem__` but got `typing.Union[Type[Event], str]`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 634,
    "warning_line": "            self._event_callbacks[event] = [cb for cb in callbacks]"
  },
  {
    "project": "bokeh/bokeh",
    "commit": "03cc08c313378265d32b046897540b3bb34b08e4",
    "filename": "bokeh/document/document.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/bokeh-bokeh/bokeh/document/document.py",
    "file_hunks_size": 37,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "bokeh/document/document.py:1025:26 Incompatible parameter type [6]: Expected `Document` for 1st positional only parameter to call `patch_curdoc` but got `typing.Union[Document, UnlockedDocumentProxy]`.",
    "message": " Expected `Document` for 1st positional only parameter to call `patch_curdoc` but got `typing.Union[Document, UnlockedDocumentProxy]`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 1025,
    "warning_line": "        with patch_curdoc(doc):"
  },
  {
    "project": "bokeh/bokeh",
    "commit": "03cc08c313378265d32b046897540b3bb34b08e4",
    "filename": "bokeh/io/doc.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/bokeh-bokeh/bokeh/io/doc.py",
    "file_hunks_size": 7,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": true,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "bokeh/io/doc.py:90:4 Incompatible return type [7]: Expected `None` but got `typing.Generator[None, None, None]`.",
    "message": " Expected `None` but got `typing.Generator[None, None, None]`.",
    "rule_id": "Incompatible return type [7]",
    "warning_line_no": 90,
    "warning_line": "    yield",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": true,
        "has_suppression": false,
        "source_code": "\n@contextmanager\ndef patch_curdoc(doc: Document) -> None:\n    '''\n\n    Args:\n        doc (Document) : new Document\n\n    '''\n    global _PATCHED_CURDOCS\n    _PATCHED_CURDOCS.append(doc)\n    yield\n    _PATCHED_CURDOCS.pop()\n\n#-----------------------------------------------------------------------------\n",
        "source_code_len": 302,
        "target_code": "\n#-----------------------------------------------------------------------------\n",
        "target_code_len": 80,
        "diff_format": "@@ -79,15 +102,2 @@\n \n-@contextmanager\n-def patch_curdoc(doc: Document) -> None:\n-    '''\n-\n-    Args:\n-        doc (Document) : new Document\n-\n-    '''\n-    global _PATCHED_CURDOCS\n-    _PATCHED_CURDOCS.append(doc)\n-    yield\n-    _PATCHED_CURDOCS.pop()\n-\n #-----------------------------------------------------------------------------\n",
        "source_code_with_indent": "\n<DED>@contextmanager\ndef patch_curdoc(doc: Document) -> None:\n    <IND>'''\n\n    Args:\n        doc (Document) : new Document\n\n    '''\n    global _PATCHED_CURDOCS\n    _PATCHED_CURDOCS.append(doc)\n    yield\n    _PATCHED_CURDOCS.pop()\n\n#-----------------------------------------------------------------------------\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n#-----------------------------------------------------------------------------\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "bokeh/bokeh",
    "commit": "03cc08c313378265d32b046897540b3bb34b08e4",
    "filename": "tests/unit/bokeh/document/test_document.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/bokeh-bokeh/tests/unit/bokeh/document/test_document.py",
    "file_hunks_size": 4,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "tests/unit/bokeh/document/test_document.py:94:19 Incompatible parameter type [6]: Expected `typing.Union[typing_extensions.Literal['collect'], typing_extensions.Literal['combine']]` for 1st positional only parameter to call `document.Document.hold` but got `typing_extensions.Literal['junk']`.",
    "message": " Expected `typing.Union[typing_extensions.Literal['collect'], typing_extensions.Literal['combine']]` for 1st positional only parameter to call `document.Document.hold` but got `typing_extensions.Literal['junk']`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 94,
    "warning_line": "            d.hold(\"junk\")",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n# Standard library imports\nimport logging\n\n# External imports\nfrom mock import MagicMock, patch\n\n# Bokeh imports\nfrom bokeh.core.properties import (\n",
        "source_code_len": 150,
        "target_code": "\n# External imports\nfrom mock import patch\n\n# Bokeh imports\nfrom bokeh.core.enums import HoldPolicy\nfrom bokeh.core.properties import (\n",
        "target_code_len": 136,
        "diff_format": "@@ -18,9 +18,7 @@\n \n-# Standard library imports\n-import logging\n-\n # External imports\n-from mock import MagicMock, patch\n+from mock import patch\n \n # Bokeh imports\n+from bokeh.core.enums import HoldPolicy\n from bokeh.core.properties import (\n",
        "source_code_with_indent": "\n# Standard library imports\nimport logging\n\n# External imports\nfrom mock import MagicMock, patch\n\n# Bokeh imports\nfrom bokeh.core.properties import (\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n# External imports\nfrom mock import patch\n\n# Bokeh imports\nfrom bokeh.core.enums import HoldPolicy\nfrom bokeh.core.properties import (\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n\nclass TestDocumentHold:\n    @pytest.mark.parametrize('policy', document.HoldPolicy)\n    def test_hold(self, policy) -> None:\n        d = document.Document()\n        assert d._hold == None\n        assert d._held_events == []\n\n        d.hold(policy)\n        assert d._hold == policy\n\n    def test_hold_bad_policy(self) -> None:\n        d = document.Document()\n        with pytest.raises(ValueError):\n            d.hold(\"junk\")\n\n    @pytest.mark.parametrize('first,second', [('combine', 'collect'), ('collect', 'combine')])\n    def test_rehold(self, first, second, caplog: pytest.LogCaptureFixture) -> None:\n        d = document.Document()\n        with caplog.at_level(logging.WARN):\n            d.hold(first)\n            assert caplog.text == \"\"\n            assert len(caplog.records) == 0\n\n            d.hold(first)\n            assert caplog.text == \"\"\n            assert len(caplog.records) == 0\n\n            d.hold(second)\n            assert caplog.text.strip().endswith(\"hold already active with '%s', ignoring '%s'\" % (first, second))\n            assert len(caplog.records) == 1\n\n            d.unhold()\n\n            d.hold(second)\n            assert len(caplog.records) == 1\n\n    @pytest.mark.parametrize('policy', document.HoldPolicy)\n    def test_unhold(self, policy) -> None:\n        d = document.Document()\n        assert d._hold == None\n        assert d._held_events == []\n\n        d.hold(policy)\n        assert d._hold == policy\n        d.unhold()\n        assert d._hold == None\n\n    @patch(\"bokeh.document.document.Document._trigger_on_change\")\n    def test_unhold_triggers_events(self, mock_trigger: MagicMock) -> None:\n        d = document.Document()\n        d.hold('collect')\n        d._held_events = [1,2,3]\n        d.unhold()\n        assert mock_trigger.call_count == 3\n        assert mock_trigger.call_args[0] == (3,)\n        assert mock_trigger.call_args[1] == {}\n\nclass TestDocument:\n    def test_empty(self) -> None:\n        d = document.Document()\n        assert not d.roots\n\n    def test_default_template_vars(self) -> None:\n        d = document.Document()\n",
        "source_code_len": 2080,
        "target_code": "\nclass TestDocumentHold:\n    @pytest.mark.parametrize('policy', HoldPolicy)\n    @patch(\"bokeh.document.callbacks.DocumentCallbackManager.hold\")\n    def test_hold(self, mock_hold, policy) -> None:\n        d = document.Document()\n        d.hold(policy)\n        assert mock_hold.called\n        assert mock_hold.call_args[0] == (policy,)\n        assert mock_hold.call_args[1] == {}\n\n    @patch(\"bokeh.document.callbacks.DocumentCallbackManager.unhold\")\n    def test_unhold(self, mock_unhold) -> None:\n        d = document.Document()\n        d.unhold()\n        assert mock_unhold.called\n        assert mock_unhold.call_args[0] == ()\n        assert mock_unhold.call_args[1] == {}\n\nclass TestDocument:\n    def test_basic(self) -> None:\n        d = document.Document()\n",
        "target_code_len": 761,
        "diff_format": "@@ -79,66 +77,22 @@\n \n-\n class TestDocumentHold:\n-    @pytest.mark.parametrize('policy', document.HoldPolicy)\n-    def test_hold(self, policy) -> None:\n-        d = document.Document()\n-        assert d._hold == None\n-        assert d._held_events == []\n-\n+    @pytest.mark.parametrize('policy', HoldPolicy)\n+    @patch(\"bokeh.document.callbacks.DocumentCallbackManager.hold\")\n+    def test_hold(self, mock_hold, policy) -> None:\n+        d = document.Document()\n         d.hold(policy)\n-        assert d._hold == policy\n-\n-    def test_hold_bad_policy(self) -> None:\n-        d = document.Document()\n-        with pytest.raises(ValueError):\n-            d.hold(\"junk\")\n-\n-    @pytest.mark.parametrize('first,second', [('combine', 'collect'), ('collect', 'combine')])\n-    def test_rehold(self, first, second, caplog: pytest.LogCaptureFixture) -> None:\n-        d = document.Document()\n-        with caplog.at_level(logging.WARN):\n-            d.hold(first)\n-            assert caplog.text == \"\"\n-            assert len(caplog.records) == 0\n-\n-            d.hold(first)\n-            assert caplog.text == \"\"\n-            assert len(caplog.records) == 0\n-\n-            d.hold(second)\n-            assert caplog.text.strip().endswith(\"hold already active with '%s', ignoring '%s'\" % (first, second))\n-            assert len(caplog.records) == 1\n-\n-            d.unhold()\n-\n-            d.hold(second)\n-            assert len(caplog.records) == 1\n-\n-    @pytest.mark.parametrize('policy', document.HoldPolicy)\n-    def test_unhold(self, policy) -> None:\n-        d = document.Document()\n-        assert d._hold == None\n-        assert d._held_events == []\n-\n-        d.hold(policy)\n-        assert d._hold == policy\n+        assert mock_hold.called\n+        assert mock_hold.call_args[0] == (policy,)\n+        assert mock_hold.call_args[1] == {}\n+\n+    @patch(\"bokeh.document.callbacks.DocumentCallbackManager.unhold\")\n+    def test_unhold(self, mock_unhold) -> None:\n+        d = document.Document()\n         d.unhold()\n-        assert d._hold == None\n-\n-    @patch(\"bokeh.document.document.Document._trigger_on_change\")\n-    def test_unhold_triggers_events(self, mock_trigger: MagicMock) -> None:\n-        d = document.Document()\n-        d.hold('collect')\n-        d._held_events = [1,2,3]\n-        d.unhold()\n-        assert mock_trigger.call_count == 3\n-        assert mock_trigger.call_args[0] == (3,)\n-        assert mock_trigger.call_args[1] == {}\n+        assert mock_unhold.called\n+        assert mock_unhold.call_args[0] == ()\n+        assert mock_unhold.call_args[1] == {}\n \n class TestDocument:\n-    def test_empty(self) -> None:\n-        d = document.Document()\n-        assert not d.roots\n-\n-    def test_default_template_vars(self) -> None:\n+    def test_basic(self) -> None:\n         d = document.Document()\n",
        "source_code_with_indent": "\n\n<DED>class TestDocumentHold:\n    <IND>@pytest.mark.parametrize('policy', document.HoldPolicy)\n    def test_hold(self, policy) -> None:\n        <IND>d = document.Document()\n        assert d._hold == None\n        assert d._held_events == []\n\n        d.hold(policy)\n        assert d._hold == policy\n\n    <DED>def test_hold_bad_policy(self) -> None:\n        <IND>d = document.Document()\n        with pytest.raises(ValueError):\n            <IND>d.hold(\"junk\")\n\n    <DED><DED>@pytest.mark.parametrize('first,second', [('combine', 'collect'), ('collect', 'combine')])\n    def test_rehold(self, first, second, caplog: pytest.LogCaptureFixture) -> None:\n        <IND>d = document.Document()\n        with caplog.at_level(logging.WARN):\n            <IND>d.hold(first)\n            assert caplog.text == \"\"\n            assert len(caplog.records) == 0\n\n            d.hold(first)\n            assert caplog.text == \"\"\n            assert len(caplog.records) == 0\n\n            d.hold(second)\n            assert caplog.text.strip().endswith(\"hold already active with '%s', ignoring '%s'\" % (first, second))\n            assert len(caplog.records) == 1\n\n            d.unhold()\n\n            d.hold(second)\n            assert len(caplog.records) == 1\n\n    <DED><DED>@pytest.mark.parametrize('policy', document.HoldPolicy)\n    def test_unhold(self, policy) -> None:\n        <IND>d = document.Document()\n        assert d._hold == None\n        assert d._held_events == []\n\n        d.hold(policy)\n        assert d._hold == policy\n        d.unhold()\n        assert d._hold == None\n\n    <DED>@patch(\"bokeh.document.document.Document._trigger_on_change\")\n    def test_unhold_triggers_events(self, mock_trigger: MagicMock) -> None:\n        <IND>d = document.Document()\n        d.hold('collect')\n        d._held_events = [1,2,3]\n        d.unhold()\n        assert mock_trigger.call_count == 3\n        assert mock_trigger.call_args[0] == (3,)\n        assert mock_trigger.call_args[1] == {}\n\n<DED><DED>class TestDocument:\n    <IND>def test_empty(self) -> None:\n        <IND>d = document.Document()\n        assert not d.roots\n\n    <DED>def test_default_template_vars(self) -> None:\n        <IND>d = document.Document()\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n<DED>class TestDocumentHold:\n    <IND>@pytest.mark.parametrize('policy', HoldPolicy)\n    @patch(\"bokeh.document.callbacks.DocumentCallbackManager.hold\")\n    def test_hold(self, mock_hold, policy) -> None:\n        <IND>d = document.Document()\n        d.hold(policy)\n        assert mock_hold.called\n        assert mock_hold.call_args[0] == (policy,)\n        assert mock_hold.call_args[1] == {}\n\n    <DED>@patch(\"bokeh.document.callbacks.DocumentCallbackManager.unhold\")\n    def test_unhold(self, mock_unhold) -> None:\n        <IND>d = document.Document()\n        d.unhold()\n        assert mock_unhold.called\n        assert mock_unhold.call_args[0] == ()\n        assert mock_unhold.call_args[1] == {}\n\n<DED><DED>class TestDocument:\n    <IND>def test_basic(self) -> None:\n        <IND>d = document.Document()\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "bokeh/bokeh",
    "commit": "03cc08c313378265d32b046897540b3bb34b08e4",
    "filename": "tests/unit/bokeh/document/test_document.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/bokeh-bokeh/tests/unit/bokeh/document/test_document.py",
    "file_hunks_size": 4,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "tests/unit/bokeh/document/test_document.py:132:8 Incompatible attribute type [8]: Attribute `_held_events` declared in class `document.Document` has type `typing.List[bokeh.document.events.DocumentChangedEvent]` but is used as type `typing.List[int]`.",
    "message": " Attribute `_held_events` declared in class `document.Document` has type `typing.List[bokeh.document.events.DocumentChangedEvent]` but is used as type `typing.List[int]`.",
    "rule_id": "Incompatible attribute type [8]",
    "warning_line_no": 132,
    "warning_line": "        d._held_events = [1,2,3]",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n# Standard library imports\nimport logging\n\n# External imports\nfrom mock import MagicMock, patch\n\n# Bokeh imports\nfrom bokeh.core.properties import (\n",
        "source_code_len": 150,
        "target_code": "\n# External imports\nfrom mock import patch\n\n# Bokeh imports\nfrom bokeh.core.enums import HoldPolicy\nfrom bokeh.core.properties import (\n",
        "target_code_len": 136,
        "diff_format": "@@ -18,9 +18,7 @@\n \n-# Standard library imports\n-import logging\n-\n # External imports\n-from mock import MagicMock, patch\n+from mock import patch\n \n # Bokeh imports\n+from bokeh.core.enums import HoldPolicy\n from bokeh.core.properties import (\n",
        "source_code_with_indent": "\n# Standard library imports\nimport logging\n\n# External imports\nfrom mock import MagicMock, patch\n\n# Bokeh imports\nfrom bokeh.core.properties import (\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n# External imports\nfrom mock import patch\n\n# Bokeh imports\nfrom bokeh.core.enums import HoldPolicy\nfrom bokeh.core.properties import (\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n\nclass TestDocumentHold:\n    @pytest.mark.parametrize('policy', document.HoldPolicy)\n    def test_hold(self, policy) -> None:\n        d = document.Document()\n        assert d._hold == None\n        assert d._held_events == []\n\n        d.hold(policy)\n        assert d._hold == policy\n\n    def test_hold_bad_policy(self) -> None:\n        d = document.Document()\n        with pytest.raises(ValueError):\n            d.hold(\"junk\")\n\n    @pytest.mark.parametrize('first,second', [('combine', 'collect'), ('collect', 'combine')])\n    def test_rehold(self, first, second, caplog: pytest.LogCaptureFixture) -> None:\n        d = document.Document()\n        with caplog.at_level(logging.WARN):\n            d.hold(first)\n            assert caplog.text == \"\"\n            assert len(caplog.records) == 0\n\n            d.hold(first)\n            assert caplog.text == \"\"\n            assert len(caplog.records) == 0\n\n            d.hold(second)\n            assert caplog.text.strip().endswith(\"hold already active with '%s', ignoring '%s'\" % (first, second))\n            assert len(caplog.records) == 1\n\n            d.unhold()\n\n            d.hold(second)\n            assert len(caplog.records) == 1\n\n    @pytest.mark.parametrize('policy', document.HoldPolicy)\n    def test_unhold(self, policy) -> None:\n        d = document.Document()\n        assert d._hold == None\n        assert d._held_events == []\n\n        d.hold(policy)\n        assert d._hold == policy\n        d.unhold()\n        assert d._hold == None\n\n    @patch(\"bokeh.document.document.Document._trigger_on_change\")\n    def test_unhold_triggers_events(self, mock_trigger: MagicMock) -> None:\n        d = document.Document()\n        d.hold('collect')\n        d._held_events = [1,2,3]\n        d.unhold()\n        assert mock_trigger.call_count == 3\n        assert mock_trigger.call_args[0] == (3,)\n        assert mock_trigger.call_args[1] == {}\n\nclass TestDocument:\n    def test_empty(self) -> None:\n        d = document.Document()\n        assert not d.roots\n\n    def test_default_template_vars(self) -> None:\n        d = document.Document()\n",
        "source_code_len": 2080,
        "target_code": "\nclass TestDocumentHold:\n    @pytest.mark.parametrize('policy', HoldPolicy)\n    @patch(\"bokeh.document.callbacks.DocumentCallbackManager.hold\")\n    def test_hold(self, mock_hold, policy) -> None:\n        d = document.Document()\n        d.hold(policy)\n        assert mock_hold.called\n        assert mock_hold.call_args[0] == (policy,)\n        assert mock_hold.call_args[1] == {}\n\n    @patch(\"bokeh.document.callbacks.DocumentCallbackManager.unhold\")\n    def test_unhold(self, mock_unhold) -> None:\n        d = document.Document()\n        d.unhold()\n        assert mock_unhold.called\n        assert mock_unhold.call_args[0] == ()\n        assert mock_unhold.call_args[1] == {}\n\nclass TestDocument:\n    def test_basic(self) -> None:\n        d = document.Document()\n",
        "target_code_len": 761,
        "diff_format": "@@ -79,66 +77,22 @@\n \n-\n class TestDocumentHold:\n-    @pytest.mark.parametrize('policy', document.HoldPolicy)\n-    def test_hold(self, policy) -> None:\n-        d = document.Document()\n-        assert d._hold == None\n-        assert d._held_events == []\n-\n+    @pytest.mark.parametrize('policy', HoldPolicy)\n+    @patch(\"bokeh.document.callbacks.DocumentCallbackManager.hold\")\n+    def test_hold(self, mock_hold, policy) -> None:\n+        d = document.Document()\n         d.hold(policy)\n-        assert d._hold == policy\n-\n-    def test_hold_bad_policy(self) -> None:\n-        d = document.Document()\n-        with pytest.raises(ValueError):\n-            d.hold(\"junk\")\n-\n-    @pytest.mark.parametrize('first,second', [('combine', 'collect'), ('collect', 'combine')])\n-    def test_rehold(self, first, second, caplog: pytest.LogCaptureFixture) -> None:\n-        d = document.Document()\n-        with caplog.at_level(logging.WARN):\n-            d.hold(first)\n-            assert caplog.text == \"\"\n-            assert len(caplog.records) == 0\n-\n-            d.hold(first)\n-            assert caplog.text == \"\"\n-            assert len(caplog.records) == 0\n-\n-            d.hold(second)\n-            assert caplog.text.strip().endswith(\"hold already active with '%s', ignoring '%s'\" % (first, second))\n-            assert len(caplog.records) == 1\n-\n-            d.unhold()\n-\n-            d.hold(second)\n-            assert len(caplog.records) == 1\n-\n-    @pytest.mark.parametrize('policy', document.HoldPolicy)\n-    def test_unhold(self, policy) -> None:\n-        d = document.Document()\n-        assert d._hold == None\n-        assert d._held_events == []\n-\n-        d.hold(policy)\n-        assert d._hold == policy\n+        assert mock_hold.called\n+        assert mock_hold.call_args[0] == (policy,)\n+        assert mock_hold.call_args[1] == {}\n+\n+    @patch(\"bokeh.document.callbacks.DocumentCallbackManager.unhold\")\n+    def test_unhold(self, mock_unhold) -> None:\n+        d = document.Document()\n         d.unhold()\n-        assert d._hold == None\n-\n-    @patch(\"bokeh.document.document.Document._trigger_on_change\")\n-    def test_unhold_triggers_events(self, mock_trigger: MagicMock) -> None:\n-        d = document.Document()\n-        d.hold('collect')\n-        d._held_events = [1,2,3]\n-        d.unhold()\n-        assert mock_trigger.call_count == 3\n-        assert mock_trigger.call_args[0] == (3,)\n-        assert mock_trigger.call_args[1] == {}\n+        assert mock_unhold.called\n+        assert mock_unhold.call_args[0] == ()\n+        assert mock_unhold.call_args[1] == {}\n \n class TestDocument:\n-    def test_empty(self) -> None:\n-        d = document.Document()\n-        assert not d.roots\n-\n-    def test_default_template_vars(self) -> None:\n+    def test_basic(self) -> None:\n         d = document.Document()\n",
        "source_code_with_indent": "\n\n<DED>class TestDocumentHold:\n    <IND>@pytest.mark.parametrize('policy', document.HoldPolicy)\n    def test_hold(self, policy) -> None:\n        <IND>d = document.Document()\n        assert d._hold == None\n        assert d._held_events == []\n\n        d.hold(policy)\n        assert d._hold == policy\n\n    <DED>def test_hold_bad_policy(self) -> None:\n        <IND>d = document.Document()\n        with pytest.raises(ValueError):\n            <IND>d.hold(\"junk\")\n\n    <DED><DED>@pytest.mark.parametrize('first,second', [('combine', 'collect'), ('collect', 'combine')])\n    def test_rehold(self, first, second, caplog: pytest.LogCaptureFixture) -> None:\n        <IND>d = document.Document()\n        with caplog.at_level(logging.WARN):\n            <IND>d.hold(first)\n            assert caplog.text == \"\"\n            assert len(caplog.records) == 0\n\n            d.hold(first)\n            assert caplog.text == \"\"\n            assert len(caplog.records) == 0\n\n            d.hold(second)\n            assert caplog.text.strip().endswith(\"hold already active with '%s', ignoring '%s'\" % (first, second))\n            assert len(caplog.records) == 1\n\n            d.unhold()\n\n            d.hold(second)\n            assert len(caplog.records) == 1\n\n    <DED><DED>@pytest.mark.parametrize('policy', document.HoldPolicy)\n    def test_unhold(self, policy) -> None:\n        <IND>d = document.Document()\n        assert d._hold == None\n        assert d._held_events == []\n\n        d.hold(policy)\n        assert d._hold == policy\n        d.unhold()\n        assert d._hold == None\n\n    <DED>@patch(\"bokeh.document.document.Document._trigger_on_change\")\n    def test_unhold_triggers_events(self, mock_trigger: MagicMock) -> None:\n        <IND>d = document.Document()\n        d.hold('collect')\n        d._held_events = [1,2,3]\n        d.unhold()\n        assert mock_trigger.call_count == 3\n        assert mock_trigger.call_args[0] == (3,)\n        assert mock_trigger.call_args[1] == {}\n\n<DED><DED>class TestDocument:\n    <IND>def test_empty(self) -> None:\n        <IND>d = document.Document()\n        assert not d.roots\n\n    <DED>def test_default_template_vars(self) -> None:\n        <IND>d = document.Document()\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n<DED>class TestDocumentHold:\n    <IND>@pytest.mark.parametrize('policy', HoldPolicy)\n    @patch(\"bokeh.document.callbacks.DocumentCallbackManager.hold\")\n    def test_hold(self, mock_hold, policy) -> None:\n        <IND>d = document.Document()\n        d.hold(policy)\n        assert mock_hold.called\n        assert mock_hold.call_args[0] == (policy,)\n        assert mock_hold.call_args[1] == {}\n\n    <DED>@patch(\"bokeh.document.callbacks.DocumentCallbackManager.unhold\")\n    def test_unhold(self, mock_unhold) -> None:\n        <IND>d = document.Document()\n        d.unhold()\n        assert mock_unhold.called\n        assert mock_unhold.call_args[0] == ()\n        assert mock_unhold.call_args[1] == {}\n\n<DED><DED>class TestDocument:\n    <IND>def test_basic(self) -> None:\n        <IND>d = document.Document()\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "bokeh/bokeh",
    "commit": "03cc08c313378265d32b046897540b3bb34b08e4",
    "filename": "tests/unit/bokeh/document/test_document.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/bokeh-bokeh/tests/unit/bokeh/document/test_document.py",
    "file_hunks_size": 4,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "tests/unit/bokeh/document/test_document.py:955:31 Incompatible parameter type [6]: Expected `bokeh.events.EventJson` for 1st positional only parameter to call `document.Document.apply_json_event` but got `typing.Dict[str, typing.Union[typing.Dict[str, typing.Dict[str, bokeh.core.types.ID]], str]]`.",
    "message": " Expected `bokeh.events.EventJson` for 1st positional only parameter to call `document.Document.apply_json_event` but got `typing.Dict[str, typing.Union[typing.Dict[str, typing.Dict[str, bokeh.core.types.ID]], str]]`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 955,
    "warning_line": "            d.apply_json_event(event_json)"
  }
]