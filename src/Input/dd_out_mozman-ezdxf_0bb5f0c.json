[
  {
    "project": "mozman/ezdxf",
    "commit": "0bb5f0cb7d8d87713e4ae046600ee7ce47a21026",
    "filename": "src/ezdxf/render/dim_linear.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/mozman-ezdxf/src/ezdxf/render/dim_linear.py",
    "file_hunks_size": 47,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "src/ezdxf/render/dim_linear.py:204:48 Incompatible parameter type [6]: Expected `str` for 3rd parameter `linetype` to call `LinearDimension.add_extension_line` but got `typing.Optional[str]`.",
    "message": " Expected `str` for 3rd parameter `linetype` to call `LinearDimension.add_extension_line` but got `typing.Optional[str]`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 204,
    "warning_line": "            self.add_extension_line(start, end, linetype=self.ext1_linetype_name)"
  },
  {
    "project": "mozman/ezdxf",
    "commit": "0bb5f0cb7d8d87713e4ae046600ee7ce47a21026",
    "filename": "src/ezdxf/render/dim_linear.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/mozman-ezdxf/src/ezdxf/render/dim_linear.py",
    "file_hunks_size": 47,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "src/ezdxf/render/dim_linear.py:210:48 Incompatible parameter type [6]: Expected `str` for 3rd parameter `linetype` to call `LinearDimension.add_extension_line` but got `typing.Optional[str]`.",
    "message": " Expected `str` for 3rd parameter `linetype` to call `LinearDimension.add_extension_line` but got `typing.Optional[str]`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 210,
    "warning_line": "            self.add_extension_line(start, end, linetype=self.ext2_linetype_name)"
  },
  {
    "project": "mozman/ezdxf",
    "commit": "0bb5f0cb7d8d87713e4ae046600ee7ce47a21026",
    "filename": "src/ezdxf/render/dim_linear.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/mozman-ezdxf/src/ezdxf/render/dim_linear.py",
    "file_hunks_size": 47,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": true,
    "full_warning_msg": "src/ezdxf/render/dim_linear.py:333:34 Incompatible parameter type [6]: Expected `str` for 1st positional only parameter to call `BaseDimensionRenderer.add_blockref` but got `typing.Optional[str]`.",
    "message": " Expected `str` for 1st positional only parameter to call `BaseDimensionRenderer.add_blockref` but got `typing.Optional[str]`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 333,
    "warning_line": "                self.add_blockref(self.arrow1_name, insert=start, scale=scale, rotation=start_angle,",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": true,
        "source_code": "            if arrow1:\n                self.add_blockref(self.arrow1_name, insert=start, scale=scale, rotation=start_angle,\n                                  dxfattribs=attribs)  # reverse\n            if arrow2:\n                self.add_blockref(self.arrow2_name, insert=end, scale=scale, rotation=end_angle, dxfattribs=attribs)\n\n            if not outside:\n                # arrows inside extension lines: adjust connection points for the remaining dimension line\n                if arrow1:\n                    start = connection_point(self.arrow1_name, start, scale, start_angle)\n                if arrow2:\n                    end = connection_point(self.arrow2_name, end, scale, end_angle)\n            else:\n                # add additional extension lines to arrows placed outside of dimension extension lines\n                self.add_arrow_extension_lines()\n",
        "source_code_len": 863,
        "target_code": "            if arrow1:\n                self.add_blockref(\n                    self.arrow1_name,  # type: ignore\n                    insert=start,\n                    scale=scale,\n                    rotation=start_angle,\n                    dxfattribs=attribs,\n                )  # reverse\n            if arrow2:\n                self.add_blockref(\n                    self.arrow2_name,  # type: ignore\n                    insert=end,\n                    scale=scale,\n                    rotation=end_angle,\n                    dxfattribs=attribs,\n                )\n\n            if not outside:\n                # arrows inside extension lines: adjust connection points for\n                # the remaining dimension line\n                if arrow1:\n                    start = connection_point(\n                        self.arrow1_name, start, scale, start_angle  # type: ignore\n                    )\n                if arrow2:\n                    end = connection_point(\n                        self.arrow2_name, end, scale, end_angle  # type: ignore\n                    )\n            else:\n                # add additional extension lines to arrows placed outside of\n                # dimension extension lines\n                self.add_arrow_extension_lines()\n",
        "target_code_len": 1259,
        "diff_format": "@@ -332,15 +410,32 @@\n             if arrow1:\n-                self.add_blockref(self.arrow1_name, insert=start, scale=scale, rotation=start_angle,\n-                                  dxfattribs=attribs)  # reverse\n+                self.add_blockref(\n+                    self.arrow1_name,  # type: ignore\n+                    insert=start,\n+                    scale=scale,\n+                    rotation=start_angle,\n+                    dxfattribs=attribs,\n+                )  # reverse\n             if arrow2:\n-                self.add_blockref(self.arrow2_name, insert=end, scale=scale, rotation=end_angle, dxfattribs=attribs)\n+                self.add_blockref(\n+                    self.arrow2_name,  # type: ignore\n+                    insert=end,\n+                    scale=scale,\n+                    rotation=end_angle,\n+                    dxfattribs=attribs,\n+                )\n \n             if not outside:\n-                # arrows inside extension lines: adjust connection points for the remaining dimension line\n+                # arrows inside extension lines: adjust connection points for\n+                # the remaining dimension line\n                 if arrow1:\n-                    start = connection_point(self.arrow1_name, start, scale, start_angle)\n+                    start = connection_point(\n+                        self.arrow1_name, start, scale, start_angle  # type: ignore\n+                    )\n                 if arrow2:\n-                    end = connection_point(self.arrow2_name, end, scale, end_angle)\n+                    end = connection_point(\n+                        self.arrow2_name, end, scale, end_angle  # type: ignore\n+                    )\n             else:\n-                # add additional extension lines to arrows placed outside of dimension extension lines\n+                # add additional extension lines to arrows placed outside of\n+                # dimension extension lines\n                 self.add_arrow_extension_lines()\n",
        "source_code_with_indent": "            <DED>if arrow1:\n                <IND>self.add_blockref(self.arrow1_name, insert=start, scale=scale, rotation=start_angle,\n                                  dxfattribs=attribs)  # reverse\n            <DED>if arrow2:\n                <IND>self.add_blockref(self.arrow2_name, insert=end, scale=scale, rotation=end_angle, dxfattribs=attribs)\n\n            <DED>if not outside:\n                # arrows inside extension lines: adjust connection points for the remaining dimension line\n                <IND>if arrow1:\n                    <IND>start = connection_point(self.arrow1_name, start, scale, start_angle)\n                <DED>if arrow2:\n                    <IND>end = connection_point(self.arrow2_name, end, scale, end_angle)\n            <DED><DED>else:\n                # add additional extension lines to arrows placed outside of dimension extension lines\n                <IND>self.add_arrow_extension_lines()\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "            <DED>if arrow1:\n                <IND>self.add_blockref(\n                    self.arrow1_name,  # type: ignore\n                    insert=start,\n                    scale=scale,\n                    rotation=start_angle,\n                    dxfattribs=attribs,\n                )  # reverse\n            <DED>if arrow2:\n                <IND>self.add_blockref(\n                    self.arrow2_name,  # type: ignore\n                    insert=end,\n                    scale=scale,\n                    rotation=end_angle,\n                    dxfattribs=attribs,\n                )\n\n            <DED>if not outside:\n                # arrows inside extension lines: adjust connection points for\n                # the remaining dimension line\n                <IND>if arrow1:\n                    <IND>start = connection_point(\n                        self.arrow1_name, start, scale, start_angle  # type: ignore\n                    )\n                <DED>if arrow2:\n                    <IND>end = connection_point(\n                        self.arrow2_name, end, scale, end_angle  # type: ignore\n                    )\n            <DED><DED>else:\n                # add additional extension lines to arrows placed outside of\n                # dimension extension lines\n                <IND>self.add_arrow_extension_lines()\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "mozman/ezdxf",
    "commit": "0bb5f0cb7d8d87713e4ae046600ee7ce47a21026",
    "filename": "src/ezdxf/render/dim_linear.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/mozman-ezdxf/src/ezdxf/render/dim_linear.py",
    "file_hunks_size": 47,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": true,
    "full_warning_msg": "src/ezdxf/render/dim_linear.py:336:34 Incompatible parameter type [6]: Expected `str` for 1st positional only parameter to call `BaseDimensionRenderer.add_blockref` but got `typing.Optional[str]`.",
    "message": " Expected `str` for 1st positional only parameter to call `BaseDimensionRenderer.add_blockref` but got `typing.Optional[str]`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 336,
    "warning_line": "                self.add_blockref(self.arrow2_name, insert=end, scale=scale, rotation=end_angle, dxfattribs=attribs)",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": true,
        "source_code": "            if arrow1:\n                self.add_blockref(self.arrow1_name, insert=start, scale=scale, rotation=start_angle,\n                                  dxfattribs=attribs)  # reverse\n            if arrow2:\n                self.add_blockref(self.arrow2_name, insert=end, scale=scale, rotation=end_angle, dxfattribs=attribs)\n\n            if not outside:\n                # arrows inside extension lines: adjust connection points for the remaining dimension line\n                if arrow1:\n                    start = connection_point(self.arrow1_name, start, scale, start_angle)\n                if arrow2:\n                    end = connection_point(self.arrow2_name, end, scale, end_angle)\n            else:\n                # add additional extension lines to arrows placed outside of dimension extension lines\n                self.add_arrow_extension_lines()\n",
        "source_code_len": 863,
        "target_code": "            if arrow1:\n                self.add_blockref(\n                    self.arrow1_name,  # type: ignore\n                    insert=start,\n                    scale=scale,\n                    rotation=start_angle,\n                    dxfattribs=attribs,\n                )  # reverse\n            if arrow2:\n                self.add_blockref(\n                    self.arrow2_name,  # type: ignore\n                    insert=end,\n                    scale=scale,\n                    rotation=end_angle,\n                    dxfattribs=attribs,\n                )\n\n            if not outside:\n                # arrows inside extension lines: adjust connection points for\n                # the remaining dimension line\n                if arrow1:\n                    start = connection_point(\n                        self.arrow1_name, start, scale, start_angle  # type: ignore\n                    )\n                if arrow2:\n                    end = connection_point(\n                        self.arrow2_name, end, scale, end_angle  # type: ignore\n                    )\n            else:\n                # add additional extension lines to arrows placed outside of\n                # dimension extension lines\n                self.add_arrow_extension_lines()\n",
        "target_code_len": 1259,
        "diff_format": "@@ -332,15 +410,32 @@\n             if arrow1:\n-                self.add_blockref(self.arrow1_name, insert=start, scale=scale, rotation=start_angle,\n-                                  dxfattribs=attribs)  # reverse\n+                self.add_blockref(\n+                    self.arrow1_name,  # type: ignore\n+                    insert=start,\n+                    scale=scale,\n+                    rotation=start_angle,\n+                    dxfattribs=attribs,\n+                )  # reverse\n             if arrow2:\n-                self.add_blockref(self.arrow2_name, insert=end, scale=scale, rotation=end_angle, dxfattribs=attribs)\n+                self.add_blockref(\n+                    self.arrow2_name,  # type: ignore\n+                    insert=end,\n+                    scale=scale,\n+                    rotation=end_angle,\n+                    dxfattribs=attribs,\n+                )\n \n             if not outside:\n-                # arrows inside extension lines: adjust connection points for the remaining dimension line\n+                # arrows inside extension lines: adjust connection points for\n+                # the remaining dimension line\n                 if arrow1:\n-                    start = connection_point(self.arrow1_name, start, scale, start_angle)\n+                    start = connection_point(\n+                        self.arrow1_name, start, scale, start_angle  # type: ignore\n+                    )\n                 if arrow2:\n-                    end = connection_point(self.arrow2_name, end, scale, end_angle)\n+                    end = connection_point(\n+                        self.arrow2_name, end, scale, end_angle  # type: ignore\n+                    )\n             else:\n-                # add additional extension lines to arrows placed outside of dimension extension lines\n+                # add additional extension lines to arrows placed outside of\n+                # dimension extension lines\n                 self.add_arrow_extension_lines()\n",
        "source_code_with_indent": "            <DED>if arrow1:\n                <IND>self.add_blockref(self.arrow1_name, insert=start, scale=scale, rotation=start_angle,\n                                  dxfattribs=attribs)  # reverse\n            <DED>if arrow2:\n                <IND>self.add_blockref(self.arrow2_name, insert=end, scale=scale, rotation=end_angle, dxfattribs=attribs)\n\n            <DED>if not outside:\n                # arrows inside extension lines: adjust connection points for the remaining dimension line\n                <IND>if arrow1:\n                    <IND>start = connection_point(self.arrow1_name, start, scale, start_angle)\n                <DED>if arrow2:\n                    <IND>end = connection_point(self.arrow2_name, end, scale, end_angle)\n            <DED><DED>else:\n                # add additional extension lines to arrows placed outside of dimension extension lines\n                <IND>self.add_arrow_extension_lines()\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "            <DED>if arrow1:\n                <IND>self.add_blockref(\n                    self.arrow1_name,  # type: ignore\n                    insert=start,\n                    scale=scale,\n                    rotation=start_angle,\n                    dxfattribs=attribs,\n                )  # reverse\n            <DED>if arrow2:\n                <IND>self.add_blockref(\n                    self.arrow2_name,  # type: ignore\n                    insert=end,\n                    scale=scale,\n                    rotation=end_angle,\n                    dxfattribs=attribs,\n                )\n\n            <DED>if not outside:\n                # arrows inside extension lines: adjust connection points for\n                # the remaining dimension line\n                <IND>if arrow1:\n                    <IND>start = connection_point(\n                        self.arrow1_name, start, scale, start_angle  # type: ignore\n                    )\n                <DED>if arrow2:\n                    <IND>end = connection_point(\n                        self.arrow2_name, end, scale, end_angle  # type: ignore\n                    )\n            <DED><DED>else:\n                # add additional extension lines to arrows placed outside of\n                # dimension extension lines\n                <IND>self.add_arrow_extension_lines()\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "mozman/ezdxf",
    "commit": "0bb5f0cb7d8d87713e4ae046600ee7ce47a21026",
    "filename": "src/ezdxf/render/dim_linear.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/mozman-ezdxf/src/ezdxf/render/dim_linear.py",
    "file_hunks_size": 47,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "src/ezdxf/render/dim_linear.py:458:34 Incompatible parameter type [6]: Expected `int` for 2nd positional only parameter to call `dict.__setitem__` but got `str`.",
    "message": " Expected `int` for 2nd positional only parameter to call `dict.__setitem__` but got `str`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 458,
    "warning_line": "            attribs['linetype'] = linetype"
  },
  {
    "project": "mozman/ezdxf",
    "commit": "0bb5f0cb7d8d87713e4ae046600ee7ce47a21026",
    "filename": "src/ezdxf/render/dim_linear.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/mozman-ezdxf/src/ezdxf/render/dim_linear.py",
    "file_hunks_size": 47,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "src/ezdxf/render/dim_linear.py:518:8 Incompatible variable type [9]: override is declared to have type `typing.Dict[typing.Any, typing.Any]` but is used as type `None`.",
    "message": " override is declared to have type `typing.Dict[typing.Any, typing.Any]` but is used as type `None`.",
    "rule_id": "Incompatible variable type [9]",
    "warning_line_no": 518,
    "warning_line": "        override: dict = None,"
  },
  {
    "project": "mozman/ezdxf",
    "commit": "0bb5f0cb7d8d87713e4ae046600ee7ce47a21026",
    "filename": "src/ezdxf/render/dim_linear.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/mozman-ezdxf/src/ezdxf/render/dim_linear.py",
    "file_hunks_size": 47,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "src/ezdxf/render/dim_linear.py:519:8 Incompatible variable type [9]: dxfattribs is declared to have type `typing.Dict[typing.Any, typing.Any]` but is used as type `None`.",
    "message": " dxfattribs is declared to have type `typing.Dict[typing.Any, typing.Any]` but is used as type `None`.",
    "rule_id": "Incompatible variable type [9]",
    "warning_line_no": 519,
    "warning_line": "        dxfattribs: dict = None,"
  }
]