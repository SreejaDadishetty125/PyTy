[
  {
    "project": "Devoxin/Lavalink.py",
    "commit": "b306fc72aecb8c4ebf4c196606ad1d641d742e29",
    "filename": "examples/music.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/Devoxin-Lavalink.py/examples/music.py",
    "file_hunks_size": 6,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "examples/music.py:188:32 Incompatible variable type [9]: volume is declared to have type `int` but is used as type `None`.",
    "message": " volume is declared to have type `int` but is used as type `None`.",
    "rule_id": "Incompatible variable type [9]",
    "warning_line_no": 188,
    "warning_line": "    async def volume(self, ctx, volume: int = None):",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n    async def track_hook(self, event):\n        if isinstance(event, lavalink.events.QueueEndEvent):\n            guild_id = int(event.player.guild_id)\n            await self.connect_to(guild_id, None)\n            # Disconnect from the channel -- there's nothing else to play.\n\n    async def connect_to(self, guild_id: int, channel_id: str):\n        \"\"\" Connects to the given voicechannel ID. A channel_id of `None` means disconnect. \"\"\"\n        ws = self.bot._connection._get_websocket(guild_id)\n        await ws.voice_state(str(guild_id), channel_id)\n        # The above looks dirty, we could alternatively use `bot.shards[shard_id].ws` but that assumes\n        # the bot instance is an AutoShardedBot.\n\n    @commands.command(aliases=['p'])\n    async def play(self, ctx, *, query: str):\n        \"\"\" Searches and plays a song from a given query. \"\"\"\n        player = self.bot.lavalink.players.get(ctx.guild.id)\n\n        query = query.strip('<>')\n\n        if not url_rx.match(query):\n            query = f'ytsearch:{query}'\n\n        results = await player.node.get_tracks(query)\n\n        if not results or not results['tracks']:\n            return await ctx.send('Nothing found!')\n\n        embed = discord.Embed(color=discord.Color.blurple())\n\n        if results['loadType'] == 'PLAYLIST_LOADED':\n            tracks = results['tracks']\n\n            for track in tracks:\n                player.add(requester=ctx.author.id, track=track)\n\n            embed.title = 'Playlist Enqueued!'\n            embed.description = f'{results[\"playlistInfo\"][\"name\"]} - {len(tracks)} tracks'\n        else:\n            track = results['tracks'][0]\n            embed.title = 'Track Enqueued'\n            embed.description = f'[{track[\"info\"][\"title\"]}]({track[\"info\"][\"uri\"]})'\n            player.add(requester=ctx.author.id, track=track)\n\n        await ctx.send(embed=embed)\n\n        if not player.is_playing:\n            await player.play()\n\n    @commands.command()\n    async def seek(self, ctx, *, seconds: int):\n        \"\"\" Seeks to a given position in a track. \"\"\"\n        player = self.bot.lavalink.players.get(ctx.guild.id)\n\n        track_time = player.position + (seconds * 1000)\n        await player.seek(track_time)\n\n        await ctx.send(f'Moved track to **{lavalink.utils.format_time(track_time)}**')\n\n    @commands.command(aliases=['forceskip'])\n    async def skip(self, ctx):\n        \"\"\" Skips the current track. \"\"\"\n        player = self.bot.lavalink.players.get(ctx.guild.id)\n\n        if not player.is_playing:\n            return await ctx.send('Not playing.')\n\n        await player.skip()\n        await ctx.send('\u23ed | Skipped.')\n\n    @commands.command()\n    async def stop(self, ctx):\n        \"\"\" Stops the player and clears its queue. \"\"\"\n        player = self.bot.lavalink.players.get(ctx.guild.id)\n\n        if not player.is_playing:\n            return await ctx.send('Not playing.')\n\n        player.queue.clear()\n        await player.stop()\n        await ctx.send('\u23f9 | Stopped.')\n\n    @commands.command(aliases=['np', 'n', 'playing'])\n    async def now(self, ctx):\n        \"\"\" Shows some stats about the currently playing song. \"\"\"\n        player = self.bot.lavalink.players.get(ctx.guild.id)\n\n        if not player.current:\n            return await ctx.send('Nothing playing.')\n\n        position = lavalink.utils.format_time(player.position)\n        if player.current.stream:\n            duration = '\ud83d\udd34 LIVE'\n        else:\n            duration = lavalink.utils.format_time(player.current.duration)\n        song = f'**[{player.current.title}]({player.current.uri})**\\n({position}/{duration})'\n\n        embed = discord.Embed(color=discord.Color.blurple(),\n                              title='Now Playing', description=song)\n        await ctx.send(embed=embed)\n\n    @commands.command(aliases=['q'])\n    async def queue(self, ctx, page: int = 1):\n        \"\"\" Shows the player's queue. \"\"\"\n        player = self.bot.lavalink.players.get(ctx.guild.id)\n\n        if not player.queue:\n            return await ctx.send('Nothing queued.')\n\n        items_per_page = 10\n        pages = math.ceil(len(player.queue) / items_per_page)\n\n        start = (page - 1) * items_per_page\n        end = start + items_per_page\n\n        queue_list = ''\n        for index, track in enumerate(player.queue[start:end], start=start):\n            queue_list += f'`{index + 1}.` [**{track.title}**]({track.uri})\\n'\n\n        embed = discord.Embed(colour=discord.Color.blurple(),\n                              description=f'**{len(player.queue)} tracks**\\n\\n{queue_list}')\n        embed.set_footer(text=f'Viewing page {page}/{pages}')\n        await ctx.send(embed=embed)\n\n    @commands.command(aliases=['resume'])\n    async def pause(self, ctx):\n        \"\"\" Pauses/Resumes the current track. \"\"\"\n        player = self.bot.lavalink.players.get(ctx.guild.id)\n\n        if not player.is_playing:\n            return await ctx.send('Not playing.')\n\n        if player.paused:\n            await player.set_pause(False)\n            await ctx.send('\u23ef | Resumed')\n        else:\n            await player.set_pause(True)\n            await ctx.send('\u23ef | Paused')\n\n    @commands.command(aliases=['vol'])\n    async def volume(self, ctx, volume: int = None):\n        \"\"\" Changes the player's volume (0-1000). \"\"\"\n        player = self.bot.lavalink.players.get(ctx.guild.id)\n\n        if not volume:\n            return await ctx.send(f'\ud83d\udd08 | {player.volume}%')\n\n        await player.set_volume(volume)  # Lavalink will automatically cap values between, or equal to 0-1000.\n        await ctx.send(f'\ud83d\udd08 | Set to {player.volume}%')\n\n    @commands.command()\n    async def shuffle(self, ctx):\n        \"\"\" Shuffles the player's queue. \"\"\"\n        player = self.bot.lavalink.players.get(ctx.guild.id)\n        if not player.is_playing:\n            return await ctx.send('Nothing playing.')\n\n        player.shuffle = not player.shuffle\n        await ctx.send('\ud83d\udd00 | Shuffle ' + ('enabled' if player.shuffle else 'disabled'))\n\n    @commands.command(aliases=['loop'])\n    async def repeat(self, ctx):\n        \"\"\" Repeats the current song until the command is invoked again. \"\"\"\n        player = self.bot.lavalink.players.get(ctx.guild.id)\n\n        if not player.is_playing:\n            return await ctx.send('Nothing playing.')\n\n        player.repeat = not player.repeat\n        await ctx.send('\ud83d\udd01 | Repeat ' + ('enabled' if player.repeat else 'disabled'))\n\n    @commands.command()\n    async def remove(self, ctx, index: int):\n        \"\"\" Removes an item from the player's queue with the given index. \"\"\"\n        player = self.bot.lavalink.players.get(ctx.guild.id)\n\n        if not player.queue:\n            return await ctx.send('Nothing queued.')\n\n        if index > len(player.queue) or index < 1:\n            return await ctx.send(f'Index has to be **between** 1 and {len(player.queue)}')\n\n        removed = player.queue.pop(index - 1)  # Account for 0-index.\n\n        await ctx.send(f'Removed **{removed.title}** from the queue.')\n\n    @commands.command()\n    async def find(self, ctx, *, query):\n        \"\"\" Lists the first 10 search results from a given query. \"\"\"\n        player = self.bot.lavalink.players.get(ctx.guild.id)\n\n        if not query.startswith('ytsearch:') and not query.startswith('scsearch:'):\n            query = 'ytsearch:' + query\n\n        results = await player.node.get_tracks(query)\n\n        if not results or not results['tracks']:\n            return await ctx.send('Nothing found.')\n\n        tracks = results['tracks'][:10]  # First 10 results\n\n        o = ''\n        for index, track in enumerate(tracks, start=1):\n            track_title = track['info']['title']\n            track_uri = track['info']['uri']\n            o += f'`{index}.` [{track_title}]({track_uri})\\n'\n\n        embed = discord.Embed(color=discord.Color.blurple(), description=o)\n        await ctx.send(embed=embed)\n\n    @commands.command(aliases=['dc'])\n    async def disconnect(self, ctx):\n        \"\"\" Disconnects the player from the voice channel and clears its queue. \"\"\"\n        player = self.bot.lavalink.players.get(ctx.guild.id)\n\n        if not player.is_connected:\n            return await ctx.send('Not connected.')\n\n        if not ctx.author.voice or (player.is_connected and ctx.author.voice.channel.id != int(player.channel_id)):\n            return await ctx.send('You\\'re not in my voicechannel!')\n\n        player.queue.clear()\n        await player.stop()\n        await self.connect_to(ctx.guild.id, None)\n        await ctx.send('*\u20e3 | Disconnected.')\n\n    async def ensure_voice(self, ctx):\n        \"\"\" This check ensures that the bot and command author are in the same voicechannel. \"\"\"\n        player = self.bot.lavalink.players.create(ctx.guild.id, endpoint=str(ctx.guild.region))\n        # Create returns a player if one exists, otherwise creates.\n\n        should_connect = ctx.command.name in ('play')  # Add commands that require joining voice to work.\n\n        if not ctx.author.voice or not ctx.author.voice.channel:\n            raise commands.CommandInvokeError('Join a voicechannel first.')\n",
        "source_code_len": 9047,
        "target_code": "\n    async def ensure_voice(self, ctx):\n        \"\"\" This check ensures that the bot and command author are in the same voicechannel. \"\"\"\n        player = self.bot.lavalink.player_manager.create(ctx.guild.id, endpoint=str(ctx.guild.region))\n        # Create returns a player if one exists, otherwise creates.\n        # This line is important because it ensures that a player always exists for a guild.\n\n        # Most people might consider this a waste of resources for guilds that aren't playing, but this is\n        # the easiest and simplest way of ensuring players are created.\n\n        # These are commands that require the bot to join a voicechannel (i.e. initiating playback).\n        # Commands such as volume/skip etc don't require the bot to be in a voicechannel so don't need listing here.\n        should_connect = ctx.command.name in ('play',)\n\n        if not ctx.author.voice or not ctx.author.voice.channel:\n            # Our cog_command_error handler catches this and sends it to the voicechannel.\n            # Exceptions allow us to \"short-circuit\" command invocation via checks so the\n            # execution state of the command goes no further.\n            raise commands.CommandInvokeError('Join a voicechannel first.')\n",
        "target_code_len": 1240,
        "diff_format": "@@ -47,236 +52,19 @@\n \n-    async def track_hook(self, event):\n-        if isinstance(event, lavalink.events.QueueEndEvent):\n-            guild_id = int(event.player.guild_id)\n-            await self.connect_to(guild_id, None)\n-            # Disconnect from the channel -- there's nothing else to play.\n-\n-    async def connect_to(self, guild_id: int, channel_id: str):\n-        \"\"\" Connects to the given voicechannel ID. A channel_id of `None` means disconnect. \"\"\"\n-        ws = self.bot._connection._get_websocket(guild_id)\n-        await ws.voice_state(str(guild_id), channel_id)\n-        # The above looks dirty, we could alternatively use `bot.shards[shard_id].ws` but that assumes\n-        # the bot instance is an AutoShardedBot.\n-\n-    @commands.command(aliases=['p'])\n-    async def play(self, ctx, *, query: str):\n-        \"\"\" Searches and plays a song from a given query. \"\"\"\n-        player = self.bot.lavalink.players.get(ctx.guild.id)\n-\n-        query = query.strip('<>')\n-\n-        if not url_rx.match(query):\n-            query = f'ytsearch:{query}'\n-\n-        results = await player.node.get_tracks(query)\n-\n-        if not results or not results['tracks']:\n-            return await ctx.send('Nothing found!')\n-\n-        embed = discord.Embed(color=discord.Color.blurple())\n-\n-        if results['loadType'] == 'PLAYLIST_LOADED':\n-            tracks = results['tracks']\n-\n-            for track in tracks:\n-                player.add(requester=ctx.author.id, track=track)\n-\n-            embed.title = 'Playlist Enqueued!'\n-            embed.description = f'{results[\"playlistInfo\"][\"name\"]} - {len(tracks)} tracks'\n-        else:\n-            track = results['tracks'][0]\n-            embed.title = 'Track Enqueued'\n-            embed.description = f'[{track[\"info\"][\"title\"]}]({track[\"info\"][\"uri\"]})'\n-            player.add(requester=ctx.author.id, track=track)\n-\n-        await ctx.send(embed=embed)\n-\n-        if not player.is_playing:\n-            await player.play()\n-\n-    @commands.command()\n-    async def seek(self, ctx, *, seconds: int):\n-        \"\"\" Seeks to a given position in a track. \"\"\"\n-        player = self.bot.lavalink.players.get(ctx.guild.id)\n-\n-        track_time = player.position + (seconds * 1000)\n-        await player.seek(track_time)\n-\n-        await ctx.send(f'Moved track to **{lavalink.utils.format_time(track_time)}**')\n-\n-    @commands.command(aliases=['forceskip'])\n-    async def skip(self, ctx):\n-        \"\"\" Skips the current track. \"\"\"\n-        player = self.bot.lavalink.players.get(ctx.guild.id)\n-\n-        if not player.is_playing:\n-            return await ctx.send('Not playing.')\n-\n-        await player.skip()\n-        await ctx.send('\u23ed | Skipped.')\n-\n-    @commands.command()\n-    async def stop(self, ctx):\n-        \"\"\" Stops the player and clears its queue. \"\"\"\n-        player = self.bot.lavalink.players.get(ctx.guild.id)\n-\n-        if not player.is_playing:\n-            return await ctx.send('Not playing.')\n-\n-        player.queue.clear()\n-        await player.stop()\n-        await ctx.send('\u23f9 | Stopped.')\n-\n-    @commands.command(aliases=['np', 'n', 'playing'])\n-    async def now(self, ctx):\n-        \"\"\" Shows some stats about the currently playing song. \"\"\"\n-        player = self.bot.lavalink.players.get(ctx.guild.id)\n-\n-        if not player.current:\n-            return await ctx.send('Nothing playing.')\n-\n-        position = lavalink.utils.format_time(player.position)\n-        if player.current.stream:\n-            duration = '\ud83d\udd34 LIVE'\n-        else:\n-            duration = lavalink.utils.format_time(player.current.duration)\n-        song = f'**[{player.current.title}]({player.current.uri})**\\n({position}/{duration})'\n-\n-        embed = discord.Embed(color=discord.Color.blurple(),\n-                              title='Now Playing', description=song)\n-        await ctx.send(embed=embed)\n-\n-    @commands.command(aliases=['q'])\n-    async def queue(self, ctx, page: int = 1):\n-        \"\"\" Shows the player's queue. \"\"\"\n-        player = self.bot.lavalink.players.get(ctx.guild.id)\n-\n-        if not player.queue:\n-            return await ctx.send('Nothing queued.')\n-\n-        items_per_page = 10\n-        pages = math.ceil(len(player.queue) / items_per_page)\n-\n-        start = (page - 1) * items_per_page\n-        end = start + items_per_page\n-\n-        queue_list = ''\n-        for index, track in enumerate(player.queue[start:end], start=start):\n-            queue_list += f'`{index + 1}.` [**{track.title}**]({track.uri})\\n'\n-\n-        embed = discord.Embed(colour=discord.Color.blurple(),\n-                              description=f'**{len(player.queue)} tracks**\\n\\n{queue_list}')\n-        embed.set_footer(text=f'Viewing page {page}/{pages}')\n-        await ctx.send(embed=embed)\n-\n-    @commands.command(aliases=['resume'])\n-    async def pause(self, ctx):\n-        \"\"\" Pauses/Resumes the current track. \"\"\"\n-        player = self.bot.lavalink.players.get(ctx.guild.id)\n-\n-        if not player.is_playing:\n-            return await ctx.send('Not playing.')\n-\n-        if player.paused:\n-            await player.set_pause(False)\n-            await ctx.send('\u23ef | Resumed')\n-        else:\n-            await player.set_pause(True)\n-            await ctx.send('\u23ef | Paused')\n-\n-    @commands.command(aliases=['vol'])\n-    async def volume(self, ctx, volume: int = None):\n-        \"\"\" Changes the player's volume (0-1000). \"\"\"\n-        player = self.bot.lavalink.players.get(ctx.guild.id)\n-\n-        if not volume:\n-            return await ctx.send(f'\ud83d\udd08 | {player.volume}%')\n-\n-        await player.set_volume(volume)  # Lavalink will automatically cap values between, or equal to 0-1000.\n-        await ctx.send(f'\ud83d\udd08 | Set to {player.volume}%')\n-\n-    @commands.command()\n-    async def shuffle(self, ctx):\n-        \"\"\" Shuffles the player's queue. \"\"\"\n-        player = self.bot.lavalink.players.get(ctx.guild.id)\n-        if not player.is_playing:\n-            return await ctx.send('Nothing playing.')\n-\n-        player.shuffle = not player.shuffle\n-        await ctx.send('\ud83d\udd00 | Shuffle ' + ('enabled' if player.shuffle else 'disabled'))\n-\n-    @commands.command(aliases=['loop'])\n-    async def repeat(self, ctx):\n-        \"\"\" Repeats the current song until the command is invoked again. \"\"\"\n-        player = self.bot.lavalink.players.get(ctx.guild.id)\n-\n-        if not player.is_playing:\n-            return await ctx.send('Nothing playing.')\n-\n-        player.repeat = not player.repeat\n-        await ctx.send('\ud83d\udd01 | Repeat ' + ('enabled' if player.repeat else 'disabled'))\n-\n-    @commands.command()\n-    async def remove(self, ctx, index: int):\n-        \"\"\" Removes an item from the player's queue with the given index. \"\"\"\n-        player = self.bot.lavalink.players.get(ctx.guild.id)\n-\n-        if not player.queue:\n-            return await ctx.send('Nothing queued.')\n-\n-        if index > len(player.queue) or index < 1:\n-            return await ctx.send(f'Index has to be **between** 1 and {len(player.queue)}')\n-\n-        removed = player.queue.pop(index - 1)  # Account for 0-index.\n-\n-        await ctx.send(f'Removed **{removed.title}** from the queue.')\n-\n-    @commands.command()\n-    async def find(self, ctx, *, query):\n-        \"\"\" Lists the first 10 search results from a given query. \"\"\"\n-        player = self.bot.lavalink.players.get(ctx.guild.id)\n-\n-        if not query.startswith('ytsearch:') and not query.startswith('scsearch:'):\n-            query = 'ytsearch:' + query\n-\n-        results = await player.node.get_tracks(query)\n-\n-        if not results or not results['tracks']:\n-            return await ctx.send('Nothing found.')\n-\n-        tracks = results['tracks'][:10]  # First 10 results\n-\n-        o = ''\n-        for index, track in enumerate(tracks, start=1):\n-            track_title = track['info']['title']\n-            track_uri = track['info']['uri']\n-            o += f'`{index}.` [{track_title}]({track_uri})\\n'\n-\n-        embed = discord.Embed(color=discord.Color.blurple(), description=o)\n-        await ctx.send(embed=embed)\n-\n-    @commands.command(aliases=['dc'])\n-    async def disconnect(self, ctx):\n-        \"\"\" Disconnects the player from the voice channel and clears its queue. \"\"\"\n-        player = self.bot.lavalink.players.get(ctx.guild.id)\n-\n-        if not player.is_connected:\n-            return await ctx.send('Not connected.')\n-\n-        if not ctx.author.voice or (player.is_connected and ctx.author.voice.channel.id != int(player.channel_id)):\n-            return await ctx.send('You\\'re not in my voicechannel!')\n-\n-        player.queue.clear()\n-        await player.stop()\n-        await self.connect_to(ctx.guild.id, None)\n-        await ctx.send('*\u20e3 | Disconnected.')\n-\n     async def ensure_voice(self, ctx):\n         \"\"\" This check ensures that the bot and command author are in the same voicechannel. \"\"\"\n-        player = self.bot.lavalink.players.create(ctx.guild.id, endpoint=str(ctx.guild.region))\n+        player = self.bot.lavalink.player_manager.create(ctx.guild.id, endpoint=str(ctx.guild.region))\n         # Create returns a player if one exists, otherwise creates.\n+        # This line is important because it ensures that a player always exists for a guild.\n \n-        should_connect = ctx.command.name in ('play')  # Add commands that require joining voice to work.\n+        # Most people might consider this a waste of resources for guilds that aren't playing, but this is\n+        # the easiest and simplest way of ensuring players are created.\n+\n+        # These are commands that require the bot to join a voicechannel (i.e. initiating playback).\n+        # Commands such as volume/skip etc don't require the bot to be in a voicechannel so don't need listing here.\n+        should_connect = ctx.command.name in ('play',)\n \n         if not ctx.author.voice or not ctx.author.voice.channel:\n+            # Our cog_command_error handler catches this and sends it to the voicechannel.\n+            # Exceptions allow us to \"short-circuit\" command invocation via checks so the\n+            # execution state of the command goes no further.\n             raise commands.CommandInvokeError('Join a voicechannel first.')\n",
        "source_code_with_indent": "\n    <DED><DED>async def track_hook(self, event):\n        <IND>if isinstance(event, lavalink.events.QueueEndEvent):\n            <IND>guild_id = int(event.player.guild_id)\n            await self.connect_to(guild_id, None)\n            # Disconnect from the channel -- there's nothing else to play.\n\n    <DED><DED>async def connect_to(self, guild_id: int, channel_id: str):\n        <IND>\"\"\" Connects to the given voicechannel ID. A channel_id of `None` means disconnect. \"\"\"\n        ws = self.bot._connection._get_websocket(guild_id)\n        await ws.voice_state(str(guild_id), channel_id)\n        # The above looks dirty, we could alternatively use `bot.shards[shard_id].ws` but that assumes\n        # the bot instance is an AutoShardedBot.\n\n    <DED>@commands.command(aliases=['p'])\n    async def play(self, ctx, *, query: str):\n        <IND>\"\"\" Searches and plays a song from a given query. \"\"\"\n        player = self.bot.lavalink.players.get(ctx.guild.id)\n\n        query = query.strip('<>')\n\n        if not url_rx.match(query):\n            <IND>query = f'ytsearch:{query}'\n\n        <DED>results = await player.node.get_tracks(query)\n\n        if not results or not results['tracks']:\n            <IND>return await ctx.send('Nothing found!')\n\n        <DED>embed = discord.Embed(color=discord.Color.blurple())\n\n        if results['loadType'] == 'PLAYLIST_LOADED':\n            <IND>tracks = results['tracks']\n\n            for track in tracks:\n                <IND>player.add(requester=ctx.author.id, track=track)\n\n            <DED>embed.title = 'Playlist Enqueued!'\n            embed.description = f'{results[\"playlistInfo\"][\"name\"]} - {len(tracks)} tracks'\n        <DED>else:\n            <IND>track = results['tracks'][0]\n            embed.title = 'Track Enqueued'\n            embed.description = f'[{track[\"info\"][\"title\"]}]({track[\"info\"][\"uri\"]})'\n            player.add(requester=ctx.author.id, track=track)\n\n        <DED>await ctx.send(embed=embed)\n\n        if not player.is_playing:\n            <IND>await player.play()\n\n    <DED><DED>@commands.command()\n    async def seek(self, ctx, *, seconds: int):\n        <IND>\"\"\" Seeks to a given position in a track. \"\"\"\n        player = self.bot.lavalink.players.get(ctx.guild.id)\n\n        track_time = player.position + (seconds * 1000)\n        await player.seek(track_time)\n\n        await ctx.send(f'Moved track to **{lavalink.utils.format_time(track_time)}**')\n\n    <DED>@commands.command(aliases=['forceskip'])\n    async def skip(self, ctx):\n        <IND>\"\"\" Skips the current track. \"\"\"\n        player = self.bot.lavalink.players.get(ctx.guild.id)\n\n        if not player.is_playing:\n            <IND>return await ctx.send('Not playing.')\n\n        <DED>await player.skip()\n        await ctx.send('\u23ed | Skipped.')\n\n    <DED>@commands.command()\n    async def stop(self, ctx):\n        <IND>\"\"\" Stops the player and clears its queue. \"\"\"\n        player = self.bot.lavalink.players.get(ctx.guild.id)\n\n        if not player.is_playing:\n            <IND>return await ctx.send('Not playing.')\n\n        <DED>player.queue.clear()\n        await player.stop()\n        await ctx.send('\u23f9 | Stopped.')\n\n    <DED>@commands.command(aliases=['np', 'n', 'playing'])\n    async def now(self, ctx):\n        <IND>\"\"\" Shows some stats about the currently playing song. \"\"\"\n        player = self.bot.lavalink.players.get(ctx.guild.id)\n\n        if not player.current:\n            <IND>return await ctx.send('Nothing playing.')\n\n        <DED>position = lavalink.utils.format_time(player.position)\n        if player.current.stream:\n            <IND>duration = '\ud83d\udd34 LIVE'\n        <DED>else:\n            <IND>duration = lavalink.utils.format_time(player.current.duration)\n        <DED>song = f'**[{player.current.title}]({player.current.uri})**\\n({position}/{duration})'\n\n        embed = discord.Embed(color=discord.Color.blurple(),\n                              title='Now Playing', description=song)\n        await ctx.send(embed=embed)\n\n    <DED>@commands.command(aliases=['q'])\n    async def queue(self, ctx, page: int = 1):\n        <IND>\"\"\" Shows the player's queue. \"\"\"\n        player = self.bot.lavalink.players.get(ctx.guild.id)\n\n        if not player.queue:\n            <IND>return await ctx.send('Nothing queued.')\n\n        <DED>items_per_page = 10\n        pages = math.ceil(len(player.queue) / items_per_page)\n\n        start = (page - 1) * items_per_page\n        end = start + items_per_page\n\n        queue_list = ''\n        for index, track in enumerate(player.queue[start:end], start=start):\n            <IND>queue_list += f'`{index + 1}.` [**{track.title}**]({track.uri})\\n'\n\n        <DED>embed = discord.Embed(colour=discord.Color.blurple(),\n                              description=f'**{len(player.queue)} tracks**\\n\\n{queue_list}')\n        embed.set_footer(text=f'Viewing page {page}/{pages}')\n        await ctx.send(embed=embed)\n\n    <DED>@commands.command(aliases=['resume'])\n    async def pause(self, ctx):\n        <IND>\"\"\" Pauses/Resumes the current track. \"\"\"\n        player = self.bot.lavalink.players.get(ctx.guild.id)\n\n        if not player.is_playing:\n            <IND>return await ctx.send('Not playing.')\n\n        <DED>if player.paused:\n            <IND>await player.set_pause(False)\n            await ctx.send('\u23ef | Resumed')\n        <DED>else:\n            <IND>await player.set_pause(True)\n            await ctx.send('\u23ef | Paused')\n\n    <DED><DED>@commands.command(aliases=['vol'])\n    async def volume(self, ctx, volume: int = None):\n        <IND>\"\"\" Changes the player's volume (0-1000). \"\"\"\n        player = self.bot.lavalink.players.get(ctx.guild.id)\n\n        if not volume:\n            <IND>return await ctx.send(f'\ud83d\udd08 | {player.volume}%')\n\n        <DED>await player.set_volume(volume)  # Lavalink will automatically cap values between, or equal to 0-1000.\n        await ctx.send(f'\ud83d\udd08 | Set to {player.volume}%')\n\n    <DED>@commands.command()\n    async def shuffle(self, ctx):\n        <IND>\"\"\" Shuffles the player's queue. \"\"\"\n        player = self.bot.lavalink.players.get(ctx.guild.id)\n        if not player.is_playing:\n            <IND>return await ctx.send('Nothing playing.')\n\n        <DED>player.shuffle = not player.shuffle\n        await ctx.send('\ud83d\udd00 | Shuffle ' + ('enabled' if player.shuffle else 'disabled'))\n\n    <DED>@commands.command(aliases=['loop'])\n    async def repeat(self, ctx):\n        <IND>\"\"\" Repeats the current song until the command is invoked again. \"\"\"\n        player = self.bot.lavalink.players.get(ctx.guild.id)\n\n        if not player.is_playing:\n            <IND>return await ctx.send('Nothing playing.')\n\n        <DED>player.repeat = not player.repeat\n        await ctx.send('\ud83d\udd01 | Repeat ' + ('enabled' if player.repeat else 'disabled'))\n\n    <DED>@commands.command()\n    async def remove(self, ctx, index: int):\n        <IND>\"\"\" Removes an item from the player's queue with the given index. \"\"\"\n        player = self.bot.lavalink.players.get(ctx.guild.id)\n\n        if not player.queue:\n            <IND>return await ctx.send('Nothing queued.')\n\n        <DED>if index > len(player.queue) or index < 1:\n            <IND>return await ctx.send(f'Index has to be **between** 1 and {len(player.queue)}')\n\n        <DED>removed = player.queue.pop(index - 1)  # Account for 0-index.\n\n        await ctx.send(f'Removed **{removed.title}** from the queue.')\n\n    <DED>@commands.command()\n    async def find(self, ctx, *, query):\n        <IND>\"\"\" Lists the first 10 search results from a given query. \"\"\"\n        player = self.bot.lavalink.players.get(ctx.guild.id)\n\n        if not query.startswith('ytsearch:') and not query.startswith('scsearch:'):\n            <IND>query = 'ytsearch:' + query\n\n        <DED>results = await player.node.get_tracks(query)\n\n        if not results or not results['tracks']:\n            <IND>return await ctx.send('Nothing found.')\n\n        <DED>tracks = results['tracks'][:10]  # First 10 results\n\n        o = ''\n        for index, track in enumerate(tracks, start=1):\n            <IND>track_title = track['info']['title']\n            track_uri = track['info']['uri']\n            o += f'`{index}.` [{track_title}]({track_uri})\\n'\n\n        <DED>embed = discord.Embed(color=discord.Color.blurple(), description=o)\n        await ctx.send(embed=embed)\n\n    <DED>@commands.command(aliases=['dc'])\n    async def disconnect(self, ctx):\n        <IND>\"\"\" Disconnects the player from the voice channel and clears its queue. \"\"\"\n        player = self.bot.lavalink.players.get(ctx.guild.id)\n\n        if not player.is_connected:\n            <IND>return await ctx.send('Not connected.')\n\n        <DED>if not ctx.author.voice or (player.is_connected and ctx.author.voice.channel.id != int(player.channel_id)):\n            <IND>return await ctx.send('You\\'re not in my voicechannel!')\n\n        <DED>player.queue.clear()\n        await player.stop()\n        await self.connect_to(ctx.guild.id, None)\n        await ctx.send('*\u20e3 | Disconnected.')\n\n    <DED>async def ensure_voice(self, ctx):\n        <IND>\"\"\" This check ensures that the bot and command author are in the same voicechannel. \"\"\"\n        player = self.bot.lavalink.players.create(ctx.guild.id, endpoint=str(ctx.guild.region))\n        # Create returns a player if one exists, otherwise creates.\n\n        should_connect = ctx.command.name in ('play')  # Add commands that require joining voice to work.\n\n        if not ctx.author.voice or not ctx.author.voice.channel:\n            <IND>raise commands.CommandInvokeError('Join a voicechannel first.')\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n    <DED><DED>async def ensure_voice(self, ctx):\n        <IND>\"\"\" This check ensures that the bot and command author are in the same voicechannel. \"\"\"\n        player = self.bot.lavalink.player_manager.create(ctx.guild.id, endpoint=str(ctx.guild.region))\n        # Create returns a player if one exists, otherwise creates.\n        # This line is important because it ensures that a player always exists for a guild.\n\n        # Most people might consider this a waste of resources for guilds that aren't playing, but this is\n        # the easiest and simplest way of ensuring players are created.\n\n        # These are commands that require the bot to join a voicechannel (i.e. initiating playback).\n        # Commands such as volume/skip etc don't require the bot to be in a voicechannel so don't need listing here.\n        should_connect = ctx.command.name in ('play',)\n\n        if not ctx.author.voice or not ctx.author.voice.channel:\n            # Our cog_command_error handler catches this and sends it to the voicechannel.\n            # Exceptions allow us to \"short-circuit\" command invocation via checks so the\n            # execution state of the command goes no further.\n            <IND>raise commands.CommandInvokeError('Join a voicechannel first.')\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "Devoxin/Lavalink.py",
    "commit": "b306fc72aecb8c4ebf4c196606ad1d641d742e29",
    "filename": "lavalink/models.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/Devoxin-Lavalink.py/lavalink/models.py",
    "file_hunks_size": 27,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "lavalink/models.py:311:8 Incompatible attribute type [8]: Attribute `last_update` declared in class `DefaultPlayer` has type `int` but is used as type `float`.",
    "message": " Attribute `last_update` declared in class `DefaultPlayer` has type `int` but is used as type `float`.",
    "rule_id": "Incompatible attribute type [8]",
    "warning_line_no": 311,
    "warning_line": "        self.last_update = time() * 1000"
  },
  {
    "project": "Devoxin/Lavalink.py",
    "commit": "b306fc72aecb8c4ebf4c196606ad1d641d742e29",
    "filename": "lavalink/models.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/Devoxin-Lavalink.py/lavalink/models.py",
    "file_hunks_size": 27,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "lavalink/models.py:330:12 Incompatible attribute type [8]: Attribute `last_update` declared in class `DefaultPlayer` has type `int` but is used as type `float`.",
    "message": " Attribute `last_update` declared in class `DefaultPlayer` has type `int` but is used as type `float`.",
    "rule_id": "Incompatible attribute type [8]",
    "warning_line_no": 330,
    "warning_line": "            self.last_update = time() * 1000"
  }
]