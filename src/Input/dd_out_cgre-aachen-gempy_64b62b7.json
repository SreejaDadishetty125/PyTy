[
  {
    "project": "cgre-aachen/gempy",
    "commit": "64b62b795c5b0fec48784ca0fc734310b1461ada",
    "filename": "gempy/core/data.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/cgre-aachen-gempy/gempy/core/data.py",
    "file_hunks_size": 46,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": true,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "gempy/core/data.py:2646:34 Incompatible variable type [9]: additional_data is declared to have type `AdditionalData` but is used as type `None`.",
    "message": " additional_data is declared to have type `AdditionalData` but is used as type `None`.",
    "rule_id": "Incompatible variable type [9]",
    "warning_line_no": 2646,
    "warning_line": "    def create_theano_graph(self, additional_data: AdditionalData = None, inplace=True):",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": true,
        "has_suppression": false,
        "source_code": "        self.edges[formation_name] = edges\n\n\nclass Interpolator(object):\n    \"\"\"\n    Class that act as:\n     1) linker between the data objects and the theano graph\n     2) container of theano graphs + shared variables\n     3) container of theano function\n\n     Attributes:\n        interfaces (Interfaces)\n        orientaions (Orientations)\n        grid (GridClass)\n        formations (Formations)\n        faults (Faults)\n        additional_data (AdditionalData)\n        dtype (['float32', 'float64']): float precision\n        input_matrices (list[arrays])\n            - dip positions XYZ\n            - dip angles\n            - azimuth\n            - polarity\n            - interfaces coordinates XYZ\n\n        theano_graph: theano graph object with the properties from AdditionalData -> Options\n        theano function: python function to call the theano code\n\n    Args:\n        interfaces (Interfaces)\n        orientaions (Orientations)\n        grid (GridClass)\n        formations (Formations)\n        faults (Faults)\n        additional_data (AdditionalData)\n        kwargs:\n            - compile_theano: if true, the function is compile at the creation of the class\n    \"\"\"\n    # TODO assert passed data is rescaled\n    def __init__(self, interfaces: Interfaces, orientations: Orientations, grid: GridClass,\n                 formations: Formations, faults: Faults, additional_data: AdditionalData, **kwargs):\n\n        self.interfaces = interfaces\n        self.orientations = orientations\n        self.grid = grid\n        self.additional_data = additional_data\n        self.formations = formations\n        self.faults = faults\n\n        self.dtype = additional_data.options.df.loc['values', 'dtype']\n        self.input_matrices = self.get_input_matrix()\n\n        self.theano_graph = self.create_theano_graph(additional_data, inplace=False)\n\n        if 'compile_theano' in kwargs:\n            self.theano_function = self.compile_th_fn(additional_data.options.df.loc['values', 'output'])\n        else:\n            self.theano_function = None\n\n    def create_theano_graph(self, additional_data: AdditionalData = None, inplace=True):\n        \"\"\"\n        create the graph accordingy to the options in the AdditionalData object\n        Args:\n            additional_data (AdditionalData):\n\n        Returns:\n            # TODO look for the right type in the theano library\n            theano graph\n        \"\"\"\n        import gempy.core.theano_graph as tg\n        import importlib\n        importlib.reload(tg)\n\n        if additional_data is None:\n            additional_data = self.additional_data\n\n        #options = additional_data.options.df\n        graph = tg.TheanoGraph(output=additional_data.options.df.loc['values', 'output'],\n                               optimizer=additional_data.options.df.loc['values', 'theano_optimizer'],\n                               dtype=additional_data.options.df.loc['values', 'dtype'],\n                               verbose=additional_data.options.df.loc['values', 'verbosity'],\n                               is_lith=additional_data.structure_data.df.loc['values', 'isLith'],\n                               is_fault=additional_data.structure_data.df.loc['values', 'isFault'])\n\n        return graph\n\n    def set_theano_graph(self, th_graph):\n        self.theano_graph = th_graph\n\n    def set_theano_function(self, th_function):\n        self.theano_function = th_function\n\n    def set_theano_shared_structure(self):\n        # Size of every layer in rests. SHARED (for theano)\n        len_rest_form = (self.additional_data.structure_data.df.loc['values', 'len formations interfaces'] - 1)\n        self.theano_graph.number_of_points_per_formation_T.set_value(len_rest_form.astype('int32'))\n        self.theano_graph.npf.set_value(\n            np.cumsum(np.concatenate(([0], len_rest_form))).astype('int32'))  # Last value is useless\n        # and breaks the basement\n        # Cumulative length of the series. We add the 0 at the beginning and set the shared value. SHARED\n        self.theano_graph.len_series_i.set_value(\n            np.insert(self.additional_data.structure_data.df.loc['values', 'len series interfaces'] -\n                      self.additional_data.structure_data.df.loc['values', 'number formations per series'], 0,\n                      0).cumsum().astype('int32'))\n        # Cumulative length of the series. We add the 0 at the beginning and set the shared value. SHARED\n        self.theano_graph.len_series_f.set_value(\n            np.insert(self.additional_data.structure_data.df.loc['values', 'len series orientations'], 0,\n                      0).cumsum().astype('int32'))\n        # Number of formations per series. The function is not pretty but the result is quite clear\n        n_formations_per_serie = np.insert(\n            self.additional_data.structure_data.df.loc['values', 'number formations per series'], 0, 0). \\\n            astype('int32')\n        self.theano_graph.n_formations_per_serie.set_value(n_formations_per_serie)\n\n        self.theano_graph.n_faults.set_value(self.additional_data.structure_data.df.loc['values', 'number faults'])\n        # Set fault relation matrix\n        self.theano_graph.fault_relation.set_value(self.faults.faults_relations_df.values.astype('int32'))\n\n    def set_theano_shared_kriging(self):\n        # Range\n        # TODO add rescaled range and co into the rescaling data df?\n        self.theano_graph.a_T.set_value(np.cast[self.dtype](self.additional_data.kriging_data.df.loc['values', 'range'] /\n                                                            self.additional_data.rescaling_data.df.loc[\n                                                                'values', 'rescaling factor']))\n        # Covariance at 0\n        self.theano_graph.c_o_T.set_value(np.cast[self.dtype](self.additional_data.kriging_data.df.loc['values', '$C_o$'] /\n                                                              self.additional_data.rescaling_data.df.loc[\n                                                                  'values', 'rescaling factor']\n                                                              ))\n        # universal grades\n        self.theano_graph.n_universal_eq_T.set_value(\n            list(self.additional_data.kriging_data.df.loc['values', 'drift equations'].astype('int32')))\n        # nugget effect\n        self.theano_graph.nugget_effect_grad_T.set_value(\n            np.cast[self.dtype](self.additional_data.kriging_data.df.loc['values', 'nugget grad']))\n        self.theano_graph.nugget_effect_scalar_T.set_value(\n            np.cast[self.dtype](self.additional_data.kriging_data.df.loc['values', 'nugget scalar']))\n\n    def set_theano_shared_output_init(self):\n        # Initialization of the block model\n        self.theano_graph.final_block.set_value(np.zeros((1, self.grid.values_r.shape[0] + self.interfaces.df.shape[0]),\n                                                         dtype=self.dtype))\n        # Init the list to store the values at the interfaces. Here we init the shape for the given dataset\n        self.theano_graph.final_scalar_field_at_formations.set_value(\n            np.zeros(self.theano_graph.n_formations_per_serie.get_value()[-1],\n                     dtype=self.dtype))\n        self.theano_graph.final_scalar_field_at_faults.set_value(\n            np.zeros(self.theano_graph.n_formations_per_serie.get_value()[-1],\n                     dtype=self.dtype))\n\n    def set_theano_share_input(self):\n        self.theano_graph.grid_val_T.set_value(np.cast[self.dtype](self.grid.values_r + 10e-9))\n\n        # Unique number assigned to each lithology\n        self.theano_graph.n_formation.set_value(self.formations.df['id'].values.astype('int32'))\n        # Final values the lith block takes\n        try:\n            self.theano_graph.formation_values.set_value(self.formations.df['value_0'].values)\n        except KeyError:\n            self.theano_graph.formation_values.set_value(self.formations.df['id'].values.astype(self.dtype))\n\n    def set_theano_shared_parameters(self):\n        \"\"\"\n        Set theano shared variables from the other data objects.\n        \"\"\"\n\n        # TODO: I have to split this one between structure_data and init data\n        self.set_theano_shared_structure()\n        self.set_theano_shared_kriging()\n        self.set_theano_shared_output_init()\n        self.set_theano_share_input()\n\n    def get_input_matrix(self) -> list:\n        \"\"\"\n        Get values from the data objects used during the interpolation:\n            - dip positions XYZ\n            - dip angles\n            - azimuth\n            - polarity\n            - interfaces coordinates XYZ\n        Returns:\n            (list)\n        \"\"\"\n        # orientations, this ones I tile them inside theano. PYTHON VAR\n        dips_position = self.orientations.df[['X_r', 'Y_r', 'Z_r']].values\n        dip_angles = self.orientations.df[\"dip\"].values\n        azimuth = self.orientations.df[\"azimuth\"].values\n        polarity = self.orientations.df[\"polarity\"].values\n        interfaces_coord = self.interfaces.df[['X_r', 'Y_r', 'Z_r']].values\n\n        # Set all in a list casting them in the chosen dtype\n        idl = [np.cast[self.dtype](xs) for xs in (dips_position, dip_angles, azimuth, polarity, interfaces_coord)]\n        return idl\n\n    def compile_th_fn(self, output=None, inplace=True, **kwargs):\n        \"\"\"\n        Compile the theano function given the input_data data.\n\n        Args:\n            output (list['geology', 'gradients']): if output is gradients, the gradient field is also computed (in\n            addition to the geology and properties)\n\n        Returns:\n            theano.function: Compiled function if C or CUDA which computes the interpolation given the input_data data\n            (XYZ of dips, dip, azimuth, polarity, XYZ ref interfaces, XYZ rest interfaces)\n        \"\"\"\n        import theano\n        self.set_theano_shared_parameters()\n        # This are the shared parameters and the compilation of the function. This will be hidden as well at some point\n        input_data_T = self.theano_graph.input_parameters_list()\n        if output is None:\n            output = self.additional_data.options.df.loc['values', 'output']\n\n        print('Compiling theano function...')\n\n        if output is 'geology':\n            # then we compile we have to pass the number of formations that are df!!\n            th_fn = theano.function(input_data_T,\n                                    self.theano_graph.compute_geological_model(),\n                                    # mode=NanGuardMode(nan_is_error=True),\n                                    on_unused_input='ignore',\n                                    allow_input_downcast=False,\n                                    profile=False)\n\n        elif output is 'gravity':\n            # then we compile we have to pass the number of formations that are df!!\n            th_fn = theano.function(input_data_T,\n                                    self.theano_graph.compute_forward_gravity(),\n                                    #  mode=NanGuardMode(nan_is_error=True),\n                                    on_unused_input='ignore',\n                                    allow_input_downcast=False,\n                                    profile=False)\n\n        elif output is 'gradients':\n\n            gradients = kwargs.get('gradients', ['Gx', 'Gy', 'Gz'])\n            self.theano_graph.gradients = gradients\n\n            # then we compile we have to pass the number of formations that are df!!\n            th_fn = theano.function(input_data_T,\n                                    self.theano_graph.compute_geological_model_gradient(\n                                        self.additional_data.structure_data['number faults']),\n                                    #  mode=NanGuardMode(nan_is_error=True),\n                                    on_unused_input='ignore',\n                                    allow_input_downcast=False,\n                                    profile=False)\n\n        else:\n            raise SyntaxError('The output given does not exist. Please use geology, gradients or gravity ')\n\n        if inplace is True:\n            self.theano_function = th_fn\n\n        print('Compilation Done!')\n        print('Level of Optimization: ', theano.config.optimizer)\n        print('Device: ', theano.config.device)\n        print('Precision: ', self.dtype)\n        print('Number of faults: ', self.additional_data.structure_data.df.loc['values', 'number faults'])\n        return th_fn\n",
        "source_code_len": 12490,
        "target_code": "        self.edges[formation_name] = edges\n",
        "target_code_len": 43,
        "diff_format": "@@ -2587,259 +2535,1 @@\n         self.edges[formation_name] = edges\n-\n-\n-class Interpolator(object):\n-    \"\"\"\n-    Class that act as:\n-     1) linker between the data objects and the theano graph\n-     2) container of theano graphs + shared variables\n-     3) container of theano function\n-\n-     Attributes:\n-        interfaces (Interfaces)\n-        orientaions (Orientations)\n-        grid (GridClass)\n-        formations (Formations)\n-        faults (Faults)\n-        additional_data (AdditionalData)\n-        dtype (['float32', 'float64']): float precision\n-        input_matrices (list[arrays])\n-            - dip positions XYZ\n-            - dip angles\n-            - azimuth\n-            - polarity\n-            - interfaces coordinates XYZ\n-\n-        theano_graph: theano graph object with the properties from AdditionalData -> Options\n-        theano function: python function to call the theano code\n-\n-    Args:\n-        interfaces (Interfaces)\n-        orientaions (Orientations)\n-        grid (GridClass)\n-        formations (Formations)\n-        faults (Faults)\n-        additional_data (AdditionalData)\n-        kwargs:\n-            - compile_theano: if true, the function is compile at the creation of the class\n-    \"\"\"\n-    # TODO assert passed data is rescaled\n-    def __init__(self, interfaces: Interfaces, orientations: Orientations, grid: GridClass,\n-                 formations: Formations, faults: Faults, additional_data: AdditionalData, **kwargs):\n-\n-        self.interfaces = interfaces\n-        self.orientations = orientations\n-        self.grid = grid\n-        self.additional_data = additional_data\n-        self.formations = formations\n-        self.faults = faults\n-\n-        self.dtype = additional_data.options.df.loc['values', 'dtype']\n-        self.input_matrices = self.get_input_matrix()\n-\n-        self.theano_graph = self.create_theano_graph(additional_data, inplace=False)\n-\n-        if 'compile_theano' in kwargs:\n-            self.theano_function = self.compile_th_fn(additional_data.options.df.loc['values', 'output'])\n-        else:\n-            self.theano_function = None\n-\n-    def create_theano_graph(self, additional_data: AdditionalData = None, inplace=True):\n-        \"\"\"\n-        create the graph accordingy to the options in the AdditionalData object\n-        Args:\n-            additional_data (AdditionalData):\n-\n-        Returns:\n-            # TODO look for the right type in the theano library\n-            theano graph\n-        \"\"\"\n-        import gempy.core.theano_graph as tg\n-        import importlib\n-        importlib.reload(tg)\n-\n-        if additional_data is None:\n-            additional_data = self.additional_data\n-\n-        #options = additional_data.options.df\n-        graph = tg.TheanoGraph(output=additional_data.options.df.loc['values', 'output'],\n-                               optimizer=additional_data.options.df.loc['values', 'theano_optimizer'],\n-                               dtype=additional_data.options.df.loc['values', 'dtype'],\n-                               verbose=additional_data.options.df.loc['values', 'verbosity'],\n-                               is_lith=additional_data.structure_data.df.loc['values', 'isLith'],\n-                               is_fault=additional_data.structure_data.df.loc['values', 'isFault'])\n-\n-        return graph\n-\n-    def set_theano_graph(self, th_graph):\n-        self.theano_graph = th_graph\n-\n-    def set_theano_function(self, th_function):\n-        self.theano_function = th_function\n-\n-    def set_theano_shared_structure(self):\n-        # Size of every layer in rests. SHARED (for theano)\n-        len_rest_form = (self.additional_data.structure_data.df.loc['values', 'len formations interfaces'] - 1)\n-        self.theano_graph.number_of_points_per_formation_T.set_value(len_rest_form.astype('int32'))\n-        self.theano_graph.npf.set_value(\n-            np.cumsum(np.concatenate(([0], len_rest_form))).astype('int32'))  # Last value is useless\n-        # and breaks the basement\n-        # Cumulative length of the series. We add the 0 at the beginning and set the shared value. SHARED\n-        self.theano_graph.len_series_i.set_value(\n-            np.insert(self.additional_data.structure_data.df.loc['values', 'len series interfaces'] -\n-                      self.additional_data.structure_data.df.loc['values', 'number formations per series'], 0,\n-                      0).cumsum().astype('int32'))\n-        # Cumulative length of the series. We add the 0 at the beginning and set the shared value. SHARED\n-        self.theano_graph.len_series_f.set_value(\n-            np.insert(self.additional_data.structure_data.df.loc['values', 'len series orientations'], 0,\n-                      0).cumsum().astype('int32'))\n-        # Number of formations per series. The function is not pretty but the result is quite clear\n-        n_formations_per_serie = np.insert(\n-            self.additional_data.structure_data.df.loc['values', 'number formations per series'], 0, 0). \\\n-            astype('int32')\n-        self.theano_graph.n_formations_per_serie.set_value(n_formations_per_serie)\n-\n-        self.theano_graph.n_faults.set_value(self.additional_data.structure_data.df.loc['values', 'number faults'])\n-        # Set fault relation matrix\n-        self.theano_graph.fault_relation.set_value(self.faults.faults_relations_df.values.astype('int32'))\n-\n-    def set_theano_shared_kriging(self):\n-        # Range\n-        # TODO add rescaled range and co into the rescaling data df?\n-        self.theano_graph.a_T.set_value(np.cast[self.dtype](self.additional_data.kriging_data.df.loc['values', 'range'] /\n-                                                            self.additional_data.rescaling_data.df.loc[\n-                                                                'values', 'rescaling factor']))\n-        # Covariance at 0\n-        self.theano_graph.c_o_T.set_value(np.cast[self.dtype](self.additional_data.kriging_data.df.loc['values', '$C_o$'] /\n-                                                              self.additional_data.rescaling_data.df.loc[\n-                                                                  'values', 'rescaling factor']\n-                                                              ))\n-        # universal grades\n-        self.theano_graph.n_universal_eq_T.set_value(\n-            list(self.additional_data.kriging_data.df.loc['values', 'drift equations'].astype('int32')))\n-        # nugget effect\n-        self.theano_graph.nugget_effect_grad_T.set_value(\n-            np.cast[self.dtype](self.additional_data.kriging_data.df.loc['values', 'nugget grad']))\n-        self.theano_graph.nugget_effect_scalar_T.set_value(\n-            np.cast[self.dtype](self.additional_data.kriging_data.df.loc['values', 'nugget scalar']))\n-\n-    def set_theano_shared_output_init(self):\n-        # Initialization of the block model\n-        self.theano_graph.final_block.set_value(np.zeros((1, self.grid.values_r.shape[0] + self.interfaces.df.shape[0]),\n-                                                         dtype=self.dtype))\n-        # Init the list to store the values at the interfaces. Here we init the shape for the given dataset\n-        self.theano_graph.final_scalar_field_at_formations.set_value(\n-            np.zeros(self.theano_graph.n_formations_per_serie.get_value()[-1],\n-                     dtype=self.dtype))\n-        self.theano_graph.final_scalar_field_at_faults.set_value(\n-            np.zeros(self.theano_graph.n_formations_per_serie.get_value()[-1],\n-                     dtype=self.dtype))\n-\n-    def set_theano_share_input(self):\n-        self.theano_graph.grid_val_T.set_value(np.cast[self.dtype](self.grid.values_r + 10e-9))\n-\n-        # Unique number assigned to each lithology\n-        self.theano_graph.n_formation.set_value(self.formations.df['id'].values.astype('int32'))\n-        # Final values the lith block takes\n-        try:\n-            self.theano_graph.formation_values.set_value(self.formations.df['value_0'].values)\n-        except KeyError:\n-            self.theano_graph.formation_values.set_value(self.formations.df['id'].values.astype(self.dtype))\n-\n-    def set_theano_shared_parameters(self):\n-        \"\"\"\n-        Set theano shared variables from the other data objects.\n-        \"\"\"\n-\n-        # TODO: I have to split this one between structure_data and init data\n-        self.set_theano_shared_structure()\n-        self.set_theano_shared_kriging()\n-        self.set_theano_shared_output_init()\n-        self.set_theano_share_input()\n-\n-    def get_input_matrix(self) -> list:\n-        \"\"\"\n-        Get values from the data objects used during the interpolation:\n-            - dip positions XYZ\n-            - dip angles\n-            - azimuth\n-            - polarity\n-            - interfaces coordinates XYZ\n-        Returns:\n-            (list)\n-        \"\"\"\n-        # orientations, this ones I tile them inside theano. PYTHON VAR\n-        dips_position = self.orientations.df[['X_r', 'Y_r', 'Z_r']].values\n-        dip_angles = self.orientations.df[\"dip\"].values\n-        azimuth = self.orientations.df[\"azimuth\"].values\n-        polarity = self.orientations.df[\"polarity\"].values\n-        interfaces_coord = self.interfaces.df[['X_r', 'Y_r', 'Z_r']].values\n-\n-        # Set all in a list casting them in the chosen dtype\n-        idl = [np.cast[self.dtype](xs) for xs in (dips_position, dip_angles, azimuth, polarity, interfaces_coord)]\n-        return idl\n-\n-    def compile_th_fn(self, output=None, inplace=True, **kwargs):\n-        \"\"\"\n-        Compile the theano function given the input_data data.\n-\n-        Args:\n-            output (list['geology', 'gradients']): if output is gradients, the gradient field is also computed (in\n-            addition to the geology and properties)\n-\n-        Returns:\n-            theano.function: Compiled function if C or CUDA which computes the interpolation given the input_data data\n-            (XYZ of dips, dip, azimuth, polarity, XYZ ref interfaces, XYZ rest interfaces)\n-        \"\"\"\n-        import theano\n-        self.set_theano_shared_parameters()\n-        # This are the shared parameters and the compilation of the function. This will be hidden as well at some point\n-        input_data_T = self.theano_graph.input_parameters_list()\n-        if output is None:\n-            output = self.additional_data.options.df.loc['values', 'output']\n-\n-        print('Compiling theano function...')\n-\n-        if output is 'geology':\n-            # then we compile we have to pass the number of formations that are df!!\n-            th_fn = theano.function(input_data_T,\n-                                    self.theano_graph.compute_geological_model(),\n-                                    # mode=NanGuardMode(nan_is_error=True),\n-                                    on_unused_input='ignore',\n-                                    allow_input_downcast=False,\n-                                    profile=False)\n-\n-        elif output is 'gravity':\n-            # then we compile we have to pass the number of formations that are df!!\n-            th_fn = theano.function(input_data_T,\n-                                    self.theano_graph.compute_forward_gravity(),\n-                                    #  mode=NanGuardMode(nan_is_error=True),\n-                                    on_unused_input='ignore',\n-                                    allow_input_downcast=False,\n-                                    profile=False)\n-\n-        elif output is 'gradients':\n-\n-            gradients = kwargs.get('gradients', ['Gx', 'Gy', 'Gz'])\n-            self.theano_graph.gradients = gradients\n-\n-            # then we compile we have to pass the number of formations that are df!!\n-            th_fn = theano.function(input_data_T,\n-                                    self.theano_graph.compute_geological_model_gradient(\n-                                        self.additional_data.structure_data['number faults']),\n-                                    #  mode=NanGuardMode(nan_is_error=True),\n-                                    on_unused_input='ignore',\n-                                    allow_input_downcast=False,\n-                                    profile=False)\n-\n-        else:\n-            raise SyntaxError('The output given does not exist. Please use geology, gradients or gravity ')\n-\n-        if inplace is True:\n-            self.theano_function = th_fn\n-\n-        print('Compilation Done!')\n-        print('Level of Optimization: ', theano.config.optimizer)\n-        print('Device: ', theano.config.device)\n-        print('Precision: ', self.dtype)\n-        print('Number of faults: ', self.additional_data.structure_data.df.loc['values', 'number faults'])\n-        return th_fn\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent": "        <IND>self.edges[formation_name] = edges\n",
        "target_code_with_indent_exact_match": true,
        "source_code_with_indent": "        <IND>self.edges[formation_name] = edges\n\n\n<DED><DED>class Interpolator(object):\n    <IND>\"\"\"\n    Class that act as:\n     1) linker between the data objects and the theano graph\n     2) container of theano graphs + shared variables\n     3) container of theano function\n\n     Attributes:\n        interfaces (Interfaces)\n        orientaions (Orientations)\n        grid (GridClass)\n        formations (Formations)\n        faults (Faults)\n        additional_data (AdditionalData)\n        dtype (['float32', 'float64']): float precision\n        input_matrices (list[arrays])\n            - dip positions XYZ\n            - dip angles\n            - azimuth\n            - polarity\n            - interfaces coordinates XYZ\n\n        theano_graph: theano graph object with the properties from AdditionalData -> Options\n        theano function: python function to call the theano code\n\n    Args:\n        interfaces (Interfaces)\n        orientaions (Orientations)\n        grid (GridClass)\n        formations (Formations)\n        faults (Faults)\n        additional_data (AdditionalData)\n        kwargs:\n            - compile_theano: if true, the function is compile at the creation of the class\n    \"\"\"\n    # TODO assert passed data is rescaled\n    def __init__(self, interfaces: Interfaces, orientations: Orientations, grid: GridClass,\n                 formations: Formations, faults: Faults, additional_data: AdditionalData, **kwargs):\n\n        <IND>self.interfaces = interfaces\n        self.orientations = orientations\n        self.grid = grid\n        self.additional_data = additional_data\n        self.formations = formations\n        self.faults = faults\n\n        self.dtype = additional_data.options.df.loc['values', 'dtype']\n        self.input_matrices = self.get_input_matrix()\n\n        self.theano_graph = self.create_theano_graph(additional_data, inplace=False)\n\n        if 'compile_theano' in kwargs:\n            <IND>self.theano_function = self.compile_th_fn(additional_data.options.df.loc['values', 'output'])\n        <DED>else:\n            <IND>self.theano_function = None\n\n    <DED><DED>def create_theano_graph(self, additional_data: AdditionalData = None, inplace=True):\n        <IND>\"\"\"\n        create the graph accordingy to the options in the AdditionalData object\n        Args:\n            additional_data (AdditionalData):\n\n        Returns:\n            # TODO look for the right type in the theano library\n            theano graph\n        \"\"\"\n        import gempy.core.theano_graph as tg\n        import importlib\n        importlib.reload(tg)\n\n        if additional_data is None:\n            <IND>additional_data = self.additional_data\n\n        #options = additional_data.options.df\n        <DED>graph = tg.TheanoGraph(output=additional_data.options.df.loc['values', 'output'],\n                               optimizer=additional_data.options.df.loc['values', 'theano_optimizer'],\n                               dtype=additional_data.options.df.loc['values', 'dtype'],\n                               verbose=additional_data.options.df.loc['values', 'verbosity'],\n                               is_lith=additional_data.structure_data.df.loc['values', 'isLith'],\n                               is_fault=additional_data.structure_data.df.loc['values', 'isFault'])\n\n        return graph\n\n    <DED>def set_theano_graph(self, th_graph):\n        <IND>self.theano_graph = th_graph\n\n    <DED>def set_theano_function(self, th_function):\n        <IND>self.theano_function = th_function\n\n    <DED>def set_theano_shared_structure(self):\n        # Size of every layer in rests. SHARED (for theano)\n        <IND>len_rest_form = (self.additional_data.structure_data.df.loc['values', 'len formations interfaces'] - 1)\n        self.theano_graph.number_of_points_per_formation_T.set_value(len_rest_form.astype('int32'))\n        self.theano_graph.npf.set_value(\n            np.cumsum(np.concatenate(([0], len_rest_form))).astype('int32'))  # Last value is useless\n        # and breaks the basement\n        # Cumulative length of the series. We add the 0 at the beginning and set the shared value. SHARED\n        self.theano_graph.len_series_i.set_value(\n            np.insert(self.additional_data.structure_data.df.loc['values', 'len series interfaces'] -\n                      self.additional_data.structure_data.df.loc['values', 'number formations per series'], 0,\n                      0).cumsum().astype('int32'))\n        # Cumulative length of the series. We add the 0 at the beginning and set the shared value. SHARED\n        self.theano_graph.len_series_f.set_value(\n            np.insert(self.additional_data.structure_data.df.loc['values', 'len series orientations'], 0,\n                      0).cumsum().astype('int32'))\n        # Number of formations per series. The function is not pretty but the result is quite clear\n        n_formations_per_serie = np.insert(\n            self.additional_data.structure_data.df.loc['values', 'number formations per series'], 0, 0).            astype('int32')\n        self.theano_graph.n_formations_per_serie.set_value(n_formations_per_serie)\n\n        self.theano_graph.n_faults.set_value(self.additional_data.structure_data.df.loc['values', 'number faults'])\n        # Set fault relation matrix\n        self.theano_graph.fault_relation.set_value(self.faults.faults_relations_df.values.astype('int32'))\n\n    <DED>def set_theano_shared_kriging(self):\n        # Range\n        # TODO add rescaled range and co into the rescaling data df?\n        <IND>self.theano_graph.a_T.set_value(np.cast[self.dtype](self.additional_data.kriging_data.df.loc['values', 'range'] /\n                                                            self.additional_data.rescaling_data.df.loc[\n                                                                'values', 'rescaling factor']))\n        # Covariance at 0\n        self.theano_graph.c_o_T.set_value(np.cast[self.dtype](self.additional_data.kriging_data.df.loc['values', '$C_o$'] /\n                                                              self.additional_data.rescaling_data.df.loc[\n                                                                  'values', 'rescaling factor']\n                                                              ))\n        # universal grades\n        self.theano_graph.n_universal_eq_T.set_value(\n            list(self.additional_data.kriging_data.df.loc['values', 'drift equations'].astype('int32')))\n        # nugget effect\n        self.theano_graph.nugget_effect_grad_T.set_value(\n            np.cast[self.dtype](self.additional_data.kriging_data.df.loc['values', 'nugget grad']))\n        self.theano_graph.nugget_effect_scalar_T.set_value(\n            np.cast[self.dtype](self.additional_data.kriging_data.df.loc['values', 'nugget scalar']))\n\n    <DED>def set_theano_shared_output_init(self):\n        # Initialization of the block model\n        <IND>self.theano_graph.final_block.set_value(np.zeros((1, self.grid.values_r.shape[0] + self.interfaces.df.shape[0]),\n                                                         dtype=self.dtype))\n        # Init the list to store the values at the interfaces. Here we init the shape for the given dataset\n        self.theano_graph.final_scalar_field_at_formations.set_value(\n            np.zeros(self.theano_graph.n_formations_per_serie.get_value()[-1],\n                     dtype=self.dtype))\n        self.theano_graph.final_scalar_field_at_faults.set_value(\n            np.zeros(self.theano_graph.n_formations_per_serie.get_value()[-1],\n                     dtype=self.dtype))\n\n    <DED>def set_theano_share_input(self):\n        <IND>self.theano_graph.grid_val_T.set_value(np.cast[self.dtype](self.grid.values_r + 10e-9))\n\n        # Unique number assigned to each lithology\n        self.theano_graph.n_formation.set_value(self.formations.df['id'].values.astype('int32'))\n        # Final values the lith block takes\n        try:\n            <IND>self.theano_graph.formation_values.set_value(self.formations.df['value_0'].values)\n        <DED>except KeyError:\n            <IND>self.theano_graph.formation_values.set_value(self.formations.df['id'].values.astype(self.dtype))\n\n    <DED><DED>def set_theano_shared_parameters(self):\n        <IND>\"\"\"\n        Set theano shared variables from the other data objects.\n        \"\"\"\n\n        # TODO: I have to split this one between structure_data and init data\n        self.set_theano_shared_structure()\n        self.set_theano_shared_kriging()\n        self.set_theano_shared_output_init()\n        self.set_theano_share_input()\n\n    <DED>def get_input_matrix(self) -> list:\n        <IND>\"\"\"\n        Get values from the data objects used during the interpolation:\n            - dip positions XYZ\n            - dip angles\n            - azimuth\n            - polarity\n            - interfaces coordinates XYZ\n        Returns:\n            (list)\n        \"\"\"\n        # orientations, this ones I tile them inside theano. PYTHON VAR\n        dips_position = self.orientations.df[['X_r', 'Y_r', 'Z_r']].values\n        dip_angles = self.orientations.df[\"dip\"].values\n        azimuth = self.orientations.df[\"azimuth\"].values\n        polarity = self.orientations.df[\"polarity\"].values\n        interfaces_coord = self.interfaces.df[['X_r', 'Y_r', 'Z_r']].values\n\n        # Set all in a list casting them in the chosen dtype\n        idl = [np.cast[self.dtype](xs) for xs in (dips_position, dip_angles, azimuth, polarity, interfaces_coord)]\n        return idl\n\n    <DED>def compile_th_fn(self, output=None, inplace=True, **kwargs):\n        <IND>\"\"\"\n        Compile the theano function given the input_data data.\n\n        Args:\n            output (list['geology', 'gradients']): if output is gradients, the gradient field is also computed (in\n            addition to the geology and properties)\n\n        Returns:\n            theano.function: Compiled function if C or CUDA which computes the interpolation given the input_data data\n            (XYZ of dips, dip, azimuth, polarity, XYZ ref interfaces, XYZ rest interfaces)\n        \"\"\"\n        import theano\n        self.set_theano_shared_parameters()\n        # This are the shared parameters and the compilation of the function. This will be hidden as well at some point\n        input_data_T = self.theano_graph.input_parameters_list()\n        if output is None:\n            <IND>output = self.additional_data.options.df.loc['values', 'output']\n\n        <DED>print('Compiling theano function...')\n\n        if output is 'geology':\n            # then we compile we have to pass the number of formations that are df!!\n            <IND>th_fn = theano.function(input_data_T,\n                                    self.theano_graph.compute_geological_model(),\n                                    # mode=NanGuardMode(nan_is_error=True),\n                                    on_unused_input='ignore',\n                                    allow_input_downcast=False,\n                                    profile=False)\n\n        <DED>elif output is 'gravity':\n            # then we compile we have to pass the number of formations that are df!!\n            <IND>th_fn = theano.function(input_data_T,\n                                    self.theano_graph.compute_forward_gravity(),\n                                    #  mode=NanGuardMode(nan_is_error=True),\n                                    on_unused_input='ignore',\n                                    allow_input_downcast=False,\n                                    profile=False)\n\n        <DED>elif output is 'gradients':\n\n            <IND>gradients = kwargs.get('gradients', ['Gx', 'Gy', 'Gz'])\n            self.theano_graph.gradients = gradients\n\n            # then we compile we have to pass the number of formations that are df!!\n            th_fn = theano.function(input_data_T,\n                                    self.theano_graph.compute_geological_model_gradient(\n                                        self.additional_data.structure_data['number faults']),\n                                    #  mode=NanGuardMode(nan_is_error=True),\n                                    on_unused_input='ignore',\n                                    allow_input_downcast=False,\n                                    profile=False)\n\n        <DED>else:\n            <IND>raise SyntaxError('The output given does not exist. Please use geology, gradients or gravity ')\n\n        <DED>if inplace is True:\n            <IND>self.theano_function = th_fn\n\n        <DED>print('Compilation Done!')\n        print('Level of Optimization: ', theano.config.optimizer)\n        print('Device: ', theano.config.device)\n        print('Precision: ', self.dtype)\n        print('Number of faults: ', self.additional_data.structure_data.df.loc['values', 'number faults'])\n        return th_fn\n"
      }
    ]
  }
]