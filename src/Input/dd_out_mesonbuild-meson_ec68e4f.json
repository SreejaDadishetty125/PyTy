[
  {
    "project": "mesonbuild/meson",
    "commit": "ec68e4fd5ab2674d88c58001b8e7bb42d76ff3a1",
    "filename": "mesonbuild/dependencies/base.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/mesonbuild-meson/mesonbuild/dependencies/base.py",
    "file_hunks_size": 5,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "mesonbuild/dependencies/base.py:2504:8 Incompatible return type [7]: Expected `T.List[DependencyMethods]` but got `DependencyMethods`.",
    "message": " Expected `T.List[DependencyMethods]` but got `DependencyMethods`.",
    "rule_id": "Incompatible return type [7]",
    "warning_line_no": 2504,
    "warning_line": "        return method",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\ndef process_method_kw(possible: T.List[DependencyMethods], kwargs) -> T.List[DependencyMethods]:\n    method = kwargs.get('method', 'auto')\n    if isinstance(method, DependencyMethods):\n        return method\n    if method not in [e.value for e in DependencyMethods]:\n",
        "source_code_len": 267,
        "target_code": "\ndef process_method_kw(possible: T.Iterable[DependencyMethods], kwargs) -> T.List[DependencyMethods]:\n    method = kwargs.get('method', 'auto')  # type: T.Union[DependencyMethods, str]\n    if isinstance(method, DependencyMethods):\n        return [method]\n    # TODO: try/except?\n    if method not in [e.value for e in DependencyMethods]:\n",
        "target_code_len": 338,
        "diff_format": "@@ -2500,6 +2500,7 @@\n \n-def process_method_kw(possible: T.List[DependencyMethods], kwargs) -> T.List[DependencyMethods]:\n-    method = kwargs.get('method', 'auto')\n+def process_method_kw(possible: T.Iterable[DependencyMethods], kwargs) -> T.List[DependencyMethods]:\n+    method = kwargs.get('method', 'auto')  # type: T.Union[DependencyMethods, str]\n     if isinstance(method, DependencyMethods):\n-        return method\n+        return [method]\n+    # TODO: try/except?\n     if method not in [e.value for e in DependencyMethods]:\n",
        "source_code_with_indent": "\n<DED>def process_method_kw(possible: T.List[DependencyMethods], kwargs) -> T.List[DependencyMethods]:\n    <IND>method = kwargs.get('method', 'auto')\n    if isinstance(method, DependencyMethods):\n        <IND>return method\n    <DED>if method not in [e.value for e in DependencyMethods]:\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n<DED>def process_method_kw(possible: T.Iterable[DependencyMethods], kwargs) -> T.List[DependencyMethods]:\n    <IND>method = kwargs.get('method', 'auto')  # type: T.Union[DependencyMethods, str]\n    if isinstance(method, DependencyMethods):\n        <IND>return [method]\n    # TODO: try/except?\n    <DED>if method not in [e.value for e in DependencyMethods]:\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    if method == DependencyMethods.AUTO:\n        methods = possible\n    elif method in possible:\n",
        "source_code_len": 97,
        "target_code": "    if method == DependencyMethods.AUTO:\n        methods = list(possible)\n    elif method in possible:\n",
        "target_code_len": 103,
        "diff_format": "@@ -2521,3 +2522,3 @@\n     if method == DependencyMethods.AUTO:\n-        methods = possible\n+        methods = list(possible)\n     elif method in possible:\n",
        "source_code_with_indent": "    <DED>if method == DependencyMethods.AUTO:\n        <IND>methods = possible\n    <DED>elif method in possible:\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    <DED>if method == DependencyMethods.AUTO:\n        <IND>methods = list(possible)\n    <DED>elif method in possible:\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "                method.value,\n                mlog.format_list([x.value for x in [DependencyMethods.AUTO] + possible])))\n\n",
        "source_code_len": 122,
        "target_code": "                method.value,\n                mlog.format_list([x.value for x in [DependencyMethods.AUTO] + list(possible)])))\n\n",
        "target_code_len": 128,
        "diff_format": "@@ -2528,3 +2529,3 @@\n                 method.value,\n-                mlog.format_list([x.value for x in [DependencyMethods.AUTO] + possible])))\n+                mlog.format_list([x.value for x in [DependencyMethods.AUTO] + list(possible)])))\n \n",
        "source_code_with_indent": "                method.value,\n                mlog.format_list([x.value for x in [DependencyMethods.AUTO] + possible])))\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "                method.value,\n                mlog.format_list([x.value for x in [DependencyMethods.AUTO] + list(possible)])))\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "mesonbuild/meson",
    "commit": "ec68e4fd5ab2674d88c58001b8e7bb42d76ff3a1",
    "filename": "mesonbuild/dependencies/base.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/mesonbuild-meson/mesonbuild/dependencies/base.py",
    "file_hunks_size": 5,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "mesonbuild/dependencies/base.py:2554:50 Incompatible parameter type [6]: Expected `T.Set[DependencyMethods]` for 4th positional only parameter to anonymous call but got `T.List[DependencyMethods]`.",
    "message": " Expected `T.Set[DependencyMethods]` for 4th positional only parameter to anonymous call but got `T.List[DependencyMethods]`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 2554,
    "warning_line": "            return func(env, for_machine, kwargs, process_method_kw(methods, kwargs))"
  },
  {
    "project": "mesonbuild/meson",
    "commit": "ec68e4fd5ab2674d88c58001b8e7bb42d76ff3a1",
    "filename": "mesonbuild/dependencies/base.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/mesonbuild-meson/mesonbuild/dependencies/base.py",
    "file_hunks_size": 5,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "mesonbuild/dependencies/base.py:2554:68 Incompatible parameter type [6]: Expected `T.List[DependencyMethods]` for 1st positional only parameter to call `process_method_kw` but got `T.Set[DependencyMethods]`.",
    "message": " Expected `T.List[DependencyMethods]` for 1st positional only parameter to call `process_method_kw` but got `T.Set[DependencyMethods]`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 2554,
    "warning_line": "            return func(env, for_machine, kwargs, process_method_kw(methods, kwargs))",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\ndef process_method_kw(possible: T.List[DependencyMethods], kwargs) -> T.List[DependencyMethods]:\n    method = kwargs.get('method', 'auto')\n    if isinstance(method, DependencyMethods):\n        return method\n    if method not in [e.value for e in DependencyMethods]:\n",
        "source_code_len": 267,
        "target_code": "\ndef process_method_kw(possible: T.Iterable[DependencyMethods], kwargs) -> T.List[DependencyMethods]:\n    method = kwargs.get('method', 'auto')  # type: T.Union[DependencyMethods, str]\n    if isinstance(method, DependencyMethods):\n        return [method]\n    # TODO: try/except?\n    if method not in [e.value for e in DependencyMethods]:\n",
        "target_code_len": 338,
        "diff_format": "@@ -2500,6 +2500,7 @@\n \n-def process_method_kw(possible: T.List[DependencyMethods], kwargs) -> T.List[DependencyMethods]:\n-    method = kwargs.get('method', 'auto')\n+def process_method_kw(possible: T.Iterable[DependencyMethods], kwargs) -> T.List[DependencyMethods]:\n+    method = kwargs.get('method', 'auto')  # type: T.Union[DependencyMethods, str]\n     if isinstance(method, DependencyMethods):\n-        return method\n+        return [method]\n+    # TODO: try/except?\n     if method not in [e.value for e in DependencyMethods]:\n",
        "source_code_with_indent": "\n<DED>def process_method_kw(possible: T.List[DependencyMethods], kwargs) -> T.List[DependencyMethods]:\n    <IND>method = kwargs.get('method', 'auto')\n    if isinstance(method, DependencyMethods):\n        <IND>return method\n    <DED>if method not in [e.value for e in DependencyMethods]:\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n<DED>def process_method_kw(possible: T.Iterable[DependencyMethods], kwargs) -> T.List[DependencyMethods]:\n    <IND>method = kwargs.get('method', 'auto')  # type: T.Union[DependencyMethods, str]\n    if isinstance(method, DependencyMethods):\n        <IND>return [method]\n    # TODO: try/except?\n    <DED>if method not in [e.value for e in DependencyMethods]:\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    if method == DependencyMethods.AUTO:\n        methods = possible\n    elif method in possible:\n",
        "source_code_len": 97,
        "target_code": "    if method == DependencyMethods.AUTO:\n        methods = list(possible)\n    elif method in possible:\n",
        "target_code_len": 103,
        "diff_format": "@@ -2521,3 +2522,3 @@\n     if method == DependencyMethods.AUTO:\n-        methods = possible\n+        methods = list(possible)\n     elif method in possible:\n",
        "source_code_with_indent": "    <DED>if method == DependencyMethods.AUTO:\n        <IND>methods = possible\n    <DED>elif method in possible:\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    <DED>if method == DependencyMethods.AUTO:\n        <IND>methods = list(possible)\n    <DED>elif method in possible:\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "                method.value,\n                mlog.format_list([x.value for x in [DependencyMethods.AUTO] + possible])))\n\n",
        "source_code_len": 122,
        "target_code": "                method.value,\n                mlog.format_list([x.value for x in [DependencyMethods.AUTO] + list(possible)])))\n\n",
        "target_code_len": 128,
        "diff_format": "@@ -2528,3 +2529,3 @@\n                 method.value,\n-                mlog.format_list([x.value for x in [DependencyMethods.AUTO] + possible])))\n+                mlog.format_list([x.value for x in [DependencyMethods.AUTO] + list(possible)])))\n \n",
        "source_code_with_indent": "                method.value,\n                mlog.format_list([x.value for x in [DependencyMethods.AUTO] + possible])))\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "                method.value,\n                mlog.format_list([x.value for x in [DependencyMethods.AUTO] + list(possible)])))\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "mesonbuild/meson",
    "commit": "ec68e4fd5ab2674d88c58001b8e7bb42d76ff3a1",
    "filename": "mesonbuild/dependencies/base.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/mesonbuild-meson/mesonbuild/dependencies/base.py",
    "file_hunks_size": 5,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "mesonbuild/dependencies/base.py:2558:4 Incompatible return type [7]: Expected `typing.Callable[[Environment, MachineChoice, T.Dict[str, typing.Any]], T.List[typing.Any]]` but got `typing.Callable[[Named(func, typing.Callable[[Environment, MachineChoice, T.Dict[str, typing.Any], T.Set[DependencyMethods]], T.List[typing.Any]])], typing.Callable[[Environment, MachineChoice, T.Dict[str, typing.Any]], T.List[typing.Any]]]`.",
    "message": " Expected `typing.Callable[[Environment, MachineChoice, T.Dict[str, typing.Any]], T.List[typing.Any]]` but got `typing.Callable[[Named(func, typing.Callable[[Environment, MachineChoice, T.Dict[str, typing.Any], T.Set[DependencyMethods]], T.List[typing.Any]])], typing.Callable[[Environment, MachineChoice, T.Dict[str, typing.Any]], T.List[typing.Any]]]`.",
    "rule_id": "Incompatible return type [7]",
    "warning_line_no": 2558,
    "warning_line": "    return inner"
  }
]