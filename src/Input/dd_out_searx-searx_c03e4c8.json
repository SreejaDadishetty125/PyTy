[
  {
    "project": "searx/searx",
    "commit": "c03e4c86bc49d6ef4664c038066d9f1c16e7dafc",
    "filename": "utils/standalone_searx.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/searx-searx/utils/standalone_searx.py",
    "file_hunks_size": 4,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "utils/standalone_searx.py:104:0 Incompatible variable type [9]: sys.stdout is declared to have type `typing.TextIO` but is used as type `codecs.StreamWriter`.",
    "message": " sys.stdout is declared to have type `typing.TextIO` but is used as type `codecs.StreamWriter`.",
    "rule_id": "Incompatible variable type [9]",
    "warning_line_no": 104,
    "warning_line": "sys.stdout = codecs.getwriter(\"UTF-8\")(sys.stdout)",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "'''\n\n# set path\nfrom sys import path\nfrom os.path import realpath, dirname\npath.append(realpath(dirname(realpath(__file__)) + '/../'))\n\n# initialization\nfrom json import dumps\nfrom searx import settings\nimport sys\nimport codecs\nimport searx.query\nimport searx.search\nimport searx.engines\nimport searx.webapdater\nimport searx.preferences\nimport searx.webadapter\nimport argparse\n\nsearx.engines.initialize_engines(settings['engines'])\n\n# command line parsing\nparser = argparse.ArgumentParser(description='Standalone searx.')\nparser.add_argument('query', type=str,\n                    help='Text query')\nparser.add_argument('--category', type=str, nargs='?',\n                    choices=searx.engines.categories.keys(),\n                    default='general',\n                    help='Search category')\nparser.add_argument('--lang', type=str, nargs='?',default='all',\n                    help='Search language')\nparser.add_argument('--pageno', type=int, nargs='?', default=1,\n                    help='Page number starting from 1')\nparser.add_argument('--safesearch', type=str, nargs='?', choices=['0', '1', '2'], default='0',\n                    help='Safe content filter from none to strict')\nparser.add_argument('--timerange', type=str, nargs='?', choices=['day', 'week', 'month', 'year'],\n                    help='Filter by time range')\nargs = parser.parse_args()\n\n# search results for the query\nform = {\n    \"q\":args.query,\n    \"categories\":args.category.decode(),\n    \"pageno\":str(args.pageno),\n    \"language\":args.lang,\n    \"time_range\":args.timerange\n}\npreferences = searx.preferences.Preferences(['oscar'], searx.engines.categories.keys(), searx.engines.engines, [])\npreferences.key_value_settings['safesearch'].parse(args.safesearch)\n\nsearch_query, raw_text_query, _, _ = searx.webadapter.get_search_query_from_webapp(preferences, form)\nsearch = searx.search.Search(search_query)\nresult_container = search.search()\n\n# output\nfrom datetime import datetime\n\ndef no_parsed_url(results):\n    for result in results:\n",
        "source_code_len": 2018,
        "target_code": "'''\n# pylint: disable=wrong-import-position\nimport argparse\nimport sys\nfrom datetime import datetime\nfrom json import dumps\nfrom typing import Any, Dict, List, Optional\n\nimport searx\nimport searx.engines\nimport searx.preferences\nimport searx.query\nimport searx.search\nimport searx.webadapter\n\nEngineCategoriesVar = Optional[List[str]]\n\n\ndef get_search_query(\n        args: argparse.Namespace, engine_categories: EngineCategoriesVar = None\n) -> searx.search.SearchQuery:\n    \"\"\"Get  search results for the query\"\"\"\n    if engine_categories is None:\n        engine_categories = list(searx.engines.categories.keys())\n    try:\n        category = args.category.decode('utf-8')\n    except AttributeError:\n        category = args.category\n    form = {\n        \"q\": args.query,\n        \"categories\": category,\n        \"pageno\": str(args.pageno),\n        \"language\": args.lang,\n        \"time_range\": args.timerange\n    }\n    preferences = searx.preferences.Preferences(\n        ['oscar'], engine_categories, searx.engines.engines, [])\n    preferences.key_value_settings['safesearch'].parse(args.safesearch)\n\n    search_query = searx.webadapter.get_search_query_from_webapp(\n        preferences, form)[0]\n    return search_query\n\n\ndef no_parsed_url(results: List[Dict[str, Any]]) -> List[Dict[str, Any]]:\n    \"\"\"Remove parsed url from dict.\"\"\"\n    for result in results:\n",
        "target_code_len": 1361,
        "diff_format": "@@ -18,60 +76,47 @@\n '''\n-\n-# set path\n-from sys import path\n-from os.path import realpath, dirname\n-path.append(realpath(dirname(realpath(__file__)) + '/../'))\n-\n-# initialization\n+# pylint: disable=wrong-import-position\n+import argparse\n+import sys\n+from datetime import datetime\n from json import dumps\n-from searx import settings\n-import sys\n-import codecs\n+from typing import Any, Dict, List, Optional\n+\n+import searx\n+import searx.engines\n+import searx.preferences\n import searx.query\n import searx.search\n-import searx.engines\n-import searx.webapdater\n-import searx.preferences\n import searx.webadapter\n-import argparse\n-\n-searx.engines.initialize_engines(settings['engines'])\n-\n-# command line parsing\n-parser = argparse.ArgumentParser(description='Standalone searx.')\n-parser.add_argument('query', type=str,\n-                    help='Text query')\n-parser.add_argument('--category', type=str, nargs='?',\n-                    choices=searx.engines.categories.keys(),\n-                    default='general',\n-                    help='Search category')\n-parser.add_argument('--lang', type=str, nargs='?',default='all',\n-                    help='Search language')\n-parser.add_argument('--pageno', type=int, nargs='?', default=1,\n-                    help='Page number starting from 1')\n-parser.add_argument('--safesearch', type=str, nargs='?', choices=['0', '1', '2'], default='0',\n-                    help='Safe content filter from none to strict')\n-parser.add_argument('--timerange', type=str, nargs='?', choices=['day', 'week', 'month', 'year'],\n-                    help='Filter by time range')\n-args = parser.parse_args()\n-\n-# search results for the query\n-form = {\n-    \"q\":args.query,\n-    \"categories\":args.category.decode(),\n-    \"pageno\":str(args.pageno),\n-    \"language\":args.lang,\n-    \"time_range\":args.timerange\n-}\n-preferences = searx.preferences.Preferences(['oscar'], searx.engines.categories.keys(), searx.engines.engines, [])\n-preferences.key_value_settings['safesearch'].parse(args.safesearch)\n-\n-search_query, raw_text_query, _, _ = searx.webadapter.get_search_query_from_webapp(preferences, form)\n-search = searx.search.Search(search_query)\n-result_container = search.search()\n-\n-# output\n-from datetime import datetime\n-\n-def no_parsed_url(results):\n+\n+EngineCategoriesVar = Optional[List[str]]\n+\n+\n+def get_search_query(\n+        args: argparse.Namespace, engine_categories: EngineCategoriesVar = None\n+) -> searx.search.SearchQuery:\n+    \"\"\"Get  search results for the query\"\"\"\n+    if engine_categories is None:\n+        engine_categories = list(searx.engines.categories.keys())\n+    try:\n+        category = args.category.decode('utf-8')\n+    except AttributeError:\n+        category = args.category\n+    form = {\n+        \"q\": args.query,\n+        \"categories\": category,\n+        \"pageno\": str(args.pageno),\n+        \"language\": args.lang,\n+        \"time_range\": args.timerange\n+    }\n+    preferences = searx.preferences.Preferences(\n+        ['oscar'], engine_categories, searx.engines.engines, [])\n+    preferences.key_value_settings['safesearch'].parse(args.safesearch)\n+\n+    search_query = searx.webadapter.get_search_query_from_webapp(\n+        preferences, form)[0]\n+    return search_query\n+\n+\n+def no_parsed_url(results: List[Dict[str, Any]]) -> List[Dict[str, Any]]:\n+    \"\"\"Remove parsed url from dict.\"\"\"\n     for result in results:\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\n\n# set path\nfrom sys import path\nfrom os.path import realpath, dirname\npath.append(realpath(dirname(realpath(__file__)) + '/../'))\n\n# initialization\nfrom json import dumps\nfrom searx import settings\nimport sys\nimport codecs\nimport searx.query\nimport searx.search\nimport searx.engines\nimport searx.webapdater\nimport searx.preferences\nimport searx.webadapter\nimport argparse\n\nsearx.engines.initialize_engines(settings['engines'])\n\n# command line parsing\nparser = argparse.ArgumentParser(description='Standalone searx.')\nparser.add_argument('query', type=str,\n                    help='Text query')\nparser.add_argument('--category', type=str, nargs='?',\n                    choices=searx.engines.categories.keys(),\n                    default='general',\n                    help='Search category')\nparser.add_argument('--lang', type=str, nargs='?',default='all',\n                    help='Search language')\nparser.add_argument('--pageno', type=int, nargs='?', default=1,\n                    help='Page number starting from 1')\nparser.add_argument('--safesearch', type=str, nargs='?', choices=['0', '1', '2'], default='0',\n                    help='Safe content filter from none to strict')\nparser.add_argument('--timerange', type=str, nargs='?', choices=['day', 'week', 'month', 'year'],\n                    help='Filter by time range')\nargs = parser.parse_args()\n\n# search results for the query\nform = {\n    \"q\":args.query,\n    \"categories\":args.category.decode(),\n    \"pageno\":str(args.pageno),\n    \"language\":args.lang,\n    \"time_range\":args.timerange\n}\npreferences = searx.preferences.Preferences(['oscar'], searx.engines.categories.keys(), searx.engines.engines, [])\npreferences.key_value_settings['safesearch'].parse(args.safesearch)\n\nsearch_query, raw_text_query, _, _ = searx.webadapter.get_search_query_from_webapp(preferences, form)\nsearch = searx.search.Search(search_query)\nresult_container = search.search()\n\n# output\nfrom datetime import datetime\n\ndef no_parsed_url(results):\n    <IND>for result in results:\n",
        "target_code_with_indent": "\n# pylint: disable=wrong-import-position\nimport argparse\nimport sys\nfrom datetime import datetime\nfrom json import dumps\nfrom typing import Any, Dict, List, Optional\n\nimport searx\nimport searx.engines\nimport searx.preferences\nimport searx.query\nimport searx.search\nimport searx.webadapter\n\nEngineCategoriesVar = Optional[List[str]]\n\n\ndef get_search_query(\n        args: argparse.Namespace, engine_categories: EngineCategoriesVar = None\n) -> searx.search.SearchQuery:\n    <IND>\"\"\"Get  search results for the query\"\"\"\n    if engine_categories is None:\n        <IND>engine_categories = list(searx.engines.categories.keys())\n    <DED>try:\n        <IND>category = args.category.decode('utf-8')\n    <DED>except AttributeError:\n        <IND>category = args.category\n    <DED>form = {\n        \"q\": args.query,\n        \"categories\": category,\n        \"pageno\": str(args.pageno),\n        \"language\": args.lang,\n        \"time_range\": args.timerange\n    }\n    preferences = searx.preferences.Preferences(\n        ['oscar'], engine_categories, searx.engines.engines, [])\n    preferences.key_value_settings['safesearch'].parse(args.safesearch)\n\n    search_query = searx.webadapter.get_search_query_from_webapp(\n        preferences, form)[0]\n    return search_query\n\n\n<DED>def no_parsed_url(results: List[Dict[str, Any]]) -> List[Dict[str, Any]]:\n    <IND>\"\"\"Remove parsed url from dict.\"\"\"\n    for result in results:\n"
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "        return serial\n    raise TypeError (\"Type not serializable\")\n\nresult_container_json = {\n    \"search\": {\n        \"q\": search_query.query,\n        \"pageno\": search_query.pageno,\n        \"lang\": search_query.lang,\n        \"safesearch\": search_query.safesearch,\n        \"timerange\": search_query.time_range,\n        \"engines\": search_query.engines  \n    },\n    \"results\": no_parsed_url(result_container.get_ordered_results()),\n    \"infoboxes\": result_container.infoboxes,\n    \"suggestions\": list(result_container.suggestions),\n    \"answers\": list(result_container.answers),\n    \"paging\": result_container.paging,\n    \"results_number\": result_container.results_number()\n}\nsys.stdout = codecs.getwriter(\"UTF-8\")(sys.stdout)\nsys.stdout.write(dumps(result_container_json, sort_keys=True, indent=4, ensure_ascii=False, encoding=\"utf-8\", default=json_serial))\n",
        "source_code_len": 857,
        "target_code": "        return serial\n    if isinstance(obj, bytes):\n        return obj.decode('utf8')\n    if isinstance(obj, set):\n        return list(obj)\n    raise TypeError(\"Type ({}) not serializable\".format(type(obj)))\n\n\ndef to_dict(search_query: searx.search.SearchQuery) -> Dict[str, Any]:\n    \"\"\"Get result from parsed arguments.\"\"\"\n    result_container = searx.search.Search(search_query).search()\n    result_container_json = {\n        \"search\": {\n            \"q\": search_query.query,\n            \"pageno\": search_query.pageno,\n            \"lang\": search_query.lang,\n            \"safesearch\": search_query.safesearch,\n            \"timerange\": search_query.time_range,\n        },\n        \"results\": no_parsed_url(result_container.get_ordered_results()),\n        \"infoboxes\": result_container.infoboxes,\n        \"suggestions\": list(result_container.suggestions),\n        \"answers\": list(result_container.answers),\n        \"paging\": result_container.paging,\n        \"results_number\": result_container.results_number()\n    }\n    return result_container_json\n\n\ndef parse_argument(\n        args: Optional[List[str]]=None,\n        category_choices: EngineCategoriesVar=None\n) -> argparse.Namespace:\n    \"\"\"Parse command line.\n\n    :raise SystemExit: Query argument required on `args`\n\n    Examples:\n\n    >>> import importlib\n    ... # load module\n    ... spec = importlib.util.spec_from_file_location(\n    ...     'utils.standalone_searx', 'utils/standalone_searx.py')\n    ... sas = importlib.util.module_from_spec(spec)\n    ... spec.loader.exec_module(sas)\n    ... sas.parse_argument()\n    usage: ptipython [-h] [--category [{general}]] [--lang [LANG]] [--pageno [PAGENO]] [--safesearch [{0,1,2}]] [--timerange [{day,week,month,year}]]\n                     query\n    SystemExit: 2\n    >>> sas.parse_argument(['rain'])\n    Namespace(category='general', lang='all', pageno=1, query='rain', safesearch='0', timerange=None)\n    \"\"\"  # noqa: E501\n    if not category_choices:\n        category_choices = list(searx.engines.categories.keys())\n    parser = argparse.ArgumentParser(description='Standalone searx.')\n    parser.add_argument('query', type=str,\n                        help='Text query')\n    parser.add_argument('--category', type=str, nargs='?',\n                        choices=category_choices,\n                        default='general',\n                        help='Search category')\n    parser.add_argument('--lang', type=str, nargs='?', default='all',\n                        help='Search language')\n    parser.add_argument('--pageno', type=int, nargs='?', default=1,\n                        help='Page number starting from 1')\n    parser.add_argument(\n        '--safesearch', type=str, nargs='?',\n        choices=['0', '1', '2'], default='0',\n        help='Safe content filter from none to strict')\n    parser.add_argument(\n        '--timerange', type=str,\n        nargs='?', choices=['day', 'week', 'month', 'year'],\n        help='Filter by time range')\n    return parser.parse_args(args)\n\n\nif __name__ == '__main__':\n    searx.engines.initialize_engines(searx.settings['engines'])\n    engine_cs = list(searx.engines.categories.keys())\n    prog_args = parse_argument(category_choices=engine_cs)\n    search_q = get_search_query(prog_args, engine_categories=engine_cs)\n    res_dict = to_dict(search_q)\n    sys.stdout.write(dumps(\n        res_dict, sort_keys=True, indent=4, ensure_ascii=False,\n        default=json_serial))\n",
        "target_code_len": 3422,
        "diff_format": "@@ -85,21 +134,85 @@\n         return serial\n-    raise TypeError (\"Type not serializable\")\n-\n-result_container_json = {\n-    \"search\": {\n-        \"q\": search_query.query,\n-        \"pageno\": search_query.pageno,\n-        \"lang\": search_query.lang,\n-        \"safesearch\": search_query.safesearch,\n-        \"timerange\": search_query.time_range,\n-        \"engines\": search_query.engines  \n-    },\n-    \"results\": no_parsed_url(result_container.get_ordered_results()),\n-    \"infoboxes\": result_container.infoboxes,\n-    \"suggestions\": list(result_container.suggestions),\n-    \"answers\": list(result_container.answers),\n-    \"paging\": result_container.paging,\n-    \"results_number\": result_container.results_number()\n-}\n-sys.stdout = codecs.getwriter(\"UTF-8\")(sys.stdout)\n-sys.stdout.write(dumps(result_container_json, sort_keys=True, indent=4, ensure_ascii=False, encoding=\"utf-8\", default=json_serial))\n+    if isinstance(obj, bytes):\n+        return obj.decode('utf8')\n+    if isinstance(obj, set):\n+        return list(obj)\n+    raise TypeError(\"Type ({}) not serializable\".format(type(obj)))\n+\n+\n+def to_dict(search_query: searx.search.SearchQuery) -> Dict[str, Any]:\n+    \"\"\"Get result from parsed arguments.\"\"\"\n+    result_container = searx.search.Search(search_query).search()\n+    result_container_json = {\n+        \"search\": {\n+            \"q\": search_query.query,\n+            \"pageno\": search_query.pageno,\n+            \"lang\": search_query.lang,\n+            \"safesearch\": search_query.safesearch,\n+            \"timerange\": search_query.time_range,\n+        },\n+        \"results\": no_parsed_url(result_container.get_ordered_results()),\n+        \"infoboxes\": result_container.infoboxes,\n+        \"suggestions\": list(result_container.suggestions),\n+        \"answers\": list(result_container.answers),\n+        \"paging\": result_container.paging,\n+        \"results_number\": result_container.results_number()\n+    }\n+    return result_container_json\n+\n+\n+def parse_argument(\n+        args: Optional[List[str]]=None,\n+        category_choices: EngineCategoriesVar=None\n+) -> argparse.Namespace:\n+    \"\"\"Parse command line.\n+\n+    :raise SystemExit: Query argument required on `args`\n+\n+    Examples:\n+\n+    >>> import importlib\n+    ... # load module\n+    ... spec = importlib.util.spec_from_file_location(\n+    ...     'utils.standalone_searx', 'utils/standalone_searx.py')\n+    ... sas = importlib.util.module_from_spec(spec)\n+    ... spec.loader.exec_module(sas)\n+    ... sas.parse_argument()\n+    usage: ptipython [-h] [--category [{general}]] [--lang [LANG]] [--pageno [PAGENO]] [--safesearch [{0,1,2}]] [--timerange [{day,week,month,year}]]\n+                     query\n+    SystemExit: 2\n+    >>> sas.parse_argument(['rain'])\n+    Namespace(category='general', lang='all', pageno=1, query='rain', safesearch='0', timerange=None)\n+    \"\"\"  # noqa: E501\n+    if not category_choices:\n+        category_choices = list(searx.engines.categories.keys())\n+    parser = argparse.ArgumentParser(description='Standalone searx.')\n+    parser.add_argument('query', type=str,\n+                        help='Text query')\n+    parser.add_argument('--category', type=str, nargs='?',\n+                        choices=category_choices,\n+                        default='general',\n+                        help='Search category')\n+    parser.add_argument('--lang', type=str, nargs='?', default='all',\n+                        help='Search language')\n+    parser.add_argument('--pageno', type=int, nargs='?', default=1,\n+                        help='Page number starting from 1')\n+    parser.add_argument(\n+        '--safesearch', type=str, nargs='?',\n+        choices=['0', '1', '2'], default='0',\n+        help='Safe content filter from none to strict')\n+    parser.add_argument(\n+        '--timerange', type=str,\n+        nargs='?', choices=['day', 'week', 'month', 'year'],\n+        help='Filter by time range')\n+    return parser.parse_args(args)\n+\n+\n+if __name__ == '__main__':\n+    searx.engines.initialize_engines(searx.settings['engines'])\n+    engine_cs = list(searx.engines.categories.keys())\n+    prog_args = parse_argument(category_choices=engine_cs)\n+    search_q = get_search_query(prog_args, engine_categories=engine_cs)\n+    res_dict = to_dict(search_q)\n+    sys.stdout.write(dumps(\n+        res_dict, sort_keys=True, indent=4, ensure_ascii=False,\n+        default=json_serial))\n",
        "source_code_with_indent": "        return serial\n    <DED>raise TypeError (\"Type not serializable\")\n\n<DED>result_container_json = {\n    \"search\": {\n        \"q\": search_query.query,\n        \"pageno\": search_query.pageno,\n        \"lang\": search_query.lang,\n        \"safesearch\": search_query.safesearch,\n        \"timerange\": search_query.time_range,\n        \"engines\": search_query.engines  \n    },\n    \"results\": no_parsed_url(result_container.get_ordered_results()),\n    \"infoboxes\": result_container.infoboxes,\n    \"suggestions\": list(result_container.suggestions),\n    \"answers\": list(result_container.answers),\n    \"paging\": result_container.paging,\n    \"results_number\": result_container.results_number()\n}\nsys.stdout = codecs.getwriter(\"UTF-8\")(sys.stdout)\nsys.stdout.write(dumps(result_container_json, sort_keys=True, indent=4, ensure_ascii=False, encoding=\"utf-8\", default=json_serial))\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "        return serial\n    <DED>if isinstance(obj, bytes):\n        <IND>return obj.decode('utf8')\n    <DED>if isinstance(obj, set):\n        <IND>return list(obj)\n    <DED>raise TypeError(\"Type ({}) not serializable\".format(type(obj)))\n\n\n<DED>def to_dict(search_query: searx.search.SearchQuery) -> Dict[str, Any]:\n    <IND>\"\"\"Get result from parsed arguments.\"\"\"\n    result_container = searx.search.Search(search_query).search()\n    result_container_json = {\n        \"search\": {\n            \"q\": search_query.query,\n            \"pageno\": search_query.pageno,\n            \"lang\": search_query.lang,\n            \"safesearch\": search_query.safesearch,\n            \"timerange\": search_query.time_range,\n        },\n        \"results\": no_parsed_url(result_container.get_ordered_results()),\n        \"infoboxes\": result_container.infoboxes,\n        \"suggestions\": list(result_container.suggestions),\n        \"answers\": list(result_container.answers),\n        \"paging\": result_container.paging,\n        \"results_number\": result_container.results_number()\n    }\n    return result_container_json\n\n\n<DED>def parse_argument(\n        args: Optional[List[str]]=None,\n        category_choices: EngineCategoriesVar=None\n) -> argparse.Namespace:\n    <IND>\"\"\"Parse command line.\n\n    :raise SystemExit: Query argument required on `args`\n\n    Examples:\n\n    >>> import importlib\n    ... # load module\n    ... spec = importlib.util.spec_from_file_location(\n    ...     'utils.standalone_searx', 'utils/standalone_searx.py')\n    ... sas = importlib.util.module_from_spec(spec)\n    ... spec.loader.exec_module(sas)\n    ... sas.parse_argument()\n    usage: ptipython [-h] [--category [{general}]] [--lang [LANG]] [--pageno [PAGENO]] [--safesearch [{0,1,2}]] [--timerange [{day,week,month,year}]]\n                     query\n    SystemExit: 2\n    >>> sas.parse_argument(['rain'])\n    Namespace(category='general', lang='all', pageno=1, query='rain', safesearch='0', timerange=None)\n    \"\"\"  # noqa: E501\n    if not category_choices:\n        <IND>category_choices = list(searx.engines.categories.keys())\n    <DED>parser = argparse.ArgumentParser(description='Standalone searx.')\n    parser.add_argument('query', type=str,\n                        help='Text query')\n    parser.add_argument('--category', type=str, nargs='?',\n                        choices=category_choices,\n                        default='general',\n                        help='Search category')\n    parser.add_argument('--lang', type=str, nargs='?', default='all',\n                        help='Search language')\n    parser.add_argument('--pageno', type=int, nargs='?', default=1,\n                        help='Page number starting from 1')\n    parser.add_argument(\n        '--safesearch', type=str, nargs='?',\n        choices=['0', '1', '2'], default='0',\n        help='Safe content filter from none to strict')\n    parser.add_argument(\n        '--timerange', type=str,\n        nargs='?', choices=['day', 'week', 'month', 'year'],\n        help='Filter by time range')\n    return parser.parse_args(args)\n\n\n<DED>if __name__ == '__main__':\n    <IND>searx.engines.initialize_engines(searx.settings['engines'])\n    engine_cs = list(searx.engines.categories.keys())\n    prog_args = parse_argument(category_choices=engine_cs)\n    search_q = get_search_query(prog_args, engine_categories=engine_cs)\n    res_dict = to_dict(search_q)\n    sys.stdout.write(dumps(\n        res_dict, sort_keys=True, indent=4, ensure_ascii=False,\n        default=json_serial))\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "searx/searx",
    "commit": "c03e4c86bc49d6ef4664c038066d9f1c16e7dafc",
    "filename": "utils/standalone_searx.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/searx-searx/utils/standalone_searx.py",
    "file_hunks_size": 4,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "utils/standalone_searx.py:104:39 Incompatible parameter type [6]: Expected `typing.IO[bytes]` for 1st positional only parameter to call `codecs._StreamWriter.__call__` but got `typing.TextIO`.",
    "message": " Expected `typing.IO[bytes]` for 1st positional only parameter to call `codecs._StreamWriter.__call__` but got `typing.TextIO`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 104,
    "warning_line": "sys.stdout = codecs.getwriter(\"UTF-8\")(sys.stdout)",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "'''\n\n# set path\nfrom sys import path\nfrom os.path import realpath, dirname\npath.append(realpath(dirname(realpath(__file__)) + '/../'))\n\n# initialization\nfrom json import dumps\nfrom searx import settings\nimport sys\nimport codecs\nimport searx.query\nimport searx.search\nimport searx.engines\nimport searx.webapdater\nimport searx.preferences\nimport searx.webadapter\nimport argparse\n\nsearx.engines.initialize_engines(settings['engines'])\n\n# command line parsing\nparser = argparse.ArgumentParser(description='Standalone searx.')\nparser.add_argument('query', type=str,\n                    help='Text query')\nparser.add_argument('--category', type=str, nargs='?',\n                    choices=searx.engines.categories.keys(),\n                    default='general',\n                    help='Search category')\nparser.add_argument('--lang', type=str, nargs='?',default='all',\n                    help='Search language')\nparser.add_argument('--pageno', type=int, nargs='?', default=1,\n                    help='Page number starting from 1')\nparser.add_argument('--safesearch', type=str, nargs='?', choices=['0', '1', '2'], default='0',\n                    help='Safe content filter from none to strict')\nparser.add_argument('--timerange', type=str, nargs='?', choices=['day', 'week', 'month', 'year'],\n                    help='Filter by time range')\nargs = parser.parse_args()\n\n# search results for the query\nform = {\n    \"q\":args.query,\n    \"categories\":args.category.decode(),\n    \"pageno\":str(args.pageno),\n    \"language\":args.lang,\n    \"time_range\":args.timerange\n}\npreferences = searx.preferences.Preferences(['oscar'], searx.engines.categories.keys(), searx.engines.engines, [])\npreferences.key_value_settings['safesearch'].parse(args.safesearch)\n\nsearch_query, raw_text_query, _, _ = searx.webadapter.get_search_query_from_webapp(preferences, form)\nsearch = searx.search.Search(search_query)\nresult_container = search.search()\n\n# output\nfrom datetime import datetime\n\ndef no_parsed_url(results):\n    for result in results:\n",
        "source_code_len": 2018,
        "target_code": "'''\n# pylint: disable=wrong-import-position\nimport argparse\nimport sys\nfrom datetime import datetime\nfrom json import dumps\nfrom typing import Any, Dict, List, Optional\n\nimport searx\nimport searx.engines\nimport searx.preferences\nimport searx.query\nimport searx.search\nimport searx.webadapter\n\nEngineCategoriesVar = Optional[List[str]]\n\n\ndef get_search_query(\n        args: argparse.Namespace, engine_categories: EngineCategoriesVar = None\n) -> searx.search.SearchQuery:\n    \"\"\"Get  search results for the query\"\"\"\n    if engine_categories is None:\n        engine_categories = list(searx.engines.categories.keys())\n    try:\n        category = args.category.decode('utf-8')\n    except AttributeError:\n        category = args.category\n    form = {\n        \"q\": args.query,\n        \"categories\": category,\n        \"pageno\": str(args.pageno),\n        \"language\": args.lang,\n        \"time_range\": args.timerange\n    }\n    preferences = searx.preferences.Preferences(\n        ['oscar'], engine_categories, searx.engines.engines, [])\n    preferences.key_value_settings['safesearch'].parse(args.safesearch)\n\n    search_query = searx.webadapter.get_search_query_from_webapp(\n        preferences, form)[0]\n    return search_query\n\n\ndef no_parsed_url(results: List[Dict[str, Any]]) -> List[Dict[str, Any]]:\n    \"\"\"Remove parsed url from dict.\"\"\"\n    for result in results:\n",
        "target_code_len": 1361,
        "diff_format": "@@ -18,60 +76,47 @@\n '''\n-\n-# set path\n-from sys import path\n-from os.path import realpath, dirname\n-path.append(realpath(dirname(realpath(__file__)) + '/../'))\n-\n-# initialization\n+# pylint: disable=wrong-import-position\n+import argparse\n+import sys\n+from datetime import datetime\n from json import dumps\n-from searx import settings\n-import sys\n-import codecs\n+from typing import Any, Dict, List, Optional\n+\n+import searx\n+import searx.engines\n+import searx.preferences\n import searx.query\n import searx.search\n-import searx.engines\n-import searx.webapdater\n-import searx.preferences\n import searx.webadapter\n-import argparse\n-\n-searx.engines.initialize_engines(settings['engines'])\n-\n-# command line parsing\n-parser = argparse.ArgumentParser(description='Standalone searx.')\n-parser.add_argument('query', type=str,\n-                    help='Text query')\n-parser.add_argument('--category', type=str, nargs='?',\n-                    choices=searx.engines.categories.keys(),\n-                    default='general',\n-                    help='Search category')\n-parser.add_argument('--lang', type=str, nargs='?',default='all',\n-                    help='Search language')\n-parser.add_argument('--pageno', type=int, nargs='?', default=1,\n-                    help='Page number starting from 1')\n-parser.add_argument('--safesearch', type=str, nargs='?', choices=['0', '1', '2'], default='0',\n-                    help='Safe content filter from none to strict')\n-parser.add_argument('--timerange', type=str, nargs='?', choices=['day', 'week', 'month', 'year'],\n-                    help='Filter by time range')\n-args = parser.parse_args()\n-\n-# search results for the query\n-form = {\n-    \"q\":args.query,\n-    \"categories\":args.category.decode(),\n-    \"pageno\":str(args.pageno),\n-    \"language\":args.lang,\n-    \"time_range\":args.timerange\n-}\n-preferences = searx.preferences.Preferences(['oscar'], searx.engines.categories.keys(), searx.engines.engines, [])\n-preferences.key_value_settings['safesearch'].parse(args.safesearch)\n-\n-search_query, raw_text_query, _, _ = searx.webadapter.get_search_query_from_webapp(preferences, form)\n-search = searx.search.Search(search_query)\n-result_container = search.search()\n-\n-# output\n-from datetime import datetime\n-\n-def no_parsed_url(results):\n+\n+EngineCategoriesVar = Optional[List[str]]\n+\n+\n+def get_search_query(\n+        args: argparse.Namespace, engine_categories: EngineCategoriesVar = None\n+) -> searx.search.SearchQuery:\n+    \"\"\"Get  search results for the query\"\"\"\n+    if engine_categories is None:\n+        engine_categories = list(searx.engines.categories.keys())\n+    try:\n+        category = args.category.decode('utf-8')\n+    except AttributeError:\n+        category = args.category\n+    form = {\n+        \"q\": args.query,\n+        \"categories\": category,\n+        \"pageno\": str(args.pageno),\n+        \"language\": args.lang,\n+        \"time_range\": args.timerange\n+    }\n+    preferences = searx.preferences.Preferences(\n+        ['oscar'], engine_categories, searx.engines.engines, [])\n+    preferences.key_value_settings['safesearch'].parse(args.safesearch)\n+\n+    search_query = searx.webadapter.get_search_query_from_webapp(\n+        preferences, form)[0]\n+    return search_query\n+\n+\n+def no_parsed_url(results: List[Dict[str, Any]]) -> List[Dict[str, Any]]:\n+    \"\"\"Remove parsed url from dict.\"\"\"\n     for result in results:\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\n\n# set path\nfrom sys import path\nfrom os.path import realpath, dirname\npath.append(realpath(dirname(realpath(__file__)) + '/../'))\n\n# initialization\nfrom json import dumps\nfrom searx import settings\nimport sys\nimport codecs\nimport searx.query\nimport searx.search\nimport searx.engines\nimport searx.webapdater\nimport searx.preferences\nimport searx.webadapter\nimport argparse\n\nsearx.engines.initialize_engines(settings['engines'])\n\n# command line parsing\nparser = argparse.ArgumentParser(description='Standalone searx.')\nparser.add_argument('query', type=str,\n                    help='Text query')\nparser.add_argument('--category', type=str, nargs='?',\n                    choices=searx.engines.categories.keys(),\n                    default='general',\n                    help='Search category')\nparser.add_argument('--lang', type=str, nargs='?',default='all',\n                    help='Search language')\nparser.add_argument('--pageno', type=int, nargs='?', default=1,\n                    help='Page number starting from 1')\nparser.add_argument('--safesearch', type=str, nargs='?', choices=['0', '1', '2'], default='0',\n                    help='Safe content filter from none to strict')\nparser.add_argument('--timerange', type=str, nargs='?', choices=['day', 'week', 'month', 'year'],\n                    help='Filter by time range')\nargs = parser.parse_args()\n\n# search results for the query\nform = {\n    \"q\":args.query,\n    \"categories\":args.category.decode(),\n    \"pageno\":str(args.pageno),\n    \"language\":args.lang,\n    \"time_range\":args.timerange\n}\npreferences = searx.preferences.Preferences(['oscar'], searx.engines.categories.keys(), searx.engines.engines, [])\npreferences.key_value_settings['safesearch'].parse(args.safesearch)\n\nsearch_query, raw_text_query, _, _ = searx.webadapter.get_search_query_from_webapp(preferences, form)\nsearch = searx.search.Search(search_query)\nresult_container = search.search()\n\n# output\nfrom datetime import datetime\n\ndef no_parsed_url(results):\n    <IND>for result in results:\n",
        "target_code_with_indent": "\n# pylint: disable=wrong-import-position\nimport argparse\nimport sys\nfrom datetime import datetime\nfrom json import dumps\nfrom typing import Any, Dict, List, Optional\n\nimport searx\nimport searx.engines\nimport searx.preferences\nimport searx.query\nimport searx.search\nimport searx.webadapter\n\nEngineCategoriesVar = Optional[List[str]]\n\n\ndef get_search_query(\n        args: argparse.Namespace, engine_categories: EngineCategoriesVar = None\n) -> searx.search.SearchQuery:\n    <IND>\"\"\"Get  search results for the query\"\"\"\n    if engine_categories is None:\n        <IND>engine_categories = list(searx.engines.categories.keys())\n    <DED>try:\n        <IND>category = args.category.decode('utf-8')\n    <DED>except AttributeError:\n        <IND>category = args.category\n    <DED>form = {\n        \"q\": args.query,\n        \"categories\": category,\n        \"pageno\": str(args.pageno),\n        \"language\": args.lang,\n        \"time_range\": args.timerange\n    }\n    preferences = searx.preferences.Preferences(\n        ['oscar'], engine_categories, searx.engines.engines, [])\n    preferences.key_value_settings['safesearch'].parse(args.safesearch)\n\n    search_query = searx.webadapter.get_search_query_from_webapp(\n        preferences, form)[0]\n    return search_query\n\n\n<DED>def no_parsed_url(results: List[Dict[str, Any]]) -> List[Dict[str, Any]]:\n    <IND>\"\"\"Remove parsed url from dict.\"\"\"\n    for result in results:\n"
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "        return serial\n    raise TypeError (\"Type not serializable\")\n\nresult_container_json = {\n    \"search\": {\n        \"q\": search_query.query,\n        \"pageno\": search_query.pageno,\n        \"lang\": search_query.lang,\n        \"safesearch\": search_query.safesearch,\n        \"timerange\": search_query.time_range,\n        \"engines\": search_query.engines  \n    },\n    \"results\": no_parsed_url(result_container.get_ordered_results()),\n    \"infoboxes\": result_container.infoboxes,\n    \"suggestions\": list(result_container.suggestions),\n    \"answers\": list(result_container.answers),\n    \"paging\": result_container.paging,\n    \"results_number\": result_container.results_number()\n}\nsys.stdout = codecs.getwriter(\"UTF-8\")(sys.stdout)\nsys.stdout.write(dumps(result_container_json, sort_keys=True, indent=4, ensure_ascii=False, encoding=\"utf-8\", default=json_serial))\n",
        "source_code_len": 857,
        "target_code": "        return serial\n    if isinstance(obj, bytes):\n        return obj.decode('utf8')\n    if isinstance(obj, set):\n        return list(obj)\n    raise TypeError(\"Type ({}) not serializable\".format(type(obj)))\n\n\ndef to_dict(search_query: searx.search.SearchQuery) -> Dict[str, Any]:\n    \"\"\"Get result from parsed arguments.\"\"\"\n    result_container = searx.search.Search(search_query).search()\n    result_container_json = {\n        \"search\": {\n            \"q\": search_query.query,\n            \"pageno\": search_query.pageno,\n            \"lang\": search_query.lang,\n            \"safesearch\": search_query.safesearch,\n            \"timerange\": search_query.time_range,\n        },\n        \"results\": no_parsed_url(result_container.get_ordered_results()),\n        \"infoboxes\": result_container.infoboxes,\n        \"suggestions\": list(result_container.suggestions),\n        \"answers\": list(result_container.answers),\n        \"paging\": result_container.paging,\n        \"results_number\": result_container.results_number()\n    }\n    return result_container_json\n\n\ndef parse_argument(\n        args: Optional[List[str]]=None,\n        category_choices: EngineCategoriesVar=None\n) -> argparse.Namespace:\n    \"\"\"Parse command line.\n\n    :raise SystemExit: Query argument required on `args`\n\n    Examples:\n\n    >>> import importlib\n    ... # load module\n    ... spec = importlib.util.spec_from_file_location(\n    ...     'utils.standalone_searx', 'utils/standalone_searx.py')\n    ... sas = importlib.util.module_from_spec(spec)\n    ... spec.loader.exec_module(sas)\n    ... sas.parse_argument()\n    usage: ptipython [-h] [--category [{general}]] [--lang [LANG]] [--pageno [PAGENO]] [--safesearch [{0,1,2}]] [--timerange [{day,week,month,year}]]\n                     query\n    SystemExit: 2\n    >>> sas.parse_argument(['rain'])\n    Namespace(category='general', lang='all', pageno=1, query='rain', safesearch='0', timerange=None)\n    \"\"\"  # noqa: E501\n    if not category_choices:\n        category_choices = list(searx.engines.categories.keys())\n    parser = argparse.ArgumentParser(description='Standalone searx.')\n    parser.add_argument('query', type=str,\n                        help='Text query')\n    parser.add_argument('--category', type=str, nargs='?',\n                        choices=category_choices,\n                        default='general',\n                        help='Search category')\n    parser.add_argument('--lang', type=str, nargs='?', default='all',\n                        help='Search language')\n    parser.add_argument('--pageno', type=int, nargs='?', default=1,\n                        help='Page number starting from 1')\n    parser.add_argument(\n        '--safesearch', type=str, nargs='?',\n        choices=['0', '1', '2'], default='0',\n        help='Safe content filter from none to strict')\n    parser.add_argument(\n        '--timerange', type=str,\n        nargs='?', choices=['day', 'week', 'month', 'year'],\n        help='Filter by time range')\n    return parser.parse_args(args)\n\n\nif __name__ == '__main__':\n    searx.engines.initialize_engines(searx.settings['engines'])\n    engine_cs = list(searx.engines.categories.keys())\n    prog_args = parse_argument(category_choices=engine_cs)\n    search_q = get_search_query(prog_args, engine_categories=engine_cs)\n    res_dict = to_dict(search_q)\n    sys.stdout.write(dumps(\n        res_dict, sort_keys=True, indent=4, ensure_ascii=False,\n        default=json_serial))\n",
        "target_code_len": 3422,
        "diff_format": "@@ -85,21 +134,85 @@\n         return serial\n-    raise TypeError (\"Type not serializable\")\n-\n-result_container_json = {\n-    \"search\": {\n-        \"q\": search_query.query,\n-        \"pageno\": search_query.pageno,\n-        \"lang\": search_query.lang,\n-        \"safesearch\": search_query.safesearch,\n-        \"timerange\": search_query.time_range,\n-        \"engines\": search_query.engines  \n-    },\n-    \"results\": no_parsed_url(result_container.get_ordered_results()),\n-    \"infoboxes\": result_container.infoboxes,\n-    \"suggestions\": list(result_container.suggestions),\n-    \"answers\": list(result_container.answers),\n-    \"paging\": result_container.paging,\n-    \"results_number\": result_container.results_number()\n-}\n-sys.stdout = codecs.getwriter(\"UTF-8\")(sys.stdout)\n-sys.stdout.write(dumps(result_container_json, sort_keys=True, indent=4, ensure_ascii=False, encoding=\"utf-8\", default=json_serial))\n+    if isinstance(obj, bytes):\n+        return obj.decode('utf8')\n+    if isinstance(obj, set):\n+        return list(obj)\n+    raise TypeError(\"Type ({}) not serializable\".format(type(obj)))\n+\n+\n+def to_dict(search_query: searx.search.SearchQuery) -> Dict[str, Any]:\n+    \"\"\"Get result from parsed arguments.\"\"\"\n+    result_container = searx.search.Search(search_query).search()\n+    result_container_json = {\n+        \"search\": {\n+            \"q\": search_query.query,\n+            \"pageno\": search_query.pageno,\n+            \"lang\": search_query.lang,\n+            \"safesearch\": search_query.safesearch,\n+            \"timerange\": search_query.time_range,\n+        },\n+        \"results\": no_parsed_url(result_container.get_ordered_results()),\n+        \"infoboxes\": result_container.infoboxes,\n+        \"suggestions\": list(result_container.suggestions),\n+        \"answers\": list(result_container.answers),\n+        \"paging\": result_container.paging,\n+        \"results_number\": result_container.results_number()\n+    }\n+    return result_container_json\n+\n+\n+def parse_argument(\n+        args: Optional[List[str]]=None,\n+        category_choices: EngineCategoriesVar=None\n+) -> argparse.Namespace:\n+    \"\"\"Parse command line.\n+\n+    :raise SystemExit: Query argument required on `args`\n+\n+    Examples:\n+\n+    >>> import importlib\n+    ... # load module\n+    ... spec = importlib.util.spec_from_file_location(\n+    ...     'utils.standalone_searx', 'utils/standalone_searx.py')\n+    ... sas = importlib.util.module_from_spec(spec)\n+    ... spec.loader.exec_module(sas)\n+    ... sas.parse_argument()\n+    usage: ptipython [-h] [--category [{general}]] [--lang [LANG]] [--pageno [PAGENO]] [--safesearch [{0,1,2}]] [--timerange [{day,week,month,year}]]\n+                     query\n+    SystemExit: 2\n+    >>> sas.parse_argument(['rain'])\n+    Namespace(category='general', lang='all', pageno=1, query='rain', safesearch='0', timerange=None)\n+    \"\"\"  # noqa: E501\n+    if not category_choices:\n+        category_choices = list(searx.engines.categories.keys())\n+    parser = argparse.ArgumentParser(description='Standalone searx.')\n+    parser.add_argument('query', type=str,\n+                        help='Text query')\n+    parser.add_argument('--category', type=str, nargs='?',\n+                        choices=category_choices,\n+                        default='general',\n+                        help='Search category')\n+    parser.add_argument('--lang', type=str, nargs='?', default='all',\n+                        help='Search language')\n+    parser.add_argument('--pageno', type=int, nargs='?', default=1,\n+                        help='Page number starting from 1')\n+    parser.add_argument(\n+        '--safesearch', type=str, nargs='?',\n+        choices=['0', '1', '2'], default='0',\n+        help='Safe content filter from none to strict')\n+    parser.add_argument(\n+        '--timerange', type=str,\n+        nargs='?', choices=['day', 'week', 'month', 'year'],\n+        help='Filter by time range')\n+    return parser.parse_args(args)\n+\n+\n+if __name__ == '__main__':\n+    searx.engines.initialize_engines(searx.settings['engines'])\n+    engine_cs = list(searx.engines.categories.keys())\n+    prog_args = parse_argument(category_choices=engine_cs)\n+    search_q = get_search_query(prog_args, engine_categories=engine_cs)\n+    res_dict = to_dict(search_q)\n+    sys.stdout.write(dumps(\n+        res_dict, sort_keys=True, indent=4, ensure_ascii=False,\n+        default=json_serial))\n",
        "source_code_with_indent": "        return serial\n    <DED>raise TypeError (\"Type not serializable\")\n\n<DED>result_container_json = {\n    \"search\": {\n        \"q\": search_query.query,\n        \"pageno\": search_query.pageno,\n        \"lang\": search_query.lang,\n        \"safesearch\": search_query.safesearch,\n        \"timerange\": search_query.time_range,\n        \"engines\": search_query.engines  \n    },\n    \"results\": no_parsed_url(result_container.get_ordered_results()),\n    \"infoboxes\": result_container.infoboxes,\n    \"suggestions\": list(result_container.suggestions),\n    \"answers\": list(result_container.answers),\n    \"paging\": result_container.paging,\n    \"results_number\": result_container.results_number()\n}\nsys.stdout = codecs.getwriter(\"UTF-8\")(sys.stdout)\nsys.stdout.write(dumps(result_container_json, sort_keys=True, indent=4, ensure_ascii=False, encoding=\"utf-8\", default=json_serial))\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "        return serial\n    <DED>if isinstance(obj, bytes):\n        <IND>return obj.decode('utf8')\n    <DED>if isinstance(obj, set):\n        <IND>return list(obj)\n    <DED>raise TypeError(\"Type ({}) not serializable\".format(type(obj)))\n\n\n<DED>def to_dict(search_query: searx.search.SearchQuery) -> Dict[str, Any]:\n    <IND>\"\"\"Get result from parsed arguments.\"\"\"\n    result_container = searx.search.Search(search_query).search()\n    result_container_json = {\n        \"search\": {\n            \"q\": search_query.query,\n            \"pageno\": search_query.pageno,\n            \"lang\": search_query.lang,\n            \"safesearch\": search_query.safesearch,\n            \"timerange\": search_query.time_range,\n        },\n        \"results\": no_parsed_url(result_container.get_ordered_results()),\n        \"infoboxes\": result_container.infoboxes,\n        \"suggestions\": list(result_container.suggestions),\n        \"answers\": list(result_container.answers),\n        \"paging\": result_container.paging,\n        \"results_number\": result_container.results_number()\n    }\n    return result_container_json\n\n\n<DED>def parse_argument(\n        args: Optional[List[str]]=None,\n        category_choices: EngineCategoriesVar=None\n) -> argparse.Namespace:\n    <IND>\"\"\"Parse command line.\n\n    :raise SystemExit: Query argument required on `args`\n\n    Examples:\n\n    >>> import importlib\n    ... # load module\n    ... spec = importlib.util.spec_from_file_location(\n    ...     'utils.standalone_searx', 'utils/standalone_searx.py')\n    ... sas = importlib.util.module_from_spec(spec)\n    ... spec.loader.exec_module(sas)\n    ... sas.parse_argument()\n    usage: ptipython [-h] [--category [{general}]] [--lang [LANG]] [--pageno [PAGENO]] [--safesearch [{0,1,2}]] [--timerange [{day,week,month,year}]]\n                     query\n    SystemExit: 2\n    >>> sas.parse_argument(['rain'])\n    Namespace(category='general', lang='all', pageno=1, query='rain', safesearch='0', timerange=None)\n    \"\"\"  # noqa: E501\n    if not category_choices:\n        <IND>category_choices = list(searx.engines.categories.keys())\n    <DED>parser = argparse.ArgumentParser(description='Standalone searx.')\n    parser.add_argument('query', type=str,\n                        help='Text query')\n    parser.add_argument('--category', type=str, nargs='?',\n                        choices=category_choices,\n                        default='general',\n                        help='Search category')\n    parser.add_argument('--lang', type=str, nargs='?', default='all',\n                        help='Search language')\n    parser.add_argument('--pageno', type=int, nargs='?', default=1,\n                        help='Page number starting from 1')\n    parser.add_argument(\n        '--safesearch', type=str, nargs='?',\n        choices=['0', '1', '2'], default='0',\n        help='Safe content filter from none to strict')\n    parser.add_argument(\n        '--timerange', type=str,\n        nargs='?', choices=['day', 'week', 'month', 'year'],\n        help='Filter by time range')\n    return parser.parse_args(args)\n\n\n<DED>if __name__ == '__main__':\n    <IND>searx.engines.initialize_engines(searx.settings['engines'])\n    engine_cs = list(searx.engines.categories.keys())\n    prog_args = parse_argument(category_choices=engine_cs)\n    search_q = get_search_query(prog_args, engine_categories=engine_cs)\n    res_dict = to_dict(search_q)\n    sys.stdout.write(dumps(\n        res_dict, sort_keys=True, indent=4, ensure_ascii=False,\n        default=json_serial))\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  }
]