[
  {
    "project": "TheAlgorithms/Python",
    "commit": "2595cf059d677c39513a9d75f1736bc5b84d6298",
    "filename": "data_structures/binary_tree/lazy_segment_tree.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/TheAlgorithms-Python/data_structures/binary_tree/lazy_segment_tree.py",
    "file_hunks_size": 4,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "data_structures/binary_tree/lazy_segment_tree.py:113:12 Incompatible return type [7]: Expected `int` but got `float`.",
    "message": " Expected `int` but got `float`.",
    "rule_id": "Incompatible return type [7]",
    "warning_line_no": 113,
    "warning_line": "            return -math.inf",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "import math\n\n",
        "source_code_len": 13,
        "target_code": "import math\nfrom typing import List, Union\n\n",
        "target_code_len": 44,
        "diff_format": "@@ -3,2 +3,3 @@\n import math\n+from typing import List, Union\n \n",
        "source_code_with_indent": "import math\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "import math\nfrom typing import List, Union\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "        self, idx: int, left_element: int, right_element: int, a: int, b: int\n    ) -> int:\n        \"\"\"\n",
        "source_code_len": 104,
        "target_code": "        self, idx: int, left_element: int, right_element: int, a: int, b: int\n    ) -> Union[int, float]:\n        \"\"\"\n",
        "target_code_len": 118,
        "diff_format": "@@ -90,3 +91,3 @@\n         self, idx: int, left_element: int, right_element: int, a: int, b: int\n-    ) -> int:\n+    ) -> Union[int, float]:\n         \"\"\"\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "        self, idx: int, left_element: int, right_element: int, a: int, b: int\n    ) -> int:\n        <IND>",
        "target_code_with_indent": "        self, idx: int, left_element: int, right_element: int, a: int, b: int\n    ) -> Union[int, float]:\n        <IND>"
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n    def __str__(self) -> None:\n        return [self.query(1, 1, self.size, i, i) for i in range(1, self.size + 1)]\n\n",
        "source_code_len": 117,
        "target_code": "\n    def __str__(self) -> str:\n        return str([self.query(1, 1, self.size, i, i) for i in range(1, self.size + 1)])\n\n",
        "target_code_len": 121,
        "diff_format": "@@ -120,4 +121,4 @@\n \n-    def __str__(self) -> None:\n-        return [self.query(1, 1, self.size, i, i) for i in range(1, self.size + 1)]\n+    def __str__(self) -> str:\n+        return str([self.query(1, 1, self.size, i, i) for i in range(1, self.size + 1)])\n \n",
        "source_code_with_indent": "\n    <DED>def __str__(self) -> None:\n        <IND>return [self.query(1, 1, self.size, i, i) for i in range(1, self.size + 1)]\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n    <DED>def __str__(self) -> str:\n        <IND>return str([self.query(1, 1, self.size, i, i) for i in range(1, self.size + 1)])\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "TheAlgorithms/Python",
    "commit": "2595cf059d677c39513a9d75f1736bc5b84d6298",
    "filename": "data_structures/binary_tree/lazy_segment_tree.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/TheAlgorithms-Python/data_structures/binary_tree/lazy_segment_tree.py",
    "file_hunks_size": 4,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": true,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "data_structures/binary_tree/lazy_segment_tree.py:121:4 Inconsistent override [15]: `data_structures.binary_tree.lazy_segment_tree.SegmentTree.__str__` overrides method defined in `object` inconsistently. Returned type `None` is not a subtype of the overridden return `str`.",
    "message": " `data_structures.binary_tree.lazy_segment_tree.SegmentTree.__str__` overrides method defined in `object` inconsistently. Returned type `None` is not a subtype of the overridden return `str`.",
    "rule_id": "Inconsistent override [15]",
    "warning_line_no": 121,
    "warning_line": "    def __str__(self) -> None:",
    "min_patch": [
      {
        "hunk_fit_TFix": true,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n    def __str__(self) -> None:\n        return [self.query(1, 1, self.size, i, i) for i in range(1, self.size + 1)]\n\n",
        "source_code_len": 117,
        "target_code": "\n    def __str__(self) -> str:\n        return str([self.query(1, 1, self.size, i, i) for i in range(1, self.size + 1)])\n\n",
        "target_code_len": 121,
        "diff_format": "@@ -120,4 +121,4 @@\n \n-    def __str__(self) -> None:\n-        return [self.query(1, 1, self.size, i, i) for i in range(1, self.size + 1)]\n+    def __str__(self) -> str:\n+        return str([self.query(1, 1, self.size, i, i) for i in range(1, self.size + 1)])\n \n",
        "source_code_with_indent": "\n    <DED>def __str__(self) -> None:\n        <IND>return [self.query(1, 1, self.size, i, i) for i in range(1, self.size + 1)]\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n    <DED>def __str__(self) -> str:\n        <IND>return str([self.query(1, 1, self.size, i, i) for i in range(1, self.size + 1)])\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "TheAlgorithms/Python",
    "commit": "2595cf059d677c39513a9d75f1736bc5b84d6298",
    "filename": "data_structures/binary_tree/lazy_segment_tree.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/TheAlgorithms-Python/data_structures/binary_tree/lazy_segment_tree.py",
    "file_hunks_size": 4,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": true,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "data_structures/binary_tree/lazy_segment_tree.py:122:8 Incompatible return type [7]: Expected `None` but got `typing.List[int]`.",
    "message": " Expected `None` but got `typing.List[int]`.",
    "rule_id": "Incompatible return type [7]",
    "warning_line_no": 122,
    "warning_line": "        return [self.query(1, 1, self.size, i, i) for i in range(1, self.size + 1)]",
    "min_patch": [
      {
        "hunk_fit_TFix": true,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n    def __str__(self) -> None:\n        return [self.query(1, 1, self.size, i, i) for i in range(1, self.size + 1)]\n\n",
        "source_code_len": 117,
        "target_code": "\n    def __str__(self) -> str:\n        return str([self.query(1, 1, self.size, i, i) for i in range(1, self.size + 1)])\n\n",
        "target_code_len": 121,
        "diff_format": "@@ -120,4 +121,4 @@\n \n-    def __str__(self) -> None:\n-        return [self.query(1, 1, self.size, i, i) for i in range(1, self.size + 1)]\n+    def __str__(self) -> str:\n+        return str([self.query(1, 1, self.size, i, i) for i in range(1, self.size + 1)])\n \n",
        "source_code_with_indent": "\n    <DED>def __str__(self) -> None:\n        <IND>return [self.query(1, 1, self.size, i, i) for i in range(1, self.size + 1)]\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n    <DED>def __str__(self) -> str:\n        <IND>return str([self.query(1, 1, self.size, i, i) for i in range(1, self.size + 1)])\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "TheAlgorithms/Python",
    "commit": "2595cf059d677c39513a9d75f1736bc5b84d6298",
    "filename": "data_structures/binary_tree/treap.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/TheAlgorithms-Python/data_structures/binary_tree/treap.py",
    "file_hunks_size": 12,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "data_structures/binary_tree/treap.py:14:23 Incompatible variable type [9]: value is declared to have type `int` but is used as type `None`.",
    "message": " value is declared to have type `int` but is used as type `None`.",
    "rule_id": "Incompatible variable type [9]",
    "warning_line_no": 14,
    "warning_line": "    def __init__(self, value: int = None):",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "from random import random\n\n",
        "source_code_len": 27,
        "target_code": "from random import random\nfrom typing import Optional, Tuple\n\n",
        "target_code_len": 62,
        "diff_format": "@@ -5,2 +5,3 @@\n from random import random\n+from typing import Optional, Tuple\n \n",
        "source_code_with_indent": "from random import random\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "from random import random\nfrom typing import Optional, Tuple\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n    def __init__(self, value: int = None):\n        self.value = value\n        self.prior = random()\n        self.left = None\n        self.right = None\n\n    def __repr__(self):\n        from pprint import pformat\n",
        "source_code_len": 212,
        "target_code": "\n    def __init__(self, value: Optional[int] = None):\n        self.value = value\n        self.prior = random()\n        self.left: Optional[Node] = None\n        self.right: Optional[Node] = None\n\n    def __repr__(self) -> str:\n        from pprint import pformat\n",
        "target_code_len": 261,
        "diff_format": "@@ -13,9 +14,9 @@\n \n-    def __init__(self, value: int = None):\n+    def __init__(self, value: Optional[int] = None):\n         self.value = value\n         self.prior = random()\n-        self.left = None\n-        self.right = None\n+        self.left: Optional[Node] = None\n+        self.right: Optional[Node] = None\n \n-    def __repr__(self):\n+    def __repr__(self) -> str:\n         from pprint import pformat\n",
        "source_code_with_indent": "\n    def __init__(self, value: int = None):\n        <IND>self.value = value\n        self.prior = random()\n        self.left = None\n        self.right = None\n\n    <DED>def __repr__(self):\n        <IND>from pprint import pformat\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n    def __init__(self, value: Optional[int] = None):\n        <IND>self.value = value\n        self.prior = random()\n        self.left: Optional[Node] = None\n        self.right: Optional[Node] = None\n\n    <DED>def __repr__(self) -> str:\n        <IND>from pprint import pformat\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\ndef split(root: Node, value: int) -> tuple[Node, Node]:\n    \"\"\"\n",
        "source_code_len": 65,
        "target_code": "\ndef split(root: Optional[Node], value: int) -> Tuple[Optional[Node], Optional[Node]]:\n    \"\"\"\n",
        "target_code_len": 95,
        "diff_format": "@@ -36,3 +37,3 @@\n \n-def split(root: Node, value: int) -> tuple[Node, Node]:\n+def split(root: Optional[Node], value: int) -> Tuple[Optional[Node], Optional[Node]]:\n     \"\"\"\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\n<DED><DED>def split(root: Node, value: int) -> tuple[Node, Node]:\n    <IND>",
        "target_code_with_indent": "\n<DED><DED>def split(root: Optional[Node], value: int) -> Tuple[Optional[Node], Optional[Node]]:\n    <IND>"
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "            root.right, right = split(root.right, value)\n            return (root, right)\n\n\ndef merge(left: Node, right: Node) -> Node:\n    \"\"\"\n",
        "source_code_len": 144,
        "target_code": "            root.right, right = split(root.right, value)\n            return root, right\n\n\ndef merge(left: Optional[Node], right: Optional[Node]) -> Optional[Node]:\n    \"\"\"\n",
        "target_code_len": 172,
        "diff_format": "@@ -62,6 +63,6 @@\n             root.right, right = split(root.right, value)\n-            return (root, right)\n+            return root, right\n \n \n-def merge(left: Node, right: Node) -> Node:\n+def merge(left: Optional[Node], right: Optional[Node]) -> Optional[Node]:\n     \"\"\"\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "            root.right, right = split(root.right, value)\n            return (root, right)\n\n\n<DED><DED><DED>def merge(left: Node, right: Node) -> Node:\n    <IND>",
        "target_code_with_indent": "            root.right, right = split(root.right, value)\n            return root, right\n\n\n<DED><DED><DED>def merge(left: Optional[Node], right: Optional[Node]) -> Optional[Node]:\n    <IND>"
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\ndef insert(root: Node, value: int) -> Node:\n    \"\"\"\n",
        "source_code_len": 53,
        "target_code": "\ndef insert(root: Optional[Node], value: int) -> Optional[Node]:\n    \"\"\"\n",
        "target_code_len": 73,
        "diff_format": "@@ -87,3 +88,3 @@\n \n-def insert(root: Node, value: int) -> Node:\n+def insert(root: Optional[Node], value: int) -> Optional[Node]:\n     \"\"\"\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\n<DED><DED>def insert(root: Node, value: int) -> Node:\n    <IND>",
        "target_code_with_indent": "\n<DED><DED>def insert(root: Optional[Node], value: int) -> Optional[Node]:\n    <IND>"
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\ndef erase(root: Node, value: int) -> Node:\n    \"\"\"\n",
        "source_code_len": 52,
        "target_code": "\ndef erase(root: Optional[Node], value: int) -> Optional[Node]:\n    \"\"\"\n",
        "target_code_len": 72,
        "diff_format": "@@ -100,3 +101,3 @@\n \n-def erase(root: Node, value: int) -> Node:\n+def erase(root: Optional[Node], value: int) -> Optional[Node]:\n     \"\"\"\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\n<DED>def erase(root: Node, value: int) -> Node:\n    <IND>",
        "target_code_with_indent": "\n<DED>def erase(root: Optional[Node], value: int) -> Optional[Node]:\n    <IND>"
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\ndef inorder(root: Node):\n    \"\"\"\n",
        "source_code_len": 34,
        "target_code": "\ndef inorder(root: Optional[Node]) -> None:\n    \"\"\"\n",
        "target_code_len": 52,
        "diff_format": "@@ -113,3 +114,3 @@\n \n-def inorder(root: Node):\n+def inorder(root: Optional[Node]) -> None:\n     \"\"\"\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\n<DED>def inorder(root: Node):\n    <IND>",
        "target_code_with_indent": "\n<DED>def inorder(root: Optional[Node]) -> None:\n    <IND>"
      }
    ]
  },
  {
    "project": "TheAlgorithms/Python",
    "commit": "2595cf059d677c39513a9d75f1736bc5b84d6298",
    "filename": "data_structures/binary_tree/treap.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/TheAlgorithms-Python/data_structures/binary_tree/treap.py",
    "file_hunks_size": 12,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "data_structures/binary_tree/treap.py:45:8 Incompatible return type [7]: Expected `typing.Tuple[Node, Node]` but got `typing.Tuple[None, None]`.",
    "message": " Expected `typing.Tuple[Node, Node]` but got `typing.Tuple[None, None]`.",
    "rule_id": "Incompatible return type [7]",
    "warning_line_no": 45,
    "warning_line": "        return (None, None)",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "from random import random\n\n",
        "source_code_len": 27,
        "target_code": "from random import random\nfrom typing import Optional, Tuple\n\n",
        "target_code_len": 62,
        "diff_format": "@@ -5,2 +5,3 @@\n from random import random\n+from typing import Optional, Tuple\n \n",
        "source_code_with_indent": "from random import random\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "from random import random\nfrom typing import Optional, Tuple\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\ndef split(root: Node, value: int) -> tuple[Node, Node]:\n    \"\"\"\n",
        "source_code_len": 65,
        "target_code": "\ndef split(root: Optional[Node], value: int) -> Tuple[Optional[Node], Optional[Node]]:\n    \"\"\"\n",
        "target_code_len": 95,
        "diff_format": "@@ -36,3 +37,3 @@\n \n-def split(root: Node, value: int) -> tuple[Node, Node]:\n+def split(root: Optional[Node], value: int) -> Tuple[Optional[Node], Optional[Node]]:\n     \"\"\"\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\n<DED><DED>def split(root: Node, value: int) -> tuple[Node, Node]:\n    <IND>",
        "target_code_with_indent": "\n<DED><DED>def split(root: Optional[Node], value: int) -> Tuple[Optional[Node], Optional[Node]]:\n    <IND>"
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "            root.right, right = split(root.right, value)\n            return (root, right)\n\n\ndef merge(left: Node, right: Node) -> Node:\n    \"\"\"\n",
        "source_code_len": 144,
        "target_code": "            root.right, right = split(root.right, value)\n            return root, right\n\n\ndef merge(left: Optional[Node], right: Optional[Node]) -> Optional[Node]:\n    \"\"\"\n",
        "target_code_len": 172,
        "diff_format": "@@ -62,6 +63,6 @@\n             root.right, right = split(root.right, value)\n-            return (root, right)\n+            return root, right\n \n \n-def merge(left: Node, right: Node) -> Node:\n+def merge(left: Optional[Node], right: Optional[Node]) -> Optional[Node]:\n     \"\"\"\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "            root.right, right = split(root.right, value)\n            return (root, right)\n\n\n<DED><DED><DED>def merge(left: Node, right: Node) -> Node:\n    <IND>",
        "target_code_with_indent": "            root.right, right = split(root.right, value)\n            return root, right\n\n\n<DED><DED><DED>def merge(left: Optional[Node], right: Optional[Node]) -> Optional[Node]:\n    <IND>"
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\ndef insert(root: Node, value: int) -> Node:\n    \"\"\"\n",
        "source_code_len": 53,
        "target_code": "\ndef insert(root: Optional[Node], value: int) -> Optional[Node]:\n    \"\"\"\n",
        "target_code_len": 73,
        "diff_format": "@@ -87,3 +88,3 @@\n \n-def insert(root: Node, value: int) -> Node:\n+def insert(root: Optional[Node], value: int) -> Optional[Node]:\n     \"\"\"\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\n<DED><DED>def insert(root: Node, value: int) -> Node:\n    <IND>",
        "target_code_with_indent": "\n<DED><DED>def insert(root: Optional[Node], value: int) -> Optional[Node]:\n    <IND>"
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\ndef erase(root: Node, value: int) -> Node:\n    \"\"\"\n",
        "source_code_len": 52,
        "target_code": "\ndef erase(root: Optional[Node], value: int) -> Optional[Node]:\n    \"\"\"\n",
        "target_code_len": 72,
        "diff_format": "@@ -100,3 +101,3 @@\n \n-def erase(root: Node, value: int) -> Node:\n+def erase(root: Optional[Node], value: int) -> Optional[Node]:\n     \"\"\"\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\n<DED>def erase(root: Node, value: int) -> Node:\n    <IND>",
        "target_code_with_indent": "\n<DED>def erase(root: Optional[Node], value: int) -> Optional[Node]:\n    <IND>"
      }
    ]
  },
  {
    "project": "TheAlgorithms/Python",
    "commit": "2595cf059d677c39513a9d75f1736bc5b84d6298",
    "filename": "data_structures/binary_tree/treap.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/TheAlgorithms-Python/data_structures/binary_tree/treap.py",
    "file_hunks_size": 12,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "data_structures/binary_tree/treap.py:47:8 Incompatible return type [7]: Expected `typing.Tuple[Node, Node]` but got `typing.Tuple[None, None]`.",
    "message": " Expected `typing.Tuple[Node, Node]` but got `typing.Tuple[None, None]`.",
    "rule_id": "Incompatible return type [7]",
    "warning_line_no": 47,
    "warning_line": "        return (None, None)",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "from random import random\n\n",
        "source_code_len": 27,
        "target_code": "from random import random\nfrom typing import Optional, Tuple\n\n",
        "target_code_len": 62,
        "diff_format": "@@ -5,2 +5,3 @@\n from random import random\n+from typing import Optional, Tuple\n \n",
        "source_code_with_indent": "from random import random\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "from random import random\nfrom typing import Optional, Tuple\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\ndef split(root: Node, value: int) -> tuple[Node, Node]:\n    \"\"\"\n",
        "source_code_len": 65,
        "target_code": "\ndef split(root: Optional[Node], value: int) -> Tuple[Optional[Node], Optional[Node]]:\n    \"\"\"\n",
        "target_code_len": 95,
        "diff_format": "@@ -36,3 +37,3 @@\n \n-def split(root: Node, value: int) -> tuple[Node, Node]:\n+def split(root: Optional[Node], value: int) -> Tuple[Optional[Node], Optional[Node]]:\n     \"\"\"\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\n<DED><DED>def split(root: Node, value: int) -> tuple[Node, Node]:\n    <IND>",
        "target_code_with_indent": "\n<DED><DED>def split(root: Optional[Node], value: int) -> Tuple[Optional[Node], Optional[Node]]:\n    <IND>"
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "            root.right, right = split(root.right, value)\n            return (root, right)\n\n\ndef merge(left: Node, right: Node) -> Node:\n    \"\"\"\n",
        "source_code_len": 144,
        "target_code": "            root.right, right = split(root.right, value)\n            return root, right\n\n\ndef merge(left: Optional[Node], right: Optional[Node]) -> Optional[Node]:\n    \"\"\"\n",
        "target_code_len": 172,
        "diff_format": "@@ -62,6 +63,6 @@\n             root.right, right = split(root.right, value)\n-            return (root, right)\n+            return root, right\n \n \n-def merge(left: Node, right: Node) -> Node:\n+def merge(left: Optional[Node], right: Optional[Node]) -> Optional[Node]:\n     \"\"\"\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "            root.right, right = split(root.right, value)\n            return (root, right)\n\n\n<DED><DED><DED>def merge(left: Node, right: Node) -> Node:\n    <IND>",
        "target_code_with_indent": "            root.right, right = split(root.right, value)\n            return root, right\n\n\n<DED><DED><DED>def merge(left: Optional[Node], right: Optional[Node]) -> Optional[Node]:\n    <IND>"
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\ndef insert(root: Node, value: int) -> Node:\n    \"\"\"\n",
        "source_code_len": 53,
        "target_code": "\ndef insert(root: Optional[Node], value: int) -> Optional[Node]:\n    \"\"\"\n",
        "target_code_len": 73,
        "diff_format": "@@ -87,3 +88,3 @@\n \n-def insert(root: Node, value: int) -> Node:\n+def insert(root: Optional[Node], value: int) -> Optional[Node]:\n     \"\"\"\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\n<DED><DED>def insert(root: Node, value: int) -> Node:\n    <IND>",
        "target_code_with_indent": "\n<DED><DED>def insert(root: Optional[Node], value: int) -> Optional[Node]:\n    <IND>"
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\ndef erase(root: Node, value: int) -> Node:\n    \"\"\"\n",
        "source_code_len": 52,
        "target_code": "\ndef erase(root: Optional[Node], value: int) -> Optional[Node]:\n    \"\"\"\n",
        "target_code_len": 72,
        "diff_format": "@@ -100,3 +101,3 @@\n \n-def erase(root: Node, value: int) -> Node:\n+def erase(root: Optional[Node], value: int) -> Optional[Node]:\n     \"\"\"\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\n<DED>def erase(root: Node, value: int) -> Node:\n    <IND>",
        "target_code_with_indent": "\n<DED>def erase(root: Optional[Node], value: int) -> Optional[Node]:\n    <IND>"
      }
    ]
  }
]