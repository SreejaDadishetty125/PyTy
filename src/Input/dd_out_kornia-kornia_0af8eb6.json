[
  {
    "project": "kornia/kornia",
    "commit": "0af8eb6aa9c1b40e6805fd3dd84b65d101cb55f8",
    "filename": "kornia/geometry/warp/homography_warper.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/kornia-kornia/kornia/geometry/warp/homography_warper.py",
    "file_hunks_size": 10,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "kornia/geometry/warp/homography_warper.py:192:11 Call error [29]: `HomographyWarper` is not a function.",
    "message": " `HomographyWarper` is not a function.",
    "rule_id": "Call error [29]",
    "warning_line_no": 192,
    "warning_line": "    return warper(patch_src, src_homo_dst)",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "]\n\n",
        "source_code_len": 3,
        "target_code": "]\n\n\ndef warp_grid(grid: torch.Tensor, src_homo_dst: torch.Tensor) -> torch.Tensor:\n    r\"\"\"Compute the grid to warp the coordinates grid by the homography/ies.\n\n    Args:\n        grid: Unwrapped grid of the shape :math:`(1, N, W, 2)`.\n        src_homo_dst (torch.Tensor): Homography or homographies (stacked) to\n          transform all points in the grid. Shape of the homography\n          has to be :math:`(1, 3, 3)` or :math:`(N, 1, 3, 3)`.\n\n\n    Returns:\n        torch.Tensor: the transformed grid of shape :math:`(N, H, W, 2)`.\n    \"\"\"\n    batch_size: int = src_homo_dst.size(0)\n    _, height, width, _ = grid.size()\n    # expand grid to match the input batch size\n    grid = grid.expand(batch_size, -1, -1, -1)  # NxHxWx2\n    if len(src_homo_dst.shape) == 3:  # local homography case\n        src_homo_dst = src_homo_dst.view(batch_size, 1, 3, 3)  # Nx1x3x3\n    # perform the actual grid transformation,\n    # the grid is copied to input device and casted to the same type\n    flow: torch.Tensor = transform_points(src_homo_dst, grid.to(src_homo_dst))  # NxHxWx2\n    return flow.view(batch_size, height, width, 2)  # NxHxWx2\n\n\n# functional api\ndef homography_warp(patch_src: torch.Tensor,\n                    src_homo_dst: torch.Tensor,\n                    dsize: Tuple[int, int],\n                    mode: str = 'bilinear',\n                    padding_mode: str = 'zeros',\n                    align_corners: bool = False,\n                    normalized_coordinates: bool = True) -> torch.Tensor:\n    r\"\"\"Function that warps image patchs or tensors by homographies.\n\n    See :class:`~kornia.geometry.warp.HomographyWarper` for details.\n\n    Args:\n        patch_src (torch.Tensor): The image or tensor to warp. Should be from\n                                  source of shape :math:`(N, C, H, W)`.\n        src_homo_dst (torch.Tensor): The homography or stack of homographies\n                                     from destination to source of shape\n                                     :math:`(N, 3, 3)`.\n        dsize (Tuple[int, int]): The height and width of the image to warp.\n        mode (str): interpolation mode to calculate output values\n          'bilinear' | 'nearest'. Default: 'bilinear'.\n        padding_mode (str): padding mode for outside grid values\n          'zeros' | 'border' | 'reflection'. Default: 'zeros'.\n        align_corners(bool): interpolation flag. Default: False. See\n        https://pytorch.org/docs/stable/nn.functional.html#torch.nn.functional.interpolate for detail\n        normalized_coordinates (bool): Whether the homography assumes [-1, 1] normalized\n                                       coordinates or not.\n\n    Return:\n        torch.Tensor: Patch sampled at locations from source to destination.\n\n    Example:\n        >>> input = torch.rand(1, 3, 32, 32)\n        >>> homography = torch.eye(3).view(1, 3, 3)\n        >>> output = kornia.homography_warp(input, homography, (32, 32))\n    \"\"\"\n    if not src_homo_dst.device == patch_src.device:\n        raise TypeError(\"Patch and homography must be on the same device. \\\n                         Got patch.device: {} src_H_dst.device: {}.\".format(\n                        patch_src.device, src_homo_dst.device))\n\n    height, width = dsize\n    grid = create_meshgrid(height, width, normalized_coordinates=normalized_coordinates)\n    warped_grid = warp_grid(grid, src_homo_dst)\n\n    return F.grid_sample(patch_src, warped_grid, mode=mode, padding_mode=padding_mode,\n                         align_corners=align_corners)\n\n",
        "target_code_len": 3509,
        "diff_format": "@@ -16,2 +18,76 @@\n ]\n+\n+\n+def warp_grid(grid: torch.Tensor, src_homo_dst: torch.Tensor) -> torch.Tensor:\n+    r\"\"\"Compute the grid to warp the coordinates grid by the homography/ies.\n+\n+    Args:\n+        grid: Unwrapped grid of the shape :math:`(1, N, W, 2)`.\n+        src_homo_dst (torch.Tensor): Homography or homographies (stacked) to\n+          transform all points in the grid. Shape of the homography\n+          has to be :math:`(1, 3, 3)` or :math:`(N, 1, 3, 3)`.\n+\n+\n+    Returns:\n+        torch.Tensor: the transformed grid of shape :math:`(N, H, W, 2)`.\n+    \"\"\"\n+    batch_size: int = src_homo_dst.size(0)\n+    _, height, width, _ = grid.size()\n+    # expand grid to match the input batch size\n+    grid = grid.expand(batch_size, -1, -1, -1)  # NxHxWx2\n+    if len(src_homo_dst.shape) == 3:  # local homography case\n+        src_homo_dst = src_homo_dst.view(batch_size, 1, 3, 3)  # Nx1x3x3\n+    # perform the actual grid transformation,\n+    # the grid is copied to input device and casted to the same type\n+    flow: torch.Tensor = transform_points(src_homo_dst, grid.to(src_homo_dst))  # NxHxWx2\n+    return flow.view(batch_size, height, width, 2)  # NxHxWx2\n+\n+\n+# functional api\n+def homography_warp(patch_src: torch.Tensor,\n+                    src_homo_dst: torch.Tensor,\n+                    dsize: Tuple[int, int],\n+                    mode: str = 'bilinear',\n+                    padding_mode: str = 'zeros',\n+                    align_corners: bool = False,\n+                    normalized_coordinates: bool = True) -> torch.Tensor:\n+    r\"\"\"Function that warps image patchs or tensors by homographies.\n+\n+    See :class:`~kornia.geometry.warp.HomographyWarper` for details.\n+\n+    Args:\n+        patch_src (torch.Tensor): The image or tensor to warp. Should be from\n+                                  source of shape :math:`(N, C, H, W)`.\n+        src_homo_dst (torch.Tensor): The homography or stack of homographies\n+                                     from destination to source of shape\n+                                     :math:`(N, 3, 3)`.\n+        dsize (Tuple[int, int]): The height and width of the image to warp.\n+        mode (str): interpolation mode to calculate output values\n+          'bilinear' | 'nearest'. Default: 'bilinear'.\n+        padding_mode (str): padding mode for outside grid values\n+          'zeros' | 'border' | 'reflection'. Default: 'zeros'.\n+        align_corners(bool): interpolation flag. Default: False. See\n+        https://pytorch.org/docs/stable/nn.functional.html#torch.nn.functional.interpolate for detail\n+        normalized_coordinates (bool): Whether the homography assumes [-1, 1] normalized\n+                                       coordinates or not.\n+\n+    Return:\n+        torch.Tensor: Patch sampled at locations from source to destination.\n+\n+    Example:\n+        >>> input = torch.rand(1, 3, 32, 32)\n+        >>> homography = torch.eye(3).view(1, 3, 3)\n+        >>> output = kornia.homography_warp(input, homography, (32, 32))\n+    \"\"\"\n+    if not src_homo_dst.device == patch_src.device:\n+        raise TypeError(\"Patch and homography must be on the same device. \\\n+                         Got patch.device: {} src_H_dst.device: {}.\".format(\n+                        patch_src.device, src_homo_dst.device))\n+\n+    height, width = dsize\n+    grid = create_meshgrid(height, width, normalized_coordinates=normalized_coordinates)\n+    warped_grid = warp_grid(grid, src_homo_dst)\n+\n+    return F.grid_sample(patch_src, warped_grid, mode=mode, padding_mode=padding_mode,\n+                         align_corners=align_corners)\n \n",
        "source_code_with_indent": "]\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "]\n\n\ndef warp_grid(grid: torch.Tensor, src_homo_dst: torch.Tensor) -> torch.Tensor:\n    <IND>r\"\"\"Compute the grid to warp the coordinates grid by the homography/ies.\n\n    Args:\n        grid: Unwrapped grid of the shape :math:`(1, N, W, 2)`.\n        src_homo_dst (torch.Tensor): Homography or homographies (stacked) to\n          transform all points in the grid. Shape of the homography\n          has to be :math:`(1, 3, 3)` or :math:`(N, 1, 3, 3)`.\n\n\n    Returns:\n        torch.Tensor: the transformed grid of shape :math:`(N, H, W, 2)`.\n    \"\"\"\n    batch_size: int = src_homo_dst.size(0)\n    _, height, width, _ = grid.size()\n    # expand grid to match the input batch size\n    grid = grid.expand(batch_size, -1, -1, -1)  # NxHxWx2\n    if len(src_homo_dst.shape) == 3:  # local homography case\n        <IND>src_homo_dst = src_homo_dst.view(batch_size, 1, 3, 3)  # Nx1x3x3\n    # perform the actual grid transformation,\n    # the grid is copied to input device and casted to the same type\n    <DED>flow: torch.Tensor = transform_points(src_homo_dst, grid.to(src_homo_dst))  # NxHxWx2\n    return flow.view(batch_size, height, width, 2)  # NxHxWx2\n\n\n# functional api\n<DED>def homography_warp(patch_src: torch.Tensor,\n                    src_homo_dst: torch.Tensor,\n                    dsize: Tuple[int, int],\n                    mode: str = 'bilinear',\n                    padding_mode: str = 'zeros',\n                    align_corners: bool = False,\n                    normalized_coordinates: bool = True) -> torch.Tensor:\n    <IND>r\"\"\"Function that warps image patchs or tensors by homographies.\n\n    See :class:`~kornia.geometry.warp.HomographyWarper` for details.\n\n    Args:\n        patch_src (torch.Tensor): The image or tensor to warp. Should be from\n                                  source of shape :math:`(N, C, H, W)`.\n        src_homo_dst (torch.Tensor): The homography or stack of homographies\n                                     from destination to source of shape\n                                     :math:`(N, 3, 3)`.\n        dsize (Tuple[int, int]): The height and width of the image to warp.\n        mode (str): interpolation mode to calculate output values\n          'bilinear' | 'nearest'. Default: 'bilinear'.\n        padding_mode (str): padding mode for outside grid values\n          'zeros' | 'border' | 'reflection'. Default: 'zeros'.\n        align_corners(bool): interpolation flag. Default: False. See\n        https://pytorch.org/docs/stable/nn.functional.html#torch.nn.functional.interpolate for detail\n        normalized_coordinates (bool): Whether the homography assumes [-1, 1] normalized\n                                       coordinates or not.\n\n    Return:\n        torch.Tensor: Patch sampled at locations from source to destination.\n\n    Example:\n        >>> input = torch.rand(1, 3, 32, 32)\n        >>> homography = torch.eye(3).view(1, 3, 3)\n        >>> output = kornia.homography_warp(input, homography, (32, 32))\n    \"\"\"\n    if not src_homo_dst.device == patch_src.device:\n        <IND>raise TypeError(\"Patch and homography must be on the same device. \\\n                         Got patch.device: {} src_H_dst.device: {}.\".format(\n                        patch_src.device, src_homo_dst.device))\n\n    <DED>height, width = dsize\n    grid = create_meshgrid(height, width, normalized_coordinates=normalized_coordinates)\n    warped_grid = warp_grid(grid, src_homo_dst)\n\n    return F.grid_sample(patch_src, warped_grid, mode=mode, padding_mode=padding_mode,\n                         align_corners=align_corners)\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "        \"\"\"\n        warped_grid: torch.Tensor\n        if src_homo_dst is not None:\n            if not src_homo_dst.device == patch_src.device:\n                raise TypeError(\"Patch and homography must be on the same device. \\\n                                Got patch.device: {} src_H_dst.device: {}.\"\n                                .format(patch_src.device, src_homo_dst.device))\n            warped_grid = self.warp_grid(src_homo_dst)\n        elif self._warped_grid is not None:\n            if not self._warped_grid.device == patch_src.device:\n                raise TypeError(\"Patch and warped grid must be on the same device. \\\n                                Got patch.device: {} warped_grid.device: {}. Wheter \\\n                                recall precompute_warp_grid() with the correct device \\\n                                for the homograhy or change the patch device.\"\n                                .format(patch_src.device, self._warped_grid.device))\n            warped_grid = self._warped_grid\n        else:\n",
        "source_code_len": 1028,
        "target_code": "        \"\"\"\n        _warped_grid = self._warped_grid\n        if src_homo_dst is not None:\n            warped_patch = homography_warp(\n                patch_src, src_homo_dst, (self.height, self.width), mode=self.mode,\n                padding_mode=self.padding_mode, align_corners=self.align_corners,\n                normalized_coordinates=self.normalized_coordinates)\n        elif _warped_grid is not None:\n            if not _warped_grid.device == patch_src.device:\n                raise TypeError(\"Patch and warped grid must be on the same device. \\\n                                 Got patch.device: {} warped_grid.device: {}. Wheter \\\n                                 recall precompute_warp_grid() with the correct device \\\n                                 for the homograhy or change the patch device.\".format(\n                                patch_src.device, _warped_grid.device))\n            warped_patch = F.grid_sample(\n                patch_src, _warped_grid, mode=self.mode, padding_mode=self.padding_mode,\n                align_corners=self.align_corners)\n        else:\n",
        "target_code_len": 1083,
        "diff_format": "@@ -131,17 +182,18 @@\n         \"\"\"\n-        warped_grid: torch.Tensor\n+        _warped_grid = self._warped_grid\n         if src_homo_dst is not None:\n-            if not src_homo_dst.device == patch_src.device:\n-                raise TypeError(\"Patch and homography must be on the same device. \\\n-                                Got patch.device: {} src_H_dst.device: {}.\"\n-                                .format(patch_src.device, src_homo_dst.device))\n-            warped_grid = self.warp_grid(src_homo_dst)\n-        elif self._warped_grid is not None:\n-            if not self._warped_grid.device == patch_src.device:\n+            warped_patch = homography_warp(\n+                patch_src, src_homo_dst, (self.height, self.width), mode=self.mode,\n+                padding_mode=self.padding_mode, align_corners=self.align_corners,\n+                normalized_coordinates=self.normalized_coordinates)\n+        elif _warped_grid is not None:\n+            if not _warped_grid.device == patch_src.device:\n                 raise TypeError(\"Patch and warped grid must be on the same device. \\\n-                                Got patch.device: {} warped_grid.device: {}. Wheter \\\n-                                recall precompute_warp_grid() with the correct device \\\n-                                for the homograhy or change the patch device.\"\n-                                .format(patch_src.device, self._warped_grid.device))\n-            warped_grid = self._warped_grid\n+                                 Got patch.device: {} warped_grid.device: {}. Wheter \\\n+                                 recall precompute_warp_grid() with the correct device \\\n+                                 for the homograhy or change the patch device.\".format(\n+                                patch_src.device, _warped_grid.device))\n+            warped_patch = F.grid_sample(\n+                patch_src, _warped_grid, mode=self.mode, padding_mode=self.padding_mode,\n+                align_corners=self.align_corners)\n         else:\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\n        warped_grid: torch.Tensor\n        if src_homo_dst is not None:\n            <IND>if not src_homo_dst.device == patch_src.device:\n                <IND>raise TypeError(\"Patch and homography must be on the same device. \\\n                                Got patch.device: {} src_H_dst.device: {}.\"\n                                .format(patch_src.device, src_homo_dst.device))\n            <DED>warped_grid = self.warp_grid(src_homo_dst)\n        <DED>elif self._warped_grid is not None:\n            <IND>if not self._warped_grid.device == patch_src.device:\n                <IND>raise TypeError(\"Patch and warped grid must be on the same device. \\\n                                Got patch.device: {} warped_grid.device: {}. Wheter \\\n                                recall precompute_warp_grid() with the correct device \\\n                                for the homograhy or change the patch device.\"\n                                .format(patch_src.device, self._warped_grid.device))\n            <DED>warped_grid = self._warped_grid\n        <DED>else:\n",
        "target_code_with_indent": "\n        _warped_grid = self._warped_grid\n        if src_homo_dst is not None:\n            <IND>warped_patch = homography_warp(\n                patch_src, src_homo_dst, (self.height, self.width), mode=self.mode,\n                padding_mode=self.padding_mode, align_corners=self.align_corners,\n                normalized_coordinates=self.normalized_coordinates)\n        <DED>elif _warped_grid is not None:\n            <IND>if not _warped_grid.device == patch_src.device:\n                <IND>raise TypeError(\"Patch and warped grid must be on the same device. \\\n                                 Got patch.device: {} warped_grid.device: {}. Wheter \\\n                                 recall precompute_warp_grid() with the correct device \\\n                                 for the homograhy or change the patch device.\".format(\n                                patch_src.device, _warped_grid.device))\n            <DED>warped_patch = F.grid_sample(\n                patch_src, _warped_grid, mode=self.mode, padding_mode=self.padding_mode,\n                align_corners=self.align_corners)\n        <DED>else:\n"
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n        return F.grid_sample(patch_src, warped_grid,  # type: ignore\n                             mode=self.mode, padding_mode=self.padding_mode,\n                             align_corners=self.align_corners)\n\n\n# functional api\ndef homography_warp(patch_src: torch.Tensor,\n                    src_homo_dst: torch.Tensor,\n                    dsize: Tuple[int, int],\n                    mode: str = 'bilinear',\n                    padding_mode: str = 'zeros',\n                    align_corners: bool = False) -> torch.Tensor:\n    r\"\"\"Function that warps image patchs or tensors by homographies.\n\n    See :class:`~kornia.geometry.warp.HomographyWarper` for details.\n\n    Args:\n        patch_src (torch.Tensor): The image or tensor to warp. Should be from\n                                  source of shape :math:`(N, C, H, W)`.\n        src_homo_dst (torch.Tensor): The homography or stack of homographies\n                                     from destination to source of shape\n                                     :math:`(N, 3, 3)`. The homography assumes\n                                     normalized coordinates [-1, 1].\n        dsize (Tuple[int, int]): The height and width of the image to warp.\n        mode (str): interpolation mode to calculate output values\n          'bilinear' | 'nearest'. Default: 'bilinear'.\n        padding_mode (str): padding mode for outside grid values\n          'zeros' | 'border' | 'reflection'. Default: 'zeros'.\n        align_corners(bool): interpolation flag. Default: False. See\n        https://pytorch.org/docs/stable/nn.functional.html#torch.nn.functional.interpolate for detail\n    Return:\n        torch.Tensor: Patch sampled at locations from source to destination.\n\n    Example:\n        >>> input = torch.rand(1, 3, 32, 32)\n        >>> homography = torch.eye(3).view(1, 3, 3)\n        >>> output = kornia.homography_warp(input, homography, (32, 32))\n    \"\"\"\n    height, width = dsize\n    warper = HomographyWarper(height, width, mode, padding_mode, align_corners=align_corners)\n    return warper(patch_src, src_homo_dst)\n\n",
        "source_code_len": 2064,
        "target_code": "\n        return warped_patch\n\n",
        "target_code_len": 30,
        "diff_format": "@@ -151,43 +203,3 @@\n \n-        return F.grid_sample(patch_src, warped_grid,  # type: ignore\n-                             mode=self.mode, padding_mode=self.padding_mode,\n-                             align_corners=self.align_corners)\n-\n-\n-# functional api\n-def homography_warp(patch_src: torch.Tensor,\n-                    src_homo_dst: torch.Tensor,\n-                    dsize: Tuple[int, int],\n-                    mode: str = 'bilinear',\n-                    padding_mode: str = 'zeros',\n-                    align_corners: bool = False) -> torch.Tensor:\n-    r\"\"\"Function that warps image patchs or tensors by homographies.\n-\n-    See :class:`~kornia.geometry.warp.HomographyWarper` for details.\n-\n-    Args:\n-        patch_src (torch.Tensor): The image or tensor to warp. Should be from\n-                                  source of shape :math:`(N, C, H, W)`.\n-        src_homo_dst (torch.Tensor): The homography or stack of homographies\n-                                     from destination to source of shape\n-                                     :math:`(N, 3, 3)`. The homography assumes\n-                                     normalized coordinates [-1, 1].\n-        dsize (Tuple[int, int]): The height and width of the image to warp.\n-        mode (str): interpolation mode to calculate output values\n-          'bilinear' | 'nearest'. Default: 'bilinear'.\n-        padding_mode (str): padding mode for outside grid values\n-          'zeros' | 'border' | 'reflection'. Default: 'zeros'.\n-        align_corners(bool): interpolation flag. Default: False. See\n-        https://pytorch.org/docs/stable/nn.functional.html#torch.nn.functional.interpolate for detail\n-    Return:\n-        torch.Tensor: Patch sampled at locations from source to destination.\n-\n-    Example:\n-        >>> input = torch.rand(1, 3, 32, 32)\n-        >>> homography = torch.eye(3).view(1, 3, 3)\n-        >>> output = kornia.homography_warp(input, homography, (32, 32))\n-    \"\"\"\n-    height, width = dsize\n-    warper = HomographyWarper(height, width, mode, padding_mode, align_corners=align_corners)\n-    return warper(patch_src, src_homo_dst)\n+        return warped_patch\n \n",
        "source_code_with_indent": "\n        <DED>return F.grid_sample(patch_src, warped_grid,  # type: ignore\n                             mode=self.mode, padding_mode=self.padding_mode,\n                             align_corners=self.align_corners)\n\n\n# functional api\n<DED><DED>def homography_warp(patch_src: torch.Tensor,\n                    src_homo_dst: torch.Tensor,\n                    dsize: Tuple[int, int],\n                    mode: str = 'bilinear',\n                    padding_mode: str = 'zeros',\n                    align_corners: bool = False) -> torch.Tensor:\n    <IND>r\"\"\"Function that warps image patchs or tensors by homographies.\n\n    See :class:`~kornia.geometry.warp.HomographyWarper` for details.\n\n    Args:\n        patch_src (torch.Tensor): The image or tensor to warp. Should be from\n                                  source of shape :math:`(N, C, H, W)`.\n        src_homo_dst (torch.Tensor): The homography or stack of homographies\n                                     from destination to source of shape\n                                     :math:`(N, 3, 3)`. The homography assumes\n                                     normalized coordinates [-1, 1].\n        dsize (Tuple[int, int]): The height and width of the image to warp.\n        mode (str): interpolation mode to calculate output values\n          'bilinear' | 'nearest'. Default: 'bilinear'.\n        padding_mode (str): padding mode for outside grid values\n          'zeros' | 'border' | 'reflection'. Default: 'zeros'.\n        align_corners(bool): interpolation flag. Default: False. See\n        https://pytorch.org/docs/stable/nn.functional.html#torch.nn.functional.interpolate for detail\n    Return:\n        torch.Tensor: Patch sampled at locations from source to destination.\n\n    Example:\n        >>> input = torch.rand(1, 3, 32, 32)\n        >>> homography = torch.eye(3).view(1, 3, 3)\n        >>> output = kornia.homography_warp(input, homography, (32, 32))\n    \"\"\"\n    height, width = dsize\n    warper = HomographyWarper(height, width, mode, padding_mode, align_corners=align_corners)\n    return warper(patch_src, src_homo_dst)\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n        <DED>return warped_patch\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  }
]