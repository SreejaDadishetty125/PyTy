[
  {
    "project": "Instagram/LibCST",
    "commit": "3ccfc4adc82b8354c1c998b0abd1ded3d690a1e8",
    "filename": "libcst/codemod/visitors/_apply_type_annotations.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/Instagram-LibCST/libcst/codemod/visitors/_apply_type_annotations.py",
    "file_hunks_size": 9,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": true,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "libcst/codemod/visitors/_apply_type_annotations.py:80:51 Incompatible parameter type [6]: Expected `cst._nodes.expression.Subscript` for 1st positional only parameter to call `TypeCollector._handle_Subscript` but got `cst._nodes.expression.BaseExpression`.",
    "message": " Expected `cst._nodes.expression.Subscript` for 1st positional only parameter to call `TypeCollector._handle_Subscript` but got `cst._nodes.expression.BaseExpression`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 80,
    "warning_line": "                new_value = self._handle_Subscript(value)",
    "min_patch": [
      {
        "hunk_fit_TFix": true,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "                new_value = self._handle_NameOrAttribute(value)\n            elif isinstance(base.value, cst.Subscript):\n                new_value = self._handle_Subscript(value)\n",
        "source_code_len": 178,
        "target_code": "                new_value = self._handle_NameOrAttribute(value)\n            elif isinstance(value, cst.Subscript):\n                new_value = self._handle_Subscript(value)\n",
        "target_code_len": 173,
        "diff_format": "@@ -78,3 +78,3 @@\n                 new_value = self._handle_NameOrAttribute(value)\n-            elif isinstance(base.value, cst.Subscript):\n+            elif isinstance(value, cst.Subscript):\n                 new_value = self._handle_Subscript(value)\n",
        "source_code_with_indent": "                <IND>new_value = self._handle_NameOrAttribute(value)\n            <DED>elif isinstance(base.value, cst.Subscript):\n                <IND>new_value = self._handle_Subscript(value)\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "                <IND>new_value = self._handle_NameOrAttribute(value)\n            <DED>elif isinstance(value, cst.Subscript):\n                <IND>new_value = self._handle_Subscript(value)\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "Instagram/LibCST",
    "commit": "3ccfc4adc82b8354c1c998b0abd1ded3d690a1e8",
    "filename": "libcst/codemod/visitors/_apply_type_annotations.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/Instagram-LibCST/libcst/codemod/visitors/_apply_type_annotations.py",
    "file_hunks_size": 9,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "libcst/codemod/visitors/_apply_type_annotations.py:129:12 Incompatible return type [7]: Expected `str` but got `Optional[str]`.",
    "message": " Expected `str` but got `Optional[str]`.",
    "rule_id": "Incompatible return type [7]",
    "warning_line_no": 129,
    "warning_line": "            return get_full_name_for_node(node)",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    def _get_unique_qualified_name(self, node: cst.CSTNode) -> str:\n        names = [q.name for q in self.get_metadata(QualifiedNameProvider, node)]\n",
        "source_code_len": 149,
        "target_code": "    def _get_unique_qualified_name(self, node: cst.CSTNode) -> str:\n        name = None\n        names = [q.name for q in self.get_metadata(QualifiedNameProvider, node)]\n",
        "target_code_len": 169,
        "diff_format": "@@ -123,2 +123,3 @@\n     def _get_unique_qualified_name(self, node: cst.CSTNode) -> str:\n+        name = None\n         names = [q.name for q in self.get_metadata(QualifiedNameProvider, node)]\n",
        "source_code_with_indent": "    <DED>def _get_unique_qualified_name(self, node: cst.CSTNode) -> str:\n        <IND>names = [q.name for q in self.get_metadata(QualifiedNameProvider, node)]\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    <DED>def _get_unique_qualified_name(self, node: cst.CSTNode) -> str:\n        <IND>name = None\n        names = [q.name for q in self.get_metadata(QualifiedNameProvider, node)]\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "            # convenient to allow.\n            return get_full_name_for_node(node)\n        elif len(names) == 1:\n            return names[0]\n        else:\n            start = self.get_metadata(PositionProvider, node).start\n",
        "source_code_len": 223,
        "target_code": "            # convenient to allow.\n            name = get_full_name_for_node(node)\n        elif len(names) == 1 and isinstance(names[0], str):\n            name = names[0]\n        if name is None:\n            start = self.get_metadata(PositionProvider, node).start\n",
        "target_code_len": 264,
        "diff_format": "@@ -128,6 +129,6 @@\n             # convenient to allow.\n-            return get_full_name_for_node(node)\n-        elif len(names) == 1:\n-            return names[0]\n-        else:\n+            name = get_full_name_for_node(node)\n+        elif len(names) == 1 and isinstance(names[0], str):\n+            name = names[0]\n+        if name is None:\n             start = self.get_metadata(PositionProvider, node).start\n",
        "source_code_with_indent": "            # convenient to allow.\n            <IND>return get_full_name_for_node(node)\n        <DED>elif len(names) == 1:\n            <IND>return names[0]\n        <DED>else:\n            <IND>start = self.get_metadata(PositionProvider, node).start\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "            # convenient to allow.\n            <IND>name = get_full_name_for_node(node)\n        <DED>elif len(names) == 1 and isinstance(names[0], str):\n            <IND>name = names[0]\n        <DED>if name is None:\n            <IND>start = self.get_metadata(PositionProvider, node).start\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "            )\n\n",
        "source_code_len": 15,
        "target_code": "            )\n        return name\n\n",
        "target_code_len": 35,
        "diff_format": "@@ -138,2 +139,3 @@\n             )\n+        return name\n \n",
        "source_code_with_indent": "            )\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "            )\n        <DED>return name\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "Instagram/LibCST",
    "commit": "3ccfc4adc82b8354c1c998b0abd1ded3d690a1e8",
    "filename": "libcst/codemod/visitors/_apply_type_annotations.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/Instagram-LibCST/libcst/codemod/visitors/_apply_type_annotations.py",
    "file_hunks_size": 9,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": true,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "libcst/codemod/visitors/_apply_type_annotations.py:163:16 Incompatible return type [7]: Expected `bool` but got implicit return value of `None`.",
    "message": " Expected `bool` but got implicit return value of `None`.",
    "rule_id": "Incompatible return type [7]",
    "warning_line_no": 163,
    "warning_line": "                return False",
    "min_patch": [
      {
        "hunk_fit_TFix": true,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "                return False\n\n",
        "source_code_len": 30,
        "target_code": "                return False\n        return False\n\n",
        "target_code_len": 51,
        "diff_format": "@@ -163,2 +165,3 @@\n                 return False\n+        return False\n \n",
        "source_code_with_indent": "                return False\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "                return False\n        <DED><DED>return False\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "Instagram/LibCST",
    "commit": "3ccfc4adc82b8354c1c998b0abd1ded3d690a1e8",
    "filename": "libcst/codemod/visitors/_apply_type_annotations.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/Instagram-LibCST/libcst/codemod/visitors/_apply_type_annotations.py",
    "file_hunks_size": 9,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "libcst/codemod/visitors/_apply_type_annotations.py:189:12 Incompatible return type [7]: Expected `cst._nodes.expression.Subscript` but got `cst._nodes.expression.Index`.",
    "message": " Expected `cst._nodes.expression.Subscript` but got `cst._nodes.expression.Index`.",
    "rule_id": "Incompatible return type [7]",
    "warning_line_no": 189,
    "warning_line": "            return slice.with_changes(value=self._handle_Subscript(value))",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n    def _handle_Index(self, slice: cst.Index, node: cst.Subscript) -> cst.Subscript:\n        value = slice.value\n",
        "source_code_len": 114,
        "target_code": "\n    def _handle_Index(self, slice: cst.Index, node: cst.Subscript) -> cst.Index:\n        value = slice.value\n",
        "target_code_len": 110,
        "diff_format": "@@ -185,3 +188,3 @@\n \n-    def _handle_Index(self, slice: cst.Index, node: cst.Subscript) -> cst.Subscript:\n+    def _handle_Index(self, slice: cst.Index, node: cst.Subscript) -> cst.Index:\n         value = slice.value\n",
        "source_code_with_indent": "\n    <DED><DED>def _handle_Index(self, slice: cst.Index, node: cst.Subscript) -> cst.Subscript:\n        <IND>value = slice.value\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n    <DED><DED>def _handle_Index(self, slice: cst.Index, node: cst.Subscript) -> cst.Index:\n        <IND>value = slice.value\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "Instagram/LibCST",
    "commit": "3ccfc4adc82b8354c1c998b0abd1ded3d690a1e8",
    "filename": "libcst/codemod/visitors/_apply_type_annotations.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/Instagram-LibCST/libcst/codemod/visitors/_apply_type_annotations.py",
    "file_hunks_size": 9,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "libcst/codemod/visitors/_apply_type_annotations.py:191:12 Incompatible return type [7]: Expected `cst._nodes.expression.Subscript` but got `cst._nodes.expression.Index`.",
    "message": " Expected `cst._nodes.expression.Subscript` but got `cst._nodes.expression.Index`.",
    "rule_id": "Incompatible return type [7]",
    "warning_line_no": 191,
    "warning_line": "            return slice.with_changes(value=self._handle_NameOrAttribute(value))",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n    def _handle_Index(self, slice: cst.Index, node: cst.Subscript) -> cst.Subscript:\n        value = slice.value\n",
        "source_code_len": 114,
        "target_code": "\n    def _handle_Index(self, slice: cst.Index, node: cst.Subscript) -> cst.Index:\n        value = slice.value\n",
        "target_code_len": 110,
        "diff_format": "@@ -185,3 +188,3 @@\n \n-    def _handle_Index(self, slice: cst.Index, node: cst.Subscript) -> cst.Subscript:\n+    def _handle_Index(self, slice: cst.Index, node: cst.Subscript) -> cst.Index:\n         value = slice.value\n",
        "source_code_with_indent": "\n    <DED><DED>def _handle_Index(self, slice: cst.Index, node: cst.Subscript) -> cst.Subscript:\n        <IND>value = slice.value\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n    <DED><DED>def _handle_Index(self, slice: cst.Index, node: cst.Subscript) -> cst.Index:\n        <IND>value = slice.value\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "Instagram/LibCST",
    "commit": "3ccfc4adc82b8354c1c998b0abd1ded3d690a1e8",
    "filename": "libcst/codemod/visitors/_apply_type_annotations.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/Instagram-LibCST/libcst/codemod/visitors/_apply_type_annotations.py",
    "file_hunks_size": 9,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "libcst/codemod/visitors/_apply_type_annotations.py:193:12 Incompatible return type [7]: Expected `cst._nodes.expression.Subscript` but got `cst._nodes.expression.Index`.",
    "message": " Expected `cst._nodes.expression.Subscript` but got `cst._nodes.expression.Index`.",
    "rule_id": "Incompatible return type [7]",
    "warning_line_no": 193,
    "warning_line": "            return slice",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n    def _handle_Index(self, slice: cst.Index, node: cst.Subscript) -> cst.Subscript:\n        value = slice.value\n",
        "source_code_len": 114,
        "target_code": "\n    def _handle_Index(self, slice: cst.Index, node: cst.Subscript) -> cst.Index:\n        value = slice.value\n",
        "target_code_len": 110,
        "diff_format": "@@ -185,3 +188,3 @@\n \n-    def _handle_Index(self, slice: cst.Index, node: cst.Subscript) -> cst.Subscript:\n+    def _handle_Index(self, slice: cst.Index, node: cst.Subscript) -> cst.Index:\n         value = slice.value\n",
        "source_code_with_indent": "\n    <DED><DED>def _handle_Index(self, slice: cst.Index, node: cst.Subscript) -> cst.Subscript:\n        <IND>value = slice.value\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n    <DED><DED>def _handle_Index(self, slice: cst.Index, node: cst.Subscript) -> cst.Index:\n        <IND>value = slice.value\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "Instagram/LibCST",
    "commit": "3ccfc4adc82b8354c1c998b0abd1ded3d690a1e8",
    "filename": "libcst/codemod/visitors/_apply_type_annotations.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/Instagram-LibCST/libcst/codemod/visitors/_apply_type_annotations.py",
    "file_hunks_size": 9,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": true,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "libcst/codemod/visitors/_apply_type_annotations.py:237:74 Incompatible parameter type [6]: Expected `Union[cst._nodes.expression.Attribute, cst._nodes.expression.Name]` for 1st positional only parameter to call `TypeCollector._handle_NameOrAttribute` but got `cst._nodes.expression.BaseExpression`.",
    "message": " Expected `Union[cst._nodes.expression.Attribute, cst._nodes.expression.Name]` for 1st positional only parameter to call `TypeCollector._handle_NameOrAttribute` but got `cst._nodes.expression.BaseExpression`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 237,
    "warning_line": "            return cst.Annotation(annotation=self._handle_NameOrAttribute(node))",
    "min_patch": [
      {
        "hunk_fit_TFix": true,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "            return cst.Annotation(annotation=self._handle_Subscript(node))\n        else:\n            return cst.Annotation(annotation=self._handle_NameOrAttribute(node))\n\n",
        "source_code_len": 171,
        "target_code": "            return cst.Annotation(annotation=self._handle_Subscript(node))\n        elif isinstance(node, NAME_OR_ATTRIBUTE):\n            return cst.Annotation(annotation=self._handle_NameOrAttribute(node))\n        else:\n            raise ValueError(f\"Unexpected annotation node: {node}\")\n\n",
        "target_code_len": 289,
        "diff_format": "@@ -235,4 +238,6 @@\n             return cst.Annotation(annotation=self._handle_Subscript(node))\n-        else:\n+        elif isinstance(node, NAME_OR_ATTRIBUTE):\n             return cst.Annotation(annotation=self._handle_NameOrAttribute(node))\n+        else:\n+            raise ValueError(f\"Unexpected annotation node: {node}\")\n \n",
        "source_code_with_indent": "            <IND>return cst.Annotation(annotation=self._handle_Subscript(node))\n        <DED>else:\n            <IND>return cst.Annotation(annotation=self._handle_NameOrAttribute(node))\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "            <IND>return cst.Annotation(annotation=self._handle_Subscript(node))\n        <DED>elif isinstance(node, NAME_OR_ATTRIBUTE):\n            <IND>return cst.Annotation(annotation=self._handle_NameOrAttribute(node))\n        <DED>else:\n            <IND>raise ValueError(f\"Unexpected annotation node: {node}\")\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "Instagram/LibCST",
    "commit": "3ccfc4adc82b8354c1c998b0abd1ded3d690a1e8",
    "filename": "libcst/codemod/visitors/_apply_type_annotations.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/Instagram-LibCST/libcst/codemod/visitors/_apply_type_annotations.py",
    "file_hunks_size": 9,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "libcst/codemod/visitors/_apply_type_annotations.py:609:47 Incompatible parameter type [6]: Expected `cst._nodes.expression.Annotation` for 2nd parameter `annotation` to call `ApplyTypeAnnotationsVisitor._apply_annotation_to_return` but got `Optional[cst._nodes.expression.Annotation]`.",
    "message": " Expected `cst._nodes.expression.Annotation` for 2nd parameter `annotation` to call `ApplyTypeAnnotationsVisitor._apply_annotation_to_return` but got `Optional[cst._nodes.expression.Annotation]`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 609,
    "warning_line": "                    function_def=updated_node, annotation=function_annotation.returns",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "            # annotations or if one doesn't already exist.\n            set_return_annotation = not updated_node.returns or (\n                self.overwrite_existing_annotations and function_annotation.returns\n            )\n            if set_return_annotation:\n                updated_node = self._apply_annotation_to_return(\n                    function_def=updated_node, annotation=function_annotation.returns\n                )\n",
        "source_code_len": 430,
        "target_code": "            # annotations or if one doesn't already exist.\n            set_return_annotation = (\n                self.overwrite_existing_annotations or updated_node.returns is None\n            )\n            if set_return_annotation and function_annotation.returns is not None:\n                updated_node = self._apply_annotation_to_return(\n                    function_def=updated_node,\n                    annotation=function_annotation.returns,\n                )\n",
        "target_code_len": 467,
        "diff_format": "@@ -603,8 +608,9 @@\n             # annotations or if one doesn't already exist.\n-            set_return_annotation = not updated_node.returns or (\n-                self.overwrite_existing_annotations and function_annotation.returns\n+            set_return_annotation = (\n+                self.overwrite_existing_annotations or updated_node.returns is None\n             )\n-            if set_return_annotation:\n+            if set_return_annotation and function_annotation.returns is not None:\n                 updated_node = self._apply_annotation_to_return(\n-                    function_def=updated_node, annotation=function_annotation.returns\n+                    function_def=updated_node,\n+                    annotation=function_annotation.returns,\n                 )\n",
        "source_code_with_indent": "            # annotations or if one doesn't already exist.\n            set_return_annotation = not updated_node.returns or (\n                self.overwrite_existing_annotations and function_annotation.returns\n            )\n            if set_return_annotation:\n                <IND>updated_node = self._apply_annotation_to_return(\n                    function_def=updated_node, annotation=function_annotation.returns\n                )\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "            # annotations or if one doesn't already exist.\n            set_return_annotation = (\n                self.overwrite_existing_annotations or updated_node.returns is None\n            )\n            if set_return_annotation and function_annotation.returns is not None:\n                <IND>updated_node = self._apply_annotation_to_return(\n                    function_def=updated_node,\n                    annotation=function_annotation.returns,\n                )\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  }
]