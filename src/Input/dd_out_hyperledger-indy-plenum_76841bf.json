[
  {
    "project": "hyperledger/indy-plenum",
    "commit": "76841bf492fdc285ac4f76ced6db90d2c73d5125",
    "filename": "plenum/client/client.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/hyperledger-indy-plenum/plenum/client/client.py",
    "file_hunks_size": 9,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "plenum/client/client.py:366:12 Incompatible return type [7]: Expected `Optional[Reply]` but got `Tuple[None, str]`.",
    "message": " Expected `Optional[Reply]` but got `Tuple[None, str]`.",
    "rule_id": "Incompatible return type [7]",
    "warning_line_no": 366,
    "warning_line": "            return None, \"NOT_FOUND\""
  },
  {
    "project": "hyperledger/indy-plenum",
    "commit": "76841bf492fdc285ac4f76ced6db90d2c73d5125",
    "filename": "plenum/client/client.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/hyperledger-indy-plenum/plenum/client/client.py",
    "file_hunks_size": 9,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "plenum/client/client.py:368:12 Incompatible return type [7]: Expected `Optional[Reply]` but got `Tuple[str, str]`.",
    "message": " Expected `Optional[Reply]` but got `Tuple[str, str]`.",
    "rule_id": "Incompatible return type [7]",
    "warning_line_no": 368,
    "warning_line": "            return cons, \"CONFIRMED\""
  },
  {
    "project": "hyperledger/indy-plenum",
    "commit": "76841bf492fdc285ac4f76ced6db90d2c73d5125",
    "filename": "plenum/client/client.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/hyperledger-indy-plenum/plenum/client/client.py",
    "file_hunks_size": 9,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "plenum/client/client.py:369:8 Incompatible return type [7]: Expected `Optional[Reply]` but got `Tuple[None, str]`.",
    "message": " Expected `Optional[Reply]` but got `Tuple[None, str]`.",
    "rule_id": "Incompatible return type [7]",
    "warning_line_no": 369,
    "warning_line": "        return None, \"UNCONFIRMED\""
  },
  {
    "project": "hyperledger/indy-plenum",
    "commit": "76841bf492fdc285ac4f76ced6db90d2c73d5125",
    "filename": "plenum/client/client.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/hyperledger-indy-plenum/plenum/client/client.py",
    "file_hunks_size": 9,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "plenum/client/client.py:418:12 Incompatible return type [7]: Expected `Optional[str]` but got `bool`.",
    "message": " Expected `Optional[str]` but got `bool`.",
    "rule_id": "Incompatible return type [7]",
    "warning_line_no": 418,
    "warning_line": "            return False  # UNCONFIRMED",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "        \"\"\"\n        replies = self.getRepliesFromAllNodes(identifier, reqId)\n        if not replies:\n            raise KeyError('{}{}'.format(identifier, reqId))  # NOT_FOUND\n        # Check if at least f+1 replies are received or not.\n        if self.quorums.reply.is_reached(len(replies)):\n            onlyResults = {frm: reply[\"result\"] for frm, reply in\n                           replies.items()}\n            resultsList = list(onlyResults.values())\n            # if all the elements in the resultList are equal - consensus\n            # is reached.\n\n            # excluding state proofs from check since they can be different\n            def without_state_proof(result):\n                if STATE_PROOF in result:\n                    result.pop('state_proof')\n                return result\n\n            resultsList = [without_state_proof(result) for result in resultsList]\n            if all(result == resultsList[0] for result in resultsList):\n                return resultsList[0]  # CONFIRMED\n            else:\n                logger.error(\n                    \"Received a different result from at least one of the nodes..\")\n                return checkIfMoreThanFSameItems(resultsList, self.f)\n        else:\n            return False  # UNCONFIRMED\n\n",
        "source_code_len": 1258,
        "target_code": "        \"\"\"\n        full_req_id = '({}:{})'.format(identifier, reqId)\n        replies = self.getRepliesFromAllNodes(identifier, reqId)\n        if not replies:\n            raise KeyError(full_req_id)\n        proved_reply = self.take_one_proved(replies, full_req_id)\n        if proved_reply:\n            logger.debug(\"Found proved reply for {}\".format(full_req_id))\n            return proved_reply\n        quorumed_reply = self.take_one_quorumed(replies, full_req_id)\n        if quorumed_reply:\n            logger.debug(\"Reply quorum for {} achieved\"\n                         .format(full_req_id))\n            return quorumed_reply\n\n    def take_one_quorumed(self, replies, full_req_id):\n        \"\"\"\n        Checks whether there is sufficint number of equal replies from\n        different nodes. It uses following logic:\n\n        1. Check that there are sufficient replies received at all.\n           If not - return None.\n        2. Check that all these replies are equal.\n           If yes - return one of them.\n        3. Check that there is a group of equal replies which is large enough.\n           If yes - return one reply from this group.\n        4. Return None\n\n        \"\"\"\n        if not self.quorums.reply.is_reached(len(replies)):\n            return None\n\n        # excluding state proofs from check since they can be different\n        def without_state_proof(result):\n            if STATE_PROOF in result:\n                result.pop('state_proof')\n            return result\n\n        results = [without_state_proof(reply[\"result\"])\n                   for reply in replies.values()]\n\n        first = results[0]\n        if all(result == first for result in results):\n            return first\n        logger.warning(\"Received a different result from \"\n                       \"at least one node for {}\"\n                       .format(full_req_id))\n\n        result, freq = mostCommonElement(results)\n        if not self.quorums.reply.is_reached(freq):\n            return None\n        return result\n\n    def take_one_proved(self, replies, full_req_id):\n        \"\"\"\n        Returns one reply with valid state proof\n        \"\"\"\n        for sender, reply in replies.items():\n            result = reply['result']\n            if STATE_PROOF not in result:\n                logger.debug(\"There is no state proof in \"\n                             \"reply for {} from {}\"\n                             .format(full_req_id, sender))\n                continue\n            if not self.validate_multi_signature(result):\n                logger.warning(\"{} got reply for {} with bad \"\n                               \"multi signature from {}\"\n                               .format(self.name, full_req_id, sender))\n                # TODO: do something with this node\n                continue\n            if not self.validate_proof(result):\n                logger.warning(\"{} got reply for {} with invalid \"\n                               \"state proof from {}\"\n                               .format(self.name, full_req_id, sender))\n                # TODO: do something with this node\n                continue\n            return result\n\n    def validate_multi_signature(self, result):\n        \"\"\"\n        Validates multi signature\n        \"\"\"\n        multi_signature = result[STATE_PROOF]['multi_signature']\n        if not multi_signature:\n            logger.warning(\"There is a state proof, but no multi signature\")\n            return False\n\n        participants = multi_signature['participants']\n        signature = multi_signature['signature']\n        full_state_root = create_full_root_hash(\n            root_hash=result[STATE_PROOF]['root_hash'],\n            pool_root_hash=multi_signature['pool_state_root']\n        )\n        if not self.quorums.bls_signatures.is_reached(len(participants)):\n            logger.warning(\"There is not enough participants of \"\n                           \"multi-signature\")\n            return False\n        public_keys = []\n        for node_name in participants:\n            key = self._bls_register.get_key_by_name(node_name)\n            if key is None:\n                logger.warning(\"There is no bls key for node {}\"\n                               .format(node_name))\n                return False\n            public_keys.append(key)\n        return self._multi_sig_verifier.verify(signature,\n                                               full_state_root,\n                                               public_keys)\n\n    def validate_proof(self, result):\n        \"\"\"\n        Validates state proof\n        \"\"\"\n        state_root_hash = result[STATE_PROOF]['root_hash']\n        state_root_hash = state_roots_serializer.deserialize(state_root_hash)\n        proof_nodes = result[STATE_PROOF]['proof_nodes'].encode()\n        proof_nodes = proof_nodes_serializer.deserialize(proof_nodes)\n        key, value = self.prepare_for_state(result)\n        valid = PruningState.verify_state_proof(state_root_hash,\n                                                key,\n                                                value,\n                                                proof_nodes,\n                                                serialized=True)\n        return valid\n\n    def prepare_for_state(self, result) -> tuple:\n        # this should be overridden\n        pass\n\n",
        "target_code_len": 5277,
        "diff_format": "@@ -392,28 +412,129 @@\n         \"\"\"\n+        full_req_id = '({}:{})'.format(identifier, reqId)\n         replies = self.getRepliesFromAllNodes(identifier, reqId)\n         if not replies:\n-            raise KeyError('{}{}'.format(identifier, reqId))  # NOT_FOUND\n-        # Check if at least f+1 replies are received or not.\n-        if self.quorums.reply.is_reached(len(replies)):\n-            onlyResults = {frm: reply[\"result\"] for frm, reply in\n-                           replies.items()}\n-            resultsList = list(onlyResults.values())\n-            # if all the elements in the resultList are equal - consensus\n-            # is reached.\n-\n-            # excluding state proofs from check since they can be different\n-            def without_state_proof(result):\n-                if STATE_PROOF in result:\n-                    result.pop('state_proof')\n-                return result\n-\n-            resultsList = [without_state_proof(result) for result in resultsList]\n-            if all(result == resultsList[0] for result in resultsList):\n-                return resultsList[0]  # CONFIRMED\n-            else:\n-                logger.error(\n-                    \"Received a different result from at least one of the nodes..\")\n-                return checkIfMoreThanFSameItems(resultsList, self.f)\n-        else:\n-            return False  # UNCONFIRMED\n+            raise KeyError(full_req_id)\n+        proved_reply = self.take_one_proved(replies, full_req_id)\n+        if proved_reply:\n+            logger.debug(\"Found proved reply for {}\".format(full_req_id))\n+            return proved_reply\n+        quorumed_reply = self.take_one_quorumed(replies, full_req_id)\n+        if quorumed_reply:\n+            logger.debug(\"Reply quorum for {} achieved\"\n+                         .format(full_req_id))\n+            return quorumed_reply\n+\n+    def take_one_quorumed(self, replies, full_req_id):\n+        \"\"\"\n+        Checks whether there is sufficint number of equal replies from\n+        different nodes. It uses following logic:\n+\n+        1. Check that there are sufficient replies received at all.\n+           If not - return None.\n+        2. Check that all these replies are equal.\n+           If yes - return one of them.\n+        3. Check that there is a group of equal replies which is large enough.\n+           If yes - return one reply from this group.\n+        4. Return None\n+\n+        \"\"\"\n+        if not self.quorums.reply.is_reached(len(replies)):\n+            return None\n+\n+        # excluding state proofs from check since they can be different\n+        def without_state_proof(result):\n+            if STATE_PROOF in result:\n+                result.pop('state_proof')\n+            return result\n+\n+        results = [without_state_proof(reply[\"result\"])\n+                   for reply in replies.values()]\n+\n+        first = results[0]\n+        if all(result == first for result in results):\n+            return first\n+        logger.warning(\"Received a different result from \"\n+                       \"at least one node for {}\"\n+                       .format(full_req_id))\n+\n+        result, freq = mostCommonElement(results)\n+        if not self.quorums.reply.is_reached(freq):\n+            return None\n+        return result\n+\n+    def take_one_proved(self, replies, full_req_id):\n+        \"\"\"\n+        Returns one reply with valid state proof\n+        \"\"\"\n+        for sender, reply in replies.items():\n+            result = reply['result']\n+            if STATE_PROOF not in result:\n+                logger.debug(\"There is no state proof in \"\n+                             \"reply for {} from {}\"\n+                             .format(full_req_id, sender))\n+                continue\n+            if not self.validate_multi_signature(result):\n+                logger.warning(\"{} got reply for {} with bad \"\n+                               \"multi signature from {}\"\n+                               .format(self.name, full_req_id, sender))\n+                # TODO: do something with this node\n+                continue\n+            if not self.validate_proof(result):\n+                logger.warning(\"{} got reply for {} with invalid \"\n+                               \"state proof from {}\"\n+                               .format(self.name, full_req_id, sender))\n+                # TODO: do something with this node\n+                continue\n+            return result\n+\n+    def validate_multi_signature(self, result):\n+        \"\"\"\n+        Validates multi signature\n+        \"\"\"\n+        multi_signature = result[STATE_PROOF]['multi_signature']\n+        if not multi_signature:\n+            logger.warning(\"There is a state proof, but no multi signature\")\n+            return False\n+\n+        participants = multi_signature['participants']\n+        signature = multi_signature['signature']\n+        full_state_root = create_full_root_hash(\n+            root_hash=result[STATE_PROOF]['root_hash'],\n+            pool_root_hash=multi_signature['pool_state_root']\n+        )\n+        if not self.quorums.bls_signatures.is_reached(len(participants)):\n+            logger.warning(\"There is not enough participants of \"\n+                           \"multi-signature\")\n+            return False\n+        public_keys = []\n+        for node_name in participants:\n+            key = self._bls_register.get_key_by_name(node_name)\n+            if key is None:\n+                logger.warning(\"There is no bls key for node {}\"\n+                               .format(node_name))\n+                return False\n+            public_keys.append(key)\n+        return self._multi_sig_verifier.verify(signature,\n+                                               full_state_root,\n+                                               public_keys)\n+\n+    def validate_proof(self, result):\n+        \"\"\"\n+        Validates state proof\n+        \"\"\"\n+        state_root_hash = result[STATE_PROOF]['root_hash']\n+        state_root_hash = state_roots_serializer.deserialize(state_root_hash)\n+        proof_nodes = result[STATE_PROOF]['proof_nodes'].encode()\n+        proof_nodes = proof_nodes_serializer.deserialize(proof_nodes)\n+        key, value = self.prepare_for_state(result)\n+        valid = PruningState.verify_state_proof(state_root_hash,\n+                                                key,\n+                                                value,\n+                                                proof_nodes,\n+                                                serialized=True)\n+        return valid\n+\n+    def prepare_for_state(self, result) -> tuple:\n+        # this should be overridden\n+        pass\n \n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\n        replies = self.getRepliesFromAllNodes(identifier, reqId)\n        if not replies:\n            <IND>raise KeyError('{}{}'.format(identifier, reqId))  # NOT_FOUND\n        # Check if at least f+1 replies are received or not.\n        <DED>if self.quorums.reply.is_reached(len(replies)):\n            <IND>onlyResults = {frm: reply[\"result\"] for frm, reply in\n                           replies.items()}\n            resultsList = list(onlyResults.values())\n            # if all the elements in the resultList are equal - consensus\n            # is reached.\n\n            # excluding state proofs from check since they can be different\n            def without_state_proof(result):\n                <IND>if STATE_PROOF in result:\n                    <IND>result.pop('state_proof')\n                <DED>return result\n\n            <DED>resultsList = [without_state_proof(result) for result in resultsList]\n            if all(result == resultsList[0] for result in resultsList):\n                <IND>return resultsList[0]  # CONFIRMED\n            <DED>else:\n                <IND>logger.error(\n                    \"Received a different result from at least one of the nodes..\")\n                return checkIfMoreThanFSameItems(resultsList, self.f)\n        <DED><DED>else:\n            <IND>return False  # UNCONFIRMED\n\n",
        "target_code_with_indent": "\n        full_req_id = '({}:{})'.format(identifier, reqId)\n        replies = self.getRepliesFromAllNodes(identifier, reqId)\n        if not replies:\n            <IND>raise KeyError(full_req_id)\n        <DED>proved_reply = self.take_one_proved(replies, full_req_id)\n        if proved_reply:\n            <IND>logger.debug(\"Found proved reply for {}\".format(full_req_id))\n            return proved_reply\n        <DED>quorumed_reply = self.take_one_quorumed(replies, full_req_id)\n        if quorumed_reply:\n            <IND>logger.debug(\"Reply quorum for {} achieved\"\n                         .format(full_req_id))\n            return quorumed_reply\n\n    <DED><DED>def take_one_quorumed(self, replies, full_req_id):\n        <IND>\"\"\"\n        Checks whether there is sufficint number of equal replies from\n        different nodes. It uses following logic:\n\n        1. Check that there are sufficient replies received at all.\n           If not - return None.\n        2. Check that all these replies are equal.\n           If yes - return one of them.\n        3. Check that there is a group of equal replies which is large enough.\n           If yes - return one reply from this group.\n        4. Return None\n\n        \"\"\"\n        if not self.quorums.reply.is_reached(len(replies)):\n            <IND>return None\n\n        # excluding state proofs from check since they can be different\n        <DED>def without_state_proof(result):\n            <IND>if STATE_PROOF in result:\n                <IND>result.pop('state_proof')\n            <DED>return result\n\n        <DED>results = [without_state_proof(reply[\"result\"])\n                   for reply in replies.values()]\n\n        first = results[0]\n        if all(result == first for result in results):\n            <IND>return first\n        <DED>logger.warning(\"Received a different result from \"\n                       \"at least one node for {}\"\n                       .format(full_req_id))\n\n        result, freq = mostCommonElement(results)\n        if not self.quorums.reply.is_reached(freq):\n            <IND>return None\n        <DED>return result\n\n    <DED>def take_one_proved(self, replies, full_req_id):\n        <IND>\"\"\"\n        Returns one reply with valid state proof\n        \"\"\"\n        for sender, reply in replies.items():\n            <IND>result = reply['result']\n            if STATE_PROOF not in result:\n                <IND>logger.debug(\"There is no state proof in \"\n                             \"reply for {} from {}\"\n                             .format(full_req_id, sender))\n                continue\n            <DED>if not self.validate_multi_signature(result):\n                <IND>logger.warning(\"{} got reply for {} with bad \"\n                               \"multi signature from {}\"\n                               .format(self.name, full_req_id, sender))\n                # TODO: do something with this node\n                continue\n            <DED>if not self.validate_proof(result):\n                <IND>logger.warning(\"{} got reply for {} with invalid \"\n                               \"state proof from {}\"\n                               .format(self.name, full_req_id, sender))\n                # TODO: do something with this node\n                continue\n            <DED>return result\n\n    <DED><DED>def validate_multi_signature(self, result):\n        <IND>\"\"\"\n        Validates multi signature\n        \"\"\"\n        multi_signature = result[STATE_PROOF]['multi_signature']\n        if not multi_signature:\n            <IND>logger.warning(\"There is a state proof, but no multi signature\")\n            return False\n\n        <DED>participants = multi_signature['participants']\n        signature = multi_signature['signature']\n        full_state_root = create_full_root_hash(\n            root_hash=result[STATE_PROOF]['root_hash'],\n            pool_root_hash=multi_signature['pool_state_root']\n        )\n        if not self.quorums.bls_signatures.is_reached(len(participants)):\n            <IND>logger.warning(\"There is not enough participants of \"\n                           \"multi-signature\")\n            return False\n        <DED>public_keys = []\n        for node_name in participants:\n            <IND>key = self._bls_register.get_key_by_name(node_name)\n            if key is None:\n                <IND>logger.warning(\"There is no bls key for node {}\"\n                               .format(node_name))\n                return False\n            <DED>public_keys.append(key)\n        <DED>return self._multi_sig_verifier.verify(signature,\n                                               full_state_root,\n                                               public_keys)\n\n    <DED>def validate_proof(self, result):\n        <IND>\"\"\"\n        Validates state proof\n        \"\"\"\n        state_root_hash = result[STATE_PROOF]['root_hash']\n        state_root_hash = state_roots_serializer.deserialize(state_root_hash)\n        proof_nodes = result[STATE_PROOF]['proof_nodes'].encode()\n        proof_nodes = proof_nodes_serializer.deserialize(proof_nodes)\n        key, value = self.prepare_for_state(result)\n        valid = PruningState.verify_state_proof(state_root_hash,\n                                                key,\n                                                value,\n                                                proof_nodes,\n                                                serialized=True)\n        return valid\n\n    <DED>def prepare_for_state(self, result) -> tuple:\n        # this should be overridden\n        <IND>pass\n\n"
      }
    ]
  }
]