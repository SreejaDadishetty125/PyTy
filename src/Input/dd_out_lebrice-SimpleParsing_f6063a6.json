[
  {
    "project": "lebrice/SimpleParsing",
    "commit": "f6063a6a6325f5bf711db90492203b0a07a39a0d",
    "filename": "simple_parsing/utils.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/lebrice-SimpleParsing/simple_parsing/utils.py",
    "file_hunks_size": 7,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": true,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "simple_parsing/utils.py:34:22 Incompatible variable type [9]: b is declared to have type `str` but is used as type `None`.",
    "message": " b is declared to have type `str` but is used as type `None`.",
    "rule_id": "Incompatible variable type [9]",
    "warning_line_no": 34,
    "warning_line": "def foo(a: int = 123, b: str = None) -> float:",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": true,
        "has_suppression": false,
        "source_code": "\ndef foo(a: int = 123, b: str = None) -> float:\n    \"\"\"[summary]\n\n    [extended_summary]\n\n    Parameters\n    ----------\n    - a : int, optional\n        [description], by default 123\n    - b : str, optional\n        [description], by default None\n\n    Returns\n    -------\n    float\n        [description]\n    \"\"\"\n\n\ndef field(*,\n          alias: Union[str, List[str]] = None,\n          default: Union[T, _MISSING_TYPE] = MISSING,\n          default_factory: Union[Callable[[], T], _MISSING_TYPE] = MISSING,\n          init: bool = True,\n          repr: bool = True,\n          hash: bool = None,\n          compare: bool = True,\n          metadata: Dict[str, Any] = None,\n          **custom_argparse_args) -> T:\n    \"\"\"Calls the `dataclasses.field` function, and leftover arguments are fed\n    directly to the `ArgumentParser.add_argument(*option_strings, **kwargs)`\n    method.\n\n    Parameters\n    ----------\n    alias : List[str], optional\n        Additional option_strings to pass to the `add_argument` method, by\n        default None\n    default : Union[T, _MISSING_TYPE], optional\n        The default field value (same as in `dataclasses.field`), by default MISSING\n    default_factory : Union[Callable[[], T], _MISSING_TYPE], optional\n        (same as in `dataclasses.field`), by default None\n    init : bool, optional\n        (same as in `dataclasses.field`), by default True\n    repr : bool, optional\n        (same as in `dataclasses.field`), by default True\n    hash : bool, optional\n        (same as in `dataclasses.field`), by default None\n    compare : bool, optional\n        (same as in `dataclasses.field`), by default True\n    metadata : Dict[str, Any], optional\n        (same as in `dataclasses.field`), by default None\n\n    Returns\n    -------\n    T\n        The value returned by the `dataclasses.field` function.\n    \"\"\"\n    _metadata: Dict[str, Any] = metadata if metadata is not None else {}\n    if alias:\n        _metadata.update({\n            \"alias\": alias if isinstance(alias, list) else [alias]\n        })\n    if custom_argparse_args:\n        _metadata.update({\"custom_args\": custom_argparse_args})\n\n    if default is not MISSING:\n        return dataclasses.field(  # type: ignore\n            default=default,\n            init=init,\n            repr=repr,\n            hash=hash,\n            compare=compare,\n            metadata=_metadata\n        )\n    else:\n        return dataclasses.field(  # type: ignore\n            default_factory=default_factory,\n            init=init,\n            repr=repr,\n            hash=hash,\n            compare=compare,\n            metadata=_metadata\n        )\n\n\ndef choice(*choices: T, default: T = None, **kwargs) -> T:\n    \"\"\" Makes a regular attribute, whose value, when parsed from the \n    command-line, can only be one contained in `choices`, with a default value \n    of `default`.\n\n    Returns a regular `dataclasses.field()`, but with metadata which indicates  \n    the allowed values.\n\n    Args:\n        default (T, optional): The default value of the field. Defaults to None,\n        in which case the command-line argument is required.\n\n    Raises:\n        ValueError: If the default value isn't part of the given choices.\n\n    Returns:\n        T: the result of the usual `dataclasses.field()` function (a dataclass field/attribute).\n    \"\"\"\n    if default is not None and default not in choices:\n        raise ValueError(\n            f\"Default value of {default} is not a valid option! (options: {choices})\")\n    return field(default=default, choices=choices, **kwargs)  # type: ignore\n\n\n@dataclass\nclass Bob:\n    a: str = choice(\"1\", \"2\", \"3\", default=\"1\")\n\n\ndef list_field(*default_items: SimpleValueType, **kwargs) -> List[T]:\n    \"\"\"shorthand function for setting a `list` attribute on a dataclass,\n    so that every instance of the dataclass doesn't share the same list.\n\n    Accepts any of the arguments of the `dataclasses.field` function.\n\n    Returns:\n        List[T]: a `dataclasses.field` of type `list`, containing the `default_items`. \n    \"\"\"\n    return MutableField(list, default_items, **kwargs)\n\n\ndef dict_field(default_items: Union[Dict[K, V], Iterable[Tuple[K, V]]] = None, **kwargs) -> Dict[K, V]:\n    \"\"\"shorthand function for setting a `dict` attribute on a dataclass,\n    so that every instance of the dataclass doesn't share the same `dict`.\n\n    Accepts any of the arguments of the `dataclasses.field` function.\n\n    Returns:\n        Dict[K, V]: a `dataclasses.Field` of type `Dict[K, V]`, containing the `default_items`. \n    \"\"\"\n    if default_items is None:\n        default_items = []\n    elif isinstance(default_items, dict):\n        default_items = default_items.items()\n    return MutableField(dict, default_items, **kwargs)\n\n\ndef set_field(*default_items: T, **kwargs) -> Set[T]:\n    return MutableField(set, default_items, **kwargs)\n\n\ndef MutableField(_type: Type[T], *args, init: bool = True, repr: bool = True, hash: bool = None, compare: bool = True, metadata: Dict[str, Any] = None, **kwargs) -> T:\n    return field(default_factory=partial(_type, *args, **kwargs), init=init, repr=repr, hash=hash, compare=compare, metadata=metadata)\n\n\ndef subparsers(subcommands: Dict[str, Type], default=None) -> Any:\n    if default is not None and default not in subcommands:\n        raise ValueError(\n            f\"Default value of {default} is not a valid subparser! (subcommand: {subcommands})\")\n    return field(default=default, metadata={\n        \"subparsers\": subcommands,\n        \"default\": default,\n    })\n\n",
        "source_code_len": 5501,
        "target_code": "\n\n",
        "target_code_len": 2,
        "diff_format": "@@ -33,161 +36,2 @@\n \n-def foo(a: int = 123, b: str = None) -> float:\n-    \"\"\"[summary]\n-\n-    [extended_summary]\n-\n-    Parameters\n-    ----------\n-    - a : int, optional\n-        [description], by default 123\n-    - b : str, optional\n-        [description], by default None\n-\n-    Returns\n-    -------\n-    float\n-        [description]\n-    \"\"\"\n-\n-\n-def field(*,\n-          alias: Union[str, List[str]] = None,\n-          default: Union[T, _MISSING_TYPE] = MISSING,\n-          default_factory: Union[Callable[[], T], _MISSING_TYPE] = MISSING,\n-          init: bool = True,\n-          repr: bool = True,\n-          hash: bool = None,\n-          compare: bool = True,\n-          metadata: Dict[str, Any] = None,\n-          **custom_argparse_args) -> T:\n-    \"\"\"Calls the `dataclasses.field` function, and leftover arguments are fed\n-    directly to the `ArgumentParser.add_argument(*option_strings, **kwargs)`\n-    method.\n-\n-    Parameters\n-    ----------\n-    alias : List[str], optional\n-        Additional option_strings to pass to the `add_argument` method, by\n-        default None\n-    default : Union[T, _MISSING_TYPE], optional\n-        The default field value (same as in `dataclasses.field`), by default MISSING\n-    default_factory : Union[Callable[[], T], _MISSING_TYPE], optional\n-        (same as in `dataclasses.field`), by default None\n-    init : bool, optional\n-        (same as in `dataclasses.field`), by default True\n-    repr : bool, optional\n-        (same as in `dataclasses.field`), by default True\n-    hash : bool, optional\n-        (same as in `dataclasses.field`), by default None\n-    compare : bool, optional\n-        (same as in `dataclasses.field`), by default True\n-    metadata : Dict[str, Any], optional\n-        (same as in `dataclasses.field`), by default None\n-\n-    Returns\n-    -------\n-    T\n-        The value returned by the `dataclasses.field` function.\n-    \"\"\"\n-    _metadata: Dict[str, Any] = metadata if metadata is not None else {}\n-    if alias:\n-        _metadata.update({\n-            \"alias\": alias if isinstance(alias, list) else [alias]\n-        })\n-    if custom_argparse_args:\n-        _metadata.update({\"custom_args\": custom_argparse_args})\n-\n-    if default is not MISSING:\n-        return dataclasses.field(  # type: ignore\n-            default=default,\n-            init=init,\n-            repr=repr,\n-            hash=hash,\n-            compare=compare,\n-            metadata=_metadata\n-        )\n-    else:\n-        return dataclasses.field(  # type: ignore\n-            default_factory=default_factory,\n-            init=init,\n-            repr=repr,\n-            hash=hash,\n-            compare=compare,\n-            metadata=_metadata\n-        )\n-\n-\n-def choice(*choices: T, default: T = None, **kwargs) -> T:\n-    \"\"\" Makes a regular attribute, whose value, when parsed from the \n-    command-line, can only be one contained in `choices`, with a default value \n-    of `default`.\n-\n-    Returns a regular `dataclasses.field()`, but with metadata which indicates  \n-    the allowed values.\n-\n-    Args:\n-        default (T, optional): The default value of the field. Defaults to None,\n-        in which case the command-line argument is required.\n-\n-    Raises:\n-        ValueError: If the default value isn't part of the given choices.\n-\n-    Returns:\n-        T: the result of the usual `dataclasses.field()` function (a dataclass field/attribute).\n-    \"\"\"\n-    if default is not None and default not in choices:\n-        raise ValueError(\n-            f\"Default value of {default} is not a valid option! (options: {choices})\")\n-    return field(default=default, choices=choices, **kwargs)  # type: ignore\n-\n-\n-@dataclass\n-class Bob:\n-    a: str = choice(\"1\", \"2\", \"3\", default=\"1\")\n-\n-\n-def list_field(*default_items: SimpleValueType, **kwargs) -> List[T]:\n-    \"\"\"shorthand function for setting a `list` attribute on a dataclass,\n-    so that every instance of the dataclass doesn't share the same list.\n-\n-    Accepts any of the arguments of the `dataclasses.field` function.\n-\n-    Returns:\n-        List[T]: a `dataclasses.field` of type `list`, containing the `default_items`. \n-    \"\"\"\n-    return MutableField(list, default_items, **kwargs)\n-\n-\n-def dict_field(default_items: Union[Dict[K, V], Iterable[Tuple[K, V]]] = None, **kwargs) -> Dict[K, V]:\n-    \"\"\"shorthand function for setting a `dict` attribute on a dataclass,\n-    so that every instance of the dataclass doesn't share the same `dict`.\n-\n-    Accepts any of the arguments of the `dataclasses.field` function.\n-\n-    Returns:\n-        Dict[K, V]: a `dataclasses.Field` of type `Dict[K, V]`, containing the `default_items`. \n-    \"\"\"\n-    if default_items is None:\n-        default_items = []\n-    elif isinstance(default_items, dict):\n-        default_items = default_items.items()\n-    return MutableField(dict, default_items, **kwargs)\n-\n-\n-def set_field(*default_items: T, **kwargs) -> Set[T]:\n-    return MutableField(set, default_items, **kwargs)\n-\n-\n-def MutableField(_type: Type[T], *args, init: bool = True, repr: bool = True, hash: bool = None, compare: bool = True, metadata: Dict[str, Any] = None, **kwargs) -> T:\n-    return field(default_factory=partial(_type, *args, **kwargs), init=init, repr=repr, hash=hash, compare=compare, metadata=metadata)\n-\n-\n-def subparsers(subcommands: Dict[str, Type], default=None) -> Any:\n-    if default is not None and default not in subcommands:\n-        raise ValueError(\n-            f\"Default value of {default} is not a valid subparser! (subcommand: {subcommands})\")\n-    return field(default=default, metadata={\n-        \"subparsers\": subcommands,\n-        \"default\": default,\n-    })\n \n",
        "source_code_with_indent": "\ndef foo(a: int = 123, b: str = None) -> float:\n    <IND>\"\"\"[summary]\n\n    [extended_summary]\n\n    Parameters\n    ----------\n    - a : int, optional\n        [description], by default 123\n    - b : str, optional\n        [description], by default None\n\n    Returns\n    -------\n    float\n        [description]\n    \"\"\"\n\n\n<DED>def field(*,\n          alias: Union[str, List[str]] = None,\n          default: Union[T, _MISSING_TYPE] = MISSING,\n          default_factory: Union[Callable[[], T], _MISSING_TYPE] = MISSING,\n          init: bool = True,\n          repr: bool = True,\n          hash: bool = None,\n          compare: bool = True,\n          metadata: Dict[str, Any] = None,\n          **custom_argparse_args) -> T:\n    <IND>\"\"\"Calls the `dataclasses.field` function, and leftover arguments are fed\n    directly to the `ArgumentParser.add_argument(*option_strings, **kwargs)`\n    method.\n\n    Parameters\n    ----------\n    alias : List[str], optional\n        Additional option_strings to pass to the `add_argument` method, by\n        default None\n    default : Union[T, _MISSING_TYPE], optional\n        The default field value (same as in `dataclasses.field`), by default MISSING\n    default_factory : Union[Callable[[], T], _MISSING_TYPE], optional\n        (same as in `dataclasses.field`), by default None\n    init : bool, optional\n        (same as in `dataclasses.field`), by default True\n    repr : bool, optional\n        (same as in `dataclasses.field`), by default True\n    hash : bool, optional\n        (same as in `dataclasses.field`), by default None\n    compare : bool, optional\n        (same as in `dataclasses.field`), by default True\n    metadata : Dict[str, Any], optional\n        (same as in `dataclasses.field`), by default None\n\n    Returns\n    -------\n    T\n        The value returned by the `dataclasses.field` function.\n    \"\"\"\n    _metadata: Dict[str, Any] = metadata if metadata is not None else {}\n    if alias:\n        <IND>_metadata.update({\n            \"alias\": alias if isinstance(alias, list) else [alias]\n        })\n    <DED>if custom_argparse_args:\n        <IND>_metadata.update({\"custom_args\": custom_argparse_args})\n\n    <DED>if default is not MISSING:\n        <IND>return dataclasses.field(  # type: ignore\n            default=default,\n            init=init,\n            repr=repr,\n            hash=hash,\n            compare=compare,\n            metadata=_metadata\n        )\n    <DED>else:\n        <IND>return dataclasses.field(  # type: ignore\n            default_factory=default_factory,\n            init=init,\n            repr=repr,\n            hash=hash,\n            compare=compare,\n            metadata=_metadata\n        )\n\n\n<DED><DED>def choice(*choices: T, default: T = None, **kwargs) -> T:\n    <IND>\"\"\" Makes a regular attribute, whose value, when parsed from the \n    command-line, can only be one contained in `choices`, with a default value \n    of `default`.\n\n    Returns a regular `dataclasses.field()`, but with metadata which indicates  \n    the allowed values.\n\n    Args:\n        default (T, optional): The default value of the field. Defaults to None,\n        in which case the command-line argument is required.\n\n    Raises:\n        ValueError: If the default value isn't part of the given choices.\n\n    Returns:\n        T: the result of the usual `dataclasses.field()` function (a dataclass field/attribute).\n    \"\"\"\n    if default is not None and default not in choices:\n        <IND>raise ValueError(\n            f\"Default value of {default} is not a valid option! (options: {choices})\")\n    <DED>return field(default=default, choices=choices, **kwargs)  # type: ignore\n\n\n<DED>@dataclass\nclass Bob:\n    <IND>a: str = choice(\"1\", \"2\", \"3\", default=\"1\")\n\n\n<DED>def list_field(*default_items: SimpleValueType, **kwargs) -> List[T]:\n    <IND>\"\"\"shorthand function for setting a `list` attribute on a dataclass,\n    so that every instance of the dataclass doesn't share the same list.\n\n    Accepts any of the arguments of the `dataclasses.field` function.\n\n    Returns:\n        List[T]: a `dataclasses.field` of type `list`, containing the `default_items`. \n    \"\"\"\n    return MutableField(list, default_items, **kwargs)\n\n\n<DED>def dict_field(default_items: Union[Dict[K, V], Iterable[Tuple[K, V]]] = None, **kwargs) -> Dict[K, V]:\n    <IND>\"\"\"shorthand function for setting a `dict` attribute on a dataclass,\n    so that every instance of the dataclass doesn't share the same `dict`.\n\n    Accepts any of the arguments of the `dataclasses.field` function.\n\n    Returns:\n        Dict[K, V]: a `dataclasses.Field` of type `Dict[K, V]`, containing the `default_items`. \n    \"\"\"\n    if default_items is None:\n        <IND>default_items = []\n    <DED>elif isinstance(default_items, dict):\n        <IND>default_items = default_items.items()\n    <DED>return MutableField(dict, default_items, **kwargs)\n\n\n<DED>def set_field(*default_items: T, **kwargs) -> Set[T]:\n    <IND>return MutableField(set, default_items, **kwargs)\n\n\n<DED>def MutableField(_type: Type[T], *args, init: bool = True, repr: bool = True, hash: bool = None, compare: bool = True, metadata: Dict[str, Any] = None, **kwargs) -> T:\n    <IND>return field(default_factory=partial(_type, *args, **kwargs), init=init, repr=repr, hash=hash, compare=compare, metadata=metadata)\n\n\n<DED>def subparsers(subcommands: Dict[str, Type], default=None) -> Any:\n    <IND>if default is not None and default not in subcommands:\n        <IND>raise ValueError(\n            f\"Default value of {default} is not a valid subparser! (subcommand: {subcommands})\")\n    <DED>return field(default=default, metadata={\n        \"subparsers\": subcommands,\n        \"default\": default,\n    })\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "lebrice/SimpleParsing",
    "commit": "f6063a6a6325f5bf711db90492203b0a07a39a0d",
    "filename": "simple_parsing/utils.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/lebrice-SimpleParsing/simple_parsing/utils.py",
    "file_hunks_size": 7,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": true,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "simple_parsing/utils.py:35:4 Incompatible return type [7]: Expected `float` but got implicit return value of `None`.",
    "message": " Expected `float` but got implicit return value of `None`.",
    "rule_id": "Incompatible return type [7]",
    "warning_line_no": 35,
    "warning_line": "    \"\"\"[summary]",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": true,
        "has_suppression": false,
        "source_code": "\ndef foo(a: int = 123, b: str = None) -> float:\n    \"\"\"[summary]\n\n    [extended_summary]\n\n    Parameters\n    ----------\n    - a : int, optional\n        [description], by default 123\n    - b : str, optional\n        [description], by default None\n\n    Returns\n    -------\n    float\n        [description]\n    \"\"\"\n\n\ndef field(*,\n          alias: Union[str, List[str]] = None,\n          default: Union[T, _MISSING_TYPE] = MISSING,\n          default_factory: Union[Callable[[], T], _MISSING_TYPE] = MISSING,\n          init: bool = True,\n          repr: bool = True,\n          hash: bool = None,\n          compare: bool = True,\n          metadata: Dict[str, Any] = None,\n          **custom_argparse_args) -> T:\n    \"\"\"Calls the `dataclasses.field` function, and leftover arguments are fed\n    directly to the `ArgumentParser.add_argument(*option_strings, **kwargs)`\n    method.\n\n    Parameters\n    ----------\n    alias : List[str], optional\n        Additional option_strings to pass to the `add_argument` method, by\n        default None\n    default : Union[T, _MISSING_TYPE], optional\n        The default field value (same as in `dataclasses.field`), by default MISSING\n    default_factory : Union[Callable[[], T], _MISSING_TYPE], optional\n        (same as in `dataclasses.field`), by default None\n    init : bool, optional\n        (same as in `dataclasses.field`), by default True\n    repr : bool, optional\n        (same as in `dataclasses.field`), by default True\n    hash : bool, optional\n        (same as in `dataclasses.field`), by default None\n    compare : bool, optional\n        (same as in `dataclasses.field`), by default True\n    metadata : Dict[str, Any], optional\n        (same as in `dataclasses.field`), by default None\n\n    Returns\n    -------\n    T\n        The value returned by the `dataclasses.field` function.\n    \"\"\"\n    _metadata: Dict[str, Any] = metadata if metadata is not None else {}\n    if alias:\n        _metadata.update({\n            \"alias\": alias if isinstance(alias, list) else [alias]\n        })\n    if custom_argparse_args:\n        _metadata.update({\"custom_args\": custom_argparse_args})\n\n    if default is not MISSING:\n        return dataclasses.field(  # type: ignore\n            default=default,\n            init=init,\n            repr=repr,\n            hash=hash,\n            compare=compare,\n            metadata=_metadata\n        )\n    else:\n        return dataclasses.field(  # type: ignore\n            default_factory=default_factory,\n            init=init,\n            repr=repr,\n            hash=hash,\n            compare=compare,\n            metadata=_metadata\n        )\n\n\ndef choice(*choices: T, default: T = None, **kwargs) -> T:\n    \"\"\" Makes a regular attribute, whose value, when parsed from the \n    command-line, can only be one contained in `choices`, with a default value \n    of `default`.\n\n    Returns a regular `dataclasses.field()`, but with metadata which indicates  \n    the allowed values.\n\n    Args:\n        default (T, optional): The default value of the field. Defaults to None,\n        in which case the command-line argument is required.\n\n    Raises:\n        ValueError: If the default value isn't part of the given choices.\n\n    Returns:\n        T: the result of the usual `dataclasses.field()` function (a dataclass field/attribute).\n    \"\"\"\n    if default is not None and default not in choices:\n        raise ValueError(\n            f\"Default value of {default} is not a valid option! (options: {choices})\")\n    return field(default=default, choices=choices, **kwargs)  # type: ignore\n\n\n@dataclass\nclass Bob:\n    a: str = choice(\"1\", \"2\", \"3\", default=\"1\")\n\n\ndef list_field(*default_items: SimpleValueType, **kwargs) -> List[T]:\n    \"\"\"shorthand function for setting a `list` attribute on a dataclass,\n    so that every instance of the dataclass doesn't share the same list.\n\n    Accepts any of the arguments of the `dataclasses.field` function.\n\n    Returns:\n        List[T]: a `dataclasses.field` of type `list`, containing the `default_items`. \n    \"\"\"\n    return MutableField(list, default_items, **kwargs)\n\n\ndef dict_field(default_items: Union[Dict[K, V], Iterable[Tuple[K, V]]] = None, **kwargs) -> Dict[K, V]:\n    \"\"\"shorthand function for setting a `dict` attribute on a dataclass,\n    so that every instance of the dataclass doesn't share the same `dict`.\n\n    Accepts any of the arguments of the `dataclasses.field` function.\n\n    Returns:\n        Dict[K, V]: a `dataclasses.Field` of type `Dict[K, V]`, containing the `default_items`. \n    \"\"\"\n    if default_items is None:\n        default_items = []\n    elif isinstance(default_items, dict):\n        default_items = default_items.items()\n    return MutableField(dict, default_items, **kwargs)\n\n\ndef set_field(*default_items: T, **kwargs) -> Set[T]:\n    return MutableField(set, default_items, **kwargs)\n\n\ndef MutableField(_type: Type[T], *args, init: bool = True, repr: bool = True, hash: bool = None, compare: bool = True, metadata: Dict[str, Any] = None, **kwargs) -> T:\n    return field(default_factory=partial(_type, *args, **kwargs), init=init, repr=repr, hash=hash, compare=compare, metadata=metadata)\n\n\ndef subparsers(subcommands: Dict[str, Type], default=None) -> Any:\n    if default is not None and default not in subcommands:\n        raise ValueError(\n            f\"Default value of {default} is not a valid subparser! (subcommand: {subcommands})\")\n    return field(default=default, metadata={\n        \"subparsers\": subcommands,\n        \"default\": default,\n    })\n\n",
        "source_code_len": 5501,
        "target_code": "\n\n",
        "target_code_len": 2,
        "diff_format": "@@ -33,161 +36,2 @@\n \n-def foo(a: int = 123, b: str = None) -> float:\n-    \"\"\"[summary]\n-\n-    [extended_summary]\n-\n-    Parameters\n-    ----------\n-    - a : int, optional\n-        [description], by default 123\n-    - b : str, optional\n-        [description], by default None\n-\n-    Returns\n-    -------\n-    float\n-        [description]\n-    \"\"\"\n-\n-\n-def field(*,\n-          alias: Union[str, List[str]] = None,\n-          default: Union[T, _MISSING_TYPE] = MISSING,\n-          default_factory: Union[Callable[[], T], _MISSING_TYPE] = MISSING,\n-          init: bool = True,\n-          repr: bool = True,\n-          hash: bool = None,\n-          compare: bool = True,\n-          metadata: Dict[str, Any] = None,\n-          **custom_argparse_args) -> T:\n-    \"\"\"Calls the `dataclasses.field` function, and leftover arguments are fed\n-    directly to the `ArgumentParser.add_argument(*option_strings, **kwargs)`\n-    method.\n-\n-    Parameters\n-    ----------\n-    alias : List[str], optional\n-        Additional option_strings to pass to the `add_argument` method, by\n-        default None\n-    default : Union[T, _MISSING_TYPE], optional\n-        The default field value (same as in `dataclasses.field`), by default MISSING\n-    default_factory : Union[Callable[[], T], _MISSING_TYPE], optional\n-        (same as in `dataclasses.field`), by default None\n-    init : bool, optional\n-        (same as in `dataclasses.field`), by default True\n-    repr : bool, optional\n-        (same as in `dataclasses.field`), by default True\n-    hash : bool, optional\n-        (same as in `dataclasses.field`), by default None\n-    compare : bool, optional\n-        (same as in `dataclasses.field`), by default True\n-    metadata : Dict[str, Any], optional\n-        (same as in `dataclasses.field`), by default None\n-\n-    Returns\n-    -------\n-    T\n-        The value returned by the `dataclasses.field` function.\n-    \"\"\"\n-    _metadata: Dict[str, Any] = metadata if metadata is not None else {}\n-    if alias:\n-        _metadata.update({\n-            \"alias\": alias if isinstance(alias, list) else [alias]\n-        })\n-    if custom_argparse_args:\n-        _metadata.update({\"custom_args\": custom_argparse_args})\n-\n-    if default is not MISSING:\n-        return dataclasses.field(  # type: ignore\n-            default=default,\n-            init=init,\n-            repr=repr,\n-            hash=hash,\n-            compare=compare,\n-            metadata=_metadata\n-        )\n-    else:\n-        return dataclasses.field(  # type: ignore\n-            default_factory=default_factory,\n-            init=init,\n-            repr=repr,\n-            hash=hash,\n-            compare=compare,\n-            metadata=_metadata\n-        )\n-\n-\n-def choice(*choices: T, default: T = None, **kwargs) -> T:\n-    \"\"\" Makes a regular attribute, whose value, when parsed from the \n-    command-line, can only be one contained in `choices`, with a default value \n-    of `default`.\n-\n-    Returns a regular `dataclasses.field()`, but with metadata which indicates  \n-    the allowed values.\n-\n-    Args:\n-        default (T, optional): The default value of the field. Defaults to None,\n-        in which case the command-line argument is required.\n-\n-    Raises:\n-        ValueError: If the default value isn't part of the given choices.\n-\n-    Returns:\n-        T: the result of the usual `dataclasses.field()` function (a dataclass field/attribute).\n-    \"\"\"\n-    if default is not None and default not in choices:\n-        raise ValueError(\n-            f\"Default value of {default} is not a valid option! (options: {choices})\")\n-    return field(default=default, choices=choices, **kwargs)  # type: ignore\n-\n-\n-@dataclass\n-class Bob:\n-    a: str = choice(\"1\", \"2\", \"3\", default=\"1\")\n-\n-\n-def list_field(*default_items: SimpleValueType, **kwargs) -> List[T]:\n-    \"\"\"shorthand function for setting a `list` attribute on a dataclass,\n-    so that every instance of the dataclass doesn't share the same list.\n-\n-    Accepts any of the arguments of the `dataclasses.field` function.\n-\n-    Returns:\n-        List[T]: a `dataclasses.field` of type `list`, containing the `default_items`. \n-    \"\"\"\n-    return MutableField(list, default_items, **kwargs)\n-\n-\n-def dict_field(default_items: Union[Dict[K, V], Iterable[Tuple[K, V]]] = None, **kwargs) -> Dict[K, V]:\n-    \"\"\"shorthand function for setting a `dict` attribute on a dataclass,\n-    so that every instance of the dataclass doesn't share the same `dict`.\n-\n-    Accepts any of the arguments of the `dataclasses.field` function.\n-\n-    Returns:\n-        Dict[K, V]: a `dataclasses.Field` of type `Dict[K, V]`, containing the `default_items`. \n-    \"\"\"\n-    if default_items is None:\n-        default_items = []\n-    elif isinstance(default_items, dict):\n-        default_items = default_items.items()\n-    return MutableField(dict, default_items, **kwargs)\n-\n-\n-def set_field(*default_items: T, **kwargs) -> Set[T]:\n-    return MutableField(set, default_items, **kwargs)\n-\n-\n-def MutableField(_type: Type[T], *args, init: bool = True, repr: bool = True, hash: bool = None, compare: bool = True, metadata: Dict[str, Any] = None, **kwargs) -> T:\n-    return field(default_factory=partial(_type, *args, **kwargs), init=init, repr=repr, hash=hash, compare=compare, metadata=metadata)\n-\n-\n-def subparsers(subcommands: Dict[str, Type], default=None) -> Any:\n-    if default is not None and default not in subcommands:\n-        raise ValueError(\n-            f\"Default value of {default} is not a valid subparser! (subcommand: {subcommands})\")\n-    return field(default=default, metadata={\n-        \"subparsers\": subcommands,\n-        \"default\": default,\n-    })\n \n",
        "source_code_with_indent": "\ndef foo(a: int = 123, b: str = None) -> float:\n    <IND>\"\"\"[summary]\n\n    [extended_summary]\n\n    Parameters\n    ----------\n    - a : int, optional\n        [description], by default 123\n    - b : str, optional\n        [description], by default None\n\n    Returns\n    -------\n    float\n        [description]\n    \"\"\"\n\n\n<DED>def field(*,\n          alias: Union[str, List[str]] = None,\n          default: Union[T, _MISSING_TYPE] = MISSING,\n          default_factory: Union[Callable[[], T], _MISSING_TYPE] = MISSING,\n          init: bool = True,\n          repr: bool = True,\n          hash: bool = None,\n          compare: bool = True,\n          metadata: Dict[str, Any] = None,\n          **custom_argparse_args) -> T:\n    <IND>\"\"\"Calls the `dataclasses.field` function, and leftover arguments are fed\n    directly to the `ArgumentParser.add_argument(*option_strings, **kwargs)`\n    method.\n\n    Parameters\n    ----------\n    alias : List[str], optional\n        Additional option_strings to pass to the `add_argument` method, by\n        default None\n    default : Union[T, _MISSING_TYPE], optional\n        The default field value (same as in `dataclasses.field`), by default MISSING\n    default_factory : Union[Callable[[], T], _MISSING_TYPE], optional\n        (same as in `dataclasses.field`), by default None\n    init : bool, optional\n        (same as in `dataclasses.field`), by default True\n    repr : bool, optional\n        (same as in `dataclasses.field`), by default True\n    hash : bool, optional\n        (same as in `dataclasses.field`), by default None\n    compare : bool, optional\n        (same as in `dataclasses.field`), by default True\n    metadata : Dict[str, Any], optional\n        (same as in `dataclasses.field`), by default None\n\n    Returns\n    -------\n    T\n        The value returned by the `dataclasses.field` function.\n    \"\"\"\n    _metadata: Dict[str, Any] = metadata if metadata is not None else {}\n    if alias:\n        <IND>_metadata.update({\n            \"alias\": alias if isinstance(alias, list) else [alias]\n        })\n    <DED>if custom_argparse_args:\n        <IND>_metadata.update({\"custom_args\": custom_argparse_args})\n\n    <DED>if default is not MISSING:\n        <IND>return dataclasses.field(  # type: ignore\n            default=default,\n            init=init,\n            repr=repr,\n            hash=hash,\n            compare=compare,\n            metadata=_metadata\n        )\n    <DED>else:\n        <IND>return dataclasses.field(  # type: ignore\n            default_factory=default_factory,\n            init=init,\n            repr=repr,\n            hash=hash,\n            compare=compare,\n            metadata=_metadata\n        )\n\n\n<DED><DED>def choice(*choices: T, default: T = None, **kwargs) -> T:\n    <IND>\"\"\" Makes a regular attribute, whose value, when parsed from the \n    command-line, can only be one contained in `choices`, with a default value \n    of `default`.\n\n    Returns a regular `dataclasses.field()`, but with metadata which indicates  \n    the allowed values.\n\n    Args:\n        default (T, optional): The default value of the field. Defaults to None,\n        in which case the command-line argument is required.\n\n    Raises:\n        ValueError: If the default value isn't part of the given choices.\n\n    Returns:\n        T: the result of the usual `dataclasses.field()` function (a dataclass field/attribute).\n    \"\"\"\n    if default is not None and default not in choices:\n        <IND>raise ValueError(\n            f\"Default value of {default} is not a valid option! (options: {choices})\")\n    <DED>return field(default=default, choices=choices, **kwargs)  # type: ignore\n\n\n<DED>@dataclass\nclass Bob:\n    <IND>a: str = choice(\"1\", \"2\", \"3\", default=\"1\")\n\n\n<DED>def list_field(*default_items: SimpleValueType, **kwargs) -> List[T]:\n    <IND>\"\"\"shorthand function for setting a `list` attribute on a dataclass,\n    so that every instance of the dataclass doesn't share the same list.\n\n    Accepts any of the arguments of the `dataclasses.field` function.\n\n    Returns:\n        List[T]: a `dataclasses.field` of type `list`, containing the `default_items`. \n    \"\"\"\n    return MutableField(list, default_items, **kwargs)\n\n\n<DED>def dict_field(default_items: Union[Dict[K, V], Iterable[Tuple[K, V]]] = None, **kwargs) -> Dict[K, V]:\n    <IND>\"\"\"shorthand function for setting a `dict` attribute on a dataclass,\n    so that every instance of the dataclass doesn't share the same `dict`.\n\n    Accepts any of the arguments of the `dataclasses.field` function.\n\n    Returns:\n        Dict[K, V]: a `dataclasses.Field` of type `Dict[K, V]`, containing the `default_items`. \n    \"\"\"\n    if default_items is None:\n        <IND>default_items = []\n    <DED>elif isinstance(default_items, dict):\n        <IND>default_items = default_items.items()\n    <DED>return MutableField(dict, default_items, **kwargs)\n\n\n<DED>def set_field(*default_items: T, **kwargs) -> Set[T]:\n    <IND>return MutableField(set, default_items, **kwargs)\n\n\n<DED>def MutableField(_type: Type[T], *args, init: bool = True, repr: bool = True, hash: bool = None, compare: bool = True, metadata: Dict[str, Any] = None, **kwargs) -> T:\n    <IND>return field(default_factory=partial(_type, *args, **kwargs), init=init, repr=repr, hash=hash, compare=compare, metadata=metadata)\n\n\n<DED>def subparsers(subcommands: Dict[str, Type], default=None) -> Any:\n    <IND>if default is not None and default not in subcommands:\n        <IND>raise ValueError(\n            f\"Default value of {default} is not a valid subparser! (subcommand: {subcommands})\")\n    <DED>return field(default=default, metadata={\n        \"subparsers\": subcommands,\n        \"default\": default,\n    })\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "lebrice/SimpleParsing",
    "commit": "f6063a6a6325f5bf711db90492203b0a07a39a0d",
    "filename": "simple_parsing/utils.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/lebrice-SimpleParsing/simple_parsing/utils.py",
    "file_hunks_size": 7,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": true,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "simple_parsing/utils.py:54:10 Incompatible variable type [9]: alias is declared to have type `typing.Union[typing.List[str], str]` but is used as type `None`.",
    "message": " alias is declared to have type `typing.Union[typing.List[str], str]` but is used as type `None`.",
    "rule_id": "Incompatible variable type [9]",
    "warning_line_no": 54,
    "warning_line": "          alias: Union[str, List[str]] = None,",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": true,
        "has_suppression": false,
        "source_code": "\ndef foo(a: int = 123, b: str = None) -> float:\n    \"\"\"[summary]\n\n    [extended_summary]\n\n    Parameters\n    ----------\n    - a : int, optional\n        [description], by default 123\n    - b : str, optional\n        [description], by default None\n\n    Returns\n    -------\n    float\n        [description]\n    \"\"\"\n\n\ndef field(*,\n          alias: Union[str, List[str]] = None,\n          default: Union[T, _MISSING_TYPE] = MISSING,\n          default_factory: Union[Callable[[], T], _MISSING_TYPE] = MISSING,\n          init: bool = True,\n          repr: bool = True,\n          hash: bool = None,\n          compare: bool = True,\n          metadata: Dict[str, Any] = None,\n          **custom_argparse_args) -> T:\n    \"\"\"Calls the `dataclasses.field` function, and leftover arguments are fed\n    directly to the `ArgumentParser.add_argument(*option_strings, **kwargs)`\n    method.\n\n    Parameters\n    ----------\n    alias : List[str], optional\n        Additional option_strings to pass to the `add_argument` method, by\n        default None\n    default : Union[T, _MISSING_TYPE], optional\n        The default field value (same as in `dataclasses.field`), by default MISSING\n    default_factory : Union[Callable[[], T], _MISSING_TYPE], optional\n        (same as in `dataclasses.field`), by default None\n    init : bool, optional\n        (same as in `dataclasses.field`), by default True\n    repr : bool, optional\n        (same as in `dataclasses.field`), by default True\n    hash : bool, optional\n        (same as in `dataclasses.field`), by default None\n    compare : bool, optional\n        (same as in `dataclasses.field`), by default True\n    metadata : Dict[str, Any], optional\n        (same as in `dataclasses.field`), by default None\n\n    Returns\n    -------\n    T\n        The value returned by the `dataclasses.field` function.\n    \"\"\"\n    _metadata: Dict[str, Any] = metadata if metadata is not None else {}\n    if alias:\n        _metadata.update({\n            \"alias\": alias if isinstance(alias, list) else [alias]\n        })\n    if custom_argparse_args:\n        _metadata.update({\"custom_args\": custom_argparse_args})\n\n    if default is not MISSING:\n        return dataclasses.field(  # type: ignore\n            default=default,\n            init=init,\n            repr=repr,\n            hash=hash,\n            compare=compare,\n            metadata=_metadata\n        )\n    else:\n        return dataclasses.field(  # type: ignore\n            default_factory=default_factory,\n            init=init,\n            repr=repr,\n            hash=hash,\n            compare=compare,\n            metadata=_metadata\n        )\n\n\ndef choice(*choices: T, default: T = None, **kwargs) -> T:\n    \"\"\" Makes a regular attribute, whose value, when parsed from the \n    command-line, can only be one contained in `choices`, with a default value \n    of `default`.\n\n    Returns a regular `dataclasses.field()`, but with metadata which indicates  \n    the allowed values.\n\n    Args:\n        default (T, optional): The default value of the field. Defaults to None,\n        in which case the command-line argument is required.\n\n    Raises:\n        ValueError: If the default value isn't part of the given choices.\n\n    Returns:\n        T: the result of the usual `dataclasses.field()` function (a dataclass field/attribute).\n    \"\"\"\n    if default is not None and default not in choices:\n        raise ValueError(\n            f\"Default value of {default} is not a valid option! (options: {choices})\")\n    return field(default=default, choices=choices, **kwargs)  # type: ignore\n\n\n@dataclass\nclass Bob:\n    a: str = choice(\"1\", \"2\", \"3\", default=\"1\")\n\n\ndef list_field(*default_items: SimpleValueType, **kwargs) -> List[T]:\n    \"\"\"shorthand function for setting a `list` attribute on a dataclass,\n    so that every instance of the dataclass doesn't share the same list.\n\n    Accepts any of the arguments of the `dataclasses.field` function.\n\n    Returns:\n        List[T]: a `dataclasses.field` of type `list`, containing the `default_items`. \n    \"\"\"\n    return MutableField(list, default_items, **kwargs)\n\n\ndef dict_field(default_items: Union[Dict[K, V], Iterable[Tuple[K, V]]] = None, **kwargs) -> Dict[K, V]:\n    \"\"\"shorthand function for setting a `dict` attribute on a dataclass,\n    so that every instance of the dataclass doesn't share the same `dict`.\n\n    Accepts any of the arguments of the `dataclasses.field` function.\n\n    Returns:\n        Dict[K, V]: a `dataclasses.Field` of type `Dict[K, V]`, containing the `default_items`. \n    \"\"\"\n    if default_items is None:\n        default_items = []\n    elif isinstance(default_items, dict):\n        default_items = default_items.items()\n    return MutableField(dict, default_items, **kwargs)\n\n\ndef set_field(*default_items: T, **kwargs) -> Set[T]:\n    return MutableField(set, default_items, **kwargs)\n\n\ndef MutableField(_type: Type[T], *args, init: bool = True, repr: bool = True, hash: bool = None, compare: bool = True, metadata: Dict[str, Any] = None, **kwargs) -> T:\n    return field(default_factory=partial(_type, *args, **kwargs), init=init, repr=repr, hash=hash, compare=compare, metadata=metadata)\n\n\ndef subparsers(subcommands: Dict[str, Type], default=None) -> Any:\n    if default is not None and default not in subcommands:\n        raise ValueError(\n            f\"Default value of {default} is not a valid subparser! (subcommand: {subcommands})\")\n    return field(default=default, metadata={\n        \"subparsers\": subcommands,\n        \"default\": default,\n    })\n\n",
        "source_code_len": 5501,
        "target_code": "\n\n",
        "target_code_len": 2,
        "diff_format": "@@ -33,161 +36,2 @@\n \n-def foo(a: int = 123, b: str = None) -> float:\n-    \"\"\"[summary]\n-\n-    [extended_summary]\n-\n-    Parameters\n-    ----------\n-    - a : int, optional\n-        [description], by default 123\n-    - b : str, optional\n-        [description], by default None\n-\n-    Returns\n-    -------\n-    float\n-        [description]\n-    \"\"\"\n-\n-\n-def field(*,\n-          alias: Union[str, List[str]] = None,\n-          default: Union[T, _MISSING_TYPE] = MISSING,\n-          default_factory: Union[Callable[[], T], _MISSING_TYPE] = MISSING,\n-          init: bool = True,\n-          repr: bool = True,\n-          hash: bool = None,\n-          compare: bool = True,\n-          metadata: Dict[str, Any] = None,\n-          **custom_argparse_args) -> T:\n-    \"\"\"Calls the `dataclasses.field` function, and leftover arguments are fed\n-    directly to the `ArgumentParser.add_argument(*option_strings, **kwargs)`\n-    method.\n-\n-    Parameters\n-    ----------\n-    alias : List[str], optional\n-        Additional option_strings to pass to the `add_argument` method, by\n-        default None\n-    default : Union[T, _MISSING_TYPE], optional\n-        The default field value (same as in `dataclasses.field`), by default MISSING\n-    default_factory : Union[Callable[[], T], _MISSING_TYPE], optional\n-        (same as in `dataclasses.field`), by default None\n-    init : bool, optional\n-        (same as in `dataclasses.field`), by default True\n-    repr : bool, optional\n-        (same as in `dataclasses.field`), by default True\n-    hash : bool, optional\n-        (same as in `dataclasses.field`), by default None\n-    compare : bool, optional\n-        (same as in `dataclasses.field`), by default True\n-    metadata : Dict[str, Any], optional\n-        (same as in `dataclasses.field`), by default None\n-\n-    Returns\n-    -------\n-    T\n-        The value returned by the `dataclasses.field` function.\n-    \"\"\"\n-    _metadata: Dict[str, Any] = metadata if metadata is not None else {}\n-    if alias:\n-        _metadata.update({\n-            \"alias\": alias if isinstance(alias, list) else [alias]\n-        })\n-    if custom_argparse_args:\n-        _metadata.update({\"custom_args\": custom_argparse_args})\n-\n-    if default is not MISSING:\n-        return dataclasses.field(  # type: ignore\n-            default=default,\n-            init=init,\n-            repr=repr,\n-            hash=hash,\n-            compare=compare,\n-            metadata=_metadata\n-        )\n-    else:\n-        return dataclasses.field(  # type: ignore\n-            default_factory=default_factory,\n-            init=init,\n-            repr=repr,\n-            hash=hash,\n-            compare=compare,\n-            metadata=_metadata\n-        )\n-\n-\n-def choice(*choices: T, default: T = None, **kwargs) -> T:\n-    \"\"\" Makes a regular attribute, whose value, when parsed from the \n-    command-line, can only be one contained in `choices`, with a default value \n-    of `default`.\n-\n-    Returns a regular `dataclasses.field()`, but with metadata which indicates  \n-    the allowed values.\n-\n-    Args:\n-        default (T, optional): The default value of the field. Defaults to None,\n-        in which case the command-line argument is required.\n-\n-    Raises:\n-        ValueError: If the default value isn't part of the given choices.\n-\n-    Returns:\n-        T: the result of the usual `dataclasses.field()` function (a dataclass field/attribute).\n-    \"\"\"\n-    if default is not None and default not in choices:\n-        raise ValueError(\n-            f\"Default value of {default} is not a valid option! (options: {choices})\")\n-    return field(default=default, choices=choices, **kwargs)  # type: ignore\n-\n-\n-@dataclass\n-class Bob:\n-    a: str = choice(\"1\", \"2\", \"3\", default=\"1\")\n-\n-\n-def list_field(*default_items: SimpleValueType, **kwargs) -> List[T]:\n-    \"\"\"shorthand function for setting a `list` attribute on a dataclass,\n-    so that every instance of the dataclass doesn't share the same list.\n-\n-    Accepts any of the arguments of the `dataclasses.field` function.\n-\n-    Returns:\n-        List[T]: a `dataclasses.field` of type `list`, containing the `default_items`. \n-    \"\"\"\n-    return MutableField(list, default_items, **kwargs)\n-\n-\n-def dict_field(default_items: Union[Dict[K, V], Iterable[Tuple[K, V]]] = None, **kwargs) -> Dict[K, V]:\n-    \"\"\"shorthand function for setting a `dict` attribute on a dataclass,\n-    so that every instance of the dataclass doesn't share the same `dict`.\n-\n-    Accepts any of the arguments of the `dataclasses.field` function.\n-\n-    Returns:\n-        Dict[K, V]: a `dataclasses.Field` of type `Dict[K, V]`, containing the `default_items`. \n-    \"\"\"\n-    if default_items is None:\n-        default_items = []\n-    elif isinstance(default_items, dict):\n-        default_items = default_items.items()\n-    return MutableField(dict, default_items, **kwargs)\n-\n-\n-def set_field(*default_items: T, **kwargs) -> Set[T]:\n-    return MutableField(set, default_items, **kwargs)\n-\n-\n-def MutableField(_type: Type[T], *args, init: bool = True, repr: bool = True, hash: bool = None, compare: bool = True, metadata: Dict[str, Any] = None, **kwargs) -> T:\n-    return field(default_factory=partial(_type, *args, **kwargs), init=init, repr=repr, hash=hash, compare=compare, metadata=metadata)\n-\n-\n-def subparsers(subcommands: Dict[str, Type], default=None) -> Any:\n-    if default is not None and default not in subcommands:\n-        raise ValueError(\n-            f\"Default value of {default} is not a valid subparser! (subcommand: {subcommands})\")\n-    return field(default=default, metadata={\n-        \"subparsers\": subcommands,\n-        \"default\": default,\n-    })\n \n",
        "source_code_with_indent": "\ndef foo(a: int = 123, b: str = None) -> float:\n    <IND>\"\"\"[summary]\n\n    [extended_summary]\n\n    Parameters\n    ----------\n    - a : int, optional\n        [description], by default 123\n    - b : str, optional\n        [description], by default None\n\n    Returns\n    -------\n    float\n        [description]\n    \"\"\"\n\n\n<DED>def field(*,\n          alias: Union[str, List[str]] = None,\n          default: Union[T, _MISSING_TYPE] = MISSING,\n          default_factory: Union[Callable[[], T], _MISSING_TYPE] = MISSING,\n          init: bool = True,\n          repr: bool = True,\n          hash: bool = None,\n          compare: bool = True,\n          metadata: Dict[str, Any] = None,\n          **custom_argparse_args) -> T:\n    <IND>\"\"\"Calls the `dataclasses.field` function, and leftover arguments are fed\n    directly to the `ArgumentParser.add_argument(*option_strings, **kwargs)`\n    method.\n\n    Parameters\n    ----------\n    alias : List[str], optional\n        Additional option_strings to pass to the `add_argument` method, by\n        default None\n    default : Union[T, _MISSING_TYPE], optional\n        The default field value (same as in `dataclasses.field`), by default MISSING\n    default_factory : Union[Callable[[], T], _MISSING_TYPE], optional\n        (same as in `dataclasses.field`), by default None\n    init : bool, optional\n        (same as in `dataclasses.field`), by default True\n    repr : bool, optional\n        (same as in `dataclasses.field`), by default True\n    hash : bool, optional\n        (same as in `dataclasses.field`), by default None\n    compare : bool, optional\n        (same as in `dataclasses.field`), by default True\n    metadata : Dict[str, Any], optional\n        (same as in `dataclasses.field`), by default None\n\n    Returns\n    -------\n    T\n        The value returned by the `dataclasses.field` function.\n    \"\"\"\n    _metadata: Dict[str, Any] = metadata if metadata is not None else {}\n    if alias:\n        <IND>_metadata.update({\n            \"alias\": alias if isinstance(alias, list) else [alias]\n        })\n    <DED>if custom_argparse_args:\n        <IND>_metadata.update({\"custom_args\": custom_argparse_args})\n\n    <DED>if default is not MISSING:\n        <IND>return dataclasses.field(  # type: ignore\n            default=default,\n            init=init,\n            repr=repr,\n            hash=hash,\n            compare=compare,\n            metadata=_metadata\n        )\n    <DED>else:\n        <IND>return dataclasses.field(  # type: ignore\n            default_factory=default_factory,\n            init=init,\n            repr=repr,\n            hash=hash,\n            compare=compare,\n            metadata=_metadata\n        )\n\n\n<DED><DED>def choice(*choices: T, default: T = None, **kwargs) -> T:\n    <IND>\"\"\" Makes a regular attribute, whose value, when parsed from the \n    command-line, can only be one contained in `choices`, with a default value \n    of `default`.\n\n    Returns a regular `dataclasses.field()`, but with metadata which indicates  \n    the allowed values.\n\n    Args:\n        default (T, optional): The default value of the field. Defaults to None,\n        in which case the command-line argument is required.\n\n    Raises:\n        ValueError: If the default value isn't part of the given choices.\n\n    Returns:\n        T: the result of the usual `dataclasses.field()` function (a dataclass field/attribute).\n    \"\"\"\n    if default is not None and default not in choices:\n        <IND>raise ValueError(\n            f\"Default value of {default} is not a valid option! (options: {choices})\")\n    <DED>return field(default=default, choices=choices, **kwargs)  # type: ignore\n\n\n<DED>@dataclass\nclass Bob:\n    <IND>a: str = choice(\"1\", \"2\", \"3\", default=\"1\")\n\n\n<DED>def list_field(*default_items: SimpleValueType, **kwargs) -> List[T]:\n    <IND>\"\"\"shorthand function for setting a `list` attribute on a dataclass,\n    so that every instance of the dataclass doesn't share the same list.\n\n    Accepts any of the arguments of the `dataclasses.field` function.\n\n    Returns:\n        List[T]: a `dataclasses.field` of type `list`, containing the `default_items`. \n    \"\"\"\n    return MutableField(list, default_items, **kwargs)\n\n\n<DED>def dict_field(default_items: Union[Dict[K, V], Iterable[Tuple[K, V]]] = None, **kwargs) -> Dict[K, V]:\n    <IND>\"\"\"shorthand function for setting a `dict` attribute on a dataclass,\n    so that every instance of the dataclass doesn't share the same `dict`.\n\n    Accepts any of the arguments of the `dataclasses.field` function.\n\n    Returns:\n        Dict[K, V]: a `dataclasses.Field` of type `Dict[K, V]`, containing the `default_items`. \n    \"\"\"\n    if default_items is None:\n        <IND>default_items = []\n    <DED>elif isinstance(default_items, dict):\n        <IND>default_items = default_items.items()\n    <DED>return MutableField(dict, default_items, **kwargs)\n\n\n<DED>def set_field(*default_items: T, **kwargs) -> Set[T]:\n    <IND>return MutableField(set, default_items, **kwargs)\n\n\n<DED>def MutableField(_type: Type[T], *args, init: bool = True, repr: bool = True, hash: bool = None, compare: bool = True, metadata: Dict[str, Any] = None, **kwargs) -> T:\n    <IND>return field(default_factory=partial(_type, *args, **kwargs), init=init, repr=repr, hash=hash, compare=compare, metadata=metadata)\n\n\n<DED>def subparsers(subcommands: Dict[str, Type], default=None) -> Any:\n    <IND>if default is not None and default not in subcommands:\n        <IND>raise ValueError(\n            f\"Default value of {default} is not a valid subparser! (subcommand: {subcommands})\")\n    <DED>return field(default=default, metadata={\n        \"subparsers\": subcommands,\n        \"default\": default,\n    })\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "lebrice/SimpleParsing",
    "commit": "f6063a6a6325f5bf711db90492203b0a07a39a0d",
    "filename": "simple_parsing/utils.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/lebrice-SimpleParsing/simple_parsing/utils.py",
    "file_hunks_size": 7,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": true,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "simple_parsing/utils.py:59:10 Incompatible variable type [9]: hash is declared to have type `bool` but is used as type `None`.",
    "message": " hash is declared to have type `bool` but is used as type `None`.",
    "rule_id": "Incompatible variable type [9]",
    "warning_line_no": 59,
    "warning_line": "          hash: bool = None,",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": true,
        "has_suppression": false,
        "source_code": "\ndef foo(a: int = 123, b: str = None) -> float:\n    \"\"\"[summary]\n\n    [extended_summary]\n\n    Parameters\n    ----------\n    - a : int, optional\n        [description], by default 123\n    - b : str, optional\n        [description], by default None\n\n    Returns\n    -------\n    float\n        [description]\n    \"\"\"\n\n\ndef field(*,\n          alias: Union[str, List[str]] = None,\n          default: Union[T, _MISSING_TYPE] = MISSING,\n          default_factory: Union[Callable[[], T], _MISSING_TYPE] = MISSING,\n          init: bool = True,\n          repr: bool = True,\n          hash: bool = None,\n          compare: bool = True,\n          metadata: Dict[str, Any] = None,\n          **custom_argparse_args) -> T:\n    \"\"\"Calls the `dataclasses.field` function, and leftover arguments are fed\n    directly to the `ArgumentParser.add_argument(*option_strings, **kwargs)`\n    method.\n\n    Parameters\n    ----------\n    alias : List[str], optional\n        Additional option_strings to pass to the `add_argument` method, by\n        default None\n    default : Union[T, _MISSING_TYPE], optional\n        The default field value (same as in `dataclasses.field`), by default MISSING\n    default_factory : Union[Callable[[], T], _MISSING_TYPE], optional\n        (same as in `dataclasses.field`), by default None\n    init : bool, optional\n        (same as in `dataclasses.field`), by default True\n    repr : bool, optional\n        (same as in `dataclasses.field`), by default True\n    hash : bool, optional\n        (same as in `dataclasses.field`), by default None\n    compare : bool, optional\n        (same as in `dataclasses.field`), by default True\n    metadata : Dict[str, Any], optional\n        (same as in `dataclasses.field`), by default None\n\n    Returns\n    -------\n    T\n        The value returned by the `dataclasses.field` function.\n    \"\"\"\n    _metadata: Dict[str, Any] = metadata if metadata is not None else {}\n    if alias:\n        _metadata.update({\n            \"alias\": alias if isinstance(alias, list) else [alias]\n        })\n    if custom_argparse_args:\n        _metadata.update({\"custom_args\": custom_argparse_args})\n\n    if default is not MISSING:\n        return dataclasses.field(  # type: ignore\n            default=default,\n            init=init,\n            repr=repr,\n            hash=hash,\n            compare=compare,\n            metadata=_metadata\n        )\n    else:\n        return dataclasses.field(  # type: ignore\n            default_factory=default_factory,\n            init=init,\n            repr=repr,\n            hash=hash,\n            compare=compare,\n            metadata=_metadata\n        )\n\n\ndef choice(*choices: T, default: T = None, **kwargs) -> T:\n    \"\"\" Makes a regular attribute, whose value, when parsed from the \n    command-line, can only be one contained in `choices`, with a default value \n    of `default`.\n\n    Returns a regular `dataclasses.field()`, but with metadata which indicates  \n    the allowed values.\n\n    Args:\n        default (T, optional): The default value of the field. Defaults to None,\n        in which case the command-line argument is required.\n\n    Raises:\n        ValueError: If the default value isn't part of the given choices.\n\n    Returns:\n        T: the result of the usual `dataclasses.field()` function (a dataclass field/attribute).\n    \"\"\"\n    if default is not None and default not in choices:\n        raise ValueError(\n            f\"Default value of {default} is not a valid option! (options: {choices})\")\n    return field(default=default, choices=choices, **kwargs)  # type: ignore\n\n\n@dataclass\nclass Bob:\n    a: str = choice(\"1\", \"2\", \"3\", default=\"1\")\n\n\ndef list_field(*default_items: SimpleValueType, **kwargs) -> List[T]:\n    \"\"\"shorthand function for setting a `list` attribute on a dataclass,\n    so that every instance of the dataclass doesn't share the same list.\n\n    Accepts any of the arguments of the `dataclasses.field` function.\n\n    Returns:\n        List[T]: a `dataclasses.field` of type `list`, containing the `default_items`. \n    \"\"\"\n    return MutableField(list, default_items, **kwargs)\n\n\ndef dict_field(default_items: Union[Dict[K, V], Iterable[Tuple[K, V]]] = None, **kwargs) -> Dict[K, V]:\n    \"\"\"shorthand function for setting a `dict` attribute on a dataclass,\n    so that every instance of the dataclass doesn't share the same `dict`.\n\n    Accepts any of the arguments of the `dataclasses.field` function.\n\n    Returns:\n        Dict[K, V]: a `dataclasses.Field` of type `Dict[K, V]`, containing the `default_items`. \n    \"\"\"\n    if default_items is None:\n        default_items = []\n    elif isinstance(default_items, dict):\n        default_items = default_items.items()\n    return MutableField(dict, default_items, **kwargs)\n\n\ndef set_field(*default_items: T, **kwargs) -> Set[T]:\n    return MutableField(set, default_items, **kwargs)\n\n\ndef MutableField(_type: Type[T], *args, init: bool = True, repr: bool = True, hash: bool = None, compare: bool = True, metadata: Dict[str, Any] = None, **kwargs) -> T:\n    return field(default_factory=partial(_type, *args, **kwargs), init=init, repr=repr, hash=hash, compare=compare, metadata=metadata)\n\n\ndef subparsers(subcommands: Dict[str, Type], default=None) -> Any:\n    if default is not None and default not in subcommands:\n        raise ValueError(\n            f\"Default value of {default} is not a valid subparser! (subcommand: {subcommands})\")\n    return field(default=default, metadata={\n        \"subparsers\": subcommands,\n        \"default\": default,\n    })\n\n",
        "source_code_len": 5501,
        "target_code": "\n\n",
        "target_code_len": 2,
        "diff_format": "@@ -33,161 +36,2 @@\n \n-def foo(a: int = 123, b: str = None) -> float:\n-    \"\"\"[summary]\n-\n-    [extended_summary]\n-\n-    Parameters\n-    ----------\n-    - a : int, optional\n-        [description], by default 123\n-    - b : str, optional\n-        [description], by default None\n-\n-    Returns\n-    -------\n-    float\n-        [description]\n-    \"\"\"\n-\n-\n-def field(*,\n-          alias: Union[str, List[str]] = None,\n-          default: Union[T, _MISSING_TYPE] = MISSING,\n-          default_factory: Union[Callable[[], T], _MISSING_TYPE] = MISSING,\n-          init: bool = True,\n-          repr: bool = True,\n-          hash: bool = None,\n-          compare: bool = True,\n-          metadata: Dict[str, Any] = None,\n-          **custom_argparse_args) -> T:\n-    \"\"\"Calls the `dataclasses.field` function, and leftover arguments are fed\n-    directly to the `ArgumentParser.add_argument(*option_strings, **kwargs)`\n-    method.\n-\n-    Parameters\n-    ----------\n-    alias : List[str], optional\n-        Additional option_strings to pass to the `add_argument` method, by\n-        default None\n-    default : Union[T, _MISSING_TYPE], optional\n-        The default field value (same as in `dataclasses.field`), by default MISSING\n-    default_factory : Union[Callable[[], T], _MISSING_TYPE], optional\n-        (same as in `dataclasses.field`), by default None\n-    init : bool, optional\n-        (same as in `dataclasses.field`), by default True\n-    repr : bool, optional\n-        (same as in `dataclasses.field`), by default True\n-    hash : bool, optional\n-        (same as in `dataclasses.field`), by default None\n-    compare : bool, optional\n-        (same as in `dataclasses.field`), by default True\n-    metadata : Dict[str, Any], optional\n-        (same as in `dataclasses.field`), by default None\n-\n-    Returns\n-    -------\n-    T\n-        The value returned by the `dataclasses.field` function.\n-    \"\"\"\n-    _metadata: Dict[str, Any] = metadata if metadata is not None else {}\n-    if alias:\n-        _metadata.update({\n-            \"alias\": alias if isinstance(alias, list) else [alias]\n-        })\n-    if custom_argparse_args:\n-        _metadata.update({\"custom_args\": custom_argparse_args})\n-\n-    if default is not MISSING:\n-        return dataclasses.field(  # type: ignore\n-            default=default,\n-            init=init,\n-            repr=repr,\n-            hash=hash,\n-            compare=compare,\n-            metadata=_metadata\n-        )\n-    else:\n-        return dataclasses.field(  # type: ignore\n-            default_factory=default_factory,\n-            init=init,\n-            repr=repr,\n-            hash=hash,\n-            compare=compare,\n-            metadata=_metadata\n-        )\n-\n-\n-def choice(*choices: T, default: T = None, **kwargs) -> T:\n-    \"\"\" Makes a regular attribute, whose value, when parsed from the \n-    command-line, can only be one contained in `choices`, with a default value \n-    of `default`.\n-\n-    Returns a regular `dataclasses.field()`, but with metadata which indicates  \n-    the allowed values.\n-\n-    Args:\n-        default (T, optional): The default value of the field. Defaults to None,\n-        in which case the command-line argument is required.\n-\n-    Raises:\n-        ValueError: If the default value isn't part of the given choices.\n-\n-    Returns:\n-        T: the result of the usual `dataclasses.field()` function (a dataclass field/attribute).\n-    \"\"\"\n-    if default is not None and default not in choices:\n-        raise ValueError(\n-            f\"Default value of {default} is not a valid option! (options: {choices})\")\n-    return field(default=default, choices=choices, **kwargs)  # type: ignore\n-\n-\n-@dataclass\n-class Bob:\n-    a: str = choice(\"1\", \"2\", \"3\", default=\"1\")\n-\n-\n-def list_field(*default_items: SimpleValueType, **kwargs) -> List[T]:\n-    \"\"\"shorthand function for setting a `list` attribute on a dataclass,\n-    so that every instance of the dataclass doesn't share the same list.\n-\n-    Accepts any of the arguments of the `dataclasses.field` function.\n-\n-    Returns:\n-        List[T]: a `dataclasses.field` of type `list`, containing the `default_items`. \n-    \"\"\"\n-    return MutableField(list, default_items, **kwargs)\n-\n-\n-def dict_field(default_items: Union[Dict[K, V], Iterable[Tuple[K, V]]] = None, **kwargs) -> Dict[K, V]:\n-    \"\"\"shorthand function for setting a `dict` attribute on a dataclass,\n-    so that every instance of the dataclass doesn't share the same `dict`.\n-\n-    Accepts any of the arguments of the `dataclasses.field` function.\n-\n-    Returns:\n-        Dict[K, V]: a `dataclasses.Field` of type `Dict[K, V]`, containing the `default_items`. \n-    \"\"\"\n-    if default_items is None:\n-        default_items = []\n-    elif isinstance(default_items, dict):\n-        default_items = default_items.items()\n-    return MutableField(dict, default_items, **kwargs)\n-\n-\n-def set_field(*default_items: T, **kwargs) -> Set[T]:\n-    return MutableField(set, default_items, **kwargs)\n-\n-\n-def MutableField(_type: Type[T], *args, init: bool = True, repr: bool = True, hash: bool = None, compare: bool = True, metadata: Dict[str, Any] = None, **kwargs) -> T:\n-    return field(default_factory=partial(_type, *args, **kwargs), init=init, repr=repr, hash=hash, compare=compare, metadata=metadata)\n-\n-\n-def subparsers(subcommands: Dict[str, Type], default=None) -> Any:\n-    if default is not None and default not in subcommands:\n-        raise ValueError(\n-            f\"Default value of {default} is not a valid subparser! (subcommand: {subcommands})\")\n-    return field(default=default, metadata={\n-        \"subparsers\": subcommands,\n-        \"default\": default,\n-    })\n \n",
        "source_code_with_indent": "\ndef foo(a: int = 123, b: str = None) -> float:\n    <IND>\"\"\"[summary]\n\n    [extended_summary]\n\n    Parameters\n    ----------\n    - a : int, optional\n        [description], by default 123\n    - b : str, optional\n        [description], by default None\n\n    Returns\n    -------\n    float\n        [description]\n    \"\"\"\n\n\n<DED>def field(*,\n          alias: Union[str, List[str]] = None,\n          default: Union[T, _MISSING_TYPE] = MISSING,\n          default_factory: Union[Callable[[], T], _MISSING_TYPE] = MISSING,\n          init: bool = True,\n          repr: bool = True,\n          hash: bool = None,\n          compare: bool = True,\n          metadata: Dict[str, Any] = None,\n          **custom_argparse_args) -> T:\n    <IND>\"\"\"Calls the `dataclasses.field` function, and leftover arguments are fed\n    directly to the `ArgumentParser.add_argument(*option_strings, **kwargs)`\n    method.\n\n    Parameters\n    ----------\n    alias : List[str], optional\n        Additional option_strings to pass to the `add_argument` method, by\n        default None\n    default : Union[T, _MISSING_TYPE], optional\n        The default field value (same as in `dataclasses.field`), by default MISSING\n    default_factory : Union[Callable[[], T], _MISSING_TYPE], optional\n        (same as in `dataclasses.field`), by default None\n    init : bool, optional\n        (same as in `dataclasses.field`), by default True\n    repr : bool, optional\n        (same as in `dataclasses.field`), by default True\n    hash : bool, optional\n        (same as in `dataclasses.field`), by default None\n    compare : bool, optional\n        (same as in `dataclasses.field`), by default True\n    metadata : Dict[str, Any], optional\n        (same as in `dataclasses.field`), by default None\n\n    Returns\n    -------\n    T\n        The value returned by the `dataclasses.field` function.\n    \"\"\"\n    _metadata: Dict[str, Any] = metadata if metadata is not None else {}\n    if alias:\n        <IND>_metadata.update({\n            \"alias\": alias if isinstance(alias, list) else [alias]\n        })\n    <DED>if custom_argparse_args:\n        <IND>_metadata.update({\"custom_args\": custom_argparse_args})\n\n    <DED>if default is not MISSING:\n        <IND>return dataclasses.field(  # type: ignore\n            default=default,\n            init=init,\n            repr=repr,\n            hash=hash,\n            compare=compare,\n            metadata=_metadata\n        )\n    <DED>else:\n        <IND>return dataclasses.field(  # type: ignore\n            default_factory=default_factory,\n            init=init,\n            repr=repr,\n            hash=hash,\n            compare=compare,\n            metadata=_metadata\n        )\n\n\n<DED><DED>def choice(*choices: T, default: T = None, **kwargs) -> T:\n    <IND>\"\"\" Makes a regular attribute, whose value, when parsed from the \n    command-line, can only be one contained in `choices`, with a default value \n    of `default`.\n\n    Returns a regular `dataclasses.field()`, but with metadata which indicates  \n    the allowed values.\n\n    Args:\n        default (T, optional): The default value of the field. Defaults to None,\n        in which case the command-line argument is required.\n\n    Raises:\n        ValueError: If the default value isn't part of the given choices.\n\n    Returns:\n        T: the result of the usual `dataclasses.field()` function (a dataclass field/attribute).\n    \"\"\"\n    if default is not None and default not in choices:\n        <IND>raise ValueError(\n            f\"Default value of {default} is not a valid option! (options: {choices})\")\n    <DED>return field(default=default, choices=choices, **kwargs)  # type: ignore\n\n\n<DED>@dataclass\nclass Bob:\n    <IND>a: str = choice(\"1\", \"2\", \"3\", default=\"1\")\n\n\n<DED>def list_field(*default_items: SimpleValueType, **kwargs) -> List[T]:\n    <IND>\"\"\"shorthand function for setting a `list` attribute on a dataclass,\n    so that every instance of the dataclass doesn't share the same list.\n\n    Accepts any of the arguments of the `dataclasses.field` function.\n\n    Returns:\n        List[T]: a `dataclasses.field` of type `list`, containing the `default_items`. \n    \"\"\"\n    return MutableField(list, default_items, **kwargs)\n\n\n<DED>def dict_field(default_items: Union[Dict[K, V], Iterable[Tuple[K, V]]] = None, **kwargs) -> Dict[K, V]:\n    <IND>\"\"\"shorthand function for setting a `dict` attribute on a dataclass,\n    so that every instance of the dataclass doesn't share the same `dict`.\n\n    Accepts any of the arguments of the `dataclasses.field` function.\n\n    Returns:\n        Dict[K, V]: a `dataclasses.Field` of type `Dict[K, V]`, containing the `default_items`. \n    \"\"\"\n    if default_items is None:\n        <IND>default_items = []\n    <DED>elif isinstance(default_items, dict):\n        <IND>default_items = default_items.items()\n    <DED>return MutableField(dict, default_items, **kwargs)\n\n\n<DED>def set_field(*default_items: T, **kwargs) -> Set[T]:\n    <IND>return MutableField(set, default_items, **kwargs)\n\n\n<DED>def MutableField(_type: Type[T], *args, init: bool = True, repr: bool = True, hash: bool = None, compare: bool = True, metadata: Dict[str, Any] = None, **kwargs) -> T:\n    <IND>return field(default_factory=partial(_type, *args, **kwargs), init=init, repr=repr, hash=hash, compare=compare, metadata=metadata)\n\n\n<DED>def subparsers(subcommands: Dict[str, Type], default=None) -> Any:\n    <IND>if default is not None and default not in subcommands:\n        <IND>raise ValueError(\n            f\"Default value of {default} is not a valid subparser! (subcommand: {subcommands})\")\n    <DED>return field(default=default, metadata={\n        \"subparsers\": subcommands,\n        \"default\": default,\n    })\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "lebrice/SimpleParsing",
    "commit": "f6063a6a6325f5bf711db90492203b0a07a39a0d",
    "filename": "simple_parsing/utils.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/lebrice-SimpleParsing/simple_parsing/utils.py",
    "file_hunks_size": 7,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": true,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "simple_parsing/utils.py:61:10 Incompatible variable type [9]: metadata is declared to have type `typing.Dict[str, typing.Any]` but is used as type `None`.",
    "message": " metadata is declared to have type `typing.Dict[str, typing.Any]` but is used as type `None`.",
    "rule_id": "Incompatible variable type [9]",
    "warning_line_no": 61,
    "warning_line": "          metadata: Dict[str, Any] = None,",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": true,
        "has_suppression": false,
        "source_code": "\ndef foo(a: int = 123, b: str = None) -> float:\n    \"\"\"[summary]\n\n    [extended_summary]\n\n    Parameters\n    ----------\n    - a : int, optional\n        [description], by default 123\n    - b : str, optional\n        [description], by default None\n\n    Returns\n    -------\n    float\n        [description]\n    \"\"\"\n\n\ndef field(*,\n          alias: Union[str, List[str]] = None,\n          default: Union[T, _MISSING_TYPE] = MISSING,\n          default_factory: Union[Callable[[], T], _MISSING_TYPE] = MISSING,\n          init: bool = True,\n          repr: bool = True,\n          hash: bool = None,\n          compare: bool = True,\n          metadata: Dict[str, Any] = None,\n          **custom_argparse_args) -> T:\n    \"\"\"Calls the `dataclasses.field` function, and leftover arguments are fed\n    directly to the `ArgumentParser.add_argument(*option_strings, **kwargs)`\n    method.\n\n    Parameters\n    ----------\n    alias : List[str], optional\n        Additional option_strings to pass to the `add_argument` method, by\n        default None\n    default : Union[T, _MISSING_TYPE], optional\n        The default field value (same as in `dataclasses.field`), by default MISSING\n    default_factory : Union[Callable[[], T], _MISSING_TYPE], optional\n        (same as in `dataclasses.field`), by default None\n    init : bool, optional\n        (same as in `dataclasses.field`), by default True\n    repr : bool, optional\n        (same as in `dataclasses.field`), by default True\n    hash : bool, optional\n        (same as in `dataclasses.field`), by default None\n    compare : bool, optional\n        (same as in `dataclasses.field`), by default True\n    metadata : Dict[str, Any], optional\n        (same as in `dataclasses.field`), by default None\n\n    Returns\n    -------\n    T\n        The value returned by the `dataclasses.field` function.\n    \"\"\"\n    _metadata: Dict[str, Any] = metadata if metadata is not None else {}\n    if alias:\n        _metadata.update({\n            \"alias\": alias if isinstance(alias, list) else [alias]\n        })\n    if custom_argparse_args:\n        _metadata.update({\"custom_args\": custom_argparse_args})\n\n    if default is not MISSING:\n        return dataclasses.field(  # type: ignore\n            default=default,\n            init=init,\n            repr=repr,\n            hash=hash,\n            compare=compare,\n            metadata=_metadata\n        )\n    else:\n        return dataclasses.field(  # type: ignore\n            default_factory=default_factory,\n            init=init,\n            repr=repr,\n            hash=hash,\n            compare=compare,\n            metadata=_metadata\n        )\n\n\ndef choice(*choices: T, default: T = None, **kwargs) -> T:\n    \"\"\" Makes a regular attribute, whose value, when parsed from the \n    command-line, can only be one contained in `choices`, with a default value \n    of `default`.\n\n    Returns a regular `dataclasses.field()`, but with metadata which indicates  \n    the allowed values.\n\n    Args:\n        default (T, optional): The default value of the field. Defaults to None,\n        in which case the command-line argument is required.\n\n    Raises:\n        ValueError: If the default value isn't part of the given choices.\n\n    Returns:\n        T: the result of the usual `dataclasses.field()` function (a dataclass field/attribute).\n    \"\"\"\n    if default is not None and default not in choices:\n        raise ValueError(\n            f\"Default value of {default} is not a valid option! (options: {choices})\")\n    return field(default=default, choices=choices, **kwargs)  # type: ignore\n\n\n@dataclass\nclass Bob:\n    a: str = choice(\"1\", \"2\", \"3\", default=\"1\")\n\n\ndef list_field(*default_items: SimpleValueType, **kwargs) -> List[T]:\n    \"\"\"shorthand function for setting a `list` attribute on a dataclass,\n    so that every instance of the dataclass doesn't share the same list.\n\n    Accepts any of the arguments of the `dataclasses.field` function.\n\n    Returns:\n        List[T]: a `dataclasses.field` of type `list`, containing the `default_items`. \n    \"\"\"\n    return MutableField(list, default_items, **kwargs)\n\n\ndef dict_field(default_items: Union[Dict[K, V], Iterable[Tuple[K, V]]] = None, **kwargs) -> Dict[K, V]:\n    \"\"\"shorthand function for setting a `dict` attribute on a dataclass,\n    so that every instance of the dataclass doesn't share the same `dict`.\n\n    Accepts any of the arguments of the `dataclasses.field` function.\n\n    Returns:\n        Dict[K, V]: a `dataclasses.Field` of type `Dict[K, V]`, containing the `default_items`. \n    \"\"\"\n    if default_items is None:\n        default_items = []\n    elif isinstance(default_items, dict):\n        default_items = default_items.items()\n    return MutableField(dict, default_items, **kwargs)\n\n\ndef set_field(*default_items: T, **kwargs) -> Set[T]:\n    return MutableField(set, default_items, **kwargs)\n\n\ndef MutableField(_type: Type[T], *args, init: bool = True, repr: bool = True, hash: bool = None, compare: bool = True, metadata: Dict[str, Any] = None, **kwargs) -> T:\n    return field(default_factory=partial(_type, *args, **kwargs), init=init, repr=repr, hash=hash, compare=compare, metadata=metadata)\n\n\ndef subparsers(subcommands: Dict[str, Type], default=None) -> Any:\n    if default is not None and default not in subcommands:\n        raise ValueError(\n            f\"Default value of {default} is not a valid subparser! (subcommand: {subcommands})\")\n    return field(default=default, metadata={\n        \"subparsers\": subcommands,\n        \"default\": default,\n    })\n\n",
        "source_code_len": 5501,
        "target_code": "\n\n",
        "target_code_len": 2,
        "diff_format": "@@ -33,161 +36,2 @@\n \n-def foo(a: int = 123, b: str = None) -> float:\n-    \"\"\"[summary]\n-\n-    [extended_summary]\n-\n-    Parameters\n-    ----------\n-    - a : int, optional\n-        [description], by default 123\n-    - b : str, optional\n-        [description], by default None\n-\n-    Returns\n-    -------\n-    float\n-        [description]\n-    \"\"\"\n-\n-\n-def field(*,\n-          alias: Union[str, List[str]] = None,\n-          default: Union[T, _MISSING_TYPE] = MISSING,\n-          default_factory: Union[Callable[[], T], _MISSING_TYPE] = MISSING,\n-          init: bool = True,\n-          repr: bool = True,\n-          hash: bool = None,\n-          compare: bool = True,\n-          metadata: Dict[str, Any] = None,\n-          **custom_argparse_args) -> T:\n-    \"\"\"Calls the `dataclasses.field` function, and leftover arguments are fed\n-    directly to the `ArgumentParser.add_argument(*option_strings, **kwargs)`\n-    method.\n-\n-    Parameters\n-    ----------\n-    alias : List[str], optional\n-        Additional option_strings to pass to the `add_argument` method, by\n-        default None\n-    default : Union[T, _MISSING_TYPE], optional\n-        The default field value (same as in `dataclasses.field`), by default MISSING\n-    default_factory : Union[Callable[[], T], _MISSING_TYPE], optional\n-        (same as in `dataclasses.field`), by default None\n-    init : bool, optional\n-        (same as in `dataclasses.field`), by default True\n-    repr : bool, optional\n-        (same as in `dataclasses.field`), by default True\n-    hash : bool, optional\n-        (same as in `dataclasses.field`), by default None\n-    compare : bool, optional\n-        (same as in `dataclasses.field`), by default True\n-    metadata : Dict[str, Any], optional\n-        (same as in `dataclasses.field`), by default None\n-\n-    Returns\n-    -------\n-    T\n-        The value returned by the `dataclasses.field` function.\n-    \"\"\"\n-    _metadata: Dict[str, Any] = metadata if metadata is not None else {}\n-    if alias:\n-        _metadata.update({\n-            \"alias\": alias if isinstance(alias, list) else [alias]\n-        })\n-    if custom_argparse_args:\n-        _metadata.update({\"custom_args\": custom_argparse_args})\n-\n-    if default is not MISSING:\n-        return dataclasses.field(  # type: ignore\n-            default=default,\n-            init=init,\n-            repr=repr,\n-            hash=hash,\n-            compare=compare,\n-            metadata=_metadata\n-        )\n-    else:\n-        return dataclasses.field(  # type: ignore\n-            default_factory=default_factory,\n-            init=init,\n-            repr=repr,\n-            hash=hash,\n-            compare=compare,\n-            metadata=_metadata\n-        )\n-\n-\n-def choice(*choices: T, default: T = None, **kwargs) -> T:\n-    \"\"\" Makes a regular attribute, whose value, when parsed from the \n-    command-line, can only be one contained in `choices`, with a default value \n-    of `default`.\n-\n-    Returns a regular `dataclasses.field()`, but with metadata which indicates  \n-    the allowed values.\n-\n-    Args:\n-        default (T, optional): The default value of the field. Defaults to None,\n-        in which case the command-line argument is required.\n-\n-    Raises:\n-        ValueError: If the default value isn't part of the given choices.\n-\n-    Returns:\n-        T: the result of the usual `dataclasses.field()` function (a dataclass field/attribute).\n-    \"\"\"\n-    if default is not None and default not in choices:\n-        raise ValueError(\n-            f\"Default value of {default} is not a valid option! (options: {choices})\")\n-    return field(default=default, choices=choices, **kwargs)  # type: ignore\n-\n-\n-@dataclass\n-class Bob:\n-    a: str = choice(\"1\", \"2\", \"3\", default=\"1\")\n-\n-\n-def list_field(*default_items: SimpleValueType, **kwargs) -> List[T]:\n-    \"\"\"shorthand function for setting a `list` attribute on a dataclass,\n-    so that every instance of the dataclass doesn't share the same list.\n-\n-    Accepts any of the arguments of the `dataclasses.field` function.\n-\n-    Returns:\n-        List[T]: a `dataclasses.field` of type `list`, containing the `default_items`. \n-    \"\"\"\n-    return MutableField(list, default_items, **kwargs)\n-\n-\n-def dict_field(default_items: Union[Dict[K, V], Iterable[Tuple[K, V]]] = None, **kwargs) -> Dict[K, V]:\n-    \"\"\"shorthand function for setting a `dict` attribute on a dataclass,\n-    so that every instance of the dataclass doesn't share the same `dict`.\n-\n-    Accepts any of the arguments of the `dataclasses.field` function.\n-\n-    Returns:\n-        Dict[K, V]: a `dataclasses.Field` of type `Dict[K, V]`, containing the `default_items`. \n-    \"\"\"\n-    if default_items is None:\n-        default_items = []\n-    elif isinstance(default_items, dict):\n-        default_items = default_items.items()\n-    return MutableField(dict, default_items, **kwargs)\n-\n-\n-def set_field(*default_items: T, **kwargs) -> Set[T]:\n-    return MutableField(set, default_items, **kwargs)\n-\n-\n-def MutableField(_type: Type[T], *args, init: bool = True, repr: bool = True, hash: bool = None, compare: bool = True, metadata: Dict[str, Any] = None, **kwargs) -> T:\n-    return field(default_factory=partial(_type, *args, **kwargs), init=init, repr=repr, hash=hash, compare=compare, metadata=metadata)\n-\n-\n-def subparsers(subcommands: Dict[str, Type], default=None) -> Any:\n-    if default is not None and default not in subcommands:\n-        raise ValueError(\n-            f\"Default value of {default} is not a valid subparser! (subcommand: {subcommands})\")\n-    return field(default=default, metadata={\n-        \"subparsers\": subcommands,\n-        \"default\": default,\n-    })\n \n",
        "source_code_with_indent": "\ndef foo(a: int = 123, b: str = None) -> float:\n    <IND>\"\"\"[summary]\n\n    [extended_summary]\n\n    Parameters\n    ----------\n    - a : int, optional\n        [description], by default 123\n    - b : str, optional\n        [description], by default None\n\n    Returns\n    -------\n    float\n        [description]\n    \"\"\"\n\n\n<DED>def field(*,\n          alias: Union[str, List[str]] = None,\n          default: Union[T, _MISSING_TYPE] = MISSING,\n          default_factory: Union[Callable[[], T], _MISSING_TYPE] = MISSING,\n          init: bool = True,\n          repr: bool = True,\n          hash: bool = None,\n          compare: bool = True,\n          metadata: Dict[str, Any] = None,\n          **custom_argparse_args) -> T:\n    <IND>\"\"\"Calls the `dataclasses.field` function, and leftover arguments are fed\n    directly to the `ArgumentParser.add_argument(*option_strings, **kwargs)`\n    method.\n\n    Parameters\n    ----------\n    alias : List[str], optional\n        Additional option_strings to pass to the `add_argument` method, by\n        default None\n    default : Union[T, _MISSING_TYPE], optional\n        The default field value (same as in `dataclasses.field`), by default MISSING\n    default_factory : Union[Callable[[], T], _MISSING_TYPE], optional\n        (same as in `dataclasses.field`), by default None\n    init : bool, optional\n        (same as in `dataclasses.field`), by default True\n    repr : bool, optional\n        (same as in `dataclasses.field`), by default True\n    hash : bool, optional\n        (same as in `dataclasses.field`), by default None\n    compare : bool, optional\n        (same as in `dataclasses.field`), by default True\n    metadata : Dict[str, Any], optional\n        (same as in `dataclasses.field`), by default None\n\n    Returns\n    -------\n    T\n        The value returned by the `dataclasses.field` function.\n    \"\"\"\n    _metadata: Dict[str, Any] = metadata if metadata is not None else {}\n    if alias:\n        <IND>_metadata.update({\n            \"alias\": alias if isinstance(alias, list) else [alias]\n        })\n    <DED>if custom_argparse_args:\n        <IND>_metadata.update({\"custom_args\": custom_argparse_args})\n\n    <DED>if default is not MISSING:\n        <IND>return dataclasses.field(  # type: ignore\n            default=default,\n            init=init,\n            repr=repr,\n            hash=hash,\n            compare=compare,\n            metadata=_metadata\n        )\n    <DED>else:\n        <IND>return dataclasses.field(  # type: ignore\n            default_factory=default_factory,\n            init=init,\n            repr=repr,\n            hash=hash,\n            compare=compare,\n            metadata=_metadata\n        )\n\n\n<DED><DED>def choice(*choices: T, default: T = None, **kwargs) -> T:\n    <IND>\"\"\" Makes a regular attribute, whose value, when parsed from the \n    command-line, can only be one contained in `choices`, with a default value \n    of `default`.\n\n    Returns a regular `dataclasses.field()`, but with metadata which indicates  \n    the allowed values.\n\n    Args:\n        default (T, optional): The default value of the field. Defaults to None,\n        in which case the command-line argument is required.\n\n    Raises:\n        ValueError: If the default value isn't part of the given choices.\n\n    Returns:\n        T: the result of the usual `dataclasses.field()` function (a dataclass field/attribute).\n    \"\"\"\n    if default is not None and default not in choices:\n        <IND>raise ValueError(\n            f\"Default value of {default} is not a valid option! (options: {choices})\")\n    <DED>return field(default=default, choices=choices, **kwargs)  # type: ignore\n\n\n<DED>@dataclass\nclass Bob:\n    <IND>a: str = choice(\"1\", \"2\", \"3\", default=\"1\")\n\n\n<DED>def list_field(*default_items: SimpleValueType, **kwargs) -> List[T]:\n    <IND>\"\"\"shorthand function for setting a `list` attribute on a dataclass,\n    so that every instance of the dataclass doesn't share the same list.\n\n    Accepts any of the arguments of the `dataclasses.field` function.\n\n    Returns:\n        List[T]: a `dataclasses.field` of type `list`, containing the `default_items`. \n    \"\"\"\n    return MutableField(list, default_items, **kwargs)\n\n\n<DED>def dict_field(default_items: Union[Dict[K, V], Iterable[Tuple[K, V]]] = None, **kwargs) -> Dict[K, V]:\n    <IND>\"\"\"shorthand function for setting a `dict` attribute on a dataclass,\n    so that every instance of the dataclass doesn't share the same `dict`.\n\n    Accepts any of the arguments of the `dataclasses.field` function.\n\n    Returns:\n        Dict[K, V]: a `dataclasses.Field` of type `Dict[K, V]`, containing the `default_items`. \n    \"\"\"\n    if default_items is None:\n        <IND>default_items = []\n    <DED>elif isinstance(default_items, dict):\n        <IND>default_items = default_items.items()\n    <DED>return MutableField(dict, default_items, **kwargs)\n\n\n<DED>def set_field(*default_items: T, **kwargs) -> Set[T]:\n    <IND>return MutableField(set, default_items, **kwargs)\n\n\n<DED>def MutableField(_type: Type[T], *args, init: bool = True, repr: bool = True, hash: bool = None, compare: bool = True, metadata: Dict[str, Any] = None, **kwargs) -> T:\n    <IND>return field(default_factory=partial(_type, *args, **kwargs), init=init, repr=repr, hash=hash, compare=compare, metadata=metadata)\n\n\n<DED>def subparsers(subcommands: Dict[str, Type], default=None) -> Any:\n    <IND>if default is not None and default not in subcommands:\n        <IND>raise ValueError(\n            f\"Default value of {default} is not a valid subparser! (subcommand: {subcommands})\")\n    <DED>return field(default=default, metadata={\n        \"subparsers\": subcommands,\n        \"default\": default,\n    })\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "lebrice/SimpleParsing",
    "commit": "f6063a6a6325f5bf711db90492203b0a07a39a0d",
    "filename": "simple_parsing/utils.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/lebrice-SimpleParsing/simple_parsing/utils.py",
    "file_hunks_size": 7,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": true,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "simple_parsing/utils.py:111:12 Incompatible parameter type [6]: Expected `typing.Callable[[], Variable[dataclasses._T]]` for 1st parameter `default_factory` to call `dataclasses.field` but got `typing.Union[typing.Callable[[], Variable[T]], _MISSING_TYPE]`.",
    "message": " Expected `typing.Callable[[], Variable[dataclasses._T]]` for 1st parameter `default_factory` to call `dataclasses.field` but got `typing.Union[typing.Callable[[], Variable[T]], _MISSING_TYPE]`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 111,
    "warning_line": "            default_factory=default_factory,",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": true,
        "has_suppression": false,
        "source_code": "\ndef foo(a: int = 123, b: str = None) -> float:\n    \"\"\"[summary]\n\n    [extended_summary]\n\n    Parameters\n    ----------\n    - a : int, optional\n        [description], by default 123\n    - b : str, optional\n        [description], by default None\n\n    Returns\n    -------\n    float\n        [description]\n    \"\"\"\n\n\ndef field(*,\n          alias: Union[str, List[str]] = None,\n          default: Union[T, _MISSING_TYPE] = MISSING,\n          default_factory: Union[Callable[[], T], _MISSING_TYPE] = MISSING,\n          init: bool = True,\n          repr: bool = True,\n          hash: bool = None,\n          compare: bool = True,\n          metadata: Dict[str, Any] = None,\n          **custom_argparse_args) -> T:\n    \"\"\"Calls the `dataclasses.field` function, and leftover arguments are fed\n    directly to the `ArgumentParser.add_argument(*option_strings, **kwargs)`\n    method.\n\n    Parameters\n    ----------\n    alias : List[str], optional\n        Additional option_strings to pass to the `add_argument` method, by\n        default None\n    default : Union[T, _MISSING_TYPE], optional\n        The default field value (same as in `dataclasses.field`), by default MISSING\n    default_factory : Union[Callable[[], T], _MISSING_TYPE], optional\n        (same as in `dataclasses.field`), by default None\n    init : bool, optional\n        (same as in `dataclasses.field`), by default True\n    repr : bool, optional\n        (same as in `dataclasses.field`), by default True\n    hash : bool, optional\n        (same as in `dataclasses.field`), by default None\n    compare : bool, optional\n        (same as in `dataclasses.field`), by default True\n    metadata : Dict[str, Any], optional\n        (same as in `dataclasses.field`), by default None\n\n    Returns\n    -------\n    T\n        The value returned by the `dataclasses.field` function.\n    \"\"\"\n    _metadata: Dict[str, Any] = metadata if metadata is not None else {}\n    if alias:\n        _metadata.update({\n            \"alias\": alias if isinstance(alias, list) else [alias]\n        })\n    if custom_argparse_args:\n        _metadata.update({\"custom_args\": custom_argparse_args})\n\n    if default is not MISSING:\n        return dataclasses.field(  # type: ignore\n            default=default,\n            init=init,\n            repr=repr,\n            hash=hash,\n            compare=compare,\n            metadata=_metadata\n        )\n    else:\n        return dataclasses.field(  # type: ignore\n            default_factory=default_factory,\n            init=init,\n            repr=repr,\n            hash=hash,\n            compare=compare,\n            metadata=_metadata\n        )\n\n\ndef choice(*choices: T, default: T = None, **kwargs) -> T:\n    \"\"\" Makes a regular attribute, whose value, when parsed from the \n    command-line, can only be one contained in `choices`, with a default value \n    of `default`.\n\n    Returns a regular `dataclasses.field()`, but with metadata which indicates  \n    the allowed values.\n\n    Args:\n        default (T, optional): The default value of the field. Defaults to None,\n        in which case the command-line argument is required.\n\n    Raises:\n        ValueError: If the default value isn't part of the given choices.\n\n    Returns:\n        T: the result of the usual `dataclasses.field()` function (a dataclass field/attribute).\n    \"\"\"\n    if default is not None and default not in choices:\n        raise ValueError(\n            f\"Default value of {default} is not a valid option! (options: {choices})\")\n    return field(default=default, choices=choices, **kwargs)  # type: ignore\n\n\n@dataclass\nclass Bob:\n    a: str = choice(\"1\", \"2\", \"3\", default=\"1\")\n\n\ndef list_field(*default_items: SimpleValueType, **kwargs) -> List[T]:\n    \"\"\"shorthand function for setting a `list` attribute on a dataclass,\n    so that every instance of the dataclass doesn't share the same list.\n\n    Accepts any of the arguments of the `dataclasses.field` function.\n\n    Returns:\n        List[T]: a `dataclasses.field` of type `list`, containing the `default_items`. \n    \"\"\"\n    return MutableField(list, default_items, **kwargs)\n\n\ndef dict_field(default_items: Union[Dict[K, V], Iterable[Tuple[K, V]]] = None, **kwargs) -> Dict[K, V]:\n    \"\"\"shorthand function for setting a `dict` attribute on a dataclass,\n    so that every instance of the dataclass doesn't share the same `dict`.\n\n    Accepts any of the arguments of the `dataclasses.field` function.\n\n    Returns:\n        Dict[K, V]: a `dataclasses.Field` of type `Dict[K, V]`, containing the `default_items`. \n    \"\"\"\n    if default_items is None:\n        default_items = []\n    elif isinstance(default_items, dict):\n        default_items = default_items.items()\n    return MutableField(dict, default_items, **kwargs)\n\n\ndef set_field(*default_items: T, **kwargs) -> Set[T]:\n    return MutableField(set, default_items, **kwargs)\n\n\ndef MutableField(_type: Type[T], *args, init: bool = True, repr: bool = True, hash: bool = None, compare: bool = True, metadata: Dict[str, Any] = None, **kwargs) -> T:\n    return field(default_factory=partial(_type, *args, **kwargs), init=init, repr=repr, hash=hash, compare=compare, metadata=metadata)\n\n\ndef subparsers(subcommands: Dict[str, Type], default=None) -> Any:\n    if default is not None and default not in subcommands:\n        raise ValueError(\n            f\"Default value of {default} is not a valid subparser! (subcommand: {subcommands})\")\n    return field(default=default, metadata={\n        \"subparsers\": subcommands,\n        \"default\": default,\n    })\n\n",
        "source_code_len": 5501,
        "target_code": "\n\n",
        "target_code_len": 2,
        "diff_format": "@@ -33,161 +36,2 @@\n \n-def foo(a: int = 123, b: str = None) -> float:\n-    \"\"\"[summary]\n-\n-    [extended_summary]\n-\n-    Parameters\n-    ----------\n-    - a : int, optional\n-        [description], by default 123\n-    - b : str, optional\n-        [description], by default None\n-\n-    Returns\n-    -------\n-    float\n-        [description]\n-    \"\"\"\n-\n-\n-def field(*,\n-          alias: Union[str, List[str]] = None,\n-          default: Union[T, _MISSING_TYPE] = MISSING,\n-          default_factory: Union[Callable[[], T], _MISSING_TYPE] = MISSING,\n-          init: bool = True,\n-          repr: bool = True,\n-          hash: bool = None,\n-          compare: bool = True,\n-          metadata: Dict[str, Any] = None,\n-          **custom_argparse_args) -> T:\n-    \"\"\"Calls the `dataclasses.field` function, and leftover arguments are fed\n-    directly to the `ArgumentParser.add_argument(*option_strings, **kwargs)`\n-    method.\n-\n-    Parameters\n-    ----------\n-    alias : List[str], optional\n-        Additional option_strings to pass to the `add_argument` method, by\n-        default None\n-    default : Union[T, _MISSING_TYPE], optional\n-        The default field value (same as in `dataclasses.field`), by default MISSING\n-    default_factory : Union[Callable[[], T], _MISSING_TYPE], optional\n-        (same as in `dataclasses.field`), by default None\n-    init : bool, optional\n-        (same as in `dataclasses.field`), by default True\n-    repr : bool, optional\n-        (same as in `dataclasses.field`), by default True\n-    hash : bool, optional\n-        (same as in `dataclasses.field`), by default None\n-    compare : bool, optional\n-        (same as in `dataclasses.field`), by default True\n-    metadata : Dict[str, Any], optional\n-        (same as in `dataclasses.field`), by default None\n-\n-    Returns\n-    -------\n-    T\n-        The value returned by the `dataclasses.field` function.\n-    \"\"\"\n-    _metadata: Dict[str, Any] = metadata if metadata is not None else {}\n-    if alias:\n-        _metadata.update({\n-            \"alias\": alias if isinstance(alias, list) else [alias]\n-        })\n-    if custom_argparse_args:\n-        _metadata.update({\"custom_args\": custom_argparse_args})\n-\n-    if default is not MISSING:\n-        return dataclasses.field(  # type: ignore\n-            default=default,\n-            init=init,\n-            repr=repr,\n-            hash=hash,\n-            compare=compare,\n-            metadata=_metadata\n-        )\n-    else:\n-        return dataclasses.field(  # type: ignore\n-            default_factory=default_factory,\n-            init=init,\n-            repr=repr,\n-            hash=hash,\n-            compare=compare,\n-            metadata=_metadata\n-        )\n-\n-\n-def choice(*choices: T, default: T = None, **kwargs) -> T:\n-    \"\"\" Makes a regular attribute, whose value, when parsed from the \n-    command-line, can only be one contained in `choices`, with a default value \n-    of `default`.\n-\n-    Returns a regular `dataclasses.field()`, but with metadata which indicates  \n-    the allowed values.\n-\n-    Args:\n-        default (T, optional): The default value of the field. Defaults to None,\n-        in which case the command-line argument is required.\n-\n-    Raises:\n-        ValueError: If the default value isn't part of the given choices.\n-\n-    Returns:\n-        T: the result of the usual `dataclasses.field()` function (a dataclass field/attribute).\n-    \"\"\"\n-    if default is not None and default not in choices:\n-        raise ValueError(\n-            f\"Default value of {default} is not a valid option! (options: {choices})\")\n-    return field(default=default, choices=choices, **kwargs)  # type: ignore\n-\n-\n-@dataclass\n-class Bob:\n-    a: str = choice(\"1\", \"2\", \"3\", default=\"1\")\n-\n-\n-def list_field(*default_items: SimpleValueType, **kwargs) -> List[T]:\n-    \"\"\"shorthand function for setting a `list` attribute on a dataclass,\n-    so that every instance of the dataclass doesn't share the same list.\n-\n-    Accepts any of the arguments of the `dataclasses.field` function.\n-\n-    Returns:\n-        List[T]: a `dataclasses.field` of type `list`, containing the `default_items`. \n-    \"\"\"\n-    return MutableField(list, default_items, **kwargs)\n-\n-\n-def dict_field(default_items: Union[Dict[K, V], Iterable[Tuple[K, V]]] = None, **kwargs) -> Dict[K, V]:\n-    \"\"\"shorthand function for setting a `dict` attribute on a dataclass,\n-    so that every instance of the dataclass doesn't share the same `dict`.\n-\n-    Accepts any of the arguments of the `dataclasses.field` function.\n-\n-    Returns:\n-        Dict[K, V]: a `dataclasses.Field` of type `Dict[K, V]`, containing the `default_items`. \n-    \"\"\"\n-    if default_items is None:\n-        default_items = []\n-    elif isinstance(default_items, dict):\n-        default_items = default_items.items()\n-    return MutableField(dict, default_items, **kwargs)\n-\n-\n-def set_field(*default_items: T, **kwargs) -> Set[T]:\n-    return MutableField(set, default_items, **kwargs)\n-\n-\n-def MutableField(_type: Type[T], *args, init: bool = True, repr: bool = True, hash: bool = None, compare: bool = True, metadata: Dict[str, Any] = None, **kwargs) -> T:\n-    return field(default_factory=partial(_type, *args, **kwargs), init=init, repr=repr, hash=hash, compare=compare, metadata=metadata)\n-\n-\n-def subparsers(subcommands: Dict[str, Type], default=None) -> Any:\n-    if default is not None and default not in subcommands:\n-        raise ValueError(\n-            f\"Default value of {default} is not a valid subparser! (subcommand: {subcommands})\")\n-    return field(default=default, metadata={\n-        \"subparsers\": subcommands,\n-        \"default\": default,\n-    })\n \n",
        "source_code_with_indent": "\ndef foo(a: int = 123, b: str = None) -> float:\n    <IND>\"\"\"[summary]\n\n    [extended_summary]\n\n    Parameters\n    ----------\n    - a : int, optional\n        [description], by default 123\n    - b : str, optional\n        [description], by default None\n\n    Returns\n    -------\n    float\n        [description]\n    \"\"\"\n\n\n<DED>def field(*,\n          alias: Union[str, List[str]] = None,\n          default: Union[T, _MISSING_TYPE] = MISSING,\n          default_factory: Union[Callable[[], T], _MISSING_TYPE] = MISSING,\n          init: bool = True,\n          repr: bool = True,\n          hash: bool = None,\n          compare: bool = True,\n          metadata: Dict[str, Any] = None,\n          **custom_argparse_args) -> T:\n    <IND>\"\"\"Calls the `dataclasses.field` function, and leftover arguments are fed\n    directly to the `ArgumentParser.add_argument(*option_strings, **kwargs)`\n    method.\n\n    Parameters\n    ----------\n    alias : List[str], optional\n        Additional option_strings to pass to the `add_argument` method, by\n        default None\n    default : Union[T, _MISSING_TYPE], optional\n        The default field value (same as in `dataclasses.field`), by default MISSING\n    default_factory : Union[Callable[[], T], _MISSING_TYPE], optional\n        (same as in `dataclasses.field`), by default None\n    init : bool, optional\n        (same as in `dataclasses.field`), by default True\n    repr : bool, optional\n        (same as in `dataclasses.field`), by default True\n    hash : bool, optional\n        (same as in `dataclasses.field`), by default None\n    compare : bool, optional\n        (same as in `dataclasses.field`), by default True\n    metadata : Dict[str, Any], optional\n        (same as in `dataclasses.field`), by default None\n\n    Returns\n    -------\n    T\n        The value returned by the `dataclasses.field` function.\n    \"\"\"\n    _metadata: Dict[str, Any] = metadata if metadata is not None else {}\n    if alias:\n        <IND>_metadata.update({\n            \"alias\": alias if isinstance(alias, list) else [alias]\n        })\n    <DED>if custom_argparse_args:\n        <IND>_metadata.update({\"custom_args\": custom_argparse_args})\n\n    <DED>if default is not MISSING:\n        <IND>return dataclasses.field(  # type: ignore\n            default=default,\n            init=init,\n            repr=repr,\n            hash=hash,\n            compare=compare,\n            metadata=_metadata\n        )\n    <DED>else:\n        <IND>return dataclasses.field(  # type: ignore\n            default_factory=default_factory,\n            init=init,\n            repr=repr,\n            hash=hash,\n            compare=compare,\n            metadata=_metadata\n        )\n\n\n<DED><DED>def choice(*choices: T, default: T = None, **kwargs) -> T:\n    <IND>\"\"\" Makes a regular attribute, whose value, when parsed from the \n    command-line, can only be one contained in `choices`, with a default value \n    of `default`.\n\n    Returns a regular `dataclasses.field()`, but with metadata which indicates  \n    the allowed values.\n\n    Args:\n        default (T, optional): The default value of the field. Defaults to None,\n        in which case the command-line argument is required.\n\n    Raises:\n        ValueError: If the default value isn't part of the given choices.\n\n    Returns:\n        T: the result of the usual `dataclasses.field()` function (a dataclass field/attribute).\n    \"\"\"\n    if default is not None and default not in choices:\n        <IND>raise ValueError(\n            f\"Default value of {default} is not a valid option! (options: {choices})\")\n    <DED>return field(default=default, choices=choices, **kwargs)  # type: ignore\n\n\n<DED>@dataclass\nclass Bob:\n    <IND>a: str = choice(\"1\", \"2\", \"3\", default=\"1\")\n\n\n<DED>def list_field(*default_items: SimpleValueType, **kwargs) -> List[T]:\n    <IND>\"\"\"shorthand function for setting a `list` attribute on a dataclass,\n    so that every instance of the dataclass doesn't share the same list.\n\n    Accepts any of the arguments of the `dataclasses.field` function.\n\n    Returns:\n        List[T]: a `dataclasses.field` of type `list`, containing the `default_items`. \n    \"\"\"\n    return MutableField(list, default_items, **kwargs)\n\n\n<DED>def dict_field(default_items: Union[Dict[K, V], Iterable[Tuple[K, V]]] = None, **kwargs) -> Dict[K, V]:\n    <IND>\"\"\"shorthand function for setting a `dict` attribute on a dataclass,\n    so that every instance of the dataclass doesn't share the same `dict`.\n\n    Accepts any of the arguments of the `dataclasses.field` function.\n\n    Returns:\n        Dict[K, V]: a `dataclasses.Field` of type `Dict[K, V]`, containing the `default_items`. \n    \"\"\"\n    if default_items is None:\n        <IND>default_items = []\n    <DED>elif isinstance(default_items, dict):\n        <IND>default_items = default_items.items()\n    <DED>return MutableField(dict, default_items, **kwargs)\n\n\n<DED>def set_field(*default_items: T, **kwargs) -> Set[T]:\n    <IND>return MutableField(set, default_items, **kwargs)\n\n\n<DED>def MutableField(_type: Type[T], *args, init: bool = True, repr: bool = True, hash: bool = None, compare: bool = True, metadata: Dict[str, Any] = None, **kwargs) -> T:\n    <IND>return field(default_factory=partial(_type, *args, **kwargs), init=init, repr=repr, hash=hash, compare=compare, metadata=metadata)\n\n\n<DED>def subparsers(subcommands: Dict[str, Type], default=None) -> Any:\n    <IND>if default is not None and default not in subcommands:\n        <IND>raise ValueError(\n            f\"Default value of {default} is not a valid subparser! (subcommand: {subcommands})\")\n    <DED>return field(default=default, metadata={\n        \"subparsers\": subcommands,\n        \"default\": default,\n    })\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "lebrice/SimpleParsing",
    "commit": "f6063a6a6325f5bf711db90492203b0a07a39a0d",
    "filename": "simple_parsing/utils.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/lebrice-SimpleParsing/simple_parsing/utils.py",
    "file_hunks_size": 7,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": true,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "simple_parsing/utils.py:161:15 Incompatible variable type [9]: default_items is declared to have type `typing.Union[typing.Dict[Variable[K], Variable[V]], typing.Iterable[typing.Tuple[Variable[K], Variable[V]]]]` but is used as type `None`.",
    "message": " default_items is declared to have type `typing.Union[typing.Dict[Variable[K], Variable[V]], typing.Iterable[typing.Tuple[Variable[K], Variable[V]]]]` but is used as type `None`.",
    "rule_id": "Incompatible variable type [9]",
    "warning_line_no": 161,
    "warning_line": "def dict_field(default_items: Union[Dict[K, V], Iterable[Tuple[K, V]]] = None, **kwargs) -> Dict[K, V]:",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": true,
        "has_suppression": false,
        "source_code": "\ndef foo(a: int = 123, b: str = None) -> float:\n    \"\"\"[summary]\n\n    [extended_summary]\n\n    Parameters\n    ----------\n    - a : int, optional\n        [description], by default 123\n    - b : str, optional\n        [description], by default None\n\n    Returns\n    -------\n    float\n        [description]\n    \"\"\"\n\n\ndef field(*,\n          alias: Union[str, List[str]] = None,\n          default: Union[T, _MISSING_TYPE] = MISSING,\n          default_factory: Union[Callable[[], T], _MISSING_TYPE] = MISSING,\n          init: bool = True,\n          repr: bool = True,\n          hash: bool = None,\n          compare: bool = True,\n          metadata: Dict[str, Any] = None,\n          **custom_argparse_args) -> T:\n    \"\"\"Calls the `dataclasses.field` function, and leftover arguments are fed\n    directly to the `ArgumentParser.add_argument(*option_strings, **kwargs)`\n    method.\n\n    Parameters\n    ----------\n    alias : List[str], optional\n        Additional option_strings to pass to the `add_argument` method, by\n        default None\n    default : Union[T, _MISSING_TYPE], optional\n        The default field value (same as in `dataclasses.field`), by default MISSING\n    default_factory : Union[Callable[[], T], _MISSING_TYPE], optional\n        (same as in `dataclasses.field`), by default None\n    init : bool, optional\n        (same as in `dataclasses.field`), by default True\n    repr : bool, optional\n        (same as in `dataclasses.field`), by default True\n    hash : bool, optional\n        (same as in `dataclasses.field`), by default None\n    compare : bool, optional\n        (same as in `dataclasses.field`), by default True\n    metadata : Dict[str, Any], optional\n        (same as in `dataclasses.field`), by default None\n\n    Returns\n    -------\n    T\n        The value returned by the `dataclasses.field` function.\n    \"\"\"\n    _metadata: Dict[str, Any] = metadata if metadata is not None else {}\n    if alias:\n        _metadata.update({\n            \"alias\": alias if isinstance(alias, list) else [alias]\n        })\n    if custom_argparse_args:\n        _metadata.update({\"custom_args\": custom_argparse_args})\n\n    if default is not MISSING:\n        return dataclasses.field(  # type: ignore\n            default=default,\n            init=init,\n            repr=repr,\n            hash=hash,\n            compare=compare,\n            metadata=_metadata\n        )\n    else:\n        return dataclasses.field(  # type: ignore\n            default_factory=default_factory,\n            init=init,\n            repr=repr,\n            hash=hash,\n            compare=compare,\n            metadata=_metadata\n        )\n\n\ndef choice(*choices: T, default: T = None, **kwargs) -> T:\n    \"\"\" Makes a regular attribute, whose value, when parsed from the \n    command-line, can only be one contained in `choices`, with a default value \n    of `default`.\n\n    Returns a regular `dataclasses.field()`, but with metadata which indicates  \n    the allowed values.\n\n    Args:\n        default (T, optional): The default value of the field. Defaults to None,\n        in which case the command-line argument is required.\n\n    Raises:\n        ValueError: If the default value isn't part of the given choices.\n\n    Returns:\n        T: the result of the usual `dataclasses.field()` function (a dataclass field/attribute).\n    \"\"\"\n    if default is not None and default not in choices:\n        raise ValueError(\n            f\"Default value of {default} is not a valid option! (options: {choices})\")\n    return field(default=default, choices=choices, **kwargs)  # type: ignore\n\n\n@dataclass\nclass Bob:\n    a: str = choice(\"1\", \"2\", \"3\", default=\"1\")\n\n\ndef list_field(*default_items: SimpleValueType, **kwargs) -> List[T]:\n    \"\"\"shorthand function for setting a `list` attribute on a dataclass,\n    so that every instance of the dataclass doesn't share the same list.\n\n    Accepts any of the arguments of the `dataclasses.field` function.\n\n    Returns:\n        List[T]: a `dataclasses.field` of type `list`, containing the `default_items`. \n    \"\"\"\n    return MutableField(list, default_items, **kwargs)\n\n\ndef dict_field(default_items: Union[Dict[K, V], Iterable[Tuple[K, V]]] = None, **kwargs) -> Dict[K, V]:\n    \"\"\"shorthand function for setting a `dict` attribute on a dataclass,\n    so that every instance of the dataclass doesn't share the same `dict`.\n\n    Accepts any of the arguments of the `dataclasses.field` function.\n\n    Returns:\n        Dict[K, V]: a `dataclasses.Field` of type `Dict[K, V]`, containing the `default_items`. \n    \"\"\"\n    if default_items is None:\n        default_items = []\n    elif isinstance(default_items, dict):\n        default_items = default_items.items()\n    return MutableField(dict, default_items, **kwargs)\n\n\ndef set_field(*default_items: T, **kwargs) -> Set[T]:\n    return MutableField(set, default_items, **kwargs)\n\n\ndef MutableField(_type: Type[T], *args, init: bool = True, repr: bool = True, hash: bool = None, compare: bool = True, metadata: Dict[str, Any] = None, **kwargs) -> T:\n    return field(default_factory=partial(_type, *args, **kwargs), init=init, repr=repr, hash=hash, compare=compare, metadata=metadata)\n\n\ndef subparsers(subcommands: Dict[str, Type], default=None) -> Any:\n    if default is not None and default not in subcommands:\n        raise ValueError(\n            f\"Default value of {default} is not a valid subparser! (subcommand: {subcommands})\")\n    return field(default=default, metadata={\n        \"subparsers\": subcommands,\n        \"default\": default,\n    })\n\n",
        "source_code_len": 5501,
        "target_code": "\n\n",
        "target_code_len": 2,
        "diff_format": "@@ -33,161 +36,2 @@\n \n-def foo(a: int = 123, b: str = None) -> float:\n-    \"\"\"[summary]\n-\n-    [extended_summary]\n-\n-    Parameters\n-    ----------\n-    - a : int, optional\n-        [description], by default 123\n-    - b : str, optional\n-        [description], by default None\n-\n-    Returns\n-    -------\n-    float\n-        [description]\n-    \"\"\"\n-\n-\n-def field(*,\n-          alias: Union[str, List[str]] = None,\n-          default: Union[T, _MISSING_TYPE] = MISSING,\n-          default_factory: Union[Callable[[], T], _MISSING_TYPE] = MISSING,\n-          init: bool = True,\n-          repr: bool = True,\n-          hash: bool = None,\n-          compare: bool = True,\n-          metadata: Dict[str, Any] = None,\n-          **custom_argparse_args) -> T:\n-    \"\"\"Calls the `dataclasses.field` function, and leftover arguments are fed\n-    directly to the `ArgumentParser.add_argument(*option_strings, **kwargs)`\n-    method.\n-\n-    Parameters\n-    ----------\n-    alias : List[str], optional\n-        Additional option_strings to pass to the `add_argument` method, by\n-        default None\n-    default : Union[T, _MISSING_TYPE], optional\n-        The default field value (same as in `dataclasses.field`), by default MISSING\n-    default_factory : Union[Callable[[], T], _MISSING_TYPE], optional\n-        (same as in `dataclasses.field`), by default None\n-    init : bool, optional\n-        (same as in `dataclasses.field`), by default True\n-    repr : bool, optional\n-        (same as in `dataclasses.field`), by default True\n-    hash : bool, optional\n-        (same as in `dataclasses.field`), by default None\n-    compare : bool, optional\n-        (same as in `dataclasses.field`), by default True\n-    metadata : Dict[str, Any], optional\n-        (same as in `dataclasses.field`), by default None\n-\n-    Returns\n-    -------\n-    T\n-        The value returned by the `dataclasses.field` function.\n-    \"\"\"\n-    _metadata: Dict[str, Any] = metadata if metadata is not None else {}\n-    if alias:\n-        _metadata.update({\n-            \"alias\": alias if isinstance(alias, list) else [alias]\n-        })\n-    if custom_argparse_args:\n-        _metadata.update({\"custom_args\": custom_argparse_args})\n-\n-    if default is not MISSING:\n-        return dataclasses.field(  # type: ignore\n-            default=default,\n-            init=init,\n-            repr=repr,\n-            hash=hash,\n-            compare=compare,\n-            metadata=_metadata\n-        )\n-    else:\n-        return dataclasses.field(  # type: ignore\n-            default_factory=default_factory,\n-            init=init,\n-            repr=repr,\n-            hash=hash,\n-            compare=compare,\n-            metadata=_metadata\n-        )\n-\n-\n-def choice(*choices: T, default: T = None, **kwargs) -> T:\n-    \"\"\" Makes a regular attribute, whose value, when parsed from the \n-    command-line, can only be one contained in `choices`, with a default value \n-    of `default`.\n-\n-    Returns a regular `dataclasses.field()`, but with metadata which indicates  \n-    the allowed values.\n-\n-    Args:\n-        default (T, optional): The default value of the field. Defaults to None,\n-        in which case the command-line argument is required.\n-\n-    Raises:\n-        ValueError: If the default value isn't part of the given choices.\n-\n-    Returns:\n-        T: the result of the usual `dataclasses.field()` function (a dataclass field/attribute).\n-    \"\"\"\n-    if default is not None and default not in choices:\n-        raise ValueError(\n-            f\"Default value of {default} is not a valid option! (options: {choices})\")\n-    return field(default=default, choices=choices, **kwargs)  # type: ignore\n-\n-\n-@dataclass\n-class Bob:\n-    a: str = choice(\"1\", \"2\", \"3\", default=\"1\")\n-\n-\n-def list_field(*default_items: SimpleValueType, **kwargs) -> List[T]:\n-    \"\"\"shorthand function for setting a `list` attribute on a dataclass,\n-    so that every instance of the dataclass doesn't share the same list.\n-\n-    Accepts any of the arguments of the `dataclasses.field` function.\n-\n-    Returns:\n-        List[T]: a `dataclasses.field` of type `list`, containing the `default_items`. \n-    \"\"\"\n-    return MutableField(list, default_items, **kwargs)\n-\n-\n-def dict_field(default_items: Union[Dict[K, V], Iterable[Tuple[K, V]]] = None, **kwargs) -> Dict[K, V]:\n-    \"\"\"shorthand function for setting a `dict` attribute on a dataclass,\n-    so that every instance of the dataclass doesn't share the same `dict`.\n-\n-    Accepts any of the arguments of the `dataclasses.field` function.\n-\n-    Returns:\n-        Dict[K, V]: a `dataclasses.Field` of type `Dict[K, V]`, containing the `default_items`. \n-    \"\"\"\n-    if default_items is None:\n-        default_items = []\n-    elif isinstance(default_items, dict):\n-        default_items = default_items.items()\n-    return MutableField(dict, default_items, **kwargs)\n-\n-\n-def set_field(*default_items: T, **kwargs) -> Set[T]:\n-    return MutableField(set, default_items, **kwargs)\n-\n-\n-def MutableField(_type: Type[T], *args, init: bool = True, repr: bool = True, hash: bool = None, compare: bool = True, metadata: Dict[str, Any] = None, **kwargs) -> T:\n-    return field(default_factory=partial(_type, *args, **kwargs), init=init, repr=repr, hash=hash, compare=compare, metadata=metadata)\n-\n-\n-def subparsers(subcommands: Dict[str, Type], default=None) -> Any:\n-    if default is not None and default not in subcommands:\n-        raise ValueError(\n-            f\"Default value of {default} is not a valid subparser! (subcommand: {subcommands})\")\n-    return field(default=default, metadata={\n-        \"subparsers\": subcommands,\n-        \"default\": default,\n-    })\n \n",
        "source_code_with_indent": "\ndef foo(a: int = 123, b: str = None) -> float:\n    <IND>\"\"\"[summary]\n\n    [extended_summary]\n\n    Parameters\n    ----------\n    - a : int, optional\n        [description], by default 123\n    - b : str, optional\n        [description], by default None\n\n    Returns\n    -------\n    float\n        [description]\n    \"\"\"\n\n\n<DED>def field(*,\n          alias: Union[str, List[str]] = None,\n          default: Union[T, _MISSING_TYPE] = MISSING,\n          default_factory: Union[Callable[[], T], _MISSING_TYPE] = MISSING,\n          init: bool = True,\n          repr: bool = True,\n          hash: bool = None,\n          compare: bool = True,\n          metadata: Dict[str, Any] = None,\n          **custom_argparse_args) -> T:\n    <IND>\"\"\"Calls the `dataclasses.field` function, and leftover arguments are fed\n    directly to the `ArgumentParser.add_argument(*option_strings, **kwargs)`\n    method.\n\n    Parameters\n    ----------\n    alias : List[str], optional\n        Additional option_strings to pass to the `add_argument` method, by\n        default None\n    default : Union[T, _MISSING_TYPE], optional\n        The default field value (same as in `dataclasses.field`), by default MISSING\n    default_factory : Union[Callable[[], T], _MISSING_TYPE], optional\n        (same as in `dataclasses.field`), by default None\n    init : bool, optional\n        (same as in `dataclasses.field`), by default True\n    repr : bool, optional\n        (same as in `dataclasses.field`), by default True\n    hash : bool, optional\n        (same as in `dataclasses.field`), by default None\n    compare : bool, optional\n        (same as in `dataclasses.field`), by default True\n    metadata : Dict[str, Any], optional\n        (same as in `dataclasses.field`), by default None\n\n    Returns\n    -------\n    T\n        The value returned by the `dataclasses.field` function.\n    \"\"\"\n    _metadata: Dict[str, Any] = metadata if metadata is not None else {}\n    if alias:\n        <IND>_metadata.update({\n            \"alias\": alias if isinstance(alias, list) else [alias]\n        })\n    <DED>if custom_argparse_args:\n        <IND>_metadata.update({\"custom_args\": custom_argparse_args})\n\n    <DED>if default is not MISSING:\n        <IND>return dataclasses.field(  # type: ignore\n            default=default,\n            init=init,\n            repr=repr,\n            hash=hash,\n            compare=compare,\n            metadata=_metadata\n        )\n    <DED>else:\n        <IND>return dataclasses.field(  # type: ignore\n            default_factory=default_factory,\n            init=init,\n            repr=repr,\n            hash=hash,\n            compare=compare,\n            metadata=_metadata\n        )\n\n\n<DED><DED>def choice(*choices: T, default: T = None, **kwargs) -> T:\n    <IND>\"\"\" Makes a regular attribute, whose value, when parsed from the \n    command-line, can only be one contained in `choices`, with a default value \n    of `default`.\n\n    Returns a regular `dataclasses.field()`, but with metadata which indicates  \n    the allowed values.\n\n    Args:\n        default (T, optional): The default value of the field. Defaults to None,\n        in which case the command-line argument is required.\n\n    Raises:\n        ValueError: If the default value isn't part of the given choices.\n\n    Returns:\n        T: the result of the usual `dataclasses.field()` function (a dataclass field/attribute).\n    \"\"\"\n    if default is not None and default not in choices:\n        <IND>raise ValueError(\n            f\"Default value of {default} is not a valid option! (options: {choices})\")\n    <DED>return field(default=default, choices=choices, **kwargs)  # type: ignore\n\n\n<DED>@dataclass\nclass Bob:\n    <IND>a: str = choice(\"1\", \"2\", \"3\", default=\"1\")\n\n\n<DED>def list_field(*default_items: SimpleValueType, **kwargs) -> List[T]:\n    <IND>\"\"\"shorthand function for setting a `list` attribute on a dataclass,\n    so that every instance of the dataclass doesn't share the same list.\n\n    Accepts any of the arguments of the `dataclasses.field` function.\n\n    Returns:\n        List[T]: a `dataclasses.field` of type `list`, containing the `default_items`. \n    \"\"\"\n    return MutableField(list, default_items, **kwargs)\n\n\n<DED>def dict_field(default_items: Union[Dict[K, V], Iterable[Tuple[K, V]]] = None, **kwargs) -> Dict[K, V]:\n    <IND>\"\"\"shorthand function for setting a `dict` attribute on a dataclass,\n    so that every instance of the dataclass doesn't share the same `dict`.\n\n    Accepts any of the arguments of the `dataclasses.field` function.\n\n    Returns:\n        Dict[K, V]: a `dataclasses.Field` of type `Dict[K, V]`, containing the `default_items`. \n    \"\"\"\n    if default_items is None:\n        <IND>default_items = []\n    <DED>elif isinstance(default_items, dict):\n        <IND>default_items = default_items.items()\n    <DED>return MutableField(dict, default_items, **kwargs)\n\n\n<DED>def set_field(*default_items: T, **kwargs) -> Set[T]:\n    <IND>return MutableField(set, default_items, **kwargs)\n\n\n<DED>def MutableField(_type: Type[T], *args, init: bool = True, repr: bool = True, hash: bool = None, compare: bool = True, metadata: Dict[str, Any] = None, **kwargs) -> T:\n    <IND>return field(default_factory=partial(_type, *args, **kwargs), init=init, repr=repr, hash=hash, compare=compare, metadata=metadata)\n\n\n<DED>def subparsers(subcommands: Dict[str, Type], default=None) -> Any:\n    <IND>if default is not None and default not in subcommands:\n        <IND>raise ValueError(\n            f\"Default value of {default} is not a valid subparser! (subcommand: {subcommands})\")\n    <DED>return field(default=default, metadata={\n        \"subparsers\": subcommands,\n        \"default\": default,\n    })\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "lebrice/SimpleParsing",
    "commit": "f6063a6a6325f5bf711db90492203b0a07a39a0d",
    "filename": "simple_parsing/utils.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/lebrice-SimpleParsing/simple_parsing/utils.py",
    "file_hunks_size": 7,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": true,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "simple_parsing/utils.py:181:78 Incompatible variable type [9]: hash is declared to have type `bool` but is used as type `None`.",
    "message": " hash is declared to have type `bool` but is used as type `None`.",
    "rule_id": "Incompatible variable type [9]",
    "warning_line_no": 181,
    "warning_line": "def MutableField(_type: Type[T], *args, init: bool = True, repr: bool = True, hash: bool = None, compare: bool = True, metadata: Dict[str, Any] = None, **kwargs) -> T:",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": true,
        "has_suppression": false,
        "source_code": "\ndef foo(a: int = 123, b: str = None) -> float:\n    \"\"\"[summary]\n\n    [extended_summary]\n\n    Parameters\n    ----------\n    - a : int, optional\n        [description], by default 123\n    - b : str, optional\n        [description], by default None\n\n    Returns\n    -------\n    float\n        [description]\n    \"\"\"\n\n\ndef field(*,\n          alias: Union[str, List[str]] = None,\n          default: Union[T, _MISSING_TYPE] = MISSING,\n          default_factory: Union[Callable[[], T], _MISSING_TYPE] = MISSING,\n          init: bool = True,\n          repr: bool = True,\n          hash: bool = None,\n          compare: bool = True,\n          metadata: Dict[str, Any] = None,\n          **custom_argparse_args) -> T:\n    \"\"\"Calls the `dataclasses.field` function, and leftover arguments are fed\n    directly to the `ArgumentParser.add_argument(*option_strings, **kwargs)`\n    method.\n\n    Parameters\n    ----------\n    alias : List[str], optional\n        Additional option_strings to pass to the `add_argument` method, by\n        default None\n    default : Union[T, _MISSING_TYPE], optional\n        The default field value (same as in `dataclasses.field`), by default MISSING\n    default_factory : Union[Callable[[], T], _MISSING_TYPE], optional\n        (same as in `dataclasses.field`), by default None\n    init : bool, optional\n        (same as in `dataclasses.field`), by default True\n    repr : bool, optional\n        (same as in `dataclasses.field`), by default True\n    hash : bool, optional\n        (same as in `dataclasses.field`), by default None\n    compare : bool, optional\n        (same as in `dataclasses.field`), by default True\n    metadata : Dict[str, Any], optional\n        (same as in `dataclasses.field`), by default None\n\n    Returns\n    -------\n    T\n        The value returned by the `dataclasses.field` function.\n    \"\"\"\n    _metadata: Dict[str, Any] = metadata if metadata is not None else {}\n    if alias:\n        _metadata.update({\n            \"alias\": alias if isinstance(alias, list) else [alias]\n        })\n    if custom_argparse_args:\n        _metadata.update({\"custom_args\": custom_argparse_args})\n\n    if default is not MISSING:\n        return dataclasses.field(  # type: ignore\n            default=default,\n            init=init,\n            repr=repr,\n            hash=hash,\n            compare=compare,\n            metadata=_metadata\n        )\n    else:\n        return dataclasses.field(  # type: ignore\n            default_factory=default_factory,\n            init=init,\n            repr=repr,\n            hash=hash,\n            compare=compare,\n            metadata=_metadata\n        )\n\n\ndef choice(*choices: T, default: T = None, **kwargs) -> T:\n    \"\"\" Makes a regular attribute, whose value, when parsed from the \n    command-line, can only be one contained in `choices`, with a default value \n    of `default`.\n\n    Returns a regular `dataclasses.field()`, but with metadata which indicates  \n    the allowed values.\n\n    Args:\n        default (T, optional): The default value of the field. Defaults to None,\n        in which case the command-line argument is required.\n\n    Raises:\n        ValueError: If the default value isn't part of the given choices.\n\n    Returns:\n        T: the result of the usual `dataclasses.field()` function (a dataclass field/attribute).\n    \"\"\"\n    if default is not None and default not in choices:\n        raise ValueError(\n            f\"Default value of {default} is not a valid option! (options: {choices})\")\n    return field(default=default, choices=choices, **kwargs)  # type: ignore\n\n\n@dataclass\nclass Bob:\n    a: str = choice(\"1\", \"2\", \"3\", default=\"1\")\n\n\ndef list_field(*default_items: SimpleValueType, **kwargs) -> List[T]:\n    \"\"\"shorthand function for setting a `list` attribute on a dataclass,\n    so that every instance of the dataclass doesn't share the same list.\n\n    Accepts any of the arguments of the `dataclasses.field` function.\n\n    Returns:\n        List[T]: a `dataclasses.field` of type `list`, containing the `default_items`. \n    \"\"\"\n    return MutableField(list, default_items, **kwargs)\n\n\ndef dict_field(default_items: Union[Dict[K, V], Iterable[Tuple[K, V]]] = None, **kwargs) -> Dict[K, V]:\n    \"\"\"shorthand function for setting a `dict` attribute on a dataclass,\n    so that every instance of the dataclass doesn't share the same `dict`.\n\n    Accepts any of the arguments of the `dataclasses.field` function.\n\n    Returns:\n        Dict[K, V]: a `dataclasses.Field` of type `Dict[K, V]`, containing the `default_items`. \n    \"\"\"\n    if default_items is None:\n        default_items = []\n    elif isinstance(default_items, dict):\n        default_items = default_items.items()\n    return MutableField(dict, default_items, **kwargs)\n\n\ndef set_field(*default_items: T, **kwargs) -> Set[T]:\n    return MutableField(set, default_items, **kwargs)\n\n\ndef MutableField(_type: Type[T], *args, init: bool = True, repr: bool = True, hash: bool = None, compare: bool = True, metadata: Dict[str, Any] = None, **kwargs) -> T:\n    return field(default_factory=partial(_type, *args, **kwargs), init=init, repr=repr, hash=hash, compare=compare, metadata=metadata)\n\n\ndef subparsers(subcommands: Dict[str, Type], default=None) -> Any:\n    if default is not None and default not in subcommands:\n        raise ValueError(\n            f\"Default value of {default} is not a valid subparser! (subcommand: {subcommands})\")\n    return field(default=default, metadata={\n        \"subparsers\": subcommands,\n        \"default\": default,\n    })\n\n",
        "source_code_len": 5501,
        "target_code": "\n\n",
        "target_code_len": 2,
        "diff_format": "@@ -33,161 +36,2 @@\n \n-def foo(a: int = 123, b: str = None) -> float:\n-    \"\"\"[summary]\n-\n-    [extended_summary]\n-\n-    Parameters\n-    ----------\n-    - a : int, optional\n-        [description], by default 123\n-    - b : str, optional\n-        [description], by default None\n-\n-    Returns\n-    -------\n-    float\n-        [description]\n-    \"\"\"\n-\n-\n-def field(*,\n-          alias: Union[str, List[str]] = None,\n-          default: Union[T, _MISSING_TYPE] = MISSING,\n-          default_factory: Union[Callable[[], T], _MISSING_TYPE] = MISSING,\n-          init: bool = True,\n-          repr: bool = True,\n-          hash: bool = None,\n-          compare: bool = True,\n-          metadata: Dict[str, Any] = None,\n-          **custom_argparse_args) -> T:\n-    \"\"\"Calls the `dataclasses.field` function, and leftover arguments are fed\n-    directly to the `ArgumentParser.add_argument(*option_strings, **kwargs)`\n-    method.\n-\n-    Parameters\n-    ----------\n-    alias : List[str], optional\n-        Additional option_strings to pass to the `add_argument` method, by\n-        default None\n-    default : Union[T, _MISSING_TYPE], optional\n-        The default field value (same as in `dataclasses.field`), by default MISSING\n-    default_factory : Union[Callable[[], T], _MISSING_TYPE], optional\n-        (same as in `dataclasses.field`), by default None\n-    init : bool, optional\n-        (same as in `dataclasses.field`), by default True\n-    repr : bool, optional\n-        (same as in `dataclasses.field`), by default True\n-    hash : bool, optional\n-        (same as in `dataclasses.field`), by default None\n-    compare : bool, optional\n-        (same as in `dataclasses.field`), by default True\n-    metadata : Dict[str, Any], optional\n-        (same as in `dataclasses.field`), by default None\n-\n-    Returns\n-    -------\n-    T\n-        The value returned by the `dataclasses.field` function.\n-    \"\"\"\n-    _metadata: Dict[str, Any] = metadata if metadata is not None else {}\n-    if alias:\n-        _metadata.update({\n-            \"alias\": alias if isinstance(alias, list) else [alias]\n-        })\n-    if custom_argparse_args:\n-        _metadata.update({\"custom_args\": custom_argparse_args})\n-\n-    if default is not MISSING:\n-        return dataclasses.field(  # type: ignore\n-            default=default,\n-            init=init,\n-            repr=repr,\n-            hash=hash,\n-            compare=compare,\n-            metadata=_metadata\n-        )\n-    else:\n-        return dataclasses.field(  # type: ignore\n-            default_factory=default_factory,\n-            init=init,\n-            repr=repr,\n-            hash=hash,\n-            compare=compare,\n-            metadata=_metadata\n-        )\n-\n-\n-def choice(*choices: T, default: T = None, **kwargs) -> T:\n-    \"\"\" Makes a regular attribute, whose value, when parsed from the \n-    command-line, can only be one contained in `choices`, with a default value \n-    of `default`.\n-\n-    Returns a regular `dataclasses.field()`, but with metadata which indicates  \n-    the allowed values.\n-\n-    Args:\n-        default (T, optional): The default value of the field. Defaults to None,\n-        in which case the command-line argument is required.\n-\n-    Raises:\n-        ValueError: If the default value isn't part of the given choices.\n-\n-    Returns:\n-        T: the result of the usual `dataclasses.field()` function (a dataclass field/attribute).\n-    \"\"\"\n-    if default is not None and default not in choices:\n-        raise ValueError(\n-            f\"Default value of {default} is not a valid option! (options: {choices})\")\n-    return field(default=default, choices=choices, **kwargs)  # type: ignore\n-\n-\n-@dataclass\n-class Bob:\n-    a: str = choice(\"1\", \"2\", \"3\", default=\"1\")\n-\n-\n-def list_field(*default_items: SimpleValueType, **kwargs) -> List[T]:\n-    \"\"\"shorthand function for setting a `list` attribute on a dataclass,\n-    so that every instance of the dataclass doesn't share the same list.\n-\n-    Accepts any of the arguments of the `dataclasses.field` function.\n-\n-    Returns:\n-        List[T]: a `dataclasses.field` of type `list`, containing the `default_items`. \n-    \"\"\"\n-    return MutableField(list, default_items, **kwargs)\n-\n-\n-def dict_field(default_items: Union[Dict[K, V], Iterable[Tuple[K, V]]] = None, **kwargs) -> Dict[K, V]:\n-    \"\"\"shorthand function for setting a `dict` attribute on a dataclass,\n-    so that every instance of the dataclass doesn't share the same `dict`.\n-\n-    Accepts any of the arguments of the `dataclasses.field` function.\n-\n-    Returns:\n-        Dict[K, V]: a `dataclasses.Field` of type `Dict[K, V]`, containing the `default_items`. \n-    \"\"\"\n-    if default_items is None:\n-        default_items = []\n-    elif isinstance(default_items, dict):\n-        default_items = default_items.items()\n-    return MutableField(dict, default_items, **kwargs)\n-\n-\n-def set_field(*default_items: T, **kwargs) -> Set[T]:\n-    return MutableField(set, default_items, **kwargs)\n-\n-\n-def MutableField(_type: Type[T], *args, init: bool = True, repr: bool = True, hash: bool = None, compare: bool = True, metadata: Dict[str, Any] = None, **kwargs) -> T:\n-    return field(default_factory=partial(_type, *args, **kwargs), init=init, repr=repr, hash=hash, compare=compare, metadata=metadata)\n-\n-\n-def subparsers(subcommands: Dict[str, Type], default=None) -> Any:\n-    if default is not None and default not in subcommands:\n-        raise ValueError(\n-            f\"Default value of {default} is not a valid subparser! (subcommand: {subcommands})\")\n-    return field(default=default, metadata={\n-        \"subparsers\": subcommands,\n-        \"default\": default,\n-    })\n \n",
        "source_code_with_indent": "\ndef foo(a: int = 123, b: str = None) -> float:\n    <IND>\"\"\"[summary]\n\n    [extended_summary]\n\n    Parameters\n    ----------\n    - a : int, optional\n        [description], by default 123\n    - b : str, optional\n        [description], by default None\n\n    Returns\n    -------\n    float\n        [description]\n    \"\"\"\n\n\n<DED>def field(*,\n          alias: Union[str, List[str]] = None,\n          default: Union[T, _MISSING_TYPE] = MISSING,\n          default_factory: Union[Callable[[], T], _MISSING_TYPE] = MISSING,\n          init: bool = True,\n          repr: bool = True,\n          hash: bool = None,\n          compare: bool = True,\n          metadata: Dict[str, Any] = None,\n          **custom_argparse_args) -> T:\n    <IND>\"\"\"Calls the `dataclasses.field` function, and leftover arguments are fed\n    directly to the `ArgumentParser.add_argument(*option_strings, **kwargs)`\n    method.\n\n    Parameters\n    ----------\n    alias : List[str], optional\n        Additional option_strings to pass to the `add_argument` method, by\n        default None\n    default : Union[T, _MISSING_TYPE], optional\n        The default field value (same as in `dataclasses.field`), by default MISSING\n    default_factory : Union[Callable[[], T], _MISSING_TYPE], optional\n        (same as in `dataclasses.field`), by default None\n    init : bool, optional\n        (same as in `dataclasses.field`), by default True\n    repr : bool, optional\n        (same as in `dataclasses.field`), by default True\n    hash : bool, optional\n        (same as in `dataclasses.field`), by default None\n    compare : bool, optional\n        (same as in `dataclasses.field`), by default True\n    metadata : Dict[str, Any], optional\n        (same as in `dataclasses.field`), by default None\n\n    Returns\n    -------\n    T\n        The value returned by the `dataclasses.field` function.\n    \"\"\"\n    _metadata: Dict[str, Any] = metadata if metadata is not None else {}\n    if alias:\n        <IND>_metadata.update({\n            \"alias\": alias if isinstance(alias, list) else [alias]\n        })\n    <DED>if custom_argparse_args:\n        <IND>_metadata.update({\"custom_args\": custom_argparse_args})\n\n    <DED>if default is not MISSING:\n        <IND>return dataclasses.field(  # type: ignore\n            default=default,\n            init=init,\n            repr=repr,\n            hash=hash,\n            compare=compare,\n            metadata=_metadata\n        )\n    <DED>else:\n        <IND>return dataclasses.field(  # type: ignore\n            default_factory=default_factory,\n            init=init,\n            repr=repr,\n            hash=hash,\n            compare=compare,\n            metadata=_metadata\n        )\n\n\n<DED><DED>def choice(*choices: T, default: T = None, **kwargs) -> T:\n    <IND>\"\"\" Makes a regular attribute, whose value, when parsed from the \n    command-line, can only be one contained in `choices`, with a default value \n    of `default`.\n\n    Returns a regular `dataclasses.field()`, but with metadata which indicates  \n    the allowed values.\n\n    Args:\n        default (T, optional): The default value of the field. Defaults to None,\n        in which case the command-line argument is required.\n\n    Raises:\n        ValueError: If the default value isn't part of the given choices.\n\n    Returns:\n        T: the result of the usual `dataclasses.field()` function (a dataclass field/attribute).\n    \"\"\"\n    if default is not None and default not in choices:\n        <IND>raise ValueError(\n            f\"Default value of {default} is not a valid option! (options: {choices})\")\n    <DED>return field(default=default, choices=choices, **kwargs)  # type: ignore\n\n\n<DED>@dataclass\nclass Bob:\n    <IND>a: str = choice(\"1\", \"2\", \"3\", default=\"1\")\n\n\n<DED>def list_field(*default_items: SimpleValueType, **kwargs) -> List[T]:\n    <IND>\"\"\"shorthand function for setting a `list` attribute on a dataclass,\n    so that every instance of the dataclass doesn't share the same list.\n\n    Accepts any of the arguments of the `dataclasses.field` function.\n\n    Returns:\n        List[T]: a `dataclasses.field` of type `list`, containing the `default_items`. \n    \"\"\"\n    return MutableField(list, default_items, **kwargs)\n\n\n<DED>def dict_field(default_items: Union[Dict[K, V], Iterable[Tuple[K, V]]] = None, **kwargs) -> Dict[K, V]:\n    <IND>\"\"\"shorthand function for setting a `dict` attribute on a dataclass,\n    so that every instance of the dataclass doesn't share the same `dict`.\n\n    Accepts any of the arguments of the `dataclasses.field` function.\n\n    Returns:\n        Dict[K, V]: a `dataclasses.Field` of type `Dict[K, V]`, containing the `default_items`. \n    \"\"\"\n    if default_items is None:\n        <IND>default_items = []\n    <DED>elif isinstance(default_items, dict):\n        <IND>default_items = default_items.items()\n    <DED>return MutableField(dict, default_items, **kwargs)\n\n\n<DED>def set_field(*default_items: T, **kwargs) -> Set[T]:\n    <IND>return MutableField(set, default_items, **kwargs)\n\n\n<DED>def MutableField(_type: Type[T], *args, init: bool = True, repr: bool = True, hash: bool = None, compare: bool = True, metadata: Dict[str, Any] = None, **kwargs) -> T:\n    <IND>return field(default_factory=partial(_type, *args, **kwargs), init=init, repr=repr, hash=hash, compare=compare, metadata=metadata)\n\n\n<DED>def subparsers(subcommands: Dict[str, Type], default=None) -> Any:\n    <IND>if default is not None and default not in subcommands:\n        <IND>raise ValueError(\n            f\"Default value of {default} is not a valid subparser! (subcommand: {subcommands})\")\n    <DED>return field(default=default, metadata={\n        \"subparsers\": subcommands,\n        \"default\": default,\n    })\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "lebrice/SimpleParsing",
    "commit": "f6063a6a6325f5bf711db90492203b0a07a39a0d",
    "filename": "simple_parsing/utils.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/lebrice-SimpleParsing/simple_parsing/utils.py",
    "file_hunks_size": 7,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": true,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "simple_parsing/utils.py:181:119 Incompatible variable type [9]: metadata is declared to have type `typing.Dict[str, typing.Any]` but is used as type `None`.",
    "message": " metadata is declared to have type `typing.Dict[str, typing.Any]` but is used as type `None`.",
    "rule_id": "Incompatible variable type [9]",
    "warning_line_no": 181,
    "warning_line": "def MutableField(_type: Type[T], *args, init: bool = True, repr: bool = True, hash: bool = None, compare: bool = True, metadata: Dict[str, Any] = None, **kwargs) -> T:",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": true,
        "has_suppression": false,
        "source_code": "\ndef foo(a: int = 123, b: str = None) -> float:\n    \"\"\"[summary]\n\n    [extended_summary]\n\n    Parameters\n    ----------\n    - a : int, optional\n        [description], by default 123\n    - b : str, optional\n        [description], by default None\n\n    Returns\n    -------\n    float\n        [description]\n    \"\"\"\n\n\ndef field(*,\n          alias: Union[str, List[str]] = None,\n          default: Union[T, _MISSING_TYPE] = MISSING,\n          default_factory: Union[Callable[[], T], _MISSING_TYPE] = MISSING,\n          init: bool = True,\n          repr: bool = True,\n          hash: bool = None,\n          compare: bool = True,\n          metadata: Dict[str, Any] = None,\n          **custom_argparse_args) -> T:\n    \"\"\"Calls the `dataclasses.field` function, and leftover arguments are fed\n    directly to the `ArgumentParser.add_argument(*option_strings, **kwargs)`\n    method.\n\n    Parameters\n    ----------\n    alias : List[str], optional\n        Additional option_strings to pass to the `add_argument` method, by\n        default None\n    default : Union[T, _MISSING_TYPE], optional\n        The default field value (same as in `dataclasses.field`), by default MISSING\n    default_factory : Union[Callable[[], T], _MISSING_TYPE], optional\n        (same as in `dataclasses.field`), by default None\n    init : bool, optional\n        (same as in `dataclasses.field`), by default True\n    repr : bool, optional\n        (same as in `dataclasses.field`), by default True\n    hash : bool, optional\n        (same as in `dataclasses.field`), by default None\n    compare : bool, optional\n        (same as in `dataclasses.field`), by default True\n    metadata : Dict[str, Any], optional\n        (same as in `dataclasses.field`), by default None\n\n    Returns\n    -------\n    T\n        The value returned by the `dataclasses.field` function.\n    \"\"\"\n    _metadata: Dict[str, Any] = metadata if metadata is not None else {}\n    if alias:\n        _metadata.update({\n            \"alias\": alias if isinstance(alias, list) else [alias]\n        })\n    if custom_argparse_args:\n        _metadata.update({\"custom_args\": custom_argparse_args})\n\n    if default is not MISSING:\n        return dataclasses.field(  # type: ignore\n            default=default,\n            init=init,\n            repr=repr,\n            hash=hash,\n            compare=compare,\n            metadata=_metadata\n        )\n    else:\n        return dataclasses.field(  # type: ignore\n            default_factory=default_factory,\n            init=init,\n            repr=repr,\n            hash=hash,\n            compare=compare,\n            metadata=_metadata\n        )\n\n\ndef choice(*choices: T, default: T = None, **kwargs) -> T:\n    \"\"\" Makes a regular attribute, whose value, when parsed from the \n    command-line, can only be one contained in `choices`, with a default value \n    of `default`.\n\n    Returns a regular `dataclasses.field()`, but with metadata which indicates  \n    the allowed values.\n\n    Args:\n        default (T, optional): The default value of the field. Defaults to None,\n        in which case the command-line argument is required.\n\n    Raises:\n        ValueError: If the default value isn't part of the given choices.\n\n    Returns:\n        T: the result of the usual `dataclasses.field()` function (a dataclass field/attribute).\n    \"\"\"\n    if default is not None and default not in choices:\n        raise ValueError(\n            f\"Default value of {default} is not a valid option! (options: {choices})\")\n    return field(default=default, choices=choices, **kwargs)  # type: ignore\n\n\n@dataclass\nclass Bob:\n    a: str = choice(\"1\", \"2\", \"3\", default=\"1\")\n\n\ndef list_field(*default_items: SimpleValueType, **kwargs) -> List[T]:\n    \"\"\"shorthand function for setting a `list` attribute on a dataclass,\n    so that every instance of the dataclass doesn't share the same list.\n\n    Accepts any of the arguments of the `dataclasses.field` function.\n\n    Returns:\n        List[T]: a `dataclasses.field` of type `list`, containing the `default_items`. \n    \"\"\"\n    return MutableField(list, default_items, **kwargs)\n\n\ndef dict_field(default_items: Union[Dict[K, V], Iterable[Tuple[K, V]]] = None, **kwargs) -> Dict[K, V]:\n    \"\"\"shorthand function for setting a `dict` attribute on a dataclass,\n    so that every instance of the dataclass doesn't share the same `dict`.\n\n    Accepts any of the arguments of the `dataclasses.field` function.\n\n    Returns:\n        Dict[K, V]: a `dataclasses.Field` of type `Dict[K, V]`, containing the `default_items`. \n    \"\"\"\n    if default_items is None:\n        default_items = []\n    elif isinstance(default_items, dict):\n        default_items = default_items.items()\n    return MutableField(dict, default_items, **kwargs)\n\n\ndef set_field(*default_items: T, **kwargs) -> Set[T]:\n    return MutableField(set, default_items, **kwargs)\n\n\ndef MutableField(_type: Type[T], *args, init: bool = True, repr: bool = True, hash: bool = None, compare: bool = True, metadata: Dict[str, Any] = None, **kwargs) -> T:\n    return field(default_factory=partial(_type, *args, **kwargs), init=init, repr=repr, hash=hash, compare=compare, metadata=metadata)\n\n\ndef subparsers(subcommands: Dict[str, Type], default=None) -> Any:\n    if default is not None and default not in subcommands:\n        raise ValueError(\n            f\"Default value of {default} is not a valid subparser! (subcommand: {subcommands})\")\n    return field(default=default, metadata={\n        \"subparsers\": subcommands,\n        \"default\": default,\n    })\n\n",
        "source_code_len": 5501,
        "target_code": "\n\n",
        "target_code_len": 2,
        "diff_format": "@@ -33,161 +36,2 @@\n \n-def foo(a: int = 123, b: str = None) -> float:\n-    \"\"\"[summary]\n-\n-    [extended_summary]\n-\n-    Parameters\n-    ----------\n-    - a : int, optional\n-        [description], by default 123\n-    - b : str, optional\n-        [description], by default None\n-\n-    Returns\n-    -------\n-    float\n-        [description]\n-    \"\"\"\n-\n-\n-def field(*,\n-          alias: Union[str, List[str]] = None,\n-          default: Union[T, _MISSING_TYPE] = MISSING,\n-          default_factory: Union[Callable[[], T], _MISSING_TYPE] = MISSING,\n-          init: bool = True,\n-          repr: bool = True,\n-          hash: bool = None,\n-          compare: bool = True,\n-          metadata: Dict[str, Any] = None,\n-          **custom_argparse_args) -> T:\n-    \"\"\"Calls the `dataclasses.field` function, and leftover arguments are fed\n-    directly to the `ArgumentParser.add_argument(*option_strings, **kwargs)`\n-    method.\n-\n-    Parameters\n-    ----------\n-    alias : List[str], optional\n-        Additional option_strings to pass to the `add_argument` method, by\n-        default None\n-    default : Union[T, _MISSING_TYPE], optional\n-        The default field value (same as in `dataclasses.field`), by default MISSING\n-    default_factory : Union[Callable[[], T], _MISSING_TYPE], optional\n-        (same as in `dataclasses.field`), by default None\n-    init : bool, optional\n-        (same as in `dataclasses.field`), by default True\n-    repr : bool, optional\n-        (same as in `dataclasses.field`), by default True\n-    hash : bool, optional\n-        (same as in `dataclasses.field`), by default None\n-    compare : bool, optional\n-        (same as in `dataclasses.field`), by default True\n-    metadata : Dict[str, Any], optional\n-        (same as in `dataclasses.field`), by default None\n-\n-    Returns\n-    -------\n-    T\n-        The value returned by the `dataclasses.field` function.\n-    \"\"\"\n-    _metadata: Dict[str, Any] = metadata if metadata is not None else {}\n-    if alias:\n-        _metadata.update({\n-            \"alias\": alias if isinstance(alias, list) else [alias]\n-        })\n-    if custom_argparse_args:\n-        _metadata.update({\"custom_args\": custom_argparse_args})\n-\n-    if default is not MISSING:\n-        return dataclasses.field(  # type: ignore\n-            default=default,\n-            init=init,\n-            repr=repr,\n-            hash=hash,\n-            compare=compare,\n-            metadata=_metadata\n-        )\n-    else:\n-        return dataclasses.field(  # type: ignore\n-            default_factory=default_factory,\n-            init=init,\n-            repr=repr,\n-            hash=hash,\n-            compare=compare,\n-            metadata=_metadata\n-        )\n-\n-\n-def choice(*choices: T, default: T = None, **kwargs) -> T:\n-    \"\"\" Makes a regular attribute, whose value, when parsed from the \n-    command-line, can only be one contained in `choices`, with a default value \n-    of `default`.\n-\n-    Returns a regular `dataclasses.field()`, but with metadata which indicates  \n-    the allowed values.\n-\n-    Args:\n-        default (T, optional): The default value of the field. Defaults to None,\n-        in which case the command-line argument is required.\n-\n-    Raises:\n-        ValueError: If the default value isn't part of the given choices.\n-\n-    Returns:\n-        T: the result of the usual `dataclasses.field()` function (a dataclass field/attribute).\n-    \"\"\"\n-    if default is not None and default not in choices:\n-        raise ValueError(\n-            f\"Default value of {default} is not a valid option! (options: {choices})\")\n-    return field(default=default, choices=choices, **kwargs)  # type: ignore\n-\n-\n-@dataclass\n-class Bob:\n-    a: str = choice(\"1\", \"2\", \"3\", default=\"1\")\n-\n-\n-def list_field(*default_items: SimpleValueType, **kwargs) -> List[T]:\n-    \"\"\"shorthand function for setting a `list` attribute on a dataclass,\n-    so that every instance of the dataclass doesn't share the same list.\n-\n-    Accepts any of the arguments of the `dataclasses.field` function.\n-\n-    Returns:\n-        List[T]: a `dataclasses.field` of type `list`, containing the `default_items`. \n-    \"\"\"\n-    return MutableField(list, default_items, **kwargs)\n-\n-\n-def dict_field(default_items: Union[Dict[K, V], Iterable[Tuple[K, V]]] = None, **kwargs) -> Dict[K, V]:\n-    \"\"\"shorthand function for setting a `dict` attribute on a dataclass,\n-    so that every instance of the dataclass doesn't share the same `dict`.\n-\n-    Accepts any of the arguments of the `dataclasses.field` function.\n-\n-    Returns:\n-        Dict[K, V]: a `dataclasses.Field` of type `Dict[K, V]`, containing the `default_items`. \n-    \"\"\"\n-    if default_items is None:\n-        default_items = []\n-    elif isinstance(default_items, dict):\n-        default_items = default_items.items()\n-    return MutableField(dict, default_items, **kwargs)\n-\n-\n-def set_field(*default_items: T, **kwargs) -> Set[T]:\n-    return MutableField(set, default_items, **kwargs)\n-\n-\n-def MutableField(_type: Type[T], *args, init: bool = True, repr: bool = True, hash: bool = None, compare: bool = True, metadata: Dict[str, Any] = None, **kwargs) -> T:\n-    return field(default_factory=partial(_type, *args, **kwargs), init=init, repr=repr, hash=hash, compare=compare, metadata=metadata)\n-\n-\n-def subparsers(subcommands: Dict[str, Type], default=None) -> Any:\n-    if default is not None and default not in subcommands:\n-        raise ValueError(\n-            f\"Default value of {default} is not a valid subparser! (subcommand: {subcommands})\")\n-    return field(default=default, metadata={\n-        \"subparsers\": subcommands,\n-        \"default\": default,\n-    })\n \n",
        "source_code_with_indent": "\ndef foo(a: int = 123, b: str = None) -> float:\n    <IND>\"\"\"[summary]\n\n    [extended_summary]\n\n    Parameters\n    ----------\n    - a : int, optional\n        [description], by default 123\n    - b : str, optional\n        [description], by default None\n\n    Returns\n    -------\n    float\n        [description]\n    \"\"\"\n\n\n<DED>def field(*,\n          alias: Union[str, List[str]] = None,\n          default: Union[T, _MISSING_TYPE] = MISSING,\n          default_factory: Union[Callable[[], T], _MISSING_TYPE] = MISSING,\n          init: bool = True,\n          repr: bool = True,\n          hash: bool = None,\n          compare: bool = True,\n          metadata: Dict[str, Any] = None,\n          **custom_argparse_args) -> T:\n    <IND>\"\"\"Calls the `dataclasses.field` function, and leftover arguments are fed\n    directly to the `ArgumentParser.add_argument(*option_strings, **kwargs)`\n    method.\n\n    Parameters\n    ----------\n    alias : List[str], optional\n        Additional option_strings to pass to the `add_argument` method, by\n        default None\n    default : Union[T, _MISSING_TYPE], optional\n        The default field value (same as in `dataclasses.field`), by default MISSING\n    default_factory : Union[Callable[[], T], _MISSING_TYPE], optional\n        (same as in `dataclasses.field`), by default None\n    init : bool, optional\n        (same as in `dataclasses.field`), by default True\n    repr : bool, optional\n        (same as in `dataclasses.field`), by default True\n    hash : bool, optional\n        (same as in `dataclasses.field`), by default None\n    compare : bool, optional\n        (same as in `dataclasses.field`), by default True\n    metadata : Dict[str, Any], optional\n        (same as in `dataclasses.field`), by default None\n\n    Returns\n    -------\n    T\n        The value returned by the `dataclasses.field` function.\n    \"\"\"\n    _metadata: Dict[str, Any] = metadata if metadata is not None else {}\n    if alias:\n        <IND>_metadata.update({\n            \"alias\": alias if isinstance(alias, list) else [alias]\n        })\n    <DED>if custom_argparse_args:\n        <IND>_metadata.update({\"custom_args\": custom_argparse_args})\n\n    <DED>if default is not MISSING:\n        <IND>return dataclasses.field(  # type: ignore\n            default=default,\n            init=init,\n            repr=repr,\n            hash=hash,\n            compare=compare,\n            metadata=_metadata\n        )\n    <DED>else:\n        <IND>return dataclasses.field(  # type: ignore\n            default_factory=default_factory,\n            init=init,\n            repr=repr,\n            hash=hash,\n            compare=compare,\n            metadata=_metadata\n        )\n\n\n<DED><DED>def choice(*choices: T, default: T = None, **kwargs) -> T:\n    <IND>\"\"\" Makes a regular attribute, whose value, when parsed from the \n    command-line, can only be one contained in `choices`, with a default value \n    of `default`.\n\n    Returns a regular `dataclasses.field()`, but with metadata which indicates  \n    the allowed values.\n\n    Args:\n        default (T, optional): The default value of the field. Defaults to None,\n        in which case the command-line argument is required.\n\n    Raises:\n        ValueError: If the default value isn't part of the given choices.\n\n    Returns:\n        T: the result of the usual `dataclasses.field()` function (a dataclass field/attribute).\n    \"\"\"\n    if default is not None and default not in choices:\n        <IND>raise ValueError(\n            f\"Default value of {default} is not a valid option! (options: {choices})\")\n    <DED>return field(default=default, choices=choices, **kwargs)  # type: ignore\n\n\n<DED>@dataclass\nclass Bob:\n    <IND>a: str = choice(\"1\", \"2\", \"3\", default=\"1\")\n\n\n<DED>def list_field(*default_items: SimpleValueType, **kwargs) -> List[T]:\n    <IND>\"\"\"shorthand function for setting a `list` attribute on a dataclass,\n    so that every instance of the dataclass doesn't share the same list.\n\n    Accepts any of the arguments of the `dataclasses.field` function.\n\n    Returns:\n        List[T]: a `dataclasses.field` of type `list`, containing the `default_items`. \n    \"\"\"\n    return MutableField(list, default_items, **kwargs)\n\n\n<DED>def dict_field(default_items: Union[Dict[K, V], Iterable[Tuple[K, V]]] = None, **kwargs) -> Dict[K, V]:\n    <IND>\"\"\"shorthand function for setting a `dict` attribute on a dataclass,\n    so that every instance of the dataclass doesn't share the same `dict`.\n\n    Accepts any of the arguments of the `dataclasses.field` function.\n\n    Returns:\n        Dict[K, V]: a `dataclasses.Field` of type `Dict[K, V]`, containing the `default_items`. \n    \"\"\"\n    if default_items is None:\n        <IND>default_items = []\n    <DED>elif isinstance(default_items, dict):\n        <IND>default_items = default_items.items()\n    <DED>return MutableField(dict, default_items, **kwargs)\n\n\n<DED>def set_field(*default_items: T, **kwargs) -> Set[T]:\n    <IND>return MutableField(set, default_items, **kwargs)\n\n\n<DED>def MutableField(_type: Type[T], *args, init: bool = True, repr: bool = True, hash: bool = None, compare: bool = True, metadata: Dict[str, Any] = None, **kwargs) -> T:\n    <IND>return field(default_factory=partial(_type, *args, **kwargs), init=init, repr=repr, hash=hash, compare=compare, metadata=metadata)\n\n\n<DED>def subparsers(subcommands: Dict[str, Type], default=None) -> Any:\n    <IND>if default is not None and default not in subcommands:\n        <IND>raise ValueError(\n            f\"Default value of {default} is not a valid subparser! (subcommand: {subcommands})\")\n    <DED>return field(default=default, metadata={\n        \"subparsers\": subcommands,\n        \"default\": default,\n    })\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  }
]