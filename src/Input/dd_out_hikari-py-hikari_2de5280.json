[
  {
    "project": "hikari-py/hikari",
    "commit": "2de5280a98c782c1d6d697fdd069b3925e32af46",
    "filename": "hikari/models/users.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/hikari-py-hikari/hikari/models/users.py",
    "file_hunks_size": 12,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "hikari/models/users.py:386:49 Incompatible parameter type [6]: Expected `typing.Union[_SupportsTrunc, bytes, str, typing.SupportsInt, typing_extensions.SupportsIndex]` for 1st positional only parameter to call `int.__new__` but got `typing.Union[str, undefined.UndefinedType]`.",
    "message": " Expected `typing.Union[_SupportsTrunc, bytes, str, typing.SupportsInt, typing_extensions.SupportsIndex]` for 1st positional only parameter to call `int.__new__` but got `typing.Union[str, undefined.UndefinedType]`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 386,
    "warning_line": "            constants.CDN_URL, discriminator=int(self.discriminator) % 5, file_format=\"png\",",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "@attr.s(eq=True, hash=True, init=True, kw_only=True, slots=True, weakref_slot=False)\nclass User(snowflake.Unique, abc.ABC):\n    \"\"\"Interface for any user-like object.\n\n    This does not include partial users, as they may not be fully formed.\n    \"\"\"\n",
        "source_code_len": 250,
        "target_code": "@attr.s(eq=True, hash=True, init=True, kw_only=True, slots=True, weakref_slot=False)\nclass PartialUser(snowflake.Unique, abc.ABC):\n    \"\"\"A partial interface for a user.\n\n    Fields may or may not be present, and must be checked explicitly if so.\n\n    This is pretty much the same as a normal user, but information may not be\n    present.\n    \"\"\"\n",
        "target_code_len": 347,
        "diff_format": "@@ -112,6 +112,9 @@\n @attr.s(eq=True, hash=True, init=True, kw_only=True, slots=True, weakref_slot=False)\n-class User(snowflake.Unique, abc.ABC):\n-    \"\"\"Interface for any user-like object.\n-\n-    This does not include partial users, as they may not be fully formed.\n+class PartialUser(snowflake.Unique, abc.ABC):\n+    \"\"\"A partial interface for a user.\n+\n+    Fields may or may not be present, and must be checked explicitly if so.\n+\n+    This is pretty much the same as a normal user, but information may not be\n+    present.\n     \"\"\"\n",
        "source_code_with_indent": "<DED><DED>@attr.s(eq=True, hash=True, init=True, kw_only=True, slots=True, weakref_slot=False)\nclass User(snowflake.Unique, abc.ABC):\n    <IND>\"\"\"Interface for any user-like object.\n\n    This does not include partial users, as they may not be fully formed.\n    \"\"\"\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "<DED><DED>@attr.s(eq=True, hash=True, init=True, kw_only=True, slots=True, weakref_slot=False)\nclass PartialUser(snowflake.Unique, abc.ABC):\n    <IND>\"\"\"A partial interface for a user.\n\n    Fields may or may not be present, and must be checked explicitly if so.\n\n    This is pretty much the same as a normal user, but information may not be\n    present.\n    \"\"\"\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n    @property\n    @abc.abstractmethod\n    def avatar(self) -> files.URL:\n        \"\"\"Avatar for the user, or the default avatar if not set.\"\"\"\n\n    # noinspection PyShadowingBuiltins\n    @abc.abstractmethod\n    def format_avatar(self, *, format: typing.Optional[str] = None, size: int = 4096) -> typing.Optional[files.URL]:\n",
        "source_code_len": 324,
        "target_code": "\n\n@attr.s(eq=True, hash=True, init=True, kw_only=True, slots=True, weakref_slot=False)\nclass User(PartialUser, abc.ABC):\n    \"\"\"Interface for any user-like object.\n\n    This does not include partial users, as they may not be fully formed.\n    \"\"\"\n\n    @property\n    @abc.abstractmethod\n    def app(self) -> rest_app.IRESTApp:\n        \"\"\"Client application that models may use for procedures.\"\"\"\n\n    @property\n    @abc.abstractmethod\n    def discriminator(self) -> str:\n        \"\"\"Discriminator for the user.\"\"\"\n\n    @property\n    @abc.abstractmethod\n    def username(self) -> str:\n        \"\"\"Username for the user.\"\"\"\n\n    @property\n    @abc.abstractmethod\n    def avatar_hash(self) -> typing.Optional[str]:\n        \"\"\"Avatar hash for the user, if they have one, otherwise `builtins.None`.\"\"\"\n\n    @property\n    @abc.abstractmethod\n    def is_bot(self) -> bool:\n        \"\"\"`builtins.True` if this user is a bot account, `builtins.False` otherwise.\"\"\"\n\n    @property\n    @abc.abstractmethod\n    def is_system(self) -> bool:\n        \"\"\"`builtins.True` if this user is a system account, `builtins.False` otherwise.\"\"\"\n\n    @property\n    @abc.abstractmethod\n    def flags(self) -> UserFlag:\n        \"\"\"Flag bits that are set for the user.\"\"\"\n\n    @property\n    @abc.abstractmethod\n    def mention(self) -> str:\n        \"\"\"Return a raw mention string for the given user.\n\n        Example\n        -------\n\n        ```py\n        >>> some_user.mention\n        '<@123456789123456789>'\n        ```\n\n        Returns\n        -------\n        builtins.str\n            The mention string to use.\n        \"\"\"\n\n    @property\n    def avatar(self) -> files.URL:\n        \"\"\"Avatar for the user, or the default avatar if not set.\"\"\"\n        return self.format_avatar() or self.default_avatar\n\n    # noinspection PyShadowingBuiltins\n    def format_avatar(self, *, format: typing.Optional[str] = None, size: int = 4096) -> typing.Optional[files.URL]:\n",
        "target_code_len": 1929,
        "diff_format": "@@ -172,9 +175,70 @@\n \n-    @property\n-    @abc.abstractmethod\n+\n+@attr.s(eq=True, hash=True, init=True, kw_only=True, slots=True, weakref_slot=False)\n+class User(PartialUser, abc.ABC):\n+    \"\"\"Interface for any user-like object.\n+\n+    This does not include partial users, as they may not be fully formed.\n+    \"\"\"\n+\n+    @property\n+    @abc.abstractmethod\n+    def app(self) -> rest_app.IRESTApp:\n+        \"\"\"Client application that models may use for procedures.\"\"\"\n+\n+    @property\n+    @abc.abstractmethod\n+    def discriminator(self) -> str:\n+        \"\"\"Discriminator for the user.\"\"\"\n+\n+    @property\n+    @abc.abstractmethod\n+    def username(self) -> str:\n+        \"\"\"Username for the user.\"\"\"\n+\n+    @property\n+    @abc.abstractmethod\n+    def avatar_hash(self) -> typing.Optional[str]:\n+        \"\"\"Avatar hash for the user, if they have one, otherwise `builtins.None`.\"\"\"\n+\n+    @property\n+    @abc.abstractmethod\n+    def is_bot(self) -> bool:\n+        \"\"\"`builtins.True` if this user is a bot account, `builtins.False` otherwise.\"\"\"\n+\n+    @property\n+    @abc.abstractmethod\n+    def is_system(self) -> bool:\n+        \"\"\"`builtins.True` if this user is a system account, `builtins.False` otherwise.\"\"\"\n+\n+    @property\n+    @abc.abstractmethod\n+    def flags(self) -> UserFlag:\n+        \"\"\"Flag bits that are set for the user.\"\"\"\n+\n+    @property\n+    @abc.abstractmethod\n+    def mention(self) -> str:\n+        \"\"\"Return a raw mention string for the given user.\n+\n+        Example\n+        -------\n+\n+        ```py\n+        >>> some_user.mention\n+        '<@123456789123456789>'\n+        ```\n+\n+        Returns\n+        -------\n+        builtins.str\n+            The mention string to use.\n+        \"\"\"\n+\n+    @property\n     def avatar(self) -> files.URL:\n         \"\"\"Avatar for the user, or the default avatar if not set.\"\"\"\n+        return self.format_avatar() or self.default_avatar\n \n     # noinspection PyShadowingBuiltins\n-    @abc.abstractmethod\n     def format_avatar(self, *, format: typing.Optional[str] = None, size: int = 4096) -> typing.Optional[files.URL]:\n",
        "source_code_with_indent": "\n    <DED>@property\n    @abc.abstractmethod\n    def avatar(self) -> files.URL:\n        <IND>\"\"\"Avatar for the user, or the default avatar if not set.\"\"\"\n\n    # noinspection PyShadowingBuiltins\n    <DED>@abc.abstractmethod\n    def format_avatar(self, *, format: typing.Optional[str] = None, size: int = 4096) -> typing.Optional[files.URL]:\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n\n<DED><DED>@attr.s(eq=True, hash=True, init=True, kw_only=True, slots=True, weakref_slot=False)\nclass User(PartialUser, abc.ABC):\n    <IND>\"\"\"Interface for any user-like object.\n\n    This does not include partial users, as they may not be fully formed.\n    \"\"\"\n\n    @property\n    @abc.abstractmethod\n    def app(self) -> rest_app.IRESTApp:\n        <IND>\"\"\"Client application that models may use for procedures.\"\"\"\n\n    <DED>@property\n    @abc.abstractmethod\n    def discriminator(self) -> str:\n        <IND>\"\"\"Discriminator for the user.\"\"\"\n\n    <DED>@property\n    @abc.abstractmethod\n    def username(self) -> str:\n        <IND>\"\"\"Username for the user.\"\"\"\n\n    <DED>@property\n    @abc.abstractmethod\n    def avatar_hash(self) -> typing.Optional[str]:\n        <IND>\"\"\"Avatar hash for the user, if they have one, otherwise `builtins.None`.\"\"\"\n\n    <DED>@property\n    @abc.abstractmethod\n    def is_bot(self) -> bool:\n        <IND>\"\"\"`builtins.True` if this user is a bot account, `builtins.False` otherwise.\"\"\"\n\n    <DED>@property\n    @abc.abstractmethod\n    def is_system(self) -> bool:\n        <IND>\"\"\"`builtins.True` if this user is a system account, `builtins.False` otherwise.\"\"\"\n\n    <DED>@property\n    @abc.abstractmethod\n    def flags(self) -> UserFlag:\n        <IND>\"\"\"Flag bits that are set for the user.\"\"\"\n\n    <DED>@property\n    @abc.abstractmethod\n    def mention(self) -> str:\n        <IND>\"\"\"Return a raw mention string for the given user.\n\n        Example\n        -------\n\n        ```py\n        >>> some_user.mention\n        '<@123456789123456789>'\n        ```\n\n        Returns\n        -------\n        builtins.str\n            The mention string to use.\n        \"\"\"\n\n    <DED>@property\n    def avatar(self) -> files.URL:\n        <IND>\"\"\"Avatar for the user, or the default avatar if not set.\"\"\"\n        return self.format_avatar() or self.default_avatar\n\n    # noinspection PyShadowingBuiltins\n    <DED>def format_avatar(self, *, format: typing.Optional[str] = None, size: int = 4096) -> typing.Optional[files.URL]:\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "            If `size` is not a power of two or not between 16 and 4096.\n        builtins.LookupError\n            If the avatar hash is not known. This will occur if `avatar_hash`\n            was not provided by Discord, and is\n            `hikari.utilities.undefined.UNDEFINED`.\n            This will only ever occur for `PartialUser` objects, regular\n            `User` objects should never be expected to raise this.\n        \"\"\"\n\n    @property\n    @abc.abstractmethod\n    def default_avatar(self) -> files.URL:  # noqa: D401 imperative mood check\n        \"\"\"Placeholder default avatar for the user if no avatar is set.\n\n        Raises\n        ------\n         builtins.LookupError\n            If the descriminator is not known. This will occur if\n            `discriminator` was not provided by Discord, and is\n            `hikari.utilities.undefined.UNDEFINED`.\n            This will only ever occur for `PartialUser` objects, regular\n            `User` objects should never be expected to raise this.\n        \"\"\"\n\n\n@attr_extensions.with_copy\n@attr.s(eq=True, hash=True, init=True, kw_only=True, slots=True, weakref_slot=False)\nclass PartialUser(snowflake.Unique):\n    \"\"\"Represents partial information about a user.\n\n    This is pretty much the same as a normal user, but information may not be\n    present.\n    \"\"\"\n\n    id: snowflake.Snowflake = attr.ib(eq=True, hash=True, repr=True)\n    \"\"\"The ID of this user.\"\"\"\n\n    app: rest_app.IRESTApp = attr.ib(repr=False, eq=False, hash=False, metadata={attr_extensions.SKIP_DEEP_COPY: True})\n    \"\"\"Reference to the client application that models may use for procedures.\"\"\"\n\n    discriminator: undefined.UndefinedOr[str] = attr.ib(eq=False, hash=False, repr=True)\n    \"\"\"Four-digit discriminator for the user.\"\"\"\n\n    username: undefined.UndefinedOr[str] = attr.ib(eq=False, hash=False, repr=True)\n    \"\"\"Username of the user.\"\"\"\n\n    avatar_hash: undefined.UndefinedNoneOr[str] = attr.ib(eq=False, hash=False, repr=False)\n    \"\"\"Avatar hash of the user, if a custom avatar is set.\"\"\"\n\n    is_bot: undefined.UndefinedOr[bool] = attr.ib(eq=False, hash=False, repr=True)\n    \"\"\"Whether this user is a bot account.\"\"\"\n\n    is_system: undefined.UndefinedOr[bool] = attr.ib(eq=False, hash=False, repr=False)\n    \"\"\"Whether this user is a system account.\"\"\"\n\n    flags: undefined.UndefinedOr[UserFlag] = attr.ib(eq=False, hash=False)\n    \"\"\"Public flags for this user.\"\"\"\n\n    @property\n    def mention(self) -> str:\n        \"\"\"Return a raw mention string for the given user.\n\n        Example\n        -------\n\n        ```py\n        >>> some_user.mention\n        '<@123456789123456789>'\n        ```\n\n        Returns\n        -------\n        builtins.str\n            The mention string to use.\n        \"\"\"\n        return f\"<@{self.id}>\"\n\n    def __str__(self) -> str:\n        if self.username is undefined.UNDEFINED or self.discriminator is undefined.UNDEFINED:\n            return f\"Partial user ID {self.id}\"\n        return f\"{self.username}#{self.discriminator}\"\n\n    async def fetch_self(self) -> User:\n        \"\"\"Get this user's up-to-date object.\n\n        Returns\n        -------\n        hikari.models.users.User\n            The requested user object.\n\n        Raises\n        ------\n        hikari.errors.NotFound\n            If the user is not found.\n        \"\"\"\n        return await self.app.rest.fetch_user(user=self.id)\n\n    @property\n    def avatar(self) -> files.URL:\n        \"\"\"Avatar for the user, or the default avatar if not set.\"\"\"\n        return self.format_avatar() or self.default_avatar\n\n    # noinspection PyShadowingBuiltins\n    def format_avatar(self, *, format: typing.Optional[str] = None, size: int = 4096) -> typing.Optional[files.URL]:\n        \"\"\"Generate the avatar for this user, if set.\n\n        If no custom avatar is set, this returns `builtins.None`. You can then\n        use the `default_avatar_url` attribute instead to fetch the displayed\n        URL.\n\n        Parameters\n        ----------\n        format : builtins.str or builtins.None\n            The format to use for this URL, defaults to `png` or `gif`.\n            Supports `png`, `jpeg`, `jpg`, `webp` and `gif` (when\n            animated). Will be ignored for default avatars which can only be\n            `png`.\n\n            If `builtins.None`, then the correct default format is determined\n            based on whether the icon is animated or not.\n        size : builtins.int\n            The size to set for the URL, defaults to `4096`.\n            Can be any power of two between 16 and 4096.\n            Will be ignored for default avatars.\n\n        Returns\n        -------\n        hikari.utilities.files.URL or builtins.None\n            The URL to the avatar, or `builtins.None` if not present.\n\n        Raises\n        ------\n        builtins.ValueError\n            If `size` is not a power of two or not between 16 and 4096.\n        builtins.LookupError\n            If the avatar hash is not known. This will occur if `avatar_hash`\n            was not provided by Discord, and is\n            `hikari.utilities.undefined.UNDEFINED`.\n            This will only ever occur for `PartialUser` objects, regular\n            `User` objects should never be expected to raise this.\n        \"\"\"\n        if self.avatar_hash is undefined.UNDEFINED:\n            raise LookupError(\"Unknown avatar hash for PartialUser\")\n\n        if self.avatar_hash is None:\n",
        "source_code_len": 5385,
        "target_code": "            If `size` is not a power of two or not between 16 and 4096.\n        \"\"\"\n        if self.avatar_hash is None:\n",
        "target_code_len": 121,
        "diff_format": "@@ -210,145 +274,3 @@\n             If `size` is not a power of two or not between 16 and 4096.\n-        builtins.LookupError\n-            If the avatar hash is not known. This will occur if `avatar_hash`\n-            was not provided by Discord, and is\n-            `hikari.utilities.undefined.UNDEFINED`.\n-            This will only ever occur for `PartialUser` objects, regular\n-            `User` objects should never be expected to raise this.\n-        \"\"\"\n-\n-    @property\n-    @abc.abstractmethod\n-    def default_avatar(self) -> files.URL:  # noqa: D401 imperative mood check\n-        \"\"\"Placeholder default avatar for the user if no avatar is set.\n-\n-        Raises\n-        ------\n-         builtins.LookupError\n-            If the descriminator is not known. This will occur if\n-            `discriminator` was not provided by Discord, and is\n-            `hikari.utilities.undefined.UNDEFINED`.\n-            This will only ever occur for `PartialUser` objects, regular\n-            `User` objects should never be expected to raise this.\n-        \"\"\"\n-\n-\n-@attr_extensions.with_copy\n-@attr.s(eq=True, hash=True, init=True, kw_only=True, slots=True, weakref_slot=False)\n-class PartialUser(snowflake.Unique):\n-    \"\"\"Represents partial information about a user.\n-\n-    This is pretty much the same as a normal user, but information may not be\n-    present.\n-    \"\"\"\n-\n-    id: snowflake.Snowflake = attr.ib(eq=True, hash=True, repr=True)\n-    \"\"\"The ID of this user.\"\"\"\n-\n-    app: rest_app.IRESTApp = attr.ib(repr=False, eq=False, hash=False, metadata={attr_extensions.SKIP_DEEP_COPY: True})\n-    \"\"\"Reference to the client application that models may use for procedures.\"\"\"\n-\n-    discriminator: undefined.UndefinedOr[str] = attr.ib(eq=False, hash=False, repr=True)\n-    \"\"\"Four-digit discriminator for the user.\"\"\"\n-\n-    username: undefined.UndefinedOr[str] = attr.ib(eq=False, hash=False, repr=True)\n-    \"\"\"Username of the user.\"\"\"\n-\n-    avatar_hash: undefined.UndefinedNoneOr[str] = attr.ib(eq=False, hash=False, repr=False)\n-    \"\"\"Avatar hash of the user, if a custom avatar is set.\"\"\"\n-\n-    is_bot: undefined.UndefinedOr[bool] = attr.ib(eq=False, hash=False, repr=True)\n-    \"\"\"Whether this user is a bot account.\"\"\"\n-\n-    is_system: undefined.UndefinedOr[bool] = attr.ib(eq=False, hash=False, repr=False)\n-    \"\"\"Whether this user is a system account.\"\"\"\n-\n-    flags: undefined.UndefinedOr[UserFlag] = attr.ib(eq=False, hash=False)\n-    \"\"\"Public flags for this user.\"\"\"\n-\n-    @property\n-    def mention(self) -> str:\n-        \"\"\"Return a raw mention string for the given user.\n-\n-        Example\n-        -------\n-\n-        ```py\n-        >>> some_user.mention\n-        '<@123456789123456789>'\n-        ```\n-\n-        Returns\n-        -------\n-        builtins.str\n-            The mention string to use.\n-        \"\"\"\n-        return f\"<@{self.id}>\"\n-\n-    def __str__(self) -> str:\n-        if self.username is undefined.UNDEFINED or self.discriminator is undefined.UNDEFINED:\n-            return f\"Partial user ID {self.id}\"\n-        return f\"{self.username}#{self.discriminator}\"\n-\n-    async def fetch_self(self) -> User:\n-        \"\"\"Get this user's up-to-date object.\n-\n-        Returns\n-        -------\n-        hikari.models.users.User\n-            The requested user object.\n-\n-        Raises\n-        ------\n-        hikari.errors.NotFound\n-            If the user is not found.\n-        \"\"\"\n-        return await self.app.rest.fetch_user(user=self.id)\n-\n-    @property\n-    def avatar(self) -> files.URL:\n-        \"\"\"Avatar for the user, or the default avatar if not set.\"\"\"\n-        return self.format_avatar() or self.default_avatar\n-\n-    # noinspection PyShadowingBuiltins\n-    def format_avatar(self, *, format: typing.Optional[str] = None, size: int = 4096) -> typing.Optional[files.URL]:\n-        \"\"\"Generate the avatar for this user, if set.\n-\n-        If no custom avatar is set, this returns `builtins.None`. You can then\n-        use the `default_avatar_url` attribute instead to fetch the displayed\n-        URL.\n-\n-        Parameters\n-        ----------\n-        format : builtins.str or builtins.None\n-            The format to use for this URL, defaults to `png` or `gif`.\n-            Supports `png`, `jpeg`, `jpg`, `webp` and `gif` (when\n-            animated). Will be ignored for default avatars which can only be\n-            `png`.\n-\n-            If `builtins.None`, then the correct default format is determined\n-            based on whether the icon is animated or not.\n-        size : builtins.int\n-            The size to set for the URL, defaults to `4096`.\n-            Can be any power of two between 16 and 4096.\n-            Will be ignored for default avatars.\n-\n-        Returns\n-        -------\n-        hikari.utilities.files.URL or builtins.None\n-            The URL to the avatar, or `builtins.None` if not present.\n-\n-        Raises\n-        ------\n-        builtins.ValueError\n-            If `size` is not a power of two or not between 16 and 4096.\n-        builtins.LookupError\n-            If the avatar hash is not known. This will occur if `avatar_hash`\n-            was not provided by Discord, and is\n-            `hikari.utilities.undefined.UNDEFINED`.\n-            This will only ever occur for `PartialUser` objects, regular\n-            `User` objects should never be expected to raise this.\n-        \"\"\"\n-        if self.avatar_hash is undefined.UNDEFINED:\n-            raise LookupError(\"Unknown avatar hash for PartialUser\")\n-\n+        \"\"\"\n         if self.avatar_hash is None:\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\n\n    <DED>@property\n    @abc.abstractmethod\n    def default_avatar(self) -> files.URL:  # noqa: D401 imperative mood check\n        <IND>\"\"\"Placeholder default avatar for the user if no avatar is set.\n\n        Raises\n        ------\n         builtins.LookupError\n            If the descriminator is not known. This will occur if\n            `discriminator` was not provided by Discord, and is\n            `hikari.utilities.undefined.UNDEFINED`.\n            This will only ever occur for `PartialUser` objects, regular\n            `User` objects should never be expected to raise this.\n        \"\"\"\n\n\n<DED><DED>@attr_extensions.with_copy\n@attr.s(eq=True, hash=True, init=True, kw_only=True, slots=True, weakref_slot=False)\nclass PartialUser(snowflake.Unique):\n    <IND>\"\"\"Represents partial information about a user.\n\n    This is pretty much the same as a normal user, but information may not be\n    present.\n    \"\"\"\n\n    id: snowflake.Snowflake = attr.ib(eq=True, hash=True, repr=True)\n    \"\"\"The ID of this user.\"\"\"\n\n    app: rest_app.IRESTApp = attr.ib(repr=False, eq=False, hash=False, metadata={attr_extensions.SKIP_DEEP_COPY: True})\n    \"\"\"Reference to the client application that models may use for procedures.\"\"\"\n\n    discriminator: undefined.UndefinedOr[str] = attr.ib(eq=False, hash=False, repr=True)\n    \"\"\"Four-digit discriminator for the user.\"\"\"\n\n    username: undefined.UndefinedOr[str] = attr.ib(eq=False, hash=False, repr=True)\n    \"\"\"Username of the user.\"\"\"\n\n    avatar_hash: undefined.UndefinedNoneOr[str] = attr.ib(eq=False, hash=False, repr=False)\n    \"\"\"Avatar hash of the user, if a custom avatar is set.\"\"\"\n\n    is_bot: undefined.UndefinedOr[bool] = attr.ib(eq=False, hash=False, repr=True)\n    \"\"\"Whether this user is a bot account.\"\"\"\n\n    is_system: undefined.UndefinedOr[bool] = attr.ib(eq=False, hash=False, repr=False)\n    \"\"\"Whether this user is a system account.\"\"\"\n\n    flags: undefined.UndefinedOr[UserFlag] = attr.ib(eq=False, hash=False)\n    \"\"\"Public flags for this user.\"\"\"\n\n    @property\n    def mention(self) -> str:\n        <IND>\"\"\"Return a raw mention string for the given user.\n\n        Example\n        -------\n\n        ```py\n        >>> some_user.mention\n        '<@123456789123456789>'\n        ```\n\n        Returns\n        -------\n        builtins.str\n            The mention string to use.\n        \"\"\"\n        return f\"<@{self.id}>\"\n\n    <DED>def __str__(self) -> str:\n        <IND>if self.username is undefined.UNDEFINED or self.discriminator is undefined.UNDEFINED:\n            <IND>return f\"Partial user ID {self.id}\"\n        <DED>return f\"{self.username}#{self.discriminator}\"\n\n    <DED>async def fetch_self(self) -> User:\n        <IND>\"\"\"Get this user's up-to-date object.\n\n        Returns\n        -------\n        hikari.models.users.User\n            The requested user object.\n\n        Raises\n        ------\n        hikari.errors.NotFound\n            If the user is not found.\n        \"\"\"\n        return await self.app.rest.fetch_user(user=self.id)\n\n    <DED>@property\n    def avatar(self) -> files.URL:\n        <IND>\"\"\"Avatar for the user, or the default avatar if not set.\"\"\"\n        return self.format_avatar() or self.default_avatar\n\n    # noinspection PyShadowingBuiltins\n    <DED>def format_avatar(self, *, format: typing.Optional[str] = None, size: int = 4096) -> typing.Optional[files.URL]:\n        <IND>\"\"\"Generate the avatar for this user, if set.\n\n        If no custom avatar is set, this returns `builtins.None`. You can then\n        use the `default_avatar_url` attribute instead to fetch the displayed\n        URL.\n\n        Parameters\n        ----------\n        format : builtins.str or builtins.None\n            The format to use for this URL, defaults to `png` or `gif`.\n            Supports `png`, `jpeg`, `jpg`, `webp` and `gif` (when\n            animated). Will be ignored for default avatars which can only be\n            `png`.\n\n            If `builtins.None`, then the correct default format is determined\n            based on whether the icon is animated or not.\n        size : builtins.int\n            The size to set for the URL, defaults to `4096`.\n            Can be any power of two between 16 and 4096.\n            Will be ignored for default avatars.\n\n        Returns\n        -------\n        hikari.utilities.files.URL or builtins.None\n            The URL to the avatar, or `builtins.None` if not present.\n\n        Raises\n        ------\n        builtins.ValueError\n            If `size` is not a power of two or not between 16 and 4096.\n        builtins.LookupError\n            If the avatar hash is not known. This will occur if `avatar_hash`\n            was not provided by Discord, and is\n            `hikari.utilities.undefined.UNDEFINED`.\n            This will only ever occur for `PartialUser` objects, regular\n            `User` objects should never be expected to raise this.\n        \"\"\"\n        if self.avatar_hash is undefined.UNDEFINED:\n            <IND>raise LookupError(\"Unknown avatar hash for PartialUser\")\n\n        <DED>if self.avatar_hash is None:\n",
        "target_code_with_indent": "\n        if self.avatar_hash is None:\n"
      }
    ]
  }
]