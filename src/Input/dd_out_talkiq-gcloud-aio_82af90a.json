[
  {
    "project": "talkiq/gcloud-aio",
    "commit": "82af90a9877490b01daff1af609a39a2525d2db2",
    "filename": "auth/gcloud/aio/auth/iam.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/talkiq-gcloud-aio/auth/gcloud/aio/auth/iam.py",
    "file_hunks_size": 9,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": true,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "auth/gcloud/aio/auth/iam.py:113:30 Incompatible parameter type [6]: Expected `Union[bytes, str]` for 1st positional only parameter to call `encode` but got `Union[None, bytes, str]`.",
    "message": " Expected `Union[bytes, str]` for 1st positional only parameter to call `encode` but got `Union[None, bytes, str]`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 113,
    "warning_line": "            'payload': encode(payload).decode('utf-8'),",
    "min_patch": [
      {
        "hunk_fit_TFix": true,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "            'delegates': delegates or [resource_name],\n            'payload': encode(payload).decode('utf-8'),\n        })\n",
        "source_code_len": 122,
        "target_code": "            'delegates': delegates or [resource_name],\n            'payload': encode(payload or '').decode('utf-8'),\n        })\n",
        "target_code_len": 128,
        "diff_format": "@@ -112,3 +116,3 @@\n             'delegates': delegates or [resource_name],\n-            'payload': encode(payload).decode('utf-8'),\n+            'payload': encode(payload or '').decode('utf-8'),\n         })\n",
        "source_code_with_indent": "            'delegates': delegates or [resource_name],\n            'payload': encode(payload).decode('utf-8'),\n        })\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "            'delegates': delegates or [resource_name],\n            'payload': encode(payload or '').decode('utf-8'),\n        })\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "talkiq/gcloud-aio",
    "commit": "82af90a9877490b01daff1af609a39a2525d2db2",
    "filename": "auth/gcloud/aio/auth/session.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/talkiq-gcloud-aio/auth/gcloud/aio/auth/session.py",
    "file_hunks_size": 16,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "auth/gcloud/aio/auth/session.py:100:23 Incompatible variable type [9]: data is declared to have type `str` but is used as type `None`.",
    "message": " data is declared to have type `str` but is used as type `None`.",
    "rule_id": "Incompatible variable type [9]",
    "warning_line_no": 100,
    "warning_line": "                       data: str = None, timeout: int = 10,"
  },
  {
    "project": "talkiq/gcloud-aio",
    "commit": "82af90a9877490b01daff1af609a39a2525d2db2",
    "filename": "auth/gcloud/aio/auth/session.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/talkiq-gcloud-aio/auth/gcloud/aio/auth/session.py",
    "file_hunks_size": 16,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "auth/gcloud/aio/auth/session.py:101:23 Incompatible variable type [9]: params is declared to have type `Dict[str, str]` but is used as type `None`.",
    "message": " params is declared to have type `Dict[str, str]` but is used as type `None`.",
    "rule_id": "Incompatible variable type [9]",
    "warning_line_no": 101,
    "warning_line": "                       params: Dict[str, str] = None"
  },
  {
    "project": "talkiq/gcloud-aio",
    "commit": "82af90a9877490b01daff1af609a39a2525d2db2",
    "filename": "auth/gcloud/aio/auth/session.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/talkiq-gcloud-aio/auth/gcloud/aio/auth/session.py",
    "file_hunks_size": 16,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "auth/gcloud/aio/auth/session.py:108:38 Incompatible variable type [9]: headers is declared to have type `Dict[str, str]` but is used as type `None`.",
    "message": " headers is declared to have type `Dict[str, str]` but is used as type `None`.",
    "rule_id": "Incompatible variable type [9]",
    "warning_line_no": 108,
    "warning_line": "        async def get(self, url: str, headers: Dict[str, str] = None,"
  },
  {
    "project": "talkiq/gcloud-aio",
    "commit": "82af90a9877490b01daff1af609a39a2525d2db2",
    "filename": "auth/gcloud/aio/auth/session.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/talkiq-gcloud-aio/auth/gcloud/aio/auth/session.py",
    "file_hunks_size": 16,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "auth/gcloud/aio/auth/session.py:109:41 Incompatible variable type [9]: params is declared to have type `Dict[str, str]` but is used as type `None`.",
    "message": " params is declared to have type `Dict[str, str]` but is used as type `None`.",
    "rule_id": "Incompatible variable type [9]",
    "warning_line_no": 109,
    "warning_line": "                      timeout: int = 10, params: Dict[str, str] = None"
  },
  {
    "project": "talkiq/gcloud-aio",
    "commit": "82af90a9877490b01daff1af609a39a2525d2db2",
    "filename": "auth/gcloud/aio/auth/session.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/talkiq-gcloud-aio/auth/gcloud/aio/auth/session.py",
    "file_hunks_size": 16,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "auth/gcloud/aio/auth/session.py:161:58 Incompatible variable type [9]: data is declared to have type `str` but is used as type `None`.",
    "message": " data is declared to have type `str` but is used as type `None`.",
    "rule_id": "Incompatible variable type [9]",
    "warning_line_no": 161,
    "warning_line": "        def post(self, url: str, headers: Dict[str, str], data: str = None,"
  },
  {
    "project": "talkiq/gcloud-aio",
    "commit": "82af90a9877490b01daff1af609a39a2525d2db2",
    "filename": "auth/gcloud/aio/auth/session.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/talkiq-gcloud-aio/auth/gcloud/aio/auth/session.py",
    "file_hunks_size": 16,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "auth/gcloud/aio/auth/session.py:162:36 Incompatible variable type [9]: params is declared to have type `Dict[str, str]` but is used as type `None`.",
    "message": " params is declared to have type `Dict[str, str]` but is used as type `None`.",
    "rule_id": "Incompatible variable type [9]",
    "warning_line_no": 162,
    "warning_line": "                 timeout: int = 10, params: Dict[str, str] = None"
  },
  {
    "project": "talkiq/gcloud-aio",
    "commit": "82af90a9877490b01daff1af609a39a2525d2db2",
    "filename": "auth/gcloud/aio/auth/session.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/talkiq-gcloud-aio/auth/gcloud/aio/auth/session.py",
    "file_hunks_size": 16,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "auth/gcloud/aio/auth/session.py:170:32 Incompatible variable type [9]: headers is declared to have type `Dict[str, str]` but is used as type `None`.",
    "message": " headers is declared to have type `Dict[str, str]` but is used as type `None`.",
    "rule_id": "Incompatible variable type [9]",
    "warning_line_no": 170,
    "warning_line": "        def get(self, url: str, headers: Dict[str, str] = None,"
  },
  {
    "project": "talkiq/gcloud-aio",
    "commit": "82af90a9877490b01daff1af609a39a2525d2db2",
    "filename": "auth/gcloud/aio/auth/session.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/talkiq-gcloud-aio/auth/gcloud/aio/auth/session.py",
    "file_hunks_size": 16,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "auth/gcloud/aio/auth/session.py:171:35 Incompatible variable type [9]: params is declared to have type `Dict[str, str]` but is used as type `None`.",
    "message": " params is declared to have type `Dict[str, str]` but is used as type `None`.",
    "rule_id": "Incompatible variable type [9]",
    "warning_line_no": 171,
    "warning_line": "                timeout: int = 10, params: Dict[str, str] = None"
  },
  {
    "project": "talkiq/gcloud-aio",
    "commit": "82af90a9877490b01daff1af609a39a2525d2db2",
    "filename": "auth/gcloud/aio/auth/session.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/talkiq-gcloud-aio/auth/gcloud/aio/auth/session.py",
    "file_hunks_size": 16,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "auth/gcloud/aio/auth/session.py:182:45 Incompatible parameter type [6]: Expected `typing.Union[None, typing.IO[typing.Any], typing.Iterable[typing.Tuple[str, typing.Optional[str]]], typing.Mapping[str, typing.Any], bytes, str]` for 2nd parameter `data` to call `requests.sessions.Session.put` but got `IOBase`.",
    "message": " Expected `typing.Union[None, typing.IO[typing.Any], typing.Iterable[typing.Tuple[str, typing.Optional[str]]], typing.Mapping[str, typing.Any], bytes, str]` for 2nd parameter `data` to call `requests.sessions.Session.put` but got `IOBase`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 182,
    "warning_line": "                resp = self.session.put(url, data=data, headers=headers,"
  },
  {
    "project": "talkiq/gcloud-aio",
    "commit": "82af90a9877490b01daff1af609a39a2525d2db2",
    "filename": "auth/gcloud/aio/auth/session.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/talkiq-gcloud-aio/auth/gcloud/aio/auth/session.py",
    "file_hunks_size": 16,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": true,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "auth/gcloud/aio/auth/session.py:206:8 Inconsistent override [15]: `auth.gcloud.aio.auth.session.SyncSession.close` overrides method defined in `BaseSession` inconsistently. Returned type `None` is not a subtype of the overridden return `typing.Coroutine[typing.Any, typing.Any, None]`.",
    "message": " `auth.gcloud.aio.auth.session.SyncSession.close` overrides method defined in `BaseSession` inconsistently. Returned type `None` is not a subtype of the overridden return `typing.Coroutine[typing.Any, typing.Any, None]`.",
    "rule_id": "Inconsistent override [15]",
    "warning_line_no": 206,
    "warning_line": "        def close(self) -> None:",
    "min_patch": [
      {
        "hunk_fit_TFix": true,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n        def close(self) -> None:\n            if self._session:\n",
        "source_code_len": 64,
        "target_code": "\n        async def close(self) -> None:\n            if self._session:\n",
        "target_code_len": 70,
        "diff_format": "@@ -205,3 +218,3 @@\n \n-        def close(self) -> None:\n+        async def close(self) -> None:\n             if self._session:\n",
        "source_code_with_indent": "\n        <DED>def close(self) -> None:\n            <IND>if self._session:\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n        <DED>async def close(self) -> None:\n            <IND>if self._session:\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "talkiq/gcloud-aio",
    "commit": "82af90a9877490b01daff1af609a39a2525d2db2",
    "filename": "auth/gcloud/aio/auth/token.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/talkiq-gcloud-aio/auth/gcloud/aio/auth/token.py",
    "file_hunks_size": 14,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "auth/gcloud/aio/auth/token.py:93:17 Incompatible variable type [9]: scopes is declared to have type `List[str]` but is used as type `None`.",
    "message": " scopes is declared to have type `List[str]` but is used as type `None`.",
    "rule_id": "Incompatible variable type [9]",
    "warning_line_no": 93,
    "warning_line": "                 scopes: List[str] = None) -> None:",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "from typing import Any\nfrom typing import Dict\nfrom typing import List\n",
        "source_code_len": 71,
        "target_code": "from typing import Any\nfrom typing import AnyStr\nfrom typing import Dict\nfrom typing import IO\nfrom typing import List\n",
        "target_code_len": 119,
        "diff_format": "@@ -10,3 +9,5 @@\n from typing import Any\n+from typing import AnyStr\n from typing import Dict\n+from typing import IO\n from typing import List\n",
        "source_code_with_indent": "from typing import Any\nfrom typing import Dict\nfrom typing import List\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "from typing import Any\nfrom typing import AnyStr\nfrom typing import Dict\nfrom typing import IO\nfrom typing import List\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "def get_service_data(\n        service: Optional[Union[str, io.IOBase]]) -> Dict[str, Any]:\n    service = service or os.environ.get('GOOGLE_APPLICATION_CREDENTIALS')\n",
        "source_code_len": 165,
        "target_code": "def get_service_data(\n        service: Optional[Union[str, IO[AnyStr]]]) -> Dict[str, Any]:\n    service = service or os.environ.get('GOOGLE_APPLICATION_CREDENTIALS')\n",
        "target_code_len": 166,
        "diff_format": "@@ -58,3 +62,3 @@\n def get_service_data(\n-        service: Optional[Union[str, io.IOBase]]) -> Dict[str, Any]:\n+        service: Optional[Union[str, IO[AnyStr]]]) -> Dict[str, Any]:\n     service = service or os.environ.get('GOOGLE_APPLICATION_CREDENTIALS')\n",
        "source_code_with_indent": "<DED>def get_service_data(\n        service: Optional[Union[str, io.IOBase]]) -> Dict[str, Any]:\n    <IND>service = service or os.environ.get('GOOGLE_APPLICATION_CREDENTIALS')\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "<DED>def get_service_data(\n        service: Optional[Union[str, IO[AnyStr]]]) -> Dict[str, Any]:\n    <IND>service = service or os.environ.get('GOOGLE_APPLICATION_CREDENTIALS')\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": true,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    # pylint: disable=too-many-instance-attributes\n    def __init__(self, service_file: Optional[Union[str, io.IOBase]] = None,\n                 session: Optional[Session] = None,\n                 scopes: List[str] = None) -> None:\n        self.service_data = get_service_data(service_file)\n",
        "source_code_len": 291,
        "target_code": "    # pylint: disable=too-many-instance-attributes\n    def __init__(self, service_file: Optional[Union[str, IO[AnyStr]]] = None,\n                 session: Optional[Session] = None,\n                 scopes: Optional[List[str]] = None) -> None:\n        self.service_data = get_service_data(service_file)\n",
        "target_code_len": 302,
        "diff_format": "@@ -90,5 +94,5 @@\n     # pylint: disable=too-many-instance-attributes\n-    def __init__(self, service_file: Optional[Union[str, io.IOBase]] = None,\n+    def __init__(self, service_file: Optional[Union[str, IO[AnyStr]]] = None,\n                  session: Optional[Session] = None,\n-                 scopes: List[str] = None) -> None:\n+                 scopes: Optional[List[str]] = None) -> None:\n         self.service_data = get_service_data(service_file)\n",
        "source_code_with_indent": "    # pylint: disable=too-many-instance-attributes\n    <IND>def __init__(self, service_file: Optional[Union[str, io.IOBase]] = None,\n                 session: Optional[Session] = None,\n                 scopes: List[str] = None) -> None:\n        <IND>self.service_data = get_service_data(service_file)\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    # pylint: disable=too-many-instance-attributes\n    <IND>def __init__(self, service_file: Optional[Union[str, IO[AnyStr]]] = None,\n                 session: Optional[Session] = None,\n                 scopes: Optional[List[str]] = None) -> None:\n        <IND>self.service_data = get_service_data(service_file)\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "talkiq/gcloud-aio",
    "commit": "82af90a9877490b01daff1af609a39a2525d2db2",
    "filename": "datastore/gcloud/aio/datastore/datastore.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/talkiq-gcloud-aio/datastore/gcloud/aio/datastore/datastore.py",
    "file_hunks_size": 15,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "datastore/gcloud/aio/datastore/datastore.py:111:22 Incompatible variable type [9]: properties is declared to have type `Dict[str, typing.Any]` but is used as type `None`.",
    "message": " properties is declared to have type `Dict[str, typing.Any]` but is used as type `None`.",
    "rule_id": "Incompatible variable type [9]",
    "warning_line_no": 111,
    "warning_line": "                      properties: Dict[str, Any] = None) -> Dict[str, Any]:"
  },
  {
    "project": "talkiq/gcloud-aio",
    "commit": "82af90a9877490b01daff1af609a39a2525d2db2",
    "filename": "datastore/gcloud/aio/datastore/datastore.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/talkiq-gcloud-aio/datastore/gcloud/aio/datastore/datastore.py",
    "file_hunks_size": 15,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "datastore/gcloud/aio/datastore/datastore.py:238:44 Incompatible variable type [9]: transaction is declared to have type `str` but is used as type `None`.",
    "message": " transaction is declared to have type `str` but is used as type `None`.",
    "rule_id": "Incompatible variable type [9]",
    "warning_line_no": 238,
    "warning_line": "    async def lookup(self, keys: List[Key], transaction: str = None,"
  },
  {
    "project": "talkiq/gcloud-aio",
    "commit": "82af90a9877490b01daff1af609a39a2525d2db2",
    "filename": "datastore/gcloud/aio/datastore/datastore.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/talkiq-gcloud-aio/datastore/gcloud/aio/datastore/datastore.py",
    "file_hunks_size": 15,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "datastore/gcloud/aio/datastore/datastore.py:316:47 Incompatible variable type [9]: transaction is declared to have type `str` but is used as type `None`.",
    "message": " transaction is declared to have type `str` but is used as type `None`.",
    "rule_id": "Incompatible variable type [9]",
    "warning_line_no": 316,
    "warning_line": "    async def runQuery(self, query: BaseQuery, transaction: str = None,"
  },
  {
    "project": "talkiq/gcloud-aio",
    "commit": "82af90a9877490b01daff1af609a39a2525d2db2",
    "filename": "datastore/gcloud/aio/datastore/datastore.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/talkiq-gcloud-aio/datastore/gcloud/aio/datastore/datastore.py",
    "file_hunks_size": 15,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "datastore/gcloud/aio/datastore/datastore.py:369:22 Incompatible variable type [9]: properties is declared to have type `Dict[str, typing.Any]` but is used as type `None`.",
    "message": " properties is declared to have type `Dict[str, typing.Any]` but is used as type `None`.",
    "rule_id": "Incompatible variable type [9]",
    "warning_line_no": 369,
    "warning_line": "                      properties: Dict[str, Any] = None,",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    @classmethod\n    def make_mutation(cls, operation: Operation, key: Key,\n                      properties: Dict[str, Any] = None) -> Dict[str, Any]:\n        if operation == Operation.DELETE:\n",
        "source_code_len": 194,
        "target_code": "    @classmethod\n    def make_mutation(\n            cls, operation: Operation, key: Key,\n            properties: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:\n        if operation == Operation.DELETE:\n",
        "target_code_len": 207,
        "diff_format": "@@ -109,4 +114,5 @@\n     @classmethod\n-    def make_mutation(cls, operation: Operation, key: Key,\n-                      properties: Dict[str, Any] = None) -> Dict[str, Any]:\n+    def make_mutation(\n+            cls, operation: Operation, key: Key,\n+            properties: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:\n         if operation == Operation.DELETE:\n",
        "source_code_with_indent": "    <DED>@classmethod\n    def make_mutation(cls, operation: Operation, key: Key,\n                      properties: Dict[str, Any] = None) -> Dict[str, Any]:\n        <IND>if operation == Operation.DELETE:\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    <DED>@classmethod\n    def make_mutation(\n            cls, operation: Operation, key: Key,\n            properties: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:\n        <IND>if operation == Operation.DELETE:\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "                'properties': {k: cls.value_kind(v).to_repr()\n                               for k, v in properties.items()},\n            }\n",
        "source_code_len": 140,
        "target_code": "                'properties': {k: cls.value_kind(v).to_repr()\n                               for k, v in (properties or {}).items()},\n            }\n",
        "target_code_len": 148,
        "diff_format": "@@ -118,3 +124,3 @@\n                 'properties': {k: cls.value_kind(v).to_repr()\n-                               for k, v in properties.items()},\n+                               for k, v in (properties or {}).items()},\n             }\n",
        "source_code_with_indent": "                'properties': {k: cls.value_kind(v).to_repr()\n                               for k, v in properties.items()},\n            }\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "                'properties': {k: cls.value_kind(v).to_repr()\n                               for k, v in (properties or {}).items()},\n            }\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": true,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    async def operate(self, operation: Operation, key: Key,\n                      properties: Dict[str, Any] = None,\n                      session: Optional[Session] = None) -> None:\n",
        "source_code_len": 183,
        "target_code": "    async def operate(self, operation: Operation, key: Key,\n                      properties: Optional[Dict[str, Any]] = None,\n                      session: Optional[Session] = None) -> None:\n",
        "target_code_len": 193,
        "diff_format": "@@ -368,3 +376,3 @@\n     async def operate(self, operation: Operation, key: Key,\n-                      properties: Dict[str, Any] = None,\n+                      properties: Optional[Dict[str, Any]] = None,\n                       session: Optional[Session] = None) -> None:\n",
        "source_code_with_indent": "    <DED>async def operate(self, operation: Operation, key: Key,\n                      properties: Dict[str, Any] = None,\n                      session: Optional[Session] = None) -> None:\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    <DED>async def operate(self, operation: Operation, key: Key,\n                      properties: Optional[Dict[str, Any]] = None,\n                      session: Optional[Session] = None) -> None:\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "talkiq/gcloud-aio",
    "commit": "82af90a9877490b01daff1af609a39a2525d2db2",
    "filename": "datastore/gcloud/aio/datastore/datastore_operation.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/talkiq-gcloud-aio/datastore/gcloud/aio/datastore/datastore_operation.py",
    "file_hunks_size": 1,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": true,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "datastore/gcloud/aio/datastore/datastore_operation.py:9:17 Incompatible variable type [9]: error is declared to have type `Dict[str, str]` but is used as type `None`.",
    "message": " error is declared to have type `Dict[str, str]` but is used as type `None`.",
    "rule_id": "Incompatible variable type [9]",
    "warning_line_no": 9,
    "warning_line": "                 error: Dict[str, str] = None,",
    "min_patch": [
      {
        "hunk_fit_TFix": true,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "                 metadata: Optional[Dict[str, Any]] = None,\n                 error: Dict[str, str] = None,\n                 response: Optional[Dict[str, Any]] = None) -> None:\n",
        "source_code_len": 176,
        "target_code": "                 metadata: Optional[Dict[str, Any]] = None,\n                 error: Optional[Dict[str, str]] = None,\n                 response: Optional[Dict[str, Any]] = None) -> None:\n",
        "target_code_len": 186,
        "diff_format": "@@ -8,3 +8,3 @@\n                  metadata: Optional[Dict[str, Any]] = None,\n-                 error: Dict[str, str] = None,\n+                 error: Optional[Dict[str, str]] = None,\n                  response: Optional[Dict[str, Any]] = None) -> None:\n",
        "source_code_with_indent": "                 metadata: Optional[Dict[str, Any]] = None,\n                 error: Dict[str, str] = None,\n                 response: Optional[Dict[str, Any]] = None) -> None:\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "                 metadata: Optional[Dict[str, Any]] = None,\n                 error: Optional[Dict[str, str]] = None,\n                 response: Optional[Dict[str, Any]] = None) -> None:\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "talkiq/gcloud-aio",
    "commit": "82af90a9877490b01daff1af609a39a2525d2db2",
    "filename": "datastore/gcloud/aio/datastore/entity.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/talkiq-gcloud-aio/datastore/gcloud/aio/datastore/entity.py",
    "file_hunks_size": 2,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "datastore/gcloud/aio/datastore/entity.py:13:33 Incompatible variable type [9]: properties is declared to have type `Dict[str, Dict[typing.Any, typing.Any]]` but is used as type `None`.",
    "message": " properties is declared to have type `Dict[str, Dict[typing.Any, typing.Any]]` but is used as type `None`.",
    "rule_id": "Incompatible variable type [9]",
    "warning_line_no": 13,
    "warning_line": "    def __init__(self, key: Key, properties: Dict[str, dict] = None) -> None:"
  },
  {
    "project": "talkiq/gcloud-aio",
    "commit": "82af90a9877490b01daff1af609a39a2525d2db2",
    "filename": "datastore/gcloud/aio/datastore/entity.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/talkiq-gcloud-aio/datastore/gcloud/aio/datastore/entity.py",
    "file_hunks_size": 2,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "datastore/gcloud/aio/datastore/entity.py:77:30 Incompatible parameter type [6]: Expected `Dict[str, typing.Any]` for 2nd positional only parameter to call `dict.__setitem__` but got `str`.",
    "message": " Expected `Dict[str, typing.Any]` for 2nd positional only parameter to call `dict.__setitem__` but got `str`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 77,
    "warning_line": "            data['version'] = self.version",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    def to_repr(self) -> Dict[str, Any]:\n        data = {\n            'entity': self.entity.to_repr(),\n",
        "source_code_len": 103,
        "target_code": "    def to_repr(self) -> Dict[str, Any]:\n        data: Dict[str, Any] = {\n            'entity': self.entity.to_repr(),\n",
        "target_code_len": 119,
        "diff_format": "@@ -72,3 +74,3 @@\n     def to_repr(self) -> Dict[str, Any]:\n-        data = {\n+        data: Dict[str, Any] = {\n             'entity': self.entity.to_repr(),\n",
        "source_code_with_indent": "    <DED>def to_repr(self) -> Dict[str, Any]:\n        <IND>data = {\n            'entity': self.entity.to_repr(),\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    <DED>def to_repr(self) -> Dict[str, Any]:\n        <IND>data: Dict[str, Any] = {\n            'entity': self.entity.to_repr(),\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "talkiq/gcloud-aio",
    "commit": "82af90a9877490b01daff1af609a39a2525d2db2",
    "filename": "datastore/gcloud/aio/datastore/entity.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/talkiq-gcloud-aio/datastore/gcloud/aio/datastore/entity.py",
    "file_hunks_size": 2,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "datastore/gcloud/aio/datastore/entity.py:79:29 Incompatible parameter type [6]: Expected `Dict[str, typing.Any]` for 2nd positional only parameter to call `dict.__setitem__` but got `str`.",
    "message": " Expected `Dict[str, typing.Any]` for 2nd positional only parameter to call `dict.__setitem__` but got `str`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 79,
    "warning_line": "            data['cursor'] = self.cursor",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    def to_repr(self) -> Dict[str, Any]:\n        data = {\n            'entity': self.entity.to_repr(),\n",
        "source_code_len": 103,
        "target_code": "    def to_repr(self) -> Dict[str, Any]:\n        data: Dict[str, Any] = {\n            'entity': self.entity.to_repr(),\n",
        "target_code_len": 119,
        "diff_format": "@@ -72,3 +74,3 @@\n     def to_repr(self) -> Dict[str, Any]:\n-        data = {\n+        data: Dict[str, Any] = {\n             'entity': self.entity.to_repr(),\n",
        "source_code_with_indent": "    <DED>def to_repr(self) -> Dict[str, Any]:\n        <IND>data = {\n            'entity': self.entity.to_repr(),\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    <DED>def to_repr(self) -> Dict[str, Any]:\n        <IND>data: Dict[str, Any] = {\n            'entity': self.entity.to_repr(),\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "talkiq/gcloud-aio",
    "commit": "82af90a9877490b01daff1af609a39a2525d2db2",
    "filename": "datastore/gcloud/aio/datastore/query.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/talkiq-gcloud-aio/datastore/gcloud/aio/datastore/query.py",
    "file_hunks_size": 4,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "datastore/gcloud/aio/datastore/query.py:40:17 Incompatible variable type [9]: distinct_on is declared to have type `List[str]` but is used as type `None`.",
    "message": " distinct_on is declared to have type `List[str]` but is used as type `None`.",
    "rule_id": "Incompatible variable type [9]",
    "warning_line_no": 40,
    "warning_line": "                 distinct_on: List[str] = None) -> None:",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n    def __init__(self, kind: str = '', query_filter: Filter = None,\n                 order: List[PropertyOrder] = None, start_cursor: str = '',\n                 end_cursor: str = '', offset: Optional[int] = None,\n                 limit: Optional[int] = None,\n                 projection: List[Projection] = None,\n                 distinct_on: List[str] = None) -> None:\n        self.kind = kind\n",
        "source_code_len": 396,
        "target_code": "\n    def __init__(self, kind: str = '', query_filter: Optional[Filter] = None,\n                 order: Optional[List[PropertyOrder]] = None,\n                 start_cursor: str = '', end_cursor: str = '',\n                 offset: Optional[int] = None, limit: Optional[int] = None,\n                 projection: Optional[List[Projection]] = None,\n                 distinct_on: Optional[List[str]] = None) -> None:\n        self.kind = kind\n",
        "target_code_len": 436,
        "diff_format": "@@ -34,8 +34,8 @@\n \n-    def __init__(self, kind: str = '', query_filter: Filter = None,\n-                 order: List[PropertyOrder] = None, start_cursor: str = '',\n-                 end_cursor: str = '', offset: Optional[int] = None,\n-                 limit: Optional[int] = None,\n-                 projection: List[Projection] = None,\n-                 distinct_on: List[str] = None) -> None:\n+    def __init__(self, kind: str = '', query_filter: Optional[Filter] = None,\n+                 order: Optional[List[PropertyOrder]] = None,\n+                 start_cursor: str = '', end_cursor: str = '',\n+                 offset: Optional[int] = None, limit: Optional[int] = None,\n+                 projection: Optional[List[Projection]] = None,\n+                 distinct_on: Optional[List[str]] = None) -> None:\n         self.kind = kind\n",
        "source_code_with_indent": "\n    def __init__(self, kind: str = '', query_filter: Filter = None,\n                 order: List[PropertyOrder] = None, start_cursor: str = '',\n                 end_cursor: str = '', offset: Optional[int] = None,\n                 limit: Optional[int] = None,\n                 projection: List[Projection] = None,\n                 distinct_on: List[str] = None) -> None:\n        <IND>self.kind = kind\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n    def __init__(self, kind: str = '', query_filter: Optional[Filter] = None,\n                 order: Optional[List[PropertyOrder]] = None,\n                 start_cursor: str = '', end_cursor: str = '',\n                 offset: Optional[int] = None, limit: Optional[int] = None,\n                 projection: Optional[List[Projection]] = None,\n                 distinct_on: Optional[List[str]] = None) -> None:\n        <IND>self.kind = kind\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "talkiq/gcloud-aio",
    "commit": "82af90a9877490b01daff1af609a39a2525d2db2",
    "filename": "datastore/gcloud/aio/datastore/query.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/talkiq-gcloud-aio/datastore/gcloud/aio/datastore/query.py",
    "file_hunks_size": 4,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "datastore/gcloud/aio/datastore/query.py:86:34 Incompatible parameter type [6]: Expected `typing.Union[List[typing.Any], List[Dict[str, str]]]` for 2nd positional only parameter to call `dict.__setitem__` but got `str`.",
    "message": " Expected `typing.Union[List[typing.Any], List[Dict[str, str]]]` for 2nd positional only parameter to call `dict.__setitem__` but got `str`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 86,
    "warning_line": "            data['startCursor'] = self.start_cursor",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    def to_repr(self) -> Dict[str, Any]:\n        data = {'kind': [{'name': self.kind}] if self.kind else []}\n        if self.query_filter:\n",
        "source_code_len": 139,
        "target_code": "    def to_repr(self) -> Dict[str, Any]:\n        data: Dict[str, Any] = {\n            'kind': [{'name': self.kind}] if self.kind else [],\n        }\n        if self.query_filter:\n",
        "target_code_len": 178,
        "diff_format": "@@ -79,3 +79,5 @@\n     def to_repr(self) -> Dict[str, Any]:\n-        data = {'kind': [{'name': self.kind}] if self.kind else []}\n+        data: Dict[str, Any] = {\n+            'kind': [{'name': self.kind}] if self.kind else [],\n+        }\n         if self.query_filter:\n",
        "source_code_with_indent": "    <DED>def to_repr(self) -> Dict[str, Any]:\n        <IND>data = {'kind': [{'name': self.kind}] if self.kind else []}\n        if self.query_filter:\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    <DED>def to_repr(self) -> Dict[str, Any]:\n        <IND>data: Dict[str, Any] = {\n            'kind': [{'name': self.kind}] if self.kind else [],\n        }\n        if self.query_filter:\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "talkiq/gcloud-aio",
    "commit": "82af90a9877490b01daff1af609a39a2525d2db2",
    "filename": "datastore/gcloud/aio/datastore/query.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/talkiq-gcloud-aio/datastore/gcloud/aio/datastore/query.py",
    "file_hunks_size": 4,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "datastore/gcloud/aio/datastore/query.py:88:32 Incompatible parameter type [6]: Expected `typing.Union[List[typing.Any], List[Dict[str, str]]]` for 2nd positional only parameter to call `dict.__setitem__` but got `str`.",
    "message": " Expected `typing.Union[List[typing.Any], List[Dict[str, str]]]` for 2nd positional only parameter to call `dict.__setitem__` but got `str`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 88,
    "warning_line": "            data['endCursor'] = self.end_cursor",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    def to_repr(self) -> Dict[str, Any]:\n        data = {'kind': [{'name': self.kind}] if self.kind else []}\n        if self.query_filter:\n",
        "source_code_len": 139,
        "target_code": "    def to_repr(self) -> Dict[str, Any]:\n        data: Dict[str, Any] = {\n            'kind': [{'name': self.kind}] if self.kind else [],\n        }\n        if self.query_filter:\n",
        "target_code_len": 178,
        "diff_format": "@@ -79,3 +79,5 @@\n     def to_repr(self) -> Dict[str, Any]:\n-        data = {'kind': [{'name': self.kind}] if self.kind else []}\n+        data: Dict[str, Any] = {\n+            'kind': [{'name': self.kind}] if self.kind else [],\n+        }\n         if self.query_filter:\n",
        "source_code_with_indent": "    <DED>def to_repr(self) -> Dict[str, Any]:\n        <IND>data = {'kind': [{'name': self.kind}] if self.kind else []}\n        if self.query_filter:\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    <DED>def to_repr(self) -> Dict[str, Any]:\n        <IND>data: Dict[str, Any] = {\n            'kind': [{'name': self.kind}] if self.kind else [],\n        }\n        if self.query_filter:\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "talkiq/gcloud-aio",
    "commit": "82af90a9877490b01daff1af609a39a2525d2db2",
    "filename": "datastore/gcloud/aio/datastore/query.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/talkiq-gcloud-aio/datastore/gcloud/aio/datastore/query.py",
    "file_hunks_size": 4,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "datastore/gcloud/aio/datastore/query.py:90:29 Incompatible parameter type [6]: Expected `typing.Union[List[typing.Any], List[Dict[str, str]]]` for 2nd positional only parameter to call `dict.__setitem__` but got `int`.",
    "message": " Expected `typing.Union[List[typing.Any], List[Dict[str, str]]]` for 2nd positional only parameter to call `dict.__setitem__` but got `int`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 90,
    "warning_line": "            data['offset'] = self.offset",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    def to_repr(self) -> Dict[str, Any]:\n        data = {'kind': [{'name': self.kind}] if self.kind else []}\n        if self.query_filter:\n",
        "source_code_len": 139,
        "target_code": "    def to_repr(self) -> Dict[str, Any]:\n        data: Dict[str, Any] = {\n            'kind': [{'name': self.kind}] if self.kind else [],\n        }\n        if self.query_filter:\n",
        "target_code_len": 178,
        "diff_format": "@@ -79,3 +79,5 @@\n     def to_repr(self) -> Dict[str, Any]:\n-        data = {'kind': [{'name': self.kind}] if self.kind else []}\n+        data: Dict[str, Any] = {\n+            'kind': [{'name': self.kind}] if self.kind else [],\n+        }\n         if self.query_filter:\n",
        "source_code_with_indent": "    <DED>def to_repr(self) -> Dict[str, Any]:\n        <IND>data = {'kind': [{'name': self.kind}] if self.kind else []}\n        if self.query_filter:\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    <DED>def to_repr(self) -> Dict[str, Any]:\n        <IND>data: Dict[str, Any] = {\n            'kind': [{'name': self.kind}] if self.kind else [],\n        }\n        if self.query_filter:\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "talkiq/gcloud-aio",
    "commit": "82af90a9877490b01daff1af609a39a2525d2db2",
    "filename": "datastore/gcloud/aio/datastore/query.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/talkiq-gcloud-aio/datastore/gcloud/aio/datastore/query.py",
    "file_hunks_size": 4,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "datastore/gcloud/aio/datastore/query.py:92:28 Incompatible parameter type [6]: Expected `typing.Union[List[typing.Any], List[Dict[str, str]]]` for 2nd positional only parameter to call `dict.__setitem__` but got `int`.",
    "message": " Expected `typing.Union[List[typing.Any], List[Dict[str, str]]]` for 2nd positional only parameter to call `dict.__setitem__` but got `int`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 92,
    "warning_line": "            data['limit'] = self.limit",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    def to_repr(self) -> Dict[str, Any]:\n        data = {'kind': [{'name': self.kind}] if self.kind else []}\n        if self.query_filter:\n",
        "source_code_len": 139,
        "target_code": "    def to_repr(self) -> Dict[str, Any]:\n        data: Dict[str, Any] = {\n            'kind': [{'name': self.kind}] if self.kind else [],\n        }\n        if self.query_filter:\n",
        "target_code_len": 178,
        "diff_format": "@@ -79,3 +79,5 @@\n     def to_repr(self) -> Dict[str, Any]:\n-        data = {'kind': [{'name': self.kind}] if self.kind else []}\n+        data: Dict[str, Any] = {\n+            'kind': [{'name': self.kind}] if self.kind else [],\n+        }\n         if self.query_filter:\n",
        "source_code_with_indent": "    <DED>def to_repr(self) -> Dict[str, Any]:\n        <IND>data = {'kind': [{'name': self.kind}] if self.kind else []}\n        if self.query_filter:\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    <DED>def to_repr(self) -> Dict[str, Any]:\n        <IND>data: Dict[str, Any] = {\n            'kind': [{'name': self.kind}] if self.kind else [],\n        }\n        if self.query_filter:\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "talkiq/gcloud-aio",
    "commit": "82af90a9877490b01daff1af609a39a2525d2db2",
    "filename": "datastore/gcloud/aio/datastore/query.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/talkiq-gcloud-aio/datastore/gcloud/aio/datastore/query.py",
    "file_hunks_size": 4,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": true,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "datastore/gcloud/aio/datastore/query.py:105:17 Incompatible variable type [9]: named_bindings is declared to have type `Dict[str, typing.Any]` but is used as type `None`.",
    "message": " named_bindings is declared to have type `Dict[str, typing.Any]` but is used as type `None`.",
    "rule_id": "Incompatible variable type [9]",
    "warning_line_no": 105,
    "warning_line": "                 named_bindings: Dict[str, Any] = None,",
    "min_patch": [
      {
        "hunk_fit_TFix": true,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    def __init__(self, query_string: str, allow_literals: bool = True,\n                 named_bindings: Dict[str, Any] = None,\n                 positional_bindings: List[Any] = None) -> None:\n        self.query_string = query_string\n",
        "source_code_len": 233,
        "target_code": "    def __init__(self, query_string: str, allow_literals: bool = True,\n                 named_bindings: Optional[Dict[str, Any]] = None,\n                 positional_bindings: Optional[List[Any]] = None) -> None:\n        self.query_string = query_string\n",
        "target_code_len": 253,
        "diff_format": "@@ -104,4 +106,4 @@\n     def __init__(self, query_string: str, allow_literals: bool = True,\n-                 named_bindings: Dict[str, Any] = None,\n-                 positional_bindings: List[Any] = None) -> None:\n+                 named_bindings: Optional[Dict[str, Any]] = None,\n+                 positional_bindings: Optional[List[Any]] = None) -> None:\n         self.query_string = query_string\n",
        "source_code_with_indent": "    def __init__(self, query_string: str, allow_literals: bool = True,\n                 named_bindings: Dict[str, Any] = None,\n                 positional_bindings: List[Any] = None) -> None:\n        <IND>self.query_string = query_string\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    def __init__(self, query_string: str, allow_literals: bool = True,\n                 named_bindings: Optional[Dict[str, Any]] = None,\n                 positional_bindings: Optional[List[Any]] = None) -> None:\n        <IND>self.query_string = query_string\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "talkiq/gcloud-aio",
    "commit": "82af90a9877490b01daff1af609a39a2525d2db2",
    "filename": "datastore/gcloud/aio/datastore/query.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/talkiq-gcloud-aio/datastore/gcloud/aio/datastore/query.py",
    "file_hunks_size": 4,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": true,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "datastore/gcloud/aio/datastore/query.py:106:17 Incompatible variable type [9]: positional_bindings is declared to have type `List[typing.Any]` but is used as type `None`.",
    "message": " positional_bindings is declared to have type `List[typing.Any]` but is used as type `None`.",
    "rule_id": "Incompatible variable type [9]",
    "warning_line_no": 106,
    "warning_line": "                 positional_bindings: List[Any] = None) -> None:",
    "min_patch": [
      {
        "hunk_fit_TFix": true,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    def __init__(self, query_string: str, allow_literals: bool = True,\n                 named_bindings: Dict[str, Any] = None,\n                 positional_bindings: List[Any] = None) -> None:\n        self.query_string = query_string\n",
        "source_code_len": 233,
        "target_code": "    def __init__(self, query_string: str, allow_literals: bool = True,\n                 named_bindings: Optional[Dict[str, Any]] = None,\n                 positional_bindings: Optional[List[Any]] = None) -> None:\n        self.query_string = query_string\n",
        "target_code_len": 253,
        "diff_format": "@@ -104,4 +106,4 @@\n     def __init__(self, query_string: str, allow_literals: bool = True,\n-                 named_bindings: Dict[str, Any] = None,\n-                 positional_bindings: List[Any] = None) -> None:\n+                 named_bindings: Optional[Dict[str, Any]] = None,\n+                 positional_bindings: Optional[List[Any]] = None) -> None:\n         self.query_string = query_string\n",
        "source_code_with_indent": "    def __init__(self, query_string: str, allow_literals: bool = True,\n                 named_bindings: Dict[str, Any] = None,\n                 positional_bindings: List[Any] = None) -> None:\n        <IND>self.query_string = query_string\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    def __init__(self, query_string: str, allow_literals: bool = True,\n                 named_bindings: Optional[Dict[str, Any]] = None,\n                 positional_bindings: Optional[List[Any]] = None) -> None:\n        <IND>self.query_string = query_string\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "talkiq/gcloud-aio",
    "commit": "82af90a9877490b01daff1af609a39a2525d2db2",
    "filename": "storage/gcloud/aio/storage/bucket.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/talkiq-gcloud-aio/storage/gcloud/aio/storage/bucket.py",
    "file_hunks_size": 6,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "storage/gcloud/aio/storage/bucket.py:67:33 Incompatible variable type [9]: params is declared to have type `typing.Dict[typing.Any, typing.Any]` but is used as type `None`.",
    "message": " params is declared to have type `typing.Dict[typing.Any, typing.Any]` but is used as type `None`.",
    "rule_id": "Incompatible variable type [9]",
    "warning_line_no": 67,
    "warning_line": "    async def get_metadata(self, params: dict = None,",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "import logging\nfrom typing import List\nfrom typing import Optional\n\n",
        "source_code_len": 68,
        "target_code": "import logging\nfrom typing import Any\nfrom typing import Dict\nfrom typing import List\nfrom typing import Optional\nfrom typing import TYPE_CHECKING\n\n",
        "target_code_len": 148,
        "diff_format": "@@ -1,4 +1,7 @@\n import logging\n+from typing import Any\n+from typing import Dict\n from typing import List\n from typing import Optional\n+from typing import TYPE_CHECKING\n \n",
        "source_code_with_indent": "import logging\nfrom typing import List\nfrom typing import Optional\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "import logging\nfrom typing import Any\nfrom typing import Dict\nfrom typing import List\nfrom typing import Optional\nfrom typing import TYPE_CHECKING\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n    async def get_metadata(self, params: dict = None,\n                           session: Optional[Session] = None) -> dict:\n        return await self.storage.get_bucket_metadata(self.name, params=params,\n",
        "source_code_len": 206,
        "target_code": "\n    async def get_metadata(\n            self, params: Optional[Dict[str, Any]] = None,\n            session: Optional[Session] = None\n    ) -> Dict[str, Any]:\n        return await self.storage.get_bucket_metadata(self.name, params=params,\n",
        "target_code_len": 239,
        "diff_format": "@@ -66,4 +73,6 @@\n \n-    async def get_metadata(self, params: dict = None,\n-                           session: Optional[Session] = None) -> dict:\n+    async def get_metadata(\n+            self, params: Optional[Dict[str, Any]] = None,\n+            session: Optional[Session] = None\n+    ) -> Dict[str, Any]:\n         return await self.storage.get_bucket_metadata(self.name, params=params,\n",
        "source_code_with_indent": "\n    <DED>async def get_metadata(self, params: dict = None,\n                           session: Optional[Session] = None) -> dict:\n        <IND>return await self.storage.get_bucket_metadata(self.name, params=params,\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n    <DED>async def get_metadata(\n            self, params: Optional[Dict[str, Any]] = None,\n            session: Optional[Session] = None\n    ) -> Dict[str, Any]:\n        <IND>return await self.storage.get_bucket_metadata(self.name, params=params,\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "talkiq/gcloud-aio",
    "commit": "82af90a9877490b01daff1af609a39a2525d2db2",
    "filename": "storage/gcloud/aio/storage/storage.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/talkiq-gcloud-aio/storage/gcloud/aio/storage/storage.py",
    "file_hunks_size": 30,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "storage/gcloud/aio/storage/storage.py:76:47 Incompatible variable type [9]: new_name is declared to have type `str` but is used as type `None`.",
    "message": " new_name is declared to have type `str` but is used as type `None`.",
    "rule_id": "Incompatible variable type [9]",
    "warning_line_no": 76,
    "warning_line": "                   destination_bucket: str, *, new_name: str = None,",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    async def copy(self, bucket: str, object_name: str,\n                   destination_bucket: str, *, new_name: str = None,\n                   headers: dict = None, params: dict = None,\n                   timeout: int = 10,\n                   session: Optional[Session] = None) -> bytes:\n\n",
        "source_code_len": 290,
        "target_code": "    async def copy(self, bucket: str, object_name: str,\n                   destination_bucket: str, *, new_name: Optional[str] = None,\n                   headers: Optional[Dict[str, str]] = None,\n                   params: Optional[Dict[str, str]] = None, timeout: int = 10,\n                   session: Optional[Session] = None) -> Dict[str, Any]:\n\n",
        "target_code_len": 349,
        "diff_format": "@@ -75,6 +78,6 @@\n     async def copy(self, bucket: str, object_name: str,\n-                   destination_bucket: str, *, new_name: str = None,\n-                   headers: dict = None, params: dict = None,\n-                   timeout: int = 10,\n-                   session: Optional[Session] = None) -> bytes:\n+                   destination_bucket: str, *, new_name: Optional[str] = None,\n+                   headers: Optional[Dict[str, str]] = None,\n+                   params: Optional[Dict[str, str]] = None, timeout: int = 10,\n+                   session: Optional[Session] = None) -> Dict[str, Any]:\n \n",
        "source_code_with_indent": "    <DED>async def copy(self, bucket: str, object_name: str,\n                   destination_bucket: str, *, new_name: str = None,\n                   headers: dict = None, params: dict = None,\n                   timeout: int = 10,\n                   session: Optional[Session] = None) -> bytes:\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    <DED>async def copy(self, bucket: str, object_name: str,\n                   destination_bucket: str, *, new_name: Optional[str] = None,\n                   headers: Optional[Dict[str, str]] = None,\n                   params: Optional[Dict[str, str]] = None, timeout: int = 10,\n                   session: Optional[Session] = None) -> Dict[str, Any]:\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "talkiq/gcloud-aio",
    "commit": "82af90a9877490b01daff1af609a39a2525d2db2",
    "filename": "storage/gcloud/aio/storage/storage.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/talkiq-gcloud-aio/storage/gcloud/aio/storage/storage.py",
    "file_hunks_size": 30,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "storage/gcloud/aio/storage/storage.py:77:19 Incompatible variable type [9]: headers is declared to have type `Dict[typing.Any, typing.Any]` but is used as type `None`.",
    "message": " headers is declared to have type `Dict[typing.Any, typing.Any]` but is used as type `None`.",
    "rule_id": "Incompatible variable type [9]",
    "warning_line_no": 77,
    "warning_line": "                   headers: dict = None, params: dict = None,",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    async def copy(self, bucket: str, object_name: str,\n                   destination_bucket: str, *, new_name: str = None,\n                   headers: dict = None, params: dict = None,\n                   timeout: int = 10,\n                   session: Optional[Session] = None) -> bytes:\n\n",
        "source_code_len": 290,
        "target_code": "    async def copy(self, bucket: str, object_name: str,\n                   destination_bucket: str, *, new_name: Optional[str] = None,\n                   headers: Optional[Dict[str, str]] = None,\n                   params: Optional[Dict[str, str]] = None, timeout: int = 10,\n                   session: Optional[Session] = None) -> Dict[str, Any]:\n\n",
        "target_code_len": 349,
        "diff_format": "@@ -75,6 +78,6 @@\n     async def copy(self, bucket: str, object_name: str,\n-                   destination_bucket: str, *, new_name: str = None,\n-                   headers: dict = None, params: dict = None,\n-                   timeout: int = 10,\n-                   session: Optional[Session] = None) -> bytes:\n+                   destination_bucket: str, *, new_name: Optional[str] = None,\n+                   headers: Optional[Dict[str, str]] = None,\n+                   params: Optional[Dict[str, str]] = None, timeout: int = 10,\n+                   session: Optional[Session] = None) -> Dict[str, Any]:\n \n",
        "source_code_with_indent": "    <DED>async def copy(self, bucket: str, object_name: str,\n                   destination_bucket: str, *, new_name: str = None,\n                   headers: dict = None, params: dict = None,\n                   timeout: int = 10,\n                   session: Optional[Session] = None) -> bytes:\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    <DED>async def copy(self, bucket: str, object_name: str,\n                   destination_bucket: str, *, new_name: Optional[str] = None,\n                   headers: Optional[Dict[str, str]] = None,\n                   params: Optional[Dict[str, str]] = None, timeout: int = 10,\n                   session: Optional[Session] = None) -> Dict[str, Any]:\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "talkiq/gcloud-aio",
    "commit": "82af90a9877490b01daff1af609a39a2525d2db2",
    "filename": "storage/gcloud/aio/storage/storage.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/talkiq-gcloud-aio/storage/gcloud/aio/storage/storage.py",
    "file_hunks_size": 30,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "storage/gcloud/aio/storage/storage.py:77:41 Incompatible variable type [9]: params is declared to have type `Dict[typing.Any, typing.Any]` but is used as type `None`.",
    "message": " params is declared to have type `Dict[typing.Any, typing.Any]` but is used as type `None`.",
    "rule_id": "Incompatible variable type [9]",
    "warning_line_no": 77,
    "warning_line": "                   headers: dict = None, params: dict = None,",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    async def copy(self, bucket: str, object_name: str,\n                   destination_bucket: str, *, new_name: str = None,\n                   headers: dict = None, params: dict = None,\n                   timeout: int = 10,\n                   session: Optional[Session] = None) -> bytes:\n\n",
        "source_code_len": 290,
        "target_code": "    async def copy(self, bucket: str, object_name: str,\n                   destination_bucket: str, *, new_name: Optional[str] = None,\n                   headers: Optional[Dict[str, str]] = None,\n                   params: Optional[Dict[str, str]] = None, timeout: int = 10,\n                   session: Optional[Session] = None) -> Dict[str, Any]:\n\n",
        "target_code_len": 349,
        "diff_format": "@@ -75,6 +78,6 @@\n     async def copy(self, bucket: str, object_name: str,\n-                   destination_bucket: str, *, new_name: str = None,\n-                   headers: dict = None, params: dict = None,\n-                   timeout: int = 10,\n-                   session: Optional[Session] = None) -> bytes:\n+                   destination_bucket: str, *, new_name: Optional[str] = None,\n+                   headers: Optional[Dict[str, str]] = None,\n+                   params: Optional[Dict[str, str]] = None, timeout: int = 10,\n+                   session: Optional[Session] = None) -> Dict[str, Any]:\n \n",
        "source_code_with_indent": "    <DED>async def copy(self, bucket: str, object_name: str,\n                   destination_bucket: str, *, new_name: str = None,\n                   headers: dict = None, params: dict = None,\n                   timeout: int = 10,\n                   session: Optional[Session] = None) -> bytes:\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    <DED>async def copy(self, bucket: str, object_name: str,\n                   destination_bucket: str, *, new_name: Optional[str] = None,\n                   headers: Optional[Dict[str, str]] = None,\n                   params: Optional[Dict[str, str]] = None, timeout: int = 10,\n                   session: Optional[Session] = None) -> Dict[str, Any]:\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "talkiq/gcloud-aio",
    "commit": "82af90a9877490b01daff1af609a39a2525d2db2",
    "filename": "storage/gcloud/aio/storage/storage.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/talkiq-gcloud-aio/storage/gcloud/aio/storage/storage.py",
    "file_hunks_size": 30,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": true,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "storage/gcloud/aio/storage/storage.py:133:21 Incompatible variable type [9]: params is declared to have type `Dict[typing.Any, typing.Any]` but is used as type `None`.",
    "message": " params is declared to have type `Dict[typing.Any, typing.Any]` but is used as type `None`.",
    "rule_id": "Incompatible variable type [9]",
    "warning_line_no": 133,
    "warning_line": "                     params: dict = None, timeout: int = 10,",
    "min_patch": [
      {
        "hunk_fit_TFix": true,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n    async def delete(self, bucket: str, object_name: str, *,\n                     params: dict = None, timeout: int = 10,\n                     session: Optional[Session] = None) -> str:\n",
        "source_code_len": 187,
        "target_code": "\n    async def delete(self, bucket: str, object_name: str, *, timeout: int = 10,\n                     params: Optional[Dict[str, str]] = None,\n                     session: Optional[Session] = None) -> str:\n",
        "target_code_len": 207,
        "diff_format": "@@ -131,4 +134,4 @@\n \n-    async def delete(self, bucket: str, object_name: str, *,\n-                     params: dict = None, timeout: int = 10,\n+    async def delete(self, bucket: str, object_name: str, *, timeout: int = 10,\n+                     params: Optional[Dict[str, str]] = None,\n                      session: Optional[Session] = None) -> str:\n",
        "source_code_with_indent": "\n    <DED>async def delete(self, bucket: str, object_name: str, *,\n                     params: dict = None, timeout: int = 10,\n                     session: Optional[Session] = None) -> str:\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n    <DED>async def delete(self, bucket: str, object_name: str, *, timeout: int = 10,\n                     params: Optional[Dict[str, str]] = None,\n                     session: Optional[Session] = None) -> str:\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "talkiq/gcloud-aio",
    "commit": "82af90a9877490b01daff1af609a39a2525d2db2",
    "filename": "storage/gcloud/aio/storage/storage.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/talkiq-gcloud-aio/storage/gcloud/aio/storage/storage.py",
    "file_hunks_size": 30,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "storage/gcloud/aio/storage/storage.py:162:59 Incompatible parameter type [6]: Expected `Optional[requests.sessions.Session]` for 3rd positional only parameter to call `Storage.download` but got `Dict[str, typing.Any]`.",
    "message": " Expected `Optional[requests.sessions.Session]` for 3rd positional only parameter to call `Storage.download` but got `Dict[str, typing.Any]`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 162,
    "warning_line": "                await self.download(bucket, object_name, **kwargs))",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "                                   filename: str,\n                                   **kwargs: Dict[str, Any]) -> None:\n        with open(filename, 'wb+') as file_object:\n",
        "source_code_len": 171,
        "target_code": "                                   filename: str,\n                                   **kwargs: Any) -> None:\n        with open(filename, 'wb+') as file_object:\n",
        "target_code_len": 160,
        "diff_format": "@@ -158,3 +161,3 @@\n                                    filename: str,\n-                                   **kwargs: Dict[str, Any]) -> None:\n+                                   **kwargs: Any) -> None:\n         with open(filename, 'wb+') as file_object:\n",
        "source_code_with_indent": "                                   filename: str,\n                                   **kwargs: Dict[str, Any]) -> None:\n        <IND>with open(filename, 'wb+') as file_object:\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "                                   filename: str,\n                                   **kwargs: Any) -> None:\n        <IND>with open(filename, 'wb+') as file_object:\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "talkiq/gcloud-aio",
    "commit": "82af90a9877490b01daff1af609a39a2525d2db2",
    "filename": "storage/gcloud/aio/storage/storage.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/talkiq-gcloud-aio/storage/gcloud/aio/storage/storage.py",
    "file_hunks_size": 30,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "storage/gcloud/aio/storage/storage.py:162:59 Incompatible parameter type [6]: Expected `int` for 3rd positional only parameter to call `Storage.download` but got `Dict[str, typing.Any]`.",
    "message": " Expected `int` for 3rd positional only parameter to call `Storage.download` but got `Dict[str, typing.Any]`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 162,
    "warning_line": "                await self.download(bucket, object_name, **kwargs))",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "                                   filename: str,\n                                   **kwargs: Dict[str, Any]) -> None:\n        with open(filename, 'wb+') as file_object:\n",
        "source_code_len": 171,
        "target_code": "                                   filename: str,\n                                   **kwargs: Any) -> None:\n        with open(filename, 'wb+') as file_object:\n",
        "target_code_len": 160,
        "diff_format": "@@ -158,3 +161,3 @@\n                                    filename: str,\n-                                   **kwargs: Dict[str, Any]) -> None:\n+                                   **kwargs: Any) -> None:\n         with open(filename, 'wb+') as file_object:\n",
        "source_code_with_indent": "                                   filename: str,\n                                   **kwargs: Dict[str, Any]) -> None:\n        <IND>with open(filename, 'wb+') as file_object:\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "                                   filename: str,\n                                   **kwargs: Any) -> None:\n        <IND>with open(filename, 'wb+') as file_object:\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "talkiq/gcloud-aio",
    "commit": "82af90a9877490b01daff1af609a39a2525d2db2",
    "filename": "storage/gcloud/aio/storage/storage.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/talkiq-gcloud-aio/storage/gcloud/aio/storage/storage.py",
    "file_hunks_size": 30,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "storage/gcloud/aio/storage/storage.py:173:49 Incompatible variable type [9]: params is declared to have type `Dict[typing.Any, typing.Any]` but is used as type `None`.",
    "message": " params is declared to have type `Dict[typing.Any, typing.Any]` but is used as type `None`.",
    "rule_id": "Incompatible variable type [9]",
    "warning_line_no": 173,
    "warning_line": "    async def list_objects(self, bucket: str, *, params: dict = None,",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    async def download_metadata(self, bucket: str, object_name: str, *,\n                                timeout: int = 10,\n                                session: Optional[Session] = None) -> dict:\n        data = await self._download(bucket, object_name, timeout=timeout,\n                                    session=session)\n        metadata: dict = json.loads(data.decode())\n        return metadata\n\n    async def list_objects(self, bucket: str, *, params: dict = None,\n                           session: Optional[Session] = None,\n                           timeout: int = 10) -> dict:\n        url = f'{API_ROOT}/{bucket}/o'\n",
        "source_code_len": 628,
        "target_code": "    async def download_metadata(self, bucket: str, object_name: str, *,\n                                session: Optional[Session] = None,\n                                timeout: int = 10) -> Dict[str, Any]:\n        data = await self._download(bucket, object_name, timeout=timeout,\n                                    session=session)\n        metadata: Dict[str, Any] = json.loads(data.decode())\n        return metadata\n\n    async def list_objects(self, bucket: str, *,\n                           params: Optional[Dict[str, str]] = None,\n                           session: Optional[Session] = None,\n                           timeout: int = 10) -> Dict[str, Any]:\n        url = f'{API_ROOT}/{bucket}/o'\n",
        "target_code_len": 705,
        "diff_format": "@@ -165,12 +168,13 @@\n     async def download_metadata(self, bucket: str, object_name: str, *,\n-                                timeout: int = 10,\n-                                session: Optional[Session] = None) -> dict:\n+                                session: Optional[Session] = None,\n+                                timeout: int = 10) -> Dict[str, Any]:\n         data = await self._download(bucket, object_name, timeout=timeout,\n                                     session=session)\n-        metadata: dict = json.loads(data.decode())\n+        metadata: Dict[str, Any] = json.loads(data.decode())\n         return metadata\n \n-    async def list_objects(self, bucket: str, *, params: dict = None,\n+    async def list_objects(self, bucket: str, *,\n+                           params: Optional[Dict[str, str]] = None,\n                            session: Optional[Session] = None,\n-                           timeout: int = 10) -> dict:\n+                           timeout: int = 10) -> Dict[str, Any]:\n         url = f'{API_ROOT}/{bucket}/o'\n",
        "source_code_with_indent": "    <DED><DED>async def download_metadata(self, bucket: str, object_name: str, *,\n                                timeout: int = 10,\n                                session: Optional[Session] = None) -> dict:\n        <IND>data = await self._download(bucket, object_name, timeout=timeout,\n                                    session=session)\n        metadata: dict = json.loads(data.decode())\n        return metadata\n\n    <DED>async def list_objects(self, bucket: str, *, params: dict = None,\n                           session: Optional[Session] = None,\n                           timeout: int = 10) -> dict:\n        <IND>url = f'{API_ROOT}/{bucket}/o'\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    <DED><DED>async def download_metadata(self, bucket: str, object_name: str, *,\n                                session: Optional[Session] = None,\n                                timeout: int = 10) -> Dict[str, Any]:\n        <IND>data = await self._download(bucket, object_name, timeout=timeout,\n                                    session=session)\n        metadata: Dict[str, Any] = json.loads(data.decode())\n        return metadata\n\n    <DED>async def list_objects(self, bucket: str, *,\n                           params: Optional[Dict[str, str]] = None,\n                           session: Optional[Session] = None,\n                           timeout: int = 10) -> Dict[str, Any]:\n        <IND>url = f'{API_ROOT}/{bucket}/o'\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "talkiq/gcloud-aio",
    "commit": "82af90a9877490b01daff1af609a39a2525d2db2",
    "filename": "storage/gcloud/aio/storage/storage.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/talkiq-gcloud-aio/storage/gcloud/aio/storage/storage.py",
    "file_hunks_size": 30,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "storage/gcloud/aio/storage/storage.py:189:24 Incompatible variable type [9]: content_type is declared to have type `str` but is used as type `None`.",
    "message": " content_type is declared to have type `str` but is used as type `None`.",
    "rule_id": "Incompatible variable type [9]",
    "warning_line_no": 189,
    "warning_line": "                     *, content_type: str = None, parameters: dict = None,",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "from typing import Any\nfrom typing import Dict\nfrom typing import Optional\n",
        "source_code_len": 75,
        "target_code": "from typing import Any\nfrom typing import AnyStr\nfrom typing import Dict\nfrom typing import IO\nfrom typing import Optional\n",
        "target_code_len": 123,
        "diff_format": "@@ -7,3 +7,5 @@\n from typing import Any\n+from typing import AnyStr\n from typing import Dict\n+from typing import IO\n from typing import Optional\n",
        "source_code_with_indent": "from typing import Any\nfrom typing import Dict\nfrom typing import Optional\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "from typing import Any\nfrom typing import AnyStr\nfrom typing import Dict\nfrom typing import IO\nfrom typing import Optional\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    async def upload(self, bucket: str, object_name: str, file_data: Any,\n                     *, content_type: str = None, parameters: dict = None,\n                     headers: dict = None, metadata: dict = None,\n                     session: Optional[Session] = None, timeout: int = 30,\n                     force_resumable_upload: bool = None) -> dict:\n        url = f'{API_ROOT_UPLOAD}/{bucket}/o'\n",
        "source_code_len": 403,
        "target_code": "    async def upload(self, bucket: str, object_name: str, file_data: Any,\n                     *, content_type: Optional[str] = None,\n                     parameters: Optional[Dict[str, str]] = None,\n                     headers: Optional[Dict[str, str]] = None,\n                     metadata: Optional[Dict[str, str]] = None,\n                     session: Optional[Session] = None,\n                     force_resumable_upload: Optional[bool] = None,\n                     timeout: int = 30) -> Dict[str, Any]:\n        url = f'{API_ROOT_UPLOAD}/{bucket}/o'\n",
        "target_code_len": 556,
        "diff_format": "@@ -188,6 +192,9 @@\n     async def upload(self, bucket: str, object_name: str, file_data: Any,\n-                     *, content_type: str = None, parameters: dict = None,\n-                     headers: dict = None, metadata: dict = None,\n-                     session: Optional[Session] = None, timeout: int = 30,\n-                     force_resumable_upload: bool = None) -> dict:\n+                     *, content_type: Optional[str] = None,\n+                     parameters: Optional[Dict[str, str]] = None,\n+                     headers: Optional[Dict[str, str]] = None,\n+                     metadata: Optional[Dict[str, str]] = None,\n+                     session: Optional[Session] = None,\n+                     force_resumable_upload: Optional[bool] = None,\n+                     timeout: int = 30) -> Dict[str, Any]:\n         url = f'{API_ROOT_UPLOAD}/{bucket}/o'\n",
        "source_code_with_indent": "    <DED>async def upload(self, bucket: str, object_name: str, file_data: Any,\n                     *, content_type: str = None, parameters: dict = None,\n                     headers: dict = None, metadata: dict = None,\n                     session: Optional[Session] = None, timeout: int = 30,\n                     force_resumable_upload: bool = None) -> dict:\n        <IND>url = f'{API_ROOT_UPLOAD}/{bucket}/o'\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    <DED>async def upload(self, bucket: str, object_name: str, file_data: Any,\n                     *, content_type: Optional[str] = None,\n                     parameters: Optional[Dict[str, str]] = None,\n                     headers: Optional[Dict[str, str]] = None,\n                     metadata: Optional[Dict[str, str]] = None,\n                     session: Optional[Session] = None,\n                     force_resumable_upload: Optional[bool] = None,\n                     timeout: int = 30) -> Dict[str, Any]:\n        <IND>url = f'{API_ROOT_UPLOAD}/{bucket}/o'\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "                                   filename: str,\n                                   **kwargs: Dict[str, Any]) -> dict:\n        with open(filename, 'rb') as file_object:\n",
        "source_code_len": 170,
        "target_code": "                                   filename: str,\n                                   **kwargs: Any) -> Dict[str, Any]:\n        with open(filename, 'rb') as file_object:\n",
        "target_code_len": 169,
        "diff_format": "@@ -235,3 +242,3 @@\n                                    filename: str,\n-                                   **kwargs: Dict[str, Any]) -> dict:\n+                                   **kwargs: Any) -> Dict[str, Any]:\n         with open(filename, 'rb') as file_object:\n",
        "source_code_with_indent": "                                   filename: str,\n                                   **kwargs: Dict[str, Any]) -> dict:\n        <IND>with open(filename, 'rb') as file_object:\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "                                   filename: str,\n                                   **kwargs: Any) -> Dict[str, Any]:\n        <IND>with open(filename, 'rb') as file_object:\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    @staticmethod\n    def _get_stream_len(stream: io.IOBase) -> int:\n        current = stream.tell()\n",
        "source_code_len": 101,
        "target_code": "    @staticmethod\n    def _get_stream_len(stream: IO[AnyStr]) -> int:\n        current = stream.tell()\n",
        "target_code_len": 102,
        "diff_format": "@@ -241,3 +248,3 @@\n     @staticmethod\n-    def _get_stream_len(stream: io.IOBase) -> int:\n+    def _get_stream_len(stream: IO[AnyStr]) -> int:\n         current = stream.tell()\n",
        "source_code_with_indent": "    <DED><DED>@staticmethod\n    def _get_stream_len(stream: io.IOBase) -> int:\n        <IND>current = stream.tell()\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    <DED><DED>@staticmethod\n    def _get_stream_len(stream: IO[AnyStr]) -> int:\n        <IND>current = stream.tell()\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    @staticmethod\n    def _preprocess_data(data: Any) -> io.IOBase:\n        if data is None:\n",
        "source_code_len": 93,
        "target_code": "    @staticmethod\n    def _preprocess_data(data: Any) -> IO[Any]:\n        if data is None:\n",
        "target_code_len": 91,
        "diff_format": "@@ -249,3 +256,3 @@\n     @staticmethod\n-    def _preprocess_data(data: Any) -> io.IOBase:\n+    def _preprocess_data(data: Any) -> IO[Any]:\n         if data is None:\n",
        "source_code_with_indent": "    <DED><DED>@staticmethod\n    def _preprocess_data(data: Any) -> io.IOBase:\n        <IND>if data is None:\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    <DED><DED>@staticmethod\n    def _preprocess_data(data: Any) -> IO[Any]:\n        <IND>if data is None:\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": true,
        "source_code": "        if isinstance(data, io.IOBase):\n            return data\n\n",
        "source_code_len": 65,
        "target_code": "        if isinstance(data, io.IOBase):\n            return data  # type: ignore[return-value]\n\n",
        "target_code_len": 95,
        "diff_format": "@@ -258,3 +265,3 @@\n         if isinstance(data, io.IOBase):\n-            return data\n+            return data  # type: ignore[return-value]\n \n",
        "source_code_with_indent": "        <DED>if isinstance(data, io.IOBase):\n            <IND>return data\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "        <DED>if isinstance(data, io.IOBase):\n            <IND>return data  # type: ignore[return-value]\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    async def _upload_simple(self, url: str, object_name: str,\n                             stream: io.IOBase, params: dict, headers: dict,\n                             *, session: Optional[Session] = None,\n                             timeout: int = 30) -> dict:\n        # https://cloud.google.com/storage/docs/json_api/v1/how-tos/simple-upload\n",
        "source_code_len": 346,
        "target_code": "    async def _upload_simple(self, url: str, object_name: str,\n                             stream: IO[AnyStr], params: Dict[str, str],\n                             headers: Dict[str, str], *,\n                             session: Optional[Session] = None,\n                             timeout: int = 30) -> Dict[str, Any]:\n        # https://cloud.google.com/storage/docs/json_api/v1/how-tos/simple-upload\n",
        "target_code_len": 406,
        "diff_format": "@@ -313,5 +321,6 @@\n     async def _upload_simple(self, url: str, object_name: str,\n-                             stream: io.IOBase, params: dict, headers: dict,\n-                             *, session: Optional[Session] = None,\n-                             timeout: int = 30) -> dict:\n+                             stream: IO[AnyStr], params: Dict[str, str],\n+                             headers: Dict[str, str], *,\n+                             session: Optional[Session] = None,\n+                             timeout: int = 30) -> Dict[str, Any]:\n         # https://cloud.google.com/storage/docs/json_api/v1/how-tos/simple-upload\n",
        "source_code_with_indent": "    <DED>async def _upload_simple(self, url: str, object_name: str,\n                             stream: io.IOBase, params: dict, headers: dict,\n                             *, session: Optional[Session] = None,\n                             timeout: int = 30) -> dict:\n        # https://cloud.google.com/storage/docs/json_api/v1/how-tos/simple-upload\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    <DED>async def _upload_simple(self, url: str, object_name: str,\n                             stream: IO[AnyStr], params: Dict[str, str],\n                             headers: Dict[str, str], *,\n                             session: Optional[Session] = None,\n                             timeout: int = 30) -> Dict[str, Any]:\n        # https://cloud.google.com/storage/docs/json_api/v1/how-tos/simple-upload\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    async def _upload_resumable(self, url: str, object_name: str,\n                                stream: io.IOBase, params: dict,\n                                headers: dict, *, metadata: dict = None,\n                                session: Optional[Session] = None,\n                                timeout: int = 30) -> dict:\n        # https://cloud.google.com/storage/docs/json_api/v1/how-tos/resumable-upload\n",
        "source_code_len": 416,
        "target_code": "    async def _upload_resumable(self, url: str, object_name: str,\n                                stream: IO[AnyStr], params: Dict[str, str],\n                                headers: Dict[str, str], *,\n                                metadata: Optional[Dict[str, Any]] = None,\n                                session: Optional[Session] = None,\n                                timeout: int = 30) -> Dict[str, Any]:\n        # https://cloud.google.com/storage/docs/json_api/v1/how-tos/resumable-upload\n",
        "target_code_len": 499,
        "diff_format": "@@ -329,6 +338,7 @@\n     async def _upload_resumable(self, url: str, object_name: str,\n-                                stream: io.IOBase, params: dict,\n-                                headers: dict, *, metadata: dict = None,\n+                                stream: IO[AnyStr], params: Dict[str, str],\n+                                headers: Dict[str, str], *,\n+                                metadata: Optional[Dict[str, Any]] = None,\n                                 session: Optional[Session] = None,\n-                                timeout: int = 30) -> dict:\n+                                timeout: int = 30) -> Dict[str, Any]:\n         # https://cloud.google.com/storage/docs/json_api/v1/how-tos/resumable-upload\n",
        "source_code_with_indent": "    <DED>async def _upload_resumable(self, url: str, object_name: str,\n                                stream: io.IOBase, params: dict,\n                                headers: dict, *, metadata: dict = None,\n                                session: Optional[Session] = None,\n                                timeout: int = 30) -> dict:\n        # https://cloud.google.com/storage/docs/json_api/v1/how-tos/resumable-upload\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    <DED>async def _upload_resumable(self, url: str, object_name: str,\n                                stream: IO[AnyStr], params: Dict[str, str],\n                                headers: Dict[str, str], *,\n                                metadata: Optional[Dict[str, Any]] = None,\n                                session: Optional[Session] = None,\n                                timeout: int = 30) -> Dict[str, Any]:\n        # https://cloud.google.com/storage/docs/json_api/v1/how-tos/resumable-upload\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "                                                  session=session)\n        data: dict = await self._do_upload(session_uri, stream,\n                                           headers=headers, session=session,\n                                           timeout=timeout)\n        return data\n\n    async def _initiate_upload(self, url: str, object_name: str, params: dict,\n                               headers: dict, *, metadata: dict = None,\n                               session: Optional[Session] = None) -> str:\n",
        "source_code_len": 514,
        "target_code": "                                                  session=session)\n        return await self._do_upload(session_uri, stream, headers=headers,\n                                     session=session, timeout=timeout)\n\n    async def _initiate_upload(self, url: str, object_name: str,\n                               params: Dict[str, str], headers: Dict[str, str],\n                               *, metadata: Optional[Dict[str, str]] = None,\n                               session: Optional[Session] = None) -> str:\n",
        "target_code_len": 510,
        "diff_format": "@@ -337,9 +347,8 @@\n                                                   session=session)\n-        data: dict = await self._do_upload(session_uri, stream,\n-                                           headers=headers, session=session,\n-                                           timeout=timeout)\n-        return data\n-\n-    async def _initiate_upload(self, url: str, object_name: str, params: dict,\n-                               headers: dict, *, metadata: dict = None,\n+        return await self._do_upload(session_uri, stream, headers=headers,\n+                                     session=session, timeout=timeout)\n+\n+    async def _initiate_upload(self, url: str, object_name: str,\n+                               params: Dict[str, str], headers: Dict[str, str],\n+                               *, metadata: Optional[Dict[str, str]] = None,\n                                session: Optional[Session] = None) -> str:\n",
        "source_code_with_indent": "                                                  session=session)\n        data: dict = await self._do_upload(session_uri, stream,\n                                           headers=headers, session=session,\n                                           timeout=timeout)\n        return data\n\n    <DED>async def _initiate_upload(self, url: str, object_name: str, params: dict,\n                               headers: dict, *, metadata: dict = None,\n                               session: Optional[Session] = None) -> str:\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "                                                  session=session)\n        return await self._do_upload(session_uri, stream, headers=headers,\n                                     session=session, timeout=timeout)\n\n    <DED>async def _initiate_upload(self, url: str, object_name: str,\n                               params: Dict[str, str], headers: Dict[str, str],\n                               *, metadata: Optional[Dict[str, str]] = None,\n                               session: Optional[Session] = None) -> str:\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "        metadict.update({'name': object_name})\n        metadata = json.dumps(metadict)\n\n",
        "source_code_len": 88,
        "target_code": "        metadict.update({'name': object_name})\n        metadata_ = json.dumps(metadict)\n\n",
        "target_code_len": 89,
        "diff_format": "@@ -349,3 +358,3 @@\n         metadict.update({'name': object_name})\n-        metadata = json.dumps(metadict)\n+        metadata_ = json.dumps(metadict)\n \n",
        "source_code_with_indent": "        metadict.update({'name': object_name})\n        metadata = json.dumps(metadict)\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "        metadict.update({'name': object_name})\n        metadata_ = json.dumps(metadict)\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "        post_headers.update({\n            'Content-Length': str(len(metadata)),\n            'Content-Type': 'application/json; charset=UTF-8',\n",
        "source_code_len": 143,
        "target_code": "        post_headers.update({\n            'Content-Length': str(len(metadata_)),\n            'Content-Type': 'application/json; charset=UTF-8',\n",
        "target_code_len": 144,
        "diff_format": "@@ -353,3 +362,3 @@\n         post_headers.update({\n-            'Content-Length': str(len(metadata)),\n+            'Content-Length': str(len(metadata_)),\n             'Content-Type': 'application/json; charset=UTF-8',\n",
        "source_code_with_indent": "        post_headers.update({\n            'Content-Length': str(len(metadata)),\n            'Content-Type': 'application/json; charset=UTF-8',\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "        post_headers.update({\n            'Content-Length': str(len(metadata_)),\n            'Content-Type': 'application/json; charset=UTF-8',\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n    async def _do_upload(self, session_uri: str, stream: io.IOBase,\n                         headers: dict, *, retries: int = 5,\n                         session: Optional[Session] = None,\n                         timeout: int = 30) -> dict:\n        s = AioSession(session) if session else self.session\n",
        "source_code_len": 304,
        "target_code": "\n    async def _do_upload(self, session_uri: str, stream: IO[AnyStr],\n                         headers: Dict[str, str], *, retries: int = 5,\n                         session: Optional[Session] = None,\n                         timeout: int = 30) -> Dict[str, Any]:\n        s = AioSession(session) if session else self.session\n",
        "target_code_len": 325,
        "diff_format": "@@ -365,6 +374,6 @@\n \n-    async def _do_upload(self, session_uri: str, stream: io.IOBase,\n-                         headers: dict, *, retries: int = 5,\n+    async def _do_upload(self, session_uri: str, stream: IO[AnyStr],\n+                         headers: Dict[str, str], *, retries: int = 5,\n                          session: Optional[Session] = None,\n-                         timeout: int = 30) -> dict:\n+                         timeout: int = 30) -> Dict[str, Any]:\n         s = AioSession(session) if session else self.session\n",
        "source_code_with_indent": "\n    <DED>async def _do_upload(self, session_uri: str, stream: io.IOBase,\n                         headers: dict, *, retries: int = 5,\n                         session: Optional[Session] = None,\n                         timeout: int = 30) -> dict:\n        <IND>s = AioSession(session) if session else self.session\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n    <DED>async def _do_upload(self, session_uri: str, stream: IO[AnyStr],\n                         headers: Dict[str, str], *, retries: int = 5,\n                         session: Optional[Session] = None,\n                         timeout: int = 30) -> Dict[str, Any]:\n        <IND>s = AioSession(session) if session else self.session\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "talkiq/gcloud-aio",
    "commit": "82af90a9877490b01daff1af609a39a2525d2db2",
    "filename": "storage/gcloud/aio/storage/storage.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/talkiq-gcloud-aio/storage/gcloud/aio/storage/storage.py",
    "file_hunks_size": 30,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "storage/gcloud/aio/storage/storage.py:189:50 Incompatible variable type [9]: parameters is declared to have type `Dict[typing.Any, typing.Any]` but is used as type `None`.",
    "message": " parameters is declared to have type `Dict[typing.Any, typing.Any]` but is used as type `None`.",
    "rule_id": "Incompatible variable type [9]",
    "warning_line_no": 189,
    "warning_line": "                     *, content_type: str = None, parameters: dict = None,",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "from typing import Any\nfrom typing import Dict\nfrom typing import Optional\n",
        "source_code_len": 75,
        "target_code": "from typing import Any\nfrom typing import AnyStr\nfrom typing import Dict\nfrom typing import IO\nfrom typing import Optional\n",
        "target_code_len": 123,
        "diff_format": "@@ -7,3 +7,5 @@\n from typing import Any\n+from typing import AnyStr\n from typing import Dict\n+from typing import IO\n from typing import Optional\n",
        "source_code_with_indent": "from typing import Any\nfrom typing import Dict\nfrom typing import Optional\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "from typing import Any\nfrom typing import AnyStr\nfrom typing import Dict\nfrom typing import IO\nfrom typing import Optional\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    async def upload(self, bucket: str, object_name: str, file_data: Any,\n                     *, content_type: str = None, parameters: dict = None,\n                     headers: dict = None, metadata: dict = None,\n                     session: Optional[Session] = None, timeout: int = 30,\n                     force_resumable_upload: bool = None) -> dict:\n        url = f'{API_ROOT_UPLOAD}/{bucket}/o'\n",
        "source_code_len": 403,
        "target_code": "    async def upload(self, bucket: str, object_name: str, file_data: Any,\n                     *, content_type: Optional[str] = None,\n                     parameters: Optional[Dict[str, str]] = None,\n                     headers: Optional[Dict[str, str]] = None,\n                     metadata: Optional[Dict[str, str]] = None,\n                     session: Optional[Session] = None,\n                     force_resumable_upload: Optional[bool] = None,\n                     timeout: int = 30) -> Dict[str, Any]:\n        url = f'{API_ROOT_UPLOAD}/{bucket}/o'\n",
        "target_code_len": 556,
        "diff_format": "@@ -188,6 +192,9 @@\n     async def upload(self, bucket: str, object_name: str, file_data: Any,\n-                     *, content_type: str = None, parameters: dict = None,\n-                     headers: dict = None, metadata: dict = None,\n-                     session: Optional[Session] = None, timeout: int = 30,\n-                     force_resumable_upload: bool = None) -> dict:\n+                     *, content_type: Optional[str] = None,\n+                     parameters: Optional[Dict[str, str]] = None,\n+                     headers: Optional[Dict[str, str]] = None,\n+                     metadata: Optional[Dict[str, str]] = None,\n+                     session: Optional[Session] = None,\n+                     force_resumable_upload: Optional[bool] = None,\n+                     timeout: int = 30) -> Dict[str, Any]:\n         url = f'{API_ROOT_UPLOAD}/{bucket}/o'\n",
        "source_code_with_indent": "    <DED>async def upload(self, bucket: str, object_name: str, file_data: Any,\n                     *, content_type: str = None, parameters: dict = None,\n                     headers: dict = None, metadata: dict = None,\n                     session: Optional[Session] = None, timeout: int = 30,\n                     force_resumable_upload: bool = None) -> dict:\n        <IND>url = f'{API_ROOT_UPLOAD}/{bucket}/o'\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    <DED>async def upload(self, bucket: str, object_name: str, file_data: Any,\n                     *, content_type: Optional[str] = None,\n                     parameters: Optional[Dict[str, str]] = None,\n                     headers: Optional[Dict[str, str]] = None,\n                     metadata: Optional[Dict[str, str]] = None,\n                     session: Optional[Session] = None,\n                     force_resumable_upload: Optional[bool] = None,\n                     timeout: int = 30) -> Dict[str, Any]:\n        <IND>url = f'{API_ROOT_UPLOAD}/{bucket}/o'\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "                                   filename: str,\n                                   **kwargs: Dict[str, Any]) -> dict:\n        with open(filename, 'rb') as file_object:\n",
        "source_code_len": 170,
        "target_code": "                                   filename: str,\n                                   **kwargs: Any) -> Dict[str, Any]:\n        with open(filename, 'rb') as file_object:\n",
        "target_code_len": 169,
        "diff_format": "@@ -235,3 +242,3 @@\n                                    filename: str,\n-                                   **kwargs: Dict[str, Any]) -> dict:\n+                                   **kwargs: Any) -> Dict[str, Any]:\n         with open(filename, 'rb') as file_object:\n",
        "source_code_with_indent": "                                   filename: str,\n                                   **kwargs: Dict[str, Any]) -> dict:\n        <IND>with open(filename, 'rb') as file_object:\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "                                   filename: str,\n                                   **kwargs: Any) -> Dict[str, Any]:\n        <IND>with open(filename, 'rb') as file_object:\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    @staticmethod\n    def _get_stream_len(stream: io.IOBase) -> int:\n        current = stream.tell()\n",
        "source_code_len": 101,
        "target_code": "    @staticmethod\n    def _get_stream_len(stream: IO[AnyStr]) -> int:\n        current = stream.tell()\n",
        "target_code_len": 102,
        "diff_format": "@@ -241,3 +248,3 @@\n     @staticmethod\n-    def _get_stream_len(stream: io.IOBase) -> int:\n+    def _get_stream_len(stream: IO[AnyStr]) -> int:\n         current = stream.tell()\n",
        "source_code_with_indent": "    <DED><DED>@staticmethod\n    def _get_stream_len(stream: io.IOBase) -> int:\n        <IND>current = stream.tell()\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    <DED><DED>@staticmethod\n    def _get_stream_len(stream: IO[AnyStr]) -> int:\n        <IND>current = stream.tell()\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    @staticmethod\n    def _preprocess_data(data: Any) -> io.IOBase:\n        if data is None:\n",
        "source_code_len": 93,
        "target_code": "    @staticmethod\n    def _preprocess_data(data: Any) -> IO[Any]:\n        if data is None:\n",
        "target_code_len": 91,
        "diff_format": "@@ -249,3 +256,3 @@\n     @staticmethod\n-    def _preprocess_data(data: Any) -> io.IOBase:\n+    def _preprocess_data(data: Any) -> IO[Any]:\n         if data is None:\n",
        "source_code_with_indent": "    <DED><DED>@staticmethod\n    def _preprocess_data(data: Any) -> io.IOBase:\n        <IND>if data is None:\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    <DED><DED>@staticmethod\n    def _preprocess_data(data: Any) -> IO[Any]:\n        <IND>if data is None:\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": true,
        "source_code": "        if isinstance(data, io.IOBase):\n            return data\n\n",
        "source_code_len": 65,
        "target_code": "        if isinstance(data, io.IOBase):\n            return data  # type: ignore[return-value]\n\n",
        "target_code_len": 95,
        "diff_format": "@@ -258,3 +265,3 @@\n         if isinstance(data, io.IOBase):\n-            return data\n+            return data  # type: ignore[return-value]\n \n",
        "source_code_with_indent": "        <DED>if isinstance(data, io.IOBase):\n            <IND>return data\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "        <DED>if isinstance(data, io.IOBase):\n            <IND>return data  # type: ignore[return-value]\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    async def _upload_simple(self, url: str, object_name: str,\n                             stream: io.IOBase, params: dict, headers: dict,\n                             *, session: Optional[Session] = None,\n                             timeout: int = 30) -> dict:\n        # https://cloud.google.com/storage/docs/json_api/v1/how-tos/simple-upload\n",
        "source_code_len": 346,
        "target_code": "    async def _upload_simple(self, url: str, object_name: str,\n                             stream: IO[AnyStr], params: Dict[str, str],\n                             headers: Dict[str, str], *,\n                             session: Optional[Session] = None,\n                             timeout: int = 30) -> Dict[str, Any]:\n        # https://cloud.google.com/storage/docs/json_api/v1/how-tos/simple-upload\n",
        "target_code_len": 406,
        "diff_format": "@@ -313,5 +321,6 @@\n     async def _upload_simple(self, url: str, object_name: str,\n-                             stream: io.IOBase, params: dict, headers: dict,\n-                             *, session: Optional[Session] = None,\n-                             timeout: int = 30) -> dict:\n+                             stream: IO[AnyStr], params: Dict[str, str],\n+                             headers: Dict[str, str], *,\n+                             session: Optional[Session] = None,\n+                             timeout: int = 30) -> Dict[str, Any]:\n         # https://cloud.google.com/storage/docs/json_api/v1/how-tos/simple-upload\n",
        "source_code_with_indent": "    <DED>async def _upload_simple(self, url: str, object_name: str,\n                             stream: io.IOBase, params: dict, headers: dict,\n                             *, session: Optional[Session] = None,\n                             timeout: int = 30) -> dict:\n        # https://cloud.google.com/storage/docs/json_api/v1/how-tos/simple-upload\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    <DED>async def _upload_simple(self, url: str, object_name: str,\n                             stream: IO[AnyStr], params: Dict[str, str],\n                             headers: Dict[str, str], *,\n                             session: Optional[Session] = None,\n                             timeout: int = 30) -> Dict[str, Any]:\n        # https://cloud.google.com/storage/docs/json_api/v1/how-tos/simple-upload\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    async def _upload_resumable(self, url: str, object_name: str,\n                                stream: io.IOBase, params: dict,\n                                headers: dict, *, metadata: dict = None,\n                                session: Optional[Session] = None,\n                                timeout: int = 30) -> dict:\n        # https://cloud.google.com/storage/docs/json_api/v1/how-tos/resumable-upload\n",
        "source_code_len": 416,
        "target_code": "    async def _upload_resumable(self, url: str, object_name: str,\n                                stream: IO[AnyStr], params: Dict[str, str],\n                                headers: Dict[str, str], *,\n                                metadata: Optional[Dict[str, Any]] = None,\n                                session: Optional[Session] = None,\n                                timeout: int = 30) -> Dict[str, Any]:\n        # https://cloud.google.com/storage/docs/json_api/v1/how-tos/resumable-upload\n",
        "target_code_len": 499,
        "diff_format": "@@ -329,6 +338,7 @@\n     async def _upload_resumable(self, url: str, object_name: str,\n-                                stream: io.IOBase, params: dict,\n-                                headers: dict, *, metadata: dict = None,\n+                                stream: IO[AnyStr], params: Dict[str, str],\n+                                headers: Dict[str, str], *,\n+                                metadata: Optional[Dict[str, Any]] = None,\n                                 session: Optional[Session] = None,\n-                                timeout: int = 30) -> dict:\n+                                timeout: int = 30) -> Dict[str, Any]:\n         # https://cloud.google.com/storage/docs/json_api/v1/how-tos/resumable-upload\n",
        "source_code_with_indent": "    <DED>async def _upload_resumable(self, url: str, object_name: str,\n                                stream: io.IOBase, params: dict,\n                                headers: dict, *, metadata: dict = None,\n                                session: Optional[Session] = None,\n                                timeout: int = 30) -> dict:\n        # https://cloud.google.com/storage/docs/json_api/v1/how-tos/resumable-upload\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    <DED>async def _upload_resumable(self, url: str, object_name: str,\n                                stream: IO[AnyStr], params: Dict[str, str],\n                                headers: Dict[str, str], *,\n                                metadata: Optional[Dict[str, Any]] = None,\n                                session: Optional[Session] = None,\n                                timeout: int = 30) -> Dict[str, Any]:\n        # https://cloud.google.com/storage/docs/json_api/v1/how-tos/resumable-upload\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "                                                  session=session)\n        data: dict = await self._do_upload(session_uri, stream,\n                                           headers=headers, session=session,\n                                           timeout=timeout)\n        return data\n\n    async def _initiate_upload(self, url: str, object_name: str, params: dict,\n                               headers: dict, *, metadata: dict = None,\n                               session: Optional[Session] = None) -> str:\n",
        "source_code_len": 514,
        "target_code": "                                                  session=session)\n        return await self._do_upload(session_uri, stream, headers=headers,\n                                     session=session, timeout=timeout)\n\n    async def _initiate_upload(self, url: str, object_name: str,\n                               params: Dict[str, str], headers: Dict[str, str],\n                               *, metadata: Optional[Dict[str, str]] = None,\n                               session: Optional[Session] = None) -> str:\n",
        "target_code_len": 510,
        "diff_format": "@@ -337,9 +347,8 @@\n                                                   session=session)\n-        data: dict = await self._do_upload(session_uri, stream,\n-                                           headers=headers, session=session,\n-                                           timeout=timeout)\n-        return data\n-\n-    async def _initiate_upload(self, url: str, object_name: str, params: dict,\n-                               headers: dict, *, metadata: dict = None,\n+        return await self._do_upload(session_uri, stream, headers=headers,\n+                                     session=session, timeout=timeout)\n+\n+    async def _initiate_upload(self, url: str, object_name: str,\n+                               params: Dict[str, str], headers: Dict[str, str],\n+                               *, metadata: Optional[Dict[str, str]] = None,\n                                session: Optional[Session] = None) -> str:\n",
        "source_code_with_indent": "                                                  session=session)\n        data: dict = await self._do_upload(session_uri, stream,\n                                           headers=headers, session=session,\n                                           timeout=timeout)\n        return data\n\n    <DED>async def _initiate_upload(self, url: str, object_name: str, params: dict,\n                               headers: dict, *, metadata: dict = None,\n                               session: Optional[Session] = None) -> str:\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "                                                  session=session)\n        return await self._do_upload(session_uri, stream, headers=headers,\n                                     session=session, timeout=timeout)\n\n    <DED>async def _initiate_upload(self, url: str, object_name: str,\n                               params: Dict[str, str], headers: Dict[str, str],\n                               *, metadata: Optional[Dict[str, str]] = None,\n                               session: Optional[Session] = None) -> str:\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "        metadict.update({'name': object_name})\n        metadata = json.dumps(metadict)\n\n",
        "source_code_len": 88,
        "target_code": "        metadict.update({'name': object_name})\n        metadata_ = json.dumps(metadict)\n\n",
        "target_code_len": 89,
        "diff_format": "@@ -349,3 +358,3 @@\n         metadict.update({'name': object_name})\n-        metadata = json.dumps(metadict)\n+        metadata_ = json.dumps(metadict)\n \n",
        "source_code_with_indent": "        metadict.update({'name': object_name})\n        metadata = json.dumps(metadict)\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "        metadict.update({'name': object_name})\n        metadata_ = json.dumps(metadict)\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "        post_headers.update({\n            'Content-Length': str(len(metadata)),\n            'Content-Type': 'application/json; charset=UTF-8',\n",
        "source_code_len": 143,
        "target_code": "        post_headers.update({\n            'Content-Length': str(len(metadata_)),\n            'Content-Type': 'application/json; charset=UTF-8',\n",
        "target_code_len": 144,
        "diff_format": "@@ -353,3 +362,3 @@\n         post_headers.update({\n-            'Content-Length': str(len(metadata)),\n+            'Content-Length': str(len(metadata_)),\n             'Content-Type': 'application/json; charset=UTF-8',\n",
        "source_code_with_indent": "        post_headers.update({\n            'Content-Length': str(len(metadata)),\n            'Content-Type': 'application/json; charset=UTF-8',\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "        post_headers.update({\n            'Content-Length': str(len(metadata_)),\n            'Content-Type': 'application/json; charset=UTF-8',\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n    async def _do_upload(self, session_uri: str, stream: io.IOBase,\n                         headers: dict, *, retries: int = 5,\n                         session: Optional[Session] = None,\n                         timeout: int = 30) -> dict:\n        s = AioSession(session) if session else self.session\n",
        "source_code_len": 304,
        "target_code": "\n    async def _do_upload(self, session_uri: str, stream: IO[AnyStr],\n                         headers: Dict[str, str], *, retries: int = 5,\n                         session: Optional[Session] = None,\n                         timeout: int = 30) -> Dict[str, Any]:\n        s = AioSession(session) if session else self.session\n",
        "target_code_len": 325,
        "diff_format": "@@ -365,6 +374,6 @@\n \n-    async def _do_upload(self, session_uri: str, stream: io.IOBase,\n-                         headers: dict, *, retries: int = 5,\n+    async def _do_upload(self, session_uri: str, stream: IO[AnyStr],\n+                         headers: Dict[str, str], *, retries: int = 5,\n                          session: Optional[Session] = None,\n-                         timeout: int = 30) -> dict:\n+                         timeout: int = 30) -> Dict[str, Any]:\n         s = AioSession(session) if session else self.session\n",
        "source_code_with_indent": "\n    <DED>async def _do_upload(self, session_uri: str, stream: io.IOBase,\n                         headers: dict, *, retries: int = 5,\n                         session: Optional[Session] = None,\n                         timeout: int = 30) -> dict:\n        <IND>s = AioSession(session) if session else self.session\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n    <DED>async def _do_upload(self, session_uri: str, stream: IO[AnyStr],\n                         headers: Dict[str, str], *, retries: int = 5,\n                         session: Optional[Session] = None,\n                         timeout: int = 30) -> Dict[str, Any]:\n        <IND>s = AioSession(session) if session else self.session\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "talkiq/gcloud-aio",
    "commit": "82af90a9877490b01daff1af609a39a2525d2db2",
    "filename": "storage/gcloud/aio/storage/storage.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/talkiq-gcloud-aio/storage/gcloud/aio/storage/storage.py",
    "file_hunks_size": 30,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "storage/gcloud/aio/storage/storage.py:190:21 Incompatible variable type [9]: headers is declared to have type `Dict[typing.Any, typing.Any]` but is used as type `None`.",
    "message": " headers is declared to have type `Dict[typing.Any, typing.Any]` but is used as type `None`.",
    "rule_id": "Incompatible variable type [9]",
    "warning_line_no": 190,
    "warning_line": "                     headers: dict = None, metadata: dict = None,",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "from typing import Any\nfrom typing import Dict\nfrom typing import Optional\n",
        "source_code_len": 75,
        "target_code": "from typing import Any\nfrom typing import AnyStr\nfrom typing import Dict\nfrom typing import IO\nfrom typing import Optional\n",
        "target_code_len": 123,
        "diff_format": "@@ -7,3 +7,5 @@\n from typing import Any\n+from typing import AnyStr\n from typing import Dict\n+from typing import IO\n from typing import Optional\n",
        "source_code_with_indent": "from typing import Any\nfrom typing import Dict\nfrom typing import Optional\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "from typing import Any\nfrom typing import AnyStr\nfrom typing import Dict\nfrom typing import IO\nfrom typing import Optional\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    async def upload(self, bucket: str, object_name: str, file_data: Any,\n                     *, content_type: str = None, parameters: dict = None,\n                     headers: dict = None, metadata: dict = None,\n                     session: Optional[Session] = None, timeout: int = 30,\n                     force_resumable_upload: bool = None) -> dict:\n        url = f'{API_ROOT_UPLOAD}/{bucket}/o'\n",
        "source_code_len": 403,
        "target_code": "    async def upload(self, bucket: str, object_name: str, file_data: Any,\n                     *, content_type: Optional[str] = None,\n                     parameters: Optional[Dict[str, str]] = None,\n                     headers: Optional[Dict[str, str]] = None,\n                     metadata: Optional[Dict[str, str]] = None,\n                     session: Optional[Session] = None,\n                     force_resumable_upload: Optional[bool] = None,\n                     timeout: int = 30) -> Dict[str, Any]:\n        url = f'{API_ROOT_UPLOAD}/{bucket}/o'\n",
        "target_code_len": 556,
        "diff_format": "@@ -188,6 +192,9 @@\n     async def upload(self, bucket: str, object_name: str, file_data: Any,\n-                     *, content_type: str = None, parameters: dict = None,\n-                     headers: dict = None, metadata: dict = None,\n-                     session: Optional[Session] = None, timeout: int = 30,\n-                     force_resumable_upload: bool = None) -> dict:\n+                     *, content_type: Optional[str] = None,\n+                     parameters: Optional[Dict[str, str]] = None,\n+                     headers: Optional[Dict[str, str]] = None,\n+                     metadata: Optional[Dict[str, str]] = None,\n+                     session: Optional[Session] = None,\n+                     force_resumable_upload: Optional[bool] = None,\n+                     timeout: int = 30) -> Dict[str, Any]:\n         url = f'{API_ROOT_UPLOAD}/{bucket}/o'\n",
        "source_code_with_indent": "    <DED>async def upload(self, bucket: str, object_name: str, file_data: Any,\n                     *, content_type: str = None, parameters: dict = None,\n                     headers: dict = None, metadata: dict = None,\n                     session: Optional[Session] = None, timeout: int = 30,\n                     force_resumable_upload: bool = None) -> dict:\n        <IND>url = f'{API_ROOT_UPLOAD}/{bucket}/o'\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    <DED>async def upload(self, bucket: str, object_name: str, file_data: Any,\n                     *, content_type: Optional[str] = None,\n                     parameters: Optional[Dict[str, str]] = None,\n                     headers: Optional[Dict[str, str]] = None,\n                     metadata: Optional[Dict[str, str]] = None,\n                     session: Optional[Session] = None,\n                     force_resumable_upload: Optional[bool] = None,\n                     timeout: int = 30) -> Dict[str, Any]:\n        <IND>url = f'{API_ROOT_UPLOAD}/{bucket}/o'\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "                                   filename: str,\n                                   **kwargs: Dict[str, Any]) -> dict:\n        with open(filename, 'rb') as file_object:\n",
        "source_code_len": 170,
        "target_code": "                                   filename: str,\n                                   **kwargs: Any) -> Dict[str, Any]:\n        with open(filename, 'rb') as file_object:\n",
        "target_code_len": 169,
        "diff_format": "@@ -235,3 +242,3 @@\n                                    filename: str,\n-                                   **kwargs: Dict[str, Any]) -> dict:\n+                                   **kwargs: Any) -> Dict[str, Any]:\n         with open(filename, 'rb') as file_object:\n",
        "source_code_with_indent": "                                   filename: str,\n                                   **kwargs: Dict[str, Any]) -> dict:\n        <IND>with open(filename, 'rb') as file_object:\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "                                   filename: str,\n                                   **kwargs: Any) -> Dict[str, Any]:\n        <IND>with open(filename, 'rb') as file_object:\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    @staticmethod\n    def _get_stream_len(stream: io.IOBase) -> int:\n        current = stream.tell()\n",
        "source_code_len": 101,
        "target_code": "    @staticmethod\n    def _get_stream_len(stream: IO[AnyStr]) -> int:\n        current = stream.tell()\n",
        "target_code_len": 102,
        "diff_format": "@@ -241,3 +248,3 @@\n     @staticmethod\n-    def _get_stream_len(stream: io.IOBase) -> int:\n+    def _get_stream_len(stream: IO[AnyStr]) -> int:\n         current = stream.tell()\n",
        "source_code_with_indent": "    <DED><DED>@staticmethod\n    def _get_stream_len(stream: io.IOBase) -> int:\n        <IND>current = stream.tell()\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    <DED><DED>@staticmethod\n    def _get_stream_len(stream: IO[AnyStr]) -> int:\n        <IND>current = stream.tell()\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    @staticmethod\n    def _preprocess_data(data: Any) -> io.IOBase:\n        if data is None:\n",
        "source_code_len": 93,
        "target_code": "    @staticmethod\n    def _preprocess_data(data: Any) -> IO[Any]:\n        if data is None:\n",
        "target_code_len": 91,
        "diff_format": "@@ -249,3 +256,3 @@\n     @staticmethod\n-    def _preprocess_data(data: Any) -> io.IOBase:\n+    def _preprocess_data(data: Any) -> IO[Any]:\n         if data is None:\n",
        "source_code_with_indent": "    <DED><DED>@staticmethod\n    def _preprocess_data(data: Any) -> io.IOBase:\n        <IND>if data is None:\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    <DED><DED>@staticmethod\n    def _preprocess_data(data: Any) -> IO[Any]:\n        <IND>if data is None:\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": true,
        "source_code": "        if isinstance(data, io.IOBase):\n            return data\n\n",
        "source_code_len": 65,
        "target_code": "        if isinstance(data, io.IOBase):\n            return data  # type: ignore[return-value]\n\n",
        "target_code_len": 95,
        "diff_format": "@@ -258,3 +265,3 @@\n         if isinstance(data, io.IOBase):\n-            return data\n+            return data  # type: ignore[return-value]\n \n",
        "source_code_with_indent": "        <DED>if isinstance(data, io.IOBase):\n            <IND>return data\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "        <DED>if isinstance(data, io.IOBase):\n            <IND>return data  # type: ignore[return-value]\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    async def _upload_simple(self, url: str, object_name: str,\n                             stream: io.IOBase, params: dict, headers: dict,\n                             *, session: Optional[Session] = None,\n                             timeout: int = 30) -> dict:\n        # https://cloud.google.com/storage/docs/json_api/v1/how-tos/simple-upload\n",
        "source_code_len": 346,
        "target_code": "    async def _upload_simple(self, url: str, object_name: str,\n                             stream: IO[AnyStr], params: Dict[str, str],\n                             headers: Dict[str, str], *,\n                             session: Optional[Session] = None,\n                             timeout: int = 30) -> Dict[str, Any]:\n        # https://cloud.google.com/storage/docs/json_api/v1/how-tos/simple-upload\n",
        "target_code_len": 406,
        "diff_format": "@@ -313,5 +321,6 @@\n     async def _upload_simple(self, url: str, object_name: str,\n-                             stream: io.IOBase, params: dict, headers: dict,\n-                             *, session: Optional[Session] = None,\n-                             timeout: int = 30) -> dict:\n+                             stream: IO[AnyStr], params: Dict[str, str],\n+                             headers: Dict[str, str], *,\n+                             session: Optional[Session] = None,\n+                             timeout: int = 30) -> Dict[str, Any]:\n         # https://cloud.google.com/storage/docs/json_api/v1/how-tos/simple-upload\n",
        "source_code_with_indent": "    <DED>async def _upload_simple(self, url: str, object_name: str,\n                             stream: io.IOBase, params: dict, headers: dict,\n                             *, session: Optional[Session] = None,\n                             timeout: int = 30) -> dict:\n        # https://cloud.google.com/storage/docs/json_api/v1/how-tos/simple-upload\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    <DED>async def _upload_simple(self, url: str, object_name: str,\n                             stream: IO[AnyStr], params: Dict[str, str],\n                             headers: Dict[str, str], *,\n                             session: Optional[Session] = None,\n                             timeout: int = 30) -> Dict[str, Any]:\n        # https://cloud.google.com/storage/docs/json_api/v1/how-tos/simple-upload\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    async def _upload_resumable(self, url: str, object_name: str,\n                                stream: io.IOBase, params: dict,\n                                headers: dict, *, metadata: dict = None,\n                                session: Optional[Session] = None,\n                                timeout: int = 30) -> dict:\n        # https://cloud.google.com/storage/docs/json_api/v1/how-tos/resumable-upload\n",
        "source_code_len": 416,
        "target_code": "    async def _upload_resumable(self, url: str, object_name: str,\n                                stream: IO[AnyStr], params: Dict[str, str],\n                                headers: Dict[str, str], *,\n                                metadata: Optional[Dict[str, Any]] = None,\n                                session: Optional[Session] = None,\n                                timeout: int = 30) -> Dict[str, Any]:\n        # https://cloud.google.com/storage/docs/json_api/v1/how-tos/resumable-upload\n",
        "target_code_len": 499,
        "diff_format": "@@ -329,6 +338,7 @@\n     async def _upload_resumable(self, url: str, object_name: str,\n-                                stream: io.IOBase, params: dict,\n-                                headers: dict, *, metadata: dict = None,\n+                                stream: IO[AnyStr], params: Dict[str, str],\n+                                headers: Dict[str, str], *,\n+                                metadata: Optional[Dict[str, Any]] = None,\n                                 session: Optional[Session] = None,\n-                                timeout: int = 30) -> dict:\n+                                timeout: int = 30) -> Dict[str, Any]:\n         # https://cloud.google.com/storage/docs/json_api/v1/how-tos/resumable-upload\n",
        "source_code_with_indent": "    <DED>async def _upload_resumable(self, url: str, object_name: str,\n                                stream: io.IOBase, params: dict,\n                                headers: dict, *, metadata: dict = None,\n                                session: Optional[Session] = None,\n                                timeout: int = 30) -> dict:\n        # https://cloud.google.com/storage/docs/json_api/v1/how-tos/resumable-upload\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    <DED>async def _upload_resumable(self, url: str, object_name: str,\n                                stream: IO[AnyStr], params: Dict[str, str],\n                                headers: Dict[str, str], *,\n                                metadata: Optional[Dict[str, Any]] = None,\n                                session: Optional[Session] = None,\n                                timeout: int = 30) -> Dict[str, Any]:\n        # https://cloud.google.com/storage/docs/json_api/v1/how-tos/resumable-upload\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "                                                  session=session)\n        data: dict = await self._do_upload(session_uri, stream,\n                                           headers=headers, session=session,\n                                           timeout=timeout)\n        return data\n\n    async def _initiate_upload(self, url: str, object_name: str, params: dict,\n                               headers: dict, *, metadata: dict = None,\n                               session: Optional[Session] = None) -> str:\n",
        "source_code_len": 514,
        "target_code": "                                                  session=session)\n        return await self._do_upload(session_uri, stream, headers=headers,\n                                     session=session, timeout=timeout)\n\n    async def _initiate_upload(self, url: str, object_name: str,\n                               params: Dict[str, str], headers: Dict[str, str],\n                               *, metadata: Optional[Dict[str, str]] = None,\n                               session: Optional[Session] = None) -> str:\n",
        "target_code_len": 510,
        "diff_format": "@@ -337,9 +347,8 @@\n                                                   session=session)\n-        data: dict = await self._do_upload(session_uri, stream,\n-                                           headers=headers, session=session,\n-                                           timeout=timeout)\n-        return data\n-\n-    async def _initiate_upload(self, url: str, object_name: str, params: dict,\n-                               headers: dict, *, metadata: dict = None,\n+        return await self._do_upload(session_uri, stream, headers=headers,\n+                                     session=session, timeout=timeout)\n+\n+    async def _initiate_upload(self, url: str, object_name: str,\n+                               params: Dict[str, str], headers: Dict[str, str],\n+                               *, metadata: Optional[Dict[str, str]] = None,\n                                session: Optional[Session] = None) -> str:\n",
        "source_code_with_indent": "                                                  session=session)\n        data: dict = await self._do_upload(session_uri, stream,\n                                           headers=headers, session=session,\n                                           timeout=timeout)\n        return data\n\n    <DED>async def _initiate_upload(self, url: str, object_name: str, params: dict,\n                               headers: dict, *, metadata: dict = None,\n                               session: Optional[Session] = None) -> str:\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "                                                  session=session)\n        return await self._do_upload(session_uri, stream, headers=headers,\n                                     session=session, timeout=timeout)\n\n    <DED>async def _initiate_upload(self, url: str, object_name: str,\n                               params: Dict[str, str], headers: Dict[str, str],\n                               *, metadata: Optional[Dict[str, str]] = None,\n                               session: Optional[Session] = None) -> str:\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "        metadict.update({'name': object_name})\n        metadata = json.dumps(metadict)\n\n",
        "source_code_len": 88,
        "target_code": "        metadict.update({'name': object_name})\n        metadata_ = json.dumps(metadict)\n\n",
        "target_code_len": 89,
        "diff_format": "@@ -349,3 +358,3 @@\n         metadict.update({'name': object_name})\n-        metadata = json.dumps(metadict)\n+        metadata_ = json.dumps(metadict)\n \n",
        "source_code_with_indent": "        metadict.update({'name': object_name})\n        metadata = json.dumps(metadict)\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "        metadict.update({'name': object_name})\n        metadata_ = json.dumps(metadict)\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "        post_headers.update({\n            'Content-Length': str(len(metadata)),\n            'Content-Type': 'application/json; charset=UTF-8',\n",
        "source_code_len": 143,
        "target_code": "        post_headers.update({\n            'Content-Length': str(len(metadata_)),\n            'Content-Type': 'application/json; charset=UTF-8',\n",
        "target_code_len": 144,
        "diff_format": "@@ -353,3 +362,3 @@\n         post_headers.update({\n-            'Content-Length': str(len(metadata)),\n+            'Content-Length': str(len(metadata_)),\n             'Content-Type': 'application/json; charset=UTF-8',\n",
        "source_code_with_indent": "        post_headers.update({\n            'Content-Length': str(len(metadata)),\n            'Content-Type': 'application/json; charset=UTF-8',\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "        post_headers.update({\n            'Content-Length': str(len(metadata_)),\n            'Content-Type': 'application/json; charset=UTF-8',\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n    async def _do_upload(self, session_uri: str, stream: io.IOBase,\n                         headers: dict, *, retries: int = 5,\n                         session: Optional[Session] = None,\n                         timeout: int = 30) -> dict:\n        s = AioSession(session) if session else self.session\n",
        "source_code_len": 304,
        "target_code": "\n    async def _do_upload(self, session_uri: str, stream: IO[AnyStr],\n                         headers: Dict[str, str], *, retries: int = 5,\n                         session: Optional[Session] = None,\n                         timeout: int = 30) -> Dict[str, Any]:\n        s = AioSession(session) if session else self.session\n",
        "target_code_len": 325,
        "diff_format": "@@ -365,6 +374,6 @@\n \n-    async def _do_upload(self, session_uri: str, stream: io.IOBase,\n-                         headers: dict, *, retries: int = 5,\n+    async def _do_upload(self, session_uri: str, stream: IO[AnyStr],\n+                         headers: Dict[str, str], *, retries: int = 5,\n                          session: Optional[Session] = None,\n-                         timeout: int = 30) -> dict:\n+                         timeout: int = 30) -> Dict[str, Any]:\n         s = AioSession(session) if session else self.session\n",
        "source_code_with_indent": "\n    <DED>async def _do_upload(self, session_uri: str, stream: io.IOBase,\n                         headers: dict, *, retries: int = 5,\n                         session: Optional[Session] = None,\n                         timeout: int = 30) -> dict:\n        <IND>s = AioSession(session) if session else self.session\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n    <DED>async def _do_upload(self, session_uri: str, stream: IO[AnyStr],\n                         headers: Dict[str, str], *, retries: int = 5,\n                         session: Optional[Session] = None,\n                         timeout: int = 30) -> Dict[str, Any]:\n        <IND>s = AioSession(session) if session else self.session\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "talkiq/gcloud-aio",
    "commit": "82af90a9877490b01daff1af609a39a2525d2db2",
    "filename": "storage/gcloud/aio/storage/storage.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/talkiq-gcloud-aio/storage/gcloud/aio/storage/storage.py",
    "file_hunks_size": 30,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "storage/gcloud/aio/storage/storage.py:190:43 Incompatible variable type [9]: metadata is declared to have type `Dict[typing.Any, typing.Any]` but is used as type `None`.",
    "message": " metadata is declared to have type `Dict[typing.Any, typing.Any]` but is used as type `None`.",
    "rule_id": "Incompatible variable type [9]",
    "warning_line_no": 190,
    "warning_line": "                     headers: dict = None, metadata: dict = None,",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "from typing import Any\nfrom typing import Dict\nfrom typing import Optional\n",
        "source_code_len": 75,
        "target_code": "from typing import Any\nfrom typing import AnyStr\nfrom typing import Dict\nfrom typing import IO\nfrom typing import Optional\n",
        "target_code_len": 123,
        "diff_format": "@@ -7,3 +7,5 @@\n from typing import Any\n+from typing import AnyStr\n from typing import Dict\n+from typing import IO\n from typing import Optional\n",
        "source_code_with_indent": "from typing import Any\nfrom typing import Dict\nfrom typing import Optional\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "from typing import Any\nfrom typing import AnyStr\nfrom typing import Dict\nfrom typing import IO\nfrom typing import Optional\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    async def upload(self, bucket: str, object_name: str, file_data: Any,\n                     *, content_type: str = None, parameters: dict = None,\n                     headers: dict = None, metadata: dict = None,\n                     session: Optional[Session] = None, timeout: int = 30,\n                     force_resumable_upload: bool = None) -> dict:\n        url = f'{API_ROOT_UPLOAD}/{bucket}/o'\n",
        "source_code_len": 403,
        "target_code": "    async def upload(self, bucket: str, object_name: str, file_data: Any,\n                     *, content_type: Optional[str] = None,\n                     parameters: Optional[Dict[str, str]] = None,\n                     headers: Optional[Dict[str, str]] = None,\n                     metadata: Optional[Dict[str, str]] = None,\n                     session: Optional[Session] = None,\n                     force_resumable_upload: Optional[bool] = None,\n                     timeout: int = 30) -> Dict[str, Any]:\n        url = f'{API_ROOT_UPLOAD}/{bucket}/o'\n",
        "target_code_len": 556,
        "diff_format": "@@ -188,6 +192,9 @@\n     async def upload(self, bucket: str, object_name: str, file_data: Any,\n-                     *, content_type: str = None, parameters: dict = None,\n-                     headers: dict = None, metadata: dict = None,\n-                     session: Optional[Session] = None, timeout: int = 30,\n-                     force_resumable_upload: bool = None) -> dict:\n+                     *, content_type: Optional[str] = None,\n+                     parameters: Optional[Dict[str, str]] = None,\n+                     headers: Optional[Dict[str, str]] = None,\n+                     metadata: Optional[Dict[str, str]] = None,\n+                     session: Optional[Session] = None,\n+                     force_resumable_upload: Optional[bool] = None,\n+                     timeout: int = 30) -> Dict[str, Any]:\n         url = f'{API_ROOT_UPLOAD}/{bucket}/o'\n",
        "source_code_with_indent": "    <DED>async def upload(self, bucket: str, object_name: str, file_data: Any,\n                     *, content_type: str = None, parameters: dict = None,\n                     headers: dict = None, metadata: dict = None,\n                     session: Optional[Session] = None, timeout: int = 30,\n                     force_resumable_upload: bool = None) -> dict:\n        <IND>url = f'{API_ROOT_UPLOAD}/{bucket}/o'\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    <DED>async def upload(self, bucket: str, object_name: str, file_data: Any,\n                     *, content_type: Optional[str] = None,\n                     parameters: Optional[Dict[str, str]] = None,\n                     headers: Optional[Dict[str, str]] = None,\n                     metadata: Optional[Dict[str, str]] = None,\n                     session: Optional[Session] = None,\n                     force_resumable_upload: Optional[bool] = None,\n                     timeout: int = 30) -> Dict[str, Any]:\n        <IND>url = f'{API_ROOT_UPLOAD}/{bucket}/o'\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "                                   filename: str,\n                                   **kwargs: Dict[str, Any]) -> dict:\n        with open(filename, 'rb') as file_object:\n",
        "source_code_len": 170,
        "target_code": "                                   filename: str,\n                                   **kwargs: Any) -> Dict[str, Any]:\n        with open(filename, 'rb') as file_object:\n",
        "target_code_len": 169,
        "diff_format": "@@ -235,3 +242,3 @@\n                                    filename: str,\n-                                   **kwargs: Dict[str, Any]) -> dict:\n+                                   **kwargs: Any) -> Dict[str, Any]:\n         with open(filename, 'rb') as file_object:\n",
        "source_code_with_indent": "                                   filename: str,\n                                   **kwargs: Dict[str, Any]) -> dict:\n        <IND>with open(filename, 'rb') as file_object:\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "                                   filename: str,\n                                   **kwargs: Any) -> Dict[str, Any]:\n        <IND>with open(filename, 'rb') as file_object:\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    @staticmethod\n    def _get_stream_len(stream: io.IOBase) -> int:\n        current = stream.tell()\n",
        "source_code_len": 101,
        "target_code": "    @staticmethod\n    def _get_stream_len(stream: IO[AnyStr]) -> int:\n        current = stream.tell()\n",
        "target_code_len": 102,
        "diff_format": "@@ -241,3 +248,3 @@\n     @staticmethod\n-    def _get_stream_len(stream: io.IOBase) -> int:\n+    def _get_stream_len(stream: IO[AnyStr]) -> int:\n         current = stream.tell()\n",
        "source_code_with_indent": "    <DED><DED>@staticmethod\n    def _get_stream_len(stream: io.IOBase) -> int:\n        <IND>current = stream.tell()\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    <DED><DED>@staticmethod\n    def _get_stream_len(stream: IO[AnyStr]) -> int:\n        <IND>current = stream.tell()\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    @staticmethod\n    def _preprocess_data(data: Any) -> io.IOBase:\n        if data is None:\n",
        "source_code_len": 93,
        "target_code": "    @staticmethod\n    def _preprocess_data(data: Any) -> IO[Any]:\n        if data is None:\n",
        "target_code_len": 91,
        "diff_format": "@@ -249,3 +256,3 @@\n     @staticmethod\n-    def _preprocess_data(data: Any) -> io.IOBase:\n+    def _preprocess_data(data: Any) -> IO[Any]:\n         if data is None:\n",
        "source_code_with_indent": "    <DED><DED>@staticmethod\n    def _preprocess_data(data: Any) -> io.IOBase:\n        <IND>if data is None:\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    <DED><DED>@staticmethod\n    def _preprocess_data(data: Any) -> IO[Any]:\n        <IND>if data is None:\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": true,
        "source_code": "        if isinstance(data, io.IOBase):\n            return data\n\n",
        "source_code_len": 65,
        "target_code": "        if isinstance(data, io.IOBase):\n            return data  # type: ignore[return-value]\n\n",
        "target_code_len": 95,
        "diff_format": "@@ -258,3 +265,3 @@\n         if isinstance(data, io.IOBase):\n-            return data\n+            return data  # type: ignore[return-value]\n \n",
        "source_code_with_indent": "        <DED>if isinstance(data, io.IOBase):\n            <IND>return data\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "        <DED>if isinstance(data, io.IOBase):\n            <IND>return data  # type: ignore[return-value]\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    async def _upload_simple(self, url: str, object_name: str,\n                             stream: io.IOBase, params: dict, headers: dict,\n                             *, session: Optional[Session] = None,\n                             timeout: int = 30) -> dict:\n        # https://cloud.google.com/storage/docs/json_api/v1/how-tos/simple-upload\n",
        "source_code_len": 346,
        "target_code": "    async def _upload_simple(self, url: str, object_name: str,\n                             stream: IO[AnyStr], params: Dict[str, str],\n                             headers: Dict[str, str], *,\n                             session: Optional[Session] = None,\n                             timeout: int = 30) -> Dict[str, Any]:\n        # https://cloud.google.com/storage/docs/json_api/v1/how-tos/simple-upload\n",
        "target_code_len": 406,
        "diff_format": "@@ -313,5 +321,6 @@\n     async def _upload_simple(self, url: str, object_name: str,\n-                             stream: io.IOBase, params: dict, headers: dict,\n-                             *, session: Optional[Session] = None,\n-                             timeout: int = 30) -> dict:\n+                             stream: IO[AnyStr], params: Dict[str, str],\n+                             headers: Dict[str, str], *,\n+                             session: Optional[Session] = None,\n+                             timeout: int = 30) -> Dict[str, Any]:\n         # https://cloud.google.com/storage/docs/json_api/v1/how-tos/simple-upload\n",
        "source_code_with_indent": "    <DED>async def _upload_simple(self, url: str, object_name: str,\n                             stream: io.IOBase, params: dict, headers: dict,\n                             *, session: Optional[Session] = None,\n                             timeout: int = 30) -> dict:\n        # https://cloud.google.com/storage/docs/json_api/v1/how-tos/simple-upload\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    <DED>async def _upload_simple(self, url: str, object_name: str,\n                             stream: IO[AnyStr], params: Dict[str, str],\n                             headers: Dict[str, str], *,\n                             session: Optional[Session] = None,\n                             timeout: int = 30) -> Dict[str, Any]:\n        # https://cloud.google.com/storage/docs/json_api/v1/how-tos/simple-upload\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    async def _upload_resumable(self, url: str, object_name: str,\n                                stream: io.IOBase, params: dict,\n                                headers: dict, *, metadata: dict = None,\n                                session: Optional[Session] = None,\n                                timeout: int = 30) -> dict:\n        # https://cloud.google.com/storage/docs/json_api/v1/how-tos/resumable-upload\n",
        "source_code_len": 416,
        "target_code": "    async def _upload_resumable(self, url: str, object_name: str,\n                                stream: IO[AnyStr], params: Dict[str, str],\n                                headers: Dict[str, str], *,\n                                metadata: Optional[Dict[str, Any]] = None,\n                                session: Optional[Session] = None,\n                                timeout: int = 30) -> Dict[str, Any]:\n        # https://cloud.google.com/storage/docs/json_api/v1/how-tos/resumable-upload\n",
        "target_code_len": 499,
        "diff_format": "@@ -329,6 +338,7 @@\n     async def _upload_resumable(self, url: str, object_name: str,\n-                                stream: io.IOBase, params: dict,\n-                                headers: dict, *, metadata: dict = None,\n+                                stream: IO[AnyStr], params: Dict[str, str],\n+                                headers: Dict[str, str], *,\n+                                metadata: Optional[Dict[str, Any]] = None,\n                                 session: Optional[Session] = None,\n-                                timeout: int = 30) -> dict:\n+                                timeout: int = 30) -> Dict[str, Any]:\n         # https://cloud.google.com/storage/docs/json_api/v1/how-tos/resumable-upload\n",
        "source_code_with_indent": "    <DED>async def _upload_resumable(self, url: str, object_name: str,\n                                stream: io.IOBase, params: dict,\n                                headers: dict, *, metadata: dict = None,\n                                session: Optional[Session] = None,\n                                timeout: int = 30) -> dict:\n        # https://cloud.google.com/storage/docs/json_api/v1/how-tos/resumable-upload\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    <DED>async def _upload_resumable(self, url: str, object_name: str,\n                                stream: IO[AnyStr], params: Dict[str, str],\n                                headers: Dict[str, str], *,\n                                metadata: Optional[Dict[str, Any]] = None,\n                                session: Optional[Session] = None,\n                                timeout: int = 30) -> Dict[str, Any]:\n        # https://cloud.google.com/storage/docs/json_api/v1/how-tos/resumable-upload\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "                                                  session=session)\n        data: dict = await self._do_upload(session_uri, stream,\n                                           headers=headers, session=session,\n                                           timeout=timeout)\n        return data\n\n    async def _initiate_upload(self, url: str, object_name: str, params: dict,\n                               headers: dict, *, metadata: dict = None,\n                               session: Optional[Session] = None) -> str:\n",
        "source_code_len": 514,
        "target_code": "                                                  session=session)\n        return await self._do_upload(session_uri, stream, headers=headers,\n                                     session=session, timeout=timeout)\n\n    async def _initiate_upload(self, url: str, object_name: str,\n                               params: Dict[str, str], headers: Dict[str, str],\n                               *, metadata: Optional[Dict[str, str]] = None,\n                               session: Optional[Session] = None) -> str:\n",
        "target_code_len": 510,
        "diff_format": "@@ -337,9 +347,8 @@\n                                                   session=session)\n-        data: dict = await self._do_upload(session_uri, stream,\n-                                           headers=headers, session=session,\n-                                           timeout=timeout)\n-        return data\n-\n-    async def _initiate_upload(self, url: str, object_name: str, params: dict,\n-                               headers: dict, *, metadata: dict = None,\n+        return await self._do_upload(session_uri, stream, headers=headers,\n+                                     session=session, timeout=timeout)\n+\n+    async def _initiate_upload(self, url: str, object_name: str,\n+                               params: Dict[str, str], headers: Dict[str, str],\n+                               *, metadata: Optional[Dict[str, str]] = None,\n                                session: Optional[Session] = None) -> str:\n",
        "source_code_with_indent": "                                                  session=session)\n        data: dict = await self._do_upload(session_uri, stream,\n                                           headers=headers, session=session,\n                                           timeout=timeout)\n        return data\n\n    <DED>async def _initiate_upload(self, url: str, object_name: str, params: dict,\n                               headers: dict, *, metadata: dict = None,\n                               session: Optional[Session] = None) -> str:\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "                                                  session=session)\n        return await self._do_upload(session_uri, stream, headers=headers,\n                                     session=session, timeout=timeout)\n\n    <DED>async def _initiate_upload(self, url: str, object_name: str,\n                               params: Dict[str, str], headers: Dict[str, str],\n                               *, metadata: Optional[Dict[str, str]] = None,\n                               session: Optional[Session] = None) -> str:\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "        metadict.update({'name': object_name})\n        metadata = json.dumps(metadict)\n\n",
        "source_code_len": 88,
        "target_code": "        metadict.update({'name': object_name})\n        metadata_ = json.dumps(metadict)\n\n",
        "target_code_len": 89,
        "diff_format": "@@ -349,3 +358,3 @@\n         metadict.update({'name': object_name})\n-        metadata = json.dumps(metadict)\n+        metadata_ = json.dumps(metadict)\n \n",
        "source_code_with_indent": "        metadict.update({'name': object_name})\n        metadata = json.dumps(metadict)\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "        metadict.update({'name': object_name})\n        metadata_ = json.dumps(metadict)\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "        post_headers.update({\n            'Content-Length': str(len(metadata)),\n            'Content-Type': 'application/json; charset=UTF-8',\n",
        "source_code_len": 143,
        "target_code": "        post_headers.update({\n            'Content-Length': str(len(metadata_)),\n            'Content-Type': 'application/json; charset=UTF-8',\n",
        "target_code_len": 144,
        "diff_format": "@@ -353,3 +362,3 @@\n         post_headers.update({\n-            'Content-Length': str(len(metadata)),\n+            'Content-Length': str(len(metadata_)),\n             'Content-Type': 'application/json; charset=UTF-8',\n",
        "source_code_with_indent": "        post_headers.update({\n            'Content-Length': str(len(metadata)),\n            'Content-Type': 'application/json; charset=UTF-8',\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "        post_headers.update({\n            'Content-Length': str(len(metadata_)),\n            'Content-Type': 'application/json; charset=UTF-8',\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n    async def _do_upload(self, session_uri: str, stream: io.IOBase,\n                         headers: dict, *, retries: int = 5,\n                         session: Optional[Session] = None,\n                         timeout: int = 30) -> dict:\n        s = AioSession(session) if session else self.session\n",
        "source_code_len": 304,
        "target_code": "\n    async def _do_upload(self, session_uri: str, stream: IO[AnyStr],\n                         headers: Dict[str, str], *, retries: int = 5,\n                         session: Optional[Session] = None,\n                         timeout: int = 30) -> Dict[str, Any]:\n        s = AioSession(session) if session else self.session\n",
        "target_code_len": 325,
        "diff_format": "@@ -365,6 +374,6 @@\n \n-    async def _do_upload(self, session_uri: str, stream: io.IOBase,\n-                         headers: dict, *, retries: int = 5,\n+    async def _do_upload(self, session_uri: str, stream: IO[AnyStr],\n+                         headers: Dict[str, str], *, retries: int = 5,\n                          session: Optional[Session] = None,\n-                         timeout: int = 30) -> dict:\n+                         timeout: int = 30) -> Dict[str, Any]:\n         s = AioSession(session) if session else self.session\n",
        "source_code_with_indent": "\n    <DED>async def _do_upload(self, session_uri: str, stream: io.IOBase,\n                         headers: dict, *, retries: int = 5,\n                         session: Optional[Session] = None,\n                         timeout: int = 30) -> dict:\n        <IND>s = AioSession(session) if session else self.session\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n    <DED>async def _do_upload(self, session_uri: str, stream: IO[AnyStr],\n                         headers: Dict[str, str], *, retries: int = 5,\n                         session: Optional[Session] = None,\n                         timeout: int = 30) -> Dict[str, Any]:\n        <IND>s = AioSession(session) if session else self.session\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "talkiq/gcloud-aio",
    "commit": "82af90a9877490b01daff1af609a39a2525d2db2",
    "filename": "storage/gcloud/aio/storage/storage.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/talkiq-gcloud-aio/storage/gcloud/aio/storage/storage.py",
    "file_hunks_size": 30,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "storage/gcloud/aio/storage/storage.py:192:21 Incompatible variable type [9]: force_resumable_upload is declared to have type `bool` but is used as type `None`.",
    "message": " force_resumable_upload is declared to have type `bool` but is used as type `None`.",
    "rule_id": "Incompatible variable type [9]",
    "warning_line_no": 192,
    "warning_line": "                     force_resumable_upload: bool = None) -> dict:",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "from typing import Any\nfrom typing import Dict\nfrom typing import Optional\n",
        "source_code_len": 75,
        "target_code": "from typing import Any\nfrom typing import AnyStr\nfrom typing import Dict\nfrom typing import IO\nfrom typing import Optional\n",
        "target_code_len": 123,
        "diff_format": "@@ -7,3 +7,5 @@\n from typing import Any\n+from typing import AnyStr\n from typing import Dict\n+from typing import IO\n from typing import Optional\n",
        "source_code_with_indent": "from typing import Any\nfrom typing import Dict\nfrom typing import Optional\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "from typing import Any\nfrom typing import AnyStr\nfrom typing import Dict\nfrom typing import IO\nfrom typing import Optional\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    async def upload(self, bucket: str, object_name: str, file_data: Any,\n                     *, content_type: str = None, parameters: dict = None,\n                     headers: dict = None, metadata: dict = None,\n                     session: Optional[Session] = None, timeout: int = 30,\n                     force_resumable_upload: bool = None) -> dict:\n        url = f'{API_ROOT_UPLOAD}/{bucket}/o'\n",
        "source_code_len": 403,
        "target_code": "    async def upload(self, bucket: str, object_name: str, file_data: Any,\n                     *, content_type: Optional[str] = None,\n                     parameters: Optional[Dict[str, str]] = None,\n                     headers: Optional[Dict[str, str]] = None,\n                     metadata: Optional[Dict[str, str]] = None,\n                     session: Optional[Session] = None,\n                     force_resumable_upload: Optional[bool] = None,\n                     timeout: int = 30) -> Dict[str, Any]:\n        url = f'{API_ROOT_UPLOAD}/{bucket}/o'\n",
        "target_code_len": 556,
        "diff_format": "@@ -188,6 +192,9 @@\n     async def upload(self, bucket: str, object_name: str, file_data: Any,\n-                     *, content_type: str = None, parameters: dict = None,\n-                     headers: dict = None, metadata: dict = None,\n-                     session: Optional[Session] = None, timeout: int = 30,\n-                     force_resumable_upload: bool = None) -> dict:\n+                     *, content_type: Optional[str] = None,\n+                     parameters: Optional[Dict[str, str]] = None,\n+                     headers: Optional[Dict[str, str]] = None,\n+                     metadata: Optional[Dict[str, str]] = None,\n+                     session: Optional[Session] = None,\n+                     force_resumable_upload: Optional[bool] = None,\n+                     timeout: int = 30) -> Dict[str, Any]:\n         url = f'{API_ROOT_UPLOAD}/{bucket}/o'\n",
        "source_code_with_indent": "    <DED>async def upload(self, bucket: str, object_name: str, file_data: Any,\n                     *, content_type: str = None, parameters: dict = None,\n                     headers: dict = None, metadata: dict = None,\n                     session: Optional[Session] = None, timeout: int = 30,\n                     force_resumable_upload: bool = None) -> dict:\n        <IND>url = f'{API_ROOT_UPLOAD}/{bucket}/o'\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    <DED>async def upload(self, bucket: str, object_name: str, file_data: Any,\n                     *, content_type: Optional[str] = None,\n                     parameters: Optional[Dict[str, str]] = None,\n                     headers: Optional[Dict[str, str]] = None,\n                     metadata: Optional[Dict[str, str]] = None,\n                     session: Optional[Session] = None,\n                     force_resumable_upload: Optional[bool] = None,\n                     timeout: int = 30) -> Dict[str, Any]:\n        <IND>url = f'{API_ROOT_UPLOAD}/{bucket}/o'\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "                                   filename: str,\n                                   **kwargs: Dict[str, Any]) -> dict:\n        with open(filename, 'rb') as file_object:\n",
        "source_code_len": 170,
        "target_code": "                                   filename: str,\n                                   **kwargs: Any) -> Dict[str, Any]:\n        with open(filename, 'rb') as file_object:\n",
        "target_code_len": 169,
        "diff_format": "@@ -235,3 +242,3 @@\n                                    filename: str,\n-                                   **kwargs: Dict[str, Any]) -> dict:\n+                                   **kwargs: Any) -> Dict[str, Any]:\n         with open(filename, 'rb') as file_object:\n",
        "source_code_with_indent": "                                   filename: str,\n                                   **kwargs: Dict[str, Any]) -> dict:\n        <IND>with open(filename, 'rb') as file_object:\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "                                   filename: str,\n                                   **kwargs: Any) -> Dict[str, Any]:\n        <IND>with open(filename, 'rb') as file_object:\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    @staticmethod\n    def _get_stream_len(stream: io.IOBase) -> int:\n        current = stream.tell()\n",
        "source_code_len": 101,
        "target_code": "    @staticmethod\n    def _get_stream_len(stream: IO[AnyStr]) -> int:\n        current = stream.tell()\n",
        "target_code_len": 102,
        "diff_format": "@@ -241,3 +248,3 @@\n     @staticmethod\n-    def _get_stream_len(stream: io.IOBase) -> int:\n+    def _get_stream_len(stream: IO[AnyStr]) -> int:\n         current = stream.tell()\n",
        "source_code_with_indent": "    <DED><DED>@staticmethod\n    def _get_stream_len(stream: io.IOBase) -> int:\n        <IND>current = stream.tell()\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    <DED><DED>@staticmethod\n    def _get_stream_len(stream: IO[AnyStr]) -> int:\n        <IND>current = stream.tell()\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    @staticmethod\n    def _preprocess_data(data: Any) -> io.IOBase:\n        if data is None:\n",
        "source_code_len": 93,
        "target_code": "    @staticmethod\n    def _preprocess_data(data: Any) -> IO[Any]:\n        if data is None:\n",
        "target_code_len": 91,
        "diff_format": "@@ -249,3 +256,3 @@\n     @staticmethod\n-    def _preprocess_data(data: Any) -> io.IOBase:\n+    def _preprocess_data(data: Any) -> IO[Any]:\n         if data is None:\n",
        "source_code_with_indent": "    <DED><DED>@staticmethod\n    def _preprocess_data(data: Any) -> io.IOBase:\n        <IND>if data is None:\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    <DED><DED>@staticmethod\n    def _preprocess_data(data: Any) -> IO[Any]:\n        <IND>if data is None:\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": true,
        "source_code": "        if isinstance(data, io.IOBase):\n            return data\n\n",
        "source_code_len": 65,
        "target_code": "        if isinstance(data, io.IOBase):\n            return data  # type: ignore[return-value]\n\n",
        "target_code_len": 95,
        "diff_format": "@@ -258,3 +265,3 @@\n         if isinstance(data, io.IOBase):\n-            return data\n+            return data  # type: ignore[return-value]\n \n",
        "source_code_with_indent": "        <DED>if isinstance(data, io.IOBase):\n            <IND>return data\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "        <DED>if isinstance(data, io.IOBase):\n            <IND>return data  # type: ignore[return-value]\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    async def _upload_simple(self, url: str, object_name: str,\n                             stream: io.IOBase, params: dict, headers: dict,\n                             *, session: Optional[Session] = None,\n                             timeout: int = 30) -> dict:\n        # https://cloud.google.com/storage/docs/json_api/v1/how-tos/simple-upload\n",
        "source_code_len": 346,
        "target_code": "    async def _upload_simple(self, url: str, object_name: str,\n                             stream: IO[AnyStr], params: Dict[str, str],\n                             headers: Dict[str, str], *,\n                             session: Optional[Session] = None,\n                             timeout: int = 30) -> Dict[str, Any]:\n        # https://cloud.google.com/storage/docs/json_api/v1/how-tos/simple-upload\n",
        "target_code_len": 406,
        "diff_format": "@@ -313,5 +321,6 @@\n     async def _upload_simple(self, url: str, object_name: str,\n-                             stream: io.IOBase, params: dict, headers: dict,\n-                             *, session: Optional[Session] = None,\n-                             timeout: int = 30) -> dict:\n+                             stream: IO[AnyStr], params: Dict[str, str],\n+                             headers: Dict[str, str], *,\n+                             session: Optional[Session] = None,\n+                             timeout: int = 30) -> Dict[str, Any]:\n         # https://cloud.google.com/storage/docs/json_api/v1/how-tos/simple-upload\n",
        "source_code_with_indent": "    <DED>async def _upload_simple(self, url: str, object_name: str,\n                             stream: io.IOBase, params: dict, headers: dict,\n                             *, session: Optional[Session] = None,\n                             timeout: int = 30) -> dict:\n        # https://cloud.google.com/storage/docs/json_api/v1/how-tos/simple-upload\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    <DED>async def _upload_simple(self, url: str, object_name: str,\n                             stream: IO[AnyStr], params: Dict[str, str],\n                             headers: Dict[str, str], *,\n                             session: Optional[Session] = None,\n                             timeout: int = 30) -> Dict[str, Any]:\n        # https://cloud.google.com/storage/docs/json_api/v1/how-tos/simple-upload\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    async def _upload_resumable(self, url: str, object_name: str,\n                                stream: io.IOBase, params: dict,\n                                headers: dict, *, metadata: dict = None,\n                                session: Optional[Session] = None,\n                                timeout: int = 30) -> dict:\n        # https://cloud.google.com/storage/docs/json_api/v1/how-tos/resumable-upload\n",
        "source_code_len": 416,
        "target_code": "    async def _upload_resumable(self, url: str, object_name: str,\n                                stream: IO[AnyStr], params: Dict[str, str],\n                                headers: Dict[str, str], *,\n                                metadata: Optional[Dict[str, Any]] = None,\n                                session: Optional[Session] = None,\n                                timeout: int = 30) -> Dict[str, Any]:\n        # https://cloud.google.com/storage/docs/json_api/v1/how-tos/resumable-upload\n",
        "target_code_len": 499,
        "diff_format": "@@ -329,6 +338,7 @@\n     async def _upload_resumable(self, url: str, object_name: str,\n-                                stream: io.IOBase, params: dict,\n-                                headers: dict, *, metadata: dict = None,\n+                                stream: IO[AnyStr], params: Dict[str, str],\n+                                headers: Dict[str, str], *,\n+                                metadata: Optional[Dict[str, Any]] = None,\n                                 session: Optional[Session] = None,\n-                                timeout: int = 30) -> dict:\n+                                timeout: int = 30) -> Dict[str, Any]:\n         # https://cloud.google.com/storage/docs/json_api/v1/how-tos/resumable-upload\n",
        "source_code_with_indent": "    <DED>async def _upload_resumable(self, url: str, object_name: str,\n                                stream: io.IOBase, params: dict,\n                                headers: dict, *, metadata: dict = None,\n                                session: Optional[Session] = None,\n                                timeout: int = 30) -> dict:\n        # https://cloud.google.com/storage/docs/json_api/v1/how-tos/resumable-upload\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    <DED>async def _upload_resumable(self, url: str, object_name: str,\n                                stream: IO[AnyStr], params: Dict[str, str],\n                                headers: Dict[str, str], *,\n                                metadata: Optional[Dict[str, Any]] = None,\n                                session: Optional[Session] = None,\n                                timeout: int = 30) -> Dict[str, Any]:\n        # https://cloud.google.com/storage/docs/json_api/v1/how-tos/resumable-upload\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "                                                  session=session)\n        data: dict = await self._do_upload(session_uri, stream,\n                                           headers=headers, session=session,\n                                           timeout=timeout)\n        return data\n\n    async def _initiate_upload(self, url: str, object_name: str, params: dict,\n                               headers: dict, *, metadata: dict = None,\n                               session: Optional[Session] = None) -> str:\n",
        "source_code_len": 514,
        "target_code": "                                                  session=session)\n        return await self._do_upload(session_uri, stream, headers=headers,\n                                     session=session, timeout=timeout)\n\n    async def _initiate_upload(self, url: str, object_name: str,\n                               params: Dict[str, str], headers: Dict[str, str],\n                               *, metadata: Optional[Dict[str, str]] = None,\n                               session: Optional[Session] = None) -> str:\n",
        "target_code_len": 510,
        "diff_format": "@@ -337,9 +347,8 @@\n                                                   session=session)\n-        data: dict = await self._do_upload(session_uri, stream,\n-                                           headers=headers, session=session,\n-                                           timeout=timeout)\n-        return data\n-\n-    async def _initiate_upload(self, url: str, object_name: str, params: dict,\n-                               headers: dict, *, metadata: dict = None,\n+        return await self._do_upload(session_uri, stream, headers=headers,\n+                                     session=session, timeout=timeout)\n+\n+    async def _initiate_upload(self, url: str, object_name: str,\n+                               params: Dict[str, str], headers: Dict[str, str],\n+                               *, metadata: Optional[Dict[str, str]] = None,\n                                session: Optional[Session] = None) -> str:\n",
        "source_code_with_indent": "                                                  session=session)\n        data: dict = await self._do_upload(session_uri, stream,\n                                           headers=headers, session=session,\n                                           timeout=timeout)\n        return data\n\n    <DED>async def _initiate_upload(self, url: str, object_name: str, params: dict,\n                               headers: dict, *, metadata: dict = None,\n                               session: Optional[Session] = None) -> str:\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "                                                  session=session)\n        return await self._do_upload(session_uri, stream, headers=headers,\n                                     session=session, timeout=timeout)\n\n    <DED>async def _initiate_upload(self, url: str, object_name: str,\n                               params: Dict[str, str], headers: Dict[str, str],\n                               *, metadata: Optional[Dict[str, str]] = None,\n                               session: Optional[Session] = None) -> str:\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "        metadict.update({'name': object_name})\n        metadata = json.dumps(metadict)\n\n",
        "source_code_len": 88,
        "target_code": "        metadict.update({'name': object_name})\n        metadata_ = json.dumps(metadict)\n\n",
        "target_code_len": 89,
        "diff_format": "@@ -349,3 +358,3 @@\n         metadict.update({'name': object_name})\n-        metadata = json.dumps(metadict)\n+        metadata_ = json.dumps(metadict)\n \n",
        "source_code_with_indent": "        metadict.update({'name': object_name})\n        metadata = json.dumps(metadict)\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "        metadict.update({'name': object_name})\n        metadata_ = json.dumps(metadict)\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "        post_headers.update({\n            'Content-Length': str(len(metadata)),\n            'Content-Type': 'application/json; charset=UTF-8',\n",
        "source_code_len": 143,
        "target_code": "        post_headers.update({\n            'Content-Length': str(len(metadata_)),\n            'Content-Type': 'application/json; charset=UTF-8',\n",
        "target_code_len": 144,
        "diff_format": "@@ -353,3 +362,3 @@\n         post_headers.update({\n-            'Content-Length': str(len(metadata)),\n+            'Content-Length': str(len(metadata_)),\n             'Content-Type': 'application/json; charset=UTF-8',\n",
        "source_code_with_indent": "        post_headers.update({\n            'Content-Length': str(len(metadata)),\n            'Content-Type': 'application/json; charset=UTF-8',\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "        post_headers.update({\n            'Content-Length': str(len(metadata_)),\n            'Content-Type': 'application/json; charset=UTF-8',\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n    async def _do_upload(self, session_uri: str, stream: io.IOBase,\n                         headers: dict, *, retries: int = 5,\n                         session: Optional[Session] = None,\n                         timeout: int = 30) -> dict:\n        s = AioSession(session) if session else self.session\n",
        "source_code_len": 304,
        "target_code": "\n    async def _do_upload(self, session_uri: str, stream: IO[AnyStr],\n                         headers: Dict[str, str], *, retries: int = 5,\n                         session: Optional[Session] = None,\n                         timeout: int = 30) -> Dict[str, Any]:\n        s = AioSession(session) if session else self.session\n",
        "target_code_len": 325,
        "diff_format": "@@ -365,6 +374,6 @@\n \n-    async def _do_upload(self, session_uri: str, stream: io.IOBase,\n-                         headers: dict, *, retries: int = 5,\n+    async def _do_upload(self, session_uri: str, stream: IO[AnyStr],\n+                         headers: Dict[str, str], *, retries: int = 5,\n                          session: Optional[Session] = None,\n-                         timeout: int = 30) -> dict:\n+                         timeout: int = 30) -> Dict[str, Any]:\n         s = AioSession(session) if session else self.session\n",
        "source_code_with_indent": "\n    <DED>async def _do_upload(self, session_uri: str, stream: io.IOBase,\n                         headers: dict, *, retries: int = 5,\n                         session: Optional[Session] = None,\n                         timeout: int = 30) -> dict:\n        <IND>s = AioSession(session) if session else self.session\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n    <DED>async def _do_upload(self, session_uri: str, stream: IO[AnyStr],\n                         headers: Dict[str, str], *, retries: int = 5,\n                         session: Optional[Session] = None,\n                         timeout: int = 30) -> Dict[str, Any]:\n        <IND>s = AioSession(session) if session else self.session\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "talkiq/gcloud-aio",
    "commit": "82af90a9877490b01daff1af609a39a2525d2db2",
    "filename": "storage/gcloud/aio/storage/storage.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/talkiq-gcloud-aio/storage/gcloud/aio/storage/storage.py",
    "file_hunks_size": 30,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "storage/gcloud/aio/storage/storage.py:205:8 Incompatible variable type [9]: content_type is declared to have type `str` but is used as type `Optional[str]`.",
    "message": " content_type is declared to have type `str` but is used as type `Optional[str]`.",
    "rule_id": "Incompatible variable type [9]",
    "warning_line_no": 205,
    "warning_line": "        content_type = content_type or mimetypes.guess_type(object_name)[0]",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "from typing import Any\nfrom typing import Dict\nfrom typing import Optional\n",
        "source_code_len": 75,
        "target_code": "from typing import Any\nfrom typing import AnyStr\nfrom typing import Dict\nfrom typing import IO\nfrom typing import Optional\n",
        "target_code_len": 123,
        "diff_format": "@@ -7,3 +7,5 @@\n from typing import Any\n+from typing import AnyStr\n from typing import Dict\n+from typing import IO\n from typing import Optional\n",
        "source_code_with_indent": "from typing import Any\nfrom typing import Dict\nfrom typing import Optional\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "from typing import Any\nfrom typing import AnyStr\nfrom typing import Dict\nfrom typing import IO\nfrom typing import Optional\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    async def upload(self, bucket: str, object_name: str, file_data: Any,\n                     *, content_type: str = None, parameters: dict = None,\n                     headers: dict = None, metadata: dict = None,\n                     session: Optional[Session] = None, timeout: int = 30,\n                     force_resumable_upload: bool = None) -> dict:\n        url = f'{API_ROOT_UPLOAD}/{bucket}/o'\n",
        "source_code_len": 403,
        "target_code": "    async def upload(self, bucket: str, object_name: str, file_data: Any,\n                     *, content_type: Optional[str] = None,\n                     parameters: Optional[Dict[str, str]] = None,\n                     headers: Optional[Dict[str, str]] = None,\n                     metadata: Optional[Dict[str, str]] = None,\n                     session: Optional[Session] = None,\n                     force_resumable_upload: Optional[bool] = None,\n                     timeout: int = 30) -> Dict[str, Any]:\n        url = f'{API_ROOT_UPLOAD}/{bucket}/o'\n",
        "target_code_len": 556,
        "diff_format": "@@ -188,6 +192,9 @@\n     async def upload(self, bucket: str, object_name: str, file_data: Any,\n-                     *, content_type: str = None, parameters: dict = None,\n-                     headers: dict = None, metadata: dict = None,\n-                     session: Optional[Session] = None, timeout: int = 30,\n-                     force_resumable_upload: bool = None) -> dict:\n+                     *, content_type: Optional[str] = None,\n+                     parameters: Optional[Dict[str, str]] = None,\n+                     headers: Optional[Dict[str, str]] = None,\n+                     metadata: Optional[Dict[str, str]] = None,\n+                     session: Optional[Session] = None,\n+                     force_resumable_upload: Optional[bool] = None,\n+                     timeout: int = 30) -> Dict[str, Any]:\n         url = f'{API_ROOT_UPLOAD}/{bucket}/o'\n",
        "source_code_with_indent": "    <DED>async def upload(self, bucket: str, object_name: str, file_data: Any,\n                     *, content_type: str = None, parameters: dict = None,\n                     headers: dict = None, metadata: dict = None,\n                     session: Optional[Session] = None, timeout: int = 30,\n                     force_resumable_upload: bool = None) -> dict:\n        <IND>url = f'{API_ROOT_UPLOAD}/{bucket}/o'\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    <DED>async def upload(self, bucket: str, object_name: str, file_data: Any,\n                     *, content_type: Optional[str] = None,\n                     parameters: Optional[Dict[str, str]] = None,\n                     headers: Optional[Dict[str, str]] = None,\n                     metadata: Optional[Dict[str, str]] = None,\n                     session: Optional[Session] = None,\n                     force_resumable_upload: Optional[bool] = None,\n                     timeout: int = 30) -> Dict[str, Any]:\n        <IND>url = f'{API_ROOT_UPLOAD}/{bucket}/o'\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "                                   filename: str,\n                                   **kwargs: Dict[str, Any]) -> dict:\n        with open(filename, 'rb') as file_object:\n",
        "source_code_len": 170,
        "target_code": "                                   filename: str,\n                                   **kwargs: Any) -> Dict[str, Any]:\n        with open(filename, 'rb') as file_object:\n",
        "target_code_len": 169,
        "diff_format": "@@ -235,3 +242,3 @@\n                                    filename: str,\n-                                   **kwargs: Dict[str, Any]) -> dict:\n+                                   **kwargs: Any) -> Dict[str, Any]:\n         with open(filename, 'rb') as file_object:\n",
        "source_code_with_indent": "                                   filename: str,\n                                   **kwargs: Dict[str, Any]) -> dict:\n        <IND>with open(filename, 'rb') as file_object:\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "                                   filename: str,\n                                   **kwargs: Any) -> Dict[str, Any]:\n        <IND>with open(filename, 'rb') as file_object:\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    @staticmethod\n    def _get_stream_len(stream: io.IOBase) -> int:\n        current = stream.tell()\n",
        "source_code_len": 101,
        "target_code": "    @staticmethod\n    def _get_stream_len(stream: IO[AnyStr]) -> int:\n        current = stream.tell()\n",
        "target_code_len": 102,
        "diff_format": "@@ -241,3 +248,3 @@\n     @staticmethod\n-    def _get_stream_len(stream: io.IOBase) -> int:\n+    def _get_stream_len(stream: IO[AnyStr]) -> int:\n         current = stream.tell()\n",
        "source_code_with_indent": "    <DED><DED>@staticmethod\n    def _get_stream_len(stream: io.IOBase) -> int:\n        <IND>current = stream.tell()\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    <DED><DED>@staticmethod\n    def _get_stream_len(stream: IO[AnyStr]) -> int:\n        <IND>current = stream.tell()\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    @staticmethod\n    def _preprocess_data(data: Any) -> io.IOBase:\n        if data is None:\n",
        "source_code_len": 93,
        "target_code": "    @staticmethod\n    def _preprocess_data(data: Any) -> IO[Any]:\n        if data is None:\n",
        "target_code_len": 91,
        "diff_format": "@@ -249,3 +256,3 @@\n     @staticmethod\n-    def _preprocess_data(data: Any) -> io.IOBase:\n+    def _preprocess_data(data: Any) -> IO[Any]:\n         if data is None:\n",
        "source_code_with_indent": "    <DED><DED>@staticmethod\n    def _preprocess_data(data: Any) -> io.IOBase:\n        <IND>if data is None:\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    <DED><DED>@staticmethod\n    def _preprocess_data(data: Any) -> IO[Any]:\n        <IND>if data is None:\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": true,
        "source_code": "        if isinstance(data, io.IOBase):\n            return data\n\n",
        "source_code_len": 65,
        "target_code": "        if isinstance(data, io.IOBase):\n            return data  # type: ignore[return-value]\n\n",
        "target_code_len": 95,
        "diff_format": "@@ -258,3 +265,3 @@\n         if isinstance(data, io.IOBase):\n-            return data\n+            return data  # type: ignore[return-value]\n \n",
        "source_code_with_indent": "        <DED>if isinstance(data, io.IOBase):\n            <IND>return data\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "        <DED>if isinstance(data, io.IOBase):\n            <IND>return data  # type: ignore[return-value]\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    async def _upload_simple(self, url: str, object_name: str,\n                             stream: io.IOBase, params: dict, headers: dict,\n                             *, session: Optional[Session] = None,\n                             timeout: int = 30) -> dict:\n        # https://cloud.google.com/storage/docs/json_api/v1/how-tos/simple-upload\n",
        "source_code_len": 346,
        "target_code": "    async def _upload_simple(self, url: str, object_name: str,\n                             stream: IO[AnyStr], params: Dict[str, str],\n                             headers: Dict[str, str], *,\n                             session: Optional[Session] = None,\n                             timeout: int = 30) -> Dict[str, Any]:\n        # https://cloud.google.com/storage/docs/json_api/v1/how-tos/simple-upload\n",
        "target_code_len": 406,
        "diff_format": "@@ -313,5 +321,6 @@\n     async def _upload_simple(self, url: str, object_name: str,\n-                             stream: io.IOBase, params: dict, headers: dict,\n-                             *, session: Optional[Session] = None,\n-                             timeout: int = 30) -> dict:\n+                             stream: IO[AnyStr], params: Dict[str, str],\n+                             headers: Dict[str, str], *,\n+                             session: Optional[Session] = None,\n+                             timeout: int = 30) -> Dict[str, Any]:\n         # https://cloud.google.com/storage/docs/json_api/v1/how-tos/simple-upload\n",
        "source_code_with_indent": "    <DED>async def _upload_simple(self, url: str, object_name: str,\n                             stream: io.IOBase, params: dict, headers: dict,\n                             *, session: Optional[Session] = None,\n                             timeout: int = 30) -> dict:\n        # https://cloud.google.com/storage/docs/json_api/v1/how-tos/simple-upload\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    <DED>async def _upload_simple(self, url: str, object_name: str,\n                             stream: IO[AnyStr], params: Dict[str, str],\n                             headers: Dict[str, str], *,\n                             session: Optional[Session] = None,\n                             timeout: int = 30) -> Dict[str, Any]:\n        # https://cloud.google.com/storage/docs/json_api/v1/how-tos/simple-upload\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    async def _upload_resumable(self, url: str, object_name: str,\n                                stream: io.IOBase, params: dict,\n                                headers: dict, *, metadata: dict = None,\n                                session: Optional[Session] = None,\n                                timeout: int = 30) -> dict:\n        # https://cloud.google.com/storage/docs/json_api/v1/how-tos/resumable-upload\n",
        "source_code_len": 416,
        "target_code": "    async def _upload_resumable(self, url: str, object_name: str,\n                                stream: IO[AnyStr], params: Dict[str, str],\n                                headers: Dict[str, str], *,\n                                metadata: Optional[Dict[str, Any]] = None,\n                                session: Optional[Session] = None,\n                                timeout: int = 30) -> Dict[str, Any]:\n        # https://cloud.google.com/storage/docs/json_api/v1/how-tos/resumable-upload\n",
        "target_code_len": 499,
        "diff_format": "@@ -329,6 +338,7 @@\n     async def _upload_resumable(self, url: str, object_name: str,\n-                                stream: io.IOBase, params: dict,\n-                                headers: dict, *, metadata: dict = None,\n+                                stream: IO[AnyStr], params: Dict[str, str],\n+                                headers: Dict[str, str], *,\n+                                metadata: Optional[Dict[str, Any]] = None,\n                                 session: Optional[Session] = None,\n-                                timeout: int = 30) -> dict:\n+                                timeout: int = 30) -> Dict[str, Any]:\n         # https://cloud.google.com/storage/docs/json_api/v1/how-tos/resumable-upload\n",
        "source_code_with_indent": "    <DED>async def _upload_resumable(self, url: str, object_name: str,\n                                stream: io.IOBase, params: dict,\n                                headers: dict, *, metadata: dict = None,\n                                session: Optional[Session] = None,\n                                timeout: int = 30) -> dict:\n        # https://cloud.google.com/storage/docs/json_api/v1/how-tos/resumable-upload\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    <DED>async def _upload_resumable(self, url: str, object_name: str,\n                                stream: IO[AnyStr], params: Dict[str, str],\n                                headers: Dict[str, str], *,\n                                metadata: Optional[Dict[str, Any]] = None,\n                                session: Optional[Session] = None,\n                                timeout: int = 30) -> Dict[str, Any]:\n        # https://cloud.google.com/storage/docs/json_api/v1/how-tos/resumable-upload\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "                                                  session=session)\n        data: dict = await self._do_upload(session_uri, stream,\n                                           headers=headers, session=session,\n                                           timeout=timeout)\n        return data\n\n    async def _initiate_upload(self, url: str, object_name: str, params: dict,\n                               headers: dict, *, metadata: dict = None,\n                               session: Optional[Session] = None) -> str:\n",
        "source_code_len": 514,
        "target_code": "                                                  session=session)\n        return await self._do_upload(session_uri, stream, headers=headers,\n                                     session=session, timeout=timeout)\n\n    async def _initiate_upload(self, url: str, object_name: str,\n                               params: Dict[str, str], headers: Dict[str, str],\n                               *, metadata: Optional[Dict[str, str]] = None,\n                               session: Optional[Session] = None) -> str:\n",
        "target_code_len": 510,
        "diff_format": "@@ -337,9 +347,8 @@\n                                                   session=session)\n-        data: dict = await self._do_upload(session_uri, stream,\n-                                           headers=headers, session=session,\n-                                           timeout=timeout)\n-        return data\n-\n-    async def _initiate_upload(self, url: str, object_name: str, params: dict,\n-                               headers: dict, *, metadata: dict = None,\n+        return await self._do_upload(session_uri, stream, headers=headers,\n+                                     session=session, timeout=timeout)\n+\n+    async def _initiate_upload(self, url: str, object_name: str,\n+                               params: Dict[str, str], headers: Dict[str, str],\n+                               *, metadata: Optional[Dict[str, str]] = None,\n                                session: Optional[Session] = None) -> str:\n",
        "source_code_with_indent": "                                                  session=session)\n        data: dict = await self._do_upload(session_uri, stream,\n                                           headers=headers, session=session,\n                                           timeout=timeout)\n        return data\n\n    <DED>async def _initiate_upload(self, url: str, object_name: str, params: dict,\n                               headers: dict, *, metadata: dict = None,\n                               session: Optional[Session] = None) -> str:\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "                                                  session=session)\n        return await self._do_upload(session_uri, stream, headers=headers,\n                                     session=session, timeout=timeout)\n\n    <DED>async def _initiate_upload(self, url: str, object_name: str,\n                               params: Dict[str, str], headers: Dict[str, str],\n                               *, metadata: Optional[Dict[str, str]] = None,\n                               session: Optional[Session] = None) -> str:\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "        metadict.update({'name': object_name})\n        metadata = json.dumps(metadict)\n\n",
        "source_code_len": 88,
        "target_code": "        metadict.update({'name': object_name})\n        metadata_ = json.dumps(metadict)\n\n",
        "target_code_len": 89,
        "diff_format": "@@ -349,3 +358,3 @@\n         metadict.update({'name': object_name})\n-        metadata = json.dumps(metadict)\n+        metadata_ = json.dumps(metadict)\n \n",
        "source_code_with_indent": "        metadict.update({'name': object_name})\n        metadata = json.dumps(metadict)\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "        metadict.update({'name': object_name})\n        metadata_ = json.dumps(metadict)\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "        post_headers.update({\n            'Content-Length': str(len(metadata)),\n            'Content-Type': 'application/json; charset=UTF-8',\n",
        "source_code_len": 143,
        "target_code": "        post_headers.update({\n            'Content-Length': str(len(metadata_)),\n            'Content-Type': 'application/json; charset=UTF-8',\n",
        "target_code_len": 144,
        "diff_format": "@@ -353,3 +362,3 @@\n         post_headers.update({\n-            'Content-Length': str(len(metadata)),\n+            'Content-Length': str(len(metadata_)),\n             'Content-Type': 'application/json; charset=UTF-8',\n",
        "source_code_with_indent": "        post_headers.update({\n            'Content-Length': str(len(metadata)),\n            'Content-Type': 'application/json; charset=UTF-8',\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "        post_headers.update({\n            'Content-Length': str(len(metadata_)),\n            'Content-Type': 'application/json; charset=UTF-8',\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n    async def _do_upload(self, session_uri: str, stream: io.IOBase,\n                         headers: dict, *, retries: int = 5,\n                         session: Optional[Session] = None,\n                         timeout: int = 30) -> dict:\n        s = AioSession(session) if session else self.session\n",
        "source_code_len": 304,
        "target_code": "\n    async def _do_upload(self, session_uri: str, stream: IO[AnyStr],\n                         headers: Dict[str, str], *, retries: int = 5,\n                         session: Optional[Session] = None,\n                         timeout: int = 30) -> Dict[str, Any]:\n        s = AioSession(session) if session else self.session\n",
        "target_code_len": 325,
        "diff_format": "@@ -365,6 +374,6 @@\n \n-    async def _do_upload(self, session_uri: str, stream: io.IOBase,\n-                         headers: dict, *, retries: int = 5,\n+    async def _do_upload(self, session_uri: str, stream: IO[AnyStr],\n+                         headers: Dict[str, str], *, retries: int = 5,\n                          session: Optional[Session] = None,\n-                         timeout: int = 30) -> dict:\n+                         timeout: int = 30) -> Dict[str, Any]:\n         s = AioSession(session) if session else self.session\n",
        "source_code_with_indent": "\n    <DED>async def _do_upload(self, session_uri: str, stream: io.IOBase,\n                         headers: dict, *, retries: int = 5,\n                         session: Optional[Session] = None,\n                         timeout: int = 30) -> dict:\n        <IND>s = AioSession(session) if session else self.session\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n    <DED>async def _do_upload(self, session_uri: str, stream: IO[AnyStr],\n                         headers: Dict[str, str], *, retries: int = 5,\n                         session: Optional[Session] = None,\n                         timeout: int = 30) -> Dict[str, Any]:\n        <IND>s = AioSession(session) if session else self.session\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "talkiq/gcloud-aio",
    "commit": "82af90a9877490b01daff1af609a39a2525d2db2",
    "filename": "storage/gcloud/aio/storage/storage.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/talkiq-gcloud-aio/storage/gcloud/aio/storage/storage.py",
    "file_hunks_size": 30,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "storage/gcloud/aio/storage/storage.py:239:39 Incompatible parameter type [6]: Expected `Optional[requests.sessions.Session]` for 4th positional only parameter to call `Storage.upload` but got `Dict[str, typing.Any]`.",
    "message": " Expected `Optional[requests.sessions.Session]` for 4th positional only parameter to call `Storage.upload` but got `Dict[str, typing.Any]`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 239,
    "warning_line": "                                     **kwargs)",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "                                   filename: str,\n                                   **kwargs: Dict[str, Any]) -> dict:\n        with open(filename, 'rb') as file_object:\n",
        "source_code_len": 170,
        "target_code": "                                   filename: str,\n                                   **kwargs: Any) -> Dict[str, Any]:\n        with open(filename, 'rb') as file_object:\n",
        "target_code_len": 169,
        "diff_format": "@@ -235,3 +242,3 @@\n                                    filename: str,\n-                                   **kwargs: Dict[str, Any]) -> dict:\n+                                   **kwargs: Any) -> Dict[str, Any]:\n         with open(filename, 'rb') as file_object:\n",
        "source_code_with_indent": "                                   filename: str,\n                                   **kwargs: Dict[str, Any]) -> dict:\n        <IND>with open(filename, 'rb') as file_object:\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "                                   filename: str,\n                                   **kwargs: Any) -> Dict[str, Any]:\n        <IND>with open(filename, 'rb') as file_object:\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "talkiq/gcloud-aio",
    "commit": "82af90a9877490b01daff1af609a39a2525d2db2",
    "filename": "storage/gcloud/aio/storage/storage.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/talkiq-gcloud-aio/storage/gcloud/aio/storage/storage.py",
    "file_hunks_size": 30,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "storage/gcloud/aio/storage/storage.py:239:39 Incompatible parameter type [6]: Expected `bool` for 4th positional only parameter to call `Storage.upload` but got `Dict[str, typing.Any]`.",
    "message": " Expected `bool` for 4th positional only parameter to call `Storage.upload` but got `Dict[str, typing.Any]`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 239,
    "warning_line": "                                     **kwargs)",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "                                   filename: str,\n                                   **kwargs: Dict[str, Any]) -> dict:\n        with open(filename, 'rb') as file_object:\n",
        "source_code_len": 170,
        "target_code": "                                   filename: str,\n                                   **kwargs: Any) -> Dict[str, Any]:\n        with open(filename, 'rb') as file_object:\n",
        "target_code_len": 169,
        "diff_format": "@@ -235,3 +242,3 @@\n                                    filename: str,\n-                                   **kwargs: Dict[str, Any]) -> dict:\n+                                   **kwargs: Any) -> Dict[str, Any]:\n         with open(filename, 'rb') as file_object:\n",
        "source_code_with_indent": "                                   filename: str,\n                                   **kwargs: Dict[str, Any]) -> dict:\n        <IND>with open(filename, 'rb') as file_object:\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "                                   filename: str,\n                                   **kwargs: Any) -> Dict[str, Any]:\n        <IND>with open(filename, 'rb') as file_object:\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "talkiq/gcloud-aio",
    "commit": "82af90a9877490b01daff1af609a39a2525d2db2",
    "filename": "storage/gcloud/aio/storage/storage.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/talkiq-gcloud-aio/storage/gcloud/aio/storage/storage.py",
    "file_hunks_size": 30,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "storage/gcloud/aio/storage/storage.py:239:39 Incompatible parameter type [6]: Expected `int` for 4th positional only parameter to call `Storage.upload` but got `Dict[str, typing.Any]`.",
    "message": " Expected `int` for 4th positional only parameter to call `Storage.upload` but got `Dict[str, typing.Any]`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 239,
    "warning_line": "                                     **kwargs)",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "                                   filename: str,\n                                   **kwargs: Dict[str, Any]) -> dict:\n        with open(filename, 'rb') as file_object:\n",
        "source_code_len": 170,
        "target_code": "                                   filename: str,\n                                   **kwargs: Any) -> Dict[str, Any]:\n        with open(filename, 'rb') as file_object:\n",
        "target_code_len": 169,
        "diff_format": "@@ -235,3 +242,3 @@\n                                    filename: str,\n-                                   **kwargs: Dict[str, Any]) -> dict:\n+                                   **kwargs: Any) -> Dict[str, Any]:\n         with open(filename, 'rb') as file_object:\n",
        "source_code_with_indent": "                                   filename: str,\n                                   **kwargs: Dict[str, Any]) -> dict:\n        <IND>with open(filename, 'rb') as file_object:\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "                                   filename: str,\n                                   **kwargs: Any) -> Dict[str, Any]:\n        <IND>with open(filename, 'rb') as file_object:\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "talkiq/gcloud-aio",
    "commit": "82af90a9877490b01daff1af609a39a2525d2db2",
    "filename": "storage/gcloud/aio/storage/storage.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/talkiq-gcloud-aio/storage/gcloud/aio/storage/storage.py",
    "file_hunks_size": 30,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "storage/gcloud/aio/storage/storage.py:239:39 Incompatible parameter type [6]: Expected `str` for 4th positional only parameter to call `Storage.upload` but got `Dict[str, typing.Any]`.",
    "message": " Expected `str` for 4th positional only parameter to call `Storage.upload` but got `Dict[str, typing.Any]`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 239,
    "warning_line": "                                     **kwargs)",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "                                   filename: str,\n                                   **kwargs: Dict[str, Any]) -> dict:\n        with open(filename, 'rb') as file_object:\n",
        "source_code_len": 170,
        "target_code": "                                   filename: str,\n                                   **kwargs: Any) -> Dict[str, Any]:\n        with open(filename, 'rb') as file_object:\n",
        "target_code_len": 169,
        "diff_format": "@@ -235,3 +242,3 @@\n                                    filename: str,\n-                                   **kwargs: Dict[str, Any]) -> dict:\n+                                   **kwargs: Any) -> Dict[str, Any]:\n         with open(filename, 'rb') as file_object:\n",
        "source_code_with_indent": "                                   filename: str,\n                                   **kwargs: Dict[str, Any]) -> dict:\n        <IND>with open(filename, 'rb') as file_object:\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "                                   filename: str,\n                                   **kwargs: Any) -> Dict[str, Any]:\n        <IND>with open(filename, 'rb') as file_object:\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "talkiq/gcloud-aio",
    "commit": "82af90a9877490b01daff1af609a39a2525d2db2",
    "filename": "storage/gcloud/aio/storage/storage.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/talkiq-gcloud-aio/storage/gcloud/aio/storage/storage.py",
    "file_hunks_size": 30,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "storage/gcloud/aio/storage/storage.py:290:8 Incompatible return type [7]: Expected `Tuple[str, str]` but got `Tuple[str, Optional[str]]`.",
    "message": " Expected `Tuple[str, str]` but got `Tuple[str, Optional[str]]`.",
    "rule_id": "Incompatible return type [7]",
    "warning_line_no": 290,
    "warning_line": "        return content_type, encoding",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    @staticmethod\n    def _split_content_type(content_type: str) -> Tuple[str, str]:\n        content_type_and_encoding_split = content_type.split(';')\n",
        "source_code_len": 151,
        "target_code": "    @staticmethod\n    def _split_content_type(content_type: str) -> Tuple[str, Optional[str]]:\n        content_type_and_encoding_split = content_type.split(';')\n",
        "target_code_len": 161,
        "diff_format": "@@ -280,3 +287,3 @@\n     @staticmethod\n-    def _split_content_type(content_type: str) -> Tuple[str, str]:\n+    def _split_content_type(content_type: str) -> Tuple[str, Optional[str]]:\n         content_type_and_encoding_split = content_type.split(';')\n",
        "source_code_with_indent": "    <DED>@staticmethod\n    def _split_content_type(content_type: str) -> Tuple[str, str]:\n        <IND>content_type_and_encoding_split = content_type.split(';')\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    <DED>@staticmethod\n    def _split_content_type(content_type: str) -> Tuple[str, Optional[str]]:\n        <IND>content_type_and_encoding_split = content_type.split(';')\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "talkiq/gcloud-aio",
    "commit": "82af90a9877490b01daff1af609a39a2525d2db2",
    "filename": "storage/gcloud/aio/storage/storage.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/talkiq-gcloud-aio/storage/gcloud/aio/storage/storage.py",
    "file_hunks_size": 30,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": true,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "storage/gcloud/aio/storage/storage.py:293:24 Incompatible variable type [9]: params is declared to have type `Dict[typing.Any, typing.Any]` but is used as type `None`.",
    "message": " params is declared to have type `Dict[typing.Any, typing.Any]` but is used as type `None`.",
    "rule_id": "Incompatible variable type [9]",
    "warning_line_no": 293,
    "warning_line": "                        params: dict = None, timeout: int = 10,",
    "min_patch": [
      {
        "hunk_fit_TFix": true,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    async def _download(self, bucket: str, object_name: str, *,\n                        params: dict = None, timeout: int = 10,\n                        session: Optional[Session] = None) -> bytes:\n",
        "source_code_len": 197,
        "target_code": "    async def _download(self, bucket: str, object_name: str, *,\n                        params: Optional[Dict[str, str]] = None,\n                        timeout: int = 10,\n                        session: Optional[Session] = None) -> bytes:\n",
        "target_code_len": 241,
        "diff_format": "@@ -292,3 +299,4 @@\n     async def _download(self, bucket: str, object_name: str, *,\n-                        params: dict = None, timeout: int = 10,\n+                        params: Optional[Dict[str, str]] = None,\n+                        timeout: int = 10,\n                         session: Optional[Session] = None) -> bytes:\n",
        "source_code_with_indent": "    <DED>async def _download(self, bucket: str, object_name: str, *,\n                        params: dict = None, timeout: int = 10,\n                        session: Optional[Session] = None) -> bytes:\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    <DED>async def _download(self, bucket: str, object_name: str, *,\n                        params: Optional[Dict[str, str]] = None,\n                        timeout: int = 10,\n                        session: Optional[Session] = None) -> bytes:\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "talkiq/gcloud-aio",
    "commit": "82af90a9877490b01daff1af609a39a2525d2db2",
    "filename": "storage/gcloud/aio/storage/storage.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/talkiq-gcloud-aio/storage/gcloud/aio/storage/storage.py",
    "file_hunks_size": 30,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "storage/gcloud/aio/storage/storage.py:331:50 Incompatible variable type [9]: metadata is declared to have type `Dict[typing.Any, typing.Any]` but is used as type `None`.",
    "message": " metadata is declared to have type `Dict[typing.Any, typing.Any]` but is used as type `None`.",
    "rule_id": "Incompatible variable type [9]",
    "warning_line_no": 331,
    "warning_line": "                                headers: dict, *, metadata: dict = None,",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "from typing import Any\nfrom typing import Dict\nfrom typing import Optional\n",
        "source_code_len": 75,
        "target_code": "from typing import Any\nfrom typing import AnyStr\nfrom typing import Dict\nfrom typing import IO\nfrom typing import Optional\n",
        "target_code_len": 123,
        "diff_format": "@@ -7,3 +7,5 @@\n from typing import Any\n+from typing import AnyStr\n from typing import Dict\n+from typing import IO\n from typing import Optional\n",
        "source_code_with_indent": "from typing import Any\nfrom typing import Dict\nfrom typing import Optional\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "from typing import Any\nfrom typing import AnyStr\nfrom typing import Dict\nfrom typing import IO\nfrom typing import Optional\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    @staticmethod\n    def _get_stream_len(stream: io.IOBase) -> int:\n        current = stream.tell()\n",
        "source_code_len": 101,
        "target_code": "    @staticmethod\n    def _get_stream_len(stream: IO[AnyStr]) -> int:\n        current = stream.tell()\n",
        "target_code_len": 102,
        "diff_format": "@@ -241,3 +248,3 @@\n     @staticmethod\n-    def _get_stream_len(stream: io.IOBase) -> int:\n+    def _get_stream_len(stream: IO[AnyStr]) -> int:\n         current = stream.tell()\n",
        "source_code_with_indent": "    <DED><DED>@staticmethod\n    def _get_stream_len(stream: io.IOBase) -> int:\n        <IND>current = stream.tell()\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    <DED><DED>@staticmethod\n    def _get_stream_len(stream: IO[AnyStr]) -> int:\n        <IND>current = stream.tell()\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    @staticmethod\n    def _preprocess_data(data: Any) -> io.IOBase:\n        if data is None:\n",
        "source_code_len": 93,
        "target_code": "    @staticmethod\n    def _preprocess_data(data: Any) -> IO[Any]:\n        if data is None:\n",
        "target_code_len": 91,
        "diff_format": "@@ -249,3 +256,3 @@\n     @staticmethod\n-    def _preprocess_data(data: Any) -> io.IOBase:\n+    def _preprocess_data(data: Any) -> IO[Any]:\n         if data is None:\n",
        "source_code_with_indent": "    <DED><DED>@staticmethod\n    def _preprocess_data(data: Any) -> io.IOBase:\n        <IND>if data is None:\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    <DED><DED>@staticmethod\n    def _preprocess_data(data: Any) -> IO[Any]:\n        <IND>if data is None:\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": true,
        "source_code": "        if isinstance(data, io.IOBase):\n            return data\n\n",
        "source_code_len": 65,
        "target_code": "        if isinstance(data, io.IOBase):\n            return data  # type: ignore[return-value]\n\n",
        "target_code_len": 95,
        "diff_format": "@@ -258,3 +265,3 @@\n         if isinstance(data, io.IOBase):\n-            return data\n+            return data  # type: ignore[return-value]\n \n",
        "source_code_with_indent": "        <DED>if isinstance(data, io.IOBase):\n            <IND>return data\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "        <DED>if isinstance(data, io.IOBase):\n            <IND>return data  # type: ignore[return-value]\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    async def _upload_simple(self, url: str, object_name: str,\n                             stream: io.IOBase, params: dict, headers: dict,\n                             *, session: Optional[Session] = None,\n                             timeout: int = 30) -> dict:\n        # https://cloud.google.com/storage/docs/json_api/v1/how-tos/simple-upload\n",
        "source_code_len": 346,
        "target_code": "    async def _upload_simple(self, url: str, object_name: str,\n                             stream: IO[AnyStr], params: Dict[str, str],\n                             headers: Dict[str, str], *,\n                             session: Optional[Session] = None,\n                             timeout: int = 30) -> Dict[str, Any]:\n        # https://cloud.google.com/storage/docs/json_api/v1/how-tos/simple-upload\n",
        "target_code_len": 406,
        "diff_format": "@@ -313,5 +321,6 @@\n     async def _upload_simple(self, url: str, object_name: str,\n-                             stream: io.IOBase, params: dict, headers: dict,\n-                             *, session: Optional[Session] = None,\n-                             timeout: int = 30) -> dict:\n+                             stream: IO[AnyStr], params: Dict[str, str],\n+                             headers: Dict[str, str], *,\n+                             session: Optional[Session] = None,\n+                             timeout: int = 30) -> Dict[str, Any]:\n         # https://cloud.google.com/storage/docs/json_api/v1/how-tos/simple-upload\n",
        "source_code_with_indent": "    <DED>async def _upload_simple(self, url: str, object_name: str,\n                             stream: io.IOBase, params: dict, headers: dict,\n                             *, session: Optional[Session] = None,\n                             timeout: int = 30) -> dict:\n        # https://cloud.google.com/storage/docs/json_api/v1/how-tos/simple-upload\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    <DED>async def _upload_simple(self, url: str, object_name: str,\n                             stream: IO[AnyStr], params: Dict[str, str],\n                             headers: Dict[str, str], *,\n                             session: Optional[Session] = None,\n                             timeout: int = 30) -> Dict[str, Any]:\n        # https://cloud.google.com/storage/docs/json_api/v1/how-tos/simple-upload\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    async def _upload_resumable(self, url: str, object_name: str,\n                                stream: io.IOBase, params: dict,\n                                headers: dict, *, metadata: dict = None,\n                                session: Optional[Session] = None,\n                                timeout: int = 30) -> dict:\n        # https://cloud.google.com/storage/docs/json_api/v1/how-tos/resumable-upload\n",
        "source_code_len": 416,
        "target_code": "    async def _upload_resumable(self, url: str, object_name: str,\n                                stream: IO[AnyStr], params: Dict[str, str],\n                                headers: Dict[str, str], *,\n                                metadata: Optional[Dict[str, Any]] = None,\n                                session: Optional[Session] = None,\n                                timeout: int = 30) -> Dict[str, Any]:\n        # https://cloud.google.com/storage/docs/json_api/v1/how-tos/resumable-upload\n",
        "target_code_len": 499,
        "diff_format": "@@ -329,6 +338,7 @@\n     async def _upload_resumable(self, url: str, object_name: str,\n-                                stream: io.IOBase, params: dict,\n-                                headers: dict, *, metadata: dict = None,\n+                                stream: IO[AnyStr], params: Dict[str, str],\n+                                headers: Dict[str, str], *,\n+                                metadata: Optional[Dict[str, Any]] = None,\n                                 session: Optional[Session] = None,\n-                                timeout: int = 30) -> dict:\n+                                timeout: int = 30) -> Dict[str, Any]:\n         # https://cloud.google.com/storage/docs/json_api/v1/how-tos/resumable-upload\n",
        "source_code_with_indent": "    <DED>async def _upload_resumable(self, url: str, object_name: str,\n                                stream: io.IOBase, params: dict,\n                                headers: dict, *, metadata: dict = None,\n                                session: Optional[Session] = None,\n                                timeout: int = 30) -> dict:\n        # https://cloud.google.com/storage/docs/json_api/v1/how-tos/resumable-upload\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    <DED>async def _upload_resumable(self, url: str, object_name: str,\n                                stream: IO[AnyStr], params: Dict[str, str],\n                                headers: Dict[str, str], *,\n                                metadata: Optional[Dict[str, Any]] = None,\n                                session: Optional[Session] = None,\n                                timeout: int = 30) -> Dict[str, Any]:\n        # https://cloud.google.com/storage/docs/json_api/v1/how-tos/resumable-upload\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "                                                  session=session)\n        data: dict = await self._do_upload(session_uri, stream,\n                                           headers=headers, session=session,\n                                           timeout=timeout)\n        return data\n\n    async def _initiate_upload(self, url: str, object_name: str, params: dict,\n                               headers: dict, *, metadata: dict = None,\n                               session: Optional[Session] = None) -> str:\n",
        "source_code_len": 514,
        "target_code": "                                                  session=session)\n        return await self._do_upload(session_uri, stream, headers=headers,\n                                     session=session, timeout=timeout)\n\n    async def _initiate_upload(self, url: str, object_name: str,\n                               params: Dict[str, str], headers: Dict[str, str],\n                               *, metadata: Optional[Dict[str, str]] = None,\n                               session: Optional[Session] = None) -> str:\n",
        "target_code_len": 510,
        "diff_format": "@@ -337,9 +347,8 @@\n                                                   session=session)\n-        data: dict = await self._do_upload(session_uri, stream,\n-                                           headers=headers, session=session,\n-                                           timeout=timeout)\n-        return data\n-\n-    async def _initiate_upload(self, url: str, object_name: str, params: dict,\n-                               headers: dict, *, metadata: dict = None,\n+        return await self._do_upload(session_uri, stream, headers=headers,\n+                                     session=session, timeout=timeout)\n+\n+    async def _initiate_upload(self, url: str, object_name: str,\n+                               params: Dict[str, str], headers: Dict[str, str],\n+                               *, metadata: Optional[Dict[str, str]] = None,\n                                session: Optional[Session] = None) -> str:\n",
        "source_code_with_indent": "                                                  session=session)\n        data: dict = await self._do_upload(session_uri, stream,\n                                           headers=headers, session=session,\n                                           timeout=timeout)\n        return data\n\n    <DED>async def _initiate_upload(self, url: str, object_name: str, params: dict,\n                               headers: dict, *, metadata: dict = None,\n                               session: Optional[Session] = None) -> str:\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "                                                  session=session)\n        return await self._do_upload(session_uri, stream, headers=headers,\n                                     session=session, timeout=timeout)\n\n    <DED>async def _initiate_upload(self, url: str, object_name: str,\n                               params: Dict[str, str], headers: Dict[str, str],\n                               *, metadata: Optional[Dict[str, str]] = None,\n                               session: Optional[Session] = None) -> str:\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "        metadict.update({'name': object_name})\n        metadata = json.dumps(metadict)\n\n",
        "source_code_len": 88,
        "target_code": "        metadict.update({'name': object_name})\n        metadata_ = json.dumps(metadict)\n\n",
        "target_code_len": 89,
        "diff_format": "@@ -349,3 +358,3 @@\n         metadict.update({'name': object_name})\n-        metadata = json.dumps(metadict)\n+        metadata_ = json.dumps(metadict)\n \n",
        "source_code_with_indent": "        metadict.update({'name': object_name})\n        metadata = json.dumps(metadict)\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "        metadict.update({'name': object_name})\n        metadata_ = json.dumps(metadict)\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "        post_headers.update({\n            'Content-Length': str(len(metadata)),\n            'Content-Type': 'application/json; charset=UTF-8',\n",
        "source_code_len": 143,
        "target_code": "        post_headers.update({\n            'Content-Length': str(len(metadata_)),\n            'Content-Type': 'application/json; charset=UTF-8',\n",
        "target_code_len": 144,
        "diff_format": "@@ -353,3 +362,3 @@\n         post_headers.update({\n-            'Content-Length': str(len(metadata)),\n+            'Content-Length': str(len(metadata_)),\n             'Content-Type': 'application/json; charset=UTF-8',\n",
        "source_code_with_indent": "        post_headers.update({\n            'Content-Length': str(len(metadata)),\n            'Content-Type': 'application/json; charset=UTF-8',\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "        post_headers.update({\n            'Content-Length': str(len(metadata_)),\n            'Content-Type': 'application/json; charset=UTF-8',\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n    async def _do_upload(self, session_uri: str, stream: io.IOBase,\n                         headers: dict, *, retries: int = 5,\n                         session: Optional[Session] = None,\n                         timeout: int = 30) -> dict:\n        s = AioSession(session) if session else self.session\n",
        "source_code_len": 304,
        "target_code": "\n    async def _do_upload(self, session_uri: str, stream: IO[AnyStr],\n                         headers: Dict[str, str], *, retries: int = 5,\n                         session: Optional[Session] = None,\n                         timeout: int = 30) -> Dict[str, Any]:\n        s = AioSession(session) if session else self.session\n",
        "target_code_len": 325,
        "diff_format": "@@ -365,6 +374,6 @@\n \n-    async def _do_upload(self, session_uri: str, stream: io.IOBase,\n-                         headers: dict, *, retries: int = 5,\n+    async def _do_upload(self, session_uri: str, stream: IO[AnyStr],\n+                         headers: Dict[str, str], *, retries: int = 5,\n                          session: Optional[Session] = None,\n-                         timeout: int = 30) -> dict:\n+                         timeout: int = 30) -> Dict[str, Any]:\n         s = AioSession(session) if session else self.session\n",
        "source_code_with_indent": "\n    <DED>async def _do_upload(self, session_uri: str, stream: io.IOBase,\n                         headers: dict, *, retries: int = 5,\n                         session: Optional[Session] = None,\n                         timeout: int = 30) -> dict:\n        <IND>s = AioSession(session) if session else self.session\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n    <DED>async def _do_upload(self, session_uri: str, stream: IO[AnyStr],\n                         headers: Dict[str, str], *, retries: int = 5,\n                         session: Optional[Session] = None,\n                         timeout: int = 30) -> Dict[str, Any]:\n        <IND>s = AioSession(session) if session else self.session\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "talkiq/gcloud-aio",
    "commit": "82af90a9877490b01daff1af609a39a2525d2db2",
    "filename": "storage/gcloud/aio/storage/storage.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/talkiq-gcloud-aio/storage/gcloud/aio/storage/storage.py",
    "file_hunks_size": 30,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "storage/gcloud/aio/storage/storage.py:344:49 Incompatible variable type [9]: metadata is declared to have type `Dict[typing.Any, typing.Any]` but is used as type `None`.",
    "message": " metadata is declared to have type `Dict[typing.Any, typing.Any]` but is used as type `None`.",
    "rule_id": "Incompatible variable type [9]",
    "warning_line_no": 344,
    "warning_line": "                               headers: dict, *, metadata: dict = None,",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "from typing import Any\nfrom typing import Dict\nfrom typing import Optional\n",
        "source_code_len": 75,
        "target_code": "from typing import Any\nfrom typing import AnyStr\nfrom typing import Dict\nfrom typing import IO\nfrom typing import Optional\n",
        "target_code_len": 123,
        "diff_format": "@@ -7,3 +7,5 @@\n from typing import Any\n+from typing import AnyStr\n from typing import Dict\n+from typing import IO\n from typing import Optional\n",
        "source_code_with_indent": "from typing import Any\nfrom typing import Dict\nfrom typing import Optional\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "from typing import Any\nfrom typing import AnyStr\nfrom typing import Dict\nfrom typing import IO\nfrom typing import Optional\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    @staticmethod\n    def _get_stream_len(stream: io.IOBase) -> int:\n        current = stream.tell()\n",
        "source_code_len": 101,
        "target_code": "    @staticmethod\n    def _get_stream_len(stream: IO[AnyStr]) -> int:\n        current = stream.tell()\n",
        "target_code_len": 102,
        "diff_format": "@@ -241,3 +248,3 @@\n     @staticmethod\n-    def _get_stream_len(stream: io.IOBase) -> int:\n+    def _get_stream_len(stream: IO[AnyStr]) -> int:\n         current = stream.tell()\n",
        "source_code_with_indent": "    <DED><DED>@staticmethod\n    def _get_stream_len(stream: io.IOBase) -> int:\n        <IND>current = stream.tell()\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    <DED><DED>@staticmethod\n    def _get_stream_len(stream: IO[AnyStr]) -> int:\n        <IND>current = stream.tell()\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    @staticmethod\n    def _preprocess_data(data: Any) -> io.IOBase:\n        if data is None:\n",
        "source_code_len": 93,
        "target_code": "    @staticmethod\n    def _preprocess_data(data: Any) -> IO[Any]:\n        if data is None:\n",
        "target_code_len": 91,
        "diff_format": "@@ -249,3 +256,3 @@\n     @staticmethod\n-    def _preprocess_data(data: Any) -> io.IOBase:\n+    def _preprocess_data(data: Any) -> IO[Any]:\n         if data is None:\n",
        "source_code_with_indent": "    <DED><DED>@staticmethod\n    def _preprocess_data(data: Any) -> io.IOBase:\n        <IND>if data is None:\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    <DED><DED>@staticmethod\n    def _preprocess_data(data: Any) -> IO[Any]:\n        <IND>if data is None:\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": true,
        "source_code": "        if isinstance(data, io.IOBase):\n            return data\n\n",
        "source_code_len": 65,
        "target_code": "        if isinstance(data, io.IOBase):\n            return data  # type: ignore[return-value]\n\n",
        "target_code_len": 95,
        "diff_format": "@@ -258,3 +265,3 @@\n         if isinstance(data, io.IOBase):\n-            return data\n+            return data  # type: ignore[return-value]\n \n",
        "source_code_with_indent": "        <DED>if isinstance(data, io.IOBase):\n            <IND>return data\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "        <DED>if isinstance(data, io.IOBase):\n            <IND>return data  # type: ignore[return-value]\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    async def _upload_simple(self, url: str, object_name: str,\n                             stream: io.IOBase, params: dict, headers: dict,\n                             *, session: Optional[Session] = None,\n                             timeout: int = 30) -> dict:\n        # https://cloud.google.com/storage/docs/json_api/v1/how-tos/simple-upload\n",
        "source_code_len": 346,
        "target_code": "    async def _upload_simple(self, url: str, object_name: str,\n                             stream: IO[AnyStr], params: Dict[str, str],\n                             headers: Dict[str, str], *,\n                             session: Optional[Session] = None,\n                             timeout: int = 30) -> Dict[str, Any]:\n        # https://cloud.google.com/storage/docs/json_api/v1/how-tos/simple-upload\n",
        "target_code_len": 406,
        "diff_format": "@@ -313,5 +321,6 @@\n     async def _upload_simple(self, url: str, object_name: str,\n-                             stream: io.IOBase, params: dict, headers: dict,\n-                             *, session: Optional[Session] = None,\n-                             timeout: int = 30) -> dict:\n+                             stream: IO[AnyStr], params: Dict[str, str],\n+                             headers: Dict[str, str], *,\n+                             session: Optional[Session] = None,\n+                             timeout: int = 30) -> Dict[str, Any]:\n         # https://cloud.google.com/storage/docs/json_api/v1/how-tos/simple-upload\n",
        "source_code_with_indent": "    <DED>async def _upload_simple(self, url: str, object_name: str,\n                             stream: io.IOBase, params: dict, headers: dict,\n                             *, session: Optional[Session] = None,\n                             timeout: int = 30) -> dict:\n        # https://cloud.google.com/storage/docs/json_api/v1/how-tos/simple-upload\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    <DED>async def _upload_simple(self, url: str, object_name: str,\n                             stream: IO[AnyStr], params: Dict[str, str],\n                             headers: Dict[str, str], *,\n                             session: Optional[Session] = None,\n                             timeout: int = 30) -> Dict[str, Any]:\n        # https://cloud.google.com/storage/docs/json_api/v1/how-tos/simple-upload\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    async def _upload_resumable(self, url: str, object_name: str,\n                                stream: io.IOBase, params: dict,\n                                headers: dict, *, metadata: dict = None,\n                                session: Optional[Session] = None,\n                                timeout: int = 30) -> dict:\n        # https://cloud.google.com/storage/docs/json_api/v1/how-tos/resumable-upload\n",
        "source_code_len": 416,
        "target_code": "    async def _upload_resumable(self, url: str, object_name: str,\n                                stream: IO[AnyStr], params: Dict[str, str],\n                                headers: Dict[str, str], *,\n                                metadata: Optional[Dict[str, Any]] = None,\n                                session: Optional[Session] = None,\n                                timeout: int = 30) -> Dict[str, Any]:\n        # https://cloud.google.com/storage/docs/json_api/v1/how-tos/resumable-upload\n",
        "target_code_len": 499,
        "diff_format": "@@ -329,6 +338,7 @@\n     async def _upload_resumable(self, url: str, object_name: str,\n-                                stream: io.IOBase, params: dict,\n-                                headers: dict, *, metadata: dict = None,\n+                                stream: IO[AnyStr], params: Dict[str, str],\n+                                headers: Dict[str, str], *,\n+                                metadata: Optional[Dict[str, Any]] = None,\n                                 session: Optional[Session] = None,\n-                                timeout: int = 30) -> dict:\n+                                timeout: int = 30) -> Dict[str, Any]:\n         # https://cloud.google.com/storage/docs/json_api/v1/how-tos/resumable-upload\n",
        "source_code_with_indent": "    <DED>async def _upload_resumable(self, url: str, object_name: str,\n                                stream: io.IOBase, params: dict,\n                                headers: dict, *, metadata: dict = None,\n                                session: Optional[Session] = None,\n                                timeout: int = 30) -> dict:\n        # https://cloud.google.com/storage/docs/json_api/v1/how-tos/resumable-upload\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    <DED>async def _upload_resumable(self, url: str, object_name: str,\n                                stream: IO[AnyStr], params: Dict[str, str],\n                                headers: Dict[str, str], *,\n                                metadata: Optional[Dict[str, Any]] = None,\n                                session: Optional[Session] = None,\n                                timeout: int = 30) -> Dict[str, Any]:\n        # https://cloud.google.com/storage/docs/json_api/v1/how-tos/resumable-upload\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "                                                  session=session)\n        data: dict = await self._do_upload(session_uri, stream,\n                                           headers=headers, session=session,\n                                           timeout=timeout)\n        return data\n\n    async def _initiate_upload(self, url: str, object_name: str, params: dict,\n                               headers: dict, *, metadata: dict = None,\n                               session: Optional[Session] = None) -> str:\n",
        "source_code_len": 514,
        "target_code": "                                                  session=session)\n        return await self._do_upload(session_uri, stream, headers=headers,\n                                     session=session, timeout=timeout)\n\n    async def _initiate_upload(self, url: str, object_name: str,\n                               params: Dict[str, str], headers: Dict[str, str],\n                               *, metadata: Optional[Dict[str, str]] = None,\n                               session: Optional[Session] = None) -> str:\n",
        "target_code_len": 510,
        "diff_format": "@@ -337,9 +347,8 @@\n                                                   session=session)\n-        data: dict = await self._do_upload(session_uri, stream,\n-                                           headers=headers, session=session,\n-                                           timeout=timeout)\n-        return data\n-\n-    async def _initiate_upload(self, url: str, object_name: str, params: dict,\n-                               headers: dict, *, metadata: dict = None,\n+        return await self._do_upload(session_uri, stream, headers=headers,\n+                                     session=session, timeout=timeout)\n+\n+    async def _initiate_upload(self, url: str, object_name: str,\n+                               params: Dict[str, str], headers: Dict[str, str],\n+                               *, metadata: Optional[Dict[str, str]] = None,\n                                session: Optional[Session] = None) -> str:\n",
        "source_code_with_indent": "                                                  session=session)\n        data: dict = await self._do_upload(session_uri, stream,\n                                           headers=headers, session=session,\n                                           timeout=timeout)\n        return data\n\n    <DED>async def _initiate_upload(self, url: str, object_name: str, params: dict,\n                               headers: dict, *, metadata: dict = None,\n                               session: Optional[Session] = None) -> str:\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "                                                  session=session)\n        return await self._do_upload(session_uri, stream, headers=headers,\n                                     session=session, timeout=timeout)\n\n    <DED>async def _initiate_upload(self, url: str, object_name: str,\n                               params: Dict[str, str], headers: Dict[str, str],\n                               *, metadata: Optional[Dict[str, str]] = None,\n                               session: Optional[Session] = None) -> str:\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "        metadict.update({'name': object_name})\n        metadata = json.dumps(metadict)\n\n",
        "source_code_len": 88,
        "target_code": "        metadict.update({'name': object_name})\n        metadata_ = json.dumps(metadict)\n\n",
        "target_code_len": 89,
        "diff_format": "@@ -349,3 +358,3 @@\n         metadict.update({'name': object_name})\n-        metadata = json.dumps(metadict)\n+        metadata_ = json.dumps(metadict)\n \n",
        "source_code_with_indent": "        metadict.update({'name': object_name})\n        metadata = json.dumps(metadict)\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "        metadict.update({'name': object_name})\n        metadata_ = json.dumps(metadict)\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "        post_headers.update({\n            'Content-Length': str(len(metadata)),\n            'Content-Type': 'application/json; charset=UTF-8',\n",
        "source_code_len": 143,
        "target_code": "        post_headers.update({\n            'Content-Length': str(len(metadata_)),\n            'Content-Type': 'application/json; charset=UTF-8',\n",
        "target_code_len": 144,
        "diff_format": "@@ -353,3 +362,3 @@\n         post_headers.update({\n-            'Content-Length': str(len(metadata)),\n+            'Content-Length': str(len(metadata_)),\n             'Content-Type': 'application/json; charset=UTF-8',\n",
        "source_code_with_indent": "        post_headers.update({\n            'Content-Length': str(len(metadata)),\n            'Content-Type': 'application/json; charset=UTF-8',\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "        post_headers.update({\n            'Content-Length': str(len(metadata_)),\n            'Content-Type': 'application/json; charset=UTF-8',\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n    async def _do_upload(self, session_uri: str, stream: io.IOBase,\n                         headers: dict, *, retries: int = 5,\n                         session: Optional[Session] = None,\n                         timeout: int = 30) -> dict:\n        s = AioSession(session) if session else self.session\n",
        "source_code_len": 304,
        "target_code": "\n    async def _do_upload(self, session_uri: str, stream: IO[AnyStr],\n                         headers: Dict[str, str], *, retries: int = 5,\n                         session: Optional[Session] = None,\n                         timeout: int = 30) -> Dict[str, Any]:\n        s = AioSession(session) if session else self.session\n",
        "target_code_len": 325,
        "diff_format": "@@ -365,6 +374,6 @@\n \n-    async def _do_upload(self, session_uri: str, stream: io.IOBase,\n-                         headers: dict, *, retries: int = 5,\n+    async def _do_upload(self, session_uri: str, stream: IO[AnyStr],\n+                         headers: Dict[str, str], *, retries: int = 5,\n                          session: Optional[Session] = None,\n-                         timeout: int = 30) -> dict:\n+                         timeout: int = 30) -> Dict[str, Any]:\n         s = AioSession(session) if session else self.session\n",
        "source_code_with_indent": "\n    <DED>async def _do_upload(self, session_uri: str, stream: io.IOBase,\n                         headers: dict, *, retries: int = 5,\n                         session: Optional[Session] = None,\n                         timeout: int = 30) -> dict:\n        <IND>s = AioSession(session) if session else self.session\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n    <DED>async def _do_upload(self, session_uri: str, stream: IO[AnyStr],\n                         headers: Dict[str, str], *, retries: int = 5,\n                         session: Optional[Session] = None,\n                         timeout: int = 30) -> Dict[str, Any]:\n        <IND>s = AioSession(session) if session else self.session\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "talkiq/gcloud-aio",
    "commit": "82af90a9877490b01daff1af609a39a2525d2db2",
    "filename": "storage/gcloud/aio/storage/storage.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/talkiq-gcloud-aio/storage/gcloud/aio/storage/storage.py",
    "file_hunks_size": 30,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": true,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "storage/gcloud/aio/storage/storage.py:350:8 Incompatible variable type [9]: metadata is declared to have type `Dict[typing.Any, typing.Any]` but is used as type `str`.",
    "message": " metadata is declared to have type `Dict[typing.Any, typing.Any]` but is used as type `str`.",
    "rule_id": "Incompatible variable type [9]",
    "warning_line_no": 350,
    "warning_line": "        metadata = json.dumps(metadict)",
    "min_patch": [
      {
        "hunk_fit_TFix": true,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "        metadict.update({'name': object_name})\n        metadata = json.dumps(metadict)\n\n",
        "source_code_len": 88,
        "target_code": "        metadict.update({'name': object_name})\n        metadata_ = json.dumps(metadict)\n\n",
        "target_code_len": 89,
        "diff_format": "@@ -349,3 +358,3 @@\n         metadict.update({'name': object_name})\n-        metadata = json.dumps(metadict)\n+        metadata_ = json.dumps(metadict)\n \n",
        "source_code_with_indent": "        metadict.update({'name': object_name})\n        metadata = json.dumps(metadict)\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "        metadict.update({'name': object_name})\n        metadata_ = json.dumps(metadict)\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "talkiq/gcloud-aio",
    "commit": "82af90a9877490b01daff1af609a39a2525d2db2",
    "filename": "storage/gcloud/aio/storage/storage.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/talkiq-gcloud-aio/storage/gcloud/aio/storage/storage.py",
    "file_hunks_size": 30,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "storage/gcloud/aio/storage/storage.py:387:56 Incompatible variable type [9]: params is declared to have type `Dict[typing.Any, typing.Any]` but is used as type `None`.",
    "message": " params is declared to have type `Dict[typing.Any, typing.Any]` but is used as type `None`.",
    "rule_id": "Incompatible variable type [9]",
    "warning_line_no": 387,
    "warning_line": "    async def get_bucket_metadata(self, bucket: str, *, params: dict = None,",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n        data: dict = await resp.json(content_type=None)\n        return data\n\n    async def get_bucket_metadata(self, bucket: str, *, params: dict = None,\n                                  session: Optional[Session] = None,\n                                  timeout: int = 10) -> dict:\n        url = f'{API_ROOT}/{bucket}'\n",
        "source_code_len": 323,
        "target_code": "\n        data: Dict[str, Any] = await resp.json(content_type=None)\n        return data\n\n    async def get_bucket_metadata(self, bucket: str, *,\n                                  params: Optional[Dict[str, str]] = None,\n                                  session: Optional[Session] = None,\n                                  timeout: int = 10) -> Dict[str, Any]:\n        url = f'{API_ROOT}/{bucket}'\n",
        "target_code_len": 397,
        "diff_format": "@@ -383,8 +392,9 @@\n \n-        data: dict = await resp.json(content_type=None)\n-        return data\n-\n-    async def get_bucket_metadata(self, bucket: str, *, params: dict = None,\n+        data: Dict[str, Any] = await resp.json(content_type=None)\n+        return data\n+\n+    async def get_bucket_metadata(self, bucket: str, *,\n+                                  params: Optional[Dict[str, str]] = None,\n                                   session: Optional[Session] = None,\n-                                  timeout: int = 10) -> dict:\n+                                  timeout: int = 10) -> Dict[str, Any]:\n         url = f'{API_ROOT}/{bucket}'\n",
        "source_code_with_indent": "\n        <DED>data: dict = await resp.json(content_type=None)\n        return data\n\n    <DED>async def get_bucket_metadata(self, bucket: str, *, params: dict = None,\n                                  session: Optional[Session] = None,\n                                  timeout: int = 10) -> dict:\n        <IND>url = f'{API_ROOT}/{bucket}'\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n        <DED>data: Dict[str, Any] = await resp.json(content_type=None)\n        return data\n\n    <DED>async def get_bucket_metadata(self, bucket: str, *,\n                                  params: Optional[Dict[str, str]] = None,\n                                  session: Optional[Session] = None,\n                                  timeout: int = 10) -> Dict[str, Any]:\n        <IND>url = f'{API_ROOT}/{bucket}'\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  }
]