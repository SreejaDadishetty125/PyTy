[
  {
    "project": "cocotb/cocotb",
    "commit": "d5b532d559b061d3054a64253672094a26cba322",
    "filename": "cocotb/types/array.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/cocotb-cocotb/cocotb/types/array.py",
    "file_hunks_size": 10,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "cocotb/types/array.py:210:4 Inconsistent override [14]: `cocotb.types.array.Array.__contains__` overrides method defined in `typing.Sequence` inconsistently. Could not find parameter `x` in overriding signature.",
    "message": " `cocotb.types.array.Array.__contains__` overrides method defined in `typing.Sequence` inconsistently. Could not find parameter `x` in overriding signature.",
    "rule_id": "Inconsistent override [14]",
    "warning_line_no": 210,
    "warning_line": "    def __contains__(self, item: Any) -> bool:",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "# SPDX-License-Identifier: BSD-3-Clause\nfrom typing import Optional, Any, Iterable, Iterator, overload\nfrom collections.abc import Sequence\nfrom .range import Range\nfrom sys import maxsize\n\n\nclass Array(Sequence):\n    r\"\"\"\n    Fixed-size, arbitrarily-indexed, heterogeneous sequence type.\n\n",
        "source_code_len": 290,
        "target_code": "# SPDX-License-Identifier: BSD-3-Clause\nimport typing\nfrom itertools import chain\n\nfrom cocotb.types.range import Range\n\nT = typing.TypeVar(\"T\")\nS = typing.TypeVar(\"S\")\nSelf = typing.TypeVar(\"Self\", bound=\"Array[typing.Any]\")\n\n\nclass Array(typing.Reversible[T], typing.Collection[T]):\n    r\"\"\"\n    Fixed-size, arbitrarily-indexed, homogeneous collection type.\n\n",
        "target_code_len": 361,
        "diff_format": "@@ -3,11 +3,15 @@\n # SPDX-License-Identifier: BSD-3-Clause\n-from typing import Optional, Any, Iterable, Iterator, overload\n-from collections.abc import Sequence\n-from .range import Range\n-from sys import maxsize\n-\n-\n-class Array(Sequence):\n+import typing\n+from itertools import chain\n+\n+from cocotb.types.range import Range\n+\n+T = typing.TypeVar(\"T\")\n+S = typing.TypeVar(\"S\")\n+Self = typing.TypeVar(\"Self\", bound=\"Array[typing.Any]\")\n+\n+\n+class Array(typing.Reversible[T], typing.Collection[T]):\n     r\"\"\"\n-    Fixed-size, arbitrarily-indexed, heterogeneous sequence type.\n+    Fixed-size, arbitrarily-indexed, homogeneous collection type.\n \n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "# SPDX-License-Identifier: BSD-3-Clause\nfrom typing import Optional, Any, Iterable, Iterator, overload\nfrom collections.abc import Sequence\nfrom .range import Range\nfrom sys import maxsize\n\n\nclass Array(Sequence):\n    <IND>",
        "target_code_with_indent": "# SPDX-License-Identifier: BSD-3-Clause\nimport typing\nfrom itertools import chain\n\nfrom cocotb.types.range import Range\n\nT = typing.TypeVar(\"T\")\nS = typing.TypeVar(\"S\")\nSelf = typing.TypeVar(\"Self\", bound=\"Array[typing.Any]\")\n\n\nclass Array(typing.Reversible[T], typing.Collection[T]):\n    <IND>"
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n    _value: Sequence\n    \"\"\"\n    Private interface for subclasses to access the value as a :class:`~collections.abc.Sequence`\n\n    Subclasses that don't use a Sequence as their main representation should emulate this object,\n    or override *all* :class:`~cocotb.types.Array` methods *except*:\n        - :attr:`left`\n        - :attr:`direction`\n        - :attr:`right`\n        - :attr:`range`\n        - :attr:`__len__`\n        - :attr:`_translate_index`\n    \"\"\"\n\n    def __init__(\n        self, value: Optional[Iterable[Any]] = None, range: Optional[Range] = None\n    ):\n        if value is not None and range is None:\n            self._value = list(value)\n            self._range = Range(0, \"to\", len(self._value) - 1)\n        elif value is not None and range is not None:\n            if not isinstance(range, Range):\n                raise TypeError(\"range argument must be of type 'Range'\")\n            self._value = list(value)\n            self._range = range\n",
        "source_code_len": 964,
        "target_code": "\n    def __init__(self, value: typing.Iterable[T], range: typing.Optional[Range] = None):\n        self._value = list(value)\n        if range is None:\n            self._range = Range(0, \"to\", len(self._value) - 1)\n        else:\n            self._range = range\n",
        "target_code_len": 259,
        "diff_format": "@@ -130,26 +131,7 @@\n \n-    _value: Sequence\n-    \"\"\"\n-    Private interface for subclasses to access the value as a :class:`~collections.abc.Sequence`\n-\n-    Subclasses that don't use a Sequence as their main representation should emulate this object,\n-    or override *all* :class:`~cocotb.types.Array` methods *except*:\n-        - :attr:`left`\n-        - :attr:`direction`\n-        - :attr:`right`\n-        - :attr:`range`\n-        - :attr:`__len__`\n-        - :attr:`_translate_index`\n-    \"\"\"\n-\n-    def __init__(\n-        self, value: Optional[Iterable[Any]] = None, range: Optional[Range] = None\n-    ):\n-        if value is not None and range is None:\n-            self._value = list(value)\n+    def __init__(self, value: typing.Iterable[T], range: typing.Optional[Range] = None):\n+        self._value = list(value)\n+        if range is None:\n             self._range = Range(0, \"to\", len(self._value) - 1)\n-        elif value is not None and range is not None:\n-            if not isinstance(range, Range):\n-                raise TypeError(\"range argument must be of type 'Range'\")\n-            self._value = list(value)\n+        else:\n             self._range = range\n",
        "source_code_with_indent": "\n    _value: Sequence\n    \"\"\"\n    Private interface for subclasses to access the value as a :class:`~collections.abc.Sequence`\n\n    Subclasses that don't use a Sequence as their main representation should emulate this object,\n    or override *all* :class:`~cocotb.types.Array` methods *except*:\n        - :attr:`left`\n        - :attr:`direction`\n        - :attr:`right`\n        - :attr:`range`\n        - :attr:`__len__`\n        - :attr:`_translate_index`\n    \"\"\"\n\n    def __init__(\n        self, value: Optional[Iterable[Any]] = None, range: Optional[Range] = None\n    ):\n        <IND>if value is not None and range is None:\n            <IND>self._value = list(value)\n            self._range = Range(0, \"to\", len(self._value) - 1)\n        <DED>elif value is not None and range is not None:\n            <IND>if not isinstance(range, Range):\n                <IND>raise TypeError(\"range argument must be of type 'Range'\")\n            <DED>self._value = list(value)\n            self._range = range\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n    def __init__(self, value: typing.Iterable[T], range: typing.Optional[Range] = None):\n        <IND>self._value = list(value)\n        if range is None:\n            <IND>self._range = Range(0, \"to\", len(self._value) - 1)\n        <DED>else:\n            <IND>self._range = range\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": true,
        "has_suppression": false,
        "source_code": "                )\n        elif value is None and range is not None:\n            if not isinstance(range, Range):\n                raise TypeError(\"range argument must be of type 'Range'\")\n            self._value = [None] * len(range)\n            self._range = range\n        else:\n            raise TypeError(\"must pass a value, range, or both\")\n\n",
        "source_code_len": 345,
        "target_code": "                )\n\n",
        "target_code_len": 19,
        "diff_format": "@@ -161,9 +143,2 @@\n                 )\n-        elif value is None and range is not None:\n-            if not isinstance(range, Range):\n-                raise TypeError(\"range argument must be of type 'Range'\")\n-            self._value = [None] * len(range)\n-            self._range = range\n-        else:\n-            raise TypeError(\"must pass a value, range, or both\")\n \n",
        "source_code_with_indent": "                )\n        <DED><DED>elif value is None and range is not None:\n            <IND>if not isinstance(range, Range):\n                <IND>raise TypeError(\"range argument must be of type 'Range'\")\n            <DED>self._value = [None] * len(range)\n            self._range = range\n        <DED>else:\n            <IND>raise TypeError(\"must pass a value, range, or both\")\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "                )\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n    def __iter__(self) -> Iterator[Any]:\n        return iter(self._value)\n\n    def __reversed__(self) -> Iterator[Any]:\n        return reversed(self._value)\n\n    def __contains__(self, item: Any) -> bool:\n        return item in self._value\n\n    def __eq__(self, other: Any) -> bool:\n        if not isinstance(other, type(self)):\n            return NotImplemented\n        return self._value == other._value\n\n    @overload\n    def __getitem__(self, item: int) -> Any:\n        pass  # pragma: no cover\n\n    @overload\n    def __getitem__(self, item: slice) -> \"Array\":\n        pass  # pragma: no cover\n\n    def __getitem__(self, item):\n        if isinstance(item, int):\n",
        "source_code_len": 667,
        "target_code": "\n    def __iter__(self) -> typing.Iterator[T]:\n        return iter(self._value)\n\n    def __reversed__(self) -> typing.Iterator[T]:\n        return reversed(self._value)\n\n    def __contains__(self, item: object) -> bool:\n        return item in self._value\n\n    def __eq__(self, other: object) -> bool:\n        if isinstance(other, type(self)):\n            return self._value == other._value\n        return NotImplemented\n\n    @typing.overload\n    def __getitem__(self, item: int) -> T:\n        ...\n\n    @typing.overload\n    def __getitem__(self, item: slice) -> \"Array[T]\":\n        ...\n\n    def __getitem__(\n        self, item: typing.Union[int, slice]\n    ) -> typing.Union[T, \"Array[T]\"]:\n        if isinstance(item, int):\n",
        "target_code_len": 723,
        "diff_format": "@@ -203,25 +178,27 @@\n \n-    def __iter__(self) -> Iterator[Any]:\n+    def __iter__(self) -> typing.Iterator[T]:\n         return iter(self._value)\n \n-    def __reversed__(self) -> Iterator[Any]:\n+    def __reversed__(self) -> typing.Iterator[T]:\n         return reversed(self._value)\n \n-    def __contains__(self, item: Any) -> bool:\n+    def __contains__(self, item: object) -> bool:\n         return item in self._value\n \n-    def __eq__(self, other: Any) -> bool:\n-        if not isinstance(other, type(self)):\n-            return NotImplemented\n-        return self._value == other._value\n-\n-    @overload\n-    def __getitem__(self, item: int) -> Any:\n-        pass  # pragma: no cover\n-\n-    @overload\n-    def __getitem__(self, item: slice) -> \"Array\":\n-        pass  # pragma: no cover\n-\n-    def __getitem__(self, item):\n+    def __eq__(self, other: object) -> bool:\n+        if isinstance(other, type(self)):\n+            return self._value == other._value\n+        return NotImplemented\n+\n+    @typing.overload\n+    def __getitem__(self, item: int) -> T:\n+        ...\n+\n+    @typing.overload\n+    def __getitem__(self, item: slice) -> \"Array[T]\":\n+        ...\n+\n+    def __getitem__(\n+        self, item: typing.Union[int, slice]\n+    ) -> typing.Union[T, \"Array[T]\"]:\n         if isinstance(item, int):\n",
        "source_code_with_indent": "\n    <DED>def __iter__(self) -> Iterator[Any]:\n        <IND>return iter(self._value)\n\n    <DED>def __reversed__(self) -> Iterator[Any]:\n        <IND>return reversed(self._value)\n\n    <DED>def __contains__(self, item: Any) -> bool:\n        <IND>return item in self._value\n\n    <DED>def __eq__(self, other: Any) -> bool:\n        <IND>if not isinstance(other, type(self)):\n            <IND>return NotImplemented\n        <DED>return self._value == other._value\n\n    <DED>@overload\n    def __getitem__(self, item: int) -> Any:\n        <IND>pass  # pragma: no cover\n\n    <DED>@overload\n    def __getitem__(self, item: slice) -> \"Array\":\n        <IND>pass  # pragma: no cover\n\n    <DED>def __getitem__(self, item):\n        <IND>if isinstance(item, int):\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n    <DED>def __iter__(self) -> typing.Iterator[T]:\n        <IND>return iter(self._value)\n\n    <DED>def __reversed__(self) -> typing.Iterator[T]:\n        <IND>return reversed(self._value)\n\n    <DED>def __contains__(self, item: object) -> bool:\n        <IND>return item in self._value\n\n    <DED>def __eq__(self, other: object) -> bool:\n        <IND>if isinstance(other, type(self)):\n            <IND>return self._value == other._value\n        <DED>return NotImplemented\n\n    <DED>@typing.overload\n    def __getitem__(self, item: int) -> T:\n        <IND>...\n\n    <DED>@typing.overload\n    def __getitem__(self, item: slice) -> \"Array[T]\":\n        <IND>...\n\n    <DED>def __getitem__(\n        self, item: typing.Union[int, slice]\n    ) -> typing.Union[T, \"Array[T]\"]:\n        <IND>if isinstance(item, int):\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n    @overload\n    def __setitem__(self, item: int, value: Any) -> None:\n        pass  # pragma: no cover\n\n    @overload\n    def __setitem__(self, item: slice, value: Iterable[Any]) -> None:\n        pass  # pragma: no cover\n\n    def __setitem__(self, item, value):\n        if isinstance(item, int):\n            idx = self._translate_index(item)\n            self._value[idx] = value\n        elif isinstance(item, slice):\n",
        "source_code_len": 420,
        "target_code": "\n    @typing.overload\n    def __setitem__(self, item: int, value: T) -> None:\n        ...\n\n    @typing.overload\n    def __setitem__(self, item: slice, value: typing.Iterable[T]) -> None:\n        ...\n\n    def __setitem__(\n        self, item: typing.Union[int, slice], value: typing.Union[T, typing.Iterable[T]]\n    ) -> None:\n        if isinstance(item, int):\n            idx = self._translate_index(item)\n            self._value[idx] = typing.cast(T, value)\n        elif isinstance(item, slice):\n",
        "target_code_len": 496,
        "diff_format": "@@ -249,14 +226,16 @@\n \n-    @overload\n-    def __setitem__(self, item: int, value: Any) -> None:\n-        pass  # pragma: no cover\n-\n-    @overload\n-    def __setitem__(self, item: slice, value: Iterable[Any]) -> None:\n-        pass  # pragma: no cover\n-\n-    def __setitem__(self, item, value):\n+    @typing.overload\n+    def __setitem__(self, item: int, value: T) -> None:\n+        ...\n+\n+    @typing.overload\n+    def __setitem__(self, item: slice, value: typing.Iterable[T]) -> None:\n+        ...\n+\n+    def __setitem__(\n+        self, item: typing.Union[int, slice], value: typing.Union[T, typing.Iterable[T]]\n+    ) -> None:\n         if isinstance(item, int):\n             idx = self._translate_index(item)\n-            self._value[idx] = value\n+            self._value[idx] = typing.cast(T, value)\n         elif isinstance(item, slice):\n",
        "source_code_with_indent": "\n    <DED>@overload\n    def __setitem__(self, item: int, value: Any) -> None:\n        <IND>pass  # pragma: no cover\n\n    <DED>@overload\n    def __setitem__(self, item: slice, value: Iterable[Any]) -> None:\n        <IND>pass  # pragma: no cover\n\n    <DED>def __setitem__(self, item, value):\n        <IND>if isinstance(item, int):\n            <IND>idx = self._translate_index(item)\n            self._value[idx] = value\n        <DED>elif isinstance(item, slice):\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n    <DED>@typing.overload\n    def __setitem__(self, item: int, value: T) -> None:\n        <IND>...\n\n    <DED>@typing.overload\n    def __setitem__(self, item: slice, value: typing.Iterable[T]) -> None:\n        <IND>...\n\n    <DED>def __setitem__(\n        self, item: typing.Union[int, slice], value: typing.Union[T, typing.Iterable[T]]\n    ) -> None:\n        <IND>if isinstance(item, int):\n            <IND>idx = self._translate_index(item)\n            self._value[idx] = typing.cast(T, value)\n        <DED>elif isinstance(item, slice):\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "                )\n            value = list(value)\n            if len(value) != (stop_i - start_i + 1):\n",
        "source_code_len": 103,
        "target_code": "                )\n            value = list(typing.cast(typing.Iterable[T], value))\n            if len(value) != (stop_i - start_i + 1):\n",
        "target_code_len": 136,
        "diff_format": "@@ -274,3 +253,3 @@\n                 )\n-            value = list(value)\n+            value = list(typing.cast(typing.Iterable[T], value))\n             if len(value) != (stop_i - start_i + 1):\n",
        "source_code_with_indent": "                )\n            <DED>value = list(value)\n            if len(value) != (stop_i - start_i + 1):\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "                )\n            <DED>value = list(typing.cast(typing.Iterable[T], value))\n            if len(value) != (stop_i - start_i + 1):\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n    def __concat__(self, other: \"Array\") -> \"Array\":\n        if not isinstance(other, type(self)):\n            return NotImplemented\n        return type(self)(self._value + other._value)\n\n    def __rconcat__(self, other: \"Array\") -> \"Array\":\n        if not isinstance(other, type(self)):\n            return NotImplemented\n        return type(self)(other._value + self._value)\n\n    def index(\n        self, value: Any, start: Optional[int] = None, stop: Optional[int] = None\n    ) -> int:\n",
        "source_code_len": 489,
        "target_code": "\n    def __concat__(self: Self, other: Self) -> Self:\n        if isinstance(other, type(self)):\n            return type(self)(chain(self, other))\n        return NotImplemented\n\n    def __rconcat__(self: Self, other: Self) -> Self:\n        if isinstance(other, type(self)):\n            return type(self)(chain(other, self))\n        return NotImplemented\n\n    def index(\n        self,\n        value: T,\n        start: typing.Optional[int] = None,\n        stop: typing.Optional[int] = None,\n    ) -> int:\n",
        "target_code_len": 502,
        "diff_format": "@@ -290,14 +269,17 @@\n \n-    def __concat__(self, other: \"Array\") -> \"Array\":\n-        if not isinstance(other, type(self)):\n-            return NotImplemented\n-        return type(self)(self._value + other._value)\n-\n-    def __rconcat__(self, other: \"Array\") -> \"Array\":\n-        if not isinstance(other, type(self)):\n-            return NotImplemented\n-        return type(self)(other._value + self._value)\n+    def __concat__(self: Self, other: Self) -> Self:\n+        if isinstance(other, type(self)):\n+            return type(self)(chain(self, other))\n+        return NotImplemented\n+\n+    def __rconcat__(self: Self, other: Self) -> Self:\n+        if isinstance(other, type(self)):\n+            return type(self)(chain(other, self))\n+        return NotImplemented\n \n     def index(\n-        self, value: Any, start: Optional[int] = None, stop: Optional[int] = None\n+        self,\n+        value: T,\n+        start: typing.Optional[int] = None,\n+        stop: typing.Optional[int] = None,\n     ) -> int:\n",
        "source_code_with_indent": "\n    <DED>def __concat__(self, other: \"Array\") -> \"Array\":\n        <IND>if not isinstance(other, type(self)):\n            <IND>return NotImplemented\n        <DED>return type(self)(self._value + other._value)\n\n    <DED>def __rconcat__(self, other: \"Array\") -> \"Array\":\n        <IND>if not isinstance(other, type(self)):\n            <IND>return NotImplemented\n        <DED>return type(self)(other._value + self._value)\n\n    <DED>def index(\n        self, value: Any, start: Optional[int] = None, stop: Optional[int] = None\n    ) -> int:\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n    <DED>def __concat__(self: Self, other: Self) -> Self:\n        <IND>if isinstance(other, type(self)):\n            <IND>return type(self)(chain(self, other))\n        <DED>return NotImplemented\n\n    <DED>def __rconcat__(self: Self, other: Self) -> Self:\n        <IND>if isinstance(other, type(self)):\n            <IND>return type(self)(chain(other, self))\n        <DED>return NotImplemented\n\n    <DED>def index(\n        self,\n        value: T,\n        start: typing.Optional[int] = None,\n        stop: typing.Optional[int] = None,\n    ) -> int:\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n        Raises :exc:`ValueError` if the value is not found.\n        Search only within *start* and *stop* if given.\n        \"\"\"\n        if start is not None:\n            start = self._translate_index(start)\n        else:\n            start = 0\n        if stop is not None:\n            stop = self._translate_index(stop)\n        else:\n            stop = maxsize  # same default value used by Python lists\n        idx = self._value.index(value, start, stop)\n        return self._range[idx]\n\n    def count(self, value: Any) -> int:\n        \"\"\"Return number of occurrences of *value*.\"\"\"\n",
        "source_code_len": 584,
        "target_code": "\n        Raises :exc:`IndexError` if the value is not found.\n        Search only within *start* and *stop* if given.\n        \"\"\"\n        if start is None:\n            start = self.left\n        if stop is None:\n            stop = self.right\n        for i in Range(start, self.direction, stop):\n            if self[i] == value:\n                return i\n        raise IndexError(f\"{value!r} not in array\")\n\n    def count(self, value: T) -> int:\n        \"\"\"Return number of occurrences of *value*.\"\"\"\n",
        "target_code_len": 497,
        "diff_format": "@@ -306,17 +288,15 @@\n \n-        Raises :exc:`ValueError` if the value is not found.\n+        Raises :exc:`IndexError` if the value is not found.\n         Search only within *start* and *stop* if given.\n         \"\"\"\n-        if start is not None:\n-            start = self._translate_index(start)\n-        else:\n-            start = 0\n-        if stop is not None:\n-            stop = self._translate_index(stop)\n-        else:\n-            stop = maxsize  # same default value used by Python lists\n-        idx = self._value.index(value, start, stop)\n-        return self._range[idx]\n-\n-    def count(self, value: Any) -> int:\n+        if start is None:\n+            start = self.left\n+        if stop is None:\n+            stop = self.right\n+        for i in Range(start, self.direction, stop):\n+            if self[i] == value:\n+                return i\n+        raise IndexError(f\"{value!r} not in array\")\n+\n+    def count(self, value: T) -> int:\n         \"\"\"Return number of occurrences of *value*.\"\"\"\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\n        if start is not None:\n            <IND>start = self._translate_index(start)\n        <DED>else:\n            <IND>start = 0\n        <DED>if stop is not None:\n            <IND>stop = self._translate_index(stop)\n        <DED>else:\n            <IND>stop = maxsize  # same default value used by Python lists\n        <DED>idx = self._value.index(value, start, stop)\n        return self._range[idx]\n\n    <DED>def count(self, value: Any) -> int:\n        <IND>\"\"\"Return number of occurrences of *value*.\"\"\"\n",
        "target_code_with_indent": "\n        if start is None:\n            <IND>start = self.left\n        <DED>if stop is None:\n            <IND>stop = self.right\n        <DED>for i in Range(start, self.direction, stop):\n            <IND>if self[i] == value:\n                <IND>return i\n        <DED><DED>raise IndexError(f\"{value!r} not in array\")\n\n    <DED>def count(self, value: T) -> int:\n        <IND>\"\"\"Return number of occurrences of *value*.\"\"\"\n"
      }
    ]
  },
  {
    "project": "cocotb/cocotb",
    "commit": "d5b532d559b061d3054a64253672094a26cba322",
    "filename": "cocotb/types/array.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/cocotb-cocotb/cocotb/types/array.py",
    "file_hunks_size": 10,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "cocotb/types/array.py:294:26 Unsupported operand [58]: `+` is not supported for operand types `typing.Sequence[typing.Any]` and `typing.Sequence[typing.Any]`.",
    "message": " `+` is not supported for operand types `typing.Sequence[typing.Any]` and `typing.Sequence[typing.Any]`.",
    "rule_id": "Unsupported operand [58]",
    "warning_line_no": 294,
    "warning_line": "        return type(self)(self._value + other._value)",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "# SPDX-License-Identifier: BSD-3-Clause\nfrom typing import Optional, Any, Iterable, Iterator, overload\nfrom collections.abc import Sequence\nfrom .range import Range\nfrom sys import maxsize\n\n\nclass Array(Sequence):\n    r\"\"\"\n    Fixed-size, arbitrarily-indexed, heterogeneous sequence type.\n\n",
        "source_code_len": 290,
        "target_code": "# SPDX-License-Identifier: BSD-3-Clause\nimport typing\nfrom itertools import chain\n\nfrom cocotb.types.range import Range\n\nT = typing.TypeVar(\"T\")\nS = typing.TypeVar(\"S\")\nSelf = typing.TypeVar(\"Self\", bound=\"Array[typing.Any]\")\n\n\nclass Array(typing.Reversible[T], typing.Collection[T]):\n    r\"\"\"\n    Fixed-size, arbitrarily-indexed, homogeneous collection type.\n\n",
        "target_code_len": 361,
        "diff_format": "@@ -3,11 +3,15 @@\n # SPDX-License-Identifier: BSD-3-Clause\n-from typing import Optional, Any, Iterable, Iterator, overload\n-from collections.abc import Sequence\n-from .range import Range\n-from sys import maxsize\n-\n-\n-class Array(Sequence):\n+import typing\n+from itertools import chain\n+\n+from cocotb.types.range import Range\n+\n+T = typing.TypeVar(\"T\")\n+S = typing.TypeVar(\"S\")\n+Self = typing.TypeVar(\"Self\", bound=\"Array[typing.Any]\")\n+\n+\n+class Array(typing.Reversible[T], typing.Collection[T]):\n     r\"\"\"\n-    Fixed-size, arbitrarily-indexed, heterogeneous sequence type.\n+    Fixed-size, arbitrarily-indexed, homogeneous collection type.\n \n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "# SPDX-License-Identifier: BSD-3-Clause\nfrom typing import Optional, Any, Iterable, Iterator, overload\nfrom collections.abc import Sequence\nfrom .range import Range\nfrom sys import maxsize\n\n\nclass Array(Sequence):\n    <IND>",
        "target_code_with_indent": "# SPDX-License-Identifier: BSD-3-Clause\nimport typing\nfrom itertools import chain\n\nfrom cocotb.types.range import Range\n\nT = typing.TypeVar(\"T\")\nS = typing.TypeVar(\"S\")\nSelf = typing.TypeVar(\"Self\", bound=\"Array[typing.Any]\")\n\n\nclass Array(typing.Reversible[T], typing.Collection[T]):\n    <IND>"
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n    _value: Sequence\n    \"\"\"\n    Private interface for subclasses to access the value as a :class:`~collections.abc.Sequence`\n\n    Subclasses that don't use a Sequence as their main representation should emulate this object,\n    or override *all* :class:`~cocotb.types.Array` methods *except*:\n        - :attr:`left`\n        - :attr:`direction`\n        - :attr:`right`\n        - :attr:`range`\n        - :attr:`__len__`\n        - :attr:`_translate_index`\n    \"\"\"\n\n    def __init__(\n        self, value: Optional[Iterable[Any]] = None, range: Optional[Range] = None\n    ):\n        if value is not None and range is None:\n            self._value = list(value)\n            self._range = Range(0, \"to\", len(self._value) - 1)\n        elif value is not None and range is not None:\n            if not isinstance(range, Range):\n                raise TypeError(\"range argument must be of type 'Range'\")\n            self._value = list(value)\n            self._range = range\n",
        "source_code_len": 964,
        "target_code": "\n    def __init__(self, value: typing.Iterable[T], range: typing.Optional[Range] = None):\n        self._value = list(value)\n        if range is None:\n            self._range = Range(0, \"to\", len(self._value) - 1)\n        else:\n            self._range = range\n",
        "target_code_len": 259,
        "diff_format": "@@ -130,26 +131,7 @@\n \n-    _value: Sequence\n-    \"\"\"\n-    Private interface for subclasses to access the value as a :class:`~collections.abc.Sequence`\n-\n-    Subclasses that don't use a Sequence as their main representation should emulate this object,\n-    or override *all* :class:`~cocotb.types.Array` methods *except*:\n-        - :attr:`left`\n-        - :attr:`direction`\n-        - :attr:`right`\n-        - :attr:`range`\n-        - :attr:`__len__`\n-        - :attr:`_translate_index`\n-    \"\"\"\n-\n-    def __init__(\n-        self, value: Optional[Iterable[Any]] = None, range: Optional[Range] = None\n-    ):\n-        if value is not None and range is None:\n-            self._value = list(value)\n+    def __init__(self, value: typing.Iterable[T], range: typing.Optional[Range] = None):\n+        self._value = list(value)\n+        if range is None:\n             self._range = Range(0, \"to\", len(self._value) - 1)\n-        elif value is not None and range is not None:\n-            if not isinstance(range, Range):\n-                raise TypeError(\"range argument must be of type 'Range'\")\n-            self._value = list(value)\n+        else:\n             self._range = range\n",
        "source_code_with_indent": "\n    _value: Sequence\n    \"\"\"\n    Private interface for subclasses to access the value as a :class:`~collections.abc.Sequence`\n\n    Subclasses that don't use a Sequence as their main representation should emulate this object,\n    or override *all* :class:`~cocotb.types.Array` methods *except*:\n        - :attr:`left`\n        - :attr:`direction`\n        - :attr:`right`\n        - :attr:`range`\n        - :attr:`__len__`\n        - :attr:`_translate_index`\n    \"\"\"\n\n    def __init__(\n        self, value: Optional[Iterable[Any]] = None, range: Optional[Range] = None\n    ):\n        <IND>if value is not None and range is None:\n            <IND>self._value = list(value)\n            self._range = Range(0, \"to\", len(self._value) - 1)\n        <DED>elif value is not None and range is not None:\n            <IND>if not isinstance(range, Range):\n                <IND>raise TypeError(\"range argument must be of type 'Range'\")\n            <DED>self._value = list(value)\n            self._range = range\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n    def __init__(self, value: typing.Iterable[T], range: typing.Optional[Range] = None):\n        <IND>self._value = list(value)\n        if range is None:\n            <IND>self._range = Range(0, \"to\", len(self._value) - 1)\n        <DED>else:\n            <IND>self._range = range\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": true,
        "has_suppression": false,
        "source_code": "                )\n        elif value is None and range is not None:\n            if not isinstance(range, Range):\n                raise TypeError(\"range argument must be of type 'Range'\")\n            self._value = [None] * len(range)\n            self._range = range\n        else:\n            raise TypeError(\"must pass a value, range, or both\")\n\n",
        "source_code_len": 345,
        "target_code": "                )\n\n",
        "target_code_len": 19,
        "diff_format": "@@ -161,9 +143,2 @@\n                 )\n-        elif value is None and range is not None:\n-            if not isinstance(range, Range):\n-                raise TypeError(\"range argument must be of type 'Range'\")\n-            self._value = [None] * len(range)\n-            self._range = range\n-        else:\n-            raise TypeError(\"must pass a value, range, or both\")\n \n",
        "source_code_with_indent": "                )\n        <DED><DED>elif value is None and range is not None:\n            <IND>if not isinstance(range, Range):\n                <IND>raise TypeError(\"range argument must be of type 'Range'\")\n            <DED>self._value = [None] * len(range)\n            self._range = range\n        <DED>else:\n            <IND>raise TypeError(\"must pass a value, range, or both\")\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "                )\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n    def __iter__(self) -> Iterator[Any]:\n        return iter(self._value)\n\n    def __reversed__(self) -> Iterator[Any]:\n        return reversed(self._value)\n\n    def __contains__(self, item: Any) -> bool:\n        return item in self._value\n\n    def __eq__(self, other: Any) -> bool:\n        if not isinstance(other, type(self)):\n            return NotImplemented\n        return self._value == other._value\n\n    @overload\n    def __getitem__(self, item: int) -> Any:\n        pass  # pragma: no cover\n\n    @overload\n    def __getitem__(self, item: slice) -> \"Array\":\n        pass  # pragma: no cover\n\n    def __getitem__(self, item):\n        if isinstance(item, int):\n",
        "source_code_len": 667,
        "target_code": "\n    def __iter__(self) -> typing.Iterator[T]:\n        return iter(self._value)\n\n    def __reversed__(self) -> typing.Iterator[T]:\n        return reversed(self._value)\n\n    def __contains__(self, item: object) -> bool:\n        return item in self._value\n\n    def __eq__(self, other: object) -> bool:\n        if isinstance(other, type(self)):\n            return self._value == other._value\n        return NotImplemented\n\n    @typing.overload\n    def __getitem__(self, item: int) -> T:\n        ...\n\n    @typing.overload\n    def __getitem__(self, item: slice) -> \"Array[T]\":\n        ...\n\n    def __getitem__(\n        self, item: typing.Union[int, slice]\n    ) -> typing.Union[T, \"Array[T]\"]:\n        if isinstance(item, int):\n",
        "target_code_len": 723,
        "diff_format": "@@ -203,25 +178,27 @@\n \n-    def __iter__(self) -> Iterator[Any]:\n+    def __iter__(self) -> typing.Iterator[T]:\n         return iter(self._value)\n \n-    def __reversed__(self) -> Iterator[Any]:\n+    def __reversed__(self) -> typing.Iterator[T]:\n         return reversed(self._value)\n \n-    def __contains__(self, item: Any) -> bool:\n+    def __contains__(self, item: object) -> bool:\n         return item in self._value\n \n-    def __eq__(self, other: Any) -> bool:\n-        if not isinstance(other, type(self)):\n-            return NotImplemented\n-        return self._value == other._value\n-\n-    @overload\n-    def __getitem__(self, item: int) -> Any:\n-        pass  # pragma: no cover\n-\n-    @overload\n-    def __getitem__(self, item: slice) -> \"Array\":\n-        pass  # pragma: no cover\n-\n-    def __getitem__(self, item):\n+    def __eq__(self, other: object) -> bool:\n+        if isinstance(other, type(self)):\n+            return self._value == other._value\n+        return NotImplemented\n+\n+    @typing.overload\n+    def __getitem__(self, item: int) -> T:\n+        ...\n+\n+    @typing.overload\n+    def __getitem__(self, item: slice) -> \"Array[T]\":\n+        ...\n+\n+    def __getitem__(\n+        self, item: typing.Union[int, slice]\n+    ) -> typing.Union[T, \"Array[T]\"]:\n         if isinstance(item, int):\n",
        "source_code_with_indent": "\n    <DED>def __iter__(self) -> Iterator[Any]:\n        <IND>return iter(self._value)\n\n    <DED>def __reversed__(self) -> Iterator[Any]:\n        <IND>return reversed(self._value)\n\n    <DED>def __contains__(self, item: Any) -> bool:\n        <IND>return item in self._value\n\n    <DED>def __eq__(self, other: Any) -> bool:\n        <IND>if not isinstance(other, type(self)):\n            <IND>return NotImplemented\n        <DED>return self._value == other._value\n\n    <DED>@overload\n    def __getitem__(self, item: int) -> Any:\n        <IND>pass  # pragma: no cover\n\n    <DED>@overload\n    def __getitem__(self, item: slice) -> \"Array\":\n        <IND>pass  # pragma: no cover\n\n    <DED>def __getitem__(self, item):\n        <IND>if isinstance(item, int):\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n    <DED>def __iter__(self) -> typing.Iterator[T]:\n        <IND>return iter(self._value)\n\n    <DED>def __reversed__(self) -> typing.Iterator[T]:\n        <IND>return reversed(self._value)\n\n    <DED>def __contains__(self, item: object) -> bool:\n        <IND>return item in self._value\n\n    <DED>def __eq__(self, other: object) -> bool:\n        <IND>if isinstance(other, type(self)):\n            <IND>return self._value == other._value\n        <DED>return NotImplemented\n\n    <DED>@typing.overload\n    def __getitem__(self, item: int) -> T:\n        <IND>...\n\n    <DED>@typing.overload\n    def __getitem__(self, item: slice) -> \"Array[T]\":\n        <IND>...\n\n    <DED>def __getitem__(\n        self, item: typing.Union[int, slice]\n    ) -> typing.Union[T, \"Array[T]\"]:\n        <IND>if isinstance(item, int):\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n    @overload\n    def __setitem__(self, item: int, value: Any) -> None:\n        pass  # pragma: no cover\n\n    @overload\n    def __setitem__(self, item: slice, value: Iterable[Any]) -> None:\n        pass  # pragma: no cover\n\n    def __setitem__(self, item, value):\n        if isinstance(item, int):\n            idx = self._translate_index(item)\n            self._value[idx] = value\n        elif isinstance(item, slice):\n",
        "source_code_len": 420,
        "target_code": "\n    @typing.overload\n    def __setitem__(self, item: int, value: T) -> None:\n        ...\n\n    @typing.overload\n    def __setitem__(self, item: slice, value: typing.Iterable[T]) -> None:\n        ...\n\n    def __setitem__(\n        self, item: typing.Union[int, slice], value: typing.Union[T, typing.Iterable[T]]\n    ) -> None:\n        if isinstance(item, int):\n            idx = self._translate_index(item)\n            self._value[idx] = typing.cast(T, value)\n        elif isinstance(item, slice):\n",
        "target_code_len": 496,
        "diff_format": "@@ -249,14 +226,16 @@\n \n-    @overload\n-    def __setitem__(self, item: int, value: Any) -> None:\n-        pass  # pragma: no cover\n-\n-    @overload\n-    def __setitem__(self, item: slice, value: Iterable[Any]) -> None:\n-        pass  # pragma: no cover\n-\n-    def __setitem__(self, item, value):\n+    @typing.overload\n+    def __setitem__(self, item: int, value: T) -> None:\n+        ...\n+\n+    @typing.overload\n+    def __setitem__(self, item: slice, value: typing.Iterable[T]) -> None:\n+        ...\n+\n+    def __setitem__(\n+        self, item: typing.Union[int, slice], value: typing.Union[T, typing.Iterable[T]]\n+    ) -> None:\n         if isinstance(item, int):\n             idx = self._translate_index(item)\n-            self._value[idx] = value\n+            self._value[idx] = typing.cast(T, value)\n         elif isinstance(item, slice):\n",
        "source_code_with_indent": "\n    <DED>@overload\n    def __setitem__(self, item: int, value: Any) -> None:\n        <IND>pass  # pragma: no cover\n\n    <DED>@overload\n    def __setitem__(self, item: slice, value: Iterable[Any]) -> None:\n        <IND>pass  # pragma: no cover\n\n    <DED>def __setitem__(self, item, value):\n        <IND>if isinstance(item, int):\n            <IND>idx = self._translate_index(item)\n            self._value[idx] = value\n        <DED>elif isinstance(item, slice):\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n    <DED>@typing.overload\n    def __setitem__(self, item: int, value: T) -> None:\n        <IND>...\n\n    <DED>@typing.overload\n    def __setitem__(self, item: slice, value: typing.Iterable[T]) -> None:\n        <IND>...\n\n    <DED>def __setitem__(\n        self, item: typing.Union[int, slice], value: typing.Union[T, typing.Iterable[T]]\n    ) -> None:\n        <IND>if isinstance(item, int):\n            <IND>idx = self._translate_index(item)\n            self._value[idx] = typing.cast(T, value)\n        <DED>elif isinstance(item, slice):\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "                )\n            value = list(value)\n            if len(value) != (stop_i - start_i + 1):\n",
        "source_code_len": 103,
        "target_code": "                )\n            value = list(typing.cast(typing.Iterable[T], value))\n            if len(value) != (stop_i - start_i + 1):\n",
        "target_code_len": 136,
        "diff_format": "@@ -274,3 +253,3 @@\n                 )\n-            value = list(value)\n+            value = list(typing.cast(typing.Iterable[T], value))\n             if len(value) != (stop_i - start_i + 1):\n",
        "source_code_with_indent": "                )\n            <DED>value = list(value)\n            if len(value) != (stop_i - start_i + 1):\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "                )\n            <DED>value = list(typing.cast(typing.Iterable[T], value))\n            if len(value) != (stop_i - start_i + 1):\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n    def __concat__(self, other: \"Array\") -> \"Array\":\n        if not isinstance(other, type(self)):\n            return NotImplemented\n        return type(self)(self._value + other._value)\n\n    def __rconcat__(self, other: \"Array\") -> \"Array\":\n        if not isinstance(other, type(self)):\n            return NotImplemented\n        return type(self)(other._value + self._value)\n\n    def index(\n        self, value: Any, start: Optional[int] = None, stop: Optional[int] = None\n    ) -> int:\n",
        "source_code_len": 489,
        "target_code": "\n    def __concat__(self: Self, other: Self) -> Self:\n        if isinstance(other, type(self)):\n            return type(self)(chain(self, other))\n        return NotImplemented\n\n    def __rconcat__(self: Self, other: Self) -> Self:\n        if isinstance(other, type(self)):\n            return type(self)(chain(other, self))\n        return NotImplemented\n\n    def index(\n        self,\n        value: T,\n        start: typing.Optional[int] = None,\n        stop: typing.Optional[int] = None,\n    ) -> int:\n",
        "target_code_len": 502,
        "diff_format": "@@ -290,14 +269,17 @@\n \n-    def __concat__(self, other: \"Array\") -> \"Array\":\n-        if not isinstance(other, type(self)):\n-            return NotImplemented\n-        return type(self)(self._value + other._value)\n-\n-    def __rconcat__(self, other: \"Array\") -> \"Array\":\n-        if not isinstance(other, type(self)):\n-            return NotImplemented\n-        return type(self)(other._value + self._value)\n+    def __concat__(self: Self, other: Self) -> Self:\n+        if isinstance(other, type(self)):\n+            return type(self)(chain(self, other))\n+        return NotImplemented\n+\n+    def __rconcat__(self: Self, other: Self) -> Self:\n+        if isinstance(other, type(self)):\n+            return type(self)(chain(other, self))\n+        return NotImplemented\n \n     def index(\n-        self, value: Any, start: Optional[int] = None, stop: Optional[int] = None\n+        self,\n+        value: T,\n+        start: typing.Optional[int] = None,\n+        stop: typing.Optional[int] = None,\n     ) -> int:\n",
        "source_code_with_indent": "\n    <DED>def __concat__(self, other: \"Array\") -> \"Array\":\n        <IND>if not isinstance(other, type(self)):\n            <IND>return NotImplemented\n        <DED>return type(self)(self._value + other._value)\n\n    <DED>def __rconcat__(self, other: \"Array\") -> \"Array\":\n        <IND>if not isinstance(other, type(self)):\n            <IND>return NotImplemented\n        <DED>return type(self)(other._value + self._value)\n\n    <DED>def index(\n        self, value: Any, start: Optional[int] = None, stop: Optional[int] = None\n    ) -> int:\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n    <DED>def __concat__(self: Self, other: Self) -> Self:\n        <IND>if isinstance(other, type(self)):\n            <IND>return type(self)(chain(self, other))\n        <DED>return NotImplemented\n\n    <DED>def __rconcat__(self: Self, other: Self) -> Self:\n        <IND>if isinstance(other, type(self)):\n            <IND>return type(self)(chain(other, self))\n        <DED>return NotImplemented\n\n    <DED>def index(\n        self,\n        value: T,\n        start: typing.Optional[int] = None,\n        stop: typing.Optional[int] = None,\n    ) -> int:\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n        Raises :exc:`ValueError` if the value is not found.\n        Search only within *start* and *stop* if given.\n        \"\"\"\n        if start is not None:\n            start = self._translate_index(start)\n        else:\n            start = 0\n        if stop is not None:\n            stop = self._translate_index(stop)\n        else:\n            stop = maxsize  # same default value used by Python lists\n        idx = self._value.index(value, start, stop)\n        return self._range[idx]\n\n    def count(self, value: Any) -> int:\n        \"\"\"Return number of occurrences of *value*.\"\"\"\n",
        "source_code_len": 584,
        "target_code": "\n        Raises :exc:`IndexError` if the value is not found.\n        Search only within *start* and *stop* if given.\n        \"\"\"\n        if start is None:\n            start = self.left\n        if stop is None:\n            stop = self.right\n        for i in Range(start, self.direction, stop):\n            if self[i] == value:\n                return i\n        raise IndexError(f\"{value!r} not in array\")\n\n    def count(self, value: T) -> int:\n        \"\"\"Return number of occurrences of *value*.\"\"\"\n",
        "target_code_len": 497,
        "diff_format": "@@ -306,17 +288,15 @@\n \n-        Raises :exc:`ValueError` if the value is not found.\n+        Raises :exc:`IndexError` if the value is not found.\n         Search only within *start* and *stop* if given.\n         \"\"\"\n-        if start is not None:\n-            start = self._translate_index(start)\n-        else:\n-            start = 0\n-        if stop is not None:\n-            stop = self._translate_index(stop)\n-        else:\n-            stop = maxsize  # same default value used by Python lists\n-        idx = self._value.index(value, start, stop)\n-        return self._range[idx]\n-\n-    def count(self, value: Any) -> int:\n+        if start is None:\n+            start = self.left\n+        if stop is None:\n+            stop = self.right\n+        for i in Range(start, self.direction, stop):\n+            if self[i] == value:\n+                return i\n+        raise IndexError(f\"{value!r} not in array\")\n+\n+    def count(self, value: T) -> int:\n         \"\"\"Return number of occurrences of *value*.\"\"\"\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\n        if start is not None:\n            <IND>start = self._translate_index(start)\n        <DED>else:\n            <IND>start = 0\n        <DED>if stop is not None:\n            <IND>stop = self._translate_index(stop)\n        <DED>else:\n            <IND>stop = maxsize  # same default value used by Python lists\n        <DED>idx = self._value.index(value, start, stop)\n        return self._range[idx]\n\n    <DED>def count(self, value: Any) -> int:\n        <IND>\"\"\"Return number of occurrences of *value*.\"\"\"\n",
        "target_code_with_indent": "\n        if start is None:\n            <IND>start = self.left\n        <DED>if stop is None:\n            <IND>stop = self.right\n        <DED>for i in Range(start, self.direction, stop):\n            <IND>if self[i] == value:\n                <IND>return i\n        <DED><DED>raise IndexError(f\"{value!r} not in array\")\n\n    <DED>def count(self, value: T) -> int:\n        <IND>\"\"\"Return number of occurrences of *value*.\"\"\"\n"
      }
    ]
  },
  {
    "project": "cocotb/cocotb",
    "commit": "d5b532d559b061d3054a64253672094a26cba322",
    "filename": "cocotb/types/array.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/cocotb-cocotb/cocotb/types/array.py",
    "file_hunks_size": 10,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "cocotb/types/array.py:299:26 Unsupported operand [58]: `+` is not supported for operand types `typing.Sequence[typing.Any]` and `typing.Sequence[typing.Any]`.",
    "message": " `+` is not supported for operand types `typing.Sequence[typing.Any]` and `typing.Sequence[typing.Any]`.",
    "rule_id": "Unsupported operand [58]",
    "warning_line_no": 299,
    "warning_line": "        return type(self)(other._value + self._value)",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "# SPDX-License-Identifier: BSD-3-Clause\nfrom typing import Optional, Any, Iterable, Iterator, overload\nfrom collections.abc import Sequence\nfrom .range import Range\nfrom sys import maxsize\n\n\nclass Array(Sequence):\n    r\"\"\"\n    Fixed-size, arbitrarily-indexed, heterogeneous sequence type.\n\n",
        "source_code_len": 290,
        "target_code": "# SPDX-License-Identifier: BSD-3-Clause\nimport typing\nfrom itertools import chain\n\nfrom cocotb.types.range import Range\n\nT = typing.TypeVar(\"T\")\nS = typing.TypeVar(\"S\")\nSelf = typing.TypeVar(\"Self\", bound=\"Array[typing.Any]\")\n\n\nclass Array(typing.Reversible[T], typing.Collection[T]):\n    r\"\"\"\n    Fixed-size, arbitrarily-indexed, homogeneous collection type.\n\n",
        "target_code_len": 361,
        "diff_format": "@@ -3,11 +3,15 @@\n # SPDX-License-Identifier: BSD-3-Clause\n-from typing import Optional, Any, Iterable, Iterator, overload\n-from collections.abc import Sequence\n-from .range import Range\n-from sys import maxsize\n-\n-\n-class Array(Sequence):\n+import typing\n+from itertools import chain\n+\n+from cocotb.types.range import Range\n+\n+T = typing.TypeVar(\"T\")\n+S = typing.TypeVar(\"S\")\n+Self = typing.TypeVar(\"Self\", bound=\"Array[typing.Any]\")\n+\n+\n+class Array(typing.Reversible[T], typing.Collection[T]):\n     r\"\"\"\n-    Fixed-size, arbitrarily-indexed, heterogeneous sequence type.\n+    Fixed-size, arbitrarily-indexed, homogeneous collection type.\n \n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "# SPDX-License-Identifier: BSD-3-Clause\nfrom typing import Optional, Any, Iterable, Iterator, overload\nfrom collections.abc import Sequence\nfrom .range import Range\nfrom sys import maxsize\n\n\nclass Array(Sequence):\n    <IND>",
        "target_code_with_indent": "# SPDX-License-Identifier: BSD-3-Clause\nimport typing\nfrom itertools import chain\n\nfrom cocotb.types.range import Range\n\nT = typing.TypeVar(\"T\")\nS = typing.TypeVar(\"S\")\nSelf = typing.TypeVar(\"Self\", bound=\"Array[typing.Any]\")\n\n\nclass Array(typing.Reversible[T], typing.Collection[T]):\n    <IND>"
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n    _value: Sequence\n    \"\"\"\n    Private interface for subclasses to access the value as a :class:`~collections.abc.Sequence`\n\n    Subclasses that don't use a Sequence as their main representation should emulate this object,\n    or override *all* :class:`~cocotb.types.Array` methods *except*:\n        - :attr:`left`\n        - :attr:`direction`\n        - :attr:`right`\n        - :attr:`range`\n        - :attr:`__len__`\n        - :attr:`_translate_index`\n    \"\"\"\n\n    def __init__(\n        self, value: Optional[Iterable[Any]] = None, range: Optional[Range] = None\n    ):\n        if value is not None and range is None:\n            self._value = list(value)\n            self._range = Range(0, \"to\", len(self._value) - 1)\n        elif value is not None and range is not None:\n            if not isinstance(range, Range):\n                raise TypeError(\"range argument must be of type 'Range'\")\n            self._value = list(value)\n            self._range = range\n",
        "source_code_len": 964,
        "target_code": "\n    def __init__(self, value: typing.Iterable[T], range: typing.Optional[Range] = None):\n        self._value = list(value)\n        if range is None:\n            self._range = Range(0, \"to\", len(self._value) - 1)\n        else:\n            self._range = range\n",
        "target_code_len": 259,
        "diff_format": "@@ -130,26 +131,7 @@\n \n-    _value: Sequence\n-    \"\"\"\n-    Private interface for subclasses to access the value as a :class:`~collections.abc.Sequence`\n-\n-    Subclasses that don't use a Sequence as their main representation should emulate this object,\n-    or override *all* :class:`~cocotb.types.Array` methods *except*:\n-        - :attr:`left`\n-        - :attr:`direction`\n-        - :attr:`right`\n-        - :attr:`range`\n-        - :attr:`__len__`\n-        - :attr:`_translate_index`\n-    \"\"\"\n-\n-    def __init__(\n-        self, value: Optional[Iterable[Any]] = None, range: Optional[Range] = None\n-    ):\n-        if value is not None and range is None:\n-            self._value = list(value)\n+    def __init__(self, value: typing.Iterable[T], range: typing.Optional[Range] = None):\n+        self._value = list(value)\n+        if range is None:\n             self._range = Range(0, \"to\", len(self._value) - 1)\n-        elif value is not None and range is not None:\n-            if not isinstance(range, Range):\n-                raise TypeError(\"range argument must be of type 'Range'\")\n-            self._value = list(value)\n+        else:\n             self._range = range\n",
        "source_code_with_indent": "\n    _value: Sequence\n    \"\"\"\n    Private interface for subclasses to access the value as a :class:`~collections.abc.Sequence`\n\n    Subclasses that don't use a Sequence as their main representation should emulate this object,\n    or override *all* :class:`~cocotb.types.Array` methods *except*:\n        - :attr:`left`\n        - :attr:`direction`\n        - :attr:`right`\n        - :attr:`range`\n        - :attr:`__len__`\n        - :attr:`_translate_index`\n    \"\"\"\n\n    def __init__(\n        self, value: Optional[Iterable[Any]] = None, range: Optional[Range] = None\n    ):\n        <IND>if value is not None and range is None:\n            <IND>self._value = list(value)\n            self._range = Range(0, \"to\", len(self._value) - 1)\n        <DED>elif value is not None and range is not None:\n            <IND>if not isinstance(range, Range):\n                <IND>raise TypeError(\"range argument must be of type 'Range'\")\n            <DED>self._value = list(value)\n            self._range = range\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n    def __init__(self, value: typing.Iterable[T], range: typing.Optional[Range] = None):\n        <IND>self._value = list(value)\n        if range is None:\n            <IND>self._range = Range(0, \"to\", len(self._value) - 1)\n        <DED>else:\n            <IND>self._range = range\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": true,
        "has_suppression": false,
        "source_code": "                )\n        elif value is None and range is not None:\n            if not isinstance(range, Range):\n                raise TypeError(\"range argument must be of type 'Range'\")\n            self._value = [None] * len(range)\n            self._range = range\n        else:\n            raise TypeError(\"must pass a value, range, or both\")\n\n",
        "source_code_len": 345,
        "target_code": "                )\n\n",
        "target_code_len": 19,
        "diff_format": "@@ -161,9 +143,2 @@\n                 )\n-        elif value is None and range is not None:\n-            if not isinstance(range, Range):\n-                raise TypeError(\"range argument must be of type 'Range'\")\n-            self._value = [None] * len(range)\n-            self._range = range\n-        else:\n-            raise TypeError(\"must pass a value, range, or both\")\n \n",
        "source_code_with_indent": "                )\n        <DED><DED>elif value is None and range is not None:\n            <IND>if not isinstance(range, Range):\n                <IND>raise TypeError(\"range argument must be of type 'Range'\")\n            <DED>self._value = [None] * len(range)\n            self._range = range\n        <DED>else:\n            <IND>raise TypeError(\"must pass a value, range, or both\")\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "                )\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n    def __iter__(self) -> Iterator[Any]:\n        return iter(self._value)\n\n    def __reversed__(self) -> Iterator[Any]:\n        return reversed(self._value)\n\n    def __contains__(self, item: Any) -> bool:\n        return item in self._value\n\n    def __eq__(self, other: Any) -> bool:\n        if not isinstance(other, type(self)):\n            return NotImplemented\n        return self._value == other._value\n\n    @overload\n    def __getitem__(self, item: int) -> Any:\n        pass  # pragma: no cover\n\n    @overload\n    def __getitem__(self, item: slice) -> \"Array\":\n        pass  # pragma: no cover\n\n    def __getitem__(self, item):\n        if isinstance(item, int):\n",
        "source_code_len": 667,
        "target_code": "\n    def __iter__(self) -> typing.Iterator[T]:\n        return iter(self._value)\n\n    def __reversed__(self) -> typing.Iterator[T]:\n        return reversed(self._value)\n\n    def __contains__(self, item: object) -> bool:\n        return item in self._value\n\n    def __eq__(self, other: object) -> bool:\n        if isinstance(other, type(self)):\n            return self._value == other._value\n        return NotImplemented\n\n    @typing.overload\n    def __getitem__(self, item: int) -> T:\n        ...\n\n    @typing.overload\n    def __getitem__(self, item: slice) -> \"Array[T]\":\n        ...\n\n    def __getitem__(\n        self, item: typing.Union[int, slice]\n    ) -> typing.Union[T, \"Array[T]\"]:\n        if isinstance(item, int):\n",
        "target_code_len": 723,
        "diff_format": "@@ -203,25 +178,27 @@\n \n-    def __iter__(self) -> Iterator[Any]:\n+    def __iter__(self) -> typing.Iterator[T]:\n         return iter(self._value)\n \n-    def __reversed__(self) -> Iterator[Any]:\n+    def __reversed__(self) -> typing.Iterator[T]:\n         return reversed(self._value)\n \n-    def __contains__(self, item: Any) -> bool:\n+    def __contains__(self, item: object) -> bool:\n         return item in self._value\n \n-    def __eq__(self, other: Any) -> bool:\n-        if not isinstance(other, type(self)):\n-            return NotImplemented\n-        return self._value == other._value\n-\n-    @overload\n-    def __getitem__(self, item: int) -> Any:\n-        pass  # pragma: no cover\n-\n-    @overload\n-    def __getitem__(self, item: slice) -> \"Array\":\n-        pass  # pragma: no cover\n-\n-    def __getitem__(self, item):\n+    def __eq__(self, other: object) -> bool:\n+        if isinstance(other, type(self)):\n+            return self._value == other._value\n+        return NotImplemented\n+\n+    @typing.overload\n+    def __getitem__(self, item: int) -> T:\n+        ...\n+\n+    @typing.overload\n+    def __getitem__(self, item: slice) -> \"Array[T]\":\n+        ...\n+\n+    def __getitem__(\n+        self, item: typing.Union[int, slice]\n+    ) -> typing.Union[T, \"Array[T]\"]:\n         if isinstance(item, int):\n",
        "source_code_with_indent": "\n    <DED>def __iter__(self) -> Iterator[Any]:\n        <IND>return iter(self._value)\n\n    <DED>def __reversed__(self) -> Iterator[Any]:\n        <IND>return reversed(self._value)\n\n    <DED>def __contains__(self, item: Any) -> bool:\n        <IND>return item in self._value\n\n    <DED>def __eq__(self, other: Any) -> bool:\n        <IND>if not isinstance(other, type(self)):\n            <IND>return NotImplemented\n        <DED>return self._value == other._value\n\n    <DED>@overload\n    def __getitem__(self, item: int) -> Any:\n        <IND>pass  # pragma: no cover\n\n    <DED>@overload\n    def __getitem__(self, item: slice) -> \"Array\":\n        <IND>pass  # pragma: no cover\n\n    <DED>def __getitem__(self, item):\n        <IND>if isinstance(item, int):\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n    <DED>def __iter__(self) -> typing.Iterator[T]:\n        <IND>return iter(self._value)\n\n    <DED>def __reversed__(self) -> typing.Iterator[T]:\n        <IND>return reversed(self._value)\n\n    <DED>def __contains__(self, item: object) -> bool:\n        <IND>return item in self._value\n\n    <DED>def __eq__(self, other: object) -> bool:\n        <IND>if isinstance(other, type(self)):\n            <IND>return self._value == other._value\n        <DED>return NotImplemented\n\n    <DED>@typing.overload\n    def __getitem__(self, item: int) -> T:\n        <IND>...\n\n    <DED>@typing.overload\n    def __getitem__(self, item: slice) -> \"Array[T]\":\n        <IND>...\n\n    <DED>def __getitem__(\n        self, item: typing.Union[int, slice]\n    ) -> typing.Union[T, \"Array[T]\"]:\n        <IND>if isinstance(item, int):\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n    @overload\n    def __setitem__(self, item: int, value: Any) -> None:\n        pass  # pragma: no cover\n\n    @overload\n    def __setitem__(self, item: slice, value: Iterable[Any]) -> None:\n        pass  # pragma: no cover\n\n    def __setitem__(self, item, value):\n        if isinstance(item, int):\n            idx = self._translate_index(item)\n            self._value[idx] = value\n        elif isinstance(item, slice):\n",
        "source_code_len": 420,
        "target_code": "\n    @typing.overload\n    def __setitem__(self, item: int, value: T) -> None:\n        ...\n\n    @typing.overload\n    def __setitem__(self, item: slice, value: typing.Iterable[T]) -> None:\n        ...\n\n    def __setitem__(\n        self, item: typing.Union[int, slice], value: typing.Union[T, typing.Iterable[T]]\n    ) -> None:\n        if isinstance(item, int):\n            idx = self._translate_index(item)\n            self._value[idx] = typing.cast(T, value)\n        elif isinstance(item, slice):\n",
        "target_code_len": 496,
        "diff_format": "@@ -249,14 +226,16 @@\n \n-    @overload\n-    def __setitem__(self, item: int, value: Any) -> None:\n-        pass  # pragma: no cover\n-\n-    @overload\n-    def __setitem__(self, item: slice, value: Iterable[Any]) -> None:\n-        pass  # pragma: no cover\n-\n-    def __setitem__(self, item, value):\n+    @typing.overload\n+    def __setitem__(self, item: int, value: T) -> None:\n+        ...\n+\n+    @typing.overload\n+    def __setitem__(self, item: slice, value: typing.Iterable[T]) -> None:\n+        ...\n+\n+    def __setitem__(\n+        self, item: typing.Union[int, slice], value: typing.Union[T, typing.Iterable[T]]\n+    ) -> None:\n         if isinstance(item, int):\n             idx = self._translate_index(item)\n-            self._value[idx] = value\n+            self._value[idx] = typing.cast(T, value)\n         elif isinstance(item, slice):\n",
        "source_code_with_indent": "\n    <DED>@overload\n    def __setitem__(self, item: int, value: Any) -> None:\n        <IND>pass  # pragma: no cover\n\n    <DED>@overload\n    def __setitem__(self, item: slice, value: Iterable[Any]) -> None:\n        <IND>pass  # pragma: no cover\n\n    <DED>def __setitem__(self, item, value):\n        <IND>if isinstance(item, int):\n            <IND>idx = self._translate_index(item)\n            self._value[idx] = value\n        <DED>elif isinstance(item, slice):\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n    <DED>@typing.overload\n    def __setitem__(self, item: int, value: T) -> None:\n        <IND>...\n\n    <DED>@typing.overload\n    def __setitem__(self, item: slice, value: typing.Iterable[T]) -> None:\n        <IND>...\n\n    <DED>def __setitem__(\n        self, item: typing.Union[int, slice], value: typing.Union[T, typing.Iterable[T]]\n    ) -> None:\n        <IND>if isinstance(item, int):\n            <IND>idx = self._translate_index(item)\n            self._value[idx] = typing.cast(T, value)\n        <DED>elif isinstance(item, slice):\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "                )\n            value = list(value)\n            if len(value) != (stop_i - start_i + 1):\n",
        "source_code_len": 103,
        "target_code": "                )\n            value = list(typing.cast(typing.Iterable[T], value))\n            if len(value) != (stop_i - start_i + 1):\n",
        "target_code_len": 136,
        "diff_format": "@@ -274,3 +253,3 @@\n                 )\n-            value = list(value)\n+            value = list(typing.cast(typing.Iterable[T], value))\n             if len(value) != (stop_i - start_i + 1):\n",
        "source_code_with_indent": "                )\n            <DED>value = list(value)\n            if len(value) != (stop_i - start_i + 1):\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "                )\n            <DED>value = list(typing.cast(typing.Iterable[T], value))\n            if len(value) != (stop_i - start_i + 1):\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n    def __concat__(self, other: \"Array\") -> \"Array\":\n        if not isinstance(other, type(self)):\n            return NotImplemented\n        return type(self)(self._value + other._value)\n\n    def __rconcat__(self, other: \"Array\") -> \"Array\":\n        if not isinstance(other, type(self)):\n            return NotImplemented\n        return type(self)(other._value + self._value)\n\n    def index(\n        self, value: Any, start: Optional[int] = None, stop: Optional[int] = None\n    ) -> int:\n",
        "source_code_len": 489,
        "target_code": "\n    def __concat__(self: Self, other: Self) -> Self:\n        if isinstance(other, type(self)):\n            return type(self)(chain(self, other))\n        return NotImplemented\n\n    def __rconcat__(self: Self, other: Self) -> Self:\n        if isinstance(other, type(self)):\n            return type(self)(chain(other, self))\n        return NotImplemented\n\n    def index(\n        self,\n        value: T,\n        start: typing.Optional[int] = None,\n        stop: typing.Optional[int] = None,\n    ) -> int:\n",
        "target_code_len": 502,
        "diff_format": "@@ -290,14 +269,17 @@\n \n-    def __concat__(self, other: \"Array\") -> \"Array\":\n-        if not isinstance(other, type(self)):\n-            return NotImplemented\n-        return type(self)(self._value + other._value)\n-\n-    def __rconcat__(self, other: \"Array\") -> \"Array\":\n-        if not isinstance(other, type(self)):\n-            return NotImplemented\n-        return type(self)(other._value + self._value)\n+    def __concat__(self: Self, other: Self) -> Self:\n+        if isinstance(other, type(self)):\n+            return type(self)(chain(self, other))\n+        return NotImplemented\n+\n+    def __rconcat__(self: Self, other: Self) -> Self:\n+        if isinstance(other, type(self)):\n+            return type(self)(chain(other, self))\n+        return NotImplemented\n \n     def index(\n-        self, value: Any, start: Optional[int] = None, stop: Optional[int] = None\n+        self,\n+        value: T,\n+        start: typing.Optional[int] = None,\n+        stop: typing.Optional[int] = None,\n     ) -> int:\n",
        "source_code_with_indent": "\n    <DED>def __concat__(self, other: \"Array\") -> \"Array\":\n        <IND>if not isinstance(other, type(self)):\n            <IND>return NotImplemented\n        <DED>return type(self)(self._value + other._value)\n\n    <DED>def __rconcat__(self, other: \"Array\") -> \"Array\":\n        <IND>if not isinstance(other, type(self)):\n            <IND>return NotImplemented\n        <DED>return type(self)(other._value + self._value)\n\n    <DED>def index(\n        self, value: Any, start: Optional[int] = None, stop: Optional[int] = None\n    ) -> int:\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n    <DED>def __concat__(self: Self, other: Self) -> Self:\n        <IND>if isinstance(other, type(self)):\n            <IND>return type(self)(chain(self, other))\n        <DED>return NotImplemented\n\n    <DED>def __rconcat__(self: Self, other: Self) -> Self:\n        <IND>if isinstance(other, type(self)):\n            <IND>return type(self)(chain(other, self))\n        <DED>return NotImplemented\n\n    <DED>def index(\n        self,\n        value: T,\n        start: typing.Optional[int] = None,\n        stop: typing.Optional[int] = None,\n    ) -> int:\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n        Raises :exc:`ValueError` if the value is not found.\n        Search only within *start* and *stop* if given.\n        \"\"\"\n        if start is not None:\n            start = self._translate_index(start)\n        else:\n            start = 0\n        if stop is not None:\n            stop = self._translate_index(stop)\n        else:\n            stop = maxsize  # same default value used by Python lists\n        idx = self._value.index(value, start, stop)\n        return self._range[idx]\n\n    def count(self, value: Any) -> int:\n        \"\"\"Return number of occurrences of *value*.\"\"\"\n",
        "source_code_len": 584,
        "target_code": "\n        Raises :exc:`IndexError` if the value is not found.\n        Search only within *start* and *stop* if given.\n        \"\"\"\n        if start is None:\n            start = self.left\n        if stop is None:\n            stop = self.right\n        for i in Range(start, self.direction, stop):\n            if self[i] == value:\n                return i\n        raise IndexError(f\"{value!r} not in array\")\n\n    def count(self, value: T) -> int:\n        \"\"\"Return number of occurrences of *value*.\"\"\"\n",
        "target_code_len": 497,
        "diff_format": "@@ -306,17 +288,15 @@\n \n-        Raises :exc:`ValueError` if the value is not found.\n+        Raises :exc:`IndexError` if the value is not found.\n         Search only within *start* and *stop* if given.\n         \"\"\"\n-        if start is not None:\n-            start = self._translate_index(start)\n-        else:\n-            start = 0\n-        if stop is not None:\n-            stop = self._translate_index(stop)\n-        else:\n-            stop = maxsize  # same default value used by Python lists\n-        idx = self._value.index(value, start, stop)\n-        return self._range[idx]\n-\n-    def count(self, value: Any) -> int:\n+        if start is None:\n+            start = self.left\n+        if stop is None:\n+            stop = self.right\n+        for i in Range(start, self.direction, stop):\n+            if self[i] == value:\n+                return i\n+        raise IndexError(f\"{value!r} not in array\")\n+\n+    def count(self, value: T) -> int:\n         \"\"\"Return number of occurrences of *value*.\"\"\"\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\n        if start is not None:\n            <IND>start = self._translate_index(start)\n        <DED>else:\n            <IND>start = 0\n        <DED>if stop is not None:\n            <IND>stop = self._translate_index(stop)\n        <DED>else:\n            <IND>stop = maxsize  # same default value used by Python lists\n        <DED>idx = self._value.index(value, start, stop)\n        return self._range[idx]\n\n    <DED>def count(self, value: Any) -> int:\n        <IND>\"\"\"Return number of occurrences of *value*.\"\"\"\n",
        "target_code_with_indent": "\n        if start is None:\n            <IND>start = self.left\n        <DED>if stop is None:\n            <IND>stop = self.right\n        <DED>for i in Range(start, self.direction, stop):\n            <IND>if self[i] == value:\n                <IND>return i\n        <DED><DED>raise IndexError(f\"{value!r} not in array\")\n\n    <DED>def count(self, value: T) -> int:\n        <IND>\"\"\"Return number of occurrences of *value*.\"\"\"\n"
      }
    ]
  }
]