[
  {
    "project": "life4/deal",
    "commit": "b70a798af83ea3ab010b08ff1d45cfed0998e545",
    "filename": "deal/linter/_extractors/exceptions_stubs.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/life4-deal/deal/linter/_extractors/exceptions_stubs.py",
    "file_hunks_size": 2,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "deal/linter/_extractors/exceptions_stubs.py:38:8 Incompatible return type [7]: Expected `StubFile` but got `None`.",
    "message": " Expected `StubFile` but got `None`.",
    "rule_id": "Incompatible return type [7]",
    "warning_line_no": 38,
    "warning_line": "        return None",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\ndef _get_stub(module_name: Optional[str], expr: astroid.FunctionDef, stubs: StubsManager) -> StubFile:\n    if not module_name:\n",
        "source_code_len": 128,
        "target_code": "\ndef _get_stub(\n    module_name: Optional[str], expr: astroid.FunctionDef, stubs: StubsManager,\n) -> Optional[StubFile]:\n    if not module_name:\n",
        "target_code_len": 145,
        "diff_format": "@@ -35,3 +35,5 @@\n \n-def _get_stub(module_name: Optional[str], expr: astroid.FunctionDef, stubs: StubsManager) -> StubFile:\n+def _get_stub(\n+    module_name: Optional[str], expr: astroid.FunctionDef, stubs: StubsManager,\n+) -> Optional[StubFile]:\n     if not module_name:\n",
        "source_code_with_indent": "\n<DED><DED><DED><DED>def _get_stub(module_name: Optional[str], expr: astroid.FunctionDef, stubs: StubsManager) -> StubFile:\n    <IND>if not module_name:\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n<DED><DED><DED><DED>def _get_stub(\n    module_name: Optional[str], expr: astroid.FunctionDef, stubs: StubsManager,\n) -> Optional[StubFile]:\n    <IND>if not module_name:\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "life4/deal",
    "commit": "b70a798af83ea3ab010b08ff1d45cfed0998e545",
    "filename": "deal/linter/_extractors/exceptions_stubs.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/life4-deal/deal/linter/_extractors/exceptions_stubs.py",
    "file_hunks_size": 2,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "deal/linter/_extractors/exceptions_stubs.py:45:8 Incompatible return type [7]: Expected `StubFile` but got `None`.",
    "message": " Expected `StubFile` but got `None`.",
    "rule_id": "Incompatible return type [7]",
    "warning_line_no": 45,
    "warning_line": "        return None  # pragma: no coverage",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\ndef _get_stub(module_name: Optional[str], expr: astroid.FunctionDef, stubs: StubsManager) -> StubFile:\n    if not module_name:\n",
        "source_code_len": 128,
        "target_code": "\ndef _get_stub(\n    module_name: Optional[str], expr: astroid.FunctionDef, stubs: StubsManager,\n) -> Optional[StubFile]:\n    if not module_name:\n",
        "target_code_len": 145,
        "diff_format": "@@ -35,3 +35,5 @@\n \n-def _get_stub(module_name: Optional[str], expr: astroid.FunctionDef, stubs: StubsManager) -> StubFile:\n+def _get_stub(\n+    module_name: Optional[str], expr: astroid.FunctionDef, stubs: StubsManager,\n+) -> Optional[StubFile]:\n     if not module_name:\n",
        "source_code_with_indent": "\n<DED><DED><DED><DED>def _get_stub(module_name: Optional[str], expr: astroid.FunctionDef, stubs: StubsManager) -> StubFile:\n    <IND>if not module_name:\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n<DED><DED><DED><DED>def _get_stub(\n    module_name: Optional[str], expr: astroid.FunctionDef, stubs: StubsManager,\n) -> Optional[StubFile]:\n    <IND>if not module_name:\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "life4/deal",
    "commit": "b70a798af83ea3ab010b08ff1d45cfed0998e545",
    "filename": "deal/linter/_extractors/exceptions_stubs.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/life4-deal/deal/linter/_extractors/exceptions_stubs.py",
    "file_hunks_size": 2,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "deal/linter/_extractors/exceptions_stubs.py:48:8 Incompatible return type [7]: Expected `StubFile` but got `None`.",
    "message": " Expected `StubFile` but got `None`.",
    "rule_id": "Incompatible return type [7]",
    "warning_line_no": 48,
    "warning_line": "        return None",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\ndef _get_stub(module_name: Optional[str], expr: astroid.FunctionDef, stubs: StubsManager) -> StubFile:\n    if not module_name:\n",
        "source_code_len": 128,
        "target_code": "\ndef _get_stub(\n    module_name: Optional[str], expr: astroid.FunctionDef, stubs: StubsManager,\n) -> Optional[StubFile]:\n    if not module_name:\n",
        "target_code_len": 145,
        "diff_format": "@@ -35,3 +35,5 @@\n \n-def _get_stub(module_name: Optional[str], expr: astroid.FunctionDef, stubs: StubsManager) -> StubFile:\n+def _get_stub(\n+    module_name: Optional[str], expr: astroid.FunctionDef, stubs: StubsManager,\n+) -> Optional[StubFile]:\n     if not module_name:\n",
        "source_code_with_indent": "\n<DED><DED><DED><DED>def _get_stub(module_name: Optional[str], expr: astroid.FunctionDef, stubs: StubsManager) -> StubFile:\n    <IND>if not module_name:\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n<DED><DED><DED><DED>def _get_stub(\n    module_name: Optional[str], expr: astroid.FunctionDef, stubs: StubsManager,\n) -> Optional[StubFile]:\n    <IND>if not module_name:\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "life4/deal",
    "commit": "b70a798af83ea3ab010b08ff1d45cfed0998e545",
    "filename": "deal/linter/_rules.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/life4-deal/deal/linter/_rules.py",
    "file_hunks_size": 2,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "deal/linter/_rules.py:107:26 Incompatible parameter type [6]: Expected `typing.Type[typing.Any]` for 1st positional only parameter to call `issubclass` but got `object`.",
    "message": " Expected `typing.Type[typing.Any]` for 1st positional only parameter to call `issubclass` but got `object`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 107,
    "warning_line": "            if issubclass(token.value, allowed_types):",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "        allowed_types = tuple(exc for exc in allowed if type(exc) is not str)\n        tokens = chain(\n            get_exceptions(body=func.body),\n            get_exceptions_stubs(body=func.body, stubs=stubs),\n        )\n        for token in tokens:\n            if token.value in allowed:\n                continue\n            if issubclass(token.value, allowed_types):\n                continue\n            exc = token.value\n            if not isinstance(exc, str):\n                exc = exc.__name__\n",
        "source_code_len": 498,
        "target_code": "        allowed_types = tuple(exc for exc in allowed if type(exc) is not str)\n        tokens = [get_exceptions(body=func.body)]\n        if stubs is not None:\n            tokens.append(get_exceptions_stubs(body=func.body, stubs=stubs))\n        for token in chain(*tokens):\n            if token.value in allowed:\n                continue\n            exc = token.value\n            if isinstance(exc, type):\n                if issubclass(exc, allowed_types):\n                    continue\n                exc = exc.__name__\n",
        "target_code_len": 519,
        "diff_format": "@@ -99,13 +99,12 @@\n         allowed_types = tuple(exc for exc in allowed if type(exc) is not str)\n-        tokens = chain(\n-            get_exceptions(body=func.body),\n-            get_exceptions_stubs(body=func.body, stubs=stubs),\n-        )\n-        for token in tokens:\n+        tokens = [get_exceptions(body=func.body)]\n+        if stubs is not None:\n+            tokens.append(get_exceptions_stubs(body=func.body, stubs=stubs))\n+        for token in chain(*tokens):\n             if token.value in allowed:\n                 continue\n-            if issubclass(token.value, allowed_types):\n-                continue\n             exc = token.value\n-            if not isinstance(exc, str):\n+            if isinstance(exc, type):\n+                if issubclass(exc, allowed_types):\n+                    continue\n                 exc = exc.__name__\n",
        "source_code_with_indent": "        allowed_types = tuple(exc for exc in allowed if type(exc) is not str)\n        tokens = chain(\n            get_exceptions(body=func.body),\n            get_exceptions_stubs(body=func.body, stubs=stubs),\n        )\n        for token in tokens:\n            <IND>if token.value in allowed:\n                <IND>continue\n            <DED>if issubclass(token.value, allowed_types):\n                <IND>continue\n            <DED>exc = token.value\n            if not isinstance(exc, str):\n                <IND>exc = exc.__name__\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "        allowed_types = tuple(exc for exc in allowed if type(exc) is not str)\n        tokens = [get_exceptions(body=func.body)]\n        if stubs is not None:\n            <IND>tokens.append(get_exceptions_stubs(body=func.body, stubs=stubs))\n        <DED>for token in chain(*tokens):\n            <IND>if token.value in allowed:\n                <IND>continue\n            <DED>exc = token.value\n            if isinstance(exc, type):\n                <IND>if issubclass(exc, allowed_types):\n                    <IND>continue\n                <DED>exc = exc.__name__\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  }
]