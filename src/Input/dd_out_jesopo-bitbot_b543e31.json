[
  {
    "project": "jesopo/bitbot",
    "commit": "b543e31cd2a665b25aab4554e46a0ed5067d1bfe",
    "filename": "src/Cache.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/jesopo-bitbot/src/Cache.py",
    "file_hunks_size": 2,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "src/Cache.py:9:33 Incompatible parameter type [6]: Expected `float` for 2nd positional only parameter to call `Cache._cache` but got `None`.",
    "message": " Expected `float` for 2nd positional only parameter to call `Cache._cache` but got `None`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 9,
    "warning_line": "        return self._cache(item, None)",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    def temporary_cache(self, item: typing.Any, timeout: float)-> str:\n        return self._cache(item, timeout)\n    def _cache(self, item: typing.Any, timeout: float) -> str:\n        id = str(uuid.uuid4())\n        self._items[id] = [item, time.monotonic()+timeout]\n        self._item_to_id[item] = id\n",
        "source_code_len": 302,
        "target_code": "    def temporary_cache(self, item: typing.Any, timeout: float)-> str:\n        return self._cache(item, time.monotonic()+timeout)\n    def _cache(self, item: typing.Any, timeout: typing.Optional[float]) -> str:\n        id = str(uuid.uuid4())\n        self._items[id] = [item, timeout]\n        self._item_to_id[item] = id\n",
        "target_code_len": 319,
        "diff_format": "@@ -10,6 +10,6 @@\n     def temporary_cache(self, item: typing.Any, timeout: float)-> str:\n-        return self._cache(item, timeout)\n-    def _cache(self, item: typing.Any, timeout: float) -> str:\n+        return self._cache(item, time.monotonic()+timeout)\n+    def _cache(self, item: typing.Any, timeout: typing.Optional[float]) -> str:\n         id = str(uuid.uuid4())\n-        self._items[id] = [item, time.monotonic()+timeout]\n+        self._items[id] = [item, timeout]\n         self._item_to_id[item] = id\n",
        "source_code_with_indent": "    <DED>def temporary_cache(self, item: typing.Any, timeout: float)-> str:\n        <IND>return self._cache(item, timeout)\n    <DED>def _cache(self, item: typing.Any, timeout: float) -> str:\n        <IND>id = str(uuid.uuid4())\n        self._items[id] = [item, time.monotonic()+timeout]\n        self._item_to_id[item] = id\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    <DED>def temporary_cache(self, item: typing.Any, timeout: float)-> str:\n        <IND>return self._cache(item, time.monotonic()+timeout)\n    <DED>def _cache(self, item: typing.Any, timeout: typing.Optional[float]) -> str:\n        <IND>id = str(uuid.uuid4())\n        self._items[id] = [item, timeout]\n        self._item_to_id[item] = id\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "jesopo/bitbot",
    "commit": "b543e31cd2a665b25aab4554e46a0ed5067d1bfe",
    "filename": "src/Cache.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/jesopo-bitbot/src/Cache.py",
    "file_hunks_size": 2,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "src/Cache.py:22:12 Incompatible return type [7]: Expected `float` but got `None`.",
    "message": " Expected `float` but got `None`.",
    "rule_id": "Incompatible return type [7]",
    "warning_line_no": 22,
    "warning_line": "            return None",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n    def next_expiration(self) -> float:\n        expirations = [self._items[id][1] for id in self._items]\n",
        "source_code_len": 106,
        "target_code": "\n    def next_expiration(self) -> typing.Optional[float]:\n        expirations = [self._items[id][1] for id in self._items]\n",
        "target_code_len": 123,
        "diff_format": "@@ -17,3 +17,3 @@\n \n-    def next_expiration(self) -> float:\n+    def next_expiration(self) -> typing.Optional[float]:\n         expirations = [self._items[id][1] for id in self._items]\n",
        "source_code_with_indent": "\n    <DED>def next_expiration(self) -> float:\n        <IND>expirations = [self._items[id][1] for id in self._items]\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n    <DED>def next_expiration(self) -> typing.Optional[float]:\n        <IND>expirations = [self._items[id][1] for id in self._items]\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "jesopo/bitbot",
    "commit": "b543e31cd2a665b25aab4554e46a0ed5067d1bfe",
    "filename": "src/EventManager.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/jesopo-bitbot/src/EventManager.py",
    "file_hunks_size": 15,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "src/EventManager.py:71:36 Incompatible parameter type [6]: Expected `str` for 2nd positional only parameter to call `EventHook._hook` but got `None`.",
    "message": " Expected `str` for 2nd positional only parameter to call `EventHook._hook` but got `None`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 71,
    "warning_line": "        return self._hook(function, None, priority, replay, kwargs)",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "        return self._hook(function, context, priority, replay, kwargs)\n    def _hook(self, function: CALLBACK_TYPE, context: str, priority: int,\n            replay: bool, kwargs: dict) -> EventCallback:\n        callback = EventCallback(function, priority, kwargs)\n",
        "source_code_len": 264,
        "target_code": "        return self._hook(function, context, priority, replay, kwargs)\n    def _hook(self, function: CALLBACK_TYPE, context: typing.Optional[str],\n            priority: int, replay: bool, kwargs: dict) -> EventCallback:\n        callback = EventCallback(function, priority, kwargs)\n",
        "target_code_len": 281,
        "diff_format": "@@ -74,4 +79,4 @@\n         return self._hook(function, context, priority, replay, kwargs)\n-    def _hook(self, function: CALLBACK_TYPE, context: str, priority: int,\n-            replay: bool, kwargs: dict) -> EventCallback:\n+    def _hook(self, function: CALLBACK_TYPE, context: typing.Optional[str],\n+            priority: int, replay: bool, kwargs: dict) -> EventCallback:\n         callback = EventCallback(function, priority, kwargs)\n",
        "source_code_with_indent": "        <IND>return self._hook(function, context, priority, replay, kwargs)\n    <DED>def _hook(self, function: CALLBACK_TYPE, context: str, priority: int,\n            replay: bool, kwargs: dict) -> EventCallback:\n        <IND>callback = EventCallback(function, priority, kwargs)\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "        <IND>return self._hook(function, context, priority, replay, kwargs)\n    <DED>def _hook(self, function: CALLBACK_TYPE, context: typing.Optional[str],\n            priority: int, replay: bool, kwargs: dict) -> EventCallback:\n        <IND>callback = EventCallback(function, priority, kwargs)\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "jesopo/bitbot",
    "commit": "b543e31cd2a665b25aab4554e46a0ed5067d1bfe",
    "filename": "src/EventManager.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/jesopo-bitbot/src/EventManager.py",
    "file_hunks_size": 15,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "src/EventManager.py:88:41 Incompatible parameter type [6]: Expected `int` for 3rd positional only parameter to call `EventHook._call` but got `None`.",
    "message": " Expected `int` for 3rd positional only parameter to call `EventHook._call` but got `None`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 88,
    "warning_line": "                self._call(kwargs, True, None)",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n    def _call(self, kwargs: dict, safe: bool, maximum: int\n            ) -> typing.List[typing.Any]:\n",
        "source_code_len": 102,
        "target_code": "\n    def _call(self, kwargs: dict, safe: bool, maximum: typing.Optional[int]\n            ) -> typing.List[typing.Any]:\n",
        "target_code_len": 119,
        "diff_format": "@@ -165,3 +177,3 @@\n \n-    def _call(self, kwargs: dict, safe: bool, maximum: int\n+    def _call(self, kwargs: dict, safe: bool, maximum: typing.Optional[int]\n             ) -> typing.List[typing.Any]:\n",
        "source_code_with_indent": "\n    <DED>def _call(self, kwargs: dict, safe: bool, maximum: int\n            ) -> typing.List[typing.Any]:\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n    <DED>def _call(self, kwargs: dict, safe: bool, maximum: typing.Optional[int]\n            ) -> typing.List[typing.Any]:\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "jesopo/bitbot",
    "commit": "b543e31cd2a665b25aab4554e46a0ed5067d1bfe",
    "filename": "src/EventManager.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/jesopo-bitbot/src/EventManager.py",
    "file_hunks_size": 15,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "src/EventManager.py:112:37 Incompatible parameter type [6]: Expected `EventHook` for 1st positional only parameter to call `MultipleEventHook._add` but got `typing.Union[EventHook, EventHookContext]`.",
    "message": " Expected `EventHook` for 1st positional only parameter to call `MultipleEventHook._add` but got `typing.Union[EventHook, EventHookContext]`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 112,
    "warning_line": "            multiple_event_hook._add(event_hook)",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n    def _make_multiple_hook(self, source: \"EventHook\", context: str,\n            events: typing.List[str]) -> \"MultipleEventHook\":\n        multiple_event_hook = MultipleEventHook()\n",
        "source_code_len": 182,
        "target_code": "\n    def _make_multiple_hook(self, source: \"EventHook\",\n            context: typing.Optional[str],\n            events: typing.Iterable[str]) -> \"MultipleEventHook\":\n        multiple_event_hook = MultipleEventHook()\n",
        "target_code_len": 215,
        "diff_format": "@@ -104,4 +109,5 @@\n \n-    def _make_multiple_hook(self, source: \"EventHook\", context: str,\n-            events: typing.List[str]) -> \"MultipleEventHook\":\n+    def _make_multiple_hook(self, source: \"EventHook\",\n+            context: typing.Optional[str],\n+            events: typing.Iterable[str]) -> \"MultipleEventHook\":\n         multiple_event_hook = MultipleEventHook()\n",
        "source_code_with_indent": "\n    <DED><DED>def _make_multiple_hook(self, source: \"EventHook\", context: str,\n            events: typing.List[str]) -> \"MultipleEventHook\":\n        <IND>multiple_event_hook = MultipleEventHook()\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n    <DED><DED>def _make_multiple_hook(self, source: \"EventHook\",\n            context: typing.Optional[str],\n            events: typing.Iterable[str]) -> \"MultipleEventHook\":\n        <IND>multiple_event_hook = MultipleEventHook()\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "            if not context == None:\n                event_hook = event_hook.new_context(context)\n            multiple_event_hook._add(event_hook)\n        return multiple_event_hook\n\n    def on(self, subevent: str, *extra_subevents,\n            delimiter: int = DEFAULT_EVENT_DELIMITER) -> \"EventHook\":\n        return self._on(subevent, extra_subevents, None, delimiter)\n    def _context_on(self, context: str, subevent: str,\n            extra_subevents: typing.List[str],\n            delimiter: str = DEFAULT_EVENT_DELIMITER) -> \"EventHook\":\n        return self._on(subevent, extra_subevents, context, delimiter)\n    def _on(self, subevent: str, extra_subevents: typing.List[str],\n            context: str, delimiter: str) -> \"EventHook\":\n        if delimiter in subevent:\n",
        "source_code_len": 773,
        "target_code": "            if not context == None:\n                context_hook = event_hook.new_context(typing.cast(str, context))\n                multiple_event_hook._add(typing.cast(EventHook, context_hook))\n            else:\n                multiple_event_hook._add(event_hook)\n        return multiple_event_hook\n\n    def on(self, subevent: str, *extra_subevents: str,\n            delimiter: str = DEFAULT_EVENT_DELIMITER) -> \"EventHook\":\n        return self._on(subevent, extra_subevents, None, delimiter)\n    def _context_on(self, context: str, subevent: str,\n            extra_subevents: typing.Tuple[str, ...],\n            delimiter: str = DEFAULT_EVENT_DELIMITER) -> \"EventHook\":\n        return self._on(subevent, extra_subevents, context, delimiter)\n    def _on(self, subevent: str, extra_subevents: typing.Tuple[str, ...],\n            context: typing.Optional[str], delimiter: str) -> \"EventHook\":\n        if delimiter in subevent:\n",
        "target_code_len": 928,
        "diff_format": "@@ -110,15 +116,17 @@\n             if not context == None:\n-                event_hook = event_hook.new_context(context)\n-            multiple_event_hook._add(event_hook)\n+                context_hook = event_hook.new_context(typing.cast(str, context))\n+                multiple_event_hook._add(typing.cast(EventHook, context_hook))\n+            else:\n+                multiple_event_hook._add(event_hook)\n         return multiple_event_hook\n \n-    def on(self, subevent: str, *extra_subevents,\n-            delimiter: int = DEFAULT_EVENT_DELIMITER) -> \"EventHook\":\n+    def on(self, subevent: str, *extra_subevents: str,\n+            delimiter: str = DEFAULT_EVENT_DELIMITER) -> \"EventHook\":\n         return self._on(subevent, extra_subevents, None, delimiter)\n     def _context_on(self, context: str, subevent: str,\n-            extra_subevents: typing.List[str],\n+            extra_subevents: typing.Tuple[str, ...],\n             delimiter: str = DEFAULT_EVENT_DELIMITER) -> \"EventHook\":\n         return self._on(subevent, extra_subevents, context, delimiter)\n-    def _on(self, subevent: str, extra_subevents: typing.List[str],\n-            context: str, delimiter: str) -> \"EventHook\":\n+    def _on(self, subevent: str, extra_subevents: typing.Tuple[str, ...],\n+            context: typing.Optional[str], delimiter: str) -> \"EventHook\":\n         if delimiter in subevent:\n",
        "source_code_with_indent": "            if not context == None:\n                <IND>event_hook = event_hook.new_context(context)\n            <DED>multiple_event_hook._add(event_hook)\n        <DED>return multiple_event_hook\n\n    <DED>def on(self, subevent: str, *extra_subevents,\n            delimiter: int = DEFAULT_EVENT_DELIMITER) -> \"EventHook\":\n        <IND>return self._on(subevent, extra_subevents, None, delimiter)\n    <DED>def _context_on(self, context: str, subevent: str,\n            extra_subevents: typing.List[str],\n            delimiter: str = DEFAULT_EVENT_DELIMITER) -> \"EventHook\":\n        <IND>return self._on(subevent, extra_subevents, context, delimiter)\n    <DED>def _on(self, subevent: str, extra_subevents: typing.List[str],\n            context: str, delimiter: str) -> \"EventHook\":\n        <IND>if delimiter in subevent:\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "            if not context == None:\n                <IND>context_hook = event_hook.new_context(typing.cast(str, context))\n                multiple_event_hook._add(typing.cast(EventHook, context_hook))\n            <DED>else:\n                <IND>multiple_event_hook._add(event_hook)\n        <DED><DED>return multiple_event_hook\n\n    <DED>def on(self, subevent: str, *extra_subevents: str,\n            delimiter: str = DEFAULT_EVENT_DELIMITER) -> \"EventHook\":\n        <IND>return self._on(subevent, extra_subevents, None, delimiter)\n    <DED>def _context_on(self, context: str, subevent: str,\n            extra_subevents: typing.Tuple[str, ...],\n            delimiter: str = DEFAULT_EVENT_DELIMITER) -> \"EventHook\":\n        <IND>return self._on(subevent, extra_subevents, context, delimiter)\n    <DED>def _on(self, subevent: str, extra_subevents: typing.Tuple[str, ...],\n            context: typing.Optional[str], delimiter: str) -> \"EventHook\":\n        <IND>if delimiter in subevent:\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "            if not context == None:\n                return event_obj.new_context(context)\n            return event_obj\n",
        "source_code_len": 119,
        "target_code": "            if not context == None:\n                context_hook = event_obj.new_context(typing.cast(str, context))\n                return typing.cast(EventHook, context_hook)\n            return event_obj\n",
        "target_code_len": 205,
        "diff_format": "@@ -133,3 +142,4 @@\n             if not context == None:\n-                return event_obj.new_context(context)\n+                context_hook = event_obj.new_context(typing.cast(str, context))\n+                return typing.cast(EventHook, context_hook)\n             return event_obj\n",
        "source_code_with_indent": "            <DED>if not context == None:\n                <IND>return event_obj.new_context(context)\n            <DED>return event_obj\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "            <DED>if not context == None:\n                <IND>context_hook = event_obj.new_context(typing.cast(str, context))\n                return typing.cast(EventHook, context_hook)\n            <DED>return event_obj\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "        if not context == None:\n            child = child.new_context(context)\n        return child\n",
        "source_code_len": 100,
        "target_code": "        if not context == None:\n            context_child = child.new_context(typing.cast(str, context))\n            child = typing.cast(EventHook, context_child)\n        return child\n",
        "target_code_len": 184,
        "diff_format": "@@ -142,3 +153,4 @@\n         if not context == None:\n-            child = child.new_context(context)\n+            context_child = child.new_context(typing.cast(str, context))\n+            child = typing.cast(EventHook, context_child)\n         return child\n",
        "source_code_with_indent": "        if not context == None:\n            <IND>child = child.new_context(context)\n        <DED>return child\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "        if not context == None:\n            <IND>context_child = child.new_context(typing.cast(str, context))\n            child = typing.cast(EventHook, context_child)\n        <DED>return child\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "jesopo/bitbot",
    "commit": "b543e31cd2a665b25aab4554e46a0ed5067d1bfe",
    "filename": "src/EventManager.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/jesopo-bitbot/src/EventManager.py",
    "file_hunks_size": 15,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "src/EventManager.py:116:12 Incompatible variable type [9]: delimiter is declared to have type `int` but is used as type `str`.",
    "message": " delimiter is declared to have type `int` but is used as type `str`.",
    "rule_id": "Incompatible variable type [9]",
    "warning_line_no": 116,
    "warning_line": "            delimiter: int = DEFAULT_EVENT_DELIMITER) -> \"EventHook\":",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n    def _make_multiple_hook(self, source: \"EventHook\", context: str,\n            events: typing.List[str]) -> \"MultipleEventHook\":\n        multiple_event_hook = MultipleEventHook()\n",
        "source_code_len": 182,
        "target_code": "\n    def _make_multiple_hook(self, source: \"EventHook\",\n            context: typing.Optional[str],\n            events: typing.Iterable[str]) -> \"MultipleEventHook\":\n        multiple_event_hook = MultipleEventHook()\n",
        "target_code_len": 215,
        "diff_format": "@@ -104,4 +109,5 @@\n \n-    def _make_multiple_hook(self, source: \"EventHook\", context: str,\n-            events: typing.List[str]) -> \"MultipleEventHook\":\n+    def _make_multiple_hook(self, source: \"EventHook\",\n+            context: typing.Optional[str],\n+            events: typing.Iterable[str]) -> \"MultipleEventHook\":\n         multiple_event_hook = MultipleEventHook()\n",
        "source_code_with_indent": "\n    <DED><DED>def _make_multiple_hook(self, source: \"EventHook\", context: str,\n            events: typing.List[str]) -> \"MultipleEventHook\":\n        <IND>multiple_event_hook = MultipleEventHook()\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n    <DED><DED>def _make_multiple_hook(self, source: \"EventHook\",\n            context: typing.Optional[str],\n            events: typing.Iterable[str]) -> \"MultipleEventHook\":\n        <IND>multiple_event_hook = MultipleEventHook()\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "            if not context == None:\n                event_hook = event_hook.new_context(context)\n            multiple_event_hook._add(event_hook)\n        return multiple_event_hook\n\n    def on(self, subevent: str, *extra_subevents,\n            delimiter: int = DEFAULT_EVENT_DELIMITER) -> \"EventHook\":\n        return self._on(subevent, extra_subevents, None, delimiter)\n    def _context_on(self, context: str, subevent: str,\n            extra_subevents: typing.List[str],\n            delimiter: str = DEFAULT_EVENT_DELIMITER) -> \"EventHook\":\n        return self._on(subevent, extra_subevents, context, delimiter)\n    def _on(self, subevent: str, extra_subevents: typing.List[str],\n            context: str, delimiter: str) -> \"EventHook\":\n        if delimiter in subevent:\n",
        "source_code_len": 773,
        "target_code": "            if not context == None:\n                context_hook = event_hook.new_context(typing.cast(str, context))\n                multiple_event_hook._add(typing.cast(EventHook, context_hook))\n            else:\n                multiple_event_hook._add(event_hook)\n        return multiple_event_hook\n\n    def on(self, subevent: str, *extra_subevents: str,\n            delimiter: str = DEFAULT_EVENT_DELIMITER) -> \"EventHook\":\n        return self._on(subevent, extra_subevents, None, delimiter)\n    def _context_on(self, context: str, subevent: str,\n            extra_subevents: typing.Tuple[str, ...],\n            delimiter: str = DEFAULT_EVENT_DELIMITER) -> \"EventHook\":\n        return self._on(subevent, extra_subevents, context, delimiter)\n    def _on(self, subevent: str, extra_subevents: typing.Tuple[str, ...],\n            context: typing.Optional[str], delimiter: str) -> \"EventHook\":\n        if delimiter in subevent:\n",
        "target_code_len": 928,
        "diff_format": "@@ -110,15 +116,17 @@\n             if not context == None:\n-                event_hook = event_hook.new_context(context)\n-            multiple_event_hook._add(event_hook)\n+                context_hook = event_hook.new_context(typing.cast(str, context))\n+                multiple_event_hook._add(typing.cast(EventHook, context_hook))\n+            else:\n+                multiple_event_hook._add(event_hook)\n         return multiple_event_hook\n \n-    def on(self, subevent: str, *extra_subevents,\n-            delimiter: int = DEFAULT_EVENT_DELIMITER) -> \"EventHook\":\n+    def on(self, subevent: str, *extra_subevents: str,\n+            delimiter: str = DEFAULT_EVENT_DELIMITER) -> \"EventHook\":\n         return self._on(subevent, extra_subevents, None, delimiter)\n     def _context_on(self, context: str, subevent: str,\n-            extra_subevents: typing.List[str],\n+            extra_subevents: typing.Tuple[str, ...],\n             delimiter: str = DEFAULT_EVENT_DELIMITER) -> \"EventHook\":\n         return self._on(subevent, extra_subevents, context, delimiter)\n-    def _on(self, subevent: str, extra_subevents: typing.List[str],\n-            context: str, delimiter: str) -> \"EventHook\":\n+    def _on(self, subevent: str, extra_subevents: typing.Tuple[str, ...],\n+            context: typing.Optional[str], delimiter: str) -> \"EventHook\":\n         if delimiter in subevent:\n",
        "source_code_with_indent": "            if not context == None:\n                <IND>event_hook = event_hook.new_context(context)\n            <DED>multiple_event_hook._add(event_hook)\n        <DED>return multiple_event_hook\n\n    <DED>def on(self, subevent: str, *extra_subevents,\n            delimiter: int = DEFAULT_EVENT_DELIMITER) -> \"EventHook\":\n        <IND>return self._on(subevent, extra_subevents, None, delimiter)\n    <DED>def _context_on(self, context: str, subevent: str,\n            extra_subevents: typing.List[str],\n            delimiter: str = DEFAULT_EVENT_DELIMITER) -> \"EventHook\":\n        <IND>return self._on(subevent, extra_subevents, context, delimiter)\n    <DED>def _on(self, subevent: str, extra_subevents: typing.List[str],\n            context: str, delimiter: str) -> \"EventHook\":\n        <IND>if delimiter in subevent:\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "            if not context == None:\n                <IND>context_hook = event_hook.new_context(typing.cast(str, context))\n                multiple_event_hook._add(typing.cast(EventHook, context_hook))\n            <DED>else:\n                <IND>multiple_event_hook._add(event_hook)\n        <DED><DED>return multiple_event_hook\n\n    <DED>def on(self, subevent: str, *extra_subevents: str,\n            delimiter: str = DEFAULT_EVENT_DELIMITER) -> \"EventHook\":\n        <IND>return self._on(subevent, extra_subevents, None, delimiter)\n    <DED>def _context_on(self, context: str, subevent: str,\n            extra_subevents: typing.Tuple[str, ...],\n            delimiter: str = DEFAULT_EVENT_DELIMITER) -> \"EventHook\":\n        <IND>return self._on(subevent, extra_subevents, context, delimiter)\n    <DED>def _on(self, subevent: str, extra_subevents: typing.Tuple[str, ...],\n            context: typing.Optional[str], delimiter: str) -> \"EventHook\":\n        <IND>if delimiter in subevent:\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "            if not context == None:\n                return event_obj.new_context(context)\n            return event_obj\n",
        "source_code_len": 119,
        "target_code": "            if not context == None:\n                context_hook = event_obj.new_context(typing.cast(str, context))\n                return typing.cast(EventHook, context_hook)\n            return event_obj\n",
        "target_code_len": 205,
        "diff_format": "@@ -133,3 +142,4 @@\n             if not context == None:\n-                return event_obj.new_context(context)\n+                context_hook = event_obj.new_context(typing.cast(str, context))\n+                return typing.cast(EventHook, context_hook)\n             return event_obj\n",
        "source_code_with_indent": "            <DED>if not context == None:\n                <IND>return event_obj.new_context(context)\n            <DED>return event_obj\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "            <DED>if not context == None:\n                <IND>context_hook = event_obj.new_context(typing.cast(str, context))\n                return typing.cast(EventHook, context_hook)\n            <DED>return event_obj\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "        if not context == None:\n            child = child.new_context(context)\n        return child\n",
        "source_code_len": 100,
        "target_code": "        if not context == None:\n            context_child = child.new_context(typing.cast(str, context))\n            child = typing.cast(EventHook, context_child)\n        return child\n",
        "target_code_len": 184,
        "diff_format": "@@ -142,3 +153,4 @@\n         if not context == None:\n-            child = child.new_context(context)\n+            context_child = child.new_context(typing.cast(str, context))\n+            child = typing.cast(EventHook, context_child)\n         return child\n",
        "source_code_with_indent": "        if not context == None:\n            <IND>child = child.new_context(context)\n        <DED>return child\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "        if not context == None:\n            <IND>context_child = child.new_context(typing.cast(str, context))\n            child = typing.cast(EventHook, context_child)\n        <DED>return child\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "jesopo/bitbot",
    "commit": "b543e31cd2a665b25aab4554e46a0ed5067d1bfe",
    "filename": "src/EventManager.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/jesopo-bitbot/src/EventManager.py",
    "file_hunks_size": 15,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "src/EventManager.py:117:34 Incompatible parameter type [6]: Expected `typing.List[str]` for 2nd positional only parameter to call `EventHook._on` but got `typing.Tuple[typing.Any, ...]`.",
    "message": " Expected `typing.List[str]` for 2nd positional only parameter to call `EventHook._on` but got `typing.Tuple[typing.Any, ...]`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 117,
    "warning_line": "        return self._on(subevent, extra_subevents, None, delimiter)",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n    def _make_multiple_hook(self, source: \"EventHook\", context: str,\n            events: typing.List[str]) -> \"MultipleEventHook\":\n        multiple_event_hook = MultipleEventHook()\n",
        "source_code_len": 182,
        "target_code": "\n    def _make_multiple_hook(self, source: \"EventHook\",\n            context: typing.Optional[str],\n            events: typing.Iterable[str]) -> \"MultipleEventHook\":\n        multiple_event_hook = MultipleEventHook()\n",
        "target_code_len": 215,
        "diff_format": "@@ -104,4 +109,5 @@\n \n-    def _make_multiple_hook(self, source: \"EventHook\", context: str,\n-            events: typing.List[str]) -> \"MultipleEventHook\":\n+    def _make_multiple_hook(self, source: \"EventHook\",\n+            context: typing.Optional[str],\n+            events: typing.Iterable[str]) -> \"MultipleEventHook\":\n         multiple_event_hook = MultipleEventHook()\n",
        "source_code_with_indent": "\n    <DED><DED>def _make_multiple_hook(self, source: \"EventHook\", context: str,\n            events: typing.List[str]) -> \"MultipleEventHook\":\n        <IND>multiple_event_hook = MultipleEventHook()\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n    <DED><DED>def _make_multiple_hook(self, source: \"EventHook\",\n            context: typing.Optional[str],\n            events: typing.Iterable[str]) -> \"MultipleEventHook\":\n        <IND>multiple_event_hook = MultipleEventHook()\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "            if not context == None:\n                event_hook = event_hook.new_context(context)\n            multiple_event_hook._add(event_hook)\n        return multiple_event_hook\n\n    def on(self, subevent: str, *extra_subevents,\n            delimiter: int = DEFAULT_EVENT_DELIMITER) -> \"EventHook\":\n        return self._on(subevent, extra_subevents, None, delimiter)\n    def _context_on(self, context: str, subevent: str,\n            extra_subevents: typing.List[str],\n            delimiter: str = DEFAULT_EVENT_DELIMITER) -> \"EventHook\":\n        return self._on(subevent, extra_subevents, context, delimiter)\n    def _on(self, subevent: str, extra_subevents: typing.List[str],\n            context: str, delimiter: str) -> \"EventHook\":\n        if delimiter in subevent:\n",
        "source_code_len": 773,
        "target_code": "            if not context == None:\n                context_hook = event_hook.new_context(typing.cast(str, context))\n                multiple_event_hook._add(typing.cast(EventHook, context_hook))\n            else:\n                multiple_event_hook._add(event_hook)\n        return multiple_event_hook\n\n    def on(self, subevent: str, *extra_subevents: str,\n            delimiter: str = DEFAULT_EVENT_DELIMITER) -> \"EventHook\":\n        return self._on(subevent, extra_subevents, None, delimiter)\n    def _context_on(self, context: str, subevent: str,\n            extra_subevents: typing.Tuple[str, ...],\n            delimiter: str = DEFAULT_EVENT_DELIMITER) -> \"EventHook\":\n        return self._on(subevent, extra_subevents, context, delimiter)\n    def _on(self, subevent: str, extra_subevents: typing.Tuple[str, ...],\n            context: typing.Optional[str], delimiter: str) -> \"EventHook\":\n        if delimiter in subevent:\n",
        "target_code_len": 928,
        "diff_format": "@@ -110,15 +116,17 @@\n             if not context == None:\n-                event_hook = event_hook.new_context(context)\n-            multiple_event_hook._add(event_hook)\n+                context_hook = event_hook.new_context(typing.cast(str, context))\n+                multiple_event_hook._add(typing.cast(EventHook, context_hook))\n+            else:\n+                multiple_event_hook._add(event_hook)\n         return multiple_event_hook\n \n-    def on(self, subevent: str, *extra_subevents,\n-            delimiter: int = DEFAULT_EVENT_DELIMITER) -> \"EventHook\":\n+    def on(self, subevent: str, *extra_subevents: str,\n+            delimiter: str = DEFAULT_EVENT_DELIMITER) -> \"EventHook\":\n         return self._on(subevent, extra_subevents, None, delimiter)\n     def _context_on(self, context: str, subevent: str,\n-            extra_subevents: typing.List[str],\n+            extra_subevents: typing.Tuple[str, ...],\n             delimiter: str = DEFAULT_EVENT_DELIMITER) -> \"EventHook\":\n         return self._on(subevent, extra_subevents, context, delimiter)\n-    def _on(self, subevent: str, extra_subevents: typing.List[str],\n-            context: str, delimiter: str) -> \"EventHook\":\n+    def _on(self, subevent: str, extra_subevents: typing.Tuple[str, ...],\n+            context: typing.Optional[str], delimiter: str) -> \"EventHook\":\n         if delimiter in subevent:\n",
        "source_code_with_indent": "            if not context == None:\n                <IND>event_hook = event_hook.new_context(context)\n            <DED>multiple_event_hook._add(event_hook)\n        <DED>return multiple_event_hook\n\n    <DED>def on(self, subevent: str, *extra_subevents,\n            delimiter: int = DEFAULT_EVENT_DELIMITER) -> \"EventHook\":\n        <IND>return self._on(subevent, extra_subevents, None, delimiter)\n    <DED>def _context_on(self, context: str, subevent: str,\n            extra_subevents: typing.List[str],\n            delimiter: str = DEFAULT_EVENT_DELIMITER) -> \"EventHook\":\n        <IND>return self._on(subevent, extra_subevents, context, delimiter)\n    <DED>def _on(self, subevent: str, extra_subevents: typing.List[str],\n            context: str, delimiter: str) -> \"EventHook\":\n        <IND>if delimiter in subevent:\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "            if not context == None:\n                <IND>context_hook = event_hook.new_context(typing.cast(str, context))\n                multiple_event_hook._add(typing.cast(EventHook, context_hook))\n            <DED>else:\n                <IND>multiple_event_hook._add(event_hook)\n        <DED><DED>return multiple_event_hook\n\n    <DED>def on(self, subevent: str, *extra_subevents: str,\n            delimiter: str = DEFAULT_EVENT_DELIMITER) -> \"EventHook\":\n        <IND>return self._on(subevent, extra_subevents, None, delimiter)\n    <DED>def _context_on(self, context: str, subevent: str,\n            extra_subevents: typing.Tuple[str, ...],\n            delimiter: str = DEFAULT_EVENT_DELIMITER) -> \"EventHook\":\n        <IND>return self._on(subevent, extra_subevents, context, delimiter)\n    <DED>def _on(self, subevent: str, extra_subevents: typing.Tuple[str, ...],\n            context: typing.Optional[str], delimiter: str) -> \"EventHook\":\n        <IND>if delimiter in subevent:\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "            if not context == None:\n                return event_obj.new_context(context)\n            return event_obj\n",
        "source_code_len": 119,
        "target_code": "            if not context == None:\n                context_hook = event_obj.new_context(typing.cast(str, context))\n                return typing.cast(EventHook, context_hook)\n            return event_obj\n",
        "target_code_len": 205,
        "diff_format": "@@ -133,3 +142,4 @@\n             if not context == None:\n-                return event_obj.new_context(context)\n+                context_hook = event_obj.new_context(typing.cast(str, context))\n+                return typing.cast(EventHook, context_hook)\n             return event_obj\n",
        "source_code_with_indent": "            <DED>if not context == None:\n                <IND>return event_obj.new_context(context)\n            <DED>return event_obj\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "            <DED>if not context == None:\n                <IND>context_hook = event_obj.new_context(typing.cast(str, context))\n                return typing.cast(EventHook, context_hook)\n            <DED>return event_obj\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "        if not context == None:\n            child = child.new_context(context)\n        return child\n",
        "source_code_len": 100,
        "target_code": "        if not context == None:\n            context_child = child.new_context(typing.cast(str, context))\n            child = typing.cast(EventHook, context_child)\n        return child\n",
        "target_code_len": 184,
        "diff_format": "@@ -142,3 +153,4 @@\n         if not context == None:\n-            child = child.new_context(context)\n+            context_child = child.new_context(typing.cast(str, context))\n+            child = typing.cast(EventHook, context_child)\n         return child\n",
        "source_code_with_indent": "        if not context == None:\n            <IND>child = child.new_context(context)\n        <DED>return child\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "        if not context == None:\n            <IND>context_child = child.new_context(typing.cast(str, context))\n            child = typing.cast(EventHook, context_child)\n        <DED>return child\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "jesopo/bitbot",
    "commit": "b543e31cd2a665b25aab4554e46a0ed5067d1bfe",
    "filename": "src/EventManager.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/jesopo-bitbot/src/EventManager.py",
    "file_hunks_size": 15,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "src/EventManager.py:117:51 Incompatible parameter type [6]: Expected `str` for 3rd positional only parameter to call `EventHook._on` but got `None`.",
    "message": " Expected `str` for 3rd positional only parameter to call `EventHook._on` but got `None`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 117,
    "warning_line": "        return self._on(subevent, extra_subevents, None, delimiter)",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n    def _make_multiple_hook(self, source: \"EventHook\", context: str,\n            events: typing.List[str]) -> \"MultipleEventHook\":\n        multiple_event_hook = MultipleEventHook()\n",
        "source_code_len": 182,
        "target_code": "\n    def _make_multiple_hook(self, source: \"EventHook\",\n            context: typing.Optional[str],\n            events: typing.Iterable[str]) -> \"MultipleEventHook\":\n        multiple_event_hook = MultipleEventHook()\n",
        "target_code_len": 215,
        "diff_format": "@@ -104,4 +109,5 @@\n \n-    def _make_multiple_hook(self, source: \"EventHook\", context: str,\n-            events: typing.List[str]) -> \"MultipleEventHook\":\n+    def _make_multiple_hook(self, source: \"EventHook\",\n+            context: typing.Optional[str],\n+            events: typing.Iterable[str]) -> \"MultipleEventHook\":\n         multiple_event_hook = MultipleEventHook()\n",
        "source_code_with_indent": "\n    <DED><DED>def _make_multiple_hook(self, source: \"EventHook\", context: str,\n            events: typing.List[str]) -> \"MultipleEventHook\":\n        <IND>multiple_event_hook = MultipleEventHook()\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n    <DED><DED>def _make_multiple_hook(self, source: \"EventHook\",\n            context: typing.Optional[str],\n            events: typing.Iterable[str]) -> \"MultipleEventHook\":\n        <IND>multiple_event_hook = MultipleEventHook()\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "            if not context == None:\n                event_hook = event_hook.new_context(context)\n            multiple_event_hook._add(event_hook)\n        return multiple_event_hook\n\n    def on(self, subevent: str, *extra_subevents,\n            delimiter: int = DEFAULT_EVENT_DELIMITER) -> \"EventHook\":\n        return self._on(subevent, extra_subevents, None, delimiter)\n    def _context_on(self, context: str, subevent: str,\n            extra_subevents: typing.List[str],\n            delimiter: str = DEFAULT_EVENT_DELIMITER) -> \"EventHook\":\n        return self._on(subevent, extra_subevents, context, delimiter)\n    def _on(self, subevent: str, extra_subevents: typing.List[str],\n            context: str, delimiter: str) -> \"EventHook\":\n        if delimiter in subevent:\n",
        "source_code_len": 773,
        "target_code": "            if not context == None:\n                context_hook = event_hook.new_context(typing.cast(str, context))\n                multiple_event_hook._add(typing.cast(EventHook, context_hook))\n            else:\n                multiple_event_hook._add(event_hook)\n        return multiple_event_hook\n\n    def on(self, subevent: str, *extra_subevents: str,\n            delimiter: str = DEFAULT_EVENT_DELIMITER) -> \"EventHook\":\n        return self._on(subevent, extra_subevents, None, delimiter)\n    def _context_on(self, context: str, subevent: str,\n            extra_subevents: typing.Tuple[str, ...],\n            delimiter: str = DEFAULT_EVENT_DELIMITER) -> \"EventHook\":\n        return self._on(subevent, extra_subevents, context, delimiter)\n    def _on(self, subevent: str, extra_subevents: typing.Tuple[str, ...],\n            context: typing.Optional[str], delimiter: str) -> \"EventHook\":\n        if delimiter in subevent:\n",
        "target_code_len": 928,
        "diff_format": "@@ -110,15 +116,17 @@\n             if not context == None:\n-                event_hook = event_hook.new_context(context)\n-            multiple_event_hook._add(event_hook)\n+                context_hook = event_hook.new_context(typing.cast(str, context))\n+                multiple_event_hook._add(typing.cast(EventHook, context_hook))\n+            else:\n+                multiple_event_hook._add(event_hook)\n         return multiple_event_hook\n \n-    def on(self, subevent: str, *extra_subevents,\n-            delimiter: int = DEFAULT_EVENT_DELIMITER) -> \"EventHook\":\n+    def on(self, subevent: str, *extra_subevents: str,\n+            delimiter: str = DEFAULT_EVENT_DELIMITER) -> \"EventHook\":\n         return self._on(subevent, extra_subevents, None, delimiter)\n     def _context_on(self, context: str, subevent: str,\n-            extra_subevents: typing.List[str],\n+            extra_subevents: typing.Tuple[str, ...],\n             delimiter: str = DEFAULT_EVENT_DELIMITER) -> \"EventHook\":\n         return self._on(subevent, extra_subevents, context, delimiter)\n-    def _on(self, subevent: str, extra_subevents: typing.List[str],\n-            context: str, delimiter: str) -> \"EventHook\":\n+    def _on(self, subevent: str, extra_subevents: typing.Tuple[str, ...],\n+            context: typing.Optional[str], delimiter: str) -> \"EventHook\":\n         if delimiter in subevent:\n",
        "source_code_with_indent": "            if not context == None:\n                <IND>event_hook = event_hook.new_context(context)\n            <DED>multiple_event_hook._add(event_hook)\n        <DED>return multiple_event_hook\n\n    <DED>def on(self, subevent: str, *extra_subevents,\n            delimiter: int = DEFAULT_EVENT_DELIMITER) -> \"EventHook\":\n        <IND>return self._on(subevent, extra_subevents, None, delimiter)\n    <DED>def _context_on(self, context: str, subevent: str,\n            extra_subevents: typing.List[str],\n            delimiter: str = DEFAULT_EVENT_DELIMITER) -> \"EventHook\":\n        <IND>return self._on(subevent, extra_subevents, context, delimiter)\n    <DED>def _on(self, subevent: str, extra_subevents: typing.List[str],\n            context: str, delimiter: str) -> \"EventHook\":\n        <IND>if delimiter in subevent:\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "            if not context == None:\n                <IND>context_hook = event_hook.new_context(typing.cast(str, context))\n                multiple_event_hook._add(typing.cast(EventHook, context_hook))\n            <DED>else:\n                <IND>multiple_event_hook._add(event_hook)\n        <DED><DED>return multiple_event_hook\n\n    <DED>def on(self, subevent: str, *extra_subevents: str,\n            delimiter: str = DEFAULT_EVENT_DELIMITER) -> \"EventHook\":\n        <IND>return self._on(subevent, extra_subevents, None, delimiter)\n    <DED>def _context_on(self, context: str, subevent: str,\n            extra_subevents: typing.Tuple[str, ...],\n            delimiter: str = DEFAULT_EVENT_DELIMITER) -> \"EventHook\":\n        <IND>return self._on(subevent, extra_subevents, context, delimiter)\n    <DED>def _on(self, subevent: str, extra_subevents: typing.Tuple[str, ...],\n            context: typing.Optional[str], delimiter: str) -> \"EventHook\":\n        <IND>if delimiter in subevent:\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "            if not context == None:\n                return event_obj.new_context(context)\n            return event_obj\n",
        "source_code_len": 119,
        "target_code": "            if not context == None:\n                context_hook = event_obj.new_context(typing.cast(str, context))\n                return typing.cast(EventHook, context_hook)\n            return event_obj\n",
        "target_code_len": 205,
        "diff_format": "@@ -133,3 +142,4 @@\n             if not context == None:\n-                return event_obj.new_context(context)\n+                context_hook = event_obj.new_context(typing.cast(str, context))\n+                return typing.cast(EventHook, context_hook)\n             return event_obj\n",
        "source_code_with_indent": "            <DED>if not context == None:\n                <IND>return event_obj.new_context(context)\n            <DED>return event_obj\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "            <DED>if not context == None:\n                <IND>context_hook = event_obj.new_context(typing.cast(str, context))\n                return typing.cast(EventHook, context_hook)\n            <DED>return event_obj\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "        if not context == None:\n            child = child.new_context(context)\n        return child\n",
        "source_code_len": 100,
        "target_code": "        if not context == None:\n            context_child = child.new_context(typing.cast(str, context))\n            child = typing.cast(EventHook, context_child)\n        return child\n",
        "target_code_len": 184,
        "diff_format": "@@ -142,3 +153,4 @@\n         if not context == None:\n-            child = child.new_context(context)\n+            context_child = child.new_context(typing.cast(str, context))\n+            child = typing.cast(EventHook, context_child)\n         return child\n",
        "source_code_with_indent": "        if not context == None:\n            <IND>child = child.new_context(context)\n        <DED>return child\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "        if not context == None:\n            <IND>context_child = child.new_context(typing.cast(str, context))\n            child = typing.cast(EventHook, context_child)\n        <DED>return child\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "jesopo/bitbot",
    "commit": "b543e31cd2a665b25aab4554e46a0ed5067d1bfe",
    "filename": "src/EventManager.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/jesopo-bitbot/src/EventManager.py",
    "file_hunks_size": 15,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "src/EventManager.py:117:57 Incompatible parameter type [6]: Expected `str` for 4th positional only parameter to call `EventHook._on` but got `int`.",
    "message": " Expected `str` for 4th positional only parameter to call `EventHook._on` but got `int`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 117,
    "warning_line": "        return self._on(subevent, extra_subevents, None, delimiter)",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n    def _make_multiple_hook(self, source: \"EventHook\", context: str,\n            events: typing.List[str]) -> \"MultipleEventHook\":\n        multiple_event_hook = MultipleEventHook()\n",
        "source_code_len": 182,
        "target_code": "\n    def _make_multiple_hook(self, source: \"EventHook\",\n            context: typing.Optional[str],\n            events: typing.Iterable[str]) -> \"MultipleEventHook\":\n        multiple_event_hook = MultipleEventHook()\n",
        "target_code_len": 215,
        "diff_format": "@@ -104,4 +109,5 @@\n \n-    def _make_multiple_hook(self, source: \"EventHook\", context: str,\n-            events: typing.List[str]) -> \"MultipleEventHook\":\n+    def _make_multiple_hook(self, source: \"EventHook\",\n+            context: typing.Optional[str],\n+            events: typing.Iterable[str]) -> \"MultipleEventHook\":\n         multiple_event_hook = MultipleEventHook()\n",
        "source_code_with_indent": "\n    <DED><DED>def _make_multiple_hook(self, source: \"EventHook\", context: str,\n            events: typing.List[str]) -> \"MultipleEventHook\":\n        <IND>multiple_event_hook = MultipleEventHook()\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n    <DED><DED>def _make_multiple_hook(self, source: \"EventHook\",\n            context: typing.Optional[str],\n            events: typing.Iterable[str]) -> \"MultipleEventHook\":\n        <IND>multiple_event_hook = MultipleEventHook()\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "            if not context == None:\n                event_hook = event_hook.new_context(context)\n            multiple_event_hook._add(event_hook)\n        return multiple_event_hook\n\n    def on(self, subevent: str, *extra_subevents,\n            delimiter: int = DEFAULT_EVENT_DELIMITER) -> \"EventHook\":\n        return self._on(subevent, extra_subevents, None, delimiter)\n    def _context_on(self, context: str, subevent: str,\n            extra_subevents: typing.List[str],\n            delimiter: str = DEFAULT_EVENT_DELIMITER) -> \"EventHook\":\n        return self._on(subevent, extra_subevents, context, delimiter)\n    def _on(self, subevent: str, extra_subevents: typing.List[str],\n            context: str, delimiter: str) -> \"EventHook\":\n        if delimiter in subevent:\n",
        "source_code_len": 773,
        "target_code": "            if not context == None:\n                context_hook = event_hook.new_context(typing.cast(str, context))\n                multiple_event_hook._add(typing.cast(EventHook, context_hook))\n            else:\n                multiple_event_hook._add(event_hook)\n        return multiple_event_hook\n\n    def on(self, subevent: str, *extra_subevents: str,\n            delimiter: str = DEFAULT_EVENT_DELIMITER) -> \"EventHook\":\n        return self._on(subevent, extra_subevents, None, delimiter)\n    def _context_on(self, context: str, subevent: str,\n            extra_subevents: typing.Tuple[str, ...],\n            delimiter: str = DEFAULT_EVENT_DELIMITER) -> \"EventHook\":\n        return self._on(subevent, extra_subevents, context, delimiter)\n    def _on(self, subevent: str, extra_subevents: typing.Tuple[str, ...],\n            context: typing.Optional[str], delimiter: str) -> \"EventHook\":\n        if delimiter in subevent:\n",
        "target_code_len": 928,
        "diff_format": "@@ -110,15 +116,17 @@\n             if not context == None:\n-                event_hook = event_hook.new_context(context)\n-            multiple_event_hook._add(event_hook)\n+                context_hook = event_hook.new_context(typing.cast(str, context))\n+                multiple_event_hook._add(typing.cast(EventHook, context_hook))\n+            else:\n+                multiple_event_hook._add(event_hook)\n         return multiple_event_hook\n \n-    def on(self, subevent: str, *extra_subevents,\n-            delimiter: int = DEFAULT_EVENT_DELIMITER) -> \"EventHook\":\n+    def on(self, subevent: str, *extra_subevents: str,\n+            delimiter: str = DEFAULT_EVENT_DELIMITER) -> \"EventHook\":\n         return self._on(subevent, extra_subevents, None, delimiter)\n     def _context_on(self, context: str, subevent: str,\n-            extra_subevents: typing.List[str],\n+            extra_subevents: typing.Tuple[str, ...],\n             delimiter: str = DEFAULT_EVENT_DELIMITER) -> \"EventHook\":\n         return self._on(subevent, extra_subevents, context, delimiter)\n-    def _on(self, subevent: str, extra_subevents: typing.List[str],\n-            context: str, delimiter: str) -> \"EventHook\":\n+    def _on(self, subevent: str, extra_subevents: typing.Tuple[str, ...],\n+            context: typing.Optional[str], delimiter: str) -> \"EventHook\":\n         if delimiter in subevent:\n",
        "source_code_with_indent": "            if not context == None:\n                <IND>event_hook = event_hook.new_context(context)\n            <DED>multiple_event_hook._add(event_hook)\n        <DED>return multiple_event_hook\n\n    <DED>def on(self, subevent: str, *extra_subevents,\n            delimiter: int = DEFAULT_EVENT_DELIMITER) -> \"EventHook\":\n        <IND>return self._on(subevent, extra_subevents, None, delimiter)\n    <DED>def _context_on(self, context: str, subevent: str,\n            extra_subevents: typing.List[str],\n            delimiter: str = DEFAULT_EVENT_DELIMITER) -> \"EventHook\":\n        <IND>return self._on(subevent, extra_subevents, context, delimiter)\n    <DED>def _on(self, subevent: str, extra_subevents: typing.List[str],\n            context: str, delimiter: str) -> \"EventHook\":\n        <IND>if delimiter in subevent:\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "            if not context == None:\n                <IND>context_hook = event_hook.new_context(typing.cast(str, context))\n                multiple_event_hook._add(typing.cast(EventHook, context_hook))\n            <DED>else:\n                <IND>multiple_event_hook._add(event_hook)\n        <DED><DED>return multiple_event_hook\n\n    <DED>def on(self, subevent: str, *extra_subevents: str,\n            delimiter: str = DEFAULT_EVENT_DELIMITER) -> \"EventHook\":\n        <IND>return self._on(subevent, extra_subevents, None, delimiter)\n    <DED>def _context_on(self, context: str, subevent: str,\n            extra_subevents: typing.Tuple[str, ...],\n            delimiter: str = DEFAULT_EVENT_DELIMITER) -> \"EventHook\":\n        <IND>return self._on(subevent, extra_subevents, context, delimiter)\n    <DED>def _on(self, subevent: str, extra_subevents: typing.Tuple[str, ...],\n            context: typing.Optional[str], delimiter: str) -> \"EventHook\":\n        <IND>if delimiter in subevent:\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "            if not context == None:\n                return event_obj.new_context(context)\n            return event_obj\n",
        "source_code_len": 119,
        "target_code": "            if not context == None:\n                context_hook = event_obj.new_context(typing.cast(str, context))\n                return typing.cast(EventHook, context_hook)\n            return event_obj\n",
        "target_code_len": 205,
        "diff_format": "@@ -133,3 +142,4 @@\n             if not context == None:\n-                return event_obj.new_context(context)\n+                context_hook = event_obj.new_context(typing.cast(str, context))\n+                return typing.cast(EventHook, context_hook)\n             return event_obj\n",
        "source_code_with_indent": "            <DED>if not context == None:\n                <IND>return event_obj.new_context(context)\n            <DED>return event_obj\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "            <DED>if not context == None:\n                <IND>context_hook = event_obj.new_context(typing.cast(str, context))\n                return typing.cast(EventHook, context_hook)\n            <DED>return event_obj\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "        if not context == None:\n            child = child.new_context(context)\n        return child\n",
        "source_code_len": 100,
        "target_code": "        if not context == None:\n            context_child = child.new_context(typing.cast(str, context))\n            child = typing.cast(EventHook, context_child)\n        return child\n",
        "target_code_len": 184,
        "diff_format": "@@ -142,3 +153,4 @@\n         if not context == None:\n-            child = child.new_context(context)\n+            context_child = child.new_context(typing.cast(str, context))\n+            child = typing.cast(EventHook, context_child)\n         return child\n",
        "source_code_with_indent": "        if not context == None:\n            <IND>child = child.new_context(context)\n        <DED>return child\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "        if not context == None:\n            <IND>context_child = child.new_context(typing.cast(str, context))\n            child = typing.cast(EventHook, context_child)\n        <DED>return child\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "jesopo/bitbot",
    "commit": "b543e31cd2a665b25aab4554e46a0ed5067d1bfe",
    "filename": "src/EventManager.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/jesopo-bitbot/src/EventManager.py",
    "file_hunks_size": 15,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": true,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "src/EventManager.py:129:20 Incompatible return type [7]: Expected `EventHook` but got `MultipleEventHook`.",
    "message": " Expected `EventHook` but got `MultipleEventHook`.",
    "rule_id": "Incompatible return type [7]",
    "warning_line_no": 129,
    "warning_line": "                    return self._make_multiple_hook(event_obj, context,",
    "min_patch": [
      {
        "hunk_fit_TFix": true,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "                if DEFAULT_MULTI_DELIMITER in event_name:\n                    return self._make_multiple_hook(event_obj, context,\n                        event_name.split(DEFAULT_MULTI_DELIMITER))\n\n",
        "source_code_len": 198,
        "target_code": "                if DEFAULT_MULTI_DELIMITER in event_name:\n                    multiple_hook = self._make_multiple_hook(event_obj, context,\n                        event_name.split(DEFAULT_MULTI_DELIMITER))\n                    return typing.cast(EventHook, multiple_hook)\n\n",
        "target_code_len": 272,
        "diff_format": "@@ -128,4 +136,5 @@\n                 if DEFAULT_MULTI_DELIMITER in event_name:\n-                    return self._make_multiple_hook(event_obj, context,\n+                    multiple_hook = self._make_multiple_hook(event_obj, context,\n                         event_name.split(DEFAULT_MULTI_DELIMITER))\n+                    return typing.cast(EventHook, multiple_hook)\n \n",
        "source_code_with_indent": "                <IND>if DEFAULT_MULTI_DELIMITER in event_name:\n                    <IND>return self._make_multiple_hook(event_obj, context,\n                        event_name.split(DEFAULT_MULTI_DELIMITER))\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "                <IND>if DEFAULT_MULTI_DELIMITER in event_name:\n                    <IND>multiple_hook = self._make_multiple_hook(event_obj, context,\n                        event_name.split(DEFAULT_MULTI_DELIMITER))\n                    return typing.cast(EventHook, multiple_hook)\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "jesopo/bitbot",
    "commit": "b543e31cd2a665b25aab4554e46a0ed5067d1bfe",
    "filename": "src/EventManager.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/jesopo-bitbot/src/EventManager.py",
    "file_hunks_size": 15,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "src/EventManager.py:134:16 Incompatible return type [7]: Expected `EventHook` but got `EventHookContext`.",
    "message": " Expected `EventHook` but got `EventHookContext`.",
    "rule_id": "Incompatible return type [7]",
    "warning_line_no": 134,
    "warning_line": "                return event_obj.new_context(context)",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n    def _make_multiple_hook(self, source: \"EventHook\", context: str,\n            events: typing.List[str]) -> \"MultipleEventHook\":\n        multiple_event_hook = MultipleEventHook()\n",
        "source_code_len": 182,
        "target_code": "\n    def _make_multiple_hook(self, source: \"EventHook\",\n            context: typing.Optional[str],\n            events: typing.Iterable[str]) -> \"MultipleEventHook\":\n        multiple_event_hook = MultipleEventHook()\n",
        "target_code_len": 215,
        "diff_format": "@@ -104,4 +109,5 @@\n \n-    def _make_multiple_hook(self, source: \"EventHook\", context: str,\n-            events: typing.List[str]) -> \"MultipleEventHook\":\n+    def _make_multiple_hook(self, source: \"EventHook\",\n+            context: typing.Optional[str],\n+            events: typing.Iterable[str]) -> \"MultipleEventHook\":\n         multiple_event_hook = MultipleEventHook()\n",
        "source_code_with_indent": "\n    <DED><DED>def _make_multiple_hook(self, source: \"EventHook\", context: str,\n            events: typing.List[str]) -> \"MultipleEventHook\":\n        <IND>multiple_event_hook = MultipleEventHook()\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n    <DED><DED>def _make_multiple_hook(self, source: \"EventHook\",\n            context: typing.Optional[str],\n            events: typing.Iterable[str]) -> \"MultipleEventHook\":\n        <IND>multiple_event_hook = MultipleEventHook()\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "            if not context == None:\n                event_hook = event_hook.new_context(context)\n            multiple_event_hook._add(event_hook)\n        return multiple_event_hook\n\n    def on(self, subevent: str, *extra_subevents,\n            delimiter: int = DEFAULT_EVENT_DELIMITER) -> \"EventHook\":\n        return self._on(subevent, extra_subevents, None, delimiter)\n    def _context_on(self, context: str, subevent: str,\n            extra_subevents: typing.List[str],\n            delimiter: str = DEFAULT_EVENT_DELIMITER) -> \"EventHook\":\n        return self._on(subevent, extra_subevents, context, delimiter)\n    def _on(self, subevent: str, extra_subevents: typing.List[str],\n            context: str, delimiter: str) -> \"EventHook\":\n        if delimiter in subevent:\n",
        "source_code_len": 773,
        "target_code": "            if not context == None:\n                context_hook = event_hook.new_context(typing.cast(str, context))\n                multiple_event_hook._add(typing.cast(EventHook, context_hook))\n            else:\n                multiple_event_hook._add(event_hook)\n        return multiple_event_hook\n\n    def on(self, subevent: str, *extra_subevents: str,\n            delimiter: str = DEFAULT_EVENT_DELIMITER) -> \"EventHook\":\n        return self._on(subevent, extra_subevents, None, delimiter)\n    def _context_on(self, context: str, subevent: str,\n            extra_subevents: typing.Tuple[str, ...],\n            delimiter: str = DEFAULT_EVENT_DELIMITER) -> \"EventHook\":\n        return self._on(subevent, extra_subevents, context, delimiter)\n    def _on(self, subevent: str, extra_subevents: typing.Tuple[str, ...],\n            context: typing.Optional[str], delimiter: str) -> \"EventHook\":\n        if delimiter in subevent:\n",
        "target_code_len": 928,
        "diff_format": "@@ -110,15 +116,17 @@\n             if not context == None:\n-                event_hook = event_hook.new_context(context)\n-            multiple_event_hook._add(event_hook)\n+                context_hook = event_hook.new_context(typing.cast(str, context))\n+                multiple_event_hook._add(typing.cast(EventHook, context_hook))\n+            else:\n+                multiple_event_hook._add(event_hook)\n         return multiple_event_hook\n \n-    def on(self, subevent: str, *extra_subevents,\n-            delimiter: int = DEFAULT_EVENT_DELIMITER) -> \"EventHook\":\n+    def on(self, subevent: str, *extra_subevents: str,\n+            delimiter: str = DEFAULT_EVENT_DELIMITER) -> \"EventHook\":\n         return self._on(subevent, extra_subevents, None, delimiter)\n     def _context_on(self, context: str, subevent: str,\n-            extra_subevents: typing.List[str],\n+            extra_subevents: typing.Tuple[str, ...],\n             delimiter: str = DEFAULT_EVENT_DELIMITER) -> \"EventHook\":\n         return self._on(subevent, extra_subevents, context, delimiter)\n-    def _on(self, subevent: str, extra_subevents: typing.List[str],\n-            context: str, delimiter: str) -> \"EventHook\":\n+    def _on(self, subevent: str, extra_subevents: typing.Tuple[str, ...],\n+            context: typing.Optional[str], delimiter: str) -> \"EventHook\":\n         if delimiter in subevent:\n",
        "source_code_with_indent": "            if not context == None:\n                <IND>event_hook = event_hook.new_context(context)\n            <DED>multiple_event_hook._add(event_hook)\n        <DED>return multiple_event_hook\n\n    <DED>def on(self, subevent: str, *extra_subevents,\n            delimiter: int = DEFAULT_EVENT_DELIMITER) -> \"EventHook\":\n        <IND>return self._on(subevent, extra_subevents, None, delimiter)\n    <DED>def _context_on(self, context: str, subevent: str,\n            extra_subevents: typing.List[str],\n            delimiter: str = DEFAULT_EVENT_DELIMITER) -> \"EventHook\":\n        <IND>return self._on(subevent, extra_subevents, context, delimiter)\n    <DED>def _on(self, subevent: str, extra_subevents: typing.List[str],\n            context: str, delimiter: str) -> \"EventHook\":\n        <IND>if delimiter in subevent:\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "            if not context == None:\n                <IND>context_hook = event_hook.new_context(typing.cast(str, context))\n                multiple_event_hook._add(typing.cast(EventHook, context_hook))\n            <DED>else:\n                <IND>multiple_event_hook._add(event_hook)\n        <DED><DED>return multiple_event_hook\n\n    <DED>def on(self, subevent: str, *extra_subevents: str,\n            delimiter: str = DEFAULT_EVENT_DELIMITER) -> \"EventHook\":\n        <IND>return self._on(subevent, extra_subevents, None, delimiter)\n    <DED>def _context_on(self, context: str, subevent: str,\n            extra_subevents: typing.Tuple[str, ...],\n            delimiter: str = DEFAULT_EVENT_DELIMITER) -> \"EventHook\":\n        <IND>return self._on(subevent, extra_subevents, context, delimiter)\n    <DED>def _on(self, subevent: str, extra_subevents: typing.Tuple[str, ...],\n            context: typing.Optional[str], delimiter: str) -> \"EventHook\":\n        <IND>if delimiter in subevent:\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": true,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "            if not context == None:\n                return event_obj.new_context(context)\n            return event_obj\n",
        "source_code_len": 119,
        "target_code": "            if not context == None:\n                context_hook = event_obj.new_context(typing.cast(str, context))\n                return typing.cast(EventHook, context_hook)\n            return event_obj\n",
        "target_code_len": 205,
        "diff_format": "@@ -133,3 +142,4 @@\n             if not context == None:\n-                return event_obj.new_context(context)\n+                context_hook = event_obj.new_context(typing.cast(str, context))\n+                return typing.cast(EventHook, context_hook)\n             return event_obj\n",
        "source_code_with_indent": "            <DED>if not context == None:\n                <IND>return event_obj.new_context(context)\n            <DED>return event_obj\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "            <DED>if not context == None:\n                <IND>context_hook = event_obj.new_context(typing.cast(str, context))\n                return typing.cast(EventHook, context_hook)\n            <DED>return event_obj\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "        if not context == None:\n            child = child.new_context(context)\n        return child\n",
        "source_code_len": 100,
        "target_code": "        if not context == None:\n            context_child = child.new_context(typing.cast(str, context))\n            child = typing.cast(EventHook, context_child)\n        return child\n",
        "target_code_len": 184,
        "diff_format": "@@ -142,3 +153,4 @@\n         if not context == None:\n-            child = child.new_context(context)\n+            context_child = child.new_context(typing.cast(str, context))\n+            child = typing.cast(EventHook, context_child)\n         return child\n",
        "source_code_with_indent": "        if not context == None:\n            <IND>child = child.new_context(context)\n        <DED>return child\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "        if not context == None:\n            <IND>context_child = child.new_context(typing.cast(str, context))\n            child = typing.cast(EventHook, context_child)\n        <DED>return child\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "jesopo/bitbot",
    "commit": "b543e31cd2a665b25aab4554e46a0ed5067d1bfe",
    "filename": "src/EventManager.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/jesopo-bitbot/src/EventManager.py",
    "file_hunks_size": 15,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "src/EventManager.py:138:12 Incompatible return type [7]: Expected `EventHook` but got `MultipleEventHook`.",
    "message": " Expected `EventHook` but got `MultipleEventHook`.",
    "rule_id": "Incompatible return type [7]",
    "warning_line_no": 138,
    "warning_line": "            return self._make_multiple_hook(self, context,",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n    def _make_multiple_hook(self, source: \"EventHook\", context: str,\n            events: typing.List[str]) -> \"MultipleEventHook\":\n        multiple_event_hook = MultipleEventHook()\n",
        "source_code_len": 182,
        "target_code": "\n    def _make_multiple_hook(self, source: \"EventHook\",\n            context: typing.Optional[str],\n            events: typing.Iterable[str]) -> \"MultipleEventHook\":\n        multiple_event_hook = MultipleEventHook()\n",
        "target_code_len": 215,
        "diff_format": "@@ -104,4 +109,5 @@\n \n-    def _make_multiple_hook(self, source: \"EventHook\", context: str,\n-            events: typing.List[str]) -> \"MultipleEventHook\":\n+    def _make_multiple_hook(self, source: \"EventHook\",\n+            context: typing.Optional[str],\n+            events: typing.Iterable[str]) -> \"MultipleEventHook\":\n         multiple_event_hook = MultipleEventHook()\n",
        "source_code_with_indent": "\n    <DED><DED>def _make_multiple_hook(self, source: \"EventHook\", context: str,\n            events: typing.List[str]) -> \"MultipleEventHook\":\n        <IND>multiple_event_hook = MultipleEventHook()\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n    <DED><DED>def _make_multiple_hook(self, source: \"EventHook\",\n            context: typing.Optional[str],\n            events: typing.Iterable[str]) -> \"MultipleEventHook\":\n        <IND>multiple_event_hook = MultipleEventHook()\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "            if not context == None:\n                event_hook = event_hook.new_context(context)\n            multiple_event_hook._add(event_hook)\n        return multiple_event_hook\n\n    def on(self, subevent: str, *extra_subevents,\n            delimiter: int = DEFAULT_EVENT_DELIMITER) -> \"EventHook\":\n        return self._on(subevent, extra_subevents, None, delimiter)\n    def _context_on(self, context: str, subevent: str,\n            extra_subevents: typing.List[str],\n            delimiter: str = DEFAULT_EVENT_DELIMITER) -> \"EventHook\":\n        return self._on(subevent, extra_subevents, context, delimiter)\n    def _on(self, subevent: str, extra_subevents: typing.List[str],\n            context: str, delimiter: str) -> \"EventHook\":\n        if delimiter in subevent:\n",
        "source_code_len": 773,
        "target_code": "            if not context == None:\n                context_hook = event_hook.new_context(typing.cast(str, context))\n                multiple_event_hook._add(typing.cast(EventHook, context_hook))\n            else:\n                multiple_event_hook._add(event_hook)\n        return multiple_event_hook\n\n    def on(self, subevent: str, *extra_subevents: str,\n            delimiter: str = DEFAULT_EVENT_DELIMITER) -> \"EventHook\":\n        return self._on(subevent, extra_subevents, None, delimiter)\n    def _context_on(self, context: str, subevent: str,\n            extra_subevents: typing.Tuple[str, ...],\n            delimiter: str = DEFAULT_EVENT_DELIMITER) -> \"EventHook\":\n        return self._on(subevent, extra_subevents, context, delimiter)\n    def _on(self, subevent: str, extra_subevents: typing.Tuple[str, ...],\n            context: typing.Optional[str], delimiter: str) -> \"EventHook\":\n        if delimiter in subevent:\n",
        "target_code_len": 928,
        "diff_format": "@@ -110,15 +116,17 @@\n             if not context == None:\n-                event_hook = event_hook.new_context(context)\n-            multiple_event_hook._add(event_hook)\n+                context_hook = event_hook.new_context(typing.cast(str, context))\n+                multiple_event_hook._add(typing.cast(EventHook, context_hook))\n+            else:\n+                multiple_event_hook._add(event_hook)\n         return multiple_event_hook\n \n-    def on(self, subevent: str, *extra_subevents,\n-            delimiter: int = DEFAULT_EVENT_DELIMITER) -> \"EventHook\":\n+    def on(self, subevent: str, *extra_subevents: str,\n+            delimiter: str = DEFAULT_EVENT_DELIMITER) -> \"EventHook\":\n         return self._on(subevent, extra_subevents, None, delimiter)\n     def _context_on(self, context: str, subevent: str,\n-            extra_subevents: typing.List[str],\n+            extra_subevents: typing.Tuple[str, ...],\n             delimiter: str = DEFAULT_EVENT_DELIMITER) -> \"EventHook\":\n         return self._on(subevent, extra_subevents, context, delimiter)\n-    def _on(self, subevent: str, extra_subevents: typing.List[str],\n-            context: str, delimiter: str) -> \"EventHook\":\n+    def _on(self, subevent: str, extra_subevents: typing.Tuple[str, ...],\n+            context: typing.Optional[str], delimiter: str) -> \"EventHook\":\n         if delimiter in subevent:\n",
        "source_code_with_indent": "            if not context == None:\n                <IND>event_hook = event_hook.new_context(context)\n            <DED>multiple_event_hook._add(event_hook)\n        <DED>return multiple_event_hook\n\n    <DED>def on(self, subevent: str, *extra_subevents,\n            delimiter: int = DEFAULT_EVENT_DELIMITER) -> \"EventHook\":\n        <IND>return self._on(subevent, extra_subevents, None, delimiter)\n    <DED>def _context_on(self, context: str, subevent: str,\n            extra_subevents: typing.List[str],\n            delimiter: str = DEFAULT_EVENT_DELIMITER) -> \"EventHook\":\n        <IND>return self._on(subevent, extra_subevents, context, delimiter)\n    <DED>def _on(self, subevent: str, extra_subevents: typing.List[str],\n            context: str, delimiter: str) -> \"EventHook\":\n        <IND>if delimiter in subevent:\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "            if not context == None:\n                <IND>context_hook = event_hook.new_context(typing.cast(str, context))\n                multiple_event_hook._add(typing.cast(EventHook, context_hook))\n            <DED>else:\n                <IND>multiple_event_hook._add(event_hook)\n        <DED><DED>return multiple_event_hook\n\n    <DED>def on(self, subevent: str, *extra_subevents: str,\n            delimiter: str = DEFAULT_EVENT_DELIMITER) -> \"EventHook\":\n        <IND>return self._on(subevent, extra_subevents, None, delimiter)\n    <DED>def _context_on(self, context: str, subevent: str,\n            extra_subevents: typing.Tuple[str, ...],\n            delimiter: str = DEFAULT_EVENT_DELIMITER) -> \"EventHook\":\n        <IND>return self._on(subevent, extra_subevents, context, delimiter)\n    <DED>def _on(self, subevent: str, extra_subevents: typing.Tuple[str, ...],\n            context: typing.Optional[str], delimiter: str) -> \"EventHook\":\n        <IND>if delimiter in subevent:\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "            if not context == None:\n                return event_obj.new_context(context)\n            return event_obj\n",
        "source_code_len": 119,
        "target_code": "            if not context == None:\n                context_hook = event_obj.new_context(typing.cast(str, context))\n                return typing.cast(EventHook, context_hook)\n            return event_obj\n",
        "target_code_len": 205,
        "diff_format": "@@ -133,3 +142,4 @@\n             if not context == None:\n-                return event_obj.new_context(context)\n+                context_hook = event_obj.new_context(typing.cast(str, context))\n+                return typing.cast(EventHook, context_hook)\n             return event_obj\n",
        "source_code_with_indent": "            <DED>if not context == None:\n                <IND>return event_obj.new_context(context)\n            <DED>return event_obj\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "            <DED>if not context == None:\n                <IND>context_hook = event_obj.new_context(typing.cast(str, context))\n                return typing.cast(EventHook, context_hook)\n            <DED>return event_obj\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": true,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "        if extra_subevents:\n            return self._make_multiple_hook(self, context,\n                (subevent,)+extra_subevents)\n\n",
        "source_code_len": 133,
        "target_code": "        if extra_subevents:\n            multiple_hook = self._make_multiple_hook(self, context,\n                (subevent,)+extra_subevents)\n            return typing.cast(EventHook, multiple_hook)\n\n",
        "target_code_len": 199,
        "diff_format": "@@ -137,4 +147,5 @@\n         if extra_subevents:\n-            return self._make_multiple_hook(self, context,\n+            multiple_hook = self._make_multiple_hook(self, context,\n                 (subevent,)+extra_subevents)\n+            return typing.cast(EventHook, multiple_hook)\n \n",
        "source_code_with_indent": "        <DED>if extra_subevents:\n            <IND>return self._make_multiple_hook(self, context,\n                (subevent,)+extra_subevents)\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "        <DED>if extra_subevents:\n            <IND>multiple_hook = self._make_multiple_hook(self, context,\n                (subevent,)+extra_subevents)\n            return typing.cast(EventHook, multiple_hook)\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "        if not context == None:\n            child = child.new_context(context)\n        return child\n",
        "source_code_len": 100,
        "target_code": "        if not context == None:\n            context_child = child.new_context(typing.cast(str, context))\n            child = typing.cast(EventHook, context_child)\n        return child\n",
        "target_code_len": 184,
        "diff_format": "@@ -142,3 +153,4 @@\n         if not context == None:\n-            child = child.new_context(context)\n+            context_child = child.new_context(typing.cast(str, context))\n+            child = typing.cast(EventHook, context_child)\n         return child\n",
        "source_code_with_indent": "        if not context == None:\n            <IND>child = child.new_context(context)\n        <DED>return child\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "        if not context == None:\n            <IND>context_child = child.new_context(typing.cast(str, context))\n            child = typing.cast(EventHook, context_child)\n        <DED>return child\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "jesopo/bitbot",
    "commit": "b543e31cd2a665b25aab4554e46a0ed5067d1bfe",
    "filename": "src/EventManager.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/jesopo-bitbot/src/EventManager.py",
    "file_hunks_size": 15,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "src/EventManager.py:139:16 Incompatible parameter type [6]: Expected `typing.List[str]` for 3rd positional only parameter to call `EventHook._make_multiple_hook` but got `typing.Tuple[str, ...]`.",
    "message": " Expected `typing.List[str]` for 3rd positional only parameter to call `EventHook._make_multiple_hook` but got `typing.Tuple[str, ...]`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 139,
    "warning_line": "                (subevent,)+extra_subevents)",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n    def _make_multiple_hook(self, source: \"EventHook\", context: str,\n            events: typing.List[str]) -> \"MultipleEventHook\":\n        multiple_event_hook = MultipleEventHook()\n",
        "source_code_len": 182,
        "target_code": "\n    def _make_multiple_hook(self, source: \"EventHook\",\n            context: typing.Optional[str],\n            events: typing.Iterable[str]) -> \"MultipleEventHook\":\n        multiple_event_hook = MultipleEventHook()\n",
        "target_code_len": 215,
        "diff_format": "@@ -104,4 +109,5 @@\n \n-    def _make_multiple_hook(self, source: \"EventHook\", context: str,\n-            events: typing.List[str]) -> \"MultipleEventHook\":\n+    def _make_multiple_hook(self, source: \"EventHook\",\n+            context: typing.Optional[str],\n+            events: typing.Iterable[str]) -> \"MultipleEventHook\":\n         multiple_event_hook = MultipleEventHook()\n",
        "source_code_with_indent": "\n    <DED><DED>def _make_multiple_hook(self, source: \"EventHook\", context: str,\n            events: typing.List[str]) -> \"MultipleEventHook\":\n        <IND>multiple_event_hook = MultipleEventHook()\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n    <DED><DED>def _make_multiple_hook(self, source: \"EventHook\",\n            context: typing.Optional[str],\n            events: typing.Iterable[str]) -> \"MultipleEventHook\":\n        <IND>multiple_event_hook = MultipleEventHook()\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "            if not context == None:\n                event_hook = event_hook.new_context(context)\n            multiple_event_hook._add(event_hook)\n        return multiple_event_hook\n\n    def on(self, subevent: str, *extra_subevents,\n            delimiter: int = DEFAULT_EVENT_DELIMITER) -> \"EventHook\":\n        return self._on(subevent, extra_subevents, None, delimiter)\n    def _context_on(self, context: str, subevent: str,\n            extra_subevents: typing.List[str],\n            delimiter: str = DEFAULT_EVENT_DELIMITER) -> \"EventHook\":\n        return self._on(subevent, extra_subevents, context, delimiter)\n    def _on(self, subevent: str, extra_subevents: typing.List[str],\n            context: str, delimiter: str) -> \"EventHook\":\n        if delimiter in subevent:\n",
        "source_code_len": 773,
        "target_code": "            if not context == None:\n                context_hook = event_hook.new_context(typing.cast(str, context))\n                multiple_event_hook._add(typing.cast(EventHook, context_hook))\n            else:\n                multiple_event_hook._add(event_hook)\n        return multiple_event_hook\n\n    def on(self, subevent: str, *extra_subevents: str,\n            delimiter: str = DEFAULT_EVENT_DELIMITER) -> \"EventHook\":\n        return self._on(subevent, extra_subevents, None, delimiter)\n    def _context_on(self, context: str, subevent: str,\n            extra_subevents: typing.Tuple[str, ...],\n            delimiter: str = DEFAULT_EVENT_DELIMITER) -> \"EventHook\":\n        return self._on(subevent, extra_subevents, context, delimiter)\n    def _on(self, subevent: str, extra_subevents: typing.Tuple[str, ...],\n            context: typing.Optional[str], delimiter: str) -> \"EventHook\":\n        if delimiter in subevent:\n",
        "target_code_len": 928,
        "diff_format": "@@ -110,15 +116,17 @@\n             if not context == None:\n-                event_hook = event_hook.new_context(context)\n-            multiple_event_hook._add(event_hook)\n+                context_hook = event_hook.new_context(typing.cast(str, context))\n+                multiple_event_hook._add(typing.cast(EventHook, context_hook))\n+            else:\n+                multiple_event_hook._add(event_hook)\n         return multiple_event_hook\n \n-    def on(self, subevent: str, *extra_subevents,\n-            delimiter: int = DEFAULT_EVENT_DELIMITER) -> \"EventHook\":\n+    def on(self, subevent: str, *extra_subevents: str,\n+            delimiter: str = DEFAULT_EVENT_DELIMITER) -> \"EventHook\":\n         return self._on(subevent, extra_subevents, None, delimiter)\n     def _context_on(self, context: str, subevent: str,\n-            extra_subevents: typing.List[str],\n+            extra_subevents: typing.Tuple[str, ...],\n             delimiter: str = DEFAULT_EVENT_DELIMITER) -> \"EventHook\":\n         return self._on(subevent, extra_subevents, context, delimiter)\n-    def _on(self, subevent: str, extra_subevents: typing.List[str],\n-            context: str, delimiter: str) -> \"EventHook\":\n+    def _on(self, subevent: str, extra_subevents: typing.Tuple[str, ...],\n+            context: typing.Optional[str], delimiter: str) -> \"EventHook\":\n         if delimiter in subevent:\n",
        "source_code_with_indent": "            if not context == None:\n                <IND>event_hook = event_hook.new_context(context)\n            <DED>multiple_event_hook._add(event_hook)\n        <DED>return multiple_event_hook\n\n    <DED>def on(self, subevent: str, *extra_subevents,\n            delimiter: int = DEFAULT_EVENT_DELIMITER) -> \"EventHook\":\n        <IND>return self._on(subevent, extra_subevents, None, delimiter)\n    <DED>def _context_on(self, context: str, subevent: str,\n            extra_subevents: typing.List[str],\n            delimiter: str = DEFAULT_EVENT_DELIMITER) -> \"EventHook\":\n        <IND>return self._on(subevent, extra_subevents, context, delimiter)\n    <DED>def _on(self, subevent: str, extra_subevents: typing.List[str],\n            context: str, delimiter: str) -> \"EventHook\":\n        <IND>if delimiter in subevent:\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "            if not context == None:\n                <IND>context_hook = event_hook.new_context(typing.cast(str, context))\n                multiple_event_hook._add(typing.cast(EventHook, context_hook))\n            <DED>else:\n                <IND>multiple_event_hook._add(event_hook)\n        <DED><DED>return multiple_event_hook\n\n    <DED>def on(self, subevent: str, *extra_subevents: str,\n            delimiter: str = DEFAULT_EVENT_DELIMITER) -> \"EventHook\":\n        <IND>return self._on(subevent, extra_subevents, None, delimiter)\n    <DED>def _context_on(self, context: str, subevent: str,\n            extra_subevents: typing.Tuple[str, ...],\n            delimiter: str = DEFAULT_EVENT_DELIMITER) -> \"EventHook\":\n        <IND>return self._on(subevent, extra_subevents, context, delimiter)\n    <DED>def _on(self, subevent: str, extra_subevents: typing.Tuple[str, ...],\n            context: typing.Optional[str], delimiter: str) -> \"EventHook\":\n        <IND>if delimiter in subevent:\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "            if not context == None:\n                return event_obj.new_context(context)\n            return event_obj\n",
        "source_code_len": 119,
        "target_code": "            if not context == None:\n                context_hook = event_obj.new_context(typing.cast(str, context))\n                return typing.cast(EventHook, context_hook)\n            return event_obj\n",
        "target_code_len": 205,
        "diff_format": "@@ -133,3 +142,4 @@\n             if not context == None:\n-                return event_obj.new_context(context)\n+                context_hook = event_obj.new_context(typing.cast(str, context))\n+                return typing.cast(EventHook, context_hook)\n             return event_obj\n",
        "source_code_with_indent": "            <DED>if not context == None:\n                <IND>return event_obj.new_context(context)\n            <DED>return event_obj\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "            <DED>if not context == None:\n                <IND>context_hook = event_obj.new_context(typing.cast(str, context))\n                return typing.cast(EventHook, context_hook)\n            <DED>return event_obj\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "        if not context == None:\n            child = child.new_context(context)\n        return child\n",
        "source_code_len": 100,
        "target_code": "        if not context == None:\n            context_child = child.new_context(typing.cast(str, context))\n            child = typing.cast(EventHook, context_child)\n        return child\n",
        "target_code_len": 184,
        "diff_format": "@@ -142,3 +153,4 @@\n         if not context == None:\n-            child = child.new_context(context)\n+            context_child = child.new_context(typing.cast(str, context))\n+            child = typing.cast(EventHook, context_child)\n         return child\n",
        "source_code_with_indent": "        if not context == None:\n            <IND>child = child.new_context(context)\n        <DED>return child\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "        if not context == None:\n            <IND>context_child = child.new_context(typing.cast(str, context))\n            child = typing.cast(EventHook, context_child)\n        <DED>return child\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "jesopo/bitbot",
    "commit": "b543e31cd2a665b25aab4554e46a0ed5067d1bfe",
    "filename": "src/EventManager.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/jesopo-bitbot/src/EventManager.py",
    "file_hunks_size": 15,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "src/EventManager.py:139:28 Unsupported operand [58]: `+` is not supported for operand types `typing.Tuple[str]` and `typing.List[str]`.",
    "message": " `+` is not supported for operand types `typing.Tuple[str]` and `typing.List[str]`.",
    "rule_id": "Unsupported operand [58]",
    "warning_line_no": 139,
    "warning_line": "                (subevent,)+extra_subevents)",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n    def _make_multiple_hook(self, source: \"EventHook\", context: str,\n            events: typing.List[str]) -> \"MultipleEventHook\":\n        multiple_event_hook = MultipleEventHook()\n",
        "source_code_len": 182,
        "target_code": "\n    def _make_multiple_hook(self, source: \"EventHook\",\n            context: typing.Optional[str],\n            events: typing.Iterable[str]) -> \"MultipleEventHook\":\n        multiple_event_hook = MultipleEventHook()\n",
        "target_code_len": 215,
        "diff_format": "@@ -104,4 +109,5 @@\n \n-    def _make_multiple_hook(self, source: \"EventHook\", context: str,\n-            events: typing.List[str]) -> \"MultipleEventHook\":\n+    def _make_multiple_hook(self, source: \"EventHook\",\n+            context: typing.Optional[str],\n+            events: typing.Iterable[str]) -> \"MultipleEventHook\":\n         multiple_event_hook = MultipleEventHook()\n",
        "source_code_with_indent": "\n    <DED><DED>def _make_multiple_hook(self, source: \"EventHook\", context: str,\n            events: typing.List[str]) -> \"MultipleEventHook\":\n        <IND>multiple_event_hook = MultipleEventHook()\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n    <DED><DED>def _make_multiple_hook(self, source: \"EventHook\",\n            context: typing.Optional[str],\n            events: typing.Iterable[str]) -> \"MultipleEventHook\":\n        <IND>multiple_event_hook = MultipleEventHook()\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "            if not context == None:\n                event_hook = event_hook.new_context(context)\n            multiple_event_hook._add(event_hook)\n        return multiple_event_hook\n\n    def on(self, subevent: str, *extra_subevents,\n            delimiter: int = DEFAULT_EVENT_DELIMITER) -> \"EventHook\":\n        return self._on(subevent, extra_subevents, None, delimiter)\n    def _context_on(self, context: str, subevent: str,\n            extra_subevents: typing.List[str],\n            delimiter: str = DEFAULT_EVENT_DELIMITER) -> \"EventHook\":\n        return self._on(subevent, extra_subevents, context, delimiter)\n    def _on(self, subevent: str, extra_subevents: typing.List[str],\n            context: str, delimiter: str) -> \"EventHook\":\n        if delimiter in subevent:\n",
        "source_code_len": 773,
        "target_code": "            if not context == None:\n                context_hook = event_hook.new_context(typing.cast(str, context))\n                multiple_event_hook._add(typing.cast(EventHook, context_hook))\n            else:\n                multiple_event_hook._add(event_hook)\n        return multiple_event_hook\n\n    def on(self, subevent: str, *extra_subevents: str,\n            delimiter: str = DEFAULT_EVENT_DELIMITER) -> \"EventHook\":\n        return self._on(subevent, extra_subevents, None, delimiter)\n    def _context_on(self, context: str, subevent: str,\n            extra_subevents: typing.Tuple[str, ...],\n            delimiter: str = DEFAULT_EVENT_DELIMITER) -> \"EventHook\":\n        return self._on(subevent, extra_subevents, context, delimiter)\n    def _on(self, subevent: str, extra_subevents: typing.Tuple[str, ...],\n            context: typing.Optional[str], delimiter: str) -> \"EventHook\":\n        if delimiter in subevent:\n",
        "target_code_len": 928,
        "diff_format": "@@ -110,15 +116,17 @@\n             if not context == None:\n-                event_hook = event_hook.new_context(context)\n-            multiple_event_hook._add(event_hook)\n+                context_hook = event_hook.new_context(typing.cast(str, context))\n+                multiple_event_hook._add(typing.cast(EventHook, context_hook))\n+            else:\n+                multiple_event_hook._add(event_hook)\n         return multiple_event_hook\n \n-    def on(self, subevent: str, *extra_subevents,\n-            delimiter: int = DEFAULT_EVENT_DELIMITER) -> \"EventHook\":\n+    def on(self, subevent: str, *extra_subevents: str,\n+            delimiter: str = DEFAULT_EVENT_DELIMITER) -> \"EventHook\":\n         return self._on(subevent, extra_subevents, None, delimiter)\n     def _context_on(self, context: str, subevent: str,\n-            extra_subevents: typing.List[str],\n+            extra_subevents: typing.Tuple[str, ...],\n             delimiter: str = DEFAULT_EVENT_DELIMITER) -> \"EventHook\":\n         return self._on(subevent, extra_subevents, context, delimiter)\n-    def _on(self, subevent: str, extra_subevents: typing.List[str],\n-            context: str, delimiter: str) -> \"EventHook\":\n+    def _on(self, subevent: str, extra_subevents: typing.Tuple[str, ...],\n+            context: typing.Optional[str], delimiter: str) -> \"EventHook\":\n         if delimiter in subevent:\n",
        "source_code_with_indent": "            if not context == None:\n                <IND>event_hook = event_hook.new_context(context)\n            <DED>multiple_event_hook._add(event_hook)\n        <DED>return multiple_event_hook\n\n    <DED>def on(self, subevent: str, *extra_subevents,\n            delimiter: int = DEFAULT_EVENT_DELIMITER) -> \"EventHook\":\n        <IND>return self._on(subevent, extra_subevents, None, delimiter)\n    <DED>def _context_on(self, context: str, subevent: str,\n            extra_subevents: typing.List[str],\n            delimiter: str = DEFAULT_EVENT_DELIMITER) -> \"EventHook\":\n        <IND>return self._on(subevent, extra_subevents, context, delimiter)\n    <DED>def _on(self, subevent: str, extra_subevents: typing.List[str],\n            context: str, delimiter: str) -> \"EventHook\":\n        <IND>if delimiter in subevent:\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "            if not context == None:\n                <IND>context_hook = event_hook.new_context(typing.cast(str, context))\n                multiple_event_hook._add(typing.cast(EventHook, context_hook))\n            <DED>else:\n                <IND>multiple_event_hook._add(event_hook)\n        <DED><DED>return multiple_event_hook\n\n    <DED>def on(self, subevent: str, *extra_subevents: str,\n            delimiter: str = DEFAULT_EVENT_DELIMITER) -> \"EventHook\":\n        <IND>return self._on(subevent, extra_subevents, None, delimiter)\n    <DED>def _context_on(self, context: str, subevent: str,\n            extra_subevents: typing.Tuple[str, ...],\n            delimiter: str = DEFAULT_EVENT_DELIMITER) -> \"EventHook\":\n        <IND>return self._on(subevent, extra_subevents, context, delimiter)\n    <DED>def _on(self, subevent: str, extra_subevents: typing.Tuple[str, ...],\n            context: typing.Optional[str], delimiter: str) -> \"EventHook\":\n        <IND>if delimiter in subevent:\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "            if not context == None:\n                return event_obj.new_context(context)\n            return event_obj\n",
        "source_code_len": 119,
        "target_code": "            if not context == None:\n                context_hook = event_obj.new_context(typing.cast(str, context))\n                return typing.cast(EventHook, context_hook)\n            return event_obj\n",
        "target_code_len": 205,
        "diff_format": "@@ -133,3 +142,4 @@\n             if not context == None:\n-                return event_obj.new_context(context)\n+                context_hook = event_obj.new_context(typing.cast(str, context))\n+                return typing.cast(EventHook, context_hook)\n             return event_obj\n",
        "source_code_with_indent": "            <DED>if not context == None:\n                <IND>return event_obj.new_context(context)\n            <DED>return event_obj\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "            <DED>if not context == None:\n                <IND>context_hook = event_obj.new_context(typing.cast(str, context))\n                return typing.cast(EventHook, context_hook)\n            <DED>return event_obj\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "        if not context == None:\n            child = child.new_context(context)\n        return child\n",
        "source_code_len": 100,
        "target_code": "        if not context == None:\n            context_child = child.new_context(typing.cast(str, context))\n            child = typing.cast(EventHook, context_child)\n        return child\n",
        "target_code_len": 184,
        "diff_format": "@@ -142,3 +153,4 @@\n         if not context == None:\n-            child = child.new_context(context)\n+            context_child = child.new_context(typing.cast(str, context))\n+            child = typing.cast(EventHook, context_child)\n         return child\n",
        "source_code_with_indent": "        if not context == None:\n            <IND>child = child.new_context(context)\n        <DED>return child\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "        if not context == None:\n            <IND>context_child = child.new_context(typing.cast(str, context))\n            child = typing.cast(EventHook, context_child)\n        <DED>return child\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "jesopo/bitbot",
    "commit": "b543e31cd2a665b25aab4554e46a0ed5067d1bfe",
    "filename": "src/EventManager.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/jesopo-bitbot/src/EventManager.py",
    "file_hunks_size": 15,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "src/EventManager.py:144:8 Incompatible return type [7]: Expected `EventHook` but got `typing.Union[EventHook, EventHookContext]`.",
    "message": " Expected `EventHook` but got `typing.Union[EventHook, EventHookContext]`.",
    "rule_id": "Incompatible return type [7]",
    "warning_line_no": 144,
    "warning_line": "        return child",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n    def _make_multiple_hook(self, source: \"EventHook\", context: str,\n            events: typing.List[str]) -> \"MultipleEventHook\":\n        multiple_event_hook = MultipleEventHook()\n",
        "source_code_len": 182,
        "target_code": "\n    def _make_multiple_hook(self, source: \"EventHook\",\n            context: typing.Optional[str],\n            events: typing.Iterable[str]) -> \"MultipleEventHook\":\n        multiple_event_hook = MultipleEventHook()\n",
        "target_code_len": 215,
        "diff_format": "@@ -104,4 +109,5 @@\n \n-    def _make_multiple_hook(self, source: \"EventHook\", context: str,\n-            events: typing.List[str]) -> \"MultipleEventHook\":\n+    def _make_multiple_hook(self, source: \"EventHook\",\n+            context: typing.Optional[str],\n+            events: typing.Iterable[str]) -> \"MultipleEventHook\":\n         multiple_event_hook = MultipleEventHook()\n",
        "source_code_with_indent": "\n    <DED><DED>def _make_multiple_hook(self, source: \"EventHook\", context: str,\n            events: typing.List[str]) -> \"MultipleEventHook\":\n        <IND>multiple_event_hook = MultipleEventHook()\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n    <DED><DED>def _make_multiple_hook(self, source: \"EventHook\",\n            context: typing.Optional[str],\n            events: typing.Iterable[str]) -> \"MultipleEventHook\":\n        <IND>multiple_event_hook = MultipleEventHook()\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "            if not context == None:\n                event_hook = event_hook.new_context(context)\n            multiple_event_hook._add(event_hook)\n        return multiple_event_hook\n\n    def on(self, subevent: str, *extra_subevents,\n            delimiter: int = DEFAULT_EVENT_DELIMITER) -> \"EventHook\":\n        return self._on(subevent, extra_subevents, None, delimiter)\n    def _context_on(self, context: str, subevent: str,\n            extra_subevents: typing.List[str],\n            delimiter: str = DEFAULT_EVENT_DELIMITER) -> \"EventHook\":\n        return self._on(subevent, extra_subevents, context, delimiter)\n    def _on(self, subevent: str, extra_subevents: typing.List[str],\n            context: str, delimiter: str) -> \"EventHook\":\n        if delimiter in subevent:\n",
        "source_code_len": 773,
        "target_code": "            if not context == None:\n                context_hook = event_hook.new_context(typing.cast(str, context))\n                multiple_event_hook._add(typing.cast(EventHook, context_hook))\n            else:\n                multiple_event_hook._add(event_hook)\n        return multiple_event_hook\n\n    def on(self, subevent: str, *extra_subevents: str,\n            delimiter: str = DEFAULT_EVENT_DELIMITER) -> \"EventHook\":\n        return self._on(subevent, extra_subevents, None, delimiter)\n    def _context_on(self, context: str, subevent: str,\n            extra_subevents: typing.Tuple[str, ...],\n            delimiter: str = DEFAULT_EVENT_DELIMITER) -> \"EventHook\":\n        return self._on(subevent, extra_subevents, context, delimiter)\n    def _on(self, subevent: str, extra_subevents: typing.Tuple[str, ...],\n            context: typing.Optional[str], delimiter: str) -> \"EventHook\":\n        if delimiter in subevent:\n",
        "target_code_len": 928,
        "diff_format": "@@ -110,15 +116,17 @@\n             if not context == None:\n-                event_hook = event_hook.new_context(context)\n-            multiple_event_hook._add(event_hook)\n+                context_hook = event_hook.new_context(typing.cast(str, context))\n+                multiple_event_hook._add(typing.cast(EventHook, context_hook))\n+            else:\n+                multiple_event_hook._add(event_hook)\n         return multiple_event_hook\n \n-    def on(self, subevent: str, *extra_subevents,\n-            delimiter: int = DEFAULT_EVENT_DELIMITER) -> \"EventHook\":\n+    def on(self, subevent: str, *extra_subevents: str,\n+            delimiter: str = DEFAULT_EVENT_DELIMITER) -> \"EventHook\":\n         return self._on(subevent, extra_subevents, None, delimiter)\n     def _context_on(self, context: str, subevent: str,\n-            extra_subevents: typing.List[str],\n+            extra_subevents: typing.Tuple[str, ...],\n             delimiter: str = DEFAULT_EVENT_DELIMITER) -> \"EventHook\":\n         return self._on(subevent, extra_subevents, context, delimiter)\n-    def _on(self, subevent: str, extra_subevents: typing.List[str],\n-            context: str, delimiter: str) -> \"EventHook\":\n+    def _on(self, subevent: str, extra_subevents: typing.Tuple[str, ...],\n+            context: typing.Optional[str], delimiter: str) -> \"EventHook\":\n         if delimiter in subevent:\n",
        "source_code_with_indent": "            if not context == None:\n                <IND>event_hook = event_hook.new_context(context)\n            <DED>multiple_event_hook._add(event_hook)\n        <DED>return multiple_event_hook\n\n    <DED>def on(self, subevent: str, *extra_subevents,\n            delimiter: int = DEFAULT_EVENT_DELIMITER) -> \"EventHook\":\n        <IND>return self._on(subevent, extra_subevents, None, delimiter)\n    <DED>def _context_on(self, context: str, subevent: str,\n            extra_subevents: typing.List[str],\n            delimiter: str = DEFAULT_EVENT_DELIMITER) -> \"EventHook\":\n        <IND>return self._on(subevent, extra_subevents, context, delimiter)\n    <DED>def _on(self, subevent: str, extra_subevents: typing.List[str],\n            context: str, delimiter: str) -> \"EventHook\":\n        <IND>if delimiter in subevent:\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "            if not context == None:\n                <IND>context_hook = event_hook.new_context(typing.cast(str, context))\n                multiple_event_hook._add(typing.cast(EventHook, context_hook))\n            <DED>else:\n                <IND>multiple_event_hook._add(event_hook)\n        <DED><DED>return multiple_event_hook\n\n    <DED>def on(self, subevent: str, *extra_subevents: str,\n            delimiter: str = DEFAULT_EVENT_DELIMITER) -> \"EventHook\":\n        <IND>return self._on(subevent, extra_subevents, None, delimiter)\n    <DED>def _context_on(self, context: str, subevent: str,\n            extra_subevents: typing.Tuple[str, ...],\n            delimiter: str = DEFAULT_EVENT_DELIMITER) -> \"EventHook\":\n        <IND>return self._on(subevent, extra_subevents, context, delimiter)\n    <DED>def _on(self, subevent: str, extra_subevents: typing.Tuple[str, ...],\n            context: typing.Optional[str], delimiter: str) -> \"EventHook\":\n        <IND>if delimiter in subevent:\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "            if not context == None:\n                return event_obj.new_context(context)\n            return event_obj\n",
        "source_code_len": 119,
        "target_code": "            if not context == None:\n                context_hook = event_obj.new_context(typing.cast(str, context))\n                return typing.cast(EventHook, context_hook)\n            return event_obj\n",
        "target_code_len": 205,
        "diff_format": "@@ -133,3 +142,4 @@\n             if not context == None:\n-                return event_obj.new_context(context)\n+                context_hook = event_obj.new_context(typing.cast(str, context))\n+                return typing.cast(EventHook, context_hook)\n             return event_obj\n",
        "source_code_with_indent": "            <DED>if not context == None:\n                <IND>return event_obj.new_context(context)\n            <DED>return event_obj\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "            <DED>if not context == None:\n                <IND>context_hook = event_obj.new_context(typing.cast(str, context))\n                return typing.cast(EventHook, context_hook)\n            <DED>return event_obj\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": true,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "        if not context == None:\n            child = child.new_context(context)\n        return child\n",
        "source_code_len": 100,
        "target_code": "        if not context == None:\n            context_child = child.new_context(typing.cast(str, context))\n            child = typing.cast(EventHook, context_child)\n        return child\n",
        "target_code_len": 184,
        "diff_format": "@@ -142,3 +153,4 @@\n         if not context == None:\n-            child = child.new_context(context)\n+            context_child = child.new_context(typing.cast(str, context))\n+            child = typing.cast(EventHook, context_child)\n         return child\n",
        "source_code_with_indent": "        if not context == None:\n            <IND>child = child.new_context(context)\n        <DED>return child\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "        if not context == None:\n            <IND>context_child = child.new_context(typing.cast(str, context))\n            child = typing.cast(EventHook, context_child)\n        <DED>return child\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "jesopo/bitbot",
    "commit": "b543e31cd2a665b25aab4554e46a0ed5067d1bfe",
    "filename": "src/EventManager.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/jesopo-bitbot/src/EventManager.py",
    "file_hunks_size": 15,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "src/EventManager.py:154:40 Incompatible parameter type [6]: Expected `int` for 3rd positional only parameter to call `EventHook._call` but got `None`.",
    "message": " Expected `int` for 3rd positional only parameter to call `EventHook._call` but got `None`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 154,
    "warning_line": "        return self._call(kwargs, True, None)",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n    def _call(self, kwargs: dict, safe: bool, maximum: int\n            ) -> typing.List[typing.Any]:\n",
        "source_code_len": 102,
        "target_code": "\n    def _call(self, kwargs: dict, safe: bool, maximum: typing.Optional[int]\n            ) -> typing.List[typing.Any]:\n",
        "target_code_len": 119,
        "diff_format": "@@ -165,3 +177,3 @@\n \n-    def _call(self, kwargs: dict, safe: bool, maximum: int\n+    def _call(self, kwargs: dict, safe: bool, maximum: typing.Optional[int]\n             ) -> typing.List[typing.Any]:\n",
        "source_code_with_indent": "\n    <DED>def _call(self, kwargs: dict, safe: bool, maximum: int\n            ) -> typing.List[typing.Any]:\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n    <DED>def _call(self, kwargs: dict, safe: bool, maximum: typing.Optional[int]\n            ) -> typing.List[typing.Any]:\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "jesopo/bitbot",
    "commit": "b543e31cd2a665b25aab4554e46a0ed5067d1bfe",
    "filename": "src/EventManager.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/jesopo-bitbot/src/EventManager.py",
    "file_hunks_size": 15,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": true,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "src/EventManager.py:156:40 Incompatible parameter type [6]: Expected `int` for 3rd positional only parameter to call `EventHook._call` but got `None`.",
    "message": " Expected `int` for 3rd positional only parameter to call `EventHook._call` but got `None`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 156,
    "warning_line": "        return self._call(kwargs, True, None)",
    "min_patch": [
      {
        "hunk_fit_TFix": true,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    def call_limited(self, maximum: int, **kwargs) -> typing.List[typing.Any]:\n        return self._call(kwargs, True, None)\n\n",
        "source_code_len": 126,
        "target_code": "    def call_limited(self, maximum: int, **kwargs) -> typing.List[typing.Any]:\n        return self._call(kwargs, True, maximum)\n\n",
        "target_code_len": 129,
        "diff_format": "@@ -155,3 +167,3 @@\n     def call_limited(self, maximum: int, **kwargs) -> typing.List[typing.Any]:\n-        return self._call(kwargs, True, None)\n+        return self._call(kwargs, True, maximum)\n \n",
        "source_code_with_indent": "    <DED>def call_limited(self, maximum: int, **kwargs) -> typing.List[typing.Any]:\n        <IND>return self._call(kwargs, True, None)\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    <DED>def call_limited(self, maximum: int, **kwargs) -> typing.List[typing.Any]:\n        <IND>return self._call(kwargs, True, maximum)\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "jesopo/bitbot",
    "commit": "b543e31cd2a665b25aab4554e46a0ed5067d1bfe",
    "filename": "src/EventManager.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/jesopo-bitbot/src/EventManager.py",
    "file_hunks_size": 15,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "src/EventManager.py:161:41 Incompatible parameter type [6]: Expected `int` for 3rd positional only parameter to call `EventHook._call` but got `None`.",
    "message": " Expected `int` for 3rd positional only parameter to call `EventHook._call` but got `None`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 161,
    "warning_line": "        return self._call(kwargs, False, None)",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n    def _call(self, kwargs: dict, safe: bool, maximum: int\n            ) -> typing.List[typing.Any]:\n",
        "source_code_len": 102,
        "target_code": "\n    def _call(self, kwargs: dict, safe: bool, maximum: typing.Optional[int]\n            ) -> typing.List[typing.Any]:\n",
        "target_code_len": 119,
        "diff_format": "@@ -165,3 +177,3 @@\n \n-    def _call(self, kwargs: dict, safe: bool, maximum: int\n+    def _call(self, kwargs: dict, safe: bool, maximum: typing.Optional[int]\n             ) -> typing.List[typing.Any]:\n",
        "source_code_with_indent": "\n    <DED>def _call(self, kwargs: dict, safe: bool, maximum: int\n            ) -> typing.List[typing.Any]:\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n    <DED>def _call(self, kwargs: dict, safe: bool, maximum: typing.Optional[int]\n            ) -> typing.List[typing.Any]:\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "jesopo/bitbot",
    "commit": "b543e31cd2a665b25aab4554e46a0ed5067d1bfe",
    "filename": "src/EventManager.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/jesopo-bitbot/src/EventManager.py",
    "file_hunks_size": 15,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "src/EventManager.py:220:35 Incompatible parameter type [6]: Expected `str` for 1st positional only parameter to call `EventHook.get_child` but got `EventHook`.",
    "message": " Expected `str` for 1st positional only parameter to call `EventHook.get_child` but got `EventHook`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 220,
    "warning_line": "            child = self.get_child(child_name)",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "            key=lambda e: e.priority)\n    def get_children(self) -> typing.List[\"EventHook\"]:\n        return list(self._children.keys())\n    def is_empty(self) -> bool:\n        return len(self.get_hooks() + self.get_children()) == 0\n\n",
        "source_code_len": 234,
        "target_code": "            key=lambda e: e.priority)\n    def get_children(self) -> typing.List[str]:\n        return list(self._children.keys())\n    def is_empty(self) -> bool:\n        return (len(self.get_hooks())+len(self.get_children())) == 0\n\n",
        "target_code_len": 231,
        "diff_format": "@@ -225,6 +237,6 @@\n             key=lambda e: e.priority)\n-    def get_children(self) -> typing.List[\"EventHook\"]:\n+    def get_children(self) -> typing.List[str]:\n         return list(self._children.keys())\n     def is_empty(self) -> bool:\n-        return len(self.get_hooks() + self.get_children()) == 0\n+        return (len(self.get_hooks())+len(self.get_children())) == 0\n \n",
        "source_code_with_indent": "            key=lambda e: e.priority)\n    <DED>def get_children(self) -> typing.List[\"EventHook\"]:\n        <IND>return list(self._children.keys())\n    <DED>def is_empty(self) -> bool:\n        <IND>return len(self.get_hooks() + self.get_children()) == 0\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "            key=lambda e: e.priority)\n    <DED>def get_children(self) -> typing.List[str]:\n        <IND>return list(self._children.keys())\n    <DED>def is_empty(self) -> bool:\n        <IND>return (len(self.get_hooks())+len(self.get_children())) == 0\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "jesopo/bitbot",
    "commit": "b543e31cd2a665b25aab4554e46a0ed5067d1bfe",
    "filename": "src/EventManager.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/jesopo-bitbot/src/EventManager.py",
    "file_hunks_size": 15,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": true,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "src/EventManager.py:229:38 Unsupported operand [58]: `+` is not supported for operand types `typing.List[EventCallback]` and `typing.List[EventHook]`.",
    "message": " `+` is not supported for operand types `typing.List[EventCallback]` and `typing.List[EventHook]`.",
    "rule_id": "Unsupported operand [58]",
    "warning_line_no": 229,
    "warning_line": "        return len(self.get_hooks() + self.get_children()) == 0",
    "min_patch": [
      {
        "hunk_fit_TFix": true,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "            key=lambda e: e.priority)\n    def get_children(self) -> typing.List[\"EventHook\"]:\n        return list(self._children.keys())\n    def is_empty(self) -> bool:\n        return len(self.get_hooks() + self.get_children()) == 0\n\n",
        "source_code_len": 234,
        "target_code": "            key=lambda e: e.priority)\n    def get_children(self) -> typing.List[str]:\n        return list(self._children.keys())\n    def is_empty(self) -> bool:\n        return (len(self.get_hooks())+len(self.get_children())) == 0\n\n",
        "target_code_len": 231,
        "diff_format": "@@ -225,6 +237,6 @@\n             key=lambda e: e.priority)\n-    def get_children(self) -> typing.List[\"EventHook\"]:\n+    def get_children(self) -> typing.List[str]:\n         return list(self._children.keys())\n     def is_empty(self) -> bool:\n-        return len(self.get_hooks() + self.get_children()) == 0\n+        return (len(self.get_hooks())+len(self.get_children())) == 0\n \n",
        "source_code_with_indent": "            key=lambda e: e.priority)\n    <DED>def get_children(self) -> typing.List[\"EventHook\"]:\n        <IND>return list(self._children.keys())\n    <DED>def is_empty(self) -> bool:\n        <IND>return len(self.get_hooks() + self.get_children()) == 0\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "            key=lambda e: e.priority)\n    <DED>def get_children(self) -> typing.List[str]:\n        <IND>return list(self._children.keys())\n    <DED>def is_empty(self) -> bool:\n        <IND>return (len(self.get_hooks())+len(self.get_children())) == 0\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "jesopo/bitbot",
    "commit": "b543e31cd2a665b25aab4554e46a0ed5067d1bfe",
    "filename": "src/Exports.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/jesopo-bitbot/src/Exports.py",
    "file_hunks_size": 1,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "src/Exports.py:12:18 Incompatible parameter type [6]: Expected `str` for 1st positional only parameter to call `Exports._add` but got `None`.",
    "message": " Expected `str` for 1st positional only parameter to call `Exports._add` but got `None`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 12,
    "warning_line": "        self._add(None, setting, value)",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "        self._add(context, setting, value)\n    def _add(self, context: str, setting: str, value: typing.Any):\n        if context == None:\n",
        "source_code_len": 138,
        "target_code": "        self._add(context, setting, value)\n    def _add(self, context: typing.Optional[str], setting: str,\n            value: typing.Any):\n        if context == None:\n",
        "target_code_len": 167,
        "diff_format": "@@ -14,3 +14,4 @@\n         self._add(context, setting, value)\n-    def _add(self, context: str, setting: str, value: typing.Any):\n+    def _add(self, context: typing.Optional[str], setting: str,\n+            value: typing.Any):\n         if context == None:\n",
        "source_code_with_indent": "        <IND>self._add(context, setting, value)\n    <DED>def _add(self, context: str, setting: str, value: typing.Any):\n        <IND>if context == None:\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "        <IND>self._add(context, setting, value)\n    <DED>def _add(self, context: typing.Optional[str], setting: str,\n            value: typing.Any):\n        <IND>if context == None:\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "jesopo/bitbot",
    "commit": "b543e31cd2a665b25aab4554e46a0ed5067d1bfe",
    "filename": "src/IRCBot.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/jesopo-bitbot/src/IRCBot.py",
    "file_hunks_size": 2,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "src/IRCBot.py:130:24 Incompatible parameter type [6]: Expected `IRCServer.Server` for 1st positional only parameter to call `Bot.connect` but got `typing.Optional[IRCServer.Server]`.",
    "message": " Expected `IRCServer.Server` for 1st positional only parameter to call `Bot.connect` but got `typing.Optional[IRCServer.Server]`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 130,
    "warning_line": "        if self.connect(server):",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    def add_server(self, server_id: int, connect: bool = True\n            ) -> typing.Optional[IRCServer.Server]:\n        (_, alias, hostname, port, password, ipv4, tls, bindhost, nickname,\n",
        "source_code_len": 190,
        "target_code": "    def add_server(self, server_id: int, connect: bool = True\n            ) -> IRCServer.Server:\n        (_, alias, hostname, port, password, ipv4, tls, bindhost, nickname,\n",
        "target_code_len": 173,
        "diff_format": "@@ -38,3 +38,3 @@\n     def add_server(self, server_id: int, connect: bool = True\n-            ) -> typing.Optional[IRCServer.Server]:\n+            ) -> IRCServer.Server:\n         (_, alias, hostname, port, password, ipv4, tls, bindhost, nickname,\n",
        "source_code_with_indent": "    <DED>def add_server(self, server_id: int, connect: bool = True\n            ) -> typing.Optional[IRCServer.Server]:\n        <IND>(_, alias, hostname, port, password, ipv4, tls, bindhost, nickname,\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    <DED>def add_server(self, server_id: int, connect: bool = True\n            ) -> IRCServer.Server:\n        <IND>(_, alias, hostname, port, password, ipv4, tls, bindhost, nickname,\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "        if not new_server.get_setting(\"connect\", True):\n            return\n        self._events.on(\"new.server\").call(server=new_server)\n",
        "source_code_len": 137,
        "target_code": "        if not new_server.get_setting(\"connect\", True):\n            return new_server\n        self._events.on(\"new.server\").call(server=new_server)\n",
        "target_code_len": 148,
        "diff_format": "@@ -46,3 +46,3 @@\n         if not new_server.get_setting(\"connect\", True):\n-            return\n+            return new_server\n         self._events.on(\"new.server\").call(server=new_server)\n",
        "source_code_with_indent": "        if not new_server.get_setting(\"connect\", True):\n            <IND>return\n        <DED>self._events.on(\"new.server\").call(server=new_server)\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "        if not new_server.get_setting(\"connect\", True):\n            <IND>return new_server\n        <DED>self._events.on(\"new.server\").call(server=new_server)\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "jesopo/bitbot",
    "commit": "b543e31cd2a665b25aab4554e46a0ed5067d1bfe",
    "filename": "src/IRCServer.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/jesopo-bitbot/src/IRCServer.py",
    "file_hunks_size": 1,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "src/IRCServer.py:163:32 Incompatible parameter type [6]: Expected `str` for 1st positional only parameter to call `utils.irc.equals` but got `Server`.",
    "message": " Expected `str` for 1st positional only parameter to call `utils.irc.equals` but got `Server`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 163,
    "warning_line": "        return utils.irc.equals(self, nickname, self.nickname)"
  },
  {
    "project": "jesopo/bitbot",
    "commit": "b543e31cd2a665b25aab4554e46a0ed5067d1bfe",
    "filename": "src/Socket.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/jesopo-bitbot/src/Socket.py",
    "file_hunks_size": 1,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": true,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "src/Socket.py:36:36 Unbound name [10]: Name `delimiter` is used but not defined in the current scope.",
    "message": " Name `delimiter` is used but not defined in the current scope.",
    "rule_id": "Unbound name [10]",
    "warning_line_no": 36,
    "warning_line": "            data_split = data.split(delimiter)",
    "min_patch": [
      {
        "hunk_fit_TFix": true,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "        if not self.delimiter == None:\n            data_split = data.split(delimiter)\n            if data_split[-1]:\n",
        "source_code_len": 117,
        "target_code": "        if not self.delimiter == None:\n            data_split = data.split(self.delimiter)\n            if data_split[-1]:\n",
        "target_code_len": 122,
        "diff_format": "@@ -35,3 +35,3 @@\n         if not self.delimiter == None:\n-            data_split = data.split(delimiter)\n+            data_split = data.split(self.delimiter)\n             if data_split[-1]:\n",
        "source_code_with_indent": "        if not self.delimiter == None:\n            <IND>data_split = data.split(delimiter)\n            if data_split[-1]:\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "        if not self.delimiter == None:\n            <IND>data_split = data.split(self.delimiter)\n            if data_split[-1]:\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "jesopo/bitbot",
    "commit": "b543e31cd2a665b25aab4554e46a0ed5067d1bfe",
    "filename": "src/Timers.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/jesopo-bitbot/src/Timers.py",
    "file_hunks_size": 4,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "src/Timers.py:49:37 Incompatible parameter type [6]: Expected `str` for 2nd positional only parameter to call `Timers._add` but got `None`.",
    "message": " Expected `str` for 2nd positional only parameter to call `Timers._add` but got `None`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 49,
    "warning_line": "            self._add(timer[\"name\"], None, timer[\"delay\"], timer[",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "class Timer(object):\n    def __init__(self, id: int, context: str, name: str, delay: float,\n            next_due: float, kwargs: dict):\n        self.id = id\n",
        "source_code_len": 157,
        "target_code": "class Timer(object):\n    def __init__(self, id: str, context: typing.Optional[str], name: str,\n            delay: float, next_due: typing.Optional[float], kwargs: dict):\n        self.id = id\n",
        "target_code_len": 191,
        "diff_format": "@@ -4,4 +4,4 @@\n class Timer(object):\n-    def __init__(self, id: int, context: str, name: str, delay: float,\n-            next_due: float, kwargs: dict):\n+    def __init__(self, id: str, context: typing.Optional[str], name: str,\n+            delay: float, next_due: typing.Optional[float], kwargs: dict):\n         self.id = id\n",
        "source_code_with_indent": "class Timer(object):\n    <IND>def __init__(self, id: int, context: str, name: str, delay: float,\n            next_due: float, kwargs: dict):\n        <IND>self.id = id\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "class Timer(object):\n    <IND>def __init__(self, id: str, context: typing.Optional[str], name: str,\n            delay: float, next_due: typing.Optional[float], kwargs: dict):\n        <IND>self.id = id\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": true,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "            id = name.split(\"timer-\", 1)[1]\n            self._add(timer[\"name\"], None, timer[\"delay\"], timer[\n                \"next-due\"], id, False, timer[\"kwargs\"])\n",
        "source_code_len": 167,
        "target_code": "            id = name.split(\"timer-\", 1)[1]\n            self._add(None, timer[\"name\"], timer[\"delay\"], timer[\n                \"next-due\"], id, False, timer[\"kwargs\"])\n",
        "target_code_len": 167,
        "diff_format": "@@ -48,3 +48,3 @@\n             id = name.split(\"timer-\", 1)[1]\n-            self._add(timer[\"name\"], None, timer[\"delay\"], timer[\n+            self._add(None, timer[\"name\"], timer[\"delay\"], timer[\n                 \"next-due\"], id, False, timer[\"kwargs\"])\n",
        "source_code_with_indent": "            <IND>id = name.split(\"timer-\", 1)[1]\n            self._add(timer[\"name\"], None, timer[\"delay\"], timer[\n                \"next-due\"], id, False, timer[\"kwargs\"])\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "            <IND>id = name.split(\"timer-\", 1)[1]\n            self._add(None, timer[\"name\"], timer[\"delay\"], timer[\n                \"next-due\"], id, False, timer[\"kwargs\"])\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "        self._add(None, name, delay, next_due, None, True, kwargs)\n    def _add(self, context: str, name: str, delay: float, next_due: float,\n            id: str, persist: bool, kwargs: dict):\n        id = id or uuid.uuid4().hex\n        timer = Timer(id, context, name, delay, next_due, kwargs)\n",
        "source_code_len": 295,
        "target_code": "        self._add(None, name, delay, next_due, None, True, kwargs)\n    def _add(self, context: typing.Optional[str], name: str, delay: float,\n            next_due: typing.Optional[float], id: typing.Optional[str],\n            persist: bool, kwargs: dict):\n        id = id or str(uuid.uuid4())\n        timer = Timer(id, context, name, delay, next_due, kwargs)\n",
        "target_code_len": 359,
        "diff_format": "@@ -69,5 +69,6 @@\n         self._add(None, name, delay, next_due, None, True, kwargs)\n-    def _add(self, context: str, name: str, delay: float, next_due: float,\n-            id: str, persist: bool, kwargs: dict):\n-        id = id or uuid.uuid4().hex\n+    def _add(self, context: typing.Optional[str], name: str, delay: float,\n+            next_due: typing.Optional[float], id: typing.Optional[str],\n+            persist: bool, kwargs: dict):\n+        id = id or str(uuid.uuid4())\n         timer = Timer(id, context, name, delay, next_due, kwargs)\n",
        "source_code_with_indent": "        <IND>self._add(None, name, delay, next_due, None, True, kwargs)\n    <DED>def _add(self, context: str, name: str, delay: float, next_due: float,\n            id: str, persist: bool, kwargs: dict):\n        <IND>id = id or uuid.uuid4().hex\n        timer = Timer(id, context, name, delay, next_due, kwargs)\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "        <IND>self._add(None, name, delay, next_due, None, True, kwargs)\n    <DED>def _add(self, context: typing.Optional[str], name: str, delay: float,\n            next_due: typing.Optional[float], id: typing.Optional[str],\n            persist: bool, kwargs: dict):\n        <IND>id = id or str(uuid.uuid4())\n        timer = Timer(id, context, name, delay, next_due, kwargs)\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "jesopo/bitbot",
    "commit": "b543e31cd2a665b25aab4554e46a0ed5067d1bfe",
    "filename": "src/Timers.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/jesopo-bitbot/src/Timers.py",
    "file_hunks_size": 4,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "src/Timers.py:66:18 Incompatible parameter type [6]: Expected `str` for 1st positional only parameter to call `Timers._add` but got `None`.",
    "message": " Expected `str` for 1st positional only parameter to call `Timers._add` but got `None`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 66,
    "warning_line": "        self._add(None, name, delay, next_due, None, False, kwargs)",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "class Timer(object):\n    def __init__(self, id: int, context: str, name: str, delay: float,\n            next_due: float, kwargs: dict):\n        self.id = id\n",
        "source_code_len": 157,
        "target_code": "class Timer(object):\n    def __init__(self, id: str, context: typing.Optional[str], name: str,\n            delay: float, next_due: typing.Optional[float], kwargs: dict):\n        self.id = id\n",
        "target_code_len": 191,
        "diff_format": "@@ -4,4 +4,4 @@\n class Timer(object):\n-    def __init__(self, id: int, context: str, name: str, delay: float,\n-            next_due: float, kwargs: dict):\n+    def __init__(self, id: str, context: typing.Optional[str], name: str,\n+            delay: float, next_due: typing.Optional[float], kwargs: dict):\n         self.id = id\n",
        "source_code_with_indent": "class Timer(object):\n    <IND>def __init__(self, id: int, context: str, name: str, delay: float,\n            next_due: float, kwargs: dict):\n        <IND>self.id = id\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "class Timer(object):\n    <IND>def __init__(self, id: str, context: typing.Optional[str], name: str,\n            delay: float, next_due: typing.Optional[float], kwargs: dict):\n        <IND>self.id = id\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "        self._add(None, name, delay, next_due, None, True, kwargs)\n    def _add(self, context: str, name: str, delay: float, next_due: float,\n            id: str, persist: bool, kwargs: dict):\n        id = id or uuid.uuid4().hex\n        timer = Timer(id, context, name, delay, next_due, kwargs)\n",
        "source_code_len": 295,
        "target_code": "        self._add(None, name, delay, next_due, None, True, kwargs)\n    def _add(self, context: typing.Optional[str], name: str, delay: float,\n            next_due: typing.Optional[float], id: typing.Optional[str],\n            persist: bool, kwargs: dict):\n        id = id or str(uuid.uuid4())\n        timer = Timer(id, context, name, delay, next_due, kwargs)\n",
        "target_code_len": 359,
        "diff_format": "@@ -69,5 +69,6 @@\n         self._add(None, name, delay, next_due, None, True, kwargs)\n-    def _add(self, context: str, name: str, delay: float, next_due: float,\n-            id: str, persist: bool, kwargs: dict):\n-        id = id or uuid.uuid4().hex\n+    def _add(self, context: typing.Optional[str], name: str, delay: float,\n+            next_due: typing.Optional[float], id: typing.Optional[str],\n+            persist: bool, kwargs: dict):\n+        id = id or str(uuid.uuid4())\n         timer = Timer(id, context, name, delay, next_due, kwargs)\n",
        "source_code_with_indent": "        <IND>self._add(None, name, delay, next_due, None, True, kwargs)\n    <DED>def _add(self, context: str, name: str, delay: float, next_due: float,\n            id: str, persist: bool, kwargs: dict):\n        <IND>id = id or uuid.uuid4().hex\n        timer = Timer(id, context, name, delay, next_due, kwargs)\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "        <IND>self._add(None, name, delay, next_due, None, True, kwargs)\n    <DED>def _add(self, context: typing.Optional[str], name: str, delay: float,\n            next_due: typing.Optional[float], id: typing.Optional[str],\n            persist: bool, kwargs: dict):\n        <IND>id = id or str(uuid.uuid4())\n        timer = Timer(id, context, name, delay, next_due, kwargs)\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "jesopo/bitbot",
    "commit": "b543e31cd2a665b25aab4554e46a0ed5067d1bfe",
    "filename": "src/Timers.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/jesopo-bitbot/src/Timers.py",
    "file_hunks_size": 4,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "src/Timers.py:66:47 Incompatible parameter type [6]: Expected `str` for 5th positional only parameter to call `Timers._add` but got `None`.",
    "message": " Expected `str` for 5th positional only parameter to call `Timers._add` but got `None`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 66,
    "warning_line": "        self._add(None, name, delay, next_due, None, False, kwargs)",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "class Timer(object):\n    def __init__(self, id: int, context: str, name: str, delay: float,\n            next_due: float, kwargs: dict):\n        self.id = id\n",
        "source_code_len": 157,
        "target_code": "class Timer(object):\n    def __init__(self, id: str, context: typing.Optional[str], name: str,\n            delay: float, next_due: typing.Optional[float], kwargs: dict):\n        self.id = id\n",
        "target_code_len": 191,
        "diff_format": "@@ -4,4 +4,4 @@\n class Timer(object):\n-    def __init__(self, id: int, context: str, name: str, delay: float,\n-            next_due: float, kwargs: dict):\n+    def __init__(self, id: str, context: typing.Optional[str], name: str,\n+            delay: float, next_due: typing.Optional[float], kwargs: dict):\n         self.id = id\n",
        "source_code_with_indent": "class Timer(object):\n    <IND>def __init__(self, id: int, context: str, name: str, delay: float,\n            next_due: float, kwargs: dict):\n        <IND>self.id = id\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "class Timer(object):\n    <IND>def __init__(self, id: str, context: typing.Optional[str], name: str,\n            delay: float, next_due: typing.Optional[float], kwargs: dict):\n        <IND>self.id = id\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "        self._add(None, name, delay, next_due, None, True, kwargs)\n    def _add(self, context: str, name: str, delay: float, next_due: float,\n            id: str, persist: bool, kwargs: dict):\n        id = id or uuid.uuid4().hex\n        timer = Timer(id, context, name, delay, next_due, kwargs)\n",
        "source_code_len": 295,
        "target_code": "        self._add(None, name, delay, next_due, None, True, kwargs)\n    def _add(self, context: typing.Optional[str], name: str, delay: float,\n            next_due: typing.Optional[float], id: typing.Optional[str],\n            persist: bool, kwargs: dict):\n        id = id or str(uuid.uuid4())\n        timer = Timer(id, context, name, delay, next_due, kwargs)\n",
        "target_code_len": 359,
        "diff_format": "@@ -69,5 +69,6 @@\n         self._add(None, name, delay, next_due, None, True, kwargs)\n-    def _add(self, context: str, name: str, delay: float, next_due: float,\n-            id: str, persist: bool, kwargs: dict):\n-        id = id or uuid.uuid4().hex\n+    def _add(self, context: typing.Optional[str], name: str, delay: float,\n+            next_due: typing.Optional[float], id: typing.Optional[str],\n+            persist: bool, kwargs: dict):\n+        id = id or str(uuid.uuid4())\n         timer = Timer(id, context, name, delay, next_due, kwargs)\n",
        "source_code_with_indent": "        <IND>self._add(None, name, delay, next_due, None, True, kwargs)\n    <DED>def _add(self, context: str, name: str, delay: float, next_due: float,\n            id: str, persist: bool, kwargs: dict):\n        <IND>id = id or uuid.uuid4().hex\n        timer = Timer(id, context, name, delay, next_due, kwargs)\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "        <IND>self._add(None, name, delay, next_due, None, True, kwargs)\n    <DED>def _add(self, context: typing.Optional[str], name: str, delay: float,\n            next_due: typing.Optional[float], id: typing.Optional[str],\n            persist: bool, kwargs: dict):\n        <IND>id = id or str(uuid.uuid4())\n        timer = Timer(id, context, name, delay, next_due, kwargs)\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "jesopo/bitbot",
    "commit": "b543e31cd2a665b25aab4554e46a0ed5067d1bfe",
    "filename": "src/Timers.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/jesopo-bitbot/src/Timers.py",
    "file_hunks_size": 4,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "src/Timers.py:69:18 Incompatible parameter type [6]: Expected `str` for 1st positional only parameter to call `Timers._add` but got `None`.",
    "message": " Expected `str` for 1st positional only parameter to call `Timers._add` but got `None`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 69,
    "warning_line": "        self._add(None, name, delay, next_due, None, True, kwargs)",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "class Timer(object):\n    def __init__(self, id: int, context: str, name: str, delay: float,\n            next_due: float, kwargs: dict):\n        self.id = id\n",
        "source_code_len": 157,
        "target_code": "class Timer(object):\n    def __init__(self, id: str, context: typing.Optional[str], name: str,\n            delay: float, next_due: typing.Optional[float], kwargs: dict):\n        self.id = id\n",
        "target_code_len": 191,
        "diff_format": "@@ -4,4 +4,4 @@\n class Timer(object):\n-    def __init__(self, id: int, context: str, name: str, delay: float,\n-            next_due: float, kwargs: dict):\n+    def __init__(self, id: str, context: typing.Optional[str], name: str,\n+            delay: float, next_due: typing.Optional[float], kwargs: dict):\n         self.id = id\n",
        "source_code_with_indent": "class Timer(object):\n    <IND>def __init__(self, id: int, context: str, name: str, delay: float,\n            next_due: float, kwargs: dict):\n        <IND>self.id = id\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "class Timer(object):\n    <IND>def __init__(self, id: str, context: typing.Optional[str], name: str,\n            delay: float, next_due: typing.Optional[float], kwargs: dict):\n        <IND>self.id = id\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "        self._add(None, name, delay, next_due, None, True, kwargs)\n    def _add(self, context: str, name: str, delay: float, next_due: float,\n            id: str, persist: bool, kwargs: dict):\n        id = id or uuid.uuid4().hex\n        timer = Timer(id, context, name, delay, next_due, kwargs)\n",
        "source_code_len": 295,
        "target_code": "        self._add(None, name, delay, next_due, None, True, kwargs)\n    def _add(self, context: typing.Optional[str], name: str, delay: float,\n            next_due: typing.Optional[float], id: typing.Optional[str],\n            persist: bool, kwargs: dict):\n        id = id or str(uuid.uuid4())\n        timer = Timer(id, context, name, delay, next_due, kwargs)\n",
        "target_code_len": 359,
        "diff_format": "@@ -69,5 +69,6 @@\n         self._add(None, name, delay, next_due, None, True, kwargs)\n-    def _add(self, context: str, name: str, delay: float, next_due: float,\n-            id: str, persist: bool, kwargs: dict):\n-        id = id or uuid.uuid4().hex\n+    def _add(self, context: typing.Optional[str], name: str, delay: float,\n+            next_due: typing.Optional[float], id: typing.Optional[str],\n+            persist: bool, kwargs: dict):\n+        id = id or str(uuid.uuid4())\n         timer = Timer(id, context, name, delay, next_due, kwargs)\n",
        "source_code_with_indent": "        <IND>self._add(None, name, delay, next_due, None, True, kwargs)\n    <DED>def _add(self, context: str, name: str, delay: float, next_due: float,\n            id: str, persist: bool, kwargs: dict):\n        <IND>id = id or uuid.uuid4().hex\n        timer = Timer(id, context, name, delay, next_due, kwargs)\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "        <IND>self._add(None, name, delay, next_due, None, True, kwargs)\n    <DED>def _add(self, context: typing.Optional[str], name: str, delay: float,\n            next_due: typing.Optional[float], id: typing.Optional[str],\n            persist: bool, kwargs: dict):\n        <IND>id = id or str(uuid.uuid4())\n        timer = Timer(id, context, name, delay, next_due, kwargs)\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "jesopo/bitbot",
    "commit": "b543e31cd2a665b25aab4554e46a0ed5067d1bfe",
    "filename": "src/Timers.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/jesopo-bitbot/src/Timers.py",
    "file_hunks_size": 4,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "src/Timers.py:69:47 Incompatible parameter type [6]: Expected `str` for 5th positional only parameter to call `Timers._add` but got `None`.",
    "message": " Expected `str` for 5th positional only parameter to call `Timers._add` but got `None`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 69,
    "warning_line": "        self._add(None, name, delay, next_due, None, True, kwargs)",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "class Timer(object):\n    def __init__(self, id: int, context: str, name: str, delay: float,\n            next_due: float, kwargs: dict):\n        self.id = id\n",
        "source_code_len": 157,
        "target_code": "class Timer(object):\n    def __init__(self, id: str, context: typing.Optional[str], name: str,\n            delay: float, next_due: typing.Optional[float], kwargs: dict):\n        self.id = id\n",
        "target_code_len": 191,
        "diff_format": "@@ -4,4 +4,4 @@\n class Timer(object):\n-    def __init__(self, id: int, context: str, name: str, delay: float,\n-            next_due: float, kwargs: dict):\n+    def __init__(self, id: str, context: typing.Optional[str], name: str,\n+            delay: float, next_due: typing.Optional[float], kwargs: dict):\n         self.id = id\n",
        "source_code_with_indent": "class Timer(object):\n    <IND>def __init__(self, id: int, context: str, name: str, delay: float,\n            next_due: float, kwargs: dict):\n        <IND>self.id = id\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "class Timer(object):\n    <IND>def __init__(self, id: str, context: typing.Optional[str], name: str,\n            delay: float, next_due: typing.Optional[float], kwargs: dict):\n        <IND>self.id = id\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "        self._add(None, name, delay, next_due, None, True, kwargs)\n    def _add(self, context: str, name: str, delay: float, next_due: float,\n            id: str, persist: bool, kwargs: dict):\n        id = id or uuid.uuid4().hex\n        timer = Timer(id, context, name, delay, next_due, kwargs)\n",
        "source_code_len": 295,
        "target_code": "        self._add(None, name, delay, next_due, None, True, kwargs)\n    def _add(self, context: typing.Optional[str], name: str, delay: float,\n            next_due: typing.Optional[float], id: typing.Optional[str],\n            persist: bool, kwargs: dict):\n        id = id or str(uuid.uuid4())\n        timer = Timer(id, context, name, delay, next_due, kwargs)\n",
        "target_code_len": 359,
        "diff_format": "@@ -69,5 +69,6 @@\n         self._add(None, name, delay, next_due, None, True, kwargs)\n-    def _add(self, context: str, name: str, delay: float, next_due: float,\n-            id: str, persist: bool, kwargs: dict):\n-        id = id or uuid.uuid4().hex\n+    def _add(self, context: typing.Optional[str], name: str, delay: float,\n+            next_due: typing.Optional[float], id: typing.Optional[str],\n+            persist: bool, kwargs: dict):\n+        id = id or str(uuid.uuid4())\n         timer = Timer(id, context, name, delay, next_due, kwargs)\n",
        "source_code_with_indent": "        <IND>self._add(None, name, delay, next_due, None, True, kwargs)\n    <DED>def _add(self, context: str, name: str, delay: float, next_due: float,\n            id: str, persist: bool, kwargs: dict):\n        <IND>id = id or uuid.uuid4().hex\n        timer = Timer(id, context, name, delay, next_due, kwargs)\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "        <IND>self._add(None, name, delay, next_due, None, True, kwargs)\n    <DED>def _add(self, context: typing.Optional[str], name: str, delay: float,\n            next_due: typing.Optional[float], id: typing.Optional[str],\n            persist: bool, kwargs: dict):\n        <IND>id = id or str(uuid.uuid4())\n        timer = Timer(id, context, name, delay, next_due, kwargs)\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "jesopo/bitbot",
    "commit": "b543e31cd2a665b25aab4554e46a0ed5067d1bfe",
    "filename": "src/Timers.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/jesopo-bitbot/src/Timers.py",
    "file_hunks_size": 4,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "src/Timers.py:73:22 Incompatible parameter type [6]: Expected `int` for 1st positional only parameter to call `Timer.__init__` but got `str`.",
    "message": " Expected `int` for 1st positional only parameter to call `Timer.__init__` but got `str`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 73,
    "warning_line": "        timer = Timer(id, context, name, delay, next_due, kwargs)",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "class Timer(object):\n    def __init__(self, id: int, context: str, name: str, delay: float,\n            next_due: float, kwargs: dict):\n        self.id = id\n",
        "source_code_len": 157,
        "target_code": "class Timer(object):\n    def __init__(self, id: str, context: typing.Optional[str], name: str,\n            delay: float, next_due: typing.Optional[float], kwargs: dict):\n        self.id = id\n",
        "target_code_len": 191,
        "diff_format": "@@ -4,4 +4,4 @@\n class Timer(object):\n-    def __init__(self, id: int, context: str, name: str, delay: float,\n-            next_due: float, kwargs: dict):\n+    def __init__(self, id: str, context: typing.Optional[str], name: str,\n+            delay: float, next_due: typing.Optional[float], kwargs: dict):\n         self.id = id\n",
        "source_code_with_indent": "class Timer(object):\n    <IND>def __init__(self, id: int, context: str, name: str, delay: float,\n            next_due: float, kwargs: dict):\n        <IND>self.id = id\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "class Timer(object):\n    <IND>def __init__(self, id: str, context: typing.Optional[str], name: str,\n            delay: float, next_due: typing.Optional[float], kwargs: dict):\n        <IND>self.id = id\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "jesopo/bitbot",
    "commit": "b543e31cd2a665b25aab4554e46a0ed5067d1bfe",
    "filename": "src/Timers.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/jesopo-bitbot/src/Timers.py",
    "file_hunks_size": 4,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "src/Timers.py:87:12 Incompatible return type [7]: Expected `float` but got `None`.",
    "message": " Expected `float` but got `None`.",
    "rule_id": "Incompatible return type [7]",
    "warning_line_no": 87,
    "warning_line": "            return None",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n    def next(self) -> float:\n        times = filter(None, [timer.time_left() for timer in self.get_timers()])\n",
        "source_code_len": 111,
        "target_code": "\n    def next(self) -> typing.Optional[float]:\n        times = filter(None, [timer.time_left() for timer in self.get_timers()])\n",
        "target_code_len": 128,
        "diff_format": "@@ -83,3 +84,3 @@\n \n-    def next(self) -> float:\n+    def next(self) -> typing.Optional[float]:\n         times = filter(None, [timer.time_left() for timer in self.get_timers()])\n",
        "source_code_with_indent": "\n    <DED><DED>def next(self) -> float:\n        <IND>times = filter(None, [timer.time_left() for timer in self.get_timers()])\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n    <DED><DED>def next(self) -> typing.Optional[float]:\n        <IND>times = filter(None, [timer.time_left() for timer in self.get_timers()])\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "jesopo/bitbot",
    "commit": "b543e31cd2a665b25aab4554e46a0ed5067d1bfe",
    "filename": "src/Timers.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/jesopo-bitbot/src/Timers.py",
    "file_hunks_size": 4,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "src/Timers.py:112:63 Incompatible parameter type [6]: Expected `str` for 5th positional only parameter to call `Timers._add` but got `None`.",
    "message": " Expected `str` for 5th positional only parameter to call `Timers._add` but got `None`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 112,
    "warning_line": "        self._parent._add(self.context, name, delay, next_due, None, False,",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "class Timer(object):\n    def __init__(self, id: int, context: str, name: str, delay: float,\n            next_due: float, kwargs: dict):\n        self.id = id\n",
        "source_code_len": 157,
        "target_code": "class Timer(object):\n    def __init__(self, id: str, context: typing.Optional[str], name: str,\n            delay: float, next_due: typing.Optional[float], kwargs: dict):\n        self.id = id\n",
        "target_code_len": 191,
        "diff_format": "@@ -4,4 +4,4 @@\n class Timer(object):\n-    def __init__(self, id: int, context: str, name: str, delay: float,\n-            next_due: float, kwargs: dict):\n+    def __init__(self, id: str, context: typing.Optional[str], name: str,\n+            delay: float, next_due: typing.Optional[float], kwargs: dict):\n         self.id = id\n",
        "source_code_with_indent": "class Timer(object):\n    <IND>def __init__(self, id: int, context: str, name: str, delay: float,\n            next_due: float, kwargs: dict):\n        <IND>self.id = id\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "class Timer(object):\n    <IND>def __init__(self, id: str, context: typing.Optional[str], name: str,\n            delay: float, next_due: typing.Optional[float], kwargs: dict):\n        <IND>self.id = id\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "        self._add(None, name, delay, next_due, None, True, kwargs)\n    def _add(self, context: str, name: str, delay: float, next_due: float,\n            id: str, persist: bool, kwargs: dict):\n        id = id or uuid.uuid4().hex\n        timer = Timer(id, context, name, delay, next_due, kwargs)\n",
        "source_code_len": 295,
        "target_code": "        self._add(None, name, delay, next_due, None, True, kwargs)\n    def _add(self, context: typing.Optional[str], name: str, delay: float,\n            next_due: typing.Optional[float], id: typing.Optional[str],\n            persist: bool, kwargs: dict):\n        id = id or str(uuid.uuid4())\n        timer = Timer(id, context, name, delay, next_due, kwargs)\n",
        "target_code_len": 359,
        "diff_format": "@@ -69,5 +69,6 @@\n         self._add(None, name, delay, next_due, None, True, kwargs)\n-    def _add(self, context: str, name: str, delay: float, next_due: float,\n-            id: str, persist: bool, kwargs: dict):\n-        id = id or uuid.uuid4().hex\n+    def _add(self, context: typing.Optional[str], name: str, delay: float,\n+            next_due: typing.Optional[float], id: typing.Optional[str],\n+            persist: bool, kwargs: dict):\n+        id = id or str(uuid.uuid4())\n         timer = Timer(id, context, name, delay, next_due, kwargs)\n",
        "source_code_with_indent": "        <IND>self._add(None, name, delay, next_due, None, True, kwargs)\n    <DED>def _add(self, context: str, name: str, delay: float, next_due: float,\n            id: str, persist: bool, kwargs: dict):\n        <IND>id = id or uuid.uuid4().hex\n        timer = Timer(id, context, name, delay, next_due, kwargs)\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "        <IND>self._add(None, name, delay, next_due, None, True, kwargs)\n    <DED>def _add(self, context: typing.Optional[str], name: str, delay: float,\n            next_due: typing.Optional[float], id: typing.Optional[str],\n            persist: bool, kwargs: dict):\n        <IND>id = id or str(uuid.uuid4())\n        timer = Timer(id, context, name, delay, next_due, kwargs)\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "jesopo/bitbot",
    "commit": "b543e31cd2a665b25aab4554e46a0ed5067d1bfe",
    "filename": "src/Timers.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/jesopo-bitbot/src/Timers.py",
    "file_hunks_size": 4,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "src/Timers.py:116:26 Incompatible parameter type [6]: Expected `str` for 1st positional only parameter to call `Timers._add` but got `None`.",
    "message": " Expected `str` for 1st positional only parameter to call `Timers._add` but got `None`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 116,
    "warning_line": "        self._parent._add(None, name, delay, next_due, None, True,",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "class Timer(object):\n    def __init__(self, id: int, context: str, name: str, delay: float,\n            next_due: float, kwargs: dict):\n        self.id = id\n",
        "source_code_len": 157,
        "target_code": "class Timer(object):\n    def __init__(self, id: str, context: typing.Optional[str], name: str,\n            delay: float, next_due: typing.Optional[float], kwargs: dict):\n        self.id = id\n",
        "target_code_len": 191,
        "diff_format": "@@ -4,4 +4,4 @@\n class Timer(object):\n-    def __init__(self, id: int, context: str, name: str, delay: float,\n-            next_due: float, kwargs: dict):\n+    def __init__(self, id: str, context: typing.Optional[str], name: str,\n+            delay: float, next_due: typing.Optional[float], kwargs: dict):\n         self.id = id\n",
        "source_code_with_indent": "class Timer(object):\n    <IND>def __init__(self, id: int, context: str, name: str, delay: float,\n            next_due: float, kwargs: dict):\n        <IND>self.id = id\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "class Timer(object):\n    <IND>def __init__(self, id: str, context: typing.Optional[str], name: str,\n            delay: float, next_due: typing.Optional[float], kwargs: dict):\n        <IND>self.id = id\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "        self._add(None, name, delay, next_due, None, True, kwargs)\n    def _add(self, context: str, name: str, delay: float, next_due: float,\n            id: str, persist: bool, kwargs: dict):\n        id = id or uuid.uuid4().hex\n        timer = Timer(id, context, name, delay, next_due, kwargs)\n",
        "source_code_len": 295,
        "target_code": "        self._add(None, name, delay, next_due, None, True, kwargs)\n    def _add(self, context: typing.Optional[str], name: str, delay: float,\n            next_due: typing.Optional[float], id: typing.Optional[str],\n            persist: bool, kwargs: dict):\n        id = id or str(uuid.uuid4())\n        timer = Timer(id, context, name, delay, next_due, kwargs)\n",
        "target_code_len": 359,
        "diff_format": "@@ -69,5 +69,6 @@\n         self._add(None, name, delay, next_due, None, True, kwargs)\n-    def _add(self, context: str, name: str, delay: float, next_due: float,\n-            id: str, persist: bool, kwargs: dict):\n-        id = id or uuid.uuid4().hex\n+    def _add(self, context: typing.Optional[str], name: str, delay: float,\n+            next_due: typing.Optional[float], id: typing.Optional[str],\n+            persist: bool, kwargs: dict):\n+        id = id or str(uuid.uuid4())\n         timer = Timer(id, context, name, delay, next_due, kwargs)\n",
        "source_code_with_indent": "        <IND>self._add(None, name, delay, next_due, None, True, kwargs)\n    <DED>def _add(self, context: str, name: str, delay: float, next_due: float,\n            id: str, persist: bool, kwargs: dict):\n        <IND>id = id or uuid.uuid4().hex\n        timer = Timer(id, context, name, delay, next_due, kwargs)\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "        <IND>self._add(None, name, delay, next_due, None, True, kwargs)\n    <DED>def _add(self, context: typing.Optional[str], name: str, delay: float,\n            next_due: typing.Optional[float], id: typing.Optional[str],\n            persist: bool, kwargs: dict):\n        <IND>id = id or str(uuid.uuid4())\n        timer = Timer(id, context, name, delay, next_due, kwargs)\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "jesopo/bitbot",
    "commit": "b543e31cd2a665b25aab4554e46a0ed5067d1bfe",
    "filename": "src/Timers.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/jesopo-bitbot/src/Timers.py",
    "file_hunks_size": 4,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "src/Timers.py:116:55 Incompatible parameter type [6]: Expected `str` for 5th positional only parameter to call `Timers._add` but got `None`.",
    "message": " Expected `str` for 5th positional only parameter to call `Timers._add` but got `None`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 116,
    "warning_line": "        self._parent._add(None, name, delay, next_due, None, True,",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "class Timer(object):\n    def __init__(self, id: int, context: str, name: str, delay: float,\n            next_due: float, kwargs: dict):\n        self.id = id\n",
        "source_code_len": 157,
        "target_code": "class Timer(object):\n    def __init__(self, id: str, context: typing.Optional[str], name: str,\n            delay: float, next_due: typing.Optional[float], kwargs: dict):\n        self.id = id\n",
        "target_code_len": 191,
        "diff_format": "@@ -4,4 +4,4 @@\n class Timer(object):\n-    def __init__(self, id: int, context: str, name: str, delay: float,\n-            next_due: float, kwargs: dict):\n+    def __init__(self, id: str, context: typing.Optional[str], name: str,\n+            delay: float, next_due: typing.Optional[float], kwargs: dict):\n         self.id = id\n",
        "source_code_with_indent": "class Timer(object):\n    <IND>def __init__(self, id: int, context: str, name: str, delay: float,\n            next_due: float, kwargs: dict):\n        <IND>self.id = id\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "class Timer(object):\n    <IND>def __init__(self, id: str, context: typing.Optional[str], name: str,\n            delay: float, next_due: typing.Optional[float], kwargs: dict):\n        <IND>self.id = id\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "        self._add(None, name, delay, next_due, None, True, kwargs)\n    def _add(self, context: str, name: str, delay: float, next_due: float,\n            id: str, persist: bool, kwargs: dict):\n        id = id or uuid.uuid4().hex\n        timer = Timer(id, context, name, delay, next_due, kwargs)\n",
        "source_code_len": 295,
        "target_code": "        self._add(None, name, delay, next_due, None, True, kwargs)\n    def _add(self, context: typing.Optional[str], name: str, delay: float,\n            next_due: typing.Optional[float], id: typing.Optional[str],\n            persist: bool, kwargs: dict):\n        id = id or str(uuid.uuid4())\n        timer = Timer(id, context, name, delay, next_due, kwargs)\n",
        "target_code_len": 359,
        "diff_format": "@@ -69,5 +69,6 @@\n         self._add(None, name, delay, next_due, None, True, kwargs)\n-    def _add(self, context: str, name: str, delay: float, next_due: float,\n-            id: str, persist: bool, kwargs: dict):\n-        id = id or uuid.uuid4().hex\n+    def _add(self, context: typing.Optional[str], name: str, delay: float,\n+            next_due: typing.Optional[float], id: typing.Optional[str],\n+            persist: bool, kwargs: dict):\n+        id = id or str(uuid.uuid4())\n         timer = Timer(id, context, name, delay, next_due, kwargs)\n",
        "source_code_with_indent": "        <IND>self._add(None, name, delay, next_due, None, True, kwargs)\n    <DED>def _add(self, context: str, name: str, delay: float, next_due: float,\n            id: str, persist: bool, kwargs: dict):\n        <IND>id = id or uuid.uuid4().hex\n        timer = Timer(id, context, name, delay, next_due, kwargs)\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "        <IND>self._add(None, name, delay, next_due, None, True, kwargs)\n    <DED>def _add(self, context: typing.Optional[str], name: str, delay: float,\n            next_due: typing.Optional[float], id: typing.Optional[str],\n            persist: bool, kwargs: dict):\n        <IND>id = id or str(uuid.uuid4())\n        timer = Timer(id, context, name, delay, next_due, kwargs)\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  }
]