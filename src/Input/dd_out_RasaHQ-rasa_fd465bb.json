[
  {
    "project": "RasaHQ/rasa",
    "commit": "fd465bb4a4e55c5661e401d1cc5fa0694d792870",
    "filename": "rasa/core/evaluation/marker_base.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/RasaHQ-rasa/rasa/core/evaluation/marker_base.py",
    "file_hunks_size": 12,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "rasa/core/evaluation/marker_base.py:606:46 Incompatible parameter type [6]: Expected `List[Union[Dict[str, EventMetaData], str]]` for 2nd positional only parameter to call `Marker._compute_stats` but got `Dict[typing.Any, typing.Any]`.",
    "message": " Expected `List[Union[Dict[str, EventMetaData], str]]` for 2nd positional only parameter to call `Marker._compute_stats` but got `Dict[typing.Any, typing.Any]`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 606,
    "warning_line": "            Marker._compute_stats(stats_file, processed_trackers)",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n\n",
        "source_code_len": 2,
        "target_code": "\n\n# We evaluate markers separately against every session and extract, for every marker\n# that we want to evaluate, the meta data of the respective relevant events where the\n# marker applies.\nSessionEvaluation = Dict[Text, List[EventMetaData]]\n\n",
        "target_code_len": 244,
        "diff_format": "@@ -146,2 +135,7 @@\n \n+\n+# We evaluate markers separately against every session and extract, for every marker\n+# that we want to evaluate, the meta data of the respective relevant events where the\n+# marker applies.\n+SessionEvaluation = Dict[Text, List[EventMetaData]]\n \n",
        "source_code_with_indent": "\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n\n# We evaluate markers separately against every session and extract, for every marker\n# that we want to evaluate, the meta data of the respective relevant events where the\n# marker applies.\n<DED>SessionEvaluation = Dict[Text, List[EventMetaData]]\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n    def export_markers(\n        self,\n        tracker_loader: Iterator[Optional[DialogueStateTracker]],\n        output_file: Text,\n        stats_file: Optional[Text] = None,\n    ) -> None:\n",
        "source_code_len": 190,
        "target_code": "\n    def evaluate_trackers(\n        self,\n        trackers: Iterator[Optional[DialogueStateTracker]],\n        output_file: Path,\n        session_stats_file: Optional[Path] = None,\n        overall_stats_file: Optional[Path] = None,\n    ) -> None:\n",
        "target_code_len": 246,
        "diff_format": "@@ -580,7 +574,8 @@\n \n-    def export_markers(\n+    def evaluate_trackers(\n         self,\n-        tracker_loader: Iterator[Optional[DialogueStateTracker]],\n-        output_file: Text,\n-        stats_file: Optional[Text] = None,\n+        trackers: Iterator[Optional[DialogueStateTracker]],\n+        output_file: Path,\n+        session_stats_file: Optional[Path] = None,\n+        overall_stats_file: Optional[Path] = None,\n     ) -> None:\n",
        "source_code_with_indent": "\n    <DED>def export_markers(\n        self,\n        tracker_loader: Iterator[Optional[DialogueStateTracker]],\n        output_file: Text,\n        stats_file: Optional[Text] = None,\n    ) -> None:\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n    <DED>def evaluate_trackers(\n        self,\n        trackers: Iterator[Optional[DialogueStateTracker]],\n        output_file: Path,\n        session_stats_file: Optional[Path] = None,\n        overall_stats_file: Optional[Path] = None,\n    ) -> None:\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "        Args:\n            tracker_loader: The tracker loader to use to select trackers for marker\n                            extraction.\n            output_file: Path to write out the extracted markers.\n            stats_file: (Optional) Path to write out statistics about the extracted\n                        markers.\n        \"\"\"\n        processed_trackers = {}\n\n        for tracker in tracker_loader:\n            if tracker:\n",
        "source_code_len": 429,
        "target_code": "        Args:\n            trackers: An iterator over the trackers from which we want to extract\n                markers.\n            output_file: Path to write out the extracted markers.\n            session_stats_file: (Optional) Path to write out statistics about the\n                extracted markers for each session separately.\n            overall_stats_file: (Optional) Path to write out statistics about the\n                markers extracted from all session data.\n\n        Raises:\n            `FileExistsError` if any of the specified files already exists\n            `NotADirectoryError` if any of the specified files is supposed to be\n                contained in a directory that does not exist\n        \"\"\"\n        # Check files and folders before doing the costly swipe over the trackers:\n        for path in [session_stats_file, overall_stats_file, output_file]:\n            if path is not None and path.is_file():\n                raise FileExistsError(f\"Expected that no file {path} already exists.\")\n            if path is not None and not path.parent.is_dir():\n                raise NotADirectoryError(f\"Expected directory {path.parent} to exist.\")\n\n        # Apply marker to each session stored in each tracker and save the results.\n        processed_trackers: Dict[Text, List[SessionEvaluation]] = {}\n        for tracker in trackers:\n            if tracker:\n",
        "target_code_len": 1375,
        "diff_format": "@@ -589,11 +584,25 @@\n         Args:\n-            tracker_loader: The tracker loader to use to select trackers for marker\n-                            extraction.\n+            trackers: An iterator over the trackers from which we want to extract\n+                markers.\n             output_file: Path to write out the extracted markers.\n-            stats_file: (Optional) Path to write out statistics about the extracted\n-                        markers.\n-        \"\"\"\n-        processed_trackers = {}\n-\n-        for tracker in tracker_loader:\n+            session_stats_file: (Optional) Path to write out statistics about the\n+                extracted markers for each session separately.\n+            overall_stats_file: (Optional) Path to write out statistics about the\n+                markers extracted from all session data.\n+\n+        Raises:\n+            `FileExistsError` if any of the specified files already exists\n+            `NotADirectoryError` if any of the specified files is supposed to be\n+                contained in a directory that does not exist\n+        \"\"\"\n+        # Check files and folders before doing the costly swipe over the trackers:\n+        for path in [session_stats_file, overall_stats_file, output_file]:\n+            if path is not None and path.is_file():\n+                raise FileExistsError(f\"Expected that no file {path} already exists.\")\n+            if path is not None and not path.parent.is_dir():\n+                raise NotADirectoryError(f\"Expected directory {path.parent} to exist.\")\n+\n+        # Apply marker to each session stored in each tracker and save the results.\n+        processed_trackers: Dict[Text, List[SessionEvaluation]] = {}\n+        for tracker in trackers:\n             if tracker:\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\n        processed_trackers = {}\n\n        for tracker in tracker_loader:\n            <IND>if tracker:\n",
        "target_code_with_indent": "\n        # Check files and folders before doing the costly swipe over the trackers:\n        for path in [session_stats_file, overall_stats_file, output_file]:\n            <IND>if path is not None and path.is_file():\n                <IND>raise FileExistsError(f\"Expected that no file {path} already exists.\")\n            <DED>if path is not None and not path.parent.is_dir():\n                <IND>raise NotADirectoryError(f\"Expected directory {path.parent} to exist.\")\n\n        # Apply marker to each session stored in each tracker and save the results.\n        <DED><DED>processed_trackers: Dict[Text, List[SessionEvaluation]] = {}\n        for tracker in trackers:\n            <IND>if tracker:\n"
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "                processed_trackers[tracker.sender_id] = tracker_result\n\n        Marker._save_results(output_file, processed_trackers)\n\n        if stats_file:\n            Marker._compute_stats(stats_file, processed_trackers)\n\n    @staticmethod\n    def _save_results(\n        path: Text, results: Dict[Text, List[Dict[Text, EventMetaData]]]\n    ) -> None:\n        \"\"\"Save extracted marker results as CSV to specified path.\n",
        "source_code_len": 421,
        "target_code": "                processed_trackers[tracker.sender_id] = tracker_result\n        Marker._save_results(output_file, processed_trackers)\n\n        # Compute and write statistics if requested.\n        if session_stats_file or overall_stats_file:\n            from rasa.core.evaluation.marker_stats import MarkerStatistics\n\n            stats = MarkerStatistics()\n            for sender_id, tracker_result in processed_trackers.items():\n                for session_idx, session_result in enumerate(tracker_result):\n                    stats.process(\n                        sender_id=sender_id,\n                        session_idx=session_idx,\n                        meta_data_on_relevant_events_per_marker=session_result,\n                    )\n            if overall_stats_file:\n                stats.overall_statistic_to_csv(path=overall_stats_file)\n            if session_stats_file:\n                stats.per_session_statistics_to_csv(path=session_stats_file)\n\n    @staticmethod\n    def _save_results(path: Path, results: Dict[Text, List[SessionEvaluation]]) -> None:\n        \"\"\"Save extracted marker results as CSV to specified path.\n",
        "target_code_len": 1131,
        "diff_format": "@@ -601,12 +610,23 @@\n                 processed_trackers[tracker.sender_id] = tracker_result\n-\n         Marker._save_results(output_file, processed_trackers)\n \n-        if stats_file:\n-            Marker._compute_stats(stats_file, processed_trackers)\n-\n-    @staticmethod\n-    def _save_results(\n-        path: Text, results: Dict[Text, List[Dict[Text, EventMetaData]]]\n-    ) -> None:\n+        # Compute and write statistics if requested.\n+        if session_stats_file or overall_stats_file:\n+            from rasa.core.evaluation.marker_stats import MarkerStatistics\n+\n+            stats = MarkerStatistics()\n+            for sender_id, tracker_result in processed_trackers.items():\n+                for session_idx, session_result in enumerate(tracker_result):\n+                    stats.process(\n+                        sender_id=sender_id,\n+                        session_idx=session_idx,\n+                        meta_data_on_relevant_events_per_marker=session_result,\n+                    )\n+            if overall_stats_file:\n+                stats.overall_statistic_to_csv(path=overall_stats_file)\n+            if session_stats_file:\n+                stats.per_session_statistics_to_csv(path=session_stats_file)\n+\n+    @staticmethod\n+    def _save_results(path: Path, results: Dict[Text, List[SessionEvaluation]]) -> None:\n         \"\"\"Save extracted marker results as CSV to specified path.\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "                processed_trackers[tracker.sender_id] = tracker_result\n\n        <DED><DED>Marker._save_results(output_file, processed_trackers)\n\n        if stats_file:\n            <IND>Marker._compute_stats(stats_file, processed_trackers)\n\n    <DED><DED>@staticmethod\n    def _save_results(\n        path: Text, results: Dict[Text, List[Dict[Text, EventMetaData]]]\n    ) -> None:\n        <IND>",
        "target_code_with_indent": "                processed_trackers[tracker.sender_id] = tracker_result\n        <DED><DED>Marker._save_results(output_file, processed_trackers)\n\n        # Compute and write statistics if requested.\n        if session_stats_file or overall_stats_file:\n            <IND>from rasa.core.evaluation.marker_stats import MarkerStatistics\n\n            stats = MarkerStatistics()\n            for sender_id, tracker_result in processed_trackers.items():\n                <IND>for session_idx, session_result in enumerate(tracker_result):\n                    <IND>stats.process(\n                        sender_id=sender_id,\n                        session_idx=session_idx,\n                        meta_data_on_relevant_events_per_marker=session_result,\n                    )\n            <DED><DED>if overall_stats_file:\n                <IND>stats.overall_statistic_to_csv(path=overall_stats_file)\n            <DED>if session_stats_file:\n                <IND>stats.per_session_statistics_to_csv(path=session_stats_file)\n\n    <DED><DED><DED>@staticmethod\n    def _save_results(path: Path, results: Dict[Text, List[SessionEvaluation]]) -> None:\n        <IND>"
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    def _write_relevant_events(\n        writer: WriteRow,\n        sender_id: Text,\n        session_idx: int,\n        session: Dict[Text, EventMetaData],\n    ) -> None:\n        for marker_name, marker_metadata in session.items():\n            for metadata in marker_metadata:\n                writer.writerow(\n",
        "source_code_len": 307,
        "target_code": "    def _write_relevant_events(\n        writer: WriteRow, sender_id: Text, session_idx: int, session: SessionEvaluation,\n    ) -> None:\n        for marker_name, meta_data_per_relevant_event in session.items():\n            for event_meta_data in meta_data_per_relevant_event:\n                writer.writerow(\n",
        "target_code_len": 308,
        "diff_format": "@@ -636,9 +656,6 @@\n     def _write_relevant_events(\n-        writer: WriteRow,\n-        sender_id: Text,\n-        session_idx: int,\n-        session: Dict[Text, EventMetaData],\n+        writer: WriteRow, sender_id: Text, session_idx: int, session: SessionEvaluation,\n     ) -> None:\n-        for marker_name, marker_metadata in session.items():\n-            for metadata in marker_metadata:\n+        for marker_name, meta_data_per_relevant_event in session.items():\n+            for event_meta_data in meta_data_per_relevant_event:\n                 writer.writerow(\n",
        "source_code_with_indent": "    def _write_relevant_events(\n        writer: WriteRow,\n        sender_id: Text,\n        session_idx: int,\n        session: Dict[Text, EventMetaData],\n    ) -> None:\n        <IND>for marker_name, marker_metadata in session.items():\n            <IND>for metadata in marker_metadata:\n                <IND>writer.writerow(\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    def _write_relevant_events(\n        writer: WriteRow, sender_id: Text, session_idx: int, session: SessionEvaluation,\n    ) -> None:\n        <IND>for marker_name, meta_data_per_relevant_event in session.items():\n            <IND>for event_meta_data in meta_data_per_relevant_event:\n                <IND>writer.writerow(\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "                        marker_name,\n                        metadata.idx,\n                        metadata.preceding_user_turns,\n                    ]\n                )\n\n    @staticmethod\n    def _compute_stats(\n        out_file: Text, results: List[Union[Text, Dict[Text, EventMetaData]]]\n    ) -> None:\n        \"\"\"Compute stats over extracted marker data.\"\"\"\n        # TODO: Figure out how this is done\n        pass\n\n",
        "source_code_len": 420,
        "target_code": "                        marker_name,\n                        str(event_meta_data.idx),\n                        str(event_meta_data.preceding_user_turns),\n                    ]\n                )\n\n",
        "target_code_len": 195,
        "diff_format": "@@ -648,14 +665,6 @@\n                         marker_name,\n-                        metadata.idx,\n-                        metadata.preceding_user_turns,\n+                        str(event_meta_data.idx),\n+                        str(event_meta_data.preceding_user_turns),\n                     ]\n                 )\n-\n-    @staticmethod\n-    def _compute_stats(\n-        out_file: Text, results: List[Union[Text, Dict[Text, EventMetaData]]]\n-    ) -> None:\n-        \"\"\"Compute stats over extracted marker data.\"\"\"\n-        # TODO: Figure out how this is done\n-        pass\n \n",
        "source_code_with_indent": "                        marker_name,\n                        metadata.idx,\n                        metadata.preceding_user_turns,\n                    ]\n                )\n\n    <DED><DED><DED>@staticmethod\n    def _compute_stats(\n        out_file: Text, results: List[Union[Text, Dict[Text, EventMetaData]]]\n    ) -> None:\n        <IND>\"\"\"Compute stats over extracted marker data.\"\"\"\n        # TODO: Figure out how this is done\n        pass\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "                        marker_name,\n                        str(event_meta_data.idx),\n                        str(event_meta_data.preceding_user_turns),\n                    ]\n                )\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "RasaHQ/rasa",
    "commit": "fd465bb4a4e55c5661e401d1cc5fa0694d792870",
    "filename": "tests/core/evaluation/test_marker.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/RasaHQ-rasa/tests/core/evaluation/test_marker.py",
    "file_hunks_size": 1,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "tests/core/evaluation/test_marker.py:496:50 Incompatible parameter type [6]: Expected `str` for 2nd positional only parameter to call `Marker.export_markers` but got `Path`.",
    "message": " Expected `str` for 2nd positional only parameter to call `Marker.export_markers` but got `Path`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 496,
    "warning_line": "    markers.export_markers(tracker_loader.load(), results_path, stats_file=None)"
  }
]