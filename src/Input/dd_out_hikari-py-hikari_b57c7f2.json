[
  {
    "project": "hikari-py/hikari",
    "commit": "b57c7f2c9b2d152e1030680c10feb9d6c01a7a1e",
    "filename": "hikari/orm/models/guilds.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/hikari-py-hikari/hikari/orm/models/guilds.py",
    "file_hunks_size": 4,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "hikari/orm/models/guilds.py:327:8 Incompatible attribute type [8]: Attribute `emojis` declared in class `Guild` has type `typing.MutableMapping[int, emojis.GuildEmoji]` but is used as type `typing.MutableMapping[int, emojis.Emoji]`.",
    "message": " Attribute `emojis` declared in class `Guild` has type `typing.MutableMapping[int, emojis.GuildEmoji]` but is used as type `typing.MutableMapping[int, emojis.Emoji]`.",
    "rule_id": "Incompatible attribute type [8]",
    "warning_line_no": 327,
    "warning_line": "        self.emojis = transformations.id_map("
  },
  {
    "project": "hikari-py/hikari",
    "commit": "b57c7f2c9b2d152e1030680c10feb9d6c01a7a1e",
    "filename": "hikari/orm/models/guilds.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/hikari-py-hikari/hikari/orm/models/guilds.py",
    "file_hunks_size": 4,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "hikari/orm/models/guilds.py:333:82 Incompatible parameter type [6]: Expected `typing.Dict[str, typing.Union[None, typing.Dict[typing.Any, typing.Any], typing.List[typing.Any], bool, float, int, str]]` for 2nd positional only parameter to call `hikari.orm.state_registry.IStateRegistry.parse_voice_state` but got `Guild`.",
    "message": " Expected `typing.Dict[str, typing.Union[None, typing.Dict[typing.Any, typing.Any], typing.List[typing.Any], bool, float, int, str]]` for 2nd positional only parameter to call `hikari.orm.state_registry.IStateRegistry.parse_voice_state` but got `Guild`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 333,
    "warning_line": "            int(vs[\"user_id\"]): self._fabric.state_registry.parse_voice_state(vs, self)"
  },
  {
    "project": "hikari-py/hikari",
    "commit": "b57c7f2c9b2d152e1030680c10feb9d6c01a7a1e",
    "filename": "hikari/orm/models/guilds.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/hikari-py-hikari/hikari/orm/models/guilds.py",
    "file_hunks_size": 4,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "hikari/orm/models/guilds.py:345:8 Incompatible attribute type [8]: Attribute `channels` declared in class `Guild` has type `typing.MutableMapping[int, channels.GuildChannel]` but is used as type `typing.MutableMapping[int, channels.Channel]`.",
    "message": " Attribute `channels` declared in class `Guild` has type `typing.MutableMapping[int, channels.GuildChannel]` but is used as type `typing.MutableMapping[int, channels.Channel]`.",
    "rule_id": "Incompatible attribute type [8]",
    "warning_line_no": 345,
    "warning_line": "        self.channels = transformations.id_map("
  },
  {
    "project": "hikari-py/hikari",
    "commit": "b57c7f2c9b2d152e1030680c10feb9d6c01a7a1e",
    "filename": "hikari/orm/models/guilds.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/hikari-py-hikari/hikari/orm/models/guilds.py",
    "file_hunks_size": 4,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "hikari/orm/models/guilds.py:479:8 Incompatible attribute type [8]: Attribute `user` declared in class `Ban` has type `users.User` but is used as type `users.IUser`.",
    "message": " Attribute `user` declared in class `Ban` has type `users.User` but is used as type `users.IUser`.",
    "rule_id": "Incompatible attribute type [8]",
    "warning_line_no": 479,
    "warning_line": "        self.user = fabric_obj.state_registry.parse_user(payload.get(\"user\"))",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    #: :type: :class:`hikari.orm.models.users.User`\n    user: users.User\n\n",
        "source_code_len": 74,
        "target_code": "    #: :type: :class:`hikari.orm.models.users.User`\n    user: users.IUser\n\n",
        "target_code_len": 75,
        "diff_format": "@@ -472,3 +474,3 @@\n     #: :type: :class:`hikari.orm.models.users.User`\n-    user: users.User\n+    user: users.IUser\n \n",
        "source_code_with_indent": "    #: :type: :class:`hikari.orm.models.users.User`\n    user: users.User\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    #: :type: :class:`hikari.orm.models.users.User`\n    user: users.IUser\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "hikari-py/hikari",
    "commit": "b57c7f2c9b2d152e1030680c10feb9d6c01a7a1e",
    "filename": "hikari/orm/models/integrations.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/hikari-py-hikari/hikari/orm/models/integrations.py",
    "file_hunks_size": 5,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "hikari/orm/models/integrations.py:144:8 Incompatible attribute type [8]: Attribute `user` declared in class `Integration` has type `users.User` but is used as type `users.IUser`.",
    "message": " Attribute `user` declared in class `Integration` has type `users.User` but is used as type `users.IUser`.",
    "rule_id": "Incompatible attribute type [8]",
    "warning_line_no": 144,
    "warning_line": "        self.user = self._fabric.state_registry.parse_user(payload[\"user\"])"
  },
  {
    "project": "hikari-py/hikari",
    "commit": "b57c7f2c9b2d152e1030680c10feb9d6c01a7a1e",
    "filename": "hikari/orm/models/invites.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/hikari-py-hikari/hikari/orm/models/invites.py",
    "file_hunks_size": 2,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "hikari/orm/models/invites.py:160:8 Incompatible attribute type [8]: Attribute `inviter` declared in class `InviteMetadata` has type `users.User` but is used as type `users.IUser`.",
    "message": " Attribute `inviter` declared in class `InviteMetadata` has type `users.User` but is used as type `users.IUser`.",
    "rule_id": "Incompatible attribute type [8]",
    "warning_line_no": 160,
    "warning_line": "        self.inviter = fabric_obj.state_registry.parse_user(payload[\"inviter\"])"
  },
  {
    "project": "hikari-py/hikari",
    "commit": "b57c7f2c9b2d152e1030680c10feb9d6c01a7a1e",
    "filename": "hikari/orm/models/media.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/hikari-py-hikari/hikari/orm/models/media.py",
    "file_hunks_size": 3,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": true,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "hikari/orm/models/media.py:55:4 Inconsistent override [15]: `__slots__` overrides attribute defined in `interfaces.IModel` inconsistently. Type `typing.Tuple[str, str]` is not a subtype of the overridden attribute `typing.Tuple[]`.",
    "message": " `__slots__` overrides attribute defined in `interfaces.IModel` inconsistently. Type `typing.Tuple[str, str]` is not a subtype of the overridden attribute `typing.Tuple[]`.",
    "rule_id": "Inconsistent override [15]",
    "warning_line_no": 55,
    "warning_line": "    __slots__ = (\"mime_type\", \"data\")",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": true,
        "has_suppression": false,
        "source_code": "_DATA_URI_SCHEME_REGEX = re.compile(r\"^data:([^;]+);base64,(.+)$\", re.I | re.U)\n\n\nclass Avatar(interfaces.IModel):\n    \"\"\"\n    Represents an Avatar. This contains compressed raw byte data of the given image.\n\n    The object is initialized from a MIME type and base 64 string. This base 64 string is decoded on initialization\n    which reduces the overall byte string size by roughly 1/3.\n    \"\"\"\n\n    __slots__ = (\"mime_type\", \"data\")\n\n    #: The MIME type of the data.\n    #:\n    #: :type: :class:`str`\n    mime_type: str\n\n    #: Image data\n    #:\n    #: :type: :class:`bytes`\n    data: bytes\n\n    __repr__ = auto_repr.repr_of(\"mime_type\")\n\n    def __init__(self, mime_type: str, base64_data: bytes) -> None:\n        \"\"\"\n        Args:\n            mime_type:\n                The MIME type of the data.\n            base64_data:\n                The raw Base64 data that was provided from the data URI scheme.\n        \"\"\"\n        self.mime_type = mime_type\n        self.data = base64.b64decode(base64_data)\n\n    def get_file_types(self) -> typing.Sequence[str]:\n        \"\"\"\n        Returns:\n            A sequence of guessed file extensions that are valid for the given MIME type of this avatar. Each will begin\n            with a period `.` and is simply an educated guess.\n        \"\"\"\n        return mimetypes.guess_all_extensions(self.mime_type, strict=True)\n\n    def to_data_uri(self) -> str:\n        \"\"\"\n        Returns:\n            A data URI of the given image.\n            See the :attr:`data` note for performance information.\n        \"\"\"\n        b64 = base64.b64encode(self.data).decode()\n        return f\"data:{self.mime_type};base64,{b64}\"\n\n    def to_file_object(self) -> io.BytesIO:\n        \"\"\"\n        Returns:\n            A file-like object that is seekable containing the uncompressed image data.\n        \"\"\"\n        return io.BytesIO(self.data)\n\n    @classmethod\n    def from_data_uri_scheme(cls, data_uri_scheme: str) -> Avatar:\n        \"\"\"\n        Consumes a given base64-type data URI scheme and produces a compressed Avatar object from it.\n\n        Args:\n            data_uri_scheme:\n                The data URI scheme to parse.\n        Returns:\n            A compressed Avatar object.\n        \"\"\"\n        try:\n            mime_type, b64 = _DATA_URI_SCHEME_REGEX.findall(data_uri_scheme)[0]\n            return cls(mime_type, bytes(b64, \"ascii\"))\n        except IndexError:\n            raise TypeError(\"Invalid data URI scheme provided\") from None\n\n    def __len__(self):\n        return len(self.data)\n\n",
        "source_code_len": 2522,
        "target_code": "_DATA_URI_SCHEME_REGEX = re.compile(r\"^data:([^;]+);base64,(.+)$\", re.I | re.U)\n\n",
        "target_code_len": 81,
        "diff_format": "@@ -44,80 +45,2 @@\n _DATA_URI_SCHEME_REGEX = re.compile(r\"^data:([^;]+);base64,(.+)$\", re.I | re.U)\n-\n-\n-class Avatar(interfaces.IModel):\n-    \"\"\"\n-    Represents an Avatar. This contains compressed raw byte data of the given image.\n-\n-    The object is initialized from a MIME type and base 64 string. This base 64 string is decoded on initialization\n-    which reduces the overall byte string size by roughly 1/3.\n-    \"\"\"\n-\n-    __slots__ = (\"mime_type\", \"data\")\n-\n-    #: The MIME type of the data.\n-    #:\n-    #: :type: :class:`str`\n-    mime_type: str\n-\n-    #: Image data\n-    #:\n-    #: :type: :class:`bytes`\n-    data: bytes\n-\n-    __repr__ = auto_repr.repr_of(\"mime_type\")\n-\n-    def __init__(self, mime_type: str, base64_data: bytes) -> None:\n-        \"\"\"\n-        Args:\n-            mime_type:\n-                The MIME type of the data.\n-            base64_data:\n-                The raw Base64 data that was provided from the data URI scheme.\n-        \"\"\"\n-        self.mime_type = mime_type\n-        self.data = base64.b64decode(base64_data)\n-\n-    def get_file_types(self) -> typing.Sequence[str]:\n-        \"\"\"\n-        Returns:\n-            A sequence of guessed file extensions that are valid for the given MIME type of this avatar. Each will begin\n-            with a period `.` and is simply an educated guess.\n-        \"\"\"\n-        return mimetypes.guess_all_extensions(self.mime_type, strict=True)\n-\n-    def to_data_uri(self) -> str:\n-        \"\"\"\n-        Returns:\n-            A data URI of the given image.\n-            See the :attr:`data` note for performance information.\n-        \"\"\"\n-        b64 = base64.b64encode(self.data).decode()\n-        return f\"data:{self.mime_type};base64,{b64}\"\n-\n-    def to_file_object(self) -> io.BytesIO:\n-        \"\"\"\n-        Returns:\n-            A file-like object that is seekable containing the uncompressed image data.\n-        \"\"\"\n-        return io.BytesIO(self.data)\n-\n-    @classmethod\n-    def from_data_uri_scheme(cls, data_uri_scheme: str) -> Avatar:\n-        \"\"\"\n-        Consumes a given base64-type data URI scheme and produces a compressed Avatar object from it.\n-\n-        Args:\n-            data_uri_scheme:\n-                The data URI scheme to parse.\n-        Returns:\n-            A compressed Avatar object.\n-        \"\"\"\n-        try:\n-            mime_type, b64 = _DATA_URI_SCHEME_REGEX.findall(data_uri_scheme)[0]\n-            return cls(mime_type, bytes(b64, \"ascii\"))\n-        except IndexError:\n-            raise TypeError(\"Invalid data URI scheme provided\") from None\n-\n-    def __len__(self):\n-        return len(self.data)\n \n",
        "source_code_with_indent": "_DATA_URI_SCHEME_REGEX = re.compile(r\"^data:([^;]+);base64,(.+)$\", re.I | re.U)\n\n\nclass Avatar(interfaces.IModel):\n    <IND>\"\"\"\n    Represents an Avatar. This contains compressed raw byte data of the given image.\n\n    The object is initialized from a MIME type and base 64 string. This base 64 string is decoded on initialization\n    which reduces the overall byte string size by roughly 1/3.\n    \"\"\"\n\n    __slots__ = (\"mime_type\", \"data\")\n\n    #: The MIME type of the data.\n    #:\n    #: :type: :class:`str`\n    mime_type: str\n\n    #: Image data\n    #:\n    #: :type: :class:`bytes`\n    data: bytes\n\n    __repr__ = auto_repr.repr_of(\"mime_type\")\n\n    def __init__(self, mime_type: str, base64_data: bytes) -> None:\n        <IND>\"\"\"\n        Args:\n            mime_type:\n                The MIME type of the data.\n            base64_data:\n                The raw Base64 data that was provided from the data URI scheme.\n        \"\"\"\n        self.mime_type = mime_type\n        self.data = base64.b64decode(base64_data)\n\n    <DED>def get_file_types(self) -> typing.Sequence[str]:\n        <IND>\"\"\"\n        Returns:\n            A sequence of guessed file extensions that are valid for the given MIME type of this avatar. Each will begin\n            with a period `.` and is simply an educated guess.\n        \"\"\"\n        return mimetypes.guess_all_extensions(self.mime_type, strict=True)\n\n    <DED>def to_data_uri(self) -> str:\n        <IND>\"\"\"\n        Returns:\n            A data URI of the given image.\n            See the :attr:`data` note for performance information.\n        \"\"\"\n        b64 = base64.b64encode(self.data).decode()\n        return f\"data:{self.mime_type};base64,{b64}\"\n\n    <DED>def to_file_object(self) -> io.BytesIO:\n        <IND>\"\"\"\n        Returns:\n            A file-like object that is seekable containing the uncompressed image data.\n        \"\"\"\n        return io.BytesIO(self.data)\n\n    <DED>@classmethod\n    def from_data_uri_scheme(cls, data_uri_scheme: str) -> Avatar:\n        <IND>\"\"\"\n        Consumes a given base64-type data URI scheme and produces a compressed Avatar object from it.\n\n        Args:\n            data_uri_scheme:\n                The data URI scheme to parse.\n        Returns:\n            A compressed Avatar object.\n        \"\"\"\n        try:\n            <IND>mime_type, b64 = _DATA_URI_SCHEME_REGEX.findall(data_uri_scheme)[0]\n            return cls(mime_type, bytes(b64, \"ascii\"))\n        <DED>except IndexError:\n            <IND>raise TypeError(\"Invalid data URI scheme provided\") from None\n\n    <DED><DED>def __len__(self):\n        <IND>return len(self.data)\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "_DATA_URI_SCHEME_REGEX = re.compile(r\"^data:([^;]+);base64,(.+)$\", re.I | re.U)\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "hikari-py/hikari",
    "commit": "b57c7f2c9b2d152e1030680c10feb9d6c01a7a1e",
    "filename": "hikari/orm/models/messages.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/hikari-py-hikari/hikari/orm/models/messages.py",
    "file_hunks_size": 6,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "hikari/orm/models/messages.py:265:12 Incompatible attribute type [8]: Attribute `author` declared in class `Message` has type `typing.Union[members.Member, users.User, webhooks.Webhook]` but is used as type `users.IUser`.",
    "message": " Attribute `author` declared in class `Message` has type `typing.Union[members.Member, users.User, webhooks.Webhook]` but is used as type `users.IUser`.",
    "rule_id": "Incompatible attribute type [8]",
    "warning_line_no": 265,
    "warning_line": "            self.author = self._fabric.state_registry.parse_user(payload[\"author\"])"
  }
]