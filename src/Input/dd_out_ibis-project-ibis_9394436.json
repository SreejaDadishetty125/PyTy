[
  {
    "project": "ibis-project/ibis",
    "commit": "9394436c86ed860c0735cc622c8128aa49dd58cd",
    "filename": "ibis/expr/types.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/ibis-project-ibis/ibis/expr/types.py",
    "file_hunks_size": 18,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "ibis/expr/types.py:260:11 Invalid type [31]: Expression `six.with_metaclass(ibis.expr.types.OperationMeta, object)` is not a valid type.",
    "message": " Expression `six.with_metaclass(ibis.expr.types.OperationMeta, object)` is not a valid type.",
    "rule_id": "Invalid type [31]",
    "warning_line_no": 260,
    "warning_line": "class Node(six.with_metaclass(OperationMeta, object)):",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": true,
        "has_suppression": false,
        "source_code": "\ndef _safe_repr(x, memo=None):\n    return x._repr(memo=memo) if isinstance(x, (Expr, Node)) else repr(x)\n\n\nclass OperationMeta(type):\n\n    def __new__(cls, name, parents, dct):\n        if 'input_type' in dct:\n            from ibis.expr.rules import TypeSignature, signature\n            sig = dct['input_type']\n            if not isinstance(sig, TypeSignature):\n                dct['input_type'] = sig = signature(sig)\n\n                for i, t in enumerate(sig.types):\n                    if t.name is None:\n                        continue\n\n                    if t.name not in dct:\n                        dct[t.name] = _arg_getter(i, doc=t.doc)\n\n        return super(OperationMeta, cls).__new__(cls, name, parents, dct)\n\n\nclass Node(six.with_metaclass(OperationMeta, object)):\n\n    \"\"\"\n    Node is the base class for all relational algebra and analytical\n    functionality. It transforms the input expressions into an output\n    expression.\n\n    Each node implementation is responsible for validating the inputs,\n    including any type promotion and / or casting issues, and producing a\n    well-typed expression\n\n    Note that Node is deliberately not made an expression subclass: think\n    of Node as merely a typed expression builder.\n    \"\"\"\n\n    def __init__(self, args=None):\n        args = args or []\n        self.args = self._validate_args(args)\n\n    def _validate_args(self, args):\n        if not hasattr(self, 'input_type'):\n            return args\n\n        return self.input_type.validate(args)\n\n    def __repr__(self):\n        return self._repr()\n\n    def _repr(self, memo=None):\n        if memo is None:\n            from ibis.expr.format import FormatMemo\n            memo = FormatMemo()\n\n        opname = type(self).__name__\n        pprint_args = []\n\n        def _pp(x):\n            return _safe_repr(x, memo=memo)\n\n        for x in self.args:\n            if isinstance(x, (tuple, list)):\n                pp = repr([_pp(y) for y in x])\n            else:\n                pp = _pp(x)\n            pprint_args.append(pp)\n\n        return '%s(%s)' % (opname, ', '.join(pprint_args))\n\n    def blocks(self):\n        # The contents of this node at referentially distinct and may not be\n        # analyzed deeper\n        return False\n\n    def flat_args(self):\n        for arg in self.args:\n            if not isinstance(arg, six.string_types) and isinstance(\n                arg, collections.Iterable\n            ):\n                for x in arg:\n                    yield x\n            else:\n                yield arg\n\n    def equals(self, other, cache=None):\n        if cache is None:\n            cache = {}\n\n        if (self, other) in cache:\n            return cache[(self, other)]\n\n        if id(self) == id(other):\n            cache[(self, other)] = True\n            return True\n\n        if type(self) != type(other):\n            cache[(self, other)] = False\n            return False\n\n        if len(self.args) != len(other.args):\n            cache[(self, other)] = False\n            return False\n\n        for left, right in zip(self.args, other.args):\n            if not all_equal(left, right, cache=cache):\n                cache[(self, other)] = False\n                return False\n        cache[(self, other)] = True\n        return True\n\n    def is_ancestor(self, other):\n        if isinstance(other, Expr):\n            other = other.op()\n\n        return self.equals(other)\n\n    _expr_cached = None\n\n    def to_expr(self):\n        if self._expr_cached is None:\n            self._expr_cached = self._make_expr()\n        return self._expr_cached\n\n    def _make_expr(self):\n        klass = self.output_type()\n        return klass(self)\n\n    def output_type(self):\n        \"\"\"\n        This function must resolve the output type of the expression and return\n        the node wrapped in the appropriate ValueExpr type.\n        \"\"\"\n        raise NotImplementedError\n\n    @property\n    def _arg_names(self):\n        try:\n            input_type = self.__class__.input_type\n        except AttributeError:\n            return []\n        else:\n            return [t.name for t in getattr(input_type, 'types', [])]\n\n\ndef all_equal(left, right, cache=None):\n    if isinstance(left, list):\n        if not isinstance(right, list):\n            return False\n        for a, b in zip(left, right):\n            if not all_equal(a, b, cache=cache):\n                return False\n        return True\n\n    if hasattr(left, 'equals'):\n        return left.equals(right, cache=cache)\n    return left == right\n\n\ndef _arg_getter(i, doc=None):\n    def arg_accessor(self):\n        return self.args[i]\n    return property(arg_accessor, doc=doc)\n\n\nclass ValueOp(Node):\n\n    def __init__(self, *args):\n        super(ValueOp, self).__init__(args)\n\n    def root_tables(self):\n        exprs = [arg for arg in self.args if isinstance(arg, Expr)]\n        return distinct_roots(*exprs)\n\n    def resolve_name(self):\n        raise com.ExpressionError('Expression is not named: %s' % repr(self))\n\n    def has_resolved_name(self):\n        return False\n\n\nclass TableColumn(ValueOp):\n\n    \"\"\"\n    Selects a column from a TableExpr\n    \"\"\"\n\n    def __init__(self, name, table_expr):\n        schema = table_expr.schema()\n        if isinstance(name, six.integer_types):\n            name = schema.name_at_position(name)\n\n        super(TableColumn, self).__init__(name, table_expr)\n        if name not in schema:\n            raise com.IbisTypeError(\n                \"'{0}' is not a field in {1}\".format(name, table_expr.columns)\n            )\n\n        self.name = name\n        self.table = table_expr\n\n    def parent(self):\n        return self.table\n\n    def resolve_name(self):\n        return self.name\n\n    def has_resolved_name(self):\n        return True\n\n    def root_tables(self):\n        return self.table._root_tables()\n\n    def _make_expr(self):\n        ctype = self.table._get_type(self.name)\n        klass = ctype.array_type()\n        return klass(self, name=self.name)\n\n\nclass ExpressionList(Node):\n\n    def __init__(self, exprs):\n        exprs = [as_value_expr(x) for x in exprs]\n        Node.__init__(self, exprs)\n\n    def root_tables(self):\n        return distinct_roots(*self.args)\n\n    def output_type(self):\n        return ExprList\n\n\nclass ExprList(Expr):\n",
        "source_code_len": 6234,
        "target_code": "\nclass ExprList(Expr):\n",
        "target_code_len": 23,
        "diff_format": "@@ -236,235 +224,2 @@\n \n-def _safe_repr(x, memo=None):\n-    return x._repr(memo=memo) if isinstance(x, (Expr, Node)) else repr(x)\n-\n-\n-class OperationMeta(type):\n-\n-    def __new__(cls, name, parents, dct):\n-        if 'input_type' in dct:\n-            from ibis.expr.rules import TypeSignature, signature\n-            sig = dct['input_type']\n-            if not isinstance(sig, TypeSignature):\n-                dct['input_type'] = sig = signature(sig)\n-\n-                for i, t in enumerate(sig.types):\n-                    if t.name is None:\n-                        continue\n-\n-                    if t.name not in dct:\n-                        dct[t.name] = _arg_getter(i, doc=t.doc)\n-\n-        return super(OperationMeta, cls).__new__(cls, name, parents, dct)\n-\n-\n-class Node(six.with_metaclass(OperationMeta, object)):\n-\n-    \"\"\"\n-    Node is the base class for all relational algebra and analytical\n-    functionality. It transforms the input expressions into an output\n-    expression.\n-\n-    Each node implementation is responsible for validating the inputs,\n-    including any type promotion and / or casting issues, and producing a\n-    well-typed expression\n-\n-    Note that Node is deliberately not made an expression subclass: think\n-    of Node as merely a typed expression builder.\n-    \"\"\"\n-\n-    def __init__(self, args=None):\n-        args = args or []\n-        self.args = self._validate_args(args)\n-\n-    def _validate_args(self, args):\n-        if not hasattr(self, 'input_type'):\n-            return args\n-\n-        return self.input_type.validate(args)\n-\n-    def __repr__(self):\n-        return self._repr()\n-\n-    def _repr(self, memo=None):\n-        if memo is None:\n-            from ibis.expr.format import FormatMemo\n-            memo = FormatMemo()\n-\n-        opname = type(self).__name__\n-        pprint_args = []\n-\n-        def _pp(x):\n-            return _safe_repr(x, memo=memo)\n-\n-        for x in self.args:\n-            if isinstance(x, (tuple, list)):\n-                pp = repr([_pp(y) for y in x])\n-            else:\n-                pp = _pp(x)\n-            pprint_args.append(pp)\n-\n-        return '%s(%s)' % (opname, ', '.join(pprint_args))\n-\n-    def blocks(self):\n-        # The contents of this node at referentially distinct and may not be\n-        # analyzed deeper\n-        return False\n-\n-    def flat_args(self):\n-        for arg in self.args:\n-            if not isinstance(arg, six.string_types) and isinstance(\n-                arg, collections.Iterable\n-            ):\n-                for x in arg:\n-                    yield x\n-            else:\n-                yield arg\n-\n-    def equals(self, other, cache=None):\n-        if cache is None:\n-            cache = {}\n-\n-        if (self, other) in cache:\n-            return cache[(self, other)]\n-\n-        if id(self) == id(other):\n-            cache[(self, other)] = True\n-            return True\n-\n-        if type(self) != type(other):\n-            cache[(self, other)] = False\n-            return False\n-\n-        if len(self.args) != len(other.args):\n-            cache[(self, other)] = False\n-            return False\n-\n-        for left, right in zip(self.args, other.args):\n-            if not all_equal(left, right, cache=cache):\n-                cache[(self, other)] = False\n-                return False\n-        cache[(self, other)] = True\n-        return True\n-\n-    def is_ancestor(self, other):\n-        if isinstance(other, Expr):\n-            other = other.op()\n-\n-        return self.equals(other)\n-\n-    _expr_cached = None\n-\n-    def to_expr(self):\n-        if self._expr_cached is None:\n-            self._expr_cached = self._make_expr()\n-        return self._expr_cached\n-\n-    def _make_expr(self):\n-        klass = self.output_type()\n-        return klass(self)\n-\n-    def output_type(self):\n-        \"\"\"\n-        This function must resolve the output type of the expression and return\n-        the node wrapped in the appropriate ValueExpr type.\n-        \"\"\"\n-        raise NotImplementedError\n-\n-    @property\n-    def _arg_names(self):\n-        try:\n-            input_type = self.__class__.input_type\n-        except AttributeError:\n-            return []\n-        else:\n-            return [t.name for t in getattr(input_type, 'types', [])]\n-\n-\n-def all_equal(left, right, cache=None):\n-    if isinstance(left, list):\n-        if not isinstance(right, list):\n-            return False\n-        for a, b in zip(left, right):\n-            if not all_equal(a, b, cache=cache):\n-                return False\n-        return True\n-\n-    if hasattr(left, 'equals'):\n-        return left.equals(right, cache=cache)\n-    return left == right\n-\n-\n-def _arg_getter(i, doc=None):\n-    def arg_accessor(self):\n-        return self.args[i]\n-    return property(arg_accessor, doc=doc)\n-\n-\n-class ValueOp(Node):\n-\n-    def __init__(self, *args):\n-        super(ValueOp, self).__init__(args)\n-\n-    def root_tables(self):\n-        exprs = [arg for arg in self.args if isinstance(arg, Expr)]\n-        return distinct_roots(*exprs)\n-\n-    def resolve_name(self):\n-        raise com.ExpressionError('Expression is not named: %s' % repr(self))\n-\n-    def has_resolved_name(self):\n-        return False\n-\n-\n-class TableColumn(ValueOp):\n-\n-    \"\"\"\n-    Selects a column from a TableExpr\n-    \"\"\"\n-\n-    def __init__(self, name, table_expr):\n-        schema = table_expr.schema()\n-        if isinstance(name, six.integer_types):\n-            name = schema.name_at_position(name)\n-\n-        super(TableColumn, self).__init__(name, table_expr)\n-        if name not in schema:\n-            raise com.IbisTypeError(\n-                \"'{0}' is not a field in {1}\".format(name, table_expr.columns)\n-            )\n-\n-        self.name = name\n-        self.table = table_expr\n-\n-    def parent(self):\n-        return self.table\n-\n-    def resolve_name(self):\n-        return self.name\n-\n-    def has_resolved_name(self):\n-        return True\n-\n-    def root_tables(self):\n-        return self.table._root_tables()\n-\n-    def _make_expr(self):\n-        ctype = self.table._get_type(self.name)\n-        klass = ctype.array_type()\n-        return klass(self, name=self.name)\n-\n-\n-class ExpressionList(Node):\n-\n-    def __init__(self, exprs):\n-        exprs = [as_value_expr(x) for x in exprs]\n-        Node.__init__(self, exprs)\n-\n-    def root_tables(self):\n-        return distinct_roots(*self.args)\n-\n-    def output_type(self):\n-        return ExprList\n-\n-\n class ExprList(Expr):\n",
        "source_code_with_indent": "\n<DED>def _safe_repr(x, memo=None):\n    <IND>return x._repr(memo=memo) if isinstance(x, (Expr, Node)) else repr(x)\n\n\n<DED>class OperationMeta(type):\n\n    <IND>def __new__(cls, name, parents, dct):\n        <IND>if 'input_type' in dct:\n            <IND>from ibis.expr.rules import TypeSignature, signature\n            sig = dct['input_type']\n            if not isinstance(sig, TypeSignature):\n                <IND>dct['input_type'] = sig = signature(sig)\n\n                for i, t in enumerate(sig.types):\n                    <IND>if t.name is None:\n                        <IND>continue\n\n                    <DED>if t.name not in dct:\n                        <IND>dct[t.name] = _arg_getter(i, doc=t.doc)\n\n        <DED><DED><DED><DED>return super(OperationMeta, cls).__new__(cls, name, parents, dct)\n\n\n<DED><DED>class Node(six.with_metaclass(OperationMeta, object)):\n\n    <IND>\"\"\"\n    Node is the base class for all relational algebra and analytical\n    functionality. It transforms the input expressions into an output\n    expression.\n\n    Each node implementation is responsible for validating the inputs,\n    including any type promotion and / or casting issues, and producing a\n    well-typed expression\n\n    Note that Node is deliberately not made an expression subclass: think\n    of Node as merely a typed expression builder.\n    \"\"\"\n\n    def __init__(self, args=None):\n        <IND>args = args or []\n        self.args = self._validate_args(args)\n\n    <DED>def _validate_args(self, args):\n        <IND>if not hasattr(self, 'input_type'):\n            <IND>return args\n\n        <DED>return self.input_type.validate(args)\n\n    <DED>def __repr__(self):\n        <IND>return self._repr()\n\n    <DED>def _repr(self, memo=None):\n        <IND>if memo is None:\n            <IND>from ibis.expr.format import FormatMemo\n            memo = FormatMemo()\n\n        <DED>opname = type(self).__name__\n        pprint_args = []\n\n        def _pp(x):\n            <IND>return _safe_repr(x, memo=memo)\n\n        <DED>for x in self.args:\n            <IND>if isinstance(x, (tuple, list)):\n                <IND>pp = repr([_pp(y) for y in x])\n            <DED>else:\n                <IND>pp = _pp(x)\n            <DED>pprint_args.append(pp)\n\n        <DED>return '%s(%s)' % (opname, ', '.join(pprint_args))\n\n    <DED>def blocks(self):\n        # The contents of this node at referentially distinct and may not be\n        # analyzed deeper\n        <IND>return False\n\n    <DED>def flat_args(self):\n        <IND>for arg in self.args:\n            <IND>if not isinstance(arg, six.string_types) and isinstance(\n                arg, collections.Iterable\n            ):\n                <IND>for x in arg:\n                    <IND>yield x\n            <DED><DED>else:\n                <IND>yield arg\n\n    <DED><DED><DED>def equals(self, other, cache=None):\n        <IND>if cache is None:\n            <IND>cache = {}\n\n        <DED>if (self, other) in cache:\n            <IND>return cache[(self, other)]\n\n        <DED>if id(self) == id(other):\n            <IND>cache[(self, other)] = True\n            return True\n\n        <DED>if type(self) != type(other):\n            <IND>cache[(self, other)] = False\n            return False\n\n        <DED>if len(self.args) != len(other.args):\n            <IND>cache[(self, other)] = False\n            return False\n\n        <DED>for left, right in zip(self.args, other.args):\n            <IND>if not all_equal(left, right, cache=cache):\n                <IND>cache[(self, other)] = False\n                return False\n        <DED><DED>cache[(self, other)] = True\n        return True\n\n    <DED>def is_ancestor(self, other):\n        <IND>if isinstance(other, Expr):\n            <IND>other = other.op()\n\n        <DED>return self.equals(other)\n\n    <DED>_expr_cached = None\n\n    def to_expr(self):\n        <IND>if self._expr_cached is None:\n            <IND>self._expr_cached = self._make_expr()\n        <DED>return self._expr_cached\n\n    <DED>def _make_expr(self):\n        <IND>klass = self.output_type()\n        return klass(self)\n\n    <DED>def output_type(self):\n        <IND>\"\"\"\n        This function must resolve the output type of the expression and return\n        the node wrapped in the appropriate ValueExpr type.\n        \"\"\"\n        raise NotImplementedError\n\n    <DED>@property\n    def _arg_names(self):\n        <IND>try:\n            <IND>input_type = self.__class__.input_type\n        <DED>except AttributeError:\n            <IND>return []\n        <DED>else:\n            <IND>return [t.name for t in getattr(input_type, 'types', [])]\n\n\n<DED><DED><DED>def all_equal(left, right, cache=None):\n    <IND>if isinstance(left, list):\n        <IND>if not isinstance(right, list):\n            <IND>return False\n        <DED>for a, b in zip(left, right):\n            <IND>if not all_equal(a, b, cache=cache):\n                <IND>return False\n        <DED><DED>return True\n\n    <DED>if hasattr(left, 'equals'):\n        <IND>return left.equals(right, cache=cache)\n    <DED>return left == right\n\n\n<DED>def _arg_getter(i, doc=None):\n    <IND>def arg_accessor(self):\n        <IND>return self.args[i]\n    <DED>return property(arg_accessor, doc=doc)\n\n\n<DED>class ValueOp(Node):\n\n    <IND>def __init__(self, *args):\n        <IND>super(ValueOp, self).__init__(args)\n\n    <DED>def root_tables(self):\n        <IND>exprs = [arg for arg in self.args if isinstance(arg, Expr)]\n        return distinct_roots(*exprs)\n\n    <DED>def resolve_name(self):\n        <IND>raise com.ExpressionError('Expression is not named: %s' % repr(self))\n\n    <DED>def has_resolved_name(self):\n        <IND>return False\n\n\n<DED><DED>class TableColumn(ValueOp):\n\n    <IND>\"\"\"\n    Selects a column from a TableExpr\n    \"\"\"\n\n    def __init__(self, name, table_expr):\n        <IND>schema = table_expr.schema()\n        if isinstance(name, six.integer_types):\n            <IND>name = schema.name_at_position(name)\n\n        <DED>super(TableColumn, self).__init__(name, table_expr)\n        if name not in schema:\n            <IND>raise com.IbisTypeError(\n                \"'{0}' is not a field in {1}\".format(name, table_expr.columns)\n            )\n\n        <DED>self.name = name\n        self.table = table_expr\n\n    <DED>def parent(self):\n        <IND>return self.table\n\n    <DED>def resolve_name(self):\n        <IND>return self.name\n\n    <DED>def has_resolved_name(self):\n        <IND>return True\n\n    <DED>def root_tables(self):\n        <IND>return self.table._root_tables()\n\n    <DED>def _make_expr(self):\n        <IND>ctype = self.table._get_type(self.name)\n        klass = ctype.array_type()\n        return klass(self, name=self.name)\n\n\n<DED><DED>class ExpressionList(Node):\n\n    <IND>def __init__(self, exprs):\n        <IND>exprs = [as_value_expr(x) for x in exprs]\n        Node.__init__(self, exprs)\n\n    <DED>def root_tables(self):\n        <IND>return distinct_roots(*self.args)\n\n    <DED>def output_type(self):\n        <IND>return ExprList\n\n\n<DED><DED>class ExprList(Expr):\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n<DED>class ExprList(Expr):\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "            exprs.extend(o.exprs())\n        return ExpressionList(exprs).to_expr()\n\n\ndef infer_literal_type(value):\n    # TODO: depricate?\n    if value is null:\n        return dt.null\n\n    return dt.infer(value)\n\n\nclass Literal(ValueOp):\n\n    def __init__(self, value, type=None):\n        super(Literal, self).__init__(value, type)\n        self.value = value\n        self._output_type = type.scalar_type()\n\n    def __repr__(self):\n        return '{}({})'.format(\n            type(self).__name__,\n            ', '.join(map(repr, self.args))\n        )\n\n    def equals(self, other, cache=None):\n        return (\n            isinstance(other, Literal) and\n            isinstance(other.value, type(self.value)) and\n            self.value == other.value\n        )\n\n    def output_type(self):\n        return self._output_type\n\n    def root_tables(self):\n        return []\n\n\nclass ScalarParameter(ValueOp):\n\n    parameter_counter = itertools.count()\n\n    def __init__(self, type):\n        super(ScalarParameter, self).__init__(type)\n        self.output_type = type.scalar_type\n        self.counter = next(self.__class__.parameter_counter)\n\n    def resolve_name(self):\n        return 'param_{:d}'.format(self.counter)\n\n    def __repr__(self):\n        return '{}(type={})'.format(type(self).__name__, self.type)\n\n    def __hash__(self):\n        return hash((self.type, self.counter))\n\n    @property\n    def type(self):\n        return self.args[0]\n\n    def equals(self, other, cache=None):\n        return (\n            isinstance(other, ScalarParameter) and\n            self.counter == other.counter and\n            self.type.equals(other.type, cache=cache)\n        )\n\n    def root_tables(self):\n        return []\n\n\ndef param(type):\n    \"\"\"Create a parameter of a particular type to be defined just before\n    execution.\n\n    Parameters\n    ----------\n    type : dt.DataType\n        The type of the unbound parameter, e.g., double, int64, date, etc.\n\n    Returns\n    -------\n    ScalarExpr\n\n    Examples\n    --------\n    >>> import ibis\n    >>> import ibis.expr.datatypes as dt\n    >>> start = ibis.param(dt.date)\n    >>> end = ibis.param(dt.date)\n    >>> schema = [('timestamp_col', 'timestamp'), ('value', 'double')]\n    >>> t = ibis.table(schema)\n    >>> predicates = [t.timestamp_col >= start, t.timestamp_col <= end]\n    >>> expr = t.filter(predicates).value.sum()\n    \"\"\"\n    expr = ScalarParameter(dt.dtype(type)).to_expr()\n    return expr\n\n\ndef distinct_roots(*expressions):\n    roots = toolz.concat(\n        expression._root_tables() for expression in expressions\n    )\n    return list(toolz.unique(roots, key=id))\n\n",
        "source_code_len": 2614,
        "target_code": "            exprs.extend(o.exprs())\n        return ops.ExpressionList(exprs).to_expr()\n\n",
        "target_code_len": 88,
        "diff_format": "@@ -511,106 +267,3 @@\n             exprs.extend(o.exprs())\n-        return ExpressionList(exprs).to_expr()\n-\n-\n-def infer_literal_type(value):\n-    # TODO: depricate?\n-    if value is null:\n-        return dt.null\n-\n-    return dt.infer(value)\n-\n-\n-class Literal(ValueOp):\n-\n-    def __init__(self, value, type=None):\n-        super(Literal, self).__init__(value, type)\n-        self.value = value\n-        self._output_type = type.scalar_type()\n-\n-    def __repr__(self):\n-        return '{}({})'.format(\n-            type(self).__name__,\n-            ', '.join(map(repr, self.args))\n-        )\n-\n-    def equals(self, other, cache=None):\n-        return (\n-            isinstance(other, Literal) and\n-            isinstance(other.value, type(self.value)) and\n-            self.value == other.value\n-        )\n-\n-    def output_type(self):\n-        return self._output_type\n-\n-    def root_tables(self):\n-        return []\n-\n-\n-class ScalarParameter(ValueOp):\n-\n-    parameter_counter = itertools.count()\n-\n-    def __init__(self, type):\n-        super(ScalarParameter, self).__init__(type)\n-        self.output_type = type.scalar_type\n-        self.counter = next(self.__class__.parameter_counter)\n-\n-    def resolve_name(self):\n-        return 'param_{:d}'.format(self.counter)\n-\n-    def __repr__(self):\n-        return '{}(type={})'.format(type(self).__name__, self.type)\n-\n-    def __hash__(self):\n-        return hash((self.type, self.counter))\n-\n-    @property\n-    def type(self):\n-        return self.args[0]\n-\n-    def equals(self, other, cache=None):\n-        return (\n-            isinstance(other, ScalarParameter) and\n-            self.counter == other.counter and\n-            self.type.equals(other.type, cache=cache)\n-        )\n-\n-    def root_tables(self):\n-        return []\n-\n-\n-def param(type):\n-    \"\"\"Create a parameter of a particular type to be defined just before\n-    execution.\n-\n-    Parameters\n-    ----------\n-    type : dt.DataType\n-        The type of the unbound parameter, e.g., double, int64, date, etc.\n-\n-    Returns\n-    -------\n-    ScalarExpr\n-\n-    Examples\n-    --------\n-    >>> import ibis\n-    >>> import ibis.expr.datatypes as dt\n-    >>> start = ibis.param(dt.date)\n-    >>> end = ibis.param(dt.date)\n-    >>> schema = [('timestamp_col', 'timestamp'), ('value', 'double')]\n-    >>> t = ibis.table(schema)\n-    >>> predicates = [t.timestamp_col >= start, t.timestamp_col <= end]\n-    >>> expr = t.filter(predicates).value.sum()\n-    \"\"\"\n-    expr = ScalarParameter(dt.dtype(type)).to_expr()\n-    return expr\n-\n-\n-def distinct_roots(*expressions):\n-    roots = toolz.concat(\n-        expression._root_tables() for expression in expressions\n-    )\n-    return list(toolz.unique(roots, key=id))\n+        return ops.ExpressionList(exprs).to_expr()\n \n",
        "source_code_with_indent": "            <DED>exprs.extend(o.exprs())\n        <DED>return ExpressionList(exprs).to_expr()\n\n\n<DED><DED>def infer_literal_type(value):\n    # TODO: depricate?\n    <IND>if value is null:\n        <IND>return dt.null\n\n    <DED>return dt.infer(value)\n\n\n<DED>class Literal(ValueOp):\n\n    <IND>def __init__(self, value, type=None):\n        <IND>super(Literal, self).__init__(value, type)\n        self.value = value\n        self._output_type = type.scalar_type()\n\n    <DED>def __repr__(self):\n        <IND>return '{}({})'.format(\n            type(self).__name__,\n            ', '.join(map(repr, self.args))\n        )\n\n    <DED>def equals(self, other, cache=None):\n        <IND>return (\n            isinstance(other, Literal) and\n            isinstance(other.value, type(self.value)) and\n            self.value == other.value\n        )\n\n    <DED>def output_type(self):\n        <IND>return self._output_type\n\n    <DED>def root_tables(self):\n        <IND>return []\n\n\n<DED><DED>class ScalarParameter(ValueOp):\n\n    <IND>parameter_counter = itertools.count()\n\n    def __init__(self, type):\n        <IND>super(ScalarParameter, self).__init__(type)\n        self.output_type = type.scalar_type\n        self.counter = next(self.__class__.parameter_counter)\n\n    <DED>def resolve_name(self):\n        <IND>return 'param_{:d}'.format(self.counter)\n\n    <DED>def __repr__(self):\n        <IND>return '{}(type={})'.format(type(self).__name__, self.type)\n\n    <DED>def __hash__(self):\n        <IND>return hash((self.type, self.counter))\n\n    <DED>@property\n    def type(self):\n        <IND>return self.args[0]\n\n    <DED>def equals(self, other, cache=None):\n        <IND>return (\n            isinstance(other, ScalarParameter) and\n            self.counter == other.counter and\n            self.type.equals(other.type, cache=cache)\n        )\n\n    <DED>def root_tables(self):\n        <IND>return []\n\n\n<DED><DED>def param(type):\n    <IND>\"\"\"Create a parameter of a particular type to be defined just before\n    execution.\n\n    Parameters\n    ----------\n    type : dt.DataType\n        The type of the unbound parameter, e.g., double, int64, date, etc.\n\n    Returns\n    -------\n    ScalarExpr\n\n    Examples\n    --------\n    >>> import ibis\n    >>> import ibis.expr.datatypes as dt\n    >>> start = ibis.param(dt.date)\n    >>> end = ibis.param(dt.date)\n    >>> schema = [('timestamp_col', 'timestamp'), ('value', 'double')]\n    >>> t = ibis.table(schema)\n    >>> predicates = [t.timestamp_col >= start, t.timestamp_col <= end]\n    >>> expr = t.filter(predicates).value.sum()\n    \"\"\"\n    expr = ScalarParameter(dt.dtype(type)).to_expr()\n    return expr\n\n\n<DED>def distinct_roots(*expressions):\n    <IND>roots = toolz.concat(\n        expression._root_tables() for expression in expressions\n    )\n    return list(toolz.unique(roots, key=id))\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "            <DED>exprs.extend(o.exprs())\n        <DED>return ops.ExpressionList(exprs).to_expr()\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    \"\"\"\n    return ValueList(values).to_expr()\n\n\nclass NullLiteral(ValueOp):\n\n    \"\"\"\n    Typeless NULL literal\n    \"\"\"\n\n    def __init__(self):\n        self.value = None\n\n    @property\n    def args(self):\n        return [self.value]\n\n    def equals(self, other, cache=None):\n        return isinstance(other, NullLiteral)\n\n    def output_type(self):\n        return NullScalar\n\n    def root_tables(self):\n        return []\n\n\nclass ListExpr(ColumnExpr, AnyValue):\n\n    @property\n    def values(self):\n        return self.op().values\n\n    def __iter__(self):\n        return iter(self.values)\n\n    def __getitem__(self, key):\n        return self.values[key]\n\n    def __add__(self, other):\n        other_values = getattr(other, 'values', other)\n        return type(self.op())(self.values + other_values).to_expr()\n\n    def __radd__(self, other):\n        other_values = getattr(other, 'values', other)\n        return type(self.op())(other_values + self.values).to_expr()\n\n    def __bool__(self):\n        return bool(self.values)\n\n    def __len__(self):\n        return len(self.values)\n\n    def type(self):\n        from ibis.expr import rules\n        return rules.highest_precedence_type(self.values)\n\n\nclass SortExpr(Expr):\n\n    def _type_display(self):\n        return 'array-sort'\n\n\nclass ValueList(ValueOp):\n\n    \"\"\"\n    Data structure for a list of value expressions\n    \"\"\"\n\n    def __init__(self, args):\n        self.values = list(map(as_value_expr, args))\n        super(ValueList, self).__init__(self.values)\n\n    def root_tables(self):\n        return distinct_roots(*self.values)\n\n    def _make_expr(self):\n        return ListExpr(self)\n\n\ndef bind_expr(table, expr):\n    if isinstance(expr, (list, tuple)):\n        return [bind_expr(table, x) for x in expr]\n\n    return table._ensure_expr(expr)\n\n\ndef find_base_table(expr):\n    if isinstance(expr, TableExpr):\n        return expr\n\n    for arg in expr.op().flat_args():\n        if isinstance(arg, Expr):\n            r = find_base_table(arg)\n            if isinstance(r, TableExpr):\n                return r\n",
        "source_code_len": 2057,
        "target_code": "    \"\"\"\n    import ibis.expr.operations as ops\n\n    return ops.ValueList(values).to_expr()\n\n\ndef as_value_expr(val):\n    import pandas as pd\n    if not isinstance(val, Expr):\n        if isinstance(val, (tuple, list)):\n            val = sequence(val)\n        elif isinstance(val, pd.Series):\n            val = sequence(list(val))\n        else:\n            val = literal(val)\n\n    return val\n\n\ndef param(type):\n    \"\"\"Create a parameter of a particular type to be defined just before\n    execution.\n\n    Parameters\n    ----------\n    type : dt.DataType\n        The type of the unbound parameter, e.g., double, int64, date, etc.\n\n    Returns\n    -------\n    ScalarExpr\n\n    Examples\n    --------\n    >>> import ibis\n    >>> import ibis.expr.datatypes as dt\n    >>> start = ibis.param(dt.date)\n    >>> end = ibis.param(dt.date)\n    >>> schema = [('timestamp_col', 'timestamp'), ('value', 'double')]\n    >>> t = ibis.table(schema)\n    >>> predicates = [t.timestamp_col >= start, t.timestamp_col <= end]\n    >>> expr = t.filter(predicates).value.sum()\n    \"\"\"\n    import ibis.expr.datatypes as dt\n    import ibis.expr.operations as ops\n    return ops.ScalarParameter(dt.dtype(type)).to_expr()\n\n\nclass UnnamedMarker(object):\n    pass\n\n\nunnamed = UnnamedMarker()\n",
        "target_code_len": 1255,
        "diff_format": "@@ -1471,97 +857,53 @@\n     \"\"\"\n-    return ValueList(values).to_expr()\n-\n-\n-class NullLiteral(ValueOp):\n-\n+    import ibis.expr.operations as ops\n+\n+    return ops.ValueList(values).to_expr()\n+\n+\n+def as_value_expr(val):\n+    import pandas as pd\n+    if not isinstance(val, Expr):\n+        if isinstance(val, (tuple, list)):\n+            val = sequence(val)\n+        elif isinstance(val, pd.Series):\n+            val = sequence(list(val))\n+        else:\n+            val = literal(val)\n+\n+    return val\n+\n+\n+def param(type):\n+    \"\"\"Create a parameter of a particular type to be defined just before\n+    execution.\n+\n+    Parameters\n+    ----------\n+    type : dt.DataType\n+        The type of the unbound parameter, e.g., double, int64, date, etc.\n+\n+    Returns\n+    -------\n+    ScalarExpr\n+\n+    Examples\n+    --------\n+    >>> import ibis\n+    >>> import ibis.expr.datatypes as dt\n+    >>> start = ibis.param(dt.date)\n+    >>> end = ibis.param(dt.date)\n+    >>> schema = [('timestamp_col', 'timestamp'), ('value', 'double')]\n+    >>> t = ibis.table(schema)\n+    >>> predicates = [t.timestamp_col >= start, t.timestamp_col <= end]\n+    >>> expr = t.filter(predicates).value.sum()\n     \"\"\"\n-    Typeless NULL literal\n-    \"\"\"\n-\n-    def __init__(self):\n-        self.value = None\n-\n-    @property\n-    def args(self):\n-        return [self.value]\n-\n-    def equals(self, other, cache=None):\n-        return isinstance(other, NullLiteral)\n-\n-    def output_type(self):\n-        return NullScalar\n-\n-    def root_tables(self):\n-        return []\n-\n-\n-class ListExpr(ColumnExpr, AnyValue):\n-\n-    @property\n-    def values(self):\n-        return self.op().values\n-\n-    def __iter__(self):\n-        return iter(self.values)\n-\n-    def __getitem__(self, key):\n-        return self.values[key]\n-\n-    def __add__(self, other):\n-        other_values = getattr(other, 'values', other)\n-        return type(self.op())(self.values + other_values).to_expr()\n-\n-    def __radd__(self, other):\n-        other_values = getattr(other, 'values', other)\n-        return type(self.op())(other_values + self.values).to_expr()\n-\n-    def __bool__(self):\n-        return bool(self.values)\n-\n-    def __len__(self):\n-        return len(self.values)\n-\n-    def type(self):\n-        from ibis.expr import rules\n-        return rules.highest_precedence_type(self.values)\n-\n-\n-class SortExpr(Expr):\n-\n-    def _type_display(self):\n-        return 'array-sort'\n-\n-\n-class ValueList(ValueOp):\n-\n-    \"\"\"\n-    Data structure for a list of value expressions\n-    \"\"\"\n-\n-    def __init__(self, args):\n-        self.values = list(map(as_value_expr, args))\n-        super(ValueList, self).__init__(self.values)\n-\n-    def root_tables(self):\n-        return distinct_roots(*self.values)\n-\n-    def _make_expr(self):\n-        return ListExpr(self)\n-\n-\n-def bind_expr(table, expr):\n-    if isinstance(expr, (list, tuple)):\n-        return [bind_expr(table, x) for x in expr]\n-\n-    return table._ensure_expr(expr)\n-\n-\n-def find_base_table(expr):\n-    if isinstance(expr, TableExpr):\n-        return expr\n-\n-    for arg in expr.op().flat_args():\n-        if isinstance(arg, Expr):\n-            r = find_base_table(arg)\n-            if isinstance(r, TableExpr):\n-                return r\n+    import ibis.expr.datatypes as dt\n+    import ibis.expr.operations as ops\n+    return ops.ScalarParameter(dt.dtype(type)).to_expr()\n+\n+\n+class UnnamedMarker(object):\n+    pass\n+\n+\n+unnamed = UnnamedMarker()\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\n    return ValueList(values).to_expr()\n\n\n<DED>class NullLiteral(ValueOp):\n\n    <IND>\"\"\"\n    Typeless NULL literal\n    \"\"\"\n\n    def __init__(self):\n        <IND>self.value = None\n\n    <DED>@property\n    def args(self):\n        <IND>return [self.value]\n\n    <DED>def equals(self, other, cache=None):\n        <IND>return isinstance(other, NullLiteral)\n\n    <DED>def output_type(self):\n        <IND>return NullScalar\n\n    <DED>def root_tables(self):\n        <IND>return []\n\n\n<DED><DED>class ListExpr(ColumnExpr, AnyValue):\n\n    <IND>@property\n    def values(self):\n        <IND>return self.op().values\n\n    <DED>def __iter__(self):\n        <IND>return iter(self.values)\n\n    <DED>def __getitem__(self, key):\n        <IND>return self.values[key]\n\n    <DED>def __add__(self, other):\n        <IND>other_values = getattr(other, 'values', other)\n        return type(self.op())(self.values + other_values).to_expr()\n\n    <DED>def __radd__(self, other):\n        <IND>other_values = getattr(other, 'values', other)\n        return type(self.op())(other_values + self.values).to_expr()\n\n    <DED>def __bool__(self):\n        <IND>return bool(self.values)\n\n    <DED>def __len__(self):\n        <IND>return len(self.values)\n\n    <DED>def type(self):\n        <IND>from ibis.expr import rules\n        return rules.highest_precedence_type(self.values)\n\n\n<DED><DED>class SortExpr(Expr):\n\n    <IND>def _type_display(self):\n        <IND>return 'array-sort'\n\n\n<DED><DED>class ValueList(ValueOp):\n\n    <IND>\"\"\"\n    Data structure for a list of value expressions\n    \"\"\"\n\n    def __init__(self, args):\n        <IND>self.values = list(map(as_value_expr, args))\n        super(ValueList, self).__init__(self.values)\n\n    <DED>def root_tables(self):\n        <IND>return distinct_roots(*self.values)\n\n    <DED>def _make_expr(self):\n        <IND>return ListExpr(self)\n\n\n<DED><DED>def bind_expr(table, expr):\n    <IND>if isinstance(expr, (list, tuple)):\n        <IND>return [bind_expr(table, x) for x in expr]\n\n    <DED>return table._ensure_expr(expr)\n\n\n<DED>def find_base_table(expr):\n    <IND>if isinstance(expr, TableExpr):\n        <IND>return expr\n\n    <DED>for arg in expr.op().flat_args():\n        <IND>if isinstance(arg, Expr):\n            <IND>r = find_base_table(arg)\n            if isinstance(r, TableExpr):\n                <IND>return r\n",
        "target_code_with_indent": "\n    import ibis.expr.operations as ops\n\n    return ops.ValueList(values).to_expr()\n\n\n<DED>def as_value_expr(val):\n    <IND>import pandas as pd\n    if not isinstance(val, Expr):\n        <IND>if isinstance(val, (tuple, list)):\n            <IND>val = sequence(val)\n        <DED>elif isinstance(val, pd.Series):\n            <IND>val = sequence(list(val))\n        <DED>else:\n            <IND>val = literal(val)\n\n    <DED><DED>return val\n\n\n<DED>def param(type):\n    <IND>\"\"\"Create a parameter of a particular type to be defined just before\n    execution.\n\n    Parameters\n    ----------\n    type : dt.DataType\n        The type of the unbound parameter, e.g., double, int64, date, etc.\n\n    Returns\n    -------\n    ScalarExpr\n\n    Examples\n    --------\n    >>> import ibis\n    >>> import ibis.expr.datatypes as dt\n    >>> start = ibis.param(dt.date)\n    >>> end = ibis.param(dt.date)\n    >>> schema = [('timestamp_col', 'timestamp'), ('value', 'double')]\n    >>> t = ibis.table(schema)\n    >>> predicates = [t.timestamp_col >= start, t.timestamp_col <= end]\n    >>> expr = t.filter(predicates).value.sum()\n    \"\"\"\n    import ibis.expr.datatypes as dt\n    import ibis.expr.operations as ops\n    return ops.ScalarParameter(dt.dtype(type)).to_expr()\n\n\n<DED>class UnnamedMarker(object):\n    <IND>pass\n\n\n<DED>unnamed = UnnamedMarker()\n"
      }
    ]
  }
]