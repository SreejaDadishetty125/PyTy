[
  {
    "project": "niklasf/python-chess",
    "commit": "86ec01f7ba98d635659bdb5c0afdcb5a7809de85",
    "filename": "chess/__init__.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/niklasf-python-chess/chess/__init__.py",
    "file_hunks_size": 11,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "chess/__init__.py:2455:30 Unsupported operand [58]: `+` is not supported for operand types `str` and `Optional[str]`.",
    "message": " `+` is not supported for operand types `str` and `Optional[str]`.",
    "rule_id": "Unsupported operand [58]",
    "warning_line_no": 2455,
    "warning_line": "                    opcode += ch",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "                        state = \"after_opcode\"\n                elif ch in [\";\", None]:\n                    if opcode:\n",
        "source_code_len": 118,
        "target_code": "                        state = \"after_opcode\"\n                elif ch is None or ch == \";\":\n                    if opcode:\n",
        "target_code_len": 124,
        "diff_format": "@@ -2449,3 +2449,3 @@\n                         state = \"after_opcode\"\n-                elif ch in [\";\", None]:\n+                elif ch is None or ch == \";\":\n                     if opcode:\n",
        "source_code_with_indent": "                        <IND>state = \"after_opcode\"\n                <DED><DED>elif ch in [\";\", None]:\n                    <IND>if opcode:\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "                        <IND>state = \"after_opcode\"\n                <DED><DED>elif ch is None or ch == \";\":\n                    <IND>if opcode:\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "niklasf/python-chess",
    "commit": "86ec01f7ba98d635659bdb5c0afdcb5a7809de85",
    "filename": "chess/__init__.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/niklasf-python-chess/chess/__init__.py",
    "file_hunks_size": 11,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "chess/__init__.py:2459:21 Incompatible parameter type [6]: Expected `str` for 1st positional only parameter to call `str.__contains__` but got `Optional[str]`.",
    "message": " Expected `str` for 1st positional only parameter to call `str.__contains__` but got `Optional[str]`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 2459,
    "warning_line": "                elif ch in \"+-.0123456789\":",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "                    pass\n                elif ch in \"+-.0123456789\":\n                    operand = ch\n                    state = \"numeric\"\n                elif ch == \"\\\"\":\n                    state = \"string\"\n                elif ch in [\";\", None]:\n                    if opcode:\n",
        "source_code_len": 281,
        "target_code": "                    pass\n                elif ch == \"\\\"\":\n                    state = \"string\"\n                elif ch is None or ch == \";\":\n                    if opcode:\n",
        "target_code_len": 172,
        "diff_format": "@@ -2458,8 +2458,5 @@\n                     pass\n-                elif ch in \"+-.0123456789\":\n-                    operand = ch\n-                    state = \"numeric\"\n                 elif ch == \"\\\"\":\n                     state = \"string\"\n-                elif ch in [\";\", None]:\n+                elif ch is None or ch == \";\":\n                     if opcode:\n",
        "source_code_with_indent": "                    <IND>pass\n                <DED>elif ch in \"+-.0123456789\":\n                    <IND>operand = ch\n                    state = \"numeric\"\n                <DED>elif ch == \"\\\"\":\n                    <IND>state = \"string\"\n                <DED>elif ch in [\";\", None]:\n                    <IND>if opcode:\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "                    <IND>pass\n                <DED>elif ch == \"\\\"\":\n                    <IND>state = \"string\"\n                <DED>elif ch is None or ch == \";\":\n                    <IND>if opcode:\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "niklasf/python-chess",
    "commit": "86ec01f7ba98d635659bdb5c0afdcb5a7809de85",
    "filename": "chess/__init__.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/niklasf-python-chess/chess/__init__.py",
    "file_hunks_size": 11,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "chess/__init__.py:2524:45 Incompatible parameter type [6]: Expected `Union[None, List[Move], float, int, str]` for 2nd positional only parameter to call `dict.__setitem__` but got `Move`.",
    "message": " Expected `Union[None, List[Move], float, int, str]` for 2nd positional only parameter to call `dict.__setitem__` but got `Move`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 2524,
    "warning_line": "                        operations[opcode] = position.parse_xboard(operand)",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n    def _parse_epd_ops(self: BoardT, operation_part: str, make_board: Callable[[], BoardT]) -> Dict[str, Union[None, str, int, float, List[Move]]]:\n        operations = {}  # type: Dict[str, Union[None, str, int, float, List[Move]]]\n        state = \"opcode\"\n",
        "source_code_len": 259,
        "target_code": "\n    def _parse_epd_ops(self: BoardT, operation_part: str, make_board: Callable[[], BoardT]) -> Dict[str, Union[None, str, int, float, Move, List[Move]]]:\n        operations = {}  # type: Dict[str, Union[None, str, int, float, Move, List[Move]]]\n        state = \"opcode\"\n",
        "target_code_len": 271,
        "diff_format": "@@ -2437,4 +2437,4 @@\n \n-    def _parse_epd_ops(self: BoardT, operation_part: str, make_board: Callable[[], BoardT]) -> Dict[str, Union[None, str, int, float, List[Move]]]:\n-        operations = {}  # type: Dict[str, Union[None, str, int, float, List[Move]]]\n+    def _parse_epd_ops(self: BoardT, operation_part: str, make_board: Callable[[], BoardT]) -> Dict[str, Union[None, str, int, float, Move, List[Move]]]:\n+        operations = {}  # type: Dict[str, Union[None, str, int, float, Move, List[Move]]]\n         state = \"opcode\"\n",
        "source_code_with_indent": "\n    <DED>def _parse_epd_ops(self: BoardT, operation_part: str, make_board: Callable[[], BoardT]) -> Dict[str, Union[None, str, int, float, List[Move]]]:\n        <IND>operations = {}  # type: Dict[str, Union[None, str, int, float, List[Move]]]\n        state = \"opcode\"\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n    <DED>def _parse_epd_ops(self: BoardT, operation_part: str, make_board: Callable[[], BoardT]) -> Dict[str, Union[None, str, int, float, Move, List[Move]]]:\n        <IND>operations = {}  # type: Dict[str, Union[None, str, int, float, Move, List[Move]]]\n        state = \"opcode\"\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n    def set_epd(self, epd: str) -> Dict[str, Union[None, str, int, float, List[Move]]]:\n        \"\"\"\n",
        "source_code_len": 101,
        "target_code": "\n    def set_epd(self, epd: str) -> Dict[str, Union[None, str, int, float, Move, List[Move]]]:\n        \"\"\"\n",
        "target_code_len": 107,
        "diff_format": "@@ -2534,3 +2536,3 @@\n \n-    def set_epd(self, epd: str) -> Dict[str, Union[None, str, int, float, List[Move]]]:\n+    def set_epd(self, epd: str) -> Dict[str, Union[None, str, int, float, Move, List[Move]]]:\n         \"\"\"\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\n    <DED>def set_epd(self, epd: str) -> Dict[str, Union[None, str, int, float, List[Move]]]:\n        <IND>",
        "target_code_with_indent": "\n    <DED>def set_epd(self, epd: str) -> Dict[str, Union[None, str, int, float, Move, List[Move]]]:\n        <IND>"
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    @classmethod\n    def from_epd(cls: Type[BoardT], epd: str, *, chess960: bool = False) -> Tuple[BoardT, Dict[str, Union[None, str, int, float, List[Move]]]]:\n        \"\"\"\n",
        "source_code_len": 173,
        "target_code": "    @classmethod\n    def from_epd(cls: Type[BoardT], epd: str, *, chess960: bool = False) -> Tuple[BoardT, Dict[str, Union[None, str, int, float, Move, List[Move]]]]:\n        \"\"\"\n",
        "target_code_len": 179,
        "diff_format": "@@ -3425,3 +3427,3 @@\n     @classmethod\n-    def from_epd(cls: Type[BoardT], epd: str, *, chess960: bool = False) -> Tuple[BoardT, Dict[str, Union[None, str, int, float, List[Move]]]]:\n+    def from_epd(cls: Type[BoardT], epd: str, *, chess960: bool = False) -> Tuple[BoardT, Dict[str, Union[None, str, int, float, Move, List[Move]]]]:\n         \"\"\"\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "    <DED>@classmethod\n    def from_epd(cls: Type[BoardT], epd: str, *, chess960: bool = False) -> Tuple[BoardT, Dict[str, Union[None, str, int, float, List[Move]]]]:\n        <IND>",
        "target_code_with_indent": "    <DED>@classmethod\n    def from_epd(cls: Type[BoardT], epd: str, *, chess960: bool = False) -> Tuple[BoardT, Dict[str, Union[None, str, int, float, Move, List[Move]]]]:\n        <IND>"
      }
    ]
  }
]