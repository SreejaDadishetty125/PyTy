[
  {
    "project": "bogdandm/json2python-models",
    "commit": "a0d6d831eba0b8b79d3d4ecc6816f8acb4c4f7d8",
    "filename": "rest_client_gen/dynamic_typing/base.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/bogdandm-json2python-models/rest_client_gen/dynamic_typing/base.py",
    "file_hunks_size": 2,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": true,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "rest_client_gen/dynamic_typing/base.py:139:55 Incompatible parameter type [6]: Expected `Iterable[Variable[_T1]]` for 2nd positional only parameter to call `map.__init__` but got `ComplexType`.",
    "message": " Expected `Iterable[Variable[_T1]]` for 2nd positional only parameter to call `map.__init__` but got `ComplexType`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 139,
    "warning_line": "        imports, nested = zip(*map(metadata_to_typing, self))",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": true,
        "has_suppression": false,
        "source_code": "MetaData = Union[type, dict, BaseType]\n\n\nclass SingleType(BaseType):\n    __slots__ = [\"type\"]\n\n    def __init__(self, t: MetaData):\n        self.type = t\n\n    def __str__(self):\n        return f\"{self.__class__.__name__}[{self.type}]\"\n\n    def __repr__(self):\n        return f\"<{self.__class__.__name__} [{self.type}]>\"\n\n    def __iter__(self) -> Iterable['MetaData']:\n        yield self.type\n\n    def __eq__(self, other):\n        return isinstance(other, self.__class__) and self.type == other.type\n\n    def replace(self, t: 'MetaData', **kwargs) -> 'SingleType':\n        self.type = t\n        return self\n\n\nclass ComplexType(BaseType):\n    __slots__ = [\"_types\"]\n\n    def __init__(self, *types: MetaData):\n        self._types = list(types)\n\n    @property\n    def types(self):\n        return self._types\n\n    @types.setter\n    def types(self, value):\n        self._types = value\n        self._sorted = None\n\n    @property\n    def sorted(self):\n        \"\"\"\n        Getter of cached sorted types list\n        \"\"\"\n        sorted_types = getattr(self, '_sorted', None)\n        if sorted_types is None:\n            sorted_types = sorted(self.types, key=self._sort_key)\n            self._sorted = sorted_types\n        return sorted_types\n\n    def _sort_key(self, item):\n        if hasattr(item, 'keys'):\n            return str(sorted(item.keys()))\n        else:\n            return str(item)\n\n    def __str__(self):\n        items = ', '.join(map(str, self.types))\n        return f\"{self.__class__.__name__}[{items}]\"\n\n    def __repr__(self):\n        items = ', '.join(map(str, self.types))\n        return f\"<{self.__class__.__name__} [{items}]>\"\n\n    def __iter__(self) -> Iterable['MetaData']:\n        yield from self.types\n\n    def __eq__(self, other):\n        return isinstance(other, self.__class__) and self.sorted == other.sorted\n\n    def __len__(self):\n        return len(self.types)\n\n    def replace(self, t: Union['MetaData', List['MetaData']], index=None, **kwargs) -> 'ComplexType':\n        if index is None and isinstance(t, list):\n            self.types = t\n        elif index is not None and not isinstance(t, list):\n            types = self.types\n            types[index] = t\n            # Using property setter here\n            self.types = types\n        else:\n            raise ValueError(f\"Unsupported arguments: t={t} index={index} kwargs={kwargs}\")\n        return self\n\n    def to_typing_code(self) -> Tuple[ImportPathList, str]:\n        imports, nested = zip(*map(metadata_to_typing, self))\n        nested = \", \".join(nested)\n        return (\n            list(chain(*imports)),\n            f\"[{nested}]\"\n        )\n\n\ndef metadata_to_typing(t: MetaData) -> Tuple[ImportPathList, str]:\n    if isclass(t):\n        return ([], t.__name__)\n    elif isinstance(t, dict):\n        raise ValueError(\"Can not convert dict instance to typing code. It should be wrapped into ModelMeta instance\")\n    return t.to_typing_code()\n\n\ndef compile_imports(imports: ImportPathList) -> str:\n    imports_map: Dict[str, Set[str]] = OrderedDict()\n    for module, classes in filter(None, imports):\n        classes_set = imports_map.get(module, set())\n        if isinstance(classes, str):\n            classes_set.add(classes)\n        else:\n            classes_set.update(classes)\n        imports_map[module] = classes_set\n\n    imports_map = OrderedDict(sorted(\n        ((module, sorted(classes)) for module, classes in imports_map.items()),\n        key=operator.itemgetter(0)\n    ))\n\n    imports_map_joined = OrderedDict()\n    for module, classes in imports_map.items():\n        imports_map_joined[module] = \", \".join(classes)\n\n    return \"\\n\".join(f\"from {module} import {classes}\" for module, classes in imports_map_joined.items())\n",
        "source_code_len": 3721,
        "target_code": "MetaData = Union[type, dict, BaseType]\n",
        "target_code_len": 39,
        "diff_format": "@@ -51,124 +47,1 @@\n MetaData = Union[type, dict, BaseType]\n-\n-\n-class SingleType(BaseType):\n-    __slots__ = [\"type\"]\n-\n-    def __init__(self, t: MetaData):\n-        self.type = t\n-\n-    def __str__(self):\n-        return f\"{self.__class__.__name__}[{self.type}]\"\n-\n-    def __repr__(self):\n-        return f\"<{self.__class__.__name__} [{self.type}]>\"\n-\n-    def __iter__(self) -> Iterable['MetaData']:\n-        yield self.type\n-\n-    def __eq__(self, other):\n-        return isinstance(other, self.__class__) and self.type == other.type\n-\n-    def replace(self, t: 'MetaData', **kwargs) -> 'SingleType':\n-        self.type = t\n-        return self\n-\n-\n-class ComplexType(BaseType):\n-    __slots__ = [\"_types\"]\n-\n-    def __init__(self, *types: MetaData):\n-        self._types = list(types)\n-\n-    @property\n-    def types(self):\n-        return self._types\n-\n-    @types.setter\n-    def types(self, value):\n-        self._types = value\n-        self._sorted = None\n-\n-    @property\n-    def sorted(self):\n-        \"\"\"\n-        Getter of cached sorted types list\n-        \"\"\"\n-        sorted_types = getattr(self, '_sorted', None)\n-        if sorted_types is None:\n-            sorted_types = sorted(self.types, key=self._sort_key)\n-            self._sorted = sorted_types\n-        return sorted_types\n-\n-    def _sort_key(self, item):\n-        if hasattr(item, 'keys'):\n-            return str(sorted(item.keys()))\n-        else:\n-            return str(item)\n-\n-    def __str__(self):\n-        items = ', '.join(map(str, self.types))\n-        return f\"{self.__class__.__name__}[{items}]\"\n-\n-    def __repr__(self):\n-        items = ', '.join(map(str, self.types))\n-        return f\"<{self.__class__.__name__} [{items}]>\"\n-\n-    def __iter__(self) -> Iterable['MetaData']:\n-        yield from self.types\n-\n-    def __eq__(self, other):\n-        return isinstance(other, self.__class__) and self.sorted == other.sorted\n-\n-    def __len__(self):\n-        return len(self.types)\n-\n-    def replace(self, t: Union['MetaData', List['MetaData']], index=None, **kwargs) -> 'ComplexType':\n-        if index is None and isinstance(t, list):\n-            self.types = t\n-        elif index is not None and not isinstance(t, list):\n-            types = self.types\n-            types[index] = t\n-            # Using property setter here\n-            self.types = types\n-        else:\n-            raise ValueError(f\"Unsupported arguments: t={t} index={index} kwargs={kwargs}\")\n-        return self\n-\n-    def to_typing_code(self) -> Tuple[ImportPathList, str]:\n-        imports, nested = zip(*map(metadata_to_typing, self))\n-        nested = \", \".join(nested)\n-        return (\n-            list(chain(*imports)),\n-            f\"[{nested}]\"\n-        )\n-\n-\n-def metadata_to_typing(t: MetaData) -> Tuple[ImportPathList, str]:\n-    if isclass(t):\n-        return ([], t.__name__)\n-    elif isinstance(t, dict):\n-        raise ValueError(\"Can not convert dict instance to typing code. It should be wrapped into ModelMeta instance\")\n-    return t.to_typing_code()\n-\n-\n-def compile_imports(imports: ImportPathList) -> str:\n-    imports_map: Dict[str, Set[str]] = OrderedDict()\n-    for module, classes in filter(None, imports):\n-        classes_set = imports_map.get(module, set())\n-        if isinstance(classes, str):\n-            classes_set.add(classes)\n-        else:\n-            classes_set.update(classes)\n-        imports_map[module] = classes_set\n-\n-    imports_map = OrderedDict(sorted(\n-        ((module, sorted(classes)) for module, classes in imports_map.items()),\n-        key=operator.itemgetter(0)\n-    ))\n-\n-    imports_map_joined = OrderedDict()\n-    for module, classes in imports_map.items():\n-        imports_map_joined[module] = \", \".join(classes)\n-\n-    return \"\\n\".join(f\"from {module} import {classes}\" for module, classes in imports_map_joined.items())\n",
        "source_code_with_indent": "MetaData = Union[type, dict, BaseType]\n\n\nclass SingleType(BaseType):\n    <IND>__slots__ = [\"type\"]\n\n    def __init__(self, t: MetaData):\n        <IND>self.type = t\n\n    <DED>def __str__(self):\n        <IND>return f\"{self.__class__.__name__}[{self.type}]\"\n\n    <DED>def __repr__(self):\n        <IND>return f\"<{self.__class__.__name__} [{self.type}]>\"\n\n    <DED>def __iter__(self) -> Iterable['MetaData']:\n        <IND>yield self.type\n\n    <DED>def __eq__(self, other):\n        <IND>return isinstance(other, self.__class__) and self.type == other.type\n\n    <DED>def replace(self, t: 'MetaData', **kwargs) -> 'SingleType':\n        <IND>self.type = t\n        return self\n\n\n<DED><DED>class ComplexType(BaseType):\n    <IND>__slots__ = [\"_types\"]\n\n    def __init__(self, *types: MetaData):\n        <IND>self._types = list(types)\n\n    <DED>@property\n    def types(self):\n        <IND>return self._types\n\n    <DED>@types.setter\n    def types(self, value):\n        <IND>self._types = value\n        self._sorted = None\n\n    <DED>@property\n    def sorted(self):\n        <IND>\"\"\"\n        Getter of cached sorted types list\n        \"\"\"\n        sorted_types = getattr(self, '_sorted', None)\n        if sorted_types is None:\n            <IND>sorted_types = sorted(self.types, key=self._sort_key)\n            self._sorted = sorted_types\n        <DED>return sorted_types\n\n    <DED>def _sort_key(self, item):\n        <IND>if hasattr(item, 'keys'):\n            <IND>return str(sorted(item.keys()))\n        <DED>else:\n            <IND>return str(item)\n\n    <DED><DED>def __str__(self):\n        <IND>items = ', '.join(map(str, self.types))\n        return f\"{self.__class__.__name__}[{items}]\"\n\n    <DED>def __repr__(self):\n        <IND>items = ', '.join(map(str, self.types))\n        return f\"<{self.__class__.__name__} [{items}]>\"\n\n    <DED>def __iter__(self) -> Iterable['MetaData']:\n        <IND>yield from self.types\n\n    <DED>def __eq__(self, other):\n        <IND>return isinstance(other, self.__class__) and self.sorted == other.sorted\n\n    <DED>def __len__(self):\n        <IND>return len(self.types)\n\n    <DED>def replace(self, t: Union['MetaData', List['MetaData']], index=None, **kwargs) -> 'ComplexType':\n        <IND>if index is None and isinstance(t, list):\n            <IND>self.types = t\n        <DED>elif index is not None and not isinstance(t, list):\n            <IND>types = self.types\n            types[index] = t\n            # Using property setter here\n            self.types = types\n        <DED>else:\n            <IND>raise ValueError(f\"Unsupported arguments: t={t} index={index} kwargs={kwargs}\")\n        <DED>return self\n\n    <DED>def to_typing_code(self) -> Tuple[ImportPathList, str]:\n        <IND>imports, nested = zip(*map(metadata_to_typing, self))\n        nested = \", \".join(nested)\n        return (\n            list(chain(*imports)),\n            f\"[{nested}]\"\n        )\n\n\n<DED><DED>def metadata_to_typing(t: MetaData) -> Tuple[ImportPathList, str]:\n    <IND>if isclass(t):\n        <IND>return ([], t.__name__)\n    <DED>elif isinstance(t, dict):\n        <IND>raise ValueError(\"Can not convert dict instance to typing code. It should be wrapped into ModelMeta instance\")\n    <DED>return t.to_typing_code()\n\n\n<DED>def compile_imports(imports: ImportPathList) -> str:\n    <IND>imports_map: Dict[str, Set[str]] = OrderedDict()\n    for module, classes in filter(None, imports):\n        <IND>classes_set = imports_map.get(module, set())\n        if isinstance(classes, str):\n            <IND>classes_set.add(classes)\n        <DED>else:\n            <IND>classes_set.update(classes)\n        <DED>imports_map[module] = classes_set\n\n    <DED>imports_map = OrderedDict(sorted(\n        ((module, sorted(classes)) for module, classes in imports_map.items()),\n        key=operator.itemgetter(0)\n    ))\n\n    imports_map_joined = OrderedDict()\n    for module, classes in imports_map.items():\n        <IND>imports_map_joined[module] = \", \".join(classes)\n\n    <DED>return \"\\n\".join(f\"from {module} import {classes}\" for module, classes in imports_map_joined.items())\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "MetaData = Union[type, dict, BaseType]\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "bogdandm/json2python-models",
    "commit": "a0d6d831eba0b8b79d3d4ecc6816f8acb4c4f7d8",
    "filename": "rest_client_gen/dynamic_typing/base.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/bogdandm-json2python-models/rest_client_gen/dynamic_typing/base.py",
    "file_hunks_size": 2,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": true,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "rest_client_gen/dynamic_typing/base.py:165:4 Incompatible variable type [9]: imports_map is declared to have type `Dict[str, Set[str]]` but is used as type `OrderedDict[str, List[str]]`.",
    "message": " imports_map is declared to have type `Dict[str, Set[str]]` but is used as type `OrderedDict[str, List[str]]`.",
    "rule_id": "Incompatible variable type [9]",
    "warning_line_no": 165,
    "warning_line": "    imports_map = OrderedDict(sorted(",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": true,
        "has_suppression": false,
        "source_code": "MetaData = Union[type, dict, BaseType]\n\n\nclass SingleType(BaseType):\n    __slots__ = [\"type\"]\n\n    def __init__(self, t: MetaData):\n        self.type = t\n\n    def __str__(self):\n        return f\"{self.__class__.__name__}[{self.type}]\"\n\n    def __repr__(self):\n        return f\"<{self.__class__.__name__} [{self.type}]>\"\n\n    def __iter__(self) -> Iterable['MetaData']:\n        yield self.type\n\n    def __eq__(self, other):\n        return isinstance(other, self.__class__) and self.type == other.type\n\n    def replace(self, t: 'MetaData', **kwargs) -> 'SingleType':\n        self.type = t\n        return self\n\n\nclass ComplexType(BaseType):\n    __slots__ = [\"_types\"]\n\n    def __init__(self, *types: MetaData):\n        self._types = list(types)\n\n    @property\n    def types(self):\n        return self._types\n\n    @types.setter\n    def types(self, value):\n        self._types = value\n        self._sorted = None\n\n    @property\n    def sorted(self):\n        \"\"\"\n        Getter of cached sorted types list\n        \"\"\"\n        sorted_types = getattr(self, '_sorted', None)\n        if sorted_types is None:\n            sorted_types = sorted(self.types, key=self._sort_key)\n            self._sorted = sorted_types\n        return sorted_types\n\n    def _sort_key(self, item):\n        if hasattr(item, 'keys'):\n            return str(sorted(item.keys()))\n        else:\n            return str(item)\n\n    def __str__(self):\n        items = ', '.join(map(str, self.types))\n        return f\"{self.__class__.__name__}[{items}]\"\n\n    def __repr__(self):\n        items = ', '.join(map(str, self.types))\n        return f\"<{self.__class__.__name__} [{items}]>\"\n\n    def __iter__(self) -> Iterable['MetaData']:\n        yield from self.types\n\n    def __eq__(self, other):\n        return isinstance(other, self.__class__) and self.sorted == other.sorted\n\n    def __len__(self):\n        return len(self.types)\n\n    def replace(self, t: Union['MetaData', List['MetaData']], index=None, **kwargs) -> 'ComplexType':\n        if index is None and isinstance(t, list):\n            self.types = t\n        elif index is not None and not isinstance(t, list):\n            types = self.types\n            types[index] = t\n            # Using property setter here\n            self.types = types\n        else:\n            raise ValueError(f\"Unsupported arguments: t={t} index={index} kwargs={kwargs}\")\n        return self\n\n    def to_typing_code(self) -> Tuple[ImportPathList, str]:\n        imports, nested = zip(*map(metadata_to_typing, self))\n        nested = \", \".join(nested)\n        return (\n            list(chain(*imports)),\n            f\"[{nested}]\"\n        )\n\n\ndef metadata_to_typing(t: MetaData) -> Tuple[ImportPathList, str]:\n    if isclass(t):\n        return ([], t.__name__)\n    elif isinstance(t, dict):\n        raise ValueError(\"Can not convert dict instance to typing code. It should be wrapped into ModelMeta instance\")\n    return t.to_typing_code()\n\n\ndef compile_imports(imports: ImportPathList) -> str:\n    imports_map: Dict[str, Set[str]] = OrderedDict()\n    for module, classes in filter(None, imports):\n        classes_set = imports_map.get(module, set())\n        if isinstance(classes, str):\n            classes_set.add(classes)\n        else:\n            classes_set.update(classes)\n        imports_map[module] = classes_set\n\n    imports_map = OrderedDict(sorted(\n        ((module, sorted(classes)) for module, classes in imports_map.items()),\n        key=operator.itemgetter(0)\n    ))\n\n    imports_map_joined = OrderedDict()\n    for module, classes in imports_map.items():\n        imports_map_joined[module] = \", \".join(classes)\n\n    return \"\\n\".join(f\"from {module} import {classes}\" for module, classes in imports_map_joined.items())\n",
        "source_code_len": 3721,
        "target_code": "MetaData = Union[type, dict, BaseType]\n",
        "target_code_len": 39,
        "diff_format": "@@ -51,124 +47,1 @@\n MetaData = Union[type, dict, BaseType]\n-\n-\n-class SingleType(BaseType):\n-    __slots__ = [\"type\"]\n-\n-    def __init__(self, t: MetaData):\n-        self.type = t\n-\n-    def __str__(self):\n-        return f\"{self.__class__.__name__}[{self.type}]\"\n-\n-    def __repr__(self):\n-        return f\"<{self.__class__.__name__} [{self.type}]>\"\n-\n-    def __iter__(self) -> Iterable['MetaData']:\n-        yield self.type\n-\n-    def __eq__(self, other):\n-        return isinstance(other, self.__class__) and self.type == other.type\n-\n-    def replace(self, t: 'MetaData', **kwargs) -> 'SingleType':\n-        self.type = t\n-        return self\n-\n-\n-class ComplexType(BaseType):\n-    __slots__ = [\"_types\"]\n-\n-    def __init__(self, *types: MetaData):\n-        self._types = list(types)\n-\n-    @property\n-    def types(self):\n-        return self._types\n-\n-    @types.setter\n-    def types(self, value):\n-        self._types = value\n-        self._sorted = None\n-\n-    @property\n-    def sorted(self):\n-        \"\"\"\n-        Getter of cached sorted types list\n-        \"\"\"\n-        sorted_types = getattr(self, '_sorted', None)\n-        if sorted_types is None:\n-            sorted_types = sorted(self.types, key=self._sort_key)\n-            self._sorted = sorted_types\n-        return sorted_types\n-\n-    def _sort_key(self, item):\n-        if hasattr(item, 'keys'):\n-            return str(sorted(item.keys()))\n-        else:\n-            return str(item)\n-\n-    def __str__(self):\n-        items = ', '.join(map(str, self.types))\n-        return f\"{self.__class__.__name__}[{items}]\"\n-\n-    def __repr__(self):\n-        items = ', '.join(map(str, self.types))\n-        return f\"<{self.__class__.__name__} [{items}]>\"\n-\n-    def __iter__(self) -> Iterable['MetaData']:\n-        yield from self.types\n-\n-    def __eq__(self, other):\n-        return isinstance(other, self.__class__) and self.sorted == other.sorted\n-\n-    def __len__(self):\n-        return len(self.types)\n-\n-    def replace(self, t: Union['MetaData', List['MetaData']], index=None, **kwargs) -> 'ComplexType':\n-        if index is None and isinstance(t, list):\n-            self.types = t\n-        elif index is not None and not isinstance(t, list):\n-            types = self.types\n-            types[index] = t\n-            # Using property setter here\n-            self.types = types\n-        else:\n-            raise ValueError(f\"Unsupported arguments: t={t} index={index} kwargs={kwargs}\")\n-        return self\n-\n-    def to_typing_code(self) -> Tuple[ImportPathList, str]:\n-        imports, nested = zip(*map(metadata_to_typing, self))\n-        nested = \", \".join(nested)\n-        return (\n-            list(chain(*imports)),\n-            f\"[{nested}]\"\n-        )\n-\n-\n-def metadata_to_typing(t: MetaData) -> Tuple[ImportPathList, str]:\n-    if isclass(t):\n-        return ([], t.__name__)\n-    elif isinstance(t, dict):\n-        raise ValueError(\"Can not convert dict instance to typing code. It should be wrapped into ModelMeta instance\")\n-    return t.to_typing_code()\n-\n-\n-def compile_imports(imports: ImportPathList) -> str:\n-    imports_map: Dict[str, Set[str]] = OrderedDict()\n-    for module, classes in filter(None, imports):\n-        classes_set = imports_map.get(module, set())\n-        if isinstance(classes, str):\n-            classes_set.add(classes)\n-        else:\n-            classes_set.update(classes)\n-        imports_map[module] = classes_set\n-\n-    imports_map = OrderedDict(sorted(\n-        ((module, sorted(classes)) for module, classes in imports_map.items()),\n-        key=operator.itemgetter(0)\n-    ))\n-\n-    imports_map_joined = OrderedDict()\n-    for module, classes in imports_map.items():\n-        imports_map_joined[module] = \", \".join(classes)\n-\n-    return \"\\n\".join(f\"from {module} import {classes}\" for module, classes in imports_map_joined.items())\n",
        "source_code_with_indent": "MetaData = Union[type, dict, BaseType]\n\n\nclass SingleType(BaseType):\n    <IND>__slots__ = [\"type\"]\n\n    def __init__(self, t: MetaData):\n        <IND>self.type = t\n\n    <DED>def __str__(self):\n        <IND>return f\"{self.__class__.__name__}[{self.type}]\"\n\n    <DED>def __repr__(self):\n        <IND>return f\"<{self.__class__.__name__} [{self.type}]>\"\n\n    <DED>def __iter__(self) -> Iterable['MetaData']:\n        <IND>yield self.type\n\n    <DED>def __eq__(self, other):\n        <IND>return isinstance(other, self.__class__) and self.type == other.type\n\n    <DED>def replace(self, t: 'MetaData', **kwargs) -> 'SingleType':\n        <IND>self.type = t\n        return self\n\n\n<DED><DED>class ComplexType(BaseType):\n    <IND>__slots__ = [\"_types\"]\n\n    def __init__(self, *types: MetaData):\n        <IND>self._types = list(types)\n\n    <DED>@property\n    def types(self):\n        <IND>return self._types\n\n    <DED>@types.setter\n    def types(self, value):\n        <IND>self._types = value\n        self._sorted = None\n\n    <DED>@property\n    def sorted(self):\n        <IND>\"\"\"\n        Getter of cached sorted types list\n        \"\"\"\n        sorted_types = getattr(self, '_sorted', None)\n        if sorted_types is None:\n            <IND>sorted_types = sorted(self.types, key=self._sort_key)\n            self._sorted = sorted_types\n        <DED>return sorted_types\n\n    <DED>def _sort_key(self, item):\n        <IND>if hasattr(item, 'keys'):\n            <IND>return str(sorted(item.keys()))\n        <DED>else:\n            <IND>return str(item)\n\n    <DED><DED>def __str__(self):\n        <IND>items = ', '.join(map(str, self.types))\n        return f\"{self.__class__.__name__}[{items}]\"\n\n    <DED>def __repr__(self):\n        <IND>items = ', '.join(map(str, self.types))\n        return f\"<{self.__class__.__name__} [{items}]>\"\n\n    <DED>def __iter__(self) -> Iterable['MetaData']:\n        <IND>yield from self.types\n\n    <DED>def __eq__(self, other):\n        <IND>return isinstance(other, self.__class__) and self.sorted == other.sorted\n\n    <DED>def __len__(self):\n        <IND>return len(self.types)\n\n    <DED>def replace(self, t: Union['MetaData', List['MetaData']], index=None, **kwargs) -> 'ComplexType':\n        <IND>if index is None and isinstance(t, list):\n            <IND>self.types = t\n        <DED>elif index is not None and not isinstance(t, list):\n            <IND>types = self.types\n            types[index] = t\n            # Using property setter here\n            self.types = types\n        <DED>else:\n            <IND>raise ValueError(f\"Unsupported arguments: t={t} index={index} kwargs={kwargs}\")\n        <DED>return self\n\n    <DED>def to_typing_code(self) -> Tuple[ImportPathList, str]:\n        <IND>imports, nested = zip(*map(metadata_to_typing, self))\n        nested = \", \".join(nested)\n        return (\n            list(chain(*imports)),\n            f\"[{nested}]\"\n        )\n\n\n<DED><DED>def metadata_to_typing(t: MetaData) -> Tuple[ImportPathList, str]:\n    <IND>if isclass(t):\n        <IND>return ([], t.__name__)\n    <DED>elif isinstance(t, dict):\n        <IND>raise ValueError(\"Can not convert dict instance to typing code. It should be wrapped into ModelMeta instance\")\n    <DED>return t.to_typing_code()\n\n\n<DED>def compile_imports(imports: ImportPathList) -> str:\n    <IND>imports_map: Dict[str, Set[str]] = OrderedDict()\n    for module, classes in filter(None, imports):\n        <IND>classes_set = imports_map.get(module, set())\n        if isinstance(classes, str):\n            <IND>classes_set.add(classes)\n        <DED>else:\n            <IND>classes_set.update(classes)\n        <DED>imports_map[module] = classes_set\n\n    <DED>imports_map = OrderedDict(sorted(\n        ((module, sorted(classes)) for module, classes in imports_map.items()),\n        key=operator.itemgetter(0)\n    ))\n\n    imports_map_joined = OrderedDict()\n    for module, classes in imports_map.items():\n        <IND>imports_map_joined[module] = \", \".join(classes)\n\n    <DED>return \"\\n\".join(f\"from {module} import {classes}\" for module, classes in imports_map_joined.items())\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "MetaData = Union[type, dict, BaseType]\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  }
]