[
  {
    "project": "aio-libs/aiopg",
    "commit": "187d13a06581054e1f910961b8238837e7c8bd0b",
    "filename": "aiopg/transaction.py",
    "min_patch_found": false,
    "full_warning_msg": "aiopg/transaction.py:60:4 Inconsistent override [15]: `__slots__` overrides attribute defined in `IsolationCompiler` inconsistently. Type `typing.Tuple[]` is not a subtype of the overridden attribute `typing.Tuple[str, str, str]`.",
    "exception": "[Errno 2] No such file or directory: '/home/chowyi/TypeAnnotation_Study/GitHub/aio-libs-aiopg/aiopg/transaction.py'",
    "dd_fail": true
  },
  {
    "project": "aio-libs/aiopg",
    "commit": "187d13a06581054e1f910961b8238837e7c8bd0b",
    "filename": "aiopg/transaction.py",
    "min_patch_found": false,
    "full_warning_msg": "aiopg/transaction.py:67:4 Inconsistent override [15]: `__slots__` overrides attribute defined in `IsolationCompiler` inconsistently. Type `typing.Tuple[]` is not a subtype of the overridden attribute `typing.Tuple[str, str, str]`.",
    "exception": "[Errno 2] No such file or directory: '/home/chowyi/TypeAnnotation_Study/GitHub/aio-libs-aiopg/aiopg/transaction.py'",
    "dd_fail": true
  },
  {
    "project": "aio-libs/aiopg",
    "commit": "187d13a06581054e1f910961b8238837e7c8bd0b",
    "filename": "aiopg/transaction.py",
    "min_patch_found": false,
    "full_warning_msg": "aiopg/transaction.py:74:4 Inconsistent override [15]: `__slots__` overrides attribute defined in `IsolationCompiler` inconsistently. Type `typing.Tuple[]` is not a subtype of the overridden attribute `typing.Tuple[str, str, str]`.",
    "exception": "[Errno 2] No such file or directory: '/home/chowyi/TypeAnnotation_Study/GitHub/aio-libs-aiopg/aiopg/transaction.py'",
    "dd_fail": true
  },
  {
    "project": "aio-libs/aiopg",
    "commit": "187d13a06581054e1f910961b8238837e7c8bd0b",
    "filename": "aiopg/transaction.py",
    "min_patch_found": false,
    "full_warning_msg": "aiopg/transaction.py:81:4 Inconsistent override [15]: `__slots__` overrides attribute defined in `IsolationCompiler` inconsistently. Type `typing.Tuple[]` is not a subtype of the overridden attribute `typing.Tuple[str, str, str]`.",
    "exception": "[Errno 2] No such file or directory: '/home/chowyi/TypeAnnotation_Study/GitHub/aio-libs-aiopg/aiopg/transaction.py'",
    "dd_fail": true
  },
  {
    "project": "aio-libs/aiopg",
    "commit": "187d13a06581054e1f910961b8238837e7c8bd0b",
    "filename": "aiopg/utils.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/aio-libs-aiopg/aiopg/utils.py",
    "file_hunks_size": 6,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "aiopg/utils.py:83:4 Inconsistent override [15]: `__slots__` overrides attribute defined in `_ContextManager` inconsistently. Type `typing.Tuple[]` is not a subtype of the overridden attribute `typing.Tuple[str, str]`.",
    "message": " `__slots__` overrides attribute defined in `_ContextManager` inconsistently. Type `typing.Tuple[]` is not a subtype of the overridden attribute `typing.Tuple[str, str]`.",
    "rule_id": "Inconsistent override [15]",
    "warning_line_no": 83,
    "warning_line": "    __slots__ = ()"
  },
  {
    "project": "aio-libs/aiopg",
    "commit": "187d13a06581054e1f910961b8238837e7c8bd0b",
    "filename": "aiopg/utils.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/aio-libs-aiopg/aiopg/utils.py",
    "file_hunks_size": 6,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": true,
    "full_warning_msg": "aiopg/utils.py:101:4 Inconsistent override [15]: `__slots__` overrides attribute defined in `_ContextManager` inconsistently. Type `typing.Tuple[]` is not a subtype of the overridden attribute `typing.Tuple[str, str]`.",
    "message": " `__slots__` overrides attribute defined in `_ContextManager` inconsistently. Type `typing.Tuple[]` is not a subtype of the overridden attribute `typing.Tuple[str, str]`.",
    "rule_id": "Inconsistent override [15]",
    "warning_line_no": 101,
    "warning_line": "    __slots__ = ()",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": true,
        "source_code": "        try:\n            return await self._obj.__anext__()\n        except StopAsyncIteration:\n            self._obj.close()\n            self._obj = None\n            raise\n\n\nclass _PoolContextManager(_ContextManager):\n    __slots__ = ()\n\n    async def __aexit__(self, exc_type, exc, tb):\n        self._obj.close()\n        await self._obj.wait_closed()\n        self._obj = None\n\n\nclass _TransactionPointContextManager(_ContextManager):\n    __slots__ = ()\n\n    async def __aexit__(self, exc_type, exc_val, exc_tb):\n        if exc_type is not None:\n            await self._obj.rollback_savepoint()\n        else:\n            await self._obj.release_savepoint()\n\n        self._obj = None\n\n\nclass _TransactionBeginContextManager(_ContextManager):\n    __slots__ = ()\n\n    async def __aexit__(self, exc_type, exc_val, exc_tb):\n        if exc_type is not None:\n            await self._obj.rollback()\n        else:\n            await self._obj.commit()\n\n        self._obj = None\n\n\nclass _TransactionContextManager(_ContextManager):\n    __slots__ = ()\n\n    async def __aexit__(self, exc_type, exc, tb):\n        if exc_type:\n            await self._obj.rollback()\n        else:\n            if self._obj.is_active:\n                await self._obj.commit()\n        self._obj = None\n\n\nclass _PoolAcquireContextManager(_ContextManager):\n    __slots__ = ('_coro', '_obj', '_pool')\n\n    def __init__(self, coro, pool):\n        super().__init__(coro)\n        self._pool = pool\n\n    async def __aexit__(self, exc_type, exc, tb):\n        await self._pool.release(self._obj)\n        self._pool = None\n        self._obj = None\n\n\nclass _PoolConnectionContextManager:\n    \"\"\"Context manager.\n\n    This enables the following idiom for acquiring and releasing a\n    connection around a block:\n\n        async with pool as conn:\n            cur = await conn.cursor()\n\n    while failing loudly when accidentally using:\n\n        with pool:\n            <block>\n    \"\"\"\n\n    __slots__ = ('_pool', '_conn')\n\n    def __init__(self, pool, conn):\n        self._pool = pool\n        self._conn = conn\n\n    def __enter__(self):\n        assert self._conn\n        return self._conn\n\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        try:\n            self._pool.release(self._conn)\n        finally:\n            self._pool = None\n            self._conn = None\n\n    async def __aenter__(self):\n        assert not self._conn\n        self._conn = await self._pool.acquire()\n        return self._conn\n\n    async def __aexit__(self, exc_type, exc_val, exc_tb):\n        try:\n            await self._pool.release(self._conn)\n        finally:\n            self._pool = None\n            self._conn = None\n\n\nclass _PoolCursorContextManager:\n    \"\"\"Context manager.\n\n    This enables the following idiom for acquiring and releasing a\n    cursor around a block:\n\n        async with pool.cursor() as cur:\n            await cur.execute(\"SELECT 1\")\n\n    while failing loudly when accidentally using:\n\n        with pool:\n            <block>\n    \"\"\"\n\n    __slots__ = ('_pool', '_conn', '_cur')\n\n    def __init__(self, pool, conn, cur):\n        self._pool = pool\n        self._conn = conn\n        self._cur = cur\n\n    def __enter__(self):\n        return self._cur\n\n    def __exit__(self, *args):\n        try:\n            self._cur.close()\n        except psycopg2.ProgrammingError:\n            # seen instances where the cursor fails to close:\n            #   https://github.com/aio-libs/aiopg/issues/364\n            # We close it here so we don't return a bad connection to the pool\n            self._conn.close()\n            raise\n        finally:\n            try:\n                self._pool.release(self._conn)\n            finally:\n                self._pool = None\n                self._conn = None\n                self._cur = None\n",
        "source_code_len": 3780,
        "target_code": "        try:\n            return await self._obj.__anext__()  # type: ignore\n        except StopAsyncIteration:\n            try:\n                await self._release(self._obj)\n            finally:\n                self._obj = None\n            raise\n",
        "target_code_len": 247,
        "diff_format": "@@ -92,152 +118,8 @@\n         try:\n-            return await self._obj.__anext__()\n+            return await self._obj.__anext__()  # type: ignore\n         except StopAsyncIteration:\n-            self._obj.close()\n-            self._obj = None\n+            try:\n+                await self._release(self._obj)\n+            finally:\n+                self._obj = None\n             raise\n-\n-\n-class _PoolContextManager(_ContextManager):\n-    __slots__ = ()\n-\n-    async def __aexit__(self, exc_type, exc, tb):\n-        self._obj.close()\n-        await self._obj.wait_closed()\n-        self._obj = None\n-\n-\n-class _TransactionPointContextManager(_ContextManager):\n-    __slots__ = ()\n-\n-    async def __aexit__(self, exc_type, exc_val, exc_tb):\n-        if exc_type is not None:\n-            await self._obj.rollback_savepoint()\n-        else:\n-            await self._obj.release_savepoint()\n-\n-        self._obj = None\n-\n-\n-class _TransactionBeginContextManager(_ContextManager):\n-    __slots__ = ()\n-\n-    async def __aexit__(self, exc_type, exc_val, exc_tb):\n-        if exc_type is not None:\n-            await self._obj.rollback()\n-        else:\n-            await self._obj.commit()\n-\n-        self._obj = None\n-\n-\n-class _TransactionContextManager(_ContextManager):\n-    __slots__ = ()\n-\n-    async def __aexit__(self, exc_type, exc, tb):\n-        if exc_type:\n-            await self._obj.rollback()\n-        else:\n-            if self._obj.is_active:\n-                await self._obj.commit()\n-        self._obj = None\n-\n-\n-class _PoolAcquireContextManager(_ContextManager):\n-    __slots__ = ('_coro', '_obj', '_pool')\n-\n-    def __init__(self, coro, pool):\n-        super().__init__(coro)\n-        self._pool = pool\n-\n-    async def __aexit__(self, exc_type, exc, tb):\n-        await self._pool.release(self._obj)\n-        self._pool = None\n-        self._obj = None\n-\n-\n-class _PoolConnectionContextManager:\n-    \"\"\"Context manager.\n-\n-    This enables the following idiom for acquiring and releasing a\n-    connection around a block:\n-\n-        async with pool as conn:\n-            cur = await conn.cursor()\n-\n-    while failing loudly when accidentally using:\n-\n-        with pool:\n-            <block>\n-    \"\"\"\n-\n-    __slots__ = ('_pool', '_conn')\n-\n-    def __init__(self, pool, conn):\n-        self._pool = pool\n-        self._conn = conn\n-\n-    def __enter__(self):\n-        assert self._conn\n-        return self._conn\n-\n-    def __exit__(self, exc_type, exc_val, exc_tb):\n-        try:\n-            self._pool.release(self._conn)\n-        finally:\n-            self._pool = None\n-            self._conn = None\n-\n-    async def __aenter__(self):\n-        assert not self._conn\n-        self._conn = await self._pool.acquire()\n-        return self._conn\n-\n-    async def __aexit__(self, exc_type, exc_val, exc_tb):\n-        try:\n-            await self._pool.release(self._conn)\n-        finally:\n-            self._pool = None\n-            self._conn = None\n-\n-\n-class _PoolCursorContextManager:\n-    \"\"\"Context manager.\n-\n-    This enables the following idiom for acquiring and releasing a\n-    cursor around a block:\n-\n-        async with pool.cursor() as cur:\n-            await cur.execute(\"SELECT 1\")\n-\n-    while failing loudly when accidentally using:\n-\n-        with pool:\n-            <block>\n-    \"\"\"\n-\n-    __slots__ = ('_pool', '_conn', '_cur')\n-\n-    def __init__(self, pool, conn, cur):\n-        self._pool = pool\n-        self._conn = conn\n-        self._cur = cur\n-\n-    def __enter__(self):\n-        return self._cur\n-\n-    def __exit__(self, *args):\n-        try:\n-            self._cur.close()\n-        except psycopg2.ProgrammingError:\n-            # seen instances where the cursor fails to close:\n-            #   https://github.com/aio-libs/aiopg/issues/364\n-            # We close it here so we don't return a bad connection to the pool\n-            self._conn.close()\n-            raise\n-        finally:\n-            try:\n-                self._pool.release(self._conn)\n-            finally:\n-                self._pool = None\n-                self._conn = None\n-                self._cur = None\n",
        "source_code_with_indent": "        <DED>try:\n            <IND>return await self._obj.__anext__()\n        <DED>except StopAsyncIteration:\n            <IND>self._obj.close()\n            self._obj = None\n            raise\n\n\n<DED><DED><DED>class _PoolContextManager(_ContextManager):\n    <IND>__slots__ = ()\n\n    async def __aexit__(self, exc_type, exc, tb):\n        <IND>self._obj.close()\n        await self._obj.wait_closed()\n        self._obj = None\n\n\n<DED><DED>class _TransactionPointContextManager(_ContextManager):\n    <IND>__slots__ = ()\n\n    async def __aexit__(self, exc_type, exc_val, exc_tb):\n        <IND>if exc_type is not None:\n            <IND>await self._obj.rollback_savepoint()\n        <DED>else:\n            <IND>await self._obj.release_savepoint()\n\n        <DED>self._obj = None\n\n\n<DED><DED>class _TransactionBeginContextManager(_ContextManager):\n    <IND>__slots__ = ()\n\n    async def __aexit__(self, exc_type, exc_val, exc_tb):\n        <IND>if exc_type is not None:\n            <IND>await self._obj.rollback()\n        <DED>else:\n            <IND>await self._obj.commit()\n\n        <DED>self._obj = None\n\n\n<DED><DED>class _TransactionContextManager(_ContextManager):\n    <IND>__slots__ = ()\n\n    async def __aexit__(self, exc_type, exc, tb):\n        <IND>if exc_type:\n            <IND>await self._obj.rollback()\n        <DED>else:\n            <IND>if self._obj.is_active:\n                <IND>await self._obj.commit()\n        <DED><DED>self._obj = None\n\n\n<DED><DED>class _PoolAcquireContextManager(_ContextManager):\n    <IND>__slots__ = ('_coro', '_obj', '_pool')\n\n    def __init__(self, coro, pool):\n        <IND>super().__init__(coro)\n        self._pool = pool\n\n    <DED>async def __aexit__(self, exc_type, exc, tb):\n        <IND>await self._pool.release(self._obj)\n        self._pool = None\n        self._obj = None\n\n\n<DED><DED>class _PoolConnectionContextManager:\n    <IND>\"\"\"Context manager.\n\n    This enables the following idiom for acquiring and releasing a\n    connection around a block:\n\n        async with pool as conn:\n            cur = await conn.cursor()\n\n    while failing loudly when accidentally using:\n\n        with pool:\n            <block>\n    \"\"\"\n\n    __slots__ = ('_pool', '_conn')\n\n    def __init__(self, pool, conn):\n        <IND>self._pool = pool\n        self._conn = conn\n\n    <DED>def __enter__(self):\n        <IND>assert self._conn\n        return self._conn\n\n    <DED>def __exit__(self, exc_type, exc_val, exc_tb):\n        <IND>try:\n            <IND>self._pool.release(self._conn)\n        <DED>finally:\n            <IND>self._pool = None\n            self._conn = None\n\n    <DED><DED>async def __aenter__(self):\n        <IND>assert not self._conn\n        self._conn = await self._pool.acquire()\n        return self._conn\n\n    <DED>async def __aexit__(self, exc_type, exc_val, exc_tb):\n        <IND>try:\n            <IND>await self._pool.release(self._conn)\n        <DED>finally:\n            <IND>self._pool = None\n            self._conn = None\n\n\n<DED><DED><DED>class _PoolCursorContextManager:\n    <IND>\"\"\"Context manager.\n\n    This enables the following idiom for acquiring and releasing a\n    cursor around a block:\n\n        async with pool.cursor() as cur:\n            await cur.execute(\"SELECT 1\")\n\n    while failing loudly when accidentally using:\n\n        with pool:\n            <block>\n    \"\"\"\n\n    __slots__ = ('_pool', '_conn', '_cur')\n\n    def __init__(self, pool, conn, cur):\n        <IND>self._pool = pool\n        self._conn = conn\n        self._cur = cur\n\n    <DED>def __enter__(self):\n        <IND>return self._cur\n\n    <DED>def __exit__(self, *args):\n        <IND>try:\n            <IND>self._cur.close()\n        <DED>except psycopg2.ProgrammingError:\n            # seen instances where the cursor fails to close:\n            #   https://github.com/aio-libs/aiopg/issues/364\n            # We close it here so we don't return a bad connection to the pool\n            <IND>self._conn.close()\n            raise\n        <DED>finally:\n            <IND>try:\n                <IND>self._pool.release(self._conn)\n            <DED>finally:\n                <IND>self._pool = None\n                self._conn = None\n                self._cur = None\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "        <DED>try:\n            <IND>return await self._obj.__anext__()  # type: ignore\n        <DED>except StopAsyncIteration:\n            <IND>try:\n                <IND>await self._release(self._obj)\n            <DED>finally:\n                <IND>self._obj = None\n            <DED>raise\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "aio-libs/aiopg",
    "commit": "187d13a06581054e1f910961b8238837e7c8bd0b",
    "filename": "aiopg/utils.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/aio-libs-aiopg/aiopg/utils.py",
    "file_hunks_size": 6,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": true,
    "full_warning_msg": "aiopg/utils.py:110:4 Inconsistent override [15]: `__slots__` overrides attribute defined in `_ContextManager` inconsistently. Type `typing.Tuple[]` is not a subtype of the overridden attribute `typing.Tuple[str, str]`.",
    "message": " `__slots__` overrides attribute defined in `_ContextManager` inconsistently. Type `typing.Tuple[]` is not a subtype of the overridden attribute `typing.Tuple[str, str]`.",
    "rule_id": "Inconsistent override [15]",
    "warning_line_no": 110,
    "warning_line": "    __slots__ = ()",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": true,
        "source_code": "        try:\n            return await self._obj.__anext__()\n        except StopAsyncIteration:\n            self._obj.close()\n            self._obj = None\n            raise\n\n\nclass _PoolContextManager(_ContextManager):\n    __slots__ = ()\n\n    async def __aexit__(self, exc_type, exc, tb):\n        self._obj.close()\n        await self._obj.wait_closed()\n        self._obj = None\n\n\nclass _TransactionPointContextManager(_ContextManager):\n    __slots__ = ()\n\n    async def __aexit__(self, exc_type, exc_val, exc_tb):\n        if exc_type is not None:\n            await self._obj.rollback_savepoint()\n        else:\n            await self._obj.release_savepoint()\n\n        self._obj = None\n\n\nclass _TransactionBeginContextManager(_ContextManager):\n    __slots__ = ()\n\n    async def __aexit__(self, exc_type, exc_val, exc_tb):\n        if exc_type is not None:\n            await self._obj.rollback()\n        else:\n            await self._obj.commit()\n\n        self._obj = None\n\n\nclass _TransactionContextManager(_ContextManager):\n    __slots__ = ()\n\n    async def __aexit__(self, exc_type, exc, tb):\n        if exc_type:\n            await self._obj.rollback()\n        else:\n            if self._obj.is_active:\n                await self._obj.commit()\n        self._obj = None\n\n\nclass _PoolAcquireContextManager(_ContextManager):\n    __slots__ = ('_coro', '_obj', '_pool')\n\n    def __init__(self, coro, pool):\n        super().__init__(coro)\n        self._pool = pool\n\n    async def __aexit__(self, exc_type, exc, tb):\n        await self._pool.release(self._obj)\n        self._pool = None\n        self._obj = None\n\n\nclass _PoolConnectionContextManager:\n    \"\"\"Context manager.\n\n    This enables the following idiom for acquiring and releasing a\n    connection around a block:\n\n        async with pool as conn:\n            cur = await conn.cursor()\n\n    while failing loudly when accidentally using:\n\n        with pool:\n            <block>\n    \"\"\"\n\n    __slots__ = ('_pool', '_conn')\n\n    def __init__(self, pool, conn):\n        self._pool = pool\n        self._conn = conn\n\n    def __enter__(self):\n        assert self._conn\n        return self._conn\n\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        try:\n            self._pool.release(self._conn)\n        finally:\n            self._pool = None\n            self._conn = None\n\n    async def __aenter__(self):\n        assert not self._conn\n        self._conn = await self._pool.acquire()\n        return self._conn\n\n    async def __aexit__(self, exc_type, exc_val, exc_tb):\n        try:\n            await self._pool.release(self._conn)\n        finally:\n            self._pool = None\n            self._conn = None\n\n\nclass _PoolCursorContextManager:\n    \"\"\"Context manager.\n\n    This enables the following idiom for acquiring and releasing a\n    cursor around a block:\n\n        async with pool.cursor() as cur:\n            await cur.execute(\"SELECT 1\")\n\n    while failing loudly when accidentally using:\n\n        with pool:\n            <block>\n    \"\"\"\n\n    __slots__ = ('_pool', '_conn', '_cur')\n\n    def __init__(self, pool, conn, cur):\n        self._pool = pool\n        self._conn = conn\n        self._cur = cur\n\n    def __enter__(self):\n        return self._cur\n\n    def __exit__(self, *args):\n        try:\n            self._cur.close()\n        except psycopg2.ProgrammingError:\n            # seen instances where the cursor fails to close:\n            #   https://github.com/aio-libs/aiopg/issues/364\n            # We close it here so we don't return a bad connection to the pool\n            self._conn.close()\n            raise\n        finally:\n            try:\n                self._pool.release(self._conn)\n            finally:\n                self._pool = None\n                self._conn = None\n                self._cur = None\n",
        "source_code_len": 3780,
        "target_code": "        try:\n            return await self._obj.__anext__()  # type: ignore\n        except StopAsyncIteration:\n            try:\n                await self._release(self._obj)\n            finally:\n                self._obj = None\n            raise\n",
        "target_code_len": 247,
        "diff_format": "@@ -92,152 +118,8 @@\n         try:\n-            return await self._obj.__anext__()\n+            return await self._obj.__anext__()  # type: ignore\n         except StopAsyncIteration:\n-            self._obj.close()\n-            self._obj = None\n+            try:\n+                await self._release(self._obj)\n+            finally:\n+                self._obj = None\n             raise\n-\n-\n-class _PoolContextManager(_ContextManager):\n-    __slots__ = ()\n-\n-    async def __aexit__(self, exc_type, exc, tb):\n-        self._obj.close()\n-        await self._obj.wait_closed()\n-        self._obj = None\n-\n-\n-class _TransactionPointContextManager(_ContextManager):\n-    __slots__ = ()\n-\n-    async def __aexit__(self, exc_type, exc_val, exc_tb):\n-        if exc_type is not None:\n-            await self._obj.rollback_savepoint()\n-        else:\n-            await self._obj.release_savepoint()\n-\n-        self._obj = None\n-\n-\n-class _TransactionBeginContextManager(_ContextManager):\n-    __slots__ = ()\n-\n-    async def __aexit__(self, exc_type, exc_val, exc_tb):\n-        if exc_type is not None:\n-            await self._obj.rollback()\n-        else:\n-            await self._obj.commit()\n-\n-        self._obj = None\n-\n-\n-class _TransactionContextManager(_ContextManager):\n-    __slots__ = ()\n-\n-    async def __aexit__(self, exc_type, exc, tb):\n-        if exc_type:\n-            await self._obj.rollback()\n-        else:\n-            if self._obj.is_active:\n-                await self._obj.commit()\n-        self._obj = None\n-\n-\n-class _PoolAcquireContextManager(_ContextManager):\n-    __slots__ = ('_coro', '_obj', '_pool')\n-\n-    def __init__(self, coro, pool):\n-        super().__init__(coro)\n-        self._pool = pool\n-\n-    async def __aexit__(self, exc_type, exc, tb):\n-        await self._pool.release(self._obj)\n-        self._pool = None\n-        self._obj = None\n-\n-\n-class _PoolConnectionContextManager:\n-    \"\"\"Context manager.\n-\n-    This enables the following idiom for acquiring and releasing a\n-    connection around a block:\n-\n-        async with pool as conn:\n-            cur = await conn.cursor()\n-\n-    while failing loudly when accidentally using:\n-\n-        with pool:\n-            <block>\n-    \"\"\"\n-\n-    __slots__ = ('_pool', '_conn')\n-\n-    def __init__(self, pool, conn):\n-        self._pool = pool\n-        self._conn = conn\n-\n-    def __enter__(self):\n-        assert self._conn\n-        return self._conn\n-\n-    def __exit__(self, exc_type, exc_val, exc_tb):\n-        try:\n-            self._pool.release(self._conn)\n-        finally:\n-            self._pool = None\n-            self._conn = None\n-\n-    async def __aenter__(self):\n-        assert not self._conn\n-        self._conn = await self._pool.acquire()\n-        return self._conn\n-\n-    async def __aexit__(self, exc_type, exc_val, exc_tb):\n-        try:\n-            await self._pool.release(self._conn)\n-        finally:\n-            self._pool = None\n-            self._conn = None\n-\n-\n-class _PoolCursorContextManager:\n-    \"\"\"Context manager.\n-\n-    This enables the following idiom for acquiring and releasing a\n-    cursor around a block:\n-\n-        async with pool.cursor() as cur:\n-            await cur.execute(\"SELECT 1\")\n-\n-    while failing loudly when accidentally using:\n-\n-        with pool:\n-            <block>\n-    \"\"\"\n-\n-    __slots__ = ('_pool', '_conn', '_cur')\n-\n-    def __init__(self, pool, conn, cur):\n-        self._pool = pool\n-        self._conn = conn\n-        self._cur = cur\n-\n-    def __enter__(self):\n-        return self._cur\n-\n-    def __exit__(self, *args):\n-        try:\n-            self._cur.close()\n-        except psycopg2.ProgrammingError:\n-            # seen instances where the cursor fails to close:\n-            #   https://github.com/aio-libs/aiopg/issues/364\n-            # We close it here so we don't return a bad connection to the pool\n-            self._conn.close()\n-            raise\n-        finally:\n-            try:\n-                self._pool.release(self._conn)\n-            finally:\n-                self._pool = None\n-                self._conn = None\n-                self._cur = None\n",
        "source_code_with_indent": "        <DED>try:\n            <IND>return await self._obj.__anext__()\n        <DED>except StopAsyncIteration:\n            <IND>self._obj.close()\n            self._obj = None\n            raise\n\n\n<DED><DED><DED>class _PoolContextManager(_ContextManager):\n    <IND>__slots__ = ()\n\n    async def __aexit__(self, exc_type, exc, tb):\n        <IND>self._obj.close()\n        await self._obj.wait_closed()\n        self._obj = None\n\n\n<DED><DED>class _TransactionPointContextManager(_ContextManager):\n    <IND>__slots__ = ()\n\n    async def __aexit__(self, exc_type, exc_val, exc_tb):\n        <IND>if exc_type is not None:\n            <IND>await self._obj.rollback_savepoint()\n        <DED>else:\n            <IND>await self._obj.release_savepoint()\n\n        <DED>self._obj = None\n\n\n<DED><DED>class _TransactionBeginContextManager(_ContextManager):\n    <IND>__slots__ = ()\n\n    async def __aexit__(self, exc_type, exc_val, exc_tb):\n        <IND>if exc_type is not None:\n            <IND>await self._obj.rollback()\n        <DED>else:\n            <IND>await self._obj.commit()\n\n        <DED>self._obj = None\n\n\n<DED><DED>class _TransactionContextManager(_ContextManager):\n    <IND>__slots__ = ()\n\n    async def __aexit__(self, exc_type, exc, tb):\n        <IND>if exc_type:\n            <IND>await self._obj.rollback()\n        <DED>else:\n            <IND>if self._obj.is_active:\n                <IND>await self._obj.commit()\n        <DED><DED>self._obj = None\n\n\n<DED><DED>class _PoolAcquireContextManager(_ContextManager):\n    <IND>__slots__ = ('_coro', '_obj', '_pool')\n\n    def __init__(self, coro, pool):\n        <IND>super().__init__(coro)\n        self._pool = pool\n\n    <DED>async def __aexit__(self, exc_type, exc, tb):\n        <IND>await self._pool.release(self._obj)\n        self._pool = None\n        self._obj = None\n\n\n<DED><DED>class _PoolConnectionContextManager:\n    <IND>\"\"\"Context manager.\n\n    This enables the following idiom for acquiring and releasing a\n    connection around a block:\n\n        async with pool as conn:\n            cur = await conn.cursor()\n\n    while failing loudly when accidentally using:\n\n        with pool:\n            <block>\n    \"\"\"\n\n    __slots__ = ('_pool', '_conn')\n\n    def __init__(self, pool, conn):\n        <IND>self._pool = pool\n        self._conn = conn\n\n    <DED>def __enter__(self):\n        <IND>assert self._conn\n        return self._conn\n\n    <DED>def __exit__(self, exc_type, exc_val, exc_tb):\n        <IND>try:\n            <IND>self._pool.release(self._conn)\n        <DED>finally:\n            <IND>self._pool = None\n            self._conn = None\n\n    <DED><DED>async def __aenter__(self):\n        <IND>assert not self._conn\n        self._conn = await self._pool.acquire()\n        return self._conn\n\n    <DED>async def __aexit__(self, exc_type, exc_val, exc_tb):\n        <IND>try:\n            <IND>await self._pool.release(self._conn)\n        <DED>finally:\n            <IND>self._pool = None\n            self._conn = None\n\n\n<DED><DED><DED>class _PoolCursorContextManager:\n    <IND>\"\"\"Context manager.\n\n    This enables the following idiom for acquiring and releasing a\n    cursor around a block:\n\n        async with pool.cursor() as cur:\n            await cur.execute(\"SELECT 1\")\n\n    while failing loudly when accidentally using:\n\n        with pool:\n            <block>\n    \"\"\"\n\n    __slots__ = ('_pool', '_conn', '_cur')\n\n    def __init__(self, pool, conn, cur):\n        <IND>self._pool = pool\n        self._conn = conn\n        self._cur = cur\n\n    <DED>def __enter__(self):\n        <IND>return self._cur\n\n    <DED>def __exit__(self, *args):\n        <IND>try:\n            <IND>self._cur.close()\n        <DED>except psycopg2.ProgrammingError:\n            # seen instances where the cursor fails to close:\n            #   https://github.com/aio-libs/aiopg/issues/364\n            # We close it here so we don't return a bad connection to the pool\n            <IND>self._conn.close()\n            raise\n        <DED>finally:\n            <IND>try:\n                <IND>self._pool.release(self._conn)\n            <DED>finally:\n                <IND>self._pool = None\n                self._conn = None\n                self._cur = None\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "        <DED>try:\n            <IND>return await self._obj.__anext__()  # type: ignore\n        <DED>except StopAsyncIteration:\n            <IND>try:\n                <IND>await self._release(self._obj)\n            <DED>finally:\n                <IND>self._obj = None\n            <DED>raise\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "aio-libs/aiopg",
    "commit": "187d13a06581054e1f910961b8238837e7c8bd0b",
    "filename": "aiopg/utils.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/aio-libs-aiopg/aiopg/utils.py",
    "file_hunks_size": 6,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": true,
    "full_warning_msg": "aiopg/utils.py:122:4 Inconsistent override [15]: `__slots__` overrides attribute defined in `_ContextManager` inconsistently. Type `typing.Tuple[]` is not a subtype of the overridden attribute `typing.Tuple[str, str]`.",
    "message": " `__slots__` overrides attribute defined in `_ContextManager` inconsistently. Type `typing.Tuple[]` is not a subtype of the overridden attribute `typing.Tuple[str, str]`.",
    "rule_id": "Inconsistent override [15]",
    "warning_line_no": 122,
    "warning_line": "    __slots__ = ()",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": true,
        "source_code": "        try:\n            return await self._obj.__anext__()\n        except StopAsyncIteration:\n            self._obj.close()\n            self._obj = None\n            raise\n\n\nclass _PoolContextManager(_ContextManager):\n    __slots__ = ()\n\n    async def __aexit__(self, exc_type, exc, tb):\n        self._obj.close()\n        await self._obj.wait_closed()\n        self._obj = None\n\n\nclass _TransactionPointContextManager(_ContextManager):\n    __slots__ = ()\n\n    async def __aexit__(self, exc_type, exc_val, exc_tb):\n        if exc_type is not None:\n            await self._obj.rollback_savepoint()\n        else:\n            await self._obj.release_savepoint()\n\n        self._obj = None\n\n\nclass _TransactionBeginContextManager(_ContextManager):\n    __slots__ = ()\n\n    async def __aexit__(self, exc_type, exc_val, exc_tb):\n        if exc_type is not None:\n            await self._obj.rollback()\n        else:\n            await self._obj.commit()\n\n        self._obj = None\n\n\nclass _TransactionContextManager(_ContextManager):\n    __slots__ = ()\n\n    async def __aexit__(self, exc_type, exc, tb):\n        if exc_type:\n            await self._obj.rollback()\n        else:\n            if self._obj.is_active:\n                await self._obj.commit()\n        self._obj = None\n\n\nclass _PoolAcquireContextManager(_ContextManager):\n    __slots__ = ('_coro', '_obj', '_pool')\n\n    def __init__(self, coro, pool):\n        super().__init__(coro)\n        self._pool = pool\n\n    async def __aexit__(self, exc_type, exc, tb):\n        await self._pool.release(self._obj)\n        self._pool = None\n        self._obj = None\n\n\nclass _PoolConnectionContextManager:\n    \"\"\"Context manager.\n\n    This enables the following idiom for acquiring and releasing a\n    connection around a block:\n\n        async with pool as conn:\n            cur = await conn.cursor()\n\n    while failing loudly when accidentally using:\n\n        with pool:\n            <block>\n    \"\"\"\n\n    __slots__ = ('_pool', '_conn')\n\n    def __init__(self, pool, conn):\n        self._pool = pool\n        self._conn = conn\n\n    def __enter__(self):\n        assert self._conn\n        return self._conn\n\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        try:\n            self._pool.release(self._conn)\n        finally:\n            self._pool = None\n            self._conn = None\n\n    async def __aenter__(self):\n        assert not self._conn\n        self._conn = await self._pool.acquire()\n        return self._conn\n\n    async def __aexit__(self, exc_type, exc_val, exc_tb):\n        try:\n            await self._pool.release(self._conn)\n        finally:\n            self._pool = None\n            self._conn = None\n\n\nclass _PoolCursorContextManager:\n    \"\"\"Context manager.\n\n    This enables the following idiom for acquiring and releasing a\n    cursor around a block:\n\n        async with pool.cursor() as cur:\n            await cur.execute(\"SELECT 1\")\n\n    while failing loudly when accidentally using:\n\n        with pool:\n            <block>\n    \"\"\"\n\n    __slots__ = ('_pool', '_conn', '_cur')\n\n    def __init__(self, pool, conn, cur):\n        self._pool = pool\n        self._conn = conn\n        self._cur = cur\n\n    def __enter__(self):\n        return self._cur\n\n    def __exit__(self, *args):\n        try:\n            self._cur.close()\n        except psycopg2.ProgrammingError:\n            # seen instances where the cursor fails to close:\n            #   https://github.com/aio-libs/aiopg/issues/364\n            # We close it here so we don't return a bad connection to the pool\n            self._conn.close()\n            raise\n        finally:\n            try:\n                self._pool.release(self._conn)\n            finally:\n                self._pool = None\n                self._conn = None\n                self._cur = None\n",
        "source_code_len": 3780,
        "target_code": "        try:\n            return await self._obj.__anext__()  # type: ignore\n        except StopAsyncIteration:\n            try:\n                await self._release(self._obj)\n            finally:\n                self._obj = None\n            raise\n",
        "target_code_len": 247,
        "diff_format": "@@ -92,152 +118,8 @@\n         try:\n-            return await self._obj.__anext__()\n+            return await self._obj.__anext__()  # type: ignore\n         except StopAsyncIteration:\n-            self._obj.close()\n-            self._obj = None\n+            try:\n+                await self._release(self._obj)\n+            finally:\n+                self._obj = None\n             raise\n-\n-\n-class _PoolContextManager(_ContextManager):\n-    __slots__ = ()\n-\n-    async def __aexit__(self, exc_type, exc, tb):\n-        self._obj.close()\n-        await self._obj.wait_closed()\n-        self._obj = None\n-\n-\n-class _TransactionPointContextManager(_ContextManager):\n-    __slots__ = ()\n-\n-    async def __aexit__(self, exc_type, exc_val, exc_tb):\n-        if exc_type is not None:\n-            await self._obj.rollback_savepoint()\n-        else:\n-            await self._obj.release_savepoint()\n-\n-        self._obj = None\n-\n-\n-class _TransactionBeginContextManager(_ContextManager):\n-    __slots__ = ()\n-\n-    async def __aexit__(self, exc_type, exc_val, exc_tb):\n-        if exc_type is not None:\n-            await self._obj.rollback()\n-        else:\n-            await self._obj.commit()\n-\n-        self._obj = None\n-\n-\n-class _TransactionContextManager(_ContextManager):\n-    __slots__ = ()\n-\n-    async def __aexit__(self, exc_type, exc, tb):\n-        if exc_type:\n-            await self._obj.rollback()\n-        else:\n-            if self._obj.is_active:\n-                await self._obj.commit()\n-        self._obj = None\n-\n-\n-class _PoolAcquireContextManager(_ContextManager):\n-    __slots__ = ('_coro', '_obj', '_pool')\n-\n-    def __init__(self, coro, pool):\n-        super().__init__(coro)\n-        self._pool = pool\n-\n-    async def __aexit__(self, exc_type, exc, tb):\n-        await self._pool.release(self._obj)\n-        self._pool = None\n-        self._obj = None\n-\n-\n-class _PoolConnectionContextManager:\n-    \"\"\"Context manager.\n-\n-    This enables the following idiom for acquiring and releasing a\n-    connection around a block:\n-\n-        async with pool as conn:\n-            cur = await conn.cursor()\n-\n-    while failing loudly when accidentally using:\n-\n-        with pool:\n-            <block>\n-    \"\"\"\n-\n-    __slots__ = ('_pool', '_conn')\n-\n-    def __init__(self, pool, conn):\n-        self._pool = pool\n-        self._conn = conn\n-\n-    def __enter__(self):\n-        assert self._conn\n-        return self._conn\n-\n-    def __exit__(self, exc_type, exc_val, exc_tb):\n-        try:\n-            self._pool.release(self._conn)\n-        finally:\n-            self._pool = None\n-            self._conn = None\n-\n-    async def __aenter__(self):\n-        assert not self._conn\n-        self._conn = await self._pool.acquire()\n-        return self._conn\n-\n-    async def __aexit__(self, exc_type, exc_val, exc_tb):\n-        try:\n-            await self._pool.release(self._conn)\n-        finally:\n-            self._pool = None\n-            self._conn = None\n-\n-\n-class _PoolCursorContextManager:\n-    \"\"\"Context manager.\n-\n-    This enables the following idiom for acquiring and releasing a\n-    cursor around a block:\n-\n-        async with pool.cursor() as cur:\n-            await cur.execute(\"SELECT 1\")\n-\n-    while failing loudly when accidentally using:\n-\n-        with pool:\n-            <block>\n-    \"\"\"\n-\n-    __slots__ = ('_pool', '_conn', '_cur')\n-\n-    def __init__(self, pool, conn, cur):\n-        self._pool = pool\n-        self._conn = conn\n-        self._cur = cur\n-\n-    def __enter__(self):\n-        return self._cur\n-\n-    def __exit__(self, *args):\n-        try:\n-            self._cur.close()\n-        except psycopg2.ProgrammingError:\n-            # seen instances where the cursor fails to close:\n-            #   https://github.com/aio-libs/aiopg/issues/364\n-            # We close it here so we don't return a bad connection to the pool\n-            self._conn.close()\n-            raise\n-        finally:\n-            try:\n-                self._pool.release(self._conn)\n-            finally:\n-                self._pool = None\n-                self._conn = None\n-                self._cur = None\n",
        "source_code_with_indent": "        <DED>try:\n            <IND>return await self._obj.__anext__()\n        <DED>except StopAsyncIteration:\n            <IND>self._obj.close()\n            self._obj = None\n            raise\n\n\n<DED><DED><DED>class _PoolContextManager(_ContextManager):\n    <IND>__slots__ = ()\n\n    async def __aexit__(self, exc_type, exc, tb):\n        <IND>self._obj.close()\n        await self._obj.wait_closed()\n        self._obj = None\n\n\n<DED><DED>class _TransactionPointContextManager(_ContextManager):\n    <IND>__slots__ = ()\n\n    async def __aexit__(self, exc_type, exc_val, exc_tb):\n        <IND>if exc_type is not None:\n            <IND>await self._obj.rollback_savepoint()\n        <DED>else:\n            <IND>await self._obj.release_savepoint()\n\n        <DED>self._obj = None\n\n\n<DED><DED>class _TransactionBeginContextManager(_ContextManager):\n    <IND>__slots__ = ()\n\n    async def __aexit__(self, exc_type, exc_val, exc_tb):\n        <IND>if exc_type is not None:\n            <IND>await self._obj.rollback()\n        <DED>else:\n            <IND>await self._obj.commit()\n\n        <DED>self._obj = None\n\n\n<DED><DED>class _TransactionContextManager(_ContextManager):\n    <IND>__slots__ = ()\n\n    async def __aexit__(self, exc_type, exc, tb):\n        <IND>if exc_type:\n            <IND>await self._obj.rollback()\n        <DED>else:\n            <IND>if self._obj.is_active:\n                <IND>await self._obj.commit()\n        <DED><DED>self._obj = None\n\n\n<DED><DED>class _PoolAcquireContextManager(_ContextManager):\n    <IND>__slots__ = ('_coro', '_obj', '_pool')\n\n    def __init__(self, coro, pool):\n        <IND>super().__init__(coro)\n        self._pool = pool\n\n    <DED>async def __aexit__(self, exc_type, exc, tb):\n        <IND>await self._pool.release(self._obj)\n        self._pool = None\n        self._obj = None\n\n\n<DED><DED>class _PoolConnectionContextManager:\n    <IND>\"\"\"Context manager.\n\n    This enables the following idiom for acquiring and releasing a\n    connection around a block:\n\n        async with pool as conn:\n            cur = await conn.cursor()\n\n    while failing loudly when accidentally using:\n\n        with pool:\n            <block>\n    \"\"\"\n\n    __slots__ = ('_pool', '_conn')\n\n    def __init__(self, pool, conn):\n        <IND>self._pool = pool\n        self._conn = conn\n\n    <DED>def __enter__(self):\n        <IND>assert self._conn\n        return self._conn\n\n    <DED>def __exit__(self, exc_type, exc_val, exc_tb):\n        <IND>try:\n            <IND>self._pool.release(self._conn)\n        <DED>finally:\n            <IND>self._pool = None\n            self._conn = None\n\n    <DED><DED>async def __aenter__(self):\n        <IND>assert not self._conn\n        self._conn = await self._pool.acquire()\n        return self._conn\n\n    <DED>async def __aexit__(self, exc_type, exc_val, exc_tb):\n        <IND>try:\n            <IND>await self._pool.release(self._conn)\n        <DED>finally:\n            <IND>self._pool = None\n            self._conn = None\n\n\n<DED><DED><DED>class _PoolCursorContextManager:\n    <IND>\"\"\"Context manager.\n\n    This enables the following idiom for acquiring and releasing a\n    cursor around a block:\n\n        async with pool.cursor() as cur:\n            await cur.execute(\"SELECT 1\")\n\n    while failing loudly when accidentally using:\n\n        with pool:\n            <block>\n    \"\"\"\n\n    __slots__ = ('_pool', '_conn', '_cur')\n\n    def __init__(self, pool, conn, cur):\n        <IND>self._pool = pool\n        self._conn = conn\n        self._cur = cur\n\n    <DED>def __enter__(self):\n        <IND>return self._cur\n\n    <DED>def __exit__(self, *args):\n        <IND>try:\n            <IND>self._cur.close()\n        <DED>except psycopg2.ProgrammingError:\n            # seen instances where the cursor fails to close:\n            #   https://github.com/aio-libs/aiopg/issues/364\n            # We close it here so we don't return a bad connection to the pool\n            <IND>self._conn.close()\n            raise\n        <DED>finally:\n            <IND>try:\n                <IND>self._pool.release(self._conn)\n            <DED>finally:\n                <IND>self._pool = None\n                self._conn = None\n                self._cur = None\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "        <DED>try:\n            <IND>return await self._obj.__anext__()  # type: ignore\n        <DED>except StopAsyncIteration:\n            <IND>try:\n                <IND>await self._release(self._obj)\n            <DED>finally:\n                <IND>self._obj = None\n            <DED>raise\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "aio-libs/aiopg",
    "commit": "187d13a06581054e1f910961b8238837e7c8bd0b",
    "filename": "aiopg/utils.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/aio-libs-aiopg/aiopg/utils.py",
    "file_hunks_size": 6,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": true,
    "full_warning_msg": "aiopg/utils.py:134:4 Inconsistent override [15]: `__slots__` overrides attribute defined in `_ContextManager` inconsistently. Type `typing.Tuple[]` is not a subtype of the overridden attribute `typing.Tuple[str, str]`.",
    "message": " `__slots__` overrides attribute defined in `_ContextManager` inconsistently. Type `typing.Tuple[]` is not a subtype of the overridden attribute `typing.Tuple[str, str]`.",
    "rule_id": "Inconsistent override [15]",
    "warning_line_no": 134,
    "warning_line": "    __slots__ = ()",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": true,
        "source_code": "        try:\n            return await self._obj.__anext__()\n        except StopAsyncIteration:\n            self._obj.close()\n            self._obj = None\n            raise\n\n\nclass _PoolContextManager(_ContextManager):\n    __slots__ = ()\n\n    async def __aexit__(self, exc_type, exc, tb):\n        self._obj.close()\n        await self._obj.wait_closed()\n        self._obj = None\n\n\nclass _TransactionPointContextManager(_ContextManager):\n    __slots__ = ()\n\n    async def __aexit__(self, exc_type, exc_val, exc_tb):\n        if exc_type is not None:\n            await self._obj.rollback_savepoint()\n        else:\n            await self._obj.release_savepoint()\n\n        self._obj = None\n\n\nclass _TransactionBeginContextManager(_ContextManager):\n    __slots__ = ()\n\n    async def __aexit__(self, exc_type, exc_val, exc_tb):\n        if exc_type is not None:\n            await self._obj.rollback()\n        else:\n            await self._obj.commit()\n\n        self._obj = None\n\n\nclass _TransactionContextManager(_ContextManager):\n    __slots__ = ()\n\n    async def __aexit__(self, exc_type, exc, tb):\n        if exc_type:\n            await self._obj.rollback()\n        else:\n            if self._obj.is_active:\n                await self._obj.commit()\n        self._obj = None\n\n\nclass _PoolAcquireContextManager(_ContextManager):\n    __slots__ = ('_coro', '_obj', '_pool')\n\n    def __init__(self, coro, pool):\n        super().__init__(coro)\n        self._pool = pool\n\n    async def __aexit__(self, exc_type, exc, tb):\n        await self._pool.release(self._obj)\n        self._pool = None\n        self._obj = None\n\n\nclass _PoolConnectionContextManager:\n    \"\"\"Context manager.\n\n    This enables the following idiom for acquiring and releasing a\n    connection around a block:\n\n        async with pool as conn:\n            cur = await conn.cursor()\n\n    while failing loudly when accidentally using:\n\n        with pool:\n            <block>\n    \"\"\"\n\n    __slots__ = ('_pool', '_conn')\n\n    def __init__(self, pool, conn):\n        self._pool = pool\n        self._conn = conn\n\n    def __enter__(self):\n        assert self._conn\n        return self._conn\n\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        try:\n            self._pool.release(self._conn)\n        finally:\n            self._pool = None\n            self._conn = None\n\n    async def __aenter__(self):\n        assert not self._conn\n        self._conn = await self._pool.acquire()\n        return self._conn\n\n    async def __aexit__(self, exc_type, exc_val, exc_tb):\n        try:\n            await self._pool.release(self._conn)\n        finally:\n            self._pool = None\n            self._conn = None\n\n\nclass _PoolCursorContextManager:\n    \"\"\"Context manager.\n\n    This enables the following idiom for acquiring and releasing a\n    cursor around a block:\n\n        async with pool.cursor() as cur:\n            await cur.execute(\"SELECT 1\")\n\n    while failing loudly when accidentally using:\n\n        with pool:\n            <block>\n    \"\"\"\n\n    __slots__ = ('_pool', '_conn', '_cur')\n\n    def __init__(self, pool, conn, cur):\n        self._pool = pool\n        self._conn = conn\n        self._cur = cur\n\n    def __enter__(self):\n        return self._cur\n\n    def __exit__(self, *args):\n        try:\n            self._cur.close()\n        except psycopg2.ProgrammingError:\n            # seen instances where the cursor fails to close:\n            #   https://github.com/aio-libs/aiopg/issues/364\n            # We close it here so we don't return a bad connection to the pool\n            self._conn.close()\n            raise\n        finally:\n            try:\n                self._pool.release(self._conn)\n            finally:\n                self._pool = None\n                self._conn = None\n                self._cur = None\n",
        "source_code_len": 3780,
        "target_code": "        try:\n            return await self._obj.__anext__()  # type: ignore\n        except StopAsyncIteration:\n            try:\n                await self._release(self._obj)\n            finally:\n                self._obj = None\n            raise\n",
        "target_code_len": 247,
        "diff_format": "@@ -92,152 +118,8 @@\n         try:\n-            return await self._obj.__anext__()\n+            return await self._obj.__anext__()  # type: ignore\n         except StopAsyncIteration:\n-            self._obj.close()\n-            self._obj = None\n+            try:\n+                await self._release(self._obj)\n+            finally:\n+                self._obj = None\n             raise\n-\n-\n-class _PoolContextManager(_ContextManager):\n-    __slots__ = ()\n-\n-    async def __aexit__(self, exc_type, exc, tb):\n-        self._obj.close()\n-        await self._obj.wait_closed()\n-        self._obj = None\n-\n-\n-class _TransactionPointContextManager(_ContextManager):\n-    __slots__ = ()\n-\n-    async def __aexit__(self, exc_type, exc_val, exc_tb):\n-        if exc_type is not None:\n-            await self._obj.rollback_savepoint()\n-        else:\n-            await self._obj.release_savepoint()\n-\n-        self._obj = None\n-\n-\n-class _TransactionBeginContextManager(_ContextManager):\n-    __slots__ = ()\n-\n-    async def __aexit__(self, exc_type, exc_val, exc_tb):\n-        if exc_type is not None:\n-            await self._obj.rollback()\n-        else:\n-            await self._obj.commit()\n-\n-        self._obj = None\n-\n-\n-class _TransactionContextManager(_ContextManager):\n-    __slots__ = ()\n-\n-    async def __aexit__(self, exc_type, exc, tb):\n-        if exc_type:\n-            await self._obj.rollback()\n-        else:\n-            if self._obj.is_active:\n-                await self._obj.commit()\n-        self._obj = None\n-\n-\n-class _PoolAcquireContextManager(_ContextManager):\n-    __slots__ = ('_coro', '_obj', '_pool')\n-\n-    def __init__(self, coro, pool):\n-        super().__init__(coro)\n-        self._pool = pool\n-\n-    async def __aexit__(self, exc_type, exc, tb):\n-        await self._pool.release(self._obj)\n-        self._pool = None\n-        self._obj = None\n-\n-\n-class _PoolConnectionContextManager:\n-    \"\"\"Context manager.\n-\n-    This enables the following idiom for acquiring and releasing a\n-    connection around a block:\n-\n-        async with pool as conn:\n-            cur = await conn.cursor()\n-\n-    while failing loudly when accidentally using:\n-\n-        with pool:\n-            <block>\n-    \"\"\"\n-\n-    __slots__ = ('_pool', '_conn')\n-\n-    def __init__(self, pool, conn):\n-        self._pool = pool\n-        self._conn = conn\n-\n-    def __enter__(self):\n-        assert self._conn\n-        return self._conn\n-\n-    def __exit__(self, exc_type, exc_val, exc_tb):\n-        try:\n-            self._pool.release(self._conn)\n-        finally:\n-            self._pool = None\n-            self._conn = None\n-\n-    async def __aenter__(self):\n-        assert not self._conn\n-        self._conn = await self._pool.acquire()\n-        return self._conn\n-\n-    async def __aexit__(self, exc_type, exc_val, exc_tb):\n-        try:\n-            await self._pool.release(self._conn)\n-        finally:\n-            self._pool = None\n-            self._conn = None\n-\n-\n-class _PoolCursorContextManager:\n-    \"\"\"Context manager.\n-\n-    This enables the following idiom for acquiring and releasing a\n-    cursor around a block:\n-\n-        async with pool.cursor() as cur:\n-            await cur.execute(\"SELECT 1\")\n-\n-    while failing loudly when accidentally using:\n-\n-        with pool:\n-            <block>\n-    \"\"\"\n-\n-    __slots__ = ('_pool', '_conn', '_cur')\n-\n-    def __init__(self, pool, conn, cur):\n-        self._pool = pool\n-        self._conn = conn\n-        self._cur = cur\n-\n-    def __enter__(self):\n-        return self._cur\n-\n-    def __exit__(self, *args):\n-        try:\n-            self._cur.close()\n-        except psycopg2.ProgrammingError:\n-            # seen instances where the cursor fails to close:\n-            #   https://github.com/aio-libs/aiopg/issues/364\n-            # We close it here so we don't return a bad connection to the pool\n-            self._conn.close()\n-            raise\n-        finally:\n-            try:\n-                self._pool.release(self._conn)\n-            finally:\n-                self._pool = None\n-                self._conn = None\n-                self._cur = None\n",
        "source_code_with_indent": "        <DED>try:\n            <IND>return await self._obj.__anext__()\n        <DED>except StopAsyncIteration:\n            <IND>self._obj.close()\n            self._obj = None\n            raise\n\n\n<DED><DED><DED>class _PoolContextManager(_ContextManager):\n    <IND>__slots__ = ()\n\n    async def __aexit__(self, exc_type, exc, tb):\n        <IND>self._obj.close()\n        await self._obj.wait_closed()\n        self._obj = None\n\n\n<DED><DED>class _TransactionPointContextManager(_ContextManager):\n    <IND>__slots__ = ()\n\n    async def __aexit__(self, exc_type, exc_val, exc_tb):\n        <IND>if exc_type is not None:\n            <IND>await self._obj.rollback_savepoint()\n        <DED>else:\n            <IND>await self._obj.release_savepoint()\n\n        <DED>self._obj = None\n\n\n<DED><DED>class _TransactionBeginContextManager(_ContextManager):\n    <IND>__slots__ = ()\n\n    async def __aexit__(self, exc_type, exc_val, exc_tb):\n        <IND>if exc_type is not None:\n            <IND>await self._obj.rollback()\n        <DED>else:\n            <IND>await self._obj.commit()\n\n        <DED>self._obj = None\n\n\n<DED><DED>class _TransactionContextManager(_ContextManager):\n    <IND>__slots__ = ()\n\n    async def __aexit__(self, exc_type, exc, tb):\n        <IND>if exc_type:\n            <IND>await self._obj.rollback()\n        <DED>else:\n            <IND>if self._obj.is_active:\n                <IND>await self._obj.commit()\n        <DED><DED>self._obj = None\n\n\n<DED><DED>class _PoolAcquireContextManager(_ContextManager):\n    <IND>__slots__ = ('_coro', '_obj', '_pool')\n\n    def __init__(self, coro, pool):\n        <IND>super().__init__(coro)\n        self._pool = pool\n\n    <DED>async def __aexit__(self, exc_type, exc, tb):\n        <IND>await self._pool.release(self._obj)\n        self._pool = None\n        self._obj = None\n\n\n<DED><DED>class _PoolConnectionContextManager:\n    <IND>\"\"\"Context manager.\n\n    This enables the following idiom for acquiring and releasing a\n    connection around a block:\n\n        async with pool as conn:\n            cur = await conn.cursor()\n\n    while failing loudly when accidentally using:\n\n        with pool:\n            <block>\n    \"\"\"\n\n    __slots__ = ('_pool', '_conn')\n\n    def __init__(self, pool, conn):\n        <IND>self._pool = pool\n        self._conn = conn\n\n    <DED>def __enter__(self):\n        <IND>assert self._conn\n        return self._conn\n\n    <DED>def __exit__(self, exc_type, exc_val, exc_tb):\n        <IND>try:\n            <IND>self._pool.release(self._conn)\n        <DED>finally:\n            <IND>self._pool = None\n            self._conn = None\n\n    <DED><DED>async def __aenter__(self):\n        <IND>assert not self._conn\n        self._conn = await self._pool.acquire()\n        return self._conn\n\n    <DED>async def __aexit__(self, exc_type, exc_val, exc_tb):\n        <IND>try:\n            <IND>await self._pool.release(self._conn)\n        <DED>finally:\n            <IND>self._pool = None\n            self._conn = None\n\n\n<DED><DED><DED>class _PoolCursorContextManager:\n    <IND>\"\"\"Context manager.\n\n    This enables the following idiom for acquiring and releasing a\n    cursor around a block:\n\n        async with pool.cursor() as cur:\n            await cur.execute(\"SELECT 1\")\n\n    while failing loudly when accidentally using:\n\n        with pool:\n            <block>\n    \"\"\"\n\n    __slots__ = ('_pool', '_conn', '_cur')\n\n    def __init__(self, pool, conn, cur):\n        <IND>self._pool = pool\n        self._conn = conn\n        self._cur = cur\n\n    <DED>def __enter__(self):\n        <IND>return self._cur\n\n    <DED>def __exit__(self, *args):\n        <IND>try:\n            <IND>self._cur.close()\n        <DED>except psycopg2.ProgrammingError:\n            # seen instances where the cursor fails to close:\n            #   https://github.com/aio-libs/aiopg/issues/364\n            # We close it here so we don't return a bad connection to the pool\n            <IND>self._conn.close()\n            raise\n        <DED>finally:\n            <IND>try:\n                <IND>self._pool.release(self._conn)\n            <DED>finally:\n                <IND>self._pool = None\n                self._conn = None\n                self._cur = None\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "        <DED>try:\n            <IND>return await self._obj.__anext__()  # type: ignore\n        <DED>except StopAsyncIteration:\n            <IND>try:\n                <IND>await self._release(self._obj)\n            <DED>finally:\n                <IND>self._obj = None\n            <DED>raise\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "aio-libs/aiopg",
    "commit": "187d13a06581054e1f910961b8238837e7c8bd0b",
    "filename": "aiopg/utils.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/aio-libs-aiopg/aiopg/utils.py",
    "file_hunks_size": 6,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": true,
    "full_warning_msg": "aiopg/utils.py:146:4 Inconsistent override [15]: `__slots__` overrides attribute defined in `_ContextManager` inconsistently. Type `typing.Tuple[str, str, str]` is not a subtype of the overridden attribute `typing.Tuple[str, str]`.",
    "message": " `__slots__` overrides attribute defined in `_ContextManager` inconsistently. Type `typing.Tuple[str, str, str]` is not a subtype of the overridden attribute `typing.Tuple[str, str]`.",
    "rule_id": "Inconsistent override [15]",
    "warning_line_no": 146,
    "warning_line": "    __slots__ = ('_coro', '_obj', '_pool')",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": true,
        "source_code": "        try:\n            return await self._obj.__anext__()\n        except StopAsyncIteration:\n            self._obj.close()\n            self._obj = None\n            raise\n\n\nclass _PoolContextManager(_ContextManager):\n    __slots__ = ()\n\n    async def __aexit__(self, exc_type, exc, tb):\n        self._obj.close()\n        await self._obj.wait_closed()\n        self._obj = None\n\n\nclass _TransactionPointContextManager(_ContextManager):\n    __slots__ = ()\n\n    async def __aexit__(self, exc_type, exc_val, exc_tb):\n        if exc_type is not None:\n            await self._obj.rollback_savepoint()\n        else:\n            await self._obj.release_savepoint()\n\n        self._obj = None\n\n\nclass _TransactionBeginContextManager(_ContextManager):\n    __slots__ = ()\n\n    async def __aexit__(self, exc_type, exc_val, exc_tb):\n        if exc_type is not None:\n            await self._obj.rollback()\n        else:\n            await self._obj.commit()\n\n        self._obj = None\n\n\nclass _TransactionContextManager(_ContextManager):\n    __slots__ = ()\n\n    async def __aexit__(self, exc_type, exc, tb):\n        if exc_type:\n            await self._obj.rollback()\n        else:\n            if self._obj.is_active:\n                await self._obj.commit()\n        self._obj = None\n\n\nclass _PoolAcquireContextManager(_ContextManager):\n    __slots__ = ('_coro', '_obj', '_pool')\n\n    def __init__(self, coro, pool):\n        super().__init__(coro)\n        self._pool = pool\n\n    async def __aexit__(self, exc_type, exc, tb):\n        await self._pool.release(self._obj)\n        self._pool = None\n        self._obj = None\n\n\nclass _PoolConnectionContextManager:\n    \"\"\"Context manager.\n\n    This enables the following idiom for acquiring and releasing a\n    connection around a block:\n\n        async with pool as conn:\n            cur = await conn.cursor()\n\n    while failing loudly when accidentally using:\n\n        with pool:\n            <block>\n    \"\"\"\n\n    __slots__ = ('_pool', '_conn')\n\n    def __init__(self, pool, conn):\n        self._pool = pool\n        self._conn = conn\n\n    def __enter__(self):\n        assert self._conn\n        return self._conn\n\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        try:\n            self._pool.release(self._conn)\n        finally:\n            self._pool = None\n            self._conn = None\n\n    async def __aenter__(self):\n        assert not self._conn\n        self._conn = await self._pool.acquire()\n        return self._conn\n\n    async def __aexit__(self, exc_type, exc_val, exc_tb):\n        try:\n            await self._pool.release(self._conn)\n        finally:\n            self._pool = None\n            self._conn = None\n\n\nclass _PoolCursorContextManager:\n    \"\"\"Context manager.\n\n    This enables the following idiom for acquiring and releasing a\n    cursor around a block:\n\n        async with pool.cursor() as cur:\n            await cur.execute(\"SELECT 1\")\n\n    while failing loudly when accidentally using:\n\n        with pool:\n            <block>\n    \"\"\"\n\n    __slots__ = ('_pool', '_conn', '_cur')\n\n    def __init__(self, pool, conn, cur):\n        self._pool = pool\n        self._conn = conn\n        self._cur = cur\n\n    def __enter__(self):\n        return self._cur\n\n    def __exit__(self, *args):\n        try:\n            self._cur.close()\n        except psycopg2.ProgrammingError:\n            # seen instances where the cursor fails to close:\n            #   https://github.com/aio-libs/aiopg/issues/364\n            # We close it here so we don't return a bad connection to the pool\n            self._conn.close()\n            raise\n        finally:\n            try:\n                self._pool.release(self._conn)\n            finally:\n                self._pool = None\n                self._conn = None\n                self._cur = None\n",
        "source_code_len": 3780,
        "target_code": "        try:\n            return await self._obj.__anext__()  # type: ignore\n        except StopAsyncIteration:\n            try:\n                await self._release(self._obj)\n            finally:\n                self._obj = None\n            raise\n",
        "target_code_len": 247,
        "diff_format": "@@ -92,152 +118,8 @@\n         try:\n-            return await self._obj.__anext__()\n+            return await self._obj.__anext__()  # type: ignore\n         except StopAsyncIteration:\n-            self._obj.close()\n-            self._obj = None\n+            try:\n+                await self._release(self._obj)\n+            finally:\n+                self._obj = None\n             raise\n-\n-\n-class _PoolContextManager(_ContextManager):\n-    __slots__ = ()\n-\n-    async def __aexit__(self, exc_type, exc, tb):\n-        self._obj.close()\n-        await self._obj.wait_closed()\n-        self._obj = None\n-\n-\n-class _TransactionPointContextManager(_ContextManager):\n-    __slots__ = ()\n-\n-    async def __aexit__(self, exc_type, exc_val, exc_tb):\n-        if exc_type is not None:\n-            await self._obj.rollback_savepoint()\n-        else:\n-            await self._obj.release_savepoint()\n-\n-        self._obj = None\n-\n-\n-class _TransactionBeginContextManager(_ContextManager):\n-    __slots__ = ()\n-\n-    async def __aexit__(self, exc_type, exc_val, exc_tb):\n-        if exc_type is not None:\n-            await self._obj.rollback()\n-        else:\n-            await self._obj.commit()\n-\n-        self._obj = None\n-\n-\n-class _TransactionContextManager(_ContextManager):\n-    __slots__ = ()\n-\n-    async def __aexit__(self, exc_type, exc, tb):\n-        if exc_type:\n-            await self._obj.rollback()\n-        else:\n-            if self._obj.is_active:\n-                await self._obj.commit()\n-        self._obj = None\n-\n-\n-class _PoolAcquireContextManager(_ContextManager):\n-    __slots__ = ('_coro', '_obj', '_pool')\n-\n-    def __init__(self, coro, pool):\n-        super().__init__(coro)\n-        self._pool = pool\n-\n-    async def __aexit__(self, exc_type, exc, tb):\n-        await self._pool.release(self._obj)\n-        self._pool = None\n-        self._obj = None\n-\n-\n-class _PoolConnectionContextManager:\n-    \"\"\"Context manager.\n-\n-    This enables the following idiom for acquiring and releasing a\n-    connection around a block:\n-\n-        async with pool as conn:\n-            cur = await conn.cursor()\n-\n-    while failing loudly when accidentally using:\n-\n-        with pool:\n-            <block>\n-    \"\"\"\n-\n-    __slots__ = ('_pool', '_conn')\n-\n-    def __init__(self, pool, conn):\n-        self._pool = pool\n-        self._conn = conn\n-\n-    def __enter__(self):\n-        assert self._conn\n-        return self._conn\n-\n-    def __exit__(self, exc_type, exc_val, exc_tb):\n-        try:\n-            self._pool.release(self._conn)\n-        finally:\n-            self._pool = None\n-            self._conn = None\n-\n-    async def __aenter__(self):\n-        assert not self._conn\n-        self._conn = await self._pool.acquire()\n-        return self._conn\n-\n-    async def __aexit__(self, exc_type, exc_val, exc_tb):\n-        try:\n-            await self._pool.release(self._conn)\n-        finally:\n-            self._pool = None\n-            self._conn = None\n-\n-\n-class _PoolCursorContextManager:\n-    \"\"\"Context manager.\n-\n-    This enables the following idiom for acquiring and releasing a\n-    cursor around a block:\n-\n-        async with pool.cursor() as cur:\n-            await cur.execute(\"SELECT 1\")\n-\n-    while failing loudly when accidentally using:\n-\n-        with pool:\n-            <block>\n-    \"\"\"\n-\n-    __slots__ = ('_pool', '_conn', '_cur')\n-\n-    def __init__(self, pool, conn, cur):\n-        self._pool = pool\n-        self._conn = conn\n-        self._cur = cur\n-\n-    def __enter__(self):\n-        return self._cur\n-\n-    def __exit__(self, *args):\n-        try:\n-            self._cur.close()\n-        except psycopg2.ProgrammingError:\n-            # seen instances where the cursor fails to close:\n-            #   https://github.com/aio-libs/aiopg/issues/364\n-            # We close it here so we don't return a bad connection to the pool\n-            self._conn.close()\n-            raise\n-        finally:\n-            try:\n-                self._pool.release(self._conn)\n-            finally:\n-                self._pool = None\n-                self._conn = None\n-                self._cur = None\n",
        "source_code_with_indent": "        <DED>try:\n            <IND>return await self._obj.__anext__()\n        <DED>except StopAsyncIteration:\n            <IND>self._obj.close()\n            self._obj = None\n            raise\n\n\n<DED><DED><DED>class _PoolContextManager(_ContextManager):\n    <IND>__slots__ = ()\n\n    async def __aexit__(self, exc_type, exc, tb):\n        <IND>self._obj.close()\n        await self._obj.wait_closed()\n        self._obj = None\n\n\n<DED><DED>class _TransactionPointContextManager(_ContextManager):\n    <IND>__slots__ = ()\n\n    async def __aexit__(self, exc_type, exc_val, exc_tb):\n        <IND>if exc_type is not None:\n            <IND>await self._obj.rollback_savepoint()\n        <DED>else:\n            <IND>await self._obj.release_savepoint()\n\n        <DED>self._obj = None\n\n\n<DED><DED>class _TransactionBeginContextManager(_ContextManager):\n    <IND>__slots__ = ()\n\n    async def __aexit__(self, exc_type, exc_val, exc_tb):\n        <IND>if exc_type is not None:\n            <IND>await self._obj.rollback()\n        <DED>else:\n            <IND>await self._obj.commit()\n\n        <DED>self._obj = None\n\n\n<DED><DED>class _TransactionContextManager(_ContextManager):\n    <IND>__slots__ = ()\n\n    async def __aexit__(self, exc_type, exc, tb):\n        <IND>if exc_type:\n            <IND>await self._obj.rollback()\n        <DED>else:\n            <IND>if self._obj.is_active:\n                <IND>await self._obj.commit()\n        <DED><DED>self._obj = None\n\n\n<DED><DED>class _PoolAcquireContextManager(_ContextManager):\n    <IND>__slots__ = ('_coro', '_obj', '_pool')\n\n    def __init__(self, coro, pool):\n        <IND>super().__init__(coro)\n        self._pool = pool\n\n    <DED>async def __aexit__(self, exc_type, exc, tb):\n        <IND>await self._pool.release(self._obj)\n        self._pool = None\n        self._obj = None\n\n\n<DED><DED>class _PoolConnectionContextManager:\n    <IND>\"\"\"Context manager.\n\n    This enables the following idiom for acquiring and releasing a\n    connection around a block:\n\n        async with pool as conn:\n            cur = await conn.cursor()\n\n    while failing loudly when accidentally using:\n\n        with pool:\n            <block>\n    \"\"\"\n\n    __slots__ = ('_pool', '_conn')\n\n    def __init__(self, pool, conn):\n        <IND>self._pool = pool\n        self._conn = conn\n\n    <DED>def __enter__(self):\n        <IND>assert self._conn\n        return self._conn\n\n    <DED>def __exit__(self, exc_type, exc_val, exc_tb):\n        <IND>try:\n            <IND>self._pool.release(self._conn)\n        <DED>finally:\n            <IND>self._pool = None\n            self._conn = None\n\n    <DED><DED>async def __aenter__(self):\n        <IND>assert not self._conn\n        self._conn = await self._pool.acquire()\n        return self._conn\n\n    <DED>async def __aexit__(self, exc_type, exc_val, exc_tb):\n        <IND>try:\n            <IND>await self._pool.release(self._conn)\n        <DED>finally:\n            <IND>self._pool = None\n            self._conn = None\n\n\n<DED><DED><DED>class _PoolCursorContextManager:\n    <IND>\"\"\"Context manager.\n\n    This enables the following idiom for acquiring and releasing a\n    cursor around a block:\n\n        async with pool.cursor() as cur:\n            await cur.execute(\"SELECT 1\")\n\n    while failing loudly when accidentally using:\n\n        with pool:\n            <block>\n    \"\"\"\n\n    __slots__ = ('_pool', '_conn', '_cur')\n\n    def __init__(self, pool, conn, cur):\n        <IND>self._pool = pool\n        self._conn = conn\n        self._cur = cur\n\n    <DED>def __enter__(self):\n        <IND>return self._cur\n\n    <DED>def __exit__(self, *args):\n        <IND>try:\n            <IND>self._cur.close()\n        <DED>except psycopg2.ProgrammingError:\n            # seen instances where the cursor fails to close:\n            #   https://github.com/aio-libs/aiopg/issues/364\n            # We close it here so we don't return a bad connection to the pool\n            <IND>self._conn.close()\n            raise\n        <DED>finally:\n            <IND>try:\n                <IND>self._pool.release(self._conn)\n            <DED>finally:\n                <IND>self._pool = None\n                self._conn = None\n                self._cur = None\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "        <DED>try:\n            <IND>return await self._obj.__anext__()  # type: ignore\n        <DED>except StopAsyncIteration:\n            <IND>try:\n                <IND>await self._release(self._obj)\n            <DED>finally:\n                <IND>self._obj = None\n            <DED>raise\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  }
]