[
  {
    "project": "HuyaneMatsu/hata",
    "commit": "6c11e330415e5bdc03a62de5c58e366fd74eee2a",
    "filename": "hata/discord/player.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/HuyaneMatsu-hata/hata/discord/player.py",
    "file_hunks_size": 36,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "hata/discord/player.py:154:4 Inconsistent override [15]: `__slots__` overrides attribute defined in `AudioSource` inconsistently. Type `typing.Tuple[str, str, str]` is not a subtype of the overridden attribute `typing.Tuple[]`.",
    "message": " `__slots__` overrides attribute defined in `AudioSource` inconsistently. Type `typing.Tuple[str, str, str]` is not a subtype of the overridden attribute `typing.Tuple[]`.",
    "rule_id": "Inconsistent override [15]",
    "warning_line_no": 154,
    "warning_line": "    __slots__ = ('process', 'source', 'stdout',)",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "        Whether the source is not opus encoded.\n    TEMPORARY : `bool` = `False`\n        Whether the audio's source is a temporary file.\n    \"\"\"\n    __slots__ = ('process', 'source', 'stdout',)\n    \n    #use __new__, so __del__ wont run\n    def __new__(cls, source, executable='ffmpeg', pipe=False, stderr=None, before_options=(), options=(),):\n        \"\"\"\n        Creates a new ``FFmpegPCMAudio`` instance.\n        \n",
        "source_code_len": 417,
        "target_code": "        Whether the source is not opus encoded.\n    \"\"\"\n    @staticmethod\n    def _create_process_preprocess(source, executable, pipe, before_options, options):\n        \"\"\"\n        Creates a a subprocess instance to the given source.\n        \n",
        "target_code_len": 243,
        "diff_format": "@@ -150,11 +165,7 @@\n         Whether the source is not opus encoded.\n-    TEMPORARY : `bool` = `False`\n-        Whether the audio's source is a temporary file.\n     \"\"\"\n-    __slots__ = ('process', 'source', 'stdout',)\n-    \n-    #use __new__, so __del__ wont run\n-    def __new__(cls, source, executable='ffmpeg', pipe=False, stderr=None, before_options=(), options=(),):\n-        \"\"\"\n-        Creates a new ``FFmpegPCMAudio`` instance.\n+    @staticmethod\n+    def _create_process_preprocess(source, executable, pipe, before_options, options):\n+        \"\"\"\n+        Creates a a subprocess instance to the given source.\n         \n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\n    __slots__ = ('process', 'source', 'stdout',)\n    \n    #use __new__, so __del__ wont run\n    def __new__(cls, source, executable='ffmpeg', pipe=False, stderr=None, before_options=(), options=(),):\n        <IND>",
        "target_code_with_indent": "\n    @staticmethod\n    def _create_process_preprocess(source, executable, pipe, before_options, options):\n        <IND>"
      }
    ]
  },
  {
    "project": "HuyaneMatsu/hata",
    "commit": "6c11e330415e5bdc03a62de5c58e366fd74eee2a",
    "filename": "hata/discord/player.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/HuyaneMatsu-hata/hata/discord/player.py",
    "file_hunks_size": 36,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "hata/discord/player.py:291:4 Inconsistent override [15]: `__slots__` overrides attribute defined in `AudioSource` inconsistently. Type `typing.Tuple[str, str, str]` is not a subtype of the overridden attribute `typing.Tuple[]`.",
    "message": " `__slots__` overrides attribute defined in `AudioSource` inconsistently. Type `typing.Tuple[str, str, str]` is not a subtype of the overridden attribute `typing.Tuple[]`.",
    "rule_id": "Inconsistent override [15]",
    "warning_line_no": 291,
    "warning_line": "    __slots__ = ('original', 'title', 'volume',)",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "        \"\"\"\n        result=self.stream.read(FRAME_SIZE)\n        if len(result)!=FRAME_SIZE:\n            return None\n        return result\n\nclass FFmpegPCMAudio(AudioSource):\n    \"\"\"\n",
        "source_code_len": 182,
        "target_code": "        \"\"\"\n        result = self.stream.read(FRAME_SIZE)\n        if (result is not None) and len(result)!=FRAME_SIZE:\n            result = None\n        return result\n\nclass LocalAudio(AudioSource):\n    \"\"\"\n",
        "target_code_len": 207,
        "diff_format": "@@ -126,8 +137,8 @@\n         \"\"\"\n-        result=self.stream.read(FRAME_SIZE)\n-        if len(result)!=FRAME_SIZE:\n-            return None\n+        result = self.stream.read(FRAME_SIZE)\n+        if (result is not None) and len(result)!=FRAME_SIZE:\n+            result = None\n         return result\n \n-class FFmpegPCMAudio(AudioSource):\n+class LocalAudio(AudioSource):\n     \"\"\"\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\n        result=self.stream.read(FRAME_SIZE)\n        if len(result)!=FRAME_SIZE:\n            <IND>return None\n        <DED>return result\n\n<DED><DED>class FFmpegPCMAudio(AudioSource):\n    <IND>",
        "target_code_with_indent": "\n        result = self.stream.read(FRAME_SIZE)\n        if (result is not None) and len(result)!=FRAME_SIZE:\n            <IND>result = None\n        <DED>return result\n\n<DED><DED>class LocalAudio(AudioSource):\n    <IND>"
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "        Whether the source is not opus encoded.\n    TEMPORARY : `bool` = `False`\n        Whether the audio's source is a temporary file.\n    \"\"\"\n    __slots__ = ('process', 'source', 'stdout',)\n    \n    #use __new__, so __del__ wont run\n    def __new__(cls, source, executable='ffmpeg', pipe=False, stderr=None, before_options=(), options=(),):\n        \"\"\"\n        Creates a new ``FFmpegPCMAudio`` instance.\n        \n",
        "source_code_len": 417,
        "target_code": "        Whether the source is not opus encoded.\n    \"\"\"\n    @staticmethod\n    def _create_process_preprocess(source, executable, pipe, before_options, options):\n        \"\"\"\n        Creates a a subprocess instance to the given source.\n        \n",
        "target_code_len": 243,
        "diff_format": "@@ -150,11 +165,7 @@\n         Whether the source is not opus encoded.\n-    TEMPORARY : `bool` = `False`\n-        Whether the audio's source is a temporary file.\n     \"\"\"\n-    __slots__ = ('process', 'source', 'stdout',)\n-    \n-    #use __new__, so __del__ wont run\n-    def __new__(cls, source, executable='ffmpeg', pipe=False, stderr=None, before_options=(), options=(),):\n-        \"\"\"\n-        Creates a new ``FFmpegPCMAudio`` instance.\n+    @staticmethod\n+    def _create_process_preprocess(source, executable, pipe, before_options, options):\n+        \"\"\"\n+        Creates a a subprocess instance to the given source.\n         \n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\n    __slots__ = ('process', 'source', 'stdout',)\n    \n    #use __new__, so __del__ wont run\n    def __new__(cls, source, executable='ffmpeg', pipe=False, stderr=None, before_options=(), options=(),):\n        <IND>",
        "target_code_with_indent": "\n    @staticmethod\n    def _create_process_preprocess(source, executable, pipe, before_options, options):\n        <IND>"
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "            process.communicate()\n\n        self.process=None\n\n    def parse_title(self):\n        \"\"\"\n        Parses and returns the audio source's title.\n        \n        Returns\n        -------\n        title : `str`\n        \"\"\"\n        _,name=os.path.split(self.source)\n        index=name.rfind('.')\n        if index<0:\n            return name\n        return name[:index]\n    \nclass PCMVolumeTransformer(AudioSource):\n    \"\"\"\n    Volume transformer what wraps an other ``AudioSource`` instance.\n    \n    Attributes\n    ----------\n    original : ``AudioSource`` instance\n        The wrapped audio source.\n    volume : `float`\n        The volume multiplier.\n    \n    Class Attributes\n    ----------------\n    NEEDS_ENCODE : `bool` = `True`\n        Whether the source is not opus encoded.\n    TEMPORARY : `bool` = `False`\n        Whether the audio's source is a temporary file.\n    \"\"\"\n    __slots__ = ('original', 'title', 'volume',)\n    \n    def __new__(cls, original):\n        \"\"\"\n        Creates a new `PCMVolumeTransformer` from the given audio source.\n        \n        Parameters\n        ----------\n        original : ``AudioSource`` instance.\n            The audio source to wrap.\n        \n        Returns\n        -------\n        self : ``PCMVolumeTransformer``\n        \n        Raises\n        ------\n        TypeError\n            `original` is not `AudioSource` instance.\n        ValueError\n            `original` is opus encoded.\n        \"\"\"\n        if not isinstance(original, AudioSource):\n            raise TypeError(f'`original` can be `{AudioSource.__name__}` instance, got {original.__class__.__name__}.')\n        \n        if not original.NEEDS_ENCODE:\n            raise ValueError('`original` must not be Opus encoded.')\n        \n        self = object.__new__(cls)\n        \n        self.original   = original\n        self.volume     = 1.0 #max volume is 2.0\n        self.title      = original.parse_title()\n        \n        return self\n    \n    def cleanup(self):\n        \"\"\"\n        Cleans up ``.original`.\n        \"\"\"\n        original = self.original\n        if original is None:\n            return\n        \n        original.cleanup()\n    \n    def read(self):\n        \"\"\"\n        Reads ``.original`` and transforms it's volume.\n        \n        Indicates end of stream by returning zero `None`.\n        \n        Returns\n        -------\n        audio_data : `bytes` or `None`\n        \"\"\"\n        audio_data = self.original.read()\n        if (audio_data is not None):\n            audio_data = audioop.mul(audio_data, 2, self.volume)\n        \n        return audio_data\n    \n    def parse_title(self):\n        \"\"\"\n        Returns the original audio source's title.\n        \n        Returns\n        -------\n        title : `str`\n        \"\"\"\n        return self.original.parse_title()\n\nasync def LocalAudio(path):\n    \"\"\"\n    Provides an easy async way to open a local audio file.\n    \n    Parameters\n    ----------\n    path : `str`\n        Path of the audio file.\n    \n    Returns\n    -------\n    audio_source : ``PCMVolumeTransformer``\n    \n    Raises\n    ------\n    RuntimeError\n        Was not called from an `EventThread`.\n    ValueError\n        - Executable as not found.\n        - Popen failed.\n    \"\"\"\n    loop = current_thread()\n    if not isinstance(loop,EventThread):\n        raise RuntimeError(f'LocalAudio({path!r},...) was called from a non {EventThread.__name__}: {loop!r}.')\n        \n    source = await loop.run_in_executor(alchemy_incendiary(FFmpegPCMAudio,(path,)))\n    return PCMVolumeTransformer(source)\n\ntry:\n",
        "source_code_len": 3540,
        "target_code": "            process.communicate()\n        \n        self._stdout = None\n        self.process = None\n \ntry:\n",
        "target_code_len": 106,
        "diff_format": "@@ -255,137 +390,6 @@\n             process.communicate()\n-\n-        self.process=None\n-\n-    def parse_title(self):\n-        \"\"\"\n-        Parses and returns the audio source's title.\n-        \n-        Returns\n-        -------\n-        title : `str`\n-        \"\"\"\n-        _,name=os.path.split(self.source)\n-        index=name.rfind('.')\n-        if index<0:\n-            return name\n-        return name[:index]\n-    \n-class PCMVolumeTransformer(AudioSource):\n-    \"\"\"\n-    Volume transformer what wraps an other ``AudioSource`` instance.\n-    \n-    Attributes\n-    ----------\n-    original : ``AudioSource`` instance\n-        The wrapped audio source.\n-    volume : `float`\n-        The volume multiplier.\n-    \n-    Class Attributes\n-    ----------------\n-    NEEDS_ENCODE : `bool` = `True`\n-        Whether the source is not opus encoded.\n-    TEMPORARY : `bool` = `False`\n-        Whether the audio's source is a temporary file.\n-    \"\"\"\n-    __slots__ = ('original', 'title', 'volume',)\n-    \n-    def __new__(cls, original):\n-        \"\"\"\n-        Creates a new `PCMVolumeTransformer` from the given audio source.\n-        \n-        Parameters\n-        ----------\n-        original : ``AudioSource`` instance.\n-            The audio source to wrap.\n-        \n-        Returns\n-        -------\n-        self : ``PCMVolumeTransformer``\n-        \n-        Raises\n-        ------\n-        TypeError\n-            `original` is not `AudioSource` instance.\n-        ValueError\n-            `original` is opus encoded.\n-        \"\"\"\n-        if not isinstance(original, AudioSource):\n-            raise TypeError(f'`original` can be `{AudioSource.__name__}` instance, got {original.__class__.__name__}.')\n-        \n-        if not original.NEEDS_ENCODE:\n-            raise ValueError('`original` must not be Opus encoded.')\n-        \n-        self = object.__new__(cls)\n-        \n-        self.original   = original\n-        self.volume     = 1.0 #max volume is 2.0\n-        self.title      = original.parse_title()\n-        \n-        return self\n-    \n-    def cleanup(self):\n-        \"\"\"\n-        Cleans up ``.original`.\n-        \"\"\"\n-        original = self.original\n-        if original is None:\n-            return\n-        \n-        original.cleanup()\n-    \n-    def read(self):\n-        \"\"\"\n-        Reads ``.original`` and transforms it's volume.\n-        \n-        Indicates end of stream by returning zero `None`.\n-        \n-        Returns\n-        -------\n-        audio_data : `bytes` or `None`\n-        \"\"\"\n-        audio_data = self.original.read()\n-        if (audio_data is not None):\n-            audio_data = audioop.mul(audio_data, 2, self.volume)\n-        \n-        return audio_data\n-    \n-    def parse_title(self):\n-        \"\"\"\n-        Returns the original audio source's title.\n-        \n-        Returns\n-        -------\n-        title : `str`\n-        \"\"\"\n-        return self.original.parse_title()\n-\n-async def LocalAudio(path):\n-    \"\"\"\n-    Provides an easy async way to open a local audio file.\n-    \n-    Parameters\n-    ----------\n-    path : `str`\n-        Path of the audio file.\n-    \n-    Returns\n-    -------\n-    audio_source : ``PCMVolumeTransformer``\n-    \n-    Raises\n-    ------\n-    RuntimeError\n-        Was not called from an `EventThread`.\n-    ValueError\n-        - Executable as not found.\n-        - Popen failed.\n-    \"\"\"\n-    loop = current_thread()\n-    if not isinstance(loop,EventThread):\n-        raise RuntimeError(f'LocalAudio({path!r},...) was called from a non {EventThread.__name__}: {loop!r}.')\n-        \n-    source = await loop.run_in_executor(alchemy_incendiary(FFmpegPCMAudio,(path,)))\n-    return PCMVolumeTransformer(source)\n-\n+        \n+        self._stdout = None\n+        self.process = None\n+ \n try:\n",
        "source_code_with_indent": "            <IND>process.communicate()\n\n        <DED>self.process=None\n\n    <DED>def parse_title(self):\n        <IND>\"\"\"\n        Parses and returns the audio source's title.\n        \n        Returns\n        -------\n        title : `str`\n        \"\"\"\n        _,name=os.path.split(self.source)\n        index=name.rfind('.')\n        if index<0:\n            <IND>return name\n        <DED>return name[:index]\n    \n<DED><DED>class PCMVolumeTransformer(AudioSource):\n    <IND>\"\"\"\n    Volume transformer what wraps an other ``AudioSource`` instance.\n    \n    Attributes\n    ----------\n    original : ``AudioSource`` instance\n        The wrapped audio source.\n    volume : `float`\n        The volume multiplier.\n    \n    Class Attributes\n    ----------------\n    NEEDS_ENCODE : `bool` = `True`\n        Whether the source is not opus encoded.\n    TEMPORARY : `bool` = `False`\n        Whether the audio's source is a temporary file.\n    \"\"\"\n    __slots__ = ('original', 'title', 'volume',)\n    \n    def __new__(cls, original):\n        <IND>\"\"\"\n        Creates a new `PCMVolumeTransformer` from the given audio source.\n        \n        Parameters\n        ----------\n        original : ``AudioSource`` instance.\n            The audio source to wrap.\n        \n        Returns\n        -------\n        self : ``PCMVolumeTransformer``\n        \n        Raises\n        ------\n        TypeError\n            `original` is not `AudioSource` instance.\n        ValueError\n            `original` is opus encoded.\n        \"\"\"\n        if not isinstance(original, AudioSource):\n            <IND>raise TypeError(f'`original` can be `{AudioSource.__name__}` instance, got {original.__class__.__name__}.')\n        \n        <DED>if not original.NEEDS_ENCODE:\n            <IND>raise ValueError('`original` must not be Opus encoded.')\n        \n        <DED>self = object.__new__(cls)\n        \n        self.original   = original\n        self.volume     = 1.0 #max volume is 2.0\n        self.title      = original.parse_title()\n        \n        return self\n    \n    <DED>def cleanup(self):\n        <IND>\"\"\"\n        Cleans up ``.original`.\n        \"\"\"\n        original = self.original\n        if original is None:\n            <IND>return\n        \n        <DED>original.cleanup()\n    \n    <DED>def read(self):\n        <IND>\"\"\"\n        Reads ``.original`` and transforms it's volume.\n        \n        Indicates end of stream by returning zero `None`.\n        \n        Returns\n        -------\n        audio_data : `bytes` or `None`\n        \"\"\"\n        audio_data = self.original.read()\n        if (audio_data is not None):\n            <IND>audio_data = audioop.mul(audio_data, 2, self.volume)\n        \n        <DED>return audio_data\n    \n    <DED>def parse_title(self):\n        <IND>\"\"\"\n        Returns the original audio source's title.\n        \n        Returns\n        -------\n        title : `str`\n        \"\"\"\n        return self.original.parse_title()\n\n<DED><DED>async def LocalAudio(path):\n    <IND>\"\"\"\n    Provides an easy async way to open a local audio file.\n    \n    Parameters\n    ----------\n    path : `str`\n        Path of the audio file.\n    \n    Returns\n    -------\n    audio_source : ``PCMVolumeTransformer``\n    \n    Raises\n    ------\n    RuntimeError\n        Was not called from an `EventThread`.\n    ValueError\n        - Executable as not found.\n        - Popen failed.\n    \"\"\"\n    loop = current_thread()\n    if not isinstance(loop,EventThread):\n        <IND>raise RuntimeError(f'LocalAudio({path!r},...) was called from a non {EventThread.__name__}: {loop!r}.')\n        \n    <DED>source = await loop.run_in_executor(alchemy_incendiary(FFmpegPCMAudio,(path,)))\n    return PCMVolumeTransformer(source)\n\n<DED>try:\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "            <IND>process.communicate()\n        \n        <DED>self._stdout = None\n        self.process = None\n \n<DED><DED>try:\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "            })\n        \n    class YTAudio(PCMVolumeTransformer):\n        \"\"\"\n",
        "source_code_len": 77,
        "target_code": "            })\n    \n    class YTAudio(LocalAudio):\n        \"\"\"\n",
        "target_code_len": 63,
        "diff_format": "@@ -413,4 +417,4 @@\n             })\n-        \n-    class YTAudio(PCMVolumeTransformer):\n+    \n+    class YTAudio(LocalAudio):\n         \"\"\"\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "            })\n        \n    class YTAudio(PCMVolumeTransformer):\n        <IND>",
        "target_code_with_indent": "            })\n    \n    class YTAudio(LocalAudio):\n        <IND>"
      }
    ]
  },
  {
    "project": "HuyaneMatsu/hata",
    "commit": "6c11e330415e5bdc03a62de5c58e366fd74eee2a",
    "filename": "hata/discord/player.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/HuyaneMatsu-hata/hata/discord/player.py",
    "file_hunks_size": 36,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "hata/discord/player.py:439:8 Inconsistent override [15]: `__slots__` overrides attribute defined in `PCMVolumeTransformer` inconsistently. Type `typing.Tuple[str, str, str, str, str]` is not a subtype of the overridden attribute `typing.Tuple[str, str, str]`.",
    "message": " `__slots__` overrides attribute defined in `PCMVolumeTransformer` inconsistently. Type `typing.Tuple[str, str, str, str, str]` is not a subtype of the overridden attribute `typing.Tuple[str, str, str]`.",
    "rule_id": "Inconsistent override [15]",
    "warning_line_no": 439,
    "warning_line": "        __slots__=('delete', 'original', 'title', 'url', 'volume',)",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "        \"\"\"\n        result=self.stream.read(FRAME_SIZE)\n        if len(result)!=FRAME_SIZE:\n            return None\n        return result\n\nclass FFmpegPCMAudio(AudioSource):\n    \"\"\"\n",
        "source_code_len": 182,
        "target_code": "        \"\"\"\n        result = self.stream.read(FRAME_SIZE)\n        if (result is not None) and len(result)!=FRAME_SIZE:\n            result = None\n        return result\n\nclass LocalAudio(AudioSource):\n    \"\"\"\n",
        "target_code_len": 207,
        "diff_format": "@@ -126,8 +137,8 @@\n         \"\"\"\n-        result=self.stream.read(FRAME_SIZE)\n-        if len(result)!=FRAME_SIZE:\n-            return None\n+        result = self.stream.read(FRAME_SIZE)\n+        if (result is not None) and len(result)!=FRAME_SIZE:\n+            result = None\n         return result\n \n-class FFmpegPCMAudio(AudioSource):\n+class LocalAudio(AudioSource):\n     \"\"\"\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\n        result=self.stream.read(FRAME_SIZE)\n        if len(result)!=FRAME_SIZE:\n            <IND>return None\n        <DED>return result\n\n<DED><DED>class FFmpegPCMAudio(AudioSource):\n    <IND>",
        "target_code_with_indent": "\n        result = self.stream.read(FRAME_SIZE)\n        if (result is not None) and len(result)!=FRAME_SIZE:\n            <IND>result = None\n        <DED>return result\n\n<DED><DED>class LocalAudio(AudioSource):\n    <IND>"
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "        Whether the source is not opus encoded.\n    TEMPORARY : `bool` = `False`\n        Whether the audio's source is a temporary file.\n    \"\"\"\n    __slots__ = ('process', 'source', 'stdout',)\n    \n    #use __new__, so __del__ wont run\n    def __new__(cls, source, executable='ffmpeg', pipe=False, stderr=None, before_options=(), options=(),):\n        \"\"\"\n        Creates a new ``FFmpegPCMAudio`` instance.\n        \n",
        "source_code_len": 417,
        "target_code": "        Whether the source is not opus encoded.\n    \"\"\"\n    @staticmethod\n    def _create_process_preprocess(source, executable, pipe, before_options, options):\n        \"\"\"\n        Creates a a subprocess instance to the given source.\n        \n",
        "target_code_len": 243,
        "diff_format": "@@ -150,11 +165,7 @@\n         Whether the source is not opus encoded.\n-    TEMPORARY : `bool` = `False`\n-        Whether the audio's source is a temporary file.\n     \"\"\"\n-    __slots__ = ('process', 'source', 'stdout',)\n-    \n-    #use __new__, so __del__ wont run\n-    def __new__(cls, source, executable='ffmpeg', pipe=False, stderr=None, before_options=(), options=(),):\n-        \"\"\"\n-        Creates a new ``FFmpegPCMAudio`` instance.\n+    @staticmethod\n+    def _create_process_preprocess(source, executable, pipe, before_options, options):\n+        \"\"\"\n+        Creates a a subprocess instance to the given source.\n         \n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\n    __slots__ = ('process', 'source', 'stdout',)\n    \n    #use __new__, so __del__ wont run\n    def __new__(cls, source, executable='ffmpeg', pipe=False, stderr=None, before_options=(), options=(),):\n        <IND>",
        "target_code_with_indent": "\n    @staticmethod\n    def _create_process_preprocess(source, executable, pipe, before_options, options):\n        <IND>"
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "            })\n        \n    class YTAudio(PCMVolumeTransformer):\n        \"\"\"\n",
        "source_code_len": 77,
        "target_code": "            })\n    \n    class YTAudio(LocalAudio):\n        \"\"\"\n",
        "target_code_len": 63,
        "diff_format": "@@ -413,4 +417,4 @@\n             })\n-        \n-    class YTAudio(PCMVolumeTransformer):\n+    \n+    class YTAudio(LocalAudio):\n         \"\"\"\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "            })\n        \n    class YTAudio(PCMVolumeTransformer):\n        <IND>",
        "target_code_with_indent": "            })\n    \n    class YTAudio(LocalAudio):\n        <IND>"
      }
    ]
  }
]