[
  {
    "project": "ConsenSys/mythril",
    "commit": "eaebc2361f02bbbb8e5fedec6967e623f5ee2949",
    "filename": "mythril/laser/smt/bitvec.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/ConsenSys-mythril/mythril/laser/smt/bitvec.py",
    "file_hunks_size": 2,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": true,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "mythril/laser/smt/bitvec.py:401:8 Incompatible variable type [9]: bvs is declared to have type `List[BitVec]` but is used as type `Union[List[BitVec], BitVec]`.",
    "message": " bvs is declared to have type `List[BitVec]` but is used as type `Union[List[BitVec], BitVec]`.",
    "rule_id": "Incompatible variable type [9]",
    "warning_line_no": 401,
    "warning_line": "        bvs = args[0]  # type: List[BitVec]",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": true,
        "has_suppression": false,
        "source_code": "\ndef _comparison_helper(\n    a: BitVec, b: BitVec, operation: Callable, default_value: bool, inputs_equal: bool\n) -> Bool:\n    annotations = a.annotations.union(b.annotations)\n    if isinstance(a, BitVecFunc):\n        if not a.symbolic and not b.symbolic:\n            return Bool(operation(a.raw, b.raw), annotations=annotations)\n\n        if (\n            not isinstance(b, BitVecFunc)\n            or not a.func_name\n            or not a.input_\n            or not a.func_name == b.func_name\n        ):\n            return Bool(z3.BoolVal(default_value), annotations=annotations)\n\n        return And(\n            Bool(operation(a.raw, b.raw), annotations=annotations),\n            a.input_ == b.input_ if inputs_equal else a.input_ != b.input_,\n        )\n\n    return Bool(operation(a.raw, b.raw), annotations)\n\n\ndef _arithmetic_helper(a: BitVec, b: BitVec, operation: Callable) -> BitVec:\n    raw = operation(a.raw, b.raw)\n    union = a.annotations.union(b.annotations)\n\n    if isinstance(a, BitVecFunc) and isinstance(b, BitVecFunc):\n        return BitVecFunc(raw=raw, func_name=None, input_=None, annotations=union)\n    elif isinstance(a, BitVecFunc):\n        return BitVecFunc(\n            raw=raw, func_name=a.func_name, input_=a.input_, annotations=union\n        )\n    elif isinstance(b, BitVecFunc):\n        return BitVecFunc(\n            raw=raw, func_name=b.func_name, input_=b.input_, annotations=union\n        )\n\n    return BitVec(raw, annotations=union)\n\n\ndef LShR(a: BitVec, b: BitVec):\n    return _arithmetic_helper(a, b, z3.LShR)\n\n\ndef If(a: Union[Bool, bool], b: Union[BitVec, int], c: Union[BitVec, int]) -> BitVec:\n    \"\"\"Create an if-then-else expression.\n\n    :param a:\n    :param b:\n    :param c:\n    :return:\n    \"\"\"\n    # TODO: Handle BitVecFunc\n\n    if not isinstance(a, Bool):\n        a = Bool(z3.BoolVal(a))\n    if not isinstance(b, BitVec):\n        b = BitVec(z3.BitVecVal(b, 256))\n    if not isinstance(c, BitVec):\n        c = BitVec(z3.BitVecVal(c, 256))\n    union = a.annotations.union(b.annotations).union(c.annotations)\n    return BitVec(z3.If(a.raw, b.raw, c.raw), union)\n\n\ndef UGT(a: BitVec, b: BitVec) -> Bool:\n    \"\"\"Create an unsigned greater than expression.\n\n    :param a:\n    :param b:\n    :return:\n    \"\"\"\n    return _comparison_helper(a, b, z3.UGT, default_value=False, inputs_equal=False)\n\n\ndef UGE(a: BitVec, b: BitVec) -> Bool:\n    \"\"\"Create an unsigned greater or equals expression.\n\n    :param a:\n    :param b:\n    :return:\n    \"\"\"\n    return Or(UGT(a, b), a == b)\n\n\ndef ULT(a: BitVec, b: BitVec) -> Bool:\n    \"\"\"Create an unsigned less than expression.\n\n    :param a:\n    :param b:\n    :return:\n    \"\"\"\n    return _comparison_helper(a, b, z3.ULT, default_value=False, inputs_equal=False)\n\n\ndef ULE(a: BitVec, b: BitVec) -> Bool:\n    \"\"\"Create an unsigned less than expression.\n\n    :param a:\n    :param b:\n    :return:\n    \"\"\"\n    return Or(ULT(a, b), a == b)\n\n\n@overload\ndef Concat(*args: List[BitVec]) -> BitVec:    ...\n\n\n@overload\ndef Concat(*args: BitVec) -> BitVec:    ...\n\n\ndef Concat(*args: Union[BitVec, List[BitVec]]) -> BitVec:\n    \"\"\"Create a concatenation expression.\n\n    :param args:\n    :return:\n    \"\"\"\n    # The following statement is used if a list is provided as an argument to concat\n    if len(args) == 1 and isinstance(args[0], list):\n        bvs = args[0]  # type: List[BitVec]\n    else:\n        bvs = cast(List[BitVec], args)\n\n    nraw = z3.Concat([a.raw for a in bvs])\n    annotations = set()  # type: Annotations\n    bitvecfunc = False\n    for bv in bvs:\n        annotations = annotations.union(bv.annotations)\n        if isinstance(bv, BitVecFunc):\n            bitvecfunc = True\n\n    if bitvecfunc:\n        # Added this not so good and misleading NOTATION to help with this\n        str_hash = \",\".join([\"hashed({})\".format(hash(bv)) for bv in bvs])\n        input_string = \"MisleadingNotationConcat({})\".format(str_hash)\n\n        return BitVecFunc(\n            raw=nraw, func_name=\"Hybrid\", input_=BitVec(z3.BitVec(input_string, 256), annotations=annotations)\n        )\n\n    return BitVec(nraw, annotations)\n\n\ndef Extract(high: int, low: int, bv: BitVec) -> BitVec:\n    \"\"\"Create an extract expression.\n\n    :param high:\n    :param low:\n    :param bv:\n    :return:\n    \"\"\"\n    raw = z3.Extract(high, low, bv.raw)\n    if isinstance(bv, BitVecFunc):\n        input_string = \"MisleadingNotationExtract({}, {}, hashed({}))\".format(high, low, hash(bv))\n        # Is there a better value to set func_name and input to in this case?\n        return BitVecFunc(\n            raw=raw, func_name=\"Hybrid\", input_=BitVec(z3.BitVec(input_string, 256), annotations=bv.annotations)\n        )\n\n    return BitVec(raw, annotations=bv.annotations)\n\n\ndef URem(a: BitVec, b: BitVec) -> BitVec:\n    \"\"\"Create an unsigned remainder expression.\n\n    :param a:\n    :param b:\n    :return:\n    \"\"\"\n    return _arithmetic_helper(a, b, z3.URem)\n\n\ndef SRem(a: BitVec, b: BitVec) -> BitVec:\n    \"\"\"Create a signed remainder expression.\n\n    :param a:\n    :param b:\n    :return:\n    \"\"\"\n    return _arithmetic_helper(a, b, z3.SRem)\n\n\ndef UDiv(a: BitVec, b: BitVec) -> BitVec:\n    \"\"\"Create an unsigned division expression.\n\n    :param a:\n    :param b:\n    :return:\n    \"\"\"\n    return _arithmetic_helper(a, b, z3.UDiv)\n\n\ndef Sum(*args: BitVec) -> BitVec:\n    \"\"\"Create sum expression.\n\n    :return:\n    \"\"\"\n    raw = z3.Sum([a.raw for a in args])\n    annotations = set()  # type: Annotations\n    bitvecfuncs = []\n\n    for bv in args:\n        annotations = annotations.union(bv.annotations)\n        if isinstance(bv, BitVecFunc):\n            bitvecfuncs.append(bv)\n\n    if len(bitvecfuncs) >= 2:\n        return BitVecFunc(raw=raw, func_name=\"Hybrid\", input_=None, annotations=annotations)\n    elif len(bitvecfuncs) == 1:\n        return BitVecFunc(\n            raw=raw,\n            func_name=bitvecfuncs[0].func_name,\n            input_=bitvecfuncs[0].input_,\n            annotations=annotations,\n        )\n\n    return BitVec(raw, annotations)\n\n\ndef BVAddNoOverflow(a: Union[BitVec, int], b: Union[BitVec, int], signed: bool) -> Bool:\n    \"\"\"Creates predicate that verifies that the addition doesn't overflow.\n\n    :param a:\n    :param b:\n    :param signed:\n    :return:\n    \"\"\"\n    if not isinstance(a, BitVec):\n        a = BitVec(z3.BitVecVal(a, 256))\n    if not isinstance(b, BitVec):\n        b = BitVec(z3.BitVecVal(b, 256))\n    return Bool(z3.BVAddNoOverflow(a.raw, b.raw, signed))\n\n\ndef BVMulNoOverflow(a: Union[BitVec, int], b: Union[BitVec, int], signed: bool) -> Bool:\n    \"\"\"Creates predicate that verifies that the multiplication doesn't\n    overflow.\n\n    :param a:\n    :param b:\n    :param signed:\n    :return:\n    \"\"\"\n    if not isinstance(a, BitVec):\n        a = BitVec(z3.BitVecVal(a, 256))\n    if not isinstance(b, BitVec):\n        b = BitVec(z3.BitVecVal(b, 256))\n    return Bool(z3.BVMulNoOverflow(a.raw, b.raw, signed))\n\n\ndef BVSubNoUnderflow(\n    a: Union[BitVec, int], b: Union[BitVec, int], signed: bool\n) -> Bool:\n    \"\"\"Creates predicate that verifies that the subtraction doesn't overflow.\n\n    :param a:\n    :param b:\n    :param signed:\n    :return:\n    \"\"\"\n    if not isinstance(a, BitVec):\n        a = BitVec(z3.BitVecVal(a, 256))\n    if not isinstance(b, BitVec):\n        b = BitVec(z3.BitVecVal(b, 256))\n\n    return Bool(z3.BVSubNoUnderflow(a.raw, b.raw, signed))\n\n\n# TODO: Fix circular import issues\n",
        "source_code_len": 7366,
        "target_code": "\n# TODO: Fix circular import issues\n",
        "target_code_len": 36,
        "diff_format": "@@ -278,273 +279,2 @@\n \n-def _comparison_helper(\n-    a: BitVec, b: BitVec, operation: Callable, default_value: bool, inputs_equal: bool\n-) -> Bool:\n-    annotations = a.annotations.union(b.annotations)\n-    if isinstance(a, BitVecFunc):\n-        if not a.symbolic and not b.symbolic:\n-            return Bool(operation(a.raw, b.raw), annotations=annotations)\n-\n-        if (\n-            not isinstance(b, BitVecFunc)\n-            or not a.func_name\n-            or not a.input_\n-            or not a.func_name == b.func_name\n-        ):\n-            return Bool(z3.BoolVal(default_value), annotations=annotations)\n-\n-        return And(\n-            Bool(operation(a.raw, b.raw), annotations=annotations),\n-            a.input_ == b.input_ if inputs_equal else a.input_ != b.input_,\n-        )\n-\n-    return Bool(operation(a.raw, b.raw), annotations)\n-\n-\n-def _arithmetic_helper(a: BitVec, b: BitVec, operation: Callable) -> BitVec:\n-    raw = operation(a.raw, b.raw)\n-    union = a.annotations.union(b.annotations)\n-\n-    if isinstance(a, BitVecFunc) and isinstance(b, BitVecFunc):\n-        return BitVecFunc(raw=raw, func_name=None, input_=None, annotations=union)\n-    elif isinstance(a, BitVecFunc):\n-        return BitVecFunc(\n-            raw=raw, func_name=a.func_name, input_=a.input_, annotations=union\n-        )\n-    elif isinstance(b, BitVecFunc):\n-        return BitVecFunc(\n-            raw=raw, func_name=b.func_name, input_=b.input_, annotations=union\n-        )\n-\n-    return BitVec(raw, annotations=union)\n-\n-\n-def LShR(a: BitVec, b: BitVec):\n-    return _arithmetic_helper(a, b, z3.LShR)\n-\n-\n-def If(a: Union[Bool, bool], b: Union[BitVec, int], c: Union[BitVec, int]) -> BitVec:\n-    \"\"\"Create an if-then-else expression.\n-\n-    :param a:\n-    :param b:\n-    :param c:\n-    :return:\n-    \"\"\"\n-    # TODO: Handle BitVecFunc\n-\n-    if not isinstance(a, Bool):\n-        a = Bool(z3.BoolVal(a))\n-    if not isinstance(b, BitVec):\n-        b = BitVec(z3.BitVecVal(b, 256))\n-    if not isinstance(c, BitVec):\n-        c = BitVec(z3.BitVecVal(c, 256))\n-    union = a.annotations.union(b.annotations).union(c.annotations)\n-    return BitVec(z3.If(a.raw, b.raw, c.raw), union)\n-\n-\n-def UGT(a: BitVec, b: BitVec) -> Bool:\n-    \"\"\"Create an unsigned greater than expression.\n-\n-    :param a:\n-    :param b:\n-    :return:\n-    \"\"\"\n-    return _comparison_helper(a, b, z3.UGT, default_value=False, inputs_equal=False)\n-\n-\n-def UGE(a: BitVec, b: BitVec) -> Bool:\n-    \"\"\"Create an unsigned greater or equals expression.\n-\n-    :param a:\n-    :param b:\n-    :return:\n-    \"\"\"\n-    return Or(UGT(a, b), a == b)\n-\n-\n-def ULT(a: BitVec, b: BitVec) -> Bool:\n-    \"\"\"Create an unsigned less than expression.\n-\n-    :param a:\n-    :param b:\n-    :return:\n-    \"\"\"\n-    return _comparison_helper(a, b, z3.ULT, default_value=False, inputs_equal=False)\n-\n-\n-def ULE(a: BitVec, b: BitVec) -> Bool:\n-    \"\"\"Create an unsigned less than expression.\n-\n-    :param a:\n-    :param b:\n-    :return:\n-    \"\"\"\n-    return Or(ULT(a, b), a == b)\n-\n-\n-@overload\n-def Concat(*args: List[BitVec]) -> BitVec:    ...\n-\n-\n-@overload\n-def Concat(*args: BitVec) -> BitVec:    ...\n-\n-\n-def Concat(*args: Union[BitVec, List[BitVec]]) -> BitVec:\n-    \"\"\"Create a concatenation expression.\n-\n-    :param args:\n-    :return:\n-    \"\"\"\n-    # The following statement is used if a list is provided as an argument to concat\n-    if len(args) == 1 and isinstance(args[0], list):\n-        bvs = args[0]  # type: List[BitVec]\n-    else:\n-        bvs = cast(List[BitVec], args)\n-\n-    nraw = z3.Concat([a.raw for a in bvs])\n-    annotations = set()  # type: Annotations\n-    bitvecfunc = False\n-    for bv in bvs:\n-        annotations = annotations.union(bv.annotations)\n-        if isinstance(bv, BitVecFunc):\n-            bitvecfunc = True\n-\n-    if bitvecfunc:\n-        # Added this not so good and misleading NOTATION to help with this\n-        str_hash = \",\".join([\"hashed({})\".format(hash(bv)) for bv in bvs])\n-        input_string = \"MisleadingNotationConcat({})\".format(str_hash)\n-\n-        return BitVecFunc(\n-            raw=nraw, func_name=\"Hybrid\", input_=BitVec(z3.BitVec(input_string, 256), annotations=annotations)\n-        )\n-\n-    return BitVec(nraw, annotations)\n-\n-\n-def Extract(high: int, low: int, bv: BitVec) -> BitVec:\n-    \"\"\"Create an extract expression.\n-\n-    :param high:\n-    :param low:\n-    :param bv:\n-    :return:\n-    \"\"\"\n-    raw = z3.Extract(high, low, bv.raw)\n-    if isinstance(bv, BitVecFunc):\n-        input_string = \"MisleadingNotationExtract({}, {}, hashed({}))\".format(high, low, hash(bv))\n-        # Is there a better value to set func_name and input to in this case?\n-        return BitVecFunc(\n-            raw=raw, func_name=\"Hybrid\", input_=BitVec(z3.BitVec(input_string, 256), annotations=bv.annotations)\n-        )\n-\n-    return BitVec(raw, annotations=bv.annotations)\n-\n-\n-def URem(a: BitVec, b: BitVec) -> BitVec:\n-    \"\"\"Create an unsigned remainder expression.\n-\n-    :param a:\n-    :param b:\n-    :return:\n-    \"\"\"\n-    return _arithmetic_helper(a, b, z3.URem)\n-\n-\n-def SRem(a: BitVec, b: BitVec) -> BitVec:\n-    \"\"\"Create a signed remainder expression.\n-\n-    :param a:\n-    :param b:\n-    :return:\n-    \"\"\"\n-    return _arithmetic_helper(a, b, z3.SRem)\n-\n-\n-def UDiv(a: BitVec, b: BitVec) -> BitVec:\n-    \"\"\"Create an unsigned division expression.\n-\n-    :param a:\n-    :param b:\n-    :return:\n-    \"\"\"\n-    return _arithmetic_helper(a, b, z3.UDiv)\n-\n-\n-def Sum(*args: BitVec) -> BitVec:\n-    \"\"\"Create sum expression.\n-\n-    :return:\n-    \"\"\"\n-    raw = z3.Sum([a.raw for a in args])\n-    annotations = set()  # type: Annotations\n-    bitvecfuncs = []\n-\n-    for bv in args:\n-        annotations = annotations.union(bv.annotations)\n-        if isinstance(bv, BitVecFunc):\n-            bitvecfuncs.append(bv)\n-\n-    if len(bitvecfuncs) >= 2:\n-        return BitVecFunc(raw=raw, func_name=\"Hybrid\", input_=None, annotations=annotations)\n-    elif len(bitvecfuncs) == 1:\n-        return BitVecFunc(\n-            raw=raw,\n-            func_name=bitvecfuncs[0].func_name,\n-            input_=bitvecfuncs[0].input_,\n-            annotations=annotations,\n-        )\n-\n-    return BitVec(raw, annotations)\n-\n-\n-def BVAddNoOverflow(a: Union[BitVec, int], b: Union[BitVec, int], signed: bool) -> Bool:\n-    \"\"\"Creates predicate that verifies that the addition doesn't overflow.\n-\n-    :param a:\n-    :param b:\n-    :param signed:\n-    :return:\n-    \"\"\"\n-    if not isinstance(a, BitVec):\n-        a = BitVec(z3.BitVecVal(a, 256))\n-    if not isinstance(b, BitVec):\n-        b = BitVec(z3.BitVecVal(b, 256))\n-    return Bool(z3.BVAddNoOverflow(a.raw, b.raw, signed))\n-\n-\n-def BVMulNoOverflow(a: Union[BitVec, int], b: Union[BitVec, int], signed: bool) -> Bool:\n-    \"\"\"Creates predicate that verifies that the multiplication doesn't\n-    overflow.\n-\n-    :param a:\n-    :param b:\n-    :param signed:\n-    :return:\n-    \"\"\"\n-    if not isinstance(a, BitVec):\n-        a = BitVec(z3.BitVecVal(a, 256))\n-    if not isinstance(b, BitVec):\n-        b = BitVec(z3.BitVecVal(b, 256))\n-    return Bool(z3.BVMulNoOverflow(a.raw, b.raw, signed))\n-\n-\n-def BVSubNoUnderflow(\n-    a: Union[BitVec, int], b: Union[BitVec, int], signed: bool\n-) -> Bool:\n-    \"\"\"Creates predicate that verifies that the subtraction doesn't overflow.\n-\n-    :param a:\n-    :param b:\n-    :param signed:\n-    :return:\n-    \"\"\"\n-    if not isinstance(a, BitVec):\n-        a = BitVec(z3.BitVecVal(a, 256))\n-    if not isinstance(b, BitVec):\n-        b = BitVec(z3.BitVecVal(b, 256))\n-\n-    return Bool(z3.BVSubNoUnderflow(a.raw, b.raw, signed))\n-\n-\n # TODO: Fix circular import issues\n",
        "source_code_with_indent": "\n<DED><DED>def _comparison_helper(\n    a: BitVec, b: BitVec, operation: Callable, default_value: bool, inputs_equal: bool\n) -> Bool:\n    <IND>annotations = a.annotations.union(b.annotations)\n    if isinstance(a, BitVecFunc):\n        <IND>if not a.symbolic and not b.symbolic:\n            <IND>return Bool(operation(a.raw, b.raw), annotations=annotations)\n\n        <DED>if (\n            not isinstance(b, BitVecFunc)\n            or not a.func_name\n            or not a.input_\n            or not a.func_name == b.func_name\n        ):\n            <IND>return Bool(z3.BoolVal(default_value), annotations=annotations)\n\n        <DED>return And(\n            Bool(operation(a.raw, b.raw), annotations=annotations),\n            a.input_ == b.input_ if inputs_equal else a.input_ != b.input_,\n        )\n\n    <DED>return Bool(operation(a.raw, b.raw), annotations)\n\n\n<DED>def _arithmetic_helper(a: BitVec, b: BitVec, operation: Callable) -> BitVec:\n    <IND>raw = operation(a.raw, b.raw)\n    union = a.annotations.union(b.annotations)\n\n    if isinstance(a, BitVecFunc) and isinstance(b, BitVecFunc):\n        <IND>return BitVecFunc(raw=raw, func_name=None, input_=None, annotations=union)\n    <DED>elif isinstance(a, BitVecFunc):\n        <IND>return BitVecFunc(\n            raw=raw, func_name=a.func_name, input_=a.input_, annotations=union\n        )\n    <DED>elif isinstance(b, BitVecFunc):\n        <IND>return BitVecFunc(\n            raw=raw, func_name=b.func_name, input_=b.input_, annotations=union\n        )\n\n    <DED>return BitVec(raw, annotations=union)\n\n\n<DED>def LShR(a: BitVec, b: BitVec):\n    <IND>return _arithmetic_helper(a, b, z3.LShR)\n\n\n<DED>def If(a: Union[Bool, bool], b: Union[BitVec, int], c: Union[BitVec, int]) -> BitVec:\n    <IND>\"\"\"Create an if-then-else expression.\n\n    :param a:\n    :param b:\n    :param c:\n    :return:\n    \"\"\"\n    # TODO: Handle BitVecFunc\n\n    if not isinstance(a, Bool):\n        <IND>a = Bool(z3.BoolVal(a))\n    <DED>if not isinstance(b, BitVec):\n        <IND>b = BitVec(z3.BitVecVal(b, 256))\n    <DED>if not isinstance(c, BitVec):\n        <IND>c = BitVec(z3.BitVecVal(c, 256))\n    <DED>union = a.annotations.union(b.annotations).union(c.annotations)\n    return BitVec(z3.If(a.raw, b.raw, c.raw), union)\n\n\n<DED>def UGT(a: BitVec, b: BitVec) -> Bool:\n    <IND>\"\"\"Create an unsigned greater than expression.\n\n    :param a:\n    :param b:\n    :return:\n    \"\"\"\n    return _comparison_helper(a, b, z3.UGT, default_value=False, inputs_equal=False)\n\n\n<DED>def UGE(a: BitVec, b: BitVec) -> Bool:\n    <IND>\"\"\"Create an unsigned greater or equals expression.\n\n    :param a:\n    :param b:\n    :return:\n    \"\"\"\n    return Or(UGT(a, b), a == b)\n\n\n<DED>def ULT(a: BitVec, b: BitVec) -> Bool:\n    <IND>\"\"\"Create an unsigned less than expression.\n\n    :param a:\n    :param b:\n    :return:\n    \"\"\"\n    return _comparison_helper(a, b, z3.ULT, default_value=False, inputs_equal=False)\n\n\n<DED>def ULE(a: BitVec, b: BitVec) -> Bool:\n    <IND>\"\"\"Create an unsigned less than expression.\n\n    :param a:\n    :param b:\n    :return:\n    \"\"\"\n    return Or(ULT(a, b), a == b)\n\n\n<DED>@overload\ndef Concat(*args: List[BitVec]) -> BitVec:    ...\n\n\n@overload\ndef Concat(*args: BitVec) -> BitVec:    ...\n\n\ndef Concat(*args: Union[BitVec, List[BitVec]]) -> BitVec:\n    <IND>\"\"\"Create a concatenation expression.\n\n    :param args:\n    :return:\n    \"\"\"\n    # The following statement is used if a list is provided as an argument to concat\n    if len(args) == 1 and isinstance(args[0], list):\n        <IND>bvs = args[0]  # type: List[BitVec]\n    <DED>else:\n        <IND>bvs = cast(List[BitVec], args)\n\n    <DED>nraw = z3.Concat([a.raw for a in bvs])\n    annotations = set()  # type: Annotations\n    bitvecfunc = False\n    for bv in bvs:\n        <IND>annotations = annotations.union(bv.annotations)\n        if isinstance(bv, BitVecFunc):\n            <IND>bitvecfunc = True\n\n    <DED><DED>if bitvecfunc:\n        # Added this not so good and misleading NOTATION to help with this\n        <IND>str_hash = \",\".join([\"hashed({})\".format(hash(bv)) for bv in bvs])\n        input_string = \"MisleadingNotationConcat({})\".format(str_hash)\n\n        return BitVecFunc(\n            raw=nraw, func_name=\"Hybrid\", input_=BitVec(z3.BitVec(input_string, 256), annotations=annotations)\n        )\n\n    <DED>return BitVec(nraw, annotations)\n\n\n<DED>def Extract(high: int, low: int, bv: BitVec) -> BitVec:\n    <IND>\"\"\"Create an extract expression.\n\n    :param high:\n    :param low:\n    :param bv:\n    :return:\n    \"\"\"\n    raw = z3.Extract(high, low, bv.raw)\n    if isinstance(bv, BitVecFunc):\n        <IND>input_string = \"MisleadingNotationExtract({}, {}, hashed({}))\".format(high, low, hash(bv))\n        # Is there a better value to set func_name and input to in this case?\n        return BitVecFunc(\n            raw=raw, func_name=\"Hybrid\", input_=BitVec(z3.BitVec(input_string, 256), annotations=bv.annotations)\n        )\n\n    <DED>return BitVec(raw, annotations=bv.annotations)\n\n\n<DED>def URem(a: BitVec, b: BitVec) -> BitVec:\n    <IND>\"\"\"Create an unsigned remainder expression.\n\n    :param a:\n    :param b:\n    :return:\n    \"\"\"\n    return _arithmetic_helper(a, b, z3.URem)\n\n\n<DED>def SRem(a: BitVec, b: BitVec) -> BitVec:\n    <IND>\"\"\"Create a signed remainder expression.\n\n    :param a:\n    :param b:\n    :return:\n    \"\"\"\n    return _arithmetic_helper(a, b, z3.SRem)\n\n\n<DED>def UDiv(a: BitVec, b: BitVec) -> BitVec:\n    <IND>\"\"\"Create an unsigned division expression.\n\n    :param a:\n    :param b:\n    :return:\n    \"\"\"\n    return _arithmetic_helper(a, b, z3.UDiv)\n\n\n<DED>def Sum(*args: BitVec) -> BitVec:\n    <IND>\"\"\"Create sum expression.\n\n    :return:\n    \"\"\"\n    raw = z3.Sum([a.raw for a in args])\n    annotations = set()  # type: Annotations\n    bitvecfuncs = []\n\n    for bv in args:\n        <IND>annotations = annotations.union(bv.annotations)\n        if isinstance(bv, BitVecFunc):\n            <IND>bitvecfuncs.append(bv)\n\n    <DED><DED>if len(bitvecfuncs) >= 2:\n        <IND>return BitVecFunc(raw=raw, func_name=\"Hybrid\", input_=None, annotations=annotations)\n    <DED>elif len(bitvecfuncs) == 1:\n        <IND>return BitVecFunc(\n            raw=raw,\n            func_name=bitvecfuncs[0].func_name,\n            input_=bitvecfuncs[0].input_,\n            annotations=annotations,\n        )\n\n    <DED>return BitVec(raw, annotations)\n\n\n<DED>def BVAddNoOverflow(a: Union[BitVec, int], b: Union[BitVec, int], signed: bool) -> Bool:\n    <IND>\"\"\"Creates predicate that verifies that the addition doesn't overflow.\n\n    :param a:\n    :param b:\n    :param signed:\n    :return:\n    \"\"\"\n    if not isinstance(a, BitVec):\n        <IND>a = BitVec(z3.BitVecVal(a, 256))\n    <DED>if not isinstance(b, BitVec):\n        <IND>b = BitVec(z3.BitVecVal(b, 256))\n    <DED>return Bool(z3.BVAddNoOverflow(a.raw, b.raw, signed))\n\n\n<DED>def BVMulNoOverflow(a: Union[BitVec, int], b: Union[BitVec, int], signed: bool) -> Bool:\n    <IND>\"\"\"Creates predicate that verifies that the multiplication doesn't\n    overflow.\n\n    :param a:\n    :param b:\n    :param signed:\n    :return:\n    \"\"\"\n    if not isinstance(a, BitVec):\n        <IND>a = BitVec(z3.BitVecVal(a, 256))\n    <DED>if not isinstance(b, BitVec):\n        <IND>b = BitVec(z3.BitVecVal(b, 256))\n    <DED>return Bool(z3.BVMulNoOverflow(a.raw, b.raw, signed))\n\n\n<DED>def BVSubNoUnderflow(\n    a: Union[BitVec, int], b: Union[BitVec, int], signed: bool\n) -> Bool:\n    <IND>\"\"\"Creates predicate that verifies that the subtraction doesn't overflow.\n\n    :param a:\n    :param b:\n    :param signed:\n    :return:\n    \"\"\"\n    if not isinstance(a, BitVec):\n        <IND>a = BitVec(z3.BitVecVal(a, 256))\n    <DED>if not isinstance(b, BitVec):\n        <IND>b = BitVec(z3.BitVecVal(b, 256))\n\n    <DED>return Bool(z3.BVSubNoUnderflow(a.raw, b.raw, signed))\n\n\n# TODO: Fix circular import issues\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n# TODO: Fix circular import issues\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  }
]