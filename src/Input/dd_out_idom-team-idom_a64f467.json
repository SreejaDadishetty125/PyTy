[
  {
    "project": "idom-team/idom",
    "commit": "a64f4678de456da17b38ffb1dd14ea46ce294070",
    "filename": "src/py/idom/server/base.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/idom-team-idom/src/py/idom/server/base.py",
    "file_hunks_size": 8,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "src/py/idom/server/base.py:55:4 Inconsistent override [14]: `src.py.idom.server.base.AbstractRenderServer.register` overrides method defined in `abc.ABCMeta` inconsistently. Could not find parameter `cls` in overriding signature.",
    "message": " `src.py.idom.server.base.AbstractRenderServer.register` overrides method defined in `abc.ABCMeta` inconsistently. Could not find parameter `cls` in overriding signature.",
    "rule_id": "Inconsistent override [14]",
    "warning_line_no": 55,
    "warning_line": "    def register(self: _S, app: Any) -> _S:",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "from asyncio import AbstractEventLoop\nfrom typing import TypeVar, Dict, Any, Tuple, Type, Optional\nfrom threading import Thread\n",
        "source_code_len": 128,
        "target_code": "from asyncio import AbstractEventLoop\nfrom typing import TypeVar, Dict, Any, Tuple, Type, Optional, Generic, TypeVar\nfrom threading import Thread\n",
        "target_code_len": 146,
        "diff_format": "@@ -2,3 +2,3 @@\n from asyncio import AbstractEventLoop\n-from typing import TypeVar, Dict, Any, Tuple, Type, Optional\n+from typing import TypeVar, Dict, Any, Tuple, Type, Optional, Generic, TypeVar\n from threading import Thread\n",
        "source_code_with_indent": "from asyncio import AbstractEventLoop\nfrom typing import TypeVar, Dict, Any, Tuple, Type, Optional\nfrom threading import Thread\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "from asyncio import AbstractEventLoop\nfrom typing import TypeVar, Dict, Any, Tuple, Type, Optional, Generic, TypeVar\nfrom threading import Thread\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n_S = TypeVar(\"_S\", bound=\"AbstractRenderServer\")\nConfig = Dict[str, Any]\n\n\nclass AbstractRenderServer(abc.ABC):\n    \"\"\"Base class for all IDOM server application and extension implementations.\n",
        "source_code_len": 194,
        "target_code": "\n_App = TypeVar(\"_App\", bound=Any)\n_Config = TypeVar(\"_Config\", bound=Any)\n_Self = TypeVar(\"_Self\", bound=\"AbstractRenderServer[Any, Any]\")\n\n\nclass AbstractRenderServer(Generic[_App, _Config]):\n    \"\"\"Base class for all IDOM server application and extension implementations.\n",
        "target_code_len": 275,
        "diff_format": "@@ -10,7 +10,8 @@\n \n-_S = TypeVar(\"_S\", bound=\"AbstractRenderServer\")\n-Config = Dict[str, Any]\n+_App = TypeVar(\"_App\", bound=Any)\n+_Config = TypeVar(\"_Config\", bound=Any)\n+_Self = TypeVar(\"_Self\", bound=\"AbstractRenderServer[Any, Any]\")\n \n \n-class AbstractRenderServer(abc.ABC):\n+class AbstractRenderServer(Generic[_App, _Config]):\n     \"\"\"Base class for all IDOM server application and extension implementations.\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\n_S = TypeVar(\"_S\", bound=\"AbstractRenderServer\")\nConfig = Dict[str, Any]\n\n\nclass AbstractRenderServer(abc.ABC):\n    <IND>",
        "target_code_with_indent": "\n_App = TypeVar(\"_App\", bound=Any)\n_Config = TypeVar(\"_Config\", bound=Any)\n_Self = TypeVar(\"_Self\", bound=\"AbstractRenderServer[Any, Any]\")\n\n\nclass AbstractRenderServer(Generic[_App, _Config]):\n    <IND>"
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "        self._daemonized = False\n        self._config: Config = {}\n        self._init_config(self._config)\n\n",
        "source_code_len": 108,
        "target_code": "        self._daemonized = False\n        self._config = self._init_config()\n\n    @property\n    def application(self) -> _App:\n        if self._app is None:\n            raise RuntimeError(\"No application registered.\")\n        return self._app\n\n",
        "target_code_len": 243,
        "diff_format": "@@ -38,4 +39,9 @@\n         self._daemonized = False\n-        self._config: Config = {}\n-        self._init_config(self._config)\n+        self._config = self._init_config()\n+\n+    @property\n+    def application(self) -> _App:\n+        if self._app is None:\n+            raise RuntimeError(\"No application registered.\")\n+        return self._app\n \n",
        "source_code_with_indent": "        self._daemonized = False\n        self._config: Config = {}\n        self._init_config(self._config)\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "        self._daemonized = False\n        self._config = self._init_config()\n\n    <DED>@property\n    def application(self) -> _App:\n        <IND>if self._app is None:\n            <IND>raise RuntimeError(\"No application registered.\")\n        <DED>return self._app\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": true,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n    def register(self: _S, app: Any) -> _S:\n        \"\"\"Register this as an extension.\"\"\"\n",
        "source_code_len": 90,
        "target_code": "\n    def register(self: _Self, app: _App) -> _Self:\n        \"\"\"Register this as an extension.\"\"\"\n",
        "target_code_len": 97,
        "diff_format": "@@ -54,3 +63,3 @@\n \n-    def register(self: _S, app: Any) -> _S:\n+    def register(self: _Self, app: _App) -> _Self:\n         \"\"\"Register this as an extension.\"\"\"\n",
        "source_code_with_indent": "\n    <DED>def register(self: _S, app: Any) -> _S:\n        <IND>\"\"\"Register this as an extension.\"\"\"\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n    <DED>def register(self: _Self, app: _App) -> _Self:\n        <IND>\"\"\"Register this as an extension.\"\"\"\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n    def configure(self: _S, settings: Dict[str, Any]) -> _S:\n        \"\"\"Configure this extension.\"\"\"\n        for k, v in settings.items():\n            if k not in self._config:\n                raise ValueError(f\"Unknown option {k!r}\")\n        self._config.update(settings)\n        return self\n\n    def _init_config(self, config: Config) -> None:\n        \"\"\"Set the default configuration options.\n\n        Initialize configuration options by mutating the ``config`` dict.\n        \"\"\"\n\n",
        "source_code_len": 485,
        "target_code": "\n    def configure(self: _Self, config: _Config) -> _Self:\n        \"\"\"Configure this extension.\"\"\"\n        self._config = self._update_config(self._config, config)\n        return self\n\n    @abc.abstractmethod\n    def _init_config(self) -> _Config:\n        \"\"\"Return the default configuration options.\"\"\"\n\n    @abc.abstractmethod\n    def _default_application(self, config: _Config) -> _App:\n        \"\"\"If used standalone this should return an application.\"\"\"\n        raise NotImplementedError()\n\n    @abc.abstractmethod\n    def _setup_application(self, app: _App, config: _Config) -> None:\n        ...\n\n    @abc.abstractmethod\n    def _run_application(\n        self, app: _App, config: _Config, args: Tuple[Any, ...], kwargs: Dict[str, Any]\n    ) -> Any:\n        ...\n\n    def _update_config(self, old: _Config, new: _Config) -> _Config:\n        \"\"\"Return the new configuration options\n\n        Parameters:\n            old: The existing configuration options\n            new: The new configuration options\n        \"\"\"\n        return new\n\n",
        "target_code_len": 1036,
        "diff_format": "@@ -60,15 +69,34 @@\n \n-    def configure(self: _S, settings: Dict[str, Any]) -> _S:\n+    def configure(self: _Self, config: _Config) -> _Self:\n         \"\"\"Configure this extension.\"\"\"\n-        for k, v in settings.items():\n-            if k not in self._config:\n-                raise ValueError(f\"Unknown option {k!r}\")\n-        self._config.update(settings)\n+        self._config = self._update_config(self._config, config)\n         return self\n \n-    def _init_config(self, config: Config) -> None:\n-        \"\"\"Set the default configuration options.\n+    @abc.abstractmethod\n+    def _init_config(self) -> _Config:\n+        \"\"\"Return the default configuration options.\"\"\"\n \n-        Initialize configuration options by mutating the ``config`` dict.\n+    @abc.abstractmethod\n+    def _default_application(self, config: _Config) -> _App:\n+        \"\"\"If used standalone this should return an application.\"\"\"\n+        raise NotImplementedError()\n+\n+    @abc.abstractmethod\n+    def _setup_application(self, app: _App, config: _Config) -> None:\n+        ...\n+\n+    @abc.abstractmethod\n+    def _run_application(\n+        self, app: _App, config: _Config, args: Tuple[Any, ...], kwargs: Dict[str, Any]\n+    ) -> Any:\n+        ...\n+\n+    def _update_config(self, old: _Config, new: _Config) -> _Config:\n+        \"\"\"Return the new configuration options\n+\n+        Parameters:\n+            old: The existing configuration options\n+            new: The new configuration options\n         \"\"\"\n+        return new\n \n",
        "source_code_with_indent": "\n    <DED>def configure(self: _S, settings: Dict[str, Any]) -> _S:\n        <IND>\"\"\"Configure this extension.\"\"\"\n        for k, v in settings.items():\n            <IND>if k not in self._config:\n                <IND>raise ValueError(f\"Unknown option {k!r}\")\n        <DED><DED>self._config.update(settings)\n        return self\n\n    <DED>def _init_config(self, config: Config) -> None:\n        <IND>\"\"\"Set the default configuration options.\n\n        Initialize configuration options by mutating the ``config`` dict.\n        \"\"\"\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n    <DED>def configure(self: _Self, config: _Config) -> _Self:\n        <IND>\"\"\"Configure this extension.\"\"\"\n        self._config = self._update_config(self._config, config)\n        return self\n\n    <DED>@abc.abstractmethod\n    def _init_config(self) -> _Config:\n        <IND>\"\"\"Return the default configuration options.\"\"\"\n\n    <DED>@abc.abstractmethod\n    def _default_application(self, config: _Config) -> _App:\n        <IND>\"\"\"If used standalone this should return an application.\"\"\"\n        raise NotImplementedError()\n\n    <DED>@abc.abstractmethod\n    def _setup_application(self, app: _App, config: _Config) -> None:\n        <IND>...\n\n    <DED>@abc.abstractmethod\n    def _run_application(\n        self, app: _App, config: _Config, args: Tuple[Any, ...], kwargs: Dict[str, Any]\n    ) -> Any:\n        <IND>...\n\n    <DED>def _update_config(self, old: _Config, new: _Config) -> _Config:\n        <IND>\"\"\"Return the new configuration options\n\n        Parameters:\n            old: The existing configuration options\n            new: The new configuration options\n        \"\"\"\n        return new\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": true,
        "has_suppression": false,
        "source_code": "        )\n\n    def _get_renderer_event_loop(self) -> AbstractEventLoop:\n        raise NotImplementedError()\n\n    @abc.abstractmethod\n    def _default_application(self, config: Config) -> Any:\n        \"\"\"If used standalone this should return an application.\"\"\"\n        raise NotImplementedError()\n\n    @abc.abstractmethod\n    def _setup_application(self, app: Any, config: Config) -> None:\n        ...\n\n    @abc.abstractmethod\n    def _run_application(\n        self, app: Any, config: Config, args: Tuple[Any, ...], kwargs: Dict[str, Any]\n    ) -> Any:\n        ...\n",
        "source_code_len": 564,
        "target_code": "        )\n",
        "target_code_len": 10,
        "diff_format": "@@ -86,19 +114,1 @@\n         )\n-\n-    def _get_renderer_event_loop(self) -> AbstractEventLoop:\n-        raise NotImplementedError()\n-\n-    @abc.abstractmethod\n-    def _default_application(self, config: Config) -> Any:\n-        \"\"\"If used standalone this should return an application.\"\"\"\n-        raise NotImplementedError()\n-\n-    @abc.abstractmethod\n-    def _setup_application(self, app: Any, config: Config) -> None:\n-        ...\n-\n-    @abc.abstractmethod\n-    def _run_application(\n-        self, app: Any, config: Config, args: Tuple[Any, ...], kwargs: Dict[str, Any]\n-    ) -> Any:\n-        ...\n",
        "source_code_with_indent": "        )\n\n    <DED>def _get_renderer_event_loop(self) -> AbstractEventLoop:\n        <IND>raise NotImplementedError()\n\n    <DED>@abc.abstractmethod\n    def _default_application(self, config: Config) -> Any:\n        <IND>\"\"\"If used standalone this should return an application.\"\"\"\n        raise NotImplementedError()\n\n    <DED>@abc.abstractmethod\n    def _setup_application(self, app: Any, config: Config) -> None:\n        <IND>...\n\n    <DED>@abc.abstractmethod\n    def _run_application(\n        self, app: Any, config: Config, args: Tuple[Any, ...], kwargs: Dict[str, Any]\n    ) -> Any:\n        <IND>...\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "        )\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "idom-team/idom",
    "commit": "a64f4678de456da17b38ffb1dd14ea46ce294070",
    "filename": "src/py/idom/server/base.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/idom-team-idom/src/py/idom/server/base.py",
    "file_hunks_size": 8,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "src/py/idom/server/base.py:55:4 Inconsistent override [14]: `src.py.idom.server.base.AbstractRenderServer.register` overrides method defined in `abc.ABCMeta` inconsistently. Could not find parameter `subclass` in overriding signature.",
    "message": " `src.py.idom.server.base.AbstractRenderServer.register` overrides method defined in `abc.ABCMeta` inconsistently. Could not find parameter `subclass` in overriding signature.",
    "rule_id": "Inconsistent override [14]",
    "warning_line_no": 55,
    "warning_line": "    def register(self: _S, app: Any) -> _S:",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "from asyncio import AbstractEventLoop\nfrom typing import TypeVar, Dict, Any, Tuple, Type, Optional\nfrom threading import Thread\n",
        "source_code_len": 128,
        "target_code": "from asyncio import AbstractEventLoop\nfrom typing import TypeVar, Dict, Any, Tuple, Type, Optional, Generic, TypeVar\nfrom threading import Thread\n",
        "target_code_len": 146,
        "diff_format": "@@ -2,3 +2,3 @@\n from asyncio import AbstractEventLoop\n-from typing import TypeVar, Dict, Any, Tuple, Type, Optional\n+from typing import TypeVar, Dict, Any, Tuple, Type, Optional, Generic, TypeVar\n from threading import Thread\n",
        "source_code_with_indent": "from asyncio import AbstractEventLoop\nfrom typing import TypeVar, Dict, Any, Tuple, Type, Optional\nfrom threading import Thread\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "from asyncio import AbstractEventLoop\nfrom typing import TypeVar, Dict, Any, Tuple, Type, Optional, Generic, TypeVar\nfrom threading import Thread\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n_S = TypeVar(\"_S\", bound=\"AbstractRenderServer\")\nConfig = Dict[str, Any]\n\n\nclass AbstractRenderServer(abc.ABC):\n    \"\"\"Base class for all IDOM server application and extension implementations.\n",
        "source_code_len": 194,
        "target_code": "\n_App = TypeVar(\"_App\", bound=Any)\n_Config = TypeVar(\"_Config\", bound=Any)\n_Self = TypeVar(\"_Self\", bound=\"AbstractRenderServer[Any, Any]\")\n\n\nclass AbstractRenderServer(Generic[_App, _Config]):\n    \"\"\"Base class for all IDOM server application and extension implementations.\n",
        "target_code_len": 275,
        "diff_format": "@@ -10,7 +10,8 @@\n \n-_S = TypeVar(\"_S\", bound=\"AbstractRenderServer\")\n-Config = Dict[str, Any]\n+_App = TypeVar(\"_App\", bound=Any)\n+_Config = TypeVar(\"_Config\", bound=Any)\n+_Self = TypeVar(\"_Self\", bound=\"AbstractRenderServer[Any, Any]\")\n \n \n-class AbstractRenderServer(abc.ABC):\n+class AbstractRenderServer(Generic[_App, _Config]):\n     \"\"\"Base class for all IDOM server application and extension implementations.\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\n_S = TypeVar(\"_S\", bound=\"AbstractRenderServer\")\nConfig = Dict[str, Any]\n\n\nclass AbstractRenderServer(abc.ABC):\n    <IND>",
        "target_code_with_indent": "\n_App = TypeVar(\"_App\", bound=Any)\n_Config = TypeVar(\"_Config\", bound=Any)\n_Self = TypeVar(\"_Self\", bound=\"AbstractRenderServer[Any, Any]\")\n\n\nclass AbstractRenderServer(Generic[_App, _Config]):\n    <IND>"
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "        self._daemonized = False\n        self._config: Config = {}\n        self._init_config(self._config)\n\n",
        "source_code_len": 108,
        "target_code": "        self._daemonized = False\n        self._config = self._init_config()\n\n    @property\n    def application(self) -> _App:\n        if self._app is None:\n            raise RuntimeError(\"No application registered.\")\n        return self._app\n\n",
        "target_code_len": 243,
        "diff_format": "@@ -38,4 +39,9 @@\n         self._daemonized = False\n-        self._config: Config = {}\n-        self._init_config(self._config)\n+        self._config = self._init_config()\n+\n+    @property\n+    def application(self) -> _App:\n+        if self._app is None:\n+            raise RuntimeError(\"No application registered.\")\n+        return self._app\n \n",
        "source_code_with_indent": "        self._daemonized = False\n        self._config: Config = {}\n        self._init_config(self._config)\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "        self._daemonized = False\n        self._config = self._init_config()\n\n    <DED>@property\n    def application(self) -> _App:\n        <IND>if self._app is None:\n            <IND>raise RuntimeError(\"No application registered.\")\n        <DED>return self._app\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": true,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n    def register(self: _S, app: Any) -> _S:\n        \"\"\"Register this as an extension.\"\"\"\n",
        "source_code_len": 90,
        "target_code": "\n    def register(self: _Self, app: _App) -> _Self:\n        \"\"\"Register this as an extension.\"\"\"\n",
        "target_code_len": 97,
        "diff_format": "@@ -54,3 +63,3 @@\n \n-    def register(self: _S, app: Any) -> _S:\n+    def register(self: _Self, app: _App) -> _Self:\n         \"\"\"Register this as an extension.\"\"\"\n",
        "source_code_with_indent": "\n    <DED>def register(self: _S, app: Any) -> _S:\n        <IND>\"\"\"Register this as an extension.\"\"\"\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n    <DED>def register(self: _Self, app: _App) -> _Self:\n        <IND>\"\"\"Register this as an extension.\"\"\"\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n    def configure(self: _S, settings: Dict[str, Any]) -> _S:\n        \"\"\"Configure this extension.\"\"\"\n        for k, v in settings.items():\n            if k not in self._config:\n                raise ValueError(f\"Unknown option {k!r}\")\n        self._config.update(settings)\n        return self\n\n    def _init_config(self, config: Config) -> None:\n        \"\"\"Set the default configuration options.\n\n        Initialize configuration options by mutating the ``config`` dict.\n        \"\"\"\n\n",
        "source_code_len": 485,
        "target_code": "\n    def configure(self: _Self, config: _Config) -> _Self:\n        \"\"\"Configure this extension.\"\"\"\n        self._config = self._update_config(self._config, config)\n        return self\n\n    @abc.abstractmethod\n    def _init_config(self) -> _Config:\n        \"\"\"Return the default configuration options.\"\"\"\n\n    @abc.abstractmethod\n    def _default_application(self, config: _Config) -> _App:\n        \"\"\"If used standalone this should return an application.\"\"\"\n        raise NotImplementedError()\n\n    @abc.abstractmethod\n    def _setup_application(self, app: _App, config: _Config) -> None:\n        ...\n\n    @abc.abstractmethod\n    def _run_application(\n        self, app: _App, config: _Config, args: Tuple[Any, ...], kwargs: Dict[str, Any]\n    ) -> Any:\n        ...\n\n    def _update_config(self, old: _Config, new: _Config) -> _Config:\n        \"\"\"Return the new configuration options\n\n        Parameters:\n            old: The existing configuration options\n            new: The new configuration options\n        \"\"\"\n        return new\n\n",
        "target_code_len": 1036,
        "diff_format": "@@ -60,15 +69,34 @@\n \n-    def configure(self: _S, settings: Dict[str, Any]) -> _S:\n+    def configure(self: _Self, config: _Config) -> _Self:\n         \"\"\"Configure this extension.\"\"\"\n-        for k, v in settings.items():\n-            if k not in self._config:\n-                raise ValueError(f\"Unknown option {k!r}\")\n-        self._config.update(settings)\n+        self._config = self._update_config(self._config, config)\n         return self\n \n-    def _init_config(self, config: Config) -> None:\n-        \"\"\"Set the default configuration options.\n+    @abc.abstractmethod\n+    def _init_config(self) -> _Config:\n+        \"\"\"Return the default configuration options.\"\"\"\n \n-        Initialize configuration options by mutating the ``config`` dict.\n+    @abc.abstractmethod\n+    def _default_application(self, config: _Config) -> _App:\n+        \"\"\"If used standalone this should return an application.\"\"\"\n+        raise NotImplementedError()\n+\n+    @abc.abstractmethod\n+    def _setup_application(self, app: _App, config: _Config) -> None:\n+        ...\n+\n+    @abc.abstractmethod\n+    def _run_application(\n+        self, app: _App, config: _Config, args: Tuple[Any, ...], kwargs: Dict[str, Any]\n+    ) -> Any:\n+        ...\n+\n+    def _update_config(self, old: _Config, new: _Config) -> _Config:\n+        \"\"\"Return the new configuration options\n+\n+        Parameters:\n+            old: The existing configuration options\n+            new: The new configuration options\n         \"\"\"\n+        return new\n \n",
        "source_code_with_indent": "\n    <DED>def configure(self: _S, settings: Dict[str, Any]) -> _S:\n        <IND>\"\"\"Configure this extension.\"\"\"\n        for k, v in settings.items():\n            <IND>if k not in self._config:\n                <IND>raise ValueError(f\"Unknown option {k!r}\")\n        <DED><DED>self._config.update(settings)\n        return self\n\n    <DED>def _init_config(self, config: Config) -> None:\n        <IND>\"\"\"Set the default configuration options.\n\n        Initialize configuration options by mutating the ``config`` dict.\n        \"\"\"\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n    <DED>def configure(self: _Self, config: _Config) -> _Self:\n        <IND>\"\"\"Configure this extension.\"\"\"\n        self._config = self._update_config(self._config, config)\n        return self\n\n    <DED>@abc.abstractmethod\n    def _init_config(self) -> _Config:\n        <IND>\"\"\"Return the default configuration options.\"\"\"\n\n    <DED>@abc.abstractmethod\n    def _default_application(self, config: _Config) -> _App:\n        <IND>\"\"\"If used standalone this should return an application.\"\"\"\n        raise NotImplementedError()\n\n    <DED>@abc.abstractmethod\n    def _setup_application(self, app: _App, config: _Config) -> None:\n        <IND>...\n\n    <DED>@abc.abstractmethod\n    def _run_application(\n        self, app: _App, config: _Config, args: Tuple[Any, ...], kwargs: Dict[str, Any]\n    ) -> Any:\n        <IND>...\n\n    <DED>def _update_config(self, old: _Config, new: _Config) -> _Config:\n        <IND>\"\"\"Return the new configuration options\n\n        Parameters:\n            old: The existing configuration options\n            new: The new configuration options\n        \"\"\"\n        return new\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": true,
        "has_suppression": false,
        "source_code": "        )\n\n    def _get_renderer_event_loop(self) -> AbstractEventLoop:\n        raise NotImplementedError()\n\n    @abc.abstractmethod\n    def _default_application(self, config: Config) -> Any:\n        \"\"\"If used standalone this should return an application.\"\"\"\n        raise NotImplementedError()\n\n    @abc.abstractmethod\n    def _setup_application(self, app: Any, config: Config) -> None:\n        ...\n\n    @abc.abstractmethod\n    def _run_application(\n        self, app: Any, config: Config, args: Tuple[Any, ...], kwargs: Dict[str, Any]\n    ) -> Any:\n        ...\n",
        "source_code_len": 564,
        "target_code": "        )\n",
        "target_code_len": 10,
        "diff_format": "@@ -86,19 +114,1 @@\n         )\n-\n-    def _get_renderer_event_loop(self) -> AbstractEventLoop:\n-        raise NotImplementedError()\n-\n-    @abc.abstractmethod\n-    def _default_application(self, config: Config) -> Any:\n-        \"\"\"If used standalone this should return an application.\"\"\"\n-        raise NotImplementedError()\n-\n-    @abc.abstractmethod\n-    def _setup_application(self, app: Any, config: Config) -> None:\n-        ...\n-\n-    @abc.abstractmethod\n-    def _run_application(\n-        self, app: Any, config: Config, args: Tuple[Any, ...], kwargs: Dict[str, Any]\n-    ) -> Any:\n-        ...\n",
        "source_code_with_indent": "        )\n\n    <DED>def _get_renderer_event_loop(self) -> AbstractEventLoop:\n        <IND>raise NotImplementedError()\n\n    <DED>@abc.abstractmethod\n    def _default_application(self, config: Config) -> Any:\n        <IND>\"\"\"If used standalone this should return an application.\"\"\"\n        raise NotImplementedError()\n\n    <DED>@abc.abstractmethod\n    def _setup_application(self, app: Any, config: Config) -> None:\n        <IND>...\n\n    <DED>@abc.abstractmethod\n    def _run_application(\n        self, app: Any, config: Config, args: Tuple[Any, ...], kwargs: Dict[str, Any]\n    ) -> Any:\n        <IND>...\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "        )\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  }
]