[
  {
    "project": "apache/airflow",
    "commit": "cdbdcae7c0645ac2987360fced43407202716b99",
    "filename": "airflow/contrib/operators/gcp_function_operator.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/apache-airflow/airflow/contrib/operators/gcp_function_operator.py",
    "file_hunks_size": 8,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": true,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "airflow/contrib/operators/gcp_function_operator.py:76:54 Invalid type [31]: Expression `\"[dict]\"` is not a valid type.",
    "message": " Expression `\"[dict]\"` is not a valid type.",
    "rule_id": "Invalid type [31]",
    "warning_line_no": 76,
    "warning_line": "    def __init__(self, validation_specs, api_version):",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": true,
        "has_suppression": false,
        "source_code": "\n# TODO: This whole section should be extracted later to contrib/tools/field_validator.py\n\nCOMPOSITE_FIELD_TYPES = ['union', 'dict']\n\n\nclass FieldValidationException(AirflowException):\n    \"\"\"\n    Thrown when validation finds dictionary field not valid according to specification.\n    \"\"\"\n\n    def __init__(self, message):\n        super(FieldValidationException, self).__init__(message)\n\n\nclass ValidationSpecificationException(AirflowException):\n    \"\"\"\n    Thrown when validation specification is wrong\n    (rather than dictionary being validated).\n    This should only happen during development as ideally\n     specification itself should not be invalid ;) .\n    \"\"\"\n\n    def __init__(self, message):\n        super(ValidationSpecificationException, self).__init__(message)\n\n\n# TODO: make better description, add some examples\n# TODO: move to contrib/utils folder when we reuse it.\nclass BodyFieldValidator(LoggingMixin):\n    \"\"\"\n    Validates correctness of request body according to specification.\n    The specification can describe various type of\n    fields including custom validation, and union of fields. This validator is meant\n    to be reusable by various operators\n    in the near future, but for now it is left as part of the Google Cloud Function,\n    so documentation about the\n    validator is not yet complete. To see what kind of specification can be used,\n    please take a look at\n    gcp_function_operator.CLOUD_FUNCTION_VALIDATION which specifies validation\n    for GCF deploy operator.\n\n    :param validation_specs: dictionary describing validation specification\n    :type validation_specs: [dict]\n    :param api_version: Version of the api used (for example v1)\n    :type api_version: str\n\n    \"\"\"\n    def __init__(self, validation_specs, api_version):\n        # type: ([dict], str) -> None\n        super(BodyFieldValidator, self).__init__()\n        self._validation_specs = validation_specs\n        self._api_version = api_version\n\n    @staticmethod\n    def _get_field_name_with_parent(field_name, parent):\n        if parent:\n            return parent + '.' + field_name\n        return field_name\n\n    @staticmethod\n    def _sanity_checks(children_validation_specs, field_type, full_field_path,\n                       regexp, custom_validation, value):\n        # type: (dict, str, str, str, function, object) -> None\n        if value is None and field_type != 'union':\n            raise FieldValidationException(\n                \"The required body field '{}' is missing. Please add it.\".\n                format(full_field_path))\n        if regexp and field_type:\n            raise ValidationSpecificationException(\n                \"The validation specification entry '{}' has both type and regexp. \"\n                \"The regexp is only allowed without type (i.e. assume type is 'str' \"\n                \"that can be validated with regexp)\".format(full_field_path))\n        if children_validation_specs and field_type not in COMPOSITE_FIELD_TYPES:\n            raise ValidationSpecificationException(\n                \"Nested fields are specified in field '{}' of type '{}'. \"\n                \"Nested fields are only allowed for fields of those types: ('{}').\".\n                format(full_field_path, field_type, COMPOSITE_FIELD_TYPES))\n        if custom_validation and field_type:\n            raise ValidationSpecificationException(\n                \"The validation specification field '{}' has both type and \"\n                \"custom_validation. Custom validation is only allowed without type.\".\n                format(full_field_path))\n\n    @staticmethod\n    def _validate_regexp(full_field_path, regexp, value):\n        # type: (str, str, str) -> None\n        if not re.match(regexp, value):\n            # Note matching of only the beginning as we assume the regexps all-or-nothing\n            raise FieldValidationException(\n                \"The body field '{}' of value '{}' does not match the field \"\n                \"specification regexp: '{}'.\".\n                format(full_field_path, value, regexp))\n\n    def _validate_dict(self, children_validation_specs, full_field_path, value):\n        # type: (dict, str, dict) -> None\n        for child_validation_spec in children_validation_specs:\n            self._validate_field(validation_spec=child_validation_spec,\n                                 dictionary_to_validate=value,\n                                 parent=full_field_path)\n        for field_name in value.keys():\n            if field_name not in [spec['name'] for spec in children_validation_specs]:\n                self.log.warning(\n                    \"The field '{}' is in the body, but is not specified in the \"\n                    \"validation specification '{}'. \"\n                    \"This might be because you are using newer API version and \"\n                    \"new field names defined for that version. Then the warning \"\n                    \"can be safely ignored, or you might want to upgrade the operator\"\n                    \"to the version that supports the new API version.\".format(\n                        self._get_field_name_with_parent(field_name, full_field_path),\n                        children_validation_specs))\n\n    def _validate_union(self, children_validation_specs, full_field_path,\n                        dictionary_to_validate):\n        # type: (dict, str, dict) -> None\n        field_found = False\n        found_field_name = None\n        for child_validation_spec in children_validation_specs:\n            # Forcing optional so that we do not have to type optional = True\n            # in specification for all union fields\n            new_field_found = self._validate_field(\n                validation_spec=child_validation_spec,\n                dictionary_to_validate=dictionary_to_validate,\n                parent=full_field_path,\n                force_optional=True)\n            field_name = child_validation_spec['name']\n            if new_field_found and field_found:\n                raise FieldValidationException(\n                    \"The mutually exclusive fields '{}' and '{}' belonging to the \"\n                    \"union '{}' are both present. Please remove one\".\n                    format(field_name, found_field_name, full_field_path))\n            if new_field_found:\n                field_found = True\n                found_field_name = field_name\n        if not field_found:\n            self.log.warning(\n                \"There is no '{}' union defined in the body {}. \"\n                \"Validation expected one of '{}' but could not find any. It's possible \"\n                \"that you are using newer API version and there is another union variant \"\n                \"defined for that version. Then the warning can be safely ignored, \"\n                \"or you might want to upgrade the operator to the version that \"\n                \"supports the new API version.\".format(\n                    full_field_path,\n                    dictionary_to_validate,\n                    [field['name'] for field in children_validation_specs]))\n\n    def _validate_field(self, validation_spec, dictionary_to_validate, parent=None,\n                        force_optional=False):\n        \"\"\"\n        Validates if field is OK.\n        :param validation_spec: specification of the field\n        :type validation_spec: dict\n        :param dictionary_to_validate: dictionary where the field should be present\n        :type dictionary_to_validate: dict\n        :param parent: full path of parent field\n        :type parent: str\n        :param force_optional: forces the field to be optional\n          (all union fields have force_optional set to True)\n        :type force_optional: bool\n        :return: True if the field is present\n        \"\"\"\n        field_name = validation_spec['name']\n        field_type = validation_spec.get('type')\n        optional = validation_spec.get('optional')\n        regexp = validation_spec.get('regexp')\n        children_validation_specs = validation_spec.get('fields')\n        required_api_version = validation_spec.get('api_version')\n        custom_validation = validation_spec.get('custom_validation')\n\n        full_field_path = self._get_field_name_with_parent(field_name=field_name,\n                                                           parent=parent)\n        if required_api_version and required_api_version != self._api_version:\n            self.log.debug(\n                \"Skipping validation of the field '{}' for API version '{}' \"\n                \"as it is only valid for API version '{}'\".\n                format(field_name, self._api_version, required_api_version))\n            return False\n        value = dictionary_to_validate.get(field_name)\n\n        if (optional or force_optional) and value is None:\n            self.log.debug(\"The optional field '{}' is missing. That's perfectly OK.\".\n                           format(full_field_path))\n            return False\n\n        # Certainly down from here the field is present (value is not None)\n        # so we should only return True from now on\n\n        self._sanity_checks(children_validation_specs=children_validation_specs,\n                            field_type=field_type,\n                            full_field_path=full_field_path,\n                            regexp=regexp,\n                            custom_validation=custom_validation,\n                            value=value)\n\n        if regexp:\n            self._validate_regexp(full_field_path, regexp, value)\n        elif field_type == 'dict':\n            if not isinstance(value, dict):\n                raise FieldValidationException(\n                    \"The field '{}' should be dictionary type according to \"\n                    \"specification '{}' but it is '{}'\".\n                    format(full_field_path, validation_spec, value))\n            if children_validation_specs is None:\n                self.log.debug(\n                    \"The dict field '{}' has no nested fields defined in the \"\n                    \"specification '{}'. That's perfectly ok - it's content will \"\n                    \"not be validated.\"\n                        .format(full_field_path, validation_spec))\n            else:\n                self._validate_dict(children_validation_specs, full_field_path, value)\n        elif field_type == 'union':\n            if not children_validation_specs:\n                raise ValidationSpecificationException(\n                    \"The union field '{}' has no nested fields \"\n                    \"defined in specification '{}'. Unions should have at least one \"\n                    \"nested field defined.\".format(full_field_path, validation_spec))\n            self._validate_union(children_validation_specs, full_field_path,\n                                 dictionary_to_validate)\n        elif custom_validation:\n            try:\n                custom_validation(value)\n            except Exception as e:\n                raise FieldValidationException(\n                    \"Error while validating custom field '{}' specified by '{}': '{}'\".\n                    format(full_field_path, validation_spec, e))\n        elif field_type is None:\n            self.log.debug(\"The type of field '{}' is not specified in '{}'. \"\n                           \"Not validating its content.\".\n                           format(full_field_path, validation_spec))\n        else:\n            raise ValidationSpecificationException(\n                \"The field '{}' is of type '{}' in specification '{}'.\"\n                \"This type is unknown to validation!\".format(\n                    full_field_path, field_type, validation_spec))\n        return True\n\n    def validate(self, body_to_validate):\n        \"\"\"\n        Validates if the body (dictionary) follows specification that the validator was\n        instantiated with. Raises ValidationSpecificationException or\n        ValidationFieldException in case of problems with specification or the\n        body not conforming to the specification respectively.\n        :param body_to_validate: body that must follow the specification\n        :type body_to_validate: dict\n        :return: None\n        \"\"\"\n        try:\n            for validation_spec in self._validation_specs:\n                self._validate_field(validation_spec=validation_spec,\n                                     dictionary_to_validate=body_to_validate)\n        except FieldValidationException as e:\n            raise FieldValidationException(\n                \"There was an error when validating: field '{}': '{}'\".\n                format(body_to_validate, e))\n\n# TODO End of field validator to be extracted\n\n\n",
        "source_code_len": 12571,
        "target_code": "\n\n",
        "target_code_len": 2,
        "diff_format": "@@ -28,258 +30,2 @@\n \n-# TODO: This whole section should be extracted later to contrib/tools/field_validator.py\n-\n-COMPOSITE_FIELD_TYPES = ['union', 'dict']\n-\n-\n-class FieldValidationException(AirflowException):\n-    \"\"\"\n-    Thrown when validation finds dictionary field not valid according to specification.\n-    \"\"\"\n-\n-    def __init__(self, message):\n-        super(FieldValidationException, self).__init__(message)\n-\n-\n-class ValidationSpecificationException(AirflowException):\n-    \"\"\"\n-    Thrown when validation specification is wrong\n-    (rather than dictionary being validated).\n-    This should only happen during development as ideally\n-     specification itself should not be invalid ;) .\n-    \"\"\"\n-\n-    def __init__(self, message):\n-        super(ValidationSpecificationException, self).__init__(message)\n-\n-\n-# TODO: make better description, add some examples\n-# TODO: move to contrib/utils folder when we reuse it.\n-class BodyFieldValidator(LoggingMixin):\n-    \"\"\"\n-    Validates correctness of request body according to specification.\n-    The specification can describe various type of\n-    fields including custom validation, and union of fields. This validator is meant\n-    to be reusable by various operators\n-    in the near future, but for now it is left as part of the Google Cloud Function,\n-    so documentation about the\n-    validator is not yet complete. To see what kind of specification can be used,\n-    please take a look at\n-    gcp_function_operator.CLOUD_FUNCTION_VALIDATION which specifies validation\n-    for GCF deploy operator.\n-\n-    :param validation_specs: dictionary describing validation specification\n-    :type validation_specs: [dict]\n-    :param api_version: Version of the api used (for example v1)\n-    :type api_version: str\n-\n-    \"\"\"\n-    def __init__(self, validation_specs, api_version):\n-        # type: ([dict], str) -> None\n-        super(BodyFieldValidator, self).__init__()\n-        self._validation_specs = validation_specs\n-        self._api_version = api_version\n-\n-    @staticmethod\n-    def _get_field_name_with_parent(field_name, parent):\n-        if parent:\n-            return parent + '.' + field_name\n-        return field_name\n-\n-    @staticmethod\n-    def _sanity_checks(children_validation_specs, field_type, full_field_path,\n-                       regexp, custom_validation, value):\n-        # type: (dict, str, str, str, function, object) -> None\n-        if value is None and field_type != 'union':\n-            raise FieldValidationException(\n-                \"The required body field '{}' is missing. Please add it.\".\n-                format(full_field_path))\n-        if regexp and field_type:\n-            raise ValidationSpecificationException(\n-                \"The validation specification entry '{}' has both type and regexp. \"\n-                \"The regexp is only allowed without type (i.e. assume type is 'str' \"\n-                \"that can be validated with regexp)\".format(full_field_path))\n-        if children_validation_specs and field_type not in COMPOSITE_FIELD_TYPES:\n-            raise ValidationSpecificationException(\n-                \"Nested fields are specified in field '{}' of type '{}'. \"\n-                \"Nested fields are only allowed for fields of those types: ('{}').\".\n-                format(full_field_path, field_type, COMPOSITE_FIELD_TYPES))\n-        if custom_validation and field_type:\n-            raise ValidationSpecificationException(\n-                \"The validation specification field '{}' has both type and \"\n-                \"custom_validation. Custom validation is only allowed without type.\".\n-                format(full_field_path))\n-\n-    @staticmethod\n-    def _validate_regexp(full_field_path, regexp, value):\n-        # type: (str, str, str) -> None\n-        if not re.match(regexp, value):\n-            # Note matching of only the beginning as we assume the regexps all-or-nothing\n-            raise FieldValidationException(\n-                \"The body field '{}' of value '{}' does not match the field \"\n-                \"specification regexp: '{}'.\".\n-                format(full_field_path, value, regexp))\n-\n-    def _validate_dict(self, children_validation_specs, full_field_path, value):\n-        # type: (dict, str, dict) -> None\n-        for child_validation_spec in children_validation_specs:\n-            self._validate_field(validation_spec=child_validation_spec,\n-                                 dictionary_to_validate=value,\n-                                 parent=full_field_path)\n-        for field_name in value.keys():\n-            if field_name not in [spec['name'] for spec in children_validation_specs]:\n-                self.log.warning(\n-                    \"The field '{}' is in the body, but is not specified in the \"\n-                    \"validation specification '{}'. \"\n-                    \"This might be because you are using newer API version and \"\n-                    \"new field names defined for that version. Then the warning \"\n-                    \"can be safely ignored, or you might want to upgrade the operator\"\n-                    \"to the version that supports the new API version.\".format(\n-                        self._get_field_name_with_parent(field_name, full_field_path),\n-                        children_validation_specs))\n-\n-    def _validate_union(self, children_validation_specs, full_field_path,\n-                        dictionary_to_validate):\n-        # type: (dict, str, dict) -> None\n-        field_found = False\n-        found_field_name = None\n-        for child_validation_spec in children_validation_specs:\n-            # Forcing optional so that we do not have to type optional = True\n-            # in specification for all union fields\n-            new_field_found = self._validate_field(\n-                validation_spec=child_validation_spec,\n-                dictionary_to_validate=dictionary_to_validate,\n-                parent=full_field_path,\n-                force_optional=True)\n-            field_name = child_validation_spec['name']\n-            if new_field_found and field_found:\n-                raise FieldValidationException(\n-                    \"The mutually exclusive fields '{}' and '{}' belonging to the \"\n-                    \"union '{}' are both present. Please remove one\".\n-                    format(field_name, found_field_name, full_field_path))\n-            if new_field_found:\n-                field_found = True\n-                found_field_name = field_name\n-        if not field_found:\n-            self.log.warning(\n-                \"There is no '{}' union defined in the body {}. \"\n-                \"Validation expected one of '{}' but could not find any. It's possible \"\n-                \"that you are using newer API version and there is another union variant \"\n-                \"defined for that version. Then the warning can be safely ignored, \"\n-                \"or you might want to upgrade the operator to the version that \"\n-                \"supports the new API version.\".format(\n-                    full_field_path,\n-                    dictionary_to_validate,\n-                    [field['name'] for field in children_validation_specs]))\n-\n-    def _validate_field(self, validation_spec, dictionary_to_validate, parent=None,\n-                        force_optional=False):\n-        \"\"\"\n-        Validates if field is OK.\n-        :param validation_spec: specification of the field\n-        :type validation_spec: dict\n-        :param dictionary_to_validate: dictionary where the field should be present\n-        :type dictionary_to_validate: dict\n-        :param parent: full path of parent field\n-        :type parent: str\n-        :param force_optional: forces the field to be optional\n-          (all union fields have force_optional set to True)\n-        :type force_optional: bool\n-        :return: True if the field is present\n-        \"\"\"\n-        field_name = validation_spec['name']\n-        field_type = validation_spec.get('type')\n-        optional = validation_spec.get('optional')\n-        regexp = validation_spec.get('regexp')\n-        children_validation_specs = validation_spec.get('fields')\n-        required_api_version = validation_spec.get('api_version')\n-        custom_validation = validation_spec.get('custom_validation')\n-\n-        full_field_path = self._get_field_name_with_parent(field_name=field_name,\n-                                                           parent=parent)\n-        if required_api_version and required_api_version != self._api_version:\n-            self.log.debug(\n-                \"Skipping validation of the field '{}' for API version '{}' \"\n-                \"as it is only valid for API version '{}'\".\n-                format(field_name, self._api_version, required_api_version))\n-            return False\n-        value = dictionary_to_validate.get(field_name)\n-\n-        if (optional or force_optional) and value is None:\n-            self.log.debug(\"The optional field '{}' is missing. That's perfectly OK.\".\n-                           format(full_field_path))\n-            return False\n-\n-        # Certainly down from here the field is present (value is not None)\n-        # so we should only return True from now on\n-\n-        self._sanity_checks(children_validation_specs=children_validation_specs,\n-                            field_type=field_type,\n-                            full_field_path=full_field_path,\n-                            regexp=regexp,\n-                            custom_validation=custom_validation,\n-                            value=value)\n-\n-        if regexp:\n-            self._validate_regexp(full_field_path, regexp, value)\n-        elif field_type == 'dict':\n-            if not isinstance(value, dict):\n-                raise FieldValidationException(\n-                    \"The field '{}' should be dictionary type according to \"\n-                    \"specification '{}' but it is '{}'\".\n-                    format(full_field_path, validation_spec, value))\n-            if children_validation_specs is None:\n-                self.log.debug(\n-                    \"The dict field '{}' has no nested fields defined in the \"\n-                    \"specification '{}'. That's perfectly ok - it's content will \"\n-                    \"not be validated.\"\n-                        .format(full_field_path, validation_spec))\n-            else:\n-                self._validate_dict(children_validation_specs, full_field_path, value)\n-        elif field_type == 'union':\n-            if not children_validation_specs:\n-                raise ValidationSpecificationException(\n-                    \"The union field '{}' has no nested fields \"\n-                    \"defined in specification '{}'. Unions should have at least one \"\n-                    \"nested field defined.\".format(full_field_path, validation_spec))\n-            self._validate_union(children_validation_specs, full_field_path,\n-                                 dictionary_to_validate)\n-        elif custom_validation:\n-            try:\n-                custom_validation(value)\n-            except Exception as e:\n-                raise FieldValidationException(\n-                    \"Error while validating custom field '{}' specified by '{}': '{}'\".\n-                    format(full_field_path, validation_spec, e))\n-        elif field_type is None:\n-            self.log.debug(\"The type of field '{}' is not specified in '{}'. \"\n-                           \"Not validating its content.\".\n-                           format(full_field_path, validation_spec))\n-        else:\n-            raise ValidationSpecificationException(\n-                \"The field '{}' is of type '{}' in specification '{}'.\"\n-                \"This type is unknown to validation!\".format(\n-                    full_field_path, field_type, validation_spec))\n-        return True\n-\n-    def validate(self, body_to_validate):\n-        \"\"\"\n-        Validates if the body (dictionary) follows specification that the validator was\n-        instantiated with. Raises ValidationSpecificationException or\n-        ValidationFieldException in case of problems with specification or the\n-        body not conforming to the specification respectively.\n-        :param body_to_validate: body that must follow the specification\n-        :type body_to_validate: dict\n-        :return: None\n-        \"\"\"\n-        try:\n-            for validation_spec in self._validation_specs:\n-                self._validate_field(validation_spec=validation_spec,\n-                                     dictionary_to_validate=body_to_validate)\n-        except FieldValidationException as e:\n-            raise FieldValidationException(\n-                \"There was an error when validating: field '{}': '{}'\".\n-                format(body_to_validate, e))\n-\n-# TODO End of field validator to be extracted\n-\n \n",
        "source_code_with_indent": "\n# TODO: This whole section should be extracted later to contrib/tools/field_validator.py\n\nCOMPOSITE_FIELD_TYPES = ['union', 'dict']\n\n\nclass FieldValidationException(AirflowException):\n    <IND>\"\"\"\n    Thrown when validation finds dictionary field not valid according to specification.\n    \"\"\"\n\n    def __init__(self, message):\n        <IND>super(FieldValidationException, self).__init__(message)\n\n\n<DED><DED>class ValidationSpecificationException(AirflowException):\n    <IND>\"\"\"\n    Thrown when validation specification is wrong\n    (rather than dictionary being validated).\n    This should only happen during development as ideally\n     specification itself should not be invalid ;) .\n    \"\"\"\n\n    def __init__(self, message):\n        <IND>super(ValidationSpecificationException, self).__init__(message)\n\n\n# TODO: make better description, add some examples\n# TODO: move to contrib/utils folder when we reuse it.\n<DED><DED>class BodyFieldValidator(LoggingMixin):\n    <IND>\"\"\"\n    Validates correctness of request body according to specification.\n    The specification can describe various type of\n    fields including custom validation, and union of fields. This validator is meant\n    to be reusable by various operators\n    in the near future, but for now it is left as part of the Google Cloud Function,\n    so documentation about the\n    validator is not yet complete. To see what kind of specification can be used,\n    please take a look at\n    gcp_function_operator.CLOUD_FUNCTION_VALIDATION which specifies validation\n    for GCF deploy operator.\n\n    :param validation_specs: dictionary describing validation specification\n    :type validation_specs: [dict]\n    :param api_version: Version of the api used (for example v1)\n    :type api_version: str\n\n    \"\"\"\n    def __init__(self, validation_specs, api_version):\n        # type: ([dict], str) -> None\n        <IND>super(BodyFieldValidator, self).__init__()\n        self._validation_specs = validation_specs\n        self._api_version = api_version\n\n    <DED>@staticmethod\n    def _get_field_name_with_parent(field_name, parent):\n        <IND>if parent:\n            <IND>return parent + '.' + field_name\n        <DED>return field_name\n\n    <DED>@staticmethod\n    def _sanity_checks(children_validation_specs, field_type, full_field_path,\n                       regexp, custom_validation, value):\n        # type: (dict, str, str, str, function, object) -> None\n        <IND>if value is None and field_type != 'union':\n            <IND>raise FieldValidationException(\n                \"The required body field '{}' is missing. Please add it.\".\n                format(full_field_path))\n        <DED>if regexp and field_type:\n            <IND>raise ValidationSpecificationException(\n                \"The validation specification entry '{}' has both type and regexp. \"\n                \"The regexp is only allowed without type (i.e. assume type is 'str' \"\n                \"that can be validated with regexp)\".format(full_field_path))\n        <DED>if children_validation_specs and field_type not in COMPOSITE_FIELD_TYPES:\n            <IND>raise ValidationSpecificationException(\n                \"Nested fields are specified in field '{}' of type '{}'. \"\n                \"Nested fields are only allowed for fields of those types: ('{}').\".\n                format(full_field_path, field_type, COMPOSITE_FIELD_TYPES))\n        <DED>if custom_validation and field_type:\n            <IND>raise ValidationSpecificationException(\n                \"The validation specification field '{}' has both type and \"\n                \"custom_validation. Custom validation is only allowed without type.\".\n                format(full_field_path))\n\n    <DED><DED>@staticmethod\n    def _validate_regexp(full_field_path, regexp, value):\n        # type: (str, str, str) -> None\n        <IND>if not re.match(regexp, value):\n            # Note matching of only the beginning as we assume the regexps all-or-nothing\n            <IND>raise FieldValidationException(\n                \"The body field '{}' of value '{}' does not match the field \"\n                \"specification regexp: '{}'.\".\n                format(full_field_path, value, regexp))\n\n    <DED><DED>def _validate_dict(self, children_validation_specs, full_field_path, value):\n        # type: (dict, str, dict) -> None\n        <IND>for child_validation_spec in children_validation_specs:\n            <IND>self._validate_field(validation_spec=child_validation_spec,\n                                 dictionary_to_validate=value,\n                                 parent=full_field_path)\n        <DED>for field_name in value.keys():\n            <IND>if field_name not in [spec['name'] for spec in children_validation_specs]:\n                <IND>self.log.warning(\n                    \"The field '{}' is in the body, but is not specified in the \"\n                    \"validation specification '{}'. \"\n                    \"This might be because you are using newer API version and \"\n                    \"new field names defined for that version. Then the warning \"\n                    \"can be safely ignored, or you might want to upgrade the operator\"\n                    \"to the version that supports the new API version.\".format(\n                        self._get_field_name_with_parent(field_name, full_field_path),\n                        children_validation_specs))\n\n    <DED><DED><DED>def _validate_union(self, children_validation_specs, full_field_path,\n                        dictionary_to_validate):\n        # type: (dict, str, dict) -> None\n        <IND>field_found = False\n        found_field_name = None\n        for child_validation_spec in children_validation_specs:\n            # Forcing optional so that we do not have to type optional = True\n            # in specification for all union fields\n            <IND>new_field_found = self._validate_field(\n                validation_spec=child_validation_spec,\n                dictionary_to_validate=dictionary_to_validate,\n                parent=full_field_path,\n                force_optional=True)\n            field_name = child_validation_spec['name']\n            if new_field_found and field_found:\n                <IND>raise FieldValidationException(\n                    \"The mutually exclusive fields '{}' and '{}' belonging to the \"\n                    \"union '{}' are both present. Please remove one\".\n                    format(field_name, found_field_name, full_field_path))\n            <DED>if new_field_found:\n                <IND>field_found = True\n                found_field_name = field_name\n        <DED><DED>if not field_found:\n            <IND>self.log.warning(\n                \"There is no '{}' union defined in the body {}. \"\n                \"Validation expected one of '{}' but could not find any. It's possible \"\n                \"that you are using newer API version and there is another union variant \"\n                \"defined for that version. Then the warning can be safely ignored, \"\n                \"or you might want to upgrade the operator to the version that \"\n                \"supports the new API version.\".format(\n                    full_field_path,\n                    dictionary_to_validate,\n                    [field['name'] for field in children_validation_specs]))\n\n    <DED><DED>def _validate_field(self, validation_spec, dictionary_to_validate, parent=None,\n                        force_optional=False):\n        <IND>\"\"\"\n        Validates if field is OK.\n        :param validation_spec: specification of the field\n        :type validation_spec: dict\n        :param dictionary_to_validate: dictionary where the field should be present\n        :type dictionary_to_validate: dict\n        :param parent: full path of parent field\n        :type parent: str\n        :param force_optional: forces the field to be optional\n          (all union fields have force_optional set to True)\n        :type force_optional: bool\n        :return: True if the field is present\n        \"\"\"\n        field_name = validation_spec['name']\n        field_type = validation_spec.get('type')\n        optional = validation_spec.get('optional')\n        regexp = validation_spec.get('regexp')\n        children_validation_specs = validation_spec.get('fields')\n        required_api_version = validation_spec.get('api_version')\n        custom_validation = validation_spec.get('custom_validation')\n\n        full_field_path = self._get_field_name_with_parent(field_name=field_name,\n                                                           parent=parent)\n        if required_api_version and required_api_version != self._api_version:\n            <IND>self.log.debug(\n                \"Skipping validation of the field '{}' for API version '{}' \"\n                \"as it is only valid for API version '{}'\".\n                format(field_name, self._api_version, required_api_version))\n            return False\n        <DED>value = dictionary_to_validate.get(field_name)\n\n        if (optional or force_optional) and value is None:\n            <IND>self.log.debug(\"The optional field '{}' is missing. That's perfectly OK.\".\n                           format(full_field_path))\n            return False\n\n        # Certainly down from here the field is present (value is not None)\n        # so we should only return True from now on\n\n        <DED>self._sanity_checks(children_validation_specs=children_validation_specs,\n                            field_type=field_type,\n                            full_field_path=full_field_path,\n                            regexp=regexp,\n                            custom_validation=custom_validation,\n                            value=value)\n\n        if regexp:\n            <IND>self._validate_regexp(full_field_path, regexp, value)\n        <DED>elif field_type == 'dict':\n            <IND>if not isinstance(value, dict):\n                <IND>raise FieldValidationException(\n                    \"The field '{}' should be dictionary type according to \"\n                    \"specification '{}' but it is '{}'\".\n                    format(full_field_path, validation_spec, value))\n            <DED>if children_validation_specs is None:\n                <IND>self.log.debug(\n                    \"The dict field '{}' has no nested fields defined in the \"\n                    \"specification '{}'. That's perfectly ok - it's content will \"\n                    \"not be validated.\"\n                        .format(full_field_path, validation_spec))\n            <DED>else:\n                <IND>self._validate_dict(children_validation_specs, full_field_path, value)\n        <DED><DED>elif field_type == 'union':\n            <IND>if not children_validation_specs:\n                <IND>raise ValidationSpecificationException(\n                    \"The union field '{}' has no nested fields \"\n                    \"defined in specification '{}'. Unions should have at least one \"\n                    \"nested field defined.\".format(full_field_path, validation_spec))\n            <DED>self._validate_union(children_validation_specs, full_field_path,\n                                 dictionary_to_validate)\n        <DED>elif custom_validation:\n            <IND>try:\n                <IND>custom_validation(value)\n            <DED>except Exception as e:\n                <IND>raise FieldValidationException(\n                    \"Error while validating custom field '{}' specified by '{}': '{}'\".\n                    format(full_field_path, validation_spec, e))\n        <DED><DED>elif field_type is None:\n            <IND>self.log.debug(\"The type of field '{}' is not specified in '{}'. \"\n                           \"Not validating its content.\".\n                           format(full_field_path, validation_spec))\n        <DED>else:\n            <IND>raise ValidationSpecificationException(\n                \"The field '{}' is of type '{}' in specification '{}'.\"\n                \"This type is unknown to validation!\".format(\n                    full_field_path, field_type, validation_spec))\n        <DED>return True\n\n    <DED>def validate(self, body_to_validate):\n        <IND>\"\"\"\n        Validates if the body (dictionary) follows specification that the validator was\n        instantiated with. Raises ValidationSpecificationException or\n        ValidationFieldException in case of problems with specification or the\n        body not conforming to the specification respectively.\n        :param body_to_validate: body that must follow the specification\n        :type body_to_validate: dict\n        :return: None\n        \"\"\"\n        try:\n            <IND>for validation_spec in self._validation_specs:\n                <IND>self._validate_field(validation_spec=validation_spec,\n                                     dictionary_to_validate=body_to_validate)\n        <DED><DED>except FieldValidationException as e:\n            <IND>raise FieldValidationException(\n                \"There was an error when validating: field '{}': '{}'\".\n                format(body_to_validate, e))\n\n# TODO End of field validator to be extracted\n\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  }
]