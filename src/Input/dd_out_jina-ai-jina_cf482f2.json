[
  {
    "project": "jina-ai/jina",
    "commit": "cf482f286b37933bcf060042179b86d8ee4133d6",
    "filename": "jina/clients/python/io.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/jina-ai-jina/jina/clients/python/io.py",
    "file_hunks_size": 5,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "jina/clients/python/io.py:33:12 Incompatible return type [7]: Expected `None` but got `typing.Generator[str, None, None]`.",
    "message": " Expected `None` but got `typing.Generator[str, None, None]`.",
    "rule_id": "Incompatible return type [7]",
    "warning_line_no": 33,
    "warning_line": "            yield l",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "def input_lines(lines: Iterator[str] = None, filepath: str = None, size: int = None, sampling_rate: float = None,\n                read_mode='r') -> None:\n    \"\"\" Input function that iterates over list of strings, it can be used in the Flow API\n",
        "source_code_len": 244,
        "target_code": "def input_lines(lines: Iterator[str] = None, filepath: str = None, size: int = None, sampling_rate: float = None,\n                read_mode='r') -> Iterator[Union[str, bytes]]:\n    \"\"\" Input function that iterates over list of strings, it can be used in the Flow API\n",
        "target_code_len": 267,
        "diff_format": "@@ -12,3 +12,3 @@\n def input_lines(lines: Iterator[str] = None, filepath: str = None, size: int = None, sampling_rate: float = None,\n-                read_mode='r') -> None:\n+                read_mode='r') -> Iterator[Union[str, bytes]]:\n     \"\"\" Input function that iterates over list of strings, it can be used in the Flow API\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "def input_lines(lines: Iterator[str] = None, filepath: str = None, size: int = None, sampling_rate: float = None,\n                read_mode='r') -> None:\n    <IND>",
        "target_code_with_indent": "def input_lines(lines: Iterator[str] = None, filepath: str = None, size: int = None, sampling_rate: float = None,\n                read_mode='r') -> Iterator[Union[str, bytes]]:\n    <IND>"
      }
    ]
  },
  {
    "project": "jina-ai/jina",
    "commit": "cf482f286b37933bcf060042179b86d8ee4133d6",
    "filename": "jina/clients/python/io.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/jina-ai-jina/jina/clients/python/io.py",
    "file_hunks_size": 5,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "jina/clients/python/io.py:67:16 Incompatible return type [7]: Expected `None` but got `typing.Generator[typing.Any, None, None]`.",
    "message": " Expected `None` but got `typing.Generator[typing.Any, None, None]`.",
    "rule_id": "Incompatible return type [7]",
    "warning_line_no": 67,
    "warning_line": "                yield g",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n    d = 0\n    for l in fp:\n        if sampling_rate is None or random.random() < sampling_rate:\n            yield l\n            d += 1\n        if size is not None and d > size:\n            break\n\n    if filepath:\n        fp.close()\n\n\ndef input_files(patterns: Union[str, List[str]], recursive: bool = True,\n                size: int = None, sampling_rate: float = None, read_mode: str = None) -> None:\n    \"\"\" Input function that iterates over files, it can be used in the Flow API\n",
        "source_code_len": 483,
        "target_code": "\ndef input_files(patterns: Union[str, List[str]], recursive: bool = True,\n                size: int = None, sampling_rate: float = None,\n                read_mode: str = None) -> Iterator[Union[str, bytes]]:\n    \"\"\" Input function that iterates over files, it can be used in the Flow API\n",
        "target_code_len": 288,
        "diff_format": "@@ -29,16 +36,5 @@\n \n-    d = 0\n-    for l in fp:\n-        if sampling_rate is None or random.random() < sampling_rate:\n-            yield l\n-            d += 1\n-        if size is not None and d > size:\n-            break\n-\n-    if filepath:\n-        fp.close()\n-\n-\n def input_files(patterns: Union[str, List[str]], recursive: bool = True,\n-                size: int = None, sampling_rate: float = None, read_mode: str = None) -> None:\n+                size: int = None, sampling_rate: float = None,\n+                read_mode: str = None) -> Iterator[Union[str, bytes]]:\n     \"\"\" Input function that iterates over files, it can be used in the Flow API\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\n    <DED>d = 0\n    for l in fp:\n        <IND>if sampling_rate is None or random.random() < sampling_rate:\n            <IND>yield l\n            d += 1\n        <DED>if size is not None and d > size:\n            <IND>break\n\n    <DED><DED>if filepath:\n        <IND>fp.close()\n\n\n<DED><DED>def input_files(patterns: Union[str, List[str]], recursive: bool = True,\n                size: int = None, sampling_rate: float = None, read_mode: str = None) -> None:\n    <IND>",
        "target_code_with_indent": "\n<DED><DED>def input_files(patterns: Union[str, List[str]], recursive: bool = True,\n                size: int = None, sampling_rate: float = None,\n                read_mode: str = None) -> Iterator[Union[str, bytes]]:\n    <IND>"
      }
    ]
  },
  {
    "project": "jina-ai/jina",
    "commit": "cf482f286b37933bcf060042179b86d8ee4133d6",
    "filename": "jina/clients/python/io.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/jina-ai-jina/jina/clients/python/io.py",
    "file_hunks_size": 5,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "jina/clients/python/io.py:70:20 Incompatible return type [7]: Expected `None` but got `typing.Generator[typing.Any, None, None]`.",
    "message": " Expected `None` but got `typing.Generator[typing.Any, None, None]`.",
    "rule_id": "Incompatible return type [7]",
    "warning_line_no": 70,
    "warning_line": "                    yield fp.read()",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n    d = 0\n    for l in fp:\n        if sampling_rate is None or random.random() < sampling_rate:\n            yield l\n            d += 1\n        if size is not None and d > size:\n            break\n\n    if filepath:\n        fp.close()\n\n\ndef input_files(patterns: Union[str, List[str]], recursive: bool = True,\n                size: int = None, sampling_rate: float = None, read_mode: str = None) -> None:\n    \"\"\" Input function that iterates over files, it can be used in the Flow API\n",
        "source_code_len": 483,
        "target_code": "\ndef input_files(patterns: Union[str, List[str]], recursive: bool = True,\n                size: int = None, sampling_rate: float = None,\n                read_mode: str = None) -> Iterator[Union[str, bytes]]:\n    \"\"\" Input function that iterates over files, it can be used in the Flow API\n",
        "target_code_len": 288,
        "diff_format": "@@ -29,16 +36,5 @@\n \n-    d = 0\n-    for l in fp:\n-        if sampling_rate is None or random.random() < sampling_rate:\n-            yield l\n-            d += 1\n-        if size is not None and d > size:\n-            break\n-\n-    if filepath:\n-        fp.close()\n-\n-\n def input_files(patterns: Union[str, List[str]], recursive: bool = True,\n-                size: int = None, sampling_rate: float = None, read_mode: str = None) -> None:\n+                size: int = None, sampling_rate: float = None,\n+                read_mode: str = None) -> Iterator[Union[str, bytes]]:\n     \"\"\" Input function that iterates over files, it can be used in the Flow API\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\n    <DED>d = 0\n    for l in fp:\n        <IND>if sampling_rate is None or random.random() < sampling_rate:\n            <IND>yield l\n            d += 1\n        <DED>if size is not None and d > size:\n            <IND>break\n\n    <DED><DED>if filepath:\n        <IND>fp.close()\n\n\n<DED><DED>def input_files(patterns: Union[str, List[str]], recursive: bool = True,\n                size: int = None, sampling_rate: float = None, read_mode: str = None) -> None:\n    <IND>",
        "target_code_with_indent": "\n<DED><DED>def input_files(patterns: Union[str, List[str]], recursive: bool = True,\n                size: int = None, sampling_rate: float = None,\n                read_mode: str = None) -> Iterator[Union[str, bytes]]:\n    <IND>"
      }
    ]
  },
  {
    "project": "jina-ai/jina",
    "commit": "cf482f286b37933bcf060042179b86d8ee4133d6",
    "filename": "jina/clients/python/io.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/jina-ai-jina/jina/clients/python/io.py",
    "file_hunks_size": 5,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "jina/clients/python/io.py:89:8 Incompatible return type [7]: Expected `None` but got `typing.Generator[typing.Any, None, None]`.",
    "message": " Expected `None` but got `typing.Generator[typing.Any, None, None]`.",
    "rule_id": "Incompatible return type [7]",
    "warning_line_no": 89,
    "warning_line": "        yield r",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "import random\nfrom typing import List, Union, Iterator\n\n",
        "source_code_len": 56,
        "target_code": "import random\nfrom typing import List, Union, Iterator, Any\n\n",
        "target_code_len": 61,
        "diff_format": "@@ -6,3 +6,3 @@\n import random\n-from typing import List, Union, Iterator\n+from typing import List, Union, Iterator, Any\n \n",
        "source_code_with_indent": "import random\nfrom typing import List, Union, Iterator\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "import random\nfrom typing import List, Union, Iterator, Any\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "def input_lines(lines: Iterator[str] = None, filepath: str = None, size: int = None, sampling_rate: float = None,\n                read_mode='r') -> None:\n    \"\"\" Input function that iterates over list of strings, it can be used in the Flow API\n",
        "source_code_len": 244,
        "target_code": "def input_lines(lines: Iterator[str] = None, filepath: str = None, size: int = None, sampling_rate: float = None,\n                read_mode='r') -> Iterator[Union[str, bytes]]:\n    \"\"\" Input function that iterates over list of strings, it can be used in the Flow API\n",
        "target_code_len": 267,
        "diff_format": "@@ -12,3 +12,3 @@\n def input_lines(lines: Iterator[str] = None, filepath: str = None, size: int = None, sampling_rate: float = None,\n-                read_mode='r') -> None:\n+                read_mode='r') -> Iterator[Union[str, bytes]]:\n     \"\"\" Input function that iterates over list of strings, it can be used in the Flow API\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "def input_lines(lines: Iterator[str] = None, filepath: str = None, size: int = None, sampling_rate: float = None,\n                read_mode='r') -> None:\n    <IND>",
        "target_code_with_indent": "def input_lines(lines: Iterator[str] = None, filepath: str = None, size: int = None, sampling_rate: float = None,\n                read_mode='r') -> Iterator[Union[str, bytes]]:\n    <IND>"
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    \"\"\"\n    if filepath:\n        fp = open(filepath, read_mode)\n    elif lines:\n        fp = lines\n    else:\n",
        "source_code_len": 109,
        "target_code": "    \"\"\"\n\n    def sample(iterable):\n        for i in iterable:\n            if sampling_rate is None or random.random() < sampling_rate:\n                yield i\n\n    if filepath:\n        with open(filepath, read_mode) as f:\n            return it.islice(sample(f), size)\n    elif lines:\n        return it.islice(sample(lines), size)\n    else:\n",
        "target_code_len": 340,
        "diff_format": "@@ -22,6 +22,13 @@\n     \"\"\"\n+\n+    def sample(iterable):\n+        for i in iterable:\n+            if sampling_rate is None or random.random() < sampling_rate:\n+                yield i\n+\n     if filepath:\n-        fp = open(filepath, read_mode)\n+        with open(filepath, read_mode) as f:\n+            return it.islice(sample(f), size)\n     elif lines:\n-        fp = lines\n+        return it.islice(sample(lines), size)\n     else:\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\n    if filepath:\n        <IND>fp = open(filepath, read_mode)\n    <DED>elif lines:\n        <IND>fp = lines\n    <DED>else:\n",
        "target_code_with_indent": "\n\n    def sample(iterable):\n        <IND>for i in iterable:\n            <IND>if sampling_rate is None or random.random() < sampling_rate:\n                <IND>yield i\n\n    <DED><DED><DED>if filepath:\n        <IND>with open(filepath, read_mode) as f:\n            <IND>return it.islice(sample(f), size)\n    <DED><DED>elif lines:\n        <IND>return it.islice(sample(lines), size)\n    <DED>else:\n"
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n    d = 0\n    for l in fp:\n        if sampling_rate is None or random.random() < sampling_rate:\n            yield l\n            d += 1\n        if size is not None and d > size:\n            break\n\n    if filepath:\n        fp.close()\n\n\ndef input_files(patterns: Union[str, List[str]], recursive: bool = True,\n                size: int = None, sampling_rate: float = None, read_mode: str = None) -> None:\n    \"\"\" Input function that iterates over files, it can be used in the Flow API\n",
        "source_code_len": 483,
        "target_code": "\ndef input_files(patterns: Union[str, List[str]], recursive: bool = True,\n                size: int = None, sampling_rate: float = None,\n                read_mode: str = None) -> Iterator[Union[str, bytes]]:\n    \"\"\" Input function that iterates over files, it can be used in the Flow API\n",
        "target_code_len": 288,
        "diff_format": "@@ -29,16 +36,5 @@\n \n-    d = 0\n-    for l in fp:\n-        if sampling_rate is None or random.random() < sampling_rate:\n-            yield l\n-            d += 1\n-        if size is not None and d > size:\n-            break\n-\n-    if filepath:\n-        fp.close()\n-\n-\n def input_files(patterns: Union[str, List[str]], recursive: bool = True,\n-                size: int = None, sampling_rate: float = None, read_mode: str = None) -> None:\n+                size: int = None, sampling_rate: float = None,\n+                read_mode: str = None) -> Iterator[Union[str, bytes]]:\n     \"\"\" Input function that iterates over files, it can be used in the Flow API\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\n    <DED>d = 0\n    for l in fp:\n        <IND>if sampling_rate is None or random.random() < sampling_rate:\n            <IND>yield l\n            d += 1\n        <DED>if size is not None and d > size:\n            <IND>break\n\n    <DED><DED>if filepath:\n        <IND>fp.close()\n\n\n<DED><DED>def input_files(patterns: Union[str, List[str]], recursive: bool = True,\n                size: int = None, sampling_rate: float = None, read_mode: str = None) -> None:\n    <IND>",
        "target_code_with_indent": "\n<DED><DED>def input_files(patterns: Union[str, List[str]], recursive: bool = True,\n                size: int = None, sampling_rate: float = None,\n                read_mode: str = None) -> Iterator[Union[str, bytes]]:\n    <IND>"
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\ndef input_numpy(array: 'np.ndarray', axis: int = 0, size: int = None, shuffle: bool = False) -> None:\n    \"\"\" Input function that iterates over a numpy array, it can be used in the Flow API\n",
        "source_code_len": 191,
        "target_code": "\ndef input_numpy(array: 'np.ndarray', axis: int = 0, size: int = None,\n                shuffle: bool = False) -> Iterator[Any]:\n    \"\"\" Input function that iterates over a numpy array, it can be used in the Flow API\n",
        "target_code_len": 216,
        "diff_format": "@@ -75,3 +71,4 @@\n \n-def input_numpy(array: 'np.ndarray', axis: int = 0, size: int = None, shuffle: bool = False) -> None:\n+def input_numpy(array: 'np.ndarray', axis: int = 0, size: int = None,\n+                shuffle: bool = False) -> Iterator[Any]:\n     \"\"\" Input function that iterates over a numpy array, it can be used in the Flow API\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\n<DED><DED><DED>def input_numpy(array: 'np.ndarray', axis: int = 0, size: int = None, shuffle: bool = False) -> None:\n    <IND>",
        "target_code_with_indent": "\n<DED><DED><DED>def input_numpy(array: 'np.ndarray', axis: int = 0, size: int = None,\n                shuffle: bool = False) -> Iterator[Any]:\n    <IND>"
      }
    ]
  }
]