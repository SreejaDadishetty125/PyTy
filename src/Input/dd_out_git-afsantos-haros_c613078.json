[
  {
    "project": "git-afsantos/haros",
    "commit": "c6130786daebc4d05f4aa19ff705af9fa59210db",
    "filename": "haros/hpl/hpl_ast.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/git-afsantos-haros/haros/hpl/hpl_ast.py",
    "file_hunks_size": 50,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "haros/hpl/hpl_ast.py:900:4 Inconsistent override [15]: `__slots__` overrides attribute defined in `HplValue` inconsistently. Type `typing.Tuple[str, str, str]` is not a subtype of the overridden attribute `typing.Tuple[]`.",
    "message": " `__slots__` overrides attribute defined in `HplValue` inconsistently. Type `typing.Tuple[str, str, str]` is not a subtype of the overridden attribute `typing.Tuple[]`.",
    "rule_id": "Inconsistent override [15]",
    "warning_line_no": 900,
    "warning_line": "    __slots__ = (\"token\", \"value\", \"ros_types\")",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n\nclass HplLiteral(HplValue):\n    __slots__ = (\"token\", \"value\", \"ros_types\")\n\n    def __init__(self, token, value):\n        self.token = token # string\n        self.value = value # int | long | float | bool | string\n        self.ros_types = possible_types(value) # [TypeToken]\n\n    @property\n    def is_literal(self):\n        return True\n\n    def __eq__(self, other):\n        if not isinstance(other, HplLiteral):\n            return False\n        return self.token == other.token\n\n    def __hash__(self):\n        return hash(self.token)\n\n    def __str__(self):\n        return self.token\n\n    def __repr__(self):\n        return \"{}({}, {})\".format(type(self).__name__,\n            repr(self.token), repr(self.value))\n\n\nclass HplSet(HplValue):\n    __slots__ = (\"values\", \"ros_types\")\n\n    def __init__(self, values):\n        self.values = values # [HplLiteral | HplFieldReference]\n        ros_types = set(ROS_PRIMITIVE_TYPES)\n        for value in values:\n            ros_types = ros_types & set(value.ros_types)\n        if not ros_types:\n            raise TypeError(\"mixed incompatible types: \" + repr(values))\n        self.ros_types = tuple(ros_types)\n\n",
        "source_code_len": 1153,
        "target_code": "\n    @property\n    def is_variable(self):\n        return False\n\n    @property\n    def is_this_msg(self):\n        return False\n\n\n###############################################################################\n# Compound Values\n###############################################################################\n\nclass HplSet(HplValue):\n    __slots__ = HplValue.__slots__ + (\"values\",)\n\n    def __init__(self, values):\n        HplValue.__init__(self, types=T_SET)\n        self.values = values # [HplValue]\n        for value in values:\n            self._type_check(value, T_PRIM)\n\n",
        "target_code_len": 574,
        "diff_format": "@@ -897,42 +1412,23 @@\n \n-\n-class HplLiteral(HplValue):\n-    __slots__ = (\"token\", \"value\", \"ros_types\")\n-\n-    def __init__(self, token, value):\n-        self.token = token # string\n-        self.value = value # int | long | float | bool | string\n-        self.ros_types = possible_types(value) # [TypeToken]\n-\n-    @property\n-    def is_literal(self):\n-        return True\n-\n-    def __eq__(self, other):\n-        if not isinstance(other, HplLiteral):\n-            return False\n-        return self.token == other.token\n-\n-    def __hash__(self):\n-        return hash(self.token)\n-\n-    def __str__(self):\n-        return self.token\n-\n-    def __repr__(self):\n-        return \"{}({}, {})\".format(type(self).__name__,\n-            repr(self.token), repr(self.value))\n-\n+    @property\n+    def is_variable(self):\n+        return False\n+\n+    @property\n+    def is_this_msg(self):\n+        return False\n+\n+\n+###############################################################################\n+# Compound Values\n+###############################################################################\n \n class HplSet(HplValue):\n-    __slots__ = (\"values\", \"ros_types\")\n+    __slots__ = HplValue.__slots__ + (\"values\",)\n \n     def __init__(self, values):\n-        self.values = values # [HplLiteral | HplFieldReference]\n-        ros_types = set(ROS_PRIMITIVE_TYPES)\n+        HplValue.__init__(self, types=T_SET)\n+        self.values = values # [HplValue]\n         for value in values:\n-            ros_types = ros_types & set(value.ros_types)\n-        if not ros_types:\n-            raise TypeError(\"mixed incompatible types: \" + repr(values))\n-        self.ros_types = tuple(ros_types)\n+            self._type_check(value, T_PRIM)\n \n",
        "source_code_with_indent": "\n\n<DED><DED>class HplLiteral(HplValue):\n    <IND>__slots__ = (\"token\", \"value\", \"ros_types\")\n\n    def __init__(self, token, value):\n        <IND>self.token = token # string\n        self.value = value # int | long | float | bool | string\n        self.ros_types = possible_types(value) # [TypeToken]\n\n    <DED>@property\n    def is_literal(self):\n        <IND>return True\n\n    <DED>def __eq__(self, other):\n        <IND>if not isinstance(other, HplLiteral):\n            <IND>return False\n        <DED>return self.token == other.token\n\n    <DED>def __hash__(self):\n        <IND>return hash(self.token)\n\n    <DED>def __str__(self):\n        <IND>return self.token\n\n    <DED>def __repr__(self):\n        <IND>return \"{}({}, {})\".format(type(self).__name__,\n            repr(self.token), repr(self.value))\n\n\n<DED><DED>class HplSet(HplValue):\n    <IND>__slots__ = (\"values\", \"ros_types\")\n\n    def __init__(self, values):\n        <IND>self.values = values # [HplLiteral | HplFieldReference]\n        ros_types = set(ROS_PRIMITIVE_TYPES)\n        for value in values:\n            <IND>ros_types = ros_types & set(value.ros_types)\n        <DED>if not ros_types:\n            <IND>raise TypeError(\"mixed incompatible types: \" + repr(values))\n        <DED>self.ros_types = tuple(ros_types)\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n    <DED>@property\n    def is_variable(self):\n        <IND>return False\n\n    <DED>@property\n    def is_this_msg(self):\n        <IND>return False\n\n\n###############################################################################\n# Compound Values\n###############################################################################\n\n<DED><DED>class HplSet(HplValue):\n    <IND>__slots__ = HplValue.__slots__ + (\"values\",)\n\n    def __init__(self, values):\n        <IND>HplValue.__init__(self, types=T_SET)\n        self.values = values # [HplValue]\n        for value in values:\n            <IND>self._type_check(value, T_PRIM)\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "git-afsantos/haros",
    "commit": "c6130786daebc4d05f4aa19ff705af9fa59210db",
    "filename": "haros/hpl/hpl_ast.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/git-afsantos-haros/haros/hpl/hpl_ast.py",
    "file_hunks_size": 50,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "haros/hpl/hpl_ast.py:928:4 Inconsistent override [15]: `__slots__` overrides attribute defined in `HplValue` inconsistently. Type `typing.Tuple[str, str]` is not a subtype of the overridden attribute `typing.Tuple[]`.",
    "message": " `__slots__` overrides attribute defined in `HplValue` inconsistently. Type `typing.Tuple[str, str]` is not a subtype of the overridden attribute `typing.Tuple[]`.",
    "rule_id": "Inconsistent override [15]",
    "warning_line_no": 928,
    "warning_line": "    __slots__ = (\"values\", \"ros_types\")",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n\nclass HplLiteral(HplValue):\n    __slots__ = (\"token\", \"value\", \"ros_types\")\n\n    def __init__(self, token, value):\n        self.token = token # string\n        self.value = value # int | long | float | bool | string\n        self.ros_types = possible_types(value) # [TypeToken]\n\n    @property\n    def is_literal(self):\n        return True\n\n    def __eq__(self, other):\n        if not isinstance(other, HplLiteral):\n            return False\n        return self.token == other.token\n\n    def __hash__(self):\n        return hash(self.token)\n\n    def __str__(self):\n        return self.token\n\n    def __repr__(self):\n        return \"{}({}, {})\".format(type(self).__name__,\n            repr(self.token), repr(self.value))\n\n\nclass HplSet(HplValue):\n    __slots__ = (\"values\", \"ros_types\")\n\n    def __init__(self, values):\n        self.values = values # [HplLiteral | HplFieldReference]\n        ros_types = set(ROS_PRIMITIVE_TYPES)\n        for value in values:\n            ros_types = ros_types & set(value.ros_types)\n        if not ros_types:\n            raise TypeError(\"mixed incompatible types: \" + repr(values))\n        self.ros_types = tuple(ros_types)\n\n",
        "source_code_len": 1153,
        "target_code": "\n    @property\n    def is_variable(self):\n        return False\n\n    @property\n    def is_this_msg(self):\n        return False\n\n\n###############################################################################\n# Compound Values\n###############################################################################\n\nclass HplSet(HplValue):\n    __slots__ = HplValue.__slots__ + (\"values\",)\n\n    def __init__(self, values):\n        HplValue.__init__(self, types=T_SET)\n        self.values = values # [HplValue]\n        for value in values:\n            self._type_check(value, T_PRIM)\n\n",
        "target_code_len": 574,
        "diff_format": "@@ -897,42 +1412,23 @@\n \n-\n-class HplLiteral(HplValue):\n-    __slots__ = (\"token\", \"value\", \"ros_types\")\n-\n-    def __init__(self, token, value):\n-        self.token = token # string\n-        self.value = value # int | long | float | bool | string\n-        self.ros_types = possible_types(value) # [TypeToken]\n-\n-    @property\n-    def is_literal(self):\n-        return True\n-\n-    def __eq__(self, other):\n-        if not isinstance(other, HplLiteral):\n-            return False\n-        return self.token == other.token\n-\n-    def __hash__(self):\n-        return hash(self.token)\n-\n-    def __str__(self):\n-        return self.token\n-\n-    def __repr__(self):\n-        return \"{}({}, {})\".format(type(self).__name__,\n-            repr(self.token), repr(self.value))\n-\n+    @property\n+    def is_variable(self):\n+        return False\n+\n+    @property\n+    def is_this_msg(self):\n+        return False\n+\n+\n+###############################################################################\n+# Compound Values\n+###############################################################################\n \n class HplSet(HplValue):\n-    __slots__ = (\"values\", \"ros_types\")\n+    __slots__ = HplValue.__slots__ + (\"values\",)\n \n     def __init__(self, values):\n-        self.values = values # [HplLiteral | HplFieldReference]\n-        ros_types = set(ROS_PRIMITIVE_TYPES)\n+        HplValue.__init__(self, types=T_SET)\n+        self.values = values # [HplValue]\n         for value in values:\n-            ros_types = ros_types & set(value.ros_types)\n-        if not ros_types:\n-            raise TypeError(\"mixed incompatible types: \" + repr(values))\n-        self.ros_types = tuple(ros_types)\n+            self._type_check(value, T_PRIM)\n \n",
        "source_code_with_indent": "\n\n<DED><DED>class HplLiteral(HplValue):\n    <IND>__slots__ = (\"token\", \"value\", \"ros_types\")\n\n    def __init__(self, token, value):\n        <IND>self.token = token # string\n        self.value = value # int | long | float | bool | string\n        self.ros_types = possible_types(value) # [TypeToken]\n\n    <DED>@property\n    def is_literal(self):\n        <IND>return True\n\n    <DED>def __eq__(self, other):\n        <IND>if not isinstance(other, HplLiteral):\n            <IND>return False\n        <DED>return self.token == other.token\n\n    <DED>def __hash__(self):\n        <IND>return hash(self.token)\n\n    <DED>def __str__(self):\n        <IND>return self.token\n\n    <DED>def __repr__(self):\n        <IND>return \"{}({}, {})\".format(type(self).__name__,\n            repr(self.token), repr(self.value))\n\n\n<DED><DED>class HplSet(HplValue):\n    <IND>__slots__ = (\"values\", \"ros_types\")\n\n    def __init__(self, values):\n        <IND>self.values = values # [HplLiteral | HplFieldReference]\n        ros_types = set(ROS_PRIMITIVE_TYPES)\n        for value in values:\n            <IND>ros_types = ros_types & set(value.ros_types)\n        <DED>if not ros_types:\n            <IND>raise TypeError(\"mixed incompatible types: \" + repr(values))\n        <DED>self.ros_types = tuple(ros_types)\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n    <DED>@property\n    def is_variable(self):\n        <IND>return False\n\n    <DED>@property\n    def is_this_msg(self):\n        <IND>return False\n\n\n###############################################################################\n# Compound Values\n###############################################################################\n\n<DED><DED>class HplSet(HplValue):\n    <IND>__slots__ = HplValue.__slots__ + (\"values\",)\n\n    def __init__(self, values):\n        <IND>HplValue.__init__(self, types=T_SET)\n        self.values = values # [HplValue]\n        for value in values:\n            <IND>self._type_check(value, T_PRIM)\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "git-afsantos/haros",
    "commit": "c6130786daebc4d05f4aa19ff705af9fa59210db",
    "filename": "haros/hpl/hpl_ast.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/git-afsantos-haros/haros/hpl/hpl_ast.py",
    "file_hunks_size": 50,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "haros/hpl/hpl_ast.py:965:4 Inconsistent override [15]: `__slots__` overrides attribute defined in `HplValue` inconsistently. Type `typing.Tuple[str, str, str, str, str]` is not a subtype of the overridden attribute `typing.Tuple[]`.",
    "message": " `__slots__` overrides attribute defined in `HplValue` inconsistently. Type `typing.Tuple[str, str, str, str, str]` is not a subtype of the overridden attribute `typing.Tuple[]`.",
    "rule_id": "Inconsistent override [15]",
    "warning_line_no": 965,
    "warning_line": "    __slots__ = (\"lower_bound\", \"upper_bound\", \"exclude_lower\",",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    def __repr__(self):\n        return \"{}({}, {}, {}, delay={}, duration={}, alias={})\".format(\n            type(self).__name__, self.event_type, repr(self.msg_filter),\n            self.topic, self.delay, self.duration, self.alias)\n\n\nclass HplEventChain(HplAstObject):\n    __slots__ = (\"events\", \"duration\")\n\n    def __init__(self, events, duration=INF):\n        if len(events) < 1:\n            raise ValueError(events)\n        self.events = events # [HplEvent]\n        self.duration = duration\n\n    @property\n    def root(self):\n        return self.events[0]\n\n    @property\n    def leaf(self):\n        return self.events[-1]\n\n    def prefix(self):\n        return self.events[:-1]\n\n    def suffix(self):\n        return self.events[1:]\n\n    def aliases(self):\n        return set(e.alias for e in self.events if e.alias is not None)\n\n    def external_references(self):\n        # assume sanity_check\n        aliases = set(e.alias for e in self.events if e.alias is not None)\n        refs = set()\n        for event in self.events:\n            for ref in event.external_references():\n                if ref not in aliases:\n                    refs.add(ref)\n        return refs\n\n    def sanity_check(self):\n        aliases = []\n        for ev in self.events:\n            if ev.alias is not None:\n                if ev.alias in aliases:\n                    raise HplSanityError(\"duplicate alias: \" + repr(ev.alias))\n            aliases.append(ev.alias)\n        for i in range(len(self.events)):\n            for ref in self.events[i].external_references():\n                for j in range(i + 1, len(aliases)):\n                    if ref == aliases[j]:\n                        raise HplSanityError(\n                            \"reference to a future event: \" + repr(ref))\n\n    def __eq__(self, other):\n        if not isinstance(other, HplEventChain):\n            return False\n        return (self.events == other.events\n                and self.duration == other.duration)\n\n    def __hash__(self):\n        h = hash(self.duration)\n        for event in self.events:\n            h = 31 * h + hash(event)\n        return h\n",
        "source_code_len": 2110,
        "target_code": "    def __repr__(self):\n        return \"{}({}, {}, {}, alias={})\".format(\n            type(self).__name__, repr(self.event_type), repr(self.predicate),\n            repr(self.topic), repr(self.alias))\n\n\n###############################################################################\n# Top-level Predicate\n###############################################################################\n\nclass HplPredicate(HplAstObject):\n    __slots__ = (\"condition\",)\n\n    _DIFF_TYPES = (\"multiple occurrences of '{}' with incompatible types: \"\n                   \"found ({}) and ({})\")\n    _NO_REFS = \"there are no references to any fields of this message\"\n\n    def __init__(self, expr):\n        if not expr.is_expression:\n            raise TypeError(\"not an expression: \" + str(expr))\n        if not expr.can_be_bool:\n            raise HplTypeError(\"not a boolean expression: \" + str(expr))\n        self.condition = expr\n        self._static_checks()\n\n    @property\n    def is_predicate(self):\n        return True\n\n    @property\n    def is_vacuous(self):\n        return False\n\n    @property\n    def phi(self):\n        return self.condition\n\n    def is_fully_typed(self):\n        return self.condition.is_fully_typed()\n\n    def children(self):\n        return (self.condition,)\n\n    def negate(self):\n        if self.condition.is_operator and self.condition.operator == \"not\":\n            return HplPredicate(self.condition.operand)\n        return HplPredicate(HplUnaryOperator(\"not\", self.condition))\n\n    def join(self, other):\n        if other.is_vacuous:\n            return self if other.is_true else other\n        expr = HplBinaryOperator(\"and\", self.condition, other.condition)\n        return HplPredicate(expr)\n\n    def refine_types(self, rostype, **kwargs):\n        # rostype: ROS Type Token\n        # kwargs: string (alias) -> ROS Type Token\n        stack = [self.condition]\n        while stack:\n            obj = stack.pop()\n            if obj.is_accessor:\n                self._refine_type(obj, rostype, **kwargs)\n            else:\n                stack.extend(reversed(obj.children()))\n\n    def _refine_type(self, accessor, rostype, **kwargs):\n        stack = [accessor]\n        expr = accessor.message\n        while expr.is_accessor:\n            stack.append(expr)\n            expr = expr.message\n        assert expr.is_value and (expr.is_this_msg or expr.is_variable)\n        if expr.is_this_msg:\n            t = rostype\n        else:\n            if expr.name not in kwargs:\n                raise HplSanityError(\n                    \"undefined message alias: '{}'\".format(expr.name))\n            t = kwargs[expr.name]\n        assert t.is_message\n        expr.ros_type = t\n        while stack:\n            expr = stack.pop()\n            if expr.is_field:\n                if not (t.is_message or expr.field in t.fields\n                        or expr.field in t.constants):\n                    raise HplTypeError.ros_field(t, expr.field, expr)\n                if expr.field in t.fields:\n                    t = t.fields[expr.field]\n                else:\n                    assert expr.field in t.constants, \\\n                        \"'{}' not in {} or {}\".format(\n                            expr.field, t.fields, t.constants)\n                    t = t.constants[expr.field].ros_type\n            else:\n                assert expr.is_indexed\n                if not t.is_array:\n                    raise HplTypeError.ros_array(t, expr)\n                i = expr.index\n                if (i.is_value and i.is_literal\n                        and not t.contains_index(i.value)):\n                    raise HplTypeError.ros_index(t, expr.index, expr)\n                t = t.type_token\n            if t.is_message:\n                accessor._type_check(expr, T_MSG)\n            elif t.is_array:\n                accessor._type_check(expr, T_ARR)\n            elif t.is_number:\n                accessor._type_check(expr, T_NUM)\n                # TODO check that values fit within types\n            elif t.is_bool:\n                accessor._type_check(expr, T_BOOL)\n            elif t.is_string:\n                accessor._type_check(expr, T_STR)\n            expr.ros_type = t\n\n    def _static_checks(self):\n        ref_table = {}\n        for obj in self.condition.iterate():\n            if obj.is_accessor or (obj.is_value and obj.is_variable):\n                key = str(obj)\n                refs = ref_table.get(key)\n                if refs is None:\n                    refs = []\n                    ref_table[key] = refs\n                refs.append(obj)\n        self._all_refs_same_type(ref_table)\n        self._some_field_refs(ref_table)\n\n    def _all_refs_same_type(self, table):\n        # All references to the same field/variable have the same type.\n        for key, refs in table.iteritems():\n            # must traverse twice, in case we start with the most generic\n            # and go down to the most specific\n            final_type = T_ANY\n            for ref in refs:\n                ref.cast(final_type)\n                final_type = ref.types\n            for ref in reversed(refs):\n                ref.cast(final_type)\n                final_type = ref.types\n\n    def _some_field_refs(self, table):\n        # There is, at least, one reference to a field (own).\n        #   [NYI] Stricter: one reference per atomic condition.\n        for refs in table.itervalues():\n            for ref in refs:\n                if not ref.is_accessor:\n                    break\n                if ref.is_indexed:\n                    break\n                if not ref.message.is_value:\n                    break\n                assert ref.message.is_reference\n                if not ref.message.is_this_msg:\n                    break\n                return # OK\n        raise HplSanityError(self._NO_REFS)\n\n    def __eq__(self, other):\n        if not isinstance(other, HplPredicate):\n            return False\n        return self.condition == other.condition\n\n    def __hash__(self):\n        return hash(self.condition)\n\n    def __str__(self):\n        return \"{{ {} }}\".format(self.condition)\n\n    def __repr__(self):\n        return \"{}({})\".format(type(self).__name__, repr(self.condition))\n\n\nclass HplVacuousTruth(HplAstObject):\n    __slots__ = ()\n\n    @property\n    def is_predicate(self):\n        return True\n\n    @property\n    def is_vacuous(self):\n        return True\n\n    @property\n    def is_true(self):\n        return True\n\n    def is_fully_typed(self):\n        return True\n\n    def negate(self):\n        return HplContradiction()\n\n    def join(self, other):\n        return other\n\n    def refine_types(self, rostype, **kwargs):\n        pass\n\n    def __eq__(self, other):\n        return isinstance(other, HplVacuousTruth)\n\n    def __hash__(self):\n        return 27644437\n\n    def __str__(self):\n        return \"{ True }\"\n\n    def __repr__(self):\n        return \"{}()\".format(type(self).__name__)\n\n\nclass HplContradiction(HplAstObject):\n    __slots__ = ()\n\n    @property\n    def is_predicate(self):\n        return True\n\n    @property\n    def is_vacuous(self):\n        return True\n\n    @property\n    def is_true(self):\n        return False\n\n    def is_fully_typed(self):\n        return True\n\n    def negate(self):\n        return HplVacuousTruth()\n\n    def join(self, other):\n        return self\n\n    def refine_types(self, rostype, **kwargs):\n        pass\n\n    def __eq__(self, other):\n        return isinstance(other, HplContradiction)\n\n    def __hash__(self):\n        return 65537\n\n    def __str__(self):\n        return \"{ False }\"\n\n    def __repr__(self):\n        return \"{}()\".format(type(self).__name__)\n\n\n###############################################################################\n# Type System\n###############################################################################\n\n# Bit Flags\n\n# These work as possible types for the expression.\n# An expression of unknown type would have \"any\" type (i.e., all flags on).\n# E.g., (T_NUM | T_BOOL) means the expression can be either a number or a bool.\n# Things like variables start with many possible types, and are refined as the\n# tree is built.\n\nT_BOOL = 0x1\nT_NUM = 0x2\nT_STR = 0x4\nT_ARR = 0x8\n\nT_RAN = 0x10\nT_SET = 0x20\nT_MSG = 0x40\n\nT_ANY = T_BOOL | T_NUM | T_STR | T_ARR | T_RAN | T_SET | T_MSG\nT_COMP = T_ARR | T_RAN | T_SET\nT_PRIM = T_BOOL | T_NUM | T_STR\nT_ROS = T_BOOL | T_NUM | T_STR | T_ARR | T_MSG\nT_ITEM = T_BOOL | T_NUM | T_STR | T_MSG\n\n_TYPE_NAMES = {\n    T_BOOL: \"boolean\",\n    T_NUM: \"number\",\n    T_STR: \"string\",\n    T_ARR: \"array\",\n    T_RAN: \"range\",\n    T_SET: \"set\",\n    T_MSG: \"ROS msg\",\n}\n\ndef type_name(t):\n    if t in _TYPE_NAMES:\n        return _TYPE_NAMES[t]\n    ns = []\n    for key, name in _TYPE_NAMES.items():\n        if (t & key) != 0:\n            ns.append(name)\n    return \" or \".join(ns)\n\n\n###############################################################################\n# Expressions\n###############################################################################\n\nclass HplExpression(HplAstObject):\n    __slots__ = (\"types\",)\n\n    def __init__(self, types=T_ANY):\n        self.types = types\n\n    @property\n    def is_expression(self):\n        return True\n\n    @property\n    def is_value(self):\n        return False\n\n    @property\n    def is_operator(self):\n        return False\n\n    @property\n    def is_function_call(self):\n        return False\n\n    @property\n    def is_quantifier(self):\n        return False\n\n    @property\n    def is_accessor(self):\n        return False\n\n    @property\n    def can_be_bool(self):\n        return bool(self.types & T_BOOL)\n\n    @property\n    def can_be_number(self):\n        return bool(self.types & T_NUM)\n\n    @property\n    def can_be_string(self):\n        return bool(self.types & T_STR)\n\n    @property\n    def can_be_array(self):\n        return bool(self.types & T_ARR)\n\n    @property\n    def can_be_set(self):\n        return bool(self.types & T_SET)\n\n    @property\n    def can_be_range(self):\n        return bool(self.types & T_RAN)\n\n    @property\n    def can_be_msg(self):\n        return bool(self.types & T_MSG)\n\n    def can_be(self, t):\n        return bool(self.types & t)\n\n    def is_fully_typed(self):\n        for obj in self.iterate():\n            t = obj.types\n            if (not t) or bool(t & (t - 1)): # not a power of 2\n                return False\n        return True\n\n    def cast(self, t):\n        r = self.types & t\n        if not r:\n            raise HplTypeError(\"expected ({}) but found ({}): {}\".format(\n                type_name(t), type_name(self.types), self))\n        self.types = r\n\n    def _type_check(self, x, t):\n        try:\n            x.cast(t)\n        except HplTypeError as e:\n            msg = \"Type error in expression '{}':\\n{}\".format(self, e)\n            raise HplTypeError(msg)\n\n    def add_type(self, t):\n        self.types = self.types | t\n\n    def rem_type(self, t):\n        self.types = self.types & ~t\n        if not self.types:\n            raise HplTypeError(\"no types left: \" + str(self))\n\n\n###############################################################################\n# Quantifiers\n###############################################################################\n\nclass HplQuantifier(HplExpression):\n    __slots__ = HplExpression.__slots__ + (\n        \"quantifier\", \"variable\", \"domain\", \"condition\")\n\n    _SET_REF = \"cannot reference quantified variable '{}' in the domain of:\\n{}\"\n    _MULTI_DEF = \"multiple definitions of variable '{}' in:\\n{}\"\n    _UNUSED = \"quantified variable '{}' is never used in:\\n{}\"\n\n    def __init__(self, qt, var, dom, p):\n        HplExpression.__init__(self, types=T_BOOL)\n        self.quantifier = qt # string\n        self.variable = var # string\n        self.domain = dom # HplExpression\n        self.condition = p # HplExpression\n        self._type_check(dom, T_COMP)\n        self._type_check(p, T_BOOL)\n        self._check_variables()\n\n    @property\n    def is_quantifier(self):\n        return True\n\n    @property\n    def is_universal(self):\n        return self.quantifier == \"forall\"\n\n    @property\n    def op(self):\n        return self.quantifier\n\n    @property\n    def x(self):\n        return self.variable\n\n    @property\n    def d(self):\n        return self.domain\n\n    @property\n    def p(self):\n        return self.condition\n\n    @property\n    def phi(self):\n        return self.condition\n\n    def children(self):\n        return (self.domain, self.condition)\n\n    def _check_variables(self):\n        types = self._check_domain_vars()\n        self._check_expression_vars(types)\n\n    def _check_domain_vars(self):\n        dom = self.domain\n        for obj in dom.iterate():\n            assert obj.is_expression\n            if obj.is_value and obj.is_variable:\n                assert not obj.is_defined\n                v = obj.name\n                if self.variable == v:\n                    raise HplSanityError(self._SET_REF.format(v, self))\n        if dom.is_value:\n            if dom.is_set or dom.is_range:\n                return dom.subtypes\n        return T_PRIM\n\n    def _check_expression_vars(self, t):\n        uid = id(self)\n        used = 0\n        for obj in self.condition.iterate():\n            assert obj.is_expression\n            if obj.is_value and obj.is_variable:\n                v = obj.name\n                if self.variable == v:\n                    if obj.is_defined:\n                        assert obj.defined_at != uid\n                        raise HplSanityError(self._MULTI_DEF.format(v, self))\n                    obj.defined_at = uid\n                    self._type_check(obj, t)\n                    used += 1\n        if not used:\n            raise HplSanityError(self._UNUSED.format(self.variable, self))\n\n    def __eq__(self, other):\n        if not isinstance(other, HplQuantifier):\n            return False\n        return (self.quantifier == other.quantifier\n                and self.variable == other.variable\n                and self.domain == other.domain\n                and self.condition == other.condition)\n\n    def __hash__(self):\n        h = 31 * hash(self.quantifier) + hash(self.variable)\n        h = 31 * h + hash(self.domain)\n        h = 31 * h + hash(self.condition)\n        return h\n",
        "target_code_len": 14123,
        "diff_format": "@@ -509,67 +559,497 @@\n     def __repr__(self):\n-        return \"{}({}, {}, {}, delay={}, duration={}, alias={})\".format(\n-            type(self).__name__, self.event_type, repr(self.msg_filter),\n-            self.topic, self.delay, self.duration, self.alias)\n-\n-\n-class HplEventChain(HplAstObject):\n-    __slots__ = (\"events\", \"duration\")\n-\n-    def __init__(self, events, duration=INF):\n-        if len(events) < 1:\n-            raise ValueError(events)\n-        self.events = events # [HplEvent]\n-        self.duration = duration\n-\n-    @property\n-    def root(self):\n-        return self.events[0]\n-\n-    @property\n-    def leaf(self):\n-        return self.events[-1]\n-\n-    def prefix(self):\n-        return self.events[:-1]\n-\n-    def suffix(self):\n-        return self.events[1:]\n-\n-    def aliases(self):\n-        return set(e.alias for e in self.events if e.alias is not None)\n-\n-    def external_references(self):\n-        # assume sanity_check\n-        aliases = set(e.alias for e in self.events if e.alias is not None)\n-        refs = set()\n-        for event in self.events:\n-            for ref in event.external_references():\n-                if ref not in aliases:\n-                    refs.add(ref)\n-        return refs\n-\n-    def sanity_check(self):\n-        aliases = []\n-        for ev in self.events:\n-            if ev.alias is not None:\n-                if ev.alias in aliases:\n-                    raise HplSanityError(\"duplicate alias: \" + repr(ev.alias))\n-            aliases.append(ev.alias)\n-        for i in range(len(self.events)):\n-            for ref in self.events[i].external_references():\n-                for j in range(i + 1, len(aliases)):\n-                    if ref == aliases[j]:\n-                        raise HplSanityError(\n-                            \"reference to a future event: \" + repr(ref))\n-\n-    def __eq__(self, other):\n-        if not isinstance(other, HplEventChain):\n+        return \"{}({}, {}, {}, alias={})\".format(\n+            type(self).__name__, repr(self.event_type), repr(self.predicate),\n+            repr(self.topic), repr(self.alias))\n+\n+\n+###############################################################################\n+# Top-level Predicate\n+###############################################################################\n+\n+class HplPredicate(HplAstObject):\n+    __slots__ = (\"condition\",)\n+\n+    _DIFF_TYPES = (\"multiple occurrences of '{}' with incompatible types: \"\n+                   \"found ({}) and ({})\")\n+    _NO_REFS = \"there are no references to any fields of this message\"\n+\n+    def __init__(self, expr):\n+        if not expr.is_expression:\n+            raise TypeError(\"not an expression: \" + str(expr))\n+        if not expr.can_be_bool:\n+            raise HplTypeError(\"not a boolean expression: \" + str(expr))\n+        self.condition = expr\n+        self._static_checks()\n+\n+    @property\n+    def is_predicate(self):\n+        return True\n+\n+    @property\n+    def is_vacuous(self):\n+        return False\n+\n+    @property\n+    def phi(self):\n+        return self.condition\n+\n+    def is_fully_typed(self):\n+        return self.condition.is_fully_typed()\n+\n+    def children(self):\n+        return (self.condition,)\n+\n+    def negate(self):\n+        if self.condition.is_operator and self.condition.operator == \"not\":\n+            return HplPredicate(self.condition.operand)\n+        return HplPredicate(HplUnaryOperator(\"not\", self.condition))\n+\n+    def join(self, other):\n+        if other.is_vacuous:\n+            return self if other.is_true else other\n+        expr = HplBinaryOperator(\"and\", self.condition, other.condition)\n+        return HplPredicate(expr)\n+\n+    def refine_types(self, rostype, **kwargs):\n+        # rostype: ROS Type Token\n+        # kwargs: string (alias) -> ROS Type Token\n+        stack = [self.condition]\n+        while stack:\n+            obj = stack.pop()\n+            if obj.is_accessor:\n+                self._refine_type(obj, rostype, **kwargs)\n+            else:\n+                stack.extend(reversed(obj.children()))\n+\n+    def _refine_type(self, accessor, rostype, **kwargs):\n+        stack = [accessor]\n+        expr = accessor.message\n+        while expr.is_accessor:\n+            stack.append(expr)\n+            expr = expr.message\n+        assert expr.is_value and (expr.is_this_msg or expr.is_variable)\n+        if expr.is_this_msg:\n+            t = rostype\n+        else:\n+            if expr.name not in kwargs:\n+                raise HplSanityError(\n+                    \"undefined message alias: '{}'\".format(expr.name))\n+            t = kwargs[expr.name]\n+        assert t.is_message\n+        expr.ros_type = t\n+        while stack:\n+            expr = stack.pop()\n+            if expr.is_field:\n+                if not (t.is_message or expr.field in t.fields\n+                        or expr.field in t.constants):\n+                    raise HplTypeError.ros_field(t, expr.field, expr)\n+                if expr.field in t.fields:\n+                    t = t.fields[expr.field]\n+                else:\n+                    assert expr.field in t.constants, \\\n+                        \"'{}' not in {} or {}\".format(\n+                            expr.field, t.fields, t.constants)\n+                    t = t.constants[expr.field].ros_type\n+            else:\n+                assert expr.is_indexed\n+                if not t.is_array:\n+                    raise HplTypeError.ros_array(t, expr)\n+                i = expr.index\n+                if (i.is_value and i.is_literal\n+                        and not t.contains_index(i.value)):\n+                    raise HplTypeError.ros_index(t, expr.index, expr)\n+                t = t.type_token\n+            if t.is_message:\n+                accessor._type_check(expr, T_MSG)\n+            elif t.is_array:\n+                accessor._type_check(expr, T_ARR)\n+            elif t.is_number:\n+                accessor._type_check(expr, T_NUM)\n+                # TODO check that values fit within types\n+            elif t.is_bool:\n+                accessor._type_check(expr, T_BOOL)\n+            elif t.is_string:\n+                accessor._type_check(expr, T_STR)\n+            expr.ros_type = t\n+\n+    def _static_checks(self):\n+        ref_table = {}\n+        for obj in self.condition.iterate():\n+            if obj.is_accessor or (obj.is_value and obj.is_variable):\n+                key = str(obj)\n+                refs = ref_table.get(key)\n+                if refs is None:\n+                    refs = []\n+                    ref_table[key] = refs\n+                refs.append(obj)\n+        self._all_refs_same_type(ref_table)\n+        self._some_field_refs(ref_table)\n+\n+    def _all_refs_same_type(self, table):\n+        # All references to the same field/variable have the same type.\n+        for key, refs in table.iteritems():\n+            # must traverse twice, in case we start with the most generic\n+            # and go down to the most specific\n+            final_type = T_ANY\n+            for ref in refs:\n+                ref.cast(final_type)\n+                final_type = ref.types\n+            for ref in reversed(refs):\n+                ref.cast(final_type)\n+                final_type = ref.types\n+\n+    def _some_field_refs(self, table):\n+        # There is, at least, one reference to a field (own).\n+        #   [NYI] Stricter: one reference per atomic condition.\n+        for refs in table.itervalues():\n+            for ref in refs:\n+                if not ref.is_accessor:\n+                    break\n+                if ref.is_indexed:\n+                    break\n+                if not ref.message.is_value:\n+                    break\n+                assert ref.message.is_reference\n+                if not ref.message.is_this_msg:\n+                    break\n+                return # OK\n+        raise HplSanityError(self._NO_REFS)\n+\n+    def __eq__(self, other):\n+        if not isinstance(other, HplPredicate):\n             return False\n-        return (self.events == other.events\n-                and self.duration == other.duration)\n-\n-    def __hash__(self):\n-        h = hash(self.duration)\n-        for event in self.events:\n-            h = 31 * h + hash(event)\n+        return self.condition == other.condition\n+\n+    def __hash__(self):\n+        return hash(self.condition)\n+\n+    def __str__(self):\n+        return \"{{ {} }}\".format(self.condition)\n+\n+    def __repr__(self):\n+        return \"{}({})\".format(type(self).__name__, repr(self.condition))\n+\n+\n+class HplVacuousTruth(HplAstObject):\n+    __slots__ = ()\n+\n+    @property\n+    def is_predicate(self):\n+        return True\n+\n+    @property\n+    def is_vacuous(self):\n+        return True\n+\n+    @property\n+    def is_true(self):\n+        return True\n+\n+    def is_fully_typed(self):\n+        return True\n+\n+    def negate(self):\n+        return HplContradiction()\n+\n+    def join(self, other):\n+        return other\n+\n+    def refine_types(self, rostype, **kwargs):\n+        pass\n+\n+    def __eq__(self, other):\n+        return isinstance(other, HplVacuousTruth)\n+\n+    def __hash__(self):\n+        return 27644437\n+\n+    def __str__(self):\n+        return \"{ True }\"\n+\n+    def __repr__(self):\n+        return \"{}()\".format(type(self).__name__)\n+\n+\n+class HplContradiction(HplAstObject):\n+    __slots__ = ()\n+\n+    @property\n+    def is_predicate(self):\n+        return True\n+\n+    @property\n+    def is_vacuous(self):\n+        return True\n+\n+    @property\n+    def is_true(self):\n+        return False\n+\n+    def is_fully_typed(self):\n+        return True\n+\n+    def negate(self):\n+        return HplVacuousTruth()\n+\n+    def join(self, other):\n+        return self\n+\n+    def refine_types(self, rostype, **kwargs):\n+        pass\n+\n+    def __eq__(self, other):\n+        return isinstance(other, HplContradiction)\n+\n+    def __hash__(self):\n+        return 65537\n+\n+    def __str__(self):\n+        return \"{ False }\"\n+\n+    def __repr__(self):\n+        return \"{}()\".format(type(self).__name__)\n+\n+\n+###############################################################################\n+# Type System\n+###############################################################################\n+\n+# Bit Flags\n+\n+# These work as possible types for the expression.\n+# An expression of unknown type would have \"any\" type (i.e., all flags on).\n+# E.g., (T_NUM | T_BOOL) means the expression can be either a number or a bool.\n+# Things like variables start with many possible types, and are refined as the\n+# tree is built.\n+\n+T_BOOL = 0x1\n+T_NUM = 0x2\n+T_STR = 0x4\n+T_ARR = 0x8\n+\n+T_RAN = 0x10\n+T_SET = 0x20\n+T_MSG = 0x40\n+\n+T_ANY = T_BOOL | T_NUM | T_STR | T_ARR | T_RAN | T_SET | T_MSG\n+T_COMP = T_ARR | T_RAN | T_SET\n+T_PRIM = T_BOOL | T_NUM | T_STR\n+T_ROS = T_BOOL | T_NUM | T_STR | T_ARR | T_MSG\n+T_ITEM = T_BOOL | T_NUM | T_STR | T_MSG\n+\n+_TYPE_NAMES = {\n+    T_BOOL: \"boolean\",\n+    T_NUM: \"number\",\n+    T_STR: \"string\",\n+    T_ARR: \"array\",\n+    T_RAN: \"range\",\n+    T_SET: \"set\",\n+    T_MSG: \"ROS msg\",\n+}\n+\n+def type_name(t):\n+    if t in _TYPE_NAMES:\n+        return _TYPE_NAMES[t]\n+    ns = []\n+    for key, name in _TYPE_NAMES.items():\n+        if (t & key) != 0:\n+            ns.append(name)\n+    return \" or \".join(ns)\n+\n+\n+###############################################################################\n+# Expressions\n+###############################################################################\n+\n+class HplExpression(HplAstObject):\n+    __slots__ = (\"types\",)\n+\n+    def __init__(self, types=T_ANY):\n+        self.types = types\n+\n+    @property\n+    def is_expression(self):\n+        return True\n+\n+    @property\n+    def is_value(self):\n+        return False\n+\n+    @property\n+    def is_operator(self):\n+        return False\n+\n+    @property\n+    def is_function_call(self):\n+        return False\n+\n+    @property\n+    def is_quantifier(self):\n+        return False\n+\n+    @property\n+    def is_accessor(self):\n+        return False\n+\n+    @property\n+    def can_be_bool(self):\n+        return bool(self.types & T_BOOL)\n+\n+    @property\n+    def can_be_number(self):\n+        return bool(self.types & T_NUM)\n+\n+    @property\n+    def can_be_string(self):\n+        return bool(self.types & T_STR)\n+\n+    @property\n+    def can_be_array(self):\n+        return bool(self.types & T_ARR)\n+\n+    @property\n+    def can_be_set(self):\n+        return bool(self.types & T_SET)\n+\n+    @property\n+    def can_be_range(self):\n+        return bool(self.types & T_RAN)\n+\n+    @property\n+    def can_be_msg(self):\n+        return bool(self.types & T_MSG)\n+\n+    def can_be(self, t):\n+        return bool(self.types & t)\n+\n+    def is_fully_typed(self):\n+        for obj in self.iterate():\n+            t = obj.types\n+            if (not t) or bool(t & (t - 1)): # not a power of 2\n+                return False\n+        return True\n+\n+    def cast(self, t):\n+        r = self.types & t\n+        if not r:\n+            raise HplTypeError(\"expected ({}) but found ({}): {}\".format(\n+                type_name(t), type_name(self.types), self))\n+        self.types = r\n+\n+    def _type_check(self, x, t):\n+        try:\n+            x.cast(t)\n+        except HplTypeError as e:\n+            msg = \"Type error in expression '{}':\\n{}\".format(self, e)\n+            raise HplTypeError(msg)\n+\n+    def add_type(self, t):\n+        self.types = self.types | t\n+\n+    def rem_type(self, t):\n+        self.types = self.types & ~t\n+        if not self.types:\n+            raise HplTypeError(\"no types left: \" + str(self))\n+\n+\n+###############################################################################\n+# Quantifiers\n+###############################################################################\n+\n+class HplQuantifier(HplExpression):\n+    __slots__ = HplExpression.__slots__ + (\n+        \"quantifier\", \"variable\", \"domain\", \"condition\")\n+\n+    _SET_REF = \"cannot reference quantified variable '{}' in the domain of:\\n{}\"\n+    _MULTI_DEF = \"multiple definitions of variable '{}' in:\\n{}\"\n+    _UNUSED = \"quantified variable '{}' is never used in:\\n{}\"\n+\n+    def __init__(self, qt, var, dom, p):\n+        HplExpression.__init__(self, types=T_BOOL)\n+        self.quantifier = qt # string\n+        self.variable = var # string\n+        self.domain = dom # HplExpression\n+        self.condition = p # HplExpression\n+        self._type_check(dom, T_COMP)\n+        self._type_check(p, T_BOOL)\n+        self._check_variables()\n+\n+    @property\n+    def is_quantifier(self):\n+        return True\n+\n+    @property\n+    def is_universal(self):\n+        return self.quantifier == \"forall\"\n+\n+    @property\n+    def op(self):\n+        return self.quantifier\n+\n+    @property\n+    def x(self):\n+        return self.variable\n+\n+    @property\n+    def d(self):\n+        return self.domain\n+\n+    @property\n+    def p(self):\n+        return self.condition\n+\n+    @property\n+    def phi(self):\n+        return self.condition\n+\n+    def children(self):\n+        return (self.domain, self.condition)\n+\n+    def _check_variables(self):\n+        types = self._check_domain_vars()\n+        self._check_expression_vars(types)\n+\n+    def _check_domain_vars(self):\n+        dom = self.domain\n+        for obj in dom.iterate():\n+            assert obj.is_expression\n+            if obj.is_value and obj.is_variable:\n+                assert not obj.is_defined\n+                v = obj.name\n+                if self.variable == v:\n+                    raise HplSanityError(self._SET_REF.format(v, self))\n+        if dom.is_value:\n+            if dom.is_set or dom.is_range:\n+                return dom.subtypes\n+        return T_PRIM\n+\n+    def _check_expression_vars(self, t):\n+        uid = id(self)\n+        used = 0\n+        for obj in self.condition.iterate():\n+            assert obj.is_expression\n+            if obj.is_value and obj.is_variable:\n+                v = obj.name\n+                if self.variable == v:\n+                    if obj.is_defined:\n+                        assert obj.defined_at != uid\n+                        raise HplSanityError(self._MULTI_DEF.format(v, self))\n+                    obj.defined_at = uid\n+                    self._type_check(obj, t)\n+                    used += 1\n+        if not used:\n+            raise HplSanityError(self._UNUSED.format(self.variable, self))\n+\n+    def __eq__(self, other):\n+        if not isinstance(other, HplQuantifier):\n+            return False\n+        return (self.quantifier == other.quantifier\n+                and self.variable == other.variable\n+                and self.domain == other.domain\n+                and self.condition == other.condition)\n+\n+    def __hash__(self):\n+        h = 31 * hash(self.quantifier) + hash(self.variable)\n+        h = 31 * h + hash(self.domain)\n+        h = 31 * h + hash(self.condition)\n         return h\n",
        "source_code_with_indent": "    <DED><DED>def __repr__(self):\n        <IND>return \"{}({}, {}, {}, delay={}, duration={}, alias={})\".format(\n            type(self).__name__, self.event_type, repr(self.msg_filter),\n            self.topic, self.delay, self.duration, self.alias)\n\n\n<DED><DED>class HplEventChain(HplAstObject):\n    <IND>__slots__ = (\"events\", \"duration\")\n\n    def __init__(self, events, duration=INF):\n        <IND>if len(events) < 1:\n            <IND>raise ValueError(events)\n        <DED>self.events = events # [HplEvent]\n        self.duration = duration\n\n    <DED>@property\n    def root(self):\n        <IND>return self.events[0]\n\n    <DED>@property\n    def leaf(self):\n        <IND>return self.events[-1]\n\n    <DED>def prefix(self):\n        <IND>return self.events[:-1]\n\n    <DED>def suffix(self):\n        <IND>return self.events[1:]\n\n    <DED>def aliases(self):\n        <IND>return set(e.alias for e in self.events if e.alias is not None)\n\n    <DED>def external_references(self):\n        # assume sanity_check\n        <IND>aliases = set(e.alias for e in self.events if e.alias is not None)\n        refs = set()\n        for event in self.events:\n            <IND>for ref in event.external_references():\n                <IND>if ref not in aliases:\n                    <IND>refs.add(ref)\n        <DED><DED><DED>return refs\n\n    <DED>def sanity_check(self):\n        <IND>aliases = []\n        for ev in self.events:\n            <IND>if ev.alias is not None:\n                <IND>if ev.alias in aliases:\n                    <IND>raise HplSanityError(\"duplicate alias: \" + repr(ev.alias))\n            <DED><DED>aliases.append(ev.alias)\n        <DED>for i in range(len(self.events)):\n            <IND>for ref in self.events[i].external_references():\n                <IND>for j in range(i + 1, len(aliases)):\n                    <IND>if ref == aliases[j]:\n                        <IND>raise HplSanityError(\n                            \"reference to a future event: \" + repr(ref))\n\n    <DED><DED><DED><DED><DED>def __eq__(self, other):\n        <IND>if not isinstance(other, HplEventChain):\n            <IND>return False\n        <DED>return (self.events == other.events\n                and self.duration == other.duration)\n\n    <DED>def __hash__(self):\n        <IND>h = hash(self.duration)\n        for event in self.events:\n            <IND>h = 31 * h + hash(event)\n        <DED>return h\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent_exact_match": false,
        "target_code_with_indent": "    <DED><DED>def __repr__(self):\n        <IND>return \"{}({}, {}, {}, alias={})\".format(\n            type(self).__name__, repr(self.event_type), repr(self.predicate),\n            repr(self.topic), repr(self.alias))\n\n\n###############################################################################\n# Top-level Predicate\n###############################################################################\n\n<DED><DED>class HplPredicate(HplAstObject):\n    <IND>__slots__ = (\"condition\",)\n\n    _DIFF_TYPES = (\"multiple occurrences of '{}' with incompatible types: \"\n                   \"found ({}) and ({})\")\n    _NO_REFS = \"there are no references to any fields of this message\"\n\n    def __init__(self, expr):\n        <IND>if not expr.is_expression:\n            <IND>raise TypeError(\"not an expression: \" + str(expr))\n        <DED>if not expr.can_be_bool:\n            <IND>raise HplTypeError(\"not a boolean expression: \" + str(expr))\n        <DED>self.condition = expr\n        self._static_checks()\n\n    <DED>@property\n    def is_predicate(self):\n        <IND>return True\n\n    <DED>@property\n    def is_vacuous(self):\n        <IND>return False\n\n    <DED>@property\n    def phi(self):\n        <IND>return self.condition\n\n    <DED>def is_fully_typed(self):\n        <IND>return self.condition.is_fully_typed()\n\n    <DED>def children(self):\n        <IND>return (self.condition,)\n\n    <DED>def negate(self):\n        <IND>if self.condition.is_operator and self.condition.operator == \"not\":\n            <IND>return HplPredicate(self.condition.operand)\n        <DED>return HplPredicate(HplUnaryOperator(\"not\", self.condition))\n\n    <DED>def join(self, other):\n        <IND>if other.is_vacuous:\n            <IND>return self if other.is_true else other\n        <DED>expr = HplBinaryOperator(\"and\", self.condition, other.condition)\n        return HplPredicate(expr)\n\n    <DED>def refine_types(self, rostype, **kwargs):\n        # rostype: ROS Type Token\n        # kwargs: string (alias) -> ROS Type Token\n        <IND>stack = [self.condition]\n        while stack:\n            <IND>obj = stack.pop()\n            if obj.is_accessor:\n                <IND>self._refine_type(obj, rostype, **kwargs)\n            <DED>else:\n                <IND>stack.extend(reversed(obj.children()))\n\n    <DED><DED><DED>def _refine_type(self, accessor, rostype, **kwargs):\n        <IND>stack = [accessor]\n        expr = accessor.message\n        while expr.is_accessor:\n            <IND>stack.append(expr)\n            expr = expr.message\n        <DED>assert expr.is_value and (expr.is_this_msg or expr.is_variable)\n        if expr.is_this_msg:\n            <IND>t = rostype\n        <DED>else:\n            <IND>if expr.name not in kwargs:\n                <IND>raise HplSanityError(\n                    \"undefined message alias: '{}'\".format(expr.name))\n            <DED>t = kwargs[expr.name]\n        <DED>assert t.is_message\n        expr.ros_type = t\n        while stack:\n            <IND>expr = stack.pop()\n            if expr.is_field:\n                <IND>if not (t.is_message or expr.field in t.fields\n                        or expr.field in t.constants):\n                    <IND>raise HplTypeError.ros_field(t, expr.field, expr)\n                <DED>if expr.field in t.fields:\n                    <IND>t = t.fields[expr.field]\n                <DED>else:\n                    <IND>assert expr.field in t.constants,                        \"'{}' not in {} or {}\".format(\n                            expr.field, t.fields, t.constants)\n                    t = t.constants[expr.field].ros_type\n            <DED><DED>else:\n                <IND>assert expr.is_indexed\n                if not t.is_array:\n                    <IND>raise HplTypeError.ros_array(t, expr)\n                <DED>i = expr.index\n                if (i.is_value and i.is_literal\n                        and not t.contains_index(i.value)):\n                    <IND>raise HplTypeError.ros_index(t, expr.index, expr)\n                <DED>t = t.type_token\n            <DED>if t.is_message:\n                <IND>accessor._type_check(expr, T_MSG)\n            <DED>elif t.is_array:\n                <IND>accessor._type_check(expr, T_ARR)\n            <DED>elif t.is_number:\n                <IND>accessor._type_check(expr, T_NUM)\n                # TODO check that values fit within types\n            <DED>elif t.is_bool:\n                <IND>accessor._type_check(expr, T_BOOL)\n            <DED>elif t.is_string:\n                <IND>accessor._type_check(expr, T_STR)\n            <DED>expr.ros_type = t\n\n    <DED><DED>def _static_checks(self):\n        <IND>ref_table = {}\n        for obj in self.condition.iterate():\n            <IND>if obj.is_accessor or (obj.is_value and obj.is_variable):\n                <IND>key = str(obj)\n                refs = ref_table.get(key)\n                if refs is None:\n                    <IND>refs = []\n                    ref_table[key] = refs\n                <DED>refs.append(obj)\n        <DED><DED>self._all_refs_same_type(ref_table)\n        self._some_field_refs(ref_table)\n\n    <DED>def _all_refs_same_type(self, table):\n        # All references to the same field/variable have the same type.\n        <IND>for key, refs in table.iteritems():\n            # must traverse twice, in case we start with the most generic\n            # and go down to the most specific\n            <IND>final_type = T_ANY\n            for ref in refs:\n                <IND>ref.cast(final_type)\n                final_type = ref.types\n            <DED>for ref in reversed(refs):\n                <IND>ref.cast(final_type)\n                final_type = ref.types\n\n    <DED><DED><DED>def _some_field_refs(self, table):\n        # There is, at least, one reference to a field (own).\n        #   [NYI] Stricter: one reference per atomic condition.\n        <IND>for refs in table.itervalues():\n            <IND>for ref in refs:\n                <IND>if not ref.is_accessor:\n                    <IND>break\n                <DED>if ref.is_indexed:\n                    <IND>break\n                <DED>if not ref.message.is_value:\n                    <IND>break\n                <DED>assert ref.message.is_reference\n                if not ref.message.is_this_msg:\n                    <IND>break\n                <DED>return # OK\n        <DED><DED>raise HplSanityError(self._NO_REFS)\n\n    <DED>def __eq__(self, other):\n        <IND>if not isinstance(other, HplPredicate):\n            <IND>return False\n        <DED>return self.condition == other.condition\n\n    <DED>def __hash__(self):\n        <IND>return hash(self.condition)\n\n    <DED>def __str__(self):\n        <IND>return \"{{ {} }}\".format(self.condition)\n\n    <DED>def __repr__(self):\n        <IND>return \"{}({})\".format(type(self).__name__, repr(self.condition))\n\n\n<DED><DED>class HplVacuousTruth(HplAstObject):\n    <IND>__slots__ = ()\n\n    @property\n    def is_predicate(self):\n        <IND>return True\n\n    <DED>@property\n    def is_vacuous(self):\n        <IND>return True\n\n    <DED>@property\n    def is_true(self):\n        <IND>return True\n\n    <DED>def is_fully_typed(self):\n        <IND>return True\n\n    <DED>def negate(self):\n        <IND>return HplContradiction()\n\n    <DED>def join(self, other):\n        <IND>return other\n\n    <DED>def refine_types(self, rostype, **kwargs):\n        <IND>pass\n\n    <DED>def __eq__(self, other):\n        <IND>return isinstance(other, HplVacuousTruth)\n\n    <DED>def __hash__(self):\n        <IND>return 27644437\n\n    <DED>def __str__(self):\n        <IND>return \"{ True }\"\n\n    <DED>def __repr__(self):\n        <IND>return \"{}()\".format(type(self).__name__)\n\n\n<DED><DED>class HplContradiction(HplAstObject):\n    <IND>__slots__ = ()\n\n    @property\n    def is_predicate(self):\n        <IND>return True\n\n    <DED>@property\n    def is_vacuous(self):\n        <IND>return True\n\n    <DED>@property\n    def is_true(self):\n        <IND>return False\n\n    <DED>def is_fully_typed(self):\n        <IND>return True\n\n    <DED>def negate(self):\n        <IND>return HplVacuousTruth()\n\n    <DED>def join(self, other):\n        <IND>return self\n\n    <DED>def refine_types(self, rostype, **kwargs):\n        <IND>pass\n\n    <DED>def __eq__(self, other):\n        <IND>return isinstance(other, HplContradiction)\n\n    <DED>def __hash__(self):\n        <IND>return 65537\n\n    <DED>def __str__(self):\n        <IND>return \"{ False }\"\n\n    <DED>def __repr__(self):\n        <IND>return \"{}()\".format(type(self).__name__)\n\n\n###############################################################################\n# Type System\n###############################################################################\n\n# Bit Flags\n\n# These work as possible types for the expression.\n# An expression of unknown type would have \"any\" type (i.e., all flags on).\n# E.g., (T_NUM | T_BOOL) means the expression can be either a number or a bool.\n# Things like variables start with many possible types, and are refined as the\n# tree is built.\n\n<DED><DED>T_BOOL = 0x1\nT_NUM = 0x2\nT_STR = 0x4\nT_ARR = 0x8\n\nT_RAN = 0x10\nT_SET = 0x20\nT_MSG = 0x40\n\nT_ANY = T_BOOL | T_NUM | T_STR | T_ARR | T_RAN | T_SET | T_MSG\nT_COMP = T_ARR | T_RAN | T_SET\nT_PRIM = T_BOOL | T_NUM | T_STR\nT_ROS = T_BOOL | T_NUM | T_STR | T_ARR | T_MSG\nT_ITEM = T_BOOL | T_NUM | T_STR | T_MSG\n\n_TYPE_NAMES = {\n    T_BOOL: \"boolean\",\n    T_NUM: \"number\",\n    T_STR: \"string\",\n    T_ARR: \"array\",\n    T_RAN: \"range\",\n    T_SET: \"set\",\n    T_MSG: \"ROS msg\",\n}\n\ndef type_name(t):\n    <IND>if t in _TYPE_NAMES:\n        <IND>return _TYPE_NAMES[t]\n    <DED>ns = []\n    for key, name in _TYPE_NAMES.items():\n        <IND>if (t & key) != 0:\n            <IND>ns.append(name)\n    <DED><DED>return \" or \".join(ns)\n\n\n###############################################################################\n# Expressions\n###############################################################################\n\n<DED>class HplExpression(HplAstObject):\n    <IND>__slots__ = (\"types\",)\n\n    def __init__(self, types=T_ANY):\n        <IND>self.types = types\n\n    <DED>@property\n    def is_expression(self):\n        <IND>return True\n\n    <DED>@property\n    def is_value(self):\n        <IND>return False\n\n    <DED>@property\n    def is_operator(self):\n        <IND>return False\n\n    <DED>@property\n    def is_function_call(self):\n        <IND>return False\n\n    <DED>@property\n    def is_quantifier(self):\n        <IND>return False\n\n    <DED>@property\n    def is_accessor(self):\n        <IND>return False\n\n    <DED>@property\n    def can_be_bool(self):\n        <IND>return bool(self.types & T_BOOL)\n\n    <DED>@property\n    def can_be_number(self):\n        <IND>return bool(self.types & T_NUM)\n\n    <DED>@property\n    def can_be_string(self):\n        <IND>return bool(self.types & T_STR)\n\n    <DED>@property\n    def can_be_array(self):\n        <IND>return bool(self.types & T_ARR)\n\n    <DED>@property\n    def can_be_set(self):\n        <IND>return bool(self.types & T_SET)\n\n    <DED>@property\n    def can_be_range(self):\n        <IND>return bool(self.types & T_RAN)\n\n    <DED>@property\n    def can_be_msg(self):\n        <IND>return bool(self.types & T_MSG)\n\n    <DED>def can_be(self, t):\n        <IND>return bool(self.types & t)\n\n    <DED>def is_fully_typed(self):\n        <IND>for obj in self.iterate():\n            <IND>t = obj.types\n            if (not t) or bool(t & (t - 1)): # not a power of 2\n                <IND>return False\n        <DED><DED>return True\n\n    <DED>def cast(self, t):\n        <IND>r = self.types & t\n        if not r:\n            <IND>raise HplTypeError(\"expected ({}) but found ({}): {}\".format(\n                type_name(t), type_name(self.types), self))\n        <DED>self.types = r\n\n    <DED>def _type_check(self, x, t):\n        <IND>try:\n            <IND>x.cast(t)\n        <DED>except HplTypeError as e:\n            <IND>msg = \"Type error in expression '{}':\\n{}\".format(self, e)\n            raise HplTypeError(msg)\n\n    <DED><DED>def add_type(self, t):\n        <IND>self.types = self.types | t\n\n    <DED>def rem_type(self, t):\n        <IND>self.types = self.types & ~t\n        if not self.types:\n            <IND>raise HplTypeError(\"no types left: \" + str(self))\n\n\n###############################################################################\n# Quantifiers\n###############################################################################\n\n<DED><DED><DED>class HplQuantifier(HplExpression):\n    <IND>__slots__ = HplExpression.__slots__ + (\n        \"quantifier\", \"variable\", \"domain\", \"condition\")\n\n    _SET_REF = \"cannot reference quantified variable '{}' in the domain of:\\n{}\"\n    _MULTI_DEF = \"multiple definitions of variable '{}' in:\\n{}\"\n    _UNUSED = \"quantified variable '{}' is never used in:\\n{}\"\n\n    def __init__(self, qt, var, dom, p):\n        <IND>HplExpression.__init__(self, types=T_BOOL)\n        self.quantifier = qt # string\n        self.variable = var # string\n        self.domain = dom # HplExpression\n        self.condition = p # HplExpression\n        self._type_check(dom, T_COMP)\n        self._type_check(p, T_BOOL)\n        self._check_variables()\n\n    <DED>@property\n    def is_quantifier(self):\n        <IND>return True\n\n    <DED>@property\n    def is_universal(self):\n        <IND>return self.quantifier == \"forall\"\n\n    <DED>@property\n    def op(self):\n        <IND>return self.quantifier\n\n    <DED>@property\n    def x(self):\n        <IND>return self.variable\n\n    <DED>@property\n    def d(self):\n        <IND>return self.domain\n\n    <DED>@property\n    def p(self):\n        <IND>return self.condition\n\n    <DED>@property\n    def phi(self):\n        <IND>return self.condition\n\n    <DED>def children(self):\n        <IND>return (self.domain, self.condition)\n\n    <DED>def _check_variables(self):\n        <IND>types = self._check_domain_vars()\n        self._check_expression_vars(types)\n\n    <DED>def _check_domain_vars(self):\n        <IND>dom = self.domain\n        for obj in dom.iterate():\n            <IND>assert obj.is_expression\n            if obj.is_value and obj.is_variable:\n                <IND>assert not obj.is_defined\n                v = obj.name\n                if self.variable == v:\n                    <IND>raise HplSanityError(self._SET_REF.format(v, self))\n        <DED><DED><DED>if dom.is_value:\n            <IND>if dom.is_set or dom.is_range:\n                <IND>return dom.subtypes\n        <DED><DED>return T_PRIM\n\n    <DED>def _check_expression_vars(self, t):\n        <IND>uid = id(self)\n        used = 0\n        for obj in self.condition.iterate():\n            <IND>assert obj.is_expression\n            if obj.is_value and obj.is_variable:\n                <IND>v = obj.name\n                if self.variable == v:\n                    <IND>if obj.is_defined:\n                        <IND>assert obj.defined_at != uid\n                        raise HplSanityError(self._MULTI_DEF.format(v, self))\n                    <DED>obj.defined_at = uid\n                    self._type_check(obj, t)\n                    used += 1\n        <DED><DED><DED>if not used:\n            <IND>raise HplSanityError(self._UNUSED.format(self.variable, self))\n\n    <DED><DED>def __eq__(self, other):\n        <IND>if not isinstance(other, HplQuantifier):\n            <IND>return False\n        <DED>return (self.quantifier == other.quantifier\n                and self.variable == other.variable\n                and self.domain == other.domain\n                and self.condition == other.condition)\n\n    <DED>def __hash__(self):\n        <IND>h = 31 * hash(self.quantifier) + hash(self.variable)\n        h = 31 * h + hash(self.domain)\n        h = 31 * h + hash(self.condition)\n        return h\n"
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    def __str__(self):\n        return \" || \".join(str(chain) for chain in self.chains)\n\n    def __repr__(self):\n        return \"{}({})\".format(type(self).__name__, repr(self.chains))\n\n\n###############################################################################\n# Message Filters and Field Conditions\n###############################################################################\n\nclass HplMessageFilter(HplAstObject):\n    __slots__ = (\"conditions\", \"length_conditions\")\n\n    def __init__(self, conditions, len_conditions=None):\n        # conditions :: [HplFieldCondition]\n        self.conditions = conditions\n        if len_conditions is None:\n            self.length_conditions = []\n        else:\n            self.length_conditions = len_conditions\n\n    @property\n    def is_empty(self):\n        return not self.conditions and not self.length_conditions\n\n    def __eq__(self, other):\n        if not isinstance(other, HplMessageFilter):\n            return False\n        return (len(self.conditions) == len(other.conditions)\n                and all(c in other.conditions for c in self.conditions)\n                and len(self.length_conditions) == len(other.length_conditions)\n                and all(c in other.length_conditions\n                        for c in self.length_conditions))\n\n    def __hash__(self):\n        h = 1\n        for condition in self.conditions:\n            h = 31 * h + hash(condition)\n        for condition in self.length_conditions:\n            h = 31 * h + hash(condition)\n        return h\n\n    def __str__(self):\n        conditions = \", \".join(str(c)\n            for c in iterchain(self.conditions, self.length_conditions))\n        return \"{{{}}}\".format(conditions)\n\n    def __repr__(self):\n        return \"{}({}, len_conditions={})\".format(type(self).__name__,\n            repr(self.conditions), repr(self.length_conditions))\n\n\nclass HplFieldCondition(HplAstObject):\n    __slots__ = (\"field\", \"operator\", \"value\")\n\n    OP_EQ = \"=\"\n    OP_NEQ = \"!=\"\n    OP_LT = \"<\"\n    OP_LTE = \"<=\"\n    OP_GT = \">\"\n    OP_GTE = \">=\"\n    OP_IN = \"in\"\n    OP_NIN = \"not in\"\n\n    _NOT = {\n        OP_EQ: OP_NEQ,\n        OP_NEQ: OP_EQ,\n        OP_LT: OP_GTE,\n        OP_GT: OP_LTE,\n        OP_LTE: OP_GT,\n        OP_GTE: OP_LT,\n        OP_IN: OP_NIN,\n        OP_NIN: OP_IN\n    }\n\n    _INV = {\n        OP_EQ: OP_EQ,\n        OP_NEQ: OP_NEQ,\n        OP_LT: OP_GT,\n        OP_LTE: OP_GTE,\n        OP_GT: OP_LT,\n        OP_GTE: OP_LTE\n    }\n\n    def __init__(self, field_ref, op_token, hpl_value):\n        if not op_token in self._NOT:\n            raise ValueError(\"invalid operator token: \" + str(op_token))\n        self.field = field_ref # HplFieldReference\n        self.operator = op_token # string\n        self.value = hpl_value # HplValue\n\n    @property\n    def is_eq(self):\n        return self.operator == self.OP_EQ\n\n    @property\n    def is_neq(self):\n        return self.operator == self.OP_NEQ\n\n    @property\n    def is_lt(self):\n        return self.operator == self.OP_LT\n\n    @property\n    def is_lte(self):\n        return self.operator == self.OP_LTE\n\n    @property\n    def is_gt(self):\n        return self.operator == self.OP_GT\n\n    @property\n    def is_gte(self):\n        return self.operator == self.OP_GTE\n\n    @property\n    def is_in(self):\n        return self.operator == self.OP_IN\n\n    @property\n    def is_not_in(self):\n        return self.operator == self.OP_NIN\n\n    @property\n    def is_equality_test(self):\n        return self.operator == self.OP_EQ or self.operator == self.OP_NEQ\n\n    @property\n    def is_comparison_test(self):\n        return (self.operator == self.OP_LT or self.operator == self.OP_LTE\n            or self.operator == self.OP_GT or self.operator == self.OP_GTE)\n\n    @property\n    def is_inclusion_test(self):\n        return self.operator == self.OP_IN or self.operator == self.OP_NIN\n\n    @property\n    def requires_number(self):\n        return (self.operator == self.OP_LT or self.operator == self.OP_LTE\n                or self.operator == self.OP_GT or self.operator == self.OP_GTE\n                or (self.operator == self.OP_IN\n                    and isinstance(self.value, HplRange)))\n\n    @property\n    def is_invertible(self):\n        return self.operator in self._INV and self.value.is_reference\n\n    def negation(self):\n        return HplFieldCondition(\n            self.field, self._NOT[self.operator], self.value)\n\n    def inverted(self, alias):\n        if self.operator not in self._INV or not self.value.is_reference:\n            raise HplLogicError(\"impossible to invert: \" + str(self))\n        new_value = HplFieldReference(self.field.token, message=alias)\n        new_field = HplFieldReference(self.value.token, message=None)\n        new_op = self._INV[self.operator]\n        return HplFieldCondition(new_field, new_op, new_value)\n\n    # NOTE old, unused code that might be needed later\n    def __normalise_quantifiers(self):\n        #negate = False\n        #expr = self.field.clone()\n        #for field in expr.fields:\n        #    if field.index == NO_INDEX:\n        #        field.index = SOME_INDEX if negate else ALL_INDICES\n        #        negate = not negate\n        #    elif field.index == ALL_INDICES and negate:\n        #        field.index = SOME_INDEX\n        #    elif field.index == SOME_INDEX and negate:\n        #        field.index = ALL_INDICES\n        #op = self._NOT[self.operator] if negate else self.operator\n        #return HplMsgFieldCondition(expr, op, self.value)\n        pass\n\n    def __eq__(self, other):\n        if not isinstance(other, HplMsgFieldCondition):\n            return False\n        return (self.field == other.field\n                and self.operator == other.operator\n                and self.value == other.value)\n\n    def __hash__(self):\n        h = 31 * hash(self.field) + hash(self.operator)\n        return 31 * h + hash(self.value)\n\n    def __str__(self):\n        return \"{} {} {}\".format(self.field, self.operator, self.value)\n\n    def __repr__(self):\n        return \"{}({}, {}, {})\".format(type(self).__name__,\n            repr(self.field), repr(self.operator), repr(self.value))\n\n\n###############################################################################\n# Values and Field References\n###############################################################################\n\nclass HplValue(HplAstObject):\n    __slots__ = ()\n\n",
        "source_code_len": 6348,
        "target_code": "    def __str__(self):\n        a = str(self.operand1)\n        b = str(self.operand2)\n        if self.infix:\n            return \"({} {} {})\".format(a, self.operator, b)\n        else:\n            return \"{}({}, {})\".format(self.operator, a, b)\n\n    def __repr__(self):\n        return \"{}({}, {}, {})\".format(\n            type(self).__name__, repr(self.operator),\n            repr(self.operand1), repr(self.operand2))\n\n\nclass HplFunctionCall(HplExpression):\n    __slots__ = HplExpression.__slots__ + (\"function\", \"arguments\",)\n\n    # name: Input -> Output\n    _BUILTINS = {\n        \"abs\": (T_NUM, T_NUM),\n        \"bool\": (T_PRIM, T_BOOL),\n        \"int\": (T_PRIM, T_NUM),\n        \"float\": (T_PRIM, T_NUM),\n        \"str\": (T_PRIM, T_STR),\n        \"len\": (T_ARR, T_NUM),\n        \"max\": (T_ARR, T_NUM),\n        \"min\": (T_ARR, T_NUM),\n        \"sum\": (T_ARR, T_NUM),\n        \"prod\": (T_ARR, T_NUM),\n    }\n\n    def __init__(self, fun, args):\n        try:\n            tin, tout = self._BUILTINS[fun]\n        except KeyError:\n            raise HplTypeError(\"undefined function '{}'\".format(fun))\n        HplExpression.__init__(self, types=tout)\n        self.function = fun # string\n        self.arguments = args # [HplValue]\n        for arg in args:\n            self._type_check(arg, tin)\n\n    @property\n    def is_function_call(self):\n        return True\n\n    @property\n    def arity(self):\n        return len(self.arguments)\n\n    def children(self):\n        return self.arguments\n\n    def __eq__(self, other):\n        if not isinstance(other, HplFunctionCall):\n            return False\n        return (self.function == other.function\n                and self.arguments == other.arguments)\n\n    def __hash__(self):\n        return 31 * hash(self.function) + hash(self.arguments)\n\n    def __str__(self):\n        return \"{}({})\".format(self.function,\n            \", \".join(str(arg) for arg in self.arguments))\n\n    def __repr__(self):\n        return \"{}({}, {})\".format(\n            type(self).__name__, repr(self.function), repr(self.arguments))\n\n\n###############################################################################\n# Message Field Access\n###############################################################################\n\nclass HplFieldAccess(HplExpression):\n    __slots__ = HplExpression.__slots__ + (\"message\", \"field\", \"ros_type\")\n\n    def __init__(self, msg, field):\n        HplExpression.__init__(self, types=T_ROS)\n        self.message = msg # HplExpression\n        self.field = field # string\n        self.ros_type = None\n        self._type_check(msg, T_MSG)\n\n    @property\n    def is_accessor(self):\n        return True\n\n    @property\n    def is_field(self):\n        return True\n\n    @property\n    def is_indexed(self):\n        return False\n\n    def base_message(self):\n        obj = self\n        while obj.is_accessor:\n            obj = obj.message\n        assert obj.is_value\n        return obj\n\n    def children(self):\n        return (self.message,)\n\n    def __eq__(self, other):\n        if not isinstance(other, HplFieldAccess):\n            return False\n        return (self.message == other.message\n                and self.field == other.field)\n\n    def __hash__(self):\n        return 31 * hash(self.message) + hash(self.field)\n\n    def __str__(self):\n        msg = str(self.message)\n        if msg:\n            return \"{}.{}\".format(msg, self.field)\n        return str(self.field)\n\n    def __repr__(self):\n        return \"{}({}, {})\".format(\n            type(self).__name__, repr(self.message), repr(self.field))\n\n\nclass HplArrayAccess(HplExpression):\n    __slots__ = HplExpression.__slots__ + (\"array\", \"item\", \"ros_type\")\n\n    _MULTI_ARRAY = \"multi-dimensional array access: '{}[{}]'\"\n\n    def __init__(self, array, index):\n        if array.is_accessor and array.is_indexed:\n            raise HplTypeError(self._MULTI_ARRAY.format(array, index))\n        HplExpression.__init__(self, types=T_ITEM)\n        self.array = array # HplExpression\n        self.index = index # HplExpression\n        self.ros_type = None\n        self._type_check(array, T_ARR)\n        self._type_check(index, T_NUM)\n\n    @property\n    def is_accessor(self):\n        return True\n\n    @property\n    def is_field(self):\n        return False\n\n    @property\n    def is_indexed(self):\n        return True\n\n    @property\n    def message(self):\n        return self.array\n\n    def base_message(self):\n        obj = self\n        while obj.is_accessor:\n            obj = obj.message\n        assert obj.is_value\n        return obj\n\n    def children(self):\n        return (self.array, self.index)\n\n    def __eq__(self, other):\n        if not isinstance(other, HplArrayAccess):\n            return False\n        return (self.array == other.array\n                and self.index == other.index)\n\n    def __hash__(self):\n        return 31 * hash(self.array) + hash(self.index)\n\n    def __str__(self):\n        return \"{}[{}]\".format(self.array, self.index)\n\n    def __repr__(self):\n        return \"{}({}, {})\".format(\n            type(self).__name__, repr(self.array), repr(self.index))\n\n\n###############################################################################\n# Values\n###############################################################################\n\nclass HplValue(HplExpression):\n    __slots__ = HplExpression.__slots__\n\n    @property\n    def is_value(self):\n        return True\n\n",
        "target_code_len": 5359,
        "diff_format": "@@ -680,202 +1201,196 @@\n     def __str__(self):\n-        return \" || \".join(str(chain) for chain in self.chains)\n-\n-    def __repr__(self):\n-        return \"{}({})\".format(type(self).__name__, repr(self.chains))\n-\n-\n-###############################################################################\n-# Message Filters and Field Conditions\n-###############################################################################\n-\n-class HplMessageFilter(HplAstObject):\n-    __slots__ = (\"conditions\", \"length_conditions\")\n-\n-    def __init__(self, conditions, len_conditions=None):\n-        # conditions :: [HplFieldCondition]\n-        self.conditions = conditions\n-        if len_conditions is None:\n-            self.length_conditions = []\n+        a = str(self.operand1)\n+        b = str(self.operand2)\n+        if self.infix:\n+            return \"({} {} {})\".format(a, self.operator, b)\n         else:\n-            self.length_conditions = len_conditions\n-\n-    @property\n-    def is_empty(self):\n-        return not self.conditions and not self.length_conditions\n-\n-    def __eq__(self, other):\n-        if not isinstance(other, HplMessageFilter):\n+            return \"{}({}, {})\".format(self.operator, a, b)\n+\n+    def __repr__(self):\n+        return \"{}({}, {}, {})\".format(\n+            type(self).__name__, repr(self.operator),\n+            repr(self.operand1), repr(self.operand2))\n+\n+\n+class HplFunctionCall(HplExpression):\n+    __slots__ = HplExpression.__slots__ + (\"function\", \"arguments\",)\n+\n+    # name: Input -> Output\n+    _BUILTINS = {\n+        \"abs\": (T_NUM, T_NUM),\n+        \"bool\": (T_PRIM, T_BOOL),\n+        \"int\": (T_PRIM, T_NUM),\n+        \"float\": (T_PRIM, T_NUM),\n+        \"str\": (T_PRIM, T_STR),\n+        \"len\": (T_ARR, T_NUM),\n+        \"max\": (T_ARR, T_NUM),\n+        \"min\": (T_ARR, T_NUM),\n+        \"sum\": (T_ARR, T_NUM),\n+        \"prod\": (T_ARR, T_NUM),\n+    }\n+\n+    def __init__(self, fun, args):\n+        try:\n+            tin, tout = self._BUILTINS[fun]\n+        except KeyError:\n+            raise HplTypeError(\"undefined function '{}'\".format(fun))\n+        HplExpression.__init__(self, types=tout)\n+        self.function = fun # string\n+        self.arguments = args # [HplValue]\n+        for arg in args:\n+            self._type_check(arg, tin)\n+\n+    @property\n+    def is_function_call(self):\n+        return True\n+\n+    @property\n+    def arity(self):\n+        return len(self.arguments)\n+\n+    def children(self):\n+        return self.arguments\n+\n+    def __eq__(self, other):\n+        if not isinstance(other, HplFunctionCall):\n             return False\n-        return (len(self.conditions) == len(other.conditions)\n-                and all(c in other.conditions for c in self.conditions)\n-                and len(self.length_conditions) == len(other.length_conditions)\n-                and all(c in other.length_conditions\n-                        for c in self.length_conditions))\n-\n-    def __hash__(self):\n-        h = 1\n-        for condition in self.conditions:\n-            h = 31 * h + hash(condition)\n-        for condition in self.length_conditions:\n-            h = 31 * h + hash(condition)\n-        return h\n-\n-    def __str__(self):\n-        conditions = \", \".join(str(c)\n-            for c in iterchain(self.conditions, self.length_conditions))\n-        return \"{{{}}}\".format(conditions)\n-\n-    def __repr__(self):\n-        return \"{}({}, len_conditions={})\".format(type(self).__name__,\n-            repr(self.conditions), repr(self.length_conditions))\n-\n-\n-class HplFieldCondition(HplAstObject):\n-    __slots__ = (\"field\", \"operator\", \"value\")\n-\n-    OP_EQ = \"=\"\n-    OP_NEQ = \"!=\"\n-    OP_LT = \"<\"\n-    OP_LTE = \"<=\"\n-    OP_GT = \">\"\n-    OP_GTE = \">=\"\n-    OP_IN = \"in\"\n-    OP_NIN = \"not in\"\n-\n-    _NOT = {\n-        OP_EQ: OP_NEQ,\n-        OP_NEQ: OP_EQ,\n-        OP_LT: OP_GTE,\n-        OP_GT: OP_LTE,\n-        OP_LTE: OP_GT,\n-        OP_GTE: OP_LT,\n-        OP_IN: OP_NIN,\n-        OP_NIN: OP_IN\n-    }\n-\n-    _INV = {\n-        OP_EQ: OP_EQ,\n-        OP_NEQ: OP_NEQ,\n-        OP_LT: OP_GT,\n-        OP_LTE: OP_GTE,\n-        OP_GT: OP_LT,\n-        OP_GTE: OP_LTE\n-    }\n-\n-    def __init__(self, field_ref, op_token, hpl_value):\n-        if not op_token in self._NOT:\n-            raise ValueError(\"invalid operator token: \" + str(op_token))\n-        self.field = field_ref # HplFieldReference\n-        self.operator = op_token # string\n-        self.value = hpl_value # HplValue\n-\n-    @property\n-    def is_eq(self):\n-        return self.operator == self.OP_EQ\n-\n-    @property\n-    def is_neq(self):\n-        return self.operator == self.OP_NEQ\n-\n-    @property\n-    def is_lt(self):\n-        return self.operator == self.OP_LT\n-\n-    @property\n-    def is_lte(self):\n-        return self.operator == self.OP_LTE\n-\n-    @property\n-    def is_gt(self):\n-        return self.operator == self.OP_GT\n-\n-    @property\n-    def is_gte(self):\n-        return self.operator == self.OP_GTE\n-\n-    @property\n-    def is_in(self):\n-        return self.operator == self.OP_IN\n-\n-    @property\n-    def is_not_in(self):\n-        return self.operator == self.OP_NIN\n-\n-    @property\n-    def is_equality_test(self):\n-        return self.operator == self.OP_EQ or self.operator == self.OP_NEQ\n-\n-    @property\n-    def is_comparison_test(self):\n-        return (self.operator == self.OP_LT or self.operator == self.OP_LTE\n-            or self.operator == self.OP_GT or self.operator == self.OP_GTE)\n-\n-    @property\n-    def is_inclusion_test(self):\n-        return self.operator == self.OP_IN or self.operator == self.OP_NIN\n-\n-    @property\n-    def requires_number(self):\n-        return (self.operator == self.OP_LT or self.operator == self.OP_LTE\n-                or self.operator == self.OP_GT or self.operator == self.OP_GTE\n-                or (self.operator == self.OP_IN\n-                    and isinstance(self.value, HplRange)))\n-\n-    @property\n-    def is_invertible(self):\n-        return self.operator in self._INV and self.value.is_reference\n-\n-    def negation(self):\n-        return HplFieldCondition(\n-            self.field, self._NOT[self.operator], self.value)\n-\n-    def inverted(self, alias):\n-        if self.operator not in self._INV or not self.value.is_reference:\n-            raise HplLogicError(\"impossible to invert: \" + str(self))\n-        new_value = HplFieldReference(self.field.token, message=alias)\n-        new_field = HplFieldReference(self.value.token, message=None)\n-        new_op = self._INV[self.operator]\n-        return HplFieldCondition(new_field, new_op, new_value)\n-\n-    # NOTE old, unused code that might be needed later\n-    def __normalise_quantifiers(self):\n-        #negate = False\n-        #expr = self.field.clone()\n-        #for field in expr.fields:\n-        #    if field.index == NO_INDEX:\n-        #        field.index = SOME_INDEX if negate else ALL_INDICES\n-        #        negate = not negate\n-        #    elif field.index == ALL_INDICES and negate:\n-        #        field.index = SOME_INDEX\n-        #    elif field.index == SOME_INDEX and negate:\n-        #        field.index = ALL_INDICES\n-        #op = self._NOT[self.operator] if negate else self.operator\n-        #return HplMsgFieldCondition(expr, op, self.value)\n-        pass\n-\n-    def __eq__(self, other):\n-        if not isinstance(other, HplMsgFieldCondition):\n+        return (self.function == other.function\n+                and self.arguments == other.arguments)\n+\n+    def __hash__(self):\n+        return 31 * hash(self.function) + hash(self.arguments)\n+\n+    def __str__(self):\n+        return \"{}({})\".format(self.function,\n+            \", \".join(str(arg) for arg in self.arguments))\n+\n+    def __repr__(self):\n+        return \"{}({}, {})\".format(\n+            type(self).__name__, repr(self.function), repr(self.arguments))\n+\n+\n+###############################################################################\n+# Message Field Access\n+###############################################################################\n+\n+class HplFieldAccess(HplExpression):\n+    __slots__ = HplExpression.__slots__ + (\"message\", \"field\", \"ros_type\")\n+\n+    def __init__(self, msg, field):\n+        HplExpression.__init__(self, types=T_ROS)\n+        self.message = msg # HplExpression\n+        self.field = field # string\n+        self.ros_type = None\n+        self._type_check(msg, T_MSG)\n+\n+    @property\n+    def is_accessor(self):\n+        return True\n+\n+    @property\n+    def is_field(self):\n+        return True\n+\n+    @property\n+    def is_indexed(self):\n+        return False\n+\n+    def base_message(self):\n+        obj = self\n+        while obj.is_accessor:\n+            obj = obj.message\n+        assert obj.is_value\n+        return obj\n+\n+    def children(self):\n+        return (self.message,)\n+\n+    def __eq__(self, other):\n+        if not isinstance(other, HplFieldAccess):\n             return False\n-        return (self.field == other.field\n-                and self.operator == other.operator\n-                and self.value == other.value)\n-\n-    def __hash__(self):\n-        h = 31 * hash(self.field) + hash(self.operator)\n-        return 31 * h + hash(self.value)\n-\n-    def __str__(self):\n-        return \"{} {} {}\".format(self.field, self.operator, self.value)\n-\n-    def __repr__(self):\n-        return \"{}({}, {}, {})\".format(type(self).__name__,\n-            repr(self.field), repr(self.operator), repr(self.value))\n-\n-\n-###############################################################################\n-# Values and Field References\n-###############################################################################\n-\n-class HplValue(HplAstObject):\n-    __slots__ = ()\n+        return (self.message == other.message\n+                and self.field == other.field)\n+\n+    def __hash__(self):\n+        return 31 * hash(self.message) + hash(self.field)\n+\n+    def __str__(self):\n+        msg = str(self.message)\n+        if msg:\n+            return \"{}.{}\".format(msg, self.field)\n+        return str(self.field)\n+\n+    def __repr__(self):\n+        return \"{}({}, {})\".format(\n+            type(self).__name__, repr(self.message), repr(self.field))\n+\n+\n+class HplArrayAccess(HplExpression):\n+    __slots__ = HplExpression.__slots__ + (\"array\", \"item\", \"ros_type\")\n+\n+    _MULTI_ARRAY = \"multi-dimensional array access: '{}[{}]'\"\n+\n+    def __init__(self, array, index):\n+        if array.is_accessor and array.is_indexed:\n+            raise HplTypeError(self._MULTI_ARRAY.format(array, index))\n+        HplExpression.__init__(self, types=T_ITEM)\n+        self.array = array # HplExpression\n+        self.index = index # HplExpression\n+        self.ros_type = None\n+        self._type_check(array, T_ARR)\n+        self._type_check(index, T_NUM)\n+\n+    @property\n+    def is_accessor(self):\n+        return True\n+\n+    @property\n+    def is_field(self):\n+        return False\n+\n+    @property\n+    def is_indexed(self):\n+        return True\n+\n+    @property\n+    def message(self):\n+        return self.array\n+\n+    def base_message(self):\n+        obj = self\n+        while obj.is_accessor:\n+            obj = obj.message\n+        assert obj.is_value\n+        return obj\n+\n+    def children(self):\n+        return (self.array, self.index)\n+\n+    def __eq__(self, other):\n+        if not isinstance(other, HplArrayAccess):\n+            return False\n+        return (self.array == other.array\n+                and self.index == other.index)\n+\n+    def __hash__(self):\n+        return 31 * hash(self.array) + hash(self.index)\n+\n+    def __str__(self):\n+        return \"{}[{}]\".format(self.array, self.index)\n+\n+    def __repr__(self):\n+        return \"{}({}, {})\".format(\n+            type(self).__name__, repr(self.array), repr(self.index))\n+\n+\n+###############################################################################\n+# Values\n+###############################################################################\n+\n+class HplValue(HplExpression):\n+    __slots__ = HplExpression.__slots__\n+\n+    @property\n+    def is_value(self):\n+        return True\n \n",
        "source_code_with_indent": "    <DED>def __str__(self):\n        <IND>return \" || \".join(str(chain) for chain in self.chains)\n\n    <DED>def __repr__(self):\n        <IND>return \"{}({})\".format(type(self).__name__, repr(self.chains))\n\n\n###############################################################################\n# Message Filters and Field Conditions\n###############################################################################\n\n<DED><DED>class HplMessageFilter(HplAstObject):\n    <IND>__slots__ = (\"conditions\", \"length_conditions\")\n\n    def __init__(self, conditions, len_conditions=None):\n        # conditions :: [HplFieldCondition]\n        <IND>self.conditions = conditions\n        if len_conditions is None:\n            <IND>self.length_conditions = []\n        <DED>else:\n            <IND>self.length_conditions = len_conditions\n\n    <DED><DED>@property\n    def is_empty(self):\n        <IND>return not self.conditions and not self.length_conditions\n\n    <DED>def __eq__(self, other):\n        <IND>if not isinstance(other, HplMessageFilter):\n            <IND>return False\n        <DED>return (len(self.conditions) == len(other.conditions)\n                and all(c in other.conditions for c in self.conditions)\n                and len(self.length_conditions) == len(other.length_conditions)\n                and all(c in other.length_conditions\n                        for c in self.length_conditions))\n\n    <DED>def __hash__(self):\n        <IND>h = 1\n        for condition in self.conditions:\n            <IND>h = 31 * h + hash(condition)\n        <DED>for condition in self.length_conditions:\n            <IND>h = 31 * h + hash(condition)\n        <DED>return h\n\n    <DED>def __str__(self):\n        <IND>conditions = \", \".join(str(c)\n            for c in iterchain(self.conditions, self.length_conditions))\n        return \"{{{}}}\".format(conditions)\n\n    <DED>def __repr__(self):\n        <IND>return \"{}({}, len_conditions={})\".format(type(self).__name__,\n            repr(self.conditions), repr(self.length_conditions))\n\n\n<DED><DED>class HplFieldCondition(HplAstObject):\n    <IND>__slots__ = (\"field\", \"operator\", \"value\")\n\n    OP_EQ = \"=\"\n    OP_NEQ = \"!=\"\n    OP_LT = \"<\"\n    OP_LTE = \"<=\"\n    OP_GT = \">\"\n    OP_GTE = \">=\"\n    OP_IN = \"in\"\n    OP_NIN = \"not in\"\n\n    _NOT = {\n        OP_EQ: OP_NEQ,\n        OP_NEQ: OP_EQ,\n        OP_LT: OP_GTE,\n        OP_GT: OP_LTE,\n        OP_LTE: OP_GT,\n        OP_GTE: OP_LT,\n        OP_IN: OP_NIN,\n        OP_NIN: OP_IN\n    }\n\n    _INV = {\n        OP_EQ: OP_EQ,\n        OP_NEQ: OP_NEQ,\n        OP_LT: OP_GT,\n        OP_LTE: OP_GTE,\n        OP_GT: OP_LT,\n        OP_GTE: OP_LTE\n    }\n\n    def __init__(self, field_ref, op_token, hpl_value):\n        <IND>if not op_token in self._NOT:\n            <IND>raise ValueError(\"invalid operator token: \" + str(op_token))\n        <DED>self.field = field_ref # HplFieldReference\n        self.operator = op_token # string\n        self.value = hpl_value # HplValue\n\n    <DED>@property\n    def is_eq(self):\n        <IND>return self.operator == self.OP_EQ\n\n    <DED>@property\n    def is_neq(self):\n        <IND>return self.operator == self.OP_NEQ\n\n    <DED>@property\n    def is_lt(self):\n        <IND>return self.operator == self.OP_LT\n\n    <DED>@property\n    def is_lte(self):\n        <IND>return self.operator == self.OP_LTE\n\n    <DED>@property\n    def is_gt(self):\n        <IND>return self.operator == self.OP_GT\n\n    <DED>@property\n    def is_gte(self):\n        <IND>return self.operator == self.OP_GTE\n\n    <DED>@property\n    def is_in(self):\n        <IND>return self.operator == self.OP_IN\n\n    <DED>@property\n    def is_not_in(self):\n        <IND>return self.operator == self.OP_NIN\n\n    <DED>@property\n    def is_equality_test(self):\n        <IND>return self.operator == self.OP_EQ or self.operator == self.OP_NEQ\n\n    <DED>@property\n    def is_comparison_test(self):\n        <IND>return (self.operator == self.OP_LT or self.operator == self.OP_LTE\n            or self.operator == self.OP_GT or self.operator == self.OP_GTE)\n\n    <DED>@property\n    def is_inclusion_test(self):\n        <IND>return self.operator == self.OP_IN or self.operator == self.OP_NIN\n\n    <DED>@property\n    def requires_number(self):\n        <IND>return (self.operator == self.OP_LT or self.operator == self.OP_LTE\n                or self.operator == self.OP_GT or self.operator == self.OP_GTE\n                or (self.operator == self.OP_IN\n                    and isinstance(self.value, HplRange)))\n\n    <DED>@property\n    def is_invertible(self):\n        <IND>return self.operator in self._INV and self.value.is_reference\n\n    <DED>def negation(self):\n        <IND>return HplFieldCondition(\n            self.field, self._NOT[self.operator], self.value)\n\n    <DED>def inverted(self, alias):\n        <IND>if self.operator not in self._INV or not self.value.is_reference:\n            <IND>raise HplLogicError(\"impossible to invert: \" + str(self))\n        <DED>new_value = HplFieldReference(self.field.token, message=alias)\n        new_field = HplFieldReference(self.value.token, message=None)\n        new_op = self._INV[self.operator]\n        return HplFieldCondition(new_field, new_op, new_value)\n\n    # NOTE old, unused code that might be needed later\n    <DED>def __normalise_quantifiers(self):\n        #negate = False\n        #expr = self.field.clone()\n        #for field in expr.fields:\n        #    if field.index == NO_INDEX:\n        #        field.index = SOME_INDEX if negate else ALL_INDICES\n        #        negate = not negate\n        #    elif field.index == ALL_INDICES and negate:\n        #        field.index = SOME_INDEX\n        #    elif field.index == SOME_INDEX and negate:\n        #        field.index = ALL_INDICES\n        #op = self._NOT[self.operator] if negate else self.operator\n        #return HplMsgFieldCondition(expr, op, self.value)\n        <IND>pass\n\n    <DED>def __eq__(self, other):\n        <IND>if not isinstance(other, HplMsgFieldCondition):\n            <IND>return False\n        <DED>return (self.field == other.field\n                and self.operator == other.operator\n                and self.value == other.value)\n\n    <DED>def __hash__(self):\n        <IND>h = 31 * hash(self.field) + hash(self.operator)\n        return 31 * h + hash(self.value)\n\n    <DED>def __str__(self):\n        <IND>return \"{} {} {}\".format(self.field, self.operator, self.value)\n\n    <DED>def __repr__(self):\n        <IND>return \"{}({}, {}, {})\".format(type(self).__name__,\n            repr(self.field), repr(self.operator), repr(self.value))\n\n\n###############################################################################\n# Values and Field References\n###############################################################################\n\n<DED><DED>class HplValue(HplAstObject):\n    <IND>__slots__ = ()\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    <DED>def __str__(self):\n        <IND>a = str(self.operand1)\n        b = str(self.operand2)\n        if self.infix:\n            <IND>return \"({} {} {})\".format(a, self.operator, b)\n        <DED>else:\n            <IND>return \"{}({}, {})\".format(self.operator, a, b)\n\n    <DED><DED>def __repr__(self):\n        <IND>return \"{}({}, {}, {})\".format(\n            type(self).__name__, repr(self.operator),\n            repr(self.operand1), repr(self.operand2))\n\n\n<DED><DED>class HplFunctionCall(HplExpression):\n    <IND>__slots__ = HplExpression.__slots__ + (\"function\", \"arguments\",)\n\n    # name: Input -> Output\n    _BUILTINS = {\n        \"abs\": (T_NUM, T_NUM),\n        \"bool\": (T_PRIM, T_BOOL),\n        \"int\": (T_PRIM, T_NUM),\n        \"float\": (T_PRIM, T_NUM),\n        \"str\": (T_PRIM, T_STR),\n        \"len\": (T_ARR, T_NUM),\n        \"max\": (T_ARR, T_NUM),\n        \"min\": (T_ARR, T_NUM),\n        \"sum\": (T_ARR, T_NUM),\n        \"prod\": (T_ARR, T_NUM),\n    }\n\n    def __init__(self, fun, args):\n        <IND>try:\n            <IND>tin, tout = self._BUILTINS[fun]\n        <DED>except KeyError:\n            <IND>raise HplTypeError(\"undefined function '{}'\".format(fun))\n        <DED>HplExpression.__init__(self, types=tout)\n        self.function = fun # string\n        self.arguments = args # [HplValue]\n        for arg in args:\n            <IND>self._type_check(arg, tin)\n\n    <DED><DED>@property\n    def is_function_call(self):\n        <IND>return True\n\n    <DED>@property\n    def arity(self):\n        <IND>return len(self.arguments)\n\n    <DED>def children(self):\n        <IND>return self.arguments\n\n    <DED>def __eq__(self, other):\n        <IND>if not isinstance(other, HplFunctionCall):\n            <IND>return False\n        <DED>return (self.function == other.function\n                and self.arguments == other.arguments)\n\n    <DED>def __hash__(self):\n        <IND>return 31 * hash(self.function) + hash(self.arguments)\n\n    <DED>def __str__(self):\n        <IND>return \"{}({})\".format(self.function,\n            \", \".join(str(arg) for arg in self.arguments))\n\n    <DED>def __repr__(self):\n        <IND>return \"{}({}, {})\".format(\n            type(self).__name__, repr(self.function), repr(self.arguments))\n\n\n###############################################################################\n# Message Field Access\n###############################################################################\n\n<DED><DED>class HplFieldAccess(HplExpression):\n    <IND>__slots__ = HplExpression.__slots__ + (\"message\", \"field\", \"ros_type\")\n\n    def __init__(self, msg, field):\n        <IND>HplExpression.__init__(self, types=T_ROS)\n        self.message = msg # HplExpression\n        self.field = field # string\n        self.ros_type = None\n        self._type_check(msg, T_MSG)\n\n    <DED>@property\n    def is_accessor(self):\n        <IND>return True\n\n    <DED>@property\n    def is_field(self):\n        <IND>return True\n\n    <DED>@property\n    def is_indexed(self):\n        <IND>return False\n\n    <DED>def base_message(self):\n        <IND>obj = self\n        while obj.is_accessor:\n            <IND>obj = obj.message\n        <DED>assert obj.is_value\n        return obj\n\n    <DED>def children(self):\n        <IND>return (self.message,)\n\n    <DED>def __eq__(self, other):\n        <IND>if not isinstance(other, HplFieldAccess):\n            <IND>return False\n        <DED>return (self.message == other.message\n                and self.field == other.field)\n\n    <DED>def __hash__(self):\n        <IND>return 31 * hash(self.message) + hash(self.field)\n\n    <DED>def __str__(self):\n        <IND>msg = str(self.message)\n        if msg:\n            <IND>return \"{}.{}\".format(msg, self.field)\n        <DED>return str(self.field)\n\n    <DED>def __repr__(self):\n        <IND>return \"{}({}, {})\".format(\n            type(self).__name__, repr(self.message), repr(self.field))\n\n\n<DED><DED>class HplArrayAccess(HplExpression):\n    <IND>__slots__ = HplExpression.__slots__ + (\"array\", \"item\", \"ros_type\")\n\n    _MULTI_ARRAY = \"multi-dimensional array access: '{}[{}]'\"\n\n    def __init__(self, array, index):\n        <IND>if array.is_accessor and array.is_indexed:\n            <IND>raise HplTypeError(self._MULTI_ARRAY.format(array, index))\n        <DED>HplExpression.__init__(self, types=T_ITEM)\n        self.array = array # HplExpression\n        self.index = index # HplExpression\n        self.ros_type = None\n        self._type_check(array, T_ARR)\n        self._type_check(index, T_NUM)\n\n    <DED>@property\n    def is_accessor(self):\n        <IND>return True\n\n    <DED>@property\n    def is_field(self):\n        <IND>return False\n\n    <DED>@property\n    def is_indexed(self):\n        <IND>return True\n\n    <DED>@property\n    def message(self):\n        <IND>return self.array\n\n    <DED>def base_message(self):\n        <IND>obj = self\n        while obj.is_accessor:\n            <IND>obj = obj.message\n        <DED>assert obj.is_value\n        return obj\n\n    <DED>def children(self):\n        <IND>return (self.array, self.index)\n\n    <DED>def __eq__(self, other):\n        <IND>if not isinstance(other, HplArrayAccess):\n            <IND>return False\n        <DED>return (self.array == other.array\n                and self.index == other.index)\n\n    <DED>def __hash__(self):\n        <IND>return 31 * hash(self.array) + hash(self.index)\n\n    <DED>def __str__(self):\n        <IND>return \"{}[{}]\".format(self.array, self.index)\n\n    <DED>def __repr__(self):\n        <IND>return \"{}({}, {})\".format(\n            type(self).__name__, repr(self.array), repr(self.index))\n\n\n###############################################################################\n# Values\n###############################################################################\n\n<DED><DED>class HplValue(HplExpression):\n    <IND>__slots__ = HplExpression.__slots__\n\n    @property\n    def is_value(self):\n        <IND>return True\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "git-afsantos/haros",
    "commit": "c6130786daebc4d05f4aa19ff705af9fa59210db",
    "filename": "haros/hpl/hpl_ast.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/git-afsantos-haros/haros/hpl/hpl_ast.py",
    "file_hunks_size": 50,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "haros/hpl/hpl_ast.py:1010:4 Inconsistent override [15]: `__slots__` overrides attribute defined in `HplValue` inconsistently. Type `typing.Tuple[str, str, str, str]` is not a subtype of the overridden attribute `typing.Tuple[]`.",
    "message": " `__slots__` overrides attribute defined in `HplValue` inconsistently. Type `typing.Tuple[str, str, str, str]` is not a subtype of the overridden attribute `typing.Tuple[]`.",
    "rule_id": "Inconsistent override [15]",
    "warning_line_no": 1010,
    "warning_line": "    __slots__ = (\"token\", \"message\", \"ros_types\", \"_parts\")",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    def __repr__(self):\n        return \"{}({}, {}, {}, delay={}, duration={}, alias={})\".format(\n            type(self).__name__, self.event_type, repr(self.msg_filter),\n            self.topic, self.delay, self.duration, self.alias)\n\n\nclass HplEventChain(HplAstObject):\n    __slots__ = (\"events\", \"duration\")\n\n    def __init__(self, events, duration=INF):\n        if len(events) < 1:\n            raise ValueError(events)\n        self.events = events # [HplEvent]\n        self.duration = duration\n\n    @property\n    def root(self):\n        return self.events[0]\n\n    @property\n    def leaf(self):\n        return self.events[-1]\n\n    def prefix(self):\n        return self.events[:-1]\n\n    def suffix(self):\n        return self.events[1:]\n\n    def aliases(self):\n        return set(e.alias for e in self.events if e.alias is not None)\n\n    def external_references(self):\n        # assume sanity_check\n        aliases = set(e.alias for e in self.events if e.alias is not None)\n        refs = set()\n        for event in self.events:\n            for ref in event.external_references():\n                if ref not in aliases:\n                    refs.add(ref)\n        return refs\n\n    def sanity_check(self):\n        aliases = []\n        for ev in self.events:\n            if ev.alias is not None:\n                if ev.alias in aliases:\n                    raise HplSanityError(\"duplicate alias: \" + repr(ev.alias))\n            aliases.append(ev.alias)\n        for i in range(len(self.events)):\n            for ref in self.events[i].external_references():\n                for j in range(i + 1, len(aliases)):\n                    if ref == aliases[j]:\n                        raise HplSanityError(\n                            \"reference to a future event: \" + repr(ref))\n\n    def __eq__(self, other):\n        if not isinstance(other, HplEventChain):\n            return False\n        return (self.events == other.events\n                and self.duration == other.duration)\n\n    def __hash__(self):\n        h = hash(self.duration)\n        for event in self.events:\n            h = 31 * h + hash(event)\n        return h\n",
        "source_code_len": 2110,
        "target_code": "    def __repr__(self):\n        return \"{}({}, {}, {}, alias={})\".format(\n            type(self).__name__, repr(self.event_type), repr(self.predicate),\n            repr(self.topic), repr(self.alias))\n\n\n###############################################################################\n# Top-level Predicate\n###############################################################################\n\nclass HplPredicate(HplAstObject):\n    __slots__ = (\"condition\",)\n\n    _DIFF_TYPES = (\"multiple occurrences of '{}' with incompatible types: \"\n                   \"found ({}) and ({})\")\n    _NO_REFS = \"there are no references to any fields of this message\"\n\n    def __init__(self, expr):\n        if not expr.is_expression:\n            raise TypeError(\"not an expression: \" + str(expr))\n        if not expr.can_be_bool:\n            raise HplTypeError(\"not a boolean expression: \" + str(expr))\n        self.condition = expr\n        self._static_checks()\n\n    @property\n    def is_predicate(self):\n        return True\n\n    @property\n    def is_vacuous(self):\n        return False\n\n    @property\n    def phi(self):\n        return self.condition\n\n    def is_fully_typed(self):\n        return self.condition.is_fully_typed()\n\n    def children(self):\n        return (self.condition,)\n\n    def negate(self):\n        if self.condition.is_operator and self.condition.operator == \"not\":\n            return HplPredicate(self.condition.operand)\n        return HplPredicate(HplUnaryOperator(\"not\", self.condition))\n\n    def join(self, other):\n        if other.is_vacuous:\n            return self if other.is_true else other\n        expr = HplBinaryOperator(\"and\", self.condition, other.condition)\n        return HplPredicate(expr)\n\n    def refine_types(self, rostype, **kwargs):\n        # rostype: ROS Type Token\n        # kwargs: string (alias) -> ROS Type Token\n        stack = [self.condition]\n        while stack:\n            obj = stack.pop()\n            if obj.is_accessor:\n                self._refine_type(obj, rostype, **kwargs)\n            else:\n                stack.extend(reversed(obj.children()))\n\n    def _refine_type(self, accessor, rostype, **kwargs):\n        stack = [accessor]\n        expr = accessor.message\n        while expr.is_accessor:\n            stack.append(expr)\n            expr = expr.message\n        assert expr.is_value and (expr.is_this_msg or expr.is_variable)\n        if expr.is_this_msg:\n            t = rostype\n        else:\n            if expr.name not in kwargs:\n                raise HplSanityError(\n                    \"undefined message alias: '{}'\".format(expr.name))\n            t = kwargs[expr.name]\n        assert t.is_message\n        expr.ros_type = t\n        while stack:\n            expr = stack.pop()\n            if expr.is_field:\n                if not (t.is_message or expr.field in t.fields\n                        or expr.field in t.constants):\n                    raise HplTypeError.ros_field(t, expr.field, expr)\n                if expr.field in t.fields:\n                    t = t.fields[expr.field]\n                else:\n                    assert expr.field in t.constants, \\\n                        \"'{}' not in {} or {}\".format(\n                            expr.field, t.fields, t.constants)\n                    t = t.constants[expr.field].ros_type\n            else:\n                assert expr.is_indexed\n                if not t.is_array:\n                    raise HplTypeError.ros_array(t, expr)\n                i = expr.index\n                if (i.is_value and i.is_literal\n                        and not t.contains_index(i.value)):\n                    raise HplTypeError.ros_index(t, expr.index, expr)\n                t = t.type_token\n            if t.is_message:\n                accessor._type_check(expr, T_MSG)\n            elif t.is_array:\n                accessor._type_check(expr, T_ARR)\n            elif t.is_number:\n                accessor._type_check(expr, T_NUM)\n                # TODO check that values fit within types\n            elif t.is_bool:\n                accessor._type_check(expr, T_BOOL)\n            elif t.is_string:\n                accessor._type_check(expr, T_STR)\n            expr.ros_type = t\n\n    def _static_checks(self):\n        ref_table = {}\n        for obj in self.condition.iterate():\n            if obj.is_accessor or (obj.is_value and obj.is_variable):\n                key = str(obj)\n                refs = ref_table.get(key)\n                if refs is None:\n                    refs = []\n                    ref_table[key] = refs\n                refs.append(obj)\n        self._all_refs_same_type(ref_table)\n        self._some_field_refs(ref_table)\n\n    def _all_refs_same_type(self, table):\n        # All references to the same field/variable have the same type.\n        for key, refs in table.iteritems():\n            # must traverse twice, in case we start with the most generic\n            # and go down to the most specific\n            final_type = T_ANY\n            for ref in refs:\n                ref.cast(final_type)\n                final_type = ref.types\n            for ref in reversed(refs):\n                ref.cast(final_type)\n                final_type = ref.types\n\n    def _some_field_refs(self, table):\n        # There is, at least, one reference to a field (own).\n        #   [NYI] Stricter: one reference per atomic condition.\n        for refs in table.itervalues():\n            for ref in refs:\n                if not ref.is_accessor:\n                    break\n                if ref.is_indexed:\n                    break\n                if not ref.message.is_value:\n                    break\n                assert ref.message.is_reference\n                if not ref.message.is_this_msg:\n                    break\n                return # OK\n        raise HplSanityError(self._NO_REFS)\n\n    def __eq__(self, other):\n        if not isinstance(other, HplPredicate):\n            return False\n        return self.condition == other.condition\n\n    def __hash__(self):\n        return hash(self.condition)\n\n    def __str__(self):\n        return \"{{ {} }}\".format(self.condition)\n\n    def __repr__(self):\n        return \"{}({})\".format(type(self).__name__, repr(self.condition))\n\n\nclass HplVacuousTruth(HplAstObject):\n    __slots__ = ()\n\n    @property\n    def is_predicate(self):\n        return True\n\n    @property\n    def is_vacuous(self):\n        return True\n\n    @property\n    def is_true(self):\n        return True\n\n    def is_fully_typed(self):\n        return True\n\n    def negate(self):\n        return HplContradiction()\n\n    def join(self, other):\n        return other\n\n    def refine_types(self, rostype, **kwargs):\n        pass\n\n    def __eq__(self, other):\n        return isinstance(other, HplVacuousTruth)\n\n    def __hash__(self):\n        return 27644437\n\n    def __str__(self):\n        return \"{ True }\"\n\n    def __repr__(self):\n        return \"{}()\".format(type(self).__name__)\n\n\nclass HplContradiction(HplAstObject):\n    __slots__ = ()\n\n    @property\n    def is_predicate(self):\n        return True\n\n    @property\n    def is_vacuous(self):\n        return True\n\n    @property\n    def is_true(self):\n        return False\n\n    def is_fully_typed(self):\n        return True\n\n    def negate(self):\n        return HplVacuousTruth()\n\n    def join(self, other):\n        return self\n\n    def refine_types(self, rostype, **kwargs):\n        pass\n\n    def __eq__(self, other):\n        return isinstance(other, HplContradiction)\n\n    def __hash__(self):\n        return 65537\n\n    def __str__(self):\n        return \"{ False }\"\n\n    def __repr__(self):\n        return \"{}()\".format(type(self).__name__)\n\n\n###############################################################################\n# Type System\n###############################################################################\n\n# Bit Flags\n\n# These work as possible types for the expression.\n# An expression of unknown type would have \"any\" type (i.e., all flags on).\n# E.g., (T_NUM | T_BOOL) means the expression can be either a number or a bool.\n# Things like variables start with many possible types, and are refined as the\n# tree is built.\n\nT_BOOL = 0x1\nT_NUM = 0x2\nT_STR = 0x4\nT_ARR = 0x8\n\nT_RAN = 0x10\nT_SET = 0x20\nT_MSG = 0x40\n\nT_ANY = T_BOOL | T_NUM | T_STR | T_ARR | T_RAN | T_SET | T_MSG\nT_COMP = T_ARR | T_RAN | T_SET\nT_PRIM = T_BOOL | T_NUM | T_STR\nT_ROS = T_BOOL | T_NUM | T_STR | T_ARR | T_MSG\nT_ITEM = T_BOOL | T_NUM | T_STR | T_MSG\n\n_TYPE_NAMES = {\n    T_BOOL: \"boolean\",\n    T_NUM: \"number\",\n    T_STR: \"string\",\n    T_ARR: \"array\",\n    T_RAN: \"range\",\n    T_SET: \"set\",\n    T_MSG: \"ROS msg\",\n}\n\ndef type_name(t):\n    if t in _TYPE_NAMES:\n        return _TYPE_NAMES[t]\n    ns = []\n    for key, name in _TYPE_NAMES.items():\n        if (t & key) != 0:\n            ns.append(name)\n    return \" or \".join(ns)\n\n\n###############################################################################\n# Expressions\n###############################################################################\n\nclass HplExpression(HplAstObject):\n    __slots__ = (\"types\",)\n\n    def __init__(self, types=T_ANY):\n        self.types = types\n\n    @property\n    def is_expression(self):\n        return True\n\n    @property\n    def is_value(self):\n        return False\n\n    @property\n    def is_operator(self):\n        return False\n\n    @property\n    def is_function_call(self):\n        return False\n\n    @property\n    def is_quantifier(self):\n        return False\n\n    @property\n    def is_accessor(self):\n        return False\n\n    @property\n    def can_be_bool(self):\n        return bool(self.types & T_BOOL)\n\n    @property\n    def can_be_number(self):\n        return bool(self.types & T_NUM)\n\n    @property\n    def can_be_string(self):\n        return bool(self.types & T_STR)\n\n    @property\n    def can_be_array(self):\n        return bool(self.types & T_ARR)\n\n    @property\n    def can_be_set(self):\n        return bool(self.types & T_SET)\n\n    @property\n    def can_be_range(self):\n        return bool(self.types & T_RAN)\n\n    @property\n    def can_be_msg(self):\n        return bool(self.types & T_MSG)\n\n    def can_be(self, t):\n        return bool(self.types & t)\n\n    def is_fully_typed(self):\n        for obj in self.iterate():\n            t = obj.types\n            if (not t) or bool(t & (t - 1)): # not a power of 2\n                return False\n        return True\n\n    def cast(self, t):\n        r = self.types & t\n        if not r:\n            raise HplTypeError(\"expected ({}) but found ({}): {}\".format(\n                type_name(t), type_name(self.types), self))\n        self.types = r\n\n    def _type_check(self, x, t):\n        try:\n            x.cast(t)\n        except HplTypeError as e:\n            msg = \"Type error in expression '{}':\\n{}\".format(self, e)\n            raise HplTypeError(msg)\n\n    def add_type(self, t):\n        self.types = self.types | t\n\n    def rem_type(self, t):\n        self.types = self.types & ~t\n        if not self.types:\n            raise HplTypeError(\"no types left: \" + str(self))\n\n\n###############################################################################\n# Quantifiers\n###############################################################################\n\nclass HplQuantifier(HplExpression):\n    __slots__ = HplExpression.__slots__ + (\n        \"quantifier\", \"variable\", \"domain\", \"condition\")\n\n    _SET_REF = \"cannot reference quantified variable '{}' in the domain of:\\n{}\"\n    _MULTI_DEF = \"multiple definitions of variable '{}' in:\\n{}\"\n    _UNUSED = \"quantified variable '{}' is never used in:\\n{}\"\n\n    def __init__(self, qt, var, dom, p):\n        HplExpression.__init__(self, types=T_BOOL)\n        self.quantifier = qt # string\n        self.variable = var # string\n        self.domain = dom # HplExpression\n        self.condition = p # HplExpression\n        self._type_check(dom, T_COMP)\n        self._type_check(p, T_BOOL)\n        self._check_variables()\n\n    @property\n    def is_quantifier(self):\n        return True\n\n    @property\n    def is_universal(self):\n        return self.quantifier == \"forall\"\n\n    @property\n    def op(self):\n        return self.quantifier\n\n    @property\n    def x(self):\n        return self.variable\n\n    @property\n    def d(self):\n        return self.domain\n\n    @property\n    def p(self):\n        return self.condition\n\n    @property\n    def phi(self):\n        return self.condition\n\n    def children(self):\n        return (self.domain, self.condition)\n\n    def _check_variables(self):\n        types = self._check_domain_vars()\n        self._check_expression_vars(types)\n\n    def _check_domain_vars(self):\n        dom = self.domain\n        for obj in dom.iterate():\n            assert obj.is_expression\n            if obj.is_value and obj.is_variable:\n                assert not obj.is_defined\n                v = obj.name\n                if self.variable == v:\n                    raise HplSanityError(self._SET_REF.format(v, self))\n        if dom.is_value:\n            if dom.is_set or dom.is_range:\n                return dom.subtypes\n        return T_PRIM\n\n    def _check_expression_vars(self, t):\n        uid = id(self)\n        used = 0\n        for obj in self.condition.iterate():\n            assert obj.is_expression\n            if obj.is_value and obj.is_variable:\n                v = obj.name\n                if self.variable == v:\n                    if obj.is_defined:\n                        assert obj.defined_at != uid\n                        raise HplSanityError(self._MULTI_DEF.format(v, self))\n                    obj.defined_at = uid\n                    self._type_check(obj, t)\n                    used += 1\n        if not used:\n            raise HplSanityError(self._UNUSED.format(self.variable, self))\n\n    def __eq__(self, other):\n        if not isinstance(other, HplQuantifier):\n            return False\n        return (self.quantifier == other.quantifier\n                and self.variable == other.variable\n                and self.domain == other.domain\n                and self.condition == other.condition)\n\n    def __hash__(self):\n        h = 31 * hash(self.quantifier) + hash(self.variable)\n        h = 31 * h + hash(self.domain)\n        h = 31 * h + hash(self.condition)\n        return h\n",
        "target_code_len": 14123,
        "diff_format": "@@ -509,67 +559,497 @@\n     def __repr__(self):\n-        return \"{}({}, {}, {}, delay={}, duration={}, alias={})\".format(\n-            type(self).__name__, self.event_type, repr(self.msg_filter),\n-            self.topic, self.delay, self.duration, self.alias)\n-\n-\n-class HplEventChain(HplAstObject):\n-    __slots__ = (\"events\", \"duration\")\n-\n-    def __init__(self, events, duration=INF):\n-        if len(events) < 1:\n-            raise ValueError(events)\n-        self.events = events # [HplEvent]\n-        self.duration = duration\n-\n-    @property\n-    def root(self):\n-        return self.events[0]\n-\n-    @property\n-    def leaf(self):\n-        return self.events[-1]\n-\n-    def prefix(self):\n-        return self.events[:-1]\n-\n-    def suffix(self):\n-        return self.events[1:]\n-\n-    def aliases(self):\n-        return set(e.alias for e in self.events if e.alias is not None)\n-\n-    def external_references(self):\n-        # assume sanity_check\n-        aliases = set(e.alias for e in self.events if e.alias is not None)\n-        refs = set()\n-        for event in self.events:\n-            for ref in event.external_references():\n-                if ref not in aliases:\n-                    refs.add(ref)\n-        return refs\n-\n-    def sanity_check(self):\n-        aliases = []\n-        for ev in self.events:\n-            if ev.alias is not None:\n-                if ev.alias in aliases:\n-                    raise HplSanityError(\"duplicate alias: \" + repr(ev.alias))\n-            aliases.append(ev.alias)\n-        for i in range(len(self.events)):\n-            for ref in self.events[i].external_references():\n-                for j in range(i + 1, len(aliases)):\n-                    if ref == aliases[j]:\n-                        raise HplSanityError(\n-                            \"reference to a future event: \" + repr(ref))\n-\n-    def __eq__(self, other):\n-        if not isinstance(other, HplEventChain):\n+        return \"{}({}, {}, {}, alias={})\".format(\n+            type(self).__name__, repr(self.event_type), repr(self.predicate),\n+            repr(self.topic), repr(self.alias))\n+\n+\n+###############################################################################\n+# Top-level Predicate\n+###############################################################################\n+\n+class HplPredicate(HplAstObject):\n+    __slots__ = (\"condition\",)\n+\n+    _DIFF_TYPES = (\"multiple occurrences of '{}' with incompatible types: \"\n+                   \"found ({}) and ({})\")\n+    _NO_REFS = \"there are no references to any fields of this message\"\n+\n+    def __init__(self, expr):\n+        if not expr.is_expression:\n+            raise TypeError(\"not an expression: \" + str(expr))\n+        if not expr.can_be_bool:\n+            raise HplTypeError(\"not a boolean expression: \" + str(expr))\n+        self.condition = expr\n+        self._static_checks()\n+\n+    @property\n+    def is_predicate(self):\n+        return True\n+\n+    @property\n+    def is_vacuous(self):\n+        return False\n+\n+    @property\n+    def phi(self):\n+        return self.condition\n+\n+    def is_fully_typed(self):\n+        return self.condition.is_fully_typed()\n+\n+    def children(self):\n+        return (self.condition,)\n+\n+    def negate(self):\n+        if self.condition.is_operator and self.condition.operator == \"not\":\n+            return HplPredicate(self.condition.operand)\n+        return HplPredicate(HplUnaryOperator(\"not\", self.condition))\n+\n+    def join(self, other):\n+        if other.is_vacuous:\n+            return self if other.is_true else other\n+        expr = HplBinaryOperator(\"and\", self.condition, other.condition)\n+        return HplPredicate(expr)\n+\n+    def refine_types(self, rostype, **kwargs):\n+        # rostype: ROS Type Token\n+        # kwargs: string (alias) -> ROS Type Token\n+        stack = [self.condition]\n+        while stack:\n+            obj = stack.pop()\n+            if obj.is_accessor:\n+                self._refine_type(obj, rostype, **kwargs)\n+            else:\n+                stack.extend(reversed(obj.children()))\n+\n+    def _refine_type(self, accessor, rostype, **kwargs):\n+        stack = [accessor]\n+        expr = accessor.message\n+        while expr.is_accessor:\n+            stack.append(expr)\n+            expr = expr.message\n+        assert expr.is_value and (expr.is_this_msg or expr.is_variable)\n+        if expr.is_this_msg:\n+            t = rostype\n+        else:\n+            if expr.name not in kwargs:\n+                raise HplSanityError(\n+                    \"undefined message alias: '{}'\".format(expr.name))\n+            t = kwargs[expr.name]\n+        assert t.is_message\n+        expr.ros_type = t\n+        while stack:\n+            expr = stack.pop()\n+            if expr.is_field:\n+                if not (t.is_message or expr.field in t.fields\n+                        or expr.field in t.constants):\n+                    raise HplTypeError.ros_field(t, expr.field, expr)\n+                if expr.field in t.fields:\n+                    t = t.fields[expr.field]\n+                else:\n+                    assert expr.field in t.constants, \\\n+                        \"'{}' not in {} or {}\".format(\n+                            expr.field, t.fields, t.constants)\n+                    t = t.constants[expr.field].ros_type\n+            else:\n+                assert expr.is_indexed\n+                if not t.is_array:\n+                    raise HplTypeError.ros_array(t, expr)\n+                i = expr.index\n+                if (i.is_value and i.is_literal\n+                        and not t.contains_index(i.value)):\n+                    raise HplTypeError.ros_index(t, expr.index, expr)\n+                t = t.type_token\n+            if t.is_message:\n+                accessor._type_check(expr, T_MSG)\n+            elif t.is_array:\n+                accessor._type_check(expr, T_ARR)\n+            elif t.is_number:\n+                accessor._type_check(expr, T_NUM)\n+                # TODO check that values fit within types\n+            elif t.is_bool:\n+                accessor._type_check(expr, T_BOOL)\n+            elif t.is_string:\n+                accessor._type_check(expr, T_STR)\n+            expr.ros_type = t\n+\n+    def _static_checks(self):\n+        ref_table = {}\n+        for obj in self.condition.iterate():\n+            if obj.is_accessor or (obj.is_value and obj.is_variable):\n+                key = str(obj)\n+                refs = ref_table.get(key)\n+                if refs is None:\n+                    refs = []\n+                    ref_table[key] = refs\n+                refs.append(obj)\n+        self._all_refs_same_type(ref_table)\n+        self._some_field_refs(ref_table)\n+\n+    def _all_refs_same_type(self, table):\n+        # All references to the same field/variable have the same type.\n+        for key, refs in table.iteritems():\n+            # must traverse twice, in case we start with the most generic\n+            # and go down to the most specific\n+            final_type = T_ANY\n+            for ref in refs:\n+                ref.cast(final_type)\n+                final_type = ref.types\n+            for ref in reversed(refs):\n+                ref.cast(final_type)\n+                final_type = ref.types\n+\n+    def _some_field_refs(self, table):\n+        # There is, at least, one reference to a field (own).\n+        #   [NYI] Stricter: one reference per atomic condition.\n+        for refs in table.itervalues():\n+            for ref in refs:\n+                if not ref.is_accessor:\n+                    break\n+                if ref.is_indexed:\n+                    break\n+                if not ref.message.is_value:\n+                    break\n+                assert ref.message.is_reference\n+                if not ref.message.is_this_msg:\n+                    break\n+                return # OK\n+        raise HplSanityError(self._NO_REFS)\n+\n+    def __eq__(self, other):\n+        if not isinstance(other, HplPredicate):\n             return False\n-        return (self.events == other.events\n-                and self.duration == other.duration)\n-\n-    def __hash__(self):\n-        h = hash(self.duration)\n-        for event in self.events:\n-            h = 31 * h + hash(event)\n+        return self.condition == other.condition\n+\n+    def __hash__(self):\n+        return hash(self.condition)\n+\n+    def __str__(self):\n+        return \"{{ {} }}\".format(self.condition)\n+\n+    def __repr__(self):\n+        return \"{}({})\".format(type(self).__name__, repr(self.condition))\n+\n+\n+class HplVacuousTruth(HplAstObject):\n+    __slots__ = ()\n+\n+    @property\n+    def is_predicate(self):\n+        return True\n+\n+    @property\n+    def is_vacuous(self):\n+        return True\n+\n+    @property\n+    def is_true(self):\n+        return True\n+\n+    def is_fully_typed(self):\n+        return True\n+\n+    def negate(self):\n+        return HplContradiction()\n+\n+    def join(self, other):\n+        return other\n+\n+    def refine_types(self, rostype, **kwargs):\n+        pass\n+\n+    def __eq__(self, other):\n+        return isinstance(other, HplVacuousTruth)\n+\n+    def __hash__(self):\n+        return 27644437\n+\n+    def __str__(self):\n+        return \"{ True }\"\n+\n+    def __repr__(self):\n+        return \"{}()\".format(type(self).__name__)\n+\n+\n+class HplContradiction(HplAstObject):\n+    __slots__ = ()\n+\n+    @property\n+    def is_predicate(self):\n+        return True\n+\n+    @property\n+    def is_vacuous(self):\n+        return True\n+\n+    @property\n+    def is_true(self):\n+        return False\n+\n+    def is_fully_typed(self):\n+        return True\n+\n+    def negate(self):\n+        return HplVacuousTruth()\n+\n+    def join(self, other):\n+        return self\n+\n+    def refine_types(self, rostype, **kwargs):\n+        pass\n+\n+    def __eq__(self, other):\n+        return isinstance(other, HplContradiction)\n+\n+    def __hash__(self):\n+        return 65537\n+\n+    def __str__(self):\n+        return \"{ False }\"\n+\n+    def __repr__(self):\n+        return \"{}()\".format(type(self).__name__)\n+\n+\n+###############################################################################\n+# Type System\n+###############################################################################\n+\n+# Bit Flags\n+\n+# These work as possible types for the expression.\n+# An expression of unknown type would have \"any\" type (i.e., all flags on).\n+# E.g., (T_NUM | T_BOOL) means the expression can be either a number or a bool.\n+# Things like variables start with many possible types, and are refined as the\n+# tree is built.\n+\n+T_BOOL = 0x1\n+T_NUM = 0x2\n+T_STR = 0x4\n+T_ARR = 0x8\n+\n+T_RAN = 0x10\n+T_SET = 0x20\n+T_MSG = 0x40\n+\n+T_ANY = T_BOOL | T_NUM | T_STR | T_ARR | T_RAN | T_SET | T_MSG\n+T_COMP = T_ARR | T_RAN | T_SET\n+T_PRIM = T_BOOL | T_NUM | T_STR\n+T_ROS = T_BOOL | T_NUM | T_STR | T_ARR | T_MSG\n+T_ITEM = T_BOOL | T_NUM | T_STR | T_MSG\n+\n+_TYPE_NAMES = {\n+    T_BOOL: \"boolean\",\n+    T_NUM: \"number\",\n+    T_STR: \"string\",\n+    T_ARR: \"array\",\n+    T_RAN: \"range\",\n+    T_SET: \"set\",\n+    T_MSG: \"ROS msg\",\n+}\n+\n+def type_name(t):\n+    if t in _TYPE_NAMES:\n+        return _TYPE_NAMES[t]\n+    ns = []\n+    for key, name in _TYPE_NAMES.items():\n+        if (t & key) != 0:\n+            ns.append(name)\n+    return \" or \".join(ns)\n+\n+\n+###############################################################################\n+# Expressions\n+###############################################################################\n+\n+class HplExpression(HplAstObject):\n+    __slots__ = (\"types\",)\n+\n+    def __init__(self, types=T_ANY):\n+        self.types = types\n+\n+    @property\n+    def is_expression(self):\n+        return True\n+\n+    @property\n+    def is_value(self):\n+        return False\n+\n+    @property\n+    def is_operator(self):\n+        return False\n+\n+    @property\n+    def is_function_call(self):\n+        return False\n+\n+    @property\n+    def is_quantifier(self):\n+        return False\n+\n+    @property\n+    def is_accessor(self):\n+        return False\n+\n+    @property\n+    def can_be_bool(self):\n+        return bool(self.types & T_BOOL)\n+\n+    @property\n+    def can_be_number(self):\n+        return bool(self.types & T_NUM)\n+\n+    @property\n+    def can_be_string(self):\n+        return bool(self.types & T_STR)\n+\n+    @property\n+    def can_be_array(self):\n+        return bool(self.types & T_ARR)\n+\n+    @property\n+    def can_be_set(self):\n+        return bool(self.types & T_SET)\n+\n+    @property\n+    def can_be_range(self):\n+        return bool(self.types & T_RAN)\n+\n+    @property\n+    def can_be_msg(self):\n+        return bool(self.types & T_MSG)\n+\n+    def can_be(self, t):\n+        return bool(self.types & t)\n+\n+    def is_fully_typed(self):\n+        for obj in self.iterate():\n+            t = obj.types\n+            if (not t) or bool(t & (t - 1)): # not a power of 2\n+                return False\n+        return True\n+\n+    def cast(self, t):\n+        r = self.types & t\n+        if not r:\n+            raise HplTypeError(\"expected ({}) but found ({}): {}\".format(\n+                type_name(t), type_name(self.types), self))\n+        self.types = r\n+\n+    def _type_check(self, x, t):\n+        try:\n+            x.cast(t)\n+        except HplTypeError as e:\n+            msg = \"Type error in expression '{}':\\n{}\".format(self, e)\n+            raise HplTypeError(msg)\n+\n+    def add_type(self, t):\n+        self.types = self.types | t\n+\n+    def rem_type(self, t):\n+        self.types = self.types & ~t\n+        if not self.types:\n+            raise HplTypeError(\"no types left: \" + str(self))\n+\n+\n+###############################################################################\n+# Quantifiers\n+###############################################################################\n+\n+class HplQuantifier(HplExpression):\n+    __slots__ = HplExpression.__slots__ + (\n+        \"quantifier\", \"variable\", \"domain\", \"condition\")\n+\n+    _SET_REF = \"cannot reference quantified variable '{}' in the domain of:\\n{}\"\n+    _MULTI_DEF = \"multiple definitions of variable '{}' in:\\n{}\"\n+    _UNUSED = \"quantified variable '{}' is never used in:\\n{}\"\n+\n+    def __init__(self, qt, var, dom, p):\n+        HplExpression.__init__(self, types=T_BOOL)\n+        self.quantifier = qt # string\n+        self.variable = var # string\n+        self.domain = dom # HplExpression\n+        self.condition = p # HplExpression\n+        self._type_check(dom, T_COMP)\n+        self._type_check(p, T_BOOL)\n+        self._check_variables()\n+\n+    @property\n+    def is_quantifier(self):\n+        return True\n+\n+    @property\n+    def is_universal(self):\n+        return self.quantifier == \"forall\"\n+\n+    @property\n+    def op(self):\n+        return self.quantifier\n+\n+    @property\n+    def x(self):\n+        return self.variable\n+\n+    @property\n+    def d(self):\n+        return self.domain\n+\n+    @property\n+    def p(self):\n+        return self.condition\n+\n+    @property\n+    def phi(self):\n+        return self.condition\n+\n+    def children(self):\n+        return (self.domain, self.condition)\n+\n+    def _check_variables(self):\n+        types = self._check_domain_vars()\n+        self._check_expression_vars(types)\n+\n+    def _check_domain_vars(self):\n+        dom = self.domain\n+        for obj in dom.iterate():\n+            assert obj.is_expression\n+            if obj.is_value and obj.is_variable:\n+                assert not obj.is_defined\n+                v = obj.name\n+                if self.variable == v:\n+                    raise HplSanityError(self._SET_REF.format(v, self))\n+        if dom.is_value:\n+            if dom.is_set or dom.is_range:\n+                return dom.subtypes\n+        return T_PRIM\n+\n+    def _check_expression_vars(self, t):\n+        uid = id(self)\n+        used = 0\n+        for obj in self.condition.iterate():\n+            assert obj.is_expression\n+            if obj.is_value and obj.is_variable:\n+                v = obj.name\n+                if self.variable == v:\n+                    if obj.is_defined:\n+                        assert obj.defined_at != uid\n+                        raise HplSanityError(self._MULTI_DEF.format(v, self))\n+                    obj.defined_at = uid\n+                    self._type_check(obj, t)\n+                    used += 1\n+        if not used:\n+            raise HplSanityError(self._UNUSED.format(self.variable, self))\n+\n+    def __eq__(self, other):\n+        if not isinstance(other, HplQuantifier):\n+            return False\n+        return (self.quantifier == other.quantifier\n+                and self.variable == other.variable\n+                and self.domain == other.domain\n+                and self.condition == other.condition)\n+\n+    def __hash__(self):\n+        h = 31 * hash(self.quantifier) + hash(self.variable)\n+        h = 31 * h + hash(self.domain)\n+        h = 31 * h + hash(self.condition)\n         return h\n",
        "source_code_with_indent": "    <DED><DED>def __repr__(self):\n        <IND>return \"{}({}, {}, {}, delay={}, duration={}, alias={})\".format(\n            type(self).__name__, self.event_type, repr(self.msg_filter),\n            self.topic, self.delay, self.duration, self.alias)\n\n\n<DED><DED>class HplEventChain(HplAstObject):\n    <IND>__slots__ = (\"events\", \"duration\")\n\n    def __init__(self, events, duration=INF):\n        <IND>if len(events) < 1:\n            <IND>raise ValueError(events)\n        <DED>self.events = events # [HplEvent]\n        self.duration = duration\n\n    <DED>@property\n    def root(self):\n        <IND>return self.events[0]\n\n    <DED>@property\n    def leaf(self):\n        <IND>return self.events[-1]\n\n    <DED>def prefix(self):\n        <IND>return self.events[:-1]\n\n    <DED>def suffix(self):\n        <IND>return self.events[1:]\n\n    <DED>def aliases(self):\n        <IND>return set(e.alias for e in self.events if e.alias is not None)\n\n    <DED>def external_references(self):\n        # assume sanity_check\n        <IND>aliases = set(e.alias for e in self.events if e.alias is not None)\n        refs = set()\n        for event in self.events:\n            <IND>for ref in event.external_references():\n                <IND>if ref not in aliases:\n                    <IND>refs.add(ref)\n        <DED><DED><DED>return refs\n\n    <DED>def sanity_check(self):\n        <IND>aliases = []\n        for ev in self.events:\n            <IND>if ev.alias is not None:\n                <IND>if ev.alias in aliases:\n                    <IND>raise HplSanityError(\"duplicate alias: \" + repr(ev.alias))\n            <DED><DED>aliases.append(ev.alias)\n        <DED>for i in range(len(self.events)):\n            <IND>for ref in self.events[i].external_references():\n                <IND>for j in range(i + 1, len(aliases)):\n                    <IND>if ref == aliases[j]:\n                        <IND>raise HplSanityError(\n                            \"reference to a future event: \" + repr(ref))\n\n    <DED><DED><DED><DED><DED>def __eq__(self, other):\n        <IND>if not isinstance(other, HplEventChain):\n            <IND>return False\n        <DED>return (self.events == other.events\n                and self.duration == other.duration)\n\n    <DED>def __hash__(self):\n        <IND>h = hash(self.duration)\n        for event in self.events:\n            <IND>h = 31 * h + hash(event)\n        <DED>return h\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent_exact_match": false,
        "target_code_with_indent": "    <DED><DED>def __repr__(self):\n        <IND>return \"{}({}, {}, {}, alias={})\".format(\n            type(self).__name__, repr(self.event_type), repr(self.predicate),\n            repr(self.topic), repr(self.alias))\n\n\n###############################################################################\n# Top-level Predicate\n###############################################################################\n\n<DED><DED>class HplPredicate(HplAstObject):\n    <IND>__slots__ = (\"condition\",)\n\n    _DIFF_TYPES = (\"multiple occurrences of '{}' with incompatible types: \"\n                   \"found ({}) and ({})\")\n    _NO_REFS = \"there are no references to any fields of this message\"\n\n    def __init__(self, expr):\n        <IND>if not expr.is_expression:\n            <IND>raise TypeError(\"not an expression: \" + str(expr))\n        <DED>if not expr.can_be_bool:\n            <IND>raise HplTypeError(\"not a boolean expression: \" + str(expr))\n        <DED>self.condition = expr\n        self._static_checks()\n\n    <DED>@property\n    def is_predicate(self):\n        <IND>return True\n\n    <DED>@property\n    def is_vacuous(self):\n        <IND>return False\n\n    <DED>@property\n    def phi(self):\n        <IND>return self.condition\n\n    <DED>def is_fully_typed(self):\n        <IND>return self.condition.is_fully_typed()\n\n    <DED>def children(self):\n        <IND>return (self.condition,)\n\n    <DED>def negate(self):\n        <IND>if self.condition.is_operator and self.condition.operator == \"not\":\n            <IND>return HplPredicate(self.condition.operand)\n        <DED>return HplPredicate(HplUnaryOperator(\"not\", self.condition))\n\n    <DED>def join(self, other):\n        <IND>if other.is_vacuous:\n            <IND>return self if other.is_true else other\n        <DED>expr = HplBinaryOperator(\"and\", self.condition, other.condition)\n        return HplPredicate(expr)\n\n    <DED>def refine_types(self, rostype, **kwargs):\n        # rostype: ROS Type Token\n        # kwargs: string (alias) -> ROS Type Token\n        <IND>stack = [self.condition]\n        while stack:\n            <IND>obj = stack.pop()\n            if obj.is_accessor:\n                <IND>self._refine_type(obj, rostype, **kwargs)\n            <DED>else:\n                <IND>stack.extend(reversed(obj.children()))\n\n    <DED><DED><DED>def _refine_type(self, accessor, rostype, **kwargs):\n        <IND>stack = [accessor]\n        expr = accessor.message\n        while expr.is_accessor:\n            <IND>stack.append(expr)\n            expr = expr.message\n        <DED>assert expr.is_value and (expr.is_this_msg or expr.is_variable)\n        if expr.is_this_msg:\n            <IND>t = rostype\n        <DED>else:\n            <IND>if expr.name not in kwargs:\n                <IND>raise HplSanityError(\n                    \"undefined message alias: '{}'\".format(expr.name))\n            <DED>t = kwargs[expr.name]\n        <DED>assert t.is_message\n        expr.ros_type = t\n        while stack:\n            <IND>expr = stack.pop()\n            if expr.is_field:\n                <IND>if not (t.is_message or expr.field in t.fields\n                        or expr.field in t.constants):\n                    <IND>raise HplTypeError.ros_field(t, expr.field, expr)\n                <DED>if expr.field in t.fields:\n                    <IND>t = t.fields[expr.field]\n                <DED>else:\n                    <IND>assert expr.field in t.constants,                        \"'{}' not in {} or {}\".format(\n                            expr.field, t.fields, t.constants)\n                    t = t.constants[expr.field].ros_type\n            <DED><DED>else:\n                <IND>assert expr.is_indexed\n                if not t.is_array:\n                    <IND>raise HplTypeError.ros_array(t, expr)\n                <DED>i = expr.index\n                if (i.is_value and i.is_literal\n                        and not t.contains_index(i.value)):\n                    <IND>raise HplTypeError.ros_index(t, expr.index, expr)\n                <DED>t = t.type_token\n            <DED>if t.is_message:\n                <IND>accessor._type_check(expr, T_MSG)\n            <DED>elif t.is_array:\n                <IND>accessor._type_check(expr, T_ARR)\n            <DED>elif t.is_number:\n                <IND>accessor._type_check(expr, T_NUM)\n                # TODO check that values fit within types\n            <DED>elif t.is_bool:\n                <IND>accessor._type_check(expr, T_BOOL)\n            <DED>elif t.is_string:\n                <IND>accessor._type_check(expr, T_STR)\n            <DED>expr.ros_type = t\n\n    <DED><DED>def _static_checks(self):\n        <IND>ref_table = {}\n        for obj in self.condition.iterate():\n            <IND>if obj.is_accessor or (obj.is_value and obj.is_variable):\n                <IND>key = str(obj)\n                refs = ref_table.get(key)\n                if refs is None:\n                    <IND>refs = []\n                    ref_table[key] = refs\n                <DED>refs.append(obj)\n        <DED><DED>self._all_refs_same_type(ref_table)\n        self._some_field_refs(ref_table)\n\n    <DED>def _all_refs_same_type(self, table):\n        # All references to the same field/variable have the same type.\n        <IND>for key, refs in table.iteritems():\n            # must traverse twice, in case we start with the most generic\n            # and go down to the most specific\n            <IND>final_type = T_ANY\n            for ref in refs:\n                <IND>ref.cast(final_type)\n                final_type = ref.types\n            <DED>for ref in reversed(refs):\n                <IND>ref.cast(final_type)\n                final_type = ref.types\n\n    <DED><DED><DED>def _some_field_refs(self, table):\n        # There is, at least, one reference to a field (own).\n        #   [NYI] Stricter: one reference per atomic condition.\n        <IND>for refs in table.itervalues():\n            <IND>for ref in refs:\n                <IND>if not ref.is_accessor:\n                    <IND>break\n                <DED>if ref.is_indexed:\n                    <IND>break\n                <DED>if not ref.message.is_value:\n                    <IND>break\n                <DED>assert ref.message.is_reference\n                if not ref.message.is_this_msg:\n                    <IND>break\n                <DED>return # OK\n        <DED><DED>raise HplSanityError(self._NO_REFS)\n\n    <DED>def __eq__(self, other):\n        <IND>if not isinstance(other, HplPredicate):\n            <IND>return False\n        <DED>return self.condition == other.condition\n\n    <DED>def __hash__(self):\n        <IND>return hash(self.condition)\n\n    <DED>def __str__(self):\n        <IND>return \"{{ {} }}\".format(self.condition)\n\n    <DED>def __repr__(self):\n        <IND>return \"{}({})\".format(type(self).__name__, repr(self.condition))\n\n\n<DED><DED>class HplVacuousTruth(HplAstObject):\n    <IND>__slots__ = ()\n\n    @property\n    def is_predicate(self):\n        <IND>return True\n\n    <DED>@property\n    def is_vacuous(self):\n        <IND>return True\n\n    <DED>@property\n    def is_true(self):\n        <IND>return True\n\n    <DED>def is_fully_typed(self):\n        <IND>return True\n\n    <DED>def negate(self):\n        <IND>return HplContradiction()\n\n    <DED>def join(self, other):\n        <IND>return other\n\n    <DED>def refine_types(self, rostype, **kwargs):\n        <IND>pass\n\n    <DED>def __eq__(self, other):\n        <IND>return isinstance(other, HplVacuousTruth)\n\n    <DED>def __hash__(self):\n        <IND>return 27644437\n\n    <DED>def __str__(self):\n        <IND>return \"{ True }\"\n\n    <DED>def __repr__(self):\n        <IND>return \"{}()\".format(type(self).__name__)\n\n\n<DED><DED>class HplContradiction(HplAstObject):\n    <IND>__slots__ = ()\n\n    @property\n    def is_predicate(self):\n        <IND>return True\n\n    <DED>@property\n    def is_vacuous(self):\n        <IND>return True\n\n    <DED>@property\n    def is_true(self):\n        <IND>return False\n\n    <DED>def is_fully_typed(self):\n        <IND>return True\n\n    <DED>def negate(self):\n        <IND>return HplVacuousTruth()\n\n    <DED>def join(self, other):\n        <IND>return self\n\n    <DED>def refine_types(self, rostype, **kwargs):\n        <IND>pass\n\n    <DED>def __eq__(self, other):\n        <IND>return isinstance(other, HplContradiction)\n\n    <DED>def __hash__(self):\n        <IND>return 65537\n\n    <DED>def __str__(self):\n        <IND>return \"{ False }\"\n\n    <DED>def __repr__(self):\n        <IND>return \"{}()\".format(type(self).__name__)\n\n\n###############################################################################\n# Type System\n###############################################################################\n\n# Bit Flags\n\n# These work as possible types for the expression.\n# An expression of unknown type would have \"any\" type (i.e., all flags on).\n# E.g., (T_NUM | T_BOOL) means the expression can be either a number or a bool.\n# Things like variables start with many possible types, and are refined as the\n# tree is built.\n\n<DED><DED>T_BOOL = 0x1\nT_NUM = 0x2\nT_STR = 0x4\nT_ARR = 0x8\n\nT_RAN = 0x10\nT_SET = 0x20\nT_MSG = 0x40\n\nT_ANY = T_BOOL | T_NUM | T_STR | T_ARR | T_RAN | T_SET | T_MSG\nT_COMP = T_ARR | T_RAN | T_SET\nT_PRIM = T_BOOL | T_NUM | T_STR\nT_ROS = T_BOOL | T_NUM | T_STR | T_ARR | T_MSG\nT_ITEM = T_BOOL | T_NUM | T_STR | T_MSG\n\n_TYPE_NAMES = {\n    T_BOOL: \"boolean\",\n    T_NUM: \"number\",\n    T_STR: \"string\",\n    T_ARR: \"array\",\n    T_RAN: \"range\",\n    T_SET: \"set\",\n    T_MSG: \"ROS msg\",\n}\n\ndef type_name(t):\n    <IND>if t in _TYPE_NAMES:\n        <IND>return _TYPE_NAMES[t]\n    <DED>ns = []\n    for key, name in _TYPE_NAMES.items():\n        <IND>if (t & key) != 0:\n            <IND>ns.append(name)\n    <DED><DED>return \" or \".join(ns)\n\n\n###############################################################################\n# Expressions\n###############################################################################\n\n<DED>class HplExpression(HplAstObject):\n    <IND>__slots__ = (\"types\",)\n\n    def __init__(self, types=T_ANY):\n        <IND>self.types = types\n\n    <DED>@property\n    def is_expression(self):\n        <IND>return True\n\n    <DED>@property\n    def is_value(self):\n        <IND>return False\n\n    <DED>@property\n    def is_operator(self):\n        <IND>return False\n\n    <DED>@property\n    def is_function_call(self):\n        <IND>return False\n\n    <DED>@property\n    def is_quantifier(self):\n        <IND>return False\n\n    <DED>@property\n    def is_accessor(self):\n        <IND>return False\n\n    <DED>@property\n    def can_be_bool(self):\n        <IND>return bool(self.types & T_BOOL)\n\n    <DED>@property\n    def can_be_number(self):\n        <IND>return bool(self.types & T_NUM)\n\n    <DED>@property\n    def can_be_string(self):\n        <IND>return bool(self.types & T_STR)\n\n    <DED>@property\n    def can_be_array(self):\n        <IND>return bool(self.types & T_ARR)\n\n    <DED>@property\n    def can_be_set(self):\n        <IND>return bool(self.types & T_SET)\n\n    <DED>@property\n    def can_be_range(self):\n        <IND>return bool(self.types & T_RAN)\n\n    <DED>@property\n    def can_be_msg(self):\n        <IND>return bool(self.types & T_MSG)\n\n    <DED>def can_be(self, t):\n        <IND>return bool(self.types & t)\n\n    <DED>def is_fully_typed(self):\n        <IND>for obj in self.iterate():\n            <IND>t = obj.types\n            if (not t) or bool(t & (t - 1)): # not a power of 2\n                <IND>return False\n        <DED><DED>return True\n\n    <DED>def cast(self, t):\n        <IND>r = self.types & t\n        if not r:\n            <IND>raise HplTypeError(\"expected ({}) but found ({}): {}\".format(\n                type_name(t), type_name(self.types), self))\n        <DED>self.types = r\n\n    <DED>def _type_check(self, x, t):\n        <IND>try:\n            <IND>x.cast(t)\n        <DED>except HplTypeError as e:\n            <IND>msg = \"Type error in expression '{}':\\n{}\".format(self, e)\n            raise HplTypeError(msg)\n\n    <DED><DED>def add_type(self, t):\n        <IND>self.types = self.types | t\n\n    <DED>def rem_type(self, t):\n        <IND>self.types = self.types & ~t\n        if not self.types:\n            <IND>raise HplTypeError(\"no types left: \" + str(self))\n\n\n###############################################################################\n# Quantifiers\n###############################################################################\n\n<DED><DED><DED>class HplQuantifier(HplExpression):\n    <IND>__slots__ = HplExpression.__slots__ + (\n        \"quantifier\", \"variable\", \"domain\", \"condition\")\n\n    _SET_REF = \"cannot reference quantified variable '{}' in the domain of:\\n{}\"\n    _MULTI_DEF = \"multiple definitions of variable '{}' in:\\n{}\"\n    _UNUSED = \"quantified variable '{}' is never used in:\\n{}\"\n\n    def __init__(self, qt, var, dom, p):\n        <IND>HplExpression.__init__(self, types=T_BOOL)\n        self.quantifier = qt # string\n        self.variable = var # string\n        self.domain = dom # HplExpression\n        self.condition = p # HplExpression\n        self._type_check(dom, T_COMP)\n        self._type_check(p, T_BOOL)\n        self._check_variables()\n\n    <DED>@property\n    def is_quantifier(self):\n        <IND>return True\n\n    <DED>@property\n    def is_universal(self):\n        <IND>return self.quantifier == \"forall\"\n\n    <DED>@property\n    def op(self):\n        <IND>return self.quantifier\n\n    <DED>@property\n    def x(self):\n        <IND>return self.variable\n\n    <DED>@property\n    def d(self):\n        <IND>return self.domain\n\n    <DED>@property\n    def p(self):\n        <IND>return self.condition\n\n    <DED>@property\n    def phi(self):\n        <IND>return self.condition\n\n    <DED>def children(self):\n        <IND>return (self.domain, self.condition)\n\n    <DED>def _check_variables(self):\n        <IND>types = self._check_domain_vars()\n        self._check_expression_vars(types)\n\n    <DED>def _check_domain_vars(self):\n        <IND>dom = self.domain\n        for obj in dom.iterate():\n            <IND>assert obj.is_expression\n            if obj.is_value and obj.is_variable:\n                <IND>assert not obj.is_defined\n                v = obj.name\n                if self.variable == v:\n                    <IND>raise HplSanityError(self._SET_REF.format(v, self))\n        <DED><DED><DED>if dom.is_value:\n            <IND>if dom.is_set or dom.is_range:\n                <IND>return dom.subtypes\n        <DED><DED>return T_PRIM\n\n    <DED>def _check_expression_vars(self, t):\n        <IND>uid = id(self)\n        used = 0\n        for obj in self.condition.iterate():\n            <IND>assert obj.is_expression\n            if obj.is_value and obj.is_variable:\n                <IND>v = obj.name\n                if self.variable == v:\n                    <IND>if obj.is_defined:\n                        <IND>assert obj.defined_at != uid\n                        raise HplSanityError(self._MULTI_DEF.format(v, self))\n                    <DED>obj.defined_at = uid\n                    self._type_check(obj, t)\n                    used += 1\n        <DED><DED><DED>if not used:\n            <IND>raise HplSanityError(self._UNUSED.format(self.variable, self))\n\n    <DED><DED>def __eq__(self, other):\n        <IND>if not isinstance(other, HplQuantifier):\n            <IND>return False\n        <DED>return (self.quantifier == other.quantifier\n                and self.variable == other.variable\n                and self.domain == other.domain\n                and self.condition == other.condition)\n\n    <DED>def __hash__(self):\n        <IND>h = 31 * hash(self.quantifier) + hash(self.variable)\n        h = 31 * h + hash(self.domain)\n        h = 31 * h + hash(self.condition)\n        return h\n"
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    def __str__(self):\n        return \" || \".join(str(chain) for chain in self.chains)\n\n    def __repr__(self):\n        return \"{}({})\".format(type(self).__name__, repr(self.chains))\n\n\n###############################################################################\n# Message Filters and Field Conditions\n###############################################################################\n\nclass HplMessageFilter(HplAstObject):\n    __slots__ = (\"conditions\", \"length_conditions\")\n\n    def __init__(self, conditions, len_conditions=None):\n        # conditions :: [HplFieldCondition]\n        self.conditions = conditions\n        if len_conditions is None:\n            self.length_conditions = []\n        else:\n            self.length_conditions = len_conditions\n\n    @property\n    def is_empty(self):\n        return not self.conditions and not self.length_conditions\n\n    def __eq__(self, other):\n        if not isinstance(other, HplMessageFilter):\n            return False\n        return (len(self.conditions) == len(other.conditions)\n                and all(c in other.conditions for c in self.conditions)\n                and len(self.length_conditions) == len(other.length_conditions)\n                and all(c in other.length_conditions\n                        for c in self.length_conditions))\n\n    def __hash__(self):\n        h = 1\n        for condition in self.conditions:\n            h = 31 * h + hash(condition)\n        for condition in self.length_conditions:\n            h = 31 * h + hash(condition)\n        return h\n\n    def __str__(self):\n        conditions = \", \".join(str(c)\n            for c in iterchain(self.conditions, self.length_conditions))\n        return \"{{{}}}\".format(conditions)\n\n    def __repr__(self):\n        return \"{}({}, len_conditions={})\".format(type(self).__name__,\n            repr(self.conditions), repr(self.length_conditions))\n\n\nclass HplFieldCondition(HplAstObject):\n    __slots__ = (\"field\", \"operator\", \"value\")\n\n    OP_EQ = \"=\"\n    OP_NEQ = \"!=\"\n    OP_LT = \"<\"\n    OP_LTE = \"<=\"\n    OP_GT = \">\"\n    OP_GTE = \">=\"\n    OP_IN = \"in\"\n    OP_NIN = \"not in\"\n\n    _NOT = {\n        OP_EQ: OP_NEQ,\n        OP_NEQ: OP_EQ,\n        OP_LT: OP_GTE,\n        OP_GT: OP_LTE,\n        OP_LTE: OP_GT,\n        OP_GTE: OP_LT,\n        OP_IN: OP_NIN,\n        OP_NIN: OP_IN\n    }\n\n    _INV = {\n        OP_EQ: OP_EQ,\n        OP_NEQ: OP_NEQ,\n        OP_LT: OP_GT,\n        OP_LTE: OP_GTE,\n        OP_GT: OP_LT,\n        OP_GTE: OP_LTE\n    }\n\n    def __init__(self, field_ref, op_token, hpl_value):\n        if not op_token in self._NOT:\n            raise ValueError(\"invalid operator token: \" + str(op_token))\n        self.field = field_ref # HplFieldReference\n        self.operator = op_token # string\n        self.value = hpl_value # HplValue\n\n    @property\n    def is_eq(self):\n        return self.operator == self.OP_EQ\n\n    @property\n    def is_neq(self):\n        return self.operator == self.OP_NEQ\n\n    @property\n    def is_lt(self):\n        return self.operator == self.OP_LT\n\n    @property\n    def is_lte(self):\n        return self.operator == self.OP_LTE\n\n    @property\n    def is_gt(self):\n        return self.operator == self.OP_GT\n\n    @property\n    def is_gte(self):\n        return self.operator == self.OP_GTE\n\n    @property\n    def is_in(self):\n        return self.operator == self.OP_IN\n\n    @property\n    def is_not_in(self):\n        return self.operator == self.OP_NIN\n\n    @property\n    def is_equality_test(self):\n        return self.operator == self.OP_EQ or self.operator == self.OP_NEQ\n\n    @property\n    def is_comparison_test(self):\n        return (self.operator == self.OP_LT or self.operator == self.OP_LTE\n            or self.operator == self.OP_GT or self.operator == self.OP_GTE)\n\n    @property\n    def is_inclusion_test(self):\n        return self.operator == self.OP_IN or self.operator == self.OP_NIN\n\n    @property\n    def requires_number(self):\n        return (self.operator == self.OP_LT or self.operator == self.OP_LTE\n                or self.operator == self.OP_GT or self.operator == self.OP_GTE\n                or (self.operator == self.OP_IN\n                    and isinstance(self.value, HplRange)))\n\n    @property\n    def is_invertible(self):\n        return self.operator in self._INV and self.value.is_reference\n\n    def negation(self):\n        return HplFieldCondition(\n            self.field, self._NOT[self.operator], self.value)\n\n    def inverted(self, alias):\n        if self.operator not in self._INV or not self.value.is_reference:\n            raise HplLogicError(\"impossible to invert: \" + str(self))\n        new_value = HplFieldReference(self.field.token, message=alias)\n        new_field = HplFieldReference(self.value.token, message=None)\n        new_op = self._INV[self.operator]\n        return HplFieldCondition(new_field, new_op, new_value)\n\n    # NOTE old, unused code that might be needed later\n    def __normalise_quantifiers(self):\n        #negate = False\n        #expr = self.field.clone()\n        #for field in expr.fields:\n        #    if field.index == NO_INDEX:\n        #        field.index = SOME_INDEX if negate else ALL_INDICES\n        #        negate = not negate\n        #    elif field.index == ALL_INDICES and negate:\n        #        field.index = SOME_INDEX\n        #    elif field.index == SOME_INDEX and negate:\n        #        field.index = ALL_INDICES\n        #op = self._NOT[self.operator] if negate else self.operator\n        #return HplMsgFieldCondition(expr, op, self.value)\n        pass\n\n    def __eq__(self, other):\n        if not isinstance(other, HplMsgFieldCondition):\n            return False\n        return (self.field == other.field\n                and self.operator == other.operator\n                and self.value == other.value)\n\n    def __hash__(self):\n        h = 31 * hash(self.field) + hash(self.operator)\n        return 31 * h + hash(self.value)\n\n    def __str__(self):\n        return \"{} {} {}\".format(self.field, self.operator, self.value)\n\n    def __repr__(self):\n        return \"{}({}, {}, {})\".format(type(self).__name__,\n            repr(self.field), repr(self.operator), repr(self.value))\n\n\n###############################################################################\n# Values and Field References\n###############################################################################\n\nclass HplValue(HplAstObject):\n    __slots__ = ()\n\n",
        "source_code_len": 6348,
        "target_code": "    def __str__(self):\n        a = str(self.operand1)\n        b = str(self.operand2)\n        if self.infix:\n            return \"({} {} {})\".format(a, self.operator, b)\n        else:\n            return \"{}({}, {})\".format(self.operator, a, b)\n\n    def __repr__(self):\n        return \"{}({}, {}, {})\".format(\n            type(self).__name__, repr(self.operator),\n            repr(self.operand1), repr(self.operand2))\n\n\nclass HplFunctionCall(HplExpression):\n    __slots__ = HplExpression.__slots__ + (\"function\", \"arguments\",)\n\n    # name: Input -> Output\n    _BUILTINS = {\n        \"abs\": (T_NUM, T_NUM),\n        \"bool\": (T_PRIM, T_BOOL),\n        \"int\": (T_PRIM, T_NUM),\n        \"float\": (T_PRIM, T_NUM),\n        \"str\": (T_PRIM, T_STR),\n        \"len\": (T_ARR, T_NUM),\n        \"max\": (T_ARR, T_NUM),\n        \"min\": (T_ARR, T_NUM),\n        \"sum\": (T_ARR, T_NUM),\n        \"prod\": (T_ARR, T_NUM),\n    }\n\n    def __init__(self, fun, args):\n        try:\n            tin, tout = self._BUILTINS[fun]\n        except KeyError:\n            raise HplTypeError(\"undefined function '{}'\".format(fun))\n        HplExpression.__init__(self, types=tout)\n        self.function = fun # string\n        self.arguments = args # [HplValue]\n        for arg in args:\n            self._type_check(arg, tin)\n\n    @property\n    def is_function_call(self):\n        return True\n\n    @property\n    def arity(self):\n        return len(self.arguments)\n\n    def children(self):\n        return self.arguments\n\n    def __eq__(self, other):\n        if not isinstance(other, HplFunctionCall):\n            return False\n        return (self.function == other.function\n                and self.arguments == other.arguments)\n\n    def __hash__(self):\n        return 31 * hash(self.function) + hash(self.arguments)\n\n    def __str__(self):\n        return \"{}({})\".format(self.function,\n            \", \".join(str(arg) for arg in self.arguments))\n\n    def __repr__(self):\n        return \"{}({}, {})\".format(\n            type(self).__name__, repr(self.function), repr(self.arguments))\n\n\n###############################################################################\n# Message Field Access\n###############################################################################\n\nclass HplFieldAccess(HplExpression):\n    __slots__ = HplExpression.__slots__ + (\"message\", \"field\", \"ros_type\")\n\n    def __init__(self, msg, field):\n        HplExpression.__init__(self, types=T_ROS)\n        self.message = msg # HplExpression\n        self.field = field # string\n        self.ros_type = None\n        self._type_check(msg, T_MSG)\n\n    @property\n    def is_accessor(self):\n        return True\n\n    @property\n    def is_field(self):\n        return True\n\n    @property\n    def is_indexed(self):\n        return False\n\n    def base_message(self):\n        obj = self\n        while obj.is_accessor:\n            obj = obj.message\n        assert obj.is_value\n        return obj\n\n    def children(self):\n        return (self.message,)\n\n    def __eq__(self, other):\n        if not isinstance(other, HplFieldAccess):\n            return False\n        return (self.message == other.message\n                and self.field == other.field)\n\n    def __hash__(self):\n        return 31 * hash(self.message) + hash(self.field)\n\n    def __str__(self):\n        msg = str(self.message)\n        if msg:\n            return \"{}.{}\".format(msg, self.field)\n        return str(self.field)\n\n    def __repr__(self):\n        return \"{}({}, {})\".format(\n            type(self).__name__, repr(self.message), repr(self.field))\n\n\nclass HplArrayAccess(HplExpression):\n    __slots__ = HplExpression.__slots__ + (\"array\", \"item\", \"ros_type\")\n\n    _MULTI_ARRAY = \"multi-dimensional array access: '{}[{}]'\"\n\n    def __init__(self, array, index):\n        if array.is_accessor and array.is_indexed:\n            raise HplTypeError(self._MULTI_ARRAY.format(array, index))\n        HplExpression.__init__(self, types=T_ITEM)\n        self.array = array # HplExpression\n        self.index = index # HplExpression\n        self.ros_type = None\n        self._type_check(array, T_ARR)\n        self._type_check(index, T_NUM)\n\n    @property\n    def is_accessor(self):\n        return True\n\n    @property\n    def is_field(self):\n        return False\n\n    @property\n    def is_indexed(self):\n        return True\n\n    @property\n    def message(self):\n        return self.array\n\n    def base_message(self):\n        obj = self\n        while obj.is_accessor:\n            obj = obj.message\n        assert obj.is_value\n        return obj\n\n    def children(self):\n        return (self.array, self.index)\n\n    def __eq__(self, other):\n        if not isinstance(other, HplArrayAccess):\n            return False\n        return (self.array == other.array\n                and self.index == other.index)\n\n    def __hash__(self):\n        return 31 * hash(self.array) + hash(self.index)\n\n    def __str__(self):\n        return \"{}[{}]\".format(self.array, self.index)\n\n    def __repr__(self):\n        return \"{}({}, {})\".format(\n            type(self).__name__, repr(self.array), repr(self.index))\n\n\n###############################################################################\n# Values\n###############################################################################\n\nclass HplValue(HplExpression):\n    __slots__ = HplExpression.__slots__\n\n    @property\n    def is_value(self):\n        return True\n\n",
        "target_code_len": 5359,
        "diff_format": "@@ -680,202 +1201,196 @@\n     def __str__(self):\n-        return \" || \".join(str(chain) for chain in self.chains)\n-\n-    def __repr__(self):\n-        return \"{}({})\".format(type(self).__name__, repr(self.chains))\n-\n-\n-###############################################################################\n-# Message Filters and Field Conditions\n-###############################################################################\n-\n-class HplMessageFilter(HplAstObject):\n-    __slots__ = (\"conditions\", \"length_conditions\")\n-\n-    def __init__(self, conditions, len_conditions=None):\n-        # conditions :: [HplFieldCondition]\n-        self.conditions = conditions\n-        if len_conditions is None:\n-            self.length_conditions = []\n+        a = str(self.operand1)\n+        b = str(self.operand2)\n+        if self.infix:\n+            return \"({} {} {})\".format(a, self.operator, b)\n         else:\n-            self.length_conditions = len_conditions\n-\n-    @property\n-    def is_empty(self):\n-        return not self.conditions and not self.length_conditions\n-\n-    def __eq__(self, other):\n-        if not isinstance(other, HplMessageFilter):\n+            return \"{}({}, {})\".format(self.operator, a, b)\n+\n+    def __repr__(self):\n+        return \"{}({}, {}, {})\".format(\n+            type(self).__name__, repr(self.operator),\n+            repr(self.operand1), repr(self.operand2))\n+\n+\n+class HplFunctionCall(HplExpression):\n+    __slots__ = HplExpression.__slots__ + (\"function\", \"arguments\",)\n+\n+    # name: Input -> Output\n+    _BUILTINS = {\n+        \"abs\": (T_NUM, T_NUM),\n+        \"bool\": (T_PRIM, T_BOOL),\n+        \"int\": (T_PRIM, T_NUM),\n+        \"float\": (T_PRIM, T_NUM),\n+        \"str\": (T_PRIM, T_STR),\n+        \"len\": (T_ARR, T_NUM),\n+        \"max\": (T_ARR, T_NUM),\n+        \"min\": (T_ARR, T_NUM),\n+        \"sum\": (T_ARR, T_NUM),\n+        \"prod\": (T_ARR, T_NUM),\n+    }\n+\n+    def __init__(self, fun, args):\n+        try:\n+            tin, tout = self._BUILTINS[fun]\n+        except KeyError:\n+            raise HplTypeError(\"undefined function '{}'\".format(fun))\n+        HplExpression.__init__(self, types=tout)\n+        self.function = fun # string\n+        self.arguments = args # [HplValue]\n+        for arg in args:\n+            self._type_check(arg, tin)\n+\n+    @property\n+    def is_function_call(self):\n+        return True\n+\n+    @property\n+    def arity(self):\n+        return len(self.arguments)\n+\n+    def children(self):\n+        return self.arguments\n+\n+    def __eq__(self, other):\n+        if not isinstance(other, HplFunctionCall):\n             return False\n-        return (len(self.conditions) == len(other.conditions)\n-                and all(c in other.conditions for c in self.conditions)\n-                and len(self.length_conditions) == len(other.length_conditions)\n-                and all(c in other.length_conditions\n-                        for c in self.length_conditions))\n-\n-    def __hash__(self):\n-        h = 1\n-        for condition in self.conditions:\n-            h = 31 * h + hash(condition)\n-        for condition in self.length_conditions:\n-            h = 31 * h + hash(condition)\n-        return h\n-\n-    def __str__(self):\n-        conditions = \", \".join(str(c)\n-            for c in iterchain(self.conditions, self.length_conditions))\n-        return \"{{{}}}\".format(conditions)\n-\n-    def __repr__(self):\n-        return \"{}({}, len_conditions={})\".format(type(self).__name__,\n-            repr(self.conditions), repr(self.length_conditions))\n-\n-\n-class HplFieldCondition(HplAstObject):\n-    __slots__ = (\"field\", \"operator\", \"value\")\n-\n-    OP_EQ = \"=\"\n-    OP_NEQ = \"!=\"\n-    OP_LT = \"<\"\n-    OP_LTE = \"<=\"\n-    OP_GT = \">\"\n-    OP_GTE = \">=\"\n-    OP_IN = \"in\"\n-    OP_NIN = \"not in\"\n-\n-    _NOT = {\n-        OP_EQ: OP_NEQ,\n-        OP_NEQ: OP_EQ,\n-        OP_LT: OP_GTE,\n-        OP_GT: OP_LTE,\n-        OP_LTE: OP_GT,\n-        OP_GTE: OP_LT,\n-        OP_IN: OP_NIN,\n-        OP_NIN: OP_IN\n-    }\n-\n-    _INV = {\n-        OP_EQ: OP_EQ,\n-        OP_NEQ: OP_NEQ,\n-        OP_LT: OP_GT,\n-        OP_LTE: OP_GTE,\n-        OP_GT: OP_LT,\n-        OP_GTE: OP_LTE\n-    }\n-\n-    def __init__(self, field_ref, op_token, hpl_value):\n-        if not op_token in self._NOT:\n-            raise ValueError(\"invalid operator token: \" + str(op_token))\n-        self.field = field_ref # HplFieldReference\n-        self.operator = op_token # string\n-        self.value = hpl_value # HplValue\n-\n-    @property\n-    def is_eq(self):\n-        return self.operator == self.OP_EQ\n-\n-    @property\n-    def is_neq(self):\n-        return self.operator == self.OP_NEQ\n-\n-    @property\n-    def is_lt(self):\n-        return self.operator == self.OP_LT\n-\n-    @property\n-    def is_lte(self):\n-        return self.operator == self.OP_LTE\n-\n-    @property\n-    def is_gt(self):\n-        return self.operator == self.OP_GT\n-\n-    @property\n-    def is_gte(self):\n-        return self.operator == self.OP_GTE\n-\n-    @property\n-    def is_in(self):\n-        return self.operator == self.OP_IN\n-\n-    @property\n-    def is_not_in(self):\n-        return self.operator == self.OP_NIN\n-\n-    @property\n-    def is_equality_test(self):\n-        return self.operator == self.OP_EQ or self.operator == self.OP_NEQ\n-\n-    @property\n-    def is_comparison_test(self):\n-        return (self.operator == self.OP_LT or self.operator == self.OP_LTE\n-            or self.operator == self.OP_GT or self.operator == self.OP_GTE)\n-\n-    @property\n-    def is_inclusion_test(self):\n-        return self.operator == self.OP_IN or self.operator == self.OP_NIN\n-\n-    @property\n-    def requires_number(self):\n-        return (self.operator == self.OP_LT or self.operator == self.OP_LTE\n-                or self.operator == self.OP_GT or self.operator == self.OP_GTE\n-                or (self.operator == self.OP_IN\n-                    and isinstance(self.value, HplRange)))\n-\n-    @property\n-    def is_invertible(self):\n-        return self.operator in self._INV and self.value.is_reference\n-\n-    def negation(self):\n-        return HplFieldCondition(\n-            self.field, self._NOT[self.operator], self.value)\n-\n-    def inverted(self, alias):\n-        if self.operator not in self._INV or not self.value.is_reference:\n-            raise HplLogicError(\"impossible to invert: \" + str(self))\n-        new_value = HplFieldReference(self.field.token, message=alias)\n-        new_field = HplFieldReference(self.value.token, message=None)\n-        new_op = self._INV[self.operator]\n-        return HplFieldCondition(new_field, new_op, new_value)\n-\n-    # NOTE old, unused code that might be needed later\n-    def __normalise_quantifiers(self):\n-        #negate = False\n-        #expr = self.field.clone()\n-        #for field in expr.fields:\n-        #    if field.index == NO_INDEX:\n-        #        field.index = SOME_INDEX if negate else ALL_INDICES\n-        #        negate = not negate\n-        #    elif field.index == ALL_INDICES and negate:\n-        #        field.index = SOME_INDEX\n-        #    elif field.index == SOME_INDEX and negate:\n-        #        field.index = ALL_INDICES\n-        #op = self._NOT[self.operator] if negate else self.operator\n-        #return HplMsgFieldCondition(expr, op, self.value)\n-        pass\n-\n-    def __eq__(self, other):\n-        if not isinstance(other, HplMsgFieldCondition):\n+        return (self.function == other.function\n+                and self.arguments == other.arguments)\n+\n+    def __hash__(self):\n+        return 31 * hash(self.function) + hash(self.arguments)\n+\n+    def __str__(self):\n+        return \"{}({})\".format(self.function,\n+            \", \".join(str(arg) for arg in self.arguments))\n+\n+    def __repr__(self):\n+        return \"{}({}, {})\".format(\n+            type(self).__name__, repr(self.function), repr(self.arguments))\n+\n+\n+###############################################################################\n+# Message Field Access\n+###############################################################################\n+\n+class HplFieldAccess(HplExpression):\n+    __slots__ = HplExpression.__slots__ + (\"message\", \"field\", \"ros_type\")\n+\n+    def __init__(self, msg, field):\n+        HplExpression.__init__(self, types=T_ROS)\n+        self.message = msg # HplExpression\n+        self.field = field # string\n+        self.ros_type = None\n+        self._type_check(msg, T_MSG)\n+\n+    @property\n+    def is_accessor(self):\n+        return True\n+\n+    @property\n+    def is_field(self):\n+        return True\n+\n+    @property\n+    def is_indexed(self):\n+        return False\n+\n+    def base_message(self):\n+        obj = self\n+        while obj.is_accessor:\n+            obj = obj.message\n+        assert obj.is_value\n+        return obj\n+\n+    def children(self):\n+        return (self.message,)\n+\n+    def __eq__(self, other):\n+        if not isinstance(other, HplFieldAccess):\n             return False\n-        return (self.field == other.field\n-                and self.operator == other.operator\n-                and self.value == other.value)\n-\n-    def __hash__(self):\n-        h = 31 * hash(self.field) + hash(self.operator)\n-        return 31 * h + hash(self.value)\n-\n-    def __str__(self):\n-        return \"{} {} {}\".format(self.field, self.operator, self.value)\n-\n-    def __repr__(self):\n-        return \"{}({}, {}, {})\".format(type(self).__name__,\n-            repr(self.field), repr(self.operator), repr(self.value))\n-\n-\n-###############################################################################\n-# Values and Field References\n-###############################################################################\n-\n-class HplValue(HplAstObject):\n-    __slots__ = ()\n+        return (self.message == other.message\n+                and self.field == other.field)\n+\n+    def __hash__(self):\n+        return 31 * hash(self.message) + hash(self.field)\n+\n+    def __str__(self):\n+        msg = str(self.message)\n+        if msg:\n+            return \"{}.{}\".format(msg, self.field)\n+        return str(self.field)\n+\n+    def __repr__(self):\n+        return \"{}({}, {})\".format(\n+            type(self).__name__, repr(self.message), repr(self.field))\n+\n+\n+class HplArrayAccess(HplExpression):\n+    __slots__ = HplExpression.__slots__ + (\"array\", \"item\", \"ros_type\")\n+\n+    _MULTI_ARRAY = \"multi-dimensional array access: '{}[{}]'\"\n+\n+    def __init__(self, array, index):\n+        if array.is_accessor and array.is_indexed:\n+            raise HplTypeError(self._MULTI_ARRAY.format(array, index))\n+        HplExpression.__init__(self, types=T_ITEM)\n+        self.array = array # HplExpression\n+        self.index = index # HplExpression\n+        self.ros_type = None\n+        self._type_check(array, T_ARR)\n+        self._type_check(index, T_NUM)\n+\n+    @property\n+    def is_accessor(self):\n+        return True\n+\n+    @property\n+    def is_field(self):\n+        return False\n+\n+    @property\n+    def is_indexed(self):\n+        return True\n+\n+    @property\n+    def message(self):\n+        return self.array\n+\n+    def base_message(self):\n+        obj = self\n+        while obj.is_accessor:\n+            obj = obj.message\n+        assert obj.is_value\n+        return obj\n+\n+    def children(self):\n+        return (self.array, self.index)\n+\n+    def __eq__(self, other):\n+        if not isinstance(other, HplArrayAccess):\n+            return False\n+        return (self.array == other.array\n+                and self.index == other.index)\n+\n+    def __hash__(self):\n+        return 31 * hash(self.array) + hash(self.index)\n+\n+    def __str__(self):\n+        return \"{}[{}]\".format(self.array, self.index)\n+\n+    def __repr__(self):\n+        return \"{}({}, {})\".format(\n+            type(self).__name__, repr(self.array), repr(self.index))\n+\n+\n+###############################################################################\n+# Values\n+###############################################################################\n+\n+class HplValue(HplExpression):\n+    __slots__ = HplExpression.__slots__\n+\n+    @property\n+    def is_value(self):\n+        return True\n \n",
        "source_code_with_indent": "    <DED>def __str__(self):\n        <IND>return \" || \".join(str(chain) for chain in self.chains)\n\n    <DED>def __repr__(self):\n        <IND>return \"{}({})\".format(type(self).__name__, repr(self.chains))\n\n\n###############################################################################\n# Message Filters and Field Conditions\n###############################################################################\n\n<DED><DED>class HplMessageFilter(HplAstObject):\n    <IND>__slots__ = (\"conditions\", \"length_conditions\")\n\n    def __init__(self, conditions, len_conditions=None):\n        # conditions :: [HplFieldCondition]\n        <IND>self.conditions = conditions\n        if len_conditions is None:\n            <IND>self.length_conditions = []\n        <DED>else:\n            <IND>self.length_conditions = len_conditions\n\n    <DED><DED>@property\n    def is_empty(self):\n        <IND>return not self.conditions and not self.length_conditions\n\n    <DED>def __eq__(self, other):\n        <IND>if not isinstance(other, HplMessageFilter):\n            <IND>return False\n        <DED>return (len(self.conditions) == len(other.conditions)\n                and all(c in other.conditions for c in self.conditions)\n                and len(self.length_conditions) == len(other.length_conditions)\n                and all(c in other.length_conditions\n                        for c in self.length_conditions))\n\n    <DED>def __hash__(self):\n        <IND>h = 1\n        for condition in self.conditions:\n            <IND>h = 31 * h + hash(condition)\n        <DED>for condition in self.length_conditions:\n            <IND>h = 31 * h + hash(condition)\n        <DED>return h\n\n    <DED>def __str__(self):\n        <IND>conditions = \", \".join(str(c)\n            for c in iterchain(self.conditions, self.length_conditions))\n        return \"{{{}}}\".format(conditions)\n\n    <DED>def __repr__(self):\n        <IND>return \"{}({}, len_conditions={})\".format(type(self).__name__,\n            repr(self.conditions), repr(self.length_conditions))\n\n\n<DED><DED>class HplFieldCondition(HplAstObject):\n    <IND>__slots__ = (\"field\", \"operator\", \"value\")\n\n    OP_EQ = \"=\"\n    OP_NEQ = \"!=\"\n    OP_LT = \"<\"\n    OP_LTE = \"<=\"\n    OP_GT = \">\"\n    OP_GTE = \">=\"\n    OP_IN = \"in\"\n    OP_NIN = \"not in\"\n\n    _NOT = {\n        OP_EQ: OP_NEQ,\n        OP_NEQ: OP_EQ,\n        OP_LT: OP_GTE,\n        OP_GT: OP_LTE,\n        OP_LTE: OP_GT,\n        OP_GTE: OP_LT,\n        OP_IN: OP_NIN,\n        OP_NIN: OP_IN\n    }\n\n    _INV = {\n        OP_EQ: OP_EQ,\n        OP_NEQ: OP_NEQ,\n        OP_LT: OP_GT,\n        OP_LTE: OP_GTE,\n        OP_GT: OP_LT,\n        OP_GTE: OP_LTE\n    }\n\n    def __init__(self, field_ref, op_token, hpl_value):\n        <IND>if not op_token in self._NOT:\n            <IND>raise ValueError(\"invalid operator token: \" + str(op_token))\n        <DED>self.field = field_ref # HplFieldReference\n        self.operator = op_token # string\n        self.value = hpl_value # HplValue\n\n    <DED>@property\n    def is_eq(self):\n        <IND>return self.operator == self.OP_EQ\n\n    <DED>@property\n    def is_neq(self):\n        <IND>return self.operator == self.OP_NEQ\n\n    <DED>@property\n    def is_lt(self):\n        <IND>return self.operator == self.OP_LT\n\n    <DED>@property\n    def is_lte(self):\n        <IND>return self.operator == self.OP_LTE\n\n    <DED>@property\n    def is_gt(self):\n        <IND>return self.operator == self.OP_GT\n\n    <DED>@property\n    def is_gte(self):\n        <IND>return self.operator == self.OP_GTE\n\n    <DED>@property\n    def is_in(self):\n        <IND>return self.operator == self.OP_IN\n\n    <DED>@property\n    def is_not_in(self):\n        <IND>return self.operator == self.OP_NIN\n\n    <DED>@property\n    def is_equality_test(self):\n        <IND>return self.operator == self.OP_EQ or self.operator == self.OP_NEQ\n\n    <DED>@property\n    def is_comparison_test(self):\n        <IND>return (self.operator == self.OP_LT or self.operator == self.OP_LTE\n            or self.operator == self.OP_GT or self.operator == self.OP_GTE)\n\n    <DED>@property\n    def is_inclusion_test(self):\n        <IND>return self.operator == self.OP_IN or self.operator == self.OP_NIN\n\n    <DED>@property\n    def requires_number(self):\n        <IND>return (self.operator == self.OP_LT or self.operator == self.OP_LTE\n                or self.operator == self.OP_GT or self.operator == self.OP_GTE\n                or (self.operator == self.OP_IN\n                    and isinstance(self.value, HplRange)))\n\n    <DED>@property\n    def is_invertible(self):\n        <IND>return self.operator in self._INV and self.value.is_reference\n\n    <DED>def negation(self):\n        <IND>return HplFieldCondition(\n            self.field, self._NOT[self.operator], self.value)\n\n    <DED>def inverted(self, alias):\n        <IND>if self.operator not in self._INV or not self.value.is_reference:\n            <IND>raise HplLogicError(\"impossible to invert: \" + str(self))\n        <DED>new_value = HplFieldReference(self.field.token, message=alias)\n        new_field = HplFieldReference(self.value.token, message=None)\n        new_op = self._INV[self.operator]\n        return HplFieldCondition(new_field, new_op, new_value)\n\n    # NOTE old, unused code that might be needed later\n    <DED>def __normalise_quantifiers(self):\n        #negate = False\n        #expr = self.field.clone()\n        #for field in expr.fields:\n        #    if field.index == NO_INDEX:\n        #        field.index = SOME_INDEX if negate else ALL_INDICES\n        #        negate = not negate\n        #    elif field.index == ALL_INDICES and negate:\n        #        field.index = SOME_INDEX\n        #    elif field.index == SOME_INDEX and negate:\n        #        field.index = ALL_INDICES\n        #op = self._NOT[self.operator] if negate else self.operator\n        #return HplMsgFieldCondition(expr, op, self.value)\n        <IND>pass\n\n    <DED>def __eq__(self, other):\n        <IND>if not isinstance(other, HplMsgFieldCondition):\n            <IND>return False\n        <DED>return (self.field == other.field\n                and self.operator == other.operator\n                and self.value == other.value)\n\n    <DED>def __hash__(self):\n        <IND>h = 31 * hash(self.field) + hash(self.operator)\n        return 31 * h + hash(self.value)\n\n    <DED>def __str__(self):\n        <IND>return \"{} {} {}\".format(self.field, self.operator, self.value)\n\n    <DED>def __repr__(self):\n        <IND>return \"{}({}, {}, {})\".format(type(self).__name__,\n            repr(self.field), repr(self.operator), repr(self.value))\n\n\n###############################################################################\n# Values and Field References\n###############################################################################\n\n<DED><DED>class HplValue(HplAstObject):\n    <IND>__slots__ = ()\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    <DED>def __str__(self):\n        <IND>a = str(self.operand1)\n        b = str(self.operand2)\n        if self.infix:\n            <IND>return \"({} {} {})\".format(a, self.operator, b)\n        <DED>else:\n            <IND>return \"{}({}, {})\".format(self.operator, a, b)\n\n    <DED><DED>def __repr__(self):\n        <IND>return \"{}({}, {}, {})\".format(\n            type(self).__name__, repr(self.operator),\n            repr(self.operand1), repr(self.operand2))\n\n\n<DED><DED>class HplFunctionCall(HplExpression):\n    <IND>__slots__ = HplExpression.__slots__ + (\"function\", \"arguments\",)\n\n    # name: Input -> Output\n    _BUILTINS = {\n        \"abs\": (T_NUM, T_NUM),\n        \"bool\": (T_PRIM, T_BOOL),\n        \"int\": (T_PRIM, T_NUM),\n        \"float\": (T_PRIM, T_NUM),\n        \"str\": (T_PRIM, T_STR),\n        \"len\": (T_ARR, T_NUM),\n        \"max\": (T_ARR, T_NUM),\n        \"min\": (T_ARR, T_NUM),\n        \"sum\": (T_ARR, T_NUM),\n        \"prod\": (T_ARR, T_NUM),\n    }\n\n    def __init__(self, fun, args):\n        <IND>try:\n            <IND>tin, tout = self._BUILTINS[fun]\n        <DED>except KeyError:\n            <IND>raise HplTypeError(\"undefined function '{}'\".format(fun))\n        <DED>HplExpression.__init__(self, types=tout)\n        self.function = fun # string\n        self.arguments = args # [HplValue]\n        for arg in args:\n            <IND>self._type_check(arg, tin)\n\n    <DED><DED>@property\n    def is_function_call(self):\n        <IND>return True\n\n    <DED>@property\n    def arity(self):\n        <IND>return len(self.arguments)\n\n    <DED>def children(self):\n        <IND>return self.arguments\n\n    <DED>def __eq__(self, other):\n        <IND>if not isinstance(other, HplFunctionCall):\n            <IND>return False\n        <DED>return (self.function == other.function\n                and self.arguments == other.arguments)\n\n    <DED>def __hash__(self):\n        <IND>return 31 * hash(self.function) + hash(self.arguments)\n\n    <DED>def __str__(self):\n        <IND>return \"{}({})\".format(self.function,\n            \", \".join(str(arg) for arg in self.arguments))\n\n    <DED>def __repr__(self):\n        <IND>return \"{}({}, {})\".format(\n            type(self).__name__, repr(self.function), repr(self.arguments))\n\n\n###############################################################################\n# Message Field Access\n###############################################################################\n\n<DED><DED>class HplFieldAccess(HplExpression):\n    <IND>__slots__ = HplExpression.__slots__ + (\"message\", \"field\", \"ros_type\")\n\n    def __init__(self, msg, field):\n        <IND>HplExpression.__init__(self, types=T_ROS)\n        self.message = msg # HplExpression\n        self.field = field # string\n        self.ros_type = None\n        self._type_check(msg, T_MSG)\n\n    <DED>@property\n    def is_accessor(self):\n        <IND>return True\n\n    <DED>@property\n    def is_field(self):\n        <IND>return True\n\n    <DED>@property\n    def is_indexed(self):\n        <IND>return False\n\n    <DED>def base_message(self):\n        <IND>obj = self\n        while obj.is_accessor:\n            <IND>obj = obj.message\n        <DED>assert obj.is_value\n        return obj\n\n    <DED>def children(self):\n        <IND>return (self.message,)\n\n    <DED>def __eq__(self, other):\n        <IND>if not isinstance(other, HplFieldAccess):\n            <IND>return False\n        <DED>return (self.message == other.message\n                and self.field == other.field)\n\n    <DED>def __hash__(self):\n        <IND>return 31 * hash(self.message) + hash(self.field)\n\n    <DED>def __str__(self):\n        <IND>msg = str(self.message)\n        if msg:\n            <IND>return \"{}.{}\".format(msg, self.field)\n        <DED>return str(self.field)\n\n    <DED>def __repr__(self):\n        <IND>return \"{}({}, {})\".format(\n            type(self).__name__, repr(self.message), repr(self.field))\n\n\n<DED><DED>class HplArrayAccess(HplExpression):\n    <IND>__slots__ = HplExpression.__slots__ + (\"array\", \"item\", \"ros_type\")\n\n    _MULTI_ARRAY = \"multi-dimensional array access: '{}[{}]'\"\n\n    def __init__(self, array, index):\n        <IND>if array.is_accessor and array.is_indexed:\n            <IND>raise HplTypeError(self._MULTI_ARRAY.format(array, index))\n        <DED>HplExpression.__init__(self, types=T_ITEM)\n        self.array = array # HplExpression\n        self.index = index # HplExpression\n        self.ros_type = None\n        self._type_check(array, T_ARR)\n        self._type_check(index, T_NUM)\n\n    <DED>@property\n    def is_accessor(self):\n        <IND>return True\n\n    <DED>@property\n    def is_field(self):\n        <IND>return False\n\n    <DED>@property\n    def is_indexed(self):\n        <IND>return True\n\n    <DED>@property\n    def message(self):\n        <IND>return self.array\n\n    <DED>def base_message(self):\n        <IND>obj = self\n        while obj.is_accessor:\n            <IND>obj = obj.message\n        <DED>assert obj.is_value\n        return obj\n\n    <DED>def children(self):\n        <IND>return (self.array, self.index)\n\n    <DED>def __eq__(self, other):\n        <IND>if not isinstance(other, HplArrayAccess):\n            <IND>return False\n        <DED>return (self.array == other.array\n                and self.index == other.index)\n\n    <DED>def __hash__(self):\n        <IND>return 31 * hash(self.array) + hash(self.index)\n\n    <DED>def __str__(self):\n        <IND>return \"{}[{}]\".format(self.array, self.index)\n\n    <DED>def __repr__(self):\n        <IND>return \"{}({}, {})\".format(\n            type(self).__name__, repr(self.array), repr(self.index))\n\n\n###############################################################################\n# Values\n###############################################################################\n\n<DED><DED>class HplValue(HplExpression):\n    <IND>__slots__ = HplExpression.__slots__\n\n    @property\n    def is_value(self):\n        <IND>return True\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  }
]